commit 755dfcbca83710fa967d0efa7c5bb601f871a747
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Tue May 19 13:25:17 2020 -0700

    Bluetooth: Fix assuming EIR flags can result in SSP authentication
    
    EIR flags should just hint if SSP may be supported but we shall verify
    this with use of the actual features as the SSP bits may be disabled in
    the lower layers which would result in legacy authentication to be
    used.
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 07c34c55fc50..307800fd18e6 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -225,8 +225,6 @@ static void hci_acl_create_connection(struct hci_conn *conn)
 		}
 
 		memcpy(conn->dev_class, ie->data.dev_class, 3);
-		if (ie->data.ssp_mode > 0)
-			set_bit(HCI_CONN_SSP_ENABLED, &conn->flags);
 	}
 
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);

commit 1f8330ea1692c9c490b1e566e31d96d8cef99dd8
Author: Sathish Narsimman <nsathish41@gmail.com>
Date:   Fri Apr 3 21:43:58 2020 +0200

    Bluetooth: add support to notify using SCO air mode
    
    notifying using HCI_NOTIFY_CONN_ADD for SCO connection is generic in
    case of mSBC audio. To differntiate SCO air mode introducing
    HCI_NOTIFY_ENABLE_SCO_CVSD and HCI_NOTIFY_ENABLE_SCO_TRANSP.
    
    Signed-off-by: Sathish Narsimman <sathish.narasimman@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e245bc155cc2..07c34c55fc50 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -122,8 +122,18 @@ static void hci_conn_cleanup(struct hci_conn *conn)
 
 	hci_conn_hash_del(hdev, conn);
 
-	if (hdev->notify)
-		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
+	if (conn->type == SCO_LINK || conn->type == ESCO_LINK) {
+		switch (conn->setting & SCO_AIRMODE_MASK) {
+		case SCO_AIRMODE_CVSD:
+		case SCO_AIRMODE_TRANSP:
+			if (hdev->notify)
+				hdev->notify(hdev, HCI_NOTIFY_DISABLE_SCO);
+			break;
+		}
+	} else {
+		if (hdev->notify)
+			hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
+	}
 
 	hci_conn_del_sysfs(conn);
 
@@ -577,8 +587,15 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,
 	hci_dev_hold(hdev);
 
 	hci_conn_hash_add(hdev, conn);
-	if (hdev->notify)
-		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
+
+	/* The SCO and eSCO connections will only be notified when their
+	 * setup has been completed. This is different to ACL links which
+	 * can be notified right away.
+	 */
+	if (conn->type != SCO_LINK && conn->type != ESCO_LINK) {
+		if (hdev->notify)
+			hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
+	}
 
 	hci_conn_init_sysfs(conn);
 

commit c3bed4de5d0671426d047d9b58b140d6a9114c83
Author: Sathish Narsimman <nsathish41@gmail.com>
Date:   Mon Feb 24 10:53:40 2020 +0530

    Bluetooth: During le_conn_timeout disable EXT_ADV
    
    Disabling LE_LEGACY_ADV when LE_EXT_ADV is enabled causes 'command
    disallowed . This patch fixes that issue and disables EXT_ADV if
    enabled.
    
    Signed-off-by: Sathish Narsimman <sathish.narasimman@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 2731f0ad2a90..e245bc155cc2 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -467,6 +467,23 @@ static void hci_conn_auto_accept(struct work_struct *work)
 		     &conn->dst);
 }
 
+static void le_disable_advertising(struct hci_dev *hdev)
+{
+	if (ext_adv_capable(hdev)) {
+		struct hci_cp_le_set_ext_adv_enable cp;
+
+		cp.enable = 0x00;
+		cp.num_of_sets = 0x00;
+
+		hci_send_cmd(hdev, HCI_OP_LE_SET_EXT_ADV_ENABLE, sizeof(cp),
+			     &cp);
+	} else {
+		u8 enable = 0x00;
+		hci_send_cmd(hdev, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),
+			     &enable);
+	}
+}
+
 static void le_conn_timeout(struct work_struct *work)
 {
 	struct hci_conn *conn = container_of(work, struct hci_conn,
@@ -481,9 +498,8 @@ static void le_conn_timeout(struct work_struct *work)
 	 * (which doesn't have a timeout of its own).
 	 */
 	if (conn->role == HCI_ROLE_SLAVE) {
-		u8 enable = 0x00;
-		hci_send_cmd(hdev, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),
-			     &enable);
+		/* Disable LE Advertising */
+		le_disable_advertising(hdev);
 		hci_le_conn_failed(conn, HCI_ERROR_ADVERTISING_TIMEOUT);
 		return;
 	}

commit a9e45698b37d4235ec98b5c0327de59759cb2ef2
Author: Sathish Narsimman <nsathish41@gmail.com>
Date:   Mon Feb 24 11:02:24 2020 +0530

    Bluetooth: Remove adv set for directed advertising
    
    Extended advertising Data is set during bluetooth initialization
    by default which causes InvalidHCICommandParameters when setting
    Extended advertising parameters.
    
    As per Core Spec 5.2 Vol 2, PART E, Sec 7.8.53, for
    advertising_event_property LE_LEGACY_ADV_DIRECT_IND does not
    supports advertising data when the advertising set already
    contains some, the controller shall return erroc code
    'InvalidHCICommandParameters(0x12).
    
    So it is required to remove adv set for handle 0x00. since we use
    instance 0 for directed adv.
    
    Signed-off-by: Sathish Narsimman <sathish.narasimman@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a582c676e584..2731f0ad2a90 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -898,6 +898,16 @@ static void hci_req_directed_advertising(struct hci_request *req,
 		cp.peer_addr_type = conn->dst_type;
 		bacpy(&cp.peer_addr, &conn->dst);
 
+		/* As per Core Spec 5.2 Vol 2, PART E, Sec 7.8.53, for
+		 * advertising_event_property LE_LEGACY_ADV_DIRECT_IND
+		 * does not supports advertising data when the advertising set already
+		 * contains some, the controller shall return erroc code 'Invalid
+		 * HCI Command Parameters(0x12).
+		 * So it is required to remove adv set for handle 0x00. since we use
+		 * instance 0 for directed adv.
+		 */
+		hci_req_add(req, HCI_OP_LE_REMOVE_ADV_SET, sizeof(cp.handle), &cp.handle);
+
 		hci_req_add(req, HCI_OP_LE_SET_EXT_ADV_PARAMS, sizeof(cp), &cp);
 
 		if (own_addr_type == ADDR_LE_DEV_RANDOM &&

commit 05bd80a10411c70b5cc5cf31e0a6d2fc054a7ff0
Author: Sathish Narsimman <nsathish41@gmail.com>
Date:   Mon Feb 17 14:37:44 2020 +0530

    Bluetooth: Disable Extended Adv if enabled
    
    Disabling LEGACY_ADV when EXT_ADV is enabled causes
    'command disallowed' during DIRECTED_ADV. This Patch fixes this
    issue.
    
    Signed-off-by: Sathish Narsimman <sathish.narasimman@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 65fa44cbe514..a582c676e584 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1029,11 +1029,8 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	 * anyway have to disable it in order to start directed
 	 * advertising.
 	 */
-	if (hci_dev_test_flag(hdev, HCI_LE_ADV)) {
-		u8 enable = 0x00;
-		hci_req_add(&req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),
-			    &enable);
-	}
+	if (hci_dev_test_flag(hdev, HCI_LE_ADV))
+		 __hci_req_disable_advertising(&req);
 
 	/* If requested to connect as slave use directed advertising */
 	if (conn->role == HCI_ROLE_SLAVE) {

commit eab2404ba798a8efda2a970f44071c3406d94e57
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Fri Feb 14 10:08:57 2020 -0800

    Bluetooth: Add BT_PHY socket option
    
    This adds BT_PHY socket option (read-only) which can be used to read
    the PHYs in use by the underline connection.
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 87691404d0c6..65fa44cbe514 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1725,3 +1725,110 @@ struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle)
 
 	return hchan;
 }
+
+u32 hci_conn_get_phy(struct hci_conn *conn)
+{
+	u32 phys = 0;
+
+	hci_dev_lock(conn->hdev);
+
+	/* BLUETOOTH CORE SPECIFICATION Version 5.2 | Vol 2, Part B page 471:
+	 * Table 6.2: Packets defined for synchronous, asynchronous, and
+	 * CSB logical transport types.
+	 */
+	switch (conn->type) {
+	case SCO_LINK:
+		/* SCO logical transport (1 Mb/s):
+		 * HV1, HV2, HV3 and DV.
+		 */
+		phys |= BT_PHY_BR_1M_1SLOT;
+
+		break;
+
+	case ACL_LINK:
+		/* ACL logical transport (1 Mb/s) ptt=0:
+		 * DH1, DM3, DH3, DM5 and DH5.
+		 */
+		phys |= BT_PHY_BR_1M_1SLOT;
+
+		if (conn->pkt_type & (HCI_DM3 | HCI_DH3))
+			phys |= BT_PHY_BR_1M_3SLOT;
+
+		if (conn->pkt_type & (HCI_DM5 | HCI_DH5))
+			phys |= BT_PHY_BR_1M_5SLOT;
+
+		/* ACL logical transport (2 Mb/s) ptt=1:
+		 * 2-DH1, 2-DH3 and 2-DH5.
+		 */
+		if (!(conn->pkt_type & HCI_2DH1))
+			phys |= BT_PHY_EDR_2M_1SLOT;
+
+		if (!(conn->pkt_type & HCI_2DH3))
+			phys |= BT_PHY_EDR_2M_3SLOT;
+
+		if (!(conn->pkt_type & HCI_2DH5))
+			phys |= BT_PHY_EDR_2M_5SLOT;
+
+		/* ACL logical transport (3 Mb/s) ptt=1:
+		 * 3-DH1, 3-DH3 and 3-DH5.
+		 */
+		if (!(conn->pkt_type & HCI_3DH1))
+			phys |= BT_PHY_EDR_3M_1SLOT;
+
+		if (!(conn->pkt_type & HCI_3DH3))
+			phys |= BT_PHY_EDR_3M_3SLOT;
+
+		if (!(conn->pkt_type & HCI_3DH5))
+			phys |= BT_PHY_EDR_3M_5SLOT;
+
+		break;
+
+	case ESCO_LINK:
+		/* eSCO logical transport (1 Mb/s): EV3, EV4 and EV5 */
+		phys |= BT_PHY_BR_1M_1SLOT;
+
+		if (!(conn->pkt_type & (ESCO_EV4 | ESCO_EV5)))
+			phys |= BT_PHY_BR_1M_3SLOT;
+
+		/* eSCO logical transport (2 Mb/s): 2-EV3, 2-EV5 */
+		if (!(conn->pkt_type & ESCO_2EV3))
+			phys |= BT_PHY_EDR_2M_1SLOT;
+
+		if (!(conn->pkt_type & ESCO_2EV5))
+			phys |= BT_PHY_EDR_2M_3SLOT;
+
+		/* eSCO logical transport (3 Mb/s): 3-EV3, 3-EV5 */
+		if (!(conn->pkt_type & ESCO_3EV3))
+			phys |= BT_PHY_EDR_3M_1SLOT;
+
+		if (!(conn->pkt_type & ESCO_3EV5))
+			phys |= BT_PHY_EDR_3M_3SLOT;
+
+		break;
+
+	case LE_LINK:
+		if (conn->le_tx_phy & HCI_LE_SET_PHY_1M)
+			phys |= BT_PHY_LE_1M_TX;
+
+		if (conn->le_rx_phy & HCI_LE_SET_PHY_1M)
+			phys |= BT_PHY_LE_1M_RX;
+
+		if (conn->le_tx_phy & HCI_LE_SET_PHY_2M)
+			phys |= BT_PHY_LE_2M_TX;
+
+		if (conn->le_rx_phy & HCI_LE_SET_PHY_2M)
+			phys |= BT_PHY_LE_2M_RX;
+
+		if (conn->le_tx_phy & HCI_LE_SET_PHY_CODED)
+			phys |= BT_PHY_LE_CODED_TX;
+
+		if (conn->le_rx_phy & HCI_LE_SET_PHY_CODED)
+			phys |= BT_PHY_LE_CODED_RX;
+
+		break;
+	}
+
+	hci_dev_unlock(conn->hdev);
+
+	return phys;
+}

commit d088337c38a5cd8f0230fbf2d514ff7672f9d0d3
Author: Navid Emamdoost <navid.emamdoost@gmail.com>
Date:   Thu Nov 21 14:20:36 2019 -0600

    Bluetooth: Fix memory leak in hci_connect_le_scan
    
    In the implementation of hci_connect_le_scan() when conn is added via
    hci_conn_add(), if hci_explicit_conn_params_set() fails the allocated
    memory for conn is leaked. Use hci_conn_del() to release it.
    
    Fixes: f75113a26008 ("Bluetooth: add hci_connect_le_scan")
    Signed-off-by: Navid Emamdoost <navid.emamdoost@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7ff92dd4c53c..87691404d0c6 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1176,8 +1176,10 @@ struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
 	if (!conn)
 		return ERR_PTR(-ENOMEM);
 
-	if (hci_explicit_conn_params_set(hdev, dst, dst_type) < 0)
+	if (hci_explicit_conn_params_set(hdev, dst, dst_type) < 0) {
+		hci_conn_del(conn);
 		return ERR_PTR(-EBUSY);
+	}
 
 	conn->state = BT_CONNECT;
 	set_bit(HCI_CONN_SCANNING, &conn->flags);

commit 4c371bb95cf06ded80df0e6139fdd77cee1d9a94
Author: Szymon Janc <szymon.janc@codecoup.pl>
Date:   Wed Oct 2 14:22:43 2019 +0200

    Bluetooth: Workaround directed advertising bug in Broadcom controllers
    
    It appears that some Broadcom controllers (eg BCM20702A0) reject LE Set
    Advertising Parameters command if advertising intervals provided are not
    within range for undirected and low duty directed advertising.
    
    Workaround this bug by populating min and max intervals with 'valid'
    values.
    
    < HCI Command: LE Set Advertising Parameters (0x08|0x0006) plen 15
            Min advertising interval: 0.000 msec (0x0000)
            Max advertising interval: 0.000 msec (0x0000)
            Type: Connectable directed - ADV_DIRECT_IND (high duty cycle) (0x01)
            Own address type: Public (0x00)
            Direct address type: Random (0x01)
            Direct address: E2:F0:7B:9F:DC:F4 (Static)
            Channel map: 37, 38, 39 (0x07)
            Filter policy: Allow Scan Request from Any, Allow Connect Request from Any (0x00)
    > HCI Event: Command Complete (0x0e) plen 4
          LE Set Advertising Parameters (0x08|0x0006) ncmd 1
            Status: Invalid HCI Command Parameters (0x12)
    
    Signed-off-by: Szymon Janc <szymon.janc@codecoup.pl>
    Tested-by: SÃ¶ren Beye <linux@hypfer.de>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ad5b0ac1f9ce..7ff92dd4c53c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -934,6 +934,14 @@ static void hci_req_directed_advertising(struct hci_request *req,
 			return;
 
 		memset(&cp, 0, sizeof(cp));
+
+		/* Some controllers might reject command if intervals are not
+		 * within range for undirected advertising.
+		 * BCM20702A0 is known to be affected by this.
+		 */
+		cp.min_interval = cpu_to_le16(0x0020);
+		cp.max_interval = cpu_to_le16(0x0020);
+
 		cp.type = LE_ADV_DIRECT_IND;
 		cp.own_address_type = own_addr_type;
 		cp.direct_addr_type = conn->dst_type;

commit 1d0fac2c38edb25067e8f69195e2f76b67a2717d
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Mon Jun 3 13:48:42 2019 +0300

    Bluetooth: Use controller sets when available
    
    This makes use of controller sets when using Extended Advertising
    feature thus offloading the scheduling to the controller.
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 17e5111daa11..ad5b0ac1f9ce 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -915,7 +915,7 @@ static void hci_req_directed_advertising(struct hci_request *req,
 				    sizeof(cp), &cp);
 		}
 
-		__hci_req_enable_ext_advertising(req);
+		__hci_req_enable_ext_advertising(req, 0x00);
 	} else {
 		struct hci_cp_le_set_adv_param cp;
 

commit 302975cba1a4244d84e645773c82edbcfae1875f
Author: Spoorthi Ravishankar Koppad <spoorthix.k@intel.com>
Date:   Fri Jun 21 14:51:56 2019 +0530

    Bluetooth: Add support for LE ping feature
    
    Changes made to add HCI Write Authenticated Payload timeout
    command for LE Ping feature.
    
    As per the Core Specification 5.0 Volume 2 Part E Section 7.3.94,
    the following code changes implements
    HCI Write Authenticated Payload timeout command for LE Ping feature.
    
    Signed-off-by: Spoorthi Ravishankar Koppad <spoorthix.k@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 15d1cb5aee18..17e5111daa11 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -520,6 +520,9 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,
 	set_bit(HCI_CONN_POWER_SAVE, &conn->flags);
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
 
+	/* Set Default Authenticated payload timeout to 30s */
+	conn->auth_payload_timeout = DEFAULT_AUTH_PAYLOAD_TIMEOUT;
+
 	if (conn->role == HCI_ROLE_MASTER)
 		conn->out = true;
 

commit 693cd8ce3f882524a5d06f7800dd8492411877b3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Jun 22 15:47:01 2019 +0200

    Bluetooth: Fix regression with minimum encryption key size alignment
    
    When trying to align the minimum encryption key size requirement for
    Bluetooth connections, it turns out doing this in a central location in
    the HCI connection handling code is not possible.
    
    Original Bluetooth version up to 2.0 used a security model where the
    L2CAP service would enforce authentication and encryption.  Starting
    with Bluetooth 2.1 and Secure Simple Pairing that model has changed into
    that the connection initiator is responsible for providing an encrypted
    ACL link before any L2CAP communication can happen.
    
    Now connecting Bluetooth 2.1 or later devices with Bluetooth 2.0 and
    before devices are causing a regression.  The encryption key size check
    needs to be moved out of the HCI connection handling into the L2CAP
    channel setup.
    
    To achieve this, the current check inside hci_conn_security() has been
    moved into l2cap_check_enc_key_size() helper function and then called
    from four decisions point inside L2CAP to cover all combinations of
    Secure Simple Pairing enabled devices and device using legacy pairing
    and legacy service security model.
    
    Fixes: d5bb334a8e17 ("Bluetooth: Align minimum encryption key size for LE and BR/EDR connections")
    Bugzilla: https://bugzilla.kernel.org/show_bug.cgi?id=203643
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable@vger.kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3cf0764d5793..15d1cb5aee18 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1276,14 +1276,6 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 	    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))
 		return 0;
 
-	/* The minimum encryption key size needs to be enforced by the
-	 * host stack before establishing any L2CAP connections. The
-	 * specification in theory allows a minimum of 1, but to align
-	 * BR/EDR and LE transports, a minimum of 7 is chosen.
-	 */
-	if (conn->enc_key_size < HCI_MIN_ENC_KEY_SIZE)
-		return 0;
-
 	return 1;
 }
 
@@ -1400,8 +1392,16 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type,
 		return 0;
 
 encrypt:
-	if (test_bit(HCI_CONN_ENCRYPT, &conn->flags))
+	if (test_bit(HCI_CONN_ENCRYPT, &conn->flags)) {
+		/* Ensure that the encryption key size has been read,
+		 * otherwise stall the upper layer responses.
+		 */
+		if (!conn->enc_key_size)
+			return 0;
+
+		/* Nothing else needed, all requirements are met */
 		return 1;
+	}
 
 	hci_conn_encrypt(conn);
 	return 0;

commit d5bb334a8e171b262e48f378bd2096c0ea458265
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Apr 24 22:19:17 2019 +0200

    Bluetooth: Align minimum encryption key size for LE and BR/EDR connections
    
    The minimum encryption key size for LE connections is 56 bits and to
    align LE with BR/EDR, enforce 56 bits of minimum encryption key size for
    BR/EDR connections as well.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Cc: stable@vger.kernel.org

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index bd4978ce8c45..3cf0764d5793 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1276,6 +1276,14 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 	    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))
 		return 0;
 
+	/* The minimum encryption key size needs to be enforced by the
+	 * host stack before establishing any L2CAP connections. The
+	 * specification in theory allows a minimum of 1, but to align
+	 * BR/EDR and LE transports, a minimum of 7 is chosen.
+	 */
+	if (conn->enc_key_size < HCI_MIN_ENC_KEY_SIZE)
+		return 0;
+
 	return 1;
 }
 

commit a73c046a2869048430c332a871a5b169f192c6c3
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Thu Jul 19 17:09:45 2018 +0530

    Bluetooth: Implement Set ADV set random address
    
    This basically sets the random address for the adv instance
    Random address can be set only if the instance is created which
    is done in Set ext adv param.
    
    Random address and rpa expire timer and flags have been added
    to adv instance which will be used when the respective
    instance is scheduled.
    
    This introduces a hci_get_random_address() which returns the
    own address type and random address (rpa or nrpa) based
    on the instance flags and hdev flags. New function is required
    since own address type should be known before setting adv params
    but address can be set only after setting params.
    
    < HCI Command: LE Set Advertising Set Random Address (0x08|0x0035) plen 7
            Advertising handle: 0x00
            Advertising random address: 3C:8E:56:9B:77:84 (OUI 3C-8E-56)
    > HCI Event: Command Complete (0x0e) plen 4
          LE Set Advertising Set Random Address (0x08|0x0035) ncmd 1
            Status: Success (0x00)
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5c37d383caa3..bd4978ce8c45 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -873,6 +873,14 @@ static void hci_req_directed_advertising(struct hci_request *req,
 
 	if (ext_adv_capable(hdev)) {
 		struct hci_cp_le_set_ext_adv_params cp;
+		bdaddr_t random_addr;
+
+		/* Set require_privacy to false so that the remote device has a
+		 * chance of identifying us.
+		 */
+		if (hci_get_random_address(hdev, false, conn_use_rpa(conn), NULL,
+					   &own_addr_type, &random_addr) < 0)
+			return;
 
 		memset(&cp, 0, sizeof(cp));
 
@@ -889,6 +897,21 @@ static void hci_req_directed_advertising(struct hci_request *req,
 
 		hci_req_add(req, HCI_OP_LE_SET_EXT_ADV_PARAMS, sizeof(cp), &cp);
 
+		if (own_addr_type == ADDR_LE_DEV_RANDOM &&
+		    bacmp(&random_addr, BDADDR_ANY) &&
+		    bacmp(&random_addr, &hdev->random_addr)) {
+			struct hci_cp_le_set_adv_set_rand_addr cp;
+
+			memset(&cp, 0, sizeof(cp));
+
+			cp.handle = 0;
+			bacpy(&cp.bdaddr, &random_addr);
+
+			hci_req_add(req,
+				    HCI_OP_LE_SET_ADV_SET_RAND_ADDR,
+				    sizeof(cp), &cp);
+		}
+
 		__hci_req_enable_ext_advertising(req);
 	} else {
 		struct hci_cp_le_set_adv_param cp;

commit 075e40b79f6d0aa1479701d2dd6dea3b78478d60
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Thu Jul 19 17:09:44 2018 +0530

    Bluetooth: Use ext adv for directed adv
    
    This patch does extended advertising for directed advertising
    if the controller supportes. Instance 0 is used for directed
    advertising.
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 64e828ad3951..5c37d383caa3 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -868,35 +868,58 @@ static void hci_req_directed_advertising(struct hci_request *req,
 					 struct hci_conn *conn)
 {
 	struct hci_dev *hdev = req->hdev;
-	struct hci_cp_le_set_adv_param cp;
 	u8 own_addr_type;
 	u8 enable;
 
-	/* Clear the HCI_LE_ADV bit temporarily so that the
-	 * hci_update_random_address knows that it's safe to go ahead
-	 * and write a new random address. The flag will be set back on
-	 * as soon as the SET_ADV_ENABLE HCI command completes.
-	 */
-	hci_dev_clear_flag(hdev, HCI_LE_ADV);
+	if (ext_adv_capable(hdev)) {
+		struct hci_cp_le_set_ext_adv_params cp;
 
-	/* Set require_privacy to false so that the remote device has a
-	 * chance of identifying us.
-	 */
-	if (hci_update_random_address(req, false, conn_use_rpa(conn),
-				      &own_addr_type) < 0)
-		return;
+		memset(&cp, 0, sizeof(cp));
 
-	memset(&cp, 0, sizeof(cp));
-	cp.type = LE_ADV_DIRECT_IND;
-	cp.own_address_type = own_addr_type;
-	cp.direct_addr_type = conn->dst_type;
-	bacpy(&cp.direct_addr, &conn->dst);
-	cp.channel_map = hdev->le_adv_channel_map;
+		cp.evt_properties = cpu_to_le16(LE_LEGACY_ADV_DIRECT_IND);
+		cp.own_addr_type = own_addr_type;
+		cp.channel_map = hdev->le_adv_channel_map;
+		cp.tx_power = HCI_TX_POWER_INVALID;
+		cp.primary_phy = HCI_ADV_PHY_1M;
+		cp.secondary_phy = HCI_ADV_PHY_1M;
+		cp.handle = 0; /* Use instance 0 for directed adv */
+		cp.own_addr_type = own_addr_type;
+		cp.peer_addr_type = conn->dst_type;
+		bacpy(&cp.peer_addr, &conn->dst);
+
+		hci_req_add(req, HCI_OP_LE_SET_EXT_ADV_PARAMS, sizeof(cp), &cp);
 
-	hci_req_add(req, HCI_OP_LE_SET_ADV_PARAM, sizeof(cp), &cp);
+		__hci_req_enable_ext_advertising(req);
+	} else {
+		struct hci_cp_le_set_adv_param cp;
+
+		/* Clear the HCI_LE_ADV bit temporarily so that the
+		 * hci_update_random_address knows that it's safe to go ahead
+		 * and write a new random address. The flag will be set back on
+		 * as soon as the SET_ADV_ENABLE HCI command completes.
+		 */
+		hci_dev_clear_flag(hdev, HCI_LE_ADV);
 
-	enable = 0x01;
-	hci_req_add(req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable), &enable);
+		/* Set require_privacy to false so that the remote device has a
+		 * chance of identifying us.
+		 */
+		if (hci_update_random_address(req, false, conn_use_rpa(conn),
+					      &own_addr_type) < 0)
+			return;
+
+		memset(&cp, 0, sizeof(cp));
+		cp.type = LE_ADV_DIRECT_IND;
+		cp.own_address_type = own_addr_type;
+		cp.direct_addr_type = conn->dst_type;
+		bacpy(&cp.direct_addr, &conn->dst);
+		cp.channel_map = hdev->le_adv_channel_map;
+
+		hci_req_add(req, HCI_OP_LE_SET_ADV_PARAM, sizeof(cp), &cp);
+
+		enable = 0x01;
+		hci_req_add(req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),
+			    &enable);
+	}
 
 	conn->state = BT_CONNECT;
 }

commit 4e6e99e9336ce863449c2570dc1d1d6c2c886ac0
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Thu Jul 19 17:09:39 2018 +0530

    Bluetooth: Use selected PHYs in extended connect
    
    Use the selected PHYs by Set PHY Configuration management command
    in extended create connection.
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index cc967ca67962..64e828ad3951 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -748,6 +748,26 @@ static bool conn_use_rpa(struct hci_conn *conn)
 	return hci_dev_test_flag(hdev, HCI_PRIVACY);
 }
 
+static void set_ext_conn_params(struct hci_conn *conn,
+				struct hci_cp_le_ext_conn_param *p)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	memset(p, 0, sizeof(*p));
+
+	/* Set window to be the same value as the interval to
+	 * enable continuous scanning.
+	 */
+	p->scan_interval = cpu_to_le16(hdev->le_scan_interval);
+	p->scan_window = p->scan_interval;
+	p->conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
+	p->conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
+	p->conn_latency = cpu_to_le16(conn->le_conn_latency);
+	p->supervision_timeout = cpu_to_le16(conn->le_supv_timeout);
+	p->min_ce_len = cpu_to_le16(0x0000);
+	p->max_ce_len = cpu_to_le16(0x0000);
+}
+
 static void hci_req_add_le_create_conn(struct hci_request *req,
 				       struct hci_conn *conn,
 				       bdaddr_t *direct_rpa)
@@ -777,8 +797,8 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	if (use_ext_conn(hdev)) {
 		struct hci_cp_le_ext_create_conn *cp;
 		struct hci_cp_le_ext_conn_param *p;
-		/* As of now only LE 1M is supported */
-		u8 data[sizeof(*cp) + sizeof(*p) * 1];
+		u8 data[sizeof(*cp) + sizeof(*p) * 3];
+		u32 plen;
 
 		cp = (void *) data;
 		p = (void *) cp->data;
@@ -788,24 +808,33 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 		bacpy(&cp->peer_addr, &conn->dst);
 		cp->peer_addr_type = conn->dst_type;
 		cp->own_addr_type = own_addr_type;
-		cp->phys = LE_SCAN_PHY_1M;
 
-		memset(p, 0, sizeof(*p));
+		plen = sizeof(*cp);
 
-		/* Set window to be the same value as the interval to enable
-		 * continuous scanning.
-		 */
+		if (scan_1m(hdev)) {
+			cp->phys |= LE_SCAN_PHY_1M;
+			set_ext_conn_params(conn, p);
+
+			p++;
+			plen += sizeof(*p);
+		}
+
+		if (scan_2m(hdev)) {
+			cp->phys |= LE_SCAN_PHY_2M;
+			set_ext_conn_params(conn, p);
 
-		p->scan_interval = cpu_to_le16(hdev->le_scan_interval);
-		p->scan_window = p->scan_interval;
-		p->conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
-		p->conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
-		p->conn_latency = cpu_to_le16(conn->le_conn_latency);
-		p->supervision_timeout = cpu_to_le16(conn->le_supv_timeout);
-		p->min_ce_len = cpu_to_le16(0x0000);
-		p->max_ce_len = cpu_to_le16(0x0000);
+			p++;
+			plen += sizeof(*p);
+		}
+
+		if (scan_coded(hdev)) {
+			cp->phys |= LE_SCAN_PHY_CODED;
+			set_ext_conn_params(conn, p);
+
+			plen += sizeof(*p);
+		}
 
-		hci_req_add(req, HCI_OP_LE_EXT_CREATE_CONN, sizeof(data), data);
+		hci_req_add(req, HCI_OP_LE_EXT_CREATE_CONN, plen, data);
 
 	} else {
 		struct hci_cp_le_create_conn cp;

commit 4d94f95d30c8fbfe86068e9abed110974d697cf5
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Fri Jul 6 22:50:32 2018 +0200

    Bluetooth: Use extended LE Connection if supported
    
    This implements extended LE craete connection and enhanced
    LE conn complete event if the controller supports.
    
    For now it is as good as legacy LE connection and event as
    no new features in the extended connection is handled.
    
    < HCI Command: LE Extended Create Connection (0x08|0x0043) plen 26
            Filter policy: White list is not used (0x00)
            Own address type: Public (0x00)
            Peer address type: Random (0x01)
            Peer address: DB:7E:2E:1D:85:E8 (Static)
            Initiating PHYs: 0x01
            Entry 0: LE 1M
              Scan interval: 60.000 msec (0x0060)
              Scan window: 60.000 msec (0x0060)
              Min connection interval: 50.00 msec (0x0028)
              Max connection interval: 70.00 msec (0x0038)
              Connection latency: 0 (0x0000)
              Supervision timeout: 420 msec (0x002a)
              Min connection length: 0.000 msec (0x0000)
              Max connection length: 0.000 msec (0x0000)
    > HCI Event: Command Status (0x0f) plen 4
          LE Extended Create Connection (0x08|0x0043) ncmd 2
            Status: Success (0x00)
    > HCI Event: LE Meta Event (0x3e) plen 31
          LE Enhanced Connection Complete (0x0a)
            Status: Success (0x00)
            Handle: 3585
            Role: Master (0x00)
            Peer address type: Random (0x01)
            Peer address: DB:7E:2E:1D:85:E8 (Static)
            Local resolvable private address: 00:00:00:00:00:00 (Non-Resolvable)
            Peer resolvable private address: 00:00:00:00:00:00 (Non-Resolvable)
            Connection interval: 67.50 msec (0x0036)
            Connection latency: 0 (0x0000)
            Supervision timeout: 420 msec (0x002a)
            Master clock accuracy: 0x00
    @ MGMT Event: Device Connected (0x000b) plen 40
            LE Address: DB:7E:2E:1D:85:E8 (Static)
            Flags: 0x00000000
            Data length: 27
            Name (complete): Designer Mouse
            Appearance: Mouse (0x03c2)
            Flags: 0x05
              LE Limited Discoverable Mode
              BR/EDR Not Supported
            16-bit Service UUIDs (complete): 1 entry
              Human Interface Device (0x1812)
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 45ff5dc124cc..cc967ca67962 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -752,7 +752,6 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 				       struct hci_conn *conn,
 				       bdaddr_t *direct_rpa)
 {
-	struct hci_cp_le_create_conn cp;
 	struct hci_dev *hdev = conn->hdev;
 	u8 own_addr_type;
 
@@ -775,25 +774,62 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 			return;
 	}
 
-	memset(&cp, 0, sizeof(cp));
+	if (use_ext_conn(hdev)) {
+		struct hci_cp_le_ext_create_conn *cp;
+		struct hci_cp_le_ext_conn_param *p;
+		/* As of now only LE 1M is supported */
+		u8 data[sizeof(*cp) + sizeof(*p) * 1];
 
-	/* Set window to be the same value as the interval to enable
-	 * continuous scanning.
-	 */
-	cp.scan_interval = cpu_to_le16(hdev->le_scan_interval);
-	cp.scan_window = cp.scan_interval;
+		cp = (void *) data;
+		p = (void *) cp->data;
 
-	bacpy(&cp.peer_addr, &conn->dst);
-	cp.peer_addr_type = conn->dst_type;
-	cp.own_address_type = own_addr_type;
-	cp.conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
-	cp.conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
-	cp.conn_latency = cpu_to_le16(conn->le_conn_latency);
-	cp.supervision_timeout = cpu_to_le16(conn->le_supv_timeout);
-	cp.min_ce_len = cpu_to_le16(0x0000);
-	cp.max_ce_len = cpu_to_le16(0x0000);
-
-	hci_req_add(req, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
+		memset(cp, 0, sizeof(*cp));
+
+		bacpy(&cp->peer_addr, &conn->dst);
+		cp->peer_addr_type = conn->dst_type;
+		cp->own_addr_type = own_addr_type;
+		cp->phys = LE_SCAN_PHY_1M;
+
+		memset(p, 0, sizeof(*p));
+
+		/* Set window to be the same value as the interval to enable
+		 * continuous scanning.
+		 */
+
+		p->scan_interval = cpu_to_le16(hdev->le_scan_interval);
+		p->scan_window = p->scan_interval;
+		p->conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
+		p->conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
+		p->conn_latency = cpu_to_le16(conn->le_conn_latency);
+		p->supervision_timeout = cpu_to_le16(conn->le_supv_timeout);
+		p->min_ce_len = cpu_to_le16(0x0000);
+		p->max_ce_len = cpu_to_le16(0x0000);
+
+		hci_req_add(req, HCI_OP_LE_EXT_CREATE_CONN, sizeof(data), data);
+
+	} else {
+		struct hci_cp_le_create_conn cp;
+
+		memset(&cp, 0, sizeof(cp));
+
+		/* Set window to be the same value as the interval to enable
+		 * continuous scanning.
+		 */
+		cp.scan_interval = cpu_to_le16(hdev->le_scan_interval);
+		cp.scan_window = cp.scan_interval;
+
+		bacpy(&cp.peer_addr, &conn->dst);
+		cp.peer_addr_type = conn->dst_type;
+		cp.own_address_type = own_addr_type;
+		cp.conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
+		cp.conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
+		cp.conn_latency = cpu_to_le16(conn->le_conn_latency);
+		cp.supervision_timeout = cpu_to_le16(conn->le_supv_timeout);
+		cp.min_ce_len = cpu_to_le16(0x0000);
+		cp.max_ce_len = cpu_to_le16(0x0000);
+
+		hci_req_add(req, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
+	}
 
 	conn->state = BT_CONNECT;
 	clear_bit(HCI_CONN_SCANNING, &conn->flags);

commit 082f2300cfa1a3d9d5221c38c5eba85d4ab98bd8
Author: Szymon Janc <szymon.janc@codecoup.pl>
Date:   Tue Apr 3 13:40:06 2018 +0200

    Bluetooth: Fix connection if directed advertising and privacy is used
    
    Local random address needs to be updated before creating connection if
    RPA from LE Direct Advertising Report was resolved in host. Otherwise
    remote device might ignore connection request due to address mismatch.
    
    This was affecting following qualification test cases:
    GAP/CONN/SCEP/BV-03-C, GAP/CONN/GCEP/BV-05-C, GAP/CONN/DCEP/BV-05-C
    
    Before patch:
    < HCI Command: LE Set Random Address (0x08|0x0005) plen 6          #11350 [hci0] 84680.231216
            Address: 56:BC:E8:24:11:68 (Resolvable)
              Identity type: Random (0x01)
              Identity: F2:F1:06:3D:9C:42 (Static)
    > HCI Event: Command Complete (0x0e) plen 4                        #11351 [hci0] 84680.246022
          LE Set Random Address (0x08|0x0005) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Set Scan Parameters (0x08|0x000b) plen 7         #11352 [hci0] 84680.246417
            Type: Passive (0x00)
            Interval: 60.000 msec (0x0060)
            Window: 30.000 msec (0x0030)
            Own address type: Random (0x01)
            Filter policy: Accept all advertisement, inc. directed unresolved RPA (0x02)
    > HCI Event: Command Complete (0x0e) plen 4                        #11353 [hci0] 84680.248854
          LE Set Scan Parameters (0x08|0x000b) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Set Scan Enable (0x08|0x000c) plen 2             #11354 [hci0] 84680.249466
            Scanning: Enabled (0x01)
            Filter duplicates: Enabled (0x01)
    > HCI Event: Command Complete (0x0e) plen 4                        #11355 [hci0] 84680.253222
          LE Set Scan Enable (0x08|0x000c) ncmd 1
            Status: Success (0x00)
    > HCI Event: LE Meta Event (0x3e) plen 18                          #11356 [hci0] 84680.458387
          LE Direct Advertising Report (0x0b)
            Num reports: 1
            Event type: Connectable directed - ADV_DIRECT_IND (0x01)
            Address type: Random (0x01)
            Address: 53:38:DA:46:8C:45 (Resolvable)
              Identity type: Public (0x00)
              Identity: 11:22:33:44:55:66 (OUI 11-22-33)
            Direct address type: Random (0x01)
            Direct address: 7C:D6:76:8C:DF:82 (Resolvable)
              Identity type: Random (0x01)
              Identity: F2:F1:06:3D:9C:42 (Static)
            RSSI: -74 dBm (0xb6)
    < HCI Command: LE Set Scan Enable (0x08|0x000c) plen 2             #11357 [hci0] 84680.458737
            Scanning: Disabled (0x00)
            Filter duplicates: Disabled (0x00)
    > HCI Event: Command Complete (0x0e) plen 4                        #11358 [hci0] 84680.469982
          LE Set Scan Enable (0x08|0x000c) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Create Connection (0x08|0x000d) plen 25          #11359 [hci0] 84680.470444
            Scan interval: 60.000 msec (0x0060)
            Scan window: 60.000 msec (0x0060)
            Filter policy: White list is not used (0x00)
            Peer address type: Random (0x01)
            Peer address: 53:38:DA:46:8C:45 (Resolvable)
              Identity type: Public (0x00)
              Identity: 11:22:33:44:55:66 (OUI 11-22-33)
            Own address type: Random (0x01)
            Min connection interval: 30.00 msec (0x0018)
            Max connection interval: 50.00 msec (0x0028)
            Connection latency: 0 (0x0000)
            Supervision timeout: 420 msec (0x002a)
            Min connection length: 0.000 msec (0x0000)
            Max connection length: 0.000 msec (0x0000)
    > HCI Event: Command Status (0x0f) plen 4                          #11360 [hci0] 84680.474971
          LE Create Connection (0x08|0x000d) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Create Connection Cancel (0x08|0x000e) plen 0    #11361 [hci0] 84682.545385
    > HCI Event: Command Complete (0x0e) plen 4                        #11362 [hci0] 84682.551014
          LE Create Connection Cancel (0x08|0x000e) ncmd 1
            Status: Success (0x00)
    > HCI Event: LE Meta Event (0x3e) plen 19                          #11363 [hci0] 84682.551074
          LE Connection Complete (0x01)
            Status: Unknown Connection Identifier (0x02)
            Handle: 0
            Role: Master (0x00)
            Peer address type: Public (0x00)
            Peer address: 00:00:00:00:00:00 (OUI 00-00-00)
            Connection interval: 0.00 msec (0x0000)
            Connection latency: 0 (0x0000)
            Supervision timeout: 0 msec (0x0000)
            Master clock accuracy: 0x00
    
    After patch:
    < HCI Command: LE Set Scan Parameters (0x08|0x000b) plen 7    #210 [hci0] 667.152459
            Type: Passive (0x00)
            Interval: 60.000 msec (0x0060)
            Window: 30.000 msec (0x0030)
            Own address type: Random (0x01)
            Filter policy: Accept all advertisement, inc. directed unresolved RPA (0x02)
    > HCI Event: Command Complete (0x0e) plen 4                   #211 [hci0] 667.153613
          LE Set Scan Parameters (0x08|0x000b) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Set Scan Enable (0x08|0x000c) plen 2        #212 [hci0] 667.153704
            Scanning: Enabled (0x01)
            Filter duplicates: Enabled (0x01)
    > HCI Event: Command Complete (0x0e) plen 4                   #213 [hci0] 667.154584
          LE Set Scan Enable (0x08|0x000c) ncmd 1
            Status: Success (0x00)
    > HCI Event: LE Meta Event (0x3e) plen 18                     #214 [hci0] 667.182619
          LE Direct Advertising Report (0x0b)
            Num reports: 1
            Event type: Connectable directed - ADV_DIRECT_IND (0x01)
            Address type: Random (0x01)
            Address: 50:52:D9:A6:48:A0 (Resolvable)
              Identity type: Public (0x00)
              Identity: 11:22:33:44:55:66 (OUI 11-22-33)
            Direct address type: Random (0x01)
            Direct address: 7C:C1:57:A5:B7:A8 (Resolvable)
              Identity type: Random (0x01)
              Identity: F4:28:73:5D:38:B0 (Static)
            RSSI: -70 dBm (0xba)
    < HCI Command: LE Set Scan Enable (0x08|0x000c) plen 2       #215 [hci0] 667.182704
            Scanning: Disabled (0x00)
            Filter duplicates: Disabled (0x00)
    > HCI Event: Command Complete (0x0e) plen 4                  #216 [hci0] 667.183599
          LE Set Scan Enable (0x08|0x000c) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Set Random Address (0x08|0x0005) plen 6    #217 [hci0] 667.183645
            Address: 7C:C1:57:A5:B7:A8 (Resolvable)
              Identity type: Random (0x01)
              Identity: F4:28:73:5D:38:B0 (Static)
    > HCI Event: Command Complete (0x0e) plen 4                  #218 [hci0] 667.184590
          LE Set Random Address (0x08|0x0005) ncmd 1
            Status: Success (0x00)
    < HCI Command: LE Create Connection (0x08|0x000d) plen 25    #219 [hci0] 667.184613
            Scan interval: 60.000 msec (0x0060)
            Scan window: 60.000 msec (0x0060)
            Filter policy: White list is not used (0x00)
            Peer address type: Random (0x01)
            Peer address: 50:52:D9:A6:48:A0 (Resolvable)
              Identity type: Public (0x00)
              Identity: 11:22:33:44:55:66 (OUI 11-22-33)
            Own address type: Random (0x01)
            Min connection interval: 30.00 msec (0x0018)
            Max connection interval: 50.00 msec (0x0028)
            Connection latency: 0 (0x0000)
            Supervision timeout: 420 msec (0x002a)
            Min connection length: 0.000 msec (0x0000)
            Max connection length: 0.000 msec (0x0000)
    > HCI Event: Command Status (0x0f) plen 4                    #220 [hci0] 667.186558
          LE Create Connection (0x08|0x000d) ncmd 1
            Status: Success (0x00)
    > HCI Event: LE Meta Event (0x3e) plen 19                    #221 [hci0] 667.485824
          LE Connection Complete (0x01)
            Status: Success (0x00)
            Handle: 0
            Role: Master (0x00)
            Peer address type: Random (0x01)
            Peer address: 50:52:D9:A6:48:A0 (Resolvable)
              Identity type: Public (0x00)
              Identity: 11:22:33:44:55:66 (OUI 11-22-33)
            Connection interval: 50.00 msec (0x0028)
            Connection latency: 0 (0x0000)
            Supervision timeout: 420 msec (0x002a)
            Master clock accuracy: 0x07
    @ MGMT Event: Device Connected (0x000b) plen 13          {0x0002} [hci0] 667.485996
            LE Address: 11:22:33:44:55:66 (OUI 11-22-33)
            Flags: 0x00000000
            Data length: 0
    
    Signed-off-by: Szymon Janc <szymon.janc@codecoup.pl>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable@vger.kernel.org

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a9682534c377..45ff5dc124cc 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -749,18 +749,31 @@ static bool conn_use_rpa(struct hci_conn *conn)
 }
 
 static void hci_req_add_le_create_conn(struct hci_request *req,
-				       struct hci_conn *conn)
+				       struct hci_conn *conn,
+				       bdaddr_t *direct_rpa)
 {
 	struct hci_cp_le_create_conn cp;
 	struct hci_dev *hdev = conn->hdev;
 	u8 own_addr_type;
 
-	/* Update random address, but set require_privacy to false so
-	 * that we never connect with an non-resolvable address.
+	/* If direct address was provided we use it instead of current
+	 * address.
 	 */
-	if (hci_update_random_address(req, false, conn_use_rpa(conn),
-				      &own_addr_type))
-		return;
+	if (direct_rpa) {
+		if (bacmp(&req->hdev->random_addr, direct_rpa))
+			hci_req_add(req, HCI_OP_LE_SET_RANDOM_ADDR, 6,
+								direct_rpa);
+
+		/* direct address is always RPA */
+		own_addr_type = ADDR_LE_DEV_RANDOM;
+	} else {
+		/* Update random address, but set require_privacy to false so
+		 * that we never connect with an non-resolvable address.
+		 */
+		if (hci_update_random_address(req, false, conn_use_rpa(conn),
+					      &own_addr_type))
+			return;
+	}
 
 	memset(&cp, 0, sizeof(cp));
 
@@ -825,7 +838,7 @@ static void hci_req_directed_advertising(struct hci_request *req,
 
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				u8 dst_type, u8 sec_level, u16 conn_timeout,
-				u8 role)
+				u8 role, bdaddr_t *direct_rpa)
 {
 	struct hci_conn_params *params;
 	struct hci_conn *conn;
@@ -940,7 +953,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		hci_dev_set_flag(hdev, HCI_LE_SCAN_INTERRUPTED);
 	}
 
-	hci_req_add_le_create_conn(&req, conn);
+	hci_req_add_le_create_conn(&req, conn, direct_rpa);
 
 create_conn:
 	err = hci_req_run(&req, create_le_conn_complete);

commit 2064ee332e4c1b7495cf68b84355c213d8fe71fd
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Oct 30 10:42:59 2017 +0100

    Bluetooth: Use bt_dev_err and bt_dev_info when possible
    
    In case of using BT_ERR and BT_INFO, convert to bt_dev_err and
    bt_dev_info when possible. This allows for controller specific
    reporting.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 746adcb62259..a9682534c377 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -729,8 +729,8 @@ static void create_le_conn_complete(struct hci_dev *hdev, u8 status, u16 opcode)
 		goto done;
 	}
 
-	BT_ERR("HCI request failed to create LE connection: status 0x%2.2x",
-	       status);
+	bt_dev_err(hdev, "request failed to create LE connection: "
+		   "status 0x%2.2x", status);
 
 	if (!conn)
 		goto done;

commit f17d858ed0a48270db4368d8cf370e3839ee6f4f
Author: Jaganath Kanakkassery <jaganath.k.os@gmail.com>
Date:   Wed Oct 25 10:58:48 2017 +0530

    Bluetooth: Fix potential memory leak
    
    If command is added to req then it should be freed in case if
    hdev is down or HCI_ADVERTISING flag is set.
    
    This introduces a helper in hci_request to purge the cmd_q
    to make cmd_q internal to hci_request which is used to fix
    the leak.
    
    This also replace accessing of cmd_q in hci_conn with the
    new helper.
    
    Signed-off-by: Jaganath Kanakkassery <jaganathx.kanakkassery@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index dc59eae54717..746adcb62259 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -907,7 +907,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		 */
 		if (hci_dev_test_flag(hdev, HCI_LE_SCAN) &&
 		    hdev->le_scan_type == LE_SCAN_ACTIVE) {
-			skb_queue_purge(&req.cmd_q);
+			hci_req_purge(&req);
 			hci_conn_del(conn);
 			return ERR_PTR(-EBUSY);
 		}

commit 39385cb5f3274735b03ed1f8e7ff517b02a0beed
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sat Nov 12 17:03:07 2016 +0200

    Bluetooth: Fix using the correct source address type
    
    The hci_get_route() API is used to look up local HCI devices, however
    so far it has been incapable of dealing with anything else than the
    public address of HCI devices. This completely breaks with LE-only HCI
    devices that do not come with a public address, but use a static
    random address instead.
    
    This patch exteds the hci_get_route() API with a src_type parameter
    that's used for comparing with the right address of each HCI device.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3809617aa98d..dc59eae54717 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -613,7 +613,7 @@ int hci_conn_del(struct hci_conn *conn)
 	return 0;
 }
 
-struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
+struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src, uint8_t src_type)
 {
 	int use_src = bacmp(src, BDADDR_ANY);
 	struct hci_dev *hdev = NULL, *d;
@@ -634,7 +634,29 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 		 */
 
 		if (use_src) {
-			if (!bacmp(&d->bdaddr, src)) {
+			bdaddr_t id_addr;
+			u8 id_addr_type;
+
+			if (src_type == BDADDR_BREDR) {
+				if (!lmp_bredr_capable(d))
+					continue;
+				bacpy(&id_addr, &d->bdaddr);
+				id_addr_type = BDADDR_BREDR;
+			} else {
+				if (!lmp_le_capable(d))
+					continue;
+
+				hci_copy_identity_address(d, &id_addr,
+							  &id_addr_type);
+
+				/* Convert from HCI to three-value type */
+				if (id_addr_type == ADDR_LE_DEV_PUBLIC)
+					id_addr_type = BDADDR_LE_PUBLIC;
+				else
+					id_addr_type = BDADDR_LE_RANDOM;
+			}
+
+			if (!bacmp(&id_addr, src) && id_addr_type == src_type) {
 				hdev = d; break;
 			}
 		} else {

commit ca8bee5dde1f02c2dbe8c8453dce27f2dfafb21c
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Jul 5 14:30:14 2016 +0200

    Bluetooth: Rename HCI_BREDR into HCI_PRIMARY
    
    The HCI_BREDR naming is confusing since it actually stands for Primary
    Bluetooth Controller. Which is a term that has been used in the latest
    standard. However from a legacy point of view there only really have
    been Basic Rate (BR) and Enhanced Data Rate (EDR). Recent versions of
    Bluetooth introduced Low Energy (LE) and made this terminology a little
    bit confused since Dual Mode Controllers include BR/EDR and LE. To
    simplify this the name HCI_PRIMARY stands for the Primary Controller
    which can be a single mode or dual mode controller.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index bf9f8a801a2e..3809617aa98d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -625,7 +625,7 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 	list_for_each_entry(d, &hci_dev_list, list) {
 		if (!test_bit(HCI_UP, &d->flags) ||
 		    hci_dev_test_flag(d, HCI_USER_CHANNEL) ||
-		    d->dev_type != HCI_BREDR)
+		    d->dev_type != HCI_PRIMARY)
 			continue;
 
 		/* Simple routing:

commit 82a37adeedd38880940e2772ec1ae27a09353e5a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Mar 9 17:30:34 2016 +0200

    Bluetooth: Add support for limited privacy mode
    
    Introduce a limited privacy mode indicated by value 0x02 to the mgmt
    Set Privacy command.
    
    With value 0x02 the kernel will use privacy mode with a resolvable
    private address. In case the controller is bondable and discoverable
    the identity address will be used.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7264025dc781..bf9f8a801a2e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -719,6 +719,13 @@ static void create_le_conn_complete(struct hci_dev *hdev, u8 status, u16 opcode)
 	hci_dev_unlock(hdev);
 }
 
+static bool conn_use_rpa(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	return hci_dev_test_flag(hdev, HCI_PRIVACY);
+}
+
 static void hci_req_add_le_create_conn(struct hci_request *req,
 				       struct hci_conn *conn)
 {
@@ -729,7 +736,8 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	/* Update random address, but set require_privacy to false so
 	 * that we never connect with an non-resolvable address.
 	 */
-	if (hci_update_random_address(req, false, &own_addr_type))
+	if (hci_update_random_address(req, false, conn_use_rpa(conn),
+				      &own_addr_type))
 		return;
 
 	memset(&cp, 0, sizeof(cp));
@@ -774,7 +782,8 @@ static void hci_req_directed_advertising(struct hci_request *req,
 	/* Set require_privacy to false so that the remote device has a
 	 * chance of identifying us.
 	 */
-	if (hci_update_random_address(req, false, &own_addr_type) < 0)
+	if (hci_update_random_address(req, false, conn_use_rpa(conn),
+				      &own_addr_type) < 0)
 		return;
 
 	memset(&cp, 0, sizeof(cp));

commit eec7a01dc8366f7e43fc0417f4aee70eaeaca9a9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Mar 9 17:30:32 2016 +0200

    Bluetooth: Move memset closer to where it's needed
    
    Minor fix to not do the memset until the variable it clears is
    actually used.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 32575b49f4a0..7264025dc781 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -726,14 +726,14 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	struct hci_dev *hdev = conn->hdev;
 	u8 own_addr_type;
 
-	memset(&cp, 0, sizeof(cp));
-
 	/* Update random address, but set require_privacy to false so
 	 * that we never connect with an non-resolvable address.
 	 */
 	if (hci_update_random_address(req, false, &own_addr_type))
 		return;
 
+	memset(&cp, 0, sizeof(cp));
+
 	/* Set window to be the same value as the interval to enable
 	 * continuous scanning.
 	 */

commit acb9f911ea1f828822001d72b21f7cc06e6718c7
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Dec 3 12:45:20 2015 +0200

    Bluetooth: Don't treat connection timeout as a failure
    
    When we're doing background scanning and connection attempts it's
    possible we timeout trying to connect and go back to scanning again.
    The timeout triggers a HCI_LE_Create_Connection_Cancel which will
    trigger a Connection Complete with "Unknown Connection Identifier"
    error status. Since we go back to scanning this isn't really a failure
    and shouldn't be presented as such to user space through mgmt.
    
    The exception to this is if the connection attempt was due to an
    explicit request on an L2CAP socket (indicated by
    params->explicit_connect being true). Since the socket will get an
    error it's consistent to also notify the failure on mgmt in this case.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 48a7eac6ef71..32575b49f4a0 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -668,8 +668,16 @@ void hci_le_conn_failed(struct hci_conn *conn, u8 status)
 
 	conn->state = BT_CLOSED;
 
-	mgmt_connect_failed(hdev, &conn->dst, conn->type, conn->dst_type,
-			    status);
+	/* If the status indicates successful cancellation of
+	 * the attempt (i.e. Unkown Connection Id) there's no point of
+	 * notifying failure since we'll go back to keep trying to
+	 * connect. The only exception is explicit connect requests
+	 * where a timeout + cancel does indicate an actual failure.
+	 */
+	if (status != HCI_ERROR_UNKNOWN_CONN_ID ||
+	    (params && params->explicit_connect))
+		mgmt_connect_failed(hdev, &conn->dst, conn->type,
+				    conn->dst_type, status);
 
 	hci_connect_cfm(conn, status);
 

commit 2f99536a5b34d5b0f54723067d68f6cef3f0fdc6
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Dec 3 12:45:19 2015 +0200

    Bluetooth: Use continuous scanning when creating LE connections
    
    All LE connections are now triggered through a preceding passive scan
    and waiting for a connectable advertising report. This means we've got
    the best possible guarantee that the device is within range and should
    be able to request the controller to perform continuous scanning. This
    way we minimize the risk that we miss out on any advertising packets.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable@vger.kernel.org # 4.3+

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e2600213cd50..48a7eac6ef71 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -726,8 +726,12 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	if (hci_update_random_address(req, false, &own_addr_type))
 		return;
 
+	/* Set window to be the same value as the interval to enable
+	 * continuous scanning.
+	 */
 	cp.scan_interval = cpu_to_le16(hdev->le_scan_interval);
-	cp.scan_window = cpu_to_le16(hdev->le_scan_window);
+	cp.scan_window = cp.scan_interval;
+
 	bacpy(&cp.peer_addr, &conn->dst);
 	cp.peer_addr_type = conn->dst_type;
 	cp.own_address_type = own_addr_type;

commit f22525700b2ae34eb97a29a91e2eee902062b484
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 18 12:49:20 2015 +0200

    Bluetooth: Move advertising instance management to hci_request.c
    
    This paves the way for eventually performing advertising changes
    through the hdev->req_workqueue. Some new APIs need to be exposed from
    mgmt.c to hci_request.c and vice-versa, but many of them will go away
    once hdev->req_workqueue gets used.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 2d334e07fd77..e2600213cd50 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -683,7 +683,7 @@ void hci_le_conn_failed(struct hci_conn *conn, u8 status)
 	/* Re-enable advertising in case this was a failed connection
 	 * attempt as a peripheral.
 	 */
-	mgmt_reenable_advertising(hdev);
+	hci_req_reenable_advertising(hdev);
 }
 
 static void create_le_conn_complete(struct hci_dev *hdev, u8 status, u16 opcode)

commit e2caced40734731e2a17b501840809e30a08141a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 11 14:44:59 2015 +0200

    Bluetooth: Remove conn_unfinished variable from hci_connect_le()
    
    The conn_unfinished variable makes the entire logic of
    hci_connect_le() rather confusing. By restructuring and clarifying the
    logic we can actually remove the conn_unfinished variable and still
    keep the same behavior.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 08a291dd0f3a..2d334e07fd77 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -785,7 +785,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				u8 role)
 {
 	struct hci_conn_params *params;
-	struct hci_conn *conn, *conn_unfinished;
+	struct hci_conn *conn;
 	struct smp_irk *irk;
 	struct hci_request req;
 	int err;
@@ -804,27 +804,14 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	if (hci_lookup_le_connect(hdev))
 		return ERR_PTR(-EBUSY);
 
-	/* Some devices send ATT messages as soon as the physical link is
-	 * established. To be able to handle these ATT messages, the user-
-	 * space first establishes the connection and then starts the pairing
-	 * process.
-	 *
-	 * So if a hci_conn object already exists for the following connection
-	 * attempt, we simply update pending_sec_level and auth_type fields
-	 * and return the object found.
+	/* If there's already a connection object but it's not in
+	 * scanning state it means it must already be established, in
+	 * which case we can't do anything else except report a failure
+	 * to connect.
 	 */
 	conn = hci_conn_hash_lookup_le(hdev, dst, dst_type);
-	conn_unfinished = NULL;
-	if (conn) {
-		if (conn->state == BT_CONNECT &&
-		    test_bit(HCI_CONN_SCANNING, &conn->flags)) {
-			BT_DBG("will continue unfinished conn %pMR", dst);
-			conn_unfinished = conn;
-		} else {
-			if (conn->pending_sec_level < sec_level)
-				conn->pending_sec_level = sec_level;
-			goto done;
-		}
+	if (conn && !test_bit(HCI_CONN_SCANNING, &conn->flags)) {
+		return ERR_PTR(-EBUSY);
 	}
 
 	/* When given an identity address with existing identity
@@ -842,23 +829,20 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		dst_type = ADDR_LE_DEV_RANDOM;
 	}
 
-	if (conn_unfinished) {
-		conn = conn_unfinished;
+	if (conn) {
 		bacpy(&conn->dst, dst);
 	} else {
 		conn = hci_conn_add(hdev, LE_LINK, dst, role);
+		if (!conn)
+			return ERR_PTR(-ENOMEM);
+		hci_conn_hold(conn);
+		conn->pending_sec_level = sec_level;
 	}
 
-	if (!conn)
-		return ERR_PTR(-ENOMEM);
-
 	conn->dst_type = dst_type;
 	conn->sec_level = BT_SECURITY_LOW;
 	conn->conn_timeout = conn_timeout;
 
-	if (!conn_unfinished)
-		conn->pending_sec_level = sec_level;
-
 	hci_req_init(&req, hdev);
 
 	/* Disable advertising if we're active. For master role
@@ -922,14 +906,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		return ERR_PTR(err);
 	}
 
-done:
-	/* If this is continuation of connect started by hci_connect_le_scan,
-	 * it already called hci_conn_hold and calling it again would mess the
-	 * counter.
-	 */
-	if (!conn_unfinished)
-		hci_conn_hold(conn);
-
 	return conn;
 }
 

commit 658aead94bb65c0141391f20f8c24f51e971b6ea
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 11 14:44:58 2015 +0200

    Bluetooth: Move check for ongoing connect earlier in hci_connect_le()
    
    This helps simplify the logic in further patches (less cleanups to do
    in this failure branch).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 673c2254935b..08a291dd0f3a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -798,6 +798,12 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		return ERR_PTR(-EOPNOTSUPP);
 	}
 
+	/* Since the controller supports only one LE connection attempt at a
+	 * time, we return -EBUSY if there is any connection attempt running.
+	 */
+	if (hci_lookup_le_connect(hdev))
+		return ERR_PTR(-EBUSY);
+
 	/* Some devices send ATT messages as soon as the physical link is
 	 * established. To be able to handle these ATT messages, the user-
 	 * space first establishes the connection and then starts the pairing
@@ -821,12 +827,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		}
 	}
 
-	/* Since the controller supports only one LE connection attempt at a
-	 * time, we return -EBUSY if there is any connection attempt running.
-	 */
-	if (hci_lookup_le_connect(hdev))
-		return ERR_PTR(-EBUSY);
-
 	/* When given an identity address with existing identity
 	 * resolving key, the connection needs to be established
 	 * to a resolvable random address.

commit 0ad06aa6a7682319bb1adcc187a1fa8db6b2da2c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 11 14:44:57 2015 +0200

    Bluetooth: Fix specifying role for LE connections
    
    The hci_connect_le_scan() is (as the name implies) a master/central
    role API, so it makes no sense in passing a role parameter to it. At
    the same time this patch also fixes the direct advertising support for
    LE L2CAP sockets where we now call the more appropriate hci_le_connect()
    API if slave/peripheral role is desired.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 1ed1e153b3fa..673c2254935b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -988,7 +988,7 @@ static int hci_explicit_conn_params_set(struct hci_dev *hdev,
 /* This function requires the caller holds hdev->lock */
 struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
 				     u8 dst_type, u8 sec_level,
-				     u16 conn_timeout, u8 role)
+				     u16 conn_timeout)
 {
 	struct hci_conn *conn;
 
@@ -1018,7 +1018,7 @@ struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
 
 	BT_DBG("requesting refresh of dst_addr");
 
-	conn = hci_conn_add(hdev, LE_LINK, dst, role);
+	conn = hci_conn_add(hdev, LE_LINK, dst, HCI_ROLE_MASTER);
 	if (!conn)
 		return ERR_PTR(-ENOMEM);
 

commit 84235d222a297a281dbe984ef4f28519cacc5fe3
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Nov 11 08:11:20 2015 +0200

    Bluetooth: Use req_workqueue for explicit connect requests
    
    Since explicit connect requests are also a sub-category of passive
    scan updates, run them through the same workqueue as the other passive
    scan changes.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index fd6120a41138..1ed1e153b3fa 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -933,26 +933,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	return conn;
 }
 
-static void hci_connect_le_scan_complete(struct hci_dev *hdev, u8 status,
-					 u16 opcode)
-{
-	struct hci_conn *conn;
-
-	if (!status)
-		return;
-
-	BT_ERR("Failed to add device to auto conn whitelist: status 0x%2.2x",
-	       status);
-
-	hci_dev_lock(hdev);
-
-	conn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
-	if (conn)
-		hci_le_conn_failed(conn, status);
-
-	hci_dev_unlock(hdev);
-}
-
 static bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)
 {
 	struct hci_conn *conn;
@@ -968,10 +948,9 @@ static bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)
 }
 
 /* This function requires the caller holds hdev->lock */
-static int hci_explicit_conn_params_set(struct hci_request *req,
+static int hci_explicit_conn_params_set(struct hci_dev *hdev,
 					bdaddr_t *addr, u8 addr_type)
 {
-	struct hci_dev *hdev = req->hdev;
 	struct hci_conn_params *params;
 
 	if (is_connected(hdev, addr, addr_type))
@@ -999,7 +978,6 @@ static int hci_explicit_conn_params_set(struct hci_request *req,
 	}
 
 	params->explicit_connect = true;
-	__hci_update_background_scan(req);
 
 	BT_DBG("addr %pMR (type %u) auto_connect %u", addr, addr_type,
 	       params->auto_connect);
@@ -1013,8 +991,6 @@ struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
 				     u16 conn_timeout, u8 role)
 {
 	struct hci_conn *conn;
-	struct hci_request req;
-	int err;
 
 	/* Let's make sure that le is enabled.*/
 	if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {
@@ -1046,25 +1022,18 @@ struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
 	if (!conn)
 		return ERR_PTR(-ENOMEM);
 
-	hci_req_init(&req, hdev);
-
-	if (hci_explicit_conn_params_set(&req, dst, dst_type) < 0)
+	if (hci_explicit_conn_params_set(hdev, dst, dst_type) < 0)
 		return ERR_PTR(-EBUSY);
 
 	conn->state = BT_CONNECT;
 	set_bit(HCI_CONN_SCANNING, &conn->flags);
-
-	err = hci_req_run(&req, hci_connect_le_scan_complete);
-	if (err && err != -ENODATA) {
-		hci_conn_del(conn);
-		return ERR_PTR(err);
-	}
-
 	conn->dst_type = dst_type;
 	conn->sec_level = BT_SECURITY_LOW;
 	conn->pending_sec_level = sec_level;
 	conn->conn_timeout = conn_timeout;
 
+	hci_update_background_scan(hdev);
+
 done:
 	hci_conn_hold(conn);
 	return conn;

commit 0ebc181884e8f538c4786840ed4abef828d4dc9b
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Nov 6 13:35:33 2015 +0200

    Bluetooth: Add clarifying comment why schedule_work is used
    
    It's not obvious why schedule_work is used instead of queue_work. Add
    a comment explaining why.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 85b82f7adbd2..fd6120a41138 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -178,6 +178,10 @@ static void hci_connect_le_scan_remove(struct hci_conn *conn)
 	hci_dev_hold(conn->hdev);
 	hci_conn_get(conn);
 
+	/* Even though we hold a reference to the hdev, many other
+	 * things might get cleaned up meanwhile, including the hdev's
+	 * own workqueue, so we can't use that for scheduling.
+	 */
 	schedule_work(&conn->le_scan_cleanup);
 }
 

commit 88d07feb097b60fcca20ba63d2920b0f05a05fa0
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Oct 22 10:49:39 2015 +0300

    Bluetooth: Make hci_disconnect() behave correctly for all states
    
    There are a few places that don't explicitly check the connection
    state before calling hci_disconnect(). To make this API do the right
    thing take advantage of the new hci_abort_conn() API and also make
    sure to only read the clock offset if we're really connected.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 665a52fa6c60..85b82f7adbd2 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -226,8 +226,6 @@ static void hci_acl_create_connection(struct hci_conn *conn)
 
 int hci_disconnect(struct hci_conn *conn, __u8 reason)
 {
-	struct hci_cp_disconnect cp;
-
 	BT_DBG("hcon %p", conn);
 
 	/* When we are master of an established connection and it enters
@@ -235,7 +233,8 @@ int hci_disconnect(struct hci_conn *conn, __u8 reason)
 	 * current clock offset.  Processing of the result is done
 	 * within the event handling and hci_clock_offset_evt function.
 	 */
-	if (conn->type == ACL_LINK && conn->role == HCI_ROLE_MASTER) {
+	if (conn->type == ACL_LINK && conn->role == HCI_ROLE_MASTER &&
+	    (conn->state == BT_CONNECTED || conn->state == BT_CONFIG)) {
 		struct hci_dev *hdev = conn->hdev;
 		struct hci_cp_read_clock_offset clkoff_cp;
 
@@ -244,11 +243,7 @@ int hci_disconnect(struct hci_conn *conn, __u8 reason)
 			     &clkoff_cp);
 	}
 
-	conn->state = BT_DISCONN;
-
-	cp.handle = cpu_to_le16(conn->handle);
-	cp.reason = reason;
-	return hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
+	return hci_abort_conn(conn, reason);
 }
 
 static void hci_add_sco(struct hci_conn *conn, __u16 handle)

commit 89e0ccc882c47a4553698a580bec70cd90bc6319
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Oct 22 10:49:38 2015 +0300

    Bluetooth: Take advantage of connection abort helpers
    
    Convert the various places mapping connection state to
    disconnect/cancel HCI command to use the new hci_abort_conn helper
    API.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 11316159a5a7..665a52fa6c60 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -59,11 +59,6 @@ static const struct sco_param esco_param_msbc[] = {
 	{ EDR_ESCO_MASK | ESCO_EV3,   0x0008,	0x02 }, /* T1 */
 };
 
-static void hci_le_create_connection_cancel(struct hci_conn *conn)
-{
-	hci_send_cmd(conn->hdev, HCI_OP_LE_CREATE_CONN_CANCEL, 0, NULL);
-}
-
 /* This function requires the caller holds hdev->lock */
 static void hci_connect_le_scan_cleanup(struct hci_conn *conn)
 {
@@ -229,29 +224,6 @@ static void hci_acl_create_connection(struct hci_conn *conn)
 	hci_send_cmd(hdev, HCI_OP_CREATE_CONN, sizeof(cp), &cp);
 }
 
-static void hci_acl_create_connection_cancel(struct hci_conn *conn)
-{
-	struct hci_cp_create_conn_cancel cp;
-
-	BT_DBG("hcon %p", conn);
-
-	if (conn->hdev->hci_ver < BLUETOOTH_VER_1_2)
-		return;
-
-	bacpy(&cp.bdaddr, &conn->dst);
-	hci_send_cmd(conn->hdev, HCI_OP_CREATE_CONN_CANCEL, sizeof(cp), &cp);
-}
-
-static void hci_reject_sco(struct hci_conn *conn)
-{
-	struct hci_cp_reject_sync_conn_req cp;
-
-	cp.reason = HCI_ERROR_REJ_LIMITED_RESOURCES;
-	bacpy(&cp.bdaddr, &conn->dst);
-
-	hci_send_cmd(conn->hdev, HCI_OP_REJECT_SYNC_CONN_REQ, sizeof(cp), &cp);
-}
-
 int hci_disconnect(struct hci_conn *conn, __u8 reason)
 {
 	struct hci_cp_disconnect cp;
@@ -279,20 +251,6 @@ int hci_disconnect(struct hci_conn *conn, __u8 reason)
 	return hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
 }
 
-static void hci_amp_disconn(struct hci_conn *conn)
-{
-	struct hci_cp_disconn_phy_link cp;
-
-	BT_DBG("hcon %p", conn);
-
-	conn->state = BT_DISCONN;
-
-	cp.phy_handle = HCI_PHY_HANDLE(conn->handle);
-	cp.reason = hci_proto_disconn_ind(conn);
-	hci_send_cmd(conn->hdev, HCI_OP_DISCONN_PHY_LINK,
-		     sizeof(cp), &cp);
-}
-
 static void hci_add_sco(struct hci_conn *conn, __u16 handle)
 {
 	struct hci_dev *hdev = conn->hdev;
@@ -456,35 +414,14 @@ static void hci_conn_timeout(struct work_struct *work)
 	if (refcnt > 0)
 		return;
 
-	switch (conn->state) {
-	case BT_CONNECT:
-	case BT_CONNECT2:
-		if (conn->out) {
-			if (conn->type == ACL_LINK)
-				hci_acl_create_connection_cancel(conn);
-			else if (conn->type == LE_LINK) {
-				if (test_bit(HCI_CONN_SCANNING, &conn->flags))
-					hci_connect_le_scan_remove(conn);
-				else
-					hci_le_create_connection_cancel(conn);
-			}
-		} else if (conn->type == SCO_LINK || conn->type == ESCO_LINK) {
-			hci_reject_sco(conn);
-		}
-		break;
-	case BT_CONFIG:
-	case BT_CONNECTED:
-		if (conn->type == AMP_LINK) {
-			hci_amp_disconn(conn);
-		} else {
-			__u8 reason = hci_proto_disconn_ind(conn);
-			hci_disconnect(conn, reason);
-		}
-		break;
-	default:
-		conn->state = BT_CLOSED;
-		break;
+	/* LE connections in scanning state need special handling */
+	if (conn->state == BT_CONNECT && conn->type == LE_LINK &&
+	    test_bit(HCI_CONN_SCANNING, &conn->flags)) {
+		hci_connect_le_scan_remove(conn);
+		return;
 	}
+
+	hci_abort_conn(conn, hci_proto_disconn_ind(conn));
 }
 
 /* Enter sniff mode */
@@ -552,7 +489,7 @@ static void le_conn_timeout(struct work_struct *work)
 		return;
 	}
 
-	hci_le_create_connection_cancel(conn);
+	hci_abort_conn(conn, HCI_ERROR_REMOTE_USER_TERM);
 }
 
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,

commit 17bc08f0d1b17d6d5e4967c1b430af627c5f2041
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 21 18:03:10 2015 +0300

    Bluetooth: Remove unnecessary hci_explicit_connect_lookup function
    
    There's only one user of this helper which can be replaces with a call
    to hci_pend_le_action_lookup() and a check for params->explicit_connect.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6ef1b4cc71a6..11316159a5a7 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -83,8 +83,9 @@ static void hci_connect_le_scan_cleanup(struct hci_conn *conn)
 		bdaddr_type = irk->addr_type;
 	}
 
-	params = hci_explicit_connect_lookup(hdev, bdaddr, bdaddr_type);
-	if (!params)
+	params = hci_pend_le_action_lookup(&hdev->pend_le_conns, bdaddr,
+					   bdaddr_type);
+	if (!params || !params->explicit_connect)
 		return;
 
 	/* The connection attempt was doing scan for new RPA, and is

commit b5c2b6214c609f2be4c020c0be90758b5feeb446
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 21 18:03:09 2015 +0300

    Bluetooth: Add hdev helper variable to hci_le_create_connection_cancel
    
    The hci_le_create_connection_cancel() function needs to use the hdev
    pointer in many places so add a variable for it to avoid the need to
    dereference the hci_conn every time.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 60fe6a570800..6ef1b4cc71a6 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -68,6 +68,7 @@ static void hci_le_create_connection_cancel(struct hci_conn *conn)
 static void hci_connect_le_scan_cleanup(struct hci_conn *conn)
 {
 	struct hci_conn_params *params;
+	struct hci_dev *hdev = conn->hdev;
 	struct smp_irk *irk;
 	bdaddr_t *bdaddr;
 	u8 bdaddr_type;
@@ -76,13 +77,13 @@ static void hci_connect_le_scan_cleanup(struct hci_conn *conn)
 	bdaddr_type = conn->dst_type;
 
 	/* Check if we need to convert to identity address */
-	irk = hci_get_irk(conn->hdev, bdaddr, bdaddr_type);
+	irk = hci_get_irk(hdev, bdaddr, bdaddr_type);
 	if (irk) {
 		bdaddr = &irk->bdaddr;
 		bdaddr_type = irk->addr_type;
 	}
 
-	params = hci_explicit_connect_lookup(conn->hdev, bdaddr, bdaddr_type);
+	params = hci_explicit_connect_lookup(hdev, bdaddr, bdaddr_type);
 	if (!params)
 		return;
 
@@ -97,21 +98,21 @@ static void hci_connect_le_scan_cleanup(struct hci_conn *conn)
 
 	switch (params->auto_connect) {
 	case HCI_AUTO_CONN_EXPLICIT:
-		hci_conn_params_del(conn->hdev, bdaddr, bdaddr_type);
+		hci_conn_params_del(hdev, bdaddr, bdaddr_type);
 		/* return instead of break to avoid duplicate scan update */
 		return;
 	case HCI_AUTO_CONN_DIRECT:
 	case HCI_AUTO_CONN_ALWAYS:
-		list_add(&params->action, &conn->hdev->pend_le_conns);
+		list_add(&params->action, &hdev->pend_le_conns);
 		break;
 	case HCI_AUTO_CONN_REPORT:
-		list_add(&params->action, &conn->hdev->pend_le_reports);
+		list_add(&params->action, &hdev->pend_le_reports);
 		break;
 	default:
 		break;
 	}
 
-	hci_update_background_scan(conn->hdev);
+	hci_update_background_scan(hdev);
 }
 
 static void hci_conn_cleanup(struct hci_conn *conn)

commit 9d4c1cc15b14b4a96ddfcfac533a12f9f527c129
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 21 18:03:01 2015 +0300

    Bluetooth: Use hci_conn_hash_lookup_le() when possible
    
    Use the new hci_conn_hash_lookup_le() API to look up LE connections.
    This way we're guaranteed exact matches that also take into account
    the address type.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ec4836f243bc..60fe6a570800 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -869,7 +869,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	 * attempt, we simply update pending_sec_level and auth_type fields
 	 * and return the object found.
 	 */
-	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
+	conn = hci_conn_hash_lookup_le(hdev, dst, dst_type);
 	conn_unfinished = NULL;
 	if (conn) {
 		if (conn->state == BT_CONNECT &&
@@ -1019,13 +1019,10 @@ static bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)
 {
 	struct hci_conn *conn;
 
-	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, addr);
+	conn = hci_conn_hash_lookup_le(hdev, addr, type);
 	if (!conn)
 		return false;
 
-	if (conn->dst_type != type)
-		return false;
-
 	if (conn->state != BT_CONNECTED)
 		return false;
 
@@ -1098,7 +1095,7 @@ struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
 	 * attempt, we simply update pending_sec_level and auth_type fields
 	 * and return the object found.
 	 */
-	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
+	conn = hci_conn_hash_lookup_le(hdev, dst, dst_type);
 	if (conn) {
 		if (conn->pending_sec_level < sec_level)
 			conn->pending_sec_level = sec_level;

commit 8ce783dc5ea3af3a213ac9b4d9d2ccfeeb9c9058
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 21 15:21:31 2015 +0300

    Bluetooth: Fix missing hdev locking for LE scan cleanup
    
    The hci_conn objects don't have a dedicated lock themselves but rely
    on the caller to hold the hci_dev lock for most types of access. The
    hci_conn_timeout() function has so far sent certain HCI commands based
    on the hci_conn state which has been possible without holding the
    hci_dev lock.
    
    The recent changes to do LE scanning before connect attempts added
    even more operations to hci_conn and hci_dev from hci_conn_timeout,
    thereby exposing potential race conditions with the hci_dev and
    hci_conn states.
    
    As an example of such a race, here there's a timeout but an
    l2cap_sock_connect() call manages to race with the cleanup routine:
    
    [Oct21 08:14] l2cap_chan_timeout: chan ee4b12c0 state BT_CONNECT
    [  +0.000004] l2cap_chan_close: chan ee4b12c0 state BT_CONNECT
    [  +0.000002] l2cap_chan_del: chan ee4b12c0, conn f3141580, err 111, state BT_CONNECT
    [  +0.000002] l2cap_sock_teardown_cb: chan ee4b12c0 state BT_CONNECT
    [  +0.000005] l2cap_chan_put: chan ee4b12c0 orig refcnt 4
    [  +0.000010] hci_conn_drop: hcon f53d56e0 orig refcnt 1
    [  +0.000013] l2cap_chan_put: chan ee4b12c0 orig refcnt 3
    [  +0.000063] hci_conn_timeout: hcon f53d56e0 state BT_CONNECT
    [  +0.000049] hci_conn_params_del: addr ee:0d:30:09:53:1f (type 1)
    [  +0.000002] hci_chan_list_flush: hcon f53d56e0
    [  +0.000001] hci_chan_del: hci0 hcon f53d56e0 chan f4e7ccc0
    [  +0.004528] l2cap_sock_create: sock e708fc00
    [  +0.000023] l2cap_chan_create: chan ee4b1770
    [  +0.000001] l2cap_chan_hold: chan ee4b1770 orig refcnt 1
    [  +0.000002] l2cap_sock_init: sk ee4b3390
    [  +0.000029] l2cap_sock_bind: sk ee4b3390
    [  +0.000010] l2cap_sock_setsockopt: sk ee4b3390
    [  +0.000037] l2cap_sock_connect: sk ee4b3390
    [  +0.000002] l2cap_chan_connect: 00:02:72:d9:e5:8b -> ee:0d:30:09:53:1f (type 2) psm 0x00
    [  +0.000002] hci_get_route: 00:02:72:d9:e5:8b -> ee:0d:30:09:53:1f
    [  +0.000001] hci_dev_hold: hci0 orig refcnt 8
    [  +0.000003] hci_conn_hold: hcon f53d56e0 orig refcnt 0
    
    Above the l2cap_chan_connect() shouldn't have been able to reach the
    hci_conn f53d56e0 anymore but since hci_conn_timeout didn't do proper
    locking that's not the case. The end result is a reference to hci_conn
    that's not in the conn_hash list, resulting in list corruption when
    trying to remove it later:
    
    [Oct21 08:15] l2cap_chan_timeout: chan ee4b1770 state BT_CONNECT
    [  +0.000004] l2cap_chan_close: chan ee4b1770 state BT_CONNECT
    [  +0.000003] l2cap_chan_del: chan ee4b1770, conn f3141580, err 111, state BT_CONNECT
    [  +0.000001] l2cap_sock_teardown_cb: chan ee4b1770 state BT_CONNECT
    [  +0.000005] l2cap_chan_put: chan ee4b1770 orig refcnt 4
    [  +0.000002] hci_conn_drop: hcon f53d56e0 orig refcnt 1
    [  +0.000015] l2cap_chan_put: chan ee4b1770 orig refcnt 3
    [  +0.000038] hci_conn_timeout: hcon f53d56e0 state BT_CONNECT
    [  +0.000003] hci_chan_list_flush: hcon f53d56e0
    [  +0.000002] hci_conn_hash_del: hci0 hcon f53d56e0
    [  +0.000001] ------------[ cut here ]------------
    [  +0.000461] WARNING: CPU: 0 PID: 1782 at lib/list_debug.c:56 __list_del_entry+0x3f/0x71()
    [  +0.000839] list_del corruption, f53d56e0->prev is LIST_POISON2 (00000200)
    
    The necessary fix is unfortunately more complicated than just adding
    hci_dev_lock/unlock calls to the hci_conn_timeout() call path.
    Particularly, the hci_conn_del() API, which expects the hci_dev lock to
    be held, performs a cancel_delayed_work_sync(&hcon->disc_work) which
    would lead to a deadlock if the hci_conn_timeout() call path tries to
    acquire the same lock.
    
    This patch solves the problem by deferring the cleanup work to a
    separate work callback. To protect against the hci_dev or hci_conn
    going away meanwhile temporary references are taken with the help of
    hci_dev_hold() and hci_conn_get().
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable@vger.kernel.org # 4.3

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 2dda439c8cb8..ec4836f243bc 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -137,18 +137,51 @@ static void hci_conn_cleanup(struct hci_conn *conn)
 	hci_conn_put(conn);
 }
 
-/* This function requires the caller holds hdev->lock */
-static void hci_connect_le_scan_remove(struct hci_conn *conn)
+static void le_scan_cleanup(struct work_struct *work)
 {
-	hci_connect_le_scan_cleanup(conn);
+	struct hci_conn *conn = container_of(work, struct hci_conn,
+					     le_scan_cleanup);
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_conn *c = NULL;
 
-	/* We can't call hci_conn_del here since that would deadlock
-	 * with trying to call cancel_delayed_work_sync(&conn->disc_work).
-	 * Instead, call just hci_conn_cleanup() which contains the bare
-	 * minimum cleanup operations needed for a connection in this
-	 * state.
+	BT_DBG("%s hcon %p", hdev->name, conn);
+
+	hci_dev_lock(hdev);
+
+	/* Check that the hci_conn is still around */
+	rcu_read_lock();
+	list_for_each_entry_rcu(c, &hdev->conn_hash.list, list) {
+		if (c == conn)
+			break;
+	}
+	rcu_read_unlock();
+
+	if (c == conn) {
+		hci_connect_le_scan_cleanup(conn);
+		hci_conn_cleanup(conn);
+	}
+
+	hci_dev_unlock(hdev);
+	hci_dev_put(hdev);
+	hci_conn_put(conn);
+}
+
+static void hci_connect_le_scan_remove(struct hci_conn *conn)
+{
+	BT_DBG("%s hcon %p", conn->hdev->name, conn);
+
+	/* We can't call hci_conn_del/hci_conn_cleanup here since that
+	 * could deadlock with another hci_conn_del() call that's holding
+	 * hci_dev_lock and doing cancel_delayed_work_sync(&conn->disc_work).
+	 * Instead, grab temporary extra references to the hci_dev and
+	 * hci_conn and perform the necessary cleanup in a separate work
+	 * callback.
 	 */
-	hci_conn_cleanup(conn);
+
+	hci_dev_hold(conn->hdev);
+	hci_conn_get(conn);
+
+	schedule_work(&conn->le_scan_cleanup);
 }
 
 static void hci_acl_create_connection(struct hci_conn *conn)
@@ -580,6 +613,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,
 	INIT_DELAYED_WORK(&conn->auto_accept_work, hci_conn_auto_accept);
 	INIT_DELAYED_WORK(&conn->idle_work, hci_conn_idle);
 	INIT_DELAYED_WORK(&conn->le_conn_timeout, le_conn_timeout);
+	INIT_WORK(&conn->le_scan_cleanup, le_scan_cleanup);
 
 	atomic_set(&conn->refcnt, 0);
 

commit 5157b8a503fa834e8569c7fed06981e3d3d53db0
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Fri Oct 16 10:07:54 2015 +0300

    Bluetooth: Fix initializing conn_params in scan phase
    
    This patch makes sure that conn_params that were created just for
    explicit_connect, will get properly deleted during cleanup.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index fe99025fb649..2dda439c8cb8 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1008,15 +1008,23 @@ static int hci_explicit_conn_params_set(struct hci_request *req,
 	if (is_connected(hdev, addr, addr_type))
 		return -EISCONN;
 
-	params = hci_conn_params_add(hdev, addr, addr_type);
-	if (!params)
-		return -EIO;
+	params = hci_conn_params_lookup(hdev, addr, addr_type);
+	if (!params) {
+		params = hci_conn_params_add(hdev, addr, addr_type);
+		if (!params)
+			return -ENOMEM;
+
+		/* If we created new params, mark them to be deleted in
+		 * hci_connect_le_scan_cleanup. It's different case than
+		 * existing disabled params, those will stay after cleanup.
+		 */
+		params->auto_connect = HCI_AUTO_CONN_EXPLICIT;
+	}
 
-	/* If we created new params, or existing params were marked as disabled,
-	 * mark them to be used just once to connect.
-	 */
+	/* We're trying to connect, so make sure params are at pend_le_conns */
 	if (params->auto_connect == HCI_AUTO_CONN_DISABLED ||
-	    params->auto_connect == HCI_AUTO_CONN_REPORT) {
+	    params->auto_connect == HCI_AUTO_CONN_REPORT ||
+	    params->auto_connect == HCI_AUTO_CONN_EXPLICIT) {
 		list_del_init(&params->action);
 		list_add(&params->action, &hdev->pend_le_conns);
 	}

commit 9ad3e6ffe189a988389d88ce33101668cb2d54c6
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Oct 16 10:07:53 2015 +0300

    Bluetooth: Fix conn_params list update in hci_connect_le_scan_cleanup
    
    After clearing the params->explicit_connect variable the parameters
    may need to be either added back to the right list or potentially left
    absent from both the le_reports and the le_conns lists.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index d5c06eeab4a3..fe99025fb649 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -91,12 +91,27 @@ static void hci_connect_le_scan_cleanup(struct hci_conn *conn)
 	 * autoconnect action, remove them completely. If they are, just unmark
 	 * them as waiting for connection, by clearing explicit_connect field.
 	 */
-	if (params->auto_connect == HCI_AUTO_CONN_EXPLICIT) {
+	params->explicit_connect = false;
+
+	list_del_init(&params->action);
+
+	switch (params->auto_connect) {
+	case HCI_AUTO_CONN_EXPLICIT:
 		hci_conn_params_del(conn->hdev, bdaddr, bdaddr_type);
-	} else {
-		params->explicit_connect = false;
-		hci_update_background_scan(conn->hdev);
+		/* return instead of break to avoid duplicate scan update */
+		return;
+	case HCI_AUTO_CONN_DIRECT:
+	case HCI_AUTO_CONN_ALWAYS:
+		list_add(&params->action, &conn->hdev->pend_le_conns);
+		break;
+	case HCI_AUTO_CONN_REPORT:
+		list_add(&params->action, &conn->hdev->pend_le_reports);
+		break;
+	default:
+		break;
 	}
+
+	hci_update_background_scan(conn->hdev);
 }
 
 static void hci_conn_cleanup(struct hci_conn *conn)

commit 49c509220db990ad003060db2267b9bbb597cd94
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Oct 16 10:07:51 2015 +0300

    Bluetooth: Fix LE reconnection logic
    
    We can't use hci_explicit_connect_lookup() since that would only cover
    explicit connections, leaving normal reconnections completely
    untouched. Not using it in turn means leaving out entries in
    pend_le_reports.
    
    To fix this and simplify the logic move conn params from the reports
    list to the pend_le_conns list for the duration of an explicit
    connect. Once the connect is complete move the params back to the
    pend_le_reports list. This also means that the explicit connect lookup
    function only needs to look into the pend_le_conns list.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 4c240c1cb2cb..d5c06eeab4a3 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1000,8 +1000,8 @@ static int hci_explicit_conn_params_set(struct hci_request *req,
 	/* If we created new params, or existing params were marked as disabled,
 	 * mark them to be used just once to connect.
 	 */
-	if (params->auto_connect == HCI_AUTO_CONN_DISABLED) {
-		params->auto_connect = HCI_AUTO_CONN_EXPLICIT;
+	if (params->auto_connect == HCI_AUTO_CONN_DISABLED ||
+	    params->auto_connect == HCI_AUTO_CONN_REPORT) {
 		list_del_init(&params->action);
 		list_add(&params->action, &hdev->pend_le_conns);
 	}

commit b958f9a3e87766a88036616389eaaf3ad3bd5fc8
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Oct 16 10:07:50 2015 +0300

    Bluetooth: Fix reference counting for LE-scan based connections
    
    The code should never directly call hci_conn_hash_del since many
    cleanup & reference counting updates would be lost. Normally
    hci_conn_del is the right thing to do, but in the case of a connection
    doing LE scanning this could cause a deadlock due to doing a
    cancel_delayed_work_sync() on the same work callback that we were
    called from.
    
    Connections in the LE scanning state actually need very little cleanup
    - just a small subset of hci_conn_del. To solve the issue, refactor
    out these essential pieces into a new hci_conn_cleanup() function and
    call that from the two necessary places.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 2ebcaaa6b855..4c240c1cb2cb 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -99,12 +99,41 @@ static void hci_connect_le_scan_cleanup(struct hci_conn *conn)
 	}
 }
 
+static void hci_conn_cleanup(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	if (test_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags))
+		hci_conn_params_del(conn->hdev, &conn->dst, conn->dst_type);
+
+	hci_chan_list_flush(conn);
+
+	hci_conn_hash_del(hdev, conn);
+
+	if (hdev->notify)
+		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
+
+	hci_conn_del_sysfs(conn);
+
+	debugfs_remove_recursive(conn->debugfs);
+
+	hci_dev_put(hdev);
+
+	hci_conn_put(conn);
+}
+
 /* This function requires the caller holds hdev->lock */
 static void hci_connect_le_scan_remove(struct hci_conn *conn)
 {
 	hci_connect_le_scan_cleanup(conn);
 
-	hci_conn_hash_del(conn->hdev, conn);
+	/* We can't call hci_conn_del here since that would deadlock
+	 * with trying to call cancel_delayed_work_sync(&conn->disc_work).
+	 * Instead, call just hci_conn_cleanup() which contains the bare
+	 * minimum cleanup operations needed for a connection in this
+	 * state.
+	 */
+	hci_conn_cleanup(conn);
 }
 
 static void hci_acl_create_connection(struct hci_conn *conn)
@@ -582,27 +611,17 @@ int hci_conn_del(struct hci_conn *conn)
 		}
 	}
 
-	hci_chan_list_flush(conn);
-
 	if (conn->amp_mgr)
 		amp_mgr_put(conn->amp_mgr);
 
-	hci_conn_hash_del(hdev, conn);
-	if (hdev->notify)
-		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
-
 	skb_queue_purge(&conn->data_q);
 
-	hci_conn_del_sysfs(conn);
-
-	debugfs_remove_recursive(conn->debugfs);
-
-	if (test_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags))
-		hci_conn_params_del(conn->hdev, &conn->dst, conn->dst_type);
-
-	hci_dev_put(hdev);
-
-	hci_conn_put(conn);
+	/* Remove the connection from the list and cleanup its remaining
+	 * state. This is a separate function since for some cases like
+	 * BT_CONNECT_SCAN we *only* want the cleanup part without the
+	 * rest of hci_conn_del.
+	 */
+	hci_conn_cleanup(conn);
 
 	return 0;
 }

commit 168b8a25c0ac30f427bfe6ad547779c4c363d042
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Fri Oct 16 10:07:49 2015 +0300

    Bluetooth: Fix double scan updates
    
    When disable/enable scan command is issued twice, some controllers
    will return an error for the second request, i.e. requests with this
    command will fail on some controllers, and succeed on others.
    
    This patch makes sure that unnecessary scan disable/enable commands
    are not issued.
    
    When adding device to the auto connect whitelist when there is pending
    connect attempt, there is no need to update scan.
    
    hci_connect_le_scan_cleanup is conditionally executing
    hci_conn_params_del, that is calling hci_update_background_scan. Make
    the other case also update scan, and remove reduntand call from
    hci_connect_le_scan_remove.
    
    When stopping interleaved discovery the state should be set to stopped
    only when both LE scanning and discovery has stopped.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b4548c739a64..2ebcaaa6b855 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -91,10 +91,12 @@ static void hci_connect_le_scan_cleanup(struct hci_conn *conn)
 	 * autoconnect action, remove them completely. If they are, just unmark
 	 * them as waiting for connection, by clearing explicit_connect field.
 	 */
-	if (params->auto_connect == HCI_AUTO_CONN_EXPLICIT)
+	if (params->auto_connect == HCI_AUTO_CONN_EXPLICIT) {
 		hci_conn_params_del(conn->hdev, bdaddr, bdaddr_type);
-	else
+	} else {
 		params->explicit_connect = false;
+		hci_update_background_scan(conn->hdev);
+	}
 }
 
 /* This function requires the caller holds hdev->lock */
@@ -103,7 +105,6 @@ static void hci_connect_le_scan_remove(struct hci_conn *conn)
 	hci_connect_le_scan_cleanup(conn);
 
 	hci_conn_hash_del(conn->hdev, conn);
-	hci_update_background_scan(conn->hdev);
 }
 
 static void hci_acl_create_connection(struct hci_conn *conn)

commit cc2b6911a205b327b29c1d771925f8ab2f80295f
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Fri Aug 7 20:22:55 2015 +0200

    Bluetooth: timeout handling in new connect procedure
    
    Currently, when trying to connect to already paired device that just
    rotated its RPA MAC address, old address would be used and connection
    would fail. In order to fix that, kernel must scan and receive
    advertisement with fresh RPA before connecting.
    
    This patch makes sure that when new procedure is in use, and we're stuck
    in scan phase because no advertisement was received and timeout happened,
    or app decided to close socket, scan whitelist gets properly cleaned up.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 85c6aa5d5bbc..b4548c739a64 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -382,8 +382,12 @@ static void hci_conn_timeout(struct work_struct *work)
 		if (conn->out) {
 			if (conn->type == ACL_LINK)
 				hci_acl_create_connection_cancel(conn);
-			else if (conn->type == LE_LINK)
-				hci_le_create_connection_cancel(conn);
+			else if (conn->type == LE_LINK) {
+				if (test_bit(HCI_CONN_SCANNING, &conn->flags))
+					hci_connect_le_scan_remove(conn);
+				else
+					hci_le_create_connection_cancel(conn);
+			}
 		} else if (conn->type == SCO_LINK || conn->type == ESCO_LINK) {
 			hci_reject_sco(conn);
 		}

commit 28a667c9c279df5a6467842ee2b3b73ddf874732
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Fri Aug 7 20:22:54 2015 +0200

    Bluetooth: advertisement handling in new connect procedure
    
    Currently, when trying to connect to already paired device that just
    rotated its RPA MAC address, old address would be used and connection
    would fail. In order to fix that, kernel must scan and receive
    advertisement with fresh RPA before connecting.
    
    This path makes sure that after advertisement is received from device that
    we try to connect to, it is properly handled in check_pending_le_conn and
    trigger connect attempt.
    
    It also modifies hci_le_connect to make sure that connect attempt will be
    properly continued.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 534feb7956a3..85c6aa5d5bbc 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -679,15 +679,18 @@ static void create_le_conn_complete(struct hci_dev *hdev, u8 status, u16 opcode)
 {
 	struct hci_conn *conn;
 
-	if (status == 0)
-		return;
+	hci_dev_lock(hdev);
+
+	conn = hci_lookup_le_connect(hdev);
+
+	if (!status) {
+		hci_connect_le_scan_cleanup(conn);
+		goto done;
+	}
 
 	BT_ERR("HCI request failed to create LE connection: status 0x%2.2x",
 	       status);
 
-	hci_dev_lock(hdev);
-
-	conn = hci_lookup_le_connect(hdev);
 	if (!conn)
 		goto done;
 
@@ -727,6 +730,7 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	hci_req_add(req, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
 
 	conn->state = BT_CONNECT;
+	clear_bit(HCI_CONN_SCANNING, &conn->flags);
 }
 
 static void hci_req_directed_advertising(struct hci_request *req,
@@ -770,7 +774,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				u8 role)
 {
 	struct hci_conn_params *params;
-	struct hci_conn *conn;
+	struct hci_conn *conn, *conn_unfinished;
 	struct smp_irk *irk;
 	struct hci_request req;
 	int err;
@@ -793,9 +797,17 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	 * and return the object found.
 	 */
 	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
+	conn_unfinished = NULL;
 	if (conn) {
-		conn->pending_sec_level = sec_level;
-		goto done;
+		if (conn->state == BT_CONNECT &&
+		    test_bit(HCI_CONN_SCANNING, &conn->flags)) {
+			BT_DBG("will continue unfinished conn %pMR", dst);
+			conn_unfinished = conn;
+		} else {
+			if (conn->pending_sec_level < sec_level)
+				conn->pending_sec_level = sec_level;
+			goto done;
+		}
 	}
 
 	/* Since the controller supports only one LE connection attempt at a
@@ -808,10 +820,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	 * resolving key, the connection needs to be established
 	 * to a resolvable random address.
 	 *
-	 * This uses the cached random resolvable address from
-	 * a previous scan. When no cached address is available,
-	 * try connecting to the identity address instead.
-	 *
 	 * Storing the resolvable random address is required here
 	 * to handle connection failures. The address will later
 	 * be resolved back into the original identity address
@@ -823,15 +831,23 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		dst_type = ADDR_LE_DEV_RANDOM;
 	}
 
-	conn = hci_conn_add(hdev, LE_LINK, dst, role);
+	if (conn_unfinished) {
+		conn = conn_unfinished;
+		bacpy(&conn->dst, dst);
+	} else {
+		conn = hci_conn_add(hdev, LE_LINK, dst, role);
+	}
+
 	if (!conn)
 		return ERR_PTR(-ENOMEM);
 
 	conn->dst_type = dst_type;
 	conn->sec_level = BT_SECURITY_LOW;
-	conn->pending_sec_level = sec_level;
 	conn->conn_timeout = conn_timeout;
 
+	if (!conn_unfinished)
+		conn->pending_sec_level = sec_level;
+
 	hci_req_init(&req, hdev);
 
 	/* Disable advertising if we're active. For master role
@@ -896,7 +912,13 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	}
 
 done:
-	hci_conn_hold(conn);
+	/* If this is continuation of connect started by hci_connect_le_scan,
+	 * it already called hci_conn_hold and calling it again would mess the
+	 * counter.
+	 */
+	if (!conn_unfinished)
+		hci_conn_hold(conn);
+
 	return conn;
 }
 

commit f75113a26008980ca13834fb6573145523596776
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Fri Aug 7 20:22:53 2015 +0200

    Bluetooth: add hci_connect_le_scan
    
    Currently, when trying to connect to already paired device that just
    rotated its RPA MAC address, old address would be used and connection
    would fail. In order to fix that, kernel must scan and receive
    advertisement with fresh RPA before connecting.
    
    This patch adds hci_connect_le_scan with dependencies, new method that
    will be used to connect to remote LE devices. Instead of just sending
    connect request, it adds a device to whitelist. Later patches will make
    use of this whitelist to send conenct request when advertisement is
    received, and properly handle timeouts.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 0b4d919c8d96..534feb7956a3 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -64,6 +64,48 @@ static void hci_le_create_connection_cancel(struct hci_conn *conn)
 	hci_send_cmd(conn->hdev, HCI_OP_LE_CREATE_CONN_CANCEL, 0, NULL);
 }
 
+/* This function requires the caller holds hdev->lock */
+static void hci_connect_le_scan_cleanup(struct hci_conn *conn)
+{
+	struct hci_conn_params *params;
+	struct smp_irk *irk;
+	bdaddr_t *bdaddr;
+	u8 bdaddr_type;
+
+	bdaddr = &conn->dst;
+	bdaddr_type = conn->dst_type;
+
+	/* Check if we need to convert to identity address */
+	irk = hci_get_irk(conn->hdev, bdaddr, bdaddr_type);
+	if (irk) {
+		bdaddr = &irk->bdaddr;
+		bdaddr_type = irk->addr_type;
+	}
+
+	params = hci_explicit_connect_lookup(conn->hdev, bdaddr, bdaddr_type);
+	if (!params)
+		return;
+
+	/* The connection attempt was doing scan for new RPA, and is
+	 * in scan phase. If params are not associated with any other
+	 * autoconnect action, remove them completely. If they are, just unmark
+	 * them as waiting for connection, by clearing explicit_connect field.
+	 */
+	if (params->auto_connect == HCI_AUTO_CONN_EXPLICIT)
+		hci_conn_params_del(conn->hdev, bdaddr, bdaddr_type);
+	else
+		params->explicit_connect = false;
+}
+
+/* This function requires the caller holds hdev->lock */
+static void hci_connect_le_scan_remove(struct hci_conn *conn)
+{
+	hci_connect_le_scan_cleanup(conn);
+
+	hci_conn_hash_del(conn->hdev, conn);
+	hci_update_background_scan(conn->hdev);
+}
+
 static void hci_acl_create_connection(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
@@ -858,6 +900,138 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	return conn;
 }
 
+static void hci_connect_le_scan_complete(struct hci_dev *hdev, u8 status,
+					 u16 opcode)
+{
+	struct hci_conn *conn;
+
+	if (!status)
+		return;
+
+	BT_ERR("Failed to add device to auto conn whitelist: status 0x%2.2x",
+	       status);
+
+	hci_dev_lock(hdev);
+
+	conn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
+	if (conn)
+		hci_le_conn_failed(conn, status);
+
+	hci_dev_unlock(hdev);
+}
+
+static bool is_connected(struct hci_dev *hdev, bdaddr_t *addr, u8 type)
+{
+	struct hci_conn *conn;
+
+	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, addr);
+	if (!conn)
+		return false;
+
+	if (conn->dst_type != type)
+		return false;
+
+	if (conn->state != BT_CONNECTED)
+		return false;
+
+	return true;
+}
+
+/* This function requires the caller holds hdev->lock */
+static int hci_explicit_conn_params_set(struct hci_request *req,
+					bdaddr_t *addr, u8 addr_type)
+{
+	struct hci_dev *hdev = req->hdev;
+	struct hci_conn_params *params;
+
+	if (is_connected(hdev, addr, addr_type))
+		return -EISCONN;
+
+	params = hci_conn_params_add(hdev, addr, addr_type);
+	if (!params)
+		return -EIO;
+
+	/* If we created new params, or existing params were marked as disabled,
+	 * mark them to be used just once to connect.
+	 */
+	if (params->auto_connect == HCI_AUTO_CONN_DISABLED) {
+		params->auto_connect = HCI_AUTO_CONN_EXPLICIT;
+		list_del_init(&params->action);
+		list_add(&params->action, &hdev->pend_le_conns);
+	}
+
+	params->explicit_connect = true;
+	__hci_update_background_scan(req);
+
+	BT_DBG("addr %pMR (type %u) auto_connect %u", addr, addr_type,
+	       params->auto_connect);
+
+	return 0;
+}
+
+/* This function requires the caller holds hdev->lock */
+struct hci_conn *hci_connect_le_scan(struct hci_dev *hdev, bdaddr_t *dst,
+				     u8 dst_type, u8 sec_level,
+				     u16 conn_timeout, u8 role)
+{
+	struct hci_conn *conn;
+	struct hci_request req;
+	int err;
+
+	/* Let's make sure that le is enabled.*/
+	if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {
+		if (lmp_le_capable(hdev))
+			return ERR_PTR(-ECONNREFUSED);
+
+		return ERR_PTR(-EOPNOTSUPP);
+	}
+
+	/* Some devices send ATT messages as soon as the physical link is
+	 * established. To be able to handle these ATT messages, the user-
+	 * space first establishes the connection and then starts the pairing
+	 * process.
+	 *
+	 * So if a hci_conn object already exists for the following connection
+	 * attempt, we simply update pending_sec_level and auth_type fields
+	 * and return the object found.
+	 */
+	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
+	if (conn) {
+		if (conn->pending_sec_level < sec_level)
+			conn->pending_sec_level = sec_level;
+		goto done;
+	}
+
+	BT_DBG("requesting refresh of dst_addr");
+
+	conn = hci_conn_add(hdev, LE_LINK, dst, role);
+	if (!conn)
+		return ERR_PTR(-ENOMEM);
+
+	hci_req_init(&req, hdev);
+
+	if (hci_explicit_conn_params_set(&req, dst, dst_type) < 0)
+		return ERR_PTR(-EBUSY);
+
+	conn->state = BT_CONNECT;
+	set_bit(HCI_CONN_SCANNING, &conn->flags);
+
+	err = hci_req_run(&req, hci_connect_le_scan_complete);
+	if (err && err != -ENODATA) {
+		hci_conn_del(conn);
+		return ERR_PTR(err);
+	}
+
+	conn->dst_type = dst_type;
+	conn->sec_level = BT_SECURITY_LOW;
+	conn->pending_sec_level = sec_level;
+	conn->conn_timeout = conn_timeout;
+
+done:
+	hci_conn_hold(conn);
+	return conn;
+}
+
 struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 				 u8 sec_level, u8 auth_type)
 {

commit e7d9ab731ac7babaf2e1b7b5e2280f5f555d263f
Author: Jakub Pawlowski <jpawlowski@google.com>
Date:   Fri Aug 7 20:22:52 2015 +0200

    Bluetooth: add hci_lookup_le_connect
    
    This patch adds hci_lookup_le_connect method, that will be used to check
    wether outgoing le connection attempt is in progress.
    
    Signed-off-by: Jakub Pawlowski <jpawlowski@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 2c48bf0b5afb..0b4d919c8d96 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -645,7 +645,7 @@ static void create_le_conn_complete(struct hci_dev *hdev, u8 status, u16 opcode)
 
 	hci_dev_lock(hdev);
 
-	conn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
+	conn = hci_lookup_le_connect(hdev);
 	if (!conn)
 		goto done;
 
@@ -759,8 +759,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	/* Since the controller supports only one LE connection attempt at a
 	 * time, we return -EBUSY if there is any connection attempt running.
 	 */
-	conn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
-	if (conn)
+	if (hci_lookup_le_connect(hdev))
 		return ERR_PTR(-EBUSY);
 
 	/* When given an identity address with existing identity

commit 8b76ce34c43a569f981623485c1b6c700594678e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jun 8 18:14:39 2015 +0300

    Bluetooth: Fix encryption key size handling for LTKs
    
    The encryption key size for LTKs is supposed to be applied only at the
    moment of encryption. When generating a Link Key (using LE SC) from
    the LTK the full non-shortened value should be used. This patch
    modifies the code to always keep the full value around and only apply
    the key size when passing the value to HCI.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ee5e59839b02..2c48bf0b5afb 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -276,7 +276,7 @@ u8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,
 }
 
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,
-		      __u8 ltk[16])
+		      __u8 ltk[16], __u8 key_size)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_le_start_enc cp;
@@ -288,7 +288,7 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,
 	cp.handle = cpu_to_le16(conn->handle);
 	cp.rand = rand;
 	cp.ediv = ediv;
-	memcpy(cp.ltk, ltk, sizeof(cp.ltk));
+	memcpy(cp.ltk, ltk, key_size);
 
 	hci_send_cmd(hdev, HCI_OP_LE_START_ENC, sizeof(cp), &cp);
 }

commit a358dc11d80ecaca443aa1fd2fd9d4f3425922e7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 02:11:02 2015 -0700

    Bluetooth: Introduce hci_dev_clear_flag helper macro
    
    Instead of manually coding clear_bit on hdev->dev_flags all the time,
    use hci_dev_clear_flag helper macro.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index c0fd42ceff61..ee5e59839b02 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -700,7 +700,7 @@ static void hci_req_directed_advertising(struct hci_request *req,
 	 * and write a new random address. The flag will be set back on
 	 * as soon as the SET_ADV_ENABLE HCI command completes.
 	 */
-	clear_bit(HCI_LE_ADV, &hdev->dev_flags);
+	hci_dev_clear_flag(hdev, HCI_LE_ADV);
 
 	/* Set require_privacy to false so that the remote device has a
 	 * chance of identifying us.

commit a1536da255f16f42b8f069b2769134b32558b265
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 02:11:01 2015 -0700

    Bluetooth: Introduce hci_dev_set_flag helper macro
    
    Instead of manually coding set_bit on hdev->dev_flags all the time,
    use hci_dev_set_flag helper macro.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5444e194eb4e..c0fd42ceff61 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -842,7 +842,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	 */
 	if (hci_dev_test_flag(hdev, HCI_LE_SCAN)) {
 		hci_req_add_le_scan_disable(&req);
-		set_bit(HCI_LE_SCAN_INTERRUPTED, &hdev->dev_flags);
+		hci_dev_set_flag(hdev, HCI_LE_SCAN_INTERRUPTED);
 	}
 
 	hci_req_add_le_create_conn(&req, conn);

commit d7a5a11d7fa80beb43d5f7cb421c86f9b4d21200
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Mar 13 02:11:00 2015 -0700

    Bluetooth: Introduce hci_dev_test_flag helper macro
    
    Instead of manually coding test_bit on hdev->dev_flags all the time,
    use hci_dev_test_flag helper macro.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 91ebb9cb31de..5444e194eb4e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -571,7 +571,7 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 
 	list_for_each_entry(d, &hci_dev_list, list) {
 		if (!test_bit(HCI_UP, &d->flags) ||
-		    test_bit(HCI_USER_CHANNEL, &d->dev_flags) ||
+		    hci_dev_test_flag(d, HCI_USER_CHANNEL) ||
 		    d->dev_type != HCI_BREDR)
 			continue;
 
@@ -734,7 +734,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	int err;
 
 	/* Let's make sure that le is enabled.*/
-	if (!test_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {
+	if (!hci_dev_test_flag(hdev, HCI_LE_ENABLED)) {
 		if (lmp_le_capable(hdev))
 			return ERR_PTR(-ECONNREFUSED);
 
@@ -799,7 +799,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	 * anyway have to disable it in order to start directed
 	 * advertising.
 	 */
-	if (test_bit(HCI_LE_ADV, &hdev->dev_flags)) {
+	if (hci_dev_test_flag(hdev, HCI_LE_ADV)) {
 		u8 enable = 0x00;
 		hci_req_add(&req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),
 			    &enable);
@@ -810,7 +810,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		/* If we're active scanning most controllers are unable
 		 * to initiate advertising. Simply reject the attempt.
 		 */
-		if (test_bit(HCI_LE_SCAN, &hdev->dev_flags) &&
+		if (hci_dev_test_flag(hdev, HCI_LE_SCAN) &&
 		    hdev->le_scan_type == LE_SCAN_ACTIVE) {
 			skb_queue_purge(&req.cmd_q);
 			hci_conn_del(conn);
@@ -840,7 +840,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	 * handler for scan disabling knows to set the correct discovery
 	 * state.
 	 */
-	if (test_bit(HCI_LE_SCAN, &hdev->dev_flags)) {
+	if (hci_dev_test_flag(hdev, HCI_LE_SCAN)) {
 		hci_req_add_le_scan_disable(&req);
 		set_bit(HCI_LE_SCAN_INTERRUPTED, &hdev->dev_flags);
 	}
@@ -864,7 +864,7 @@ struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 {
 	struct hci_conn *acl;
 
-	if (!test_bit(HCI_BREDR_ENABLED, &hdev->dev_flags)) {
+	if (!hci_dev_test_flag(hdev, HCI_BREDR_ENABLED)) {
 		if (lmp_bredr_capable(hdev))
 			return ERR_PTR(-ECONNREFUSED);
 
@@ -942,7 +942,7 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 	 * Connections is used and the link is encrypted with AES-CCM
 	 * using a P-256 authenticated combination key.
 	 */
-	if (test_bit(HCI_SC_ONLY, &conn->hdev->flags)) {
+	if (hci_dev_test_flag(conn->hdev, HCI_SC_ONLY)) {
 		if (!hci_conn_sc_enabled(conn) ||
 		    !test_bit(HCI_CONN_AES_CCM, &conn->flags) ||
 		    conn->key_type != HCI_LK_AUTH_COMBINATION_P256)

commit 3a6d576be9fe02b0c3ffa89ef6eac048e14eec84
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 18 14:53:58 2015 +0200

    Bluetooth: Convert disconn_cfm to be triggered through hci_cb
    
    This patch moves all the disconn_cfm callbacks to be based on the hci_cb
    list. This means making l2cap_disconn_cfm private to l2cap_core.c and
    sco_conn_cb private to sco.c respectively. Since the hci_conn type
    filtering isn't done any more on the wrapper level the callbacks
    themselves need to check that they were passed a relevant type of
    connection.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e9206734e024..91ebb9cb31de 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1151,7 +1151,7 @@ void hci_conn_hash_flush(struct hci_dev *hdev)
 	list_for_each_entry_safe(c, n, &h->list, list) {
 		c->state = BT_CLOSED;
 
-		hci_proto_disconn_cfm(c, HCI_ERROR_LOCAL_HOST_TERM);
+		hci_disconn_cfm(c, HCI_ERROR_LOCAL_HOST_TERM);
 		hci_conn_del(c);
 	}
 }

commit 539c496d88f7f96d42abde4e9d901c8f8167d615
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Feb 18 14:53:57 2015 +0200

    Bluetooth: Convert connect_cfm to be triggered through hci_cb
    
    This patch moves all the connect_cfm callbacks to be based on the hci_cb
    list. This means making l2cap_connect_cfm private to l2cap_core.c and
    sco_connect_cb private to sco.c respectively. Since the hci_conn type
    filtering isn't done any more on the wrapper level the callbacks
    themselves need to check that they were passed a relevant type of
    connection.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e3263b61bcf3..e9206734e024 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -309,7 +309,7 @@ void hci_sco_setup(struct hci_conn *conn, __u8 status)
 		else
 			hci_add_sco(sco, conn->handle);
 	} else {
-		hci_proto_connect_cfm(sco, status);
+		hci_connect_cfm(sco, status);
 		hci_conn_del(sco);
 	}
 }
@@ -618,7 +618,7 @@ void hci_le_conn_failed(struct hci_conn *conn, u8 status)
 	mgmt_connect_failed(hdev, &conn->dst, conn->type, conn->dst_type,
 			    status);
 
-	hci_proto_connect_cfm(conn, status);
+	hci_connect_cfm(conn, status);
 
 	hci_conn_del(conn);
 

commit c411110e1f13abd64886c8abdf6f31c10136969f
Author: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
Date:   Wed Feb 11 12:31:41 2015 +0100

    Bluetooth: Improve error handling in connect acl
    
    With this patch -EOPNOTSUPP will be returned by hci_connect_acl for LE
    only controllers. If it is dual device with disabled BREDR -ECONNREFUSED
    will be returned
    
    Signed-off-by: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 409c05e9e00a..e3263b61bcf3 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -864,8 +864,12 @@ struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 {
 	struct hci_conn *acl;
 
-	if (!test_bit(HCI_BREDR_ENABLED, &hdev->dev_flags))
+	if (!test_bit(HCI_BREDR_ENABLED, &hdev->dev_flags)) {
+		if (lmp_bredr_capable(hdev))
+			return ERR_PTR(-ECONNREFUSED);
+
 		return ERR_PTR(-EOPNOTSUPP);
+	}
 
 	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (!acl) {

commit 152d386e111fed3fee5fe888f38b0ae73ea15400
Author: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
Date:   Wed Feb 11 12:31:40 2015 +0100

    Bluetooth: Do not allow LE connection if LE is not enabled
    
    Kernel gives possibility to enable/disable LE host support.
    There is flag HCI_LE_ENABLED which is set when this support is enabled
    and some parts of the code checks this flag e.g. SMP
    However it is still possible to make LE connection if LE Host support is
    disabled, what might be confused for remote device.
    This patch makes sure that kernel will not send HCI LE Create Connection
    if LE HOST support is not enabled.
    
    Signed-off-by: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index c9b8fa544785..409c05e9e00a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -733,6 +733,14 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	struct hci_request req;
 	int err;
 
+	/* Let's make sure that le is enabled.*/
+	if (!test_bit(HCI_LE_ENABLED, &hdev->dev_flags)) {
+		if (lmp_le_capable(hdev))
+			return ERR_PTR(-ECONNREFUSED);
+
+		return ERR_PTR(-EOPNOTSUPP);
+	}
+
 	/* Some devices send ATT messages as soon as the physical link is
 	 * established. To be able to handle these ATT messages, the user-
 	 * space first establishes the connection and then starts the pairing

commit 0026b6551b51a9520b912f41b8d447b89a825f5a
Author: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
Date:   Sun Jan 4 16:55:14 2015 +0100

    Bluetooth: Remove unused function
    
    Remove the function hci_conn_change_link_key() that is not used anywhere.
    
    This was partially found by using a static code analysis program called
    cppcheck.
    
    Signed-off-by: Rickard Strandqvist <rickard_strandqvist@spectrumdigital.se>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 2e724e0b75b9..c9b8fa544785 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1084,21 +1084,6 @@ int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)
 }
 EXPORT_SYMBOL(hci_conn_check_secure);
 
-/* Change link key */
-int hci_conn_change_link_key(struct hci_conn *conn)
-{
-	BT_DBG("hcon %p", conn);
-
-	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
-		struct hci_cp_change_conn_link_key cp;
-		cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(conn->hdev, HCI_OP_CHANGE_CONN_LINK_KEY,
-			     sizeof(cp), &cp);
-	}
-
-	return 0;
-}
-
 /* Switch role */
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role)
 {

commit 1904a853fae40ee61bed7c231fc5bd2158984441
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jan 11 13:50:44 2015 -0800

    Bluetooth: Add opcode parameter to hci_req_complete_t callback
    
    When hci_req_run() calls its provided complete function and one of the
    HCI commands in the sequence fails, then provide the opcode of failing
    command. In case of success HCI_OP_NOP is provided since all commands
    completed.
    
    This patch fixes the prototype of hci_req_complete_t and all its users.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 75240aaca101..2e724e0b75b9 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -633,7 +633,7 @@ void hci_le_conn_failed(struct hci_conn *conn, u8 status)
 	mgmt_reenable_advertising(hdev);
 }
 
-static void create_le_conn_complete(struct hci_dev *hdev, u8 status)
+static void create_le_conn_complete(struct hci_dev *hdev, u8 status, u16 opcode)
 {
 	struct hci_conn *conn;
 

commit 23b9ceb74f8e46bddd61a1e2afd9317221be74b7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Dec 20 17:13:41 2014 +0100

    Bluetooth: Create debugfs directory for each connection handle
    
    For every internal representation of a Bluetooth connection which is
    identified by hci_conn, create a debugfs directory with the handle
    number as directory name.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 4405fb352c70..75240aaca101 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -25,6 +25,7 @@
 /* Bluetooth HCI connection handling. */
 
 #include <linux/export.h>
+#include <linux/debugfs.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
@@ -547,6 +548,8 @@ int hci_conn_del(struct hci_conn *conn)
 
 	hci_conn_del_sysfs(conn);
 
+	debugfs_remove_recursive(conn->debugfs);
+
 	if (test_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags))
 		hci_conn_params_del(conn->hdev, &conn->dst, conn->dst_type);
 

commit 0857dd3bed62d8f905f61a399d1ed76464b5270f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Dec 19 13:40:20 2014 +0200

    Bluetooth: Split hci_request helpers to hci_request.[ch]
    
    None of the hci_request related things in net/bluetooth/hci_core.h are
    needed anywhere outside of the core bluetooth module. This patch creates
    a new net/bluetooth/hci_request.c file with its corresponding h-file and
    moves the functionality there from hci_core.c and hci_core.h.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index fe18825cc8a4..4405fb352c70 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -30,6 +30,7 @@
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/l2cap.h>
 
+#include "hci_request.h"
 #include "smp.h"
 #include "a2mp.h"
 

commit 9437d2edc39ed8f7e40536281ee53ec3fd5a14ca
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Dec 7 20:13:17 2014 +0100

    Bluetooth: Fix generation of non-resolvable private addresses
    
    When the host decides to use a non-resolvable private address, it
    must ensure that this generated address does not match the public
    address of the controller. Add an extra check to ensure this required
    behavior.
    
    In addition rename the variable from urpa to nrpa and fix all of the
    comments in the code that use the term unresolvable instead of the
    term non-resolvable as used in the Bluetooth specification.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 79d84b88b8f0..fe18825cc8a4 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -661,7 +661,7 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	memset(&cp, 0, sizeof(cp));
 
 	/* Update random address, but set require_privacy to false so
-	 * that we never connect with an unresolvable address.
+	 * that we never connect with an non-resolvable address.
 	 */
 	if (hci_update_random_address(req, false, &own_addr_type))
 		return;

commit ebf86aa3aeaa4e9f434dacdd0a1d851a6c0332f8
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Dec 5 13:36:08 2014 +0200

    Bluetooth: Fix initializing hci_conn RSSI to invalid value
    
    When we create the hci_conn object we should properly initialize the
    RSSI to HCI_RSSI_INVALID.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 96887ae8375b..79d84b88b8f0 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -449,6 +449,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,
 	conn->io_capability = hdev->io_capability;
 	conn->remote_auth = 0xff;
 	conn->key_type = 0xff;
+	conn->rssi = HCI_RSSI_INVALID;
 	conn->tx_power = HCI_TX_POWER_INVALID;
 	conn->max_tx_power = HCI_TX_POWER_INVALID;
 

commit 0b1db38ca26b322296cbd141f3080eccfe1cc3e1
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Oct 28 22:23:27 2014 +0100

    Bluetooth: Fix check for direct advertising
    
    These days we allow simultaneous LE scanning and advertising. Checking
    for whether advertising is enabled or not is therefore not a reliable
    way to determine whether directed advertising was used to trigger the
    connection creation. The appropriate place to check (instead of the hdev
    context) is the connection role that's stored in the hci_conn. This
    patch fixes such a check in le_conn_timeout() which could otherwise lead
    to incorrect HCI commands being sent.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable@vger.kernel.org # 3.16.x

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 74b8e2421e96..96887ae8375b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -416,7 +416,7 @@ static void le_conn_timeout(struct work_struct *work)
 	 * happen with broken hardware or if low duty cycle was used
 	 * (which doesn't have a timeout of its own).
 	 */
-	if (test_bit(HCI_ADVERTISING, &hdev->dev_flags)) {
+	if (conn->role == HCI_ROLE_SLAVE) {
 		u8 enable = 0x00;
 		hci_send_cmd(hdev, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),
 			     &enable);

commit 980ffc0a2cec2c37589cc97993e1ad17252f4f47
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Oct 28 22:23:26 2014 +0100

    Bluetooth: Fix LE connection timeout deadlock
    
    The le_conn_timeout() may call hci_le_conn_failed() which in turn may
    call hci_conn_del(). Trying to use the _sync variant for cancelling the
    conn timeout from hci_conn_del() could therefore result in a deadlock.
    This patch converts hci_conn_del() to use the non-sync variant so the
    deadlock is not possible.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable@vger.kernel.org # 3.16.x

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6a3225bf7bac..74b8e2421e96 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -518,7 +518,7 @@ int hci_conn_del(struct hci_conn *conn)
 		/* Unacked frames */
 		hdev->acl_cnt += conn->sent;
 	} else if (conn->type == LE_LINK) {
-		cancel_delayed_work_sync(&conn->le_conn_timeout);
+		cancel_delayed_work(&conn->le_conn_timeout);
 
 		if (hdev->le_pkts)
 			hdev->le_cnt += conn->sent;

commit 4f639edef73c15ddb1534e39f4bd6234ee04e4f8
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat Oct 25 10:48:58 2014 +0200

    Bluetooth: fix shadow warning in hci_disconnect()
    
    use clkoff_cp for hci_cp_read_clock_offset instead of cp
    (already defined above).
    
    Suggested-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 11aac06d53ce..6a3225bf7bac 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -141,10 +141,11 @@ int hci_disconnect(struct hci_conn *conn, __u8 reason)
 	 */
 	if (conn->type == ACL_LINK && conn->role == HCI_ROLE_MASTER) {
 		struct hci_dev *hdev = conn->hdev;
-		struct hci_cp_read_clock_offset cp;
+		struct hci_cp_read_clock_offset clkoff_cp;
 
-		cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET, sizeof(cp), &cp);
+		clkoff_cp.handle = cpu_to_le16(conn->handle);
+		hci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET, sizeof(clkoff_cp),
+			     &clkoff_cp);
 	}
 
 	conn->state = BT_DISCONN;

commit 89cbb0638e9b7ba6fab02558f47a29f144df1a19
Author: Alfonso Acosta <fons@spotify.com>
Date:   Sat Oct 11 21:44:47 2014 +0000

    Bluetooth: Defer connection-parameter removal when unpairing
    
    Systematically removing the LE connection parameters and autoconnect
    action is inconvenient for rebonding without disconnecting from
    userland (i.e. unpairing followed by repairing without
    disconnecting). The parameters will be lost after unparing and
    userland needs to take care of book-keeping them and re-adding them.
    
    This patch allows userland to forget about parameter management when
    rebonding without disconnecting. It defers clearing the connection
    parameters when unparing without disconnecting, giving a chance of
    keeping the parameters if a repairing happens before the connection is
    closed.
    
    Signed-off-by: Alfonso Acosta <fons@spotify.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b9517bd17190..11aac06d53ce 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -544,6 +544,9 @@ int hci_conn_del(struct hci_conn *conn)
 
 	hci_conn_del_sysfs(conn);
 
+	if (test_bit(HCI_CONN_PARAM_REMOVAL_PEND, &conn->flags))
+		hci_conn_params_del(conn->hdev, &conn->dst, conn->dst_type);
+
 	hci_dev_put(hdev);
 
 	hci_conn_put(conn);

commit 565766b087a6d6ff257f5b79c8ceda0188c9169f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Sep 25 09:48:01 2014 +0300

    Bluetooth: Rename sco_param_wideband table to esco_param_msbc
    
    The sco_param_wideband table represents the eSCO parameters for
    specifically mSBC encoding. This patch renames the table to the more
    descriptive esco_param_msbc name.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 06047142797c..b9517bd17190 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -52,7 +52,7 @@ static const struct sco_param sco_param_cvsd[] = {
 	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff,	0xff }, /* D0 */
 };
 
-static const struct sco_param sco_param_wideband[] = {
+static const struct sco_param esco_param_msbc[] = {
 	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000d,	0x02 }, /* T2 */
 	{ EDR_ESCO_MASK | ESCO_EV3,   0x0008,	0x02 }, /* T1 */
 };
@@ -207,9 +207,9 @@ bool hci_setup_sync(struct hci_conn *conn, __u16 handle)
 
 	switch (conn->setting & SCO_AIRMODE_MASK) {
 	case SCO_AIRMODE_TRANSP:
-		if (conn->attempt > ARRAY_SIZE(sco_param_wideband))
+		if (conn->attempt > ARRAY_SIZE(esco_param_msbc))
 			return false;
-		param = &sco_param_wideband[conn->attempt - 1];
+		param = &esco_param_msbc[conn->attempt - 1];
 		break;
 	case SCO_AIRMODE_CVSD:
 		if (lmp_esco_capable(conn->link)) {

commit c7da579763f29cf45a861ad4c339aba590d8b80d
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Sep 24 22:41:46 2014 +0300

    Bluetooth: Add retransmission effort into SCO parameter table
    
    It is expected that new parameter combinations will have the
    retransmission effort value different between some entries (mainly
    because of the new S4 configuration added by HFP 1.7), so it makes sense
    to move it into the table instead of having it hard coded based on the
    selected SCO_AIRMODE_*.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 445829cd363c..06047142797c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -36,24 +36,25 @@
 struct sco_param {
 	u16 pkt_type;
 	u16 max_latency;
+	u8  retrans_effort;
 };
 
 static const struct sco_param esco_param_cvsd[] = {
-	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000a }, /* S3 */
-	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x0007 }, /* S2 */
-	{ EDR_ESCO_MASK | ESCO_EV3,   0x0007 }, /* S1 */
-	{ EDR_ESCO_MASK | ESCO_HV3,   0xffff }, /* D1 */
-	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff }, /* D0 */
+	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000a,	0x01 }, /* S3 */
+	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x0007,	0x01 }, /* S2 */
+	{ EDR_ESCO_MASK | ESCO_EV3,   0x0007,	0x01 }, /* S1 */
+	{ EDR_ESCO_MASK | ESCO_HV3,   0xffff,	0x01 }, /* D1 */
+	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff,	0x01 }, /* D0 */
 };
 
 static const struct sco_param sco_param_cvsd[] = {
-	{ EDR_ESCO_MASK | ESCO_HV3,   0xffff }, /* D1 */
-	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff }, /* D0 */
+	{ EDR_ESCO_MASK | ESCO_HV3,   0xffff,	0xff }, /* D1 */
+	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff,	0xff }, /* D0 */
 };
 
 static const struct sco_param sco_param_wideband[] = {
-	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000d }, /* T2 */
-	{ EDR_ESCO_MASK | ESCO_EV3,   0x0008 }, /* T1 */
+	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000d,	0x02 }, /* T2 */
+	{ EDR_ESCO_MASK | ESCO_EV3,   0x0008,	0x02 }, /* T1 */
 };
 
 static void hci_le_create_connection_cancel(struct hci_conn *conn)
@@ -208,19 +209,16 @@ bool hci_setup_sync(struct hci_conn *conn, __u16 handle)
 	case SCO_AIRMODE_TRANSP:
 		if (conn->attempt > ARRAY_SIZE(sco_param_wideband))
 			return false;
-		cp.retrans_effort = 0x02;
 		param = &sco_param_wideband[conn->attempt - 1];
 		break;
 	case SCO_AIRMODE_CVSD:
 		if (lmp_esco_capable(conn->link)) {
 			if (conn->attempt > ARRAY_SIZE(esco_param_cvsd))
 				return false;
-			cp.retrans_effort = 0x01;
 			param = &esco_param_cvsd[conn->attempt - 1];
 		} else {
 			if (conn->attempt > ARRAY_SIZE(sco_param_cvsd))
 				return false;
-			cp.retrans_effort = 0xff;
 			param = &sco_param_cvsd[conn->attempt - 1];
 		}
 		break;
@@ -228,6 +226,7 @@ bool hci_setup_sync(struct hci_conn *conn, __u16 handle)
 		return false;
 	}
 
+	cp.retrans_effort = param->retrans_effort;
 	cp.pkt_type = __cpu_to_le16(param->pkt_type);
 	cp.max_latency = __cpu_to_le16(param->max_latency);
 

commit d41c15cf95bd91b9c333f6f749670e22c8a47ad9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Sep 24 13:14:46 2014 +0300

    Bluetooth: Fix reason code used for rejecting SCO connections
    
    The core specification defines valid values for the
    HCI_Reject_Synchronous_Connection_Request command to be 0x0D-0x0F. So
    far the code has been using HCI_ERROR_REMOTE_USER_TERM (0x13) which is
    not a valid value and is therefore being rejected by some controllers:
    
     > HCI Event: Connect Request (0x04) plen 10
            bdaddr 40:6F:2A:6A:E5:E0 class 0x000000 type eSCO
     < HCI Command: Reject Synchronous Connection (0x01|0x002a) plen 7
            bdaddr 40:6F:2A:6A:E5:E0 reason 0x13
            Reason: Remote User Terminated Connection
     > HCI Event: Command Status (0x0f) plen 4
            Reject Synchronous Connection (0x01|0x002a) status 0x12 ncmd 1
            Error: Invalid HCI Command Parameters
    
    This patch introduces a new define for a value from the valid range
    (0x0d == Connection Rejected Due To Limited Resources) and uses it
    instead for rejecting incoming connections.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 22b253750f78..445829cd363c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -121,7 +121,7 @@ static void hci_reject_sco(struct hci_conn *conn)
 {
 	struct hci_cp_reject_sync_conn_req cp;
 
-	cp.reason = HCI_ERROR_REMOTE_USER_TERM;
+	cp.reason = HCI_ERROR_REJ_LIMITED_RESOURCES;
 	bacpy(&cp.bdaddr, &conn->dst);
 
 	hci_send_cmd(conn->hdev, HCI_OP_REJECT_SYNC_CONN_REQ, sizeof(cp), &cp);

commit 48e68ff5e55af6907d3f90233e5c4d5601a628a6
Author: Bernhard Thaler <bernhard.thaler@r-it.at>
Date:   Tue Sep 23 11:01:07 2014 +0200

    Bluetooth: Check for SCO type before setting retransmission effort
    
    SCO connection cannot be setup to devices that do not support retransmission.
    Patch based on http://permalink.gmane.org/gmane.linux.bluez.kernel/7779 and
    adapted for this kernel version.
    
    Code changed to check SCO/eSCO type before setting retransmission effort
    and max. latency. The purpose of the patch is to support older devices not
    capable of eSCO.
    
    Tested on Blackberry 655+ headset which does not support retransmission.
    Credits go to Alexander Sommerhuber.
    
    Signed-off-by: Bernhard Thaler <bernhard.thaler@r-it.at>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e3d7ae9e2edd..22b253750f78 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -38,7 +38,7 @@ struct sco_param {
 	u16 max_latency;
 };
 
-static const struct sco_param sco_param_cvsd[] = {
+static const struct sco_param esco_param_cvsd[] = {
 	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000a }, /* S3 */
 	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x0007 }, /* S2 */
 	{ EDR_ESCO_MASK | ESCO_EV3,   0x0007 }, /* S1 */
@@ -46,6 +46,11 @@ static const struct sco_param sco_param_cvsd[] = {
 	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff }, /* D0 */
 };
 
+static const struct sco_param sco_param_cvsd[] = {
+	{ EDR_ESCO_MASK | ESCO_HV3,   0xffff }, /* D1 */
+	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff }, /* D0 */
+};
+
 static const struct sco_param sco_param_wideband[] = {
 	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000d }, /* T2 */
 	{ EDR_ESCO_MASK | ESCO_EV3,   0x0008 }, /* T1 */
@@ -207,10 +212,17 @@ bool hci_setup_sync(struct hci_conn *conn, __u16 handle)
 		param = &sco_param_wideband[conn->attempt - 1];
 		break;
 	case SCO_AIRMODE_CVSD:
-		if (conn->attempt > ARRAY_SIZE(sco_param_cvsd))
-			return false;
-		cp.retrans_effort = 0x01;
-		param = &sco_param_cvsd[conn->attempt - 1];
+		if (lmp_esco_capable(conn->link)) {
+			if (conn->attempt > ARRAY_SIZE(esco_param_cvsd))
+				return false;
+			cp.retrans_effort = 0x01;
+			param = &esco_param_cvsd[conn->attempt - 1];
+		} else {
+			if (conn->attempt > ARRAY_SIZE(sco_param_cvsd))
+				return false;
+			cp.retrans_effort = 0xff;
+			param = &sco_param_cvsd[conn->attempt - 1];
+		}
 		break;
 	default:
 		return false;

commit 839035a7b3acd17a6f739b1fb50298e9499d3fa4
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Aug 18 20:33:34 2014 +0300

    Bluetooth: Move clock offset reading into hci_disconnect()
    
    To give all hci_disconnect() users the advantage of getting the clock
    offset read automatically this patch moves the necessary code from
    hci_conn_timeout() into hci_disconnect(). This way we pretty much always
    update the clock offset when disconnecting.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index dd2df20b0f7d..e3d7ae9e2edd 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -128,6 +128,19 @@ int hci_disconnect(struct hci_conn *conn, __u8 reason)
 
 	BT_DBG("hcon %p", conn);
 
+	/* When we are master of an established connection and it enters
+	 * the disconnect timeout, then go ahead and try to read the
+	 * current clock offset.  Processing of the result is done
+	 * within the event handling and hci_clock_offset_evt function.
+	 */
+	if (conn->type == ACL_LINK && conn->role == HCI_ROLE_MASTER) {
+		struct hci_dev *hdev = conn->hdev;
+		struct hci_cp_read_clock_offset cp;
+
+		cp.handle = cpu_to_le16(conn->handle);
+		hci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET, sizeof(cp), &cp);
+	}
+
 	conn->state = BT_DISCONN;
 
 	cp.handle = cpu_to_le16(conn->handle);
@@ -325,25 +338,6 @@ static void hci_conn_timeout(struct work_struct *work)
 			hci_amp_disconn(conn);
 		} else {
 			__u8 reason = hci_proto_disconn_ind(conn);
-
-			/* When we are master of an established connection
-			 * and it enters the disconnect timeout, then go
-			 * ahead and try to read the current clock offset.
-			 *
-			 * Processing of the result is done within the
-			 * event handling and hci_clock_offset_evt function.
-			 */
-			if (conn->type == ACL_LINK &&
-			    conn->role == HCI_ROLE_MASTER) {
-				struct hci_dev *hdev = conn->hdev;
-				struct hci_cp_read_clock_offset cp;
-
-				cp.handle = cpu_to_le16(conn->handle);
-
-				hci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET,
-					     sizeof(cp), &cp);
-			}
-
 			hci_disconnect(conn, reason);
 		}
 		break;

commit e3b679d56caa2bc555dee646a6ac5861631e7a28
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Aug 18 20:33:32 2014 +0300

    Bluetooth: Update hci_disconnect() to return an error value
    
    We'll soon use hci_disconnect() from places that are interested to know
    whether the hci_send_cmd() really succeeded or not. This patch updates
    hci_disconnect() to pass on any error returned from hci_send_cmd().
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5157a0990732..dd2df20b0f7d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -122,7 +122,7 @@ static void hci_reject_sco(struct hci_conn *conn)
 	hci_send_cmd(conn->hdev, HCI_OP_REJECT_SYNC_CONN_REQ, sizeof(cp), &cp);
 }
 
-void hci_disconnect(struct hci_conn *conn, __u8 reason)
+int hci_disconnect(struct hci_conn *conn, __u8 reason)
 {
 	struct hci_cp_disconnect cp;
 
@@ -132,7 +132,7 @@ void hci_disconnect(struct hci_conn *conn, __u8 reason)
 
 	cp.handle = cpu_to_le16(conn->handle);
 	cp.reason = reason;
-	hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
+	return hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
 }
 
 static void hci_amp_disconn(struct hci_conn *conn)

commit bcbb655a180344d8004ede669228992bff1921e4
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Aug 18 20:33:27 2014 +0300

    Bluetooth: Remove hci_conn_hold/drop from hci_chan
    
    We can't have hci_chan contribute to the "active" reference counting of
    the hci_conn since otherwise the connection would never get dropped when
    there are no more users (since hci_chan would be counted as a user).
    This patch removes hold() when creating the hci_chan and drop() when
    destroying it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index aaa7e388d026..5157a0990732 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1301,7 +1301,6 @@ struct hci_chan *hci_chan_create(struct hci_conn *conn)
 		return NULL;
 
 	chan->conn = hci_conn_get(conn);
-	hci_conn_hold(conn);
 	skb_queue_head_init(&chan->data_q);
 	chan->state = BT_CONNECTED;
 
@@ -1321,11 +1320,9 @@ void hci_chan_del(struct hci_chan *chan)
 
 	synchronize_rcu();
 
-	/* Force the connection to be immediately dropped */
-	conn->disc_timeout = 0;
+	/* Prevent new hci_chan's to be created for this hci_conn */
 	set_bit(HCI_CONN_DROP, &conn->flags);
 
-	hci_conn_drop(conn);
 	hci_conn_put(conn);
 
 	skb_queue_purge(&chan->data_q);

commit f94b665dcf15324f5ac8aa639e47be0829b6409d
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Aug 18 00:41:44 2014 +0300

    Bluetooth: Ignore incoming data after initiating disconnection
    
    When hci_chan_del is called the disconnection routines get scheduled
    through a workqueue. If there's any incoming ACL data before the
    routines get executed there's a chance that a new hci_chan is created
    and the disconnection never happens. This patch adds a new hci_conn flag
    to indicate that we're in the process of driving the connection down. We
    set the flag in hci_chan_del and check for it in hci_chan_create so that
    no new channels are created for the same connection.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index cb04a4e3c829..aaa7e388d026 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1291,6 +1291,11 @@ struct hci_chan *hci_chan_create(struct hci_conn *conn)
 
 	BT_DBG("%s hcon %p", hdev->name, conn);
 
+	if (test_bit(HCI_CONN_DROP, &conn->flags)) {
+		BT_DBG("Refusing to create new hci_chan");
+		return NULL;
+	}
+
 	chan = kzalloc(sizeof(*chan), GFP_KERNEL);
 	if (!chan)
 		return NULL;
@@ -1318,6 +1323,7 @@ void hci_chan_del(struct hci_chan *chan)
 
 	/* Force the connection to be immediately dropped */
 	conn->disc_timeout = 0;
+	set_bit(HCI_CONN_DROP, &conn->flags);
 
 	hci_conn_drop(conn);
 	hci_conn_put(conn);

commit b3ff670a44cc34c01e78900c42255511e4f232e6
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Aug 18 00:41:43 2014 +0300

    Bluetooth: Set disc_timeout to 0 when calling hci_chan_del
    
    The hci_chan_del() function is used in scenarios where we've decided we
    want to get rid of the underlying baseband link. It makes therefore
    sense to force the disc_timeout to 0 so that the disconnection routines
    are immediately scheduled.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7815826a48e4..cb04a4e3c829 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1316,6 +1316,9 @@ void hci_chan_del(struct hci_chan *chan)
 
 	synchronize_rcu();
 
+	/* Force the connection to be immediately dropped */
+	conn->disc_timeout = 0;
+
 	hci_conn_drop(conn);
 	hci_conn_put(conn);
 

commit 6c388d32ec1b9fcc2f2404fb5e9b3b0096be5de9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Aug 18 00:41:42 2014 +0300

    Bluetooth: Fix hci_conn reference counting with hci_chan
    
    The hci_chan_del() function was doing a hci_conn_drop() but there was no
    matching hci_conn_hold() in the hci_chan_create() function. Furthermore,
    as the hci_chan struct holds a pointer to the hci_conn there should be
    proper use of hci_conn_get/put. This patch fixes both issues so that
    hci_chan does correct reference counting of the hci_conn object.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 4ecc9d5fce7a..7815826a48e4 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1295,7 +1295,8 @@ struct hci_chan *hci_chan_create(struct hci_conn *conn)
 	if (!chan)
 		return NULL;
 
-	chan->conn = conn;
+	chan->conn = hci_conn_get(conn);
+	hci_conn_hold(conn);
 	skb_queue_head_init(&chan->data_q);
 	chan->state = BT_CONNECTED;
 
@@ -1316,6 +1317,7 @@ void hci_chan_del(struct hci_chan *chan)
 	synchronize_rcu();
 
 	hci_conn_drop(conn);
+	hci_conn_put(conn);
 
 	skb_queue_purge(&chan->data_q);
 	kfree(chan);

commit f8aaf9b65a77267f749c1af641e46c3457d50701
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Aug 17 23:28:57 2014 +0300

    Bluetooth: Fix using hci_conn_get() for hci_conn pointers
    
    Wherever we keep hci_conn pointers around we should be using
    hci_conn_get/put to ensure that they stay valid. This patch fixes
    all places violating against the principle currently.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index faff6247ac8f..4ecc9d5fce7a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -595,6 +595,7 @@ void hci_le_conn_failed(struct hci_conn *conn, u8 status)
 					   conn->dst_type);
 	if (params && params->conn) {
 		hci_conn_drop(params->conn);
+		hci_conn_put(params->conn);
 		params->conn = NULL;
 	}
 

commit f161dd4122ffa73e4e12000309dca65bec80d416
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Aug 15 21:06:54 2014 +0300

    Bluetooth: Fix hci_conn reference counting for auto-connections
    
    Recently the LE passive scanning and auto-connections feature was
    introduced. It uses the hci_connect_le() API which returns a hci_conn
    along with a reference count to that object. All previous users would
    tie this returned reference to some existing object, such as an L2CAP
    channel, and there'd be no leaked references this way. For
    auto-connections however the reference was returned but not stored
    anywhere, leaving established connections with one higher reference
    count than they should have.
    
    Instead of playing special tricks with hci_conn_hold/drop this patch
    associates the returned reference from hci_connect_le() with the object
    that in practice does own this reference, i.e. the hci_conn_params
    struct that caused us to initiate a connection in the first place. Once
    the connection is established or fails to establish this reference is
    removed appropriately.
    
    One extra thing needed is to call hci_pend_le_actions_clear() before
    calling hci_conn_hash_flush() so that the reference is cleared before
    the hci_conn objects are fully removed.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b50dabb3f86a..faff6247ac8f 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -589,6 +589,14 @@ EXPORT_SYMBOL(hci_get_route);
 void hci_le_conn_failed(struct hci_conn *conn, u8 status)
 {
 	struct hci_dev *hdev = conn->hdev;
+	struct hci_conn_params *params;
+
+	params = hci_pend_le_action_lookup(&hdev->pend_le_conns, &conn->dst,
+					   conn->dst_type);
+	if (params && params->conn) {
+		hci_conn_drop(params->conn);
+		params->conn = NULL;
+	}
 
 	conn->state = BT_CLOSED;
 

commit 27f70f3e628c82362def60eb0af79d2129a51da2
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jul 21 10:50:06 2014 +0300

    Bluetooth: Prefer sizeof(*ptr) when allocating memory
    
    It's safer practice to use sizeof(*ptr) instead of sizeof(ptr_type) when
    allocating memory in case the type changes. This also fixes the
    following style of warnings from static analyzers:
    
    CHECK: Prefer kzalloc(sizeof(*ie)...) over kzalloc(sizeof(struct inquiry_entry)...)
    +       ie = kzalloc(sizeof(struct inquiry_entry), GFP_KERNEL);
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 1ac9f7f52acd..b50dabb3f86a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -428,7 +428,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,
 
 	BT_DBG("%s dst %pMR", hdev->name, dst);
 
-	conn = kzalloc(sizeof(struct hci_conn), GFP_KERNEL);
+	conn = kzalloc(sizeof(*conn), GFP_KERNEL);
 	if (!conn)
 		return NULL;
 
@@ -1282,7 +1282,7 @@ struct hci_chan *hci_chan_create(struct hci_conn *conn)
 
 	BT_DBG("%s hcon %p", hdev->name, conn);
 
-	chan = kzalloc(sizeof(struct hci_chan), GFP_KERNEL);
+	chan = kzalloc(sizeof(*chan), GFP_KERNEL);
 	if (!chan)
 		return NULL;
 

commit beb19e4c079d626bf0502fbb65bd7c9891a10c2e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Jul 18 11:15:26 2014 +0300

    Bluetooth: Use EOPNOTSUPP instead of ENOTSUPP
    
    The EOPNOTSUPP and ENOTSUPP errors are very similar in meaning, but
    ENOTSUPP is a fairly new addition to POSIX. Not all libc versions know
    about the value the kernel uses for ENOTSUPP so it's better to use
    EOPNOTSUPP to ensure understandable error messages.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 0d76054efd26..1ac9f7f52acd 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -834,7 +834,7 @@ struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 	struct hci_conn *acl;
 
 	if (!test_bit(HCI_BREDR_ENABLED, &hdev->dev_flags))
-		return ERR_PTR(-ENOTSUPP);
+		return ERR_PTR(-EOPNOTSUPP);
 
 	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (!acl) {

commit 977f8fce0279e5f96dc5c5068610d60b9ae94802
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Jul 17 15:35:39 2014 +0300

    Bluetooth: Introduce a flag to track who really initiates authentication
    
    Even though our side requests authentication, the original action that
    caused it may be remotely triggered, such as an incoming L2CAP or RFCOMM
    connect request. To track this information introduce a new hci_conn flag
    called HCI_CONN_AUTH_INITIATOR.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 76c5a38e5997..0d76054efd26 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1027,6 +1027,9 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type,
 	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
 		return 0;
 
+	if (initiator)
+		set_bit(HCI_CONN_AUTH_INITIATOR, &conn->flags);
+
 	if (!hci_conn_auth(conn, sec_level, auth_type))
 		return 0;
 

commit e7cafc45258c852c5176cd421615846e79a3d307
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Jul 17 15:35:38 2014 +0300

    Bluetooth: Pass initiator/acceptor information to hci_conn_security()
    
    We're interested in whether an authentication request is because of a
    remote or local action. So far hci_conn_security() has been used both
    for incoming and outgoing actions (e.g. RFCOMM or L2CAP connect
    requests) so without some modifications it cannot know which peer is
    responsible for requesting authentication.
    
    This patch adds a new "bool initiator" parameter to hci_conn_security()
    to indicate which side is responsible for the request and updates the
    current users to pass this information correspondingly.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ad5f0b819e90..76c5a38e5997 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -973,7 +973,8 @@ static void hci_conn_encrypt(struct hci_conn *conn)
 }
 
 /* Enable security */
-int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
+int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type,
+		      bool initiator)
 {
 	BT_DBG("hcon %p", conn);
 

commit a5c4e309b9f23b9de5475029b2cb1641ec293137
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 16 11:56:07 2014 +0300

    Bluetooth: Add a role parameter to hci_conn_add()
    
    We need to be able to track slave vs master LE connections in
    hci_conn_hash, and to be able to do that we need to know the role of the
    connection by the time hci_conn_add_has() is called. This means in
    practice the hci_conn_add() call that creates the hci_conn_object.
    
    This patch adds a new role parameter to hci_conn_add() function to give
    the object its initial role value, and updates the callers to pass the
    appropriate role to it. Since the function now takes care of
    initializing both conn->role and conn->out values we can remove some
    other unnecessary assignments.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6edd55340157..ad5f0b819e90 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -421,7 +421,8 @@ static void le_conn_timeout(struct work_struct *work)
 	hci_le_create_connection_cancel(conn);
 }
 
-struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst,
+			      u8 role)
 {
 	struct hci_conn *conn;
 
@@ -435,6 +436,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	bacpy(&conn->src, &hdev->bdaddr);
 	conn->hdev  = hdev;
 	conn->type  = type;
+	conn->role  = role;
 	conn->mode  = HCI_CM_ACTIVE;
 	conn->state = BT_OPEN;
 	conn->auth_type = HCI_AT_GENERAL_BONDING;
@@ -447,6 +449,9 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	set_bit(HCI_CONN_POWER_SAVE, &conn->flags);
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
 
+	if (conn->role == HCI_ROLE_MASTER)
+		conn->out = true;
+
 	switch (type) {
 	case ACL_LINK:
 		conn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;
@@ -746,7 +751,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		dst_type = ADDR_LE_DEV_RANDOM;
 	}
 
-	conn = hci_conn_add(hdev, LE_LINK, dst);
+	conn = hci_conn_add(hdev, LE_LINK, dst, role);
 	if (!conn)
 		return ERR_PTR(-ENOMEM);
 
@@ -769,8 +774,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 			    &enable);
 	}
 
-	conn->role = role;
-
 	/* If requested to connect as slave use directed advertising */
 	if (conn->role == HCI_ROLE_SLAVE) {
 		/* If we're active scanning most controllers are unable
@@ -787,8 +790,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		goto create_conn;
 	}
 
-	conn->out  = true;
-
 	params = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);
 	if (params) {
 		conn->le_conn_min_interval = params->conn_min_interval;
@@ -837,7 +838,7 @@ struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 
 	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (!acl) {
-		acl = hci_conn_add(hdev, ACL_LINK, dst);
+		acl = hci_conn_add(hdev, ACL_LINK, dst, HCI_ROLE_MASTER);
 		if (!acl)
 			return ERR_PTR(-ENOMEM);
 	}
@@ -866,7 +867,7 @@ struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,
 
 	sco = hci_conn_hash_lookup_ba(hdev, type, dst);
 	if (!sco) {
-		sco = hci_conn_add(hdev, type, dst);
+		sco = hci_conn_add(hdev, type, dst, HCI_ROLE_MASTER);
 		if (!sco) {
 			hci_conn_drop(acl);
 			return ERR_PTR(-ENOMEM);

commit e804d25d4a07c0ff9e5e1c58ea5ee67232aa9af8
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 16 11:42:28 2014 +0300

    Bluetooth: Use explicit role instead of a bool in function parameters
    
    To make the code more understandable it makes sense to use the new HCI
    defines for connection role instead of a "bool master" parameter. This
    makes it immediately clear when looking at the function calls what the
    last parameter is describing.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6c1c5048984c..6edd55340157 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -697,7 +697,7 @@ static void hci_req_directed_advertising(struct hci_request *req,
 
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				u8 dst_type, u8 sec_level, u16 conn_timeout,
-				bool master)
+				u8 role)
 {
 	struct hci_conn_params *params;
 	struct hci_conn *conn;
@@ -769,8 +769,10 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 			    &enable);
 	}
 
+	conn->role = role;
+
 	/* If requested to connect as slave use directed advertising */
-	if (!master) {
+	if (conn->role == HCI_ROLE_SLAVE) {
 		/* If we're active scanning most controllers are unable
 		 * to initiate advertising. Simply reject the attempt.
 		 */
@@ -786,7 +788,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	}
 
 	conn->out  = true;
-	conn->role = HCI_ROLE_MASTER;
 
 	params = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);
 	if (params) {

commit 40bef302f6323d1ee6fb3dc0e62edb0f446d0339
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 16 11:42:27 2014 +0300

    Bluetooth: Convert HCI_CONN_MASTER flag to a conn->role variable
    
    Having a dedicated u8 role variable in the hci_conn struct greatly
    simplifies tracking of the role, since this is the native way that it's
    represented on the HCI level.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 490ee8846d9e..6c1c5048984c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -66,8 +66,7 @@ static void hci_acl_create_connection(struct hci_conn *conn)
 
 	conn->state = BT_CONNECT;
 	conn->out = true;
-
-	set_bit(HCI_CONN_MASTER, &conn->flags);
+	conn->role = HCI_ROLE_MASTER;
 
 	conn->attempt++;
 
@@ -335,7 +334,7 @@ static void hci_conn_timeout(struct work_struct *work)
 			 * event handling and hci_clock_offset_evt function.
 			 */
 			if (conn->type == ACL_LINK &&
-			    test_bit(HCI_CONN_MASTER, &conn->flags)) {
+			    conn->role == HCI_ROLE_MASTER) {
 				struct hci_dev *hdev = conn->hdev;
 				struct hci_cp_read_clock_offset cp;
 
@@ -786,8 +785,8 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		goto create_conn;
 	}
 
-	conn->out = true;
-	set_bit(HCI_CONN_MASTER, &conn->flags);
+	conn->out  = true;
+	conn->role = HCI_ROLE_MASTER;
 
 	params = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);
 	if (params) {
@@ -1076,7 +1075,7 @@ int hci_conn_switch_role(struct hci_conn *conn, __u8 role)
 {
 	BT_DBG("hcon %p", conn);
 
-	if (!role && test_bit(HCI_CONN_MASTER, &conn->flags))
+	if (role == conn->role)
 		return 1;
 
 	if (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->flags)) {
@@ -1151,7 +1150,7 @@ static u32 get_link_mode(struct hci_conn *conn)
 {
 	u32 link_mode = 0;
 
-	if (test_bit(HCI_CONN_MASTER, &conn->flags))
+	if (conn->role == HCI_ROLE_MASTER)
 		link_mode |= HCI_LM_MASTER;
 
 	if (test_bit(HCI_CONN_ENCRYPT, &conn->flags))

commit e8bb6b9739e2e80e0e413f56816af3871388cfe8
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jul 8 15:07:53 2014 +0300

    Bluetooth: Fix advertising and active scanning co-existence
    
    Many controllers allow simultaneous active scanning and advertising
    (e.g. Intel and Broadcom) but some do not (e.g. CSR). It's therefore
    safest to implement mutual exclusion of these states in the kernel.
    
    This patch ensures that the two states are never entered simultaneously.
    Extra precaution needs to be taken for outgoing connection attempts in
    slave role (i.e. through directed advertising) in which case the
    operation that came first has precedence and the one that comes after
    gets a rejection.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 1517f1549f85..490ee8846d9e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -772,6 +772,16 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 
 	/* If requested to connect as slave use directed advertising */
 	if (!master) {
+		/* If we're active scanning most controllers are unable
+		 * to initiate advertising. Simply reject the attempt.
+		 */
+		if (test_bit(HCI_LE_SCAN, &hdev->dev_flags) &&
+		    hdev->le_scan_type == LE_SCAN_ACTIVE) {
+			skb_queue_purge(&req.cmd_q);
+			hci_conn_del(conn);
+			return ERR_PTR(-EBUSY);
+		}
+
 		hci_req_directed_advertising(&req, conn);
 		goto create_conn;
 	}

commit 376f54c171674ac1f9a2eefe67d413db4836d25a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jul 8 15:07:52 2014 +0300

    Bluetooth: Stop advertising always before initiating a connection
    
    Most controllers do not support advertising while initiating an LE
    connection. We also have to first disable current advertising if the
    initiation is going to happen through direct advertising. Therefore,
    simply stop advertising as the first thing when starting to issue
    commands to establish an LE connection.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 0db2579ea6c6..1517f1549f85 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -668,9 +668,6 @@ static void hci_req_directed_advertising(struct hci_request *req,
 	u8 own_addr_type;
 	u8 enable;
 
-	enable = 0x00;
-	hci_req_add(req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable), &enable);
-
 	/* Clear the HCI_LE_ADV bit temporarily so that the
 	 * hci_update_random_address knows that it's safe to go ahead
 	 * and write a new random address. The flag will be set back on
@@ -761,6 +758,18 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 
 	hci_req_init(&req, hdev);
 
+	/* Disable advertising if we're active. For master role
+	 * connections most controllers will refuse to connect if
+	 * advertising is enabled, and for slave role connections we
+	 * anyway have to disable it in order to start directed
+	 * advertising.
+	 */
+	if (test_bit(HCI_LE_ADV, &hdev->dev_flags)) {
+		u8 enable = 0x00;
+		hci_req_add(&req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),
+			    &enable);
+	}
+
 	/* If requested to connect as slave use directed advertising */
 	if (!master) {
 		hci_req_directed_advertising(&req, conn);

commit 5ce194c4a751ac603966dd1567b62035a7dfbf89
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jul 8 15:07:49 2014 +0300

    Bluetooth: Use real advertising state to random address update decision
    
    Now that we have a flag for tracking the real advertising state we
    should use that to determine whether it's safe to update the random
    address or not. The couple of places that were clearing the flag due to
    a pending request need to be updated too.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 16fd55da9c1d..0db2579ea6c6 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -671,12 +671,12 @@ static void hci_req_directed_advertising(struct hci_request *req,
 	enable = 0x00;
 	hci_req_add(req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable), &enable);
 
-	/* Clear the HCI_ADVERTISING bit temporarily so that the
+	/* Clear the HCI_LE_ADV bit temporarily so that the
 	 * hci_update_random_address knows that it's safe to go ahead
 	 * and write a new random address. The flag will be set back on
 	 * as soon as the SET_ADV_ENABLE HCI command completes.
 	 */
-	clear_bit(HCI_ADVERTISING, &hdev->dev_flags);
+	clear_bit(HCI_LE_ADV, &hdev->dev_flags);
 
 	/* Set require_privacy to false so that the remote device has a
 	 * chance of identifying us.

commit cdd6275e510bd86c44d3fc85a78306f514bbac9a
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jul 7 15:02:28 2014 +0300

    Bluetooth: Pass desired connection role to hci_connect_le()
    
    If we have both LE scanning and advertising simultaneously enabled we
    need a way to tell hci_connect_le() in which role to initiate a
    connection. This patch adds a new parameter to the function to give it
    the necessary information. For auto-connect and mgmt_pair_device we
    always use master role, whereas for L2CAP users (in practice sockets) we
    use slave role whenever HCI_ADVERTISING is set and master role
    otherwise.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 9323044f01cd..16fd55da9c1d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -700,7 +700,8 @@ static void hci_req_directed_advertising(struct hci_request *req,
 }
 
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
-				u8 dst_type, u8 sec_level, u16 conn_timeout)
+				u8 dst_type, u8 sec_level, u16 conn_timeout,
+				bool master)
 {
 	struct hci_conn_params *params;
 	struct hci_conn *conn;
@@ -760,7 +761,8 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 
 	hci_req_init(&req, hdev);
 
-	if (test_bit(HCI_ADVERTISING, &hdev->dev_flags)) {
+	/* If requested to connect as slave use directed advertising */
+	if (!master) {
 		hci_req_directed_advertising(&req, conn);
 		goto create_conn;
 	}

commit d93375a82da10cb023afc945fa18471bf3c41704
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jul 7 15:02:27 2014 +0300

    Bluetooth: Remove auth_type parameter from hci_connect_le()
    
    The auth_type value which gets assigned to hci_conn->auth_type is
    something that's only used for BR/EDR connections and is of no value for
    LE connections. It makes therefore little sense to pass it to the
    hci_connect_le() function. This patch removes the parameter from the
    function.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index faa032fcdaee..9323044f01cd 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -700,8 +700,7 @@ static void hci_req_directed_advertising(struct hci_request *req,
 }
 
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
-				u8 dst_type, u8 sec_level, u8 auth_type,
-				u16 conn_timeout)
+				u8 dst_type, u8 sec_level, u16 conn_timeout)
 {
 	struct hci_conn_params *params;
 	struct hci_conn *conn;
@@ -721,7 +720,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
 	if (conn) {
 		conn->pending_sec_level = sec_level;
-		conn->auth_type = auth_type;
 		goto done;
 	}
 
@@ -758,7 +756,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	conn->dst_type = dst_type;
 	conn->sec_level = BT_SECURITY_LOW;
 	conn->pending_sec_level = sec_level;
-	conn->auth_type = auth_type;
 	conn->conn_timeout = conn_timeout;
 
 	hci_req_init(&req, hdev);

commit 09ae260ba452c2ed36ec295941a58cb75db213ed
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Jul 6 13:41:15 2014 +0300

    Bluetooth: Use lower timeout for LE auto-connections
    
    When we establish connections as a consequence of receiving an
    advertising report it makes no sense to wait the normal 20 second LE
    connection timeout. This patch modifies the hci_connect_le function to
    take an extra timeout value and uses a lower 2 second timeout for the
    auto-connection case. This timeout is intentionally chosen to be just a
    bit higher than the 1.28 second timeout that High Duty Cycle Advertising
    uses.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 0d579d036833..faa032fcdaee 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -700,7 +700,8 @@ static void hci_req_directed_advertising(struct hci_request *req,
 }
 
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
-				u8 dst_type, u8 sec_level, u8 auth_type)
+				u8 dst_type, u8 sec_level, u8 auth_type,
+				u16 conn_timeout)
 {
 	struct hci_conn_params *params;
 	struct hci_conn *conn;
@@ -758,6 +759,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	conn->sec_level = BT_SECURITY_LOW;
 	conn->pending_sec_level = sec_level;
 	conn->auth_type = auth_type;
+	conn->conn_timeout = conn_timeout;
 
 	hci_req_init(&req, hdev);
 

commit 7d6ca6939cb2f701204317cbab15af1b98f7f501
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jul 2 17:37:31 2014 +0300

    Bluetooth: Make hci_le_conn_update return the store hint
    
    The caller of hci_le_conn_update is directly interested in knowing what
    the best value is for the store_hint parameter of the corresponding
    mgmt event. Since hci_le_conn_update knows whether there were stored
    parameters that were updated or not we can have it return an initial
    store_hint value to the caller.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index d00aaf976efc..0d579d036833 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -213,8 +213,8 @@ bool hci_setup_sync(struct hci_conn *conn, __u16 handle)
 	return true;
 }
 
-void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
-			u16 latency, u16 to_multiplier)
+u8 hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max, u16 latency,
+		      u16 to_multiplier)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_conn_params *params;
@@ -242,6 +242,11 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 	cp.max_ce_len		= cpu_to_le16(0x0000);
 
 	hci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);
+
+	if (params)
+		return 0x01;
+
+	return 0x00;
 }
 
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,

commit 04fb7d9066dd9173ef0d4ccea8fe3bb59bd94605
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jun 30 12:34:36 2014 +0200

    Bluetooth: Provide defaults for LE connection latency and timeout
    
    Store the connection latency and supervision timeout default values
    with all the other controller defaults. And when needed use them
    for new connections.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e7ee7267f846..d00aaf976efc 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -773,8 +773,8 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	} else {
 		conn->le_conn_min_interval = hdev->le_conn_min_interval;
 		conn->le_conn_max_interval = hdev->le_conn_max_interval;
-		conn->le_conn_latency = 0x0000;
-		conn->le_supv_timeout = 0x002a;
+		conn->le_conn_latency = hdev->le_conn_latency;
+		conn->le_supv_timeout = hdev->le_supv_timeout;
 	}
 
 	/* If controller is scanning, we stop it since some controllers are

commit 037fc415bce5ac7604ac52216ec03d011f81e5b0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jun 29 16:43:27 2014 +0200

    Bluetooth: Use LE connection parameters if known
    
    When the LE connection parameters for connection latency and
    supervision timeout are known, then use then. If they are not
    know fallback to defaults.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index adb413d77637..e7ee7267f846 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -645,7 +645,8 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	cp.own_address_type = own_addr_type;
 	cp.conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
 	cp.conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
-	cp.supervision_timeout = cpu_to_le16(0x002a);
+	cp.conn_latency = cpu_to_le16(conn->le_conn_latency);
+	cp.supervision_timeout = cpu_to_le16(conn->le_supv_timeout);
 	cp.min_ce_len = cpu_to_le16(0x0000);
 	cp.max_ce_len = cpu_to_le16(0x0000);
 
@@ -767,9 +768,13 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	if (params) {
 		conn->le_conn_min_interval = params->conn_min_interval;
 		conn->le_conn_max_interval = params->conn_max_interval;
+		conn->le_conn_latency = params->conn_latency;
+		conn->le_supv_timeout = params->supervision_timeout;
 	} else {
 		conn->le_conn_min_interval = hdev->le_conn_min_interval;
 		conn->le_conn_max_interval = hdev->le_conn_max_interval;
+		conn->le_conn_latency = 0x0000;
+		conn->le_supv_timeout = 0x002a;
 	}
 
 	/* If controller is scanning, we stop it since some controllers are

commit f044eb0524a02ea7f921c9234fbdba43290da1e2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jun 29 16:43:26 2014 +0200

    Bluetooth: Store latency and supervision timeout in connection params
    
    When the slave updates the connection parameters, store also the
    connection latency and supervision timeout information in the
    internal list of connection parameters for known devices.
    
    Having these values available allowes the auto-connection
    procedure to use the correct values from the beginning without
    having to request an update on every connection establishment.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 25ee27ddc882..adb413d77637 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -216,11 +216,23 @@ bool hci_setup_sync(struct hci_conn *conn, __u16 handle)
 void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 			u16 latency, u16 to_multiplier)
 {
-	struct hci_cp_le_conn_update cp;
 	struct hci_dev *hdev = conn->hdev;
+	struct hci_conn_params *params;
+	struct hci_cp_le_conn_update cp;
 
-	memset(&cp, 0, sizeof(cp));
+	hci_dev_lock(hdev);
+
+	params = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);
+	if (params) {
+		params->conn_min_interval = min;
+		params->conn_max_interval = max;
+		params->conn_latency = latency;
+		params->supervision_timeout = to_multiplier;
+	}
 
+	hci_dev_unlock(hdev);
+
+	memset(&cp, 0, sizeof(cp));
 	cp.handle		= cpu_to_le16(conn->handle);
 	cp.conn_interval_min	= cpu_to_le16(min);
 	cp.conn_interval_max	= cpu_to_le16(max);

commit fee746b0babf128a50ece050ee6e63003ebb5ae1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Jun 29 12:13:05 2014 +0200

    Bluetooth: Restrict access for raw-only controllers
    
    Bluetooth controllers that are marked for raw-only usage can only be
    used with user channel access. Any other operation should be rejected.
    
    This simplifies the whole raw-only support since it now depends on
    the fact that the controller is marked with HCI_QUIRK_RAW_DEVICE and
    runtime raw access is restricted to user channel operation.
    
    The kernel internal processing of HCI commands and events is designed
    around the case that either the kernel has full control over the device
    or that the device is driven from userspace. This now makes a clear
    distinction between these two possible operation modes.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 8a0c7a0ac1b6..25ee27ddc882 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -346,9 +346,6 @@ static void hci_conn_idle(struct work_struct *work)
 
 	BT_DBG("hcon %p mode %d", conn, conn->mode);
 
-	if (test_bit(HCI_RAW, &hdev->flags))
-		return;
-
 	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
 		return;
 
@@ -539,7 +536,6 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 
 	list_for_each_entry(d, &hci_dev_list, list) {
 		if (!test_bit(HCI_UP, &d->flags) ||
-		    test_bit(HCI_RAW, &d->flags) ||
 		    test_bit(HCI_USER_CHANNEL, &d->dev_flags) ||
 		    d->dev_type != HCI_BREDR)
 			continue;
@@ -1059,9 +1055,6 @@ void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 
 	BT_DBG("hcon %p mode %d", conn, conn->mode);
 
-	if (test_bit(HCI_RAW, &hdev->flags))
-		return;
-
 	if (conn->mode != HCI_CM_SNIFF)
 		goto timer;
 

commit df935429be40b02568d4bcf9ebfacf8011b85a85
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jun 27 14:32:16 2014 +0200

    Bluetooth: Send HCI_Read_Clock_Offset before disconnecting
    
    When the connection is in master role and it is going to be
    disconnected based on the disconnection timeout, then send
    the HCI_Read_Clock_Offset command in an attempt to update the
    clock offset value in the inquiry cache.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6d0fe3df2fa5..8a0c7a0ac1b6 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -309,6 +309,25 @@ static void hci_conn_timeout(struct work_struct *work)
 			hci_amp_disconn(conn);
 		} else {
 			__u8 reason = hci_proto_disconn_ind(conn);
+
+			/* When we are master of an established connection
+			 * and it enters the disconnect timeout, then go
+			 * ahead and try to read the current clock offset.
+			 *
+			 * Processing of the result is done within the
+			 * event handling and hci_clock_offset_evt function.
+			 */
+			if (conn->type == ACL_LINK &&
+			    test_bit(HCI_CONN_MASTER, &conn->flags)) {
+				struct hci_dev *hdev = conn->hdev;
+				struct hci_cp_read_clock_offset cp;
+
+				cp.handle = cpu_to_le16(conn->handle);
+
+				hci_send_cmd(hdev, HCI_OP_READ_CLOCK_OFFSET,
+					     sizeof(cp), &cp);
+			}
+
 			hci_disconnect(conn, reason);
 		}
 		break;

commit 40051e4686d6fa8743a38933727604f75bef05cf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jun 27 13:45:09 2014 +0200

    Bluetooth: Remove unneeded hci_conn_disconnect abstraction
    
    The abstraction of disconnect operation via hci_conn_disconnect is not
    needed and it does not add any readability. Handle the difference of
    AMP physical channels and BR/EDR/LE connection in the timeout callback.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index cc64fbe952fa..6d0fe3df2fa5 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -271,21 +271,6 @@ void hci_sco_setup(struct hci_conn *conn, __u8 status)
 	}
 }
 
-static void hci_conn_disconnect(struct hci_conn *conn)
-{
-	__u8 reason;
-
-	switch (conn->type) {
-	case AMP_LINK:
-		hci_amp_disconn(conn);
-		break;
-	default:
-		reason = hci_proto_disconn_ind(conn);
-		hci_disconnect(conn, reason);
-		break;
-	}
-}
-
 static void hci_conn_timeout(struct work_struct *work)
 {
 	struct hci_conn *conn = container_of(work, struct hci_conn,
@@ -320,7 +305,12 @@ static void hci_conn_timeout(struct work_struct *work)
 		break;
 	case BT_CONFIG:
 	case BT_CONNECTED:
-		hci_conn_disconnect(conn);
+		if (conn->type == AMP_LINK) {
+			hci_amp_disconn(conn);
+		} else {
+			__u8 reason = hci_proto_disconn_ind(conn);
+			hci_disconnect(conn, reason);
+		}
 		break;
 	default:
 		conn->state = BT_CLOSED;

commit a2b1976b8e0184635a1119f8511fc3e68902e429
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jun 27 13:45:08 2014 +0200

    Bluetooth: Remove reason parameter from hci_amp_disconn function
    
    The hci_amp_disconn function is a local function and there is no
    need for a reason parameter. That one can be retrieved from the
    hci_conn object easily.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 626160c37103..cc64fbe952fa 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -136,7 +136,7 @@ void hci_disconnect(struct hci_conn *conn, __u8 reason)
 	hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
 }
 
-static void hci_amp_disconn(struct hci_conn *conn, __u8 reason)
+static void hci_amp_disconn(struct hci_conn *conn)
 {
 	struct hci_cp_disconn_phy_link cp;
 
@@ -145,7 +145,7 @@ static void hci_amp_disconn(struct hci_conn *conn, __u8 reason)
 	conn->state = BT_DISCONN;
 
 	cp.phy_handle = HCI_PHY_HANDLE(conn->handle);
-	cp.reason = reason;
+	cp.reason = hci_proto_disconn_ind(conn);
 	hci_send_cmd(conn->hdev, HCI_OP_DISCONN_PHY_LINK,
 		     sizeof(cp), &cp);
 }
@@ -273,13 +273,14 @@ void hci_sco_setup(struct hci_conn *conn, __u8 status)
 
 static void hci_conn_disconnect(struct hci_conn *conn)
 {
-	__u8 reason = hci_proto_disconn_ind(conn);
+	__u8 reason;
 
 	switch (conn->type) {
 	case AMP_LINK:
-		hci_amp_disconn(conn, reason);
+		hci_amp_disconn(conn);
 		break;
 	default:
+		reason = hci_proto_disconn_ind(conn);
 		hci_disconnect(conn, reason);
 		break;
 	}

commit 4dae27983eaaee15c6867561eb2c8d7b2d28d6cc
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jun 24 17:03:50 2014 +0300

    Bluetooth: Convert hci_conn->link_mode into flags
    
    Since the link_mode member of the hci_conn struct is a bit field and we
    already have a flags member as well it makes sense to merge these two
    together. This patch moves all used link_mode bits into corresponding
    flags. To keep backwards compatibility with user space we still need to
    provide a get_link_mode() helper function for the ioctl's that expect a
    link_mode style value.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a7a27bc2c0b1..626160c37103 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -67,7 +67,7 @@ static void hci_acl_create_connection(struct hci_conn *conn)
 	conn->state = BT_CONNECT;
 	conn->out = true;
 
-	conn->link_mode = HCI_LM_MASTER;
+	set_bit(HCI_CONN_MASTER, &conn->flags);
 
 	conn->attempt++;
 
@@ -743,7 +743,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	}
 
 	conn->out = true;
-	conn->link_mode |= HCI_LM_MASTER;
+	set_bit(HCI_CONN_MASTER, &conn->flags);
 
 	params = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);
 	if (params) {
@@ -865,7 +865,8 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 			return 0;
 	}
 
-	if (hci_conn_ssp_enabled(conn) && !(conn->link_mode & HCI_LM_ENCRYPT))
+	if (hci_conn_ssp_enabled(conn) &&
+	    !test_bit(HCI_CONN_ENCRYPT, &conn->flags))
 		return 0;
 
 	return 1;
@@ -881,7 +882,7 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 
 	if (sec_level > conn->sec_level)
 		conn->pending_sec_level = sec_level;
-	else if (conn->link_mode & HCI_LM_AUTH)
+	else if (test_bit(HCI_CONN_AUTH, &conn->flags))
 		return 1;
 
 	/* Make sure we preserve an existing MITM requirement*/
@@ -899,7 +900,7 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 		/* If we're already encrypted set the REAUTH_PEND flag,
 		 * otherwise set the ENCRYPT_PEND.
 		 */
-		if (conn->link_mode & HCI_LM_ENCRYPT)
+		if (test_bit(HCI_CONN_ENCRYPT, &conn->flags))
 			set_bit(HCI_CONN_REAUTH_PEND, &conn->flags);
 		else
 			set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
@@ -940,7 +941,7 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 		return 1;
 
 	/* For other security levels we need the link key. */
-	if (!(conn->link_mode & HCI_LM_AUTH))
+	if (!test_bit(HCI_CONN_AUTH, &conn->flags))
 		goto auth;
 
 	/* An authenticated FIPS approved combination key has sufficient
@@ -980,7 +981,7 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 		return 0;
 
 encrypt:
-	if (conn->link_mode & HCI_LM_ENCRYPT)
+	if (test_bit(HCI_CONN_ENCRYPT, &conn->flags))
 		return 1;
 
 	hci_conn_encrypt(conn);
@@ -1027,7 +1028,7 @@ int hci_conn_switch_role(struct hci_conn *conn, __u8 role)
 {
 	BT_DBG("hcon %p", conn);
 
-	if (!role && conn->link_mode & HCI_LM_MASTER)
+	if (!role && test_bit(HCI_CONN_MASTER, &conn->flags))
 		return 1;
 
 	if (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->flags)) {
@@ -1101,6 +1102,28 @@ void hci_conn_check_pending(struct hci_dev *hdev)
 	hci_dev_unlock(hdev);
 }
 
+static u32 get_link_mode(struct hci_conn *conn)
+{
+	u32 link_mode = 0;
+
+	if (test_bit(HCI_CONN_MASTER, &conn->flags))
+		link_mode |= HCI_LM_MASTER;
+
+	if (test_bit(HCI_CONN_ENCRYPT, &conn->flags))
+		link_mode |= HCI_LM_ENCRYPT;
+
+	if (test_bit(HCI_CONN_AUTH, &conn->flags))
+		link_mode |= HCI_LM_AUTH;
+
+	if (test_bit(HCI_CONN_SECURE, &conn->flags))
+		link_mode |= HCI_LM_SECURE;
+
+	if (test_bit(HCI_CONN_FIPS, &conn->flags))
+		link_mode |= HCI_LM_FIPS;
+
+	return link_mode;
+}
+
 int hci_get_conn_list(void __user *arg)
 {
 	struct hci_conn *c;
@@ -1136,7 +1159,7 @@ int hci_get_conn_list(void __user *arg)
 		(ci + n)->type  = c->type;
 		(ci + n)->out   = c->out;
 		(ci + n)->state = c->state;
-		(ci + n)->link_mode = c->link_mode;
+		(ci + n)->link_mode = get_link_mode(c);
 		if (++n >= req.conn_num)
 			break;
 	}
@@ -1172,7 +1195,7 @@ int hci_get_conn_info(struct hci_dev *hdev, void __user *arg)
 		ci.type  = conn->type;
 		ci.out   = conn->out;
 		ci.state = conn->state;
-		ci.link_mode = conn->link_mode;
+		ci.link_mode = get_link_mode(conn);
 	}
 	hci_dev_unlock(hdev);
 

commit 1d56dc4f5f7cdf0ba99062d974b7586a28fc5cf4
Author: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
Date:   Tue Jun 17 13:04:20 2014 +0200

    Bluetooth: Fix for ACL disconnect when pairing fails
    
    When pairing fails hci_conn refcnt drops below zero. This cause that
    ACL link is not disconnected when disconnect timeout fires.
    
    Probably this is because l2cap_conn_del calls l2cap_chan_del for each
    channel, and inside l2cap_chan_del conn is dropped. After that loop
    hci_chan_del is called which also drops conn.
    
    Anyway, as it is desrcibed in hci_core.h, it is known that refcnt
    drops below 0 sometimes and it should be fine. If so, let disconnect
    link when hci_conn_timeout fires and refcnt is 0 or below. This patch
    does it.
    
    This affects PTS test SM_TC_JW_BV_05_C
    
    Logs from scenario:
    
    [69713.706227] [6515] pair_device:
    [69713.706230] [6515] hci_conn_add: hci0 dst 00:1b:dc:06:06:22
    [69713.706233] [6515] hci_dev_hold: hci0 orig refcnt 8
    [69713.706235] [6515] hci_conn_init_sysfs: conn ffff88021f65a000
    [69713.706239] [6515] hci_req_add_ev: hci0 opcode 0x200d plen 25
    [69713.706242] [6515] hci_prepare_cmd: skb len 28
    [69713.706243] [6515] hci_req_run: length 1
    [69713.706248] [6515] hci_conn_hold: hcon ffff88021f65a000 orig refcnt 0
    [69713.706251] [6515] hci_dev_put: hci0 orig refcnt 9
    [69713.706281] [8909] hci_cmd_work: hci0 cmd_cnt 1 cmd queued 1
    [69713.706288] [8909] hci_send_frame: hci0 type 1 len 28
    [69713.706290] [8909] hci_send_to_monitor: hdev ffff88021f0c7000 len 28
    [69713.706316] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69713.706382] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69713.711664] [8909] hci_rx_work: hci0
    [69713.711668] [8909] hci_send_to_monitor: hdev ffff88021f0c7000 len 6
    [69713.711680] [8909] hci_rx_work: hci0 Event packet
    [69713.711683] [8909] hci_cs_le_create_conn: hci0 status 0x00
    [69713.711685] [8909] hci_sent_cmd_data: hci0 opcode 0x200d
    [69713.711688] [8909] hci_req_cmd_complete: opcode 0x200d status 0x00
    [69713.711690] [8909] hci_sent_cmd_data: hci0 opcode 0x200d
    [69713.711695] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69713.711744] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69713.818875] [8909] hci_rx_work: hci0
    [69713.818889] [8909] hci_send_to_monitor: hdev ffff88021f0c7000 len 21
    [69713.818913] [8909] hci_rx_work: hci0 Event packet
    [69713.818917] [8909] hci_le_conn_complete_evt: hci0 status 0x00
    [69713.818922] [8909] hci_send_to_control: len 19
    [69713.818927] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69713.818938] [8909] hci_conn_add_sysfs: conn ffff88021f65a000
    [69713.818975] [6450] bt_sock_poll: sock ffff88005e758500, sk ffff88010323b800
    [69713.818981] [6515] hci_sock_recvmsg: sock ffff88005e75a080, sk ffff88010323ac00
    ...
    [69713.819021] [8909] hci_dev_hold: hci0 orig refcnt 10
    [69713.819025] [8909] l2cap_connect_cfm: hcon ffff88021f65a000 bdaddr 00:1b:dc:06:06:22 status 0
    [69713.819028] [8909] hci_chan_create: hci0 hcon ffff88021f65a000
    [69713.819031] [8909] l2cap_conn_add: hcon ffff88021f65a000 conn ffff880221005c00 hchan ffff88020d60b1c0
    [69713.819034] [8909] l2cap_conn_ready: conn ffff880221005c00
    [69713.819036] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69713.819037] [8909] smp_conn_security: conn ffff880221005c00 hcon ffff88021f65a000 level 0x02
    [69713.819039] [8909] smp_chan_create:
    [69713.819041] [8909] hci_conn_hold: hcon ffff88021f65a000 orig refcnt 1
    [69713.819043] [8909] smp_send_cmd: code 0x01
    [69713.819045] [8909] hci_send_acl: hci0 chan ffff88020d60b1c0 flags 0x0000
    [69713.819046] [5949] hci_sock_recvmsg: sock ffff8800941a9900, sk ffff88012bf4e800
    [69713.819049] [8909] hci_queue_acl: hci0 nonfrag skb ffff88005157c100 len 15
    [69713.819055] [5949] hci_sock_recvmsg: sock ffff8800941a9900, sk ffff88012bf4e800
    [69713.819057] [8909] l2cap_le_conn_ready:
    [69713.819064] [8909] l2cap_chan_create: chan ffff88005ede2c00
    [69713.819066] [8909] l2cap_chan_hold: chan ffff88005ede2c00 orig refcnt 1
    [69713.819069] [8909] l2cap_sock_init: sk ffff88005ede5800
    [69713.819072] [8909] bt_accept_enqueue: parent ffff880160356000, sk ffff88005ede5800
    [69713.819074] [8909] __l2cap_chan_add: conn ffff880221005c00, psm 0x00, dcid 0x0004
    [69713.819076] [8909] l2cap_chan_hold: chan ffff88005ede2c00 orig refcnt 2
    [69713.819078] [8909] hci_conn_hold: hcon ffff88021f65a000 orig refcnt 2
    [69713.819080] [8909] smp_conn_security: conn ffff880221005c00 hcon ffff88021f65a000 level 0x01
    [69713.819082] [8909] l2cap_sock_ready_cb: sk ffff88005ede5800, parent ffff880160356000
    [69713.819086] [8909] le_pairing_complete_cb: status 0
    [69713.819091] [8909] hci_tx_work: hci0 acl 10 sco 8 le 0
    [69713.819093] [8909] hci_sched_acl: hci0
    [69713.819094] [8909] hci_sched_sco: hci0
    [69713.819096] [8909] hci_sched_esco: hci0
    [69713.819098] [8909] hci_sched_le: hci0
    [69713.819099] [8909] hci_chan_sent: hci0
    [69713.819101] [8909] hci_chan_sent: chan ffff88020d60b1c0 quote 10
    [69713.819104] [8909] hci_sched_le: chan ffff88020d60b1c0 skb ffff88005157c100 len 15 priority 7
    [69713.819106] [8909] hci_send_frame: hci0 type 2 len 15
    [69713.819108] [8909] hci_send_to_monitor: hdev ffff88021f0c7000 len 15
    [69713.819119] [8909] hci_chan_sent: hci0
    [69713.819121] [8909] hci_prio_recalculate: hci0
    [69713.819123] [8909] process_pending_rx:
    [69713.819226] [6450] hci_sock_recvmsg: sock ffff88005e758780, sk ffff88010323d400
    ...
    [69713.822022] [6450] l2cap_sock_accept: sk ffff880160356000 timeo 0
    [69713.822024] [6450] bt_accept_dequeue: parent ffff880160356000
    [69713.822026] [6450] bt_accept_unlink: sk ffff88005ede5800 state 1
    [69713.822028] [6450] l2cap_sock_accept: new socket ffff88005ede5800
    [69713.822368] [6450] l2cap_sock_getname: sock ffff8800941ab700, sk ffff88005ede5800
    [69713.822375] [6450] l2cap_sock_getsockopt: sk ffff88005ede5800
    [69713.822383] [6450] l2cap_sock_getname: sock ffff8800941ab700, sk ffff88005ede5800
    [69713.822414] [6450] bt_sock_poll: sock ffff8800941ab700, sk ffff88005ede5800
    ...
    [69713.823255] [6450] l2cap_sock_getname: sock ffff8800941ab700, sk ffff88005ede5800
    [69713.823259] [6450] l2cap_sock_getsockopt: sk ffff88005ede5800
    [69713.824322] [6450] l2cap_sock_getname: sock ffff8800941ab700, sk ffff88005ede5800
    [69713.824330] [6450] l2cap_sock_getsockopt: sk ffff88005ede5800
    [69713.825029] [6450] bt_sock_poll: sock ffff88005e758500, sk ffff88010323b800
    ...
    [69713.825187] [6450] l2cap_sock_sendmsg: sock ffff8800941ab700, sk ffff88005ede5800
    [69713.825189] [6450] bt_sock_wait_ready: sk ffff88005ede5800
    [69713.825192] [6450] l2cap_create_basic_pdu: chan ffff88005ede2c00 len 3
    [69713.825196] [6450] l2cap_do_send: chan ffff88005ede2c00, skb ffff880160b0b500 len 7 priority 0
    [69713.825199] [6450] hci_send_acl: hci0 chan ffff88020d60b1c0 flags 0x0000
    [69713.825201] [6450] hci_queue_acl: hci0 nonfrag skb ffff880160b0b500 len 11
    [69713.825210] [8909] hci_tx_work: hci0 acl 9 sco 8 le 0
    [69713.825213] [8909] hci_sched_acl: hci0
    [69713.825214] [8909] hci_sched_sco: hci0
    [69713.825216] [8909] hci_sched_esco: hci0
    [69713.825217] [8909] hci_sched_le: hci0
    [69713.825219] [8909] hci_chan_sent: hci0
    [69713.825221] [8909] hci_chan_sent: chan ffff88020d60b1c0 quote 9
    [69713.825223] [8909] hci_sched_le: chan ffff88020d60b1c0 skb ffff880160b0b500 len 11 priority 0
    [69713.825225] [8909] hci_send_frame: hci0 type 2 len 11
    [69713.825227] [8909] hci_send_to_monitor: hdev ffff88021f0c7000 len 11
    [69713.825242] [8909] hci_chan_sent: hci0
    [69713.825253] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69713.825253] [8909] hci_prio_recalculate: hci0
    [69713.825292] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69713.825768] [6450] bt_sock_poll: sock ffff88005e758500, sk ffff88010323b800
    ...
    [69713.866902] [8909] hci_rx_work: hci0
    [69713.866921] [8909] hci_send_to_monitor: hdev ffff88021f0c7000 len 7
    [69713.866928] [8909] hci_rx_work: hci0 Event packet
    [69713.866931] [8909] hci_num_comp_pkts_evt: hci0 num_hndl 1
    [69713.866937] [8909] hci_tx_work: hci0 acl 9 sco 8 le 0
    [69713.866939] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69713.866940] [8909] hci_sched_acl: hci0
    ...
    [69713.866944] [8909] hci_sched_le: hci0
    [69713.866953] [8909] hci_chan_sent: hci0
    [69713.866997] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69713.867840] [28074] hci_rx_work: hci0
    [69713.867844] [28074] hci_send_to_monitor: hdev ffff88021f0c7000 len 7
    [69713.867850] [28074] hci_rx_work: hci0 Event packet
    [69713.867853] [28074] hci_num_comp_pkts_evt: hci0 num_hndl 1
    [69713.867857] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69713.867858] [28074] hci_tx_work: hci0 acl 10 sco 8 le 0
    [69713.867860] [28074] hci_sched_acl: hci0
    [69713.867861] [28074] hci_sched_sco: hci0
    [69713.867862] [28074] hci_sched_esco: hci0
    [69713.867863] [28074] hci_sched_le: hci0
    [69713.867865] [28074] hci_chan_sent: hci0
    [69713.867888] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69714.145661] [8909] hci_rx_work: hci0
    [69714.145666] [8909] hci_send_to_monitor: hdev ffff88021f0c7000 len 10
    [69714.145676] [8909] hci_rx_work: hci0 ACL data packet
    [69714.145679] [8909] hci_acldata_packet: hci0 len 6 handle 0x002d flags 0x0002
    [69714.145681] [8909] hci_conn_enter_active_mode: hcon ffff88021f65a000 mode 0
    [69714.145683] [8909] l2cap_recv_acldata: conn ffff880221005c00 len 6 flags 0x2
    [69714.145693] [8909] l2cap_recv_frame: len 2, cid 0x0006
    [69714.145696] [8909] hci_send_to_control: len 14
    [69714.145710] [8909] smp_chan_destroy:
    [69714.145713] [8909] pairing_complete: status 3
    [69714.145714] [8909] cmd_complete: sock ffff88010323ac00
    [69714.145717] [8909] hci_conn_drop: hcon ffff88021f65a000 orig refcnt 3
    [69714.145719] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69714.145720] [6450] bt_sock_poll: sock ffff88005e758500, sk ffff88010323b800
    [69714.145722] [6515] hci_sock_recvmsg: sock ffff88005e75a080, sk ffff88010323ac00
    [69714.145724] [6450] bt_sock_poll: sock ffff8801db6b4f00, sk ffff880160351c00
    ...
    [69714.145735] [6515] hci_sock_recvmsg: sock ffff88005e75a080, sk ffff88010323ac00
    [69714.145737] [8909] hci_conn_drop: hcon ffff88021f65a000 orig refcnt 2
    [69714.145739] [8909] l2cap_conn_del: hcon ffff88021f65a000 conn ffff880221005c00, err 13
    [69714.145740] [6450] bt_sock_poll: sock ffff8801db6b5400, sk ffff88021e775000
    [69714.145743] [6450] bt_sock_poll: sock ffff8801db6b5e00, sk ffff880160356000
    [69714.145744] [8909] l2cap_chan_hold: chan ffff88005ede2c00 orig refcnt 3
    [69714.145746] [6450] bt_sock_poll: sock ffff8800941ab700, sk ffff88005ede5800
    [69714.145748] [8909] l2cap_chan_del: chan ffff88005ede2c00, conn ffff880221005c00, err 13
    [69714.145749] [8909] l2cap_chan_put: chan ffff88005ede2c00 orig refcnt 4
    [69714.145751] [8909] hci_conn_drop: hcon ffff88021f65a000 orig refcnt 1
    [69714.145754] [6450] bt_sock_poll: sock ffff8800941ab700, sk ffff88005ede5800
    [69714.145756] [8909] l2cap_chan_put: chan ffff88005ede2c00 orig refcnt 3
    [69714.145759] [8909] hci_chan_del: hci0 hcon ffff88021f65a000 chan ffff88020d60b1c0
    [69714.145766] [5949] hci_sock_recvmsg: sock ffff8800941a9680, sk ffff88012bf4d000
    [69714.145787] [6515] hci_sock_release: sock ffff88005e75a080 sk ffff88010323ac00
    [69714.146002] [6450] hci_sock_recvmsg: sock ffff88005e758780, sk ffff88010323d400
    [69714.150795] [6450] l2cap_sock_release: sock ffff8800941ab700, sk ffff88005ede5800
    [69714.150799] [6450] l2cap_sock_shutdown: sock ffff8800941ab700, sk ffff88005ede5800
    [69714.150802] [6450] l2cap_chan_close: chan ffff88005ede2c00 state BT_CLOSED
    [69714.150805] [6450] l2cap_sock_kill: sk ffff88005ede5800 state BT_CLOSED
    [69714.150806] [6450] l2cap_chan_put: chan ffff88005ede2c00 orig refcnt 2
    [69714.150808] [6450] l2cap_sock_destruct: sk ffff88005ede5800
    [69714.150809] [6450] l2cap_chan_put: chan ffff88005ede2c00 orig refcnt 1
    [69714.150811] [6450] l2cap_chan_destroy: chan ffff88005ede2c00
    [69714.150970] [6450] bt_sock_poll: sock ffff88005e758500, sk ffff88010323b800
    ...
    [69714.151991] [8909] hci_conn_drop: hcon ffff88021f65a000 orig refcnt 0
    [69716.150339] [8909] hci_conn_timeout: hcon ffff88021f65a000 state BT_CONNECTED, refcnt -1
    
    Signed-off-by: Lukasz Rymanowski <lukasz.rymanowski@tieto.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ca01d1861854..a7a27bc2c0b1 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -289,10 +289,20 @@ static void hci_conn_timeout(struct work_struct *work)
 {
 	struct hci_conn *conn = container_of(work, struct hci_conn,
 					     disc_work.work);
+	int refcnt = atomic_read(&conn->refcnt);
 
 	BT_DBG("hcon %p state %s", conn, state_to_string(conn->state));
 
-	if (atomic_read(&conn->refcnt))
+	WARN_ON(refcnt < 0);
+
+	/* FIXME: It was observed that in pairing failed scenario, refcnt
+	 * drops below 0. Probably this is because l2cap_conn_del calls
+	 * l2cap_chan_del for each channel, and inside l2cap_chan_del conn is
+	 * dropped. After that loop hci_chan_del is called which also drops
+	 * conn. For now make sure that ACL is alive if refcnt is higher then 0,
+	 * otherwise drop it.
+	 */
+	if (refcnt > 0)
 		return;
 
 	switch (conn->state) {

commit e694788d73efe139b24f78b036deb97fe57fa8cb
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Jun 10 09:54:24 2014 +0300

    Bluetooth: Fix check for connection encryption
    
    The conn->link_key variable tracks the type of link key in use. It is
    set whenever we respond to a link key request as well as when we get a
    link key notification event.
    
    These two events do not however always guarantee that encryption is
    enabled: getting a link key request and responding to it may only mean
    that the remote side has requested authentication but not encryption. On
    the other hand, the encrypt change event is a certain guarantee that
    encryption is enabled. The real encryption state is already tracked in
    the conn->link_mode variable through the HCI_LM_ENCRYPT bit.
    
    This patch fixes a check for encryption in the hci_conn_auth function to
    use the proper conn->link_mode value and thereby eliminates the chance
    of a false positive result.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable@vger.kernel.org

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b9b2bd464bec..ca01d1861854 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -889,7 +889,7 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 		/* If we're already encrypted set the REAUTH_PEND flag,
 		 * otherwise set the ENCRYPT_PEND.
 		 */
-		if (conn->key_type != 0xff)
+		if (conn->link_mode & HCI_LM_ENCRYPT)
 			set_bit(HCI_CONN_REAUTH_PEND, &conn->flags);
 		else
 			set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);

commit b62b65055bcc5372d5c3f4103629176cb8db3678
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Thu Jun 5 12:19:54 2014 +0300

    Bluetooth: Fix incorrectly overriding conn->src_type
    
    The src_type member of struct hci_conn should always reflect the address
    type of the src_member. It should never be overridden. There is already
    code in place in the command status handler of HCI_LE_Create_Connection
    to copy the right initiator address into conn->init_addr_type.
    
    Without this patch, if privacy is enabled, we will send the wrong
    address type in the SMP identity address information PDU (it'll e.g.
    contain our public address but a random address type).
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable@vger.kernel.org

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 8671bc79a35b..b9b2bd464bec 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -610,11 +610,6 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	if (hci_update_random_address(req, false, &own_addr_type))
 		return;
 
-	/* Save the address type used for this connnection attempt so we able
-	 * to retrieve this information if we need it.
-	 */
-	conn->src_type = own_addr_type;
-
 	cp.scan_interval = cpu_to_le16(hdev->le_scan_interval);
 	cp.scan_window = cpu_to_le16(hdev->le_scan_window);
 	bacpy(&cp.peer_addr, &conn->dst);

commit a5eb1aeb25df89c627248a162cc35ffb556dc486
Merge: 737be10d8cb7 d7b2545023ec
Author: John W. Linville <linville@tuxdriver.com>
Date:   Thu May 29 13:03:47 2014 -0400

    Merge branch 'for-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next
    
    Conflicts:
            drivers/bluetooth/btusb.c

commit 4bc58f51e156227d139668199ffe5df2ccb2f3c2
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue May 20 09:45:47 2014 +0300

    Bluetooth: Make SMP context private to smp.c
    
    There are no users of the smp_chan struct outside of smp.c so move it
    away from smp.h. The addition of the l2cap.h include to hci_core.c,
    hci_conn.c and mgmt.c is something that should have been there already
    previously to avoid warnings of undeclared struct l2cap_conn, but the
    compiler warning was apparently shadowed away by the mention of
    l2cap_conn in the struct smp_chan definition.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a987e7def025..1bb8900086dd 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -28,6 +28,7 @@
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
+#include <net/bluetooth/l2cap.h>
 
 #include "smp.h"
 #include "a2mp.h"

commit d0455ed996df84fd2670a655fe13ab72f8264765
Author: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
Date:   Wed May 14 13:43:05 2014 +0200

    Bluetooth: Store max TX power level for connection
    
    This patch adds support to store local maximum TX power level for
    connection when reply for HCI_Read_Transmit_Power_Level is received.
    
    Signed-off-by: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 74b368bfe102..a987e7def025 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -408,6 +408,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	conn->remote_auth = 0xff;
 	conn->key_type = 0xff;
 	conn->tx_power = HCI_TX_POWER_INVALID;
+	conn->max_tx_power = HCI_TX_POWER_INVALID;
 
 	set_bit(HCI_CONN_POWER_SAVE, &conn->flags);
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;

commit 3231d65ffe36e177caf5006d4079867d9b7b2d4a
Merge: 0d770a82ad8a 209f6c37540a
Author: John W. Linville <linville@tuxdriver.com>
Date:   Tue May 13 15:27:44 2014 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/linville/wireless

commit 5a134faeef82b46ff4ad244d11d8c6be41679834
Author: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
Date:   Fri May 9 21:35:28 2014 +0200

    Bluetooth: Store TX power level for connection
    
    This patch adds support to store local TX power level for connection
    when reply for HCI_Read_Transmit_Power_Level is received.
    
    Signed-off-by: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 55a174317925..74b368bfe102 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -407,6 +407,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	conn->io_capability = hdev->io_capability;
 	conn->remote_auth = 0xff;
 	conn->key_type = 0xff;
+	conn->tx_power = HCI_TX_POWER_INVALID;
 
 	set_bit(HCI_CONN_POWER_SAVE, &conn->flags);
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;

commit 09da1f3463eb81d59685df723b1c5950b7570340
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Apr 11 12:02:32 2014 -0700

    Bluetooth: Fix redundant encryption request for reauthentication
    
    When we're performing reauthentication (in order to elevate the
    security level from an unauthenticated key to an authenticated one) we
    do not need to issue any encryption command once authentication
    completes. Since the trigger for the encryption HCI command is the
    ENCRYPT_PEND flag this flag should not be set in this scenario.
    Instead, the REAUTH_PEND flag takes care of all necessary steps for
    reauthentication.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Cc: stable@vger.kernel.org

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index d958e2dca52f..521fd4f3985e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -819,14 +819,17 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_auth_requested cp;
 
-		/* encrypt must be pending if auth is also pending */
-		set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
-
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
 			     sizeof(cp), &cp);
+
+		/* If we're already encrypted set the REAUTH_PEND flag,
+		 * otherwise set the ENCRYPT_PEND.
+		 */
 		if (conn->key_type != 0xff)
 			set_bit(HCI_CONN_REAUTH_PEND, &conn->flags);
+		else
+			set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
 	}
 
 	return 0;

commit 3c857757ef6e5a4e472bd3e5c934709c2eb482af
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Mar 25 10:30:49 2014 +0200

    Bluetooth: Add directed advertising support through connect()
    
    When we're in peripheral mode (HCI_ADVERTISING flag is set) the most
    natural mapping of connect() is to perform directed advertising to the
    peer device.
    
    This patch does the necessary changes to enable directed advertising and
    keeps the hci_conn state as BT_CONNECT in a similar way as is done for
    central or BR/EDR connection initiation.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 129c22a85ccf..55a174317925 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -367,9 +367,23 @@ static void le_conn_timeout(struct work_struct *work)
 {
 	struct hci_conn *conn = container_of(work, struct hci_conn,
 					     le_conn_timeout.work);
+	struct hci_dev *hdev = conn->hdev;
 
 	BT_DBG("");
 
+	/* We could end up here due to having done directed advertising,
+	 * so clean up the state if necessary. This should however only
+	 * happen with broken hardware or if low duty cycle was used
+	 * (which doesn't have a timeout of its own).
+	 */
+	if (test_bit(HCI_ADVERTISING, &hdev->dev_flags)) {
+		u8 enable = 0x00;
+		hci_send_cmd(hdev, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable),
+			     &enable);
+		hci_le_conn_failed(conn, HCI_ERROR_ADVERTISING_TIMEOUT);
+		return;
+	}
+
 	hci_le_create_connection_cancel(conn);
 }
 
@@ -549,6 +563,11 @@ void hci_le_conn_failed(struct hci_conn *conn, u8 status)
 	 * favor of connection establishment, we should restart it.
 	 */
 	hci_update_background_scan(hdev);
+
+	/* Re-enable advertising in case this was a failed connection
+	 * attempt as a peripheral.
+	 */
+	mgmt_reenable_advertising(hdev);
 }
 
 static void create_le_conn_complete(struct hci_dev *hdev, u8 status)
@@ -609,6 +628,45 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	conn->state = BT_CONNECT;
 }
 
+static void hci_req_directed_advertising(struct hci_request *req,
+					 struct hci_conn *conn)
+{
+	struct hci_dev *hdev = req->hdev;
+	struct hci_cp_le_set_adv_param cp;
+	u8 own_addr_type;
+	u8 enable;
+
+	enable = 0x00;
+	hci_req_add(req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable), &enable);
+
+	/* Clear the HCI_ADVERTISING bit temporarily so that the
+	 * hci_update_random_address knows that it's safe to go ahead
+	 * and write a new random address. The flag will be set back on
+	 * as soon as the SET_ADV_ENABLE HCI command completes.
+	 */
+	clear_bit(HCI_ADVERTISING, &hdev->dev_flags);
+
+	/* Set require_privacy to false so that the remote device has a
+	 * chance of identifying us.
+	 */
+	if (hci_update_random_address(req, false, &own_addr_type) < 0)
+		return;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.type = LE_ADV_DIRECT_IND;
+	cp.own_address_type = own_addr_type;
+	cp.direct_addr_type = conn->dst_type;
+	bacpy(&cp.direct_addr, &conn->dst);
+	cp.channel_map = hdev->le_adv_channel_map;
+
+	hci_req_add(req, HCI_OP_LE_SET_ADV_PARAM, sizeof(cp), &cp);
+
+	enable = 0x01;
+	hci_req_add(req, HCI_OP_LE_SET_ADV_ENABLE, sizeof(enable), &enable);
+
+	conn->state = BT_CONNECT;
+}
+
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				u8 dst_type, u8 sec_level, u8 auth_type)
 {
@@ -618,9 +676,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	struct hci_request req;
 	int err;
 
-	if (test_bit(HCI_ADVERTISING, &hdev->flags))
-		return ERR_PTR(-ENOTSUPP);
-
 	/* Some devices send ATT messages as soon as the physical link is
 	 * established. To be able to handle these ATT messages, the user-
 	 * space first establishes the connection and then starts the pairing
@@ -668,13 +723,20 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		return ERR_PTR(-ENOMEM);
 
 	conn->dst_type = dst_type;
-
-	conn->out = true;
-	conn->link_mode |= HCI_LM_MASTER;
 	conn->sec_level = BT_SECURITY_LOW;
 	conn->pending_sec_level = sec_level;
 	conn->auth_type = auth_type;
 
+	hci_req_init(&req, hdev);
+
+	if (test_bit(HCI_ADVERTISING, &hdev->dev_flags)) {
+		hci_req_directed_advertising(&req, conn);
+		goto create_conn;
+	}
+
+	conn->out = true;
+	conn->link_mode |= HCI_LM_MASTER;
+
 	params = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);
 	if (params) {
 		conn->le_conn_min_interval = params->conn_min_interval;
@@ -684,8 +746,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		conn->le_conn_max_interval = hdev->le_conn_max_interval;
 	}
 
-	hci_req_init(&req, hdev);
-
 	/* If controller is scanning, we stop it since some controllers are
 	 * not able to scan and connect at the same time. Also set the
 	 * HCI_LE_SCAN_INTERRUPTED flag so that the command complete
@@ -699,6 +759,7 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 
 	hci_req_add_le_create_conn(&req, conn);
 
+create_conn:
 	err = hci_req_run(&req, create_le_conn_complete);
 	if (err) {
 		hci_conn_del(conn);

commit 9c84d1da974ee8b54fa49ae369648a0247b7cd6f
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Mar 24 20:21:50 2014 +0200

    Bluetooth: Move local identity address setting to a central place
    
    Any time hci_conn_add is used for an LE connection we need to ensure
    that the local identity address is correctly described in the src and
    src_type variables. This patch moves setting these values directly into
    hci_conn_add so that callers don't have to duplicate the effort
    themselves.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index d958e2dca52f..129c22a85ccf 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -401,6 +401,10 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	case ACL_LINK:
 		conn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;
 		break;
+	case LE_LINK:
+		/* conn->src should reflect the local identity address */
+		hci_copy_identity_address(hdev, &conn->src, &conn->src_type);
+		break;
 	case SCO_LINK:
 		if (lmp_esco_capable(hdev))
 			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |

commit 40b552aa5a0bfa785bc7ddb5c2d7965b1e0bb08d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Mar 19 14:10:25 2014 -0700

    Bluetooth: Enforce strict Secure Connections Only mode security
    
    In Secure Connections Only mode, it is required that Secure Connections
    is used for pairing and that the link key is encrypted with AES-CCM using
    a P-256 authenticated combination key. If this is not the case, then new
    connection shall be refused or existing connections shall be dropped.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b4809e473a19..d958e2dca52f 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -781,6 +781,17 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 {
 	BT_DBG("hcon %p", conn);
 
+	/* In Secure Connections Only mode, it is required that Secure
+	 * Connections is used and the link is encrypted with AES-CCM
+	 * using a P-256 authenticated combination key.
+	 */
+	if (test_bit(HCI_SC_ONLY, &conn->hdev->flags)) {
+		if (!hci_conn_sc_enabled(conn) ||
+		    !test_bit(HCI_CONN_AES_CCM, &conn->flags) ||
+		    conn->key_type != HCI_LK_AUTH_COMBINATION_P256)
+			return 0;
+	}
+
 	if (hci_conn_ssp_enabled(conn) && !(conn->link_mode & HCI_LM_ENCRYPT))
 		return 0;
 

commit dcf4adbfdc7ad14ca50c1133f93f998c78493c2d
Author: Joe Perches <joe@perches.com>
Date:   Wed Mar 12 10:52:35 2014 -0700

    Bluetooth: Convert uses of __constant_<foo> to <foo>
    
    The use of __constant_<foo> has been unnecessary for quite awhile now.
    
    Make these uses consistent with the rest of the kernel.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7c713c4675ba..b4809e473a19 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -82,7 +82,7 @@ static void hci_acl_create_connection(struct hci_conn *conn)
 			cp.pscan_rep_mode = ie->data.pscan_rep_mode;
 			cp.pscan_mode     = ie->data.pscan_mode;
 			cp.clock_offset   = ie->data.clock_offset |
-					    __constant_cpu_to_le16(0x8000);
+					    cpu_to_le16(0x8000);
 		}
 
 		memcpy(conn->dev_class, ie->data.dev_class, 3);
@@ -182,8 +182,8 @@ bool hci_setup_sync(struct hci_conn *conn, __u16 handle)
 
 	cp.handle   = cpu_to_le16(handle);
 
-	cp.tx_bandwidth   = __constant_cpu_to_le32(0x00001f40);
-	cp.rx_bandwidth   = __constant_cpu_to_le32(0x00001f40);
+	cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
+	cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
 	cp.voice_setting  = cpu_to_le16(conn->setting);
 
 	switch (conn->setting & SCO_AIRMODE_MASK) {
@@ -225,8 +225,8 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 	cp.conn_interval_max	= cpu_to_le16(max);
 	cp.conn_latency		= cpu_to_le16(latency);
 	cp.supervision_timeout	= cpu_to_le16(to_multiplier);
-	cp.min_ce_len		= __constant_cpu_to_le16(0x0000);
-	cp.max_ce_len		= __constant_cpu_to_le16(0x0000);
+	cp.min_ce_len		= cpu_to_le16(0x0000);
+	cp.max_ce_len		= cpu_to_le16(0x0000);
 
 	hci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);
 }
@@ -337,9 +337,9 @@ static void hci_conn_idle(struct work_struct *work)
 	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
 		struct hci_cp_sniff_subrate cp;
 		cp.handle             = cpu_to_le16(conn->handle);
-		cp.max_latency        = __constant_cpu_to_le16(0);
-		cp.min_remote_timeout = __constant_cpu_to_le16(0);
-		cp.min_local_timeout  = __constant_cpu_to_le16(0);
+		cp.max_latency        = cpu_to_le16(0);
+		cp.min_remote_timeout = cpu_to_le16(0);
+		cp.min_local_timeout  = cpu_to_le16(0);
 		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
 	}
 
@@ -348,8 +348,8 @@ static void hci_conn_idle(struct work_struct *work)
 		cp.handle       = cpu_to_le16(conn->handle);
 		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
 		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
-		cp.attempt      = __constant_cpu_to_le16(4);
-		cp.timeout      = __constant_cpu_to_le16(1);
+		cp.attempt      = cpu_to_le16(4);
+		cp.timeout      = cpu_to_le16(1);
 		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
 	}
 }
@@ -596,9 +596,9 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	cp.own_address_type = own_addr_type;
 	cp.conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
 	cp.conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
-	cp.supervision_timeout = __constant_cpu_to_le16(0x002a);
-	cp.min_ce_len = __constant_cpu_to_le16(0x0000);
-	cp.max_ce_len = __constant_cpu_to_le16(0x0000);
+	cp.supervision_timeout = cpu_to_le16(0x002a);
+	cp.min_ce_len = cpu_to_le16(0x0000);
+	cp.max_ce_len = cpu_to_le16(0x0000);
 
 	hci_req_add(req, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
 

commit 81ad6fd9698f659dbabdc6cd3e1667a98eb2be3b
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Feb 28 20:26:13 2014 +0200

    Bluetooth: Remove unnecessary stop_scan_complete function
    
    The stop_scan_complete function was used as an intermediate step before
    doing the actual connection creation. Since we're using hci_request
    there's no reason to have this extra function around, i.e. we can simply
    put both HCI commands into the same request.
    
    The single task that the intermediate function had, i.e. indicating
    discovery as stopped is now taken care of by a new
    HCI_LE_SCAN_INTERRUPTED flag which allows us to do the discovery state
    update when the stop scan command completes.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5330fcfde93d..7c713c4675ba 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -605,44 +605,6 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	conn->state = BT_CONNECT;
 }
 
-static void stop_scan_complete(struct hci_dev *hdev, u8 status)
-{
-	struct hci_request req;
-	struct hci_conn *conn;
-	int err;
-
-	conn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
-	if (!conn)
-		return;
-
-	if (status) {
-		BT_DBG("HCI request failed to stop scanning: status 0x%2.2x",
-		       status);
-
-		hci_dev_lock(hdev);
-		hci_le_conn_failed(conn, status);
-		hci_dev_unlock(hdev);
-		return;
-	}
-
-	/* Since we may have prematurely stopped discovery procedure, we should
-	 * update discovery state.
-	 */
-	hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
-
-	hci_req_init(&req, hdev);
-
-	hci_req_add_le_create_conn(&req, conn);
-
-	err = hci_req_run(&req, create_le_conn_complete);
-	if (err) {
-		hci_dev_lock(hdev);
-		hci_le_conn_failed(conn, HCI_ERROR_MEMORY_EXCEEDED);
-		hci_dev_unlock(hdev);
-		return;
-	}
-}
-
 struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				u8 dst_type, u8 sec_level, u8 auth_type)
 {
@@ -721,16 +683,19 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	hci_req_init(&req, hdev);
 
 	/* If controller is scanning, we stop it since some controllers are
-	 * not able to scan and connect at the same time.
+	 * not able to scan and connect at the same time. Also set the
+	 * HCI_LE_SCAN_INTERRUPTED flag so that the command complete
+	 * handler for scan disabling knows to set the correct discovery
+	 * state.
 	 */
 	if (test_bit(HCI_LE_SCAN, &hdev->dev_flags)) {
 		hci_req_add_le_scan_disable(&req);
-		err = hci_req_run(&req, stop_scan_complete);
-	} else {
-		hci_req_add_le_create_conn(&req, conn);
-		err = hci_req_run(&req, create_le_conn_complete);
+		set_bit(HCI_LE_SCAN_INTERRUPTED, &hdev->dev_flags);
 	}
 
+	hci_req_add_le_create_conn(&req, conn);
+
+	err = hci_req_run(&req, create_le_conn_complete);
 	if (err) {
 		hci_conn_del(conn);
 		return ERR_PTR(err);

commit 317ac8cb3f9fb58b9ec5764b766a449004ab2a62
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Feb 28 20:26:12 2014 +0200

    Bluetooth: Fix trying to disable scanning twice
    
    The discovery process has a timer for disabling scanning, however
    scanning might be disabled through other means too like the auto-connect
    process.  We should therefore ensure that the timer is never active
    after sending a HCI command to disable scanning.
    
    There was some existing code in stop_scan_complete trying to avoid the
    timer when a connect request interrupts a discovery procedure, but the
    other way around was not covered. This patch covers both scenarios by
    canceling the timer as soon as we get a successful command complete for
    the disabling HCI command.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7e47e4240c95..5330fcfde93d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -628,7 +628,6 @@ static void stop_scan_complete(struct hci_dev *hdev, u8 status)
 	/* Since we may have prematurely stopped discovery procedure, we should
 	 * update discovery state.
 	 */
-	cancel_delayed_work(&hdev->le_scan_disable);
 	hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
 
 	hci_req_init(&req, hdev);

commit 9489eca4ab2fd5d9bbf3bab992168cc8107fc3e9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Feb 28 17:45:46 2014 +0200

    Bluetooth: Add timeout for LE connection attempts
    
    LE connection attempts do not have a controller side timeout in the same
    way as BR/EDR has (in form of the page timeout). Since we always do
    scanning before initiating connections the attempts are always expected
    to succeed in some reasonable time.
    
    This patch adds a timer which forces a cancellation of the connection
    attempt within 20 seconds if it has not been successful by then. This
    way we e.g. ensure that mgmt_pair_device times out eventually and gives
    an error response.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 818330c1b2a2..7e47e4240c95 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -363,6 +363,16 @@ static void hci_conn_auto_accept(struct work_struct *work)
 		     &conn->dst);
 }
 
+static void le_conn_timeout(struct work_struct *work)
+{
+	struct hci_conn *conn = container_of(work, struct hci_conn,
+					     le_conn_timeout.work);
+
+	BT_DBG("");
+
+	hci_le_create_connection_cancel(conn);
+}
+
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 {
 	struct hci_conn *conn;
@@ -410,6 +420,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	INIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);
 	INIT_DELAYED_WORK(&conn->auto_accept_work, hci_conn_auto_accept);
 	INIT_DELAYED_WORK(&conn->idle_work, hci_conn_idle);
+	INIT_DELAYED_WORK(&conn->le_conn_timeout, le_conn_timeout);
 
 	atomic_set(&conn->refcnt, 0);
 
@@ -442,6 +453,8 @@ int hci_conn_del(struct hci_conn *conn)
 		/* Unacked frames */
 		hdev->acl_cnt += conn->sent;
 	} else if (conn->type == LE_LINK) {
+		cancel_delayed_work_sync(&conn->le_conn_timeout);
+
 		if (hdev->le_pkts)
 			hdev->le_cnt += conn->sent;
 		else

commit b46e00308929cc0317a021a7ac050790f023b1ca
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Fri Feb 28 12:54:15 2014 +0200

    Bluetooth: Fix updating connection state to BT_CONNECT too early
    
    We shouldn't update the hci_conn state to BT_CONNECT until the moment
    that we're ready to send the initiating HCI command for it. If the
    connection has the BT_CONNECT state too early the code responsible for
    updating the local random address may incorrectly think there's a
    pending connection in progress and refuse to update the address.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5b0802994cbb..818330c1b2a2 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -588,6 +588,8 @@ static void hci_req_add_le_create_conn(struct hci_request *req,
 	cp.max_ce_len = __constant_cpu_to_le16(0x0000);
 
 	hci_req_add(req, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
+
+	conn->state = BT_CONNECT;
 }
 
 static void stop_scan_complete(struct hci_dev *hdev, u8 status)
@@ -689,7 +691,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 
 	conn->dst_type = dst_type;
 
-	conn->state = BT_CONNECT;
 	conn->out = true;
 	conn->link_mode |= HCI_LM_MASTER;
 	conn->sec_level = BT_SECURITY_LOW;

commit fe39c7b2dacf7fd4dcddc26704d01315ab92b7cb
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 27 16:00:28 2014 -0800

    Bluetooth: Use __le64 type for LE random numbers
    
    The random numbers in Bluetooth Low Energy are 64-bit numbers and should
    also be little endian since the HCI specification is little endian.
    
    Change the whole Low Energy pairing to use __le64 instead of a byte
    array.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7d6f05e3cae8..5b0802994cbb 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -231,7 +231,7 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 	hci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);
 }
 
-void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
+void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __le64 rand,
 		      __u8 ltk[16])
 {
 	struct hci_dev *hdev = conn->hdev;
@@ -242,9 +242,9 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 	memset(&cp, 0, sizeof(cp));
 
 	cp.handle = cpu_to_le16(conn->handle);
-	memcpy(cp.ltk, ltk, sizeof(cp.ltk));
+	cp.rand = rand;
 	cp.ediv = ediv;
-	memcpy(cp.rand, rand, sizeof(cp.rand));
+	memcpy(cp.ltk, ltk, sizeof(cp.ltk));
 
 	hci_send_cmd(hdev, HCI_OP_LE_START_ENC, sizeof(cp), &cp);
 }

commit a4790dbd43d1617b09d57e96494fde5a4b01980a
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:47 2014 -0300

    Bluetooth: Introduce LE auto connection infrastructure
    
    This patch introduces the LE auto connection infrastructure which
    will be used to implement the LE auto connection options.
    
    In summary, the auto connection mechanism works as follows: Once the
    first pending LE connection is created, the background scanning is
    started. When the target device is found in range, the kernel
    autonomously starts the connection attempt. If connection is
    established successfully, that pending LE connection is deleted and
    the background is stopped.
    
    To achieve that, this patch introduces the hci_update_background_scan()
    which controls the background scanning state. This function starts or
    stops the background scanning based on the hdev->pend_le_conns list. If
    there is no pending LE connection, the background scanning is stopped.
    Otherwise, we start the background scanning.
    
    Then, every time a pending LE connection is added we call hci_update_
    background_scan() so the background scanning is started (in case it is
    not already running). Likewise, every time a pending LE connection is
    deleted we call hci_update_background_scan() so the background scanning
    is stopped (in case this was the last pending LE connection) or it is
    started again (in case we have more pending LE connections). Finally,
    we also call hci_update_background_scan() in hci_le_conn_failed() so
    the background scan is restarted in case the connection establishment
    fails. This way the background scanning keeps running until all pending
    LE connection are established.
    
    At this point, resolvable addresses are not support by this
    infrastructure. The proper support is added in upcoming patches.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 46b27133740f..7d6f05e3cae8 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -527,6 +527,11 @@ void hci_le_conn_failed(struct hci_conn *conn, u8 status)
 	hci_proto_connect_cfm(conn, status);
 
 	hci_conn_del(conn);
+
+	/* Since we may have temporarily stopped the background scanning in
+	 * favor of connection establishment, we should restart it.
+	 */
+	hci_update_background_scan(hdev);
 }
 
 static void create_le_conn_complete(struct hci_dev *hdev, u8 status)

commit 6f77d8c757523f675679d845ff0e15d3276a168a
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:45 2014 -0300

    Bluetooth: Move address type conversion to outside hci_connect_le
    
    This patch moves address type conversion (L2CAP address type to HCI
    address type) to outside hci_connect_le. This way, we avoid back and
    forth address type conversion in a comming patch.
    
    So hci_connect_le() now expects 'dst_type' parameter in HCI address
    type convention.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5c392aaed5a9..46b27133740f 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -659,12 +659,6 @@ struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	if (conn)
 		return ERR_PTR(-EBUSY);
 
-	/* Convert from L2CAP channel address type to HCI address type */
-	if (dst_type == BDADDR_LE_PUBLIC)
-		dst_type = ADDR_LE_DEV_PUBLIC;
-	else
-		dst_type = ADDR_LE_DEV_RANDOM;
-
 	/* When given an identity address with existing identity
 	 * resolving key, the connection needs to be established
 	 * to a resolvable random address.

commit 04a6c5898e8cbb46313b7d425001b701f0fa4e3d
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:44 2014 -0300

    Bluetooth: Refactor HCI connection code
    
    hci_connect() is a very simple and useless wrapper of hci_connect_acl
    and hci_connect_le functions. Addtionally, all places where hci_connect
    is called the link type value is passed explicitly. This way, we can
    safely delete hci_connect, declare hci_connect_acl and hci_connect_le
    in hci_core.h and call them directly.
    
    No functionality is changed by this patch.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 296b8ee42451..5c392aaed5a9 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -624,8 +624,8 @@ static void stop_scan_complete(struct hci_dev *hdev, u8 status)
 	}
 }
 
-static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
-				    u8 dst_type, u8 sec_level, u8 auth_type)
+struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
+				u8 dst_type, u8 sec_level, u8 auth_type)
 {
 	struct hci_conn_params *params;
 	struct hci_conn *conn;
@@ -729,8 +729,8 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	return conn;
 }
 
-static struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
-						u8 sec_level, u8 auth_type)
+struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
+				 u8 sec_level, u8 auth_type)
 {
 	struct hci_conn *acl;
 
@@ -799,22 +799,6 @@ struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,
 	return sco;
 }
 
-/* Create SCO, ACL or LE connection. */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
-			     __u8 dst_type, __u8 sec_level, __u8 auth_type)
-{
-	BT_DBG("%s dst %pMR type 0x%x", hdev->name, dst, type);
-
-	switch (type) {
-	case LE_LINK:
-		return hci_connect_le(hdev, dst, dst_type, sec_level, auth_type);
-	case ACL_LINK:
-		return hci_connect_acl(hdev, dst, sec_level, auth_type);
-	}
-
-	return ERR_PTR(-EINVAL);
-}
-
 /* Check link security requirement */
 int hci_conn_check_link_mode(struct hci_conn *conn)
 {

commit c99ed8343cdf84279f4d1937d25a3b644a14ed0d
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:43 2014 -0300

    Bluetooth: Remove unused function
    
    This patch removes hci_create_le_conn() since it is not used anymore.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 2b8bfda3ea35..296b8ee42451 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -551,49 +551,6 @@ static void create_le_conn_complete(struct hci_dev *hdev, u8 status)
 	hci_dev_unlock(hdev);
 }
 
-static int hci_create_le_conn(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_le_create_conn cp;
-	struct hci_request req;
-	u8 own_addr_type;
-	int err;
-
-	hci_req_init(&req, hdev);
-
-	memset(&cp, 0, sizeof(cp));
-
-	/* Update random address, but set require_privacy to false so
-	 * that we never connect with an unresolvable address.
-	 */
-	err = hci_update_random_address(&req, false, &own_addr_type);
-	if (err < 0)
-		return err;
-
-	conn->src_type = own_addr_type;
-
-	cp.scan_interval = cpu_to_le16(hdev->le_scan_interval);
-	cp.scan_window = cpu_to_le16(hdev->le_scan_window);
-	bacpy(&cp.peer_addr, &conn->dst);
-	cp.peer_addr_type = conn->dst_type;
-	cp.own_address_type = own_addr_type;
-	cp.conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
-	cp.conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
-	cp.supervision_timeout = __constant_cpu_to_le16(0x002a);
-	cp.min_ce_len = __constant_cpu_to_le16(0x0000);
-	cp.max_ce_len = __constant_cpu_to_le16(0x0000);
-
-	hci_req_add(&req, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
-
-	err = hci_req_run(&req, create_le_conn_complete);
-	if (err) {
-		hci_conn_del(conn);
-		return err;
-	}
-
-	return 0;
-}
-
 static void hci_req_add_le_create_conn(struct hci_request *req,
 				       struct hci_conn *conn)
 {

commit 2acf3d9066b36e1b05db42bfe43152eee07a5e9e
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:42 2014 -0300

    Bluetooth: Stop scanning on LE connection
    
    Some LE controllers don't support scanning and creating a connection
    at the same time. So we should always stop scanning in order to
    establish the connection.
    
    Since we may prematurely stop the discovery procedure in favor of
    the connection establishment, we should also cancel hdev->le_scan_
    disable delayed work and set the discovery state to DISCOVERY_STOPPED.
    
    This change does a small improvement since it is not mandatory the
    user stops scanning before connecting anymore. Moreover, this change
    is required by upcoming LE auto connection mechanism in order to work
    properly with controllers that don't support background scanning and
    connection establishment at the same time.
    
    In future, we might want to do a small optimization by checking if
    controller is able to scan and connect at the same time. For now,
    we want the simplest approach so we always stop scanning (even if
    the controller is able to carry out both operations).
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index dc8aad946426..2b8bfda3ea35 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -594,12 +594,86 @@ static int hci_create_le_conn(struct hci_conn *conn)
 	return 0;
 }
 
+static void hci_req_add_le_create_conn(struct hci_request *req,
+				       struct hci_conn *conn)
+{
+	struct hci_cp_le_create_conn cp;
+	struct hci_dev *hdev = conn->hdev;
+	u8 own_addr_type;
+
+	memset(&cp, 0, sizeof(cp));
+
+	/* Update random address, but set require_privacy to false so
+	 * that we never connect with an unresolvable address.
+	 */
+	if (hci_update_random_address(req, false, &own_addr_type))
+		return;
+
+	/* Save the address type used for this connnection attempt so we able
+	 * to retrieve this information if we need it.
+	 */
+	conn->src_type = own_addr_type;
+
+	cp.scan_interval = cpu_to_le16(hdev->le_scan_interval);
+	cp.scan_window = cpu_to_le16(hdev->le_scan_window);
+	bacpy(&cp.peer_addr, &conn->dst);
+	cp.peer_addr_type = conn->dst_type;
+	cp.own_address_type = own_addr_type;
+	cp.conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
+	cp.conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
+	cp.supervision_timeout = __constant_cpu_to_le16(0x002a);
+	cp.min_ce_len = __constant_cpu_to_le16(0x0000);
+	cp.max_ce_len = __constant_cpu_to_le16(0x0000);
+
+	hci_req_add(req, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
+}
+
+static void stop_scan_complete(struct hci_dev *hdev, u8 status)
+{
+	struct hci_request req;
+	struct hci_conn *conn;
+	int err;
+
+	conn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
+	if (!conn)
+		return;
+
+	if (status) {
+		BT_DBG("HCI request failed to stop scanning: status 0x%2.2x",
+		       status);
+
+		hci_dev_lock(hdev);
+		hci_le_conn_failed(conn, status);
+		hci_dev_unlock(hdev);
+		return;
+	}
+
+	/* Since we may have prematurely stopped discovery procedure, we should
+	 * update discovery state.
+	 */
+	cancel_delayed_work(&hdev->le_scan_disable);
+	hci_discovery_set_state(hdev, DISCOVERY_STOPPED);
+
+	hci_req_init(&req, hdev);
+
+	hci_req_add_le_create_conn(&req, conn);
+
+	err = hci_req_run(&req, create_le_conn_complete);
+	if (err) {
+		hci_dev_lock(hdev);
+		hci_le_conn_failed(conn, HCI_ERROR_MEMORY_EXCEEDED);
+		hci_dev_unlock(hdev);
+		return;
+	}
+}
+
 static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				    u8 dst_type, u8 sec_level, u8 auth_type)
 {
 	struct hci_conn_params *params;
 	struct hci_conn *conn;
 	struct smp_irk *irk;
+	struct hci_request req;
 	int err;
 
 	if (test_bit(HCI_ADVERTISING, &hdev->flags))
@@ -675,9 +749,23 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		conn->le_conn_max_interval = hdev->le_conn_max_interval;
 	}
 
-	err = hci_create_le_conn(conn);
-	if (err)
+	hci_req_init(&req, hdev);
+
+	/* If controller is scanning, we stop it since some controllers are
+	 * not able to scan and connect at the same time.
+	 */
+	if (test_bit(HCI_LE_SCAN, &hdev->dev_flags)) {
+		hci_req_add_le_scan_disable(&req);
+		err = hci_req_run(&req, stop_scan_complete);
+	} else {
+		hci_req_add_le_create_conn(&req, conn);
+		err = hci_req_run(&req, create_le_conn_complete);
+	}
+
+	if (err) {
+		hci_conn_del(conn);
 		return ERR_PTR(err);
+	}
 
 done:
 	hci_conn_hold(conn);

commit 06c053fb54c10be49ef30fc9b6b01e42cc9a1b61
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Feb 26 20:21:41 2014 -0300

    Bluetooth: Declare le_conn_failed in hci_core.h
    
    This patch adds the "hci_" prefix to le_conn_failed() helper and
    declares it in hci_core.h so it can be reused in hci_event.c.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3d6b1cf07d23..dc8aad946426 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -515,7 +515,7 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 EXPORT_SYMBOL(hci_get_route);
 
 /* This function requires the caller holds hdev->lock */
-static void le_conn_failed(struct hci_conn *conn, u8 status)
+void hci_le_conn_failed(struct hci_conn *conn, u8 status)
 {
 	struct hci_dev *hdev = conn->hdev;
 
@@ -545,7 +545,7 @@ static void create_le_conn_complete(struct hci_dev *hdev, u8 status)
 	if (!conn)
 		goto done;
 
-	le_conn_failed(conn, status);
+	hci_le_conn_failed(conn, status);
 
 done:
 	hci_dev_unlock(hdev);

commit 94b1fc92cd7cf550460ffd4bcc08c2707564aa49
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Feb 23 20:25:54 2014 -0800

    Bluetooth: Use unresolvable private address for active scanning
    
    When running active scanning during LE discovery, do not reveal the own
    identity to the peer devices. In case LE privacy has been enabled, then
    a resolvable private address is used. If the LE privacy option is off,
    then use an unresolvable private address.
    
    The public address or static random address is never used in active
    scanning anymore. This ensures that scan request are send using a
    random address.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a1efa1c62de8..3d6b1cf07d23 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -563,7 +563,10 @@ static int hci_create_le_conn(struct hci_conn *conn)
 
 	memset(&cp, 0, sizeof(cp));
 
-	err = hci_update_random_address(&req, &own_addr_type);
+	/* Update random address, but set require_privacy to false so
+	 * that we never connect with an unresolvable address.
+	 */
+	err = hci_update_random_address(&req, false, &own_addr_type);
 	if (err < 0)
 		return err;
 

commit e26b1ffa11bb1e0afa194823623ee64b7e143993
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Feb 23 19:42:28 2014 +0200

    Bluetooth: Fix setting correct src_type when connecting LE
    
    This patch ensures that conn->src_type contains the same address type as
    is used for initiating the connection while the connection attempt is in
    progress. Once connected this value will be overwritten with the
    identity address type.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 4cb337d6401f..a1efa1c62de8 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -567,6 +567,8 @@ static int hci_create_le_conn(struct hci_conn *conn)
 	if (err < 0)
 		return err;
 
+	conn->src_type = own_addr_type;
+
 	cp.scan_interval = cpu_to_le16(hdev->le_scan_interval);
 	cp.scan_window = cpu_to_le16(hdev->le_scan_window);
 	bacpy(&cp.peer_addr, &conn->dst);
@@ -653,7 +655,6 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		return ERR_PTR(-ENOMEM);
 
 	conn->dst_type = dst_type;
-	conn->src_type = hdev->own_addr_type;
 
 	conn->state = BT_CONNECT;
 	conn->out = true;

commit 85030be4c5ce39e709b2cb5d4f8ee8779af8e50b
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Feb 23 19:42:22 2014 +0200

    Bluetooth: Use hci_update_random_address() when connecting LE
    
    When we initiate LE connections we need to update the local random
    address if necessary. This patch updates the LE connection creation
    mechanism to use the new hci_update_random_address() function to set the
    own_address_type parameter and to update the local random address if
    necessary.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index bd66c52eff95..4cb337d6401f 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -556,16 +556,22 @@ static int hci_create_le_conn(struct hci_conn *conn)
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_le_create_conn cp;
 	struct hci_request req;
+	u8 own_addr_type;
 	int err;
 
 	hci_req_init(&req, hdev);
 
 	memset(&cp, 0, sizeof(cp));
+
+	err = hci_update_random_address(&req, &own_addr_type);
+	if (err < 0)
+		return err;
+
 	cp.scan_interval = cpu_to_le16(hdev->le_scan_interval);
 	cp.scan_window = cpu_to_le16(hdev->le_scan_window);
 	bacpy(&cp.peer_addr, &conn->dst);
 	cp.peer_addr_type = conn->dst_type;
-	cp.own_address_type = conn->src_type;
+	cp.own_address_type = own_addr_type;
 	cp.conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
 	cp.conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
 	cp.supervision_timeout = __constant_cpu_to_le16(0x002a);

commit d66c295031aec712e179d21de66602d631390f34
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 18 22:27:14 2014 -0800

    Bluetooth: Use same LE min/max connection event length during update
    
    During LE connection establishment the value 0x0000 is used for min/max
    connection event length. So use the same value when the peripheral is
    requesting an update of the the connection paramters.
    
    For some reason the value 0x0001 got used in the connection update and
    0x0000 in the connection creation. Using the same value for both just
    makes sense.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a027951d0da5..bd66c52eff95 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -225,8 +225,8 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 	cp.conn_interval_max	= cpu_to_le16(max);
 	cp.conn_latency		= cpu_to_le16(latency);
 	cp.supervision_timeout	= cpu_to_le16(to_multiplier);
-	cp.min_ce_len		= __constant_cpu_to_le16(0x0001);
-	cp.max_ce_len		= __constant_cpu_to_le16(0x0001);
+	cp.min_ce_len		= __constant_cpu_to_le16(0x0000);
+	cp.max_ce_len		= __constant_cpu_to_le16(0x0000);
 
 	hci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);
 }

commit edb4b46651c87f1579154298c41f9c1a753565a3
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Feb 18 15:13:43 2014 -0800

    Bluetooth: Fix wrong identity address during connection failures
    
    When the connection attempt fails, the address information are not
    provided in the HCI_LE_Connection_Complete event. So use the original
    information from the connection to reconstruct the identity address.
    
    This is important when a connection attempt has been made using the
    identity address, but the cached resolvable random address has changed
    in the meantime. The failure event needs to use the identity address
    and not the resolvable random address.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 40ec37355d6f..a027951d0da5 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -623,6 +623,19 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	else
 		dst_type = ADDR_LE_DEV_RANDOM;
 
+	/* When given an identity address with existing identity
+	 * resolving key, the connection needs to be established
+	 * to a resolvable random address.
+	 *
+	 * This uses the cached random resolvable address from
+	 * a previous scan. When no cached address is available,
+	 * try connecting to the identity address instead.
+	 *
+	 * Storing the resolvable random address is required here
+	 * to handle connection failures. The address will later
+	 * be resolved back into the original identity address
+	 * from the connect request.
+	 */
 	irk = hci_find_irk_by_addr(hdev, dst, dst_type);
 	if (irk && bacmp(&irk->rpa, BDADDR_ANY)) {
 		dst = &irk->rpa;

commit 1ebfcc1f5884509925522ab76c17db9befe0aac9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Tue Feb 18 21:41:36 2014 +0200

    Bluetooth: Look up RPA for connection requests with Identity Address
    
    We need to check whether there's a matching IRK and RPA when we're
    requested to connect to a remote LE device based on its Identity
    Address. This patch updates the hci_connect_le function to do an extra
    call to hci_find_irk_by_addr and uses the RPA if it's cached. This is
    particularly important once we start exposing the Identity Address to
    user space instead of the RPA in events such as Device Connected and
    Device Found.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 67972928a623..40ec37355d6f 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -588,6 +588,7 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 {
 	struct hci_conn_params *params;
 	struct hci_conn *conn;
+	struct smp_irk *irk;
 	int err;
 
 	if (test_bit(HCI_ADVERTISING, &hdev->flags))
@@ -616,15 +617,23 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	if (conn)
 		return ERR_PTR(-EBUSY);
 
+	/* Convert from L2CAP channel address type to HCI address type */
+	if (dst_type == BDADDR_LE_PUBLIC)
+		dst_type = ADDR_LE_DEV_PUBLIC;
+	else
+		dst_type = ADDR_LE_DEV_RANDOM;
+
+	irk = hci_find_irk_by_addr(hdev, dst, dst_type);
+	if (irk && bacmp(&irk->rpa, BDADDR_ANY)) {
+		dst = &irk->rpa;
+		dst_type = ADDR_LE_DEV_RANDOM;
+	}
+
 	conn = hci_conn_add(hdev, LE_LINK, dst);
 	if (!conn)
 		return ERR_PTR(-ENOMEM);
 
-	if (dst_type == BDADDR_LE_PUBLIC)
-		conn->dst_type = ADDR_LE_DEV_PUBLIC;
-	else
-		conn->dst_type = ADDR_LE_DEV_RANDOM;
-
+	conn->dst_type = dst_type;
 	conn->src_type = hdev->own_addr_type;
 
 	conn->state = BT_CONNECT;

commit 4292f1f3370193fd3f2e4f849211fd9596ce832f
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Mon Feb 3 13:56:19 2014 -0300

    Bluetooth: Use connection parameters if any
    
    This patch changes hci_connect_le() so it uses the connection
    parameters specified for the certain device. If no parameters
    were configured, we use the default values.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 801820f12226..67972928a623 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -586,6 +586,7 @@ static int hci_create_le_conn(struct hci_conn *conn)
 static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				    u8 dst_type, u8 sec_level, u8 auth_type)
 {
+	struct hci_conn_params *params;
 	struct hci_conn *conn;
 	int err;
 
@@ -632,8 +633,15 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	conn->sec_level = BT_SECURITY_LOW;
 	conn->pending_sec_level = sec_level;
 	conn->auth_type = auth_type;
-	conn->le_conn_min_interval = hdev->le_conn_min_interval;
-	conn->le_conn_max_interval = hdev->le_conn_max_interval;
+
+	params = hci_conn_params_lookup(hdev, &conn->dst, conn->dst_type);
+	if (params) {
+		conn->le_conn_min_interval = params->conn_min_interval;
+		conn->le_conn_max_interval = params->conn_max_interval;
+	} else {
+		conn->le_conn_min_interval = hdev->le_conn_min_interval;
+		conn->le_conn_max_interval = hdev->le_conn_max_interval;
+	}
 
 	err = hci_create_le_conn(conn);
 	if (err)

commit 9cb2e030e6a0787f5c216702e6e78dd85ffe04c4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Feb 1 11:32:25 2014 -0800

    Bluetooth: Include security level 4 in connections check
    
    This check is only used for RFCOMM connections and most likely no
    RFCOMM based profile will require security level 4 secure connection
    security policy. In case it ever does make sure that seucrity level 4
    is treated as sufficient security level.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7ef5bffb61aa..801820f12226 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -860,13 +860,17 @@ int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)
 {
 	BT_DBG("hcon %p", conn);
 
-	if (sec_level != BT_SECURITY_HIGH)
-		return 1; /* Accept if non-secure is required */
+	/* Accept if non-secure or higher security level is required */
+	if (sec_level != BT_SECURITY_HIGH && sec_level != BT_SECURITY_FIPS)
+		return 1;
 
-	if (conn->sec_level == BT_SECURITY_HIGH)
+	/* Accept if secure or higher security level is already present */
+	if (conn->sec_level == BT_SECURITY_HIGH ||
+	    conn->sec_level == BT_SECURITY_FIPS)
 		return 1;
 
-	return 0; /* Reject not secure link */
+	/* Reject not secure link */
+	return 0;
 }
 EXPORT_SYMBOL(hci_conn_check_secure);
 

commit 9bb3c01fdb2201d405dfff8950145640b2355ec4
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu Jan 30 18:22:08 2014 -0300

    Bluetooth: Introduce le_conn_failed() helper
    
    This patch moves connection attempt failure code to its own function
    so it can be reused in the next patch.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7f148c975736..7ef5bffb61aa 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -514,6 +514,21 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 }
 EXPORT_SYMBOL(hci_get_route);
 
+/* This function requires the caller holds hdev->lock */
+static void le_conn_failed(struct hci_conn *conn, u8 status)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	conn->state = BT_CLOSED;
+
+	mgmt_connect_failed(hdev, &conn->dst, conn->type, conn->dst_type,
+			    status);
+
+	hci_proto_connect_cfm(conn, status);
+
+	hci_conn_del(conn);
+}
+
 static void create_le_conn_complete(struct hci_dev *hdev, u8 status)
 {
 	struct hci_conn *conn;
@@ -530,14 +545,7 @@ static void create_le_conn_complete(struct hci_dev *hdev, u8 status)
 	if (!conn)
 		goto done;
 
-	conn->state = BT_CLOSED;
-
-	mgmt_connect_failed(hdev, &conn->dst, conn->type, conn->dst_type,
-			    status);
-
-	hci_proto_connect_cfm(conn, status);
-
-	hci_conn_del(conn);
+	le_conn_failed(conn, status);
 
 done:
 	hci_dev_unlock(hdev);

commit 1e406eefbe41467c00973939c2b61b37bf0e1323
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu Jan 30 18:22:04 2014 -0300

    Bluetooth: Save connection interval parameters in hci_conn
    
    This patch creates two new fields in struct hci_conn to save the
    minimum and maximum connection interval values used to establish
    the connection this object represents.
    
    This change is required in order to know what parameters the
    connection is currently using.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 0266bd8e4913..7f148c975736 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -558,8 +558,8 @@ static int hci_create_le_conn(struct hci_conn *conn)
 	bacpy(&cp.peer_addr, &conn->dst);
 	cp.peer_addr_type = conn->dst_type;
 	cp.own_address_type = conn->src_type;
-	cp.conn_interval_min = cpu_to_le16(hdev->le_conn_min_interval);
-	cp.conn_interval_max = cpu_to_le16(hdev->le_conn_max_interval);
+	cp.conn_interval_min = cpu_to_le16(conn->le_conn_min_interval);
+	cp.conn_interval_max = cpu_to_le16(conn->le_conn_max_interval);
 	cp.supervision_timeout = __constant_cpu_to_le16(0x002a);
 	cp.min_ce_len = __constant_cpu_to_le16(0x0000);
 	cp.max_ce_len = __constant_cpu_to_le16(0x0000);
@@ -624,6 +624,8 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	conn->sec_level = BT_SECURITY_LOW;
 	conn->pending_sec_level = sec_level;
 	conn->auth_type = auth_type;
+	conn->le_conn_min_interval = hdev->le_conn_min_interval;
+	conn->le_conn_max_interval = hdev->le_conn_max_interval;
 
 	err = hci_create_le_conn(conn);
 	if (err)

commit 7b5a9241b780ea2f77e71647bc0d3c9708c18ef1
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jan 15 22:37:39 2014 -0800

    Bluetooth: Introduce requirements for security level 4
    
    The security level 4 is a new strong security requirement that is based
    around 128-bit equivalent strength for link and encryption keys required
    using FIPS approved algorithms. Which means that E0, SAFER+ and P-192
    are not allowed. Only connections created with P-256 resulting from
    using Secure Connections support are allowed.
    
    This security level needs to be enforced when Secure Connection Only
    mode is enabled for a controller or a service requires FIPS compliant
    strong security. Currently it is not possible to enable either of
    these two cases. This patch just puts in the foundation for being
    able to handle security level 4 in the future.
    
    It should be noted that devices or services with security level 4
    requirement can only communicate using Bluetooth 4.1 controllers
    with support for Secure Connections. There is no backward compatibilty
    if used with older hardware.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index cf96b3438a91..0266bd8e4913 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -800,10 +800,17 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 	if (!(conn->link_mode & HCI_LM_AUTH))
 		goto auth;
 
-	/* An authenticated combination key has sufficient security for any
-	   security level. */
-	if (conn->key_type == HCI_LK_AUTH_COMBINATION_P192 ||
-	    conn->key_type == HCI_LK_AUTH_COMBINATION_P256)
+	/* An authenticated FIPS approved combination key has sufficient
+	 * security for security level 4. */
+	if (conn->key_type == HCI_LK_AUTH_COMBINATION_P256 &&
+	    sec_level == BT_SECURITY_FIPS)
+		goto encrypt;
+
+	/* An authenticated combination key has sufficient security for
+	   security level 3. */
+	if ((conn->key_type == HCI_LK_AUTH_COMBINATION_P192 ||
+	     conn->key_type == HCI_LK_AUTH_COMBINATION_P256) &&
+	    sec_level == BT_SECURITY_HIGH)
 		goto encrypt;
 
 	/* An unauthenticated combination key has sufficient security for
@@ -818,7 +825,8 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 	   is generated using maximum PIN code length (16).
 	   For pre 2.1 units. */
 	if (conn->key_type == HCI_LK_COMBINATION &&
-	    (sec_level != BT_SECURITY_HIGH || conn->pin_length == 16))
+	    (sec_level == BT_SECURITY_MEDIUM || sec_level == BT_SECURITY_LOW ||
+	     conn->pin_length == 16))
 		goto encrypt;
 
 auth:

commit 66138ce8e556a8ddd13baf035fb3a8d0d6dd4bb5
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 10 02:07:20 2014 -0800

    Bluetooth: Add support for handling P-256 derived link keys
    
    Before being able to enable Secure Connections support, the core needs
    to know on how to handle P-256 derived link keys. The difference between
    authenticated and unauthenticated P-256 derived link keys is the same as
    its P-192 counter parts.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 251f22e32fbf..cf96b3438a91 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -802,12 +802,14 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 
 	/* An authenticated combination key has sufficient security for any
 	   security level. */
-	if (conn->key_type == HCI_LK_AUTH_COMBINATION_P192)
+	if (conn->key_type == HCI_LK_AUTH_COMBINATION_P192 ||
+	    conn->key_type == HCI_LK_AUTH_COMBINATION_P256)
 		goto encrypt;
 
 	/* An unauthenticated combination key has sufficient security for
 	   security level 1 and 2. */
-	if (conn->key_type == HCI_LK_UNAUTH_COMBINATION_P192 &&
+	if ((conn->key_type == HCI_LK_UNAUTH_COMBINATION_P192 ||
+	     conn->key_type == HCI_LK_UNAUTH_COMBINATION_P256) &&
 	    (sec_level == BT_SECURITY_MEDIUM || sec_level == BT_SECURITY_LOW))
 		goto encrypt;
 

commit 11015c7903c74350402f8753339c48bee0186e90
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Jan 10 02:07:19 2014 -0800

    Bluetooth: Add definitions for new link key types
    
    With the introduction of Secure Connections, the list of link key types
    got extended by P-256 versions of authenticated and unauthenticated
    link keys.
    
    To avoid any confusion the previous authenticated and unauthenticated
    link key types got ammended with a P912 postfix. And the two new keys
    have a P256 postfix now. Existing code using the previous definitions
    has been adjusted.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ba5366c320da..251f22e32fbf 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -802,12 +802,12 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 
 	/* An authenticated combination key has sufficient security for any
 	   security level. */
-	if (conn->key_type == HCI_LK_AUTH_COMBINATION)
+	if (conn->key_type == HCI_LK_AUTH_COMBINATION_P192)
 		goto encrypt;
 
 	/* An unauthenticated combination key has sufficient security for
 	   security level 1 and 2. */
-	if (conn->key_type == HCI_LK_UNAUTH_COMBINATION &&
+	if (conn->key_type == HCI_LK_UNAUTH_COMBINATION_P192 &&
 	    (sec_level == BT_SECURITY_MEDIUM || sec_level == BT_SECURITY_LOW))
 		goto encrypt;
 

commit 4e70c7e71c5f9cf11013628ab5a0ced449b1c7b2
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 19 07:09:13 2013 -0700

    Bluetooth: Expose debugfs settings for LE connection interval
    
    For testing purposes expose the default LE connection interval values
    via debugfs.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 974d7bccbb6f..ba5366c320da 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -558,11 +558,12 @@ static int hci_create_le_conn(struct hci_conn *conn)
 	bacpy(&cp.peer_addr, &conn->dst);
 	cp.peer_addr_type = conn->dst_type;
 	cp.own_address_type = conn->src_type;
-	cp.conn_interval_min = __constant_cpu_to_le16(0x0028);
-	cp.conn_interval_max = __constant_cpu_to_le16(0x0038);
+	cp.conn_interval_min = cpu_to_le16(hdev->le_conn_min_interval);
+	cp.conn_interval_max = cpu_to_le16(hdev->le_conn_max_interval);
 	cp.supervision_timeout = __constant_cpu_to_le16(0x002a);
 	cp.min_ce_len = __constant_cpu_to_le16(0x0000);
 	cp.max_ce_len = __constant_cpu_to_le16(0x0000);
+
 	hci_req_add(&req, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
 
 	err = hci_req_run(&req, create_le_conn_complete);

commit 79830f66e3cbd224bcf697b032dce9828b5a3c9e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 18 16:38:09 2013 -0700

    Bluetooth: Select the own address type during initial setup phase
    
    The own address type is based on the fact if the controller has
    a public address or not. This means that this detail can be just
    configured once during setup phase.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 4e726505f52b..974d7bccbb6f 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -615,12 +615,7 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	else
 		conn->dst_type = ADDR_LE_DEV_RANDOM;
 
-	if (bacmp(&conn->src, BDADDR_ANY)) {
-		conn->src_type = ADDR_LE_DEV_PUBLIC;
-	} else {
-		bacpy(&conn->src, &hdev->static_addr);
-		conn->src_type = ADDR_LE_DEV_RANDOM;
-	}
+	conn->src_type = hdev->own_addr_type;
 
 	conn->state = BT_CONNECT;
 	conn->out = true;

commit a74a84f696537f38fa994c1b95a0dca9ae386865
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 16 18:11:40 2013 +0300

    Bluetooth: Convert idle timer to use delayed work
    
    There is no need to use a timer since the entire Bluetooth subsystem
    runs using workqueues these days.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 8d1f466520a5..4e726505f52b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -317,8 +317,10 @@ static void hci_conn_timeout(struct work_struct *work)
 }
 
 /* Enter sniff mode */
-static void hci_conn_enter_sniff_mode(struct hci_conn *conn)
+static void hci_conn_idle(struct work_struct *work)
 {
+	struct hci_conn *conn = container_of(work, struct hci_conn,
+					     idle_work.work);
 	struct hci_dev *hdev = conn->hdev;
 
 	BT_DBG("hcon %p mode %d", conn, conn->mode);
@@ -352,15 +354,6 @@ static void hci_conn_enter_sniff_mode(struct hci_conn *conn)
 	}
 }
 
-static void hci_conn_idle(unsigned long arg)
-{
-	struct hci_conn *conn = (void *) arg;
-
-	BT_DBG("hcon %p mode %d", conn, conn->mode);
-
-	hci_conn_enter_sniff_mode(conn);
-}
-
 static void hci_conn_auto_accept(struct work_struct *work)
 {
 	struct hci_conn *conn = container_of(work, struct hci_conn,
@@ -416,7 +409,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	INIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);
 	INIT_DELAYED_WORK(&conn->auto_accept_work, hci_conn_auto_accept);
-	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);
+	INIT_DELAYED_WORK(&conn->idle_work, hci_conn_idle);
 
 	atomic_set(&conn->refcnt, 0);
 
@@ -437,10 +430,9 @@ int hci_conn_del(struct hci_conn *conn)
 
 	BT_DBG("%s hcon %p handle %d", hdev->name, conn, conn->handle);
 
-	del_timer(&conn->idle_timer);
-
 	cancel_delayed_work_sync(&conn->disc_work);
 	cancel_delayed_work_sync(&conn->auto_accept_work);
+	cancel_delayed_work_sync(&conn->idle_work);
 
 	if (conn->type == ACL_LINK) {
 		struct hci_conn *sco = conn->link;
@@ -920,8 +912,8 @@ void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 
 timer:
 	if (hdev->idle_timeout > 0)
-		mod_timer(&conn->idle_timer,
-			  jiffies + msecs_to_jiffies(hdev->idle_timeout));
+		queue_delayed_work(hdev->workqueue, &conn->idle_work,
+				   msecs_to_jiffies(hdev->idle_timeout));
 }
 
 /* Drop all connection on the device */

commit 7bc18d9d3d7ffbc09dabb201933a063583a39027
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 16 18:11:39 2013 +0300

    Bluetooth: Convert auto accept timer to use delayed work
    
    Since the entire Bluetooth subsystem runs in workqueues these days there
    is no need to use a timer for deferring work.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ff04b051792d..8d1f466520a5 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -361,12 +361,12 @@ static void hci_conn_idle(unsigned long arg)
 	hci_conn_enter_sniff_mode(conn);
 }
 
-static void hci_conn_auto_accept(unsigned long arg)
+static void hci_conn_auto_accept(struct work_struct *work)
 {
-	struct hci_conn *conn = (void *) arg;
-	struct hci_dev *hdev = conn->hdev;
+	struct hci_conn *conn = container_of(work, struct hci_conn,
+					     auto_accept_work.work);
 
-	hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),
+	hci_send_cmd(conn->hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),
 		     &conn->dst);
 }
 
@@ -415,9 +415,8 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	INIT_LIST_HEAD(&conn->chan_list);
 
 	INIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);
+	INIT_DELAYED_WORK(&conn->auto_accept_work, hci_conn_auto_accept);
 	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);
-	setup_timer(&conn->auto_accept_timer, hci_conn_auto_accept,
-		    (unsigned long) conn);
 
 	atomic_set(&conn->refcnt, 0);
 
@@ -441,8 +440,7 @@ int hci_conn_del(struct hci_conn *conn)
 	del_timer(&conn->idle_timer);
 
 	cancel_delayed_work_sync(&conn->disc_work);
-
-	del_timer(&conn->auto_accept_timer);
+	cancel_delayed_work_sync(&conn->auto_accept_work);
 
 	if (conn->type == ACL_LINK) {
 		struct hci_conn *sco = conn->link;

commit 662e8820f38dcc458e0d4769194db5ed3469224f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 13 05:23:59 2013 -0700

    Bluetooth: Store source address of HCI connections
    
    The source addressed was based on the public address of the HCI device,
    but with LE connections this not always the case. For example single
    mode LE-only controllers would use a static random address. And this
    address is configured by userspace.
    
    To not complicate the lookup of what kind of address is in use, store
    the correct source address for each HCI connection.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index d9f7f93b813e..ff04b051792d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -381,6 +381,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 		return NULL;
 
 	bacpy(&conn->dst, dst);
+	bacpy(&conn->src, &hdev->bdaddr);
 	conn->hdev  = hdev;
 	conn->type  = type;
 	conn->mode  = HCI_CM_ACTIVE;
@@ -624,10 +625,12 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	else
 		conn->dst_type = ADDR_LE_DEV_RANDOM;
 
-	if (bacmp(&hdev->bdaddr, BDADDR_ANY))
+	if (bacmp(&conn->src, BDADDR_ANY)) {
 		conn->src_type = ADDR_LE_DEV_PUBLIC;
-	else
+	} else {
+		bacpy(&conn->src, &hdev->static_addr);
 		conn->src_type = ADDR_LE_DEV_RANDOM;
+	}
 
 	conn->state = BT_CONNECT;
 	conn->out = true;

commit e7c4096e16f0e362c6cf902baab0de37ebfc1266
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 13 03:57:39 2013 -0700

    Bluetooth: Store the source address type of LE connections
    
    When establishing LE connections, it is possible to use a public
    address (if available) or a random address. The type of address
    is only known when creating connections, so make sure it is
    stored in hci_conn structure.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index bb32f48b88f9..d9f7f93b813e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -566,10 +566,7 @@ static int hci_create_le_conn(struct hci_conn *conn)
 	cp.scan_window = cpu_to_le16(hdev->le_scan_window);
 	bacpy(&cp.peer_addr, &conn->dst);
 	cp.peer_addr_type = conn->dst_type;
-	if (bacmp(&hdev->bdaddr, BDADDR_ANY))
-		cp.own_address_type = ADDR_LE_DEV_PUBLIC;
-	else
-		cp.own_address_type = ADDR_LE_DEV_RANDOM;
+	cp.own_address_type = conn->src_type;
 	cp.conn_interval_min = __constant_cpu_to_le16(0x0028);
 	cp.conn_interval_max = __constant_cpu_to_le16(0x0038);
 	cp.supervision_timeout = __constant_cpu_to_le16(0x002a);
@@ -626,6 +623,12 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		conn->dst_type = ADDR_LE_DEV_PUBLIC;
 	else
 		conn->dst_type = ADDR_LE_DEV_RANDOM;
+
+	if (bacmp(&hdev->bdaddr, BDADDR_ANY))
+		conn->src_type = ADDR_LE_DEV_PUBLIC;
+	else
+		conn->src_type = ADDR_LE_DEV_RANDOM;
+
 	conn->state = BT_CONNECT;
 	conn->out = true;
 	conn->link_mode |= HCI_LM_MASTER;

commit 79d95a19a445f5758571b3342064f2c1e40b6c5f
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 13 03:57:38 2013 -0700

    Bluetooth: Remove pointless bdaddr_to_le() helper function
    
    The bdaddr_to_le() function tries to convert the internal address
    type to one that matches the HCI address type for LE. It does not
    handle any address types not used by LE and in the end just make
    the code a lot harder to read.
    
    So instead of just hiding behind a magic function, just convert
    the internal address type where it needs to be converted. And it
    turns out that these are only two cases anyway. One when creating
    new LE connections and the other when loading the long term keys.
    In both cases this makes it more clear on what it going on.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index c52bfb7e44fd..bb32f48b88f9 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -622,7 +622,10 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	if (!conn)
 		return ERR_PTR(-ENOMEM);
 
-	conn->dst_type = bdaddr_to_le(dst_type);
+	if (dst_type == BDADDR_LE_PUBLIC)
+		conn->dst_type = ADDR_LE_DEV_PUBLIC;
+	else
+		conn->dst_type = ADDR_LE_DEV_RANDOM;
 	conn->state = BT_CONNECT;
 	conn->out = true;
 	conn->link_mode |= HCI_LM_MASTER;

commit bef64738e3fb87eabc6fbeededad0c44ea173384
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Oct 11 08:23:19 2013 -0700

    Bluetooth: Make LE scan interval and window a controller option
    
    The scan interval and window for LE passive scanning and connection
    establishment should be configurable on a per controller basis. So
    introduce a setting that later on will allow modifying it.
    
    This setting does not affect LE active scanning during device
    discovery phase. As long as that phase uses interleaved discovery,
    it will continuously scan.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 139587159200..c52bfb7e44fd 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -562,8 +562,8 @@ static int hci_create_le_conn(struct hci_conn *conn)
 	hci_req_init(&req, hdev);
 
 	memset(&cp, 0, sizeof(cp));
-	cp.scan_interval = __constant_cpu_to_le16(0x0060);
-	cp.scan_window = __constant_cpu_to_le16(0x0030);
+	cp.scan_interval = cpu_to_le16(hdev->le_scan_interval);
+	cp.scan_window = cpu_to_le16(hdev->le_scan_window);
 	bacpy(&cp.peer_addr, &conn->dst);
 	cp.peer_addr_type = conn->dst_type;
 	if (bacmp(&hdev->bdaddr, BDADDR_ANY))

commit ac4b7236610cef99821f40f44a74030b85d85270
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 10 14:54:16 2013 -0700

    Bluetooth: Move smp.h header file into net/bluetooth/
    
    The smp.h header file is only used internally by the bluetooth.ko
    module and is not a public API. So make it local to the core
    Bluetooth module.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 8141c8d83139..139587159200 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -28,8 +28,8 @@
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/smp.h>
 
+#include "smp.h"
 #include "a2mp.h"
 
 struct sco_param {

commit 7024728ee534d739380dc4fd31f020cfc6e86c28
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Oct 10 14:54:15 2013 -0700

    Bluetooth: Move a2mp.h header file into net/bluetooth/
    
    The a2mp.h header file is only used internally by the bluetooth.ko
    module and is not a public API. So make it local to the core
    Bluetooth module.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index dedd1ea5dd4c..8141c8d83139 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -28,9 +28,10 @@
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
-#include <net/bluetooth/a2mp.h>
 #include <net/bluetooth/smp.h>
 
+#include "a2mp.h"
+
 struct sco_param {
 	u16 pkt_type;
 	u16 max_latency;

commit 620ad5219c0f0aa43731b2fd8fd9efac78c10deb
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Oct 8 08:21:18 2013 -0300

    Bluetooth: Refactor hci_connect_le
    
    This patch does some code refactoring in hci_connect_le() by moving
    the exception code into if statements and letting the main flow in
    first level of function scope. It also adds extra comments to improve
    the code readability.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 1800b50558e4..dedd1ea5dd4c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -594,32 +594,47 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	if (test_bit(HCI_ADVERTISING, &hdev->flags))
 		return ERR_PTR(-ENOTSUPP);
 
+	/* Some devices send ATT messages as soon as the physical link is
+	 * established. To be able to handle these ATT messages, the user-
+	 * space first establishes the connection and then starts the pairing
+	 * process.
+	 *
+	 * So if a hci_conn object already exists for the following connection
+	 * attempt, we simply update pending_sec_level and auth_type fields
+	 * and return the object found.
+	 */
 	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
-	if (!conn) {
-		conn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
-		if (conn)
-			return ERR_PTR(-EBUSY);
-
-		conn = hci_conn_add(hdev, LE_LINK, dst);
-		if (!conn)
-			return ERR_PTR(-ENOMEM);
+	if (conn) {
+		conn->pending_sec_level = sec_level;
+		conn->auth_type = auth_type;
+		goto done;
+	}
 
-		conn->dst_type = bdaddr_to_le(dst_type);
-		conn->state = BT_CONNECT;
-		conn->out = true;
-		conn->link_mode |= HCI_LM_MASTER;
-		conn->sec_level = BT_SECURITY_LOW;
+	/* Since the controller supports only one LE connection attempt at a
+	 * time, we return -EBUSY if there is any connection attempt running.
+	 */
+	conn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
+	if (conn)
+		return ERR_PTR(-EBUSY);
 
-		err = hci_create_le_conn(conn);
-		if (err)
-			return ERR_PTR(err);
-	}
+	conn = hci_conn_add(hdev, LE_LINK, dst);
+	if (!conn)
+		return ERR_PTR(-ENOMEM);
 
+	conn->dst_type = bdaddr_to_le(dst_type);
+	conn->state = BT_CONNECT;
+	conn->out = true;
+	conn->link_mode |= HCI_LM_MASTER;
+	conn->sec_level = BT_SECURITY_LOW;
 	conn->pending_sec_level = sec_level;
 	conn->auth_type = auth_type;
 
-	hci_conn_hold(conn);
+	err = hci_create_le_conn(conn);
+	if (err)
+		return ERR_PTR(err);
 
+done:
+	hci_conn_hold(conn);
 	return conn;
 }
 

commit 1d399ae5c74619c841fa13834c4f79506aaf6957
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Oct 8 08:21:17 2013 -0300

    Bluetooth: Use HCI request for LE connection
    
    This patch introduces a new helper, which uses the HCI request
    framework, for creating LE connectons. All the handling is now
    done by this function so we can remove the hci_cs_le_create_conn()
    event handler.
    
    This patch also removes the old hci_le_create_connection() since
    it is not used anymore.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 2a220a8c9869..1800b50558e4 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -49,29 +49,6 @@ static const struct sco_param sco_param_wideband[] = {
 	{ EDR_ESCO_MASK | ESCO_EV3,   0x0008 }, /* T1 */
 };
 
-static void hci_le_create_connection(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_le_create_conn cp;
-
-	memset(&cp, 0, sizeof(cp));
-	cp.scan_interval = __constant_cpu_to_le16(0x0060);
-	cp.scan_window = __constant_cpu_to_le16(0x0030);
-	bacpy(&cp.peer_addr, &conn->dst);
-	cp.peer_addr_type = conn->dst_type;
-	if (bacmp(&hdev->bdaddr, BDADDR_ANY))
-		cp.own_address_type = ADDR_LE_DEV_PUBLIC;
-	else
-		cp.own_address_type = ADDR_LE_DEV_RANDOM;
-	cp.conn_interval_min = __constant_cpu_to_le16(0x0028);
-	cp.conn_interval_max = __constant_cpu_to_le16(0x0038);
-	cp.supervision_timeout = __constant_cpu_to_le16(0x002a);
-	cp.min_ce_len = __constant_cpu_to_le16(0x0000);
-	cp.max_ce_len = __constant_cpu_to_le16(0x0000);
-
-	hci_send_cmd(hdev, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
-}
-
 static void hci_le_create_connection_cancel(struct hci_conn *conn)
 {
 	hci_send_cmd(conn->hdev, HCI_OP_LE_CREATE_CONN_CANCEL, 0, NULL);
@@ -545,10 +522,74 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 }
 EXPORT_SYMBOL(hci_get_route);
 
+static void create_le_conn_complete(struct hci_dev *hdev, u8 status)
+{
+	struct hci_conn *conn;
+
+	if (status == 0)
+		return;
+
+	BT_ERR("HCI request failed to create LE connection: status 0x%2.2x",
+	       status);
+
+	hci_dev_lock(hdev);
+
+	conn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
+	if (!conn)
+		goto done;
+
+	conn->state = BT_CLOSED;
+
+	mgmt_connect_failed(hdev, &conn->dst, conn->type, conn->dst_type,
+			    status);
+
+	hci_proto_connect_cfm(conn, status);
+
+	hci_conn_del(conn);
+
+done:
+	hci_dev_unlock(hdev);
+}
+
+static int hci_create_le_conn(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_cp_le_create_conn cp;
+	struct hci_request req;
+	int err;
+
+	hci_req_init(&req, hdev);
+
+	memset(&cp, 0, sizeof(cp));
+	cp.scan_interval = __constant_cpu_to_le16(0x0060);
+	cp.scan_window = __constant_cpu_to_le16(0x0030);
+	bacpy(&cp.peer_addr, &conn->dst);
+	cp.peer_addr_type = conn->dst_type;
+	if (bacmp(&hdev->bdaddr, BDADDR_ANY))
+		cp.own_address_type = ADDR_LE_DEV_PUBLIC;
+	else
+		cp.own_address_type = ADDR_LE_DEV_RANDOM;
+	cp.conn_interval_min = __constant_cpu_to_le16(0x0028);
+	cp.conn_interval_max = __constant_cpu_to_le16(0x0038);
+	cp.supervision_timeout = __constant_cpu_to_le16(0x002a);
+	cp.min_ce_len = __constant_cpu_to_le16(0x0000);
+	cp.max_ce_len = __constant_cpu_to_le16(0x0000);
+	hci_req_add(&req, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
+
+	err = hci_req_run(&req, create_le_conn_complete);
+	if (err) {
+		hci_conn_del(conn);
+		return err;
+	}
+
+	return 0;
+}
+
 static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				    u8 dst_type, u8 sec_level, u8 auth_type)
 {
 	struct hci_conn *conn;
+	int err;
 
 	if (test_bit(HCI_ADVERTISING, &hdev->flags))
 		return ERR_PTR(-ENOTSUPP);
@@ -569,7 +610,9 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 		conn->link_mode |= HCI_LM_MASTER;
 		conn->sec_level = BT_SECURITY_LOW;
 
-		hci_le_create_connection(conn);
+		err = hci_create_le_conn(conn);
+		if (err)
+			return ERR_PTR(err);
 	}
 
 	conn->pending_sec_level = sec_level;

commit c25dfc610b983f74f05b3c12d9ad4ff4af6cd858
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 6 02:08:36 2013 -0700

    Bluetooth: Use random address if public address is not available
    
    For single mode LE-only controllers, it is possible that they come
    without a public address. If a public address is not available,
    then use the random address for connection establishment and
    scanning.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 8b0d08fb6158..2a220a8c9869 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -59,6 +59,10 @@ static void hci_le_create_connection(struct hci_conn *conn)
 	cp.scan_window = __constant_cpu_to_le16(0x0030);
 	bacpy(&cp.peer_addr, &conn->dst);
 	cp.peer_addr_type = conn->dst_type;
+	if (bacmp(&hdev->bdaddr, BDADDR_ANY))
+		cp.own_address_type = ADDR_LE_DEV_PUBLIC;
+	else
+		cp.own_address_type = ADDR_LE_DEV_RANDOM;
 	cp.conn_interval_min = __constant_cpu_to_le16(0x0028);
 	cp.conn_interval_max = __constant_cpu_to_le16(0x0038);
 	cp.supervision_timeout = __constant_cpu_to_le16(0x002a);

commit f3d3444a4d7f76e79841c59c78105a45295cc4b0
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sat Oct 5 12:01:04 2013 +0200

    Bluetooth: Rename HCI_LE_PERIPHERAL to HCI_ADVERTISING
    
    This flag is used to indicate whether we want to have advertising
    enabled or not, so give it a more suitable name.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 08e601c68314..8b0d08fb6158 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -546,7 +546,7 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 {
 	struct hci_conn *conn;
 
-	if (test_bit(HCI_LE_PERIPHERAL, &hdev->flags))
+	if (test_bit(HCI_ADVERTISING, &hdev->flags))
 		return ERR_PTR(-ENOTSUPP);
 
 	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);

commit 46a190cbd3d8992a017664367e9227dcd357ce53
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu Oct 3 18:25:45 2013 -0300

    Bluetooth: Initialize hci_conn fields in hci_connect_le
    
    This patch moves some hci_conn fields initialization from hci_le_
    create_connection() to hci_connect_le(). It makes more sense to
    initialize these fields within the function that creates the hci_
    conn object.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5aba520cddfe..08e601c68314 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -54,11 +54,6 @@ static void hci_le_create_connection(struct hci_conn *conn)
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_le_create_conn cp;
 
-	conn->state = BT_CONNECT;
-	conn->out = true;
-	conn->link_mode |= HCI_LM_MASTER;
-	conn->sec_level = BT_SECURITY_LOW;
-
 	memset(&cp, 0, sizeof(cp));
 	cp.scan_interval = __constant_cpu_to_le16(0x0060);
 	cp.scan_window = __constant_cpu_to_le16(0x0030);
@@ -565,6 +560,11 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 			return ERR_PTR(-ENOMEM);
 
 		conn->dst_type = bdaddr_to_le(dst_type);
+		conn->state = BT_CONNECT;
+		conn->out = true;
+		conn->link_mode |= HCI_LM_MASTER;
+		conn->sec_level = BT_SECURITY_LOW;
+
 		hci_le_create_connection(conn);
 	}
 

commit f1e5d54743b99cbbea0e0cfb2b3f8053f045b3d7
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Thu Oct 3 18:25:44 2013 -0300

    Bluetooth: Rename hci_conn variable in hci_connect_le()
    
    This patch simply rename the hci_conn variable "le" to "conn"
    since it is a better name.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 514148b7a66b..5aba520cddfe 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -549,31 +549,31 @@ EXPORT_SYMBOL(hci_get_route);
 static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 				    u8 dst_type, u8 sec_level, u8 auth_type)
 {
-	struct hci_conn *le;
+	struct hci_conn *conn;
 
 	if (test_bit(HCI_LE_PERIPHERAL, &hdev->flags))
 		return ERR_PTR(-ENOTSUPP);
 
-	le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
-	if (!le) {
-		le = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
-		if (le)
+	conn = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
+	if (!conn) {
+		conn = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
+		if (conn)
 			return ERR_PTR(-EBUSY);
 
-		le = hci_conn_add(hdev, LE_LINK, dst);
-		if (!le)
+		conn = hci_conn_add(hdev, LE_LINK, dst);
+		if (!conn)
 			return ERR_PTR(-ENOMEM);
 
-		le->dst_type = bdaddr_to_le(dst_type);
-		hci_le_create_connection(le);
+		conn->dst_type = bdaddr_to_le(dst_type);
+		hci_le_create_connection(conn);
 	}
 
-	le->pending_sec_level = sec_level;
-	le->auth_type = auth_type;
+	conn->pending_sec_level = sec_level;
+	conn->auth_type = auth_type;
 
-	hci_conn_hold(le);
+	hci_conn_hold(conn);
 
-	return le;
+	return conn;
 }
 
 static struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,

commit 56f8790102f48a4959a729ecdccff332591014e1
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 2 13:43:13 2013 +0300

    Bluetooth: Introduce a new HCI_BREDR_ENABLED flag
    
    To allow treating dual-mode (BR/EDR/LE) controllers as single-mode ones
    (LE-only) we want to introduce a new HCI_BREDR_ENABLED flag to track
    whether BR/EDR is enabled or not (previously we simply looked at the
    feature bit with lmp_bredr_enabled).
    
    This patch add the new flag and updates the relevant places to test
    against it instead of using lmp_bredr_enabled. The flag is by default
    enabled when registering an adapter and only cleared if necessary once
    the local features have been read during the HCI init procedure.
    
    We cannot completely block BR/EDR usage in case user space uses raw HCI
    sockets but the patch tries to block this in places where possible, such
    as the various BR/EDR specific ioctls.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index d2380e0c7df0..514148b7a66b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -581,6 +581,9 @@ static struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 {
 	struct hci_conn *acl;
 
+	if (!test_bit(HCI_BREDR_ENABLED, &hdev->dev_flags))
+		return ERR_PTR(-ENOTSUPP);
+
 	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (!acl) {
 		acl = hci_conn_add(hdev, ACL_LINK, dst);

commit af750e942ea138553ee5693210c2f918448f58dc
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 3 18:08:37 2013 -0700

    Bluetooth: Disable upper layer connections when user channel is active
    
    When the device has the user channel flag set, it means it is driven by
    an user application. In that case do not allow any connections from
    L2CAP or SCO sockets.
    
    This is the same situation as when the device has the raw flag set and
    it will then return EHOSTUNREACH.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index f0817121ec5e..d2380e0c7df0 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -518,6 +518,7 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 	list_for_each_entry(d, &hci_dev_list, list) {
 		if (!test_bit(HCI_UP, &d->flags) ||
 		    test_bit(HCI_RAW, &d->flags) ||
+		    test_bit(HCI_USER_CHANNEL, &d->dev_flags) ||
 		    d->dev_type != HCI_BREDR)
 			continue;
 

commit 2dea632f9acad076370fe871d4ccc93868621403
Author: FrÃ©dÃ©ric Dalleau <frederic.dalleau@linux.intel.com>
Date:   Mon Aug 19 14:24:03 2013 +0200

    Bluetooth: Add SCO connection fallback
    
    When initiating a transparent eSCO connection, make use of T2 settings
    at first try. T2 is the recommended settings from HFP 1.6 WideBand
    Speech. Upon connection failure, try T1 settings.
    
    When CVSD is requested and eSCO is supported, try to establish eSCO
    connection using S3 settings. If it fails, fallback in sequence to S2,
    S1, D1, D0 settings.
    
    To know which setting should be used, conn->attempt is used. It
    indicates the currently ongoing SCO connection attempt and can be used
    as the index for the fallback settings table.
    
    These setting and the fallback order are described in Bluetooth HFP 1.6
    specification p. 101.
    
    Signed-off-by: FrÃ©dÃ©ric Dalleau <frederic.dalleau@linux.intel.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index c0e56a512ff3..f0817121ec5e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -31,6 +31,24 @@
 #include <net/bluetooth/a2mp.h>
 #include <net/bluetooth/smp.h>
 
+struct sco_param {
+	u16 pkt_type;
+	u16 max_latency;
+};
+
+static const struct sco_param sco_param_cvsd[] = {
+	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000a }, /* S3 */
+	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x0007 }, /* S2 */
+	{ EDR_ESCO_MASK | ESCO_EV3,   0x0007 }, /* S1 */
+	{ EDR_ESCO_MASK | ESCO_HV3,   0xffff }, /* D1 */
+	{ EDR_ESCO_MASK | ESCO_HV1,   0xffff }, /* D0 */
+};
+
+static const struct sco_param sco_param_wideband[] = {
+	{ EDR_ESCO_MASK & ~ESCO_2EV3, 0x000d }, /* T2 */
+	{ EDR_ESCO_MASK | ESCO_EV3,   0x0008 }, /* T1 */
+};
+
 static void hci_le_create_connection(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
@@ -172,10 +190,11 @@ static void hci_add_sco(struct hci_conn *conn, __u16 handle)
 	hci_send_cmd(hdev, HCI_OP_ADD_SCO, sizeof(cp), &cp);
 }
 
-void hci_setup_sync(struct hci_conn *conn, __u16 handle)
+bool hci_setup_sync(struct hci_conn *conn, __u16 handle)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_setup_sync_conn cp;
+	const struct sco_param *param;
 
 	BT_DBG("hcon %p", conn);
 
@@ -192,19 +211,28 @@ void hci_setup_sync(struct hci_conn *conn, __u16 handle)
 
 	switch (conn->setting & SCO_AIRMODE_MASK) {
 	case SCO_AIRMODE_TRANSP:
-		cp.pkt_type = __constant_cpu_to_le16(EDR_ESCO_MASK &
-						     ~ESCO_2EV3);
-		cp.max_latency = __constant_cpu_to_le16(0x000d);
+		if (conn->attempt > ARRAY_SIZE(sco_param_wideband))
+			return false;
 		cp.retrans_effort = 0x02;
+		param = &sco_param_wideband[conn->attempt - 1];
 		break;
 	case SCO_AIRMODE_CVSD:
-		cp.pkt_type = cpu_to_le16(conn->pkt_type);
-		cp.max_latency = __constant_cpu_to_le16(0xffff);
-		cp.retrans_effort = 0xff;
+		if (conn->attempt > ARRAY_SIZE(sco_param_cvsd))
+			return false;
+		cp.retrans_effort = 0x01;
+		param = &sco_param_cvsd[conn->attempt - 1];
 		break;
+	default:
+		return false;
 	}
 
-	hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp);
+	cp.pkt_type = __cpu_to_le16(param->pkt_type);
+	cp.max_latency = __cpu_to_le16(param->max_latency);
+
+	if (hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp) < 0)
+		return false;
+
+	return true;
 }
 
 void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,

commit 10c62ddc6f032c3a096401ca3ce7e5b2d5780859
Author: FrÃ©dÃ©ric Dalleau <frederic.dalleau@linux.intel.com>
Date:   Mon Aug 19 14:23:59 2013 +0200

    Bluetooth: Parameters for outgoing SCO connections
    
    In order to establish a transparent SCO connection, the correct settings
    must be specified in the Setup Synchronous Connection request. For that,
    a setting field is added to ACL connection data to set up the desired
    parameters. The patch also removes usage of hdev->voice_setting in CVSD
    connection and makes use of T2 parameters for transparent data.
    
    Signed-off-by: FrÃ©dÃ©ric Dalleau <frederic.dalleau@linux.intel.com>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5f1f448dd0f2..c0e56a512ff3 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -185,13 +185,24 @@ void hci_setup_sync(struct hci_conn *conn, __u16 handle)
 	conn->attempt++;
 
 	cp.handle   = cpu_to_le16(handle);
-	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 
 	cp.tx_bandwidth   = __constant_cpu_to_le32(0x00001f40);
 	cp.rx_bandwidth   = __constant_cpu_to_le32(0x00001f40);
-	cp.max_latency    = __constant_cpu_to_le16(0xffff);
-	cp.voice_setting  = cpu_to_le16(hdev->voice_setting);
-	cp.retrans_effort = 0xff;
+	cp.voice_setting  = cpu_to_le16(conn->setting);
+
+	switch (conn->setting & SCO_AIRMODE_MASK) {
+	case SCO_AIRMODE_TRANSP:
+		cp.pkt_type = __constant_cpu_to_le16(EDR_ESCO_MASK &
+						     ~ESCO_2EV3);
+		cp.max_latency = __constant_cpu_to_le16(0x000d);
+		cp.retrans_effort = 0x02;
+		break;
+	case SCO_AIRMODE_CVSD:
+		cp.pkt_type = cpu_to_le16(conn->pkt_type);
+		cp.max_latency = __constant_cpu_to_le16(0xffff);
+		cp.retrans_effort = 0xff;
+		break;
+	}
 
 	hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp);
 }
@@ -560,7 +571,8 @@ static struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 	return acl;
 }
 
-struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst)
+struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst,
+				 __u16 setting)
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
@@ -583,6 +595,8 @@ struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	hci_conn_hold(sco);
 
+	sco->setting = setting;
+
 	if (acl->state == BT_CONNECTED &&
 	    (sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
 		set_bit(HCI_CONN_POWER_SAVE, &acl->flags);

commit e660ed6c70370dae0887e2b5224d8b6c1e138120
Author: FrÃ©dÃ©ric Dalleau <frederic.dalleau@linux.intel.com>
Date:   Mon Aug 19 14:23:54 2013 +0200

    Bluetooth: Use hci_connect_sco directly
    
    hci_connect is a super function for connecting hci protocols. But the
    voice_setting parameter (introduced in subsequent patches) is only
    needed by SCO and security requirements are not needed for SCO channels.
    Thus, it makes sense to have a separate function for SCO.
    
    Signed-off-by: FrÃ©dÃ©ric Dalleau <frederic.dalleau@linux.intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6c7f36379722..5f1f448dd0f2 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -560,13 +560,12 @@ static struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 	return acl;
 }
 
-static struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type,
-				bdaddr_t *dst, u8 sec_level, u8 auth_type)
+struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type, bdaddr_t *dst)
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
 
-	acl = hci_connect_acl(hdev, dst, sec_level, auth_type);
+	acl = hci_connect_acl(hdev, dst, BT_SECURITY_LOW, HCI_AT_NO_BONDING);
 	if (IS_ERR(acl))
 		return acl;
 
@@ -612,9 +611,6 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 		return hci_connect_le(hdev, dst, dst_type, sec_level, auth_type);
 	case ACL_LINK:
 		return hci_connect_acl(hdev, dst, sec_level, auth_type);
-	case SCO_LINK:
-	case ESCO_LINK:
-		return hci_connect_sco(hdev, type, dst, sec_level, auth_type);
 	}
 
 	return ERR_PTR(-EINVAL);

commit 8d12356f33f819ec0d064e233f7ca8e59eaa38ef
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Sat Apr 6 20:28:39 2013 +0200

    Bluetooth: introduce hci_conn ref-counting
    
    We currently do not allow using hci_conn from outside of HCI-core.
    However, several other users could make great use of it. This includes
    HIDP, rfcomm and all other sub-protocols that rely on an active
    connection.
    
    Hence, we now introduce hci_conn ref-counting. We currently never call
    get_device(). put_device() is exclusively used in hci_conn_del_sysfs().
    Hence, we currently never have a greater device-refcnt than 1.
    Therefore, it is safe to move the put_device() call from
    hci_conn_del_sysfs() to hci_conn_del() (it's the only caller). In fact,
    this even fixes a "use-after-free" bug as we access hci_conn after calling
    hci_conn_del_sysfs() in hci_conn_del().
    
    From now on we can add references to hci_conn objects in other layers
    (like l2cap_sock, HIDP, rfcomm, ...) and grab a reference via
    hci_conn_get(). This does _not_ guarantee, that the connection is still
    alive. But, this isn't what we want. We can simply lock the hci_conn
    device and use "device_is_registered(hci_conn->dev)" to test that.
    However, this is hardly necessary as outside users should never rely on
    the HCI connection to be alive, anyway. Instead, they should solely rely
    on the device-object to be available.
    But if sub-devices want the hci_conn object as sysfs parent, they need to
    be notified when the connection drops. This will be introduced in later
    patches with l2cap_users.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6b5b8e77cf0b..6c7f36379722 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -462,8 +462,7 @@ int hci_conn_del(struct hci_conn *conn)
 
 	hci_dev_put(hdev);
 
-	if (conn->handle == 0)
-		kfree(conn);
+	hci_conn_put(conn);
 
 	return 0;
 }

commit fc225c3f5d1b6aa6f99c5c300af4605e4923ce79
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Sat Apr 6 20:28:38 2013 +0200

    Bluetooth: remove unneeded hci_conn_hold/put_device()
    
    hci_conn_hold/put_device() is used to control when hci_conn->dev is no
    longer needed and can be deleted from the system. Lets first look how they
    are currently used throughout the code (excluding HIDP!).
    
    All code that uses hci_conn_hold_device() looks like this:
        ...
        hci_conn_hold_device();
        hci_conn_add_sysfs();
        ...
    On the other side, hci_conn_put_device() is exclusively used in
    hci_conn_del().
    
    So, considering that hci_conn_del() must not be called twice (which would
    fail horribly), we know that hci_conn_put_device() is only called _once_
    (which is in hci_conn_del()).
    On the other hand, hci_conn_add_sysfs() must not be called twice, either
    (it would call device_add twice, which breaks the device, see
    drivers/base/core.c). So we know that hci_conn_hold_device() is also
    called only once (it's only called directly before hci_conn_add_sysfs()).
    
    So hold and put are known to be called only once. That means we can safely
    remove them and directly call hci_conn_del_sysfs() in hci_conn_del().
    
    But there is one issue left: HIDP also uses hci_conn_hold/put_device().
    However, this case can be ignored and simply removed as it is totally
    broken. The issue is, the only thing HIDP delays with
    hci_conn_hold_device() is the removal of the hci_conn->dev from sysfs.
    But, the hci_conn device has no mechanism to get notified when its own
    parent (hci_dev) gets removed from sysfs. hci_dev_hold/put() does _not_
    control when it is removed but only when the device object is created
    and destroyed.
    And hci_dev calls hci_conn_flush_*() when it removes itself from sysfs,
    which itself causes hci_conn_del() to be called, but it does _not_ cause
    hci_conn_del_sysfs() to be called, which is wrong.
    
    Hence, we fix it to call hci_conn_del_sysfs() in hci_conn_del(). This
    guarantees that a hci_conn object is removed from sysfs _before_ its
    parent hci_dev is removed.
    
    The changes to HIDP look scary, wrong and broken. However, if you look at
    the HIDP session management, you will notice they're already broken in the
    exact _same_ way (ever tried "unplugging" HIDP devices? Breaks _all_ the
    time).
    So this patch only makes HIDP look _scary_ and _obviously broken_. It does
    not break HIDP itself, it already is!
    
    See later patches in this series which fix HIDP to use proper
    session-management.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b1a02ce39a20..6b5b8e77cf0b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -410,8 +410,6 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
 
-	atomic_set(&conn->devref, 0);
-
 	hci_conn_init_sysfs(conn);
 
 	return conn;
@@ -460,7 +458,7 @@ int hci_conn_del(struct hci_conn *conn)
 
 	skb_queue_purge(&conn->data_q);
 
-	hci_conn_put_device(conn);
+	hci_conn_del_sysfs(conn);
 
 	hci_dev_put(hdev);
 
@@ -847,19 +845,6 @@ void hci_conn_check_pending(struct hci_dev *hdev)
 	hci_dev_unlock(hdev);
 }
 
-void hci_conn_hold_device(struct hci_conn *conn)
-{
-	atomic_inc(&conn->devref);
-}
-EXPORT_SYMBOL(hci_conn_hold_device);
-
-void hci_conn_put_device(struct hci_conn *conn)
-{
-	if (atomic_dec_and_test(&conn->devref))
-		hci_conn_del_sysfs(conn);
-}
-EXPORT_SYMBOL(hci_conn_put_device);
-
 int hci_get_conn_list(void __user *arg)
 {
 	struct hci_conn *c;

commit 93796fa6f21411dab2ce7ba4fd7fd4d4ed4aca2e
Author: Claudio Takahasi <claudio.takahasi@openbossa.org>
Date:   Thu Apr 11 13:54:56 2013 -0300

    Bluetooth: Reject SCO when hci connection timeouts
    
    This patch sends Reject Synchronous Connection Request Command when
    hci_conn_timeout is triggered, and the SCO connection is in BT_CONNECT2
    state. It prevents inconsistency if the remote host doesn't implement
    properly the timeout for the connection request, and it removes the
    connection reference left when the socket is closed for incoming SCO
    connections.
    
    [ 2650.129080] sco_sock_release: sock ffff8801ca417400, sk ffff88020c408800
    [ 2650.129092] sco_sock_clear_timer: sock ffff88020c408800 state 6
    [ 2650.129101] __sco_sock_close: sk ffff88020c408800 state 6 socket
            ffff8801ca417400
    [ 2650.129108] sco_chan_del: sk ffff88020c408800, conn ffff8801c650ea20,
            err 104
    [ 2650.129114] hci_conn_put: hcon ffff88020c40a800 orig refcnt 1
    [ 2650.129128] sco_sock_kill: sk ffff88020c408800 state 9
    [ 2650.129135] sco_sock_destruct: sk ffff88020c408800
    [ 2650.138468] hci_conn_timeout: hcon ffff88020c40a800 state BT_CONNECT2
    
    Signed-off-by: Claudio Takahasi <claudio.takahasi@openbossa.org>
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 30d7dfc23002..b1a02ce39a20 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -117,6 +117,16 @@ static void hci_acl_create_connection_cancel(struct hci_conn *conn)
 	hci_send_cmd(conn->hdev, HCI_OP_CREATE_CONN_CANCEL, sizeof(cp), &cp);
 }
 
+static void hci_reject_sco(struct hci_conn *conn)
+{
+	struct hci_cp_reject_sync_conn_req cp;
+
+	cp.reason = HCI_ERROR_REMOTE_USER_TERM;
+	bacpy(&cp.bdaddr, &conn->dst);
+
+	hci_send_cmd(conn->hdev, HCI_OP_REJECT_SYNC_CONN_REQ, sizeof(cp), &cp);
+}
+
 void hci_disconnect(struct hci_conn *conn, __u8 reason)
 {
 	struct hci_cp_disconnect cp;
@@ -276,6 +286,8 @@ static void hci_conn_timeout(struct work_struct *work)
 				hci_acl_create_connection_cancel(conn);
 			else if (conn->type == LE_LINK)
 				hci_le_create_connection_cancel(conn);
+		} else if (conn->type == SCO_LINK || conn->type == ESCO_LINK) {
+			hci_reject_sco(conn);
 		}
 		break;
 	case BT_CONFIG:

commit 76a68ba0ae097be72dfa8f918b3139130da769a4
Author: David Herrmann <dh.herrmann@gmail.com>
Date:   Sat Apr 6 20:28:37 2013 +0200

    Bluetooth: rename hci_conn_put to hci_conn_drop
    
    We use _get() and _put() for device ref-counting in the kernel. However,
    hci_conn_put() is _not_ used for ref-counting, hence, rename it to
    hci_conn_drop() so we can later fix ref-counting and introduce
    hci_conn_put().
    
    hci_conn_hold() and hci_conn_put() are currently used to manage how long a
    connection should be held alive. When the last user drops the connection,
    we spawn a delayed work that performs the disconnect. Obviously, this has
    nothing to do with ref-counting for the _object_ but rather for the
    keep-alive of the connection.
    
    But we really _need_ proper ref-counting for the _object_ to allow
    connection-users like rfcomm-tty, HIDP or others.
    
    Signed-off-by: David Herrmann <dh.herrmann@gmail.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b9f90169940b..30d7dfc23002 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -433,7 +433,7 @@ int hci_conn_del(struct hci_conn *conn)
 		struct hci_conn *acl = conn->link;
 		if (acl) {
 			acl->link = NULL;
-			hci_conn_put(acl);
+			hci_conn_drop(acl);
 		}
 	}
 
@@ -565,7 +565,7 @@ static struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type,
 	if (!sco) {
 		sco = hci_conn_add(hdev, type, dst);
 		if (!sco) {
-			hci_conn_put(acl);
+			hci_conn_drop(acl);
 			return ERR_PTR(-ENOMEM);
 		}
 	}
@@ -980,7 +980,7 @@ void hci_chan_del(struct hci_chan *chan)
 
 	synchronize_rcu();
 
-	hci_conn_put(conn);
+	hci_conn_drop(conn);
 
 	skb_queue_purge(&chan->data_q);
 	kfree(chan);

commit bed71748346ae0807c7f7a2913965508dbd61403
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Jan 30 11:50:56 2013 -0300

    Bluetooth: Rename hci_acl_disconn
    
    As hci_acl_disconn function basically sends the HCI Disconnect Command
    and it is used to disconnect ACL, SCO and LE links, renaming it to
    hci_disconnect is more suitable.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 4925a02ae7e4..b9f90169940b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -117,7 +117,7 @@ static void hci_acl_create_connection_cancel(struct hci_conn *conn)
 	hci_send_cmd(conn->hdev, HCI_OP_CREATE_CONN_CANCEL, sizeof(cp), &cp);
 }
 
-void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
+void hci_disconnect(struct hci_conn *conn, __u8 reason)
 {
 	struct hci_cp_disconnect cp;
 
@@ -253,7 +253,7 @@ static void hci_conn_disconnect(struct hci_conn *conn)
 		hci_amp_disconn(conn, reason);
 		break;
 	default:
-		hci_acl_disconn(conn, reason);
+		hci_disconnect(conn, reason);
 		break;
 	}
 }

commit 4c02e2d444595200d0b18b889994aac3611cd288
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Wed Jan 30 11:50:55 2013 -0300

    Bluetooth: Fix hci_conn timeout routine
    
    If occurs a LE or SCO hci_conn timeout and the connection is already
    established (BT_CONNECTED state), the connection is not terminated as
    expected. This bug can be reproduced using l2test or scotest tool.
    Once the connection is established, kill l2test/scotest and the
    connection won't be terminated.
    
    This patch fixes hci_conn_disconnect helper so it is able to
    terminate LE and SCO connections, as well as ACL.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 25bfce0666eb..4925a02ae7e4 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -249,12 +249,12 @@ static void hci_conn_disconnect(struct hci_conn *conn)
 	__u8 reason = hci_proto_disconn_ind(conn);
 
 	switch (conn->type) {
-	case ACL_LINK:
-		hci_acl_disconn(conn, reason);
-		break;
 	case AMP_LINK:
 		hci_amp_disconn(conn, reason);
 		break;
+	default:
+		hci_acl_disconn(conn, reason);
+		break;
 	}
 }
 

commit e9b02748ffc043e8a36f7893bbf58bb886f0b7e4
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Oct 25 15:20:51 2012 +0300

    Bluetooth: Add put(hcon) when deleting hchan
    
    When refcnt reaches zero disconnect timeout will run and hci_conn
    will be disconnected.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index dc331ceca471..25bfce0666eb 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -980,6 +980,8 @@ void hci_chan_del(struct hci_chan *chan)
 
 	synchronize_rcu();
 
+	hci_conn_put(conn);
+
 	skb_queue_purge(&chan->data_q);
 	kfree(chan);
 }

commit f15504788d7b1613ef2ef0a673cfe250c16a6b0d
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Oct 24 21:12:03 2012 +0300

    Bluetooth: Disallow LE scanning and connecting in peripheral role
    
    When an adapter is in the LE peripheral role scanning for other devices
    or initiating connections to them is not allowed. This patch makes sure
    that such attempts will result in appropriate error returns.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6dcf4523df3c..dc331ceca471 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -502,6 +502,9 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 {
 	struct hci_conn *le;
 
+	if (test_bit(HCI_LE_PERIPHERAL, &hdev->flags))
+		return ERR_PTR(-ENOTSUPP);
+
 	le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
 	if (!le) {
 		le = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);

commit 168df8e57e7c1afce3f86a86ae106f82ff7c18d8
Author: Mat Martineau <mathewm@codeaurora.org>
Date:   Tue Oct 23 15:24:13 2012 -0700

    Bluetooth: Add state to hci_chan
    
    On an AMP controller, hci_chan maps to a logical link.  When a channel
    is being moved, the logical link may or may not be connected already.
    The hci_chan->state is used to determine the existance of a useable
    logical link so the link can be either used or requested.
    
    Signed-off-by: Mat Martineau <mathewm@codeaurora.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Acked-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index fe646211c61f..6dcf4523df3c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -959,6 +959,7 @@ struct hci_chan *hci_chan_create(struct hci_conn *conn)
 
 	chan->conn = conn;
 	skb_queue_head_init(&chan->data_q);
+	chan->state = BT_CONNECTED;
 
 	list_add_rcu(&chan->list, &conn->chan_list);
 

commit 42c4e53e7ac3d4069105e852d1ee24e6ee9e57b8
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Wed Oct 10 17:38:28 2012 +0300

    Bluetooth: AMP: Add handle to hci_chan structure
    
    hci_chan will be identified by handle used in logical link creation
    process. This handle is used in AMP ACL-U packet handle field.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 64875794dd9b..fe646211c61f 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -989,3 +989,35 @@ void hci_chan_list_flush(struct hci_conn *conn)
 	list_for_each_entry_safe(chan, n, &conn->chan_list, list)
 		hci_chan_del(chan);
 }
+
+static struct hci_chan *__hci_chan_lookup_handle(struct hci_conn *hcon,
+						 __u16 handle)
+{
+	struct hci_chan *hchan;
+
+	list_for_each_entry(hchan, &hcon->chan_list, list) {
+		if (hchan->handle == handle)
+			return hchan;
+	}
+
+	return NULL;
+}
+
+struct hci_chan *hci_chan_lookup_handle(struct hci_dev *hdev, __u16 handle)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct hci_conn *hcon;
+	struct hci_chan *hchan = NULL;
+
+	rcu_read_lock();
+
+	list_for_each_entry_rcu(hcon, &h->list, list) {
+		hchan = __hci_chan_lookup_handle(hcon, handle);
+		if (hchan)
+			break;
+	}
+
+	rcu_read_unlock();
+
+	return hchan;
+}

commit 53502d69be49e3dd5bc95ab0f2deeaea260bd617
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Wed Oct 10 17:38:27 2012 +0300

    Bluetooth: AMP: Handle AMP_LINK timeout
    
    When AMP_LINK timeouts execute HCI_OP_DISCONN_PHY_LINK as analog to
    HCI_OP_DISCONNECT for ACL_LINK.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 53202f6733ae..64875794dd9b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -130,6 +130,20 @@ void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
 	hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
 }
 
+static void hci_amp_disconn(struct hci_conn *conn, __u8 reason)
+{
+	struct hci_cp_disconn_phy_link cp;
+
+	BT_DBG("hcon %p", conn);
+
+	conn->state = BT_DISCONN;
+
+	cp.phy_handle = HCI_PHY_HANDLE(conn->handle);
+	cp.reason = reason;
+	hci_send_cmd(conn->hdev, HCI_OP_DISCONN_PHY_LINK,
+		     sizeof(cp), &cp);
+}
+
 static void hci_add_sco(struct hci_conn *conn, __u16 handle)
 {
 	struct hci_dev *hdev = conn->hdev;
@@ -230,11 +244,24 @@ void hci_sco_setup(struct hci_conn *conn, __u8 status)
 	}
 }
 
+static void hci_conn_disconnect(struct hci_conn *conn)
+{
+	__u8 reason = hci_proto_disconn_ind(conn);
+
+	switch (conn->type) {
+	case ACL_LINK:
+		hci_acl_disconn(conn, reason);
+		break;
+	case AMP_LINK:
+		hci_amp_disconn(conn, reason);
+		break;
+	}
+}
+
 static void hci_conn_timeout(struct work_struct *work)
 {
 	struct hci_conn *conn = container_of(work, struct hci_conn,
 					     disc_work.work);
-	__u8 reason;
 
 	BT_DBG("hcon %p state %s", conn, state_to_string(conn->state));
 
@@ -253,8 +280,7 @@ static void hci_conn_timeout(struct work_struct *work)
 		break;
 	case BT_CONFIG:
 	case BT_CONNECTED:
-		reason = hci_proto_disconn_ind(conn);
-		hci_acl_disconn(conn, reason);
+		hci_conn_disconnect(conn);
 		break;
 	default:
 		conn->state = BT_CLOSED;

commit 6ed93dc6427d14cdfe0b272cc0a9ee4685ce9ad7
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Tue Sep 25 12:49:43 2012 +0300

    Bluetooth: Use %pMR in debug instead of batostr
    
    Instead of old unsafe batostr function use %pMR print specifier
    for printing Bluetooth addresses in debug and error statements.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b9196a44f759..53202f6733ae 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -320,7 +320,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 {
 	struct hci_conn *conn;
 
-	BT_DBG("%s dst %s", hdev->name, batostr(dst));
+	BT_DBG("%s dst %pMR", hdev->name, dst);
 
 	conn = kzalloc(sizeof(struct hci_conn), GFP_KERNEL);
 	if (!conn)
@@ -437,7 +437,7 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 	int use_src = bacmp(src, BDADDR_ANY);
 	struct hci_dev *hdev = NULL, *d;
 
-	BT_DBG("%s -> %s", batostr(src), batostr(dst));
+	BT_DBG("%pMR -> %pMR", src, dst);
 
 	read_lock(&hci_dev_list_lock);
 
@@ -567,7 +567,7 @@ static struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type,
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 			     __u8 dst_type, __u8 sec_level, __u8 auth_type)
 {
-	BT_DBG("%s dst %s type 0x%x", hdev->name, batostr(dst), type);
+	BT_DBG("%s dst %pMR type 0x%x", hdev->name, dst, type);
 
 	switch (type) {
 	case LE_LINK:

commit 791ef39cd18ae2745a63c51a5dbbd23312be0744
Merge: e5a876250d05 0c1abbd1aa04
Author: John W. Linville <linville@tuxdriver.com>
Date:   Mon Sep 24 14:39:16 2012 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth-next

commit 9472007c62ecc8f21daa2e1e252bf73b67e535fc
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Sep 6 15:05:43 2012 +0300

    Bluetooth: trivial: Make hci_chan_del return void
    
    Return code is not needed in hci_chan_del
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3e65c021df50..59f0344406c8 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -935,7 +935,7 @@ struct hci_chan *hci_chan_create(struct hci_conn *conn)
 	return chan;
 }
 
-int hci_chan_del(struct hci_chan *chan)
+void hci_chan_del(struct hci_chan *chan)
 {
 	struct hci_conn *conn = chan->conn;
 	struct hci_dev *hdev = conn->hdev;
@@ -948,8 +948,6 @@ int hci_chan_del(struct hci_chan *chan)
 
 	skb_queue_purge(&chan->data_q);
 	kfree(chan);
-
-	return 0;
 }
 
 void hci_chan_list_flush(struct hci_conn *conn)

commit d8343f125710fb596f7a88cd756679f14f4e77b9
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Aug 23 21:32:44 2012 -0300

    Bluetooth: Fix sending a HCI Authorization Request over LE links
    
    In the case that the link is already in the connected state and a
    Pairing request arrives from the mgmt interface, hci_conn_security()
    would be called but it was not considering LE links.
    
    Reported-by: JoÃ£o Paulo Rechi Vita <jprvita@openbossa.org>
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5ad7da217474..3c094e78dde9 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -29,6 +29,7 @@
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/a2mp.h>
+#include <net/bluetooth/smp.h>
 
 static void hci_le_connect(struct hci_conn *conn)
 {
@@ -619,6 +620,9 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
 	BT_DBG("hcon %p", conn);
 
+	if (conn->type == LE_LINK)
+		return smp_conn_security(conn, sec_level);
+
 	/* For sdp we don't need the link key. */
 	if (sec_level == BT_SECURITY_SDP)
 		return 1;

commit f91c8468df97d0ac18132eb38283524a74317901
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Aug 17 21:37:59 2012 -0300

    Bluetooth: Fix establishing ESCO links
    
    Commit 4cd2d98340b4f03d5532c30fdaeb451b035429cb "Bluetooth: Simplify
    the connection type handling" broke the creation of ESCO links.
    
    This patch adds a type parameter to hci_connect_sco() so it creates
    the connection of the right kind.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 98670b1df17b..3e65c021df50 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -521,8 +521,8 @@ static struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 	return acl;
 }
 
-static struct hci_conn *hci_connect_sco(struct hci_dev *hdev, bdaddr_t *dst,
-				     u8 sec_level, u8 auth_type)
+static struct hci_conn *hci_connect_sco(struct hci_dev *hdev, int type,
+				bdaddr_t *dst, u8 sec_level, u8 auth_type)
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
@@ -531,9 +531,9 @@ static struct hci_conn *hci_connect_sco(struct hci_dev *hdev, bdaddr_t *dst,
 	if (IS_ERR(acl))
 		return acl;
 
-	sco = hci_conn_hash_lookup_ba(hdev, SCO_LINK, dst);
+	sco = hci_conn_hash_lookup_ba(hdev, type, dst);
 	if (!sco) {
-		sco = hci_conn_add(hdev, SCO_LINK, dst);
+		sco = hci_conn_add(hdev, type, dst);
 		if (!sco) {
 			hci_conn_put(acl);
 			return ERR_PTR(-ENOMEM);
@@ -574,7 +574,8 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 	case ACL_LINK:
 		return hci_connect_acl(hdev, dst, sec_level, auth_type);
 	case SCO_LINK:
-		return hci_connect_sco(hdev, dst, sec_level, auth_type);
+	case ESCO_LINK:
+		return hci_connect_sco(hdev, type, dst, sec_level, auth_type);
 	}
 
 	return ERR_PTR(-EINVAL);

commit e6dd548b9a3c7b3fcdd2fd97880abf7597e8334b
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Jul 27 19:33:00 2012 -0300

    Bluetooth: Add type information to the hci_connect() debug statement
    
    Now that we have a "connect" function for each link type, we should be
    able to indentify which function is going to be called.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 2e7b7765e0ea..98670b1df17b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -566,7 +566,7 @@ static struct hci_conn *hci_connect_sco(struct hci_dev *hdev, bdaddr_t *dst,
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 			     __u8 dst_type, __u8 sec_level, __u8 auth_type)
 {
-	BT_DBG("%s dst %s", hdev->name, batostr(dst));
+	BT_DBG("%s dst %s type 0x%x", hdev->name, batostr(dst), type);
 
 	switch (type) {
 	case LE_LINK:

commit 4cd2d98340b4f03d5532c30fdaeb451b035429cb
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Jul 27 19:32:59 2012 -0300

    Bluetooth: Simplify a the connection type handling
    
    Now that we have separate ways of doing connections for each link type,
    we can do better than an "if" statement to handle each link type.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index de7df88a396b..2e7b7765e0ea 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -568,13 +568,16 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 {
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
-	if (type == LE_LINK)
+	switch (type) {
+	case LE_LINK:
 		return hci_connect_le(hdev, dst, dst_type, sec_level, auth_type);
-
-	if (type == ACL_LINK)
+	case ACL_LINK:
 		return hci_connect_acl(hdev, dst, sec_level, auth_type);
+	case SCO_LINK:
+		return hci_connect_sco(hdev, dst, sec_level, auth_type);
+	}
 
-	return hci_connect_sco(hdev, dst, sec_level, auth_type);
+	return ERR_PTR(-EINVAL);
 }
 
 /* Check link security requirement */

commit b7d839bfff78a01705f3d7b0acd5257dc7b067c9
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Jul 27 19:32:58 2012 -0300

    Bluetooth: Refactor SCO connection into its own function
    
    We can do the same that we did for the other link types, for SCO
    connections. The only thing that's worth noting is that as SCO
    links need an ACL link, this functions uses the function that adds
    an ACL link.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 1d70e9fc7a4c..de7df88a396b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -521,29 +521,19 @@ static struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
 	return acl;
 }
 
-/* Create SCO, ACL or LE connection.
- * Device _must_ be locked */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
-			     __u8 dst_type, __u8 sec_level, __u8 auth_type)
+static struct hci_conn *hci_connect_sco(struct hci_dev *hdev, bdaddr_t *dst,
+				     u8 sec_level, u8 auth_type)
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
 
-	BT_DBG("%s dst %s", hdev->name, batostr(dst));
-
-	if (type == LE_LINK)
-		return hci_connect_le(hdev, dst, dst_type, sec_level, auth_type);
-
 	acl = hci_connect_acl(hdev, dst, sec_level, auth_type);
 	if (IS_ERR(acl))
 		return acl;
 
-	if (type == ACL_LINK)
-		return acl;
-
-	sco = hci_conn_hash_lookup_ba(hdev, type, dst);
+	sco = hci_conn_hash_lookup_ba(hdev, SCO_LINK, dst);
 	if (!sco) {
-		sco = hci_conn_add(hdev, type, dst);
+		sco = hci_conn_add(hdev, SCO_LINK, dst);
 		if (!sco) {
 			hci_conn_put(acl);
 			return ERR_PTR(-ENOMEM);
@@ -572,6 +562,21 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 	return sco;
 }
 
+/* Create SCO, ACL or LE connection. */
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
+			     __u8 dst_type, __u8 sec_level, __u8 auth_type)
+{
+	BT_DBG("%s dst %s", hdev->name, batostr(dst));
+
+	if (type == LE_LINK)
+		return hci_connect_le(hdev, dst, dst_type, sec_level, auth_type);
+
+	if (type == ACL_LINK)
+		return hci_connect_acl(hdev, dst, sec_level, auth_type);
+
+	return hci_connect_sco(hdev, dst, sec_level, auth_type);
+}
+
 /* Check link security requirement */
 int hci_conn_check_link_mode(struct hci_conn *conn)
 {

commit db4742756ae2a836618cd5acf599522573589149
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Sat Jul 28 22:35:59 2012 -0300

    Bluetooth: Refactor ACL connection into its own function
    
    The hci_connect() function was starting to get too complicated to be
    quickly understood. We can separate the creation of a new ACL
    connection into its own function.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 0a74399dde5e..1d70e9fc7a4c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -497,18 +497,10 @@ static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
 	return le;
 }
 
-/* Create SCO, ACL or LE connection.
- * Device _must_ be locked */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
-			     __u8 dst_type, __u8 sec_level, __u8 auth_type)
+static struct hci_conn *hci_connect_acl(struct hci_dev *hdev, bdaddr_t *dst,
+						u8 sec_level, u8 auth_type)
 {
 	struct hci_conn *acl;
-	struct hci_conn *sco;
-
-	BT_DBG("%s dst %s", hdev->name, batostr(dst));
-
-	if (type == LE_LINK)
-		return hci_connect_le(hdev, dst, dst_type, sec_level, auth_type);
 
 	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (!acl) {
@@ -526,6 +518,26 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 		hci_acl_create_connection(acl);
 	}
 
+	return acl;
+}
+
+/* Create SCO, ACL or LE connection.
+ * Device _must_ be locked */
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
+			     __u8 dst_type, __u8 sec_level, __u8 auth_type)
+{
+	struct hci_conn *acl;
+	struct hci_conn *sco;
+
+	BT_DBG("%s dst %s", hdev->name, batostr(dst));
+
+	if (type == LE_LINK)
+		return hci_connect_le(hdev, dst, dst_type, sec_level, auth_type);
+
+	acl = hci_connect_acl(hdev, dst, sec_level, auth_type);
+	if (IS_ERR(acl))
+		return acl;
+
 	if (type == ACL_LINK)
 		return acl;
 

commit d04aef4cccf203fdfd1716e9ba458060cbab0928
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Jul 27 19:32:56 2012 -0300

    Bluetooth: Refactor LE connection into its own function
    
    The code that handles LE connection is already quite separated from
    the rest of the connection procedure, so we can easily put it into
    its own.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index c30c507345f8..0a74399dde5e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -470,6 +470,33 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 }
 EXPORT_SYMBOL(hci_get_route);
 
+static struct hci_conn *hci_connect_le(struct hci_dev *hdev, bdaddr_t *dst,
+				    u8 dst_type, u8 sec_level, u8 auth_type)
+{
+	struct hci_conn *le;
+
+	le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
+	if (!le) {
+		le = hci_conn_hash_lookup_state(hdev, LE_LINK, BT_CONNECT);
+		if (le)
+			return ERR_PTR(-EBUSY);
+
+		le = hci_conn_add(hdev, LE_LINK, dst);
+		if (!le)
+			return ERR_PTR(-ENOMEM);
+
+		le->dst_type = bdaddr_to_le(dst_type);
+		hci_le_create_connection(le);
+	}
+
+	le->pending_sec_level = sec_level;
+	le->auth_type = auth_type;
+
+	hci_conn_hold(le);
+
+	return le;
+}
+
 /* Create SCO, ACL or LE connection.
  * Device _must_ be locked */
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
@@ -477,33 +504,11 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
-	struct hci_conn *le;
 
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
-	if (type == LE_LINK) {
-		le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
-		if (!le) {
-			le = hci_conn_hash_lookup_state(hdev, LE_LINK,
-							BT_CONNECT);
-			if (le)
-				return ERR_PTR(-EBUSY);
-
-			le = hci_conn_add(hdev, LE_LINK, dst);
-			if (!le)
-				return ERR_PTR(-ENOMEM);
-
-			le->dst_type = bdaddr_to_le(dst_type);
-			hci_le_create_connection(le);
-		}
-
-		le->pending_sec_level = sec_level;
-		le->auth_type = auth_type;
-
-		hci_conn_hold(le);
-
-		return le;
-	}
+	if (type == LE_LINK)
+		return hci_connect_le(hdev, dst, dst_type, sec_level, auth_type);
 
 	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (!acl) {

commit 1aef866968223ddfd7268457b642a9233f0b8006
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Jul 27 19:32:55 2012 -0300

    Bluetooth: Rename LE and ACL connection functions
    
    These names were causing much confusion, so we rename these functions
    that send HCI commands to be more similar in naming to the actual HCI
    commands that will be sent.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 724eea980812..c30c507345f8 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -30,7 +30,7 @@
 #include <net/bluetooth/hci_core.h>
 #include <net/bluetooth/a2mp.h>
 
-static void hci_le_connect(struct hci_conn *conn)
+static void hci_le_create_connection(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_le_create_conn cp;
@@ -54,12 +54,12 @@ static void hci_le_connect(struct hci_conn *conn)
 	hci_send_cmd(hdev, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
 }
 
-static void hci_le_connect_cancel(struct hci_conn *conn)
+static void hci_le_create_connection_cancel(struct hci_conn *conn)
 {
 	hci_send_cmd(conn->hdev, HCI_OP_LE_CREATE_CONN_CANCEL, 0, NULL);
 }
 
-static void hci_acl_connect(struct hci_conn *conn)
+static void hci_acl_create_connection(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct inquiry_entry *ie;
@@ -103,7 +103,7 @@ static void hci_acl_connect(struct hci_conn *conn)
 	hci_send_cmd(hdev, HCI_OP_CREATE_CONN, sizeof(cp), &cp);
 }
 
-static void hci_acl_connect_cancel(struct hci_conn *conn)
+static void hci_acl_create_connection_cancel(struct hci_conn *conn)
 {
 	struct hci_cp_create_conn_cancel cp;
 
@@ -245,9 +245,9 @@ static void hci_conn_timeout(struct work_struct *work)
 	case BT_CONNECT2:
 		if (conn->out) {
 			if (conn->type == ACL_LINK)
-				hci_acl_connect_cancel(conn);
+				hci_acl_create_connection_cancel(conn);
 			else if (conn->type == LE_LINK)
-				hci_le_connect_cancel(conn);
+				hci_le_create_connection_cancel(conn);
 		}
 		break;
 	case BT_CONFIG:
@@ -494,7 +494,7 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 				return ERR_PTR(-ENOMEM);
 
 			le->dst_type = bdaddr_to_le(dst_type);
-			hci_le_connect(le);
+			hci_le_create_connection(le);
 		}
 
 		le->pending_sec_level = sec_level;
@@ -518,7 +518,7 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 		acl->sec_level = BT_SECURITY_LOW;
 		acl->pending_sec_level = sec_level;
 		acl->auth_type = auth_type;
-		hci_acl_connect(acl);
+		hci_acl_create_connection(acl);
 	}
 
 	if (type == ACL_LINK)
@@ -771,7 +771,7 @@ void hci_conn_check_pending(struct hci_dev *hdev)
 
 	conn = hci_conn_hash_lookup_state(hdev, ACL_LINK, BT_CONNECT2);
 	if (conn)
-		hci_acl_connect(conn);
+		hci_acl_create_connection(conn);
 
 	hci_dev_unlock(hdev);
 }

commit 57f5d0d1d9f8e59819cb0ab4b707364c54b5b2d1
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Jul 27 19:32:54 2012 -0300

    Bluetooth: Remove some functions from being exported
    
    Some connection related functions are only used inside hci_conn.c
    so no need to have them exported.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5ad7da217474..724eea980812 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -59,7 +59,7 @@ static void hci_le_connect_cancel(struct hci_conn *conn)
 	hci_send_cmd(conn->hdev, HCI_OP_LE_CREATE_CONN_CANCEL, 0, NULL);
 }
 
-void hci_acl_connect(struct hci_conn *conn)
+static void hci_acl_connect(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct inquiry_entry *ie;
@@ -129,7 +129,7 @@ void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
 	hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
 }
 
-void hci_add_sco(struct hci_conn *conn, __u16 handle)
+static void hci_add_sco(struct hci_conn *conn, __u16 handle)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_add_sco cp;

commit d300fa9b14549c64e63691356c68483bcfeb0f04
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Tue Jun 19 15:21:21 2012 +0300

    Bluetooth: Route traffic only through BR/EDR controller
    
    If AMP controller is first in the list then Bluetooth traffic might
    be routed through it (if source is not specified). The patch
    prevents this case and also checks that source is BR/EDR.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 9bbef6e95d2c..5ad7da217474 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -442,7 +442,8 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 
 	list_for_each_entry(d, &hci_dev_list, list) {
 		if (!test_bit(HCI_UP, &d->flags) ||
-		    test_bit(HCI_RAW, &d->flags))
+		    test_bit(HCI_RAW, &d->flags) ||
+		    d->dev_type != HCI_BREDR)
 			continue;
 
 		/* Simple routing:

commit 38b3fef1730319e2730af3fc9f73698e3a9aeb4a
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Fri Jun 15 11:50:28 2012 +0300

    Bluetooth: Improve debugging messages for hci_conn
    
    Improve debugging of hci_conn objects by: adding print to hci_conn
    refcounting, adding object spcifier when missing, change conn to hcon
    since conn is heavily used for l2cap_conn objects and this is misleading.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 2fcced377e50..9bbef6e95d2c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -107,7 +107,7 @@ static void hci_acl_connect_cancel(struct hci_conn *conn)
 {
 	struct hci_cp_create_conn_cancel cp;
 
-	BT_DBG("%p", conn);
+	BT_DBG("hcon %p", conn);
 
 	if (conn->hdev->hci_ver < BLUETOOTH_VER_1_2)
 		return;
@@ -120,7 +120,7 @@ void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
 {
 	struct hci_cp_disconnect cp;
 
-	BT_DBG("%p", conn);
+	BT_DBG("hcon %p", conn);
 
 	conn->state = BT_DISCONN;
 
@@ -134,7 +134,7 @@ void hci_add_sco(struct hci_conn *conn, __u16 handle)
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_add_sco cp;
 
-	BT_DBG("%p", conn);
+	BT_DBG("hcon %p", conn);
 
 	conn->state = BT_CONNECT;
 	conn->out = true;
@@ -152,7 +152,7 @@ void hci_setup_sync(struct hci_conn *conn, __u16 handle)
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_setup_sync_conn cp;
 
-	BT_DBG("%p", conn);
+	BT_DBG("hcon %p", conn);
 
 	conn->state = BT_CONNECT;
 	conn->out = true;
@@ -196,7 +196,7 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_le_start_enc cp;
 
-	BT_DBG("%p", conn);
+	BT_DBG("hcon %p", conn);
 
 	memset(&cp, 0, sizeof(cp));
 
@@ -213,11 +213,11 @@ void hci_sco_setup(struct hci_conn *conn, __u8 status)
 {
 	struct hci_conn *sco = conn->link;
 
-	BT_DBG("%p", conn);
-
 	if (!sco)
 		return;
 
+	BT_DBG("hcon %p", conn);
+
 	if (!status) {
 		if (lmp_esco_capable(conn->hdev))
 			hci_setup_sync(sco, conn->handle);
@@ -235,7 +235,7 @@ static void hci_conn_timeout(struct work_struct *work)
 					     disc_work.work);
 	__u8 reason;
 
-	BT_DBG("conn %p state %s", conn, state_to_string(conn->state));
+	BT_DBG("hcon %p state %s", conn, state_to_string(conn->state));
 
 	if (atomic_read(&conn->refcnt))
 		return;
@@ -266,7 +266,7 @@ static void hci_conn_enter_sniff_mode(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
 
-	BT_DBG("conn %p mode %d", conn, conn->mode);
+	BT_DBG("hcon %p mode %d", conn, conn->mode);
 
 	if (test_bit(HCI_RAW, &hdev->flags))
 		return;
@@ -301,7 +301,7 @@ static void hci_conn_idle(unsigned long arg)
 {
 	struct hci_conn *conn = (void *) arg;
 
-	BT_DBG("conn %p mode %d", conn, conn->mode);
+	BT_DBG("hcon %p mode %d", conn, conn->mode);
 
 	hci_conn_enter_sniff_mode(conn);
 }
@@ -382,7 +382,7 @@ int hci_conn_del(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
 
-	BT_DBG("%s conn %p handle %d", hdev->name, conn, conn->handle);
+	BT_DBG("%s hcon %p handle %d", hdev->name, conn, conn->handle);
 
 	del_timer(&conn->idle_timer);
 
@@ -557,7 +557,7 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 /* Check link security requirement */
 int hci_conn_check_link_mode(struct hci_conn *conn)
 {
-	BT_DBG("conn %p", conn);
+	BT_DBG("hcon %p", conn);
 
 	if (hci_conn_ssp_enabled(conn) && !(conn->link_mode & HCI_LM_ENCRYPT))
 		return 0;
@@ -568,7 +568,7 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 /* Authenticate remote device */
 static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
-	BT_DBG("conn %p", conn);
+	BT_DBG("hcon %p", conn);
 
 	if (conn->pending_sec_level > sec_level)
 		sec_level = conn->pending_sec_level;
@@ -602,7 +602,7 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 /* Encrypt the the link */
 static void hci_conn_encrypt(struct hci_conn *conn)
 {
-	BT_DBG("conn %p", conn);
+	BT_DBG("hcon %p", conn);
 
 	if (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {
 		struct hci_cp_set_conn_encrypt cp;
@@ -616,7 +616,7 @@ static void hci_conn_encrypt(struct hci_conn *conn)
 /* Enable security */
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
-	BT_DBG("conn %p", conn);
+	BT_DBG("hcon %p", conn);
 
 	/* For sdp we don't need the link key. */
 	if (sec_level == BT_SECURITY_SDP)
@@ -669,7 +669,7 @@ EXPORT_SYMBOL(hci_conn_security);
 /* Check secure link requirement */
 int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)
 {
-	BT_DBG("conn %p", conn);
+	BT_DBG("hcon %p", conn);
 
 	if (sec_level != BT_SECURITY_HIGH)
 		return 1; /* Accept if non-secure is required */
@@ -684,7 +684,7 @@ EXPORT_SYMBOL(hci_conn_check_secure);
 /* Change link key */
 int hci_conn_change_link_key(struct hci_conn *conn)
 {
-	BT_DBG("conn %p", conn);
+	BT_DBG("hcon %p", conn);
 
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_change_conn_link_key cp;
@@ -699,7 +699,7 @@ int hci_conn_change_link_key(struct hci_conn *conn)
 /* Switch role */
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role)
 {
-	BT_DBG("conn %p", conn);
+	BT_DBG("hcon %p", conn);
 
 	if (!role && conn->link_mode & HCI_LM_MASTER)
 		return 1;
@@ -720,7 +720,7 @@ void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 {
 	struct hci_dev *hdev = conn->hdev;
 
-	BT_DBG("conn %p mode %d", conn, conn->mode);
+	BT_DBG("hcon %p mode %d", conn, conn->mode);
 
 	if (test_bit(HCI_RAW, &hdev->flags))
 		return;
@@ -894,7 +894,7 @@ struct hci_chan *hci_chan_create(struct hci_conn *conn)
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_chan *chan;
 
-	BT_DBG("%s conn %p", hdev->name, conn);
+	BT_DBG("%s hcon %p", hdev->name, conn);
 
 	chan = kzalloc(sizeof(struct hci_chan), GFP_KERNEL);
 	if (!chan)
@@ -913,7 +913,7 @@ int hci_chan_del(struct hci_chan *chan)
 	struct hci_conn *conn = chan->conn;
 	struct hci_dev *hdev = conn->hdev;
 
-	BT_DBG("%s conn %p chan %p", hdev->name, conn, chan);
+	BT_DBG("%s hcon %p chan %p", hdev->name, conn, chan);
 
 	list_del_rcu(&chan->list);
 
@@ -929,7 +929,7 @@ void hci_chan_list_flush(struct hci_conn *conn)
 {
 	struct hci_chan *chan, *n;
 
-	BT_DBG("conn %p", conn);
+	BT_DBG("hcon %p", conn);
 
 	list_for_each_entry_safe(chan, n, &conn->chan_list, list)
 		hci_chan_del(chan);

commit dfc94dbdb999154dc2ff44e6011a4912c0b29e88
Author: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
Date:   Wed May 30 15:39:21 2012 +0200

    Bluetooth: Allow only one LE connection attempt
    
    Only one outgoing LE connection attempt should be possible.
    hci_connect() will now return -EBUSY in case there's another pending
    outgoing connection.
    
    Signed-off-by: Andrzej Kaczmarek <andrzej.kaczmarek@tieto.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 1458667b2845..2fcced377e50 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -483,6 +483,11 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 	if (type == LE_LINK) {
 		le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
 		if (!le) {
+			le = hci_conn_hash_lookup_state(hdev, LE_LINK,
+							BT_CONNECT);
+			if (le)
+				return ERR_PTR(-EBUSY);
+
 			le = hci_conn_add(hdev, LE_LINK, dst);
 			if (!le)
 				return ERR_PTR(-ENOMEM);

commit 9740e49d17e55f3832661fd99a8e0a17e921a82e
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Tue May 29 13:59:02 2012 +0300

    Bluetooth: A2MP: AMP Manager basic functions
    
    Define AMP Manager and some basic functions.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 126876d915f5..1458667b2845 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -28,6 +28,7 @@
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
+#include <net/bluetooth/a2mp.h>
 
 static void hci_le_connect(struct hci_conn *conn)
 {
@@ -411,6 +412,9 @@ int hci_conn_del(struct hci_conn *conn)
 
 	hci_chan_list_flush(conn);
 
+	if (conn->amp_mgr)
+		amp_mgr_put(conn->amp_mgr);
+
 	hci_conn_hash_del(hdev, conn);
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);

commit 82781e634f815e9a675ef643a5e11da0cf77ce0e
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Fri May 25 11:38:27 2012 +0300

    Bluetooth: Use __constant modifier in HCI code
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 8163ee175d6a..126876d915f5 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -40,15 +40,15 @@ static void hci_le_connect(struct hci_conn *conn)
 	conn->sec_level = BT_SECURITY_LOW;
 
 	memset(&cp, 0, sizeof(cp));
-	cp.scan_interval = cpu_to_le16(0x0060);
-	cp.scan_window = cpu_to_le16(0x0030);
+	cp.scan_interval = __constant_cpu_to_le16(0x0060);
+	cp.scan_window = __constant_cpu_to_le16(0x0030);
 	bacpy(&cp.peer_addr, &conn->dst);
 	cp.peer_addr_type = conn->dst_type;
-	cp.conn_interval_min = cpu_to_le16(0x0028);
-	cp.conn_interval_max = cpu_to_le16(0x0038);
-	cp.supervision_timeout = cpu_to_le16(0x002a);
-	cp.min_ce_len = cpu_to_le16(0x0000);
-	cp.max_ce_len = cpu_to_le16(0x0000);
+	cp.conn_interval_min = __constant_cpu_to_le16(0x0028);
+	cp.conn_interval_max = __constant_cpu_to_le16(0x0038);
+	cp.supervision_timeout = __constant_cpu_to_le16(0x002a);
+	cp.min_ce_len = __constant_cpu_to_le16(0x0000);
+	cp.max_ce_len = __constant_cpu_to_le16(0x0000);
 
 	hci_send_cmd(hdev, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
 }
@@ -85,7 +85,7 @@ void hci_acl_connect(struct hci_conn *conn)
 			cp.pscan_rep_mode = ie->data.pscan_rep_mode;
 			cp.pscan_mode     = ie->data.pscan_mode;
 			cp.clock_offset   = ie->data.clock_offset |
-							cpu_to_le16(0x8000);
+					    __constant_cpu_to_le16(0x8000);
 		}
 
 		memcpy(conn->dev_class, ie->data.dev_class, 3);
@@ -161,9 +161,9 @@ void hci_setup_sync(struct hci_conn *conn, __u16 handle)
 	cp.handle   = cpu_to_le16(handle);
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 
-	cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
-	cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
-	cp.max_latency    = cpu_to_le16(0xffff);
+	cp.tx_bandwidth   = __constant_cpu_to_le32(0x00001f40);
+	cp.rx_bandwidth   = __constant_cpu_to_le32(0x00001f40);
+	cp.max_latency    = __constant_cpu_to_le16(0xffff);
 	cp.voice_setting  = cpu_to_le16(hdev->voice_setting);
 	cp.retrans_effort = 0xff;
 
@@ -183,8 +183,8 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 	cp.conn_interval_max	= cpu_to_le16(max);
 	cp.conn_latency		= cpu_to_le16(latency);
 	cp.supervision_timeout	= cpu_to_le16(to_multiplier);
-	cp.min_ce_len		= cpu_to_le16(0x0001);
-	cp.max_ce_len		= cpu_to_le16(0x0001);
+	cp.min_ce_len		= __constant_cpu_to_le16(0x0001);
+	cp.max_ce_len		= __constant_cpu_to_le16(0x0001);
 
 	hci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);
 }
@@ -279,9 +279,9 @@ static void hci_conn_enter_sniff_mode(struct hci_conn *conn)
 	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
 		struct hci_cp_sniff_subrate cp;
 		cp.handle             = cpu_to_le16(conn->handle);
-		cp.max_latency        = cpu_to_le16(0);
-		cp.min_remote_timeout = cpu_to_le16(0);
-		cp.min_local_timeout  = cpu_to_le16(0);
+		cp.max_latency        = __constant_cpu_to_le16(0);
+		cp.min_remote_timeout = __constant_cpu_to_le16(0);
+		cp.min_local_timeout  = __constant_cpu_to_le16(0);
 		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
 	}
 
@@ -290,8 +290,8 @@ static void hci_conn_enter_sniff_mode(struct hci_conn *conn)
 		cp.handle       = cpu_to_le16(conn->handle);
 		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
 		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
-		cp.attempt      = cpu_to_le16(4);
-		cp.timeout      = cpu_to_le16(1);
+		cp.attempt      = __constant_cpu_to_le16(4);
+		cp.timeout      = __constant_cpu_to_le16(1);
 		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
 	}
 }

commit 8449e381a8558fb1d911017ea26bae681fea4240
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Wed May 23 04:04:23 2012 -0300

    Bluetooth: Remove unneeded EXPORT_SYMBOL
    
    After l2cap, sco and bluetooth modules merge some symbols doesn't need to
    be exported anymore.
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3bb2d552a888..8163ee175d6a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -188,7 +188,6 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 
 	hci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);
 }
-EXPORT_SYMBOL(hci_le_conn_update);
 
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 		      __u8 ltk[16])
@@ -207,7 +206,6 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 
 	hci_send_cmd(hdev, HCI_OP_LE_START_ENC, sizeof(cp), &cp);
 }
-EXPORT_SYMBOL(hci_le_start_enc);
 
 /* Device _must_ be locked */
 void hci_sco_setup(struct hci_conn *conn, __u8 status)
@@ -546,7 +544,6 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 
 	return sco;
 }
-EXPORT_SYMBOL(hci_connect);
 
 /* Check link security requirement */
 int hci_conn_check_link_mode(struct hci_conn *conn)
@@ -558,7 +555,6 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 
 	return 1;
 }
-EXPORT_SYMBOL(hci_conn_check_link_mode);
 
 /* Authenticate remote device */
 static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
@@ -690,7 +686,6 @@ int hci_conn_change_link_key(struct hci_conn *conn)
 
 	return 0;
 }
-EXPORT_SYMBOL(hci_conn_change_link_key);
 
 /* Switch role */
 int hci_conn_switch_role(struct hci_conn *conn, __u8 role)

commit 8c520a59927a5600973782505dbb750d985057c4
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Wed May 23 04:04:22 2012 -0300

    Bluetooth: Remove unnecessary headers include
    
    Most of the include were unnecessary or already included by some other
    header.
    Replace module.h by export.h where possible.
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 231fc4400f37..3bb2d552a888 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -24,21 +24,7 @@
 
 /* Bluetooth HCI connection handling. */
 
-#include <linux/module.h>
-
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/poll.h>
-#include <linux/fcntl.h>
-#include <linux/init.h>
-#include <linux/skbuff.h>
-#include <linux/interrupt.h>
-#include <net/sock.h>
-
-#include <linux/uaccess.h>
-#include <asm/unaligned.h>
+#include <linux/export.h>
 
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>

commit 8fc9ced398824739d3c25c8aa7f6f34d8e7a49d9
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Wed May 23 04:04:21 2012 -0300

    Bluetooth: Fix coding style in the subsystem
    
    This is some leftover from the last patches that fixed style. It is mostly
    line over 80 characters fixes reported by checkpatch.pl.
    checkpatch.pl is clean for these files now.
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 0d73577b84cb..231fc4400f37 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -453,7 +453,8 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 	read_lock(&hci_dev_list_lock);
 
 	list_for_each_entry(d, &hci_dev_list, list) {
-		if (!test_bit(HCI_UP, &d->flags) || test_bit(HCI_RAW, &d->flags))
+		if (!test_bit(HCI_UP, &d->flags) ||
+		    test_bit(HCI_RAW, &d->flags))
 			continue;
 
 		/* Simple routing:

commit fc5fef615a963c8b13abf0bbc2a8e8d7c3fd1ffb
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Wed May 23 04:04:19 2012 -0300

    Bluetooth: Remove 'register' usage from the subsystem
    
    Let the compiler chooses what is best.
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index da9f827241d0..0d73577b84cb 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -799,7 +799,7 @@ EXPORT_SYMBOL(hci_conn_put_device);
 
 int hci_get_conn_list(void __user *arg)
 {
-	register struct hci_conn *c;
+	struct hci_conn *c;
 	struct hci_conn_list_req req, *cl;
 	struct hci_conn_info *ci;
 	struct hci_dev *hdev;

commit 4f42a8cd4905e69ba4dd694d9338aeee1bb7e9ab
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Wed May 23 11:31:23 2012 +0300

    Bluetooth: trivial: Remove empty line
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 971601e0ad4a..da9f827241d0 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -425,7 +425,6 @@ int hci_conn_del(struct hci_conn *conn)
 		}
 	}
 
-
 	hci_chan_list_flush(conn);
 
 	hci_conn_hash_del(hdev, conn);

commit 5974e4c469658696e6e0ce8951a59a61b122415a
Author: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
Date:   Thu May 17 00:36:25 2012 -0300

    Bluetooth: Fix coding style in hci_conn.c
    
    Follow net subsystem rules.
    
    Signed-off-by: Gustavo Padovan <gustavo.padovan@collabora.co.uk>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3f18a6ed9731..971601e0ad4a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -185,7 +185,7 @@ void hci_setup_sync(struct hci_conn *conn, __u16 handle)
 }
 
 void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
-					u16 latency, u16 to_multiplier)
+			u16 latency, u16 to_multiplier)
 {
 	struct hci_cp_le_conn_update cp;
 	struct hci_dev *hdev = conn->hdev;
@@ -205,7 +205,7 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 EXPORT_SYMBOL(hci_le_conn_update);
 
 void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
-							__u8 ltk[16])
+		      __u8 ltk[16])
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct hci_cp_le_start_enc cp;
@@ -247,7 +247,7 @@ void hci_sco_setup(struct hci_conn *conn, __u8 status)
 static void hci_conn_timeout(struct work_struct *work)
 {
 	struct hci_conn *conn = container_of(work, struct hci_conn,
-							disc_work.work);
+					     disc_work.work);
 	__u8 reason;
 
 	BT_DBG("conn %p state %s", conn, state_to_string(conn->state));
@@ -327,7 +327,7 @@ static void hci_conn_auto_accept(unsigned long arg)
 	struct hci_dev *hdev = conn->hdev;
 
 	hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),
-								&conn->dst);
+		     &conn->dst);
 }
 
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
@@ -376,7 +376,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	INIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);
 	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);
 	setup_timer(&conn->auto_accept_timer, hci_conn_auto_accept,
-							(unsigned long) conn);
+		    (unsigned long) conn);
 
 	atomic_set(&conn->refcnt, 0);
 
@@ -545,7 +545,7 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
 	hci_conn_hold(sco);
 
 	if (acl->state == BT_CONNECTED &&
-			(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
+	    (sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
 		set_bit(HCI_CONN_POWER_SAVE, &acl->flags);
 		hci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);
 
@@ -600,7 +600,7 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
-							sizeof(cp), &cp);
+			     sizeof(cp), &cp);
 		if (conn->key_type != 0xff)
 			set_bit(HCI_CONN_REAUTH_PEND, &conn->flags);
 	}
@@ -618,7 +618,7 @@ static void hci_conn_encrypt(struct hci_conn *conn)
 		cp.handle  = cpu_to_le16(conn->handle);
 		cp.encrypt = 0x01;
 		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
-									&cp);
+			     &cp);
 	}
 }
 
@@ -648,8 +648,7 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 	/* An unauthenticated combination key has sufficient security for
 	   security level 1 and 2. */
 	if (conn->key_type == HCI_LK_UNAUTH_COMBINATION &&
-			(sec_level == BT_SECURITY_MEDIUM ||
-			sec_level == BT_SECURITY_LOW))
+	    (sec_level == BT_SECURITY_MEDIUM || sec_level == BT_SECURITY_LOW))
 		goto encrypt;
 
 	/* A combination key has always sufficient security for the security
@@ -657,8 +656,7 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 	   is generated using maximum PIN code length (16).
 	   For pre 2.1 units. */
 	if (conn->key_type == HCI_LK_COMBINATION &&
-			(sec_level != BT_SECURITY_HIGH ||
-			conn->pin_length == 16))
+	    (sec_level != BT_SECURITY_HIGH || conn->pin_length == 16))
 		goto encrypt;
 
 auth:
@@ -701,7 +699,7 @@ int hci_conn_change_link_key(struct hci_conn *conn)
 		struct hci_cp_change_conn_link_key cp;
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_CHANGE_CONN_LINK_KEY,
-							sizeof(cp), &cp);
+			     sizeof(cp), &cp);
 	}
 
 	return 0;
@@ -752,7 +750,7 @@ void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 timer:
 	if (hdev->idle_timeout > 0)
 		mod_timer(&conn->idle_timer,
-			jiffies + msecs_to_jiffies(hdev->idle_timeout));
+			  jiffies + msecs_to_jiffies(hdev->idle_timeout));
 }
 
 /* Drop all connection on the device */

commit 2ee8ce35b1e8ba2523fa4c45fa19f9dbe321f008
Author: Syam Sidhardhan <s.syam@samsung.com>
Date:   Fri Apr 20 22:12:31 2012 +0530

    Bluetooth: Remove unused hci_le_ltk_neg_reply()
    
    No one is using hci_le_ltk_neg_reply() in bluetooth subsystem.
    
    Signed-off-by: Syam Sidhardhan <s.syam@samsung.com>
    Signed-off-by: Gustavo Padovan <gustavo@padovan.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index cae7ec2df7ad..3f18a6ed9731 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -223,20 +223,6 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 }
 EXPORT_SYMBOL(hci_le_start_enc);
 
-void hci_le_ltk_neg_reply(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_le_ltk_neg_reply cp;
-
-	BT_DBG("%p", conn);
-
-	memset(&cp, 0, sizeof(cp));
-
-	cp.handle = cpu_to_le16(conn->handle);
-
-	hci_send_cmd(hdev, HCI_OP_LE_LTK_NEG_REPLY, sizeof(cp), &cp);
-}
-
 /* Device _must_ be locked */
 void hci_sco_setup(struct hci_conn *conn, __u8 status)
 {

commit e10b9969f217c948c5523045f44eba4d3a758ff0
Author: Syam Sidhardhan <s.syam@samsung.com>
Date:   Thu Apr 12 20:33:17 2012 +0530

    Bluetooth: Remove unused hci_le_ltk_reply()
    
    In this API, we were using sizeof operator for an array
    given as function argument, which is invalid.
    However this API is not used anywhere.
    
    Signed-off-by: Syam Sidhardhan <s.syam@samsung.com>
    Signed-off-by: Gustavo Padovan <gustavo@padovan.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a3ee1a929a6c..cae7ec2df7ad 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -223,22 +223,6 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 }
 EXPORT_SYMBOL(hci_le_start_enc);
 
-void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16])
-{
-	struct hci_dev *hdev = conn->hdev;
-	struct hci_cp_le_ltk_reply cp;
-
-	BT_DBG("%p", conn);
-
-	memset(&cp, 0, sizeof(cp));
-
-	cp.handle = cpu_to_le16(conn->handle);
-	memcpy(cp.ltk, ltk, sizeof(ltk));
-
-	hci_send_cmd(hdev, HCI_OP_LE_LTK_REPLY, sizeof(cp), &cp);
-}
-EXPORT_SYMBOL(hci_le_ltk_reply);
-
 void hci_le_ltk_neg_reply(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;

commit b12f62cfd9f46ac70013ce661640174b489efd39
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 24 21:02:54 2012 -0300

    Bluetooth: Add dst_type parameter to hci_connect
    
    This patch adds the dst_type parameter to hci_connect function.
    Instead of searching the address type in advertising cache, we
    use the dst_type parameter to establish LE connections.
    
    The dst_type is ignored for BR/EDR connection establishment.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 8f352cd1745a..a3ee1a929a6c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -513,7 +513,8 @@ EXPORT_SYMBOL(hci_get_route);
 
 /* Create SCO, ACL or LE connection.
  * Device _must_ be locked */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type)
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst,
+			     __u8 dst_type, __u8 sec_level, __u8 auth_type)
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
@@ -522,19 +523,13 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
 	if (type == LE_LINK) {
-		struct adv_entry *entry = NULL;
-
 		le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
 		if (!le) {
-			entry = hci_find_adv_entry(hdev, dst);
-			if (!entry)
-				return ERR_PTR(-EHOSTUNREACH);
-
 			le = hci_conn_add(hdev, LE_LINK, dst);
 			if (!le)
 				return ERR_PTR(-ENOMEM);
 
-			le->dst_type = entry->bdaddr_type;
+			le->dst_type = bdaddr_to_le(dst_type);
 			hci_le_connect(le);
 		}
 

commit b29050448a7efcedf5e8bec71c371169389a7a26
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue Apr 24 16:11:11 2012 -0300

    Bluetooth: Remove useless code in hci_connect
    
    This patch removes unneeded variable assignments in hci_connect.
    'sec_level' is already assigned to BT_SECURITY_LOW in hci_le_connect
    and 'pending_sec_level' and 'auth_type' are assigned right after
    if statement.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7db3edc28f77..8f352cd1745a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -535,9 +535,6 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 				return ERR_PTR(-ENOMEM);
 
 			le->dst_type = entry->bdaddr_type;
-			le->pending_sec_level = sec_level;
-			le->sec_level = BT_SECURITY_LOW;
-			le->auth_type = auth_type;
 			hci_le_connect(le);
 		}
 

commit 9f0caeb1deafa9a894ee03134f6642c3a245b1af
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Fri Apr 20 15:46:08 2012 -0300

    Bluetooth: Add support for reusing the same hci_conn for LE links
    
    As most LE devices leave advertising mode when they enter the connected
    state, we may want to "pass" that connection to other users.
    
    The first user will be the pairing procedure, the connection is
    established without an associated socket, after the pairing is
    complete, userspace may want to discover via GATT what services the
    newly bonded device has.
    
    If userspace establishes the connection while the timeout still
    hasn't expired, the connection will be re-used.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Tested-by: JoÃ£o Paulo Rechi Vita <jprvita@openbossa.org>
    Signed-off-by: Gustavo Padovan <gustavo@padovan.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5238b6b3ea6a..7db3edc28f77 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -522,23 +522,27 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
 	if (type == LE_LINK) {
-		struct adv_entry *entry;
+		struct adv_entry *entry = NULL;
 
 		le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
-		if (le)
-			return ERR_PTR(-EBUSY);
-
-		entry = hci_find_adv_entry(hdev, dst);
-		if (!entry)
-			return ERR_PTR(-EHOSTUNREACH);
-
-		le = hci_conn_add(hdev, LE_LINK, dst);
-		if (!le)
-			return ERR_PTR(-ENOMEM);
-
-		le->dst_type = entry->bdaddr_type;
+		if (!le) {
+			entry = hci_find_adv_entry(hdev, dst);
+			if (!entry)
+				return ERR_PTR(-EHOSTUNREACH);
+
+			le = hci_conn_add(hdev, LE_LINK, dst);
+			if (!le)
+				return ERR_PTR(-ENOMEM);
+
+			le->dst_type = entry->bdaddr_type;
+			le->pending_sec_level = sec_level;
+			le->sec_level = BT_SECURITY_LOW;
+			le->auth_type = auth_type;
+			hci_le_connect(le);
+		}
 
-		hci_le_connect(le);
+		le->pending_sec_level = sec_level;
+		le->auth_type = auth_type;
 
 		hci_conn_hold(le);
 

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 947172bf1621..5238b6b3ea6a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -37,7 +37,6 @@
 #include <linux/interrupt.h>
 #include <net/sock.h>
 
-#include <asm/system.h>
 #include <linux/uaccess.h>
 #include <asm/unaligned.h>
 

commit 70c1f20b00495fd25b81be14b263d32648a3d629
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Feb 22 12:06:43 2012 +0100

    Bluetooth: Fix two minor style issues in HCI code
    
    WARNING: min() should probably be min_t(__u16, scb->expect, count)
    +               len = min(scb->expect, (__u16)count);
    
    WARNING: Statements terminations use 1 semicolon
    +       INIT_LIST_HEAD(&conn->chan_list);;
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3c68e606d5e5..947172bf1621 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -402,7 +402,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	skb_queue_head_init(&conn->data_q);
 
-	INIT_LIST_HEAD(&conn->chan_list);;
+	INIT_LIST_HEAD(&conn->chan_list);
 
 	INIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);
 	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);

commit 040030ef7d907107e6489b39da518bdf94136d68
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 20 14:50:37 2012 +0100

    Bluetooth: Remove HCI notifier handling
    
    The HCI notifier handling was never used outside of Bluetooth core layer
    and thus remove it and replace it with direct function calls. Also move
    the stack internal event generation into the HCI socket layer.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 8549d04e3313..3c68e606d5e5 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -35,7 +35,6 @@
 #include <linux/init.h>
 #include <linux/skbuff.h>
 #include <linux/interrupt.h>
-#include <linux/notifier.h>
 #include <net/sock.h>
 
 #include <asm/system.h>

commit 48c7aba91f372251867d15efc9cf694ceee2de02
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Sun Feb 19 14:06:48 2012 +0200

    Bluetooth: Fix hci_connect error return values
    
    The hci_connect function should either return a valid hci_conn pointer
    or a ERR_PTR() but never NULL. This patch fixes the two places where
    hci_conn_add failures would have caused a NULL return. The only reason
    for failure with hci_conn_add is memory allocation so ENOMEM seems to be
    a good choice here.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7ee6895c4b0c..8549d04e3313 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -551,7 +551,7 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 	if (!acl) {
 		acl = hci_conn_add(hdev, ACL_LINK, dst);
 		if (!acl)
-			return NULL;
+			return ERR_PTR(-ENOMEM);
 	}
 
 	hci_conn_hold(acl);
@@ -571,7 +571,7 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 		sco = hci_conn_add(hdev, type, dst);
 		if (!sco) {
 			hci_conn_put(acl);
-			return NULL;
+			return ERR_PTR(-ENOMEM);
 		}
 	}
 

commit 42d2d87cfe837e987802588f8d8b119a76714a74
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Fri Feb 17 11:40:57 2012 +0200

    Bluetooth: Prefix hex numbers with object name
    
    Several hex numbers were printed without object name which
    complicates debugging.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index f38e1b11d835..7ee6895c4b0c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -80,7 +80,7 @@ void hci_acl_connect(struct hci_conn *conn)
 	struct inquiry_entry *ie;
 	struct hci_cp_create_conn cp;
 
-	BT_DBG("%p", conn);
+	BT_DBG("hcon %p", conn);
 
 	conn->state = BT_CONNECT;
 	conn->out = true;

commit e05dcc3291dcfe9ab1b456f38ccb3041ebbda59c
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Fri Feb 17 11:40:56 2012 +0200

    Bluetooth: Use symbolic names for state in debug
    
    Use state_to_string function in debug statements.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b4ecddee11b5..f38e1b11d835 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -282,7 +282,7 @@ static void hci_conn_timeout(struct work_struct *work)
 							disc_work.work);
 	__u8 reason;
 
-	BT_DBG("conn %p state %d", conn, conn->state);
+	BT_DBG("conn %p state %s", conn, state_to_string(conn->state));
 
 	if (atomic_read(&conn->refcnt))
 		return;

commit 2a5a5ec620a29d4ba07743c3151cdf0a417c8f8c
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Feb 2 10:32:18 2012 +0200

    Bluetooth: Use list _safe deleting from conn chan_list
    
    Fixes possible bug when deleting element from the list in
    function hci_chan_list_flush. list_for_each_entry_rcu is used
    and after deleting element from the list we also free pointer
    and then list_entry_rcu is taken from freed pointer.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b074bd698cf6..b4ecddee11b5 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -975,10 +975,10 @@ int hci_chan_del(struct hci_chan *chan)
 
 void hci_chan_list_flush(struct hci_conn *conn)
 {
-	struct hci_chan *chan;
+	struct hci_chan *chan, *n;
 
 	BT_DBG("conn %p", conn);
 
-	list_for_each_entry_rcu(chan, &conn->chan_list, list)
+	list_for_each_entry_safe(chan, n, &conn->chan_list, list)
 		hci_chan_del(chan);
 }

commit 3c4e0df028935618d052235ba85bc7079be13394
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Feb 2 10:32:17 2012 +0200

    Bluetooth: Use list _safe deleting from conn_hash_list
    
    Use list_for_each_entry_safe which is safe version against removal
    of list entry. Otherwise we remove hci_conn element and reference
    next element which result in accessing LIST_POISON.
    
    [   95.571834] Bluetooth: unknown link type 127
    [   95.578349] BUG: unable to handle kernel paging request at 20002000
    [   95.580236] IP: [<20002000>] 0x20001fff
    [   95.580763] *pde = 00000000
    [   95.581196] Oops: 0000 [#1] SMP
    ...
    [   95.582298] Pid: 3355, comm: hciconfig Tainted: G   O 3.2.0-VirttualBox
    [   95.582298] EIP: 0060:[<20002000>] EFLAGS: 00210206 CPU: 0
    [   95.582298] EIP is at 0x20002000
    ...
    [   95.582298] Call Trace:
    [   95.582298]  [<f8231ab6>] ? hci_conn_hash_flush+0x76/0xf0 [bluetooth]
    [   95.582298]  [<f822bcb1>] hci_dev_do_close+0xc1/0x2e0 [bluetooth]
    [   95.582298]  [<f822d679>] ? hci_dev_get+0x69/0xb0 [bluetooth]
    [   95.582298]  [<f822e1da>] hci_dev_close+0x2a/0x50 [bluetooth]
    [   95.582298]  [<f824102f>] hci_sock_ioctl+0x1af/0x3f0 [bluetooth]
    [   95.582298]  [<c11153ea>] ? handle_pte_fault+0x8a/0x8f0
    [   95.582298]  [<c146becf>] sock_ioctl+0x5f/0x260
    [   95.582298]  [<c146be70>] ? sock_fasync+0x90/0x90
    [   95.582298]  [<c1152b33>] do_vfs_ioctl+0x83/0x5b0
    [   95.582298]  [<c1563f87>] ? do_page_fault+0x297/0x500
    [   95.582298]  [<c1563cf0>] ? spurious_fault+0xd0/0xd0
    [   95.582298]  [<c107165b>] ? up_read+0x1b/0x30
    [   95.582298]  [<c1563f87>] ? do_page_fault+0x297/0x500
    [   95.582298]  [<c100aa9f>] ? init_fpu+0xef/0x160
    [   95.582298]  [<c15617c0>] ? do_debug+0x180/0x180
    [   95.582298]  [<c100a958>] ? fpu_finit+0x28/0x80
    [   95.582298]  [<c11530e7>] sys_ioctl+0x87/0x90
    [   95.582298]  [<c156795f>] sysenter_do_call+0x12/0x38
    ...
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index aca71c087a1d..b074bd698cf6 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -795,11 +795,11 @@ void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 void hci_conn_hash_flush(struct hci_dev *hdev)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct hci_conn *c;
+	struct hci_conn *c, *n;
 
 	BT_DBG("hdev %s", hdev->name);
 
-	list_for_each_entry_rcu(c, &h->list, list) {
+	list_for_each_entry_safe(c, n, &h->list, list) {
 		c->state = BT_CLOSED;
 
 		hci_proto_disconn_cfm(c, HCI_ERROR_LOCAL_HOST_TERM);

commit b7d05bad1c10a363b6b99f66ac1fa76b6892e618
Author: Peter Hurley <peter@hurleysoftware.com>
Date:   Fri Jan 13 15:11:30 2012 +0100

    Bluetooth: Fix l2cap conn failures for ssp devices
    
    Commit 330605423c fixed l2cap conn establishment for non-ssp remote
    devices by not setting HCI_CONN_ENCRYPT_PEND every time conn security
    is tested (which was always returning failure on any subsequent
    security checks).
    
    However, this broke l2cap conn establishment for ssp remote devices
    when an ACL link was already established at SDP-level security. This
    fix ensures that encryption must be pending whenever authentication
    is also pending.
    
    Signed-off-by: Peter Hurley <peter@hurleysoftware.com>
    Tested-by: Daniel Wagner <daniel.wagner@bmw-carit.de>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 67c94c4dfc3c..aca71c087a1d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -630,6 +630,10 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_auth_requested cp;
+
+		/* encrypt must be pending if auth is also pending */
+		set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags);
+
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
 							sizeof(cp), &cp);

commit e72acc13c770a82b4ce4a07e9716f29320eae0f8
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Fri Jan 27 19:42:03 2012 -0300

    Bluetooth: Remove unneeded locking
    
    We don't need locking hdev in hci_conn_timeout() since it doesn't
    access any hdev's shared resources, it basically queues HCI commands.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Reviewed-by: Ulisses Furquim <ulisses@profusion.mobi>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7b38a0ba8765..67c94c4dfc3c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -280,7 +280,6 @@ static void hci_conn_timeout(struct work_struct *work)
 {
 	struct hci_conn *conn = container_of(work, struct hci_conn,
 							disc_work.work);
-	struct hci_dev *hdev = conn->hdev;
 	__u8 reason;
 
 	BT_DBG("conn %p state %d", conn, conn->state);
@@ -288,8 +287,6 @@ static void hci_conn_timeout(struct work_struct *work)
 	if (atomic_read(&conn->refcnt))
 		return;
 
-	hci_dev_lock(hdev);
-
 	switch (conn->state) {
 	case BT_CONNECT:
 	case BT_CONNECT2:
@@ -309,8 +306,6 @@ static void hci_conn_timeout(struct work_struct *work)
 		conn->state = BT_CLOSED;
 		break;
 	}
-
-	hci_dev_unlock(hdev);
 }
 
 /* Enter sniff mode */

commit 75d7735c7a3ddc3842473219460285748d10db11
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Mon Jan 30 09:22:10 2012 -0300

    Bluetooth: Use GFP_KERNEL in hci_chan_create()
    
    This function is called in process context only, so it should use
    GFP_KERNEL to allocate memory.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 9ec7b8efae50..7b38a0ba8765 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -945,7 +945,7 @@ struct hci_chan *hci_chan_create(struct hci_conn *conn)
 
 	BT_DBG("%s conn %p", hdev->name, conn);
 
-	chan = kzalloc(sizeof(struct hci_chan), GFP_ATOMIC);
+	chan = kzalloc(sizeof(struct hci_chan), GFP_KERNEL);
 	if (!chan)
 		return NULL;
 

commit cb601d7e65f497a2a172d65b2ef1d738ac6fe4f4
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Mon Jan 30 09:22:09 2012 -0300

    Bluetooth: Use GFP_KERNEL in hci_conn_add()
    
    This function is called in process context only, so it should use
    GFP_KERNEL to allocate memory.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index eae7a53467ef..9ec7b8efae50 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -373,7 +373,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
-	conn = kzalloc(sizeof(struct hci_conn), GFP_ATOMIC);
+	conn = kzalloc(sizeof(struct hci_conn), GFP_KERNEL);
 	if (!conn)
 		return NULL;
 

commit aa64a8b500e61c33c17f1d5e7de0cc154489c59e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jan 18 21:33:12 2012 +0200

    Bluetooth: Add a convenience function to check for SSP enabled
    
    It's a very common test to see if both the local and the remote device
    have SSP enabled. By creating a simple function to test this we can
    shorten many if-statements in the code.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6ec259e84b95..eae7a53467ef 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -608,9 +608,7 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 {
 	BT_DBG("conn %p", conn);
 
-	if (test_bit(HCI_CONN_SSP_ENABLED, &conn->flags) &&
-			test_bit(HCI_SSP_ENABLED, &conn->hdev->dev_flags) &&
-			!(conn->link_mode & HCI_LM_ENCRYPT))
+	if (hci_conn_ssp_enabled(conn) && !(conn->link_mode & HCI_LM_ENCRYPT))
 		return 0;
 
 	return 1;
@@ -672,9 +670,7 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 
 	/* For non 2.1 devices and low security level we don't need the link
 	   key. */
-	if (sec_level == BT_SECURITY_LOW &&
-			(!test_bit(HCI_CONN_SSP_ENABLED, &conn->flags) ||
-			!test_bit(HCI_SSP_ENABLED, &conn->hdev->dev_flags)))
+	if (sec_level == BT_SECURITY_LOW && !hci_conn_ssp_enabled(conn))
 		return 1;
 
 	/* For other security levels we need the link key. */

commit 84bde9d6c0e6830f4a8685a5d237965053118bf9
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Wed Jan 25 14:21:06 2012 +0200

    Bluetooth: Convert hdev->ssp_mode to a flag
    
    The ssp_mode is essentially just a boolean so it's more appropriate to
    have it simply as a flag in hdev->dev_flags.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 8288e303621a..6ec259e84b95 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -609,8 +609,8 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 	BT_DBG("conn %p", conn);
 
 	if (test_bit(HCI_CONN_SSP_ENABLED, &conn->flags) &&
-					conn->hdev->ssp_mode > 0 &&
-					!(conn->link_mode & HCI_LM_ENCRYPT))
+			test_bit(HCI_SSP_ENABLED, &conn->hdev->dev_flags) &&
+			!(conn->link_mode & HCI_LM_ENCRYPT))
 		return 0;
 
 	return 1;
@@ -674,7 +674,7 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 	   key. */
 	if (sec_level == BT_SECURITY_LOW &&
 			(!test_bit(HCI_CONN_SSP_ENABLED, &conn->flags) ||
-							!conn->hdev->ssp_mode))
+			!test_bit(HCI_SSP_ENABLED, &conn->hdev->dev_flags)))
 		return 1;
 
 	/* For other security levels we need the link key. */

commit 58a681ef1455aef9caad1d41073868fb399373f6
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jan 16 06:47:28 2012 +0200

    Bluetooth: Merge boolean members of struct hci_conn into flags
    
    Now that the flags member of struct hci_conn is supposed to accommodate
    any boolean type values we can easily merge all boolean members into it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a707d19ee44e..8288e303621a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -105,7 +105,8 @@ void hci_acl_connect(struct hci_conn *conn)
 		}
 
 		memcpy(conn->dev_class, ie->data.dev_class, 3);
-		conn->ssp_mode = ie->data.ssp_mode;
+		if (ie->data.ssp_mode > 0)
+			set_bit(HCI_CONN_SSP_ENABLED, &conn->flags);
 	}
 
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);
@@ -386,7 +387,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	conn->remote_auth = 0xff;
 	conn->key_type = 0xff;
 
-	conn->power_save = 1;
+	set_bit(HCI_CONN_POWER_SAVE, &conn->flags);
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
 
 	switch (type) {
@@ -586,7 +587,7 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 
 	if (acl->state == BT_CONNECTED &&
 			(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
-		acl->power_save = 1;
+		set_bit(HCI_CONN_POWER_SAVE, &acl->flags);
 		hci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);
 
 		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->flags)) {
@@ -607,7 +608,8 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 {
 	BT_DBG("conn %p", conn);
 
-	if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0 &&
+	if (test_bit(HCI_CONN_SSP_ENABLED, &conn->flags) &&
+					conn->hdev->ssp_mode > 0 &&
 					!(conn->link_mode & HCI_LM_ENCRYPT))
 		return 0;
 
@@ -671,7 +673,8 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 	/* For non 2.1 devices and low security level we don't need the link
 	   key. */
 	if (sec_level == BT_SECURITY_LOW &&
-				(!conn->ssp_mode || !conn->hdev->ssp_mode))
+			(!test_bit(HCI_CONN_SSP_ENABLED, &conn->flags) ||
+							!conn->hdev->ssp_mode))
 		return 1;
 
 	/* For other security levels we need the link key. */
@@ -778,7 +781,7 @@ void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 	if (conn->mode != HCI_CM_SNIFF)
 		goto timer;
 
-	if (!conn->power_save && !force_active)
+	if (!test_bit(HCI_CONN_POWER_SAVE, &conn->flags) && !force_active)
 		goto timer;
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {

commit a0c808b373e89aecc3ecae4cbdcdeff68aa12e3e
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jan 16 09:49:58 2012 +0200

    Bluetooth: Convert hdev->out to a bool type
    
    The hdev->out variable is essentially a boolean so the type 'bool' makes
    more sense than u8.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 8a4678a2c982..a707d19ee44e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -51,7 +51,7 @@ static void hci_le_connect(struct hci_conn *conn)
 	struct hci_cp_le_create_conn cp;
 
 	conn->state = BT_CONNECT;
-	conn->out = 1;
+	conn->out = true;
 	conn->link_mode |= HCI_LM_MASTER;
 	conn->sec_level = BT_SECURITY_LOW;
 
@@ -83,7 +83,7 @@ void hci_acl_connect(struct hci_conn *conn)
 	BT_DBG("%p", conn);
 
 	conn->state = BT_CONNECT;
-	conn->out = 1;
+	conn->out = true;
 
 	conn->link_mode = HCI_LM_MASTER;
 
@@ -151,7 +151,7 @@ void hci_add_sco(struct hci_conn *conn, __u16 handle)
 	BT_DBG("%p", conn);
 
 	conn->state = BT_CONNECT;
-	conn->out = 1;
+	conn->out = true;
 
 	conn->attempt++;
 
@@ -169,7 +169,7 @@ void hci_setup_sync(struct hci_conn *conn, __u16 handle)
 	BT_DBG("%p", conn);
 
 	conn->state = BT_CONNECT;
-	conn->out = 1;
+	conn->out = true;
 
 	conn->attempt++;
 

commit 51a8efd7d02c13cb1c6fdd1cd66788792a3fcc7c
Author: Johan Hedberg <johan.hedberg@intel.com>
Date:   Mon Jan 16 06:10:31 2012 +0200

    Bluetooth: Rename conn->pend to conn->flags
    
    These flags can and will be used for more general purpose values than
    just pending state transitions so the more common name "flags" makes
    more sense than "pend".
    
    Signed-off-by: Johan Hedberg <johan.hedberg@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3db432473ad5..8a4678a2c982 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -337,7 +337,7 @@ static void hci_conn_enter_sniff_mode(struct hci_conn *conn)
 		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
 	}
 
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
 		struct hci_cp_sniff_mode cp;
 		cp.handle       = cpu_to_le16(conn->handle);
 		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
@@ -589,9 +589,9 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 		acl->power_save = 1;
 		hci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);
 
-		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->pend)) {
+		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->flags)) {
 			/* defer SCO setup until mode change completed */
-			set_bit(HCI_CONN_SCO_SETUP_PEND, &acl->pend);
+			set_bit(HCI_CONN_SCO_SETUP_PEND, &acl->flags);
 			return sco;
 		}
 
@@ -633,13 +633,13 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 
 	conn->auth_type = auth_type;
 
-	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_auth_requested cp;
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
 							sizeof(cp), &cp);
 		if (conn->key_type != 0xff)
-			set_bit(HCI_CONN_REAUTH_PEND, &conn->pend);
+			set_bit(HCI_CONN_REAUTH_PEND, &conn->flags);
 	}
 
 	return 0;
@@ -650,7 +650,7 @@ static void hci_conn_encrypt(struct hci_conn *conn)
 {
 	BT_DBG("conn %p", conn);
 
-	if (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags)) {
 		struct hci_cp_set_conn_encrypt cp;
 		cp.handle  = cpu_to_le16(conn->handle);
 		cp.encrypt = 0x01;
@@ -700,7 +700,7 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 		goto encrypt;
 
 auth:
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->flags))
 		return 0;
 
 	if (!hci_conn_auth(conn, sec_level, auth_type))
@@ -735,7 +735,7 @@ int hci_conn_change_link_key(struct hci_conn *conn)
 {
 	BT_DBG("conn %p", conn);
 
-	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->flags)) {
 		struct hci_cp_change_conn_link_key cp;
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_CHANGE_CONN_LINK_KEY,
@@ -754,7 +754,7 @@ int hci_conn_switch_role(struct hci_conn *conn, __u8 role)
 	if (!role && conn->link_mode & HCI_LM_MASTER)
 		return 1;
 
-	if (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->flags)) {
 		struct hci_cp_switch_role cp;
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.role = role;
@@ -781,7 +781,7 @@ void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 	if (!conn->power_save && !force_active)
 		goto timer;
 
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
+	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->flags)) {
 		struct hci_cp_exit_sniff_mode cp;
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(hdev, HCI_OP_EXIT_SNIFF_MODE, sizeof(cp), &cp);

commit f20d09d5f7093e5dc5f231c65835e2d04739bd5e
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Thu Dec 22 16:30:27 2011 -0200

    Bluetooth: remove *_bh usage from hci_dev_list and hci_cb_list
    
    They don't need to disable interrupts anymore, we only run in process
    context now.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 401d8ea266aa..3db432473ad5 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -487,7 +487,7 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 
 	BT_DBG("%s -> %s", batostr(src), batostr(dst));
 
-	read_lock_bh(&hci_dev_list_lock);
+	read_lock(&hci_dev_list_lock);
 
 	list_for_each_entry(d, &hci_dev_list, list) {
 		if (!test_bit(HCI_UP, &d->flags) || test_bit(HCI_RAW, &d->flags))
@@ -512,7 +512,7 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 	if (hdev)
 		hdev = hci_dev_hold(hdev);
 
-	read_unlock_bh(&hci_dev_list_lock);
+	read_unlock(&hci_dev_list_lock);
 	return hdev;
 }
 EXPORT_SYMBOL(hci_get_route);

commit 4b0b2f088f12e2ada1297502d7bebde182cf65b0
Merge: 4dad99928211 d7660918fce2
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Mon Dec 19 11:37:53 2011 -0200

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/padovan/bluetooth
    
    Conflicts:
            net/bluetooth/l2cap_core.c

commit d7660918fce210f421cc58c060ca3de71e4ffd37
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Sun Dec 18 22:33:30 2011 -0200

    Revert "Bluetooth: Revert: Fix L2CAP connection establishment"
    
    This reverts commit 4dff523a913197e3314c7b0d08734ab037709093.
    
    It was reported that this patch cause issues when trying to connect to
    legacy devices so reverting it.
    
    Reported-by: David Fries <david@fries.net>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e0af7237cd92..c1c597e3e198 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -673,7 +673,7 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 		goto encrypt;
 
 auth:
-	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
 		return 0;
 
 	if (!hci_conn_auth(conn, sec_level, auth_type))

commit 3c54711c4fd103edf2044ab60726939f1de02b0c
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 14 22:58:44 2011 -0200

    Bluetooth: Don't disable tasklets to call hdev->notify()
    
    It's pointless, we aren't protecting anything since btusb_notify()
    schedules a work to run, then all it operation happens without protection.
    If protection is really needed here, we will fix it further.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5e9e193ac71e..385cccbcafe0 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -419,11 +419,8 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	hci_dev_hold(hdev);
 
 	hci_conn_hash_add(hdev, conn);
-	if (hdev->notify) {
-		tasklet_disable(&hdev->tx_task);
+	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
-		tasklet_enable(&hdev->tx_task);
-	}
 
 	atomic_set(&conn->devref, 0);
 
@@ -468,11 +465,8 @@ int hci_conn_del(struct hci_conn *conn)
 	hci_chan_list_flush(conn);
 
 	hci_conn_hash_del(hdev, conn);
-	if (hdev->notify) {
-		tasklet_disable(&hdev->tx_task);
+	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
-		tasklet_enable(&hdev->tx_task);
-	}
 
 	skb_queue_purge(&conn->data_q);
 

commit bf4c63252490ba78fb833cc7acf1a5b1900c970f
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 14 22:54:12 2011 -0200

    Bluetooth: convert conn hash to RCU
    
    Handling hci_conn_hash with RCU make us avoid some locking and disable
    tasklets.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b04467674a13..5e9e193ac71e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -418,18 +418,17 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	hci_dev_hold(hdev);
 
-	tasklet_disable(&hdev->tx_task);
-
 	hci_conn_hash_add(hdev, conn);
-	if (hdev->notify)
+	if (hdev->notify) {
+		tasklet_disable(&hdev->tx_task);
 		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
+		tasklet_enable(&hdev->tx_task);
+	}
 
 	atomic_set(&conn->devref, 0);
 
 	hci_conn_init_sysfs(conn);
 
-	tasklet_enable(&hdev->tx_task);
-
 	return conn;
 }
 
@@ -465,15 +464,15 @@ int hci_conn_del(struct hci_conn *conn)
 		}
 	}
 
-	tasklet_disable(&hdev->tx_task);
 
 	hci_chan_list_flush(conn);
 
 	hci_conn_hash_del(hdev, conn);
-	if (hdev->notify)
+	if (hdev->notify) {
+		tasklet_disable(&hdev->tx_task);
 		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
-
-	tasklet_enable(&hdev->tx_task);
+		tasklet_enable(&hdev->tx_task);
+	}
 
 	skb_queue_purge(&conn->data_q);
 
@@ -808,7 +807,7 @@ void hci_conn_hash_flush(struct hci_dev *hdev)
 
 	BT_DBG("hdev %s", hdev->name);
 
-	list_for_each_entry(c, &h->list, list) {
+	list_for_each_entry_rcu(c, &h->list, list) {
 		c->state = BT_CLOSED;
 
 		hci_proto_disconn_cfm(c, HCI_ERROR_LOCAL_HOST_TERM);

commit 8192edef03f9b47f1cc1120724db525e63e218f3
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 14 15:08:48 2011 -0200

    Bluetooth: Use RCU to manipulate chan_list
    
    Instead of using tasklet_disable() to prevent acess to the channel use, we
    can use RCU and improve the performance of our code.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e6d8a220b5d9..b04467674a13 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -960,9 +960,7 @@ struct hci_chan *hci_chan_create(struct hci_conn *conn)
 	chan->conn = conn;
 	skb_queue_head_init(&chan->data_q);
 
-	tasklet_disable(&hdev->tx_task);
-	list_add(&conn->chan_list, &chan->list);
-	tasklet_enable(&hdev->tx_task);
+	list_add_rcu(&chan->list, &conn->chan_list);
 
 	return chan;
 }
@@ -974,9 +972,9 @@ int hci_chan_del(struct hci_chan *chan)
 
 	BT_DBG("%s conn %p chan %p", hdev->name, conn, chan);
 
-	tasklet_disable(&hdev->tx_task);
-	list_del(&chan->list);
-	tasklet_enable(&hdev->tx_task);
+	list_del_rcu(&chan->list);
+
+	synchronize_rcu();
 
 	skb_queue_purge(&chan->data_q);
 	kfree(chan);
@@ -986,10 +984,10 @@ int hci_chan_del(struct hci_chan *chan)
 
 void hci_chan_list_flush(struct hci_conn *conn)
 {
-	struct hci_chan *chan, *tmp;
+	struct hci_chan *chan;
 
 	BT_DBG("conn %p", conn);
 
-	list_for_each_entry_safe(chan, tmp, &conn->chan_list, list)
+	list_for_each_entry_rcu(chan, &conn->chan_list, list)
 		hci_chan_del(chan);
 }

commit b9cc553f12d14b692d0fcb607d28db783da68139
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Fri Jun 17 12:58:41 2011 -0300

    Bluetooth: hci_conn_auto_accept() doesn't need locking
    
    It doesn't really touch any sensitive information about hdev. So no need
    to lock here.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7d88a6142092..e6d8a220b5d9 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -362,12 +362,8 @@ static void hci_conn_auto_accept(unsigned long arg)
 	struct hci_conn *conn = (void *) arg;
 	struct hci_dev *hdev = conn->hdev;
 
-	hci_dev_lock(hdev);
-
 	hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),
 								&conn->dst);
-
-	hci_dev_unlock(hdev);
 }
 
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)

commit 19c40e3bcaf2d969f5d4ee85bbe1330b54d36d9c
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Fri Jun 17 13:03:21 2011 -0300

    Bluetooth: Use delayed_work for connection timeout
    
    Bluetooth rx task runs now in a workqueue, so it a good approach run any
    timer that share locking with process context code also in a workqueue.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index d45783de5e2a..7d88a6142092 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -275,9 +275,10 @@ void hci_sco_setup(struct hci_conn *conn, __u8 status)
 	}
 }
 
-static void hci_conn_timeout(unsigned long arg)
+static void hci_conn_timeout(struct work_struct *work)
 {
-	struct hci_conn *conn = (void *) arg;
+	struct hci_conn *conn = container_of(work, struct hci_conn,
+							disc_work.work);
 	struct hci_dev *hdev = conn->hdev;
 	__u8 reason;
 
@@ -412,7 +413,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	INIT_LIST_HEAD(&conn->chan_list);;
 
-	setup_timer(&conn->disc_timer, hci_conn_timeout, (unsigned long)conn);
+	INIT_DELAYED_WORK(&conn->disc_work, hci_conn_timeout);
 	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);
 	setup_timer(&conn->auto_accept_timer, hci_conn_auto_accept,
 							(unsigned long) conn);
@@ -444,7 +445,7 @@ int hci_conn_del(struct hci_conn *conn)
 
 	del_timer(&conn->idle_timer);
 
-	del_timer(&conn->disc_timer);
+	cancel_delayed_work_sync(&conn->disc_work);
 
 	del_timer(&conn->auto_accept_timer);
 

commit 09fd0de5bd8f8ef3317e5365f92f1a13dcd89aa9
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Fri Jun 17 13:03:21 2011 -0300

    Bluetooth: Replace spin_lock by mutex in hci_dev
    
    Now we run everything in HCI in process context, so it's a better idea use
    mutex instead spin_lock. The macro remains hci_dev_lock() (and I got rid
    of hci_dev_lock_bh()), of course.
    
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3131a99dd5f6..d45783de5e2a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -876,7 +876,7 @@ int hci_get_conn_list(void __user *arg)
 
 	ci = cl->conn_info;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	list_for_each_entry(c, &hdev->conn_hash.list, list) {
 		bacpy(&(ci + n)->bdaddr, &c->dst);
 		(ci + n)->handle = c->handle;
@@ -887,7 +887,7 @@ int hci_get_conn_list(void __user *arg)
 		if (++n >= req.conn_num)
 			break;
 	}
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	cl->dev_id = hdev->id;
 	cl->conn_num = n;
@@ -911,7 +911,7 @@ int hci_get_conn_info(struct hci_dev *hdev, void __user *arg)
 	if (copy_from_user(&req, arg, sizeof(req)))
 		return -EFAULT;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	conn = hci_conn_hash_lookup_ba(hdev, req.type, &req.bdaddr);
 	if (conn) {
 		bacpy(&ci.bdaddr, &conn->dst);
@@ -921,7 +921,7 @@ int hci_get_conn_info(struct hci_dev *hdev, void __user *arg)
 		ci.state = conn->state;
 		ci.link_mode = conn->link_mode;
 	}
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	if (!conn)
 		return -ENOENT;
@@ -937,11 +937,11 @@ int hci_get_auth_info(struct hci_dev *hdev, void __user *arg)
 	if (copy_from_user(&req, arg, sizeof(req)))
 		return -EFAULT;
 
-	hci_dev_lock_bh(hdev);
+	hci_dev_lock(hdev);
 	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);
 	if (conn)
 		req.type = conn->auth_type;
-	hci_dev_unlock_bh(hdev);
+	hci_dev_unlock(hdev);
 
 	if (!conn)
 		return -ENOENT;

commit 416dc94baa4a0de6904707d17522f7eae7778c8e
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 7 13:24:33 2011 -0200

    Bluetooth: make hci_conn_enter_sniff_mode static
    
    It isn't used outside hci_conn.c
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index dfe807fb7e79..3131a99dd5f6 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -311,6 +311,42 @@ static void hci_conn_timeout(unsigned long arg)
 	hci_dev_unlock(hdev);
 }
 
+/* Enter sniff mode */
+static void hci_conn_enter_sniff_mode(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("conn %p mode %d", conn, conn->mode);
+
+	if (test_bit(HCI_RAW, &hdev->flags))
+		return;
+
+	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
+		return;
+
+	if (conn->mode != HCI_CM_ACTIVE || !(conn->link_policy & HCI_LP_SNIFF))
+		return;
+
+	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
+		struct hci_cp_sniff_subrate cp;
+		cp.handle             = cpu_to_le16(conn->handle);
+		cp.max_latency        = cpu_to_le16(0);
+		cp.min_remote_timeout = cpu_to_le16(0);
+		cp.min_local_timeout  = cpu_to_le16(0);
+		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
+	}
+
+	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
+		struct hci_cp_sniff_mode cp;
+		cp.handle       = cpu_to_le16(conn->handle);
+		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
+		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
+		cp.attempt      = cpu_to_le16(4);
+		cp.timeout      = cpu_to_le16(1);
+		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
+	}
+}
+
 static void hci_conn_idle(unsigned long arg)
 {
 	struct hci_conn *conn = (void *) arg;
@@ -767,42 +803,6 @@ void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 			jiffies + msecs_to_jiffies(hdev->idle_timeout));
 }
 
-/* Enter sniff mode */
-void hci_conn_enter_sniff_mode(struct hci_conn *conn)
-{
-	struct hci_dev *hdev = conn->hdev;
-
-	BT_DBG("conn %p mode %d", conn, conn->mode);
-
-	if (test_bit(HCI_RAW, &hdev->flags))
-		return;
-
-	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
-		return;
-
-	if (conn->mode != HCI_CM_ACTIVE || !(conn->link_policy & HCI_LP_SNIFF))
-		return;
-
-	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
-		struct hci_cp_sniff_subrate cp;
-		cp.handle             = cpu_to_le16(conn->handle);
-		cp.max_latency        = cpu_to_le16(0);
-		cp.min_remote_timeout = cpu_to_le16(0);
-		cp.min_local_timeout  = cpu_to_le16(0);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
-	}
-
-	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
-		struct hci_cp_sniff_mode cp;
-		cp.handle       = cpu_to_le16(conn->handle);
-		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
-		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
-		cp.attempt      = cpu_to_le16(4);
-		cp.timeout      = cpu_to_le16(1);
-		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
-	}
-}
-
 /* Drop all connection on the device */
 void hci_conn_hash_flush(struct hci_dev *hdev)
 {

commit 3e9c40a6f72a4ee7a978204cac00f91ad08bbe9b
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 14 22:52:31 2011 -0200

    Bluetooth: Use list_for_each_entry in hci_conn_hash_flush()
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 1a076941829b..dfe807fb7e79 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -807,17 +807,11 @@ void hci_conn_enter_sniff_mode(struct hci_conn *conn)
 void hci_conn_hash_flush(struct hci_dev *hdev)
 {
 	struct hci_conn_hash *h = &hdev->conn_hash;
-	struct list_head *p;
+	struct hci_conn *c;
 
 	BT_DBG("hdev %s", hdev->name);
 
-	p = h->list.next;
-	while (p != &h->list) {
-		struct hci_conn *c;
-
-		c = list_entry(p, struct hci_conn, list);
-		p = p->next;
-
+	list_for_each_entry(c, &h->list, list) {
 		c->state = BT_CLOSED;
 
 		hci_proto_disconn_cfm(c, HCI_ERROR_LOCAL_HOST_TERM);

commit 2c33c06a8fd2f784ca763ad150d5d63c3c49946e
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Wed Dec 14 13:02:51 2011 -0200

    Bluetooth: remove struct hci_chan_hash
    
    Only the list member of the struct was used, so we now fold it into
    hci_conn.
    
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b328ac611ccd..1a076941829b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -374,7 +374,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	skb_queue_head_init(&conn->data_q);
 
-	hci_chan_hash_init(conn);
+	INIT_LIST_HEAD(&conn->chan_list);;
 
 	setup_timer(&conn->disc_timer, hci_conn_timeout, (unsigned long)conn);
 	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);
@@ -434,7 +434,7 @@ int hci_conn_del(struct hci_conn *conn)
 
 	tasklet_disable(&hdev->tx_task);
 
-	hci_chan_hash_flush(conn);
+	hci_chan_list_flush(conn);
 
 	hci_conn_hash_del(hdev, conn);
 	if (hdev->notify)
@@ -970,7 +970,7 @@ struct hci_chan *hci_chan_create(struct hci_conn *conn)
 	skb_queue_head_init(&chan->data_q);
 
 	tasklet_disable(&hdev->tx_task);
-	hci_chan_hash_add(conn, chan);
+	list_add(&conn->chan_list, &chan->list);
 	tasklet_enable(&hdev->tx_task);
 
 	return chan;
@@ -984,7 +984,7 @@ int hci_chan_del(struct hci_chan *chan)
 	BT_DBG("%s conn %p chan %p", hdev->name, conn, chan);
 
 	tasklet_disable(&hdev->tx_task);
-	hci_chan_hash_del(conn, chan);
+	list_del(&chan->list);
 	tasklet_enable(&hdev->tx_task);
 
 	skb_queue_purge(&chan->data_q);
@@ -993,13 +993,12 @@ int hci_chan_del(struct hci_chan *chan)
 	return 0;
 }
 
-void hci_chan_hash_flush(struct hci_conn *conn)
+void hci_chan_list_flush(struct hci_conn *conn)
 {
-	struct hci_chan_hash *h = &conn->chan_hash;
 	struct hci_chan *chan, *tmp;
 
 	BT_DBG("conn %p", conn);
 
-	list_for_each_entry_safe(chan, tmp, &h->list, list)
+	list_for_each_entry_safe(chan, tmp, &conn->chan_list, list)
 		hci_chan_del(chan);
 }

commit d095c1ebd43a43c1d78055ff111f464b04f8624e
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Thu Dec 1 14:33:27 2011 +0200

    Bluetooth: Remove magic bluetooth version numbers
    
    Use bluetooth names instead of BT SIG assigned numbers
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index de0b93e45980..b328ac611ccd 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -123,7 +123,7 @@ static void hci_acl_connect_cancel(struct hci_conn *conn)
 
 	BT_DBG("%p", conn);
 
-	if (conn->hdev->hci_ver < 2)
+	if (conn->hdev->hci_ver < BLUETOOTH_VER_1_2)
 		return;
 
 	bacpy(&cp.bdaddr, &conn->dst);

commit 312fef7d18adda2be822d31916547f84ed6af28b
Merge: 5e819059a20b 2aeabcbedd51
Author: John W. Linville <linville@tuxdriver.com>
Date:   Wed Nov 9 14:54:33 2011 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/padovan/bluetooth-next
    
    Conflicts:
            net/bluetooth/l2cap_sock.c
            net/bluetooth/mgmt.c

commit 9f5a0d7bf079e9e26771ad13ff1c2cb3adf80963
Author: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
Date:   Mon Nov 7 14:20:25 2011 +0200

    Bluetooth: Define HCI reasons instead of magic number
    
    Use HCI error reasons instead of magic numbers.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e545376379c5..ac943676f78d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -820,7 +820,7 @@ void hci_conn_hash_flush(struct hci_dev *hdev)
 
 		c->state = BT_CLOSED;
 
-		hci_proto_disconn_cfm(c, 0x16);
+		hci_proto_disconn_cfm(c, HCI_ERROR_LOCAL_HOST_TERM);
 		hci_conn_del(c);
 	}
 }

commit 73d80deb7bdf0171f22e76dc2429c1f99eff90e2
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Wed Nov 2 15:52:01 2011 +0200

    Bluetooth: prioritizing data over HCI
    
    This implement priority based scheduler using skbuffer priority set via
    SO_PRIORITY socket option.
    
    It introduces hci_chan_hash (list of HCI Channel/hci_chan) per connection,
    each item in this list refer to a L2CAP connection and it is used to
    queue the data for transmission.
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6e98ff3da2a4..e545376379c5 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -374,6 +374,8 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	skb_queue_head_init(&conn->data_q);
 
+	hci_chan_hash_init(conn);
+
 	setup_timer(&conn->disc_timer, hci_conn_timeout, (unsigned long)conn);
 	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);
 	setup_timer(&conn->auto_accept_timer, hci_conn_auto_accept,
@@ -432,6 +434,8 @@ int hci_conn_del(struct hci_conn *conn)
 
 	tasklet_disable(&hdev->tx_task);
 
+	hci_chan_hash_flush(conn);
+
 	hci_conn_hash_del(hdev, conn);
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
@@ -950,3 +954,52 @@ int hci_get_auth_info(struct hci_dev *hdev, void __user *arg)
 
 	return copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;
 }
+
+struct hci_chan *hci_chan_create(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_chan *chan;
+
+	BT_DBG("%s conn %p", hdev->name, conn);
+
+	chan = kzalloc(sizeof(struct hci_chan), GFP_ATOMIC);
+	if (!chan)
+		return NULL;
+
+	chan->conn = conn;
+	skb_queue_head_init(&chan->data_q);
+
+	tasklet_disable(&hdev->tx_task);
+	hci_chan_hash_add(conn, chan);
+	tasklet_enable(&hdev->tx_task);
+
+	return chan;
+}
+
+int hci_chan_del(struct hci_chan *chan)
+{
+	struct hci_conn *conn = chan->conn;
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("%s conn %p chan %p", hdev->name, conn, chan);
+
+	tasklet_disable(&hdev->tx_task);
+	hci_chan_hash_del(conn, chan);
+	tasklet_enable(&hdev->tx_task);
+
+	skb_queue_purge(&chan->data_q);
+	kfree(chan);
+
+	return 0;
+}
+
+void hci_chan_hash_flush(struct hci_conn *conn)
+{
+	struct hci_chan_hash *h = &conn->chan_hash;
+	struct hci_chan *chan, *tmp;
+
+	BT_DBG("conn %p", conn);
+
+	list_for_each_entry_safe(chan, tmp, &h->list, list)
+		hci_chan_del(chan);
+}

commit 8035ded466049ca2fe8c04564a0fa00f222abe3f
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Tue Nov 1 10:58:56 2011 +0200

    Bluetooth: replace list_for_each with list_for_each_entry whenever possible
    
    When all items in the list have the same type there is no much of a point
    to use list_for_each except if you want to use the list pointer itself.
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index c1c597e3e198..6e98ff3da2a4 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -453,16 +453,13 @@ int hci_conn_del(struct hci_conn *conn)
 struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 {
 	int use_src = bacmp(src, BDADDR_ANY);
-	struct hci_dev *hdev = NULL;
-	struct list_head *p;
+	struct hci_dev *hdev = NULL, *d;
 
 	BT_DBG("%s -> %s", batostr(src), batostr(dst));
 
 	read_lock_bh(&hci_dev_list_lock);
 
-	list_for_each(p, &hci_dev_list) {
-		struct hci_dev *d = list_entry(p, struct hci_dev, list);
-
+	list_for_each_entry(d, &hci_dev_list, list) {
 		if (!test_bit(HCI_UP, &d->flags) || test_bit(HCI_RAW, &d->flags))
 			continue;
 
@@ -855,10 +852,10 @@ EXPORT_SYMBOL(hci_conn_put_device);
 
 int hci_get_conn_list(void __user *arg)
 {
+	register struct hci_conn *c;
 	struct hci_conn_list_req req, *cl;
 	struct hci_conn_info *ci;
 	struct hci_dev *hdev;
-	struct list_head *p;
 	int n = 0, size, err;
 
 	if (copy_from_user(&req, arg, sizeof(req)))
@@ -882,10 +879,7 @@ int hci_get_conn_list(void __user *arg)
 	ci = cl->conn_info;
 
 	hci_dev_lock_bh(hdev);
-	list_for_each(p, &hdev->conn_hash.list) {
-		register struct hci_conn *c;
-		c = list_entry(p, struct hci_conn, list);
-
+	list_for_each_entry(c, &hdev->conn_hash.list, list) {
 		bacpy(&(ci + n)->bdaddr, &c->dst);
 		(ci + n)->handle = c->handle;
 		(ci + n)->type  = c->type;

commit 4dff523a913197e3314c7b0d08734ab037709093
Author: Arek Lichwa <arkadiusz.lichwa@tieto.com>
Date:   Wed Oct 26 11:23:22 2011 +0200

    Bluetooth: Revert: Fix L2CAP connection establishment
    
    This reverts commit 330605423ca6eafafb8dcc27502bce1c585d1b06.
    The commit introduces regression when two 2.1 devices attempt
    establish rfcomm channel. Such connection is refused since there's
    a security block issue on l2cap. It means the link is unencrypted.
    
    2011-09-16 18:08:46.567616 < ACL data: handle 1 flags 0x00 dlen 24
        0000: 14 00 40 00 06 00 02 00  0f 35 03 19 12 00 ff ff
    ..@......5....ËË
        0010: 35 05 0a 00 00 ff ff 00                           5....ËË.
    2011-09-16 18:08:46.572377 > HCI Event: Number of Completed Packets
    (0x13) plen 5
        handle 1 packets 1
    2011-09-16 18:08:46.577931 > ACL data: handle 1 flags 0x02 dlen 88
        L2CAP(d): cid 0x0040 len 84 [psm 0]
          0000: 07 00 02 00 4f 00 4c 35  4a 35 48 09 00 00 0a 00
    ....O.L5J5H.....
          0010: 01 00 00 09 00 01 35 03  19 12 00 09 00 05 35 03
    ......5.......5.
          0020: 19 10 02 09 00 09 35 08  35 06 19 12 00 09 01 02
    ......5.5.......
          0030: 09 02 00 09 01 02 09 02  01 09 00 0a 09 02 02 09
    ................
          0040: 00 00 09 02 03 09 00 00  09 02 04 28 01 09 02 05
    ...........(....
          0050: 09 00 02 00                                       ....
    2011-09-16 18:08:46.626057 < HCI Command: Authentication Requested
    (0x01|0x0011) plen 2
        handle 1
    2011-09-16 18:08:46.627614 > HCI Event: Command Status (0x0f) plen 4
        Authentication Requested (0x01|0x0011) status 0x00 ncmd 1
    2011-09-16 18:08:46.627675 > HCI Event: Link Key Request (0x17) plen 6
        bdaddr 00:00:F2:6A:29:69
    2011-09-16 18:08:46.634999 < HCI Command: Link Key Request Reply
    (0x01|0x000b) plen 22
        bdaddr 00:00:F2:6A:29:69 key 58CD393179FC902E5E8F512A855EE532
    2011-09-16 18:08:46.683278 > HCI Event: Command Complete (0x0e) plen 10
        Link Key Request Reply (0x01|0x000b) ncmd 1
        status 0x00 bdaddr 00:00:F2:6A:29:69
    2011-09-16 18:08:46.764729 > HCI Event: Auth Complete (0x06) plen 3
        status 0x00 handle 1
    2011-09-16 18:08:46.764821 < ACL data: handle 1 flags 0x00 dlen 12
        0000: 08 00 01 00 02 05 04 00  03 00 41 00              ..........A.
    2011-09-16 18:08:46.764851 > HCI Event: Command Status (0x0f) plen 4
        Unknown (0x00|0x0000) status 0x00 ncmd 2
    2011-09-16 18:08:46.768117 > HCI Event: Number of Completed Packets
    (0x13) plen 5
        handle 1 packets 1
    2011-09-16 18:08:46.770894 > ACL data: handle 1 flags 0x02 dlen 16
        L2CAP(s): Connect rsp: dcid 0x0000 scid 0x0041 result 3 status 0
          Connection refused - security block
    2011-09-16 18:08:49.000691 < ACL data: handle 1 flags 0x00 dlen 12
        0000: 08 00 01 00 06 06 04 00  40 00 40 00              ........@.@.
    2011-09-16 18:08:49.015675 > HCI Event: Number of Completed Packets
    (0x13) plen 5
        handle 1 packets 1
    2011-09-16 18:08:49.016927 > ACL data: handle 1 flags 0x02 dlen 12
        L2CAP(s): Disconn rsp: dcid 0x0040 scid 0x0040
    2011-09-16 18:08:51.009480 < HCI Command: Disconnect (0x01|0x0006) plen
    3
        handle 1 reason 0x13
        Reason: Remote User Terminated Connection
    2011-09-16 18:08:51.011525 > HCI Event: Command Status (0x0f) plen 4
        Disconnect (0x01|0x0006) status 0x00 ncmd 1
    2011-09-16 18:08:51.123494 > HCI Event: Disconn Complete (0x05) plen 4
        status 0x00 handle 1 reason 0x16
        Reason: Connection Terminated by Local Host
    
    Signed-off-by: Arek Lichwa <arkadiusz.lichwa@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index c1c597e3e198..e0af7237cd92 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -673,7 +673,7 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 		goto encrypt;
 
 auth:
-	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
 		return 0;
 
 	if (!hci_conn_auth(conn, sec_level, auth_type))

commit 0e8339151fa85cb9b088abfb13e2dd5214a25429
Author: Anderson Lizardo <anderson.lizardo@openbossa.org>
Date:   Wed Jul 27 18:40:09 2011 -0300

    Bluetooth: use recommended LE connection parameters
    
    The new connection parameters now match the recommended values for
    Proximity and Health Thermometer profiles. The previous values were
    ramdomly chosen, and are either too low or too high for most cases.
    
    New values:
    
    Scan Interval: 60 ms
    Scan Window: 30 ms
    Minimum Connection Interval: 50 ms
    Maximum Connection Interval: 70 ms
    Supervision Timeout: 420 ms
    
    See "Table 5.2: Recommended Scan Interval and Scan Window Values" and
    "Table 5.3: Recommended Connection Interval Values" for both profiles
    for details. Note that the "fast connection" parameters were chosen,
    because we do not support yet dynamically changing these parameters from
    initiator side.
    
    Additionally, the Proximity profile recommends (section "4.4 Alert on
    Link Loss"):
    
    "It is recommended that the Link Supervision Timeout (LSTO) is set to 6x
    the connection interval."
    
    Minimum_CE_Length and Maximum_CE_Length were also changed from 0x0001 to
    0x0000 because they are informational and optional, and old value was
    not reflecting reality.
    
    Signed-off-by: Anderson Lizardo <anderson.lizardo@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index c2df7bf1d374..c1c597e3e198 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -56,15 +56,15 @@ static void hci_le_connect(struct hci_conn *conn)
 	conn->sec_level = BT_SECURITY_LOW;
 
 	memset(&cp, 0, sizeof(cp));
-	cp.scan_interval = cpu_to_le16(0x0004);
-	cp.scan_window = cpu_to_le16(0x0004);
+	cp.scan_interval = cpu_to_le16(0x0060);
+	cp.scan_window = cpu_to_le16(0x0030);
 	bacpy(&cp.peer_addr, &conn->dst);
 	cp.peer_addr_type = conn->dst_type;
-	cp.conn_interval_min = cpu_to_le16(0x0008);
-	cp.conn_interval_max = cpu_to_le16(0x0100);
-	cp.supervision_timeout = cpu_to_le16(0x0064);
-	cp.min_ce_len = cpu_to_le16(0x0001);
-	cp.max_ce_len = cpu_to_le16(0x0001);
+	cp.conn_interval_min = cpu_to_le16(0x0028);
+	cp.conn_interval_max = cpu_to_le16(0x0038);
+	cp.supervision_timeout = cpu_to_le16(0x002a);
+	cp.min_ce_len = cpu_to_le16(0x0000);
+	cp.max_ce_len = cpu_to_le16(0x0000);
 
 	hci_send_cmd(hdev, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
 }

commit 51beabdf624df14d0805b001d3f939629b70d9db
Author: Anderson Briglia <anderson.briglia@openbossa.org>
Date:   Mon Sep 19 14:41:09 2011 -0400

    Bluetooth: Fix wrong memcpy size on LE start encryption
    
    This patch fixes wrong memcpy size when copying rand value to
    HCI_OP_LE_START_ENC command.
    The compiler pretends that the array parameter was declared as a pointer
    and sizeof reports the size of the pointer. [1]
    
    [1] http://www.c-faq.com/aryptr/aryparmsize.html
    
    Signed-off-by: Anderson Briglia <anderson.briglia@openbossa.org>
    Signed-off-by: Anderson Lizardo <anderson.lizardo@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ea7f031f3b04..c2df7bf1d374 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -218,7 +218,7 @@ void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
 	cp.handle = cpu_to_le16(conn->handle);
 	memcpy(cp.ltk, ltk, sizeof(cp.ltk));
 	cp.ediv = ediv;
-	memcpy(cp.rand, rand, sizeof(rand));
+	memcpy(cp.rand, rand, sizeof(cp.rand));
 
 	hci_send_cmd(hdev, HCI_OP_LE_START_ENC, sizeof(cp), &cp);
 }

commit 6a7ebdf2fd15417e87b4fd02ff411aeaca34da5f
Merge: f6b72b6217f8 51414d410844
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jul 14 07:56:40 2011 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            net/bluetooth/l2cap_core.c

commit 163f4dabea4e3be485c17e8f08e3a6468ad31cbf
Author: Tomas Targownik <ttargownik@geicp.com>
Date:   Thu Jun 30 16:30:44 2011 -0300

    Bluetooth: Fix memory leak under page timeouts
    
    If the remote device is not present, the connections attemp fails and
    the struct hci_conn was not freed
    
    Signed-off-by: Tomas Targownik <ttargownik@geicp.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index d3a05b9ade7a..bcd158f40bb9 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -393,6 +393,9 @@ int hci_conn_del(struct hci_conn *conn)
 
 	hci_dev_put(hdev);
 
+	if (conn->handle == 0)
+		kfree(conn);
+
 	return 0;
 }
 

commit 0555891184a5c18df0e2349872e7ecf9701fc5b5
Merge: e13e21dc5d06 330605423ca6
Author: Gustavo F. Padovan <padovan@profusion.mobi>
Date:   Tue Jun 21 14:52:56 2011 -0300

    Merge master.kernel.org:/pub/scm/linux/kernel/git/padovan/bluetooth-2.6
    
    Conflicts:
            net/bluetooth/l2cap_core.c

commit 330605423ca6eafafb8dcc27502bce1c585d1b06
Author: Ilia Kolomisnky <ilia.kolominsky@gmail.com>
Date:   Wed Jun 15 06:52:26 2011 +0300

    Bluetooth: Fix L2CAP connection establishment
    
    In hci_conn_security ( which is used during L2CAP connection
    establishment ) test for HCI_CONN_ENCRYPT_PEND state also
    sets this state, which is bogus and leads to connection time-out
    on L2CAP sockets in certain situations (especially when
    using non-ssp devices )
    
    Signed-off-by: Ilia Kolomisnky <iliak@ti.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b9aa9862d14b..d3a05b9ade7a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -608,7 +608,7 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 		goto encrypt;
 
 auth:
-	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+	if (test_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
 		return 0;
 
 	if (!hci_conn_auth(conn, sec_level, auth_type))

commit 7b5c0d5242295a3b52e7161bf129e2f0e8c624cb
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Jun 9 18:50:50 2011 -0300

    Bluetooth: Fix initial security level of LE links
    
    As the default security level (BT_SECURITY_SDP) doesn't make sense for
    LE links, initialize LE links with something that makes sense.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 18193831bbf1..2f5ae53057c7 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -53,6 +53,7 @@ static void hci_le_connect(struct hci_conn *conn)
 	conn->state = BT_CONNECT;
 	conn->out = 1;
 	conn->link_mode |= HCI_LM_MASTER;
+	conn->sec_level = BT_SECURITY_LOW;
 
 	memset(&cp, 0, sizeof(cp));
 	cp.scan_interval = cpu_to_le16(0x0004);

commit a7a595f675f1b33dc73167147321dba5c4395acc
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Jun 9 18:50:47 2011 -0300

    Bluetooth: Add support for LE Start Encryption
    
    This adds support for starting SMP Phase 2 Encryption, when the initial
    SMP negotiation is successful. This adds the LE Start Encryption and LE
    Long Term Key Request commands and related events.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 37f5a174f072..18193831bbf1 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -204,6 +204,55 @@ void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
 }
 EXPORT_SYMBOL(hci_le_conn_update);
 
+void hci_le_start_enc(struct hci_conn *conn, __le16 ediv, __u8 rand[8],
+							__u8 ltk[16])
+{
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_cp_le_start_enc cp;
+
+	BT_DBG("%p", conn);
+
+	memset(&cp, 0, sizeof(cp));
+
+	cp.handle = cpu_to_le16(conn->handle);
+	memcpy(cp.ltk, ltk, sizeof(cp.ltk));
+	cp.ediv = ediv;
+	memcpy(cp.rand, rand, sizeof(rand));
+
+	hci_send_cmd(hdev, HCI_OP_LE_START_ENC, sizeof(cp), &cp);
+}
+EXPORT_SYMBOL(hci_le_start_enc);
+
+void hci_le_ltk_reply(struct hci_conn *conn, u8 ltk[16])
+{
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_cp_le_ltk_reply cp;
+
+	BT_DBG("%p", conn);
+
+	memset(&cp, 0, sizeof(cp));
+
+	cp.handle = cpu_to_le16(conn->handle);
+	memcpy(cp.ltk, ltk, sizeof(ltk));
+
+	hci_send_cmd(hdev, HCI_OP_LE_LTK_REPLY, sizeof(cp), &cp);
+}
+EXPORT_SYMBOL(hci_le_ltk_reply);
+
+void hci_le_ltk_neg_reply(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_cp_le_ltk_neg_reply cp;
+
+	BT_DBG("%p", conn);
+
+	memset(&cp, 0, sizeof(cp));
+
+	cp.handle = cpu_to_le16(conn->handle);
+
+	hci_send_cmd(hdev, HCI_OP_LE_LTK_NEG_REPLY, sizeof(cp), &cp);
+}
+
 /* Device _must_ be locked */
 void hci_sco_setup(struct hci_conn *conn, __u8 status)
 {

commit 6fdf658c9a0e51e6663f2769f6d310c2843a862b
Author: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
Date:   Mon Jun 13 15:37:35 2011 +0300

    Bluetooth: Fix L2CAP security check
    
    With older userspace versions (using hciops) it might not have the
    key type to check if the key has sufficient security for any security
    level so it is necessary to check the return of hci_conn_auth to make
    sure the connection is authenticated
    
    Signed-off-by: Luiz Augusto von Dentz <luiz.von.dentz@intel.com>
    Acked-by: Johan Hedberg <johan.hedberg@intel.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3163330cd4f1..b9aa9862d14b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -611,8 +611,8 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
 		return 0;
 
-	hci_conn_auth(conn, sec_level, auth_type);
-	return 0;
+	if (!hci_conn_auth(conn, sec_level, auth_type))
+		return 0;
 
 encrypt:
 	if (conn->link_mode & HCI_LM_ENCRYPT)

commit ef4177e2bf92543e422fae154888062376e2283d
Author: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
Date:   Thu Jun 2 14:24:52 2011 +0200

    Bluetooth: Simplify hci_conn_accept_secure check
    
    If the link key is secure (authenticated or combination 16 digit)
    the sec_level will be always BT_SECURITY_HIGH. Therefore, instead
    of checking the link key type simply check the sec_level on the link.
    
    Signed-off-by: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 0408a93570d6..37f5a174f072 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -643,9 +643,7 @@ int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)
 	if (sec_level != BT_SECURITY_HIGH)
 		return 1; /* Accept if non-secure is required */
 
-	if (conn->key_type == HCI_LK_AUTH_COMBINATION ||
-			(conn->key_type == HCI_LK_COMBINATION &&
-			conn->pin_length == 16))
+	if (conn->sec_level == BT_SECURITY_HIGH)
 		return 1;
 
 	return 0; /* Reject not secure link */

commit 14b12d0b98f87162b7e9e93dde66d1af97886567
Author: Jaikumar Ganesh <jaikumar@google.com>
Date:   Mon May 23 18:06:04 2011 -0700

    Bluetooth: Add BT_POWER L2CAP socket option.
    
    Add BT_POWER socket option used to control the power
    characteristics of the underlying ACL link. When the remote end
    has put the link in sniff mode and the host stack wants to send
    data we need need to explicitly exit sniff mode to work well with
    certain devices (For example, A2DP on Plantronics Voyager 855).
    However, this causes problems with HID devices.
    
    Hence, moving into active mode when sending data, irrespective
    of who set the sniff mode has been made as a socket option. By
    default, we will move into active mode. HID devices can set the
    L2CAP socket option to prevent this from happening.
    
    Currently, this has been implemented for L2CAP sockets. This has been
    tested with incoming and outgoing L2CAP sockets for HID and A2DP.
    
    Based on discussions on linux-bluetooth and patches submitted by
    Andrei Emeltchenko.
    
    Signed-off-by: Jaikumar Ganesh <jaikumar@google.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ce67d0ff486f..0408a93570d6 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -507,7 +507,7 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 	if (acl->state == BT_CONNECTED &&
 			(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
 		acl->power_save = 1;
-		hci_conn_enter_active_mode(acl);
+		hci_conn_enter_active_mode(acl, BT_POWER_FORCE_ACTIVE_ON);
 
 		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->pend)) {
 			/* defer SCO setup until mode change completed */
@@ -688,7 +688,7 @@ int hci_conn_switch_role(struct hci_conn *conn, __u8 role)
 EXPORT_SYMBOL(hci_conn_switch_role);
 
 /* Enter active mode */
-void hci_conn_enter_active_mode(struct hci_conn *conn)
+void hci_conn_enter_active_mode(struct hci_conn *conn, __u8 force_active)
 {
 	struct hci_dev *hdev = conn->hdev;
 
@@ -697,7 +697,10 @@ void hci_conn_enter_active_mode(struct hci_conn *conn)
 	if (test_bit(HCI_RAW, &hdev->flags))
 		return;
 
-	if (conn->mode != HCI_CM_SNIFF || !conn->power_save)
+	if (conn->mode != HCI_CM_SNIFF)
+		goto timer;
+
+	if (!conn->power_save && !force_active)
 		goto timer;
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {

commit 6d3ce0e7902314ddb330deaf8827205881d7e59f
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue May 31 14:20:57 2011 -0300

    Bluetooth: Set 'peer_addr_type' in hci_le_connect()
    
    Set the 'peer_addr_type' field of the LE Create Connection command
    sent in hci_le_connect().
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Ville Tervo <ville.tervo@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 4e38b4872865..ce67d0ff486f 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -58,6 +58,7 @@ static void hci_le_connect(struct hci_conn *conn)
 	cp.scan_interval = cpu_to_le16(0x0004);
 	cp.scan_window = cpu_to_le16(0x0004);
 	bacpy(&cp.peer_addr, &conn->dst);
+	cp.peer_addr_type = conn->dst_type;
 	cp.conn_interval_min = cpu_to_le16(0x0008);
 	cp.conn_interval_max = cpu_to_le16(0x0100);
 	cp.supervision_timeout = cpu_to_le16(0x0064);

commit eda42b503a3c866d51146549fe46da1f5f64e2c7
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue May 31 14:20:56 2011 -0300

    Bluetooth: Check advertising cache in hci_connect()
    
    When connecting to a LE device, we need to check the advertising
    cache in order to know the address type of that device.
    
    If its advertising entry is not found, the connection is not
    established and hci_connect() returns error.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Ville Tervo <ville.tervo@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ca283a0f63ea..4e38b4872865 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -447,13 +447,22 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
 	if (type == LE_LINK) {
+		struct adv_entry *entry;
+
 		le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
 		if (le)
 			return ERR_PTR(-EBUSY);
+
+		entry = hci_find_adv_entry(hdev, dst);
+		if (!entry)
+			return ERR_PTR(-EHOSTUNREACH);
+
 		le = hci_conn_add(hdev, LE_LINK, dst);
 		if (!le)
 			return ERR_PTR(-ENOMEM);
 
+		le->dst_type = entry->bdaddr_type;
+
 		hci_le_connect(le);
 
 		hci_conn_hold(le);

commit 893d67514aebcfd3ebf17bd212ceea1e2741a443
Author: Andre Guedes <andre.guedes@openbossa.org>
Date:   Tue May 31 14:20:55 2011 -0300

    Bluetooth: Remove useless check in hci_connect()
    
    There is no need to check the connection's state since hci_conn_add()
    has just created a new connection and its state has been set properly.
    
    Signed-off-by: Andre Guedes <andre.guedes@openbossa.org>
    Acked-by: Ville Tervo <ville.tervo@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e67540216cd4..ca283a0f63ea 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -453,8 +453,8 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 		le = hci_conn_add(hdev, LE_LINK, dst);
 		if (!le)
 			return ERR_PTR(-ENOMEM);
-		if (le->state == BT_OPEN)
-			hci_le_connect(le);
+
+		hci_le_connect(le);
 
 		hci_conn_hold(le);
 

commit 19f8def031bfa50c579149b200bfeeb919727b27
Author: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
Date:   Tue May 31 15:49:25 2011 +0200

    Bluetooth: Fix auth_complete_evt for legacy units
    
    Legacy devices don't re-authenticate the link properly if a link key
    already exists.  Thus, don't update sec_level for this case even if
    hci_auth_complete_evt indicates success. Otherwise the sec_level will
    not reflect a real security on the link.
    
    Signed-off-by: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 3163330cd4f1..e67540216cd4 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -548,6 +548,8 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
 							sizeof(cp), &cp);
+		if (conn->key_type != 0xff)
+			set_bit(HCI_CONN_REAUTH_PEND, &conn->pend);
 	}
 
 	return 0;

commit b3b1b061583ba4909b59a2f736825d86495fe956
Author: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
Date:   Fri May 6 09:42:31 2011 +0200

    Bluetooth: Double check sec req for pre 2.1 device
    
    In case of pre v2.1 devices authentication request will return
    success immediately if the link key already exists without any
    authentication process.
    
    That means, it's not possible to re-authenticate the link if you
    already have combination key and for instance want to re-authenticate
    to get the high security (use 16 digit pin).
    
    Therefore, it's necessary to check security requirements on auth
    complete event to prevent not enough secure connection.
    
    Signed-off-by: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7f5ad8a2b22d..3163330cd4f1 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -623,6 +623,23 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 }
 EXPORT_SYMBOL(hci_conn_security);
 
+/* Check secure link requirement */
+int hci_conn_check_secure(struct hci_conn *conn, __u8 sec_level)
+{
+	BT_DBG("conn %p", conn);
+
+	if (sec_level != BT_SECURITY_HIGH)
+		return 1; /* Accept if non-secure is required */
+
+	if (conn->key_type == HCI_LK_AUTH_COMBINATION ||
+			(conn->key_type == HCI_LK_COMBINATION &&
+			conn->pin_length == 16))
+		return 1;
+
+	return 0; /* Reject not secure link */
+}
+EXPORT_SYMBOL(hci_conn_check_secure);
+
 /* Change link key */
 int hci_conn_change_link_key(struct hci_conn *conn)
 {

commit 9f61656a60c9506e3e4cd41af5efbcf6a30ee3b9
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Thu Apr 28 11:28:54 2011 -0700

    Bluetooth: Add variable SSP auto-accept delay support
    
    Some test systems require an arbitrary delay to the auto-accept test
    cases for Secure Simple Pairing in order for the tests to pass.
    Previously when this was handled in user space it was worked around by
    code modifications and recompilation, but now that it's on the kernel
    side it's more convenient if there's a debugfs interface for it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 74cd755b38a7..7f5ad8a2b22d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -269,6 +269,19 @@ static void hci_conn_idle(unsigned long arg)
 	hci_conn_enter_sniff_mode(conn);
 }
 
+static void hci_conn_auto_accept(unsigned long arg)
+{
+	struct hci_conn *conn = (void *) arg;
+	struct hci_dev *hdev = conn->hdev;
+
+	hci_dev_lock(hdev);
+
+	hci_send_cmd(hdev, HCI_OP_USER_CONFIRM_REPLY, sizeof(conn->dst),
+								&conn->dst);
+
+	hci_dev_unlock(hdev);
+}
+
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 {
 	struct hci_conn *conn;
@@ -312,6 +325,8 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	setup_timer(&conn->disc_timer, hci_conn_timeout, (unsigned long)conn);
 	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);
+	setup_timer(&conn->auto_accept_timer, hci_conn_auto_accept,
+							(unsigned long) conn);
 
 	atomic_set(&conn->refcnt, 0);
 
@@ -342,6 +357,8 @@ int hci_conn_del(struct hci_conn *conn)
 
 	del_timer(&conn->disc_timer);
 
+	del_timer(&conn->auto_accept_timer);
+
 	if (conn->type == ACL_LINK) {
 		struct hci_conn *sco = conn->link;
 		if (sco)

commit 13d39315c22b128f4796fc008b04914a7c32bb1a
Author: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
Date:   Thu Apr 28 12:07:55 2011 +0200

    Bluetooth: Map sec_level to link key requirements
    
    Keep the link key type together with connection and use it to
    map security level to link key requirements. Authenticate and/or
    encrypt connection if the link is insufficiently secure.
    
    Signed-off-by: Waldemar Rymarkiewicz <waldemar.rymarkiewicz@tieto.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7a6f56b2f49d..74cd755b38a7 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -287,6 +287,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	conn->auth_type = HCI_AT_GENERAL_BONDING;
 	conn->io_capability = hdev->io_capability;
 	conn->remote_auth = 0xff;
+	conn->key_type = 0xff;
 
 	conn->power_save = 1;
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
@@ -535,32 +536,72 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 	return 0;
 }
 
+/* Encrypt the the link */
+static void hci_conn_encrypt(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
+
+	if (!test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend)) {
+		struct hci_cp_set_conn_encrypt cp;
+		cp.handle  = cpu_to_le16(conn->handle);
+		cp.encrypt = 0x01;
+		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp),
+									&cp);
+	}
+}
+
 /* Enable security */
 int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
 	BT_DBG("conn %p", conn);
 
+	/* For sdp we don't need the link key. */
 	if (sec_level == BT_SECURITY_SDP)
 		return 1;
 
+	/* For non 2.1 devices and low security level we don't need the link
+	   key. */
 	if (sec_level == BT_SECURITY_LOW &&
 				(!conn->ssp_mode || !conn->hdev->ssp_mode))
 		return 1;
 
-	if (conn->link_mode & HCI_LM_ENCRYPT)
-		return hci_conn_auth(conn, sec_level, auth_type);
-
+	/* For other security levels we need the link key. */
+	if (!(conn->link_mode & HCI_LM_AUTH))
+		goto auth;
+
+	/* An authenticated combination key has sufficient security for any
+	   security level. */
+	if (conn->key_type == HCI_LK_AUTH_COMBINATION)
+		goto encrypt;
+
+	/* An unauthenticated combination key has sufficient security for
+	   security level 1 and 2. */
+	if (conn->key_type == HCI_LK_UNAUTH_COMBINATION &&
+			(sec_level == BT_SECURITY_MEDIUM ||
+			sec_level == BT_SECURITY_LOW))
+		goto encrypt;
+
+	/* A combination key has always sufficient security for the security
+	   levels 1 or 2. High security level requires the combination key
+	   is generated using maximum PIN code length (16).
+	   For pre 2.1 units. */
+	if (conn->key_type == HCI_LK_COMBINATION &&
+			(sec_level != BT_SECURITY_HIGH ||
+			conn->pin_length == 16))
+		goto encrypt;
+
+auth:
 	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
 		return 0;
 
-	if (hci_conn_auth(conn, sec_level, auth_type)) {
-		struct hci_cp_set_conn_encrypt cp;
-		cp.handle  = cpu_to_le16(conn->handle);
-		cp.encrypt = 1;
-		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT,
-							sizeof(cp), &cp);
-	}
+	hci_conn_auth(conn, sec_level, auth_type);
+	return 0;
+
+encrypt:
+	if (conn->link_mode & HCI_LM_ENCRYPT)
+		return 1;
 
+	hci_conn_encrypt(conn);
 	return 0;
 }
 EXPORT_SYMBOL(hci_conn_security);

commit 30e7627219f985cd17a1ac24e0163ebcfb1277bf
Author: Ville Tervo <ville.tervo@nokia.com>
Date:   Tue Feb 22 16:10:53 2011 -0300

    Bluetooth: Use ERR_PTR as return error from hci_connect
    
    Use ERR_PTR mechanism to return error from hci_connect.
    
    Signed-off-by: Ville Tervo <ville.tervo@nokia.com>
    Signed-off-by: Anderson Briglia <anderson.briglia@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 4504cb6af6ae..7a6f56b2f49d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -431,10 +431,10 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 	if (type == LE_LINK) {
 		le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
 		if (le)
-			return NULL;
+			return ERR_PTR(-EBUSY);
 		le = hci_conn_add(hdev, LE_LINK, dst);
 		if (!le)
-			return NULL;
+			return ERR_PTR(-ENOMEM);
 		if (le->state == BT_OPEN)
 			hci_le_connect(le);
 

commit 15c4794fe247d85ce38eb5f5e2a5855d996f56cd
Author: Anderson Briglia <anderson.briglia@openbossa.org>
Date:   Mon Feb 21 15:09:23 2011 -0300

    Bluetooth: Fix LE conn creation
    
    This patch prevents a crash when remote host tries to create a LE
    link which already exists. i.e.: call l2test twice passing the
    same parameters.
    
    Signed-off-by: Anderson Briglia <anderson.briglia@openbossa.org>
    Signed-off-by: Ville Tervo <ville.tervo@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6d8b988d9ef6..4504cb6af6ae 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -430,8 +430,9 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 
 	if (type == LE_LINK) {
 		le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
-		if (!le)
-			le = hci_conn_add(hdev, LE_LINK, dst);
+		if (le)
+			return NULL;
+		le = hci_conn_add(hdev, LE_LINK, dst);
 		if (!le)
 			return NULL;
 		if (le->state == BT_OPEN)

commit a958355699dd90ba69951bdf55dda00e3e97222c
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Sat Feb 19 12:06:01 2011 -0300

    Bluetooth: Fix inititial value for remote authentication requirements
    
    The remote authentication requirements for conections need to be
    initialized to 0xff (unknown) since it is possible that we receive a IO
    Capability Request before we have received information about the remote
    requirements.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a050a6984901..6d8b988d9ef6 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -286,6 +286,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	conn->state = BT_OPEN;
 	conn->auth_type = HCI_AT_GENERAL_BONDING;
 	conn->io_capability = hdev->io_capability;
+	conn->remote_auth = 0xff;
 
 	conn->power_save = 1;
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;

commit 2ce603ebe1f1420c7c5b013638ec29b4fc975180
Author: Claudio Takahasi <claudio.takahasi@openbossa.org>
Date:   Wed Feb 16 20:44:53 2011 -0200

    Bluetooth: Send LE Connection Update Command
    
    If the new connection update parameter are accepted, the LE master
    host sends the LE Connection Update Command to its controller informing
    the new requested parameters.
    
    Signed-off-by: Claudio Takahasi <claudio.takahasi@openbossa.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index efcd2b508f5d..a050a6984901 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -183,6 +183,26 @@ void hci_setup_sync(struct hci_conn *conn, __u16 handle)
 	hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp);
 }
 
+void hci_le_conn_update(struct hci_conn *conn, u16 min, u16 max,
+					u16 latency, u16 to_multiplier)
+{
+	struct hci_cp_le_conn_update cp;
+	struct hci_dev *hdev = conn->hdev;
+
+	memset(&cp, 0, sizeof(cp));
+
+	cp.handle		= cpu_to_le16(conn->handle);
+	cp.conn_interval_min	= cpu_to_le16(min);
+	cp.conn_interval_max	= cpu_to_le16(max);
+	cp.conn_latency		= cpu_to_le16(latency);
+	cp.supervision_timeout	= cpu_to_le16(to_multiplier);
+	cp.min_ce_len		= cpu_to_le16(0x0001);
+	cp.max_ce_len		= cpu_to_le16(0x0001);
+
+	hci_send_cmd(hdev, HCI_OP_LE_CONN_UPDATE, sizeof(cp), &cp);
+}
+EXPORT_SYMBOL(hci_le_conn_update);
+
 /* Device _must_ be locked */
 void hci_sco_setup(struct hci_conn *conn, __u8 status)
 {

commit b92a62238ff2d3fb88cf0f6de454f3d1b4ae5d52
Author: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
Date:   Thu Feb 10 22:38:52 2011 -0300

    Bluetooth: Fix initiated LE connections
    
    Fix LE connections not being marked as master.
    
    Signed-off-by: Vinicius Costa Gomes <vinicius.gomes@openbossa.org>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index aecd78e6cceb..efcd2b508f5d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -52,6 +52,7 @@ static void hci_le_connect(struct hci_conn *conn)
 
 	conn->state = BT_CONNECT;
 	conn->out = 1;
+	conn->link_mode |= HCI_LM_MASTER;
 
 	memset(&cp, 0, sizeof(cp));
 	cp.scan_interval = cpu_to_le16(0x0004);

commit 6ed58ec520ad2b2fe3f955c8a5fd0eecafccebdf
Author: Ville Tervo <ville.tervo@nokia.com>
Date:   Thu Feb 10 22:38:48 2011 -0300

    Bluetooth: Use LE buffers for LE traffic
    
    Bluetooth chips may have separate buffers for LE traffic.
    This patch add support to use LE buffers provided by the chip.
    
    Signed-off-by: Ville Tervo <ville.tervo@nokia.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index d0c470c18f9d..aecd78e6cceb 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -326,6 +326,11 @@ int hci_conn_del(struct hci_conn *conn)
 
 		/* Unacked frames */
 		hdev->acl_cnt += conn->sent;
+	} else if (conn->type == LE_LINK) {
+		if (hdev->le_pkts)
+			hdev->le_cnt += conn->sent;
+		else
+			hdev->acl_cnt += conn->sent;
 	} else {
 		struct hci_conn *acl = conn->link;
 		if (acl) {

commit fcd89c09a59a054fb986861e0862aa2fff7d7c40
Author: Ville Tervo <ville.tervo@nokia.com>
Date:   Thu Feb 10 22:38:47 2011 -0300

    Bluetooth: Add LE connect support
    
    Bluetooth V4.0 adds support for Low Energy (LE) connections.
    Specification introduces new set of hci commands to control LE
    connection. This patch adds logic to create, cancel and disconnect
    LE connections.
    
    Signed-off-by: Ville Tervo <ville.tervo@nokia.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 42dc39f25b72..d0c470c18f9d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -45,6 +45,32 @@
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
+static void hci_le_connect(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_cp_le_create_conn cp;
+
+	conn->state = BT_CONNECT;
+	conn->out = 1;
+
+	memset(&cp, 0, sizeof(cp));
+	cp.scan_interval = cpu_to_le16(0x0004);
+	cp.scan_window = cpu_to_le16(0x0004);
+	bacpy(&cp.peer_addr, &conn->dst);
+	cp.conn_interval_min = cpu_to_le16(0x0008);
+	cp.conn_interval_max = cpu_to_le16(0x0100);
+	cp.supervision_timeout = cpu_to_le16(0x0064);
+	cp.min_ce_len = cpu_to_le16(0x0001);
+	cp.max_ce_len = cpu_to_le16(0x0001);
+
+	hci_send_cmd(hdev, HCI_OP_LE_CREATE_CONN, sizeof(cp), &cp);
+}
+
+static void hci_le_connect_cancel(struct hci_conn *conn)
+{
+	hci_send_cmd(conn->hdev, HCI_OP_LE_CREATE_CONN_CANCEL, 0, NULL);
+}
+
 void hci_acl_connect(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
@@ -193,8 +219,12 @@ static void hci_conn_timeout(unsigned long arg)
 	switch (conn->state) {
 	case BT_CONNECT:
 	case BT_CONNECT2:
-		if (conn->type == ACL_LINK && conn->out)
-			hci_acl_connect_cancel(conn);
+		if (conn->out) {
+			if (conn->type == ACL_LINK)
+				hci_acl_connect_cancel(conn);
+			else if (conn->type == LE_LINK)
+				hci_le_connect_cancel(conn);
+		}
 		break;
 	case BT_CONFIG:
 	case BT_CONNECTED:
@@ -361,15 +391,30 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 }
 EXPORT_SYMBOL(hci_get_route);
 
-/* Create SCO or ACL connection.
+/* Create SCO, ACL or LE connection.
  * Device _must_ be locked */
 struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type)
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
+	struct hci_conn *le;
 
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
+	if (type == LE_LINK) {
+		le = hci_conn_hash_lookup_ba(hdev, LE_LINK, dst);
+		if (!le)
+			le = hci_conn_add(hdev, LE_LINK, dst);
+		if (!le)
+			return NULL;
+		if (le->state == BT_OPEN)
+			hci_le_connect(le);
+
+		hci_conn_hold(le);
+
+		return le;
+	}
+
 	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
 	if (!acl) {
 		acl = hci_conn_add(hdev, ACL_LINK, dst);

commit 17fa4b9dff72fb3a1a68cc80caf98fc941d2b8b3
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Tue Jan 25 13:28:33 2011 +0200

    Bluetooth: Add set_io_capability management command
    
    This patch adds a new set_io_capability management command which is used
    to set the IO capability for Secure Simple Pairing (SSP) as well as the
    Security Manager Protocol (SMP). The value is per hci_dev and each
    hci_conn object inherits it upon creation.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 99cd8d9d891b..42dc39f25b72 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -234,6 +234,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	conn->mode  = HCI_CM_ACTIVE;
 	conn->state = BT_OPEN;
 	conn->auth_type = HCI_AT_GENERAL_BONDING;
+	conn->io_capability = hdev->io_capability;
 
 	conn->power_save = 1;
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;

commit 765c2a964b49bd06b61a52991519281c85d82b67
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Jan 19 12:06:52 2011 +0530

    Bluetooth: Fix race condition with conn->sec_level
    
    The conn->sec_level value is supposed to represent the current level of
    security that the connection has. However, by assigning to it before
    requesting authentication it will have the wrong value during the
    authentication procedure. To fix this a pending_sec_level variable is
    added which is used to track the desired security level while making
    sure that sec_level always represents the current level of security.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index fe712a89a856..99cd8d9d891b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -379,7 +379,8 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 	hci_conn_hold(acl);
 
 	if (acl->state == BT_OPEN || acl->state == BT_CLOSED) {
-		acl->sec_level = sec_level;
+		acl->sec_level = BT_SECURITY_LOW;
+		acl->pending_sec_level = sec_level;
 		acl->auth_type = auth_type;
 		hci_acl_connect(acl);
 	}
@@ -437,8 +438,11 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
 	BT_DBG("conn %p", conn);
 
+	if (conn->pending_sec_level > sec_level)
+		sec_level = conn->pending_sec_level;
+
 	if (sec_level > conn->sec_level)
-		conn->sec_level = sec_level;
+		conn->pending_sec_level = sec_level;
 	else if (conn->link_mode & HCI_LM_AUTH)
 		return 1;
 

commit 65cf686ee102b7eb0477a4bab82ff227071a0258
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Jan 19 12:06:49 2011 +0530

    Bluetooth: Fix MITM protection requirement preservation
    
    If an existing connection has a MITM protection requirement (the first
    bit of the auth_type) then that requirement should not be cleared by new
    sockets that reuse the ACL but don't have that requirement.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 65a3fb5678eb..fe712a89a856 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -442,6 +442,9 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 	else if (conn->link_mode & HCI_LM_AUTH)
 		return 1;
 
+	/* Make sure we preserve an existing MITM requirement*/
+	auth_type |= (conn->auth_type & 0x01);
+
 	conn->auth_type = auth_type;
 
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {

commit 88644bb9fee591b2743a881923263bc28df4cded
Author: Johan Hedberg <johan.hedberg@nokia.com>
Date:   Wed Jan 19 12:06:48 2011 +0530

    Revert "Bluetooth: Update sec_level/auth_type for already existing connections"
    
    This reverts commit 045309820afe047920a50de25634dab46a1e851d. That
    commit is wrong for two reasons:
    
    - The conn->sec_level shouldn't be updated without performing
    authentication first (as it's supposed to represent the level of
    security that the existing connection has)
    
    - A higher auth_type value doesn't mean "more secure" like the commit
    seems to assume. E.g. dedicated bonding with MITM protection is 0x03
    whereas general bonding without MITM protection is 0x04. hci_conn_auth
    already takes care of updating conn->auth_type so hci_connect doesn't
    need to do it.
    
    Signed-off-by: Johan Hedberg <johan.hedberg@nokia.com>
    Acked-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6b90a4191734..65a3fb5678eb 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -382,11 +382,6 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 		acl->sec_level = sec_level;
 		acl->auth_type = auth_type;
 		hci_acl_connect(acl);
-	} else {
-		if (acl->sec_level < sec_level)
-			acl->sec_level = sec_level;
-		if (acl->auth_type < auth_type)
-			acl->auth_type = auth_type;
 	}
 
 	if (type == ACL_LINK)

commit 70f23020e6d89155504b5b39f22505f4aec6fa6f
Author: Andrei Emeltchenko <andrei.emeltchenko@nokia.com>
Date:   Wed Dec 1 16:58:25 2010 +0200

    Bluetooth: clean up hci code
    
    Do not use assignment in IF condition, remove extra spaces,
    fixing typos, simplify code.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@nokia.com>
    Signed-off-by: Gustavo F. Padovan <padovan@profusion.mobi>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 0b1e460fe440..6b90a4191734 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -39,7 +39,7 @@
 #include <net/sock.h>
 
 #include <asm/system.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/unaligned.h>
 
 #include <net/bluetooth/bluetooth.h>
@@ -66,7 +66,8 @@ void hci_acl_connect(struct hci_conn *conn)
 	bacpy(&cp.bdaddr, &conn->dst);
 	cp.pscan_rep_mode = 0x02;
 
-	if ((ie = hci_inquiry_cache_lookup(hdev, &conn->dst))) {
+	ie = hci_inquiry_cache_lookup(hdev, &conn->dst);
+	if (ie) {
 		if (inquiry_entry_age(ie) <= INQUIRY_ENTRY_AGE_MAX) {
 			cp.pscan_rep_mode = ie->data.pscan_rep_mode;
 			cp.pscan_mode     = ie->data.pscan_mode;
@@ -368,8 +369,10 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
-	if (!(acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst))) {
-		if (!(acl = hci_conn_add(hdev, ACL_LINK, dst)))
+	acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst);
+	if (!acl) {
+		acl = hci_conn_add(hdev, ACL_LINK, dst);
+		if (!acl)
 			return NULL;
 	}
 
@@ -389,8 +392,10 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 	if (type == ACL_LINK)
 		return acl;
 
-	if (!(sco = hci_conn_hash_lookup_ba(hdev, type, dst))) {
-		if (!(sco = hci_conn_add(hdev, type, dst))) {
+	sco = hci_conn_hash_lookup_ba(hdev, type, dst);
+	if (!sco) {
+		sco = hci_conn_add(hdev, type, dst);
+		if (!sco) {
 			hci_conn_put(acl);
 			return NULL;
 		}
@@ -647,10 +652,12 @@ int hci_get_conn_list(void __user *arg)
 
 	size = sizeof(req) + req.conn_num * sizeof(*ci);
 
-	if (!(cl = kmalloc(size, GFP_KERNEL)))
+	cl = kmalloc(size, GFP_KERNEL);
+	if (!cl)
 		return -ENOMEM;
 
-	if (!(hdev = hci_dev_get(req.dev_id))) {
+	hdev = hci_dev_get(req.dev_id);
+	if (!hdev) {
 		kfree(cl);
 		return -ENODEV;
 	}

commit e73439d8c0e4c522c843b8bb98c0eb5700da6b05
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 26 10:06:00 2010 -0400

    Bluetooth: Defer SCO setup if mode change is pending
    
    Certain headsets such as the Motorola H350 will reject SCO and eSCO
    connection requests while the ACL is transitioning from sniff mode
    to active mode. Add synchronization so that SCO and eSCO connection
    requests will wait until the ACL has fully transitioned to active mode.
    
    < HCI Command: Exit Sniff Mode (0x02|0x0004) plen 2
        handle 12
    > HCI Event: Command Status (0x0f) plen 4
        Exit Sniff Mode (0x02|0x0004) status 0x00 ncmd 1
    < HCI Command:  Setup Synchronous Connection (0x01|0x0028) plen 17
        handle 12 voice setting 0x0040
    > HCI Event: Command Status (0x0f) plen 4
        Setup Synchronous Connection (0x01|0x0028) status 0x00 ncmd 1
    > HCI Event: Number of Completed Packets (0x13) plen 5
        handle 12 packets 1
    > HCI Event: Mode Change (0x14) plen 6
        status 0x00 handle 12 mode 0x00 interval 0
        Mode: Active
    > HCI Event: Synchronous Connect Complete (0x2c) plen 17
        status 0x10 handle 14 bdaddr 00:1A:0E:50:28:A4 type SCO
        Error: Connection Accept Timeout Exceeded
    
    Signed-off-by: Ron Shaffer <rshaffer@codeaurora.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index e9fef83449f8..0b1e460fe440 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -155,6 +155,27 @@ void hci_setup_sync(struct hci_conn *conn, __u16 handle)
 	hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp);
 }
 
+/* Device _must_ be locked */
+void hci_sco_setup(struct hci_conn *conn, __u8 status)
+{
+	struct hci_conn *sco = conn->link;
+
+	BT_DBG("%p", conn);
+
+	if (!sco)
+		return;
+
+	if (!status) {
+		if (lmp_esco_capable(conn->hdev))
+			hci_setup_sync(sco, conn->handle);
+		else
+			hci_add_sco(sco, conn->handle);
+	} else {
+		hci_proto_connect_cfm(sco, status);
+		hci_conn_del(sco);
+	}
+}
+
 static void hci_conn_timeout(unsigned long arg)
 {
 	struct hci_conn *conn = (void *) arg;
@@ -385,10 +406,13 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 		acl->power_save = 1;
 		hci_conn_enter_active_mode(acl);
 
-		if (lmp_esco_capable(hdev))
-			hci_setup_sync(sco, acl->handle);
-		else
-			hci_add_sco(sco, acl->handle);
+		if (test_bit(HCI_CONN_MODE_CHANGE_PEND, &acl->pend)) {
+			/* defer SCO setup until mode change completed */
+			set_bit(HCI_CONN_SCO_SETUP_PEND, &acl->pend);
+			return sco;
+		}
+
+		hci_sco_setup(acl, 0x00);
 	}
 
 	return sco;

commit 2d0a03460a8a0c611843500735096ff799aa8510
Author: Ron Shaffer <rshaffer@codeaurora.org>
Date:   Fri May 28 11:53:46 2010 -0400

    Bluetooth: Reassigned copyright to Code Aurora Forum
    
    Qualcomm, Inc. has reassigned rights to Code Aurora Forum. Accordingly,
    as files are modified by Code Aurora Forum members, the copyright
    statement will be updated.
    
    Signed-off-by: Ron Shaffer <rshaffer@codeaurora.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 800b6b9fbbae..e9fef83449f8 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1,6 +1,6 @@
 /*
    BlueZ - Bluetooth protocol stack for Linux
-   Copyright (C) 2000-2001 Qualcomm Incorporated
+   Copyright (c) 2000-2001, 2010, Code Aurora Forum. All rights reserved.
 
    Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
 

commit 045309820afe047920a50de25634dab46a1e851d
Author: Ville Tervo <ville.tervo@nokia.com>
Date:   Tue Jun 15 15:56:05 2010 +0300

    Bluetooth: Update sec_level/auth_type for already existing connections
    
    Update auth level for already existing connections if it is lower
    than required by new connection.
    
    Signed-off-by: Ville Tervo <ville.tervo@nokia.com>
    Reviewed-by: Emeltchenko Andrei <andrei.emeltchenko@nokia.com>
    Signed-off-by: Luciano Coelho <luciano.coelho@nokia.com>
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@nokia.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b10e3cdb08f8..800b6b9fbbae 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -358,6 +358,11 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 		acl->sec_level = sec_level;
 		acl->auth_type = auth_type;
 		hci_acl_connect(acl);
+	} else {
+		if (acl->sec_level < sec_level)
+			acl->sec_level = sec_level;
+		if (acl->auth_type < auth_type)
+			acl->auth_type = auth_type;
 	}
 
 	if (type == ACL_LINK)

commit c390216b3e868b16d8154939f4b6f8c16dbd9a9f
Author: Nick Pelly <npelly@google.com>
Date:   Fri Nov 13 14:16:32 2009 -0800

    Bluetooth: Enter active mode before establishing a SCO link.
    
    When in sniff mode with a long interval time (1.28s) it can take 4+ seconds
    to establish a SCO link. Fix by requesting active mode before requesting
    SCO connection. This improves SCO setup time to ~500ms.
    
    Bluetooth headsets that use a long interval time, and exhibit the long
    SCO connection time include Motorola H790, HX1 and H17. They have a
    CSR 2.1 chipset.
    
    Verified this behavior and fix with host Bluetooth chipsets: BCM4329 and
    TI1271.
    
    2009-10-13 14:17:46.183722 > HCI Event: Mode Change (0x14) plen 6
        status 0x00 handle 1 mode 0x02 interval 2048
        Mode: Sniff
    2009-10-13 14:17:53.436285 < HCI Command: Setup Synchronous Connection (0x01|0x0028) plen 17
        handle 1 voice setting 0x0060
    2009-10-13 14:17:53.445593 > HCI Event: Command Status (0x0f) plen 4
        Setup Synchronous Connection (0x01|0x0028) status 0x00 ncmd 1
    2009-10-13 14:17:57.788855 > HCI Event: Synchronous Connect Complete 0x2c) plen 17
        status 0x00 handle 257 bdaddr 00:1A:0E:F1:A4:7F type eSCO
        Air mode: CVSD
    
    Signed-off-by: Nick Pelly <npelly@google.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b7c4224f4e7d..b10e3cdb08f8 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -377,6 +377,9 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 
 	if (acl->state == BT_CONNECTED &&
 			(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
+		acl->power_save = 1;
+		hci_conn_enter_active_mode(acl);
+
 		if (lmp_esco_capable(hdev))
 			hci_setup_sync(sco, acl->handle);
 		else

commit 93f19c9fc8c98bb6d2e9825115989603ffd5cd1f
Author: Andrei Emeltchenko <andrei.emeltchenko@nokia.com>
Date:   Thu Sep 3 12:34:19 2009 +0300

    Bluetooth: Set general bonding security for ACL by default
    
    This patch fixes double pairing issues with Secure Simple
    Paring support. It was observed that when pairing with SSP
    enabled, that the confirmation will be asked twice.
    
    http://www.spinics.net/lists/linux-bluetooth/msg02473.html
    
    This also causes bug when initiating SSP connection from
    Windows Vista.
    
    The reason is because bluetoothd does not store link keys
    since HCIGETAUTHINFO returns 0. Setting default to general
    bonding fixes these issues.
    
    Signed-off-by: Andrei Emeltchenko <andrei.emeltchenko@nokia.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a9750984f772..b7c4224f4e7d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -211,6 +211,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	conn->type  = type;
 	conn->mode  = HCI_CM_ACTIVE;
 	conn->state = BT_OPEN;
+	conn->auth_type = HCI_AT_GENERAL_BONDING;
 
 	conn->power_save = 1;
 	conn->disc_timeout = HCI_DISCONN_TIMEOUT;

commit 9eba32b86d17ef87131fa0bce43c614904ab5781
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Aug 22 14:19:26 2009 -0700

    Bluetooth: Add extra device reference counting for connections
    
    The device model itself has no real usable reference counting at the
    moment and this causes problems if parents are deleted before their
    children. The device model itself handles the memory details of this
    correctly, but the uevent order is not consistent. This causes various
    problems for systems like HAL or even X.
    
    So until device_put() does a proper cleanup, the device for Bluetooth
    connection will be protected with an extra reference counting to ensure
    the correct order of uevents when connections are terminated.
    
    This is not an automatic feature. Higher Bluetooth layers like HIDP or
    BNEP should grab this new reference to ensure that their uevents are
    send before the ones from the parent device.
    
    Based on a report by Brian Rogers <brian@xyzw.org>
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index fa47d5d84f5c..a9750984f772 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -246,6 +246,8 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
 
+	atomic_set(&conn->devref, 0);
+
 	hci_conn_init_sysfs(conn);
 
 	tasklet_enable(&hdev->tx_task);
@@ -288,7 +290,7 @@ int hci_conn_del(struct hci_conn *conn)
 
 	skb_queue_purge(&conn->data_q);
 
-	hci_conn_del_sysfs(conn);
+	hci_conn_put_device(conn);
 
 	hci_dev_put(hdev);
 
@@ -583,6 +585,19 @@ void hci_conn_check_pending(struct hci_dev *hdev)
 	hci_dev_unlock(hdev);
 }
 
+void hci_conn_hold_device(struct hci_conn *conn)
+{
+	atomic_inc(&conn->devref);
+}
+EXPORT_SYMBOL(hci_conn_hold_device);
+
+void hci_conn_put_device(struct hci_conn *conn)
+{
+	if (atomic_dec_and_test(&conn->devref))
+		hci_conn_del_sysfs(conn);
+}
+EXPORT_SYMBOL(hci_conn_put_device);
+
 int hci_get_conn_list(void __user *arg)
 {
 	struct hci_conn_list_req req, *cl;

commit 1b0336bb36f88976f1210a65b62f6a3e9578ee7b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat May 9 12:04:08 2009 -0700

    Bluetooth: Don't use hci_acl_connect_cancel() for incoming connections
    
    The connection setup phase takes around 2 seconds or longer and in
    that time it is possible that the need for an ACL connection is no
    longer present. If that happens then, the connection attempt will
    be canceled.
    
    This only applies to outgoing connections, but currently it can also
    be triggered by incoming connection. Don't call hci_acl_connect_cancel()
    on incoming connection since these have to be either accepted or rejected
    in this state. Once they are successfully connected they need to be
    fully disconnected anyway.
    
    Also remove the wrong hci_acl_disconn() call for SCO and eSCO links
    since at this stage they can't be disconnected either, because the
    connection handle is still unknown.
    
    Based on a report by Johan Hedberg <johan.hedberg@nokia.com>
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Tested-by: Johan Hedberg <johan.hedberg@nokia.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 85a1c6be2db9..fa47d5d84f5c 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -171,10 +171,8 @@ static void hci_conn_timeout(unsigned long arg)
 	switch (conn->state) {
 	case BT_CONNECT:
 	case BT_CONNECT2:
-		if (conn->type == ACL_LINK)
+		if (conn->type == ACL_LINK && conn->out)
 			hci_acl_connect_cancel(conn);
-		else
-			hci_acl_disconn(conn, 0x13);
 		break;
 	case BT_CONFIG:
 	case BT_CONNECTED:

commit 384943ec1bb462e410390ad8f108ff1474cd882d
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri May 8 18:20:43 2009 -0700

    Bluetooth: Fix wrong module refcount when connection setup fails
    
    The module refcount is increased by hci_dev_hold() call in hci_conn_add()
    and decreased by hci_dev_put() call in del_conn(). In case the connection
    setup fails, hci_dev_put() is never called.
    
    Procedure to reproduce the issue:
    
      # hciconfig hci0 up
      # lsmod | grep btusb                   -> "used by" refcount = 1
    
      # hcitool cc <non-exisiting bdaddr>    -> will get timeout
    
      # lsmod | grep btusb                   -> "used by" refcount = 2
      # hciconfig hci0 down
      # lsmod | grep btusb                   -> "used by" refcount = 1
      # rmmod btusb                          -> ERROR: Module btusb is in use
    
    The hci_dev_put() call got moved into del_conn() with the 2.6.25 kernel
    to fix an issue with hci_dev going away before hci_conn. However that
    change was wrong and introduced this problem.
    
    When calling hci_conn_del() it has to call hci_dev_put() after freeing
    the connection details. This handling should be fully symmetric. The
    execution of del_conn() is done in a work queue and needs it own calls
    to hci_dev_hold() and hci_dev_put() to ensure that the hci_dev stays
    until the connection cleanup has been finished.
    
    Based on a report by Bing Zhao <bzhao@marvell.com>
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Tested-by: Bing Zhao <bzhao@marvell.com>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 61309b26f271..85a1c6be2db9 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -292,6 +292,8 @@ int hci_conn_del(struct hci_conn *conn)
 
 	hci_conn_del_sysfs(conn);
 
+	hci_dev_put(hdev);
+
 	return 0;
 }
 

commit a67e899cf38ae542d1a028ccd021f9189f76fb74
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat May 2 18:24:06 2009 -0700

    Bluetooth: Fix issue with sysfs handling for connections
    
    Due to a semantic changes in flush_workqueue() the current approach of
    synchronizing the sysfs handling for connections doesn't work anymore. The
    whole approach is actually fully broken and based on assumptions that are
    no longer valid.
    
    With the introduction of Simple Pairing support, the creation of low-level
    ACL links got changed. This change invalidates the reason why in the past
    two independent work queues have been used for adding/removing sysfs
    devices. The adding of the actual sysfs device is now postponed until the
    host controller successfully assigns an unique handle to that link. So
    the real synchronization happens inside the controller and not the host.
    
    The only left-over problem is that some internals of the sysfs device
    handling are not initialized ahead of time. This leaves potential access
    to invalid data and can cause various NULL pointer dereferences. To fix
    this a new function makes sure that all sysfs details are initialized
    when an connection attempt is made. The actual sysfs device is only
    registered when the connection has been successfully established. To
    avoid a race condition with the registration, the check if a device is
    registered has been moved into the removal work.
    
    As an extra protection two flush_work() calls are left in place to
    make sure a previous add/del work has been completed first.
    
    Based on a report by Marc Pignat <marc.pignat@hevs.ch>
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>
    Tested-by: Justin P. Mattock <justinmattock@gmail.com>
    Tested-by: Roger Quadros <ext-roger.quadros@nokia.com>
    Tested-by: Marc Pignat <marc.pignat@hevs.ch>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 375f4b4f7f79..61309b26f271 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -248,6 +248,8 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
 
+	hci_conn_init_sysfs(conn);
+
 	tasklet_enable(&hdev->tx_task);
 
 	return conn;

commit 3fdca1e1370ffe89980927cdef0583bebcd8caaf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Apr 28 09:04:55 2009 -0700

    Bluetooth: Fix connection establishment with low security requirement
    
    The Bluetooth 2.1 specification introduced four different security modes
    that can be mapped using Legacy Pairing and Simple Pairing. With the
    usage of Simple Pairing it is required that all connections (except
    the ones for SDP) are encrypted. So even the low security requirement
    mandates an encrypted connection when using Simple Pairing. When using
    Legacy Pairing (for Bluetooth 2.0 devices and older) this is not required
    since it causes interoperability issues.
    
    To support this properly the low security requirement translates into
    different host controller transactions depending if Simple Pairing is
    supported or not. However in case of Simple Pairing the command to
    switch on encryption after a successful authentication is not triggered
    for the low security mode. This patch fixes this and actually makes
    the logic to differentiate between Simple Pairing and Legacy Pairing
    a lot simpler.
    
    Based on a report by Ville Tervo <ville.tervo@nokia.com>
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 75ebbe2221a3..375f4b4f7f79 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -425,12 +425,9 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 	if (sec_level == BT_SECURITY_SDP)
 		return 1;
 
-	if (sec_level == BT_SECURITY_LOW) {
-		if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0)
-			return hci_conn_auth(conn, sec_level, auth_type);
-		else
-			return 1;
-	}
+	if (sec_level == BT_SECURITY_LOW &&
+				(!conn->ssp_mode || !conn->hdev->ssp_mode))
+		return 1;
 
 	if (conn->link_mode & HCI_LM_ENCRYPT)
 		return hci_conn_auth(conn, sec_level, auth_type);

commit 052b30b0a8eec8db5b18ad49effdf2a9ba4c1e1a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Apr 26 20:01:22 2009 +0200

    Bluetooth: Add different pairing timeout for Legacy Pairing
    
    The Bluetooth stack uses a reference counting for all established ACL
    links and if no user (L2CAP connection) is present, the link will be
    terminated to save power. The problem part is the dedicated pairing
    when using Legacy Pairing (Bluetooth 2.0 and before). At that point
    no user is present and pairing attempts will be disconnected within
    10 seconds or less. In previous kernel version this was not a problem
    since the disconnect timeout wasn't triggered on incoming connections
    for the first time. However this caused issues with broken host stacks
    that kept the connections around after dedicated pairing. When the
    support for Simple Pairing got added, the link establishment procedure
    needed to be changed and now causes issues when using Legacy Pairing
    
    When using Simple Pairing it is possible to do a proper reference
    counting of ACL link users. With Legacy Pairing this is not possible
    since the specification is unclear in some areas and too many broken
    Bluetooth devices have already been deployed. So instead of trying to
    deal with all the broken devices, a special pairing timeout will be
    introduced that increases the timeout to 60 seconds when pairing is
    triggered.
    
    If a broken devices now puts the stack into an unforeseen state, the
    worst that happens is the disconnect timeout triggers after 120 seconds
    instead of 4 seconds. This allows successful pairings with legacy and
    broken devices now.
    
    Based on a report by Johan Hedberg <johan.hedberg@nokia.com>
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 1181db08d9de..75ebbe2221a3 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -215,6 +215,7 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	conn->state = BT_OPEN;
 
 	conn->power_save = 1;
+	conn->disc_timeout = HCI_DISCONN_TIMEOUT;
 
 	switch (type) {
 	case ACL_LINK:

commit 2ae9a6be5f476f3512839a4d11a8f432bfd2914c
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Sat Feb 21 16:13:34 2009 +0800

    Bluetooth: Move hci_conn_del_sysfs() back to avoid device destruct too early
    
    The following commit introduce a regression:
    
            commit 7d0db0a373195385a2e0b19d1f5e4b186fdcffac
            Author: Marcel Holtmann <marcel@holtmann.org>
            Date:   Mon Jul 14 20:13:51 2008 +0200
    
                    [Bluetooth] Use a more unique bus name for connections
    
    I get panic as following (by netconsole):
    
    [ 2709.344034] usb 5-1: new full speed USB device using uhci_hcd and address 4
    [ 2709.505776] usb 5-1: configuration #1 chosen from 1 choice
    [ 2709.569207] Bluetooth: Generic Bluetooth USB driver ver 0.4
    [ 2709.570169] usbcore: registered new interface driver btusb
    [ 2845.742781] BUG: unable to handle kernel paging request at 6b6b6c2f
    [ 2845.742958] IP: [<c015515c>] __lock_acquire+0x6c/0xa80
    [ 2845.743087] *pde = 00000000
    [ 2845.743206] Oops: 0002 [#1] SMP
    [ 2845.743377] last sysfs file: /sys/class/bluetooth/hci0/hci0:6/type
    [ 2845.743742] Modules linked in: btusb netconsole snd_seq_dummy snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device snd_pcm_oss snd_mixer_oss rfcomm l2cap bluetooth vfat fuse snd_hda_codec_idt snd_hda_intel snd_hda_codec snd_hwdep snd_pcm pl2303 snd_timer psmouse usbserial snd 3c59x e100 serio_raw soundcore i2c_i801 intel_agp mii agpgart snd_page_alloc rtc_cmos rtc_core thermal processor rtc_lib button thermal_sys sg evdev
    [ 2845.743742]
    [ 2845.743742] Pid: 0, comm: swapper Not tainted (2.6.29-rc5-smp #54) Dell DM051
    [ 2845.743742] EIP: 0060:[<c015515c>] EFLAGS: 00010002 CPU: 0
    [ 2845.743742] EIP is at __lock_acquire+0x6c/0xa80
    [ 2845.743742] EAX: 00000046 EBX: 00000046 ECX: 6b6b6b6b EDX: 00000002
    [ 2845.743742] ESI: 6b6b6b6b EDI: 00000000 EBP: c064fd14 ESP: c064fcc8
    [ 2845.743742]  DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068
    [ 2845.743742] Process swapper (pid: 0, ti=c064e000 task=c05d1400 task.ti=c064e000)
    [ 2845.743742] Stack:
    [ 2845.743742]  c05d1400 00000002 c05d1400 00000001 00000002 00000000 f65388dc c05d1400
    [ 2845.743742]  6b6b6b6b 00000292 c064fd0c c0153732 00000000 00000000 00000001 f700fa50
    [ 2845.743742]  00000046 00000000 00000000 c064fd40 c0155be6 00000000 00000002 00000001
    [ 2845.743742] Call Trace:
    [ 2845.743742]  [<c0153732>] ? trace_hardirqs_on_caller+0x72/0x1c0
    [ 2845.743742]  [<c0155be6>] ? lock_acquire+0x76/0xa0
    [ 2845.743742]  [<c03e1aad>] ? skb_dequeue+0x1d/0x70
    [ 2845.743742]  [<c046c885>] ? _spin_lock_irqsave+0x45/0x80
    [ 2845.743742]  [<c03e1aad>] ? skb_dequeue+0x1d/0x70
    [ 2845.743742]  [<c03e1aad>] ? skb_dequeue+0x1d/0x70
    [ 2845.743742]  [<c03e1f94>] ? skb_queue_purge+0x14/0x20
    [ 2845.743742]  [<f8171f5a>] ? hci_conn_del+0x10a/0x1c0 [bluetooth]
    [ 2845.743742]  [<f81399c9>] ? l2cap_disconn_ind+0x59/0xb0 [l2cap]
    [ 2845.743742]  [<f81795ce>] ? hci_conn_del_sysfs+0x8e/0xd0 [bluetooth]
    [ 2845.743742]  [<f8175758>] ? hci_event_packet+0x5f8/0x31c0 [bluetooth]
    [ 2845.743742]  [<c03dfe19>] ? sock_def_readable+0x59/0x80
    [ 2845.743742]  [<c046c14d>] ? _read_unlock+0x1d/0x20
    [ 2845.743742]  [<f8178aa9>] ? hci_send_to_sock+0xe9/0x1d0 [bluetooth]
    [ 2845.743742]  [<c015388b>] ? trace_hardirqs_on+0xb/0x10
    [ 2845.743742]  [<f816fa6a>] ? hci_rx_task+0x2ba/0x490 [bluetooth]
    [ 2845.743742]  [<c0133661>] ? tasklet_action+0x31/0xc0
    [ 2845.743742]  [<c013367c>] ? tasklet_action+0x4c/0xc0
    [ 2845.743742]  [<c0132eb7>] ? __do_softirq+0xa7/0x170
    [ 2845.743742]  [<c0116dec>] ? ack_apic_level+0x5c/0x1c0
    [ 2845.743742]  [<c0132fd7>] ? do_softirq+0x57/0x60
    [ 2845.743742]  [<c01333dc>] ? irq_exit+0x7c/0x90
    [ 2845.743742]  [<c01055bb>] ? do_IRQ+0x4b/0x90
    [ 2845.743742]  [<c01333d5>] ? irq_exit+0x75/0x90
    [ 2845.743742]  [<c010392c>] ? common_interrupt+0x2c/0x34
    [ 2845.743742]  [<c010a14f>] ? mwait_idle+0x4f/0x70
    [ 2845.743742]  [<c0101c05>] ? cpu_idle+0x65/0xb0
    [ 2845.743742]  [<c045731e>] ? rest_init+0x4e/0x60
    [ 2845.743742] Code: 0f 84 69 02 00 00 83 ff 07 0f 87 1e 06 00 00 85 ff 0f 85 08 05 00 00 8b 4d cc 8b 49 04 85 c9 89 4d d4 0f 84 f7 04 00 00 8b 75 d4 <f0> ff 86 c4 00 00 00 89 f0 e8 56 a9 ff ff 85 c0 0f 85 6e 03 00
    [ 2845.743742] EIP: [<c015515c>] __lock_acquire+0x6c/0xa80 SS:ESP 0068:c064fcc8
    [ 2845.743742] ---[ end trace 4c985b38f022279f ]---
    [ 2845.743742] Kernel panic - not syncing: Fatal exception in interrupt
    [ 2845.743742] ------------[ cut here ]------------
    [ 2845.743742] WARNING: at kernel/smp.c:329 smp_call_function_many+0x151/0x200()
    [ 2845.743742] Hardware name: Dell DM051
    [ 2845.743742] Modules linked in: btusb netconsole snd_seq_dummy snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device snd_pcm_oss snd_mixer_oss rfcomm l2cap bluetooth vfat fuse snd_hda_codec_idt snd_hda_intel snd_hda_codec snd_hwdep snd_pcm pl2303 snd_timer psmouse usbserial snd 3c59x e100 serio_raw soundcore i2c_i801 intel_agp mii agpgart snd_page_alloc rtc_cmos rtc_core thermal processor rtc_lib button thermal_sys sg evdev
    [ 2845.743742] Pid: 0, comm: swapper Tainted: G      D    2.6.29-rc5-smp #54
    [ 2845.743742] Call Trace:
    [ 2845.743742]  [<c012e076>] warn_slowpath+0x86/0xa0
    [ 2845.743742]  [<c015041b>] ? trace_hardirqs_off+0xb/0x10
    [ 2845.743742]  [<c0146384>] ? up+0x14/0x40
    [ 2845.743742]  [<c012e661>] ? release_console_sem+0x31/0x1e0
    [ 2845.743742]  [<c046c8ab>] ? _spin_lock_irqsave+0x6b/0x80
    [ 2845.743742]  [<c015041b>] ? trace_hardirqs_off+0xb/0x10
    [ 2845.743742]  [<c046c900>] ? _read_lock_irqsave+0x40/0x80
    [ 2845.743742]  [<c012e7f2>] ? release_console_sem+0x1c2/0x1e0
    [ 2845.743742]  [<c0146384>] ? up+0x14/0x40
    [ 2845.743742]  [<c015041b>] ? trace_hardirqs_off+0xb/0x10
    [ 2845.743742]  [<c046a3d7>] ? __mutex_unlock_slowpath+0x97/0x160
    [ 2845.743742]  [<c046a563>] ? mutex_trylock+0xb3/0x180
    [ 2845.743742]  [<c046a4a8>] ? mutex_unlock+0x8/0x10
    [ 2845.743742]  [<c015b991>] smp_call_function_many+0x151/0x200
    [ 2845.743742]  [<c010a1a0>] ? stop_this_cpu+0x0/0x40
    [ 2845.743742]  [<c015ba61>] smp_call_function+0x21/0x30
    [ 2845.743742]  [<c01137ae>] native_smp_send_stop+0x1e/0x50
    [ 2845.743742]  [<c012e0f5>] panic+0x55/0x110
    [ 2845.743742]  [<c01065a8>] oops_end+0xb8/0xc0
    [ 2845.743742]  [<c010668f>] die+0x4f/0x70
    [ 2845.743742]  [<c011a8c9>] do_page_fault+0x269/0x610
    [ 2845.743742]  [<c011a660>] ? do_page_fault+0x0/0x610
    [ 2845.743742]  [<c046cbaf>] error_code+0x77/0x7c
    [ 2845.743742]  [<c015515c>] ? __lock_acquire+0x6c/0xa80
    [ 2845.743742]  [<c0153732>] ? trace_hardirqs_on_caller+0x72/0x1c0
    [ 2845.743742]  [<c0155be6>] lock_acquire+0x76/0xa0
    [ 2845.743742]  [<c03e1aad>] ? skb_dequeue+0x1d/0x70
    [ 2845.743742]  [<c046c885>] _spin_lock_irqsave+0x45/0x80
    [ 2845.743742]  [<c03e1aad>] ? skb_dequeue+0x1d/0x70
    [ 2845.743742]  [<c03e1aad>] skb_dequeue+0x1d/0x70
    [ 2845.743742]  [<c03e1f94>] skb_queue_purge+0x14/0x20
    [ 2845.743742]  [<f8171f5a>] hci_conn_del+0x10a/0x1c0 [bluetooth]
    [ 2845.743742]  [<f81399c9>] ? l2cap_disconn_ind+0x59/0xb0 [l2cap]
    [ 2845.743742]  [<f81795ce>] ? hci_conn_del_sysfs+0x8e/0xd0 [bluetooth]
    [ 2845.743742]  [<f8175758>] hci_event_packet+0x5f8/0x31c0 [bluetooth]
    [ 2845.743742]  [<c03dfe19>] ? sock_def_readable+0x59/0x80
    [ 2845.743742]  [<c046c14d>] ? _read_unlock+0x1d/0x20
    [ 2845.743742]  [<f8178aa9>] ? hci_send_to_sock+0xe9/0x1d0 [bluetooth]
    [ 2845.743742]  [<c015388b>] ? trace_hardirqs_on+0xb/0x10
    [ 2845.743742]  [<f816fa6a>] hci_rx_task+0x2ba/0x490 [bluetooth]
    [ 2845.743742]  [<c0133661>] ? tasklet_action+0x31/0xc0
    [ 2845.743742]  [<c013367c>] tasklet_action+0x4c/0xc0
    [ 2845.743742]  [<c0132eb7>] __do_softirq+0xa7/0x170
    [ 2845.743742]  [<c0116dec>] ? ack_apic_level+0x5c/0x1c0
    [ 2845.743742]  [<c0132fd7>] do_softirq+0x57/0x60
    [ 2845.743742]  [<c01333dc>] irq_exit+0x7c/0x90
    [ 2845.743742]  [<c01055bb>] do_IRQ+0x4b/0x90
    [ 2845.743742]  [<c01333d5>] ? irq_exit+0x75/0x90
    [ 2845.743742]  [<c010392c>] common_interrupt+0x2c/0x34
    [ 2845.743742]  [<c010a14f>] ? mwait_idle+0x4f/0x70
    [ 2845.743742]  [<c0101c05>] cpu_idle+0x65/0xb0
    [ 2845.743742]  [<c045731e>] rest_init+0x4e/0x60
    [ 2845.743742] ---[ end trace 4c985b38f02227a0 ]---
    [ 2845.743742] ------------[ cut here ]------------
    [ 2845.743742] WARNING: at kernel/smp.c:226 smp_call_function_single+0x8e/0x110()
    [ 2845.743742] Hardware name: Dell DM051
    [ 2845.743742] Modules linked in: btusb netconsole snd_seq_dummy snd_seq_oss snd_seq_midi_event snd_seq snd_seq_device snd_pcm_oss snd_mixer_oss rfcomm l2cap bluetooth vfat fuse snd_hda_codec_idt snd_hda_intel snd_hda_codec snd_hwdep snd_pcm pl2303 snd_timer psmouse usbserial snd 3c59x e100 serio_raw soundcore i2c_i801 intel_agp mii agpgart snd_page_alloc rtc_cmos rtc_core thermal processor rtc_lib button thermal_sys sg evdev
    [ 2845.743742] Pid: 0, comm: swapper Tainted: G      D W  2.6.29-rc5-smp #54
    [ 2845.743742] Call Trace:
    [ 2845.743742]  [<c012e076>] warn_slowpath+0x86/0xa0
    [ 2845.743742]  [<c012e000>] ? warn_slowpath+0x10/0xa0
    [ 2845.743742]  [<c015041b>] ? trace_hardirqs_off+0xb/0x10
    [ 2845.743742]  [<c0146384>] ? up+0x14/0x40
    [ 2845.743742]  [<c012e661>] ? release_console_sem+0x31/0x1e0
    [ 2845.743742]  [<c046c8ab>] ? _spin_lock_irqsave+0x6b/0x80
    [ 2845.743742]  [<c015041b>] ? trace_hardirqs_off+0xb/0x10
    [ 2845.743742]  [<c046c900>] ? _read_lock_irqsave+0x40/0x80
    [ 2845.743742]  [<c012e7f2>] ? release_console_sem+0x1c2/0x1e0
    [ 2845.743742]  [<c0146384>] ? up+0x14/0x40
    [ 2845.743742]  [<c015b7be>] smp_call_function_single+0x8e/0x110
    [ 2845.743742]  [<c010a1a0>] ? stop_this_cpu+0x0/0x40
    [ 2845.743742]  [<c026d23f>] ? cpumask_next_and+0x1f/0x40
    [ 2845.743742]  [<c015b95a>] smp_call_function_many+0x11a/0x200
    [ 2845.743742]  [<c010a1a0>] ? stop_this_cpu+0x0/0x40
    [ 2845.743742]  [<c015ba61>] smp_call_function+0x21/0x30
    [ 2845.743742]  [<c01137ae>] native_smp_send_stop+0x1e/0x50
    [ 2845.743742]  [<c012e0f5>] panic+0x55/0x110
    [ 2845.743742]  [<c01065a8>] oops_end+0xb8/0xc0
    [ 2845.743742]  [<c010668f>] die+0x4f/0x70
    [ 2845.743742]  [<c011a8c9>] do_page_fault+0x269/0x610
    [ 2845.743742]  [<c011a660>] ? do_page_fault+0x0/0x610
    [ 2845.743742]  [<c046cbaf>] error_code+0x77/0x7c
    [ 2845.743742]  [<c015515c>] ? __lock_acquire+0x6c/0xa80
    [ 2845.743742]  [<c0153732>] ? trace_hardirqs_on_caller+0x72/0x1c0
    [ 2845.743742]  [<c0155be6>] lock_acquire+0x76/0xa0
    [ 2845.743742]  [<c03e1aad>] ? skb_dequeue+0x1d/0x70
    [ 2845.743742]  [<c046c885>] _spin_lock_irqsave+0x45/0x80
    [ 2845.743742]  [<c03e1aad>] ? skb_dequeue+0x1d/0x70
    [ 2845.743742]  [<c03e1aad>] skb_dequeue+0x1d/0x70
    [ 2845.743742]  [<c03e1f94>] skb_queue_purge+0x14/0x20
    [ 2845.743742]  [<f8171f5a>] hci_conn_del+0x10a/0x1c0 [bluetooth]
    [ 2845.743742]  [<f81399c9>] ? l2cap_disconn_ind+0x59/0xb0 [l2cap]
    [ 2845.743742]  [<f81795ce>] ? hci_conn_del_sysfs+0x8e/0xd0 [bluetooth]
    [ 2845.743742]  [<f8175758>] hci_event_packet+0x5f8/0x31c0 [bluetooth]
    [ 2845.743742]  [<c03dfe19>] ? sock_def_readable+0x59/0x80
    [ 2845.743742]  [<c046c14d>] ? _read_unlock+0x1d/0x20
    [ 2845.743742]  [<f8178aa9>] ? hci_send_to_sock+0xe9/0x1d0 [bluetooth]
    [ 2845.743742]  [<c015388b>] ? trace_hardirqs_on+0xb/0x10
    [ 2845.743742]  [<f816fa6a>] hci_rx_task+0x2ba/0x490 [bluetooth]
    [ 2845.743742]  [<c0133661>] ? tasklet_action+0x31/0xc0
    [ 2845.743742]  [<c013367c>] tasklet_action+0x4c/0xc0
    [ 2845.743742]  [<c0132eb7>] __do_softirq+0xa7/0x170
    [ 2845.743742]  [<c0116dec>] ? ack_apic_level+0x5c/0x1c0
    [ 2845.743742]  [<c0132fd7>] do_softirq+0x57/0x60
    [ 2845.743742]  [<c01333dc>] irq_exit+0x7c/0x90
    [ 2845.743742]  [<c01055bb>] do_IRQ+0x4b/0x90
    [ 2845.743742]  [<c01333d5>] ? irq_exit+0x75/0x90
    [ 2845.743742]  [<c010392c>] common_interrupt+0x2c/0x34
    [ 2845.743742]  [<c010a14f>] ? mwait_idle+0x4f/0x70
    [ 2845.743742]  [<c0101c05>] cpu_idle+0x65/0xb0
    [ 2845.743742]  [<c045731e>] rest_init+0x4e/0x60
    [ 2845.743742] ---[ end trace 4c985b38f02227a1 ]---
    [ 2845.743742] Rebooting in 3 seconds..
    
    My logitec bluetooth mouse trying connect to pc, but
    pc side reject the connection again and again. then panic happens.
    
    The reason is due to hci_conn_del_sysfs now called in hci_event_packet,
    the del work is done in a workqueue, so it's possible done before
    skb_queue_purge called.
    
    I move the hci_conn_del_sysfs after skb_queue_purge just as that before
    marcel's commit.
    
    Remove the hci_conn_del_sysfs in hci_conn_hash_flush as well due to
    hci_conn_del will deal with the work.
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index efd5c926cc1b..1181db08d9de 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -287,6 +287,8 @@ int hci_conn_del(struct hci_conn *conn)
 
 	skb_queue_purge(&conn->data_q);
 
+	hci_conn_del_sysfs(conn);
+
 	return 0;
 }
 
@@ -560,8 +562,6 @@ void hci_conn_hash_flush(struct hci_dev *hdev)
 
 		c->state = BT_CLOSED;
 
-		hci_conn_del_sysfs(c);
-
 		hci_proto_disconn_cfm(c, 0x16);
 		hci_conn_del(c);
 	}

commit 96a3183322cba1a2846771b067c99b9d6f481263
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 12 16:23:03 2009 +0100

    Bluetooth: Set authentication requirement before requesting it
    
    The authentication requirement got only updated when the security level
    increased. This is a wrong behavior. The authentication requirement is
    read by the Bluetooth daemon to make proper decisions when handling the
    IO capabilities exchange. So set the value that is currently expected by
    the higher layers like L2CAP and RFCOMM.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 96281a11a186..efd5c926cc1b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -397,12 +397,13 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
 	BT_DBG("conn %p", conn);
 
-	if (sec_level > conn->sec_level) {
+	if (sec_level > conn->sec_level)
 		conn->sec_level = sec_level;
-		conn->auth_type = auth_type;
-	} else if (conn->link_mode & HCI_LM_AUTH)
+	else if (conn->link_mode & HCI_LM_AUTH)
 		return 1;
 
+	conn->auth_type = auth_type;
+
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
 		struct hci_cp_auth_requested cp;
 		cp.handle = cpu_to_le16(conn->handle);
@@ -418,9 +419,6 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
 	BT_DBG("conn %p", conn);
 
-	if (conn->auth_type == 0xff)
-		conn->auth_type = auth_type;
-
 	if (sec_level == BT_SECURITY_SDP)
 		return 1;
 

commit 2950f21acb0f6b8fcd964485c2ebf1e06545ac20
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Feb 12 14:02:50 2009 +0100

    Bluetooth: Ask upper layers for HCI disconnect reason
    
    Some of the qualification tests demand that in case of failures in L2CAP
    the HCI disconnect should indicate a reason why L2CAP fails. This is a
    bluntly layer violation since multiple L2CAP connections could be using
    the same ACL and thus forcing a disconnect reason is not a good idea.
    
    To comply with the Bluetooth test specification, the disconnect reason
    is now stored in the L2CAP connection structure and every time a new
    L2CAP channel is added it will set back to its default. So only in the
    case where the L2CAP channel with the disconnect reason is really the
    last one, it will propagated to the HCI layer.
    
    The HCI layer has been extended with a disconnect indication that allows
    it to ask upper layers for a disconnect reason. The upper layer must not
    support this callback and in that case it will nicely default to the
    existing behavior. If an upper layer like L2CAP can provide a disconnect
    reason that one will be used to disconnect the ACL or SCO link.
    
    No modification to the ACL disconnect timeout have been made. So in case
    of Linux to Linux connection the initiator will disconnect the ACL link
    before the acceptor side can signal the specific disconnect reason. That
    is perfectly fine since Linux doesn't make use of this value anyway. The
    L2CAP layer has a perfect valid error code for rejecting connection due
    to a security violation. It is unclear why the Bluetooth specification
    insists on having specific HCI disconnect reason.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index dcdaa4be7847..96281a11a186 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -159,6 +159,7 @@ static void hci_conn_timeout(unsigned long arg)
 {
 	struct hci_conn *conn = (void *) arg;
 	struct hci_dev *hdev = conn->hdev;
+	__u8 reason;
 
 	BT_DBG("conn %p state %d", conn, conn->state);
 
@@ -177,7 +178,8 @@ static void hci_conn_timeout(unsigned long arg)
 		break;
 	case BT_CONFIG:
 	case BT_CONNECTED:
-		hci_acl_disconn(conn, 0x13);
+		reason = hci_proto_disconn_ind(conn);
+		hci_acl_disconn(conn, reason);
 		break;
 	default:
 		conn->state = BT_CLOSED;
@@ -562,7 +564,7 @@ void hci_conn_hash_flush(struct hci_dev *hdev)
 
 		hci_conn_del_sysfs(c);
 
-		hci_proto_disconn_ind(c, 0x16);
+		hci_proto_disconn_cfm(c, 0x16);
 		hci_conn_del(c);
 	}
 }

commit 657e17b03c80bec817975984d221bef716f83558
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Feb 6 19:45:36 2009 +0100

    Bluetooth: Set authentication requirements if not available
    
    When no authentication requirements are selected, but an outgoing or
    incoming connection has requested any kind of security enforcement,
    then set these authentication requirements.
    
    This ensures that the userspace always gets informed about the
    authentication requirements (if available). Only when no security
    enforcement has happened, the kernel will signal invalid requirements.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7fc4c048b57b..dcdaa4be7847 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -416,6 +416,9 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
 	BT_DBG("conn %p", conn);
 
+	if (conn->auth_type == 0xff)
+		conn->auth_type = auth_type;
+
 	if (sec_level == BT_SECURITY_SDP)
 		return 1;
 

commit 0684e5f9fb9e3f7e168ab831dfca693bcb44805b
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Feb 9 02:48:38 2009 +0100

    Bluetooth: Use general bonding whenever possible
    
    When receiving incoming connection to specific services, always use
    general bonding. This ensures that the link key gets stored and can be
    used for further authentications.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 2435e830ba60..7fc4c048b57b 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -391,19 +391,14 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 EXPORT_SYMBOL(hci_conn_check_link_mode);
 
 /* Authenticate remote device */
-static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level)
+static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
 	BT_DBG("conn %p", conn);
 
-	if (sec_level > conn->sec_level)
-		conn->link_mode &= ~HCI_LM_AUTH;
-
-	conn->sec_level = sec_level;
-
-	if (sec_level == BT_SECURITY_HIGH)
-		conn->auth_type |= 0x01;
-
-	if (conn->link_mode & HCI_LM_AUTH)
+	if (sec_level > conn->sec_level) {
+		conn->sec_level = sec_level;
+		conn->auth_type = auth_type;
+	} else if (conn->link_mode & HCI_LM_AUTH)
 		return 1;
 
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
@@ -417,7 +412,7 @@ static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level)
 }
 
 /* Enable security */
-int hci_conn_security(struct hci_conn *conn, __u8 sec_level)
+int hci_conn_security(struct hci_conn *conn, __u8 sec_level, __u8 auth_type)
 {
 	BT_DBG("conn %p", conn);
 
@@ -426,18 +421,18 @@ int hci_conn_security(struct hci_conn *conn, __u8 sec_level)
 
 	if (sec_level == BT_SECURITY_LOW) {
 		if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0)
-			return hci_conn_auth(conn, sec_level);
+			return hci_conn_auth(conn, sec_level, auth_type);
 		else
 			return 1;
 	}
 
 	if (conn->link_mode & HCI_LM_ENCRYPT)
-		return hci_conn_auth(conn, sec_level);
+		return hci_conn_auth(conn, sec_level, auth_type);
 
 	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
 		return 0;
 
-	if (hci_conn_auth(conn, sec_level)) {
+	if (hci_conn_auth(conn, sec_level, auth_type)) {
 		struct hci_cp_set_conn_encrypt cp;
 		cp.handle  = cpu_to_le16(conn->handle);
 		cp.encrypt = 1;

commit efc7688b557dd1be10eead7399b315efcb1dbc74
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Fri Feb 6 09:13:37 2009 +0100

    Bluetooth: Add SCO fallback for eSCO connection attempts
    
    When attempting to setup eSCO connections it can happen that some link
    manager implementations fail to properly negotiate the eSCO parameters
    and thus fail the eSCO setup. Normally the link manager is responsible
    for the negotiation of the parameters and actually fallback to SCO if
    no agreement can be reached. In cases where the link manager is just too
    stupid, then at least try to establish a SCO link if eSCO fails.
    
    For the Bluetooth devices with EDR support this includes handling packet
    types of EDR basebands. This is particular tricky since for the EDR the
    logic of enabling/disabling one specific packet type is turned around.
    This fix contains an extra bitmask to disable eSCO EDR packet when
    trying to fallback to a SCO connection.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 98f97a1e9bbb..2435e830ba60 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -123,6 +123,8 @@ void hci_add_sco(struct hci_conn *conn, __u16 handle)
 	conn->state = BT_CONNECT;
 	conn->out = 1;
 
+	conn->attempt++;
+
 	cp.handle   = cpu_to_le16(handle);
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 
@@ -139,6 +141,8 @@ void hci_setup_sync(struct hci_conn *conn, __u16 handle)
 	conn->state = BT_CONNECT;
 	conn->out = 1;
 
+	conn->attempt++;
+
 	cp.handle   = cpu_to_le16(handle);
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 
@@ -216,12 +220,13 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 		break;
 	case SCO_LINK:
 		if (lmp_esco_capable(hdev))
-			conn->pkt_type = hdev->esco_type & SCO_ESCO_MASK;
+			conn->pkt_type = (hdev->esco_type & SCO_ESCO_MASK) |
+					(hdev->esco_type & EDR_ESCO_MASK);
 		else
 			conn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;
 		break;
 	case ESCO_LINK:
-		conn->pkt_type = hdev->esco_type;
+		conn->pkt_type = hdev->esco_type & ~EDR_ESCO_MASK;
 		break;
 	}
 

commit 8c1b235594fbab9a13240a1dac12ea9fd99b6440
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jan 15 21:58:04 2009 +0100

    Bluetooth: Add enhanced security model for Simple Pairing
    
    The current security model is based around the flags AUTH, ENCRYPT and
    SECURE. Starting with support for the Bluetooth 2.1 specification this is
    no longer sufficient. The different security levels are now defined as
    SDP, LOW, MEDIUM and SECURE.
    
    Previously it was possible to set each security independently, but this
    actually doesn't make a lot of sense. For Bluetooth the encryption depends
    on a previous successful authentication. Also you can only update your
    existing link key if you successfully created at least one before. And of
    course the update of link keys without having proper encryption in place
    is a security issue.
    
    The new security levels from the Bluetooth 2.1 specification are now
    used internally. All old settings are mapped to the new values and this
    way it ensures that old applications still work. The only limitation
    is that it is no longer possible to set authentication without also
    enabling encryption. No application should have done this anyway since
    this is actually a security issue. Without encryption the integrity of
    the authentication can't be guaranteed.
    
    As default for a new L2CAP or RFCOMM connection, the LOW security level
    is used. The only exception here are the service discovery sessions on
    PSM 1 where SDP level is used. To have similar security strength as with
    a Bluetooth 2.0 and before combination key, the MEDIUM level should be
    used. This is according to the Bluetooth specification. The MEDIUM level
    will not require any kind of man-in-the-middle (MITM) protection. Only
    the HIGH security level will require this.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a4a789f24c8d..98f97a1e9bbb 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -325,7 +325,7 @@ EXPORT_SYMBOL(hci_get_route);
 
 /* Create SCO or ACL connection.
  * Device _must_ be locked */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 auth_type)
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 sec_level, __u8 auth_type)
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
@@ -340,6 +340,7 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 	hci_conn_hold(acl);
 
 	if (acl->state == BT_OPEN || acl->state == BT_CLOSED) {
+		acl->sec_level = sec_level;
 		acl->auth_type = auth_type;
 		hci_acl_connect(acl);
 	}
@@ -385,16 +386,17 @@ int hci_conn_check_link_mode(struct hci_conn *conn)
 EXPORT_SYMBOL(hci_conn_check_link_mode);
 
 /* Authenticate remote device */
-int hci_conn_auth(struct hci_conn *conn)
+static int hci_conn_auth(struct hci_conn *conn, __u8 sec_level)
 {
 	BT_DBG("conn %p", conn);
 
-	if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0) {
-		if (!(conn->auth_type & 0x01)) {
-			conn->auth_type |= 0x01;
-			conn->link_mode &= ~HCI_LM_AUTH;
-		}
-	}
+	if (sec_level > conn->sec_level)
+		conn->link_mode &= ~HCI_LM_AUTH;
+
+	conn->sec_level = sec_level;
+
+	if (sec_level == BT_SECURITY_HIGH)
+		conn->auth_type |= 0x01;
 
 	if (conn->link_mode & HCI_LM_AUTH)
 		return 1;
@@ -405,31 +407,42 @@ int hci_conn_auth(struct hci_conn *conn)
 		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
 							sizeof(cp), &cp);
 	}
+
 	return 0;
 }
-EXPORT_SYMBOL(hci_conn_auth);
 
-/* Enable encryption */
-int hci_conn_encrypt(struct hci_conn *conn)
+/* Enable security */
+int hci_conn_security(struct hci_conn *conn, __u8 sec_level)
 {
 	BT_DBG("conn %p", conn);
 
+	if (sec_level == BT_SECURITY_SDP)
+		return 1;
+
+	if (sec_level == BT_SECURITY_LOW) {
+		if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0)
+			return hci_conn_auth(conn, sec_level);
+		else
+			return 1;
+	}
+
 	if (conn->link_mode & HCI_LM_ENCRYPT)
-		return hci_conn_auth(conn);
+		return hci_conn_auth(conn, sec_level);
 
 	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
 		return 0;
 
-	if (hci_conn_auth(conn)) {
+	if (hci_conn_auth(conn, sec_level)) {
 		struct hci_cp_set_conn_encrypt cp;
 		cp.handle  = cpu_to_le16(conn->handle);
 		cp.encrypt = 1;
 		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT,
 							sizeof(cp), &cp);
 	}
+
 	return 0;
 }
-EXPORT_SYMBOL(hci_conn_encrypt);
+EXPORT_SYMBOL(hci_conn_security);
 
 /* Change link key */
 int hci_conn_change_link_key(struct hci_conn *conn)
@@ -442,12 +455,13 @@ int hci_conn_change_link_key(struct hci_conn *conn)
 		hci_send_cmd(conn->hdev, HCI_OP_CHANGE_CONN_LINK_KEY,
 							sizeof(cp), &cp);
 	}
+
 	return 0;
 }
 EXPORT_SYMBOL(hci_conn_change_link_key);
 
 /* Switch role */
-int hci_conn_switch_role(struct hci_conn *conn, uint8_t role)
+int hci_conn_switch_role(struct hci_conn *conn, __u8 role)
 {
 	BT_DBG("conn %p", conn);
 
@@ -460,6 +474,7 @@ int hci_conn_switch_role(struct hci_conn *conn, uint8_t role)
 		cp.role = role;
 		hci_send_cmd(conn->hdev, HCI_OP_SWITCH_ROLE, sizeof(cp), &cp);
 	}
+
 	return 0;
 }
 EXPORT_SYMBOL(hci_conn_switch_role);

commit a418b893a6af11ae73c762ed5b76c1bad6dc19d8
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Nov 30 12:17:28 2008 +0100

    Bluetooth: Enable per-module dynamic debug messages
    
    With the introduction of CONFIG_DYNAMIC_PRINTK_DEBUG it is possible to
    allow debugging without having to recompile the kernel. This patch turns
    all BT_DBG() calls into pr_debug() to support dynamic debug messages.
    
    As a side effect all CONFIG_BT_*_DEBUG statements are now removed and
    some broken debug entries have been fixed.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index b7002429f152..a4a789f24c8d 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -45,11 +45,6 @@
 #include <net/bluetooth/bluetooth.h>
 #include <net/bluetooth/hci_core.h>
 
-#ifndef CONFIG_BT_HCI_CORE_DEBUG
-#undef  BT_DBG
-#define BT_DBG(D...)
-#endif
-
 void hci_acl_connect(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;

commit e7c29cb16c833441fd2160642bb13025f4e7ac70
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 9 07:19:20 2008 +0200

    [Bluetooth] Reject L2CAP connections on an insecure ACL link
    
    The Security Mode 4 of the Bluetooth 2.1 specification has strict
    authentication and encryption requirements. It is the initiators job
    to create a secure ACL link. However in case of malicious devices, the
    acceptor has to make sure that the ACL is encrypted before allowing
    any kind of L2CAP connection. The only exception here is the PSM 1 for
    the service discovery protocol, because that is allowed to run on an
    insecure ACL link.
    
    Previously it was enough to reject a L2CAP connection during the
    connection setup phase, but with Bluetooth 2.1 it is forbidden to
    do any L2CAP protocol exchange on an insecure link (except SDP).
    
    The new hci_conn_check_link_mode() function can be used to check the
    integrity of an ACL link. This functions also takes care of the cases
    where Security Mode 4 is disabled or one of the devices is based on
    an older specification.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a2f9efaa3361..b7002429f152 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -376,6 +376,19 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8
 }
 EXPORT_SYMBOL(hci_connect);
 
+/* Check link security requirement */
+int hci_conn_check_link_mode(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
+
+	if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0 &&
+					!(conn->link_mode & HCI_LM_ENCRYPT))
+		return 0;
+
+	return 1;
+}
+EXPORT_SYMBOL(hci_conn_check_link_mode);
+
 /* Authenticate remote device */
 int hci_conn_auth(struct hci_conn *conn)
 {

commit 09ab6f4c2376a0fc31abde1e2991513f900ea825
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 9 07:19:20 2008 +0200

    [Bluetooth] Enforce correct authentication requirements
    
    With the introduction of Security Mode 4 and Simple Pairing from the
    Bluetooth 2.1 specification it became mandatory that the initiator
    requires authentication and encryption before any L2CAP channel can
    be established. The only exception here is PSM 1 for the service
    discovery protocol (SDP). It is meant to be used without any encryption
    since it contains only public information. This is how Bluetooth 2.0
    and before handle connections on PSM 1.
    
    For Bluetooth 2.1 devices the pairing procedure differentiates between
    no bonding, general bonding and dedicated bonding. The L2CAP layer
    wrongly uses always general bonding when creating new connections, but it
    should not do this for SDP connections. In this case the authentication
    requirement should be no bonding and the just-works model should be used,
    but in case of non-SDP connection it is required to use general bonding.
    
    If the new connection requires man-in-the-middle (MITM) protection, it
    also first wrongly creates an unauthenticated link key and then later on
    requests an upgrade to an authenticated link key to provide full MITM
    protection. With Simple Pairing the link key generation is an expensive
    operation (compared to Bluetooth 2.0 and before) and doing this twice
    during a connection setup causes a noticeable delay when establishing
    a new connection. This should be avoided to not regress from the expected
    Bluetooth 2.0 connection times. The authentication requirements are known
    up-front and so enforce them.
    
    To fulfill these requirements the hci_connect() function has been extended
    with an authentication requirement parameter that will be stored inside
    the connection information and can be retrieved by userspace at any
    time. This allows the correct IO capabilities exchange and results in
    the expected behavior.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index ca8d05245ca0..a2f9efaa3361 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -330,7 +330,7 @@ EXPORT_SYMBOL(hci_get_route);
 
 /* Create SCO or ACL connection.
  * Device _must_ be locked */
-struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst)
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst, __u8 auth_type)
 {
 	struct hci_conn *acl;
 	struct hci_conn *sco;
@@ -344,8 +344,10 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	hci_conn_hold(acl);
 
-	if (acl->state == BT_OPEN || acl->state == BT_CLOSED)
+	if (acl->state == BT_OPEN || acl->state == BT_CLOSED) {
+		acl->auth_type = auth_type;
 		hci_acl_connect(acl);
+	}
 
 	if (type == ACL_LINK)
 		return acl;
@@ -381,7 +383,7 @@ int hci_conn_auth(struct hci_conn *conn)
 
 	if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0) {
 		if (!(conn->auth_type & 0x01)) {
-			conn->auth_type = HCI_AT_GENERAL_BONDING_MITM;
+			conn->auth_type |= 0x01;
 			conn->link_mode &= ~HCI_LM_AUTH;
 		}
 	}

commit 7d0db0a373195385a2e0b19d1f5e4b186fdcffac
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:51 2008 +0200

    [Bluetooth] Use a more unique bus name for connections
    
    When attaching Bluetooth low-level connections to the bus, the bus name
    is constructed from the remote address since at that time the connection
    handle is not assigned yet. This has worked so far, but also caused a
    lot of troubles. It is better to postpone the creation of the sysfs
    entry to the time when the connection actually has been established
    and then use its connection handle as unique identifier.
    
    This also fixes the case where two different adapters try to connect
    to the same remote device.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 0d4b8aeb8e09..ca8d05245ca0 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -245,8 +245,6 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
 
-	hci_conn_add_sysfs(conn);
-
 	tasklet_enable(&hdev->tx_task);
 
 	return conn;
@@ -278,12 +276,14 @@ int hci_conn_del(struct hci_conn *conn)
 	}
 
 	tasklet_disable(&hdev->tx_task);
+
 	hci_conn_hash_del(hdev, conn);
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
+
 	tasklet_enable(&hdev->tx_task);
+
 	skb_queue_purge(&conn->data_q);
-	hci_conn_del_sysfs(conn);
 
 	return 0;
 }
@@ -532,6 +532,8 @@ void hci_conn_hash_flush(struct hci_dev *hdev)
 
 		c->state = BT_CLOSED;
 
+		hci_conn_del_sysfs(c);
+
 		hci_proto_disconn_ind(c, 0x16);
 		hci_conn_del(c);
 	}

commit 40be492fe4fab829951681860c2bb26fa1d5fe4a
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:50 2008 +0200

    [Bluetooth] Export details about authentication requirements
    
    With the Simple Pairing support, the authentication requirements are
    an explicit setting during the bonding process. Track and enforce the
    requirements and allow higher layers like L2CAP and RFCOMM to increase
    them if needed.
    
    This patch introduces a new IOCTL that allows to query the current
    authentication requirements. It is also possible to detect Simple
    Pairing support in the kernel this way.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6f22533e7656..0d4b8aeb8e09 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -379,13 +379,21 @@ int hci_conn_auth(struct hci_conn *conn)
 {
 	BT_DBG("conn %p", conn);
 
+	if (conn->ssp_mode > 0 && conn->hdev->ssp_mode > 0) {
+		if (!(conn->auth_type & 0x01)) {
+			conn->auth_type = HCI_AT_GENERAL_BONDING_MITM;
+			conn->link_mode &= ~HCI_LM_AUTH;
+		}
+	}
+
 	if (conn->link_mode & HCI_LM_AUTH)
 		return 1;
 
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
 		struct hci_cp_auth_requested cp;
 		cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);
+		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED,
+							sizeof(cp), &cp);
 	}
 	return 0;
 }
@@ -397,7 +405,7 @@ int hci_conn_encrypt(struct hci_conn *conn)
 	BT_DBG("conn %p", conn);
 
 	if (conn->link_mode & HCI_LM_ENCRYPT)
-		return 1;
+		return hci_conn_auth(conn);
 
 	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
 		return 0;
@@ -406,7 +414,8 @@ int hci_conn_encrypt(struct hci_conn *conn)
 		struct hci_cp_set_conn_encrypt cp;
 		cp.handle  = cpu_to_le16(conn->handle);
 		cp.encrypt = 1;
-		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp), &cp);
+		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT,
+							sizeof(cp), &cp);
 	}
 	return 0;
 }
@@ -420,7 +429,8 @@ int hci_conn_change_link_key(struct hci_conn *conn)
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
 		struct hci_cp_change_conn_link_key cp;
 		cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(conn->hdev, HCI_OP_CHANGE_CONN_LINK_KEY, sizeof(cp), &cp);
+		hci_send_cmd(conn->hdev, HCI_OP_CHANGE_CONN_LINK_KEY,
+							sizeof(cp), &cp);
 	}
 	return 0;
 }
@@ -624,3 +634,23 @@ int hci_get_conn_info(struct hci_dev *hdev, void __user *arg)
 
 	return copy_to_user(ptr, &ci, sizeof(ci)) ? -EFAULT : 0;
 }
+
+int hci_get_auth_info(struct hci_dev *hdev, void __user *arg)
+{
+	struct hci_auth_info_req req;
+	struct hci_conn *conn;
+
+	if (copy_from_user(&req, arg, sizeof(req)))
+		return -EFAULT;
+
+	hci_dev_lock_bh(hdev);
+	conn = hci_conn_hash_lookup_ba(hdev, ACL_LINK, &req.bdaddr);
+	if (conn)
+		req.type = conn->auth_type;
+	hci_dev_unlock_bh(hdev);
+
+	if (!conn)
+		return -ENOENT;
+
+	return copy_to_user(arg, &req, sizeof(req)) ? -EFAULT : 0;
+}

commit 769be974d0c7b4fe1a52f9cdaad22259b60953f7
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:49 2008 +0200

    [Bluetooth] Use ACL config stage to retrieve remote features
    
    The Bluetooth technology introduces new features on a regular basis
    and for some of them it is important that the hardware on both sides
    support them. For features like Simple Pairing it is important that
    the host stacks on both sides have switched this feature on. To make
    valid decisions, a config stage during ACL link establishment has been
    introduced that retrieves remote features and if needed also the remote
    extended features (known as remote host features) before signalling
    this link as connected.
    
    This change introduces full reference counting of incoming and outgoing
    ACL links and the Bluetooth core will disconnect both if no owner of it
    is present. To better handle interoperability during the pairing phase
    the disconnect timeout for incoming connections has been increased to
    10 seconds. This is five times more than for outgoing connections.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 41351ba692e9..6f22533e7656 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -170,11 +170,13 @@ static void hci_conn_timeout(unsigned long arg)
 
 	switch (conn->state) {
 	case BT_CONNECT:
+	case BT_CONNECT2:
 		if (conn->type == ACL_LINK)
 			hci_acl_connect_cancel(conn);
 		else
 			hci_acl_disconn(conn, 0x13);
 		break;
+	case BT_CONFIG:
 	case BT_CONNECTED:
 		hci_acl_disconn(conn, 0x13);
 		break;

commit 41a96212b3b7b3cd59e8e8d33e6dabf0e21d9778
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:48 2008 +0200

    [Bluetooth] Track status of remote Simple Pairing mode
    
    The Simple Pairing process can only be used if both sides have the
    support enabled in the host stack. The current Bluetooth specification
    has three ways to detect this support.
    
    If an Extended Inquiry Result has been sent during inquiry then it
    is safe to assume that Simple Pairing is enabled. It is not allowed
    to enable Extended Inquiry without Simple Pairing. During the remote
    name request phase a notification with the remote host supported
    features will be sent to indicate Simple Pairing support. Also the
    second page of the remote extended features can indicate support for
    Simple Pairing.
    
    For all three cases the value of remote Simple Pairing mode is stored
    in the inquiry cache for later use.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6175ce841e9e..41351ba692e9 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -71,12 +71,16 @@ void hci_acl_connect(struct hci_conn *conn)
 	bacpy(&cp.bdaddr, &conn->dst);
 	cp.pscan_rep_mode = 0x02;
 
-	if ((ie = hci_inquiry_cache_lookup(hdev, &conn->dst)) &&
-			inquiry_entry_age(ie) <= INQUIRY_ENTRY_AGE_MAX) {
-		cp.pscan_rep_mode = ie->data.pscan_rep_mode;
-		cp.pscan_mode     = ie->data.pscan_mode;
-		cp.clock_offset   = ie->data.clock_offset | cpu_to_le16(0x8000);
+	if ((ie = hci_inquiry_cache_lookup(hdev, &conn->dst))) {
+		if (inquiry_entry_age(ie) <= INQUIRY_ENTRY_AGE_MAX) {
+			cp.pscan_rep_mode = ie->data.pscan_rep_mode;
+			cp.pscan_mode     = ie->data.pscan_mode;
+			cp.clock_offset   = ie->data.clock_offset |
+							cpu_to_le16(0x8000);
+		}
+
 		memcpy(conn->dev_class, ie->data.dev_class, 3);
+		conn->ssp_mode = ie->data.ssp_mode;
 	}
 
 	cp.pkt_type = cpu_to_le16(conn->pkt_type);

commit e4e8e37c42bdaaefcb84eeaef0dc1bc3f696f8f6
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:47 2008 +0200

    [Bluetooth] Make use of the default link policy settings
    
    The Bluetooth specification supports the default link policy settings
    on a per host controller basis. For every new connection the link
    manager would then use these settings. It is better to use this instead
    of bothering the controller on every connection setup to overwrite the
    default settings.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 69c64ce054fb..6175ce841e9e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -65,6 +65,8 @@ void hci_acl_connect(struct hci_conn *conn)
 
 	conn->attempt++;
 
+	conn->link_policy = hdev->link_policy;
+
 	memset(&cp, 0, sizeof(cp));
 	bacpy(&cp.bdaddr, &conn->dst);
 	cp.pscan_rep_mode = 0x02;

commit a8746417e864da1ed36dd2432a399fbeb843c2a0
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 14 20:13:46 2008 +0200

    [Bluetooth] Track connection packet type changes
    
    The connection packet type can be changed after the connection has been
    established and thus needs to be properly tracked to ensure that the
    host stack has always correct and valid information about it.
    
    On incoming connections the Bluetooth core switches the supported packet
    types to the configured list for this controller. However the usefulness
    of this feature has been questioned a lot. The general consent is that
    every Bluetooth host stack should enable as many packet types as the
    hardware actually supports and leave the decision to the link manager
    software running on the Bluetooth chip.
    
    When running on Bluetooth 2.0 or later hardware, don't change the packet
    type for incoming connections anymore. This hardware likely supports
    Enhanced Data Rate and thus leave it completely up to the link manager
    to pick the best packet type.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index f8880261da0e..69c64ce054fb 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -59,7 +59,8 @@ void hci_acl_connect(struct hci_conn *conn)
 	BT_DBG("%p", conn);
 
 	conn->state = BT_CONNECT;
-	conn->out   = 1;
+	conn->out = 1;
+
 	conn->link_mode = HCI_LM_MASTER;
 
 	conn->attempt++;
@@ -76,7 +77,7 @@ void hci_acl_connect(struct hci_conn *conn)
 		memcpy(conn->dev_class, ie->data.dev_class, 3);
 	}
 
-	cp.pkt_type = cpu_to_le16(hdev->pkt_type & ACL_PTYPE_MASK);
+	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))
 		cp.role_switch = 0x01;
 	else
@@ -122,7 +123,7 @@ void hci_add_sco(struct hci_conn *conn, __u16 handle)
 	conn->out = 1;
 
 	cp.handle   = cpu_to_le16(handle);
-	cp.pkt_type = cpu_to_le16(hdev->pkt_type & SCO_PTYPE_MASK);
+	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 
 	hci_send_cmd(hdev, HCI_OP_ADD_SCO, sizeof(cp), &cp);
 }
@@ -138,7 +139,7 @@ void hci_setup_sync(struct hci_conn *conn, __u16 handle)
 	conn->out = 1;
 
 	cp.handle   = cpu_to_le16(handle);
-	cp.pkt_type = cpu_to_le16(hdev->esco_type);
+	cp.pkt_type = cpu_to_le16(conn->pkt_type);
 
 	cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
 	cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
@@ -199,13 +200,28 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 		return NULL;
 
 	bacpy(&conn->dst, dst);
-	conn->hdev   = hdev;
-	conn->type   = type;
-	conn->mode   = HCI_CM_ACTIVE;
-	conn->state  = BT_OPEN;
+	conn->hdev  = hdev;
+	conn->type  = type;
+	conn->mode  = HCI_CM_ACTIVE;
+	conn->state = BT_OPEN;
 
 	conn->power_save = 1;
 
+	switch (type) {
+	case ACL_LINK:
+		conn->pkt_type = hdev->pkt_type & ACL_PTYPE_MASK;
+		break;
+	case SCO_LINK:
+		if (lmp_esco_capable(hdev))
+			conn->pkt_type = hdev->esco_type & SCO_ESCO_MASK;
+		else
+			conn->pkt_type = hdev->pkt_type & SCO_PTYPE_MASK;
+		break;
+	case ESCO_LINK:
+		conn->pkt_type = hdev->esco_type;
+		break;
+	}
+
 	skb_queue_head_init(&conn->data_q);
 
 	setup_timer(&conn->disc_timer, hci_conn_timeout, (unsigned long)conn);

commit 0cd63c8089f0f6316df1393c3a93bdbc67ab314d
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Mon Feb 18 20:44:01 2008 -0800

    bluetooth: put hci dev after del conn
    
    Move hci_dev_put to del_conn to avoid hci dev going away before hci conn.
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5fc7be206f62..f8880261da0e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -260,7 +260,6 @@ int hci_conn_del(struct hci_conn *conn)
 	tasklet_enable(&hdev->tx_task);
 	skb_queue_purge(&conn->data_q);
 	hci_conn_del_sysfs(conn);
-	hci_dev_put(hdev);
 
 	return 0;
 }

commit b24b8a247ff65c01b252025926fe564209fae4fc
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Wed Jan 23 21:20:07 2008 -0800

    [NET]: Convert init_timer into setup_timer
    
    Many-many code in the kernel initialized the timer->function
    and  timer->data together with calling init_timer(timer). There
    is already a helper for this. Use it for networking code.
    
    The patch is HUGE, but makes the code 130 lines shorter
    (98 insertions(+), 228 deletions(-)).
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Acked-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 34d1a3c822bf..5fc7be206f62 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -208,13 +208,8 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	skb_queue_head_init(&conn->data_q);
 
-	init_timer(&conn->disc_timer);
-	conn->disc_timer.function = hci_conn_timeout;
-	conn->disc_timer.data = (unsigned long) conn;
-
-	init_timer(&conn->idle_timer);
-	conn->idle_timer.function = hci_conn_idle;
-	conn->idle_timer.data = (unsigned long) conn;
+	setup_timer(&conn->disc_timer, hci_conn_timeout, (unsigned long)conn);
+	setup_timer(&conn->idle_timer, hci_conn_idle, (unsigned long)conn);
 
 	atomic_set(&conn->refcnt, 0);
 

commit 38b7da09cfdb2202f08476d6fb22a47649a177ec
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Sat Dec 29 19:17:47 2007 -0800

    [BLUETOOTH]: put_device before device_del fix
    
    Because of workqueue delay, the put_device could be called before
    device_del, so move it to del_conn.
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 9483320f6dad..34d1a3c822bf 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -259,22 +259,14 @@ int hci_conn_del(struct hci_conn *conn)
 	}
 
 	tasklet_disable(&hdev->tx_task);
-
-	hci_conn_del_sysfs(conn);
-
 	hci_conn_hash_del(hdev, conn);
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
-
 	tasklet_enable(&hdev->tx_task);
-
 	skb_queue_purge(&conn->data_q);
-
+	hci_conn_del_sysfs(conn);
 	hci_dev_put(hdev);
 
-	/* will free via device release */
-	put_device(&conn->dev);
-
 	return 0;
 }
 

commit b6a0dc822497e1c0b9e8c4add270cc27fce48454
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 20 14:55:10 2007 +0200

    [Bluetooth] Add support for handling simple eSCO links
    
    With the Bluetooth 1.2 specification the Extended SCO feature for
    better audio connections was introduced. So far the Bluetooth core
    wasn't able to handle any eSCO connections correctly. This patch
    adds simple eSCO support while keeping backward compatibility with
    older devices.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 797a30bec6fd..9483320f6dad 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -78,9 +78,9 @@ void hci_acl_connect(struct hci_conn *conn)
 
 	cp.pkt_type = cpu_to_le16(hdev->pkt_type & ACL_PTYPE_MASK);
 	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))
-		cp.role_switch	= 0x01;
+		cp.role_switch = 0x01;
 	else
-		cp.role_switch	= 0x00;
+		cp.role_switch = 0x00;
 
 	hci_send_cmd(hdev, HCI_OP_CREATE_CONN, sizeof(cp), &cp);
 }
@@ -127,6 +127,28 @@ void hci_add_sco(struct hci_conn *conn, __u16 handle)
 	hci_send_cmd(hdev, HCI_OP_ADD_SCO, sizeof(cp), &cp);
 }
 
+void hci_setup_sync(struct hci_conn *conn, __u16 handle)
+{
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_cp_setup_sync_conn cp;
+
+	BT_DBG("%p", conn);
+
+	conn->state = BT_CONNECT;
+	conn->out = 1;
+
+	cp.handle   = cpu_to_le16(handle);
+	cp.pkt_type = cpu_to_le16(hdev->esco_type);
+
+	cp.tx_bandwidth   = cpu_to_le32(0x00001f40);
+	cp.rx_bandwidth   = cpu_to_le32(0x00001f40);
+	cp.max_latency    = cpu_to_le16(0xffff);
+	cp.voice_setting  = cpu_to_le16(hdev->voice_setting);
+	cp.retrans_effort = 0xff;
+
+	hci_send_cmd(hdev, HCI_OP_SETUP_SYNC_CONN, sizeof(cp), &cp);
+}
+
 static void hci_conn_timeout(unsigned long arg)
 {
 	struct hci_conn *conn = (void *) arg;
@@ -141,7 +163,10 @@ static void hci_conn_timeout(unsigned long arg)
 
 	switch (conn->state) {
 	case BT_CONNECT:
-		hci_acl_connect_cancel(conn);
+		if (conn->type == ACL_LINK)
+			hci_acl_connect_cancel(conn);
+		else
+			hci_acl_disconn(conn, 0x13);
 		break;
 	case BT_CONNECTED:
 		hci_acl_disconn(conn, 0x13);
@@ -328,8 +353,12 @@ struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	hci_conn_hold(sco);
 
 	if (acl->state == BT_CONNECTED &&
-			(sco->state == BT_OPEN || sco->state == BT_CLOSED))
-		hci_add_sco(sco, acl->handle);
+			(sco->state == BT_OPEN || sco->state == BT_CLOSED)) {
+		if (lmp_esco_capable(hdev))
+			hci_setup_sync(sco, acl->handle);
+		else
+			hci_add_sco(sco, acl->handle);
+	}
 
 	return sco;
 }

commit a9de9248064bfc8eb0a183a6a951a4e7b5ca10a4
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sat Oct 20 13:33:56 2007 +0200

    [Bluetooth] Switch from OGF+OCF to using only opcodes
    
    The Bluetooth HCI commands are divided into logical OGF groups for
    easier identification of their purposes. While this still makes sense
    for the written specification, its makes the code only more complex
    and harder to read. So instead of using separate OGF and OCF values
    to identify the commands, use a common 16-bit opcode that combines
    both values. As a side effect this also reduces the complexity of
    OGF and OCF calculations during command header parsing.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5fdfc9a67d39..797a30bec6fd 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -82,7 +82,7 @@ void hci_acl_connect(struct hci_conn *conn)
 	else
 		cp.role_switch	= 0x00;
 
-	hci_send_cmd(hdev, OGF_LINK_CTL, OCF_CREATE_CONN, sizeof(cp), &cp);
+	hci_send_cmd(hdev, HCI_OP_CREATE_CONN, sizeof(cp), &cp);
 }
 
 static void hci_acl_connect_cancel(struct hci_conn *conn)
@@ -95,8 +95,7 @@ static void hci_acl_connect_cancel(struct hci_conn *conn)
 		return;
 
 	bacpy(&cp.bdaddr, &conn->dst);
-	hci_send_cmd(conn->hdev, OGF_LINK_CTL,
-				OCF_CREATE_CONN_CANCEL, sizeof(cp), &cp);
+	hci_send_cmd(conn->hdev, HCI_OP_CREATE_CONN_CANCEL, sizeof(cp), &cp);
 }
 
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
@@ -109,8 +108,7 @@ void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
 
 	cp.handle = cpu_to_le16(conn->handle);
 	cp.reason = reason;
-	hci_send_cmd(conn->hdev, OGF_LINK_CTL,
-				OCF_DISCONNECT, sizeof(cp), &cp);
+	hci_send_cmd(conn->hdev, HCI_OP_DISCONNECT, sizeof(cp), &cp);
 }
 
 void hci_add_sco(struct hci_conn *conn, __u16 handle)
@@ -126,7 +124,7 @@ void hci_add_sco(struct hci_conn *conn, __u16 handle)
 	cp.handle   = cpu_to_le16(handle);
 	cp.pkt_type = cpu_to_le16(hdev->pkt_type & SCO_PTYPE_MASK);
 
-	hci_send_cmd(hdev, OGF_LINK_CTL, OCF_ADD_SCO, sizeof(cp), &cp);
+	hci_send_cmd(hdev, HCI_OP_ADD_SCO, sizeof(cp), &cp);
 }
 
 static void hci_conn_timeout(unsigned long arg)
@@ -348,7 +346,7 @@ int hci_conn_auth(struct hci_conn *conn)
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
 		struct hci_cp_auth_requested cp;
 		cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_AUTH_REQUESTED, sizeof(cp), &cp);
+		hci_send_cmd(conn->hdev, HCI_OP_AUTH_REQUESTED, sizeof(cp), &cp);
 	}
 	return 0;
 }
@@ -369,7 +367,7 @@ int hci_conn_encrypt(struct hci_conn *conn)
 		struct hci_cp_set_conn_encrypt cp;
 		cp.handle  = cpu_to_le16(conn->handle);
 		cp.encrypt = 1;
-		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT, sizeof(cp), &cp);
+		hci_send_cmd(conn->hdev, HCI_OP_SET_CONN_ENCRYPT, sizeof(cp), &cp);
 	}
 	return 0;
 }
@@ -383,7 +381,7 @@ int hci_conn_change_link_key(struct hci_conn *conn)
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
 		struct hci_cp_change_conn_link_key cp;
 		cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_CHANGE_CONN_LINK_KEY, sizeof(cp), &cp);
+		hci_send_cmd(conn->hdev, HCI_OP_CHANGE_CONN_LINK_KEY, sizeof(cp), &cp);
 	}
 	return 0;
 }
@@ -401,7 +399,7 @@ int hci_conn_switch_role(struct hci_conn *conn, uint8_t role)
 		struct hci_cp_switch_role cp;
 		bacpy(&cp.bdaddr, &conn->dst);
 		cp.role = role;
-		hci_send_cmd(conn->hdev, OGF_LINK_POLICY, OCF_SWITCH_ROLE, sizeof(cp), &cp);
+		hci_send_cmd(conn->hdev, HCI_OP_SWITCH_ROLE, sizeof(cp), &cp);
 	}
 	return 0;
 }
@@ -423,8 +421,7 @@ void hci_conn_enter_active_mode(struct hci_conn *conn)
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
 		struct hci_cp_exit_sniff_mode cp;
 		cp.handle = cpu_to_le16(conn->handle);
-		hci_send_cmd(hdev, OGF_LINK_POLICY,
-				OCF_EXIT_SNIFF_MODE, sizeof(cp), &cp);
+		hci_send_cmd(hdev, HCI_OP_EXIT_SNIFF_MODE, sizeof(cp), &cp);
 	}
 
 timer:
@@ -455,8 +452,7 @@ void hci_conn_enter_sniff_mode(struct hci_conn *conn)
 		cp.max_latency        = cpu_to_le16(0);
 		cp.min_remote_timeout = cpu_to_le16(0);
 		cp.min_local_timeout  = cpu_to_le16(0);
-		hci_send_cmd(hdev, OGF_LINK_POLICY,
-				OCF_SNIFF_SUBRATE, sizeof(cp), &cp);
+		hci_send_cmd(hdev, HCI_OP_SNIFF_SUBRATE, sizeof(cp), &cp);
 	}
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
@@ -466,8 +462,7 @@ void hci_conn_enter_sniff_mode(struct hci_conn *conn)
 		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
 		cp.attempt      = cpu_to_le16(4);
 		cp.timeout      = cpu_to_le16(1);
-		hci_send_cmd(hdev, OGF_LINK_POLICY,
-				OCF_SNIFF_MODE, sizeof(cp), &cp);
+		hci_send_cmd(hdev, HCI_OP_SNIFF_MODE, sizeof(cp), &cp);
 	}
 }
 
@@ -493,6 +488,22 @@ void hci_conn_hash_flush(struct hci_dev *hdev)
 	}
 }
 
+/* Check pending connect attempts */
+void hci_conn_check_pending(struct hci_dev *hdev)
+{
+	struct hci_conn *conn;
+
+	BT_DBG("hdev %s", hdev->name);
+
+	hci_dev_lock(hdev);
+
+	conn = hci_conn_hash_lookup_state(hdev, ACL_LINK, BT_CONNECT2);
+	if (conn)
+		hci_acl_connect(conn);
+
+	hci_dev_unlock(hdev);
+}
+
 int hci_get_conn_list(void __user *arg)
 {
 	struct hci_conn_list_req req, *cl;

commit 5b7f990927fe87ad3bec762a33c0e72bcbf6841e
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Wed Jul 11 09:51:55 2007 +0200

    [Bluetooth] Add basics to better support and handle eSCO links
    
    To better support and handle eSCO links in the future a bunch of
    constants needs to be added and some basic routines need to be
    updated. This is the initial step.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 63980bd6b5f2..5fdfc9a67d39 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -123,8 +123,8 @@ void hci_add_sco(struct hci_conn *conn, __u16 handle)
 	conn->state = BT_CONNECT;
 	conn->out = 1;
 
-	cp.pkt_type = cpu_to_le16(hdev->pkt_type & SCO_PTYPE_MASK);
 	cp.handle   = cpu_to_le16(handle);
+	cp.pkt_type = cpu_to_le16(hdev->pkt_type & SCO_PTYPE_MASK);
 
 	hci_send_cmd(hdev, OGF_LINK_CTL, OCF_ADD_SCO, sizeof(cp), &cp);
 }
@@ -220,19 +220,19 @@ int hci_conn_del(struct hci_conn *conn)
 
 	del_timer(&conn->disc_timer);
 
-	if (conn->type == SCO_LINK) {
-		struct hci_conn *acl = conn->link;
-		if (acl) {
-			acl->link = NULL;
-			hci_conn_put(acl);
-		}
-	} else {
+	if (conn->type == ACL_LINK) {
 		struct hci_conn *sco = conn->link;
 		if (sco)
 			sco->link = NULL;
 
 		/* Unacked frames */
 		hdev->acl_cnt += conn->sent;
+	} else {
+		struct hci_conn *acl = conn->link;
+		if (acl) {
+			acl->link = NULL;
+			hci_conn_put(acl);
+		}
 	}
 
 	tasklet_disable(&hdev->tx_task);
@@ -297,9 +297,10 @@ EXPORT_SYMBOL(hci_get_route);
 
 /* Create SCO or ACL connection.
  * Device _must_ be locked */
-struct hci_conn * hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst)
+struct hci_conn *hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst)
 {
 	struct hci_conn *acl;
+	struct hci_conn *sco;
 
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
@@ -313,28 +314,26 @@ struct hci_conn * hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	if (acl->state == BT_OPEN || acl->state == BT_CLOSED)
 		hci_acl_connect(acl);
 
-	if (type == SCO_LINK) {
-		struct hci_conn *sco;
+	if (type == ACL_LINK)
+		return acl;
 
-		if (!(sco = hci_conn_hash_lookup_ba(hdev, SCO_LINK, dst))) {
-			if (!(sco = hci_conn_add(hdev, SCO_LINK, dst))) {
-				hci_conn_put(acl);
-				return NULL;
-			}
+	if (!(sco = hci_conn_hash_lookup_ba(hdev, type, dst))) {
+		if (!(sco = hci_conn_add(hdev, type, dst))) {
+			hci_conn_put(acl);
+			return NULL;
 		}
-		acl->link = sco;
-		sco->link = acl;
+	}
 
-		hci_conn_hold(sco);
+	acl->link = sco;
+	sco->link = acl;
 
-		if (acl->state == BT_CONNECTED &&
-				(sco->state == BT_OPEN || sco->state == BT_CLOSED))
-			hci_add_sco(sco, acl->handle);
+	hci_conn_hold(sco);
 
-		return sco;
-	} else {
-		return acl;
-	}
+	if (acl->state == BT_CONNECTED &&
+			(sco->state == BT_OPEN || sco->state == BT_CLOSED))
+		hci_add_sco(sco, acl->handle);
+
+	return sco;
 }
 EXPORT_SYMBOL(hci_connect);
 

commit aca3192cc60d2bf193c2252e45563c32e3117289
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Sun Mar 25 20:12:50 2007 -0700

    [NET] BLUETOOTH: Use cpu_to_le{16,32}() where appropriate.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index f3403fdb59f8..63980bd6b5f2 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -72,11 +72,11 @@ void hci_acl_connect(struct hci_conn *conn)
 			inquiry_entry_age(ie) <= INQUIRY_ENTRY_AGE_MAX) {
 		cp.pscan_rep_mode = ie->data.pscan_rep_mode;
 		cp.pscan_mode     = ie->data.pscan_mode;
-		cp.clock_offset   = ie->data.clock_offset | __cpu_to_le16(0x8000);
+		cp.clock_offset   = ie->data.clock_offset | cpu_to_le16(0x8000);
 		memcpy(conn->dev_class, ie->data.dev_class, 3);
 	}
 
-	cp.pkt_type = __cpu_to_le16(hdev->pkt_type & ACL_PTYPE_MASK);
+	cp.pkt_type = cpu_to_le16(hdev->pkt_type & ACL_PTYPE_MASK);
 	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))
 		cp.role_switch	= 0x01;
 	else
@@ -107,7 +107,7 @@ void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
 
 	conn->state = BT_DISCONN;
 
-	cp.handle = __cpu_to_le16(conn->handle);
+	cp.handle = cpu_to_le16(conn->handle);
 	cp.reason = reason;
 	hci_send_cmd(conn->hdev, OGF_LINK_CTL,
 				OCF_DISCONNECT, sizeof(cp), &cp);
@@ -123,8 +123,8 @@ void hci_add_sco(struct hci_conn *conn, __u16 handle)
 	conn->state = BT_CONNECT;
 	conn->out = 1;
 
-	cp.pkt_type = __cpu_to_le16(hdev->pkt_type & SCO_PTYPE_MASK);
-	cp.handle   = __cpu_to_le16(handle);
+	cp.pkt_type = cpu_to_le16(hdev->pkt_type & SCO_PTYPE_MASK);
+	cp.handle   = cpu_to_le16(handle);
 
 	hci_send_cmd(hdev, OGF_LINK_CTL, OCF_ADD_SCO, sizeof(cp), &cp);
 }
@@ -348,7 +348,7 @@ int hci_conn_auth(struct hci_conn *conn)
 
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
 		struct hci_cp_auth_requested cp;
-		cp.handle = __cpu_to_le16(conn->handle);
+		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_AUTH_REQUESTED, sizeof(cp), &cp);
 	}
 	return 0;
@@ -368,7 +368,7 @@ int hci_conn_encrypt(struct hci_conn *conn)
 
 	if (hci_conn_auth(conn)) {
 		struct hci_cp_set_conn_encrypt cp;
-		cp.handle  = __cpu_to_le16(conn->handle);
+		cp.handle  = cpu_to_le16(conn->handle);
 		cp.encrypt = 1;
 		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT, sizeof(cp), &cp);
 	}
@@ -383,7 +383,7 @@ int hci_conn_change_link_key(struct hci_conn *conn)
 
 	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
 		struct hci_cp_change_conn_link_key cp;
-		cp.handle = __cpu_to_le16(conn->handle);
+		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_CHANGE_CONN_LINK_KEY, sizeof(cp), &cp);
 	}
 	return 0;
@@ -423,7 +423,7 @@ void hci_conn_enter_active_mode(struct hci_conn *conn)
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
 		struct hci_cp_exit_sniff_mode cp;
-		cp.handle = __cpu_to_le16(conn->handle);
+		cp.handle = cpu_to_le16(conn->handle);
 		hci_send_cmd(hdev, OGF_LINK_POLICY,
 				OCF_EXIT_SNIFF_MODE, sizeof(cp), &cp);
 	}
@@ -452,21 +452,21 @@ void hci_conn_enter_sniff_mode(struct hci_conn *conn)
 
 	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
 		struct hci_cp_sniff_subrate cp;
-		cp.handle             = __cpu_to_le16(conn->handle);
-		cp.max_latency        = __constant_cpu_to_le16(0);
-		cp.min_remote_timeout = __constant_cpu_to_le16(0);
-		cp.min_local_timeout  = __constant_cpu_to_le16(0);
+		cp.handle             = cpu_to_le16(conn->handle);
+		cp.max_latency        = cpu_to_le16(0);
+		cp.min_remote_timeout = cpu_to_le16(0);
+		cp.min_local_timeout  = cpu_to_le16(0);
 		hci_send_cmd(hdev, OGF_LINK_POLICY,
 				OCF_SNIFF_SUBRATE, sizeof(cp), &cp);
 	}
 
 	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
 		struct hci_cp_sniff_mode cp;
-		cp.handle       = __cpu_to_le16(conn->handle);
-		cp.max_interval = __cpu_to_le16(hdev->sniff_max_interval);
-		cp.min_interval = __cpu_to_le16(hdev->sniff_min_interval);
-		cp.attempt      = __constant_cpu_to_le16(4);
-		cp.timeout      = __constant_cpu_to_le16(1);
+		cp.handle       = cpu_to_le16(conn->handle);
+		cp.max_interval = cpu_to_le16(hdev->sniff_max_interval);
+		cp.min_interval = cpu_to_le16(hdev->sniff_min_interval);
+		cp.attempt      = cpu_to_le16(4);
+		cp.timeout      = cpu_to_le16(1);
 		hci_send_cmd(hdev, OGF_LINK_POLICY,
 				OCF_SNIFF_MODE, sizeof(cp), &cp);
 	}

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 67ee0bd80f5f..f3403fdb59f8 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -29,7 +29,6 @@
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
-#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/poll.h>
 #include <linux/fcntl.h>

commit 8e87d14255acffeee36873de226dc25c11b5f46d
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Feb 9 23:24:33 2007 +0900

    [NET] BLUETOOTH: Fix whitespace errors.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 6cd5711fa28a..67ee0bd80f5f 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -1,4 +1,4 @@
-/* 
+/*
    BlueZ - Bluetooth protocol stack for Linux
    Copyright (C) 2000-2001 Qualcomm Incorporated
 
@@ -12,13 +12,13 @@
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
    IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
-   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES 
-   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
-   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 
-   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, 
-   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS 
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS,
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS
    SOFTWARE IS DISCLAIMED.
 */
 
@@ -146,7 +146,7 @@ static void hci_conn_timeout(unsigned long arg)
 	case BT_CONNECT:
 		hci_acl_connect_cancel(conn);
 		break;
- 	case BT_CONNECTED:
+	case BT_CONNECTED:
 		hci_acl_disconn(conn, 0x13);
 		break;
 	default:
@@ -272,7 +272,7 @@ struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
 		if (!test_bit(HCI_UP, &d->flags) || test_bit(HCI_RAW, &d->flags))
 			continue;
 
-		/* Simple routing: 
+		/* Simple routing:
 		 *   No source address - find interface with bdaddr != dst
 		 *   Source address    - find interface with bdaddr == src
 		 */
@@ -328,7 +328,7 @@ struct hci_conn * hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 		hci_conn_hold(sco);
 
-		if (acl->state == BT_CONNECTED && 
+		if (acl->state == BT_CONNECTED &&
 				(sco->state == BT_OPEN || sco->state == BT_CLOSED))
 			hci_add_sco(sco, acl->handle);
 
@@ -370,7 +370,7 @@ int hci_conn_encrypt(struct hci_conn *conn)
 	if (hci_conn_auth(conn)) {
 		struct hci_cp_set_conn_encrypt cp;
 		cp.handle  = __cpu_to_le16(conn->handle);
-		cp.encrypt = 1; 
+		cp.encrypt = 1;
 		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT, sizeof(cp), &cp);
 	}
 	return 0;

commit 4c67bc74f016b0d360b8573e18969c0ff7926974
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Sun Oct 15 17:30:56 2006 +0200

    [Bluetooth] Support concurrent connect requests
    
    Most Bluetooth chips don't support concurrent connect requests, because
    this would involve a multiple baseband page with only one radio. In the
    case an upper layer like L2CAP requests a concurrent connect these chips
    return the error "Command Disallowed" for the second request. If this
    happens it the responsibility of the Bluetooth core to queue the request
    and try again after the previous connect attempt has been completed.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 90e3a285a17e..6cd5711fa28a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -51,7 +51,7 @@
 #define BT_DBG(D...)
 #endif
 
-static void hci_acl_connect(struct hci_conn *conn)
+void hci_acl_connect(struct hci_conn *conn)
 {
 	struct hci_dev *hdev = conn->hdev;
 	struct inquiry_entry *ie;
@@ -63,6 +63,8 @@ static void hci_acl_connect(struct hci_conn *conn)
 	conn->out   = 1;
 	conn->link_mode = HCI_LM_MASTER;
 
+	conn->attempt++;
+
 	memset(&cp, 0, sizeof(cp));
 	bacpy(&cp.bdaddr, &conn->dst);
 	cp.pscan_rep_mode = 0x02;
@@ -80,7 +82,7 @@ static void hci_acl_connect(struct hci_conn *conn)
 		cp.role_switch	= 0x01;
 	else
 		cp.role_switch	= 0x00;
-		
+
 	hci_send_cmd(hdev, OGF_LINK_CTL, OCF_CREATE_CONN, sizeof(cp), &cp);
 }
 

commit 6ac59344ef25d5f0ebadb5663cf700d25d2a3886
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Tue Sep 26 09:43:48 2006 +0200

    [Bluetooth] Support create connection cancel command
    
    In case of non-blocking connects it is possible that the last user
    of an ACL link quits before the connection has been fully established.
    This will lead to a race condition where the internal state of a
    connection is closed, but the actual link has been established and is
    active. In case of Bluetooth 1.2 and later devices it is possible to
    call create connection cancel to abort the connect. For older devices
    the disconnect timer will be used to trigger the needed disconnect.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 7e9515b41cc0..90e3a285a17e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -84,6 +84,20 @@ static void hci_acl_connect(struct hci_conn *conn)
 	hci_send_cmd(hdev, OGF_LINK_CTL, OCF_CREATE_CONN, sizeof(cp), &cp);
 }
 
+static void hci_acl_connect_cancel(struct hci_conn *conn)
+{
+	struct hci_cp_create_conn_cancel cp;
+
+	BT_DBG("%p", conn);
+
+	if (conn->hdev->hci_ver < 2)
+		return;
+
+	bacpy(&cp.bdaddr, &conn->dst);
+	hci_send_cmd(conn->hdev, OGF_LINK_CTL,
+				OCF_CREATE_CONN_CANCEL, sizeof(cp), &cp);
+}
+
 void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
 {
 	struct hci_cp_disconnect cp;
@@ -94,7 +108,8 @@ void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
 
 	cp.handle = __cpu_to_le16(conn->handle);
 	cp.reason = reason;
-	hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_DISCONNECT, sizeof(cp), &cp);
+	hci_send_cmd(conn->hdev, OGF_LINK_CTL,
+				OCF_DISCONNECT, sizeof(cp), &cp);
 }
 
 void hci_add_sco(struct hci_conn *conn, __u16 handle)
@@ -124,12 +139,20 @@ static void hci_conn_timeout(unsigned long arg)
 		return;
 
 	hci_dev_lock(hdev);
- 	if (conn->state == BT_CONNECTED)
+
+	switch (conn->state) {
+	case BT_CONNECT:
+		hci_acl_connect_cancel(conn);
+		break;
+ 	case BT_CONNECTED:
 		hci_acl_disconn(conn, 0x13);
-	else
+		break;
+	default:
 		conn->state = BT_CLOSED;
+		break;
+	}
+
 	hci_dev_unlock(hdev);
-	return;
 }
 
 static void hci_conn_idle(unsigned long arg)

commit b219e3ac66183fc9771b94af931fb5fd41d586ec
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Thu Jul 6 12:38:46 2006 +0200

    [Bluetooth] Integrate low-level connections into the driver model
    
    This patch integrates the low-level connections (ACL and SCO) into the
    driver model. Every connection is presented as device with the parent
    set to its host controller device.
    
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 420ed4d7e57e..7e9515b41cc0 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -179,6 +179,8 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
 
+	hci_conn_add_sysfs(conn);
+
 	tasklet_enable(&hdev->tx_task);
 
 	return conn;
@@ -211,6 +213,8 @@ int hci_conn_del(struct hci_conn *conn)
 
 	tasklet_disable(&hdev->tx_task);
 
+	hci_conn_del_sysfs(conn);
+
 	hci_conn_hash_del(hdev, conn);
 	if (hdev->notify)
 		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
@@ -221,7 +225,9 @@ int hci_conn_del(struct hci_conn *conn)
 
 	hci_dev_put(hdev);
 
-	kfree(conn);
+	/* will free via device release */
+	put_device(&conn->dev);
+
 	return 0;
 }
 

commit 04837f6447c7f3ef114cda1ad761822dedbff8cf
Author: Marcel Holtmann <marcel@holtmann.org>
Date:   Mon Jul 3 10:02:33 2006 +0200

    [Bluetooth] Add automatic sniff mode support
    
    This patch introduces the automatic sniff mode feature. This allows
    the host to switch idle connections into sniff mode to safe power.
    
    Signed-off-by: Ulisses Furquim <ulissesf@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 5c0c2b1ef34a..420ed4d7e57e 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -115,8 +115,8 @@ void hci_add_sco(struct hci_conn *conn, __u16 handle)
 
 static void hci_conn_timeout(unsigned long arg)
 {
-	struct hci_conn *conn = (void *)arg;
-	struct hci_dev  *hdev = conn->hdev;
+	struct hci_conn *conn = (void *) arg;
+	struct hci_dev *hdev = conn->hdev;
 
 	BT_DBG("conn %p state %d", conn, conn->state);
 
@@ -132,11 +132,13 @@ static void hci_conn_timeout(unsigned long arg)
 	return;
 }
 
-static void hci_conn_init_timer(struct hci_conn *conn)
+static void hci_conn_idle(unsigned long arg)
 {
-	init_timer(&conn->timer);
-	conn->timer.function = hci_conn_timeout;
-	conn->timer.data = (unsigned long)conn;
+	struct hci_conn *conn = (void *) arg;
+
+	BT_DBG("conn %p mode %d", conn, conn->mode);
+
+	hci_conn_enter_sniff_mode(conn);
 }
 
 struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
@@ -145,17 +147,27 @@ struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
 
 	BT_DBG("%s dst %s", hdev->name, batostr(dst));
 
-	if (!(conn = kmalloc(sizeof(struct hci_conn), GFP_ATOMIC)))
+	conn = kzalloc(sizeof(struct hci_conn), GFP_ATOMIC);
+	if (!conn)
 		return NULL;
-	memset(conn, 0, sizeof(struct hci_conn));
 
 	bacpy(&conn->dst, dst);
-	conn->type   = type;
 	conn->hdev   = hdev;
+	conn->type   = type;
+	conn->mode   = HCI_CM_ACTIVE;
 	conn->state  = BT_OPEN;
 
+	conn->power_save = 1;
+
 	skb_queue_head_init(&conn->data_q);
-	hci_conn_init_timer(conn);
+
+	init_timer(&conn->disc_timer);
+	conn->disc_timer.function = hci_conn_timeout;
+	conn->disc_timer.data = (unsigned long) conn;
+
+	init_timer(&conn->idle_timer);
+	conn->idle_timer.function = hci_conn_idle;
+	conn->idle_timer.data = (unsigned long) conn;
 
 	atomic_set(&conn->refcnt, 0);
 
@@ -178,7 +190,9 @@ int hci_conn_del(struct hci_conn *conn)
 
 	BT_DBG("%s conn %p handle %d", hdev->name, conn, conn->handle);
 
-	hci_conn_del_timer(conn);
+	del_timer(&conn->idle_timer);
+
+	del_timer(&conn->disc_timer);
 
 	if (conn->type == SCO_LINK) {
 		struct hci_conn *acl = conn->link;
@@ -364,6 +378,70 @@ int hci_conn_switch_role(struct hci_conn *conn, uint8_t role)
 }
 EXPORT_SYMBOL(hci_conn_switch_role);
 
+/* Enter active mode */
+void hci_conn_enter_active_mode(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("conn %p mode %d", conn, conn->mode);
+
+	if (test_bit(HCI_RAW, &hdev->flags))
+		return;
+
+	if (conn->mode != HCI_CM_SNIFF || !conn->power_save)
+		goto timer;
+
+	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
+		struct hci_cp_exit_sniff_mode cp;
+		cp.handle = __cpu_to_le16(conn->handle);
+		hci_send_cmd(hdev, OGF_LINK_POLICY,
+				OCF_EXIT_SNIFF_MODE, sizeof(cp), &cp);
+	}
+
+timer:
+	if (hdev->idle_timeout > 0)
+		mod_timer(&conn->idle_timer,
+			jiffies + msecs_to_jiffies(hdev->idle_timeout));
+}
+
+/* Enter sniff mode */
+void hci_conn_enter_sniff_mode(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("conn %p mode %d", conn, conn->mode);
+
+	if (test_bit(HCI_RAW, &hdev->flags))
+		return;
+
+	if (!lmp_sniff_capable(hdev) || !lmp_sniff_capable(conn))
+		return;
+
+	if (conn->mode != HCI_CM_ACTIVE || !(conn->link_policy & HCI_LP_SNIFF))
+		return;
+
+	if (lmp_sniffsubr_capable(hdev) && lmp_sniffsubr_capable(conn)) {
+		struct hci_cp_sniff_subrate cp;
+		cp.handle             = __cpu_to_le16(conn->handle);
+		cp.max_latency        = __constant_cpu_to_le16(0);
+		cp.min_remote_timeout = __constant_cpu_to_le16(0);
+		cp.min_local_timeout  = __constant_cpu_to_le16(0);
+		hci_send_cmd(hdev, OGF_LINK_POLICY,
+				OCF_SNIFF_SUBRATE, sizeof(cp), &cp);
+	}
+
+	if (!test_and_set_bit(HCI_CONN_MODE_CHANGE_PEND, &conn->pend)) {
+		struct hci_cp_sniff_mode cp;
+		cp.handle       = __cpu_to_le16(conn->handle);
+		cp.max_interval = __cpu_to_le16(hdev->sniff_max_interval);
+		cp.min_interval = __cpu_to_le16(hdev->sniff_min_interval);
+		cp.attempt      = __constant_cpu_to_le16(4);
+		cp.timeout      = __constant_cpu_to_le16(1);
+		hci_send_cmd(hdev, OGF_LINK_POLICY,
+				OCF_SNIFF_MODE, sizeof(cp), &cp);
+	}
+}
+
 /* Drop all connection on the device */
 void hci_conn_hash_flush(struct hci_dev *hdev)
 {

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: JÃ¶rn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: JÃ¶rn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index f812ed129e58..5c0c2b1ef34a 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -24,7 +24,6 @@
 
 /* Bluetooth HCI connection handling. */
 
-#include <linux/config.h>
 #include <linux/module.h>
 
 #include <linux/types.h>

commit 12fe2c588df77d60dfe13b432f95d00f76b8c969
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Tue Jan 10 13:08:21 2006 -0800

    [NET]: Remove unneeded kmalloc() return value casts
    
    Get rid of needless casting of kmalloc() return value in net/
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index a31244e58888..f812ed129e58 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -403,7 +403,7 @@ int hci_get_conn_list(void __user *arg)
 
 	size = sizeof(req) + req.conn_num * sizeof(*ci);
 
-	if (!(cl = (void *) kmalloc(size, GFP_KERNEL)))
+	if (!(cl = kmalloc(size, GFP_KERNEL)))
 		return -ENOMEM;
 
 	if (!(hdev = hci_dev_get(req.dev_id))) {

commit b453257f057b834fdf9f4a6ad6133598b79bd982
Author: Al Viro <viro@www.linux.org.uk>
Date:   Mon Apr 25 18:32:13 2005 -0700

    [PATCH] kill gratitious includes of major.h under net/*
    
    A lot of places in there are including major.h for no reason whatsoever.
    Removed.  And yes, it still builds.
    
    The history of that stuff is often amusing.  E.g.  for net/core/sock.c
    the story looks so, as far as I've been able to reconstruct it: we used
    to need major.h in net/socket.c circa 1.1.early.  In 1.1.13 that need
    had disappeared, along with register_chrdev(SOCKET_MAJOR, "socket",
    &net_fops) in sock_init().  Include had not.  When 1.2 -> 1.3 reorg of
    net/* had moved a lot of stuff from net/socket.c to net/core/sock.c,
    this crap had followed...
    
    Signed-off-by: Al Viro <viro@parcelfarce.linux.theplanet.co.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
index 71762d7e9970..a31244e58888 100644
--- a/net/bluetooth/hci_conn.c
+++ b/net/bluetooth/hci_conn.c
@@ -30,7 +30,6 @@
 #include <linux/types.h>
 #include <linux/errno.h>
 #include <linux/kernel.h>
-#include <linux/major.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/poll.h>

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/net/bluetooth/hci_conn.c b/net/bluetooth/hci_conn.c
new file mode 100644
index 000000000000..71762d7e9970
--- /dev/null
+++ b/net/bluetooth/hci_conn.c
@@ -0,0 +1,471 @@
+/* 
+   BlueZ - Bluetooth protocol stack for Linux
+   Copyright (C) 2000-2001 Qualcomm Incorporated
+
+   Written 2000,2001 by Maxim Krasnyansky <maxk@qualcomm.com>
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License version 2 as
+   published by the Free Software Foundation;
+
+   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY RIGHTS.
+   IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) AND AUTHOR(S) BE LIABLE FOR ANY
+   CLAIM, OR ANY SPECIAL INDIRECT OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES 
+   WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN 
+   ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF 
+   OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
+   ALL LIABILITY, INCLUDING LIABILITY FOR INFRINGEMENT OF ANY PATENTS, 
+   COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS, RELATING TO USE OF THIS 
+   SOFTWARE IS DISCLAIMED.
+*/
+
+/* Bluetooth HCI connection handling. */
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/major.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/poll.h>
+#include <linux/fcntl.h>
+#include <linux/init.h>
+#include <linux/skbuff.h>
+#include <linux/interrupt.h>
+#include <linux/notifier.h>
+#include <net/sock.h>
+
+#include <asm/system.h>
+#include <asm/uaccess.h>
+#include <asm/unaligned.h>
+
+#include <net/bluetooth/bluetooth.h>
+#include <net/bluetooth/hci_core.h>
+
+#ifndef CONFIG_BT_HCI_CORE_DEBUG
+#undef  BT_DBG
+#define BT_DBG(D...)
+#endif
+
+static void hci_acl_connect(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+	struct inquiry_entry *ie;
+	struct hci_cp_create_conn cp;
+
+	BT_DBG("%p", conn);
+
+	conn->state = BT_CONNECT;
+	conn->out   = 1;
+	conn->link_mode = HCI_LM_MASTER;
+
+	memset(&cp, 0, sizeof(cp));
+	bacpy(&cp.bdaddr, &conn->dst);
+	cp.pscan_rep_mode = 0x02;
+
+	if ((ie = hci_inquiry_cache_lookup(hdev, &conn->dst)) &&
+			inquiry_entry_age(ie) <= INQUIRY_ENTRY_AGE_MAX) {
+		cp.pscan_rep_mode = ie->data.pscan_rep_mode;
+		cp.pscan_mode     = ie->data.pscan_mode;
+		cp.clock_offset   = ie->data.clock_offset | __cpu_to_le16(0x8000);
+		memcpy(conn->dev_class, ie->data.dev_class, 3);
+	}
+
+	cp.pkt_type = __cpu_to_le16(hdev->pkt_type & ACL_PTYPE_MASK);
+	if (lmp_rswitch_capable(hdev) && !(hdev->link_mode & HCI_LM_MASTER))
+		cp.role_switch	= 0x01;
+	else
+		cp.role_switch	= 0x00;
+		
+	hci_send_cmd(hdev, OGF_LINK_CTL, OCF_CREATE_CONN, sizeof(cp), &cp);
+}
+
+void hci_acl_disconn(struct hci_conn *conn, __u8 reason)
+{
+	struct hci_cp_disconnect cp;
+
+	BT_DBG("%p", conn);
+
+	conn->state = BT_DISCONN;
+
+	cp.handle = __cpu_to_le16(conn->handle);
+	cp.reason = reason;
+	hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_DISCONNECT, sizeof(cp), &cp);
+}
+
+void hci_add_sco(struct hci_conn *conn, __u16 handle)
+{
+	struct hci_dev *hdev = conn->hdev;
+	struct hci_cp_add_sco cp;
+
+	BT_DBG("%p", conn);
+
+	conn->state = BT_CONNECT;
+	conn->out = 1;
+
+	cp.pkt_type = __cpu_to_le16(hdev->pkt_type & SCO_PTYPE_MASK);
+	cp.handle   = __cpu_to_le16(handle);
+
+	hci_send_cmd(hdev, OGF_LINK_CTL, OCF_ADD_SCO, sizeof(cp), &cp);
+}
+
+static void hci_conn_timeout(unsigned long arg)
+{
+	struct hci_conn *conn = (void *)arg;
+	struct hci_dev  *hdev = conn->hdev;
+
+	BT_DBG("conn %p state %d", conn, conn->state);
+
+	if (atomic_read(&conn->refcnt))
+		return;
+
+	hci_dev_lock(hdev);
+ 	if (conn->state == BT_CONNECTED)
+		hci_acl_disconn(conn, 0x13);
+	else
+		conn->state = BT_CLOSED;
+	hci_dev_unlock(hdev);
+	return;
+}
+
+static void hci_conn_init_timer(struct hci_conn *conn)
+{
+	init_timer(&conn->timer);
+	conn->timer.function = hci_conn_timeout;
+	conn->timer.data = (unsigned long)conn;
+}
+
+struct hci_conn *hci_conn_add(struct hci_dev *hdev, int type, bdaddr_t *dst)
+{
+	struct hci_conn *conn;
+
+	BT_DBG("%s dst %s", hdev->name, batostr(dst));
+
+	if (!(conn = kmalloc(sizeof(struct hci_conn), GFP_ATOMIC)))
+		return NULL;
+	memset(conn, 0, sizeof(struct hci_conn));
+
+	bacpy(&conn->dst, dst);
+	conn->type   = type;
+	conn->hdev   = hdev;
+	conn->state  = BT_OPEN;
+
+	skb_queue_head_init(&conn->data_q);
+	hci_conn_init_timer(conn);
+
+	atomic_set(&conn->refcnt, 0);
+
+	hci_dev_hold(hdev);
+
+	tasklet_disable(&hdev->tx_task);
+
+	hci_conn_hash_add(hdev, conn);
+	if (hdev->notify)
+		hdev->notify(hdev, HCI_NOTIFY_CONN_ADD);
+
+	tasklet_enable(&hdev->tx_task);
+
+	return conn;
+}
+
+int hci_conn_del(struct hci_conn *conn)
+{
+	struct hci_dev *hdev = conn->hdev;
+
+	BT_DBG("%s conn %p handle %d", hdev->name, conn, conn->handle);
+
+	hci_conn_del_timer(conn);
+
+	if (conn->type == SCO_LINK) {
+		struct hci_conn *acl = conn->link;
+		if (acl) {
+			acl->link = NULL;
+			hci_conn_put(acl);
+		}
+	} else {
+		struct hci_conn *sco = conn->link;
+		if (sco)
+			sco->link = NULL;
+
+		/* Unacked frames */
+		hdev->acl_cnt += conn->sent;
+	}
+
+	tasklet_disable(&hdev->tx_task);
+
+	hci_conn_hash_del(hdev, conn);
+	if (hdev->notify)
+		hdev->notify(hdev, HCI_NOTIFY_CONN_DEL);
+
+	tasklet_enable(&hdev->tx_task);
+
+	skb_queue_purge(&conn->data_q);
+
+	hci_dev_put(hdev);
+
+	kfree(conn);
+	return 0;
+}
+
+struct hci_dev *hci_get_route(bdaddr_t *dst, bdaddr_t *src)
+{
+	int use_src = bacmp(src, BDADDR_ANY);
+	struct hci_dev *hdev = NULL;
+	struct list_head *p;
+
+	BT_DBG("%s -> %s", batostr(src), batostr(dst));
+
+	read_lock_bh(&hci_dev_list_lock);
+
+	list_for_each(p, &hci_dev_list) {
+		struct hci_dev *d = list_entry(p, struct hci_dev, list);
+
+		if (!test_bit(HCI_UP, &d->flags) || test_bit(HCI_RAW, &d->flags))
+			continue;
+
+		/* Simple routing: 
+		 *   No source address - find interface with bdaddr != dst
+		 *   Source address    - find interface with bdaddr == src
+		 */
+
+		if (use_src) {
+			if (!bacmp(&d->bdaddr, src)) {
+				hdev = d; break;
+			}
+		} else {
+			if (bacmp(&d->bdaddr, dst)) {
+				hdev = d; break;
+			}
+		}
+	}
+
+	if (hdev)
+		hdev = hci_dev_hold(hdev);
+
+	read_unlock_bh(&hci_dev_list_lock);
+	return hdev;
+}
+EXPORT_SYMBOL(hci_get_route);
+
+/* Create SCO or ACL connection.
+ * Device _must_ be locked */
+struct hci_conn * hci_connect(struct hci_dev *hdev, int type, bdaddr_t *dst)
+{
+	struct hci_conn *acl;
+
+	BT_DBG("%s dst %s", hdev->name, batostr(dst));
+
+	if (!(acl = hci_conn_hash_lookup_ba(hdev, ACL_LINK, dst))) {
+		if (!(acl = hci_conn_add(hdev, ACL_LINK, dst)))
+			return NULL;
+	}
+
+	hci_conn_hold(acl);
+
+	if (acl->state == BT_OPEN || acl->state == BT_CLOSED)
+		hci_acl_connect(acl);
+
+	if (type == SCO_LINK) {
+		struct hci_conn *sco;
+
+		if (!(sco = hci_conn_hash_lookup_ba(hdev, SCO_LINK, dst))) {
+			if (!(sco = hci_conn_add(hdev, SCO_LINK, dst))) {
+				hci_conn_put(acl);
+				return NULL;
+			}
+		}
+		acl->link = sco;
+		sco->link = acl;
+
+		hci_conn_hold(sco);
+
+		if (acl->state == BT_CONNECTED && 
+				(sco->state == BT_OPEN || sco->state == BT_CLOSED))
+			hci_add_sco(sco, acl->handle);
+
+		return sco;
+	} else {
+		return acl;
+	}
+}
+EXPORT_SYMBOL(hci_connect);
+
+/* Authenticate remote device */
+int hci_conn_auth(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
+
+	if (conn->link_mode & HCI_LM_AUTH)
+		return 1;
+
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
+		struct hci_cp_auth_requested cp;
+		cp.handle = __cpu_to_le16(conn->handle);
+		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_AUTH_REQUESTED, sizeof(cp), &cp);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(hci_conn_auth);
+
+/* Enable encryption */
+int hci_conn_encrypt(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
+
+	if (conn->link_mode & HCI_LM_ENCRYPT)
+		return 1;
+
+	if (test_and_set_bit(HCI_CONN_ENCRYPT_PEND, &conn->pend))
+		return 0;
+
+	if (hci_conn_auth(conn)) {
+		struct hci_cp_set_conn_encrypt cp;
+		cp.handle  = __cpu_to_le16(conn->handle);
+		cp.encrypt = 1; 
+		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_SET_CONN_ENCRYPT, sizeof(cp), &cp);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(hci_conn_encrypt);
+
+/* Change link key */
+int hci_conn_change_link_key(struct hci_conn *conn)
+{
+	BT_DBG("conn %p", conn);
+
+	if (!test_and_set_bit(HCI_CONN_AUTH_PEND, &conn->pend)) {
+		struct hci_cp_change_conn_link_key cp;
+		cp.handle = __cpu_to_le16(conn->handle);
+		hci_send_cmd(conn->hdev, OGF_LINK_CTL, OCF_CHANGE_CONN_LINK_KEY, sizeof(cp), &cp);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(hci_conn_change_link_key);
+
+/* Switch role */
+int hci_conn_switch_role(struct hci_conn *conn, uint8_t role)
+{
+	BT_DBG("conn %p", conn);
+
+	if (!role && conn->link_mode & HCI_LM_MASTER)
+		return 1;
+
+	if (!test_and_set_bit(HCI_CONN_RSWITCH_PEND, &conn->pend)) {
+		struct hci_cp_switch_role cp;
+		bacpy(&cp.bdaddr, &conn->dst);
+		cp.role = role;
+		hci_send_cmd(conn->hdev, OGF_LINK_POLICY, OCF_SWITCH_ROLE, sizeof(cp), &cp);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(hci_conn_switch_role);
+
+/* Drop all connection on the device */
+void hci_conn_hash_flush(struct hci_dev *hdev)
+{
+	struct hci_conn_hash *h = &hdev->conn_hash;
+	struct list_head *p;
+
+	BT_DBG("hdev %s", hdev->name);
+
+	p = h->list.next;
+	while (p != &h->list) {
+		struct hci_conn *c;
+
+		c = list_entry(p, struct hci_conn, list);
+		p = p->next;
+
+		c->state = BT_CLOSED;
+
+		hci_proto_disconn_ind(c, 0x16);
+		hci_conn_del(c);
+	}
+}
+
+int hci_get_conn_list(void __user *arg)
+{
+	struct hci_conn_list_req req, *cl;
+	struct hci_conn_info *ci;
+	struct hci_dev *hdev;
+	struct list_head *p;
+	int n = 0, size, err;
+
+	if (copy_from_user(&req, arg, sizeof(req)))
+		return -EFAULT;
+
+	if (!req.conn_num || req.conn_num > (PAGE_SIZE * 2) / sizeof(*ci))
+		return -EINVAL;
+
+	size = sizeof(req) + req.conn_num * sizeof(*ci);
+
+	if (!(cl = (void *) kmalloc(size, GFP_KERNEL)))
+		return -ENOMEM;
+
+	if (!(hdev = hci_dev_get(req.dev_id))) {
+		kfree(cl);
+		return -ENODEV;
+	}
+
+	ci = cl->conn_info;
+
+	hci_dev_lock_bh(hdev);
+	list_for_each(p, &hdev->conn_hash.list) {
+		register struct hci_conn *c;
+		c = list_entry(p, struct hci_conn, list);
+
+		bacpy(&(ci + n)->bdaddr, &c->dst);
+		(ci + n)->handle = c->handle;
+		(ci + n)->type  = c->type;
+		(ci + n)->out   = c->out;
+		(ci + n)->state = c->state;
+		(ci + n)->link_mode = c->link_mode;
+		if (++n >= req.conn_num)
+			break;
+	}
+	hci_dev_unlock_bh(hdev);
+
+	cl->dev_id = hdev->id;
+	cl->conn_num = n;
+	size = sizeof(req) + n * sizeof(*ci);
+
+	hci_dev_put(hdev);
+
+	err = copy_to_user(arg, cl, size);
+	kfree(cl);
+
+	return err ? -EFAULT : 0;
+}
+
+int hci_get_conn_info(struct hci_dev *hdev, void __user *arg)
+{
+	struct hci_conn_info_req req;
+	struct hci_conn_info ci;
+	struct hci_conn *conn;
+	char __user *ptr = arg + sizeof(req);
+
+	if (copy_from_user(&req, arg, sizeof(req)))
+		return -EFAULT;
+
+	hci_dev_lock_bh(hdev);
+	conn = hci_conn_hash_lookup_ba(hdev, req.type, &req.bdaddr);
+	if (conn) {
+		bacpy(&ci.bdaddr, &conn->dst);
+		ci.handle = conn->handle;
+		ci.type  = conn->type;
+		ci.out   = conn->out;
+		ci.state = conn->state;
+		ci.link_mode = conn->link_mode;
+	}
+	hci_dev_unlock_bh(hdev);
+
+	if (!conn)
+		return -ENOENT;
+
+	return copy_to_user(ptr, &ci, sizeof(ci)) ? -EFAULT : 0;
+}
