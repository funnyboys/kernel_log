commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index bd88a9b80773..1cf5ac09edcb 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -1,15 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright 2007-2012 Siemens AG
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * Written by:
  * Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
  * Sergey Lapin <slapin@ossfans.org>

commit cf124db566e6b036b8bcbe8decbed740bdfac8c6
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 8 12:52:56 2017 -0400

    net: Fix inconsistent teardown and release of private netdev state.
    
    Network devices can allocate reasources and private memory using
    netdev_ops->ndo_init().  However, the release of these resources
    can occur in one of two different places.
    
    Either netdev_ops->ndo_uninit() or netdev->destructor().
    
    The decision of which operation frees the resources depends upon
    whether it is necessary for all netdev refs to be released before it
    is safe to perform the freeing.
    
    netdev_ops->ndo_uninit() presumably can occur right after the
    NETDEV_UNREGISTER notifier completes and the unicast and multicast
    address lists are flushed.
    
    netdev->destructor(), on the other hand, does not run until the
    netdev references all go away.
    
    Further complicating the situation is that netdev->destructor()
    almost universally does also a free_netdev().
    
    This creates a problem for the logic in register_netdevice().
    Because all callers of register_netdevice() manage the freeing
    of the netdev, and invoke free_netdev(dev) if register_netdevice()
    fails.
    
    If netdev_ops->ndo_init() succeeds, but something else fails inside
    of register_netdevice(), it does call ndo_ops->ndo_uninit().  But
    it is not able to invoke netdev->destructor().
    
    This is because netdev->destructor() will do a free_netdev() and
    then the caller of register_netdevice() will do the same.
    
    However, this means that the resources that would normally be released
    by netdev->destructor() will not be.
    
    Over the years drivers have added local hacks to deal with this, by
    invoking their destructor parts by hand when register_netdevice()
    fails.
    
    Many drivers do not try to deal with this, and instead we have leaks.
    
    Let's close this hole by formalizing the distinction between what
    private things need to be freed up by netdev->destructor() and whether
    the driver needs unregister_netdevice() to perform the free_netdev().
    
    netdev->priv_destructor() performs all actions to free up the private
    resources that used to be freed by netdev->destructor(), except for
    free_netdev().
    
    netdev->needs_free_netdev is a boolean that indicates whether
    free_netdev() should be done at the end of unregister_netdevice().
    
    Now, register_netdevice() can sanely release all resources after
    ndo_ops->ndo_init() succeeds, by invoking both ndo_ops->ndo_uninit()
    and netdev->priv_destructor().
    
    And at the end of unregister_netdevice(), we invoke
    netdev->priv_destructor() and optionally call free_netdev().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 06019dba4b10..bd88a9b80773 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -526,8 +526,6 @@ static void mac802154_wpan_free(struct net_device *dev)
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	mac802154_llsec_destroy(&sdata->sec);
-
-	free_netdev(dev);
 }
 
 static void ieee802154_if_setup(struct net_device *dev)
@@ -593,7 +591,8 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 					sdata->dev->dev_addr);
 
 		sdata->dev->header_ops = &mac802154_header_ops;
-		sdata->dev->destructor = mac802154_wpan_free;
+		sdata->dev->needs_free_netdev = true;
+		sdata->dev->priv_destructor = mac802154_wpan_free;
 		sdata->dev->netdev_ops = &mac802154_wpan_ops;
 		sdata->dev->ml_priv = &mac802154_mlme_wpan;
 		wpan_dev->promiscuous_mode = false;
@@ -608,7 +607,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 
 		break;
 	case NL802154_IFTYPE_MONITOR:
-		sdata->dev->destructor = free_netdev;
+		sdata->dev->needs_free_netdev = true;
 		sdata->dev->netdev_ops = &mac802154_monitor_ops;
 		wpan_dev->promiscuous_mode = true;
 		break;

commit abbcc341adb16f68915cae7ef9a10e0d7b57e3c0
Author: Alexander Aring <aar@pengutronix.de>
Date:   Sun Jul 24 16:12:24 2016 +0200

    mac802154: set phy net namespace for new ifaces
    
    This patch sets the net namespace when creating SoftMAC interfaces. This
    is important if the namespace at phy layer was switched before.
    Currently we losing interfaces in some namespace and it's not possible
    to recover that.
    
    Signed-off-by: Alexander Aring <aar@pengutronix.de>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 7079cd32a7ad..06019dba4b10 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -663,6 +663,7 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 
 	/* TODO check this */
 	SET_NETDEV_DEV(ndev, &local->phy->dev);
+	dev_net_set(ndev, wpan_phy_net(local->hw.phy));
 	sdata = netdev_priv(ndev);
 	ndev->ieee802154_ptr = &sdata->wpan_dev;
 	memcpy(sdata->name, ndev->name, IFNAMSIZ);

commit b40988c438c2405a177ae54ff4baa08c720c296f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Sep 28 12:36:26 2015 +0200

    ieee802154: change mtu size behaviour
    
    This patch changes the mtu size of 802.15.4 interfaces. The current
    setting is the meaning of the maximum transport unit with mac header,
    which is 127 bytes according 802.15.4. The linux meaning of the mtu size
    field is the maximum payload of a mac frame. Like in ethernet, which is
    1500 bytes.
    
    We have dynamic length of mac frames in 802.15.4, this is why we assume
    the minimum header length which is hard_header_len. This contains fc and
    sequence fields. These can evaluated by driver layer without additional
    checks. We currently don't support to set the FCS from userspace, so we
    need to subtract this from mtu size as well.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 3954bcff70e4..7079cd32a7ad 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -547,7 +547,17 @@ static void ieee802154_if_setup(struct net_device *dev)
 	 */
 	dev->needed_tailroom	= IEEE802154_MAX_AUTH_TAG_LEN +
 				  IEEE802154_FCS_LEN;
-	dev->mtu		= IEEE802154_MTU;
+	/* The mtu size is the payload without mac header in this case.
+	 * We have a dynamic length header with a minimum header length
+	 * which is hard_header_len. In this case we let mtu to the size
+	 * of maximum payload which is IEEE802154_MTU - IEEE802154_FCS_LEN -
+	 * hard_header_len. The FCS which is set by hardware or ndo_start_xmit
+	 * and the minimum mac header which can be evaluated inside driver
+	 * layer. The rest of mac header will be part of payload if greater
+	 * than hard_header_len.
+	 */
+	dev->mtu		= IEEE802154_MTU - IEEE802154_FCS_LEN -
+				  dev->hard_header_len;
 	dev->tx_queue_len	= 300;
 	dev->flags		= IFF_NOARP | IFF_BROADCAST;
 }

commit c2d5ecfaeafdedfb997a466c654c7029c511f43d
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Thu Sep 24 09:37:11 2015 +0200

    mac802154: iface: assume big endian for af_packet
    
    The callback "create" and "parse" from header_ops are called from
    netdev core upper-layer functionality, like af_packet. These callbacks
    assumes big endian for addresses and we should not introduce a special
    byteordering handling for ieee802154 over af_packet in userspace.
    
    We have an identical issue with setting the mac address which also
    assumes big endian byteordering.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index b5a0936ce514..3954bcff70e4 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -461,7 +461,7 @@ static int mac802154_header_create(struct sk_buff *skb,
 
 	hdr.dest.pan_id = wpan_dev->pan_id;
 	hdr.dest.mode = IEEE802154_ADDR_LONG;
-	memcpy(&hdr.dest.extended_addr, daddr, IEEE802154_EXTENDED_ADDR_LEN);
+	ieee802154_be64_to_le64(&hdr.dest.extended_addr, daddr);
 
 	hdr.source.pan_id = hdr.dest.pan_id;
 	hdr.source.mode = IEEE802154_ADDR_LONG;
@@ -469,8 +469,7 @@ static int mac802154_header_create(struct sk_buff *skb,
 	if (!saddr)
 		hdr.source.extended_addr = wpan_dev->extended_addr;
 	else
-		memcpy(&hdr.source.extended_addr, saddr,
-		       IEEE802154_EXTENDED_ADDR_LEN);
+		ieee802154_be64_to_le64(&hdr.source.extended_addr, saddr);
 
 	hlen = ieee802154_hdr_push(skb, &hdr);
 	if (hlen < 0)
@@ -496,8 +495,7 @@ mac802154_header_parse(const struct sk_buff *skb, unsigned char *haddr)
 	}
 
 	if (hdr.source.mode == IEEE802154_ADDR_LONG) {
-		memcpy(haddr, &hdr.source.extended_addr,
-		       IEEE802154_EXTENDED_ADDR_LEN);
+		ieee802154_le64_to_be64(haddr, &hdr.source.extended_addr);
 		return IEEE802154_EXTENDED_ADDR_LEN;
 	}
 

commit 87a93e4eceb495f93e3f37b100334d2641765b6c
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri Sep 18 11:30:43 2015 +0200

    ieee802154: change needed headroom/tailroom
    
    This patch cleanups needed_headroom, needed_tailroom and hard_header_len
    fields for wpan and lowpan interfaces.
    
    For wpan interfaces the worst case mac header len should be part of
    needed_headroom, currently this is set as hard_header_len, but
    hard_header_len should be set to the minimum header length which xmit
    call assumes and this is the minimum frame length of 802.15.4.
    The hard_header_len value will check inside send callbacl of AF_PACKET
    raw sockets.
    
    For lowpan interfaces, if fragmentation isn't needed the skb will
    call dev_hard_header for 802154 layer and queue it afterwards. This
    happens without new skb allocation, so we need the same headroom and
    tailroom lengths like 802154 inside 802154 6lowpan layer. At least we
    assume as minimum header length an ipv6 header size.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 8afe26d72971..b5a0936ce514 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -537,8 +537,18 @@ static void ieee802154_if_setup(struct net_device *dev)
 	dev->addr_len		= IEEE802154_EXTENDED_ADDR_LEN;
 	memset(dev->broadcast, 0xff, IEEE802154_EXTENDED_ADDR_LEN);
 
-	dev->hard_header_len	= MAC802154_FRAME_HARD_HEADER_LEN;
-	dev->needed_tailroom	= 2 + 16; /* FCS + MIC */
+	/* Let hard_header_len set to IEEE802154_MIN_HEADER_LEN. AF_PACKET
+	 * will not send frames without any payload, but ack frames
+	 * has no payload, so substract one that we can send a 3 bytes
+	 * frame. The xmit callback assumes at least a hard header where two
+	 * bytes fc and sequence field are set.
+	 */
+	dev->hard_header_len	= IEEE802154_MIN_HEADER_LEN - 1;
+	/* The auth_tag header is for security and places in private payload
+	 * room of mac frame which stucks between payload and FCS field.
+	 */
+	dev->needed_tailroom	= IEEE802154_MAX_AUTH_TAG_LEN +
+				  IEEE802154_FCS_LEN;
 	dev->mtu		= IEEE802154_MTU;
 	dev->tx_queue_len	= 300;
 	dev->flags		= IFF_NOARP | IFF_BROADCAST;
@@ -617,7 +627,8 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 	if (!ndev)
 		return ERR_PTR(-ENOMEM);
 
-	ndev->needed_headroom = local->hw.extra_tx_headroom;
+	ndev->needed_headroom = local->hw.extra_tx_headroom +
+				IEEE802154_MAX_HEADER_LEN;
 
 	ret = dev_alloc_name(ndev, ndev->name);
 	if (ret < 0)

commit 838b83d63d2909f9136f3030dc4fffa8230c31da
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri Sep 18 11:30:42 2015 +0200

    ieee802154: introduce wpan_dev_header_ops
    
    The current header_ops callback structure of net device are used mostly
    from 802.15.4 upper-layers. Because this callback structure is a very
    generic one, which is also used by e.g. DGRAM AF_PACKET sockets, we
    can't make this callback structure 802.15.4 specific which is currently
    is.
    
    I saw the smallest "constraint" for calling this callback with
    dev_hard_header/dev_parse_header by AF_PACKET which assign a 8 byte
    array for address void pointers. Currently 802.15.4 specific protocols
    like af802154 and 6LoWPAN will assign the "struct ieee802154_addr" as
    these parameters which is greater than 8 bytes. The current callback
    implementation for header_ops.create assumes always a complete
    "struct ieee802154_addr" which AF_PACKET can't never handled and is
    greater than 8 bytes.
    
    For that reason we introduce now a "generic" create/parse header_ops
    callback which allows handling with intra-pan extended addresses only.
    This allows a small use-case with AF_PACKET to send "somehow" a valid
    dataframe over DGRAM.
    
    To keeping the current dev_hard_header behaviour we introduce a similar
    callback structure "wpan_dev_header_ops" which contains 802.15.4 specific
    upper-layer header creation functionality, which can be called by
    wpan_dev_hard_header.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index ed26952f9e14..8afe26d72971 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -367,12 +367,11 @@ static int mac802154_set_header_security(struct ieee802154_sub_if_data *sdata,
 	return 0;
 }
 
-static int mac802154_header_create(struct sk_buff *skb,
-				   struct net_device *dev,
-				   unsigned short type,
-				   const void *daddr,
-				   const void *saddr,
-				   unsigned len)
+static int ieee802154_header_create(struct sk_buff *skb,
+				    struct net_device *dev,
+				    const struct ieee802154_addr *daddr,
+				    const struct ieee802154_addr *saddr,
+				    unsigned len)
 {
 	struct ieee802154_hdr hdr;
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
@@ -423,24 +422,91 @@ static int mac802154_header_create(struct sk_buff *skb,
 	return hlen;
 }
 
+static const struct wpan_dev_header_ops ieee802154_header_ops = {
+	.create		= ieee802154_header_create,
+};
+
+/* This header create functionality assumes a 8 byte array for
+ * source and destination pointer at maximum. To adapt this for
+ * the 802.15.4 dataframe header we use extended address handling
+ * here only and intra pan connection. fc fields are mostly fallback
+ * handling. For provide dev_hard_header for dgram sockets.
+ */
+static int mac802154_header_create(struct sk_buff *skb,
+				   struct net_device *dev,
+				   unsigned short type,
+				   const void *daddr,
+				   const void *saddr,
+				   unsigned len)
+{
+	struct ieee802154_hdr hdr;
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
+	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
+	struct ieee802154_mac_cb cb = { };
+	int hlen;
+
+	if (!daddr)
+		return -EINVAL;
+
+	memset(&hdr.fc, 0, sizeof(hdr.fc));
+	hdr.fc.type = IEEE802154_FC_TYPE_DATA;
+	hdr.fc.ack_request = wpan_dev->ackreq;
+	hdr.seq = atomic_inc_return(&dev->ieee802154_ptr->dsn) & 0xFF;
+
+	/* TODO currently a workaround to give zero cb block to set
+	 * security parameters defaults according MIB.
+	 */
+	if (mac802154_set_header_security(sdata, &hdr, &cb) < 0)
+		return -EINVAL;
+
+	hdr.dest.pan_id = wpan_dev->pan_id;
+	hdr.dest.mode = IEEE802154_ADDR_LONG;
+	memcpy(&hdr.dest.extended_addr, daddr, IEEE802154_EXTENDED_ADDR_LEN);
+
+	hdr.source.pan_id = hdr.dest.pan_id;
+	hdr.source.mode = IEEE802154_ADDR_LONG;
+
+	if (!saddr)
+		hdr.source.extended_addr = wpan_dev->extended_addr;
+	else
+		memcpy(&hdr.source.extended_addr, saddr,
+		       IEEE802154_EXTENDED_ADDR_LEN);
+
+	hlen = ieee802154_hdr_push(skb, &hdr);
+	if (hlen < 0)
+		return -EINVAL;
+
+	skb_reset_mac_header(skb);
+	skb->mac_len = hlen;
+
+	if (len > ieee802154_max_payload(&hdr))
+		return -EMSGSIZE;
+
+	return hlen;
+}
+
 static int
 mac802154_header_parse(const struct sk_buff *skb, unsigned char *haddr)
 {
 	struct ieee802154_hdr hdr;
-	struct ieee802154_addr *addr = (struct ieee802154_addr *)haddr;
 
 	if (ieee802154_hdr_peek_addrs(skb, &hdr) < 0) {
 		pr_debug("malformed packet\n");
 		return 0;
 	}
 
-	*addr = hdr.source;
-	return sizeof(*addr);
+	if (hdr.source.mode == IEEE802154_ADDR_LONG) {
+		memcpy(haddr, &hdr.source.extended_addr,
+		       IEEE802154_EXTENDED_ADDR_LEN);
+		return IEEE802154_EXTENDED_ADDR_LEN;
+	}
+
+	return 0;
 }
 
-static struct header_ops mac802154_header_ops = {
-	.create		= mac802154_header_create,
-	.parse		= mac802154_header_parse,
+static const struct header_ops mac802154_header_ops = {
+	.create         = mac802154_header_create,
+	.parse          = mac802154_header_parse,
 };
 
 static const struct net_device_ops mac802154_wpan_ops = {
@@ -513,6 +579,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 		sdata->dev->netdev_ops = &mac802154_wpan_ops;
 		sdata->dev->ml_priv = &mac802154_mlme_wpan;
 		wpan_dev->promiscuous_mode = false;
+		wpan_dev->header_ops = &ieee802154_header_ops;
 
 		mutex_init(&sdata->sec_mtx);
 

commit 89c7d788f89d58136a2e5596796c298942ee32d6
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Aug 10 21:15:56 2015 +0200

    mac802154: change frame_retries behaviour
    
    This patch changes the default minimum value of frame_retries to 0 and
    changes the frame_retries default value to 3 which is also 802.15.4
    default.
    
    We don't use the frame_retries "-1" value as indicator for no-aret mode
    anymore, instead we checking on the ack request bit inside the 802.15.4
    frame control field. This allows a acknowledge handling per frame. This
    checking is done by transceiver or inside xmit callback of driver layer.
    
    If a transceiver doesn't support ARET handling the transmit
    functionality ignores ack frames then, which isn't well but should not
    effect anything of current functionality.
    
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index ff99055631f9..ed26952f9e14 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -498,8 +498,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 	wpan_dev->min_be = 3;
 	wpan_dev->max_be = 5;
 	wpan_dev->csma_retries = 4;
-	/* for compatibility, actual default is 3 */
-	wpan_dev->frame_retries = -1;
+	wpan_dev->frame_retries = 3;
 
 	wpan_dev->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);
 	wpan_dev->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);

commit 09095fdc9e5d5438051fc4e92867f1aff764cd21
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Aug 10 21:15:54 2015 +0200

    mac802154: fix wpan mac setting while lowpan is there
    
    If we currently change the mac address inside the wpan interface while
    we have a lowpan interface on top of the wpan interface, the mac address
    setting doesn't reach the lowpan interface. The effect would be that the
    IPv6 lowpan interface has the old SLAAC address and isn't working
    anymore because the lowpan interface use in internal mechanism sometimes
    dev->addr which is the old mac address of the wpan interface.
    
    This patch checks if a wpan interface belongs to lowpan interface, if
    yes then we need to check if the lowpan interface is down and change the
    mac address also at the lowpan interface. When the lowpan interface will
    be set up afterwards, it will use the correct SLAAC address which based
    on the updated mac address setting.
    
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Tested-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 416de903e467..ff99055631f9 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -125,6 +125,14 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 	if (netif_running(dev))
 		return -EBUSY;
 
+	/* lowpan need to be down for update
+	 * SLAAC address after ifup
+	 */
+	if (sdata->wpan_dev.lowpan_dev) {
+		if (netif_running(sdata->wpan_dev.lowpan_dev))
+			return -EBUSY;
+	}
+
 	ieee802154_be64_to_le64(&extended_addr, addr->sa_data);
 	if (!ieee802154_is_valid_extended_unicast_addr(extended_addr))
 		return -EINVAL;
@@ -132,6 +140,13 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
 	sdata->wpan_dev.extended_addr = extended_addr;
 
+	/* update lowpan interface mac address when
+	 * wpan mac has been changed
+	 */
+	if (sdata->wpan_dev.lowpan_dev)
+		memcpy(sdata->wpan_dev.lowpan_dev->dev_addr, dev->dev_addr,
+		       dev->addr_len);
+
 	return mac802154_wpan_update_llsec(dev);
 }
 

commit c4227c8a6246b30793bd7360113ddc7b66d526dc
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Jun 24 11:36:34 2015 +0200

    mac802154: util: add stop_device utility function
    
    This patch adds ieee802154_stop_device for preparing a utility function
    to stop the ieee802154 device.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 4760368a3493..416de903e467 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -314,11 +314,8 @@ static int mac802154_slave_close(struct net_device *dev)
 
 	clear_bit(SDATA_STATE_RUNNING, &sdata->state);
 
-	if (!local->open_count) {
-		flush_workqueue(local->workqueue);
-		hrtimer_cancel(&local->ifs_timer);
-		drv_stop(local);
-	}
+	if (!local->open_count)
+		ieee802154_stop_device(local);
 
 	return 0;
 }

commit d77b4852b4d3698a90eef219acf9cddc964b1f3a
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Jun 21 16:45:20 2015 +0200

    mac802154: add llsec address update workaround
    
    This patch adds a workaround for using the new nl802154 netlink
    interface with the old ieee802154 netlink interface togehter. The
    nl802154 currently supports no access for llsec layer, currently there
    are users outside which are using both interfaces at the same time. This
    patch adds a necessary call when addresses are updated.
    
    Reported-by: Simon Vincent <simon.vincent@xsilon.com>
    Suggested-by: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 8b698246a51b..4760368a3493 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -30,7 +30,7 @@
 #include "ieee802154_i.h"
 #include "driver-ops.h"
 
-static int mac802154_wpan_update_llsec(struct net_device *dev)
+int mac802154_wpan_update_llsec(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct ieee802154_mlme_ops *ops = ieee802154_mlme_ops(dev);
@@ -471,6 +471,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 		       enum nl802154_iftype type)
 {
 	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
+	int ret;
 	u8 tmp;
 
 	/* set some type-dependent values */
@@ -505,6 +506,10 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 		mutex_init(&sdata->sec_mtx);
 
 		mac802154_llsec_init(&sdata->sec);
+		ret = mac802154_wpan_update_llsec(sdata->dev);
+		if (ret < 0)
+			return ret;
+
 		break;
 	case NL802154_IFTYPE_MONITOR:
 		sdata->dev->destructor = free_netdev;

commit 5c698e8bbfaa6e26d851eeeeee09d61dfc9ff4a0
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Jun 17 15:35:18 2015 +0200

    mac802154: iface: cleanup stack variable
    
    There is no need to init res with zero, res can be unused but then we
    returning zero and not res.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 0b0cccb85336..8b698246a51b 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -189,7 +189,7 @@ static int mac802154_slave_open(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct ieee802154_local *local = sdata->local;
-	int res = 0;
+	int res;
 
 	ASSERT_RTNL();
 

commit 95c0aa15711e1e5fd62300a8abd244186ebf67e7
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Jun 17 15:35:17 2015 +0200

    mac802154: iface: fix order while interface up
    
    This patch moves the hardware setting before calling the driver start
    callback which activates the receive handling. The hardware setup
    contains settings like address filtering which should be setup before
    activate the receive handling on the transceiver. These setting are
    protected by ieee802154_check_concurrent_iface check. This means we
    need to set these registers once before calling drv_start and can't
    be overwritten by other interfaces.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 692731d240e4..0b0cccb85336 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -135,6 +135,56 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 	return mac802154_wpan_update_llsec(dev);
 }
 
+static int ieee802154_setup_hw(struct ieee802154_sub_if_data *sdata)
+{
+	struct ieee802154_local *local = sdata->local;
+	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
+	int ret;
+
+	if (local->hw.flags & IEEE802154_HW_PROMISCUOUS) {
+		ret = drv_set_promiscuous_mode(local,
+					       wpan_dev->promiscuous_mode);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (local->hw.flags & IEEE802154_HW_AFILT) {
+		ret = drv_set_pan_id(local, wpan_dev->pan_id);
+		if (ret < 0)
+			return ret;
+
+		ret = drv_set_extended_addr(local, wpan_dev->extended_addr);
+		if (ret < 0)
+			return ret;
+
+		ret = drv_set_short_addr(local, wpan_dev->short_addr);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (local->hw.flags & IEEE802154_HW_LBT) {
+		ret = drv_set_lbt_mode(local, wpan_dev->lbt);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (local->hw.flags & IEEE802154_HW_CSMA_PARAMS) {
+		ret = drv_set_csma_params(local, wpan_dev->min_be,
+					  wpan_dev->max_be,
+					  wpan_dev->csma_retries);
+		if (ret < 0)
+			return ret;
+	}
+
+	if (local->hw.flags & IEEE802154_HW_FRAME_RETRIES) {
+		ret = drv_set_max_frame_retries(local, wpan_dev->frame_retries);
+		if (ret < 0)
+			return ret;
+	}
+
+	return 0;
+}
+
 static int mac802154_slave_open(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
@@ -146,6 +196,10 @@ static int mac802154_slave_open(struct net_device *dev)
 	set_bit(SDATA_STATE_RUNNING, &sdata->state);
 
 	if (!local->open_count) {
+		res = ieee802154_setup_hw(sdata);
+		if (res)
+			goto err;
+
 		res = drv_start(local);
 		if (res)
 			goto err;
@@ -239,60 +293,13 @@ static int mac802154_wpan_open(struct net_device *dev)
 {
 	int rc;
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	struct ieee802154_local *local = sdata->local;
 	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
 
 	rc = ieee802154_check_concurrent_iface(sdata, wpan_dev->iftype);
 	if (rc < 0)
 		return rc;
 
-	rc = mac802154_slave_open(dev);
-	if (rc < 0)
-		return rc;
-
-	if (local->hw.flags & IEEE802154_HW_PROMISCUOUS) {
-		rc = drv_set_promiscuous_mode(local,
-					      wpan_dev->promiscuous_mode);
-		if (rc < 0)
-			goto out;
-	}
-
-	if (local->hw.flags & IEEE802154_HW_AFILT) {
-		rc = drv_set_pan_id(local, wpan_dev->pan_id);
-		if (rc < 0)
-			goto out;
-
-		rc = drv_set_extended_addr(local, wpan_dev->extended_addr);
-		if (rc < 0)
-			goto out;
-
-		rc = drv_set_short_addr(local, wpan_dev->short_addr);
-		if (rc < 0)
-			goto out;
-	}
-
-	if (local->hw.flags & IEEE802154_HW_LBT) {
-		rc = drv_set_lbt_mode(local, wpan_dev->lbt);
-		if (rc < 0)
-			goto out;
-	}
-
-	if (local->hw.flags & IEEE802154_HW_CSMA_PARAMS) {
-		rc = drv_set_csma_params(local, wpan_dev->min_be,
-					 wpan_dev->max_be,
-					 wpan_dev->csma_retries);
-		if (rc < 0)
-			goto out;
-	}
-
-	if (local->hw.flags & IEEE802154_HW_FRAME_RETRIES) {
-		rc = drv_set_max_frame_retries(local, wpan_dev->frame_retries);
-		if (rc < 0)
-			goto out;
-	}
-
-out:
-	return rc;
+	return mac802154_slave_open(dev);
 }
 
 static int mac802154_slave_close(struct net_device *dev)

commit ed2e627cb17d385f02d0a28fd7e564031f7769b0
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Jun 13 22:15:52 2015 +0200

    mac802154: iface: flush workqueue before stop
    
    This patch flushs the workqueue which is currently used for xmit_sync
    callback before calling stop driver-ops. Flush the queue will ensure all
    pending tx frames are transmitted.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index d8043378e7a0..692731d240e4 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -308,6 +308,7 @@ static int mac802154_slave_close(struct net_device *dev)
 	clear_bit(SDATA_STATE_RUNNING, &sdata->state);
 
 	if (!local->open_count) {
+		flush_workqueue(local->workqueue);
 		hrtimer_cancel(&local->ifs_timer);
 		drv_stop(local);
 	}

commit b4ee194441d7e4457c7bac6c2a5da8428974db5a
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Jun 13 22:15:51 2015 +0200

    mac802154: iface: fix hrtimer cancel on ifdown
    
    The interframe spacing timer is a per phy definition and is part of a
    ieee802154_local structure. If we have possible multiple interfaces
    ifdown one interface then the timer should not be cancled. First if the
    last interface is down and the receive handling is stopped we should be
    sure that the interframe spacing timer isn't run anymore.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index e3d77b07c0e4..d8043378e7a0 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -302,15 +302,15 @@ static int mac802154_slave_close(struct net_device *dev)
 
 	ASSERT_RTNL();
 
-	hrtimer_cancel(&local->ifs_timer);
-
 	netif_stop_queue(dev);
 	local->open_count--;
 
 	clear_bit(SDATA_STATE_RUNNING, &sdata->state);
 
-	if (!local->open_count)
+	if (!local->open_count) {
+		hrtimer_cancel(&local->ifs_timer);
 		drv_stop(local);
+	}
 
 	return 0;
 }

commit 9a4d3d4ba17c93def2b4dc3126eba30716d15469
Author: Stefan Schmidt <stefan@osg.samsung.com>
Date:   Mon Jun 8 22:06:40 2015 +0200

    mac802154/iface: remove superfluous WARN_ON call in slave_open()
    
    This call was used before we aligned our code with the wireless code base. We
    are wanted to handle this in the err: code path. Which would actually not work
    because the WARN_ON() macro would reset the res value to 0 and thus we would
    never hit err:. Removing it makes the code do what we actually intend.
    
    Signed-off-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 3a67d35d4672..e3d77b07c0e4 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -147,7 +147,6 @@ static int mac802154_slave_open(struct net_device *dev)
 
 	if (!local->open_count) {
 		res = drv_start(local);
-		WARN_ON(res);
 		if (res)
 			goto err;
 	}

commit ed65963ba0a2bdc330b1d7183f930d1c6a0a6685
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Jun 6 17:30:46 2015 +0200

    mac802154: remove unneeded vif struct
    
    This patch removes the virtual interface structure from sub if data
    struct, because it isn't used anywhere. This structure could be useful
    for give per interface information at softmac driver layer. Nevertheless
    there exist no use case currently and it contains the interface type
    information currently. This information is also stored inside wpan dev
    which is now used to check on the wpan dev interface type.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reviewed-by: Varka Bhadram <varkabhadram@gmail.com>
    Acked-by: Varka Bhadram <varkabhadram@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 6ac023932ce0..3a67d35d4672 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -219,8 +219,8 @@ ieee802154_check_concurrent_iface(struct ieee802154_sub_if_data *sdata,
 			 * exist really an use case if we need to support
 			 * multiple node types at the same time.
 			 */
-			if (sdata->vif.type == NL802154_IFTYPE_NODE &&
-			    nsdata->vif.type == NL802154_IFTYPE_NODE)
+			if (wpan_dev->iftype == NL802154_IFTYPE_NODE &&
+			    nsdata->wpan_dev.iftype == NL802154_IFTYPE_NODE)
 				return -EBUSY;
 
 			/* check all phy mac sublayer settings are the same.
@@ -243,7 +243,7 @@ static int mac802154_wpan_open(struct net_device *dev)
 	struct ieee802154_local *local = sdata->local;
 	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
 
-	rc = ieee802154_check_concurrent_iface(sdata, sdata->vif.type);
+	rc = ieee802154_check_concurrent_iface(sdata, wpan_dev->iftype);
 	if (rc < 0)
 		return rc;
 
@@ -467,7 +467,6 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 	u8 tmp;
 
 	/* set some type-dependent values */
-	sdata->vif.type = type;
 	sdata->wpan_dev.iftype = type;
 
 	get_random_bytes(&tmp, sizeof(tmp));
@@ -523,7 +522,7 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 
 	ASSERT_RTNL();
 
-	ndev = alloc_netdev(sizeof(*sdata) + local->hw.vif_data_size, name,
+	ndev = alloc_netdev(sizeof(*sdata), name,
 			    name_assign_type, ieee802154_if_setup);
 	if (!ndev)
 		return ERR_PTR(-ENOMEM);

commit daf4e2c89254ed6eb8cf7ef60f614edebfdb9f3a
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Thu May 28 15:38:43 2015 +0300

    ieee802154: Fix EUI-64 station address validation.
    
    Refuse to allow setting an EUI-64 group address as an interface
    address, as those are not valid station addresses.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index b544b5dc4bfb..6ac023932ce0 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -126,7 +126,7 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 		return -EBUSY;
 
 	ieee802154_be64_to_le64(&extended_addr, addr->sa_data);
-	if (!ieee802154_is_valid_extended_addr(extended_addr))
+	if (!ieee802154_is_valid_extended_unicast_addr(extended_addr))
 		return -EINVAL;
 
 	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
@@ -539,7 +539,7 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 	switch (type) {
 	case NL802154_IFTYPE_NODE:
 		ndev->type = ARPHRD_IEEE802154;
-		if (ieee802154_is_valid_extended_addr(extended_addr))
+		if (ieee802154_is_valid_extended_unicast_addr(extended_addr))
 			ieee802154_le64_to_be64(ndev->dev_addr, &extended_addr);
 		else
 			memcpy(ndev->dev_addr, ndev->perm_addr,

commit e34fd879f5516496c7241c9c2caf3a108295a30c
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Tue May 26 15:06:10 2015 +0300

    mac802154: Avoid rtnl deadlock in mac802154_wpan_ioctl().
    
    ->ndo_do_ioctl() can be entered with the rtnl lock already held,
    for example when sending a wext ioctl to a device (in which case
    the rtnl lock is taken by wext_ioctl_dispatch()), but
    mac802154_wpan_ioctl() currently unconditionally takes the rtnl
    lock on entry, which can cause deadlocks.
    
    To fix this, bail out of mac802154_wpan_ioctl() before taking the
    rtnl lock if the ioctl cmd is not one of the cmds we implement.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index f30788d2702f..b544b5dc4bfb 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -62,6 +62,9 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		(struct sockaddr_ieee802154 *)&ifr->ifr_addr;
 	int err = -ENOIOCTLCMD;
 
+	if (cmd != SIOCGIFADDR && cmd != SIOCSIFADDR)
+		return err;
+
 	rtnl_lock();
 
 	switch (cmd) {

commit c947f7e1e31a708f5a4ea8c1a627bec578cd9223
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri May 22 17:43:54 2015 +0200

    mac802154: remove mib lock
    
    This patch removes the mib lock. The new locking mechanism is to protect
    the mib values with the rtnl lock. Note that this isn't always necessary
    if we have an interface up the most mib values are readonly (e.g.
    address settings). With this behaviour we can remove locking in
    hotpath like frame parsing completely. It depends on context if we need
    to hold the rtnl lock or not, this makes the callbacks of
    ieee802154_mlme_ops unnecessary because these callbacks hols always the
    locks.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 0ec7bc402e29..f30788d2702f 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -63,7 +63,6 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	int err = -ENOIOCTLCMD;
 
 	rtnl_lock();
-	spin_lock_bh(&sdata->mib_lock);
 
 	switch (cmd) {
 	case SIOCGIFADDR:
@@ -88,7 +87,6 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	}
 	case SIOCSIFADDR:
 		if (netif_running(dev)) {
-			spin_unlock_bh(&sdata->mib_lock);
 			rtnl_unlock();
 			return -EBUSY;
 		}
@@ -111,7 +109,6 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		break;
 	}
 
-	spin_unlock_bh(&sdata->mib_lock);
 	rtnl_unlock();
 	return err;
 }
@@ -374,8 +371,6 @@ static int mac802154_header_create(struct sk_buff *skb,
 		return -EINVAL;
 
 	if (!saddr) {
-		spin_lock_bh(&sdata->mib_lock);
-
 		if (wpan_dev->short_addr == cpu_to_le16(IEEE802154_ADDR_BROADCAST) ||
 		    wpan_dev->short_addr == cpu_to_le16(IEEE802154_ADDR_UNDEF) ||
 		    wpan_dev->pan_id == cpu_to_le16(IEEE802154_PANID_BROADCAST)) {
@@ -387,8 +382,6 @@ static int mac802154_header_create(struct sk_buff *skb,
 		}
 
 		hdr.source.pan_id = wpan_dev->pan_id;
-
-		spin_unlock_bh(&sdata->mib_lock);
 	} else {
 		hdr.source = *(const struct ieee802154_addr *)saddr;
 	}
@@ -500,7 +493,6 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 		sdata->dev->ml_priv = &mac802154_mlme_wpan;
 		wpan_dev->promiscuous_mode = false;
 
-		spin_lock_init(&sdata->mib_lock);
 		mutex_init(&sdata->sec_mtx);
 
 		mac802154_llsec_init(&sdata->sec);

commit 344f8c119df742f2bf7098cf8fc326351f583249
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri May 22 17:43:53 2015 +0200

    mac802154: use atomic ops for sequence incrementation
    
    This patch will use atomic operations for sequence number incrementation
    while MAC header generation. Upper layers like af_802154 or 6LoWPAN
    could call this function in a parallel context while generating 802.15.4
    MAC header before queuing into wpan interfaces transmit queue.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 22f478be7489..0ec7bc402e29 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -368,7 +368,7 @@ static int mac802154_header_create(struct sk_buff *skb,
 	hdr.fc.type = cb->type;
 	hdr.fc.security_enabled = cb->secen;
 	hdr.fc.ack_request = cb->ackreq;
-	hdr.seq = ieee802154_mlme_ops(dev)->get_dsn(dev);
+	hdr.seq = atomic_inc_return(&dev->ieee802154_ptr->dsn) & 0xFF;
 
 	if (mac802154_set_header_security(sdata, &hdr, cb) < 0)
 		return -EINVAL;
@@ -468,13 +468,16 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 		       enum nl802154_iftype type)
 {
 	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
+	u8 tmp;
 
 	/* set some type-dependent values */
 	sdata->vif.type = type;
 	sdata->wpan_dev.iftype = type;
 
-	get_random_bytes(&wpan_dev->bsn, 1);
-	get_random_bytes(&wpan_dev->dsn, 1);
+	get_random_bytes(&tmp, sizeof(tmp));
+	atomic_set(&wpan_dev->bsn, tmp);
+	get_random_bytes(&tmp, sizeof(tmp));
+	atomic_set(&wpan_dev->dsn, tmp);
 
 	/* defaults per 802.15.4-2011 */
 	wpan_dev->min_be = 3;

commit 4a3a8c0c3a613e481bea931f0d65dc4a7efaa9b9
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri May 22 17:43:52 2015 +0200

    mac802154: remove pib lock
    
    This patch removes the pib lock which is now replaced by rtnl lock. The
    new interface already use the rtnl lock only. Nevertheless this patch
    will fix issues while using new and old interface at the same time.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 2a5878889289..22f478be7489 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -242,7 +242,6 @@ static int mac802154_wpan_open(struct net_device *dev)
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct ieee802154_local *local = sdata->local;
 	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
-	struct wpan_phy *phy = sdata->local->phy;
 
 	rc = ieee802154_check_concurrent_iface(sdata, sdata->vif.type);
 	if (rc < 0)
@@ -252,8 +251,6 @@ static int mac802154_wpan_open(struct net_device *dev)
 	if (rc < 0)
 		return rc;
 
-	mutex_lock(&phy->pib_lock);
-
 	if (local->hw.flags & IEEE802154_HW_PROMISCUOUS) {
 		rc = drv_set_promiscuous_mode(local,
 					      wpan_dev->promiscuous_mode);
@@ -295,11 +292,7 @@ static int mac802154_wpan_open(struct net_device *dev)
 			goto out;
 	}
 
-	mutex_unlock(&phy->pib_lock);
-	return 0;
-
 out:
-	mutex_unlock(&phy->pib_lock);
 	return rc;
 }
 

commit 4a669f7d72535017dd03cbcdf5af6e85edfdf90c
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri May 22 17:43:51 2015 +0200

    mac802154: fix hold rtnl while ioctl
    
    This patch fixes an issue to set address configuration with ioctl.
    Accessing the mib requires rtnl lock and the ndo_do_ioctl doesn't hold
    the rtnl lock while this callback is called. This patch do that
    manually.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reported-by: Matteo Petracca <matteo.petracca@sssup.it>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 91b75abbd1a1..2a5878889289 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -62,8 +62,7 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		(struct sockaddr_ieee802154 *)&ifr->ifr_addr;
 	int err = -ENOIOCTLCMD;
 
-	ASSERT_RTNL();
-
+	rtnl_lock();
 	spin_lock_bh(&sdata->mib_lock);
 
 	switch (cmd) {
@@ -90,6 +89,7 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	case SIOCSIFADDR:
 		if (netif_running(dev)) {
 			spin_unlock_bh(&sdata->mib_lock);
+			rtnl_unlock();
 			return -EBUSY;
 		}
 
@@ -112,6 +112,7 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	}
 
 	spin_unlock_bh(&sdata->mib_lock);
+	rtnl_unlock();
 	return err;
 }
 

commit 5b4a10390460cccf17a9fac739e153d68cf25ef5
Author: Varka Bhadram <varkabhadram@gmail.com>
Date:   Thu Apr 30 17:44:57 2015 +0200

    cfg802154: pass name_assign_type to rdev_add_virtual_intf()
    
    This code is based on commit 6bab2e19c5ffd
    ("cfg80211: pass name_assign_type to rdev_add_virtual_intf()")
    
    This will expose in sysfs whether the ifname of a IEEE-802.15.4
    device is set by userspace or generated by the kernel.
    We are using two types of name_assign_types
     o NET_NAME_ENUM: Default interface name provided by kernel
     o NET_NAME_USER: Interface name provided by user.
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 38b56f9d9386..91b75abbd1a1 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -522,7 +522,8 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 
 struct net_device *
 ieee802154_if_add(struct ieee802154_local *local, const char *name,
-		  enum nl802154_iftype type, __le64 extended_addr)
+		  unsigned char name_assign_type, enum nl802154_iftype type,
+		  __le64 extended_addr)
 {
 	struct net_device *ndev = NULL;
 	struct ieee802154_sub_if_data *sdata = NULL;
@@ -531,7 +532,7 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 	ASSERT_RTNL();
 
 	ndev = alloc_netdev(sizeof(*sdata) + local->hw.vif_data_size, name,
-			    NET_NAME_UNKNOWN, ieee802154_if_setup);
+			    name_assign_type, ieee802154_if_setup);
 	if (!ndev)
 		return ERR_PTR(-ENOMEM);
 

commit 8bf9538a5de5f6496993fb294ef606e453232ea4
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Thu Mar 26 12:46:28 2015 +0100

    mac802154: cleanup concurrent check
    
    This patch cleanups the checking of different mac phy depended values by
    handling depended mac settings per hw support flag in one condition.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 6fb6bdf9868c..38b56f9d9386 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -174,24 +174,16 @@ ieee802154_check_mac_settings(struct ieee802154_local *local,
 	}
 
 	if (local->hw.flags & IEEE802154_HW_AFILT) {
-		if (wpan_dev->pan_id != nwpan_dev->pan_id)
-			return -EBUSY;
-
-		if (wpan_dev->short_addr != nwpan_dev->short_addr)
-			return -EBUSY;
-
-		if (wpan_dev->extended_addr != nwpan_dev->extended_addr)
+		if (wpan_dev->pan_id != nwpan_dev->pan_id ||
+		    wpan_dev->short_addr != nwpan_dev->short_addr ||
+		    wpan_dev->extended_addr != nwpan_dev->extended_addr)
 			return -EBUSY;
 	}
 
 	if (local->hw.flags & IEEE802154_HW_CSMA_PARAMS) {
-		if (wpan_dev->min_be != nwpan_dev->min_be)
-			return -EBUSY;
-
-		if (wpan_dev->max_be != nwpan_dev->max_be)
-			return -EBUSY;
-
-		if (wpan_dev->csma_retries != nwpan_dev->csma_retries)
+		if (wpan_dev->min_be != nwpan_dev->min_be ||
+		    wpan_dev->max_be != nwpan_dev->max_be ||
+		    wpan_dev->csma_retries != nwpan_dev->csma_retries)
 			return -EBUSY;
 	}
 

commit cd1c56653a65e5559cf48effe8864ff6df4b4430
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri Dec 19 23:45:59 2014 +0100

    ieee802154: iface: move multiple node type check
    
    This patch moves the handling for checking on multiple node type
    interface to the corresponding concurrent iface check function.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 61f3ff00a508..6fb6bdf9868c 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -137,25 +137,11 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 static int mac802154_slave_open(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	struct ieee802154_sub_if_data *subif;
 	struct ieee802154_local *local = sdata->local;
 	int res = 0;
 
 	ASSERT_RTNL();
 
-	if (sdata->vif.type == NL802154_IFTYPE_NODE) {
-		mutex_lock(&sdata->local->iflist_mtx);
-		list_for_each_entry(subif, &sdata->local->interfaces, list) {
-			if (subif != sdata &&
-			    subif->vif.type == sdata->vif.type &&
-			    ieee802154_sdata_running(subif)) {
-				mutex_unlock(&sdata->local->iflist_mtx);
-				return -EBUSY;
-			}
-		}
-		mutex_unlock(&sdata->local->iflist_mtx);
-	}
-
 	set_bit(SDATA_STATE_RUNNING, &sdata->state);
 
 	if (!local->open_count) {
@@ -235,6 +221,15 @@ ieee802154_check_concurrent_iface(struct ieee802154_sub_if_data *sdata,
 		if (nsdata != sdata && ieee802154_sdata_running(nsdata)) {
 			int ret;
 
+			/* TODO currently we don't support multiple node types
+			 * we need to run skb_clone at rx path. Check if there
+			 * exist really an use case if we need to support
+			 * multiple node types at the same time.
+			 */
+			if (sdata->vif.type == NL802154_IFTYPE_NODE &&
+			    nsdata->vif.type == NL802154_IFTYPE_NODE)
+				return -EBUSY;
+
 			/* check all phy mac sublayer settings are the same.
 			 * We have only one phy, different values makes trouble.
 			 */

commit bd37a78de91e1b67b540b43f10bbb2d552348cbd
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri Dec 19 23:45:58 2014 +0100

    mac802154: iface: check concurrent ifaces
    
    This patch adds a check for concurrent interfaces while calling
    interface up. This avoids to have different mac parameters on one phy.
    Otherwise it could be that a interface can overwrite current phy mac
    settings which is set by an another interface.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 9ae893057dd7..61f3ff00a508 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -175,6 +175,79 @@ static int mac802154_slave_open(struct net_device *dev)
 	return res;
 }
 
+static int
+ieee802154_check_mac_settings(struct ieee802154_local *local,
+			      struct wpan_dev *wpan_dev,
+			      struct wpan_dev *nwpan_dev)
+{
+	ASSERT_RTNL();
+
+	if (local->hw.flags & IEEE802154_HW_PROMISCUOUS) {
+		if (wpan_dev->promiscuous_mode != nwpan_dev->promiscuous_mode)
+			return -EBUSY;
+	}
+
+	if (local->hw.flags & IEEE802154_HW_AFILT) {
+		if (wpan_dev->pan_id != nwpan_dev->pan_id)
+			return -EBUSY;
+
+		if (wpan_dev->short_addr != nwpan_dev->short_addr)
+			return -EBUSY;
+
+		if (wpan_dev->extended_addr != nwpan_dev->extended_addr)
+			return -EBUSY;
+	}
+
+	if (local->hw.flags & IEEE802154_HW_CSMA_PARAMS) {
+		if (wpan_dev->min_be != nwpan_dev->min_be)
+			return -EBUSY;
+
+		if (wpan_dev->max_be != nwpan_dev->max_be)
+			return -EBUSY;
+
+		if (wpan_dev->csma_retries != nwpan_dev->csma_retries)
+			return -EBUSY;
+	}
+
+	if (local->hw.flags & IEEE802154_HW_FRAME_RETRIES) {
+		if (wpan_dev->frame_retries != nwpan_dev->frame_retries)
+			return -EBUSY;
+	}
+
+	if (local->hw.flags & IEEE802154_HW_LBT) {
+		if (wpan_dev->lbt != nwpan_dev->lbt)
+			return -EBUSY;
+	}
+
+	return 0;
+}
+
+static int
+ieee802154_check_concurrent_iface(struct ieee802154_sub_if_data *sdata,
+				  enum nl802154_iftype iftype)
+{
+	struct ieee802154_local *local = sdata->local;
+	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
+	struct ieee802154_sub_if_data *nsdata;
+
+	/* we hold the RTNL here so can safely walk the list */
+	list_for_each_entry(nsdata, &local->interfaces, list) {
+		if (nsdata != sdata && ieee802154_sdata_running(nsdata)) {
+			int ret;
+
+			/* check all phy mac sublayer settings are the same.
+			 * We have only one phy, different values makes trouble.
+			 */
+			ret = ieee802154_check_mac_settings(local, wpan_dev,
+							    &nsdata->wpan_dev);
+			if (ret < 0)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
 static int mac802154_wpan_open(struct net_device *dev)
 {
 	int rc;
@@ -183,6 +256,10 @@ static int mac802154_wpan_open(struct net_device *dev)
 	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
 	struct wpan_phy *phy = sdata->local->phy;
 
+	rc = ieee802154_check_concurrent_iface(sdata, sdata->vif.type);
+	if (rc < 0)
+		return rc;
+
 	rc = mac802154_slave_open(dev);
 	if (rc < 0)
 		return rc;

commit 473f3766b5c2145f4c70bed39f4595b15c889ae2
Author: Varka Bhadram <varkabhadram@gmail.com>
Date:   Tue Nov 25 16:34:43 2014 +0530

    mac802154: remove unnecessary if statement
    
    Removes unnecessary if statement check for net device. Error check performed
    after alloc_netdev().
    
            ndev = alloc_netdev(sizeof(*sdata) + local->hw.vif_data_size, name,
                                NET_NAME_UNKNOWN, ieee802154_if_setup);
            if (!ndev)
                    return ERR_PTR(-ENOMEM);
            ..
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 38dfc72d24b6..9ae893057dd7 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -510,11 +510,9 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 	if (ret)
 		goto err;
 
-	if (ndev) {
-		ret = register_netdevice(ndev);
-		if (ret < 0)
-			goto err;
-	}
+	ret = register_netdevice(ndev);
+	if (ret < 0)
+		goto err;
 
 	mutex_lock(&local->iflist_mtx);
 	list_add_tail_rcu(&sdata->list, &local->interfaces);

commit 0e57547eb7f0aa99aba32b50c49dbd722a80d6fb
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Nov 17 08:20:52 2014 +0100

    ieee802154: setting extended address while iface add
    
    This patch adds support for setting an extended address while
    registration a new interface. If ieee802154_is_valid_extended_addr
    getting as parameter and invalid extended address then the perm address
    is fallback. This is useful to make some default handling while for
    example default registration of a wpan interface while phy registration.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index ba63ac93ae90..38dfc72d24b6 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -458,7 +458,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 
 struct net_device *
 ieee802154_if_add(struct ieee802154_local *local, const char *name,
-		  enum nl802154_iftype type)
+		  enum nl802154_iftype type, __le64 extended_addr)
 {
 	struct net_device *ndev = NULL;
 	struct ieee802154_sub_if_data *sdata = NULL;
@@ -477,9 +477,16 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 	if (ret < 0)
 		goto err;
 
+	ieee802154_le64_to_be64(ndev->perm_addr,
+				&local->hw.phy->perm_extended_addr);
 	switch (type) {
 	case NL802154_IFTYPE_NODE:
 		ndev->type = ARPHRD_IEEE802154;
+		if (ieee802154_is_valid_extended_addr(extended_addr))
+			ieee802154_le64_to_be64(ndev->dev_addr, &extended_addr);
+		else
+			memcpy(ndev->dev_addr, ndev->perm_addr,
+			       IEEE802154_EXTENDED_ADDR_LEN);
 		break;
 	case NL802154_IFTYPE_MONITOR:
 		ndev->type = ARPHRD_IEEE802154_MONITOR;
@@ -489,9 +496,6 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 		goto err;
 	}
 
-	ieee802154_le64_to_be64(ndev->perm_addr,
-				&local->hw.phy->perm_extended_addr);
-	memcpy(ndev->dev_addr, ndev->perm_addr, IEEE802154_EXTENDED_ADDR_LEN);
 	/* TODO check this */
 	SET_NETDEV_DEV(ndev, &local->phy->dev);
 	sdata = netdev_priv(ndev);

commit 133d3f31729a62908ab98d0b6562cc1a35d3dc39
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Nov 17 08:20:50 2014 +0100

    mac802154: remove wpan_dev parameter in if_add
    
    This parameter was grabbed from wireless implementation with the
    identically wireless dev struct. We don't need this right now and so we
    remove it. Maybe we will add it later again if we found any real reason
    to have such parameter.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index cc992e8405d3..ba63ac93ae90 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -458,7 +458,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
 
 struct net_device *
 ieee802154_if_add(struct ieee802154_local *local, const char *name,
-		  struct wpan_dev **new_wpan_dev, enum nl802154_iftype type)
+		  enum nl802154_iftype type)
 {
 	struct net_device *ndev = NULL;
 	struct ieee802154_sub_if_data *sdata = NULL;
@@ -516,9 +516,6 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 	list_add_tail_rcu(&sdata->list, &local->interfaces);
 	mutex_unlock(&local->iflist_mtx);
 
-	if (new_wpan_dev)
-		*new_wpan_dev = &sdata->wpan_dev;
-
 	return ndev;
 
 err:

commit 944742a36d784c2a36a141ac10ba5168b0313cec
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Nov 17 08:20:49 2014 +0100

    mac802154: use new nl802154 iftype types
    
    This patch replace the depracted IEEE802154_DEV to the new introduced
    NL802154_IFTYPE_NODE types. There is a backwards compatibility to have
    the identical types for both enum definitions. Also remove some inlcude
    issue with "linux/nl802154.h", because the export nl_policy inside this
    header it was always necessary to have an include of "net/rtnetlink.h"
    before. The reason for this is more complicated. Nevertheless we removed
    this now, because "linux/nl802154.h" is the depracted netlink interface.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index feb064715d1f..cc992e8405d3 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -22,8 +22,7 @@
 #include <linux/if_arp.h>
 #include <linux/ieee802154.h>
 
-#include <net/rtnetlink.h>
-#include <linux/nl802154.h>
+#include <net/nl802154.h>
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
 #include <net/cfg802154.h>
@@ -144,7 +143,7 @@ static int mac802154_slave_open(struct net_device *dev)
 
 	ASSERT_RTNL();
 
-	if (sdata->vif.type == IEEE802154_DEV_WPAN) {
+	if (sdata->vif.type == NL802154_IFTYPE_NODE) {
 		mutex_lock(&sdata->local->iflist_mtx);
 		list_for_each_entry(subif, &sdata->local->interfaces, list) {
 			if (subif != sdata &&
@@ -407,7 +406,8 @@ static void ieee802154_if_setup(struct net_device *dev)
 }
 
 static int
-ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
+ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata,
+		       enum nl802154_iftype type)
 {
 	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
 
@@ -429,7 +429,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 	wpan_dev->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);
 
 	switch (type) {
-	case IEEE802154_DEV_WPAN:
+	case NL802154_IFTYPE_NODE:
 		ieee802154_be64_to_le64(&wpan_dev->extended_addr,
 					sdata->dev->dev_addr);
 
@@ -444,7 +444,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 
 		mac802154_llsec_init(&sdata->sec);
 		break;
-	case IEEE802154_DEV_MONITOR:
+	case NL802154_IFTYPE_MONITOR:
 		sdata->dev->destructor = free_netdev;
 		sdata->dev->netdev_ops = &mac802154_monitor_ops;
 		wpan_dev->promiscuous_mode = true;
@@ -458,7 +458,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 
 struct net_device *
 ieee802154_if_add(struct ieee802154_local *local, const char *name,
-		  struct wpan_dev **new_wpan_dev, int type)
+		  struct wpan_dev **new_wpan_dev, enum nl802154_iftype type)
 {
 	struct net_device *ndev = NULL;
 	struct ieee802154_sub_if_data *sdata = NULL;
@@ -478,10 +478,10 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 		goto err;
 
 	switch (type) {
-	case IEEE802154_DEV_WPAN:
+	case NL802154_IFTYPE_NODE:
 		ndev->type = ARPHRD_IEEE802154;
 		break;
-	case IEEE802154_DEV_MONITOR:
+	case NL802154_IFTYPE_MONITOR:
 		ndev->type = ARPHRD_IEEE802154_MONITOR;
 		break;
 	default:

commit 61f2dcba9a03d4fd9342f0d6821af0a46c7098e9
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 12 19:51:56 2014 +0100

    mac802154: add interframe spacing time handling
    
    This patch adds a new interframe spacing time handling into mac802154
    layer. Interframe spacing time is a time period between each transmit.
    This patch adds a high resolution timer into mac802154 and starts on
    xmit complete with corresponding interframe spacing expire time if
    ifs_handling is true. We make it variable because it depends if
    interframe spacing time is handled by transceiver or mac802154. At the
    timer complete function we wake the netdev queue again. This avoids
    new frame transmit in range of interframe spacing time.
    
    For synced driver we add no handling of interframe spacing time. This
    is currently a lack of support in all synced xmit drivers. I suppose
    it's working because the latency of workqueue which is needed to call
    spi_sync.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index ec92b48d1b0b..feb064715d1f 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -246,6 +246,8 @@ static int mac802154_slave_close(struct net_device *dev)
 
 	ASSERT_RTNL();
 
+	hrtimer_cancel(&local->ifs_timer);
+
 	netif_stop_queue(dev);
 	local->open_count--;
 

commit be4fd8e5d9f5cd3fdc368e32e7957bcb83bcbb8b
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 12 03:36:53 2014 +0100

    mac802154: add ifname change notifier
    
    This patch adds a netdev notifier for interface renaming. We have a name
    attribute inside of subif data struct. This is needed to have always the
    actual netdev name in sdata name attribute.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 85d215562b4a..ec92b48d1b0b 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -548,3 +548,38 @@ void ieee802154_remove_interfaces(struct ieee802154_local *local)
 	}
 	mutex_unlock(&local->iflist_mtx);
 }
+
+static int netdev_notify(struct notifier_block *nb,
+			 unsigned long state, void *ptr)
+{
+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+	struct ieee802154_sub_if_data *sdata;
+
+	if (state != NETDEV_CHANGENAME)
+		return NOTIFY_DONE;
+
+	if (!dev->ieee802154_ptr || !dev->ieee802154_ptr->wpan_phy)
+		return NOTIFY_DONE;
+
+	if (dev->ieee802154_ptr->wpan_phy->privid != mac802154_wpan_phy_privid)
+		return NOTIFY_DONE;
+
+	sdata = IEEE802154_DEV_TO_SUB_IF(dev);
+	memcpy(sdata->name, dev->name, IFNAMSIZ);
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block mac802154_netdev_notifier = {
+	.notifier_call = netdev_notify,
+};
+
+int ieee802154_iface_init(void)
+{
+	return register_netdevice_notifier(&mac802154_netdev_notifier);
+}
+
+void ieee802154_iface_exit(void)
+{
+	unregister_netdevice_notifier(&mac802154_netdev_notifier);
+}

commit 2789e6297f8fd4943b8d63599a75c3e1cf4f8517
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 12 03:36:50 2014 +0100

    mac820154: move mutex locks out of loop
    
    Instead of always re-lock the iflist_mtx at multiple interfaces we lock
    the complete for each loop at start and at the end.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 8b21d201fc97..85d215562b4a 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -540,11 +540,11 @@ void ieee802154_remove_interfaces(struct ieee802154_local *local)
 {
 	struct ieee802154_sub_if_data *sdata, *tmp;
 
+	mutex_lock(&local->iflist_mtx);
 	list_for_each_entry_safe(sdata, tmp, &local->interfaces, list) {
-		mutex_lock(&sdata->local->iflist_mtx);
 		list_del(&sdata->list);
-		mutex_unlock(&sdata->local->iflist_mtx);
 
 		unregister_netdevice(sdata->dev);
 	}
+	mutex_unlock(&local->iflist_mtx);
 }

commit d14e1c71cfa870a2ed9f058a79b1c71decdaa9ba
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 12 03:36:49 2014 +0100

    mac820154: rename sdata next to tmp
    
    This patch is just a cleanup to name the temporary variable for
    protected list for each loop as tmp.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 8d90fbafda14..8b21d201fc97 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -538,9 +538,9 @@ void ieee802154_if_remove(struct ieee802154_sub_if_data *sdata)
 
 void ieee802154_remove_interfaces(struct ieee802154_local *local)
 {
-	struct ieee802154_sub_if_data *sdata, *next;
+	struct ieee802154_sub_if_data *sdata, *tmp;
 
-	list_for_each_entry_safe(sdata, next, &local->interfaces, list) {
+	list_for_each_entry_safe(sdata, tmp, &local->interfaces, list) {
 		mutex_lock(&sdata->local->iflist_mtx);
 		list_del(&sdata->list);
 		mutex_unlock(&sdata->local->iflist_mtx);

commit 592dfbfc72f5352437c883aa11ab579d10cdb595
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 12 03:36:48 2014 +0100

    mac820154: move interface unregistration into iface
    
    This patch move the iface unregistration into iface.c file to have
    a behaviour which is similar like mac80211. Also iface handling should
    be inside iface.c file only.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 83715b5ffe43..8d90fbafda14 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -535,3 +535,16 @@ void ieee802154_if_remove(struct ieee802154_sub_if_data *sdata)
 	synchronize_rcu();
 	unregister_netdevice(sdata->dev);
 }
+
+void ieee802154_remove_interfaces(struct ieee802154_local *local)
+{
+	struct ieee802154_sub_if_data *sdata, *next;
+
+	list_for_each_entry_safe(sdata, next, &local->interfaces, list) {
+		mutex_lock(&sdata->local->iflist_mtx);
+		list_del(&sdata->list);
+		mutex_unlock(&sdata->local->iflist_mtx);
+
+		unregister_netdevice(sdata->dev);
+	}
+}

commit f7cb96f105fb406e8db5e68e0cdd5067e2556d34
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:59 2014 +0100

    mac802154: protect address changes via ioctl
    
    This patch adds a netif_running check while trying to change the address
    attributes via ioctl. While netif_running is true these attributes
    should be only readable.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index d635f367b03f..83715b5ffe43 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -63,6 +63,8 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		(struct sockaddr_ieee802154 *)&ifr->ifr_addr;
 	int err = -ENOIOCTLCMD;
 
+	ASSERT_RTNL();
+
 	spin_lock_bh(&sdata->mib_lock);
 
 	switch (cmd) {
@@ -87,6 +89,11 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 		break;
 	}
 	case SIOCSIFADDR:
+		if (netif_running(dev)) {
+			spin_unlock_bh(&sdata->mib_lock);
+			return -EBUSY;
+		}
+
 		dev_warn(&dev->dev,
 			 "Using DEBUGing ioctl SIOCSIFADDR isn't recommended!\n");
 		if (sa->family != AF_IEEE802154 ||

commit b03c9cccfa808f1b314097b162a36c3937cb818e
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:56 2014 +0100

    mac820154: don't set monitor dev_addr
    
    This patch removes the setting of dev_addr on a monitor device. This
    address should be zero. A monitor should only sniff and send raw frames
    out. The address should be never used by upper layers and receiving
    frame parsing.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 4630ceb25ad2..d635f367b03f 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -416,12 +416,14 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 	/* for compatibility, actual default is 3 */
 	wpan_dev->frame_retries = -1;
 
-	ieee802154_be64_to_le64(&wpan_dev->extended_addr, sdata->dev->dev_addr);
 	wpan_dev->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);
 	wpan_dev->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);
 
 	switch (type) {
 	case IEEE802154_DEV_WPAN:
+		ieee802154_be64_to_le64(&wpan_dev->extended_addr,
+					sdata->dev->dev_addr);
+
 		sdata->dev->header_ops = &mac802154_header_ops;
 		sdata->dev->destructor = mac802154_wpan_free;
 		sdata->dev->netdev_ops = &mac802154_wpan_ops;

commit 190ac1ca33442dc25a172ece0f34746a7e1514f3
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:49 2014 +0100

    ieee802154: add iftype to wpan_dev
    
    This patch adds an iftype argument to the wpan_dev. This is needed to
    get the interface type from netdev ieee802154_ptr. The subif data struct
    can only accessible in mac802154 branch.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index c0b96cf525d6..4630ceb25ad2 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -404,6 +404,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 
 	/* set some type-dependent values */
 	sdata->vif.type = type;
+	sdata->wpan_dev.iftype = type;
 
 	get_random_bytes(&wpan_dev->bsn, 1);
 	get_random_bytes(&wpan_dev->dsn, 1);

commit 5fb3f026ae15827fe32e34adafce0d0f63ad0366
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:46 2014 +0100

    mac802154: remove mac_params in sdata
    
    This patch removes the mac_params from subif data struct. Instead we
    manipulate the wpan attributes directly.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 6669da7446f2..c0b96cf525d6 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -205,22 +205,21 @@ static int mac802154_wpan_open(struct net_device *dev)
 	}
 
 	if (local->hw.flags & IEEE802154_HW_LBT) {
-		rc = drv_set_lbt_mode(local, sdata->mac_params.lbt);
+		rc = drv_set_lbt_mode(local, wpan_dev->lbt);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (local->hw.flags & IEEE802154_HW_CSMA_PARAMS) {
-		rc = drv_set_csma_params(local, sdata->mac_params.min_be,
-					 sdata->mac_params.max_be,
-					 sdata->mac_params.csma_retries);
+		rc = drv_set_csma_params(local, wpan_dev->min_be,
+					 wpan_dev->max_be,
+					 wpan_dev->csma_retries);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (local->hw.flags & IEEE802154_HW_FRAME_RETRIES) {
-		rc = drv_set_max_frame_retries(local,
-					       sdata->mac_params.frame_retries);
+		rc = drv_set_max_frame_retries(local, wpan_dev->frame_retries);
 		if (rc < 0)
 			goto out;
 	}
@@ -410,11 +409,11 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 	get_random_bytes(&wpan_dev->dsn, 1);
 
 	/* defaults per 802.15.4-2011 */
-	sdata->mac_params.min_be = 3;
-	sdata->mac_params.max_be = 5;
-	sdata->mac_params.csma_retries = 4;
+	wpan_dev->min_be = 3;
+	wpan_dev->max_be = 5;
+	wpan_dev->csma_retries = 4;
 	/* for compatibility, actual default is 3 */
-	sdata->mac_params.frame_retries = -1;
+	wpan_dev->frame_retries = -1;
 
 	ieee802154_be64_to_le64(&wpan_dev->extended_addr, sdata->dev->dev_addr);
 	wpan_dev->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);

commit 863e88f255dac0657e57d5f1a1f95ee8733f8c13
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:45 2014 +0100

    mac802154: move mac pib attributes into wpan_dev
    
    This patch moves all mac pib attributes into the wpan_dev struct.
    Furthermore we can easier access these attributes over the netdev
    802154_ptr pointer. Currently this is only possible over a complicated
    callback structure in mac802154 because subif data structure is
    accessable inside mac802154 only.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 384f4bb3c99b..6669da7446f2 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -35,16 +35,17 @@ static int mac802154_wpan_update_llsec(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct ieee802154_mlme_ops *ops = ieee802154_mlme_ops(dev);
+	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
 	int rc = 0;
 
 	if (ops->llsec) {
 		struct ieee802154_llsec_params params;
 		int changed = 0;
 
-		params.pan_id = sdata->pan_id;
+		params.pan_id = wpan_dev->pan_id;
 		changed |= IEEE802154_LLSEC_PARAM_PAN_ID;
 
-		params.hwaddr = sdata->extended_addr;
+		params.hwaddr = wpan_dev->extended_addr;
 		changed |= IEEE802154_LLSEC_PARAM_HWADDR;
 
 		rc = ops->llsec->set_params(dev, &params, changed);
@@ -57,6 +58,7 @@ static int
 mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
+	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
 	struct sockaddr_ieee802154 *sa =
 		(struct sockaddr_ieee802154 *)&ifr->ifr_addr;
 	int err = -ENOIOCTLCMD;
@@ -68,8 +70,8 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	{
 		u16 pan_id, short_addr;
 
-		pan_id = le16_to_cpu(sdata->pan_id);
-		short_addr = le16_to_cpu(sdata->short_addr);
+		pan_id = le16_to_cpu(wpan_dev->pan_id);
+		short_addr = le16_to_cpu(wpan_dev->short_addr);
 		if (pan_id == IEEE802154_PANID_BROADCAST ||
 		    short_addr == IEEE802154_ADDR_BROADCAST) {
 			err = -EADDRNOTAVAIL;
@@ -96,8 +98,8 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 			break;
 		}
 
-		sdata->pan_id = cpu_to_le16(sa->addr.pan_id);
-		sdata->short_addr = cpu_to_le16(sa->addr.short_addr);
+		wpan_dev->pan_id = cpu_to_le16(sa->addr.pan_id);
+		wpan_dev->short_addr = cpu_to_le16(sa->addr.short_addr);
 
 		err = mac802154_wpan_update_llsec(dev);
 		break;
@@ -121,7 +123,7 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 		return -EINVAL;
 
 	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
-	sdata->extended_addr = extended_addr;
+	sdata->wpan_dev.extended_addr = extended_addr;
 
 	return mac802154_wpan_update_llsec(dev);
 }
@@ -172,6 +174,7 @@ static int mac802154_wpan_open(struct net_device *dev)
 	int rc;
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct ieee802154_local *local = sdata->local;
+	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
 	struct wpan_phy *phy = sdata->local->phy;
 
 	rc = mac802154_slave_open(dev);
@@ -181,21 +184,22 @@ static int mac802154_wpan_open(struct net_device *dev)
 	mutex_lock(&phy->pib_lock);
 
 	if (local->hw.flags & IEEE802154_HW_PROMISCUOUS) {
-		rc = drv_set_promiscuous_mode(local, sdata->promiscuous_mode);
+		rc = drv_set_promiscuous_mode(local,
+					      wpan_dev->promiscuous_mode);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (local->hw.flags & IEEE802154_HW_AFILT) {
-		rc = drv_set_pan_id(local, sdata->pan_id);
+		rc = drv_set_pan_id(local, wpan_dev->pan_id);
 		if (rc < 0)
 			goto out;
 
-		rc = drv_set_extended_addr(local, sdata->extended_addr);
+		rc = drv_set_extended_addr(local, wpan_dev->extended_addr);
 		if (rc < 0)
 			goto out;
 
-		rc = drv_set_short_addr(local, sdata->short_addr);
+		rc = drv_set_short_addr(local, wpan_dev->short_addr);
 		if (rc < 0)
 			goto out;
 	}
@@ -288,6 +292,7 @@ static int mac802154_header_create(struct sk_buff *skb,
 {
 	struct ieee802154_hdr hdr;
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
+	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
 	struct ieee802154_mac_cb *cb = mac_cb(skb);
 	int hlen;
 
@@ -306,17 +311,17 @@ static int mac802154_header_create(struct sk_buff *skb,
 	if (!saddr) {
 		spin_lock_bh(&sdata->mib_lock);
 
-		if (sdata->short_addr == cpu_to_le16(IEEE802154_ADDR_BROADCAST) ||
-		    sdata->short_addr == cpu_to_le16(IEEE802154_ADDR_UNDEF) ||
-		    sdata->pan_id == cpu_to_le16(IEEE802154_PANID_BROADCAST)) {
+		if (wpan_dev->short_addr == cpu_to_le16(IEEE802154_ADDR_BROADCAST) ||
+		    wpan_dev->short_addr == cpu_to_le16(IEEE802154_ADDR_UNDEF) ||
+		    wpan_dev->pan_id == cpu_to_le16(IEEE802154_PANID_BROADCAST)) {
 			hdr.source.mode = IEEE802154_ADDR_LONG;
-			hdr.source.extended_addr = sdata->extended_addr;
+			hdr.source.extended_addr = wpan_dev->extended_addr;
 		} else {
 			hdr.source.mode = IEEE802154_ADDR_SHORT;
-			hdr.source.short_addr = sdata->short_addr;
+			hdr.source.short_addr = wpan_dev->short_addr;
 		}
 
-		hdr.source.pan_id = sdata->pan_id;
+		hdr.source.pan_id = wpan_dev->pan_id;
 
 		spin_unlock_bh(&sdata->mib_lock);
 	} else {
@@ -396,11 +401,13 @@ static void ieee802154_if_setup(struct net_device *dev)
 static int
 ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 {
+	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
+
 	/* set some type-dependent values */
 	sdata->vif.type = type;
 
-	get_random_bytes(&sdata->bsn, 1);
-	get_random_bytes(&sdata->dsn, 1);
+	get_random_bytes(&wpan_dev->bsn, 1);
+	get_random_bytes(&wpan_dev->dsn, 1);
 
 	/* defaults per 802.15.4-2011 */
 	sdata->mac_params.min_be = 3;
@@ -409,9 +416,9 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 	/* for compatibility, actual default is 3 */
 	sdata->mac_params.frame_retries = -1;
 
-	ieee802154_be64_to_le64(&sdata->extended_addr, sdata->dev->dev_addr);
-	sdata->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);
-	sdata->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);
+	ieee802154_be64_to_le64(&wpan_dev->extended_addr, sdata->dev->dev_addr);
+	wpan_dev->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);
+	wpan_dev->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);
 
 	switch (type) {
 	case IEEE802154_DEV_WPAN:
@@ -419,7 +426,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 		sdata->dev->destructor = mac802154_wpan_free;
 		sdata->dev->netdev_ops = &mac802154_wpan_ops;
 		sdata->dev->ml_priv = &mac802154_mlme_wpan;
-		sdata->promiscuous_mode = false;
+		wpan_dev->promiscuous_mode = false;
 
 		spin_lock_init(&sdata->mib_lock);
 		mutex_init(&sdata->sec_mtx);
@@ -429,7 +436,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 	case IEEE802154_DEV_MONITOR:
 		sdata->dev->destructor = free_netdev;
 		sdata->dev->netdev_ops = &mac802154_monitor_ops;
-		sdata->promiscuous_mode = true;
+		wpan_dev->promiscuous_mode = true;
 		break;
 	default:
 		BUG();

commit 0916c02205ed76c03863b401e60fa105c4008cfa
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:29 2014 +0100

    mac802154: fix typo promisuous to promiscuous
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 51abe05a6aab..384f4bb3c99b 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -181,7 +181,7 @@ static int mac802154_wpan_open(struct net_device *dev)
 	mutex_lock(&phy->pib_lock);
 
 	if (local->hw.flags & IEEE802154_HW_PROMISCUOUS) {
-		rc = drv_set_promiscuous_mode(local, sdata->promisuous_mode);
+		rc = drv_set_promiscuous_mode(local, sdata->promiscuous_mode);
 		if (rc < 0)
 			goto out;
 	}
@@ -419,7 +419,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 		sdata->dev->destructor = mac802154_wpan_free;
 		sdata->dev->netdev_ops = &mac802154_wpan_ops;
 		sdata->dev->ml_priv = &mac802154_mlme_wpan;
-		sdata->promisuous_mode = false;
+		sdata->promiscuous_mode = false;
 
 		spin_lock_init(&sdata->mib_lock);
 		mutex_init(&sdata->sec_mtx);
@@ -429,7 +429,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 	case IEEE802154_DEV_MONITOR:
 		sdata->dev->destructor = free_netdev;
 		sdata->dev->netdev_ops = &mac802154_monitor_ops;
-		sdata->promisuous_mode = true;
+		sdata->promiscuous_mode = true;
 		break;
 	default:
 		BUG();

commit e57a8946847148560114a8deb8e9fad0112530b2
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:28 2014 +0100

    mac802154: use IEEE802154_EXTENDED_ADDR_LEN
    
    This patch removes the af_ieee802154 defines and use the
    IEEE802154_EXTENDED_ADDR_LEN. We should do this everywhere in the
    802.15.4 subsystem because af_ieee802154 should be normally an uapi
    header.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 97e5bed9f917..51abe05a6aab 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -24,7 +24,6 @@
 
 #include <net/rtnetlink.h>
 #include <linux/nl802154.h>
-#include <net/af_ieee802154.h>
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
 #include <net/cfg802154.h>
@@ -384,8 +383,8 @@ static void mac802154_wpan_free(struct net_device *dev)
 
 static void ieee802154_if_setup(struct net_device *dev)
 {
-	dev->addr_len		= IEEE802154_ADDR_LEN;
-	memset(dev->broadcast, 0xff, IEEE802154_ADDR_LEN);
+	dev->addr_len		= IEEE802154_EXTENDED_ADDR_LEN;
+	memset(dev->broadcast, 0xff, IEEE802154_EXTENDED_ADDR_LEN);
 
 	dev->hard_header_len	= MAC802154_FRAME_HARD_HEADER_LEN;
 	dev->needed_tailroom	= 2 + 16; /* FCS + MIC */

commit dee56d14779b1e01706adafb9e020303318e22e3
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:25 2014 +0100

    mac802154: add support for perm_extended_addr
    
    This patch adding support for a perm extended address. This is useful
    when a device supports an eeprom with a programmed static extended address.
    If a device doesn't support such eeprom or serial registers then the
    driver should generate a random extended address.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index a1aa09b03d12..97e5bed9f917 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -410,6 +410,7 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 	/* for compatibility, actual default is 3 */
 	sdata->mac_params.frame_retries = -1;
 
+	ieee802154_be64_to_le64(&sdata->extended_addr, sdata->dev->dev_addr);
 	sdata->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);
 	sdata->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);
 
@@ -471,6 +472,9 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 		goto err;
 	}
 
+	ieee802154_le64_to_be64(ndev->perm_addr,
+				&local->hw.phy->perm_extended_addr);
+	memcpy(ndev->dev_addr, ndev->perm_addr, IEEE802154_EXTENDED_ADDR_LEN);
 	/* TODO check this */
 	SET_NETDEV_DEV(ndev, &local->phy->dev);
 	sdata = netdev_priv(ndev);

commit 705cbbbe9ccca260658f971a4369c22f5704db75
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:24 2014 +0100

    mac802154: cleanup ieee802154_netdev_to_extended_addr
    
    This patch cleanups the ieee802154_be64_to_le64 to have a similar
    function like ieee802154_le64_to_be64 only with switched source and
    destionation types.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 764ce496fdc3..a1aa09b03d12 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -117,7 +117,7 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 	if (netif_running(dev))
 		return -EBUSY;
 
-	extended_addr = ieee802154_netdev_to_extended_addr(addr->sa_data);
+	ieee802154_be64_to_le64(&extended_addr, addr->sa_data);
 	if (!ieee802154_is_valid_extended_addr(extended_addr))
 		return -EINVAL;
 

commit 7c118c1a866454cf2091fd84404d0915a27b0eef
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:20 2014 +0100

    mac802154: add ieee802154_vif struct
    
    This patch adds an ieee802154_vif similar like the ieee80211_vif which
    holds the interface type and maybe further more attributes like the
    ieee80211_vif structure.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Varka Bhadram <varkabhadram@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 2e2638e72ae8..764ce496fdc3 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -136,10 +136,11 @@ static int mac802154_slave_open(struct net_device *dev)
 
 	ASSERT_RTNL();
 
-	if (sdata->type == IEEE802154_DEV_WPAN) {
+	if (sdata->vif.type == IEEE802154_DEV_WPAN) {
 		mutex_lock(&sdata->local->iflist_mtx);
 		list_for_each_entry(subif, &sdata->local->interfaces, list) {
-			if (subif != sdata && subif->type == sdata->type &&
+			if (subif != sdata &&
+			    subif->vif.type == sdata->vif.type &&
 			    ieee802154_sdata_running(subif)) {
 				mutex_unlock(&sdata->local->iflist_mtx);
 				return -EBUSY;
@@ -397,7 +398,7 @@ static int
 ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 {
 	/* set some type-dependent values */
-	sdata->type = type;
+	sdata->vif.type = type;
 
 	get_random_bytes(&sdata->bsn, 1);
 	get_random_bytes(&sdata->dsn, 1);
@@ -447,8 +448,8 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 
 	ASSERT_RTNL();
 
-	ndev = alloc_netdev(sizeof(*sdata), name, NET_NAME_UNKNOWN,
-			    ieee802154_if_setup);
+	ndev = alloc_netdev(sizeof(*sdata) + local->hw.vif_data_size, name,
+			    NET_NAME_UNKNOWN, ieee802154_if_setup);
 	if (!ndev)
 		return ERR_PTR(-ENOMEM);
 

commit bd28a11f25f2c2a563620e7be588dc4dd8a91396
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:18 2014 +0100

    ieee802154: remove mlme get_phy callback
    
    This patch removes the get_phy callback from mlme ops structure. Instead
    we doing a dereference via ieee802154_ptr dev pointer. For backwards
    compatibility we need to run get_device after dereference wpan_phy via
    ieee802154_ptr.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index f9ed608aa260..2e2638e72ae8 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -428,7 +428,6 @@ ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
 	case IEEE802154_DEV_MONITOR:
 		sdata->dev->destructor = free_netdev;
 		sdata->dev->netdev_ops = &mac802154_monitor_ops;
-		sdata->dev->ml_priv = &mac802154_mlme_reduced;
 		sdata->promisuous_mode = true;
 		break;
 	default:

commit d5ae67bacd9654b0e26b9f248249e9ee1b6e338b
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:17 2014 +0100

    ieee802154: rework interface registration
    
    This patch meld mac802154_netdev_register into ieee802154_if_add
    function. Also we have now only one alloc_netdev call with one interface
    setup routine "ieee802154_if_setup" instead two different one for each
    interface type. This patch checks via runtime the interface type and do
    different handling now. Additional we add the wpan_dev struct in
    ieee802154_sub_if_data and set the new ieee802154_ptr while netdev
    registration. This behaviour is very similar the mac80211 netdev
    registration functionality.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 78cb38124a2a..f9ed608aa260 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -381,30 +381,23 @@ static void mac802154_wpan_free(struct net_device *dev)
 	free_netdev(dev);
 }
 
-void mac802154_wpan_setup(struct net_device *dev)
+static void ieee802154_if_setup(struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata;
-
 	dev->addr_len		= IEEE802154_ADDR_LEN;
 	memset(dev->broadcast, 0xff, IEEE802154_ADDR_LEN);
 
 	dev->hard_header_len	= MAC802154_FRAME_HARD_HEADER_LEN;
-	dev->header_ops		= &mac802154_header_ops;
 	dev->needed_tailroom	= 2 + 16; /* FCS + MIC */
 	dev->mtu		= IEEE802154_MTU;
 	dev->tx_queue_len	= 300;
-	dev->type		= ARPHRD_IEEE802154;
 	dev->flags		= IFF_NOARP | IFF_BROADCAST;
+}
 
-	dev->destructor		= mac802154_wpan_free;
-	dev->netdev_ops		= &mac802154_wpan_ops;
-	dev->ml_priv		= &mac802154_mlme_wpan;
-
-	sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	sdata->type = IEEE802154_DEV_WPAN;
-
-	spin_lock_init(&sdata->mib_lock);
-	mutex_init(&sdata->sec_mtx);
+static int
+ieee802154_setup_sdata(struct ieee802154_sub_if_data *sdata, int type)
+{
+	/* set some type-dependent values */
+	sdata->type = type;
 
 	get_random_bytes(&sdata->bsn, 1);
 	get_random_bytes(&sdata->dsn, 1);
@@ -419,54 +412,28 @@ void mac802154_wpan_setup(struct net_device *dev)
 	sdata->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);
 	sdata->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);
 
-	sdata->promisuous_mode = false;
-
-	mac802154_llsec_init(&sdata->sec);
-}
-
-void mac802154_monitor_setup(struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata;
-
-	dev->needed_tailroom	= 2; /* room for FCS */
-	dev->mtu		= IEEE802154_MTU;
-	dev->tx_queue_len	= 10;
-	dev->type		= ARPHRD_IEEE802154_MONITOR;
-	dev->flags		= IFF_NOARP | IFF_BROADCAST;
-
-	dev->destructor		= free_netdev;
-	dev->netdev_ops		= &mac802154_monitor_ops;
-	dev->ml_priv		= &mac802154_mlme_reduced;
-
-	sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	sdata->type = IEEE802154_DEV_MONITOR;
-
-	sdata->promisuous_mode = true;
-}
-
-static int
-mac802154_netdev_register(struct ieee802154_local *local,
-			  struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	int err;
-
-	sdata->dev = dev;
-	sdata->local = local;
-
-	dev->needed_headroom = local->hw.extra_tx_headroom;
-
-	SET_NETDEV_DEV(dev, &local->phy->dev);
+	switch (type) {
+	case IEEE802154_DEV_WPAN:
+		sdata->dev->header_ops = &mac802154_header_ops;
+		sdata->dev->destructor = mac802154_wpan_free;
+		sdata->dev->netdev_ops = &mac802154_wpan_ops;
+		sdata->dev->ml_priv = &mac802154_mlme_wpan;
+		sdata->promisuous_mode = false;
 
-	err = register_netdev(dev);
-	if (err < 0)
-		return err;
+		spin_lock_init(&sdata->mib_lock);
+		mutex_init(&sdata->sec_mtx);
 
-	rtnl_lock();
-	mutex_lock(&local->iflist_mtx);
-	list_add_tail_rcu(&sdata->list, &local->interfaces);
-	mutex_unlock(&local->iflist_mtx);
-	rtnl_unlock();
+		mac802154_llsec_init(&sdata->sec);
+		break;
+	case IEEE802154_DEV_MONITOR:
+		sdata->dev->destructor = free_netdev;
+		sdata->dev->netdev_ops = &mac802154_monitor_ops;
+		sdata->dev->ml_priv = &mac802154_mlme_reduced;
+		sdata->promisuous_mode = true;
+		break;
+	default:
+		BUG();
+	}
 
 	return 0;
 }
@@ -475,38 +442,67 @@ struct net_device *
 ieee802154_if_add(struct ieee802154_local *local, const char *name,
 		  struct wpan_dev **new_wpan_dev, int type)
 {
-	struct net_device *dev;
-	int err = -ENOMEM;
+	struct net_device *ndev = NULL;
+	struct ieee802154_sub_if_data *sdata = NULL;
+	int ret = -ENOMEM;
+
+	ASSERT_RTNL();
+
+	ndev = alloc_netdev(sizeof(*sdata), name, NET_NAME_UNKNOWN,
+			    ieee802154_if_setup);
+	if (!ndev)
+		return ERR_PTR(-ENOMEM);
+
+	ndev->needed_headroom = local->hw.extra_tx_headroom;
+
+	ret = dev_alloc_name(ndev, ndev->name);
+	if (ret < 0)
+		goto err;
 
 	switch (type) {
-	case IEEE802154_DEV_MONITOR:
-		dev = alloc_netdev(sizeof(struct ieee802154_sub_if_data),
-				   name, NET_NAME_UNKNOWN,
-				   mac802154_monitor_setup);
-		break;
 	case IEEE802154_DEV_WPAN:
-		dev = alloc_netdev(sizeof(struct ieee802154_sub_if_data),
-				   name, NET_NAME_UNKNOWN,
-				   mac802154_wpan_setup);
+		ndev->type = ARPHRD_IEEE802154;
 		break;
-	default:
-		dev = NULL;
-		err = -EINVAL;
+	case IEEE802154_DEV_MONITOR:
+		ndev->type = ARPHRD_IEEE802154_MONITOR;
 		break;
+	default:
+		ret = -EINVAL;
+		goto err;
 	}
-	if (!dev)
+
+	/* TODO check this */
+	SET_NETDEV_DEV(ndev, &local->phy->dev);
+	sdata = netdev_priv(ndev);
+	ndev->ieee802154_ptr = &sdata->wpan_dev;
+	memcpy(sdata->name, ndev->name, IFNAMSIZ);
+	sdata->dev = ndev;
+	sdata->wpan_dev.wpan_phy = local->hw.phy;
+	sdata->local = local;
+
+	/* setup type-dependent data */
+	ret = ieee802154_setup_sdata(sdata, type);
+	if (ret)
 		goto err;
 
-	err = mac802154_netdev_register(local, dev);
-	if (err)
-		goto err_free;
+	if (ndev) {
+		ret = register_netdevice(ndev);
+		if (ret < 0)
+			goto err;
+	}
+
+	mutex_lock(&local->iflist_mtx);
+	list_add_tail_rcu(&sdata->list, &local->interfaces);
+	mutex_unlock(&local->iflist_mtx);
 
-	return dev;
+	if (new_wpan_dev)
+		*new_wpan_dev = &sdata->wpan_dev;
+
+	return ndev;
 
-err_free:
-	free_netdev(dev);
 err:
-	return ERR_PTR(err);
+	free_netdev(ndev);
+	return ERR_PTR(ret);
 }
 
 void ieee802154_if_remove(struct ieee802154_sub_if_data *sdata)

commit 12cb56c2370b2911295026630a71af044c12d2aa
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:16 2014 +0100

    mac802154: move dev_hold out of ieee802154_if_add
    
    This patch moves the dev_hold call inside of nl-phy ieee802154_add_iface
    function. The ieee802154_add_iface is the only one function which use the
    ieee802154_if_add function and contains the corresponding dev_put call.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index fced04b05275..78cb38124a2a 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -501,7 +501,6 @@ ieee802154_if_add(struct ieee802154_local *local, const char *name,
 	if (err)
 		goto err_free;
 
-	dev_hold(dev); /* we return an incremented device refcount */
 	return dev;
 
 err_free:

commit 986a8abfc51e66c96f9d39529a6ff0443fcd2591
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:15 2014 +0100

    mac802154: move interface add handling in iface
    
    This patch moves and renames the mac802154_add_iface and
    mac802154_netdev_register functions into iface.c. The function
    mac802154_add_iface is renamed to ieee802154_if_add which is a similar naming
    convention like mac80211.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 9d6012e430de..fced04b05275 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -444,6 +444,72 @@ void mac802154_monitor_setup(struct net_device *dev)
 	sdata->promisuous_mode = true;
 }
 
+static int
+mac802154_netdev_register(struct ieee802154_local *local,
+			  struct net_device *dev)
+{
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
+	int err;
+
+	sdata->dev = dev;
+	sdata->local = local;
+
+	dev->needed_headroom = local->hw.extra_tx_headroom;
+
+	SET_NETDEV_DEV(dev, &local->phy->dev);
+
+	err = register_netdev(dev);
+	if (err < 0)
+		return err;
+
+	rtnl_lock();
+	mutex_lock(&local->iflist_mtx);
+	list_add_tail_rcu(&sdata->list, &local->interfaces);
+	mutex_unlock(&local->iflist_mtx);
+	rtnl_unlock();
+
+	return 0;
+}
+
+struct net_device *
+ieee802154_if_add(struct ieee802154_local *local, const char *name,
+		  struct wpan_dev **new_wpan_dev, int type)
+{
+	struct net_device *dev;
+	int err = -ENOMEM;
+
+	switch (type) {
+	case IEEE802154_DEV_MONITOR:
+		dev = alloc_netdev(sizeof(struct ieee802154_sub_if_data),
+				   name, NET_NAME_UNKNOWN,
+				   mac802154_monitor_setup);
+		break;
+	case IEEE802154_DEV_WPAN:
+		dev = alloc_netdev(sizeof(struct ieee802154_sub_if_data),
+				   name, NET_NAME_UNKNOWN,
+				   mac802154_wpan_setup);
+		break;
+	default:
+		dev = NULL;
+		err = -EINVAL;
+		break;
+	}
+	if (!dev)
+		goto err;
+
+	err = mac802154_netdev_register(local, dev);
+	if (err)
+		goto err_free;
+
+	dev_hold(dev); /* we return an incremented device refcount */
+	return dev;
+
+err_free:
+	free_netdev(dev);
+err:
+	return ERR_PTR(err);
+}
+
 void ieee802154_if_remove(struct ieee802154_sub_if_data *sdata)
 {
 	ASSERT_RTNL();

commit b210b18747cb511bb71f6a49c97e8d38f639b435
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:14 2014 +0100

    mac802154: move interface del handling in iface
    
    This patch moves and rename the mac802154_del_iface function into
    iface.c and rename the function to ieee802154_if_remove which is a similar
    naming convention like mac80211.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 0c9d00c83654..9d6012e430de 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -443,3 +443,15 @@ void mac802154_monitor_setup(struct net_device *dev)
 
 	sdata->promisuous_mode = true;
 }
+
+void ieee802154_if_remove(struct ieee802154_sub_if_data *sdata)
+{
+	ASSERT_RTNL();
+
+	mutex_lock(&sdata->local->iflist_mtx);
+	list_del_rcu(&sdata->list);
+	mutex_unlock(&sdata->local->iflist_mtx);
+
+	synchronize_rcu();
+	unregister_netdevice(sdata->dev);
+}

commit 868ed8e06a35ea2e73dfe4cb81d96dc85f545a8e
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 21:43:06 2014 +0100

    ieee802154: remove unnecessary functions
    
    This patch fixes commit c7420c367d63a7e1414e010afb52c3837fd9134e
    ("mac802154: move mac_params functions into mac_cmd"). The mac_params
    functions wasn't deleted by this commit.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reported-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index ceedf3ef1ce2..0c9d00c83654 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -127,28 +127,6 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 	return mac802154_wpan_update_llsec(dev);
 }
 
-int mac802154_set_mac_params(struct net_device *dev,
-			     const struct ieee802154_mac_params *params)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-
-	mutex_lock(&sdata->local->iflist_mtx);
-	sdata->mac_params = *params;
-	mutex_unlock(&sdata->local->iflist_mtx);
-
-	return 0;
-}
-
-void mac802154_get_mac_params(struct net_device *dev,
-			      struct ieee802154_mac_params *params)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-
-	mutex_lock(&sdata->local->iflist_mtx);
-	*params = sdata->mac_params;
-	mutex_unlock(&sdata->local->iflist_mtx);
-}
-
 static int mac802154_slave_open(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);

commit ea7053c1df41689dea0db2c49dc9d25dbe8fcf33
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:46 2014 +0100

    mac802154: iface: add validation for extended address
    
    This patch use the validation function to check if an extended address
    is valid or not while set the extended address.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index eaad66590f10..ceedf3ef1ce2 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -112,13 +112,17 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct sockaddr *addr = p;
+	__le64 extended_addr;
 
 	if (netif_running(dev))
 		return -EBUSY;
 
-	/* FIXME: validate addr */
+	extended_addr = ieee802154_netdev_to_extended_addr(addr->sa_data);
+	if (!ieee802154_is_valid_extended_addr(extended_addr))
+		return -EINVAL;
+
 	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
-	sdata->extended_addr = ieee802154_netdev_to_extended_addr(dev->dev_addr);
+	sdata->extended_addr = extended_addr;
 
 	return mac802154_wpan_update_llsec(dev);
 }

commit f59f419d31ee27c131b44beda5b14b8ce0aaf519
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:44 2014 +0100

    mac802154: move phy settings into netlink receive
    
    All PHY attributes should be directly set to the transceiver after netlink.
    MAC attributes should be set by interface up. Currently the macparams
    netlink cmd contains mixed attributes of phy and mac settings. This patch
    moves all phy settings to the netlink receive function for setting macparams.
    This is the only way which doesn't change the userspace API and keep the
    deprecated netlink interface alive.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 5f94c70478f9..eaad66590f10 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -218,31 +218,12 @@ static int mac802154_wpan_open(struct net_device *dev)
 			goto out;
 	}
 
-	if (local->hw.flags & IEEE802154_HW_TXPOWER) {
-		rc = drv_set_tx_power(local, sdata->mac_params.transmit_power);
-		if (rc < 0)
-			goto out;
-	}
-
 	if (local->hw.flags & IEEE802154_HW_LBT) {
 		rc = drv_set_lbt_mode(local, sdata->mac_params.lbt);
 		if (rc < 0)
 			goto out;
 	}
 
-	if (local->hw.flags & IEEE802154_HW_CCA_MODE) {
-		rc = drv_set_cca_mode(local, sdata->mac_params.cca_mode);
-		if (rc < 0)
-			goto out;
-	}
-
-	if (local->hw.flags & IEEE802154_HW_CCA_ED_LEVEL) {
-		rc = drv_set_cca_ed_level(local,
-					  sdata->mac_params.cca_ed_level);
-		if (rc < 0)
-			goto out;
-	}
-
 	if (local->hw.flags & IEEE802154_HW_CSMA_PARAMS) {
 		rc = drv_set_csma_params(local, sdata->mac_params.min_be,
 					 sdata->mac_params.max_be,

commit 50c79075019e7b952327cfebf0681548573fd8e5
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:43 2014 +0100

    mac802154: set panid address filter on ifup
    
    This patch moves the setting of hardware panid address filtering
    inside of interface up instead doing it it directly inside of netlink
    interface. The netlink call which can only be called when netif isn't
    running sets only the necessary panid value in sdata. After an
    interface up the address filter will be set with this value.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 1bae29dff082..5f94c70478f9 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -205,6 +205,10 @@ static int mac802154_wpan_open(struct net_device *dev)
 	}
 
 	if (local->hw.flags & IEEE802154_HW_AFILT) {
+		rc = drv_set_pan_id(local, sdata->pan_id);
+		if (rc < 0)
+			goto out;
+
 		rc = drv_set_extended_addr(local, sdata->extended_addr);
 		if (rc < 0)
 			goto out;

commit 78b4bad16ec41e1d3d5575ff9aca29aab2f831bc
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:42 2014 +0100

    mac802154: set short address filter on ifup
    
    This patch moves the setting of hardware short address filtering
    inside of interface up instead doing it it directly inside of netlink
    interface. The netlink call which can only be called when netif isn't
    running sets only the necessary short_addr value in sdata. After an
    interface up the address filter will be set with this value.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index a509a7151be9..1bae29dff082 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -208,6 +208,10 @@ static int mac802154_wpan_open(struct net_device *dev)
 		rc = drv_set_extended_addr(local, sdata->extended_addr);
 		if (rc < 0)
 			goto out;
+
+		rc = drv_set_short_addr(local, sdata->short_addr);
+		if (rc < 0)
+			goto out;
 	}
 
 	if (local->hw.flags & IEEE802154_HW_TXPOWER) {

commit 776e59de46b5db368e1bd0a4ec5c4feaa740a3d1
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:41 2014 +0100

    mac802154: set extended address filter on ifup
    
    This patch moves the setting of hardware extended address filtering
    inside of interface up instead doing it directly inside of netlink interface.
    Also we don't need to set the sdata extended attribute in netlink. This
    is already done by ndo_set_mac_address of net_device_ops.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index f7a6f83301e2..a509a7151be9 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -110,6 +110,7 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 
 static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 {
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct sockaddr *addr = p;
 
 	if (netif_running(dev))
@@ -117,7 +118,8 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 
 	/* FIXME: validate addr */
 	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
-	mac802154_dev_set_ieee_addr(dev);
+	sdata->extended_addr = ieee802154_netdev_to_extended_addr(dev->dev_addr);
+
 	return mac802154_wpan_update_llsec(dev);
 }
 
@@ -202,6 +204,12 @@ static int mac802154_wpan_open(struct net_device *dev)
 			goto out;
 	}
 
+	if (local->hw.flags & IEEE802154_HW_AFILT) {
+		rc = drv_set_extended_addr(local, sdata->extended_addr);
+		if (rc < 0)
+			goto out;
+	}
+
 	if (local->hw.flags & IEEE802154_HW_TXPOWER) {
 		rc = drv_set_tx_power(local, sdata->mac_params.transmit_power);
 		if (rc < 0)

commit 38130c31ef50de1999983601e448db2b1bc1057c
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:44 2014 +0100

    mac802154: add basic support for monitor
    
    This patch adds basic support for monitor mode. Also change the open
    call that we set the transceiver mac setting on an interface up. Futher
    patches will add a better handling while interface up an interface.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index c0bf5f9b9953..f7a6f83301e2 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -196,6 +196,12 @@ static int mac802154_wpan_open(struct net_device *dev)
 
 	mutex_lock(&phy->pib_lock);
 
+	if (local->hw.flags & IEEE802154_HW_PROMISCUOUS) {
+		rc = drv_set_promiscuous_mode(local, sdata->promisuous_mode);
+		if (rc < 0)
+			goto out;
+	}
+
 	if (local->hw.flags & IEEE802154_HW_TXPOWER) {
 		rc = drv_set_tx_power(local, sdata->mac_params.transmit_power);
 		if (rc < 0)
@@ -382,7 +388,7 @@ static const struct net_device_ops mac802154_wpan_ops = {
 };
 
 static const struct net_device_ops mac802154_monitor_ops = {
-	.ndo_open		= mac802154_slave_open,
+	.ndo_open		= mac802154_wpan_open,
 	.ndo_stop		= mac802154_slave_close,
 	.ndo_start_xmit		= ieee802154_monitor_start_xmit,
 };
@@ -434,6 +440,8 @@ void mac802154_wpan_setup(struct net_device *dev)
 	sdata->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);
 	sdata->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);
 
+	sdata->promisuous_mode = false;
+
 	mac802154_llsec_init(&sdata->sec);
 }
 
@@ -453,4 +461,6 @@ void mac802154_monitor_setup(struct net_device *dev)
 
 	sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	sdata->type = IEEE802154_DEV_MONITOR;
+
+	sdata->promisuous_mode = true;
 }

commit 74457641558baded3c9f05bc3fb81293a2c02b2e
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:31 2014 +0100

    mac802154: cleanup open count handling
    
    This patch cleanups the open_count variable increment in open and close
    calls of netdev.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 1c0274ed9370..c0bf5f9b9953 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -166,19 +166,19 @@ static int mac802154_slave_open(struct net_device *dev)
 
 	set_bit(SDATA_STATE_RUNNING, &sdata->state);
 
-	if (local->open_count++ == 0) {
+	if (!local->open_count) {
 		res = drv_start(local);
 		WARN_ON(res);
 		if (res)
 			goto err;
 	}
 
+	local->open_count++;
 	netif_start_queue(dev);
 	return 0;
 err:
 	/* might already be clear but that doesn't matter */
 	clear_bit(SDATA_STATE_RUNNING, &sdata->state);
-	sdata->local->open_count--;
 
 	return res;
 }
@@ -252,10 +252,11 @@ static int mac802154_slave_close(struct net_device *dev)
 	ASSERT_RTNL();
 
 	netif_stop_queue(dev);
+	local->open_count--;
 
 	clear_bit(SDATA_STATE_RUNNING, &sdata->state);
 
-	if (!--local->open_count)
+	if (!local->open_count)
 		drv_stop(local);
 
 	return 0;

commit 12439a53560097bc8e42cf14967717d14588dddd
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:29 2014 +0100

    mac802154: remove channel attributes from sdata
    
    These channel attributes was part of "channel context switch while xmit"
    which was removed by commit dc67c6b30f36d57b70b70547a30e7a8432540c6f
    ("mac802154: tx: remove xmit channel context switch"). This patch
    removes these unnecessary variables and use the current_page and
    current_channel by wpan_phy struct now.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 2423aa7671df..1c0274ed9370 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -417,8 +417,6 @@ void mac802154_wpan_setup(struct net_device *dev)
 	sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	sdata->type = IEEE802154_DEV_WPAN;
 
-	sdata->chan = MAC802154_CHAN_NONE;
-
 	spin_lock_init(&sdata->mib_lock);
 	mutex_init(&sdata->sec_mtx);
 
@@ -454,6 +452,4 @@ void mac802154_monitor_setup(struct net_device *dev)
 
 	sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	sdata->type = IEEE802154_DEV_MONITOR;
-
-	sdata->chan = MAC802154_CHAN_NONE; /* not initialized */
 }

commit 33d4189f51f0dbb522a4d81aafc7edb2e048c570
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:28 2014 +0100

    mac802154: iface: remove assign to zero
    
    These variables should already be zero, so we remove the extra assign to
    zero.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index e10fd786a11f..2423aa7671df 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -409,7 +409,6 @@ void mac802154_wpan_setup(struct net_device *dev)
 	dev->tx_queue_len	= 300;
 	dev->type		= ARPHRD_IEEE802154;
 	dev->flags		= IFF_NOARP | IFF_BROADCAST;
-	dev->watchdog_timeo	= 0;
 
 	dev->destructor		= mac802154_wpan_free;
 	dev->netdev_ops		= &mac802154_wpan_ops;
@@ -419,7 +418,6 @@ void mac802154_wpan_setup(struct net_device *dev)
 	sdata->type = IEEE802154_DEV_WPAN;
 
 	sdata->chan = MAC802154_CHAN_NONE;
-	sdata->page = 0;
 
 	spin_lock_init(&sdata->mib_lock);
 	mutex_init(&sdata->sec_mtx);
@@ -444,14 +442,11 @@ void mac802154_monitor_setup(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata;
 
-	dev->addr_len		= 0;
-	dev->hard_header_len	= 0;
 	dev->needed_tailroom	= 2; /* room for FCS */
 	dev->mtu		= IEEE802154_MTU;
 	dev->tx_queue_len	= 10;
 	dev->type		= ARPHRD_IEEE802154_MONITOR;
 	dev->flags		= IFF_NOARP | IFF_BROADCAST;
-	dev->watchdog_timeo	= 0;
 
 	dev->destructor		= free_netdev;
 	dev->netdev_ops		= &mac802154_monitor_ops;
@@ -461,5 +456,4 @@ void mac802154_monitor_setup(struct net_device *dev)
 	sdata->type = IEEE802154_DEV_MONITOR;
 
 	sdata->chan = MAC802154_CHAN_NONE; /* not initialized */
-	sdata->page = 0;
 }

commit 0ea3da64fa602efa0a89502eefdb396be84d2eba
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:24 2014 +0100

    mac802154: rework sdata state change to running
    
    This patch reworks the handling for setting the state like mac80211. We
    use bit's instead a bool variable. The mutex is not needed because it use
    test and set bits which are atomic operations.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 300877a1a0c9..e10fd786a11f 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -156,7 +156,7 @@ static int mac802154_slave_open(struct net_device *dev)
 		mutex_lock(&sdata->local->iflist_mtx);
 		list_for_each_entry(subif, &sdata->local->interfaces, list) {
 			if (subif != sdata && subif->type == sdata->type &&
-			    subif->running) {
+			    ieee802154_sdata_running(subif)) {
 				mutex_unlock(&sdata->local->iflist_mtx);
 				return -EBUSY;
 			}
@@ -164,9 +164,7 @@ static int mac802154_slave_open(struct net_device *dev)
 		mutex_unlock(&sdata->local->iflist_mtx);
 	}
 
-	mutex_lock(&sdata->local->iflist_mtx);
-	sdata->running = true;
-	mutex_unlock(&sdata->local->iflist_mtx);
+	set_bit(SDATA_STATE_RUNNING, &sdata->state);
 
 	if (local->open_count++ == 0) {
 		res = drv_start(local);
@@ -178,6 +176,8 @@ static int mac802154_slave_open(struct net_device *dev)
 	netif_start_queue(dev);
 	return 0;
 err:
+	/* might already be clear but that doesn't matter */
+	clear_bit(SDATA_STATE_RUNNING, &sdata->state);
 	sdata->local->open_count--;
 
 	return res;
@@ -253,9 +253,7 @@ static int mac802154_slave_close(struct net_device *dev)
 
 	netif_stop_queue(dev);
 
-	mutex_lock(&sdata->local->iflist_mtx);
-	sdata->running = false;
-	mutex_unlock(&sdata->local->iflist_mtx);
+	clear_bit(SDATA_STATE_RUNNING, &sdata->state);
 
 	if (!--local->open_count)
 		drv_stop(local);

commit a543c5989d7711d984608f4e12a73218642ca865
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:23 2014 +0100

    mac802154: remove driver ops in wpan-phy
    
    This patch removes the driver ops callbacks inside of wpan_phy struct.
    It was used to check if a phy supports this driver ops call. We do this
    now via hardware flags.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 025cd5aba13f..300877a1a0c9 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -196,32 +196,32 @@ static int mac802154_wpan_open(struct net_device *dev)
 
 	mutex_lock(&phy->pib_lock);
 
-	if (phy->set_txpower) {
+	if (local->hw.flags & IEEE802154_HW_TXPOWER) {
 		rc = drv_set_tx_power(local, sdata->mac_params.transmit_power);
 		if (rc < 0)
 			goto out;
 	}
 
-	if (phy->set_lbt) {
+	if (local->hw.flags & IEEE802154_HW_LBT) {
 		rc = drv_set_lbt_mode(local, sdata->mac_params.lbt);
 		if (rc < 0)
 			goto out;
 	}
 
-	if (phy->set_cca_mode) {
+	if (local->hw.flags & IEEE802154_HW_CCA_MODE) {
 		rc = drv_set_cca_mode(local, sdata->mac_params.cca_mode);
 		if (rc < 0)
 			goto out;
 	}
 
-	if (phy->set_cca_ed_level) {
+	if (local->hw.flags & IEEE802154_HW_CCA_ED_LEVEL) {
 		rc = drv_set_cca_ed_level(local,
 					  sdata->mac_params.cca_ed_level);
 		if (rc < 0)
 			goto out;
 	}
 
-	if (phy->set_csma_params) {
+	if (local->hw.flags & IEEE802154_HW_CSMA_PARAMS) {
 		rc = drv_set_csma_params(local, sdata->mac_params.min_be,
 					 sdata->mac_params.max_be,
 					 sdata->mac_params.csma_retries);
@@ -229,7 +229,7 @@ static int mac802154_wpan_open(struct net_device *dev)
 			goto out;
 	}
 
-	if (phy->set_frame_retries) {
+	if (local->hw.flags & IEEE802154_HW_FRAME_RETRIES) {
 		rc = drv_set_max_frame_retries(local,
 					       sdata->mac_params.frame_retries);
 		if (rc < 0)

commit 59cb300f2b2ce1fc46696deb9a7bd066cd53a65a
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:21 2014 +0100

    mac802154: use driver-ops function wrappers
    
    This patch replaces all directly called driver ops by previous
    introduced driver-ops function wrappers.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 0b21413081f1..025cd5aba13f 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -30,6 +30,7 @@
 #include <net/cfg802154.h>
 
 #include "ieee802154_i.h"
+#include "driver-ops.h"
 
 static int mac802154_wpan_update_llsec(struct net_device *dev)
 {
@@ -168,7 +169,7 @@ static int mac802154_slave_open(struct net_device *dev)
 	mutex_unlock(&sdata->local->iflist_mtx);
 
 	if (local->open_count++ == 0) {
-		res = local->ops->start(&local->hw);
+		res = drv_start(local);
 		WARN_ON(res);
 		if (res)
 			goto err;
@@ -186,6 +187,7 @@ static int mac802154_wpan_open(struct net_device *dev)
 {
 	int rc;
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
+	struct ieee802154_local *local = sdata->local;
 	struct wpan_phy *phy = sdata->local->phy;
 
 	rc = mac802154_slave_open(dev);
@@ -195,40 +197,41 @@ static int mac802154_wpan_open(struct net_device *dev)
 	mutex_lock(&phy->pib_lock);
 
 	if (phy->set_txpower) {
-		rc = phy->set_txpower(phy, sdata->mac_params.transmit_power);
+		rc = drv_set_tx_power(local, sdata->mac_params.transmit_power);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (phy->set_lbt) {
-		rc = phy->set_lbt(phy, sdata->mac_params.lbt);
+		rc = drv_set_lbt_mode(local, sdata->mac_params.lbt);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (phy->set_cca_mode) {
-		rc = phy->set_cca_mode(phy, sdata->mac_params.cca_mode);
+		rc = drv_set_cca_mode(local, sdata->mac_params.cca_mode);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (phy->set_cca_ed_level) {
-		rc = phy->set_cca_ed_level(phy, sdata->mac_params.cca_ed_level);
+		rc = drv_set_cca_ed_level(local,
+					  sdata->mac_params.cca_ed_level);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (phy->set_csma_params) {
-		rc = phy->set_csma_params(phy, sdata->mac_params.min_be,
-					  sdata->mac_params.max_be,
-					  sdata->mac_params.csma_retries);
+		rc = drv_set_csma_params(local, sdata->mac_params.min_be,
+					 sdata->mac_params.max_be,
+					 sdata->mac_params.csma_retries);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (phy->set_frame_retries) {
-		rc = phy->set_frame_retries(phy,
-					    sdata->mac_params.frame_retries);
+		rc = drv_set_max_frame_retries(local,
+					       sdata->mac_params.frame_retries);
 		if (rc < 0)
 			goto out;
 	}
@@ -255,7 +258,7 @@ static int mac802154_slave_close(struct net_device *dev)
 	mutex_unlock(&sdata->local->iflist_mtx);
 
 	if (!--local->open_count)
-		local->ops->stop(&local->hw);
+		drv_stop(local);
 
 	return 0;
 }

commit 19ec690a431d8ebf3e9d939160dc223ad40d7d63
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:17 2014 +0100

    mac802154: main: move open and close into iface
    
    These functions can be static inside the iface file, because it's not
    used anywhere else. This patch moves these functions into iface file.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index dafb2c3ac109..0b21413081f1 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -142,6 +142,46 @@ void mac802154_get_mac_params(struct net_device *dev,
 	mutex_unlock(&sdata->local->iflist_mtx);
 }
 
+static int mac802154_slave_open(struct net_device *dev)
+{
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
+	struct ieee802154_sub_if_data *subif;
+	struct ieee802154_local *local = sdata->local;
+	int res = 0;
+
+	ASSERT_RTNL();
+
+	if (sdata->type == IEEE802154_DEV_WPAN) {
+		mutex_lock(&sdata->local->iflist_mtx);
+		list_for_each_entry(subif, &sdata->local->interfaces, list) {
+			if (subif != sdata && subif->type == sdata->type &&
+			    subif->running) {
+				mutex_unlock(&sdata->local->iflist_mtx);
+				return -EBUSY;
+			}
+		}
+		mutex_unlock(&sdata->local->iflist_mtx);
+	}
+
+	mutex_lock(&sdata->local->iflist_mtx);
+	sdata->running = true;
+	mutex_unlock(&sdata->local->iflist_mtx);
+
+	if (local->open_count++ == 0) {
+		res = local->ops->start(&local->hw);
+		WARN_ON(res);
+		if (res)
+			goto err;
+	}
+
+	netif_start_queue(dev);
+	return 0;
+err:
+	sdata->local->open_count--;
+
+	return res;
+}
+
 static int mac802154_wpan_open(struct net_device *dev)
 {
 	int rc;
@@ -201,6 +241,25 @@ static int mac802154_wpan_open(struct net_device *dev)
 	return rc;
 }
 
+static int mac802154_slave_close(struct net_device *dev)
+{
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
+	struct ieee802154_local *local = sdata->local;
+
+	ASSERT_RTNL();
+
+	netif_stop_queue(dev);
+
+	mutex_lock(&sdata->local->iflist_mtx);
+	sdata->running = false;
+	mutex_unlock(&sdata->local->iflist_mtx);
+
+	if (!--local->open_count)
+		local->ops->stop(&local->hw);
+
+	return 0;
+}
+
 static int mac802154_set_header_security(struct ieee802154_sub_if_data *sdata,
 					 struct ieee802154_hdr *hdr,
 					 const struct ieee802154_mac_cb *cb)

commit b9ff77e50c6e469db63dfc8fcc62586522649cd3
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:16 2014 +0100

    mac802154: monitor: merge into iface implementation
    
    This patch removes the monitor implementation file and put all monitor
    stuff into iface file. It's now small enough to put all necessary
    handling into iface.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 7e4bffcbcd4d..dafb2c3ac109 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -320,6 +320,12 @@ static const struct net_device_ops mac802154_wpan_ops = {
 	.ndo_set_mac_address	= mac802154_wpan_mac_addr,
 };
 
+static const struct net_device_ops mac802154_monitor_ops = {
+	.ndo_open		= mac802154_slave_open,
+	.ndo_stop		= mac802154_slave_close,
+	.ndo_start_xmit		= ieee802154_monitor_start_xmit,
+};
+
 static void mac802154_wpan_free(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
@@ -373,3 +379,27 @@ void mac802154_wpan_setup(struct net_device *dev)
 
 	mac802154_llsec_init(&sdata->sec);
 }
+
+void mac802154_monitor_setup(struct net_device *dev)
+{
+	struct ieee802154_sub_if_data *sdata;
+
+	dev->addr_len		= 0;
+	dev->hard_header_len	= 0;
+	dev->needed_tailroom	= 2; /* room for FCS */
+	dev->mtu		= IEEE802154_MTU;
+	dev->tx_queue_len	= 10;
+	dev->type		= ARPHRD_IEEE802154_MONITOR;
+	dev->flags		= IFF_NOARP | IFF_BROADCAST;
+	dev->watchdog_timeo	= 0;
+
+	dev->destructor		= free_netdev;
+	dev->netdev_ops		= &mac802154_monitor_ops;
+	dev->ml_priv		= &mac802154_mlme_reduced;
+
+	sdata = IEEE802154_DEV_TO_SUB_IF(dev);
+	sdata->type = IEEE802154_DEV_MONITOR;
+
+	sdata->chan = MAC802154_CHAN_NONE; /* not initialized */
+	sdata->page = 0;
+}

commit 2a9820c9e20a7889bf464e1edff5f75d685a8214
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:32 2014 +0100

    mac802154: rx: move receive handling into rx.c
    
    This patch removes all relevant receiving functions inclusive frame
    parsing into rx file. Like mac80211 we should implement the complete
    receive handling and parsing in this file.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 311f60c8629b..7e4bffcbcd4d 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -373,189 +373,3 @@ void mac802154_wpan_setup(struct net_device *dev)
 
 	mac802154_llsec_init(&sdata->sec);
 }
-
-static int mac802154_process_data(struct net_device *dev, struct sk_buff *skb)
-{
-	return netif_receive_skb(skb);
-}
-
-static int
-mac802154_subif_frame(struct ieee802154_sub_if_data *sdata, struct sk_buff *skb,
-		      const struct ieee802154_hdr *hdr)
-{
-	__le16 span, sshort;
-	int rc;
-
-	pr_debug("getting packet via slave interface %s\n", sdata->dev->name);
-
-	spin_lock_bh(&sdata->mib_lock);
-
-	span = sdata->pan_id;
-	sshort = sdata->short_addr;
-
-	switch (mac_cb(skb)->dest.mode) {
-	case IEEE802154_ADDR_NONE:
-		if (mac_cb(skb)->dest.mode != IEEE802154_ADDR_NONE)
-			/* FIXME: check if we are PAN coordinator */
-			skb->pkt_type = PACKET_OTHERHOST;
-		else
-			/* ACK comes with both addresses empty */
-			skb->pkt_type = PACKET_HOST;
-		break;
-	case IEEE802154_ADDR_LONG:
-		if (mac_cb(skb)->dest.pan_id != span &&
-		    mac_cb(skb)->dest.pan_id != cpu_to_le16(IEEE802154_PANID_BROADCAST))
-			skb->pkt_type = PACKET_OTHERHOST;
-		else if (mac_cb(skb)->dest.extended_addr == sdata->extended_addr)
-			skb->pkt_type = PACKET_HOST;
-		else
-			skb->pkt_type = PACKET_OTHERHOST;
-		break;
-	case IEEE802154_ADDR_SHORT:
-		if (mac_cb(skb)->dest.pan_id != span &&
-		    mac_cb(skb)->dest.pan_id != cpu_to_le16(IEEE802154_PANID_BROADCAST))
-			skb->pkt_type = PACKET_OTHERHOST;
-		else if (mac_cb(skb)->dest.short_addr == sshort)
-			skb->pkt_type = PACKET_HOST;
-		else if (mac_cb(skb)->dest.short_addr ==
-			  cpu_to_le16(IEEE802154_ADDR_BROADCAST))
-			skb->pkt_type = PACKET_BROADCAST;
-		else
-			skb->pkt_type = PACKET_OTHERHOST;
-		break;
-	default:
-		spin_unlock_bh(&sdata->mib_lock);
-		pr_debug("invalid dest mode\n");
-		kfree_skb(skb);
-		return NET_RX_DROP;
-	}
-
-	spin_unlock_bh(&sdata->mib_lock);
-
-	skb->dev = sdata->dev;
-
-	rc = mac802154_llsec_decrypt(&sdata->sec, skb);
-	if (rc) {
-		pr_debug("decryption failed: %i\n", rc);
-		goto fail;
-	}
-
-	sdata->dev->stats.rx_packets++;
-	sdata->dev->stats.rx_bytes += skb->len;
-
-	switch (mac_cb(skb)->type) {
-	case IEEE802154_FC_TYPE_DATA:
-		return mac802154_process_data(sdata->dev, skb);
-	default:
-		pr_warn("ieee802154: bad frame received (type = %d)\n",
-			mac_cb(skb)->type);
-		goto fail;
-	}
-
-fail:
-	kfree_skb(skb);
-	return NET_RX_DROP;
-}
-
-static void mac802154_print_addr(const char *name,
-				 const struct ieee802154_addr *addr)
-{
-	if (addr->mode == IEEE802154_ADDR_NONE)
-		pr_debug("%s not present\n", name);
-
-	pr_debug("%s PAN ID: %04x\n", name, le16_to_cpu(addr->pan_id));
-	if (addr->mode == IEEE802154_ADDR_SHORT) {
-		pr_debug("%s is short: %04x\n", name,
-			 le16_to_cpu(addr->short_addr));
-	} else {
-		u64 hw = swab64((__force u64) addr->extended_addr);
-
-		pr_debug("%s is hardware: %8phC\n", name, &hw);
-	}
-}
-
-static int mac802154_parse_frame_start(struct sk_buff *skb,
-				       struct ieee802154_hdr *hdr)
-{
-	int hlen;
-	struct ieee802154_mac_cb *cb = mac_cb_init(skb);
-
-	hlen = ieee802154_hdr_pull(skb, hdr);
-	if (hlen < 0)
-		return -EINVAL;
-
-	skb->mac_len = hlen;
-
-	pr_debug("fc: %04x dsn: %02x\n", le16_to_cpup((__le16 *)&hdr->fc),
-		 hdr->seq);
-
-	cb->type = hdr->fc.type;
-	cb->ackreq = hdr->fc.ack_request;
-	cb->secen = hdr->fc.security_enabled;
-
-	mac802154_print_addr("destination", &hdr->dest);
-	mac802154_print_addr("source", &hdr->source);
-
-	cb->source = hdr->source;
-	cb->dest = hdr->dest;
-
-	if (hdr->fc.security_enabled) {
-		u64 key;
-
-		pr_debug("seclevel %i\n", hdr->sec.level);
-
-		switch (hdr->sec.key_id_mode) {
-		case IEEE802154_SCF_KEY_IMPLICIT:
-			pr_debug("implicit key\n");
-			break;
-
-		case IEEE802154_SCF_KEY_INDEX:
-			pr_debug("key %02x\n", hdr->sec.key_id);
-			break;
-
-		case IEEE802154_SCF_KEY_SHORT_INDEX:
-			pr_debug("key %04x:%04x %02x\n",
-				 le32_to_cpu(hdr->sec.short_src) >> 16,
-				 le32_to_cpu(hdr->sec.short_src) & 0xffff,
-				 hdr->sec.key_id);
-			break;
-
-		case IEEE802154_SCF_KEY_HW_INDEX:
-			key = swab64((__force u64) hdr->sec.extended_src);
-			pr_debug("key source %8phC %02x\n", &key,
-				 hdr->sec.key_id);
-			break;
-		}
-	}
-
-	return 0;
-}
-
-void mac802154_wpans_rx(struct ieee802154_local *local, struct sk_buff *skb)
-{
-	int ret;
-	struct ieee802154_sub_if_data *sdata;
-	struct ieee802154_hdr hdr;
-
-	ret = mac802154_parse_frame_start(skb, &hdr);
-	if (ret) {
-		pr_debug("got invalid frame\n");
-		kfree_skb(skb);
-		return;
-	}
-
-	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-		if (sdata->type != IEEE802154_DEV_WPAN ||
-		    !netif_running(sdata->dev))
-			continue;
-
-		mac802154_subif_frame(sdata, skb, &hdr);
-		skb = NULL;
-		break;
-	}
-	rcu_read_unlock();
-
-	if (skb)
-		kfree_skb(skb);
-}

commit c5c47e67bcd24638a059b1b5e9ec18c95f8634ca
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:30 2014 +0100

    mac802154: rx: use tasklet instead workqueue
    
    Tasklets have much less overhead than workqueues. This patch also
    removes the heap allocation for the worker on receiving path.
    Like mac80211 we should prefer use a tasklet here instead a workqueue to
    getting fast out of interrupt context when ieee802154_rx_irqsafe is
    called by driver. Like wireless inside the tasklet context we should
    call netif_receive_skb instead netif_rx_ni anymore.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index be45dc9257b3..311f60c8629b 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -376,7 +376,7 @@ void mac802154_wpan_setup(struct net_device *dev)
 
 static int mac802154_process_data(struct net_device *dev, struct sk_buff *skb)
 {
-	return netif_rx_ni(skb);
+	return netif_receive_skb(skb);
 }
 
 static int

commit e5e584fcc26b6b2225855b6fdba64d90dd8e2ea6
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:13 2014 +0100

    mac802154: tx: change naming convention
    
    This patch changes the naming convention of the tx functions like
    mac80211. Just with an 802154 instead 80211 inside the name.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index f14e4365c4c7..be45dc9257b3 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -315,7 +315,7 @@ static struct header_ops mac802154_header_ops = {
 static const struct net_device_ops mac802154_wpan_ops = {
 	.ndo_open		= mac802154_wpan_open,
 	.ndo_stop		= mac802154_slave_close,
-	.ndo_start_xmit		= mac802154_wpan_xmit,
+	.ndo_start_xmit		= ieee802154_subif_start_xmit,
 	.ndo_do_ioctl		= mac802154_wpan_ioctl,
 	.ndo_set_mac_address	= mac802154_wpan_mac_addr,
 };

commit 50c6fb9965907732b4f5c45bd3bacf4b4f3463b9
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:01 2014 +0100

    mac802154: tx: move xmit callback to tx file
    
    This patch moves the netdev xmit callback functions into the tx.c file.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index cdd661f0ef3f..f14e4365c4c7 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -307,41 +307,6 @@ mac802154_header_parse(const struct sk_buff *skb, unsigned char *haddr)
 	return sizeof(*addr);
 }
 
-static netdev_tx_t
-mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata;
-	u8 chan, page;
-	int rc;
-
-	sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-
-	spin_lock_bh(&sdata->mib_lock);
-	chan = sdata->chan;
-	page = sdata->page;
-	spin_unlock_bh(&sdata->mib_lock);
-
-	if (chan == MAC802154_CHAN_NONE ||
-	    page >= WPAN_NUM_PAGES ||
-	    chan >= WPAN_NUM_CHANNELS) {
-		kfree_skb(skb);
-		return NETDEV_TX_OK;
-	}
-
-	rc = mac802154_llsec_encrypt(&sdata->sec, skb);
-	if (rc) {
-		pr_warn("encryption failed: %i\n", rc);
-		kfree_skb(skb);
-		return NETDEV_TX_OK;
-	}
-
-	skb->skb_iif = dev->ifindex;
-	dev->stats.tx_packets++;
-	dev->stats.tx_bytes += skb->len;
-
-	return mac802154_tx(sdata->local, skb, page, chan);
-}
-
 static struct header_ops mac802154_header_ops = {
 	.create		= mac802154_header_create,
 	.parse		= mac802154_header_parse,

commit 59d19cd70cd38afd2d9bf2e3b48c3a5bbb630b5a
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:40 2014 +0200

    mac802154: introduce IEEE802154_DEV_TO_SUB_IF
    
    This function adds a wrapper to call netdev_priv to getting the sdata
    attribute. This is similar like the IEEE80211_DEV_TO_SUB_IF function
    inside wireless stack implementation.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index c0dbb402b99b..cdd661f0ef3f 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -33,7 +33,7 @@
 
 static int mac802154_wpan_update_llsec(struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct ieee802154_mlme_ops *ops = ieee802154_mlme_ops(dev);
 	int rc = 0;
 
@@ -56,7 +56,7 @@ static int mac802154_wpan_update_llsec(struct net_device *dev)
 static int
 mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct sockaddr_ieee802154 *sa =
 		(struct sockaddr_ieee802154 *)&ifr->ifr_addr;
 	int err = -ENOIOCTLCMD;
@@ -123,7 +123,7 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 int mac802154_set_mac_params(struct net_device *dev,
 			     const struct ieee802154_mac_params *params)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	mutex_lock(&sdata->local->iflist_mtx);
 	sdata->mac_params = *params;
@@ -135,7 +135,7 @@ int mac802154_set_mac_params(struct net_device *dev,
 void mac802154_get_mac_params(struct net_device *dev,
 			      struct ieee802154_mac_params *params)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	mutex_lock(&sdata->local->iflist_mtx);
 	*params = sdata->mac_params;
@@ -145,7 +145,7 @@ void mac802154_get_mac_params(struct net_device *dev,
 static int mac802154_wpan_open(struct net_device *dev)
 {
 	int rc;
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct wpan_phy *phy = sdata->local->phy;
 
 	rc = mac802154_slave_open(dev);
@@ -241,7 +241,7 @@ static int mac802154_header_create(struct sk_buff *skb,
 				   unsigned len)
 {
 	struct ieee802154_hdr hdr;
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct ieee802154_mac_cb *cb = mac_cb(skb);
 	int hlen;
 
@@ -314,7 +314,7 @@ mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
 	u8 chan, page;
 	int rc;
 
-	sdata = netdev_priv(dev);
+	sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	spin_lock_bh(&sdata->mib_lock);
 	chan = sdata->chan;
@@ -357,7 +357,7 @@ static const struct net_device_ops mac802154_wpan_ops = {
 
 static void mac802154_wpan_free(struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	mac802154_llsec_destroy(&sdata->sec);
 
@@ -384,7 +384,7 @@ void mac802154_wpan_setup(struct net_device *dev)
 	dev->netdev_ops		= &mac802154_wpan_ops;
 	dev->ml_priv		= &mac802154_mlme_wpan;
 
-	sdata = netdev_priv(dev);
+	sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	sdata->type = IEEE802154_DEV_WPAN;
 
 	sdata->chan = MAC802154_CHAN_NONE;

commit d98be45b3657fc233f5a098279a4e42ab6f0fa4f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:38 2014 +0200

    mac802154: rename sdata slaves and slaves_mtx
    
    This patch renamens the slaves attribute in sdata to interfaces and
    slaves_mtx to iflist_mtx. This is similar like the mac80211 stack naming
    convention.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 6eace90da3ed..c0dbb402b99b 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -125,9 +125,9 @@ int mac802154_set_mac_params(struct net_device *dev,
 {
 	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
-	mutex_lock(&sdata->local->slaves_mtx);
+	mutex_lock(&sdata->local->iflist_mtx);
 	sdata->mac_params = *params;
-	mutex_unlock(&sdata->local->slaves_mtx);
+	mutex_unlock(&sdata->local->iflist_mtx);
 
 	return 0;
 }
@@ -137,9 +137,9 @@ void mac802154_get_mac_params(struct net_device *dev,
 {
 	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
-	mutex_lock(&sdata->local->slaves_mtx);
+	mutex_lock(&sdata->local->iflist_mtx);
 	*params = sdata->mac_params;
-	mutex_unlock(&sdata->local->slaves_mtx);
+	mutex_unlock(&sdata->local->iflist_mtx);
 }
 
 static int mac802154_wpan_open(struct net_device *dev)
@@ -580,7 +580,7 @@ void mac802154_wpans_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	}
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &local->slaves, list) {
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
 		if (sdata->type != IEEE802154_DEV_WPAN ||
 		    !netif_running(sdata->dev))
 			continue;

commit 04e850fe06312a9f570fcc7dbd0f141c012df404
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:37 2014 +0200

    mac802154: rename hw subif_data variable to local
    
    This patch renames the hw attribute in struct ieee802154_sub_if_data to
    local. This avoid confusing with the struct ieee802154_hw hw; inside of
    local struct.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index d3eb8a445a81..6eace90da3ed 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -125,9 +125,9 @@ int mac802154_set_mac_params(struct net_device *dev,
 {
 	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
-	mutex_lock(&sdata->hw->slaves_mtx);
+	mutex_lock(&sdata->local->slaves_mtx);
 	sdata->mac_params = *params;
-	mutex_unlock(&sdata->hw->slaves_mtx);
+	mutex_unlock(&sdata->local->slaves_mtx);
 
 	return 0;
 }
@@ -137,16 +137,16 @@ void mac802154_get_mac_params(struct net_device *dev,
 {
 	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
-	mutex_lock(&sdata->hw->slaves_mtx);
+	mutex_lock(&sdata->local->slaves_mtx);
 	*params = sdata->mac_params;
-	mutex_unlock(&sdata->hw->slaves_mtx);
+	mutex_unlock(&sdata->local->slaves_mtx);
 }
 
 static int mac802154_wpan_open(struct net_device *dev)
 {
 	int rc;
 	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
-	struct wpan_phy *phy = sdata->hw->phy;
+	struct wpan_phy *phy = sdata->local->phy;
 
 	rc = mac802154_slave_open(dev);
 	if (rc < 0)
@@ -339,7 +339,7 @@ mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
 	dev->stats.tx_packets++;
 	dev->stats.tx_bytes += skb->len;
 
-	return mac802154_tx(sdata->hw, skb, page, chan);
+	return mac802154_tx(sdata->local, skb, page, chan);
 }
 
 static struct header_ops mac802154_header_ops = {

commit 036562f9c4d942f2fbc77ae3215309bde340546f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:36 2014 +0200

    mac802154: rename mac802154_sub_if_data
    
    Like wireless this structure should named ieee802154_sub_if_data and not
    mac802154_sub_if_data. This patch renames the struct and variables to
    sdata instead priv sometimes.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 10f1ee27a616..d3eb8a445a81 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -33,7 +33,7 @@
 
 static int mac802154_wpan_update_llsec(struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	struct ieee802154_mlme_ops *ops = ieee802154_mlme_ops(dev);
 	int rc = 0;
 
@@ -41,10 +41,10 @@ static int mac802154_wpan_update_llsec(struct net_device *dev)
 		struct ieee802154_llsec_params params;
 		int changed = 0;
 
-		params.pan_id = priv->pan_id;
+		params.pan_id = sdata->pan_id;
 		changed |= IEEE802154_LLSEC_PARAM_PAN_ID;
 
-		params.hwaddr = priv->extended_addr;
+		params.hwaddr = sdata->extended_addr;
 		changed |= IEEE802154_LLSEC_PARAM_HWADDR;
 
 		rc = ops->llsec->set_params(dev, &params, changed);
@@ -56,20 +56,20 @@ static int mac802154_wpan_update_llsec(struct net_device *dev)
 static int
 mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	struct sockaddr_ieee802154 *sa =
 		(struct sockaddr_ieee802154 *)&ifr->ifr_addr;
 	int err = -ENOIOCTLCMD;
 
-	spin_lock_bh(&priv->mib_lock);
+	spin_lock_bh(&sdata->mib_lock);
 
 	switch (cmd) {
 	case SIOCGIFADDR:
 	{
 		u16 pan_id, short_addr;
 
-		pan_id = le16_to_cpu(priv->pan_id);
-		short_addr = le16_to_cpu(priv->short_addr);
+		pan_id = le16_to_cpu(sdata->pan_id);
+		short_addr = le16_to_cpu(sdata->short_addr);
 		if (pan_id == IEEE802154_PANID_BROADCAST ||
 		    short_addr == IEEE802154_ADDR_BROADCAST) {
 			err = -EADDRNOTAVAIL;
@@ -96,14 +96,14 @@ mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 			break;
 		}
 
-		priv->pan_id = cpu_to_le16(sa->addr.pan_id);
-		priv->short_addr = cpu_to_le16(sa->addr.short_addr);
+		sdata->pan_id = cpu_to_le16(sa->addr.pan_id);
+		sdata->short_addr = cpu_to_le16(sa->addr.short_addr);
 
 		err = mac802154_wpan_update_llsec(dev);
 		break;
 	}
 
-	spin_unlock_bh(&priv->mib_lock);
+	spin_unlock_bh(&sdata->mib_lock);
 	return err;
 }
 
@@ -123,11 +123,11 @@ static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
 int mac802154_set_mac_params(struct net_device *dev,
 			     const struct ieee802154_mac_params *params)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
-	mutex_lock(&priv->hw->slaves_mtx);
-	priv->mac_params = *params;
-	mutex_unlock(&priv->hw->slaves_mtx);
+	mutex_lock(&sdata->hw->slaves_mtx);
+	sdata->mac_params = *params;
+	mutex_unlock(&sdata->hw->slaves_mtx);
 
 	return 0;
 }
@@ -135,18 +135,18 @@ int mac802154_set_mac_params(struct net_device *dev,
 void mac802154_get_mac_params(struct net_device *dev,
 			      struct ieee802154_mac_params *params)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
-	mutex_lock(&priv->hw->slaves_mtx);
-	*params = priv->mac_params;
-	mutex_unlock(&priv->hw->slaves_mtx);
+	mutex_lock(&sdata->hw->slaves_mtx);
+	*params = sdata->mac_params;
+	mutex_unlock(&sdata->hw->slaves_mtx);
 }
 
 static int mac802154_wpan_open(struct net_device *dev)
 {
 	int rc;
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
-	struct wpan_phy *phy = priv->hw->phy;
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct wpan_phy *phy = sdata->hw->phy;
 
 	rc = mac802154_slave_open(dev);
 	if (rc < 0)
@@ -155,40 +155,40 @@ static int mac802154_wpan_open(struct net_device *dev)
 	mutex_lock(&phy->pib_lock);
 
 	if (phy->set_txpower) {
-		rc = phy->set_txpower(phy, priv->mac_params.transmit_power);
+		rc = phy->set_txpower(phy, sdata->mac_params.transmit_power);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (phy->set_lbt) {
-		rc = phy->set_lbt(phy, priv->mac_params.lbt);
+		rc = phy->set_lbt(phy, sdata->mac_params.lbt);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (phy->set_cca_mode) {
-		rc = phy->set_cca_mode(phy, priv->mac_params.cca_mode);
+		rc = phy->set_cca_mode(phy, sdata->mac_params.cca_mode);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (phy->set_cca_ed_level) {
-		rc = phy->set_cca_ed_level(phy, priv->mac_params.cca_ed_level);
+		rc = phy->set_cca_ed_level(phy, sdata->mac_params.cca_ed_level);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (phy->set_csma_params) {
-		rc = phy->set_csma_params(phy, priv->mac_params.min_be,
-					  priv->mac_params.max_be,
-					  priv->mac_params.csma_retries);
+		rc = phy->set_csma_params(phy, sdata->mac_params.min_be,
+					  sdata->mac_params.max_be,
+					  sdata->mac_params.csma_retries);
 		if (rc < 0)
 			goto out;
 	}
 
 	if (phy->set_frame_retries) {
 		rc = phy->set_frame_retries(phy,
-					    priv->mac_params.frame_retries);
+					    sdata->mac_params.frame_retries);
 		if (rc < 0)
 			goto out;
 	}
@@ -201,14 +201,14 @@ static int mac802154_wpan_open(struct net_device *dev)
 	return rc;
 }
 
-static int mac802154_set_header_security(struct mac802154_sub_if_data *priv,
+static int mac802154_set_header_security(struct ieee802154_sub_if_data *sdata,
 					 struct ieee802154_hdr *hdr,
 					 const struct ieee802154_mac_cb *cb)
 {
 	struct ieee802154_llsec_params params;
 	u8 level;
 
-	mac802154_llsec_get_params(&priv->sec, &params);
+	mac802154_llsec_get_params(&sdata->sec, &params);
 
 	if (!params.enabled && cb->secen_override && cb->secen)
 		return -EINVAL;
@@ -241,7 +241,7 @@ static int mac802154_header_create(struct sk_buff *skb,
 				   unsigned len)
 {
 	struct ieee802154_hdr hdr;
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	struct ieee802154_mac_cb *cb = mac_cb(skb);
 	int hlen;
 
@@ -254,25 +254,25 @@ static int mac802154_header_create(struct sk_buff *skb,
 	hdr.fc.ack_request = cb->ackreq;
 	hdr.seq = ieee802154_mlme_ops(dev)->get_dsn(dev);
 
-	if (mac802154_set_header_security(priv, &hdr, cb) < 0)
+	if (mac802154_set_header_security(sdata, &hdr, cb) < 0)
 		return -EINVAL;
 
 	if (!saddr) {
-		spin_lock_bh(&priv->mib_lock);
+		spin_lock_bh(&sdata->mib_lock);
 
-		if (priv->short_addr == cpu_to_le16(IEEE802154_ADDR_BROADCAST) ||
-		    priv->short_addr == cpu_to_le16(IEEE802154_ADDR_UNDEF) ||
-		    priv->pan_id == cpu_to_le16(IEEE802154_PANID_BROADCAST)) {
+		if (sdata->short_addr == cpu_to_le16(IEEE802154_ADDR_BROADCAST) ||
+		    sdata->short_addr == cpu_to_le16(IEEE802154_ADDR_UNDEF) ||
+		    sdata->pan_id == cpu_to_le16(IEEE802154_PANID_BROADCAST)) {
 			hdr.source.mode = IEEE802154_ADDR_LONG;
-			hdr.source.extended_addr = priv->extended_addr;
+			hdr.source.extended_addr = sdata->extended_addr;
 		} else {
 			hdr.source.mode = IEEE802154_ADDR_SHORT;
-			hdr.source.short_addr = priv->short_addr;
+			hdr.source.short_addr = sdata->short_addr;
 		}
 
-		hdr.source.pan_id = priv->pan_id;
+		hdr.source.pan_id = sdata->pan_id;
 
-		spin_unlock_bh(&priv->mib_lock);
+		spin_unlock_bh(&sdata->mib_lock);
 	} else {
 		hdr.source = *(const struct ieee802154_addr *)saddr;
 	}
@@ -310,16 +310,16 @@ mac802154_header_parse(const struct sk_buff *skb, unsigned char *haddr)
 static netdev_tx_t
 mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv;
+	struct ieee802154_sub_if_data *sdata;
 	u8 chan, page;
 	int rc;
 
-	priv = netdev_priv(dev);
+	sdata = netdev_priv(dev);
 
-	spin_lock_bh(&priv->mib_lock);
-	chan = priv->chan;
-	page = priv->page;
-	spin_unlock_bh(&priv->mib_lock);
+	spin_lock_bh(&sdata->mib_lock);
+	chan = sdata->chan;
+	page = sdata->page;
+	spin_unlock_bh(&sdata->mib_lock);
 
 	if (chan == MAC802154_CHAN_NONE ||
 	    page >= WPAN_NUM_PAGES ||
@@ -328,7 +328,7 @@ mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
 		return NETDEV_TX_OK;
 	}
 
-	rc = mac802154_llsec_encrypt(&priv->sec, skb);
+	rc = mac802154_llsec_encrypt(&sdata->sec, skb);
 	if (rc) {
 		pr_warn("encryption failed: %i\n", rc);
 		kfree_skb(skb);
@@ -339,7 +339,7 @@ mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
 	dev->stats.tx_packets++;
 	dev->stats.tx_bytes += skb->len;
 
-	return mac802154_tx(priv->hw, skb, page, chan);
+	return mac802154_tx(sdata->hw, skb, page, chan);
 }
 
 static struct header_ops mac802154_header_ops = {
@@ -357,16 +357,16 @@ static const struct net_device_ops mac802154_wpan_ops = {
 
 static void mac802154_wpan_free(struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
-	mac802154_llsec_destroy(&priv->sec);
+	mac802154_llsec_destroy(&sdata->sec);
 
 	free_netdev(dev);
 }
 
 void mac802154_wpan_setup(struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv;
+	struct ieee802154_sub_if_data *sdata;
 
 	dev->addr_len		= IEEE802154_ADDR_LEN;
 	memset(dev->broadcast, 0xff, IEEE802154_ADDR_LEN);
@@ -384,28 +384,29 @@ void mac802154_wpan_setup(struct net_device *dev)
 	dev->netdev_ops		= &mac802154_wpan_ops;
 	dev->ml_priv		= &mac802154_mlme_wpan;
 
-	priv = netdev_priv(dev);
-	priv->type = IEEE802154_DEV_WPAN;
+	sdata = netdev_priv(dev);
+	sdata->type = IEEE802154_DEV_WPAN;
 
-	priv->chan = MAC802154_CHAN_NONE;
-	priv->page = 0;
+	sdata->chan = MAC802154_CHAN_NONE;
+	sdata->page = 0;
 
-	spin_lock_init(&priv->mib_lock);
-	mutex_init(&priv->sec_mtx);
+	spin_lock_init(&sdata->mib_lock);
+	mutex_init(&sdata->sec_mtx);
 
-	get_random_bytes(&priv->bsn, 1);
-	get_random_bytes(&priv->dsn, 1);
+	get_random_bytes(&sdata->bsn, 1);
+	get_random_bytes(&sdata->dsn, 1);
 
 	/* defaults per 802.15.4-2011 */
-	priv->mac_params.min_be = 3;
-	priv->mac_params.max_be = 5;
-	priv->mac_params.csma_retries = 4;
-	priv->mac_params.frame_retries = -1; /* for compatibility, actual default is 3 */
+	sdata->mac_params.min_be = 3;
+	sdata->mac_params.max_be = 5;
+	sdata->mac_params.csma_retries = 4;
+	/* for compatibility, actual default is 3 */
+	sdata->mac_params.frame_retries = -1;
 
-	priv->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);
-	priv->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);
+	sdata->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);
+	sdata->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);
 
-	mac802154_llsec_init(&priv->sec);
+	mac802154_llsec_init(&sdata->sec);
 }
 
 static int mac802154_process_data(struct net_device *dev, struct sk_buff *skb)
@@ -414,7 +415,7 @@ static int mac802154_process_data(struct net_device *dev, struct sk_buff *skb)
 }
 
 static int
-mac802154_subif_frame(struct mac802154_sub_if_data *sdata, struct sk_buff *skb,
+mac802154_subif_frame(struct ieee802154_sub_if_data *sdata, struct sk_buff *skb,
 		      const struct ieee802154_hdr *hdr)
 {
 	__le16 span, sshort;
@@ -568,7 +569,7 @@ static int mac802154_parse_frame_start(struct sk_buff *skb,
 void mac802154_wpans_rx(struct ieee802154_local *local, struct sk_buff *skb)
 {
 	int ret;
-	struct mac802154_sub_if_data *sdata;
+	struct ieee802154_sub_if_data *sdata;
 	struct ieee802154_hdr hdr;
 
 	ret = mac802154_parse_frame_start(skb, &hdr);

commit a5e1ec538f54c4cb8ec9ce30867cfbab57225280
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:35 2014 +0200

    mac802154: rename mac802154_priv to ieee802154_local
    
    This patch rename the mac802154_priv to ieee802154_local. The
    mac802154_priv structure is like ieee80211_local and so we name it
    ieee802154_local.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 03eedc3b23ef..10f1ee27a616 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -565,7 +565,7 @@ static int mac802154_parse_frame_start(struct sk_buff *skb,
 	return 0;
 }
 
-void mac802154_wpans_rx(struct mac802154_priv *priv, struct sk_buff *skb)
+void mac802154_wpans_rx(struct ieee802154_local *local, struct sk_buff *skb)
 {
 	int ret;
 	struct mac802154_sub_if_data *sdata;
@@ -579,7 +579,7 @@ void mac802154_wpans_rx(struct mac802154_priv *priv, struct sk_buff *skb)
 	}
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &priv->slaves, list) {
+	list_for_each_entry_rcu(sdata, &local->slaves, list) {
 		if (sdata->type != IEEE802154_DEV_WPAN ||
 		    !netif_running(sdata->dev))
 			continue;

commit 4ca24aca55fe1e2a61f3ffaac9015d9c45204729
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:41:04 2014 +0200

    ieee802154: move ieee802154 header
    
    This patch moves the ieee802154 header into include/linux instead
    include/net. Similar like wireless which have the ieee80211 header
    inside of include/linux.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 5a604074555b..03eedc3b23ef 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -20,13 +20,13 @@
 #include <linux/netdevice.h>
 #include <linux/module.h>
 #include <linux/if_arp.h>
+#include <linux/ieee802154.h>
 
 #include <net/rtnetlink.h>
 #include <linux/nl802154.h>
 #include <net/af_ieee802154.h>
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
-#include <net/ieee802154.h>
 #include <net/cfg802154.h>
 
 #include "ieee802154_i.h"

commit 5ad60d36993596f7b3b958500f9c66c5338cd855
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:41:02 2014 +0200

    ieee802154: move wpan-phy.h to cfg802154.h
    
    The wpan-phy header contains the wpan_phy struct information. Later this
    header will be have similar function like cfg80211 header. The cfg80211
    header contains the wiphy struct which is identically the wpan_phy
    struct inside 802.15.4 subsystem.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
index 5adcbd87a4f5..5a604074555b 100644
--- a/net/mac802154/iface.c
+++ b/net/mac802154/iface.c
@@ -27,7 +27,7 @@
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
 #include <net/ieee802154.h>
-#include <net/wpan-phy.h>
+#include <net/cfg802154.h>
 
 #include "ieee802154_i.h"
 

commit 15859a5e141c4914c7c4d9dc9b2d54fa948fbd42
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:41:01 2014 +0200

    mac802154: move wpan.c to iface.c
    
    The wpan.c file contains the interface handling functions now. It's similar
    like the mac80211 iface.c file. This patch renames this file to iface.c to
    have similar naming convention in mac802154.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/iface.c b/net/mac802154/iface.c
new file mode 100644
index 000000000000..5adcbd87a4f5
--- /dev/null
+++ b/net/mac802154/iface.c
@@ -0,0 +1,595 @@
+/*
+ * Copyright 2007-2012 Siemens AG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * Written by:
+ * Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
+ * Sergey Lapin <slapin@ossfans.org>
+ * Maxim Gorbachyov <maxim.gorbachev@siemens.com>
+ * Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
+ */
+
+#include <linux/netdevice.h>
+#include <linux/module.h>
+#include <linux/if_arp.h>
+
+#include <net/rtnetlink.h>
+#include <linux/nl802154.h>
+#include <net/af_ieee802154.h>
+#include <net/mac802154.h>
+#include <net/ieee802154_netdev.h>
+#include <net/ieee802154.h>
+#include <net/wpan-phy.h>
+
+#include "ieee802154_i.h"
+
+static int mac802154_wpan_update_llsec(struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_mlme_ops *ops = ieee802154_mlme_ops(dev);
+	int rc = 0;
+
+	if (ops->llsec) {
+		struct ieee802154_llsec_params params;
+		int changed = 0;
+
+		params.pan_id = priv->pan_id;
+		changed |= IEEE802154_LLSEC_PARAM_PAN_ID;
+
+		params.hwaddr = priv->extended_addr;
+		changed |= IEEE802154_LLSEC_PARAM_HWADDR;
+
+		rc = ops->llsec->set_params(dev, &params, changed);
+	}
+
+	return rc;
+}
+
+static int
+mac802154_wpan_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct sockaddr_ieee802154 *sa =
+		(struct sockaddr_ieee802154 *)&ifr->ifr_addr;
+	int err = -ENOIOCTLCMD;
+
+	spin_lock_bh(&priv->mib_lock);
+
+	switch (cmd) {
+	case SIOCGIFADDR:
+	{
+		u16 pan_id, short_addr;
+
+		pan_id = le16_to_cpu(priv->pan_id);
+		short_addr = le16_to_cpu(priv->short_addr);
+		if (pan_id == IEEE802154_PANID_BROADCAST ||
+		    short_addr == IEEE802154_ADDR_BROADCAST) {
+			err = -EADDRNOTAVAIL;
+			break;
+		}
+
+		sa->family = AF_IEEE802154;
+		sa->addr.addr_type = IEEE802154_ADDR_SHORT;
+		sa->addr.pan_id = pan_id;
+		sa->addr.short_addr = short_addr;
+
+		err = 0;
+		break;
+	}
+	case SIOCSIFADDR:
+		dev_warn(&dev->dev,
+			 "Using DEBUGing ioctl SIOCSIFADDR isn't recommended!\n");
+		if (sa->family != AF_IEEE802154 ||
+		    sa->addr.addr_type != IEEE802154_ADDR_SHORT ||
+		    sa->addr.pan_id == IEEE802154_PANID_BROADCAST ||
+		    sa->addr.short_addr == IEEE802154_ADDR_BROADCAST ||
+		    sa->addr.short_addr == IEEE802154_ADDR_UNDEF) {
+			err = -EINVAL;
+			break;
+		}
+
+		priv->pan_id = cpu_to_le16(sa->addr.pan_id);
+		priv->short_addr = cpu_to_le16(sa->addr.short_addr);
+
+		err = mac802154_wpan_update_llsec(dev);
+		break;
+	}
+
+	spin_unlock_bh(&priv->mib_lock);
+	return err;
+}
+
+static int mac802154_wpan_mac_addr(struct net_device *dev, void *p)
+{
+	struct sockaddr *addr = p;
+
+	if (netif_running(dev))
+		return -EBUSY;
+
+	/* FIXME: validate addr */
+	memcpy(dev->dev_addr, addr->sa_data, dev->addr_len);
+	mac802154_dev_set_ieee_addr(dev);
+	return mac802154_wpan_update_llsec(dev);
+}
+
+int mac802154_set_mac_params(struct net_device *dev,
+			     const struct ieee802154_mac_params *params)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+
+	mutex_lock(&priv->hw->slaves_mtx);
+	priv->mac_params = *params;
+	mutex_unlock(&priv->hw->slaves_mtx);
+
+	return 0;
+}
+
+void mac802154_get_mac_params(struct net_device *dev,
+			      struct ieee802154_mac_params *params)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+
+	mutex_lock(&priv->hw->slaves_mtx);
+	*params = priv->mac_params;
+	mutex_unlock(&priv->hw->slaves_mtx);
+}
+
+static int mac802154_wpan_open(struct net_device *dev)
+{
+	int rc;
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct wpan_phy *phy = priv->hw->phy;
+
+	rc = mac802154_slave_open(dev);
+	if (rc < 0)
+		return rc;
+
+	mutex_lock(&phy->pib_lock);
+
+	if (phy->set_txpower) {
+		rc = phy->set_txpower(phy, priv->mac_params.transmit_power);
+		if (rc < 0)
+			goto out;
+	}
+
+	if (phy->set_lbt) {
+		rc = phy->set_lbt(phy, priv->mac_params.lbt);
+		if (rc < 0)
+			goto out;
+	}
+
+	if (phy->set_cca_mode) {
+		rc = phy->set_cca_mode(phy, priv->mac_params.cca_mode);
+		if (rc < 0)
+			goto out;
+	}
+
+	if (phy->set_cca_ed_level) {
+		rc = phy->set_cca_ed_level(phy, priv->mac_params.cca_ed_level);
+		if (rc < 0)
+			goto out;
+	}
+
+	if (phy->set_csma_params) {
+		rc = phy->set_csma_params(phy, priv->mac_params.min_be,
+					  priv->mac_params.max_be,
+					  priv->mac_params.csma_retries);
+		if (rc < 0)
+			goto out;
+	}
+
+	if (phy->set_frame_retries) {
+		rc = phy->set_frame_retries(phy,
+					    priv->mac_params.frame_retries);
+		if (rc < 0)
+			goto out;
+	}
+
+	mutex_unlock(&phy->pib_lock);
+	return 0;
+
+out:
+	mutex_unlock(&phy->pib_lock);
+	return rc;
+}
+
+static int mac802154_set_header_security(struct mac802154_sub_if_data *priv,
+					 struct ieee802154_hdr *hdr,
+					 const struct ieee802154_mac_cb *cb)
+{
+	struct ieee802154_llsec_params params;
+	u8 level;
+
+	mac802154_llsec_get_params(&priv->sec, &params);
+
+	if (!params.enabled && cb->secen_override && cb->secen)
+		return -EINVAL;
+	if (!params.enabled ||
+	    (cb->secen_override && !cb->secen) ||
+	    !params.out_level)
+		return 0;
+	if (cb->seclevel_override && !cb->seclevel)
+		return -EINVAL;
+
+	level = cb->seclevel_override ? cb->seclevel : params.out_level;
+
+	hdr->fc.security_enabled = 1;
+	hdr->sec.level = level;
+	hdr->sec.key_id_mode = params.out_key.mode;
+	if (params.out_key.mode == IEEE802154_SCF_KEY_SHORT_INDEX)
+		hdr->sec.short_src = params.out_key.short_source;
+	else if (params.out_key.mode == IEEE802154_SCF_KEY_HW_INDEX)
+		hdr->sec.extended_src = params.out_key.extended_source;
+	hdr->sec.key_id = params.out_key.id;
+
+	return 0;
+}
+
+static int mac802154_header_create(struct sk_buff *skb,
+				   struct net_device *dev,
+				   unsigned short type,
+				   const void *daddr,
+				   const void *saddr,
+				   unsigned len)
+{
+	struct ieee802154_hdr hdr;
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_mac_cb *cb = mac_cb(skb);
+	int hlen;
+
+	if (!daddr)
+		return -EINVAL;
+
+	memset(&hdr.fc, 0, sizeof(hdr.fc));
+	hdr.fc.type = cb->type;
+	hdr.fc.security_enabled = cb->secen;
+	hdr.fc.ack_request = cb->ackreq;
+	hdr.seq = ieee802154_mlme_ops(dev)->get_dsn(dev);
+
+	if (mac802154_set_header_security(priv, &hdr, cb) < 0)
+		return -EINVAL;
+
+	if (!saddr) {
+		spin_lock_bh(&priv->mib_lock);
+
+		if (priv->short_addr == cpu_to_le16(IEEE802154_ADDR_BROADCAST) ||
+		    priv->short_addr == cpu_to_le16(IEEE802154_ADDR_UNDEF) ||
+		    priv->pan_id == cpu_to_le16(IEEE802154_PANID_BROADCAST)) {
+			hdr.source.mode = IEEE802154_ADDR_LONG;
+			hdr.source.extended_addr = priv->extended_addr;
+		} else {
+			hdr.source.mode = IEEE802154_ADDR_SHORT;
+			hdr.source.short_addr = priv->short_addr;
+		}
+
+		hdr.source.pan_id = priv->pan_id;
+
+		spin_unlock_bh(&priv->mib_lock);
+	} else {
+		hdr.source = *(const struct ieee802154_addr *)saddr;
+	}
+
+	hdr.dest = *(const struct ieee802154_addr *)daddr;
+
+	hlen = ieee802154_hdr_push(skb, &hdr);
+	if (hlen < 0)
+		return -EINVAL;
+
+	skb_reset_mac_header(skb);
+	skb->mac_len = hlen;
+
+	if (len > ieee802154_max_payload(&hdr))
+		return -EMSGSIZE;
+
+	return hlen;
+}
+
+static int
+mac802154_header_parse(const struct sk_buff *skb, unsigned char *haddr)
+{
+	struct ieee802154_hdr hdr;
+	struct ieee802154_addr *addr = (struct ieee802154_addr *)haddr;
+
+	if (ieee802154_hdr_peek_addrs(skb, &hdr) < 0) {
+		pr_debug("malformed packet\n");
+		return 0;
+	}
+
+	*addr = hdr.source;
+	return sizeof(*addr);
+}
+
+static netdev_tx_t
+mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv;
+	u8 chan, page;
+	int rc;
+
+	priv = netdev_priv(dev);
+
+	spin_lock_bh(&priv->mib_lock);
+	chan = priv->chan;
+	page = priv->page;
+	spin_unlock_bh(&priv->mib_lock);
+
+	if (chan == MAC802154_CHAN_NONE ||
+	    page >= WPAN_NUM_PAGES ||
+	    chan >= WPAN_NUM_CHANNELS) {
+		kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	rc = mac802154_llsec_encrypt(&priv->sec, skb);
+	if (rc) {
+		pr_warn("encryption failed: %i\n", rc);
+		kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	skb->skb_iif = dev->ifindex;
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+
+	return mac802154_tx(priv->hw, skb, page, chan);
+}
+
+static struct header_ops mac802154_header_ops = {
+	.create		= mac802154_header_create,
+	.parse		= mac802154_header_parse,
+};
+
+static const struct net_device_ops mac802154_wpan_ops = {
+	.ndo_open		= mac802154_wpan_open,
+	.ndo_stop		= mac802154_slave_close,
+	.ndo_start_xmit		= mac802154_wpan_xmit,
+	.ndo_do_ioctl		= mac802154_wpan_ioctl,
+	.ndo_set_mac_address	= mac802154_wpan_mac_addr,
+};
+
+static void mac802154_wpan_free(struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+
+	mac802154_llsec_destroy(&priv->sec);
+
+	free_netdev(dev);
+}
+
+void mac802154_wpan_setup(struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv;
+
+	dev->addr_len		= IEEE802154_ADDR_LEN;
+	memset(dev->broadcast, 0xff, IEEE802154_ADDR_LEN);
+
+	dev->hard_header_len	= MAC802154_FRAME_HARD_HEADER_LEN;
+	dev->header_ops		= &mac802154_header_ops;
+	dev->needed_tailroom	= 2 + 16; /* FCS + MIC */
+	dev->mtu		= IEEE802154_MTU;
+	dev->tx_queue_len	= 300;
+	dev->type		= ARPHRD_IEEE802154;
+	dev->flags		= IFF_NOARP | IFF_BROADCAST;
+	dev->watchdog_timeo	= 0;
+
+	dev->destructor		= mac802154_wpan_free;
+	dev->netdev_ops		= &mac802154_wpan_ops;
+	dev->ml_priv		= &mac802154_mlme_wpan;
+
+	priv = netdev_priv(dev);
+	priv->type = IEEE802154_DEV_WPAN;
+
+	priv->chan = MAC802154_CHAN_NONE;
+	priv->page = 0;
+
+	spin_lock_init(&priv->mib_lock);
+	mutex_init(&priv->sec_mtx);
+
+	get_random_bytes(&priv->bsn, 1);
+	get_random_bytes(&priv->dsn, 1);
+
+	/* defaults per 802.15.4-2011 */
+	priv->mac_params.min_be = 3;
+	priv->mac_params.max_be = 5;
+	priv->mac_params.csma_retries = 4;
+	priv->mac_params.frame_retries = -1; /* for compatibility, actual default is 3 */
+
+	priv->pan_id = cpu_to_le16(IEEE802154_PANID_BROADCAST);
+	priv->short_addr = cpu_to_le16(IEEE802154_ADDR_BROADCAST);
+
+	mac802154_llsec_init(&priv->sec);
+}
+
+static int mac802154_process_data(struct net_device *dev, struct sk_buff *skb)
+{
+	return netif_rx_ni(skb);
+}
+
+static int
+mac802154_subif_frame(struct mac802154_sub_if_data *sdata, struct sk_buff *skb,
+		      const struct ieee802154_hdr *hdr)
+{
+	__le16 span, sshort;
+	int rc;
+
+	pr_debug("getting packet via slave interface %s\n", sdata->dev->name);
+
+	spin_lock_bh(&sdata->mib_lock);
+
+	span = sdata->pan_id;
+	sshort = sdata->short_addr;
+
+	switch (mac_cb(skb)->dest.mode) {
+	case IEEE802154_ADDR_NONE:
+		if (mac_cb(skb)->dest.mode != IEEE802154_ADDR_NONE)
+			/* FIXME: check if we are PAN coordinator */
+			skb->pkt_type = PACKET_OTHERHOST;
+		else
+			/* ACK comes with both addresses empty */
+			skb->pkt_type = PACKET_HOST;
+		break;
+	case IEEE802154_ADDR_LONG:
+		if (mac_cb(skb)->dest.pan_id != span &&
+		    mac_cb(skb)->dest.pan_id != cpu_to_le16(IEEE802154_PANID_BROADCAST))
+			skb->pkt_type = PACKET_OTHERHOST;
+		else if (mac_cb(skb)->dest.extended_addr == sdata->extended_addr)
+			skb->pkt_type = PACKET_HOST;
+		else
+			skb->pkt_type = PACKET_OTHERHOST;
+		break;
+	case IEEE802154_ADDR_SHORT:
+		if (mac_cb(skb)->dest.pan_id != span &&
+		    mac_cb(skb)->dest.pan_id != cpu_to_le16(IEEE802154_PANID_BROADCAST))
+			skb->pkt_type = PACKET_OTHERHOST;
+		else if (mac_cb(skb)->dest.short_addr == sshort)
+			skb->pkt_type = PACKET_HOST;
+		else if (mac_cb(skb)->dest.short_addr ==
+			  cpu_to_le16(IEEE802154_ADDR_BROADCAST))
+			skb->pkt_type = PACKET_BROADCAST;
+		else
+			skb->pkt_type = PACKET_OTHERHOST;
+		break;
+	default:
+		spin_unlock_bh(&sdata->mib_lock);
+		pr_debug("invalid dest mode\n");
+		kfree_skb(skb);
+		return NET_RX_DROP;
+	}
+
+	spin_unlock_bh(&sdata->mib_lock);
+
+	skb->dev = sdata->dev;
+
+	rc = mac802154_llsec_decrypt(&sdata->sec, skb);
+	if (rc) {
+		pr_debug("decryption failed: %i\n", rc);
+		goto fail;
+	}
+
+	sdata->dev->stats.rx_packets++;
+	sdata->dev->stats.rx_bytes += skb->len;
+
+	switch (mac_cb(skb)->type) {
+	case IEEE802154_FC_TYPE_DATA:
+		return mac802154_process_data(sdata->dev, skb);
+	default:
+		pr_warn("ieee802154: bad frame received (type = %d)\n",
+			mac_cb(skb)->type);
+		goto fail;
+	}
+
+fail:
+	kfree_skb(skb);
+	return NET_RX_DROP;
+}
+
+static void mac802154_print_addr(const char *name,
+				 const struct ieee802154_addr *addr)
+{
+	if (addr->mode == IEEE802154_ADDR_NONE)
+		pr_debug("%s not present\n", name);
+
+	pr_debug("%s PAN ID: %04x\n", name, le16_to_cpu(addr->pan_id));
+	if (addr->mode == IEEE802154_ADDR_SHORT) {
+		pr_debug("%s is short: %04x\n", name,
+			 le16_to_cpu(addr->short_addr));
+	} else {
+		u64 hw = swab64((__force u64) addr->extended_addr);
+
+		pr_debug("%s is hardware: %8phC\n", name, &hw);
+	}
+}
+
+static int mac802154_parse_frame_start(struct sk_buff *skb,
+				       struct ieee802154_hdr *hdr)
+{
+	int hlen;
+	struct ieee802154_mac_cb *cb = mac_cb_init(skb);
+
+	hlen = ieee802154_hdr_pull(skb, hdr);
+	if (hlen < 0)
+		return -EINVAL;
+
+	skb->mac_len = hlen;
+
+	pr_debug("fc: %04x dsn: %02x\n", le16_to_cpup((__le16 *)&hdr->fc),
+		 hdr->seq);
+
+	cb->type = hdr->fc.type;
+	cb->ackreq = hdr->fc.ack_request;
+	cb->secen = hdr->fc.security_enabled;
+
+	mac802154_print_addr("destination", &hdr->dest);
+	mac802154_print_addr("source", &hdr->source);
+
+	cb->source = hdr->source;
+	cb->dest = hdr->dest;
+
+	if (hdr->fc.security_enabled) {
+		u64 key;
+
+		pr_debug("seclevel %i\n", hdr->sec.level);
+
+		switch (hdr->sec.key_id_mode) {
+		case IEEE802154_SCF_KEY_IMPLICIT:
+			pr_debug("implicit key\n");
+			break;
+
+		case IEEE802154_SCF_KEY_INDEX:
+			pr_debug("key %02x\n", hdr->sec.key_id);
+			break;
+
+		case IEEE802154_SCF_KEY_SHORT_INDEX:
+			pr_debug("key %04x:%04x %02x\n",
+				 le32_to_cpu(hdr->sec.short_src) >> 16,
+				 le32_to_cpu(hdr->sec.short_src) & 0xffff,
+				 hdr->sec.key_id);
+			break;
+
+		case IEEE802154_SCF_KEY_HW_INDEX:
+			key = swab64((__force u64) hdr->sec.extended_src);
+			pr_debug("key source %8phC %02x\n", &key,
+				 hdr->sec.key_id);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+void mac802154_wpans_rx(struct mac802154_priv *priv, struct sk_buff *skb)
+{
+	int ret;
+	struct mac802154_sub_if_data *sdata;
+	struct ieee802154_hdr hdr;
+
+	ret = mac802154_parse_frame_start(skb, &hdr);
+	if (ret) {
+		pr_debug("got invalid frame\n");
+		kfree_skb(skb);
+		return;
+	}
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(sdata, &priv->slaves, list) {
+		if (sdata->type != IEEE802154_DEV_WPAN ||
+		    !netif_running(sdata->dev))
+			continue;
+
+		mac802154_subif_frame(sdata, skb, &hdr);
+		skb = NULL;
+		break;
+	}
+	rcu_read_unlock();
+
+	if (skb)
+		kfree_skb(skb);
+}
