commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index bcd1a5e6ebf4..ab52811523e9 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -1,15 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright 2007-2012 Siemens AG
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * Written by:
  * Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
  * Sergey Lapin <slapin@ossfans.org>

commit f9c52831133050c6b82aa8b6831c92da2bbf2a0b
Author: Alexander Aring <aring@mojatatu.com>
Date:   Mon Jul 2 16:32:03 2018 -0400

    net: mac802154: tx: expand tailroom if necessary
    
    This patch is necessary if case of AF_PACKET or other socket interface
    which I am aware of it and didn't allocated the necessary room.
    
    Reported-by: David Palma <david.palma@ntnu.no>
    Reported-by: Rabi Narayan Sahoo <rabinarayans0828@gmail.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: Alexander Aring <aring@mojatatu.com>
    Signed-off-by: Stefan Schmidt <stefan@datenfreihafen.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 7e253455f9dd..bcd1a5e6ebf4 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -63,8 +63,21 @@ ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 	int ret;
 
 	if (!(local->hw.flags & IEEE802154_HW_TX_OMIT_CKSUM)) {
-		u16 crc = crc_ccitt(0, skb->data, skb->len);
+		struct sk_buff *nskb;
+		u16 crc;
+
+		if (unlikely(skb_tailroom(skb) < IEEE802154_FCS_LEN)) {
+			nskb = skb_copy_expand(skb, 0, IEEE802154_FCS_LEN,
+					       GFP_ATOMIC);
+			if (likely(nskb)) {
+				consume_skb(skb);
+				skb = nskb;
+			} else {
+				goto err_tx;
+			}
+		}
 
+		crc = crc_ccitt(0, skb->data, skb->len);
 		put_unaligned_le16(crc, skb_put(skb, 2));
 	}
 

commit c38383530fb5e160b739aff4bf08c1cc2dfcc659
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Dec 9 23:23:56 2015 +0100

    mac802154: tx: fix synced xmit deadlock
    
    This patch reverts 6001d52 ("mac802154: tx: don't allow if down while
    sync tx"). This has side effects with stop callback which flush the
    transmit workqueue. The stop callback will wait until the workqueue is
    flushed and holding the rtnl lock. That means it can happen that the stop
    callback waits forever because it try to lock the rtnl mutex which is
    already hold by stop callback.
    
    Cc: Michael Hennerich <michael.hennerich@analog.com>
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 3827f359b336..7e253455f9dd 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -38,12 +38,6 @@ void ieee802154_xmit_worker(struct work_struct *work)
 	struct net_device *dev = skb->dev;
 	int res;
 
-	rtnl_lock();
-
-	/* check if ifdown occurred while schedule */
-	if (!netif_running(dev))
-		goto err_tx;
-
 	res = drv_xmit_sync(local, skb);
 	if (res)
 		goto err_tx;
@@ -53,14 +47,11 @@ void ieee802154_xmit_worker(struct work_struct *work)
 	dev->stats.tx_packets++;
 	dev->stats.tx_bytes += skb->len;
 
-	rtnl_unlock();
-
 	return;
 
 err_tx:
 	/* Restart the netif queue on each sub_if_data object. */
 	ieee802154_wake_queue(&local->hw);
-	rtnl_unlock();
 	kfree_skb(skb);
 	netdev_dbg(dev, "transmission failed\n");
 }

commit b40988c438c2405a177ae54ff4baa08c720c296f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Sep 28 12:36:26 2015 +0200

    ieee802154: change mtu size behaviour
    
    This patch changes the mtu size of 802.15.4 interfaces. The current
    setting is the meaning of the maximum transport unit with mac header,
    which is 127 bytes according 802.15.4. The linux meaning of the mtu size
    field is the maximum payload of a mac frame. Like in ethernet, which is
    1500 bytes.
    
    We have dynamic length of mac frames in 802.15.4, this is why we assume
    the minimum header length which is hard_header_len. This contains fc and
    sequence fields. These can evaluated by driver layer without additional
    checks. We currently don't support to set the FCS from userspace, so we
    need to subtract this from mtu size as well.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index b205bbec7bdf..3827f359b336 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -71,17 +71,6 @@ ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 	struct net_device *dev = skb->dev;
 	int ret;
 
-	/* This check is for AF_PACKET RAW socket only, which doesn't
-	 * know about the FCS which is set here or by hardware. otherwise
-	 * it should not occur in any case!
-	 *
-	 * TODO: This should be handled in AF_PACKET and return -EMSGSIZE.
-	 */
-	if (skb->len > IEEE802154_MTU - IEEE802154_FCS_LEN) {
-		netdev_warn(dev, "Frame len above MTU limit. Dropped.\n");
-		goto err_tx;
-	}
-
 	if (!(local->hw.flags & IEEE802154_HW_TX_OMIT_CKSUM)) {
 		u16 crc = crc_ccitt(0, skb->data, skb->len);
 

commit d58a2fa903c18f97aac30cd3c4c8a378a2c647c4
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Sep 28 09:00:26 2015 +0200

    mac802154: add comments for llsec issues
    
    While doing a little test with the llsec implementation I saw these
    issues. We should move decryption and encruption somewhere else,
    otherwise while capturing with wireshark the mac header shows secuirty
    fields but the payload is plaintext.
    
    A complete other issue is what doing with HardMAC drivers where the
    payload is always plaintext. I think we need a special handling then in
    userspace. We currently doesn't support any HardMAC transceivers, so we
    should fix the first issue for SoftMAC transceivers.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 5ee596e00a6d..b205bbec7bdf 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -129,6 +129,10 @@ ieee802154_subif_start_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int rc;
 
+	/* TODO we should move it to wpan_dev_hard_header and dev_hard_header
+	 * functions. The reason is wireshark will show a mac header which is
+	 * with security fields but the payload is not encrypted.
+	 */
 	rc = mac802154_llsec_encrypt(&sdata->sec, skb);
 	if (rc) {
 		netdev_warn(dev, "encryption failed: %i\n", rc);

commit 02c7b6922899621aa8e8babe27fca7b6b2e497b0
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri Sep 18 11:30:44 2015 +0200

    mac802154: tx: add warning if MTU exceeds
    
    Sending over AF_PACKET RAW sockets we can sending frames which exceeds
    MTU size. To handling it correct we need to change things in AF_PACKET
    which knows on RAW sockets an additional FCS is set by hardware or
    mac802154 transmit functionality.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 66d7ecb7c56b..5ee596e00a6d 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -71,6 +71,17 @@ ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 	struct net_device *dev = skb->dev;
 	int ret;
 
+	/* This check is for AF_PACKET RAW socket only, which doesn't
+	 * know about the FCS which is set here or by hardware. otherwise
+	 * it should not occur in any case!
+	 *
+	 * TODO: This should be handled in AF_PACKET and return -EMSGSIZE.
+	 */
+	if (skb->len > IEEE802154_MTU - IEEE802154_FCS_LEN) {
+		netdev_warn(dev, "Frame len above MTU limit. Dropped.\n");
+		goto err_tx;
+	}
+
 	if (!(local->hw.flags & IEEE802154_HW_TX_OMIT_CKSUM)) {
 		u16 crc = crc_ccitt(0, skb->data, skb->len);
 

commit 87a93e4eceb495f93e3f37b100334d2641765b6c
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri Sep 18 11:30:43 2015 +0200

    ieee802154: change needed headroom/tailroom
    
    This patch cleanups needed_headroom, needed_tailroom and hard_header_len
    fields for wpan and lowpan interfaces.
    
    For wpan interfaces the worst case mac header len should be part of
    needed_headroom, currently this is set as hard_header_len, but
    hard_header_len should be set to the minimum header length which xmit
    call assumes and this is the minimum frame length of 802.15.4.
    The hard_header_len value will check inside send callbacl of AF_PACKET
    raw sockets.
    
    For lowpan interfaces, if fragmentation isn't needed the skb will
    call dev_hard_header for 802154 layer and queue it afterwards. This
    happens without new skb allocation, so we need the same headroom and
    tailroom lengths like 802154 inside 802154 6lowpan layer. At least we
    assume as minimum header length an ipv6 header size.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 7ed439172f30..66d7ecb7c56b 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -77,9 +77,6 @@ ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 		put_unaligned_le16(crc, skb_put(skb, 2));
 	}
 
-	if (skb_cow_head(skb, local->hw.extra_tx_headroom))
-		goto err_tx;
-
 	/* Stop the netif queue on each sub_if_data object. */
 	ieee802154_stop_queue(&local->hw);
 

commit c22ff7b4e74d8136a9911d8b8d0f25f9f7c3edc1
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Tue Jul 21 17:44:47 2015 +0300

    mac802154: Fix memory corruption with global deferred transmit state.
    
    When transmitting a packet via a mac802154 driver that can sleep in
    its transmit function, mac802154 defers the call to the driver's
    transmit function to a per-device workqueue.
    
    However, mac802154 uses a single global work_struct for this, which
    means that if you have more than one registered mac802154 interface
    in the system, and you transmit on more than one of them at the same
    time, you'll very easily cause memory corruption.
    
    This patch moves the deferred transmit processing state from global
    variables to struct ieee802154_local, and this seems to fix the memory
    corruption issue.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index c62e95695c78..7ed439172f30 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -30,23 +30,11 @@
 #include "ieee802154_i.h"
 #include "driver-ops.h"
 
-/* IEEE 802.15.4 transceivers can sleep during the xmit session, so process
- * packets through the workqueue.
- */
-struct ieee802154_xmit_cb {
-	struct sk_buff *skb;
-	struct work_struct work;
-	struct ieee802154_local *local;
-};
-
-static struct ieee802154_xmit_cb ieee802154_xmit_cb;
-
-static void ieee802154_xmit_worker(struct work_struct *work)
+void ieee802154_xmit_worker(struct work_struct *work)
 {
-	struct ieee802154_xmit_cb *cb =
-		container_of(work, struct ieee802154_xmit_cb, work);
-	struct ieee802154_local *local = cb->local;
-	struct sk_buff *skb = cb->skb;
+	struct ieee802154_local *local =
+		container_of(work, struct ieee802154_local, tx_work);
+	struct sk_buff *skb = local->tx_skb;
 	struct net_device *dev = skb->dev;
 	int res;
 
@@ -106,11 +94,8 @@ ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 		dev->stats.tx_packets++;
 		dev->stats.tx_bytes += skb->len;
 	} else {
-		INIT_WORK(&ieee802154_xmit_cb.work, ieee802154_xmit_worker);
-		ieee802154_xmit_cb.skb = skb;
-		ieee802154_xmit_cb.local = local;
-
-		queue_work(local->workqueue, &ieee802154_xmit_cb.work);
+		local->tx_skb = skb;
+		queue_work(local->workqueue, &local->tx_work);
 	}
 
 	return NETDEV_TX_OK;

commit 61f2dcba9a03d4fd9342f0d6821af0a46c7098e9
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 12 19:51:56 2014 +0100

    mac802154: add interframe spacing time handling
    
    This patch adds a new interframe spacing time handling into mac802154
    layer. Interframe spacing time is a time period between each transmit.
    This patch adds a high resolution timer into mac802154 and starts on
    xmit complete with corresponding interframe spacing expire time if
    ifs_handling is true. We make it variable because it depends if
    interframe spacing time is handled by transceiver or mac802154. At the
    timer complete function we wake the netdev queue again. This avoids
    new frame transmit in range of interframe spacing time.
    
    For synced driver we add no handling of interframe spacing time. This
    is currently a lack of support in all synced xmit drivers. I suppose
    it's working because the latency of workqueue which is needed to call
    spi_sync.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index cc37b77f2632..c62e95695c78 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -60,7 +60,7 @@ static void ieee802154_xmit_worker(struct work_struct *work)
 	if (res)
 		goto err_tx;
 
-	ieee802154_xmit_complete(&local->hw, skb);
+	ieee802154_xmit_complete(&local->hw, skb, false);
 
 	dev->stats.tx_packets++;
 	dev->stats.tx_bytes += skb->len;

commit 90386a7e3bcce60b6b83d0d1bd65d7b55a77fa60
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:34 2014 +0100

    mac802154: separate omit tx/rx flags
    
    This patch splits the IEEE802154_HW_OMIT_CKSUM hardware flag into
    IEEE802154_HW_TX_OMIT_CKSUM and IEEE802154_HW_RX_OMIT_CKSUM. This is
    useful to deliver the received crc from the driver layer to the monitor
    interface. At the moment we can't do that without change the xmit
    handling.
    
    The received checksum should be visible in monitor mode only.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 77973a84e9a2..cc37b77f2632 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -83,7 +83,7 @@ ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 	struct net_device *dev = skb->dev;
 	int ret;
 
-	if (!(local->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
+	if (!(local->hw.flags & IEEE802154_HW_TX_OMIT_CKSUM)) {
 		u16 crc = crc_ccitt(0, skb->data, skb->len);
 
 		put_unaligned_le16(crc, skb_put(skb, 2));

commit 59cb300f2b2ce1fc46696deb9a7bd066cd53a65a
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:21 2014 +0100

    mac802154: use driver-ops function wrappers
    
    This patch replaces all directly called driver ops by previous
    introduced driver-ops function wrappers.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index e85767355c48..77973a84e9a2 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -28,6 +28,7 @@
 #include <net/cfg802154.h>
 
 #include "ieee802154_i.h"
+#include "driver-ops.h"
 
 /* IEEE 802.15.4 transceivers can sleep during the xmit session, so process
  * packets through the workqueue.
@@ -55,7 +56,7 @@ static void ieee802154_xmit_worker(struct work_struct *work)
 	if (!netif_running(dev))
 		goto err_tx;
 
-	res = local->ops->xmit_sync(&local->hw, skb);
+	res = drv_xmit_sync(local, skb);
 	if (res)
 		goto err_tx;
 
@@ -96,7 +97,7 @@ ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 
 	/* async is priority, otherwise sync is fallback */
 	if (local->ops->xmit_async) {
-		ret = local->ops->xmit_async(&local->hw, skb);
+		ret = drv_xmit_async(local, skb);
 		if (ret) {
 			ieee802154_wake_queue(&local->hw);
 			goto err_tx;

commit 4ca18be54f507ddb2bedb44c2e3b988163684988
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:33 2014 +0100

    mac802154: tx: remove monitor receive while xmit
    
    This removes the call of monitor receive funktion when any interface
    type call xmit. There exist no such use case that a monitor interface
    should receive the actual sending frame. One use case could be that a
    wpan interface and monitor interface could be running at the same time
    on one phy. Then the monitor interface receives the wpan frames also.
    Furthermore we adding support for promiscous mode setting. With
    promiscous mode setting we can't run a wpan and monitor interface at the
    same time.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 31e51e4635e4..e85767355c48 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -82,8 +82,6 @@ ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 	struct net_device *dev = skb->dev;
 	int ret;
 
-	mac802154_monitors_rx(local, skb);
-
 	if (!(local->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
 		u16 crc = crc_ccitt(0, skb->data, skb->len);
 

commit 061ef8f915988839b12460c47ebfcf3700e124f0
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:28 2014 +0100

    mac802154: tx: use put_unaligned_le16 for copy crc
    
    This patch replaces the memcpy with a put_unaligned_le16. The placement
    of crc inside of PSDU can also be unaligned. With memcpy this can fail
    on some architectures.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reported-by: Marcel Holtmann <marcel@holtmann.org>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index fe2e17e6fee3..31e51e4635e4 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -20,6 +20,7 @@
 #include <linux/netdevice.h>
 #include <linux/if_arp.h>
 #include <linux/crc-ccitt.h>
+#include <asm/unaligned.h>
 
 #include <net/rtnetlink.h>
 #include <net/ieee802154_netdev.h>
@@ -84,9 +85,9 @@ ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 	mac802154_monitors_rx(local, skb);
 
 	if (!(local->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
-		__le16 crc = cpu_to_le16(crc_ccitt(0, skb->data, skb->len));
+		u16 crc = crc_ccitt(0, skb->data, skb->len);
 
-		memcpy(skb_put(skb, 2), &crc, 2);
+		put_unaligned_le16(crc, skb_put(skb, 2));
 	}
 
 	if (skb_cow_head(skb, local->hw.extra_tx_headroom))

commit f81f466ca588a5bd868008154050305481f241d4
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 18:15:34 2014 +0100

    mac802154: tx: make worker information static
    
    This patch moves the worker information struct out of skb control block.
    Instead control block we declare it static inside of tx.c file. We can do
    that, because the worker can't be used twice at the same time. It's
    protected by stop and wake netdev queue.
    
    This patch fix an issue that the "struct ieee802154_xmit_cb" doesn't fit
    into the skb control block on some kernel configuartion reported by
    kbuild test robot.
    
    It was introduced by commit fe24371d6645b766c59ec664c59d0a9c310ad455
    ("mac802154: tx: remove kmalloc in xmit hotpath").
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 74882c72b6c3..fe2e17e6fee3 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -37,13 +37,7 @@ struct ieee802154_xmit_cb {
 	struct ieee802154_local *local;
 };
 
-static inline struct ieee802154_xmit_cb *
-ieee802154_xmit_cb(const struct sk_buff *skb)
-{
-	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct ieee802154_xmit_cb));
-
-	return (struct ieee802154_xmit_cb *)skb->cb;
-}
+static struct ieee802154_xmit_cb ieee802154_xmit_cb;
 
 static void ieee802154_xmit_worker(struct work_struct *work)
 {
@@ -84,7 +78,6 @@ static void ieee802154_xmit_worker(struct work_struct *work)
 static netdev_tx_t
 ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 {
-	struct ieee802154_xmit_cb *cb = ieee802154_xmit_cb(skb);
 	struct net_device *dev = skb->dev;
 	int ret;
 
@@ -113,11 +106,11 @@ ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 		dev->stats.tx_packets++;
 		dev->stats.tx_bytes += skb->len;
 	} else {
-		INIT_WORK(&cb->work, ieee802154_xmit_worker);
-		cb->skb = skb;
-		cb->local = local;
+		INIT_WORK(&ieee802154_xmit_cb.work, ieee802154_xmit_worker);
+		ieee802154_xmit_cb.skb = skb;
+		ieee802154_xmit_cb.local = local;
 
-		queue_work(local->workqueue, &cb->work);
+		queue_work(local->workqueue, &ieee802154_xmit_cb.work);
 	}
 
 	return NETDEV_TX_OK;

commit e5e584fcc26b6b2225855b6fdba64d90dd8e2ea6
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:13 2014 +0100

    mac802154: tx: change naming convention
    
    This patch changes the naming convention of the tx functions like
    mac80211. Just with an 802154 instead 80211 inside the name.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index fe105d42ef83..74882c72b6c3 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -31,22 +31,24 @@
 /* IEEE 802.15.4 transceivers can sleep during the xmit session, so process
  * packets through the workqueue.
  */
-struct wpan_xmit_cb {
+struct ieee802154_xmit_cb {
 	struct sk_buff *skb;
 	struct work_struct work;
 	struct ieee802154_local *local;
 };
 
-static inline struct wpan_xmit_cb *wpan_xmit_cb(const struct sk_buff *skb)
+static inline struct ieee802154_xmit_cb *
+ieee802154_xmit_cb(const struct sk_buff *skb)
 {
-	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct wpan_xmit_cb));
+	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct ieee802154_xmit_cb));
 
-	return (struct wpan_xmit_cb *)skb->cb;
+	return (struct ieee802154_xmit_cb *)skb->cb;
 }
 
-static void mac802154_xmit_worker(struct work_struct *work)
+static void ieee802154_xmit_worker(struct work_struct *work)
 {
-	struct wpan_xmit_cb *cb = container_of(work, struct wpan_xmit_cb, work);
+	struct ieee802154_xmit_cb *cb =
+		container_of(work, struct ieee802154_xmit_cb, work);
 	struct ieee802154_local *local = cb->local;
 	struct sk_buff *skb = cb->skb;
 	struct net_device *dev = skb->dev;
@@ -80,9 +82,9 @@ static void mac802154_xmit_worker(struct work_struct *work)
 }
 
 static netdev_tx_t
-mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
+ieee802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 {
-	struct wpan_xmit_cb *cb = wpan_xmit_cb(skb);
+	struct ieee802154_xmit_cb *cb = ieee802154_xmit_cb(skb);
 	struct net_device *dev = skb->dev;
 	int ret;
 
@@ -111,7 +113,7 @@ mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 		dev->stats.tx_packets++;
 		dev->stats.tx_bytes += skb->len;
 	} else {
-		INIT_WORK(&cb->work, mac802154_xmit_worker);
+		INIT_WORK(&cb->work, ieee802154_xmit_worker);
 		cb->skb = skb;
 		cb->local = local;
 
@@ -125,16 +127,18 @@ mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 	return NETDEV_TX_OK;
 }
 
-netdev_tx_t mac802154_monitor_xmit(struct sk_buff *skb, struct net_device *dev)
+netdev_tx_t
+ieee802154_monitor_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	skb->skb_iif = dev->ifindex;
 
-	return mac802154_tx(sdata->local, skb);
+	return ieee802154_tx(sdata->local, skb);
 }
 
-netdev_tx_t mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
+netdev_tx_t
+ieee802154_subif_start_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int rc;
@@ -148,5 +152,5 @@ netdev_tx_t mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	skb->skb_iif = dev->ifindex;
 
-	return mac802154_tx(sdata->local, skb);
+	return ieee802154_tx(sdata->local, skb);
 }

commit 409c3b0c5f030e36e9d6ca747dc3059eadde0cad
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:12 2014 +0100

    mac802154: tx: move stats tx increment
    
    This patch moves the stats increment of successful transmitted packets
    in the right place when the skb was really successful transmitted.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 70fd22632cf6..fe105d42ef83 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -49,12 +49,13 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	struct wpan_xmit_cb *cb = container_of(work, struct wpan_xmit_cb, work);
 	struct ieee802154_local *local = cb->local;
 	struct sk_buff *skb = cb->skb;
+	struct net_device *dev = skb->dev;
 	int res;
 
 	rtnl_lock();
 
 	/* check if ifdown occurred while schedule */
-	if (!netif_running(skb->dev))
+	if (!netif_running(dev))
 		goto err_tx;
 
 	res = local->ops->xmit_sync(&local->hw, skb);
@@ -63,6 +64,9 @@ static void mac802154_xmit_worker(struct work_struct *work)
 
 	ieee802154_xmit_complete(&local->hw, skb);
 
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+
 	rtnl_unlock();
 
 	return;
@@ -72,13 +76,14 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	ieee802154_wake_queue(&local->hw);
 	rtnl_unlock();
 	kfree_skb(skb);
-	netdev_dbg(skb->dev, "transmission failed\n");
+	netdev_dbg(dev, "transmission failed\n");
 }
 
 static netdev_tx_t
 mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 {
 	struct wpan_xmit_cb *cb = wpan_xmit_cb(skb);
+	struct net_device *dev = skb->dev;
 	int ret;
 
 	mac802154_monitors_rx(local, skb);
@@ -102,6 +107,9 @@ mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 			ieee802154_wake_queue(&local->hw);
 			goto err_tx;
 		}
+
+		dev->stats.tx_packets++;
+		dev->stats.tx_bytes += skb->len;
 	} else {
 		INIT_WORK(&cb->work, mac802154_xmit_worker);
 		cb->skb = skb;
@@ -122,8 +130,6 @@ netdev_tx_t mac802154_monitor_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	skb->skb_iif = dev->ifindex;
-	dev->stats.tx_packets++;
-	dev->stats.tx_bytes += skb->len;
 
 	return mac802154_tx(sdata->local, skb);
 }
@@ -141,8 +147,6 @@ netdev_tx_t mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
 	}
 
 	skb->skb_iif = dev->ifindex;
-	dev->stats.tx_packets++;
-	dev->stats.tx_bytes += skb->len;
 
 	return mac802154_tx(sdata->local, skb);
 }

commit b7eec52bcb7ab93a8cce0f718f42fa17d6d91745
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:11 2014 +0100

    mac802154: tx: cleanup crc calculation
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index d39c7d946bc3..70fd22632cf6 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -84,11 +84,9 @@ mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 	mac802154_monitors_rx(local, skb);
 
 	if (!(local->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
-		u16 crc = crc_ccitt(0, skb->data, skb->len);
-		u8 *data = skb_put(skb, 2);
+		__le16 crc = cpu_to_le16(crc_ccitt(0, skb->data, skb->len));
 
-		data[0] = crc & 0xff;
-		data[1] = crc >> 8;
+		memcpy(skb_put(skb, 2), &crc, 2);
 	}
 
 	if (skb_cow_head(skb, local->hw.extra_tx_headroom))

commit cfa626cb3725101fd1853c2cab857aabfd78274b
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:10 2014 +0100

    mac802154: tx: use netdev print helpers
    
    This patch replace the pr_foo printout function to netdev_foo printout
    function. Inside the xmit handling, the interface is already known.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 44390419af86..d39c7d946bc3 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -72,7 +72,7 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	ieee802154_wake_queue(&local->hw);
 	rtnl_unlock();
 	kfree_skb(skb);
-	pr_debug("transmission failed\n");
+	netdev_dbg(skb->dev, "transmission failed\n");
 }
 
 static netdev_tx_t
@@ -137,7 +137,7 @@ netdev_tx_t mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	rc = mac802154_llsec_encrypt(&sdata->sec, skb);
 	if (rc) {
-		pr_warn("encryption failed: %i\n", rc);
+		netdev_warn(dev, "encryption failed: %i\n", rc);
 		kfree_skb(skb);
 		return NETDEV_TX_OK;
 	}

commit 6001d5223dd458e4f0063df2a24762eb2a619b17
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:09 2014 +0100

    mac802154: tx: don't allow if down while sync tx
    
    This patch holds rtnl lock while sync xmit inside of workqueue.
    Otherwise we could down the interface while worker xmit handling.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 1a4f6d91ab8c..44390419af86 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -21,6 +21,7 @@
 #include <linux/if_arp.h>
 #include <linux/crc-ccitt.h>
 
+#include <net/rtnetlink.h>
 #include <net/ieee802154_netdev.h>
 #include <net/mac802154.h>
 #include <net/cfg802154.h>
@@ -50,16 +51,28 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	struct sk_buff *skb = cb->skb;
 	int res;
 
+	rtnl_lock();
+
+	/* check if ifdown occurred while schedule */
+	if (!netif_running(skb->dev))
+		goto err_tx;
+
 	res = local->ops->xmit_sync(&local->hw, skb);
-	if (res) {
-		pr_debug("transmission failed\n");
-		/* Restart the netif queue on each sub_if_data object. */
-		ieee802154_wake_queue(&local->hw);
-		kfree_skb(skb);
-	} else {
-		/* Restart the netif queue on each sub_if_data object. */
-		ieee802154_xmit_complete(&local->hw, skb);
-	}
+	if (res)
+		goto err_tx;
+
+	ieee802154_xmit_complete(&local->hw, skb);
+
+	rtnl_unlock();
+
+	return;
+
+err_tx:
+	/* Restart the netif queue on each sub_if_data object. */
+	ieee802154_wake_queue(&local->hw);
+	rtnl_unlock();
+	kfree_skb(skb);
+	pr_debug("transmission failed\n");
 }
 
 static netdev_tx_t

commit ed0a5dce0c29f30ee53a87793206156cf38ae70d
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:08 2014 +0100

    mac802154: tx: add support for xmit_async callback
    
    This patch renames the existsing xmit callback to xmit_sync and
    introduces an asynchronous xmit_async function. If ieee802154_ops
    doesn't provide the xmit_async callback, then we have a fallback to
    the xmit_sync callback.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 23139cae0764..1a4f6d91ab8c 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -50,7 +50,7 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	struct sk_buff *skb = cb->skb;
 	int res;
 
-	res = local->ops->xmit(&local->hw, skb);
+	res = local->ops->xmit_sync(&local->hw, skb);
 	if (res) {
 		pr_debug("transmission failed\n");
 		/* Restart the netif queue on each sub_if_data object. */
@@ -66,6 +66,7 @@ static netdev_tx_t
 mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 {
 	struct wpan_xmit_cb *cb = wpan_xmit_cb(skb);
+	int ret;
 
 	mac802154_monitors_rx(local, skb);
 
@@ -83,11 +84,20 @@ mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 	/* Stop the netif queue on each sub_if_data object. */
 	ieee802154_stop_queue(&local->hw);
 
-	INIT_WORK(&cb->work, mac802154_xmit_worker);
-	cb->skb = skb;
-	cb->local = local;
+	/* async is priority, otherwise sync is fallback */
+	if (local->ops->xmit_async) {
+		ret = local->ops->xmit_async(&local->hw, skb);
+		if (ret) {
+			ieee802154_wake_queue(&local->hw);
+			goto err_tx;
+		}
+	} else {
+		INIT_WORK(&cb->work, mac802154_xmit_worker);
+		cb->skb = skb;
+		cb->local = local;
 
-	queue_work(local->workqueue, &cb->work);
+		queue_work(local->workqueue, &cb->work);
+	}
 
 	return NETDEV_TX_OK;
 

commit cdb66beaa0da7d326069b10bef090645d61d813f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:07 2014 +0100

    mac802154: tx: fix error handling while xmit
    
    In case of an error we should call kfree_skb instead of consume_skb which
    is called by ieee802154_xmit_complete function.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 8e2f429a4546..23139cae0764 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -51,11 +51,15 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	int res;
 
 	res = local->ops->xmit(&local->hw, skb);
-	if (res)
+	if (res) {
 		pr_debug("transmission failed\n");
-
-	/* Restart the netif queue on each sub_if_data object. */
-	ieee802154_xmit_complete(&local->hw, skb);
+		/* Restart the netif queue on each sub_if_data object. */
+		ieee802154_wake_queue(&local->hw);
+		kfree_skb(skb);
+	} else {
+		/* Restart the netif queue on each sub_if_data object. */
+		ieee802154_xmit_complete(&local->hw, skb);
+	}
 }
 
 static netdev_tx_t

commit 18d60a0d49ef3eb2d31f65cf5b652702d9c6e710
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:06 2014 +0100

    mac802154: tx: use queue helpers in xmit worker
    
    This patch uses the queue utility helpers inside the xmit worker of
    mac802154 subsystem.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index be8deae19386..8e2f429a4546 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -47,7 +47,6 @@ static void mac802154_xmit_worker(struct work_struct *work)
 {
 	struct wpan_xmit_cb *cb = container_of(work, struct wpan_xmit_cb, work);
 	struct ieee802154_local *local = cb->local;
-	struct ieee802154_sub_if_data *sdata;
 	struct sk_buff *skb = cb->skb;
 	int res;
 
@@ -56,18 +55,12 @@ static void mac802154_xmit_worker(struct work_struct *work)
 		pr_debug("transmission failed\n");
 
 	/* Restart the netif queue on each sub_if_data object. */
-	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &local->interfaces, list)
-		netif_wake_queue(sdata->dev);
-	rcu_read_unlock();
-
-	dev_kfree_skb(skb);
+	ieee802154_xmit_complete(&local->hw, skb);
 }
 
 static netdev_tx_t
 mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 {
-	struct ieee802154_sub_if_data *sdata;
 	struct wpan_xmit_cb *cb = wpan_xmit_cb(skb);
 
 	mac802154_monitors_rx(local, skb);
@@ -84,10 +77,7 @@ mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 		goto err_tx;
 
 	/* Stop the netif queue on each sub_if_data object. */
-	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &local->interfaces, list)
-		netif_stop_queue(sdata->dev);
-	rcu_read_unlock();
+	ieee802154_stop_queue(&local->hw);
 
 	INIT_WORK(&cb->work, mac802154_xmit_worker);
 	cb->skb = skb;

commit dc67c6b30f36d57b70b70547a30e7a8432540c6f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:04 2014 +0100

    mac802154: tx: remove xmit channel context switch
    
    This patch removes the channel hopping feature before xmit. There are
    several issues to provide a real channel hopping (timing requirements,
    etc...).
    
    We don't have any known kernelspace protocol which really use this
    feature. And I don't know an real user of this feature.
    We simply drop this feature now.
    
    This patch removes also the hold of pib lock which isn't needed by any
    real driver xmit callback implementation.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index d0ceb46134d9..be8deae19386 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -34,8 +34,6 @@ struct wpan_xmit_cb {
 	struct sk_buff *skb;
 	struct work_struct work;
 	struct ieee802154_local *local;
-	u8 chan;
-	u8 page;
 };
 
 static inline struct wpan_xmit_cb *wpan_xmit_cb(const struct sk_buff *skb)
@@ -53,26 +51,10 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	struct sk_buff *skb = cb->skb;
 	int res;
 
-	mutex_lock(&local->phy->pib_lock);
-	if (local->phy->current_channel != cb->chan ||
-	    local->phy->current_page != cb->page) {
-		res = local->ops->set_channel(&local->hw, cb->page, cb->chan);
-		if (res) {
-			pr_debug("set_channel failed\n");
-			goto out;
-		}
-
-		local->phy->current_channel = cb->chan;
-		local->phy->current_page = cb->page;
-	}
-
 	res = local->ops->xmit(&local->hw, skb);
 	if (res)
 		pr_debug("transmission failed\n");
 
-out:
-	mutex_unlock(&local->phy->pib_lock);
-
 	/* Restart the netif queue on each sub_if_data object. */
 	rcu_read_lock();
 	list_for_each_entry_rcu(sdata, &local->interfaces, list)
@@ -82,17 +64,12 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	dev_kfree_skb(skb);
 }
 
-static netdev_tx_t mac802154_tx(struct ieee802154_local *local,
-				struct sk_buff *skb, u8 page, u8 chan)
+static netdev_tx_t
+mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb)
 {
 	struct ieee802154_sub_if_data *sdata;
 	struct wpan_xmit_cb *cb = wpan_xmit_cb(skb);
 
-	if (!(local->phy->channels_supported[page] & (1 << chan))) {
-		WARN_ON(1);
-		goto err_tx;
-	}
-
 	mac802154_monitors_rx(local, skb);
 
 	if (!(local->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
@@ -115,8 +92,6 @@ static netdev_tx_t mac802154_tx(struct ieee802154_local *local,
 	INIT_WORK(&cb->work, mac802154_xmit_worker);
 	cb->skb = skb;
 	cb->local = local;
-	cb->page = page;
-	cb->chan = chan;
 
 	queue_work(local->workqueue, &cb->work);
 
@@ -130,44 +105,19 @@ static netdev_tx_t mac802154_tx(struct ieee802154_local *local,
 netdev_tx_t mac802154_monitor_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	u8 chan, page;
-
-	/* FIXME: locking */
-	chan = sdata->local->phy->current_channel;
-	page = sdata->local->phy->current_page;
-
-	if (chan == MAC802154_CHAN_NONE) /* not initialized */
-		return NETDEV_TX_OK;
-
-	if (WARN_ON(page >= WPAN_NUM_PAGES) ||
-	    WARN_ON(chan >= WPAN_NUM_CHANNELS))
-		return NETDEV_TX_OK;
 
 	skb->skb_iif = dev->ifindex;
 	dev->stats.tx_packets++;
 	dev->stats.tx_bytes += skb->len;
 
-	return mac802154_tx(sdata->local, skb, page, chan);
+	return mac802154_tx(sdata->local, skb);
 }
 
 netdev_tx_t mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	u8 chan, page;
 	int rc;
 
-	spin_lock_bh(&sdata->mib_lock);
-	chan = sdata->chan;
-	page = sdata->page;
-	spin_unlock_bh(&sdata->mib_lock);
-
-	if (chan == MAC802154_CHAN_NONE ||
-	    page >= WPAN_NUM_PAGES ||
-	    chan >= WPAN_NUM_CHANNELS) {
-		kfree_skb(skb);
-		return NETDEV_TX_OK;
-	}
-
 	rc = mac802154_llsec_encrypt(&sdata->sec, skb);
 	if (rc) {
 		pr_warn("encryption failed: %i\n", rc);
@@ -179,5 +129,5 @@ netdev_tx_t mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
 	dev->stats.tx_packets++;
 	dev->stats.tx_bytes += skb->len;
 
-	return mac802154_tx(sdata->local, skb, page, chan);
+	return mac802154_tx(sdata->local, skb);
 }

commit e89e45f22a382d14d5e2362cd4f4d12d77ee4935
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:03 2014 +0100

    mac802154: tx: squash multiple dereferencing
    
    This patch introduce some new stack variables to avoid multiple
    dereferencing inside the xmit worker function.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 513e760a8557..d0ceb46134d9 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -48,37 +48,38 @@ static inline struct wpan_xmit_cb *wpan_xmit_cb(const struct sk_buff *skb)
 static void mac802154_xmit_worker(struct work_struct *work)
 {
 	struct wpan_xmit_cb *cb = container_of(work, struct wpan_xmit_cb, work);
+	struct ieee802154_local *local = cb->local;
 	struct ieee802154_sub_if_data *sdata;
+	struct sk_buff *skb = cb->skb;
 	int res;
 
-	mutex_lock(&cb->local->phy->pib_lock);
-	if (cb->local->phy->current_channel != cb->chan ||
-	    cb->local->phy->current_page != cb->page) {
-		res = cb->local->ops->set_channel(&cb->local->hw, cb->page,
-						  cb->chan);
+	mutex_lock(&local->phy->pib_lock);
+	if (local->phy->current_channel != cb->chan ||
+	    local->phy->current_page != cb->page) {
+		res = local->ops->set_channel(&local->hw, cb->page, cb->chan);
 		if (res) {
 			pr_debug("set_channel failed\n");
 			goto out;
 		}
 
-		cb->local->phy->current_channel = cb->chan;
-		cb->local->phy->current_page = cb->page;
+		local->phy->current_channel = cb->chan;
+		local->phy->current_page = cb->page;
 	}
 
-	res = cb->local->ops->xmit(&cb->local->hw, cb->skb);
+	res = local->ops->xmit(&local->hw, skb);
 	if (res)
 		pr_debug("transmission failed\n");
 
 out:
-	mutex_unlock(&cb->local->phy->pib_lock);
+	mutex_unlock(&local->phy->pib_lock);
 
 	/* Restart the netif queue on each sub_if_data object. */
 	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &cb->local->interfaces, list)
+	list_for_each_entry_rcu(sdata, &local->interfaces, list)
 		netif_wake_queue(sdata->dev);
 	rcu_read_unlock();
 
-	dev_kfree_skb(cb->skb);
+	dev_kfree_skb(skb);
 }
 
 static netdev_tx_t mac802154_tx(struct ieee802154_local *local,

commit fe24371d6645b766c59ec664c59d0a9c310ad455
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:02 2014 +0100

    mac802154: tx: remove kmalloc in xmit hotpath
    
    This patch removes the kmalloc allocation for workqueue data. This patch
    replaces the kmalloc and uses the control block of skb. The control block
    has enough space and isn't use by any other layer in this case.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 2eb06c2cf96d..513e760a8557 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -30,7 +30,7 @@
 /* IEEE 802.15.4 transceivers can sleep during the xmit session, so process
  * packets through the workqueue.
  */
-struct xmit_work {
+struct wpan_xmit_cb {
 	struct sk_buff *skb;
 	struct work_struct work;
 	struct ieee802154_local *local;
@@ -38,50 +38,54 @@ struct xmit_work {
 	u8 page;
 };
 
+static inline struct wpan_xmit_cb *wpan_xmit_cb(const struct sk_buff *skb)
+{
+	BUILD_BUG_ON(sizeof(skb->cb) < sizeof(struct wpan_xmit_cb));
+
+	return (struct wpan_xmit_cb *)skb->cb;
+}
+
 static void mac802154_xmit_worker(struct work_struct *work)
 {
-	struct xmit_work *xw = container_of(work, struct xmit_work, work);
+	struct wpan_xmit_cb *cb = container_of(work, struct wpan_xmit_cb, work);
 	struct ieee802154_sub_if_data *sdata;
 	int res;
 
-	mutex_lock(&xw->local->phy->pib_lock);
-	if (xw->local->phy->current_channel != xw->chan ||
-	    xw->local->phy->current_page != xw->page) {
-		res = xw->local->ops->set_channel(&xw->local->hw,
-						  xw->page,
-						  xw->chan);
+	mutex_lock(&cb->local->phy->pib_lock);
+	if (cb->local->phy->current_channel != cb->chan ||
+	    cb->local->phy->current_page != cb->page) {
+		res = cb->local->ops->set_channel(&cb->local->hw, cb->page,
+						  cb->chan);
 		if (res) {
 			pr_debug("set_channel failed\n");
 			goto out;
 		}
 
-		xw->local->phy->current_channel = xw->chan;
-		xw->local->phy->current_page = xw->page;
+		cb->local->phy->current_channel = cb->chan;
+		cb->local->phy->current_page = cb->page;
 	}
 
-	res = xw->local->ops->xmit(&xw->local->hw, xw->skb);
+	res = cb->local->ops->xmit(&cb->local->hw, cb->skb);
 	if (res)
 		pr_debug("transmission failed\n");
 
 out:
-	mutex_unlock(&xw->local->phy->pib_lock);
+	mutex_unlock(&cb->local->phy->pib_lock);
 
 	/* Restart the netif queue on each sub_if_data object. */
 	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &xw->local->interfaces, list)
+	list_for_each_entry_rcu(sdata, &cb->local->interfaces, list)
 		netif_wake_queue(sdata->dev);
 	rcu_read_unlock();
 
-	dev_kfree_skb(xw->skb);
-
-	kfree(xw);
+	dev_kfree_skb(cb->skb);
 }
 
 static netdev_tx_t mac802154_tx(struct ieee802154_local *local,
 				struct sk_buff *skb, u8 page, u8 chan)
 {
-	struct xmit_work *work;
 	struct ieee802154_sub_if_data *sdata;
+	struct wpan_xmit_cb *cb = wpan_xmit_cb(skb);
 
 	if (!(local->phy->channels_supported[page] & (1 << chan))) {
 		WARN_ON(1);
@@ -101,25 +105,19 @@ static netdev_tx_t mac802154_tx(struct ieee802154_local *local,
 	if (skb_cow_head(skb, local->hw.extra_tx_headroom))
 		goto err_tx;
 
-	work = kzalloc(sizeof(*work), GFP_ATOMIC);
-	if (!work) {
-		kfree_skb(skb);
-		return NETDEV_TX_BUSY;
-	}
-
 	/* Stop the netif queue on each sub_if_data object. */
 	rcu_read_lock();
 	list_for_each_entry_rcu(sdata, &local->interfaces, list)
 		netif_stop_queue(sdata->dev);
 	rcu_read_unlock();
 
-	INIT_WORK(&work->work, mac802154_xmit_worker);
-	work->skb = skb;
-	work->local = local;
-	work->page = page;
-	work->chan = chan;
+	INIT_WORK(&cb->work, mac802154_xmit_worker);
+	cb->skb = skb;
+	cb->local = local;
+	cb->page = page;
+	cb->chan = chan;
 
-	queue_work(local->workqueue, &work->work);
+	queue_work(local->workqueue, &cb->work);
 
 	return NETDEV_TX_OK;
 

commit 50c6fb9965907732b4f5c45bd3bacf4b4f3463b9
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:01 2014 +0100

    mac802154: tx: move xmit callback to tx file
    
    This patch moves the netdev xmit callback functions into the tx.c file.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 2c40d9bb8387..2eb06c2cf96d 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -77,8 +77,8 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	kfree(xw);
 }
 
-netdev_tx_t mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb,
-			 u8 page, u8 chan)
+static netdev_tx_t mac802154_tx(struct ieee802154_local *local,
+				struct sk_buff *skb, u8 page, u8 chan)
 {
 	struct xmit_work *work;
 	struct ieee802154_sub_if_data *sdata;
@@ -127,3 +127,58 @@ netdev_tx_t mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb,
 	kfree_skb(skb);
 	return NETDEV_TX_OK;
 }
+
+netdev_tx_t mac802154_monitor_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
+	u8 chan, page;
+
+	/* FIXME: locking */
+	chan = sdata->local->phy->current_channel;
+	page = sdata->local->phy->current_page;
+
+	if (chan == MAC802154_CHAN_NONE) /* not initialized */
+		return NETDEV_TX_OK;
+
+	if (WARN_ON(page >= WPAN_NUM_PAGES) ||
+	    WARN_ON(chan >= WPAN_NUM_CHANNELS))
+		return NETDEV_TX_OK;
+
+	skb->skb_iif = dev->ifindex;
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+
+	return mac802154_tx(sdata->local, skb, page, chan);
+}
+
+netdev_tx_t mac802154_wpan_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
+	u8 chan, page;
+	int rc;
+
+	spin_lock_bh(&sdata->mib_lock);
+	chan = sdata->chan;
+	page = sdata->page;
+	spin_unlock_bh(&sdata->mib_lock);
+
+	if (chan == MAC802154_CHAN_NONE ||
+	    page >= WPAN_NUM_PAGES ||
+	    chan >= WPAN_NUM_CHANNELS) {
+		kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	rc = mac802154_llsec_encrypt(&sdata->sec, skb);
+	if (rc) {
+		pr_warn("encryption failed: %i\n", rc);
+		kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	skb->skb_iif = dev->ifindex;
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+
+	return mac802154_tx(sdata->local, skb, page, chan);
+}

commit f773054254b6aa0196063658c7e247e7c6eacbeb
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:41 2014 +0200

    mac802154: rename dev_workqueue to workqueue
    
    Small rename to use the name workqueue than dev_workqueue. To bring the
    same naming convention like wireless into 802.15.4.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 36844264b20b..2c40d9bb8387 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -119,7 +119,7 @@ netdev_tx_t mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb,
 	work->page = page;
 	work->chan = chan;
 
-	queue_work(local->dev_workqueue, &work->work);
+	queue_work(local->workqueue, &work->work);
 
 	return NETDEV_TX_OK;
 

commit 60741361c3ca229a1dbb18e05d11e97b7ea75d69
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:39 2014 +0200

    mac802154: introduce hw_to_local function
    
    This patch replace the mac802154_to_priv macro with a static inline
    function named hw_to_local. This brings a similar naming convention like
    mac80211 stack.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index b6039c75d175..36844264b20b 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -88,7 +88,7 @@ netdev_tx_t mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb,
 		goto err_tx;
 	}
 
-	mac802154_monitors_rx(mac802154_to_priv(&local->hw), skb);
+	mac802154_monitors_rx(local, skb);
 
 	if (!(local->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
 		u16 crc = crc_ccitt(0, skb->data, skb->len);

commit d98be45b3657fc233f5a098279a4e42ab6f0fa4f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:38 2014 +0200

    mac802154: rename sdata slaves and slaves_mtx
    
    This patch renamens the slaves attribute in sdata to interfaces and
    slaves_mtx to iflist_mtx. This is similar like the mac80211 stack naming
    convention.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index d20dadd6f27c..b6039c75d175 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -68,7 +68,7 @@ static void mac802154_xmit_worker(struct work_struct *work)
 
 	/* Restart the netif queue on each sub_if_data object. */
 	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &xw->local->slaves, list)
+	list_for_each_entry_rcu(sdata, &xw->local->interfaces, list)
 		netif_wake_queue(sdata->dev);
 	rcu_read_unlock();
 
@@ -109,7 +109,7 @@ netdev_tx_t mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb,
 
 	/* Stop the netif queue on each sub_if_data object. */
 	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &local->slaves, list)
+	list_for_each_entry_rcu(sdata, &local->interfaces, list)
 		netif_stop_queue(sdata->dev);
 	rcu_read_unlock();
 

commit 036562f9c4d942f2fbc77ae3215309bde340546f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:36 2014 +0200

    mac802154: rename mac802154_sub_if_data
    
    Like wireless this structure should named ieee802154_sub_if_data and not
    mac802154_sub_if_data. This patch renames the struct and variables to
    sdata instead priv sometimes.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index d4c92bd3ad32..d20dadd6f27c 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -41,7 +41,7 @@ struct xmit_work {
 static void mac802154_xmit_worker(struct work_struct *work)
 {
 	struct xmit_work *xw = container_of(work, struct xmit_work, work);
-	struct mac802154_sub_if_data *sdata;
+	struct ieee802154_sub_if_data *sdata;
 	int res;
 
 	mutex_lock(&xw->local->phy->pib_lock);
@@ -81,7 +81,7 @@ netdev_tx_t mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb,
 			 u8 page, u8 chan)
 {
 	struct xmit_work *work;
-	struct mac802154_sub_if_data *sdata;
+	struct ieee802154_sub_if_data *sdata;
 
 	if (!(local->phy->channels_supported[page] & (1 << chan))) {
 		WARN_ON(1);

commit a5e1ec538f54c4cb8ec9ce30867cfbab57225280
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:35 2014 +0200

    mac802154: rename mac802154_priv to ieee802154_local
    
    This patch rename the mac802154_priv to ieee802154_local. The
    mac802154_priv structure is like ieee80211_local and so we name it
    ieee802154_local.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 8f537bf731ca..d4c92bd3ad32 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -33,7 +33,7 @@
 struct xmit_work {
 	struct sk_buff *skb;
 	struct work_struct work;
-	struct mac802154_priv *priv;
+	struct ieee802154_local *local;
 	u8 chan;
 	u8 page;
 };
@@ -44,10 +44,10 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	struct mac802154_sub_if_data *sdata;
 	int res;
 
-	mutex_lock(&xw->priv->phy->pib_lock);
-	if (xw->priv->phy->current_channel != xw->chan ||
-	    xw->priv->phy->current_page != xw->page) {
-		res = xw->priv->ops->set_channel(&xw->priv->hw,
+	mutex_lock(&xw->local->phy->pib_lock);
+	if (xw->local->phy->current_channel != xw->chan ||
+	    xw->local->phy->current_page != xw->page) {
+		res = xw->local->ops->set_channel(&xw->local->hw,
 						  xw->page,
 						  xw->chan);
 		if (res) {
@@ -55,20 +55,20 @@ static void mac802154_xmit_worker(struct work_struct *work)
 			goto out;
 		}
 
-		xw->priv->phy->current_channel = xw->chan;
-		xw->priv->phy->current_page = xw->page;
+		xw->local->phy->current_channel = xw->chan;
+		xw->local->phy->current_page = xw->page;
 	}
 
-	res = xw->priv->ops->xmit(&xw->priv->hw, xw->skb);
+	res = xw->local->ops->xmit(&xw->local->hw, xw->skb);
 	if (res)
 		pr_debug("transmission failed\n");
 
 out:
-	mutex_unlock(&xw->priv->phy->pib_lock);
+	mutex_unlock(&xw->local->phy->pib_lock);
 
 	/* Restart the netif queue on each sub_if_data object. */
 	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &xw->priv->slaves, list)
+	list_for_each_entry_rcu(sdata, &xw->local->slaves, list)
 		netif_wake_queue(sdata->dev);
 	rcu_read_unlock();
 
@@ -77,20 +77,20 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	kfree(xw);
 }
 
-netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
+netdev_tx_t mac802154_tx(struct ieee802154_local *local, struct sk_buff *skb,
 			 u8 page, u8 chan)
 {
 	struct xmit_work *work;
 	struct mac802154_sub_if_data *sdata;
 
-	if (!(priv->phy->channels_supported[page] & (1 << chan))) {
+	if (!(local->phy->channels_supported[page] & (1 << chan))) {
 		WARN_ON(1);
 		goto err_tx;
 	}
 
-	mac802154_monitors_rx(mac802154_to_priv(&priv->hw), skb);
+	mac802154_monitors_rx(mac802154_to_priv(&local->hw), skb);
 
-	if (!(priv->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
+	if (!(local->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
 		u16 crc = crc_ccitt(0, skb->data, skb->len);
 		u8 *data = skb_put(skb, 2);
 
@@ -98,7 +98,7 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 		data[1] = crc >> 8;
 	}
 
-	if (skb_cow_head(skb, priv->hw.extra_tx_headroom))
+	if (skb_cow_head(skb, local->hw.extra_tx_headroom))
 		goto err_tx;
 
 	work = kzalloc(sizeof(*work), GFP_ATOMIC);
@@ -109,17 +109,17 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 
 	/* Stop the netif queue on each sub_if_data object. */
 	rcu_read_lock();
-	list_for_each_entry_rcu(sdata, &priv->slaves, list)
+	list_for_each_entry_rcu(sdata, &local->slaves, list)
 		netif_stop_queue(sdata->dev);
 	rcu_read_unlock();
 
 	INIT_WORK(&work->work, mac802154_xmit_worker);
 	work->skb = skb;
-	work->priv = priv;
+	work->local = local;
 	work->page = page;
 	work->chan = chan;
 
-	queue_work(priv->dev_workqueue, &work->work);
+	queue_work(local->dev_workqueue, &work->work);
 
 	return NETDEV_TX_OK;
 

commit 5ad60d36993596f7b3b958500f9c66c5338cd855
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:41:02 2014 +0200

    ieee802154: move wpan-phy.h to cfg802154.h
    
    The wpan-phy header contains the wpan_phy struct information. Later this
    header will be have similar function like cfg80211 header. The cfg80211
    header contains the wiphy struct which is identically the wpan_phy
    struct inside 802.15.4 subsystem.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index ef11cc6fa323..8f537bf731ca 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -23,7 +23,7 @@
 
 #include <net/ieee802154_netdev.h>
 #include <net/mac802154.h>
-#include <net/wpan-phy.h>
+#include <net/cfg802154.h>
 
 #include "ieee802154_i.h"
 

commit 0f1556bc2b152fc5d2a6b929c579748ec90c55d0
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:41:00 2014 +0200

    mac802154: move mac802154.h to ieee802154_i.h
    
    This patch moves the mac802154.h internal header to ieee802154_i.h like
    the wireless stack ieee80211_i.h file. This avoids confusing with the
    not internal header include/net/mac802154.h header. Additional we get
    the same naming conversion like mac80211 for this file.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 95ea412395c7..ef11cc6fa323 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -25,7 +25,7 @@
 #include <net/mac802154.h>
 #include <net/wpan-phy.h>
 
-#include "mac802154.h"
+#include "ieee802154_i.h"
 
 /* IEEE 802.15.4 transceivers can sleep during the xmit session, so process
  * packets through the workqueue.

commit b3020f0a35fc431f7acf3fba9a5b7376d79932e5
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 05:25:07 2014 +0200

    ieee802154: mac802154: remove FSF address
    
    This patch removes the FSF address in files which belongs to ieee802154
    and mac802154.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index fdf4c0e67259..95ea412395c7 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -10,10 +10,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
  * Written by:
  * Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
  * Sergey Lapin <slapin@ossfans.org>

commit f55889128a776b51581394b20abd0b470304cf95
Author: Varka Bhadram <varkab@cdac.in>
Date:   Mon Aug 11 13:25:10 2014 +0200

    mac802154: common tx error path
    
    This patch introduce the common error path on failure of Tx by
    inserting the label 'err_tx'.
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 8124353646ae..fdf4c0e67259 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -89,8 +89,7 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 
 	if (!(priv->phy->channels_supported[page] & (1 << chan))) {
 		WARN_ON(1);
-		kfree_skb(skb);
-		return NETDEV_TX_OK;
+		goto err_tx;
 	}
 
 	mac802154_monitors_rx(mac802154_to_priv(&priv->hw), skb);
@@ -103,12 +102,10 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 		data[1] = crc >> 8;
 	}
 
-	if (skb_cow_head(skb, priv->hw.extra_tx_headroom)) {
-		kfree_skb(skb);
-		return NETDEV_TX_OK;
-	}
+	if (skb_cow_head(skb, priv->hw.extra_tx_headroom))
+		goto err_tx;
 
-	work = kzalloc(sizeof(struct xmit_work), GFP_ATOMIC);
+	work = kzalloc(sizeof(*work), GFP_ATOMIC);
 	if (!work) {
 		kfree_skb(skb);
 		return NETDEV_TX_BUSY;
@@ -129,4 +126,8 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 	queue_work(priv->dev_workqueue, &work->work);
 
 	return NETDEV_TX_OK;
+
+err_tx:
+	kfree_skb(skb);
+	return NETDEV_TX_OK;
 }

commit 4710d806fcb825156e0a7b3a81104915c5e90f5d
Author: Varka Bhadram <varkabhadram@gmail.com>
Date:   Wed Jul 2 09:01:09 2014 +0530

    6lowpan: mac802154: fix coding style issues
    
    This patch fixed the coding style issues reported by checkpatch.pl
    
    following issues fixed:
            CHECK: Alignment should match open parenthesis
            WARNING: line over 80 characters
            CHECK: Blank lines aren't necessary before a close brace '}'
            WARNING: networking block comments don't use an empty /* line, use /* Comment...
            WARNING: Missing a blank line after declarations
            WARNING: networking block comments start with * on subsequent lines
            CHECK: braces {} should be used on all arms of this statement
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Tested-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 6d1647399d4f..8124353646ae 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -98,6 +98,7 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 	if (!(priv->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
 		u16 crc = crc_ccitt(0, skb->data, skb->len);
 		u8 *data = skb_put(skb, 2);
+
 		data[0] = crc & 0xff;
 		data[1] = crc >> 8;
 	}

commit 9f7f78b479ae06279a85451d456040bbe4eae013
Author: Alan Ott <alan@signal11.us>
Date:   Fri Apr 5 13:03:10 2013 +0000

    mac802154: Keep track of the channel when changed
    
    Two sections checked whether the current channel != the new channel
    without ever setting the current channel variables.
    
    1. net/mac802154/tx.c: Prevent set_channel() from getting called every
    time a packet is sent.
    
    2. net/mac802154/mib.c: Lock (pib_lock) accesses to current_channel and
    current_page and make sure they are updated when the channel has been
    changed.
    
    Signed-off-by: Alan Ott <alan@signal11.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 3fd3e07ec599..6d1647399d4f 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -58,6 +58,9 @@ static void mac802154_xmit_worker(struct work_struct *work)
 			pr_debug("set_channel failed\n");
 			goto out;
 		}
+
+		xw->priv->phy->current_channel = xw->chan;
+		xw->priv->phy->current_page = xw->page;
 	}
 
 	res = xw->priv->ops->xmit(&xw->priv->hw, xw->skb);

commit b5992fe962b0c91880229ec31166517e4db2977b
Author: Alan Ott <alan@signal11.us>
Date:   Wed Apr 3 04:00:56 2013 +0000

    mac802154: Use netif flow control
    
    Use netif_stop_queue() and netif_wake_queue() to control the flow of
    packets to mac802154 devices.  Since many IEEE 802.15.4 devices have no
    output buffer, and since the mac802154 xmit() function is designed to
    block, netif_stop_queue() is called after each packet.
    
    Signed-off-by: Alan Ott <alan@signal11.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 726487493e5c..3fd3e07ec599 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -25,6 +25,7 @@
 #include <linux/if_arp.h>
 #include <linux/crc-ccitt.h>
 
+#include <net/ieee802154_netdev.h>
 #include <net/mac802154.h>
 #include <net/wpan-phy.h>
 
@@ -44,6 +45,7 @@ struct xmit_work {
 static void mac802154_xmit_worker(struct work_struct *work)
 {
 	struct xmit_work *xw = container_of(work, struct xmit_work, work);
+	struct mac802154_sub_if_data *sdata;
 	int res;
 
 	mutex_lock(&xw->priv->phy->pib_lock);
@@ -65,6 +67,11 @@ static void mac802154_xmit_worker(struct work_struct *work)
 out:
 	mutex_unlock(&xw->priv->phy->pib_lock);
 
+	/* Restart the netif queue on each sub_if_data object. */
+	rcu_read_lock();
+	list_for_each_entry_rcu(sdata, &xw->priv->slaves, list)
+		netif_wake_queue(sdata->dev);
+	rcu_read_unlock();
 
 	dev_kfree_skb(xw->skb);
 
@@ -75,6 +82,7 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 			 u8 page, u8 chan)
 {
 	struct xmit_work *work;
+	struct mac802154_sub_if_data *sdata;
 
 	if (!(priv->phy->channels_supported[page] & (1 << chan))) {
 		WARN_ON(1);
@@ -102,6 +110,12 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 		return NETDEV_TX_BUSY;
 	}
 
+	/* Stop the netif queue on each sub_if_data object. */
+	rcu_read_lock();
+	list_for_each_entry_rcu(sdata, &priv->slaves, list)
+		netif_stop_queue(sdata->dev);
+	rcu_read_unlock();
+
 	INIT_WORK(&work->work, mac802154_xmit_worker);
 	work->skb = skb;
 	work->priv = priv;

commit 7dd43d356e739ea0fbeb832722fec36ba4e47540
Author: Alan Ott <alan@signal11.us>
Date:   Wed Apr 3 04:00:55 2013 +0000

    mac802154: Do not try to resend failed packets
    
    When ops->xmit() fails, drop the packet. Devices which support hardware
    ack and retry (which include all devices currently supported by mainline),
    will automatically retry sending the packet (in the hardware) up to 3
    times, per the 802.15.4 spec.  There is no need, and it is incorrect to
    try to do it in mac802154.
    
    Signed-off-by: Alan Ott <alan@signal11.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 4e09d070995a..726487493e5c 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -39,7 +39,6 @@ struct xmit_work {
 	struct mac802154_priv *priv;
 	u8 chan;
 	u8 page;
-	u8 xmit_attempts;
 };
 
 static void mac802154_xmit_worker(struct work_struct *work)
@@ -60,18 +59,12 @@ static void mac802154_xmit_worker(struct work_struct *work)
 	}
 
 	res = xw->priv->ops->xmit(&xw->priv->hw, xw->skb);
+	if (res)
+		pr_debug("transmission failed\n");
 
 out:
 	mutex_unlock(&xw->priv->phy->pib_lock);
 
-	if (res) {
-		if (xw->xmit_attempts++ < MAC802154_MAX_XMIT_ATTEMPTS) {
-			queue_work(xw->priv->dev_workqueue, &xw->work);
-			return;
-		} else
-			pr_debug("transmission failed for %d times",
-				 MAC802154_MAX_XMIT_ATTEMPTS);
-	}
 
 	dev_kfree_skb(xw->skb);
 
@@ -114,7 +107,6 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 	work->priv = priv;
 	work->page = page;
 	work->chan = chan;
-	work->xmit_attempts = 0;
 
 	queue_work(priv->dev_workqueue, &work->work);
 

commit 92a2ec72a7dbb84f4b614c9b72880d86db69475f
Author: Alan Ott <alan@signal11.us>
Date:   Thu Nov 29 18:25:11 2012 +0000

    mac802154: use kfree_skb() instead of dev_kfree_skb()
    
    kfree_skb() indicates failure, which is where this is being used.
    
    Signed-off-by: Alan Ott <alan@signal11.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index db639140afc6..4e09d070995a 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -99,7 +99,7 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 	}
 
 	if (skb_cow_head(skb, priv->hw.extra_tx_headroom)) {
-		dev_kfree_skb(skb);
+		kfree_skb(skb);
 		return NETDEV_TX_OK;
 	}
 

commit fcefbe9fcb3b0d72c91629f7fcf7ea09a46ab2c1
Author: Alan Ott <alan@signal11.us>
Date:   Thu Nov 29 18:25:10 2012 +0000

    mac802154: fix memory leaks
    
    kfree_skb() was not getting called in the case of some failures.
    This was pointed out by Eric Dumazet.
    
    Signed-off-by: Alan Ott <alan@signal11.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 1a4df39c722e..db639140afc6 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -85,6 +85,7 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 
 	if (!(priv->phy->channels_supported[page] & (1 << chan))) {
 		WARN_ON(1);
+		kfree_skb(skb);
 		return NETDEV_TX_OK;
 	}
 
@@ -103,8 +104,10 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 	}
 
 	work = kzalloc(sizeof(struct xmit_work), GFP_ATOMIC);
-	if (!work)
+	if (!work) {
+		kfree_skb(skb);
 		return NETDEV_TX_BUSY;
+	}
 
 	INIT_WORK(&work->work, mac802154_xmit_worker);
 	work->skb = skb;

commit b26d344c6b87058ae3e8f919a18580abfc4204eb
Merge: 82aee5d7c01f 76fbc247b9ae
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jun 28 17:37:00 2012 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/caif/caif_hsi.c
            drivers/net/usb/qmi_wwan.c
    
    The qmi_wwan merge was trivial.
    
    The caif_hsi.c, on the other hand, was not.  It's a conflict between
    1c385f1fdf6f9c66d982802cd74349c040980b50 ("caif-hsi: Replace platform
    device with ops structure.") in the net-next tree and commit
    39abbaef19cd0a30be93794aa4773c779c3eb1f3 ("caif-hsi: Postpone init of
    HIS until open()") in the net tree.
    
    I did my best with that one and will ask Sjur to check it out.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 72fd5a8b75fb9962295a8c1338e13a4b1536714a
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Mon Jun 25 23:24:54 2012 +0000

    mac802154: add monitor listener to TX datapath
    
    Add monitor receive callback to the TX datapath to catch all the
    data sent to transceivers.
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 8781d8f904d9..86891153dcba 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -87,6 +87,8 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 		WARN_ON(1);
 		return NETDEV_TX_OK;
 
+	mac802154_monitors_rx(mac802154_to_priv(&priv->hw), skb);
+
 	if (!(priv->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
 		u16 crc = crc_ccitt(0, skb->data, skb->len);
 		u8 *data = skb_put(skb, 2);

commit 8a8e28b8e2c27362f24cf06513c05d5e3a304e03
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Mon Jun 25 03:30:13 2012 +0000

    mac802154: add missed braces
    
    Add missed braces after 'if' operator.
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
index 8781d8f904d9..434b6873b352 100644
--- a/net/mac802154/tx.c
+++ b/net/mac802154/tx.c
@@ -83,9 +83,10 @@ netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
 {
 	struct xmit_work *work;
 
-	if (!(priv->phy->channels_supported[page] & (1 << chan)))
+	if (!(priv->phy->channels_supported[page] & (1 << chan))) {
 		WARN_ON(1);
 		return NETDEV_TX_OK;
+	}
 
 	if (!(priv->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
 		u16 crc = crc_ccitt(0, skb->data, skb->len);

commit 5b641ebeec348761c9ebac9454c672d4d2d3ef91
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Tue May 15 20:50:22 2012 +0000

    mac802154: TX data path
    
    Main TX data path implementation between upper and physical layers.
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/tx.c b/net/mac802154/tx.c
new file mode 100644
index 000000000000..8781d8f904d9
--- /dev/null
+++ b/net/mac802154/tx.c
@@ -0,0 +1,116 @@
+/*
+ * Copyright 2007-2012 Siemens AG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Written by:
+ * Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
+ * Sergey Lapin <slapin@ossfans.org>
+ * Maxim Gorbachyov <maxim.gorbachev@siemens.com>
+ * Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
+ */
+
+#include <linux/netdevice.h>
+#include <linux/if_arp.h>
+#include <linux/crc-ccitt.h>
+
+#include <net/mac802154.h>
+#include <net/wpan-phy.h>
+
+#include "mac802154.h"
+
+/* IEEE 802.15.4 transceivers can sleep during the xmit session, so process
+ * packets through the workqueue.
+ */
+struct xmit_work {
+	struct sk_buff *skb;
+	struct work_struct work;
+	struct mac802154_priv *priv;
+	u8 chan;
+	u8 page;
+	u8 xmit_attempts;
+};
+
+static void mac802154_xmit_worker(struct work_struct *work)
+{
+	struct xmit_work *xw = container_of(work, struct xmit_work, work);
+	int res;
+
+	mutex_lock(&xw->priv->phy->pib_lock);
+	if (xw->priv->phy->current_channel != xw->chan ||
+	    xw->priv->phy->current_page != xw->page) {
+		res = xw->priv->ops->set_channel(&xw->priv->hw,
+						  xw->page,
+						  xw->chan);
+		if (res) {
+			pr_debug("set_channel failed\n");
+			goto out;
+		}
+	}
+
+	res = xw->priv->ops->xmit(&xw->priv->hw, xw->skb);
+
+out:
+	mutex_unlock(&xw->priv->phy->pib_lock);
+
+	if (res) {
+		if (xw->xmit_attempts++ < MAC802154_MAX_XMIT_ATTEMPTS) {
+			queue_work(xw->priv->dev_workqueue, &xw->work);
+			return;
+		} else
+			pr_debug("transmission failed for %d times",
+				 MAC802154_MAX_XMIT_ATTEMPTS);
+	}
+
+	dev_kfree_skb(xw->skb);
+
+	kfree(xw);
+}
+
+netdev_tx_t mac802154_tx(struct mac802154_priv *priv, struct sk_buff *skb,
+			 u8 page, u8 chan)
+{
+	struct xmit_work *work;
+
+	if (!(priv->phy->channels_supported[page] & (1 << chan)))
+		WARN_ON(1);
+		return NETDEV_TX_OK;
+
+	if (!(priv->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
+		u16 crc = crc_ccitt(0, skb->data, skb->len);
+		u8 *data = skb_put(skb, 2);
+		data[0] = crc & 0xff;
+		data[1] = crc >> 8;
+	}
+
+	if (skb_cow_head(skb, priv->hw.extra_tx_headroom)) {
+		dev_kfree_skb(skb);
+		return NETDEV_TX_OK;
+	}
+
+	work = kzalloc(sizeof(struct xmit_work), GFP_ATOMIC);
+	if (!work)
+		return NETDEV_TX_BUSY;
+
+	INIT_WORK(&work->work, mac802154_xmit_worker);
+	work->skb = skb;
+	work->priv = priv;
+	work->page = page;
+	work->chan = chan;
+	work->xmit_attempts = 0;
+
+	queue_work(priv->dev_workqueue, &work->work);
+
+	return NETDEV_TX_OK;
+}
