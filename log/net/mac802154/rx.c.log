commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 4dcf6e18563a..b8ce84618a55 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -1,15 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2007-2012 Siemens AG
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * Written by:
  * Pavel Smolenskiy <pavel.smolenskiy@gmail.com>
  * Maxim Gorbachyov <maxim.gorbachev@siemens.com>

commit bd89bb6daaca3e4a7c509bdacb53a610f432fa2c
Author: Aristeu Rozanski <arozansk@redhat.com>
Date:   Mon Jul 25 11:46:41 2016 -0400

    mac802154: use rate limited warnings for malformed frames
    
    Signed-off-by: Aristeu Rozanski <arozansk@redhat.com>
    Acked-by: Alexander Aring <aar@pengutronix.de>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index b978da018bf8..4dcf6e18563a 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -109,8 +109,8 @@ ieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,
 	case IEEE802154_FC_TYPE_DATA:
 		return ieee802154_deliver_skb(skb);
 	default:
-		pr_warn("ieee802154: bad frame received (type = %d)\n",
-			mac_cb(skb)->type);
+		pr_warn_ratelimited("ieee802154: bad frame received "
+				    "(type = %d)\n", mac_cb(skb)->type);
 		goto fail;
 	}
 

commit ca1de81aa262dcf48354a7c55f2558205517d06e
Author: Aristeu Rozanski <arozansk@redhat.com>
Date:   Mon Jul 25 11:46:40 2016 -0400

    mac802154: don't warn on unsupported frames
    
    Just because we don't support certain types of frames yet doesn't mean
    we have to flood the message log with warnings about "invalid" frames.
    
    Signed-off-by: Aristeu Rozanski <arozansk@redhat.com>
    Acked-by: Alexander Aring <aar@pengutronix.de>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 446e1300383e..b978da018bf8 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -101,6 +101,11 @@ ieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,
 	sdata->dev->stats.rx_bytes += skb->len;
 
 	switch (mac_cb(skb)->type) {
+	case IEEE802154_FC_TYPE_BEACON:
+	case IEEE802154_FC_TYPE_ACK:
+	case IEEE802154_FC_TYPE_MAC_CMD:
+		goto fail;
+
 	case IEEE802154_FC_TYPE_DATA:
 		return ieee802154_deliver_skb(skb);
 	default:

commit 56f9ebe641d613916d3dce710004d48ab66660fa
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sat Nov 14 20:22:41 2015 +0100

    mac802154: Delete an unnecessary check before the function call "kfree_skb"
    
    The kfree_skb() function tests whether its argument is NULL and then
    returns immediately. Thus the test around the call is not needed.
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 42e96729dae6..446e1300383e 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -217,8 +217,7 @@ __ieee802154_rx_handle_packet(struct ieee802154_local *local,
 		break;
 	}
 
-	if (skb)
-		kfree_skb(skb);
+	kfree_skb(skb);
 }
 
 static void

commit d58a2fa903c18f97aac30cd3c4c8a378a2c647c4
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Sep 28 09:00:26 2015 +0200

    mac802154: add comments for llsec issues
    
    While doing a little test with the llsec implementation I saw these
    issues. We should move decryption and encruption somewhere else,
    otherwise while capturing with wireshark the mac header shows secuirty
    fields but the payload is plaintext.
    
    A complete other issue is what doing with HardMAC drivers where the
    payload is always plaintext. I think we need a special handling then in
    userspace. We currently doesn't support any HardMAC transceivers, so we
    should fix the first issue for SoftMAC transceivers.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index d1c33c1d6b9b..42e96729dae6 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -87,6 +87,10 @@ ieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,
 
 	skb->dev = sdata->dev;
 
+	/* TODO this should be moved after netif_receive_skb call, otherwise
+	 * wireshark will show a mac header with security fields and the
+	 * payload is already decrypted.
+	 */
 	rc = mac802154_llsec_decrypt(&sdata->sec, skb);
 	if (rc) {
 		pr_debug("decryption failed: %i\n", rc);

commit d10270ce941ee89afd74076ea3ed8dbef8a0ff25
Author: Varka Bhadram <varkabhadram@gmail.com>
Date:   Tue Jul 7 10:50:43 2015 +0530

    mac802154: fix ieee802154_rx handling
    
    Instead of passing ieee802154_hw pointer to ieee802154_rx,
    we can directly pass the ieee802154_local pointer.
    
    Signed-off-by: Varka Bhadram <varkabhadram@gmail.com>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 7791c9b8cb57..d1c33c1d6b9b 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -246,9 +246,8 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	}
 }
 
-void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
+void ieee802154_rx(struct ieee802154_local *local, struct sk_buff *skb)
 {
-	struct ieee802154_local *local = hw_to_local(hw);
 	u16 crc;
 
 	WARN_ON_ONCE(softirq_count() == 0);

commit 729a8989b3fa8ae7965c537dfccbd08512e84d3c
Author: Varka Bhadram <varkabhadram@gmail.com>
Date:   Tue Jul 7 10:50:42 2015 +0530

    mac802154: do not export ieee802154_rx()
    
    Right now there are no other users for ieee802154_rx()
    in kernel. So lets remove EXPORT_SYMBOL() for this.
    
    Also it moves the function prototype from global header
    file to local header file.
    
    Signed-off-by: Varka Bhadram <varkabhadram@gmail.com>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 5a258c11ed3b..7791c9b8cb57 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -290,7 +290,6 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 drop:
 	kfree_skb(skb);
 }
-EXPORT_SYMBOL(ieee802154_rx);
 
 void
 ieee802154_rx_irqsafe(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)

commit 3cf24cf8c3c06f9a6cacc8fc2cad94661b6096b6
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Jun 24 11:36:36 2015 +0200

    mac802154: cfg: add suspend and resume callbacks
    
    This patch introduces suspend and resume callbacks to mac802154. When
    doing suspend we calling the stop driver callback which should stop the
    receiving of frames. A transceiver should go into low-power mode then.
    Calling resume will call the start driver callback, which starts receiving
    again and allow to transmit frames.
    
    This was tested only with the fakelb driver and a qemu vm by doing the
    following commands:
    
    echo "devices" > /sys/power/pm_test
    echo "freeze" > /sys/power/state
    
    while doing some high traffic between two fakelb phys.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index d93ad2d4a4fc..5a258c11ed3b 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -253,6 +253,9 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 
 	WARN_ON_ONCE(softirq_count() == 0);
 
+	if (local->suspended)
+		goto drop;
+
 	/* TODO: When a transceiver omits the checksum here, we
 	 * add an own calculated one. This is currently an ugly
 	 * solution because the monitor needs a crc here.
@@ -273,8 +276,7 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 		crc = crc_ccitt(0, skb->data, skb->len);
 		if (crc) {
 			rcu_read_unlock();
-			kfree_skb(skb);
-			return;
+			goto drop;
 		}
 	}
 	/* remove crc */
@@ -283,6 +285,10 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 	__ieee802154_rx_handle_packet(local, skb);
 
 	rcu_read_unlock();
+
+	return;
+drop:
+	kfree_skb(skb);
 }
 EXPORT_SYMBOL(ieee802154_rx);
 

commit 1bc1754e82f03c2c29b6e39ee02af48fa3bdef23
Author: Varka Bhadram <varkabhadram@gmail.com>
Date:   Fri Jun 12 12:44:24 2015 +0530

    mac802154: rx packet handle cleanup
    
    This patch replaces !netif_running(sdata->dev) with
    !ieee802154_sdata_running(sdata) and also devide the
    code two separate if branches.
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 1bdf98068608..d93ad2d4a4fc 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -202,8 +202,10 @@ __ieee802154_rx_handle_packet(struct ieee802154_local *local,
 	}
 
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-		if (sdata->wpan_dev.iftype != NL802154_IFTYPE_NODE ||
-		    !netif_running(sdata->dev))
+		if (sdata->wpan_dev.iftype != NL802154_IFTYPE_NODE)
+			continue;
+
+		if (!ieee802154_sdata_running(sdata))
 			continue;
 
 		ieee802154_subif_frame(sdata, skb, &hdr);

commit ed65963ba0a2bdc330b1d7183f930d1c6a0a6685
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Jun 6 17:30:46 2015 +0200

    mac802154: remove unneeded vif struct
    
    This patch removes the virtual interface structure from sub if data
    struct, because it isn't used anywhere. This structure could be useful
    for give per interface information at softmac driver layer. Nevertheless
    there exist no use case currently and it contains the interface type
    information currently. This information is also stored inside wpan dev
    which is now used to check on the wpan dev interface type.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reviewed-by: Varka Bhadram <varkabhadram@gmail.com>
    Acked-by: Varka Bhadram <varkabhadram@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index e0f10063cac3..1bdf98068608 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -202,7 +202,7 @@ __ieee802154_rx_handle_packet(struct ieee802154_local *local,
 	}
 
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-		if (sdata->vif.type != NL802154_IFTYPE_NODE ||
+		if (sdata->wpan_dev.iftype != NL802154_IFTYPE_NODE ||
 		    !netif_running(sdata->dev))
 			continue;
 
@@ -227,7 +227,7 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	skb->protocol = htons(ETH_P_IEEE802154);
 
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-		if (sdata->vif.type != NL802154_IFTYPE_MONITOR)
+		if (sdata->wpan_dev.iftype != NL802154_IFTYPE_MONITOR)
 			continue;
 
 		if (!ieee802154_sdata_running(sdata))

commit c947f7e1e31a708f5a4ea8c1a627bec578cd9223
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri May 22 17:43:54 2015 +0200

    mac802154: remove mib lock
    
    This patch removes the mib lock. The new locking mechanism is to protect
    the mib values with the rtnl lock. Note that this isn't always necessary
    if we have an interface up the most mib values are readonly (e.g.
    address settings). With this behaviour we can remove locking in
    hotpath like frame parsing completely. It depends on context if we need
    to hold the rtnl lock or not, this makes the callbacks of
    ieee802154_mlme_ops unnecessary because these callbacks hols always the
    locks.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index c0d67b2b4132..e0f10063cac3 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -47,8 +47,6 @@ ieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,
 
 	pr_debug("getting packet via slave interface %s\n", sdata->dev->name);
 
-	spin_lock_bh(&sdata->mib_lock);
-
 	span = wpan_dev->pan_id;
 	sshort = wpan_dev->short_addr;
 
@@ -83,13 +81,10 @@ ieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,
 			skb->pkt_type = PACKET_OTHERHOST;
 		break;
 	default:
-		spin_unlock_bh(&sdata->mib_lock);
 		pr_debug("invalid dest mode\n");
 		goto fail;
 	}
 
-	spin_unlock_bh(&sdata->mib_lock);
-
 	skb->dev = sdata->dev;
 
 	rc = mac802154_llsec_decrypt(&sdata->sec, skb);

commit bcb47aabf4121e5cac3d34e3c83418c938374554
Author: Varka Bhadram <varkabhadram@gmail.com>
Date:   Fri Dec 5 17:19:09 2014 +0530

    mac802154: use goto label on failure
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Reviewed-by: Stefan Schmidt <s.schmidt@samsung.com>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 041dbd5958d4..c0d67b2b4132 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -85,8 +85,7 @@ ieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,
 	default:
 		spin_unlock_bh(&sdata->mib_lock);
 		pr_debug("invalid dest mode\n");
-		kfree_skb(skb);
-		return NET_RX_DROP;
+		goto fail;
 	}
 
 	spin_unlock_bh(&sdata->mib_lock);

commit 944742a36d784c2a36a141ac10ba5168b0313cec
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Nov 17 08:20:49 2014 +0100

    mac802154: use new nl802154 iftype types
    
    This patch replace the depracted IEEE802154_DEV to the new introduced
    NL802154_IFTYPE_NODE types. There is a backwards compatibility to have
    the identical types for both enum definitions. Also remove some inlcude
    issue with "linux/nl802154.h", because the export nl_policy inside this
    header it was always necessary to have an include of "net/rtnetlink.h"
    before. The reason for this is more complicated. Nevertheless we removed
    this now, because "linux/nl802154.h" is the depracted netlink interface.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index b18e755c38ce..041dbd5958d4 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -25,8 +25,7 @@
 
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
-#include <net/rtnetlink.h>
-#include <linux/nl802154.h>
+#include <net/nl802154.h>
 
 #include "ieee802154_i.h"
 
@@ -209,7 +208,7 @@ __ieee802154_rx_handle_packet(struct ieee802154_local *local,
 	}
 
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-		if (sdata->vif.type != IEEE802154_DEV_WPAN ||
+		if (sdata->vif.type != NL802154_IFTYPE_NODE ||
 		    !netif_running(sdata->dev))
 			continue;
 
@@ -234,7 +233,7 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	skb->protocol = htons(ETH_P_IEEE802154);
 
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-		if (sdata->vif.type != IEEE802154_DEV_MONITOR)
+		if (sdata->vif.type != NL802154_IFTYPE_MONITOR)
 			continue;
 
 		if (!ieee802154_sdata_running(sdata))

commit 863e88f255dac0657e57d5f1a1f95ee8733f8c13
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:45 2014 +0100

    mac802154: move mac pib attributes into wpan_dev
    
    This patch moves all mac pib attributes into the wpan_dev struct.
    Furthermore we can easier access these attributes over the netdev
    802154_ptr pointer. Currently this is only possible over a complicated
    callback structure in mac802154 because subif data structure is
    accessable inside mac802154 only.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 4b54cf33e562..b18e755c38ce 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -42,6 +42,7 @@ static int
 ieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,
 		       struct sk_buff *skb, const struct ieee802154_hdr *hdr)
 {
+	struct wpan_dev *wpan_dev = &sdata->wpan_dev;
 	__le16 span, sshort;
 	int rc;
 
@@ -49,8 +50,8 @@ ieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,
 
 	spin_lock_bh(&sdata->mib_lock);
 
-	span = sdata->pan_id;
-	sshort = sdata->short_addr;
+	span = wpan_dev->pan_id;
+	sshort = wpan_dev->short_addr;
 
 	switch (mac_cb(skb)->dest.mode) {
 	case IEEE802154_ADDR_NONE:
@@ -65,7 +66,7 @@ ieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,
 		if (mac_cb(skb)->dest.pan_id != span &&
 		    mac_cb(skb)->dest.pan_id != cpu_to_le16(IEEE802154_PANID_BROADCAST))
 			skb->pkt_type = PACKET_OTHERHOST;
-		else if (mac_cb(skb)->dest.extended_addr == sdata->extended_addr)
+		else if (mac_cb(skb)->dest.extended_addr == wpan_dev->extended_addr)
 			skb->pkt_type = PACKET_HOST;
 		else
 			skb->pkt_type = PACKET_OTHERHOST;

commit 7c118c1a866454cf2091fd84404d0915a27b0eef
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:20 2014 +0100

    mac802154: add ieee802154_vif struct
    
    This patch adds an ieee802154_vif similar like the ieee80211_vif which
    holds the interface type and maybe further more attributes like the
    ieee80211_vif structure.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Varka Bhadram <varkabhadram@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 95961cccc253..4b54cf33e562 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -208,7 +208,7 @@ __ieee802154_rx_handle_packet(struct ieee802154_local *local,
 	}
 
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-		if (sdata->type != IEEE802154_DEV_WPAN ||
+		if (sdata->vif.type != IEEE802154_DEV_WPAN ||
 		    !netif_running(sdata->dev))
 			continue;
 
@@ -233,7 +233,7 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	skb->protocol = htons(ETH_P_IEEE802154);
 
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-		if (sdata->type != IEEE802154_DEV_MONITOR)
+		if (sdata->vif.type != IEEE802154_DEV_MONITOR)
 			continue;
 
 		if (!ieee802154_sdata_running(sdata))

commit 05f7de67921d8b382b14597c3955c5881d804d99
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:42 2014 +0100

    mac802154: rx: add error handling after skb_clone
    
    This patch adds error handling after skb_clone and deliver only if
    skb_clone was successful.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 971a8553e9b6..95961cccc253 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -240,12 +240,13 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 			continue;
 
 		skb2 = skb_clone(skb, GFP_ATOMIC);
-		skb2->dev = sdata->dev;
+		if (skb2) {
+			skb2->dev = sdata->dev;
+			ieee802154_deliver_skb(skb2);
 
-		ieee802154_deliver_skb(skb2);
-
-		sdata->dev->stats.rx_packets++;
-		sdata->dev->stats.rx_bytes += skb->len;
+			sdata->dev->stats.rx_packets++;
+			sdata->dev->stats.rx_bytes += skb->len;
+		}
 	}
 }
 

commit 20b48120c14fb4bf6ebe4ed4cfa1b828e5e1dff8
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:41 2014 +0100

    mac802154: rx: monitor receive cleanup
    
    This patch replace the !netif_running(sdata->dev) instead we doing a
    !ieee802154_sdata_running(sdata). Also move this in two separate if
    branches to compare with mac80211 code.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 6ba2769f5fb4..971a8553e9b6 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -233,8 +233,10 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	skb->protocol = htons(ETH_P_IEEE802154);
 
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
-		if (sdata->type != IEEE802154_DEV_MONITOR ||
-		    !netif_running(sdata->dev))
+		if (sdata->type != IEEE802154_DEV_MONITOR)
+			continue;
+
+		if (!ieee802154_sdata_running(sdata))
 			continue;
 
 		skb2 = skb_clone(skb, GFP_ATOMIC);

commit 18460672e0651705ca557c94a369003553c3f9d6
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:40 2014 +0100

    mac802154: rx: add rx stats incrementation
    
    This patch adds rx stats incrementation when the monitor interface
    recevied a frame.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 7669cdbba526..6ba2769f5fb4 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -241,6 +241,9 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 		skb2->dev = sdata->dev;
 
 		ieee802154_deliver_skb(skb2);
+
+		sdata->dev->stats.rx_packets++;
+		sdata->dev->stats.rx_bytes += skb->len;
 	}
 }
 

commit 21fdf0a1c10719f6edbb5961f5b076f5575d4bce
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:39 2014 +0100

    mac802154: rx: use netif_receive_skb
    
    This patch removes netif_rx_ni call. Instead we call netif_receive_skb,
    we can do that since commit c5c47e67bcd24638a059b1b5e9ec18c95f8634ca
    ("mac802154: rx: use tasklet instead workqueue").
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index f15c50b97c3c..7669cdbba526 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -240,7 +240,7 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 		skb2 = skb_clone(skb, GFP_ATOMIC);
 		skb2->dev = sdata->dev;
 
-		netif_rx_ni(skb2);
+		ieee802154_deliver_skb(skb2);
 	}
 }
 

commit 1054ed81c4f5225d7a45fe5dec67430280bf3793
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:38 2014 +0100

    mac802154: rx: remove override pkt_type set to PACKET_HOST
    
    This patch removes pkt_type set to PACKET_HOST while monitor receiving.
    This should be PACKET_OTHERHOST on monitor mode which already set
    before.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index c9f1c72a1afc..f15c50b97c3c 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -239,7 +239,6 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 
 		skb2 = skb_clone(skb, GFP_ATOMIC);
 		skb2->dev = sdata->dev;
-		skb2->pkt_type = PACKET_HOST;
 
 		netif_rx_ni(skb2);
 	}

commit ec718f3db9b7968ca5dfb10c85c56ff27149df94
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:37 2014 +0100

    mac802154: rx: add software checksum filtering check
    
    This patch adds a new hardware flag which indicate that the transceiver
    doesn't support check for bad checksum via hardware. Also add a handling of
    this while receive.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index b6a4bbfdbf90..c9f1c72a1afc 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -248,6 +248,7 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 {
 	struct ieee802154_local *local = hw_to_local(hw);
+	u16 crc;
 
 	WARN_ON_ONCE(softirq_count() == 0);
 
@@ -256,8 +257,7 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 	 * solution because the monitor needs a crc here.
 	 */
 	if (local->hw.flags & IEEE802154_HW_RX_OMIT_CKSUM) {
-		u16 crc = crc_ccitt(0, skb->data, skb->len);
-
+		crc = crc_ccitt(0, skb->data, skb->len);
 		put_unaligned_le16(crc, skb_put(skb, 2));
 	}
 
@@ -265,6 +265,17 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 
 	ieee802154_monitors_rx(local, skb);
 
+	/* Check if transceiver doesn't validate the checksum.
+	 * If not we validate the checksum here.
+	 */
+	if (local->hw.flags & IEEE802154_HW_RX_DROP_BAD_CKSUM) {
+		crc = crc_ccitt(0, skb->data, skb->len);
+		if (crc) {
+			rcu_read_unlock();
+			kfree_skb(skb);
+			return;
+		}
+	}
 	/* remove crc */
 	skb_trim(skb, skb->len - 2);
 

commit b7889497d306df0be52300b3060ebc12b4194f9a
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:36 2014 +0100

    mac802154: rx: simplify crc receive handling
    
    This patch change the actual crc handling while receive. Currently the
    IEEE802154_HW_RX_OMIT_CKSUM flag is used to filter a frame with a bad crc.
    This patch changes the behaviour of IEEE802154_HW_RX_OMIT_CKSUM to add a
    crc while receiving for the monitor interface. After monitor receiving
    we remove the crc for frame parsing. This affect the driver layer
    because all drivers sets IEEE802154_HW_RX_OMIT_CKSUM and deliver without
    checksum.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 51a55d9200cb..b6a4bbfdbf90 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -21,6 +21,7 @@
 #include <linux/module.h>
 #include <linux/netdevice.h>
 #include <linux/crc-ccitt.h>
+#include <asm/unaligned.h>
 
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
@@ -225,8 +226,6 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 {
 	struct sk_buff *skb2;
 	struct ieee802154_sub_if_data *sdata;
-	u16 crc = crc_ccitt(0, skb->data, skb->len);
-	u8 *data;
 
 	skb_reset_mac_header(skb);
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
@@ -241,9 +240,6 @@ ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 		skb2 = skb_clone(skb, GFP_ATOMIC);
 		skb2->dev = sdata->dev;
 		skb2->pkt_type = PACKET_HOST;
-		data = skb_put(skb2, 2);
-		data[0] = crc & 0xff;
-		data[1] = crc >> 8;
 
 		netif_rx_ni(skb2);
 	}
@@ -255,32 +251,26 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 
 	WARN_ON_ONCE(softirq_count() == 0);
 
-	if (!(local->hw.flags & IEEE802154_HW_RX_OMIT_CKSUM)) {
-		u16 crc;
+	/* TODO: When a transceiver omits the checksum here, we
+	 * add an own calculated one. This is currently an ugly
+	 * solution because the monitor needs a crc here.
+	 */
+	if (local->hw.flags & IEEE802154_HW_RX_OMIT_CKSUM) {
+		u16 crc = crc_ccitt(0, skb->data, skb->len);
 
-		if (skb->len < 2) {
-			pr_debug("got invalid frame\n");
-			goto fail;
-		}
-		crc = crc_ccitt(0, skb->data, skb->len);
-		if (crc) {
-			pr_debug("CRC mismatch\n");
-			goto fail;
-		}
-		skb_trim(skb, skb->len - 2); /* CRC */
+		put_unaligned_le16(crc, skb_put(skb, 2));
 	}
 
 	rcu_read_lock();
 
 	ieee802154_monitors_rx(local, skb);
-	__ieee802154_rx_handle_packet(local, skb);
 
-	rcu_read_unlock();
+	/* remove crc */
+	skb_trim(skb, skb->len - 2);
 
-	return;
+	__ieee802154_rx_handle_packet(local, skb);
 
-fail:
-	kfree_skb(skb);
+	rcu_read_unlock();
 }
 EXPORT_SYMBOL(ieee802154_rx);
 

commit 08c511a7331cf6edb28895d7f46c3039180b30cb
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:35 2014 +0100

    mac802154: rx: remove unnecessary parameter
    
    This patch removes a not used parameter in ieee802154_deliver_skb.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 2aa80bdcbacf..51a55d9200cb 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -29,7 +29,7 @@
 
 #include "ieee802154_i.h"
 
-static int ieee802154_deliver_skb(struct net_device *dev, struct sk_buff *skb)
+static int ieee802154_deliver_skb(struct sk_buff *skb)
 {
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
 	skb->protocol = htons(ETH_P_IEEE802154);
@@ -103,7 +103,7 @@ ieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,
 
 	switch (mac_cb(skb)->type) {
 	case IEEE802154_FC_TYPE_DATA:
-		return ieee802154_deliver_skb(sdata->dev, skb);
+		return ieee802154_deliver_skb(skb);
 	default:
 		pr_warn("ieee802154: bad frame received (type = %d)\n",
 			mac_cb(skb)->type);

commit 90386a7e3bcce60b6b83d0d1bd65d7b55a77fa60
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:34 2014 +0100

    mac802154: separate omit tx/rx flags
    
    This patch splits the IEEE802154_HW_OMIT_CKSUM hardware flag into
    IEEE802154_HW_TX_OMIT_CKSUM and IEEE802154_HW_RX_OMIT_CKSUM. This is
    useful to deliver the received crc from the driver layer to the monitor
    interface. At the moment we can't do that without change the xmit
    handling.
    
    The received checksum should be visible in monitor mode only.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 86394befbf88..2aa80bdcbacf 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -255,7 +255,7 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 
 	WARN_ON_ONCE(softirq_count() == 0);
 
-	if (!(local->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
+	if (!(local->hw.flags & IEEE802154_HW_RX_OMIT_CKSUM)) {
 		u16 crc;
 
 		if (skb->len < 2) {

commit be9d215fa9d13ecfe013a1b0d0f92f6d84a52c5c
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:43 2014 +0100

    mac802154: rx: change naming convention
    
    This patch changes the naming convention of mac802154 rx file. It should
    be more named like mac80211 stack. Furthermore we introduce a new frame
    parsing implementation which is much similar the mac80211
    implementation.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 689bb7ff5b2a..86394befbf88 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -29,7 +29,7 @@
 
 #include "ieee802154_i.h"
 
-static int mac802154_process_data(struct net_device *dev, struct sk_buff *skb)
+static int ieee802154_deliver_skb(struct net_device *dev, struct sk_buff *skb)
 {
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
 	skb->protocol = htons(ETH_P_IEEE802154);
@@ -38,8 +38,8 @@ static int mac802154_process_data(struct net_device *dev, struct sk_buff *skb)
 }
 
 static int
-mac802154_subif_frame(struct ieee802154_sub_if_data *sdata, struct sk_buff *skb,
-		      const struct ieee802154_hdr *hdr)
+ieee802154_subif_frame(struct ieee802154_sub_if_data *sdata,
+		       struct sk_buff *skb, const struct ieee802154_hdr *hdr)
 {
 	__le16 span, sshort;
 	int rc;
@@ -103,7 +103,7 @@ mac802154_subif_frame(struct ieee802154_sub_if_data *sdata, struct sk_buff *skb,
 
 	switch (mac_cb(skb)->type) {
 	case IEEE802154_FC_TYPE_DATA:
-		return mac802154_process_data(sdata->dev, skb);
+		return ieee802154_deliver_skb(sdata->dev, skb);
 	default:
 		pr_warn("ieee802154: bad frame received (type = %d)\n",
 			mac_cb(skb)->type);
@@ -115,8 +115,8 @@ mac802154_subif_frame(struct ieee802154_sub_if_data *sdata, struct sk_buff *skb,
 	return NET_RX_DROP;
 }
 
-static void mac802154_print_addr(const char *name,
-				 const struct ieee802154_addr *addr)
+static void
+ieee802154_print_addr(const char *name, const struct ieee802154_addr *addr)
 {
 	if (addr->mode == IEEE802154_ADDR_NONE)
 		pr_debug("%s not present\n", name);
@@ -132,8 +132,8 @@ static void mac802154_print_addr(const char *name,
 	}
 }
 
-static int mac802154_parse_frame_start(struct sk_buff *skb,
-				       struct ieee802154_hdr *hdr)
+static int
+ieee802154_parse_frame_start(struct sk_buff *skb, struct ieee802154_hdr *hdr)
 {
 	int hlen;
 	struct ieee802154_mac_cb *cb = mac_cb_init(skb);
@@ -153,8 +153,8 @@ static int mac802154_parse_frame_start(struct sk_buff *skb,
 	cb->ackreq = hdr->fc.ack_request;
 	cb->secen = hdr->fc.security_enabled;
 
-	mac802154_print_addr("destination", &hdr->dest);
-	mac802154_print_addr("source", &hdr->source);
+	ieee802154_print_addr("destination", &hdr->dest);
+	ieee802154_print_addr("source", &hdr->source);
 
 	cb->source = hdr->source;
 	cb->dest = hdr->dest;
@@ -192,13 +192,14 @@ static int mac802154_parse_frame_start(struct sk_buff *skb,
 }
 
 static void
-mac802154_wpans_rx(struct ieee802154_local *local, struct sk_buff *skb)
+__ieee802154_rx_handle_packet(struct ieee802154_local *local,
+			      struct sk_buff *skb)
 {
 	int ret;
 	struct ieee802154_sub_if_data *sdata;
 	struct ieee802154_hdr hdr;
 
-	ret = mac802154_parse_frame_start(skb, &hdr);
+	ret = ieee802154_parse_frame_start(skb, &hdr);
 	if (ret) {
 		pr_debug("got invalid frame\n");
 		kfree_skb(skb);
@@ -210,7 +211,7 @@ mac802154_wpans_rx(struct ieee802154_local *local, struct sk_buff *skb)
 		    !netif_running(sdata->dev))
 			continue;
 
-		mac802154_subif_frame(sdata, skb, &hdr);
+		ieee802154_subif_frame(sdata, skb, &hdr);
 		skb = NULL;
 		break;
 	}
@@ -220,7 +221,7 @@ mac802154_wpans_rx(struct ieee802154_local *local, struct sk_buff *skb)
 }
 
 static void
-mac802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
+ieee802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 {
 	struct sk_buff *skb2;
 	struct ieee802154_sub_if_data *sdata;
@@ -271,8 +272,8 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 
 	rcu_read_lock();
 
-	mac802154_monitors_rx(local, skb);
-	mac802154_wpans_rx(local, skb);
+	ieee802154_monitors_rx(local, skb);
+	__ieee802154_rx_handle_packet(local, skb);
 
 	rcu_read_unlock();
 

commit e176b681b00d2b60e9231072d3ca841f9ddc74ea
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:39 2014 +0100

    mac802154: rx: move rcu locking
    
    Instead of twice lock and unlock mechanism this patch hold these locks
    only once at one position.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index c2999804126a..689bb7ff5b2a 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -205,7 +205,6 @@ mac802154_wpans_rx(struct ieee802154_local *local, struct sk_buff *skb)
 		return;
 	}
 
-	rcu_read_lock();
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
 		if (sdata->type != IEEE802154_DEV_WPAN ||
 		    !netif_running(sdata->dev))
@@ -215,7 +214,6 @@ mac802154_wpans_rx(struct ieee802154_local *local, struct sk_buff *skb)
 		skb = NULL;
 		break;
 	}
-	rcu_read_unlock();
 
 	if (skb)
 		kfree_skb(skb);
@@ -234,7 +232,6 @@ mac802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	skb->pkt_type = PACKET_OTHERHOST;
 	skb->protocol = htons(ETH_P_IEEE802154);
 
-	rcu_read_lock();
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
 		if (sdata->type != IEEE802154_DEV_MONITOR ||
 		    !netif_running(sdata->dev))
@@ -249,7 +246,6 @@ mac802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 
 		netif_rx_ni(skb2);
 	}
-	rcu_read_unlock();
 }
 
 void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
@@ -273,9 +269,13 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 		skb_trim(skb, skb->len - 2); /* CRC */
 	}
 
+	rcu_read_lock();
+
 	mac802154_monitors_rx(local, skb);
 	mac802154_wpans_rx(local, skb);
 
+	rcu_read_unlock();
+
 	return;
 
 fail:

commit 9cf215d0733256687796ef1161b7b358be1b0602
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:38 2014 +0100

    mac802154: rx: move skb_reset_mac_header
    
    This patch moves the skb_reset_mac_header call before frame parsing
    while wpan rx and before monitor deliver functionality.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index f7f09b46faa4..c2999804126a 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -138,6 +138,8 @@ static int mac802154_parse_frame_start(struct sk_buff *skb,
 	int hlen;
 	struct ieee802154_mac_cb *cb = mac_cb_init(skb);
 
+	skb_reset_mac_header(skb);
+
 	hlen = ieee802154_hdr_pull(skb, hdr);
 	if (hlen < 0)
 		return -EINVAL;
@@ -227,6 +229,7 @@ mac802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	u16 crc = crc_ccitt(0, skb->data, skb->len);
 	u8 *data;
 
+	skb_reset_mac_header(skb);
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
 	skb->pkt_type = PACKET_OTHERHOST;
 	skb->protocol = htons(ETH_P_IEEE802154);
@@ -255,8 +258,6 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 
 	WARN_ON_ONCE(softirq_count() == 0);
 
-	skb_reset_mac_header(skb);
-
 	if (!(local->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
 		u16 crc;
 

commit c9ca6401405ea0c197ab7c8bcab2b82b26678145
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:37 2014 +0100

    mac802154: rx: add monitor pkt_type information
    
    This patch adds a PACKET_OTHERHOST setting when a monitor interface
    receives a skb. All receiving skb's to the monitor interface should
    be PACKET_OTHERHOST.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 14eecace1859..f7f09b46faa4 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -228,6 +228,7 @@ mac802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	u8 *data;
 
 	skb->ip_summed = CHECKSUM_UNNECESSARY;
+	skb->pkt_type = PACKET_OTHERHOST;
 	skb->protocol = htons(ETH_P_IEEE802154);
 
 	rcu_read_lock();

commit 75a46f0ee774894152d505de594616f9c4dd7ef5
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:36 2014 +0100

    mac802154: rx: add CHECKSUM_UNNECESSARY
    
    This patch adds CHECKSUM_UNNECESSARY to skb->ip_summed before delivery.
    There exist no transceiver with IP checksum functionality.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index c4066b5006f1..14eecace1859 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -31,6 +31,7 @@
 
 static int mac802154_process_data(struct net_device *dev, struct sk_buff *skb)
 {
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
 	skb->protocol = htons(ETH_P_IEEE802154);
 
 	return netif_receive_skb(skb);
@@ -226,6 +227,7 @@ mac802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	u16 crc = crc_ccitt(0, skb->data, skb->len);
 	u8 *data;
 
+	skb->ip_summed = CHECKSUM_UNNECESSARY;
 	skb->protocol = htons(ETH_P_IEEE802154);
 
 	rcu_read_lock();

commit 702dcf994a0f0c467aae4b65885833a114126387
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:35 2014 +0100

    mac802154: rx: move skb->protocol setting
    
    This patch moves the skb->protocol setting to the position when it's
    needed. It's only needed when frame parsing was successful.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 246a60e8f76a..c4066b5006f1 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -31,6 +31,8 @@
 
 static int mac802154_process_data(struct net_device *dev, struct sk_buff *skb)
 {
+	skb->protocol = htons(ETH_P_IEEE802154);
+
 	return netif_receive_skb(skb);
 }
 
@@ -224,6 +226,8 @@ mac802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	u16 crc = crc_ccitt(0, skb->data, skb->len);
 	u8 *data;
 
+	skb->protocol = htons(ETH_P_IEEE802154);
+
 	rcu_read_lock();
 	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
 		if (sdata->type != IEEE802154_DEV_MONITOR ||
@@ -248,7 +252,6 @@ void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 
 	WARN_ON_ONCE(softirq_count() == 0);
 
-	skb->protocol = htons(ETH_P_IEEE802154);
 	skb_reset_mac_header(skb);
 
 	if (!(local->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {

commit 469100d6c2ff22cd1f50672ac6d09a1633334489
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:34 2014 +0100

    mac802154: rx: rename remove mac802154_subif_rx
    
    This patch removes the mac802154_subif_rx function and do the necessary
    calls inside of ieee802154_rx function. The ieee802154_rx is small
    enough to move the functionality inside this function.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 04f3d61719ec..246a60e8f76a 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -242,11 +242,12 @@ mac802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 	rcu_read_unlock();
 }
 
-static void
-mac802154_subif_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
+void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 {
 	struct ieee802154_local *local = hw_to_local(hw);
 
+	WARN_ON_ONCE(softirq_count() == 0);
+
 	skb->protocol = htons(ETH_P_IEEE802154);
 	skb_reset_mac_header(skb);
 
@@ -273,13 +274,6 @@ mac802154_subif_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 fail:
 	kfree_skb(skb);
 }
-
-void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
-{
-	WARN_ON_ONCE(softirq_count() == 0);
-
-	mac802154_subif_rx(hw, skb);
-}
 EXPORT_SYMBOL(ieee802154_rx);
 
 void

commit 4ca18be54f507ddb2bedb44c2e3b988163684988
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:33 2014 +0100

    mac802154: tx: remove monitor receive while xmit
    
    This removes the call of monitor receive funktion when any interface
    type call xmit. There exist no such use case that a monitor interface
    should receive the actual sending frame. One use case could be that a
    wpan interface and monitor interface could be running at the same time
    on one phy. Then the monitor interface receives the wpan frames also.
    Furthermore we adding support for promiscous mode setting. With
    promiscous mode setting we can't run a wpan and monitor interface at the
    same time.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index d8498c5fc297..04f3d61719ec 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -216,7 +216,8 @@ mac802154_wpans_rx(struct ieee802154_local *local, struct sk_buff *skb)
 		kfree_skb(skb);
 }
 
-void mac802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
+static void
+mac802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
 {
 	struct sk_buff *skb2;
 	struct ieee802154_sub_if_data *sdata;

commit 2a9820c9e20a7889bf464e1edff5f75d685a8214
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:32 2014 +0100

    mac802154: rx: move receive handling into rx.c
    
    This patch removes all relevant receiving functions inclusive frame
    parsing into rx file. Like mac80211 we should implement the complete
    receive handling and parsing in this file.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index c4df3210c5e6..d8498c5fc297 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -24,9 +24,223 @@
 
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
+#include <net/rtnetlink.h>
+#include <linux/nl802154.h>
 
 #include "ieee802154_i.h"
 
+static int mac802154_process_data(struct net_device *dev, struct sk_buff *skb)
+{
+	return netif_receive_skb(skb);
+}
+
+static int
+mac802154_subif_frame(struct ieee802154_sub_if_data *sdata, struct sk_buff *skb,
+		      const struct ieee802154_hdr *hdr)
+{
+	__le16 span, sshort;
+	int rc;
+
+	pr_debug("getting packet via slave interface %s\n", sdata->dev->name);
+
+	spin_lock_bh(&sdata->mib_lock);
+
+	span = sdata->pan_id;
+	sshort = sdata->short_addr;
+
+	switch (mac_cb(skb)->dest.mode) {
+	case IEEE802154_ADDR_NONE:
+		if (mac_cb(skb)->dest.mode != IEEE802154_ADDR_NONE)
+			/* FIXME: check if we are PAN coordinator */
+			skb->pkt_type = PACKET_OTHERHOST;
+		else
+			/* ACK comes with both addresses empty */
+			skb->pkt_type = PACKET_HOST;
+		break;
+	case IEEE802154_ADDR_LONG:
+		if (mac_cb(skb)->dest.pan_id != span &&
+		    mac_cb(skb)->dest.pan_id != cpu_to_le16(IEEE802154_PANID_BROADCAST))
+			skb->pkt_type = PACKET_OTHERHOST;
+		else if (mac_cb(skb)->dest.extended_addr == sdata->extended_addr)
+			skb->pkt_type = PACKET_HOST;
+		else
+			skb->pkt_type = PACKET_OTHERHOST;
+		break;
+	case IEEE802154_ADDR_SHORT:
+		if (mac_cb(skb)->dest.pan_id != span &&
+		    mac_cb(skb)->dest.pan_id != cpu_to_le16(IEEE802154_PANID_BROADCAST))
+			skb->pkt_type = PACKET_OTHERHOST;
+		else if (mac_cb(skb)->dest.short_addr == sshort)
+			skb->pkt_type = PACKET_HOST;
+		else if (mac_cb(skb)->dest.short_addr ==
+			  cpu_to_le16(IEEE802154_ADDR_BROADCAST))
+			skb->pkt_type = PACKET_BROADCAST;
+		else
+			skb->pkt_type = PACKET_OTHERHOST;
+		break;
+	default:
+		spin_unlock_bh(&sdata->mib_lock);
+		pr_debug("invalid dest mode\n");
+		kfree_skb(skb);
+		return NET_RX_DROP;
+	}
+
+	spin_unlock_bh(&sdata->mib_lock);
+
+	skb->dev = sdata->dev;
+
+	rc = mac802154_llsec_decrypt(&sdata->sec, skb);
+	if (rc) {
+		pr_debug("decryption failed: %i\n", rc);
+		goto fail;
+	}
+
+	sdata->dev->stats.rx_packets++;
+	sdata->dev->stats.rx_bytes += skb->len;
+
+	switch (mac_cb(skb)->type) {
+	case IEEE802154_FC_TYPE_DATA:
+		return mac802154_process_data(sdata->dev, skb);
+	default:
+		pr_warn("ieee802154: bad frame received (type = %d)\n",
+			mac_cb(skb)->type);
+		goto fail;
+	}
+
+fail:
+	kfree_skb(skb);
+	return NET_RX_DROP;
+}
+
+static void mac802154_print_addr(const char *name,
+				 const struct ieee802154_addr *addr)
+{
+	if (addr->mode == IEEE802154_ADDR_NONE)
+		pr_debug("%s not present\n", name);
+
+	pr_debug("%s PAN ID: %04x\n", name, le16_to_cpu(addr->pan_id));
+	if (addr->mode == IEEE802154_ADDR_SHORT) {
+		pr_debug("%s is short: %04x\n", name,
+			 le16_to_cpu(addr->short_addr));
+	} else {
+		u64 hw = swab64((__force u64)addr->extended_addr);
+
+		pr_debug("%s is hardware: %8phC\n", name, &hw);
+	}
+}
+
+static int mac802154_parse_frame_start(struct sk_buff *skb,
+				       struct ieee802154_hdr *hdr)
+{
+	int hlen;
+	struct ieee802154_mac_cb *cb = mac_cb_init(skb);
+
+	hlen = ieee802154_hdr_pull(skb, hdr);
+	if (hlen < 0)
+		return -EINVAL;
+
+	skb->mac_len = hlen;
+
+	pr_debug("fc: %04x dsn: %02x\n", le16_to_cpup((__le16 *)&hdr->fc),
+		 hdr->seq);
+
+	cb->type = hdr->fc.type;
+	cb->ackreq = hdr->fc.ack_request;
+	cb->secen = hdr->fc.security_enabled;
+
+	mac802154_print_addr("destination", &hdr->dest);
+	mac802154_print_addr("source", &hdr->source);
+
+	cb->source = hdr->source;
+	cb->dest = hdr->dest;
+
+	if (hdr->fc.security_enabled) {
+		u64 key;
+
+		pr_debug("seclevel %i\n", hdr->sec.level);
+
+		switch (hdr->sec.key_id_mode) {
+		case IEEE802154_SCF_KEY_IMPLICIT:
+			pr_debug("implicit key\n");
+			break;
+
+		case IEEE802154_SCF_KEY_INDEX:
+			pr_debug("key %02x\n", hdr->sec.key_id);
+			break;
+
+		case IEEE802154_SCF_KEY_SHORT_INDEX:
+			pr_debug("key %04x:%04x %02x\n",
+				 le32_to_cpu(hdr->sec.short_src) >> 16,
+				 le32_to_cpu(hdr->sec.short_src) & 0xffff,
+				 hdr->sec.key_id);
+			break;
+
+		case IEEE802154_SCF_KEY_HW_INDEX:
+			key = swab64((__force u64)hdr->sec.extended_src);
+			pr_debug("key source %8phC %02x\n", &key,
+				 hdr->sec.key_id);
+			break;
+		}
+	}
+
+	return 0;
+}
+
+static void
+mac802154_wpans_rx(struct ieee802154_local *local, struct sk_buff *skb)
+{
+	int ret;
+	struct ieee802154_sub_if_data *sdata;
+	struct ieee802154_hdr hdr;
+
+	ret = mac802154_parse_frame_start(skb, &hdr);
+	if (ret) {
+		pr_debug("got invalid frame\n");
+		kfree_skb(skb);
+		return;
+	}
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		if (sdata->type != IEEE802154_DEV_WPAN ||
+		    !netif_running(sdata->dev))
+			continue;
+
+		mac802154_subif_frame(sdata, skb, &hdr);
+		skb = NULL;
+		break;
+	}
+	rcu_read_unlock();
+
+	if (skb)
+		kfree_skb(skb);
+}
+
+void mac802154_monitors_rx(struct ieee802154_local *local, struct sk_buff *skb)
+{
+	struct sk_buff *skb2;
+	struct ieee802154_sub_if_data *sdata;
+	u16 crc = crc_ccitt(0, skb->data, skb->len);
+	u8 *data;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(sdata, &local->interfaces, list) {
+		if (sdata->type != IEEE802154_DEV_MONITOR ||
+		    !netif_running(sdata->dev))
+			continue;
+
+		skb2 = skb_clone(skb, GFP_ATOMIC);
+		skb2->dev = sdata->dev;
+		skb2->pkt_type = PACKET_HOST;
+		data = skb_put(skb2, 2);
+		data[0] = crc & 0xff;
+		data[1] = crc >> 8;
+
+		netif_rx_ni(skb2);
+	}
+	rcu_read_unlock();
+}
+
 static void
 mac802154_subif_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 {

commit c730c90316aa5753c6b2d3d5af40085c220e3a91
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:31 2014 +0100

    mac802154: rx: document ieee802154_rx() context requirement
    
    This patch is similar like d20ef63d32461332958661df73e21c0ca42601b0
    ("mac80211: document ieee80211_rx() context requirement"). The
    netif_receive_skb call requires with softirqs disabled. This patch
    adds a warning if softirqs are pending while calling ieee802154_rx.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 2851a3f7ac0b..c4df3210c5e6 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -61,6 +61,8 @@ mac802154_subif_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 
 void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 {
+	WARN_ON_ONCE(softirq_count() == 0);
+
 	mac802154_subif_rx(hw, skb);
 }
 EXPORT_SYMBOL(ieee802154_rx);

commit c5c47e67bcd24638a059b1b5e9ec18c95f8634ca
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:30 2014 +0100

    mac802154: rx: use tasklet instead workqueue
    
    Tasklets have much less overhead than workqueues. This patch also
    removes the heap allocation for the worker on receiving path.
    Like mac80211 we should prefer use a tasklet here instead a workqueue to
    getting fast out of interrupt context when ieee802154_rx_irqsafe is
    called by driver. Like wireless inside the tasklet context we should
    call netif_receive_skb instead netif_rx_ni anymore.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 53c9e0c10a87..2851a3f7ac0b 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -19,7 +19,6 @@
 
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/workqueue.h>
 #include <linux/netdevice.h>
 #include <linux/crc-ccitt.h>
 
@@ -28,30 +27,11 @@
 
 #include "ieee802154_i.h"
 
-/* The IEEE 802.15.4 standard defines 4 MAC packet types:
- * - beacon frame
- * - MAC command frame
- * - acknowledgement frame
- * - data frame
- *
- * and only the data frame should be pushed to the upper layers, other types
- * are just internal MAC layer management information. So only data packets
- * are going to be sent to the networking queue, all other will be processed
- * right here by using the device workqueue.
- */
-struct rx_work {
-	struct sk_buff *skb;
-	struct work_struct work;
-	struct ieee802154_hw *hw;
-	u8 lqi;
-};
-
 static void
-mac802154_subif_rx(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
+mac802154_subif_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 {
 	struct ieee802154_local *local = hw_to_local(hw);
 
-	mac_cb(skb)->lqi = lqi;
 	skb->protocol = htons(ETH_P_IEEE802154);
 	skb_reset_mac_header(skb);
 
@@ -79,32 +59,20 @@ mac802154_subif_rx(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
 	kfree_skb(skb);
 }
 
-static void mac802154_rx_worker(struct work_struct *work)
+void ieee802154_rx(struct ieee802154_hw *hw, struct sk_buff *skb)
 {
-	struct rx_work *rw = container_of(work, struct rx_work, work);
-
-	mac802154_subif_rx(rw->hw, rw->skb, rw->lqi);
-	kfree(rw);
+	mac802154_subif_rx(hw, skb);
 }
+EXPORT_SYMBOL(ieee802154_rx);
 
 void
 ieee802154_rx_irqsafe(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
 {
 	struct ieee802154_local *local = hw_to_local(hw);
-	struct rx_work *work;
 
-	if (!skb)
-		return;
-
-	work = kzalloc(sizeof(*work), GFP_ATOMIC);
-	if (!work)
-		return;
-
-	INIT_WORK(&work->work, mac802154_rx_worker);
-	work->skb = skb;
-	work->hw = hw;
-	work->lqi = lqi;
-
-	queue_work(local->workqueue, &work->work);
+	mac_cb(skb)->lqi = lqi;
+	skb->pkt_type = IEEE802154_RX_MSG;
+	skb_queue_tail(&local->skb_queue, skb);
+	tasklet_schedule(&local->tasklet);
 }
 EXPORT_SYMBOL(ieee802154_rx_irqsafe);

commit f773054254b6aa0196063658c7e247e7c6eacbeb
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:41 2014 +0200

    mac802154: rename dev_workqueue to workqueue
    
    Small rename to use the name workqueue than dev_workqueue. To bring the
    same naming convention like wireless into 802.15.4.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 1b5e8e332b9b..53c9e0c10a87 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -105,6 +105,6 @@ ieee802154_rx_irqsafe(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
 	work->hw = hw;
 	work->lqi = lqi;
 
-	queue_work(local->dev_workqueue, &work->work);
+	queue_work(local->workqueue, &work->work);
 }
 EXPORT_SYMBOL(ieee802154_rx_irqsafe);

commit 60741361c3ca229a1dbb18e05d11e97b7ea75d69
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:39 2014 +0200

    mac802154: introduce hw_to_local function
    
    This patch replace the mac802154_to_priv macro with a static inline
    function named hw_to_local. This brings a similar naming convention like
    mac80211 stack.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index dc01817a92c5..1b5e8e332b9b 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -49,7 +49,7 @@ struct rx_work {
 static void
 mac802154_subif_rx(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
 {
-	struct ieee802154_local *local = mac802154_to_priv(hw);
+	struct ieee802154_local *local = hw_to_local(hw);
 
 	mac_cb(skb)->lqi = lqi;
 	skb->protocol = htons(ETH_P_IEEE802154);
@@ -90,7 +90,7 @@ static void mac802154_rx_worker(struct work_struct *work)
 void
 ieee802154_rx_irqsafe(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
 {
-	struct ieee802154_local *local = mac802154_to_priv(hw);
+	struct ieee802154_local *local = hw_to_local(hw);
 	struct rx_work *work;
 
 	if (!skb)

commit a5e1ec538f54c4cb8ec9ce30867cfbab57225280
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:35 2014 +0200

    mac802154: rename mac802154_priv to ieee802154_local
    
    This patch rename the mac802154_priv to ieee802154_local. The
    mac802154_priv structure is like ieee80211_local and so we name it
    ieee802154_local.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 62b5c7dfe7f3..dc01817a92c5 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -49,13 +49,13 @@ struct rx_work {
 static void
 mac802154_subif_rx(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
 {
-	struct mac802154_priv *priv = mac802154_to_priv(hw);
+	struct ieee802154_local *local = mac802154_to_priv(hw);
 
 	mac_cb(skb)->lqi = lqi;
 	skb->protocol = htons(ETH_P_IEEE802154);
 	skb_reset_mac_header(skb);
 
-	if (!(priv->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
+	if (!(local->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
 		u16 crc;
 
 		if (skb->len < 2) {
@@ -70,8 +70,8 @@ mac802154_subif_rx(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
 		skb_trim(skb, skb->len - 2); /* CRC */
 	}
 
-	mac802154_monitors_rx(priv, skb);
-	mac802154_wpans_rx(priv, skb);
+	mac802154_monitors_rx(local, skb);
+	mac802154_wpans_rx(local, skb);
 
 	return;
 
@@ -90,7 +90,7 @@ static void mac802154_rx_worker(struct work_struct *work)
 void
 ieee802154_rx_irqsafe(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
 {
-	struct mac802154_priv *priv = mac802154_to_priv(hw);
+	struct ieee802154_local *local = mac802154_to_priv(hw);
 	struct rx_work *work;
 
 	if (!skb)
@@ -105,6 +105,6 @@ ieee802154_rx_irqsafe(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
 	work->hw = hw;
 	work->lqi = lqi;
 
-	queue_work(priv->dev_workqueue, &work->work);
+	queue_work(local->dev_workqueue, &work->work);
 }
 EXPORT_SYMBOL(ieee802154_rx_irqsafe);

commit 5a50439775853a8d565115edb63a5ab4bb780479
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:34 2014 +0200

    ieee802154: rename ieee802154_dev to ieee802154_hw
    
    The identical struct of the wireless stack implementation is named
    ieee80211_hw. This is useful to name the variable hw instead of get
    confusing with netdev dev variable.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index bc6cffd51f94..62b5c7dfe7f3 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -42,12 +42,12 @@
 struct rx_work {
 	struct sk_buff *skb;
 	struct work_struct work;
-	struct ieee802154_dev *dev;
+	struct ieee802154_hw *hw;
 	u8 lqi;
 };
 
 static void
-mac802154_subif_rx(struct ieee802154_dev *hw, struct sk_buff *skb, u8 lqi)
+mac802154_subif_rx(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
 {
 	struct mac802154_priv *priv = mac802154_to_priv(hw);
 
@@ -83,14 +83,14 @@ static void mac802154_rx_worker(struct work_struct *work)
 {
 	struct rx_work *rw = container_of(work, struct rx_work, work);
 
-	mac802154_subif_rx(rw->dev, rw->skb, rw->lqi);
+	mac802154_subif_rx(rw->hw, rw->skb, rw->lqi);
 	kfree(rw);
 }
 
 void
-ieee802154_rx_irqsafe(struct ieee802154_dev *dev, struct sk_buff *skb, u8 lqi)
+ieee802154_rx_irqsafe(struct ieee802154_hw *hw, struct sk_buff *skb, u8 lqi)
 {
-	struct mac802154_priv *priv = mac802154_to_priv(dev);
+	struct mac802154_priv *priv = mac802154_to_priv(hw);
 	struct rx_work *work;
 
 	if (!skb)
@@ -102,7 +102,7 @@ ieee802154_rx_irqsafe(struct ieee802154_dev *dev, struct sk_buff *skb, u8 lqi)
 
 	INIT_WORK(&work->work, mac802154_rx_worker);
 	work->skb = skb;
-	work->dev = dev;
+	work->hw = hw;
 	work->lqi = lqi;
 
 	queue_work(priv->dev_workqueue, &work->work);

commit 0f1556bc2b152fc5d2a6b929c579748ec90c55d0
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:41:00 2014 +0200

    mac802154: move mac802154.h to ieee802154_i.h
    
    This patch moves the mac802154.h internal header to ieee802154_i.h like
    the wireless stack ieee80211_i.h file. This avoids confusing with the
    not internal header include/net/mac802154.h header. Additional we get
    the same naming conversion like mac80211 for this file.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index e99d9394d13a..bc6cffd51f94 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -26,7 +26,7 @@
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
 
-#include "mac802154.h"
+#include "ieee802154_i.h"
 
 /* The IEEE 802.15.4 standard defines 4 MAC packet types:
  * - beacon frame

commit b3020f0a35fc431f7acf3fba9a5b7376d79932e5
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 05:25:07 2014 +0200

    ieee802154: mac802154: remove FSF address
    
    This patch removes the FSF address in files which belongs to ieee802154
    and mac802154.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index a14cf9ede171..e99d9394d13a 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -10,10 +10,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
  * Written by:
  * Pavel Smolenskiy <pavel.smolenskiy@gmail.com>
  * Maxim Gorbachyov <maxim.gorbachev@siemens.com>

commit 24bbd44a96c7a209fafbf1b28f0ac1a00cf4e551
Author: Varka Bhadram <varkab@cdac.in>
Date:   Mon Aug 11 13:25:07 2014 +0200

    mac802154: cleanup in rx path
    
    This patch replace the sizeof(struct rx_work) with sizeof(*work)
    and directly passing the skb in mac802154_subif_rx()
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 7f820a108a9c..a14cf9ede171 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -86,9 +86,8 @@ mac802154_subif_rx(struct ieee802154_dev *hw, struct sk_buff *skb, u8 lqi)
 static void mac802154_rx_worker(struct work_struct *work)
 {
 	struct rx_work *rw = container_of(work, struct rx_work, work);
-	struct sk_buff *skb = rw->skb;
 
-	mac802154_subif_rx(rw->dev, skb, rw->lqi);
+	mac802154_subif_rx(rw->dev, rw->skb, rw->lqi);
 	kfree(rw);
 }
 
@@ -101,7 +100,7 @@ ieee802154_rx_irqsafe(struct ieee802154_dev *dev, struct sk_buff *skb, u8 lqi)
 	if (!skb)
 		return;
 
-	work = kzalloc(sizeof(struct rx_work), GFP_ATOMIC);
+	work = kzalloc(sizeof(*work), GFP_ATOMIC);
 	if (!work)
 		return;
 

commit 2d3b5b0a90e5370ad13ca98d95519c3e41d2c925
Author: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
Date:   Wed Jun 11 12:03:07 2014 +0200

    mac802154: don't deliver packets to devices that are down
    
    Only one WPAN devices can be active at any given time, so only deliver
    packets to that one interface that is actually up. Multiple monitors may
    be up at any given time, but we don't have to deliver to monitors that
    are down either.
    
    Signed-off-by: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 0597b96dc9ba..7f820a108a9c 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -64,20 +64,23 @@ mac802154_subif_rx(struct ieee802154_dev *hw, struct sk_buff *skb, u8 lqi)
 
 		if (skb->len < 2) {
 			pr_debug("got invalid frame\n");
-			goto out;
+			goto fail;
 		}
 		crc = crc_ccitt(0, skb->data, skb->len);
 		if (crc) {
 			pr_debug("CRC mismatch\n");
-			goto out;
+			goto fail;
 		}
 		skb_trim(skb, skb->len - 2); /* CRC */
 	}
 
 	mac802154_monitors_rx(priv, skb);
 	mac802154_wpans_rx(priv, skb);
-out:
-	dev_kfree_skb(skb);
+
+	return;
+
+fail:
+	kfree_skb(skb);
 }
 
 static void mac802154_rx_worker(struct work_struct *work)

commit 32edc40ae65cf84e1ab69f6f8316ce81559e115d
Author: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
Date:   Wed May 14 17:43:08 2014 +0200

    ieee802154: change _cb handling slightly
    
    The current mac_cb handling of ieee802154 is rather awkward and limited.
    Decompose the single flags field into multiple fields with the meanings
    of each subfield of the flags field to make future extensions (for
    example, link-layer security) easier. Also don't set the frame sequence
    number in upper layers, since that's a thing the MAC is supposed to set
    on frame transmit - we set it on header creation, but assuming that
    upper layers do not blindly duplicate our headers, this is fine.
    
    Signed-off-by: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 03855b0677cc..0597b96dc9ba 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -59,8 +59,6 @@ mac802154_subif_rx(struct ieee802154_dev *hw, struct sk_buff *skb, u8 lqi)
 	skb->protocol = htons(ETH_P_IEEE802154);
 	skb_reset_mac_header(skb);
 
-	BUILD_BUG_ON(sizeof(struct ieee802154_mac_cb) > sizeof(skb->cb));
-
 	if (!(priv->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
 		u16 crc;
 

commit 2045ceaed4d54e6e698874d008be727ee5b2a01c
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Wed Feb 12 20:51:22 2014 -0800

    net: remove unnecessary return's
    
    One of my pet coding style peeves is the practice of
    adding extra return; at the end of function.
    Kill several instances of this in network code.
    
    I suppose some coccinelle wizardy could do this automatically.
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 38548ec2098f..03855b0677cc 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -80,7 +80,6 @@ mac802154_subif_rx(struct ieee802154_dev *hw, struct sk_buff *skb, u8 lqi)
 	mac802154_wpans_rx(priv, skb);
 out:
 	dev_kfree_skb(skb);
-	return;
 }
 
 static void mac802154_rx_worker(struct work_struct *work)

commit 32bad7e30f113a8a5cebe4704bf6519ab4383e1b
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Mon Jun 25 23:24:48 2012 +0000

    mac802154: add wpan device-class support
    
    Every real 802.15.4 transceiver, which works with software MAC layer,
    can be classified as a wpan device in this stack. So the wpan device
    implementation provides missing link in datapath between the device
    drivers and the Linux network queue.
    
    According to the IEEE 802.15.4 standard each packet can be one of the
    following types:
     - beacon
     - MAC layer command
     - ACK
     - data
    
    This patch adds support for the data packet-type only, but this is
    enough to perform data transmission and receiving over radio.
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index 4a7d76d4f8bc..38548ec2098f 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -77,6 +77,7 @@ mac802154_subif_rx(struct ieee802154_dev *hw, struct sk_buff *skb, u8 lqi)
 	}
 
 	mac802154_monitors_rx(priv, skb);
+	mac802154_wpans_rx(priv, skb);
 out:
 	dev_kfree_skb(skb);
 	return;

commit 0606069d9ef538687957d41ed6387d665af7a643
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Tue May 15 20:50:29 2012 +0000

    mac802154: monitor device support
    
    Support for monitor device intended to capture all the network activity.
    This interface could be used by networks sniffers and is already
    supported by WireShark. That's a good test point to check that basic
    MAC support works.
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
index d15738fae551..4a7d76d4f8bc 100644
--- a/net/mac802154/rx.c
+++ b/net/mac802154/rx.c
@@ -76,6 +76,7 @@ mac802154_subif_rx(struct ieee802154_dev *hw, struct sk_buff *skb, u8 lqi)
 		skb_trim(skb, skb->len - 2); /* CRC */
 	}
 
+	mac802154_monitors_rx(priv, skb);
 out:
 	dev_kfree_skb(skb);
 	return;

commit 1cd829c83eab8b899b85d597c767fcf8b4cf8fd6
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Tue May 15 20:50:21 2012 +0000

    mac802154: RX data path
    
    Main RX data path implementation between physical and mac layers.
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/rx.c b/net/mac802154/rx.c
new file mode 100644
index 000000000000..d15738fae551
--- /dev/null
+++ b/net/mac802154/rx.c
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2007-2012 Siemens AG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Written by:
+ * Pavel Smolenskiy <pavel.smolenskiy@gmail.com>
+ * Maxim Gorbachyov <maxim.gorbachev@siemens.com>
+ * Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
+ * Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/workqueue.h>
+#include <linux/netdevice.h>
+#include <linux/crc-ccitt.h>
+
+#include <net/mac802154.h>
+#include <net/ieee802154_netdev.h>
+
+#include "mac802154.h"
+
+/* The IEEE 802.15.4 standard defines 4 MAC packet types:
+ * - beacon frame
+ * - MAC command frame
+ * - acknowledgement frame
+ * - data frame
+ *
+ * and only the data frame should be pushed to the upper layers, other types
+ * are just internal MAC layer management information. So only data packets
+ * are going to be sent to the networking queue, all other will be processed
+ * right here by using the device workqueue.
+ */
+struct rx_work {
+	struct sk_buff *skb;
+	struct work_struct work;
+	struct ieee802154_dev *dev;
+	u8 lqi;
+};
+
+static void
+mac802154_subif_rx(struct ieee802154_dev *hw, struct sk_buff *skb, u8 lqi)
+{
+	struct mac802154_priv *priv = mac802154_to_priv(hw);
+
+	mac_cb(skb)->lqi = lqi;
+	skb->protocol = htons(ETH_P_IEEE802154);
+	skb_reset_mac_header(skb);
+
+	BUILD_BUG_ON(sizeof(struct ieee802154_mac_cb) > sizeof(skb->cb));
+
+	if (!(priv->hw.flags & IEEE802154_HW_OMIT_CKSUM)) {
+		u16 crc;
+
+		if (skb->len < 2) {
+			pr_debug("got invalid frame\n");
+			goto out;
+		}
+		crc = crc_ccitt(0, skb->data, skb->len);
+		if (crc) {
+			pr_debug("CRC mismatch\n");
+			goto out;
+		}
+		skb_trim(skb, skb->len - 2); /* CRC */
+	}
+
+out:
+	dev_kfree_skb(skb);
+	return;
+}
+
+static void mac802154_rx_worker(struct work_struct *work)
+{
+	struct rx_work *rw = container_of(work, struct rx_work, work);
+	struct sk_buff *skb = rw->skb;
+
+	mac802154_subif_rx(rw->dev, skb, rw->lqi);
+	kfree(rw);
+}
+
+void
+ieee802154_rx_irqsafe(struct ieee802154_dev *dev, struct sk_buff *skb, u8 lqi)
+{
+	struct mac802154_priv *priv = mac802154_to_priv(dev);
+	struct rx_work *work;
+
+	if (!skb)
+		return;
+
+	work = kzalloc(sizeof(struct rx_work), GFP_ATOMIC);
+	if (!work)
+		return;
+
+	INIT_WORK(&work->work, mac802154_rx_worker);
+	work->skb = skb;
+	work->dev = dev;
+	work->lqi = lqi;
+
+	queue_work(priv->dev_workqueue, &work->work);
+}
+EXPORT_SYMBOL(ieee802154_rx_irqsafe);
