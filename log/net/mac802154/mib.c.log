commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 73f94fbf8785..81666e1d779d 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -1,15 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright 2007-2012 Siemens AG
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  * Written by:
  * Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
  * Sergey Lapin <slapin@ossfans.org>

commit c947f7e1e31a708f5a4ea8c1a627bec578cd9223
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri May 22 17:43:54 2015 +0200

    mac802154: remove mib lock
    
    This patch removes the mib lock. The new locking mechanism is to protect
    the mib values with the rtnl lock. Note that this isn't always necessary
    if we have an interface up the most mib values are readonly (e.g.
    address settings). With this behaviour we can remove locking in
    hotpath like frame parsing completely. It depends on context if we need
    to hold the rtnl lock or not, this makes the callbacks of
    ieee802154_mlme_ops unnecessary because these callbacks hols always the
    locks.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 00a62de9cc23..73f94fbf8785 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -26,56 +26,6 @@
 #include "ieee802154_i.h"
 #include "driver-ops.h"
 
-void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-
-	BUG_ON(dev->type != ARPHRD_IEEE802154);
-
-	spin_lock_bh(&sdata->mib_lock);
-	sdata->wpan_dev.short_addr = val;
-	spin_unlock_bh(&sdata->mib_lock);
-}
-
-__le16 mac802154_dev_get_short_addr(const struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	__le16 ret;
-
-	BUG_ON(dev->type != ARPHRD_IEEE802154);
-
-	spin_lock_bh(&sdata->mib_lock);
-	ret = sdata->wpan_dev.short_addr;
-	spin_unlock_bh(&sdata->mib_lock);
-
-	return ret;
-}
-
-__le16 mac802154_dev_get_pan_id(const struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	__le16 ret;
-
-	BUG_ON(dev->type != ARPHRD_IEEE802154);
-
-	spin_lock_bh(&sdata->mib_lock);
-	ret = sdata->wpan_dev.pan_id;
-	spin_unlock_bh(&sdata->mib_lock);
-
-	return ret;
-}
-
-void mac802154_dev_set_pan_id(struct net_device *dev, __le16 val)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-
-	BUG_ON(dev->type != ARPHRD_IEEE802154);
-
-	spin_lock_bh(&sdata->mib_lock);
-	sdata->wpan_dev.pan_id = val;
-	spin_unlock_bh(&sdata->mib_lock);
-}
-
 void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);

commit 344f8c119df742f2bf7098cf8fc326351f583249
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri May 22 17:43:53 2015 +0200

    mac802154: use atomic ops for sequence incrementation
    
    This patch will use atomic operations for sequence number incrementation
    while MAC header generation. Upper layers like af_802154 or 6LoWPAN
    could call this function in a parallel context while generating 802.15.4
    MAC header before queuing into wpan interfaces transmit queue.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 033dfc7755c6..00a62de9cc23 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -76,15 +76,6 @@ void mac802154_dev_set_pan_id(struct net_device *dev, __le16 val)
 	spin_unlock_bh(&sdata->mib_lock);
 }
 
-u8 mac802154_dev_get_dsn(const struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-
-	BUG_ON(dev->type != ARPHRD_IEEE802154);
-
-	return sdata->wpan_dev.dsn++;
-}
-
 void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);

commit 4a3a8c0c3a613e481bea931f0d65dc4a7efaa9b9
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri May 22 17:43:52 2015 +0200

    mac802154: remove pib lock
    
    This patch removes the pib lock which is now replaced by rtnl lock. The
    new interface already use the rtnl lock only. Nevertheless this patch
    will fix issues while using new and old interface at the same time.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 5cf019a57fd7..033dfc7755c6 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -91,16 +91,16 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 	struct ieee802154_local *local = sdata->local;
 	int res;
 
+	ASSERT_RTNL();
+
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
 	res = drv_set_channel(local, page, chan);
 	if (res) {
 		pr_debug("set_channel failed\n");
 	} else {
-		mutex_lock(&local->phy->pib_lock);
 		local->phy->current_channel = chan;
 		local->phy->current_page = page;
-		mutex_unlock(&local->phy->pib_lock);
 	}
 }
 

commit a4dc132196ba776d3c34ef91b484e7fa19c0f994
Author: Stefan Schmidt <s.schmidt@samsung.com>
Date:   Thu Dec 4 11:52:00 2014 +0100

    net/mac802154: Remove extra blank lines.
    
    Signed-off-by: Stefan Schmidt <s.schmidt@samsung.com>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 3596b29ead6b..5cf019a57fd7 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -104,7 +104,6 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 	}
 }
 
-
 int mac802154_get_params(struct net_device *dev,
 			 struct ieee802154_llsec_params *params)
 {
@@ -136,7 +135,6 @@ int mac802154_set_params(struct net_device *dev,
 	return res;
 }
 
-
 int mac802154_add_key(struct net_device *dev,
 		      const struct ieee802154_llsec_key_id *id,
 		      const struct ieee802154_llsec_key *key)
@@ -168,7 +166,6 @@ int mac802154_del_key(struct net_device *dev,
 	return res;
 }
 
-
 int mac802154_add_dev(struct net_device *dev,
 		      const struct ieee802154_llsec_device *llsec_dev)
 {
@@ -198,7 +195,6 @@ int mac802154_del_dev(struct net_device *dev, __le64 dev_addr)
 	return res;
 }
 
-
 int mac802154_add_devkey(struct net_device *dev,
 			 __le64 device_addr,
 			 const struct ieee802154_llsec_device_key *key)
@@ -231,7 +227,6 @@ int mac802154_del_devkey(struct net_device *dev,
 	return res;
 }
 
-
 int mac802154_add_seclevel(struct net_device *dev,
 			   const struct ieee802154_llsec_seclevel *sl)
 {
@@ -262,7 +257,6 @@ int mac802154_del_seclevel(struct net_device *dev,
 	return res;
 }
 
-
 void mac802154_lock_table(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);

commit 863e88f255dac0657e57d5f1a1f95ee8733f8c13
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:45 2014 +0100

    mac802154: move mac pib attributes into wpan_dev
    
    This patch moves all mac pib attributes into the wpan_dev struct.
    Furthermore we can easier access these attributes over the netdev
    802154_ptr pointer. Currently this is only possible over a complicated
    callback structure in mac802154 because subif data structure is
    accessable inside mac802154 only.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 6fa749154baf..3596b29ead6b 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -33,7 +33,7 @@ void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
 	spin_lock_bh(&sdata->mib_lock);
-	sdata->short_addr = val;
+	sdata->wpan_dev.short_addr = val;
 	spin_unlock_bh(&sdata->mib_lock);
 }
 
@@ -45,7 +45,7 @@ __le16 mac802154_dev_get_short_addr(const struct net_device *dev)
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
 	spin_lock_bh(&sdata->mib_lock);
-	ret = sdata->short_addr;
+	ret = sdata->wpan_dev.short_addr;
 	spin_unlock_bh(&sdata->mib_lock);
 
 	return ret;
@@ -59,7 +59,7 @@ __le16 mac802154_dev_get_pan_id(const struct net_device *dev)
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
 	spin_lock_bh(&sdata->mib_lock);
-	ret = sdata->pan_id;
+	ret = sdata->wpan_dev.pan_id;
 	spin_unlock_bh(&sdata->mib_lock);
 
 	return ret;
@@ -72,7 +72,7 @@ void mac802154_dev_set_pan_id(struct net_device *dev, __le16 val)
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
 	spin_lock_bh(&sdata->mib_lock);
-	sdata->pan_id = val;
+	sdata->wpan_dev.pan_id = val;
 	spin_unlock_bh(&sdata->mib_lock);
 }
 
@@ -82,7 +82,7 @@ u8 mac802154_dev_get_dsn(const struct net_device *dev)
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	return sdata->dsn++;
+	return sdata->wpan_dev.dsn++;
 }
 
 void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)

commit 50c79075019e7b952327cfebf0681548573fd8e5
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:43 2014 +0100

    mac802154: set panid address filter on ifup
    
    This patch moves the setting of hardware panid address filtering
    inside of interface up instead doing it it directly inside of netlink
    interface. The netlink call which can only be called when netif isn't
    running sets only the necessary panid value in sdata. After an
    interface up the address filter will be set with this value.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 755befde6a17..6fa749154baf 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -26,51 +26,6 @@
 #include "ieee802154_i.h"
 #include "driver-ops.h"
 
-struct hw_addr_filt_notify_work {
-	struct work_struct work;
-	struct net_device *dev;
-	unsigned long changed;
-};
-
-static struct ieee802154_local *mac802154_slave_get_priv(struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-
-	BUG_ON(dev->type != ARPHRD_IEEE802154);
-
-	return sdata->local;
-}
-
-static void hw_addr_notify(struct work_struct *work)
-{
-	struct hw_addr_filt_notify_work *nw = container_of(work,
-			struct hw_addr_filt_notify_work, work);
-	struct ieee802154_local *local = mac802154_slave_get_priv(nw->dev);
-	int res;
-
-	res = local->ops->set_hw_addr_filt(&local->hw, &local->hw.hw_filt,
-					   nw->changed);
-	if (res)
-		pr_debug("failed changed mask %lx\n", nw->changed);
-
-	kfree(nw);
-}
-
-static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	struct hw_addr_filt_notify_work *work;
-
-	work = kzalloc(sizeof(*work), GFP_ATOMIC);
-	if (!work)
-		return;
-
-	INIT_WORK(&work->work, hw_addr_notify);
-	work->dev = dev;
-	work->changed = changed;
-	queue_work(sdata->local->workqueue, &work->work);
-}
-
 void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
@@ -119,12 +74,6 @@ void mac802154_dev_set_pan_id(struct net_device *dev, __le16 val)
 	spin_lock_bh(&sdata->mib_lock);
 	sdata->pan_id = val;
 	spin_unlock_bh(&sdata->mib_lock);
-
-	if ((sdata->local->ops->set_hw_addr_filt) &&
-	    (sdata->local->hw.hw_filt.pan_id != sdata->pan_id)) {
-		sdata->local->hw.hw_filt.pan_id = sdata->pan_id;
-		set_hw_addr_filt(dev, IEEE802154_AFILT_PANID_CHANGED);
-	}
 }
 
 u8 mac802154_dev_get_dsn(const struct net_device *dev)

commit 78b4bad16ec41e1d3d5575ff9aca29aab2f831bc
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:42 2014 +0100

    mac802154: set short address filter on ifup
    
    This patch moves the setting of hardware short address filtering
    inside of interface up instead doing it it directly inside of netlink
    interface. The netlink call which can only be called when netif isn't
    running sets only the necessary short_addr value in sdata. After an
    interface up the address filter will be set with this value.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index cfd4f657a24e..755befde6a17 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -80,12 +80,6 @@ void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
 	spin_lock_bh(&sdata->mib_lock);
 	sdata->short_addr = val;
 	spin_unlock_bh(&sdata->mib_lock);
-
-	if ((sdata->local->ops->set_hw_addr_filt) &&
-	    (sdata->local->hw.hw_filt.short_addr != sdata->short_addr)) {
-		sdata->local->hw.hw_filt.short_addr = sdata->short_addr;
-		set_hw_addr_filt(dev, IEEE802154_AFILT_SADDR_CHANGED);
-	}
 }
 
 __le16 mac802154_dev_get_short_addr(const struct net_device *dev)

commit 776e59de46b5db368e1bd0a4ec5c4feaa740a3d1
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:41 2014 +0100

    mac802154: set extended address filter on ifup
    
    This patch moves the setting of hardware extended address filtering
    inside of interface up instead doing it directly inside of netlink interface.
    Also we don't need to set the sdata extended attribute in netlink. This
    is already done by ndo_set_mac_address of net_device_ops.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 0184fced2f62..cfd4f657a24e 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -102,20 +102,6 @@ __le16 mac802154_dev_get_short_addr(const struct net_device *dev)
 	return ret;
 }
 
-void mac802154_dev_set_ieee_addr(struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	struct ieee802154_local *local = sdata->local;
-
-	sdata->extended_addr = ieee802154_devaddr_from_raw(dev->dev_addr);
-
-	if (local->ops->set_hw_addr_filt &&
-	    local->hw.hw_filt.ieee_addr != sdata->extended_addr) {
-		local->hw.hw_filt.ieee_addr = sdata->extended_addr;
-		set_hw_addr_filt(dev, IEEE802154_AFILT_IEEEADDR_CHANGED);
-	}
-}
-
 __le16 mac802154_dev_get_pan_id(const struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);

commit 12439a53560097bc8e42cf14967717d14588dddd
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:29 2014 +0100

    mac802154: remove channel attributes from sdata
    
    These channel attributes was part of "channel context switch while xmit"
    which was removed by commit dc67c6b30f36d57b70b70547a30e7a8432540c6f
    ("mac802154: tx: remove xmit channel context switch"). This patch
    removes these unnecessary variables and use the current_page and
    current_channel by wpan_phy struct now.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 3fbc217dbdcc..0184fced2f62 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -26,11 +26,6 @@
 #include "ieee802154_i.h"
 #include "driver-ops.h"
 
-struct phy_chan_notify_work {
-	struct work_struct work;
-	struct net_device *dev;
-};
-
 struct hw_addr_filt_notify_work {
 	struct work_struct work;
 	struct net_device *dev;
@@ -161,54 +156,22 @@ u8 mac802154_dev_get_dsn(const struct net_device *dev)
 	return sdata->dsn++;
 }
 
-static void phy_chan_notify(struct work_struct *work)
-{
-	struct phy_chan_notify_work *nw = container_of(work,
-					  struct phy_chan_notify_work, work);
-	struct net_device *dev = nw->dev;
-	struct ieee802154_local *local = mac802154_slave_get_priv(dev);
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	int res;
-
-	mutex_lock(&sdata->local->phy->pib_lock);
-	res = drv_set_channel(local, sdata->page, sdata->chan);
-	if (res) {
-		pr_debug("set_channel failed\n");
-	} else {
-		sdata->local->phy->current_channel = sdata->chan;
-		sdata->local->phy->current_page = sdata->page;
-	}
-	mutex_unlock(&sdata->local->phy->pib_lock);
-
-	kfree(nw);
-}
-
 void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	struct phy_chan_notify_work *work;
+	struct ieee802154_local *local = sdata->local;
+	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	spin_lock_bh(&sdata->mib_lock);
-	sdata->page = page;
-	sdata->chan = chan;
-	spin_unlock_bh(&sdata->mib_lock);
-
-	mutex_lock(&sdata->local->phy->pib_lock);
-	if (sdata->local->phy->current_channel != sdata->chan ||
-	    sdata->local->phy->current_page != sdata->page) {
-		mutex_unlock(&sdata->local->phy->pib_lock);
-
-		work = kzalloc(sizeof(*work), GFP_ATOMIC);
-		if (!work)
-			return;
-
-		INIT_WORK(&work->work, phy_chan_notify);
-		work->dev = dev;
-		queue_work(sdata->local->workqueue, &work->work);
+	res = drv_set_channel(local, page, chan);
+	if (res) {
+		pr_debug("set_channel failed\n");
 	} else {
-		mutex_unlock(&sdata->local->phy->pib_lock);
+		mutex_lock(&local->phy->pib_lock);
+		local->phy->current_channel = chan;
+		local->phy->current_page = page;
+		mutex_unlock(&local->phy->pib_lock);
 	}
 }
 

commit 59cb300f2b2ce1fc46696deb9a7bd066cd53a65a
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:21 2014 +0100

    mac802154: use driver-ops function wrappers
    
    This patch replaces all directly called driver ops by previous
    introduced driver-ops function wrappers.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 16baff1ea313..3fbc217dbdcc 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -24,6 +24,7 @@
 #include <net/cfg802154.h>
 
 #include "ieee802154_i.h"
+#include "driver-ops.h"
 
 struct phy_chan_notify_work {
 	struct work_struct work;
@@ -170,7 +171,7 @@ static void phy_chan_notify(struct work_struct *work)
 	int res;
 
 	mutex_lock(&sdata->local->phy->pib_lock);
-	res = local->ops->set_channel(&local->hw, sdata->page, sdata->chan);
+	res = drv_set_channel(local, sdata->page, sdata->chan);
 	if (res) {
 		pr_debug("set_channel failed\n");
 	} else {

commit f773054254b6aa0196063658c7e247e7c6eacbeb
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:41 2014 +0200

    mac802154: rename dev_workqueue to workqueue
    
    Small rename to use the name workqueue than dev_workqueue. To bring the
    same naming convention like wireless into 802.15.4.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index d7a25048a8af..16baff1ea313 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -72,7 +72,7 @@ static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
 	INIT_WORK(&work->work, hw_addr_notify);
 	work->dev = dev;
 	work->changed = changed;
-	queue_work(sdata->local->dev_workqueue, &work->work);
+	queue_work(sdata->local->workqueue, &work->work);
 }
 
 void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
@@ -205,7 +205,7 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 
 		INIT_WORK(&work->work, phy_chan_notify);
 		work->dev = dev;
-		queue_work(sdata->local->dev_workqueue, &work->work);
+		queue_work(sdata->local->workqueue, &work->work);
 	} else {
 		mutex_unlock(&sdata->local->phy->pib_lock);
 	}

commit 59d19cd70cd38afd2d9bf2e3b48c3a5bbb630b5a
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:40 2014 +0200

    mac802154: introduce IEEE802154_DEV_TO_SUB_IF
    
    This function adds a wrapper to call netdev_priv to getting the sdata
    attribute. This is similar like the IEEE80211_DEV_TO_SUB_IF function
    inside wireless stack implementation.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 1ffca5c6b0b9..d7a25048a8af 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -38,7 +38,7 @@ struct hw_addr_filt_notify_work {
 
 static struct ieee802154_local *mac802154_slave_get_priv(struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
@@ -62,7 +62,7 @@ static void hw_addr_notify(struct work_struct *work)
 
 static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct hw_addr_filt_notify_work *work;
 
 	work = kzalloc(sizeof(*work), GFP_ATOMIC);
@@ -77,7 +77,7 @@ static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
 
 void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
@@ -94,7 +94,7 @@ void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
 
 __le16 mac802154_dev_get_short_addr(const struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	__le16 ret;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -108,7 +108,7 @@ __le16 mac802154_dev_get_short_addr(const struct net_device *dev)
 
 void mac802154_dev_set_ieee_addr(struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct ieee802154_local *local = sdata->local;
 
 	sdata->extended_addr = ieee802154_devaddr_from_raw(dev->dev_addr);
@@ -122,7 +122,7 @@ void mac802154_dev_set_ieee_addr(struct net_device *dev)
 
 __le16 mac802154_dev_get_pan_id(const struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	__le16 ret;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -136,7 +136,7 @@ __le16 mac802154_dev_get_pan_id(const struct net_device *dev)
 
 void mac802154_dev_set_pan_id(struct net_device *dev, __le16 val)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
@@ -153,7 +153,7 @@ void mac802154_dev_set_pan_id(struct net_device *dev, __le16 val)
 
 u8 mac802154_dev_get_dsn(const struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
@@ -164,8 +164,9 @@ static void phy_chan_notify(struct work_struct *work)
 {
 	struct phy_chan_notify_work *nw = container_of(work,
 					  struct phy_chan_notify_work, work);
-	struct ieee802154_local *local = mac802154_slave_get_priv(nw->dev);
-	struct ieee802154_sub_if_data *sdata = netdev_priv(nw->dev);
+	struct net_device *dev = nw->dev;
+	struct ieee802154_local *local = mac802154_slave_get_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int res;
 
 	mutex_lock(&sdata->local->phy->pib_lock);
@@ -183,7 +184,7 @@ static void phy_chan_notify(struct work_struct *work)
 
 void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct phy_chan_notify_work *work;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -214,7 +215,7 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 int mac802154_get_params(struct net_device *dev,
 			 struct ieee802154_llsec_params *params)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -230,7 +231,7 @@ int mac802154_set_params(struct net_device *dev,
 			 const struct ieee802154_llsec_params *params,
 			 int changed)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -247,7 +248,7 @@ int mac802154_add_key(struct net_device *dev,
 		      const struct ieee802154_llsec_key_id *id,
 		      const struct ieee802154_llsec_key *key)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -262,7 +263,7 @@ int mac802154_add_key(struct net_device *dev,
 int mac802154_del_key(struct net_device *dev,
 		      const struct ieee802154_llsec_key_id *id)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -278,7 +279,7 @@ int mac802154_del_key(struct net_device *dev,
 int mac802154_add_dev(struct net_device *dev,
 		      const struct ieee802154_llsec_device *llsec_dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -292,7 +293,7 @@ int mac802154_add_dev(struct net_device *dev,
 
 int mac802154_del_dev(struct net_device *dev, __le64 dev_addr)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -309,7 +310,7 @@ int mac802154_add_devkey(struct net_device *dev,
 			 __le64 device_addr,
 			 const struct ieee802154_llsec_device_key *key)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -325,7 +326,7 @@ int mac802154_del_devkey(struct net_device *dev,
 			 __le64 device_addr,
 			 const struct ieee802154_llsec_device_key *key)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -341,7 +342,7 @@ int mac802154_del_devkey(struct net_device *dev,
 int mac802154_add_seclevel(struct net_device *dev,
 			   const struct ieee802154_llsec_seclevel *sl)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -356,7 +357,7 @@ int mac802154_add_seclevel(struct net_device *dev,
 int mac802154_del_seclevel(struct net_device *dev,
 			   const struct ieee802154_llsec_seclevel *sl)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
@@ -371,7 +372,7 @@ int mac802154_del_seclevel(struct net_device *dev,
 
 void mac802154_lock_table(struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
@@ -381,7 +382,7 @@ void mac802154_lock_table(struct net_device *dev)
 void mac802154_get_table(struct net_device *dev,
 			 struct ieee802154_llsec_table **t)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
@@ -390,7 +391,7 @@ void mac802154_get_table(struct net_device *dev,
 
 void mac802154_unlock_table(struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 

commit 04e850fe06312a9f570fcc7dbd0f141c012df404
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:37 2014 +0200

    mac802154: rename hw subif_data variable to local
    
    This patch renames the hw attribute in struct ieee802154_sub_if_data to
    local. This avoid confusing with the struct ieee802154_hw hw; inside of
    local struct.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index ef05b3bd9a63..1ffca5c6b0b9 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -42,7 +42,7 @@ static struct ieee802154_local *mac802154_slave_get_priv(struct net_device *dev)
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	return sdata->hw;
+	return sdata->local;
 }
 
 static void hw_addr_notify(struct work_struct *work)
@@ -72,7 +72,7 @@ static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
 	INIT_WORK(&work->work, hw_addr_notify);
 	work->dev = dev;
 	work->changed = changed;
-	queue_work(sdata->hw->dev_workqueue, &work->work);
+	queue_work(sdata->local->dev_workqueue, &work->work);
 }
 
 void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
@@ -85,9 +85,9 @@ void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
 	sdata->short_addr = val;
 	spin_unlock_bh(&sdata->mib_lock);
 
-	if ((sdata->hw->ops->set_hw_addr_filt) &&
-	    (sdata->hw->hw.hw_filt.short_addr != sdata->short_addr)) {
-		sdata->hw->hw.hw_filt.short_addr = sdata->short_addr;
+	if ((sdata->local->ops->set_hw_addr_filt) &&
+	    (sdata->local->hw.hw_filt.short_addr != sdata->short_addr)) {
+		sdata->local->hw.hw_filt.short_addr = sdata->short_addr;
 		set_hw_addr_filt(dev, IEEE802154_AFILT_SADDR_CHANGED);
 	}
 }
@@ -109,7 +109,7 @@ __le16 mac802154_dev_get_short_addr(const struct net_device *dev)
 void mac802154_dev_set_ieee_addr(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
-	struct ieee802154_local *local = sdata->hw;
+	struct ieee802154_local *local = sdata->local;
 
 	sdata->extended_addr = ieee802154_devaddr_from_raw(dev->dev_addr);
 
@@ -144,9 +144,9 @@ void mac802154_dev_set_pan_id(struct net_device *dev, __le16 val)
 	sdata->pan_id = val;
 	spin_unlock_bh(&sdata->mib_lock);
 
-	if ((sdata->hw->ops->set_hw_addr_filt) &&
-	    (sdata->hw->hw.hw_filt.pan_id != sdata->pan_id)) {
-		sdata->hw->hw.hw_filt.pan_id = sdata->pan_id;
+	if ((sdata->local->ops->set_hw_addr_filt) &&
+	    (sdata->local->hw.hw_filt.pan_id != sdata->pan_id)) {
+		sdata->local->hw.hw_filt.pan_id = sdata->pan_id;
 		set_hw_addr_filt(dev, IEEE802154_AFILT_PANID_CHANGED);
 	}
 }
@@ -168,15 +168,15 @@ static void phy_chan_notify(struct work_struct *work)
 	struct ieee802154_sub_if_data *sdata = netdev_priv(nw->dev);
 	int res;
 
-	mutex_lock(&sdata->hw->phy->pib_lock);
+	mutex_lock(&sdata->local->phy->pib_lock);
 	res = local->ops->set_channel(&local->hw, sdata->page, sdata->chan);
 	if (res) {
 		pr_debug("set_channel failed\n");
 	} else {
-		sdata->hw->phy->current_channel = sdata->chan;
-		sdata->hw->phy->current_page = sdata->page;
+		sdata->local->phy->current_channel = sdata->chan;
+		sdata->local->phy->current_page = sdata->page;
 	}
-	mutex_unlock(&sdata->hw->phy->pib_lock);
+	mutex_unlock(&sdata->local->phy->pib_lock);
 
 	kfree(nw);
 }
@@ -193,10 +193,10 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 	sdata->chan = chan;
 	spin_unlock_bh(&sdata->mib_lock);
 
-	mutex_lock(&sdata->hw->phy->pib_lock);
-	if (sdata->hw->phy->current_channel != sdata->chan ||
-	    sdata->hw->phy->current_page != sdata->page) {
-		mutex_unlock(&sdata->hw->phy->pib_lock);
+	mutex_lock(&sdata->local->phy->pib_lock);
+	if (sdata->local->phy->current_channel != sdata->chan ||
+	    sdata->local->phy->current_page != sdata->page) {
+		mutex_unlock(&sdata->local->phy->pib_lock);
 
 		work = kzalloc(sizeof(*work), GFP_ATOMIC);
 		if (!work)
@@ -204,9 +204,9 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 
 		INIT_WORK(&work->work, phy_chan_notify);
 		work->dev = dev;
-		queue_work(sdata->hw->dev_workqueue, &work->work);
+		queue_work(sdata->local->dev_workqueue, &work->work);
 	} else {
-		mutex_unlock(&sdata->hw->phy->pib_lock);
+		mutex_unlock(&sdata->local->phy->pib_lock);
 	}
 }
 

commit 036562f9c4d942f2fbc77ae3215309bde340546f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:36 2014 +0200

    mac802154: rename mac802154_sub_if_data
    
    Like wireless this structure should named ieee802154_sub_if_data and not
    mac802154_sub_if_data. This patch renames the struct and variables to
    sdata instead priv sometimes.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 5d9592a128db..ef05b3bd9a63 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -38,11 +38,11 @@ struct hw_addr_filt_notify_work {
 
 static struct ieee802154_local *mac802154_slave_get_priv(struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	return priv->hw;
+	return sdata->hw;
 }
 
 static void hw_addr_notify(struct work_struct *work)
@@ -62,7 +62,7 @@ static void hw_addr_notify(struct work_struct *work)
 
 static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	struct hw_addr_filt_notify_work *work;
 
 	work = kzalloc(sizeof(*work), GFP_ATOMIC);
@@ -72,92 +72,92 @@ static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
 	INIT_WORK(&work->work, hw_addr_notify);
 	work->dev = dev;
 	work->changed = changed;
-	queue_work(priv->hw->dev_workqueue, &work->work);
+	queue_work(sdata->hw->dev_workqueue, &work->work);
 }
 
 void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	spin_lock_bh(&priv->mib_lock);
-	priv->short_addr = val;
-	spin_unlock_bh(&priv->mib_lock);
+	spin_lock_bh(&sdata->mib_lock);
+	sdata->short_addr = val;
+	spin_unlock_bh(&sdata->mib_lock);
 
-	if ((priv->hw->ops->set_hw_addr_filt) &&
-	    (priv->hw->hw.hw_filt.short_addr != priv->short_addr)) {
-		priv->hw->hw.hw_filt.short_addr = priv->short_addr;
+	if ((sdata->hw->ops->set_hw_addr_filt) &&
+	    (sdata->hw->hw.hw_filt.short_addr != sdata->short_addr)) {
+		sdata->hw->hw.hw_filt.short_addr = sdata->short_addr;
 		set_hw_addr_filt(dev, IEEE802154_AFILT_SADDR_CHANGED);
 	}
 }
 
 __le16 mac802154_dev_get_short_addr(const struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	__le16 ret;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	spin_lock_bh(&priv->mib_lock);
-	ret = priv->short_addr;
-	spin_unlock_bh(&priv->mib_lock);
+	spin_lock_bh(&sdata->mib_lock);
+	ret = sdata->short_addr;
+	spin_unlock_bh(&sdata->mib_lock);
 
 	return ret;
 }
 
 void mac802154_dev_set_ieee_addr(struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
-	struct ieee802154_local *local = priv->hw;
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_local *local = sdata->hw;
 
-	priv->extended_addr = ieee802154_devaddr_from_raw(dev->dev_addr);
+	sdata->extended_addr = ieee802154_devaddr_from_raw(dev->dev_addr);
 
 	if (local->ops->set_hw_addr_filt &&
-	    local->hw.hw_filt.ieee_addr != priv->extended_addr) {
-		local->hw.hw_filt.ieee_addr = priv->extended_addr;
+	    local->hw.hw_filt.ieee_addr != sdata->extended_addr) {
+		local->hw.hw_filt.ieee_addr = sdata->extended_addr;
 		set_hw_addr_filt(dev, IEEE802154_AFILT_IEEEADDR_CHANGED);
 	}
 }
 
 __le16 mac802154_dev_get_pan_id(const struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	__le16 ret;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	spin_lock_bh(&priv->mib_lock);
-	ret = priv->pan_id;
-	spin_unlock_bh(&priv->mib_lock);
+	spin_lock_bh(&sdata->mib_lock);
+	ret = sdata->pan_id;
+	spin_unlock_bh(&sdata->mib_lock);
 
 	return ret;
 }
 
 void mac802154_dev_set_pan_id(struct net_device *dev, __le16 val)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	spin_lock_bh(&priv->mib_lock);
-	priv->pan_id = val;
-	spin_unlock_bh(&priv->mib_lock);
+	spin_lock_bh(&sdata->mib_lock);
+	sdata->pan_id = val;
+	spin_unlock_bh(&sdata->mib_lock);
 
-	if ((priv->hw->ops->set_hw_addr_filt) &&
-	    (priv->hw->hw.hw_filt.pan_id != priv->pan_id)) {
-		priv->hw->hw.hw_filt.pan_id = priv->pan_id;
+	if ((sdata->hw->ops->set_hw_addr_filt) &&
+	    (sdata->hw->hw.hw_filt.pan_id != sdata->pan_id)) {
+		sdata->hw->hw.hw_filt.pan_id = sdata->pan_id;
 		set_hw_addr_filt(dev, IEEE802154_AFILT_PANID_CHANGED);
 	}
 }
 
 u8 mac802154_dev_get_dsn(const struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	return priv->dsn++;
+	return sdata->dsn++;
 }
 
 static void phy_chan_notify(struct work_struct *work)
@@ -165,38 +165,38 @@ static void phy_chan_notify(struct work_struct *work)
 	struct phy_chan_notify_work *nw = container_of(work,
 					  struct phy_chan_notify_work, work);
 	struct ieee802154_local *local = mac802154_slave_get_priv(nw->dev);
-	struct mac802154_sub_if_data *priv = netdev_priv(nw->dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(nw->dev);
 	int res;
 
-	mutex_lock(&priv->hw->phy->pib_lock);
-	res = local->ops->set_channel(&local->hw, priv->page, priv->chan);
+	mutex_lock(&sdata->hw->phy->pib_lock);
+	res = local->ops->set_channel(&local->hw, sdata->page, sdata->chan);
 	if (res) {
 		pr_debug("set_channel failed\n");
 	} else {
-		priv->hw->phy->current_channel = priv->chan;
-		priv->hw->phy->current_page = priv->page;
+		sdata->hw->phy->current_channel = sdata->chan;
+		sdata->hw->phy->current_page = sdata->page;
 	}
-	mutex_unlock(&priv->hw->phy->pib_lock);
+	mutex_unlock(&sdata->hw->phy->pib_lock);
 
 	kfree(nw);
 }
 
 void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	struct phy_chan_notify_work *work;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	spin_lock_bh(&priv->mib_lock);
-	priv->page = page;
-	priv->chan = chan;
-	spin_unlock_bh(&priv->mib_lock);
+	spin_lock_bh(&sdata->mib_lock);
+	sdata->page = page;
+	sdata->chan = chan;
+	spin_unlock_bh(&sdata->mib_lock);
 
-	mutex_lock(&priv->hw->phy->pib_lock);
-	if (priv->hw->phy->current_channel != priv->chan ||
-	    priv->hw->phy->current_page != priv->page) {
-		mutex_unlock(&priv->hw->phy->pib_lock);
+	mutex_lock(&sdata->hw->phy->pib_lock);
+	if (sdata->hw->phy->current_channel != sdata->chan ||
+	    sdata->hw->phy->current_page != sdata->page) {
+		mutex_unlock(&sdata->hw->phy->pib_lock);
 
 		work = kzalloc(sizeof(*work), GFP_ATOMIC);
 		if (!work)
@@ -204,9 +204,9 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 
 		INIT_WORK(&work->work, phy_chan_notify);
 		work->dev = dev;
-		queue_work(priv->hw->dev_workqueue, &work->work);
+		queue_work(sdata->hw->dev_workqueue, &work->work);
 	} else {
-		mutex_unlock(&priv->hw->phy->pib_lock);
+		mutex_unlock(&sdata->hw->phy->pib_lock);
 	}
 }
 
@@ -214,14 +214,14 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 int mac802154_get_params(struct net_device *dev,
 			 struct ieee802154_llsec_params *params)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_lock(&priv->sec_mtx);
-	res = mac802154_llsec_get_params(&priv->sec, params);
-	mutex_unlock(&priv->sec_mtx);
+	mutex_lock(&sdata->sec_mtx);
+	res = mac802154_llsec_get_params(&sdata->sec, params);
+	mutex_unlock(&sdata->sec_mtx);
 
 	return res;
 }
@@ -230,14 +230,14 @@ int mac802154_set_params(struct net_device *dev,
 			 const struct ieee802154_llsec_params *params,
 			 int changed)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_lock(&priv->sec_mtx);
-	res = mac802154_llsec_set_params(&priv->sec, params, changed);
-	mutex_unlock(&priv->sec_mtx);
+	mutex_lock(&sdata->sec_mtx);
+	res = mac802154_llsec_set_params(&sdata->sec, params, changed);
+	mutex_unlock(&sdata->sec_mtx);
 
 	return res;
 }
@@ -247,14 +247,14 @@ int mac802154_add_key(struct net_device *dev,
 		      const struct ieee802154_llsec_key_id *id,
 		      const struct ieee802154_llsec_key *key)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_lock(&priv->sec_mtx);
-	res = mac802154_llsec_key_add(&priv->sec, id, key);
-	mutex_unlock(&priv->sec_mtx);
+	mutex_lock(&sdata->sec_mtx);
+	res = mac802154_llsec_key_add(&sdata->sec, id, key);
+	mutex_unlock(&sdata->sec_mtx);
 
 	return res;
 }
@@ -262,14 +262,14 @@ int mac802154_add_key(struct net_device *dev,
 int mac802154_del_key(struct net_device *dev,
 		      const struct ieee802154_llsec_key_id *id)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_lock(&priv->sec_mtx);
-	res = mac802154_llsec_key_del(&priv->sec, id);
-	mutex_unlock(&priv->sec_mtx);
+	mutex_lock(&sdata->sec_mtx);
+	res = mac802154_llsec_key_del(&sdata->sec, id);
+	mutex_unlock(&sdata->sec_mtx);
 
 	return res;
 }
@@ -278,28 +278,28 @@ int mac802154_del_key(struct net_device *dev,
 int mac802154_add_dev(struct net_device *dev,
 		      const struct ieee802154_llsec_device *llsec_dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_lock(&priv->sec_mtx);
-	res = mac802154_llsec_dev_add(&priv->sec, llsec_dev);
-	mutex_unlock(&priv->sec_mtx);
+	mutex_lock(&sdata->sec_mtx);
+	res = mac802154_llsec_dev_add(&sdata->sec, llsec_dev);
+	mutex_unlock(&sdata->sec_mtx);
 
 	return res;
 }
 
 int mac802154_del_dev(struct net_device *dev, __le64 dev_addr)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_lock(&priv->sec_mtx);
-	res = mac802154_llsec_dev_del(&priv->sec, dev_addr);
-	mutex_unlock(&priv->sec_mtx);
+	mutex_lock(&sdata->sec_mtx);
+	res = mac802154_llsec_dev_del(&sdata->sec, dev_addr);
+	mutex_unlock(&sdata->sec_mtx);
 
 	return res;
 }
@@ -309,14 +309,14 @@ int mac802154_add_devkey(struct net_device *dev,
 			 __le64 device_addr,
 			 const struct ieee802154_llsec_device_key *key)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_lock(&priv->sec_mtx);
-	res = mac802154_llsec_devkey_add(&priv->sec, device_addr, key);
-	mutex_unlock(&priv->sec_mtx);
+	mutex_lock(&sdata->sec_mtx);
+	res = mac802154_llsec_devkey_add(&sdata->sec, device_addr, key);
+	mutex_unlock(&sdata->sec_mtx);
 
 	return res;
 }
@@ -325,14 +325,14 @@ int mac802154_del_devkey(struct net_device *dev,
 			 __le64 device_addr,
 			 const struct ieee802154_llsec_device_key *key)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_lock(&priv->sec_mtx);
-	res = mac802154_llsec_devkey_del(&priv->sec, device_addr, key);
-	mutex_unlock(&priv->sec_mtx);
+	mutex_lock(&sdata->sec_mtx);
+	res = mac802154_llsec_devkey_del(&sdata->sec, device_addr, key);
+	mutex_unlock(&sdata->sec_mtx);
 
 	return res;
 }
@@ -341,14 +341,14 @@ int mac802154_del_devkey(struct net_device *dev,
 int mac802154_add_seclevel(struct net_device *dev,
 			   const struct ieee802154_llsec_seclevel *sl)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_lock(&priv->sec_mtx);
-	res = mac802154_llsec_seclevel_add(&priv->sec, sl);
-	mutex_unlock(&priv->sec_mtx);
+	mutex_lock(&sdata->sec_mtx);
+	res = mac802154_llsec_seclevel_add(&sdata->sec, sl);
+	mutex_unlock(&sdata->sec_mtx);
 
 	return res;
 }
@@ -356,14 +356,14 @@ int mac802154_add_seclevel(struct net_device *dev,
 int mac802154_del_seclevel(struct net_device *dev,
 			   const struct ieee802154_llsec_seclevel *sl)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	int res;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_lock(&priv->sec_mtx);
-	res = mac802154_llsec_seclevel_del(&priv->sec, sl);
-	mutex_unlock(&priv->sec_mtx);
+	mutex_lock(&sdata->sec_mtx);
+	res = mac802154_llsec_seclevel_del(&sdata->sec, sl);
+	mutex_unlock(&sdata->sec_mtx);
 
 	return res;
 }
@@ -371,28 +371,28 @@ int mac802154_del_seclevel(struct net_device *dev,
 
 void mac802154_lock_table(struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_lock(&priv->sec_mtx);
+	mutex_lock(&sdata->sec_mtx);
 }
 
 void mac802154_get_table(struct net_device *dev,
 			 struct ieee802154_llsec_table **t)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	*t = &priv->sec.table;
+	*t = &sdata->sec.table;
 }
 
 void mac802154_unlock_table(struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
-	mutex_unlock(&priv->sec_mtx);
+	mutex_unlock(&sdata->sec_mtx);
 }

commit a5e1ec538f54c4cb8ec9ce30867cfbab57225280
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:35 2014 +0200

    mac802154: rename mac802154_priv to ieee802154_local
    
    This patch rename the mac802154_priv to ieee802154_local. The
    mac802154_priv structure is like ieee80211_local and so we name it
    ieee802154_local.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 7c9467216199..5d9592a128db 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -36,7 +36,7 @@ struct hw_addr_filt_notify_work {
 	unsigned long changed;
 };
 
-static struct mac802154_priv *mac802154_slave_get_priv(struct net_device *dev)
+static struct ieee802154_local *mac802154_slave_get_priv(struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);
 
@@ -49,12 +49,11 @@ static void hw_addr_notify(struct work_struct *work)
 {
 	struct hw_addr_filt_notify_work *nw = container_of(work,
 			struct hw_addr_filt_notify_work, work);
-	struct mac802154_priv *hw = mac802154_slave_get_priv(nw->dev);
+	struct ieee802154_local *local = mac802154_slave_get_priv(nw->dev);
 	int res;
 
-	res = hw->ops->set_hw_addr_filt(&hw->hw,
-					&hw->hw.hw_filt,
-					nw->changed);
+	res = local->ops->set_hw_addr_filt(&local->hw, &local->hw.hw_filt,
+					   nw->changed);
 	if (res)
 		pr_debug("failed changed mask %lx\n", nw->changed);
 
@@ -110,13 +109,13 @@ __le16 mac802154_dev_get_short_addr(const struct net_device *dev)
 void mac802154_dev_set_ieee_addr(struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);
-	struct mac802154_priv *mac = priv->hw;
+	struct ieee802154_local *local = priv->hw;
 
 	priv->extended_addr = ieee802154_devaddr_from_raw(dev->dev_addr);
 
-	if (mac->ops->set_hw_addr_filt &&
-	    mac->hw.hw_filt.ieee_addr != priv->extended_addr) {
-		mac->hw.hw_filt.ieee_addr = priv->extended_addr;
+	if (local->ops->set_hw_addr_filt &&
+	    local->hw.hw_filt.ieee_addr != priv->extended_addr) {
+		local->hw.hw_filt.ieee_addr = priv->extended_addr;
 		set_hw_addr_filt(dev, IEEE802154_AFILT_IEEEADDR_CHANGED);
 	}
 }
@@ -165,12 +164,12 @@ static void phy_chan_notify(struct work_struct *work)
 {
 	struct phy_chan_notify_work *nw = container_of(work,
 					  struct phy_chan_notify_work, work);
-	struct mac802154_priv *hw = mac802154_slave_get_priv(nw->dev);
+	struct ieee802154_local *local = mac802154_slave_get_priv(nw->dev);
 	struct mac802154_sub_if_data *priv = netdev_priv(nw->dev);
 	int res;
 
 	mutex_lock(&priv->hw->phy->pib_lock);
-	res = hw->ops->set_channel(&hw->hw, priv->page, priv->chan);
+	res = local->ops->set_channel(&local->hw, priv->page, priv->chan);
 	if (res) {
 		pr_debug("set_channel failed\n");
 	} else {

commit 5ad60d36993596f7b3b958500f9c66c5338cd855
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:41:02 2014 +0200

    ieee802154: move wpan-phy.h to cfg802154.h
    
    The wpan-phy header contains the wpan_phy struct information. Later this
    header will be have similar function like cfg80211 header. The cfg80211
    header contains the wiphy struct which is identically the wpan_phy
    struct inside 802.15.4 subsystem.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 91cd3b260243..7c9467216199 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -21,7 +21,7 @@
 
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
-#include <net/wpan-phy.h>
+#include <net/cfg802154.h>
 
 #include "ieee802154_i.h"
 

commit 0f1556bc2b152fc5d2a6b929c579748ec90c55d0
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:41:00 2014 +0200

    mac802154: move mac802154.h to ieee802154_i.h
    
    This patch moves the mac802154.h internal header to ieee802154_i.h like
    the wireless stack ieee80211_i.h file. This avoids confusing with the
    not internal header include/net/mac802154.h header. Additional we get
    the same naming conversion like mac80211 for this file.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 3ee604292238..91cd3b260243 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -23,7 +23,7 @@
 #include <net/ieee802154_netdev.h>
 #include <net/wpan-phy.h>
 
-#include "mac802154.h"
+#include "ieee802154_i.h"
 
 struct phy_chan_notify_work {
 	struct work_struct work;

commit 57205c14ca9147c1907556f77998cf82624d9fd6
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 05:25:09 2014 +0200

    mac802154: fix typo IEEE802515 to IEEE802154
    
    This patch fixs a typo in address filter defines from IEEE802515 to
    IEEE802154.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index d7e5df872be7..3ee604292238 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -89,7 +89,7 @@ void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
 	if ((priv->hw->ops->set_hw_addr_filt) &&
 	    (priv->hw->hw.hw_filt.short_addr != priv->short_addr)) {
 		priv->hw->hw.hw_filt.short_addr = priv->short_addr;
-		set_hw_addr_filt(dev, IEEE802515_AFILT_SADDR_CHANGED);
+		set_hw_addr_filt(dev, IEEE802154_AFILT_SADDR_CHANGED);
 	}
 }
 
@@ -117,7 +117,7 @@ void mac802154_dev_set_ieee_addr(struct net_device *dev)
 	if (mac->ops->set_hw_addr_filt &&
 	    mac->hw.hw_filt.ieee_addr != priv->extended_addr) {
 		mac->hw.hw_filt.ieee_addr = priv->extended_addr;
-		set_hw_addr_filt(dev, IEEE802515_AFILT_IEEEADDR_CHANGED);
+		set_hw_addr_filt(dev, IEEE802154_AFILT_IEEEADDR_CHANGED);
 	}
 }
 
@@ -148,7 +148,7 @@ void mac802154_dev_set_pan_id(struct net_device *dev, __le16 val)
 	if ((priv->hw->ops->set_hw_addr_filt) &&
 	    (priv->hw->hw.hw_filt.pan_id != priv->pan_id)) {
 		priv->hw->hw.hw_filt.pan_id = priv->pan_id;
-		set_hw_addr_filt(dev, IEEE802515_AFILT_PANID_CHANGED);
+		set_hw_addr_filt(dev, IEEE802154_AFILT_PANID_CHANGED);
 	}
 }
 

commit b3020f0a35fc431f7acf3fba9a5b7376d79932e5
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 05:25:07 2014 +0200

    ieee802154: mac802154: remove FSF address
    
    This patch removes the FSF address in files which belongs to ieee802154
    and mac802154.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 868a040fd422..d7e5df872be7 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -10,10 +10,6 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
  * Written by:
  * Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
  * Sergey Lapin <slapin@ossfans.org>

commit 4710d806fcb825156e0a7b3a81104915c5e90f5d
Author: Varka Bhadram <varkabhadram@gmail.com>
Date:   Wed Jul 2 09:01:09 2014 +0530

    6lowpan: mac802154: fix coding style issues
    
    This patch fixed the coding style issues reported by checkpatch.pl
    
    following issues fixed:
            CHECK: Alignment should match open parenthesis
            WARNING: line over 80 characters
            CHECK: Blank lines aren't necessary before a close brace '}'
            WARNING: networking block comments don't use an empty /* line, use /* Comment...
            WARNING: Missing a blank line after declarations
            WARNING: networking block comments start with * on subsequent lines
            CHECK: braces {} should be used on all arms of this statement
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Tested-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 15aa2f2b03a7..868a040fd422 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -175,9 +175,9 @@ static void phy_chan_notify(struct work_struct *work)
 
 	mutex_lock(&priv->hw->phy->pib_lock);
 	res = hw->ops->set_channel(&hw->hw, priv->page, priv->chan);
-	if (res)
+	if (res) {
 		pr_debug("set_channel failed\n");
-	else {
+	} else {
 		priv->hw->phy->current_channel = priv->chan;
 		priv->hw->phy->current_page = priv->page;
 	}
@@ -210,8 +210,9 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 		INIT_WORK(&work->work, phy_chan_notify);
 		work->dev = dev;
 		queue_work(priv->hw->dev_workqueue, &work->work);
-	} else
+	} else {
 		mutex_unlock(&priv->hw->phy->pib_lock);
+	}
 }
 
 

commit 29e023746a672e4ff702ca9dc63a06145fd8f4b0
Author: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
Date:   Fri May 16 17:46:42 2014 +0200

    mac802154: add llsec configuration functions
    
    Signed-off-by: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index f0991f2344d4..15aa2f2b03a7 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -213,3 +213,190 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 	} else
 		mutex_unlock(&priv->hw->phy->pib_lock);
 }
+
+
+int mac802154_get_params(struct net_device *dev,
+			 struct ieee802154_llsec_params *params)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	int res;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_lock(&priv->sec_mtx);
+	res = mac802154_llsec_get_params(&priv->sec, params);
+	mutex_unlock(&priv->sec_mtx);
+
+	return res;
+}
+
+int mac802154_set_params(struct net_device *dev,
+			 const struct ieee802154_llsec_params *params,
+			 int changed)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	int res;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_lock(&priv->sec_mtx);
+	res = mac802154_llsec_set_params(&priv->sec, params, changed);
+	mutex_unlock(&priv->sec_mtx);
+
+	return res;
+}
+
+
+int mac802154_add_key(struct net_device *dev,
+		      const struct ieee802154_llsec_key_id *id,
+		      const struct ieee802154_llsec_key *key)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	int res;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_lock(&priv->sec_mtx);
+	res = mac802154_llsec_key_add(&priv->sec, id, key);
+	mutex_unlock(&priv->sec_mtx);
+
+	return res;
+}
+
+int mac802154_del_key(struct net_device *dev,
+		      const struct ieee802154_llsec_key_id *id)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	int res;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_lock(&priv->sec_mtx);
+	res = mac802154_llsec_key_del(&priv->sec, id);
+	mutex_unlock(&priv->sec_mtx);
+
+	return res;
+}
+
+
+int mac802154_add_dev(struct net_device *dev,
+		      const struct ieee802154_llsec_device *llsec_dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	int res;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_lock(&priv->sec_mtx);
+	res = mac802154_llsec_dev_add(&priv->sec, llsec_dev);
+	mutex_unlock(&priv->sec_mtx);
+
+	return res;
+}
+
+int mac802154_del_dev(struct net_device *dev, __le64 dev_addr)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	int res;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_lock(&priv->sec_mtx);
+	res = mac802154_llsec_dev_del(&priv->sec, dev_addr);
+	mutex_unlock(&priv->sec_mtx);
+
+	return res;
+}
+
+
+int mac802154_add_devkey(struct net_device *dev,
+			 __le64 device_addr,
+			 const struct ieee802154_llsec_device_key *key)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	int res;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_lock(&priv->sec_mtx);
+	res = mac802154_llsec_devkey_add(&priv->sec, device_addr, key);
+	mutex_unlock(&priv->sec_mtx);
+
+	return res;
+}
+
+int mac802154_del_devkey(struct net_device *dev,
+			 __le64 device_addr,
+			 const struct ieee802154_llsec_device_key *key)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	int res;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_lock(&priv->sec_mtx);
+	res = mac802154_llsec_devkey_del(&priv->sec, device_addr, key);
+	mutex_unlock(&priv->sec_mtx);
+
+	return res;
+}
+
+
+int mac802154_add_seclevel(struct net_device *dev,
+			   const struct ieee802154_llsec_seclevel *sl)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	int res;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_lock(&priv->sec_mtx);
+	res = mac802154_llsec_seclevel_add(&priv->sec, sl);
+	mutex_unlock(&priv->sec_mtx);
+
+	return res;
+}
+
+int mac802154_del_seclevel(struct net_device *dev,
+			   const struct ieee802154_llsec_seclevel *sl)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	int res;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_lock(&priv->sec_mtx);
+	res = mac802154_llsec_seclevel_del(&priv->sec, sl);
+	mutex_unlock(&priv->sec_mtx);
+
+	return res;
+}
+
+
+void mac802154_lock_table(struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_lock(&priv->sec_mtx);
+}
+
+void mac802154_get_table(struct net_device *dev,
+			 struct ieee802154_llsec_table **t)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	*t = &priv->sec.table;
+}
+
+void mac802154_unlock_table(struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	mutex_unlock(&priv->sec_mtx);
+}

commit 6c6a9855560d3cfa93120f2ab07b8ea0110f953d
Author: Jean Sacren <sakiwit@gmail.com>
Date:   Sat Apr 5 00:29:01 2014 -0600

    mac802154: fix duplicate #include headers
    
    The commit e6278d92005e ("mac802154: use header operations to
    create/parse headers") included the header
    
                    net/ieee802154_netdev.h
    
    which had been included by the commit b70ab2e87f17 ("ieee802154:
    enforce consistent endianness in the 802.15.4 stack"). Fix this
    duplicate #include by deleting the latter one as the required header
    has already been in place.
    
    Signed-off-by: Jean Sacren <sakiwit@gmail.com>
    Cc: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
    Cc: linux-zigbee-devel@lists.sourceforge.net
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 153bd1ddbfbb..f0991f2344d4 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -26,7 +26,6 @@
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
 #include <net/wpan-phy.h>
-#include <net/ieee802154_netdev.h>
 
 #include "mac802154.h"
 

commit e6278d92005e9d6e374f269b4ce39c908a68ad5d
Author: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
Date:   Fri Mar 14 21:24:01 2014 +0100

    mac802154: use header operations to create/parse headers
    
    Use the operations on 802.15.4 header structs introduced in a previous
    patch to create and parse all headers in the mac802154 stack. This patch
    reduces code duplication between different parts of the mac802154 stack
    that needed information from headers, and also fixes a few bugs that
    seem to have gone unnoticed until now:
    
     * 802.15.4 dgram sockets would return a slightly incorrect value for
       the SIOCINQ ioctl
     * mac802154 would not drop frames with the "security enabled" bit set,
       even though it does not support security, in violation of the
       standard
    
    Signed-off-by: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index ba5abdcbd25f..153bd1ddbfbb 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -26,6 +26,7 @@
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
 #include <net/wpan-phy.h>
+#include <net/ieee802154_netdev.h>
 
 #include "mac802154.h"
 
@@ -115,13 +116,12 @@ void mac802154_dev_set_ieee_addr(struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);
 	struct mac802154_priv *mac = priv->hw;
-	__le64 addr;
 
-	addr = ieee802154_devaddr_from_raw(dev->dev_addr);
-	priv->extended_addr = addr;
+	priv->extended_addr = ieee802154_devaddr_from_raw(dev->dev_addr);
 
-	if (mac->ops->set_hw_addr_filt && mac->hw.hw_filt.ieee_addr != addr) {
-		mac->hw.hw_filt.ieee_addr = addr;
+	if (mac->ops->set_hw_addr_filt &&
+	    mac->hw.hw_filt.ieee_addr != priv->extended_addr) {
+		mac->hw.hw_filt.ieee_addr = priv->extended_addr;
 		set_hw_addr_filt(dev, IEEE802515_AFILT_IEEEADDR_CHANGED);
 	}
 }

commit b70ab2e87f17176d18f67ef331064441a032b5f3
Author: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
Date:   Fri Mar 14 21:23:59 2014 +0100

    ieee802154: enforce consistent endianness in the 802.15.4 stack
    
    Enable sparse warnings about endianness, replace the remaining fields
    regarding network operations without explicit endianness annotations
    with such that are annotated, and propagate this through the entire
    stack.
    
    Uses of ieee802154_addr_sa are not changed yet, this patch is only
    concerned with all other fields (such as address filters, operation
    parameters and the likes).
    
    Signed-off-by: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index f48f40c1da1a..ba5abdcbd25f 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -24,6 +24,7 @@
 #include <linux/if_arp.h>
 
 #include <net/mac802154.h>
+#include <net/ieee802154_netdev.h>
 #include <net/wpan-phy.h>
 
 #include "mac802154.h"
@@ -79,7 +80,7 @@ static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
 	queue_work(priv->hw->dev_workqueue, &work->work);
 }
 
-void mac802154_dev_set_short_addr(struct net_device *dev, u16 val)
+void mac802154_dev_set_short_addr(struct net_device *dev, __le16 val)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);
 
@@ -96,10 +97,10 @@ void mac802154_dev_set_short_addr(struct net_device *dev, u16 val)
 	}
 }
 
-u16 mac802154_dev_get_short_addr(const struct net_device *dev)
+__le16 mac802154_dev_get_short_addr(const struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);
-	u16 ret;
+	__le16 ret;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
@@ -114,20 +115,21 @@ void mac802154_dev_set_ieee_addr(struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);
 	struct mac802154_priv *mac = priv->hw;
+	__le64 addr;
 
-	if (mac->ops->set_hw_addr_filt &&
-	    memcmp(mac->hw.hw_filt.ieee_addr,
-		   dev->dev_addr, IEEE802154_ADDR_LEN)) {
-		memcpy(mac->hw.hw_filt.ieee_addr,
-		       dev->dev_addr, IEEE802154_ADDR_LEN);
+	addr = ieee802154_devaddr_from_raw(dev->dev_addr);
+	priv->extended_addr = addr;
+
+	if (mac->ops->set_hw_addr_filt && mac->hw.hw_filt.ieee_addr != addr) {
+		mac->hw.hw_filt.ieee_addr = addr;
 		set_hw_addr_filt(dev, IEEE802515_AFILT_IEEEADDR_CHANGED);
 	}
 }
 
-u16 mac802154_dev_get_pan_id(const struct net_device *dev)
+__le16 mac802154_dev_get_pan_id(const struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);
-	u16 ret;
+	__le16 ret;
 
 	BUG_ON(dev->type != ARPHRD_IEEE802154);
 
@@ -138,7 +140,7 @@ u16 mac802154_dev_get_pan_id(const struct net_device *dev)
 	return ret;
 }
 
-void mac802154_dev_set_pan_id(struct net_device *dev, u16 val)
+void mac802154_dev_set_pan_id(struct net_device *dev, __le16 val)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);
 

commit 2045ceaed4d54e6e698874d008be727ee5b2a01c
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Wed Feb 12 20:51:22 2014 -0800

    net: remove unnecessary return's
    
    One of my pet coding style peeves is the practice of
    adding extra return; at the end of function.
    Kill several instances of this in network code.
    
    I suppose some coccinelle wizardy could do this automatically.
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 8ded97cf1c33..f48f40c1da1a 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -62,8 +62,6 @@ static void hw_addr_notify(struct work_struct *work)
 		pr_debug("failed changed mask %lx\n", nw->changed);
 
 	kfree(nw);
-
-	return;
 }
 
 static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
@@ -79,8 +77,6 @@ static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
 	work->dev = dev;
 	work->changed = changed;
 	queue_work(priv->hw->dev_workqueue, &work->work);
-
-	return;
 }
 
 void mac802154_dev_set_short_addr(struct net_device *dev, u16 val)

commit 9f7f78b479ae06279a85451d456040bbe4eae013
Author: Alan Ott <alan@signal11.us>
Date:   Fri Apr 5 13:03:10 2013 +0000

    mac802154: Keep track of the channel when changed
    
    Two sections checked whether the current channel != the new channel
    without ever setting the current channel variables.
    
    1. net/mac802154/tx.c: Prevent set_channel() from getting called every
    time a packet is sent.
    
    2. net/mac802154/mib.c: Lock (pib_lock) accesses to current_channel and
    current_page and make sure they are updated when the channel has been
    changed.
    
    Signed-off-by: Alan Ott <alan@signal11.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index f03e55f2ebf0..8ded97cf1c33 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -176,9 +176,15 @@ static void phy_chan_notify(struct work_struct *work)
 	struct mac802154_sub_if_data *priv = netdev_priv(nw->dev);
 	int res;
 
+	mutex_lock(&priv->hw->phy->pib_lock);
 	res = hw->ops->set_channel(&hw->hw, priv->page, priv->chan);
 	if (res)
 		pr_debug("set_channel failed\n");
+	else {
+		priv->hw->phy->current_channel = priv->chan;
+		priv->hw->phy->current_page = priv->page;
+	}
+	mutex_unlock(&priv->hw->phy->pib_lock);
 
 	kfree(nw);
 }
@@ -195,8 +201,11 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 	priv->chan = chan;
 	spin_unlock_bh(&priv->mib_lock);
 
+	mutex_lock(&priv->hw->phy->pib_lock);
 	if (priv->hw->phy->current_channel != priv->chan ||
 	    priv->hw->phy->current_page != priv->page) {
+		mutex_unlock(&priv->hw->phy->pib_lock);
+
 		work = kzalloc(sizeof(*work), GFP_ATOMIC);
 		if (!work)
 			return;
@@ -204,5 +213,6 @@ void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
 		INIT_WORK(&work->work, phy_chan_notify);
 		work->dev = dev;
 		queue_work(priv->hw->dev_workqueue, &work->work);
-	}
+	} else
+		mutex_unlock(&priv->hw->phy->pib_lock);
 }

commit 0483546a3de329cad7705d42962edb09a28794c6
Author: Tony Cheneau <tony.cheneau@amnesiak.org>
Date:   Mon Mar 25 17:59:29 2013 +0000

    mac802154: add mac802154_dev_get_dsn()
    
    Bring-over mac802154_dev_get_dsn() function that was present in the
    Linux ZigBee kernel. This function is called by the 6LoWPAN code in
    order to properly set the DSN (Data Sequence Number) value in the IEEE
    802.15.4 frame.
    
    Signed-off-by: Tony Cheneau <tony.cheneau@amnesiak.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index f47781ab0ccc..f03e55f2ebf0 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -159,6 +159,15 @@ void mac802154_dev_set_pan_id(struct net_device *dev, u16 val)
 	}
 }
 
+u8 mac802154_dev_get_dsn(const struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	return priv->dsn++;
+}
+
 static void phy_chan_notify(struct work_struct *work)
 {
 	struct phy_chan_notify_work *nw = container_of(work,

commit 428840424fc54dd2d3f67d3de8b78bb71a479537
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Tue Jul 10 21:22:46 2012 +0000

    mac802154: sparse warnings: make symbols static
    
    Make symbols static to avoid the following warning shown up
    by sparse:
    
        warning: symbol ... was not declared. Should it be static?
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 5c66b8f73f02..f47781ab0ccc 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -39,7 +39,7 @@ struct hw_addr_filt_notify_work {
 	unsigned long changed;
 };
 
-struct mac802154_priv *mac802154_slave_get_priv(struct net_device *dev)
+static struct mac802154_priv *mac802154_slave_get_priv(struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);
 

commit e885a47a474fe53ed7d952af4b6e9a5cf86d9a07
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Tue Jul 10 21:22:44 2012 +0000

    mac802154: add get short address method
    
    Add method to get the device short 802.15.4 address. This call
    needed by ieee802154 layer to satisfy 'iz list' request from
    the user space.
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 380829d84600..5c66b8f73f02 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -100,6 +100,20 @@ void mac802154_dev_set_short_addr(struct net_device *dev, u16 val)
 	}
 }
 
+u16 mac802154_dev_get_short_addr(const struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	u16 ret;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	spin_lock_bh(&priv->mib_lock);
+	ret = priv->short_addr;
+	spin_unlock_bh(&priv->mib_lock);
+
+	return ret;
+}
+
 void mac802154_dev_set_ieee_addr(struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);

commit 66b69d4d7fe3026a4add368b72905b4d7878c320
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Mon Jun 25 23:24:51 2012 +0000

    mac802154: page and channel setter
    
    A new method to set page and channel values for a transceiver
    was added to the MIB.
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index d74503b4302f..380829d84600 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -28,6 +28,11 @@
 
 #include "mac802154.h"
 
+struct phy_chan_notify_work {
+	struct work_struct work;
+	struct net_device *dev;
+};
+
 struct hw_addr_filt_notify_work {
 	struct work_struct work;
 	struct net_device *dev;
@@ -139,3 +144,42 @@ void mac802154_dev_set_pan_id(struct net_device *dev, u16 val)
 		set_hw_addr_filt(dev, IEEE802515_AFILT_PANID_CHANGED);
 	}
 }
+
+static void phy_chan_notify(struct work_struct *work)
+{
+	struct phy_chan_notify_work *nw = container_of(work,
+					  struct phy_chan_notify_work, work);
+	struct mac802154_priv *hw = mac802154_slave_get_priv(nw->dev);
+	struct mac802154_sub_if_data *priv = netdev_priv(nw->dev);
+	int res;
+
+	res = hw->ops->set_channel(&hw->hw, priv->page, priv->chan);
+	if (res)
+		pr_debug("set_channel failed\n");
+
+	kfree(nw);
+}
+
+void mac802154_dev_set_page_channel(struct net_device *dev, u8 page, u8 chan)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct phy_chan_notify_work *work;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	spin_lock_bh(&priv->mib_lock);
+	priv->page = page;
+	priv->chan = chan;
+	spin_unlock_bh(&priv->mib_lock);
+
+	if (priv->hw->phy->current_channel != priv->chan ||
+	    priv->hw->phy->current_page != priv->page) {
+		work = kzalloc(sizeof(*work), GFP_ATOMIC);
+		if (!work)
+			return;
+
+		INIT_WORK(&work->work, phy_chan_notify);
+		work->dev = dev;
+		queue_work(priv->hw->dev_workqueue, &work->work);
+	}
+}

commit 48e44d5057144b4e28615e3e1ce725b2ca887b40
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Mon Jun 25 23:24:50 2012 +0000

    mac802154: short address setter
    
    A method to assign the IEEE802.15.4 short address was added to the
    MIB implementation.
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index 8e772ed30d1c..d74503b4302f 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -78,6 +78,23 @@ static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
 	return;
 }
 
+void mac802154_dev_set_short_addr(struct net_device *dev, u16 val)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	spin_lock_bh(&priv->mib_lock);
+	priv->short_addr = val;
+	spin_unlock_bh(&priv->mib_lock);
+
+	if ((priv->hw->ops->set_hw_addr_filt) &&
+	    (priv->hw->hw.hw_filt.short_addr != priv->short_addr)) {
+		priv->hw->hw.hw_filt.short_addr = priv->short_addr;
+		set_hw_addr_filt(dev, IEEE802515_AFILT_SADDR_CHANGED);
+	}
+}
+
 void mac802154_dev_set_ieee_addr(struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);

commit dcbe4f93f6d220c22c937f4e305171119b87905e
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Mon Jun 25 23:24:49 2012 +0000

    mac802154: set and get PAN id
    
    Two methods intended to get and set the Private Area Network identifier
    were added to the MIB implementation.
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
index ab59821ec729..8e772ed30d1c 100644
--- a/net/mac802154/mib.c
+++ b/net/mac802154/mib.c
@@ -91,3 +91,34 @@ void mac802154_dev_set_ieee_addr(struct net_device *dev)
 		set_hw_addr_filt(dev, IEEE802515_AFILT_IEEEADDR_CHANGED);
 	}
 }
+
+u16 mac802154_dev_get_pan_id(const struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	u16 ret;
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	spin_lock_bh(&priv->mib_lock);
+	ret = priv->pan_id;
+	spin_unlock_bh(&priv->mib_lock);
+
+	return ret;
+}
+
+void mac802154_dev_set_pan_id(struct net_device *dev, u16 val)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	spin_lock_bh(&priv->mib_lock);
+	priv->pan_id = val;
+	spin_unlock_bh(&priv->mib_lock);
+
+	if ((priv->hw->ops->set_hw_addr_filt) &&
+	    (priv->hw->hw.hw_filt.pan_id != priv->pan_id)) {
+		priv->hw->hw.hw_filt.pan_id = priv->pan_id;
+		set_hw_addr_filt(dev, IEEE802515_AFILT_PANID_CHANGED);
+	}
+}

commit ef2486f5538b886ad4f0d1ac0857b518291b48f7
Author: alex.bluesman.smirnov@gmail.com <alex.bluesman.smirnov@gmail.com>
Date:   Tue May 15 20:50:26 2012 +0000

    mac802154: basic mib support
    
    Basic support for IEEE 802.15.4 management information base.
    Current implementation contains a command to set HW address only.
    
    Signed-off-by: Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac802154/mib.c b/net/mac802154/mib.c
new file mode 100644
index 000000000000..ab59821ec729
--- /dev/null
+++ b/net/mac802154/mib.c
@@ -0,0 +1,93 @@
+/*
+ * Copyright 2007-2012 Siemens AG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Written by:
+ * Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
+ * Sergey Lapin <slapin@ossfans.org>
+ * Maxim Gorbachyov <maxim.gorbachev@siemens.com>
+ * Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
+ */
+
+#include <linux/if_arp.h>
+
+#include <net/mac802154.h>
+#include <net/wpan-phy.h>
+
+#include "mac802154.h"
+
+struct hw_addr_filt_notify_work {
+	struct work_struct work;
+	struct net_device *dev;
+	unsigned long changed;
+};
+
+struct mac802154_priv *mac802154_slave_get_priv(struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+
+	BUG_ON(dev->type != ARPHRD_IEEE802154);
+
+	return priv->hw;
+}
+
+static void hw_addr_notify(struct work_struct *work)
+{
+	struct hw_addr_filt_notify_work *nw = container_of(work,
+			struct hw_addr_filt_notify_work, work);
+	struct mac802154_priv *hw = mac802154_slave_get_priv(nw->dev);
+	int res;
+
+	res = hw->ops->set_hw_addr_filt(&hw->hw,
+					&hw->hw.hw_filt,
+					nw->changed);
+	if (res)
+		pr_debug("failed changed mask %lx\n", nw->changed);
+
+	kfree(nw);
+
+	return;
+}
+
+static void set_hw_addr_filt(struct net_device *dev, unsigned long changed)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct hw_addr_filt_notify_work *work;
+
+	work = kzalloc(sizeof(*work), GFP_ATOMIC);
+	if (!work)
+		return;
+
+	INIT_WORK(&work->work, hw_addr_notify);
+	work->dev = dev;
+	work->changed = changed;
+	queue_work(priv->hw->dev_workqueue, &work->work);
+
+	return;
+}
+
+void mac802154_dev_set_ieee_addr(struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct mac802154_priv *mac = priv->hw;
+
+	if (mac->ops->set_hw_addr_filt &&
+	    memcmp(mac->hw.hw_filt.ieee_addr,
+		   dev->dev_addr, IEEE802154_ADDR_LEN)) {
+		memcpy(mac->hw.hw_filt.ieee_addr,
+		       dev->dev_addr, IEEE802154_ADDR_LEN);
+		set_hw_addr_filt(dev, IEEE802515_AFILT_IEEEADDR_CHANGED);
+	}
+}
