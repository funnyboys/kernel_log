commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 87da85ae5a6b..06ea0f8bfd5c 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -1,17 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2007-2012 Siemens AG
  *
  * Written by:
  * Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #include <linux/kernel.h>

commit aef00c15b8c503083a703900a755fdb1cf2436e0
Author: Koen Zandberg <koen@bergzand.net>
Date:   Wed Feb 10 11:49:38 2016 +0100

    mac802154: Fixes kernel oops when unloading a radio driver
    
    Destroying the workqueue before unregistering the net device caused a
    kernel oops
    
    Signed-off-by: Koen Zandberg <koen@bergzand.net>
    Acked-by: Alexander Aring <aar@pengutronix.de>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index e8cab5bb80c6..87da85ae5a6b 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -218,7 +218,6 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 
 	tasklet_kill(&local->tasklet);
 	flush_workqueue(local->workqueue);
-	destroy_workqueue(local->workqueue);
 
 	rtnl_lock();
 
@@ -226,6 +225,7 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 
 	rtnl_unlock();
 
+	destroy_workqueue(local->workqueue);
 	wpan_phy_unregister(local->phy);
 }
 EXPORT_SYMBOL(ieee802154_unregister_hw);

commit 89c7d788f89d58136a2e5596796c298942ee32d6
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Aug 10 21:15:56 2015 +0200

    mac802154: change frame_retries behaviour
    
    This patch changes the default minimum value of frame_retries to 0 and
    changes the frame_retries default value to 3 which is also 802.15.4
    default.
    
    We don't use the frame_retries "-1" value as indicator for no-aret mode
    anymore, instead we checking on the ack request bit inside the 802.15.4
    frame control field. This allows a acknowledge handling per frame. This
    checking is done by transceiver or inside xmit callback of driver layer.
    
    If a transceiver doesn't support ARET handling the transmit
    functionality ignores ack frames then, which isn't well but should not
    effect anything of current functionality.
    
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 9e55431b9a5c..e8cab5bb80c6 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -111,7 +111,7 @@ ieee802154_alloc_hw(size_t priv_data_len, const struct ieee802154_ops *ops)
 	phy->supported.max_minbe = 8;
 	phy->supported.min_maxbe = 3;
 	phy->supported.max_maxbe = 8;
-	phy->supported.min_frame_retries = -1;
+	phy->supported.min_frame_retries = 0;
 	phy->supported.max_frame_retries = 7;
 	phy->supported.max_csma_backoffs = 5;
 	phy->supported.lbt = NL802154_SUPPORTED_BOOL_FALSE;
@@ -177,11 +177,8 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 	}
 
 	if (!(hw->flags & IEEE802154_HW_FRAME_RETRIES)) {
-		/* TODO should be 3, but our default value is -1 which means
-		 * no ARET handling.
-		 */
-		local->phy->supported.min_frame_retries = -1;
-		local->phy->supported.max_frame_retries = -1;
+		local->phy->supported.min_frame_retries = 3;
+		local->phy->supported.max_frame_retries = 3;
 	}
 
 	if (hw->flags & IEEE802154_HW_PROMISCUOUS)

commit c22ff7b4e74d8136a9911d8b8d0f25f9f7c3edc1
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Tue Jul 21 17:44:47 2015 +0300

    mac802154: Fix memory corruption with global deferred transmit state.
    
    When transmitting a packet via a mac802154 driver that can sleep in
    its transmit function, mac802154 defers the call to the driver's
    transmit function to a per-device workqueue.
    
    However, mac802154 uses a single global work_struct for this, which
    means that if you have more than one registered mac802154 interface
    in the system, and you transmit on more than one of them at the same
    time, you'll very easily cause memory corruption.
    
    This patch moves the deferred transmit processing state from global
    variables to struct ieee802154_local, and this seems to fix the memory
    corruption issue.
    
    Signed-off-by: Lennert Buytenhek <buytenh@wantstofly.org>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 91f120845a45..9e55431b9a5c 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -105,6 +105,8 @@ ieee802154_alloc_hw(size_t priv_data_len, const struct ieee802154_ops *ops)
 
 	skb_queue_head_init(&local->skb_queue);
 
+	INIT_WORK(&local->tx_work, ieee802154_xmit_worker);
+
 	/* init supported flags with 802.15.4 default ranges */
 	phy->supported.max_minbe = 8;
 	phy->supported.min_maxbe = 3;

commit d10270ce941ee89afd74076ea3ed8dbef8a0ff25
Author: Varka Bhadram <varkabhadram@gmail.com>
Date:   Tue Jul 7 10:50:43 2015 +0530

    mac802154: fix ieee802154_rx handling
    
    Instead of passing ieee802154_hw pointer to ieee802154_rx,
    we can directly pass the ieee802154_local pointer.
    
    Signed-off-by: Varka Bhadram <varkabhadram@gmail.com>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 4caf04b676d7..91f120845a45 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -40,7 +40,7 @@ static void ieee802154_tasklet_handler(unsigned long data)
 			 * netstack.
 			 */
 			skb->pkt_type = 0;
-			ieee802154_rx(&local->hw, skb);
+			ieee802154_rx(local, skb);
 			break;
 		default:
 			WARN(1, "mac802154: Packet is of unknown type %d\n",

commit 8f451829dd97fb22f03844ca52a49828e2e1d666
Author: Varka Bhadram <varkabhadram@gmail.com>
Date:   Tue Jun 23 11:41:03 2015 +0530

    mac802154: use WARN_ON() macro
    
    This patch will generate the warning if the required driver ops
    were not defined. Also it removes unnecessary debug message.
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 356b346e1ee8..4caf04b676d7 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -58,11 +58,9 @@ ieee802154_alloc_hw(size_t priv_data_len, const struct ieee802154_ops *ops)
 	struct ieee802154_local *local;
 	size_t priv_size;
 
-	if (!ops || !(ops->xmit_async || ops->xmit_sync) || !ops->ed ||
-	    !ops->start || !ops->stop || !ops->set_channel) {
-		pr_err("undefined IEEE802.15.4 device operations\n");
+	if (WARN_ON(!ops || !(ops->xmit_async || ops->xmit_sync) || !ops->ed ||
+		    !ops->start || !ops->stop || !ops->set_channel))
 		return NULL;
-	}
 
 	/* Ensure 32-byte alignment of our private data and hw private data.
 	 * We use the wpan_phy priv data for both our ieee802154_local and for

commit 65318680c97cca15e3678148b3a5acaa33e991ec
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun May 17 21:44:47 2015 +0200

    ieee802154: add iftypes capability
    
    This patch adds capability flags for supported interface types.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index ddcd6ff8d39c..356b346e1ee8 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -116,6 +116,9 @@ ieee802154_alloc_hw(size_t priv_data_len, const struct ieee802154_ops *ops)
 	phy->supported.max_csma_backoffs = 5;
 	phy->supported.lbt = NL802154_SUPPORTED_BOOL_FALSE;
 
+	/* always supported */
+	phy->supported.iftypes = BIT(NL802154_IFTYPE_NODE);
+
 	return &local->hw;
 }
 EXPORT_SYMBOL(ieee802154_alloc_hw);
@@ -181,6 +184,9 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 		local->phy->supported.max_frame_retries = -1;
 	}
 
+	if (hw->flags & IEEE802154_HW_PROMISCUOUS)
+		local->phy->supported.iftypes |= BIT(NL802154_IFTYPE_MONITOR);
+
 	rc = wpan_phy_register(local->phy);
 	if (rc < 0)
 		goto out_wq;

commit fea3318d20776a94afeea0460c6ee9904e60569e
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun May 17 21:44:43 2015 +0200

    ieee802154: add several phy supported handling
    
    This patch adds support for phy supported handling for all other already
    existing handling 802.15.4 functionality. We assume now a fully 802.15.4
    complaint transceiver at phy allocation. If a transceiver can support
    802.15.4 default values only, then the values should be overwirtten by
    values the transceiver supports. If the transceiver doesn't set the
    according hardware flags, we assume the 802.15.4 defaults now which
    cannot be changed.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Suggested-by: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 08cb32dc8fd3..ddcd6ff8d39c 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -107,6 +107,15 @@ ieee802154_alloc_hw(size_t priv_data_len, const struct ieee802154_ops *ops)
 
 	skb_queue_head_init(&local->skb_queue);
 
+	/* init supported flags with 802.15.4 default ranges */
+	phy->supported.max_minbe = 8;
+	phy->supported.min_maxbe = 3;
+	phy->supported.max_maxbe = 8;
+	phy->supported.min_frame_retries = -1;
+	phy->supported.max_frame_retries = 7;
+	phy->supported.max_csma_backoffs = 5;
+	phy->supported.lbt = NL802154_SUPPORTED_BOOL_FALSE;
+
 	return &local->hw;
 }
 EXPORT_SYMBOL(ieee802154_alloc_hw);
@@ -155,6 +164,23 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 
 	ieee802154_setup_wpan_phy_pib(local->phy);
 
+	if (!(hw->flags & IEEE802154_HW_CSMA_PARAMS)) {
+		local->phy->supported.min_csma_backoffs = 4;
+		local->phy->supported.max_csma_backoffs = 4;
+		local->phy->supported.min_maxbe = 5;
+		local->phy->supported.max_maxbe = 5;
+		local->phy->supported.min_minbe = 3;
+		local->phy->supported.max_minbe = 3;
+	}
+
+	if (!(hw->flags & IEEE802154_HW_FRAME_RETRIES)) {
+		/* TODO should be 3, but our default value is -1 which means
+		 * no ARET handling.
+		 */
+		local->phy->supported.min_frame_retries = -1;
+		local->phy->supported.max_frame_retries = -1;
+	}
+
 	rc = wpan_phy_register(local->phy);
 	if (rc < 0)
 		goto out_wq;

commit 0a801445db4cb00bc900fd89b1e5eb7d7b581d7e
Merge: 31ccd0e66d41 89eb6d0677a6
Author: David S. Miller <davem@davemloft.net>
Date:   Sat May 9 15:51:00 2015 -0400

    Merge branch 'for-upstream' of git://git.kernel.org/pub/scm/linux/kernel/git/bluetooth/bluetooth
    
    Johan Hedberg says:
    
    ====================
    Here are a couple of important Bluetooth & mac802154 fixes for 4.1:
    
     - mac802154 fix for crypto algorithm allocation failure checking
     - mac802154 wpan phy leak fix for error code path
     - Fix for not calling Bluetooth shutdown() if interface is not up
    
    Let me know if there are any issues pulling. Thanks.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 5b4a10390460cccf17a9fac739e153d68cf25ef5
Author: Varka Bhadram <varkabhadram@gmail.com>
Date:   Thu Apr 30 17:44:57 2015 +0200

    cfg802154: pass name_assign_type to rdev_add_virtual_intf()
    
    This code is based on commit 6bab2e19c5ffd
    ("cfg80211: pass name_assign_type to rdev_add_virtual_intf()")
    
    This will expose in sysfs whether the ifname of a IEEE-802.15.4
    device is set by userspace or generated by the kernel.
    We are using two types of name_assign_types
     o NET_NAME_ENUM: Default interface name provided by kernel
     o NET_NAME_USER: Interface name provided by user.
    
    Signed-off-by: Varka Bhadram <varkab@cdac.in>
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 8500378c8318..68b9667323ec 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -161,7 +161,8 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 
 	rtnl_lock();
 
-	dev = ieee802154_if_add(local, "wpan%d", NL802154_IFTYPE_NODE,
+	dev = ieee802154_if_add(local, "wpan%d", NET_NAME_ENUM,
+				NL802154_IFTYPE_NODE,
 				cpu_to_le64(0x0000000000000000ULL));
 	if (IS_ERR(dev)) {
 		rtnl_unlock();

commit 2b4d413c3871af0f2ccd466fb6581ed2c2d89438
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Thu Apr 30 17:44:53 2015 +0200

    mac802154: fix ieee802154_register_hw error handling
    
    Currently if ieee802154_if_add failed, we don't unregister the wpan phy
    which was registered before. This patch adds a correct error handling
    for unregister the wpan phy when ieee802154_if_add failed.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 8500378c8318..beece7b7a776 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -166,13 +166,15 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 	if (IS_ERR(dev)) {
 		rtnl_unlock();
 		rc = PTR_ERR(dev);
-		goto out_wq;
+		goto out_phy;
 	}
 
 	rtnl_unlock();
 
 	return 0;
 
+out_phy:
+	wpan_phy_unregister(local->phy);
 out_wq:
 	destroy_workqueue(local->workqueue);
 out:

commit 0e57547eb7f0aa99aba32b50c49dbd722a80d6fb
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Nov 17 08:20:52 2014 +0100

    ieee802154: setting extended address while iface add
    
    This patch adds support for setting an extended address while
    registration a new interface. If ieee802154_is_valid_extended_addr
    getting as parameter and invalid extended address then the perm address
    is fallback. This is useful to make some default handling while for
    example default registration of a wpan interface while phy registration.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index bbb19dd585a0..8500378c8318 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -161,7 +161,8 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 
 	rtnl_lock();
 
-	dev = ieee802154_if_add(local, "wpan%d", NL802154_IFTYPE_NODE);
+	dev = ieee802154_if_add(local, "wpan%d", NL802154_IFTYPE_NODE,
+				cpu_to_le64(0x0000000000000000ULL));
 	if (IS_ERR(dev)) {
 		rtnl_unlock();
 		rc = PTR_ERR(dev);

commit 133d3f31729a62908ab98d0b6562cc1a35d3dc39
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Nov 17 08:20:50 2014 +0100

    mac802154: remove wpan_dev parameter in if_add
    
    This parameter was grabbed from wireless implementation with the
    identically wireless dev struct. We don't need this right now and so we
    remove it. Maybe we will add it later again if we found any real reason
    to have such parameter.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 2e42fc2e430c..bbb19dd585a0 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -161,7 +161,7 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 
 	rtnl_lock();
 
-	dev = ieee802154_if_add(local, "wpan%d", NULL, NL802154_IFTYPE_NODE);
+	dev = ieee802154_if_add(local, "wpan%d", NL802154_IFTYPE_NODE);
 	if (IS_ERR(dev)) {
 		rtnl_unlock();
 		rc = PTR_ERR(dev);

commit 944742a36d784c2a36a141ac10ba5168b0313cec
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Nov 17 08:20:49 2014 +0100

    mac802154: use new nl802154 iftype types
    
    This patch replace the depracted IEEE802154_DEV to the new introduced
    NL802154_IFTYPE_NODE types. There is a backwards compatibility to have
    the identical types for both enum definitions. Also remove some inlcude
    issue with "linux/nl802154.h", because the export nl_policy inside this
    header it was always necessary to have an include of "net/rtnetlink.h"
    before. The reason for this is more complicated. Nevertheless we removed
    this now, because "linux/nl802154.h" is the depracted netlink interface.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 5199f2115ee9..2e42fc2e430c 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -19,7 +19,7 @@
 #include <linux/netdevice.h>
 
 #include <net/netlink.h>
-#include <linux/nl802154.h>
+#include <net/nl802154.h>
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
 #include <net/route.h>
@@ -161,7 +161,7 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 
 	rtnl_lock();
 
-	dev = ieee802154_if_add(local, "wpan%d", NULL, IEEE802154_DEV_WPAN);
+	dev = ieee802154_if_add(local, "wpan%d", NULL, NL802154_IFTYPE_NODE);
 	if (IS_ERR(dev)) {
 		rtnl_unlock();
 		rc = PTR_ERR(dev);

commit cd11d935f2df86b6a619e8721553b1d41633f0fd
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Nov 17 08:20:48 2014 +0100

    mac802154: remove deprecated linux-zigbee info
    
    We don't and we can't name it zigbee anymore. This patch removes
    deprecated information for project website.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 0af1be64e8ad..5199f2115ee9 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -4,8 +4,6 @@
  * Written by:
  * Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
  *
- * Based on the code from 'linux-zigbee.sourceforge.net' project.
- *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation.

commit 61f2dcba9a03d4fd9342f0d6821af0a46c7098e9
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 12 19:51:56 2014 +0100

    mac802154: add interframe spacing time handling
    
    This patch adds a new interframe spacing time handling into mac802154
    layer. Interframe spacing time is a time period between each transmit.
    This patch adds a high resolution timer into mac802154 and starts on
    xmit complete with corresponding interframe spacing expire time if
    ifs_handling is true. We make it variable because it depends if
    interframe spacing time is handled by transceiver or mac802154. At the
    timer complete function we wake the netdev queue again. This avoids
    new frame transmit in range of interframe spacing time.
    
    For synced driver we add no handling of interframe spacing time. This
    is currently a lack of support in all synced xmit drivers. I suppose
    it's working because the latency of workqueue which is needed to call
    spi_sync.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 46c76e005446..0af1be64e8ad 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -125,6 +125,18 @@ void ieee802154_free_hw(struct ieee802154_hw *hw)
 }
 EXPORT_SYMBOL(ieee802154_free_hw);
 
+static void ieee802154_setup_wpan_phy_pib(struct wpan_phy *wpan_phy)
+{
+	/* TODO warn on empty symbol_duration
+	 * Should be done when all drivers sets this value.
+	 */
+
+	wpan_phy->lifs_period = IEEE802154_LIFS_PERIOD *
+				wpan_phy->symbol_duration;
+	wpan_phy->sifs_period = IEEE802154_SIFS_PERIOD *
+				wpan_phy->symbol_duration;
+}
+
 int ieee802154_register_hw(struct ieee802154_hw *hw)
 {
 	struct ieee802154_local *local = hw_to_local(hw);
@@ -138,8 +150,13 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 		goto out;
 	}
 
+	hrtimer_init(&local->ifs_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+	local->ifs_timer.function = ieee802154_xmit_ifs_timer;
+
 	wpan_phy_set_dev(local->phy, local->hw.parent);
 
+	ieee802154_setup_wpan_phy_pib(local->phy);
+
 	rc = wpan_phy_register(local->phy);
 	if (rc < 0)
 		goto out_wq;

commit be4fd8e5d9f5cd3fdc368e32e7957bcb83bcbb8b
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 12 03:36:53 2014 +0100

    mac802154: add ifname change notifier
    
    This patch adds a netdev notifier for interface renaming. We have a name
    attribute inside of subif data struct. This is needed to have always the
    actual netdev name in sdata name attribute.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 40a326402ec1..46c76e005446 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -182,5 +182,20 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 }
 EXPORT_SYMBOL(ieee802154_unregister_hw);
 
+static int __init ieee802154_init(void)
+{
+	return ieee802154_iface_init();
+}
+
+static void __exit ieee802154_exit(void)
+{
+	ieee802154_iface_exit();
+
+	rcu_barrier();
+}
+
+subsys_initcall(ieee802154_init);
+module_exit(ieee802154_exit);
+
 MODULE_DESCRIPTION("IEEE 802.15.4 subsystem");
 MODULE_LICENSE("GPL v2");

commit 912f67aec761ea4d2107ed0bcb5aef01ae1ecd2e
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 12 03:36:52 2014 +0100

    mac802154: change module description
    
    This patch changes the module description like wireless which is IEEE
    802.11 "subsystem" and not "implementation".
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 24e8ca6a669d..40a326402ec1 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -182,5 +182,5 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 }
 EXPORT_SYMBOL(ieee802154_unregister_hw);
 
-MODULE_DESCRIPTION("IEEE 802.15.4 implementation");
+MODULE_DESCRIPTION("IEEE 802.15.4 subsystem");
 MODULE_LICENSE("GPL v2");

commit 6322d50d879c7ad150164cedc64015a7817f7b28
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 12 03:36:51 2014 +0100

    mac802154: add wpan_phy priv id
    
    This patch adds an unique id for an wpan_phy. This behaviour is mostly
    grabbed from wireless stack. This is needed for upcomming patches which
    identify the wpan netdev while NETDEV_CHANGENAME in netdev notify function.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 709dcc5f7f17..24e8ca6a669d 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -92,6 +92,8 @@ ieee802154_alloc_hw(size_t priv_data_len, const struct ieee802154_ops *ops)
 		return NULL;
 	}
 
+	phy->privid = mac802154_wpan_phy_privid;
+
 	local = wpan_phy_priv(phy);
 	local->phy = phy;
 	local->hw.phy = local->phy;

commit 592dfbfc72f5352437c883aa11ab579d10cdb595
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 12 03:36:48 2014 +0100

    mac820154: move interface unregistration into iface
    
    This patch move the iface unregistration into iface.c file to have
    a behaviour which is similar like mac80211. Also iface handling should
    be inside iface.c file only.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 234084d26906..709dcc5f7f17 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -165,7 +165,6 @@ EXPORT_SYMBOL(ieee802154_register_hw);
 void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 {
 	struct ieee802154_local *local = hw_to_local(hw);
-	struct ieee802154_sub_if_data *sdata, *next;
 
 	tasklet_kill(&local->tasklet);
 	flush_workqueue(local->workqueue);
@@ -173,13 +172,7 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 
 	rtnl_lock();
 
-	list_for_each_entry_safe(sdata, next, &local->interfaces, list) {
-		mutex_lock(&sdata->local->iflist_mtx);
-		list_del(&sdata->list);
-		mutex_unlock(&sdata->local->iflist_mtx);
-
-		unregister_netdevice(sdata->dev);
-	}
+	ieee802154_remove_interfaces(local);
 
 	rtnl_unlock();
 

commit f601379fa113906b8bf4389a62002def283519c9
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:47 2014 +0100

    ieee802154: rename wpan_phy_alloc
    
    This patch renames the wpan_phy_alloc function to wpan_phy_new. This
    naming convention is like wireless and "wiphy_new" function.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 7d0ff7fd2cd4..234084d26906 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -86,7 +86,7 @@ ieee802154_alloc_hw(size_t priv_data_len, const struct ieee802154_ops *ops)
 
 	priv_size = ALIGN(sizeof(*local), NETDEV_ALIGN) + priv_data_len;
 
-	phy = wpan_phy_alloc(&mac802154_config_ops, priv_size);
+	phy = wpan_phy_new(&mac802154_config_ops, priv_size);
 	if (!phy) {
 		pr_err("failure to allocate master IEEE802.15.4 device\n");
 		return NULL;

commit e4962a14435e15c0c070e8aa1b010454c9292c02
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:19 2014 +0100

    mac802154: add default interface registration
    
    This patch adds a default interface registration for a wpan interface
    type. Currently the 802.15.4 subsystem need to call userspace tools to
    add an interface. This patch is like mac80211 handling for registration
    a station interface type by default.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index a371eb5fa053..7d0ff7fd2cd4 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -126,6 +126,7 @@ EXPORT_SYMBOL(ieee802154_free_hw);
 int ieee802154_register_hw(struct ieee802154_hw *hw)
 {
 	struct ieee802154_local *local = hw_to_local(hw);
+	struct net_device *dev;
 	int rc = -ENOSYS;
 
 	local->workqueue =
@@ -141,6 +142,17 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 	if (rc < 0)
 		goto out_wq;
 
+	rtnl_lock();
+
+	dev = ieee802154_if_add(local, "wpan%d", NULL, IEEE802154_DEV_WPAN);
+	if (IS_ERR(dev)) {
+		rtnl_unlock();
+		rc = PTR_ERR(dev);
+		goto out_wq;
+	}
+
+	rtnl_unlock();
+
 	return 0;
 
 out_wq:

commit 986a8abfc51e66c96f9d39529a6ff0443fcd2591
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:15 2014 +0100

    mac802154: move interface add handling in iface
    
    This patch moves and renames the mac802154_add_iface and
    mac802154_netdev_register functions into iface.c. The function
    mac802154_add_iface is renamed to ieee802154_if_add which is a similar naming
    convention like mac80211.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 333d33daec6e..a371eb5fa053 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -30,73 +30,6 @@
 #include "ieee802154_i.h"
 #include "cfg.h"
 
-static int
-mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	struct ieee802154_local *local;
-	int err;
-
-	local = wpan_phy_priv(phy);
-
-	sdata->dev = dev;
-	sdata->local = local;
-
-	dev->needed_headroom = local->hw.extra_tx_headroom;
-
-	SET_NETDEV_DEV(dev, &local->phy->dev);
-
-	err = register_netdev(dev);
-	if (err < 0)
-		return err;
-
-	rtnl_lock();
-	mutex_lock(&local->iflist_mtx);
-	list_add_tail_rcu(&sdata->list, &local->interfaces);
-	mutex_unlock(&local->iflist_mtx);
-	rtnl_unlock();
-
-	return 0;
-}
-
-struct net_device *
-mac802154_add_iface(struct wpan_phy *phy, const char *name, int type)
-{
-	struct net_device *dev;
-	int err = -ENOMEM;
-
-	switch (type) {
-	case IEEE802154_DEV_MONITOR:
-		dev = alloc_netdev(sizeof(struct ieee802154_sub_if_data),
-				   name, NET_NAME_UNKNOWN,
-				   mac802154_monitor_setup);
-		break;
-	case IEEE802154_DEV_WPAN:
-		dev = alloc_netdev(sizeof(struct ieee802154_sub_if_data),
-				   name, NET_NAME_UNKNOWN,
-				   mac802154_wpan_setup);
-		break;
-	default:
-		dev = NULL;
-		err = -EINVAL;
-		break;
-	}
-	if (!dev)
-		goto err;
-
-	err = mac802154_netdev_register(phy, dev);
-	if (err)
-		goto err_free;
-
-	dev_hold(dev); /* we return an incremented device refcount */
-	return dev;
-
-err_free:
-	free_netdev(dev);
-err:
-	return ERR_PTR(err);
-}
-
 static void ieee802154_tasklet_handler(unsigned long data)
 {
 	struct ieee802154_local *local = (struct ieee802154_local *)data;

commit b210b18747cb511bb71f6a49c97e8d38f639b435
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:14 2014 +0100

    mac802154: move interface del handling in iface
    
    This patch moves and rename the mac802154_del_iface function into
    iface.c and rename the function to ieee802154_if_remove which is a similar
    naming convention like mac80211.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index b34ddbf43c3d..333d33daec6e 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -59,22 +59,6 @@ mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 	return 0;
 }
 
-void mac802154_del_iface(struct wpan_phy *phy, struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-
-	ASSERT_RTNL();
-
-	BUG_ON(sdata->local->phy != phy);
-
-	mutex_lock(&sdata->local->iflist_mtx);
-	list_del_rcu(&sdata->list);
-	mutex_unlock(&sdata->local->iflist_mtx);
-
-	synchronize_rcu();
-	unregister_netdevice(sdata->dev);
-}
-
 struct net_device *
 mac802154_add_iface(struct wpan_phy *phy, const char *name, int type)
 {

commit 4a9a816a4f8c79260446811bdf80615b36539949
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:38 2014 +0100

    cfg802154: convert deprecated iface add and del
    
    This patch removes the wpan_phy callbacks for add and del an interface
    on a phy. Instead we introduce deprecated cfg802154 callbacks for this.
    Furthermore we introduce a new netlink interface nl802154 which use
    different callbacks. The deprecated function is to have a backwards
    compatibility with the current netlink interface.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 785abb1aafb4..b34ddbf43c3d 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -59,8 +59,7 @@ mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 	return 0;
 }
 
-static void
-mac802154_del_iface(struct wpan_phy *phy, struct net_device *dev)
+void mac802154_del_iface(struct wpan_phy *phy, struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
@@ -76,7 +75,7 @@ mac802154_del_iface(struct wpan_phy *phy, struct net_device *dev)
 	unregister_netdevice(sdata->dev);
 }
 
-static struct net_device *
+struct net_device *
 mac802154_add_iface(struct wpan_phy *phy, const char *name, int type)
 {
 	struct net_device *dev;
@@ -221,9 +220,6 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 
 	wpan_phy_set_dev(local->phy, local->hw.parent);
 
-	local->phy->add_iface = mac802154_add_iface;
-	local->phy->del_iface = mac802154_del_iface;
-
 	rc = wpan_phy_register(local->phy);
 	if (rc < 0)
 		goto out_wq;

commit 1201cd22fd1f4579a888c0f7abc65627d5962f29
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:36 2014 +0100

    mac802154: introduce mac802154_config_ops
    
    This patch introduces mac802154_config_ops struct. Like wireless this
    struct should be the only one interface between ieee802154 to mac802154
    or possible HardMAC drivers.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index ebc2bb123cfe..785abb1aafb4 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -28,6 +28,7 @@
 #include <net/cfg802154.h>
 
 #include "ieee802154_i.h"
+#include "cfg.h"
 
 static int
 mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
@@ -169,7 +170,7 @@ ieee802154_alloc_hw(size_t priv_data_len, const struct ieee802154_ops *ops)
 
 	priv_size = ALIGN(sizeof(*local), NETDEV_ALIGN) + priv_data_len;
 
-	phy = wpan_phy_alloc(NULL, priv_size);
+	phy = wpan_phy_alloc(&mac802154_config_ops, priv_size);
 	if (!phy) {
 		pr_err("failure to allocate master IEEE802.15.4 device\n");
 		return NULL;

commit a5dd1d72d868ec9c8f44d60ca29900b6a38321b4
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:35 2014 +0100

    cfg802154: introduce cfg802154_registered_device
    
    This patch introduce the cfg802154_registered_device struct. Like
    cfg80211_registered_device in wireless this should contain similar
    functionality for cfg802154. This patch should not change any behaviour.
    We just adds cfg802154_registered_device as container for wpan_phy struct.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 86e533ed3775..ebc2bb123cfe 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -169,7 +169,7 @@ ieee802154_alloc_hw(size_t priv_data_len, const struct ieee802154_ops *ops)
 
 	priv_size = ALIGN(sizeof(*local), NETDEV_ALIGN) + priv_data_len;
 
-	phy = wpan_phy_alloc(priv_size);
+	phy = wpan_phy_alloc(NULL, priv_size);
 	if (!phy) {
 		pr_err("failure to allocate master IEEE802.15.4 device\n");
 		return NULL;

commit 55a2d0651762eb6f70d48ff94d21bc5718d5e47d
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Oct 29 21:34:28 2014 +0100

    mac802154: main: remove unnecessary include
    
    This patch removes an unnecessary include of driver-ops header file.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 21dcc56930d1..86e533ed3775 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -28,7 +28,6 @@
 #include <net/cfg802154.h>
 
 #include "ieee802154_i.h"
-#include "driver-ops.h"
 
 static int
 mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)

commit e363eca386d0c28d8c6c4f176e1fa48b09a75315
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:26 2014 +0100

    mac802154: move local started handling
    
    This patch removes the current handling of started boolean. This is
    actually dead code, because mac802154_netdev_register can't never be
    called before ieee802154_register_hw. This means that local->started is
    always be true when mac802154_netdev_register is called. Instead we
    using this now like mac80211 to indicate that an instance of sdata is
    running.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 7458f71c151c..21dcc56930d1 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -46,13 +46,6 @@ mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 
 	SET_NETDEV_DEV(dev, &local->phy->dev);
 
-	mutex_lock(&local->iflist_mtx);
-	if (!local->started) {
-		mutex_unlock(&local->iflist_mtx);
-		return -ENODEV;
-	}
-	mutex_unlock(&local->iflist_mtx);
-
 	err = register_netdev(dev);
 	if (err < 0)
 		return err;
@@ -235,14 +228,6 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 	if (rc < 0)
 		goto out_wq;
 
-	rtnl_lock();
-
-	mutex_lock(&local->iflist_mtx);
-	local->started = MAC802154_DEVICE_RUN;
-	mutex_unlock(&local->iflist_mtx);
-
-	rtnl_unlock();
-
 	return 0;
 
 out_wq:
@@ -263,10 +248,6 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 
 	rtnl_lock();
 
-	mutex_lock(&local->iflist_mtx);
-	local->started = MAC802154_DEVICE_STOPPED;
-	mutex_unlock(&local->iflist_mtx);
-
 	list_for_each_entry_safe(sdata, next, &local->interfaces, list) {
 		mutex_lock(&sdata->local->iflist_mtx);
 		list_del(&sdata->list);

commit 5d65cae4bf6ffe29bba90f621e947922c5fb80db
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:25 2014 +0100

    mac802154: rename running to started
    
    This variable should be handled like ieee80211_local struct of mac80211.
    We rename this variable to started now to have the same name convention.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 9fa9514b3a36..7458f71c151c 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -47,7 +47,7 @@ mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 	SET_NETDEV_DEV(dev, &local->phy->dev);
 
 	mutex_lock(&local->iflist_mtx);
-	if (!local->running) {
+	if (!local->started) {
 		mutex_unlock(&local->iflist_mtx);
 		return -ENODEV;
 	}
@@ -238,7 +238,7 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 	rtnl_lock();
 
 	mutex_lock(&local->iflist_mtx);
-	local->running = MAC802154_DEVICE_RUN;
+	local->started = MAC802154_DEVICE_RUN;
 	mutex_unlock(&local->iflist_mtx);
 
 	rtnl_unlock();
@@ -264,7 +264,7 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 	rtnl_lock();
 
 	mutex_lock(&local->iflist_mtx);
-	local->running = MAC802154_DEVICE_STOPPED;
+	local->started = MAC802154_DEVICE_STOPPED;
 	mutex_unlock(&local->iflist_mtx);
 
 	list_for_each_entry_safe(sdata, next, &local->interfaces, list) {

commit a543c5989d7711d984608f4e12a73218642ca865
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:23 2014 +0100

    mac802154: remove driver ops in wpan-phy
    
    This patch removes the driver ops callbacks inside of wpan_phy struct.
    It was used to check if a phy supports this driver ops call. We do this
    now via hardware flags.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 24ecc09de2a4..9fa9514b3a36 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -121,49 +121,6 @@ mac802154_add_iface(struct wpan_phy *phy, const char *name, int type)
 	return ERR_PTR(err);
 }
 
-static int mac802154_set_txpower(struct wpan_phy *phy, int db)
-{
-	struct ieee802154_local *local = wpan_phy_priv(phy);
-
-	return drv_set_tx_power(local, db);
-}
-
-static int mac802154_set_lbt(struct wpan_phy *phy, bool on)
-{
-	struct ieee802154_local *local = wpan_phy_priv(phy);
-
-	return drv_set_lbt_mode(local, on);
-}
-
-static int mac802154_set_cca_mode(struct wpan_phy *phy, u8 mode)
-{
-	struct ieee802154_local *local = wpan_phy_priv(phy);
-
-	return drv_set_cca_mode(local, mode);
-}
-
-static int mac802154_set_cca_ed_level(struct wpan_phy *phy, s32 level)
-{
-	struct ieee802154_local *local = wpan_phy_priv(phy);
-
-	return drv_set_cca_ed_level(local, level);
-}
-
-static int mac802154_set_csma_params(struct wpan_phy *phy, u8 min_be,
-				     u8 max_be, u8 retries)
-{
-	struct ieee802154_local *local = wpan_phy_priv(phy);
-
-	return drv_set_csma_params(local, min_be, max_be, retries);
-}
-
-static int mac802154_set_frame_retries(struct wpan_phy *phy, s8 retries)
-{
-	struct ieee802154_local *local = wpan_phy_priv(phy);
-
-	return drv_set_max_frame_retries(local, retries);
-}
-
 static void ieee802154_tasklet_handler(unsigned long data)
 {
 	struct ieee802154_local *local = (struct ieee802154_local *)data;
@@ -262,48 +219,6 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 	struct ieee802154_local *local = hw_to_local(hw);
 	int rc = -ENOSYS;
 
-	if (hw->flags & IEEE802154_HW_TXPOWER) {
-		if (!local->ops->set_txpower)
-			goto out;
-
-		local->phy->set_txpower = mac802154_set_txpower;
-	}
-
-	if (hw->flags & IEEE802154_HW_LBT) {
-		if (!local->ops->set_lbt)
-			goto out;
-
-		local->phy->set_lbt = mac802154_set_lbt;
-	}
-
-	if (hw->flags & IEEE802154_HW_CCA_MODE) {
-		if (!local->ops->set_cca_mode)
-			goto out;
-
-		local->phy->set_cca_mode = mac802154_set_cca_mode;
-	}
-
-	if (hw->flags & IEEE802154_HW_CCA_ED_LEVEL) {
-		if (!local->ops->set_cca_ed_level)
-			goto out;
-
-		local->phy->set_cca_ed_level = mac802154_set_cca_ed_level;
-	}
-
-	if (hw->flags & IEEE802154_HW_CSMA_PARAMS) {
-		if (!local->ops->set_csma_params)
-			goto out;
-
-		local->phy->set_csma_params = mac802154_set_csma_params;
-	}
-
-	if (hw->flags & IEEE802154_HW_FRAME_RETRIES) {
-		if (!local->ops->set_frame_retries)
-			goto out;
-
-		local->phy->set_frame_retries = mac802154_set_frame_retries;
-	}
-
 	local->workqueue =
 		create_singlethread_workqueue(wpan_phy_name(local->phy));
 	if (!local->workqueue) {

commit 59cb300f2b2ce1fc46696deb9a7bd066cd53a65a
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:21 2014 +0100

    mac802154: use driver-ops function wrappers
    
    This patch replaces all directly called driver ops by previous
    introduced driver-ops function wrappers.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 632707bc47b9..24ecc09de2a4 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -28,6 +28,7 @@
 #include <net/cfg802154.h>
 
 #include "ieee802154_i.h"
+#include "driver-ops.h"
 
 static int
 mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
@@ -124,28 +125,28 @@ static int mac802154_set_txpower(struct wpan_phy *phy, int db)
 {
 	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return local->ops->set_txpower(&local->hw, db);
+	return drv_set_tx_power(local, db);
 }
 
 static int mac802154_set_lbt(struct wpan_phy *phy, bool on)
 {
 	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return local->ops->set_lbt(&local->hw, on);
+	return drv_set_lbt_mode(local, on);
 }
 
 static int mac802154_set_cca_mode(struct wpan_phy *phy, u8 mode)
 {
 	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return local->ops->set_cca_mode(&local->hw, mode);
+	return drv_set_cca_mode(local, mode);
 }
 
 static int mac802154_set_cca_ed_level(struct wpan_phy *phy, s32 level)
 {
 	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return local->ops->set_cca_ed_level(&local->hw, level);
+	return drv_set_cca_ed_level(local, level);
 }
 
 static int mac802154_set_csma_params(struct wpan_phy *phy, u8 min_be,
@@ -153,14 +154,14 @@ static int mac802154_set_csma_params(struct wpan_phy *phy, u8 min_be,
 {
 	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return local->ops->set_csma_params(&local->hw, min_be, max_be, retries);
+	return drv_set_csma_params(local, min_be, max_be, retries);
 }
 
 static int mac802154_set_frame_retries(struct wpan_phy *phy, s8 retries)
 {
 	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return local->ops->set_frame_retries(&local->hw, retries);
+	return drv_set_max_frame_retries(local, retries);
 }
 
 static void ieee802154_tasklet_handler(unsigned long data)

commit 16301861004e50be9c47113cceca62f56516a9a2
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:18 2014 +0100

    mac802154: declare struct ieee802154_ops as const
    
    The ieee802154_ops structure should be never changed during runtime.
    This patch declare this structure as const to avoid a runtime change.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 2c6d77259822..632707bc47b9 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -187,7 +187,7 @@ static void ieee802154_tasklet_handler(unsigned long data)
 }
 
 struct ieee802154_hw *
-ieee802154_alloc_hw(size_t priv_data_len, struct ieee802154_ops *ops)
+ieee802154_alloc_hw(size_t priv_data_len, const struct ieee802154_ops *ops)
 {
 	struct wpan_phy *phy;
 	struct ieee802154_local *local;

commit 19ec690a431d8ebf3e9d939160dc223ad40d7d63
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:17 2014 +0100

    mac802154: main: move open and close into iface
    
    These functions can be static inside the iface file, because it's not
    used anywhere else. This patch moves these functions into iface file.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index ff0de0f990cb..2c6d77259822 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -29,65 +29,6 @@
 
 #include "ieee802154_i.h"
 
-int mac802154_slave_open(struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	struct ieee802154_sub_if_data *subif;
-	struct ieee802154_local *local = sdata->local;
-	int res = 0;
-
-	ASSERT_RTNL();
-
-	if (sdata->type == IEEE802154_DEV_WPAN) {
-		mutex_lock(&sdata->local->iflist_mtx);
-		list_for_each_entry(subif, &sdata->local->interfaces, list) {
-			if (subif != sdata && subif->type == sdata->type &&
-			    subif->running) {
-				mutex_unlock(&sdata->local->iflist_mtx);
-				return -EBUSY;
-			}
-		}
-		mutex_unlock(&sdata->local->iflist_mtx);
-	}
-
-	mutex_lock(&sdata->local->iflist_mtx);
-	sdata->running = true;
-	mutex_unlock(&sdata->local->iflist_mtx);
-
-	if (local->open_count++ == 0) {
-		res = local->ops->start(&local->hw);
-		WARN_ON(res);
-		if (res)
-			goto err;
-	}
-
-	netif_start_queue(dev);
-	return 0;
-err:
-	sdata->local->open_count--;
-
-	return res;
-}
-
-int mac802154_slave_close(struct net_device *dev)
-{
-	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
-	struct ieee802154_local *local = sdata->local;
-
-	ASSERT_RTNL();
-
-	netif_stop_queue(dev);
-
-	mutex_lock(&sdata->local->iflist_mtx);
-	sdata->running = false;
-	mutex_unlock(&sdata->local->iflist_mtx);
-
-	if (!--local->open_count)
-		local->ops->stop(&local->hw);
-
-	return 0;
-}
-
 static int
 mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 {

commit c5c47e67bcd24638a059b1b5e9ec18c95f8634ca
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Oct 27 17:13:30 2014 +0100

    mac802154: rx: use tasklet instead workqueue
    
    Tasklets have much less overhead than workqueues. This patch also
    removes the heap allocation for the worker on receiving path.
    Like mac80211 we should prefer use a tasklet here instead a workqueue to
    getting fast out of interrupt context when ieee802154_rx_irqsafe is
    called by driver. Like wireless inside the tasklet context we should
    call netif_receive_skb instead netif_rx_ni anymore.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 3c0a824d24ac..ff0de0f990cb 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -222,6 +222,29 @@ static int mac802154_set_frame_retries(struct wpan_phy *phy, s8 retries)
 	return local->ops->set_frame_retries(&local->hw, retries);
 }
 
+static void ieee802154_tasklet_handler(unsigned long data)
+{
+	struct ieee802154_local *local = (struct ieee802154_local *)data;
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&local->skb_queue))) {
+		switch (skb->pkt_type) {
+		case IEEE802154_RX_MSG:
+			/* Clear skb->pkt_type in order to not confuse kernel
+			 * netstack.
+			 */
+			skb->pkt_type = 0;
+			ieee802154_rx(&local->hw, skb);
+			break;
+		default:
+			WARN(1, "mac802154: Packet is of unknown type %d\n",
+			     skb->pkt_type);
+			kfree_skb(skb);
+			break;
+		}
+	}
+}
+
 struct ieee802154_hw *
 ieee802154_alloc_hw(size_t priv_data_len, struct ieee802154_ops *ops)
 {
@@ -270,6 +293,12 @@ ieee802154_alloc_hw(size_t priv_data_len, struct ieee802154_ops *ops)
 	INIT_LIST_HEAD(&local->interfaces);
 	mutex_init(&local->iflist_mtx);
 
+	tasklet_init(&local->tasklet,
+		     ieee802154_tasklet_handler,
+		     (unsigned long)local);
+
+	skb_queue_head_init(&local->skb_queue);
+
 	return &local->hw;
 }
 EXPORT_SYMBOL(ieee802154_alloc_hw);
@@ -371,6 +400,7 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 	struct ieee802154_local *local = hw_to_local(hw);
 	struct ieee802154_sub_if_data *sdata, *next;
 
+	tasklet_kill(&local->tasklet);
 	flush_workqueue(local->workqueue);
 	destroy_workqueue(local->workqueue);
 

commit ed0a5dce0c29f30ee53a87793206156cf38ae70d
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Oct 26 09:37:08 2014 +0100

    mac802154: tx: add support for xmit_async callback
    
    This patch renames the existsing xmit callback to xmit_sync and
    introduces an asynchronous xmit_async function. If ieee802154_ops
    doesn't provide the xmit_async callback, then we have a fallback to
    the xmit_sync callback.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 0e9a6a203f7a..3c0a824d24ac 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -229,8 +229,8 @@ ieee802154_alloc_hw(size_t priv_data_len, struct ieee802154_ops *ops)
 	struct ieee802154_local *local;
 	size_t priv_size;
 
-	if (!ops || !ops->xmit || !ops->ed || !ops->start ||
-	    !ops->stop || !ops->set_channel) {
+	if (!ops || !(ops->xmit_async || ops->xmit_sync) || !ops->ed ||
+	    !ops->start || !ops->stop || !ops->set_channel) {
 		pr_err("undefined IEEE802.15.4 device operations\n");
 		return NULL;
 	}

commit c6f635faf3bca66cf73f6b3319a054959e367b19
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:42 2014 +0200

    mac802154: remove ieee802154_addr from driver_ops
    
    This driver_ops callback function is never used by any driver.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 5ce3184bc674..0e9a6a203f7a 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -61,16 +61,6 @@ int mac802154_slave_open(struct net_device *dev)
 			goto err;
 	}
 
-	if (local->ops->ieee_addr) {
-		__le64 addr = ieee802154_devaddr_from_raw(dev->dev_addr);
-
-		res = local->ops->ieee_addr(&local->hw, addr);
-		WARN_ON(res);
-		if (res)
-			goto err;
-		mac802154_dev_set_ieee_addr(dev);
-	}
-
 	netif_start_queue(dev);
 	return 0;
 err:

commit f773054254b6aa0196063658c7e247e7c6eacbeb
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:41 2014 +0200

    mac802154: rename dev_workqueue to workqueue
    
    Small rename to use the name workqueue than dev_workqueue. To bring the
    same naming convention like wireless into 802.15.4.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index a34006edcb8d..5ce3184bc674 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -343,9 +343,9 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 		local->phy->set_frame_retries = mac802154_set_frame_retries;
 	}
 
-	local->dev_workqueue =
+	local->workqueue =
 		create_singlethread_workqueue(wpan_phy_name(local->phy));
-	if (!local->dev_workqueue) {
+	if (!local->workqueue) {
 		rc = -ENOMEM;
 		goto out;
 	}
@@ -370,7 +370,7 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 	return 0;
 
 out_wq:
-	destroy_workqueue(local->dev_workqueue);
+	destroy_workqueue(local->workqueue);
 out:
 	return rc;
 }
@@ -381,8 +381,8 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 	struct ieee802154_local *local = hw_to_local(hw);
 	struct ieee802154_sub_if_data *sdata, *next;
 
-	flush_workqueue(local->dev_workqueue);
-	destroy_workqueue(local->dev_workqueue);
+	flush_workqueue(local->workqueue);
+	destroy_workqueue(local->workqueue);
 
 	rtnl_lock();
 

commit 59d19cd70cd38afd2d9bf2e3b48c3a5bbb630b5a
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:40 2014 +0200

    mac802154: introduce IEEE802154_DEV_TO_SUB_IF
    
    This function adds a wrapper to call netdev_priv to getting the sdata
    attribute. This is similar like the IEEE80211_DEV_TO_SUB_IF function
    inside wireless stack implementation.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index c7799faf508b..a34006edcb8d 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -31,7 +31,7 @@
 
 int mac802154_slave_open(struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct ieee802154_sub_if_data *subif;
 	struct ieee802154_local *local = sdata->local;
 	int res = 0;
@@ -81,7 +81,7 @@ int mac802154_slave_open(struct net_device *dev)
 
 int mac802154_slave_close(struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct ieee802154_local *local = sdata->local;
 
 	ASSERT_RTNL();
@@ -101,13 +101,12 @@ int mac802154_slave_close(struct net_device *dev)
 static int
 mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata;
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 	struct ieee802154_local *local;
 	int err;
 
 	local = wpan_phy_priv(phy);
 
-	sdata = netdev_priv(dev);
 	sdata->dev = dev;
 	sdata->local = local;
 
@@ -138,12 +137,10 @@ mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 static void
 mac802154_del_iface(struct wpan_phy *phy, struct net_device *dev)
 {
-	struct ieee802154_sub_if_data *sdata;
+	struct ieee802154_sub_if_data *sdata = IEEE802154_DEV_TO_SUB_IF(dev);
 
 	ASSERT_RTNL();
 
-	sdata = netdev_priv(dev);
-
 	BUG_ON(sdata->local->phy != phy);
 
 	mutex_lock(&sdata->local->iflist_mtx);

commit 60741361c3ca229a1dbb18e05d11e97b7ea75d69
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:39 2014 +0200

    mac802154: introduce hw_to_local function
    
    This patch replace the mac802154_to_priv macro with a static inline
    function named hw_to_local. This brings a similar naming convention like
    mac80211 stack.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 34e7e617611a..c7799faf508b 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -289,7 +289,7 @@ EXPORT_SYMBOL(ieee802154_alloc_hw);
 
 void ieee802154_free_hw(struct ieee802154_hw *hw)
 {
-	struct ieee802154_local *local = mac802154_to_priv(hw);
+	struct ieee802154_local *local = hw_to_local(hw);
 
 	BUG_ON(!list_empty(&local->interfaces));
 
@@ -301,7 +301,7 @@ EXPORT_SYMBOL(ieee802154_free_hw);
 
 int ieee802154_register_hw(struct ieee802154_hw *hw)
 {
-	struct ieee802154_local *local = mac802154_to_priv(hw);
+	struct ieee802154_local *local = hw_to_local(hw);
 	int rc = -ENOSYS;
 
 	if (hw->flags & IEEE802154_HW_TXPOWER) {
@@ -381,7 +381,7 @@ EXPORT_SYMBOL(ieee802154_register_hw);
 
 void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 {
-	struct ieee802154_local *local = mac802154_to_priv(hw);
+	struct ieee802154_local *local = hw_to_local(hw);
 	struct ieee802154_sub_if_data *sdata, *next;
 
 	flush_workqueue(local->dev_workqueue);

commit d98be45b3657fc233f5a098279a4e42ab6f0fa4f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:38 2014 +0200

    mac802154: rename sdata slaves and slaves_mtx
    
    This patch renamens the slaves attribute in sdata to interfaces and
    slaves_mtx to iflist_mtx. This is similar like the mac80211 stack naming
    convention.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 9b2644ff6de5..34e7e617611a 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -39,20 +39,20 @@ int mac802154_slave_open(struct net_device *dev)
 	ASSERT_RTNL();
 
 	if (sdata->type == IEEE802154_DEV_WPAN) {
-		mutex_lock(&sdata->local->slaves_mtx);
-		list_for_each_entry(subif, &sdata->local->slaves, list) {
+		mutex_lock(&sdata->local->iflist_mtx);
+		list_for_each_entry(subif, &sdata->local->interfaces, list) {
 			if (subif != sdata && subif->type == sdata->type &&
 			    subif->running) {
-				mutex_unlock(&sdata->local->slaves_mtx);
+				mutex_unlock(&sdata->local->iflist_mtx);
 				return -EBUSY;
 			}
 		}
-		mutex_unlock(&sdata->local->slaves_mtx);
+		mutex_unlock(&sdata->local->iflist_mtx);
 	}
 
-	mutex_lock(&sdata->local->slaves_mtx);
+	mutex_lock(&sdata->local->iflist_mtx);
 	sdata->running = true;
-	mutex_unlock(&sdata->local->slaves_mtx);
+	mutex_unlock(&sdata->local->iflist_mtx);
 
 	if (local->open_count++ == 0) {
 		res = local->ops->start(&local->hw);
@@ -88,9 +88,9 @@ int mac802154_slave_close(struct net_device *dev)
 
 	netif_stop_queue(dev);
 
-	mutex_lock(&sdata->local->slaves_mtx);
+	mutex_lock(&sdata->local->iflist_mtx);
 	sdata->running = false;
-	mutex_unlock(&sdata->local->slaves_mtx);
+	mutex_unlock(&sdata->local->iflist_mtx);
 
 	if (!--local->open_count)
 		local->ops->stop(&local->hw);
@@ -115,21 +115,21 @@ mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 
 	SET_NETDEV_DEV(dev, &local->phy->dev);
 
-	mutex_lock(&local->slaves_mtx);
+	mutex_lock(&local->iflist_mtx);
 	if (!local->running) {
-		mutex_unlock(&local->slaves_mtx);
+		mutex_unlock(&local->iflist_mtx);
 		return -ENODEV;
 	}
-	mutex_unlock(&local->slaves_mtx);
+	mutex_unlock(&local->iflist_mtx);
 
 	err = register_netdev(dev);
 	if (err < 0)
 		return err;
 
 	rtnl_lock();
-	mutex_lock(&local->slaves_mtx);
-	list_add_tail_rcu(&sdata->list, &local->slaves);
-	mutex_unlock(&local->slaves_mtx);
+	mutex_lock(&local->iflist_mtx);
+	list_add_tail_rcu(&sdata->list, &local->interfaces);
+	mutex_unlock(&local->iflist_mtx);
 	rtnl_unlock();
 
 	return 0;
@@ -146,9 +146,9 @@ mac802154_del_iface(struct wpan_phy *phy, struct net_device *dev)
 
 	BUG_ON(sdata->local->phy != phy);
 
-	mutex_lock(&sdata->local->slaves_mtx);
+	mutex_lock(&sdata->local->iflist_mtx);
 	list_del_rcu(&sdata->list);
-	mutex_unlock(&sdata->local->slaves_mtx);
+	mutex_unlock(&sdata->local->iflist_mtx);
 
 	synchronize_rcu();
 	unregister_netdevice(sdata->dev);
@@ -280,8 +280,8 @@ ieee802154_alloc_hw(size_t priv_data_len, struct ieee802154_ops *ops)
 	local->hw.priv = (char *)local + ALIGN(sizeof(*local), NETDEV_ALIGN);
 	local->ops = ops;
 
-	INIT_LIST_HEAD(&local->slaves);
-	mutex_init(&local->slaves_mtx);
+	INIT_LIST_HEAD(&local->interfaces);
+	mutex_init(&local->iflist_mtx);
 
 	return &local->hw;
 }
@@ -291,9 +291,9 @@ void ieee802154_free_hw(struct ieee802154_hw *hw)
 {
 	struct ieee802154_local *local = mac802154_to_priv(hw);
 
-	BUG_ON(!list_empty(&local->slaves));
+	BUG_ON(!list_empty(&local->interfaces));
 
-	mutex_destroy(&local->slaves_mtx);
+	mutex_destroy(&local->iflist_mtx);
 
 	wpan_phy_free(local->phy);
 }
@@ -364,9 +364,9 @@ int ieee802154_register_hw(struct ieee802154_hw *hw)
 
 	rtnl_lock();
 
-	mutex_lock(&local->slaves_mtx);
+	mutex_lock(&local->iflist_mtx);
 	local->running = MAC802154_DEVICE_RUN;
-	mutex_unlock(&local->slaves_mtx);
+	mutex_unlock(&local->iflist_mtx);
 
 	rtnl_unlock();
 
@@ -389,14 +389,14 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 
 	rtnl_lock();
 
-	mutex_lock(&local->slaves_mtx);
+	mutex_lock(&local->iflist_mtx);
 	local->running = MAC802154_DEVICE_STOPPED;
-	mutex_unlock(&local->slaves_mtx);
+	mutex_unlock(&local->iflist_mtx);
 
-	list_for_each_entry_safe(sdata, next, &local->slaves, list) {
-		mutex_lock(&sdata->local->slaves_mtx);
+	list_for_each_entry_safe(sdata, next, &local->interfaces, list) {
+		mutex_lock(&sdata->local->iflist_mtx);
 		list_del(&sdata->list);
-		mutex_unlock(&sdata->local->slaves_mtx);
+		mutex_unlock(&sdata->local->iflist_mtx);
 
 		unregister_netdevice(sdata->dev);
 	}

commit 04e850fe06312a9f570fcc7dbd0f141c012df404
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:37 2014 +0200

    mac802154: rename hw subif_data variable to local
    
    This patch renames the hw attribute in struct ieee802154_sub_if_data to
    local. This avoid confusing with the struct ieee802154_hw hw; inside of
    local struct.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 6f630d4990fa..9b2644ff6de5 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -33,26 +33,26 @@ int mac802154_slave_open(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
 	struct ieee802154_sub_if_data *subif;
-	struct ieee802154_local *local = sdata->hw;
+	struct ieee802154_local *local = sdata->local;
 	int res = 0;
 
 	ASSERT_RTNL();
 
 	if (sdata->type == IEEE802154_DEV_WPAN) {
-		mutex_lock(&sdata->hw->slaves_mtx);
-		list_for_each_entry(subif, &sdata->hw->slaves, list) {
+		mutex_lock(&sdata->local->slaves_mtx);
+		list_for_each_entry(subif, &sdata->local->slaves, list) {
 			if (subif != sdata && subif->type == sdata->type &&
 			    subif->running) {
-				mutex_unlock(&sdata->hw->slaves_mtx);
+				mutex_unlock(&sdata->local->slaves_mtx);
 				return -EBUSY;
 			}
 		}
-		mutex_unlock(&sdata->hw->slaves_mtx);
+		mutex_unlock(&sdata->local->slaves_mtx);
 	}
 
-	mutex_lock(&sdata->hw->slaves_mtx);
+	mutex_lock(&sdata->local->slaves_mtx);
 	sdata->running = true;
-	mutex_unlock(&sdata->hw->slaves_mtx);
+	mutex_unlock(&sdata->local->slaves_mtx);
 
 	if (local->open_count++ == 0) {
 		res = local->ops->start(&local->hw);
@@ -74,7 +74,7 @@ int mac802154_slave_open(struct net_device *dev)
 	netif_start_queue(dev);
 	return 0;
 err:
-	sdata->hw->open_count--;
+	sdata->local->open_count--;
 
 	return res;
 }
@@ -82,15 +82,15 @@ int mac802154_slave_open(struct net_device *dev)
 int mac802154_slave_close(struct net_device *dev)
 {
 	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
-	struct ieee802154_local *local = sdata->hw;
+	struct ieee802154_local *local = sdata->local;
 
 	ASSERT_RTNL();
 
 	netif_stop_queue(dev);
 
-	mutex_lock(&sdata->hw->slaves_mtx);
+	mutex_lock(&sdata->local->slaves_mtx);
 	sdata->running = false;
-	mutex_unlock(&sdata->hw->slaves_mtx);
+	mutex_unlock(&sdata->local->slaves_mtx);
 
 	if (!--local->open_count)
 		local->ops->stop(&local->hw);
@@ -109,7 +109,7 @@ mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 
 	sdata = netdev_priv(dev);
 	sdata->dev = dev;
-	sdata->hw = local;
+	sdata->local = local;
 
 	dev->needed_headroom = local->hw.extra_tx_headroom;
 
@@ -144,11 +144,11 @@ mac802154_del_iface(struct wpan_phy *phy, struct net_device *dev)
 
 	sdata = netdev_priv(dev);
 
-	BUG_ON(sdata->hw->phy != phy);
+	BUG_ON(sdata->local->phy != phy);
 
-	mutex_lock(&sdata->hw->slaves_mtx);
+	mutex_lock(&sdata->local->slaves_mtx);
 	list_del_rcu(&sdata->list);
-	mutex_unlock(&sdata->hw->slaves_mtx);
+	mutex_unlock(&sdata->local->slaves_mtx);
 
 	synchronize_rcu();
 	unregister_netdevice(sdata->dev);
@@ -394,9 +394,9 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 	mutex_unlock(&local->slaves_mtx);
 
 	list_for_each_entry_safe(sdata, next, &local->slaves, list) {
-		mutex_lock(&sdata->hw->slaves_mtx);
+		mutex_lock(&sdata->local->slaves_mtx);
 		list_del(&sdata->list);
-		mutex_unlock(&sdata->hw->slaves_mtx);
+		mutex_unlock(&sdata->local->slaves_mtx);
 
 		unregister_netdevice(sdata->dev);
 	}

commit 036562f9c4d942f2fbc77ae3215309bde340546f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:36 2014 +0200

    mac802154: rename mac802154_sub_if_data
    
    Like wireless this structure should named ieee802154_sub_if_data and not
    mac802154_sub_if_data. This patch renames the struct and variables to
    sdata instead priv sometimes.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 387d4cf94853..6f630d4990fa 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -31,28 +31,28 @@
 
 int mac802154_slave_open(struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
-	struct mac802154_sub_if_data *subif;
-	struct ieee802154_local *local = priv->hw;
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_sub_if_data *subif;
+	struct ieee802154_local *local = sdata->hw;
 	int res = 0;
 
 	ASSERT_RTNL();
 
-	if (priv->type == IEEE802154_DEV_WPAN) {
-		mutex_lock(&priv->hw->slaves_mtx);
-		list_for_each_entry(subif, &priv->hw->slaves, list) {
-			if (subif != priv && subif->type == priv->type &&
+	if (sdata->type == IEEE802154_DEV_WPAN) {
+		mutex_lock(&sdata->hw->slaves_mtx);
+		list_for_each_entry(subif, &sdata->hw->slaves, list) {
+			if (subif != sdata && subif->type == sdata->type &&
 			    subif->running) {
-				mutex_unlock(&priv->hw->slaves_mtx);
+				mutex_unlock(&sdata->hw->slaves_mtx);
 				return -EBUSY;
 			}
 		}
-		mutex_unlock(&priv->hw->slaves_mtx);
+		mutex_unlock(&sdata->hw->slaves_mtx);
 	}
 
-	mutex_lock(&priv->hw->slaves_mtx);
-	priv->running = true;
-	mutex_unlock(&priv->hw->slaves_mtx);
+	mutex_lock(&sdata->hw->slaves_mtx);
+	sdata->running = true;
+	mutex_unlock(&sdata->hw->slaves_mtx);
 
 	if (local->open_count++ == 0) {
 		res = local->ops->start(&local->hw);
@@ -74,23 +74,23 @@ int mac802154_slave_open(struct net_device *dev)
 	netif_start_queue(dev);
 	return 0;
 err:
-	priv->hw->open_count--;
+	sdata->hw->open_count--;
 
 	return res;
 }
 
 int mac802154_slave_close(struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv = netdev_priv(dev);
-	struct ieee802154_local *local = priv->hw;
+	struct ieee802154_sub_if_data *sdata = netdev_priv(dev);
+	struct ieee802154_local *local = sdata->hw;
 
 	ASSERT_RTNL();
 
 	netif_stop_queue(dev);
 
-	mutex_lock(&priv->hw->slaves_mtx);
-	priv->running = false;
-	mutex_unlock(&priv->hw->slaves_mtx);
+	mutex_lock(&sdata->hw->slaves_mtx);
+	sdata->running = false;
+	mutex_unlock(&sdata->hw->slaves_mtx);
 
 	if (!--local->open_count)
 		local->ops->stop(&local->hw);
@@ -101,15 +101,15 @@ int mac802154_slave_close(struct net_device *dev)
 static int
 mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 {
-	struct mac802154_sub_if_data *priv;
+	struct ieee802154_sub_if_data *sdata;
 	struct ieee802154_local *local;
 	int err;
 
 	local = wpan_phy_priv(phy);
 
-	priv = netdev_priv(dev);
-	priv->dev = dev;
-	priv->hw = local;
+	sdata = netdev_priv(dev);
+	sdata->dev = dev;
+	sdata->hw = local;
 
 	dev->needed_headroom = local->hw.extra_tx_headroom;
 
@@ -128,7 +128,7 @@ mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 
 	rtnl_lock();
 	mutex_lock(&local->slaves_mtx);
-	list_add_tail_rcu(&priv->list, &local->slaves);
+	list_add_tail_rcu(&sdata->list, &local->slaves);
 	mutex_unlock(&local->slaves_mtx);
 	rtnl_unlock();
 
@@ -138,7 +138,7 @@ mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 static void
 mac802154_del_iface(struct wpan_phy *phy, struct net_device *dev)
 {
-	struct mac802154_sub_if_data *sdata;
+	struct ieee802154_sub_if_data *sdata;
 
 	ASSERT_RTNL();
 
@@ -162,12 +162,12 @@ mac802154_add_iface(struct wpan_phy *phy, const char *name, int type)
 
 	switch (type) {
 	case IEEE802154_DEV_MONITOR:
-		dev = alloc_netdev(sizeof(struct mac802154_sub_if_data),
+		dev = alloc_netdev(sizeof(struct ieee802154_sub_if_data),
 				   name, NET_NAME_UNKNOWN,
 				   mac802154_monitor_setup);
 		break;
 	case IEEE802154_DEV_WPAN:
-		dev = alloc_netdev(sizeof(struct mac802154_sub_if_data),
+		dev = alloc_netdev(sizeof(struct ieee802154_sub_if_data),
 				   name, NET_NAME_UNKNOWN,
 				   mac802154_wpan_setup);
 		break;
@@ -382,7 +382,7 @@ EXPORT_SYMBOL(ieee802154_register_hw);
 void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 {
 	struct ieee802154_local *local = mac802154_to_priv(hw);
-	struct mac802154_sub_if_data *sdata, *next;
+	struct ieee802154_sub_if_data *sdata, *next;
 
 	flush_workqueue(local->dev_workqueue);
 	destroy_workqueue(local->dev_workqueue);

commit a5e1ec538f54c4cb8ec9ce30867cfbab57225280
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:35 2014 +0200

    mac802154: rename mac802154_priv to ieee802154_local
    
    This patch rename the mac802154_priv to ieee802154_local. The
    mac802154_priv structure is like ieee80211_local and so we name it
    ieee802154_local.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index b0bcc063e9af..387d4cf94853 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -33,7 +33,7 @@ int mac802154_slave_open(struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);
 	struct mac802154_sub_if_data *subif;
-	struct mac802154_priv *ipriv = priv->hw;
+	struct ieee802154_local *local = priv->hw;
 	int res = 0;
 
 	ASSERT_RTNL();
@@ -54,17 +54,17 @@ int mac802154_slave_open(struct net_device *dev)
 	priv->running = true;
 	mutex_unlock(&priv->hw->slaves_mtx);
 
-	if (ipriv->open_count++ == 0) {
-		res = ipriv->ops->start(&ipriv->hw);
+	if (local->open_count++ == 0) {
+		res = local->ops->start(&local->hw);
 		WARN_ON(res);
 		if (res)
 			goto err;
 	}
 
-	if (ipriv->ops->ieee_addr) {
+	if (local->ops->ieee_addr) {
 		__le64 addr = ieee802154_devaddr_from_raw(dev->dev_addr);
 
-		res = ipriv->ops->ieee_addr(&ipriv->hw, addr);
+		res = local->ops->ieee_addr(&local->hw, addr);
 		WARN_ON(res);
 		if (res)
 			goto err;
@@ -82,7 +82,7 @@ int mac802154_slave_open(struct net_device *dev)
 int mac802154_slave_close(struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv = netdev_priv(dev);
-	struct mac802154_priv *ipriv = priv->hw;
+	struct ieee802154_local *local = priv->hw;
 
 	ASSERT_RTNL();
 
@@ -92,8 +92,8 @@ int mac802154_slave_close(struct net_device *dev)
 	priv->running = false;
 	mutex_unlock(&priv->hw->slaves_mtx);
 
-	if (!--ipriv->open_count)
-		ipriv->ops->stop(&ipriv->hw);
+	if (!--local->open_count)
+		local->ops->stop(&local->hw);
 
 	return 0;
 }
@@ -102,34 +102,34 @@ static int
 mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
 {
 	struct mac802154_sub_if_data *priv;
-	struct mac802154_priv *ipriv;
+	struct ieee802154_local *local;
 	int err;
 
-	ipriv = wpan_phy_priv(phy);
+	local = wpan_phy_priv(phy);
 
 	priv = netdev_priv(dev);
 	priv->dev = dev;
-	priv->hw = ipriv;
+	priv->hw = local;
 
-	dev->needed_headroom = ipriv->hw.extra_tx_headroom;
+	dev->needed_headroom = local->hw.extra_tx_headroom;
 
-	SET_NETDEV_DEV(dev, &ipriv->phy->dev);
+	SET_NETDEV_DEV(dev, &local->phy->dev);
 
-	mutex_lock(&ipriv->slaves_mtx);
-	if (!ipriv->running) {
-		mutex_unlock(&ipriv->slaves_mtx);
+	mutex_lock(&local->slaves_mtx);
+	if (!local->running) {
+		mutex_unlock(&local->slaves_mtx);
 		return -ENODEV;
 	}
-	mutex_unlock(&ipriv->slaves_mtx);
+	mutex_unlock(&local->slaves_mtx);
 
 	err = register_netdev(dev);
 	if (err < 0)
 		return err;
 
 	rtnl_lock();
-	mutex_lock(&ipriv->slaves_mtx);
-	list_add_tail_rcu(&priv->list, &ipriv->slaves);
-	mutex_unlock(&ipriv->slaves_mtx);
+	mutex_lock(&local->slaves_mtx);
+	list_add_tail_rcu(&priv->list, &local->slaves);
+	mutex_unlock(&local->slaves_mtx);
 	rtnl_unlock();
 
 	return 0;
@@ -194,52 +194,52 @@ mac802154_add_iface(struct wpan_phy *phy, const char *name, int type)
 
 static int mac802154_set_txpower(struct wpan_phy *phy, int db)
 {
-	struct mac802154_priv *priv = wpan_phy_priv(phy);
+	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return priv->ops->set_txpower(&priv->hw, db);
+	return local->ops->set_txpower(&local->hw, db);
 }
 
 static int mac802154_set_lbt(struct wpan_phy *phy, bool on)
 {
-	struct mac802154_priv *priv = wpan_phy_priv(phy);
+	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return priv->ops->set_lbt(&priv->hw, on);
+	return local->ops->set_lbt(&local->hw, on);
 }
 
 static int mac802154_set_cca_mode(struct wpan_phy *phy, u8 mode)
 {
-	struct mac802154_priv *priv = wpan_phy_priv(phy);
+	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return priv->ops->set_cca_mode(&priv->hw, mode);
+	return local->ops->set_cca_mode(&local->hw, mode);
 }
 
 static int mac802154_set_cca_ed_level(struct wpan_phy *phy, s32 level)
 {
-	struct mac802154_priv *priv = wpan_phy_priv(phy);
+	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return priv->ops->set_cca_ed_level(&priv->hw, level);
+	return local->ops->set_cca_ed_level(&local->hw, level);
 }
 
 static int mac802154_set_csma_params(struct wpan_phy *phy, u8 min_be,
 				     u8 max_be, u8 retries)
 {
-	struct mac802154_priv *priv = wpan_phy_priv(phy);
+	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return priv->ops->set_csma_params(&priv->hw, min_be, max_be, retries);
+	return local->ops->set_csma_params(&local->hw, min_be, max_be, retries);
 }
 
 static int mac802154_set_frame_retries(struct wpan_phy *phy, s8 retries)
 {
-	struct mac802154_priv *priv = wpan_phy_priv(phy);
+	struct ieee802154_local *local = wpan_phy_priv(phy);
 
-	return priv->ops->set_frame_retries(&priv->hw, retries);
+	return local->ops->set_frame_retries(&local->hw, retries);
 }
 
 struct ieee802154_hw *
 ieee802154_alloc_hw(size_t priv_data_len, struct ieee802154_ops *ops)
 {
 	struct wpan_phy *phy;
-	struct mac802154_priv *priv;
+	struct ieee802154_local *local;
 	size_t priv_size;
 
 	if (!ops || !ops->xmit || !ops->ed || !ops->start ||
@@ -249,24 +249,24 @@ ieee802154_alloc_hw(size_t priv_data_len, struct ieee802154_ops *ops)
 	}
 
 	/* Ensure 32-byte alignment of our private data and hw private data.
-	 * We use the wpan_phy priv data for both our mac802154_priv and for
+	 * We use the wpan_phy priv data for both our ieee802154_local and for
 	 * the driver's private data
 	 *
 	 * in memory it'll be like this:
 	 *
-	 * +-----------------------+
-	 * | struct wpan_phy       |
-	 * +-----------------------+
-	 * | struct mac802154_priv |
-	 * +-----------------------+
-	 * | driver's private data |
-	 * +-----------------------+
+	 * +-------------------------+
+	 * | struct wpan_phy         |
+	 * +-------------------------+
+	 * | struct ieee802154_local |
+	 * +-------------------------+
+	 * | driver's private data   |
+	 * +-------------------------+
 	 *
 	 * Due to ieee802154 layer isn't aware of driver and MAC structures,
 	 * so lets align them here.
 	 */
 
-	priv_size = ALIGN(sizeof(*priv), NETDEV_ALIGN) + priv_data_len;
+	priv_size = ALIGN(sizeof(*local), NETDEV_ALIGN) + priv_data_len;
 
 	phy = wpan_phy_alloc(priv_size);
 	if (!phy) {
@@ -274,106 +274,106 @@ ieee802154_alloc_hw(size_t priv_data_len, struct ieee802154_ops *ops)
 		return NULL;
 	}
 
-	priv = wpan_phy_priv(phy);
-	priv->phy = phy;
-	priv->hw.phy = priv->phy;
-	priv->hw.priv = (char *)priv + ALIGN(sizeof(*priv), NETDEV_ALIGN);
-	priv->ops = ops;
+	local = wpan_phy_priv(phy);
+	local->phy = phy;
+	local->hw.phy = local->phy;
+	local->hw.priv = (char *)local + ALIGN(sizeof(*local), NETDEV_ALIGN);
+	local->ops = ops;
 
-	INIT_LIST_HEAD(&priv->slaves);
-	mutex_init(&priv->slaves_mtx);
+	INIT_LIST_HEAD(&local->slaves);
+	mutex_init(&local->slaves_mtx);
 
-	return &priv->hw;
+	return &local->hw;
 }
 EXPORT_SYMBOL(ieee802154_alloc_hw);
 
 void ieee802154_free_hw(struct ieee802154_hw *hw)
 {
-	struct mac802154_priv *priv = mac802154_to_priv(hw);
+	struct ieee802154_local *local = mac802154_to_priv(hw);
 
-	BUG_ON(!list_empty(&priv->slaves));
+	BUG_ON(!list_empty(&local->slaves));
 
-	mutex_destroy(&priv->slaves_mtx);
+	mutex_destroy(&local->slaves_mtx);
 
-	wpan_phy_free(priv->phy);
+	wpan_phy_free(local->phy);
 }
 EXPORT_SYMBOL(ieee802154_free_hw);
 
 int ieee802154_register_hw(struct ieee802154_hw *hw)
 {
-	struct mac802154_priv *priv = mac802154_to_priv(hw);
+	struct ieee802154_local *local = mac802154_to_priv(hw);
 	int rc = -ENOSYS;
 
 	if (hw->flags & IEEE802154_HW_TXPOWER) {
-		if (!priv->ops->set_txpower)
+		if (!local->ops->set_txpower)
 			goto out;
 
-		priv->phy->set_txpower = mac802154_set_txpower;
+		local->phy->set_txpower = mac802154_set_txpower;
 	}
 
 	if (hw->flags & IEEE802154_HW_LBT) {
-		if (!priv->ops->set_lbt)
+		if (!local->ops->set_lbt)
 			goto out;
 
-		priv->phy->set_lbt = mac802154_set_lbt;
+		local->phy->set_lbt = mac802154_set_lbt;
 	}
 
 	if (hw->flags & IEEE802154_HW_CCA_MODE) {
-		if (!priv->ops->set_cca_mode)
+		if (!local->ops->set_cca_mode)
 			goto out;
 
-		priv->phy->set_cca_mode = mac802154_set_cca_mode;
+		local->phy->set_cca_mode = mac802154_set_cca_mode;
 	}
 
 	if (hw->flags & IEEE802154_HW_CCA_ED_LEVEL) {
-		if (!priv->ops->set_cca_ed_level)
+		if (!local->ops->set_cca_ed_level)
 			goto out;
 
-		priv->phy->set_cca_ed_level = mac802154_set_cca_ed_level;
+		local->phy->set_cca_ed_level = mac802154_set_cca_ed_level;
 	}
 
 	if (hw->flags & IEEE802154_HW_CSMA_PARAMS) {
-		if (!priv->ops->set_csma_params)
+		if (!local->ops->set_csma_params)
 			goto out;
 
-		priv->phy->set_csma_params = mac802154_set_csma_params;
+		local->phy->set_csma_params = mac802154_set_csma_params;
 	}
 
 	if (hw->flags & IEEE802154_HW_FRAME_RETRIES) {
-		if (!priv->ops->set_frame_retries)
+		if (!local->ops->set_frame_retries)
 			goto out;
 
-		priv->phy->set_frame_retries = mac802154_set_frame_retries;
+		local->phy->set_frame_retries = mac802154_set_frame_retries;
 	}
 
-	priv->dev_workqueue =
-		create_singlethread_workqueue(wpan_phy_name(priv->phy));
-	if (!priv->dev_workqueue) {
+	local->dev_workqueue =
+		create_singlethread_workqueue(wpan_phy_name(local->phy));
+	if (!local->dev_workqueue) {
 		rc = -ENOMEM;
 		goto out;
 	}
 
-	wpan_phy_set_dev(priv->phy, priv->hw.parent);
+	wpan_phy_set_dev(local->phy, local->hw.parent);
 
-	priv->phy->add_iface = mac802154_add_iface;
-	priv->phy->del_iface = mac802154_del_iface;
+	local->phy->add_iface = mac802154_add_iface;
+	local->phy->del_iface = mac802154_del_iface;
 
-	rc = wpan_phy_register(priv->phy);
+	rc = wpan_phy_register(local->phy);
 	if (rc < 0)
 		goto out_wq;
 
 	rtnl_lock();
 
-	mutex_lock(&priv->slaves_mtx);
-	priv->running = MAC802154_DEVICE_RUN;
-	mutex_unlock(&priv->slaves_mtx);
+	mutex_lock(&local->slaves_mtx);
+	local->running = MAC802154_DEVICE_RUN;
+	mutex_unlock(&local->slaves_mtx);
 
 	rtnl_unlock();
 
 	return 0;
 
 out_wq:
-	destroy_workqueue(priv->dev_workqueue);
+	destroy_workqueue(local->dev_workqueue);
 out:
 	return rc;
 }
@@ -381,19 +381,19 @@ EXPORT_SYMBOL(ieee802154_register_hw);
 
 void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 {
-	struct mac802154_priv *priv = mac802154_to_priv(hw);
+	struct ieee802154_local *local = mac802154_to_priv(hw);
 	struct mac802154_sub_if_data *sdata, *next;
 
-	flush_workqueue(priv->dev_workqueue);
-	destroy_workqueue(priv->dev_workqueue);
+	flush_workqueue(local->dev_workqueue);
+	destroy_workqueue(local->dev_workqueue);
 
 	rtnl_lock();
 
-	mutex_lock(&priv->slaves_mtx);
-	priv->running = MAC802154_DEVICE_STOPPED;
-	mutex_unlock(&priv->slaves_mtx);
+	mutex_lock(&local->slaves_mtx);
+	local->running = MAC802154_DEVICE_STOPPED;
+	mutex_unlock(&local->slaves_mtx);
 
-	list_for_each_entry_safe(sdata, next, &priv->slaves, list) {
+	list_for_each_entry_safe(sdata, next, &local->slaves, list) {
 		mutex_lock(&sdata->hw->slaves_mtx);
 		list_del(&sdata->list);
 		mutex_unlock(&sdata->hw->slaves_mtx);
@@ -403,7 +403,7 @@ void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 
 	rtnl_unlock();
 
-	wpan_phy_unregister(priv->phy);
+	wpan_phy_unregister(local->phy);
 }
 EXPORT_SYMBOL(ieee802154_unregister_hw);
 

commit 5a50439775853a8d565115edb63a5ab4bb780479
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 17:16:34 2014 +0200

    ieee802154: rename ieee802154_dev to ieee802154_hw
    
    The identical struct of the wireless stack implementation is named
    ieee80211_hw. This is useful to name the variable hw instead of get
    confusing with netdev dev variable.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 9798c741739c..b0bcc063e9af 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -235,8 +235,8 @@ static int mac802154_set_frame_retries(struct wpan_phy *phy, s8 retries)
 	return priv->ops->set_frame_retries(&priv->hw, retries);
 }
 
-struct ieee802154_dev *
-ieee802154_alloc_device(size_t priv_data_len, struct ieee802154_ops *ops)
+struct ieee802154_hw *
+ieee802154_alloc_hw(size_t priv_data_len, struct ieee802154_ops *ops)
 {
 	struct wpan_phy *phy;
 	struct mac802154_priv *priv;
@@ -285,9 +285,9 @@ ieee802154_alloc_device(size_t priv_data_len, struct ieee802154_ops *ops)
 
 	return &priv->hw;
 }
-EXPORT_SYMBOL(ieee802154_alloc_device);
+EXPORT_SYMBOL(ieee802154_alloc_hw);
 
-void ieee802154_free_device(struct ieee802154_dev *hw)
+void ieee802154_free_hw(struct ieee802154_hw *hw)
 {
 	struct mac802154_priv *priv = mac802154_to_priv(hw);
 
@@ -297,49 +297,49 @@ void ieee802154_free_device(struct ieee802154_dev *hw)
 
 	wpan_phy_free(priv->phy);
 }
-EXPORT_SYMBOL(ieee802154_free_device);
+EXPORT_SYMBOL(ieee802154_free_hw);
 
-int ieee802154_register_device(struct ieee802154_dev *dev)
+int ieee802154_register_hw(struct ieee802154_hw *hw)
 {
-	struct mac802154_priv *priv = mac802154_to_priv(dev);
+	struct mac802154_priv *priv = mac802154_to_priv(hw);
 	int rc = -ENOSYS;
 
-	if (dev->flags & IEEE802154_HW_TXPOWER) {
+	if (hw->flags & IEEE802154_HW_TXPOWER) {
 		if (!priv->ops->set_txpower)
 			goto out;
 
 		priv->phy->set_txpower = mac802154_set_txpower;
 	}
 
-	if (dev->flags & IEEE802154_HW_LBT) {
+	if (hw->flags & IEEE802154_HW_LBT) {
 		if (!priv->ops->set_lbt)
 			goto out;
 
 		priv->phy->set_lbt = mac802154_set_lbt;
 	}
 
-	if (dev->flags & IEEE802154_HW_CCA_MODE) {
+	if (hw->flags & IEEE802154_HW_CCA_MODE) {
 		if (!priv->ops->set_cca_mode)
 			goto out;
 
 		priv->phy->set_cca_mode = mac802154_set_cca_mode;
 	}
 
-	if (dev->flags & IEEE802154_HW_CCA_ED_LEVEL) {
+	if (hw->flags & IEEE802154_HW_CCA_ED_LEVEL) {
 		if (!priv->ops->set_cca_ed_level)
 			goto out;
 
 		priv->phy->set_cca_ed_level = mac802154_set_cca_ed_level;
 	}
 
-	if (dev->flags & IEEE802154_HW_CSMA_PARAMS) {
+	if (hw->flags & IEEE802154_HW_CSMA_PARAMS) {
 		if (!priv->ops->set_csma_params)
 			goto out;
 
 		priv->phy->set_csma_params = mac802154_set_csma_params;
 	}
 
-	if (dev->flags & IEEE802154_HW_FRAME_RETRIES) {
+	if (hw->flags & IEEE802154_HW_FRAME_RETRIES) {
 		if (!priv->ops->set_frame_retries)
 			goto out;
 
@@ -377,11 +377,11 @@ int ieee802154_register_device(struct ieee802154_dev *dev)
 out:
 	return rc;
 }
-EXPORT_SYMBOL(ieee802154_register_device);
+EXPORT_SYMBOL(ieee802154_register_hw);
 
-void ieee802154_unregister_device(struct ieee802154_dev *dev)
+void ieee802154_unregister_hw(struct ieee802154_hw *hw)
 {
-	struct mac802154_priv *priv = mac802154_to_priv(dev);
+	struct mac802154_priv *priv = mac802154_to_priv(hw);
 	struct mac802154_sub_if_data *sdata, *next;
 
 	flush_workqueue(priv->dev_workqueue);
@@ -405,7 +405,7 @@ void ieee802154_unregister_device(struct ieee802154_dev *dev)
 
 	wpan_phy_unregister(priv->phy);
 }
-EXPORT_SYMBOL(ieee802154_unregister_device);
+EXPORT_SYMBOL(ieee802154_unregister_hw);
 
 MODULE_DESCRIPTION("IEEE 802.15.4 implementation");
 MODULE_LICENSE("GPL v2");

commit 5ad60d36993596f7b3b958500f9c66c5338cd855
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:41:02 2014 +0200

    ieee802154: move wpan-phy.h to cfg802154.h
    
    The wpan-phy header contains the wpan_phy struct information. Later this
    header will be have similar function like cfg80211 header. The cfg80211
    header contains the wiphy struct which is identically the wpan_phy
    struct inside 802.15.4 subsystem.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Cc: Alan Ott <alan@signal11.us>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index d11e42ae10d6..9798c741739c 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -25,7 +25,7 @@
 #include <net/mac802154.h>
 #include <net/ieee802154_netdev.h>
 #include <net/route.h>
-#include <net/wpan-phy.h>
+#include <net/cfg802154.h>
 
 #include "ieee802154_i.h"
 

commit 0f1556bc2b152fc5d2a6b929c579748ec90c55d0
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:41:00 2014 +0200

    mac802154: move mac802154.h to ieee802154_i.h
    
    This patch moves the mac802154.h internal header to ieee802154_i.h like
    the wireless stack ieee80211_i.h file. This avoids confusing with the
    not internal header include/net/mac802154.h header. Additional we get
    the same naming conversion like mac80211 for this file.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
index 086d4a91ae45..d11e42ae10d6 100644
--- a/net/mac802154/main.c
+++ b/net/mac802154/main.c
@@ -27,7 +27,7 @@
 #include <net/route.h>
 #include <net/wpan-phy.h>
 
-#include "mac802154.h"
+#include "ieee802154_i.h"
 
 int mac802154_slave_open(struct net_device *dev)
 {

commit 62eb01f5c2d735e8aeab6bc95e5832cb59397527
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:40:59 2014 +0200

    mac802154: move ieee802154_dev.c to main.c
    
    The ieee802154_dev functionality contains various function for
    allocation and registration of an ieee802154_dev. This is equal to the
    net/mac80211/main.c file. This patch rename the ieee802154_dev.c to
    main.c to have the same behaviour.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/mac802154/main.c b/net/mac802154/main.c
new file mode 100644
index 000000000000..086d4a91ae45
--- /dev/null
+++ b/net/mac802154/main.c
@@ -0,0 +1,411 @@
+/*
+ * Copyright (C) 2007-2012 Siemens AG
+ *
+ * Written by:
+ * Alexander Smirnov <alex.bluesman.smirnov@gmail.com>
+ *
+ * Based on the code from 'linux-zigbee.sourceforge.net' project.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+
+#include <net/netlink.h>
+#include <linux/nl802154.h>
+#include <net/mac802154.h>
+#include <net/ieee802154_netdev.h>
+#include <net/route.h>
+#include <net/wpan-phy.h>
+
+#include "mac802154.h"
+
+int mac802154_slave_open(struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct mac802154_sub_if_data *subif;
+	struct mac802154_priv *ipriv = priv->hw;
+	int res = 0;
+
+	ASSERT_RTNL();
+
+	if (priv->type == IEEE802154_DEV_WPAN) {
+		mutex_lock(&priv->hw->slaves_mtx);
+		list_for_each_entry(subif, &priv->hw->slaves, list) {
+			if (subif != priv && subif->type == priv->type &&
+			    subif->running) {
+				mutex_unlock(&priv->hw->slaves_mtx);
+				return -EBUSY;
+			}
+		}
+		mutex_unlock(&priv->hw->slaves_mtx);
+	}
+
+	mutex_lock(&priv->hw->slaves_mtx);
+	priv->running = true;
+	mutex_unlock(&priv->hw->slaves_mtx);
+
+	if (ipriv->open_count++ == 0) {
+		res = ipriv->ops->start(&ipriv->hw);
+		WARN_ON(res);
+		if (res)
+			goto err;
+	}
+
+	if (ipriv->ops->ieee_addr) {
+		__le64 addr = ieee802154_devaddr_from_raw(dev->dev_addr);
+
+		res = ipriv->ops->ieee_addr(&ipriv->hw, addr);
+		WARN_ON(res);
+		if (res)
+			goto err;
+		mac802154_dev_set_ieee_addr(dev);
+	}
+
+	netif_start_queue(dev);
+	return 0;
+err:
+	priv->hw->open_count--;
+
+	return res;
+}
+
+int mac802154_slave_close(struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv = netdev_priv(dev);
+	struct mac802154_priv *ipriv = priv->hw;
+
+	ASSERT_RTNL();
+
+	netif_stop_queue(dev);
+
+	mutex_lock(&priv->hw->slaves_mtx);
+	priv->running = false;
+	mutex_unlock(&priv->hw->slaves_mtx);
+
+	if (!--ipriv->open_count)
+		ipriv->ops->stop(&ipriv->hw);
+
+	return 0;
+}
+
+static int
+mac802154_netdev_register(struct wpan_phy *phy, struct net_device *dev)
+{
+	struct mac802154_sub_if_data *priv;
+	struct mac802154_priv *ipriv;
+	int err;
+
+	ipriv = wpan_phy_priv(phy);
+
+	priv = netdev_priv(dev);
+	priv->dev = dev;
+	priv->hw = ipriv;
+
+	dev->needed_headroom = ipriv->hw.extra_tx_headroom;
+
+	SET_NETDEV_DEV(dev, &ipriv->phy->dev);
+
+	mutex_lock(&ipriv->slaves_mtx);
+	if (!ipriv->running) {
+		mutex_unlock(&ipriv->slaves_mtx);
+		return -ENODEV;
+	}
+	mutex_unlock(&ipriv->slaves_mtx);
+
+	err = register_netdev(dev);
+	if (err < 0)
+		return err;
+
+	rtnl_lock();
+	mutex_lock(&ipriv->slaves_mtx);
+	list_add_tail_rcu(&priv->list, &ipriv->slaves);
+	mutex_unlock(&ipriv->slaves_mtx);
+	rtnl_unlock();
+
+	return 0;
+}
+
+static void
+mac802154_del_iface(struct wpan_phy *phy, struct net_device *dev)
+{
+	struct mac802154_sub_if_data *sdata;
+
+	ASSERT_RTNL();
+
+	sdata = netdev_priv(dev);
+
+	BUG_ON(sdata->hw->phy != phy);
+
+	mutex_lock(&sdata->hw->slaves_mtx);
+	list_del_rcu(&sdata->list);
+	mutex_unlock(&sdata->hw->slaves_mtx);
+
+	synchronize_rcu();
+	unregister_netdevice(sdata->dev);
+}
+
+static struct net_device *
+mac802154_add_iface(struct wpan_phy *phy, const char *name, int type)
+{
+	struct net_device *dev;
+	int err = -ENOMEM;
+
+	switch (type) {
+	case IEEE802154_DEV_MONITOR:
+		dev = alloc_netdev(sizeof(struct mac802154_sub_if_data),
+				   name, NET_NAME_UNKNOWN,
+				   mac802154_monitor_setup);
+		break;
+	case IEEE802154_DEV_WPAN:
+		dev = alloc_netdev(sizeof(struct mac802154_sub_if_data),
+				   name, NET_NAME_UNKNOWN,
+				   mac802154_wpan_setup);
+		break;
+	default:
+		dev = NULL;
+		err = -EINVAL;
+		break;
+	}
+	if (!dev)
+		goto err;
+
+	err = mac802154_netdev_register(phy, dev);
+	if (err)
+		goto err_free;
+
+	dev_hold(dev); /* we return an incremented device refcount */
+	return dev;
+
+err_free:
+	free_netdev(dev);
+err:
+	return ERR_PTR(err);
+}
+
+static int mac802154_set_txpower(struct wpan_phy *phy, int db)
+{
+	struct mac802154_priv *priv = wpan_phy_priv(phy);
+
+	return priv->ops->set_txpower(&priv->hw, db);
+}
+
+static int mac802154_set_lbt(struct wpan_phy *phy, bool on)
+{
+	struct mac802154_priv *priv = wpan_phy_priv(phy);
+
+	return priv->ops->set_lbt(&priv->hw, on);
+}
+
+static int mac802154_set_cca_mode(struct wpan_phy *phy, u8 mode)
+{
+	struct mac802154_priv *priv = wpan_phy_priv(phy);
+
+	return priv->ops->set_cca_mode(&priv->hw, mode);
+}
+
+static int mac802154_set_cca_ed_level(struct wpan_phy *phy, s32 level)
+{
+	struct mac802154_priv *priv = wpan_phy_priv(phy);
+
+	return priv->ops->set_cca_ed_level(&priv->hw, level);
+}
+
+static int mac802154_set_csma_params(struct wpan_phy *phy, u8 min_be,
+				     u8 max_be, u8 retries)
+{
+	struct mac802154_priv *priv = wpan_phy_priv(phy);
+
+	return priv->ops->set_csma_params(&priv->hw, min_be, max_be, retries);
+}
+
+static int mac802154_set_frame_retries(struct wpan_phy *phy, s8 retries)
+{
+	struct mac802154_priv *priv = wpan_phy_priv(phy);
+
+	return priv->ops->set_frame_retries(&priv->hw, retries);
+}
+
+struct ieee802154_dev *
+ieee802154_alloc_device(size_t priv_data_len, struct ieee802154_ops *ops)
+{
+	struct wpan_phy *phy;
+	struct mac802154_priv *priv;
+	size_t priv_size;
+
+	if (!ops || !ops->xmit || !ops->ed || !ops->start ||
+	    !ops->stop || !ops->set_channel) {
+		pr_err("undefined IEEE802.15.4 device operations\n");
+		return NULL;
+	}
+
+	/* Ensure 32-byte alignment of our private data and hw private data.
+	 * We use the wpan_phy priv data for both our mac802154_priv and for
+	 * the driver's private data
+	 *
+	 * in memory it'll be like this:
+	 *
+	 * +-----------------------+
+	 * | struct wpan_phy       |
+	 * +-----------------------+
+	 * | struct mac802154_priv |
+	 * +-----------------------+
+	 * | driver's private data |
+	 * +-----------------------+
+	 *
+	 * Due to ieee802154 layer isn't aware of driver and MAC structures,
+	 * so lets align them here.
+	 */
+
+	priv_size = ALIGN(sizeof(*priv), NETDEV_ALIGN) + priv_data_len;
+
+	phy = wpan_phy_alloc(priv_size);
+	if (!phy) {
+		pr_err("failure to allocate master IEEE802.15.4 device\n");
+		return NULL;
+	}
+
+	priv = wpan_phy_priv(phy);
+	priv->phy = phy;
+	priv->hw.phy = priv->phy;
+	priv->hw.priv = (char *)priv + ALIGN(sizeof(*priv), NETDEV_ALIGN);
+	priv->ops = ops;
+
+	INIT_LIST_HEAD(&priv->slaves);
+	mutex_init(&priv->slaves_mtx);
+
+	return &priv->hw;
+}
+EXPORT_SYMBOL(ieee802154_alloc_device);
+
+void ieee802154_free_device(struct ieee802154_dev *hw)
+{
+	struct mac802154_priv *priv = mac802154_to_priv(hw);
+
+	BUG_ON(!list_empty(&priv->slaves));
+
+	mutex_destroy(&priv->slaves_mtx);
+
+	wpan_phy_free(priv->phy);
+}
+EXPORT_SYMBOL(ieee802154_free_device);
+
+int ieee802154_register_device(struct ieee802154_dev *dev)
+{
+	struct mac802154_priv *priv = mac802154_to_priv(dev);
+	int rc = -ENOSYS;
+
+	if (dev->flags & IEEE802154_HW_TXPOWER) {
+		if (!priv->ops->set_txpower)
+			goto out;
+
+		priv->phy->set_txpower = mac802154_set_txpower;
+	}
+
+	if (dev->flags & IEEE802154_HW_LBT) {
+		if (!priv->ops->set_lbt)
+			goto out;
+
+		priv->phy->set_lbt = mac802154_set_lbt;
+	}
+
+	if (dev->flags & IEEE802154_HW_CCA_MODE) {
+		if (!priv->ops->set_cca_mode)
+			goto out;
+
+		priv->phy->set_cca_mode = mac802154_set_cca_mode;
+	}
+
+	if (dev->flags & IEEE802154_HW_CCA_ED_LEVEL) {
+		if (!priv->ops->set_cca_ed_level)
+			goto out;
+
+		priv->phy->set_cca_ed_level = mac802154_set_cca_ed_level;
+	}
+
+	if (dev->flags & IEEE802154_HW_CSMA_PARAMS) {
+		if (!priv->ops->set_csma_params)
+			goto out;
+
+		priv->phy->set_csma_params = mac802154_set_csma_params;
+	}
+
+	if (dev->flags & IEEE802154_HW_FRAME_RETRIES) {
+		if (!priv->ops->set_frame_retries)
+			goto out;
+
+		priv->phy->set_frame_retries = mac802154_set_frame_retries;
+	}
+
+	priv->dev_workqueue =
+		create_singlethread_workqueue(wpan_phy_name(priv->phy));
+	if (!priv->dev_workqueue) {
+		rc = -ENOMEM;
+		goto out;
+	}
+
+	wpan_phy_set_dev(priv->phy, priv->hw.parent);
+
+	priv->phy->add_iface = mac802154_add_iface;
+	priv->phy->del_iface = mac802154_del_iface;
+
+	rc = wpan_phy_register(priv->phy);
+	if (rc < 0)
+		goto out_wq;
+
+	rtnl_lock();
+
+	mutex_lock(&priv->slaves_mtx);
+	priv->running = MAC802154_DEVICE_RUN;
+	mutex_unlock(&priv->slaves_mtx);
+
+	rtnl_unlock();
+
+	return 0;
+
+out_wq:
+	destroy_workqueue(priv->dev_workqueue);
+out:
+	return rc;
+}
+EXPORT_SYMBOL(ieee802154_register_device);
+
+void ieee802154_unregister_device(struct ieee802154_dev *dev)
+{
+	struct mac802154_priv *priv = mac802154_to_priv(dev);
+	struct mac802154_sub_if_data *sdata, *next;
+
+	flush_workqueue(priv->dev_workqueue);
+	destroy_workqueue(priv->dev_workqueue);
+
+	rtnl_lock();
+
+	mutex_lock(&priv->slaves_mtx);
+	priv->running = MAC802154_DEVICE_STOPPED;
+	mutex_unlock(&priv->slaves_mtx);
+
+	list_for_each_entry_safe(sdata, next, &priv->slaves, list) {
+		mutex_lock(&sdata->hw->slaves_mtx);
+		list_del(&sdata->list);
+		mutex_unlock(&sdata->hw->slaves_mtx);
+
+		unregister_netdevice(sdata->dev);
+	}
+
+	rtnl_unlock();
+
+	wpan_phy_unregister(priv->phy);
+}
+EXPORT_SYMBOL(ieee802154_unregister_device);
+
+MODULE_DESCRIPTION("IEEE 802.15.4 implementation");
+MODULE_LICENSE("GPL v2");
