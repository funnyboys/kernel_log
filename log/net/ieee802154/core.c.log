commit 6cda08a20dbde45b021091230c8a359fa08c5103
Author: Suzuki K Poulose <suzuki.poulose@arm.com>
Date:   Tue Jul 23 23:18:32 2019 +0100

    drivers: Introduce device lookup variants by name
    
    Add a helper to match the device name for device lookup. Also
    reuse this generic exported helper for the existing bus_find_device_by_name().
    and add similar variants for driver/class.
    
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexander Aring <alex.aring@gmail.com>
    Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Dan Murphy <dmurphy@ti.com>
    Cc: Harald Freudenberger <freude@linux.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Jacek Anaszewski <jacek.anaszewski@gmail.com>
    Cc: Lee Jones <lee.jones@linaro.org>
    Cc: linux-leds@vger.kernel.org
    Cc: linux-rtc@vger.kernel.org
    Cc: linux-usb@vger.kernel.org
    Cc: linux-wpan@vger.kernel.org
    Cc: Maxime Coquelin <mcoquelin.stm32@gmail.com>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Peter Oberparleiter <oberpar@linux.ibm.com>
    Cc: "Rafael J. Wysocki" <rafael@kernel.org>
    Cc: Stefan Schmidt <stefan@datenfreihafen.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rafael.j.wysocki@intel.com>
    Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
    Reviewed-by: Heikki Krogerus <heikki.krogerus@linux.intel.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Link: https://lore.kernel.org/r/20190723221838.12024-2-suzuki.poulose@arm.com
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index 60b7ac56a1f5..de259b5170ab 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -23,11 +23,6 @@
 LIST_HEAD(cfg802154_rdev_list);
 int cfg802154_rdev_list_generation;
 
-static int wpan_phy_match(struct device *dev, const void *data)
-{
-	return !strcmp(dev_name(dev), (const char *)data);
-}
-
 struct wpan_phy *wpan_phy_find(const char *str)
 {
 	struct device *dev;
@@ -35,7 +30,7 @@ struct wpan_phy *wpan_phy_find(const char *str)
 	if (WARN_ON(!str))
 		return NULL;
 
-	dev = class_find_device(&wpan_phy_class, NULL, str, wpan_phy_match);
+	dev = class_find_device_by_name(&wpan_phy_class, str);
 	if (!dev)
 		return NULL;
 

commit 1802d0beecafe581ad584634ba92f8a471d8a63a
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:21 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 174
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 655 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070034.575739538@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index fe225d9a1877..60b7ac56a1f5 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -1,15 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2007, 2008, 2009 Siemens AG
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
  */
 
 #include <linux/slab.h>

commit e446a2760f1e265192accd7ddebd3ca5ff1d57bb
Author: Stephen Hemminger <stephen@networkplumber.org>
Date:   Tue Jul 24 12:29:18 2018 -0700

    net: remove blank lines at end of file
    
    Several files have extra line at end of file.
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index cb7176cd4cd6..fe225d9a1877 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -400,4 +400,3 @@ module_exit(wpan_phy_class_exit);
 MODULE_LICENSE("GPL v2");
 MODULE_DESCRIPTION("IEEE 802.15.4 configuration interface");
 MODULE_AUTHOR("Dmitry Eremin-Solenikov");
-

commit 66e5c2672cd11b9310008099faf6a4ffb9dfb6d0
Author: Alexander Aring <aar@pengutronix.de>
Date:   Sat Jun 18 10:45:34 2016 +0200

    ieee802154: add netns support
    
    This patch adds netns support for 802.15.4 subsystem. Most parts are
    copy&pasted from wireless subsystem, it has the identically userspace
    API.
    
    Cc: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Alexander Aring <aar@pengutronix.de>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index c35fdfa6d04e..cb7176cd4cd6 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -140,6 +140,8 @@ wpan_phy_new(const struct cfg802154_ops *ops, size_t priv_size)
 	rdev->wpan_phy.dev.class = &wpan_phy_class;
 	rdev->wpan_phy.dev.platform_data = rdev;
 
+	wpan_phy_net_set(&rdev->wpan_phy, &init_net);
+
 	init_waitqueue_head(&rdev->dev_wait);
 
 	return &rdev->wpan_phy;
@@ -207,6 +209,49 @@ void wpan_phy_free(struct wpan_phy *phy)
 }
 EXPORT_SYMBOL(wpan_phy_free);
 
+int cfg802154_switch_netns(struct cfg802154_registered_device *rdev,
+			   struct net *net)
+{
+	struct wpan_dev *wpan_dev;
+	int err = 0;
+
+	list_for_each_entry(wpan_dev, &rdev->wpan_dev_list, list) {
+		if (!wpan_dev->netdev)
+			continue;
+		wpan_dev->netdev->features &= ~NETIF_F_NETNS_LOCAL;
+		err = dev_change_net_namespace(wpan_dev->netdev, net, "wpan%d");
+		if (err)
+			break;
+		wpan_dev->netdev->features |= NETIF_F_NETNS_LOCAL;
+	}
+
+	if (err) {
+		/* failed -- clean up to old netns */
+		net = wpan_phy_net(&rdev->wpan_phy);
+
+		list_for_each_entry_continue_reverse(wpan_dev,
+						     &rdev->wpan_dev_list,
+						     list) {
+			if (!wpan_dev->netdev)
+				continue;
+			wpan_dev->netdev->features &= ~NETIF_F_NETNS_LOCAL;
+			err = dev_change_net_namespace(wpan_dev->netdev, net,
+						       "wpan%d");
+			WARN_ON(err);
+			wpan_dev->netdev->features |= NETIF_F_NETNS_LOCAL;
+		}
+
+		return err;
+	}
+
+	wpan_phy_net_set(&rdev->wpan_phy, net);
+
+	err = device_rename(&rdev->wpan_phy.dev, dev_name(&rdev->wpan_phy.dev));
+	WARN_ON(err);
+
+	return 0;
+}
+
 void cfg802154_dev_free(struct cfg802154_registered_device *rdev)
 {
 	kfree(rdev);
@@ -286,14 +331,34 @@ static struct notifier_block cfg802154_netdev_notifier = {
 	.notifier_call = cfg802154_netdev_notifier_call,
 };
 
+static void __net_exit cfg802154_pernet_exit(struct net *net)
+{
+	struct cfg802154_registered_device *rdev;
+
+	rtnl_lock();
+	list_for_each_entry(rdev, &cfg802154_rdev_list, list) {
+		if (net_eq(wpan_phy_net(&rdev->wpan_phy), net))
+			WARN_ON(cfg802154_switch_netns(rdev, &init_net));
+	}
+	rtnl_unlock();
+}
+
+static struct pernet_operations cfg802154_pernet_ops = {
+	.exit = cfg802154_pernet_exit,
+};
+
 static int __init wpan_phy_class_init(void)
 {
 	int rc;
 
-	rc = wpan_phy_sysfs_init();
+	rc = register_pernet_device(&cfg802154_pernet_ops);
 	if (rc)
 		goto err;
 
+	rc = wpan_phy_sysfs_init();
+	if (rc)
+		goto err_sysfs;
+
 	rc = register_netdevice_notifier(&cfg802154_netdev_notifier);
 	if (rc)
 		goto err_nl;
@@ -315,6 +380,8 @@ static int __init wpan_phy_class_init(void)
 	unregister_netdevice_notifier(&cfg802154_netdev_notifier);
 err_nl:
 	wpan_phy_sysfs_exit();
+err_sysfs:
+	unregister_pernet_device(&cfg802154_pernet_ops);
 err:
 	return rc;
 }
@@ -326,6 +393,7 @@ static void __exit wpan_phy_class_exit(void)
 	ieee802154_nl_exit();
 	unregister_netdevice_notifier(&cfg802154_netdev_notifier);
 	wpan_phy_sysfs_exit();
+	unregister_pernet_device(&cfg802154_pernet_ops);
 }
 module_exit(wpan_phy_class_exit);
 

commit a26c5fd7622d4951425131d54a8c99f076fe2068
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Sep 28 09:00:25 2015 +0200

    nl802154: add support for security layer
    
    This patch adds support for accessing mac802154 llsec implementation
    over nl802154. I added for a new Kconfig entry to provide this
    functionality CONFIG_IEEE802154_NL802154_EXPERIMENTAL. This interface is
    still in development. It provides to change security parameters and
    add/del/dump entries of security tables. Later we can add also a get to
    get an entry by unique identifier.
    
    Cc: Phoebe Buckheister <phoebe.buckheister@itwm.fraunhofer.de>
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index b0248e934230..c35fdfa6d04e 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -95,6 +95,18 @@ cfg802154_rdev_by_wpan_phy_idx(int wpan_phy_idx)
 	return result;
 }
 
+struct wpan_phy *wpan_phy_idx_to_wpan_phy(int wpan_phy_idx)
+{
+	struct cfg802154_registered_device *rdev;
+
+	ASSERT_RTNL();
+
+	rdev = cfg802154_rdev_by_wpan_phy_idx(wpan_phy_idx);
+	if (!rdev)
+		return NULL;
+	return &rdev->wpan_phy;
+}
+
 struct wpan_phy *
 wpan_phy_new(const struct cfg802154_ops *ops, size_t priv_size)
 {

commit 4a3a8c0c3a613e481bea931f0d65dc4a7efaa9b9
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Fri May 22 17:43:52 2015 +0200

    mac802154: remove pib lock
    
    This patch removes the pib lock which is now replaced by rtnl lock. The
    new interface already use the rtnl lock only. Nevertheless this patch
    will fix issues while using new and old interface at the same time.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Reviewed-by: Stefan Schmidt <stefan@osg.samsung.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index 2ee00e8a0308..b0248e934230 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -121,8 +121,6 @@ wpan_phy_new(const struct cfg802154_ops *ops, size_t priv_size)
 	/* atomic_inc_return makes it start at 1, make it start at 0 */
 	rdev->wpan_phy_idx--;
 
-	mutex_init(&rdev->wpan_phy.pib_lock);
-
 	INIT_LIST_HEAD(&rdev->wpan_dev_list);
 	device_initialize(&rdev->wpan_phy.dev);
 	dev_set_name(&rdev->wpan_phy.dev, PHY_NAME "%d", rdev->wpan_phy_idx);

commit c4dd7471de03f0e4278265e08af2923243496db0
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Mon Mar 2 15:10:04 2015 +0100

    ieee802154: change wpan-phy name to phy
    
    Currently the wpan_phy under /sys/class/ieee802154/ is named as
    "wpan-phy#", this patch will change the name to phy. This will
    introduce the same naming convention like wireless.
    
    Note: wpan-tools users will not type "wpan-phy#" anymore, just a simple
          "phy#" is enough.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index 888d0991c761..2ee00e8a0308 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -25,6 +25,9 @@
 #include "sysfs.h"
 #include "core.h"
 
+/* name for sysfs, %d is appended */
+#define PHY_NAME "phy"
+
 /* RCU-protected (and RTNL for writers) */
 LIST_HEAD(cfg802154_rdev_list);
 int cfg802154_rdev_list_generation;
@@ -122,7 +125,7 @@ wpan_phy_new(const struct cfg802154_ops *ops, size_t priv_size)
 
 	INIT_LIST_HEAD(&rdev->wpan_dev_list);
 	device_initialize(&rdev->wpan_phy.dev);
-	dev_set_name(&rdev->wpan_phy.dev, "wpan-phy%d", rdev->wpan_phy_idx);
+	dev_set_name(&rdev->wpan_phy.dev, PHY_NAME "%d", rdev->wpan_phy_idx);
 
 	rdev->wpan_phy.dev.class = &wpan_phy_class;
 	rdev->wpan_phy.dev.platform_data = rdev;

commit f9d1ce8f81eb046626cfa1bb0f419f8dca04bcae
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Thu Feb 5 18:21:30 2015 +0100

    ieee802154: fix netns settings
    
    6LoWPAN currently doesn't supports x-netns and works only in init_net.
    
    With this patch, we ensure that:
     - the wpan interface cannot be moved to another netns;
     - the 6lowpan interface cannot be moved to another netns;
     - the wpan interface is in the same netns than the 6lowpan interface;
     - the 6lowpan interface is in init_net.
    
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Acked-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index 18bc7e738507..888d0991c761 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -225,6 +225,7 @@ static int cfg802154_netdev_notifier_call(struct notifier_block *nb,
 	switch (state) {
 		/* TODO NETDEV_DEVTYPE */
 	case NETDEV_REGISTER:
+		dev->features |= NETIF_F_NETNS_LOCAL;
 		wpan_dev->identifier = ++rdev->wpan_dev_id;
 		list_add_rcu(&wpan_dev->list, &rdev->wpan_dev_list);
 		rdev->devlist_generation++;

commit ca20ce201c8d4123de0fd2b0d59ea19b0160d88f
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:54 2014 +0100

    ieee802154: add wpan_phy dump support
    
    This patch adds support for dumping wpan_phy attributes via nl802154.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index ae5ecbc2ca0a..18bc7e738507 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -27,7 +27,7 @@
 
 /* RCU-protected (and RTNL for writers) */
 LIST_HEAD(cfg802154_rdev_list);
-static int cfg802154_rdev_list_generation;
+int cfg802154_rdev_list_generation;
 
 static int wpan_phy_match(struct device *dev, const void *data)
 {

commit 79fe1a2aa7b504c68642e510154f17e2de60da60
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:53 2014 +0100

    ieee802154: add nl802154 framework
    
    This patch adds a basic nl802154 framework. Most of this code was
    grabbed from nl80211 framework.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index 3ee00bf0e514..ae5ecbc2ca0a 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -21,11 +21,12 @@
 #include <net/rtnetlink.h>
 
 #include "ieee802154.h"
+#include "nl802154.h"
 #include "sysfs.h"
 #include "core.h"
 
 /* RCU-protected (and RTNL for writers) */
-static LIST_HEAD(cfg802154_rdev_list);
+LIST_HEAD(cfg802154_rdev_list);
 static int cfg802154_rdev_list_generation;
 
 static int wpan_phy_match(struct device *dev, const void *data)
@@ -74,6 +75,23 @@ int wpan_phy_for_each(int (*fn)(struct wpan_phy *phy, void *data),
 }
 EXPORT_SYMBOL(wpan_phy_for_each);
 
+struct cfg802154_registered_device *
+cfg802154_rdev_by_wpan_phy_idx(int wpan_phy_idx)
+{
+	struct cfg802154_registered_device *result = NULL, *rdev;
+
+	ASSERT_RTNL();
+
+	list_for_each_entry(rdev, &cfg802154_rdev_list, list) {
+		if (rdev->wpan_phy_idx == wpan_phy_idx) {
+			result = rdev;
+			break;
+		}
+	}
+
+	return result;
+}
+
 struct wpan_phy *
 wpan_phy_new(const struct cfg802154_ops *ops, size_t priv_size)
 {
@@ -270,8 +288,15 @@ static int __init wpan_phy_class_init(void)
 	if (rc)
 		goto err_notifier;
 
+	rc = nl802154_init();
+	if (rc)
+		goto err_ieee802154_nl;
+
 	return 0;
 
+err_ieee802154_nl:
+	ieee802154_nl_exit();
+
 err_notifier:
 	unregister_netdevice_notifier(&cfg802154_netdev_notifier);
 err_nl:
@@ -283,6 +308,7 @@ subsys_initcall(wpan_phy_class_init);
 
 static void __exit wpan_phy_class_exit(void)
 {
+	nl802154_exit();
 	ieee802154_nl_exit();
 	unregister_netdevice_notifier(&cfg802154_netdev_notifier);
 	wpan_phy_sysfs_exit();

commit fcf39e6e88e9492f6688ec8ba4e1be622b904232
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:50 2014 +0100

    ieee802154: add wpan_dev_list
    
    This patch adds a wpan_dev_list list into cfg802154_registered_device
    struct. Also adding new wpan_dev into this list while
    cfg802154_netdev_notifier_call. This behaviour is mostly grab from
    wireless core.c implementation and is needed for preparing nl802154
    framework.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index 11a1d2ed5b26..3ee00bf0e514 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -102,12 +102,15 @@ wpan_phy_new(const struct cfg802154_ops *ops, size_t priv_size)
 
 	mutex_init(&rdev->wpan_phy.pib_lock);
 
+	INIT_LIST_HEAD(&rdev->wpan_dev_list);
 	device_initialize(&rdev->wpan_phy.dev);
 	dev_set_name(&rdev->wpan_phy.dev, "wpan-phy%d", rdev->wpan_phy_idx);
 
 	rdev->wpan_phy.dev.class = &wpan_phy_class;
 	rdev->wpan_phy.dev.platform_data = rdev;
 
+	init_waitqueue_head(&rdev->dev_wait);
+
 	return &rdev->wpan_phy;
 }
 EXPORT_SYMBOL(wpan_phy_new);
@@ -140,13 +143,18 @@ void wpan_phy_unregister(struct wpan_phy *phy)
 {
 	struct cfg802154_registered_device *rdev = wpan_phy_to_rdev(phy);
 
-	/* TODO open count */
+	wait_event(rdev->dev_wait, ({
+		int __count;
+		rtnl_lock();
+		__count = rdev->opencount;
+		rtnl_unlock();
+		__count == 0; }));
 
 	rtnl_lock();
 	/* TODO nl802154 phy notify */
 	/* TODO phy registered lock */
 
-	/* TODO WARN_ON wpan_dev_list */
+	WARN_ON(!list_empty(&rdev->wpan_dev_list));
 
 	/* First remove the hardware from everywhere, this makes
 	 * it impossible to find from userspace.
@@ -173,6 +181,79 @@ void cfg802154_dev_free(struct cfg802154_registered_device *rdev)
 	kfree(rdev);
 }
 
+static void
+cfg802154_update_iface_num(struct cfg802154_registered_device *rdev,
+			   int iftype, int num)
+{
+	ASSERT_RTNL();
+
+	rdev->num_running_ifaces += num;
+}
+
+static int cfg802154_netdev_notifier_call(struct notifier_block *nb,
+					  unsigned long state, void *ptr)
+{
+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+	struct wpan_dev *wpan_dev = dev->ieee802154_ptr;
+	struct cfg802154_registered_device *rdev;
+
+	if (!wpan_dev)
+		return NOTIFY_DONE;
+
+	rdev = wpan_phy_to_rdev(wpan_dev->wpan_phy);
+
+	/* TODO WARN_ON unspec type */
+
+	switch (state) {
+		/* TODO NETDEV_DEVTYPE */
+	case NETDEV_REGISTER:
+		wpan_dev->identifier = ++rdev->wpan_dev_id;
+		list_add_rcu(&wpan_dev->list, &rdev->wpan_dev_list);
+		rdev->devlist_generation++;
+
+		wpan_dev->netdev = dev;
+		break;
+	case NETDEV_DOWN:
+		cfg802154_update_iface_num(rdev, wpan_dev->iftype, -1);
+
+		rdev->opencount--;
+		wake_up(&rdev->dev_wait);
+		break;
+	case NETDEV_UP:
+		cfg802154_update_iface_num(rdev, wpan_dev->iftype, 1);
+
+		rdev->opencount++;
+		break;
+	case NETDEV_UNREGISTER:
+		/* It is possible to get NETDEV_UNREGISTER
+		 * multiple times. To detect that, check
+		 * that the interface is still on the list
+		 * of registered interfaces, and only then
+		 * remove and clean it up.
+		 */
+		if (!list_empty(&wpan_dev->list)) {
+			list_del_rcu(&wpan_dev->list);
+			rdev->devlist_generation++;
+		}
+		/* synchronize (so that we won't find this netdev
+		 * from other code any more) and then clear the list
+		 * head so that the above code can safely check for
+		 * !list_empty() to avoid double-cleanup.
+		 */
+		synchronize_rcu();
+		INIT_LIST_HEAD(&wpan_dev->list);
+		break;
+	default:
+		return NOTIFY_DONE;
+	}
+
+	return NOTIFY_OK;
+}
+
+static struct notifier_block cfg802154_netdev_notifier = {
+	.notifier_call = cfg802154_netdev_notifier_call,
+};
+
 static int __init wpan_phy_class_init(void)
 {
 	int rc;
@@ -181,11 +262,18 @@ static int __init wpan_phy_class_init(void)
 	if (rc)
 		goto err;
 
-	rc = ieee802154_nl_init();
+	rc = register_netdevice_notifier(&cfg802154_netdev_notifier);
 	if (rc)
 		goto err_nl;
 
+	rc = ieee802154_nl_init();
+	if (rc)
+		goto err_notifier;
+
 	return 0;
+
+err_notifier:
+	unregister_netdevice_notifier(&cfg802154_netdev_notifier);
 err_nl:
 	wpan_phy_sysfs_exit();
 err:
@@ -196,6 +284,7 @@ subsys_initcall(wpan_phy_class_init);
 static void __exit wpan_phy_class_exit(void)
 {
 	ieee802154_nl_exit();
+	unregister_netdevice_notifier(&cfg802154_netdev_notifier);
 	wpan_phy_sysfs_exit();
 }
 module_exit(wpan_phy_class_exit);

commit f3ada640c25f2d57beef79b7b98619748be3f3ca
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:48 2014 +0100

    ieee802154: add cfg802154_registered_device list
    
    This patch adds a new cfg802154_rdev_list to remember all registered
    cfg802154_registered_device structs. This is needed to prepare the
    upcomming nl802154 framework.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index a3aa23f8c36c..11a1d2ed5b26 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -18,11 +18,16 @@
 #include <linux/device.h>
 
 #include <net/cfg802154.h>
+#include <net/rtnetlink.h>
 
 #include "ieee802154.h"
 #include "sysfs.h"
 #include "core.h"
 
+/* RCU-protected (and RTNL for writers) */
+static LIST_HEAD(cfg802154_rdev_list);
+static int cfg802154_rdev_list_generation;
+
 static int wpan_phy_match(struct device *dev, const void *data)
 {
 	return !strcmp(dev_name(dev), (const char *)data);
@@ -109,13 +114,51 @@ EXPORT_SYMBOL(wpan_phy_new);
 
 int wpan_phy_register(struct wpan_phy *phy)
 {
-	return device_add(&phy->dev);
+	struct cfg802154_registered_device *rdev = wpan_phy_to_rdev(phy);
+	int ret;
+
+	rtnl_lock();
+	ret = device_add(&phy->dev);
+	if (ret) {
+		rtnl_unlock();
+		return ret;
+	}
+
+	list_add_rcu(&rdev->list, &cfg802154_rdev_list);
+	cfg802154_rdev_list_generation++;
+
+	/* TODO phy registered lock */
+	rtnl_unlock();
+
+	/* TODO nl802154 phy notify */
+
+	return 0;
 }
 EXPORT_SYMBOL(wpan_phy_register);
 
 void wpan_phy_unregister(struct wpan_phy *phy)
 {
+	struct cfg802154_registered_device *rdev = wpan_phy_to_rdev(phy);
+
+	/* TODO open count */
+
+	rtnl_lock();
+	/* TODO nl802154 phy notify */
+	/* TODO phy registered lock */
+
+	/* TODO WARN_ON wpan_dev_list */
+
+	/* First remove the hardware from everywhere, this makes
+	 * it impossible to find from userspace.
+	 */
+	list_del_rcu(&rdev->list);
+	synchronize_rcu();
+
+	cfg802154_rdev_list_generation++;
+
 	device_del(&phy->dev);
+
+	rtnl_unlock();
 }
 EXPORT_SYMBOL(wpan_phy_unregister);
 

commit f601379fa113906b8bf4389a62002def283519c9
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 9 08:36:47 2014 +0100

    ieee802154: rename wpan_phy_alloc
    
    This patch renames the wpan_phy_alloc function to wpan_phy_new. This
    naming convention is like wireless and "wiphy_new" function.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index d1cd0edfb149..a3aa23f8c36c 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -70,7 +70,7 @@ int wpan_phy_for_each(int (*fn)(struct wpan_phy *phy, void *data),
 EXPORT_SYMBOL(wpan_phy_for_each);
 
 struct wpan_phy *
-wpan_phy_alloc(const struct cfg802154_ops *ops, size_t priv_size)
+wpan_phy_new(const struct cfg802154_ops *ops, size_t priv_size)
 {
 	static atomic_t wpan_phy_counter = ATOMIC_INIT(0);
 	struct cfg802154_registered_device *rdev;
@@ -105,7 +105,7 @@ wpan_phy_alloc(const struct cfg802154_ops *ops, size_t priv_size)
 
 	return &rdev->wpan_phy;
 }
-EXPORT_SYMBOL(wpan_phy_alloc);
+EXPORT_SYMBOL(wpan_phy_new);
 
 int wpan_phy_register(struct wpan_phy *phy)
 {

commit 53f9ee61b46d81a43d8c6694d136896e8f49a7b8
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Wed Nov 5 20:51:12 2014 +0100

    ieee802154: rework wpan_phy index assignment
    
    This patch reworks the wpan_phy index incrementation. It's now similar
    like wireless wiphy index incrementation. We move the wpan_phy index
    attribute inside of cfg802154_registered_device and use atomic
    operations instead locking mechanism via wpan_phy_mutex.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index ed5b014dbec7..d1cd0edfb149 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -23,9 +23,6 @@
 #include "sysfs.h"
 #include "core.h"
 
-static DEFINE_MUTEX(wpan_phy_mutex);
-static int wpan_phy_idx;
-
 static int wpan_phy_match(struct device *dev, const void *data)
 {
 	return !strcmp(dev_name(dev), (const char *)data);
@@ -72,14 +69,10 @@ int wpan_phy_for_each(int (*fn)(struct wpan_phy *phy, void *data),
 }
 EXPORT_SYMBOL(wpan_phy_for_each);
 
-static int wpan_phy_idx_valid(int idx)
-{
-	return idx >= 0;
-}
-
 struct wpan_phy *
 wpan_phy_alloc(const struct cfg802154_ops *ops, size_t priv_size)
 {
+	static atomic_t wpan_phy_counter = ATOMIC_INIT(0);
 	struct cfg802154_registered_device *rdev;
 	size_t alloc_size;
 
@@ -90,28 +83,27 @@ wpan_phy_alloc(const struct cfg802154_ops *ops, size_t priv_size)
 
 	rdev->ops = ops;
 
-	mutex_lock(&wpan_phy_mutex);
-	rdev->wpan_phy.idx = wpan_phy_idx++;
-	if (unlikely(!wpan_phy_idx_valid(rdev->wpan_phy.idx))) {
-		wpan_phy_idx--;
-		mutex_unlock(&wpan_phy_mutex);
+	rdev->wpan_phy_idx = atomic_inc_return(&wpan_phy_counter);
+
+	if (unlikely(rdev->wpan_phy_idx < 0)) {
+		/* ugh, wrapped! */
+		atomic_dec(&wpan_phy_counter);
 		kfree(rdev);
-		goto out;
+		return NULL;
 	}
-	mutex_unlock(&wpan_phy_mutex);
+
+	/* atomic_inc_return makes it start at 1, make it start at 0 */
+	rdev->wpan_phy_idx--;
 
 	mutex_init(&rdev->wpan_phy.pib_lock);
 
 	device_initialize(&rdev->wpan_phy.dev);
-	dev_set_name(&rdev->wpan_phy.dev, "wpan-phy%d", rdev->wpan_phy.idx);
+	dev_set_name(&rdev->wpan_phy.dev, "wpan-phy%d", rdev->wpan_phy_idx);
 
 	rdev->wpan_phy.dev.class = &wpan_phy_class;
 	rdev->wpan_phy.dev.platform_data = rdev;
 
 	return &rdev->wpan_phy;
-
-out:
-	return NULL;
 }
 EXPORT_SYMBOL(wpan_phy_alloc);
 

commit a5dd1d72d868ec9c8f44d60ca29900b6a38321b4
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:35 2014 +0100

    cfg802154: introduce cfg802154_registered_device
    
    This patch introduce the cfg802154_registered_device struct. Like
    cfg80211_registered_device in wireless this should contain similar
    functionality for cfg802154. This patch should not change any behaviour.
    We just adds cfg802154_registered_device as container for wpan_phy struct.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index dc294a415d05..ed5b014dbec7 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -21,6 +21,7 @@
 
 #include "ieee802154.h"
 #include "sysfs.h"
+#include "core.h"
 
 static DEFINE_MUTEX(wpan_phy_mutex);
 static int wpan_phy_idx;
@@ -76,31 +77,38 @@ static int wpan_phy_idx_valid(int idx)
 	return idx >= 0;
 }
 
-struct wpan_phy *wpan_phy_alloc(size_t priv_size)
+struct wpan_phy *
+wpan_phy_alloc(const struct cfg802154_ops *ops, size_t priv_size)
 {
-	struct wpan_phy *phy = kzalloc(sizeof(*phy) + priv_size,
-			GFP_KERNEL);
+	struct cfg802154_registered_device *rdev;
+	size_t alloc_size;
+
+	alloc_size = sizeof(*rdev) + priv_size;
+	rdev = kzalloc(alloc_size, GFP_KERNEL);
+	if (!rdev)
+		return NULL;
+
+	rdev->ops = ops;
 
-	if (!phy)
-		goto out;
 	mutex_lock(&wpan_phy_mutex);
-	phy->idx = wpan_phy_idx++;
-	if (unlikely(!wpan_phy_idx_valid(phy->idx))) {
+	rdev->wpan_phy.idx = wpan_phy_idx++;
+	if (unlikely(!wpan_phy_idx_valid(rdev->wpan_phy.idx))) {
 		wpan_phy_idx--;
 		mutex_unlock(&wpan_phy_mutex);
-		kfree(phy);
+		kfree(rdev);
 		goto out;
 	}
 	mutex_unlock(&wpan_phy_mutex);
 
-	mutex_init(&phy->pib_lock);
+	mutex_init(&rdev->wpan_phy.pib_lock);
 
-	device_initialize(&phy->dev);
-	dev_set_name(&phy->dev, "wpan-phy%d", phy->idx);
+	device_initialize(&rdev->wpan_phy.dev);
+	dev_set_name(&rdev->wpan_phy.dev, "wpan-phy%d", rdev->wpan_phy.idx);
 
-	phy->dev.class = &wpan_phy_class;
+	rdev->wpan_phy.dev.class = &wpan_phy_class;
+	rdev->wpan_phy.dev.platform_data = rdev;
 
-	return phy;
+	return &rdev->wpan_phy;
 
 out:
 	return NULL;
@@ -125,6 +133,11 @@ void wpan_phy_free(struct wpan_phy *phy)
 }
 EXPORT_SYMBOL(wpan_phy_free);
 
+void cfg802154_dev_free(struct cfg802154_registered_device *rdev)
+{
+	kfree(rdev);
+}
+
 static int __init wpan_phy_class_init(void)
 {
 	int rc;

commit ff4e65581eb5349b7cefeda4083abe6eba44378a
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sun Nov 2 04:18:33 2014 +0100

    ieee802154: remove default channel settings
    
    This patch removes the default channel setting. A channel is always set
    and there is no default channel setting according 802.15.4.
    
    Drivers should set the default channel and page in probing routine. This
    behaviour is currently a lack of all 802.15.4 drivers.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index 620abc2ba5fc..dc294a415d05 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -100,9 +100,6 @@ struct wpan_phy *wpan_phy_alloc(size_t priv_size)
 
 	phy->dev.class = &wpan_phy_class;
 
-	phy->current_channel = -1; /* not initialised */
-	phy->current_page = 0; /* for compatibility */
-
 	return phy;
 
 out:

commit e23e9ec16bf4bbaf12fc030079b277cb00f618f4
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Tue Oct 28 18:21:32 2014 +0100

    ieee802154: introduce sysfs file
    
    This patch moves the sysfs handling in a own file. This is like wireless
    sysfs file handling.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
index 760b7d752190..620abc2ba5fc 100644
--- a/net/ieee802154/core.c
+++ b/net/ieee802154/core.c
@@ -20,72 +20,7 @@
 #include <net/cfg802154.h>
 
 #include "ieee802154.h"
-
-#define MASTER_SHOW_COMPLEX(name, format_string, args...)		\
-static ssize_t name ## _show(struct device *dev,			\
-			    struct device_attribute *attr, char *buf)	\
-{									\
-	struct wpan_phy *phy = container_of(dev, struct wpan_phy, dev);	\
-	int ret;							\
-									\
-	mutex_lock(&phy->pib_lock);					\
-	ret = snprintf(buf, PAGE_SIZE, format_string "\n", args);	\
-	mutex_unlock(&phy->pib_lock);					\
-	return ret;							\
-}									\
-static DEVICE_ATTR_RO(name)
-
-#define MASTER_SHOW(field, format_string)				\
-	MASTER_SHOW_COMPLEX(field, format_string, phy->field)
-
-MASTER_SHOW(current_channel, "%d");
-MASTER_SHOW(current_page, "%d");
-MASTER_SHOW(transmit_power, "%d +- 1 dB");
-MASTER_SHOW(cca_mode, "%d");
-
-static ssize_t channels_supported_show(struct device *dev,
-				       struct device_attribute *attr,
-				       char *buf)
-{
-	struct wpan_phy *phy = container_of(dev, struct wpan_phy, dev);
-	int ret;
-	int i, len = 0;
-
-	mutex_lock(&phy->pib_lock);
-	for (i = 0; i < 32; i++) {
-		ret = snprintf(buf + len, PAGE_SIZE - len,
-			       "%#09x\n", phy->channels_supported[i]);
-		if (ret < 0)
-			break;
-		len += ret;
-	}
-	mutex_unlock(&phy->pib_lock);
-	return len;
-}
-static DEVICE_ATTR_RO(channels_supported);
-
-static struct attribute *pmib_attrs[] = {
-	&dev_attr_current_channel.attr,
-	&dev_attr_current_page.attr,
-	&dev_attr_channels_supported.attr,
-	&dev_attr_transmit_power.attr,
-	&dev_attr_cca_mode.attr,
-	NULL,
-};
-ATTRIBUTE_GROUPS(pmib);
-
-static void wpan_phy_release(struct device *d)
-{
-	struct wpan_phy *phy = container_of(d, struct wpan_phy, dev);
-
-	kfree(phy);
-}
-
-static struct class wpan_phy_class = {
-	.name = "ieee802154",
-	.dev_release = wpan_phy_release,
-	.dev_groups = pmib_groups,
-};
+#include "sysfs.h"
 
 static DEFINE_MUTEX(wpan_phy_mutex);
 static int wpan_phy_idx;
@@ -197,7 +132,7 @@ static int __init wpan_phy_class_init(void)
 {
 	int rc;
 
-	rc = class_register(&wpan_phy_class);
+	rc = wpan_phy_sysfs_init();
 	if (rc)
 		goto err;
 
@@ -207,7 +142,7 @@ static int __init wpan_phy_class_init(void)
 
 	return 0;
 err_nl:
-	class_unregister(&wpan_phy_class);
+	wpan_phy_sysfs_exit();
 err:
 	return rc;
 }
@@ -216,7 +151,7 @@ subsys_initcall(wpan_phy_class_init);
 static void __exit wpan_phy_class_exit(void)
 {
 	ieee802154_nl_exit();
-	class_unregister(&wpan_phy_class);
+	wpan_phy_sysfs_exit();
 }
 module_exit(wpan_phy_class_exit);
 

commit 86d52cd96414f05c4053fb264a85309772c6ae26
Author: Alexander Aring <alex.aring@gmail.com>
Date:   Sat Oct 25 09:41:03 2014 +0200

    ieee802154: move wpan-class.c to core.c
    
    Like the wireless core.c file this file contains function for phy
    allocation and freeing. Move this file to core.c to get similar
    behaviour.
    
    Signed-off-by: Alexander Aring <alex.aring@gmail.com>
    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>

diff --git a/net/ieee802154/core.c b/net/ieee802154/core.c
new file mode 100644
index 000000000000..760b7d752190
--- /dev/null
+++ b/net/ieee802154/core.c
@@ -0,0 +1,226 @@
+/*
+ * Copyright (C) 2007, 2008, 2009 Siemens AG
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/device.h>
+
+#include <net/cfg802154.h>
+
+#include "ieee802154.h"
+
+#define MASTER_SHOW_COMPLEX(name, format_string, args...)		\
+static ssize_t name ## _show(struct device *dev,			\
+			    struct device_attribute *attr, char *buf)	\
+{									\
+	struct wpan_phy *phy = container_of(dev, struct wpan_phy, dev);	\
+	int ret;							\
+									\
+	mutex_lock(&phy->pib_lock);					\
+	ret = snprintf(buf, PAGE_SIZE, format_string "\n", args);	\
+	mutex_unlock(&phy->pib_lock);					\
+	return ret;							\
+}									\
+static DEVICE_ATTR_RO(name)
+
+#define MASTER_SHOW(field, format_string)				\
+	MASTER_SHOW_COMPLEX(field, format_string, phy->field)
+
+MASTER_SHOW(current_channel, "%d");
+MASTER_SHOW(current_page, "%d");
+MASTER_SHOW(transmit_power, "%d +- 1 dB");
+MASTER_SHOW(cca_mode, "%d");
+
+static ssize_t channels_supported_show(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	struct wpan_phy *phy = container_of(dev, struct wpan_phy, dev);
+	int ret;
+	int i, len = 0;
+
+	mutex_lock(&phy->pib_lock);
+	for (i = 0; i < 32; i++) {
+		ret = snprintf(buf + len, PAGE_SIZE - len,
+			       "%#09x\n", phy->channels_supported[i]);
+		if (ret < 0)
+			break;
+		len += ret;
+	}
+	mutex_unlock(&phy->pib_lock);
+	return len;
+}
+static DEVICE_ATTR_RO(channels_supported);
+
+static struct attribute *pmib_attrs[] = {
+	&dev_attr_current_channel.attr,
+	&dev_attr_current_page.attr,
+	&dev_attr_channels_supported.attr,
+	&dev_attr_transmit_power.attr,
+	&dev_attr_cca_mode.attr,
+	NULL,
+};
+ATTRIBUTE_GROUPS(pmib);
+
+static void wpan_phy_release(struct device *d)
+{
+	struct wpan_phy *phy = container_of(d, struct wpan_phy, dev);
+
+	kfree(phy);
+}
+
+static struct class wpan_phy_class = {
+	.name = "ieee802154",
+	.dev_release = wpan_phy_release,
+	.dev_groups = pmib_groups,
+};
+
+static DEFINE_MUTEX(wpan_phy_mutex);
+static int wpan_phy_idx;
+
+static int wpan_phy_match(struct device *dev, const void *data)
+{
+	return !strcmp(dev_name(dev), (const char *)data);
+}
+
+struct wpan_phy *wpan_phy_find(const char *str)
+{
+	struct device *dev;
+
+	if (WARN_ON(!str))
+		return NULL;
+
+	dev = class_find_device(&wpan_phy_class, NULL, str, wpan_phy_match);
+	if (!dev)
+		return NULL;
+
+	return container_of(dev, struct wpan_phy, dev);
+}
+EXPORT_SYMBOL(wpan_phy_find);
+
+struct wpan_phy_iter_data {
+	int (*fn)(struct wpan_phy *phy, void *data);
+	void *data;
+};
+
+static int wpan_phy_iter(struct device *dev, void *_data)
+{
+	struct wpan_phy_iter_data *wpid = _data;
+	struct wpan_phy *phy = container_of(dev, struct wpan_phy, dev);
+
+	return wpid->fn(phy, wpid->data);
+}
+
+int wpan_phy_for_each(int (*fn)(struct wpan_phy *phy, void *data),
+		      void *data)
+{
+	struct wpan_phy_iter_data wpid = {
+		.fn = fn,
+		.data = data,
+	};
+
+	return class_for_each_device(&wpan_phy_class, NULL,
+			&wpid, wpan_phy_iter);
+}
+EXPORT_SYMBOL(wpan_phy_for_each);
+
+static int wpan_phy_idx_valid(int idx)
+{
+	return idx >= 0;
+}
+
+struct wpan_phy *wpan_phy_alloc(size_t priv_size)
+{
+	struct wpan_phy *phy = kzalloc(sizeof(*phy) + priv_size,
+			GFP_KERNEL);
+
+	if (!phy)
+		goto out;
+	mutex_lock(&wpan_phy_mutex);
+	phy->idx = wpan_phy_idx++;
+	if (unlikely(!wpan_phy_idx_valid(phy->idx))) {
+		wpan_phy_idx--;
+		mutex_unlock(&wpan_phy_mutex);
+		kfree(phy);
+		goto out;
+	}
+	mutex_unlock(&wpan_phy_mutex);
+
+	mutex_init(&phy->pib_lock);
+
+	device_initialize(&phy->dev);
+	dev_set_name(&phy->dev, "wpan-phy%d", phy->idx);
+
+	phy->dev.class = &wpan_phy_class;
+
+	phy->current_channel = -1; /* not initialised */
+	phy->current_page = 0; /* for compatibility */
+
+	return phy;
+
+out:
+	return NULL;
+}
+EXPORT_SYMBOL(wpan_phy_alloc);
+
+int wpan_phy_register(struct wpan_phy *phy)
+{
+	return device_add(&phy->dev);
+}
+EXPORT_SYMBOL(wpan_phy_register);
+
+void wpan_phy_unregister(struct wpan_phy *phy)
+{
+	device_del(&phy->dev);
+}
+EXPORT_SYMBOL(wpan_phy_unregister);
+
+void wpan_phy_free(struct wpan_phy *phy)
+{
+	put_device(&phy->dev);
+}
+EXPORT_SYMBOL(wpan_phy_free);
+
+static int __init wpan_phy_class_init(void)
+{
+	int rc;
+
+	rc = class_register(&wpan_phy_class);
+	if (rc)
+		goto err;
+
+	rc = ieee802154_nl_init();
+	if (rc)
+		goto err_nl;
+
+	return 0;
+err_nl:
+	class_unregister(&wpan_phy_class);
+err:
+	return rc;
+}
+subsys_initcall(wpan_phy_class_init);
+
+static void __exit wpan_phy_class_exit(void)
+{
+	ieee802154_nl_exit();
+	class_unregister(&wpan_phy_class);
+}
+module_exit(wpan_phy_class_exit);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("IEEE 802.15.4 configuration interface");
+MODULE_AUTHOR("Dmitry Eremin-Solenikov");
+
