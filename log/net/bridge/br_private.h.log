commit 9b14d1f8a76682124c5e465196685a9833ff526e
Author: Horatiu Vultur <horatiu.vultur@microchip.com>
Date:   Sun Jun 28 15:45:16 2020 +0200

    bridge: mrp: Fix endian conversion and some other warnings
    
    The following sparse warnings are fixed:
    net/bridge/br_mrp.c:106:18: warning: incorrect type in assignment (different base types)
    net/bridge/br_mrp.c:106:18:    expected unsigned short [usertype]
    net/bridge/br_mrp.c:106:18:    got restricted __be16 [usertype]
    net/bridge/br_mrp.c:281:23: warning: incorrect type in argument 1 (different modifiers)
    net/bridge/br_mrp.c:281:23:    expected struct list_head *entry
    net/bridge/br_mrp.c:281:23:    got struct list_head [noderef] *
    net/bridge/br_mrp.c:332:28: warning: incorrect type in argument 1 (different modifiers)
    net/bridge/br_mrp.c:332:28:    expected struct list_head *new
    net/bridge/br_mrp.c:332:28:    got struct list_head [noderef] *
    net/bridge/br_mrp.c:332:40: warning: incorrect type in argument 2 (different modifiers)
    net/bridge/br_mrp.c:332:40:    expected struct list_head *head
    net/bridge/br_mrp.c:332:40:    got struct list_head [noderef] *
    net/bridge/br_mrp.c:682:29: warning: incorrect type in argument 1 (different modifiers)
    net/bridge/br_mrp.c:682:29:    expected struct list_head const *head
    net/bridge/br_mrp.c:682:29:    got struct list_head [noderef] *
    
    Reported-by: kernel test robot <lkp@intel.com>
    Fixes: 2f1a11ae11d222 ("bridge: mrp: Add MRP interface.")
    Fixes: 4b8d7d4c599182 ("bridge: mrp: Extend bridge interface")
    Fixes: 9a9f26e8f7ea30 ("bridge: mrp: Connect MRP API with the switchdev API")
    Signed-off-by: Horatiu Vultur <horatiu.vultur@microchip.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2130fe0194e6..e0ea6dbbc97e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -430,7 +430,7 @@ struct net_bridge {
 	struct hlist_head		fdb_list;
 
 #if IS_ENABLED(CONFIG_BRIDGE_MRP)
-	struct list_head		__rcu mrp_list;
+	struct list_head		mrp_list;
 #endif
 };
 

commit 206e732323c2a8e6d11f4125a62c27e60a50a850
Author: Thomas Martitz <t.martitz@avm.de>
Date:   Thu Jun 25 14:26:03 2020 +0200

    net: bridge: enfore alignment for ethernet address
    
    The eth_addr member is passed to ether_addr functions that require
    2-byte alignment, therefore the member must be properly aligned
    to avoid unaligned accesses.
    
    The problem is in place since the initial merge of multicast to unicast:
    commit 6db6f0eae6052b70885562e1733896647ec1d807 bridge: multicast to unicast
    
    Fixes: 6db6f0eae605 ("bridge: multicast to unicast")
    Cc: Roopa Prabhu <roopa@cumulusnetworks.com>
    Cc: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Jakub Kicinski <kuba@kernel.org>
    Cc: Felix Fietkau <nbd@nbd.name>
    Signed-off-by: Thomas Martitz <t.martitz@avm.de>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 7501be4eeba0..2130fe0194e6 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -217,8 +217,8 @@ struct net_bridge_port_group {
 	struct rcu_head			rcu;
 	struct timer_list		timer;
 	struct br_ip			addr;
+	unsigned char			eth_addr[ETH_ALEN] __aligned(2);
 	unsigned char			flags;
-	unsigned char			eth_addr[ETH_ALEN];
 };
 
 struct net_bridge_mdb_entry {

commit 9eb8eff0cf2f1e1afc0756bb30cb9746ba90dd07
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sun May 10 19:37:40 2020 +0300

    net: bridge: allow enslaving some DSA master network devices
    
    Commit 8db0a2ee2c63 ("net: bridge: reject DSA-enabled master netdevices
    as bridge members") added a special check in br_if.c in order to check
    for a DSA master network device with a tagging protocol configured. This
    was done because back then, such devices, once enslaved in a bridge
    would become inoperative and would not pass DSA tagged traffic anymore
    due to br_handle_frame returning RX_HANDLER_CONSUMED.
    
    But right now we have valid use cases which do require bridging of DSA
    masters. One such example is when the DSA master ports are DSA switch
    ports themselves (in a disjoint tree setup). This should be completely
    equivalent, functionally speaking, from having multiple DSA switches
    hanging off of the ports of a switchdev driver. So we should allow the
    enslaving of DSA tagged master network devices.
    
    Instead of the regular br_handle_frame(), install a new function
    br_handle_frame_dummy() on these DSA masters, which returns
    RX_HANDLER_PASS in order to call into the DSA specific tagging protocol
    handlers, and lift the restriction from br_add_if.
    
    Suggested-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Suggested-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 4dc21e8f7e33..7501be4eeba0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -702,16 +702,16 @@ int nbp_backup_change(struct net_bridge_port *p, struct net_device *backup_dev);
 
 /* br_input.c */
 int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb);
-rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
+rx_handler_func_t *br_get_rx_handler(const struct net_device *dev);
 
 static inline bool br_rx_handler_check_rcu(const struct net_device *dev)
 {
-	return rcu_dereference(dev->rx_handler) == br_handle_frame;
+	return rcu_dereference(dev->rx_handler) == br_get_rx_handler(dev);
 }
 
 static inline bool br_rx_handler_check_rtnl(const struct net_device *dev)
 {
-	return rcu_dereference_rtnl(dev->rx_handler) == br_handle_frame;
+	return rcu_dereference_rtnl(dev->rx_handler) == br_get_rx_handler(dev);
 }
 
 static inline struct net_bridge_port *br_port_get_check_rcu(const struct net_device *dev)

commit f78ed2204db9fc35b545d693865bddbe0149aa1f
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu May 7 09:32:21 2020 -0700

    netpoll: accept NULL np argument in netpoll_send_skb()
    
    netpoll_send_skb() callers seem to leak skb if
    the np pointer is NULL. While this should not happen, we
    can make the code more robust.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 78d3a951180d..4dc21e8f7e33 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -598,10 +598,7 @@ netdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev);
 static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 				       struct sk_buff *skb)
 {
-	struct netpoll *np = p->np;
-
-	if (np)
-		netpoll_send_skb(np, skb);
+	netpoll_send_skb(p->np, skb);
 }
 
 int br_netpoll_enable(struct net_bridge_port *p);

commit 8741e18419bf4b9e3b02c0ed01ea13f1aa497fa7
Author: Jason Yan <yanaijie@huawei.com>
Date:   Wed May 6 14:16:16 2020 +0800

    net: bridge: return false in br_mrp_enabled()
    
    Fix the following coccicheck warning:
    
    net/bridge/br_private.h:1334:8-9: WARNING: return of 0/1 in function
    'br_mrp_enabled' with return type bool
    
    Fixes: 6536993371fab ("bridge: mrp: Integrate MRP into the bridge")
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c35647cb138a..78d3a951180d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1331,7 +1331,7 @@ static inline int br_mrp_process(struct net_bridge_port *p, struct sk_buff *skb)
 
 static inline bool br_mrp_enabled(struct net_bridge *br)
 {
-	return 0;
+	return false;
 }
 
 static inline void br_mrp_port_del(struct net_bridge *br,

commit 419dba8a49d7cc355e5b495d20dea8217369ed63
Author: Horatiu Vultur <horatiu.vultur@microchip.com>
Date:   Sun Apr 26 15:22:08 2020 +0200

    net: bridge: Add checks for enabling the STP.
    
    It is not possible to have the MRP and STP running at the same time on the
    bridge, therefore add check when enabling the STP to check if MRP is already
    enabled. In that case return error.
    
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Horatiu Vultur <horatiu.vultur@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 5835828320b6..c35647cb138a 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1283,7 +1283,8 @@ int br_set_ageing_time(struct net_bridge *br, clock_t ageing_time);
 /* br_stp_if.c */
 void br_stp_enable_bridge(struct net_bridge *br);
 void br_stp_disable_bridge(struct net_bridge *br);
-void br_stp_set_enabled(struct net_bridge *br, unsigned long val);
+int br_stp_set_enabled(struct net_bridge *br, unsigned long val,
+		       struct netlink_ext_ack *extack);
 void br_stp_enable_port(struct net_bridge_port *p);
 void br_stp_disable_port(struct net_bridge_port *p);
 bool br_stp_recalculate_bridge_id(struct net_bridge *br);

commit 6536993371fab3de4e8379649b60e94d03e6ff37
Author: Horatiu Vultur <horatiu.vultur@microchip.com>
Date:   Sun Apr 26 15:22:07 2020 +0200

    bridge: mrp: Integrate MRP into the bridge
    
    To integrate MRP into the bridge, the bridge needs to do the following:
    - detect if the MRP frame was received on MRP ring port in that case it would be
      processed otherwise just forward it as usual.
    - enable parsing of MRP
    - before whenever the bridge was set up, it would set all the ports in
      forwarding state. Add an extra check to not set ports in forwarding state if
      the port is an MRP ring port. The reason of this change is that if the MRP
      instance initially sets the port in blocked state by setting the bridge up it
      would overwrite this setting.
    
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Horatiu Vultur <horatiu.vultur@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 835a70f8d3ea..5835828320b6 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1308,6 +1308,37 @@ unsigned long br_timer_value(const struct timer_list *timer);
 extern int (*br_fdb_test_addr_hook)(struct net_device *dev, unsigned char *addr);
 #endif
 
+/* br_mrp.c */
+#if IS_ENABLED(CONFIG_BRIDGE_MRP)
+int br_mrp_parse(struct net_bridge *br, struct net_bridge_port *p,
+		 struct nlattr *attr, int cmd, struct netlink_ext_ack *extack);
+int br_mrp_process(struct net_bridge_port *p, struct sk_buff *skb);
+bool br_mrp_enabled(struct net_bridge *br);
+void br_mrp_port_del(struct net_bridge *br, struct net_bridge_port *p);
+#else
+static inline int br_mrp_parse(struct net_bridge *br, struct net_bridge_port *p,
+			       struct nlattr *attr, int cmd,
+			       struct netlink_ext_ack *extack)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int br_mrp_process(struct net_bridge_port *p, struct sk_buff *skb)
+{
+	return 0;
+}
+
+static inline bool br_mrp_enabled(struct net_bridge *br)
+{
+	return 0;
+}
+
+static inline void br_mrp_port_del(struct net_bridge *br,
+				   struct net_bridge_port *p)
+{
+}
+#endif
+
 /* br_netlink.c */
 extern struct rtnl_link_ops br_link_ops;
 int br_netlink_init(void);

commit 4b8d7d4c599182393421c190bae3604b4db9629a
Author: Horatiu Vultur <horatiu.vultur@microchip.com>
Date:   Sun Apr 26 15:22:00 2020 +0200

    bridge: mrp: Extend bridge interface
    
    To integrate MRP into the bridge, first the bridge needs to be aware of ports
    that are part of an MRP ring and which rings are on the bridge.
    Therefore extend bridge interface with the following:
    - add new flag(BR_MPP_AWARE) to the net bridge ports, this bit will be
      set when the port is added to an MRP instance. In this way it knows if
      the frame was received on MRP ring port
    - add new flag(BR_MRP_LOST_CONT) to the net bridge ports, this bit will be set
      when the port lost the continuity of MRP Test frames.
    - add a list of MRP instances
    
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Horatiu Vultur <horatiu.vultur@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1f97703a52ff..835a70f8d3ea 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -428,6 +428,10 @@ struct net_bridge {
 	int offload_fwd_mark;
 #endif
 	struct hlist_head		fdb_list;
+
+#if IS_ENABLED(CONFIG_BRIDGE_MRP)
+	struct list_head		__rcu mrp_list;
+#endif
 };
 
 struct br_input_skb_cb {

commit 99f7c5e0960dfaabb5c685bab2ab8a1fc163b8e6
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Mar 17 14:08:33 2020 +0200

    net: bridge: vlan options: rename br_vlan_opts_eq to br_vlan_opts_eq_range
    
    It is more appropriate name as it shows the intent of why we need to
    check the options' state. It also allows us to give meaning to the two
    arguments of the function: the first is the current vlan (v_curr) being
    checked if it could enter the range ending in the second one (range_end).
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 5153ffe79a01..1f97703a52ff 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1199,8 +1199,8 @@ static inline void br_vlan_notify(const struct net_bridge *br,
 
 /* br_vlan_options.c */
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
-bool br_vlan_opts_eq(const struct net_bridge_vlan *v1,
-		     const struct net_bridge_vlan *v2);
+bool br_vlan_opts_eq_range(const struct net_bridge_vlan *v_curr,
+			   const struct net_bridge_vlan *range_end);
 bool br_vlan_opts_fill(struct sk_buff *skb, const struct net_bridge_vlan *v);
 size_t br_vlan_opts_nl_size(void);
 int br_vlan_process_options(const struct net_bridge *br,

commit a580c76d534c7360ba68042b19cb255e8420e987
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Jan 24 13:40:22 2020 +0200

    net: bridge: vlan: add per-vlan state
    
    The first per-vlan option added is state, it is needed for EVPN and for
    per-vlan STP. The state allows to control the forwarding on per-vlan
    basis. The vlan state is considered only if the port state is forwarding
    in order to avoid conflicts and be consistent. br_allowed_egress is
    called only when the state is forwarding, but the ingress case is a bit
    more complicated due to the fact that we may have the transition between
    port:BR_STATE_FORWARDING -> vlan:BR_STATE_LEARNING which should still
    allow the bridge to learn from the packet after vlan filtering and it will
    be dropped after that. Also to optimize the pvid state check we keep a
    copy in the vlan group to avoid one lookup. The state members are
    modified with *_ONCE() to annotate the lockless access.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 084904ee22a8..5153ffe79a01 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -113,6 +113,7 @@ enum {
  * @vid: VLAN id
  * @flags: bridge vlan flags
  * @priv_flags: private (in-kernel) bridge vlan flags
+ * @state: STP state (e.g. blocking, learning, forwarding)
  * @stats: per-cpu VLAN statistics
  * @br: if MASTER flag set, this points to a bridge struct
  * @port: if MASTER flag unset, this points to a port struct
@@ -133,6 +134,7 @@ struct net_bridge_vlan {
 	u16				vid;
 	u16				flags;
 	u16				priv_flags;
+	u8				state;
 	struct br_vlan_stats __percpu	*stats;
 	union {
 		struct net_bridge	*br;
@@ -157,6 +159,7 @@ struct net_bridge_vlan {
  * @vlan_list: sorted VLAN entry list
  * @num_vlans: number of total VLAN entries
  * @pvid: PVID VLAN id
+ * @pvid_state: PVID's STP state (e.g. forwarding, learning, blocking)
  *
  * IMPORTANT: Be careful when checking if there're VLAN entries using list
  *            primitives because the bridge can have entries in its list which
@@ -170,6 +173,7 @@ struct net_bridge_vlan_group {
 	struct list_head		vlan_list;
 	u16				num_vlans;
 	u16				pvid;
+	u8				pvid_state;
 };
 
 /* bridge fdb flags */
@@ -935,7 +939,7 @@ static inline int br_multicast_igmp_type(const struct sk_buff *skb)
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 bool br_allowed_ingress(const struct net_bridge *br,
 			struct net_bridge_vlan_group *vg, struct sk_buff *skb,
-			u16 *vid);
+			u16 *vid, u8 *state);
 bool br_allowed_egress(struct net_bridge_vlan_group *vg,
 		       const struct sk_buff *skb);
 bool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid);
@@ -1037,7 +1041,7 @@ static inline u16 br_vlan_flags(const struct net_bridge_vlan *v, u16 pvid)
 static inline bool br_allowed_ingress(const struct net_bridge *br,
 				      struct net_bridge_vlan_group *vg,
 				      struct sk_buff *skb,
-				      u16 *vid)
+				      u16 *vid, u8 *state)
 {
 	return true;
 }
@@ -1205,6 +1209,41 @@ int br_vlan_process_options(const struct net_bridge *br,
 			    struct net_bridge_vlan *range_end,
 			    struct nlattr **tb,
 			    struct netlink_ext_ack *extack);
+
+/* vlan state manipulation helpers using *_ONCE to annotate lock-free access */
+static inline u8 br_vlan_get_state(const struct net_bridge_vlan *v)
+{
+	return READ_ONCE(v->state);
+}
+
+static inline void br_vlan_set_state(struct net_bridge_vlan *v, u8 state)
+{
+	WRITE_ONCE(v->state, state);
+}
+
+static inline u8 br_vlan_get_pvid_state(const struct net_bridge_vlan_group *vg)
+{
+	return READ_ONCE(vg->pvid_state);
+}
+
+static inline void br_vlan_set_pvid_state(struct net_bridge_vlan_group *vg,
+					  u8 state)
+{
+	WRITE_ONCE(vg->pvid_state, state);
+}
+
+/* learn_allow is true at ingress and false at egress */
+static inline bool br_vlan_state_allowed(u8 state, bool learn_allow)
+{
+	switch (state) {
+	case BR_STATE_LEARNING:
+		return learn_allow;
+	case BR_STATE_FORWARDING:
+		return true;
+	default:
+		return false;
+	}
+}
 #endif
 
 struct nf_br_ops {

commit a5d29ae226812ae620f58a0726525d8af9b1d751
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Jan 24 13:40:21 2020 +0200

    net: bridge: vlan: add basic option setting support
    
    This patch adds support for option modification of single vlans and
    ranges. It allows to only modify options, i.e. skip create/delete by
    using the BRIDGE_VLAN_INFO_ONLY_OPTS flag. When working with a range
    option changes we try to pack the notifications as much as possible.
    
    v2: do full port (all vlans) notification only when creating/deleting
        vlans for compatibility, rework the range detection when changing
        options, add more verbose extack errors and check if a vlan should
        be used (br_vlan_should_use checks)
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 403df71d2cfa..084904ee22a8 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -976,6 +976,8 @@ void br_vlan_notify(const struct net_bridge *br,
 		    const struct net_bridge_port *p,
 		    u16 vid, u16 vid_range,
 		    int cmd);
+bool br_vlan_can_enter_range(const struct net_bridge_vlan *v_curr,
+			     const struct net_bridge_vlan *range_end);
 
 static inline struct net_bridge_vlan_group *br_vlan_group(
 					const struct net_bridge *br)
@@ -1197,6 +1199,12 @@ bool br_vlan_opts_eq(const struct net_bridge_vlan *v1,
 		     const struct net_bridge_vlan *v2);
 bool br_vlan_opts_fill(struct sk_buff *skb, const struct net_bridge_vlan *v);
 size_t br_vlan_opts_nl_size(void);
+int br_vlan_process_options(const struct net_bridge *br,
+			    const struct net_bridge_port *p,
+			    struct net_bridge_vlan *range_start,
+			    struct net_bridge_vlan *range_end,
+			    struct nlattr **tb,
+			    struct netlink_ext_ack *extack);
 #endif
 
 struct nf_br_ops {

commit 7a53e718c551752924416b33235bf338729b5115
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Jan 24 13:40:20 2020 +0200

    net: bridge: vlan: add basic option dumping support
    
    We'll be dumping the options for the whole range if they're equal. The
    first range vlan will be used to extract the options. The commit doesn't
    change anything yet it just adds the skeleton for the support. The dump
    will happen when the first option is added.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index a6226ff2f0cc..403df71d2cfa 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1191,6 +1191,14 @@ static inline void br_vlan_notify(const struct net_bridge *br,
 }
 #endif
 
+/* br_vlan_options.c */
+#ifdef CONFIG_BRIDGE_VLAN_FILTERING
+bool br_vlan_opts_eq(const struct net_bridge_vlan *v1,
+		     const struct net_bridge_vlan *v2);
+bool br_vlan_opts_fill(struct sk_buff *skb, const struct net_bridge_vlan *v);
+size_t br_vlan_opts_nl_size(void);
+#endif
+
 struct nf_br_ops {
 	int (*br_dev_xmit_hook)(struct sk_buff *skb);
 };

commit f545923b4a6bd7abedac50ea3fce76c713be1b74
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Jan 14 19:56:14 2020 +0200

    net: bridge: vlan: notify on vlan add/delete/change flags
    
    Now that we can notify, send a notification on add/del or change of flags.
    Notifications are also compressed when possible to reduce their number
    and relieve user-space of extra processing, due to that we have to
    manually notify after each add/del in order to avoid double
    notifications. We try hard to notify only about the vlans which actually
    changed, thus a single command can result in multiple notifications
    about disjoint ranges if there were vlans which didn't change inside.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ba162c8197da..a6226ff2f0cc 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -554,6 +554,18 @@ static inline bool br_vlan_valid_range(const struct bridge_vlan_info *cur,
 	return true;
 }
 
+static inline int br_afspec_cmd_to_rtm(int cmd)
+{
+	switch (cmd) {
+	case RTM_SETLINK:
+		return RTM_NEWVLAN;
+	case RTM_DELLINK:
+		return RTM_DELVLAN;
+	}
+
+	return 0;
+}
+
 static inline int br_opt_get(const struct net_bridge *br,
 			     enum net_bridge_opts opt)
 {

commit cf5bddb95cbe5340e486e84d46cf2f0bb324078c
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Jan 14 19:56:13 2020 +0200

    net: bridge: vlan: add rtnetlink group and notify support
    
    Add a new rtnetlink group for bridge vlan notifications - RTNLGRP_BRVLAN
    and add support for sending vlan notifications (both single and ranges).
    No functional changes intended, the notification support will be used by
    later patches.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ee3871dea68f..ba162c8197da 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -960,6 +960,10 @@ int br_vlan_bridge_event(struct net_device *dev, unsigned long event,
 			 void *ptr);
 void br_vlan_rtnl_init(void);
 void br_vlan_rtnl_uninit(void);
+void br_vlan_notify(const struct net_bridge *br,
+		    const struct net_bridge_port *p,
+		    u16 vid, u16 vid_range,
+		    int cmd);
 
 static inline struct net_bridge_vlan_group *br_vlan_group(
 					const struct net_bridge *br)
@@ -1166,6 +1170,13 @@ static inline void br_vlan_rtnl_init(void)
 static inline void br_vlan_rtnl_uninit(void)
 {
 }
+
+static inline void br_vlan_notify(const struct net_bridge *br,
+				  const struct net_bridge_port *p,
+				  u16 vid, u16 vid_range,
+				  int cmd)
+{
+}
 #endif
 
 struct nf_br_ops {

commit f26b296585dca043d78f13ef67cb17fb200d5e57
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Jan 14 19:56:10 2020 +0200

    net: bridge: vlan: add new rtm message support
    
    Add initial RTM_NEWVLAN support which can only create vlans, operating
    similar to the current br_afspec(). We will use it later to also change
    per-vlan options. Old-style (flag-based) vlan ranges are not allowed
    when using RTM messages, we will introduce vlan ranges later via a new
    nested attribute which would allow us to have all the information about a
    range encapsulated into a single nl attribute.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1c00411ae938..ee3871dea68f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1237,6 +1237,12 @@ int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags,
 int br_dellink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags);
 int br_getlink(struct sk_buff *skb, u32 pid, u32 seq, struct net_device *dev,
 	       u32 filter_mask, int nlflags);
+int br_process_vlan_info(struct net_bridge *br,
+			 struct net_bridge_port *p, int cmd,
+			 struct bridge_vlan_info *vinfo_curr,
+			 struct bridge_vlan_info **vinfo_last,
+			 bool *changed,
+			 struct netlink_ext_ack *extack);
 
 #ifdef CONFIG_SYSFS
 /* br_sysfs_if.c */

commit 8dcea187088bce5d2f1149294ad109f022653547
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Jan 14 19:56:09 2020 +0200

    net: bridge: vlan: add rtm definitions and dump support
    
    This patch adds vlan rtm definitions:
     - NEWVLAN: to be used for creating vlans, setting options and
       notifications
     - DELVLAN: to be used for deleting vlans
     - GETVLAN: used for dumping vlan information
    
    Dumping vlans which can span multiple messages is added now with basic
    information (vid and flags). We use nlmsg_parse() to validate the header
    length in order to be able to extend the message with filtering
    attributes later.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index a7dddc5d7790..1c00411ae938 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -958,6 +958,8 @@ void br_vlan_get_stats(const struct net_bridge_vlan *v,
 void br_vlan_port_event(struct net_bridge_port *p, unsigned long event);
 int br_vlan_bridge_event(struct net_device *dev, unsigned long event,
 			 void *ptr);
+void br_vlan_rtnl_init(void);
+void br_vlan_rtnl_uninit(void);
 
 static inline struct net_bridge_vlan_group *br_vlan_group(
 					const struct net_bridge *br)
@@ -1009,6 +1011,10 @@ static inline u16 br_get_pvid(const struct net_bridge_vlan_group *vg)
 	return vg->pvid;
 }
 
+static inline u16 br_vlan_flags(const struct net_bridge_vlan *v, u16 pvid)
+{
+	return v->vid == pvid ? v->flags | BRIDGE_VLAN_INFO_PVID : v->flags;
+}
 #else
 static inline bool br_allowed_ingress(const struct net_bridge *br,
 				      struct net_bridge_vlan_group *vg,
@@ -1152,6 +1158,14 @@ static inline int br_vlan_bridge_event(struct net_device *dev,
 {
 	return 0;
 }
+
+static inline void br_vlan_rtnl_init(void)
+{
+}
+
+static inline void br_vlan_rtnl_uninit(void)
+{
+}
 #endif
 
 struct nf_br_ops {

commit 8f4cc940a149b9fe013a191d6d8dc87aee9a204f
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Jan 14 19:56:08 2020 +0200

    net: bridge: netlink: add extack error messages when processing vlans
    
    Add extack messages on vlan processing errors. We need to move the flags
    missing check after the "last" check since we may have "last" set but
    lack a range end flag in the next entry.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index dbc0089e2c1a..a7dddc5d7790 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -507,32 +507,48 @@ static inline bool nbp_state_should_learn(const struct net_bridge_port *p)
 	return p->state == BR_STATE_LEARNING || p->state == BR_STATE_FORWARDING;
 }
 
-static inline bool br_vlan_valid_id(u16 vid)
+static inline bool br_vlan_valid_id(u16 vid, struct netlink_ext_ack *extack)
 {
-	return vid > 0 && vid < VLAN_VID_MASK;
+	bool ret = vid > 0 && vid < VLAN_VID_MASK;
+
+	if (!ret)
+		NL_SET_ERR_MSG_MOD(extack, "Vlan id is invalid");
+
+	return ret;
 }
 
 static inline bool br_vlan_valid_range(const struct bridge_vlan_info *cur,
-				       const struct bridge_vlan_info *last)
+				       const struct bridge_vlan_info *last,
+				       struct netlink_ext_ack *extack)
 {
 	/* pvid flag is not allowed in ranges */
-	if (cur->flags & BRIDGE_VLAN_INFO_PVID)
-		return false;
-
-	/* check for required range flags */
-	if (!(cur->flags & (BRIDGE_VLAN_INFO_RANGE_BEGIN |
-			    BRIDGE_VLAN_INFO_RANGE_END)))
+	if (cur->flags & BRIDGE_VLAN_INFO_PVID) {
+		NL_SET_ERR_MSG_MOD(extack, "Pvid isn't allowed in a range");
 		return false;
+	}
 
 	/* when cur is the range end, check if:
 	 *  - it has range start flag
 	 *  - range ids are invalid (end is equal to or before start)
 	 */
 	if (last) {
-		if (cur->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN)
+		if (cur->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN) {
+			NL_SET_ERR_MSG_MOD(extack, "Found a new vlan range start while processing one");
 			return false;
-		else if (cur->vid <= last->vid)
+		} else if (!(cur->flags & BRIDGE_VLAN_INFO_RANGE_END)) {
+			NL_SET_ERR_MSG_MOD(extack, "Vlan range end flag is missing");
 			return false;
+		} else if (cur->vid <= last->vid) {
+			NL_SET_ERR_MSG_MOD(extack, "End vlan id is less than or equal to start vlan id");
+			return false;
+		}
+	}
+
+	/* check for required range flags */
+	if (!(cur->flags & (BRIDGE_VLAN_INFO_RANGE_BEGIN |
+			    BRIDGE_VLAN_INFO_RANGE_END))) {
+		NL_SET_ERR_MSG_MOD(extack, "Both vlan range flags are missing");
+		return false;
 	}
 
 	return true;

commit 5a46facbbcd454985992b5109185329aebf82a02
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Jan 14 19:56:07 2020 +0200

    net: bridge: vlan: add helpers to check for vlan id/range validity
    
    Add helpers to check if a vlan id or range are valid. The range helper
    must be called when range start or end are detected.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f540f3bdf294..dbc0089e2c1a 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -507,6 +507,37 @@ static inline bool nbp_state_should_learn(const struct net_bridge_port *p)
 	return p->state == BR_STATE_LEARNING || p->state == BR_STATE_FORWARDING;
 }
 
+static inline bool br_vlan_valid_id(u16 vid)
+{
+	return vid > 0 && vid < VLAN_VID_MASK;
+}
+
+static inline bool br_vlan_valid_range(const struct bridge_vlan_info *cur,
+				       const struct bridge_vlan_info *last)
+{
+	/* pvid flag is not allowed in ranges */
+	if (cur->flags & BRIDGE_VLAN_INFO_PVID)
+		return false;
+
+	/* check for required range flags */
+	if (!(cur->flags & (BRIDGE_VLAN_INFO_RANGE_BEGIN |
+			    BRIDGE_VLAN_INFO_RANGE_END)))
+		return false;
+
+	/* when cur is the range end, check if:
+	 *  - it has range start flag
+	 *  - range ids are invalid (end is equal to or before start)
+	 */
+	if (last) {
+		if (cur->flags & BRIDGE_VLAN_INFO_RANGE_BEGIN)
+			return false;
+		else if (cur->vid <= last->vid)
+			return false;
+	}
+
+	return true;
+}
+
 static inline int br_opt_get(const struct net_bridge *br,
 			     enum net_bridge_opts opt)
 {

commit de1799667b002331609e8ee6b924ccfd51968d99
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Wed Dec 11 20:07:10 2019 -0500

    net: bridge: add STP xstats
    
    This adds rx_bpdu, tx_bpdu, rx_tcn, tx_tcn, transition_blk,
    transition_fwd xstats counters to the bridge ports copied over via
    netlink, providing useful information for STP.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 36b0367ca1e0..f540f3bdf294 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -283,6 +283,8 @@ struct net_bridge_port {
 #endif
 	u16				group_fwd_mask;
 	u16				backup_redirected_cnt;
+
+	struct bridge_stp_xstats	stp_xstats;
 };
 
 #define kobj_to_brport(obj)	container_of(obj, struct net_bridge_port, kobj)

commit 5d1fcaf35d74b4188d238e46f0be37c14a01f169
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Mon Nov 4 11:36:51 2019 +0200

    net: bridge: fdb: eliminate extra port state tests from fast-path
    
    When commit df1c0b8468b3 ("[BRIDGE]: Packets leaking out of
    disabled/blocked ports.") introduced the port state tests in
    br_fdb_update() it was to avoid learning/refreshing from STP BPDUs, it was
    also used to avoid learning/refreshing from user-space with NTF_USE. Those
    two tests are done for every packet entering the bridge if it's learning,
    but for the fast-path we already have them checked in br_handle_frame() and
    is unnecessary to do it again. Thus push the checks to the unlikely cases
    and drop them from br_fdb_update(), the new nbp_state_should_learn() helper
    is used to determine if the port state allows br_fdb_update() to be called.
    The two places which need to do it manually are:
     - user-space add call with NTF_USE set
     - link-local packet learning done in __br_handle_local_finish()
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 08742bff9bf0..36b0367ca1e0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -500,6 +500,11 @@ static inline bool br_vlan_should_use(const struct net_bridge_vlan *v)
 	return true;
 }
 
+static inline bool nbp_state_should_learn(const struct net_bridge_port *p)
+{
+	return p->state == BR_STATE_LEARNING || p->state == BR_STATE_FORWARDING;
+}
+
 static inline int br_opt_get(const struct net_bridge *br,
 			     enum net_bridge_opts opt)
 {

commit be0c5677970d4f21dc701136a178437aad9983b2
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Nov 1 14:46:37 2019 +0200

    net: bridge: fdb: br_fdb_update can take flags directly
    
    If we modify br_fdb_update() to take flags directly we can get rid of
    one test and one atomic bitop in the learning path.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f4754bf7f4bd..08742bff9bf0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -571,7 +571,7 @@ int br_fdb_fillbuf(struct net_bridge *br, void *buf, unsigned long count,
 int br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
 		  const unsigned char *addr, u16 vid);
 void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
-		   const unsigned char *addr, u16 vid, bool added_by_user);
+		   const unsigned char *addr, u16 vid, unsigned long flags);
 
 int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 		  struct net_device *dev, const unsigned char *addr, u16 vid);

commit d38c6e3db0c4314efadf53ddcf98345a4b115f31
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Oct 29 13:45:58 2019 +0200

    net: bridge: fdb: convert offloaded to use bitops
    
    Convert the offloaded field to a flag and use bitops.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index cf325177a34e..f4754bf7f4bd 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -179,6 +179,7 @@ enum {
 	BR_FDB_STICKY,
 	BR_FDB_ADDED_BY_USER,
 	BR_FDB_ADDED_BY_EXT_LEARN,
+	BR_FDB_OFFLOADED,
 };
 
 struct net_bridge_fdb_key {
@@ -193,7 +194,6 @@ struct net_bridge_fdb_entry {
 	struct net_bridge_fdb_key	key;
 	struct hlist_node		fdb_node;
 	unsigned long			flags;
-	unsigned char			offloaded:1;
 
 	/* write-heavy members should not affect lookups */
 	unsigned long			updated ____cacheline_aligned_in_smp;

commit b5cd9f7c42480ede119a390607a9dbe6263f6795
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Oct 29 13:45:57 2019 +0200

    net: bridge: fdb: convert added_by_external_learn to use bitops
    
    Convert the added_by_external_learn field to a flag and use bitops.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index bf4a4d1cc3bb..cf325177a34e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -178,6 +178,7 @@ enum {
 	BR_FDB_STATIC,
 	BR_FDB_STICKY,
 	BR_FDB_ADDED_BY_USER,
+	BR_FDB_ADDED_BY_EXT_LEARN,
 };
 
 struct net_bridge_fdb_key {
@@ -192,8 +193,7 @@ struct net_bridge_fdb_entry {
 	struct net_bridge_fdb_key	key;
 	struct hlist_node		fdb_node;
 	unsigned long			flags;
-	unsigned char			added_by_external_learn:1,
-					offloaded:1;
+	unsigned char			offloaded:1;
 
 	/* write-heavy members should not affect lookups */
 	unsigned long			updated ____cacheline_aligned_in_smp;

commit ac3ca6af443aa495c7907e5010ac77fbd2450eaa
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Oct 29 13:45:56 2019 +0200

    net: bridge: fdb: convert added_by_user to bitops
    
    Straight-forward convert of the added_by_user field to bitops.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 296f2f12c232..bf4a4d1cc3bb 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -177,6 +177,7 @@ enum {
 	BR_FDB_LOCAL,
 	BR_FDB_STATIC,
 	BR_FDB_STICKY,
+	BR_FDB_ADDED_BY_USER,
 };
 
 struct net_bridge_fdb_key {
@@ -191,8 +192,7 @@ struct net_bridge_fdb_entry {
 	struct net_bridge_fdb_key	key;
 	struct hlist_node		fdb_node;
 	unsigned long			flags;
-	unsigned char			added_by_user:1,
-					added_by_external_learn:1,
+	unsigned char			added_by_external_learn:1,
 					offloaded:1;
 
 	/* write-heavy members should not affect lookups */

commit e0458d9a733ba71a2821d0c3fc0745baac697db0
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Oct 29 13:45:55 2019 +0200

    net: bridge: fdb: convert is_sticky to bitops
    
    Straight-forward convert of the is_sticky field to bitops.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c5258fad76e5..296f2f12c232 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -176,6 +176,7 @@ struct net_bridge_vlan_group {
 enum {
 	BR_FDB_LOCAL,
 	BR_FDB_STATIC,
+	BR_FDB_STICKY,
 };
 
 struct net_bridge_fdb_key {
@@ -190,8 +191,7 @@ struct net_bridge_fdb_entry {
 	struct net_bridge_fdb_key	key;
 	struct hlist_node		fdb_node;
 	unsigned long			flags;
-	unsigned char			is_sticky:1,
-					added_by_user:1,
+	unsigned char			added_by_user:1,
 					added_by_external_learn:1,
 					offloaded:1;
 

commit 29e63fffd666f1945756882d4b02bc7bec132101
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Oct 29 13:45:54 2019 +0200

    net: bridge: fdb: convert is_static to bitops
    
    Convert the is_static to bitops, make use of the combined
    test_and_set/clear_bit to simplify expressions in fdb_add_entry.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 888cbe9c639a..c5258fad76e5 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -175,6 +175,7 @@ struct net_bridge_vlan_group {
 /* bridge fdb flags */
 enum {
 	BR_FDB_LOCAL,
+	BR_FDB_STATIC,
 };
 
 struct net_bridge_fdb_key {
@@ -189,8 +190,7 @@ struct net_bridge_fdb_entry {
 	struct net_bridge_fdb_key	key;
 	struct hlist_node		fdb_node;
 	unsigned long			flags;
-	unsigned char			is_static:1,
-					is_sticky:1,
+	unsigned char			is_sticky:1,
 					added_by_user:1,
 					added_by_external_learn:1,
 					offloaded:1;

commit 6869c3b02b596eba931a754f56875d2e2ac612db
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Oct 29 13:45:53 2019 +0200

    net: bridge: fdb: convert is_local to bitops
    
    The patch adds a new fdb flags field in the hole between the two cache
    lines and uses it to convert is_local to bitops.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ce2ab14ee605..888cbe9c639a 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -172,6 +172,11 @@ struct net_bridge_vlan_group {
 	u16				pvid;
 };
 
+/* bridge fdb flags */
+enum {
+	BR_FDB_LOCAL,
+};
+
 struct net_bridge_fdb_key {
 	mac_addr addr;
 	u16 vlan_id;
@@ -183,8 +188,8 @@ struct net_bridge_fdb_entry {
 
 	struct net_bridge_fdb_key	key;
 	struct hlist_node		fdb_node;
-	unsigned char			is_local:1,
-					is_static:1,
+	unsigned long			flags;
+	unsigned char			is_static:1,
 					is_sticky:1,
 					added_by_user:1,
 					added_by_external_learn:1,

commit 1bc844ee0faa1b92e3ede00bdd948021c78d7088
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sat Aug 17 14:22:13 2019 +0300

    net: bridge: mdb: allow add/delete for host-joined groups
    
    Currently this is needed only for user-space compatibility, so similar
    object adds/deletes as the dumped ones would succeed. Later it can be
    used for L2 mcast MAC add/delete.
    
    v3: fix compiler warning (DaveM)
    v2: don't send a notification when used from user-space, arm the group
        timer if no ports are left after host entry del
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index b7a4942ff1b3..ce2ab14ee605 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -702,6 +702,8 @@ void br_multicast_get_stats(const struct net_bridge *br,
 			    struct br_mcast_stats *dest);
 void br_mdb_init(void);
 void br_mdb_uninit(void);
+void br_multicast_host_join(struct net_bridge_mdb_entry *mp, bool notify);
+void br_multicast_host_leave(struct net_bridge_mdb_entry *mp, bool notify);
 
 #define mlock_dereference(X, br) \
 	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))

commit 13dfb3fa494361ea9a5950f27c9cd8b06d28c04f
Merge: 05bb520376af 33920f1ec5bf
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Aug 6 18:44:57 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Just minor overlapping changes in the conflicts here.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 091adf9ba6cdb432cbcc217b47e4ffb8aa0d8865
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Aug 2 13:57:36 2019 +0300

    net: bridge: move default pvid init/deinit to NETDEV_REGISTER/UNREGISTER
    
    Most of the bridge device's vlan init bugs come from the fact that its
    default pvid is created at the wrong time, way too early in ndo_init()
    before the device is even assigned an ifindex. It introduces a bug when the
    bridge's dev_addr is added as fdb during the initial default pvid creation
    the notification has ifindex/NDA_MASTER both equal to 0 (see example below)
    which really makes no sense for user-space[0] and is wrong.
    Usually user-space software would ignore such entries, but they are
    actually valid and will eventually have all necessary attributes.
    It makes much more sense to send a notification *after* the device has
    registered and has a proper ifindex allocated rather than before when
    there's a chance that the registration might still fail or to receive
    it with ifindex/NDA_MASTER == 0. Note that we can remove the fdb flush
    from br_vlan_flush() since that case can no longer happen. At
    NETDEV_REGISTER br->default_pvid is always == 1 as it's initialized by
    br_vlan_init() before that and at NETDEV_UNREGISTER it can be anything
    depending why it was called (if called due to NETDEV_REGISTER error
    it'll still be == 1, otherwise it could be any value changed during the
    device life time).
    
    For the demonstration below a small change to iproute2 for printing all fdb
    notifications is added, because it contained a workaround not to show
    entries with ifindex == 0.
    Command executed while monitoring: $ ip l add br0 type bridge
    Before (both ifindex and master == 0):
    $ bridge monitor fdb
    36:7e:8a:b3:56:ba dev * vlan 1 master * permanent
    
    After (proper br0 ifindex):
    $ bridge monitor fdb
    e6:2a:ae:7a:b7:48 dev br0 vlan 1 master br0 permanent
    
    v4: move only the default pvid init/deinit to NETDEV_REGISTER/UNREGISTER
    v3: send the correct v2 patch with all changes (stub should return 0)
    v2: on error in br_vlan_init set br->vlgrp to NULL and return 0 in
        the br_vlan_bridge_event stub when bridge vlans are disabled
    
    [0] https://bugzilla.kernel.org/show_bug.cgi?id=204389
    
    Reported-by: michael-dev <michael-dev@fami-braun.de>
    Fixes: 5be5a2df40f0 ("bridge: Add filtering support for default_pvid")
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e8cf03b43b7d..646504db0220 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -894,8 +894,8 @@ int nbp_get_num_vlan_infos(struct net_bridge_port *p, u32 filter_mask);
 void br_vlan_get_stats(const struct net_bridge_vlan *v,
 		       struct br_vlan_stats *stats);
 void br_vlan_port_event(struct net_bridge_port *p, unsigned long event);
-void br_vlan_bridge_event(struct net_device *dev, unsigned long event,
-			  void *ptr);
+int br_vlan_bridge_event(struct net_device *dev, unsigned long event,
+			 void *ptr);
 
 static inline struct net_bridge_vlan_group *br_vlan_group(
 					const struct net_bridge *br)
@@ -1085,9 +1085,10 @@ static inline void br_vlan_port_event(struct net_bridge_port *p,
 {
 }
 
-static inline void br_vlan_bridge_event(struct net_device *dev,
-					unsigned long event, void *ptr)
+static inline int br_vlan_bridge_event(struct net_device *dev,
+				       unsigned long event, void *ptr)
 {
+	return 0;
 }
 #endif
 

commit 3247b272048ffefc12c7dcfa3169bd03047a49bc
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Jul 30 15:20:41 2019 +0300

    net: bridge: mcast: add delete due to fast-leave mdb flag
    
    In user-space there's no way to distinguish why an mdb entry was deleted
    and that is a problem for daemons which would like to keep the mdb in
    sync with remote ends (e.g. mlag) but would also like to converge faster.
    In almost all cases we'd like to age-out the remote entry for performance
    and convergence reasons except when fast-leave is enabled. In that case we
    want explicit immediate remote delete, thus add mdb flag which is set only
    when the entry is being deleted due to fast-leave.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e8cf03b43b7d..c4fd307fbfdc 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -199,6 +199,7 @@ struct net_bridge_fdb_entry {
 
 #define MDB_PG_FLAGS_PERMANENT	BIT(0)
 #define MDB_PG_FLAGS_OFFLOAD	BIT(1)
+#define MDB_PG_FLAGS_FAST_LEAVE	BIT(2)
 
 struct net_bridge_port_group {
 	struct net_bridge_port		*port;

commit a6cdeeb16bff89c8486324f53577db058cbe81ba
Merge: 96524ea4be04 1e1d92636954
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jun 7 11:00:14 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Some ISDN files that got removed in net-next had some changes
    done in mainline, take the removals.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 3c171f496ef57774f8e5d509923372549734877f
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Wed May 29 13:25:37 2019 +0200

    netfilter: bridge: add connection tracking system
    
    This patch adds basic connection tracking support for the bridge,
    including initial IPv4 support.
    
    This patch register two hooks to deal with the bridge forwarding path,
    one from the bridge prerouting hook to call nf_conntrack_in(); and
    another from the bridge postrouting hook to confirm the entry.
    
    The conntrack bridge prerouting hook defragments packets before passing
    them to nf_conntrack_in() to look up for an existing entry, otherwise a
    new entry is allocated and it is attached to the skbuff. The conntrack
    bridge postrouting hook confirms new conntrack entries, ie. if this is
    the first packet seen, then it adds the entry to the hashtable and (if
    needed) it refragments the skbuff into the original fragments, leaving
    the geometry as is if possible. Exceptions are linearized skbuffs, eg.
    skbuffs that are passed up to nfqueue and conntrack helpers, as well as
    cloned skbuff for the local delivery (eg. tcpdump), also in case of
    bridge port flooding (cloned skbuff too).
    
    The packet defragmentation is done through the ip_defrag() call.  This
    forces us to save the bridge control buffer, reset the IP control buffer
    area and then restore it after call. This function also bumps the IP
    fragmentation statistics, it would be probably desiderable to have
    independent statistics for the bridge defragmentation/refragmentation.
    The maximum fragment length is stored in the control buffer and it is
    used to refragment the skbuff from the postrouting path.
    
    The new fraglist splitter and fragment transformer APIs are used to
    implement the bridge refragmentation code. The br_ip_fragment() function
    drops the packet in case the maximum fragment size seen is larger than
    the output port MTU.
    
    This patchset follows the principle that conntrack should not drop
    packets, so users can do it through policy via invalid state matching.
    
    Like br_netfilter, there is no refragmentation for packets that are
    passed up for local delivery, ie. prerouting -> input path. There are
    calls to nf_reset() already in several spots in the stack since time ago
    already, eg. af_packet, that show that skbuff fraglist handling from the
    netif_rx path is supported already.
    
    The helpers are called from the postrouting hook, before confirmation,
    from there we may see packet floods to bridge ports. Then, although
    unlikely, this may result in exercising the helpers many times for each
    clone. It would be good to explore how to pass all the packets in a list
    to the conntrack hook to do this handle only once for this case.
    
    Thanks to Florian Westphal for handing me over an initial patchset
    version to add support for conntrack bridge.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 334a8c496b50..68561741e827 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -425,6 +425,7 @@ struct net_bridge {
 struct br_input_skb_cb {
 	struct net_device *brdev;
 
+	u16 frag_max_size;
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	u8 igmp;
 	u8 mrouters_only:1;

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 334a8c496b50..159a0e2cb0f6 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1,13 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  *	Linux ethernet bridge
  *
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License
- *	as published by the Free Software Foundation; either version
- *	2 of the License, or (at your option) any later version.
  */
 
 #ifndef _BR_PRIVATE_H

commit 9c0ec2e7182a508335364c752da0883a2a7f3999
Author: Mike Manning <mmanning@vyatta.att-mail.com>
Date:   Thu Apr 18 18:35:33 2019 +0100

    bridge: support binding vlan dev link state to vlan member bridge ports
    
    In the case of vlan filtering on bridges, the bridge may also have the
    corresponding vlan devices as upper devices. A vlan bridge binding mode
    is added to allow the link state of the vlan device to track only the
    state of the subset of bridge ports that are also members of the vlan,
    rather than that of all bridge ports. This mode is set with a vlan flag
    rather than a bridge sysfs so that the 8021q module is aware that it
    should not set the link state for the vlan device.
    
    If bridge vlan is configured, the bridge device event handling results
    in the link state for an upper device being set, if it is a vlan device
    with the vlan bridge binding mode enabled. This also sets a
    vlan_bridge_binding flag so that subsequent UP/DOWN/CHANGE events for
    the ports in that bridge result in a link state update of the vlan
    device if required.
    
    The link state of the vlan device is up if there is at least one bridge
    port that is a vlan member that is admin & oper up, otherwise its oper
    state is IF_OPER_LOWERLAYERDOWN.
    
    Signed-off-by: Mike Manning <mmanning@vyatta.att-mail.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 4bea2f11da9b..334a8c496b50 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -321,6 +321,7 @@ enum net_bridge_opts {
 	BROPT_MTU_SET_BY_USER,
 	BROPT_VLAN_STATS_PER_PORT,
 	BROPT_NO_LL_LEARN,
+	BROPT_VLAN_BRIDGE_BINDING,
 };
 
 struct net_bridge {
@@ -895,6 +896,9 @@ int nbp_vlan_init(struct net_bridge_port *port, struct netlink_ext_ack *extack);
 int nbp_get_num_vlan_infos(struct net_bridge_port *p, u32 filter_mask);
 void br_vlan_get_stats(const struct net_bridge_vlan *v,
 		       struct br_vlan_stats *stats);
+void br_vlan_port_event(struct net_bridge_port *p, unsigned long event);
+void br_vlan_bridge_event(struct net_device *dev, unsigned long event,
+			  void *ptr);
 
 static inline struct net_bridge_vlan_group *br_vlan_group(
 					const struct net_bridge *br)
@@ -1078,6 +1082,16 @@ static inline void br_vlan_get_stats(const struct net_bridge_vlan *v,
 				     struct br_vlan_stats *stats)
 {
 }
+
+static inline void br_vlan_port_event(struct net_bridge_port *p,
+				      unsigned long event)
+{
+}
+
+static inline void br_vlan_bridge_event(struct net_device *dev,
+					unsigned long event, void *ptr)
+{
+}
 #endif
 
 struct nf_br_ops {

commit 223fd0adfa8af36d5d9b5d38016e579ee052f367
Author: Florian Westphal <fw@strlen.de>
Date:   Thu Apr 11 16:36:42 2019 +0200

    bridge: broute: make broute a real ebtables table
    
    This makes broute a normal ebtables table, hooking at PREROUTING.
    The broute hook is removed.
    
    It uses skb->cb to signal to bridge rx handler that the skb should be
    routed instead of being bridged.
    
    This change is backwards compatible with ebtables as no userspace visible
    parts are changed.
    
    This means we can also remove the !ops test in ebt_register_table,
    it was only there for broute table sake.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e7110a6e2b7e..4bea2f11da9b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -433,6 +433,9 @@ struct br_input_skb_cb {
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	u8 vlan_filtered:1;
 #endif
+#ifdef CONFIG_NETFILTER_FAMILY_BRIDGE
+	u8 br_netfilter_broute:1;
+#endif
 
 #ifdef CONFIG_NET_SWITCHDEV
 	int offload_fwd_mark;

commit f12064d1b402c60c5db9c4b63d5ed6d7facb33f6
Author: Florian Westphal <fw@strlen.de>
Date:   Thu Apr 11 16:36:40 2019 +0200

    bridge: reduce size of input cb to 16 bytes
    
    Reduce size of br_input_skb_cb from 24 to 16 bytes by
    using bitfield for those values that can only be 0 or 1.
    
    igmp is the igmp type value, so it needs to be at least u8.
    
    Furthermore, the bridge currently relies on step-by-step initialization
    of br_input_skb_cb fields as the skb passes through the stack.
    
    Explicitly zero out the bridge input cb instead, this avoids having to
    review/validate that no BR_INPUT_SKB_CB(skb)->foo test can see a
    'random' value from previous protocol cb.
    
    AFAICS all current fields are always set up before they are read again,
    so this is not a bug fix.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Acked-by: David S. Miller <davem@davemloft.net>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 7946aa3b6e09..e7110a6e2b7e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -425,15 +425,13 @@ struct br_input_skb_cb {
 	struct net_device *brdev;
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
-	int igmp;
-	int mrouters_only;
+	u8 igmp;
+	u8 mrouters_only:1;
 #endif
-
-	bool proxyarp_replied;
-	bool src_port_isolated;
-
+	u8 proxyarp_replied:1;
+	u8 src_port_isolated:1;
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
-	bool vlan_filtered;
+	u8 vlan_filtered:1;
 #endif
 
 #ifdef CONFIG_NET_SWITCHDEV

commit 35f861e3c58e128f0ecb5669c43159285ea5254a
Author: Julian Wiedmann <jwi@linux.ibm.com>
Date:   Fri Mar 29 14:38:19 2019 +0100

    net: bridge: use netif_is_bridge_port()
    
    Replace the br_port_exists() macro with its twin from netdevice.h
    
    CC: Roopa Prabhu <roopa@cumulusnetworks.com>
    CC: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Julian Wiedmann <jwi@linux.ibm.com>
    Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 00deef7fc1f3..7946aa3b6e09 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -288,8 +288,6 @@ struct net_bridge_port {
 #define br_auto_port(p) ((p)->flags & BR_AUTO_MASK)
 #define br_promisc_port(p) ((p)->flags & BR_PROMISC)
 
-#define br_port_exists(dev) (dev->priv_flags & IFF_BRIDGE_PORT)
-
 static inline struct net_bridge_port *br_port_get_rcu(const struct net_device *dev)
 {
 	return rcu_dereference(dev->rx_handler_data);
@@ -297,13 +295,13 @@ static inline struct net_bridge_port *br_port_get_rcu(const struct net_device *d
 
 static inline struct net_bridge_port *br_port_get_rtnl(const struct net_device *dev)
 {
-	return br_port_exists(dev) ?
+	return netif_is_bridge_port(dev) ?
 		rtnl_dereference(dev->rx_handler_data) : NULL;
 }
 
 static inline struct net_bridge_port *br_port_get_rtnl_rcu(const struct net_device *dev)
 {
-	return br_port_exists(dev) ?
+	return netif_is_bridge_port(dev) ?
 		rcu_dereference_rtnl(dev->rx_handler_data) : NULL;
 }
 

commit 87b0984ebfabafcfe959e52ca5cdab5eeb2d60c0
Author: Petr Machata <petrm@mellanox.com>
Date:   Wed Jan 16 23:06:50 2019 +0000

    net: Add extack argument to ndo_fdb_add()
    
    Drivers may not be able to support certain FDB entries, and an error
    code is insufficient to give clear hints as to the reasons of rejection.
    
    In order to make it possible to communicate the rejection reason, extend
    ndo_fdb_add() with an extack argument. Adapt the existing
    implementations of ndo_fdb_add() to take the parameter (and ignore it).
    Pass the extack parameter when invoking ndo_fdb_add() from rtnl_fdb_add().
    
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index eabf8bf28a3f..00deef7fc1f3 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -573,7 +573,8 @@ void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
 int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 		  struct net_device *dev, const unsigned char *addr, u16 vid);
 int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[], struct net_device *dev,
-	       const unsigned char *addr, u16 vid, u16 nlh_flags);
+	       const unsigned char *addr, u16 vid, u16 nlh_flags,
+	       struct netlink_ext_ack *extack);
 int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
 		struct net_device *dev, struct net_device *fdev, int *idx);
 int br_fdb_get(struct sk_buff *skb, struct nlattr *tb[], struct net_device *dev,

commit 279737939a8194f02fa352ab4476a1b241f44ef4
Author: Ido Schimmel <idosch@mellanox.com>
Date:   Tue Jan 8 16:48:11 2019 +0000

    net: bridge: Fix VLANs memory leak
    
    When adding / deleting VLANs to / from a bridge port, the bridge driver
    first tries to propagate the information via switchdev and falls back to
    the 8021q driver in case the underlying driver does not support
    switchdev. This can result in a memory leak [1] when VXLAN and mlxsw
    ports are enslaved to the bridge:
    
    $ ip link set dev vxlan0 master br0
    # No mlxsw ports are enslaved to 'br0', so mlxsw ignores the switchdev
    # notification and the bridge driver adds the VLAN on 'vxlan0' via the
    # 8021q driver
    $ bridge vlan add vid 10 dev vxlan0 pvid untagged
    # mlxsw port is enslaved to the bridge
    $ ip link set dev swp1 master br0
    # mlxsw processes the switchdev notification and the 8021q driver is
    # skipped
    $ bridge vlan del vid 10 dev vxlan0
    
    This results in 'struct vlan_info' and 'struct vlan_vid_info' being
    leaked, as they were allocated by the 8021q driver during VLAN addition,
    but never freed as the 8021q driver was skipped during deletion.
    
    Fix this by introducing a new VLAN private flag that indicates whether
    the VLAN was added on the port by switchdev or the 8021q driver. If the
    VLAN was added by the 8021q driver, then we make sure to delete it via
    the 8021q driver as well.
    
    [1]
    unreferenced object 0xffff88822d20b1e8 (size 256):
      comm "bridge", pid 2532, jiffies 4295216998 (age 1188.830s)
      hex dump (first 32 bytes):
        e0 42 97 ce 81 88 ff ff 00 00 00 00 00 00 00 00  .B..............
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      backtrace:
        [<00000000f82d851d>] kmem_cache_alloc_trace+0x1be/0x330
        [<00000000e0178b02>] vlan_vid_add+0x661/0x920
        [<00000000218ebd5f>] __vlan_add+0x1be9/0x3a00
        [<000000006eafa1ca>] nbp_vlan_add+0x8b3/0xd90
        [<000000003535392c>] br_vlan_info+0x132/0x410
        [<00000000aedaa9dc>] br_afspec+0x75c/0x870
        [<00000000f5716133>] br_setlink+0x3dc/0x6d0
        [<00000000aceca5e2>] rtnl_bridge_setlink+0x615/0xb30
        [<00000000a2f2d23e>] rtnetlink_rcv_msg+0x3a3/0xa80
        [<0000000064097e69>] netlink_rcv_skb+0x152/0x3c0
        [<000000008be8d614>] rtnetlink_rcv+0x21/0x30
        [<000000009ab2ca25>] netlink_unicast+0x52f/0x740
        [<00000000e7d9ac96>] netlink_sendmsg+0x9c7/0xf50
        [<000000005d1e2050>] sock_sendmsg+0xbe/0x120
        [<00000000d51426bc>] ___sys_sendmsg+0x778/0x8f0
        [<00000000b9d7b2cc>] __sys_sendmsg+0x112/0x270
    unreferenced object 0xffff888227454308 (size 32):
      comm "bridge", pid 2532, jiffies 4295216998 (age 1188.882s)
      hex dump (first 32 bytes):
        88 b2 20 2d 82 88 ff ff 88 b2 20 2d 82 88 ff ff  .. -...... -....
        81 00 0a 00 01 00 00 00 00 00 00 00 00 00 00 00  ................
      backtrace:
        [<00000000f82d851d>] kmem_cache_alloc_trace+0x1be/0x330
        [<0000000018050631>] vlan_vid_add+0x3e6/0x920
        [<00000000218ebd5f>] __vlan_add+0x1be9/0x3a00
        [<000000006eafa1ca>] nbp_vlan_add+0x8b3/0xd90
        [<000000003535392c>] br_vlan_info+0x132/0x410
        [<00000000aedaa9dc>] br_afspec+0x75c/0x870
        [<00000000f5716133>] br_setlink+0x3dc/0x6d0
        [<00000000aceca5e2>] rtnl_bridge_setlink+0x615/0xb30
        [<00000000a2f2d23e>] rtnetlink_rcv_msg+0x3a3/0xa80
        [<0000000064097e69>] netlink_rcv_skb+0x152/0x3c0
        [<000000008be8d614>] rtnetlink_rcv+0x21/0x30
        [<000000009ab2ca25>] netlink_unicast+0x52f/0x740
        [<00000000e7d9ac96>] netlink_sendmsg+0x9c7/0xf50
        [<000000005d1e2050>] sock_sendmsg+0xbe/0x120
        [<00000000d51426bc>] ___sys_sendmsg+0x778/0x8f0
        [<00000000b9d7b2cc>] __sys_sendmsg+0x112/0x270
    
    Fixes: d70e42b22dd4 ("mlxsw: spectrum: Enable VxLAN enslavement to VLAN-aware bridges")
    Signed-off-by: Ido Schimmel <idosch@mellanox.com>
    Reviewed-by: Petr Machata <petrm@mellanox.com>
    Cc: Roopa Prabhu <roopa@cumulusnetworks.com>
    Cc: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Cc: bridge@lists.linux-foundation.org
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index d240b3e7919f..eabf8bf28a3f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -107,6 +107,7 @@ struct br_tunnel_info {
 /* private vlan flags */
 enum {
 	BR_VLFLAG_PER_PORT_STATS = BIT(0),
+	BR_VLFLAG_ADDED_BY_SWITCHDEV = BIT(1),
 };
 
 /**

commit 4767456212f8cd70775dc55d9bc72e184ff84642
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Sat Dec 15 22:35:09 2018 -0800

    bridge: support for ndo_fdb_get
    
    This patch implements ndo_fdb_get for the bridge
    fdb.
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ff3dfb2a78b8..d240b3e7919f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -575,6 +575,9 @@ int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[], struct net_device *dev,
 	       const unsigned char *addr, u16 vid, u16 nlh_flags);
 int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
 		struct net_device *dev, struct net_device *fdev, int *idx);
+int br_fdb_get(struct sk_buff *skb, struct nlattr *tb[], struct net_device *dev,
+	       const unsigned char *addr, u16 vid, u32 portid, u32 seq,
+	       struct netlink_ext_ack *extack);
 int br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p);
 void br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p);
 int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,

commit 169327d5850cb80d98d095cfaf8dfbb63d576864
Author: Petr Machata <petrm@mellanox.com>
Date:   Wed Dec 12 17:02:50 2018 +0000

    net: bridge: Propagate extack to switchdev
    
    ndo_bridge_setlink has been updated in the previous patch to have extack
    available, and changelink RTNL op has had this argument since the time
    extack was added. Propagate both through the bridge driver to eventually
    reach br_switchdev_port_vlan_add(), where it will be used by subsequent
    patches.
    
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Acked-by: Jiri Pirko <jiri@mellanox.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Ivan Vecera <ivecera@redhat.com>
    Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 090dfacdc438..ff3dfb2a78b8 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -868,7 +868,7 @@ struct sk_buff *br_handle_vlan(struct net_bridge *br,
 			       struct net_bridge_vlan_group *vg,
 			       struct sk_buff *skb);
 int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags,
-		bool *changed);
+		bool *changed, struct netlink_ext_ack *extack);
 int br_vlan_delete(struct net_bridge *br, u16 vid);
 void br_vlan_flush(struct net_bridge *br);
 struct net_bridge_vlan *br_vlan_find(struct net_bridge_vlan_group *vg, u16 vid);
@@ -881,12 +881,13 @@ int br_vlan_set_stats(struct net_bridge *br, unsigned long val);
 int br_vlan_set_stats_per_port(struct net_bridge *br, unsigned long val);
 int br_vlan_init(struct net_bridge *br);
 int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
-int __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid);
+int __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid,
+			       struct netlink_ext_ack *extack);
 int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags,
-		 bool *changed);
+		 bool *changed, struct netlink_ext_ack *extack);
 int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 void nbp_vlan_flush(struct net_bridge_port *port);
-int nbp_vlan_init(struct net_bridge_port *port);
+int nbp_vlan_init(struct net_bridge_port *port, struct netlink_ext_ack *extack);
 int nbp_get_num_vlan_infos(struct net_bridge_port *p, u32 filter_mask);
 void br_vlan_get_stats(const struct net_bridge_vlan *v,
 		       struct br_vlan_stats *stats);
@@ -971,7 +972,7 @@ static inline struct sk_buff *br_handle_vlan(struct net_bridge *br,
 }
 
 static inline int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags,
-			      bool *changed)
+			      bool *changed, struct netlink_ext_ack *extack)
 {
 	*changed = false;
 	return -EOPNOTSUPP;
@@ -996,7 +997,7 @@ static inline int br_vlan_init(struct net_bridge *br)
 }
 
 static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags,
-			       bool *changed)
+			       bool *changed, struct netlink_ext_ack *extack)
 {
 	*changed = false;
 	return -EOPNOTSUPP;
@@ -1017,7 +1018,8 @@ static inline struct net_bridge_vlan *br_vlan_find(struct net_bridge_vlan_group
 	return NULL;
 }
 
-static inline int nbp_vlan_init(struct net_bridge_port *port)
+static inline int nbp_vlan_init(struct net_bridge_port *port,
+				struct netlink_ext_ack *extack)
 {
 	return 0;
 }
@@ -1174,7 +1176,8 @@ int br_switchdev_set_port_flag(struct net_bridge_port *p,
 			       unsigned long mask);
 void br_switchdev_fdb_notify(const struct net_bridge_fdb_entry *fdb,
 			     int type);
-int br_switchdev_port_vlan_add(struct net_device *dev, u16 vid, u16 flags);
+int br_switchdev_port_vlan_add(struct net_device *dev, u16 vid, u16 flags,
+			       struct netlink_ext_ack *extack);
 int br_switchdev_port_vlan_del(struct net_device *dev, u16 vid);
 
 static inline void br_switchdev_frame_unmark(struct sk_buff *skb)
@@ -1206,7 +1209,8 @@ static inline int br_switchdev_set_port_flag(struct net_bridge_port *p,
 }
 
 static inline int br_switchdev_port_vlan_add(struct net_device *dev,
-					     u16 vid, u16 flags)
+					     u16 vid, u16 flags,
+					     struct netlink_ext_ack *extack)
 {
 	return -EOPNOTSUPP;
 }

commit 2fd527b72bb6f95dfe8a1902e998cb76390c431e
Author: Petr Machata <petrm@mellanox.com>
Date:   Wed Dec 12 17:02:48 2018 +0000

    net: ndo_bridge_setlink: Add extack
    
    Drivers may not be able to implement a VLAN addition or reconfiguration.
    In those cases it's desirable to explain to the user that it was
    rejected (and why).
    
    To that end, add extack argument to ndo_bridge_setlink. Adapt all users
    to that change.
    
    Following patches will use the new argument in the bridge driver.
    
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Acked-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 5719b4d3e466..090dfacdc438 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1138,7 +1138,8 @@ int br_netlink_init(void);
 void br_netlink_fini(void);
 void br_ifinfo_notify(int event, const struct net_bridge *br,
 		      const struct net_bridge_port *port);
-int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags);
+int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags,
+	       struct netlink_ext_ack *extack);
 int br_dellink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags);
 int br_getlink(struct sk_buff *skb, u32 pid, u32 seq, struct net_device *dev,
 	       u32 filter_mask, int nlflags);

commit d08c6bc08f72f74cd37f6b7954e3f708005518f9
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Dec 5 15:14:27 2018 +0200

    net: bridge: increase multicast's default maximum number of entries
    
    bridge's default hash_max was 512 which is rather conservative, now that
    we're using the generic rhashtable API which autoshrinks let's increase
    it to 4096 and move it to a define in br_private.h.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ba50fa437a94..5719b4d3e466 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -31,6 +31,8 @@
 #define BR_PORT_BITS	10
 #define BR_MAX_PORTS	(1<<BR_PORT_BITS)
 
+#define BR_MULTICAST_DEFAULT_HASH_MAX 4096
+
 #define BR_VERSION	"2.3"
 
 /* Control of forwarding link local multicast */

commit cf332bca56f4981cad19027f037fb4d661dcb172
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Dec 5 15:14:26 2018 +0200

    net: bridge: mark hash_elasticity as obsolete
    
    Now that the bridge multicast uses the generic rhashtable interface we
    can drop the hash_elasticity option as that is already done for us and
    it's hardcoded to a maximum of RHT_ELASTICITY (16 currently). Add a
    warning about the obsolete option when the hash_elasticity is set.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index cf1f7365deb3..ba50fa437a94 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -372,7 +372,6 @@ struct net_bridge {
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 
-	u32				hash_elasticity;
 	u32				hash_max;
 
 	u32				multicast_last_member_count;

commit 4329596cb10d23c9e22c78e676a3667ef28ed62f
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Dec 5 15:14:25 2018 +0200

    net: bridge: multicast: use non-bh rcu flavor
    
    The bridge multicast code has been using a mix of RCU and RCU-bh flavors
    sometimes in questionable way. Since we've moved to rhashtable just use
    non-bh RCU everywhere. In addition this simplifies freeing of objects
    and allows us to remove some unnecessary callback functions.
    
    v3: new patch
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index a0ce0822921c..cf1f7365deb3 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -679,7 +679,6 @@ struct net_bridge_mdb_entry *
 br_mdb_ip_get(struct net_bridge *br, struct br_ip *dst);
 struct net_bridge_mdb_entry *
 br_multicast_new_group(struct net_bridge *br, struct br_ip *group);
-void br_multicast_free_pg(struct rcu_head *head);
 struct net_bridge_port_group *
 br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
 			    struct net_bridge_port_group __rcu *next,

commit 19e3a9c90c53479fecaa02307bf2db5ab8b3ffe3
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Dec 5 15:14:24 2018 +0200

    net: bridge: convert multicast to generic rhashtable
    
    The bridge multicast code currently uses a custom resizable hashtable
    which predates the generic rhashtable interface. It has many
    shortcomings compared and duplicates functionality that is presently
    available via the generic rhashtable, so this patch removes the custom
    rhashtable implementation in favor of the kernel's generic rhashtable.
    The hash maximum is kept and the rhashtable's size is used to do a loose
    check if it's reached in which case we revert to the old behaviour and
    disable further bridge multicast processing. Also now we can support any
    hash maximum, doesn't need to be a power of 2.
    
    v3: add non-rcu br_mdb_get variant and use it where multicast_lock is
        held to avoid RCU splat, drop hash_max function and just set it
        directly
    
    v2: handle when IGMP snooping is undefined, add br_mdb_init/uninit
        placeholders
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index d29f837cd7a2..a0ce0822921c 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -213,23 +213,14 @@ struct net_bridge_port_group {
 };
 
 struct net_bridge_mdb_entry {
-	struct hlist_node		hlist[2];
+	struct rhash_head		rhnode;
 	struct net_bridge		*br;
 	struct net_bridge_port_group __rcu *ports;
 	struct rcu_head			rcu;
 	struct timer_list		timer;
 	struct br_ip			addr;
 	bool				host_joined;
-};
-
-struct net_bridge_mdb_htable {
-	struct hlist_head		*mhash;
-	struct rcu_head			rcu;
-	struct net_bridge_mdb_htable	*old;
-	u32				size;
-	u32				max;
-	u32				secret;
-	u32				ver;
+	struct hlist_node		mdb_node;
 };
 
 struct net_bridge_port {
@@ -400,7 +391,9 @@ struct net_bridge {
 	unsigned long			multicast_query_response_interval;
 	unsigned long			multicast_startup_query_interval;
 
-	struct net_bridge_mdb_htable __rcu *mdb;
+	struct rhashtable		mdb_hash_tbl;
+
+	struct hlist_head		mdb_list;
 	struct hlist_head		router_list;
 
 	struct timer_list		multicast_router_timer;
@@ -659,7 +652,6 @@ int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd,
 
 /* br_multicast.c */
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
-extern unsigned int br_mdb_rehash_seq;
 int br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,
 		     struct sk_buff *skb, u16 vid);
 struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
@@ -684,17 +676,16 @@ int br_multicast_set_igmp_version(struct net_bridge *br, unsigned long val);
 int br_multicast_set_mld_version(struct net_bridge *br, unsigned long val);
 #endif
 struct net_bridge_mdb_entry *
-br_mdb_ip_get(struct net_bridge_mdb_htable *mdb, struct br_ip *dst);
+br_mdb_ip_get(struct net_bridge *br, struct br_ip *dst);
 struct net_bridge_mdb_entry *
-br_multicast_new_group(struct net_bridge *br, struct net_bridge_port *port,
-		       struct br_ip *group);
+br_multicast_new_group(struct net_bridge *br, struct br_ip *group);
 void br_multicast_free_pg(struct rcu_head *head);
 struct net_bridge_port_group *
 br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
 			    struct net_bridge_port_group __rcu *next,
 			    unsigned char flags, const unsigned char *src);
-void br_mdb_init(void);
-void br_mdb_uninit(void);
+int br_mdb_hash_init(struct net_bridge *br);
+void br_mdb_hash_fini(struct net_bridge *br);
 void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
 		   struct br_ip *group, int type, u8 flags);
 void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
@@ -706,6 +697,8 @@ void br_multicast_uninit_stats(struct net_bridge *br);
 void br_multicast_get_stats(const struct net_bridge *br,
 			    const struct net_bridge_port *p,
 			    struct br_mcast_stats *dest);
+void br_mdb_init(void);
+void br_mdb_uninit(void);
 
 #define mlock_dereference(X, br) \
 	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
@@ -831,6 +824,15 @@ static inline void br_mdb_uninit(void)
 {
 }
 
+static inline int br_mdb_hash_init(struct net_bridge *br)
+{
+	return 0;
+}
+
+static inline void br_mdb_hash_fini(struct net_bridge *br)
+{
+}
+
 static inline void br_multicast_count(struct net_bridge *br,
 				      const struct net_bridge_port *p,
 				      const struct sk_buff *skb,

commit 70e4272b4c81828e7d942209bae83b9d92752cfe
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sat Nov 24 04:34:21 2018 +0200

    net: bridge: add no_linklocal_learn bool option
    
    Use the new boolopt API to add an option which disables learning from
    link-local packets. The default is kept as before and learning is
    enabled. This is a simple map from a boolopt bit to a bridge private
    flag that is tested before learning.
    
    v2: pass NULL for extack via sysfs
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 6d4c208fbf08..d29f837cd7a2 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -328,6 +328,7 @@ enum net_bridge_opts {
 	BROPT_NEIGH_SUPPRESS_ENABLED,
 	BROPT_MTU_SET_BY_USER,
 	BROPT_VLAN_STATS_PER_PORT,
+	BROPT_NO_LL_LEARN,
 };
 
 struct net_bridge {

commit a428afe82f98d2ffb31c981671630df1fa25906f
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sat Nov 24 04:34:20 2018 +0200

    net: bridge: add support for user-controlled bool options
    
    We have been adding many new bridge options, a big number of which are
    boolean but still take up netlink attribute ids and waste space in the skb.
    Recently we discussed learning from link-local packets[1] and decided
    yet another new boolean option will be needed, thus introducing this API
    to save some bridge nl space.
    The API supports changing the value of multiple boolean options at once
    via the br_boolopt_multi struct which has an optmask (which options to
    set, bit per opt) and optval (options' new values). Future boolean
    options will only be added to the br_boolopt_id enum and then will have
    to be handled in br_boolopt_toggle/get. The API will automatically
    add the ability to change and export them via netlink, sysfs can use the
    single boolopt function versions to do the same. The behaviour with
    failing/succeeding is the same as with normal netlink option changing.
    
    If an option requires mapping to internal kernel flag or needs special
    configuration to be enabled then it should be handled in
    br_boolopt_toggle. It should also be able to retrieve an option's current
    state via br_boolopt_get.
    
    v2: WARN_ON() on unsupported option as that shouldn't be possible and
        also will help catch people who add new options without handling
        them for both set and get. Pass down extack so if an option desires
        it could set it on error and be more user-friendly.
    
    [1] https://www.spinics.net/lists/netdev/msg532698.html
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index bc2653738fc3..6d4c208fbf08 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -507,6 +507,14 @@ static inline int br_opt_get(const struct net_bridge *br,
 	return test_bit(opt, &br->options);
 }
 
+int br_boolopt_toggle(struct net_bridge *br, enum br_boolopt_id opt, bool on,
+		      struct netlink_ext_ack *extack);
+int br_boolopt_get(const struct net_bridge *br, enum br_boolopt_id opt);
+int br_boolopt_multi_toggle(struct net_bridge *br,
+			    struct br_boolopt_multi *bm,
+			    struct netlink_ext_ack *extack);
+void br_boolopt_multi_get(const struct net_bridge *br,
+			  struct br_boolopt_multi *bm);
 void br_opt_toggle(struct net_bridge *br, enum net_bridge_opts opt, bool on);
 
 /* br_device.c */

commit f2be6d710d25be7d8d13f49f713d69dea9c71d57
Merge: bae4e109837b f2ce1065e767
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 19 10:55:00 2018 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net

commit 9d332e69c1dc74dcd748de7cbd2dac5c61bda265
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Nov 16 18:50:01 2018 +0200

    net: bridge: fix vlan stats use-after-free on destruction
    
    Syzbot reported a use-after-free of the global vlan context on port vlan
    destruction. When I added per-port vlan stats I missed the fact that the
    global vlan context can be freed before the per-port vlan rcu callback.
    There're a few different ways to deal with this, I've chosen to add a
    new private flag that is set only when per-port stats are allocated so
    we can directly check it on destruction without dereferencing the global
    context at all. The new field in net_bridge_vlan uses a hole.
    
    v2: cosmetic change, move the check to br_process_vlan_info where the
        other checks are done
    v3: add change log in the patch, add private (in-kernel only) flags in a
        hole in net_bridge_vlan struct and use that instead of mixing
        user-space flags with private flags
    
    Fixes: 9163a0fc1f0c ("net: bridge: add support for per-port vlan stats")
    Reported-by: syzbot+04681da557a0e49a52e5@syzkaller.appspotmail.com
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2920e06a5403..04c19a37e500 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -102,12 +102,18 @@ struct br_tunnel_info {
 	struct metadata_dst	*tunnel_dst;
 };
 
+/* private vlan flags */
+enum {
+	BR_VLFLAG_PER_PORT_STATS = BIT(0),
+};
+
 /**
  * struct net_bridge_vlan - per-vlan entry
  *
  * @vnode: rhashtable member
  * @vid: VLAN id
  * @flags: bridge vlan flags
+ * @priv_flags: private (in-kernel) bridge vlan flags
  * @stats: per-cpu VLAN statistics
  * @br: if MASTER flag set, this points to a bridge struct
  * @port: if MASTER flag unset, this points to a port struct
@@ -127,6 +133,7 @@ struct net_bridge_vlan {
 	struct rhash_head		tnode;
 	u16				vid;
 	u16				flags;
+	u16				priv_flags;
 	struct br_vlan_stats __percpu	*stats;
 	union {
 		struct net_bridge	*br;

commit 5978f8a9fb492a74765822a545f16eb879fab937
Author: Micha Mirosaw <mirq-linux@rere.qmqm.pl>
Date:   Fri Nov 9 00:18:03 2018 +0100

    bridge: use __vlan_hwaccel helpers
    
    This removes assumption than vlan_tci != 0 when tag is present.
    
    Signed-off-by: Micha Mirosaw <mirq-linux@rere.qmqm.pl>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2920e06a5403..67105c66584a 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -905,7 +905,7 @@ static inline int br_vlan_get_tag(const struct sk_buff *skb, u16 *vid)
 	int err = 0;
 
 	if (skb_vlan_tag_present(skb)) {
-		*vid = skb_vlan_tag_get(skb) & VLAN_VID_MASK;
+		*vid = skb_vlan_tag_get_id(skb);
 	} else {
 		*vid = 0;
 		err = -EINVAL;

commit e9ba0fbc7dd23a74e77960c98c988f59a1ff75aa
Author: Ido Schimmel <idosch@mellanox.com>
Date:   Wed Oct 17 08:53:29 2018 +0000

    bridge: switchdev: Allow clearing FDB entry offload indication
    
    Currently, an FDB entry only ceases being offloaded when it is deleted.
    This changes with VxLAN encapsulation.
    
    Devices capable of performing VxLAN encapsulation usually have only one
    FDB table, unlike the software data path which has two - one in the
    bridge driver and another in the VxLAN driver.
    
    Therefore, bridge FDB entries pointing to a VxLAN device are only
    offloaded if there is a corresponding entry in the VxLAN FDB.
    
    Allow clearing the offload indication in case the corresponding entry
    was deleted from the VxLAN FDB.
    
    Signed-off-by: Ido Schimmel <idosch@mellanox.com>
    Reviewed-by: Petr Machata <petrm@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 10ee39fdca5c..2920e06a5403 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -574,7 +574,7 @@ int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 			      const unsigned char *addr, u16 vid,
 			      bool swdev_notify);
 void br_fdb_offloaded_set(struct net_bridge *br, struct net_bridge_port *p,
-			  const unsigned char *addr, u16 vid);
+			  const unsigned char *addr, u16 vid, bool offloaded);
 
 /* br_forward.c */
 enum br_pkt_type {

commit 9163a0fc1f0c0980f117cc25f4fa6ba9b0750a36
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Oct 12 13:41:16 2018 +0300

    net: bridge: add support for per-port vlan stats
    
    This patch adds an option to have per-port vlan stats instead of the
    default global stats. The option can be set only when there are no port
    vlans in the bridge since we need to allocate the stats if it is set
    when vlans are being added to ports (and respectively free them
    when being deleted). Also bump RTNL_MAX_TYPE as the bridge is the
    largest user of options. The current stats design allows us to add
    these without any changes to the fast-path, it all comes down to
    the per-vlan stats pointer which, if this option is enabled, will
    be allocated for each port vlan instead of using the global bridge-wide
    one.
    
    CC: bridge@lists.linux-foundation.org
    CC: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 57229b9d800f..10ee39fdca5c 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -320,6 +320,7 @@ enum net_bridge_opts {
 	BROPT_HAS_IPV6_ADDR,
 	BROPT_NEIGH_SUPPRESS_ENABLED,
 	BROPT_MTU_SET_BY_USER,
+	BROPT_VLAN_STATS_PER_PORT,
 };
 
 struct net_bridge {
@@ -859,6 +860,7 @@ int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 int __br_vlan_set_proto(struct net_bridge *br, __be16 proto);
 int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
 int br_vlan_set_stats(struct net_bridge *br, unsigned long val);
+int br_vlan_set_stats_per_port(struct net_bridge *br, unsigned long val);
 int br_vlan_init(struct net_bridge *br);
 int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
 int __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid);

commit 35750b0bca530b459c98b6383c19ee07d9546c14
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Sep 26 17:01:07 2018 +0300

    net: bridge: pack net_bridge better
    
    Further reduce the size of net_bridge with 8 bytes and reduce the number of
    holes in it:
     Before: holes: 5, sum holes: 15
     After: holes: 3, sum holes: 7
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 92d08f8c7dd4..57229b9d800f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -349,7 +349,6 @@ struct net_bridge {
 	/* STP */
 	bridge_id			designated_root;
 	bridge_id			bridge_id;
-	u32				root_path_cost;
 	unsigned char			topology_change;
 	unsigned char			topology_change_detected;
 	u16				root_port;
@@ -361,6 +360,7 @@ struct net_bridge {
 	unsigned long			bridge_hello_time;
 	unsigned long			bridge_forward_delay;
 	unsigned long			bridge_ageing_time;
+	u32				root_path_cost;
 
 	u8				group_addr[ETH_ALEN];
 
@@ -383,6 +383,7 @@ struct net_bridge {
 #if IS_ENABLED(CONFIG_IPV6)
 	u8				multicast_mld_version;
 #endif
+	spinlock_t			multicast_lock;
 	unsigned long			multicast_last_member_interval;
 	unsigned long			multicast_membership_interval;
 	unsigned long			multicast_querier_interval;
@@ -390,7 +391,6 @@ struct net_bridge {
 	unsigned long			multicast_query_response_interval;
 	unsigned long			multicast_startup_query_interval;
 
-	spinlock_t			multicast_lock;
 	struct net_bridge_mdb_htable __rcu *mdb;
 	struct hlist_head		router_list;
 

commit 3341d9170228d521fb38afae14b449308f3e4018
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Sep 26 17:01:06 2018 +0300

    net: bridge: convert mtu_set_by_user to a bit
    
    Convert the last remaining bool option to a bit thus reducing the overall
    net_bridge size further by 8 bytes.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 6bdcc701bc71..92d08f8c7dd4 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -319,6 +319,7 @@ enum net_bridge_opts {
 	BROPT_MULTICAST_STATS_ENABLED,
 	BROPT_HAS_IPV6_ADDR,
 	BROPT_NEIGH_SUPPRESS_ENABLED,
+	BROPT_MTU_SET_BY_USER,
 };
 
 struct net_bridge {
@@ -415,7 +416,6 @@ struct net_bridge {
 #ifdef CONFIG_NET_SWITCHDEV
 	int offload_fwd_mark;
 #endif
-	bool				mtu_set_by_user;
 	struct hlist_head		fdb_list;
 };
 

commit c69c2cd444ccf0ea5e5741f92073619e57217b6b
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Sep 26 17:01:05 2018 +0300

    net: bridge: convert neigh_suppress_enabled option to a bit
    
    Convert the neigh_suppress_enabled option to a bit.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e6bdb107fe04..6bdcc701bc71 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -318,6 +318,7 @@ enum net_bridge_opts {
 	BROPT_MULTICAST_QUERY_USE_IFADDR,
 	BROPT_MULTICAST_STATS_ENABLED,
 	BROPT_HAS_IPV6_ADDR,
+	BROPT_NEIGH_SUPPRESS_ENABLED,
 };
 
 struct net_bridge {
@@ -414,7 +415,6 @@ struct net_bridge {
 #ifdef CONFIG_NET_SWITCHDEV
 	int offload_fwd_mark;
 #endif
-	bool				neigh_suppress_enabled;
 	bool				mtu_set_by_user;
 	struct hlist_head		fdb_list;
 };

commit 675779adbf7c80cd4af8e085118c82be048643e7
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Sep 26 17:01:04 2018 +0300

    net: bridge: convert mcast options to bits
    
    This patch converts the rest of the mcast options to bits. It also packs
    the mcast options a little better by moving multicast_mld_version to an
    existing hole, reducing the net_bridge size by 8 bytes.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index fb1a266cdac8..e6bdb107fe04 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -314,6 +314,10 @@ enum net_bridge_opts {
 	BROPT_NF_CALL_ARPTABLES,
 	BROPT_GROUP_ADDR_SET,
 	BROPT_MULTICAST_ENABLED,
+	BROPT_MULTICAST_QUERIER,
+	BROPT_MULTICAST_QUERY_USE_IFADDR,
+	BROPT_MULTICAST_STATS_ENABLED,
+	BROPT_HAS_IPV6_ADDR,
 };
 
 struct net_bridge {
@@ -365,12 +369,6 @@ struct net_bridge {
 	} stp_enabled;
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
-	unsigned char			multicast_router;
-
-	u8				multicast_querier:1;
-	u8				multicast_query_use_ifaddr:1;
-	u8				has_ipv6_addr:1;
-	u8				multicast_stats_enabled:1;
 
 	u32				hash_elasticity;
 	u32				hash_max;
@@ -379,7 +377,10 @@ struct net_bridge {
 	u32				multicast_startup_query_count;
 
 	u8				multicast_igmp_version;
-
+	u8				multicast_router;
+#if IS_ENABLED(CONFIG_IPV6)
+	u8				multicast_mld_version;
+#endif
 	unsigned long			multicast_last_member_interval;
 	unsigned long			multicast_membership_interval;
 	unsigned long			multicast_querier_interval;
@@ -400,7 +401,6 @@ struct net_bridge {
 	struct bridge_mcast_other_query	ip6_other_query;
 	struct bridge_mcast_own_query	ip6_own_query;
 	struct bridge_mcast_querier	ip6_querier;
-	u8				multicast_mld_version;
 #endif /* IS_ENABLED(CONFIG_IPV6) */
 #endif
 
@@ -707,8 +707,8 @@ __br_multicast_querier_exists(struct net_bridge *br,
 {
 	bool own_querier_enabled;
 
-	if (br->multicast_querier) {
-		if (is_ipv6 && !br->has_ipv6_addr)
+	if (br_opt_get(br, BROPT_MULTICAST_QUERIER)) {
+		if (is_ipv6 && !br_opt_get(br, BROPT_HAS_IPV6_ADDR))
 			own_querier_enabled = false;
 		else
 			own_querier_enabled = true;

commit 13cefad2f2c1d99b778c62b142e077779c5f9395
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Sep 26 17:01:03 2018 +0300

    net: bridge: convert and rename mcast disabled
    
    Convert mcast disabled to an option bit and while doing so convert the
    logic to check if multicast is enabled instead. That is make the logic
    follow the option value - if it's set then mcast is enabled and vice versa.
    This avoids a few confusing places where we inverted the value that's being
    set to follow the mcast_disabled logic.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index dda117ce386e..fb1a266cdac8 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -313,6 +313,7 @@ enum net_bridge_opts {
 	BROPT_NF_CALL_IP6TABLES,
 	BROPT_NF_CALL_ARPTABLES,
 	BROPT_GROUP_ADDR_SET,
+	BROPT_MULTICAST_ENABLED,
 };
 
 struct net_bridge {
@@ -366,7 +367,6 @@ struct net_bridge {
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	unsigned char			multicast_router;
 
-	u8				multicast_disabled:1;
 	u8				multicast_querier:1;
 	u8				multicast_query_use_ifaddr:1;
 	u8				has_ipv6_addr:1;

commit be3664a038075b3d108e554d08d2578776b7b3a7
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Sep 26 17:01:02 2018 +0300

    net: bridge: convert group_addr_set option to a bit
    
    Convert group_addr_set internal bridge opt to a bit.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index d8eadab09d7d..dda117ce386e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -312,6 +312,7 @@ enum net_bridge_opts {
 	BROPT_NF_CALL_IPTABLES,
 	BROPT_NF_CALL_IP6TABLES,
 	BROPT_NF_CALL_ARPTABLES,
+	BROPT_GROUP_ADDR_SET,
 };
 
 struct net_bridge {
@@ -355,7 +356,6 @@ struct net_bridge {
 	unsigned long			bridge_ageing_time;
 
 	u8				group_addr[ETH_ALEN];
-	bool				group_addr_set;
 
 	enum {
 		BR_NO_STP, 		/* no spanning tree */

commit 8df3510f28e5cba2e94fecb40585e9b7e8a0c6ec
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Sep 26 17:01:01 2018 +0300

    net: bridge: convert nf call options to bits
    
    No functional change, convert of nf_call_[ip|ip6|arp]tables to bits.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 0abb632283ff..d8eadab09d7d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -309,6 +309,9 @@ static inline struct net_bridge_port *br_port_get_rtnl_rcu(const struct net_devi
 enum net_bridge_opts {
 	BROPT_VLAN_ENABLED,
 	BROPT_VLAN_STATS_ENABLED,
+	BROPT_NF_CALL_IPTABLES,
+	BROPT_NF_CALL_IP6TABLES,
+	BROPT_NF_CALL_ARPTABLES,
 };
 
 struct net_bridge {
@@ -331,9 +334,6 @@ struct net_bridge {
 		struct rtable		fake_rtable;
 		struct rt6_info		fake_rt6_info;
 	};
-	bool				nf_call_iptables;
-	bool				nf_call_ip6tables;
-	bool				nf_call_arptables;
 #endif
 	u16				group_fwd_mask;
 	u16				group_fwd_mask_required;

commit ae75767ec206c6f445973e5e6c5af8a865016e15
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Sep 26 17:01:00 2018 +0300

    net: bridge: add bitfield for options and convert vlan opts
    
    Bridge options have usually been added as separate fields all over the
    net_bridge struct taking up space and ending up in different cache lines.
    Let's move them to a single bitfield to save up space and speedup lookups.
    This patch adds a simple API for option modifying and retrieving using
    bitops and converts the first user of the API - the bridge vlan options
    (vlan_enabled and vlan_stats_enabled).
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 522d707cc533..0abb632283ff 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -306,16 +306,20 @@ static inline struct net_bridge_port *br_port_get_rtnl_rcu(const struct net_devi
 		rcu_dereference_rtnl(dev->rx_handler_data) : NULL;
 }
 
+enum net_bridge_opts {
+	BROPT_VLAN_ENABLED,
+	BROPT_VLAN_STATS_ENABLED,
+};
+
 struct net_bridge {
 	spinlock_t			lock;
 	spinlock_t			hash_lock;
 	struct list_head		port_list;
 	struct net_device		*dev;
 	struct pcpu_sw_netstats		__percpu *stats;
+	unsigned long			options;
 	/* These fields are accessed on each packet */
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
-	u8				vlan_enabled;
-	u8				vlan_stats_enabled;
 	__be16				vlan_proto;
 	u16				default_pvid;
 	struct net_bridge_vlan_group	__rcu *vlgrp;
@@ -489,6 +493,14 @@ static inline bool br_vlan_should_use(const struct net_bridge_vlan *v)
 	return true;
 }
 
+static inline int br_opt_get(const struct net_bridge *br,
+			     enum net_bridge_opts opt)
+{
+	return test_bit(opt, &br->options);
+}
+
+void br_opt_toggle(struct net_bridge *br, enum net_bridge_opts opt, bool on);
+
 /* br_device.c */
 void br_dev_setup(struct net_device *dev);
 void br_dev_delete(struct net_device *dev, struct list_head *list);

commit 1c1cb6d0321f4248e8a659a31659dcdac6866c29
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Sep 26 17:00:59 2018 +0300

    net: bridge: make struct opening bracket consistent
    
    Currently we have a mix of opening brackets on new lines and on the same
    line, let's move them all on the same line.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index d21035a17f4c..522d707cc533 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -54,14 +54,12 @@ typedef struct bridge_id bridge_id;
 typedef struct mac_addr mac_addr;
 typedef __u16 port_id;
 
-struct bridge_id
-{
+struct bridge_id {
 	unsigned char	prio[2];
 	unsigned char	addr[ETH_ALEN];
 };
 
-struct mac_addr
-{
+struct mac_addr {
 	unsigned char	addr[ETH_ALEN];
 };
 
@@ -207,8 +205,7 @@ struct net_bridge_port_group {
 	unsigned char			eth_addr[ETH_ALEN];
 };
 
-struct net_bridge_mdb_entry
-{
+struct net_bridge_mdb_entry {
 	struct hlist_node		hlist[2];
 	struct net_bridge		*br;
 	struct net_bridge_port_group __rcu *ports;
@@ -218,8 +215,7 @@ struct net_bridge_mdb_entry
 	bool				host_joined;
 };
 
-struct net_bridge_mdb_htable
-{
+struct net_bridge_mdb_htable {
 	struct hlist_head		*mhash;
 	struct rcu_head			rcu;
 	struct net_bridge_mdb_htable	*old;

commit 435f2e7cc0b783615d7fbcf08f5f00d289f9caeb
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Sep 11 09:39:53 2018 +0300

    net: bridge: add support for sticky fdb entries
    
    Add support for entries which are "sticky", i.e. will not change their port
    if they show up from a different one. A new ndm flag is introduced for that
    purpose - NTF_STICKY. We allow to set it only to non-local entries.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 11ed2029985f..d21035a17f4c 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -181,6 +181,7 @@ struct net_bridge_fdb_entry {
 	struct hlist_node		fdb_node;
 	unsigned char			is_local:1,
 					is_static:1,
+					is_sticky:1,
 					added_by_user:1,
 					added_by_external_learn:1,
 					offloaded:1;

commit 2756f68c314917d03eb348084edb08bb929139d9
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Mon Jul 23 11:16:59 2018 +0300

    net: bridge: add support for backup port
    
    This patch adds a new port attribute - IFLA_BRPORT_BACKUP_PORT, which
    allows to set a backup port to be used for known unicast traffic if the
    port has gone carrier down. The backup pointer is rcu protected and set
    only under RTNL, a counter is maintained so when deleting a port we know
    how many other ports reference it as a backup and we remove it from all.
    Also the pointer is in the first cache line which is hot at the time of
    the check and thus in the common case we only add one more test.
    The backup port will be used only for the non-flooding case since
    it's a part of the bridge and the flooded packets will be forwarded to it
    anyway. To remove the forwarding just send a 0/non-existing backup port.
    This is used to avoid numerous scalability problems when using MLAG most
    notably if we have thousands of fdbs one would need to change all of them
    on port carrier going down which takes too long and causes a storm of fdb
    notifications (and again when the port comes back up). In a Multi-chassis
    Link Aggregation setup usually hosts are connected to two different
    switches which act as a single logical switch. Those switches usually have
    a control and backup link between them called peerlink which might be used
    for communication in case a host loses connectivity to one of them.
    We need a fast way to failover in case a host port goes down and currently
    none of the solutions (like bond) cannot fulfill the requirements because
    the participating ports are actually the "master" devices and must have the
    same peerlink as their backup interface and at the same time all of them
    must participate in the bridge device. As Roopa noted it's normal practice
    in routing called fast re-route where a precalculated backup path is used
    when the main one is down.
    Another use case of this is with EVPN, having a single vxlan device which
    is backup of every port. Due to the nature of master devices it's not
    currently possible to use one device as a backup for many and still have
    all of them participate in the bridge (which is master itself).
    More detailed information about MLAG is available at the link below.
    https://docs.cumulusnetworks.com/display/DOCS/Multi-Chassis+Link+Aggregation+-+MLAG
    
    Further explanation and a diagram by Roopa:
    Two switches acting in a MLAG pair are connected by the peerlink
    interface which is a bridge port.
    
    the config on one of the switches looks like the below. The other
    switch also has a similar config.
    eth0 is connected to one port on the server. And the server is
    connected to both switches.
    
    br0 -- team0---eth0
          |
          -- switch-peerlink
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index cf0005d2a4d0..11ed2029985f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -237,6 +237,7 @@ struct net_bridge_port {
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	struct net_bridge_vlan_group	__rcu *vlgrp;
 #endif
+	struct net_bridge_port		__rcu *backup_port;
 
 	/* STP */
 	u8				priority;
@@ -281,6 +282,7 @@ struct net_bridge_port {
 	int				offload_fwd_mark;
 #endif
 	u16				group_fwd_mask;
+	u16				backup_redirected_cnt;
 };
 
 #define kobj_to_brport(obj)	container_of(obj, struct net_bridge_port, kobj)
@@ -597,6 +599,7 @@ netdev_features_t br_features_recompute(struct net_bridge *br,
 					netdev_features_t features);
 void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);
 void br_manage_promisc(struct net_bridge *br);
+int nbp_backup_change(struct net_bridge_port *p, struct net_device *backup_dev);
 
 /* br_input.c */
 int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb);

commit 705e0dea4d52ef420a7d37fd9cc6725092e5e1ff
Author: Tyler Hicks <tyhicks@canonical.com>
Date:   Fri Jul 20 21:56:54 2018 +0000

    bridge: make sure objects belong to container's owner
    
    When creating various bridge objects in /sys/class/net/... make sure
    that they belong to the container's owner instead of global root (if
    they belong to a container/namespace).
    
    Signed-off-by: Tyler Hicks <tyhicks@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 5216a524b537..cf0005d2a4d0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -283,6 +283,8 @@ struct net_bridge_port {
 	u16				group_fwd_mask;
 };
 
+#define kobj_to_brport(obj)	container_of(obj, struct net_bridge_port, kobj)
+
 #define br_auto_port(p) ((p)->flags & BR_AUTO_MASK)
 #define br_promisc_port(p) ((p)->flags & BR_PROMISC)
 

commit d66e4348969de33cccdd2bc3920b49fb0114b306
Author: Petr Machata <petrm@mellanox.com>
Date:   Wed May 30 02:56:03 2018 +0200

    net: bridge: Extract boilerplate around switchdev_port_obj_*()
    
    A call to switchdev_port_obj_add() or switchdev_port_obj_del() involves
    initializing a struct switchdev_obj_port_vlan, a piece of code that
    repeats on each call site almost verbatim. While in the current codebase
    there is just one duplicated add call, the follow-up patches add more of
    both add and del calls.
    
    Thus to remove the duplication, extract the repetition into named
    functions and reuse.
    
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 11520ed528b0..5216a524b537 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1139,6 +1139,8 @@ int br_switchdev_set_port_flag(struct net_bridge_port *p,
 			       unsigned long mask);
 void br_switchdev_fdb_notify(const struct net_bridge_fdb_entry *fdb,
 			     int type);
+int br_switchdev_port_vlan_add(struct net_device *dev, u16 vid, u16 flags);
+int br_switchdev_port_vlan_del(struct net_device *dev, u16 vid);
 
 static inline void br_switchdev_frame_unmark(struct sk_buff *skb)
 {
@@ -1168,6 +1170,17 @@ static inline int br_switchdev_set_port_flag(struct net_bridge_port *p,
 	return 0;
 }
 
+static inline int br_switchdev_port_vlan_add(struct net_device *dev,
+					     u16 vid, u16 flags)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int br_switchdev_port_vlan_del(struct net_device *dev, u16 vid)
+{
+	return -EOPNOTSUPP;
+}
+
 static inline void
 br_switchdev_fdb_notify(const struct net_bridge_fdb_entry *fdb, int type)
 {

commit 7d850abd5f4edb1b1ca4b4141a4453305736f564
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Thu May 24 11:56:48 2018 +0300

    net: bridge: add support for port isolation
    
    This patch adds support for a new port flag - BR_ISOLATED. If it is set
    then isolated ports cannot communicate between each other, but they can
    still communicate with non-isolated ports. The same can be achieved via
    ACLs but they can't scale with large number of ports and also the
    complexity of the rules grows. This feature can be used to achieve
    isolated vlan functionality (similar to pvlan) as well, though currently
    it will be port-wide (for all vlans on the port). The new test in
    should_deliver uses data that is already cache hot and the new boolean
    is used to avoid an additional source port test in should_deliver.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 742f40aefdaf..11520ed528b0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -423,6 +423,7 @@ struct br_input_skb_cb {
 #endif
 
 	bool proxyarp_replied;
+	bool src_port_isolated;
 
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	bool vlan_filtered;
@@ -574,6 +575,14 @@ int br_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb);
 void br_flood(struct net_bridge *br, struct sk_buff *skb,
 	      enum br_pkt_type pkt_type, bool local_rcv, bool local_orig);
 
+/* return true if both source port and dest port are isolated */
+static inline bool br_skb_isolated(const struct net_bridge_port *to,
+				   const struct sk_buff *skb)
+{
+	return BR_INPUT_SKB_CB(skb)->src_port_isolated &&
+	       (to->flags & BR_ISOLATED);
+}
+
 /* br_if.c */
 void br_port_carrier_check(struct net_bridge_port *p, bool *notified);
 int br_add_bridge(struct net *net, const char *name);

commit 161d82de1ff8430ef96d90d0da0e3643979791d2
Author: Petr Machata <petrm@mellanox.com>
Date:   Thu May 3 14:43:53 2018 +0200

    net: bridge: Notify about !added_by_user FDB entries
    
    Do not automatically bail out on sending notifications about activity on
    non-user-added FDB entries. Instead, notify about this activity except
    for cases where the activity itself originates in a notification, to
    avoid sending duplicate notifications.
    
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Ivan Vecera <ivecera@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 0ddeeea2c6a7..742f40aefdaf 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -553,9 +553,11 @@ int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
 int br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p);
 void br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p);
 int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,
-			      const unsigned char *addr, u16 vid);
+			      const unsigned char *addr, u16 vid,
+			      bool swdev_notify);
 int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
-			      const unsigned char *addr, u16 vid);
+			      const unsigned char *addr, u16 vid,
+			      bool swdev_notify);
 void br_fdb_offloaded_set(struct net_bridge *br, struct net_bridge_port *p,
 			  const unsigned char *addr, u16 vid);
 

commit faa1cd8298439cf56f7fd2d8647726b30c263bf0
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Thu May 3 13:47:24 2018 +0300

    net: bridge: avoid duplicate notification on up/down/change netdev events
    
    While handling netdevice events, br_device_event() sometimes uses
    br_stp_(disable|enable)_port which unconditionally send a notification,
    but then a second notification for the same event is sent at the end of
    the br_device_event() function. To avoid sending duplicate notifications
    in such cases, check if one has already been sent (i.e.
    br_stp_enable/disable_port have been called).
    The patch is based on a change by Satish Ashok.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1a5093115534..0ddeeea2c6a7 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -573,7 +573,7 @@ void br_flood(struct net_bridge *br, struct sk_buff *skb,
 	      enum br_pkt_type pkt_type, bool local_rcv, bool local_orig);
 
 /* br_if.c */
-void br_port_carrier_check(struct net_bridge_port *p);
+void br_port_carrier_check(struct net_bridge_port *p, bool *notified);
 int br_add_bridge(struct net *net, const char *name);
 int br_del_bridge(struct net *net, const char *name);
 int br_add_if(struct net_bridge *br, struct net_device *dev,

commit 4d4fd36126d66d6091ca5aaabab262b5da3849c5
Author: Petr Machata <petrm@mellanox.com>
Date:   Sun Apr 29 10:56:08 2018 +0300

    net: bridge: Publish bridge accessor functions
    
    Add a couple new functions to allow querying FDB and vlan settings of a
    bridge.
    
    Signed-off-by: Petr Machata <petrm@mellanox.com>
    Signed-off-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index a7cb3ece5031..1a5093115534 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -594,11 +594,22 @@ static inline bool br_rx_handler_check_rcu(const struct net_device *dev)
 	return rcu_dereference(dev->rx_handler) == br_handle_frame;
 }
 
+static inline bool br_rx_handler_check_rtnl(const struct net_device *dev)
+{
+	return rcu_dereference_rtnl(dev->rx_handler) == br_handle_frame;
+}
+
 static inline struct net_bridge_port *br_port_get_check_rcu(const struct net_device *dev)
 {
 	return br_rx_handler_check_rcu(dev) ? br_port_get_rcu(dev) : NULL;
 }
 
+static inline struct net_bridge_port *
+br_port_get_check_rtnl(const struct net_device *dev)
+{
+	return br_rx_handler_check_rtnl(dev) ? br_port_get_rtnl_rcu(dev) : NULL;
+}
+
 /* br_ioctl.c */
 int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd,

commit 804b854d374e39f5f8bff9638fd274b9a9ca7d33
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Mar 30 13:46:19 2018 +0300

    net: bridge: disable bridge MTU auto tuning if it was set manually
    
    As Roopa noted today the biggest source of problems when configuring
    bridge and ports is that the bridge MTU keeps changing automatically on
    port events (add/del/changemtu). That leads to inconsistent behaviour
    and network config software needs to chase the MTU and fix it on each
    such event. Let's improve on that situation and allow for the user to
    set any MTU within ETH_MIN/MAX limits, but once manually configured it
    is the user's responsibility to keep it correct afterwards.
    
    In case the MTU isn't manually set - the behaviour reverts to the
    previous and the bridge follows the minimum MTU.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 586f84b9670d..a7cb3ece5031 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -410,6 +410,7 @@ struct net_bridge {
 	int offload_fwd_mark;
 #endif
 	bool				neigh_suppress_enabled;
+	bool				mtu_set_by_user;
 	struct hlist_head		fdb_list;
 };
 
@@ -578,7 +579,7 @@ int br_del_bridge(struct net *net, const char *name);
 int br_add_if(struct net_bridge *br, struct net_device *dev,
 	      struct netlink_ext_ack *extack);
 int br_del_if(struct net_bridge *br, struct net_device *dev);
-int br_mtu(const struct net_bridge *br, bool max);
+void br_mtu_auto_adjust(struct net_bridge *br);
 netdev_features_t br_features_recompute(struct net_bridge *br,
 					netdev_features_t features);
 void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);

commit f40aa23339e2d06b1a8daaece5a511bb1c4f704c
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Mar 30 13:46:18 2018 +0300

    net: bridge: set min MTU on port events and allow user to set max
    
    Recently the bridge was changed to automatically set maximum MTU on port
    events (add/del/changemtu) when vlan filtering is enabled, but that
    actually changes behaviour in a way which breaks some setups and can lead
    to packet drops. In order to still allow that maximum to be set while being
    compatible, we add the ability for the user to tune the bridge MTU up to
    the maximum when vlan filtering is enabled, but that has to be done
    explicitly and all port events (add/del/changemtu) lead to resetting that
    MTU to the minimum as before.
    
    Suggested-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 048d5b51813b..586f84b9670d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -578,7 +578,7 @@ int br_del_bridge(struct net *net, const char *name);
 int br_add_if(struct net_bridge *br, struct net_device *dev,
 	      struct netlink_ext_ack *extack);
 int br_del_if(struct net_bridge *br, struct net_device *dev);
-int br_mtu(const struct net_bridge *br);
+int br_mtu(const struct net_bridge *br, bool max);
 netdev_features_t br_features_recompute(struct net_bridge *br,
 					netdev_features_t features);
 void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);

commit 419d14af9e07fb5ca32b1b1614793c6b1e242152
Author: Chas Williams <3chas3@gmail.com>
Date:   Thu Mar 22 11:34:06 2018 -0400

    bridge: Allow max MTU when multiple VLANs present
    
    If the bridge is allowing multiple VLANs, some VLANs may have
    different MTUs.  Instead of choosing the minimum MTU for the
    bridge interface, choose the maximum MTU of the bridge members.
    With this the user only needs to set a larger MTU on the member
    ports that are participating in the large MTU VLANS.
    
    Signed-off-by: Chas Williams <3chas3@gmail.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8e13a64d8c99..048d5b51813b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -578,7 +578,7 @@ int br_del_bridge(struct net *net, const char *name);
 int br_add_if(struct net_bridge *br, struct net_device *dev,
 	      struct netlink_ext_ack *extack);
 int br_del_if(struct net_bridge *br, struct net_device *dev);
-int br_min_mtu(const struct net_bridge *br);
+int br_mtu(const struct net_bridge *br);
 netdev_features_t br_features_recompute(struct net_bridge *br,
 					netdev_features_t features);
 void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);

commit 03aaa9e2677ee25bb31fb9f54ea72b4dacbe0df8
Author: Gustavo A. R. Silva <garsilva@embeddedor.com>
Date:   Thu Jan 18 17:37:45 2018 -0600

    bridge: return boolean instead of integer in br_multicast_is_router
    
    Return statements in functions returning bool should use
    true/false instead of 1/0.
    
    This issue was detected with the help of Coccinelle.
    
    Fixes: 85b352693264 ("bridge: Fix build error when IGMP_SNOOPING is not enabled")
    Signed-off-by: Gustavo A. R. Silva <garsilva@embeddedor.com>
    Reviewed-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 80559fd11b7e..8e13a64d8c99 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -760,7 +760,7 @@ static inline void br_multicast_flood(struct net_bridge_mdb_entry *mdst,
 
 static inline bool br_multicast_is_router(struct net_bridge *br)
 {
-	return 0;
+	return false;
 }
 
 static inline bool br_multicast_querier_exists(struct net_bridge *br,

commit eb7935830d00b9e0c4ca11382143ea2320eb45c2
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Dec 12 16:02:50 2017 +0200

    net: bridge: use rhashtable for fdbs
    
    Before this patch the bridge used a fixed 256 element hash table which
    was fine for small use cases (in my tests it starts to degrade
    above 1000 entries), but it wasn't enough for medium or large
    scale deployments. Modern setups have thousands of participants in a
    single bridge, even only enabling vlans and adding a few thousand vlan
    entries will cause a few thousand fdbs to be automatically inserted per
    participating port. So we need to scale the fdb table considerably to
    cope with modern workloads, and this patch converts it to use a
    rhashtable for its operations thus improving the bridge scalability.
    Tests show the following results (10 runs each), at up to 1000 entries
    rhashtable is ~3% slower, at 2000 rhashtable is 30% faster, at 3000 it
    is 2 times faster and at 30000 it is 50 times faster.
    Obviously this happens because of the properties of the two constructs
    and is expected, rhashtable keeps pretty much a constant time even with
    10000000 entries (tested), while the fixed hash table struggles
    considerably even above 10000.
    As a side effect this also reduces the net_bridge struct size from 3248
    bytes to 1344 bytes. Also note that the key struct is 8 bytes.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1312b8d20ec3..80559fd11b7e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -168,12 +168,17 @@ struct net_bridge_vlan_group {
 	u16				pvid;
 };
 
+struct net_bridge_fdb_key {
+	mac_addr addr;
+	u16 vlan_id;
+};
+
 struct net_bridge_fdb_entry {
-	struct hlist_node		hlist;
+	struct rhash_head		rhnode;
 	struct net_bridge_port		*dst;
 
-	mac_addr			addr;
-	__u16				vlan_id;
+	struct net_bridge_fdb_key	key;
+	struct hlist_node		fdb_node;
 	unsigned char			is_local:1,
 					is_static:1,
 					added_by_user:1,
@@ -315,7 +320,7 @@ struct net_bridge {
 	struct net_bridge_vlan_group	__rcu *vlgrp;
 #endif
 
-	struct hlist_head		hash[BR_HASH_SIZE];
+	struct rhashtable		fdb_hash_tbl;
 #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
 	union {
 		struct rtable		fake_rtable;
@@ -405,6 +410,7 @@ struct net_bridge {
 	int offload_fwd_mark;
 #endif
 	bool				neigh_suppress_enabled;
+	struct hlist_head		fdb_list;
 };
 
 struct br_input_skb_cb {
@@ -515,6 +521,8 @@ static inline void br_netpoll_disable(struct net_bridge_port *p)
 /* br_fdb.c */
 int br_fdb_init(void);
 void br_fdb_fini(void);
+int br_fdb_hash_init(struct net_bridge *br);
+void br_fdb_hash_fini(struct net_bridge *br);
 void br_fdb_flush(struct net_bridge *br);
 void br_fdb_find_delete_local(struct net_bridge *br,
 			      const struct net_bridge_port *p,

commit ff0fd34eaee9978f9ed7f6e2ac47f9590d4afac3
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Thu Nov 9 23:10:57 2017 +0100

    net: bridge: Rename mglist to host_joined
    
    The boolean mglist indicates the host has joined a particular
    multicast group on the bridge interface. It is badly named, obscuring
    what is means. Rename it.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 40553d832b6e..1312b8d20ec3 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -209,7 +209,7 @@ struct net_bridge_mdb_entry
 	struct rcu_head			rcu;
 	struct timer_list		timer;
 	struct br_ip			addr;
-	bool				mglist;
+	bool				host_joined;
 };
 
 struct net_bridge_mdb_htable

commit 928990631327cf00a9195e30fa22f7ae5f8d7e67
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Nov 1 12:18:13 2017 +0200

    net: bridge: add notifications for the bridge dev on vlan change
    
    Currently the bridge device doesn't generate any notifications upon vlan
    modifications on itself because it doesn't use the generic bridge
    notifications.
    With the recent changes we know if anything was modified in the vlan config
    thus we can generate a notification when necessary for the bridge device
    so add support to br_ifinfo_notify() similar to how other combined
    functions are done - if port is present it takes precedence, otherwise
    notify about the bridge. I've explicitly marked the locations where the
    notification should be always for the port by setting bridge to NULL.
    I've also taken the liberty to rearrange each modified function's local
    variables in reverse xmas tree as well.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 860e4afaf71a..40553d832b6e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1071,7 +1071,8 @@ extern int (*br_fdb_test_addr_hook)(struct net_device *dev, unsigned char *addr)
 extern struct rtnl_link_ops br_link_ops;
 int br_netlink_init(void);
 void br_netlink_fini(void);
-void br_ifinfo_notify(int event, struct net_bridge_port *port);
+void br_ifinfo_notify(int event, const struct net_bridge *br,
+		      const struct net_bridge_port *port);
 int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags);
 int br_dellink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags);
 int br_getlink(struct sk_buff *skb, u32 pid, u32 seq, struct net_device *dev,

commit f418af6343fbfaaa3306e7cf15906be4f20c69ff
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Oct 27 13:19:37 2017 +0300

    bridge: vlan: signal if anything changed on vlan add
    
    Before this patch there was no way to tell if the vlan add operation
    actually changed anything, thus we would always generate a notification
    on adds. Let's make the notifications more precise and generate them
    only if anything changed, so use the new bool parameter to signal that the
    vlan was updated. We cannot return an error because there are valid use
    cases that will be broken (e.g. overlapping range add) and also we can't
    risk masking errors due to calls into drivers for vlan add which can
    potentially return anything.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index fa0039f44818..860e4afaf71a 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -803,7 +803,8 @@ struct sk_buff *br_handle_vlan(struct net_bridge *br,
 			       const struct net_bridge_port *port,
 			       struct net_bridge_vlan_group *vg,
 			       struct sk_buff *skb);
-int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
+int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags,
+		bool *changed);
 int br_vlan_delete(struct net_bridge *br, u16 vid);
 void br_vlan_flush(struct net_bridge *br);
 struct net_bridge_vlan *br_vlan_find(struct net_bridge_vlan_group *vg, u16 vid);
@@ -816,7 +817,8 @@ int br_vlan_set_stats(struct net_bridge *br, unsigned long val);
 int br_vlan_init(struct net_bridge *br);
 int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
 int __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid);
-int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
+int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags,
+		 bool *changed);
 int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 void nbp_vlan_flush(struct net_bridge_port *port);
 int nbp_vlan_init(struct net_bridge_port *port);
@@ -903,8 +905,10 @@ static inline struct sk_buff *br_handle_vlan(struct net_bridge *br,
 	return skb;
 }
 
-static inline int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags)
+static inline int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags,
+			      bool *changed)
 {
+	*changed = false;
 	return -EOPNOTSUPP;
 }
 
@@ -926,8 +930,10 @@ static inline int br_vlan_init(struct net_bridge *br)
 	return 0;
 }
 
-static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags)
+static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags,
+			       bool *changed)
 {
+	*changed = false;
 	return -EOPNOTSUPP;
 }
 

commit ed842faeb2bd49256f00485402f3113205f91d30
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Fri Oct 6 22:12:39 2017 -0700

    bridge: suppress nd pkts on BR_NEIGH_SUPPRESS ports
    
    This patch avoids flooding and proxies ndisc packets
    for BR_NEIGH_SUPPRESS ports.
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 4e6b25be14d0..fa0039f44818 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1144,4 +1144,7 @@ static inline void br_switchdev_frame_unmark(struct sk_buff *skb)
 void br_recalculate_neigh_suppress_enabled(struct net_bridge *br);
 void br_do_proxy_suppress_arp(struct sk_buff *skb, struct net_bridge *br,
 			      u16 vid, struct net_bridge_port *p);
+void br_do_suppress_nd(struct sk_buff *skb, struct net_bridge *br,
+		       u16 vid, struct net_bridge_port *p, struct nd_msg *msg);
+struct nd_msg *br_is_nd_neigh_msg(struct sk_buff *skb, struct nd_msg *m);
 #endif

commit 057658cb33fbf4d4309f01fe8845903b1cd07fad
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Fri Oct 6 22:12:38 2017 -0700

    bridge: suppress arp pkts on BR_NEIGH_SUPPRESS ports
    
    This patch avoids flooding and proxies arp packets
    for BR_NEIGH_SUPPRESS ports.
    
    Moves existing br_do_proxy_arp to br_do_proxy_suppress_arp
    to support both proxy arp and neigh suppress.
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 00fa371b1fb2..4e6b25be14d0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1140,5 +1140,8 @@ static inline void br_switchdev_frame_unmark(struct sk_buff *skb)
 }
 #endif /* CONFIG_NET_SWITCHDEV */
 
+/* br_arp_nd_proxy.c */
 void br_recalculate_neigh_suppress_enabled(struct net_bridge *br);
+void br_do_proxy_suppress_arp(struct sk_buff *skb, struct net_bridge *br,
+			      u16 vid, struct net_bridge_port *p);
 #endif

commit 821f1b21cabb46827ce39ddf82e2789680b5042a
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Fri Oct 6 22:12:37 2017 -0700

    bridge: add new BR_NEIGH_SUPPRESS port flag to suppress arp and nd flood
    
    This patch adds a new bridge port flag BR_NEIGH_SUPPRESS to
    suppress arp and nd flood on bridge ports. It implements
    rfc7432, section 10.
    https://tools.ietf.org/html/rfc7432#section-10
    for ethernet VPN deployments. It is similar to the existing
    BR_PROXYARP* flags but has a few semantic differences to conform
    to EVPN standard. Unlike the existing flags, this new flag suppresses
    flood of all neigh discovery packets (arp and nd) to tunnel ports.
    Supports both vlan filtering and non-vlan filtering bridges.
    
    In case of EVPN, it is mainly used to avoid flooding
    of arp and nd packets to tunnel ports like vxlan.
    
    This patch adds netlink and sysfs support to set this bridge port
    flag.
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ab4df24f7bba..00fa371b1fb2 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -404,6 +404,7 @@ struct net_bridge {
 #ifdef CONFIG_NET_SWITCHDEV
 	int offload_fwd_mark;
 #endif
+	bool				neigh_suppress_enabled;
 };
 
 struct br_input_skb_cb {
@@ -1139,4 +1140,5 @@ static inline void br_switchdev_frame_unmark(struct sk_buff *skb)
 }
 #endif /* CONFIG_NET_SWITCHDEV */
 
+void br_recalculate_neigh_suppress_enabled(struct net_bridge *br);
 #endif

commit ca752be006013ac6f19721280f44c91ef07ad3d1
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Oct 4 17:48:50 2017 -0700

    net: bridge: Pass extack to down to netdev_master_upper_dev_link
    
    Pass extack arg to br_add_if. Add messages for a couple of failures
    and pass arg to netdev_master_upper_dev_link.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Acked-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 020c709a017f..ab4df24f7bba 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -566,7 +566,8 @@ void br_flood(struct net_bridge *br, struct sk_buff *skb,
 void br_port_carrier_check(struct net_bridge_port *p);
 int br_add_bridge(struct net *net, const char *name);
 int br_del_bridge(struct net *net, const char *name);
-int br_add_if(struct net_bridge *br, struct net_device *dev);
+int br_add_if(struct net_bridge *br, struct net_device *dev,
+	      struct netlink_ext_ack *extack);
 int br_del_if(struct net_bridge *br, struct net_device *dev);
 int br_min_mtu(const struct net_bridge *br);
 netdev_features_t br_features_recompute(struct net_bridge *br,

commit 5af48b59f35cf712793badabe1a574a0d0ce3bd3
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Sep 27 16:12:44 2017 +0300

    net: bridge: add per-port group_fwd_mask with less restrictions
    
    We need to be able to transparently forward most link-local frames via
    tunnels (e.g. vxlan, qinq). Currently the bridge's group_fwd_mask has a
    mask which restricts the forwarding of STP and LACP, but we need to be able
    to forward these over tunnels and control that forwarding on a per-port
    basis thus add a new per-port group_fwd_mask option which only disallows
    mac pause frames to be forwarded (they're always dropped anyway).
    The patch does not change the current default situation - all of the others
    are still restricted unless configured for forwarding.
    We have successfully tested this patch with LACP and STP forwarding over
    VxLAN and qinq tunnels.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e870cfc85b14..020c709a017f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -36,7 +36,14 @@
 /* Control of forwarding link local multicast */
 #define BR_GROUPFWD_DEFAULT	0
 /* Don't allow forwarding of control protocols like STP, MAC PAUSE and LACP */
-#define BR_GROUPFWD_RESTRICTED	0x0007u
+enum {
+	BR_GROUPFWD_STP		= BIT(0),
+	BR_GROUPFWD_MACPAUSE	= BIT(1),
+	BR_GROUPFWD_LACP	= BIT(2),
+};
+
+#define BR_GROUPFWD_RESTRICTED (BR_GROUPFWD_STP | BR_GROUPFWD_MACPAUSE | \
+				BR_GROUPFWD_LACP)
 /* The Nearest Customer Bridge Group Address, 01-80-C2-00-00-[00,0B,0C,0D,0F] */
 #define BR_GROUPFWD_8021AD	0xB801u
 
@@ -268,6 +275,7 @@ struct net_bridge_port {
 #ifdef CONFIG_NET_SWITCHDEV
 	int				offload_fwd_mark;
 #endif
+	u16				group_fwd_mask;
 };
 
 #define br_auto_port(p) ((p)->flags & BR_AUTO_MASK)

commit f1c2eddf4cb6a6c8ca5f6e728e7328b9c5bc3e8a
Author: Ido Schimmel <idosch@mellanox.com>
Date:   Sun Sep 3 17:44:13 2017 +0300

    bridge: switchdev: Use an helper to clear forward mark
    
    Instead of using ifdef in the C file.
    
    Signed-off-by: Ido Schimmel <idosch@mellanox.com>
    Suggested-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Tested-by: Yotam Gigi <yotamg@mellanox.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index fd9ee73e0a6d..e870cfc85b14 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1091,6 +1091,11 @@ int br_switchdev_set_port_flag(struct net_bridge_port *p,
 			       unsigned long mask);
 void br_switchdev_fdb_notify(const struct net_bridge_fdb_entry *fdb,
 			     int type);
+
+static inline void br_switchdev_frame_unmark(struct sk_buff *skb)
+{
+	skb->offload_fwd_mark = 0;
+}
 #else
 static inline int nbp_switchdev_mark_set(struct net_bridge_port *p)
 {
@@ -1119,6 +1124,10 @@ static inline void
 br_switchdev_fdb_notify(const struct net_bridge_fdb_entry *fdb, int type)
 {
 }
+
+static inline void br_switchdev_frame_unmark(struct sk_buff *skb)
+{
+}
 #endif /* CONFIG_NET_SWITCHDEV */
 
 #endif

commit 2512775985969a3dadb09670701f0c16499ee784
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Tue Jul 4 15:53:05 2017 +0300

    net, bridge: convert net_bridge_vlan.refcnt from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c18682f804a0..fd9ee73e0a6d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -21,6 +21,7 @@
 #include <net/ip6_fib.h>
 #include <linux/if_vlan.h>
 #include <linux/rhashtable.h>
+#include <linux/refcount.h>
 
 #define BR_HASH_BITS 8
 #define BR_HASH_SIZE (1 << BR_HASH_BITS)
@@ -127,7 +128,7 @@ struct net_bridge_vlan {
 		struct net_bridge_port	*port;
 	};
 	union {
-		atomic_t		refcnt;
+		refcount_t		refcnt;
 		struct net_bridge_vlan	*brvlan;
 	};
 

commit 9fe8bcec0dbc19604acc3a2cd469febf96f0d59a
Author: Arkadi Sharshevsky <arkadis@mellanox.com>
Date:   Thu Jun 8 08:44:15 2017 +0200

    net: bridge: Receive notification about successful FDB offload
    
    When a new static FDB is added to the bridge a notification is sent to
    the driver for offload. In case of successful offload the driver should
    notify the bridge back, which in turn should mark the FDB as offloaded.
    
    Currently, externally learned is equivalent for being offloaded which is
    not correct due to the fact that FDBs which are added from user-space are
    also marked as externally learned. In order to specify if an FDB was
    successfully offloaded a new flag is introduced.
    
    Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 98410ea032cb..c18682f804a0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -169,7 +169,8 @@ struct net_bridge_fdb_entry {
 	unsigned char			is_local:1,
 					is_static:1,
 					added_by_user:1,
-					added_by_external_learn:1;
+					added_by_external_learn:1,
+					offloaded:1;
 
 	/* write-heavy members should not affect lookups */
 	unsigned long			updated ____cacheline_aligned_in_smp;
@@ -536,6 +537,8 @@ int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,
 			      const unsigned char *addr, u16 vid);
 int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 			      const unsigned char *addr, u16 vid);
+void br_fdb_offloaded_set(struct net_bridge *br, struct net_bridge_port *p,
+			  const unsigned char *addr, u16 vid);
 
 /* br_forward.c */
 enum br_pkt_type {

commit 6b26b51b1d13c62a09f55d745b06a8e964900715
Author: Arkadi Sharshevsky <arkadis@mellanox.com>
Date:   Thu Jun 8 08:44:14 2017 +0200

    net: bridge: Add support for notifying devices about FDB add/del
    
    Currently the bridge doesn't notify the underlying devices about new
    FDBs learned. The FDB sync is placed on the switchdev notifier chain
    because devices may potentially learn FDB that are not directly related
    to their ports, for example:
    
    1. Mixed SW/HW bridge - FDBs that point to the ASICs external devices
                            should be offloaded as CPU traps in order to
                            perform forwarding in slow path.
    2. EVPN - Externally learned FDBs for the vtep device.
    
    Notification is sent only about static FDB add/del. This is done due
    to fact that currently this is the only scenario supported by switch
    drivers.
    
    Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Ivan Vecera <ivecera@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index a122684b6a41..98410ea032cb 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1085,6 +1085,8 @@ bool nbp_switchdev_allowed_egress(const struct net_bridge_port *p,
 int br_switchdev_set_port_flag(struct net_bridge_port *p,
 			       unsigned long flags,
 			       unsigned long mask);
+void br_switchdev_fdb_notify(const struct net_bridge_fdb_entry *fdb,
+			     int type);
 #else
 static inline int nbp_switchdev_mark_set(struct net_bridge_port *p)
 {
@@ -1108,6 +1110,11 @@ static inline int br_switchdev_set_port_flag(struct net_bridge_port *p,
 {
 	return 0;
 }
+
+static inline void
+br_switchdev_fdb_notify(const struct net_bridge_fdb_entry *fdb, int type)
+{
+}
 #endif /* CONFIG_NET_SWITCHDEV */
 
 #endif

commit 0baa10fff2c8a8a0e3bca8fb43112ed93c179c38
Author: Arkadi Sharshevsky <arkadis@mellanox.com>
Date:   Thu Jun 8 08:44:12 2017 +0200

    net: bridge: Add support for calling FDB external learning under rcu
    
    This is done as a preparation to moving the switchdev notifier chain
    to be atomic. The FDB external learning should be called under rtnl
    or rcu.
    
    Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 7f439927a66d..a122684b6a41 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -284,6 +284,12 @@ static inline struct net_bridge_port *br_port_get_rtnl(const struct net_device *
 		rtnl_dereference(dev->rx_handler_data) : NULL;
 }
 
+static inline struct net_bridge_port *br_port_get_rtnl_rcu(const struct net_device *dev)
+{
+	return br_port_exists(dev) ?
+		rcu_dereference_rtnl(dev->rx_handler_data) : NULL;
+}
+
 struct net_bridge {
 	spinlock_t			lock;
 	spinlock_t			hash_lock;

commit 3922285d96e79231817227439c214728edfbe406
Author: Arkadi Sharshevsky <arkadis@mellanox.com>
Date:   Thu Jun 8 08:44:11 2017 +0200

    net: bridge: Add support for offloading port attributes
    
    Currently the flood, learning and learning_sync port attributes are
    offloaded by setting the SELF flag. Add support for offloading the
    flood and learning attribute through the bridge code. In case of
    setting an unsupported flag on a offloded port the operation will
    fail.
    
    The learning_sync attribute doesn't have any software representation
    and cannot be offloaded through the bridge code.
    
    Signed-off-by: Arkadi Sharshevsky <arkadis@mellanox.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Ivan Vecera <ivecera@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 20626927f433..7f439927a66d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -1076,6 +1076,9 @@ void nbp_switchdev_frame_mark(const struct net_bridge_port *p,
 			      struct sk_buff *skb);
 bool nbp_switchdev_allowed_egress(const struct net_bridge_port *p,
 				  const struct sk_buff *skb);
+int br_switchdev_set_port_flag(struct net_bridge_port *p,
+			       unsigned long flags,
+			       unsigned long mask);
 #else
 static inline int nbp_switchdev_mark_set(struct net_bridge_port *p)
 {
@@ -1092,6 +1095,13 @@ static inline bool nbp_switchdev_allowed_egress(const struct net_bridge_port *p,
 {
 	return true;
 }
+
+static inline int br_switchdev_set_port_flag(struct net_bridge_port *p,
+					     unsigned long flags,
+					     unsigned long mask)
+{
+	return 0;
+}
 #endif /* CONFIG_NET_SWITCHDEV */
 
 #endif

commit 1f51445af35e8477027d87ca015a10257b13f5a2
Author: Ido Schimmel <idosch@mellanox.com>
Date:   Fri May 26 08:37:23 2017 +0200

    bridge: Export VLAN filtering state
    
    It's useful for drivers supporting bridge offload to be able to query
    the bridge's VLAN filtering state.
    
    Currently, upon enslavement to a bridge master, the offloading driver
    will only learn about the bridge's VLAN filtering state after the bridge
    device was already linked with its slave.
    
    Being able to query the bridge's VLAN filtering state allows such
    drivers to forbid enslavement in case resource couldn't be allocated for
    a VLAN-aware bridge and also choose the correct initialization routine
    for the enslaved port, which is dependent on the bridge type.
    
    Signed-off-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 0d177280aa84..20626927f433 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -854,10 +854,6 @@ static inline u16 br_get_pvid(const struct net_bridge_vlan_group *vg)
 	return vg->pvid;
 }
 
-static inline int br_vlan_enabled(struct net_bridge *br)
-{
-	return br->vlan_enabled;
-}
 #else
 static inline bool br_allowed_ingress(const struct net_bridge *br,
 				      struct net_bridge_vlan_group *vg,
@@ -945,11 +941,6 @@ static inline u16 br_get_pvid(const struct net_bridge_vlan_group *vg)
 	return 0;
 }
 
-static inline int br_vlan_enabled(struct net_bridge *br)
-{
-	return 0;
-}
-
 static inline int __br_vlan_filter_toggle(struct net_bridge *br,
 					  unsigned long val)
 {

commit b6fe0440c63716e09cfc0d1484e3898a0f29d1d1
Author: Ido Schimmel <idosch@mellanox.com>
Date:   Mon Apr 10 14:59:27 2017 +0300

    bridge: implement missing ndo_uninit()
    
    While the bridge driver implements an ndo_init(), it was missing a
    symmetric ndo_uninit(), causing the different de-initialization
    operations to be scattered around its dellink() and destructor().
    
    Implement a symmetric ndo_uninit() and remove the overlapping operations
    from its dellink() and destructor().
    
    This is a prerequisite for the next patch, as it allows us to have a
    proper cleanup upon changelink() failure during the bridge's newlink().
    
    Fixes: b6677449dff6 ("bridge: netlink: call br_changelink() during br_dev_newlink()")
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 61368186edea..0d177280aa84 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -620,6 +620,7 @@ void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
 void br_multicast_count(struct net_bridge *br, const struct net_bridge_port *p,
 			const struct sk_buff *skb, u8 type, u8 dir);
 int br_multicast_init_stats(struct net_bridge *br);
+void br_multicast_uninit_stats(struct net_bridge *br);
 void br_multicast_get_stats(const struct net_bridge *br,
 			    const struct net_bridge_port *p,
 			    struct br_mcast_stats *dest);
@@ -760,6 +761,10 @@ static inline int br_multicast_init_stats(struct net_bridge *br)
 	return 0;
 }
 
+static inline void br_multicast_uninit_stats(struct net_bridge *br)
+{
+}
+
 static inline int br_multicast_igmp_type(const struct sk_buff *skb)
 {
 	return 0;

commit d12c917691b45d9dffcfe7c2362d25caa40905fd
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Thu Mar 16 10:32:42 2017 -0700

    bridge: resolve a false alarm of lockdep
    
    Andrei reported a false alarm of lockdep at net/bridge/br_fdb.c:109,
    this is because in Andrei's case, a spin_bug() was already triggered
    before this, therefore the debug_locks is turned off, lockdep_is_held()
    is no longer accurate after that. We should use lockdep_assert_held_once()
    instead of lockdep_is_held() to respect debug_locks.
    
    Fixes: 410b3d48f5111 ("bridge: fdb: add proper lock checks in searching functions")
    Reported-by: Andrei Vagin <avagin@gmail.com>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2288fca7756c..61368186edea 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -531,15 +531,6 @@ int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,
 int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 			      const unsigned char *addr, u16 vid);
 
-static inline bool br_hash_lock_held(struct net_bridge *br)
-{
-#ifdef CONFIG_LOCKDEP
-	return lockdep_is_held(&br->hash_lock);
-#else
-	return true;
-#endif
-}
-
 /* br_forward.c */
 enum br_pkt_type {
 	BR_PKT_UNICAST,

commit 410b3d48f5111a28bb8d4c3d3dc5984c1baf7fc9
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Mon Feb 13 14:59:10 2017 +0100

    bridge: fdb: add proper lock checks in searching functions
    
    In order to avoid new errors add checks to br_fdb_find and fdb_find_rcu
    functions. The first requires hash_lock, the second obviously RCU.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 61368186edea..2288fca7756c 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -531,6 +531,15 @@ int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,
 int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 			      const unsigned char *addr, u16 vid);
 
+static inline bool br_hash_lock_held(struct net_bridge *br)
+{
+#ifdef CONFIG_LOCKDEP
+	return lockdep_is_held(&br->hash_lock);
+#else
+	return true;
+#endif
+}
+
 /* br_forward.c */
 enum br_pkt_type {
 	BR_PKT_UNICAST,

commit bfd0aeac52f74bfb44c0974131e44abb33a13e78
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Mon Feb 13 14:59:09 2017 +0100

    bridge: fdb: converge fdb searching functions into one
    
    Before this patch we had 3 different fdb searching functions which was
    confusing. This patch reduces all of them to one - fdb_find_rcu(), and
    two flavors: br_fdb_find() which requires hash_lock and br_fdb_find_rcu
    which requires RCU. This makes it clear what needs to be used, we also
    remove two abusers of __br_fdb_get which called it under hash_lock and
    replace them with br_fdb_find().
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1cbbf63a5ef7..61368186edea 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -507,8 +507,9 @@ void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
 void br_fdb_cleanup(struct work_struct *work);
 void br_fdb_delete_by_port(struct net_bridge *br,
 			   const struct net_bridge_port *p, u16 vid, int do_all);
-struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
-					  const unsigned char *addr, __u16 vid);
+struct net_bridge_fdb_entry *br_fdb_find_rcu(struct net_bridge *br,
+					     const unsigned char *addr,
+					     __u16 vid);
 int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
 int br_fdb_fillbuf(struct net_bridge *br, void *buf, unsigned long count,
 		   unsigned long off);

commit 1214628cb1868254e107230c9052f28ff9899b6a
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sat Feb 4 18:05:08 2017 +0100

    bridge: move write-heavy fdb members in their own cache line
    
    Fdb's used and updated fields are written to on every packet forward and
    packet receive respectively. Thus if we are receiving packets from a
    particular fdb, they'll cause false-sharing with everyone who has looked
    it up (even if it didn't match, since mac/vid share cache line!). The
    "used" field is even worse since it is updated on every packet forward
    to that fdb, thus the standard config where X ports use a single gateway
    results in 100% fdb false-sharing. Note that this patch does not prevent
    the last scenario, but it makes it better for other bridge participants
    which are not using that fdb (and are only doing lookups over it).
    The point is with this move we make sure that only communicating parties
    get the false-sharing, in a later patch we'll show how to avoid that too.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 47fd64bf5022..1cbbf63a5ef7 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -160,19 +160,21 @@ struct net_bridge_vlan_group {
 	u16				pvid;
 };
 
-struct net_bridge_fdb_entry
-{
+struct net_bridge_fdb_entry {
 	struct hlist_node		hlist;
 	struct net_bridge_port		*dst;
 
-	unsigned long			updated;
-	unsigned long			used;
 	mac_addr			addr;
 	__u16				vlan_id;
 	unsigned char			is_local:1,
 					is_static:1,
 					added_by_user:1,
 					added_by_external_learn:1;
+
+	/* write-heavy members should not affect lookups */
+	unsigned long			updated ____cacheline_aligned_in_smp;
+	unsigned long			used;
+
 	struct rcu_head			rcu;
 };
 

commit f7cdee8a79a1cb03fa9ca71b825e72f880b344e1
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sat Feb 4 18:05:07 2017 +0100

    bridge: move to workqueue gc
    
    Move the fdb garbage collector to a workqueue which fires at least 10
    milliseconds apart and cleans chain by chain allowing for other tasks
    to run in the meantime. When having thousands of fdbs the system is much
    more responsive. Most importantly remove the need to check if the
    matched entry has expired in __br_fdb_get that causes false-sharing and
    is completely unnecessary if we cleanup entries, at worst we'll get 10ms
    of traffic for that entry before it gets deleted.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ec8560349b6f..47fd64bf5022 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -379,7 +379,7 @@ struct net_bridge {
 	struct timer_list		hello_timer;
 	struct timer_list		tcn_timer;
 	struct timer_list		topology_change_timer;
-	struct timer_list		gc_timer;
+	struct delayed_work		gc_work;
 	struct kobject			*ifobj;
 	u32				auto_cnt;
 
@@ -502,7 +502,7 @@ void br_fdb_find_delete_local(struct net_bridge *br,
 			      const unsigned char *addr, u16 vid);
 void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr);
 void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
-void br_fdb_cleanup(unsigned long arg);
+void br_fdb_cleanup(struct work_struct *work);
 void br_fdb_delete_by_port(struct net_bridge *br,
 			   const struct net_bridge_port *p, u16 vid, int do_all);
 struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,

commit 1f90c7f3470580e24da25f6a6c1fb480ed9371ac
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sat Feb 4 18:05:06 2017 +0100

    bridge: modify bridge and port to have often accessed fields in one cache line
    
    Move around net_bridge so the vlan fields are in the beginning since
    they're checked on every packet even if vlan filtering is disabled.
    For the port move flags & vlan group to the beginning, so they're in the
    same cache line with the port's state (both flags and state are checked
    on each packet).
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 40177df45ba6..ec8560349b6f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -212,12 +212,16 @@ struct net_bridge_mdb_htable
 	u32				ver;
 };
 
-struct net_bridge_port
-{
+struct net_bridge_port {
 	struct net_bridge		*br;
 	struct net_device		*dev;
 	struct list_head		list;
 
+	unsigned long			flags;
+#ifdef CONFIG_BRIDGE_VLAN_FILTERING
+	struct net_bridge_vlan_group	__rcu *vlgrp;
+#endif
+
 	/* STP */
 	u8				priority;
 	u8				state;
@@ -238,8 +242,6 @@ struct net_bridge_port
 	struct kobject			kobj;
 	struct rcu_head			rcu;
 
-	unsigned long 			flags;
-
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	struct bridge_mcast_own_query	ip4_own_query;
 #if IS_ENABLED(CONFIG_IPV6)
@@ -259,9 +261,6 @@ struct net_bridge_port
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	struct netpoll			*np;
 #endif
-#ifdef CONFIG_BRIDGE_VLAN_FILTERING
-	struct net_bridge_vlan_group	__rcu *vlgrp;
-#endif
 #ifdef CONFIG_NET_SWITCHDEV
 	int				offload_fwd_mark;
 #endif
@@ -283,14 +282,21 @@ static inline struct net_bridge_port *br_port_get_rtnl(const struct net_device *
 		rtnl_dereference(dev->rx_handler_data) : NULL;
 }
 
-struct net_bridge
-{
+struct net_bridge {
 	spinlock_t			lock;
+	spinlock_t			hash_lock;
 	struct list_head		port_list;
 	struct net_device		*dev;
-
 	struct pcpu_sw_netstats		__percpu *stats;
-	spinlock_t			hash_lock;
+	/* These fields are accessed on each packet */
+#ifdef CONFIG_BRIDGE_VLAN_FILTERING
+	u8				vlan_enabled;
+	u8				vlan_stats_enabled;
+	__be16				vlan_proto;
+	u16				default_pvid;
+	struct net_bridge_vlan_group	__rcu *vlgrp;
+#endif
+
 	struct hlist_head		hash[BR_HASH_SIZE];
 #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
 	union {
@@ -308,6 +314,9 @@ struct net_bridge
 	bridge_id			designated_root;
 	bridge_id			bridge_id;
 	u32				root_path_cost;
+	unsigned char			topology_change;
+	unsigned char			topology_change_detected;
+	u16				root_port;
 	unsigned long			max_age;
 	unsigned long			hello_time;
 	unsigned long			forward_delay;
@@ -319,7 +328,6 @@ struct net_bridge
 
 	u8				group_addr[ETH_ALEN];
 	bool				group_addr_set;
-	u16				root_port;
 
 	enum {
 		BR_NO_STP, 		/* no spanning tree */
@@ -327,9 +335,6 @@ struct net_bridge
 		BR_USER_STP,		/* new RSTP in userspace */
 	} stp_enabled;
 
-	unsigned char			topology_change;
-	unsigned char			topology_change_detected;
-
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	unsigned char			multicast_router;
 
@@ -381,14 +386,6 @@ struct net_bridge
 #ifdef CONFIG_NET_SWITCHDEV
 	int offload_fwd_mark;
 #endif
-
-#ifdef CONFIG_BRIDGE_VLAN_FILTERING
-	struct net_bridge_vlan_group	__rcu *vlgrp;
-	u8				vlan_enabled;
-	u8				vlan_stats_enabled;
-	__be16				vlan_proto;
-	u16				default_pvid;
-#endif
 };
 
 struct br_input_skb_cb {

commit 11538d039ac6efcf4f1a6c536e1b87cd3668a9fd
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Tue Jan 31 22:59:55 2017 -0800

    bridge: vlan dst_metadata hooks in ingress and egress paths
    
    - ingress hook:
        - if port is a tunnel port, use tunnel info in
          attached dst_metadata to map it to a local vlan
    - egress hook:
        - if port is a tunnel port, use tunnel info attached to
          vlan to set dst_metadata on the skb
    
    CC: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 61de90f28afa..40177df45ba6 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -775,6 +775,7 @@ bool br_allowed_egress(struct net_bridge_vlan_group *vg,
 		       const struct sk_buff *skb);
 bool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid);
 struct sk_buff *br_handle_vlan(struct net_bridge *br,
+			       const struct net_bridge_port *port,
 			       struct net_bridge_vlan_group *vg,
 			       struct sk_buff *skb);
 int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
@@ -874,6 +875,7 @@ static inline bool br_should_learn(struct net_bridge_port *p,
 }
 
 static inline struct sk_buff *br_handle_vlan(struct net_bridge *br,
+					     const struct net_bridge_port *port,
 					     struct net_bridge_vlan_group *vg,
 					     struct sk_buff *skb)
 {

commit efa5356b0d9753b9d7e63e41459eba106cce30f3
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Tue Jan 31 22:59:54 2017 -0800

    bridge: per vlan dst_metadata netlink support
    
    This patch adds support to attach per vlan tunnel info dst
    metadata. This enables bridge driver to map vlan to tunnel_info
    at ingress and egress. It uses the kernel dst_metadata infrastructure.
    
    The initial use case is vlan to vni bridging, but the api is generic
    to extend to any tunnel_info in the future:
        - Uapi to configure/unconfigure/dump per vlan tunnel data
        - netlink functions to configure vlan and tunnel_info mapping
        - Introduces bridge port flag BR_LWT_VLAN to enable attach/detach
        dst_metadata to bridged packets on ports. off by default.
        - changes to existing code is mainly refactor some existing vlan
        handling netlink code + hooks for new vlan tunnel code
        - I have kept the vlan tunnel code isolated in separate files.
        - most of the netlink vlan tunnel code is handling of vlan-tunid
        ranges (follows the vlan range handling code). To conserve space
        vlan-tunid by default are always dumped in ranges if applicable.
    
    Use case:
    example use for this is a vxlan bridging gateway or vtep
    which maps vlans to vn-segments (or vnis).
    
    iproute2 example (patched and pruned iproute2 output to just show
    relevant fdb entries):
    example shows same host mac learnt on two vni's and
    vlan 100 maps to vni 1000, vlan 101 maps to vni 1001
    
    before (netdev per vni):
    $bridge fdb show | grep "00:02:00:00:00:03"
    00:02:00:00:00:03 dev vxlan1001 vlan 101 master bridge
    00:02:00:00:00:03 dev vxlan1001 dst 12.0.0.8 self
    00:02:00:00:00:03 dev vxlan1000 vlan 100 master bridge
    00:02:00:00:00:03 dev vxlan1000 dst 12.0.0.8 self
    
    after this patch with collect metdata in bridged mode (single netdev):
    $bridge fdb show | grep "00:02:00:00:00:03"
    00:02:00:00:00:03 dev vxlan0 vlan 101 master bridge
    00:02:00:00:00:03 dev vxlan0 src_vni 1001 dst 12.0.0.8 self
    00:02:00:00:00:03 dev vxlan0 vlan 100 master bridge
    00:02:00:00:00:03 dev vxlan0 src_vni 1000 dst 12.0.0.8 self
    
    CC: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 0b82a227fc34..61de90f28afa 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -91,6 +91,11 @@ struct br_vlan_stats {
 	struct u64_stats_sync syncp;
 };
 
+struct br_tunnel_info {
+	__be64			tunnel_id;
+	struct metadata_dst	*tunnel_dst;
+};
+
 /**
  * struct net_bridge_vlan - per-vlan entry
  *
@@ -113,6 +118,7 @@ struct br_vlan_stats {
  */
 struct net_bridge_vlan {
 	struct rhash_head		vnode;
+	struct rhash_head		tnode;
 	u16				vid;
 	u16				flags;
 	struct br_vlan_stats __percpu	*stats;
@@ -124,6 +130,9 @@ struct net_bridge_vlan {
 		atomic_t		refcnt;
 		struct net_bridge_vlan	*brvlan;
 	};
+
+	struct br_tunnel_info		tinfo;
+
 	struct list_head		vlist;
 
 	struct rcu_head			rcu;
@@ -145,6 +154,7 @@ struct net_bridge_vlan {
  */
 struct net_bridge_vlan_group {
 	struct rhashtable		vlan_hash;
+	struct rhashtable		tunnel_hash;
 	struct list_head		vlan_list;
 	u16				num_vlans;
 	u16				pvid;

commit 6db6f0eae6052b70885562e1733896647ec1d807
Author: Felix Fietkau <nbd@nbd.name>
Date:   Sat Jan 21 21:01:32 2017 +0100

    bridge: multicast to unicast
    
    Implements an optional, per bridge port flag and feature to deliver
    multicast packets to any host on the according port via unicast
    individually. This is done by copying the packet per host and
    changing the multicast destination MAC to a unicast one accordingly.
    
    multicast-to-unicast works on top of the multicast snooping feature of
    the bridge. Which means unicast copies are only delivered to hosts which
    are interested in it and signalized this via IGMP/MLD reports
    previously.
    
    This feature is intended for interface types which have a more reliable
    and/or efficient way to deliver unicast packets than broadcast ones
    (e.g. wifi).
    
    However, it should only be enabled on interfaces where no IGMPv2/MLDv1
    report suppression takes place. This feature is disabled by default.
    
    The initial patch and idea is from Felix Fietkau.
    
    Signed-off-by: Felix Fietkau <nbd@nbd.name>
    [linus.luessing@c0d3.blue: various bug + style fixes, commit message]
    Signed-off-by: Linus Lssing <linus.luessing@c0d3.blue>
    Reviewed-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8ce621e8345c..0b82a227fc34 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -177,6 +177,7 @@ struct net_bridge_port_group {
 	struct timer_list		timer;
 	struct br_ip			addr;
 	unsigned char			flags;
+	unsigned char			eth_addr[ETH_ALEN];
 };
 
 struct net_bridge_mdb_entry
@@ -599,7 +600,7 @@ void br_multicast_free_pg(struct rcu_head *head);
 struct net_bridge_port_group *
 br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
 			    struct net_bridge_port_group __rcu *next,
-			    unsigned char flags);
+			    unsigned char flags, const unsigned char *src);
 void br_mdb_init(void);
 void br_mdb_uninit(void);
 void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,

commit 34d8acd8aabb6e070b6fb718909db80458ef32ec
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Sat Dec 10 13:44:29 2016 -0500

    net: bridge: shorten ageing time on topology change
    
    802.1D [1] specifies that the bridges must use a short value to age out
    dynamic entries in the Filtering Database for a period, once a topology
    change has been communicated by the root bridge.
    
    Add a bridge_ageing_time member in the net_bridge structure to store the
    bridge ageing time value configured by the user (ioctl/netlink/sysfs).
    
    If we are using in-kernel STP, shorten the ageing time value to twice
    the forward delay used by the topology when the topology change flag is
    set. When the flag is cleared, restore the configured ageing time.
    
    [1] "8.3.5 Notifying topology changes ",
        http://profesores.elo.utfsm.cl/~agv/elo309/doc/802.1D-1998.pdf
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e2cd6d12a273..8ce621e8345c 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -300,10 +300,11 @@ struct net_bridge
 	unsigned long			max_age;
 	unsigned long			hello_time;
 	unsigned long			forward_delay;
-	unsigned long			bridge_max_age;
 	unsigned long			ageing_time;
+	unsigned long			bridge_max_age;
 	unsigned long			bridge_hello_time;
 	unsigned long			bridge_forward_delay;
+	unsigned long			bridge_ageing_time;
 
 	u8				group_addr[ETH_ALEN];
 	bool				group_addr_set;

commit 82dd4332aa07843f7444c55bc17fee9bd76aa0f7
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Sat Dec 10 13:44:27 2016 -0500

    net: bridge: add helper to offload ageing time
    
    The SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME switchdev attr is actually set
    when initializing a bridge port, and when configuring the bridge ageing
    time from ioctl/netlink/sysfs.
    
    Add a __set_ageing_time helper to offload the ageing time to physical
    switches, and add the SWITCHDEV_F_DEFER flag since it can be called
    under bridge lock.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 26aec2366bc3..e2cd6d12a273 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -999,6 +999,7 @@ void __br_set_forward_delay(struct net_bridge *br, unsigned long t);
 int br_set_forward_delay(struct net_bridge *br, unsigned long x);
 int br_set_hello_time(struct net_bridge *br, unsigned long x);
 int br_set_max_age(struct net_bridge *br, unsigned long x);
+int __set_ageing_time(struct net_device *dev, unsigned long t);
 int br_set_ageing_time(struct net_bridge *br, clock_t ageing_time);
 
 

commit aa2ae3e71c74cc00ec22f133dc900b3817415785
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Mon Nov 21 13:03:25 2016 +0100

    bridge: mcast: add MLDv2 querier support
    
    This patch adds basic support for MLDv2 queries, the default is MLDv1
    as before. A new multicast option - multicast_mld_version, adds the
    ability to change it between 1 and 2 via netlink and sysfs.
    The MLD option is disabled if CONFIG_IPV6 is disabled.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3d207d92d899..26aec2366bc3 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -355,6 +355,7 @@ struct net_bridge
 	struct bridge_mcast_other_query	ip6_other_query;
 	struct bridge_mcast_own_query	ip6_own_query;
 	struct bridge_mcast_querier	ip6_querier;
+	u8				multicast_mld_version;
 #endif /* IS_ENABLED(CONFIG_IPV6) */
 #endif
 
@@ -585,6 +586,9 @@ int br_multicast_toggle(struct net_bridge *br, unsigned long val);
 int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
 int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
 int br_multicast_set_igmp_version(struct net_bridge *br, unsigned long val);
+#if IS_ENABLED(CONFIG_IPV6)
+int br_multicast_set_mld_version(struct net_bridge *br, unsigned long val);
+#endif
 struct net_bridge_mdb_entry *
 br_mdb_ip_get(struct net_bridge_mdb_htable *mdb, struct br_ip *dst);
 struct net_bridge_mdb_entry *

commit 5e9235853d652a295d5f56cb8652950b6b5bf56b
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Mon Nov 21 13:03:24 2016 +0100

    bridge: mcast: add IGMPv3 query support
    
    This patch adds basic support for IGMPv3 queries, the default is IGMPv2
    as before. A new multicast option - multicast_igmp_version, adds the
    ability to change it between 2 and 3 via netlink and sysfs. The option
    struct member is in a 4 byte hole in net_bridge.
    
    There also a few minor style adjustments in br_multicast_new_group and
    br_multicast_add_group.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1b63177e0ccd..3d207d92d899 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -333,6 +333,8 @@ struct net_bridge
 	u32				multicast_last_member_count;
 	u32				multicast_startup_query_count;
 
+	u8				multicast_igmp_version;
+
 	unsigned long			multicast_last_member_interval;
 	unsigned long			multicast_membership_interval;
 	unsigned long			multicast_querier_interval;
@@ -582,6 +584,7 @@ int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val);
 int br_multicast_toggle(struct net_bridge *br, unsigned long val);
 int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
 int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
+int br_multicast_set_igmp_version(struct net_bridge *br, unsigned long val);
 struct net_bridge_mdb_entry *
 br_mdb_ip_get(struct net_bridge_mdb_htable *mdb, struct br_ip *dst);
 struct net_bridge_mdb_entry *

commit 8addd5e7d3a5c118a214a7794ae299787198aa25
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Aug 31 15:36:51 2016 +0200

    net: bridge: change unicast boolean to exact pkt_type
    
    Remove the unicast flag and introduce an exact pkt_type. That would help us
    for the upcoming per-port multicast flood flag and also slightly reduce the
    tests in the input fast path.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3d36493f4487..1b63177e0ccd 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -517,12 +517,17 @@ int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 			      const unsigned char *addr, u16 vid);
 
 /* br_forward.c */
+enum br_pkt_type {
+	BR_PKT_UNICAST,
+	BR_PKT_MULTICAST,
+	BR_PKT_BROADCAST
+};
 int br_dev_queue_push_xmit(struct net *net, struct sock *sk, struct sk_buff *skb);
 void br_forward(const struct net_bridge_port *to, struct sk_buff *skb,
 		bool local_rcv, bool local_orig);
 int br_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb);
 void br_flood(struct net_bridge *br, struct sk_buff *skb,
-	      bool unicast, bool local_rcv, bool local_orig);
+	      enum br_pkt_type pkt_type, bool local_rcv, bool local_orig);
 
 /* br_if.c */
 void br_port_carrier_check(struct net_bridge_port *p);

commit d297653dd6f07afbe7e6c702a4bcd7615680002e
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Tue Aug 30 21:56:45 2016 -0700

    rtnetlink: fdb dump: optimize by saving last interface markers
    
    fdb dumps spanning multiple skb's currently restart from the first
    interface again for every skb. This results in unnecessary
    iterations on the already visited interfaces and their fdb
    entries. In large scale setups, we have seen this to slow
    down fdb dumps considerably. On a system with 30k macs we
    see fdb dumps spanning across more than 300 skbs.
    
    To fix the problem, this patch replaces the existing single fdb
    marker with three markers: netdev hash entries, netdevs and fdb
    index to continue where we left off instead of restarting from the
    first netdev. This is consistent with link dumps.
    
    In the process of fixing the performance issue, this patch also
    re-implements fix done by
    commit 472681d57a5d ("net: ndo_fdb_dump should report -EMSGSIZE to rtnl_fdb_dump")
    (with an internal fix from Wilson Kok) in the following ways:
    - change ndo_fdb_dump handlers to return error code instead
    of the last fdb index
    - use cb->args strictly for dump frag markers and not error codes.
    This is consistent with other dump functions.
    
    Below results were taken on a system with 1000 netdevs
    and 35085 fdb entries:
    before patch:
    $time bridge fdb show | wc -l
    15065
    
    real    1m11.791s
    user    0m0.070s
    sys 1m8.395s
    
    (existing code does not return all macs)
    
    after patch:
    $time bridge fdb show | wc -l
    35085
    
    real    0m2.017s
    user    0m0.113s
    sys 0m1.942s
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: Wilson Kok <wkok@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2379b2b865c9..3d36493f4487 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -508,7 +508,7 @@ int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[], struct net_device *dev,
 	       const unsigned char *addr, u16 vid, u16 nlh_flags);
 int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
-		struct net_device *dev, struct net_device *fdev, int idx);
+		struct net_device *dev, struct net_device *fdev, int *idx);
 int br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p);
 void br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p);
 int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,

commit 6bc506b4fb065eac3d89ca1ce37082e174493d9e
Author: Ido Schimmel <idosch@mellanox.com>
Date:   Thu Aug 25 18:42:37 2016 +0200

    bridge: switchdev: Add forward mark support for stacked devices
    
    switchdev_port_fwd_mark_set() is used to set the 'offload_fwd_mark' of
    port netdevs so that packets being flooded by the device won't be
    flooded twice.
    
    It works by assigning a unique identifier (the ifindex of the first
    bridge port) to bridge ports sharing the same parent ID. This prevents
    packets from being flooded twice by the same switch, but will flood
    packets through bridge ports belonging to a different switch.
    
    This method is problematic when stacked devices are taken into account,
    such as VLANs. In such cases, a physical port netdev can have upper
    devices being members in two different bridges, thus requiring two
    different 'offload_fwd_mark's to be configured on the port netdev, which
    is impossible.
    
    The main problem is that packet and netdev marking is performed at the
    physical netdev level, whereas flooding occurs between bridge ports,
    which are not necessarily port netdevs.
    
    Instead, packet and netdev marking should really be done in the bridge
    driver with the switch driver only telling it which packets it already
    forwarded. The bridge driver will mark such packets using the mark
    assigned to the ingress bridge port and will prevent the packet from
    being forwarded through any bridge port sharing the same mark (i.e.
    having the same parent ID).
    
    Remove the current switchdev 'offload_fwd_mark' implementation and
    instead implement the proposed method. In addition, make rocker - the
    sole user of the mark - use the proposed method.
    
    Signed-off-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index aac2a6e6b008..2379b2b865c9 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -251,6 +251,9 @@ struct net_bridge_port
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	struct net_bridge_vlan_group	__rcu *vlgrp;
 #endif
+#ifdef CONFIG_NET_SWITCHDEV
+	int				offload_fwd_mark;
+#endif
 };
 
 #define br_auto_port(p) ((p)->flags & BR_AUTO_MASK)
@@ -359,6 +362,11 @@ struct net_bridge
 	struct timer_list		gc_timer;
 	struct kobject			*ifobj;
 	u32				auto_cnt;
+
+#ifdef CONFIG_NET_SWITCHDEV
+	int offload_fwd_mark;
+#endif
+
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	struct net_bridge_vlan_group	__rcu *vlgrp;
 	u8				vlan_enabled;
@@ -381,6 +389,10 @@ struct br_input_skb_cb {
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	bool vlan_filtered;
 #endif
+
+#ifdef CONFIG_NET_SWITCHDEV
+	int offload_fwd_mark;
+#endif
 };
 
 #define BR_INPUT_SKB_CB(__skb)	((struct br_input_skb_cb *)(__skb)->cb)
@@ -1034,4 +1046,29 @@ static inline int br_sysfs_addbr(struct net_device *dev) { return 0; }
 static inline void br_sysfs_delbr(struct net_device *dev) { return; }
 #endif /* CONFIG_SYSFS */
 
+/* br_switchdev.c */
+#ifdef CONFIG_NET_SWITCHDEV
+int nbp_switchdev_mark_set(struct net_bridge_port *p);
+void nbp_switchdev_frame_mark(const struct net_bridge_port *p,
+			      struct sk_buff *skb);
+bool nbp_switchdev_allowed_egress(const struct net_bridge_port *p,
+				  const struct sk_buff *skb);
+#else
+static inline int nbp_switchdev_mark_set(struct net_bridge_port *p)
+{
+	return 0;
+}
+
+static inline void nbp_switchdev_frame_mark(const struct net_bridge_port *p,
+					    struct sk_buff *skb)
+{
+}
+
+static inline bool nbp_switchdev_allowed_egress(const struct net_bridge_port *p,
+						const struct sk_buff *skb)
+{
+	return true;
+}
+#endif /* CONFIG_NET_SWITCHDEV */
+
 #endif

commit 9e0b27fe5ada7752577f3e1260eec44e79476142
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Thu Jul 21 12:42:19 2016 -0400

    net: bridge: br_set_ageing_time takes a clock_t
    
    Change the ageing_time type in br_set_ageing_time() from u32 to what it
    is expected to be, i.e. a clock_t.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index b3088264f844..aac2a6e6b008 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -975,7 +975,7 @@ void __br_set_forward_delay(struct net_bridge *br, unsigned long t);
 int br_set_forward_delay(struct net_bridge *br, unsigned long x);
 int br_set_hello_time(struct net_bridge *br, unsigned long x);
 int br_set_max_age(struct net_bridge *br, unsigned long x);
-int br_set_ageing_time(struct net_bridge *br, u32 ageing_time);
+int br_set_ageing_time(struct net_bridge *br, clock_t ageing_time);
 
 
 /* br_stp_if.c */

commit 37b090e6be2dc98ccb55bb663931546282abf2e8
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Thu Jul 14 06:10:02 2016 +0300

    net: bridge: remove _deliver functions and consolidate forward code
    
    Before this patch we had two flavors of most forwarding functions -
    _forward and _deliver, the difference being that the latter are used
    when the packets are locally originated. Instead of all this function
    pointer passing and code duplication, we can just pass a boolean noting
    that the packet was locally originated and use that to perform the
    necessary checks in __br_forward. This gives a minor performance
    improvement but more importantly consolidates the forwarding paths.
    Also add a kernel doc comment to explain the exported br_forward()'s
    arguments.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 4d6cdf459e57..b3088264f844 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -505,14 +505,12 @@ int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 			      const unsigned char *addr, u16 vid);
 
 /* br_forward.c */
-void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb);
 int br_dev_queue_push_xmit(struct net *net, struct sock *sk, struct sk_buff *skb);
 void br_forward(const struct net_bridge_port *to, struct sk_buff *skb,
-		bool local_rcv);
+		bool local_rcv, bool local_orig);
 int br_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb);
-void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast);
-void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
-		      bool local_rcv, bool unicast);
+void br_flood(struct net_bridge *br, struct sk_buff *skb,
+	      bool unicast, bool local_rcv, bool local_orig);
 
 /* br_if.c */
 void br_port_carrier_check(struct net_bridge_port *p);
@@ -560,10 +558,8 @@ void br_multicast_init(struct net_bridge *br);
 void br_multicast_open(struct net_bridge *br);
 void br_multicast_stop(struct net_bridge *br);
 void br_multicast_dev_del(struct net_bridge *br);
-void br_multicast_deliver(struct net_bridge_mdb_entry *mdst,
-			  struct sk_buff *skb);
-void br_multicast_forward(struct net_bridge_mdb_entry *mdst,
-			  struct sk_buff *skb, bool local_rcv);
+void br_multicast_flood(struct net_bridge_mdb_entry *mdst,
+			struct sk_buff *skb, bool local_rcv, bool local_orig);
 int br_multicast_set_router(struct net_bridge *br, unsigned long val);
 int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val);
 int br_multicast_toggle(struct net_bridge *br, unsigned long val);
@@ -691,28 +687,27 @@ static inline void br_multicast_dev_del(struct net_bridge *br)
 {
 }
 
-static inline void br_multicast_deliver(struct net_bridge_mdb_entry *mdst,
-					struct sk_buff *skb)
+static inline void br_multicast_flood(struct net_bridge_mdb_entry *mdst,
+				      struct sk_buff *skb,
+				      bool local_rcv, bool local_orig)
 {
 }
 
-static inline void br_multicast_forward(struct net_bridge_mdb_entry *mdst,
-					struct sk_buff *skb,
-					bool local_rcv)
-{
-}
 static inline bool br_multicast_is_router(struct net_bridge *br)
 {
 	return 0;
 }
+
 static inline bool br_multicast_querier_exists(struct net_bridge *br,
 					       struct ethhdr *eth)
 {
 	return false;
 }
+
 static inline void br_mdb_init(void)
 {
 }
+
 static inline void br_mdb_uninit(void)
 {
 }

commit b35c5f632b630183396a2ea2e2247ff8bbf2c94f
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Thu Jul 14 06:10:01 2016 +0300

    net: bridge: drop skb2/skb0 variables and use a local_rcv boolean
    
    Currently if the packet is going to be received locally we set skb0 or
    sometimes called skb2 variables to the original skb. This can get
    confusing and also we can avoid one conditional on the fast path by
    simply using a boolean and passing it around. Thanks to Roopa for the
    name suggestion.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 40f200947ddc..4d6cdf459e57 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -507,12 +507,12 @@ int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 /* br_forward.c */
 void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb);
 int br_dev_queue_push_xmit(struct net *net, struct sock *sk, struct sk_buff *skb);
-void br_forward(const struct net_bridge_port *to,
-		struct sk_buff *skb, struct sk_buff *skb0);
+void br_forward(const struct net_bridge_port *to, struct sk_buff *skb,
+		bool local_rcv);
 int br_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb);
 void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast);
 void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
-		      struct sk_buff *skb2, bool unicast);
+		      bool local_rcv, bool unicast);
 
 /* br_if.c */
 void br_port_carrier_check(struct net_bridge_port *p);
@@ -563,7 +563,7 @@ void br_multicast_dev_del(struct net_bridge *br);
 void br_multicast_deliver(struct net_bridge_mdb_entry *mdst,
 			  struct sk_buff *skb);
 void br_multicast_forward(struct net_bridge_mdb_entry *mdst,
-			  struct sk_buff *skb, struct sk_buff *skb2);
+			  struct sk_buff *skb, bool local_rcv);
 int br_multicast_set_router(struct net_bridge *br, unsigned long val);
 int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val);
 int br_multicast_toggle(struct net_bridge *br, unsigned long val);
@@ -698,7 +698,7 @@ static inline void br_multicast_deliver(struct net_bridge_mdb_entry *mdst,
 
 static inline void br_multicast_forward(struct net_bridge_mdb_entry *mdst,
 					struct sk_buff *skb,
-					struct sk_buff *skb2)
+					bool local_rcv)
 {
 }
 static inline bool br_multicast_is_router(struct net_bridge *br)

commit a65056ecf4b48be0d0284a7b6a57b6dace10b843
Author: Nikolay Aleksandrov <razor@blackwall.org>
Date:   Wed Jul 6 12:12:21 2016 -0700

    net: bridge: extend MLD/IGMP query stats
    
    As was suggested this patch adds support for the different versions of MLD
    and IGMP query types. Since the user visible structure is still in net-next
    we can augment it instead of adding netlink attributes.
    The distinction between the different IGMP/MLD query types is done as
    suggested in Section 7.1, RFC 3376 [1] and Section 8.1, RFC 3810 [2] based
    on query payload size and code for IGMP. Since all IGMP packets go through
    multicast_rcv() and it uses ip_mc_check_igmp/ipv6_mc_check_mld we can be
    sure that at least the ip/ipv6 header can be directly used.
    
    [1] https://tools.ietf.org/html/rfc3376#section-7
    [2] https://tools.ietf.org/html/rfc3810#section-8.1
    
    Suggested-by: Linus Lssing <linus.luessing@c0d3.blue>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Acked-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 4dc851166ad1..40f200947ddc 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -586,7 +586,7 @@ void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
 void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
 		   int type);
 void br_multicast_count(struct net_bridge *br, const struct net_bridge_port *p,
-			__be16 proto, u8 type, u8 dir);
+			const struct sk_buff *skb, u8 type, u8 dir);
 int br_multicast_init_stats(struct net_bridge *br);
 void br_multicast_get_stats(const struct net_bridge *br,
 			    const struct net_bridge_port *p,
@@ -719,7 +719,8 @@ static inline void br_mdb_uninit(void)
 
 static inline void br_multicast_count(struct net_bridge *br,
 				      const struct net_bridge_port *p,
-				      __be16 proto, u8 type, u8 dir)
+				      const struct sk_buff *skb,
+				      u8 type, u8 dir)
 {
 }
 

commit 1080ab95e3c7bdd77870e209aff83c763fdcf439
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Jun 28 16:57:06 2016 +0200

    net: bridge: add support for IGMP/MLD stats and export them via netlink
    
    This patch adds stats support for the currently used IGMP/MLD types by the
    bridge. The stats are per-port (plus one stat per-bridge) and per-direction
    (RX/TX). The stats are exported via netlink via the new linkxstats API
    (RTM_GETSTATS). In order to minimize the performance impact, a new option
    is used to enable/disable the stats - multicast_stats_enabled, similar to
    the recent vlan stats. Also in order to avoid multiple IGMP/MLD type
    lookups and checks, we make use of the current "igmp" member of the bridge
    private skb->cb region to record the type on Rx (both host-generated and
    external packets pass by multicast_rcv()). We can do that since the igmp
    member was used as a boolean and all the valid IGMP/MLD types are positive
    values. The normal bridge fast-path is not affected at all, the only
    affected paths are the flooding ones and since we make use of the IGMP/MLD
    type, we can quickly determine if the packet should be counted using
    cache-hot data (cb's igmp member). We add counters for:
    * IGMP Queries
    * IGMP Leaves
    * IGMP v1/v2/v3 reports
    
    * MLD Queries
    * MLD Leaves
    * MLD v1/v2 reports
    
    These are invaluable when monitoring or debugging complex multicast setups
    with bridges.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 52edecf3c294..4dc851166ad1 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -75,6 +75,12 @@ struct bridge_mcast_querier {
 	struct br_ip addr;
 	struct net_bridge_port __rcu	*port;
 };
+
+/* IGMP/MLD statistics */
+struct bridge_mcast_stats {
+	struct br_mcast_stats mstats;
+	struct u64_stats_sync syncp;
+};
 #endif
 
 struct br_vlan_stats {
@@ -229,6 +235,7 @@ struct net_bridge_port
 	struct bridge_mcast_own_query	ip6_own_query;
 #endif /* IS_ENABLED(CONFIG_IPV6) */
 	unsigned char			multicast_router;
+	struct bridge_mcast_stats	__percpu *mcast_stats;
 	struct timer_list		multicast_router_timer;
 	struct hlist_head		mglist;
 	struct hlist_node		rlist;
@@ -315,6 +322,7 @@ struct net_bridge
 	u8				multicast_querier:1;
 	u8				multicast_query_use_ifaddr:1;
 	u8				has_ipv6_addr:1;
+	u8				multicast_stats_enabled:1;
 
 	u32				hash_elasticity;
 	u32				hash_max;
@@ -337,6 +345,7 @@ struct net_bridge
 	struct bridge_mcast_other_query	ip4_other_query;
 	struct bridge_mcast_own_query	ip4_own_query;
 	struct bridge_mcast_querier	ip4_querier;
+	struct bridge_mcast_stats	__percpu *mcast_stats;
 #if IS_ENABLED(CONFIG_IPV6)
 	struct bridge_mcast_other_query	ip6_other_query;
 	struct bridge_mcast_own_query	ip6_own_query;
@@ -543,7 +552,7 @@ int br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,
 		     struct sk_buff *skb, u16 vid);
 struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
 					struct sk_buff *skb, u16 vid);
-void br_multicast_add_port(struct net_bridge_port *port);
+int br_multicast_add_port(struct net_bridge_port *port);
 void br_multicast_del_port(struct net_bridge_port *port);
 void br_multicast_enable_port(struct net_bridge_port *port);
 void br_multicast_disable_port(struct net_bridge_port *port);
@@ -576,6 +585,12 @@ void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
 		   struct br_ip *group, int type, u8 flags);
 void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
 		   int type);
+void br_multicast_count(struct net_bridge *br, const struct net_bridge_port *p,
+			__be16 proto, u8 type, u8 dir);
+int br_multicast_init_stats(struct net_bridge *br);
+void br_multicast_get_stats(const struct net_bridge *br,
+			    const struct net_bridge_port *p,
+			    struct br_mcast_stats *dest);
 
 #define mlock_dereference(X, br) \
 	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
@@ -623,6 +638,11 @@ static inline bool br_multicast_querier_exists(struct net_bridge *br,
 		return false;
 	}
 }
+
+static inline int br_multicast_igmp_type(const struct sk_buff *skb)
+{
+	return BR_INPUT_SKB_CB(skb)->igmp;
+}
 #else
 static inline int br_multicast_rcv(struct net_bridge *br,
 				   struct net_bridge_port *port,
@@ -638,8 +658,9 @@ static inline struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
 	return NULL;
 }
 
-static inline void br_multicast_add_port(struct net_bridge_port *port)
+static inline int br_multicast_add_port(struct net_bridge_port *port)
 {
+	return 0;
 }
 
 static inline void br_multicast_del_port(struct net_bridge_port *port)
@@ -695,6 +716,22 @@ static inline void br_mdb_init(void)
 static inline void br_mdb_uninit(void)
 {
 }
+
+static inline void br_multicast_count(struct net_bridge *br,
+				      const struct net_bridge_port *p,
+				      __be16 proto, u8 type, u8 dir)
+{
+}
+
+static inline int br_multicast_init_stats(struct net_bridge *br)
+{
+	return 0;
+}
+
+static inline int br_multicast_igmp_type(const struct sk_buff *skb)
+{
+	return 0;
+}
 #endif
 
 /* br_vlan.c */

commit 0888d5f3c0f183ea6177355752ada433d370ac89
Author: daniel <daniel@dd-wrt.com>
Date:   Fri Jun 24 12:35:18 2016 +0200

    Bridge: Fix ipv6 mc snooping if bridge has no ipv6 address
    
    The bridge is falsly dropping ipv6 mulitcast packets if there is:
     1. No ipv6 address assigned on the brigde.
     2. No external mld querier present.
     3. The internal querier enabled.
    
    When the bridge fails to build mld queries, because it has no
    ipv6 address, it slilently returns, but keeps the local querier enabled.
    This specific case causes confusing packet loss.
    
    Ipv6 multicast snooping can only work if:
     a) An external querier is present
     OR
     b) The bridge has an ipv6 address an is capable of sending own queries
    
    Otherwise it has to forward/flood the ipv6 multicast traffic,
    because snooping cannot work.
    
    This patch fixes the issue by adding a flag to the bridge struct that
    indicates that there is currently no ipv6 address assinged to the bridge
    and returns a false state for the local querier in
    __br_multicast_querier_exists().
    
    Special thanks to Linus Lssing.
    
    Fixes: d1d81d4c3dd8 ("bridge: check return value of ipv6_dev_get_saddr()")
    Signed-off-by: Daniel Danzberger <daniel@dd-wrt.com>
    Acked-by: Linus Lssing <linus.luessing@c0d3.blue>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c7fb5d7a7218..52edecf3c294 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -314,6 +314,7 @@ struct net_bridge
 	u8				multicast_disabled:1;
 	u8				multicast_querier:1;
 	u8				multicast_query_use_ifaddr:1;
+	u8				has_ipv6_addr:1;
 
 	u32				hash_elasticity;
 	u32				hash_max;
@@ -588,10 +589,22 @@ static inline bool br_multicast_is_router(struct net_bridge *br)
 
 static inline bool
 __br_multicast_querier_exists(struct net_bridge *br,
-			      struct bridge_mcast_other_query *querier)
+				struct bridge_mcast_other_query *querier,
+				const bool is_ipv6)
 {
+	bool own_querier_enabled;
+
+	if (br->multicast_querier) {
+		if (is_ipv6 && !br->has_ipv6_addr)
+			own_querier_enabled = false;
+		else
+			own_querier_enabled = true;
+	} else {
+		own_querier_enabled = false;
+	}
+
 	return time_is_before_jiffies(querier->delay_time) &&
-	       (br->multicast_querier || timer_pending(&querier->timer));
+	       (own_querier_enabled || timer_pending(&querier->timer));
 }
 
 static inline bool br_multicast_querier_exists(struct net_bridge *br,
@@ -599,10 +612,12 @@ static inline bool br_multicast_querier_exists(struct net_bridge *br,
 {
 	switch (eth->h_proto) {
 	case (htons(ETH_P_IP)):
-		return __br_multicast_querier_exists(br, &br->ip4_other_query);
+		return __br_multicast_querier_exists(br,
+			&br->ip4_other_query, false);
 #if IS_ENABLED(CONFIG_IPV6)
 	case (htons(ETH_P_IPV6)):
-		return __br_multicast_querier_exists(br, &br->ip6_other_query);
+		return __br_multicast_querier_exists(br,
+			&br->ip6_other_query, true);
 #endif
 	default:
 		return false;

commit a60c090361ea211625c27052dbbc11c5222e20e4
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sat Apr 30 10:25:29 2016 +0200

    bridge: netlink: export per-vlan stats
    
    Add a new LINK_XSTATS_TYPE_BRIDGE attribute and implement the
    RTM_GETSTATS callbacks for IFLA_STATS_LINK_XSTATS (fill_linkxstats and
    get_linkxstats_size) in order to export the per-vlan stats.
    The paddings were added because soon these fields will be needed for
    per-port per-vlan stats (or something else if someone beats me to it) so
    avoiding at least a few more netlink attributes.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 12b6d82dbd68..c7fb5d7a7218 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -711,6 +711,8 @@ int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 void nbp_vlan_flush(struct net_bridge_port *port);
 int nbp_vlan_init(struct net_bridge_port *port);
 int nbp_get_num_vlan_infos(struct net_bridge_port *p, u32 filter_mask);
+void br_vlan_get_stats(const struct net_bridge_vlan *v,
+		       struct br_vlan_stats *stats);
 
 static inline struct net_bridge_vlan_group *br_vlan_group(
 					const struct net_bridge *br)
@@ -892,6 +894,11 @@ static inline struct net_bridge_vlan_group *nbp_vlan_group_rcu(
 {
 	return NULL;
 }
+
+static inline void br_vlan_get_stats(const struct net_bridge_vlan *v,
+				     struct br_vlan_stats *stats)
+{
+}
 #endif
 
 struct nf_br_ops {

commit 6dada9b10a0818ba72c249526a742c8c41274a73
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sat Apr 30 10:25:28 2016 +0200

    bridge: vlan: learn to count
    
    Add support for per-VLAN Tx/Rx statistics. Every global vlan context gets
    allocated a per-cpu stats which is then set in each per-port vlan context
    for quick access. The br_allowed_ingress() common function is used to
    account for Rx packets and the br_handle_vlan() common function is used
    to account for Tx packets. Stats accounting is performed only if the
    bridge-wide vlan_stats_enabled option is set either via sysfs or netlink.
    A struct hole between vlan_enabled and vlan_proto is used for the new
    option so it is in the same cache line. Currently it is binary (on/off)
    but it is intentionally restricted to exactly 0 and 1 since other values
    will be used in the future for different purposes (e.g. per-port stats).
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index d9da857182ef..12b6d82dbd68 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -77,12 +77,21 @@ struct bridge_mcast_querier {
 };
 #endif
 
+struct br_vlan_stats {
+	u64 rx_bytes;
+	u64 rx_packets;
+	u64 tx_bytes;
+	u64 tx_packets;
+	struct u64_stats_sync syncp;
+};
+
 /**
  * struct net_bridge_vlan - per-vlan entry
  *
  * @vnode: rhashtable member
  * @vid: VLAN id
  * @flags: bridge vlan flags
+ * @stats: per-cpu VLAN statistics
  * @br: if MASTER flag set, this points to a bridge struct
  * @port: if MASTER flag unset, this points to a port struct
  * @refcnt: if MASTER flag set, this is bumped for each port referencing it
@@ -100,6 +109,7 @@ struct net_bridge_vlan {
 	struct rhash_head		vnode;
 	u16				vid;
 	u16				flags;
+	struct br_vlan_stats __percpu	*stats;
 	union {
 		struct net_bridge	*br;
 		struct net_bridge_port	*port;
@@ -342,6 +352,7 @@ struct net_bridge
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	struct net_bridge_vlan_group	__rcu *vlgrp;
 	u8				vlan_enabled;
+	u8				vlan_stats_enabled;
 	__be16				vlan_proto;
 	u16				default_pvid;
 #endif
@@ -691,6 +702,7 @@ int __br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 int __br_vlan_set_proto(struct net_bridge *br, __be16 proto);
 int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
+int br_vlan_set_stats(struct net_bridge *br, unsigned long val);
 int br_vlan_init(struct net_bridge *br);
 int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
 int __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid);
@@ -880,7 +892,6 @@ static inline struct net_bridge_vlan_group *nbp_vlan_group_rcu(
 {
 	return NULL;
 }
-
 #endif
 
 struct nf_br_ops {

commit 45ebcce56823d14d196dbdecd26783b3d5f464a6
Author: Elad Raz <eladr@mellanox.com>
Date:   Thu Apr 21 12:52:45 2016 +0200

    bridge: mdb: Marking port-group as offloaded
    
    There is a race-condition when updating the mdb offload flag without using
    the mulicast_lock. This reverts commit 9e8430f8d60d98 ("bridge: mdb:
    Passing the port-group pointer to br_mdb module").
    
    This patch marks offloaded MDB entry as "offload" by changing the port-
    group flags and marks it as MDB_PG_FLAGS_OFFLOAD.
    
    When switchdev PORT_MDB succeeded and adds a multicast group, a completion
    callback is been invoked "br_mdb_complete". The completion function
    locks the multicast_lock and finds the right net_bridge_port_group and
    marks it as offloaded.
    
    Fixes: 9e8430f8d60d98 ("bridge: mdb: Passing the port-group pointer to br_mdb module")
    Reported-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: Elad Raz <eladr@mellanox.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Acked-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1b5d145dfcbf..d9da857182ef 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -560,8 +560,8 @@ br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
 			    unsigned char flags);
 void br_mdb_init(void);
 void br_mdb_uninit(void);
-void br_mdb_notify(struct net_device *dev, struct net_bridge_port_group *pg,
-		   int type);
+void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
+		   struct br_ip *group, int type, u8 flags);
 void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
 		   int type);
 

commit 7c25b16dbbcf37ce8019bacf634ee47d852225d9
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Tue Feb 16 10:09:51 2016 -0500

    net: bridge: log port STP state on change
    
    Remove the shared br_log_state function and print the info directly in
    br_set_state, where the net_bridge_port state is actually changed.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Acked-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 302ab0a43725..1b5d145dfcbf 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -900,7 +900,6 @@ static inline void br_nf_core_fini(void) {}
 #endif
 
 /* br_stp.c */
-void br_log_state(const struct net_bridge_port *p);
 void br_set_state(struct net_bridge_port *p, unsigned int state);
 struct net_bridge_port *br_get_port(struct net_bridge *br, u16 port_no);
 void br_init_port(struct net_bridge_port *p);

commit 9e8430f8d60d985c9f292b5eb5790cc13a87200c
Author: Elad Raz <eladr@mellanox.com>
Date:   Wed Feb 3 09:57:06 2016 +0100

    bridge: mdb: Passing the port-group pointer to br_mdb module
    
    Passing the port-group to br_mdb in order to allow direct access to the
    structure. br_mdb will later use the structure to reflect HW reflection
    status via "state" variable.
    
    Signed-off-by: Elad Raz <eladr@mellanox.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 67f4dce3c3d2..302ab0a43725 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -560,8 +560,8 @@ br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
 			    unsigned char flags);
 void br_mdb_init(void);
 void br_mdb_uninit(void);
-void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
-		   struct br_ip *group, int type, u8 flags);
+void br_mdb_notify(struct net_device *dev, struct net_bridge_port_group *pg,
+		   int type);
 void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
 		   int type);
 

commit 9d06b6d8a3fcba8eb8e1c62c92942452afea8057
Author: Elad Raz <eladr@mellanox.com>
Date:   Wed Feb 3 09:57:05 2016 +0100

    bridge: mdb: Separate br_mdb_entry->state from net_bridge_port_group->state
    
    Change net_bridge_port_group 'state' member to 'flags' and define new set
    of flags internal to the kernel.
    
    Signed-off-by: Elad Raz <eladr@mellanox.com>
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 216018c76018..67f4dce3c3d2 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -150,6 +150,9 @@ struct net_bridge_fdb_entry
 	struct rcu_head			rcu;
 };
 
+#define MDB_PG_FLAGS_PERMANENT	BIT(0)
+#define MDB_PG_FLAGS_OFFLOAD	BIT(1)
+
 struct net_bridge_port_group {
 	struct net_bridge_port		*port;
 	struct net_bridge_port_group __rcu *next;
@@ -157,7 +160,7 @@ struct net_bridge_port_group {
 	struct rcu_head			rcu;
 	struct timer_list		timer;
 	struct br_ip			addr;
-	unsigned char			state;
+	unsigned char			flags;
 };
 
 struct net_bridge_mdb_entry
@@ -554,11 +557,11 @@ void br_multicast_free_pg(struct rcu_head *head);
 struct net_bridge_port_group *
 br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
 			    struct net_bridge_port_group __rcu *next,
-			    unsigned char state);
+			    unsigned char flags);
 void br_mdb_init(void);
 void br_mdb_uninit(void);
 void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
-		   struct br_ip *group, int type, u8 state);
+		   struct br_ip *group, int type, u8 flags);
 void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
 		   int type);
 

commit f409d0ed87d2721e1099ce36266e98c5aea2d486
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Mon Oct 12 21:47:05 2015 +0200

    bridge: vlan: move back vlan_flush
    
    Ido Schimmel reported a problem with switchdev devices because of the
    order change of del_nbp operations, more specifically the move of
    nbp_vlan_flush() which deletes all vlans and frees vlgrp after the
    rx_handler has been unregistered. So in order to fix this move
    vlan_flush back where it was and make it destroy the rhtable after
    NULLing vlgrp and waiting a grace period to make sure noone can see it.
    
    Reported-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8835642a6326..216018c76018 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -132,7 +132,6 @@ struct net_bridge_vlan_group {
 	struct list_head		vlan_list;
 	u16				num_vlans;
 	u16				pvid;
-	struct rcu_head			rcu;
 };
 
 struct net_bridge_fdb_entry

commit 907b1e6e83ed25d9dece1e55b704581b6c127051
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Mon Oct 12 21:47:02 2015 +0200

    bridge: vlan: use proper rcu for the vlgrp member
    
    The bridge and port's vlgrp member is already used in RCU way, currently
    we rely on the fact that it cannot disappear while the port exists but
    that is error-prone and we might miss places with improper locking
    (either RCU or RTNL must be held to walk the vlan_list). So make it
    official and use RCU for vlgrp to catch offenders. Introduce proper vlgrp
    accessors and use them consistently throughout the code.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Reviewed-by: Ido Schimmel <idosch@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ba0c67b2159a..8835642a6326 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -132,6 +132,7 @@ struct net_bridge_vlan_group {
 	struct list_head		vlan_list;
 	u16				num_vlans;
 	u16				pvid;
+	struct rcu_head			rcu;
 };
 
 struct net_bridge_fdb_entry
@@ -229,7 +230,7 @@ struct net_bridge_port
 	struct netpoll			*np;
 #endif
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
-	struct net_bridge_vlan_group	*vlgrp;
+	struct net_bridge_vlan_group	__rcu *vlgrp;
 #endif
 };
 
@@ -337,7 +338,7 @@ struct net_bridge
 	struct kobject			*ifobj;
 	u32				auto_cnt;
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
-	struct net_bridge_vlan_group	*vlgrp;
+	struct net_bridge_vlan_group	__rcu *vlgrp;
 	u8				vlan_enabled;
 	__be16				vlan_proto;
 	u16				default_pvid;
@@ -700,13 +701,25 @@ int nbp_get_num_vlan_infos(struct net_bridge_port *p, u32 filter_mask);
 static inline struct net_bridge_vlan_group *br_vlan_group(
 					const struct net_bridge *br)
 {
-	return br->vlgrp;
+	return rtnl_dereference(br->vlgrp);
 }
 
 static inline struct net_bridge_vlan_group *nbp_vlan_group(
 					const struct net_bridge_port *p)
 {
-	return p->vlgrp;
+	return rtnl_dereference(p->vlgrp);
+}
+
+static inline struct net_bridge_vlan_group *br_vlan_group_rcu(
+					const struct net_bridge *br)
+{
+	return rcu_dereference(br->vlgrp);
+}
+
+static inline struct net_bridge_vlan_group *nbp_vlan_group_rcu(
+					const struct net_bridge_port *p)
+{
+	return rcu_dereference(p->vlgrp);
 }
 
 /* Since bridge now depends on 8021Q module, but the time bridge sees the
@@ -853,6 +866,19 @@ static inline struct net_bridge_vlan_group *nbp_vlan_group(
 {
 	return NULL;
 }
+
+static inline struct net_bridge_vlan_group *br_vlan_group_rcu(
+					const struct net_bridge *br)
+{
+	return NULL;
+}
+
+static inline struct net_bridge_vlan_group *nbp_vlan_group_rcu(
+					const struct net_bridge_port *p)
+{
+	return NULL;
+}
+
 #endif
 
 struct nf_br_ops {

commit c62987bbd8a1a1664f99e89e3959339350a6131e
Author: Scott Feldman <sfeldma@gmail.com>
Date:   Thu Oct 8 19:23:19 2015 -0700

    bridge: push bridge setting ageing_time down to switchdev
    
    Use SWITCHDEV_F_SKIP_EOPNOTSUPP to skip over ports in bridge that don't
    support setting ageing_time (or setting bridge attrs in general).
    
    If push fails, don't update ageing_time in bridge and return err to user.
    
    If push succeeds, update ageing_time in bridge and run gc_timer now to
    recalabrate when to run gc_timer next, based on new ageing_time.
    
    Signed-off-by: Scott Feldman <sfeldma@gmail.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Acked-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 09d3ecbcb4f0..ba0c67b2159a 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -882,6 +882,7 @@ void __br_set_forward_delay(struct net_bridge *br, unsigned long t);
 int br_set_forward_delay(struct net_bridge *br, unsigned long x);
 int br_set_hello_time(struct net_bridge *br, unsigned long x);
 int br_set_max_age(struct net_bridge *br, unsigned long x);
+int br_set_ageing_time(struct net_bridge *br, u32 ageing_time);
 
 
 /* br_stp_if.c */

commit 0f963b7592ef9e054974b6672b86ec1edd84b4bc
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Sun Oct 4 14:23:47 2015 +0200

    bridge: netlink: add support for default_pvid
    
    Add IFLA_BR_VLAN_DEFAULT_PVID to allow setting/getting bridge's
    default_pvid via netlink.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1ff6a0faef3f..09d3ecbcb4f0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -690,6 +690,7 @@ int __br_vlan_set_proto(struct net_bridge *br, __be16 proto);
 int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
 int br_vlan_init(struct net_bridge *br);
 int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
+int __br_vlan_set_default_pvid(struct net_bridge *br, u16 pvid);
 int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 void nbp_vlan_flush(struct net_bridge_port *port);

commit 6be144f62f64c8a67e11b2f8b86c7bf390b87411
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Oct 2 15:05:13 2015 +0200

    bridge: vlan: use br_vlan_should_use to simplify __vlan_add/del
    
    The checks that lead to num_vlans change are always what
    br_vlan_should_use checks for, namely if the vlan is only a context or
    not and depending on that it's either not counted or counted
    as a real/used vlan respectively.
    Also give better explanation in br_vlan_should_use's comment.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 4ed8308db66e..1ff6a0faef3f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -400,7 +400,7 @@ static inline bool br_vlan_is_brentry(const struct net_bridge_vlan *v)
 	return v->flags & BRIDGE_VLAN_INFO_BRENTRY;
 }
 
-/* check if we should use the vlan entry is usable */
+/* check if we should use the vlan entry, returns false if it's only context */
 static inline bool br_vlan_should_use(const struct net_bridge_vlan *v)
 {
 	if (br_vlan_is_master(v)) {

commit 77751ee8aec3e1748e0d1471ccbfc008793e88a6
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Wed Sep 30 20:16:53 2015 +0200

    bridge: vlan: move pvid inside net_bridge_vlan_group
    
    One obvious way to converge more code (which was also used by the
    previous vlan code) is to move pvid inside net_bridge_vlan_group. This
    allows us to simplify some and remove other port-specific functions.
    Also gives us the ability to simply pass the vlan group and use all of the
    contained information.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index cfe945f5ab8b..4ed8308db66e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -119,6 +119,7 @@ struct net_bridge_vlan {
  * @vlan_hash: VLAN entry rhashtable
  * @vlan_list: sorted VLAN entry list
  * @num_vlans: number of total VLAN entries
+ * @pvid: PVID VLAN id
  *
  * IMPORTANT: Be careful when checking if there're VLAN entries using list
  *            primitives because the bridge can have entries in its list which
@@ -130,6 +131,7 @@ struct net_bridge_vlan_group {
 	struct rhashtable		vlan_hash;
 	struct list_head		vlan_list;
 	u16				num_vlans;
+	u16				pvid;
 };
 
 struct net_bridge_fdb_entry
@@ -228,7 +230,6 @@ struct net_bridge_port
 #endif
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	struct net_bridge_vlan_group	*vlgrp;
-	u16				pvid;
 #endif
 };
 
@@ -340,7 +341,6 @@ struct net_bridge
 	u8				vlan_enabled;
 	__be16				vlan_proto;
 	u16				default_pvid;
-	u16				pvid;
 #endif
 };
 
@@ -670,10 +670,10 @@ static inline void br_mdb_uninit(void)
 
 /* br_vlan.c */
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
-bool br_allowed_ingress(struct net_bridge *br, struct sk_buff *skb, u16 *vid);
-bool nbp_allowed_ingress(struct net_bridge_port *p, struct sk_buff *skb,
-			 u16 *vid);
-bool br_allowed_egress(struct net_bridge_vlan_group *br,
+bool br_allowed_ingress(const struct net_bridge *br,
+			struct net_bridge_vlan_group *vg, struct sk_buff *skb,
+			u16 *vid);
+bool br_allowed_egress(struct net_bridge_vlan_group *vg,
 		       const struct sk_buff *skb);
 bool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid);
 struct sk_buff *br_handle_vlan(struct net_bridge *br,
@@ -725,22 +725,13 @@ static inline int br_vlan_get_tag(const struct sk_buff *skb, u16 *vid)
 	return err;
 }
 
-static inline u16 br_get_pvid(const struct net_bridge *br)
-{
-	if (!br)
-		return 0;
-
-	smp_rmb();
-	return br->pvid;
-}
-
-static inline u16 nbp_get_pvid(const struct net_bridge_port *p)
+static inline u16 br_get_pvid(const struct net_bridge_vlan_group *vg)
 {
-	if (!p)
+	if (!vg)
 		return 0;
 
 	smp_rmb();
-	return p->pvid;
+	return vg->pvid;
 }
 
 static inline int br_vlan_enabled(struct net_bridge *br)
@@ -748,20 +739,14 @@ static inline int br_vlan_enabled(struct net_bridge *br)
 	return br->vlan_enabled;
 }
 #else
-static inline bool br_allowed_ingress(struct net_bridge *br,
+static inline bool br_allowed_ingress(const struct net_bridge *br,
+				      struct net_bridge_vlan_group *vg,
 				      struct sk_buff *skb,
 				      u16 *vid)
 {
 	return true;
 }
 
-static inline bool nbp_allowed_ingress(struct net_bridge_port *p,
-				       struct sk_buff *skb,
-				       u16 *vid)
-{
-	return true;
-}
-
 static inline bool br_allowed_egress(struct net_bridge_vlan_group *vg,
 				     const struct sk_buff *skb)
 {
@@ -834,12 +819,7 @@ static inline u16 br_vlan_get_tag(const struct sk_buff *skb, u16 *tag)
 	return 0;
 }
 
-static inline u16 br_get_pvid(const struct net_bridge *br)
-{
-	return 0;
-}
-
-static inline u16 nbp_get_pvid(const struct net_bridge_port *p)
+static inline u16 br_get_pvid(const struct net_bridge_vlan_group *vg)
 {
 	return 0;
 }

commit 2594e9064a57634efc146ff4e89a5de562e05011
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Sep 25 19:00:11 2015 +0200

    bridge: vlan: add per-vlan struct and move to rhashtables
    
    This patch changes the bridge vlan implementation to use rhashtables
    instead of bitmaps. The main motivation behind this change is that we
    need extensible per-vlan structures (both per-port and global) so more
    advanced features can be introduced and the vlan support can be
    extended. I've tried to break this up but the moment net_port_vlans is
    changed and the whole API goes away, thus this is a larger patch.
    A few short goals of this patch are:
    - Extensible per-vlan structs stored in rhashtables and a sorted list
    - Keep user-visible behaviour (compressed vlans etc)
    - Keep fastpath ingress/egress logic the same (optimizations to come
      later)
    
    Here's a brief list of some of the new features we'd like to introduce:
    - per-vlan counters
    - vlan ingress/egress mapping
    - per-vlan igmp configuration
    - vlan priorities
    - avoid fdb entries replication (e.g. local fdb scaling issues)
    
    The structure is kept single for both global and per-port entries so to
    avoid code duplication where possible and also because we'll soon introduce
    "port0 / aka bridge as port" which should simplify things further
    (thanks to Vlad for the suggestion!).
    
    Now we have per-vlan global rhashtable (bridge-wide) and per-vlan port
    rhashtable, if an entry is added to a port it'll get a pointer to its
    global context so it can be quickly accessed later. There's also a
    sorted vlan list which is used for stable walks and some user-visible
    behaviour such as the vlan ranges, also for error paths.
    VLANs are stored in a "vlan group" which currently contains the
    rhashtable, sorted vlan list and the number of "real" vlan entries.
    A good side-effect of this change is that it resembles how hw keeps
    per-vlan data.
    One important note after this change is that if a VLAN is being looked up
    in the bridge's rhashtable for filtering purposes (or to check if it's an
    existing usable entry, not just a global context) then the new helper
    br_vlan_should_use() needs to be used if the vlan is found. In case the
    lookup is done only with a port's vlan group, then this check can be
    skipped.
    
    Things tested so far:
    - basic vlan ingress/egress
    - pvids
    - untagged vlans
    - undef CONFIG_BRIDGE_VLAN_FILTERING
    - adding/deleting vlans in different scenarios (with/without global ctx,
      while transmitting traffic, in ranges etc)
    - loading/removing the module while having/adding/deleting vlans
    - extracting bridge vlan information (user ABI), compressed requests
    - adding/deleting fdbs on vlans
    - bridge mac change, promisc mode
    - default pvid change
    - kmemleak ON during the whole time
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 74e99c75c8e4..cfe945f5ab8b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -20,6 +20,7 @@
 #include <net/route.h>
 #include <net/ip6_fib.h>
 #include <linux/if_vlan.h>
+#include <linux/rhashtable.h>
 
 #define BR_HASH_BITS 8
 #define BR_HASH_SIZE (1 << BR_HASH_BITS)
@@ -28,7 +29,6 @@
 
 #define BR_PORT_BITS	10
 #define BR_MAX_PORTS	(1<<BR_PORT_BITS)
-#define BR_VLAN_BITMAP_LEN	BITS_TO_LONGS(VLAN_N_VID)
 
 #define BR_VERSION	"2.3"
 
@@ -77,16 +77,58 @@ struct bridge_mcast_querier {
 };
 #endif
 
-struct net_port_vlans {
-	u16				port_idx;
-	u16				pvid;
+/**
+ * struct net_bridge_vlan - per-vlan entry
+ *
+ * @vnode: rhashtable member
+ * @vid: VLAN id
+ * @flags: bridge vlan flags
+ * @br: if MASTER flag set, this points to a bridge struct
+ * @port: if MASTER flag unset, this points to a port struct
+ * @refcnt: if MASTER flag set, this is bumped for each port referencing it
+ * @brvlan: if MASTER flag unset, this points to the global per-VLAN context
+ *          for this VLAN entry
+ * @vlist: sorted list of VLAN entries
+ * @rcu: used for entry destruction
+ *
+ * This structure is shared between the global per-VLAN entries contained in
+ * the bridge rhashtable and the local per-port per-VLAN entries contained in
+ * the port's rhashtable. The union entries should be interpreted depending on
+ * the entry flags that are set.
+ */
+struct net_bridge_vlan {
+	struct rhash_head		vnode;
+	u16				vid;
+	u16				flags;
 	union {
-		struct net_bridge_port		*port;
-		struct net_bridge		*br;
-	}				parent;
+		struct net_bridge	*br;
+		struct net_bridge_port	*port;
+	};
+	union {
+		atomic_t		refcnt;
+		struct net_bridge_vlan	*brvlan;
+	};
+	struct list_head		vlist;
+
 	struct rcu_head			rcu;
-	unsigned long			vlan_bitmap[BR_VLAN_BITMAP_LEN];
-	unsigned long			untagged_bitmap[BR_VLAN_BITMAP_LEN];
+};
+
+/**
+ * struct net_bridge_vlan_group
+ *
+ * @vlan_hash: VLAN entry rhashtable
+ * @vlan_list: sorted VLAN entry list
+ * @num_vlans: number of total VLAN entries
+ *
+ * IMPORTANT: Be careful when checking if there're VLAN entries using list
+ *            primitives because the bridge can have entries in its list which
+ *            are just for global context but not for filtering, i.e. they have
+ *            the master flag set but not the brentry flag. If you have to check
+ *            if there're "real" entries in the bridge please test @num_vlans
+ */
+struct net_bridge_vlan_group {
+	struct rhashtable		vlan_hash;
+	struct list_head		vlan_list;
 	u16				num_vlans;
 };
 
@@ -185,7 +227,8 @@ struct net_bridge_port
 	struct netpoll			*np;
 #endif
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
-	struct net_port_vlans __rcu	*vlan_info;
+	struct net_bridge_vlan_group	*vlgrp;
+	u16				pvid;
 #endif
 };
 
@@ -293,10 +336,11 @@ struct net_bridge
 	struct kobject			*ifobj;
 	u32				auto_cnt;
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
+	struct net_bridge_vlan_group	*vlgrp;
 	u8				vlan_enabled;
 	__be16				vlan_proto;
 	u16				default_pvid;
-	struct net_port_vlans __rcu	*vlan_info;
+	u16				pvid;
 #endif
 };
 
@@ -344,6 +388,31 @@ static inline int br_is_root_bridge(const struct net_bridge *br)
 	return !memcmp(&br->bridge_id, &br->designated_root, 8);
 }
 
+/* check if a VLAN entry is global */
+static inline bool br_vlan_is_master(const struct net_bridge_vlan *v)
+{
+	return v->flags & BRIDGE_VLAN_INFO_MASTER;
+}
+
+/* check if a VLAN entry is used by the bridge */
+static inline bool br_vlan_is_brentry(const struct net_bridge_vlan *v)
+{
+	return v->flags & BRIDGE_VLAN_INFO_BRENTRY;
+}
+
+/* check if we should use the vlan entry is usable */
+static inline bool br_vlan_should_use(const struct net_bridge_vlan *v)
+{
+	if (br_vlan_is_master(v)) {
+		if (br_vlan_is_brentry(v))
+			return true;
+		else
+			return false;
+	}
+
+	return true;
+}
+
 /* br_device.c */
 void br_dev_setup(struct net_device *dev);
 void br_dev_delete(struct net_device *dev, struct list_head *list);
@@ -601,18 +670,19 @@ static inline void br_mdb_uninit(void)
 
 /* br_vlan.c */
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
-bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
-			struct sk_buff *skb, u16 *vid);
-bool br_allowed_egress(struct net_bridge *br, const struct net_port_vlans *v,
+bool br_allowed_ingress(struct net_bridge *br, struct sk_buff *skb, u16 *vid);
+bool nbp_allowed_ingress(struct net_bridge_port *p, struct sk_buff *skb,
+			 u16 *vid);
+bool br_allowed_egress(struct net_bridge_vlan_group *br,
 		       const struct sk_buff *skb);
 bool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid);
 struct sk_buff *br_handle_vlan(struct net_bridge *br,
-			       const struct net_port_vlans *v,
+			       struct net_bridge_vlan_group *vg,
 			       struct sk_buff *skb);
 int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
 int br_vlan_delete(struct net_bridge *br, u16 vid);
 void br_vlan_flush(struct net_bridge *br);
-bool br_vlan_find(struct net_bridge *br, u16 vid);
+struct net_bridge_vlan *br_vlan_find(struct net_bridge_vlan_group *vg, u16 vid);
 void br_recalculate_fwd_mask(struct net_bridge *br);
 int __br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
@@ -623,19 +693,19 @@ int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
 int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 void nbp_vlan_flush(struct net_bridge_port *port);
-bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
 int nbp_vlan_init(struct net_bridge_port *port);
+int nbp_get_num_vlan_infos(struct net_bridge_port *p, u32 filter_mask);
 
-static inline struct net_port_vlans *br_get_vlan_info(
-						const struct net_bridge *br)
+static inline struct net_bridge_vlan_group *br_vlan_group(
+					const struct net_bridge *br)
 {
-	return rcu_dereference_rtnl(br->vlan_info);
+	return br->vlgrp;
 }
 
-static inline struct net_port_vlans *nbp_get_vlan_info(
-						const struct net_bridge_port *p)
+static inline struct net_bridge_vlan_group *nbp_vlan_group(
+					const struct net_bridge_port *p)
 {
-	return rcu_dereference_rtnl(p->vlan_info);
+	return p->vlgrp;
 }
 
 /* Since bridge now depends on 8021Q module, but the time bridge sees the
@@ -645,9 +715,9 @@ static inline int br_vlan_get_tag(const struct sk_buff *skb, u16 *vid)
 {
 	int err = 0;
 
-	if (skb_vlan_tag_present(skb))
+	if (skb_vlan_tag_present(skb)) {
 		*vid = skb_vlan_tag_get(skb) & VLAN_VID_MASK;
-	else {
+	} else {
 		*vid = 0;
 		err = -EINVAL;
 	}
@@ -655,13 +725,22 @@ static inline int br_vlan_get_tag(const struct sk_buff *skb, u16 *vid)
 	return err;
 }
 
-static inline u16 br_get_pvid(const struct net_port_vlans *v)
+static inline u16 br_get_pvid(const struct net_bridge *br)
 {
-	if (!v)
+	if (!br)
 		return 0;
 
 	smp_rmb();
-	return v->pvid;
+	return br->pvid;
+}
+
+static inline u16 nbp_get_pvid(const struct net_bridge_port *p)
+{
+	if (!p)
+		return 0;
+
+	smp_rmb();
+	return p->pvid;
 }
 
 static inline int br_vlan_enabled(struct net_bridge *br)
@@ -670,15 +749,20 @@ static inline int br_vlan_enabled(struct net_bridge *br)
 }
 #else
 static inline bool br_allowed_ingress(struct net_bridge *br,
-				      struct net_port_vlans *v,
 				      struct sk_buff *skb,
 				      u16 *vid)
 {
 	return true;
 }
 
-static inline bool br_allowed_egress(struct net_bridge *br,
-				     const struct net_port_vlans *v,
+static inline bool nbp_allowed_ingress(struct net_bridge_port *p,
+				       struct sk_buff *skb,
+				       u16 *vid)
+{
+	return true;
+}
+
+static inline bool br_allowed_egress(struct net_bridge_vlan_group *vg,
 				     const struct sk_buff *skb)
 {
 	return true;
@@ -691,7 +775,7 @@ static inline bool br_should_learn(struct net_bridge_port *p,
 }
 
 static inline struct sk_buff *br_handle_vlan(struct net_bridge *br,
-					     const struct net_port_vlans *v,
+					     struct net_bridge_vlan_group *vg,
 					     struct sk_buff *skb)
 {
 	return skb;
@@ -711,11 +795,6 @@ static inline void br_vlan_flush(struct net_bridge *br)
 {
 }
 
-static inline bool br_vlan_find(struct net_bridge *br, u16 vid)
-{
-	return false;
-}
-
 static inline void br_recalculate_fwd_mask(struct net_bridge *br)
 {
 }
@@ -739,32 +818,28 @@ static inline void nbp_vlan_flush(struct net_bridge_port *port)
 {
 }
 
-static inline struct net_port_vlans *br_get_vlan_info(
-						const struct net_bridge *br)
-{
-	return NULL;
-}
-static inline struct net_port_vlans *nbp_get_vlan_info(
-						const struct net_bridge_port *p)
+static inline struct net_bridge_vlan *br_vlan_find(struct net_bridge_vlan_group *vg,
+						   u16 vid)
 {
 	return NULL;
 }
 
-static inline bool nbp_vlan_find(struct net_bridge_port *port, u16 vid)
+static inline int nbp_vlan_init(struct net_bridge_port *port)
 {
-	return false;
+	return 0;
 }
 
-static inline int nbp_vlan_init(struct net_bridge_port *port)
+static inline u16 br_vlan_get_tag(const struct sk_buff *skb, u16 *tag)
 {
 	return 0;
 }
 
-static inline u16 br_vlan_get_tag(const struct sk_buff *skb, u16 *tag)
+static inline u16 br_get_pvid(const struct net_bridge *br)
 {
 	return 0;
 }
-static inline u16 br_get_pvid(const struct net_port_vlans *v)
+
+static inline u16 nbp_get_pvid(const struct net_bridge_port *p)
 {
 	return 0;
 }
@@ -779,6 +854,24 @@ static inline int __br_vlan_filter_toggle(struct net_bridge *br,
 {
 	return -EOPNOTSUPP;
 }
+
+static inline int nbp_get_num_vlan_infos(struct net_bridge_port *p,
+					 u32 filter_mask)
+{
+	return 0;
+}
+
+static inline struct net_bridge_vlan_group *br_vlan_group(
+					const struct net_bridge *br)
+{
+	return NULL;
+}
+
+static inline struct net_bridge_vlan_group *nbp_vlan_group(
+					const struct net_bridge_port *p)
+{
+	return NULL;
+}
 #endif
 
 struct nf_br_ops {

commit 0c4b51f0054ce85c0ec578ab818f0631834573eb
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Sep 15 20:04:18 2015 -0500

    netfilter: Pass net into okfn
    
    This is immediately motivated by the bridge code that chains functions that
    call into netfilter.  Without passing net into the okfns the bridge code would
    need to guess about the best expression for the network namespace to process
    packets in.
    
    As net is frequently one of the first things computed in continuation functions
    after netfilter has done it's job passing in the desired network namespace is in
    many cases a code simplification.
    
    To support this change the function dst_output_okfn is introduced to
    simplify passing dst_output as an okfn.  For the moment dst_output_okfn
    just silently drops the struct net.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 213baf7aaa93..74e99c75c8e4 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -413,10 +413,10 @@ int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 
 /* br_forward.c */
 void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb);
-int br_dev_queue_push_xmit(struct sock *sk, struct sk_buff *skb);
+int br_dev_queue_push_xmit(struct net *net, struct sock *sk, struct sk_buff *skb);
 void br_forward(const struct net_bridge_port *to,
 		struct sk_buff *skb, struct sk_buff *skb0);
-int br_forward_finish(struct sock *sk, struct sk_buff *skb);
+int br_forward_finish(struct net *net, struct sock *sk, struct sk_buff *skb);
 void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast);
 void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
 		      struct sk_buff *skb2, bool unicast);
@@ -434,7 +434,7 @@ void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);
 void br_manage_promisc(struct net_bridge *br);
 
 /* br_input.c */
-int br_handle_frame_finish(struct sock *sk, struct sk_buff *skb);
+int br_handle_frame_finish(struct net *net, struct sock *sk, struct sk_buff *skb);
 rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
 
 static inline bool br_rx_handler_check_rcu(const struct net_device *dev)

commit b22fbf22f8469d8cacb6fcf5d266426826e1137d
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Thu Aug 27 14:19:20 2015 -0700

    bridge: fdb: rearrange net_bridge_fdb_entry
    
    While looking into fixing the local entries scalability issue I noticed
    that the structure is badly arranged because vlan_id would fall in a
    second cache line while keeping rcu which is used only when deleting
    in the first, so re-arrange the structure and push rcu to the end so we
    can get 16 bytes which can be used for other fields (by pushing rcu
    fully in the second 64 byte chunk). With this change all the core
    necessary information when doing fdb lookups will be available in a
    single cache line.
    
    pahole before (note vlan_id):
    struct net_bridge_fdb_entry {
            struct hlist_node          hlist;                /*     0    16 */
            struct net_bridge_port *   dst;                  /*    16     8 */
            struct callback_head       rcu;                  /*    24    16 */
            long unsigned int          updated;              /*    40     8 */
            long unsigned int          used;                 /*    48     8 */
            mac_addr                   addr;                 /*    56     6 */
            unsigned char              is_local:1;           /*    62: 7  1 */
            unsigned char              is_static:1;          /*    62: 6  1 */
            unsigned char              added_by_user:1;      /*    62: 5  1 */
            unsigned char              added_by_external_learn:1; /*    62: 4  1 */
    
            /* XXX 4 bits hole, try to pack */
            /* XXX 1 byte hole, try to pack */
    
            /* --- cacheline 1 boundary (64 bytes) --- */
            __u16                      vlan_id;              /*    64     2 */
    
            /* size: 72, cachelines: 2, members: 11 */
            /* sum members: 65, holes: 1, sum holes: 1 */
            /* bit holes: 1, sum bit holes: 4 bits */
            /* padding: 6 */
            /* last cacheline: 8 bytes */
    }
    
    pahole after (note vlan_id):
    struct net_bridge_fdb_entry {
            struct hlist_node          hlist;                /*     0    16 */
            struct net_bridge_port *   dst;                  /*    16     8 */
            long unsigned int          updated;              /*    24     8 */
            long unsigned int          used;                 /*    32     8 */
            mac_addr                   addr;                 /*    40     6 */
            __u16                      vlan_id;              /*    46     2 */
            unsigned char              is_local:1;           /*    48: 7  1 */
            unsigned char              is_static:1;          /*    48: 6  1 */
            unsigned char              added_by_user:1;      /*    48: 5  1 */
            unsigned char              added_by_external_learn:1; /*    48: 4  1 */
    
            /* XXX 4 bits hole, try to pack */
            /* XXX 7 bytes hole, try to pack */
    
            struct callback_head       rcu;                  /*    56    16 */
            /* --- cacheline 1 boundary (64 bytes) was 8 bytes ago --- */
    
            /* size: 72, cachelines: 2, members: 11 */
            /* sum members: 65, holes: 1, sum holes: 7 */
            /* bit holes: 1, sum bit holes: 4 bits */
            /* last cacheline: 8 bytes */
    }
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 19e8f79b6b99..213baf7aaa93 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -95,15 +95,15 @@ struct net_bridge_fdb_entry
 	struct hlist_node		hlist;
 	struct net_bridge_port		*dst;
 
-	struct rcu_head			rcu;
 	unsigned long			updated;
 	unsigned long			used;
 	mac_addr			addr;
+	__u16				vlan_id;
 	unsigned char			is_local:1,
 					is_static:1,
 					added_by_user:1,
 					added_by_external_learn:1;
-	__u16				vlan_id;
+	struct rcu_head			rcu;
 };
 
 struct net_bridge_port_group {

commit d2d427b3927bd7a0348fc7f323d0e291f79a2779
Author: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
Date:   Thu Aug 27 15:32:26 2015 +0900

    bridge: Add netlink support for vlan_protocol attribute
    
    This enables bridge vlan_protocol to be configured through netlink.
    
    When CONFIG_BRIDGE_VLAN_FILTERING is disabled, kernel behaves the
    same way as this feature is not implemented.
    
    Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3d95647039d0..19e8f79b6b99 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -616,6 +616,7 @@ bool br_vlan_find(struct net_bridge *br, u16 vid);
 void br_recalculate_fwd_mask(struct net_bridge *br);
 int __br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
+int __br_vlan_set_proto(struct net_bridge *br, __be16 proto);
 int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
 int br_vlan_init(struct net_bridge *br);
 int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);

commit a7854037da006a7472c48773e3190db55217ec9b
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Fri Aug 7 19:40:45 2015 +0300

    bridge: netlink: add support for vlan_filtering attribute
    
    This patch adds the ability to toggle the vlan filtering support via
    netlink. Since we're already running with rtnl in .changelink() we don't
    need to take any additional locks.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e2cb359f9dd3..3d95647039d0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -614,6 +614,7 @@ int br_vlan_delete(struct net_bridge *br, u16 vid);
 void br_vlan_flush(struct net_bridge *br);
 bool br_vlan_find(struct net_bridge *br, u16 vid);
 void br_recalculate_fwd_mask(struct net_bridge *br);
+int __br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
 int br_vlan_init(struct net_bridge *br);
@@ -771,6 +772,12 @@ static inline int br_vlan_enabled(struct net_bridge *br)
 {
 	return 0;
 }
+
+static inline int __br_vlan_filter_toggle(struct net_bridge *br,
+					  unsigned long val)
+{
+	return -EOPNOTSUPP;
+}
 #endif
 
 struct nf_br_ops {

commit 949f1e39a6177503349ef8adeedd13fa1c89e5dd
Author: Satish Ashok <sashok@cumulusnetworks.com>
Date:   Thu Jul 23 05:00:53 2015 -0700

    bridge: mdb: notify on router port add and del
    
    Send notifications on router port add and del/expire, re-use the already
    existing MDBA_ROUTER and send NEWMDB/DELMDB netlink notifications
    respectively.
    
    Signed-off-by: Satish Ashok <sashok@cumulusnetworks.com>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3ad1290528af..e2cb359f9dd3 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -490,6 +490,8 @@ void br_mdb_init(void);
 void br_mdb_uninit(void);
 void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
 		   struct br_ip *group, int type, u8 state);
+void br_rtr_notify(struct net_device *dev, struct net_bridge_port *port,
+		   int type);
 
 #define mlock_dereference(X, br) \
 	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))

commit a7ce45a74bedd0ed80b956b3e14f8bc6dec85327
Author: Nikolay Aleksandrov <razor@blackwall.org>
Date:   Mon Jul 20 23:03:45 2015 +0200

    bridge: mcast: fix br_multicast_dev_del warn when igmp snooping is not defined
    
    Fix:
    net/bridge/br_if.c: In function 'br_dev_delete':
    >> net/bridge/br_if.c:284:2: error: implicit declaration of function
    >> 'br_multicast_dev_del' [-Werror=implicit-function-declaration]
         br_multicast_dev_del(br);
         ^
       cc1: some warnings being treated as errors
    
    when igmp snooping is not defined.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2bada2279721..3ad1290528af 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -566,6 +566,10 @@ static inline void br_multicast_stop(struct net_bridge *br)
 {
 }
 
+static inline void br_multicast_dev_del(struct net_bridge *br)
+{
+}
+
 static inline void br_multicast_deliver(struct net_bridge_mdb_entry *mdst,
 					struct sk_buff *skb)
 {

commit e10177abf842d0c40dfecc43bd57a0a762a2fccf
Author: Satish Ashok <sashok@cumulusnetworks.com>
Date:   Wed Jul 15 07:16:51 2015 -0700

    bridge: multicast: fix handling of temp and perm entries
    
    When the bridge (or port) is brought down/up flush only temp entries and
    leave the perm ones. Flush perm entries only when deleting the bridge
    device or the associated port.
    
    Signed-off-by: Satish Ashok <sashok@cumulusnetworks.com>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c73fd785654d..2bada2279721 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -466,6 +466,7 @@ void br_multicast_disable_port(struct net_bridge_port *port);
 void br_multicast_init(struct net_bridge *br);
 void br_multicast_open(struct net_bridge *br);
 void br_multicast_stop(struct net_bridge *br);
+void br_multicast_dev_del(struct net_bridge *br);
 void br_multicast_deliver(struct net_bridge_mdb_entry *mdst,
 			  struct sk_buff *skb);
 void br_multicast_forward(struct net_bridge_mdb_entry *mdst,

commit 09cf0211f970311383fdb453bbd5b3beeb294324
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Thu Jul 9 03:11:10 2015 -0700

    bridge: mdb: fill state in br_mdb_notify
    
    Fill also the port group state when sending notifications.
    
    Signed-off-by: Satish Ashok <sashok@cumulusnetworks.com>
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8b21146b24a0..c73fd785654d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -488,7 +488,7 @@ br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
 void br_mdb_init(void);
 void br_mdb_uninit(void);
 void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
-		   struct br_ip *group, int type);
+		   struct br_ip *group, int type, u8 state);
 
 #define mlock_dereference(X, br) \
 	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))

commit 1ea2d020ba477cb7011a7174e8501a9e04a325d4
Author: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
Date:   Tue Jun 23 05:28:16 2015 -0700

    bridge: vlan: flush the dynamically learned entries on port vlan delete
    
    Add a new argument to br_fdb_delete_by_port which allows to specify a
    vid to match when flushing entries and use it in nbp_vlan_delete() to
    flush the dynamically learned entries of the vlan/port pair when removing
    a vlan from a port. Before this patch only the local mac was being
    removed and the dynamically learned ones were left to expire.
    Note that the do_all argument is still respected and if specified, the
    vid will be ignored.
    
    Signed-off-by: Nikolay Aleksandrov <nikolay@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 5dccced71269..8b21146b24a0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -387,7 +387,7 @@ void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr);
 void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
 void br_fdb_cleanup(unsigned long arg);
 void br_fdb_delete_by_port(struct net_bridge *br,
-			   const struct net_bridge_port *p, int do_all);
+			   const struct net_bridge_port *p, u16 vid, int do_all);
 struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 					  const unsigned char *addr, __u16 vid);
 int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);

commit efb6de9b4ba0092b2c55f6a52d16294a8a698edd
Author: Bernhard Thaler <bernhard.thaler@wvnet.at>
Date:   Sat May 30 15:30:16 2015 +0200

    netfilter: bridge: forward IPv6 fragmented packets
    
    IPv6 fragmented packets are not forwarded on an ethernet bridge
    with netfilter ip6_tables loaded. e.g. steps to reproduce
    
    1) create a simple bridge like this
    
            modprobe br_netfilter
            brctl addbr br0
            brctl addif br0 eth0
            brctl addif br0 eth2
            ifconfig eth0 up
            ifconfig eth2 up
            ifconfig br0 up
    
    2) place a host with an IPv6 address on each side of the bridge
    
            set IPv6 address on host A:
            ip -6 addr add fd01:2345:6789:1::1/64 dev eth0
    
            set IPv6 address on host B:
            ip -6 addr add fd01:2345:6789:1::2/64 dev eth0
    
    3) run a simple ping command on host A with packets > MTU
    
            ping6 -s 4000 fd01:2345:6789:1::2
    
    4) wait some time and run e.g. "ip6tables -t nat -nvL" on the bridge
    
    IPv6 fragmented packets traverse the bridge cleanly until somebody runs.
    "ip6tables -t nat -nvL". As soon as it is run (and netfilter modules are
    loaded) IPv6 fragmented packets do not traverse the bridge any more (you
    see no more responses in ping's output).
    
    After applying this patch IPv6 fragmented packets traverse the bridge
    cleanly in above scenario.
    
    Signed-off-by: Bernhard Thaler <bernhard.thaler@wvnet.at>
    [pablo@netfilter.org: small changes to br_nf_dev_queue_xmit]
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8cde96e68fd5..5dccced71269 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -18,6 +18,7 @@
 #include <linux/netpoll.h>
 #include <linux/u64_stats_sync.h>
 #include <net/route.h>
+#include <net/ip6_fib.h>
 #include <linux/if_vlan.h>
 
 #define BR_HASH_BITS 8
@@ -214,7 +215,10 @@ struct net_bridge
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
 #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
-	struct rtable 			fake_rtable;
+	union {
+		struct rtable		fake_rtable;
+		struct rt6_info		fake_rt6_info;
+	};
 	bool				nf_call_iptables;
 	bool				nf_call_ip6tables;
 	bool				nf_call_arptables;

commit 411ffb4fde80705a9a8db4c2d38dbeef6f5bd689
Author: Bernhard Thaler <bernhard.thaler@wvnet.at>
Date:   Sat May 30 15:28:28 2015 +0200

    netfilter: bridge: refactor frag_max_size
    
    Currently frag_max_size is member of br_input_skb_cb and copied back and
    forth using IPCB(skb) and BR_INPUT_SKB_CB(skb) each time it is changed or
    used.
    
    Attach frag_max_size to nf_bridge_info and set value in pre_routing and
    forward functions. Use its value in forward and xmit functions.
    
    Signed-off-by: Bernhard Thaler <bernhard.thaler@wvnet.at>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1f36fa70639b..8cde96e68fd5 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -304,7 +304,6 @@ struct br_input_skb_cb {
 	int mrouters_only;
 #endif
 
-	u16 frag_max_size;
 	bool proxyarp_replied;
 
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING

commit 784b58a327ad16967ab64bbfa558df81980d31e9
Author: Bernhard Thaler <bernhard.thaler@wvnet.at>
Date:   Mon May 4 22:47:13 2015 +0200

    bridge: change BR_GROUPFWD_RESTRICTED to allow forwarding of LLDP frames
    
    BR_GROUPFWD_RESTRICTED bitmask restricts users from setting values to
    /sys/class/net/brX/bridge/group_fwd_mask that allow forwarding of
    some IEEE 802.1D Table 7-10 Reserved addresses:
    
            (MAC Control) 802.3             01-80-C2-00-00-01
            (Link Aggregation) 802.3        01-80-C2-00-00-02
            802.1AB LLDP                    01-80-C2-00-00-0E
    
    Change BR_GROUPFWD_RESTRICTED to allow to forward LLDP frames and document
    group_fwd_mask.
    
    e.g.
       echo 16384 > /sys/class/net/brX/bridge/group_fwd_mask
    allows to forward LLDP frames.
    
    This may be needed for bridge setups used for network troubleshooting or
    any other scenario where forwarding of LLDP frames is desired (e.g. bridge
    connecting a virtual machine to real switch transmitting LLDP frames that
    virtual machine needs to receive).
    
    Tested on a simple bridge setup with two interfaces and host transmitting
    LLDP frames on one side of this bridge (used lldpd). Setting group_fwd_mask
    as described above lets LLDP frames traverse bridge.
    
    Signed-off-by: Bernhard Thaler <bernhard.thaler@wvnet.at>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3362c29400f1..1f36fa70639b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -33,8 +33,8 @@
 
 /* Control of forwarding link local multicast */
 #define BR_GROUPFWD_DEFAULT	0
-/* Don't allow forwarding control protocols like STP and LLDP */
-#define BR_GROUPFWD_RESTRICTED	0x4007u
+/* Don't allow forwarding of control protocols like STP, MAC PAUSE and LACP */
+#define BR_GROUPFWD_RESTRICTED	0x0007u
 /* The Nearest Customer Bridge Group Address, 01-80-C2-00-00-[00,0B,0C,0D,0F] */
 #define BR_GROUPFWD_8021AD	0xB801u
 

commit 46c264daaaa569e24f8aba877d0fd8167c42a9a4
Author: Nicolas Dichtel <nicolas.dichtel@6wind.com>
Date:   Tue Apr 28 18:33:49 2015 +0200

    bridge/nl: remove wrong use of NLM_F_MULTI
    
    NLM_F_MULTI must be used only when a NLMSG_DONE message is sent. In fact,
    it is sent only at the end of a dump.
    
    Libraries like libnl will wait forever for NLMSG_DONE.
    
    Fixes: e5a55a898720 ("net: create generic bridge ops")
    Fixes: 815cccbf10b2 ("ixgbe: add setlink, getlink support to ixgbe and ixgbevf")
    CC: John Fastabend <john.r.fastabend@intel.com>
    CC: Sathya Perla <sathya.perla@emulex.com>
    CC: Subbu Seetharaman <subbu.seetharaman@emulex.com>
    CC: Ajit Khaparde <ajit.khaparde@emulex.com>
    CC: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
    CC: intel-wired-lan@lists.osuosl.org
    CC: Jiri Pirko <jiri@resnulli.us>
    CC: Scott Feldman <sfeldma@gmail.com>
    CC: Stephen Hemminger <stephen@networkplumber.org>
    CC: bridge@lists.linux-foundation.org
    Signed-off-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 6ca0251cb478..3362c29400f1 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -828,7 +828,7 @@ void br_ifinfo_notify(int event, struct net_bridge_port *port);
 int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags);
 int br_dellink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags);
 int br_getlink(struct sk_buff *skb, u32 pid, u32 seq, struct net_device *dev,
-	       u32 filter_mask);
+	       u32 filter_mask, int nlflags);
 
 #ifdef CONFIG_SYSFS
 /* br_sysfs_if.c */

commit 7026b1ddb6b8d4e6ee33dc2bd06c0ca8746fa7ab
Author: David Miller <davem@davemloft.net>
Date:   Sun Apr 5 22:19:04 2015 -0400

    netfilter: Pass socket pointer down through okfn().
    
    On the output paths in particular, we have to sometimes deal with two
    socket contexts.  First, and usually skb->sk, is the local socket that
    generated the frame.
    
    And second, is potentially the socket used to control a tunneling
    socket, such as one the encapsulates using UDP.
    
    We do not want to disassociate skb->sk when encapsulating in order
    to fix this, because that would break socket memory accounting.
    
    The most extreme case where this can cause huge problems is an
    AF_PACKET socket transmitting over a vxlan device.  We hit code
    paths doing checks that assume they are dealing with an ipv4
    socket, but are actually operating upon the AF_PACKET one.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index b46fa0c5b8ec..6ca0251cb478 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -410,10 +410,10 @@ int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
 
 /* br_forward.c */
 void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb);
-int br_dev_queue_push_xmit(struct sk_buff *skb);
+int br_dev_queue_push_xmit(struct sock *sk, struct sk_buff *skb);
 void br_forward(const struct net_bridge_port *to,
 		struct sk_buff *skb, struct sk_buff *skb0);
-int br_forward_finish(struct sk_buff *skb);
+int br_forward_finish(struct sock *sk, struct sk_buff *skb);
 void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast);
 void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
 		      struct sk_buff *skb2, bool unicast);
@@ -431,7 +431,7 @@ void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);
 void br_manage_promisc(struct net_bridge *br);
 
 /* br_input.c */
-int br_handle_frame_finish(struct sk_buff *skb);
+int br_handle_frame_finish(struct sock *sk, struct sk_buff *skb);
 rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
 
 static inline bool br_rx_handler_check_rcu(const struct net_device *dev)

commit 1a4ba64d16a42c1b31d52b671accd7f9103e2626
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Tue Mar 10 10:27:18 2015 +0100

    netfilter: bridge: use rcu hook to resolve br_netfilter dependency
    
    e5de75b ("netfilter: bridge: move DNAT helper to br_netfilter") results
    in the following link problem:
    
    net/bridge/br_device.c:29: undefined reference to `br_nf_prerouting_finish_bridge`
    
    Moreover it creates a hard dependency between br_netfilter and the
    bridge core, which is what we've been trying to avoid so far.
    
    Resolve this problem by using a hook structure so we reduce #ifdef
    pollution and keep bridge netfilter specific code under br_netfilter.c
    which was the original intention.
    
    Reported-by: Simon Horman <simon.horman@netronome.com>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f0a0438dbd6d..b46fa0c5b8ec 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -763,17 +763,17 @@ static inline int br_vlan_enabled(struct net_bridge *br)
 }
 #endif
 
+struct nf_br_ops {
+	int (*br_dev_xmit_hook)(struct sk_buff *skb);
+};
+extern const struct nf_br_ops __rcu *nf_br_ops;
+
 /* br_netfilter.c */
 #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
-int br_nf_prerouting_finish_bridge(struct sk_buff *skb);
 int br_nf_core_init(void);
 void br_nf_core_fini(void);
 void br_netfilter_rtable_init(struct net_bridge *);
 #else
-static inline int br_nf_prerouting_finish_bridge(struct sk_buff *skb)
-{
-        return 0;
-}
 static inline int br_nf_core_init(void) { return 0; }
 static inline void br_nf_core_fini(void) {}
 #define br_netfilter_rtable_init(x)

commit 5428aef81157768f1052b116e0cc8abf88ff3e36
Merge: 26c459a8072f e5de75bf8885
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Mar 9 15:58:21 2015 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/pablo/nf-next
    
    Pablo Neira Ayuso says:
    
    ====================
    Netfilter updates for net-next
    
    The following patchset contains Netfilter updates for your net-next
    tree. Basically, improvements for the packet rejection infrastructure,
    deprecation of CLUSTERIP, cleanups for nf_tables and some untangling for
    br_netfilter. More specifically they are:
    
    1) Send packet to reset flow if checksum is valid, from Florian Westphal.
    
    2) Fix nf_tables reject bridge from the input chain, also from Florian.
    
    3) Deprecate the CLUSTERIP target, the cluster match supersedes it in
       functionality and it's known to have problems.
    
    4) A couple of cleanups for nf_tables rule tracing infrastructure, from
       Patrick McHardy.
    
    5) Another cleanup to place transaction declarations at the bottom of
       nf_tables.h, also from Patrick.
    
    6) Consolidate Kconfig dependencies wrt. NF_TABLES.
    
    7) Limit table names to 32 bytes in nf_tables.
    
    8) mac header copying in bridge netfilter is already required when
       calling ip_fragment(), from Florian Westphal.
    
    9) move nf_bridge_update_protocol() to br_netfilter.c, also from
       Florian.
    
    10) Small refactor in br_netfilter in the transmission path, again from
        Florian.
    
    11) Move br_nf_pre_routing_finish_bridge_slow() to br_netfilter.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e5de75bf88858f5b3ab11e2504b86ec059f03102
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Mon Mar 9 12:30:12 2015 +0100

    netfilter: bridge: move DNAT helper to br_netfilter
    
    Only one caller, there is no need to keep this in a header.
    Move it to br_netfilter.c where this belongs to.
    
    Based on patch from Florian Westphal.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index de0919975a25..d63fc17fe4f4 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -764,10 +764,15 @@ static inline int br_vlan_enabled(struct net_bridge *br)
 
 /* br_netfilter.c */
 #if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
+int br_nf_prerouting_finish_bridge(struct sk_buff *skb);
 int br_nf_core_init(void);
 void br_nf_core_fini(void);
 void br_netfilter_rtable_init(struct net_bridge *);
 #else
+static inline int br_nf_prerouting_finish_bridge(struct sk_buff *skb)
+{
+        return 0;
+}
 static inline int br_nf_core_init(void) { return 0; }
 static inline void br_nf_core_fini(void) {}
 #define br_netfilter_rtable_init(x)

commit 842a9ae08a25671db3d4f689eed68b4d64be15b5
Author: Jouni Malinen <jouni@codeaurora.org>
Date:   Wed Mar 4 12:54:21 2015 +0200

    bridge: Extend Proxy ARP design to allow optional rules for Wi-Fi
    
    This extends the design in commit 958501163ddd ("bridge: Add support for
    IEEE 802.11 Proxy ARP") with optional set of rules that are needed to
    meet the IEEE 802.11 and Hotspot 2.0 requirements for ProxyARP. The
    previously added BR_PROXYARP behavior is left as-is and a new
    BR_PROXYARP_WIFI alternative is added so that this behavior can be
    configured from user space when required.
    
    In addition, this enables proxyarp functionality for unicast ARP
    requests for both BR_PROXYARP and BR_PROXYARP_WIFI since it is possible
    to use unicast as well as broadcast for these frames.
    
    The key differences in functionality:
    
    BR_PROXYARP:
    - uses the flag on the bridge port on which the request frame was
      received to determine whether to reply
    - block bridge port flooding completely on ports that enable proxy ARP
    
    BR_PROXYARP_WIFI:
    - uses the flag on the bridge port to which the target device of the
      request belongs
    - block bridge port flooding selectively based on whether the proxyarp
      functionality replied
    
    Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index de0919975a25..c32e279c62f8 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -305,6 +305,7 @@ struct br_input_skb_cb {
 #endif
 
 	u16 frag_max_size;
+	bool proxyarp_replied;
 
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	bool vlan_filtered;

commit add511b38266aa10c1079f9248854e6a415c4dc2
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Thu Jan 29 22:40:12 2015 -0800

    bridge: add flags argument to ndo_bridge_setlink and ndo_bridge_dellink
    
    bridge flags are needed inside ndo_bridge_setlink/dellink handlers to
    avoid another call to parse IFLA_AF_SPEC inside these handlers
    
    This is used later in this series
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e8e3f3681680..de0919975a25 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -819,8 +819,8 @@ extern struct rtnl_link_ops br_link_ops;
 int br_netlink_init(void);
 void br_netlink_fini(void);
 void br_ifinfo_notify(int event, struct net_bridge_port *port);
-int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg);
-int br_dellink(struct net_device *dev, struct nlmsghdr *nlmsg);
+int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags);
+int br_dellink(struct net_device *dev, struct nlmsghdr *nlmsg, u16 flags);
 int br_getlink(struct sk_buff *skb, u32 pid, u32 seq, struct net_device *dev,
 	       u32 filter_mask);
 

commit 3aeb66176ffa8fefd7a9f7d37bda1d8adcf469a1
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Thu Jan 15 23:49:37 2015 +0100

    net: replace br_fdb_external_learn_* calls with switchdev notifier events
    
    This patch benefits from newly introduced switchdev notifier and uses it
    to propagate fdb learn events from rocker driver to bridge. That avoids
    direct function calls and possible use by other listeners (ovs).
    
    Suggested-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: Scott Feldman <sfeldma@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index d808d766334d..e8e3f3681680 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -402,6 +402,10 @@ int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
 		struct net_device *dev, struct net_device *fdev, int idx);
 int br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p);
 void br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p);
+int br_fdb_external_learn_add(struct net_bridge *br, struct net_bridge_port *p,
+			      const unsigned char *addr, u16 vid);
+int br_fdb_external_learn_del(struct net_bridge *br, struct net_bridge_port *p,
+			      const unsigned char *addr, u16 vid);
 
 /* br_forward.c */
 void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb);

commit df8a39defad46b83694ea6dd868d332976d62cc0
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Tue Jan 13 17:13:44 2015 +0100

    net: rename vlan_tx_* helpers since "tx" is misleading there
    
    The same macros are used for rx as well. So rename it.
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index aea3d1339b3f..d808d766334d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -628,8 +628,8 @@ static inline int br_vlan_get_tag(const struct sk_buff *skb, u16 *vid)
 {
 	int err = 0;
 
-	if (vlan_tx_tag_present(skb))
-		*vid = vlan_tx_tag_get(skb) & VLAN_VID_MASK;
+	if (skb_vlan_tag_present(skb))
+		*vid = skb_vlan_tag_get(skb) & VLAN_VID_MASK;
 	else {
 		*vid = 0;
 		err = -EINVAL;

commit 065c212a9e25172069f368b36228379521dadb65
Author: Scott Feldman <sfeldma@gmail.com>
Date:   Fri Nov 28 14:34:22 2014 +0100

    bridge: move private brport flags to if_bridge.h so port drivers can use flags
    
    Signed-off-by: Scott Feldman <sfeldma@gmail.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
    Acked-by: Andy Gospodarek <gospo@cumulusnetworks.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index cc36fb3efbdd..aea3d1339b3f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -164,16 +164,6 @@ struct net_bridge_port
 	struct rcu_head			rcu;
 
 	unsigned long 			flags;
-#define BR_HAIRPIN_MODE		0x00000001
-#define BR_BPDU_GUARD           0x00000002
-#define BR_ROOT_BLOCK		0x00000004
-#define BR_MULTICAST_FAST_LEAVE	0x00000008
-#define BR_ADMIN_COST		0x00000010
-#define BR_LEARNING		0x00000020
-#define BR_FLOOD		0x00000040
-#define BR_AUTO_MASK (BR_FLOOD | BR_LEARNING)
-#define BR_PROMISC		0x00000080
-#define BR_PROXYARP		0x00000100
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	struct bridge_mcast_own_query	ip4_own_query;

commit cf6b8e1eedffd9ef9a22c0c9453d752b07daf89a
Author: Scott Feldman <sfeldma@gmail.com>
Date:   Fri Nov 28 14:34:21 2014 +0100

    bridge: add API to notify bridge driver of learned FBD on offloaded device
    
    When the swdev device learns a new mac/vlan on a port, it sends some async
    notification to the driver and the driver installs an FDB in the device.
    To give a holistic system view, the learned mac/vlan should be reflected
    in the bridge's FBD table, so the user, using normal iproute2 cmds, can view
    what is currently learned by the device.  This API on the bridge driver gives
    a way for the swdev driver to install an FBD entry in the bridge FBD table.
    (And remove one).
    
    This is equivalent to the device running these cmds:
    
      bridge fdb [add|del] <mac> dev <dev> vid <vlan id> master
    
    This patch needs some extra eyeballs for review, in paricular around the
    locking and contexts.
    
    Signed-off-by: Scott Feldman <sfeldma@gmail.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1b529da8234d..cc36fb3efbdd 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -100,7 +100,8 @@ struct net_bridge_fdb_entry
 	mac_addr			addr;
 	unsigned char			is_local:1,
 					is_static:1,
-					added_by_user:1;
+					added_by_user:1,
+					added_by_external_learn:1;
 	__u16				vlan_id;
 };
 

commit f6f6424ba773da6221ecaaa70973eb4dacfa03b2
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Fri Nov 28 14:34:15 2014 +0100

    net: make vid as a parameter for ndo_fdb_add/ndo_fdb_del
    
    Do the work of parsing NDA_VLAN directly in rtnetlink code, pass simple
    u16 vid to drivers from there.
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Acked-by: Andy Gospodarek <gospo@cumulusnetworks.com>
    Acked-by: Jamal Hadi Salim <jhs@mojatatu.com>
    Acked-by: John Fastabend <john.r.fastabend@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 5b370773ad9c..1b529da8234d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -404,9 +404,9 @@ void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
 		   const unsigned char *addr, u16 vid, bool added_by_user);
 
 int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
-		  struct net_device *dev, const unsigned char *addr);
+		  struct net_device *dev, const unsigned char *addr, u16 vid);
 int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[], struct net_device *dev,
-	       const unsigned char *addr, u16 nlh_flags);
+	       const unsigned char *addr, u16 vid, u16 nlh_flags);
 int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
 		struct net_device *dev, struct net_device *fdev, int idx);
 int br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p);

commit 93859b13fa7ecef9d4d8bab4a7acc9f212c8fce2
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Fri Nov 28 14:34:14 2014 +0100

    bridge: convert flags in fbd entry into bitfields
    
    Suggested-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8f3f08140258..5b370773ad9c 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -98,9 +98,9 @@ struct net_bridge_fdb_entry
 	unsigned long			updated;
 	unsigned long			used;
 	mac_addr			addr;
-	unsigned char			is_local;
-	unsigned char			is_static;
-	unsigned char			added_by_user;
+	unsigned char			is_local:1,
+					is_static:1,
+					added_by_user:1;
 	__u16				vlan_id;
 };
 

commit 958501163ddd6ea22a98f94fa0e7ce6d4734e5c4
Author: Kyeyoon Park <kyeyoonp@codeaurora.org>
Date:   Thu Oct 23 14:49:17 2014 -0700

    bridge: Add support for IEEE 802.11 Proxy ARP
    
    This feature is defined in IEEE Std 802.11-2012, 10.23.13. It allows
    the AP devices to keep track of the hardware-address-to-IP-address
    mapping of the mobile devices within the WLAN network.
    
    The AP will learn this mapping via observing DHCP, ARP, and NS/NA
    frames. When a request for such information is made (i.e. ARP request,
    Neighbor Solicitation), the AP will respond on behalf of the
    associated mobile device. In the process of doing so, the AP will drop
    the multicast request frame that was intended to go out to the wireless
    medium.
    
    It was recommended at the LKS workshop to do this implementation in
    the bridge layer. vxlan.c is already doing something very similar.
    The DHCP snooping code will be added to the userspace application
    (hostapd) per the recommendation.
    
    This RFC commit is only for IPv4. A similar approach in the bridge
    layer will be taken for IPv6 as well.
    
    Signed-off-by: Kyeyoon Park <kyeyoonp@codeaurora.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 4d783d071305..8f3f08140258 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -172,6 +172,7 @@ struct net_bridge_port
 #define BR_FLOOD		0x00000040
 #define BR_AUTO_MASK (BR_FLOOD | BR_LEARNING)
 #define BR_PROMISC		0x00000080
+#define BR_PROXYARP		0x00000100
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	struct bridge_mcast_own_query	ip4_own_query;

commit 64b1f00a0830e1c53874067273a096b228d83d36
Merge: 16b99a4f6644 5301e3e117d8
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Oct 8 16:22:22 2014 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net

commit 93fdd47e52f3f869a437319db9da1ea409acc07e
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sun Oct 5 12:00:22 2014 +0800

    bridge: Save frag_max_size between PRE_ROUTING and POST_ROUTING
    
    As we may defragment the packet in IPv4 PRE_ROUTING and refragment
    it after POST_ROUTING we should save the value of frag_max_size.
    
    This is still very wrong as the bridge is supposed to leave the
    packets intact, meaning that the right thing to do is to use the
    original frag_list for fragmentation.
    
    Unfortunately we don't currently guarantee that the frag_list is
    left untouched throughout netfilter so until this changes this is
    the best we can do.
    
    There is also a spot in FORWARD where it appears that we can
    forward a packet without going through fragmentation, mark it
    so that we can fix it later.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index b6c04cbcfdc5..2398369c6dda 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -305,10 +305,14 @@ struct net_bridge
 
 struct br_input_skb_cb {
 	struct net_device *brdev;
+
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	int igmp;
 	int mrouters_only;
 #endif
+
+	u16 frag_max_size;
+
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	bool vlan_filtered;
 #endif

commit 5be5a2df40f005ea7fb7e280e87bbbcfcf1c2fc0
Author: Vlad Yasevich <vyasevich@gmail.com>
Date:   Fri Oct 3 11:29:18 2014 -0400

    bridge: Add filtering support for default_pvid
    
    Currently when vlan filtering is turned on on the bridge, the bridge
    will drop all traffic untill the user configures the filter.  This
    isn't very nice for ports that don't care about vlans and just
    want untagged traffic.
    
    A concept of a default_pvid was recently introduced.  This patch
    adds filtering support for default_pvid.   Now, ports that don't
    care about vlans and don't define there own filter will belong
    to the VLAN of the default_pvid and continue to receive untagged
    traffic.
    
    This filtering can be disabled by setting default_pvid to 0.
    
    Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f671561b3053..d8cbaa694227 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -605,12 +605,13 @@ bool br_vlan_find(struct net_bridge *br, u16 vid);
 void br_recalculate_fwd_mask(struct net_bridge *br);
 int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
-void br_vlan_init(struct net_bridge *br);
+int br_vlan_init(struct net_bridge *br);
 int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
 int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 void nbp_vlan_flush(struct net_bridge_port *port);
 bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
+int nbp_vlan_init(struct net_bridge_port *port);
 
 static inline struct net_port_vlans *br_get_vlan_info(
 						const struct net_bridge *br)
@@ -643,6 +644,9 @@ static inline int br_vlan_get_tag(const struct sk_buff *skb, u16 *vid)
 
 static inline u16 br_get_pvid(const struct net_port_vlans *v)
 {
+	if (!v)
+		return 0;
+
 	smp_rmb();
 	return v->pvid;
 }
@@ -703,8 +707,9 @@ static inline void br_recalculate_fwd_mask(struct net_bridge *br)
 {
 }
 
-static inline void br_vlan_init(struct net_bridge *br)
+static inline int br_vlan_init(struct net_bridge *br)
 {
+	return 0;
 }
 
 static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags)
@@ -737,6 +742,11 @@ static inline bool nbp_vlan_find(struct net_bridge_port *port, u16 vid)
 	return false;
 }
 
+static inline int nbp_vlan_init(struct net_bridge_port *port)
+{
+	return 0;
+}
+
 static inline u16 br_vlan_get_tag(const struct sk_buff *skb, u16 *tag)
 {
 	return 0;

commit 3df6bf45ec008942f16f1814123c4bdebcf50741
Author: Vlad Yasevich <vyasevich@gmail.com>
Date:   Fri Oct 3 11:29:17 2014 -0400

    bridge: Simplify pvid checks.
    
    Currently, if the pvid is not set, we return an illegal vlan value
    even though the pvid value is set to 0.  Since pvid of 0 is currently
    invalid, just return 0 instead.  This makes the current and future
    checks simpler.
    
    Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 5a347eb1d139..f671561b3053 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -643,11 +643,8 @@ static inline int br_vlan_get_tag(const struct sk_buff *skb, u16 *vid)
 
 static inline u16 br_get_pvid(const struct net_port_vlans *v)
 {
-	/* Return just the VID if it is set, or VLAN_N_VID (invalid vid) if
-	 * vid wasn't set
-	 */
 	smp_rmb();
-	return v->pvid ?: VLAN_N_VID;
+	return v->pvid;
 }
 
 static inline int br_vlan_enabled(struct net_bridge *br)
@@ -746,7 +743,7 @@ static inline u16 br_vlan_get_tag(const struct sk_buff *skb, u16 *tag)
 }
 static inline u16 br_get_pvid(const struct net_port_vlans *v)
 {
-	return VLAN_N_VID;	/* Returns invalid vid */
+	return 0;
 }
 
 static inline int br_vlan_enabled(struct net_bridge *br)

commit 96a20d9d7fff7068a2233b00379f0778a150bf86
Author: Vlad Yasevich <vyasevich@gmail.com>
Date:   Fri Oct 3 11:29:16 2014 -0400

    bridge: Add a default_pvid sysfs attribute
    
    This patch allows the user to set and retrieve default_pvid
    value.  A new value can only be stored when vlan filtering
    is disabled.
    
    Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index fe7463c2af9a..5a347eb1d139 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -299,6 +299,7 @@ struct net_bridge
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	u8				vlan_enabled;
 	__be16				vlan_proto;
+	u16				default_pvid;
 	struct net_port_vlans __rcu	*vlan_info;
 #endif
 };
@@ -605,6 +606,7 @@ void br_recalculate_fwd_mask(struct net_bridge *br);
 int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
 void br_vlan_init(struct net_bridge *br);
+int br_vlan_set_default_pvid(struct net_bridge *br, unsigned long val);
 int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 void nbp_vlan_flush(struct net_bridge_port *port);

commit 775dd692bd34f9201ed2aa775a0edcba4f973f3e
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Sep 30 16:13:19 2014 -0700

    net: bridge: add a br_set_state helper function
    
    In preparation for being able to propagate port states to e.g: notifiers
    or other kernel parts, do not manipulate the port state directly, but
    instead use a helper function which will allow us to do a bit more than
    just setting the state.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f53592fc3ef9..fe7463c2af9a 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -766,6 +766,7 @@ static inline void br_nf_core_fini(void) {}
 
 /* br_stp.c */
 void br_log_state(const struct net_bridge_port *p);
+void br_set_state(struct net_bridge_port *p, unsigned int state);
 struct net_bridge_port *br_get_port(struct net_bridge *br, u16 port_no);
 void br_init_port(struct net_bridge_port *p);
 void br_become_designated_port(struct net_bridge_port *p);

commit 852248449c73b5ffe109a33d65485c71d3d398a7
Merge: 735d383117e1 db29a9508a92
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Sep 29 14:46:53 2014 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/pablo/nf-next
    
    Pablo Neira Ayuso says:
    
    ====================
    pull request: netfilter/ipvs updates for net-next
    
    The following patchset contains Netfilter/IPVS updates for net-next,
    most relevantly they are:
    
    1) Four patches to make the new nf_tables masquerading support
       independent of the x_tables infrastructure. This also resolves a
       compilation breakage if the masquerade target is disabled but the
       nf_tables masq expression is enabled.
    
    2) ipset updates via Jozsef Kadlecsik. This includes the addition of the
       skbinfo extension that allows you to store packet metainformation in the
       elements. This can be used to fetch and restore this to the packets through
       the iptables SET target, patches from Anton Danilov.
    
    3) Add the hash:mac set type to ipset, from Jozsef Kadlecsick.
    
    4) Add simple weighted fail-over scheduler via Simon Horman. This provides
       a fail-over IPVS scheduler (unlike existing load balancing schedulers).
       Connections are directed to the appropriate server based solely on
       highest weight value and server availability, patch from Kenny Mathis.
    
    5) Support IPv6 real servers in IPv4 virtual-services and vice versa.
       Simon Horman informs that the motivation for this is to allow more
       flexibility in the choice of IP version offered by both virtual-servers
       and real-servers as they no longer need to match: An IPv4 connection
       from an end-user may be forwarded to a real-server using IPv6 and
       vice versa. No ip_vs_sync support yet though. Patches from Alex Gartrell
       and Julian Anastasov.
    
    6) Add global generation ID to the nf_tables ruleset. When dumping from
       several different object lists, we need a way to identify that an update
       has ocurred so userspace knows that it needs to refresh its lists. This
       also includes a new command to obtain the 32-bits generation ID. The
       less significant 16-bits of this ID is also exposed through res_id field
       in the nfnetlink header to quickly detect the interference and retry when
       there is no risk of ID wraparound.
    
    7) Move br_netfilter out of the bridge core. The br_netfilter code is
       built in the bridge core by default. This causes problems of different
       kind to people that don't want this: Jesper reported performance drop due
       to the inconditional hook registration and I remember to have read complains
       on netdev from people regarding the unexpected behaviour of our bridging
       stack when br_netfilter is enabled (fragmentation handling, layer 3 and
       upper inspection). People that still need this should easily undo the
       damage by modprobing the new br_netfilter module.
    
    8) Dump the set policy nf_tables that allows set parameterization. So
       userspace can keep user-defined preferences when saving the ruleset.
       From Arturo Borrero.
    
    9) Use __seq_open_private() helper function to reduce boiler plate code
       in x_tables, From Rob Jones.
    
    10) Safer default behaviour in case that you forget to load the protocol
       tracker. Daniel Borkmann and Florian Westphal detected that if your
       ruleset is stateful, you allow traffic to at least one single SCTP port
       and the SCTP protocol tracker is not loaded, then any SCTP traffic may
       be pass through unfiltered. After this patch, the connection tracking
       classifies SCTP/DCCP/UDPlite/GRE packets as invalid if your kernel has
       been compiled with support for these modules.
    ====================
    
    Trivially resolved conflict in include/linux/skbuff.h, Eric moved some
    netfilter skbuff members around, and the netfilter tree adjusted the
    ifdef guards for the bridging info pointer.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 34666d467cbf1e2e3c7bb15a63eccfb582cdd71f
Author: Pablo Neira Ayuso <pablo@netfilter.org>
Date:   Thu Sep 18 11:29:03 2014 +0200

    netfilter: bridge: move br_netfilter out of the core
    
    Jesper reported that br_netfilter always registers the hooks since
    this is part of the bridge core. This harms performance for people that
    don't need this.
    
    This patch modularizes br_netfilter so it can be rmmod'ed, thus,
    the hooks can be unregistered. I think the bridge netfilter should have
    been a separated module since the beginning, Patrick agreed on that.
    
    Note that this is breaking compatibility for users that expect that
    bridge netfilter is going to be available after explicitly 'modprobe
    bridge' or via automatic load through brctl.
    
    However, the damage can be easily undone by modprobing br_netfilter.
    The bridge core also spots a message to provide a clue to people that
    didn't notice that this has been deprecated.
    
    On top of that, the plan is that nftables will not rely on this software
    layer, but integrate the connection tracking into the bridge layer to
    enable stateful filtering and NAT, which is was bridge netfilter users
    seem to require.
    
    This patch still keeps the fake_dst_ops in the bridge core, since this
    is required by when the bridge port is initialized. So we can safely
    modprobe/rmmod br_netfilter anytime.
    
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>
    Acked-by: Florian Westphal <fw@strlen.de>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 62a7fa2e3569..d304d752c091 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -221,7 +221,7 @@ struct net_bridge
 	struct pcpu_sw_netstats		__percpu *stats;
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
-#ifdef CONFIG_BRIDGE_NETFILTER
+#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
 	struct rtable 			fake_rtable;
 	bool				nf_call_iptables;
 	bool				nf_call_ip6tables;
@@ -751,13 +751,13 @@ static inline int br_vlan_enabled(struct net_bridge *br)
 #endif
 
 /* br_netfilter.c */
-#ifdef CONFIG_BRIDGE_NETFILTER
-int br_netfilter_init(void);
-void br_netfilter_fini(void);
+#if IS_ENABLED(CONFIG_BRIDGE_NETFILTER)
+int br_nf_core_init(void);
+void br_nf_core_fini(void);
 void br_netfilter_rtable_init(struct net_bridge *);
 #else
-#define br_netfilter_init()	(0)
-#define br_netfilter_fini()	do { } while (0)
+static inline int br_nf_core_init(void) { return 0; }
+static inline void br_nf_core_fini(void) {}
 #define br_netfilter_rtable_init(x)
 #endif
 

commit 20adfa1a81af00bf2027644507ad4fa9cd2849cf
Author: Vlad Yasevich <vyasevich@gmail.com>
Date:   Fri Sep 12 16:26:16 2014 -0400

    bridge: Check if vlan filtering is enabled only once.
    
    The bridge code checks if vlan filtering is enabled on both
    ingress and egress.   When the state flip happens, it
    is possible for the bridge to currently be forwarding packets
    and forwarding behavior becomes non-deterministic.  Bridge
    may drop packets on some interfaces, but not others.
    
    This patch solves this by caching the filtered state of the
    packet into skb_cb on ingress.  The skb_cb is guaranteed to
    not be over-written between the time packet entres bridge
    forwarding path and the time it leaves it.  On egress, we
    can then check the cached state to see if we need to
    apply filtering information.
    
    Signed-off-by: Vladislav Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 62a7fa2e3569..b6c04cbcfdc5 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -309,6 +309,9 @@ struct br_input_skb_cb {
 	int igmp;
 	int mrouters_only;
 #endif
+#ifdef CONFIG_BRIDGE_VLAN_FILTERING
+	bool vlan_filtered;
+#endif
 };
 
 #define BR_INPUT_SKB_CB(__skb)	((struct br_input_skb_cb *)(__skb)->cb)

commit 5d5eacb34c9e1fdc0a47b885d832eaa4de860dc7
Author: Jamal Hadi Salim <jhs@mojatatu.com>
Date:   Thu Jul 10 07:01:58 2014 -0400

    bridge: fdb dumping takes a filter device
    
    Dumping a bridge fdb dumps every fdb entry
    held. With this change we are going to filter
    on selected bridge port.
    
    Signed-off-by: Jamal Hadi Salim <jhs@mojatatu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 23caf5b0309e..62a7fa2e3569 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -399,7 +399,7 @@ int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[], struct net_device *dev,
 	       const unsigned char *addr, u16 nlh_flags);
 int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
-		struct net_device *dev, int idx);
+		struct net_device *dev, struct net_device *fdev, int idx);
 int br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p);
 void br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p);
 

commit 204177f3f30c2dbd2db0aa62b5e9cf9029786450
Author: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
Date:   Tue Jun 10 20:59:25 2014 +0900

    bridge: Support 802.1ad vlan filtering
    
    This enables us to change the vlan protocol for vlan filtering.
    We come to be able to filter frames on the basis of 802.1ad vlan tags
    through a bridge.
    
    This also changes br->group_addr if it has not been set by user.
    This is needed for an 802.1ad bridge.
    (See IEEE 802.1Q-2011 8.13.5.)
    
    Furthermore, this sets br->group_fwd_mask_required so that an 802.1ad
    bridge can forward the Nearest Customer Bridge group addresses except
    for br->group_addr, which should be passed to higher layer.
    
    To change the vlan protocol, write a protocol in sysfs:
    # echo 0x88a8 > /sys/class/net/br0/bridge/vlan_protocol
    
    Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 4eba348a985b..23caf5b0309e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -243,6 +243,7 @@ struct net_bridge
 	unsigned long			bridge_forward_delay;
 
 	u8				group_addr[ETH_ALEN];
+	bool				group_addr_set;
 	u16				root_port;
 
 	enum {
@@ -597,7 +598,9 @@ int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
 int br_vlan_delete(struct net_bridge *br, u16 vid);
 void br_vlan_flush(struct net_bridge *br);
 bool br_vlan_find(struct net_bridge *br, u16 vid);
+void br_recalculate_fwd_mask(struct net_bridge *br);
 int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
+int br_vlan_set_proto(struct net_bridge *br, unsigned long val);
 void br_vlan_init(struct net_bridge *br);
 int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
@@ -694,6 +697,10 @@ static inline bool br_vlan_find(struct net_bridge *br, u16 vid)
 	return false;
 }
 
+static inline void br_recalculate_fwd_mask(struct net_bridge *br)
+{
+}
+
 static inline void br_vlan_init(struct net_bridge *br)
 {
 }

commit f2808d226f4efe15a0ea44697a3525176d6c8eae
Author: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
Date:   Tue Jun 10 20:59:24 2014 +0900

    bridge: Prepare for forwarding another bridge group addresses
    
    If a bridge is an 802.1ad bridge, it must forward another bridge group
    addresses (the Nearest Customer Bridge group addresses).
    (For details, see IEEE 802.1Q-2011 8.6.3.)
    
    As user might not want group_fwd_mask to be modified by enabling 802.1ad,
    introduce a new mask, group_fwd_mask_required, which indicates addresses
    the bridge wants to forward. This will be set by enabling 802.1ad.
    
    Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 13e570e8b0fc..4eba348a985b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -35,6 +35,8 @@
 #define BR_GROUPFWD_DEFAULT	0
 /* Don't allow forwarding control protocols like STP and LLDP */
 #define BR_GROUPFWD_RESTRICTED	0x4007u
+/* The Nearest Customer Bridge Group Address, 01-80-C2-00-00-[00,0B,0C,0D,0F] */
+#define BR_GROUPFWD_8021AD	0xB801u
 
 /* Path to usermode spanning tree program */
 #define BR_STP_PROG	"/sbin/bridge-stp"
@@ -226,6 +228,7 @@ struct net_bridge
 	bool				nf_call_arptables;
 #endif
 	u16				group_fwd_mask;
+	u16				group_fwd_mask_required;
 
 	/* STP */
 	bridge_id			designated_root;

commit 8580e2117c06ac0c97a561219eaab6dab968ea3f
Author: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
Date:   Tue Jun 10 20:59:23 2014 +0900

    bridge: Prepare for 802.1ad vlan filtering support
    
    This enables a bridge to have vlan protocol informantion and allows vlan
    tag manipulation (retrieve, insert and remove tags) according to the vlan
    protocol.
    
    Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8346e9504cdb..13e570e8b0fc 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -294,6 +294,7 @@ struct net_bridge
 	u32				auto_cnt;
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	u8				vlan_enabled;
+	__be16				vlan_proto;
 	struct net_port_vlans __rcu	*vlan_info;
 #endif
 };
@@ -594,6 +595,7 @@ int br_vlan_delete(struct net_bridge *br, u16 vid);
 void br_vlan_flush(struct net_bridge *br);
 bool br_vlan_find(struct net_bridge *br, u16 vid);
 int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
+void br_vlan_init(struct net_bridge *br);
 int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 void nbp_vlan_flush(struct net_bridge_port *port);
@@ -689,6 +691,10 @@ static inline bool br_vlan_find(struct net_bridge *br, u16 vid)
 	return false;
 }
 
+static inline void br_vlan_init(struct net_bridge *br)
+{
+}
+
 static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags)
 {
 	return -EOPNOTSUPP;

commit 2cd4143192e8c60f66cb32c3a30c76d0470a372d
Author: Linus Lssing <linus.luessing@web.de>
Date:   Sat Jun 7 18:26:29 2014 +0200

    bridge: memorize and export selected IGMP/MLD querier port
    
    Adding bridge support to the batman-adv multicast optimization requires
    batman-adv knowing about the existence of bridged-in IGMP/MLD queriers
    to be able to reliably serve any multicast listener behind this same
    bridge.
    
    Signed-off-by: Linus Lssing <linus.luessing@web.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 50e2ab021484..8346e9504cdb 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -70,6 +70,7 @@ struct bridge_mcast_other_query {
 /* selected querier */
 struct bridge_mcast_querier {
 	struct br_ip addr;
+	struct net_bridge_port __rcu	*port;
 };
 #endif
 

commit 07f8ac4a1e26e8283542cdaf658a6e2a12fd6980
Author: Linus Lssing <linus.luessing@web.de>
Date:   Sat Jun 7 18:26:28 2014 +0200

    bridge: add export of multicast database adjacent to net_dev
    
    With this new, exported function br_multicast_list_adjacent(net_dev) a
    list of IPv4/6 addresses is returned. This list contains all multicast
    addresses sensed by the bridge multicast snooping feature on all bridge
    ports of the bridge interface of net_dev, excluding addresses from the
    specified net_device itself.
    
    Adding bridge support to the batman-adv multicast optimization requires
    batman-adv knowing about the existence of bridged-in multicast
    listeners to be able to reliably serve them with multicast packets.
    
    Signed-off-by: Linus Lssing <linus.luessing@web.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 97c5e46dde72..50e2ab021484 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -54,18 +54,6 @@ struct mac_addr
 	unsigned char	addr[ETH_ALEN];
 };
 
-struct br_ip
-{
-	union {
-		__be32	ip4;
-#if IS_ENABLED(CONFIG_IPV6)
-		struct in6_addr ip6;
-#endif
-	} u;
-	__be16		proto;
-	__u16		vid;
-};
-
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 /* our own querier */
 struct bridge_mcast_own_query {

commit dc4eb53a996a78bfb8ea07b47423ff5a3aadc362
Author: Linus Lssing <linus.luessing@web.de>
Date:   Sat Jun 7 18:26:27 2014 +0200

    bridge: adhere to querier election mechanism specified by RFCs
    
    MLDv1 (RFC2710 section 6), MLDv2 (RFC3810 section 7.6.2), IGMPv2
    (RFC2236 section 3) and IGMPv3 (RFC3376 section 6.6.2) specify that the
    querier with lowest source address shall become the selected
    querier.
    
    So far the bridge stopped its querier as soon as it heard another
    querier regardless of its source address. This results in the "wrong"
    querier potentially becoming the active querier or a potential,
    unnecessary querying delay.
    
    With this patch the bridge memorizes the source address of the currently
    selected querier and ignores queries from queriers with a higher source
    address than the currently selected one. This slight optimization is
    supposed to make it more RFC compliant (but is rather uncritical and
    therefore probably not necessary to be queued for stable kernels).
    
    Signed-off-by: Linus Lssing <linus.luessing@web.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2469aeeda1ec..97c5e46dde72 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -78,6 +78,11 @@ struct bridge_mcast_other_query {
 	struct timer_list		timer;
 	unsigned long			delay_time;
 };
+
+/* selected querier */
+struct bridge_mcast_querier {
+	struct br_ip addr;
+};
 #endif
 
 struct net_port_vlans {
@@ -284,9 +289,11 @@ struct net_bridge
 	struct timer_list		multicast_router_timer;
 	struct bridge_mcast_other_query	ip4_other_query;
 	struct bridge_mcast_own_query	ip4_own_query;
+	struct bridge_mcast_querier	ip4_querier;
 #if IS_ENABLED(CONFIG_IPV6)
 	struct bridge_mcast_other_query	ip6_other_query;
 	struct bridge_mcast_own_query	ip6_own_query;
+	struct bridge_mcast_querier	ip6_querier;
 #endif /* IS_ENABLED(CONFIG_IPV6) */
 #endif
 

commit 90010b36ebbedc6c3b7f09d384fecc5f18d77031
Author: Linus Lssing <linus.luessing@web.de>
Date:   Sat Jun 7 18:26:26 2014 +0200

    bridge: rename struct bridge_mcast_query/querier
    
    The current naming of these two structs is very random, in that
    reversing their naming would not make any semantical difference.
    
    This patch tries to make the naming less confusing by giving them a more
    specific, distinguishable naming.
    
    This is also useful for the upcoming patches reintroducing the
    "struct bridge_mcast_querier" but for storing information about the
    selected querier (no matter if our own or a foreign querier).
    
    Signed-off-by: Linus Lssing <linus.luessing@web.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index bc17210d4c52..2469aeeda1ec 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -68,13 +68,13 @@ struct br_ip
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 /* our own querier */
-struct bridge_mcast_query {
+struct bridge_mcast_own_query {
 	struct timer_list	timer;
 	u32			startup_sent;
 };
 
 /* other querier */
-struct bridge_mcast_querier {
+struct bridge_mcast_other_query {
 	struct timer_list		timer;
 	unsigned long			delay_time;
 };
@@ -178,9 +178,9 @@ struct net_bridge_port
 #define BR_PROMISC		0x00000080
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
-	struct bridge_mcast_query	ip4_query;
+	struct bridge_mcast_own_query	ip4_own_query;
 #if IS_ENABLED(CONFIG_IPV6)
-	struct bridge_mcast_query	ip6_query;
+	struct bridge_mcast_own_query	ip6_own_query;
 #endif /* IS_ENABLED(CONFIG_IPV6) */
 	unsigned char			multicast_router;
 	struct timer_list		multicast_router_timer;
@@ -282,11 +282,11 @@ struct net_bridge
 	struct hlist_head		router_list;
 
 	struct timer_list		multicast_router_timer;
-	struct bridge_mcast_querier	ip4_querier;
-	struct bridge_mcast_query	ip4_query;
+	struct bridge_mcast_other_query	ip4_other_query;
+	struct bridge_mcast_own_query	ip4_own_query;
 #if IS_ENABLED(CONFIG_IPV6)
-	struct bridge_mcast_querier	ip6_querier;
-	struct bridge_mcast_query	ip6_query;
+	struct bridge_mcast_other_query	ip6_other_query;
+	struct bridge_mcast_own_query	ip6_own_query;
 #endif /* IS_ENABLED(CONFIG_IPV6) */
 #endif
 
@@ -493,7 +493,7 @@ static inline bool br_multicast_is_router(struct net_bridge *br)
 
 static inline bool
 __br_multicast_querier_exists(struct net_bridge *br,
-			      struct bridge_mcast_querier *querier)
+			      struct bridge_mcast_other_query *querier)
 {
 	return time_is_before_jiffies(querier->delay_time) &&
 	       (br->multicast_querier || timer_pending(&querier->timer));
@@ -504,10 +504,10 @@ static inline bool br_multicast_querier_exists(struct net_bridge *br,
 {
 	switch (eth->h_proto) {
 	case (htons(ETH_P_IP)):
-		return __br_multicast_querier_exists(br, &br->ip4_querier);
+		return __br_multicast_querier_exists(br, &br->ip4_other_query);
 #if IS_ENABLED(CONFIG_IPV6)
 	case (htons(ETH_P_IPV6)):
-		return __br_multicast_querier_exists(br, &br->ip6_querier);
+		return __br_multicast_querier_exists(br, &br->ip6_other_query);
 #endif
 	default:
 		return false;

commit c99f7abf0e69987e4add567e155e042cb1f2a20b
Merge: 92ff71b8fe9c d8b0426af5b6
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 3 23:32:12 2014 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            include/net/inetpeer.h
            net/ipv6/output_core.c
    
    Changes in net were fixing bugs in code removed in net-next.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e0d7968ab6c8bce2437b36fa7f04117e333f196d
Author: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
Date:   Mon May 26 15:15:53 2014 +0900

    bridge: Prevent insertion of FDB entry with disallowed vlan
    
    br_handle_local_finish() is allowing us to insert an FDB entry with
    disallowed vlan. For example, when port 1 and 2 are communicating in
    vlan 10, and even if vlan 10 is disallowed on port 3, port 3 can
    interfere with their communication by spoofed src mac address with
    vlan id 10.
    
    Note: Even if it is judged that a frame should not be learned, it should
    not be dropped because it is destined for not forwarding layer but higher
    layer. See IEEE 802.1Q-2011 8.13.10.
    
    Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Acked-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 06811d79f89f..59d3a85c5873 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -581,6 +581,7 @@ bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
 			struct sk_buff *skb, u16 *vid);
 bool br_allowed_egress(struct net_bridge *br, const struct net_port_vlans *v,
 		       const struct sk_buff *skb);
+bool br_should_learn(struct net_bridge_port *p, struct sk_buff *skb, u16 *vid);
 struct sk_buff *br_handle_vlan(struct net_bridge *br,
 			       const struct net_port_vlans *v,
 			       struct sk_buff *skb);
@@ -648,6 +649,12 @@ static inline bool br_allowed_egress(struct net_bridge *br,
 	return true;
 }
 
+static inline bool br_should_learn(struct net_bridge_port *p,
+				   struct sk_buff *skb, u16 *vid)
+{
+	return true;
+}
+
 static inline struct sk_buff *br_handle_vlan(struct net_bridge *br,
 					     const struct net_port_vlans *v,
 					     struct sk_buff *skb)

commit b1282726d53465c7362eb134eb335173e8cd5b8c
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Tue May 20 17:30:00 2014 -0700

    bridge: make br_device_notifier static
    
    Merge net/bridge/br_notify.c into net/bridge/br.c,
    since it has only br_device_event() and br.c is small.
    
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: David S. Miller <davem@davemloft.net>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index af067711574f..53d6e32965fc 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -333,8 +333,6 @@ struct br_input_skb_cb {
 #define br_debug(br, format, args...)			\
 	pr_debug("%s: " format,  (br)->dev->name, ##args)
 
-extern struct notifier_block br_device_notifier;
-
 /* called under bridge lock */
 static inline int br_is_root_bridge(const struct net_bridge *br)
 {

commit d4f0e0958dbacaa1c678d88bf02a4794c66fb832
Author: Alexei Starovoitov <ast@plumgrid.com>
Date:   Sun May 18 10:30:28 2014 -0700

    net: bridge: fix build
    
    fix build when BRIDGE_VLAN_FILTERING is not set
    
    Fixes: 2796d0c648c94 ("bridge: Automatically manage port promiscuous mode")
    
    Signed-off-by: Alexei Starovoitov <ast@plumgrid.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2b2286d8572d..af067711574f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -727,7 +727,7 @@ static inline u16 br_get_pvid(const struct net_port_vlans *v)
 	return VLAN_N_VID;	/* Returns invalid vid */
 }
 
-static inline int br_vlan_enabled(struct net_bridge *br);
+static inline int br_vlan_enabled(struct net_bridge *br)
 {
 	return 0;
 }

commit 2796d0c648c940b4796f84384fbcfb0a2399db84
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Fri May 16 09:59:20 2014 -0400

    bridge: Automatically manage port promiscuous mode.
    
    There exist configurations where the administrator or another management
    entity has the foreknowledge of all the mac addresses of end systems
    that are being bridged together.
    
    In these environments, the administrator can statically configure known
    addresses in the bridge FDB and disable flooding and learning on ports.
    This makes it possible to turn off promiscuous mode on the interfaces
    connected to the bridge.
    
    Here is why disabling flooding and learning allows us to control
    promiscuity:
     Consider port X.  All traffic coming into this port from outside the
    bridge (ingress) will be either forwarded through other ports of the
    bridge (egress) or dropped.  Forwarding (egress) is defined by FDB
    entries and by flooding in the event that no FDB entry exists.
    In the event that flooding is disabled, only FDB entries define
    the egress.  Once learning is disabled, only static FDB entries
    provided by a management entity define the egress.  If we provide
    information from these static FDBs to the ingress port X, then we'll
    be able to accept all traffic that can be successfully forwarded and
    drop all the other traffic sooner without spending CPU cycles to
    process it.
     Another way to define the above is as following equations:
        ingress = egress + drop
     expanding egress
        ingress = static FDB + learned FDB + flooding + drop
     disabling flooding and learning we a left with
        ingress = static FDB + drop
    
    By adding addresses from the static FDB entries to the MAC address
    filter of an ingress port X, we fully define what the bridge can
    process without dropping and can thus turn off promiscuous mode,
    thus dropping packets sooner.
    
    There have been suggestions that we may want to allow learning
    and update the filters with learned addresses as well.  This
    would require mac-level authentication similar to 802.1x to
    prevent attacks against the hw filters as they are limited
    resource.
    
    Additionally, if the user places the bridge device in promiscuous mode,
    all ports are placed in promiscuous mode regardless of the changes
    to flooding and learning.
    
    Since the above functionality depends on full static configuration,
    we have also require that vlan filtering be enabled to take
    advantage of this.  The reason is that the bridge has to be
    able to receive and process VLAN-tagged frames and the there
    are only 2 ways to accomplish this right now: promiscuous mode
    or vlan filtering.
    
    Suggested-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 00922a4fa795..2b2286d8572d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -424,6 +424,7 @@ int br_min_mtu(const struct net_bridge *br);
 netdev_features_t br_features_recompute(struct net_bridge *br,
 					netdev_features_t features);
 void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);
+void br_manage_promisc(struct net_bridge *br);
 
 /* br_input.c */
 int br_handle_frame_finish(struct sk_buff *skb);
@@ -641,6 +642,10 @@ static inline u16 br_get_pvid(const struct net_port_vlans *v)
 	return v->pvid ?: VLAN_N_VID;
 }
 
+static inline int br_vlan_enabled(struct net_bridge *br)
+{
+	return br->vlan_enabled;
+}
 #else
 static inline bool br_allowed_ingress(struct net_bridge *br,
 				      struct net_port_vlans *v,
@@ -721,6 +726,11 @@ static inline u16 br_get_pvid(const struct net_port_vlans *v)
 {
 	return VLAN_N_VID;	/* Returns invalid vid */
 }
+
+static inline int br_vlan_enabled(struct net_bridge *br);
+{
+	return 0;
+}
 #endif
 
 /* br_netfilter.c */

commit f3a6ddf15209cfad90b83e04168f42a5d9c8cc17
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Fri May 16 09:59:18 2014 -0400

    bridge: Introduce BR_PROMISC flag
    
    Introduce a BR_PROMISC per-port flag that will help us track if the
    current port is supposed to be in promiscuous mode or not.  For now,
    always start in promiscuous mode.
    
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c0a804b5ff08..00922a4fa795 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -175,6 +175,7 @@ struct net_bridge_port
 #define BR_LEARNING		0x00000020
 #define BR_FLOOD		0x00000040
 #define BR_AUTO_MASK (BR_FLOOD | BR_LEARNING)
+#define BR_PROMISC		0x00000080
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	struct bridge_mcast_query	ip4_query;
@@ -200,6 +201,7 @@ struct net_bridge_port
 };
 
 #define br_auto_port(p) ((p)->flags & BR_AUTO_MASK)
+#define br_promisc_port(p) ((p)->flags & BR_PROMISC)
 
 #define br_port_exists(dev) (dev->priv_flags & IFF_BRIDGE_PORT)
 

commit 8db24af71b31690a30ad371b35936fa10e547ee7
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Fri May 16 09:59:17 2014 -0400

    bridge: Add functionality to sync static fdb entries to hw
    
    Add code that allows static fdb entires to be synced to the
    hw list for a specified port.  This will be used later to
    program ports that can function in non-promiscuous mode.
    
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 5ce3191438d8..c0a804b5ff08 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -399,6 +399,8 @@ int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[], struct net_device *dev,
 	       const unsigned char *addr, u16 nlh_flags);
 int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
 		struct net_device *dev, int idx);
+int br_fdb_sync_static(struct net_bridge *br, struct net_bridge_port *p);
+void br_fdb_unsync_static(struct net_bridge *br, struct net_bridge_port *p);
 
 /* br_forward.c */
 void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb);

commit e028e4b8dc93be7bc3ff9e0b94cb68d7f104883b
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Fri May 16 09:59:16 2014 -0400

    bridge: Keep track of ports capable of automatic discovery.
    
    By default, ports on the bridge are capable of automatic
    discovery of nodes located behind the port.  This is accomplished
    via flooding of unknown traffic (BR_FLOOD) and learning the
    mac addresses from these packets (BR_LEARNING).
    If the above functionality is disabled by turning off these
    flags, the port requires static configuration in the form
    of static FDB entries to function properly.
    
    This patch adds functionality to keep track of all ports
    capable of automatic discovery.  This will later be used
    to control promiscuity settings.
    
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 06811d79f89f..5ce3191438d8 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -174,6 +174,7 @@ struct net_bridge_port
 #define BR_ADMIN_COST		0x00000010
 #define BR_LEARNING		0x00000020
 #define BR_FLOOD		0x00000040
+#define BR_AUTO_MASK (BR_FLOOD | BR_LEARNING)
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	struct bridge_mcast_query	ip4_query;
@@ -198,6 +199,8 @@ struct net_bridge_port
 #endif
 };
 
+#define br_auto_port(p) ((p)->flags & BR_AUTO_MASK)
+
 #define br_port_exists(dev) (dev->priv_flags & IFF_BRIDGE_PORT)
 
 static inline struct net_bridge_port *br_port_get_rcu(const struct net_device *dev)
@@ -290,6 +293,7 @@ struct net_bridge
 	struct timer_list		topology_change_timer;
 	struct timer_list		gc_timer;
 	struct kobject			*ifobj;
+	u32				auto_cnt;
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 	u8				vlan_enabled;
 	struct net_port_vlans __rcu	*vlan_info;
@@ -415,6 +419,7 @@ int br_del_if(struct net_bridge *br, struct net_device *dev);
 int br_min_mtu(const struct net_bridge *br);
 netdev_features_t br_features_recompute(struct net_bridge *br,
 					netdev_features_t features);
+void br_port_flags_change(struct net_bridge_port *port, unsigned long mask);
 
 /* br_input.c */
 int br_handle_frame_finish(struct sk_buff *skb);

commit a8779ec1c5e60548b7b661a8d74a8cecf7775690
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Thu Mar 27 15:36:38 2014 -0700

    netpoll: Remove gfp parameter from __netpoll_setup
    
    The gfp parameter was added in:
    commit 47be03a28cc6c80e3aa2b3e8ed6d960ff0c5c0af
    Author: Amerigo Wang <amwang@redhat.com>
    Date:   Fri Aug 10 01:24:37 2012 +0000
    
        netpoll: use GFP_ATOMIC in slave_enable_netpoll() and __netpoll_setup()
    
        slave_enable_netpoll() and __netpoll_setup() may be called
        with read_lock() held, so should use GFP_ATOMIC to allocate
        memory. Eric suggested to pass gfp flags to __netpoll_setup().
    
        Cc: Eric Dumazet <eric.dumazet@gmail.com>
        Cc: "David S. Miller" <davem@davemloft.net>
        Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
        Signed-off-by: Eric Dumazet <edumazet@google.com>
        Signed-off-by: Cong Wang <amwang@redhat.com>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
    The reason for the gfp parameter was removed in:
    commit c4cdef9b7183159c23c7302aaf270d64c549f557
    Author: dingtianhong <dingtianhong@huawei.com>
    Date:   Tue Jul 23 15:25:27 2013 +0800
    
        bonding: don't call slave_xxx_netpoll under spinlocks
    
        The slave_xxx_netpoll will call synchronize_rcu_bh(),
        so the function may schedule and sleep, it should't be
        called under spinlocks.
    
        bond_netpoll_setup() and bond_netpoll_cleanup() are always
        protected by rtnl lock, it is no need to take the read lock,
        as the slave list couldn't be changed outside rtnl lock.
    
        Signed-off-by: Ding Tianhong <dingtianhong@huawei.com>
        Cc: Jay Vosburgh <fubar@us.ibm.com>
        Cc: Andy Gospodarek <andy@greyhouse.net>
        Signed-off-by: David S. Miller <davem@davemloft.net>
    
    Nothing else that calls __netpoll_setup or ndo_netpoll_setup
    requires a gfp paramter, so remove the gfp parameter from both
    of these functions making the code clearer.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e1ca1dc916a4..06811d79f89f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -349,7 +349,7 @@ static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 		netpoll_send_skb(np, skb);
 }
 
-int br_netpoll_enable(struct net_bridge_port *p, gfp_t gfp);
+int br_netpoll_enable(struct net_bridge_port *p);
 void br_netpoll_disable(struct net_bridge_port *p);
 #else
 static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
@@ -357,7 +357,7 @@ static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 {
 }
 
-static inline int br_netpoll_enable(struct net_bridge_port *p, gfp_t gfp)
+static inline int br_netpoll_enable(struct net_bridge_port *p)
 {
 	return 0;
 }

commit e5a727f6632654098fa4e87d8551a5873e8f658a
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 23 00:05:25 2014 -0800

    bridge: Use ether_addr_copy and ETH_ALEN
    
    Convert the more obvious uses of memcpy to ether_addr_copy.
    
    There are still uses of memcpy that could be converted but
    these addresses are __aligned(2).
    
    Convert a couple uses of 6 in gr_private.h to ETH_ALEN.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3ba11bc99b65..e1ca1dc916a4 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -46,12 +46,12 @@ typedef __u16 port_id;
 struct bridge_id
 {
 	unsigned char	prio[2];
-	unsigned char	addr[6];
+	unsigned char	addr[ETH_ALEN];
 };
 
 struct mac_addr
 {
-	unsigned char	addr[6];
+	unsigned char	addr[ETH_ALEN];
 };
 
 struct br_ip

commit 424bb9c97cc1992018950485ca7410779b8ea21d
Author: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
Date:   Fri Feb 7 16:48:25 2014 +0900

    bridge: Properly check if local fdb entry can be deleted when deleting vlan
    
    Vlan codes unconditionally delete local fdb entries.
    We should consider the possibility that other ports have the same
    address and vlan.
    
    Example of problematic case:
      ip link set eth0 address 12:34:56:78:90:ab
      ip link set eth1 address aa:bb:cc:dd:ee:ff
      brctl addif br0 eth0
      brctl addif br0 eth1 # br0 will have mac address 12:34:56:78:90:ab
      bridge vlan add dev eth0 vid 10
      bridge vlan add dev eth1 vid 10
      bridge vlan add dev br0 vid 10 self
    We will have fdb entry such that f->dst == eth0, f->vlan_id == 10 and
    f->addr == 12:34:56:78:90:ab at this time.
    Next, delete eth0 vlan 10.
      bridge vlan del dev eth0 vid 10
    In this case, we still need the entry for br0, but it will be deleted.
    
    Note that br0 needs the entry even though its mac address is not set
    manually. To delete the entry with proper condition checking,
    fdb_delete_local() is suitable to use.
    
    Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Acked-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f91e1d9c8e92..3ba11bc99b65 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -371,6 +371,9 @@ static inline void br_netpoll_disable(struct net_bridge_port *p)
 int br_fdb_init(void);
 void br_fdb_fini(void);
 void br_fdb_flush(struct net_bridge *br);
+void br_fdb_find_delete_local(struct net_bridge *br,
+			      const struct net_bridge_port *p,
+			      const unsigned char *addr, u16 vid);
 void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr);
 void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
 void br_fdb_cleanup(unsigned long arg);
@@ -385,7 +388,6 @@ int br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
 		  const unsigned char *addr, u16 vid);
 void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
 		   const unsigned char *addr, u16 vid, bool added_by_user);
-int fdb_delete_by_addr(struct net_bridge *br, const u8 *addr, u16 vid);
 
 int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 		  struct net_device *dev, const unsigned char *addr);

commit 2b292fb4a57dc233e298a84196d33be0bc3828e4
Author: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
Date:   Fri Feb 7 16:48:22 2014 +0900

    bridge: Fix the way to check if a local fdb entry can be deleted
    
    We should take into account the followings when deleting a local fdb
    entry.
    
    - nbp_vlan_find() can be used only when vid != 0 to check if an entry is
      deletable, because a fdb entry with vid 0 can exist at any time while
      nbp_vlan_find() always return false with vid 0.
    
      Example of problematic case:
        ip link set eth0 address 12:34:56:78:90:ab
        ip link set eth1 address 12:34:56:78:90:ab
        brctl addif br0 eth0
        brctl addif br0 eth1
        ip link set eth0 address aa:bb:cc:dd:ee:ff
      Then, the fdb entry 12:34:56:78:90:ab will be deleted even though the
      bridge port eth1 still has that address.
    
    - The port to which the bridge device is attached might needs a local entry
      if its mac address is set manually.
    
      Example of problematic case:
        ip link set eth0 address 12:34:56:78:90:ab
        brctl addif br0 eth0
        ip link set br0 address 12:34:56:78:90:ab
        ip link set eth0 address aa:bb:cc:dd:ee:ff
      Then, the fdb still must have the entry 12:34:56:78:90:ab, but it will be
      deleted.
    
    We can use br->dev->addr_assign_type to check if the address is manually
    set or not, but I propose another approach.
    
    Since we delete and insert local entries whenever changing mac address
    of the bridge device, we can change dst of the entry to NULL regardless of
    addr_assign_type when deleting an entry associated with a certain port,
    and if it is found to be unnecessary later, then delete it.
    That is, if changing mac address of a port, the entry might be changed
    to its dst being NULL first, but is eventually deleted when recalculating
    and changing bridge id.
    
    This approach is especially useful when we want to share the code with
    deleting vlan in which the bridge device might want such an entry regardless
    of addr_assign_type, and makes things easy because we don't have to consider
    if mac address of the bridge device will be changed or not at the time we
    delete a local entry of a port, which means fdb code will not be bothered
    even if the bridge id calculating logic is changed in the future.
    
    Also, this change reduces inconsistent state, where frames whose dst is the
    mac address of the bridge, can't reach the bridge because of premature fdb
    entry deletion. This change reduces the possibility that the bridge device
    replies unreachable mac address to arp requests, which could occur during
    the short window between calling del_nbp() and br_stp_recalculate_bridge_id()
    in br_del_if(). This will effective after br_fdb_delete_by_port() starts to
    use the same code by following patch.
    
    Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Acked-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 939a59e15036..f91e1d9c8e92 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -585,6 +585,7 @@ struct sk_buff *br_handle_vlan(struct net_bridge *br,
 int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
 int br_vlan_delete(struct net_bridge *br, u16 vid);
 void br_vlan_flush(struct net_bridge *br);
+bool br_vlan_find(struct net_bridge *br, u16 vid);
 int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
@@ -666,6 +667,11 @@ static inline void br_vlan_flush(struct net_bridge *br)
 {
 }
 
+static inline bool br_vlan_find(struct net_bridge *br, u16 vid)
+{
+	return false;
+}
+
 static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags)
 {
 	return -EOPNOTSUPP;

commit a5642ab4744bc8c5a8c7ce7c6e30c01bd6bbc691
Author: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
Date:   Fri Feb 7 16:48:18 2014 +0900

    bridge: Fix the way to find old local fdb entries in br_fdb_changeaddr
    
    br_fdb_changeaddr() assumes that there is at most one local entry per port
    per vlan. It used to be true, but since commit 36fd2b63e3b4 ("bridge: allow
    creating/deleting fdb entries via netlink"), it has not been so.
    Therefore, the function might fail to search a correct previous address
    to be deleted and delete an arbitrary local entry if user has added local
    entries manually.
    
    Example of problematic case:
      ip link set eth0 address ee:ff:12:34:56:78
      brctl addif br0 eth0
      bridge fdb add 12:34:56:78:90:ab dev eth0 master
      ip link set eth0 address aa:bb:cc:dd:ee:ff
    Then, the address 12:34:56:78:90:ab might be deleted instead of
    ee:ff:12:34:56:78, the original mac address of eth0.
    
    Address this issue by introducing a new flag, added_by_user, to struct
    net_bridge_fdb_entry.
    
    Note that br_fdb_delete_by_port() has to set added_by_user to 0 in cases
    like:
      ip link set eth0 address 12:34:56:78:90:ab
      ip link set eth1 address aa:bb:cc:dd:ee:ff
      brctl addif br0 eth0
      bridge fdb add aa:bb:cc:dd:ee:ff dev eth0 master
      brctl addif br0 eth1
      brctl delif br0 eth0
    In this case, kernel should delete the user-added entry aa:bb:cc:dd:ee:ff,
    but it also should have been added by "brctl addif br0 eth1" originally,
    so we don't delete it and treat it a new kernel-created entry.
    
    Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index fcd12333c59b..939a59e15036 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -104,6 +104,7 @@ struct net_bridge_fdb_entry
 	mac_addr			addr;
 	unsigned char			is_local;
 	unsigned char			is_static;
+	unsigned char			added_by_user;
 	__u16				vlan_id;
 };
 
@@ -383,7 +384,7 @@ int br_fdb_fillbuf(struct net_bridge *br, void *buf, unsigned long count,
 int br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
 		  const unsigned char *addr, u16 vid);
 void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
-		   const unsigned char *addr, u16 vid);
+		   const unsigned char *addr, u16 vid, bool added_by_user);
 int fdb_delete_by_addr(struct net_bridge *br, const u8 *addr, u16 vid);
 
 int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],

commit b86f81cca9442ce6cfbe76d10fb8d2c61122ae12
Author: WANG Cong <xiyou.wangcong@gmail.com>
Date:   Fri Jan 10 13:58:47 2014 -0800

    bridge: move br_net_exit() to br.c
    
    And it can become static.
    
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: David S. Miller <davem@davemloft.net>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3733f152351c..fcd12333c59b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -407,7 +407,6 @@ void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
 void br_port_carrier_check(struct net_bridge_port *p);
 int br_add_bridge(struct net *net, const char *name);
 int br_del_bridge(struct net *net, const char *name);
-void br_net_exit(struct net *net);
 int br_add_if(struct net_bridge *br, struct net_device *dev);
 int br_del_if(struct net_bridge *br, struct net_device *dev);
 int br_min_mtu(const struct net_bridge *br);

commit 8f84985fec10de64a6b4cdfea45f2b0ab8f07c78
Author: Li RongQing <roy.qing.li@gmail.com>
Date:   Sat Jan 4 13:57:59 2014 +0800

    net: unify the pcpu_tstats and br_cpu_netstats as one
    
    They are same, so unify them as one, pcpu_sw_netstats.
    
    Define pcpu_sw_netstat in netdevice.h, remove pcpu_tstats
    from if_tunnel and remove br_cpu_netstats from br_private.h
    
    Cc: Cong Wang <xiyou.wangcong@gmail.com>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Li RongQing <roy.qing.li@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2e77d923c8ee..3733f152351c 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -210,21 +210,13 @@ static inline struct net_bridge_port *br_port_get_rtnl(const struct net_device *
 		rtnl_dereference(dev->rx_handler_data) : NULL;
 }
 
-struct br_cpu_netstats {
-	u64			rx_packets;
-	u64			rx_bytes;
-	u64			tx_packets;
-	u64			tx_bytes;
-	struct u64_stats_sync	syncp;
-};
-
 struct net_bridge
 {
 	spinlock_t			lock;
 	struct list_head		port_list;
 	struct net_device		*dev;
 
-	struct br_cpu_netstats __percpu *stats;
+	struct pcpu_sw_netstats		__percpu *stats;
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
 #ifdef CONFIG_BRIDGE_NETFILTER

commit 31a5b837c2e0d282f36d06a2b96f16d97464fd68
Author: tanxiaojun <tanxiaojun@huawei.com>
Date:   Thu Dec 19 13:28:12 2013 +0800

    bridge: add space before '(/{', after ',', etc.
    
    Spaces required before the open parenthesis '(', before the open
    brace '{', after that ',' and around that '?/:'.
    
    Signed-off-by: Tan Xiaojun <tanxiaojun@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 045d56eaeca2..2e77d923c8ee 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -721,7 +721,7 @@ void br_netfilter_fini(void);
 void br_netfilter_rtable_init(struct net_bridge *);
 #else
 #define br_netfilter_init()	(0)
-#define br_netfilter_fini()	do { } while(0)
+#define br_netfilter_fini()	do { } while (0)
 #define br_netfilter_rtable_init(x)
 #endif
 

commit 859828c0ea476b42f3a93d69d117aaba90994b6f
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Thu Dec 5 16:27:37 2013 +0100

    br: fix use of ->rx_handler_data in code executed on non-rx_handler path
    
    br_stp_rcv() is reached by non-rx_handler path. That means there is no
    guarantee that dev is bridge port and therefore simple NULL check of
    ->rx_handler_data is not enough. There is need to check if dev is really
    bridge port and since only rcu read lock is held here, do it by checking
    ->rx_handler pointer.
    
    Note that synchronize_net() in netdev_rx_handler_unregister() ensures
    this approach as valid.
    
    Introduced originally by:
    commit f350a0a87374418635689471606454abc7beaa3a
      "bridge: use rx_handler_data pointer to store net_bridge_port pointer"
    
    Fixed but not in the best way by:
    commit b5ed54e94d324f17c97852296d61a143f01b227a
      "bridge: fix RCU races with bridge port"
    
    Reintroduced by:
    commit 716ec052d2280d511e10e90ad54a86f5b5d4dcc2
      "bridge: fix NULL pointer deref of br_port_get_rcu"
    
    Please apply to stable trees as well. Thanks.
    
    RH bugzilla reference: https://bugzilla.redhat.com/show_bug.cgi?id=1025770
    
    Reported-by: Laine Stump <laine@redhat.com>
    Debugged-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Acked-by: Michael S. Tsirkin <mst@redhat.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 229d820bdf0b..045d56eaeca2 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -426,6 +426,16 @@ netdev_features_t br_features_recompute(struct net_bridge *br,
 int br_handle_frame_finish(struct sk_buff *skb);
 rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
 
+static inline bool br_rx_handler_check_rcu(const struct net_device *dev)
+{
+	return rcu_dereference(dev->rx_handler) == br_handle_frame;
+}
+
+static inline struct net_bridge_port *br_port_get_check_rcu(const struct net_device *dev)
+{
+	return br_rx_handler_check_rcu(dev) ? br_port_get_rcu(dev) : NULL;
+}
+
 /* br_ioctl.c */
 int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd,

commit 394efd19d5fcae936261bd48e5b33b21897aacf8
Merge: f421436a591d be408cd3e1fe
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 4 13:48:30 2013 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/ethernet/emulex/benet/be.h
            drivers/net/netconsole.c
            net/bridge/br_private.h
    
    Three mostly trivial conflicts.
    
    The net/bridge/br_private.h conflict was a function signature (argument
    addition) change overlapping with the extern removals from Joe Perches.
    
    In drivers/net/netconsole.c we had one change adjusting a printk message
    whilst another changed "printk(KERN_INFO" into "pr_info(".
    
    Lastly, the emulex change was a new inline function addition overlapping
    with Joe Perches's extern removals.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 06499098a02b9ed906a7b6060f2c60fb813918d4
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Mon Oct 28 15:45:07 2013 -0400

    bridge: pass correct vlan id to multicast code
    
    Currently multicast code attempts to extrace the vlan id from
    the skb even when vlan filtering is disabled.  This can lead
    to mdb entries being created with the wrong vlan id.
    Pass the already extracted vlan id to the multicast
    filtering code to make the correct id is used in
    creation as well as lookup.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Acked-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e14c33b42f75..2e8244efb262 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -451,7 +451,8 @@ extern int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __us
 extern unsigned int br_mdb_rehash_seq;
 extern int br_multicast_rcv(struct net_bridge *br,
 			    struct net_bridge_port *port,
-			    struct sk_buff *skb);
+			    struct sk_buff *skb,
+			    u16 vid);
 extern struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
 					       struct sk_buff *skb, u16 vid);
 extern void br_multicast_add_port(struct net_bridge_port *port);
@@ -522,7 +523,8 @@ static inline bool br_multicast_querier_exists(struct net_bridge *br,
 #else
 static inline int br_multicast_rcv(struct net_bridge *br,
 				   struct net_bridge_port *port,
-				   struct sk_buff *skb)
+				   struct sk_buff *skb,
+				   u16 vid)
 {
 	return 0;
 }

commit c3fa32b9764dc45dcf8a2231b1c110abc4a63e0b
Merge: 34d92d5315b6 320437af954c
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Oct 23 16:28:39 2013 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/usb/qmi_wwan.c
            include/net/dst.h
    
    Trivial merge conflicts, both were overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 454594f3b93a49ef568cd190c5af31376b105a7b
Author: Linus Lssing <linus.luessing@web.de>
Date:   Sun Oct 20 00:58:57 2013 +0200

    Revert "bridge: only expire the mdb entry when query is received"
    
    While this commit was a good attempt to fix issues occuring when no
    multicast querier is present, this commit still has two more issues:
    
    1) There are cases where mdb entries do not expire even if there is a
    querier present. The bridge will unnecessarily continue flooding
    multicast packets on the according ports.
    
    2) Never removing an mdb entry could be exploited for a Denial of
    Service by an attacker on the local link, slowly, but steadily eating up
    all memory.
    
    Actually, this commit became obsolete with
    "bridge: disable snooping if there is no querier" (b00589af3b)
    which included fixes for a few more cases.
    
    Therefore reverting the following commits (the commit stated in the
    commit message plus three of its follow up fixes):
    
    ====================
    Revert "bridge: update mdb expiration timer upon reports."
    This reverts commit f144febd93d5ee534fdf23505ab091b2b9088edc.
    Revert "bridge: do not call setup_timer() multiple times"
    This reverts commit 1faabf2aab1fdaa1ace4e8c829d1b9cf7bfec2f1.
    Revert "bridge: fix some kernel warning in multicast timer"
    This reverts commit c7e8e8a8f7a70b343ca1e0f90a31e35ab2d16de1.
    Revert "bridge: only expire the mdb entry when query is received"
    This reverts commit 9f00b2e7cf241fa389733d41b615efdaa2cb0f5b.
    ====================
    
    CC: Cong Wang <amwang@redhat.com>
    Signed-off-by: Linus Lssing <linus.luessing@web.de>
    Reviewed-by: Vlad Yasevich <vyasevich@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 7ca2ae45b2d5..e14c33b42f75 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -126,7 +126,6 @@ struct net_bridge_mdb_entry
 	struct timer_list		timer;
 	struct br_ip			addr;
 	bool				mglist;
-	bool				timer_armed;
 };
 
 struct net_bridge_mdb_htable

commit 348662a1429f95ed2d488c939c324ec152638742
Author: Joe Perches <joe@perches.com>
Date:   Fri Oct 18 13:48:22 2013 -0700

    net: 8021q/bluetooth/bridge/can/ceph: Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index efb57d911569..767c4dad8504 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -344,10 +344,9 @@ static inline int br_is_root_bridge(const struct net_bridge *br)
 }
 
 /* br_device.c */
-extern void br_dev_setup(struct net_device *dev);
-extern void br_dev_delete(struct net_device *dev, struct list_head *list);
-extern netdev_tx_t br_dev_xmit(struct sk_buff *skb,
-			       struct net_device *dev);
+void br_dev_setup(struct net_device *dev);
+void br_dev_delete(struct net_device *dev, struct list_head *list);
+netdev_tx_t br_dev_xmit(struct sk_buff *skb, struct net_device *dev);
 #ifdef CONFIG_NET_POLL_CONTROLLER
 static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 				       struct sk_buff *skb)
@@ -358,8 +357,8 @@ static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 		netpoll_send_skb(np, skb);
 }
 
-extern int br_netpoll_enable(struct net_bridge_port *p, gfp_t gfp);
-extern void br_netpoll_disable(struct net_bridge_port *p);
+int br_netpoll_enable(struct net_bridge_port *p, gfp_t gfp);
+void br_netpoll_disable(struct net_bridge_port *p);
 #else
 static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 				       struct sk_buff *skb)
@@ -377,116 +376,99 @@ static inline void br_netpoll_disable(struct net_bridge_port *p)
 #endif
 
 /* br_fdb.c */
-extern int br_fdb_init(void);
-extern void br_fdb_fini(void);
-extern void br_fdb_flush(struct net_bridge *br);
-extern void br_fdb_changeaddr(struct net_bridge_port *p,
-			      const unsigned char *newaddr);
-extern void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
-extern void br_fdb_cleanup(unsigned long arg);
-extern void br_fdb_delete_by_port(struct net_bridge *br,
-				  const struct net_bridge_port *p, int do_all);
-extern struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
-						 const unsigned char *addr,
-						 __u16 vid);
-extern int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
-extern int br_fdb_fillbuf(struct net_bridge *br, void *buf,
-			  unsigned long count, unsigned long off);
-extern int br_fdb_insert(struct net_bridge *br,
-			 struct net_bridge_port *source,
-			 const unsigned char *addr,
-			 u16 vid);
-extern void br_fdb_update(struct net_bridge *br,
-			  struct net_bridge_port *source,
-			  const unsigned char *addr,
-			  u16 vid);
-extern int fdb_delete_by_addr(struct net_bridge *br, const u8 *addr, u16 vid);
-
-extern int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
-			 struct net_device *dev,
-			 const unsigned char *addr);
-extern int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[],
-		      struct net_device *dev,
-		      const unsigned char *addr,
-		      u16 nlh_flags);
-extern int br_fdb_dump(struct sk_buff *skb,
-		       struct netlink_callback *cb,
-		       struct net_device *dev,
-		       int idx);
+int br_fdb_init(void);
+void br_fdb_fini(void);
+void br_fdb_flush(struct net_bridge *br);
+void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr);
+void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
+void br_fdb_cleanup(unsigned long arg);
+void br_fdb_delete_by_port(struct net_bridge *br,
+			   const struct net_bridge_port *p, int do_all);
+struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
+					  const unsigned char *addr, __u16 vid);
+int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
+int br_fdb_fillbuf(struct net_bridge *br, void *buf, unsigned long count,
+		   unsigned long off);
+int br_fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
+		  const unsigned char *addr, u16 vid);
+void br_fdb_update(struct net_bridge *br, struct net_bridge_port *source,
+		   const unsigned char *addr, u16 vid);
+int fdb_delete_by_addr(struct net_bridge *br, const u8 *addr, u16 vid);
+
+int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
+		  struct net_device *dev, const unsigned char *addr);
+int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[], struct net_device *dev,
+	       const unsigned char *addr, u16 nlh_flags);
+int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb,
+		struct net_device *dev, int idx);
 
 /* br_forward.c */
-extern void br_deliver(const struct net_bridge_port *to,
-		struct sk_buff *skb);
-extern int br_dev_queue_push_xmit(struct sk_buff *skb);
-extern void br_forward(const struct net_bridge_port *to,
+void br_deliver(const struct net_bridge_port *to, struct sk_buff *skb);
+int br_dev_queue_push_xmit(struct sk_buff *skb);
+void br_forward(const struct net_bridge_port *to,
 		struct sk_buff *skb, struct sk_buff *skb0);
-extern int br_forward_finish(struct sk_buff *skb);
-extern void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb,
-			     bool unicast);
-extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
-			     struct sk_buff *skb2, bool unicast);
+int br_forward_finish(struct sk_buff *skb);
+void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb, bool unicast);
+void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
+		      struct sk_buff *skb2, bool unicast);
 
 /* br_if.c */
-extern void br_port_carrier_check(struct net_bridge_port *p);
-extern int br_add_bridge(struct net *net, const char *name);
-extern int br_del_bridge(struct net *net, const char *name);
-extern void br_net_exit(struct net *net);
-extern int br_add_if(struct net_bridge *br,
-	      struct net_device *dev);
-extern int br_del_if(struct net_bridge *br,
-	      struct net_device *dev);
-extern int br_min_mtu(const struct net_bridge *br);
-extern netdev_features_t br_features_recompute(struct net_bridge *br,
-	netdev_features_t features);
+void br_port_carrier_check(struct net_bridge_port *p);
+int br_add_bridge(struct net *net, const char *name);
+int br_del_bridge(struct net *net, const char *name);
+void br_net_exit(struct net *net);
+int br_add_if(struct net_bridge *br, struct net_device *dev);
+int br_del_if(struct net_bridge *br, struct net_device *dev);
+int br_min_mtu(const struct net_bridge *br);
+netdev_features_t br_features_recompute(struct net_bridge *br,
+					netdev_features_t features);
 
 /* br_input.c */
-extern int br_handle_frame_finish(struct sk_buff *skb);
-extern rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
+int br_handle_frame_finish(struct sk_buff *skb);
+rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
 
 /* br_ioctl.c */
-extern int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
-extern int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __user *arg);
+int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd,
+			     void __user *arg);
 
 /* br_multicast.c */
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 extern unsigned int br_mdb_rehash_seq;
-extern int br_multicast_rcv(struct net_bridge *br,
-			    struct net_bridge_port *port,
-			    struct sk_buff *skb);
-extern struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
-					       struct sk_buff *skb, u16 vid);
-extern void br_multicast_add_port(struct net_bridge_port *port);
-extern void br_multicast_del_port(struct net_bridge_port *port);
-extern void br_multicast_enable_port(struct net_bridge_port *port);
-extern void br_multicast_disable_port(struct net_bridge_port *port);
-extern void br_multicast_init(struct net_bridge *br);
-extern void br_multicast_open(struct net_bridge *br);
-extern void br_multicast_stop(struct net_bridge *br);
-extern void br_multicast_deliver(struct net_bridge_mdb_entry *mdst,
-				 struct sk_buff *skb);
-extern void br_multicast_forward(struct net_bridge_mdb_entry *mdst,
-				 struct sk_buff *skb, struct sk_buff *skb2);
-extern int br_multicast_set_router(struct net_bridge *br, unsigned long val);
-extern int br_multicast_set_port_router(struct net_bridge_port *p,
-					unsigned long val);
-extern int br_multicast_toggle(struct net_bridge *br, unsigned long val);
-extern int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
-extern int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
-extern struct net_bridge_mdb_entry *br_mdb_ip_get(
-				struct net_bridge_mdb_htable *mdb,
-				struct br_ip *dst);
-extern struct net_bridge_mdb_entry *br_multicast_new_group(struct net_bridge *br,
-				struct net_bridge_port *port, struct br_ip *group);
-extern void br_multicast_free_pg(struct rcu_head *head);
-extern struct net_bridge_port_group *br_multicast_new_port_group(
-				struct net_bridge_port *port,
-				struct br_ip *group,
-				struct net_bridge_port_group __rcu *next,
-				unsigned char state);
-extern void br_mdb_init(void);
-extern void br_mdb_uninit(void);
-extern void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
-			  struct br_ip *group, int type);
+int br_multicast_rcv(struct net_bridge *br, struct net_bridge_port *port,
+		     struct sk_buff *skb);
+struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
+					struct sk_buff *skb, u16 vid);
+void br_multicast_add_port(struct net_bridge_port *port);
+void br_multicast_del_port(struct net_bridge_port *port);
+void br_multicast_enable_port(struct net_bridge_port *port);
+void br_multicast_disable_port(struct net_bridge_port *port);
+void br_multicast_init(struct net_bridge *br);
+void br_multicast_open(struct net_bridge *br);
+void br_multicast_stop(struct net_bridge *br);
+void br_multicast_deliver(struct net_bridge_mdb_entry *mdst,
+			  struct sk_buff *skb);
+void br_multicast_forward(struct net_bridge_mdb_entry *mdst,
+			  struct sk_buff *skb, struct sk_buff *skb2);
+int br_multicast_set_router(struct net_bridge *br, unsigned long val);
+int br_multicast_set_port_router(struct net_bridge_port *p, unsigned long val);
+int br_multicast_toggle(struct net_bridge *br, unsigned long val);
+int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
+int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
+struct net_bridge_mdb_entry *
+br_mdb_ip_get(struct net_bridge_mdb_htable *mdb, struct br_ip *dst);
+struct net_bridge_mdb_entry *
+br_multicast_new_group(struct net_bridge *br, struct net_bridge_port *port,
+		       struct br_ip *group);
+void br_multicast_free_pg(struct rcu_head *head);
+struct net_bridge_port_group *
+br_multicast_new_port_group(struct net_bridge_port *port, struct br_ip *group,
+			    struct net_bridge_port_group __rcu *next,
+			    unsigned char state);
+void br_mdb_init(void);
+void br_mdb_uninit(void);
+void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
+		   struct br_ip *group, int type);
 
 #define mlock_dereference(X, br) \
 	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
@@ -591,22 +573,21 @@ static inline void br_mdb_uninit(void)
 
 /* br_vlan.c */
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
-extern bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
-			       struct sk_buff *skb, u16 *vid);
-extern bool br_allowed_egress(struct net_bridge *br,
-			      const struct net_port_vlans *v,
-			      const struct sk_buff *skb);
-extern struct sk_buff *br_handle_vlan(struct net_bridge *br,
-				      const struct net_port_vlans *v,
-				      struct sk_buff *skb);
-extern int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
-extern int br_vlan_delete(struct net_bridge *br, u16 vid);
-extern void br_vlan_flush(struct net_bridge *br);
-extern int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
-extern int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
-extern int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
-extern void nbp_vlan_flush(struct net_bridge_port *port);
-extern bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
+bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
+			struct sk_buff *skb, u16 *vid);
+bool br_allowed_egress(struct net_bridge *br, const struct net_port_vlans *v,
+		       const struct sk_buff *skb);
+struct sk_buff *br_handle_vlan(struct net_bridge *br,
+			       const struct net_port_vlans *v,
+			       struct sk_buff *skb);
+int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
+int br_vlan_delete(struct net_bridge *br, u16 vid);
+void br_vlan_flush(struct net_bridge *br);
+int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
+int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
+int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
+void nbp_vlan_flush(struct net_bridge_port *port);
+bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
 
 static inline struct net_port_vlans *br_get_vlan_info(
 						const struct net_bridge *br)
@@ -727,9 +708,9 @@ static inline u16 br_get_pvid(const struct net_port_vlans *v)
 
 /* br_netfilter.c */
 #ifdef CONFIG_BRIDGE_NETFILTER
-extern int br_netfilter_init(void);
-extern void br_netfilter_fini(void);
-extern void br_netfilter_rtable_init(struct net_bridge *);
+int br_netfilter_init(void);
+void br_netfilter_fini(void);
+void br_netfilter_rtable_init(struct net_bridge *);
 #else
 #define br_netfilter_init()	(0)
 #define br_netfilter_fini()	do { } while(0)
@@ -737,43 +718,39 @@ extern void br_netfilter_rtable_init(struct net_bridge *);
 #endif
 
 /* br_stp.c */
-extern void br_log_state(const struct net_bridge_port *p);
-extern struct net_bridge_port *br_get_port(struct net_bridge *br,
-					   u16 port_no);
-extern void br_init_port(struct net_bridge_port *p);
-extern void br_become_designated_port(struct net_bridge_port *p);
+void br_log_state(const struct net_bridge_port *p);
+struct net_bridge_port *br_get_port(struct net_bridge *br, u16 port_no);
+void br_init_port(struct net_bridge_port *p);
+void br_become_designated_port(struct net_bridge_port *p);
 
-extern void __br_set_forward_delay(struct net_bridge *br, unsigned long t);
-extern int br_set_forward_delay(struct net_bridge *br, unsigned long x);
-extern int br_set_hello_time(struct net_bridge *br, unsigned long x);
-extern int br_set_max_age(struct net_bridge *br, unsigned long x);
+void __br_set_forward_delay(struct net_bridge *br, unsigned long t);
+int br_set_forward_delay(struct net_bridge *br, unsigned long x);
+int br_set_hello_time(struct net_bridge *br, unsigned long x);
+int br_set_max_age(struct net_bridge *br, unsigned long x);
 
 
 /* br_stp_if.c */
-extern void br_stp_enable_bridge(struct net_bridge *br);
-extern void br_stp_disable_bridge(struct net_bridge *br);
-extern void br_stp_set_enabled(struct net_bridge *br, unsigned long val);
-extern void br_stp_enable_port(struct net_bridge_port *p);
-extern void br_stp_disable_port(struct net_bridge_port *p);
-extern bool br_stp_recalculate_bridge_id(struct net_bridge *br);
-extern void br_stp_change_bridge_id(struct net_bridge *br, const unsigned char *a);
-extern void br_stp_set_bridge_priority(struct net_bridge *br,
-				       u16 newprio);
-extern int br_stp_set_port_priority(struct net_bridge_port *p,
-				    unsigned long newprio);
-extern int br_stp_set_path_cost(struct net_bridge_port *p,
-				unsigned long path_cost);
-extern ssize_t br_show_bridge_id(char *buf, const struct bridge_id *id);
+void br_stp_enable_bridge(struct net_bridge *br);
+void br_stp_disable_bridge(struct net_bridge *br);
+void br_stp_set_enabled(struct net_bridge *br, unsigned long val);
+void br_stp_enable_port(struct net_bridge_port *p);
+void br_stp_disable_port(struct net_bridge_port *p);
+bool br_stp_recalculate_bridge_id(struct net_bridge *br);
+void br_stp_change_bridge_id(struct net_bridge *br, const unsigned char *a);
+void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio);
+int br_stp_set_port_priority(struct net_bridge_port *p, unsigned long newprio);
+int br_stp_set_path_cost(struct net_bridge_port *p, unsigned long path_cost);
+ssize_t br_show_bridge_id(char *buf, const struct bridge_id *id);
 
 /* br_stp_bpdu.c */
 struct stp_proto;
-extern void br_stp_rcv(const struct stp_proto *proto, struct sk_buff *skb,
-		       struct net_device *dev);
+void br_stp_rcv(const struct stp_proto *proto, struct sk_buff *skb,
+		struct net_device *dev);
 
 /* br_stp_timer.c */
-extern void br_stp_timer_init(struct net_bridge *br);
-extern void br_stp_port_timer_init(struct net_bridge_port *p);
-extern unsigned long br_timer_value(const struct timer_list *timer);
+void br_stp_timer_init(struct net_bridge *br);
+void br_stp_port_timer_init(struct net_bridge_port *p);
+unsigned long br_timer_value(const struct timer_list *timer);
 
 /* br.c */
 #if IS_ENABLED(CONFIG_ATM_LANE)
@@ -782,23 +759,23 @@ extern int (*br_fdb_test_addr_hook)(struct net_device *dev, unsigned char *addr)
 
 /* br_netlink.c */
 extern struct rtnl_link_ops br_link_ops;
-extern int br_netlink_init(void);
-extern void br_netlink_fini(void);
-extern void br_ifinfo_notify(int event, struct net_bridge_port *port);
-extern int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg);
-extern int br_dellink(struct net_device *dev, struct nlmsghdr *nlmsg);
-extern int br_getlink(struct sk_buff *skb, u32 pid, u32 seq,
-		      struct net_device *dev, u32 filter_mask);
+int br_netlink_init(void);
+void br_netlink_fini(void);
+void br_ifinfo_notify(int event, struct net_bridge_port *port);
+int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg);
+int br_dellink(struct net_device *dev, struct nlmsghdr *nlmsg);
+int br_getlink(struct sk_buff *skb, u32 pid, u32 seq, struct net_device *dev,
+	       u32 filter_mask);
 
 #ifdef CONFIG_SYSFS
 /* br_sysfs_if.c */
 extern const struct sysfs_ops brport_sysfs_ops;
-extern int br_sysfs_addif(struct net_bridge_port *p);
-extern int br_sysfs_renameif(struct net_bridge_port *p);
+int br_sysfs_addif(struct net_bridge_port *p);
+int br_sysfs_renameif(struct net_bridge_port *p);
 
 /* br_sysfs_br.c */
-extern int br_sysfs_addbr(struct net_device *dev);
-extern void br_sysfs_delbr(struct net_device *dev);
+int br_sysfs_addbr(struct net_device *dev);
+void br_sysfs_delbr(struct net_device *dev);
 
 #else
 

commit d1c6c708c4da9d104e0b7c116654cb449bff9b5f
Author: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
Date:   Wed Oct 16 17:07:15 2013 +0900

    bridge: Fix the way the PVID is referenced
    
    We are using the VLAN_TAG_PRESENT bit to detect whether the PVID is
    set or not at br_get_pvid(), while we don't care about the bit in
    adding/deleting the PVID, which makes it impossible to forward any
    incomming untagged frame with vlan_filtering enabled.
    
    Since vid 0 cannot be used for the PVID, we can use vid 0 to indicate
    that the PVID is not set, which is slightly more efficient than using
    the VLAN_TAG_PRESENT.
    
    Fix the problem by getting rid of using the VLAN_TAG_PRESENT.
    
    Signed-off-by: Toshiaki Makita <makita.toshiaki@lab.ntt.co.jp>
    Reviewed-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index efb57d911569..7ca2ae45b2d5 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -643,9 +643,7 @@ static inline u16 br_get_pvid(const struct net_port_vlans *v)
 	 * vid wasn't set
 	 */
 	smp_rmb();
-	return (v->pvid & VLAN_TAG_PRESENT) ?
-			(v->pvid & ~VLAN_TAG_PRESENT) :
-			VLAN_N_VID;
+	return v->pvid ?: VLAN_N_VID;
 }
 
 #else

commit 716ec052d2280d511e10e90ad54a86f5b5d4dcc2
Author: Hong Zhiguo <zhiguohong@tencent.com>
Date:   Sat Sep 14 22:42:28 2013 +0800

    bridge: fix NULL pointer deref of br_port_get_rcu
    
    The NULL deref happens when br_handle_frame is called between these
    2 lines of del_nbp:
            dev->priv_flags &= ~IFF_BRIDGE_PORT;
            /* --> br_handle_frame is called at this time */
            netdev_rx_handler_unregister(dev);
    
    In br_handle_frame the return of br_port_get_rcu(dev) is dereferenced
    without check but br_port_get_rcu(dev) returns NULL if:
            !(dev->priv_flags & IFF_BRIDGE_PORT)
    
    Eric Dumazet pointed out the testing of IFF_BRIDGE_PORT is not necessary
    here since we're in rcu_read_lock and we have synchronize_net() in
    netdev_rx_handler_unregister. So remove the testing of IFF_BRIDGE_PORT
    and by the previous patch, make sure br_port_get_rcu is called in
    bridging code.
    
    Signed-off-by: Hong Zhiguo <zhiguohong@tencent.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index dd583177cba4..efb57d911569 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -202,10 +202,7 @@ struct net_bridge_port
 
 static inline struct net_bridge_port *br_port_get_rcu(const struct net_device *dev)
 {
-	struct net_bridge_port *port =
-			rcu_dereference_rtnl(dev->rx_handler_data);
-
-	return br_port_exists(dev) ? port : NULL;
+	return rcu_dereference(dev->rx_handler_data);
 }
 
 static inline struct net_bridge_port *br_port_get_rtnl(const struct net_device *dev)

commit 1fb1754a8c70d69ab480763c423e0a74369c4a67
Author: Hong Zhiguo <zhiguohong@tencent.com>
Date:   Sat Sep 14 22:42:27 2013 +0800

    bridge: use br_port_get_rtnl within rtnl lock
    
    current br_port_get_rcu is problematic in bridging path
    (NULL deref). Change these calls in netlink path first.
    
    Signed-off-by: Hong Zhiguo <zhiguohong@tencent.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index cda83158a21c..dd583177cba4 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -208,7 +208,7 @@ static inline struct net_bridge_port *br_port_get_rcu(const struct net_device *d
 	return br_port_exists(dev) ? port : NULL;
 }
 
-static inline struct net_bridge_port *br_port_get_rtnl(struct net_device *dev)
+static inline struct net_bridge_port *br_port_get_rtnl(const struct net_device *dev)
 {
 	return br_port_exists(dev) ?
 		rtnl_dereference(dev->rx_handler_data) : NULL;

commit be4f154d5ef0ca147ab6bcd38857a774133f5450
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Thu Sep 12 17:12:05 2013 +1000

    bridge: Clamp forward_delay when enabling STP
    
    At some point limits were added to forward_delay.  However, the
    limits are only enforced when STP is enabled.  This created a
    scenario where you could have a value outside the allowed range
    while STP is disabled, which then stuck around even after STP
    is enabled.
    
    This patch fixes this by clamping the value when we enable STP.
    
    I had to move the locking around a bit to ensure that there is
    no window where someone could insert a value outside the range
    while we're in the middle of enabling STP.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    
    Cheers,
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 598cb0b333c6..cda83158a21c 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -746,6 +746,7 @@ extern struct net_bridge_port *br_get_port(struct net_bridge *br,
 extern void br_init_port(struct net_bridge_port *p);
 extern void br_become_designated_port(struct net_bridge_port *p);
 
+extern void __br_set_forward_delay(struct net_bridge *br, unsigned long t);
 extern int br_set_forward_delay(struct net_bridge *br, unsigned long x);
 extern int br_set_hello_time(struct net_bridge *br, unsigned long x);
 extern int br_set_max_age(struct net_bridge *br, unsigned long x);

commit 06c54055bebf919249aa1eb68312887c3cfe77b4
Merge: 1a5bbfc3d6b7 e2e5c4c07caf
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Sep 5 14:58:52 2013 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/ethernet/stmicro/stmmac/stmmac_platform.c
            net/bridge/br_multicast.c
            net/ipv6/sit.c
    
    The conflicts were minor:
    
    1) sit.c changes overlap with change to ip_tunnel_xmit() signature.
    
    2) br_multicast.c had an overlap between computing max_delay using
       msecs_to_jiffies and turning MLDV2_MRC() into an inline function
       with a name using lowercase instead of uppercase letters.
    
    3) stmmac had two overlapping changes, one which conditionally allocated
       and hooked up a dma_cfg based upon the presence of the pbl OF property,
       and another one handling store-and-forward DMA made.  The latter of
       which should not go into the new of_find_property() basic block.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 3c3769e63301fd92fcaf51870c371583dd0282ce
Author: Linus Lssing <linus.luessing@web.de>
Date:   Wed Sep 4 02:13:39 2013 +0200

    bridge: apply multicast snooping to IPv6 link-local, too
    
    The multicast snooping code should have matured enough to be safely
    applicable to IPv6 link-local multicast addresses (excluding the
    link-local all nodes address, ff02::1), too.
    
    Signed-off-by: Linus Lssing <linus.luessing@web.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index d41283c57952..89b2949be02f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -476,16 +476,6 @@ extern void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
 #define mlock_dereference(X, br) \
 	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
 
-#if IS_ENABLED(CONFIG_IPV6)
-#include <net/addrconf.h>
-static inline int ipv6_is_transient_multicast(const struct in6_addr *addr)
-{
-	if (ipv6_addr_is_multicast(addr) && IPV6_ADDR_MC_FLAG_TRANSIENT(addr))
-		return 1;
-	return 0;
-}
-#endif
-
 static inline bool br_multicast_is_router(struct net_bridge *br)
 {
 	return br->multicast_router == 2 ||

commit cc0fdd802859eaeb00e1c87dbb655594bed2844c
Author: Linus Lssing <linus.luessing@web.de>
Date:   Fri Aug 30 17:28:17 2013 +0200

    bridge: separate querier and query timer into IGMP/IPv4 and MLD/IPv6 ones
    
    Currently we would still potentially suffer multicast packet loss if there
    is just either an IGMP or an MLD querier: For the former case, we would
    possibly drop IPv6 multicast packets, for the latter IPv4 ones. This is
    because we are currently assuming that if either an IGMP or MLD querier
    is present that the other one is present, too.
    
    This patch makes the behaviour and fix added in
    "bridge: disable snooping if there is no querier" (b00589af3b04)
    to also work if there is either just an IGMP or an MLD querier on the
    link: It refines the deactivation of the snooping to be protocol
    specific by using separate timers for the snooped IGMP and MLD queries
    as well as separate timers for our internal IGMP and MLD queriers.
    
    Signed-off-by: Linus Lssing <linus.luessing@web.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2f7da41851bf..263ba9034468 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -66,6 +66,20 @@ struct br_ip
 	__u16		vid;
 };
 
+#ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+/* our own querier */
+struct bridge_mcast_query {
+	struct timer_list	timer;
+	u32			startup_sent;
+};
+
+/* other querier */
+struct bridge_mcast_querier {
+	struct timer_list		timer;
+	unsigned long			delay_time;
+};
+#endif
+
 struct net_port_vlans {
 	u16				port_idx;
 	u16				pvid;
@@ -162,10 +176,12 @@ struct net_bridge_port
 #define BR_FLOOD		0x00000040
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
-	u32				multicast_startup_queries_sent;
+	struct bridge_mcast_query	ip4_query;
+#if IS_ENABLED(CONFIG_IPV6)
+	struct bridge_mcast_query	ip6_query;
+#endif /* IS_ENABLED(CONFIG_IPV6) */
 	unsigned char			multicast_router;
 	struct timer_list		multicast_router_timer;
-	struct timer_list		multicast_query_timer;
 	struct hlist_head		mglist;
 	struct hlist_node		rlist;
 #endif
@@ -258,7 +274,6 @@ struct net_bridge
 	u32				hash_max;
 
 	u32				multicast_last_member_count;
-	u32				multicast_startup_queries_sent;
 	u32				multicast_startup_query_count;
 
 	unsigned long			multicast_last_member_interval;
@@ -267,15 +282,18 @@ struct net_bridge
 	unsigned long			multicast_query_interval;
 	unsigned long			multicast_query_response_interval;
 	unsigned long			multicast_startup_query_interval;
-	unsigned long			multicast_querier_delay_time;
 
 	spinlock_t			multicast_lock;
 	struct net_bridge_mdb_htable __rcu *mdb;
 	struct hlist_head		router_list;
 
 	struct timer_list		multicast_router_timer;
-	struct timer_list		multicast_querier_timer;
-	struct timer_list		multicast_query_timer;
+	struct bridge_mcast_querier	ip4_querier;
+	struct bridge_mcast_query	ip4_query;
+#if IS_ENABLED(CONFIG_IPV6)
+	struct bridge_mcast_querier	ip6_querier;
+	struct bridge_mcast_query	ip6_query;
+#endif /* IS_ENABLED(CONFIG_IPV6) */
 #endif
 
 	struct timer_list		hello_timer;
@@ -503,11 +521,27 @@ static inline bool br_multicast_is_router(struct net_bridge *br)
 		timer_pending(&br->multicast_router_timer));
 }
 
-static inline bool br_multicast_querier_exists(struct net_bridge *br)
+static inline bool
+__br_multicast_querier_exists(struct net_bridge *br,
+			      struct bridge_mcast_querier *querier)
+{
+	return time_is_before_jiffies(querier->delay_time) &&
+	       (br->multicast_querier || timer_pending(&querier->timer));
+}
+
+static inline bool br_multicast_querier_exists(struct net_bridge *br,
+					       struct ethhdr *eth)
 {
-	return time_is_before_jiffies(br->multicast_querier_delay_time) &&
-	       (br->multicast_querier ||
-		timer_pending(&br->multicast_querier_timer));
+	switch (eth->h_proto) {
+	case (htons(ETH_P_IP)):
+		return __br_multicast_querier_exists(br, &br->ip4_querier);
+#if IS_ENABLED(CONFIG_IPV6)
+	case (htons(ETH_P_IPV6)):
+		return __br_multicast_querier_exists(br, &br->ip6_querier);
+#endif
+	default:
+		return false;
+	}
 }
 #else
 static inline int br_multicast_rcv(struct net_bridge *br,
@@ -565,7 +599,8 @@ static inline bool br_multicast_is_router(struct net_bridge *br)
 {
 	return 0;
 }
-static inline bool br_multicast_querier_exists(struct net_bridge *br)
+static inline bool br_multicast_querier_exists(struct net_bridge *br,
+					       struct ethhdr *eth)
 {
 	return false;
 }

commit 762a3d89ebf5873f71b3839449ac6562049ef1ce
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Sun Aug 4 17:19:38 2013 -0700

    bridge: fix rcu check warning in multicast port group
    
    Use of RCU here with out marked pointer and function doesn't match prototype
    with sparse.
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1514c9f4f102..d41283c57952 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -466,7 +466,7 @@ extern void br_multicast_free_pg(struct rcu_head *head);
 extern struct net_bridge_port_group *br_multicast_new_port_group(
 				struct net_bridge_port *port,
 				struct br_ip *group,
-				struct net_bridge_port_group *next,
+				struct net_bridge_port_group __rcu *next,
 				unsigned char state);
 extern void br_mdb_init(void);
 extern void br_mdb_uninit(void);

commit 0e76a3a587fc7abda2badf249053b427baad255e
Merge: fba3679d3451 72a67a94bcba
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Aug 3 21:36:46 2013 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Merge net into net-next to setup some infrastructure Eric
    Dumazet needs for usbnet changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b00589af3b04736376f24625ab0b394642e89e29
Author: Linus Lssing <linus.luessing@web.de>
Date:   Thu Aug 1 01:06:20 2013 +0200

    bridge: disable snooping if there is no querier
    
    If there is no querier on a link then we won't get periodic reports and
    therefore won't be able to learn about multicast listeners behind ports,
    potentially leading to lost multicast packets, especially for multicast
    listeners that joined before the creation of the bridge.
    
    These lost multicast packets can appear since c5c23260594
    ("bridge: Add multicast_querier toggle and disable queries by default")
    in particular.
    
    With this patch we are flooding multicast packets if our querier is
    disabled and if we didn't detect any other querier.
    
    A grace period of the Maximum Response Delay of the querier is added to
    give multicast responses enough time to arrive and to be learned from
    before disabling the flooding behaviour again.
    
    Signed-off-by: Linus Lssing <linus.luessing@web.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3be89b3ce17b..2f7da41851bf 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -267,6 +267,7 @@ struct net_bridge
 	unsigned long			multicast_query_interval;
 	unsigned long			multicast_query_response_interval;
 	unsigned long			multicast_startup_query_interval;
+	unsigned long			multicast_querier_delay_time;
 
 	spinlock_t			multicast_lock;
 	struct net_bridge_mdb_htable __rcu *mdb;
@@ -501,6 +502,13 @@ static inline bool br_multicast_is_router(struct net_bridge *br)
 	       (br->multicast_router == 1 &&
 		timer_pending(&br->multicast_router_timer));
 }
+
+static inline bool br_multicast_querier_exists(struct net_bridge *br)
+{
+	return time_is_before_jiffies(br->multicast_querier_delay_time) &&
+	       (br->multicast_querier ||
+		timer_pending(&br->multicast_querier_timer));
+}
 #else
 static inline int br_multicast_rcv(struct net_bridge *br,
 				   struct net_bridge_port *port,
@@ -557,6 +565,10 @@ static inline bool br_multicast_is_router(struct net_bridge *br)
 {
 	return 0;
 }
+static inline bool br_multicast_querier_exists(struct net_bridge *br)
+{
+	return false;
+}
 static inline void br_mdb_init(void)
 {
 }

commit 93d8bf9fb8f39d6d3e461db60f883d9f81006159
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Wed Jul 24 11:51:41 2013 -0700

    bridge: cleanup netpoll code
    
    This started out with fixing a sparse warning, then I realized that
    the wrapper function br_netpoll_info could just be collapsed away
    by rolling it into the enable code.
    
    Also, eliminate unnecessary goto's
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Reviewed-by: Jiri Pirko <jiri@resnulli.us>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3be89b3ce17b..43347f129943 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -333,11 +333,6 @@ extern void br_dev_delete(struct net_device *dev, struct list_head *list);
 extern netdev_tx_t br_dev_xmit(struct sk_buff *skb,
 			       struct net_device *dev);
 #ifdef CONFIG_NET_POLL_CONTROLLER
-static inline struct netpoll_info *br_netpoll_info(struct net_bridge *br)
-{
-	return br->dev->npinfo;
-}
-
 static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 				       struct sk_buff *skb)
 {
@@ -350,11 +345,6 @@ static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 extern int br_netpoll_enable(struct net_bridge_port *p, gfp_t gfp);
 extern void br_netpoll_disable(struct net_bridge_port *p);
 #else
-static inline struct netpoll_info *br_netpoll_info(struct net_bridge *br)
-{
-	return NULL;
-}
-
 static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 				       struct sk_buff *skb)
 {

commit 867a59436fc35593ae0e0efcd56cc6d2f8506586
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Jun 5 10:08:01 2013 -0400

    bridge: Add a flag to control unicast packet flood.
    
    Add a flag to control flood of unicast traffic.  By default, flood is
    on and the bridge will flood unicast traffic if it doesn't know
    the destination.  When the flag is turned off, unicast traffic
    without an FDB will not be forwarded to the specified port.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Reviewed-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 04d7f43508f7..3be89b3ce17b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -159,6 +159,7 @@ struct net_bridge_port
 #define BR_MULTICAST_FAST_LEAVE	0x00000008
 #define BR_ADMIN_COST		0x00000010
 #define BR_LEARNING		0x00000020
+#define BR_FLOOD		0x00000040
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	u32				multicast_startup_queries_sent;
@@ -414,9 +415,10 @@ extern int br_dev_queue_push_xmit(struct sk_buff *skb);
 extern void br_forward(const struct net_bridge_port *to,
 		struct sk_buff *skb, struct sk_buff *skb0);
 extern int br_forward_finish(struct sk_buff *skb);
-extern void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb);
+extern void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb,
+			     bool unicast);
 extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
-			     struct sk_buff *skb2);
+			     struct sk_buff *skb2, bool unicast);
 
 /* br_if.c */
 extern void br_port_carrier_check(struct net_bridge_port *p);

commit 9ba18891f75535eca3ef53138b48970eb60f5255
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Jun 5 10:08:00 2013 -0400

    bridge: Add flag to control mac learning.
    
    Allow user to control whether mac learning is enabled on the port.
    By default, mac learning is enabled.  Disabling mac learning will
    cause new dynamic FDB entries to not be created for a particular port.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1b0ac95a5c37..04d7f43508f7 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -158,6 +158,7 @@ struct net_bridge_port
 #define BR_ROOT_BLOCK		0x00000004
 #define BR_MULTICAST_FAST_LEAVE	0x00000008
 #define BR_ADMIN_COST		0x00000010
+#define BR_LEARNING		0x00000020
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	u32				multicast_startup_queries_sent;

commit 9f00b2e7cf241fa389733d41b615efdaa2cb0f5b
Author: Cong Wang <amwang@redhat.com>
Date:   Tue May 21 21:52:55 2013 +0000

    bridge: only expire the mdb entry when query is received
    
    Currently we arm the expire timer when the mdb entry is added,
    however, this causes problem when there is no querier sent
    out after that.
    
    So we should only arm the timer when a corresponding query is
    received, as suggested by Herbert.
    
    And he also mentioned "if there is no querier then group
    subscriptions shouldn't expire. There has to be at least one querier
    in the network for this thing to work.  Otherwise it just degenerates
    into a non-snooping switch, which is OK."
    
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Adam Baker <linux@baker-net.org.uk>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e260710a01d4..1b0ac95a5c37 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -112,6 +112,7 @@ struct net_bridge_mdb_entry
 	struct timer_list		timer;
 	struct br_ip			addr;
 	bool				mglist;
+	bool				timer_armed;
 };
 
 struct net_bridge_mdb_htable

commit 1c8ad5bfa2be5025b0c81e3c2decd0574d453ab1
Author: Cong Wang <amwang@redhat.com>
Date:   Tue May 21 21:52:54 2013 +0000

    bridge: use the bridge IP addr as source addr for querier
    
    Quote from Adam:
    "If it is believed that the use of 0.0.0.0
    as the IP address is what is causing strange behaviour on other devices
    then is there a good reason that a bridge rather than a router shouldn't
    be the active querier? If not then using the bridge IP address and
    having the querier enabled by default may be a reasonable solution
    (provided that our querier obeys the election rules and shuts up if it
    sees a query from a lower IP address that isn't 0.0.0.0). Just because a
    device is the elected querier for IGMP doesn't appear to mean it is
    required to perform any other routing functions."
    
    And introduce a new troggle for it, as suggested by Herbert.
    
    Suggested-by: Adam Baker <linux@baker-net.org.uk>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Adam Baker <linux@baker-net.org.uk>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index d2c043a857b6..e260710a01d4 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -249,6 +249,7 @@ struct net_bridge
 
 	u8				multicast_disabled:1;
 	u8				multicast_querier:1;
+	u8				multicast_query_use_ifaddr:1;
 
 	u32				hash_elasticity;
 	u32				hash_max;

commit 8f3359bdc83f1abb1989e0817ab0e0b18667c828
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Sat Apr 13 14:06:07 2013 +0000

    bridge: make user modified path cost sticky
    
    Keep a STP port path cost value if it was set by a user.
    Don't replace it with the link-speed based path cost
    whenever the link goes down and comes back up.
    
    Reported-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3cbf5beb3d4b..d2c043a857b6 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -156,6 +156,7 @@ struct net_bridge_port
 #define BR_BPDU_GUARD           0x00000002
 #define BR_ROOT_BLOCK		0x00000004
 #define BR_MULTICAST_FAST_LEAVE	0x00000008
+#define BR_ADMIN_COST		0x00000010
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	u32				multicast_startup_queries_sent;

commit fbca58a2242ef2b84049365786d501ee512aefcf
Author: Cong Wang <amwang@redhat.com>
Date:   Thu Mar 7 03:05:33 2013 +0000

    bridge: add missing vid to br_mdb_get()
    
    Obviously, vid should be considered when searching for multicast
    group.
    
    Cc: Vlad Yasevich <vyasevic@redhat.com>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Acked-by: Vlad Yasevich <vyasevich@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 6d314c4e6bcb..3cbf5beb3d4b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -442,7 +442,7 @@ extern int br_multicast_rcv(struct net_bridge *br,
 			    struct net_bridge_port *port,
 			    struct sk_buff *skb);
 extern struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
-					       struct sk_buff *skb);
+					       struct sk_buff *skb, u16 vid);
 extern void br_multicast_add_port(struct net_bridge_port *port);
 extern void br_multicast_del_port(struct net_bridge_port *port);
 extern void br_multicast_enable_port(struct net_bridge_port *port);
@@ -504,7 +504,7 @@ static inline int br_multicast_rcv(struct net_bridge *br,
 }
 
 static inline struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
-						      struct sk_buff *skb)
+						      struct sk_buff *skb, u16 vid)
 {
 	return NULL;
 }

commit 35e03f3a0275a1ba57e432d7c948cf6f70fbb37a
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:20 2013 +0000

    bridge: Separate egress policy bitmap
    
    Add an ability to configure a separate "untagged" egress
    policy to the VLAN information of the bridge.  This superseeds PVID
    policy and makes PVID ingress-only.  The policy is configured with a
    new flag and is represented as a port bitmap per vlan.  Egress frames
    with a VLAN id in "untagged" policy bitmap would egress
    the port without VLAN header.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 32ecfa4ef47f..6d314c4e6bcb 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -75,6 +75,7 @@ struct net_port_vlans {
 	}				parent;
 	struct rcu_head			rcu;
 	unsigned long			vlan_bitmap[BR_VLAN_BITMAP_LEN];
+	unsigned long			untagged_bitmap[BR_VLAN_BITMAP_LEN];
 	u16				num_vlans;
 };
 

commit bc9a25d21ef8bad30e259af5114ccfb845c066db
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:19 2013 +0000

    bridge: Add vlan support for local fdb entries
    
    When VLAN is added to the port, a local fdb entry for that port
    (the entry with the mac address of the port) is added for that
    VLAN.  This way we can correctly determine if the traffic
    is for the bridge itself.  If the address of the port changes,
    we try to change all the local fdb entries we have for that port.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 799dbb37e5a2..32ecfa4ef47f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -382,11 +382,13 @@ extern int br_fdb_fillbuf(struct net_bridge *br, void *buf,
 			  unsigned long count, unsigned long off);
 extern int br_fdb_insert(struct net_bridge *br,
 			 struct net_bridge_port *source,
-			 const unsigned char *addr);
+			 const unsigned char *addr,
+			 u16 vid);
 extern void br_fdb_update(struct net_bridge *br,
 			  struct net_bridge_port *source,
 			  const unsigned char *addr,
 			  u16 vid);
+extern int fdb_delete_by_addr(struct net_bridge *br, const u8 *addr, u16 vid);
 
 extern int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 			 struct net_device *dev,
@@ -573,6 +575,7 @@ extern int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 extern int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 extern int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 extern void nbp_vlan_flush(struct net_bridge_port *port);
+extern bool nbp_vlan_find(struct net_bridge_port *port, u16 vid);
 
 static inline struct net_port_vlans *br_get_vlan_info(
 						const struct net_bridge *br)
@@ -676,6 +679,11 @@ static inline struct net_port_vlans *nbp_get_vlan_info(
 	return NULL;
 }
 
+static inline bool nbp_vlan_find(struct net_bridge_port *port, u16 vid)
+{
+	return false;
+}
+
 static inline u16 br_vlan_get_tag(const struct sk_buff *skb, u16 *tag)
 {
 	return 0;

commit 1690be63a27b20ae65c792729a44f5970561ffa4
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:18 2013 +0000

    bridge: Add vlan support to static neighbors
    
    When a user adds bridge neighbors, allow him to specify VLAN id.
    If the VLAN id is not specified, the neighbor will be added
    for VLANs currently in the ports filter list.  If no VLANs are
    configured on the port, we use vlan 0 and only add 1 entry.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Acked-by: Jitendra Kalsaria <jitendra.kalsaria@qlogic.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 22915c8e9961..799dbb37e5a2 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -388,7 +388,7 @@ extern void br_fdb_update(struct net_bridge *br,
 			  const unsigned char *addr,
 			  u16 vid);
 
-extern int br_fdb_delete(struct ndmsg *ndm,
+extern int br_fdb_delete(struct ndmsg *ndm, struct nlattr *tb[],
 			 struct net_device *dev,
 			 const unsigned char *addr);
 extern int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[],
@@ -577,13 +577,13 @@ extern void nbp_vlan_flush(struct net_bridge_port *port);
 static inline struct net_port_vlans *br_get_vlan_info(
 						const struct net_bridge *br)
 {
-	return rcu_dereference(br->vlan_info);
+	return rcu_dereference_rtnl(br->vlan_info);
 }
 
 static inline struct net_port_vlans *nbp_get_vlan_info(
 						const struct net_bridge_port *p)
 {
-	return rcu_dereference(p->vlan_info);
+	return rcu_dereference_rtnl(p->vlan_info);
 }
 
 /* Since bridge now depends on 8021Q module, but the time bridge sees the

commit b0e9a30dd669a844bb4f74515f8bcd307018ffd0
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:17 2013 +0000

    bridge: Add vlan id to multicast groups
    
    Add vlan_id to multicasts groups so that we know which vlan
    each group belongs to and can correctly forward to appropriate vlan.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f4ae87b5aa6e..22915c8e9961 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -63,6 +63,7 @@ struct br_ip
 #endif
 	} u;
 	__be16		proto;
+	__u16		vid;
 };
 
 struct net_port_vlans {

commit 2ba071ecb6d41ce172f9ccb3996f28cb337b3576
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:16 2013 +0000

    bridge: Add vlan to unicast fdb entries
    
    This patch adds vlan to unicast fdb entries that are created for
    learned addresses (not the manually configured ones).  It adds
    vlan id into the hash mix and uses vlan as an addditional parameter
    for an entry match.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1ae6395a0369..f4ae87b5aa6e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -88,6 +88,7 @@ struct net_bridge_fdb_entry
 	mac_addr			addr;
 	unsigned char			is_local;
 	unsigned char			is_static;
+	__u16				vlan_id;
 };
 
 struct net_bridge_port_group {
@@ -373,7 +374,8 @@ extern void br_fdb_cleanup(unsigned long arg);
 extern void br_fdb_delete_by_port(struct net_bridge *br,
 				  const struct net_bridge_port *p, int do_all);
 extern struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
-						 const unsigned char *addr);
+						 const unsigned char *addr,
+						 __u16 vid);
 extern int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
 extern int br_fdb_fillbuf(struct net_bridge *br, void *buf,
 			  unsigned long count, unsigned long off);
@@ -382,7 +384,8 @@ extern int br_fdb_insert(struct net_bridge *br,
 			 const unsigned char *addr);
 extern void br_fdb_update(struct net_bridge *br,
 			  struct net_bridge_port *source,
-			  const unsigned char *addr);
+			  const unsigned char *addr,
+			  u16 vid);
 
 extern int br_fdb_delete(struct ndmsg *ndm,
 			 struct net_device *dev,

commit 552406c488ec2cf1aaf8b5bd24d1750c9fd6d8cc
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:15 2013 +0000

    bridge: Add the ability to configure pvid
    
    A user may designate a certain vlan as PVID.  This means that
    any ingress frame that does not contain a vlan tag is assigned to
    this vlan and any forwarding decisions are made with this vlan in mind.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ea8e7efd9137..1ae6395a0369 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -562,11 +562,11 @@ extern bool br_allowed_egress(struct net_bridge *br,
 extern struct sk_buff *br_handle_vlan(struct net_bridge *br,
 				      const struct net_port_vlans *v,
 				      struct sk_buff *skb);
-extern int br_vlan_add(struct net_bridge *br, u16 vid);
+extern int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags);
 extern int br_vlan_delete(struct net_bridge *br, u16 vid);
 extern void br_vlan_flush(struct net_bridge *br);
 extern int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
-extern int nbp_vlan_add(struct net_bridge_port *port, u16 vid);
+extern int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags);
 extern int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 extern void nbp_vlan_flush(struct net_bridge_port *port);
 
@@ -633,7 +633,7 @@ static inline struct sk_buff *br_handle_vlan(struct net_bridge *br,
 	return skb;
 }
 
-static inline int br_vlan_add(struct net_bridge *br, u16 vid)
+static inline int br_vlan_add(struct net_bridge *br, u16 vid, u16 flags)
 {
 	return -EOPNOTSUPP;
 }
@@ -647,7 +647,7 @@ static inline void br_vlan_flush(struct net_bridge *br)
 {
 }
 
-static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid)
+static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid, u16 flags)
 {
 	return -EOPNOTSUPP;
 }

commit 7885198861fc9a3dfdc6bb90dc0ba12689d6cd57
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:14 2013 +0000

    bridge: Implement vlan ingress/egress policy with PVID.
    
    At ingress, any untagged traffic is assigned to the PVID.
    Any tagged traffic is filtered according to membership bitmap.
    
    At egress, if the vlan matches the PVID, the frame is sent
    untagged.  Otherwise the frame is sent tagged.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ce2235255c2f..ea8e7efd9137 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -67,6 +67,7 @@ struct br_ip
 
 struct net_port_vlans {
 	u16				port_idx;
+	u16				pvid;
 	union {
 		struct net_bridge_port		*port;
 		struct net_bridge		*br;
@@ -554,10 +555,13 @@ static inline void br_mdb_uninit(void)
 /* br_vlan.c */
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 extern bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
-			       struct sk_buff *skb);
+			       struct sk_buff *skb, u16 *vid);
 extern bool br_allowed_egress(struct net_bridge *br,
 			      const struct net_port_vlans *v,
 			      const struct sk_buff *skb);
+extern struct sk_buff *br_handle_vlan(struct net_bridge *br,
+				      const struct net_port_vlans *v,
+				      struct sk_buff *skb);
 extern int br_vlan_add(struct net_bridge *br, u16 vid);
 extern int br_vlan_delete(struct net_bridge *br, u16 vid);
 extern void br_vlan_flush(struct net_bridge *br);
@@ -594,10 +598,23 @@ static inline int br_vlan_get_tag(const struct sk_buff *skb, u16 *vid)
 
 	return err;
 }
+
+static inline u16 br_get_pvid(const struct net_port_vlans *v)
+{
+	/* Return just the VID if it is set, or VLAN_N_VID (invalid vid) if
+	 * vid wasn't set
+	 */
+	smp_rmb();
+	return (v->pvid & VLAN_TAG_PRESENT) ?
+			(v->pvid & ~VLAN_TAG_PRESENT) :
+			VLAN_N_VID;
+}
+
 #else
 static inline bool br_allowed_ingress(struct net_bridge *br,
 				      struct net_port_vlans *v,
-				      struct sk_buff *skb)
+				      struct sk_buff *skb,
+				      u16 *vid)
 {
 	return true;
 }
@@ -609,6 +626,13 @@ static inline bool br_allowed_egress(struct net_bridge *br,
 	return true;
 }
 
+static inline struct sk_buff *br_handle_vlan(struct net_bridge *br,
+					     const struct net_port_vlans *v,
+					     struct sk_buff *skb)
+{
+	return skb;
+}
+
 static inline int br_vlan_add(struct net_bridge *br, u16 vid)
 {
 	return -EOPNOTSUPP;
@@ -648,10 +672,14 @@ static inline struct net_port_vlans *nbp_get_vlan_info(
 	return NULL;
 }
 
-static inline u16 br_vlan_get_tag(const struct sk_buff *skb)
+static inline u16 br_vlan_get_tag(const struct sk_buff *skb, u16 *tag)
 {
 	return 0;
 }
+static inline u16 br_get_pvid(const struct net_port_vlans *v)
+{
+	return VLAN_N_VID;	/* Returns invalid vid */
+}
 #endif
 
 /* br_netfilter.c */

commit 6cbdceeb1cb12c7d620161925a8c3e81daadb2e4
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:13 2013 +0000

    bridge: Dump vlan information from a bridge port
    
    Using the RTM_GETLINK dump the vlan filter list of a given
    bridge port.  The information depends on setting the filter
    flag similar to how nic VF info is dumped.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index a42f9d49a64e..ce2235255c2f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -73,6 +73,7 @@ struct net_port_vlans {
 	}				parent;
 	struct rcu_head			rcu;
 	unsigned long			vlan_bitmap[BR_VLAN_BITMAP_LEN];
+	u16				num_vlans;
 };
 
 struct net_bridge_fdb_entry
@@ -715,7 +716,7 @@ extern void br_ifinfo_notify(int event, struct net_bridge_port *port);
 extern int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg);
 extern int br_dellink(struct net_device *dev, struct nlmsghdr *nlmsg);
 extern int br_getlink(struct sk_buff *skb, u32 pid, u32 seq,
-		      struct net_device *dev);
+		      struct net_device *dev, u32 filter_mask);
 
 #ifdef CONFIG_SYSFS
 /* br_sysfs_if.c */

commit 407af3299ef1ac7e87ce3fb530e32a009d1a9efd
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:12 2013 +0000

    bridge: Add netlink interface to configure vlans on bridge ports
    
    Add a netlink interface to add and remove vlan configuration on bridge port.
    The interface uses the RTM_SETLINK message and encodes the vlan
    configuration inside the IFLA_AF_SPEC.  It is possble to include multiple
    vlans to either add or remove in a single message.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f0f24610d111..a42f9d49a64e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -713,6 +713,7 @@ extern int br_netlink_init(void);
 extern void br_netlink_fini(void);
 extern void br_ifinfo_notify(int event, struct net_bridge_port *port);
 extern int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg);
+extern int br_dellink(struct net_device *dev, struct nlmsghdr *nlmsg);
 extern int br_getlink(struct sk_buff *skb, u32 pid, u32 seq,
 		      struct net_device *dev);
 

commit 85f46c6baef1486ce20e13dd7cdea5dd15be2a90
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:11 2013 +0000

    bridge: Verify that a vlan is allowed to egress on given port
    
    When bridge forwards a frame, make sure that a frame is allowed
    to egress on that port.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ed7c764ee9da..f0f24610d111 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -554,6 +554,9 @@ static inline void br_mdb_uninit(void)
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
 extern bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
 			       struct sk_buff *skb);
+extern bool br_allowed_egress(struct net_bridge *br,
+			      const struct net_port_vlans *v,
+			      const struct sk_buff *skb);
 extern int br_vlan_add(struct net_bridge *br, u16 vid);
 extern int br_vlan_delete(struct net_bridge *br, u16 vid);
 extern void br_vlan_flush(struct net_bridge *br);
@@ -598,6 +601,13 @@ static inline bool br_allowed_ingress(struct net_bridge *br,
 	return true;
 }
 
+static inline bool br_allowed_egress(struct net_bridge *br,
+				     const struct net_port_vlans *v,
+				     const struct sk_buff *skb)
+{
+	return true;
+}
+
 static inline int br_vlan_add(struct net_bridge *br, u16 vid)
 {
 	return -EOPNOTSUPP;

commit a37b85c9fbd1dc69fbec3985763f373203eaf9e3
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:10 2013 +0000

    bridge: Validate that vlan is permitted on ingress
    
    When a frame arrives on a port or transmitted by the bridge,
    if we have VLANs configured, validate that a given VLAN is allowed
    to enter the bridge.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1f3b309beea8..ed7c764ee9da 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -552,6 +552,8 @@ static inline void br_mdb_uninit(void)
 
 /* br_vlan.c */
 #ifdef CONFIG_BRIDGE_VLAN_FILTERING
+extern bool br_allowed_ingress(struct net_bridge *br, struct net_port_vlans *v,
+			       struct sk_buff *skb);
 extern int br_vlan_add(struct net_bridge *br, u16 vid);
 extern int br_vlan_delete(struct net_bridge *br, u16 vid);
 extern void br_vlan_flush(struct net_bridge *br);
@@ -559,7 +561,43 @@ extern int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
 extern int nbp_vlan_add(struct net_bridge_port *port, u16 vid);
 extern int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
 extern void nbp_vlan_flush(struct net_bridge_port *port);
+
+static inline struct net_port_vlans *br_get_vlan_info(
+						const struct net_bridge *br)
+{
+	return rcu_dereference(br->vlan_info);
+}
+
+static inline struct net_port_vlans *nbp_get_vlan_info(
+						const struct net_bridge_port *p)
+{
+	return rcu_dereference(p->vlan_info);
+}
+
+/* Since bridge now depends on 8021Q module, but the time bridge sees the
+ * skb, the vlan tag will always be present if the frame was tagged.
+ */
+static inline int br_vlan_get_tag(const struct sk_buff *skb, u16 *vid)
+{
+	int err = 0;
+
+	if (vlan_tx_tag_present(skb))
+		*vid = vlan_tx_tag_get(skb) & VLAN_VID_MASK;
+	else {
+		*vid = 0;
+		err = -EINVAL;
+	}
+
+	return err;
+}
 #else
+static inline bool br_allowed_ingress(struct net_bridge *br,
+				      struct net_port_vlans *v,
+				      struct sk_buff *skb)
+{
+	return true;
+}
+
 static inline int br_vlan_add(struct net_bridge *br, u16 vid)
 {
 	return -EOPNOTSUPP;
@@ -588,6 +626,21 @@ static inline void nbp_vlan_flush(struct net_bridge_port *port)
 {
 }
 
+static inline struct net_port_vlans *br_get_vlan_info(
+						const struct net_bridge *br)
+{
+	return NULL;
+}
+static inline struct net_port_vlans *nbp_get_vlan_info(
+						const struct net_bridge_port *p)
+{
+	return NULL;
+}
+
+static inline u16 br_vlan_get_tag(const struct sk_buff *skb)
+{
+	return 0;
+}
 #endif
 
 /* br_netfilter.c */

commit 243a2e63f5f47763b802e9dee8dbf1611a1c1322
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Feb 13 12:00:09 2013 +0000

    bridge: Add vlan filtering infrastructure
    
    Adds an optional infrustructure component to bridge that would allow
    native vlan filtering in the bridge.  Each bridge port (as well
    as the bridge device) now get a VLAN bitmap.  Each bit in the bitmap
    is associated with a vlan id.  This way if the bit corresponding to
    the vid is set in the bitmap that the packet with vid is allowed to
    enter and exit the port.
    
    Write access the bitmap is protected by RTNL and read access
    protected by RCU.
    
    Vlan functionality is disabled by default.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 06e85d9c05aa..1f3b309beea8 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -18,6 +18,7 @@
 #include <linux/netpoll.h>
 #include <linux/u64_stats_sync.h>
 #include <net/route.h>
+#include <linux/if_vlan.h>
 
 #define BR_HASH_BITS 8
 #define BR_HASH_SIZE (1 << BR_HASH_BITS)
@@ -26,6 +27,7 @@
 
 #define BR_PORT_BITS	10
 #define BR_MAX_PORTS	(1<<BR_PORT_BITS)
+#define BR_VLAN_BITMAP_LEN	BITS_TO_LONGS(VLAN_N_VID)
 
 #define BR_VERSION	"2.3"
 
@@ -63,6 +65,16 @@ struct br_ip
 	__be16		proto;
 };
 
+struct net_port_vlans {
+	u16				port_idx;
+	union {
+		struct net_bridge_port		*port;
+		struct net_bridge		*br;
+	}				parent;
+	struct rcu_head			rcu;
+	unsigned long			vlan_bitmap[BR_VLAN_BITMAP_LEN];
+};
+
 struct net_bridge_fdb_entry
 {
 	struct hlist_node		hlist;
@@ -156,6 +168,9 @@ struct net_bridge_port
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	struct netpoll			*np;
 #endif
+#ifdef CONFIG_BRIDGE_VLAN_FILTERING
+	struct net_port_vlans __rcu	*vlan_info;
+#endif
 };
 
 #define br_port_exists(dev) (dev->priv_flags & IFF_BRIDGE_PORT)
@@ -257,6 +272,10 @@ struct net_bridge
 	struct timer_list		topology_change_timer;
 	struct timer_list		gc_timer;
 	struct kobject			*ifobj;
+#ifdef CONFIG_BRIDGE_VLAN_FILTERING
+	u8				vlan_enabled;
+	struct net_port_vlans __rcu	*vlan_info;
+#endif
 };
 
 struct br_input_skb_cb {
@@ -531,6 +550,46 @@ static inline void br_mdb_uninit(void)
 }
 #endif
 
+/* br_vlan.c */
+#ifdef CONFIG_BRIDGE_VLAN_FILTERING
+extern int br_vlan_add(struct net_bridge *br, u16 vid);
+extern int br_vlan_delete(struct net_bridge *br, u16 vid);
+extern void br_vlan_flush(struct net_bridge *br);
+extern int br_vlan_filter_toggle(struct net_bridge *br, unsigned long val);
+extern int nbp_vlan_add(struct net_bridge_port *port, u16 vid);
+extern int nbp_vlan_delete(struct net_bridge_port *port, u16 vid);
+extern void nbp_vlan_flush(struct net_bridge_port *port);
+#else
+static inline int br_vlan_add(struct net_bridge *br, u16 vid)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int br_vlan_delete(struct net_bridge *br, u16 vid)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline void br_vlan_flush(struct net_bridge *br)
+{
+}
+
+static inline int nbp_vlan_add(struct net_bridge_port *port, u16 vid)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline int nbp_vlan_delete(struct net_bridge_port *port, u16 vid)
+{
+	return -EOPNOTSUPP;
+}
+
+static inline void nbp_vlan_flush(struct net_bridge_port *port)
+{
+}
+
+#endif
+
 /* br_netfilter.c */
 #ifdef CONFIG_BRIDGE_NETFILTER
 extern int br_netfilter_init(void);

commit b2748267d6487857f1400dc42748c5409e0ee130
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Sun Feb 10 11:41:01 2013 +0000

    bridge: use dev->addr_assign_type to see if user change mac
    
    And remove no longer used br->flags.
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Acked-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 711094aed41a..06e85d9c05aa 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -197,9 +197,6 @@ struct net_bridge
 	bool				nf_call_ip6tables;
 	bool				nf_call_arptables;
 #endif
-	unsigned long			flags;
-#define BR_SET_MAC_ADDR		0x00000001
-
 	u16				group_fwd_mask;
 
 	/* STP */

commit fdb184d1467f9ed5b17c553b85eb1bb72bdbf62f
Author: Rami Rosen <ramirose@gmail.com>
Date:   Thu Jan 3 13:30:43 2013 +0200

    bridge: add empty br_mdb_init() and br_mdb_uninit() definitions.
    
    This patch adds empty br_mdb_init() and br_mdb_uninit() definitions in
    br_private.h to avoid build failure when CONFIG_BRIDGE_IGMP_SNOOPING is not set.
    These methods were moved from br_multicast.c to br_netlink.c by
    commit 3ec8e9f085bcaef0de1077f555c2c5102c223390
    
    Signed-off-by: Rami Rosen <ramirose@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8d83be5ffedc..711094aed41a 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -526,6 +526,12 @@ static inline bool br_multicast_is_router(struct net_bridge *br)
 {
 	return 0;
 }
+static inline void br_mdb_init(void)
+{
+}
+static inline void br_mdb_uninit(void)
+{
+}
 #endif
 
 /* br_netfilter.c */

commit 63233159fd4e596568f5f168ecb0879b61631d47
Author: Vlad Yasevich <vyasevic@redhat.com>
Date:   Wed Dec 19 09:13:48 2012 +0000

    bridge: Do not unregister all PF_BRIDGE rtnl operations
    
    Bridge fdb and link rtnl operations are registered in
    core/rtnetlink.  Bridge mdb operations are registred
    in bridge/mdb.  When removing bridge module, do not
    unregister ALL PF_BRIDGE ops since that would remove
    the ops from rtnetlink as well.  Do remove mdb ops when
    bridge is destroyed.
    
    Signed-off-by: Vlad Yasevich <vyasevic@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 49b85af44016..8d83be5ffedc 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -447,6 +447,7 @@ extern struct net_bridge_port_group *br_multicast_new_port_group(
 				struct net_bridge_port_group *next,
 				unsigned char state);
 extern void br_mdb_init(void);
+extern void br_mdb_uninit(void);
 extern void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
 			  struct br_ip *group, int type);
 

commit ccb1c31a7a8744cd153a7d92b726a56b56ad61d3
Author: Amerigo Wang <amwang@redhat.com>
Date:   Fri Dec 14 22:09:51 2012 +0000

    bridge: add flags to distinguish permanent mdb entires
    
    This patch adds a flag to each mdb entry, so that we can distinguish
    permanent entries with temporary entries.
    
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Stephen Hemminger <shemminger@vyatta.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f21a739a6186..49b85af44016 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -83,6 +83,7 @@ struct net_bridge_port_group {
 	struct rcu_head			rcu;
 	struct timer_list		timer;
 	struct br_ip			addr;
+	unsigned char			state;
 };
 
 struct net_bridge_mdb_entry
@@ -443,7 +444,8 @@ extern void br_multicast_free_pg(struct rcu_head *head);
 extern struct net_bridge_port_group *br_multicast_new_port_group(
 				struct net_bridge_port *port,
 				struct br_ip *group,
-				struct net_bridge_port_group *next);
+				struct net_bridge_port_group *next,
+				unsigned char state);
 extern void br_mdb_init(void);
 extern void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
 			  struct br_ip *group, int type);

commit cfd567543590f71ca0af397437e2554f9756d750
Author: Cong Wang <amwang@redhat.com>
Date:   Tue Dec 11 22:23:08 2012 +0000

    bridge: add support of adding and deleting mdb entries
    
    This patch implents adding/deleting mdb entries via netlink.
    Currently all entries are temp, we probably need a flag to distinguish
    permanent entries too.
    
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Stephen Hemminger <shemminger@vyatta.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2807c7680c38..f21a739a6186 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -434,10 +434,33 @@ extern int br_multicast_set_port_router(struct net_bridge_port *p,
 extern int br_multicast_toggle(struct net_bridge *br, unsigned long val);
 extern int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
 extern int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
+extern struct net_bridge_mdb_entry *br_mdb_ip_get(
+				struct net_bridge_mdb_htable *mdb,
+				struct br_ip *dst);
+extern struct net_bridge_mdb_entry *br_multicast_new_group(struct net_bridge *br,
+				struct net_bridge_port *port, struct br_ip *group);
+extern void br_multicast_free_pg(struct rcu_head *head);
+extern struct net_bridge_port_group *br_multicast_new_port_group(
+				struct net_bridge_port *port,
+				struct br_ip *group,
+				struct net_bridge_port_group *next);
 extern void br_mdb_init(void);
 extern void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
 			  struct br_ip *group, int type);
 
+#define mlock_dereference(X, br) \
+	rcu_dereference_protected(X, lockdep_is_held(&br->multicast_lock))
+
+#if IS_ENABLED(CONFIG_IPV6)
+#include <net/addrconf.h>
+static inline int ipv6_is_transient_multicast(const struct in6_addr *addr)
+{
+	if (ipv6_addr_is_multicast(addr) && IPV6_ADDR_MC_FLAG_TRANSIENT(addr))
+		return 1;
+	return 0;
+}
+#endif
+
 static inline bool br_multicast_is_router(struct net_bridge *br)
 {
 	return br->multicast_router == 2 ||

commit 37a393bc4932d7bac360f40064aaafc01ab44901
Author: Cong Wang <amwang@redhat.com>
Date:   Tue Dec 11 22:23:07 2012 +0000

    bridge: notify mdb changes via netlink
    
    As Stephen mentioned, we need to monitor the mdb
    changes in user-space, so add notifications via netlink too.
    
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Stephen Hemminger <shemminger@vyatta.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f95b766c7a98..2807c7680c38 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -435,6 +435,8 @@ extern int br_multicast_toggle(struct net_bridge *br, unsigned long val);
 extern int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
 extern int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
 extern void br_mdb_init(void);
+extern void br_mdb_notify(struct net_device *dev, struct net_bridge_port *port,
+			  struct br_ip *group, int type);
 
 static inline bool br_multicast_is_router(struct net_bridge *br)
 {

commit 2ce297fc24d1f0b70c756d1f593e7a089a2d888d
Author: Cong Wang <amwang@redhat.com>
Date:   Mon Dec 10 02:15:35 2012 +0000

    bridge: fix seq check in br_mdb_dump()
    
    In case of rehashing, introduce a global variable 'br_mdb_rehash_seq'
    which gets increased every time when rehashing, and assign
    net->dev_base_seq + br_mdb_rehash_seq to cb->seq.
    
    In theory cb->seq could be wrapped to zero, but this is not
    easy to fix, as net->dev_base_seq is not visible inside
    br_mdb_rehash(). In practice, this is rare.
    
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Stephen Hemminger <shemminger@vyatta.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Graf <tgraf@suug.ch>
    Cc: Jesper Dangaard Brouer <brouer@redhat.com>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index ae0a6ec0a702..f95b766c7a98 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -411,6 +411,7 @@ extern int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __us
 
 /* br_multicast.c */
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+extern unsigned int br_mdb_rehash_seq;
 extern int br_multicast_rcv(struct net_bridge *br,
 			    struct net_bridge_port *port,
 			    struct sk_buff *skb);

commit ee07c6e7a6f8a25c18f0a6b18152fbd7499245f6
Author: Cong Wang <amwang@redhat.com>
Date:   Fri Dec 7 00:04:48 2012 +0000

    bridge: export multicast database via netlink
    
    V5: fix two bugs pointed out by Thomas
        remove seq check for now, mark it as TODO
    
    V4: remove some useless #include
        some coding style fix
    
    V3: drop debugging printk's
        update selinux perm table as well
    
    V2: drop patch 1/2, export ifindex directly
        Redesign netlink attributes
        Improve netlink seq check
        Handle IPv6 addr as well
    
    This patch exports bridge multicast database via netlink
    message type RTM_GETMDB. Similar to fdb, but currently bridge-specific.
    We may need to support modify multicast database too (RTM_{ADD,DEL}MDB).
    
    (Thanks to Thomas for patient reviews)
    
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Stephen Hemminger <shemminger@vyatta.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Thomas Graf <tgraf@suug.ch>
    Cc: Jesper Dangaard Brouer <brouer@redhat.com>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Acked-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index cd86222cf5e3..ae0a6ec0a702 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -433,6 +433,7 @@ extern int br_multicast_set_port_router(struct net_bridge_port *p,
 extern int br_multicast_toggle(struct net_bridge *br, unsigned long val);
 extern int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
 extern int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
+extern void br_mdb_init(void);
 
 static inline bool br_multicast_is_router(struct net_bridge *br)
 {

commit c2d3babfafbb9f6629cfb47139758e59a5eb0d80
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Dec 5 16:24:45 2012 -0500

    bridge: implement multicast fast leave
    
    V3: make it a flag
    V2: make the toggle per-port
    
    Fast leave allows bridge to immediately stops the multicast
    traffic on the port receives IGMP Leave when IGMP snooping is enabled,
    no timeouts are observed.
    
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Stephen Hemminger <shemminger@vyatta.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Cong Wang <amwang@redhat.com>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index cdbf9047a659..cd86222cf5e3 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -137,11 +137,11 @@ struct net_bridge_port
 #define BR_HAIRPIN_MODE		0x00000001
 #define BR_BPDU_GUARD           0x00000002
 #define BR_ROOT_BLOCK		0x00000004
+#define BR_MULTICAST_FAST_LEAVE	0x00000008
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	u32				multicast_startup_queries_sent;
 	unsigned char			multicast_router;
-	unsigned char			multicast_fast_leave;
 	struct timer_list		multicast_router_timer;
 	struct timer_list		multicast_query_timer;
 	struct hlist_head		mglist;

commit 50426b5925ff0d7f47c20e6886047f1bb6245901
Author: Amerigo Wang <amwang@redhat.com>
Date:   Mon Dec 3 23:56:40 2012 +0000

    bridge: implement multicast fast leave
    
    V2: make the toggle per-port
    
    Fast leave allows bridge to immediately stops the multicast
    traffic on the port receives IGMP Leave when IGMP snooping is enabled,
    no timeouts are observed.
    
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: Stephen Hemminger <shemminger@vyatta.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index eb9cd42146a5..cdbf9047a659 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -141,6 +141,7 @@ struct net_bridge_port
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	u32				multicast_startup_queries_sent;
 	unsigned char			multicast_router;
+	unsigned char			multicast_fast_leave;
 	struct timer_list		multicast_router_timer;
 	struct timer_list		multicast_query_timer;
 	struct hlist_head		mglist;

commit 1007dd1aa50b0403df370834f647abef1722925c
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Tue Nov 13 07:53:08 2012 +0000

    bridge: add root port blocking
    
    This is Linux bridge implementation of root port guard.
    If BPDU is received from a leaf (edge) port, it should not
    be elected as root port.
    
    Why would you want to do this?
    If using STP on a bridge and the downstream bridges are not fully
    trusted; this prevents a hostile guest for rerouting traffic.
    
    Why not just use netfilter?
    Netfilter does not track of follow spanning tree decisions.
    It would be difficult and error prone to try and mirror STP
    resolution in netfilter module.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c92b0804ff2d..eb9cd42146a5 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -136,6 +136,7 @@ struct net_bridge_port
 	unsigned long 			flags;
 #define BR_HAIRPIN_MODE		0x00000001
 #define BR_BPDU_GUARD           0x00000002
+#define BR_ROOT_BLOCK		0x00000004
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	u32				multicast_startup_queries_sent;

commit a2e01a65cd7135dab26d27d4b589b2e5358bec99
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Tue Nov 13 07:53:07 2012 +0000

    bridge: implement BPDU blocking
    
    This is Linux bridge implementation of STP protection
    (Cisco BPDU guard/Juniper BPDU block). BPDU block disables
    the bridge port if a STP BPDU packet is received.
    
    Why would you want to do this?
    If running Spanning Tree on bridge, hostile devices on the network
    may send BPDU and cause network failure. Enabling bpdu block
    will detect and stop this.
    
    How to recover the port?
    The port will be restarted if link is brought down, or
    removed and reattached.  For example:
     # ip li set dev eth0 down; ip li set dev eth0 up
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 22111ffd68df..c92b0804ff2d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -135,6 +135,7 @@ struct net_bridge_port
 
 	unsigned long 			flags;
 #define BR_HAIRPIN_MODE		0x00000001
+#define BR_BPDU_GUARD           0x00000002
 
 #ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	u32				multicast_startup_queries_sent;

commit 0cb2bbbea0857c5c76db4cae85343553a882c0de
Author: Lee Jones <lee.jones@linaro.org>
Date:   Sat Nov 3 23:02:30 2012 +0100

    bridge: Avoid 'statement with no effect' compiler warnings
    
    Instead of issuing (0) statements when !CONFIG_SYSFS which will cause
    'warning: ', we'll use inline statements instead. This will effectively
    do the same thing, but suppress any unnecessary warnings.
    
    Cc: Stephen Hemminger <shemminger@vyatta.com>
    Cc: bridge@lists.linux-foundation.org
    Cc: netdev@vger.kernel.org
    Signed-off-by: Lee Jones <lee.jones@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index d5efa57a2c20..22111ffd68df 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -570,10 +570,10 @@ extern void br_sysfs_delbr(struct net_device *dev);
 
 #else
 
-#define br_sysfs_addif(p)	(0)
-#define br_sysfs_renameif(p)	(0)
-#define br_sysfs_addbr(dev)	(0)
-#define br_sysfs_delbr(dev)	do { } while(0)
+static inline int br_sysfs_addif(struct net_bridge_port *p) { return 0; }
+static inline int br_sysfs_renameif(struct net_bridge_port *p) { return 0; }
+static inline int br_sysfs_addbr(struct net_device *dev) { return 0; }
+static inline void br_sysfs_delbr(struct net_device *dev) { return; }
 #endif /* CONFIG_SYSFS */
 
 #endif

commit 810b6d7638a288216f99bd190470d67061c8bd88
Merge: f7b4fb22b838 ac61d515f14f
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Oct 31 14:25:33 2012 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/jkirsher/net-next
    
    Jeff Kirsher says:
    
    ====================
    This series contains updates to ixgbe, ixgbevf, igbvf, igb and
    networking core (bridge).  Most notably is the addition of support
    for local link multicast addresses in SR-IOV mode to the networking
    core.
    
    Also note, the ixgbe patch "ixgbe: Add support for pipeline reset" and
    "ixgbe: Fix return value from macvlan filter function" is revised based
    on community feedback.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2469ffd723f76ac2d3ce3d4f31ee31ee0a06cd38
Author: John Fastabend <john.r.fastabend@intel.com>
Date:   Wed Oct 24 08:13:03 2012 +0000

    net: set and query VEB/VEPA bridge mode via PF_BRIDGE
    
    Hardware switches may support enabling and disabling the
    loopback switch which puts the device in a VEPA mode defined
    in the IEEE 802.1Qbg specification. In this mode frames are
    not switched in the hardware but sent directly to the switch.
    SR-IOV capable NICs will likely support this mode I am
    aware of at least two such devices. Also I am told (but don't
    have any of this hardware available) that there are devices
    that only support VEPA modes. In these cases it is important
    at a minimum to be able to query these attributes.
    
    This patch adds an additional IFLA_BRIDGE_MODE attribute that can be
    set and dumped via the PF_BRIDGE:{SET|GET}LINK operations. Also
    anticipating bridge attributes that may be common for both embedded
    bridges and software bridges this adds a flags attribute
    IFLA_BRIDGE_FLAGS currently used to determine if the command or event
    is being generated to/from an embedded bridge or software bridge.
    Finally, the event generation is pulled out of the bridge module and
    into rtnetlink proper.
    
    For example using the macvlan driver in VEPA mode on top of
    an embedded switch requires putting the embedded switch into
    a VEPA mode to get the expected results.
    
            --------  --------
            | VEPA |  | VEPA |       <-- macvlan vepa edge relays
            --------  --------
               |        |
               |        |
            ------------------
            |      VEPA      |       <-- embedded switch in NIC
            ------------------
                    |
                    |
            -------------------
            | external switch |      <-- shiny new physical
            -------------------          switch with VEPA support
    
    A packet sent from the macvlan VEPA at the top could be
    loopbacked on the embedded switch and never seen by the
    external switch. So in order for this to work the embedded
    switch needs to be set in the VEPA state via the above
    described commands.
    
    By making these attributes nested in IFLA_AF_SPEC we allow
    future extensions to be made as needed.
    
    CC: Lennert Buytenhek <buytenh@wantstofly.org>
    CC: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index fdcd5f626ca6..6f40c14a2a65 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -158,7 +158,9 @@ struct net_bridge_port
 
 static inline struct net_bridge_port *br_port_get_rcu(const struct net_device *dev)
 {
-	struct net_bridge_port *port = rcu_dereference(dev->rx_handler_data);
+	struct net_bridge_port *port =
+			rcu_dereference_rtnl(dev->rx_handler_data);
+
 	return br_port_exists(dev) ? port : NULL;
 }
 

commit e5a55a898720096f43bc24938f8875c0a1b34cd7
Author: John Fastabend <john.r.fastabend@intel.com>
Date:   Wed Oct 24 08:12:57 2012 +0000

    net: create generic bridge ops
    
    The PF_BRIDGE:RTM_{GET|SET}LINK nlmsg family and type are
    currently embedded in the ./net/bridge module. This prohibits
    them from being used by other bridging devices. One example
    of this being hardware that has embedded bridging components.
    
    In order to use these nlmsg types more generically this patch
    adds two net_device_ops hooks. One to set link bridge attributes
    and another to dump the current bride attributes.
    
            ndo_bridge_setlink()
            ndo_bridge_getlink()
    
    CC: Lennert Buytenhek <buytenh@wantstofly.org>
    CC: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 9b278c4ebee1..fdcd5f626ca6 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -553,6 +553,9 @@ extern struct rtnl_link_ops br_link_ops;
 extern int br_netlink_init(void);
 extern void br_netlink_fini(void);
 extern void br_ifinfo_notify(int event, struct net_bridge_port *port);
+extern int br_setlink(struct net_device *dev, struct nlmsghdr *nlmsg);
+extern int br_getlink(struct sk_buff *skb, u32 pid, u32 seq,
+		      struct net_device *dev);
 
 #ifdef CONFIG_SYSFS
 /* br_sysfs_if.c */

commit b3343a2a2c95b3b7ed4f6596e860c4276ba46217
Author: John Fastabend <john.r.fastabend@intel.com>
Date:   Tue Sep 18 00:01:12 2012 +0000

    net, ixgbe: handle link local multicast addresses in SR-IOV mode
    
    In SR-IOV mode the PF driver acts as the uplink port and is
    used to send control packets e.g. lldpad, stp, etc.
    
       eth0.1     eth0.2     eth0
       VF         VF         PF
       |          |          |   <-- stand-in for uplink
       |          |          |
      --------------------------
      |  Embedded Switch       |
      --------------------------
                  |
                 MAC   <-- uplink
    
    But the embedded switch is setup to forward multicast addresses
    to all interfaces both VFs and PF and onto the physical link.
    This results in reserved MAC addresses used by control protocols
    to be forwarded over the switch onto the VF.
    
    In the LLDP case the PF sends an LLDPDU and it is currently
    being forwarded to all the VFs who then see the PF as a peer.
    This is incorrect.
    
    This patch adds the multicast addresses to the RAR table in the
    hardware to prevent this behavior.
    
    Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
    Tested-by: Phil Schmitt <phillip.j.schmitt@intel.com>
    Tested-by: Sibai Li <sibai.li@intel.com>
    Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 9b278c4ebee1..65b191a05dd6 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -288,7 +288,6 @@ struct br_input_skb_cb {
 	pr_debug("%s: " format,  (br)->dev->name, ##args)
 
 extern struct notifier_block br_device_notifier;
-extern const u8 br_group_address[ETH_ALEN];
 
 /* called under bridge lock */
 static inline int br_is_root_bridge(const struct net_bridge *br)

commit edc7d57327bd08bfd04f41531d49b176369db218
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon Oct 1 12:32:33 2012 +0000

    netlink: add attributes to fdb interface
    
    Later changes need to be able to refer to neighbour attributes
    when doing fdb_add.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 11a984b87e62..9b278c4ebee1 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -364,7 +364,7 @@ extern void br_fdb_update(struct net_bridge *br,
 extern int br_fdb_delete(struct ndmsg *ndm,
 			 struct net_device *dev,
 			 const unsigned char *addr);
-extern int br_fdb_add(struct ndmsg *nlh,
+extern int br_fdb_add(struct ndmsg *nlh, struct nlattr *tb[],
 		      struct net_device *dev,
 		      const unsigned char *addr,
 		      u16 nlh_flags);

commit 6b6e27255f29a6191ef8ad96bfcc392ab2ef6c71
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon Sep 17 10:03:26 2012 +0000

    netdev: make address const in device address management
    
    The internal functions for add/deleting addresses don't change
    their argument.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f507d2af9646..11a984b87e62 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -363,10 +363,10 @@ extern void br_fdb_update(struct net_bridge *br,
 
 extern int br_fdb_delete(struct ndmsg *ndm,
 			 struct net_device *dev,
-			 unsigned char *addr);
+			 const unsigned char *addr);
 extern int br_fdb_add(struct ndmsg *nlh,
 		      struct net_device *dev,
-		      unsigned char *addr,
+		      const unsigned char *addr,
 		      u16 nlh_flags);
 extern int br_fdb_dump(struct sk_buff *skb,
 		       struct netlink_callback *cb,

commit 47be03a28cc6c80e3aa2b3e8ed6d960ff0c5c0af
Author: Amerigo Wang <amwang@redhat.com>
Date:   Fri Aug 10 01:24:37 2012 +0000

    netpoll: use GFP_ATOMIC in slave_enable_netpoll() and __netpoll_setup()
    
    slave_enable_netpoll() and __netpoll_setup() may be called
    with read_lock() held, so should use GFP_ATOMIC to allocate
    memory. Eric suggested to pass gfp flags to __netpoll_setup().
    
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: Cong Wang <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index a768b2408edf..f507d2af9646 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -316,7 +316,7 @@ static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 		netpoll_send_skb(np, skb);
 }
 
-extern int br_netpoll_enable(struct net_bridge_port *p);
+extern int br_netpoll_enable(struct net_bridge_port *p, gfp_t gfp);
 extern void br_netpoll_disable(struct net_bridge_port *p);
 #else
 static inline struct netpoll_info *br_netpoll_info(struct net_bridge *br)
@@ -329,7 +329,7 @@ static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 {
 }
 
-static inline int br_netpoll_enable(struct net_bridge_port *p)
+static inline int br_netpoll_enable(struct net_bridge_port *p, gfp_t gfp)
 {
 	return 0;
 }

commit 149ddd83a92b02c658d6c61f3276eb6500d585e8
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Tue Jun 26 05:48:45 2012 +0000

    bridge: Assign rtnl_link_ops to bridge devices created via ioctl (v2)
    
    This ensures that bridges created with brctl(8) or ioctl(2) directly
    also carry IFLA_LINKINFO when dumped over netlink. This also allows
    to create a bridge with ioctl(2) and delete it with RTM_DELLINK.
    
    Signed-off-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1a8ad4fb9a6b..a768b2408edf 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -549,6 +549,7 @@ extern int (*br_fdb_test_addr_hook)(struct net_device *dev, unsigned char *addr)
 #endif
 
 /* br_netlink.c */
+extern struct rtnl_link_ops br_link_ops;
 extern int br_netlink_init(void);
 extern void br_netlink_fini(void);
 extern void br_ifinfo_notify(int event, struct net_bridge_port *port);

commit 77162022ab26a1f99d3af30c03760a76f86e193d
Author: John Fastabend <john.r.fastabend@intel.com>
Date:   Sun Apr 15 06:43:56 2012 +0000

    net: add generic PF_BRIDGE:RTM_ FDB hooks
    
    This adds two new flags NTF_MASTER and NTF_SELF that can
    now be used to specify where PF_BRIDGE netlink commands should
    be sent. NTF_MASTER sends the commands to the 'dev->master'
    device for parsing. Typically this will be the linux net/bridge,
    or open-vswitch devices. Also without any flags set the command
    will be handled by the master device as well so that current user
    space tools continue to work as expected.
    
    The NTF_SELF flag will push the PF_BRIDGE commands to the
    device. In the basic example below the commands are then parsed
    and programmed in the embedded bridge.
    
    Note if both NTF_SELF and NTF_MASTER bits are set then the
    command will be sent to both 'dev->master' and 'dev' this allows
    user space to easily keep the embedded bridge and software bridge
    in sync.
    
    There is a slight complication in the case with both flags set
    when an error occurs. To resolve this the rtnl handler clears
    the NTF_ flag in the netlink ack to indicate which sets completed
    successfully. The add/del handlers will abort as soon as any
    error occurs.
    
    To support this new net device ops were added to call into
    the device and the existing bridging code was refactored
    to use these. There should be no required changes in user space
    to support the current bridge behavior.
    
    A basic setup with a SR-IOV enabled NIC looks like this,
    
              veth0  veth2
                |      |
              ------------
              |  bridge0 |   <---- software bridging
              ------------
                   /
                   /
      ethx.y      ethx
        VF         PF
         \         \          <---- propagate FDB entries to HW
         \         \
      --------------------
      |  Embedded Bridge |    <---- hardware offloaded switching
      --------------------
    
    In this case the embedded bridge must be managed to allow 'veth0'
    to communicate with 'ethx.y' correctly. At present drivers managing
    the embedded bridge either send frames onto the network which
    then get dropped by the switch OR the embedded bridge will flood
    these frames. With this patch we have a mechanism to manage the
    embedded bridge correctly from user space. This example is specific
    to SR-IOV but replacing the VF with another PF or dropping this
    into the DSA framework generates similar management issues.
    
    Examples session using the 'br'[1] tool to add, dump and then
    delete a mac address with a new "embedded" option and enabled
    ixgbe driver:
    
    # br fdb add 22:35:19:ac:60:59 dev eth3
    # br fdb
    port    mac addr                flags
    veth0   22:35:19:ac:60:58       static
    veth0   9a:5f:81:f7:f6:ec       local
    eth3    00:1b:21:55:23:59       local
    eth3    22:35:19:ac:60:59       static
    veth0   22:35:19:ac:60:57       static
    #br fdb add 22:35:19:ac:60:59 embedded dev eth3
    #br fdb
    port    mac addr                flags
    veth0   22:35:19:ac:60:58       static
    veth0   9a:5f:81:f7:f6:ec       local
    eth3    00:1b:21:55:23:59       local
    eth3    22:35:19:ac:60:59       static
    veth0   22:35:19:ac:60:57       static
    eth3    22:35:19:ac:60:59       local embedded
    #br fdb del 22:35:19:ac:60:59 embedded dev eth3
    
    I added a couple lines to 'br' to set the flags correctly is all. It
    is my opinion that the merit of this patch is now embedded and SW
    bridges can both be modeled correctly in user space using very nearly
    the same message passing.
    
    [1] 'br' tool was published as an RFC here and will be renamed 'bridge'
        http://patchwork.ozlabs.org/patch/117664/
    
    Thanks to Jamal Hadi Salim, Stephen Hemminger and Ben Hutchings for
    valuable feedback, suggestions, and review.
    
    v2: fixed api descriptions and error case with both NTF_SELF and
        NTF_MASTER set plus updated patch description.
    
    Signed-off-by: John Fastabend <john.r.fastabend@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f8ffd8c49054..1a8ad4fb9a6b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -360,9 +360,18 @@ extern int br_fdb_insert(struct net_bridge *br,
 extern void br_fdb_update(struct net_bridge *br,
 			  struct net_bridge_port *source,
 			  const unsigned char *addr);
-extern int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb);
-extern int br_fdb_add(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg);
-extern int br_fdb_delete(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg);
+
+extern int br_fdb_delete(struct ndmsg *ndm,
+			 struct net_device *dev,
+			 unsigned char *addr);
+extern int br_fdb_add(struct ndmsg *nlh,
+		      struct net_device *dev,
+		      unsigned char *addr,
+		      u16 nlh_flags);
+extern int br_fdb_dump(struct sk_buff *skb,
+		       struct netlink_callback *cb,
+		       struct net_device *dev,
+		       int idx);
 
 /* br_forward.c */
 extern void br_deliver(const struct net_bridge_port *to,

commit c5c23260594c5701af66ef754916775ba6a46bbc
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Fri Apr 13 02:37:42 2012 +0000

    bridge: Add multicast_querier toggle and disable queries by default
    
    Sending general queries was implemented as an optimisation to speed
    up convergence on start-up.  In order to prevent interference with
    multicast routers a zero source address has to be used.
    
    Unfortunately these packets appear to cause some multicast-aware
    switches to misbehave, e.g., by disrupting multicast packets to us.
    
    Since the multicast snooping feature still functions without sending
    our own queries, this patch will change the default to not send
    queries.
    
    For those that need queries in order to speed up convergence on start-up,
    a toggle is provided to restore the previous behaviour.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e1d882257877..f8ffd8c49054 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -224,6 +224,7 @@ struct net_bridge
 	unsigned char			multicast_router;
 
 	u8				multicast_disabled:1;
+	u8				multicast_querier:1;
 
 	u32				hash_elasticity;
 	u32				hash_max;
@@ -417,6 +418,7 @@ extern int br_multicast_set_router(struct net_bridge *br, unsigned long val);
 extern int br_multicast_set_port_router(struct net_bridge_port *p,
 					unsigned long val);
 extern int br_multicast_toggle(struct net_bridge *br, unsigned long val);
+extern int br_multicast_set_querier(struct net_bridge *br, unsigned long val);
 extern int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
 
 static inline bool br_multicast_is_router(struct net_bridge *br)

commit 996304bbea3d2a094b7ba54c3bd65d3fffeac57b
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Wed Apr 4 01:01:20 2012 +0000

    bridge: Do not send queries on multicast group leaves
    
    As it stands the bridge IGMP snooping system will respond to
    group leave messages with queries for remaining membership.
    This is both unnecessary and undesirable.  First of all any
    multicast routers present should be doing this rather than us.
    What's more the queries that we send may end up upsetting other
    multicast snooping swithces in the system that are buggy.
    
    In fact, we can simply remove the code that send these queries
    because the existing membership expiry mechanism doesn't rely
    on them anyway.
    
    So this patch simply removes all code associated with group
    queries in response to group leave messages.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 0b67a63ad7a8..e1d882257877 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -82,9 +82,7 @@ struct net_bridge_port_group {
 	struct hlist_node		mglist;
 	struct rcu_head			rcu;
 	struct timer_list		timer;
-	struct timer_list		query_timer;
 	struct br_ip			addr;
-	u32				queries_sent;
 };
 
 struct net_bridge_mdb_entry
@@ -94,10 +92,8 @@ struct net_bridge_mdb_entry
 	struct net_bridge_port_group __rcu *ports;
 	struct rcu_head			rcu;
 	struct timer_list		timer;
-	struct timer_list		query_timer;
 	struct br_ip			addr;
 	bool				mglist;
-	u32				queries_sent;
 };
 
 struct net_bridge_mdb_htable

commit e6373c4c0ecb3a944c34117a3daeac315d641b5f
Author: Igor Maravi <igorm@etf.rs>
Date:   Mon Dec 12 02:58:25 2011 +0000

    net:bridge: use IS_ENABLED
    
    Use IS_ENABLED(CONFIG_FOO)
    instead of defined(CONFIG_FOO) || defined (CONFIG_FOO_MODULE)
    
    Signed-off-by: Igor Maravi <igorm@etf.rs>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 57dcd1489f3f..0b67a63ad7a8 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -537,7 +537,7 @@ extern void br_stp_port_timer_init(struct net_bridge_port *p);
 extern unsigned long br_timer_value(const struct timer_list *timer);
 
 /* br.c */
-#if defined(CONFIG_ATM_LANE) || defined(CONFIG_ATM_LANE_MODULE)
+#if IS_ENABLED(CONFIG_ATM_LANE)
 extern int (*br_fdb_test_addr_hook)(struct net_device *dev, unsigned char *addr);
 #endif
 

commit dfd56b8b38fff3586f36232db58e1e9f7885a605
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Sat Dec 10 09:48:31 2011 +0000

    net: use IS_ENABLED(CONFIG_IPV6)
    
    Instead of testing defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 89969080c384..57dcd1489f3f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -56,7 +56,7 @@ struct br_ip
 {
 	union {
 		__be32	ip4;
-#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+#if IS_ENABLED(CONFIG_IPV6)
 		struct in6_addr ip6;
 #endif
 	} u;

commit 43598813386f6205edf3c21f1fe97f731ccb4f15
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Thu Dec 8 07:17:49 2011 +0000

    bridge: add local MAC address to forwarding table (v2)
    
    If user has configured a MAC address that is not one of the existing
    ports of the bridge, then we need to add a special entry in the forwarding
    table. This forwarding table entry has no outgoing port so it has to be
    treated a little differently. The special entry is reported by the netlink
    interface with ifindex of bridge, but ignored by the old interface since there
    is no usable way to put it in the ABI.
    
    Reported-by: Koki Sanagi <sanagi.koki@jp.fujitsu.com>
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 4027029aa5e4..89969080c384 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -348,6 +348,7 @@ extern void br_fdb_fini(void);
 extern void br_fdb_flush(struct net_bridge *br);
 extern void br_fdb_changeaddr(struct net_bridge_port *p,
 			      const unsigned char *newaddr);
+extern void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr);
 extern void br_fdb_cleanup(unsigned long arg);
 extern void br_fdb_delete_by_port(struct net_bridge *br,
 				  const struct net_bridge_port *p, int do_all);

commit c8f44affb7244f2ac3e703cab13d55ede27621bb
Author: Micha Mirosaw <mirq-linux@rere.qmqm.pl>
Date:   Tue Nov 15 15:29:55 2011 +0000

    net: introduce and use netdev_features_t for device features sets
    
    v2:     add couple missing conversions in drivers
            split unexporting netdev_fix_features()
            implemented %pNF
            convert sock::sk_route_(no?)caps
    
    Signed-off-by: Micha Mirosaw <mirq-linux@rere.qmqm.pl>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index d7d6fb05411f..4027029aa5e4 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -387,7 +387,8 @@ extern int br_add_if(struct net_bridge *br,
 extern int br_del_if(struct net_bridge *br,
 	      struct net_device *dev);
 extern int br_min_mtu(const struct net_bridge *br);
-extern u32 br_features_recompute(struct net_bridge *br, u32 features);
+extern netdev_features_t br_features_recompute(struct net_bridge *br,
+	netdev_features_t features);
 
 /* br_input.c */
 extern int br_handle_frame_finish(struct sk_buff *skb);

commit 1805b2f04855f07afe3a71d620a68f483b0ed74f
Merge: 78d81d15b742 f42af6c486aa
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Oct 24 18:18:09 2011 -0400

    Merge branch 'master' of ra.kernel.org:/pub/scm/linux/kernel/git/davem/net

commit 1ce5cce895309862d2c35d922816adebe094fe4a
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Thu Oct 6 11:19:41 2011 +0000

    bridge: fix hang on removal of bridge via netlink
    
    Need to cleanup bridge device timers and ports when being bridge
    device is being removed via netlink.
    
    This fixes the problem of observed when doing:
     ip link add br0 type bridge
     ip link set dev eth1 master br0
     ip link set br0 up
     ip link del br0
    
    which would cause br0 to hang in unregister_netdev because
    of leftover reference count.
    
    Reported-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Acked-by: Sridhar Samudrala <sri@us.ibm.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 78cc364997d9..857a021deea9 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -294,6 +294,7 @@ static inline int br_is_root_bridge(const struct net_bridge *br)
 
 /* br_device.c */
 extern void br_dev_setup(struct net_device *dev);
+extern void br_dev_delete(struct net_device *dev, struct list_head *list);
 extern netdev_tx_t br_dev_xmit(struct sk_buff *skb,
 			       struct net_device *dev);
 #ifdef CONFIG_NET_POLL_CONTROLLER

commit 515853ccecc6987dfb8ed809dd8bf8900286f29e
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon Oct 3 18:14:46 2011 +0000

    bridge: allow forwarding some link local frames
    
    This is based on an earlier patch by Nick Carter with comments
    by David Lamparter but with some refinements. Thanks for their patience
    this is a confusing area with overlap of standards, user requirements,
    and compatibility with earlier releases.
    
    It adds a new sysfs attribute
       /sys/class/net/brX/bridge/group_fwd_mask
    that controls forwarding of frames with address of: 01-80-C2-00-00-0X
    The default setting has no forwarding to retain compatibility.
    
    One change from earlier releases is that forwarding of group
    addresses is not dependent on STP being enabled or disabled. This
    choice was made based on interpretation of tie 802.1 standards.
    I expect complaints will arise because of this, but better to follow
    the standard than continue acting incorrectly by default.
    
    The filtering mask is writeable, but only values that don't forward
    known control frames are allowed. It intentionally blocks attempts
    to filter control protocols. For example: writing a 8 allows
    forwarding 802.1X PAE addresses which is the most common request.
    
    Reported-by: David Lamparter <equinox@diac24.net>
    Original-patch-by: Nick Carter <ncarter100@gmail.com>
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Tested-by: Benjamin Poirier <benjamin.poirier@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 78cc364997d9..a248fe65b29a 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -29,6 +29,11 @@
 
 #define BR_VERSION	"2.3"
 
+/* Control of forwarding link local multicast */
+#define BR_GROUPFWD_DEFAULT	0
+/* Don't allow forwarding control protocols like STP and LLDP */
+#define BR_GROUPFWD_RESTRICTED	0x4007u
+
 /* Path to usermode spanning tree program */
 #define BR_STP_PROG	"/sbin/bridge-stp"
 
@@ -193,6 +198,8 @@ struct net_bridge
 	unsigned long			flags;
 #define BR_SET_MAC_ADDR		0x00000001
 
+	u16				group_fwd_mask;
+
 	/* STP */
 	bridge_id			designated_root;
 	bridge_id			bridge_id;

commit 0c03150e7ea8f7fcd03cfef29385e0010b22ee92
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Fri Jul 22 07:47:06 2011 +0000

    bridge: send proper message_age in config BPDU
    
    A bridge topology with three systems:
    
          +------+  +------+
          | A(2) |--| B(1) |
          +------+  +------+
               \    /
              +------+
              | C(3) |
              +------+
    
    What is supposed to happen:
     * bridge with the lowest ID is elected root (for example: B)
     * C detects that A->C is higher cost path and puts in blocking state
    
    What happens. Bridge with lowest id (B) is elected correctly as
    root and things start out fine initially. But then config BPDU
    doesn't get transmitted from A -> C. Because of that
    the link from A-C is transistioned to the forwarding state.
    
    The root cause of this is that the configuration messages
    is generated with bogus message age, and dropped before
    sending.
    
    In the standardmessage_age is supposed to be:
      the time since the generation of the Configuration BPDU by
      the Root that instigated the generation of this Configuration BPDU.
    
    Reimplement this by recording the timestamp (age + jiffies) when
    recording config information. The old code incorrectly used the time
    elapsed on the ageing timer which was incorrect.
    
    See also:
      https://bugzilla.vyatta.com/show_bug.cgi?id=7164
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 54578f274d85..78cc364997d9 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -124,6 +124,7 @@ struct net_bridge_port
 	bridge_id			designated_bridge;
 	u32				path_cost;
 	u32				designated_cost;
+	unsigned long			designated_age;
 
 	struct timer_list		forward_delay_timer;
 	struct timer_list		hold_timer;

commit c4d27ef957cd9261c0bc8488edaf8390e412cd35
Author: Micha Mirosaw <mirq-linux@rere.qmqm.pl>
Date:   Fri Apr 22 06:31:16 2011 +0000

    bridge: convert br_features_recompute() to ndo_fix_features
    
    Note: netdev_update_features() needs only rtnl_lock as br->port_list
    is only changed while holding it.
    
    Signed-off-by: Micha Mirosaw <mirq-linux@rere.qmqm.pl>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e2a40343aa09..54578f274d85 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -183,7 +183,6 @@ struct net_bridge
 	struct br_cpu_netstats __percpu *stats;
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
-	u32				feature_mask;
 #ifdef CONFIG_BRIDGE_NETFILTER
 	struct rtable 			fake_rtable;
 	bool				nf_call_iptables;
@@ -379,7 +378,7 @@ extern int br_add_if(struct net_bridge *br,
 extern int br_del_if(struct net_bridge *br,
 	      struct net_device *dev);
 extern int br_min_mtu(const struct net_bridge *br);
-extern void br_features_recompute(struct net_bridge *br);
+extern u32 br_features_recompute(struct net_bridge *br, u32 features);
 
 /* br_input.c */
 extern int br_handle_frame_finish(struct sk_buff *skb);

commit 14f98f258f1936e0dba77474bd7eda63f61a9826
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon Apr 4 14:03:33 2011 +0000

    bridge: range check STP parameters
    
    Apply restrictions on STP parameters based 802.1D 1998 standard.
       * Fixes missing locking in set path cost ioctl
       * Uses common code for both ioctl and sysfs
    
    This is based on an earlier patch Sasikanth V but with overhaul.
    
    Note:
    1. It does NOT enforce the restriction on the relationship max_age and
       forward delay or hello time because in existing implementation these are
       set as independant operations.
    
    2. If STP is disabled, there is no restriction on forward delay
    
    3. No restriction on holding time because users use Linux code to act
       as hub or be sticky.
    
    4. Although standard allow 0-255, Linux only allows 0-63 for port priority
       because more bits are reserved for port number.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 4bbe0d14c9a2..e2a40343aa09 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -495,6 +495,11 @@ extern struct net_bridge_port *br_get_port(struct net_bridge *br,
 extern void br_init_port(struct net_bridge_port *p);
 extern void br_become_designated_port(struct net_bridge_port *p);
 
+extern int br_set_forward_delay(struct net_bridge *br, unsigned long x);
+extern int br_set_hello_time(struct net_bridge *br, unsigned long x);
+extern int br_set_max_age(struct net_bridge *br, unsigned long x);
+
+
 /* br_stp_if.c */
 extern void br_stp_enable_bridge(struct net_bridge *br);
 extern void br_stp_disable_bridge(struct net_bridge *br);
@@ -505,10 +510,10 @@ extern bool br_stp_recalculate_bridge_id(struct net_bridge *br);
 extern void br_stp_change_bridge_id(struct net_bridge *br, const unsigned char *a);
 extern void br_stp_set_bridge_priority(struct net_bridge *br,
 				       u16 newprio);
-extern void br_stp_set_port_priority(struct net_bridge_port *p,
-				     u8 newprio);
-extern void br_stp_set_path_cost(struct net_bridge_port *p,
-				 u32 path_cost);
+extern int br_stp_set_port_priority(struct net_bridge_port *p,
+				    unsigned long newprio);
+extern int br_stp_set_path_cost(struct net_bridge_port *p,
+				unsigned long path_cost);
 extern ssize_t br_show_bridge_id(char *buf, const struct bridge_id *id);
 
 /* br_stp_bpdu.c */

commit 36fd2b63e3b4336744cf3f6a6c9543ecbec334a7
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon Apr 4 14:03:31 2011 +0000

    bridge: allow creating/deleting fdb entries via netlink
    
    Use RTM_NEWNEIGH and RTM_DELNEIGH to allow updating of entries
    in bridge forwarding table. This allows manipulating static entries
    which is not possible with existing tools.
    
    Example (using bridge extensions to iproute2)
       # br fdb add 00:02:03:04:05:06 dev eth0
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 884d245a205a..4bbe0d14c9a2 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -355,6 +355,8 @@ extern void br_fdb_update(struct net_bridge *br,
 			  struct net_bridge_port *source,
 			  const unsigned char *addr);
 extern int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb);
+extern int br_fdb_add(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg);
+extern int br_fdb_delete(struct sk_buff *skb, struct nlmsghdr *nlh, void *arg);
 
 /* br_forward.c */
 extern void br_deliver(const struct net_bridge_port *to,

commit b078f0df676233fc7ebc1ab270bd11ef5824bb64
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon Apr 4 14:03:30 2011 +0000

    bridge: add netlink notification on forward entry changes
    
    This allows applications to query and monitor bridge forwarding
    table in the same method used for neighbor table. The forward table
    entries are returned in same structure format as used by the ioctl.
    If more information is desired in future, the netlink method is
    extensible.
    
    Example (using bridge extensions to iproute2)
      # br monitor
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index a0e6b94c515b..884d245a205a 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -354,6 +354,7 @@ extern int br_fdb_insert(struct net_bridge *br,
 extern void br_fdb_update(struct net_bridge *br,
 			  struct net_bridge_port *source,
 			  const unsigned char *addr);
+extern int br_fdb_dump(struct sk_buff *skb, struct netlink_callback *cb);
 
 /* br_forward.c */
 extern void br_deliver(const struct net_bridge_port *to,

commit 7cd8861ab0d907430bbea0af93bc41aee0437efc
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon Apr 4 14:03:28 2011 +0000

    bridge: track last used time in forwarding table
    
    Adds tracking the last used time in forwarding table.
    Rename ageing_timer to updated to better describe it.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 387013d33745..a0e6b94c515b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -64,7 +64,8 @@ struct net_bridge_fdb_entry
 	struct net_bridge_port		*dst;
 
 	struct rcu_head			rcu;
-	unsigned long			ageing_timer;
+	unsigned long			updated;
+	unsigned long			used;
 	mac_addr			addr;
 	unsigned char			is_local;
 	unsigned char			is_static;

commit edf947f10074fea27fdb1730524dca59355a1c40
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Thu Mar 24 13:24:01 2011 +0000

    bridge: notify applications if address of bridge device changes
    
    The mac address of the bridge device may be changed when a new interface
    is added to the bridge. If this happens, then the bridge needs to call
    the network notifiers to tickle any other systems that care. Since bridge
    can be a module, this also means exporting the notifier function.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 19e2f46ed086..387013d33745 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -497,7 +497,7 @@ extern void br_stp_disable_bridge(struct net_bridge *br);
 extern void br_stp_set_enabled(struct net_bridge *br, unsigned long val);
 extern void br_stp_enable_port(struct net_bridge_port *p);
 extern void br_stp_disable_port(struct net_bridge_port *p);
-extern void br_stp_recalculate_bridge_id(struct net_bridge *br);
+extern bool br_stp_recalculate_bridge_id(struct net_bridge *br);
 extern void br_stp_change_bridge_id(struct net_bridge *br, const unsigned char *a);
 extern void br_stp_set_bridge_priority(struct net_bridge *br,
 				       u16 newprio);

commit 8a4eb5734e8d1dc60a8c28576bbbdfdcc643626d
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Sat Mar 12 03:14:39 2011 +0000

    net: introduce rx_handler results and logic around that
    
    This patch allows rx_handlers to better signalize what to do next to
    it's caller. That makes skb->deliver_no_wcard no longer needed.
    
    kernel-doc for rx_handler_result is taken from Nicolas' patch.
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Reviewed-by: Nicolas de Pesloan <nicolas.2p.debian@free.fr>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f7afc364d777..19e2f46ed086 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -379,7 +379,7 @@ extern void br_features_recompute(struct net_bridge *br);
 
 /* br_input.c */
 extern int br_handle_frame_finish(struct sk_buff *skb);
-extern struct sk_buff *br_handle_frame(struct sk_buff *skb);
+extern rx_handler_result_t br_handle_frame(struct sk_buff **pskb);
 
 /* br_ioctl.c */
 extern int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);

commit da935c66bacb3ed9ada984b053297f87c2dff63a
Merge: 9435eb1cf0b7 2205a6ea93fe
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Feb 19 19:17:35 2011 -0800

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            Documentation/feature-removal-schedule.txt
            drivers/net/e1000e/netdev.c
            net/xfrm/xfrm_policy.c

commit 8a870178c0ad1bae9994c99bd01eb10c9903e616
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sat Feb 12 01:05:42 2011 -0800

    bridge: Replace mp->mglist hlist with a bool
    
    As it turns out we never need to walk through the list of multicast
    groups subscribed by the bridge interface itself (the only time we'd
    want to do that is when we shut down the bridge, in which case we
    simply walk through all multicast groups), we don't really need to
    keep an hlist for mp->mglist.
    
    This means that we can replace it with just a single bit to indicate
    whether the bridge interface is subscribed to a group.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 84aac7734bfc..4e1b620b6be6 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -84,13 +84,13 @@ struct net_bridge_port_group {
 struct net_bridge_mdb_entry
 {
 	struct hlist_node		hlist[2];
-	struct hlist_node		mglist;
 	struct net_bridge		*br;
 	struct net_bridge_port_group __rcu *ports;
 	struct rcu_head			rcu;
 	struct timer_list		timer;
 	struct timer_list		query_timer;
 	struct br_ip			addr;
+	bool				mglist;
 	u32				queries_sent;
 };
 
@@ -238,7 +238,6 @@ struct net_bridge
 	spinlock_t			multicast_lock;
 	struct net_bridge_mdb_htable __rcu *mdb;
 	struct hlist_head		router_list;
-	struct hlist_head		mglist;
 
 	struct timer_list		multicast_router_timer;
 	struct timer_list		multicast_querier_timer;

commit 04ed3e741d0f133e02bed7fa5c98edba128f90e7
Author: Micha Mirosaw <mirq-linux@rere.qmqm.pl>
Date:   Mon Jan 24 15:32:47 2011 -0800

    net: change netdev->features to u32
    
    Quoting Ben Hutchings: we presumably won't be defining features that
    can only be enabled on 64-bit architectures.
    
    Occurences found by `grep -r` on net/, drivers/net, include/
    
    [ Move features and vlan_features next to each other in
      struct netdev, as per Eric Dumazet's suggestion -DaveM ]
    
    Signed-off-by: Micha Mirosaw <mirq-linux@rere.qmqm.pl>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 84aac7734bfc..9f22898c5359 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -182,7 +182,7 @@ struct net_bridge
 	struct br_cpu_netstats __percpu *stats;
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
-	unsigned long			feature_mask;
+	u32				feature_mask;
 #ifdef CONFIG_BRIDGE_NETFILTER
 	struct rtable 			fake_rtable;
 	bool				nf_call_iptables;

commit ec1e5610c00c7f5bc530d2aadd47faa473b90a30
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Mon Nov 15 06:38:14 2010 +0000

    bridge: add RCU annotations to bridge port lookup
    
    br_port_get() renamed to br_port_get_rtnl() to make clear RTNL is held.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 46e0bec1d7c5..84aac7734bfc 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -159,9 +159,10 @@ static inline struct net_bridge_port *br_port_get_rcu(const struct net_device *d
 	return br_port_exists(dev) ? port : NULL;
 }
 
-static inline struct net_bridge_port *br_port_get(struct net_device *dev)
+static inline struct net_bridge_port *br_port_get_rtnl(struct net_device *dev)
 {
-	return br_port_exists(dev) ? dev->rx_handler_data : NULL;
+	return br_port_exists(dev) ?
+		rtnl_dereference(dev->rx_handler_data) : NULL;
 }
 
 struct br_cpu_netstats {

commit b5ed54e94d324f17c97852296d61a143f01b227a
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon Nov 15 06:38:13 2010 +0000

    bridge: fix RCU races with bridge port
    
    The macro br_port_exists() is not enough protection when only
    RCU is being used. There is a tiny race where other CPU has cleared port
    handler hook, but is bridge port flag might still be set.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index b862071bf601..46e0bec1d7c5 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -151,11 +151,19 @@ struct net_bridge_port
 #endif
 };
 
-#define br_port_get_rcu(dev) \
-	((struct net_bridge_port *) rcu_dereference(dev->rx_handler_data))
-#define br_port_get(dev) ((struct net_bridge_port *) dev->rx_handler_data)
 #define br_port_exists(dev) (dev->priv_flags & IFF_BRIDGE_PORT)
 
+static inline struct net_bridge_port *br_port_get_rcu(const struct net_device *dev)
+{
+	struct net_bridge_port *port = rcu_dereference(dev->rx_handler_data);
+	return br_port_exists(dev) ? port : NULL;
+}
+
+static inline struct net_bridge_port *br_port_get(struct net_device *dev)
+{
+	return br_port_exists(dev) ? dev->rx_handler_data : NULL;
+}
+
 struct br_cpu_netstats {
 	u64			rx_packets;
 	u64			rx_bytes;

commit e80516880019aa1f7c5c410276edfea9575ec89f
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Mon Nov 15 06:38:10 2010 +0000

    bridge: add RCU annotation to bridge multicast table
    
    Add modern __rcu annotatations to bridge multicast table.
    Use newer hlist macros to avoid direct access to hlist internals.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 75c90edaf7db..b862071bf601 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -72,7 +72,7 @@ struct net_bridge_fdb_entry
 
 struct net_bridge_port_group {
 	struct net_bridge_port		*port;
-	struct net_bridge_port_group	*next;
+	struct net_bridge_port_group __rcu *next;
 	struct hlist_node		mglist;
 	struct rcu_head			rcu;
 	struct timer_list		timer;
@@ -86,7 +86,7 @@ struct net_bridge_mdb_entry
 	struct hlist_node		hlist[2];
 	struct hlist_node		mglist;
 	struct net_bridge		*br;
-	struct net_bridge_port_group	*ports;
+	struct net_bridge_port_group __rcu *ports;
 	struct rcu_head			rcu;
 	struct timer_list		timer;
 	struct timer_list		query_timer;
@@ -227,7 +227,7 @@ struct net_bridge
 	unsigned long			multicast_startup_query_interval;
 
 	spinlock_t			multicast_lock;
-	struct net_bridge_mdb_htable	*mdb;
+	struct net_bridge_mdb_htable __rcu *mdb;
 	struct hlist_head		router_list;
 	struct hlist_head		mglist;
 

commit e490c1defec4236a6a131fe2d13bf7ba787c02f8
Merge: 0a17d8c744e4 4df53d8bab65
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jul 2 22:42:06 2010 -0700

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/kaber/nf-next-2.6

commit 4df53d8bab65cf2c18daebd51a5a4847e03f1943
Author: Patrick McHardy <kaber@trash.net>
Date:   Fri Jul 2 09:32:57 2010 +0200

    bridge: add per bridge device controls for invoking iptables
    
    Support more fine grained control of bridge netfilter iptables invocation
    by adding seperate brnf_call_*tables parameters for each device using the
    sysfs interface. Packets are passed to layer 3 netfilter when either the
    global parameter or the per bridge parameter is enabled.
    
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Patrick McHardy <kaber@trash.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c83519b555bb..7484065da303 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -164,6 +164,9 @@ struct net_bridge
 	unsigned long			feature_mask;
 #ifdef CONFIG_BRIDGE_NETFILTER
 	struct rtable 			fake_rtable;
+	bool				nf_call_iptables;
+	bool				nf_call_ip6tables;
+	bool				nf_call_arptables;
 #endif
 	unsigned long			flags;
 #define BR_SET_MAC_ADDR		0x00000001

commit 406818ff347cbbdae2fb21fafd1939d00cf479c5
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Jun 23 13:00:48 2010 -0700

    bridge: 64bit rx/tx counters
    
    Use u64_stats_sync infrastructure to provide 64bit rx/tx
    counters even on 32bit hosts.
    
    It is safe to use a single u64_stats_sync for rx and tx,
    because BH is disabled on both, and we use per_cpu data.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 07cf57b373fe..3f0678fd1fd0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -16,6 +16,7 @@
 #include <linux/netdevice.h>
 #include <linux/if_bridge.h>
 #include <linux/netpoll.h>
+#include <linux/u64_stats_sync.h>
 #include <net/route.h>
 
 #define BR_HASH_BITS 8
@@ -156,10 +157,11 @@ struct net_bridge_port
 #define br_port_exists(dev) (dev->priv_flags & IFF_BRIDGE_PORT)
 
 struct br_cpu_netstats {
-	unsigned long	rx_packets;
-	unsigned long	rx_bytes;
-	unsigned long	tx_packets;
-	unsigned long	tx_bytes;
+	u64			rx_packets;
+	u64			rx_bytes;
+	u64			tx_packets;
+	u64			tx_bytes;
+	struct u64_stats_sync	syncp;
 };
 
 struct net_bridge

commit 9f70b0fcecd134890affe627aa2823591313a413
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Tue Jun 15 21:43:48 2010 -0700

    bridge: Add const to dummy br_netpoll_send_skb
    
    The version of br_netpoll_send_skb used when netpoll is off is
    missing a const thus causing a warning.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f6bc979b1135..07cf57b373fe 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -305,7 +305,7 @@ static inline struct netpoll_info *br_netpoll_info(struct net_bridge *br)
 	return NULL;
 }
 
-static inline void br_netpoll_send_skb(struct net_bridge_port *p,
+static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
 				       struct sk_buff *skb)
 {
 }

commit f350a0a87374418635689471606454abc7beaa3a
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Tue Jun 15 06:50:45 2010 +0000

    bridge: use rx_handler_data pointer to store net_bridge_port pointer
    
    Register net_bridge_port pointer as rx_handler data pointer. As br_port is
    removed from struct net_device, another netdev priv_flag is added to indicate
    the device serves as a bridge port. Also rcuized pointers are now correctly
    dereferenced in br_fdb.c and in netfilter parts.
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 0f5394c4f2f1..f6bc979b1135 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -150,6 +150,11 @@ struct net_bridge_port
 #endif
 };
 
+#define br_port_get_rcu(dev) \
+	((struct net_bridge_port *) rcu_dereference(dev->rx_handler_data))
+#define br_port_get(dev) ((struct net_bridge_port *) dev->rx_handler_data)
+#define br_port_exists(dev) (dev->priv_flags & IFF_BRIDGE_PORT)
+
 struct br_cpu_netstats {
 	unsigned long	rx_packets;
 	unsigned long	rx_bytes;

commit 91d2c34a4eed32876ca333b0ca44f3bc56645805
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Thu Jun 10 16:12:50 2010 +0000

    bridge: Fix netpoll support
    
    There are multiple problems with the newly added netpoll support:
    
    1) Use-after-free on each netpoll packet.
    2) Invoking unsafe code on netpoll/IRQ path.
    3) Breaks when netpoll is enabled on the underlying device.
    
    This patch fixes all of these problems.  In particular, we now
    allocate proper netpoll structures for each underlying device.
    
    We only allow netpoll to be enabled on the bridge when all the
    devices underneath it support netpoll.  Once it is enabled, we
    do not allow non-netpoll devices to join the bridge (until netpoll
    is disabled again).
    
    This allows us to do away with the npinfo juggling that caused
    problem number 1.
    
    Incidentally this patch fixes number 2 by bypassing unsafe code
    such as multicast snooping and netfilter.
    
    Reported-by: Qianfeng Zhang <frzhang@redhat.com>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c83519b555bb..0f5394c4f2f1 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -15,6 +15,7 @@
 
 #include <linux/netdevice.h>
 #include <linux/if_bridge.h>
+#include <linux/netpoll.h>
 #include <net/route.h>
 
 #define BR_HASH_BITS 8
@@ -143,6 +144,10 @@ struct net_bridge_port
 #ifdef CONFIG_SYSFS
 	char				sysfs_name[IFNAMSIZ];
 #endif
+
+#ifdef CONFIG_NET_POLL_CONTROLLER
+	struct netpoll			*np;
+#endif
 };
 
 struct br_cpu_netstats {
@@ -273,16 +278,41 @@ extern void br_dev_setup(struct net_device *dev);
 extern netdev_tx_t br_dev_xmit(struct sk_buff *skb,
 			       struct net_device *dev);
 #ifdef CONFIG_NET_POLL_CONTROLLER
-extern void br_netpoll_cleanup(struct net_device *dev);
-extern void br_netpoll_enable(struct net_bridge *br,
-			      struct net_device *dev);
-extern void br_netpoll_disable(struct net_bridge *br,
-			       struct net_device *dev);
+static inline struct netpoll_info *br_netpoll_info(struct net_bridge *br)
+{
+	return br->dev->npinfo;
+}
+
+static inline void br_netpoll_send_skb(const struct net_bridge_port *p,
+				       struct sk_buff *skb)
+{
+	struct netpoll *np = p->np;
+
+	if (np)
+		netpoll_send_skb(np, skb);
+}
+
+extern int br_netpoll_enable(struct net_bridge_port *p);
+extern void br_netpoll_disable(struct net_bridge_port *p);
 #else
-#define br_netpoll_cleanup(br)
-#define br_netpoll_enable(br, dev)
-#define br_netpoll_disable(br, dev)
+static inline struct netpoll_info *br_netpoll_info(struct net_bridge *br)
+{
+	return NULL;
+}
+
+static inline void br_netpoll_send_skb(struct net_bridge_port *p,
+				       struct sk_buff *skb)
+{
+}
 
+static inline int br_netpoll_enable(struct net_bridge_port *p)
+{
+	return 0;
+}
+
+static inline void br_netpoll_disable(struct net_bridge_port *p)
+{
+}
 #endif
 
 /* br_fdb.c */

commit ab95bfe01f9872459c8678572ccadbf646badad0
Author: Jiri Pirko <jpirko@redhat.com>
Date:   Tue Jun 1 21:52:08 2010 +0000

    net: replace hooks in __netif_receive_skb V5
    
    What this patch does is it removes two receive frame hooks (for bridge and for
    macvlan) from __netif_receive_skb. These are replaced them with a single
    hook for both. It only supports one hook per device because it makes no
    sense to do bridging and macvlan on the same device.
    
    Then a network driver (of virtual netdev like macvlan or bridge) can register
    an rx_handler for needed net device.
    
    Signed-off-by: Jiri Pirko <jpirko@redhat.com>
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 0f4a74bc6a9b..c83519b555bb 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -331,8 +331,7 @@ extern void br_features_recompute(struct net_bridge *br);
 
 /* br_input.c */
 extern int br_handle_frame_finish(struct sk_buff *skb);
-extern struct sk_buff *br_handle_frame(struct net_bridge_port *p,
-				       struct sk_buff *skb);
+extern struct sk_buff *br_handle_frame(struct sk_buff *skb);
 
 /* br_ioctl.c */
 extern int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);

commit e0f43752a942b7be1bc06b9fd74e20ae337c1cca
Author: Simon Arlott <simon@fire.lp0.eu>
Date:   Mon May 10 09:31:11 2010 +0000

    bridge: update sysfs link names if port device names have changed
    
    Links for each port are created in sysfs using the device
    name, but this could be changed after being added to the
    bridge.
    
    As well as being unable to remove interfaces after this
    occurs (because userspace tools don't recognise the new
    name, and the kernel won't recognise the old name), adding
    another interface with the old name to the bridge will
    cause an error trying to create the sysfs link.
    
    This fixes the problem by listening for NETDEV_CHANGENAME
    notifications and renaming the link.
    
    https://bugzilla.kernel.org/show_bug.cgi?id=12743
    
    Signed-off-by: Simon Arlott <simon@fire.lp0.eu>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 79a13d1c2573..0f4a74bc6a9b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -139,6 +139,10 @@ struct net_bridge_port
 	struct hlist_head		mglist;
 	struct hlist_node		rlist;
 #endif
+
+#ifdef CONFIG_SYSFS
+	char				sysfs_name[IFNAMSIZ];
+#endif
 };
 
 struct br_cpu_netstats {
@@ -480,6 +484,7 @@ extern void br_ifinfo_notify(int event, struct net_bridge_port *port);
 /* br_sysfs_if.c */
 extern const struct sysfs_ops brport_sysfs_ops;
 extern int br_sysfs_addif(struct net_bridge_port *p);
+extern int br_sysfs_renameif(struct net_bridge_port *p);
 
 /* br_sysfs_br.c */
 extern int br_sysfs_addbr(struct net_device *dev);
@@ -488,6 +493,7 @@ extern void br_sysfs_delbr(struct net_device *dev);
 #else
 
 #define br_sysfs_addif(p)	(0)
+#define br_sysfs_renameif(p)	(0)
 #define br_sysfs_addbr(dev)	(0)
 #define br_sysfs_delbr(dev)	do { } while(0)
 #endif /* CONFIG_SYSFS */

commit 28a16c97963d3bc36a2c192859f6d8025ef2967a
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon May 10 09:31:09 2010 +0000

    bridge: change console message interface
    
    Use one set of macro's for all bridge messages.
    
    Note: can't use netdev_XXX macro's because bridge is purely
    virtual and has no device parent.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8a072661a744..79a13d1c2573 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -240,6 +240,21 @@ struct br_input_skb_cb {
 # define BR_INPUT_SKB_CB_MROUTERS_ONLY(__skb)	(0)
 #endif
 
+#define br_printk(level, br, format, args...)	\
+	printk(level "%s: " format, (br)->dev->name, ##args)
+
+#define br_err(__br, format, args...)			\
+	br_printk(KERN_ERR, __br, format, ##args)
+#define br_warn(__br, format, args...)			\
+	br_printk(KERN_WARNING, __br, format, ##args)
+#define br_notice(__br, format, args...)		\
+	br_printk(KERN_NOTICE, __br, format, ##args)
+#define br_info(__br, format, args...)			\
+	br_printk(KERN_INFO, __br, format, ##args)
+
+#define br_debug(br, format, args...)			\
+	pr_debug("%s: " format,  (br)->dev->name, ##args)
+
 extern struct notifier_block br_device_notifier;
 extern const u8 br_group_address[ETH_ALEN];
 

commit cfb478da70f2213520866c84cb0aea0d7c0e1148
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Mon May 10 09:31:08 2010 +0000

    bridge: netpoll cleanup
    
    Move code around so that the ifdef for NETPOLL_CONTROLLER don't have to
    show up in main code path. The control functions should be in helpers
    that are only compiled if needed.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3d2d3fe0a97e..8a072661a744 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -253,8 +253,18 @@ static inline int br_is_root_bridge(const struct net_bridge *br)
 extern void br_dev_setup(struct net_device *dev);
 extern netdev_tx_t br_dev_xmit(struct sk_buff *skb,
 			       struct net_device *dev);
-extern bool br_devices_support_netpoll(struct net_bridge *br);
-extern void br_netpoll_cleanup(struct net_device *br_dev);
+#ifdef CONFIG_NET_POLL_CONTROLLER
+extern void br_netpoll_cleanup(struct net_device *dev);
+extern void br_netpoll_enable(struct net_bridge *br,
+			      struct net_device *dev);
+extern void br_netpoll_disable(struct net_bridge *br,
+			       struct net_device *dev);
+#else
+#define br_netpoll_cleanup(br)
+#define br_netpoll_enable(br, dev)
+#define br_netpoll_disable(br, dev)
+
+#endif
 
 /* br_fdb.c */
 extern int br_fdb_init(void);

commit c06ee961d3c0e51009cbd0e123b61fbb97f37d0b
Author: WANG Cong <amwang@redhat.com>
Date:   Thu May 6 00:48:24 2010 -0700

    bridge: make bridge support netpoll
    
    Based on the previous patch, make bridge support netpoll by:
    
    1) implement the 2 methods to support netpoll for bridge;
    
    2) modify netpoll during forwarding packets via bridge;
    
    3) disable netpoll support of bridge when a netpoll-unabled device
       is added to bridge;
    
    4) enable netpoll support when all underlying devices support netpoll.
    
    Cc: David Miller <davem@davemloft.net>
    Cc: Neil Horman <nhorman@tuxdriver.com>
    Cc: Stephen Hemminger <shemminger@linux-foundation.org>
    Cc: Matt Mackall <mpm@selenic.com>
    Signed-off-by: WANG Cong <amwang@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 018499ebe19d..3d2d3fe0a97e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -253,6 +253,8 @@ static inline int br_is_root_bridge(const struct net_bridge *br)
 extern void br_dev_setup(struct net_device *dev);
 extern netdev_tx_t br_dev_xmit(struct sk_buff *skb,
 			       struct net_device *dev);
+extern bool br_devices_support_netpoll(struct net_bridge *br);
+extern void br_netpoll_cleanup(struct net_device *br_dev);
 
 /* br_fdb.c */
 extern int br_fdb_init(void);

commit 08b202b6726459626c73ecfa08fcdc8c3efc76c2
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Apr 23 01:54:22 2010 +0900

    bridge br_multicast: IPv6 MLD support.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 45d11e49fbbb..018499ebe19d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -49,6 +49,9 @@ struct br_ip
 {
 	union {
 		__be32	ip4;
+#if defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
+		struct in6_addr ip6;
+#endif
 	} u;
 	__be16		proto;
 };

commit 8ef2a9a59854994bace13b5c4f7edc2c8d4d124e
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Sun Apr 18 12:42:07 2010 +0900

    bridge br_multicast: Make functions less ipv4 dependent.
    
    Introduce struct br_ip{} to store ip address and protocol
    and make functions more generic so that we can support
    both IPv4 and IPv6 with less pain.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 63181e4a2a67..45d11e49fbbb 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -45,6 +45,14 @@ struct mac_addr
 	unsigned char	addr[6];
 };
 
+struct br_ip
+{
+	union {
+		__be32	ip4;
+	} u;
+	__be16		proto;
+};
+
 struct net_bridge_fdb_entry
 {
 	struct hlist_node		hlist;
@@ -64,7 +72,7 @@ struct net_bridge_port_group {
 	struct rcu_head			rcu;
 	struct timer_list		timer;
 	struct timer_list		query_timer;
-	__be32				addr;
+	struct br_ip			addr;
 	u32				queries_sent;
 };
 
@@ -77,7 +85,7 @@ struct net_bridge_mdb_entry
 	struct rcu_head			rcu;
 	struct timer_list		timer;
 	struct timer_list		query_timer;
-	__be32				addr;
+	struct br_ip			addr;
 	u32				queries_sent;
 };
 

commit 0eae88f31ca2b88911ce843452054139e028771f
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Tue Apr 20 19:06:52 2010 -0700

    net: Fix various endianness glitches
    
    Sparse can help us find endianness bugs, but we need to make some
    cleanups to be able to more easily spot real bugs.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 791d4ab0fd4d..63181e4a2a67 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -130,19 +130,20 @@ struct net_bridge_port
 #endif
 };
 
+struct br_cpu_netstats {
+	unsigned long	rx_packets;
+	unsigned long	rx_bytes;
+	unsigned long	tx_packets;
+	unsigned long	tx_bytes;
+};
+
 struct net_bridge
 {
 	spinlock_t			lock;
 	struct list_head		port_list;
 	struct net_device		*dev;
 
-	struct br_cpu_netstats __percpu {
-		unsigned long	rx_packets;
-		unsigned long	rx_bytes;
-		unsigned long	tx_packets;
-		unsigned long	tx_bytes;
-	} *stats;
-
+	struct br_cpu_netstats __percpu *stats;
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
 	unsigned long			feature_mask;

commit 14bb4789833a2e2610f30e2d3e1451701ac96ec1
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Tue Mar 2 13:32:09 2010 +0000

    bridge: per-cpu packet statistics (v3)
    
    The shared packet statistics are a potential source of slow down
    on bridged traffic. Convert to per-cpu array, but only keep those
    statistics which change per-packet.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 846d7d1e2075..791d4ab0fd4d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -135,6 +135,14 @@ struct net_bridge
 	spinlock_t			lock;
 	struct list_head		port_list;
 	struct net_device		*dev;
+
+	struct br_cpu_netstats __percpu {
+		unsigned long	rx_packets;
+		unsigned long	rx_bytes;
+		unsigned long	tx_packets;
+		unsigned long	tx_bytes;
+	} *stats;
+
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
 	unsigned long			feature_mask;

commit 32dec5dd0233ebffa9cae25ce7ba6daeb7df4467
Author: YOSHIFUJI Hideaki /  <yoshfuji@linux-ipv6.org>
Date:   Mon Mar 15 21:51:18 2010 +0000

    bridge br_multicast: Don't refer to BR_INPUT_SKB_CB(skb)->mrouters_only without IGMP snooping.
    
    Without CONFIG_BRIDGE_IGMP_SNOOPING,
    BR_INPUT_SKB_CB(skb)->mrouters_only is not appropriately
    initialized, so we can see garbage.
    
    A clear option to fix this is to set it even without that
    config, but we cannot optimize out the branch.
    
    Let's introduce a macro that returns value of mrouters_only
    and let it return 0 without CONFIG_BRIDGE_IGMP_SNOOPING.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index bfb8feb310a6..846d7d1e2075 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -206,12 +206,20 @@ struct net_bridge
 
 struct br_input_skb_cb {
 	struct net_device *brdev;
+#ifdef CONFIG_BRIDGE_IGMP_SNOOPING
 	int igmp;
 	int mrouters_only;
+#endif
 };
 
 #define BR_INPUT_SKB_CB(__skb)	((struct br_input_skb_cb *)(__skb)->cb)
 
+#ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+# define BR_INPUT_SKB_CB_MROUTERS_ONLY(__skb)	(BR_INPUT_SKB_CB(__skb)->mrouters_only)
+#else
+# define BR_INPUT_SKB_CB_MROUTERS_ONLY(__skb)	(0)
+#endif
+
 extern struct notifier_block br_device_notifier;
 extern const u8 br_group_address[ETH_ALEN];
 

commit 7f7708f0055e49e331f267700aa8b2ee879f004c
Author: Michael Braun <michael-dev@fami-braun.de>
Date:   Tue Mar 16 00:26:22 2010 -0700

    bridge: Fix br_forward crash in promiscuous mode
    
    From: Michael Braun <michael-dev@fami-braun.de>
    
    bridge: Fix br_forward crash in promiscuous mode
    
    It's a linux-next kernel from 2010-03-12 on an x86 system and it
    OOPs in the bridge module in br_pass_frame_up (called by
    br_handle_frame_finish) because brdev cannot be dereferenced (its set to
    a non-null value).
    
    Adding some BUG_ON statements revealed that
     BR_INPUT_SKB_CB(skb)->brdev == br-dev
    (as set in br_handle_frame_finish first)
    only holds until br_forward is called.
    The next call to br_pass_frame_up then fails.
    
    Digging deeper it seems that br_forward either frees the skb or passes
    it to NF_HOOK which will in turn take care of freeing the skb. The
    same is holds for br_pass_frame_ip. So it seems as if two independent
    skb allocations are required. As far as I can see, commit
    b33084be192ee1e347d98bb5c9e38a53d98d35e2 ("bridge: Avoid unnecessary
    clone on forward path") removed skb duplication and so likely causes
    this crash. This crash does not happen on 2.6.33.
    
    I've therefore modified br_forward the same way br_flood has been
    modified so that the skb is not freed if skb0 is going to be used
    and I can confirm that the attached patch resolves the issue for me.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index fef0384e3c0b..bfb8feb310a6 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -252,7 +252,7 @@ extern void br_deliver(const struct net_bridge_port *to,
 		struct sk_buff *skb);
 extern int br_dev_queue_push_xmit(struct sk_buff *skb);
 extern void br_forward(const struct net_bridge_port *to,
-		struct sk_buff *skb);
+		struct sk_buff *skb, struct sk_buff *skb0);
 extern int br_forward_finish(struct sk_buff *skb);
 extern void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb);
 extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,

commit 52cf25d0ab7f78eeecc59ac652ed5090f69b619e
Author: Emese Revfy <re.emese@gmail.com>
Date:   Tue Jan 19 02:58:23 2010 +0100

    Driver core: Constify struct sysfs_ops in struct kobj_type
    
    Constify struct sysfs_ops.
    
    This is part of the ops structure constification
    effort started by Arjan van de Ven et al.
    
    Benefits of this constification:
    
     * prevents modification of data that is shared
       (referenced) by many other structure instances
       at runtime
    
     * detects/prevents accidental (but not intentional)
       modification attempts on archs that enforce
       read-only kernel data at runtime
    
     * potentially better optimized code as the compiler
       can assume that the const data cannot be changed
    
     * the compiler/linker move const data into .rodata
       and therefore exclude them from false sharing
    
    Signed-off-by: Emese Revfy <re.emese@gmail.com>
    Acked-by: David Teigland <teigland@redhat.com>
    Acked-by: Matt Domsch <Matt_Domsch@dell.com>
    Acked-by: Maciej Sosnowski <maciej.sosnowski@intel.com>
    Acked-by: Hans J. Koch <hjk@linutronix.de>
    Acked-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Acked-by: Jens Axboe <jens.axboe@oracle.com>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1cf2cef78584..fef0384e3c0b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -423,7 +423,7 @@ extern void br_ifinfo_notify(int event, struct net_bridge_port *port);
 
 #ifdef CONFIG_SYSFS
 /* br_sysfs_if.c */
-extern struct sysfs_ops brport_sysfs_ops;
+extern const struct sysfs_ops brport_sysfs_ops;
 extern int br_sysfs_addif(struct net_bridge_port *p);
 
 /* br_sysfs_br.c */

commit 85b3526932645269f67fee3583fa2aa500ab4f34
Author: Sridhar Samudrala <sri@us.ibm.com>
Date:   Mon Mar 1 09:53:04 2010 +0000

    bridge: Fix build error when IGMP_SNOOPING is not enabled
    
    Fix the following build error when IGMP_SNOOPING is not enabled.
    In file included from net/bridge/br.c:24:
    net/bridge/br_private.h: In function 'br_multicast_is_router':
    net/bridge/br_private.h:361: error: 'struct net_bridge' has no member named 'multicast_router'
    net/bridge/br_private.h:362: error: 'struct net_bridge' has no member named 'multicast_router'
    net/bridge/br_private.h:363: error: 'struct net_bridge' has no member named 'multicast_router_timer'
    
    Signed-off-by: Sridhar Samudrala <sri@us.ibm.com>
    Acked-by: Randy Dunlap <randy.dunlap@oracle.com>
    Acked-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 9191198c4f1b..1cf2cef78584 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -302,6 +302,13 @@ extern int br_multicast_set_port_router(struct net_bridge_port *p,
 					unsigned long val);
 extern int br_multicast_toggle(struct net_bridge *br, unsigned long val);
 extern int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
+
+static inline bool br_multicast_is_router(struct net_bridge *br)
+{
+	return br->multicast_router == 2 ||
+	       (br->multicast_router == 1 &&
+		timer_pending(&br->multicast_router_timer));
+}
 #else
 static inline int br_multicast_rcv(struct net_bridge *br,
 				   struct net_bridge_port *port,
@@ -354,14 +361,11 @@ static inline void br_multicast_forward(struct net_bridge_mdb_entry *mdst,
 					struct sk_buff *skb2)
 {
 }
-#endif
-
 static inline bool br_multicast_is_router(struct net_bridge *br)
 {
-	return br->multicast_router == 2 ||
-	       (br->multicast_router == 1 &&
-		timer_pending(&br->multicast_router_timer));
+	return 0;
 }
+#endif
 
 /* br_netfilter.c */
 #ifdef CONFIG_BRIDGE_NETFILTER

commit b195167fcf089dbdc650bb874084555035f07f98
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sat Feb 27 19:41:51 2010 +0000

    bridge: Add hash elasticity/max sysfs entries
    
    This patch allows the user to control the hash elasticity/max
    parameters.  The elasticity setting does not take effect until
    the next new multicast group is added.  At which point it is
    checked and if after rehashing it still can't be satisfied then
    snooping will be disabled.
    
    The max setting on the other hand takes effect immediately.  It
    must be a power of two and cannot be set to a value less than the
    current number of multicast group entries.  This is the only way
    to shrink the multicast hash.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index bf162fa6b23b..9191198c4f1b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -301,6 +301,7 @@ extern int br_multicast_set_router(struct net_bridge *br, unsigned long val);
 extern int br_multicast_set_port_router(struct net_bridge_port *p,
 					unsigned long val);
 extern int br_multicast_toggle(struct net_bridge *br, unsigned long val);
+extern int br_multicast_set_hash_max(struct net_bridge *br, unsigned long val);
 #else
 static inline int br_multicast_rcv(struct net_bridge *br,
 				   struct net_bridge_port *port,

commit 561f1103a2b70de7e06e1e7fd072a5b142a4278c
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sat Feb 27 19:41:50 2010 +0000

    bridge: Add multicast_snooping sysfs toggle
    
    This patch allows the user to disable IGMP snooping completely
    through a sysfs toggle.  It also allows the user to reenable
    snooping when it has been automatically disabled due to hash
    collisions.  If the collisions have not been resolved however
    the system will refuse to reenable snooping.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index dcdfafbe4b17..bf162fa6b23b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -300,6 +300,7 @@ extern void br_multicast_forward(struct net_bridge_mdb_entry *mdst,
 extern int br_multicast_set_router(struct net_bridge *br, unsigned long val);
 extern int br_multicast_set_port_router(struct net_bridge_port *p,
 					unsigned long val);
+extern int br_multicast_toggle(struct net_bridge *br, unsigned long val);
 #else
 static inline int br_multicast_rcv(struct net_bridge *br,
 				   struct net_bridge_port *port,

commit 0909e11758bd28848aeb6646e021ec1e031a3f0f
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sat Feb 27 19:41:49 2010 +0000

    bridge: Add multicast_router sysfs entries
    
    This patch allows the user to forcibly enable/disable ports as
    having multicast routers attached.  A port with a multicast router
    will receive all multicast traffic.
    
    The value 0 disables it completely.  The default is 1 which lets
    the system automatically detect the presence of routers (currently
    this is limited to picking up queries), and 2 means that the port
    will always receive all multicast traffic.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c85943c2b23f..dcdfafbe4b17 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -297,6 +297,9 @@ extern void br_multicast_deliver(struct net_bridge_mdb_entry *mdst,
 				 struct sk_buff *skb);
 extern void br_multicast_forward(struct net_bridge_mdb_entry *mdst,
 				 struct sk_buff *skb, struct sk_buff *skb2);
+extern int br_multicast_set_router(struct net_bridge *br, unsigned long val);
+extern int br_multicast_set_port_router(struct net_bridge_port *p,
+					unsigned long val);
 #else
 static inline int br_multicast_rcv(struct net_bridge *br,
 				   struct net_bridge_port *port,

commit 5cb5e947d8f82011e3d7e7017e9d10db9a40ae9f
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sat Feb 27 19:41:46 2010 +0000

    bridge: Add multicast forwarding functions
    
    This patch adds code to perform selective multicast forwarding.
    
    We forward multicast traffic to a set of ports plus all multicast
    router ports.  In order to avoid duplications among these two
    sets of ports, we order all ports by the numeric value of their
    pointers.  The two lists are then walked in lock-step to eliminate
    duplicates.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 44345c9afdd3..c85943c2b23f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -293,6 +293,10 @@ extern void br_multicast_disable_port(struct net_bridge_port *port);
 extern void br_multicast_init(struct net_bridge *br);
 extern void br_multicast_open(struct net_bridge *br);
 extern void br_multicast_stop(struct net_bridge *br);
+extern void br_multicast_deliver(struct net_bridge_mdb_entry *mdst,
+				 struct sk_buff *skb);
+extern void br_multicast_forward(struct net_bridge_mdb_entry *mdst,
+				 struct sk_buff *skb, struct sk_buff *skb2);
 #else
 static inline int br_multicast_rcv(struct net_bridge *br,
 				   struct net_bridge_port *port,
@@ -334,6 +338,17 @@ static inline void br_multicast_open(struct net_bridge *br)
 static inline void br_multicast_stop(struct net_bridge *br)
 {
 }
+
+static inline void br_multicast_deliver(struct net_bridge_mdb_entry *mdst,
+					struct sk_buff *skb)
+{
+}
+
+static inline void br_multicast_forward(struct net_bridge_mdb_entry *mdst,
+					struct sk_buff *skb,
+					struct sk_buff *skb2)
+{
+}
 #endif
 
 static inline bool br_multicast_is_router(struct net_bridge *br)

commit eb1d16414339a6e113d89e2cca2556005d7ce919
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sat Feb 27 19:41:45 2010 +0000

    bridge: Add core IGMP snooping support
    
    This patch adds the core functionality of IGMP snooping support
    without actually hooking it up.  So this patch should be a no-op
    as far as the bridge's external behaviour is concerned.
    
    All the new code and data is controlled by the Kconfig option
    BRIDGE_IGMP_SNOOPING.  A run-time toggle is also available.
    
    The multicast switching is done using an hash table that is
    lockless on the read-side through RCU.  On the write-side the
    new multicast_lock is used for all operations.  The hash table
    supports dynamic growth/rehashing.
    
    The hash table will be rehashed if any chain length exceeds a
    preset limit.  If rehashing does not reduce the maximum chain
    length then snooping will be disabled.
    
    These features may be added in future (in no particular order):
    
    * IGMPv3 source support
    * Non-querier router detection
    * IPv6
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index fad5a2669d34..44345c9afdd3 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -57,6 +57,41 @@ struct net_bridge_fdb_entry
 	unsigned char			is_static;
 };
 
+struct net_bridge_port_group {
+	struct net_bridge_port		*port;
+	struct net_bridge_port_group	*next;
+	struct hlist_node		mglist;
+	struct rcu_head			rcu;
+	struct timer_list		timer;
+	struct timer_list		query_timer;
+	__be32				addr;
+	u32				queries_sent;
+};
+
+struct net_bridge_mdb_entry
+{
+	struct hlist_node		hlist[2];
+	struct hlist_node		mglist;
+	struct net_bridge		*br;
+	struct net_bridge_port_group	*ports;
+	struct rcu_head			rcu;
+	struct timer_list		timer;
+	struct timer_list		query_timer;
+	__be32				addr;
+	u32				queries_sent;
+};
+
+struct net_bridge_mdb_htable
+{
+	struct hlist_head		*mhash;
+	struct rcu_head			rcu;
+	struct net_bridge_mdb_htable	*old;
+	u32				size;
+	u32				max;
+	u32				secret;
+	u32				ver;
+};
+
 struct net_bridge_port
 {
 	struct net_bridge		*br;
@@ -84,6 +119,15 @@ struct net_bridge_port
 
 	unsigned long 			flags;
 #define BR_HAIRPIN_MODE		0x00000001
+
+#ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+	u32				multicast_startup_queries_sent;
+	unsigned char			multicast_router;
+	struct timer_list		multicast_router_timer;
+	struct timer_list		multicast_query_timer;
+	struct hlist_head		mglist;
+	struct hlist_node		rlist;
+#endif
 };
 
 struct net_bridge
@@ -124,6 +168,35 @@ struct net_bridge
 	unsigned char			topology_change;
 	unsigned char			topology_change_detected;
 
+#ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+	unsigned char			multicast_router;
+
+	u8				multicast_disabled:1;
+
+	u32				hash_elasticity;
+	u32				hash_max;
+
+	u32				multicast_last_member_count;
+	u32				multicast_startup_queries_sent;
+	u32				multicast_startup_query_count;
+
+	unsigned long			multicast_last_member_interval;
+	unsigned long			multicast_membership_interval;
+	unsigned long			multicast_querier_interval;
+	unsigned long			multicast_query_interval;
+	unsigned long			multicast_query_response_interval;
+	unsigned long			multicast_startup_query_interval;
+
+	spinlock_t			multicast_lock;
+	struct net_bridge_mdb_htable	*mdb;
+	struct hlist_head		router_list;
+	struct hlist_head		mglist;
+
+	struct timer_list		multicast_router_timer;
+	struct timer_list		multicast_querier_timer;
+	struct timer_list		multicast_query_timer;
+#endif
+
 	struct timer_list		hello_timer;
 	struct timer_list		tcn_timer;
 	struct timer_list		topology_change_timer;
@@ -133,6 +206,8 @@ struct net_bridge
 
 struct br_input_skb_cb {
 	struct net_device *brdev;
+	int igmp;
+	int mrouters_only;
 };
 
 #define BR_INPUT_SKB_CB(__skb)	((struct br_input_skb_cb *)(__skb)->cb)
@@ -204,6 +279,70 @@ extern struct sk_buff *br_handle_frame(struct net_bridge_port *p,
 extern int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 extern int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __user *arg);
 
+/* br_multicast.c */
+#ifdef CONFIG_BRIDGE_IGMP_SNOOPING
+extern int br_multicast_rcv(struct net_bridge *br,
+			    struct net_bridge_port *port,
+			    struct sk_buff *skb);
+extern struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
+					       struct sk_buff *skb);
+extern void br_multicast_add_port(struct net_bridge_port *port);
+extern void br_multicast_del_port(struct net_bridge_port *port);
+extern void br_multicast_enable_port(struct net_bridge_port *port);
+extern void br_multicast_disable_port(struct net_bridge_port *port);
+extern void br_multicast_init(struct net_bridge *br);
+extern void br_multicast_open(struct net_bridge *br);
+extern void br_multicast_stop(struct net_bridge *br);
+#else
+static inline int br_multicast_rcv(struct net_bridge *br,
+				   struct net_bridge_port *port,
+				   struct sk_buff *skb)
+{
+	return 0;
+}
+
+static inline struct net_bridge_mdb_entry *br_mdb_get(struct net_bridge *br,
+						      struct sk_buff *skb)
+{
+	return NULL;
+}
+
+static inline void br_multicast_add_port(struct net_bridge_port *port)
+{
+}
+
+static inline void br_multicast_del_port(struct net_bridge_port *port)
+{
+}
+
+static inline void br_multicast_enable_port(struct net_bridge_port *port)
+{
+}
+
+static inline void br_multicast_disable_port(struct net_bridge_port *port)
+{
+}
+
+static inline void br_multicast_init(struct net_bridge *br)
+{
+}
+
+static inline void br_multicast_open(struct net_bridge *br)
+{
+}
+
+static inline void br_multicast_stop(struct net_bridge *br)
+{
+}
+#endif
+
+static inline bool br_multicast_is_router(struct net_bridge *br)
+{
+	return br->multicast_router == 2 ||
+	       (br->multicast_router == 1 &&
+		timer_pending(&br->multicast_router_timer));
+}
+
 /* br_netfilter.c */
 #ifdef CONFIG_BRIDGE_NETFILTER
 extern int br_netfilter_init(void);

commit b33084be192ee1e347d98bb5c9e38a53d98d35e2
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sat Feb 27 19:41:41 2010 +0000

    bridge: Avoid unnecessary clone on forward path
    
    When the packet is delivered to the local bridge device we may
    end up cloning it unnecessarily if no bridge port can receive
    the packet in br_flood.
    
    This patch avoids this by moving the skb_clone into br_flood.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 16513793156e..fad5a2669d34 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -180,7 +180,8 @@ extern void br_forward(const struct net_bridge_port *to,
 		struct sk_buff *skb);
 extern int br_forward_finish(struct sk_buff *skb);
 extern void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb);
-extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb);
+extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb,
+			     struct sk_buff *skb2);
 
 /* br_if.c */
 extern void br_port_carrier_check(struct net_bridge_port *p);

commit 68b7c895be336b19f4c38d7cb500132fabba0afd
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sat Feb 27 19:41:40 2010 +0000

    bridge: Allow tail-call on br_pass_frame_up
    
    This patch allows tail-call on the call to br_pass_frame_up
    in br_handle_frame_finish.  This is now possible because of the
    previous patch to call br_pass_frame_up last.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 1f0c4f44b765..16513793156e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -131,6 +131,12 @@ struct net_bridge
 	struct kobject			*ifobj;
 };
 
+struct br_input_skb_cb {
+	struct net_device *brdev;
+};
+
+#define BR_INPUT_SKB_CB(__skb)	((struct br_input_skb_cb *)(__skb)->cb)
+
 extern struct notifier_block br_device_notifier;
 extern const u8 br_group_address[ETH_ALEN];
 

commit 570930fe1ee497de6aafd895dbe80116cb10525f
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Thu Feb 4 20:28:48 2010 -0800

    bridge: Remove unused age_list
    
    This patch removes the unused age_list member from the net_bridge
    structure.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2114e45682ea..1f0c4f44b765 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -93,7 +93,6 @@ struct net_bridge
 	struct net_device		*dev;
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
-	struct list_head		age_list;
 	unsigned long			feature_mask;
 #ifdef CONFIG_BRIDGE_NETFILTER
 	struct rtable 			fake_rtable;

commit 6fef4c0c8eeff7de13007a5f56113475444a253d
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Aug 31 19:50:41 2009 +0000

    netdev: convert pseudo-devices to netdev_tx_t
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8319247dad5d..2114e45682ea 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -143,7 +143,8 @@ static inline int br_is_root_bridge(const struct net_bridge *br)
 
 /* br_device.c */
 extern void br_dev_setup(struct net_device *dev);
-extern int br_dev_xmit(struct sk_buff *skb, struct net_device *dev);
+extern netdev_tx_t br_dev_xmit(struct sk_buff *skb,
+			       struct net_device *dev);
 
 /* br_fdb.c */
 extern int br_fdb_init(void);

commit 3982d3d28b02bed5312015762fe2112ccbaf9051
Author: Fischer, Anna <anna.fischer@hp.com>
Date:   Thu Aug 13 06:55:16 2009 +0000

    net/bridge: Add 'hairpin' port forwarding mode
    
    This patch adds a 'hairpin' (also called 'reflective relay') mode
    port configuration to the Linux Ethernet bridge kernel module.
    A bridge supporting hairpin forwarding mode can send frames back
    out through the port the frame was received on.
    
    Hairpin mode is required to support basic VEPA (Virtual
    Ethernet Port Aggregator) capabilities.
    
    You can find additional information on VEPA here:
    http://tech.groups.yahoo.com/group/evb/
    http://www.ieee802.org/1/files/public/docs2009/new-hudson-vepa_seminar-20090514d.pdf
    http://www.internet2.edu/presentations/jt2009jul/20090719-congdon.pdf
    
    An additional patch 'bridge-utils: Add 'hairpin' port forwarding mode'
    is provided to allow configuring hairpin mode from userspace tools.
    
    Signed-off-by: Paul Congdon <paul.congdon@hp.com>
    Signed-off-by: Anna Fischer <anna.fischer@hp.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index d5b5537272b4..8319247dad5d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -81,6 +81,9 @@ struct net_bridge_port
 	struct timer_list		message_age_timer;
 	struct kobject			kobj;
 	struct rcu_head			rcu;
+
+	unsigned long 			flags;
+#define BR_HAIRPIN_MODE		0x00000001
 };
 
 struct net_bridge

commit da6782927de809d9d427bd4bd6a4024243e41f13
Author: Micha Mirosaw <mirq-linux@rere.qmqm.pl>
Date:   Fri Jun 5 05:35:28 2009 +0000

    bridge: Simplify interface for ATM LANE
    
    This patch changes FDB entry check for ATM LANE bridge integration.
    There's no point in holding a FDB entry around SKB building.
    
    br_fdb_get()/br_fdb_put() pair are changed into single br_fdb_test_addr()
    hook that checks if the addr has FDB entry pointing to other port
    to the one the request arrived on.
    
    FDB entry refcounting is removed as it's not used anywhere else.
    
    Signed-off-by: Micha Mirosaw <mirq-linux@rere.qmqm.pl>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index b6c3b71974dc..d5b5537272b4 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -51,7 +51,6 @@ struct net_bridge_fdb_entry
 	struct net_bridge_port		*dst;
 
 	struct rcu_head			rcu;
-	atomic_t			use_count;
 	unsigned long			ageing_timer;
 	mac_addr			addr;
 	unsigned char			is_local;
@@ -154,9 +153,7 @@ extern void br_fdb_delete_by_port(struct net_bridge *br,
 				  const struct net_bridge_port *p, int do_all);
 extern struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 						 const unsigned char *addr);
-extern struct net_bridge_fdb_entry *br_fdb_get(struct net_bridge *br,
-					       unsigned char *addr);
-extern void br_fdb_put(struct net_bridge_fdb_entry *ent);
+extern int br_fdb_test_addr(struct net_device *dev, unsigned char *addr);
 extern int br_fdb_fillbuf(struct net_bridge *br, void *buf,
 			  unsigned long count, unsigned long off);
 extern int br_fdb_insert(struct net_bridge *br,
@@ -242,10 +239,9 @@ extern void br_stp_port_timer_init(struct net_bridge_port *p);
 extern unsigned long br_timer_value(const struct timer_list *timer);
 
 /* br.c */
-extern struct net_bridge_fdb_entry *(*br_fdb_get_hook)(struct net_bridge *br,
-						       unsigned char *addr);
-extern void (*br_fdb_put_hook)(struct net_bridge_fdb_entry *ent);
-
+#if defined(CONFIG_ATM_LANE) || defined(CONFIG_ATM_LANE_MODULE)
+extern int (*br_fdb_test_addr_hook)(struct net_device *dev, unsigned char *addr);
+#endif
 
 /* br_netlink.c */
 extern int br_netlink_init(void);

commit 712d6954e3998d0de2840d8130941e8042541246
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Sep 8 16:20:18 2008 -0700

    netns bridge: cleanup bridges during netns stop
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Acked-by: Stephen Hemminger <shemming@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 51eaeaaa58c0..b6c3b71974dc 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -180,7 +180,7 @@ extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb);
 extern void br_port_carrier_check(struct net_bridge_port *p);
 extern int br_add_bridge(struct net *net, const char *name);
 extern int br_del_bridge(struct net *net, const char *name);
-extern void br_cleanup_bridges(void);
+extern void br_net_exit(struct net *net);
 extern int br_add_if(struct net_bridge *br,
 	      struct net_device *dev);
 extern int br_del_if(struct net_bridge *br,

commit 4aa678ba44aa35759c04f300afbc97d3dab5faa2
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Mon Sep 8 16:19:58 2008 -0700

    netns bridge: allow bridges in netns!
    
    Bridge as netdevice doesn't cross netns boundaries.
    
    Bridge ports and bridge itself live in same netns.
    
    Notifiers are fixed.
    
    netns propagated from userspace socket for setup and teardown.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Acked-by: Stephen Hemminger <shemming@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c3dc18ddc043..51eaeaaa58c0 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -178,8 +178,8 @@ extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb);
 
 /* br_if.c */
 extern void br_port_carrier_check(struct net_bridge_port *p);
-extern int br_add_bridge(const char *name);
-extern int br_del_bridge(const char *name);
+extern int br_add_bridge(struct net *net, const char *name);
+extern int br_del_bridge(struct net *net, const char *name);
 extern void br_cleanup_bridges(void);
 extern int br_add_if(struct net_bridge *br,
 	      struct net_device *dev);

commit 4adf0af6818f3ea52421dc0bae836cfaf20ef72a
Author: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
Date:   Wed Jul 30 16:27:55 2008 -0700

    bridge: send correct MTU value in PMTU (revised)
    
    When bridging interfaces with different MTUs, the bridge correctly chooses
    the minimum of the MTUs of the physical devices as the bridges MTU.  But
    when a frame is passed which fits through the incoming, but not through
    the outgoing interface, a "Fragmentation Needed" packet is generated.
    
    However, the propagated MTU is hardcoded to 1500, which is wrong in this
    situation.  The sender will repeat the packet again with the same frame
    size, and the same problem will occur again.
    
    Instead of sending 1500, the (correct) MTU value of the bridge is now sent
    via PMTU.  To achieve this, the corresponding rtable structure is stored
    in its net_bridge structure.
    
    Modified to get rid of fake_net_device as well.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 815ed38925b2..c3dc18ddc043 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -15,6 +15,7 @@
 
 #include <linux/netdevice.h>
 #include <linux/if_bridge.h>
+#include <net/route.h>
 
 #define BR_HASH_BITS 8
 #define BR_HASH_SIZE (1 << BR_HASH_BITS)
@@ -92,6 +93,9 @@ struct net_bridge
 	struct hlist_head		hash[BR_HASH_SIZE];
 	struct list_head		age_list;
 	unsigned long			feature_mask;
+#ifdef CONFIG_BRIDGE_NETFILTER
+	struct rtable 			fake_rtable;
+#endif
 	unsigned long			flags;
 #define BR_SET_MAC_ADDR		0x00000001
 
@@ -197,9 +201,11 @@ extern int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __us
 #ifdef CONFIG_BRIDGE_NETFILTER
 extern int br_netfilter_init(void);
 extern void br_netfilter_fini(void);
+extern void br_netfilter_rtable_init(struct net_bridge *);
 #else
 #define br_netfilter_init()	(0)
 #define br_netfilter_fini()	do { } while(0)
+#define br_netfilter_rtable_init(x)
 #endif
 
 /* br_stp.c */

commit 7c85fbf0657f216557b0c9c4a2e4e07f37d8bb8c
Author: Patrick McHardy <kaber@trash.net>
Date:   Sat Jul 5 21:25:56 2008 -0700

    bridge: Use STP demux
    
    Use the STP demux layer for receiving STP PDUs instead of directly
    registering with LLC.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8593c9f6a302..815ed38925b2 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -226,8 +226,9 @@ extern void br_stp_set_path_cost(struct net_bridge_port *p,
 extern ssize_t br_show_bridge_id(char *buf, const struct bridge_id *id);
 
 /* br_stp_bpdu.c */
-extern int br_stp_rcv(struct sk_buff *skb, struct net_device *dev,
-		      struct packet_type *pt, struct net_device *orig_dev);
+struct stp_proto;
+extern void br_stp_rcv(const struct stp_proto *proto, struct sk_buff *skb,
+		       struct net_device *dev);
 
 /* br_stp_timer.c */
 extern void br_stp_timer_init(struct net_bridge *br);

commit 92c0574f11598c8036f81e27d2e8bdd6eed7d76d
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Tue Jun 17 16:10:06 2008 -0700

    bridge: make bridge address settings sticky
    
    Normally, the bridge just chooses the smallest mac address as the
    bridge id and mac address of bridge device. But if the administrator
    has explictly set the interface address then don't change it.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 83ff5861c2d2..8593c9f6a302 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -92,6 +92,8 @@ struct net_bridge
 	struct hlist_head		hash[BR_HASH_SIZE];
 	struct list_head		age_list;
 	unsigned long			feature_mask;
+	unsigned long			flags;
+#define BR_SET_MAC_ADDR		0x00000001
 
 	/* STP */
 	bridge_id			designated_root;

commit 0b040829952d84bf2a62526f0e24b624e0699447
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Jun 10 22:46:50 2008 -0700

    net: remove CVS keywords
    
    This patch removes CVS keywords that weren't updated for a long time
    from comments.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 0243cb489edd..83ff5861c2d2 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -4,8 +4,6 @@
  *	Authors:
  *	Lennert Buytenhek		<buytenh@gnu.org>
  *
- *	$Id: br_private.h,v 1.7 2001/12/24 00:59:55 davem Exp $
- *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
  *	as published by the Free Software Foundation; either version

commit a339f1c881fdb8092ef9b118610307e10e885fc8
Author: Pavel Emelyanov <xemul@openvz.org>
Date:   Wed May 21 14:13:47 2008 -0700

    bridge: Use on-device stats instead of private ones.
    
    Even though bridges require 6 fields from struct net_device_stats,
    the on-device stats are always there, so we may just use them.
    
    The br_dev_get_stats is no longer required after this.
    
    Signed-off-by: Pavel Emelyanov <xemul@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c11b554fd109..0243cb489edd 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -90,7 +90,6 @@ struct net_bridge
 	spinlock_t			lock;
 	struct list_head		port_list;
 	struct net_device		*dev;
-	struct net_device_stats		statistics;
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
 	struct list_head		age_list;

commit 43b98c4a66760d18d4056beed4078a8dbad193cc
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Dec 17 15:54:39 2007 -0400

    Kobject: change net/bridge to use kobject_create_and_add
    
    The kobject in the bridge code is only used for registering with sysfs,
    not for any lifespan rules.  This patch changes it to be only a pointer
    and use the simpler api for this kind of thing.
    
    Cc: Stephen Hemminger <shemminger@linux-foundation.org>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index f666f7b28ff5..c11b554fd109 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -124,7 +124,7 @@ struct net_bridge
 	struct timer_list		tcn_timer;
 	struct timer_list		topology_change_timer;
 	struct timer_list		gc_timer;
-	struct kobject			ifobj;
+	struct kobject			*ifobj;
 };
 
 extern struct notifier_block br_device_notifier;

commit 881d966b48b035ab3f3aeaae0f3d3f9b584f45b2
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Mon Sep 17 11:56:21 2007 -0700

    [NET]: Make the device list and device lookups per namespace.
    
    This patch makes most of the generic device layer network
    namespace safe.  This patch makes dev_base_head a
    network namespace variable, and then it picks up
    a few associated variables.  The functions:
    dev_getbyhwaddr
    dev_getfirsthwbytype
    dev_get_by_flags
    dev_get_by_name
    __dev_get_by_name
    dev_get_by_index
    __dev_get_by_index
    dev_ioctl
    dev_ethtool
    dev_load
    wireless_process_ioctl
    
    were modified to take a network namespace argument, and
    deal with it.
    
    vlan_ioctl_set and brioctl_set were modified so their
    hooks will receive a network namespace argument.
    
    So basically anthing in the core of the network stack that was
    affected to by the change of dev_base was modified to handle
    multiple network namespaces.  The rest of the network stack was
    simply modified to explicitly use &init_net the initial network
    namespace.  This can be fixed when those components of the network
    stack are modified to handle multiple network namespaces.
    
    For now the ifindex generator is left global.
    
    Fundametally ifindex numbers are per namespace, or else
    we will have corner case problems with migration when
    we get that far.
    
    At the same time there are assumptions in the network stack
    that the ifindex of a network device won't change.  Making
    the ifindex number global seems a good compromise until
    the network stack can cope with ifindex changes when
    you change namespaces, and the like.
    
    Signed-off-by: Eric W. Biederman <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e6dc6f52990d..f666f7b28ff5 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -192,7 +192,7 @@ extern struct sk_buff *br_handle_frame(struct net_bridge_port *p,
 
 /* br_ioctl.c */
 extern int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
-extern int br_ioctl_deviceless_stub(unsigned int cmd, void __user *arg);
+extern int br_ioctl_deviceless_stub(struct net *net, unsigned int cmd, void __user *arg);
 
 /* br_netfilter.c */
 #ifdef CONFIG_BRIDGE_NETFILTER

commit e081e1e3ef4682802ac63b1e5e26158fb9ca9e90
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sun Sep 16 16:20:48 2007 -0700

    [BRIDGE]: Kill clone argument to br_flood_*
    
    The clone argument is only used by one caller and that caller can clone
    the packet itself.  This patch moves the clone call into the caller and
    kills the clone argument.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 21bf3a9a03fd..e6dc6f52990d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -170,12 +170,8 @@ extern int br_dev_queue_push_xmit(struct sk_buff *skb);
 extern void br_forward(const struct net_bridge_port *to,
 		struct sk_buff *skb);
 extern int br_forward_finish(struct sk_buff *skb);
-extern void br_flood_deliver(struct net_bridge *br,
-		      struct sk_buff *skb,
-		      int clone);
-extern void br_flood_forward(struct net_bridge *br,
-		      struct sk_buff *skb,
-		      int clone);
+extern void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb);
+extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb);
 
 /* br_if.c */
 extern void br_port_carrier_check(struct net_bridge_port *p);

commit 87a596e0b8bc344bd6bfebe83b56d11fb79ee23a
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Sat Apr 7 18:57:07 2007 +0900

    bridge: check kmem_cache_create() error
    
    This patch checks kmem_cache_create() error and aborts loading module
    on failure.
    
    Signed-off-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 974feccd28b1..21bf3a9a03fd 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -141,7 +141,7 @@ extern void br_dev_setup(struct net_device *dev);
 extern int br_dev_xmit(struct sk_buff *skb, struct net_device *dev);
 
 /* br_fdb.c */
-extern void br_fdb_init(void);
+extern int br_fdb_init(void);
 extern void br_fdb_fini(void);
 extern void br_fdb_flush(struct net_bridge *br);
 extern void br_fdb_changeaddr(struct net_bridge_port *p,

commit 9cde070874b822d4677f4f01fe146991785813b1
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Wed Mar 21 14:22:44 2007 -0700

    bridge: add support for user mode STP
    
    This patchset based on work by Aji_Srinivas@emc.com provides allows
    spanning tree to be controled from userspace.  Like hotplug, it
    uses call_usermodehelper when spanning tree is enabled so there
    is no visible API change. If call to start usermode STP fails
    it falls back to existing kernel STP.
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3adacdf3406f..974feccd28b1 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -26,7 +26,10 @@
 #define BR_PORT_BITS	10
 #define BR_MAX_PORTS	(1<<BR_PORT_BITS)
 
-#define BR_VERSION	"2.2"
+#define BR_VERSION	"2.3"
+
+/* Path to usermode spanning tree program */
+#define BR_STP_PROG	"/sbin/bridge-stp"
 
 typedef struct bridge_id bridge_id;
 typedef struct mac_addr mac_addr;
@@ -107,7 +110,13 @@ struct net_bridge
 
 	u8				group_addr[ETH_ALEN];
 	u16				root_port;
-	unsigned char			stp_enabled;
+
+	enum {
+		BR_NO_STP, 		/* no spanning tree */
+		BR_KERNEL_STP,		/* old STP in kernel */
+		BR_USER_STP,		/* new RSTP in userspace */
+	} stp_enabled;
+
 	unsigned char			topology_change;
 	unsigned char			topology_change_detected;
 
@@ -127,7 +136,6 @@ static inline int br_is_root_bridge(const struct net_bridge *br)
 	return !memcmp(&br->bridge_id, &br->designated_root, 8);
 }
 
-
 /* br_device.c */
 extern void br_dev_setup(struct net_device *dev);
 extern int br_dev_xmit(struct sk_buff *skb, struct net_device *dev);
@@ -209,6 +217,7 @@ extern void br_become_designated_port(struct net_bridge_port *p);
 /* br_stp_if.c */
 extern void br_stp_enable_bridge(struct net_bridge *br);
 extern void br_stp_disable_bridge(struct net_bridge *br);
+extern void br_stp_set_enabled(struct net_bridge *br, unsigned long val);
 extern void br_stp_enable_port(struct net_bridge_port *p);
 extern void br_stp_disable_port(struct net_bridge_port *p);
 extern void br_stp_recalculate_bridge_id(struct net_bridge *br);

commit 9cf637473c8535b5abe27fee79254c2d552e042a
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Mon Apr 9 12:57:54 2007 -0700

    bridge: add sysfs hook to flush forwarding table
    
    The RSTP daemon needs to be able to flush all dynamic forwarding
    entries in the case of topology change.
    
    This is a temporary interface. It will change to a netlink interface
    before RSTP daemon is officially released.
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index fab8ce0ce88d..3adacdf3406f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -135,6 +135,7 @@ extern int br_dev_xmit(struct sk_buff *skb, struct net_device *dev);
 /* br_fdb.c */
 extern void br_fdb_init(void);
 extern void br_fdb_fini(void);
+extern void br_fdb_flush(struct net_bridge *br);
 extern void br_fdb_changeaddr(struct net_bridge_port *p,
 			      const unsigned char *newaddr);
 extern void br_fdb_cleanup(unsigned long arg);

commit 6229e362dd49b9e8387126bd4483ab0574d23e9c
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Wed Mar 21 13:38:47 2007 -0700

    bridge: eliminate call by reference
    
    Change the bridging hook to be simple function with return value
    rather than modifying the skb argument. This could generate better
    code and is cleaner.
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2b73de6c0b47..fab8ce0ce88d 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -182,7 +182,8 @@ extern void br_features_recompute(struct net_bridge *br);
 
 /* br_input.c */
 extern int br_handle_frame_finish(struct sk_buff *skb);
-extern int br_handle_frame(struct net_bridge_port *p, struct sk_buff **pskb);
+extern struct sk_buff *br_handle_frame(struct net_bridge_port *p,
+				       struct sk_buff *skb);
 
 /* br_ioctl.c */
 extern int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);

commit 32fe21c0c0a3091552fea8f2f7e4905f547a3433
Author: Thomas Graf <tgraf@suug.ch>
Date:   Thu Mar 22 11:59:03 2007 -0700

    [BRIDGE]: Use rtnl registration interface
    
    Signed-off-by: Thomas Graf <tgraf@suug.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index cc3f1c99261a..2b73de6c0b47 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -235,7 +235,7 @@ extern void (*br_fdb_put_hook)(struct net_bridge_fdb_entry *ent);
 
 
 /* br_netlink.c */
-extern void br_netlink_init(void);
+extern int br_netlink_init(void);
 extern void br_netlink_fini(void);
 extern void br_ifinfo_notify(int event, struct net_bridge_port *port);
 

commit 269def7c505b4d229f9ad49bf88543d1e605533e
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Thu Feb 22 01:10:18 2007 -0800

    [BRIDGE]: eliminate workqueue for carrier check
    
    Having a work queue for checking carrier leads to lots of race issues.
    Simpler to just get the cost when data structure is created and
    update on change.
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 16fc47a821e5..cc3f1c99261a 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -26,8 +26,6 @@
 #define BR_PORT_BITS	10
 #define BR_MAX_PORTS	(1<<BR_PORT_BITS)
 
-#define BR_PORT_DEBOUNCE (HZ/10)
-
 #define BR_VERSION	"2.2"
 
 typedef struct bridge_id bridge_id;
@@ -81,7 +79,6 @@ struct net_bridge_port
 	struct timer_list		hold_timer;
 	struct timer_list		message_age_timer;
 	struct kobject			kobj;
-	struct delayed_work		carrier_check;
 	struct rcu_head			rcu;
 };
 
@@ -172,6 +169,7 @@ extern void br_flood_forward(struct net_bridge *br,
 		      int clone);
 
 /* br_if.c */
+extern void br_port_carrier_check(struct net_bridge_port *p);
 extern int br_add_bridge(const char *name);
 extern int br_del_bridge(const char *name);
 extern void br_cleanup_bridges(void);

commit ac062e84d0c177c43549e7fb608152fec218e7fc
Author: Stephen Hemminger <shemminger@linux-foundation.org>
Date:   Thu Feb 22 01:07:53 2007 -0800

    [BRIDGE]: get rid of miscdevice include
    
    The bridge hasn't used miscdevice for a long long time.
    
    Signed-off-by: Stephen Hemminger <shemminger@linux-foundation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 6a0540e0591e..16fc47a821e5 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -16,7 +16,6 @@
 #define _BR_PRIVATE_H
 
 #include <linux/netdevice.h>
-#include <linux/miscdevice.h>
 #include <linux/if_bridge.h>
 
 #define BR_HASH_BITS 8

commit 9d6f229fc45b6ac268020c0c8eff29e94bb34381
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Feb 9 23:24:35 2007 +0900

    [NET] BRIDGE: Fix whitespace errors.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3a534e94c7f3..6a0540e0591e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -149,7 +149,7 @@ extern struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 extern struct net_bridge_fdb_entry *br_fdb_get(struct net_bridge *br,
 					       unsigned char *addr);
 extern void br_fdb_put(struct net_bridge_fdb_entry *ent);
-extern int br_fdb_fillbuf(struct net_bridge *br, void *buf, 
+extern int br_fdb_fillbuf(struct net_bridge *br, void *buf,
 			  unsigned long count, unsigned long off);
 extern int br_fdb_insert(struct net_bridge *br,
 			 struct net_bridge_port *source,
@@ -203,7 +203,7 @@ extern void br_netfilter_fini(void);
 /* br_stp.c */
 extern void br_log_state(const struct net_bridge_port *p);
 extern struct net_bridge_port *br_get_port(struct net_bridge *br,
-				    	   u16 port_no);
+					   u16 port_no);
 extern void br_init_port(struct net_bridge_port *p);
 extern void br_become_designated_port(struct net_bridge_port *p);
 

commit c4028958b6ecad064b1a6303a6a5906d4fe48d73
Author: David Howells <dhowells@redhat.com>
Date:   Wed Nov 22 14:57:56 2006 +0000

    WorkStruct: make allyesconfig
    
    Fix up for make allyesconfig.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 74258d86f256..3a534e94c7f3 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -82,7 +82,7 @@ struct net_bridge_port
 	struct timer_list		hold_timer;
 	struct timer_list		message_age_timer;
 	struct kobject			kobj;
-	struct work_struct		carrier_check;
+	struct delayed_work		carrier_check;
 	struct rcu_head			rcu;
 };
 

commit 1a620698c29b5e18150ec04ace0609fb07d08d3e
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Thu Oct 12 14:45:38 2006 -0700

    [BRIDGE]: flush forwarding table when device carrier off
    
    Flush the forwarding table when carrier is lost. This helps for
    availability because we don't want to forward to a downed device and
    new packets may come in on other links.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c491fb2f280e..74258d86f256 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -143,7 +143,7 @@ extern void br_fdb_changeaddr(struct net_bridge_port *p,
 			      const unsigned char *newaddr);
 extern void br_fdb_cleanup(unsigned long arg);
 extern void br_fdb_delete_by_port(struct net_bridge *br,
-			   struct net_bridge_port *p);
+				  const struct net_bridge_port *p, int do_all);
 extern struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
 						 const unsigned char *addr);
 extern struct net_bridge_fdb_entry *br_fdb_get(struct net_bridge *br,

commit 11dc1f36a6701b502ecb695f308aae46ede8bac6
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Thu May 25 16:00:12 2006 -0700

    [BRIDGE]: netlink interface for link management
    
    Add basic netlink support to the Ethernet bridge. Including:
     * dump interfaces in bridges
     * monitor link status changes
     * change state of bridge port
    
    For some demo programs see:
            http://developer.osdl.org/shemminger/prototypes/brnl.tar.gz
    
    These are to allow building a daemon that does alternative
    implementations of Spanning Tree Protocol.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 22071d156828..c491fb2f280e 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -29,7 +29,7 @@
 
 #define BR_PORT_DEBOUNCE (HZ/10)
 
-#define BR_VERSION	"2.1"
+#define BR_VERSION	"2.2"
 
 typedef struct bridge_id bridge_id;
 typedef struct mac_addr mac_addr;
@@ -237,6 +237,11 @@ extern struct net_bridge_fdb_entry *(*br_fdb_get_hook)(struct net_bridge *br,
 extern void (*br_fdb_put_hook)(struct net_bridge_fdb_entry *ent);
 
 
+/* br_netlink.c */
+extern void br_netlink_init(void);
+extern void br_netlink_fini(void);
+extern void br_ifinfo_notify(int event, struct net_bridge_port *port);
+
 #ifdef CONFIG_SYSFS
 /* br_sysfs_if.c */
 extern struct sysfs_ops brport_sysfs_ops;

commit c090971326db094ed702c1f8f2dbe04b7e3b8f27
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Thu May 25 15:59:33 2006 -0700

    [BRIDGE]: fix module startup error handling
    
    Return address in use, if some other kernel code has the SAP.
    Propogate out error codes from netfilter registration and unwind.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 86ecea7ed372..22071d156828 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -192,8 +192,13 @@ extern int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
 extern int br_ioctl_deviceless_stub(unsigned int cmd, void __user *arg);
 
 /* br_netfilter.c */
+#ifdef CONFIG_BRIDGE_NETFILTER
 extern int br_netfilter_init(void);
 extern void br_netfilter_fini(void);
+#else
+#define br_netfilter_init()	(0)
+#define br_netfilter_fini()	do { } while(0)
+#endif
 
 /* br_stp.c */
 extern void br_log_state(const struct net_bridge_port *p);

commit fda93d92d7824159d8532995072dde2bee4bc4b3
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Mon Mar 20 22:59:21 2006 -0800

    [BRIDGE]: allow show/store of group multicast address
    
    Bridge's communicate with each other using Spanning Tree Protocol
    over a standard multicast address. There are times when testing or
    layering bridges over existing topologies or tunnels, when it is
    useful to use alternative multicast addresses for STP packets.
    
    The 802.1d standard has some unused addresses, that can be used for this.
    This patch is restrictive in that it only allows one of the possible
    addresses in the standard.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 3bc9ad483473..86ecea7ed372 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -109,6 +109,7 @@ struct net_bridge
 	unsigned long			bridge_hello_time;
 	unsigned long			bridge_forward_delay;
 
+	u8				group_addr[ETH_ALEN];
 	u16				root_port;
 	unsigned char			stp_enabled;
 	unsigned char			topology_change;
@@ -122,7 +123,7 @@ struct net_bridge
 };
 
 extern struct notifier_block br_device_notifier;
-extern const unsigned char bridge_ula[6];
+extern const u8 br_group_address[ETH_ALEN];
 
 /* called under bridge lock */
 static inline int br_is_root_bridge(const struct net_bridge *br)

commit cf0f02d04a830c8202e6a8f8bb37acc6c1629a91
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Mon Mar 20 22:59:06 2006 -0800

    [BRIDGE]: use llc for receiving STP packets
    
    Use LLC for the receive path of Spanning Tree Protocol packets.
    This allows link local multicast packets to be received by
    other protocols (if they care), and uses the existing LLC
    code to get STP packets back into bridge code.
    
    The bridge multicast address is also checked, so bridges using
    other link local multicast addresses are ignored. This allows
    for use of different multicast addresses to define separate STP
    domains.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 8f10e09f251b..3bc9ad483473 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -217,7 +217,8 @@ extern void br_stp_set_path_cost(struct net_bridge_port *p,
 extern ssize_t br_show_bridge_id(char *buf, const struct bridge_id *id);
 
 /* br_stp_bpdu.c */
-extern int br_stp_handle_bpdu(struct sk_buff *skb);
+extern int br_stp_rcv(struct sk_buff *skb, struct net_device *dev,
+		      struct packet_type *pt, struct net_device *orig_dev);
 
 /* br_stp_timer.c */
 extern void br_stp_timer_init(struct net_bridge *br);

commit bab1deea308afcf9200837d6ac20aefe92972efb
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Thu Feb 9 17:10:12 2006 -0800

    [BRIDGE]: fix error handling for add interface to bridge
    
    Refactor how the bridge code interacts with kobject system.
    It should still use kobjects even if not using sysfs.
    Fix the error unwind handling in br_add_if.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c5bd631ffcd5..8f10e09f251b 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -232,9 +232,8 @@ extern void (*br_fdb_put_hook)(struct net_bridge_fdb_entry *ent);
 
 #ifdef CONFIG_SYSFS
 /* br_sysfs_if.c */
+extern struct sysfs_ops brport_sysfs_ops;
 extern int br_sysfs_addif(struct net_bridge_port *p);
-extern void br_sysfs_removeif(struct net_bridge_port *p);
-extern void br_sysfs_freeif(struct net_bridge_port *p);
 
 /* br_sysfs_br.c */
 extern int br_sysfs_addbr(struct net_device *dev);
@@ -243,8 +242,6 @@ extern void br_sysfs_delbr(struct net_device *dev);
 #else
 
 #define br_sysfs_addif(p)	(0)
-#define br_sysfs_removeif(p)	do { } while(0)
-#define br_sysfs_freeif(p)	kfree(p)
 #define br_sysfs_addbr(dev)	(0)
 #define br_sysfs_delbr(dev)	do { } while(0)
 #endif /* CONFIG_SYSFS */

commit b3f1be4b5412e34647764457bec901e06b03e624
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Thu Feb 9 17:08:52 2006 -0800

    [BRIDGE]: fix for RCU and deadlock on device removal
    
    Change Bridge receive path to correctly handle RCU removal of device
    from bridge.  Also fixes deadlock between carrier_check and del_nbp.
    This replaces the previous deleted flag fix.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index e330b17b6d81..c5bd631ffcd5 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -68,7 +68,6 @@ struct net_bridge_port
 	/* STP */
 	u8				priority;
 	u8				state;
-	u8				deleted;
 	u16				port_no;
 	unsigned char			topology_change_ack;
 	unsigned char			config_pending;

commit 3f4cfc2d11c9e29709e6f0f3add54039614d847a
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Tue Jan 31 17:44:07 2006 -0800

    [BRIDGE]: Fix device delete race.
    
    This is a simpler fix for the two races in bridge device removal.
    The Xen race of delif and notify is managed now by a new deleted flag.
    No need for barriers or other locking because of rtnl mutex.
    
    The del_timer_sync()'s are unnecessary, because br_stp_disable_port
    delete's the timers, and they will finish running before RCU callback.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index c5bd631ffcd5..e330b17b6d81 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -68,6 +68,7 @@ struct net_bridge_port
 	/* STP */
 	u8				priority;
 	u8				state;
+	u8				deleted;
 	u16				port_no;
 	unsigned char			topology_change_ack;
 	unsigned char			config_pending;

commit 8cbb512e50fb702b5b1d444f76ebcdb53577b2ec
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Wed Dec 21 19:01:30 2005 -0800

    [BRIDGE]: add version number
    
    Add version info to bridge module.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index db7b26b8de96..c5bd631ffcd5 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -29,6 +29,8 @@
 
 #define BR_PORT_DEBOUNCE (HZ/10)
 
+#define BR_VERSION	"2.1"
+
 typedef struct bridge_id bridge_id;
 typedef struct mac_addr mac_addr;
 typedef __u16 port_id;

commit edb5e46fc03d0a45f2b41e3717631f7af7e9fc19
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Wed Dec 21 19:00:58 2005 -0800

    [BRIDGE]: limited ethtool support
    
    Add limited ethtool support to bridge to allow disabling
    features.
    
    Note: if underlying device does not support a feature (like checksum
    offload), then the bridge device won't inherit it.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 7ad53c2aa684..db7b26b8de96 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -93,6 +93,7 @@ struct net_bridge
 	spinlock_t			hash_lock;
 	struct hlist_head		hash[BR_HASH_SIZE];
 	struct list_head		age_list;
+	unsigned long			feature_mask;
 
 	/* STP */
 	bridge_id			designated_root;

commit 4433f420e57afae0ab308b1e2b979f09c86bc115
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Tue Dec 20 15:19:51 2005 -0800

    [BRIDGE]: handle speed detection after carrier changes
    
    Speed of a interface may not be available until carrier
    is detected in the case of autonegotiation. To get the correct value
    we need to recheck speed after carrier event.  But the check needs to
    be done in a context that is similar to normal ethtool interface (can sleep).
    
    Also, delay check for 1ms to try avoid any carrier bounce transitions.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 2c249486476f..7ad53c2aa684 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -27,6 +27,8 @@
 #define BR_PORT_BITS	10
 #define BR_MAX_PORTS	(1<<BR_PORT_BITS)
 
+#define BR_PORT_DEBOUNCE (HZ/10)
+
 typedef struct bridge_id bridge_id;
 typedef struct mac_addr mac_addr;
 typedef __u16 port_id;
@@ -78,6 +80,7 @@ struct net_bridge_port
 	struct timer_list		hold_timer;
 	struct timer_list		message_age_timer;
 	struct kobject			kobj;
+	struct work_struct		carrier_check;
 	struct rcu_head			rcu;
 };
 

commit 4505a3ef720845b5db3ddb440de13cd4800fd508
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Wed Dec 21 18:51:49 2005 -0800

    [BRIDGE]: allow setting hardware address of bridge pseudo-dev
    
    Some people are using bridging to hide multiple machines from an ISP
    that restricts by MAC address. So in that case allow the bridge mac
    address to be set to any of the existing interfaces.  I don't want to
    allow any arbitrary value and confuse STP.
    
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index bdf95a74d8cd..2c249486476f 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -201,6 +201,7 @@ extern void br_stp_disable_bridge(struct net_bridge *br);
 extern void br_stp_enable_port(struct net_bridge_port *p);
 extern void br_stp_disable_port(struct net_bridge_port *p);
 extern void br_stp_recalculate_bridge_id(struct net_bridge *br);
+extern void br_stp_change_bridge_id(struct net_bridge *br, const unsigned char *a);
 extern void br_stp_set_bridge_priority(struct net_bridge *br,
 				       u16 newprio);
 extern void br_stp_set_port_priority(struct net_bridge_port *p,

commit 81d35307dd468b92fe8c58797abb13c62e3e64dd
Author: Stephen Hemminger <shemminger@osdl.org>
Date:   Sun May 29 14:15:17 2005 -0700

    [BRIDGE]: set features based on enslaved devices
    
    Make features of the bridge pseudo-device be a subset of the underlying
    devices.  Motivated by Xen and others who use bridging to do failover.
    
    Signed-off-by: Catalin BOIE <catab at umrella.ro>
    Signed-off-by: Stephen Hemminger <shemminger@osdl.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
index 54d63f1372a0..bdf95a74d8cd 100644
--- a/net/bridge/br_private.h
+++ b/net/bridge/br_private.h
@@ -174,6 +174,7 @@ extern int br_add_if(struct net_bridge *br,
 extern int br_del_if(struct net_bridge *br,
 	      struct net_device *dev);
 extern int br_min_mtu(const struct net_bridge *br);
+extern void br_features_recompute(struct net_bridge *br);
 
 /* br_input.c */
 extern int br_handle_frame_finish(struct sk_buff *skb);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/net/bridge/br_private.h b/net/bridge/br_private.h
new file mode 100644
index 000000000000..54d63f1372a0
--- /dev/null
+++ b/net/bridge/br_private.h
@@ -0,0 +1,244 @@
+/*
+ *	Linux ethernet bridge
+ *
+ *	Authors:
+ *	Lennert Buytenhek		<buytenh@gnu.org>
+ *
+ *	$Id: br_private.h,v 1.7 2001/12/24 00:59:55 davem Exp $
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _BR_PRIVATE_H
+#define _BR_PRIVATE_H
+
+#include <linux/netdevice.h>
+#include <linux/miscdevice.h>
+#include <linux/if_bridge.h>
+
+#define BR_HASH_BITS 8
+#define BR_HASH_SIZE (1 << BR_HASH_BITS)
+
+#define BR_HOLD_TIME (1*HZ)
+
+#define BR_PORT_BITS	10
+#define BR_MAX_PORTS	(1<<BR_PORT_BITS)
+
+typedef struct bridge_id bridge_id;
+typedef struct mac_addr mac_addr;
+typedef __u16 port_id;
+
+struct bridge_id
+{
+	unsigned char	prio[2];
+	unsigned char	addr[6];
+};
+
+struct mac_addr
+{
+	unsigned char	addr[6];
+};
+
+struct net_bridge_fdb_entry
+{
+	struct hlist_node		hlist;
+	struct net_bridge_port		*dst;
+
+	struct rcu_head			rcu;
+	atomic_t			use_count;
+	unsigned long			ageing_timer;
+	mac_addr			addr;
+	unsigned char			is_local;
+	unsigned char			is_static;
+};
+
+struct net_bridge_port
+{
+	struct net_bridge		*br;
+	struct net_device		*dev;
+	struct list_head		list;
+
+	/* STP */
+	u8				priority;
+	u8				state;
+	u16				port_no;
+	unsigned char			topology_change_ack;
+	unsigned char			config_pending;
+	port_id				port_id;
+	port_id				designated_port;
+	bridge_id			designated_root;
+	bridge_id			designated_bridge;
+	u32				path_cost;
+	u32				designated_cost;
+
+	struct timer_list		forward_delay_timer;
+	struct timer_list		hold_timer;
+	struct timer_list		message_age_timer;
+	struct kobject			kobj;
+	struct rcu_head			rcu;
+};
+
+struct net_bridge
+{
+	spinlock_t			lock;
+	struct list_head		port_list;
+	struct net_device		*dev;
+	struct net_device_stats		statistics;
+	spinlock_t			hash_lock;
+	struct hlist_head		hash[BR_HASH_SIZE];
+	struct list_head		age_list;
+
+	/* STP */
+	bridge_id			designated_root;
+	bridge_id			bridge_id;
+	u32				root_path_cost;
+	unsigned long			max_age;
+	unsigned long			hello_time;
+	unsigned long			forward_delay;
+	unsigned long			bridge_max_age;
+	unsigned long			ageing_time;
+	unsigned long			bridge_hello_time;
+	unsigned long			bridge_forward_delay;
+
+	u16				root_port;
+	unsigned char			stp_enabled;
+	unsigned char			topology_change;
+	unsigned char			topology_change_detected;
+
+	struct timer_list		hello_timer;
+	struct timer_list		tcn_timer;
+	struct timer_list		topology_change_timer;
+	struct timer_list		gc_timer;
+	struct kobject			ifobj;
+};
+
+extern struct notifier_block br_device_notifier;
+extern const unsigned char bridge_ula[6];
+
+/* called under bridge lock */
+static inline int br_is_root_bridge(const struct net_bridge *br)
+{
+	return !memcmp(&br->bridge_id, &br->designated_root, 8);
+}
+
+
+/* br_device.c */
+extern void br_dev_setup(struct net_device *dev);
+extern int br_dev_xmit(struct sk_buff *skb, struct net_device *dev);
+
+/* br_fdb.c */
+extern void br_fdb_init(void);
+extern void br_fdb_fini(void);
+extern void br_fdb_changeaddr(struct net_bridge_port *p,
+			      const unsigned char *newaddr);
+extern void br_fdb_cleanup(unsigned long arg);
+extern void br_fdb_delete_by_port(struct net_bridge *br,
+			   struct net_bridge_port *p);
+extern struct net_bridge_fdb_entry *__br_fdb_get(struct net_bridge *br,
+						 const unsigned char *addr);
+extern struct net_bridge_fdb_entry *br_fdb_get(struct net_bridge *br,
+					       unsigned char *addr);
+extern void br_fdb_put(struct net_bridge_fdb_entry *ent);
+extern int br_fdb_fillbuf(struct net_bridge *br, void *buf, 
+			  unsigned long count, unsigned long off);
+extern int br_fdb_insert(struct net_bridge *br,
+			 struct net_bridge_port *source,
+			 const unsigned char *addr);
+extern void br_fdb_update(struct net_bridge *br,
+			  struct net_bridge_port *source,
+			  const unsigned char *addr);
+
+/* br_forward.c */
+extern void br_deliver(const struct net_bridge_port *to,
+		struct sk_buff *skb);
+extern int br_dev_queue_push_xmit(struct sk_buff *skb);
+extern void br_forward(const struct net_bridge_port *to,
+		struct sk_buff *skb);
+extern int br_forward_finish(struct sk_buff *skb);
+extern void br_flood_deliver(struct net_bridge *br,
+		      struct sk_buff *skb,
+		      int clone);
+extern void br_flood_forward(struct net_bridge *br,
+		      struct sk_buff *skb,
+		      int clone);
+
+/* br_if.c */
+extern int br_add_bridge(const char *name);
+extern int br_del_bridge(const char *name);
+extern void br_cleanup_bridges(void);
+extern int br_add_if(struct net_bridge *br,
+	      struct net_device *dev);
+extern int br_del_if(struct net_bridge *br,
+	      struct net_device *dev);
+extern int br_min_mtu(const struct net_bridge *br);
+
+/* br_input.c */
+extern int br_handle_frame_finish(struct sk_buff *skb);
+extern int br_handle_frame(struct net_bridge_port *p, struct sk_buff **pskb);
+
+/* br_ioctl.c */
+extern int br_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd);
+extern int br_ioctl_deviceless_stub(unsigned int cmd, void __user *arg);
+
+/* br_netfilter.c */
+extern int br_netfilter_init(void);
+extern void br_netfilter_fini(void);
+
+/* br_stp.c */
+extern void br_log_state(const struct net_bridge_port *p);
+extern struct net_bridge_port *br_get_port(struct net_bridge *br,
+				    	   u16 port_no);
+extern void br_init_port(struct net_bridge_port *p);
+extern void br_become_designated_port(struct net_bridge_port *p);
+
+/* br_stp_if.c */
+extern void br_stp_enable_bridge(struct net_bridge *br);
+extern void br_stp_disable_bridge(struct net_bridge *br);
+extern void br_stp_enable_port(struct net_bridge_port *p);
+extern void br_stp_disable_port(struct net_bridge_port *p);
+extern void br_stp_recalculate_bridge_id(struct net_bridge *br);
+extern void br_stp_set_bridge_priority(struct net_bridge *br,
+				       u16 newprio);
+extern void br_stp_set_port_priority(struct net_bridge_port *p,
+				     u8 newprio);
+extern void br_stp_set_path_cost(struct net_bridge_port *p,
+				 u32 path_cost);
+extern ssize_t br_show_bridge_id(char *buf, const struct bridge_id *id);
+
+/* br_stp_bpdu.c */
+extern int br_stp_handle_bpdu(struct sk_buff *skb);
+
+/* br_stp_timer.c */
+extern void br_stp_timer_init(struct net_bridge *br);
+extern void br_stp_port_timer_init(struct net_bridge_port *p);
+extern unsigned long br_timer_value(const struct timer_list *timer);
+
+/* br.c */
+extern struct net_bridge_fdb_entry *(*br_fdb_get_hook)(struct net_bridge *br,
+						       unsigned char *addr);
+extern void (*br_fdb_put_hook)(struct net_bridge_fdb_entry *ent);
+
+
+#ifdef CONFIG_SYSFS
+/* br_sysfs_if.c */
+extern int br_sysfs_addif(struct net_bridge_port *p);
+extern void br_sysfs_removeif(struct net_bridge_port *p);
+extern void br_sysfs_freeif(struct net_bridge_port *p);
+
+/* br_sysfs_br.c */
+extern int br_sysfs_addbr(struct net_device *dev);
+extern void br_sysfs_delbr(struct net_device *dev);
+
+#else
+
+#define br_sysfs_addif(p)	(0)
+#define br_sysfs_removeif(p)	do { } while(0)
+#define br_sysfs_freeif(p)	kfree(p)
+#define br_sysfs_addbr(dev)	(0)
+#define br_sysfs_delbr(dev)	do { } while(0)
+#endif /* CONFIG_SYSFS */
+
+#endif
