commit 2025cf9e193de05b0654570dd639acb49ebd3adf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:18:02 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 288
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 263 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141901.208660670@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index ec0a8998e52d..e3599ed4a7a8 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -1,16 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * NFC Digital Protocol stack
  * Copyright (c) 2013, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
  */
 
 #define pr_fmt(fmt) "digital: %s: " fmt, __func__

commit 72ad533acc22870156736c2fef4674c01307695e
Author: Mark Greer <mgreer@animalcreek.com>
Date:   Thu Jun 15 20:34:21 2017 -0700

    NFC: digital: Abort cmd when deactivating target
    
    When deactivating an active target, the outstanding command should
    be aborted.
    
    Signed-off-by: Mark Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index de6dd37d04c7..ec0a8998e52d 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -650,6 +650,7 @@ static void digital_deactivate_target(struct nfc_dev *nfc_dev,
 		return;
 	}
 
+	digital_abort_cmd(ddev);
 	ddev->curr_protocol = 0;
 }
 

commit dcfca27faf6d19d2af530cfccee2fcdbcd836a2c
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon May 22 14:24:24 2017 +0200

    NFC: digital: Delete an error message for memory allocation failure
    
    Omit an extra message for a memory allocation failure in this function.
    
    This issue was detected by using the Coccinelle software.
    
    Link: http://events.linuxfoundation.org/sites/events/files/slides/LCJ16-Refactor_Strings-WSang_0.pdf
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 321514636da1..de6dd37d04c7 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -707,10 +707,8 @@ static int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,
 	int rc;
 
 	data_exch = kzalloc(sizeof(*data_exch), GFP_KERNEL);
-	if (!data_exch) {
-		pr_err("Failed to allocate data_exch struct\n");
+	if (!data_exch)
 		return -ENOMEM;
-	}
 
 	data_exch->cb = cb;
 	data_exch->cb_context = cb_context;

commit ae72c9910b170e55386586cf18ef9015a8d172e6
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Mon May 22 14:11:01 2017 +0200

    NFC: digital: Improve a size determination in four functions
    
    Replace the specification of four data structures by pointer dereferences
    as the parameter for the operator "sizeof" to make the corresponding size
    determination a bit safer according to the Linux coding style convention.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index ebeace7a8278..321514636da1 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -240,7 +240,7 @@ int digital_send_cmd(struct nfc_digital_dev *ddev, u8 cmd_type,
 {
 	struct digital_cmd *cmd;
 
-	cmd = kzalloc(sizeof(struct digital_cmd), GFP_KERNEL);
+	cmd = kzalloc(sizeof(*cmd), GFP_KERNEL);
 	if (!cmd)
 		return -ENOMEM;
 
@@ -287,7 +287,7 @@ static int digital_tg_listen_mdaa(struct nfc_digital_dev *ddev, u8 rf_tech)
 {
 	struct digital_tg_mdaa_params *params;
 
-	params = kzalloc(sizeof(struct digital_tg_mdaa_params), GFP_KERNEL);
+	params = kzalloc(sizeof(*params), GFP_KERNEL);
 	if (!params)
 		return -ENOMEM;
 
@@ -706,7 +706,7 @@ static int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,
 	struct digital_data_exch *data_exch;
 	int rc;
 
-	data_exch = kzalloc(sizeof(struct digital_data_exch), GFP_KERNEL);
+	data_exch = kzalloc(sizeof(*data_exch), GFP_KERNEL);
 	if (!data_exch) {
 		pr_err("Failed to allocate data_exch struct\n");
 		return -ENOMEM;
@@ -764,7 +764,7 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 	    !ops->switch_rf || (ops->tg_listen_md && !ops->tg_get_rf_tech))
 		return NULL;
 
-	ddev = kzalloc(sizeof(struct nfc_digital_dev), GFP_KERNEL);
+	ddev = kzalloc(sizeof(*ddev), GFP_KERNEL);
 	if (!ddev)
 		return NULL;
 

commit 634fef61076d644b989b86abc2f560d81a089a31
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:24 2017 +0200

    networking: add and use skb_put_u8()
    
    Joe and Bjørn suggested that it'd be nicer to not have the
    cast in the fairly common case of doing
            *(u8 *)skb_put(skb, 1) = c;
    
    Add skb_put_u8() for this case, and use it across the code,
    using the following spatch:
    
        @@
        expression SKB, C, S;
        typedef u8;
        identifier fn = {skb_put};
        fresh identifier fn2 = fn ## "_u8";
        @@
        - *(u8 *)fn(SKB, S) = C;
        + fn2(SKB, C);
    
    Note that due to the "S", the spatch isn't perfect, it should
    have checked that S is 1, but there's also places that use a
    sizeof expression like sizeof(var) or sizeof(u8) etc. Turns
    out that nobody ever did something like
            *(u8 *)skb_put(skb, 2) = c;
    
    which would be wrong anyway since the second byte wouldn't be
    initialized.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Suggested-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index fec47a7d0092..ebeace7a8278 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -74,8 +74,8 @@ void digital_skb_add_crc(struct sk_buff *skb, crc_func_t crc_func, u16 init,
 	if (msb_first)
 		crc = __fswab16(crc);
 
-	*(u8 *)skb_put(skb, 1) = crc & 0xFF;
-	*(u8 *)skb_put(skb, 1) = (crc >> 8) & 0xFF;
+	skb_put_u8(skb, crc & 0xFF);
+	skb_put_u8(skb, (crc >> 8) & 0xFF);
 }
 
 int digital_skb_check_crc(struct sk_buff *skb, crc_func_t crc_func,

commit 4df864c1d9afb46e2461a9f808d9f11a42d31bad
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:21 2017 +0200

    networking: make skb_put & friends return void pointers
    
    It seems like a historic accident that these return unsigned char *,
    and in many places that means casts are required, more often than not.
    
    Make these functions (skb_put, __skb_put and pskb_put) return void *
    and remove all the casts across the tree, adding a (u8 *) cast only
    where the unsigned char pointer was used directly, all done with the
    following spatch:
    
        @@
        expression SKB, LEN;
        typedef u8;
        identifier fn = { skb_put, __skb_put };
        @@
        - *(fn(SKB, LEN))
        + *(u8 *)fn(SKB, LEN)
    
        @@
        expression E, SKB, LEN;
        identifier fn = { skb_put, __skb_put };
        type T;
        @@
        - E = ((T *)(fn(SKB, LEN)))
        + E = fn(SKB, LEN)
    
    which actually doesn't cover pskb_put since there are only three
    users overall.
    
    A handful of stragglers were converted manually, notably a macro in
    drivers/isdn/i4l/isdn_bsdcomp.c and, oddly enough, one of the many
    instances in net/bluetooth/hci_sock.c. In the former file, I also
    had to fix one whitespace problem spatch introduced.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 0fd5518bf252..fec47a7d0092 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -74,8 +74,8 @@ void digital_skb_add_crc(struct sk_buff *skb, crc_func_t crc_func, u16 init,
 	if (msb_first)
 		crc = __fswab16(crc);
 
-	*skb_put(skb, 1) = crc & 0xFF;
-	*skb_put(skb, 1) = (crc >> 8) & 0xFF;
+	*(u8 *)skb_put(skb, 1) = crc & 0xFF;
+	*(u8 *)skb_put(skb, 1) = (crc >> 8) & 0xFF;
 }
 
 int digital_skb_check_crc(struct sk_buff *skb, crc_func_t crc_func,

commit 3cc952dbf1a7176b9247da4cd2612c9ddc1d1b51
Author: Thierry Escande <thierry.escande@collabora.com>
Date:   Thu Jun 16 20:24:45 2016 +0200

    NFC: digital: Abort last command when dep link goes down
    
    With this patch, the Digital Protocol layer abort the last issued
    command when the dep link goes down. That way it does not have to wait
    for the driver to reply with a timeout error before sending a new
    command (i.e. a start poll command if constant polling is on).
    
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 0146e42ee28f..0fd5518bf252 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -612,6 +612,8 @@ static int digital_dep_link_down(struct nfc_dev *nfc_dev)
 {
 	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
 
+	digital_abort_cmd(ddev);
+
 	ddev->curr_protocol = 0;
 
 	return 0;

commit af66df0f53b9120437556d8eb00d70a36e791258
Author: Thierry Escande <thierry.escande@collabora.com>
Date:   Thu Jun 16 20:24:44 2016 +0200

    NFC: digital: Set the command pending flag
    
    There is a flag in the command structure indicating that this command is
    pending. It was checked before sending the command to not send the same
    command twice but it was actually never set. This is now fixed.
    
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 6e0b255aec66..0146e42ee28f 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -176,6 +176,8 @@ static void digital_wq_cmd(struct work_struct *work)
 		return;
 	}
 
+	cmd->pending = 1;
+
 	mutex_unlock(&ddev->cmd_lock);
 
 	if (cmd->req)

commit 82e57952869fbbdf09d8f9e7ac284df13741e93d
Author: Thierry Escande <thierry.escande@collabora.com>
Date:   Thu Jun 16 20:24:43 2016 +0200

    NFC: digital: Call pending command callbacks at device unregister
    
    With this patch, when freeing the command queue in the module unregister
    function, the callbacks of the commands still queued are called with a
    ENODEV error. This gives a chance to the command issuer to free any
    memory it could have allocate.
    
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 27769ac89d27..6e0b255aec66 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -842,6 +842,14 @@ void nfc_digital_unregister_device(struct nfc_digital_dev *ddev)
 
 	list_for_each_entry_safe(cmd, n, &ddev->cmd_queue, queue) {
 		list_del(&cmd->queue);
+
+		/* Call the command callback if any and pass it a ENODEV error.
+		 * This gives a chance to the command issuer to free any
+		 * allocated buffer.
+		 */
+		if (cmd->cmd_cb)
+			cmd->cmd_cb(ddev, cmd->cb_context, ERR_PTR(-ENODEV));
+
 		kfree(cmd->mdaa_params);
 		kfree(cmd);
 	}

commit 7854a44526de84142e367f08288c9f3a33c4c8ee
Author: Thierry Escande <thierry.escande@collabora.com>
Date:   Tue Jun 7 16:21:52 2016 +0200

    NFC: digital: Add a delay between poll cycles
    
    This replaces the polling work struct with a delayed work struct and add
    a 10 ms delay between 2 poll cycles. This avoids to flood the device
    with 'switch off'/'switch on' commands.
    
    Signed-off-by: Thierry Escande <thierry.escande@collabora.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index dd9003f38822..27769ac89d27 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -30,6 +30,9 @@
 
 #define DIGITAL_PROTO_ISO15693_RF_TECH	NFC_PROTO_ISO15693_MASK
 
+/* Delay between each poll frame (ms) */
+#define DIGITAL_POLL_INTERVAL 10
+
 struct digital_cmd {
 	struct list_head queue;
 
@@ -419,7 +422,8 @@ void digital_poll_next_tech(struct nfc_digital_dev *ddev)
 
 	mutex_unlock(&ddev->poll_lock);
 
-	schedule_work(&ddev->poll_work);
+	schedule_delayed_work(&ddev->poll_work,
+			      msecs_to_jiffies(DIGITAL_POLL_INTERVAL));
 }
 
 static void digital_wq_poll(struct work_struct *work)
@@ -428,7 +432,7 @@ static void digital_wq_poll(struct work_struct *work)
 	struct digital_poll_tech *poll_tech;
 	struct nfc_digital_dev *ddev = container_of(work,
 						    struct nfc_digital_dev,
-						    poll_work);
+						    poll_work.work);
 	mutex_lock(&ddev->poll_lock);
 
 	if (!ddev->poll_tech_count) {
@@ -543,7 +547,7 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 		return -EINVAL;
 	}
 
-	schedule_work(&ddev->poll_work);
+	schedule_delayed_work(&ddev->poll_work, 0);
 
 	return 0;
 }
@@ -564,7 +568,7 @@ static void digital_stop_poll(struct nfc_dev *nfc_dev)
 
 	mutex_unlock(&ddev->poll_lock);
 
-	cancel_work_sync(&ddev->poll_work);
+	cancel_delayed_work_sync(&ddev->poll_work);
 
 	digital_abort_cmd(ddev);
 }
@@ -770,7 +774,7 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 	INIT_WORK(&ddev->cmd_complete_work, digital_wq_cmd_complete);
 
 	mutex_init(&ddev->poll_lock);
-	INIT_WORK(&ddev->poll_work, digital_wq_poll);
+	INIT_DELAYED_WORK(&ddev->poll_work, digital_wq_poll);
 
 	if (supported_protocols & NFC_PROTO_JEWEL_MASK)
 		ddev->protocols |= NFC_PROTO_JEWEL_MASK;
@@ -832,7 +836,7 @@ void nfc_digital_unregister_device(struct nfc_digital_dev *ddev)
 	ddev->poll_tech_count = 0;
 	mutex_unlock(&ddev->poll_lock);
 
-	cancel_work_sync(&ddev->poll_work);
+	cancel_delayed_work_sync(&ddev->poll_work);
 	cancel_work_sync(&ddev->cmd_work);
 	cancel_work_sync(&ddev->cmd_complete_work);
 

commit ce2e56cdfbb010e22073d303161e74c144ebe731
Author: Shikha Singh <shikha.singh@st.com>
Date:   Fri Nov 20 06:40:19 2015 -0500

    NFC: digital: Add Type4A tags support
    
    The definition of DIGITAL_PROTO_NFCA_RF_TECH is modified to support
    ISO14443 Type4A tags. Without this change it is not possible to start
    polling for ISO14443 Type4A tags from the initiator side.
    
    Signed-off-by: Shikha Singh <shikha.singh@st.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 23c2a118ac9f..dd9003f38822 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -20,7 +20,8 @@
 #include "digital.h"
 
 #define DIGITAL_PROTO_NFCA_RF_TECH \
-	(NFC_PROTO_JEWEL_MASK | NFC_PROTO_MIFARE_MASK | NFC_PROTO_NFC_DEP_MASK)
+	(NFC_PROTO_JEWEL_MASK | NFC_PROTO_MIFARE_MASK | \
+	NFC_PROTO_NFC_DEP_MASK | NFC_PROTO_ISO14443_MASK)
 
 #define DIGITAL_PROTO_NFCB_RF_TECH	NFC_PROTO_ISO14443_B_MASK
 

commit 96d4581f0b3712221d6ed4a765bb6b4ea40f2b2f
Author: Christophe Ricard <christophe.ricard@gmail.com>
Date:   Sun Oct 25 22:54:43 2015 +0100

    NFC: netlink: Add mode parameter to deactivate_target functions
    
    In order to manage in a better way the nci poll mode state machine,
    add mode parameter to deactivate_target functions.
    This way we can manage different target state.
    mode parameter make sense only in nci core.
    
    Signed-off-by: Christophe Ricard <christophe-h.ricard@st.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 009bcf317101..23c2a118ac9f 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -631,7 +631,8 @@ static int digital_activate_target(struct nfc_dev *nfc_dev,
 }
 
 static void digital_deactivate_target(struct nfc_dev *nfc_dev,
-				      struct nfc_target *target)
+				      struct nfc_target *target,
+				      u8 mode)
 {
 	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
 

commit bf30a67c947ed57c1cf7c68a47dc24331458037e
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Mon Jul 21 21:24:39 2014 -0700

    NFC: digital: Add 'tg_listen_md' and 'tg_get_rf_tech' driver hooks
    
    The digital layer of the NFC subsystem currently
    supports a 'tg_listen_mdaa' driver hook that supports
    devices that can do mode detection and automatic
    anticollision.  However, there are some devices that
    can do mode detection but not automatic anitcollision
    so add the 'tg_listen_md' hook to support those devices.
    
    In order for the digital layer to get the RF technology
    detected by the device from the driver, add the
    'tg_get_rf_tech' hook.  It is only valid to call this
    hook immediately after a successful call to 'tg_listen_md'.
    
    CC: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 361bc37d2db1..009bcf317101 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -201,6 +201,11 @@ static void digital_wq_cmd(struct work_struct *work)
 					       digital_send_cmd_complete, cmd);
 		break;
 
+	case DIGITAL_CMD_TG_LISTEN_MD:
+		rc = ddev->ops->tg_listen_md(ddev, cmd->timeout,
+					       digital_send_cmd_complete, cmd);
+		break;
+
 	default:
 		pr_err("Unknown cmd type %d\n", cmd->type);
 		return;
@@ -293,6 +298,12 @@ static int digital_tg_listen_mdaa(struct nfc_digital_dev *ddev, u8 rf_tech)
 				500, digital_tg_recv_atr_req, NULL);
 }
 
+static int digital_tg_listen_md(struct nfc_digital_dev *ddev, u8 rf_tech)
+{
+	return digital_send_cmd(ddev, DIGITAL_CMD_TG_LISTEN_MD, NULL, NULL, 500,
+				digital_tg_recv_md_req, NULL);
+}
+
 int digital_target_found(struct nfc_digital_dev *ddev,
 			 struct nfc_target *target, u8 protocol)
 {
@@ -510,6 +521,9 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 		if (ddev->ops->tg_listen_mdaa) {
 			digital_add_poll_tech(ddev, 0,
 					      digital_tg_listen_mdaa);
+		} else if (ddev->ops->tg_listen_md) {
+			digital_add_poll_tech(ddev, 0,
+					      digital_tg_listen_md);
 		} else {
 			digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106A,
 					      digital_tg_listen_nfca);
@@ -737,7 +751,7 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 
 	if (!ops->in_configure_hw || !ops->in_send_cmd || !ops->tg_listen ||
 	    !ops->tg_configure_hw || !ops->tg_send_cmd || !ops->abort_cmd ||
-	    !ops->switch_rf)
+	    !ops->switch_rf || (ops->tg_listen_md && !ops->tg_get_rf_tech))
 		return NULL;
 
 	ddev = kzalloc(sizeof(struct nfc_digital_dev), GFP_KERNEL);

commit 0529a7adf3421acf251355444a012073abaffebc
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Wed Jul 2 09:03:49 2014 -0700

    NFC: digital: Clear poll_tech_count before activating target
    
    Currently, digital_target_found() has a race between
    the events started by calling nfc_targets_found()
    (which ultimately expect ddev->poll_tech_count to be
    zero) and setting ddev->poll_tech_count to zero after
    the call to nfc_targets_found().  When the race is
    "lost" (i.e., ddev->poll_tech_count is found to not
    be zero by the events started by nfc_targets_found()),
    an error message is printed and the target is not found.
    A similar race exists when digital_tg_recv_atr_req()
    calls nfc_tm_activated().
    
    Fix this by first saving the current value of
    ddev->poll_tech_count and then clearing it before
    calling nfc_targets_found()/nfc_tm_activated().
    Clearing ddev->poll_tech_count before calling
    nfc_targets_found()/nfc_tm_activated() eliminates
    the race.  Saving the value is required so it can be
    restored when nfc_targets_found()/nfc_tm_activated()
    fails and polling needs to continue.
    
    Acked-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index a6ce3c627e4e..361bc37d2db1 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -299,6 +299,7 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 	int rc;
 	u8 framing;
 	u8 rf_tech;
+	u8 poll_tech_count;
 	int (*check_crc)(struct sk_buff *skb);
 	void (*add_crc)(struct sk_buff *skb);
 
@@ -375,12 +376,16 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 		return rc;
 
 	target->supported_protocols = (1 << protocol);
-	rc = nfc_targets_found(ddev->nfc_dev, target, 1);
-	if (rc)
-		return rc;
 
+	poll_tech_count = ddev->poll_tech_count;
 	ddev->poll_tech_count = 0;
 
+	rc = nfc_targets_found(ddev->nfc_dev, target, 1);
+	if (rc) {
+		ddev->poll_tech_count = poll_tech_count;
+		return rc;
+	}
+
 	return 0;
 }
 

commit 9dc33705b26aa67a94d8ada0a083557e9815cd0d
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Sat May 10 13:06:02 2014 +0200

    NFC: digital: Randomize poll cycles
    
    This change adds some entropy to polling cycles, choosing the next
    polling rf technology randomly. This reflects the change done in the
    pn533 driver, avoiding possible infinite loop for devices that export 2
    targets on 2 different modulations. If the first target is not
    readable, we will stay in an error loop for ever.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index b105cfb00e76..a6ce3c627e4e 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -386,6 +386,8 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 
 void digital_poll_next_tech(struct nfc_digital_dev *ddev)
 {
+	u8 rand_mod;
+
 	digital_switch_rf(ddev, 0);
 
 	mutex_lock(&ddev->poll_lock);
@@ -395,8 +397,8 @@ void digital_poll_next_tech(struct nfc_digital_dev *ddev)
 		return;
 	}
 
-	ddev->poll_tech_index = (ddev->poll_tech_index + 1) %
-				ddev->poll_tech_count;
+	get_random_bytes(&rand_mod, sizeof(rand_mod));
+	ddev->poll_tech_index = rand_mod % ddev->poll_tech_count;
 
 	mutex_unlock(&ddev->poll_lock);
 

commit 24734607351a4f1c418f127f61958585dc7ed51d
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Mon Mar 31 17:36:38 2014 -0700

    NFC: digital: Add support for ISO/IEC 14443-B Protocol
    
    Add support for the ISO/IEC 14443-B protocol and Type 4B tags.
    It is expected that there will be only one tag within range so the full
    anticollision scheme is not implemented. Only the SENSB_REQ/SENSB_RES
    and ATTRIB_REQ/ATTRIB_RES are implemented.
    
    CC: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index e01e15dbf1ab..b105cfb00e76 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -22,6 +22,8 @@
 #define DIGITAL_PROTO_NFCA_RF_TECH \
 	(NFC_PROTO_JEWEL_MASK | NFC_PROTO_MIFARE_MASK | NFC_PROTO_NFC_DEP_MASK)
 
+#define DIGITAL_PROTO_NFCB_RF_TECH	NFC_PROTO_ISO14443_B_MASK
+
 #define DIGITAL_PROTO_NFCF_RF_TECH \
 	(NFC_PROTO_FELICA_MASK | NFC_PROTO_NFC_DEP_MASK)
 
@@ -345,6 +347,12 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 		add_crc = digital_skb_add_crc_a;
 		break;
 
+	case NFC_PROTO_ISO14443_B:
+		framing = NFC_DIGITAL_FRAMING_NFCB_T4T;
+		check_crc = digital_skb_check_crc_b;
+		add_crc = digital_skb_add_crc_b;
+		break;
+
 	default:
 		pr_err("Invalid protocol %d\n", protocol);
 		return -EINVAL;
@@ -475,6 +483,10 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 		digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106A,
 				      digital_in_send_sens_req);
 
+	if (matching_im_protocols & DIGITAL_PROTO_NFCB_RF_TECH)
+		digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106B,
+				      digital_in_send_sensb_req);
+
 	if (matching_im_protocols & DIGITAL_PROTO_NFCF_RF_TECH) {
 		digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_212F,
 				      digital_in_send_sensf_req);
@@ -635,7 +647,8 @@ static void digital_in_send_complete(struct nfc_digital_dev *ddev, void *arg,
 		goto done;
 	}
 
-	if (ddev->curr_protocol == NFC_PROTO_ISO14443) {
+	if ((ddev->curr_protocol == NFC_PROTO_ISO14443) ||
+	    (ddev->curr_protocol == NFC_PROTO_ISO14443_B)) {
 		rc = digital_in_iso_dep_pull_sod(ddev, resp);
 		if (rc)
 			goto done;
@@ -676,7 +689,8 @@ static int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,
 		goto exit;
 	}
 
-	if (ddev->curr_protocol == NFC_PROTO_ISO14443) {
+	if ((ddev->curr_protocol == NFC_PROTO_ISO14443) ||
+	    (ddev->curr_protocol == NFC_PROTO_ISO14443_B)) {
 		rc = digital_in_iso_dep_push_sod(ddev, skb);
 		if (rc)
 			goto exit;
@@ -747,6 +761,8 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 		ddev->protocols |= NFC_PROTO_ISO15693_MASK;
 	if (supported_protocols & NFC_PROTO_ISO14443_MASK)
 		ddev->protocols |= NFC_PROTO_ISO14443_MASK;
+	if (supported_protocols & NFC_PROTO_ISO14443_B_MASK)
+		ddev->protocols |= NFC_PROTO_ISO14443_B_MASK;
 
 	ddev->tx_headroom = tx_headroom + DIGITAL_MAX_HEADER_LEN;
 	ddev->tx_tailroom = tx_tailroom + DIGITAL_CRC_LEN;

commit ceeee42d85b4c91b16b6019e69c584589b72be04
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Thu Mar 6 07:39:19 2014 -0700

    NFC: digital: Rename Type V tags to Type 5 tags
    
    According to the latest draft specification from
    the NFC-V committee, ISO/IEC 15693 tags will be
    referred to as "Type 5" tags and not "Type V"
    tags anymore.  Make the code reflect the new
    terminology.
    
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 492fa7355e0d..e01e15dbf1ab 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -334,7 +334,7 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 		break;
 
 	case NFC_PROTO_ISO15693:
-		framing = NFC_DIGITAL_FRAMING_ISO15693_TVT;
+		framing = NFC_DIGITAL_FRAMING_ISO15693_T5T;
 		check_crc = digital_skb_check_crc_b;
 		add_crc = digital_skb_add_crc_b;
 		break;

commit 4f913d4631fa9c47320669b2e7ec62fa7436719d
Author: Axel Lin <axel.lin@ingics.com>
Date:   Sat Feb 22 10:16:11 2014 +0800

    NFC: digital: Use matching_[im|tm]_protocols to check with NFC protocols masks
    
    This ensures we won't add polling function to the table of polling technologies
    for non-supported protocols.
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 969a7f924a37..492fa7355e0d 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -475,7 +475,7 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 		digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106A,
 				      digital_in_send_sens_req);
 
-	if (im_protocols & DIGITAL_PROTO_NFCF_RF_TECH) {
+	if (matching_im_protocols & DIGITAL_PROTO_NFCF_RF_TECH) {
 		digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_212F,
 				      digital_in_send_sensf_req);
 
@@ -487,7 +487,7 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 		digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_ISO15693,
 				      digital_in_send_iso15693_inv_req);
 
-	if (tm_protocols & NFC_PROTO_NFC_DEP_MASK) {
+	if (matching_tm_protocols & NFC_PROTO_NFC_DEP_MASK) {
 		if (ddev->ops->tg_listen_mdaa) {
 			digital_add_poll_tech(ddev, 0,
 					      digital_tg_listen_mdaa);

commit 6ea7398d00345a33b47d905875416ca4421838de
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Wed Feb 12 14:27:51 2014 +0100

    NFC: digital: Fix a possible memory leak
    
    This fixes a memory leak issue that may occur if data sending fails in
    initiator mode. The data_exch structure was not released in case of
    error.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 10146e703270..969a7f924a37 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -671,19 +671,27 @@ static int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,
 	data_exch->cb = cb;
 	data_exch->cb_context = cb_context;
 
-	if (ddev->curr_protocol == NFC_PROTO_NFC_DEP)
-		return digital_in_send_dep_req(ddev, target, skb, data_exch);
+	if (ddev->curr_protocol == NFC_PROTO_NFC_DEP) {
+		rc = digital_in_send_dep_req(ddev, target, skb, data_exch);
+		goto exit;
+	}
 
 	if (ddev->curr_protocol == NFC_PROTO_ISO14443) {
 		rc = digital_in_iso_dep_push_sod(ddev, skb);
 		if (rc)
-			return rc;
+			goto exit;
 	}
 
 	ddev->skb_add_crc(skb);
 
-	return digital_in_send_cmd(ddev, skb, 500, digital_in_send_complete,
-				   data_exch);
+	rc = digital_in_send_cmd(ddev, skb, 500, digital_in_send_complete,
+				 data_exch);
+
+exit:
+	if (rc)
+		kfree(data_exch);
+
+	return rc;
 }
 
 static struct nfc_ops digital_nfc_ops = {

commit 564af14e36742f5900e40d48dcf30a3414acb143
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Wed Feb 12 12:13:23 2014 +0100

    NFC: digital: Add missing break in switch statement
    
    There was a missing break making the digital stack configured for
    ISO1443 target instead of ISO15693.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 5b440e7d9598..10146e703270 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -337,6 +337,7 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 		framing = NFC_DIGITAL_FRAMING_ISO15693_TVT;
 		check_crc = digital_skb_check_crc_b;
 		add_crc = digital_skb_add_crc_b;
+		break;
 
 	case NFC_PROTO_ISO14443:
 		framing = NFC_DIGITAL_FRAMING_NFCA_T4T;

commit c813007f9ffb0b6e9f3dc43bfd9e28806aa57e5d
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Mon Jan 27 00:31:32 2014 +0100

    NFC: digital: Add ISO-DEP support for data exchange
    
    When a type 4A target is activated, this change adds the ISO-DEP SoD
    when sending frames and removes it when receiving responses. Chaining
    is not supported so sent frames are rejected if they exceed remote FSC
    bytes.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index e1f240266adf..5b440e7d9598 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -624,20 +624,30 @@ static void digital_in_send_complete(struct nfc_digital_dev *ddev, void *arg,
 
 	if (IS_ERR(resp)) {
 		rc = PTR_ERR(resp);
+		resp = NULL;
 		goto done;
 	}
 
-	if (ddev->curr_protocol == NFC_PROTO_MIFARE)
+	if (ddev->curr_protocol == NFC_PROTO_MIFARE) {
 		rc = digital_in_recv_mifare_res(resp);
-	else
-		rc = ddev->skb_check_crc(resp);
+		/* crc check is done in digital_in_recv_mifare_res() */
+		goto done;
+	}
+
+	if (ddev->curr_protocol == NFC_PROTO_ISO14443) {
+		rc = digital_in_iso_dep_pull_sod(ddev, resp);
+		if (rc)
+			goto done;
+	}
+
+	rc = ddev->skb_check_crc(resp);
 
+done:
 	if (rc) {
 		kfree_skb(resp);
 		resp = NULL;
 	}
 
-done:
 	data_exch->cb(data_exch->cb_context, resp, rc);
 
 	kfree(data_exch);
@@ -649,6 +659,7 @@ static int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,
 {
 	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
 	struct digital_data_exch *data_exch;
+	int rc;
 
 	data_exch = kzalloc(sizeof(struct digital_data_exch), GFP_KERNEL);
 	if (!data_exch) {
@@ -662,6 +673,12 @@ static int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,
 	if (ddev->curr_protocol == NFC_PROTO_NFC_DEP)
 		return digital_in_send_dep_req(ddev, target, skb, data_exch);
 
+	if (ddev->curr_protocol == NFC_PROTO_ISO14443) {
+		rc = digital_in_iso_dep_push_sod(ddev, skb);
+		if (rc)
+			return rc;
+	}
+
 	ddev->skb_add_crc(skb);
 
 	return digital_in_send_cmd(ddev, skb, 500, digital_in_send_complete,

commit 12e3d241e42956da168fd499347855af799f62fb
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Mon Jan 27 00:31:31 2014 +0100

    NFC: digital: Add poll support for type 4A tag platform
    
    This adds support for ATS request and response handling for type 4A tag
    activation.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 48906ca60540..e1f240266adf 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -337,6 +337,11 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 		framing = NFC_DIGITAL_FRAMING_ISO15693_TVT;
 		check_crc = digital_skb_check_crc_b;
 		add_crc = digital_skb_add_crc_b;
+
+	case NFC_PROTO_ISO14443:
+		framing = NFC_DIGITAL_FRAMING_NFCA_T4T;
+		check_crc = digital_skb_check_crc_a;
+		add_crc = digital_skb_add_crc_a;
 		break;
 
 	default:
@@ -714,6 +719,8 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 		ddev->protocols |= NFC_PROTO_NFC_DEP_MASK;
 	if (supported_protocols & NFC_PROTO_ISO15693_MASK)
 		ddev->protocols |= NFC_PROTO_ISO15693_MASK;
+	if (supported_protocols & NFC_PROTO_ISO14443_MASK)
+		ddev->protocols |= NFC_PROTO_ISO14443_MASK;
 
 	ddev->tx_headroom = tx_headroom + DIGITAL_MAX_HEADER_LEN;
 	ddev->tx_tailroom = tx_tailroom + DIGITAL_CRC_LEN;

commit a381d4828625f526d290b296a829f8549b14ce49
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Tue Jan 21 16:23:59 2014 -0700

    NFC: digital: Add Digital Layer support for ISO/IEC 15693
    
    Add support for ISO/IEC 15693 to the digital layer.  The code
    currently uses single-slot anticollision only since the digital
    layer infrastructure only supports one tag per adapter (making
    it pointless to do 16-slot anticollision).
    
    The code uses two new framing types:
    'NFC_DIGITAL_FRAMING_ISO15693_INVENTORY' and
    'NFC_DIGITAL_FRAMING_ISO15693_TVT'.  The former is used to
    tell the driver to prepare for an Inventory command and the
    ensuing anticollision sequence.  The latter is used to tell
    the driver that the anticollision sequence is over and to
    prepare for non-inventory commands.
    
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index c129d1571ca6..48906ca60540 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -25,6 +25,8 @@
 #define DIGITAL_PROTO_NFCF_RF_TECH \
 	(NFC_PROTO_FELICA_MASK | NFC_PROTO_NFC_DEP_MASK)
 
+#define DIGITAL_PROTO_ISO15693_RF_TECH	NFC_PROTO_ISO15693_MASK
+
 struct digital_cmd {
 	struct list_head queue;
 
@@ -331,6 +333,12 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 		}
 		break;
 
+	case NFC_PROTO_ISO15693:
+		framing = NFC_DIGITAL_FRAMING_ISO15693_TVT;
+		check_crc = digital_skb_check_crc_b;
+		add_crc = digital_skb_add_crc_b;
+		break;
+
 	default:
 		pr_err("Invalid protocol %d\n", protocol);
 		return -EINVAL;
@@ -469,6 +477,10 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 				      digital_in_send_sensf_req);
 	}
 
+	if (matching_im_protocols & DIGITAL_PROTO_ISO15693_RF_TECH)
+		digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_ISO15693,
+				      digital_in_send_iso15693_inv_req);
+
 	if (tm_protocols & NFC_PROTO_NFC_DEP_MASK) {
 		if (ddev->ops->tg_listen_mdaa) {
 			digital_add_poll_tech(ddev, 0,
@@ -700,6 +712,8 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 		ddev->protocols |= NFC_PROTO_FELICA_MASK;
 	if (supported_protocols & NFC_PROTO_NFC_DEP_MASK)
 		ddev->protocols |= NFC_PROTO_NFC_DEP_MASK;
+	if (supported_protocols & NFC_PROTO_ISO15693_MASK)
+		ddev->protocols |= NFC_PROTO_ISO15693_MASK;
 
 	ddev->tx_headroom = tx_headroom + DIGITAL_MAX_HEADER_LEN;
 	ddev->tx_tailroom = tx_tailroom + DIGITAL_CRC_LEN;

commit 48e1044515967a0d88ee076045b2141535557d8e
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Mon Jan 6 23:34:37 2014 +0100

    NFC: digital: Set current target active on activate_target() call
    
    The curr_protocol field of nfc_digital_dev structure used to determine
    if a target is currently active was set too soon, immediately when a
    target is found. This is not good since there is no other way than
    deactivate_target() to reset curr_protocol and if activate_target() is
    not called, the target remains active and it's not possible to put the
    device in poll mode anymore.
    
    With this patch curr_protocol is set when nfc core activates a target,
    puts a device up, or when an ATR_REQ is received in target mode.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 09fc95439955..c129d1571ca6 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -339,7 +339,6 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 	pr_debug("rf_tech=%d, protocol=%d\n", rf_tech, protocol);
 
 	ddev->curr_rf_tech = rf_tech;
-	ddev->curr_protocol = protocol;
 
 	if (DIGITAL_DRV_CAPS_IN_CRC(ddev)) {
 		ddev->skb_add_crc = digital_skb_add_crc_none;
@@ -541,8 +540,14 @@ static int digital_dep_link_up(struct nfc_dev *nfc_dev,
 			       __u8 comm_mode, __u8 *gb, size_t gb_len)
 {
 	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
+	int rc;
+
+	rc = digital_in_send_atr_req(ddev, target, comm_mode, gb, gb_len);
 
-	return digital_in_send_atr_req(ddev, target, comm_mode, gb, gb_len);
+	if (!rc)
+		ddev->curr_protocol = NFC_PROTO_NFC_DEP;
+
+	return rc;
 }
 
 static int digital_dep_link_down(struct nfc_dev *nfc_dev)
@@ -557,6 +562,20 @@ static int digital_dep_link_down(struct nfc_dev *nfc_dev)
 static int digital_activate_target(struct nfc_dev *nfc_dev,
 				   struct nfc_target *target, __u32 protocol)
 {
+	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
+
+	if (ddev->poll_tech_count) {
+		pr_err("Can't activate a target while polling\n");
+		return -EBUSY;
+	}
+
+	if (ddev->curr_protocol) {
+		pr_err("A target is already active\n");
+		return -EBUSY;
+	}
+
+	ddev->curr_protocol = protocol;
+
 	return 0;
 }
 
@@ -565,6 +584,11 @@ static void digital_deactivate_target(struct nfc_dev *nfc_dev,
 {
 	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
 
+	if (!ddev->curr_protocol) {
+		pr_err("No active target\n");
+		return;
+	}
+
 	ddev->curr_protocol = 0;
 }
 

commit 260425308de63155a087361d961dafd2dd45e275
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Fri Sep 20 16:56:40 2013 +0200

    NFC: digital: Add newline to pr_* calls
    
    We do not add the newline to the pr_fmt macro, in order to give more
    flexibility to the caller and to keep the logging style consistent with
    the rest of the NFC and kernel code.
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 6f563d09b520..09fc95439955 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -198,14 +198,14 @@ static void digital_wq_cmd(struct work_struct *work)
 		break;
 
 	default:
-		pr_err("Unknown cmd type %d", cmd->type);
+		pr_err("Unknown cmd type %d\n", cmd->type);
 		return;
 	}
 
 	if (!rc)
 		return;
 
-	pr_err("in_send_command returned err %d", rc);
+	pr_err("in_send_command returned err %d\n", rc);
 
 	mutex_lock(&ddev->cmd_lock);
 	list_del(&cmd->queue);
@@ -252,7 +252,7 @@ int digital_in_configure_hw(struct nfc_digital_dev *ddev, int type, int param)
 
 	rc = ddev->ops->in_configure_hw(ddev, type, param);
 	if (rc)
-		pr_err("in_configure_hw failed: %d", rc);
+		pr_err("in_configure_hw failed: %d\n", rc);
 
 	return rc;
 }
@@ -263,7 +263,7 @@ int digital_tg_configure_hw(struct nfc_digital_dev *ddev, int type, int param)
 
 	rc = ddev->ops->tg_configure_hw(ddev, type, param);
 	if (rc)
-		pr_err("tg_configure_hw failed: %d", rc);
+		pr_err("tg_configure_hw failed: %d\n", rc);
 
 	return rc;
 }
@@ -332,11 +332,11 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 		break;
 
 	default:
-		pr_err("Invalid protocol %d", protocol);
+		pr_err("Invalid protocol %d\n", protocol);
 		return -EINVAL;
 	}
 
-	pr_debug("rf_tech=%d, protocol=%d", rf_tech, protocol);
+	pr_debug("rf_tech=%d, protocol=%d\n", rf_tech, protocol);
 
 	ddev->curr_rf_tech = rf_tech;
 	ddev->curr_protocol = protocol;
@@ -434,24 +434,24 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
 	u32 matching_im_protocols, matching_tm_protocols;
 
-	pr_debug("protocols: im 0x%x, tm 0x%x, supported 0x%x", im_protocols,
+	pr_debug("protocols: im 0x%x, tm 0x%x, supported 0x%x\n", im_protocols,
 		 tm_protocols, ddev->protocols);
 
 	matching_im_protocols = ddev->protocols & im_protocols;
 	matching_tm_protocols = ddev->protocols & tm_protocols;
 
 	if (!matching_im_protocols && !matching_tm_protocols) {
-		pr_err("No known protocol");
+		pr_err("Unknown protocol\n");
 		return -EINVAL;
 	}
 
 	if (ddev->poll_tech_count) {
-		pr_err("Already polling");
+		pr_err("Already polling\n");
 		return -EBUSY;
 	}
 
 	if (ddev->curr_protocol) {
-		pr_err("A target is already active");
+		pr_err("A target is already active\n");
 		return -EBUSY;
 	}
 
@@ -487,7 +487,7 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 	}
 
 	if (!ddev->poll_tech_count) {
-		pr_err("Unsupported protocols: im=0x%x, tm=0x%x",
+		pr_err("Unsupported protocols: im=0x%x, tm=0x%x\n",
 		       matching_im_protocols, matching_tm_protocols);
 		return -EINVAL;
 	}
@@ -504,7 +504,7 @@ static void digital_stop_poll(struct nfc_dev *nfc_dev)
 	mutex_lock(&ddev->poll_lock);
 
 	if (!ddev->poll_tech_count) {
-		pr_err("Polling operation was not running");
+		pr_err("Polling operation was not running\n");
 		mutex_unlock(&ddev->poll_lock);
 		return;
 	}
@@ -611,7 +611,7 @@ static int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,
 
 	data_exch = kzalloc(sizeof(struct digital_data_exch), GFP_KERNEL);
 	if (!data_exch) {
-		pr_err("Failed to allocate data_exch struct");
+		pr_err("Failed to allocate data_exch struct\n");
 		return -ENOMEM;
 	}
 
@@ -653,10 +653,8 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 		return NULL;
 
 	ddev = kzalloc(sizeof(struct nfc_digital_dev), GFP_KERNEL);
-	if (!ddev) {
-		pr_err("kzalloc failed");
+	if (!ddev)
 		return NULL;
-	}
 
 	ddev->driver_capabilities = driver_capabilities;
 	ddev->ops = ops;
@@ -686,7 +684,7 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 					    ddev->tx_headroom,
 					    ddev->tx_tailroom);
 	if (!ddev->nfc_dev) {
-		pr_err("nfc_allocate_device failed");
+		pr_err("nfc_allocate_device failed\n");
 		goto free_dev;
 	}
 

commit c5da0e4a35eb1eba0c1593bef4bf2b58d9d50d6b
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Fri Sep 20 09:05:48 2013 +0200

    NFC: digital: Remove PR_ERR and PR_DBG macros
    
    They can be replaced by the standard pr_err and pr_debug one after
    defining the right pr_fmt macro.
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 66151fc5d990..6f563d09b520 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -13,6 +13,8 @@
  *
  */
 
+#define pr_fmt(fmt) "digital: %s: " fmt, __func__
+
 #include <linux/module.h>
 
 #include "digital.h"
@@ -196,14 +198,14 @@ static void digital_wq_cmd(struct work_struct *work)
 		break;
 
 	default:
-		PR_ERR("Unknown cmd type %d", cmd->type);
+		pr_err("Unknown cmd type %d", cmd->type);
 		return;
 	}
 
 	if (!rc)
 		return;
 
-	PR_ERR("in_send_command returned err %d", rc);
+	pr_err("in_send_command returned err %d", rc);
 
 	mutex_lock(&ddev->cmd_lock);
 	list_del(&cmd->queue);
@@ -250,7 +252,7 @@ int digital_in_configure_hw(struct nfc_digital_dev *ddev, int type, int param)
 
 	rc = ddev->ops->in_configure_hw(ddev, type, param);
 	if (rc)
-		PR_ERR("in_configure_hw failed: %d", rc);
+		pr_err("in_configure_hw failed: %d", rc);
 
 	return rc;
 }
@@ -261,7 +263,7 @@ int digital_tg_configure_hw(struct nfc_digital_dev *ddev, int type, int param)
 
 	rc = ddev->ops->tg_configure_hw(ddev, type, param);
 	if (rc)
-		PR_ERR("tg_configure_hw failed: %d", rc);
+		pr_err("tg_configure_hw failed: %d", rc);
 
 	return rc;
 }
@@ -330,11 +332,11 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 		break;
 
 	default:
-		PR_ERR("Invalid protocol %d", protocol);
+		pr_err("Invalid protocol %d", protocol);
 		return -EINVAL;
 	}
 
-	PR_DBG("rf_tech=%d, protocol=%d", rf_tech, protocol);
+	pr_debug("rf_tech=%d, protocol=%d", rf_tech, protocol);
 
 	ddev->curr_rf_tech = rf_tech;
 	ddev->curr_protocol = protocol;
@@ -432,24 +434,24 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
 	u32 matching_im_protocols, matching_tm_protocols;
 
-	PR_DBG("protocols: im 0x%x, tm 0x%x, supported 0x%x", im_protocols,
-	       tm_protocols, ddev->protocols);
+	pr_debug("protocols: im 0x%x, tm 0x%x, supported 0x%x", im_protocols,
+		 tm_protocols, ddev->protocols);
 
 	matching_im_protocols = ddev->protocols & im_protocols;
 	matching_tm_protocols = ddev->protocols & tm_protocols;
 
 	if (!matching_im_protocols && !matching_tm_protocols) {
-		PR_ERR("No known protocol");
+		pr_err("No known protocol");
 		return -EINVAL;
 	}
 
 	if (ddev->poll_tech_count) {
-		PR_ERR("Already polling");
+		pr_err("Already polling");
 		return -EBUSY;
 	}
 
 	if (ddev->curr_protocol) {
-		PR_ERR("A target is already active");
+		pr_err("A target is already active");
 		return -EBUSY;
 	}
 
@@ -485,7 +487,7 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 	}
 
 	if (!ddev->poll_tech_count) {
-		PR_ERR("Unsupported protocols: im=0x%x, tm=0x%x",
+		pr_err("Unsupported protocols: im=0x%x, tm=0x%x",
 		       matching_im_protocols, matching_tm_protocols);
 		return -EINVAL;
 	}
@@ -502,7 +504,7 @@ static void digital_stop_poll(struct nfc_dev *nfc_dev)
 	mutex_lock(&ddev->poll_lock);
 
 	if (!ddev->poll_tech_count) {
-		PR_ERR("Polling operation was not running");
+		pr_err("Polling operation was not running");
 		mutex_unlock(&ddev->poll_lock);
 		return;
 	}
@@ -609,7 +611,7 @@ static int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,
 
 	data_exch = kzalloc(sizeof(struct digital_data_exch), GFP_KERNEL);
 	if (!data_exch) {
-		PR_ERR("Failed to allocate data_exch struct");
+		pr_err("Failed to allocate data_exch struct");
 		return -ENOMEM;
 	}
 
@@ -652,7 +654,7 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 
 	ddev = kzalloc(sizeof(struct nfc_digital_dev), GFP_KERNEL);
 	if (!ddev) {
-		PR_ERR("kzalloc failed");
+		pr_err("kzalloc failed");
 		return NULL;
 	}
 
@@ -684,7 +686,7 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 					    ddev->tx_headroom,
 					    ddev->tx_tailroom);
 	if (!ddev->nfc_dev) {
-		PR_ERR("nfc_allocate_device failed");
+		pr_err("nfc_allocate_device failed");
 		goto free_dev;
 	}
 

commit 1c7a4c24fbfd99442cc6e14dc80fcb00f118e8b8
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:30 2013 +0200

    NFC Digital: Add target NFC-DEP support
    
    This adds support for NFC-DEP target mode for NFC-A and NFC-F
    technologies.
    
    If the driver provides it, the stack uses an automatic mode for
    technology detection and automatic anti-collision. Otherwise the stack
    tries to use non-automatic synchronization and listens for SENS_REQ and
    SENSF_REQ commands.
    
    The detection, activation, and data exchange procedures work exactly
    the same way as in initiator mode, as described in the previous
    commits, except that the digital stack waits for commands and sends
    responses back to the peer device.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index dccfcccf6998..66151fc5d990 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -32,6 +32,7 @@ struct digital_cmd {
 	u16 timeout;
 	struct sk_buff *req;
 	struct sk_buff *resp;
+	struct digital_tg_mdaa_params *mdaa_params;
 
 	nfc_digital_cmd_complete_t cmd_cb;
 	void *cb_context;
@@ -131,6 +132,7 @@ static void digital_wq_cmd_complete(struct work_struct *work)
 
 	cmd->cmd_cb(ddev, cmd->cb_context, cmd->resp);
 
+	kfree(cmd->mdaa_params);
 	kfree(cmd);
 
 	schedule_work(&ddev->cmd_work);
@@ -150,6 +152,7 @@ static void digital_wq_cmd(struct work_struct *work)
 {
 	int rc;
 	struct digital_cmd *cmd;
+	struct digital_tg_mdaa_params *params;
 	struct nfc_digital_dev *ddev = container_of(work,
 						    struct nfc_digital_dev,
 						    cmd_work);
@@ -174,6 +177,24 @@ static void digital_wq_cmd(struct work_struct *work)
 		rc = ddev->ops->in_send_cmd(ddev, cmd->req, cmd->timeout,
 					    digital_send_cmd_complete, cmd);
 		break;
+
+	case DIGITAL_CMD_TG_SEND:
+		rc = ddev->ops->tg_send_cmd(ddev, cmd->req, cmd->timeout,
+					    digital_send_cmd_complete, cmd);
+		break;
+
+	case DIGITAL_CMD_TG_LISTEN:
+		rc = ddev->ops->tg_listen(ddev, cmd->timeout,
+					  digital_send_cmd_complete, cmd);
+		break;
+
+	case DIGITAL_CMD_TG_LISTEN_MDAA:
+		params = cmd->mdaa_params;
+
+		rc = ddev->ops->tg_listen_mdaa(ddev, params, cmd->timeout,
+					       digital_send_cmd_complete, cmd);
+		break;
+
 	default:
 		PR_ERR("Unknown cmd type %d", cmd->type);
 		return;
@@ -189,14 +210,16 @@ static void digital_wq_cmd(struct work_struct *work)
 	mutex_unlock(&ddev->cmd_lock);
 
 	kfree_skb(cmd->req);
+	kfree(cmd->mdaa_params);
 	kfree(cmd);
 
 	schedule_work(&ddev->cmd_work);
 }
 
 int digital_send_cmd(struct nfc_digital_dev *ddev, u8 cmd_type,
-		     struct sk_buff *skb, u16 timeout,
-		     nfc_digital_cmd_complete_t cmd_cb, void *cb_context)
+		     struct sk_buff *skb, struct digital_tg_mdaa_params *params,
+		     u16 timeout, nfc_digital_cmd_complete_t cmd_cb,
+		     void *cb_context)
 {
 	struct digital_cmd *cmd;
 
@@ -207,6 +230,7 @@ int digital_send_cmd(struct nfc_digital_dev *ddev, u8 cmd_type,
 	cmd->type = cmd_type;
 	cmd->timeout = timeout;
 	cmd->req = skb;
+	cmd->mdaa_params = params;
 	cmd->cmd_cb = cmd_cb;
 	cmd->cb_context = cb_context;
 	INIT_LIST_HEAD(&cmd->queue);
@@ -231,6 +255,38 @@ int digital_in_configure_hw(struct nfc_digital_dev *ddev, int type, int param)
 	return rc;
 }
 
+int digital_tg_configure_hw(struct nfc_digital_dev *ddev, int type, int param)
+{
+	int rc;
+
+	rc = ddev->ops->tg_configure_hw(ddev, type, param);
+	if (rc)
+		PR_ERR("tg_configure_hw failed: %d", rc);
+
+	return rc;
+}
+
+static int digital_tg_listen_mdaa(struct nfc_digital_dev *ddev, u8 rf_tech)
+{
+	struct digital_tg_mdaa_params *params;
+
+	params = kzalloc(sizeof(struct digital_tg_mdaa_params), GFP_KERNEL);
+	if (!params)
+		return -ENOMEM;
+
+	params->sens_res = DIGITAL_SENS_RES_NFC_DEP;
+	get_random_bytes(params->nfcid1, sizeof(params->nfcid1));
+	params->sel_res = DIGITAL_SEL_RES_NFC_DEP;
+
+	params->nfcid2[0] = DIGITAL_SENSF_NFCID2_NFC_DEP_B1;
+	params->nfcid2[1] = DIGITAL_SENSF_NFCID2_NFC_DEP_B2;
+	get_random_bytes(params->nfcid2 + 2, NFC_NFCID2_MAXSIZE - 2);
+	params->sc = DIGITAL_SENSF_FELICA_SC;
+
+	return digital_send_cmd(ddev, DIGITAL_CMD_TG_LISTEN_MDAA, NULL, params,
+				500, digital_tg_recv_atr_req, NULL);
+}
+
 int digital_target_found(struct nfc_digital_dev *ddev,
 			 struct nfc_target *target, u8 protocol)
 {
@@ -412,6 +468,22 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 				      digital_in_send_sensf_req);
 	}
 
+	if (tm_protocols & NFC_PROTO_NFC_DEP_MASK) {
+		if (ddev->ops->tg_listen_mdaa) {
+			digital_add_poll_tech(ddev, 0,
+					      digital_tg_listen_mdaa);
+		} else {
+			digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106A,
+					      digital_tg_listen_nfca);
+
+			digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_212F,
+					      digital_tg_listen_nfcf);
+
+			digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_424F,
+					      digital_tg_listen_nfcf);
+		}
+	}
+
 	if (!ddev->poll_tech_count) {
 		PR_ERR("Unsupported protocols: im=0x%x, tm=0x%x",
 		       matching_im_protocols, matching_tm_protocols);
@@ -496,7 +568,9 @@ static void digital_deactivate_target(struct nfc_dev *nfc_dev,
 
 static int digital_tg_send(struct nfc_dev *dev, struct sk_buff *skb)
 {
-	return -EOPNOTSUPP;
+	struct nfc_digital_dev *ddev = nfc_get_drvdata(dev);
+
+	return digital_tg_send_dep_res(ddev, skb);
 }
 
 static void digital_in_send_complete(struct nfc_digital_dev *ddev, void *arg,
@@ -654,6 +728,7 @@ void nfc_digital_unregister_device(struct nfc_digital_dev *ddev)
 
 	list_for_each_entry_safe(cmd, n, &ddev->cmd_queue, queue) {
 		list_del(&cmd->queue);
+		kfree(cmd->mdaa_params);
 		kfree(cmd);
 	}
 }

commit 7d0911c02fa2a448a28d7844d2a0c439ff8397b1
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:29 2013 +0200

    NFC Digital: Add initiator NFC-DEP support
    
    This adds support for NFC-DEP protocol in initiator mode for NFC-A and
    NFC-F technologies.
    
    When a target is detected, the process flow is as follow:
    
    For NFC-A technology:
    1 - The digital stack receives a SEL_RES as the reply of the SEL_REQ
        command.
    2   - If b7 of SEL_RES is set, the peer device is configure for NFC-DEP
          protocol. NFC core is notified through nfc_targets_found().
          Execution continues at step 4.
    3   - Otherwise, it's a tag and the NFC core is notified. Detection
          ends.
    4 - The digital stacks sends an ATR_REQ command containing a randomly
        generated NFCID3 and the general bytes obtained from the LLCP layer
        of NFC core.
    
    For NFC-F technology:
    1 - The digital stack receives a SENSF_RES as the reply of the
        SENSF_REQ command.
    2   - If B1 and B2 of NFCID2 are 0x01 and 0xFE respectively, the peer
          device is configured for NFC-DEP protocol. NFC core is notified
          through nfc_targets_found(). Execution continues at step 4.
    3   - Otherwise it's a type 3 tag. NFC core is notified. Detection
          ends.
    4 - The digital stacks sends an ATR_REQ command containing the NFC-F
        NFCID2 as NFCID3 and the general bytes obtained from the LLCP layer
        of NFC core.
    
    For both technologies:
    5 - The digital stacks receives the ATR_RES response containing the
        NFCID3 and the general bytes of the peer device.
    6 - The digital stack notifies NFC core that the DEP link is up through
        nfc_dep_link_up().
    7 - The NFC core performs data exchange through tm_transceive().
    8 - The digital stack sends a DEP_REQ command containing an I PDU with
        the data from NFC core.
    9 - The digital stack receives a DEP_RES command
    10  - If the DEP_RES response contains a supervisor PDU with timeout
          extension request (RTOX) the digital stack sends a DEP_REQ
          command containing a supervisor PDU acknowledging the RTOX
          request. The execution continues at step 9.
    11  - If the DEP_RES response contains an I PDU, the response data is
          passed back to NFC core through the response callback. The
          execution continues at step 8.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 25e5bcb946e0..dccfcccf6998 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -18,9 +18,10 @@
 #include "digital.h"
 
 #define DIGITAL_PROTO_NFCA_RF_TECH \
-	(NFC_PROTO_JEWEL_MASK | NFC_PROTO_MIFARE_MASK)
+	(NFC_PROTO_JEWEL_MASK | NFC_PROTO_MIFARE_MASK | NFC_PROTO_NFC_DEP_MASK)
 
-#define DIGITAL_PROTO_NFCF_RF_TECH (NFC_PROTO_FELICA_MASK)
+#define DIGITAL_PROTO_NFCF_RF_TECH \
+	(NFC_PROTO_FELICA_MASK | NFC_PROTO_NFC_DEP_MASK)
 
 struct digital_cmd {
 	struct list_head queue;
@@ -260,6 +261,18 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 		add_crc = digital_skb_add_crc_f;
 		break;
 
+	case NFC_PROTO_NFC_DEP:
+		if (rf_tech == NFC_DIGITAL_RF_TECH_106A) {
+			framing = NFC_DIGITAL_FRAMING_NFCA_NFC_DEP;
+			check_crc = digital_skb_check_crc_a;
+			add_crc = digital_skb_add_crc_a;
+		} else {
+			framing = NFC_DIGITAL_FRAMING_NFCF_NFC_DEP;
+			check_crc = digital_skb_check_crc_f;
+			add_crc = digital_skb_add_crc_f;
+		}
+		break;
+
 	default:
 		PR_ERR("Invalid protocol %d", protocol);
 		return -EINVAL;
@@ -453,12 +466,18 @@ static int digital_dep_link_up(struct nfc_dev *nfc_dev,
 			       struct nfc_target *target,
 			       __u8 comm_mode, __u8 *gb, size_t gb_len)
 {
-	return -EOPNOTSUPP;
+	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
+
+	return digital_in_send_atr_req(ddev, target, comm_mode, gb, gb_len);
 }
 
 static int digital_dep_link_down(struct nfc_dev *nfc_dev)
 {
-	return -EOPNOTSUPP;
+	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
+
+	ddev->curr_protocol = 0;
+
+	return 0;
 }
 
 static int digital_activate_target(struct nfc_dev *nfc_dev,
@@ -523,6 +542,9 @@ static int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,
 	data_exch->cb = cb;
 	data_exch->cb_context = cb_context;
 
+	if (ddev->curr_protocol == NFC_PROTO_NFC_DEP)
+		return digital_in_send_dep_req(ddev, target, skb, data_exch);
+
 	ddev->skb_add_crc(skb);
 
 	return digital_in_send_cmd(ddev, skb, 500, digital_in_send_complete,
@@ -578,6 +600,8 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 		ddev->protocols |= NFC_PROTO_MIFARE_MASK;
 	if (supported_protocols & NFC_PROTO_FELICA_MASK)
 		ddev->protocols |= NFC_PROTO_FELICA_MASK;
+	if (supported_protocols & NFC_PROTO_NFC_DEP_MASK)
+		ddev->protocols |= NFC_PROTO_NFC_DEP_MASK;
 
 	ddev->tx_headroom = tx_headroom + DIGITAL_MAX_HEADER_LEN;
 	ddev->tx_tailroom = tx_tailroom + DIGITAL_CRC_LEN;

commit 8c0695e4998dd268ff2a05951961247b7e015651
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:28 2013 +0200

    NFC Digital: Add NFC-F technology support
    
    This adds polling support for NFC-F technology at 212 kbits/s and 424
    kbits/s. A user space application like neard can send type 3 tag
    commands through the NFC core.
    
    Process flow for NFC-F detection is as follow:
    
    1 - The digital stack sends the SENSF_REQ command to the NFC device.
    2 - A peer device replies with a SENSF_RES response.
    3   - The digital stack notifies the NFC core of the presence of a
          target in the operation field and passes the target NFCID2.
    
    This also adds support for CRC calculation of type CRC-F. The CRC
    calculation is handled by the digital stack if the NFC device doesn't
    support it.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 4b3ceb45834b..25e5bcb946e0 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -20,6 +20,8 @@
 #define DIGITAL_PROTO_NFCA_RF_TECH \
 	(NFC_PROTO_JEWEL_MASK | NFC_PROTO_MIFARE_MASK)
 
+#define DIGITAL_PROTO_NFCF_RF_TECH (NFC_PROTO_FELICA_MASK)
+
 struct digital_cmd {
 	struct list_head queue;
 
@@ -252,6 +254,12 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 		add_crc = digital_skb_add_crc_a;
 		break;
 
+	case NFC_PROTO_FELICA:
+		framing = NFC_DIGITAL_FRAMING_NFCF_T3T;
+		check_crc = digital_skb_check_crc_f;
+		add_crc = digital_skb_add_crc_f;
+		break;
+
 	default:
 		PR_ERR("Invalid protocol %d", protocol);
 		return -EINVAL;
@@ -383,6 +391,14 @@ static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 		digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106A,
 				      digital_in_send_sens_req);
 
+	if (im_protocols & DIGITAL_PROTO_NFCF_RF_TECH) {
+		digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_212F,
+				      digital_in_send_sensf_req);
+
+		digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_424F,
+				      digital_in_send_sensf_req);
+	}
+
 	if (!ddev->poll_tech_count) {
 		PR_ERR("Unsupported protocols: im=0x%x, tm=0x%x",
 		       matching_im_protocols, matching_tm_protocols);
@@ -560,6 +576,8 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 		ddev->protocols |= NFC_PROTO_JEWEL_MASK;
 	if (supported_protocols & NFC_PROTO_MIFARE_MASK)
 		ddev->protocols |= NFC_PROTO_MIFARE_MASK;
+	if (supported_protocols & NFC_PROTO_FELICA_MASK)
+		ddev->protocols |= NFC_PROTO_FELICA_MASK;
 
 	ddev->tx_headroom = tx_headroom + DIGITAL_MAX_HEADER_LEN;
 	ddev->tx_tailroom = tx_tailroom + DIGITAL_CRC_LEN;

commit 2c66daecc4092e6049673c281b2e6f0d5e59a94c
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:27 2013 +0200

    NFC Digital: Add NFC-A technology support
    
    This adds support for NFC-A technology at 106 kbits/s. The stack can
    detect tags of type 1 and 2. There is no support for collision
    detection. Tags can be read and written by using a user space
    application or a daemon like neard.
    
    The flow of polling operations for NFC-A detection is as follow:
    
    1 - The digital stack sends the SENS_REQ command to the NFC device.
    2 - The NFC device receives a SENS_RES response from a peer device and
        passes it to the digital stack.
    3   - If the SENS_RES response identifies a type 1 tag, detection ends.
          NFC core is notified through nfc_targets_found().
    4   - Otherwise, the digital stack sets the cascade level of NFCID1 to
          CL1 and sends the SDD_REQ command.
    5 - The digital stack selects SEL_CMD and SEL_PAR according to the
        cascade level and sends the SDD_REQ command.
    4 - The digital stack receives a SDD_RES response for the cascade level
        passed in the SDD_REQ command.
    5 - The digital stack analyses (part of) NFCID1 and verify BCC.
    6 - The digital stack sends the SEL_REQ command with the NFCID1
        received in the SDD_RES.
    6 - The peer device replies with a SEL_RES response
    7   - Detection ends if NFCID1 is complete. NFC core notified of new
          target by nfc_targets_found().
    8   - If NFCID1 is not complete, the cascade level is incremented (up
          to and including CL3) and the execution continues at step 5 to
          get the remaining bytes of NFCID1.
    
    Once target detection is done, type 1 and 2 tag commands must be
    handled by a user space application (i.e neard) through the NFC core.
    Responses for type 1 tag are returned directly to user space via NFC
    core.
    Responses of type 2 commands are handled differently. The digital stack
    doesn't analyse the type of commands sent through im_transceive() and
    must differentiate valid responses from error ones.
    The response process flow is as follow:
    
    1 - If the response length is 16 bytes, it is a valid response of a
        READ command. the packet is returned to the NFC core through the
        callback passed to im_transceive(). Processing stops.
    2 - If the response is 1 byte long and is a ACK byte (0x0A), it is a
        valid response of a WRITE command for example. First packet byte
        is set to 0 for no-error and passed back to the NFC core.
        Processing stops.
    3 - Any other response is treated as an error and -EIO error code is
        returned to the NFC core through the response callback.
    
    Moreover, since the driver can't differentiate success response from a
    NACK response, the digital stack has to handle CRC calculation.
    
    Thus, this patch also adds support for CRC calculation. If the driver
    doesn't handle it, the digital stack will calculate CRC and will add it
    to sent frames. CRC will also be checked and removed from received
    frames. Pointers to the correct CRC calculation functions are stored in
    the digital stack device structure when a target is detected. This
    avoids the need to check the current target type for every call to
    im_transceive() and for every response received from a peer device.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 13abd293ca37..4b3ceb45834b 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -47,6 +47,51 @@ struct sk_buff *digital_skb_alloc(struct nfc_digital_dev *ddev,
 	return skb;
 }
 
+void digital_skb_add_crc(struct sk_buff *skb, crc_func_t crc_func, u16 init,
+			 u8 bitwise_inv, u8 msb_first)
+{
+	u16 crc;
+
+	crc = crc_func(init, skb->data, skb->len);
+
+	if (bitwise_inv)
+		crc = ~crc;
+
+	if (msb_first)
+		crc = __fswab16(crc);
+
+	*skb_put(skb, 1) = crc & 0xFF;
+	*skb_put(skb, 1) = (crc >> 8) & 0xFF;
+}
+
+int digital_skb_check_crc(struct sk_buff *skb, crc_func_t crc_func,
+			  u16 crc_init, u8 bitwise_inv, u8 msb_first)
+{
+	int rc;
+	u16 crc;
+
+	if (skb->len <= 2)
+		return -EIO;
+
+	crc = crc_func(crc_init, skb->data, skb->len - 2);
+
+	if (bitwise_inv)
+		crc = ~crc;
+
+	if (msb_first)
+		crc = __swab16(crc);
+
+	rc = (skb->data[skb->len - 2] - (crc & 0xFF)) +
+	     (skb->data[skb->len - 1] - ((crc >> 8) & 0xFF));
+
+	if (rc)
+		return -EIO;
+
+	skb_trim(skb, skb->len - 2);
+
+	return 0;
+}
+
 static inline void digital_switch_rf(struct nfc_digital_dev *ddev, bool on)
 {
 	ddev->ops->switch_rf(ddev, on);
@@ -183,6 +228,62 @@ int digital_in_configure_hw(struct nfc_digital_dev *ddev, int type, int param)
 	return rc;
 }
 
+int digital_target_found(struct nfc_digital_dev *ddev,
+			 struct nfc_target *target, u8 protocol)
+{
+	int rc;
+	u8 framing;
+	u8 rf_tech;
+	int (*check_crc)(struct sk_buff *skb);
+	void (*add_crc)(struct sk_buff *skb);
+
+	rf_tech = ddev->poll_techs[ddev->poll_tech_index].rf_tech;
+
+	switch (protocol) {
+	case NFC_PROTO_JEWEL:
+		framing = NFC_DIGITAL_FRAMING_NFCA_T1T;
+		check_crc = digital_skb_check_crc_b;
+		add_crc = digital_skb_add_crc_b;
+		break;
+
+	case NFC_PROTO_MIFARE:
+		framing = NFC_DIGITAL_FRAMING_NFCA_T2T;
+		check_crc = digital_skb_check_crc_a;
+		add_crc = digital_skb_add_crc_a;
+		break;
+
+	default:
+		PR_ERR("Invalid protocol %d", protocol);
+		return -EINVAL;
+	}
+
+	PR_DBG("rf_tech=%d, protocol=%d", rf_tech, protocol);
+
+	ddev->curr_rf_tech = rf_tech;
+	ddev->curr_protocol = protocol;
+
+	if (DIGITAL_DRV_CAPS_IN_CRC(ddev)) {
+		ddev->skb_add_crc = digital_skb_add_crc_none;
+		ddev->skb_check_crc = digital_skb_check_crc_none;
+	} else {
+		ddev->skb_add_crc = add_crc;
+		ddev->skb_check_crc = check_crc;
+	}
+
+	rc = digital_in_configure_hw(ddev, NFC_DIGITAL_CONFIG_FRAMING, framing);
+	if (rc)
+		return rc;
+
+	target->supported_protocols = (1 << protocol);
+	rc = nfc_targets_found(ddev->nfc_dev, target, 1);
+	if (rc)
+		return rc;
+
+	ddev->poll_tech_count = 0;
+
+	return 0;
+}
+
 void digital_poll_next_tech(struct nfc_digital_dev *ddev)
 {
 	digital_switch_rf(ddev, 0);
@@ -363,11 +464,53 @@ static int digital_tg_send(struct nfc_dev *dev, struct sk_buff *skb)
 	return -EOPNOTSUPP;
 }
 
+static void digital_in_send_complete(struct nfc_digital_dev *ddev, void *arg,
+				     struct sk_buff *resp)
+{
+	struct digital_data_exch *data_exch = arg;
+	int rc;
+
+	if (IS_ERR(resp)) {
+		rc = PTR_ERR(resp);
+		goto done;
+	}
+
+	if (ddev->curr_protocol == NFC_PROTO_MIFARE)
+		rc = digital_in_recv_mifare_res(resp);
+	else
+		rc = ddev->skb_check_crc(resp);
+
+	if (rc) {
+		kfree_skb(resp);
+		resp = NULL;
+	}
+
+done:
+	data_exch->cb(data_exch->cb_context, resp, rc);
+
+	kfree(data_exch);
+}
+
 static int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,
 			   struct sk_buff *skb, data_exchange_cb_t cb,
 			   void *cb_context)
 {
-	return -EOPNOTSUPP;
+	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
+	struct digital_data_exch *data_exch;
+
+	data_exch = kzalloc(sizeof(struct digital_data_exch), GFP_KERNEL);
+	if (!data_exch) {
+		PR_ERR("Failed to allocate data_exch struct");
+		return -ENOMEM;
+	}
+
+	data_exch->cb = cb;
+	data_exch->cb_context = cb_context;
+
+	ddev->skb_add_crc(skb);
+
+	return digital_in_send_cmd(ddev, skb, 500, digital_in_send_complete,
+				   data_exch);
 }
 
 static struct nfc_ops digital_nfc_ops = {

commit 59ee2361c9248f07846f7a6e585768dcce18fb16
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:26 2013 +0200

    NFC Digital: Implement driver commands mechanism
    
    This implements the mechanism used to send commands to the driver in
    initiator mode through in_send_cmd().
    
    Commands are serialized and sent to the driver by using a work item
    on the system workqueue. Responses are handled asynchronously by
    another work item. Once the digital stack receives the response through
    the command_complete callback, the next command is sent to the driver.
    
    This also implements the polling mechanism. It's handled by a work item
    cycling on all supported protocols. The start poll command for a given
    protocol is sent to the driver using the mechanism described above.
    The process continues until a peer is discovered or stop_poll is
    called. This patch implements the poll function for NFC-A that sends a
    SENS_REQ command and waits for the SENS_RES response.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
index 471188a0d2e0..13abd293ca37 100644
--- a/net/nfc/digital_core.c
+++ b/net/nfc/digital_core.c
@@ -17,24 +17,319 @@
 
 #include "digital.h"
 
+#define DIGITAL_PROTO_NFCA_RF_TECH \
+	(NFC_PROTO_JEWEL_MASK | NFC_PROTO_MIFARE_MASK)
+
+struct digital_cmd {
+	struct list_head queue;
+
+	u8 type;
+	u8 pending;
+
+	u16 timeout;
+	struct sk_buff *req;
+	struct sk_buff *resp;
+
+	nfc_digital_cmd_complete_t cmd_cb;
+	void *cb_context;
+};
+
+struct sk_buff *digital_skb_alloc(struct nfc_digital_dev *ddev,
+				  unsigned int len)
+{
+	struct sk_buff *skb;
+
+	skb = alloc_skb(len + ddev->tx_headroom + ddev->tx_tailroom,
+			GFP_KERNEL);
+	if (skb)
+		skb_reserve(skb, ddev->tx_headroom);
+
+	return skb;
+}
+
+static inline void digital_switch_rf(struct nfc_digital_dev *ddev, bool on)
+{
+	ddev->ops->switch_rf(ddev, on);
+}
+
+static inline void digital_abort_cmd(struct nfc_digital_dev *ddev)
+{
+	ddev->ops->abort_cmd(ddev);
+}
+
+static void digital_wq_cmd_complete(struct work_struct *work)
+{
+	struct digital_cmd *cmd;
+	struct nfc_digital_dev *ddev = container_of(work,
+						    struct nfc_digital_dev,
+						    cmd_complete_work);
+
+	mutex_lock(&ddev->cmd_lock);
+
+	cmd = list_first_entry_or_null(&ddev->cmd_queue, struct digital_cmd,
+				       queue);
+	if (!cmd) {
+		mutex_unlock(&ddev->cmd_lock);
+		return;
+	}
+
+	list_del(&cmd->queue);
+
+	mutex_unlock(&ddev->cmd_lock);
+
+	if (!IS_ERR(cmd->resp))
+		print_hex_dump_debug("DIGITAL RX: ", DUMP_PREFIX_NONE, 16, 1,
+				     cmd->resp->data, cmd->resp->len, false);
+
+	cmd->cmd_cb(ddev, cmd->cb_context, cmd->resp);
+
+	kfree(cmd);
+
+	schedule_work(&ddev->cmd_work);
+}
+
+static void digital_send_cmd_complete(struct nfc_digital_dev *ddev,
+				      void *arg, struct sk_buff *resp)
+{
+	struct digital_cmd *cmd = arg;
+
+	cmd->resp = resp;
+
+	schedule_work(&ddev->cmd_complete_work);
+}
+
+static void digital_wq_cmd(struct work_struct *work)
+{
+	int rc;
+	struct digital_cmd *cmd;
+	struct nfc_digital_dev *ddev = container_of(work,
+						    struct nfc_digital_dev,
+						    cmd_work);
+
+	mutex_lock(&ddev->cmd_lock);
+
+	cmd = list_first_entry_or_null(&ddev->cmd_queue, struct digital_cmd,
+				       queue);
+	if (!cmd || cmd->pending) {
+		mutex_unlock(&ddev->cmd_lock);
+		return;
+	}
+
+	mutex_unlock(&ddev->cmd_lock);
+
+	if (cmd->req)
+		print_hex_dump_debug("DIGITAL TX: ", DUMP_PREFIX_NONE, 16, 1,
+				     cmd->req->data, cmd->req->len, false);
+
+	switch (cmd->type) {
+	case DIGITAL_CMD_IN_SEND:
+		rc = ddev->ops->in_send_cmd(ddev, cmd->req, cmd->timeout,
+					    digital_send_cmd_complete, cmd);
+		break;
+	default:
+		PR_ERR("Unknown cmd type %d", cmd->type);
+		return;
+	}
+
+	if (!rc)
+		return;
+
+	PR_ERR("in_send_command returned err %d", rc);
+
+	mutex_lock(&ddev->cmd_lock);
+	list_del(&cmd->queue);
+	mutex_unlock(&ddev->cmd_lock);
+
+	kfree_skb(cmd->req);
+	kfree(cmd);
+
+	schedule_work(&ddev->cmd_work);
+}
+
+int digital_send_cmd(struct nfc_digital_dev *ddev, u8 cmd_type,
+		     struct sk_buff *skb, u16 timeout,
+		     nfc_digital_cmd_complete_t cmd_cb, void *cb_context)
+{
+	struct digital_cmd *cmd;
+
+	cmd = kzalloc(sizeof(struct digital_cmd), GFP_KERNEL);
+	if (!cmd)
+		return -ENOMEM;
+
+	cmd->type = cmd_type;
+	cmd->timeout = timeout;
+	cmd->req = skb;
+	cmd->cmd_cb = cmd_cb;
+	cmd->cb_context = cb_context;
+	INIT_LIST_HEAD(&cmd->queue);
+
+	mutex_lock(&ddev->cmd_lock);
+	list_add_tail(&cmd->queue, &ddev->cmd_queue);
+	mutex_unlock(&ddev->cmd_lock);
+
+	schedule_work(&ddev->cmd_work);
+
+	return 0;
+}
+
+int digital_in_configure_hw(struct nfc_digital_dev *ddev, int type, int param)
+{
+	int rc;
+
+	rc = ddev->ops->in_configure_hw(ddev, type, param);
+	if (rc)
+		PR_ERR("in_configure_hw failed: %d", rc);
+
+	return rc;
+}
+
+void digital_poll_next_tech(struct nfc_digital_dev *ddev)
+{
+	digital_switch_rf(ddev, 0);
+
+	mutex_lock(&ddev->poll_lock);
+
+	if (!ddev->poll_tech_count) {
+		mutex_unlock(&ddev->poll_lock);
+		return;
+	}
+
+	ddev->poll_tech_index = (ddev->poll_tech_index + 1) %
+				ddev->poll_tech_count;
+
+	mutex_unlock(&ddev->poll_lock);
+
+	schedule_work(&ddev->poll_work);
+}
+
+static void digital_wq_poll(struct work_struct *work)
+{
+	int rc;
+	struct digital_poll_tech *poll_tech;
+	struct nfc_digital_dev *ddev = container_of(work,
+						    struct nfc_digital_dev,
+						    poll_work);
+	mutex_lock(&ddev->poll_lock);
+
+	if (!ddev->poll_tech_count) {
+		mutex_unlock(&ddev->poll_lock);
+		return;
+	}
+
+	poll_tech = &ddev->poll_techs[ddev->poll_tech_index];
+
+	mutex_unlock(&ddev->poll_lock);
+
+	rc = poll_tech->poll_func(ddev, poll_tech->rf_tech);
+	if (rc)
+		digital_poll_next_tech(ddev);
+}
+
+static void digital_add_poll_tech(struct nfc_digital_dev *ddev, u8 rf_tech,
+				  digital_poll_t poll_func)
+{
+	struct digital_poll_tech *poll_tech;
+
+	if (ddev->poll_tech_count >= NFC_DIGITAL_POLL_MODE_COUNT_MAX)
+		return;
+
+	poll_tech = &ddev->poll_techs[ddev->poll_tech_count++];
+
+	poll_tech->rf_tech = rf_tech;
+	poll_tech->poll_func = poll_func;
+}
+
+/**
+ * start_poll operation
+ *
+ * For every supported protocol, the corresponding polling function is added
+ * to the table of polling technologies (ddev->poll_techs[]) using
+ * digital_add_poll_tech().
+ * When a polling function fails (by timeout or protocol error) the next one is
+ * schedule by digital_poll_next_tech() on the poll workqueue (ddev->poll_work).
+ */
 static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
 			      __u32 tm_protocols)
 {
-	return -EOPNOTSUPP;
+	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
+	u32 matching_im_protocols, matching_tm_protocols;
+
+	PR_DBG("protocols: im 0x%x, tm 0x%x, supported 0x%x", im_protocols,
+	       tm_protocols, ddev->protocols);
+
+	matching_im_protocols = ddev->protocols & im_protocols;
+	matching_tm_protocols = ddev->protocols & tm_protocols;
+
+	if (!matching_im_protocols && !matching_tm_protocols) {
+		PR_ERR("No known protocol");
+		return -EINVAL;
+	}
+
+	if (ddev->poll_tech_count) {
+		PR_ERR("Already polling");
+		return -EBUSY;
+	}
+
+	if (ddev->curr_protocol) {
+		PR_ERR("A target is already active");
+		return -EBUSY;
+	}
+
+	ddev->poll_tech_count = 0;
+	ddev->poll_tech_index = 0;
+
+	if (matching_im_protocols & DIGITAL_PROTO_NFCA_RF_TECH)
+		digital_add_poll_tech(ddev, NFC_DIGITAL_RF_TECH_106A,
+				      digital_in_send_sens_req);
+
+	if (!ddev->poll_tech_count) {
+		PR_ERR("Unsupported protocols: im=0x%x, tm=0x%x",
+		       matching_im_protocols, matching_tm_protocols);
+		return -EINVAL;
+	}
+
+	schedule_work(&ddev->poll_work);
+
+	return 0;
 }
 
 static void digital_stop_poll(struct nfc_dev *nfc_dev)
 {
+	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
+
+	mutex_lock(&ddev->poll_lock);
+
+	if (!ddev->poll_tech_count) {
+		PR_ERR("Polling operation was not running");
+		mutex_unlock(&ddev->poll_lock);
+		return;
+	}
+
+	ddev->poll_tech_count = 0;
+
+	mutex_unlock(&ddev->poll_lock);
+
+	cancel_work_sync(&ddev->poll_work);
+
+	digital_abort_cmd(ddev);
 }
 
 static int digital_dev_up(struct nfc_dev *nfc_dev)
 {
-	return -EOPNOTSUPP;
+	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
+
+	digital_switch_rf(ddev, 1);
+
+	return 0;
 }
 
 static int digital_dev_down(struct nfc_dev *nfc_dev)
 {
-	return -EOPNOTSUPP;
+	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
+
+	digital_switch_rf(ddev, 0);
+
+	return 0;
 }
 
 static int digital_dep_link_up(struct nfc_dev *nfc_dev,
@@ -52,12 +347,15 @@ static int digital_dep_link_down(struct nfc_dev *nfc_dev)
 static int digital_activate_target(struct nfc_dev *nfc_dev,
 				   struct nfc_target *target, __u32 protocol)
 {
-	return -EOPNOTSUPP;
+	return 0;
 }
 
 static void digital_deactivate_target(struct nfc_dev *nfc_dev,
 				      struct nfc_target *target)
 {
+	struct nfc_digital_dev *ddev = nfc_get_drvdata(nfc_dev);
+
+	ddev->curr_protocol = 0;
 }
 
 static int digital_tg_send(struct nfc_dev *dev, struct sk_buff *skb)
@@ -106,8 +404,22 @@ struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
 	ddev->driver_capabilities = driver_capabilities;
 	ddev->ops = ops;
 
-	ddev->tx_headroom = tx_headroom;
-	ddev->tx_tailroom = tx_tailroom;
+	mutex_init(&ddev->cmd_lock);
+	INIT_LIST_HEAD(&ddev->cmd_queue);
+
+	INIT_WORK(&ddev->cmd_work, digital_wq_cmd);
+	INIT_WORK(&ddev->cmd_complete_work, digital_wq_cmd_complete);
+
+	mutex_init(&ddev->poll_lock);
+	INIT_WORK(&ddev->poll_work, digital_wq_poll);
+
+	if (supported_protocols & NFC_PROTO_JEWEL_MASK)
+		ddev->protocols |= NFC_PROTO_JEWEL_MASK;
+	if (supported_protocols & NFC_PROTO_MIFARE_MASK)
+		ddev->protocols |= NFC_PROTO_MIFARE_MASK;
+
+	ddev->tx_headroom = tx_headroom + DIGITAL_MAX_HEADER_LEN;
+	ddev->tx_tailroom = tx_tailroom + DIGITAL_CRC_LEN;
 
 	ddev->nfc_dev = nfc_allocate_device(&digital_nfc_ops, ddev->protocols,
 					    ddev->tx_headroom,
@@ -131,7 +443,6 @@ EXPORT_SYMBOL(nfc_digital_allocate_device);
 void nfc_digital_free_device(struct nfc_digital_dev *ddev)
 {
 	nfc_free_device(ddev->nfc_dev);
-
 	kfree(ddev);
 }
 EXPORT_SYMBOL(nfc_digital_free_device);
@@ -144,7 +455,22 @@ EXPORT_SYMBOL(nfc_digital_register_device);
 
 void nfc_digital_unregister_device(struct nfc_digital_dev *ddev)
 {
+	struct digital_cmd *cmd, *n;
+
 	nfc_unregister_device(ddev->nfc_dev);
+
+	mutex_lock(&ddev->poll_lock);
+	ddev->poll_tech_count = 0;
+	mutex_unlock(&ddev->poll_lock);
+
+	cancel_work_sync(&ddev->poll_work);
+	cancel_work_sync(&ddev->cmd_work);
+	cancel_work_sync(&ddev->cmd_complete_work);
+
+	list_for_each_entry_safe(cmd, n, &ddev->cmd_queue, queue) {
+		list_del(&cmd->queue);
+		kfree(cmd);
+	}
 }
 EXPORT_SYMBOL(nfc_digital_unregister_device);
 

commit 4b10884eb428c243ae2070a539612e645f3d9b93
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:25 2013 +0200

    NFC: Digital Protocol stack implementation
    
    This is the initial commit of the NFC Digital Protocol stack
    implementation.
    
    It offers an interface for devices that don't have an embedded NFC
    Digital protocol stack. The driver instantiates the digital stack by
    calling nfc_digital_allocate_device(). Within the nfc_digital_ops
    structure, the driver specifies a set of function pointers for driver
    operations. These functions must be implemented by the driver and are:
    
    in_configure_hw:
    Hardware configuration for RF technology and communication framing in
    initiator mode. This is a synchronous function.
    
    in_send_cmd:
    Initiator mode data exchange using RF technology and framing previously
    set with in_configure_hw. The peer response is returned through
    callback cb. If an io error occurs or the peer didn't reply within the
    specified timeout (ms), the error code is passed back through the resp
    pointer. This is an asynchronous function.
    
    tg_configure_hw:
    Hardware configuration for RF technology and communication framing in
    target mode. This is a synchronous function.
    
    tg_send_cmd:
    Target mode data exchange using RF technology and framing previously
    set with tg_configure_hw. The peer next command is returned through
    callback cb. If an io error occurs or the peer didn't reply within the
    specified timeout (ms), the error code is passed back through the resp
    pointer. This is an asynchronous function.
    
    tg_listen:
    Put the device in listen mode waiting for data from the peer device.
    This is an asynchronous function.
    
    tg_listen_mdaa:
    If supported, put the device in automatic listen mode with mode
    detection and automatic anti-collision. In this mode, the device
    automatically detects the RF technology and executes the
    anti-collision detection using the command responses specified in
    mdaa_params. The mdaa_params structure contains SENS_RES, NFCID1, and
    SEL_RES for 106A RF tech. NFCID2 and system code (sc) for 212F and
    424F. The driver returns the NFC-DEP ATR_REQ command through cb. The
    digital stack deducts the RF tech by analyzing the SoD of the frame
    containing the ATR_REQ command. This is an asynchronous function.
    
    switch_rf:
    Turns device radio on or off. The stack does not call explicitly
    switch_rf to turn the radio on. A call to in|tg_configure_hw must turn
    the device radio on.
    
    abort_cmd:
    Discard the last sent command.
    
    Then the driver registers itself against the digital stack by using
    nfc_digital_register_device() which in turn registers the digital stack
    against the NFC core layer. The digital stack implements common NFC
    operations like dev_up(), dev_down(), start_poll(), stop_poll(), etc.
    
    This patch is only a skeleton and NFC operations are just stubs.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital_core.c b/net/nfc/digital_core.c
new file mode 100644
index 000000000000..471188a0d2e0
--- /dev/null
+++ b/net/nfc/digital_core.c
@@ -0,0 +1,151 @@
+/*
+ * NFC Digital Protocol stack
+ * Copyright (c) 2013, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#include <linux/module.h>
+
+#include "digital.h"
+
+static int digital_start_poll(struct nfc_dev *nfc_dev, __u32 im_protocols,
+			      __u32 tm_protocols)
+{
+	return -EOPNOTSUPP;
+}
+
+static void digital_stop_poll(struct nfc_dev *nfc_dev)
+{
+}
+
+static int digital_dev_up(struct nfc_dev *nfc_dev)
+{
+	return -EOPNOTSUPP;
+}
+
+static int digital_dev_down(struct nfc_dev *nfc_dev)
+{
+	return -EOPNOTSUPP;
+}
+
+static int digital_dep_link_up(struct nfc_dev *nfc_dev,
+			       struct nfc_target *target,
+			       __u8 comm_mode, __u8 *gb, size_t gb_len)
+{
+	return -EOPNOTSUPP;
+}
+
+static int digital_dep_link_down(struct nfc_dev *nfc_dev)
+{
+	return -EOPNOTSUPP;
+}
+
+static int digital_activate_target(struct nfc_dev *nfc_dev,
+				   struct nfc_target *target, __u32 protocol)
+{
+	return -EOPNOTSUPP;
+}
+
+static void digital_deactivate_target(struct nfc_dev *nfc_dev,
+				      struct nfc_target *target)
+{
+}
+
+static int digital_tg_send(struct nfc_dev *dev, struct sk_buff *skb)
+{
+	return -EOPNOTSUPP;
+}
+
+static int digital_in_send(struct nfc_dev *nfc_dev, struct nfc_target *target,
+			   struct sk_buff *skb, data_exchange_cb_t cb,
+			   void *cb_context)
+{
+	return -EOPNOTSUPP;
+}
+
+static struct nfc_ops digital_nfc_ops = {
+	.dev_up = digital_dev_up,
+	.dev_down = digital_dev_down,
+	.start_poll = digital_start_poll,
+	.stop_poll = digital_stop_poll,
+	.dep_link_up = digital_dep_link_up,
+	.dep_link_down = digital_dep_link_down,
+	.activate_target = digital_activate_target,
+	.deactivate_target = digital_deactivate_target,
+	.tm_send = digital_tg_send,
+	.im_transceive = digital_in_send,
+};
+
+struct nfc_digital_dev *nfc_digital_allocate_device(struct nfc_digital_ops *ops,
+					    __u32 supported_protocols,
+					    __u32 driver_capabilities,
+					    int tx_headroom, int tx_tailroom)
+{
+	struct nfc_digital_dev *ddev;
+
+	if (!ops->in_configure_hw || !ops->in_send_cmd || !ops->tg_listen ||
+	    !ops->tg_configure_hw || !ops->tg_send_cmd || !ops->abort_cmd ||
+	    !ops->switch_rf)
+		return NULL;
+
+	ddev = kzalloc(sizeof(struct nfc_digital_dev), GFP_KERNEL);
+	if (!ddev) {
+		PR_ERR("kzalloc failed");
+		return NULL;
+	}
+
+	ddev->driver_capabilities = driver_capabilities;
+	ddev->ops = ops;
+
+	ddev->tx_headroom = tx_headroom;
+	ddev->tx_tailroom = tx_tailroom;
+
+	ddev->nfc_dev = nfc_allocate_device(&digital_nfc_ops, ddev->protocols,
+					    ddev->tx_headroom,
+					    ddev->tx_tailroom);
+	if (!ddev->nfc_dev) {
+		PR_ERR("nfc_allocate_device failed");
+		goto free_dev;
+	}
+
+	nfc_set_drvdata(ddev->nfc_dev, ddev);
+
+	return ddev;
+
+free_dev:
+	kfree(ddev);
+
+	return NULL;
+}
+EXPORT_SYMBOL(nfc_digital_allocate_device);
+
+void nfc_digital_free_device(struct nfc_digital_dev *ddev)
+{
+	nfc_free_device(ddev->nfc_dev);
+
+	kfree(ddev);
+}
+EXPORT_SYMBOL(nfc_digital_free_device);
+
+int nfc_digital_register_device(struct nfc_digital_dev *ddev)
+{
+	return nfc_register_device(ddev->nfc_dev);
+}
+EXPORT_SYMBOL(nfc_digital_register_device);
+
+void nfc_digital_unregister_device(struct nfc_digital_dev *ddev)
+{
+	nfc_unregister_device(ddev->nfc_dev);
+}
+EXPORT_SYMBOL(nfc_digital_unregister_device);
+
+MODULE_LICENSE("GPL");
