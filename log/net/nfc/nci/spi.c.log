commit 099ffd7eddfe03b9b5b43e1f4ffece99121dd7ba
Author: Alexandru Ardelean <alexandru.ardelean@analog.com>
Date:   Wed Dec 4 09:58:09 2019 +0200

    NFC: NCI: use new `delay` structure for SPI transfer delays
    
    In a recent change to the SPI subsystem [1], a new `delay` struct was added
    to replace the `delay_usecs`. This change replaces the current `delay_secs`
    with `delay` for this driver.
    
    The `spi_transfer_delay_exec()` function [in the SPI framework] makes sure
    that both `delay_usecs` & `delay` are used (in this order to preserve
    backwards compatibility).
    
    [1] commit bebcfd272df6485 ("spi: introduce `delay` field for
    `spi_transfer` + spi_transfer_delay_exec()")
    
    Signed-off-by: Alexandru Ardelean <alexandru.ardelean@analog.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index 9dd8a1096916..7d8e10e27c20 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -44,7 +44,8 @@ static int __nci_spi_send(struct nci_spi *nspi, struct sk_buff *skb,
 		t.len = 0;
 	}
 	t.cs_change = cs_change;
-	t.delay_usecs = nspi->xfer_udelay;
+	t.delay.value = nspi->xfer_udelay;
+	t.delay.unit = SPI_DELAY_UNIT_USECS;
 	t.speed_hz = nspi->xfer_speed_hz;
 
 	spi_message_init(&m);
@@ -216,7 +217,8 @@ static struct sk_buff *__nci_spi_read(struct nci_spi *nspi)
 	rx.rx_buf = skb_put(skb, rx_len);
 	rx.len = rx_len;
 	rx.cs_change = 0;
-	rx.delay_usecs = nspi->xfer_udelay;
+	rx.delay.value = nspi->xfer_udelay;
+	rx.delay.unit = SPI_DELAY_UNIT_USECS;
 	rx.speed_hz = nspi->xfer_speed_hz;
 	spi_message_add_tail(&rx, &m);
 

commit a61127c2130236168321cc76c5a58e15c00ad154
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:49 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 335
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin st fifth floor boston ma 02110
      1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 111 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.567572064@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index 452f4c16b7a9..9dd8a1096916 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -1,19 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2013  Intel Corporation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
- * You should have received a copy of the GNU General Public License along with
- * this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
- *
  */
 
 #define pr_fmt(fmt) "nci_spi: %s: " fmt, __func__

commit 634fef61076d644b989b86abc2f560d81a089a31
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:24 2017 +0200

    networking: add and use skb_put_u8()
    
    Joe and Bjørn suggested that it'd be nicer to not have the
    cast in the fairly common case of doing
            *(u8 *)skb_put(skb, 1) = c;
    
    Add skb_put_u8() for this case, and use it across the code,
    using the following spatch:
    
        @@
        expression SKB, C, S;
        typedef u8;
        identifier fn = {skb_put};
        fresh identifier fn2 = fn ## "_u8";
        @@
        - *(u8 *)fn(SKB, S) = C;
        + fn2(SKB, C);
    
    Note that due to the "S", the spatch isn't perfect, it should
    have checked that S is 1, but there's also places that use a
    sizeof expression like sizeof(var) or sizeof(u8) etc. Turns
    out that nobody ever did something like
            *(u8 *)skb_put(skb, 2) = c;
    
    which would be wrong anyway since the second byte wouldn't be
    initialized.
    
    Suggested-by: Joe Perches <joe@perches.com>
    Suggested-by: Bjørn Mork <bjorn@mork.no>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index 3b4512731a2f..452f4c16b7a9 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -86,8 +86,8 @@ int nci_spi_send(struct nci_spi *nspi,
 		u16 crc;
 
 		crc = crc_ccitt(CRC_INIT, skb->data, skb->len);
-		*(u8 *)skb_put(skb, 1) = crc >> 8;
-		*(u8 *)skb_put(skb, 1) = crc & 0xFF;
+		skb_put_u8(skb, crc >> 8);
+		skb_put_u8(skb, crc & 0xFF);
 	}
 
 	if (write_handshake_completion)	{
@@ -172,8 +172,8 @@ static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)
 	hdr[3] = 0;
 
 	crc = crc_ccitt(CRC_INIT, skb->data, skb->len);
-	*(u8 *)skb_put(skb, 1) = crc >> 8;
-	*(u8 *)skb_put(skb, 1) = crc & 0xFF;
+	skb_put_u8(skb, crc >> 8);
+	skb_put_u8(skb, crc & 0xFF);
 
 	ret = __nci_spi_send(nspi, skb, 0);
 

commit d58ff35122847a83ba55394e2ae3a1527b6febf5
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:23 2017 +0200

    networking: make skb_push & __skb_push return void pointers
    
    It seems like a historic accident that these return unsigned char *,
    and in many places that means casts are required, more often than not.
    
    Make these functions return void * and remove all the casts across
    the tree, adding a (u8 *) cast only where the unsigned char pointer
    was used directly, all done with the following spatch:
    
        @@
        expression SKB, LEN;
        typedef u8;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        @@
        - *(fn(SKB, LEN))
        + *(u8 *)fn(SKB, LEN)
    
        @@
        expression E, SKB, LEN;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        type T;
        @@
        - E = ((T *)(fn(SKB, LEN)))
        + E = fn(SKB, LEN)
    
        @@
        expression SKB, LEN;
        identifier fn = { skb_push, __skb_push, skb_push_rcsum };
        @@
        - fn(SKB, LEN)[0]
        + *(u8 *)fn(SKB, LEN)
    
    Note that the last part there converts from push(...)[0] to the
    more idiomatic *(u8 *)push(...).
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index a502a334918a..3b4512731a2f 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -238,8 +238,8 @@ static struct sk_buff *__nci_spi_read(struct nci_spi *nspi)
 		goto receive_error;
 
 	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
-		*skb_push(skb, 1) = resp_hdr[1];
-		*skb_push(skb, 1) = resp_hdr[0];
+		*(u8 *)skb_push(skb, 1) = resp_hdr[1];
+		*(u8 *)skb_push(skb, 1) = resp_hdr[0];
 	}
 
 	return skb;

commit 4df864c1d9afb46e2461a9f808d9f11a42d31bad
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 16 14:29:21 2017 +0200

    networking: make skb_put & friends return void pointers
    
    It seems like a historic accident that these return unsigned char *,
    and in many places that means casts are required, more often than not.
    
    Make these functions (skb_put, __skb_put and pskb_put) return void *
    and remove all the casts across the tree, adding a (u8 *) cast only
    where the unsigned char pointer was used directly, all done with the
    following spatch:
    
        @@
        expression SKB, LEN;
        typedef u8;
        identifier fn = { skb_put, __skb_put };
        @@
        - *(fn(SKB, LEN))
        + *(u8 *)fn(SKB, LEN)
    
        @@
        expression E, SKB, LEN;
        identifier fn = { skb_put, __skb_put };
        type T;
        @@
        - E = ((T *)(fn(SKB, LEN)))
        + E = fn(SKB, LEN)
    
    which actually doesn't cover pskb_put since there are only three
    users overall.
    
    A handful of stragglers were converted manually, notably a macro in
    drivers/isdn/i4l/isdn_bsdcomp.c and, oddly enough, one of the many
    instances in net/bluetooth/hci_sock.c. In the former file, I also
    had to fix one whitespace problem spatch introduced.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index d904cd2f1442..a502a334918a 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -86,8 +86,8 @@ int nci_spi_send(struct nci_spi *nspi,
 		u16 crc;
 
 		crc = crc_ccitt(CRC_INIT, skb->data, skb->len);
-		*skb_put(skb, 1) = crc >> 8;
-		*skb_put(skb, 1) = crc & 0xFF;
+		*(u8 *)skb_put(skb, 1) = crc >> 8;
+		*(u8 *)skb_put(skb, 1) = crc & 0xFF;
 	}
 
 	if (write_handshake_completion)	{
@@ -172,8 +172,8 @@ static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)
 	hdr[3] = 0;
 
 	crc = crc_ccitt(CRC_INIT, skb->data, skb->len);
-	*skb_put(skb, 1) = crc >> 8;
-	*skb_put(skb, 1) = crc & 0xFF;
+	*(u8 *)skb_put(skb, 1) = crc >> 8;
+	*(u8 *)skb_put(skb, 1) = crc & 0xFF;
 
 	ret = __nci_spi_send(nspi, skb, 0);
 

commit 2bd832459a0827b8dcf13b345380b66f92089d74
Author: Vincent Cuissard <cuissard@marvell.com>
Date:   Mon Oct 26 10:27:43 2015 +0100

    NFC: NCI: allow spi driver to choose transfer clock
    
    In some cases low level drivers might want to update the
    SPI transfer clock (e.g. during firmware download).
    
    This patch adds this support. Without any modification the
    driver will use the default SPI clock (from pdata or device tree).
    
    Signed-off-by: Vincent Cuissard <cuissard@marvell.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index 25153d0e33cf..d904cd2f1442 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -58,6 +58,7 @@ static int __nci_spi_send(struct nci_spi *nspi, struct sk_buff *skb,
 	}
 	t.cs_change = cs_change;
 	t.delay_usecs = nspi->xfer_udelay;
+	t.speed_hz = nspi->xfer_speed_hz;
 
 	spi_message_init(&m);
 	spi_message_add_tail(&t, &m);
@@ -144,7 +145,8 @@ struct nci_spi *nci_spi_allocate_spi(struct spi_device *spi,
 
 	nspi->acknowledge_mode = acknowledge_mode;
 	nspi->xfer_udelay = delay;
-
+	/* Use controller max SPI speed by default */
+	nspi->xfer_speed_hz = 0;
 	nspi->spi = spi;
 	nspi->ndev = ndev;
 	init_completion(&nspi->req_completion);
@@ -197,12 +199,14 @@ static struct sk_buff *__nci_spi_read(struct nci_spi *nspi)
 	tx.tx_buf = req;
 	tx.len = 2;
 	tx.cs_change = 0;
+	tx.speed_hz = nspi->xfer_speed_hz;
 	spi_message_add_tail(&tx, &m);
 
 	memset(&rx, 0, sizeof(struct spi_transfer));
 	rx.rx_buf = resp_hdr;
 	rx.len = 2;
 	rx.cs_change = 1;
+	rx.speed_hz = nspi->xfer_speed_hz;
 	spi_message_add_tail(&rx, &m);
 
 	ret = spi_sync(nspi->spi, &m);
@@ -226,6 +230,7 @@ static struct sk_buff *__nci_spi_read(struct nci_spi *nspi)
 	rx.len = rx_len;
 	rx.cs_change = 0;
 	rx.delay_usecs = nspi->xfer_udelay;
+	rx.speed_hz = nspi->xfer_speed_hz;
 	spi_message_add_tail(&rx, &m);
 
 	ret = spi_sync(nspi->spi, &m);

commit fcd9d046fd8998cc984f2ff80e76f246ebca15b6
Author: Vincent Cuissard <cuissard@marvell.com>
Date:   Mon Oct 26 10:27:42 2015 +0100

    NFC: NCI: move generic spi driver to a module
    
    SPI driver should be a module.
    
    Signed-off-by: Vincent Cuissard <cuissard@marvell.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index ec250e77763a..25153d0e33cf 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -18,6 +18,8 @@
 
 #define pr_fmt(fmt) "nci_spi: %s: " fmt, __func__
 
+#include <linux/module.h>
+
 #include <linux/export.h>
 #include <linux/spi/spi.h>
 #include <linux/crc-ccitt.h>
@@ -320,3 +322,5 @@ struct sk_buff *nci_spi_read(struct nci_spi *nspi)
 	return skb;
 }
 EXPORT_SYMBOL_GPL(nci_spi_read);
+
+MODULE_LICENSE("GPL");

commit 9bec44bf0bcd623b5ea48ae1ce44205260ad4b77
Author: Axel Lin <axel.lin@ingics.com>
Date:   Thu Feb 13 13:25:48 2014 +0800

    NFC: NCI: Use reinit_completion() at appropriate places
    
    Calling init_completion() once is enough.
    Then use reinit_completion() instead in __nci_request() and nci_spi_send().
    
    Signed-off-by: Axel Lin <axel.lin@ingics.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index f1d426f10cce..ec250e77763a 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -105,7 +105,7 @@ int nci_spi_send(struct nci_spi *nspi,
 	if (ret != 0 || nspi->acknowledge_mode == NCI_SPI_CRC_DISABLED)
 		goto done;
 
-	init_completion(&nspi->req_completion);
+	reinit_completion(&nspi->req_completion);
 	completion_rc =	wait_for_completion_interruptible_timeout(
 							&nspi->req_completion,
 							NCI_SPI_SEND_TIMEOUT);
@@ -145,6 +145,7 @@ struct nci_spi *nci_spi_allocate_spi(struct spi_device *spi,
 
 	nspi->spi = spi;
 	nspi->ndev = ndev;
+	init_completion(&nspi->req_completion);
 
 	return nspi;
 }

commit 2bed27851767d93b5d2823eee110857f350a9fbe
Author: Eric Lapuyade <eric.lapuyade@linux.intel.com>
Date:   Mon Sep 23 17:56:43 2013 +0200

    NFC: NCI: Modify NCI SPI to implement CS/INT handshake per the spec
    
    The NFC Forum NCI specification defines both a hardware and software
    protocol when using a SPI physical transport to connect an NFC NCI
    Chipset. The hardware requirement is that, after having raised the chip
    select line, the SPI driver must wait for an INT line from the NFC
    chipset to raise before it sends the data. The chip select must be
    raised first though, because this is the signal that the NFC chipset
    will detect to wake up and then raise its INT line. If the INT line
    doesn't raise in a timely fashion, the SPI driver should abort
    operation.
    
    When data is transferred from Device host (DH) to NFC Controller (NFCC),
    the signaling sequence is the following:
    
    Data Transfer from DH to NFCC
    • 1-Master asserts SPI_CSN
    • 2-Slave asserts SPI_INT
    • 3-Master sends NCI-over-SPI protocol header and payload data
    • 4-Slave deasserts SPI_INT
    • 5-Master deasserts SPI_CSN
    
    When data must be transferred from NFCC to DH, things are a little bit
    different.
    
    Data Transfer from NFCC to DH
    • 1-Slave asserts SPI_INT -> NFC chipset irq handler called -> process
    reading from SPI
    • 2-Master asserts SPI_CSN
    • 3-Master send 2-octet NCI-over-SPI protocol header
    • 4-Slave sends 2-octet NCI-over-SPI protocol payload length
    • 5-Slave sends NCI-over-SPI protocol payload
    • 6-Master deasserts SPI_CSN
    
    In this case, SPI driver should function normally as it does today. Note
    that the INT line can and will be lowered anytime between beginning of
    step 3 and end of step 5. A low INT is therefore valid after chip select
    has been raised.
    
    This would be easily implemented in a single driver. Unfortunately, we
    don't write the SPI driver and I had to imagine some workaround trick to
    get the SPI and NFC drivers to work in a synchronized fashion. The trick
    is the following:
    
    - send an empty spi message: this will raise the chip select line, and
    send nothing. We expect the /CS line will stay arisen because we asked
    for it in the spi_transfer cs_change field
    - wait for a completion, that will be completed by the NFC driver IRQ
    handler when it knows we are in the process of sending data (NFC spec
    says that we use SPI in a half duplex mode, so we are either sending or
    receiving).
    - when completed, proceed with the normal data send.
    
    This has been tested and verified to work very consistently on a Nexus
    10 (spi-s3c64xx driver). It may not work the same with other spi
    drivers.
    
    The previously defined nci_spi_ops{} whose intended purpose were to
    address this problem are not used anymore and therefore totally removed.
    
    The nci_spi_send() takes a new optional write_handshake_completion
    completion pointer. If non NULL, the nci spi layer will run the above
    trick when sending data to the NFC Chip. If NULL, the data is sent
    normally all at once and it is then the NFC driver responsibility to
    know what it's doing.
    
    Signed-off-by: Eric Lapuyade <eric.lapuyade@intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index 734c6dde7751..f1d426f10cce 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -38,15 +38,23 @@
 
 #define CRC_INIT		0xFFFF
 
-static int __nci_spi_send(struct nci_spi *nspi, struct sk_buff *skb)
+static int __nci_spi_send(struct nci_spi *nspi, struct sk_buff *skb,
+			  int cs_change)
 {
 	struct spi_message m;
 	struct spi_transfer t;
 
 	memset(&t, 0, sizeof(struct spi_transfer));
-	t.tx_buf = skb->data;
-	t.len = skb->len;
-	t.cs_change = 0;
+	/* a NULL skb means we just want the SPI chip select line to raise */
+	if (skb) {
+		t.tx_buf = skb->data;
+		t.len = skb->len;
+	} else {
+		/* still set tx_buf non NULL to make the driver happy */
+		t.tx_buf = &t;
+		t.len = 0;
+	}
+	t.cs_change = cs_change;
 	t.delay_usecs = nspi->xfer_udelay;
 
 	spi_message_init(&m);
@@ -55,15 +63,15 @@ static int __nci_spi_send(struct nci_spi *nspi, struct sk_buff *skb)
 	return spi_sync(nspi->spi, &m);
 }
 
-int nci_spi_send(struct nci_spi *nspi, struct sk_buff *skb)
+int nci_spi_send(struct nci_spi *nspi,
+		 struct completion *write_handshake_completion,
+		 struct sk_buff *skb)
 {
 	unsigned int payload_len = skb->len;
 	unsigned char *hdr;
 	int ret;
 	long completion_rc;
 
-	nspi->ops->deassert_int(nspi);
-
 	/* add the NCI SPI header to the start of the buffer */
 	hdr = skb_push(skb, NCI_SPI_HDR_LEN);
 	hdr[0] = NCI_SPI_DIRECT_WRITE;
@@ -79,11 +87,21 @@ int nci_spi_send(struct nci_spi *nspi, struct sk_buff *skb)
 		*skb_put(skb, 1) = crc & 0xFF;
 	}
 
-	ret = __nci_spi_send(nspi, skb);
+	if (write_handshake_completion)	{
+		/* Trick SPI driver to raise chip select */
+		ret = __nci_spi_send(nspi, NULL, 1);
+		if (ret)
+			goto done;
 
-	kfree_skb(skb);
-	nspi->ops->assert_int(nspi);
+		/* wait for NFC chip hardware handshake to complete */
+		if (wait_for_completion_timeout(write_handshake_completion,
+						msecs_to_jiffies(1000)) == 0) {
+			ret = -ETIME;
+			goto done;
+		}
+	}
 
+	ret = __nci_spi_send(nspi, skb, 0);
 	if (ret != 0 || nspi->acknowledge_mode == NCI_SPI_CRC_DISABLED)
 		goto done;
 
@@ -96,6 +114,8 @@ int nci_spi_send(struct nci_spi *nspi, struct sk_buff *skb)
 		ret = -EIO;
 
 done:
+	kfree_skb(skb);
+
 	return ret;
 }
 EXPORT_SYMBOL_GPL(nci_spi_send);
@@ -106,26 +126,20 @@ EXPORT_SYMBOL_GPL(nci_spi_send);
  * nci_spi_allocate_spi - allocate a new nci spi
  *
  * @spi: SPI device
- * @ops: device operations
  * @acknowledge_mode: Acknowledge mode used by the NFC device
  * @delay: delay between transactions in us
  * @ndev: nci dev to send incoming nci frames to
  */
 struct nci_spi *nci_spi_allocate_spi(struct spi_device *spi,
-				     struct nci_spi_ops *ops,
 				     u8 acknowledge_mode, unsigned int delay,
 				     struct nci_dev *ndev)
 {
 	struct nci_spi *nspi;
 
-	if (!ops->assert_int || !ops->deassert_int)
-		return NULL;
-
 	nspi = devm_kzalloc(&spi->dev, sizeof(struct nci_spi), GFP_KERNEL);
 	if (!nspi)
 		return NULL;
 
-	nspi->ops = ops;
 	nspi->acknowledge_mode = acknowledge_mode;
 	nspi->xfer_udelay = delay;
 
@@ -156,7 +170,7 @@ static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)
 	*skb_put(skb, 1) = crc >> 8;
 	*skb_put(skb, 1) = crc & 0xFF;
 
-	ret = __nci_spi_send(nspi, skb);
+	ret = __nci_spi_send(nspi, skb, 0);
 
 	kfree_skb(skb);
 
@@ -189,7 +203,6 @@ static struct sk_buff *__nci_spi_read(struct nci_spi *nspi)
 	spi_message_add_tail(&rx, &m);
 
 	ret = spi_sync(nspi->spi, &m);
-
 	if (ret)
 		return NULL;
 
@@ -213,7 +226,6 @@ static struct sk_buff *__nci_spi_read(struct nci_spi *nspi)
 	spi_message_add_tail(&rx, &m);
 
 	ret = spi_sync(nspi->spi, &m);
-
 	if (ret)
 		goto receive_error;
 
@@ -271,8 +283,6 @@ struct sk_buff *nci_spi_read(struct nci_spi *nspi)
 {
 	struct sk_buff *skb;
 
-	nspi->ops->deassert_int(nspi);
-
 	/* Retrieve frame from SPI */
 	skb = __nci_spi_read(nspi);
 	if (!skb)
@@ -305,7 +315,6 @@ struct sk_buff *nci_spi_read(struct nci_spi *nspi)
 		send_acknowledge(nspi, ACKNOWLEDGE_ACK);
 
 done:
-	nspi->ops->assert_int(nspi);
 
 	return skb;
 }

commit 22d4aae5897fb8355130b8f7d9a3af153eac9714
Author: Eric Lapuyade <eric.lapuyade@linux.intel.com>
Date:   Mon Sep 23 17:56:31 2013 +0200

    NFC: NCI: nci_spi_recv_frame() now returns (not forward) the read frame
    
    Previously, nci_spi_recv_frame() would directly transmit incoming frames
    to the NCI Core. However, it turns out that some NFC NCI Chips will add
    additional proprietary headers that must be handled/removed before NCI
    Core gets a chance to handle the frame. With this modification, the chip
    phy or driver are now responsible to transmit incoming frames to NCI
    Core after proper treatment, and NCI SPI becomes a driver helper instead
    of sitting between the NFC driver and NCI Core.
    
    As a general rule in NFC, *_recv_frame() APIs are used to deliver an
    incoming frame to an upper layer. To better suit the actual purpose of
    nci_spi_recv_frame(), and go along with its nci_spi_send()
    counterpart, the function is renamed to nci_spi_read()
    
    The skb is returned as the function result
    
    Signed-off-by: Eric Lapuyade <eric.lapuyade@intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index c111506b36d1..734c6dde7751 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -21,7 +21,6 @@
 #include <linux/export.h>
 #include <linux/spi/spi.h>
 #include <linux/crc-ccitt.h>
-#include <linux/nfc.h>
 #include <net/nfc/nci_core.h>
 
 #define NCI_SPI_ACK_SHIFT		6
@@ -164,7 +163,7 @@ static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)
 	return ret;
 }
 
-static struct sk_buff *__nci_spi_recv_frame(struct nci_spi *nspi)
+static struct sk_buff *__nci_spi_read(struct nci_spi *nspi)
 {
 	struct sk_buff *skb;
 	struct spi_message m;
@@ -258,7 +257,7 @@ static u8 nci_spi_get_ack(struct sk_buff *skb)
 }
 
 /**
- * nci_spi_recv_frame - receive frame from NCI SPI drivers
+ * nci_spi_read - read frame from NCI SPI drivers
  *
  * @nspi: The nci spi
  * Context: can sleep
@@ -266,21 +265,18 @@ static u8 nci_spi_get_ack(struct sk_buff *skb)
  * This call may only be used from a context that may sleep.  The sleep
  * is non-interruptible, and has no timeout.
  *
- * It returns zero on success, else a negative error code.
+ * It returns an allocated skb containing the frame on success, or NULL.
  */
-int nci_spi_recv_frame(struct nci_spi *nspi)
+struct sk_buff *nci_spi_read(struct nci_spi *nspi)
 {
 	struct sk_buff *skb;
-	int ret = 0;
 
 	nspi->ops->deassert_int(nspi);
 
 	/* Retrieve frame from SPI */
-	skb = __nci_spi_recv_frame(nspi);
-	if (!skb) {
-		ret = -EIO;
+	skb = __nci_spi_read(nspi);
+	if (!skb)
 		goto done;
-	}
 
 	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
 		if (!nci_spi_check_crc(skb)) {
@@ -299,20 +295,18 @@ int nci_spi_recv_frame(struct nci_spi *nspi)
 	/* If there is no payload (ACK/NACK only frame),
 	 * free the socket buffer
 	 */
-	if (skb->len == 0) {
+	if (!skb->len) {
 		kfree_skb(skb);
+		skb = NULL;
 		goto done;
 	}
 
 	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)
 		send_acknowledge(nspi, ACKNOWLEDGE_ACK);
 
-	/* Forward skb to NCI core layer */
-	ret = nci_recv_frame(nspi->ndev, skb);
-
 done:
 	nspi->ops->assert_int(nspi);
 
-	return ret;
+	return skb;
 }
-EXPORT_SYMBOL_GPL(nci_spi_recv_frame);
+EXPORT_SYMBOL_GPL(nci_spi_read);

commit a4ada6cadb8a2246f263ff6a0d0cca8832f3970e
Author: Eric Lapuyade <eric.lapuyade@linux.intel.com>
Date:   Mon Sep 23 18:02:43 2013 +0200

    NFC: NCI: zero struct spi_transfer variables before usage
    
    Using ARM compiler, and without zero-ing spi_transfer, spi-s3c64xx
    driver would issue abnormal errors due to bpw field value being set to
    unexpected value. This structure MUST be set to all zeros except for
    those field specifically used.
    
    Signed-off-by: Eric Lapuyade <eric.lapuyade@intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index 5c2234024774..c111506b36d1 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -44,6 +44,7 @@ static int __nci_spi_send(struct nci_spi *nspi, struct sk_buff *skb)
 	struct spi_message m;
 	struct spi_transfer t;
 
+	memset(&t, 0, sizeof(struct spi_transfer));
 	t.tx_buf = skb->data;
 	t.len = skb->len;
 	t.cs_change = 0;
@@ -173,16 +174,21 @@ static struct sk_buff *__nci_spi_recv_frame(struct nci_spi *nspi)
 	int ret;
 
 	spi_message_init(&m);
+
+	memset(&tx, 0, sizeof(struct spi_transfer));
 	req[0] = NCI_SPI_DIRECT_READ;
 	req[1] = nspi->acknowledge_mode;
 	tx.tx_buf = req;
 	tx.len = 2;
 	tx.cs_change = 0;
 	spi_message_add_tail(&tx, &m);
+
+	memset(&rx, 0, sizeof(struct spi_transfer));
 	rx.rx_buf = resp_hdr;
 	rx.len = 2;
 	rx.cs_change = 1;
 	spi_message_add_tail(&rx, &m);
+
 	ret = spi_sync(nspi->spi, &m);
 
 	if (ret)
@@ -199,11 +205,14 @@ static struct sk_buff *__nci_spi_recv_frame(struct nci_spi *nspi)
 		return NULL;
 
 	spi_message_init(&m);
+
+	memset(&rx, 0, sizeof(struct spi_transfer));
 	rx.rx_buf = skb_put(skb, rx_len);
 	rx.len = rx_len;
 	rx.cs_change = 0;
 	rx.delay_usecs = nspi->xfer_udelay;
 	spi_message_add_tail(&rx, &m);
+
 	ret = spi_sync(nspi->spi, &m);
 
 	if (ret)

commit 645d5087bd9667ed398bcb4bfd8784e1de1ee693
Author: Eric Lapuyade <eric.lapuyade@linux.intel.com>
Date:   Thu Sep 19 16:52:06 2013 +0200

    NFC: NCI: Store the spi device pointer from the spi instance
    
    Storing the spi device was forgotten in the original implementation,
    which would pretty obviously cause some kind of serious crash when
    actually trying to send something through that device.
    
    Signed-off-by: Eric Lapuyade <eric.lapuyade@intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index 910dfd8015f4..5c2234024774 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -129,6 +129,7 @@ struct nci_spi *nci_spi_allocate_spi(struct spi_device *spi,
 	nspi->acknowledge_mode = acknowledge_mode;
 	nspi->xfer_udelay = delay;
 
+	nspi->spi = spi;
 	nspi->ndev = ndev;
 
 	return nspi;

commit fa544fff62aeeb0cf8008c61077aae10fb1407a9
Author: Eric Lapuyade <eric.lapuyade@linux.intel.com>
Date:   Thu Sep 5 11:02:21 2013 +0200

    NFC: NCI: Simplify NCI SPI to become a simple framing/checking layer
    
    NCI SPI layer should not manage the nci dev, this is the job of the nci
    chipset driver. This layer should be limited to frame/deframe nci
    packets, and optionnaly check integrity (crc) and manage the ack/nak
    protocol.
    
    The NCI SPI must not be mixed up with an NCI dev. spi_[dev|device] are
    therefore renamed to a simple spi for more clarity.
    The header and crc sizes are moved to nci.h so that drivers can use
    them to reserve space in outgoing skbs.
    nci_spi_send() is exported to be accessible by drivers.
    
    Signed-off-by: Eric Lapuyade <eric.lapuyade@intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index e66fda4d9ede..910dfd8015f4 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -24,8 +24,6 @@
 #include <linux/nfc.h>
 #include <net/nfc/nci_core.h>
 
-#define NCI_SPI_HDR_LEN			4
-#define NCI_SPI_CRC_LEN			2
 #define NCI_SPI_ACK_SHIFT		6
 #define NCI_SPI_MSB_PAYLOAD_MASK	0x3F
 
@@ -41,21 +39,7 @@
 
 #define CRC_INIT		0xFFFF
 
-static int nci_spi_open(struct nci_dev *ndev)
-{
-	struct nci_spi_dev *nsdev = nci_get_drvdata(ndev);
-
-	return nsdev->ops->open(nsdev);
-}
-
-static int nci_spi_close(struct nci_dev *ndev)
-{
-	struct nci_spi_dev *nsdev = nci_get_drvdata(ndev);
-
-	return nsdev->ops->close(nsdev);
-}
-
-static int __nci_spi_send(struct nci_spi_dev *nsdev, struct sk_buff *skb)
+static int __nci_spi_send(struct nci_spi *nspi, struct sk_buff *skb)
 {
 	struct spi_message m;
 	struct spi_transfer t;
@@ -63,32 +47,31 @@ static int __nci_spi_send(struct nci_spi_dev *nsdev, struct sk_buff *skb)
 	t.tx_buf = skb->data;
 	t.len = skb->len;
 	t.cs_change = 0;
-	t.delay_usecs = nsdev->xfer_udelay;
+	t.delay_usecs = nspi->xfer_udelay;
 
 	spi_message_init(&m);
 	spi_message_add_tail(&t, &m);
 
-	return spi_sync(nsdev->spi, &m);
+	return spi_sync(nspi->spi, &m);
 }
 
-static int nci_spi_send(struct nci_dev *ndev, struct sk_buff *skb)
+int nci_spi_send(struct nci_spi *nspi, struct sk_buff *skb)
 {
-	struct nci_spi_dev *nsdev = nci_get_drvdata(ndev);
 	unsigned int payload_len = skb->len;
 	unsigned char *hdr;
 	int ret;
 	long completion_rc;
 
-	nsdev->ops->deassert_int(nsdev);
+	nspi->ops->deassert_int(nspi);
 
 	/* add the NCI SPI header to the start of the buffer */
 	hdr = skb_push(skb, NCI_SPI_HDR_LEN);
 	hdr[0] = NCI_SPI_DIRECT_WRITE;
-	hdr[1] = nsdev->acknowledge_mode;
+	hdr[1] = nspi->acknowledge_mode;
 	hdr[2] = payload_len >> 8;
 	hdr[3] = payload_len & 0xFF;
 
-	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
 		u16 crc;
 
 		crc = crc_ccitt(CRC_INIT, skb->data, skb->len);
@@ -96,123 +79,70 @@ static int nci_spi_send(struct nci_dev *ndev, struct sk_buff *skb)
 		*skb_put(skb, 1) = crc & 0xFF;
 	}
 
-	ret = __nci_spi_send(nsdev, skb);
+	ret = __nci_spi_send(nspi, skb);
 
 	kfree_skb(skb);
-	nsdev->ops->assert_int(nsdev);
+	nspi->ops->assert_int(nspi);
 
-	if (ret != 0 || nsdev->acknowledge_mode == NCI_SPI_CRC_DISABLED)
+	if (ret != 0 || nspi->acknowledge_mode == NCI_SPI_CRC_DISABLED)
 		goto done;
 
-	init_completion(&nsdev->req_completion);
+	init_completion(&nspi->req_completion);
 	completion_rc =	wait_for_completion_interruptible_timeout(
-							&nsdev->req_completion,
+							&nspi->req_completion,
 							NCI_SPI_SEND_TIMEOUT);
 
-	if (completion_rc <= 0 || nsdev->req_result == ACKNOWLEDGE_NACK)
+	if (completion_rc <= 0 || nspi->req_result == ACKNOWLEDGE_NACK)
 		ret = -EIO;
 
 done:
 	return ret;
 }
-
-static struct nci_ops nci_spi_ops = {
-	.open = nci_spi_open,
-	.close = nci_spi_close,
-	.send = nci_spi_send,
-};
+EXPORT_SYMBOL_GPL(nci_spi_send);
 
 /* ---- Interface to NCI SPI drivers ---- */
 
 /**
- * nci_spi_allocate_device - allocate a new nci spi device
+ * nci_spi_allocate_spi - allocate a new nci spi
  *
  * @spi: SPI device
  * @ops: device operations
- * @supported_protocols: NFC protocols supported by the device
- * @supported_se: NFC Secure Elements supported by the device
- * @acknowledge_mode: Acknowledge mode used by the device
+ * @acknowledge_mode: Acknowledge mode used by the NFC device
  * @delay: delay between transactions in us
+ * @ndev: nci dev to send incoming nci frames to
  */
-struct nci_spi_dev *nci_spi_allocate_device(struct spi_device *spi,
-						struct nci_spi_ops *ops,
-						u32 supported_protocols,
-						u32 supported_se,
-						u8 acknowledge_mode,
-						unsigned int delay)
+struct nci_spi *nci_spi_allocate_spi(struct spi_device *spi,
+				     struct nci_spi_ops *ops,
+				     u8 acknowledge_mode, unsigned int delay,
+				     struct nci_dev *ndev)
 {
-	struct nci_spi_dev *nsdev;
-	int tailroom = 0;
-
-	if (!ops->open || !ops->close || !ops->assert_int || !ops->deassert_int)
-		return NULL;
-
-	if (!supported_protocols)
-		return NULL;
+	struct nci_spi *nspi;
 
-	nsdev = devm_kzalloc(&spi->dev, sizeof(struct nci_spi_dev), GFP_KERNEL);
-	if (!nsdev)
+	if (!ops->assert_int || !ops->deassert_int)
 		return NULL;
 
-	nsdev->ops = ops;
-	nsdev->acknowledge_mode = acknowledge_mode;
-	nsdev->xfer_udelay = delay;
-
-	if (acknowledge_mode == NCI_SPI_CRC_ENABLED)
-		tailroom += NCI_SPI_CRC_LEN;
-
-	nsdev->ndev = nci_allocate_device(&nci_spi_ops, supported_protocols,
-					  NCI_SPI_HDR_LEN, tailroom);
-	if (!nsdev->ndev)
+	nspi = devm_kzalloc(&spi->dev, sizeof(struct nci_spi), GFP_KERNEL);
+	if (!nspi)
 		return NULL;
 
-	nci_set_drvdata(nsdev->ndev, nsdev);
-
-	return nsdev;
-}
-EXPORT_SYMBOL_GPL(nci_spi_allocate_device);
-
-/**
- * nci_spi_free_device - deallocate nci spi device
- *
- * @nsdev: The nci spi device to deallocate
- */
-void nci_spi_free_device(struct nci_spi_dev *nsdev)
-{
-	nci_free_device(nsdev->ndev);
-}
-EXPORT_SYMBOL_GPL(nci_spi_free_device);
+	nspi->ops = ops;
+	nspi->acknowledge_mode = acknowledge_mode;
+	nspi->xfer_udelay = delay;
 
-/**
- * nci_spi_register_device - register a nci spi device in the nfc subsystem
- *
- * @pdev: The nci spi device to register
- */
-int nci_spi_register_device(struct nci_spi_dev *nsdev)
-{
-	return nci_register_device(nsdev->ndev);
-}
-EXPORT_SYMBOL_GPL(nci_spi_register_device);
+	nspi->ndev = ndev;
 
-/**
- * nci_spi_unregister_device - unregister a nci spi device in the nfc subsystem
- *
- * @dev: The nci spi device to unregister
- */
-void nci_spi_unregister_device(struct nci_spi_dev *nsdev)
-{
-	nci_unregister_device(nsdev->ndev);
+	return nspi;
 }
-EXPORT_SYMBOL_GPL(nci_spi_unregister_device);
+EXPORT_SYMBOL_GPL(nci_spi_allocate_spi);
 
-static int send_acknowledge(struct nci_spi_dev *nsdev, u8 acknowledge)
+static int send_acknowledge(struct nci_spi *nspi, u8 acknowledge)
 {
 	struct sk_buff *skb;
 	unsigned char *hdr;
 	u16 crc;
 	int ret;
 
-	skb = nci_skb_alloc(nsdev->ndev, 0, GFP_KERNEL);
+	skb = nci_skb_alloc(nspi->ndev, 0, GFP_KERNEL);
 
 	/* add the NCI SPI header to the start of the buffer */
 	hdr = skb_push(skb, NCI_SPI_HDR_LEN);
@@ -225,14 +155,14 @@ static int send_acknowledge(struct nci_spi_dev *nsdev, u8 acknowledge)
 	*skb_put(skb, 1) = crc >> 8;
 	*skb_put(skb, 1) = crc & 0xFF;
 
-	ret = __nci_spi_send(nsdev, skb);
+	ret = __nci_spi_send(nspi, skb);
 
 	kfree_skb(skb);
 
 	return ret;
 }
 
-static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *nsdev)
+static struct sk_buff *__nci_spi_recv_frame(struct nci_spi *nspi)
 {
 	struct sk_buff *skb;
 	struct spi_message m;
@@ -243,7 +173,7 @@ static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *nsdev)
 
 	spi_message_init(&m);
 	req[0] = NCI_SPI_DIRECT_READ;
-	req[1] = nsdev->acknowledge_mode;
+	req[1] = nspi->acknowledge_mode;
 	tx.tx_buf = req;
 	tx.len = 2;
 	tx.cs_change = 0;
@@ -252,18 +182,18 @@ static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *nsdev)
 	rx.len = 2;
 	rx.cs_change = 1;
 	spi_message_add_tail(&rx, &m);
-	ret = spi_sync(nsdev->spi, &m);
+	ret = spi_sync(nspi->spi, &m);
 
 	if (ret)
 		return NULL;
 
-	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
+	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)
 		rx_len = ((resp_hdr[0] & NCI_SPI_MSB_PAYLOAD_MASK) << 8) +
 				resp_hdr[1] + NCI_SPI_CRC_LEN;
 	else
 		rx_len = (resp_hdr[0] << 8) | resp_hdr[1];
 
-	skb = nci_skb_alloc(nsdev->ndev, rx_len, GFP_KERNEL);
+	skb = nci_skb_alloc(nspi->ndev, rx_len, GFP_KERNEL);
 	if (!skb)
 		return NULL;
 
@@ -271,14 +201,14 @@ static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *nsdev)
 	rx.rx_buf = skb_put(skb, rx_len);
 	rx.len = rx_len;
 	rx.cs_change = 0;
-	rx.delay_usecs = nsdev->xfer_udelay;
+	rx.delay_usecs = nspi->xfer_udelay;
 	spi_message_add_tail(&rx, &m);
-	ret = spi_sync(nsdev->spi, &m);
+	ret = spi_sync(nspi->spi, &m);
 
 	if (ret)
 		goto receive_error;
 
-	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
 		*skb_push(skb, 1) = resp_hdr[1];
 		*skb_push(skb, 1) = resp_hdr[0];
 	}
@@ -320,7 +250,7 @@ static u8 nci_spi_get_ack(struct sk_buff *skb)
 /**
  * nci_spi_recv_frame - receive frame from NCI SPI drivers
  *
- * @nsdev: The nci spi device
+ * @nspi: The nci spi
  * Context: can sleep
  *
  * This call may only be used from a context that may sleep.  The sleep
@@ -328,32 +258,32 @@ static u8 nci_spi_get_ack(struct sk_buff *skb)
  *
  * It returns zero on success, else a negative error code.
  */
-int nci_spi_recv_frame(struct nci_spi_dev *nsdev)
+int nci_spi_recv_frame(struct nci_spi *nspi)
 {
 	struct sk_buff *skb;
 	int ret = 0;
 
-	nsdev->ops->deassert_int(nsdev);
+	nspi->ops->deassert_int(nspi);
 
 	/* Retrieve frame from SPI */
-	skb = __nci_spi_recv_frame(nsdev);
+	skb = __nci_spi_recv_frame(nspi);
 	if (!skb) {
 		ret = -EIO;
 		goto done;
 	}
 
-	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
 		if (!nci_spi_check_crc(skb)) {
-			send_acknowledge(nsdev, ACKNOWLEDGE_NACK);
+			send_acknowledge(nspi, ACKNOWLEDGE_NACK);
 			goto done;
 		}
 
 		/* In case of acknowledged mode: if ACK or NACK received,
 		 * unblock completion of latest frame sent.
 		 */
-		nsdev->req_result = nci_spi_get_ack(skb);
-		if (nsdev->req_result)
-			complete(&nsdev->req_completion);
+		nspi->req_result = nci_spi_get_ack(skb);
+		if (nspi->req_result)
+			complete(&nspi->req_completion);
 	}
 
 	/* If there is no payload (ACK/NACK only frame),
@@ -364,14 +294,14 @@ int nci_spi_recv_frame(struct nci_spi_dev *nsdev)
 		goto done;
 	}
 
-	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
-		send_acknowledge(nsdev, ACKNOWLEDGE_ACK);
+	if (nspi->acknowledge_mode == NCI_SPI_CRC_ENABLED)
+		send_acknowledge(nspi, ACKNOWLEDGE_ACK);
 
 	/* Forward skb to NCI core layer */
-	ret = nci_recv_frame(nsdev->ndev, skb);
+	ret = nci_recv_frame(nspi->ndev, skb);
 
 done:
-	nsdev->ops->assert_int(nsdev);
+	nspi->ops->assert_int(nspi);
 
 	return ret;
 }

commit d593751129ec26762412b2fa7afe9c9258923340
Author: Eric Lapuyade <eric.lapuyade@linux.intel.com>
Date:   Mon Sep 2 12:35:39 2013 +0200

    NFC: NCI: Rename spi ndev -> nsdev and nci_dev -> ndev for consistency
    
    An hci dev is an hdev. An nci dev is an ndev. Calling an nci spi dev an
    ndev is misleading since it's not the same thing. The nci dev contained
    in the nci spi dev is also named inconsistently.
    
    Signed-off-by: Eric Lapuyade <eric.lapuyade@intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index b6795955432d..e66fda4d9ede 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -41,21 +41,21 @@
 
 #define CRC_INIT		0xFFFF
 
-static int nci_spi_open(struct nci_dev *nci_dev)
+static int nci_spi_open(struct nci_dev *ndev)
 {
-	struct nci_spi_dev *ndev = nci_get_drvdata(nci_dev);
+	struct nci_spi_dev *nsdev = nci_get_drvdata(ndev);
 
-	return ndev->ops->open(ndev);
+	return nsdev->ops->open(nsdev);
 }
 
-static int nci_spi_close(struct nci_dev *nci_dev)
+static int nci_spi_close(struct nci_dev *ndev)
 {
-	struct nci_spi_dev *ndev = nci_get_drvdata(nci_dev);
+	struct nci_spi_dev *nsdev = nci_get_drvdata(ndev);
 
-	return ndev->ops->close(ndev);
+	return nsdev->ops->close(nsdev);
 }
 
-static int __nci_spi_send(struct nci_spi_dev *ndev, struct sk_buff *skb)
+static int __nci_spi_send(struct nci_spi_dev *nsdev, struct sk_buff *skb)
 {
 	struct spi_message m;
 	struct spi_transfer t;
@@ -63,32 +63,32 @@ static int __nci_spi_send(struct nci_spi_dev *ndev, struct sk_buff *skb)
 	t.tx_buf = skb->data;
 	t.len = skb->len;
 	t.cs_change = 0;
-	t.delay_usecs = ndev->xfer_udelay;
+	t.delay_usecs = nsdev->xfer_udelay;
 
 	spi_message_init(&m);
 	spi_message_add_tail(&t, &m);
 
-	return spi_sync(ndev->spi, &m);
+	return spi_sync(nsdev->spi, &m);
 }
 
-static int nci_spi_send(struct nci_dev *nci_dev, struct sk_buff *skb)
+static int nci_spi_send(struct nci_dev *ndev, struct sk_buff *skb)
 {
-	struct nci_spi_dev *ndev = nci_get_drvdata(nci_dev);
+	struct nci_spi_dev *nsdev = nci_get_drvdata(ndev);
 	unsigned int payload_len = skb->len;
 	unsigned char *hdr;
 	int ret;
 	long completion_rc;
 
-	ndev->ops->deassert_int(ndev);
+	nsdev->ops->deassert_int(nsdev);
 
 	/* add the NCI SPI header to the start of the buffer */
 	hdr = skb_push(skb, NCI_SPI_HDR_LEN);
 	hdr[0] = NCI_SPI_DIRECT_WRITE;
-	hdr[1] = ndev->acknowledge_mode;
+	hdr[1] = nsdev->acknowledge_mode;
 	hdr[2] = payload_len >> 8;
 	hdr[3] = payload_len & 0xFF;
 
-	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
 		u16 crc;
 
 		crc = crc_ccitt(CRC_INIT, skb->data, skb->len);
@@ -96,20 +96,20 @@ static int nci_spi_send(struct nci_dev *nci_dev, struct sk_buff *skb)
 		*skb_put(skb, 1) = crc & 0xFF;
 	}
 
-	ret = __nci_spi_send(ndev, skb);
+	ret = __nci_spi_send(nsdev, skb);
 
 	kfree_skb(skb);
-	ndev->ops->assert_int(ndev);
+	nsdev->ops->assert_int(nsdev);
 
-	if (ret != 0 || ndev->acknowledge_mode == NCI_SPI_CRC_DISABLED)
+	if (ret != 0 || nsdev->acknowledge_mode == NCI_SPI_CRC_DISABLED)
 		goto done;
 
-	init_completion(&ndev->req_completion);
-	completion_rc =
-		wait_for_completion_interruptible_timeout(&ndev->req_completion,
-							  NCI_SPI_SEND_TIMEOUT);
+	init_completion(&nsdev->req_completion);
+	completion_rc =	wait_for_completion_interruptible_timeout(
+							&nsdev->req_completion,
+							NCI_SPI_SEND_TIMEOUT);
 
-	if (completion_rc <= 0 || ndev->req_result == ACKNOWLEDGE_NACK)
+	if (completion_rc <= 0 || nsdev->req_result == ACKNOWLEDGE_NACK)
 		ret = -EIO;
 
 done:
@@ -141,7 +141,7 @@ struct nci_spi_dev *nci_spi_allocate_device(struct spi_device *spi,
 						u8 acknowledge_mode,
 						unsigned int delay)
 {
-	struct nci_spi_dev *ndev;
+	struct nci_spi_dev *nsdev;
 	int tailroom = 0;
 
 	if (!ops->open || !ops->close || !ops->assert_int || !ops->deassert_int)
@@ -150,36 +150,36 @@ struct nci_spi_dev *nci_spi_allocate_device(struct spi_device *spi,
 	if (!supported_protocols)
 		return NULL;
 
-	ndev = devm_kzalloc(&spi->dev, sizeof(struct nci_spi_dev), GFP_KERNEL);
-	if (!ndev)
+	nsdev = devm_kzalloc(&spi->dev, sizeof(struct nci_spi_dev), GFP_KERNEL);
+	if (!nsdev)
 		return NULL;
 
-	ndev->ops = ops;
-	ndev->acknowledge_mode = acknowledge_mode;
-	ndev->xfer_udelay = delay;
+	nsdev->ops = ops;
+	nsdev->acknowledge_mode = acknowledge_mode;
+	nsdev->xfer_udelay = delay;
 
 	if (acknowledge_mode == NCI_SPI_CRC_ENABLED)
 		tailroom += NCI_SPI_CRC_LEN;
 
-	ndev->nci_dev = nci_allocate_device(&nci_spi_ops, supported_protocols,
-					    NCI_SPI_HDR_LEN, tailroom);
-	if (!ndev->nci_dev)
+	nsdev->ndev = nci_allocate_device(&nci_spi_ops, supported_protocols,
+					  NCI_SPI_HDR_LEN, tailroom);
+	if (!nsdev->ndev)
 		return NULL;
 
-	nci_set_drvdata(ndev->nci_dev, ndev);
+	nci_set_drvdata(nsdev->ndev, nsdev);
 
-	return ndev;
+	return nsdev;
 }
 EXPORT_SYMBOL_GPL(nci_spi_allocate_device);
 
 /**
  * nci_spi_free_device - deallocate nci spi device
  *
- * @ndev: The nci spi device to deallocate
+ * @nsdev: The nci spi device to deallocate
  */
-void nci_spi_free_device(struct nci_spi_dev *ndev)
+void nci_spi_free_device(struct nci_spi_dev *nsdev)
 {
-	nci_free_device(ndev->nci_dev);
+	nci_free_device(nsdev->ndev);
 }
 EXPORT_SYMBOL_GPL(nci_spi_free_device);
 
@@ -188,9 +188,9 @@ EXPORT_SYMBOL_GPL(nci_spi_free_device);
  *
  * @pdev: The nci spi device to register
  */
-int nci_spi_register_device(struct nci_spi_dev *ndev)
+int nci_spi_register_device(struct nci_spi_dev *nsdev)
 {
-	return nci_register_device(ndev->nci_dev);
+	return nci_register_device(nsdev->ndev);
 }
 EXPORT_SYMBOL_GPL(nci_spi_register_device);
 
@@ -199,20 +199,20 @@ EXPORT_SYMBOL_GPL(nci_spi_register_device);
  *
  * @dev: The nci spi device to unregister
  */
-void nci_spi_unregister_device(struct nci_spi_dev *ndev)
+void nci_spi_unregister_device(struct nci_spi_dev *nsdev)
 {
-	nci_unregister_device(ndev->nci_dev);
+	nci_unregister_device(nsdev->ndev);
 }
 EXPORT_SYMBOL_GPL(nci_spi_unregister_device);
 
-static int send_acknowledge(struct nci_spi_dev *ndev, u8 acknowledge)
+static int send_acknowledge(struct nci_spi_dev *nsdev, u8 acknowledge)
 {
 	struct sk_buff *skb;
 	unsigned char *hdr;
 	u16 crc;
 	int ret;
 
-	skb = nci_skb_alloc(ndev->nci_dev, 0, GFP_KERNEL);
+	skb = nci_skb_alloc(nsdev->ndev, 0, GFP_KERNEL);
 
 	/* add the NCI SPI header to the start of the buffer */
 	hdr = skb_push(skb, NCI_SPI_HDR_LEN);
@@ -225,14 +225,14 @@ static int send_acknowledge(struct nci_spi_dev *ndev, u8 acknowledge)
 	*skb_put(skb, 1) = crc >> 8;
 	*skb_put(skb, 1) = crc & 0xFF;
 
-	ret = __nci_spi_send(ndev, skb);
+	ret = __nci_spi_send(nsdev, skb);
 
 	kfree_skb(skb);
 
 	return ret;
 }
 
-static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *ndev)
+static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *nsdev)
 {
 	struct sk_buff *skb;
 	struct spi_message m;
@@ -243,7 +243,7 @@ static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *ndev)
 
 	spi_message_init(&m);
 	req[0] = NCI_SPI_DIRECT_READ;
-	req[1] = ndev->acknowledge_mode;
+	req[1] = nsdev->acknowledge_mode;
 	tx.tx_buf = req;
 	tx.len = 2;
 	tx.cs_change = 0;
@@ -252,18 +252,18 @@ static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *ndev)
 	rx.len = 2;
 	rx.cs_change = 1;
 	spi_message_add_tail(&rx, &m);
-	ret = spi_sync(ndev->spi, &m);
+	ret = spi_sync(nsdev->spi, &m);
 
 	if (ret)
 		return NULL;
 
-	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
+	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
 		rx_len = ((resp_hdr[0] & NCI_SPI_MSB_PAYLOAD_MASK) << 8) +
 				resp_hdr[1] + NCI_SPI_CRC_LEN;
 	else
 		rx_len = (resp_hdr[0] << 8) | resp_hdr[1];
 
-	skb = nci_skb_alloc(ndev->nci_dev, rx_len, GFP_KERNEL);
+	skb = nci_skb_alloc(nsdev->ndev, rx_len, GFP_KERNEL);
 	if (!skb)
 		return NULL;
 
@@ -271,14 +271,14 @@ static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *ndev)
 	rx.rx_buf = skb_put(skb, rx_len);
 	rx.len = rx_len;
 	rx.cs_change = 0;
-	rx.delay_usecs = ndev->xfer_udelay;
+	rx.delay_usecs = nsdev->xfer_udelay;
 	spi_message_add_tail(&rx, &m);
-	ret = spi_sync(ndev->spi, &m);
+	ret = spi_sync(nsdev->spi, &m);
 
 	if (ret)
 		goto receive_error;
 
-	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
 		*skb_push(skb, 1) = resp_hdr[1];
 		*skb_push(skb, 1) = resp_hdr[0];
 	}
@@ -320,7 +320,7 @@ static u8 nci_spi_get_ack(struct sk_buff *skb)
 /**
  * nci_spi_recv_frame - receive frame from NCI SPI drivers
  *
- * @ndev: The nci spi device
+ * @nsdev: The nci spi device
  * Context: can sleep
  *
  * This call may only be used from a context that may sleep.  The sleep
@@ -328,32 +328,32 @@ static u8 nci_spi_get_ack(struct sk_buff *skb)
  *
  * It returns zero on success, else a negative error code.
  */
-int nci_spi_recv_frame(struct nci_spi_dev *ndev)
+int nci_spi_recv_frame(struct nci_spi_dev *nsdev)
 {
 	struct sk_buff *skb;
 	int ret = 0;
 
-	ndev->ops->deassert_int(ndev);
+	nsdev->ops->deassert_int(nsdev);
 
 	/* Retrieve frame from SPI */
-	skb = __nci_spi_recv_frame(ndev);
+	skb = __nci_spi_recv_frame(nsdev);
 	if (!skb) {
 		ret = -EIO;
 		goto done;
 	}
 
-	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
 		if (!nci_spi_check_crc(skb)) {
-			send_acknowledge(ndev, ACKNOWLEDGE_NACK);
+			send_acknowledge(nsdev, ACKNOWLEDGE_NACK);
 			goto done;
 		}
 
 		/* In case of acknowledged mode: if ACK or NACK received,
 		 * unblock completion of latest frame sent.
 		 */
-		ndev->req_result = nci_spi_get_ack(skb);
-		if (ndev->req_result)
-			complete(&ndev->req_completion);
+		nsdev->req_result = nci_spi_get_ack(skb);
+		if (nsdev->req_result)
+			complete(&nsdev->req_completion);
 	}
 
 	/* If there is no payload (ACK/NACK only frame),
@@ -364,14 +364,14 @@ int nci_spi_recv_frame(struct nci_spi_dev *ndev)
 		goto done;
 	}
 
-	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
-		send_acknowledge(ndev, ACKNOWLEDGE_ACK);
+	if (nsdev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
+		send_acknowledge(nsdev, ACKNOWLEDGE_ACK);
 
 	/* Forward skb to NCI core layer */
-	ret = nci_recv_frame(ndev->nci_dev, skb);
+	ret = nci_recv_frame(nsdev->ndev, skb);
 
 done:
-	ndev->ops->assert_int(ndev);
+	nsdev->ops->assert_int(nsdev);
 
 	return ret;
 }

commit 079797c3b7ca74a4e81496fda5d53adec9f727bf
Author: Eric Lapuyade <eric.lapuyade@linux.intel.com>
Date:   Mon Sep 2 12:34:34 2013 +0200

    NFC: NCI: Fix wrong allocation size in nci_spi_allocate_device()
    
    Signed-off-by: Eric Lapuyade <eric.lapuyade@intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index c7cf37ba7298..b6795955432d 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -150,7 +150,7 @@ struct nci_spi_dev *nci_spi_allocate_device(struct spi_device *spi,
 	if (!supported_protocols)
 		return NULL;
 
-	ndev = devm_kzalloc(&spi->dev, sizeof(struct nci_dev), GFP_KERNEL);
+	ndev = devm_kzalloc(&spi->dev, sizeof(struct nci_spi_dev), GFP_KERNEL);
 	if (!ndev)
 		return NULL;
 

commit 0b456c418a5595b9d67f300c9ac6a2441e774603
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Tue May 7 19:22:11 2013 +0200

    NFC: Remove the static supported_se field
    
    Supported secure elements are typically found during a discovery process
    initiated when the NFC controller is up and running. For a given NFC
    chipset there can be many configurations (embedded SE or not, with or
    without a SIM card wired to the NFC controller SWP interface, etc...) and
    thus driver code will never know before hand which SEs are available.
    So we remove this field, it will be replaced by a real SE discovery
    mechanism.
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index 70afc387a965..c7cf37ba7298 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -162,8 +162,7 @@ struct nci_spi_dev *nci_spi_allocate_device(struct spi_device *spi,
 		tailroom += NCI_SPI_CRC_LEN;
 
 	ndev->nci_dev = nci_allocate_device(&nci_spi_ops, supported_protocols,
-					    supported_se, NCI_SPI_HDR_LEN,
-					    tailroom);
+					    NCI_SPI_HDR_LEN, tailroom);
 	if (!ndev->nci_dev)
 		return NULL;
 

commit 391d8a2da787257aeaf952c974405b53926e3fb3
Author: Frederic Danis <frederic.danis@linux.intel.com>
Date:   Wed May 29 15:35:04 2013 +0200

    NFC: Add NCI over SPI receive
    
    Before any operation, driver interruption is de-asserted to prevent
    race condition between TX and RX.
    
    Transaction starts by emitting "Direct read" and acknowledged mode
    bytes. Then packet length is read allowing to allocate correct NCI
    socket buffer. After that payload is retrieved.
    
    A delay after the transaction can be added.
    This delay is determined by the driver during nci_spi_allocate_device()
    call and can be 0.
    
    If acknowledged mode is set:
    - CRC of header and payload is checked
    - if frame reception fails (CRC error): NACK is sent
    - if received frame has ACK or NACK flag: unblock nci_spi_send()
    
    Payload is passed to NCI module.
    
    At the end, driver interruption is re asserted.
    
    Signed-off-by: Frederic Danis <frederic.danis@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index 6258461e6998..70afc387a965 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -26,6 +26,8 @@
 
 #define NCI_SPI_HDR_LEN			4
 #define NCI_SPI_CRC_LEN			2
+#define NCI_SPI_ACK_SHIFT		6
+#define NCI_SPI_MSB_PAYLOAD_MASK	0x3F
 
 #define NCI_SPI_SEND_TIMEOUT	(NCI_CMD_TIMEOUT > NCI_DATA_TIMEOUT ? \
 					NCI_CMD_TIMEOUT : NCI_DATA_TIMEOUT)
@@ -203,3 +205,175 @@ void nci_spi_unregister_device(struct nci_spi_dev *ndev)
 	nci_unregister_device(ndev->nci_dev);
 }
 EXPORT_SYMBOL_GPL(nci_spi_unregister_device);
+
+static int send_acknowledge(struct nci_spi_dev *ndev, u8 acknowledge)
+{
+	struct sk_buff *skb;
+	unsigned char *hdr;
+	u16 crc;
+	int ret;
+
+	skb = nci_skb_alloc(ndev->nci_dev, 0, GFP_KERNEL);
+
+	/* add the NCI SPI header to the start of the buffer */
+	hdr = skb_push(skb, NCI_SPI_HDR_LEN);
+	hdr[0] = NCI_SPI_DIRECT_WRITE;
+	hdr[1] = NCI_SPI_CRC_ENABLED;
+	hdr[2] = acknowledge << NCI_SPI_ACK_SHIFT;
+	hdr[3] = 0;
+
+	crc = crc_ccitt(CRC_INIT, skb->data, skb->len);
+	*skb_put(skb, 1) = crc >> 8;
+	*skb_put(skb, 1) = crc & 0xFF;
+
+	ret = __nci_spi_send(ndev, skb);
+
+	kfree_skb(skb);
+
+	return ret;
+}
+
+static struct sk_buff *__nci_spi_recv_frame(struct nci_spi_dev *ndev)
+{
+	struct sk_buff *skb;
+	struct spi_message m;
+	unsigned char req[2], resp_hdr[2];
+	struct spi_transfer tx, rx;
+	unsigned short rx_len = 0;
+	int ret;
+
+	spi_message_init(&m);
+	req[0] = NCI_SPI_DIRECT_READ;
+	req[1] = ndev->acknowledge_mode;
+	tx.tx_buf = req;
+	tx.len = 2;
+	tx.cs_change = 0;
+	spi_message_add_tail(&tx, &m);
+	rx.rx_buf = resp_hdr;
+	rx.len = 2;
+	rx.cs_change = 1;
+	spi_message_add_tail(&rx, &m);
+	ret = spi_sync(ndev->spi, &m);
+
+	if (ret)
+		return NULL;
+
+	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
+		rx_len = ((resp_hdr[0] & NCI_SPI_MSB_PAYLOAD_MASK) << 8) +
+				resp_hdr[1] + NCI_SPI_CRC_LEN;
+	else
+		rx_len = (resp_hdr[0] << 8) | resp_hdr[1];
+
+	skb = nci_skb_alloc(ndev->nci_dev, rx_len, GFP_KERNEL);
+	if (!skb)
+		return NULL;
+
+	spi_message_init(&m);
+	rx.rx_buf = skb_put(skb, rx_len);
+	rx.len = rx_len;
+	rx.cs_change = 0;
+	rx.delay_usecs = ndev->xfer_udelay;
+	spi_message_add_tail(&rx, &m);
+	ret = spi_sync(ndev->spi, &m);
+
+	if (ret)
+		goto receive_error;
+
+	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+		*skb_push(skb, 1) = resp_hdr[1];
+		*skb_push(skb, 1) = resp_hdr[0];
+	}
+
+	return skb;
+
+receive_error:
+	kfree_skb(skb);
+
+	return NULL;
+}
+
+static int nci_spi_check_crc(struct sk_buff *skb)
+{
+	u16 crc_data = (skb->data[skb->len - 2] << 8) |
+			skb->data[skb->len - 1];
+	int ret;
+
+	ret = (crc_ccitt(CRC_INIT, skb->data, skb->len - NCI_SPI_CRC_LEN)
+			== crc_data);
+
+	skb_trim(skb, skb->len - NCI_SPI_CRC_LEN);
+
+	return ret;
+}
+
+static u8 nci_spi_get_ack(struct sk_buff *skb)
+{
+	u8 ret;
+
+	ret = skb->data[0] >> NCI_SPI_ACK_SHIFT;
+
+	/* Remove NFCC part of the header: ACK, NACK and MSB payload len */
+	skb_pull(skb, 2);
+
+	return ret;
+}
+
+/**
+ * nci_spi_recv_frame - receive frame from NCI SPI drivers
+ *
+ * @ndev: The nci spi device
+ * Context: can sleep
+ *
+ * This call may only be used from a context that may sleep.  The sleep
+ * is non-interruptible, and has no timeout.
+ *
+ * It returns zero on success, else a negative error code.
+ */
+int nci_spi_recv_frame(struct nci_spi_dev *ndev)
+{
+	struct sk_buff *skb;
+	int ret = 0;
+
+	ndev->ops->deassert_int(ndev);
+
+	/* Retrieve frame from SPI */
+	skb = __nci_spi_recv_frame(ndev);
+	if (!skb) {
+		ret = -EIO;
+		goto done;
+	}
+
+	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+		if (!nci_spi_check_crc(skb)) {
+			send_acknowledge(ndev, ACKNOWLEDGE_NACK);
+			goto done;
+		}
+
+		/* In case of acknowledged mode: if ACK or NACK received,
+		 * unblock completion of latest frame sent.
+		 */
+		ndev->req_result = nci_spi_get_ack(skb);
+		if (ndev->req_result)
+			complete(&ndev->req_completion);
+	}
+
+	/* If there is no payload (ACK/NACK only frame),
+	 * free the socket buffer
+	 */
+	if (skb->len == 0) {
+		kfree_skb(skb);
+		goto done;
+	}
+
+	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED)
+		send_acknowledge(ndev, ACKNOWLEDGE_ACK);
+
+	/* Forward skb to NCI core layer */
+	ret = nci_recv_frame(ndev->nci_dev, skb);
+
+done:
+	ndev->ops->assert_int(ndev);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(nci_spi_recv_frame);

commit ee9596d467e4d05c77a8c883aeeb5b74d1a3cd31
Author: Frederic Danis <frederic.danis@linux.intel.com>
Date:   Wed May 29 15:35:03 2013 +0200

    NFC: Add NCI over SPI send
    
    Before any operation, driver interruption is de-asserted to prevent
    race condition between TX and RX.
    
    The NCI over SPI header is added in front of NCI packet.
    If acknowledged mode is set, CRC-16-CCITT is added to the packet.
    Then the packet is forwarded to SPI module to be sent.
    
    A delay after the transaction is added.
    This delay is determined by the driver during nci_spi_allocate_device()
    call and can be 0.
    
    After data has been sent, driver interruption is re-asserted.
    
    If acknowledged mode is set, nci_spi_send will block until
    acknowledgment is received.
    
    Signed-off-by: Frederic Danis <frederic.danis@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
index ebcdba51418c..6258461e6998 100644
--- a/net/nfc/nci/spi.c
+++ b/net/nfc/nci/spi.c
@@ -20,12 +20,25 @@
 
 #include <linux/export.h>
 #include <linux/spi/spi.h>
+#include <linux/crc-ccitt.h>
 #include <linux/nfc.h>
 #include <net/nfc/nci_core.h>
 
 #define NCI_SPI_HDR_LEN			4
 #define NCI_SPI_CRC_LEN			2
 
+#define NCI_SPI_SEND_TIMEOUT	(NCI_CMD_TIMEOUT > NCI_DATA_TIMEOUT ? \
+					NCI_CMD_TIMEOUT : NCI_DATA_TIMEOUT)
+
+#define NCI_SPI_DIRECT_WRITE	0x01
+#define NCI_SPI_DIRECT_READ	0x02
+
+#define ACKNOWLEDGE_NONE	0
+#define ACKNOWLEDGE_ACK		1
+#define ACKNOWLEDGE_NACK	2
+
+#define CRC_INIT		0xFFFF
+
 static int nci_spi_open(struct nci_dev *nci_dev)
 {
 	struct nci_spi_dev *ndev = nci_get_drvdata(nci_dev);
@@ -40,9 +53,65 @@ static int nci_spi_close(struct nci_dev *nci_dev)
 	return ndev->ops->close(ndev);
 }
 
+static int __nci_spi_send(struct nci_spi_dev *ndev, struct sk_buff *skb)
+{
+	struct spi_message m;
+	struct spi_transfer t;
+
+	t.tx_buf = skb->data;
+	t.len = skb->len;
+	t.cs_change = 0;
+	t.delay_usecs = ndev->xfer_udelay;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+
+	return spi_sync(ndev->spi, &m);
+}
+
 static int nci_spi_send(struct nci_dev *nci_dev, struct sk_buff *skb)
 {
-	return 0;
+	struct nci_spi_dev *ndev = nci_get_drvdata(nci_dev);
+	unsigned int payload_len = skb->len;
+	unsigned char *hdr;
+	int ret;
+	long completion_rc;
+
+	ndev->ops->deassert_int(ndev);
+
+	/* add the NCI SPI header to the start of the buffer */
+	hdr = skb_push(skb, NCI_SPI_HDR_LEN);
+	hdr[0] = NCI_SPI_DIRECT_WRITE;
+	hdr[1] = ndev->acknowledge_mode;
+	hdr[2] = payload_len >> 8;
+	hdr[3] = payload_len & 0xFF;
+
+	if (ndev->acknowledge_mode == NCI_SPI_CRC_ENABLED) {
+		u16 crc;
+
+		crc = crc_ccitt(CRC_INIT, skb->data, skb->len);
+		*skb_put(skb, 1) = crc >> 8;
+		*skb_put(skb, 1) = crc & 0xFF;
+	}
+
+	ret = __nci_spi_send(ndev, skb);
+
+	kfree_skb(skb);
+	ndev->ops->assert_int(ndev);
+
+	if (ret != 0 || ndev->acknowledge_mode == NCI_SPI_CRC_DISABLED)
+		goto done;
+
+	init_completion(&ndev->req_completion);
+	completion_rc =
+		wait_for_completion_interruptible_timeout(&ndev->req_completion,
+							  NCI_SPI_SEND_TIMEOUT);
+
+	if (completion_rc <= 0 || ndev->req_result == ACKNOWLEDGE_NACK)
+		ret = -EIO;
+
+done:
+	return ret;
 }
 
 static struct nci_ops nci_spi_ops = {

commit 8a00a61b0ef2bfd1b468dd20c0d0b1a94a8f7475
Author: Frederic Danis <frederic.danis@linux.intel.com>
Date:   Wed May 29 15:35:02 2013 +0200

    NFC: Add basic NCI over SPI
    
    The NFC Forum defines a transport interface based on
    Serial Peripheral Interface (SPI) for the NFC Controller
    Interface (NCI).
    
    This module implements the SPI transport of NCI, calling SPI module
    directly to read/write data to NFC controller (NFCC).
    
    NFCC driver should provide functions performing device open and close.
    It should also provide functions asserting/de-asserting interruption
    to prevent TX/RX race conditions.
    NFCC driver can also fix a delay between transactions if needed by
    the hardware.
    
    Signed-off-by: Frederic Danis <frederic.danis@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/nci/spi.c b/net/nfc/nci/spi.c
new file mode 100644
index 000000000000..ebcdba51418c
--- /dev/null
+++ b/net/nfc/nci/spi.c
@@ -0,0 +1,136 @@
+/*
+ * Copyright (C) 2013  Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ */
+
+#define pr_fmt(fmt) "nci_spi: %s: " fmt, __func__
+
+#include <linux/export.h>
+#include <linux/spi/spi.h>
+#include <linux/nfc.h>
+#include <net/nfc/nci_core.h>
+
+#define NCI_SPI_HDR_LEN			4
+#define NCI_SPI_CRC_LEN			2
+
+static int nci_spi_open(struct nci_dev *nci_dev)
+{
+	struct nci_spi_dev *ndev = nci_get_drvdata(nci_dev);
+
+	return ndev->ops->open(ndev);
+}
+
+static int nci_spi_close(struct nci_dev *nci_dev)
+{
+	struct nci_spi_dev *ndev = nci_get_drvdata(nci_dev);
+
+	return ndev->ops->close(ndev);
+}
+
+static int nci_spi_send(struct nci_dev *nci_dev, struct sk_buff *skb)
+{
+	return 0;
+}
+
+static struct nci_ops nci_spi_ops = {
+	.open = nci_spi_open,
+	.close = nci_spi_close,
+	.send = nci_spi_send,
+};
+
+/* ---- Interface to NCI SPI drivers ---- */
+
+/**
+ * nci_spi_allocate_device - allocate a new nci spi device
+ *
+ * @spi: SPI device
+ * @ops: device operations
+ * @supported_protocols: NFC protocols supported by the device
+ * @supported_se: NFC Secure Elements supported by the device
+ * @acknowledge_mode: Acknowledge mode used by the device
+ * @delay: delay between transactions in us
+ */
+struct nci_spi_dev *nci_spi_allocate_device(struct spi_device *spi,
+						struct nci_spi_ops *ops,
+						u32 supported_protocols,
+						u32 supported_se,
+						u8 acknowledge_mode,
+						unsigned int delay)
+{
+	struct nci_spi_dev *ndev;
+	int tailroom = 0;
+
+	if (!ops->open || !ops->close || !ops->assert_int || !ops->deassert_int)
+		return NULL;
+
+	if (!supported_protocols)
+		return NULL;
+
+	ndev = devm_kzalloc(&spi->dev, sizeof(struct nci_dev), GFP_KERNEL);
+	if (!ndev)
+		return NULL;
+
+	ndev->ops = ops;
+	ndev->acknowledge_mode = acknowledge_mode;
+	ndev->xfer_udelay = delay;
+
+	if (acknowledge_mode == NCI_SPI_CRC_ENABLED)
+		tailroom += NCI_SPI_CRC_LEN;
+
+	ndev->nci_dev = nci_allocate_device(&nci_spi_ops, supported_protocols,
+					    supported_se, NCI_SPI_HDR_LEN,
+					    tailroom);
+	if (!ndev->nci_dev)
+		return NULL;
+
+	nci_set_drvdata(ndev->nci_dev, ndev);
+
+	return ndev;
+}
+EXPORT_SYMBOL_GPL(nci_spi_allocate_device);
+
+/**
+ * nci_spi_free_device - deallocate nci spi device
+ *
+ * @ndev: The nci spi device to deallocate
+ */
+void nci_spi_free_device(struct nci_spi_dev *ndev)
+{
+	nci_free_device(ndev->nci_dev);
+}
+EXPORT_SYMBOL_GPL(nci_spi_free_device);
+
+/**
+ * nci_spi_register_device - register a nci spi device in the nfc subsystem
+ *
+ * @pdev: The nci spi device to register
+ */
+int nci_spi_register_device(struct nci_spi_dev *ndev)
+{
+	return nci_register_device(ndev->nci_dev);
+}
+EXPORT_SYMBOL_GPL(nci_spi_register_device);
+
+/**
+ * nci_spi_unregister_device - unregister a nci spi device in the nfc subsystem
+ *
+ * @dev: The nci spi device to unregister
+ */
+void nci_spi_unregister_device(struct nci_spi_dev *ndev)
+{
+	nci_unregister_device(ndev->nci_dev);
+}
+EXPORT_SYMBOL_GPL(nci_spi_unregister_device);
