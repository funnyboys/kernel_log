commit 2025cf9e193de05b0654570dd639acb49ebd3adf
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:18:02 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 288
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms and conditions of the gnu general public license
      version 2 as published by the free software foundation this program
      is distributed in the hope it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 263 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141901.208660670@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
index 3c39c72eb038..c33b2f7e1072 100644
--- a/net/nfc/digital.h
+++ b/net/nfc/digital.h
@@ -1,16 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * NFC Digital Protocol stack
  * Copyright (c) 2013, Intel Corporation.
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms and conditions of the GNU General Public License,
- * version 2, as published by the Free Software Foundation.
- *
- * This program is distributed in the hope it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
- * more details.
- *
  */
 
 #ifndef __DIGITAL_H

commit bf30a67c947ed57c1cf7c68a47dc24331458037e
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Mon Jul 21 21:24:39 2014 -0700

    NFC: digital: Add 'tg_listen_md' and 'tg_get_rf_tech' driver hooks
    
    The digital layer of the NFC subsystem currently
    supports a 'tg_listen_mdaa' driver hook that supports
    devices that can do mode detection and automatic
    anticollision.  However, there are some devices that
    can do mode detection but not automatic anitcollision
    so add the 'tg_listen_md' hook to support those devices.
    
    In order for the digital layer to get the RF technology
    detected by the device from the driver, add the
    'tg_get_rf_tech' hook.  It is only valid to call this
    hook immediately after a successful call to 'tg_listen_md'.
    
    CC: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
index 71ad7eefddd4..3c39c72eb038 100644
--- a/net/nfc/digital.h
+++ b/net/nfc/digital.h
@@ -29,6 +29,7 @@
 #define DIGITAL_CMD_TG_SEND        1
 #define DIGITAL_CMD_TG_LISTEN      2
 #define DIGITAL_CMD_TG_LISTEN_MDAA 3
+#define DIGITAL_CMD_TG_LISTEN_MD   4
 
 #define DIGITAL_MAX_HEADER_LEN 7
 #define DIGITAL_CRC_LEN        2
@@ -121,6 +122,8 @@ int digital_tg_send_dep_res(struct nfc_digital_dev *ddev, struct sk_buff *skb);
 
 int digital_tg_listen_nfca(struct nfc_digital_dev *ddev, u8 rf_tech);
 int digital_tg_listen_nfcf(struct nfc_digital_dev *ddev, u8 rf_tech);
+void digital_tg_recv_md_req(struct nfc_digital_dev *ddev, void *arg,
+			    struct sk_buff *resp);
 
 typedef u16 (*crc_func_t)(u16, const u8 *, size_t);
 

commit 24734607351a4f1c418f127f61958585dc7ed51d
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Mon Mar 31 17:36:38 2014 -0700

    NFC: digital: Add support for ISO/IEC 14443-B Protocol
    
    Add support for the ISO/IEC 14443-B protocol and Type 4B tags.
    It is expected that there will be only one tag within range so the full
    anticollision scheme is not implemented. Only the SENSB_REQ/SENSB_RES
    and ATTRIB_REQ/ATTRIB_RES are implemented.
    
    CC: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
index 3759add68b1b..71ad7eefddd4 100644
--- a/net/nfc/digital.h
+++ b/net/nfc/digital.h
@@ -71,6 +71,7 @@ static inline int digital_in_send_cmd(struct nfc_digital_dev *ddev,
 void digital_poll_next_tech(struct nfc_digital_dev *ddev);
 
 int digital_in_send_sens_req(struct nfc_digital_dev *ddev, u8 rf_tech);
+int digital_in_send_sensb_req(struct nfc_digital_dev *ddev, u8 rf_tech);
 int digital_in_send_sensf_req(struct nfc_digital_dev *ddev, u8 rf_tech);
 int digital_in_send_iso15693_inv_req(struct nfc_digital_dev *ddev, u8 rf_tech);
 

commit c813007f9ffb0b6e9f3dc43bfd9e28806aa57e5d
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Mon Jan 27 00:31:32 2014 +0100

    NFC: digital: Add ISO-DEP support for data exchange
    
    When a type 4A target is activated, this change adds the ISO-DEP SoD
    when sending frames and removes it when receiving responses. Chaining
    is not supported so sent frames are rejected if they exceed remote FSC
    bytes.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
index 3c757dc7d44f..3759add68b1b 100644
--- a/net/nfc/digital.h
+++ b/net/nfc/digital.h
@@ -74,6 +74,11 @@ int digital_in_send_sens_req(struct nfc_digital_dev *ddev, u8 rf_tech);
 int digital_in_send_sensf_req(struct nfc_digital_dev *ddev, u8 rf_tech);
 int digital_in_send_iso15693_inv_req(struct nfc_digital_dev *ddev, u8 rf_tech);
 
+int digital_in_iso_dep_pull_sod(struct nfc_digital_dev *ddev,
+				struct sk_buff *skb);
+int digital_in_iso_dep_push_sod(struct nfc_digital_dev *ddev,
+				struct sk_buff *skb);
+
 int digital_target_found(struct nfc_digital_dev *ddev,
 			 struct nfc_target *target, u8 protocol);
 

commit a381d4828625f526d290b296a829f8549b14ce49
Author: Mark A. Greer <mgreer@animalcreek.com>
Date:   Tue Jan 21 16:23:59 2014 -0700

    NFC: digital: Add Digital Layer support for ISO/IEC 15693
    
    Add support for ISO/IEC 15693 to the digital layer.  The code
    currently uses single-slot anticollision only since the digital
    layer infrastructure only supports one tag per adapter (making
    it pointless to do 16-slot anticollision).
    
    The code uses two new framing types:
    'NFC_DIGITAL_FRAMING_ISO15693_INVENTORY' and
    'NFC_DIGITAL_FRAMING_ISO15693_TVT'.  The former is used to
    tell the driver to prepare for an Inventory command and the
    ensuing anticollision sequence.  The latter is used to tell
    the driver that the anticollision sequence is over and to
    prepare for non-inventory commands.
    
    Signed-off-by: Mark A. Greer <mgreer@animalcreek.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
index 08b29b55ea63..3c757dc7d44f 100644
--- a/net/nfc/digital.h
+++ b/net/nfc/digital.h
@@ -72,6 +72,7 @@ void digital_poll_next_tech(struct nfc_digital_dev *ddev);
 
 int digital_in_send_sens_req(struct nfc_digital_dev *ddev, u8 rf_tech);
 int digital_in_send_sensf_req(struct nfc_digital_dev *ddev, u8 rf_tech);
+int digital_in_send_iso15693_inv_req(struct nfc_digital_dev *ddev, u8 rf_tech);
 
 int digital_target_found(struct nfc_digital_dev *ddev,
 			 struct nfc_target *target, u8 protocol);

commit c5da0e4a35eb1eba0c1593bef4bf2b58d9d50d6b
Author: Samuel Ortiz <sameo@linux.intel.com>
Date:   Fri Sep 20 09:05:48 2013 +0200

    NFC: digital: Remove PR_ERR and PR_DBG macros
    
    They can be replaced by the standard pr_err and pr_debug one after
    defining the right pr_fmt macro.
    
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
index 586075a3feed..08b29b55ea63 100644
--- a/net/nfc/digital.h
+++ b/net/nfc/digital.h
@@ -22,10 +22,8 @@
 #include <linux/crc-ccitt.h>
 #include <linux/crc-itu-t.h>
 
-#define PR_DBG(fmt, ...)  pr_debug("%s: " fmt "\n", __func__, ##__VA_ARGS__)
-#define PR_ERR(fmt, ...)  pr_err("%s: " fmt "\n", __func__, ##__VA_ARGS__)
-#define PROTOCOL_ERR(req) pr_err("%s:%d: NFC Digital Protocol error: %s\n", \
-				 __func__, __LINE__, req)
+#define PROTOCOL_ERR(req) pr_err("%d: NFC Digital Protocol error: %s\n", \
+				 __LINE__, req)
 
 #define DIGITAL_CMD_IN_SEND        0
 #define DIGITAL_CMD_TG_SEND        1

commit 1c7a4c24fbfd99442cc6e14dc80fcb00f118e8b8
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:30 2013 +0200

    NFC Digital: Add target NFC-DEP support
    
    This adds support for NFC-DEP target mode for NFC-A and NFC-F
    technologies.
    
    If the driver provides it, the stack uses an automatic mode for
    technology detection and automatic anti-collision. Otherwise the stack
    tries to use non-automatic synchronization and listens for SENS_REQ and
    SENSF_REQ commands.
    
    The detection, activation, and data exchange procedures work exactly
    the same way as in initiator mode, as described in the previous
    commits, except that the digital stack waits for commands and sends
    responses back to the peer device.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
index 5254a872522b..586075a3feed 100644
--- a/net/nfc/digital.h
+++ b/net/nfc/digital.h
@@ -56,8 +56,9 @@ struct sk_buff *digital_skb_alloc(struct nfc_digital_dev *ddev,
 				  unsigned int len);
 
 int digital_send_cmd(struct nfc_digital_dev *ddev, u8 cmd_type,
-		     struct sk_buff *skb, u16 timeout,
-		     nfc_digital_cmd_complete_t cmd_cb, void *cb_context);
+		     struct sk_buff *skb, struct digital_tg_mdaa_params *params,
+		     u16 timeout, nfc_digital_cmd_complete_t cmd_cb,
+		     void *cb_context);
 
 int digital_in_configure_hw(struct nfc_digital_dev *ddev, int type, int param);
 static inline int digital_in_send_cmd(struct nfc_digital_dev *ddev,
@@ -65,8 +66,8 @@ static inline int digital_in_send_cmd(struct nfc_digital_dev *ddev,
 				      nfc_digital_cmd_complete_t cmd_cb,
 				      void *cb_context)
 {
-	return digital_send_cmd(ddev, DIGITAL_CMD_IN_SEND, skb, timeout, cmd_cb,
-				cb_context);
+	return digital_send_cmd(ddev, DIGITAL_CMD_IN_SEND, skb, NULL, timeout,
+				cmd_cb, cb_context);
 }
 
 void digital_poll_next_tech(struct nfc_digital_dev *ddev);
@@ -86,6 +87,36 @@ int digital_in_send_dep_req(struct nfc_digital_dev *ddev,
 			    struct nfc_target *target, struct sk_buff *skb,
 			    struct digital_data_exch *data_exch);
 
+int digital_tg_configure_hw(struct nfc_digital_dev *ddev, int type, int param);
+static inline int digital_tg_send_cmd(struct nfc_digital_dev *ddev,
+			struct sk_buff *skb, u16 timeout,
+			nfc_digital_cmd_complete_t cmd_cb, void *cb_context)
+{
+	return digital_send_cmd(ddev, DIGITAL_CMD_TG_SEND, skb, NULL, timeout,
+				cmd_cb, cb_context);
+}
+
+void digital_tg_recv_sens_req(struct nfc_digital_dev *ddev, void *arg,
+			      struct sk_buff *resp);
+
+void digital_tg_recv_sensf_req(struct nfc_digital_dev *ddev, void *arg,
+			       struct sk_buff *resp);
+
+static inline int digital_tg_listen(struct nfc_digital_dev *ddev, u16 timeout,
+				    nfc_digital_cmd_complete_t cb, void *arg)
+{
+	return digital_send_cmd(ddev, DIGITAL_CMD_TG_LISTEN, NULL, NULL,
+				timeout, cb, arg);
+}
+
+void digital_tg_recv_atr_req(struct nfc_digital_dev *ddev, void *arg,
+			     struct sk_buff *resp);
+
+int digital_tg_send_dep_res(struct nfc_digital_dev *ddev, struct sk_buff *skb);
+
+int digital_tg_listen_nfca(struct nfc_digital_dev *ddev, u8 rf_tech);
+int digital_tg_listen_nfcf(struct nfc_digital_dev *ddev, u8 rf_tech);
+
 typedef u16 (*crc_func_t)(u16, const u8 *, size_t);
 
 #define CRC_A_INIT 0x6363

commit 7d0911c02fa2a448a28d7844d2a0c439ff8397b1
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:29 2013 +0200

    NFC Digital: Add initiator NFC-DEP support
    
    This adds support for NFC-DEP protocol in initiator mode for NFC-A and
    NFC-F technologies.
    
    When a target is detected, the process flow is as follow:
    
    For NFC-A technology:
    1 - The digital stack receives a SEL_RES as the reply of the SEL_REQ
        command.
    2   - If b7 of SEL_RES is set, the peer device is configure for NFC-DEP
          protocol. NFC core is notified through nfc_targets_found().
          Execution continues at step 4.
    3   - Otherwise, it's a tag and the NFC core is notified. Detection
          ends.
    4 - The digital stacks sends an ATR_REQ command containing a randomly
        generated NFCID3 and the general bytes obtained from the LLCP layer
        of NFC core.
    
    For NFC-F technology:
    1 - The digital stack receives a SENSF_RES as the reply of the
        SENSF_REQ command.
    2   - If B1 and B2 of NFCID2 are 0x01 and 0xFE respectively, the peer
          device is configured for NFC-DEP protocol. NFC core is notified
          through nfc_targets_found(). Execution continues at step 4.
    3   - Otherwise it's a type 3 tag. NFC core is notified. Detection
          ends.
    4 - The digital stacks sends an ATR_REQ command containing the NFC-F
        NFCID2 as NFCID3 and the general bytes obtained from the LLCP layer
        of NFC core.
    
    For both technologies:
    5 - The digital stacks receives the ATR_RES response containing the
        NFCID3 and the general bytes of the peer device.
    6 - The digital stack notifies NFC core that the DEP link is up through
        nfc_dep_link_up().
    7 - The NFC core performs data exchange through tm_transceive().
    8 - The digital stack sends a DEP_REQ command containing an I PDU with
        the data from NFC core.
    9 - The digital stack receives a DEP_RES command
    10  - If the DEP_RES response contains a supervisor PDU with timeout
          extension request (RTOX) the digital stack sends a DEP_REQ
          command containing a supervisor PDU acknowledging the RTOX
          request. The execution continues at step 9.
    11  - If the DEP_RES response contains an I PDU, the response data is
          passed back to NFC core through the response callback. The
          execution continues at step 8.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
index 85bc74c988f8..5254a872522b 100644
--- a/net/nfc/digital.h
+++ b/net/nfc/digital.h
@@ -35,6 +35,13 @@
 #define DIGITAL_MAX_HEADER_LEN 7
 #define DIGITAL_CRC_LEN        2
 
+#define DIGITAL_SENSF_NFCID2_NFC_DEP_B1 0x01
+#define DIGITAL_SENSF_NFCID2_NFC_DEP_B2 0xFE
+
+#define DIGITAL_SENS_RES_NFC_DEP 0x0100
+#define DIGITAL_SEL_RES_NFC_DEP  0x40
+#define DIGITAL_SENSF_FELICA_SC  0xFFFF
+
 #define DIGITAL_DRV_CAPS_IN_CRC(ddev) \
 	((ddev)->driver_capabilities & NFC_DIGITAL_DRV_CAPS_IN_CRC)
 #define DIGITAL_DRV_CAPS_TG_CRC(ddev) \
@@ -72,6 +79,13 @@ int digital_target_found(struct nfc_digital_dev *ddev,
 
 int digital_in_recv_mifare_res(struct sk_buff *resp);
 
+int digital_in_send_atr_req(struct nfc_digital_dev *ddev,
+			    struct nfc_target *target, __u8 comm_mode, __u8 *gb,
+			    size_t gb_len);
+int digital_in_send_dep_req(struct nfc_digital_dev *ddev,
+			    struct nfc_target *target, struct sk_buff *skb,
+			    struct digital_data_exch *data_exch);
+
 typedef u16 (*crc_func_t)(u16, const u8 *, size_t);
 
 #define CRC_A_INIT 0x6363

commit 8c0695e4998dd268ff2a05951961247b7e015651
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:28 2013 +0200

    NFC Digital: Add NFC-F technology support
    
    This adds polling support for NFC-F technology at 212 kbits/s and 424
    kbits/s. A user space application like neard can send type 3 tag
    commands through the NFC core.
    
    Process flow for NFC-F detection is as follow:
    
    1 - The digital stack sends the SENSF_REQ command to the NFC device.
    2 - A peer device replies with a SENSF_RES response.
    3   - The digital stack notifies the NFC core of the presence of a
          target in the operation field and passes the target NFCID2.
    
    This also adds support for CRC calculation of type CRC-F. The CRC
    calculation is handled by the digital stack if the NFC device doesn't
    support it.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
index fb5324b792de..85bc74c988f8 100644
--- a/net/nfc/digital.h
+++ b/net/nfc/digital.h
@@ -20,6 +20,7 @@
 #include <net/nfc/digital.h>
 
 #include <linux/crc-ccitt.h>
+#include <linux/crc-itu-t.h>
 
 #define PR_DBG(fmt, ...)  pr_debug("%s: " fmt "\n", __func__, ##__VA_ARGS__)
 #define PR_ERR(fmt, ...)  pr_err("%s: " fmt "\n", __func__, ##__VA_ARGS__)
@@ -64,6 +65,7 @@ static inline int digital_in_send_cmd(struct nfc_digital_dev *ddev,
 void digital_poll_next_tech(struct nfc_digital_dev *ddev);
 
 int digital_in_send_sens_req(struct nfc_digital_dev *ddev, u8 rf_tech);
+int digital_in_send_sensf_req(struct nfc_digital_dev *ddev, u8 rf_tech);
 
 int digital_target_found(struct nfc_digital_dev *ddev,
 			 struct nfc_target *target, u8 protocol);
@@ -74,6 +76,7 @@ typedef u16 (*crc_func_t)(u16, const u8 *, size_t);
 
 #define CRC_A_INIT 0x6363
 #define CRC_B_INIT 0xFFFF
+#define CRC_F_INIT 0x0000
 
 void digital_skb_add_crc(struct sk_buff *skb, crc_func_t crc_func, u16 init,
 			 u8 bitwise_inv, u8 msb_first);
@@ -88,6 +91,11 @@ static inline void digital_skb_add_crc_b(struct sk_buff *skb)
 	digital_skb_add_crc(skb, crc_ccitt, CRC_B_INIT, 1, 0);
 }
 
+static inline void digital_skb_add_crc_f(struct sk_buff *skb)
+{
+	digital_skb_add_crc(skb, crc_itu_t, CRC_F_INIT, 0, 1);
+}
+
 static inline void digital_skb_add_crc_none(struct sk_buff *skb)
 {
 	return;
@@ -106,6 +114,11 @@ static inline int digital_skb_check_crc_b(struct sk_buff *skb)
 	return digital_skb_check_crc(skb, crc_ccitt, CRC_B_INIT, 1, 0);
 }
 
+static inline int digital_skb_check_crc_f(struct sk_buff *skb)
+{
+	return digital_skb_check_crc(skb, crc_itu_t, CRC_F_INIT, 0, 1);
+}
+
 static inline int digital_skb_check_crc_none(struct sk_buff *skb)
 {
 	return 0;

commit 2c66daecc4092e6049673c281b2e6f0d5e59a94c
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:27 2013 +0200

    NFC Digital: Add NFC-A technology support
    
    This adds support for NFC-A technology at 106 kbits/s. The stack can
    detect tags of type 1 and 2. There is no support for collision
    detection. Tags can be read and written by using a user space
    application or a daemon like neard.
    
    The flow of polling operations for NFC-A detection is as follow:
    
    1 - The digital stack sends the SENS_REQ command to the NFC device.
    2 - The NFC device receives a SENS_RES response from a peer device and
        passes it to the digital stack.
    3   - If the SENS_RES response identifies a type 1 tag, detection ends.
          NFC core is notified through nfc_targets_found().
    4   - Otherwise, the digital stack sets the cascade level of NFCID1 to
          CL1 and sends the SDD_REQ command.
    5 - The digital stack selects SEL_CMD and SEL_PAR according to the
        cascade level and sends the SDD_REQ command.
    4 - The digital stack receives a SDD_RES response for the cascade level
        passed in the SDD_REQ command.
    5 - The digital stack analyses (part of) NFCID1 and verify BCC.
    6 - The digital stack sends the SEL_REQ command with the NFCID1
        received in the SDD_RES.
    6 - The peer device replies with a SEL_RES response
    7   - Detection ends if NFCID1 is complete. NFC core notified of new
          target by nfc_targets_found().
    8   - If NFCID1 is not complete, the cascade level is incremented (up
          to and including CL3) and the execution continues at step 5 to
          get the remaining bytes of NFCID1.
    
    Once target detection is done, type 1 and 2 tag commands must be
    handled by a user space application (i.e neard) through the NFC core.
    Responses for type 1 tag are returned directly to user space via NFC
    core.
    Responses of type 2 commands are handled differently. The digital stack
    doesn't analyse the type of commands sent through im_transceive() and
    must differentiate valid responses from error ones.
    The response process flow is as follow:
    
    1 - If the response length is 16 bytes, it is a valid response of a
        READ command. the packet is returned to the NFC core through the
        callback passed to im_transceive(). Processing stops.
    2 - If the response is 1 byte long and is a ACK byte (0x0A), it is a
        valid response of a WRITE command for example. First packet byte
        is set to 0 for no-error and passed back to the NFC core.
        Processing stops.
    3 - Any other response is treated as an error and -EIO error code is
        returned to the NFC core through the response callback.
    
    Moreover, since the driver can't differentiate success response from a
    NACK response, the digital stack has to handle CRC calculation.
    
    Thus, this patch also adds support for CRC calculation. If the driver
    doesn't handle it, the digital stack will calculate CRC and will add it
    to sent frames. CRC will also be checked and removed from received
    frames. Pointers to the correct CRC calculation functions are stored in
    the digital stack device structure when a target is detected. This
    avoids the need to check the current target type for every call to
    im_transceive() and for every response received from a peer device.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
index 0a2767098daa..fb5324b792de 100644
--- a/net/nfc/digital.h
+++ b/net/nfc/digital.h
@@ -19,6 +19,8 @@
 #include <net/nfc/nfc.h>
 #include <net/nfc/digital.h>
 
+#include <linux/crc-ccitt.h>
+
 #define PR_DBG(fmt, ...)  pr_debug("%s: " fmt "\n", __func__, ##__VA_ARGS__)
 #define PR_ERR(fmt, ...)  pr_err("%s: " fmt "\n", __func__, ##__VA_ARGS__)
 #define PROTOCOL_ERR(req) pr_err("%s:%d: NFC Digital Protocol error: %s\n", \
@@ -32,6 +34,16 @@
 #define DIGITAL_MAX_HEADER_LEN 7
 #define DIGITAL_CRC_LEN        2
 
+#define DIGITAL_DRV_CAPS_IN_CRC(ddev) \
+	((ddev)->driver_capabilities & NFC_DIGITAL_DRV_CAPS_IN_CRC)
+#define DIGITAL_DRV_CAPS_TG_CRC(ddev) \
+	((ddev)->driver_capabilities & NFC_DIGITAL_DRV_CAPS_TG_CRC)
+
+struct digital_data_exch {
+	data_exchange_cb_t cb;
+	void *cb_context;
+};
+
 struct sk_buff *digital_skb_alloc(struct nfc_digital_dev *ddev,
 				  unsigned int len);
 
@@ -53,4 +65,50 @@ void digital_poll_next_tech(struct nfc_digital_dev *ddev);
 
 int digital_in_send_sens_req(struct nfc_digital_dev *ddev, u8 rf_tech);
 
+int digital_target_found(struct nfc_digital_dev *ddev,
+			 struct nfc_target *target, u8 protocol);
+
+int digital_in_recv_mifare_res(struct sk_buff *resp);
+
+typedef u16 (*crc_func_t)(u16, const u8 *, size_t);
+
+#define CRC_A_INIT 0x6363
+#define CRC_B_INIT 0xFFFF
+
+void digital_skb_add_crc(struct sk_buff *skb, crc_func_t crc_func, u16 init,
+			 u8 bitwise_inv, u8 msb_first);
+
+static inline void digital_skb_add_crc_a(struct sk_buff *skb)
+{
+	digital_skb_add_crc(skb, crc_ccitt, CRC_A_INIT, 0, 0);
+}
+
+static inline void digital_skb_add_crc_b(struct sk_buff *skb)
+{
+	digital_skb_add_crc(skb, crc_ccitt, CRC_B_INIT, 1, 0);
+}
+
+static inline void digital_skb_add_crc_none(struct sk_buff *skb)
+{
+	return;
+}
+
+int digital_skb_check_crc(struct sk_buff *skb, crc_func_t crc_func,
+			  u16 crc_init, u8 bitwise_inv, u8 msb_first);
+
+static inline int digital_skb_check_crc_a(struct sk_buff *skb)
+{
+	return digital_skb_check_crc(skb, crc_ccitt, CRC_A_INIT, 0, 0);
+}
+
+static inline int digital_skb_check_crc_b(struct sk_buff *skb)
+{
+	return digital_skb_check_crc(skb, crc_ccitt, CRC_B_INIT, 1, 0);
+}
+
+static inline int digital_skb_check_crc_none(struct sk_buff *skb)
+{
+	return 0;
+}
+
 #endif /* __DIGITAL_H */

commit 59ee2361c9248f07846f7a6e585768dcce18fb16
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:26 2013 +0200

    NFC Digital: Implement driver commands mechanism
    
    This implements the mechanism used to send commands to the driver in
    initiator mode through in_send_cmd().
    
    Commands are serialized and sent to the driver by using a work item
    on the system workqueue. Responses are handled asynchronously by
    another work item. Once the digital stack receives the response through
    the command_complete callback, the next command is sent to the driver.
    
    This also implements the polling mechanism. It's handled by a work item
    cycling on all supported protocols. The start poll command for a given
    protocol is sent to the driver using the mechanism described above.
    The process continues until a peer is discovered or stop_poll is
    called. This patch implements the poll function for NFC-A that sends a
    SENS_REQ command and waits for the SENS_RES response.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
index 8d91ed820912..0a2767098daa 100644
--- a/net/nfc/digital.h
+++ b/net/nfc/digital.h
@@ -24,4 +24,33 @@
 #define PROTOCOL_ERR(req) pr_err("%s:%d: NFC Digital Protocol error: %s\n", \
 				 __func__, __LINE__, req)
 
+#define DIGITAL_CMD_IN_SEND        0
+#define DIGITAL_CMD_TG_SEND        1
+#define DIGITAL_CMD_TG_LISTEN      2
+#define DIGITAL_CMD_TG_LISTEN_MDAA 3
+
+#define DIGITAL_MAX_HEADER_LEN 7
+#define DIGITAL_CRC_LEN        2
+
+struct sk_buff *digital_skb_alloc(struct nfc_digital_dev *ddev,
+				  unsigned int len);
+
+int digital_send_cmd(struct nfc_digital_dev *ddev, u8 cmd_type,
+		     struct sk_buff *skb, u16 timeout,
+		     nfc_digital_cmd_complete_t cmd_cb, void *cb_context);
+
+int digital_in_configure_hw(struct nfc_digital_dev *ddev, int type, int param);
+static inline int digital_in_send_cmd(struct nfc_digital_dev *ddev,
+				      struct sk_buff *skb, u16 timeout,
+				      nfc_digital_cmd_complete_t cmd_cb,
+				      void *cb_context)
+{
+	return digital_send_cmd(ddev, DIGITAL_CMD_IN_SEND, skb, timeout, cmd_cb,
+				cb_context);
+}
+
+void digital_poll_next_tech(struct nfc_digital_dev *ddev);
+
+int digital_in_send_sens_req(struct nfc_digital_dev *ddev, u8 rf_tech);
+
 #endif /* __DIGITAL_H */

commit 4b10884eb428c243ae2070a539612e645f3d9b93
Author: Thierry Escande <thierry.escande@linux.intel.com>
Date:   Thu Sep 19 17:55:25 2013 +0200

    NFC: Digital Protocol stack implementation
    
    This is the initial commit of the NFC Digital Protocol stack
    implementation.
    
    It offers an interface for devices that don't have an embedded NFC
    Digital protocol stack. The driver instantiates the digital stack by
    calling nfc_digital_allocate_device(). Within the nfc_digital_ops
    structure, the driver specifies a set of function pointers for driver
    operations. These functions must be implemented by the driver and are:
    
    in_configure_hw:
    Hardware configuration for RF technology and communication framing in
    initiator mode. This is a synchronous function.
    
    in_send_cmd:
    Initiator mode data exchange using RF technology and framing previously
    set with in_configure_hw. The peer response is returned through
    callback cb. If an io error occurs or the peer didn't reply within the
    specified timeout (ms), the error code is passed back through the resp
    pointer. This is an asynchronous function.
    
    tg_configure_hw:
    Hardware configuration for RF technology and communication framing in
    target mode. This is a synchronous function.
    
    tg_send_cmd:
    Target mode data exchange using RF technology and framing previously
    set with tg_configure_hw. The peer next command is returned through
    callback cb. If an io error occurs or the peer didn't reply within the
    specified timeout (ms), the error code is passed back through the resp
    pointer. This is an asynchronous function.
    
    tg_listen:
    Put the device in listen mode waiting for data from the peer device.
    This is an asynchronous function.
    
    tg_listen_mdaa:
    If supported, put the device in automatic listen mode with mode
    detection and automatic anti-collision. In this mode, the device
    automatically detects the RF technology and executes the
    anti-collision detection using the command responses specified in
    mdaa_params. The mdaa_params structure contains SENS_RES, NFCID1, and
    SEL_RES for 106A RF tech. NFCID2 and system code (sc) for 212F and
    424F. The driver returns the NFC-DEP ATR_REQ command through cb. The
    digital stack deducts the RF tech by analyzing the SoD of the frame
    containing the ATR_REQ command. This is an asynchronous function.
    
    switch_rf:
    Turns device radio on or off. The stack does not call explicitly
    switch_rf to turn the radio on. A call to in|tg_configure_hw must turn
    the device radio on.
    
    abort_cmd:
    Discard the last sent command.
    
    Then the driver registers itself against the digital stack by using
    nfc_digital_register_device() which in turn registers the digital stack
    against the NFC core layer. The digital stack implements common NFC
    operations like dev_up(), dev_down(), start_poll(), stop_poll(), etc.
    
    This patch is only a skeleton and NFC operations are just stubs.
    
    Signed-off-by: Thierry Escande <thierry.escande@linux.intel.com>
    Signed-off-by: Samuel Ortiz <sameo@linux.intel.com>

diff --git a/net/nfc/digital.h b/net/nfc/digital.h
new file mode 100644
index 000000000000..8d91ed820912
--- /dev/null
+++ b/net/nfc/digital.h
@@ -0,0 +1,27 @@
+/*
+ * NFC Digital Protocol stack
+ * Copyright (c) 2013, Intel Corporation.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ */
+
+#ifndef __DIGITAL_H
+#define __DIGITAL_H
+
+#include <net/nfc/nfc.h>
+#include <net/nfc/digital.h>
+
+#define PR_DBG(fmt, ...)  pr_debug("%s: " fmt "\n", __func__, ##__VA_ARGS__)
+#define PR_ERR(fmt, ...)  pr_err("%s: " fmt "\n", __func__, ##__VA_ARGS__)
+#define PROTOCOL_ERR(req) pr_err("%s:%d: NFC Digital Protocol error: %s\n", \
+				 __func__, __LINE__, req)
+
+#endif /* __DIGITAL_H */
