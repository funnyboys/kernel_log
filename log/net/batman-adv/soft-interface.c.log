commit 845e0ebb4408d4473cf60d21224a897037e9a77a
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Mon Jun 8 14:53:01 2020 -0700

    net: change addr_list_lock back to static key
    
    The dynamic key update for addr_list_lock still causes troubles,
    for example the following race condition still exists:
    
    CPU 0:                          CPU 1:
    (RCU read lock)                 (RTNL lock)
    dev_mc_seq_show()               netdev_update_lockdep_key()
                                      -> lockdep_unregister_key()
     -> netif_addr_lock_bh()
    
    because lockdep doesn't provide an API to update it atomically.
    Therefore, we have to move it back to static keys and use subclass
    for nest locking like before.
    
    In commit 1a33e10e4a95 ("net: partially revert dynamic lockdep key
    changes"), I already reverted most parts of commit ab92d68fc22f
    ("net: core: add generic lockdep keys").
    
    This patch reverts the rest and also part of commit f3b0a18bb6cb
    ("net: remove unnecessary variables and callback"). After this
    patch, addr_list_lock changes back to using static keys and
    subclasses to satisfy lockdep. Thanks to dev->lower_level, we do
    not have to change back to ->ndo_get_lock_subclass().
    
    And hopefully this reduces some syzbot lockdep noises too.
    
    Reported-by: syzbot+f3a0e80c34b3fc28ac5e@syzkaller.appspotmail.com
    Cc: Taehee Yoo <ap420073@gmail.com>
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 0ddd80130ea3..f1f1c86f3419 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -745,6 +745,7 @@ static int batadv_interface_kill_vid(struct net_device *dev, __be16 proto,
  * separate class since they always nest.
  */
 static struct lock_class_key batadv_netdev_xmit_lock_key;
+static struct lock_class_key batadv_netdev_addr_lock_key;
 
 /**
  * batadv_set_lockdep_class_one() - Set lockdep class for a single tx queue
@@ -765,6 +766,7 @@ static void batadv_set_lockdep_class_one(struct net_device *dev,
  */
 static void batadv_set_lockdep_class(struct net_device *dev)
 {
+	lockdep_set_class(&dev->addr_list_lock, &batadv_netdev_addr_lock_key);
 	netdev_for_each_tx_queue(dev, batadv_set_lockdep_class_one, NULL);
 }
 

commit 2092c910e2399c9e13b199c07421133681b9eaff
Author: Sven Eckelmann <sven@narfation.org>
Date:   Wed May 6 22:13:30 2020 +0200

    batman-adv: Revert "Drop lockdep.h include for soft-interface.c"
    
    The commit 1a33e10e4a95 ("net: partially revert dynamic lockdep key
    changes") reverts the commit ab92d68fc22f ("net: core: add generic lockdep
    keys"). But it forgot to also revert the commit 5759af0682b3 ("batman-adv:
    Drop lockdep.h include for soft-interface.c") which depends on the latter.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 822af540b854..0ddd80130ea3 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -22,6 +22,7 @@
 #include <linux/kernel.h>
 #include <linux/kref.h>
 #include <linux/list.h>
+#include <linux/lockdep.h>
 #include <linux/netdevice.h>
 #include <linux/netlink.h>
 #include <linux/percpu.h>

commit 1a33e10e4a95cb109ff1145098175df3113313ef
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Sat May 2 22:22:19 2020 -0700

    net: partially revert dynamic lockdep key changes
    
    This patch reverts the folowing commits:
    
    commit 064ff66e2bef84f1153087612032b5b9eab005bd
    "bonding: add missing netdev_update_lockdep_key()"
    
    commit 53d374979ef147ab51f5d632dfe20b14aebeccd0
    "net: avoid updating qdisc_xmit_lock_key in netdev_update_lockdep_key()"
    
    commit 1f26c0d3d24125992ab0026b0dab16c08df947c7
    "net: fix kernel-doc warning in <linux/netdevice.h>"
    
    commit ab92d68fc22f9afab480153bd82a20f6e2533769
    "net: core: add generic lockdep keys"
    
    but keeps the addr_list_lock_key because we still lock
    addr_list_lock nestedly on stack devices, unlikely xmit_lock
    this is safe because we don't take addr_list_lock on any fast
    path.
    
    Reported-and-tested-by: syzbot+aaa6fa4949cc5d9b7b25@syzkaller.appspotmail.com
    Cc: Dmitry Vyukov <dvyukov@google.com>
    Cc: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Acked-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 5f05a728f347..822af540b854 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -739,6 +739,34 @@ static int batadv_interface_kill_vid(struct net_device *dev, __be16 proto,
 	return 0;
 }
 
+/* batman-adv network devices have devices nesting below it and are a special
+ * "super class" of normal network devices; split their locks off into a
+ * separate class since they always nest.
+ */
+static struct lock_class_key batadv_netdev_xmit_lock_key;
+
+/**
+ * batadv_set_lockdep_class_one() - Set lockdep class for a single tx queue
+ * @dev: device which owns the tx queue
+ * @txq: tx queue to modify
+ * @_unused: always NULL
+ */
+static void batadv_set_lockdep_class_one(struct net_device *dev,
+					 struct netdev_queue *txq,
+					 void *_unused)
+{
+	lockdep_set_class(&txq->_xmit_lock, &batadv_netdev_xmit_lock_key);
+}
+
+/**
+ * batadv_set_lockdep_class() - Set txq and addr_list lockdep class
+ * @dev: network device to modify
+ */
+static void batadv_set_lockdep_class(struct net_device *dev)
+{
+	netdev_for_each_tx_queue(dev, batadv_set_lockdep_class_one, NULL);
+}
+
 /**
  * batadv_softif_init_late() - late stage initialization of soft interface
  * @dev: registered network device to modify
@@ -752,6 +780,8 @@ static int batadv_softif_init_late(struct net_device *dev)
 	int ret;
 	size_t cnt_len = sizeof(u64) * BATADV_CNT_NUM;
 
+	batadv_set_lockdep_class(dev);
+
 	bat_priv = netdev_priv(dev);
 	bat_priv->soft_iface = dev;
 

commit 68e039f966cb577c91649a02591646ac3919f8c9
Author: Sven Eckelmann <sven@narfation.org>
Date:   Wed Jan 1 00:00:01 2020 +0100

    batman-adv: Update copyright years for 2020
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 832e156c519e..5f05a728f347 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright (C) 2007-2019  B.A.T.M.A.N. contributors:
+/* Copyright (C) 2007-2020  B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
  */

commit 5759af0682b3395e64cf615e062d6ecad01428dc
Author: Sven Eckelmann <sven@narfation.org>
Date:   Wed Oct 30 08:03:49 2019 +0100

    batman-adv: Drop lockdep.h include for soft-interface.c
    
    The commit ab92d68fc22f ("net: core: add generic lockdep keys") removed
    all lockdep functionality from soft-interface.c but didn't remove the
    include for this functionality.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 697f2da12487..832e156c519e 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -22,7 +22,6 @@
 #include <linux/kernel.h>
 #include <linux/kref.h>
 #include <linux/list.h>
-#include <linux/lockdep.h>
 #include <linux/netdevice.h>
 #include <linux/netlink.h>
 #include <linux/percpu.h>

commit a7757d318a8afaf3e1f17926ee1857b0d005db70
Author: Sven Eckelmann <sven@narfation.org>
Date:   Thu Oct 31 17:34:37 2019 +0100

    batman-adv: Use 'fallthrough' pseudo keyword
    
    The usage of the '/* fall through */' comments in switches are no longer
    marked as non-deprecated variant of implicit fall throughs for switch
    statements. The commit 294f69e662d1 ("compiler_attributes.h: Add
    'fallthrough' pseudo keyword for switch/case use") introduced a replacement
    keyword which should be used instead.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 5ee8e9a100f9..697f2da12487 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -230,7 +230,7 @@ static netdev_tx_t batadv_interface_tx(struct sk_buff *skb,
 			break;
 		}
 
-		/* fall through */
+		fallthrough;
 	case ETH_P_BATMAN:
 		goto dropped;
 	}
@@ -455,7 +455,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 		if (vhdr->h_vlan_encapsulated_proto != htons(ETH_P_BATMAN))
 			break;
 
-		/* fall through */
+		fallthrough;
 	case ETH_P_BATMAN:
 		goto dropped;
 	}

commit ab92d68fc22f9afab480153bd82a20f6e2533769
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Mon Oct 21 18:47:51 2019 +0000

    net: core: add generic lockdep keys
    
    Some interface types could be nested.
    (VLAN, BONDING, TEAM, MACSEC, MACVLAN, IPVLAN, VIRT_WIFI, VXLAN, etc..)
    These interface types should set lockdep class because, without lockdep
    class key, lockdep always warn about unexisting circular locking.
    
    In the current code, these interfaces have their own lockdep class keys and
    these manage itself. So that there are so many duplicate code around the
    /driver/net and /net/.
    This patch adds new generic lockdep keys and some helper functions for it.
    
    This patch does below changes.
    a) Add lockdep class keys in struct net_device
       - qdisc_running, xmit, addr_list, qdisc_busylock
       - these keys are used as dynamic lockdep key.
    b) When net_device is being allocated, lockdep keys are registered.
       - alloc_netdev_mqs()
    c) When net_device is being free'd llockdep keys are unregistered.
       - free_netdev()
    d) Add generic lockdep key helper function
       - netdev_register_lockdep_key()
       - netdev_unregister_lockdep_key()
       - netdev_update_lockdep_key()
    e) Remove unnecessary generic lockdep macro and functions
    f) Remove unnecessary lockdep code of each interfaces.
    
    After this patch, each interface modules don't need to maintain
    their lockdep keys.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 9cbed6f5a85a..5ee8e9a100f9 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -740,36 +740,6 @@ static int batadv_interface_kill_vid(struct net_device *dev, __be16 proto,
 	return 0;
 }
 
-/* batman-adv network devices have devices nesting below it and are a special
- * "super class" of normal network devices; split their locks off into a
- * separate class since they always nest.
- */
-static struct lock_class_key batadv_netdev_xmit_lock_key;
-static struct lock_class_key batadv_netdev_addr_lock_key;
-
-/**
- * batadv_set_lockdep_class_one() - Set lockdep class for a single tx queue
- * @dev: device which owns the tx queue
- * @txq: tx queue to modify
- * @_unused: always NULL
- */
-static void batadv_set_lockdep_class_one(struct net_device *dev,
-					 struct netdev_queue *txq,
-					 void *_unused)
-{
-	lockdep_set_class(&txq->_xmit_lock, &batadv_netdev_xmit_lock_key);
-}
-
-/**
- * batadv_set_lockdep_class() - Set txq and addr_list lockdep class
- * @dev: network device to modify
- */
-static void batadv_set_lockdep_class(struct net_device *dev)
-{
-	lockdep_set_class(&dev->addr_list_lock, &batadv_netdev_addr_lock_key);
-	netdev_for_each_tx_queue(dev, batadv_set_lockdep_class_one, NULL);
-}
-
 /**
  * batadv_softif_init_late() - late stage initialization of soft interface
  * @dev: registered network device to modify
@@ -783,8 +753,6 @@ static int batadv_softif_init_late(struct net_device *dev)
 	int ret;
 	size_t cnt_len = sizeof(u64) * BATADV_CNT_NUM;
 
-	batadv_set_lockdep_class(dev);
-
 	bat_priv = netdev_priv(dev);
 	bat_priv->soft_iface = dev;
 

commit 895b5c9f206eb7d25dc1360a8ccfc5958895eb89
Author: Florian Westphal <fw@strlen.de>
Date:   Sun Sep 29 20:54:03 2019 +0200

    netfilter: drop bridge nf reset from nf_reset
    
    commit 174e23810cd31
    ("sk_buff: drop all skb extensions on free and skb scrubbing") made napi
    recycle always drop skb extensions.  The additional skb_ext_del() that is
    performed via nf_reset on napi skb recycle is not needed anymore.
    
    Most nf_reset() calls in the stack are there so queued skb won't block
    'rmmod nf_conntrack' indefinitely.
    
    This removes the skb_ext_del from nf_reset, and renames it to a more
    fitting nf_reset_ct().
    
    In a few selected places, add a call to skb_ext_reset to make sure that
    no active extensions remain.
    
    I am submitting this for "net", because we're still early in the release
    cycle.  The patch applies to net-next too, but I think the rename causes
    needless divergence between those trees.
    
    Suggested-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Pablo Neira Ayuso <pablo@netfilter.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index a1146cb10919..9cbed6f5a85a 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -436,7 +436,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	/* clean the netfilter state now that the batman-adv header has been
 	 * removed
 	 */
-	nf_reset(skb);
+	nf_reset_ct(skb);
 
 	if (unlikely(!pskb_may_pull(skb, ETH_HLEN)))
 		goto dropped;

commit 529a8f939a5fdbfa27d10bba728d9764212ab26f
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Jul 6 14:56:13 2019 +0200

    batman-adv: Replace usage of strlcpy with strscpy
    
    The strscpy was introduced to fix some API problems around strlcpy. And
    checkpatch started to report recently that strlcpy is deprecated and
    strscpy is preferred.
    
    The functionality introduced in commit 30035e45753b ("string: provide
    strscpy()") improves following points compared to strlcpy:
    
    * it doesn't read from memory beyond (src + size)
    * provides an easy way to check for destination buffer overflow
    * robust against asynchronous source buffer changes
    
    Since batman-adv doesn't depend on any of the previously mentioned behavior
    changes, the usage of strlcpy can simply be replaced by strscpy to silence
    checkpatch.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c7a2e77ca1da..a1146cb10919 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -943,10 +943,10 @@ static const struct net_device_ops batadv_netdev_ops = {
 static void batadv_get_drvinfo(struct net_device *dev,
 			       struct ethtool_drvinfo *info)
 {
-	strlcpy(info->driver, "B.A.T.M.A.N. advanced", sizeof(info->driver));
-	strlcpy(info->version, BATADV_SOURCE_VERSION, sizeof(info->version));
-	strlcpy(info->fw_version, "N/A", sizeof(info->fw_version));
-	strlcpy(info->bus_info, "batman", sizeof(info->bus_info));
+	strscpy(info->driver, "B.A.T.M.A.N. advanced", sizeof(info->driver));
+	strscpy(info->version, BATADV_SOURCE_VERSION, sizeof(info->version));
+	strscpy(info->fw_version, "N/A", sizeof(info->fw_version));
+	strscpy(info->bus_info, "batman", sizeof(info->bus_info));
 }
 
 /* Inspired by drivers/net/ethernet/dlink/sundance.c:1702

commit 6bc4544021f82283f0949f94494011730ecdd084
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Tue May 7 06:08:26 2019 +0200

    batman-adv: mcast: shorten multicast tt/tvlv worker spinlock section
    
    It is not necessary to hold the mla_lock spinlock during the whole
    multicast tt/tvlv worker callback. Just holding it during the checks and
    updates of the bat_priv stored multicast flags and mla_list is enough.
    
    Therefore this patch splits batadv_mcast_mla_tvlv_update() in two:
    batadv_mcast_mla_flags_get() at the beginning of the worker to gather
    and calculate the new multicast flags, which does not need any locking
    as it neither reads from nor writes to bat_priv->mcast.
    
    And batadv_mcast_mla_flags_update() at the end of the worker which
    commits the newly calculated flags and lists to bat_priv->mcast and
    therefore needs the lock.
    
    Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 499afbce44dc..c7a2e77ca1da 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -804,11 +804,6 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->distributed_arp_table, 1);
 #endif
 #ifdef CONFIG_BATMAN_ADV_MCAST
-	bat_priv->mcast.querier_ipv4.exists = false;
-	bat_priv->mcast.querier_ipv4.shadowing = false;
-	bat_priv->mcast.querier_ipv6.exists = false;
-	bat_priv->mcast.querier_ipv6.shadowing = false;
-	bat_priv->mcast.flags = BATADV_NO_FLAGS;
 	atomic_set(&bat_priv->multicast_mode, 1);
 	atomic_set(&bat_priv->multicast_fanout, 16);
 	atomic_set(&bat_priv->mcast.num_want_all_unsnoopables, 0);

commit 68a600de9afc2134aa24d0cce539b98a0acb68b1
Author: Sven Eckelmann <sven@narfation.org>
Date:   Fri May 24 20:11:17 2019 +0200

    batman-adv: Use includes instead of fwdecls
    
    While it can be slightly beneficial for the build performance to use
    forward declarations instead of includes, the handling of them together
    with changes in the included headers makes it unnecessary complicated and
    fragile. Just replace them with actual includes since some parts (hwmon,
    ..) of the kernel even request avoidance of forward declarations and net/
    is mostly not using them in *.c file.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index a7677e1d000f..499afbce44dc 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -24,6 +24,7 @@
 #include <linux/list.h>
 #include <linux/lockdep.h>
 #include <linux/netdevice.h>
+#include <linux/netlink.h>
 #include <linux/percpu.h>
 #include <linux/printk.h>
 #include <linux/random.h>

commit 32e727449c792b689c2a06a8b4cc9fef6270c5a7
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Sat Mar 23 05:47:41 2019 +0100

    batman-adv: Add multicast-to-unicast support for multiple targets
    
    With this patch multicast packets with a limited number of destinations
    (current default: 16) will be split and transmitted by the originator as
    individual unicast transmissions.
    
    Wifi broadcasts with their low bitrate are still a costly undertaking.
    In a mesh network this cost multiplies with the overall size of the mesh
    network. Therefore using multiple unicast transmissions instead of
    broadcast flooding is almost always less burdensome for the mesh
    network.
    
    The maximum amount of unicast packets can be configured via the newly
    introduced multicast_fanout parameter. If this limit is exceeded
    distribution will fall back to classic broadcast flooding.
    
    The multicast-to-unicast conversion is performed on the initial
    multicast sender node and counts on a final destination node, mesh-wide
    basis (and not next hop, neighbor node basis).
    
    Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index f8fcdd6de656..a7677e1d000f 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -197,7 +197,7 @@ static netdev_tx_t batadv_interface_tx(struct sk_buff *skb,
 	unsigned short vid;
 	u32 seqno;
 	int gw_mode;
-	enum batadv_forw_mode forw_mode;
+	enum batadv_forw_mode forw_mode = BATADV_FORW_SINGLE;
 	struct batadv_orig_node *mcast_single_orig = NULL;
 	int network_offset = ETH_HLEN;
 	__be16 proto;
@@ -305,7 +305,8 @@ static netdev_tx_t batadv_interface_tx(struct sk_buff *skb,
 			if (forw_mode == BATADV_FORW_NONE)
 				goto dropped;
 
-			if (forw_mode == BATADV_FORW_SINGLE)
+			if (forw_mode == BATADV_FORW_SINGLE ||
+			    forw_mode == BATADV_FORW_SOME)
 				do_bcast = false;
 		}
 	}
@@ -365,6 +366,8 @@ static netdev_tx_t batadv_interface_tx(struct sk_buff *skb,
 			ret = batadv_send_skb_unicast(bat_priv, skb,
 						      BATADV_UNICAST, 0,
 						      mcast_single_orig, vid);
+		} else if (forw_mode == BATADV_FORW_SOME) {
+			ret = batadv_mcast_forw_send(bat_priv, skb, vid);
 		} else {
 			if (batadv_dat_snoop_outgoing_arp_request(bat_priv,
 								  skb))
@@ -806,6 +809,7 @@ static int batadv_softif_init_late(struct net_device *dev)
 	bat_priv->mcast.querier_ipv6.shadowing = false;
 	bat_priv->mcast.flags = BATADV_NO_FLAGS;
 	atomic_set(&bat_priv->multicast_mode, 1);
+	atomic_set(&bat_priv->multicast_fanout, 16);
 	atomic_set(&bat_priv->mcast.num_want_all_unsnoopables, 0);
 	atomic_set(&bat_priv->mcast.num_want_all_ipv4, 0);
 	atomic_set(&bat_priv->mcast.num_want_all_ipv6, 0);

commit 0d5f20c42b24adffa1505ec3d4930d11dfaea82f
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Mar 3 15:52:07 2019 +0100

    batman-adv: Drop license boilerplate
    
    All files got a SPDX-License-Identifier with commit 7db7d9f369a4
    ("batman-adv: Add SPDX license identifier above copyright header"). All the
    required information about the license conditions can be found in
    LICENSES/.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 2e367230376b..f8fcdd6de656 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -2,18 +2,6 @@
 /* Copyright (C) 2007-2019  B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of version 2 of the GNU General Public
- * License as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "soft-interface.h"

commit 3313da8188cc346a205783c22c37e821b4b7016d
Merge: 50f444aa50a4 24f0a48743a2
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Feb 15 12:38:38 2019 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    The netfilter conflicts were rather simple overlapping
    changes.
    
    However, the cls_tcindex.c stuff was a bit more complex.
    
    On the 'net' side, Cong is fixing several races and memory
    leaks.  Whilst on the 'net-next' side we have Vlad adding
    the rtnl-ness support.
    
    What I've decided to do, in order to resolve this, is revert the
    conversion over to using a workqueue that Cong did, bringing us back
    to pure RCU.  I did it this way because I believe that either Cong's
    races don't apply with have Vlad did things, or Cong will have to
    implement the race fix slightly differently.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 03b967420280f01b225d9f7c46c2d9117e1bc16b
Merge: e7c2e3b57044 7e6f461efe25
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Feb 13 22:28:11 2019 -0800

    Merge tag 'batadv-next-for-davem-20190213' of git://git.open-mesh.org/linux-merge
    
    Simon Wunderlich says:
    
    ====================
    This feature/cleanup patchset includes the following patches:
    
     - fix memory leak in in batadv_dat_put_dhcp, by Martin Weinelt
    
     - fix typo, by Sven Eckelmann
    
     - netlink restructuring patch series (part 2), by Sven Eckelmann
       (19 patches)
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 4ffcbfac60642f63ae3d80891f573ba7e94a265c
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Feb 11 14:41:22 2019 -0800

    batman-adv: fix uninit-value in batadv_interface_tx()
    
    KMSAN reported batadv_interface_tx() was possibly using a
    garbage value [1]
    
    batadv_get_vid() does have a pskb_may_pull() call
    but batadv_interface_tx() does not actually make sure
    this did not fail.
    
    [1]
    BUG: KMSAN: uninit-value in batadv_interface_tx+0x908/0x1e40 net/batman-adv/soft-interface.c:231
    CPU: 0 PID: 10006 Comm: syz-executor469 Not tainted 4.20.0-rc7+ #5
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    Call Trace:
     __dump_stack lib/dump_stack.c:77 [inline]
     dump_stack+0x173/0x1d0 lib/dump_stack.c:113
     kmsan_report+0x12e/0x2a0 mm/kmsan/kmsan.c:613
     __msan_warning+0x82/0xf0 mm/kmsan/kmsan_instr.c:313
     batadv_interface_tx+0x908/0x1e40 net/batman-adv/soft-interface.c:231
     __netdev_start_xmit include/linux/netdevice.h:4356 [inline]
     netdev_start_xmit include/linux/netdevice.h:4365 [inline]
     xmit_one net/core/dev.c:3257 [inline]
     dev_hard_start_xmit+0x607/0xc40 net/core/dev.c:3273
     __dev_queue_xmit+0x2e42/0x3bc0 net/core/dev.c:3843
     dev_queue_xmit+0x4b/0x60 net/core/dev.c:3876
     packet_snd net/packet/af_packet.c:2928 [inline]
     packet_sendmsg+0x8306/0x8f30 net/packet/af_packet.c:2953
     sock_sendmsg_nosec net/socket.c:621 [inline]
     sock_sendmsg net/socket.c:631 [inline]
     __sys_sendto+0x8c4/0xac0 net/socket.c:1788
     __do_sys_sendto net/socket.c:1800 [inline]
     __se_sys_sendto+0x107/0x130 net/socket.c:1796
     __x64_sys_sendto+0x6e/0x90 net/socket.c:1796
     do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291
     entry_SYSCALL_64_after_hwframe+0x63/0xe7
    RIP: 0033:0x441889
    Code: 18 89 d0 c3 66 2e 0f 1f 84 00 00 00 00 00 0f 1f 00 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 bb 10 fc ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007ffdda6fd468 EFLAGS: 00000216 ORIG_RAX: 000000000000002c
    RAX: ffffffffffffffda RBX: 0000000000000002 RCX: 0000000000441889
    RDX: 000000000000000e RSI: 00000000200000c0 RDI: 0000000000000003
    RBP: 0000000000000003 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000216 R12: 00007ffdda6fd4c0
    R13: 00007ffdda6fd4b0 R14: 0000000000000000 R15: 0000000000000000
    
    Uninit was created at:
     kmsan_save_stack_with_flags mm/kmsan/kmsan.c:204 [inline]
     kmsan_internal_poison_shadow+0x92/0x150 mm/kmsan/kmsan.c:158
     kmsan_kmalloc+0xa6/0x130 mm/kmsan/kmsan_hooks.c:176
     kmsan_slab_alloc+0xe/0x10 mm/kmsan/kmsan_hooks.c:185
     slab_post_alloc_hook mm/slab.h:446 [inline]
     slab_alloc_node mm/slub.c:2759 [inline]
     __kmalloc_node_track_caller+0xe18/0x1030 mm/slub.c:4383
     __kmalloc_reserve net/core/skbuff.c:137 [inline]
     __alloc_skb+0x309/0xa20 net/core/skbuff.c:205
     alloc_skb include/linux/skbuff.h:998 [inline]
     alloc_skb_with_frags+0x1c7/0xac0 net/core/skbuff.c:5220
     sock_alloc_send_pskb+0xafd/0x10e0 net/core/sock.c:2083
     packet_alloc_skb net/packet/af_packet.c:2781 [inline]
     packet_snd net/packet/af_packet.c:2872 [inline]
     packet_sendmsg+0x661a/0x8f30 net/packet/af_packet.c:2953
     sock_sendmsg_nosec net/socket.c:621 [inline]
     sock_sendmsg net/socket.c:631 [inline]
     __sys_sendto+0x8c4/0xac0 net/socket.c:1788
     __do_sys_sendto net/socket.c:1800 [inline]
     __se_sys_sendto+0x107/0x130 net/socket.c:1796
     __x64_sys_sendto+0x6e/0x90 net/socket.c:1796
     do_syscall_64+0xbc/0xf0 arch/x86/entry/common.c:291
     entry_SYSCALL_64_after_hwframe+0x63/0xe7
    
    Fixes: c6c8fea29769 ("net: Add batman-adv meshing protocol")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc:     Marek Lindner <mareklindner@neomailbox.ch>
    Cc:     Simon Wunderlich <sw@simonwunderlich.de>
    Cc:     Antonio Quartulli <a@unstable.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b85ca809e509..ffc83bebfe40 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -227,6 +227,8 @@ static netdev_tx_t batadv_interface_tx(struct sk_buff *skb,
 
 	switch (ntohs(ethhdr->h_proto)) {
 	case ETH_P_8021Q:
+		if (!pskb_may_pull(skb, sizeof(*vhdr)))
+			goto dropped;
 		vhdr = vlan_eth_hdr(skb);
 
 		/* drop batman-in-batman packets to prevent loops */

commit e2d0d35b5b0ce420505e88255fd5922ed035bb8d
Author: Sven Eckelmann <sven@narfation.org>
Date:   Fri Nov 23 13:15:00 2018 +0100

    batman-adv: Add gateway mesh genl configuration
    
    The mesh/soft-interface can optimize the handling of DHCP packets. Instead
    of flooding them through the whole mesh, it can be forwarded as unicast to
    a specific gateway server. The originator which injects the packets in the
    mesh has to select (based on sel_class thresholds) a responsible gateway
    server. This is done by switching this originator to the gw_mode client.
    The servers announce their forwarding bandwidth (download/upload) when the
    gw_mode server was selected.
    
    The BATADV_CMD_SET_MESH/BATADV_CMD_GET_MESH commands allow to set/get the
    configuration of this feature using the attributes:
    
    * u8 BATADV_ATTR_GW_MODE (0 == off, 1 == client, 2 == server)
    * u32 BATADV_ATTR_GW_BANDWIDTH_DOWN (in 100 kbit/s steps)
    * u32 BATADV_ATTR_GW_BANDWIDTH_UP (in 100 kbit/s steps)
    * u32 BATADV_ATTR_GW_SEL_CLASS
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b14fb3462af7..12028c287de5 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -50,13 +50,13 @@
 #include <linux/string.h>
 #include <linux/types.h>
 #include <uapi/linux/batadv_packet.h>
+#include <uapi/linux/batman_adv.h>
 
 #include "bat_algo.h"
 #include "bridge_loop_avoidance.h"
 #include "debugfs.h"
 #include "distributed-arp-table.h"
 #include "gateway_client.h"
-#include "gateway_common.h"
 #include "hard-interface.h"
 #include "multicast.h"
 #include "network-coding.h"

commit a655fe9f194842693258f43b5382855db1c2f654
Merge: 7499a288bf1a 27b4ad621e88
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Feb 8 15:00:17 2019 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    An ipvlan bug fix in 'net' conflicted with the abstraction away
    of the IPV6 specific support in 'net-next'.
    
    Similarly, a bug fix for mlx5 in 'net' conflicted with the flow
    action conversion in 'net-next'.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 7a79d717e0817610932ce3b7b6033ea06ee1d577
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Dec 31 23:59:59 2018 +0100

    batman-adv: Update copyright years for 2019
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 943071008670..b14fb3462af7 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright (C) 2007-2018  B.A.T.M.A.N. contributors:
+/* Copyright (C) 2007-2019  B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
  *

commit 9114daa825fc3f335f9bea3313ce667090187280
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Dec 31 22:31:01 2018 +0100

    batman-adv: Force mac header to start of data on xmit
    
    The caller of ndo_start_xmit may not already have called
    skb_reset_mac_header. The returned value of skb_mac_header/eth_hdr
    therefore can be in the wrong position and even outside the current skbuff.
    This for example happens when the user binds to the device using a
    PF_PACKET-SOCK_RAW with enabled qdisc-bypass:
    
      int opt = 4;
      setsockopt(sock, SOL_PACKET, PACKET_QDISC_BYPASS, &opt, sizeof(opt));
    
    Since eth_hdr is used all over the codebase, the batadv_interface_tx
    function must always take care of resetting it.
    
    Fixes: c6c8fea29769 ("net: Add batman-adv meshing protocol")
    Reported-by: syzbot+9d7405c7faa390e60b4e@syzkaller.appspotmail.com
    Reported-by: syzbot+7d20bc3f1ddddc0f9079@syzkaller.appspotmail.com
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 5db5a0a4c959..b85ca809e509 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -221,6 +221,8 @@ static netdev_tx_t batadv_interface_tx(struct sk_buff *skb,
 
 	netif_trans_update(soft_iface);
 	vid = batadv_get_vid(skb, 0);
+
+	skb_reset_mac_header(skb);
 	ethhdr = eth_hdr(skb);
 
 	switch (ntohs(ethhdr->h_proto)) {

commit b61ec31c85756bbc898fb892555509afe709459a
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Sun Dec 30 16:52:53 2018 +0100

    batman-adv: Snoop DHCPACKs for DAT
    
    In a 1000 nodes mesh network (Freifunk Hamburg) we can still see
    30KBit/s of ARP traffic (equalling about 25% of all layer two
    specific overhead, remaining after some filtering) flooded through
    the mesh. These 30KBit/s are mainly ARP Requests from the
    gateways / DHCP servers.
    
    By snooping DHCPACKs we can learn about MAC/IP address pairs
    in the DHCP range without relying on ARP. This patch is in preparation
    to eliminate the need for mesh wide message flooding for IPv4 address
    resolution.
    
    Also this allows to quickly update a MAC/IP pair at least in the DHT when
    DHCP reassigns an IP address to a new host.
    
    Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 5db5a0a4c959..943071008670 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -212,6 +212,7 @@ static netdev_tx_t batadv_interface_tx(struct sk_buff *skb,
 	enum batadv_forw_mode forw_mode;
 	struct batadv_orig_node *mcast_single_orig = NULL;
 	int network_offset = ETH_HLEN;
+	__be16 proto;
 
 	if (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)
 		goto dropped;
@@ -223,12 +224,15 @@ static netdev_tx_t batadv_interface_tx(struct sk_buff *skb,
 	vid = batadv_get_vid(skb, 0);
 	ethhdr = eth_hdr(skb);
 
-	switch (ntohs(ethhdr->h_proto)) {
+	proto = ethhdr->h_proto;
+
+	switch (ntohs(proto)) {
 	case ETH_P_8021Q:
 		vhdr = vlan_eth_hdr(skb);
+		proto = vhdr->h_vlan_encapsulated_proto;
 
 		/* drop batman-in-batman packets to prevent loops */
-		if (vhdr->h_vlan_encapsulated_proto != htons(ETH_P_BATMAN)) {
+		if (proto != htons(ETH_P_BATMAN)) {
 			network_offset += VLAN_HLEN;
 			break;
 		}
@@ -256,6 +260,9 @@ static netdev_tx_t batadv_interface_tx(struct sk_buff *skb,
 			goto dropped;
 	}
 
+	/* Snoop address candidates from DHCPACKs for early DAT filling */
+	batadv_dat_snoop_outgoing_dhcp_ack(bat_priv, skb, proto, vid);
+
 	/* don't accept stp packets. STP does not help in meshes.
 	 * better use the bridge loop avoidance ...
 	 *

commit a06ee256e5d6f03fffbd088de9bf84035658cc5a
Merge: bd6207202db8 846e8dd47c26
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Sep 25 10:35:29 2018 -0700

    Merge ra.kernel.org:/pub/scm/linux/kernel/git/davem/net
    
    Version bump conflict in batman-adv, take what's in net-next.
    
    iavf conflict, adjustment of netdev_ops in net-next conflicting
    with poll controller method removal in net.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit a7ea49afcc888dd5aac76774767bfb90be937aad
Author: Sven Eckelmann <sven@narfation.org>
Date:   Tue Sep 11 17:22:01 2018 +0200

    batman-adv: Enable LockLess TX for softif
    
    The batadv interfaces are virtual interfaces which just tunnel the traffic
    over other ethernet compatible interfaces. It doesn't need serialization
    during the tx phase and is using RCU for most of its internal
    datastructures. Since it doesn't have actual queues which could be locked
    independently, the throughput gets significantly reduced by the extra lock
    in the core net code.
    
    8 parallel TCP connections forwarded by an IPQ4019 based hardware over
    5GHz could reach:
    
    * without LLTX: 349 Mibit/s
    * with LLTX:    563 Mibit/s
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e121c59fc1fa..2c7d95727f90 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1050,6 +1050,7 @@ static void batadv_softif_init_early(struct net_device *dev)
 	dev->needs_free_netdev = true;
 	dev->priv_destructor = batadv_softif_free;
 	dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_NETNS_LOCAL;
+	dev->features |= NETIF_F_LLTX;
 	dev->priv_flags |= IFF_NO_QUEUE;
 
 	/* can't call min_mtu, because the needed variables

commit dee222c7b20cdfff4b4d554bb4a5199572c5f28c
Author: Sven Eckelmann <sven@narfation.org>
Date:   Thu Aug 16 16:54:45 2018 +0200

    batman-adv: Move OGM rebroadcast stats to orig_ifinfo
    
    B.A.T.M.A.N. IV requires the number of rebroadcast from a neighboring
    originator. These statistics are gathered per interface which transmitted
    the OGM (and then received it again). Since an originator is not interface
    specific, a resizable array was used in each originator.
    
    This resizable array had an entry for each interface and had to be resizes
    (for all OGMs) when the number of active interface was modified. This could
    cause problems when a large number of interface is added and not enough
    continuous memory is available to allocate the array.
    
    There is already a per interface originator structure "batadv_orig_ifinfo"
    which can be used to store this information.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 1485263a348b..e121c59fc1fa 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -833,7 +833,6 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->frag_seqno, random_seqno);
 
 	bat_priv->primary_if = NULL;
-	bat_priv->num_ifaces = 0;
 
 	batadv_nc_init_bat_priv(bat_priv);
 

commit 94cb82f594ed86be303398d6dfc7640a6f1d45d4
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Aug 12 21:04:43 2018 +0200

    batman-adv: Prevent duplicated softif_vlan entry
    
    The function batadv_softif_vlan_get is responsible for adding new
    softif_vlan to the softif_vlan_list. It first checks whether the entry
    already is in the list or not. If it is, then the creation of a new entry
    is aborted.
    
    But the lock for the list is only held when the list is really modified.
    This could lead to duplicated entries because another context could create
    an entry with the same key between the check and the list manipulation.
    
    The check and the manipulation of the list must therefore be in the same
    locked code section.
    
    Fixes: 5d2c05b21337 ("batman-adv: add per VLAN interface attribute framework")
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 1485263a348b..626ddca332db 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -574,15 +574,20 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 	struct batadv_softif_vlan *vlan;
 	int err;
 
+	spin_lock_bh(&bat_priv->softif_vlan_list_lock);
+
 	vlan = batadv_softif_vlan_get(bat_priv, vid);
 	if (vlan) {
 		batadv_softif_vlan_put(vlan);
+		spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
 		return -EEXIST;
 	}
 
 	vlan = kzalloc(sizeof(*vlan), GFP_ATOMIC);
-	if (!vlan)
+	if (!vlan) {
+		spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
 		return -ENOMEM;
+	}
 
 	vlan->bat_priv = bat_priv;
 	vlan->vid = vid;
@@ -590,17 +595,23 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 
 	atomic_set(&vlan->ap_isolation, 0);
 
+	kref_get(&vlan->refcount);
+	hlist_add_head_rcu(&vlan->list, &bat_priv->softif_vlan_list);
+	spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
+
+	/* batadv_sysfs_add_vlan cannot be in the spinlock section due to the
+	 * sleeping behavior of the sysfs functions and the fs_reclaim lock
+	 */
 	err = batadv_sysfs_add_vlan(bat_priv->soft_iface, vlan);
 	if (err) {
-		kfree(vlan);
+		/* ref for the function */
+		batadv_softif_vlan_put(vlan);
+
+		/* ref for the list */
+		batadv_softif_vlan_put(vlan);
 		return err;
 	}
 
-	spin_lock_bh(&bat_priv->softif_vlan_list_lock);
-	kref_get(&vlan->refcount);
-	hlist_add_head_rcu(&vlan->list, &bat_priv->softif_vlan_list);
-	spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
-
 	/* add a new TT local entry. This one will be marked with the NOPURGE
 	 * flag
 	 */

commit 6bf9e4d39a582a4beea1844d6955cb2ebc979a67
Author: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
Date:   Tue Apr 24 15:18:46 2018 +0200

    batman-adv: fix batadv_interface_tx()'s return type
    
    The method ndo_start_xmit() is defined as returning an 'netdev_tx_t',
    which is a typedef for an enum type, but the implementation in this
    driver returns an 'int'.
    
    Fix this by returning 'netdev_tx_t' in this driver too.
    
    Signed-off-by: Luc Van Oostenryck <luc.vanoostenryck@gmail.com>
    [sven@narfation.org: fixed alignment]
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 67065e35de51..1485263a348b 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -188,8 +188,8 @@ static void batadv_interface_set_rx_mode(struct net_device *dev)
 {
 }
 
-static int batadv_interface_tx(struct sk_buff *skb,
-			       struct net_device *soft_iface)
+static netdev_tx_t batadv_interface_tx(struct sk_buff *skb,
+				       struct net_device *soft_iface)
 {
 	struct ethhdr *ethhdr;
 	struct batadv_priv *bat_priv = netdev_priv(soft_iface);

commit f26e4e98b15322522bc6221325bf14cbead65d1b
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Sun Mar 25 00:32:04 2018 +0100

    batman-adv: Avoid old nodes disabling multicast optimizations completely
    
    Instead of disabling multicast optimizations mesh-wide once a node with
    no multicast optimizations capabilities joins the mesh, do the
    following:
    
    Just insert such nodes into the WANT_ALL_IPV4/IPV6 lists. This is
    sufficient to avoid multicast packet loss to such unsupportive nodes.
    
    Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index edeffcb9f3a2..67065e35de51 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -796,7 +796,6 @@ static int batadv_softif_init_late(struct net_device *dev)
 	bat_priv->mcast.querier_ipv6.shadowing = false;
 	bat_priv->mcast.flags = BATADV_NO_FLAGS;
 	atomic_set(&bat_priv->multicast_mode, 1);
-	atomic_set(&bat_priv->mcast.num_disabled, 0);
 	atomic_set(&bat_priv->mcast.num_want_all_unsnoopables, 0);
 	atomic_set(&bat_priv->mcast.num_want_all_ipv4, 0);
 	atomic_set(&bat_priv->mcast.num_want_all_ipv6, 0);

commit 0f3e9c97eb5a97972b0c0076a5cc01bb142f8e70
Merge: ef3f6c256f0b ce380619fab9
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Mar 6 00:53:44 2018 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    All of the conflicts were cases of overlapping changes.
    
    In net/core/devlink.c, we have to make care that the
    resouce size_params have become a struct member rather
    than a pointer to such an object.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 6b1aea8cf2c8618146edaf6b35775ab55f7cafe5
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Jan 1 00:00:00 2018 +0100

    batman-adv: Update copyright years for 2018
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 900c5ce21cd4..c95e2b2677fd 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,5 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
-/* Copyright (C) 2007-2017  B.A.T.M.A.N. contributors:
+/* Copyright (C) 2007-2018  B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
  *

commit abd6360591d3f8259f41c34e31ac4826dfe621b8
Author: Matthias Schiffer <mschiffer@universe-factory.net>
Date:   Tue Jan 23 10:59:49 2018 +0100

    batman-adv: fix packet checksum in receive path
    
    eth_type_trans() internally calls skb_pull(), which does not adjust the
    skb checksum; skb_postpull_rcsum() is necessary to avoid log spam of the
    form "bat0: hw csum failure" when packets with CHECKSUM_COMPLETE are
    received.
    
    Note that in usual setups, packets don't reach batman-adv with
    CHECKSUM_COMPLETE (I assume NICs bail out of checksumming when they see
    batadv's ethtype?), which is why the log messages do not occur on every
    system using batman-adv. I could reproduce this issue by stacking
    batman-adv on top of a VXLAN interface.
    
    Fixes: c6c8fea29769 ("net: Add batman-adv meshing protocol")
    Tested-by: Maximilian Wilhelm <max@sdn.clinic>
    Signed-off-by: Matthias Schiffer <mschiffer@universe-factory.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 900c5ce21cd4..367a81fb785f 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -459,13 +459,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 
 	/* skb->dev & skb->pkt_type are set here */
 	skb->protocol = eth_type_trans(skb, soft_iface);
-
-	/* should not be necessary anymore as we use skb_pull_rcsum()
-	 * TODO: please verify this and remove this TODO
-	 * -- Dec 21st 2009, Simon Wunderlich
-	 */
-
-	/* skb->ip_summed = CHECKSUM_UNNECESSARY; */
+	skb_postpull_rcsum(skb, eth_hdr(skb), ETH_HLEN);
 
 	batadv_inc_counter(bat_priv, BATADV_CNT_RX);
 	batadv_add_counter(bat_priv, BATADV_CNT_RX_BYTES,

commit fec149f5d3234c037ec761d1db4cc8c0550e9964
Author: Sven Eckelmann <sven.eckelmann@openmesh.com>
Date:   Thu Dec 21 10:17:41 2017 +0100

    batman-adv: Convert packet.h to uapi header
    
    The header file is used by different userspace programs to inject packets
    or to decode sniffed packets. It should therefore be available to them as
    userspace header.
    
    Also other components in the kernel (like the flow dissector) require
    access to the packet definitions to be able to decode ETH_P_BATMAN ethernet
    packets.
    
    Signed-off-by: Sven Eckelmann <sven.eckelmann@openmesh.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 1eb5555c5fe4..900c5ce21cd4 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -49,6 +49,7 @@
 #include <linux/stddef.h>
 #include <linux/string.h>
 #include <linux/types.h>
+#include <uapi/linux/batadv_packet.h>
 
 #include "bat_algo.h"
 #include "bridge_loop_avoidance.h"
@@ -60,7 +61,6 @@
 #include "multicast.h"
 #include "network-coding.h"
 #include "originator.h"
-#include "packet.h"
 #include "send.h"
 #include "sysfs.h"
 #include "translation-table.h"

commit ff15c27c97303fbe5abc49c25c73ea299ab72d31
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Dec 2 19:51:53 2017 +0100

    batman-adv: Add kernel-doc to externally visible functions
    
    According to the kernel-doc documentation, externally visible functions
    should be documented. This refers to all all non-static function which can
    (and will) be used by functions in other sources files.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 9b66e0edc741..1eb5555c5fe4 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -65,6 +65,13 @@
 #include "sysfs.h"
 #include "translation-table.h"
 
+/**
+ * batadv_skb_head_push() - Increase header size and move (push) head pointer
+ * @skb: packet buffer which should be modified
+ * @len: number of bytes to add
+ *
+ * Return: 0 on success or negative error number in case of failure
+ */
 int batadv_skb_head_push(struct sk_buff *skb, unsigned int len)
 {
 	int result;
@@ -1064,6 +1071,13 @@ static void batadv_softif_init_early(struct net_device *dev)
 	dev->ethtool_ops = &batadv_ethtool_ops;
 }
 
+/**
+ * batadv_softif_create() - Create and register soft interface
+ * @net: the applicable net namespace
+ * @name: name of the new soft interface
+ *
+ * Return: newly allocated soft_interface, NULL on errors
+ */
 struct net_device *batadv_softif_create(struct net *net, const char *name)
 {
 	struct net_device *soft_iface;
@@ -1141,6 +1155,12 @@ static void batadv_softif_destroy_netlink(struct net_device *soft_iface,
 	unregister_netdevice_queue(soft_iface, head);
 }
 
+/**
+ * batadv_softif_is_valid() - Check whether device is a batadv soft interface
+ * @net_dev: device which should be checked
+ *
+ * Return: true when net_dev is a batman-adv interface, false otherwise
+ */
 bool batadv_softif_is_valid(const struct net_device *net_dev)
 {
 	if (net_dev->netdev_ops->ndo_start_xmit == batadv_interface_tx)

commit 7e9a8c2ce7c5f8745c003e2ba4758c21c38a0419
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Dec 2 19:51:47 2017 +0100

    batman-adv: Use parentheses in function kernel-doc
    
    The documentation describing kernel-doc comments for functions ("How to
    format kernel-doc comments") uses parentheses at the end of the function
    name. Using this format allows to use a consistent style when adding
    documentation to a function and when referencing this function in a
    different kernel-doc section.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index ba8fd06eee7e..9b66e0edc741 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -97,7 +97,7 @@ static int batadv_interface_release(struct net_device *dev)
 }
 
 /**
- * batadv_sum_counter - Sum the cpu-local counters for index 'idx'
+ * batadv_sum_counter() - Sum the cpu-local counters for index 'idx'
  * @bat_priv: the bat priv with all the soft interface information
  * @idx: index of counter to sum up
  *
@@ -170,7 +170,7 @@ static int batadv_interface_change_mtu(struct net_device *dev, int new_mtu)
 }
 
 /**
- * batadv_interface_set_rx_mode - set the rx mode of a device
+ * batadv_interface_set_rx_mode() - set the rx mode of a device
  * @dev: registered network device to modify
  *
  * We do not actually need to set any rx filters for the virtual batman
@@ -390,7 +390,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 }
 
 /**
- * batadv_interface_rx - receive ethernet frame on local batman-adv interface
+ * batadv_interface_rx() - receive ethernet frame on local batman-adv interface
  * @soft_iface: local interface which will receive the ethernet frame
  * @skb: ethernet frame for @soft_iface
  * @hdr_size: size of already parsed batman-adv header
@@ -502,8 +502,8 @@ void batadv_interface_rx(struct net_device *soft_iface,
 }
 
 /**
- * batadv_softif_vlan_release - release vlan from lists and queue for free after
- *  rcu grace period
+ * batadv_softif_vlan_release() - release vlan from lists and queue for free
+ *  after rcu grace period
  * @ref: kref pointer of the vlan object
  */
 static void batadv_softif_vlan_release(struct kref *ref)
@@ -520,7 +520,7 @@ static void batadv_softif_vlan_release(struct kref *ref)
 }
 
 /**
- * batadv_softif_vlan_put - decrease the vlan object refcounter and
+ * batadv_softif_vlan_put() - decrease the vlan object refcounter and
  *  possibly release it
  * @vlan: the vlan object to release
  */
@@ -533,7 +533,7 @@ void batadv_softif_vlan_put(struct batadv_softif_vlan *vlan)
 }
 
 /**
- * batadv_softif_vlan_get - get the vlan object for a specific vid
+ * batadv_softif_vlan_get() - get the vlan object for a specific vid
  * @bat_priv: the bat priv with all the soft interface information
  * @vid: the identifier of the vlan object to retrieve
  *
@@ -562,7 +562,7 @@ struct batadv_softif_vlan *batadv_softif_vlan_get(struct batadv_priv *bat_priv,
 }
 
 /**
- * batadv_softif_create_vlan - allocate the needed resources for a new vlan
+ * batadv_softif_create_vlan() - allocate the needed resources for a new vlan
  * @bat_priv: the bat priv with all the soft interface information
  * @vid: the VLAN identifier
  *
@@ -614,7 +614,7 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 }
 
 /**
- * batadv_softif_destroy_vlan - remove and destroy a softif_vlan object
+ * batadv_softif_destroy_vlan() - remove and destroy a softif_vlan object
  * @bat_priv: the bat priv with all the soft interface information
  * @vlan: the object to remove
  */
@@ -632,7 +632,7 @@ static void batadv_softif_destroy_vlan(struct batadv_priv *bat_priv,
 }
 
 /**
- * batadv_interface_add_vid - ndo_add_vid API implementation
+ * batadv_interface_add_vid() - ndo_add_vid API implementation
  * @dev: the netdev of the mesh interface
  * @proto: protocol of the the vlan id
  * @vid: identifier of the new vlan
@@ -690,7 +690,7 @@ static int batadv_interface_add_vid(struct net_device *dev, __be16 proto,
 }
 
 /**
- * batadv_interface_kill_vid - ndo_kill_vid API implementation
+ * batadv_interface_kill_vid() - ndo_kill_vid API implementation
  * @dev: the netdev of the mesh interface
  * @proto: protocol of the the vlan id
  * @vid: identifier of the deleted vlan
@@ -733,7 +733,7 @@ static struct lock_class_key batadv_netdev_xmit_lock_key;
 static struct lock_class_key batadv_netdev_addr_lock_key;
 
 /**
- * batadv_set_lockdep_class_one - Set lockdep class for a single tx queue
+ * batadv_set_lockdep_class_one() - Set lockdep class for a single tx queue
  * @dev: device which owns the tx queue
  * @txq: tx queue to modify
  * @_unused: always NULL
@@ -746,7 +746,7 @@ static void batadv_set_lockdep_class_one(struct net_device *dev,
 }
 
 /**
- * batadv_set_lockdep_class - Set txq and addr_list lockdep class
+ * batadv_set_lockdep_class() - Set txq and addr_list lockdep class
  * @dev: network device to modify
  */
 static void batadv_set_lockdep_class(struct net_device *dev)
@@ -756,7 +756,7 @@ static void batadv_set_lockdep_class(struct net_device *dev)
 }
 
 /**
- * batadv_softif_init_late - late stage initialization of soft interface
+ * batadv_softif_init_late() - late stage initialization of soft interface
  * @dev: registered network device to modify
  *
  * Return: error code on failures
@@ -861,7 +861,7 @@ static int batadv_softif_init_late(struct net_device *dev)
 }
 
 /**
- * batadv_softif_slave_add - Add a slave interface to a batadv_soft_interface
+ * batadv_softif_slave_add() - Add a slave interface to a batadv_soft_interface
  * @dev: batadv_soft_interface used as master interface
  * @slave_dev: net_device which should become the slave interface
  * @extack: extended ACK report struct
@@ -889,7 +889,7 @@ static int batadv_softif_slave_add(struct net_device *dev,
 }
 
 /**
- * batadv_softif_slave_del - Delete a slave iface from a batadv_soft_interface
+ * batadv_softif_slave_del() - Delete a slave iface from a batadv_soft_interface
  * @dev: batadv_soft_interface used as master interface
  * @slave_dev: net_device which should be removed from the master interface
  *
@@ -1024,7 +1024,7 @@ static const struct ethtool_ops batadv_ethtool_ops = {
 };
 
 /**
- * batadv_softif_free - Deconstructor of batadv_soft_interface
+ * batadv_softif_free() - Deconstructor of batadv_soft_interface
  * @dev: Device to cleanup and remove
  */
 static void batadv_softif_free(struct net_device *dev)
@@ -1040,7 +1040,7 @@ static void batadv_softif_free(struct net_device *dev)
 }
 
 /**
- * batadv_softif_init_early - early stage initialization of soft interface
+ * batadv_softif_init_early() - early stage initialization of soft interface
  * @dev: registered network device to modify
  */
 static void batadv_softif_init_early(struct net_device *dev)
@@ -1090,7 +1090,7 @@ struct net_device *batadv_softif_create(struct net *net, const char *name)
 }
 
 /**
- * batadv_softif_destroy_sysfs - deletion of batadv_soft_interface via sysfs
+ * batadv_softif_destroy_sysfs() - deletion of batadv_soft_interface via sysfs
  * @soft_iface: the to-be-removed batman-adv interface
  */
 void batadv_softif_destroy_sysfs(struct net_device *soft_iface)
@@ -1112,7 +1112,8 @@ void batadv_softif_destroy_sysfs(struct net_device *soft_iface)
 }
 
 /**
- * batadv_softif_destroy_netlink - deletion of batadv_soft_interface via netlink
+ * batadv_softif_destroy_netlink() - deletion of batadv_soft_interface via
+ *  netlink
  * @soft_iface: the to-be-removed batman-adv interface
  * @head: list pointer
  */

commit b92b94ac732f5c83c60be2825d8b5cec4dc469d3
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Nov 19 17:12:02 2017 +0100

    batman-adv: include gfp.h for GFP_* defines
    
    The linux/gfp.h provides the GFP_ATOMIC and GFP_KERNEL define. It should
    therefore be included instead of linux/fs.h.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e543024f98ef..ba8fd06eee7e 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -27,7 +27,7 @@
 #include <linux/errno.h>
 #include <linux/etherdevice.h>
 #include <linux/ethtool.h>
-#include <linux/fs.h>
+#include <linux/gfp.h>
 #include <linux/if_ether.h>
 #include <linux/if_vlan.h>
 #include <linux/jiffies.h>

commit 7db7d9f369a47e1a46f93c320b45cb89e81723e7
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Nov 19 15:05:11 2017 +0100

    batman-adv: Add SPDX license identifier above copyright header
    
    The "Linux kernel licensing rules" require that each file has a SPDX
    license identifier as first line (and sometimes as second line).
    
    The FSFE REUSE practices [1] would also require the same tags but have no
    restrictions on the placement in the source file. Using the "Linux kernel
    licensing rules" is therefore also fulfilling the FSFE REUSE practices
    requirements at the same time.
    
    [1] https://reuse.software/practices/
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 9f673cdfecf8..e543024f98ef 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /* Copyright (C) 2007-2017  B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich

commit bad5680b5052f9d3008a8cfcc0b34ba0da08401d
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Oct 7 14:21:22 2017 +0200

    batman-adv: Add missing kerneldoc for extack
    
    The parameter extack was added to batadv_softif_slave_add without adding
    the kernel-doc for it. This caused kernel-doc warnings.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Acked-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 543d2c3e0f0d..9f673cdfecf8 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -863,6 +863,7 @@ static int batadv_softif_init_late(struct net_device *dev)
  * batadv_softif_slave_add - Add a slave interface to a batadv_soft_interface
  * @dev: batadv_soft_interface used as master interface
  * @slave_dev: net_device which should become the slave interface
+ * @extack: extended ACK report struct
  *
  * Return: 0 if successful or error otherwise.
  */

commit 4bc4e64c2cfdafa6b8ecdcc5edf10cc1a147587f
Merge: d2746fe5380e 706cc9f51d9a
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Oct 6 10:12:52 2017 -0700

    Merge tag 'batadv-next-for-davem-20171006' of git://git.open-mesh.org/linux-merge
    
    Simon Wunderlich says:
    
    ====================
    This cleanup patchset includes the following patches:
    
     - bump version strings, by Simon Wunderlich
    
     - Cleanup patches to make checkpatch happy, by Sven Eckelmann (3 patches)
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 33eaf2a6eb48ebf00374aaaf4b1b43f9950dcbe4
Author: David Ahern <dsahern@gmail.com>
Date:   Wed Oct 4 17:48:46 2017 -0700

    net: Add extack to ndo_add_slave
    
    Pass extack to do_set_master and down to ndo_add_slave
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c2c986746d0b..e7d5fbb6ad53 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -867,7 +867,8 @@ static int batadv_softif_init_late(struct net_device *dev)
  * Return: 0 if successful or error otherwise.
  */
 static int batadv_softif_slave_add(struct net_device *dev,
-				   struct net_device *slave_dev)
+				   struct net_device *slave_dev,
+				   struct netlink_ext_ack *extack)
 {
 	struct batadv_hard_iface *hard_iface;
 	struct net *net = dev_net(dev);

commit 48915aed60c9615e5eaa0f1683640635dade788e
Author: Sven Eckelmann <sven@narfation.org>
Date:   Thu Sep 28 17:16:51 2017 +0200

    batman-adv: Fix "line over 80 characters" checkpatch warning
    
    Fixes: 242c1a28eb61 ("net: Remove useless function skb_header_release")
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 7c8288245f80..3af4b0b29b23 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -69,8 +69,8 @@ int batadv_skb_head_push(struct sk_buff *skb, unsigned int len)
 	int result;
 
 	/* TODO: We must check if we can release all references to non-payload
-	 * data using __skb_header_release in our skbs to allow skb_cow_header to
-	 * work optimally. This means that those skbs are not allowed to read
+	 * data using __skb_header_release in our skbs to allow skb_cow_header
+	 * to work optimally. This means that those skbs are not allowed to read
 	 * or write any data which is before the current position of skb->data
 	 * after that call and thus allow other skbs with the same data buffer
 	 * to write freely in that area.

commit 825ffe1f7b875127bc03faffec0ecfb05906650a
Author: Sven Eckelmann <sven@narfation.org>
Date:   Wed Aug 23 21:52:13 2017 +0200

    batman-adv: Remove unnecessary parentheses
    
    checkpatch introduced with commit 63b7c73ec86b ("checkpatch: add --strict
    check for ifs with unnecessary parentheses") an additional test which
    identifies some unnecessary parentheses.
    
    Remove these unnecessary parentheses to avoid the warnings and to unify the
    coding style slightly more.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c2c986746d0b..7c8288245f80 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -160,7 +160,7 @@ static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 static int batadv_interface_change_mtu(struct net_device *dev, int new_mtu)
 {
 	/* check ranges */
-	if ((new_mtu < 68) || (new_mtu > batadv_hardif_min_mtu(dev)))
+	if (new_mtu < 68 || new_mtu > batadv_hardif_min_mtu(dev))
 		return -EINVAL;
 
 	dev->mtu = new_mtu;

commit 242c1a28eb61cb34974e8aa05235d84355940a8a
Author: Gao Feng <gfree.wind@vip.163.com>
Date:   Fri Sep 22 10:25:22 2017 +0800

    net: Remove useless function skb_header_release
    
    There is no one which would invokes the function skb_header_release.
    So just remove it now.
    
    Signed-off-by: Gao Feng <gfree.wind@vip.163.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 10f7edfb176e..c2c986746d0b 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -69,7 +69,7 @@ int batadv_skb_head_push(struct sk_buff *skb, unsigned int len)
 	int result;
 
 	/* TODO: We must check if we can release all references to non-payload
-	 * data using skb_header_release in our skbs to allow skb_cow_header to
+	 * data using __skb_header_release in our skbs to allow skb_cow_header to
 	 * work optimally. This means that those skbs are not allowed to read
 	 * or write any data which is before the current position of skb->data
 	 * after that call and thus allow other skbs with the same data buffer

commit cf124db566e6b036b8bcbe8decbed740bdfac8c6
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 8 12:52:56 2017 -0400

    net: Fix inconsistent teardown and release of private netdev state.
    
    Network devices can allocate reasources and private memory using
    netdev_ops->ndo_init().  However, the release of these resources
    can occur in one of two different places.
    
    Either netdev_ops->ndo_uninit() or netdev->destructor().
    
    The decision of which operation frees the resources depends upon
    whether it is necessary for all netdev refs to be released before it
    is safe to perform the freeing.
    
    netdev_ops->ndo_uninit() presumably can occur right after the
    NETDEV_UNREGISTER notifier completes and the unicast and multicast
    address lists are flushed.
    
    netdev->destructor(), on the other hand, does not run until the
    netdev references all go away.
    
    Further complicating the situation is that netdev->destructor()
    almost universally does also a free_netdev().
    
    This creates a problem for the logic in register_netdevice().
    Because all callers of register_netdevice() manage the freeing
    of the netdev, and invoke free_netdev(dev) if register_netdevice()
    fails.
    
    If netdev_ops->ndo_init() succeeds, but something else fails inside
    of register_netdevice(), it does call ndo_ops->ndo_uninit().  But
    it is not able to invoke netdev->destructor().
    
    This is because netdev->destructor() will do a free_netdev() and
    then the caller of register_netdevice() will do the same.
    
    However, this means that the resources that would normally be released
    by netdev->destructor() will not be.
    
    Over the years drivers have added local hacks to deal with this, by
    invoking their destructor parts by hand when register_netdevice()
    fails.
    
    Many drivers do not try to deal with this, and instead we have leaks.
    
    Let's close this hole by formalizing the distinction between what
    private things need to be freed up by netdev->destructor() and whether
    the driver needs unregister_netdevice() to perform the free_netdev().
    
    netdev->priv_destructor() performs all actions to free up the private
    resources that used to be freed by netdev->destructor(), except for
    free_netdev().
    
    netdev->needs_free_netdev is a boolean that indicates whether
    free_netdev() should be done at the end of unregister_netdevice().
    
    Now, register_netdevice() can sanely release all resources after
    ndo_ops->ndo_init() succeeds, by invoking both ndo_ops->ndo_uninit()
    and netdev->priv_destructor().
    
    And at the end of unregister_netdevice(), we invoke
    netdev->priv_destructor() and optionally call free_netdev().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b25789abf7b9..10f7edfb176e 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1034,8 +1034,6 @@ static void batadv_softif_free(struct net_device *dev)
 	 * netdev and its private data (bat_priv)
 	 */
 	rcu_barrier();
-
-	free_netdev(dev);
 }
 
 /**
@@ -1047,7 +1045,8 @@ static void batadv_softif_init_early(struct net_device *dev)
 	ether_setup(dev);
 
 	dev->netdev_ops = &batadv_netdev_ops;
-	dev->destructor = batadv_softif_free;
+	dev->needs_free_netdev = true;
+	dev->priv_destructor = batadv_softif_free;
 	dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_NETNS_LOCAL;
 	dev->priv_flags |= IFF_NO_QUEUE;
 

commit bd414860440eebc8a7eb54be94c97e6ed09bb402
Merge: 54280168f3d9 ab044f8e3eaf
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Apr 6 14:37:50 2017 -0700

    Merge tag 'batadv-next-for-davem-20170406' of git://git.open-mesh.org/linux-merge
    
    Simon Wunderlich says:
    
    ====================
    This feature/cleanup patchset includes the following patches:
    
     - bump version strings, by Simon Wunderlich
    
     - Code and Style cleanups, by Sven Eckelmann (5 patches)
    
     - Remove an unneccessary memset, by Tobias Klauser
    
     - DAT and BLA optimizations for various corner cases, by Andreas Pape
       (5 patches)
    
     - forward/rebroadcast packet restructuring, by Linus Luessing
       (2 patches)
    
     - ethtool cleanup and remove unncessary code, by Sven Eckelmann
       (4 patches)
    
     - use net_device_stats from net_device instead of private copy,
       by Tobias Klauser
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ab044f8e3eaf84c4cc95d7606fadfdfa006dc8ec
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Apr 5 13:46:31 2017 +0200

    batman-adv: Use net_device_stats from struct net_device
    
    Instead of using a private copy of struct net_device_stats in struct
    batadv_priv, use stats from struct net_device.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index f33bee08bd99..b223d3cacbae 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -118,7 +118,7 @@ static u64 batadv_sum_counter(struct batadv_priv *bat_priv,  size_t idx)
 static struct net_device_stats *batadv_interface_stats(struct net_device *dev)
 {
 	struct batadv_priv *bat_priv = netdev_priv(dev);
-	struct net_device_stats *stats = &bat_priv->stats;
+	struct net_device_stats *stats = &dev->stats;
 
 	stats->tx_packets = batadv_sum_counter(bat_priv, BATADV_CNT_TX);
 	stats->tx_bytes = batadv_sum_counter(bat_priv, BATADV_CNT_TX_BYTES);

commit 5405e19e705909bba1a879174ffe93e241455426
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Apr 1 14:47:06 2017 +0200

    batman-adv: Group ethtool related code together
    
    The ethtool code was spread in soft-interface.c. This makes reading the
    code and working on it unnecessary complicated. Having everything in a
    common place next to the other code which references it, makes it slightly
    easier.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Acked-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 6f22b1283c92..f33bee08bd99 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -64,21 +64,6 @@
 #include "sysfs.h"
 #include "translation-table.h"
 
-static void batadv_get_drvinfo(struct net_device *dev,
-			       struct ethtool_drvinfo *info);
-static void batadv_get_strings(struct net_device *dev, u32 stringset, u8 *data);
-static void batadv_get_ethtool_stats(struct net_device *dev,
-				     struct ethtool_stats *stats, u64 *data);
-static int batadv_get_sset_count(struct net_device *dev, int stringset);
-
-static const struct ethtool_ops batadv_ethtool_ops = {
-	.get_drvinfo = batadv_get_drvinfo,
-	.get_link = ethtool_op_get_link,
-	.get_strings = batadv_get_strings,
-	.get_ethtool_stats = batadv_get_ethtool_stats,
-	.get_sset_count = batadv_get_sset_count,
-};
-
 int batadv_skb_head_push(struct sk_buff *skb, unsigned int len)
 {
 	int result;
@@ -944,6 +929,98 @@ static const struct net_device_ops batadv_netdev_ops = {
 	.ndo_del_slave = batadv_softif_slave_del,
 };
 
+static void batadv_get_drvinfo(struct net_device *dev,
+			       struct ethtool_drvinfo *info)
+{
+	strlcpy(info->driver, "B.A.T.M.A.N. advanced", sizeof(info->driver));
+	strlcpy(info->version, BATADV_SOURCE_VERSION, sizeof(info->version));
+	strlcpy(info->fw_version, "N/A", sizeof(info->fw_version));
+	strlcpy(info->bus_info, "batman", sizeof(info->bus_info));
+}
+
+/* Inspired by drivers/net/ethernet/dlink/sundance.c:1702
+ * Declare each description string in struct.name[] to get fixed sized buffer
+ * and compile time checking for strings longer than ETH_GSTRING_LEN.
+ */
+static const struct {
+	const char name[ETH_GSTRING_LEN];
+} batadv_counters_strings[] = {
+	{ "tx" },
+	{ "tx_bytes" },
+	{ "tx_dropped" },
+	{ "rx" },
+	{ "rx_bytes" },
+	{ "forward" },
+	{ "forward_bytes" },
+	{ "mgmt_tx" },
+	{ "mgmt_tx_bytes" },
+	{ "mgmt_rx" },
+	{ "mgmt_rx_bytes" },
+	{ "frag_tx" },
+	{ "frag_tx_bytes" },
+	{ "frag_rx" },
+	{ "frag_rx_bytes" },
+	{ "frag_fwd" },
+	{ "frag_fwd_bytes" },
+	{ "tt_request_tx" },
+	{ "tt_request_rx" },
+	{ "tt_response_tx" },
+	{ "tt_response_rx" },
+	{ "tt_roam_adv_tx" },
+	{ "tt_roam_adv_rx" },
+#ifdef CONFIG_BATMAN_ADV_DAT
+	{ "dat_get_tx" },
+	{ "dat_get_rx" },
+	{ "dat_put_tx" },
+	{ "dat_put_rx" },
+	{ "dat_cached_reply_tx" },
+#endif
+#ifdef CONFIG_BATMAN_ADV_NC
+	{ "nc_code" },
+	{ "nc_code_bytes" },
+	{ "nc_recode" },
+	{ "nc_recode_bytes" },
+	{ "nc_buffer" },
+	{ "nc_decode" },
+	{ "nc_decode_bytes" },
+	{ "nc_decode_failed" },
+	{ "nc_sniffed" },
+#endif
+};
+
+static void batadv_get_strings(struct net_device *dev, u32 stringset, u8 *data)
+{
+	if (stringset == ETH_SS_STATS)
+		memcpy(data, batadv_counters_strings,
+		       sizeof(batadv_counters_strings));
+}
+
+static void batadv_get_ethtool_stats(struct net_device *dev,
+				     struct ethtool_stats *stats, u64 *data)
+{
+	struct batadv_priv *bat_priv = netdev_priv(dev);
+	int i;
+
+	for (i = 0; i < BATADV_CNT_NUM; i++)
+		data[i] = batadv_sum_counter(bat_priv, i);
+}
+
+static int batadv_get_sset_count(struct net_device *dev, int stringset)
+{
+	if (stringset == ETH_SS_STATS)
+		return BATADV_CNT_NUM;
+
+	return -EOPNOTSUPP;
+}
+
+static const struct ethtool_ops batadv_ethtool_ops = {
+	.get_drvinfo = batadv_get_drvinfo,
+	.get_link = ethtool_op_get_link,
+	.get_strings = batadv_get_strings,
+	.get_ethtool_stats = batadv_get_ethtool_stats,
+	.get_sset_count = batadv_get_sset_count,
+};
+
 /**
  * batadv_softif_free - Deconstructor of batadv_soft_interface
  * @dev: Device to cleanup and remove
@@ -1076,87 +1153,3 @@ struct rtnl_link_ops batadv_link_ops __read_mostly = {
 	.setup		= batadv_softif_init_early,
 	.dellink	= batadv_softif_destroy_netlink,
 };
-
-static void batadv_get_drvinfo(struct net_device *dev,
-			       struct ethtool_drvinfo *info)
-{
-	strlcpy(info->driver, "B.A.T.M.A.N. advanced", sizeof(info->driver));
-	strlcpy(info->version, BATADV_SOURCE_VERSION, sizeof(info->version));
-	strlcpy(info->fw_version, "N/A", sizeof(info->fw_version));
-	strlcpy(info->bus_info, "batman", sizeof(info->bus_info));
-}
-
-/* Inspired by drivers/net/ethernet/dlink/sundance.c:1702
- * Declare each description string in struct.name[] to get fixed sized buffer
- * and compile time checking for strings longer than ETH_GSTRING_LEN.
- */
-static const struct {
-	const char name[ETH_GSTRING_LEN];
-} batadv_counters_strings[] = {
-	{ "tx" },
-	{ "tx_bytes" },
-	{ "tx_dropped" },
-	{ "rx" },
-	{ "rx_bytes" },
-	{ "forward" },
-	{ "forward_bytes" },
-	{ "mgmt_tx" },
-	{ "mgmt_tx_bytes" },
-	{ "mgmt_rx" },
-	{ "mgmt_rx_bytes" },
-	{ "frag_tx" },
-	{ "frag_tx_bytes" },
-	{ "frag_rx" },
-	{ "frag_rx_bytes" },
-	{ "frag_fwd" },
-	{ "frag_fwd_bytes" },
-	{ "tt_request_tx" },
-	{ "tt_request_rx" },
-	{ "tt_response_tx" },
-	{ "tt_response_rx" },
-	{ "tt_roam_adv_tx" },
-	{ "tt_roam_adv_rx" },
-#ifdef CONFIG_BATMAN_ADV_DAT
-	{ "dat_get_tx" },
-	{ "dat_get_rx" },
-	{ "dat_put_tx" },
-	{ "dat_put_rx" },
-	{ "dat_cached_reply_tx" },
-#endif
-#ifdef CONFIG_BATMAN_ADV_NC
-	{ "nc_code" },
-	{ "nc_code_bytes" },
-	{ "nc_recode" },
-	{ "nc_recode_bytes" },
-	{ "nc_buffer" },
-	{ "nc_decode" },
-	{ "nc_decode_bytes" },
-	{ "nc_decode_failed" },
-	{ "nc_sniffed" },
-#endif
-};
-
-static void batadv_get_strings(struct net_device *dev, u32 stringset, u8 *data)
-{
-	if (stringset == ETH_SS_STATS)
-		memcpy(data, batadv_counters_strings,
-		       sizeof(batadv_counters_strings));
-}
-
-static void batadv_get_ethtool_stats(struct net_device *dev,
-				     struct ethtool_stats *stats, u64 *data)
-{
-	struct batadv_priv *bat_priv = netdev_priv(dev);
-	int i;
-
-	for (i = 0; i < BATADV_CNT_NUM; i++)
-		data[i] = batadv_sum_counter(bat_priv, i);
-}
-
-static int batadv_get_sset_count(struct net_device *dev, int stringset)
-{
-	if (stringset == ETH_SS_STATS)
-		return BATADV_CNT_NUM;
-
-	return -EOPNOTSUPP;
-}

commit e2790a4b275d52e332e0ad71b5f2eff53fe21805
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Apr 1 14:47:05 2017 +0200

    batman-adv: Remove ethtool .get_settings stub
    
    The .get_settings function pointer and the related API was deprecated.
    Fortunately, batman-adv is a virtual interface and never provided any
    useful information via .get_settings. The stub can therefore be
    removed.
    
    This also avoids that incorrect information is shown in ethtool about the
    batadv interface.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Acked-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 3e0ee2afb814..6f22b1283c92 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -64,7 +64,6 @@
 #include "sysfs.h"
 #include "translation-table.h"
 
-static int batadv_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);
 static void batadv_get_drvinfo(struct net_device *dev,
 			       struct ethtool_drvinfo *info);
 static void batadv_get_strings(struct net_device *dev, u32 stringset, u8 *data);
@@ -73,7 +72,6 @@ static void batadv_get_ethtool_stats(struct net_device *dev,
 static int batadv_get_sset_count(struct net_device *dev, int stringset);
 
 static const struct ethtool_ops batadv_ethtool_ops = {
-	.get_settings = batadv_get_settings,
 	.get_drvinfo = batadv_get_drvinfo,
 	.get_link = ethtool_op_get_link,
 	.get_strings = batadv_get_strings,
@@ -1079,23 +1077,6 @@ struct rtnl_link_ops batadv_link_ops __read_mostly = {
 	.dellink	= batadv_softif_destroy_netlink,
 };
 
-/* ethtool */
-static int batadv_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
-{
-	cmd->supported = 0;
-	cmd->advertising = 0;
-	ethtool_cmd_speed_set(cmd, SPEED_10);
-	cmd->duplex = DUPLEX_FULL;
-	cmd->port = PORT_TP;
-	cmd->phy_address = 0;
-	cmd->transceiver = XCVR_INTERNAL;
-	cmd->autoneg = AUTONEG_DISABLE;
-	cmd->maxtxpkt = 0;
-	cmd->maxrxpkt = 0;
-
-	return 0;
-}
-
 static void batadv_get_drvinfo(struct net_device *dev,
 			       struct ethtool_drvinfo *info)
 {

commit 40ad9842cb35d9b7ddfea5b246fcabf17f275686
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Apr 1 14:47:04 2017 +0200

    batman-adv: Remove ethtool msglevel functions
    
    batadv devices don't support msglevel. The ethtool stubs therefore returned
    that it isn't supported. But instead, the complete function can be dropped
    to avoid that bogus values are shown in ethtool.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Acked-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index eff23d519c6f..3e0ee2afb814 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -67,8 +67,6 @@
 static int batadv_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);
 static void batadv_get_drvinfo(struct net_device *dev,
 			       struct ethtool_drvinfo *info);
-static u32 batadv_get_msglevel(struct net_device *dev);
-static void batadv_set_msglevel(struct net_device *dev, u32 value);
 static void batadv_get_strings(struct net_device *dev, u32 stringset, u8 *data);
 static void batadv_get_ethtool_stats(struct net_device *dev,
 				     struct ethtool_stats *stats, u64 *data);
@@ -77,8 +75,6 @@ static int batadv_get_sset_count(struct net_device *dev, int stringset);
 static const struct ethtool_ops batadv_ethtool_ops = {
 	.get_settings = batadv_get_settings,
 	.get_drvinfo = batadv_get_drvinfo,
-	.get_msglevel = batadv_get_msglevel,
-	.set_msglevel = batadv_set_msglevel,
 	.get_link = ethtool_op_get_link,
 	.get_strings = batadv_get_strings,
 	.get_ethtool_stats = batadv_get_ethtool_stats,
@@ -1109,15 +1105,6 @@ static void batadv_get_drvinfo(struct net_device *dev,
 	strlcpy(info->bus_info, "batman", sizeof(info->bus_info));
 }
 
-static u32 batadv_get_msglevel(struct net_device *dev)
-{
-	return -EOPNOTSUPP;
-}
-
-static void batadv_set_msglevel(struct net_device *dev, u32 value)
-{
-}
-
 /* Inspired by drivers/net/ethernet/dlink/sundance.c:1702
  * Declare each description string in struct.name[] to get fixed sized buffer
  * and compile time checking for strings longer than ETH_GSTRING_LEN.

commit 2f249e99c7cda7107ac52f0319c89bed9a6431d3
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Apr 1 14:47:03 2017 +0200

    batman-adv: Use ethtool helper to get link status
    
    The ethtool_ops of batman-adv never contained more than a stub for the
    get_link function pointer. It was always returning that a link exists even
    when the devices was not yet up and therefore nothing resampling a link
    could have been available.
    
    Instead use the ethtool helper which returns the current carrier state.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Acked-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index a9dbcc1590bd..eff23d519c6f 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -69,7 +69,6 @@ static void batadv_get_drvinfo(struct net_device *dev,
 			       struct ethtool_drvinfo *info);
 static u32 batadv_get_msglevel(struct net_device *dev);
 static void batadv_set_msglevel(struct net_device *dev, u32 value);
-static u32 batadv_get_link(struct net_device *dev);
 static void batadv_get_strings(struct net_device *dev, u32 stringset, u8 *data);
 static void batadv_get_ethtool_stats(struct net_device *dev,
 				     struct ethtool_stats *stats, u64 *data);
@@ -80,7 +79,7 @@ static const struct ethtool_ops batadv_ethtool_ops = {
 	.get_drvinfo = batadv_get_drvinfo,
 	.get_msglevel = batadv_get_msglevel,
 	.set_msglevel = batadv_set_msglevel,
-	.get_link = batadv_get_link,
+	.get_link = ethtool_op_get_link,
 	.get_strings = batadv_get_strings,
 	.get_ethtool_stats = batadv_get_ethtool_stats,
 	.get_sset_count = batadv_get_sset_count,
@@ -1119,11 +1118,6 @@ static void batadv_set_msglevel(struct net_device *dev, u32 value)
 {
 }
 
-static u32 batadv_get_link(struct net_device *dev)
-{
-	return 1;
-}
-
 /* Inspired by drivers/net/ethernet/dlink/sundance.c:1702
  * Declare each description string in struct.name[] to get fixed sized buffer
  * and compile time checking for strings longer than ETH_GSTRING_LEN.

commit e2d9ba43559e5fcd94a365ba86718332737b0817
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Fri Feb 17 11:17:07 2017 +0100

    batman-adv: restructure rebroadcast counter into forw_packet API
    
    This patch refactors the num_packets counter of a forw_packet in the
    following three ways:
    
    1) Removed dual-use of forw_packet::num_packets:
       -> now for aggregation purposes only
    2) Using forw_packet::skb::cb::num_bcasts instead:
       -> for easier access in aggregation code later
    3) make access to num_bcasts private to batadv_forw_packet_*()
    
    Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
    [sven@narfation.org: Change num_bcasts to unsigned]
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 8226495c6664..a9dbcc1590bd 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -230,6 +230,9 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	if (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)
 		goto dropped;
 
+	/* reset control block to avoid left overs from previous users */
+	memset(skb->cb, 0, sizeof(struct batadv_skb_cb));
+
 	netif_trans_update(soft_iface);
 	vid = batadv_get_vid(skb, 0);
 	ethhdr = eth_hdr(skb);

commit 13b0ea0f5934ac30bf75c21554d3061b02abbad4
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Fri Mar 17 12:08:59 2017 +0100

    batman-adv: Omit unnecessary memset of netdev private data
    
    The memory for netdev_priv is allocated using kzalloc in alloc_netdev
    (or alloc_netdev_mq respectively) so there is no need to set it to 0
    again.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 5d099b2e6cfc..8226495c6664 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -972,8 +972,6 @@ static void batadv_softif_free(struct net_device *dev)
  */
 static void batadv_softif_init_early(struct net_device *dev)
 {
-	struct batadv_priv *priv = netdev_priv(dev);
-
 	ether_setup(dev);
 
 	dev->netdev_ops = &batadv_netdev_ops;
@@ -990,8 +988,6 @@ static void batadv_softif_init_early(struct net_device *dev)
 	eth_hw_addr_random(dev);
 
 	dev->ethtool_ops = &batadv_ethtool_ops;
-
-	memset(priv, 0, sizeof(*priv));
 }
 
 struct net_device *batadv_softif_create(struct net *net, const char *name)

commit b124f413323e90398b868a9848e63149d0fed8ce
Merge: 8f3dbfd79ed9 1a9070ec91b3
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Mar 16 12:05:38 2017 -0700

    Merge tag 'batadv-net-for-davem-20170316' of git://git.open-mesh.org/linux-merge
    
    Simon Wunderlich says:
    
    ====================
    Here are two batman-adv bugfixes:
    
     - Keep fragments equally sized, avoids some problems with too small fragments,
       by Sven Eckelmann
    
     - Initialize gateway class correctly when BATMAN V is compiled in,
       by Sven Eckelmann
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 1a9070ec91b37234fe915849b767c61584c64a44
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Mar 4 15:48:50 2017 +0100

    batman-adv: Initialize gw sel_class via batadv_algo
    
    The gateway selection class variable is shared between different algorithm
    versions. But the interpretation of the content is algorithm specific. The
    initialization is therefore also algorithm specific.
    
    But this was implemented incorrectly and the initialization for BATMAN_V
    always overwrote the value previously written for BATMAN_IV. This could
    only be avoided when BATMAN_V was disabled during compile time.
    
    Using a special batadv_algo hook for this initialization avoids this
    problem.
    
    Fixes: 50164d8f500f ("batman-adv: B.A.T.M.A.N. V - implement GW selection logic")
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 7b3494ae6ad9..2e0b3463ab4a 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -820,7 +820,6 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->mcast.num_want_all_ipv6, 0);
 #endif
 	atomic_set(&bat_priv->gw.mode, BATADV_GW_MODE_OFF);
-	atomic_set(&bat_priv->gw.sel_class, 20);
 	atomic_set(&bat_priv->gw.bandwidth_down, 100);
 	atomic_set(&bat_priv->gw.bandwidth_up, 20);
 	atomic_set(&bat_priv->orig_interval, 1000);

commit 49b3eb772505dc42b61c2920ca777d55455a8ee4
Merge: 27d807180ae0 c33705188c49
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jan 26 14:31:08 2017 -0500

    Merge tag 'batadv-next-for-davem-20170126' of git://git.open-mesh.org/linux-merge
    
    Simon Wunderlich says:
    
    ====================
    This feature/cleanup patchset includes the following patches:
    
     - bump version strings, by Simon Wunderlich
    
     - ignore self-generated loop detect MAC addresses in translation table,
       by Simon Wunderlich
    
     - install uapi batman_adv.h header, by Sven Eckelmann
    
     - bump copyright years, by Sven Eckelmann
    
     - Remove an unused variable in translation table code, by Sven Eckelmann
    
     - Handle NET_XMIT_CN like NET_XMIT_SUCCESS (revised according to Davids
       suggestion), and a follow up code clean up, by Gao Feng (2 patches)
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit ac79cbb96b58614ce13c4fccc00a9b4d43c2f79b
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jan 1 00:00:00 2017 +0100

    batman-adv: update copyright years for 2017
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 1f55b4b9181c..4a9923a95e8a 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2007-2016  B.A.T.M.A.N. contributors:
+/* Copyright (C) 2007-2017  B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
  *

commit d3e9768ab97fbbff43d9face2711692206a576a9
Author: Simon Wunderlich <simon.wunderlich@open-mesh.com>
Date:   Thu Nov 24 16:11:01 2016 +0100

    batman-adv: don't add loop detect macs to TT
    
    The bridge loop avoidance (BLA) feature of batman-adv sends packets to
    probe for Mesh/LAN packet loops. Those packets are not sent by real
    clients and should therefore not be added to the translation table (TT).
    
    Signed-off-by: Simon Wunderlich <simon.wunderlich@open-mesh.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 7b3494ae6ad9..1f55b4b9181c 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -258,7 +258,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	ethhdr = eth_hdr(skb);
 
 	/* Register the client MAC in the transtable */
-	if (!is_multicast_ether_addr(ethhdr->h_source)) {
+	if (!is_multicast_ether_addr(ethhdr->h_source) &&
+	    !batadv_bla_is_loopdetect_mac(ethhdr->h_source)) {
 		client_added = batadv_tt_local_add(soft_iface, ethhdr->h_source,
 						   vid, skb->skb_iif,
 						   skb->mark);

commit 4a7c972644c1151f6dd34ff4b5f7eacb239e22ee
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Wed Jan 18 17:45:01 2017 +0100

    net: Remove usage of net_device last_rx member
    
    The network stack no longer uses the last_rx member of struct net_device
    since the bonding driver switched to use its own private last_rx in
    commit 9f242738376d ("bonding: use last_arp_rx in slave_last_rx()").
    
    However, some drivers still (ab)use the field for their own purposes and
    some driver just update it without actually using it.
    
    Previously, there was an accompanying comment for the last_rx member
    added in commit 4dc89133f49b ("net: add a comment on netdev->last_rx")
    which asked drivers not to update is, unless really needed. However,
    this commend was removed in commit f8ff080dacec ("bonding: remove
    useless updating of slave->dev->last_rx"), so some drivers added later
    on still did update last_rx.
    
    Remove all usage of last_rx and switch three drivers (sky2, atp and
    smc91c92_cs) which actually read and write it to use their own private
    copy in netdev_priv.
    
    Compile-tested with allyesconfig and allmodconfig on x86 and arm.
    
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Jay Vosburgh <j.vosburgh@gmail.com>
    Cc: Veaceslav Falico <vfalico@gmail.com>
    Cc: Andy Gospodarek <andy@greyhouse.net>
    Cc: Mirko Lindner <mlindner@marvell.com>
    Cc: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Reviewed-by: Jay Vosburgh <jay.vosburgh@canonical.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 7b3494ae6ad9..420e19b501f2 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -481,8 +481,6 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	batadv_add_counter(bat_priv, BATADV_CNT_RX_BYTES,
 			   skb->len + ETH_HLEN);
 
-	soft_iface->last_rx = jiffies;
-
 	/* Let the bridge loop avoidance check the packet. If will
 	 * not handle it, we can safely push it up.
 	 */

commit eaac2c876ecce420d24ff5d5b6d6a51390446798
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jul 17 21:04:01 2016 +0200

    batman-adv: Count all non-success TX packets as dropped
    
    A failure during the submission also causes dropped packets.
    batadv_interface_tx should therefore also increase the DROPPED counter for
    these returns.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 2f0304ec459c..7b3494ae6ad9 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -386,7 +386,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 			ret = batadv_send_skb_via_tt(bat_priv, skb, dst_hint,
 						     vid);
 		}
-		if (ret == NET_XMIT_DROP)
+		if (ret != NET_XMIT_SUCCESS)
 			goto dropped_freed;
 	}
 

commit bd687fe41991611a6904b7cbc1d596f687584ebb
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jul 17 21:04:00 2016 +0200

    batman-adv: use consume_skb for non-dropped packets
    
    kfree_skb assumes that an skb is dropped after an failure and notes that.
    consume_skb should be used in non-failure situations. Such information is
    important for dropmonitor netlink which tells how many packets were dropped
    and where this drop happened.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 109f53b8e159..2f0304ec459c 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -362,7 +362,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		/* a copy is stored in the bcast list, therefore removing
 		 * the original skb.
 		 */
-		kfree_skb(skb);
+		consume_skb(skb);
 
 	/* unicast packet */
 	} else {

commit 3111beed0d595d26551afb607c9812fe49da2ead
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Sun Aug 7 12:34:19 2016 +0200

    batman-adv: Simple (re)broadcast avoidance
    
    With this patch, (re)broadcasting on a specific interfaces is avoided:
    
    * No neighbor: There is no need to broadcast on an interface if there
      is no node behind it.
    
    * Single neighbor is source: If there is just one neighbor on an
      interface and if this neighbor is the one we actually got this
      broadcast packet from, then we do not need to echo it back.
    
    * Single neighbor is originator: If there is just one neighbor on
      an interface and if this neighbor is the originator of this
      broadcast packet, then we do not need to echo it back.
    
    Goodies for BATMAN V:
    
    ("Upgrade your BATMAN IV network to V now to get these for free!")
    
    Thanks to the split of OGMv1 into two packet types, OGMv2 and ELP
    that is, we can now apply the same optimizations stated above to OGMv2
    packets, too.
    
    Furthermore, with BATMAN V, rebroadcasts can be reduced in certain
    multi interface cases, too, where BATMAN IV cannot. This is thanks to
    the removal of the "secondary interface originator" concept in BATMAN V.
    
    Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index f37c1c769da0..109f53b8e159 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -357,7 +357,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		seqno = atomic_inc_return(&bat_priv->bcast_seqno);
 		bcast_packet->seqno = htonl(seqno);
 
-		batadv_add_bcast_packet_to_list(bat_priv, skb, brd_delay);
+		batadv_add_bcast_packet_to_list(bat_priv, skb, brd_delay, true);
 
 		/* a copy is stored in the bcast list, therefore removing
 		 * the original skb.

commit c408c1b9d49077bd6f0e267292fd35624bac76fb
Author: Sven Eckelmann <sven@narfation.org>
Date:   Fri Jul 22 01:30:10 2016 +0200

    batman-adv: Move batadv_sum_counter to soft-interface.c
    
    The function batadv_sum_counter is only used in soft-interface.c and has no
    special relevance for main.h.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 49e16b6e0ba3..f37c1c769da0 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -22,6 +22,7 @@
 #include <linux/byteorder/generic.h>
 #include <linux/cache.h>
 #include <linux/compiler.h>
+#include <linux/cpumask.h>
 #include <linux/errno.h>
 #include <linux/etherdevice.h>
 #include <linux/ethtool.h>
@@ -116,6 +117,26 @@ static int batadv_interface_release(struct net_device *dev)
 	return 0;
 }
 
+/**
+ * batadv_sum_counter - Sum the cpu-local counters for index 'idx'
+ * @bat_priv: the bat priv with all the soft interface information
+ * @idx: index of counter to sum up
+ *
+ * Return: sum of all cpu-local counters
+ */
+static u64 batadv_sum_counter(struct batadv_priv *bat_priv,  size_t idx)
+{
+	u64 *counters, sum = 0;
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		counters = per_cpu_ptr(bat_priv->bat_counters, cpu);
+		sum += counters[idx];
+	}
+
+	return sum;
+}
+
 static struct net_device_stats *batadv_interface_stats(struct net_device *dev)
 {
 	struct batadv_priv *bat_priv = netdev_priv(dev);

commit df28ca6bb3282a4c8dc5b65f60b0136fc190ee52
Author: Sven Eckelmann <sven@narfation.org>
Date:   Fri Jul 15 17:39:29 2016 +0200

    batman-adv: Place kref_get for softif_vlan near use
    
    It is hard to understand why the refcnt is increased when it isn't done
    near the actual place the new reference is used. So using kref_get right
    before the place which requires the reference and in the same function
    helps to avoid accidental problems caused by incorrect reference counting.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e508bf5957b3..49e16b6e0ba3 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -594,6 +594,7 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 	}
 
 	spin_lock_bh(&bat_priv->softif_vlan_list_lock);
+	kref_get(&vlan->refcount);
 	hlist_add_head_rcu(&vlan->list, &bat_priv->softif_vlan_list);
 	spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
 
@@ -604,6 +605,9 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 			    bat_priv->soft_iface->dev_addr, vid,
 			    BATADV_NULL_IFINDEX, BATADV_NO_MARK);
 
+	/* don't return reference to new softif_vlan */
+	batadv_softif_vlan_put(vlan);
+
 	return 0;
 }
 

commit f19dc7770f5d55274ef9821392199daca03469a9
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Jun 27 08:15:42 2016 +0200

    batman-adv: Remove orig_node reference handling from send_skb_unicast
    
    The function batadv_send_skb_unicast is not acquiring a reference for an
    orig_node nor removing it from any datastructure. It still reduces the
    reference counter for an object which is still in the hands of the caller.
    
    This is confusing and can lead in the future to problems in the reference
    handling of the caller function.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Acked-by: Linus Lüssing <linus.luessing@c0d3.blue>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 216ac03ab432..e508bf5957b3 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -57,6 +57,7 @@
 #include "hard-interface.h"
 #include "multicast.h"
 #include "network-coding.h"
+#include "originator.h"
 #include "packet.h"
 #include "send.h"
 #include "sysfs.h"
@@ -377,6 +378,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 dropped_freed:
 	batadv_inc_counter(bat_priv, BATADV_CNT_TX_DROPPED);
 end:
+	if (mcast_single_orig)
+		batadv_orig_node_put(mcast_single_orig);
 	if (primary_if)
 		batadv_hardif_put(primary_if);
 	return NETDEV_TX_OK;

commit 569c98504b2004dba207127bcceb8f3aeb9b8e7d
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Jun 13 07:41:31 2016 +0200

    batman-adv: Revert "postpone sysfs removal when unregistering"
    
    Postponing the removal of the interface breaks the expected behavior of
    NETDEV_UNREGISTER and NETDEV_PRE_TYPE_CHANGE. This is especially
    problematic when an interface is removed and added in quick succession.
    
    This reverts commit 5bc44dc8458c ("batman-adv: postpone sysfs removal when
    unregistering").
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 7527c0652dd5..216ac03ab432 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -39,6 +39,7 @@
 #include <linux/random.h>
 #include <linux/rculist.h>
 #include <linux/rcupdate.h>
+#include <linux/rtnetlink.h>
 #include <linux/skbuff.h>
 #include <linux/slab.h>
 #include <linux/socket.h>
@@ -46,7 +47,6 @@
 #include <linux/stddef.h>
 #include <linux/string.h>
 #include <linux/types.h>
-#include <linux/workqueue.h>
 
 #include "bat_algo.h"
 #include "bridge_loop_avoidance.h"
@@ -746,34 +746,6 @@ static void batadv_set_lockdep_class(struct net_device *dev)
 	netdev_for_each_tx_queue(dev, batadv_set_lockdep_class_one, NULL);
 }
 
-/**
- * batadv_softif_destroy_finish - cleans up the remains of a softif
- * @work: work queue item
- *
- * Free the parts of the soft interface which can not be removed under
- * rtnl lock (to prevent deadlock situations).
- */
-static void batadv_softif_destroy_finish(struct work_struct *work)
-{
-	struct batadv_softif_vlan *vlan;
-	struct batadv_priv *bat_priv;
-	struct net_device *soft_iface;
-
-	bat_priv = container_of(work, struct batadv_priv,
-				cleanup_work);
-	soft_iface = bat_priv->soft_iface;
-
-	/* destroy the "untagged" VLAN */
-	vlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);
-	if (vlan) {
-		batadv_softif_destroy_vlan(bat_priv, vlan);
-		batadv_softif_vlan_put(vlan);
-	}
-
-	batadv_sysfs_del_meshif(soft_iface);
-	unregister_netdev(soft_iface);
-}
-
 /**
  * batadv_softif_init_late - late stage initialization of soft interface
  * @dev: registered network device to modify
@@ -791,7 +763,6 @@ static int batadv_softif_init_late(struct net_device *dev)
 
 	bat_priv = netdev_priv(dev);
 	bat_priv->soft_iface = dev;
-	INIT_WORK(&bat_priv->cleanup_work, batadv_softif_destroy_finish);
 
 	/* batadv_interface_stats() needs to be available as soon as
 	 * register_netdevice() has been called
@@ -1028,8 +999,19 @@ struct net_device *batadv_softif_create(struct net *net, const char *name)
 void batadv_softif_destroy_sysfs(struct net_device *soft_iface)
 {
 	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
+	struct batadv_softif_vlan *vlan;
+
+	ASSERT_RTNL();
+
+	/* destroy the "untagged" VLAN */
+	vlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);
+	if (vlan) {
+		batadv_softif_destroy_vlan(bat_priv, vlan);
+		batadv_softif_vlan_put(vlan);
+	}
 
-	queue_work(batadv_event_workqueue, &bat_priv->cleanup_work);
+	batadv_sysfs_del_meshif(soft_iface);
+	unregister_netdevice(soft_iface);
 }
 
 /**

commit b77af26a790a2ecfdd4109a3b1328499ea988181
Merge: 5ee389751922 29824a55c07c
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Jul 4 23:33:59 2016 -0700

    Merge tag 'batadv-next-for-davem-20160704' of git://git.open-mesh.org/linux-merge
    
    Simon Wunderlich says:
    
    ====================
    This feature patchset includes the following changes:
    
     - Cleanup work by Markus Pargmann and Sven Eckelmann (six patches)
    
     - Initial Netlink support by Matthias Schiffer (two patches)
    
     - Throughput Meter implementation by Antonio Quartulli, a kernel-space
       traffic generator to estimate link speeds. This feature is useful on
       low-end WiFi APs where running iperf or netperf from userspace
       gives wrong results due to heavy userspace/kernelspace overhead.
       (two patches)
    
     - API clean-up work by Antonio Quartulli (one patch)
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 33a3bb4a3345bb511f9c69c913da95d4693e2a4e
Author: Antonio Quartulli <antonio.quartulli@open-mesh.com>
Date:   Thu May 5 13:09:43 2016 +0200

    batman-adv: throughput meter implementation
    
    The throughput meter module is a simple, kernel-space replacement for
    throughtput measurements tool like iperf and netperf. It is intended to
    approximate TCP behaviour.
    
    It is invoked through batctl: the protocol is connection oriented, with
    cumulative acknowledgment and a dynamic-size sliding window.
    
    The test *can* be interrupted by batctl. A receiver side timeout avoids
    unlimited waitings for sender packets: after one second of inactivity, the
    receiver abort the ongoing test.
    
    Based on a prototype from Edo Monticelli <montik@autistici.org>
    
    Signed-off-by: Antonio Quartulli <antonio.quartulli@open-mesh.com>
    Signed-off-by: Sven Eckelmann <sven.eckelmann@open-mesh.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index f75631e21e48..18b6d07c3233 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -842,6 +842,8 @@ static int batadv_softif_init_late(struct net_device *dev)
 #ifdef CONFIG_BATMAN_ADV_BLA
 	atomic_set(&bat_priv->bla.num_requests, 0);
 #endif
+	atomic_set(&bat_priv->tp_num, 0);
+
 	bat_priv->tt.last_changeset = NULL;
 	bat_priv->tt.last_changeset_len = 0;
 	bat_priv->isolation_mark = 0;

commit 3ea00443f1b17405ce9e1421bb7706777339926e
Merge: ca9354a1d47d 4e3e823b5a50
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jul 1 17:05:00 2016 -0400

    Merge tag 'batadv-next-for-davem-20160701' of git://git.open-mesh.org/linux-merge
    
    Simon Wunderlich says:
    
    ====================
    This feature patchset includes the following changes:
    
     - two patches with minimal clean up work by Antonio Quartulli and
       Simon Wunderlich
    
     - eight patches of B.A.T.M.A.N. V, API and documentation clean
       up work, by Antonio Quartulli and Marek Lindner
    
     - Andrew Lunn fixed the skb priority adoption when forwarding
       fragmented packets (two patches)
    
     - Multicast optimization support is now enabled for bridges which
       comes with some protocol updates, by Linus Luessing
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 72f7b2deafde895012f93fa4827d4b1307a138e9
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Tue May 10 18:41:26 2016 +0200

    batman-adv: Adding logging of mcast flag changes
    
    With this patch changes relevant to a node's own multicast flags are
    printed to the 'mcast' log level.
    
    Tested-by: Simon Wunderlich <sw@simonwunderlich.de>
    Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 81665b159a41..b60999da134d 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -808,6 +808,10 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->distributed_arp_table, 1);
 #endif
 #ifdef CONFIG_BATMAN_ADV_MCAST
+	bat_priv->mcast.querier_ipv4.exists = false;
+	bat_priv->mcast.querier_ipv4.shadowing = false;
+	bat_priv->mcast.querier_ipv6.exists = false;
+	bat_priv->mcast.querier_ipv6.shadowing = false;
 	bat_priv->mcast.flags = BATADV_NO_FLAGS;
 	atomic_set(&bat_priv->multicast_mode, 1);
 	atomic_set(&bat_priv->mcast.num_disabled, 0);

commit 01d350d14712d1e8dbf2b00c82d2fc7c48d34e04
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun May 15 11:07:44 2016 +0200

    batman-adv: move bat_algo functions into a separate file
    
    The bat_algo functionality in main.c is mostly unrelated to the rest of the
    content. It still takes up a large portion of this source file (~15%, 103
    lines). Moving it to a separate file makes it better visible as a main
    component of the batman-adv implementation and hides it less in the other
    helper functions in main.c.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b60999da134d..f75631e21e48 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -48,6 +48,7 @@
 #include <linux/types.h>
 #include <linux/workqueue.h>
 
+#include "bat_algo.h"
 #include "bridge_loop_avoidance.h"
 #include "debugfs.h"
 #include "distributed-arp-table.h"

commit 3a24a63e74af1bffc7aeb5d83adcd63b37e38425
Author: Antonio Quartulli <a@unstable.cc>
Date:   Fri May 6 02:46:38 2016 +0800

    batman-adv: move GW mode and selection class to private data structure
    
    To reduce the field pollution in our main batadv_priv data structure
    we've already created some substructures so that we could group fields
    in a convenient manner.
    
    However gw_mode and gw_sel_class are still part of the main object.
    
    More both fields to the GW private substructure.
    
    Signed-off-by: Antonio Quartulli <a@unstable.cc>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 343d2c904399..81665b159a41 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -255,7 +255,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	if (batadv_compare_eth(ethhdr->h_dest, ectp_addr))
 		goto dropped;
 
-	gw_mode = atomic_read(&bat_priv->gw_mode);
+	gw_mode = atomic_read(&bat_priv->gw.mode);
 	if (is_multicast_ether_addr(ethhdr->h_dest)) {
 		/* if gw mode is off, broadcast every packet */
 		if (gw_mode == BATADV_GW_MODE_OFF) {
@@ -815,8 +815,8 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->mcast.num_want_all_ipv4, 0);
 	atomic_set(&bat_priv->mcast.num_want_all_ipv6, 0);
 #endif
-	atomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);
-	atomic_set(&bat_priv->gw_sel_class, 20);
+	atomic_set(&bat_priv->gw.mode, BATADV_GW_MODE_OFF);
+	atomic_set(&bat_priv->gw.sel_class, 20);
 	atomic_set(&bat_priv->gw.bandwidth_down, 100);
 	atomic_set(&bat_priv->gw.bandwidth_up, 20);
 	atomic_set(&bat_priv->orig_interval, 1000);

commit 420cb1b764f9169c5d2601b4af90e4a1702345ee
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jun 26 11:16:13 2016 +0200

    batman-adv: Clean up untagged vlan when destroying via rtnl-link
    
    The untagged vlan object is only destroyed when the interface is removed
    via the legacy sysfs interface. But it also has to be destroyed when the
    standard rtnl-link interface is used.
    
    Fixes: 5d2c05b21337 ("batman-adv: add per VLAN interface attribute framework")
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Acked-by: Antonio Quartulli <a@unstable.cc>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 343d2c904399..287a3879ed7e 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1033,7 +1033,9 @@ void batadv_softif_destroy_sysfs(struct net_device *soft_iface)
 static void batadv_softif_destroy_netlink(struct net_device *soft_iface,
 					  struct list_head *head)
 {
+	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
 	struct batadv_hard_iface *hard_iface;
+	struct batadv_softif_vlan *vlan;
 
 	list_for_each_entry(hard_iface, &batadv_hardif_list, list) {
 		if (hard_iface->soft_iface == soft_iface)
@@ -1041,6 +1043,13 @@ static void batadv_softif_destroy_netlink(struct net_device *soft_iface,
 							BATADV_IF_CLEANUP_KEEP);
 	}
 
+	/* destroy the "untagged" VLAN */
+	vlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);
+	if (vlan) {
+		batadv_softif_destroy_vlan(bat_priv, vlan);
+		batadv_softif_vlan_put(vlan);
+	}
+
 	batadv_sysfs_del_meshif(soft_iface);
 	unregister_netdevice_queue(soft_iface, head);
 }

commit 9d1601ef4347b27dfa627d61ccfa9a724cc6e303
Author: Marek Lindner <mareklindner@neomailbox.ch>
Date:   Sun Mar 20 18:39:56 2016 +0800

    batman-adv: replace ethertype variable with ETH_P_BATMAN for readability
    
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Reviewed-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 3a0fc3c18444..343d2c904399 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -186,7 +186,6 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
 	struct batadv_hard_iface *primary_if = NULL;
 	struct batadv_bcast_packet *bcast_packet;
-	__be16 ethertype = htons(ETH_P_BATMAN);
 	static const u8 stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00,
 					      0x00, 0x00};
 	static const u8 ectp_addr[ETH_ALEN] = {0xCF, 0x00, 0x00, 0x00,
@@ -216,7 +215,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	case ETH_P_8021Q:
 		vhdr = vlan_eth_hdr(skb);
 
-		if (vhdr->h_vlan_encapsulated_proto != ethertype) {
+		/* drop batman-in-batman packets to prevent loops */
+		if (vhdr->h_vlan_encapsulated_proto != htons(ETH_P_BATMAN)) {
 			network_offset += VLAN_HLEN;
 			break;
 		}
@@ -404,7 +404,6 @@ void batadv_interface_rx(struct net_device *soft_iface,
 {
 	struct batadv_bcast_packet *batadv_bcast_packet;
 	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
-	__be16 ethertype = htons(ETH_P_BATMAN);
 	struct vlan_ethhdr *vhdr;
 	struct ethhdr *ethhdr;
 	unsigned short vid;
@@ -434,7 +433,8 @@ void batadv_interface_rx(struct net_device *soft_iface,
 
 		vhdr = (struct vlan_ethhdr *)skb->data;
 
-		if (vhdr->h_vlan_encapsulated_proto != ethertype)
+		/* drop batman-in-batman packets to prevent loops */
+		if (vhdr->h_vlan_encapsulated_proto != htons(ETH_P_BATMAN))
 			break;
 
 		/* fall through */

commit 4b426b108ac82b27f5af40df7da05a2501fd2aca
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Feb 22 21:02:39 2016 +0100

    batman-adv: Use bool as return type for boolean functions
    
    It is easier to understand that the returned value of a specific function
    doesn't have to be 0 when the functions was successful when the actual
    return type is bool. This is especially true when all surrounding functions
    with return type int use negative values to return the error code.
    
    Reported-by: Nicholas Krause <xerofoify@gmail.com>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 04866c9b860a..3a0fc3c18444 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1045,12 +1045,12 @@ static void batadv_softif_destroy_netlink(struct net_device *soft_iface,
 	unregister_netdevice_queue(soft_iface, head);
 }
 
-int batadv_softif_is_valid(const struct net_device *net_dev)
+bool batadv_softif_is_valid(const struct net_device *net_dev)
 {
 	if (net_dev->netdev_ops->ndo_start_xmit == batadv_interface_tx)
-		return 1;
+		return true;
 
-	return 0;
+	return false;
 }
 
 struct rtnl_link_ops batadv_link_ops __read_mostly = {

commit 2cd45a0671d9e37ab20e844fc4c84717a38b7f52
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Thu Apr 21 12:57:27 2016 +0200

    batman-adv: Create batman soft interfaces within correct netns.
    
    When creating a soft interface, create it in the same netns as the
    hard interface. Replace all references to init_net with the correct
    name space for the interface being manipulated.
    
    Suggested-by: Daniel Ehlers <danielehlers@mindeye.net>
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Antonio Quartulli <a@unstable.cc>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 66dd0aac480a..04866c9b860a 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -885,13 +885,14 @@ static int batadv_softif_slave_add(struct net_device *dev,
 				   struct net_device *slave_dev)
 {
 	struct batadv_hard_iface *hard_iface;
+	struct net *net = dev_net(dev);
 	int ret = -EINVAL;
 
 	hard_iface = batadv_hardif_get_by_netdev(slave_dev);
 	if (!hard_iface || hard_iface->soft_iface)
 		goto out;
 
-	ret = batadv_hardif_enable_interface(hard_iface, dev->name);
+	ret = batadv_hardif_enable_interface(hard_iface, net, dev->name);
 
 out:
 	if (hard_iface)
@@ -988,7 +989,7 @@ static void batadv_softif_init_early(struct net_device *dev)
 	memset(priv, 0, sizeof(*priv));
 }
 
-struct net_device *batadv_softif_create(const char *name)
+struct net_device *batadv_softif_create(struct net *net, const char *name)
 {
 	struct net_device *soft_iface;
 	int ret;
@@ -998,6 +999,8 @@ struct net_device *batadv_softif_create(const char *name)
 	if (!soft_iface)
 		return NULL;
 
+	dev_net_set(soft_iface, net);
+
 	soft_iface->rtnl_link_ops = &batadv_link_ops;
 
 	ret = register_netdevice(soft_iface);

commit 0d21cdaa9bbf5efae95cfb6346d26ff6e61f8896
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Tue Mar 1 22:19:05 2016 +0100

    batman-adv: NETIF_F_NETNS_LOCAL feature to prevent netns moves
    
    The batX soft interface should not be moved between network name
    spaces. This is similar to bridges, bonds, tunnels, which are not
    allowed to move between network namespaces.
    
    Suggested-by: Daniel Ehlers <danielehlers@mindeye.net>
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Acked-by: Antonio Quartulli <a@unstable.cc>
    Reviewed-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index d72f88707736..66dd0aac480a 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -972,7 +972,7 @@ static void batadv_softif_init_early(struct net_device *dev)
 
 	dev->netdev_ops = &batadv_netdev_ops;
 	dev->destructor = batadv_softif_free;
-	dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
+	dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER | NETIF_F_NETNS_LOCAL;
 	dev->priv_flags |= IFF_NO_QUEUE;
 
 	/* can't call min_mtu, because the needed variables

commit 7142fc107274a0ebfd31e995de61e71a1e84770f
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Feb 28 11:38:52 2016 +0100

    batman-adv: Remove hdr_size skb size check in batadv_interface_rx
    
    The callers of batadv_interface_rx have to make sure that enough data can
    be pulled from the skb when they read the batman-adv header. The only two
    functions using it are either calling pskb_may_pull with hdr_size directly
    (batadv_recv_bcast_packet) or indirectly via batadv_check_unicast_packet
    (batadv_recv_unicast_packet).
    
    Reported-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index dc9a61a5122d..d72f88707736 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -413,10 +413,6 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	batadv_bcast_packet = (struct batadv_bcast_packet *)skb->data;
 	is_bcast = (batadv_bcast_packet->packet_type == BATADV_BCAST);
 
-	/* check if enough space is available for pulling, and pull */
-	if (!pskb_may_pull(skb, hdr_size))
-		goto dropped;
-
 	skb_pull_rcsum(skb, hdr_size);
 	skb_reset_mac_header(skb);
 

commit 6535db56d5453555b7a40230024225d9ec700585
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Feb 28 11:38:51 2016 +0100

    batman-adv: Remove unused parameter recv_if of batadv_interface_rx
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index dfb4d56120b6..dc9a61a5122d 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -385,7 +385,6 @@ static int batadv_interface_tx(struct sk_buff *skb,
  * batadv_interface_rx - receive ethernet frame on local batman-adv interface
  * @soft_iface: local interface which will receive the ethernet frame
  * @skb: ethernet frame for @soft_iface
- * @recv_if: interface on which the batman-adv packet was received
  * @hdr_size: size of already parsed batman-adv header
  * @orig_node: originator from which the batman-adv packet was sent
  *
@@ -400,8 +399,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
  * isolated clients.
  */
 void batadv_interface_rx(struct net_device *soft_iface,
-			 struct sk_buff *skb, struct batadv_hard_iface *recv_if,
-			 int hdr_size, struct batadv_orig_node *orig_node)
+			 struct sk_buff *skb, int hdr_size,
+			 struct batadv_orig_node *orig_node)
 {
 	struct batadv_bcast_packet *batadv_bcast_packet;
 	struct batadv_priv *bat_priv = netdev_priv(soft_iface);

commit 5332174a83720921a5ef6db8080a8691f7ccbc27
Merge: e98a3aabf85f 64ae74455371
Author: David S. Miller <davem@davemloft.net>
Date:   Wed May 4 16:21:08 2016 -0400

    Merge tag 'batman-adv-for-davem' of git://git.open-mesh.org/linux-merge
    
    Antonio Quartulli says:
    
    ====================
    pull request: batman-adv 20160504
    
    In this pull request you have:
    - two changes to the MAINTAINERS file where one marks our mailing list
      as moderated and the other adds a missing documentation file
    - kernel-doc fixes
    - code refactoring and various cleanups
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 860e9538a9482bb84589f7d0718a7e6d0a944d58
Author: Florian Westphal <fw@strlen.de>
Date:   Tue May 3 16:33:13 2016 +0200

    treewide: replace dev->trans_start update with helper
    
    Replace all trans_start updates with netif_trans_update helper.
    change was done via spatch:
    
    struct net_device *d;
    @@
    - d->trans_start = jiffies
    + netif_trans_update(d)
    
    Compile tested only.
    
    Cc: user-mode-linux-devel@lists.sourceforge.net
    Cc: linux-xtensa@linux-xtensa.org
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: linux-rdma@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Cc: MPT-FusionLinux.pdl@broadcom.com
    Cc: linux-scsi@vger.kernel.org
    Cc: linux-can@vger.kernel.org
    Cc: linux-parisc@vger.kernel.org
    Cc: linux-omap@vger.kernel.org
    Cc: linux-hams@vger.kernel.org
    Cc: linux-usb@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: linux-s390@vger.kernel.org
    Cc: devel@driverdev.osuosl.org
    Cc: b.a.t.m.a.n@lists.open-mesh.org
    Cc: linux-bluetooth@vger.kernel.org
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Acked-by: Felipe Balbi <felipe.balbi@linux.intel.com>
    Acked-by: Mugunthan V N <mugunthanvnm@ti.com>
    Acked-by: Antonio Quartulli <a@unstable.cc>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 8a136b6a1ff0..dcb16c33cd8b 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -208,7 +208,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	if (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)
 		goto dropped;
 
-	soft_iface->trans_start = jiffies;
+	netif_trans_update(soft_iface);
 	vid = batadv_get_vid(skb, 0);
 	ethhdr = eth_hdr(skb);
 

commit f298cb94d6cb9c103c377a370d78dc51689819f6
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Feb 28 11:38:50 2016 +0100

    batman-adv: Add kernel-doc for batadv_interface_rx
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e158235ada06..d78c560852d7 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -381,6 +381,24 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	return NETDEV_TX_OK;
 }
 
+/**
+ * batadv_interface_rx - receive ethernet frame on local batman-adv interface
+ * @soft_iface: local interface which will receive the ethernet frame
+ * @skb: ethernet frame for @soft_iface
+ * @recv_if: interface on which the batman-adv packet was received
+ * @hdr_size: size of already parsed batman-adv header
+ * @orig_node: originator from which the batman-adv packet was sent
+ *
+ * Sends a ethernet frame to the receive path of the local @soft_iface.
+ * skb->data has still point to the batman-adv header with the size @hdr_size.
+ * The caller has to have parsed this header already and made sure that at least
+ * @hdr_size bytes are still available for pull in @skb.
+ *
+ * The packet may still get dropped. This can happen when the encapsulated
+ * ethernet frame is invalid or contains again an batman-adv packet. Also
+ * unicast packets will be dropped directly when it was sent between two
+ * isolated clients.
+ */
 void batadv_interface_rx(struct net_device *soft_iface,
 			 struct sk_buff *skb, struct batadv_hard_iface *recv_if,
 			 int hdr_size, struct batadv_orig_node *orig_node)

commit 6d030de89f1beb85ce8e6b71f4fbfef8cabe37cf
Author: Antonio Quartulli <a@unstable.cc>
Date:   Fri Mar 11 16:36:19 2016 +0100

    batman-adv: fix wrong names in kerneldoc
    
    Signed-off-by: Antonio Quartulli <a@unstable.cc>
    [sven@narfation.org: Fix additional names]
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 0710379491bf..e158235ada06 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -539,7 +539,7 @@ struct batadv_softif_vlan *batadv_softif_vlan_get(struct batadv_priv *bat_priv,
 }
 
 /**
- * batadv_create_vlan - allocate the needed resources for a new vlan
+ * batadv_softif_create_vlan - allocate the needed resources for a new vlan
  * @bat_priv: the bat priv with all the soft interface information
  * @vid: the VLAN identifier
  *

commit c78296665c3d81f040117432ab9e1cb125521b0c
Author: Sven Eckelmann <sven@narfation.org>
Date:   Fri Feb 26 17:56:13 2016 +0100

    batman-adv: Check skb size before using encapsulated ETH+VLAN header
    
    The encapsulated ethernet and VLAN header may be outside the received
    ethernet frame. Thus the skb buffer size has to be checked before it can be
    parsed to find out if it encapsulates another batman-adv packet.
    
    Fixes: 420193573f11 ("batman-adv: softif bridge loop avoidance")
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 0710379491bf..8a136b6a1ff0 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -408,11 +408,17 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	 */
 	nf_reset(skb);
 
+	if (unlikely(!pskb_may_pull(skb, ETH_HLEN)))
+		goto dropped;
+
 	vid = batadv_get_vid(skb, 0);
 	ethhdr = eth_hdr(skb);
 
 	switch (ntohs(ethhdr->h_proto)) {
 	case ETH_P_8021Q:
+		if (!pskb_may_pull(skb, VLAN_ETH_HLEN))
+			goto dropped;
+
 		vhdr = (struct vlan_ethhdr *)skb->data;
 
 		if (vhdr->h_vlan_encapsulated_proto != ethertype)
@@ -424,8 +430,6 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	}
 
 	/* skb->dev & skb->pkt_type are set here */
-	if (unlikely(!pskb_may_pull(skb, ETH_HLEN)))
-		goto dropped;
 	skb->protocol = eth_type_trans(skb, soft_iface);
 
 	/* should not be necessary anymore as we use skb_pull_rcsum()

commit 9c3bf08189bd4c0675032f5d3ca9dcb42cbb3ec8
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jan 17 11:01:21 2016 +0100

    batman-adv: Rename batadv_softif_vlan *_free_ref function to *_put
    
    The batman-adv source code is the only place in the kernel which uses the
    *_free_ref naming scheme for the *_put functions. Changing it to *_put
    makes it more consistent and makes it easier to understand the connection
    to the *_get functions.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index ca8fa4e28d4f..0710379491bf 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -497,11 +497,11 @@ static void batadv_softif_vlan_release(struct kref *ref)
 }
 
 /**
- * batadv_softif_vlan_free_ref - decrease the vlan object refcounter and
+ * batadv_softif_vlan_put - decrease the vlan object refcounter and
  *  possibly release it
  * @vlan: the vlan object to release
  */
-void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *vlan)
+void batadv_softif_vlan_put(struct batadv_softif_vlan *vlan)
 {
 	if (!vlan)
 		return;
@@ -552,7 +552,7 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 
 	vlan = batadv_softif_vlan_get(bat_priv, vid);
 	if (vlan) {
-		batadv_softif_vlan_free_ref(vlan);
+		batadv_softif_vlan_put(vlan);
 		return -EEXIST;
 	}
 
@@ -601,7 +601,7 @@ static void batadv_softif_destroy_vlan(struct batadv_priv *bat_priv,
 			       vlan->vid, "vlan interface destroyed", false);
 
 	batadv_sysfs_del_vlan(bat_priv, vlan);
-	batadv_softif_vlan_free_ref(vlan);
+	batadv_softif_vlan_put(vlan);
 }
 
 /**
@@ -646,7 +646,7 @@ static int batadv_interface_add_vid(struct net_device *dev, __be16 proto,
 	if (!vlan->kobj) {
 		ret = batadv_sysfs_add_vlan(bat_priv->soft_iface, vlan);
 		if (ret) {
-			batadv_softif_vlan_free_ref(vlan);
+			batadv_softif_vlan_put(vlan);
 			return ret;
 		}
 	}
@@ -693,7 +693,7 @@ static int batadv_interface_kill_vid(struct net_device *dev, __be16 proto,
 	batadv_softif_destroy_vlan(bat_priv, vlan);
 
 	/* finally free the vlan object */
-	batadv_softif_vlan_free_ref(vlan);
+	batadv_softif_vlan_put(vlan);
 
 	return 0;
 }
@@ -749,7 +749,7 @@ static void batadv_softif_destroy_finish(struct work_struct *work)
 	vlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);
 	if (vlan) {
 		batadv_softif_destroy_vlan(bat_priv, vlan);
-		batadv_softif_vlan_free_ref(vlan);
+		batadv_softif_vlan_put(vlan);
 	}
 
 	batadv_sysfs_del_meshif(soft_iface);

commit 82047ad7fecdc2d58bbeeb3872811b1c528fdf10
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jan 17 11:01:10 2016 +0100

    batman-adv: Rename batadv_hardif *_free_ref function to *_put
    
    The batman-adv source code is the only place in the kernel which uses the
    *_free_ref naming scheme for the *_put functions. Changing it to *_put
    makes it more consistent and makes it easier to understand the connection
    to the *_get functions.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index d4490ff75edd..ca8fa4e28d4f 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -377,7 +377,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	batadv_inc_counter(bat_priv, BATADV_CNT_TX_DROPPED);
 end:
 	if (primary_if)
-		batadv_hardif_free_ref(primary_if);
+		batadv_hardif_put(primary_if);
 	return NETDEV_TX_OK;
 }
 
@@ -878,7 +878,7 @@ static int batadv_softif_slave_add(struct net_device *dev,
 
 out:
 	if (hard_iface)
-		batadv_hardif_free_ref(hard_iface);
+		batadv_hardif_put(hard_iface);
 	return ret;
 }
 
@@ -905,7 +905,7 @@ static int batadv_softif_slave_del(struct net_device *dev,
 
 out:
 	if (hard_iface)
-		batadv_hardif_free_ref(hard_iface);
+		batadv_hardif_put(hard_iface);
 	return ret;
 }
 

commit 6be4d30c18270fe275084c7cd30884535424266e
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Jan 16 10:29:42 2016 +0100

    batman-adv: Convert batadv_softif_vlan to kref
    
    batman-adv uses a self-written reference implementation which is just based
    on atomic_t. This is less obvious when reading the code than kref and
    therefore increases the change that the reference counting will be missed.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 4bf35b8c3d23..d4490ff75edd 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -30,6 +30,7 @@
 #include <linux/if_vlan.h>
 #include <linux/jiffies.h>
 #include <linux/kernel.h>
+#include <linux/kref.h>
 #include <linux/list.h>
 #include <linux/lockdep.h>
 #include <linux/netdevice.h>
@@ -477,9 +478,27 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	return;
 }
 
+/**
+ * batadv_softif_vlan_release - release vlan from lists and queue for free after
+ *  rcu grace period
+ * @ref: kref pointer of the vlan object
+ */
+static void batadv_softif_vlan_release(struct kref *ref)
+{
+	struct batadv_softif_vlan *vlan;
+
+	vlan = container_of(ref, struct batadv_softif_vlan, refcount);
+
+	spin_lock_bh(&vlan->bat_priv->softif_vlan_list_lock);
+	hlist_del_rcu(&vlan->list);
+	spin_unlock_bh(&vlan->bat_priv->softif_vlan_list_lock);
+
+	kfree_rcu(vlan, rcu);
+}
+
 /**
  * batadv_softif_vlan_free_ref - decrease the vlan object refcounter and
- *  possibly free it
+ *  possibly release it
  * @vlan: the vlan object to release
  */
 void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *vlan)
@@ -487,13 +506,7 @@ void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *vlan)
 	if (!vlan)
 		return;
 
-	if (atomic_dec_and_test(&vlan->refcount)) {
-		spin_lock_bh(&vlan->bat_priv->softif_vlan_list_lock);
-		hlist_del_rcu(&vlan->list);
-		spin_unlock_bh(&vlan->bat_priv->softif_vlan_list_lock);
-
-		kfree_rcu(vlan, rcu);
-	}
+	kref_put(&vlan->refcount, batadv_softif_vlan_release);
 }
 
 /**
@@ -514,7 +527,7 @@ struct batadv_softif_vlan *batadv_softif_vlan_get(struct batadv_priv *bat_priv,
 		if (vlan_tmp->vid != vid)
 			continue;
 
-		if (!atomic_inc_not_zero(&vlan_tmp->refcount))
+		if (!kref_get_unless_zero(&vlan_tmp->refcount))
 			continue;
 
 		vlan = vlan_tmp;
@@ -549,7 +562,7 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 
 	vlan->bat_priv = bat_priv;
 	vlan->vid = vid;
-	atomic_set(&vlan->refcount, 1);
+	kref_init(&vlan->refcount);
 
 	atomic_set(&vlan->ap_isolation, 0);
 

commit 0046b0402ac284a31940e3354614ac88c64881a3
Author: Sven Eckelmann <sven@narfation.org>
Date:   Fri Jan 1 00:01:03 2016 +0100

    batman-adv: update copyright years for 2016
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 6c65de97126c..4bf35b8c3d23 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2007-2015 B.A.T.M.A.N. contributors:
+/* Copyright (C) 2007-2016  B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
  *

commit 7afcbbef6471130a1eb586fea0f5c06609b8341f
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat Oct 31 12:29:29 2015 +0100

    batman-adv: Fix kerneldoc of main functions
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 5ee794b62392..6c65de97126c 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -594,6 +594,7 @@ static void batadv_softif_destroy_vlan(struct batadv_priv *bat_priv,
 /**
  * batadv_interface_add_vid - ndo_add_vid API implementation
  * @dev: the netdev of the mesh interface
+ * @proto: protocol of the the vlan id
  * @vid: identifier of the new vlan
  *
  * Set up all the internal structures for handling the new vlan on top of the
@@ -651,6 +652,7 @@ static int batadv_interface_add_vid(struct net_device *dev, __be16 proto,
 /**
  * batadv_interface_kill_vid - ndo_kill_vid API implementation
  * @dev: the netdev of the mesh interface
+ * @proto: protocol of the the vlan id
  * @vid: identifier of the deleted vlan
  *
  * Destroy all the internal structures used to handle the vlan identified by vid

commit 62fe710f6e2fdf4c337763bc0774cb3232fa2139
Author: Sven Eckelmann <sven@narfation.org>
Date:   Tue Sep 15 19:00:48 2015 +0200

    batman-adv: Fix kerneldoc parsing of return description
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c923e3c7b6ac..5ee794b62392 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -501,7 +501,7 @@ void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *vlan)
  * @bat_priv: the bat priv with all the soft interface information
  * @vid: the identifier of the vlan object to retrieve
  *
- * Returns the private data of the vlan matching the vid passed as argument or
+ * Return: the private data of the vlan matching the vid passed as argument or
  * NULL otherwise. The refcounter of the returned object is incremented by 1.
  */
 struct batadv_softif_vlan *batadv_softif_vlan_get(struct batadv_priv *bat_priv,
@@ -530,7 +530,7 @@ struct batadv_softif_vlan *batadv_softif_vlan_get(struct batadv_priv *bat_priv,
  * @bat_priv: the bat priv with all the soft interface information
  * @vid: the VLAN identifier
  *
- * Returns 0 on success, a negative error otherwise.
+ * Return: 0 on success, a negative error otherwise.
  */
 int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 {
@@ -599,7 +599,7 @@ static void batadv_softif_destroy_vlan(struct batadv_priv *bat_priv,
  * Set up all the internal structures for handling the new vlan on top of the
  * mesh interface
  *
- * Returns 0 on success or a negative error code in case of failure.
+ * Return: 0 on success or a negative error code in case of failure.
  */
 static int batadv_interface_add_vid(struct net_device *dev, __be16 proto,
 				    unsigned short vid)
@@ -656,7 +656,7 @@ static int batadv_interface_add_vid(struct net_device *dev, __be16 proto,
  * Destroy all the internal structures used to handle the vlan identified by vid
  * on top of the mesh interface
  *
- * Returns 0 on success, -EINVAL if the specified prototype is not ETH_P_8021Q
+ * Return: 0 on success, -EINVAL if the specified prototype is not ETH_P_8021Q
  * or -ENOENT if the specified vlan id wasn't registered.
  */
 static int batadv_interface_kill_vid(struct net_device *dev, __be16 proto,
@@ -745,7 +745,7 @@ static void batadv_softif_destroy_finish(struct work_struct *work)
  * batadv_softif_init_late - late stage initialization of soft interface
  * @dev: registered network device to modify
  *
- * Returns error code on failures
+ * Return: error code on failures
  */
 static int batadv_softif_init_late(struct net_device *dev)
 {
@@ -847,7 +847,7 @@ static int batadv_softif_init_late(struct net_device *dev)
  * @dev: batadv_soft_interface used as master interface
  * @slave_dev: net_device which should become the slave interface
  *
- * Return 0 if successful or error otherwise.
+ * Return: 0 if successful or error otherwise.
  */
 static int batadv_softif_slave_add(struct net_device *dev,
 				   struct net_device *slave_dev)
@@ -872,7 +872,7 @@ static int batadv_softif_slave_add(struct net_device *dev,
  * @dev: batadv_soft_interface used as master interface
  * @slave_dev: net_device which should be removed from the master interface
  *
- * Return 0 if successful or error otherwise.
+ * Return: 0 if successful or error otherwise.
  */
 static int batadv_softif_slave_del(struct net_device *dev,
 				   struct net_device *slave_dev)

commit e51f0397ded5bcbc2dd1694bc3d6f24cb2d42fa5
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Sep 6 21:38:51 2015 +0200

    batman-adv: Fix names in kerneldoc of functions
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <a@unstable.cc>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index ac4d08de5df4..c923e3c7b6ac 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -480,7 +480,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 /**
  * batadv_softif_vlan_free_ref - decrease the vlan object refcounter and
  *  possibly free it
- * @softif_vlan: the vlan object to release
+ * @vlan: the vlan object to release
  */
 void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *vlan)
 {

commit 7bca68c7844b1642868809a5ef4387c1f099ab1d
Author: Sven Eckelmann <sven@narfation.org>
Date:   Fri Aug 7 19:28:42 2015 +0200

    batman-adv: Add lower layer needed_(head|tail)room to own ones
    
    The maximum of hard_header_len and maximum of all needed_(head|tail)room of
    all slave interfaces of a batman-adv device must be used to define the
    batman-adv device needed_(head|tail)room. This is required to avoid too
    small buffer problems when these slave devices try to send the encapsulated
    packet in a tx path without the possibility to resize the skbuff.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index d5c5ad93a611..ac4d08de5df4 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -947,8 +947,6 @@ static void batadv_softif_init_early(struct net_device *dev)
 	 * have not been initialized yet
 	 */
 	dev->mtu = ETH_DATA_LEN;
-	/* reserve more space in the skbuff for our header */
-	dev->hard_header_len = batadv_max_header_len();
 
 	/* generate random address */
 	eth_hw_addr_random(dev);

commit 6b5e971a282c0e7b18b47823103d695352b5a3c2
Author: Sven Eckelmann <sven@narfation.org>
Date:   Tue May 26 18:34:26 2015 +0200

    batman-adv: Replace C99 int types with kernel type
    
    (s|u)(8|16|32|64) are the preferred types in the kernel. The use of the
    standard C99 types u?int(8|16|32|64)_t are objected by some people and even
    checkpatch now warns about using them.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 49d3d3aa59cb..d5c5ad93a611 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -131,7 +131,7 @@ static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 	struct batadv_priv *bat_priv = netdev_priv(dev);
 	struct batadv_softif_vlan *vlan;
 	struct sockaddr *addr = p;
-	uint8_t old_addr[ETH_ALEN];
+	u8 old_addr[ETH_ALEN];
 
 	if (!is_valid_ether_addr(addr->sa_data))
 		return -EADDRNOTAVAIL;
@@ -186,19 +186,19 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	struct batadv_hard_iface *primary_if = NULL;
 	struct batadv_bcast_packet *bcast_packet;
 	__be16 ethertype = htons(ETH_P_BATMAN);
-	static const uint8_t stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00,
-						   0x00, 0x00};
-	static const uint8_t ectp_addr[ETH_ALEN] = {0xCF, 0x00, 0x00, 0x00,
-						    0x00, 0x00};
+	static const u8 stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00,
+					      0x00, 0x00};
+	static const u8 ectp_addr[ETH_ALEN] = {0xCF, 0x00, 0x00, 0x00,
+					       0x00, 0x00};
 	enum batadv_dhcp_recipient dhcp_rcp = BATADV_DHCP_NO;
-	uint8_t *dst_hint = NULL, chaddr[ETH_ALEN];
+	u8 *dst_hint = NULL, chaddr[ETH_ALEN];
 	struct vlan_ethhdr *vhdr;
 	unsigned int header_len = 0;
 	int data_len = skb->len, ret;
 	unsigned long brd_delay = 1;
 	bool do_bcast = false, client_added;
 	unsigned short vid;
-	uint32_t seqno;
+	u32 seqno;
 	int gw_mode;
 	enum batadv_forw_mode forw_mode;
 	struct batadv_orig_node *mcast_single_orig = NULL;
@@ -750,9 +750,9 @@ static void batadv_softif_destroy_finish(struct work_struct *work)
 static int batadv_softif_init_late(struct net_device *dev)
 {
 	struct batadv_priv *bat_priv;
-	uint32_t random_seqno;
+	u32 random_seqno;
 	int ret;
-	size_t cnt_len = sizeof(uint64_t) * BATADV_CNT_NUM;
+	size_t cnt_len = sizeof(u64) * BATADV_CNT_NUM;
 
 	batadv_set_lockdep_class(dev);
 
@@ -763,7 +763,7 @@ static int batadv_softif_init_late(struct net_device *dev)
 	/* batadv_interface_stats() needs to be available as soon as
 	 * register_netdevice() has been called
 	 */
-	bat_priv->bat_counters = __alloc_percpu(cnt_len, __alignof__(uint64_t));
+	bat_priv->bat_counters = __alloc_percpu(cnt_len, __alignof__(u64));
 	if (!bat_priv->bat_counters)
 		return -ENOMEM;
 
@@ -1117,8 +1117,7 @@ static const struct {
 #endif
 };
 
-static void batadv_get_strings(struct net_device *dev, uint32_t stringset,
-			       uint8_t *data)
+static void batadv_get_strings(struct net_device *dev, u32 stringset, u8 *data)
 {
 	if (stringset == ETH_SS_STATS)
 		memcpy(data, batadv_counters_strings,
@@ -1126,8 +1125,7 @@ static void batadv_get_strings(struct net_device *dev, uint32_t stringset,
 }
 
 static void batadv_get_ethtool_stats(struct net_device *dev,
-				     struct ethtool_stats *stats,
-				     uint64_t *data)
+				     struct ethtool_stats *stats, u64 *data)
 {
 	struct batadv_priv *bat_priv = netdev_priv(dev);
 	int i;

commit cdf7370391d3a482ef2f2a8c73d16c6db3dbecf0
Author: Phil Sutter <phil@nwl.cc>
Date:   Tue Aug 18 10:30:44 2015 +0200

    net: batman-adv: convert to using IFF_NO_QUEUE
    
    Signed-off-by: Phil Sutter <phil@nwl.cc>
    Cc: Marek Lindner <mareklindner@neomailbox.ch>
    Cc: Simon Wunderlich <sw@simonwunderlich.de>
    Cc: Antonio Quartulli <antonio@meshcoding.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 51cda3a7c51d..49d3d3aa59cb 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -941,7 +941,7 @@ static void batadv_softif_init_early(struct net_device *dev)
 	dev->netdev_ops = &batadv_netdev_ops;
 	dev->destructor = batadv_softif_free;
 	dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
-	dev->tx_queue_len = 0;
+	dev->priv_flags |= IFF_NO_QUEUE;
 
 	/* can't call min_mtu, because the needed variables
 	 * have not been initialized yet

commit c1f066d4ee0bde4bb0ff4ac295218b631729e0de
Merge: 2bd736fa0d8a 53cf037bf846
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Aug 17 14:31:42 2015 -0700

    Merge tag 'batman-adv-for-davem' of git://git.open-mesh.org/linux-merge
    
    Antonio Quartulli says:
    
    ====================
    Included changes:
    - avoid integer overflow in GW selection routine
    - prevent race condition by making capability bit changes atomic (use
      clear/set/test_bit)
    - fix synchronization issue in mcast tvlv handler
    - fix crash on double list removal of TT Request objects
    - fix leak by puring packets enqueued for sending upon iface removal
    - ensure network header pointer is set in skb
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 53cf037bf846417fd92dc92ddf97267f69b110f4
Author: Linus Lüssing <linus.luessing@c0d3.blue>
Date:   Tue Jun 30 23:45:26 2015 +0200

    batman-adv: Fix potentially broken skb network header access
    
    The two commits noted below added calls to ip_hdr() and ipv6_hdr(). They
    need a correctly set skb network header.
    
    Unfortunately we cannot rely on the device drivers to set it for us.
    Therefore setting it in the beginning of the according ndo_start_xmit
    handler.
    
    Fixes: 1d8ab8d3c176 ("batman-adv: Modified forwarding behaviour for multicast packets")
    Fixes: ab49886e3da7 ("batman-adv: Add IPv4 link-local/IPv6-ll-all-nodes multicast support")
    Signed-off-by: Linus Lüssing <linus.luessing@c0d3.blue>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c002961da75d..926292d5ffa8 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -202,6 +202,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	int gw_mode;
 	enum batadv_forw_mode forw_mode;
 	struct batadv_orig_node *mcast_single_orig = NULL;
+	int network_offset = ETH_HLEN;
 
 	if (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)
 		goto dropped;
@@ -214,14 +215,18 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	case ETH_P_8021Q:
 		vhdr = vlan_eth_hdr(skb);
 
-		if (vhdr->h_vlan_encapsulated_proto != ethertype)
+		if (vhdr->h_vlan_encapsulated_proto != ethertype) {
+			network_offset += VLAN_HLEN;
 			break;
+		}
 
 		/* fall through */
 	case ETH_P_BATMAN:
 		goto dropped;
 	}
 
+	skb_set_network_header(skb, network_offset);
+
 	if (batadv_bla_tx(bat_priv, skb, vid))
 		goto dropped;
 

commit 354136bcc3c4f40a2813bba8f57ca5267d812d15
Author: Marek Lindner <mareklindner@neomailbox.ch>
Date:   Tue Jun 9 21:24:36 2015 +0800

    batman-adv: fix kernel crash due to missing NULL checks
    
    batadv_softif_vlan_get() may return NULL which has to be verified
    by the caller.
    
    Fixes: 35df3b298fc8 ("batman-adv: fix TT VLAN inconsistency on VLAN re-add")
    Reported-by: Ryan Thompson <ryan@eero.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c002961da75d..a2fc843c2243 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -479,6 +479,9 @@ void batadv_interface_rx(struct net_device *soft_iface,
  */
 void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *vlan)
 {
+	if (!vlan)
+		return;
+
 	if (atomic_dec_and_test(&vlan->refcount)) {
 		spin_lock_bh(&vlan->bat_priv->softif_vlan_list_lock);
 		hlist_del_rcu(&vlan->list);

commit 94d1dd87316fdb7a403a2750e13ec839fd2fadea
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Mon Mar 31 13:48:10 2014 +0200

    batman-adv: change the MAC of each VLAN upon ndo_set_mac_address
    
    The MAC address of the soft-interface is used to initialise
    the "non-purge" TT entry of each existing VLAN. Therefore
    when the user invokes ndo_set_mac_address() all the
    "non-purge" TT entries have to be updated, not only the one
    belonging to the non-tagged network.
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index a859322d7b41..c002961da75d 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -129,6 +129,7 @@ static struct net_device_stats *batadv_interface_stats(struct net_device *dev)
 static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 {
 	struct batadv_priv *bat_priv = netdev_priv(dev);
+	struct batadv_softif_vlan *vlan;
 	struct sockaddr *addr = p;
 	uint8_t old_addr[ETH_ALEN];
 
@@ -139,12 +140,17 @@ static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 	ether_addr_copy(dev->dev_addr, addr->sa_data);
 
 	/* only modify transtable if it has been initialized before */
-	if (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_ACTIVE) {
-		batadv_tt_local_remove(bat_priv, old_addr, BATADV_NO_FLAGS,
+	if (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)
+		return 0;
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(vlan, &bat_priv->softif_vlan_list, list) {
+		batadv_tt_local_remove(bat_priv, old_addr, vlan->vid,
 				       "mac address changed", false);
-		batadv_tt_local_add(dev, addr->sa_data, BATADV_NO_FLAGS,
+		batadv_tt_local_add(dev, addr->sa_data, vlan->vid,
 				    BATADV_NULL_IFINDEX, BATADV_NO_MARK);
 	}
+	rcu_read_unlock();
 
 	return 0;
 }

commit 1e2c2a4fe4a52cc55a78727778119f9a74283b8a
Author: Sven Eckelmann <sven@narfation.org>
Date:   Fri Apr 17 19:40:28 2015 +0200

    batman-adv: Add required includes to all files
    
    The header files could not be build indepdent from each other. This is
    happened because headers didn't include the files for things they've used.
    This was problematic because the success of a build depended on the
    knowledge about the right order of local includes.
    
    Also source files were not including everything they've used explicitly.
    Instead they required that transitive includes are always stable. This is
    problematic because some transitive includes are not obvious, depend on
    config settings and may not be stable in the future.
    
    The order for include blocks are:
    
     * primary headers (main.h and the *.h file of a *.c file)
     * global linux headers
     * required local headers
     * extra forward declarations for pointers in function/struct declarations
    
    The only exceptions are linux/bitops.h and linux/if_ether.h in packet.h.
    This header file is shared with userspace applications like batctl and must
    therefore build together with userspace applications. The header
    linux/bitops.h is not part of the uapi headers and linux/if_ether.h
    conflicts with the musl implementation of netinet/if_ether.h. The
    maintainers rejected the use of __KERNEL__ preprocessor checks and thus
    these two headers are only in main.h. All files using packet.h first have
    to include main.h to work correctly.
    
    Reported-by: Markus Pargmann <mpa@pengutronix.de>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 50cf722f4e1b..a859322d7b41 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -15,26 +15,50 @@
  * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
-#include "main.h"
 #include "soft-interface.h"
-#include "hard-interface.h"
-#include "distributed-arp-table.h"
-#include "routing.h"
-#include "send.h"
-#include "debugfs.h"
-#include "translation-table.h"
-#include "hash.h"
-#include "gateway_common.h"
-#include "gateway_client.h"
-#include "sysfs.h"
-#include "originator.h"
-#include <linux/slab.h>
-#include <linux/ethtool.h>
+#include "main.h"
+
+#include <linux/atomic.h>
+#include <linux/byteorder/generic.h>
+#include <linux/cache.h>
+#include <linux/compiler.h>
+#include <linux/errno.h>
 #include <linux/etherdevice.h>
+#include <linux/ethtool.h>
+#include <linux/fs.h>
+#include <linux/if_ether.h>
 #include <linux/if_vlan.h>
-#include "multicast.h"
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/lockdep.h>
+#include <linux/netdevice.h>
+#include <linux/percpu.h>
+#include <linux/printk.h>
+#include <linux/random.h>
+#include <linux/rculist.h>
+#include <linux/rcupdate.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/socket.h>
+#include <linux/spinlock.h>
+#include <linux/stddef.h>
+#include <linux/string.h>
+#include <linux/types.h>
+#include <linux/workqueue.h>
+
 #include "bridge_loop_avoidance.h"
+#include "debugfs.h"
+#include "distributed-arp-table.h"
+#include "gateway_client.h"
+#include "gateway_common.h"
+#include "hard-interface.h"
+#include "multicast.h"
 #include "network-coding.h"
+#include "packet.h"
+#include "send.h"
+#include "sysfs.h"
+#include "translation-table.h"
 
 static int batadv_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);
 static void batadv_get_drvinfo(struct net_device *dev,

commit 00f548bf5494ade996ae9c5e85c497dd2a3fdad5
Author: Marek Lindner <mareklindner@neomailbox.ch>
Date:   Wed Feb 18 22:17:30 2015 +0800

    batman-adv: checkpatch - comparison to NULL could be rewritten
    
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 9426b83caab6..50cf722f4e1b 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -818,7 +818,7 @@ static int batadv_softif_slave_add(struct net_device *dev,
 	int ret = -EINVAL;
 
 	hard_iface = batadv_hardif_get_by_netdev(slave_dev);
-	if (!hard_iface || hard_iface->soft_iface != NULL)
+	if (!hard_iface || hard_iface->soft_iface)
 		goto out;
 
 	ret = batadv_hardif_enable_interface(hard_iface, dev->name);

commit dab7b62190c5abbe90eef4e9f9e7c28492e77eba
Author: Sven Eckelmann <sven@narfation.org>
Date:   Wed Feb 18 18:20:24 2015 +0100

    batman-adv: Use safer default config for optional features
    
    The current default settings for optional features in batman-adv seems to
    be based around the idea that the user only compiles what he requires. They
    will automatically enabled when they are compiled in. For example the
    network coding part of batman-adv is by default disabled in the out-of-tree
    module but will be enabled when the code is compiled during the module
    build.
    
    But distributions like Debian just enable all features of the batman-adv
    kernel module and hope that more experimental features or features with
    possible negative effects have to be enabled using some runtime
    configuration interface.
    
    The network_coding feature can help in specific setups but also has
    drawbacks and is not disabled by default in the out-of-tree module.
    Disabling by default in the runtime config seems to be also quite sane.
    
    The bridge_loop_avoidance is the only feature which is disabled by default
    but may be necessary even in simple setups. Packet loops may even be
    created during the initial node setup when this is not enabled. This is
    different than STP on bridges because mesh is usually used on Adhoc WiFi.
    Having two nodes (by accident) in the same LAN segment and in the same mesh
    network is rather common in this situation.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Acked-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index d85a45c24f62..9426b83caab6 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -732,7 +732,7 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->aggregated_ogms, 1);
 	atomic_set(&bat_priv->bonding, 0);
 #ifdef CONFIG_BATMAN_ADV_BLA
-	atomic_set(&bat_priv->bridge_loop_avoidance, 0);
+	atomic_set(&bat_priv->bridge_loop_avoidance, 1);
 #endif
 #ifdef CONFIG_BATMAN_ADV_DAT
 	atomic_set(&bat_priv->distributed_arp_table, 1);

commit 9f6446c7f9af084763037334d37e85dacfcbd403
Author: Sven Eckelmann <sven@narfation.org>
Date:   Thu Apr 23 13:16:35 2015 +0200

    batman-adv: update copyright years for 2015
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 5ec31d7de24f..d85a45c24f62 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2007-2014 B.A.T.M.A.N. contributors:
+/* Copyright (C) 2007-2015 B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
  *

commit 8a3f8b6ac5c5791a04d0d30636190bfc68f2e37b
Author: Antonio Quartulli <antonio@meshcoding.com>
Date:   Mon Sep 1 14:37:28 2014 +0200

    batman-adv: checkpatch - Please don't use multiple blank lines
    
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 5467955eb27c..5ec31d7de24f 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -36,7 +36,6 @@
 #include "bridge_loop_avoidance.h"
 #include "network-coding.h"
 
-
 static int batadv_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);
 static void batadv_get_drvinfo(struct net_device *dev,
 			       struct ethtool_drvinfo *info);

commit e03366ea6b05c0ac7e53cecb292b6182419dc49c
Author: Simon Wunderlich <simon@open-mesh.com>
Date:   Tue Jun 17 12:16:03 2014 +0200

    batman-adv: increase default hop penalty
    
    The default hop penalty is currently set to 15, which is applied like
    that for multi interface devices (e.g. dual band APs). Single band
    devices will still use an effective penalty of 30 (hop penalty + wifi
    penalty).
    
    After receiving reports of too long paths in mesh networks with dual
    band APs which were fixed by increasing the hop penalty, we'd like to
    suggest to increase that default value in the default setting as well.
    We've evaluated that increase in a handful of medium sized mesh
    networks (5-20 nodes) with single and dual band devices, with changes
    for the better (shorter routes, higher throughput) or no change at all.
    
    This patch changes the hop penalty to 30, which will give an effective
    penalty of 60 on single band devices (hop penalty + wifi penalty).
    
    Signed-off-by: Simon Wunderlich <simon@open-mesh.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e0a723991c54..5467955eb27c 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -751,7 +751,7 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->gw.bandwidth_down, 100);
 	atomic_set(&bat_priv->gw.bandwidth_up, 20);
 	atomic_set(&bat_priv->orig_interval, 1000);
-	atomic_set(&bat_priv->hop_penalty, 15);
+	atomic_set(&bat_priv->hop_penalty, 30);
 #ifdef CONFIG_BATMAN_ADV_DEBUG
 	atomic_set(&bat_priv->log_level, 0);
 #endif

commit 8fd90bb889635fa1e7f80a3950948cc2e74c1446
Merge: 1bb4238b17b5 15ba2236f355
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 22 00:44:59 2014 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/infiniband/hw/cxgb4/device.c
    
    The cxgb4 conflict was simply overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 35df3b298fc8779f7edf4b0228c683f7e98edcd5
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Thu May 8 17:13:15 2014 +0200

    batman-adv: fix TT VLAN inconsistency on VLAN re-add
    
    When a VLAN interface (on top of batX) is removed and
    re-added within a short timeframe TT does not have enough
    time to properly cleanup. This creates an internal TT state
    mismatch as the newly created softif_vlan will be
    initialized from scratch with a TT client count of zero
    (even if TT entries for this VLAN still exist). The
    resulting TT messages are bogus due to the counter / tt
    client listing mismatch, thus creating inconsistencies on
    every node in the network
    
    To fix this issue destroy_vlan() has to not free the VLAN
    object immediately but it has to be kept alive until all the
    TT entries for this VLAN have been removed. destroy_vlan()
    still removes the sysfs folder so that the user has the
    feeling that everything went fine.
    
    If the same VLAN is re-added before the old object is free'd,
    then the latter is resurrected and re-used.
    
    Implement such behaviour by increasing the reference counter
    of a softif_vlan object every time a new local TT entry for
    such VLAN is created and remove the object from the list
    only when all the TT entries have been destroyed.
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e7ee65dc20bf..cbd677f48c00 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -448,10 +448,15 @@ void batadv_interface_rx(struct net_device *soft_iface,
  *  possibly free it
  * @softif_vlan: the vlan object to release
  */
-void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *softif_vlan)
+void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *vlan)
 {
-	if (atomic_dec_and_test(&softif_vlan->refcount))
-		kfree_rcu(softif_vlan, rcu);
+	if (atomic_dec_and_test(&vlan->refcount)) {
+		spin_lock_bh(&vlan->bat_priv->softif_vlan_list_lock);
+		hlist_del_rcu(&vlan->list);
+		spin_unlock_bh(&vlan->bat_priv->softif_vlan_list_lock);
+
+		kfree_rcu(vlan, rcu);
+	}
 }
 
 /**
@@ -505,6 +510,7 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 	if (!vlan)
 		return -ENOMEM;
 
+	vlan->bat_priv = bat_priv;
 	vlan->vid = vid;
 	atomic_set(&vlan->refcount, 1);
 
@@ -516,6 +522,10 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 		return err;
 	}
 
+	spin_lock_bh(&bat_priv->softif_vlan_list_lock);
+	hlist_add_head_rcu(&vlan->list, &bat_priv->softif_vlan_list);
+	spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
+
 	/* add a new TT local entry. This one will be marked with the NOPURGE
 	 * flag
 	 */
@@ -523,10 +533,6 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 			    bat_priv->soft_iface->dev_addr, vid,
 			    BATADV_NULL_IFINDEX, BATADV_NO_MARK);
 
-	spin_lock_bh(&bat_priv->softif_vlan_list_lock);
-	hlist_add_head_rcu(&vlan->list, &bat_priv->softif_vlan_list);
-	spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
-
 	return 0;
 }
 
@@ -538,18 +544,13 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 static void batadv_softif_destroy_vlan(struct batadv_priv *bat_priv,
 				       struct batadv_softif_vlan *vlan)
 {
-	spin_lock_bh(&bat_priv->softif_vlan_list_lock);
-	hlist_del_rcu(&vlan->list);
-	spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
-
-	batadv_sysfs_del_vlan(bat_priv, vlan);
-
 	/* explicitly remove the associated TT local entry because it is marked
 	 * with the NOPURGE flag
 	 */
 	batadv_tt_local_remove(bat_priv, bat_priv->soft_iface->dev_addr,
 			       vlan->vid, "vlan interface destroyed", false);
 
+	batadv_sysfs_del_vlan(bat_priv, vlan);
 	batadv_softif_vlan_free_ref(vlan);
 }
 
@@ -567,6 +568,8 @@ static int batadv_interface_add_vid(struct net_device *dev, __be16 proto,
 				    unsigned short vid)
 {
 	struct batadv_priv *bat_priv = netdev_priv(dev);
+	struct batadv_softif_vlan *vlan;
+	int ret;
 
 	/* only 802.1Q vlans are supported.
 	 * batman-adv does not know how to handle other types
@@ -576,7 +579,36 @@ static int batadv_interface_add_vid(struct net_device *dev, __be16 proto,
 
 	vid |= BATADV_VLAN_HAS_TAG;
 
-	return batadv_softif_create_vlan(bat_priv, vid);
+	/* if a new vlan is getting created and it already exists, it means that
+	 * it was not deleted yet. batadv_softif_vlan_get() increases the
+	 * refcount in order to revive the object.
+	 *
+	 * if it does not exist then create it.
+	 */
+	vlan = batadv_softif_vlan_get(bat_priv, vid);
+	if (!vlan)
+		return batadv_softif_create_vlan(bat_priv, vid);
+
+	/* recreate the sysfs object if it was already destroyed (and it should
+	 * be since we received a kill_vid() for this vlan
+	 */
+	if (!vlan->kobj) {
+		ret = batadv_sysfs_add_vlan(bat_priv->soft_iface, vlan);
+		if (ret) {
+			batadv_softif_vlan_free_ref(vlan);
+			return ret;
+		}
+	}
+
+	/* add a new TT local entry. This one will be marked with the NOPURGE
+	 * flag. This must be added again, even if the vlan object already
+	 * exists, because the entry was deleted by kill_vid()
+	 */
+	batadv_tt_local_add(bat_priv->soft_iface,
+			    bat_priv->soft_iface->dev_addr, vid,
+			    BATADV_NULL_IFINDEX, BATADV_NO_MARK);
+
+	return 0;
 }
 
 /**

commit c835a677331495cf137a7f8a023463afd9f032f8
Author: Tom Gundersen <teg@jklm.no>
Date:   Mon Jul 14 16:37:24 2014 +0200

    net: set name_assign_type in alloc_netdev()
    
    Extend alloc_netdev{,_mq{,s}}() to take name_assign_type as argument, and convert
    all users to pass NET_NAME_UNKNOWN.
    
    Coccinelle patch:
    
    @@
    expression sizeof_priv, name, setup, txqs, rxqs, count;
    @@
    
    (
    -alloc_netdev_mqs(sizeof_priv, name, setup, txqs, rxqs)
    +alloc_netdev_mqs(sizeof_priv, name, NET_NAME_UNKNOWN, setup, txqs, rxqs)
    |
    -alloc_netdev_mq(sizeof_priv, name, setup, count)
    +alloc_netdev_mq(sizeof_priv, name, NET_NAME_UNKNOWN, setup, count)
    |
    -alloc_netdev(sizeof_priv, name, setup)
    +alloc_netdev(sizeof_priv, name, NET_NAME_UNKNOWN, setup)
    )
    
    v9: move comments here from the wrong commit
    
    Signed-off-by: Tom Gundersen <teg@jklm.no>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e7ee65dc20bf..d551e6302cf3 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -895,7 +895,7 @@ struct net_device *batadv_softif_create(const char *name)
 	int ret;
 
 	soft_iface = alloc_netdev(sizeof(struct batadv_priv), name,
-				  batadv_softif_init_early);
+				  NET_NAME_UNKNOWN, batadv_softif_init_early);
 	if (!soft_iface)
 		return NULL;
 

commit 7ad24ea4bf620a32631d7b3069c3e30c078b0c3e
Author: Wilfried Klaebe <w-lkml@lebenslange-mailadresse.de>
Date:   Sun May 11 00:12:32 2014 +0000

    net: get rid of SET_ETHTOOL_OPS
    
    net: get rid of SET_ETHTOOL_OPS
    
    Dave Miller mentioned he'd like to see SET_ETHTOOL_OPS gone.
    This does that.
    
    Mostly done via coccinelle script:
    @@
    struct ethtool_ops *ops;
    struct net_device *dev;
    @@
    -       SET_ETHTOOL_OPS(dev, ops);
    +       dev->ethtool_ops = ops;
    
    Compile tested only, but I'd seriously wonder if this broke anything.
    
    Suggested-by: Dave Miller <davem@davemloft.net>
    Signed-off-by: Wilfried Klaebe <w-lkml@lebenslange-mailadresse.de>
    Acked-by: Felipe Balbi <balbi@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 744a59b85e15..e7ee65dc20bf 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -884,7 +884,7 @@ static void batadv_softif_init_early(struct net_device *dev)
 	/* generate random address */
 	eth_hw_addr_random(dev);
 
-	SET_ETHTOOL_OPS(dev, &batadv_ethtool_ops);
+	dev->ethtool_ops = &batadv_ethtool_ops;
 
 	memset(priv, 0, sizeof(*priv));
 }

commit 4c8755d69cbde2ec464a39c932aed0a83f9ff89f
Author: Linus Lüssing <linus.luessing@web.de>
Date:   Sat Feb 15 17:47:54 2014 +0100

    batman-adv: Send multicast packets to nodes with a WANT_ALL flag
    
    With this patch a node sends IPv4 multicast packets to nodes which
    have a BATADV_MCAST_WANT_ALL_IPV4 flag set and IPv6 multicast packets
    to nodes which have a BATADV_MCAST_WANT_ALL_IPV6 flag set, too.
    
    Why is this needed? There are scenarios involving bridges where
    multicast report snooping and multicast TT announcements are not
    sufficient, which would lead to packet loss for some nodes otherwise:
    
    MLDv1 and IGMPv1/IGMPv2 have a suppression mechanism
    for multicast listener reports. When we have an MLDv1/IGMPv1/IGMPv2
    querier behind a bridge then our snooping bridge is potentially not
    going to see any reports even though listeners exist because according
    to RFC4541 such reports are only forwarded to multicast routers:
    
    -----------------------------------------------------------
                ---------------
    {Querier}---|Snoop. Switch|----{Listener}
                ---------------
                           \           ^
                          -------
                          | br0 |  <  ???
                          -------
                              \
                         _-~---~_
                     _-~/        ~-_
                    ~   batman-adv  \-----{Sender}
                    \~_   cloud    ~/
                       -~~__-__-~_/
    
    I)  MLDv1 Query:  {Querier}  -> flooded
    II) MLDv1 Report: {Listener} -> {Querier}
    
    -> br0 cannot detect the {Listener}
    => Packets from {Sender} need to be forwarded to all
       detected listeners and MLDv1/IGMPv1/IGMPv2 queriers.
    
    -----------------------------------------------------------
    
    Note that we do not need to explicitly forward to MLDv2/IGMPv3 queriers,
    because these protocols have no report suppression: A bridge has no
    trouble detecting MLDv2/IGMPv3 listeners.
    
    Even though we do not support bridges yet we need to provide the
    according infrastructure already to not break compatibility later.
    
    Signed-off-by: Linus Lüssing <linus.luessing@web.de>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index db6fecaddb9c..744a59b85e15 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -711,6 +711,8 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->multicast_mode, 1);
 	atomic_set(&bat_priv->mcast.num_disabled, 0);
 	atomic_set(&bat_priv->mcast.num_want_all_unsnoopables, 0);
+	atomic_set(&bat_priv->mcast.num_want_all_ipv4, 0);
+	atomic_set(&bat_priv->mcast.num_want_all_ipv6, 0);
 #endif
 	atomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);
 	atomic_set(&bat_priv->gw_sel_class, 20);

commit ab49886e3da73b6b35ece21006e191910427bb30
Author: Linus Lüssing <linus.luessing@web.de>
Date:   Sat Feb 15 17:47:53 2014 +0100

    batman-adv: Add IPv4 link-local/IPv6-ll-all-nodes multicast support
    
    With this patch a node may additionally perform the dropping or
    unicasting behaviour for a link-local IPv4 and link-local-all-nodes
    IPv6 multicast packet, too.
    
    The extra counter and BATADV_MCAST_WANT_ALL_UNSNOOPABLES flag is needed
    because with a future bridge snooping support integration a node with a
    bridge on top of its soft interface is not able to reliably detect its
    multicast listeners for IPv4 link-local and the IPv6
    link-local-all-nodes addresses anymore (see RFC4541, section 2.1.2.2
    and section 3).
    
    Even though this new flag does make "no difference" now, it'll ensure
    a seamless integration of multicast bridge support without needing to
    break compatibility later.
    
    Also note, that even with multicast bridge support it won't be possible
    to optimize 224.0.0.x and ff02::1 towards nodes with bridges, they will
    always receive these ranges.
    
    Signed-off-by: Linus Lüssing <linus.luessing@web.de>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 1a643fe647e1..db6fecaddb9c 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -710,6 +710,7 @@ static int batadv_softif_init_late(struct net_device *dev)
 	bat_priv->mcast.flags = BATADV_NO_FLAGS;
 	atomic_set(&bat_priv->multicast_mode, 1);
 	atomic_set(&bat_priv->mcast.num_disabled, 0);
+	atomic_set(&bat_priv->mcast.num_want_all_unsnoopables, 0);
 #endif
 	atomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);
 	atomic_set(&bat_priv->gw_sel_class, 20);

commit 1d8ab8d3c176d31530b3ffd4547cf731018e2a45
Author: Linus Lüssing <linus.luessing@web.de>
Date:   Sat Feb 15 17:47:52 2014 +0100

    batman-adv: Modified forwarding behaviour for multicast packets
    
    With this patch a multicast packet is not always simply flooded anymore,
    the behaviour for the following cases is changed to reduce
    unnecessary overhead:
    
    If all nodes within the horizon of a certain node have signalized
    multicast listener announcement capability then an IPv6 multicast packet
    with a destination of IPv6 link-local scope (excluding ff02::1) coming
    from the upstream of this node...
    
    * ...is dropped if there is no according multicast listener in the
      translation table,
    * ...is forwarded via unicast if there is a single node with interested
      multicast listeners
    * ...and otherwise still gets flooded.
    
    Signed-off-by: Linus Lüssing <linus.luessing@web.de>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 8ff47b7a0e04..1a643fe647e1 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -32,6 +32,7 @@
 #include <linux/ethtool.h>
 #include <linux/etherdevice.h>
 #include <linux/if_vlan.h>
+#include "multicast.h"
 #include "bridge_loop_avoidance.h"
 #include "network-coding.h"
 
@@ -170,6 +171,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	unsigned short vid;
 	uint32_t seqno;
 	int gw_mode;
+	enum batadv_forw_mode forw_mode;
+	struct batadv_orig_node *mcast_single_orig = NULL;
 
 	if (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)
 		goto dropped;
@@ -247,9 +250,19 @@ static int batadv_interface_tx(struct sk_buff *skb,
 			 * directed to a DHCP server
 			 */
 			goto dropped;
-	}
 
 send:
+		if (do_bcast && !is_broadcast_ether_addr(ethhdr->h_dest)) {
+			forw_mode = batadv_mcast_forw_mode(bat_priv, skb,
+							   &mcast_single_orig);
+			if (forw_mode == BATADV_FORW_NONE)
+				goto dropped;
+
+			if (forw_mode == BATADV_FORW_SINGLE)
+				do_bcast = false;
+		}
+	}
+
 	batadv_skb_set_priority(skb, 0);
 
 	/* ethernet packet should be broadcasted */
@@ -301,6 +314,10 @@ static int batadv_interface_tx(struct sk_buff *skb,
 			if (ret)
 				goto dropped;
 			ret = batadv_send_skb_via_gw(bat_priv, skb, vid);
+		} else if (mcast_single_orig) {
+			ret = batadv_send_skb_unicast(bat_priv, skb,
+						      BATADV_UNICAST, 0,
+						      mcast_single_orig, vid);
 		} else {
 			if (batadv_dat_snoop_outgoing_arp_request(bat_priv,
 								  skb))
@@ -691,6 +708,7 @@ static int batadv_softif_init_late(struct net_device *dev)
 #endif
 #ifdef CONFIG_BATMAN_ADV_MCAST
 	bat_priv->mcast.flags = BATADV_NO_FLAGS;
+	atomic_set(&bat_priv->multicast_mode, 1);
 	atomic_set(&bat_priv->mcast.num_disabled, 0);
 #endif
 	atomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);

commit 60432d756cf06e597ef9da511402dd059b112447
Author: Linus Lüssing <linus.luessing@web.de>
Date:   Sat Feb 15 17:47:51 2014 +0100

    batman-adv: Announce new capability via multicast TVLV
    
    If the soft interface of a node is not part of a bridge then a node
    announces a new multicast TVLV: The existence of this TVLV
    signalizes that this node is announcing all of its multicast listeners
    via the translation table infrastructure.
    
    Signed-off-by: Linus Lüssing <linus.luessing@web.de>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 633e9d67d925..8ff47b7a0e04 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -688,6 +688,10 @@ static int batadv_softif_init_late(struct net_device *dev)
 #endif
 #ifdef CONFIG_BATMAN_ADV_DAT
 	atomic_set(&bat_priv->distributed_arp_table, 1);
+#endif
+#ifdef CONFIG_BATMAN_ADV_MCAST
+	bat_priv->mcast.flags = BATADV_NO_FLAGS;
+	atomic_set(&bat_priv->mcast.num_disabled, 0);
 #endif
 	atomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);
 	atomic_set(&bat_priv->gw_sel_class, 20);

commit af63fde5037963b03889dd22833df502532390c0
Author: Marek Lindner <mareklindner@neomailbox.ch>
Date:   Sat Feb 8 23:28:18 2014 +0800

    batman-adv: call unregister_netdev() to have it handle the locking for us
    
    Reported-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index db3e46783c6b..633e9d67d925 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -652,10 +652,7 @@ static void batadv_softif_destroy_finish(struct work_struct *work)
 	}
 
 	batadv_sysfs_del_meshif(soft_iface);
-
-	rtnl_lock();
-	unregister_netdevice(soft_iface);
-	rtnl_unlock();
+	unregister_netdev(soft_iface);
 }
 
 /**

commit 8fdd01530cda849ba531e7e9d8674fbc81ab5782
Author: Antonio Quartulli <antonio@meshcoding.com>
Date:   Wed Jan 22 00:42:11 2014 +0100

    batman-adv: prefer ether_addr_copy to memcpy
    
    On some architectures ether_addr_copy() is slightly faster
    than memcpy() therefore use the former when possible.
    
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c4392fcd4eb0..db3e46783c6b 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -111,8 +111,8 @@ static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 	if (!is_valid_ether_addr(addr->sa_data))
 		return -EADDRNOTAVAIL;
 
-	memcpy(old_addr, dev->dev_addr, ETH_ALEN);
-	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
+	ether_addr_copy(old_addr, dev->dev_addr);
+	ether_addr_copy(dev->dev_addr, addr->sa_data);
 
 	/* only modify transtable if it has been initialized before */
 	if (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_ACTIVE) {
@@ -279,8 +279,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		/* hw address of first interface is the orig mac because only
 		 * this mac is known throughout the mesh
 		 */
-		memcpy(bcast_packet->orig,
-		       primary_if->net_dev->dev_addr, ETH_ALEN);
+		ether_addr_copy(bcast_packet->orig,
+				primary_if->net_dev->dev_addr);
 
 		/* set broadcast sequence number */
 		seqno = atomic_inc_return(&bat_priv->bcast_seqno);

commit 927c2ed7e5879a96759aadda94404d516ce9fb42
Author: Linus Lüssing <linus.luessing@web.de>
Date:   Sun Jan 19 22:22:45 2014 +0100

    batman-adv: use vlan_/eth_hdr() instead of skb->data in interface_tx path
    
    Our .ndo_start_xmit handler (batadv_interface_tx()) can rely on having
    the skb mac header pointer set correctly since the following commit
    present in kernels >= 3.9:
    
    "net: reset mac header in dev_start_xmit()" (6d1ccff627)
    
    Therefore we can safely use eth_hdr() and vlan_eth_hdr() instead of
    skb->data now, which spares us some ugly type casts.
    
    At the same time set the mac_header in batadv_dat_snoop_incoming_arp_request()
    before sending the skb along the TX path.
    
    Signed-off-by: Linus Lüssing <linus.luessing@web.de>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index f82c267e1886..c4392fcd4eb0 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -176,11 +176,11 @@ static int batadv_interface_tx(struct sk_buff *skb,
 
 	soft_iface->trans_start = jiffies;
 	vid = batadv_get_vid(skb, 0);
-	ethhdr = (struct ethhdr *)skb->data;
+	ethhdr = eth_hdr(skb);
 
 	switch (ntohs(ethhdr->h_proto)) {
 	case ETH_P_8021Q:
-		vhdr = (struct vlan_ethhdr *)skb->data;
+		vhdr = vlan_eth_hdr(skb);
 
 		if (vhdr->h_vlan_encapsulated_proto != ethertype)
 			break;
@@ -194,7 +194,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		goto dropped;
 
 	/* skb->data might have been reallocated by batadv_bla_tx() */
-	ethhdr = (struct ethhdr *)skb->data;
+	ethhdr = eth_hdr(skb);
 
 	/* Register the client MAC in the transtable */
 	if (!is_multicast_ether_addr(ethhdr->h_source)) {
@@ -230,7 +230,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		/* skb->data may have been modified by
 		 * batadv_gw_dhcp_recipient_get()
 		 */
-		ethhdr = (struct ethhdr *)skb->data;
+		ethhdr = eth_hdr(skb);
 		/* if gw_mode is on, broadcast any non-DHCP message.
 		 * All the DHCP packets are going to be sent as unicast
 		 */

commit e19f9759edf811c94cf6f2dd67d08e6c86260741
Author: Simon Wunderlich <sw@simonwunderlich.de>
Date:   Sat Jan 4 18:04:25 2014 +0100

    batman-adv: update copyright years for 2014
    
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 2dc22702dd11..f82c267e1886 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2007-2013 B.A.T.M.A.N. contributors:
+/* Copyright (C) 2007-2014 B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
  *

commit c039876892e3247928ce5ad3d0ba46aee7d7099a
Author: Simon Wunderlich <simon@open-mesh.com>
Date:   Wed Nov 13 19:14:48 2013 +0100

    batman-adv: add WiFi penalty
    
    If the same interface is used for sending and receiving, there might be
    throughput degradation on half-duplex interfaces such as WiFi. Add a
    penalty if the same interface is used to reflect this problem in the
    metric. At the same time, change the hop penalty from 30 to 15 so there
    will be no change for single wifi mesh network. the effective hop
    penalty will stay at 30 due to the new wifi penalty for these networks.
    
    Signed-off-by: Simon Wunderlich <simon@open-mesh.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c50f64337f55..2dc22702dd11 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -697,7 +697,7 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->gw.bandwidth_down, 100);
 	atomic_set(&bat_priv->gw.bandwidth_up, 20);
 	atomic_set(&bat_priv->orig_interval, 1000);
-	atomic_set(&bat_priv->hop_penalty, 30);
+	atomic_set(&bat_priv->hop_penalty, 15);
 #ifdef CONFIG_BATMAN_ADV_DEBUG
 	atomic_set(&bat_priv->log_level, 0);
 #endif

commit 42cb0bef0176572e2e826b49d697c653eedd7fce
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Sat Nov 16 12:03:52 2013 +0100

    batman-adv: set the isolation mark in the skb if needed
    
    If a broadcast packet is coming from a client marked as
    isolated, then mark the skb using the isolation mark so
    that netfilter (or any other application) can recognise
    them.
    
    The mark is written in the skb based on the mask value:
    only bits set in the mask are substitued by those in the
    mark value
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e126d74da6b8..c50f64337f55 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -399,9 +399,23 @@ void batadv_interface_rx(struct net_device *soft_iface,
 		batadv_tt_add_temporary_global_entry(bat_priv, orig_node,
 						     ethhdr->h_source, vid);
 
-	if (batadv_is_ap_isolated(bat_priv, ethhdr->h_source, ethhdr->h_dest,
-				  vid))
+	if (is_multicast_ether_addr(ethhdr->h_dest)) {
+		/* set the mark on broadcast packets if AP isolation is ON and
+		 * the packet is coming from an "isolated" client
+		 */
+		if (batadv_vlan_ap_isola_get(bat_priv, vid) &&
+		    batadv_tt_global_is_isolated(bat_priv, ethhdr->h_source,
+						 vid)) {
+			/* save bits in skb->mark not covered by the mask and
+			 * apply the mark on the rest
+			 */
+			skb->mark &= ~bat_priv->isolation_mark_mask;
+			skb->mark |= bat_priv->isolation_mark;
+		}
+	} else if (batadv_is_ap_isolated(bat_priv, ethhdr->h_source,
+					 ethhdr->h_dest, vid)) {
 		goto dropped;
+	}
 
 	netif_rx(skb);
 	goto out;

commit 9464d07188c5322957427a456d12d945370f7b29
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Sat Nov 16 12:03:48 2013 +0100

    batman-adv: mark a local client as isolated when needed
    
    A client sending packets which mark matches the value
    configured via sysfs has to be identified as isolated using
    the TT_CLIENT_ISOLA flag.
    
    The match is mask based, meaning that only bits set in the
    mask are compared with those in the mark value.
    
    If the configured mask is equal to 0 no operation is
    performed.
    
    Such flag is then advertised within the classic client
    announcement mechanism.
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 35a82e36c003..e126d74da6b8 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -119,7 +119,7 @@ static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 		batadv_tt_local_remove(bat_priv, old_addr, BATADV_NO_FLAGS,
 				       "mac address changed", false);
 		batadv_tt_local_add(dev, addr->sa_data, BATADV_NO_FLAGS,
-				    BATADV_NULL_IFINDEX);
+				    BATADV_NULL_IFINDEX, BATADV_NO_MARK);
 	}
 
 	return 0;
@@ -199,7 +199,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	/* Register the client MAC in the transtable */
 	if (!is_multicast_ether_addr(ethhdr->h_source)) {
 		client_added = batadv_tt_local_add(soft_iface, ethhdr->h_source,
-						   vid, skb->skb_iif);
+						   vid, skb->skb_iif,
+						   skb->mark);
 		if (!client_added)
 			goto dropped;
 	}
@@ -489,7 +490,7 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 	 */
 	batadv_tt_local_add(bat_priv->soft_iface,
 			    bat_priv->soft_iface->dev_addr, vid,
-			    BATADV_NULL_IFINDEX);
+			    BATADV_NULL_IFINDEX, BATADV_NO_MARK);
 
 	spin_lock_bh(&bat_priv->softif_vlan_list_lock);
 	hlist_add_head_rcu(&vlan->list, &bat_priv->softif_vlan_list);

commit c42edfe382fee1c2c74550a5a3cbf50b2a28cf07
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Sat Nov 16 12:03:47 2013 +0100

    batman-adv: add isolation_mark sysfs attribute
    
    This attribute can be used to set and read the value and the
    mask of the skb mark which will be used to classify the
    source non-mesh client as ISOLATED. In this way a client can
    be advertised as such and the mark can potentially be
    restored at the receiving node before delivering the skb.
    
    This can be helpful for creating network wide netfilter
    policies.
    
    This sysfs file expects a string of the shape "$mark/$mask".
    Where $mark has to be a 32-bit number in any base, while
    $mask must be a 32bit mask expressed in hex base. Only bits
    in $mark covered by the bitmask are really stored.
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b569932ddcc4..35a82e36c003 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -701,6 +701,8 @@ static int batadv_softif_init_late(struct net_device *dev)
 #endif
 	bat_priv->tt.last_changeset = NULL;
 	bat_priv->tt.last_changeset_len = 0;
+	bat_priv->isolation_mark = 0;
+	bat_priv->isolation_mark_mask = 0;
 
 	/* randomize initial seqno to avoid collision */
 	get_random_bytes(&random_seqno, sizeof(random_seqno));

commit 6c413b1c22a2c4ef324f1c6f2c282f1ca10a93b9
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Tue Nov 5 19:31:08 2013 +0100

    batman-adv: send every DHCP packet as bat-unicast
    
    In different situations it is possible that the DHCP server
    or client uses broadcast Ethernet frames to send messages
    to each other. The GW component in batman-adv takes care of
    using bat-unicast packets to bring broadcast DHCP
    Discover/Requests to the "best" server.
    
    On the way back the DHCP server usually sends unicasts,
    but upon client request it may decide to use broadcasts as
    well.
    
    This patch improves the GW component so that it now snoops
    and sends as unicast all the DHCP packets, no matter if they
    were generated by a DHCP server or client.
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 3686be7805f3..b569932ddcc4 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -160,6 +160,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 						   0x00, 0x00};
 	static const uint8_t ectp_addr[ETH_ALEN] = {0xCF, 0x00, 0x00, 0x00,
 						    0x00, 0x00};
+	enum batadv_dhcp_recipient dhcp_rcp = BATADV_DHCP_NO;
+	uint8_t *dst_hint = NULL, chaddr[ETH_ALEN];
 	struct vlan_ethhdr *vhdr;
 	unsigned int header_len = 0;
 	int data_len = skb->len, ret;
@@ -167,6 +169,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	bool do_bcast = false, client_added;
 	unsigned short vid;
 	uint32_t seqno;
+	int gw_mode;
 
 	if (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)
 		goto dropped;
@@ -213,36 +216,39 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	if (batadv_compare_eth(ethhdr->h_dest, ectp_addr))
 		goto dropped;
 
+	gw_mode = atomic_read(&bat_priv->gw_mode);
 	if (is_multicast_ether_addr(ethhdr->h_dest)) {
-		do_bcast = true;
-
-		switch (atomic_read(&bat_priv->gw_mode)) {
-		case BATADV_GW_MODE_SERVER:
-			/* gateway servers should not send dhcp
-			 * requests into the mesh
-			 */
-			ret = batadv_gw_is_dhcp_target(skb, &header_len);
-			if (ret)
-				goto dropped;
-			break;
-		case BATADV_GW_MODE_CLIENT:
-			/* gateway clients should send dhcp requests
-			 * via unicast to their gateway
-			 */
-			ret = batadv_gw_is_dhcp_target(skb, &header_len);
-			if (ret)
-				do_bcast = false;
-			break;
-		case BATADV_GW_MODE_OFF:
-		default:
-			break;
+		/* if gw mode is off, broadcast every packet */
+		if (gw_mode == BATADV_GW_MODE_OFF) {
+			do_bcast = true;
+			goto send;
 		}
 
-		/* reminder: ethhdr might have become unusable from here on
-		 * (batadv_gw_is_dhcp_target() might have reallocated skb data)
+		dhcp_rcp = batadv_gw_dhcp_recipient_get(skb, &header_len,
+							chaddr);
+		/* skb->data may have been modified by
+		 * batadv_gw_dhcp_recipient_get()
 		 */
+		ethhdr = (struct ethhdr *)skb->data;
+		/* if gw_mode is on, broadcast any non-DHCP message.
+		 * All the DHCP packets are going to be sent as unicast
+		 */
+		if (dhcp_rcp == BATADV_DHCP_NO) {
+			do_bcast = true;
+			goto send;
+		}
+
+		if (dhcp_rcp == BATADV_DHCP_TO_CLIENT)
+			dst_hint = chaddr;
+		else if ((gw_mode == BATADV_GW_MODE_SERVER) &&
+			 (dhcp_rcp == BATADV_DHCP_TO_SERVER))
+			/* gateways should not forward any DHCP message if
+			 * directed to a DHCP server
+			 */
+			goto dropped;
 	}
 
+send:
 	batadv_skb_set_priority(skb, 0);
 
 	/* ethernet packet should be broadcasted */
@@ -288,22 +294,22 @@ static int batadv_interface_tx(struct sk_buff *skb,
 
 	/* unicast packet */
 	} else {
-		if (atomic_read(&bat_priv->gw_mode) != BATADV_GW_MODE_OFF) {
+		/* DHCP packets going to a server will use the GW feature */
+		if (dhcp_rcp == BATADV_DHCP_TO_SERVER) {
 			ret = batadv_gw_out_of_range(bat_priv, skb);
 			if (ret)
 				goto dropped;
-		}
-
-		if (batadv_dat_snoop_outgoing_arp_request(bat_priv, skb))
-			goto dropped;
-
-		batadv_dat_snoop_outgoing_arp_reply(bat_priv, skb);
-
-		if (is_multicast_ether_addr(ethhdr->h_dest))
 			ret = batadv_send_skb_via_gw(bat_priv, skb, vid);
-		else
-			ret = batadv_send_skb_via_tt(bat_priv, skb, vid);
+		} else {
+			if (batadv_dat_snoop_outgoing_arp_request(bat_priv,
+								  skb))
+				goto dropped;
 
+			batadv_dat_snoop_outgoing_arp_reply(bat_priv, skb);
+
+			ret = batadv_send_skb_via_tt(bat_priv, skb, dst_hint,
+						     vid);
+		}
 		if (ret == NET_XMIT_DROP)
 			goto dropped_freed;
 	}

commit ebf38fb7ab18ba60460bbd03de760ad5a2f435eb
Author: Antonio Quartulli <antonio@meshcoding.com>
Date:   Sun Nov 3 20:40:48 2013 +0100

    batman-adv: remove FSF address from GPL disclaimer
    
    As suggested by checkpatch, remove all the references to the
    FSF address since the kernel already has one reference in
    its documentation.
    
    In this way it is easier to update it in case of future
    changes.
    
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index a8f99d1486c0..3686be7805f3 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -12,9 +12,7 @@
  * General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
- * 02110-1301, USA
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "main.h"

commit 2b1e2cb3594df80446dc33bb8e12230da11f38ff
Author: Antonio Quartulli <antonio@meshcoding.com>
Date:   Mon Dec 23 21:43:39 2013 +0100

    batman-adv: fix vlan header access
    
    When batadv_get_vid() is invoked in interface_rx() the
    batman-adv header has already been removed, therefore
    the header_len argument has to be 0.
    
    Introduced by c018ad3de61a1dc4194879a53e5559e094aa7b1a
    ("batman-adv: add the VLAN ID attribute to the TT entry")
    
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 875a702542c2..a8f99d1486c0 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -351,7 +351,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	 */
 	nf_reset(skb);
 
-	vid = batadv_get_vid(skb, hdr_size);
+	vid = batadv_get_vid(skb, 0);
 	ethhdr = eth_hdr(skb);
 
 	switch (ntohs(ethhdr->h_proto)) {

commit 55883fd1048e09f5b6e1edaf0caf7e4f6f31f971
Author: Antonio Quartulli <antonio@meshcoding.com>
Date:   Mon Dec 23 01:28:05 2013 +0100

    batman-adv: clean nf state when removing protocol header
    
    If an interface enslaved into batman-adv is a bridge (or a
    virtual interface built on top of a bridge) the nf_bridge
    member of the skbs reaching the soft-interface is filled
    with the state about "netfilter bridge" operations.
    
    Then, if one of such skbs is locally delivered, the nf_bridge
    member should be cleaned up to avoid that the old state
    could mess up with other "netfilter bridge" operations when
    entering a second bridge.
    This is needed because batman-adv is an encapsulation
    protocol.
    
    However at the moment skb->nf_bridge is not released at all
    leading to bogus "netfilter bridge" behaviours.
    
    Fix this by cleaning the netfilter state of the skb before
    it gets delivered to the upper layer in interface_rx().
    
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b4881f8e28e8..875a702542c2 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -346,6 +346,11 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	skb_pull_rcsum(skb, hdr_size);
 	skb_reset_mac_header(skb);
 
+	/* clean the netfilter state now that the batman-adv header has been
+	 * removed
+	 */
+	nf_reset(skb);
+
 	vid = batadv_get_vid(skb, hdr_size);
 	ethhdr = eth_hdr(skb);
 

commit a40d9b075c21f06872de3f05cc2eb3d06665e2ff
Author: Simon Wunderlich <sw@simonwunderlich.de>
Date:   Mon Dec 2 20:38:31 2013 +0100

    batman-adv: fix header alignment by unrolling batadv_header
    
    The size of the batadv_header of 3 is problematic on some architectures
    which automatically pad all structures to a 32 bit boundary. To not lose
    performance by packing this struct, better embed it into the various
    host structures.
    
    Reported-by: Russell King <linux@arm.linux.org.uk>
    Signed-off-by: Simon Wunderlich <sw@simonwunderlich.de>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 36f050876f82..b4881f8e28e8 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -264,11 +264,11 @@ static int batadv_interface_tx(struct sk_buff *skb,
 			goto dropped;
 
 		bcast_packet = (struct batadv_bcast_packet *)skb->data;
-		bcast_packet->header.version = BATADV_COMPAT_VERSION;
-		bcast_packet->header.ttl = BATADV_TTL;
+		bcast_packet->version = BATADV_COMPAT_VERSION;
+		bcast_packet->ttl = BATADV_TTL;
 
 		/* batman packet type: broadcast */
-		bcast_packet->header.packet_type = BATADV_BCAST;
+		bcast_packet->packet_type = BATADV_BCAST;
 		bcast_packet->reserved = 0;
 
 		/* hw address of first interface is the orig mac because only
@@ -328,7 +328,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 			 struct sk_buff *skb, struct batadv_hard_iface *recv_if,
 			 int hdr_size, struct batadv_orig_node *orig_node)
 {
-	struct batadv_header *batadv_header = (struct batadv_header *)skb->data;
+	struct batadv_bcast_packet *batadv_bcast_packet;
 	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
 	__be16 ethertype = htons(ETH_P_BATMAN);
 	struct vlan_ethhdr *vhdr;
@@ -336,7 +336,8 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	unsigned short vid;
 	bool is_bcast;
 
-	is_bcast = (batadv_header->packet_type == BATADV_BCAST);
+	batadv_bcast_packet = (struct batadv_bcast_packet *)skb->data;
+	is_bcast = (batadv_bcast_packet->packet_type == BATADV_BCAST);
 
 	/* check if enough space is available for pulling, and pull */
 	if (!pskb_may_pull(skb, hdr_size))

commit a19d3d85e1b854e4a483a55d740a42458085560d
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Mon May 27 15:33:25 2013 +0800

    batman-adv: limit local translation table max size
    
    The local translation table size is limited by what can be
    transferred from one node to another via a full table request.
    
    The number of entries fitting into a full table request depend
    on whether the fragmentation is enabled or not. Therefore this
    patch introduces a max table size check and refuses to add
    more local clients when that size is reached. Moreover, if the
    max full table packet size changes (MTU change or fragmentation
    is disabled) the local table is downsized instantaneously.
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Acked-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e70f530d8568..36f050876f82 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -166,7 +166,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	unsigned int header_len = 0;
 	int data_len = skb->len, ret;
 	unsigned long brd_delay = 1;
-	bool do_bcast = false;
+	bool do_bcast = false, client_added;
 	unsigned short vid;
 	uint32_t seqno;
 
@@ -196,9 +196,12 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	ethhdr = (struct ethhdr *)skb->data;
 
 	/* Register the client MAC in the transtable */
-	if (!is_multicast_ether_addr(ethhdr->h_source))
-		batadv_tt_local_add(soft_iface, ethhdr->h_source, vid,
-				    skb->skb_iif);
+	if (!is_multicast_ether_addr(ethhdr->h_source)) {
+		client_added = batadv_tt_local_add(soft_iface, ethhdr->h_source,
+						   vid, skb->skb_iif);
+		if (!client_added)
+			goto dropped;
+	}
 
 	/* don't accept stp packets. STP does not help in meshes.
 	 * better use the bridge loop avoidance ...
@@ -674,6 +677,7 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->log_level, 0);
 #endif
 	atomic_set(&bat_priv->fragmentation, 1);
+	atomic_set(&bat_priv->packet_size_max, ETH_DATA_LEN);
 	atomic_set(&bat_priv->bcast_queue_left, BATADV_BCAST_QUEUE_LEN);
 	atomic_set(&bat_priv->batman_queue_left, BATADV_BATMAN_QUEUE_LEN);
 

commit e300d314664ef6746e697d5b581f85114ab1f843
Author: Linus Lüssing <linus.luessing@web.de>
Date:   Wed Jul 3 10:40:00 2013 +0200

    batman-adv: refine API calls for unicast transmissions of SKBs
    
    With this patch the functions batadv_send_skb_unicast() and
    batadv_send_skb_unicast_4addr() are further refined into
    batadv_send_skb_via_tt(), batadv_send_skb_via_tt_4addr() and
    batadv_send_skb_via_gw(). This way we avoid any "guessing" about where to send
    a packet in the unicast forwarding methods and let the callers decide.
    
    This is going to be useful for the upcoming multicast related patches in
    particular.
    
    Further, the return values were polished a little to use the more
    appropriate NET_XMIT_* defines.
    
    Signed-off-by: Linus Lüssing <linus.luessing@web.de>
    Acked-by: Antonio Quartulli <antonio@meshcoding.com>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index baa74b976c6d..e70f530d8568 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -298,8 +298,12 @@ static int batadv_interface_tx(struct sk_buff *skb,
 
 		batadv_dat_snoop_outgoing_arp_reply(bat_priv, skb);
 
-		ret = batadv_send_skb_unicast(bat_priv, skb, vid);
-		if (ret != 0)
+		if (is_multicast_ether_addr(ethhdr->h_dest))
+			ret = batadv_send_skb_via_gw(bat_priv, skb, vid);
+		else
+			ret = batadv_send_skb_via_tt(bat_priv, skb, vid);
+
+		if (ret == NET_XMIT_DROP)
 			goto dropped_freed;
 	}
 

commit b8cbd81d0944cd2dc097b2b4ae8adaf639c5b4df
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Tue Jul 2 11:04:36 2013 +0200

    batman-adv: make the AP isolation attribute VLAN specific
    
    AP isolation has to be enabled on one VLAN interface only.
    This patch moves the AP isolation attribute to the per-vlan
    interface attribute set, enabling it to have a different
    value depending on the selected vlan.
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index f74200c7e553..baa74b976c6d 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -381,7 +381,8 @@ void batadv_interface_rx(struct net_device *soft_iface,
 		batadv_tt_add_temporary_global_entry(bat_priv, orig_node,
 						     ethhdr->h_source, vid);
 
-	if (batadv_is_ap_isolated(bat_priv, ethhdr->h_source, ethhdr->h_dest))
+	if (batadv_is_ap_isolated(bat_priv, ethhdr->h_source, ethhdr->h_dest,
+				  vid))
 		goto dropped;
 
 	netif_rx(skb);
@@ -458,6 +459,8 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 	vlan->vid = vid;
 	atomic_set(&vlan->refcount, 1);
 
+	atomic_set(&vlan->ap_isolation, 0);
+
 	err = batadv_sysfs_add_vlan(bat_priv->soft_iface, vlan);
 	if (err) {
 		kfree(vlan);
@@ -657,7 +660,6 @@ static int batadv_softif_init_late(struct net_device *dev)
 #ifdef CONFIG_BATMAN_ADV_DAT
 	atomic_set(&bat_priv->distributed_arp_table, 1);
 #endif
-	atomic_set(&bat_priv->ap_isolation, 0);
 	atomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);
 	atomic_set(&bat_priv->gw_sel_class, 20);
 	atomic_set(&bat_priv->gw.bandwidth_down, 100);

commit 90f4435da43191025712fdcf6b0dc09c018456e9
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Tue Jul 2 11:04:35 2013 +0200

    batman-adv: add sysfs framework for VLAN
    
    Each VLAN can now have its own set of attributes which are
    exported through a new subfolder in the sysfs tree.
    Each VLAN created on top of a soft_iface will have its own
    subfolder.
    
    The subfolder is named "vlan%VID" and it is created inside
    the "mesh" sysfs folder belonging to batman-adv.
    
    Attributes corresponding to the untagged LAN are stored in
    the root sysfs folder as before.
    
    This patch also creates all the needed macros and data
    structures to easily handle new VLAN spacific attributes.
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 936b83bb02de..f74200c7e553 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -398,7 +398,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
  *  possibly free it
  * @softif_vlan: the vlan object to release
  */
-static void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *softif_vlan)
+void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *softif_vlan)
 {
 	if (atomic_dec_and_test(&softif_vlan->refcount))
 		kfree_rcu(softif_vlan, rcu);
@@ -412,8 +412,8 @@ static void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *softif_vlan)
  * Returns the private data of the vlan matching the vid passed as argument or
  * NULL otherwise. The refcounter of the returned object is incremented by 1.
  */
-static struct batadv_softif_vlan *
-batadv_softif_vlan_get(struct batadv_priv *bat_priv, unsigned short vid)
+struct batadv_softif_vlan *batadv_softif_vlan_get(struct batadv_priv *bat_priv,
+						  unsigned short vid)
 {
 	struct batadv_softif_vlan *vlan_tmp, *vlan = NULL;
 
@@ -443,6 +443,7 @@ batadv_softif_vlan_get(struct batadv_priv *bat_priv, unsigned short vid)
 int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 {
 	struct batadv_softif_vlan *vlan;
+	int err;
 
 	vlan = batadv_softif_vlan_get(bat_priv, vid);
 	if (vlan) {
@@ -457,6 +458,12 @@ int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
 	vlan->vid = vid;
 	atomic_set(&vlan->refcount, 1);
 
+	err = batadv_sysfs_add_vlan(bat_priv->soft_iface, vlan);
+	if (err) {
+		kfree(vlan);
+		return err;
+	}
+
 	/* add a new TT local entry. This one will be marked with the NOPURGE
 	 * flag
 	 */
@@ -483,6 +490,8 @@ static void batadv_softif_destroy_vlan(struct batadv_priv *bat_priv,
 	hlist_del_rcu(&vlan->list);
 	spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
 
+	batadv_sysfs_del_vlan(bat_priv, vlan);
+
 	/* explicitly remove the associated TT local entry because it is marked
 	 * with the NOPURGE flag
 	 */

commit 5d2c05b213377694a2aa8ce1ed9b23f7c39b0569
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Tue Jul 2 11:04:34 2013 +0200

    batman-adv: add per VLAN interface attribute framework
    
    Since batman-adv is now fully VLAN-aware, a proper framework
    able to handle per-vlan-interface attributes is needed.
    
    Those attributes will affect the associated VLAN interface
    only, rather than the real soft_iface (which would result
    in every vlan interface having the same attribute
    configuration).
    
    To make the code simpler and easier to extend, attributes
    associated to the standalone soft_iface are now treated
    like belonging to yet another vlan having a special vid.
    This vid is different from the others because it is made up
    by all zeros and the VLAN_HAS_TAG bit is not set.
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 279e91d570a7..936b83bb02de 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -393,6 +393,166 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	return;
 }
 
+/**
+ * batadv_softif_vlan_free_ref - decrease the vlan object refcounter and
+ *  possibly free it
+ * @softif_vlan: the vlan object to release
+ */
+static void batadv_softif_vlan_free_ref(struct batadv_softif_vlan *softif_vlan)
+{
+	if (atomic_dec_and_test(&softif_vlan->refcount))
+		kfree_rcu(softif_vlan, rcu);
+}
+
+/**
+ * batadv_softif_vlan_get - get the vlan object for a specific vid
+ * @bat_priv: the bat priv with all the soft interface information
+ * @vid: the identifier of the vlan object to retrieve
+ *
+ * Returns the private data of the vlan matching the vid passed as argument or
+ * NULL otherwise. The refcounter of the returned object is incremented by 1.
+ */
+static struct batadv_softif_vlan *
+batadv_softif_vlan_get(struct batadv_priv *bat_priv, unsigned short vid)
+{
+	struct batadv_softif_vlan *vlan_tmp, *vlan = NULL;
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(vlan_tmp, &bat_priv->softif_vlan_list, list) {
+		if (vlan_tmp->vid != vid)
+			continue;
+
+		if (!atomic_inc_not_zero(&vlan_tmp->refcount))
+			continue;
+
+		vlan = vlan_tmp;
+		break;
+	}
+	rcu_read_unlock();
+
+	return vlan;
+}
+
+/**
+ * batadv_create_vlan - allocate the needed resources for a new vlan
+ * @bat_priv: the bat priv with all the soft interface information
+ * @vid: the VLAN identifier
+ *
+ * Returns 0 on success, a negative error otherwise.
+ */
+int batadv_softif_create_vlan(struct batadv_priv *bat_priv, unsigned short vid)
+{
+	struct batadv_softif_vlan *vlan;
+
+	vlan = batadv_softif_vlan_get(bat_priv, vid);
+	if (vlan) {
+		batadv_softif_vlan_free_ref(vlan);
+		return -EEXIST;
+	}
+
+	vlan = kzalloc(sizeof(*vlan), GFP_ATOMIC);
+	if (!vlan)
+		return -ENOMEM;
+
+	vlan->vid = vid;
+	atomic_set(&vlan->refcount, 1);
+
+	/* add a new TT local entry. This one will be marked with the NOPURGE
+	 * flag
+	 */
+	batadv_tt_local_add(bat_priv->soft_iface,
+			    bat_priv->soft_iface->dev_addr, vid,
+			    BATADV_NULL_IFINDEX);
+
+	spin_lock_bh(&bat_priv->softif_vlan_list_lock);
+	hlist_add_head_rcu(&vlan->list, &bat_priv->softif_vlan_list);
+	spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
+
+	return 0;
+}
+
+/**
+ * batadv_softif_destroy_vlan - remove and destroy a softif_vlan object
+ * @bat_priv: the bat priv with all the soft interface information
+ * @vlan: the object to remove
+ */
+static void batadv_softif_destroy_vlan(struct batadv_priv *bat_priv,
+				       struct batadv_softif_vlan *vlan)
+{
+	spin_lock_bh(&bat_priv->softif_vlan_list_lock);
+	hlist_del_rcu(&vlan->list);
+	spin_unlock_bh(&bat_priv->softif_vlan_list_lock);
+
+	/* explicitly remove the associated TT local entry because it is marked
+	 * with the NOPURGE flag
+	 */
+	batadv_tt_local_remove(bat_priv, bat_priv->soft_iface->dev_addr,
+			       vlan->vid, "vlan interface destroyed", false);
+
+	batadv_softif_vlan_free_ref(vlan);
+}
+
+/**
+ * batadv_interface_add_vid - ndo_add_vid API implementation
+ * @dev: the netdev of the mesh interface
+ * @vid: identifier of the new vlan
+ *
+ * Set up all the internal structures for handling the new vlan on top of the
+ * mesh interface
+ *
+ * Returns 0 on success or a negative error code in case of failure.
+ */
+static int batadv_interface_add_vid(struct net_device *dev, __be16 proto,
+				    unsigned short vid)
+{
+	struct batadv_priv *bat_priv = netdev_priv(dev);
+
+	/* only 802.1Q vlans are supported.
+	 * batman-adv does not know how to handle other types
+	 */
+	if (proto != htons(ETH_P_8021Q))
+		return -EINVAL;
+
+	vid |= BATADV_VLAN_HAS_TAG;
+
+	return batadv_softif_create_vlan(bat_priv, vid);
+}
+
+/**
+ * batadv_interface_kill_vid - ndo_kill_vid API implementation
+ * @dev: the netdev of the mesh interface
+ * @vid: identifier of the deleted vlan
+ *
+ * Destroy all the internal structures used to handle the vlan identified by vid
+ * on top of the mesh interface
+ *
+ * Returns 0 on success, -EINVAL if the specified prototype is not ETH_P_8021Q
+ * or -ENOENT if the specified vlan id wasn't registered.
+ */
+static int batadv_interface_kill_vid(struct net_device *dev, __be16 proto,
+				     unsigned short vid)
+{
+	struct batadv_priv *bat_priv = netdev_priv(dev);
+	struct batadv_softif_vlan *vlan;
+
+	/* only 802.1Q vlans are supported. batman-adv does not know how to
+	 * handle other types
+	 */
+	if (proto != htons(ETH_P_8021Q))
+		return -EINVAL;
+
+	vlan = batadv_softif_vlan_get(bat_priv, vid | BATADV_VLAN_HAS_TAG);
+	if (!vlan)
+		return -ENOENT;
+
+	batadv_softif_destroy_vlan(bat_priv, vlan);
+
+	/* finally free the vlan object */
+	batadv_softif_vlan_free_ref(vlan);
+
+	return 0;
+}
+
 /* batman-adv network devices have devices nesting below it and are a special
  * "super class" of normal network devices; split their locks off into a
  * separate class since they always nest.
@@ -432,6 +592,7 @@ static void batadv_set_lockdep_class(struct net_device *dev)
  */
 static void batadv_softif_destroy_finish(struct work_struct *work)
 {
+	struct batadv_softif_vlan *vlan;
 	struct batadv_priv *bat_priv;
 	struct net_device *soft_iface;
 
@@ -439,6 +600,13 @@ static void batadv_softif_destroy_finish(struct work_struct *work)
 				cleanup_work);
 	soft_iface = bat_priv->soft_iface;
 
+	/* destroy the "untagged" VLAN */
+	vlan = batadv_softif_vlan_get(bat_priv, BATADV_NO_FLAGS);
+	if (vlan) {
+		batadv_softif_destroy_vlan(bat_priv, vlan);
+		batadv_softif_vlan_free_ref(vlan);
+	}
+
 	batadv_sysfs_del_meshif(soft_iface);
 
 	rtnl_lock();
@@ -594,6 +762,8 @@ static const struct net_device_ops batadv_netdev_ops = {
 	.ndo_open = batadv_interface_open,
 	.ndo_stop = batadv_interface_release,
 	.ndo_get_stats = batadv_interface_stats,
+	.ndo_vlan_rx_add_vid = batadv_interface_add_vid,
+	.ndo_vlan_rx_kill_vid = batadv_interface_kill_vid,
 	.ndo_set_mac_address = batadv_interface_set_mac_addr,
 	.ndo_change_mtu = batadv_interface_change_mtu,
 	.ndo_set_rx_mode = batadv_interface_set_rx_mode,
@@ -633,6 +803,7 @@ static void batadv_softif_init_early(struct net_device *dev)
 
 	dev->netdev_ops = &batadv_netdev_ops;
 	dev->destructor = batadv_softif_free;
+	dev->features |= NETIF_F_HW_VLAN_CTAG_FILTER;
 	dev->tx_queue_len = 0;
 
 	/* can't call min_mtu, because the needed variables

commit c018ad3de61a1dc4194879a53e5559e094aa7b1a
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Tue Jun 4 12:11:39 2013 +0200

    batman-adv: add the VLAN ID attribute to the TT entry
    
    To make the translation table code VLAN-aware, each entry
    must carry the VLAN ID which it belongs to. This patch adds
    such attribute to the related TT structures.
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e8a2bd699d40..279e91d570a7 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -118,9 +118,10 @@ static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 
 	/* only modify transtable if it has been initialized before */
 	if (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_ACTIVE) {
-		batadv_tt_local_remove(bat_priv, old_addr,
+		batadv_tt_local_remove(bat_priv, old_addr, BATADV_NO_FLAGS,
 				       "mac address changed", false);
-		batadv_tt_local_add(dev, addr->sa_data, BATADV_NULL_IFINDEX);
+		batadv_tt_local_add(dev, addr->sa_data, BATADV_NO_FLAGS,
+				    BATADV_NULL_IFINDEX);
 	}
 
 	return 0;
@@ -152,33 +153,33 @@ static void batadv_interface_set_rx_mode(struct net_device *dev)
 static int batadv_interface_tx(struct sk_buff *skb,
 			       struct net_device *soft_iface)
 {
-	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+	struct ethhdr *ethhdr;
 	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
 	struct batadv_hard_iface *primary_if = NULL;
 	struct batadv_bcast_packet *bcast_packet;
-	struct vlan_ethhdr *vhdr;
 	__be16 ethertype = htons(ETH_P_BATMAN);
 	static const uint8_t stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00,
 						   0x00, 0x00};
 	static const uint8_t ectp_addr[ETH_ALEN] = {0xCF, 0x00, 0x00, 0x00,
 						    0x00, 0x00};
+	struct vlan_ethhdr *vhdr;
 	unsigned int header_len = 0;
 	int data_len = skb->len, ret;
-	unsigned short vid __maybe_unused = BATADV_NO_FLAGS;
+	unsigned long brd_delay = 1;
 	bool do_bcast = false;
+	unsigned short vid;
 	uint32_t seqno;
-	unsigned long brd_delay = 1;
 
 	if (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)
 		goto dropped;
 
 	soft_iface->trans_start = jiffies;
+	vid = batadv_get_vid(skb, 0);
+	ethhdr = (struct ethhdr *)skb->data;
 
 	switch (ntohs(ethhdr->h_proto)) {
 	case ETH_P_8021Q:
 		vhdr = (struct vlan_ethhdr *)skb->data;
-		vid = ntohs(vhdr->h_vlan_TCI) & VLAN_VID_MASK;
-		vid |= BATADV_VLAN_HAS_TAG;
 
 		if (vhdr->h_vlan_encapsulated_proto != ethertype)
 			break;
@@ -196,7 +197,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 
 	/* Register the client MAC in the transtable */
 	if (!is_multicast_ether_addr(ethhdr->h_source))
-		batadv_tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
+		batadv_tt_local_add(soft_iface, ethhdr->h_source, vid,
+				    skb->skb_iif);
 
 	/* don't accept stp packets. STP does not help in meshes.
 	 * better use the bridge loop avoidance ...
@@ -296,7 +298,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 
 		batadv_dat_snoop_outgoing_arp_reply(bat_priv, skb);
 
-		ret = batadv_send_skb_unicast(bat_priv, skb);
+		ret = batadv_send_skb_unicast(bat_priv, skb, vid);
 		if (ret != 0)
 			goto dropped_freed;
 	}
@@ -319,12 +321,12 @@ void batadv_interface_rx(struct net_device *soft_iface,
 			 struct sk_buff *skb, struct batadv_hard_iface *recv_if,
 			 int hdr_size, struct batadv_orig_node *orig_node)
 {
-	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
-	struct ethhdr *ethhdr;
-	struct vlan_ethhdr *vhdr;
 	struct batadv_header *batadv_header = (struct batadv_header *)skb->data;
-	unsigned short vid __maybe_unused = BATADV_NO_FLAGS;
+	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
 	__be16 ethertype = htons(ETH_P_BATMAN);
+	struct vlan_ethhdr *vhdr;
+	struct ethhdr *ethhdr;
+	unsigned short vid;
 	bool is_bcast;
 
 	is_bcast = (batadv_header->packet_type == BATADV_BCAST);
@@ -336,13 +338,12 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	skb_pull_rcsum(skb, hdr_size);
 	skb_reset_mac_header(skb);
 
+	vid = batadv_get_vid(skb, hdr_size);
 	ethhdr = eth_hdr(skb);
 
 	switch (ntohs(ethhdr->h_proto)) {
 	case ETH_P_8021Q:
 		vhdr = (struct vlan_ethhdr *)skb->data;
-		vid = ntohs(vhdr->h_vlan_TCI) & VLAN_VID_MASK;
-		vid |= BATADV_VLAN_HAS_TAG;
 
 		if (vhdr->h_vlan_encapsulated_proto != ethertype)
 			break;
@@ -378,7 +379,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 
 	if (orig_node)
 		batadv_tt_add_temporary_global_entry(bat_priv, orig_node,
-						     ethhdr->h_source);
+						     ethhdr->h_source, vid);
 
 	if (batadv_is_ap_isolated(bat_priv, ethhdr->h_source, ethhdr->h_dest))
 		goto dropped;

commit a4deee1ad42d93746562fe7de2149729017e3fd1
Author: Linus Lüssing <linus.luessing@web.de>
Date:   Sun May 26 17:56:07 2013 +0200

    batman-adv: Add dummy soft-interface rx mode handler
    
    We do not actually need to set any rx filters for the virtual batman
    soft interface. However a dummy handler enables a user to set static
    multicast listeners for instance.
    
    Signed-off-by: Linus Lüssing <linus.luessing@web.de>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 15c7237f427b..e8a2bd699d40 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -137,6 +137,18 @@ static int batadv_interface_change_mtu(struct net_device *dev, int new_mtu)
 	return 0;
 }
 
+/**
+ * batadv_interface_set_rx_mode - set the rx mode of a device
+ * @dev: registered network device to modify
+ *
+ * We do not actually need to set any rx filters for the virtual batman
+ * soft interface. However a dummy handler enables a user to set static
+ * multicast listeners for instance.
+ */
+static void batadv_interface_set_rx_mode(struct net_device *dev)
+{
+}
+
 static int batadv_interface_tx(struct sk_buff *skb,
 			       struct net_device *soft_iface)
 {
@@ -583,6 +595,7 @@ static const struct net_device_ops batadv_netdev_ops = {
 	.ndo_get_stats = batadv_interface_stats,
 	.ndo_set_mac_address = batadv_interface_set_mac_addr,
 	.ndo_change_mtu = batadv_interface_change_mtu,
+	.ndo_set_rx_mode = batadv_interface_set_rx_mode,
 	.ndo_start_xmit = batadv_interface_tx,
 	.ndo_validate_addr = eth_validate_addr,
 	.ndo_add_slave = batadv_softif_slave_add,

commit 411d6ed93a5d0601980d3e5ce75de07c98e3a7de
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Wed May 8 13:31:59 2013 +0800

    batman-adv: consider network coding overhead when calculating required mtu
    
    The module prints a warning when the MTU on the hard interface is too
    small to transfer payload traffic without fragmentation. The required
    MTU is calculated based on the encapsulation header size. If network
    coding is compild into the module its header size is taken into
    account as well.
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 87e7e4ed216d..15c7237f427b 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -626,7 +626,7 @@ static void batadv_softif_init_early(struct net_device *dev)
 	 */
 	dev->mtu = ETH_DATA_LEN;
 	/* reserve more space in the skbuff for our header */
-	dev->hard_header_len = BATADV_HEADER_LEN;
+	dev->hard_header_len = batadv_max_header_len();
 
 	/* generate random address */
 	eth_hw_addr_random(dev);

commit 293e93385e024be71500c9480ef85d6199459d17
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Sun May 19 12:55:16 2013 +0200

    batman-adv: use htons when possible
    
    When comparing a network ordered value with a constant, it
    is better to convert the constant at compile time by means
    of htons() instead of converting the value at runtime using
    ntohs().
    
    This refactoring may slightly improve the code performance.
    
    Moreover substitute __constant_htons() with htons() since
    the latter increase readability and it is smart enough to be
    as efficient as the former
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Acked-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 18b1fd915d1f..87e7e4ed216d 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -145,7 +145,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	struct batadv_hard_iface *primary_if = NULL;
 	struct batadv_bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
-	__be16 ethertype = __constant_htons(ETH_P_BATMAN);
+	__be16 ethertype = htons(ETH_P_BATMAN);
 	static const uint8_t stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00,
 						   0x00, 0x00};
 	static const uint8_t ectp_addr[ETH_ALEN] = {0xCF, 0x00, 0x00, 0x00,
@@ -312,7 +312,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	struct vlan_ethhdr *vhdr;
 	struct batadv_header *batadv_header = (struct batadv_header *)skb->data;
 	unsigned short vid __maybe_unused = BATADV_NO_FLAGS;
-	__be16 ethertype = __constant_htons(ETH_P_BATMAN);
+	__be16 ethertype = htons(ETH_P_BATMAN);
 	bool is_bcast;
 
 	is_bcast = (batadv_header->packet_type == BATADV_BCAST);

commit ee75ed88879af88558818a5c6609d85f60ff0df4
Author: Martin Hundebøll <martin@hundeboll.net>
Date:   Thu May 23 16:53:03 2013 +0200

    batman-adv: Fragment and send skbs larger than mtu
    
    Non-broadcast packets larger than MTU are fragmented and sent with
    an encapsulating header. Up to 16 fragments are supported, which are
    sent in reverse order on the wire to allow minimal memory copying when
    creating fragments.
    
    Signed-off-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index dd189e6bf05a..18b1fd915d1f 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -442,6 +442,7 @@ static void batadv_softif_destroy_finish(struct work_struct *work)
 static int batadv_softif_init_late(struct net_device *dev)
 {
 	struct batadv_priv *bat_priv;
+	uint32_t random_seqno;
 	int ret;
 	size_t cnt_len = sizeof(uint64_t) * BATADV_CNT_NUM;
 
@@ -491,6 +492,10 @@ static int batadv_softif_init_late(struct net_device *dev)
 	bat_priv->tt.last_changeset = NULL;
 	bat_priv->tt.last_changeset_len = 0;
 
+	/* randomize initial seqno to avoid collision */
+	get_random_bytes(&random_seqno, sizeof(random_seqno));
+	atomic_set(&bat_priv->frag_seqno, random_seqno);
+
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;
 
@@ -758,6 +763,8 @@ static const struct {
 	{ "mgmt_tx_bytes" },
 	{ "mgmt_rx" },
 	{ "mgmt_rx_bytes" },
+	{ "frag_tx" },
+	{ "frag_tx_bytes" },
 	{ "frag_rx" },
 	{ "frag_rx_bytes" },
 	{ "frag_fwd" },

commit 610bfc6bc99bc83680d190ebc69359a05fc7f605
Author: Martin Hundebøll <martin@hundeboll.net>
Date:   Thu May 23 16:53:02 2013 +0200

    batman-adv: Receive fragmented packets and merge
    
    Fragments arriving at their destination are buffered for later merge.
    Merged packets are passed to the main receive function as had they never
    been fragmented.
    
    Fragments are forwarded without merging if the MTU of the outgoing
    interface is smaller than the size of the merged packet.
    
    Signed-off-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 504d0bbddc48..dd189e6bf05a 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -758,6 +758,10 @@ static const struct {
 	{ "mgmt_tx_bytes" },
 	{ "mgmt_rx" },
 	{ "mgmt_rx_bytes" },
+	{ "frag_rx" },
+	{ "frag_rx_bytes" },
+	{ "frag_fwd" },
+	{ "frag_fwd_bytes" },
 	{ "tt_request_tx" },
 	{ "tt_request_rx" },
 	{ "tt_response_tx" },

commit f097e25dbe9144447f46b6b61ca3da1a2ba432d4
Author: Martin Hundebøll <martin@hundeboll.net>
Date:   Thu May 23 16:53:01 2013 +0200

    batman-adv: Remove old fragmentation code
    
    Remove the existing fragmentation code before adding the new version
    and delete unicast.{h,c}.
    
    batadv_unicast_send_skb() is moved to send.c and renamed to
    batadv_send_skb_unicast().
    
    fragmentation entry in sysfs (bat_priv->fragmentation) is kept for use in
    the new fragmentation code.
    
    BATADV_UNICAST_FRAG packet type is renamed to BATADV_FRAG for use in the
    new fragmentation code.
    
    Signed-off-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 25e6004e8e01..504d0bbddc48 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -34,8 +34,6 @@
 #include <linux/ethtool.h>
 #include <linux/etherdevice.h>
 #include <linux/if_vlan.h>
-#include <linux/if_ether.h>
-#include "unicast.h"
 #include "bridge_loop_avoidance.h"
 #include "network-coding.h"
 
@@ -286,7 +284,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 
 		batadv_dat_snoop_outgoing_arp_reply(bat_priv, skb);
 
-		ret = batadv_unicast_send_skb(bat_priv, skb);
+		ret = batadv_send_skb_unicast(bat_priv, skb);
 		if (ret != 0)
 			goto dropped_freed;
 	}

commit 9f4980e68b4b72e6a4d7caadfacc54260d05ebf6
Author: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
Date:   Thu Apr 25 11:57:42 2013 +0200

    batman-adv: remove vis functionality
    
    This is replaced by a userspace program, we don't need this
    functionality to bloat the kernel.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 84623a955d52..25e6004e8e01 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -469,7 +469,6 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->distributed_arp_table, 1);
 #endif
 	atomic_set(&bat_priv->ap_isolation, 0);
-	atomic_set(&bat_priv->vis_mode, BATADV_VIS_TYPE_CLIENT_UPDATE);
 	atomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);
 	atomic_set(&bat_priv->gw_sel_class, 20);
 	atomic_set(&bat_priv->gw.bandwidth_down, 100);

commit 414254e342a0d58144de40c3da777521ebaeeb07
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Tue Apr 23 21:39:58 2013 +0800

    batman-adv: tvlv - gateway download/upload bandwidth container
    
    Prior to this patch batman-adv read the advertised uplink bandwidth
    from userspace and compressed this information into a single byte
    called "gateway class".
    Now the download & upload bandwidth information is sent as-is. No
    userspace change is necessary since the sysfs API always allowed
    to specify a bandwidth.
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Spyros Gasteratos <morfeas3000@gmail.com>
    Signed-off-by: Antonio Quartulli <antonio@meshcoding.com>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 813db4e64602..84623a955d52 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -472,7 +472,8 @@ static int batadv_softif_init_late(struct net_device *dev)
 	atomic_set(&bat_priv->vis_mode, BATADV_VIS_TYPE_CLIENT_UPDATE);
 	atomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);
 	atomic_set(&bat_priv->gw_sel_class, 20);
-	atomic_set(&bat_priv->gw_bandwidth, 41);
+	atomic_set(&bat_priv->gw.bandwidth_down, 100);
+	atomic_set(&bat_priv->gw.bandwidth_up, 20);
 	atomic_set(&bat_priv->orig_interval, 1000);
 	atomic_set(&bat_priv->hop_penalty, 30);
 #ifdef CONFIG_BATMAN_ADV_DEBUG

commit 4c18c425b2d228415b635e97a64737d7f27c5536
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Wed Sep 11 19:14:44 2013 +0200

    batman-adv: set the TAG flag for the vid passed to BLA
    
    When receiving or sending a packet a packet on a VLAN, the
    vid has to be marked with the TAG flag in order to make any
    component in batman-adv understand that the packet is coming
    from a really tagged network.
    
    This fix the Bridge Loop Avoidance behaviour which was not
    able to send announces over VLAN interfaces.
    
    Introduced by 0b1da1765fdb00ca5d53bc95c9abc70dfc9aae5b
    ("batman-adv: change VID semantic in the BLA code")
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.org>
    Acked-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Marek Lindner <mareklindner@neomailbox.ch>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 4493913f0d5c..813db4e64602 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -168,6 +168,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	case ETH_P_8021Q:
 		vhdr = (struct vlan_ethhdr *)skb->data;
 		vid = ntohs(vhdr->h_vlan_TCI) & VLAN_VID_MASK;
+		vid |= BATADV_VLAN_HAS_TAG;
 
 		if (vhdr->h_vlan_encapsulated_proto != ethertype)
 			break;
@@ -331,6 +332,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	case ETH_P_8021Q:
 		vhdr = (struct vlan_ethhdr *)skb->data;
 		vid = ntohs(vhdr->h_vlan_TCI) & VLAN_VID_MASK;
+		vid |= BATADV_VLAN_HAS_TAG;
 
 		if (vhdr->h_vlan_encapsulated_proto != ethertype)
 			break;

commit c54f38c9aa22ff65ca9f4c1bdbf2a11d017205f3
Author: Simon Wunderlich <simon@open-mesh.com>
Date:   Mon Jul 29 17:56:44 2013 +0200

    batman-adv: set skb priority according to content
    
    The skb priority field may help the wireless driver to choose the right
    queue (e.g. WMM queues). This should be set in batman-adv, as this
    information is only available here.
    
    This patch adds support for IPv4/IPv6 DS fields and VLAN PCP. Note that
    only VLAN PCP is used if a VLAN header is present. Also initially set
    TC_PRIO_CONTROL only for self-generated packets, and keep the priority
    set by higher layers.
    
    Signed-off-by: Simon Wunderlich <simon@open-mesh.com>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 0f04e1c302b4..4493913f0d5c 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -229,6 +229,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		 */
 	}
 
+	batadv_skb_set_priority(skb, 0);
+
 	/* ethernet packet should be broadcasted */
 	if (do_bcast) {
 		primary_if = batadv_primary_if_get_selected(bat_priv);

commit 9d2c9488cedb666bc8206fbdcdc1575e0fbc5929
Author: Linus Lüssing <linus.luessing@web.de>
Date:   Tue Aug 6 20:21:15 2013 +0200

    batman-adv: fix potential kernel paging errors for unicast transmissions
    
    There are several functions which might reallocate skb data. Currently
    some places keep reusing their old ethhdr pointer regardless of whether
    they became invalid after such a reallocation or not. This potentially
    leads to kernel paging errors.
    
    This patch fixes these by refetching the ethdr pointer after the
    potential reallocations.
    
    Signed-off-by: Linus Lüssing <linus.luessing@web.de>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 700d0b49742d..0f04e1c302b4 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -180,6 +180,9 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	if (batadv_bla_tx(bat_priv, skb, vid))
 		goto dropped;
 
+	/* skb->data might have been reallocated by batadv_bla_tx() */
+	ethhdr = (struct ethhdr *)skb->data;
+
 	/* Register the client MAC in the transtable */
 	if (!is_multicast_ether_addr(ethhdr->h_source))
 		batadv_tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
@@ -220,6 +223,10 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		default:
 			break;
 		}
+
+		/* reminder: ethhdr might have become unusable from here on
+		 * (batadv_gw_is_dhcp_target() might have reallocated skb data)
+		 */
 	}
 
 	/* ethernet packet should be broadcasted */
@@ -266,7 +273,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	/* unicast packet */
 	} else {
 		if (atomic_read(&bat_priv->gw_mode) != BATADV_GW_MODE_OFF) {
-			ret = batadv_gw_out_of_range(bat_priv, skb, ethhdr);
+			ret = batadv_gw_out_of_range(bat_priv, skb);
 			if (ret)
 				goto dropped;
 		}

commit eb2deb6b39b1597577c1635e9ebf319f1ae02213
Author: Antonio Quartulli <antonio@open-mesh.com>
Date:   Fri Apr 19 18:07:00 2013 +0200

    batman-adv: change VID semantic in the BLA code
    
    In order to make batman-adv fully vlan aware later, the
    semantic used for variables storing the VLAN ID values has
    to be changed in order to be adapted to the new one which
    will be used batman-adv wide.
    
    In particular, the VID has to be an "_unsigned_ short int"
    and its 4 MSB will be used as a flag bitfield, while the
    remaining 12 bits are used to store the real VID value
    
    Signed-off-by: Antonio Quartulli <antonio@open-mesh.com>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Acked-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b26a6cdb934c..700d0b49742d 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -154,7 +154,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 						    0x00, 0x00};
 	unsigned int header_len = 0;
 	int data_len = skb->len, ret;
-	short vid __maybe_unused = -1;
+	unsigned short vid __maybe_unused = BATADV_NO_FLAGS;
 	bool do_bcast = false;
 	uint32_t seqno;
 	unsigned long brd_delay = 1;
@@ -303,7 +303,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	struct ethhdr *ethhdr;
 	struct vlan_ethhdr *vhdr;
 	struct batadv_header *batadv_header = (struct batadv_header *)skb->data;
-	short vid __maybe_unused = -1;
+	unsigned short vid __maybe_unused = BATADV_NO_FLAGS;
 	__be16 ethertype = __constant_htons(ETH_P_BATMAN);
 	bool is_bcast;
 

commit 7ed4be9523455a061e62236dc3caa9211cd7edda
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Mon Apr 8 15:08:18 2013 +0200

    batman-adv: use eth_hdr() when it makes sense
    
    Instead of casting the result of skb_mac_header() to
    "struct ethhdr *" every time, the eth_hdr inline function
    can be use to beautify the code and improve its readability.
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 819dfb006cdf..b26a6cdb934c 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -316,7 +316,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	skb_pull_rcsum(skb, hdr_size);
 	skb_reset_mac_header(skb);
 
-	ethhdr = (struct ethhdr *)skb_mac_header(skb);
+	ethhdr = eth_hdr(skb);
 
 	switch (ntohs(ethhdr->h_proto)) {
 	case ETH_P_8021Q:

commit f69ae770e74df420fbcf93aae81b30a5dcc73b7d
Author: Martin Hundebøll <martin@hundeboll.net>
Date:   Wed Apr 17 21:13:16 2013 +0200

    batman-adv: Avoid double freeing of bat_counters
    
    On errors in batadv_mesh_init(), bat_counters will be freed in both
    batadv_mesh_free() and batadv_softif_init_late(). This patch fixes this
    by returning earlier from batadv_softif_init_late() in case of errors in
    batadv_mesh_init() and by setting bat_counters to NULL after freeing.
    
    Signed-off-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 6f20d339e33a..819dfb006cdf 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -505,6 +505,7 @@ static int batadv_softif_init_late(struct net_device *dev)
 	batadv_debugfs_del_meshif(dev);
 free_bat_counters:
 	free_percpu(bat_priv->bat_counters);
+	bat_priv->bat_counters = NULL;
 
 	return ret;
 }

commit 0c501345ce24983d234fc913e7e81b6abe59cb54
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Fri Apr 19 11:04:52 2013 +0200

    batman-adv: fix global protection fault during soft_iface destruction
    
    batadv_mesh_free() schedules some RCU callbacks which need the bat_priv struct
    to do their jobs, while free_netdev(), which is called immediately after, is
    destroying the private data.
    
    Put an rcu_barrier() in the middle so that free_netdev() is invoked only after
    all the callbacks returned.
    
    This bug has been introduced by ab8f433dd39be94e8617cff2dfe9f7eca162eb15
    ("batman-adv: Move deinitialization of soft-interface to destructor")
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 403b8c46085e..6f20d339e33a 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -582,6 +582,13 @@ static void batadv_softif_free(struct net_device *dev)
 {
 	batadv_debugfs_del_meshif(dev);
 	batadv_mesh_free(dev);
+
+	/* some scheduled RCU callbacks need the bat_priv struct to accomplish
+	 * their tasks. Wait for them all to be finished before freeing the
+	 * netdev and its private data (bat_priv)
+	 */
+	rcu_barrier();
+
 	free_netdev(dev);
 }
 

commit 3dbd550b8b2e204833d8305451bbde990e1cd743
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Feb 11 17:10:27 2013 +0800

    batman-adv: Allow to modify slaves of soft-interfaces through rntl_link
    
    The sysfs configuration interface of batman-adv to add/remove slaves of an
    soft-iface is not deadlock free and doesn't follow the currently common way to
    modify slaves of an interface.
    
    An additional configuration interface though rtnl_link is introduced which
    provides easy device adding/removing with tools like "ip":
    $ ip link set dev eth0 master bat0
    $ ip link set dev eth0 nomaster
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Acked-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 545c863b35fc..403b8c46085e 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -509,6 +509,58 @@ static int batadv_softif_init_late(struct net_device *dev)
 	return ret;
 }
 
+/**
+ * batadv_softif_slave_add - Add a slave interface to a batadv_soft_interface
+ * @dev: batadv_soft_interface used as master interface
+ * @slave_dev: net_device which should become the slave interface
+ *
+ * Return 0 if successful or error otherwise.
+ */
+static int batadv_softif_slave_add(struct net_device *dev,
+				   struct net_device *slave_dev)
+{
+	struct batadv_hard_iface *hard_iface;
+	int ret = -EINVAL;
+
+	hard_iface = batadv_hardif_get_by_netdev(slave_dev);
+	if (!hard_iface || hard_iface->soft_iface != NULL)
+		goto out;
+
+	ret = batadv_hardif_enable_interface(hard_iface, dev->name);
+
+out:
+	if (hard_iface)
+		batadv_hardif_free_ref(hard_iface);
+	return ret;
+}
+
+/**
+ * batadv_softif_slave_del - Delete a slave iface from a batadv_soft_interface
+ * @dev: batadv_soft_interface used as master interface
+ * @slave_dev: net_device which should be removed from the master interface
+ *
+ * Return 0 if successful or error otherwise.
+ */
+static int batadv_softif_slave_del(struct net_device *dev,
+				   struct net_device *slave_dev)
+{
+	struct batadv_hard_iface *hard_iface;
+	int ret = -EINVAL;
+
+	hard_iface = batadv_hardif_get_by_netdev(slave_dev);
+
+	if (!hard_iface || hard_iface->soft_iface != dev)
+		goto out;
+
+	batadv_hardif_disable_interface(hard_iface, BATADV_IF_CLEANUP_KEEP);
+	ret = 0;
+
+out:
+	if (hard_iface)
+		batadv_hardif_free_ref(hard_iface);
+	return ret;
+}
+
 static const struct net_device_ops batadv_netdev_ops = {
 	.ndo_init = batadv_softif_init_late,
 	.ndo_open = batadv_interface_open,
@@ -517,7 +569,9 @@ static const struct net_device_ops batadv_netdev_ops = {
 	.ndo_set_mac_address = batadv_interface_set_mac_addr,
 	.ndo_change_mtu = batadv_interface_change_mtu,
 	.ndo_start_xmit = batadv_interface_tx,
-	.ndo_validate_addr = eth_validate_addr
+	.ndo_validate_addr = eth_validate_addr,
+	.ndo_add_slave = batadv_softif_slave_add,
+	.ndo_del_slave = batadv_softif_slave_del,
 };
 
 /**

commit a4ac28c0d06a1c22138225a228d3a4eaffe9dd77
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Feb 11 17:10:26 2013 +0800

    batman-adv: Allow to use rntl_link for device creation/deletion
    
    The sysfs configuration interface of batman-adv to add/remove soft-interfaces
    is not deadlock free and doesn't follow the currently common way to create new
    virtual interfaces.
    
    An additional interface though rtnl_link is introduced which provides easy device
    creation/deletion with tools like "ip":
    
    $ ip link add dev bat0 type batadv
    $ ip link del dev bat0
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index bc77a5be960d..545c863b35fc 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -570,6 +570,8 @@ struct net_device *batadv_softif_create(const char *name)
 	if (!soft_iface)
 		return NULL;
 
+	soft_iface->rtnl_link_ops = &batadv_link_ops;
+
 	ret = register_netdevice(soft_iface);
 	if (ret < 0) {
 		pr_err("Unable to register the batman interface '%s': %i\n",
@@ -592,6 +594,26 @@ void batadv_softif_destroy_sysfs(struct net_device *soft_iface)
 	queue_work(batadv_event_workqueue, &bat_priv->cleanup_work);
 }
 
+/**
+ * batadv_softif_destroy_netlink - deletion of batadv_soft_interface via netlink
+ * @soft_iface: the to-be-removed batman-adv interface
+ * @head: list pointer
+ */
+static void batadv_softif_destroy_netlink(struct net_device *soft_iface,
+					  struct list_head *head)
+{
+	struct batadv_hard_iface *hard_iface;
+
+	list_for_each_entry(hard_iface, &batadv_hardif_list, list) {
+		if (hard_iface->soft_iface == soft_iface)
+			batadv_hardif_disable_interface(hard_iface,
+							BATADV_IF_CLEANUP_KEEP);
+	}
+
+	batadv_sysfs_del_meshif(soft_iface);
+	unregister_netdevice_queue(soft_iface, head);
+}
+
 int batadv_softif_is_valid(const struct net_device *net_dev)
 {
 	if (net_dev->netdev_ops->ndo_start_xmit == batadv_interface_tx)
@@ -600,6 +622,13 @@ int batadv_softif_is_valid(const struct net_device *net_dev)
 	return 0;
 }
 
+struct rtnl_link_ops batadv_link_ops __read_mostly = {
+	.kind		= "batadv",
+	.priv_size	= sizeof(struct batadv_priv),
+	.setup		= batadv_softif_init_early,
+	.dellink	= batadv_softif_destroy_netlink,
+};
+
 /* ethtool */
 static int batadv_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {

commit e07932ae6fb74ef707b2b27762fb0ad8aea4b55f
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Mon Feb 11 17:10:25 2013 +0800

    batman-adv: rename batadv_softif_destroy to reflect sysfs use case
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    CC: Sven Eckelmann <sven@narfation.org>
    Acked-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e889bfb1bfc3..bc77a5be960d 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -581,7 +581,11 @@ struct net_device *batadv_softif_create(const char *name)
 	return soft_iface;
 }
 
-void batadv_softif_destroy(struct net_device *soft_iface)
+/**
+ * batadv_softif_destroy_sysfs - deletion of batadv_soft_interface via sysfs
+ * @soft_iface: the to-be-removed batman-adv interface
+ */
+void batadv_softif_destroy_sysfs(struct net_device *soft_iface)
 {
 	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
 

commit b3246020e27ecc7c50cc77535936987d6eb6c869
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Feb 11 17:10:23 2013 +0800

    batman-adv: Move deinitialization of soft-interface to destructor
    
    The deinitialization of the soft-interface created in ndo_init/constructor
    should be done in the destructor and not directly before calling
    unregister_netdevice
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Acked-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c5cb0a7f8349..e889bfb1bfc3 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -417,7 +417,6 @@ static void batadv_softif_destroy_finish(struct work_struct *work)
 				cleanup_work);
 	soft_iface = bat_priv->soft_iface;
 
-	batadv_debugfs_del_meshif(soft_iface);
 	batadv_sysfs_del_meshif(soft_iface);
 
 	rtnl_lock();
@@ -521,6 +520,17 @@ static const struct net_device_ops batadv_netdev_ops = {
 	.ndo_validate_addr = eth_validate_addr
 };
 
+/**
+ * batadv_softif_free - Deconstructor of batadv_soft_interface
+ * @dev: Device to cleanup and remove
+ */
+static void batadv_softif_free(struct net_device *dev)
+{
+	batadv_debugfs_del_meshif(dev);
+	batadv_mesh_free(dev);
+	free_netdev(dev);
+}
+
 /**
  * batadv_softif_init_early - early stage initialization of soft interface
  * @dev: registered network device to modify
@@ -532,7 +542,7 @@ static void batadv_softif_init_early(struct net_device *dev)
 	ether_setup(dev);
 
 	dev->netdev_ops = &batadv_netdev_ops;
-	dev->destructor = free_netdev;
+	dev->destructor = batadv_softif_free;
 	dev->tx_queue_len = 0;
 
 	/* can't call min_mtu, because the needed variables
@@ -575,7 +585,6 @@ void batadv_softif_destroy(struct net_device *soft_iface)
 {
 	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
 
-	batadv_mesh_free(soft_iface);
 	queue_work(batadv_event_workqueue, &bat_priv->cleanup_work);
 }
 

commit 37130293fd50918c5498bafafd18735a24229cb9
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Feb 11 17:10:22 2013 +0800

    batman-adv: Move soft-interface initialization to ndo_init
    
    The initialization of an net_device object should be done in the
    init/constructor function and not from the outside after the register_netdevice
    was done to avoid race conditions.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Acked-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index f93ae42abb58..c5cb0a7f8349 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -401,55 +401,6 @@ static void batadv_set_lockdep_class(struct net_device *dev)
 	netdev_for_each_tx_queue(dev, batadv_set_lockdep_class_one, NULL);
 }
 
-/**
- * batadv_softif_init - Late stage initialization of soft interface
- * @dev: registered network device to modify
- *
- * Returns error code on failures
- */
-static int batadv_softif_init(struct net_device *dev)
-{
-	batadv_set_lockdep_class(dev);
-
-	return 0;
-}
-
-static const struct net_device_ops batadv_netdev_ops = {
-	.ndo_init = batadv_softif_init,
-	.ndo_open = batadv_interface_open,
-	.ndo_stop = batadv_interface_release,
-	.ndo_get_stats = batadv_interface_stats,
-	.ndo_set_mac_address = batadv_interface_set_mac_addr,
-	.ndo_change_mtu = batadv_interface_change_mtu,
-	.ndo_start_xmit = batadv_interface_tx,
-	.ndo_validate_addr = eth_validate_addr
-};
-
-static void batadv_interface_setup(struct net_device *dev)
-{
-	struct batadv_priv *priv = netdev_priv(dev);
-
-	ether_setup(dev);
-
-	dev->netdev_ops = &batadv_netdev_ops;
-	dev->destructor = free_netdev;
-	dev->tx_queue_len = 0;
-
-	/* can't call min_mtu, because the needed variables
-	 * have not been initialized yet
-	 */
-	dev->mtu = ETH_DATA_LEN;
-	/* reserve more space in the skbuff for our header */
-	dev->hard_header_len = BATADV_HEADER_LEN;
-
-	/* generate random address */
-	eth_hw_addr_random(dev);
-
-	SET_ETHTOOL_OPS(dev, &batadv_ethtool_ops);
-
-	memset(priv, 0, sizeof(*priv));
-}
-
 /**
  * batadv_softif_destroy_finish - cleans up the remains of a softif
  * @work: work queue item
@@ -474,21 +425,22 @@ static void batadv_softif_destroy_finish(struct work_struct *work)
 	rtnl_unlock();
 }
 
-struct net_device *batadv_softif_create(const char *name)
+/**
+ * batadv_softif_init_late - late stage initialization of soft interface
+ * @dev: registered network device to modify
+ *
+ * Returns error code on failures
+ */
+static int batadv_softif_init_late(struct net_device *dev)
 {
-	struct net_device *soft_iface;
 	struct batadv_priv *bat_priv;
 	int ret;
 	size_t cnt_len = sizeof(uint64_t) * BATADV_CNT_NUM;
 
-	soft_iface = alloc_netdev(sizeof(*bat_priv), name,
-				  batadv_interface_setup);
-
-	if (!soft_iface)
-		goto out;
+	batadv_set_lockdep_class(dev);
 
-	bat_priv = netdev_priv(soft_iface);
-	bat_priv->soft_iface = soft_iface;
+	bat_priv = netdev_priv(dev);
+	bat_priv->soft_iface = dev;
 	INIT_WORK(&bat_priv->cleanup_work, batadv_softif_destroy_finish);
 
 	/* batadv_interface_stats() needs to be available as soon as
@@ -496,14 +448,7 @@ struct net_device *batadv_softif_create(const char *name)
 	 */
 	bat_priv->bat_counters = __alloc_percpu(cnt_len, __alignof__(uint64_t));
 	if (!bat_priv->bat_counters)
-		goto free_soft_iface;
-
-	ret = register_netdevice(soft_iface);
-	if (ret < 0) {
-		pr_err("Unable to register the batman interface '%s': %i\n",
-		       name, ret);
-		goto free_bat_counters;
-	}
+		return -ENOMEM;
 
 	atomic_set(&bat_priv->aggregated_ogms, 1);
 	atomic_set(&bat_priv->bonding, 0);
@@ -541,41 +486,89 @@ struct net_device *batadv_softif_create(const char *name)
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;
 
-	ret = batadv_algo_select(bat_priv, batadv_routing_algo);
-	if (ret < 0)
-		goto unreg_soft_iface;
-
 	batadv_nc_init_bat_priv(bat_priv);
 
-	ret = batadv_sysfs_add_meshif(soft_iface);
+	ret = batadv_algo_select(bat_priv, batadv_routing_algo);
 	if (ret < 0)
-		goto unreg_soft_iface;
+		goto free_bat_counters;
 
-	ret = batadv_debugfs_add_meshif(soft_iface);
+	ret = batadv_debugfs_add_meshif(dev);
 	if (ret < 0)
-		goto unreg_sysfs;
+		goto free_bat_counters;
 
-	ret = batadv_mesh_init(soft_iface);
+	ret = batadv_mesh_init(dev);
 	if (ret < 0)
 		goto unreg_debugfs;
 
-	return soft_iface;
+	return 0;
 
 unreg_debugfs:
-	batadv_debugfs_del_meshif(soft_iface);
-unreg_sysfs:
-	batadv_sysfs_del_meshif(soft_iface);
-unreg_soft_iface:
-	free_percpu(bat_priv->bat_counters);
-	unregister_netdevice(soft_iface);
-	return NULL;
-
+	batadv_debugfs_del_meshif(dev);
 free_bat_counters:
 	free_percpu(bat_priv->bat_counters);
-free_soft_iface:
-	free_netdev(soft_iface);
-out:
-	return NULL;
+
+	return ret;
+}
+
+static const struct net_device_ops batadv_netdev_ops = {
+	.ndo_init = batadv_softif_init_late,
+	.ndo_open = batadv_interface_open,
+	.ndo_stop = batadv_interface_release,
+	.ndo_get_stats = batadv_interface_stats,
+	.ndo_set_mac_address = batadv_interface_set_mac_addr,
+	.ndo_change_mtu = batadv_interface_change_mtu,
+	.ndo_start_xmit = batadv_interface_tx,
+	.ndo_validate_addr = eth_validate_addr
+};
+
+/**
+ * batadv_softif_init_early - early stage initialization of soft interface
+ * @dev: registered network device to modify
+ */
+static void batadv_softif_init_early(struct net_device *dev)
+{
+	struct batadv_priv *priv = netdev_priv(dev);
+
+	ether_setup(dev);
+
+	dev->netdev_ops = &batadv_netdev_ops;
+	dev->destructor = free_netdev;
+	dev->tx_queue_len = 0;
+
+	/* can't call min_mtu, because the needed variables
+	 * have not been initialized yet
+	 */
+	dev->mtu = ETH_DATA_LEN;
+	/* reserve more space in the skbuff for our header */
+	dev->hard_header_len = BATADV_HEADER_LEN;
+
+	/* generate random address */
+	eth_hw_addr_random(dev);
+
+	SET_ETHTOOL_OPS(dev, &batadv_ethtool_ops);
+
+	memset(priv, 0, sizeof(*priv));
+}
+
+struct net_device *batadv_softif_create(const char *name)
+{
+	struct net_device *soft_iface;
+	int ret;
+
+	soft_iface = alloc_netdev(sizeof(struct batadv_priv), name,
+				  batadv_softif_init_early);
+	if (!soft_iface)
+		return NULL;
+
+	ret = register_netdevice(soft_iface);
+	if (ret < 0) {
+		pr_err("Unable to register the batman interface '%s': %i\n",
+		       name, ret);
+		free_netdev(soft_iface);
+		return NULL;
+	}
+
+	return soft_iface;
 }
 
 void batadv_softif_destroy(struct net_device *soft_iface)

commit 2df5278b0267c799f3e877e8eeddbb6e93cda0bb
Author: Martin Hundebøll <martin@hundeboll.net>
Date:   Fri Jan 25 11:12:43 2013 +0100

    batman-adv: network coding - receive coded packets and decode them
    
    When receiving a network coded packet, the decoding buffer is searched
    for a packet to use for decoding. The source, destination, and crc32 from
    the coded packet is used to identify the wanted packet. The decoded
    packet is passed to the usual unicast receiver function, as had it never
    been network coded.
    
    Signed-off-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 75204ec1eee4..f93ae42abb58 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -671,6 +671,10 @@ static const struct {
 	{ "nc_recode" },
 	{ "nc_recode_bytes" },
 	{ "nc_buffer" },
+	{ "nc_decode" },
+	{ "nc_decode_bytes" },
+	{ "nc_decode_failed" },
+	{ "nc_sniffed" },
 #endif
 };
 

commit 612d2b4fe0a1ff2f8389462a6f8be34e54124c05
Author: Martin Hundebøll <martin@hundeboll.net>
Date:   Fri Jan 25 11:12:42 2013 +0100

    batman-adv: network coding - save overheard and tx packets for decoding
    
    To be able to decode a network coded packet, a node must already know
    one of the two coded packets. This is done by buffering skbs before
    transmission and buffering packets sniffed with promiscuous mode from
    other hosts.
    
    Packets are kept in a buffer similar to the one with forward-skbs: A
    hash table, where each entry, which corresponds to a src-dst pair, has a
    linked list packets.
    
    Signed-off-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 7e463c3ae1d9..75204ec1eee4 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -670,6 +670,7 @@ static const struct {
 	{ "nc_code_bytes" },
 	{ "nc_recode" },
 	{ "nc_recode_bytes" },
+	{ "nc_buffer" },
 #endif
 };
 

commit 3c12de9a5c756b23fe7c9ab332474ece1568914c
Author: Martin Hundebøll <martin@hundeboll.net>
Date:   Fri Jan 25 11:12:41 2013 +0100

    batman-adv: network coding - code and transmit packets if possible
    
    Before adding forward-skbs to the coding buffer, the buffer is searched
    for a potential coding opportunity. If one is found, the two packets are
    network coded and transmitted right away. If not, the forward-skb is
    added to the buffer.
    
    Network coded packets are transmitted with information about the two
    receivers and the two coded packets. The first receiver is given by the
    MAC header, while the second is given in the payload/bat-header. The
    second receiver uses promiscuous mode to receive the packet and check
    the second destination.
    
    Signed-off-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 7188e07dfc6f..7e463c3ae1d9 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -665,6 +665,12 @@ static const struct {
 	{ "dat_put_rx" },
 	{ "dat_cached_reply_tx" },
 #endif
+#ifdef CONFIG_BATMAN_ADV_NC
+	{ "nc_code" },
+	{ "nc_code_bytes" },
+	{ "nc_recode" },
+	{ "nc_recode_bytes" },
+#endif
 };
 
 static void batadv_get_strings(struct net_device *dev, uint32_t stringset,

commit d353d8d4d9f0184ac43a90c6e04b593c33bd28ea
Author: Martin Hundebøll <martin@hundeboll.net>
Date:   Fri Jan 25 11:12:38 2013 +0100

    batman-adv: network coding - add the initial infrastructure code
    
    Network coding exploits the 802.11 shared medium to allow multiple
    packets to be sent in a single transmission. In brief, a relay can XOR
    two packets, and send the coded packet to two destinations. The
    receivers can decode one of the original packets by XOR'ing the coded
    packet with the other original packet. This will lead to increased
    throughput in topologies where two packets cross one relay.
    
    In a simple topology with three nodes, it takes four transmissions
    without network coding to get one packet from Node A to Node B and one
    from Node B to Node A:
    
     1.  Node A  ---- p1 --->  Node R                Node B
     2.  Node A                Node R  <--- p2 ----  Node B
     3.  Node A  <--- p2 ----  Node R                Node B
     4.  Node A                Node R  ---- p1 --->  Node B
    
    With network coding, the relay only needs one transmission, which saves
    us one slot of valuable airtime:
    
     1.  Node A  ---- p1 --->  Node R                Node B
     2.  Node A                Node R  <--- p2 ----  Node B
     3.  Node A  <- p1 x p2 -  Node R  - p1 x p2 ->  Node B
    
    The same principle holds for a topology including five nodes. Here the
    packets from Node A and Node B are overheard by Node C and Node D,
    respectively. This allows Node R to send a network coded packet to save
    one transmission:
    
       Node A                  Node B
    
        |     \              /    |
        |      p1          p2     |
        |       \          /      |
        p1       > Node R <       p2
        |                         |
        |         /      \        |
        |    p1 x p2    p1 x p2   |
        v       /          \      v
               /            \
       Node C <              > Node D
    
    More information is available on the open-mesh.org wiki[1].
    
    This patch adds the initial code to support network coding in
    batman-adv. It sets up a worker thread to do house keeping and adds a
    sysfs file to enable/disable network coding. The feature is disabled by
    default, as it requires a wifi-driver with working promiscuous mode, and
    also because it adds a small delay at each hop.
    
    [1] http://www.open-mesh.org/projects/batman-adv/wiki/Catwoman
    
    Signed-off-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 2711e870f557..7188e07dfc6f 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -37,6 +37,7 @@
 #include <linux/if_ether.h>
 #include "unicast.h"
 #include "bridge_loop_avoidance.h"
+#include "network-coding.h"
 
 
 static int batadv_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);
@@ -544,6 +545,8 @@ struct net_device *batadv_softif_create(const char *name)
 	if (ret < 0)
 		goto unreg_soft_iface;
 
+	batadv_nc_init_bat_priv(bat_priv);
+
 	ret = batadv_sysfs_add_meshif(soft_iface);
 	if (ret < 0)
 		goto unreg_soft_iface;

commit 0b87393146244c2dc31cb3c69c45f4948ca94ee1
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Fri Jan 4 03:05:31 2013 +0100

    batman-adv: update copyright years
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c9962fee44b1..2711e870f557 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,4 +1,4 @@
-/* Copyright (C) 2007-2012 B.A.T.M.A.N. contributors:
+/* Copyright (C) 2007-2013 B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
  *

commit 5bc44dc8458cbac08c664f2f337326bf87cc924b
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Fri Jan 11 10:19:51 2013 +0100

    batman-adv: postpone sysfs removal when unregistering
    
    When processing the unregister notify for a hard interface, removing
    the sysfs files may lead to a circular deadlock (rtnl mutex <->
    s_active).
    
    To overcome this problem, postpone the sysfs removal in a worker.
    
    Reported-by: Sasha Levin <sasha.levin@oracle.com>
    Reported-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 3d6816667bfc..c9962fee44b1 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -449,6 +449,30 @@ static void batadv_interface_setup(struct net_device *dev)
 	memset(priv, 0, sizeof(*priv));
 }
 
+/**
+ * batadv_softif_destroy_finish - cleans up the remains of a softif
+ * @work: work queue item
+ *
+ * Free the parts of the soft interface which can not be removed under
+ * rtnl lock (to prevent deadlock situations).
+ */
+static void batadv_softif_destroy_finish(struct work_struct *work)
+{
+	struct batadv_priv *bat_priv;
+	struct net_device *soft_iface;
+
+	bat_priv = container_of(work, struct batadv_priv,
+				cleanup_work);
+	soft_iface = bat_priv->soft_iface;
+
+	batadv_debugfs_del_meshif(soft_iface);
+	batadv_sysfs_del_meshif(soft_iface);
+
+	rtnl_lock();
+	unregister_netdevice(soft_iface);
+	rtnl_unlock();
+}
+
 struct net_device *batadv_softif_create(const char *name)
 {
 	struct net_device *soft_iface;
@@ -463,6 +487,8 @@ struct net_device *batadv_softif_create(const char *name)
 		goto out;
 
 	bat_priv = netdev_priv(soft_iface);
+	bat_priv->soft_iface = soft_iface;
+	INIT_WORK(&bat_priv->cleanup_work, batadv_softif_destroy_finish);
 
 	/* batadv_interface_stats() needs to be available as soon as
 	 * register_netdevice() has been called
@@ -551,10 +577,10 @@ struct net_device *batadv_softif_create(const char *name)
 
 void batadv_softif_destroy(struct net_device *soft_iface)
 {
-	batadv_debugfs_del_meshif(soft_iface);
-	batadv_sysfs_del_meshif(soft_iface);
+	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
+
 	batadv_mesh_free(soft_iface);
-	unregister_netdevice(soft_iface);
+	queue_work(batadv_event_workqueue, &bat_priv->cleanup_work);
 }
 
 int batadv_softif_is_valid(const struct net_device *net_dev)

commit 0c430d0d7b8bafa74959a84156ef0bda1417a3d4
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Sun Dec 16 13:53:15 2012 +0800

    batman-adv: unbloat batadv_priv if debug is not enabled
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 57714f83ede4..3d6816667bfc 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -493,7 +493,9 @@ struct net_device *batadv_softif_create(const char *name)
 	atomic_set(&bat_priv->gw_bandwidth, 41);
 	atomic_set(&bat_priv->orig_interval, 1000);
 	atomic_set(&bat_priv->hop_penalty, 30);
+#ifdef CONFIG_BATMAN_ADV_DEBUG
 	atomic_set(&bat_priv->log_level, 0);
+#endif
 	atomic_set(&bat_priv->fragmentation, 1);
 	atomic_set(&bat_priv->bcast_queue_left, BATADV_BCAST_QUEUE_LEN);
 	atomic_set(&bat_priv->batman_queue_left, BATADV_BATMAN_QUEUE_LEN);

commit fa706554d6553331e886ce6fb86ca40b6dbc2083
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Mon Nov 26 01:27:29 2012 +0100

    batman-adv: don't compile the BLA switch if not requested
    
    When the Bridge Loop Avoidance component is not compiled-in, its boolean switch
    should be not compiled as well. This patch surrounds the switch with a proper
    ifdef.
    
    This behaviour was introduced by 9fd6b0615b5499b270d39a92b8790e206cf75833
    ("batman-adv: add bridge loop avoidance compile option")
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Acked-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index f8cc1429942f..57714f83ede4 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -480,7 +480,9 @@ struct net_device *batadv_softif_create(const char *name)
 
 	atomic_set(&bat_priv->aggregated_ogms, 1);
 	atomic_set(&bat_priv->bonding, 0);
+#ifdef CONFIG_BATMAN_ADV_BLA
 	atomic_set(&bat_priv->bridge_loop_avoidance, 0);
+#endif
 #ifdef CONFIG_BATMAN_ADV_DAT
 	atomic_set(&bat_priv->distributed_arp_table, 1);
 #endif

commit 02233e0c75fc512ca60e7e82943f0a4395a85411
Author: Linus Lüssing <linus.luessing@web.de>
Date:   Wed Oct 17 15:07:35 2012 +0200

    batman-adv: Do not add multicast MAC addresses to translation table
    
    The current translation table mechanism is not suitable for multicast
    addresses and we are currently flooding such frames anyway.
    
    Therefore this patch prevents multicast MAC addresses being added to the
    translation table.
    
    Signed-off-by: Linus Lüssing <linus.luessing@web.de>
    Acked-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 90f4049a90dd..f8cc1429942f 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -180,7 +180,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		goto dropped;
 
 	/* Register the client MAC in the transtable */
-	batadv_tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
+	if (!is_multicast_ether_addr(ethhdr->h_source))
+		batadv_tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
 
 	/* don't accept stp packets. STP does not help in meshes.
 	 * better use the bridge loop avoidance ...

commit 7826d43f2db45c9305a6e0ba165650e1a203f517
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Sun Jan 6 00:44:26 2013 +0000

    ethtool: fix drvinfo strings set in drivers
    
    Use strlcpy where possible to ensure the string is \0 terminated.
    Use always sizeof(string) instead of 32, ETHTOOL_BUSINFO_LEN
    and custom defines.
    Use snprintf instead of sprint.
    Remove unnecessary inits of ->fw_version
    Remove unnecessary inits of drvinfo struct.
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index fa388b2c60d7..90f4049a90dd 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -580,10 +580,10 @@ static int batadv_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 static void batadv_get_drvinfo(struct net_device *dev,
 			       struct ethtool_drvinfo *info)
 {
-	strcpy(info->driver, "B.A.T.M.A.N. advanced");
-	strcpy(info->version, BATADV_SOURCE_VERSION);
-	strcpy(info->fw_version, "N/A");
-	strcpy(info->bus_info, "batman");
+	strlcpy(info->driver, "B.A.T.M.A.N. advanced", sizeof(info->driver));
+	strlcpy(info->version, BATADV_SOURCE_VERSION, sizeof(info->version));
+	strlcpy(info->fw_version, "N/A", sizeof(info->fw_version));
+	strlcpy(info->bus_info, "batman", sizeof(info->bus_info));
 }
 
 static u32 batadv_get_msglevel(struct net_device *dev)

commit 15c6ff3bc0ff3464a8c7efcdea09c86454571622
Author: Jiri Pirko <jiri@resnulli.us>
Date:   Tue Jan 1 03:30:17 2013 +0000

    net: remove unnecessary NET_ADDR_RANDOM "bitclean"
    
    NET_ADDR_SET is set in dev_set_mac_address() no need to alter
    dev->addr_assign_type value in drivers.
    
    Signed-off-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 6b548fde8e04..fa388b2c60d7 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -124,7 +124,6 @@ static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 		batadv_tt_local_add(dev, addr->sa_data, BATADV_NULL_IFINDEX);
 	}
 
-	dev->addr_assign_type &= ~NET_ADDR_RANDOM;
 	return 0;
 }
 

commit af5d4f7737963f2112f148f97c5820425f050650
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Mon Nov 26 00:38:50 2012 +0100

    batman-adv: use ETH_P_BATMAN
    
    The ETH_P_BATMAN ethertype is now defined kernel-wide. Use it instead
    of the private BATADV_ETH_P_BATMAN define.
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 54800c783f96..6b548fde8e04 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -34,6 +34,7 @@
 #include <linux/ethtool.h>
 #include <linux/etherdevice.h>
 #include <linux/if_vlan.h>
+#include <linux/if_ether.h>
 #include "unicast.h"
 #include "bridge_loop_avoidance.h"
 
@@ -146,7 +147,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	struct batadv_hard_iface *primary_if = NULL;
 	struct batadv_bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
-	__be16 ethertype = __constant_htons(BATADV_ETH_P_BATMAN);
+	__be16 ethertype = __constant_htons(ETH_P_BATMAN);
 	static const uint8_t stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00,
 						   0x00, 0x00};
 	static const uint8_t ectp_addr[ETH_ALEN] = {0xCF, 0x00, 0x00, 0x00,
@@ -172,7 +173,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 			break;
 
 		/* fall through */
-	case BATADV_ETH_P_BATMAN:
+	case ETH_P_BATMAN:
 		goto dropped;
 	}
 
@@ -302,7 +303,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	struct vlan_ethhdr *vhdr;
 	struct batadv_header *batadv_header = (struct batadv_header *)skb->data;
 	short vid __maybe_unused = -1;
-	__be16 ethertype = __constant_htons(BATADV_ETH_P_BATMAN);
+	__be16 ethertype = __constant_htons(ETH_P_BATMAN);
 	bool is_bcast;
 
 	is_bcast = (batadv_header->packet_type == BATADV_BCAST);
@@ -325,7 +326,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 			break;
 
 		/* fall through */
-	case BATADV_ETH_P_BATMAN:
+	case ETH_P_BATMAN:
 		goto dropped;
 	}
 

commit 67f4efdce7d85282fbd5832cddc80a07eb89b6d6
Merge: c53aa5058ad5 f4a75d2eb7b1
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Nov 17 22:00:43 2012 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Minor line offset auto-merges.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 74490f969155caf1ec945ad2d35d3a8eec6be71d
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Thu Nov 8 21:55:30 2012 +0100

    batman-adv: process broadcast packets in BLA earlier
    
    The logic in the BLA mechanism may decide to drop broadcast packets
    because the node may still be in the setup phase. For this reason,
    further broadcast processing like the early client detection mechanism
    must be done only after the BLA check.
    
    This patches moves the invocation to BLA before any other broadcast
    processing.
    
    This was introduced 30cfd02b60e1cb16f5effb0a01f826c5bb7e4c59
    ("batman-adv: detect not yet announced clients")
    
    Reported-by: Glen Page <glen.page@thet.net>
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b9a28d2dd3e8..ce0684a1fc83 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -325,6 +325,12 @@ void batadv_interface_rx(struct net_device *soft_iface,
 
 	soft_iface->last_rx = jiffies;
 
+	/* Let the bridge loop avoidance check the packet. If will
+	 * not handle it, we can safely push it up.
+	 */
+	if (batadv_bla_rx(bat_priv, skb, vid, is_bcast))
+		goto out;
+
 	if (orig_node)
 		batadv_tt_add_temporary_global_entry(bat_priv, orig_node,
 						     ethhdr->h_source);
@@ -332,12 +338,6 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	if (batadv_is_ap_isolated(bat_priv, ethhdr->h_source, ethhdr->h_dest))
 		goto dropped;
 
-	/* Let the bridge loop avoidance check the packet. If will
-	 * not handle it, we can safely push it up.
-	 */
-	if (batadv_bla_rx(bat_priv, skb, vid, is_bcast))
-		goto out;
-
 	netif_rx(skb);
 	goto out;
 

commit 7c1fd91da5a5eecc91674991199940c05f87cb3a
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Sun Sep 23 22:38:34 2012 +0200

    batman-adv: substitute tt_poss_change with a per-tt_entry flag
    
    tt_poss_change is a node-wide flag which tells whether the node is in a roaming
    state (a client recently moved to/away from it) in order to let it apply special
    re-routing rules. However this flag does not give a clear idea of the current
    state because it is not possible to understand *which client* is actually
    involved in the roaming. For this reason a better approach has been chosen:
    instead of using a node-wide variable, the roaming state is now given by a
    per-tt_entry ROAM flag which, in case of packet coming through the node, tells
    the node whether the real destination is in roaming state or not.
    
    With this flag change, batadv_check_unicast_ttvn() has also been rearranged in
    order to better fit the new re-routing logic and to be much more readable.
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c283d87c4cce..2d1f89517d99 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -505,7 +505,6 @@ struct net_device *batadv_softif_create(const char *name)
 #endif
 	bat_priv->tt.last_changeset = NULL;
 	bat_priv->tt.last_changeset_len = 0;
-	bat_priv->tt.poss_change = false;
 
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;

commit 4046b24aface62f5647699e9af3260a486bc5f49
Author: Martin Hundebøll <martin@hundeboll.net>
Date:   Fri Apr 20 17:02:45 2012 +0200

    batman-adv: Add get_ethtool_stats() support for DAT
    
    Added additional counters for D.A.T.
    
    Signed-off-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 7b4a3a3d9dd5..c283d87c4cce 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -625,6 +625,13 @@ static const struct {
 	{ "tt_response_rx" },
 	{ "tt_roam_adv_tx" },
 	{ "tt_roam_adv_rx" },
+#ifdef CONFIG_BATMAN_ADV_DAT
+	{ "dat_get_tx" },
+	{ "dat_get_rx" },
+	{ "dat_put_tx" },
+	{ "dat_put_rx" },
+	{ "dat_cached_reply_tx" },
+#endif
 };
 
 static void batadv_get_strings(struct net_device *dev, uint32_t stringset,

commit 33af49ad8ae44de52c0ac30b1a9707dad5e4c418
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Wed Aug 8 18:50:57 2012 +0200

    batman-adv: Distributed ARP Table - add runtime switch
    
    This patch adds a runtime switch that enables the user to turn the DAT feature
    on or off at runtime
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 9dc0ae1d4da3..7b4a3a3d9dd5 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -480,6 +480,9 @@ struct net_device *batadv_softif_create(const char *name)
 	atomic_set(&bat_priv->aggregated_ogms, 1);
 	atomic_set(&bat_priv->bonding, 0);
 	atomic_set(&bat_priv->bridge_loop_avoidance, 0);
+#ifdef CONFIG_BATMAN_ADV_DAT
+	atomic_set(&bat_priv->distributed_arp_table, 1);
+#endif
 	atomic_set(&bat_priv->ap_isolation, 0);
 	atomic_set(&bat_priv->vis_mode, BATADV_VIS_TYPE_CLIENT_UPDATE);
 	atomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);

commit c384ea3ec930ef11060a7308fbbd02b4871384f9
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Sun Jun 26 03:37:18 2011 +0200

    batman-adv: Distributed ARP Table - add snooping functions for ARP messages
    
    In case of an ARP message going in or out the soft_iface, it is intercepted and
    a special action is performed. In particular the DHT helper functions previously
    implemented are used to store all the ARP entries belonging to the network in
    order to provide a fast and unicast lookup instead of the classic broadcast
    flooding mechanism.
    Each node stores the entries it is responsible for (following the DHT rules) in
    its soft_iface ARP table. This makes it possible to reuse the kernel data
    structures and functions for ARP management.
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 2f123a1b174b..9dc0ae1d4da3 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -20,6 +20,7 @@
 #include "main.h"
 #include "soft-interface.h"
 #include "hard-interface.h"
+#include "distributed-arp-table.h"
 #include "routing.h"
 #include "send.h"
 #include "debugfs.h"
@@ -155,6 +156,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	short vid __maybe_unused = -1;
 	bool do_bcast = false;
 	uint32_t seqno;
+	unsigned long brd_delay = 1;
 
 	if (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)
 		goto dropped;
@@ -224,6 +226,13 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		if (!primary_if)
 			goto dropped;
 
+		/* in case of ARP request, we do not immediately broadcasti the
+		 * packet, instead we first wait for DAT to try to retrieve the
+		 * correct ARP entry
+		 */
+		if (batadv_dat_snoop_outgoing_arp_request(bat_priv, skb))
+			brd_delay = msecs_to_jiffies(ARP_REQ_DELAY);
+
 		if (batadv_skb_head_push(skb, sizeof(*bcast_packet)) < 0)
 			goto dropped;
 
@@ -245,7 +254,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		seqno = atomic_inc_return(&bat_priv->bcast_seqno);
 		bcast_packet->seqno = htonl(seqno);
 
-		batadv_add_bcast_packet_to_list(bat_priv, skb, 1);
+		batadv_add_bcast_packet_to_list(bat_priv, skb, brd_delay);
 
 		/* a copy is stored in the bcast list, therefore removing
 		 * the original skb.
@@ -260,6 +269,11 @@ static int batadv_interface_tx(struct sk_buff *skb,
 				goto dropped;
 		}
 
+		if (batadv_dat_snoop_outgoing_arp_request(bat_priv, skb))
+			goto dropped;
+
+		batadv_dat_snoop_outgoing_arp_reply(bat_priv, skb);
+
 		ret = batadv_unicast_send_skb(bat_priv, skb);
 		if (ret != 0)
 			goto dropped_freed;

commit 7cdcf6dddc428c90ac867267a8d301e9e8b25612
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Mon Oct 1 09:57:35 2012 +0200

    batman-adv: add UNICAST_4ADDR packet type
    
    The current unicast packet type does not contain the orig source address. This
    patches add a new unicast packet (called UNICAST_4ADDR) which provides two new
    fields: the originator source address and the subtype (the type of the data
    contained in the packet payload). The former is useful to identify the node
    which injected the packet into the network and the latter is useful to avoid
    creating new unicast packet types in the future: a macro defining a new subtype
    will be enough.
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 22bc65102370..2f123a1b174b 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -260,7 +260,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 				goto dropped;
 		}
 
-		ret = batadv_unicast_send_skb(skb, bat_priv);
+		ret = batadv_unicast_send_skb(bat_priv, skb);
 		if (ret != 0)
 			goto dropped_freed;
 	}

commit 4934ab951b742f7a7bbe7089f1b3d8e4a387e596
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Sun Aug 19 20:10:09 2012 +0200

    batman-adv: don't allow ECTP traffic on batman-adv
    
    We have seen this to break networks when used with bridge loop
    avoidance. As we can't see any benefit from sending these ancient frames
    via our mesh, we just drop them.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 948860a2a576..22bc65102370 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -146,8 +146,10 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	struct batadv_bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
 	__be16 ethertype = __constant_htons(BATADV_ETH_P_BATMAN);
-	static const uint8_t stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00, 0x00,
-						   0x00};
+	static const uint8_t stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00,
+						   0x00, 0x00};
+	static const uint8_t ectp_addr[ETH_ALEN] = {0xCF, 0x00, 0x00, 0x00,
+						    0x00, 0x00};
 	unsigned int header_len = 0;
 	int data_len = skb->len, ret;
 	short vid __maybe_unused = -1;
@@ -180,10 +182,16 @@ static int batadv_interface_tx(struct sk_buff *skb,
 
 	/* don't accept stp packets. STP does not help in meshes.
 	 * better use the bridge loop avoidance ...
+	 *
+	 * The same goes for ECTP sent at least by some Cisco Switches,
+	 * it might confuse the mesh when used with bridge loop avoidance.
 	 */
 	if (batadv_compare_eth(ethhdr->h_dest, stp_addr))
 		goto dropped;
 
+	if (batadv_compare_eth(ethhdr->h_dest, ectp_addr))
+		goto dropped;
+
 	if (is_multicast_ether_addr(ethhdr->h_dest)) {
 		do_bcast = true;
 

commit 36c1d1531130dcfadf845419fd15735b9b4c004f
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Aug 20 09:03:59 2012 +0200

    batman-adv: Set special lockdep classes to avoid lockdep warning
    
    Transmissions over batman-adv devices always start another nested transmission
    over devices attached to the batman-adv interface. These devices usually use
    the ethernet lockdep class for the tx_queue lock which is also set by default
    for all batman-adv devices. Lockdep will detect a nested locking attempt of two
    locks with the same class and warn about a possible deadlock.
    
    This is the default and expected behavior and should not alarm the locking
    correctness prove mechanism. Therefore, the locks for all netdevice specific tx
    queues get a special batman-adv lock class to avoid a false positive for each
    transmission.
    
    Reported-by: Linus Luessing <linus.luessing@web.de>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b9a28d2dd3e8..948860a2a576 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -347,7 +347,51 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	return;
 }
 
+/* batman-adv network devices have devices nesting below it and are a special
+ * "super class" of normal network devices; split their locks off into a
+ * separate class since they always nest.
+ */
+static struct lock_class_key batadv_netdev_xmit_lock_key;
+static struct lock_class_key batadv_netdev_addr_lock_key;
+
+/**
+ * batadv_set_lockdep_class_one - Set lockdep class for a single tx queue
+ * @dev: device which owns the tx queue
+ * @txq: tx queue to modify
+ * @_unused: always NULL
+ */
+static void batadv_set_lockdep_class_one(struct net_device *dev,
+					 struct netdev_queue *txq,
+					 void *_unused)
+{
+	lockdep_set_class(&txq->_xmit_lock, &batadv_netdev_xmit_lock_key);
+}
+
+/**
+ * batadv_set_lockdep_class - Set txq and addr_list lockdep class
+ * @dev: network device to modify
+ */
+static void batadv_set_lockdep_class(struct net_device *dev)
+{
+	lockdep_set_class(&dev->addr_list_lock, &batadv_netdev_addr_lock_key);
+	netdev_for_each_tx_queue(dev, batadv_set_lockdep_class_one, NULL);
+}
+
+/**
+ * batadv_softif_init - Late stage initialization of soft interface
+ * @dev: registered network device to modify
+ *
+ * Returns error code on failures
+ */
+static int batadv_softif_init(struct net_device *dev)
+{
+	batadv_set_lockdep_class(dev);
+
+	return 0;
+}
+
 static const struct net_device_ops batadv_netdev_ops = {
+	.ndo_init = batadv_softif_init,
 	.ndo_open = batadv_interface_open,
 	.ndo_stop = batadv_interface_release,
 	.ndo_get_stats = batadv_interface_stats,

commit 6a06e5e1bb217be077e1f8ee2745b4c5b1aa02db
Merge: d9f72f359e00 6672d90fe779
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Sep 28 14:40:49 2012 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/team/team.c
            drivers/net/usb/qmi_wwan.c
            net/batman-adv/bat_iv_ogm.c
            net/ipv4/fib_frontend.c
            net/ipv4/route.c
            net/l2tp/l2tp_netlink.c
    
    The team, fib_frontend, route, and l2tp_netlink conflicts were simply
    overlapping changes.
    
    qmi_wwan and bat_iv_ogm were of the "use HEAD" variety.
    
    With help from Antonio Quartulli.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 40a3eb33e307616567f4b81792f405a7f3f0abee
Author: Def <def@laposte.net>
Date:   Thu Sep 20 14:56:13 2012 +0200

    batman-adv: Fix change mac address of soft iface.
    
    Into function interface_set_mac_addr, the function tt_local_add was
    invoked before updating dev->dev_addr. The new MAC address was not
    tagged as NoPurge.
    
    Signed-off-by: Def <def@laposte.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 109ea2aae96c..21c53577c8d6 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -100,18 +100,21 @@ static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 {
 	struct batadv_priv *bat_priv = netdev_priv(dev);
 	struct sockaddr *addr = p;
+	uint8_t old_addr[ETH_ALEN];
 
 	if (!is_valid_ether_addr(addr->sa_data))
 		return -EADDRNOTAVAIL;
 
+	memcpy(old_addr, dev->dev_addr, ETH_ALEN);
+	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
+
 	/* only modify transtable if it has been initialized before */
 	if (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_ACTIVE) {
-		batadv_tt_local_remove(bat_priv, dev->dev_addr,
+		batadv_tt_local_remove(bat_priv, old_addr,
 				       "mac address changed", false);
 		batadv_tt_local_add(dev, addr->sa_data, BATADV_NULL_IFINDEX);
 	}
 
-	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
 	dev->addr_assign_type &= ~NET_ADDR_RANDOM;
 	return 0;
 }

commit 371351731e9c2a7d8f4b169731495cb4f0589063
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Thu Jul 5 23:38:30 2012 +0200

    batman-adv: change interface_rx to get orig node
    
    In order to understand  where a broadcast packet is coming from and use
    this information to detect not yet announced clients, this patch modifies the
    interface_rx() function by passing a new argument: the orig node
    corresponding to the node that originated the received packet (if known).
    This new argument if not NULL for broadcast packets only (other packets does not
    have source field).
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 03b0763abd2f..7b683e0bd668 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -270,7 +270,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 
 void batadv_interface_rx(struct net_device *soft_iface,
 			 struct sk_buff *skb, struct batadv_hard_iface *recv_if,
-			 int hdr_size)
+			 int hdr_size, struct batadv_orig_node *orig_node)
 {
 	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
 	struct ethhdr *ethhdr;
@@ -322,6 +322,10 @@ void batadv_interface_rx(struct net_device *soft_iface,
 
 	soft_iface->last_rx = jiffies;
 
+	if (orig_node)
+		batadv_tt_add_temporary_global_entry(bat_priv, orig_node,
+						     ethhdr->h_source);
+
 	if (batadv_is_ap_isolated(bat_priv, ethhdr->h_source, ethhdr->h_dest))
 		goto dropped;
 

commit bbb1f90efba89b31fc5e329d5fcaf10aca99212b
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jul 8 17:13:15 2012 +0200

    batman-adv: Don't break statements after assignment operator
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 6d44625c0f5e..03b0763abd2f 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -149,6 +149,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	int data_len = skb->len, ret;
 	short vid __maybe_unused = -1;
 	bool do_bcast = false;
+	uint32_t seqno;
 
 	if (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)
 		goto dropped;
@@ -230,8 +231,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		       primary_if->net_dev->dev_addr, ETH_ALEN);
 
 		/* set broadcast sequence number */
-		bcast_packet->seqno =
-			htonl(atomic_inc_return(&bat_priv->bcast_seqno));
+		seqno = atomic_inc_return(&bat_priv->bcast_seqno);
+		bcast_packet->seqno = htonl(seqno);
 
 		batadv_add_bcast_packet_to_list(bat_priv, skb, 1);
 

commit 807736f6e00714fdeb443b31061d1c27fa903296
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jul 15 22:26:51 2012 +0200

    batman-adv: Split batadv_priv in sub-structures for features
    
    The structure batadv_priv grows everytime a new feature is introduced. It gets
    hard to find the parts of the struct that belongs to a specific feature. This
    becomes even harder by the fact that not every feature uses a prefix in the
    member name.
    
    The variables for bridge loop avoidence, gateway handling, translation table
    and visualization server are moved into separate structs that are included in
    the bat_priv main struct.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 2b3842b99096..6d44625c0f5e 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -420,14 +420,15 @@ struct net_device *batadv_softif_create(const char *name)
 
 	atomic_set(&bat_priv->mesh_state, BATADV_MESH_INACTIVE);
 	atomic_set(&bat_priv->bcast_seqno, 1);
-	atomic_set(&bat_priv->ttvn, 0);
-	atomic_set(&bat_priv->tt_local_changes, 0);
-	atomic_set(&bat_priv->tt_ogm_append_cnt, 0);
-	atomic_set(&bat_priv->bla_num_requests, 0);
-
-	bat_priv->tt_buff = NULL;
-	bat_priv->tt_buff_len = 0;
-	bat_priv->tt_poss_change = false;
+	atomic_set(&bat_priv->tt.vn, 0);
+	atomic_set(&bat_priv->tt.local_changes, 0);
+	atomic_set(&bat_priv->tt.ogm_append_cnt, 0);
+#ifdef CONFIG_BATMAN_ADV_BLA
+	atomic_set(&bat_priv->bla.num_requests, 0);
+#endif
+	bat_priv->tt.last_changeset = NULL;
+	bat_priv->tt.last_changeset_len = 0;
+	bat_priv->tt.poss_change = false;
 
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;

commit 1c9b0550f4813c4931b4e142c80f5c89be9489ec
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Sat Jun 23 11:47:53 2012 +0200

    batman-adv: convert remaining packet counters to per_cpu_ptr() infrastructure
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Acked-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 109ea2aae96c..2b3842b99096 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -93,7 +93,14 @@ static int batadv_interface_release(struct net_device *dev)
 static struct net_device_stats *batadv_interface_stats(struct net_device *dev)
 {
 	struct batadv_priv *bat_priv = netdev_priv(dev);
-	return &bat_priv->stats;
+	struct net_device_stats *stats = &bat_priv->stats;
+
+	stats->tx_packets = batadv_sum_counter(bat_priv, BATADV_CNT_TX);
+	stats->tx_bytes = batadv_sum_counter(bat_priv, BATADV_CNT_TX_BYTES);
+	stats->tx_dropped = batadv_sum_counter(bat_priv, BATADV_CNT_TX_DROPPED);
+	stats->rx_packets = batadv_sum_counter(bat_priv, BATADV_CNT_RX);
+	stats->rx_bytes = batadv_sum_counter(bat_priv, BATADV_CNT_RX_BYTES);
+	return stats;
 }
 
 static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
@@ -246,14 +253,14 @@ static int batadv_interface_tx(struct sk_buff *skb,
 			goto dropped_freed;
 	}
 
-	bat_priv->stats.tx_packets++;
-	bat_priv->stats.tx_bytes += data_len;
+	batadv_inc_counter(bat_priv, BATADV_CNT_TX);
+	batadv_add_counter(bat_priv, BATADV_CNT_TX_BYTES, data_len);
 	goto end;
 
 dropped:
 	kfree_skb(skb);
 dropped_freed:
-	bat_priv->stats.tx_dropped++;
+	batadv_inc_counter(bat_priv, BATADV_CNT_TX_DROPPED);
 end:
 	if (primary_if)
 		batadv_hardif_free_ref(primary_if);
@@ -308,8 +315,9 @@ void batadv_interface_rx(struct net_device *soft_iface,
 
 	/* skb->ip_summed = CHECKSUM_UNNECESSARY; */
 
-	bat_priv->stats.rx_packets++;
-	bat_priv->stats.rx_bytes += skb->len + ETH_HLEN;
+	batadv_inc_counter(bat_priv, BATADV_CNT_RX);
+	batadv_add_counter(bat_priv, BATADV_CNT_RX_BYTES,
+			   skb->len + ETH_HLEN);
 
 	soft_iface->last_rx = jiffies;
 
@@ -379,15 +387,22 @@ struct net_device *batadv_softif_create(const char *name)
 	if (!soft_iface)
 		goto out;
 
+	bat_priv = netdev_priv(soft_iface);
+
+	/* batadv_interface_stats() needs to be available as soon as
+	 * register_netdevice() has been called
+	 */
+	bat_priv->bat_counters = __alloc_percpu(cnt_len, __alignof__(uint64_t));
+	if (!bat_priv->bat_counters)
+		goto free_soft_iface;
+
 	ret = register_netdevice(soft_iface);
 	if (ret < 0) {
 		pr_err("Unable to register the batman interface '%s': %i\n",
 		       name, ret);
-		goto free_soft_iface;
+		goto free_bat_counters;
 	}
 
-	bat_priv = netdev_priv(soft_iface);
-
 	atomic_set(&bat_priv->aggregated_ogms, 1);
 	atomic_set(&bat_priv->bonding, 0);
 	atomic_set(&bat_priv->bridge_loop_avoidance, 0);
@@ -417,17 +432,13 @@ struct net_device *batadv_softif_create(const char *name)
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;
 
-	bat_priv->bat_counters = __alloc_percpu(cnt_len, __alignof__(uint64_t));
-	if (!bat_priv->bat_counters)
-		goto unreg_soft_iface;
-
 	ret = batadv_algo_select(bat_priv, batadv_routing_algo);
 	if (ret < 0)
-		goto free_bat_counters;
+		goto unreg_soft_iface;
 
 	ret = batadv_sysfs_add_meshif(soft_iface);
 	if (ret < 0)
-		goto free_bat_counters;
+		goto unreg_soft_iface;
 
 	ret = batadv_debugfs_add_meshif(soft_iface);
 	if (ret < 0)
@@ -443,12 +454,13 @@ struct net_device *batadv_softif_create(const char *name)
 	batadv_debugfs_del_meshif(soft_iface);
 unreg_sysfs:
 	batadv_sysfs_del_meshif(soft_iface);
-free_bat_counters:
-	free_percpu(bat_priv->bat_counters);
 unreg_soft_iface:
+	free_percpu(bat_priv->bat_counters);
 	unregister_netdevice(soft_iface);
 	return NULL;
 
+free_bat_counters:
+	free_percpu(bat_priv->bat_counters);
 free_soft_iface:
 	free_netdev(soft_iface);
 out:
@@ -518,6 +530,11 @@ static u32 batadv_get_link(struct net_device *dev)
 static const struct {
 	const char name[ETH_GSTRING_LEN];
 } batadv_counters_strings[] = {
+	{ "tx" },
+	{ "tx_bytes" },
+	{ "tx_dropped" },
+	{ "rx" },
+	{ "rx_bytes" },
 	{ "forward" },
 	{ "forward_bytes" },
 	{ "mgmt_tx" },

commit 04c9f416e371cff076a8b3279fb213628915d059
Merge: c278fa53c123 c1f5163de417
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 10 23:56:33 2012 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            net/batman-adv/bridge_loop_avoidance.c
            net/batman-adv/bridge_loop_avoidance.h
            net/batman-adv/soft-interface.c
            net/mac80211/mlme.c
    
    With merge help from Antonio Quartulli (batman-adv) and
    Stephen Rothwell (drivers/net/usb/qmi_wwan.c).
    
    The net/mac80211/mlme.c conflict seemed easy enough, accounting for a
    conversion to some new tracing macros.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2d3f6ccc4ea5c74d4b4af1b47c56b4cff4bbfcb7
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Wed Jul 4 20:38:19 2012 +0200

    batman-adv: check incoming packet type for bla
    
    If the gateway functionality is used, some broadcast packets (DHCP
    requests) may be transmitted as unicast packets. As the bridge loop
    avoidance code now only considers the payload Ethernet destination,
    it may drop the DHCP request for clients which are claimed by other
    backbone gateways, because it falsely infers from the broadcast address
    that the right backbone gateway should havehandled the broadcast.
    
    Fix this by checking and delegating the batman-adv packet type used
    for transmission.
    
    Reported-by: Guido Iribarren <guidoiribarren@buenosaireslibre.org>
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 6e2530b02043..a0ec0e4ada4c 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -256,7 +256,11 @@ void interface_rx(struct net_device *soft_iface,
 	struct bat_priv *bat_priv = netdev_priv(soft_iface);
 	struct ethhdr *ethhdr;
 	struct vlan_ethhdr *vhdr;
+	struct batman_header *batadv_header = (struct batman_header *)skb->data;
 	short vid __maybe_unused = -1;
+	bool is_bcast;
+
+	is_bcast = (batadv_header->packet_type == BAT_BCAST);
 
 	/* check if enough space is available for pulling, and pull */
 	if (!pskb_may_pull(skb, hdr_size))
@@ -302,7 +306,7 @@ void interface_rx(struct net_device *soft_iface,
 	/* Let the bridge loop avoidance check the packet. If will
 	 * not handle it, we can safely push it up.
 	 */
-	if (bla_rx(bat_priv, skb, vid))
+	if (bla_rx(bat_priv, skb, vid, is_bcast))
 		goto out;
 
 	netif_rx(skb);

commit 162d549c6905485262635fe594db337efb2828b5
Author: Sven Eckelmann <sven@narfation.org>
Date:   Thu Jun 28 11:56:52 2012 +0200

    batman-adv: Don't leak information through uninitialized packet fields
    
    The reserved fields in batman-adv packets are not set to a constant value. The
    content of these memory regions is leaked unintentionally to the network.
    
    This regression was introduced in 3b27ffb00fbe9d9189715ea13ce8712e2f0cb0c5
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b7c655cf626a..9e4bb61301ec 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -214,6 +214,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 
 		/* batman packet type: broadcast */
 		bcast_packet->header.packet_type = BATADV_BCAST;
+		bcast_packet->reserved = 0;
 
 		/* hw address of first interface is the orig mac because only
 		 * this mac is known throughout the mesh

commit b706b13b6cfde22d1f4adc540fd89426247c1e3e
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jun 10 23:58:51 2012 +0200

    batman-adv: Remove bat_ prefix from bat_{debugfs, sysfs}.{c, h}
    
    The "bat_" prefix in the source files implementing the batman-adv sysfs and
    debugfs interface doesn't have a special meaning and are only used by these
    files and files that implement the actual B.A.T.M.A.N. path finding algorithm.
    
    The prefix is better suited to mark files that are used to implement the main
    part of the path finding. All other files should not use it and therefore gets
    renamed.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 7a7d82185393..b7c655cf626a 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -22,12 +22,12 @@
 #include "hard-interface.h"
 #include "routing.h"
 #include "send.h"
-#include "bat_debugfs.h"
+#include "debugfs.h"
 #include "translation-table.h"
 #include "hash.h"
 #include "gateway_common.h"
 #include "gateway_client.h"
-#include "bat_sysfs.h"
+#include "sysfs.h"
 #include "originator.h"
 #include <linux/slab.h>
 #include <linux/ethtool.h>

commit 56303d34a332be8e2f4daf7891ebc12cb7900529
Author: Sven Eckelmann <sven@narfation.org>
Date:   Tue Jun 5 22:31:31 2012 +0200

    batman-adv: Prefix types structs with batadv_
    
    Reported-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 0a5d73a549f6..7a7d82185393 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -92,13 +92,13 @@ static int batadv_interface_release(struct net_device *dev)
 
 static struct net_device_stats *batadv_interface_stats(struct net_device *dev)
 {
-	struct bat_priv *bat_priv = netdev_priv(dev);
+	struct batadv_priv *bat_priv = netdev_priv(dev);
 	return &bat_priv->stats;
 }
 
 static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 {
-	struct bat_priv *bat_priv = netdev_priv(dev);
+	struct batadv_priv *bat_priv = netdev_priv(dev);
 	struct sockaddr *addr = p;
 
 	if (!is_valid_ether_addr(addr->sa_data))
@@ -131,8 +131,8 @@ static int batadv_interface_tx(struct sk_buff *skb,
 			       struct net_device *soft_iface)
 {
 	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
-	struct bat_priv *bat_priv = netdev_priv(soft_iface);
-	struct hard_iface *primary_if = NULL;
+	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
+	struct batadv_hard_iface *primary_if = NULL;
 	struct batadv_bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
 	__be16 ethertype = __constant_htons(BATADV_ETH_P_BATMAN);
@@ -260,10 +260,10 @@ static int batadv_interface_tx(struct sk_buff *skb,
 }
 
 void batadv_interface_rx(struct net_device *soft_iface,
-			 struct sk_buff *skb, struct hard_iface *recv_if,
+			 struct sk_buff *skb, struct batadv_hard_iface *recv_if,
 			 int hdr_size)
 {
-	struct bat_priv *bat_priv = netdev_priv(soft_iface);
+	struct batadv_priv *bat_priv = netdev_priv(soft_iface);
 	struct ethhdr *ethhdr;
 	struct vlan_ethhdr *vhdr;
 	short vid __maybe_unused = -1;
@@ -338,7 +338,7 @@ static const struct net_device_ops batadv_netdev_ops = {
 
 static void batadv_interface_setup(struct net_device *dev)
 {
-	struct bat_priv *priv = netdev_priv(dev);
+	struct batadv_priv *priv = netdev_priv(dev);
 
 	ether_setup(dev);
 
@@ -364,7 +364,7 @@ static void batadv_interface_setup(struct net_device *dev)
 struct net_device *batadv_softif_create(const char *name)
 {
 	struct net_device *soft_iface;
-	struct bat_priv *bat_priv;
+	struct batadv_priv *bat_priv;
 	int ret;
 	size_t cnt_len = sizeof(uint64_t) * BATADV_CNT_NUM;
 
@@ -539,7 +539,7 @@ static void batadv_get_ethtool_stats(struct net_device *dev,
 				     struct ethtool_stats *stats,
 				     uint64_t *data)
 {
-	struct bat_priv *bat_priv = netdev_priv(dev);
+	struct batadv_priv *bat_priv = netdev_priv(dev);
 	int i;
 
 	for (i = 0; i < BATADV_CNT_NUM; i++)

commit 96412690116afcc1b2705615b5a7c8dc6c5e905f
Author: Sven Eckelmann <sven@narfation.org>
Date:   Tue Jun 5 22:31:30 2012 +0200

    batman-adv: Prefix packet structs with batadv_
    
    Reported-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 0a00324e67e3..0a5d73a549f6 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -133,7 +133,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
 	struct bat_priv *bat_priv = netdev_priv(soft_iface);
 	struct hard_iface *primary_if = NULL;
-	struct bcast_packet *bcast_packet;
+	struct batadv_bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
 	__be16 ethertype = __constant_htons(BATADV_ETH_P_BATMAN);
 	static const uint8_t stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00, 0x00,
@@ -208,7 +208,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		if (batadv_skb_head_push(skb, sizeof(*bcast_packet)) < 0)
 			goto dropped;
 
-		bcast_packet = (struct bcast_packet *)skb->data;
+		bcast_packet = (struct batadv_bcast_packet *)skb->data;
 		bcast_packet->header.version = BATADV_COMPAT_VERSION;
 		bcast_packet->header.ttl = BATADV_TTL;
 

commit 39c75a51eda38ca5ce8b75f0a62a621eb3820a54
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jun 3 22:19:22 2012 +0200

    batman-adv: Prefix main enum with BATADV_
    
    Reported-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 3aae91d0d59a..0a00324e67e3 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -105,7 +105,7 @@ static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 		return -EADDRNOTAVAIL;
 
 	/* only modify transtable if it has been initialized before */
-	if (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE) {
+	if (atomic_read(&bat_priv->mesh_state) == BATADV_MESH_ACTIVE) {
 		batadv_tt_local_remove(bat_priv, dev->dev_addr,
 				       "mac address changed", false);
 		batadv_tt_local_add(dev, addr->sa_data, BATADV_NULL_IFINDEX);
@@ -143,7 +143,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	short vid __maybe_unused = -1;
 	bool do_bcast = false;
 
-	if (atomic_read(&bat_priv->mesh_state) != MESH_ACTIVE)
+	if (atomic_read(&bat_priv->mesh_state) != BATADV_MESH_ACTIVE)
 		goto dropped;
 
 	soft_iface->trans_start = jiffies;
@@ -398,7 +398,7 @@ struct net_device *batadv_softif_create(const char *name)
 	atomic_set(&bat_priv->bcast_queue_left, BATADV_BCAST_QUEUE_LEN);
 	atomic_set(&bat_priv->batman_queue_left, BATADV_BATMAN_QUEUE_LEN);
 
-	atomic_set(&bat_priv->mesh_state, MESH_INACTIVE);
+	atomic_set(&bat_priv->mesh_state, BATADV_MESH_INACTIVE);
 	atomic_set(&bat_priv->bcast_seqno, 1);
 	atomic_set(&bat_priv->ttvn, 0);
 	atomic_set(&bat_priv->tt_local_changes, 0);

commit acd34afa89772f6379b642bb979d0a112328c769
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jun 3 22:19:21 2012 +0200

    batman-adv: Prefix packet enum with BATADV_
    
    Reported-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 19a80d276585..3aae91d0d59a 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -213,7 +213,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		bcast_packet->header.ttl = BATADV_TTL;
 
 		/* batman packet type: broadcast */
-		bcast_packet->header.packet_type = BAT_BCAST;
+		bcast_packet->header.packet_type = BATADV_BCAST;
 
 		/* hw address of first interface is the orig mac because only
 		 * this mac is known throughout the mesh
@@ -387,7 +387,7 @@ struct net_device *batadv_softif_create(const char *name)
 	atomic_set(&bat_priv->bonding, 0);
 	atomic_set(&bat_priv->bridge_loop_avoidance, 0);
 	atomic_set(&bat_priv->ap_isolation, 0);
-	atomic_set(&bat_priv->vis_mode, VIS_TYPE_CLIENT_UPDATE);
+	atomic_set(&bat_priv->vis_mode, BATADV_VIS_TYPE_CLIENT_UPDATE);
 	atomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);
 	atomic_set(&bat_priv->gw_sel_class, 20);
 	atomic_set(&bat_priv->gw_bandwidth, 41);

commit d69909d2fc9e00bd8149cc8df9b18c35008e3e62
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jun 3 22:19:20 2012 +0200

    batman-adv: Prefix types enum with BATADV_
    
    Reported-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b77e598fb2b0..19a80d276585 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -366,6 +366,7 @@ struct net_device *batadv_softif_create(const char *name)
 	struct net_device *soft_iface;
 	struct bat_priv *bat_priv;
 	int ret;
+	size_t cnt_len = sizeof(uint64_t) * BATADV_CNT_NUM;
 
 	soft_iface = alloc_netdev(sizeof(*bat_priv), name,
 				  batadv_interface_setup);
@@ -411,8 +412,7 @@ struct net_device *batadv_softif_create(const char *name)
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;
 
-	bat_priv->bat_counters = __alloc_percpu(sizeof(uint64_t) * BAT_CNT_NUM,
-						__alignof__(uint64_t));
+	bat_priv->bat_counters = __alloc_percpu(cnt_len, __alignof__(uint64_t));
 	if (!bat_priv->bat_counters)
 		goto unreg_soft_iface;
 
@@ -542,14 +542,14 @@ static void batadv_get_ethtool_stats(struct net_device *dev,
 	struct bat_priv *bat_priv = netdev_priv(dev);
 	int i;
 
-	for (i = 0; i < BAT_CNT_NUM; i++)
+	for (i = 0; i < BATADV_CNT_NUM; i++)
 		data[i] = batadv_sum_counter(bat_priv, i);
 }
 
 static int batadv_get_sset_count(struct net_device *dev, int stringset)
 {
 	if (stringset == ETH_SS_STATS)
-		return BAT_CNT_NUM;
+		return BATADV_CNT_NUM;
 
 	return -EOPNOTSUPP;
 }

commit cd646ab1e2edde9faeff52bbc1b40e58a5e381fc
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jun 3 22:19:18 2012 +0200

    batman-adv: Prefix gateway enum with BATADV_
    
    Reported-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c1b2ab2f37bb..b77e598fb2b0 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -177,7 +177,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		do_bcast = true;
 
 		switch (atomic_read(&bat_priv->gw_mode)) {
-		case GW_MODE_SERVER:
+		case BATADV_GW_MODE_SERVER:
 			/* gateway servers should not send dhcp
 			 * requests into the mesh
 			 */
@@ -185,7 +185,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 			if (ret)
 				goto dropped;
 			break;
-		case GW_MODE_CLIENT:
+		case BATADV_GW_MODE_CLIENT:
 			/* gateway clients should send dhcp requests
 			 * via unicast to their gateway
 			 */
@@ -193,7 +193,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 			if (ret)
 				do_bcast = false;
 			break;
-		case GW_MODE_OFF:
+		case BATADV_GW_MODE_OFF:
 		default:
 			break;
 		}
@@ -234,7 +234,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 
 	/* unicast packet */
 	} else {
-		if (atomic_read(&bat_priv->gw_mode) != GW_MODE_OFF) {
+		if (atomic_read(&bat_priv->gw_mode) != BATADV_GW_MODE_OFF) {
 			ret = batadv_gw_out_of_range(bat_priv, skb, ethhdr);
 			if (ret)
 				goto dropped;
@@ -387,7 +387,7 @@ struct net_device *batadv_softif_create(const char *name)
 	atomic_set(&bat_priv->bridge_loop_avoidance, 0);
 	atomic_set(&bat_priv->ap_isolation, 0);
 	atomic_set(&bat_priv->vis_mode, VIS_TYPE_CLIENT_UPDATE);
-	atomic_set(&bat_priv->gw_mode, GW_MODE_OFF);
+	atomic_set(&bat_priv->gw_mode, BATADV_GW_MODE_OFF);
 	atomic_set(&bat_priv->gw_sel_class, 20);
 	atomic_set(&bat_priv->gw_bandwidth, 41);
 	atomic_set(&bat_priv->orig_interval, 1000);

commit 42d0b044b7c9e5821f1bf3e2b4ea7861417c11c2
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jun 3 22:19:17 2012 +0200

    batman-adv: Prefix main defines with BATADV_
    
    Reported-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index bbbc9a93d430..c1b2ab2f37bb 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -108,7 +108,7 @@ static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 	if (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE) {
 		batadv_tt_local_remove(bat_priv, dev->dev_addr,
 				       "mac address changed", false);
-		batadv_tt_local_add(dev, addr->sa_data, NULL_IFINDEX);
+		batadv_tt_local_add(dev, addr->sa_data, BATADV_NULL_IFINDEX);
 	}
 
 	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
@@ -210,7 +210,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 
 		bcast_packet = (struct bcast_packet *)skb->data;
 		bcast_packet->header.version = BATADV_COMPAT_VERSION;
-		bcast_packet->header.ttl = TTL;
+		bcast_packet->header.ttl = BATADV_TTL;
 
 		/* batman packet type: broadcast */
 		bcast_packet->header.packet_type = BAT_BCAST;
@@ -394,8 +394,8 @@ struct net_device *batadv_softif_create(const char *name)
 	atomic_set(&bat_priv->hop_penalty, 30);
 	atomic_set(&bat_priv->log_level, 0);
 	atomic_set(&bat_priv->fragmentation, 1);
-	atomic_set(&bat_priv->bcast_queue_left, BCAST_QUEUE_LEN);
-	atomic_set(&bat_priv->batman_queue_left, BATMAN_QUEUE_LEN);
+	atomic_set(&bat_priv->bcast_queue_left, BATADV_BCAST_QUEUE_LEN);
+	atomic_set(&bat_priv->batman_queue_left, BATADV_BATMAN_QUEUE_LEN);
 
 	atomic_set(&bat_priv->mesh_state, MESH_INACTIVE);
 	atomic_set(&bat_priv->bcast_seqno, 1);
@@ -487,7 +487,7 @@ static void batadv_get_drvinfo(struct net_device *dev,
 			       struct ethtool_drvinfo *info)
 {
 	strcpy(info->driver, "B.A.T.M.A.N. advanced");
-	strcpy(info->version, SOURCE_VERSION);
+	strcpy(info->version, BATADV_SOURCE_VERSION);
 	strcpy(info->fw_version, "N/A");
 	strcpy(info->bus_info, "batman");
 }

commit c11fdfaefa46a83a668a73dc3ae90859e99ed251
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jun 3 22:19:14 2012 +0200

    batman-adv: Prefix types defines with BATADV_
    
    Reported-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e726419045e4..bbbc9a93d430 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -351,7 +351,7 @@ static void batadv_interface_setup(struct net_device *dev)
 	 */
 	dev->mtu = ETH_DATA_LEN;
 	/* reserve more space in the skbuff for our header */
-	dev->hard_header_len = BAT_HEADER_LEN;
+	dev->hard_header_len = BATADV_HEADER_LEN;
 
 	/* generate random address */
 	eth_hw_addr_random(dev);

commit 7e071c79a6964130d1df4dc5ca5a6f3638680fce
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jun 3 22:19:13 2012 +0200

    batman-adv: Prefix packet defines with BATADV_
    
    Reported-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 2de1d742119f..e726419045e4 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -135,6 +135,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 	struct hard_iface *primary_if = NULL;
 	struct bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
+	__be16 ethertype = __constant_htons(BATADV_ETH_P_BATMAN);
 	static const uint8_t stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00, 0x00,
 						   0x00};
 	unsigned int header_len = 0;
@@ -152,11 +153,11 @@ static int batadv_interface_tx(struct sk_buff *skb,
 		vhdr = (struct vlan_ethhdr *)skb->data;
 		vid = ntohs(vhdr->h_vlan_TCI) & VLAN_VID_MASK;
 
-		if (ntohs(vhdr->h_vlan_encapsulated_proto) != ETH_P_BATMAN)
+		if (vhdr->h_vlan_encapsulated_proto != ethertype)
 			break;
 
 		/* fall through */
-	case ETH_P_BATMAN:
+	case BATADV_ETH_P_BATMAN:
 		goto dropped;
 	}
 
@@ -208,7 +209,7 @@ static int batadv_interface_tx(struct sk_buff *skb,
 			goto dropped;
 
 		bcast_packet = (struct bcast_packet *)skb->data;
-		bcast_packet->header.version = COMPAT_VERSION;
+		bcast_packet->header.version = BATADV_COMPAT_VERSION;
 		bcast_packet->header.ttl = TTL;
 
 		/* batman packet type: broadcast */
@@ -266,6 +267,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	struct ethhdr *ethhdr;
 	struct vlan_ethhdr *vhdr;
 	short vid __maybe_unused = -1;
+	__be16 ethertype = __constant_htons(BATADV_ETH_P_BATMAN);
 
 	/* check if enough space is available for pulling, and pull */
 	if (!pskb_may_pull(skb, hdr_size))
@@ -281,11 +283,11 @@ void batadv_interface_rx(struct net_device *soft_iface,
 		vhdr = (struct vlan_ethhdr *)skb->data;
 		vid = ntohs(vhdr->h_vlan_TCI) & VLAN_VID_MASK;
 
-		if (ntohs(vhdr->h_vlan_encapsulated_proto) != ETH_P_BATMAN)
+		if (vhdr->h_vlan_encapsulated_proto != ethertype)
 			break;
 
 		/* fall through */
-	case ETH_P_BATMAN:
+	case BATADV_ETH_P_BATMAN:
 		goto dropped;
 	}
 

commit 0294ca0d92c6539ec6e37edf65a0a5b033dd6d78
Author: Sven Eckelmann <sven@narfation.org>
Date:   Wed May 16 20:23:15 2012 +0200

    batman-adv: Prefix soft-interface local static functions with batadv_
    
    All non-static symbols of batman-adv were prefixed with batadv_ to avoid
    collisions with other symbols of the kernel. Other symbols of batman-adv
    should use the same prefix to keep the naming scheme consistent.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index af676b818637..2de1d742119f 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -37,23 +37,23 @@
 #include "bridge_loop_avoidance.h"
 
 
-static int bat_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);
-static void bat_get_drvinfo(struct net_device *dev,
-			    struct ethtool_drvinfo *info);
-static u32 bat_get_msglevel(struct net_device *dev);
-static void bat_set_msglevel(struct net_device *dev, u32 value);
-static u32 bat_get_link(struct net_device *dev);
+static int batadv_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);
+static void batadv_get_drvinfo(struct net_device *dev,
+			       struct ethtool_drvinfo *info);
+static u32 batadv_get_msglevel(struct net_device *dev);
+static void batadv_set_msglevel(struct net_device *dev, u32 value);
+static u32 batadv_get_link(struct net_device *dev);
 static void batadv_get_strings(struct net_device *dev, u32 stringset, u8 *data);
 static void batadv_get_ethtool_stats(struct net_device *dev,
 				     struct ethtool_stats *stats, u64 *data);
 static int batadv_get_sset_count(struct net_device *dev, int stringset);
 
-static const struct ethtool_ops bat_ethtool_ops = {
-	.get_settings = bat_get_settings,
-	.get_drvinfo = bat_get_drvinfo,
-	.get_msglevel = bat_get_msglevel,
-	.set_msglevel = bat_set_msglevel,
-	.get_link = bat_get_link,
+static const struct ethtool_ops batadv_ethtool_ops = {
+	.get_settings = batadv_get_settings,
+	.get_drvinfo = batadv_get_drvinfo,
+	.get_msglevel = batadv_get_msglevel,
+	.set_msglevel = batadv_set_msglevel,
+	.get_link = batadv_get_link,
 	.get_strings = batadv_get_strings,
 	.get_ethtool_stats = batadv_get_ethtool_stats,
 	.get_sset_count = batadv_get_sset_count,
@@ -78,25 +78,25 @@ int batadv_skb_head_push(struct sk_buff *skb, unsigned int len)
 	return 0;
 }
 
-static int interface_open(struct net_device *dev)
+static int batadv_interface_open(struct net_device *dev)
 {
 	netif_start_queue(dev);
 	return 0;
 }
 
-static int interface_release(struct net_device *dev)
+static int batadv_interface_release(struct net_device *dev)
 {
 	netif_stop_queue(dev);
 	return 0;
 }
 
-static struct net_device_stats *interface_stats(struct net_device *dev)
+static struct net_device_stats *batadv_interface_stats(struct net_device *dev)
 {
 	struct bat_priv *bat_priv = netdev_priv(dev);
 	return &bat_priv->stats;
 }
 
-static int interface_set_mac_addr(struct net_device *dev, void *p)
+static int batadv_interface_set_mac_addr(struct net_device *dev, void *p)
 {
 	struct bat_priv *bat_priv = netdev_priv(dev);
 	struct sockaddr *addr = p;
@@ -116,7 +116,7 @@ static int interface_set_mac_addr(struct net_device *dev, void *p)
 	return 0;
 }
 
-static int interface_change_mtu(struct net_device *dev, int new_mtu)
+static int batadv_interface_change_mtu(struct net_device *dev, int new_mtu)
 {
 	/* check ranges */
 	if ((new_mtu < 68) || (new_mtu > batadv_hardif_min_mtu(dev)))
@@ -127,7 +127,8 @@ static int interface_change_mtu(struct net_device *dev, int new_mtu)
 	return 0;
 }
 
-static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
+static int batadv_interface_tx(struct sk_buff *skb,
+			       struct net_device *soft_iface)
 {
 	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
 	struct bat_priv *bat_priv = netdev_priv(soft_iface);
@@ -323,23 +324,23 @@ void batadv_interface_rx(struct net_device *soft_iface,
 	return;
 }
 
-static const struct net_device_ops bat_netdev_ops = {
-	.ndo_open = interface_open,
-	.ndo_stop = interface_release,
-	.ndo_get_stats = interface_stats,
-	.ndo_set_mac_address = interface_set_mac_addr,
-	.ndo_change_mtu = interface_change_mtu,
-	.ndo_start_xmit = interface_tx,
+static const struct net_device_ops batadv_netdev_ops = {
+	.ndo_open = batadv_interface_open,
+	.ndo_stop = batadv_interface_release,
+	.ndo_get_stats = batadv_interface_stats,
+	.ndo_set_mac_address = batadv_interface_set_mac_addr,
+	.ndo_change_mtu = batadv_interface_change_mtu,
+	.ndo_start_xmit = batadv_interface_tx,
 	.ndo_validate_addr = eth_validate_addr
 };
 
-static void interface_setup(struct net_device *dev)
+static void batadv_interface_setup(struct net_device *dev)
 {
 	struct bat_priv *priv = netdev_priv(dev);
 
 	ether_setup(dev);
 
-	dev->netdev_ops = &bat_netdev_ops;
+	dev->netdev_ops = &batadv_netdev_ops;
 	dev->destructor = free_netdev;
 	dev->tx_queue_len = 0;
 
@@ -353,7 +354,7 @@ static void interface_setup(struct net_device *dev)
 	/* generate random address */
 	eth_hw_addr_random(dev);
 
-	SET_ETHTOOL_OPS(dev, &bat_ethtool_ops);
+	SET_ETHTOOL_OPS(dev, &batadv_ethtool_ops);
 
 	memset(priv, 0, sizeof(*priv));
 }
@@ -364,7 +365,8 @@ struct net_device *batadv_softif_create(const char *name)
 	struct bat_priv *bat_priv;
 	int ret;
 
-	soft_iface = alloc_netdev(sizeof(*bat_priv), name, interface_setup);
+	soft_iface = alloc_netdev(sizeof(*bat_priv), name,
+				  batadv_interface_setup);
 
 	if (!soft_iface)
 		goto out;
@@ -456,14 +458,14 @@ void batadv_softif_destroy(struct net_device *soft_iface)
 
 int batadv_softif_is_valid(const struct net_device *net_dev)
 {
-	if (net_dev->netdev_ops->ndo_start_xmit == interface_tx)
+	if (net_dev->netdev_ops->ndo_start_xmit == batadv_interface_tx)
 		return 1;
 
 	return 0;
 }
 
 /* ethtool */
-static int bat_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+static int batadv_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	cmd->supported = 0;
 	cmd->advertising = 0;
@@ -479,8 +481,8 @@ static int bat_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 	return 0;
 }
 
-static void bat_get_drvinfo(struct net_device *dev,
-			    struct ethtool_drvinfo *info)
+static void batadv_get_drvinfo(struct net_device *dev,
+			       struct ethtool_drvinfo *info)
 {
 	strcpy(info->driver, "B.A.T.M.A.N. advanced");
 	strcpy(info->version, SOURCE_VERSION);
@@ -488,16 +490,16 @@ static void bat_get_drvinfo(struct net_device *dev,
 	strcpy(info->bus_info, "batman");
 }
 
-static u32 bat_get_msglevel(struct net_device *dev)
+static u32 batadv_get_msglevel(struct net_device *dev)
 {
 	return -EOPNOTSUPP;
 }
 
-static void bat_set_msglevel(struct net_device *dev, u32 value)
+static void batadv_set_msglevel(struct net_device *dev, u32 value)
 {
 }
 
-static u32 bat_get_link(struct net_device *dev)
+static u32 batadv_get_link(struct net_device *dev)
 {
 	return 1;
 }
@@ -508,7 +510,7 @@ static u32 bat_get_link(struct net_device *dev)
  */
 static const struct {
 	const char name[ETH_GSTRING_LEN];
-} bat_counters_strings[] = {
+} batadv_counters_strings[] = {
 	{ "forward" },
 	{ "forward_bytes" },
 	{ "mgmt_tx" },
@@ -527,8 +529,8 @@ static void batadv_get_strings(struct net_device *dev, uint32_t stringset,
 			       uint8_t *data)
 {
 	if (stringset == ETH_SS_STATS)
-		memcpy(data, bat_counters_strings,
-		       sizeof(bat_counters_strings));
+		memcpy(data, batadv_counters_strings,
+		       sizeof(batadv_counters_strings));
 }
 
 static void batadv_get_ethtool_stats(struct net_device *dev,

commit 1eda58bfc56c43e73a0cf2bfb6e4d620ab866109
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 13:48:58 2012 +0200

    batman-adv: Prefix main static inline functions with batadv_
    
    All non-static symbols of batman-adv were prefixed with batadv_ to avoid
    collisions with other symbols of the kernel. Other symbols of batman-adv
    should use the same prefix to keep the naming scheme consistent.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 85fe9c1ce5bc..af676b818637 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -168,7 +168,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	/* don't accept stp packets. STP does not help in meshes.
 	 * better use the bridge loop avoidance ...
 	 */
-	if (compare_eth(ethhdr->h_dest, stp_addr))
+	if (batadv_compare_eth(ethhdr->h_dest, stp_addr))
 		goto dropped;
 
 	if (is_multicast_ether_addr(ethhdr->h_dest)) {

commit e5d89254bf763da35b42a3c65289c9962f7240c2
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 13:48:54 2012 +0200

    batman-adv: Prefix hard-interface static inline functions with batadv_
    
    All non-static symbols of batman-adv were prefixed with batadv_ to avoid
    collisions with other symbols of the kernel. Other symbols of batman-adv
    should use the same prefix to keep the naming scheme consistent.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 0658781febde..85fe9c1ce5bc 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -199,7 +199,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 
 	/* ethernet packet should be broadcasted */
 	if (do_bcast) {
-		primary_if = primary_if_get_selected(bat_priv);
+		primary_if = batadv_primary_if_get_selected(bat_priv);
 		if (!primary_if)
 			goto dropped;
 
@@ -253,7 +253,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	bat_priv->stats.tx_dropped++;
 end:
 	if (primary_if)
-		hardif_free_ref(primary_if);
+		batadv_hardif_free_ref(primary_if);
 	return NETDEV_TX_OK;
 }
 

commit 9cfc7bd608b97463993b4f3e4775d99022253f8d
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 02:09:43 2012 +0200

    batman-adv: Reformat multiline comments to consistent style
    
    batman-adv doesn't follow the style for multiline comments that David S. Miller
    prefers. All comments should be reformatted to follow this consistent style to
    make the code slightly more readable.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 994b2b8d7e10..0658781febde 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,5 +1,4 @@
-/*
- * Copyright (C) 2007-2012 B.A.T.M.A.N. contributors:
+/* Copyright (C) 2007-2012 B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
  *
@@ -16,7 +15,6 @@
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
  * 02110-1301, USA
- *
  */
 
 #include "main.h"
@@ -65,8 +63,7 @@ int batadv_skb_head_push(struct sk_buff *skb, unsigned int len)
 {
 	int result;
 
-	/**
-	 * TODO: We must check if we can release all references to non-payload
+	/* TODO: We must check if we can release all references to non-payload
 	 * data using skb_header_release in our skbs to allow skb_cow_header to
 	 * work optimally. This means that those skbs are not allowed to read
 	 * or write any data which is before the current position of skb->data
@@ -180,14 +177,16 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		switch (atomic_read(&bat_priv->gw_mode)) {
 		case GW_MODE_SERVER:
 			/* gateway servers should not send dhcp
-			 * requests into the mesh */
+			 * requests into the mesh
+			 */
 			ret = batadv_gw_is_dhcp_target(skb, &header_len);
 			if (ret)
 				goto dropped;
 			break;
 		case GW_MODE_CLIENT:
 			/* gateway clients should send dhcp requests
-			 * via unicast to their gateway */
+			 * via unicast to their gateway
+			 */
 			ret = batadv_gw_is_dhcp_target(skb, &header_len);
 			if (ret)
 				do_bcast = false;
@@ -215,7 +214,8 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		bcast_packet->header.packet_type = BAT_BCAST;
 
 		/* hw address of first interface is the orig mac because only
-		 * this mac is known throughout the mesh */
+		 * this mac is known throughout the mesh
+		 */
 		memcpy(bcast_packet->orig,
 		       primary_if->net_dev->dev_addr, ETH_ALEN);
 
@@ -226,7 +226,8 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		batadv_add_bcast_packet_to_list(bat_priv, skb, 1);
 
 		/* a copy is stored in the bcast list, therefore removing
-		 * the original skb. */
+		 * the original skb.
+		 */
 		kfree_skb(skb);
 
 	/* unicast packet */
@@ -294,9 +295,10 @@ void batadv_interface_rx(struct net_device *soft_iface,
 
 	/* should not be necessary anymore as we use skb_pull_rcsum()
 	 * TODO: please verify this and remove this TODO
-	 * -- Dec 21st 2009, Simon Wunderlich */
+	 * -- Dec 21st 2009, Simon Wunderlich
+	 */
 
-/*	skb->ip_summed = CHECKSUM_UNNECESSARY;*/
+	/* skb->ip_summed = CHECKSUM_UNNECESSARY; */
 
 	bat_priv->stats.rx_packets++;
 	bat_priv->stats.rx_bytes += skb->len + ETH_HLEN;
@@ -341,8 +343,7 @@ static void interface_setup(struct net_device *dev)
 	dev->destructor = free_netdev;
 	dev->tx_queue_len = 0;
 
-	/**
-	 * can't call min_mtu, because the needed variables
+	/* can't call min_mtu, because the needed variables
 	 * have not been initialized yet
 	 */
 	dev->mtu = ETH_DATA_LEN;

commit 3193e8fdfa355289892661d206d1954114a7be95
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 02:09:42 2012 +0200

    batman-adv: Prefix main non-static functions with batadv_
    
    batman-adv can be compiled as part of the kernel instead of an module. In that
    case the linker will see all non-static symbols of batman-adv and all other
    non-static symbols of the kernel. This could lead to symbol collisions. A
    prefix for the batman-adv symbols that defines their private namespace avoids
    such a problem.
    
    Reported-by: David Miller <davem@davemloft.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 9fd1925775c7..994b2b8d7e10 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -411,7 +411,7 @@ struct net_device *batadv_softif_create(const char *name)
 	if (!bat_priv->bat_counters)
 		goto unreg_soft_iface;
 
-	ret = bat_algo_select(bat_priv, bat_routing_algo);
+	ret = batadv_algo_select(bat_priv, batadv_routing_algo);
 	if (ret < 0)
 		goto free_bat_counters;
 
@@ -423,7 +423,7 @@ struct net_device *batadv_softif_create(const char *name)
 	if (ret < 0)
 		goto unreg_sysfs;
 
-	ret = mesh_init(soft_iface);
+	ret = batadv_mesh_init(soft_iface);
 	if (ret < 0)
 		goto unreg_debugfs;
 
@@ -449,7 +449,7 @@ void batadv_softif_destroy(struct net_device *soft_iface)
 {
 	batadv_debugfs_del_meshif(soft_iface);
 	batadv_sysfs_del_meshif(soft_iface);
-	mesh_free(soft_iface);
+	batadv_mesh_free(soft_iface);
 	unregister_netdevice(soft_iface);
 }
 

commit 88ed1e7772bbedfd0bb013c209f61619eca0a781
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 02:09:40 2012 +0200

    batman-adv: Prefix unicast non-static functions with batadv_
    
    batman-adv can be compiled as part of the kernel instead of an module. In that
    case the linker will see all non-static symbols of batman-adv and all other
    non-static symbols of the kernel. This could lead to symbol collisions. A
    prefix for the batman-adv symbols that defines their private namespace avoids
    such a problem.
    
    Reported-by: David Miller <davem@davemloft.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index a4b5e64bf0c7..9fd1925775c7 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -237,7 +237,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 				goto dropped;
 		}
 
-		ret = unicast_send_skb(skb, bat_priv);
+		ret = batadv_unicast_send_skb(skb, bat_priv);
 		if (ret != 0)
 			goto dropped_freed;
 	}

commit 08c36d3e8ad1f73d3b0322842363b23f6d203630
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 02:09:39 2012 +0200

    batman-adv: Prefix translation-table non-static functions with batadv_
    
    batman-adv can be compiled as part of the kernel instead of an module. In that
    case the linker will see all non-static symbols of batman-adv and all other
    non-static symbols of the kernel. This could lead to symbol collisions. A
    prefix for the batman-adv symbols that defines their private namespace avoids
    such a problem.
    
    Reported-by: David Miller <davem@davemloft.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index cbc36f0ec242..a4b5e64bf0c7 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -109,9 +109,9 @@ static int interface_set_mac_addr(struct net_device *dev, void *p)
 
 	/* only modify transtable if it has been initialized before */
 	if (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE) {
-		tt_local_remove(bat_priv, dev->dev_addr,
-				"mac address changed", false);
-		tt_local_add(dev, addr->sa_data, NULL_IFINDEX);
+		batadv_tt_local_remove(bat_priv, dev->dev_addr,
+				       "mac address changed", false);
+		batadv_tt_local_add(dev, addr->sa_data, NULL_IFINDEX);
 	}
 
 	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
@@ -166,7 +166,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		goto dropped;
 
 	/* Register the client MAC in the transtable */
-	tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
+	batadv_tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
 
 	/* don't accept stp packets. STP does not help in meshes.
 	 * better use the bridge loop avoidance ...
@@ -303,7 +303,7 @@ void batadv_interface_rx(struct net_device *soft_iface,
 
 	soft_iface->last_rx = jiffies;
 
-	if (is_ap_isolated(bat_priv, ethhdr->h_source, ethhdr->h_dest))
+	if (batadv_is_ap_isolated(bat_priv, ethhdr->h_source, ethhdr->h_dest))
 		goto dropped;
 
 	/* Let the bridge loop avoidance check the packet. If will

commit 04b482a21aaf22cf5b327fb6a3fba6fdc8cb3de9
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 02:09:38 2012 +0200

    batman-adv: Prefix soft-interface non-static functions with batadv_
    
    batman-adv can be compiled as part of the kernel instead of an module. In that
    case the linker will see all non-static symbols of batman-adv and all other
    non-static symbols of the kernel. This could lead to symbol collisions. A
    prefix for the batman-adv symbols that defines their private namespace avoids
    such a problem.
    
    Reported-by: David Miller <davem@davemloft.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e15d474bd0b0..cbc36f0ec242 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -61,7 +61,7 @@ static const struct ethtool_ops bat_ethtool_ops = {
 	.get_sset_count = batadv_get_sset_count,
 };
 
-int my_skb_head_push(struct sk_buff *skb, unsigned int len)
+int batadv_skb_head_push(struct sk_buff *skb, unsigned int len)
 {
 	int result;
 
@@ -204,7 +204,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		if (!primary_if)
 			goto dropped;
 
-		if (my_skb_head_push(skb, sizeof(*bcast_packet)) < 0)
+		if (batadv_skb_head_push(skb, sizeof(*bcast_packet)) < 0)
 			goto dropped;
 
 		bcast_packet = (struct bcast_packet *)skb->data;
@@ -256,9 +256,9 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	return NETDEV_TX_OK;
 }
 
-void interface_rx(struct net_device *soft_iface,
-		  struct sk_buff *skb, struct hard_iface *recv_if,
-		  int hdr_size)
+void batadv_interface_rx(struct net_device *soft_iface,
+			 struct sk_buff *skb, struct hard_iface *recv_if,
+			 int hdr_size)
 {
 	struct bat_priv *bat_priv = netdev_priv(soft_iface);
 	struct ethhdr *ethhdr;
@@ -357,7 +357,7 @@ static void interface_setup(struct net_device *dev)
 	memset(priv, 0, sizeof(*priv));
 }
 
-struct net_device *softif_create(const char *name)
+struct net_device *batadv_softif_create(const char *name)
 {
 	struct net_device *soft_iface;
 	struct bat_priv *bat_priv;
@@ -445,7 +445,7 @@ struct net_device *softif_create(const char *name)
 	return NULL;
 }
 
-void softif_destroy(struct net_device *soft_iface)
+void batadv_softif_destroy(struct net_device *soft_iface)
 {
 	batadv_debugfs_del_meshif(soft_iface);
 	batadv_sysfs_del_meshif(soft_iface);
@@ -453,7 +453,7 @@ void softif_destroy(struct net_device *soft_iface)
 	unregister_netdevice(soft_iface);
 }
 
-int softif_is_valid(const struct net_device *net_dev)
+int batadv_softif_is_valid(const struct net_device *net_dev)
 {
 	if (net_dev->netdev_ops->ndo_start_xmit == interface_tx)
 		return 1;

commit 9455e34cb2ded22e01abb6daa65ba1caeed8d7fe
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 02:09:37 2012 +0200

    batman-adv: Prefix send non-static functions with batadv_
    
    batman-adv can be compiled as part of the kernel instead of an module. In that
    case the linker will see all non-static symbols of batman-adv and all other
    non-static symbols of the kernel. This could lead to symbol collisions. A
    prefix for the batman-adv symbols that defines their private namespace avoids
    such a problem.
    
    Reported-by: David Miller <davem@davemloft.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 5bf9a73ae799..e15d474bd0b0 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -223,7 +223,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		bcast_packet->seqno =
 			htonl(atomic_inc_return(&bat_priv->bcast_seqno));
 
-		add_bcast_packet_to_list(bat_priv, skb, 1);
+		batadv_add_bcast_packet_to_list(bat_priv, skb, 1);
 
 		/* a copy is stored in the bcast list, therefore removing
 		 * the original skb. */

commit 9563877ea52ea18bb4f1ed724c5e3a39bbbcf60b
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 02:09:31 2012 +0200

    batman-adv: Prefix hard-interface non-static functions with batadv_
    
    batman-adv can be compiled as part of the kernel instead of an module. In that
    case the linker will see all non-static symbols of batman-adv and all other
    non-static symbols of the kernel. This could lead to symbol collisions. A
    prefix for the batman-adv symbols that defines their private namespace avoids
    such a problem.
    
    Reported-by: David Miller <davem@davemloft.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index bfc4fe03cafa..5bf9a73ae799 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -122,7 +122,7 @@ static int interface_set_mac_addr(struct net_device *dev, void *p)
 static int interface_change_mtu(struct net_device *dev, int new_mtu)
 {
 	/* check ranges */
-	if ((new_mtu < 68) || (new_mtu > hardif_min_mtu(dev)))
+	if ((new_mtu < 68) || (new_mtu > batadv_hardif_min_mtu(dev)))
 		return -EINVAL;
 
 	dev->mtu = new_mtu;

commit 7cf06bc6ff810178a7fb9f12aaa6b274fc520f6f
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 02:09:29 2012 +0200

    batman-adv: Prefix gateway-client non-static functions with batadv_
    
    batman-adv can be compiled as part of the kernel instead of an module. In that
    case the linker will see all non-static symbols of batman-adv and all other
    non-static symbols of the kernel. This could lead to symbol collisions. A
    prefix for the batman-adv symbols that defines their private namespace avoids
    such a problem.
    
    Reported-by: David Miller <davem@davemloft.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 16e866ad1759..bfc4fe03cafa 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -181,14 +181,14 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		case GW_MODE_SERVER:
 			/* gateway servers should not send dhcp
 			 * requests into the mesh */
-			ret = gw_is_dhcp_target(skb, &header_len);
+			ret = batadv_gw_is_dhcp_target(skb, &header_len);
 			if (ret)
 				goto dropped;
 			break;
 		case GW_MODE_CLIENT:
 			/* gateway clients should send dhcp requests
 			 * via unicast to their gateway */
-			ret = gw_is_dhcp_target(skb, &header_len);
+			ret = batadv_gw_is_dhcp_target(skb, &header_len);
 			if (ret)
 				do_bcast = false;
 			break;
@@ -232,7 +232,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	/* unicast packet */
 	} else {
 		if (atomic_read(&bat_priv->gw_mode) != GW_MODE_OFF) {
-			ret = gw_out_of_range(bat_priv, skb, ethhdr);
+			ret = batadv_gw_out_of_range(bat_priv, skb, ethhdr);
 			if (ret)
 				goto dropped;
 		}

commit 08adf1512298201a53b88bb0a3d67e0dbbe0ed9b
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 13:38:47 2012 +0200

    batman-adv: Prefix bridge_loop_avoidance non-static functions with batadv_
    
    batman-adv can be compiled as part of the kernel instead of an module. In that
    case the linker will see all non-static symbols of batman-adv and all other
    non-static symbols of the kernel. This could lead to symbol collisions. A
    prefix for the batman-adv symbols that defines their private namespace avoids
    such a problem.
    
    Reported-by: David Miller <davem@davemloft.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 11bfe533e2a4..16e866ad1759 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -162,7 +162,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		goto dropped;
 	}
 
-	if (bla_tx(bat_priv, skb, vid))
+	if (batadv_bla_tx(bat_priv, skb, vid))
 		goto dropped;
 
 	/* Register the client MAC in the transtable */
@@ -309,7 +309,7 @@ void interface_rx(struct net_device *soft_iface,
 	/* Let the bridge loop avoidance check the packet. If will
 	 * not handle it, we can safely push it up.
 	 */
-	if (bla_rx(bat_priv, skb, vid))
+	if (batadv_bla_rx(bat_priv, skb, vid))
 		goto out;
 
 	netif_rx(skb);

commit 5853e22c58b318232fd6e15033ccb0852f865c0b
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 02:09:24 2012 +0200

    batman-adv: Prefix bat_sysfs non-static functions with batadv_
    
    batman-adv can be compiled as part of the kernel instead of an module. In that
    case the linker will see all non-static symbols of batman-adv and all other
    non-static symbols of the kernel. This could lead to symbol collisions. A
    prefix for the batman-adv symbols that defines their private namespace avoids
    such a problem.
    
    Reported-by: David Miller <davem@davemloft.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 0f0003b00f8c..11bfe533e2a4 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -415,7 +415,7 @@ struct net_device *softif_create(const char *name)
 	if (ret < 0)
 		goto free_bat_counters;
 
-	ret = sysfs_add_meshif(soft_iface);
+	ret = batadv_sysfs_add_meshif(soft_iface);
 	if (ret < 0)
 		goto free_bat_counters;
 
@@ -432,7 +432,7 @@ struct net_device *softif_create(const char *name)
 unreg_debugfs:
 	batadv_debugfs_del_meshif(soft_iface);
 unreg_sysfs:
-	sysfs_del_meshif(soft_iface);
+	batadv_sysfs_del_meshif(soft_iface);
 free_bat_counters:
 	free_percpu(bat_priv->bat_counters);
 unreg_soft_iface:
@@ -448,7 +448,7 @@ struct net_device *softif_create(const char *name)
 void softif_destroy(struct net_device *soft_iface)
 {
 	batadv_debugfs_del_meshif(soft_iface);
-	sysfs_del_meshif(soft_iface);
+	batadv_sysfs_del_meshif(soft_iface);
 	mesh_free(soft_iface);
 	unregister_netdevice(soft_iface);
 }

commit 40a072d777a4f417c0296e06f91297b0f3f2fa36
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 12 02:09:23 2012 +0200

    batman-adv: Prefix bat_debugfs non-static functions with batadv_
    
    batman-adv can be compiled as part of the kernel instead of an module. In that
    case the linker will see all non-static symbols of batman-adv and all other
    non-static symbols of the kernel. This could lead to symbol collisions. A
    prefix for the batman-adv symbols that defines their private namespace avoids
    such a problem.
    
    Reported-by: David Miller <davem@davemloft.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 304a7ba09e03..0f0003b00f8c 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -419,7 +419,7 @@ struct net_device *softif_create(const char *name)
 	if (ret < 0)
 		goto free_bat_counters;
 
-	ret = debugfs_add_meshif(soft_iface);
+	ret = batadv_debugfs_add_meshif(soft_iface);
 	if (ret < 0)
 		goto unreg_sysfs;
 
@@ -430,7 +430,7 @@ struct net_device *softif_create(const char *name)
 	return soft_iface;
 
 unreg_debugfs:
-	debugfs_del_meshif(soft_iface);
+	batadv_debugfs_del_meshif(soft_iface);
 unreg_sysfs:
 	sysfs_del_meshif(soft_iface);
 free_bat_counters:
@@ -447,7 +447,7 @@ struct net_device *softif_create(const char *name)
 
 void softif_destroy(struct net_device *soft_iface)
 {
-	debugfs_del_meshif(soft_iface);
+	batadv_debugfs_del_meshif(soft_iface);
 	sysfs_del_meshif(soft_iface);
 	mesh_free(soft_iface);
 	unregister_netdevice(soft_iface);

commit f8214865a55f805e65c33350bc0f1eb46dd8433d
Author: Martin Hundebøll <martin@hundeboll.net>
Date:   Fri Apr 20 17:02:45 2012 +0200

    batman-adv: Add get_ethtool_stats() support
    
    Added additional counters in a bat_stats structure, which are exported
    through the ethtool api. The counters are specific to batman-adv and
    includes:
     forwarded packets and bytes
     management packets and bytes (aggregated OGMs at this point)
     translation table packets
    
    New counters are added by extending "enum bat_counters" in types.h and
    adding corresponding  descriptive string(s) to bat_counters_strings in
    soft-iface.c.
    
    Counters are increased by calling batadv_add_counter() and incremented
    by one by calling batadv_inc_counter().
    
    Signed-off-by: Martin Hundebøll <martin@hundeboll.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 6e2530b02043..304a7ba09e03 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -45,6 +45,10 @@ static void bat_get_drvinfo(struct net_device *dev,
 static u32 bat_get_msglevel(struct net_device *dev);
 static void bat_set_msglevel(struct net_device *dev, u32 value);
 static u32 bat_get_link(struct net_device *dev);
+static void batadv_get_strings(struct net_device *dev, u32 stringset, u8 *data);
+static void batadv_get_ethtool_stats(struct net_device *dev,
+				     struct ethtool_stats *stats, u64 *data);
+static int batadv_get_sset_count(struct net_device *dev, int stringset);
 
 static const struct ethtool_ops bat_ethtool_ops = {
 	.get_settings = bat_get_settings,
@@ -52,6 +56,9 @@ static const struct ethtool_ops bat_ethtool_ops = {
 	.get_msglevel = bat_get_msglevel,
 	.set_msglevel = bat_set_msglevel,
 	.get_link = bat_get_link,
+	.get_strings = batadv_get_strings,
+	.get_ethtool_stats = batadv_get_ethtool_stats,
+	.get_sset_count = batadv_get_sset_count,
 };
 
 int my_skb_head_push(struct sk_buff *skb, unsigned int len)
@@ -399,13 +406,18 @@ struct net_device *softif_create(const char *name)
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;
 
+	bat_priv->bat_counters = __alloc_percpu(sizeof(uint64_t) * BAT_CNT_NUM,
+						__alignof__(uint64_t));
+	if (!bat_priv->bat_counters)
+		goto unreg_soft_iface;
+
 	ret = bat_algo_select(bat_priv, bat_routing_algo);
 	if (ret < 0)
-		goto unreg_soft_iface;
+		goto free_bat_counters;
 
 	ret = sysfs_add_meshif(soft_iface);
 	if (ret < 0)
-		goto unreg_soft_iface;
+		goto free_bat_counters;
 
 	ret = debugfs_add_meshif(soft_iface);
 	if (ret < 0)
@@ -421,6 +433,8 @@ struct net_device *softif_create(const char *name)
 	debugfs_del_meshif(soft_iface);
 unreg_sysfs:
 	sysfs_del_meshif(soft_iface);
+free_bat_counters:
+	free_percpu(bat_priv->bat_counters);
 unreg_soft_iface:
 	unregister_netdevice(soft_iface);
 	return NULL;
@@ -486,3 +500,51 @@ static u32 bat_get_link(struct net_device *dev)
 {
 	return 1;
 }
+
+/* Inspired by drivers/net/ethernet/dlink/sundance.c:1702
+ * Declare each description string in struct.name[] to get fixed sized buffer
+ * and compile time checking for strings longer than ETH_GSTRING_LEN.
+ */
+static const struct {
+	const char name[ETH_GSTRING_LEN];
+} bat_counters_strings[] = {
+	{ "forward" },
+	{ "forward_bytes" },
+	{ "mgmt_tx" },
+	{ "mgmt_tx_bytes" },
+	{ "mgmt_rx" },
+	{ "mgmt_rx_bytes" },
+	{ "tt_request_tx" },
+	{ "tt_request_rx" },
+	{ "tt_response_tx" },
+	{ "tt_response_rx" },
+	{ "tt_roam_adv_tx" },
+	{ "tt_roam_adv_rx" },
+};
+
+static void batadv_get_strings(struct net_device *dev, uint32_t stringset,
+			       uint8_t *data)
+{
+	if (stringset == ETH_SS_STATS)
+		memcpy(data, bat_counters_strings,
+		       sizeof(bat_counters_strings));
+}
+
+static void batadv_get_ethtool_stats(struct net_device *dev,
+				     struct ethtool_stats *stats,
+				     uint64_t *data)
+{
+	struct bat_priv *bat_priv = netdev_priv(dev);
+	int i;
+
+	for (i = 0; i < BAT_CNT_NUM; i++)
+		data[i] = batadv_sum_counter(bat_priv, i);
+}
+
+static int batadv_get_sset_count(struct net_device *dev, int stringset)
+{
+	if (stringset == ETH_SS_STATS)
+		return BAT_CNT_NUM;
+
+	return -EOPNOTSUPP;
+}

commit 0d125074ebc8c971e939f8c2c8f90a80fa09aeb4
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Sat Feb 18 11:27:34 2012 +0100

    batman-adv: use ETH_HLEN instead of sizeof(struct ethhdr)
    
    Instead of using sizeof(struct ethhdr) it is strongly recommended to use the
    kernel macro ETH_HLEN. This patch substitute each occurrence of the former
    expressione with the latter one.
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index efe0fbaadcd6..6e2530b02043 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -292,7 +292,7 @@ void interface_rx(struct net_device *soft_iface,
 /*	skb->ip_summed = CHECKSUM_UNNECESSARY;*/
 
 	bat_priv->stats.rx_packets++;
-	bat_priv->stats.rx_bytes += skb->len + sizeof(struct ethhdr);
+	bat_priv->stats.rx_bytes += skb->len + ETH_HLEN;
 
 	soft_iface->last_rx = jiffies;
 

commit 7a5cc24277b57ce38eb0afa6634b71d4d5cc671e
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Sun Jan 22 20:00:27 2012 +0100

    batman-adv: add bridge loop avoidance compile option
    
    The define CONFIG_BATMAN_ADV_BLA switches the bridge loop avoidance
    on - skip it, and the bridge loop avoidance is not compiled in.
    
    This is useful if binary size should be saved or the feature is
    not needed.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 10ab49aa568f..efe0fbaadcd6 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -134,7 +134,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 						   0x00};
 	unsigned int header_len = 0;
 	int data_len = skb->len, ret;
-	short vid = -1;
+	short vid __maybe_unused = -1;
 	bool do_bcast = false;
 
 	if (atomic_read(&bat_priv->mesh_state) != MESH_ACTIVE)
@@ -256,7 +256,7 @@ void interface_rx(struct net_device *soft_iface,
 	struct bat_priv *bat_priv = netdev_priv(soft_iface);
 	struct ethhdr *ethhdr;
 	struct vlan_ethhdr *vhdr;
-	short vid = -1;
+	short vid __maybe_unused = -1;
 
 	/* check if enough space is available for pulling, and pull */
 	if (!pskb_may_pull(skb, hdr_size))

commit b1a8c04b8af74158e006b92a9e7e0f619e1a9409
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Sun Jan 22 20:00:25 2012 +0100

    batman-adv: drop STP over batman
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 4d639b303bd7..10ab49aa568f 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -130,6 +130,8 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	struct hard_iface *primary_if = NULL;
 	struct bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
+	static const uint8_t stp_addr[ETH_ALEN] = {0x01, 0x80, 0xC2, 0x00, 0x00,
+						   0x00};
 	unsigned int header_len = 0;
 	int data_len = skb->len, ret;
 	short vid = -1;
@@ -159,6 +161,12 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	/* Register the client MAC in the transtable */
 	tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
 
+	/* don't accept stp packets. STP does not help in meshes.
+	 * better use the bridge loop avoidance ...
+	 */
+	if (compare_eth(ethhdr->h_dest, stp_addr))
+		goto dropped;
+
 	if (is_multicast_ether_addr(ethhdr->h_dest)) {
 		do_bcast = true;
 

commit 23721387c409087fd3b97e274f34d3ddc0970b74
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Sun Jan 22 20:00:19 2012 +0100

    batman-adv: add basic bridge loop avoidance code
    
    This second version of the bridge loop avoidance for batman-adv
    avoids loops between the mesh and a backbone (usually a LAN).
    
    By connecting multiple batman-adv mesh nodes to the same ethernet
    segment a loop can be created when the soft-interface is bridged
    into that ethernet segment. A simple visualization of the loop
    involving the most common case - a LAN as ethernet segment:
    
    node1  <-- LAN  -->  node2
      |                   |
    wifi   <-- mesh -->  wifi
    
    Packets from the LAN (e.g. ARP broadcasts) will circle forever from
    node1 or node2 over the mesh back into the LAN.
    
    With this patch, batman recognizes backbone gateways, nodes which are
    part of the mesh and backbone/LAN at the same time. Each backbone
    gateway "claims" clients from within the mesh to handle them
    exclusively. By restricting that only responsible backbone gateways
    may handle their claimed clients traffic, loops are effectively
    avoided.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e56cb88ef2ba..4d639b303bd7 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -36,6 +36,7 @@
 #include <linux/etherdevice.h>
 #include <linux/if_vlan.h>
 #include "unicast.h"
+#include "bridge_loop_avoidance.h"
 
 
 static int bat_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);
@@ -152,6 +153,9 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		goto dropped;
 	}
 
+	if (bla_tx(bat_priv, skb, vid))
+		goto dropped;
+
 	/* Register the client MAC in the transtable */
 	tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
 
@@ -287,6 +291,12 @@ void interface_rx(struct net_device *soft_iface,
 	if (is_ap_isolated(bat_priv, ethhdr->h_source, ethhdr->h_dest))
 		goto dropped;
 
+	/* Let the bridge loop avoidance check the packet. If will
+	 * not handle it, we can safely push it up.
+	 */
+	if (bla_rx(bat_priv, skb, vid))
+		goto out;
+
 	netif_rx(skb);
 	goto out;
 
@@ -354,6 +364,7 @@ struct net_device *softif_create(const char *name)
 
 	atomic_set(&bat_priv->aggregated_ogms, 1);
 	atomic_set(&bat_priv->bonding, 0);
+	atomic_set(&bat_priv->bridge_loop_avoidance, 0);
 	atomic_set(&bat_priv->ap_isolation, 0);
 	atomic_set(&bat_priv->vis_mode, VIS_TYPE_CLIENT_UPDATE);
 	atomic_set(&bat_priv->gw_mode, GW_MODE_OFF);
@@ -371,6 +382,7 @@ struct net_device *softif_create(const char *name)
 	atomic_set(&bat_priv->ttvn, 0);
 	atomic_set(&bat_priv->tt_local_changes, 0);
 	atomic_set(&bat_priv->tt_ogm_append_cnt, 0);
+	atomic_set(&bat_priv->bla_num_requests, 0);
 
 	bat_priv->tt_buff = NULL;
 	bat_priv->tt_buff_len = 0;

commit a7f6ee9493677ba40625d810258de5bd521cc1b0
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Sun Jan 22 20:00:18 2012 +0100

    batman-adv: remove old bridge loop avoidance code
    
    The functionality is to be replaced by an improved implementation,
    so first clean up.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 82c097d6ec93..e56cb88ef2ba 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -73,439 +73,6 @@ int my_skb_head_push(struct sk_buff *skb, unsigned int len)
 	return 0;
 }
 
-static void softif_neigh_free_ref(struct softif_neigh *softif_neigh)
-{
-	if (atomic_dec_and_test(&softif_neigh->refcount))
-		kfree_rcu(softif_neigh, rcu);
-}
-
-static void softif_neigh_vid_free_rcu(struct rcu_head *rcu)
-{
-	struct softif_neigh_vid *softif_neigh_vid;
-	struct softif_neigh *softif_neigh;
-	struct hlist_node *node, *node_tmp;
-	struct bat_priv *bat_priv;
-
-	softif_neigh_vid = container_of(rcu, struct softif_neigh_vid, rcu);
-	bat_priv = softif_neigh_vid->bat_priv;
-
-	spin_lock_bh(&bat_priv->softif_neigh_lock);
-	hlist_for_each_entry_safe(softif_neigh, node, node_tmp,
-				  &softif_neigh_vid->softif_neigh_list, list) {
-		hlist_del_rcu(&softif_neigh->list);
-		softif_neigh_free_ref(softif_neigh);
-	}
-	spin_unlock_bh(&bat_priv->softif_neigh_lock);
-
-	kfree(softif_neigh_vid);
-}
-
-static void softif_neigh_vid_free_ref(struct softif_neigh_vid *softif_neigh_vid)
-{
-	if (atomic_dec_and_test(&softif_neigh_vid->refcount))
-		call_rcu(&softif_neigh_vid->rcu, softif_neigh_vid_free_rcu);
-}
-
-static struct softif_neigh_vid *softif_neigh_vid_get(struct bat_priv *bat_priv,
-						     short vid)
-{
-	struct softif_neigh_vid *softif_neigh_vid;
-	struct hlist_node *node;
-
-	rcu_read_lock();
-	hlist_for_each_entry_rcu(softif_neigh_vid, node,
-				 &bat_priv->softif_neigh_vids, list) {
-		if (softif_neigh_vid->vid != vid)
-			continue;
-
-		if (!atomic_inc_not_zero(&softif_neigh_vid->refcount))
-			continue;
-
-		goto out;
-	}
-
-	softif_neigh_vid = kzalloc(sizeof(*softif_neigh_vid), GFP_ATOMIC);
-	if (!softif_neigh_vid)
-		goto out;
-
-	softif_neigh_vid->vid = vid;
-	softif_neigh_vid->bat_priv = bat_priv;
-
-	/* initialize with 2 - caller decrements counter by one */
-	atomic_set(&softif_neigh_vid->refcount, 2);
-	INIT_HLIST_HEAD(&softif_neigh_vid->softif_neigh_list);
-	INIT_HLIST_NODE(&softif_neigh_vid->list);
-	spin_lock_bh(&bat_priv->softif_neigh_vid_lock);
-	hlist_add_head_rcu(&softif_neigh_vid->list,
-			   &bat_priv->softif_neigh_vids);
-	spin_unlock_bh(&bat_priv->softif_neigh_vid_lock);
-
-out:
-	rcu_read_unlock();
-	return softif_neigh_vid;
-}
-
-static struct softif_neigh *softif_neigh_get(struct bat_priv *bat_priv,
-					     const uint8_t *addr, short vid)
-{
-	struct softif_neigh_vid *softif_neigh_vid;
-	struct softif_neigh *softif_neigh = NULL;
-	struct hlist_node *node;
-
-	softif_neigh_vid = softif_neigh_vid_get(bat_priv, vid);
-	if (!softif_neigh_vid)
-		goto out;
-
-	rcu_read_lock();
-	hlist_for_each_entry_rcu(softif_neigh, node,
-				 &softif_neigh_vid->softif_neigh_list,
-				 list) {
-		if (!compare_eth(softif_neigh->addr, addr))
-			continue;
-
-		if (!atomic_inc_not_zero(&softif_neigh->refcount))
-			continue;
-
-		softif_neigh->last_seen = jiffies;
-		goto unlock;
-	}
-
-	softif_neigh = kzalloc(sizeof(*softif_neigh), GFP_ATOMIC);
-	if (!softif_neigh)
-		goto unlock;
-
-	memcpy(softif_neigh->addr, addr, ETH_ALEN);
-	softif_neigh->last_seen = jiffies;
-	/* initialize with 2 - caller decrements counter by one */
-	atomic_set(&softif_neigh->refcount, 2);
-
-	INIT_HLIST_NODE(&softif_neigh->list);
-	spin_lock_bh(&bat_priv->softif_neigh_lock);
-	hlist_add_head_rcu(&softif_neigh->list,
-			   &softif_neigh_vid->softif_neigh_list);
-	spin_unlock_bh(&bat_priv->softif_neigh_lock);
-
-unlock:
-	rcu_read_unlock();
-out:
-	if (softif_neigh_vid)
-		softif_neigh_vid_free_ref(softif_neigh_vid);
-	return softif_neigh;
-}
-
-static struct softif_neigh *softif_neigh_get_selected(
-				struct softif_neigh_vid *softif_neigh_vid)
-{
-	struct softif_neigh *softif_neigh;
-
-	rcu_read_lock();
-	softif_neigh = rcu_dereference(softif_neigh_vid->softif_neigh);
-
-	if (softif_neigh && !atomic_inc_not_zero(&softif_neigh->refcount))
-		softif_neigh = NULL;
-
-	rcu_read_unlock();
-	return softif_neigh;
-}
-
-static struct softif_neigh *softif_neigh_vid_get_selected(
-						struct bat_priv *bat_priv,
-						short vid)
-{
-	struct softif_neigh_vid *softif_neigh_vid;
-	struct softif_neigh *softif_neigh = NULL;
-
-	softif_neigh_vid = softif_neigh_vid_get(bat_priv, vid);
-	if (!softif_neigh_vid)
-		goto out;
-
-	softif_neigh = softif_neigh_get_selected(softif_neigh_vid);
-out:
-	if (softif_neigh_vid)
-		softif_neigh_vid_free_ref(softif_neigh_vid);
-	return softif_neigh;
-}
-
-static void softif_neigh_vid_select(struct bat_priv *bat_priv,
-				    struct softif_neigh *new_neigh,
-				    short vid)
-{
-	struct softif_neigh_vid *softif_neigh_vid;
-	struct softif_neigh *curr_neigh;
-
-	softif_neigh_vid = softif_neigh_vid_get(bat_priv, vid);
-	if (!softif_neigh_vid)
-		goto out;
-
-	spin_lock_bh(&bat_priv->softif_neigh_lock);
-
-	if (new_neigh && !atomic_inc_not_zero(&new_neigh->refcount))
-		new_neigh = NULL;
-
-	curr_neigh = rcu_dereference_protected(softif_neigh_vid->softif_neigh,
-					       1);
-	rcu_assign_pointer(softif_neigh_vid->softif_neigh, new_neigh);
-
-	if ((curr_neigh) && (!new_neigh))
-		bat_dbg(DBG_ROUTES, bat_priv,
-			"Removing mesh exit point on vid: %d (prev: %pM).\n",
-			vid, curr_neigh->addr);
-	else if ((curr_neigh) && (new_neigh))
-		bat_dbg(DBG_ROUTES, bat_priv,
-			"Changing mesh exit point on vid: %d from %pM to %pM.\n",
-			vid, curr_neigh->addr, new_neigh->addr);
-	else if ((!curr_neigh) && (new_neigh))
-		bat_dbg(DBG_ROUTES, bat_priv,
-			"Setting mesh exit point on vid: %d to %pM.\n",
-			vid, new_neigh->addr);
-
-	if (curr_neigh)
-		softif_neigh_free_ref(curr_neigh);
-
-	spin_unlock_bh(&bat_priv->softif_neigh_lock);
-
-out:
-	if (softif_neigh_vid)
-		softif_neigh_vid_free_ref(softif_neigh_vid);
-}
-
-static void softif_neigh_vid_deselect(struct bat_priv *bat_priv,
-				      struct softif_neigh_vid *softif_neigh_vid)
-{
-	struct softif_neigh *curr_neigh;
-	struct softif_neigh *softif_neigh = NULL, *softif_neigh_tmp;
-	struct hard_iface *primary_if = NULL;
-	struct hlist_node *node;
-
-	primary_if = primary_if_get_selected(bat_priv);
-	if (!primary_if)
-		goto out;
-
-	/* find new softif_neigh immediately to avoid temporary loops */
-	rcu_read_lock();
-	curr_neigh = rcu_dereference(softif_neigh_vid->softif_neigh);
-
-	hlist_for_each_entry_rcu(softif_neigh_tmp, node,
-				 &softif_neigh_vid->softif_neigh_list,
-				 list) {
-		if (softif_neigh_tmp == curr_neigh)
-			continue;
-
-		/* we got a neighbor but its mac is 'bigger' than ours  */
-		if (memcmp(primary_if->net_dev->dev_addr,
-			   softif_neigh_tmp->addr, ETH_ALEN) < 0)
-			continue;
-
-		if (!atomic_inc_not_zero(&softif_neigh_tmp->refcount))
-			continue;
-
-		softif_neigh = softif_neigh_tmp;
-		goto unlock;
-	}
-
-unlock:
-	rcu_read_unlock();
-out:
-	softif_neigh_vid_select(bat_priv, softif_neigh, softif_neigh_vid->vid);
-
-	if (primary_if)
-		hardif_free_ref(primary_if);
-	if (softif_neigh)
-		softif_neigh_free_ref(softif_neigh);
-}
-
-int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
-{
-	struct net_device *net_dev = (struct net_device *)seq->private;
-	struct bat_priv *bat_priv = netdev_priv(net_dev);
-	struct softif_neigh_vid *softif_neigh_vid;
-	struct softif_neigh *softif_neigh;
-	struct hard_iface *primary_if;
-	struct hlist_node *node, *node_tmp;
-	struct softif_neigh *curr_softif_neigh;
-	int ret = 0, last_seen_secs, last_seen_msecs;
-
-	primary_if = primary_if_get_selected(bat_priv);
-	if (!primary_if) {
-		ret = seq_printf(seq,
-				 "BATMAN mesh %s disabled - please specify interfaces to enable it\n",
-				 net_dev->name);
-		goto out;
-	}
-
-	if (primary_if->if_status != IF_ACTIVE) {
-		ret = seq_printf(seq,
-				 "BATMAN mesh %s disabled - primary interface not active\n",
-				 net_dev->name);
-		goto out;
-	}
-
-	seq_printf(seq, "Softif neighbor list (%s)\n", net_dev->name);
-
-	rcu_read_lock();
-	hlist_for_each_entry_rcu(softif_neigh_vid, node,
-				 &bat_priv->softif_neigh_vids, list) {
-		seq_printf(seq, "     %-15s %s on vid: %d\n",
-			   "Originator", "last-seen", softif_neigh_vid->vid);
-
-		curr_softif_neigh = softif_neigh_get_selected(softif_neigh_vid);
-
-		hlist_for_each_entry_rcu(softif_neigh, node_tmp,
-					 &softif_neigh_vid->softif_neigh_list,
-					 list) {
-			last_seen_secs = jiffies_to_msecs(jiffies -
-						softif_neigh->last_seen) / 1000;
-			last_seen_msecs = jiffies_to_msecs(jiffies -
-						softif_neigh->last_seen) % 1000;
-			seq_printf(seq, "%s %pM  %3i.%03is\n",
-				   curr_softif_neigh == softif_neigh
-				   ? "=>" : "  ", softif_neigh->addr,
-				   last_seen_secs, last_seen_msecs);
-		}
-
-		if (curr_softif_neigh)
-			softif_neigh_free_ref(curr_softif_neigh);
-
-		seq_printf(seq, "\n");
-	}
-	rcu_read_unlock();
-
-out:
-	if (primary_if)
-		hardif_free_ref(primary_if);
-	return ret;
-}
-
-void softif_neigh_purge(struct bat_priv *bat_priv)
-{
-	struct softif_neigh *softif_neigh, *curr_softif_neigh;
-	struct softif_neigh_vid *softif_neigh_vid;
-	struct hlist_node *node, *node_tmp, *node_tmp2;
-	int do_deselect;
-
-	rcu_read_lock();
-	hlist_for_each_entry_rcu(softif_neigh_vid, node,
-				 &bat_priv->softif_neigh_vids, list) {
-		if (!atomic_inc_not_zero(&softif_neigh_vid->refcount))
-			continue;
-
-		curr_softif_neigh = softif_neigh_get_selected(softif_neigh_vid);
-		do_deselect = 0;
-
-		spin_lock_bh(&bat_priv->softif_neigh_lock);
-		hlist_for_each_entry_safe(softif_neigh, node_tmp, node_tmp2,
-					  &softif_neigh_vid->softif_neigh_list,
-					  list) {
-			if ((!has_timed_out(softif_neigh->last_seen,
-					    SOFTIF_NEIGH_TIMEOUT)) &&
-			    (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE))
-				continue;
-
-			if (curr_softif_neigh == softif_neigh) {
-				bat_dbg(DBG_ROUTES, bat_priv,
-					"Current mesh exit point on vid: %d '%pM' vanished.\n",
-					softif_neigh_vid->vid,
-					softif_neigh->addr);
-				do_deselect = 1;
-			}
-
-			hlist_del_rcu(&softif_neigh->list);
-			softif_neigh_free_ref(softif_neigh);
-		}
-		spin_unlock_bh(&bat_priv->softif_neigh_lock);
-
-		/* soft_neigh_vid_deselect() needs to acquire the
-		 * softif_neigh_lock */
-		if (do_deselect)
-			softif_neigh_vid_deselect(bat_priv, softif_neigh_vid);
-
-		if (curr_softif_neigh)
-			softif_neigh_free_ref(curr_softif_neigh);
-
-		softif_neigh_vid_free_ref(softif_neigh_vid);
-	}
-	rcu_read_unlock();
-
-	spin_lock_bh(&bat_priv->softif_neigh_vid_lock);
-	hlist_for_each_entry_safe(softif_neigh_vid, node, node_tmp,
-				  &bat_priv->softif_neigh_vids, list) {
-		if (!hlist_empty(&softif_neigh_vid->softif_neigh_list))
-			continue;
-
-		hlist_del_rcu(&softif_neigh_vid->list);
-		softif_neigh_vid_free_ref(softif_neigh_vid);
-	}
-	spin_unlock_bh(&bat_priv->softif_neigh_vid_lock);
-
-}
-
-static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
-			       short vid)
-{
-	struct bat_priv *bat_priv = netdev_priv(dev);
-	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
-	struct batman_ogm_packet *batman_ogm_packet;
-	struct softif_neigh *softif_neigh = NULL;
-	struct hard_iface *primary_if = NULL;
-	struct softif_neigh *curr_softif_neigh = NULL;
-
-	if (ntohs(ethhdr->h_proto) == ETH_P_8021Q)
-		batman_ogm_packet = (struct batman_ogm_packet *)
-					(skb->data + ETH_HLEN + VLAN_HLEN);
-	else
-		batman_ogm_packet = (struct batman_ogm_packet *)
-							(skb->data + ETH_HLEN);
-
-	if (batman_ogm_packet->header.version != COMPAT_VERSION)
-		goto out;
-
-	if (batman_ogm_packet->header.packet_type != BAT_OGM)
-		goto out;
-
-	if (!(batman_ogm_packet->flags & PRIMARIES_FIRST_HOP))
-		goto out;
-
-	if (is_my_mac(batman_ogm_packet->orig))
-		goto out;
-
-	softif_neigh = softif_neigh_get(bat_priv, batman_ogm_packet->orig, vid);
-	if (!softif_neigh)
-		goto out;
-
-	curr_softif_neigh = softif_neigh_vid_get_selected(bat_priv, vid);
-	if (curr_softif_neigh == softif_neigh)
-		goto out;
-
-	primary_if = primary_if_get_selected(bat_priv);
-	if (!primary_if)
-		goto out;
-
-	/* we got a neighbor but its mac is 'bigger' than ours  */
-	if (memcmp(primary_if->net_dev->dev_addr,
-		   softif_neigh->addr, ETH_ALEN) < 0)
-		goto out;
-
-	/* close own batX device and use softif_neigh as exit node */
-	if (!curr_softif_neigh) {
-		softif_neigh_vid_select(bat_priv, softif_neigh, vid);
-		goto out;
-	}
-
-	/* switch to new 'smallest neighbor' */
-	if (memcmp(softif_neigh->addr, curr_softif_neigh->addr, ETH_ALEN) < 0)
-		softif_neigh_vid_select(bat_priv, softif_neigh, vid);
-
-out:
-	kfree_skb(skb);
-	if (softif_neigh)
-		softif_neigh_free_ref(softif_neigh);
-	if (curr_softif_neigh)
-		softif_neigh_free_ref(curr_softif_neigh);
-	if (primary_if)
-		hardif_free_ref(primary_if);
-	return;
-}
-
 static int interface_open(struct net_device *dev)
 {
 	netif_start_queue(dev);
@@ -562,7 +129,6 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	struct hard_iface *primary_if = NULL;
 	struct bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
-	struct softif_neigh *curr_softif_neigh = NULL;
 	unsigned int header_len = 0;
 	int data_len = skb->len, ret;
 	short vid = -1;
@@ -583,17 +149,8 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 
 		/* fall through */
 	case ETH_P_BATMAN:
-		softif_batman_recv(skb, soft_iface, vid);
-		goto end;
-	}
-
-	/**
-	 * if we have a another chosen mesh exit node in range
-	 * it will transport the packets to the mesh
-	 */
-	curr_softif_neigh = softif_neigh_vid_get_selected(bat_priv, vid);
-	if (curr_softif_neigh)
 		goto dropped;
+	}
 
 	/* Register the client MAC in the transtable */
 	tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
@@ -675,8 +232,6 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 dropped_freed:
 	bat_priv->stats.tx_dropped++;
 end:
-	if (curr_softif_neigh)
-		softif_neigh_free_ref(curr_softif_neigh);
 	if (primary_if)
 		hardif_free_ref(primary_if);
 	return NETDEV_TX_OK;
@@ -687,12 +242,9 @@ void interface_rx(struct net_device *soft_iface,
 		  int hdr_size)
 {
 	struct bat_priv *bat_priv = netdev_priv(soft_iface);
-	struct unicast_packet *unicast_packet;
 	struct ethhdr *ethhdr;
 	struct vlan_ethhdr *vhdr;
-	struct softif_neigh *curr_softif_neigh = NULL;
 	short vid = -1;
-	int ret;
 
 	/* check if enough space is available for pulling, and pull */
 	if (!pskb_may_pull(skb, hdr_size))
@@ -716,30 +268,6 @@ void interface_rx(struct net_device *soft_iface,
 		goto dropped;
 	}
 
-	/**
-	 * if we have a another chosen mesh exit node in range
-	 * it will transport the packets to the non-mesh network
-	 */
-	curr_softif_neigh = softif_neigh_vid_get_selected(bat_priv, vid);
-	if (curr_softif_neigh) {
-		skb_push(skb, hdr_size);
-		unicast_packet = (struct unicast_packet *)skb->data;
-
-		if ((unicast_packet->header.packet_type != BAT_UNICAST) &&
-		    (unicast_packet->header.packet_type != BAT_UNICAST_FRAG))
-			goto dropped;
-
-		skb_reset_mac_header(skb);
-
-		memcpy(unicast_packet->dest,
-		       curr_softif_neigh->addr, ETH_ALEN);
-		ret = route_unicast_packet(skb, recv_if);
-		if (ret == NET_RX_DROP)
-			goto dropped;
-
-		goto out;
-	}
-
 	/* skb->dev & skb->pkt_type are set here */
 	if (unlikely(!pskb_may_pull(skb, ETH_HLEN)))
 		goto dropped;
@@ -765,8 +293,6 @@ void interface_rx(struct net_device *soft_iface,
 dropped:
 	kfree_skb(skb);
 out:
-	if (curr_softif_neigh)
-		softif_neigh_free_ref(curr_softif_neigh);
 	return;
 }
 

commit 8681a1c4dd258c573e80b4a7af7e7127770b67a8
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Fri Jan 27 23:11:55 2012 +0800

    batman-adv: encourage batman to take shorter routes by changing the default hop penalty
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index a5590f4193f1..82c097d6ec93 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -834,7 +834,7 @@ struct net_device *softif_create(const char *name)
 	atomic_set(&bat_priv->gw_sel_class, 20);
 	atomic_set(&bat_priv->gw_bandwidth, 41);
 	atomic_set(&bat_priv->orig_interval, 1000);
-	atomic_set(&bat_priv->hop_penalty, 10);
+	atomic_set(&bat_priv->hop_penalty, 30);
 	atomic_set(&bat_priv->log_level, 0);
 	atomic_set(&bat_priv->fragmentation, 1);
 	atomic_set(&bat_priv->bcast_queue_left, BCAST_QUEUE_LEN);

commit e8abbe0d0236ac1d55d21fec7a8d2ee03e9d3258
Merge: bb092c0db883 40e0c4f51d3f
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Mar 11 15:36:34 2012 -0700

    Merge tag 'batman-adv-for-davem' of git://git.open-mesh.org/linux-merge

commit 86ceb360565d06fcee96be85c4bafe9264756eca
Author: Sven Eckelmann <sven@narfation.org>
Date:   Wed Mar 7 09:07:45 2012 +0100

    batman-adv: Ignore 80-chars per line limits for strings
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c39c120e1171..3ba057d93521 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -252,8 +252,8 @@ static void softif_neigh_vid_select(struct bat_priv *bat_priv,
 			vid, curr_neigh->addr);
 	else if ((curr_neigh) && (new_neigh))
 		bat_dbg(DBG_ROUTES, bat_priv,
-			"Changing mesh exit point on vid: %d from %pM "
-			"to %pM.\n", vid, curr_neigh->addr, new_neigh->addr);
+			"Changing mesh exit point on vid: %d from %pM to %pM.\n",
+			vid, curr_neigh->addr, new_neigh->addr);
 	else if ((!curr_neigh) && (new_neigh))
 		bat_dbg(DBG_ROUTES, bat_priv,
 			"Setting mesh exit point on vid: %d to %pM.\n",
@@ -327,15 +327,15 @@ int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
 
 	primary_if = primary_if_get_selected(bat_priv);
 	if (!primary_if) {
-		ret = seq_printf(seq, "BATMAN mesh %s disabled - "
-				 "please specify interfaces to enable it\n",
+		ret = seq_printf(seq,
+				 "BATMAN mesh %s disabled - please specify interfaces to enable it\n",
 				 net_dev->name);
 		goto out;
 	}
 
 	if (primary_if->if_status != IF_ACTIVE) {
-		ret = seq_printf(seq, "BATMAN mesh %s "
-				 "disabled - primary interface not active\n",
+		ret = seq_printf(seq,
+				 "BATMAN mesh %s disabled - primary interface not active\n",
 				 net_dev->name);
 		goto out;
 	}
@@ -403,8 +403,7 @@ void softif_neigh_purge(struct bat_priv *bat_priv)
 
 			if (curr_softif_neigh == softif_neigh) {
 				bat_dbg(DBG_ROUTES, bat_priv,
-					"Current mesh exit point on vid: %d "
-					"'%pM' vanished.\n",
+					"Current mesh exit point on vid: %d '%pM' vanished.\n",
 					softif_neigh_vid->vid,
 					softif_neigh->addr);
 				do_deselect = 1;

commit 0695512a57a8ad5c0495b2a3b23b3216434e3f92
Merge: 5bd49735db39 7c64fd98ce51
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Feb 28 15:07:52 2012 -0500

    Merge tag 'batman-adv-for-davem' of git://git.open-mesh.org/linux-merge

commit 7c64fd98ce512de6c6dae0452dc026446bd368d5
Author: Sven Eckelmann <sven@narfation.org>
Date:   Tue Feb 28 10:55:36 2012 +0100

    batman-adv: Fix indentation of multiline statements
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 2ffdc74ac40e..c39c120e1171 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -397,7 +397,7 @@ void softif_neigh_purge(struct bat_priv *bat_priv)
 					  &softif_neigh_vid->softif_neigh_list,
 					  list) {
 			if ((!has_timed_out(softif_neigh->last_seen,
-					   SOFTIF_NEIGH_TIMEOUT)) &&
+					    SOFTIF_NEIGH_TIMEOUT)) &&
 			    (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE))
 				continue;
 

commit 28009a6cab764f04d4e7c409c180c77b2ef36ba1
Author: Danny Kukawka <danny.kukawka@bisect.de>
Date:   Fri Feb 17 05:43:27 2012 +0000

    batman-adv: use eth_hw_addr_random() instead of random_ether_addr()
    
    Use eth_hw_addr_random() instead of calling random_ether_addr()
    to set addr_assign_type correctly to NET_ADDR_RANDOM.
    
    Remove dev_addr in interface_setup(), it's not needed anymore.
    
    Reset the state to NET_ADDR_PERM as soon as the MAC get
    changed via .ndo_set_mac_address.
    
    v2: use bitops, adapt to eth_hw_addr_random()
    
    Signed-off-by: Danny Kukawka <danny.kukawka@bisect.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b5aecd5e45cc..2d8bd2ad6ba3 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -541,6 +541,7 @@ static int interface_set_mac_addr(struct net_device *dev, void *p)
 	}
 
 	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
+	dev->addr_assign_type &= ~NET_ADDR_RANDOM;
 	return 0;
 }
 
@@ -783,7 +784,6 @@ static const struct net_device_ops bat_netdev_ops = {
 static void interface_setup(struct net_device *dev)
 {
 	struct bat_priv *priv = netdev_priv(dev);
-	char dev_addr[ETH_ALEN];
 
 	ether_setup(dev);
 
@@ -800,8 +800,7 @@ static void interface_setup(struct net_device *dev)
 	dev->hard_header_len = BAT_HEADER_LEN;
 
 	/* generate random address */
-	random_ether_addr(dev_addr);
-	memcpy(dev->dev_addr, dev_addr, ETH_ALEN);
+	eth_hw_addr_random(dev);
 
 	SET_ETHTOOL_OPS(dev, &bat_ethtool_ops);
 

commit 567db7b0b7c0a94cc62846f8ebb429bdda2884bc
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Jan 1 00:41:38 2012 +0100

    batman-adv: Update copyright years
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c41dac3bbf81..2ffdc74ac40e 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2007-2011 B.A.T.M.A.N. contributors:
+ * Copyright (C) 2007-2012 B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
  *

commit 032b7969f8874d5ddc65691cd3d008beffd2a09e
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Tue Dec 20 19:30:40 2011 +0800

    batman-adv: convert time_after instances to has_timed_out
    
    To increase readability the has_timed_out() functions has been introduced.
    This patch converts existing time_after() calls to use this wrapper
    function (if applicable).
    This patch also converts all timeouts to miliseconds to be consistent.
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b5aecd5e45cc..c41dac3bbf81 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -396,8 +396,8 @@ void softif_neigh_purge(struct bat_priv *bat_priv)
 		hlist_for_each_entry_safe(softif_neigh, node_tmp, node_tmp2,
 					  &softif_neigh_vid->softif_neigh_list,
 					  list) {
-			if ((!time_after(jiffies, softif_neigh->last_seen +
-				msecs_to_jiffies(SOFTIF_NEIGH_TIMEOUT))) &&
+			if ((!has_timed_out(softif_neigh->last_seen,
+					   SOFTIF_NEIGH_TIMEOUT)) &&
 			    (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE))
 				continue;
 

commit 1c280471b013e26c833fc86acc231c73442cfa21
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Mon Nov 28 17:40:17 2011 +0800

    batman-adv: add infrastructure to change routing algorithm at runtime
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index bd8c7cfaeacf..b5aecd5e45cc 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -855,6 +855,10 @@ struct net_device *softif_create(const char *name)
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;
 
+	ret = bat_algo_select(bat_priv, bat_routing_algo);
+	if (ret < 0)
+		goto unreg_soft_iface;
+
 	ret = sysfs_add_meshif(soft_iface);
 	if (ret < 0)
 		goto unreg_soft_iface;

commit 76543d14aec6ce5cb3fc7be9b39c50fcebd2043b
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun Nov 20 15:47:38 2011 +0100

    batman-adv: Explicitly mark the common header structure
    
    All batman-adv packets have a common 3 byte header. It can be used to share
    some code between different code paths, but it was never explicit stated that
    this header has to be always the same for all packets. Therefore, new code
    changes always have the problem that they may accidently introduce regressions
    by moving some elements around.
    
    A new structure is introduced that contains the common header and makes it
    easier visible that these 3 bytes have to be the same for all on-wire packets.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 987c75a775f9..bd8c7cfaeacf 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -457,10 +457,10 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 		batman_ogm_packet = (struct batman_ogm_packet *)
 							(skb->data + ETH_HLEN);
 
-	if (batman_ogm_packet->version != COMPAT_VERSION)
+	if (batman_ogm_packet->header.version != COMPAT_VERSION)
 		goto out;
 
-	if (batman_ogm_packet->packet_type != BAT_OGM)
+	if (batman_ogm_packet->header.packet_type != BAT_OGM)
 		goto out;
 
 	if (!(batman_ogm_packet->flags & PRIMARIES_FIRST_HOP))
@@ -632,11 +632,11 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 			goto dropped;
 
 		bcast_packet = (struct bcast_packet *)skb->data;
-		bcast_packet->version = COMPAT_VERSION;
-		bcast_packet->ttl = TTL;
+		bcast_packet->header.version = COMPAT_VERSION;
+		bcast_packet->header.ttl = TTL;
 
 		/* batman packet type: broadcast */
-		bcast_packet->packet_type = BAT_BCAST;
+		bcast_packet->header.packet_type = BAT_BCAST;
 
 		/* hw address of first interface is the orig mac because only
 		 * this mac is known throughout the mesh */
@@ -725,8 +725,8 @@ void interface_rx(struct net_device *soft_iface,
 		skb_push(skb, hdr_size);
 		unicast_packet = (struct unicast_packet *)skb->data;
 
-		if ((unicast_packet->packet_type != BAT_UNICAST) &&
-		    (unicast_packet->packet_type != BAT_UNICAST_FRAG))
+		if ((unicast_packet->header.packet_type != BAT_UNICAST) &&
+		    (unicast_packet->header.packet_type != BAT_UNICAST_FRAG))
 			goto dropped;
 
 		skb_reset_mac_header(skb);

commit 06ba7ce223045369cb5459f95e6c27e708938cf4
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Mon Nov 7 13:57:48 2011 +0100

    batman-adv: use unregister_netdevice() when softif_create fails
    
    When entering softif_create(), the rtnl lock has already been acquired
    by store_mesh_iface().
    (store_mesh_iface() -> hardif_enable_interface() -> softif_create)
    
    In case of an error, we should therefore call unregister_netdevice()
    instead of unregister_netdev().
    
    unregister_netdev() tries to acquire the rtnl lock itself and deadlocks
    in this situation. unregister_netdevice() assumes that the rtnl lock
    is already been held.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 45297c843092..987c75a775f9 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -874,7 +874,7 @@ struct net_device *softif_create(const char *name)
 unreg_sysfs:
 	sysfs_del_meshif(soft_iface);
 unreg_soft_iface:
-	unregister_netdev(soft_iface);
+	unregister_netdevice(soft_iface);
 	return NULL;
 
 free_soft_iface:

commit be7af5cf9cae5e088a9783ccd6e47469ce9d43f4
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Thu Sep 8 13:12:53 2011 +0200

    batman-adv: refactoring gateway handling code
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Acked-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index f9cc95728989..45297c843092 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -563,10 +563,10 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	struct bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
 	struct softif_neigh *curr_softif_neigh = NULL;
-	struct orig_node *orig_node = NULL;
+	unsigned int header_len = 0;
 	int data_len = skb->len, ret;
 	short vid = -1;
-	bool do_bcast;
+	bool do_bcast = false;
 
 	if (atomic_read(&bat_priv->mesh_state) != MESH_ACTIVE)
 		goto dropped;
@@ -598,17 +598,28 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	/* Register the client MAC in the transtable */
 	tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
 
-	orig_node = transtable_search(bat_priv, ethhdr->h_source,
-				      ethhdr->h_dest);
-	do_bcast = is_multicast_ether_addr(ethhdr->h_dest);
-	if (do_bcast || (orig_node && orig_node->gw_flags)) {
-		ret = gw_is_target(bat_priv, skb, orig_node);
+	if (is_multicast_ether_addr(ethhdr->h_dest)) {
+		do_bcast = true;
 
-		if (ret < 0)
-			goto dropped;
-
-		if (ret)
-			do_bcast = false;
+		switch (atomic_read(&bat_priv->gw_mode)) {
+		case GW_MODE_SERVER:
+			/* gateway servers should not send dhcp
+			 * requests into the mesh */
+			ret = gw_is_dhcp_target(skb, &header_len);
+			if (ret)
+				goto dropped;
+			break;
+		case GW_MODE_CLIENT:
+			/* gateway clients should send dhcp requests
+			 * via unicast to their gateway */
+			ret = gw_is_dhcp_target(skb, &header_len);
+			if (ret)
+				do_bcast = false;
+			break;
+		case GW_MODE_OFF:
+		default:
+			break;
+		}
 	}
 
 	/* ethernet packet should be broadcasted */
@@ -644,6 +655,12 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 
 	/* unicast packet */
 	} else {
+		if (atomic_read(&bat_priv->gw_mode) != GW_MODE_OFF) {
+			ret = gw_out_of_range(bat_priv, skb, ethhdr);
+			if (ret)
+				goto dropped;
+		}
+
 		ret = unicast_send_skb(skb, bat_priv);
 		if (ret != 0)
 			goto dropped_freed;
@@ -662,8 +679,6 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		softif_neigh_free_ref(curr_softif_neigh);
 	if (primary_if)
 		hardif_free_ref(primary_if);
-	if (orig_node)
-		orig_node_free_ref(orig_node);
 	return NETDEV_TX_OK;
 }
 

commit 88c5100c28b02c4b2b2c6f6fafbbd76d90f698b9
Merge: 8083f0fc969d 3ee72ca99288
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Oct 7 13:38:43 2011 -0400

    Merge branch 'master' of github.com:davem330/net
    
    Conflicts:
            net/batman-adv/soft-interface.c

commit 8b267b312df9343fea3bd679c509b36214b5a854
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Wed Sep 21 16:06:42 2011 +0200

    batman-adv: do_bcast has to be true for broadcast packets only
    
    corrects a critical bug of the GW feature. This bug made all the unicast
    packets destined to a GW to be sent as broadcast. This bug is present even if
    the sender GW feature is configured as OFF. It's an urgent bug fix and should
    be committed as soon as possible.
    
    This was a regression introduced by 43676ab590c3f8686fd047d34c3e33803eef71f0
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 3e2f91ffa4e2..05dd35114a27 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -565,7 +565,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	struct orig_node *orig_node = NULL;
 	int data_len = skb->len, ret;
 	short vid = -1;
-	bool do_bcast = false;
+	bool do_bcast;
 
 	if (atomic_read(&bat_priv->mesh_state) != MESH_ACTIVE)
 		goto dropped;
@@ -598,15 +598,15 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	tt_local_add(soft_iface, ethhdr->h_source);
 
 	orig_node = transtable_search(bat_priv, ethhdr->h_dest);
-	if (is_multicast_ether_addr(ethhdr->h_dest) ||
-				(orig_node && orig_node->gw_flags)) {
+	do_bcast = is_multicast_ether_addr(ethhdr->h_dest);
+	if (do_bcast ||	(orig_node && orig_node->gw_flags)) {
 		ret = gw_is_target(bat_priv, skb, orig_node);
 
 		if (ret < 0)
 			goto dropped;
 
-		if (ret == 0)
-			do_bcast = true;
+		if (ret)
+			do_bcast = false;
 	}
 
 	/* ethernet packet should be broadcasted */

commit 320f422f629c7ed5d07b4186aa491d1e11d18a4c
Author: Joe Perches <joe@perches.com>
Date:   Mon Aug 29 14:17:24 2011 -0700

    batman-adv: Remove unnecessary OOM logging messages
    
    Removing unnecessary messages saves code and text.
    
    Site specific OOM messages are duplications of a generic MM
    out of memory message and aren't really useful, so just
    delete them.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 7d8332ec44d0..aceeabc2ca86 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -801,10 +801,8 @@ struct net_device *softif_create(const char *name)
 
 	soft_iface = alloc_netdev(sizeof(*bat_priv), name, interface_setup);
 
-	if (!soft_iface) {
-		pr_err("Unable to allocate the batman interface: %s\n", name);
+	if (!soft_iface)
 		goto out;
-	}
 
 	ret = register_netdevice(soft_iface);
 	if (ret < 0) {

commit b6da4bf5d7951aba4f86d65546474c4e718f650f
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Fri Jul 29 17:31:50 2011 +0200

    batman-adv: rename all instances of batman_packet to batman_ogm_packet
    
    The follow-up routing code changes are going to introduce additional
    routing packet types which make this distinction necessary.
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 402fd96239d8..7d8332ec44d0 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -445,30 +445,31 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 {
 	struct bat_priv *bat_priv = netdev_priv(dev);
 	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
-	struct batman_packet *batman_packet;
+	struct batman_ogm_packet *batman_ogm_packet;
 	struct softif_neigh *softif_neigh = NULL;
 	struct hard_iface *primary_if = NULL;
 	struct softif_neigh *curr_softif_neigh = NULL;
 
 	if (ntohs(ethhdr->h_proto) == ETH_P_8021Q)
-		batman_packet = (struct batman_packet *)
+		batman_ogm_packet = (struct batman_ogm_packet *)
 					(skb->data + ETH_HLEN + VLAN_HLEN);
 	else
-		batman_packet = (struct batman_packet *)(skb->data + ETH_HLEN);
+		batman_ogm_packet = (struct batman_ogm_packet *)
+							(skb->data + ETH_HLEN);
 
-	if (batman_packet->version != COMPAT_VERSION)
+	if (batman_ogm_packet->version != COMPAT_VERSION)
 		goto out;
 
-	if (batman_packet->packet_type != BAT_PACKET)
+	if (batman_ogm_packet->packet_type != BAT_OGM)
 		goto out;
 
-	if (!(batman_packet->flags & PRIMARIES_FIRST_HOP))
+	if (!(batman_ogm_packet->flags & PRIMARIES_FIRST_HOP))
 		goto out;
 
-	if (is_my_mac(batman_packet->orig))
+	if (is_my_mac(batman_ogm_packet->orig))
 		goto out;
 
-	softif_neigh = softif_neigh_get(bat_priv, batman_packet->orig, vid);
+	softif_neigh = softif_neigh_get(bat_priv, batman_ogm_packet->orig, vid);
 	if (!softif_neigh)
 		goto out;
 

commit 3d393e47321062dbf9078a66a7cc1c2a52bafecc
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Thu Jul 7 15:35:37 2011 +0200

    batman-adv: implement AP-isolation on the sender side
    
    If a node has to send a packet issued by a WIFI client to another WIFI client,
    the packet is dropped.
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 9addbab52999..402fd96239d8 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -597,7 +597,8 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	/* Register the client MAC in the transtable */
 	tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
 
-	orig_node = transtable_search(bat_priv, ethhdr->h_dest);
+	orig_node = transtable_search(bat_priv, ethhdr->h_source,
+				      ethhdr->h_dest);
 	if (is_multicast_ether_addr(ethhdr->h_dest) ||
 				(orig_node && orig_node->gw_flags)) {
 		ret = gw_is_target(bat_priv, skb, orig_node);

commit 59b699cdee039d75915c354da06937102d1f9a84
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Thu Jul 7 15:35:36 2011 +0200

    batman-adv: implement AP-isolation on the receiver side
    
    When a node receives a unicast packet it checks if the source and the
    destination client can communicate or not due to the AP isolation
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 6deed44a3703..9addbab52999 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -739,6 +739,9 @@ void interface_rx(struct net_device *soft_iface,
 
 	soft_iface->last_rx = jiffies;
 
+	if (is_ap_isolated(bat_priv, ethhdr->h_source, ethhdr->h_dest))
+		goto dropped;
+
 	netif_rx(skb);
 	goto out;
 
@@ -812,6 +815,7 @@ struct net_device *softif_create(const char *name)
 
 	atomic_set(&bat_priv->aggregated_ogms, 1);
 	atomic_set(&bat_priv->bonding, 0);
+	atomic_set(&bat_priv->ap_isolation, 0);
 	atomic_set(&bat_priv->vis_mode, VIS_TYPE_CLIENT_UPDATE);
 	atomic_set(&bat_priv->gw_mode, GW_MODE_OFF);
 	atomic_set(&bat_priv->gw_sel_class, 20);

commit bc2790808a7a3699a7c9f72f7ad225c8504824aa
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Thu Jul 7 15:35:35 2011 +0200

    batman-adv: detect clients connected through a 802.11 device
    
    Clients connected through a 802.11 device are now marked with the
    TT_CLIENT_WIFI flag. This flag is also advertised with the tt
    announcement.
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 6ba35a2772ff..6deed44a3703 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -536,7 +536,7 @@ static int interface_set_mac_addr(struct net_device *dev, void *p)
 	if (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE) {
 		tt_local_remove(bat_priv, dev->dev_addr,
 				"mac address changed", false);
-		tt_local_add(dev, addr->sa_data);
+		tt_local_add(dev, addr->sa_data, NULL_IFINDEX);
 	}
 
 	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
@@ -595,7 +595,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		goto dropped;
 
 	/* Register the client MAC in the transtable */
-	tt_local_add(soft_iface, ethhdr->h_source);
+	tt_local_add(soft_iface, ethhdr->h_source, skb->skb_iif);
 
 	orig_node = transtable_search(bat_priv, ethhdr->h_dest);
 	if (is_multicast_ether_addr(ethhdr->h_dest) ||

commit 015758d00251a4dd9287806cdab4b9c1298f97ed
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Sat Jul 9 17:52:13 2011 +0200

    batman-adv: correct several typ0s in the comments
    
    Several typos have been corrected and some sentences have been rephrased
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 3e2f91ffa4e2..6ba35a2772ff 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -532,7 +532,7 @@ static int interface_set_mac_addr(struct net_device *dev, void *p)
 	if (!is_valid_ether_addr(addr->sa_data))
 		return -EADDRNOTAVAIL;
 
-	/* only modify transtable if it has been initialised before */
+	/* only modify transtable if it has been initialized before */
 	if (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE) {
 		tt_local_remove(bat_priv, dev->dev_addr,
 				"mac address changed", false);

commit e2270ea62ae4d7a47d6d72942cdb8c669be6357a
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jul 12 10:37:21 2011 -0700

    netdevice: Kill 'feature' test macros.
    
    Almost all of these have long outstayed their welcome.
    
    And for every one of these macros, there are 10 features for which we
    didn't add macros.
    
    Let's just delete them all, and get out of habit of doing things this
    way.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Acked-by: Stephen Hemminger <shemminger@vyatta.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 3f20332e1d38..3e2f91ffa4e2 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -750,7 +750,6 @@ void interface_rx(struct net_device *soft_iface,
 	return;
 }
 
-#ifdef HAVE_NET_DEVICE_OPS
 static const struct net_device_ops bat_netdev_ops = {
 	.ndo_open = interface_open,
 	.ndo_stop = interface_release,
@@ -760,7 +759,6 @@ static const struct net_device_ops bat_netdev_ops = {
 	.ndo_start_xmit = interface_tx,
 	.ndo_validate_addr = eth_validate_addr
 };
-#endif
 
 static void interface_setup(struct net_device *dev)
 {
@@ -769,16 +767,7 @@ static void interface_setup(struct net_device *dev)
 
 	ether_setup(dev);
 
-#ifdef HAVE_NET_DEVICE_OPS
 	dev->netdev_ops = &bat_netdev_ops;
-#else
-	dev->open = interface_open;
-	dev->stop = interface_release;
-	dev->get_stats = interface_stats;
-	dev->set_mac_address = interface_set_mac_addr;
-	dev->change_mtu = interface_change_mtu;
-	dev->hard_start_xmit = interface_tx;
-#endif
 	dev->destructor = free_netdev;
 	dev->tx_queue_len = 0;
 
@@ -885,13 +874,8 @@ void softif_destroy(struct net_device *soft_iface)
 
 int softif_is_valid(const struct net_device *net_dev)
 {
-#ifdef HAVE_NET_DEVICE_OPS
 	if (net_dev->netdev_ops->ndo_start_xmit == interface_tx)
 		return 1;
-#else
-	if (net_dev->hard_start_xmit == interface_tx)
-		return 1;
-#endif
 
 	return 0;
 }

commit 8698529d209c43f6434592caf38733b84ccab5f3
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Sat Jun 25 19:09:12 2011 +0200

    batman-adv: add_bcast_packet_to_list() takes the sending delay as parameter
    
    In order to make possible to use the broadcast list for delayed sendings
    the "delay" parameter is now provided instead of using 1 as hardcoded
    value.
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 2dcdbb7a236c..3f20332e1d38 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -634,7 +634,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		bcast_packet->seqno =
 			htonl(atomic_inc_return(&bat_priv->bcast_seqno));
 
-		add_bcast_packet_to_list(bat_priv, skb);
+		add_bcast_packet_to_list(bat_priv, skb, 1);
 
 		/* a copy is stored in the bcast list, therefore removing
 		 * the original skb. */

commit 43676ab590c3f8686fd047d34c3e33803eef71f0
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Tue Apr 26 21:31:45 2011 +0200

    batman-adv: improved gateway tq-based selection
    
    If a client issues a DHCPREQUEST for renewal, the packet is dropped
    if the old destination (the old gateway for the client) TQ is smaller
    than the current best gateway TQ less GW_THRESHOLD
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 3371ece680a2..2dcdbb7a236c 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -30,6 +30,7 @@
 #include "gateway_common.h"
 #include "gateway_client.h"
 #include "bat_sysfs.h"
+#include "originator.h"
 #include <linux/slab.h>
 #include <linux/ethtool.h>
 #include <linux/etherdevice.h>
@@ -561,6 +562,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	struct bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
 	struct softif_neigh *curr_softif_neigh = NULL;
+	struct orig_node *orig_node = NULL;
 	int data_len = skb->len, ret;
 	short vid = -1;
 	bool do_bcast = false;
@@ -595,8 +597,10 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	/* Register the client MAC in the transtable */
 	tt_local_add(soft_iface, ethhdr->h_source);
 
-	if (is_multicast_ether_addr(ethhdr->h_dest)) {
-		ret = gw_is_target(bat_priv, skb);
+	orig_node = transtable_search(bat_priv, ethhdr->h_dest);
+	if (is_multicast_ether_addr(ethhdr->h_dest) ||
+				(orig_node && orig_node->gw_flags)) {
+		ret = gw_is_target(bat_priv, skb, orig_node);
 
 		if (ret < 0)
 			goto dropped;
@@ -656,6 +660,8 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		softif_neigh_free_ref(curr_softif_neigh);
 	if (primary_if)
 		hardif_free_ref(primary_if);
+	if (orig_node)
+		orig_node_free_ref(orig_node);
 	return NETDEV_TX_OK;
 }
 

commit cc47f66e6b9ec7e7d465f74739a6fc9844593894
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Wed Apr 27 14:27:57 2011 +0200

    batman-adv: improved roaming mechanism
    
    With the current client announcement implementation, in case of roaming,
    an update is triggered on the new AP serving the client. At that point
    the new information is spread around by means of the OGM broadcasting
    mechanism. Until this operations is not executed, no node is able to
    correctly route traffic towards the client. This obviously causes packet
    drops and introduces a delay in the time needed by the client to recover
    its connections.
    
    A new packet type called ROAMING_ADVERTISEMENT is added to account this
    issue.
    
    This message is sent in case of roaming from the new AP serving the
    client to the old one and will contain the client MAC address. In this
    way an out-of-OGM update is immediately committed, so that the old node
    can update its global translation table. Traffic reaching this node will
    then be redirected to the correct destination utilising the fresher
    information. Thus reducing the packet drops and the connection recovery
    delay.
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c288d937a154..3371ece680a2 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -534,7 +534,7 @@ static int interface_set_mac_addr(struct net_device *dev, void *p)
 	/* only modify transtable if it has been initialised before */
 	if (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE) {
 		tt_local_remove(bat_priv, dev->dev_addr,
-				"mac address changed");
+				"mac address changed", false);
 		tt_local_add(dev, addr->sa_data);
 	}
 
@@ -836,6 +836,7 @@ struct net_device *softif_create(const char *name)
 
 	bat_priv->tt_buff = NULL;
 	bat_priv->tt_buff_len = 0;
+	bat_priv->tt_poss_change = false;
 
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;

commit a73105b8d4c765d9ebfb664d0a66802127d8e4c7
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Wed Apr 27 14:27:44 2011 +0200

    batman-adv: improved client announcement mechanism
    
    The client announcement mechanism informs every mesh node in the network
    of any connected non-mesh client, in order to find the path towards that
    client from any given point in the mesh.
    
    The old implementation was based on the simple idea of appending a data
    buffer to each OGM containing all the client MAC addresses the node is
    serving. All other nodes can populate their global translation tables
    (table which links client MAC addresses to node addresses) using this
    MAC address buffer and linking it to the node's address contained in the
    OGM. A node that wants to contact a client has to lookup the node the
    client is connected to and its address in the global translation table.
    
    It is easy to understand that this implementation suffers from several
    issues:
     - big overhead (each and every OGM contains the entire list of
       connected clients)
     - high latencies for client route updates due to long OGM trip time and
       OGM losses
    
    The new implementation addresses these issues by appending client
    changes (new client joined or a client left) to the OGM instead of
    filling it with all the client addresses each time. In this way nodes
    can modify their global tables by means of "updates", thus reducing the
    overhead within the OGMs.
    
    To keep the entire network in sync each node maintains a translation
    table version number (ttvn) and a translation table checksum. These
    values are spread with the OGM to allow all the network participants to
    determine whether or not they need to update their translation table
    information.
    
    When a translation table lookup is performed in order to send a packet
    to a client attached to another node, the destination's ttvn is added to
    the payload packet. Forwarding nodes can compare the packet's ttvn with
    their destination's ttvn (this node could have a fresher information
    than the source) and re-route the packet if necessary. This greatly
    reduces the packet loss of clients roaming from one AP to the next.
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 69c002279e63..c288d937a154 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -534,7 +534,7 @@ static int interface_set_mac_addr(struct net_device *dev, void *p)
 	/* only modify transtable if it has been initialised before */
 	if (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE) {
 		tt_local_remove(bat_priv, dev->dev_addr,
-				 "mac address changed");
+				"mac address changed");
 		tt_local_add(dev, addr->sa_data);
 	}
 
@@ -592,7 +592,7 @@ static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	if (curr_softif_neigh)
 		goto dropped;
 
-	/* TODO: check this for locks */
+	/* Register the client MAC in the transtable */
 	tt_local_add(soft_iface, ethhdr->h_source);
 
 	if (is_multicast_ether_addr(ethhdr->h_dest)) {
@@ -830,7 +830,12 @@ struct net_device *softif_create(const char *name)
 
 	atomic_set(&bat_priv->mesh_state, MESH_INACTIVE);
 	atomic_set(&bat_priv->bcast_seqno, 1);
-	atomic_set(&bat_priv->tt_local_changed, 0);
+	atomic_set(&bat_priv->ttvn, 0);
+	atomic_set(&bat_priv->tt_local_changes, 0);
+	atomic_set(&bat_priv->tt_ogm_append_cnt, 0);
+
+	bat_priv->tt_buff = NULL;
+	bat_priv->tt_buff_len = 0;
 
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;

commit b4e1705417c6cc7d46d9020259a2c8f457cf82bd
Author: Sven Eckelmann <sven@narfation.org>
Date:   Wed Jun 15 09:41:37 2011 +0200

    batman-adv: Reduce usage of char
    
    char was used in different places to store information without really
    using the characteristics of that data type or by ignoring the fact that
    char has not a well defined signedness.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 0fc997e13251..69c002279e63 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -380,7 +380,7 @@ void softif_neigh_purge(struct bat_priv *bat_priv)
 	struct softif_neigh *softif_neigh, *curr_softif_neigh;
 	struct softif_neigh_vid *softif_neigh_vid;
 	struct hlist_node *node, *node_tmp, *node_tmp2;
-	char do_deselect;
+	int do_deselect;
 
 	rcu_read_lock();
 	hlist_for_each_entry_rcu(softif_neigh_vid, node,

commit db69ecfcb0d4df4d6449172186a8dd20836275ed
Author: Sven Eckelmann <sven@narfation.org>
Date:   Wed Jun 15 15:17:21 2011 +0200

    batman-adv: Keep interface_tx as local function
    
    interface_tx is not used outside of soft-interface.c and thus doesn't
    need to be declared inside soft-interface.h
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index b8d3f248efdc..0fc997e13251 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -553,7 +553,7 @@ static int interface_change_mtu(struct net_device *dev, int new_mtu)
 	return 0;
 }
 
-int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
+static int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 {
 	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
 	struct bat_priv *bat_priv = netdev_priv(soft_iface);

commit 728cbc6ac1eef89660875c70a602c1a0ba8df4ff
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun May 15 00:50:21 2011 +0200

    batman-adv: Use rcu_dereference_protected by update-side
    
    Usually rcu_dereference isn't necessary in situations were the
    RCU-protected data structure cannot change, but sparse and lockdep still
    need a similar functionality for analysis. rcu_dereference_protected
    implements the reduced version which should be used to support the
    dynamic and static analysis.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index cead606008a1..b8d3f248efdc 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -241,7 +241,8 @@ static void softif_neigh_vid_select(struct bat_priv *bat_priv,
 	if (new_neigh && !atomic_inc_not_zero(&new_neigh->refcount))
 		new_neigh = NULL;
 
-	curr_neigh = softif_neigh_vid->softif_neigh;
+	curr_neigh = rcu_dereference_protected(softif_neigh_vid->softif_neigh,
+					       1);
 	rcu_assign_pointer(softif_neigh_vid->softif_neigh, new_neigh);
 
 	if ((curr_neigh) && (!new_neigh))

commit 704509b8d44886cebfbaff1a9813c35dfa986954
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 14 23:14:54 2011 +0200

    batman-adv: Calculate sizeof using variable insead of types
    
    Documentation/CodingStyle recommends to use the form
    
            p = kmalloc(sizeof(*p), ...);
    
    to calculate the size of a struct and not the version where the struct
    name is spelled out to prevent bugs when the type of p changes. This
    also seems appropriate for manipulation of buffers when they are
    directly associated with p.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 1bec3a0f9721..cead606008a1 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -123,8 +123,7 @@ static struct softif_neigh_vid *softif_neigh_vid_get(struct bat_priv *bat_priv,
 		goto out;
 	}
 
-	softif_neigh_vid = kzalloc(sizeof(struct softif_neigh_vid),
-				   GFP_ATOMIC);
+	softif_neigh_vid = kzalloc(sizeof(*softif_neigh_vid), GFP_ATOMIC);
 	if (!softif_neigh_vid)
 		goto out;
 
@@ -170,7 +169,7 @@ static struct softif_neigh *softif_neigh_get(struct bat_priv *bat_priv,
 		goto unlock;
 	}
 
-	softif_neigh = kzalloc(sizeof(struct softif_neigh), GFP_ATOMIC);
+	softif_neigh = kzalloc(sizeof(*softif_neigh), GFP_ATOMIC);
 	if (!softif_neigh)
 		goto unlock;
 
@@ -611,7 +610,7 @@ int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		if (!primary_if)
 			goto dropped;
 
-		if (my_skb_head_push(skb, sizeof(struct bcast_packet)) < 0)
+		if (my_skb_head_push(skb, sizeof(*bcast_packet)) < 0)
 			goto dropped;
 
 		bcast_packet = (struct bcast_packet *)skb->data;
@@ -790,7 +789,7 @@ static void interface_setup(struct net_device *dev)
 
 	SET_ETHTOOL_OPS(dev, &bat_ethtool_ops);
 
-	memset(priv, 0, sizeof(struct bat_priv));
+	memset(priv, 0, sizeof(*priv));
 }
 
 struct net_device *softif_create(const char *name)
@@ -799,8 +798,7 @@ struct net_device *softif_create(const char *name)
 	struct bat_priv *bat_priv;
 	int ret;
 
-	soft_iface = alloc_netdev(sizeof(struct bat_priv) , name,
-				   interface_setup);
+	soft_iface = alloc_netdev(sizeof(*bat_priv), name, interface_setup);
 
 	if (!soft_iface) {
 		pr_err("Unable to allocate the batman interface: %s\n", name);

commit 747e4221a03cde62402b614ca1f8e961b8416130
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sat May 14 23:14:50 2011 +0200

    batman-adv: Add const type qualifier for pointers
    
    batman-adv uses pointers which are marked as const and should not
    violate that type qualifier by passing it to functions which force a
    cast to the non-const version.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index d5aa60999e83..1bec3a0f9721 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -146,7 +146,7 @@ static struct softif_neigh_vid *softif_neigh_vid_get(struct bat_priv *bat_priv,
 }
 
 static struct softif_neigh *softif_neigh_get(struct bat_priv *bat_priv,
-					     uint8_t *addr, short vid)
+					     const uint8_t *addr, short vid)
 {
 	struct softif_neigh_vid *softif_neigh_vid;
 	struct softif_neigh *softif_neigh = NULL;
@@ -793,7 +793,7 @@ static void interface_setup(struct net_device *dev)
 	memset(priv, 0, sizeof(struct bat_priv));
 }
 
-struct net_device *softif_create(char *name)
+struct net_device *softif_create(const char *name)
 {
 	struct net_device *soft_iface;
 	struct bat_priv *bat_priv;
@@ -872,7 +872,7 @@ void softif_destroy(struct net_device *soft_iface)
 	unregister_netdevice(soft_iface);
 }
 
-int softif_is_valid(struct net_device *net_dev)
+int softif_is_valid(const struct net_device *net_dev)
 {
 #ifdef HAVE_NET_DEVICE_OPS
 	if (net_dev->netdev_ops->ndo_start_xmit == interface_tx)
@@ -924,4 +924,3 @@ static u32 bat_get_link(struct net_device *dev)
 {
 	return 1;
 }
-

commit 06f4e926d256d902dd9a53dcb400fd74974ce087
Merge: 8e7bfcbab382 d93515611bbc
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 20 13:43:21 2011 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/davem/net-next-2.6: (1446 commits)
      macvlan: fix panic if lowerdev in a bond
      tg3: Add braces around 5906 workaround.
      tg3: Fix NETIF_F_LOOPBACK error
      macvlan: remove one synchronize_rcu() call
      networking: NET_CLS_ROUTE4 depends on INET
      irda: Fix error propagation in ircomm_lmp_connect_response()
      irda: Kill set but unused variable 'bytes' in irlan_check_command_param()
      irda: Kill set but unused variable 'clen' in ircomm_connect_indication()
      rxrpc: Fix set but unused variable 'usage' in rxrpc_get_transport()
      be2net: Kill set but unused variable 'req' in lancer_fw_download()
      irda: Kill set but unused vars 'saddr' and 'daddr' in irlan_provider_connect_indication()
      atl1c: atl1c_resume() is only used when CONFIG_PM_SLEEP is defined.
      rxrpc: Fix set but unused variable 'usage' in rxrpc_get_peer().
      rxrpc: Kill set but unused variable 'local' in rxrpc_UDP_error_handler()
      rxrpc: Kill set but unused variable 'sp' in rxrpc_process_connection()
      rxrpc: Kill set but unused variable 'sp' in rxrpc_rotate_tx_window()
      pkt_sched: Kill set but unused variable 'protocol' in tc_classify()
      isdn: capi: Use pr_debug() instead of ifdefs.
      tg3: Update version to 3.119
      tg3: Apply rx_discards fix to 5719/5720
      ...
    
    Fix up trivial conflicts in arch/x86/Kconfig and net/mac80211/agg-tx.c
    as per Davem.

commit 02e73c1edc3746e308d1768a27fdc8121f641ab1
Merge: c5216cc70fa7 27aea2128ec0
Author: David S. Miller <davem@davemloft.net>
Date:   Sun May 8 15:39:11 2011 -0700

    Merge branch 'batman-adv/next' of git://git.open-mesh.org/ecsv/linux-merge

commit 6e215fd8eb4930373d01da0fac16a0889804fac3
Author: Sven Eckelmann <sven@narfation.org>
Date:   Sun May 8 12:45:45 2011 +0200

    batman-adv: Remove multiline comments from line ending
    
    It is slightly irritating that comments after a long line span over
    multiple lines without any code. It is easier to put them before the
    actual code and reduce the number of lines which the eye has to read.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index d6aaf9fa64d4..8e962e3aa427 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -793,8 +793,8 @@ static void interface_setup(struct net_device *dev)
 	 * have not been initialized yet
 	 */
 	dev->mtu = ETH_DATA_LEN;
-	dev->hard_header_len = BAT_HEADER_LEN; /* reserve more space in the
-						* skbuff for our header */
+	/* reserve more space in the skbuff for our header */
+	dev->hard_header_len = BAT_HEADER_LEN;
 
 	/* generate random address */
 	random_ether_addr(dev_addr);

commit 2dafb49d84a9195193b28ac5047df1bbab6053b9
Author: Antonio Quartulli <ordex@autistici.org>
Date:   Thu May 5 08:42:45 2011 +0200

    batman-adv: rename everything from *hna* into *tt* (translation table)
    
    To be coherent, all the functions/variables/constants have been renamed
    to the TranslationTable style
    
    Signed-off-by: Antonio Quartulli <ordex@autistici.org>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 9301e21052e7..d6aaf9fa64d4 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -543,11 +543,11 @@ static int interface_set_mac_addr(struct net_device *dev, void *p)
 	if (!is_valid_ether_addr(addr->sa_data))
 		return -EADDRNOTAVAIL;
 
-	/* only modify hna-table if it has been initialised before */
+	/* only modify transtable if it has been initialised before */
 	if (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE) {
-		hna_local_remove(bat_priv, dev->dev_addr,
+		tt_local_remove(bat_priv, dev->dev_addr,
 				 "mac address changed");
-		hna_local_add(dev, addr->sa_data);
+		tt_local_add(dev, addr->sa_data);
 	}
 
 	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
@@ -605,7 +605,7 @@ int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		goto dropped;
 
 	/* TODO: check this for locks */
-	hna_local_add(soft_iface, ethhdr->h_source);
+	tt_local_add(soft_iface, ethhdr->h_source);
 
 	if (is_multicast_ether_addr(ethhdr->h_dest)) {
 		ret = gw_is_target(bat_priv, skb);
@@ -843,7 +843,7 @@ struct net_device *softif_create(char *name)
 
 	atomic_set(&bat_priv->mesh_state, MESH_INACTIVE);
 	atomic_set(&bat_priv->bcast_seqno, 1);
-	atomic_set(&bat_priv->hna_local_changed, 0);
+	atomic_set(&bat_priv->tt_local_changed, 0);
 
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;

commit c3caf5196c47a5d1c325308d8eb7f6b020ba12df
Author: Sven Eckelmann <sven@narfation.org>
Date:   Tue May 3 11:51:38 2011 +0200

    batman-adv: Remove unnecessary hardif_list_lock
    
    hardif_list_lock is unneccessary because we already ensure that no
    multiple admin operations can take place through rtnl_lock.
    hardif_list_lock only adds additional overhead and complexity.
    
    Critical functions now check whether they are called with rtnl_lock
    using ASSERT_RTNL.
    
    It indirectly fixes the problem that orig_hash_del_if() expects that
    only one interface is deleted from hardif_list at a time, but
    hardif_remove_interfaces() removes all at once and then calls
    orig_hash_del_if().
    
    Reported-by: Linus Lüssing <linus.luessing@web.de>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 8cb13a03b0e1..9301e21052e7 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -819,7 +819,7 @@ struct net_device *softif_create(char *name)
 		goto out;
 	}
 
-	ret = register_netdev(soft_iface);
+	ret = register_netdevice(soft_iface);
 	if (ret < 0) {
 		pr_err("Unable to register the batman interface '%s': %i\n",
 		       name, ret);

commit 61906ae86d8989e5bd3bc1f51b2fb8d32ffde2c5
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Thu Apr 21 15:52:17 2011 +0200

    batman-adv: multi vlan support for bridge loop detection
    
    The bridge loop detection for batman-adv allows the bat0 interface
    to be bridged into an ethernet segment which other batman-adv nodes
    are connected to. In order to also allow multiple VLANs on top of
    the bat0 interface to be bridged into the ethernet segment this
    patch extends the aforementioned bridge loop detection.
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index ea5e58c252f0..8cb13a03b0e1 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -90,135 +90,251 @@ static void softif_neigh_free_ref(struct softif_neigh *softif_neigh)
 		call_rcu(&softif_neigh->rcu, softif_neigh_free_rcu);
 }
 
-static struct softif_neigh *softif_neigh_get_selected(struct bat_priv *bat_priv)
+static void softif_neigh_vid_free_rcu(struct rcu_head *rcu)
 {
-	struct softif_neigh *neigh;
-
-	rcu_read_lock();
-	neigh = rcu_dereference(bat_priv->softif_neigh);
-
-	if (neigh && !atomic_inc_not_zero(&neigh->refcount))
-		neigh = NULL;
-
-	rcu_read_unlock();
-	return neigh;
-}
+	struct softif_neigh_vid *softif_neigh_vid;
+	struct softif_neigh *softif_neigh;
+	struct hlist_node *node, *node_tmp;
+	struct bat_priv *bat_priv;
 
-static void softif_neigh_select(struct bat_priv *bat_priv,
-				struct softif_neigh *new_neigh)
-{
-	struct softif_neigh *curr_neigh;
+	softif_neigh_vid = container_of(rcu, struct softif_neigh_vid, rcu);
+	bat_priv = softif_neigh_vid->bat_priv;
 
 	spin_lock_bh(&bat_priv->softif_neigh_lock);
-
-	if (new_neigh && !atomic_inc_not_zero(&new_neigh->refcount))
-		new_neigh = NULL;
-
-	curr_neigh = bat_priv->softif_neigh;
-	rcu_assign_pointer(bat_priv->softif_neigh, new_neigh);
-
-	if (curr_neigh)
-		softif_neigh_free_ref(curr_neigh);
-
+	hlist_for_each_entry_safe(softif_neigh, node, node_tmp,
+				  &softif_neigh_vid->softif_neigh_list, list) {
+		hlist_del_rcu(&softif_neigh->list);
+		softif_neigh_free_ref(softif_neigh);
+	}
 	spin_unlock_bh(&bat_priv->softif_neigh_lock);
+
+	kfree(softif_neigh_vid);
 }
 
-static void softif_neigh_deselect(struct bat_priv *bat_priv)
+static void softif_neigh_vid_free_ref(struct softif_neigh_vid *softif_neigh_vid)
 {
-	softif_neigh_select(bat_priv, NULL);
+	if (atomic_dec_and_test(&softif_neigh_vid->refcount))
+		call_rcu(&softif_neigh_vid->rcu, softif_neigh_vid_free_rcu);
 }
 
-void softif_neigh_purge(struct bat_priv *bat_priv)
+static struct softif_neigh_vid *softif_neigh_vid_get(struct bat_priv *bat_priv,
+						     short vid)
 {
-	struct softif_neigh *softif_neigh, *curr_softif_neigh;
-	struct hlist_node *node, *node_tmp;
-	char do_deselect = 0;
-
-	curr_softif_neigh = softif_neigh_get_selected(bat_priv);
-
-	spin_lock_bh(&bat_priv->softif_neigh_lock);
-
-	hlist_for_each_entry_safe(softif_neigh, node, node_tmp,
-				  &bat_priv->softif_neigh_list, list) {
+	struct softif_neigh_vid *softif_neigh_vid;
+	struct hlist_node *node;
 
-		if ((!time_after(jiffies, softif_neigh->last_seen +
-				msecs_to_jiffies(SOFTIF_NEIGH_TIMEOUT))) &&
-		    (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE))
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(softif_neigh_vid, node,
+				 &bat_priv->softif_neigh_vids, list) {
+		if (softif_neigh_vid->vid != vid)
 			continue;
 
-		if (curr_softif_neigh == softif_neigh) {
-			bat_dbg(DBG_ROUTES, bat_priv,
-				 "Current mesh exit point '%pM' vanished "
-				 "(vid: %d).\n",
-				 softif_neigh->addr, softif_neigh->vid);
-			do_deselect = 1;
-		}
+		if (!atomic_inc_not_zero(&softif_neigh_vid->refcount))
+			continue;
 
-		hlist_del_rcu(&softif_neigh->list);
-		softif_neigh_free_ref(softif_neigh);
+		goto out;
 	}
 
-	spin_unlock_bh(&bat_priv->softif_neigh_lock);
+	softif_neigh_vid = kzalloc(sizeof(struct softif_neigh_vid),
+				   GFP_ATOMIC);
+	if (!softif_neigh_vid)
+		goto out;
 
-	/* soft_neigh_deselect() needs to acquire the softif_neigh_lock */
-	if (do_deselect)
-		softif_neigh_deselect(bat_priv);
+	softif_neigh_vid->vid = vid;
+	softif_neigh_vid->bat_priv = bat_priv;
 
-	if (curr_softif_neigh)
-		softif_neigh_free_ref(curr_softif_neigh);
+	/* initialize with 2 - caller decrements counter by one */
+	atomic_set(&softif_neigh_vid->refcount, 2);
+	INIT_HLIST_HEAD(&softif_neigh_vid->softif_neigh_list);
+	INIT_HLIST_NODE(&softif_neigh_vid->list);
+	spin_lock_bh(&bat_priv->softif_neigh_vid_lock);
+	hlist_add_head_rcu(&softif_neigh_vid->list,
+			   &bat_priv->softif_neigh_vids);
+	spin_unlock_bh(&bat_priv->softif_neigh_vid_lock);
+
+out:
+	rcu_read_unlock();
+	return softif_neigh_vid;
 }
 
 static struct softif_neigh *softif_neigh_get(struct bat_priv *bat_priv,
 					     uint8_t *addr, short vid)
 {
-	struct softif_neigh *softif_neigh;
+	struct softif_neigh_vid *softif_neigh_vid;
+	struct softif_neigh *softif_neigh = NULL;
 	struct hlist_node *node;
 
+	softif_neigh_vid = softif_neigh_vid_get(bat_priv, vid);
+	if (!softif_neigh_vid)
+		goto out;
+
 	rcu_read_lock();
 	hlist_for_each_entry_rcu(softif_neigh, node,
-				 &bat_priv->softif_neigh_list, list) {
+				 &softif_neigh_vid->softif_neigh_list,
+				 list) {
 		if (!compare_eth(softif_neigh->addr, addr))
 			continue;
 
-		if (softif_neigh->vid != vid)
-			continue;
-
 		if (!atomic_inc_not_zero(&softif_neigh->refcount))
 			continue;
 
 		softif_neigh->last_seen = jiffies;
-		goto out;
+		goto unlock;
 	}
 
 	softif_neigh = kzalloc(sizeof(struct softif_neigh), GFP_ATOMIC);
 	if (!softif_neigh)
-		goto out;
+		goto unlock;
 
 	memcpy(softif_neigh->addr, addr, ETH_ALEN);
-	softif_neigh->vid = vid;
 	softif_neigh->last_seen = jiffies;
 	/* initialize with 2 - caller decrements counter by one */
 	atomic_set(&softif_neigh->refcount, 2);
 
 	INIT_HLIST_NODE(&softif_neigh->list);
 	spin_lock_bh(&bat_priv->softif_neigh_lock);
-	hlist_add_head_rcu(&softif_neigh->list, &bat_priv->softif_neigh_list);
+	hlist_add_head_rcu(&softif_neigh->list,
+			   &softif_neigh_vid->softif_neigh_list);
 	spin_unlock_bh(&bat_priv->softif_neigh_lock);
 
+unlock:
+	rcu_read_unlock();
 out:
+	if (softif_neigh_vid)
+		softif_neigh_vid_free_ref(softif_neigh_vid);
+	return softif_neigh;
+}
+
+static struct softif_neigh *softif_neigh_get_selected(
+				struct softif_neigh_vid *softif_neigh_vid)
+{
+	struct softif_neigh *softif_neigh;
+
+	rcu_read_lock();
+	softif_neigh = rcu_dereference(softif_neigh_vid->softif_neigh);
+
+	if (softif_neigh && !atomic_inc_not_zero(&softif_neigh->refcount))
+		softif_neigh = NULL;
+
 	rcu_read_unlock();
 	return softif_neigh;
 }
 
+static struct softif_neigh *softif_neigh_vid_get_selected(
+						struct bat_priv *bat_priv,
+						short vid)
+{
+	struct softif_neigh_vid *softif_neigh_vid;
+	struct softif_neigh *softif_neigh = NULL;
+
+	softif_neigh_vid = softif_neigh_vid_get(bat_priv, vid);
+	if (!softif_neigh_vid)
+		goto out;
+
+	softif_neigh = softif_neigh_get_selected(softif_neigh_vid);
+out:
+	if (softif_neigh_vid)
+		softif_neigh_vid_free_ref(softif_neigh_vid);
+	return softif_neigh;
+}
+
+static void softif_neigh_vid_select(struct bat_priv *bat_priv,
+				    struct softif_neigh *new_neigh,
+				    short vid)
+{
+	struct softif_neigh_vid *softif_neigh_vid;
+	struct softif_neigh *curr_neigh;
+
+	softif_neigh_vid = softif_neigh_vid_get(bat_priv, vid);
+	if (!softif_neigh_vid)
+		goto out;
+
+	spin_lock_bh(&bat_priv->softif_neigh_lock);
+
+	if (new_neigh && !atomic_inc_not_zero(&new_neigh->refcount))
+		new_neigh = NULL;
+
+	curr_neigh = softif_neigh_vid->softif_neigh;
+	rcu_assign_pointer(softif_neigh_vid->softif_neigh, new_neigh);
+
+	if ((curr_neigh) && (!new_neigh))
+		bat_dbg(DBG_ROUTES, bat_priv,
+			"Removing mesh exit point on vid: %d (prev: %pM).\n",
+			vid, curr_neigh->addr);
+	else if ((curr_neigh) && (new_neigh))
+		bat_dbg(DBG_ROUTES, bat_priv,
+			"Changing mesh exit point on vid: %d from %pM "
+			"to %pM.\n", vid, curr_neigh->addr, new_neigh->addr);
+	else if ((!curr_neigh) && (new_neigh))
+		bat_dbg(DBG_ROUTES, bat_priv,
+			"Setting mesh exit point on vid: %d to %pM.\n",
+			vid, new_neigh->addr);
+
+	if (curr_neigh)
+		softif_neigh_free_ref(curr_neigh);
+
+	spin_unlock_bh(&bat_priv->softif_neigh_lock);
+
+out:
+	if (softif_neigh_vid)
+		softif_neigh_vid_free_ref(softif_neigh_vid);
+}
+
+static void softif_neigh_vid_deselect(struct bat_priv *bat_priv,
+				      struct softif_neigh_vid *softif_neigh_vid)
+{
+	struct softif_neigh *curr_neigh;
+	struct softif_neigh *softif_neigh = NULL, *softif_neigh_tmp;
+	struct hard_iface *primary_if = NULL;
+	struct hlist_node *node;
+
+	primary_if = primary_if_get_selected(bat_priv);
+	if (!primary_if)
+		goto out;
+
+	/* find new softif_neigh immediately to avoid temporary loops */
+	rcu_read_lock();
+	curr_neigh = rcu_dereference(softif_neigh_vid->softif_neigh);
+
+	hlist_for_each_entry_rcu(softif_neigh_tmp, node,
+				 &softif_neigh_vid->softif_neigh_list,
+				 list) {
+		if (softif_neigh_tmp == curr_neigh)
+			continue;
+
+		/* we got a neighbor but its mac is 'bigger' than ours  */
+		if (memcmp(primary_if->net_dev->dev_addr,
+			   softif_neigh_tmp->addr, ETH_ALEN) < 0)
+			continue;
+
+		if (!atomic_inc_not_zero(&softif_neigh_tmp->refcount))
+			continue;
+
+		softif_neigh = softif_neigh_tmp;
+		goto unlock;
+	}
+
+unlock:
+	rcu_read_unlock();
+out:
+	softif_neigh_vid_select(bat_priv, softif_neigh, softif_neigh_vid->vid);
+
+	if (primary_if)
+		hardif_free_ref(primary_if);
+	if (softif_neigh)
+		softif_neigh_free_ref(softif_neigh);
+}
+
 int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
 {
 	struct net_device *net_dev = (struct net_device *)seq->private;
 	struct bat_priv *bat_priv = netdev_priv(net_dev);
+	struct softif_neigh_vid *softif_neigh_vid;
 	struct softif_neigh *softif_neigh;
 	struct hard_iface *primary_if;
-	struct hlist_node *node;
+	struct hlist_node *node, *node_tmp;
 	struct softif_neigh *curr_softif_neigh;
-	int ret = 0;
+	int ret = 0, last_seen_secs, last_seen_msecs;
 
 	primary_if = primary_if_get_selected(bat_priv);
 	if (!primary_if) {
@@ -237,17 +353,33 @@ int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
 
 	seq_printf(seq, "Softif neighbor list (%s)\n", net_dev->name);
 
-	curr_softif_neigh = softif_neigh_get_selected(bat_priv);
 	rcu_read_lock();
-	hlist_for_each_entry_rcu(softif_neigh, node,
-				 &bat_priv->softif_neigh_list, list)
-		seq_printf(seq, "%s %pM (vid: %d)\n",
-				curr_softif_neigh == softif_neigh
-				? "=>" : "  ", softif_neigh->addr,
-				softif_neigh->vid);
+	hlist_for_each_entry_rcu(softif_neigh_vid, node,
+				 &bat_priv->softif_neigh_vids, list) {
+		seq_printf(seq, "     %-15s %s on vid: %d\n",
+			   "Originator", "last-seen", softif_neigh_vid->vid);
+
+		curr_softif_neigh = softif_neigh_get_selected(softif_neigh_vid);
+
+		hlist_for_each_entry_rcu(softif_neigh, node_tmp,
+					 &softif_neigh_vid->softif_neigh_list,
+					 list) {
+			last_seen_secs = jiffies_to_msecs(jiffies -
+						softif_neigh->last_seen) / 1000;
+			last_seen_msecs = jiffies_to_msecs(jiffies -
+						softif_neigh->last_seen) % 1000;
+			seq_printf(seq, "%s %pM  %3i.%03is\n",
+				   curr_softif_neigh == softif_neigh
+				   ? "=>" : "  ", softif_neigh->addr,
+				   last_seen_secs, last_seen_msecs);
+		}
+
+		if (curr_softif_neigh)
+			softif_neigh_free_ref(curr_softif_neigh);
+
+		seq_printf(seq, "\n");
+	}
 	rcu_read_unlock();
-	if (curr_softif_neigh)
-		softif_neigh_free_ref(curr_softif_neigh);
 
 out:
 	if (primary_if)
@@ -255,6 +387,70 @@ int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
 	return ret;
 }
 
+void softif_neigh_purge(struct bat_priv *bat_priv)
+{
+	struct softif_neigh *softif_neigh, *curr_softif_neigh;
+	struct softif_neigh_vid *softif_neigh_vid;
+	struct hlist_node *node, *node_tmp, *node_tmp2;
+	char do_deselect;
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(softif_neigh_vid, node,
+				 &bat_priv->softif_neigh_vids, list) {
+		if (!atomic_inc_not_zero(&softif_neigh_vid->refcount))
+			continue;
+
+		curr_softif_neigh = softif_neigh_get_selected(softif_neigh_vid);
+		do_deselect = 0;
+
+		spin_lock_bh(&bat_priv->softif_neigh_lock);
+		hlist_for_each_entry_safe(softif_neigh, node_tmp, node_tmp2,
+					  &softif_neigh_vid->softif_neigh_list,
+					  list) {
+			if ((!time_after(jiffies, softif_neigh->last_seen +
+				msecs_to_jiffies(SOFTIF_NEIGH_TIMEOUT))) &&
+			    (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE))
+				continue;
+
+			if (curr_softif_neigh == softif_neigh) {
+				bat_dbg(DBG_ROUTES, bat_priv,
+					"Current mesh exit point on vid: %d "
+					"'%pM' vanished.\n",
+					softif_neigh_vid->vid,
+					softif_neigh->addr);
+				do_deselect = 1;
+			}
+
+			hlist_del_rcu(&softif_neigh->list);
+			softif_neigh_free_ref(softif_neigh);
+		}
+		spin_unlock_bh(&bat_priv->softif_neigh_lock);
+
+		/* soft_neigh_vid_deselect() needs to acquire the
+		 * softif_neigh_lock */
+		if (do_deselect)
+			softif_neigh_vid_deselect(bat_priv, softif_neigh_vid);
+
+		if (curr_softif_neigh)
+			softif_neigh_free_ref(curr_softif_neigh);
+
+		softif_neigh_vid_free_ref(softif_neigh_vid);
+	}
+	rcu_read_unlock();
+
+	spin_lock_bh(&bat_priv->softif_neigh_vid_lock);
+	hlist_for_each_entry_safe(softif_neigh_vid, node, node_tmp,
+				  &bat_priv->softif_neigh_vids, list) {
+		if (!hlist_empty(&softif_neigh_vid->softif_neigh_list))
+			continue;
+
+		hlist_del_rcu(&softif_neigh_vid->list);
+		softif_neigh_vid_free_ref(softif_neigh_vid);
+	}
+	spin_unlock_bh(&bat_priv->softif_neigh_vid_lock);
+
+}
+
 static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 			       short vid)
 {
@@ -287,10 +483,7 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 	if (!softif_neigh)
 		goto out;
 
-	curr_softif_neigh = softif_neigh_get_selected(bat_priv);
-	if (!curr_softif_neigh)
-		goto out;
-
+	curr_softif_neigh = softif_neigh_vid_get_selected(bat_priv, vid);
 	if (curr_softif_neigh == softif_neigh)
 		goto out;
 
@@ -303,33 +496,16 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 		   softif_neigh->addr, ETH_ALEN) < 0)
 		goto out;
 
-	/* switch to new 'smallest neighbor' */
-	if ((curr_softif_neigh) &&
-	    (memcmp(softif_neigh->addr, curr_softif_neigh->addr,
-							ETH_ALEN) < 0)) {
-		bat_dbg(DBG_ROUTES, bat_priv,
-			"Changing mesh exit point from %pM (vid: %d) "
-			"to %pM (vid: %d).\n",
-			 curr_softif_neigh->addr,
-			 curr_softif_neigh->vid,
-			 softif_neigh->addr, softif_neigh->vid);
-
-		softif_neigh_select(bat_priv, softif_neigh);
-		goto out;
-	}
-
 	/* close own batX device and use softif_neigh as exit node */
-	if ((!curr_softif_neigh) &&
-	    (memcmp(softif_neigh->addr,
-		    primary_if->net_dev->dev_addr, ETH_ALEN) < 0)) {
-		bat_dbg(DBG_ROUTES, bat_priv,
-			"Setting mesh exit point to %pM (vid: %d).\n",
-			softif_neigh->addr, softif_neigh->vid);
-
-		softif_neigh_select(bat_priv, softif_neigh);
+	if (!curr_softif_neigh) {
+		softif_neigh_vid_select(bat_priv, softif_neigh, vid);
 		goto out;
 	}
 
+	/* switch to new 'smallest neighbor' */
+	if (memcmp(softif_neigh->addr, curr_softif_neigh->addr, ETH_ALEN) < 0)
+		softif_neigh_vid_select(bat_priv, softif_neigh, vid);
+
 out:
 	kfree_skb(skb);
 	if (softif_neigh)
@@ -424,8 +600,8 @@ int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	 * if we have a another chosen mesh exit node in range
 	 * it will transport the packets to the mesh
 	 */
-	curr_softif_neigh = softif_neigh_get_selected(bat_priv);
-	if ((curr_softif_neigh) && (curr_softif_neigh->vid == vid))
+	curr_softif_neigh = softif_neigh_vid_get_selected(bat_priv, vid);
+	if (curr_softif_neigh)
 		goto dropped;
 
 	/* TODO: check this for locks */
@@ -533,8 +709,8 @@ void interface_rx(struct net_device *soft_iface,
 	 * if we have a another chosen mesh exit node in range
 	 * it will transport the packets to the non-mesh network
 	 */
-	curr_softif_neigh = softif_neigh_get_selected(bat_priv);
-	if (curr_softif_neigh && (curr_softif_neigh->vid == vid)) {
+	curr_softif_neigh = softif_neigh_vid_get_selected(bat_priv, vid);
+	if (curr_softif_neigh) {
 		skb_push(skb, hdr_size);
 		unicast_packet = (struct unicast_packet *)skb->data;
 
@@ -671,7 +847,6 @@ struct net_device *softif_create(char *name)
 
 	bat_priv->primary_if = NULL;
 	bat_priv->num_ifaces = 0;
-	bat_priv->softif_neigh = NULL;
 
 	ret = sysfs_add_meshif(soft_iface);
 	if (ret < 0)

commit 8e3572cff70ee19a0a1f2e2dde0bca0b7c8b54dc
Author: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
Date:   Mon May 2 00:52:23 2011 -0700

    batman,rcu: convert call_rcu(softif_neigh_free_rcu) to kfree_rcu
    
    The RCU callback softif_neigh_free_rcu() just calls kfree(), so we can
    use kfree_rcu() instead of call_rcu().
    
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Marek Lindner <lindner_marek@yahoo.de>
    Cc: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Acked-by: David S. Miller <davem@davemloft.net>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Acked-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 824e1f6e50f2..04efe022c13b 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -76,18 +76,10 @@ int my_skb_head_push(struct sk_buff *skb, unsigned int len)
 	return 0;
 }
 
-static void softif_neigh_free_rcu(struct rcu_head *rcu)
-{
-	struct softif_neigh *softif_neigh;
-
-	softif_neigh = container_of(rcu, struct softif_neigh, rcu);
-	kfree(softif_neigh);
-}
-
 static void softif_neigh_free_ref(struct softif_neigh *softif_neigh)
 {
 	if (atomic_dec_and_test(&softif_neigh->refcount))
-		call_rcu(&softif_neigh->rcu, softif_neigh_free_rcu);
+		kfree_rcu(softif_neigh, rcu);
 }
 
 void softif_neigh_purge(struct bat_priv *bat_priv)

commit dcfd9cdc1222f14d6180514e533289493a0716fb
Merge: 561578725774 32ae9b221e78
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 2 15:04:46 2011 -0700

    Merge branch 'batman-adv/next' of git://git.open-mesh.org/ecsv/linux-merge

commit 32ae9b221e788413ce68feaae2ca39e406211a0a
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Wed Apr 20 15:40:58 2011 +0200

    batman-adv: Make bat_priv->primary_if an rcu protected pointer
    
    The rcu protected macros rcu_dereference() and rcu_assign_pointer()
    for the bat_priv->primary_if need to be used, as well as spin/rcu locking.
    
    Otherwise we might end up using a primary_if pointer pointing to already
    freed memory.
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 58ce4400d581..ea5e58c252f0 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -215,13 +215,24 @@ int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
 	struct net_device *net_dev = (struct net_device *)seq->private;
 	struct bat_priv *bat_priv = netdev_priv(net_dev);
 	struct softif_neigh *softif_neigh;
+	struct hard_iface *primary_if;
 	struct hlist_node *node;
 	struct softif_neigh *curr_softif_neigh;
+	int ret = 0;
 
-	if (!bat_priv->primary_if) {
-		return seq_printf(seq, "BATMAN mesh %s disabled - "
-			       "please specify interfaces to enable it\n",
-			       net_dev->name);
+	primary_if = primary_if_get_selected(bat_priv);
+	if (!primary_if) {
+		ret = seq_printf(seq, "BATMAN mesh %s disabled - "
+				 "please specify interfaces to enable it\n",
+				 net_dev->name);
+		goto out;
+	}
+
+	if (primary_if->if_status != IF_ACTIVE) {
+		ret = seq_printf(seq, "BATMAN mesh %s "
+				 "disabled - primary interface not active\n",
+				 net_dev->name);
+		goto out;
 	}
 
 	seq_printf(seq, "Softif neighbor list (%s)\n", net_dev->name);
@@ -238,7 +249,10 @@ int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
 	if (curr_softif_neigh)
 		softif_neigh_free_ref(curr_softif_neigh);
 
-	return 0;
+out:
+	if (primary_if)
+		hardif_free_ref(primary_if);
+	return ret;
 }
 
 static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
@@ -247,7 +261,8 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 	struct bat_priv *bat_priv = netdev_priv(dev);
 	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
 	struct batman_packet *batman_packet;
-	struct softif_neigh *softif_neigh;
+	struct softif_neigh *softif_neigh = NULL;
+	struct hard_iface *primary_if = NULL;
 	struct softif_neigh *curr_softif_neigh = NULL;
 
 	if (ntohs(ethhdr->h_proto) == ETH_P_8021Q)
@@ -257,28 +272,34 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 		batman_packet = (struct batman_packet *)(skb->data + ETH_HLEN);
 
 	if (batman_packet->version != COMPAT_VERSION)
-		goto err;
+		goto out;
 
 	if (batman_packet->packet_type != BAT_PACKET)
-		goto err;
+		goto out;
 
 	if (!(batman_packet->flags & PRIMARIES_FIRST_HOP))
-		goto err;
+		goto out;
 
 	if (is_my_mac(batman_packet->orig))
-		goto err;
+		goto out;
 
 	softif_neigh = softif_neigh_get(bat_priv, batman_packet->orig, vid);
-
 	if (!softif_neigh)
-		goto err;
+		goto out;
 
 	curr_softif_neigh = softif_neigh_get_selected(bat_priv);
+	if (!curr_softif_neigh)
+		goto out;
+
 	if (curr_softif_neigh == softif_neigh)
 		goto out;
 
+	primary_if = primary_if_get_selected(bat_priv);
+	if (!primary_if)
+		goto out;
+
 	/* we got a neighbor but its mac is 'bigger' than ours  */
-	if (memcmp(bat_priv->primary_if->net_dev->dev_addr,
+	if (memcmp(primary_if->net_dev->dev_addr,
 		   softif_neigh->addr, ETH_ALEN) < 0)
 		goto out;
 
@@ -300,7 +321,7 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 	/* close own batX device and use softif_neigh as exit node */
 	if ((!curr_softif_neigh) &&
 	    (memcmp(softif_neigh->addr,
-		    bat_priv->primary_if->net_dev->dev_addr, ETH_ALEN) < 0)) {
+		    primary_if->net_dev->dev_addr, ETH_ALEN) < 0)) {
 		bat_dbg(DBG_ROUTES, bat_priv,
 			"Setting mesh exit point to %pM (vid: %d).\n",
 			softif_neigh->addr, softif_neigh->vid);
@@ -310,12 +331,13 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 	}
 
 out:
-	softif_neigh_free_ref(softif_neigh);
-err:
 	kfree_skb(skb);
+	if (softif_neigh)
+		softif_neigh_free_ref(softif_neigh);
 	if (curr_softif_neigh)
 		softif_neigh_free_ref(curr_softif_neigh);
-
+	if (primary_if)
+		hardif_free_ref(primary_if);
 	return;
 }
 
@@ -371,6 +393,7 @@ int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 {
 	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
 	struct bat_priv *bat_priv = netdev_priv(soft_iface);
+	struct hard_iface *primary_if = NULL;
 	struct bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
 	struct softif_neigh *curr_softif_neigh = NULL;
@@ -420,7 +443,8 @@ int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 
 	/* ethernet packet should be broadcasted */
 	if (do_bcast) {
-		if (!bat_priv->primary_if)
+		primary_if = primary_if_get_selected(bat_priv);
+		if (!primary_if)
 			goto dropped;
 
 		if (my_skb_head_push(skb, sizeof(struct bcast_packet)) < 0)
@@ -436,7 +460,7 @@ int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 		/* hw address of first interface is the orig mac because only
 		 * this mac is known throughout the mesh */
 		memcpy(bcast_packet->orig,
-		       bat_priv->primary_if->net_dev->dev_addr, ETH_ALEN);
+		       primary_if->net_dev->dev_addr, ETH_ALEN);
 
 		/* set broadcast sequence number */
 		bcast_packet->seqno =
@@ -466,6 +490,8 @@ int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 end:
 	if (curr_softif_neigh)
 		softif_neigh_free_ref(curr_softif_neigh);
+	if (primary_if)
+		hardif_free_ref(primary_if);
 	return NETDEV_TX_OK;
 }
 

commit 707394972093e2056e1e8cc39be19cf9bcb3e7b3
Author: David Decotigny <decot@google.com>
Date:   Wed Apr 27 18:32:40 2011 +0000

    ethtool: cosmetic: Use ethtool ethtool_cmd_speed API
    
    This updates the network drivers so that they don't access the
    ethtool_cmd::speed field directly, but use ethtool_cmd_speed()
    instead.
    
    For most of the drivers, these changes are purely cosmetic and don't
    fix any problem, such as for those 1GbE/10GbE drivers that indirectly
    call their own ethtool get_settings()/mii_ethtool_gset(). The changes
    are meant to enforce code consistency and provide robustness with
    future larger throughputs, at the expense of a few CPU cycles for each
    ethtool operation.
    
    All drivers compiled with make allyesconfig ion x86_64 have been
    updated.
    
    Tested: make allyesconfig on x86_64 + e1000e/bnx2x work
    Signed-off-by: David Decotigny <decot@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index f4d80ad008c2..eeabbb89172c 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -697,7 +697,7 @@ static int bat_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {
 	cmd->supported = 0;
 	cmd->advertising = 0;
-	cmd->speed = SPEED_10;
+	ethtool_cmd_speed_set(cmd, SPEED_10);
 	cmd->duplex = DUPLEX_FULL;
 	cmd->port = PORT_TP;
 	cmd->phy_address = 0;

commit 97dbee73978497c615a46d324e4f5629b9772f86
Author: Michał Mirosław <mirq-linux@rere.qmqm.pl>
Date:   Tue Apr 19 00:43:20 2011 +0000

    net: batman-adv: remove rx_csum ethtool_ops
    
    Signed-off-by: Michał Mirosław <mirq-linux@rere.qmqm.pl>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 1f6f756bc584..f4d80ad008c2 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -43,8 +43,6 @@ static void bat_get_drvinfo(struct net_device *dev,
 static u32 bat_get_msglevel(struct net_device *dev);
 static void bat_set_msglevel(struct net_device *dev, u32 value);
 static u32 bat_get_link(struct net_device *dev);
-static u32 bat_get_rx_csum(struct net_device *dev);
-static int bat_set_rx_csum(struct net_device *dev, u32 data);
 
 static const struct ethtool_ops bat_ethtool_ops = {
 	.get_settings = bat_get_settings,
@@ -52,8 +50,6 @@ static const struct ethtool_ops bat_ethtool_ops = {
 	.get_msglevel = bat_get_msglevel,
 	.set_msglevel = bat_set_msglevel,
 	.get_link = bat_get_link,
-	.get_rx_csum = bat_get_rx_csum,
-	.set_rx_csum = bat_set_rx_csum
 };
 
 int my_skb_head_push(struct sk_buff *skb, unsigned int len)
@@ -736,12 +732,3 @@ static u32 bat_get_link(struct net_device *dev)
 	return 1;
 }
 
-static u32 bat_get_rx_csum(struct net_device *dev)
-{
-	return 0;
-}
-
-static int bat_set_rx_csum(struct net_device *dev, u32 data)
-{
-	return -EOPNOTSUPP;
-}

commit 9c6bc16577171100e5efab0ea09ebf5884822ed6
Merge: 03746b0a02d2 af20b710479a
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Apr 17 17:37:29 2011 -0700

    Merge branch 'batman-adv/next' of git://git.open-mesh.org/ecsv/linux-merge

commit af20b710479ae662829cf739b521390daa7fcbcb
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 17 20:39:07 2011 +0200

    batman-adv: Set the txqueuelen to zero when creating soft interface
    
    Like other virtual interfaces, e.g. br0, we don't need a transmit
    queue. Packets should only be queued on real interfaces which are
    underneath. In practice this patch makes little difference since the
    virtual interfaces can accept packets as fast as they come, but the
    patch will avoid bufferbloat questions to the mailling lists in the
    future.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Linus Lüssing <linus.luessing@web.de>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index ad6da4c7ddb5..58ce4400d581 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -584,6 +584,7 @@ static void interface_setup(struct net_device *dev)
 	dev->hard_start_xmit = interface_tx;
 #endif
 	dev->destructor = free_netdev;
+	dev->tx_queue_len = 0;
 
 	/**
 	 * can't call min_mtu, because the needed variables

commit ba85fac28005a59e6e03fdb13918fc6f6e69a3ca
Author: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
Date:   Sun Apr 17 20:34:27 2011 +0200

    batman-adv: protect softif_neigh by rcu
    
    Add get/set wrapper functions for softif_neigh and
    use rcu functions to manipulate the pointers.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 9ed26140a269..ad6da4c7ddb5 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -90,10 +90,51 @@ static void softif_neigh_free_ref(struct softif_neigh *softif_neigh)
 		call_rcu(&softif_neigh->rcu, softif_neigh_free_rcu);
 }
 
+static struct softif_neigh *softif_neigh_get_selected(struct bat_priv *bat_priv)
+{
+	struct softif_neigh *neigh;
+
+	rcu_read_lock();
+	neigh = rcu_dereference(bat_priv->softif_neigh);
+
+	if (neigh && !atomic_inc_not_zero(&neigh->refcount))
+		neigh = NULL;
+
+	rcu_read_unlock();
+	return neigh;
+}
+
+static void softif_neigh_select(struct bat_priv *bat_priv,
+				struct softif_neigh *new_neigh)
+{
+	struct softif_neigh *curr_neigh;
+
+	spin_lock_bh(&bat_priv->softif_neigh_lock);
+
+	if (new_neigh && !atomic_inc_not_zero(&new_neigh->refcount))
+		new_neigh = NULL;
+
+	curr_neigh = bat_priv->softif_neigh;
+	rcu_assign_pointer(bat_priv->softif_neigh, new_neigh);
+
+	if (curr_neigh)
+		softif_neigh_free_ref(curr_neigh);
+
+	spin_unlock_bh(&bat_priv->softif_neigh_lock);
+}
+
+static void softif_neigh_deselect(struct bat_priv *bat_priv)
+{
+	softif_neigh_select(bat_priv, NULL);
+}
+
 void softif_neigh_purge(struct bat_priv *bat_priv)
 {
-	struct softif_neigh *softif_neigh, *softif_neigh_tmp;
+	struct softif_neigh *softif_neigh, *curr_softif_neigh;
 	struct hlist_node *node, *node_tmp;
+	char do_deselect = 0;
+
+	curr_softif_neigh = softif_neigh_get_selected(bat_priv);
 
 	spin_lock_bh(&bat_priv->softif_neigh_lock);
 
@@ -105,22 +146,26 @@ void softif_neigh_purge(struct bat_priv *bat_priv)
 		    (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE))
 			continue;
 
-		hlist_del_rcu(&softif_neigh->list);
-
-		if (bat_priv->softif_neigh == softif_neigh) {
+		if (curr_softif_neigh == softif_neigh) {
 			bat_dbg(DBG_ROUTES, bat_priv,
 				 "Current mesh exit point '%pM' vanished "
 				 "(vid: %d).\n",
 				 softif_neigh->addr, softif_neigh->vid);
-			softif_neigh_tmp = bat_priv->softif_neigh;
-			bat_priv->softif_neigh = NULL;
-			softif_neigh_free_ref(softif_neigh_tmp);
+			do_deselect = 1;
 		}
 
+		hlist_del_rcu(&softif_neigh->list);
 		softif_neigh_free_ref(softif_neigh);
 	}
 
 	spin_unlock_bh(&bat_priv->softif_neigh_lock);
+
+	/* soft_neigh_deselect() needs to acquire the softif_neigh_lock */
+	if (do_deselect)
+		softif_neigh_deselect(bat_priv);
+
+	if (curr_softif_neigh)
+		softif_neigh_free_ref(curr_softif_neigh);
 }
 
 static struct softif_neigh *softif_neigh_get(struct bat_priv *bat_priv,
@@ -171,6 +216,7 @@ int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
 	struct bat_priv *bat_priv = netdev_priv(net_dev);
 	struct softif_neigh *softif_neigh;
 	struct hlist_node *node;
+	struct softif_neigh *curr_softif_neigh;
 
 	if (!bat_priv->primary_if) {
 		return seq_printf(seq, "BATMAN mesh %s disabled - "
@@ -180,14 +226,17 @@ int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
 
 	seq_printf(seq, "Softif neighbor list (%s)\n", net_dev->name);
 
+	curr_softif_neigh = softif_neigh_get_selected(bat_priv);
 	rcu_read_lock();
 	hlist_for_each_entry_rcu(softif_neigh, node,
 				 &bat_priv->softif_neigh_list, list)
 		seq_printf(seq, "%s %pM (vid: %d)\n",
-				bat_priv->softif_neigh == softif_neigh
+				curr_softif_neigh == softif_neigh
 				? "=>" : "  ", softif_neigh->addr,
 				softif_neigh->vid);
 	rcu_read_unlock();
+	if (curr_softif_neigh)
+		softif_neigh_free_ref(curr_softif_neigh);
 
 	return 0;
 }
@@ -198,7 +247,8 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 	struct bat_priv *bat_priv = netdev_priv(dev);
 	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
 	struct batman_packet *batman_packet;
-	struct softif_neigh *softif_neigh, *softif_neigh_tmp;
+	struct softif_neigh *softif_neigh;
+	struct softif_neigh *curr_softif_neigh = NULL;
 
 	if (ntohs(ethhdr->h_proto) == ETH_P_8021Q)
 		batman_packet = (struct batman_packet *)
@@ -223,7 +273,8 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 	if (!softif_neigh)
 		goto err;
 
-	if (bat_priv->softif_neigh == softif_neigh)
+	curr_softif_neigh = softif_neigh_get_selected(bat_priv);
+	if (curr_softif_neigh == softif_neigh)
 		goto out;
 
 	/* we got a neighbor but its mac is 'bigger' than ours  */
@@ -232,38 +283,39 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 		goto out;
 
 	/* switch to new 'smallest neighbor' */
-	if ((bat_priv->softif_neigh) &&
-	    (memcmp(softif_neigh->addr, bat_priv->softif_neigh->addr,
+	if ((curr_softif_neigh) &&
+	    (memcmp(softif_neigh->addr, curr_softif_neigh->addr,
 							ETH_ALEN) < 0)) {
 		bat_dbg(DBG_ROUTES, bat_priv,
 			"Changing mesh exit point from %pM (vid: %d) "
 			"to %pM (vid: %d).\n",
-			 bat_priv->softif_neigh->addr,
-			 bat_priv->softif_neigh->vid,
+			 curr_softif_neigh->addr,
+			 curr_softif_neigh->vid,
 			 softif_neigh->addr, softif_neigh->vid);
-		softif_neigh_tmp = bat_priv->softif_neigh;
-		bat_priv->softif_neigh = softif_neigh;
-		softif_neigh_free_ref(softif_neigh_tmp);
-		/* we need to hold the additional reference */
-		goto err;
+
+		softif_neigh_select(bat_priv, softif_neigh);
+		goto out;
 	}
 
 	/* close own batX device and use softif_neigh as exit node */
-	if ((!bat_priv->softif_neigh) &&
+	if ((!curr_softif_neigh) &&
 	    (memcmp(softif_neigh->addr,
 		    bat_priv->primary_if->net_dev->dev_addr, ETH_ALEN) < 0)) {
 		bat_dbg(DBG_ROUTES, bat_priv,
 			"Setting mesh exit point to %pM (vid: %d).\n",
 			softif_neigh->addr, softif_neigh->vid);
-		bat_priv->softif_neigh = softif_neigh;
-		/* we need to hold the additional reference */
-		goto err;
+
+		softif_neigh_select(bat_priv, softif_neigh);
+		goto out;
 	}
 
 out:
 	softif_neigh_free_ref(softif_neigh);
 err:
 	kfree_skb(skb);
+	if (curr_softif_neigh)
+		softif_neigh_free_ref(curr_softif_neigh);
+
 	return;
 }
 
@@ -321,6 +373,7 @@ int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	struct bat_priv *bat_priv = netdev_priv(soft_iface);
 	struct bcast_packet *bcast_packet;
 	struct vlan_ethhdr *vhdr;
+	struct softif_neigh *curr_softif_neigh = NULL;
 	int data_len = skb->len, ret;
 	short vid = -1;
 	bool do_bcast = false;
@@ -348,7 +401,8 @@ int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 	 * if we have a another chosen mesh exit node in range
 	 * it will transport the packets to the mesh
 	 */
-	if ((bat_priv->softif_neigh) && (bat_priv->softif_neigh->vid == vid))
+	curr_softif_neigh = softif_neigh_get_selected(bat_priv);
+	if ((curr_softif_neigh) && (curr_softif_neigh->vid == vid))
 		goto dropped;
 
 	/* TODO: check this for locks */
@@ -410,6 +464,8 @@ int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 dropped_freed:
 	bat_priv->stats.tx_dropped++;
 end:
+	if (curr_softif_neigh)
+		softif_neigh_free_ref(curr_softif_neigh);
 	return NETDEV_TX_OK;
 }
 
@@ -421,6 +477,7 @@ void interface_rx(struct net_device *soft_iface,
 	struct unicast_packet *unicast_packet;
 	struct ethhdr *ethhdr;
 	struct vlan_ethhdr *vhdr;
+	struct softif_neigh *curr_softif_neigh = NULL;
 	short vid = -1;
 	int ret;
 
@@ -450,7 +507,8 @@ void interface_rx(struct net_device *soft_iface,
 	 * if we have a another chosen mesh exit node in range
 	 * it will transport the packets to the non-mesh network
 	 */
-	if ((bat_priv->softif_neigh) && (bat_priv->softif_neigh->vid == vid)) {
+	curr_softif_neigh = softif_neigh_get_selected(bat_priv);
+	if (curr_softif_neigh && (curr_softif_neigh->vid == vid)) {
 		skb_push(skb, hdr_size);
 		unicast_packet = (struct unicast_packet *)skb->data;
 
@@ -461,7 +519,7 @@ void interface_rx(struct net_device *soft_iface,
 		skb_reset_mac_header(skb);
 
 		memcpy(unicast_packet->dest,
-		       bat_priv->softif_neigh->addr, ETH_ALEN);
+		       curr_softif_neigh->addr, ETH_ALEN);
 		ret = route_unicast_packet(skb, recv_if);
 		if (ret == NET_RX_DROP)
 			goto dropped;
@@ -486,11 +544,13 @@ void interface_rx(struct net_device *soft_iface,
 	soft_iface->last_rx = jiffies;
 
 	netif_rx(skb);
-	return;
+	goto out;
 
 dropped:
 	kfree_skb(skb);
 out:
+	if (curr_softif_neigh)
+		softif_neigh_free_ref(curr_softif_neigh);
 	return;
 }
 

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 9ed26140a269..824e1f6e50f2 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -474,7 +474,7 @@ void interface_rx(struct net_device *soft_iface,
 		goto dropped;
 	skb->protocol = eth_type_trans(skb, soft_iface);
 
-	/* should not be neccesary anymore as we use skb_pull_rcsum()
+	/* should not be necessary anymore as we use skb_pull_rcsum()
 	 * TODO: please verify this and remove this TODO
 	 * -- Dec 21st 2009, Simon Wunderlich */
 

commit e44d8fe2b5c27ecc230f886d4cc49fcbd86f87a0
Author: Sven Eckelmann <sven@narfation.org>
Date:   Fri Mar 4 21:36:41 2011 +0000

    batman-adv: Disallow regular interface as mesh device
    
    When trying to associate a net_device with another net_device which
    already exists, batman-adv assumes that this interface is a fully
    initialized batman mesh interface without checking it. The behaviour
    when accessing data behind netdev_priv of a random net_device is
    undefined and potentially dangerous.
    
    Reported-by: Linus Lüssing <linus.luessing@ascom.ch>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 6b514ecee5a2..9ed26140a269 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -622,6 +622,19 @@ void softif_destroy(struct net_device *soft_iface)
 	unregister_netdevice(soft_iface);
 }
 
+int softif_is_valid(struct net_device *net_dev)
+{
+#ifdef HAVE_NET_DEVICE_OPS
+	if (net_dev->netdev_ops->ndo_start_xmit == interface_tx)
+		return 1;
+#else
+	if (net_dev->hard_start_xmit == interface_tx)
+		return 1;
+#endif
+
+	return 0;
+}
+
 /* ethtool */
 static int bat_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
 {

commit 7cefb149a6b0e4f7c5adfa27dcf285b729063848
Author: Linus Lüssing <linus.luessing@ascom.ch>
Date:   Wed Mar 2 17:39:31 2011 +0000

    batman-adv: Remove unused hdr_size variable in route_unicast_packet()
    
    Signed-off-by: Linus Lüssing <linus.luessing@ascom.ch>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 95d1c3f86a66..6b514ecee5a2 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -462,7 +462,7 @@ void interface_rx(struct net_device *soft_iface,
 
 		memcpy(unicast_packet->dest,
 		       bat_priv->softif_neigh->addr, ETH_ALEN);
-		ret = route_unicast_packet(skb, recv_if, hdr_size);
+		ret = route_unicast_packet(skb, recv_if);
 		if (ret == NET_RX_DROP)
 			goto dropped;
 

commit e6c10f433af9c98994c94a10ae862c152fcfb2a9
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Fri Feb 18 12:33:20 2011 +0000

    batman-adv: rename batman_if struct to hard_iface
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index bea2dcf6bef5..95d1c3f86a66 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -414,7 +414,7 @@ int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
 }
 
 void interface_rx(struct net_device *soft_iface,
-		  struct sk_buff *skb, struct batman_if *recv_if,
+		  struct sk_buff *skb, struct hard_iface *recv_if,
 		  int hdr_size)
 {
 	struct bat_priv *bat_priv = netdev_priv(soft_iface);

commit 39901e716275da4e831b40f9e45a1b61d6a776dc
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Fri Feb 18 12:28:08 2011 +0000

    batman-adv: separate ethernet comparing calls from hash functions
    
    Note: The function compare_ether_addr() provided by the Linux kernel
    requires aligned memory.
    
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index c30ccd66786a..bea2dcf6bef5 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -132,7 +132,7 @@ static struct softif_neigh *softif_neigh_get(struct bat_priv *bat_priv,
 	rcu_read_lock();
 	hlist_for_each_entry_rcu(softif_neigh, node,
 				 &bat_priv->softif_neigh_list, list) {
-		if (memcmp(softif_neigh->addr, addr, ETH_ALEN) != 0)
+		if (!compare_eth(softif_neigh->addr, addr))
 			continue;
 
 		if (softif_neigh->vid != vid)

commit 9e0b33c221f1364e4d7562177a918eef8e85317a
Author: Linus Lüssing <linus.luessing@ascom.ch>
Date:   Fri Feb 18 12:20:13 2011 +0000

    batman-adv: Fix possible buffer overflow in softif neigh list output
    
    When printing the soft interface table the number of entries in the
    softif neigh list are first being counted and a fitting buffer
    allocated. After that the softif neigh list gets locked again and
    the buffer printed - which has the following two issues:
    
    For one thing, the softif neigh list might have grown when reacquiring
    the rcu lock, which results in writing outside of the allocated buffer.
    Furthermore 31 Bytes are not enough for printing an entry with a vid
    of more than 2 digits.
    
    The manual buffering is unnecessary, we can safely print to the seq
    directly during the rcu_read_lock().
    
    Signed-off-by: Linus Lüssing <linus.luessing@ascom.ch>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 152beaafae1d..c30ccd66786a 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -171,8 +171,6 @@ int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
 	struct bat_priv *bat_priv = netdev_priv(net_dev);
 	struct softif_neigh *softif_neigh;
 	struct hlist_node *node;
-	size_t buf_size, pos;
-	char *buff;
 
 	if (!bat_priv->primary_if) {
 		return seq_printf(seq, "BATMAN mesh %s disabled - "
@@ -182,33 +180,15 @@ int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
 
 	seq_printf(seq, "Softif neighbor list (%s)\n", net_dev->name);
 
-	buf_size = 1;
-	/* Estimate length for: "   xx:xx:xx:xx:xx:xx\n" */
 	rcu_read_lock();
 	hlist_for_each_entry_rcu(softif_neigh, node,
 				 &bat_priv->softif_neigh_list, list)
-		buf_size += 30;
-	rcu_read_unlock();
-
-	buff = kmalloc(buf_size, GFP_ATOMIC);
-	if (!buff)
-		return -ENOMEM;
-
-	buff[0] = '\0';
-	pos = 0;
-
-	rcu_read_lock();
-	hlist_for_each_entry_rcu(softif_neigh, node,
-				 &bat_priv->softif_neigh_list, list) {
-		pos += snprintf(buff + pos, 31, "%s %pM (vid: %d)\n",
+		seq_printf(seq, "%s %pM (vid: %d)\n",
 				bat_priv->softif_neigh == softif_neigh
 				? "=>" : "  ", softif_neigh->addr,
 				softif_neigh->vid);
-	}
 	rcu_read_unlock();
 
-	seq_printf(seq, "%s", buff);
-	kfree(buff);
 	return 0;
 }
 

commit 7d2b554826195372764910da2f0dcb0d9b869108
Author: Marek Lindner <lindner_marek@yahoo.de>
Date:   Thu Feb 10 14:33:50 2011 +0000

    batman-adv: Correct rcu refcounting for softif_neigh
    
    It might be possible that 2 threads access the same data in the same
    rcu grace period. The first thread calls call_rcu() to decrement the
    refcount and free the data while the second thread increases the
    refcount to use the data. To avoid this race condition all refcount
    operations have to be atomic.
    
    Reported-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: Marek Lindner <lindner_marek@yahoo.de>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 7e37077ed816..152beaafae1d 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -76,20 +76,18 @@ int my_skb_head_push(struct sk_buff *skb, unsigned int len)
 	return 0;
 }
 
-static void softif_neigh_free_ref(struct kref *refcount)
+static void softif_neigh_free_rcu(struct rcu_head *rcu)
 {
 	struct softif_neigh *softif_neigh;
 
-	softif_neigh = container_of(refcount, struct softif_neigh, refcount);
+	softif_neigh = container_of(rcu, struct softif_neigh, rcu);
 	kfree(softif_neigh);
 }
 
-static void softif_neigh_free_rcu(struct rcu_head *rcu)
+static void softif_neigh_free_ref(struct softif_neigh *softif_neigh)
 {
-	struct softif_neigh *softif_neigh;
-
-	softif_neigh = container_of(rcu, struct softif_neigh, rcu);
-	kref_put(&softif_neigh->refcount, softif_neigh_free_ref);
+	if (atomic_dec_and_test(&softif_neigh->refcount))
+		call_rcu(&softif_neigh->rcu, softif_neigh_free_rcu);
 }
 
 void softif_neigh_purge(struct bat_priv *bat_priv)
@@ -116,11 +114,10 @@ void softif_neigh_purge(struct bat_priv *bat_priv)
 				 softif_neigh->addr, softif_neigh->vid);
 			softif_neigh_tmp = bat_priv->softif_neigh;
 			bat_priv->softif_neigh = NULL;
-			kref_put(&softif_neigh_tmp->refcount,
-				 softif_neigh_free_ref);
+			softif_neigh_free_ref(softif_neigh_tmp);
 		}
 
-		call_rcu(&softif_neigh->rcu, softif_neigh_free_rcu);
+		softif_neigh_free_ref(softif_neigh);
 	}
 
 	spin_unlock_bh(&bat_priv->softif_neigh_lock);
@@ -141,8 +138,11 @@ static struct softif_neigh *softif_neigh_get(struct bat_priv *bat_priv,
 		if (softif_neigh->vid != vid)
 			continue;
 
+		if (!atomic_inc_not_zero(&softif_neigh->refcount))
+			continue;
+
 		softif_neigh->last_seen = jiffies;
-		goto found;
+		goto out;
 	}
 
 	softif_neigh = kzalloc(sizeof(struct softif_neigh), GFP_ATOMIC);
@@ -152,15 +152,14 @@ static struct softif_neigh *softif_neigh_get(struct bat_priv *bat_priv,
 	memcpy(softif_neigh->addr, addr, ETH_ALEN);
 	softif_neigh->vid = vid;
 	softif_neigh->last_seen = jiffies;
-	kref_init(&softif_neigh->refcount);
+	/* initialize with 2 - caller decrements counter by one */
+	atomic_set(&softif_neigh->refcount, 2);
 
 	INIT_HLIST_NODE(&softif_neigh->list);
 	spin_lock_bh(&bat_priv->softif_neigh_lock);
 	hlist_add_head_rcu(&softif_neigh->list, &bat_priv->softif_neigh_list);
 	spin_unlock_bh(&bat_priv->softif_neigh_lock);
 
-found:
-	kref_get(&softif_neigh->refcount);
 out:
 	rcu_read_unlock();
 	return softif_neigh;
@@ -264,7 +263,7 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 			 softif_neigh->addr, softif_neigh->vid);
 		softif_neigh_tmp = bat_priv->softif_neigh;
 		bat_priv->softif_neigh = softif_neigh;
-		kref_put(&softif_neigh_tmp->refcount, softif_neigh_free_ref);
+		softif_neigh_free_ref(softif_neigh_tmp);
 		/* we need to hold the additional reference */
 		goto err;
 	}
@@ -282,7 +281,7 @@ static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
 	}
 
 out:
-	kref_put(&softif_neigh->refcount, softif_neigh_free_ref);
+	softif_neigh_free_ref(softif_neigh);
 err:
 	kfree_skb(skb);
 	return;

commit 8d689218568174955129d0f0e9e4370a391b3609
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Mon Feb 14 23:38:18 2011 +0100

    batman-adv: Remove two duplicate includes.
    
    Remove duplicate inclusion of "send.h" and "routing.h" from
    net/batman-adv/soft-interface.c
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index bd088f877e38..7e37077ed816 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -29,14 +29,12 @@
 #include "hash.h"
 #include "gateway_common.h"
 #include "gateway_client.h"
-#include "send.h"
 #include "bat_sysfs.h"
 #include <linux/slab.h>
 #include <linux/ethtool.h>
 #include <linux/etherdevice.h>
 #include <linux/if_vlan.h>
 #include "unicast.h"
-#include "routing.h"
 
 
 static int bat_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);

commit ee1e884194eb19574898ce6d5eaef5e8afdec7f2
Author: Linus Lüssing <linus.luessing@ascom.ch>
Date:   Sun Feb 6 23:08:37 2011 +0000

    batman-adv: Remove duplicate types.h inclusions
    
    types.h is included by main.h, which is included at the beginning of any
    other c-file anyway. Therefore this commit removes those duplicate
    inclussions.
    
    Signed-off-by: Linus Lüssing <linus.luessing@ascom.ch>
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index 145e0f782923..bd088f877e38 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -26,7 +26,6 @@
 #include "send.h"
 #include "bat_debugfs.h"
 #include "translation-table.h"
-#include "types.h"
 #include "hash.h"
 #include "gateway_common.h"
 #include "gateway_client.h"

commit 64afe35398269577ef9809474dd7dc0e5d265176
Author: Sven Eckelmann <sven@narfation.org>
Date:   Thu Jan 27 10:38:15 2011 +0100

    batman-adv: Update copyright years
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
index e89ede192ed0..145e0f782923 100644
--- a/net/batman-adv/soft-interface.c
+++ b/net/batman-adv/soft-interface.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2007-2010 B.A.T.M.A.N. contributors:
+ * Copyright (C) 2007-2011 B.A.T.M.A.N. contributors:
  *
  * Marek Lindner, Simon Wunderlich
  *

commit c6c8fea29769d998d94fcec9b9f14d4b52b349d3
Author: Sven Eckelmann <sven@narfation.org>
Date:   Mon Dec 13 11:19:28 2010 +0000

    net: Add batman-adv meshing protocol
    
    B.A.T.M.A.N. (better approach to mobile ad-hoc networking) is a routing
    protocol for multi-hop ad-hoc mesh networks. The networks may be wired or
    wireless. See http://www.open-mesh.org/ for more information and user space
    tools.
    
    Signed-off-by: Sven Eckelmann <sven@narfation.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c
new file mode 100644
index 000000000000..e89ede192ed0
--- /dev/null
+++ b/net/batman-adv/soft-interface.c
@@ -0,0 +1,697 @@
+/*
+ * Copyright (C) 2007-2010 B.A.T.M.A.N. contributors:
+ *
+ * Marek Lindner, Simon Wunderlich
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of version 2 of the GNU General Public
+ * License as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+ * 02110-1301, USA
+ *
+ */
+
+#include "main.h"
+#include "soft-interface.h"
+#include "hard-interface.h"
+#include "routing.h"
+#include "send.h"
+#include "bat_debugfs.h"
+#include "translation-table.h"
+#include "types.h"
+#include "hash.h"
+#include "gateway_common.h"
+#include "gateway_client.h"
+#include "send.h"
+#include "bat_sysfs.h"
+#include <linux/slab.h>
+#include <linux/ethtool.h>
+#include <linux/etherdevice.h>
+#include <linux/if_vlan.h>
+#include "unicast.h"
+#include "routing.h"
+
+
+static int bat_get_settings(struct net_device *dev, struct ethtool_cmd *cmd);
+static void bat_get_drvinfo(struct net_device *dev,
+			    struct ethtool_drvinfo *info);
+static u32 bat_get_msglevel(struct net_device *dev);
+static void bat_set_msglevel(struct net_device *dev, u32 value);
+static u32 bat_get_link(struct net_device *dev);
+static u32 bat_get_rx_csum(struct net_device *dev);
+static int bat_set_rx_csum(struct net_device *dev, u32 data);
+
+static const struct ethtool_ops bat_ethtool_ops = {
+	.get_settings = bat_get_settings,
+	.get_drvinfo = bat_get_drvinfo,
+	.get_msglevel = bat_get_msglevel,
+	.set_msglevel = bat_set_msglevel,
+	.get_link = bat_get_link,
+	.get_rx_csum = bat_get_rx_csum,
+	.set_rx_csum = bat_set_rx_csum
+};
+
+int my_skb_head_push(struct sk_buff *skb, unsigned int len)
+{
+	int result;
+
+	/**
+	 * TODO: We must check if we can release all references to non-payload
+	 * data using skb_header_release in our skbs to allow skb_cow_header to
+	 * work optimally. This means that those skbs are not allowed to read
+	 * or write any data which is before the current position of skb->data
+	 * after that call and thus allow other skbs with the same data buffer
+	 * to write freely in that area.
+	 */
+	result = skb_cow_head(skb, len);
+	if (result < 0)
+		return result;
+
+	skb_push(skb, len);
+	return 0;
+}
+
+static void softif_neigh_free_ref(struct kref *refcount)
+{
+	struct softif_neigh *softif_neigh;
+
+	softif_neigh = container_of(refcount, struct softif_neigh, refcount);
+	kfree(softif_neigh);
+}
+
+static void softif_neigh_free_rcu(struct rcu_head *rcu)
+{
+	struct softif_neigh *softif_neigh;
+
+	softif_neigh = container_of(rcu, struct softif_neigh, rcu);
+	kref_put(&softif_neigh->refcount, softif_neigh_free_ref);
+}
+
+void softif_neigh_purge(struct bat_priv *bat_priv)
+{
+	struct softif_neigh *softif_neigh, *softif_neigh_tmp;
+	struct hlist_node *node, *node_tmp;
+
+	spin_lock_bh(&bat_priv->softif_neigh_lock);
+
+	hlist_for_each_entry_safe(softif_neigh, node, node_tmp,
+				  &bat_priv->softif_neigh_list, list) {
+
+		if ((!time_after(jiffies, softif_neigh->last_seen +
+				msecs_to_jiffies(SOFTIF_NEIGH_TIMEOUT))) &&
+		    (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE))
+			continue;
+
+		hlist_del_rcu(&softif_neigh->list);
+
+		if (bat_priv->softif_neigh == softif_neigh) {
+			bat_dbg(DBG_ROUTES, bat_priv,
+				 "Current mesh exit point '%pM' vanished "
+				 "(vid: %d).\n",
+				 softif_neigh->addr, softif_neigh->vid);
+			softif_neigh_tmp = bat_priv->softif_neigh;
+			bat_priv->softif_neigh = NULL;
+			kref_put(&softif_neigh_tmp->refcount,
+				 softif_neigh_free_ref);
+		}
+
+		call_rcu(&softif_neigh->rcu, softif_neigh_free_rcu);
+	}
+
+	spin_unlock_bh(&bat_priv->softif_neigh_lock);
+}
+
+static struct softif_neigh *softif_neigh_get(struct bat_priv *bat_priv,
+					     uint8_t *addr, short vid)
+{
+	struct softif_neigh *softif_neigh;
+	struct hlist_node *node;
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(softif_neigh, node,
+				 &bat_priv->softif_neigh_list, list) {
+		if (memcmp(softif_neigh->addr, addr, ETH_ALEN) != 0)
+			continue;
+
+		if (softif_neigh->vid != vid)
+			continue;
+
+		softif_neigh->last_seen = jiffies;
+		goto found;
+	}
+
+	softif_neigh = kzalloc(sizeof(struct softif_neigh), GFP_ATOMIC);
+	if (!softif_neigh)
+		goto out;
+
+	memcpy(softif_neigh->addr, addr, ETH_ALEN);
+	softif_neigh->vid = vid;
+	softif_neigh->last_seen = jiffies;
+	kref_init(&softif_neigh->refcount);
+
+	INIT_HLIST_NODE(&softif_neigh->list);
+	spin_lock_bh(&bat_priv->softif_neigh_lock);
+	hlist_add_head_rcu(&softif_neigh->list, &bat_priv->softif_neigh_list);
+	spin_unlock_bh(&bat_priv->softif_neigh_lock);
+
+found:
+	kref_get(&softif_neigh->refcount);
+out:
+	rcu_read_unlock();
+	return softif_neigh;
+}
+
+int softif_neigh_seq_print_text(struct seq_file *seq, void *offset)
+{
+	struct net_device *net_dev = (struct net_device *)seq->private;
+	struct bat_priv *bat_priv = netdev_priv(net_dev);
+	struct softif_neigh *softif_neigh;
+	struct hlist_node *node;
+	size_t buf_size, pos;
+	char *buff;
+
+	if (!bat_priv->primary_if) {
+		return seq_printf(seq, "BATMAN mesh %s disabled - "
+			       "please specify interfaces to enable it\n",
+			       net_dev->name);
+	}
+
+	seq_printf(seq, "Softif neighbor list (%s)\n", net_dev->name);
+
+	buf_size = 1;
+	/* Estimate length for: "   xx:xx:xx:xx:xx:xx\n" */
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(softif_neigh, node,
+				 &bat_priv->softif_neigh_list, list)
+		buf_size += 30;
+	rcu_read_unlock();
+
+	buff = kmalloc(buf_size, GFP_ATOMIC);
+	if (!buff)
+		return -ENOMEM;
+
+	buff[0] = '\0';
+	pos = 0;
+
+	rcu_read_lock();
+	hlist_for_each_entry_rcu(softif_neigh, node,
+				 &bat_priv->softif_neigh_list, list) {
+		pos += snprintf(buff + pos, 31, "%s %pM (vid: %d)\n",
+				bat_priv->softif_neigh == softif_neigh
+				? "=>" : "  ", softif_neigh->addr,
+				softif_neigh->vid);
+	}
+	rcu_read_unlock();
+
+	seq_printf(seq, "%s", buff);
+	kfree(buff);
+	return 0;
+}
+
+static void softif_batman_recv(struct sk_buff *skb, struct net_device *dev,
+			       short vid)
+{
+	struct bat_priv *bat_priv = netdev_priv(dev);
+	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+	struct batman_packet *batman_packet;
+	struct softif_neigh *softif_neigh, *softif_neigh_tmp;
+
+	if (ntohs(ethhdr->h_proto) == ETH_P_8021Q)
+		batman_packet = (struct batman_packet *)
+					(skb->data + ETH_HLEN + VLAN_HLEN);
+	else
+		batman_packet = (struct batman_packet *)(skb->data + ETH_HLEN);
+
+	if (batman_packet->version != COMPAT_VERSION)
+		goto err;
+
+	if (batman_packet->packet_type != BAT_PACKET)
+		goto err;
+
+	if (!(batman_packet->flags & PRIMARIES_FIRST_HOP))
+		goto err;
+
+	if (is_my_mac(batman_packet->orig))
+		goto err;
+
+	softif_neigh = softif_neigh_get(bat_priv, batman_packet->orig, vid);
+
+	if (!softif_neigh)
+		goto err;
+
+	if (bat_priv->softif_neigh == softif_neigh)
+		goto out;
+
+	/* we got a neighbor but its mac is 'bigger' than ours  */
+	if (memcmp(bat_priv->primary_if->net_dev->dev_addr,
+		   softif_neigh->addr, ETH_ALEN) < 0)
+		goto out;
+
+	/* switch to new 'smallest neighbor' */
+	if ((bat_priv->softif_neigh) &&
+	    (memcmp(softif_neigh->addr, bat_priv->softif_neigh->addr,
+							ETH_ALEN) < 0)) {
+		bat_dbg(DBG_ROUTES, bat_priv,
+			"Changing mesh exit point from %pM (vid: %d) "
+			"to %pM (vid: %d).\n",
+			 bat_priv->softif_neigh->addr,
+			 bat_priv->softif_neigh->vid,
+			 softif_neigh->addr, softif_neigh->vid);
+		softif_neigh_tmp = bat_priv->softif_neigh;
+		bat_priv->softif_neigh = softif_neigh;
+		kref_put(&softif_neigh_tmp->refcount, softif_neigh_free_ref);
+		/* we need to hold the additional reference */
+		goto err;
+	}
+
+	/* close own batX device and use softif_neigh as exit node */
+	if ((!bat_priv->softif_neigh) &&
+	    (memcmp(softif_neigh->addr,
+		    bat_priv->primary_if->net_dev->dev_addr, ETH_ALEN) < 0)) {
+		bat_dbg(DBG_ROUTES, bat_priv,
+			"Setting mesh exit point to %pM (vid: %d).\n",
+			softif_neigh->addr, softif_neigh->vid);
+		bat_priv->softif_neigh = softif_neigh;
+		/* we need to hold the additional reference */
+		goto err;
+	}
+
+out:
+	kref_put(&softif_neigh->refcount, softif_neigh_free_ref);
+err:
+	kfree_skb(skb);
+	return;
+}
+
+static int interface_open(struct net_device *dev)
+{
+	netif_start_queue(dev);
+	return 0;
+}
+
+static int interface_release(struct net_device *dev)
+{
+	netif_stop_queue(dev);
+	return 0;
+}
+
+static struct net_device_stats *interface_stats(struct net_device *dev)
+{
+	struct bat_priv *bat_priv = netdev_priv(dev);
+	return &bat_priv->stats;
+}
+
+static int interface_set_mac_addr(struct net_device *dev, void *p)
+{
+	struct bat_priv *bat_priv = netdev_priv(dev);
+	struct sockaddr *addr = p;
+
+	if (!is_valid_ether_addr(addr->sa_data))
+		return -EADDRNOTAVAIL;
+
+	/* only modify hna-table if it has been initialised before */
+	if (atomic_read(&bat_priv->mesh_state) == MESH_ACTIVE) {
+		hna_local_remove(bat_priv, dev->dev_addr,
+				 "mac address changed");
+		hna_local_add(dev, addr->sa_data);
+	}
+
+	memcpy(dev->dev_addr, addr->sa_data, ETH_ALEN);
+	return 0;
+}
+
+static int interface_change_mtu(struct net_device *dev, int new_mtu)
+{
+	/* check ranges */
+	if ((new_mtu < 68) || (new_mtu > hardif_min_mtu(dev)))
+		return -EINVAL;
+
+	dev->mtu = new_mtu;
+
+	return 0;
+}
+
+int interface_tx(struct sk_buff *skb, struct net_device *soft_iface)
+{
+	struct ethhdr *ethhdr = (struct ethhdr *)skb->data;
+	struct bat_priv *bat_priv = netdev_priv(soft_iface);
+	struct bcast_packet *bcast_packet;
+	struct vlan_ethhdr *vhdr;
+	int data_len = skb->len, ret;
+	short vid = -1;
+	bool do_bcast = false;
+
+	if (atomic_read(&bat_priv->mesh_state) != MESH_ACTIVE)
+		goto dropped;
+
+	soft_iface->trans_start = jiffies;
+
+	switch (ntohs(ethhdr->h_proto)) {
+	case ETH_P_8021Q:
+		vhdr = (struct vlan_ethhdr *)skb->data;
+		vid = ntohs(vhdr->h_vlan_TCI) & VLAN_VID_MASK;
+
+		if (ntohs(vhdr->h_vlan_encapsulated_proto) != ETH_P_BATMAN)
+			break;
+
+		/* fall through */
+	case ETH_P_BATMAN:
+		softif_batman_recv(skb, soft_iface, vid);
+		goto end;
+	}
+
+	/**
+	 * if we have a another chosen mesh exit node in range
+	 * it will transport the packets to the mesh
+	 */
+	if ((bat_priv->softif_neigh) && (bat_priv->softif_neigh->vid == vid))
+		goto dropped;
+
+	/* TODO: check this for locks */
+	hna_local_add(soft_iface, ethhdr->h_source);
+
+	if (is_multicast_ether_addr(ethhdr->h_dest)) {
+		ret = gw_is_target(bat_priv, skb);
+
+		if (ret < 0)
+			goto dropped;
+
+		if (ret == 0)
+			do_bcast = true;
+	}
+
+	/* ethernet packet should be broadcasted */
+	if (do_bcast) {
+		if (!bat_priv->primary_if)
+			goto dropped;
+
+		if (my_skb_head_push(skb, sizeof(struct bcast_packet)) < 0)
+			goto dropped;
+
+		bcast_packet = (struct bcast_packet *)skb->data;
+		bcast_packet->version = COMPAT_VERSION;
+		bcast_packet->ttl = TTL;
+
+		/* batman packet type: broadcast */
+		bcast_packet->packet_type = BAT_BCAST;
+
+		/* hw address of first interface is the orig mac because only
+		 * this mac is known throughout the mesh */
+		memcpy(bcast_packet->orig,
+		       bat_priv->primary_if->net_dev->dev_addr, ETH_ALEN);
+
+		/* set broadcast sequence number */
+		bcast_packet->seqno =
+			htonl(atomic_inc_return(&bat_priv->bcast_seqno));
+
+		add_bcast_packet_to_list(bat_priv, skb);
+
+		/* a copy is stored in the bcast list, therefore removing
+		 * the original skb. */
+		kfree_skb(skb);
+
+	/* unicast packet */
+	} else {
+		ret = unicast_send_skb(skb, bat_priv);
+		if (ret != 0)
+			goto dropped_freed;
+	}
+
+	bat_priv->stats.tx_packets++;
+	bat_priv->stats.tx_bytes += data_len;
+	goto end;
+
+dropped:
+	kfree_skb(skb);
+dropped_freed:
+	bat_priv->stats.tx_dropped++;
+end:
+	return NETDEV_TX_OK;
+}
+
+void interface_rx(struct net_device *soft_iface,
+		  struct sk_buff *skb, struct batman_if *recv_if,
+		  int hdr_size)
+{
+	struct bat_priv *bat_priv = netdev_priv(soft_iface);
+	struct unicast_packet *unicast_packet;
+	struct ethhdr *ethhdr;
+	struct vlan_ethhdr *vhdr;
+	short vid = -1;
+	int ret;
+
+	/* check if enough space is available for pulling, and pull */
+	if (!pskb_may_pull(skb, hdr_size))
+		goto dropped;
+
+	skb_pull_rcsum(skb, hdr_size);
+	skb_reset_mac_header(skb);
+
+	ethhdr = (struct ethhdr *)skb_mac_header(skb);
+
+	switch (ntohs(ethhdr->h_proto)) {
+	case ETH_P_8021Q:
+		vhdr = (struct vlan_ethhdr *)skb->data;
+		vid = ntohs(vhdr->h_vlan_TCI) & VLAN_VID_MASK;
+
+		if (ntohs(vhdr->h_vlan_encapsulated_proto) != ETH_P_BATMAN)
+			break;
+
+		/* fall through */
+	case ETH_P_BATMAN:
+		goto dropped;
+	}
+
+	/**
+	 * if we have a another chosen mesh exit node in range
+	 * it will transport the packets to the non-mesh network
+	 */
+	if ((bat_priv->softif_neigh) && (bat_priv->softif_neigh->vid == vid)) {
+		skb_push(skb, hdr_size);
+		unicast_packet = (struct unicast_packet *)skb->data;
+
+		if ((unicast_packet->packet_type != BAT_UNICAST) &&
+		    (unicast_packet->packet_type != BAT_UNICAST_FRAG))
+			goto dropped;
+
+		skb_reset_mac_header(skb);
+
+		memcpy(unicast_packet->dest,
+		       bat_priv->softif_neigh->addr, ETH_ALEN);
+		ret = route_unicast_packet(skb, recv_if, hdr_size);
+		if (ret == NET_RX_DROP)
+			goto dropped;
+
+		goto out;
+	}
+
+	/* skb->dev & skb->pkt_type are set here */
+	if (unlikely(!pskb_may_pull(skb, ETH_HLEN)))
+		goto dropped;
+	skb->protocol = eth_type_trans(skb, soft_iface);
+
+	/* should not be neccesary anymore as we use skb_pull_rcsum()
+	 * TODO: please verify this and remove this TODO
+	 * -- Dec 21st 2009, Simon Wunderlich */
+
+/*	skb->ip_summed = CHECKSUM_UNNECESSARY;*/
+
+	bat_priv->stats.rx_packets++;
+	bat_priv->stats.rx_bytes += skb->len + sizeof(struct ethhdr);
+
+	soft_iface->last_rx = jiffies;
+
+	netif_rx(skb);
+	return;
+
+dropped:
+	kfree_skb(skb);
+out:
+	return;
+}
+
+#ifdef HAVE_NET_DEVICE_OPS
+static const struct net_device_ops bat_netdev_ops = {
+	.ndo_open = interface_open,
+	.ndo_stop = interface_release,
+	.ndo_get_stats = interface_stats,
+	.ndo_set_mac_address = interface_set_mac_addr,
+	.ndo_change_mtu = interface_change_mtu,
+	.ndo_start_xmit = interface_tx,
+	.ndo_validate_addr = eth_validate_addr
+};
+#endif
+
+static void interface_setup(struct net_device *dev)
+{
+	struct bat_priv *priv = netdev_priv(dev);
+	char dev_addr[ETH_ALEN];
+
+	ether_setup(dev);
+
+#ifdef HAVE_NET_DEVICE_OPS
+	dev->netdev_ops = &bat_netdev_ops;
+#else
+	dev->open = interface_open;
+	dev->stop = interface_release;
+	dev->get_stats = interface_stats;
+	dev->set_mac_address = interface_set_mac_addr;
+	dev->change_mtu = interface_change_mtu;
+	dev->hard_start_xmit = interface_tx;
+#endif
+	dev->destructor = free_netdev;
+
+	/**
+	 * can't call min_mtu, because the needed variables
+	 * have not been initialized yet
+	 */
+	dev->mtu = ETH_DATA_LEN;
+	dev->hard_header_len = BAT_HEADER_LEN; /* reserve more space in the
+						* skbuff for our header */
+
+	/* generate random address */
+	random_ether_addr(dev_addr);
+	memcpy(dev->dev_addr, dev_addr, ETH_ALEN);
+
+	SET_ETHTOOL_OPS(dev, &bat_ethtool_ops);
+
+	memset(priv, 0, sizeof(struct bat_priv));
+}
+
+struct net_device *softif_create(char *name)
+{
+	struct net_device *soft_iface;
+	struct bat_priv *bat_priv;
+	int ret;
+
+	soft_iface = alloc_netdev(sizeof(struct bat_priv) , name,
+				   interface_setup);
+
+	if (!soft_iface) {
+		pr_err("Unable to allocate the batman interface: %s\n", name);
+		goto out;
+	}
+
+	ret = register_netdev(soft_iface);
+	if (ret < 0) {
+		pr_err("Unable to register the batman interface '%s': %i\n",
+		       name, ret);
+		goto free_soft_iface;
+	}
+
+	bat_priv = netdev_priv(soft_iface);
+
+	atomic_set(&bat_priv->aggregated_ogms, 1);
+	atomic_set(&bat_priv->bonding, 0);
+	atomic_set(&bat_priv->vis_mode, VIS_TYPE_CLIENT_UPDATE);
+	atomic_set(&bat_priv->gw_mode, GW_MODE_OFF);
+	atomic_set(&bat_priv->gw_sel_class, 20);
+	atomic_set(&bat_priv->gw_bandwidth, 41);
+	atomic_set(&bat_priv->orig_interval, 1000);
+	atomic_set(&bat_priv->hop_penalty, 10);
+	atomic_set(&bat_priv->log_level, 0);
+	atomic_set(&bat_priv->fragmentation, 1);
+	atomic_set(&bat_priv->bcast_queue_left, BCAST_QUEUE_LEN);
+	atomic_set(&bat_priv->batman_queue_left, BATMAN_QUEUE_LEN);
+
+	atomic_set(&bat_priv->mesh_state, MESH_INACTIVE);
+	atomic_set(&bat_priv->bcast_seqno, 1);
+	atomic_set(&bat_priv->hna_local_changed, 0);
+
+	bat_priv->primary_if = NULL;
+	bat_priv->num_ifaces = 0;
+	bat_priv->softif_neigh = NULL;
+
+	ret = sysfs_add_meshif(soft_iface);
+	if (ret < 0)
+		goto unreg_soft_iface;
+
+	ret = debugfs_add_meshif(soft_iface);
+	if (ret < 0)
+		goto unreg_sysfs;
+
+	ret = mesh_init(soft_iface);
+	if (ret < 0)
+		goto unreg_debugfs;
+
+	return soft_iface;
+
+unreg_debugfs:
+	debugfs_del_meshif(soft_iface);
+unreg_sysfs:
+	sysfs_del_meshif(soft_iface);
+unreg_soft_iface:
+	unregister_netdev(soft_iface);
+	return NULL;
+
+free_soft_iface:
+	free_netdev(soft_iface);
+out:
+	return NULL;
+}
+
+void softif_destroy(struct net_device *soft_iface)
+{
+	debugfs_del_meshif(soft_iface);
+	sysfs_del_meshif(soft_iface);
+	mesh_free(soft_iface);
+	unregister_netdevice(soft_iface);
+}
+
+/* ethtool */
+static int bat_get_settings(struct net_device *dev, struct ethtool_cmd *cmd)
+{
+	cmd->supported = 0;
+	cmd->advertising = 0;
+	cmd->speed = SPEED_10;
+	cmd->duplex = DUPLEX_FULL;
+	cmd->port = PORT_TP;
+	cmd->phy_address = 0;
+	cmd->transceiver = XCVR_INTERNAL;
+	cmd->autoneg = AUTONEG_DISABLE;
+	cmd->maxtxpkt = 0;
+	cmd->maxrxpkt = 0;
+
+	return 0;
+}
+
+static void bat_get_drvinfo(struct net_device *dev,
+			    struct ethtool_drvinfo *info)
+{
+	strcpy(info->driver, "B.A.T.M.A.N. advanced");
+	strcpy(info->version, SOURCE_VERSION);
+	strcpy(info->fw_version, "N/A");
+	strcpy(info->bus_info, "batman");
+}
+
+static u32 bat_get_msglevel(struct net_device *dev)
+{
+	return -EOPNOTSUPP;
+}
+
+static void bat_set_msglevel(struct net_device *dev, u32 value)
+{
+}
+
+static u32 bat_get_link(struct net_device *dev)
+{
+	return 1;
+}
+
+static u32 bat_get_rx_csum(struct net_device *dev)
+{
+	return 0;
+}
+
+static int bat_set_rx_csum(struct net_device *dev, u32 data)
+{
+	return -EOPNOTSUPP;
+}
