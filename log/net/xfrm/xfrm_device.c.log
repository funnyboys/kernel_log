commit 94579ac3f6d0820adc83b5dc5358ead0158101e9
Author: Huy Nguyen <huyn@mellanox.com>
Date:   Mon Jun 1 16:39:37 2020 -0500

    xfrm: Fix double ESP trailer insertion in IPsec crypto offload.
    
    During IPsec performance testing, we see bad ICMP checksum. The error packet
    has duplicated ESP trailer due to double validate_xmit_xfrm calls. The first call
    is from ip_output, but the packet cannot be sent because
    netif_xmit_frozen_or_stopped is true and the packet gets dev_requeue_skb. The second
    call is from NET_TX softirq. However after the first call, the packet already
    has the ESP trailer.
    
    Fix by marking the skb with XFRM_XMIT bit after the packet is handled by
    validate_xmit_xfrm to avoid duplicate ESP trailer insertion.
    
    Fixes: f6e27114a60a ("net: Add a xfrm validate function to validate_xmit_skb")
    Signed-off-by: Huy Nguyen <huyn@mellanox.com>
    Reviewed-by: Boris Pismenny <borisp@mellanox.com>
    Reviewed-by: Raed Salem <raeds@mellanox.com>
    Reviewed-by: Saeed Mahameed <saeedm@mellanox.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index f50d1f97cf8e..626096bd0d29 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -108,7 +108,7 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 	struct xfrm_offload *xo = xfrm_offload(skb);
 	struct sec_path *sp;
 
-	if (!xo)
+	if (!xo || (xo->flags & XFRM_XMIT))
 		return skb;
 
 	if (!(features & NETIF_F_HW_ESP))
@@ -129,6 +129,8 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 		return skb;
 	}
 
+	xo->flags |= XFRM_XMIT;
+
 	if (skb_is_gso(skb)) {
 		struct net_device *dev = skb->dev;
 

commit 06a0afcfe2f551ff755849ea2549b0d8409fd9a0
Author: Xin Long <lucien.xin@gmail.com>
Date:   Fri Apr 10 17:06:31 2020 +0800

    xfrm: do pskb_pull properly in __xfrm_transport_prep
    
    For transport mode, when ipv6 nexthdr is set, the packet format might
    be like:
    
        ----------------------------------------------------
        |        | dest |     |     |      |  ESP    | ESP |
        | IP6 hdr| opts.| ESP | TCP | Data | Trailer | ICV |
        ----------------------------------------------------
    
    and in __xfrm_transport_prep():
    
      pskb_pull(skb, skb->mac_len + sizeof(ip6hdr) + x->props.header_len);
    
    it will pull the data pointer to the wrong position, as it missed the
    nexthdrs/dest opts.
    
    This patch is to fix it by using:
    
      pskb_pull(skb, skb_transport_offset(skb) + x->props.header_len);
    
    as we can be sure transport_header points to ESP header at that moment.
    
    It also fixes a panic when packets with ipv6 nexthdr are sent over
    esp6 transport mode:
    
      [  100.473845] kernel BUG at net/core/skbuff.c:4325!
      [  100.478517] RIP: 0010:__skb_to_sgvec+0x252/0x260
      [  100.494355] Call Trace:
      [  100.494829]  skb_to_sgvec+0x11/0x40
      [  100.495492]  esp6_output_tail+0x12e/0x550 [esp6]
      [  100.496358]  esp6_xmit+0x1d5/0x260 [esp6_offload]
      [  100.498029]  validate_xmit_xfrm+0x22f/0x2e0
      [  100.499604]  __dev_queue_xmit+0x589/0x910
      [  100.502928]  ip6_finish_output2+0x2a5/0x5a0
      [  100.503718]  ip6_output+0x6c/0x120
      [  100.505198]  xfrm_output_resume+0x4bf/0x530
      [  100.508683]  xfrm6_output+0x3a/0xc0
      [  100.513446]  inet6_csk_xmit+0xa1/0xf0
      [  100.517335]  tcp_sendmsg+0x27/0x40
      [  100.517977]  sock_sendmsg+0x3e/0x60
      [  100.518648]  __sys_sendto+0xee/0x160
    
    Fixes: c35fe4106b92 ("xfrm: Add mode handlers for IPsec on layer 2")
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 6cc7f7f1dd68..f50d1f97cf8e 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -25,12 +25,10 @@ static void __xfrm_transport_prep(struct xfrm_state *x, struct sk_buff *skb,
 	struct xfrm_offload *xo = xfrm_offload(skb);
 
 	skb_reset_mac_len(skb);
-	pskb_pull(skb, skb->mac_len + hsize + x->props.header_len);
-
-	if (xo->flags & XFRM_GSO_SEGMENT) {
-		skb_reset_transport_header(skb);
+	if (xo->flags & XFRM_GSO_SEGMENT)
 		skb->transport_header -= x->props.header_len;
-	}
+
+	pskb_pull(skb, skb_transport_offset(skb) + x->props.header_len);
 }
 
 static void __xfrm_mode_tunnel_prep(struct xfrm_state *x, struct sk_buff *skb,

commit acc086bfb957542be49a8165eb794bc74f6cb51b
Merge: ee91a83e0849 308491755f36
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Mar 30 10:59:20 2020 -0700

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec-next
    
    Steffen Klassert says:
    
    ====================
    pull request (net-next): ipsec-next 2020-03-28
    
    1) Use kmem_cache_zalloc() instead of kmem_cache_alloc()
       in xfrm_state_alloc(). From Huang Zijiang.
    
    2) esp_output_fill_trailer() is the same in IPv4 and IPv6,
       so share this function to avoide code duplcation.
       From Raed Salem.
    
    3) Add offload support for esp beet mode.
       From Xin Long.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 308491755f36c461ee67290af159fdba6be0169d
Author: Xin Long <lucien.xin@gmail.com>
Date:   Thu Mar 26 17:02:31 2020 +0800

    xfrm: add prep for esp beet mode offload
    
    Like __xfrm_transport/mode_tunnel_prep(), this patch is to add
    __xfrm_mode_beet_prep() to fix the transport_header for gso
    segments, and reset skb mac_len, and pull skb data to the
    proto inside esp.
    
    This patch also fixes a panic, reported by ltp:
    
      # modprobe esp4_offload
      # runltp -f net_stress.ipsec_tcp
    
      [ 2452.780511] kernel BUG at net/core/skbuff.c:109!
      [ 2452.799851] Call Trace:
      [ 2452.800298]  <IRQ>
      [ 2452.800705]  skb_push.cold.98+0x14/0x20
      [ 2452.801396]  esp_xmit+0x17b/0x270 [esp4_offload]
      [ 2452.802799]  validate_xmit_xfrm+0x22f/0x2e0
      [ 2452.804285]  __dev_queue_xmit+0x589/0x910
      [ 2452.806264]  __neigh_update+0x3d7/0xa50
      [ 2452.806958]  arp_process+0x259/0x810
      [ 2452.807589]  arp_rcv+0x18a/0x1c
    
    It was caused by the skb going to esp_xmit with a wrong transport
    header.
    
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 50f567a88f45..fa2a506c8163 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -46,6 +46,25 @@ static void __xfrm_mode_tunnel_prep(struct xfrm_state *x, struct sk_buff *skb,
 	pskb_pull(skb, skb->mac_len + x->props.header_len);
 }
 
+static void __xfrm_mode_beet_prep(struct xfrm_state *x, struct sk_buff *skb,
+				  unsigned int hsize)
+{
+	struct xfrm_offload *xo = xfrm_offload(skb);
+	int phlen = 0;
+
+	if (xo->flags & XFRM_GSO_SEGMENT)
+		skb->transport_header = skb->network_header + hsize;
+
+	skb_reset_mac_len(skb);
+	if (x->sel.family != AF_INET6) {
+		phlen = IPV4_BEET_PHMAXLEN;
+		if (x->outer_mode.family == AF_INET6)
+			phlen += sizeof(struct ipv6hdr) - sizeof(struct iphdr);
+	}
+
+	pskb_pull(skb, skb->mac_len + hsize + (x->props.header_len - phlen));
+}
+
 /* Adjust pointers into the packet when IPsec is done at layer2 */
 static void xfrm_outer_mode_prep(struct xfrm_state *x, struct sk_buff *skb)
 {
@@ -66,9 +85,16 @@ static void xfrm_outer_mode_prep(struct xfrm_state *x, struct sk_buff *skb)
 			return __xfrm_transport_prep(x, skb,
 						     sizeof(struct ipv6hdr));
 		break;
+	case XFRM_MODE_BEET:
+		if (x->outer_mode.family == AF_INET)
+			return __xfrm_mode_beet_prep(x, skb,
+						     sizeof(struct iphdr));
+		if (x->outer_mode.family == AF_INET6)
+			return __xfrm_mode_beet_prep(x, skb,
+						     sizeof(struct ipv6hdr));
+		break;
 	case XFRM_MODE_ROUTEOPTIMIZATION:
 	case XFRM_MODE_IN_TRIGGER:
-	case XFRM_MODE_BEET:
 		break;
 	}
 }

commit d1d17a359ce6901545c075d7401c10179d9cedfd
Author: Xin Long <lucien.xin@gmail.com>
Date:   Wed Mar 4 16:51:42 2020 +0800

    esp: remove the skb from the chain when it's enqueued in cryptd_wq
    
    Xiumei found a panic in esp offload:
    
      BUG: unable to handle kernel NULL pointer dereference at 0000000000000020
      RIP: 0010:esp_output_done+0x101/0x160 [esp4]
      Call Trace:
       ? esp_output+0x180/0x180 [esp4]
       cryptd_aead_crypt+0x4c/0x90
       cryptd_queue_worker+0x6e/0xa0
       process_one_work+0x1a7/0x3b0
       worker_thread+0x30/0x390
       ? create_worker+0x1a0/0x1a0
       kthread+0x112/0x130
       ? kthread_flush_work_fn+0x10/0x10
       ret_from_fork+0x35/0x40
    
    It was caused by that skb secpath is used in esp_output_done() after it's
    been released elsewhere.
    
    The tx path for esp offload is:
    
      __dev_queue_xmit()->
        validate_xmit_skb_list()->
          validate_xmit_xfrm()->
            esp_xmit()->
              esp_output_tail()->
                aead_request_set_callback(esp_output_done) <--[1]
                crypto_aead_encrypt()  <--[2]
    
    In [1], .callback is set, and in [2] it will trigger the worker schedule,
    later on a kernel thread will call .callback(esp_output_done), as the call
    trace shows.
    
    But in validate_xmit_xfrm():
    
      skb_list_walk_safe(skb, skb2, nskb) {
        ...
        err = x->type_offload->xmit(x, skb2, esp_features);  [esp_xmit]
        ...
      }
    
    When the err is -EINPROGRESS, which means this skb2 will be enqueued and
    later gets encrypted and sent out by .callback later in a kernel thread,
    skb2 should be removed fromt skb chain. Otherwise, it will get processed
    again outside validate_xmit_xfrm(), which could release skb secpath, and
    cause the panic above.
    
    This patch is to remove the skb from the chain when it's enqueued in
    cryptd_wq. While at it, remove the unnecessary 'if (!skb)' check.
    
    Fixes: 3dca3f38cfb8 ("xfrm: Separate ESP handling from segmentation for GRO packets.")
    Reported-by: Xiumei Mu <xmu@redhat.com>
    Signed-off-by: Xin Long <lucien.xin@gmail.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 3231ec628544..e2db468cf50e 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -78,8 +78,8 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 	int err;
 	unsigned long flags;
 	struct xfrm_state *x;
-	struct sk_buff *skb2, *nskb;
 	struct softnet_data *sd;
+	struct sk_buff *skb2, *nskb, *pskb = NULL;
 	netdev_features_t esp_features = features;
 	struct xfrm_offload *xo = xfrm_offload(skb);
 	struct sec_path *sp;
@@ -168,14 +168,14 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 		} else {
 			if (skb == skb2)
 				skb = nskb;
-
-			if (!skb)
-				return NULL;
+			else
+				pskb->next = nskb;
 
 			continue;
 		}
 
 		skb_push(skb2, skb2->data - skb_mac_header(skb2));
+		pskb = skb2;
 	}
 
 	return skb;

commit 03891f820c2117b19e80b370281eb924a09cf79f
Author: Raed Salem <raeds@mellanox.com>
Date:   Sun Feb 2 13:19:34 2020 +0200

    xfrm: handle NETDEV_UNREGISTER for xfrm device
    
    This patch to handle the asynchronous unregister
    device event so the device IPsec offload resources
    could be cleanly released.
    
    Fixes: e4db5b61c572 ("xfrm: policy: remove pcpu policy cache")
    Signed-off-by: Raed Salem <raeds@mellanox.com>
    Reviewed-by: Boris Pismenny <borisp@mellanox.com>
    Reviewed-by: Saeed Mahameed <saeedm@mellanox.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 50f567a88f45..3231ec628544 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -383,6 +383,7 @@ static int xfrm_dev_event(struct notifier_block *this, unsigned long event, void
 		return xfrm_dev_feat_change(dev);
 
 	case NETDEV_DOWN:
+	case NETDEV_UNREGISTER:
 		return xfrm_dev_down(dev);
 	}
 	return NOTIFY_DONE;

commit c3b18e0d925439043b5887c9a6129ff2ffaf58b0
Author: Jason A. Donenfeld <Jason@zx2c4.com>
Date:   Mon Jan 13 18:42:28 2020 -0500

    net: xfrm: use skb_list_walk_safe helper for gso segments
    
    This is converts xfrm segment iteration to use the new function, keeping
    the flow of the existing code as intact as possible. One case is very
    straight-forward, whereas the other case has some more subtle code that
    likes to peak at ->next and relink skbs. By keeping the variables the
    same as before, we can upgrade this code with minimal surgery required.
    
    Signed-off-by: Jason A. Donenfeld <Jason@zx2c4.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 189ef15acbbc..50f567a88f45 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -78,7 +78,7 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 	int err;
 	unsigned long flags;
 	struct xfrm_state *x;
-	struct sk_buff *skb2;
+	struct sk_buff *skb2, *nskb;
 	struct softnet_data *sd;
 	netdev_features_t esp_features = features;
 	struct xfrm_offload *xo = xfrm_offload(skb);
@@ -148,11 +148,7 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 		return skb;
 	}
 
-	skb2 = skb;
-
-	do {
-		struct sk_buff *nskb = skb2->next;
-
+	skb_list_walk_safe(skb, skb2, nskb) {
 		esp_features |= skb->dev->gso_partial_features;
 		skb_mark_not_on_list(skb2);
 
@@ -176,14 +172,11 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 			if (!skb)
 				return NULL;
 
-			goto skip_push;
+			continue;
 		}
 
 		skb_push(skb2, skb2->data - skb_mac_header(skb2));
-
-skip_push:
-		skb2 = nskb;
-	} while (skb2);
+	}
 
 	return skb;
 }

commit e3b60ffbc16feeb007d07b2b7d1da4304e98c1a3
Merge: c4cde5804d51 c7b37c769d2a
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jul 5 15:01:15 2019 -0700

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec-next
    
    Steffen Klassert says:
    
    ====================
    pull request (net-next): ipsec-next 2019-07-05
    
    1) A lot of work to remove indirections from the xfrm code.
       From Florian Westphal.
    
    2) Fix a WARN_ON with ipv6 that triggered because of a
       forgotten break statement. From Florian Westphal.
    
    3)  Remove xfrmi_init_net, it is not needed.
        From Li RongQing.
    
    Please pull or let me know if there are problems.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit c7b37c769d2a5e711106a3c793140a4f46768e04
Author: Florian Westphal <fw@strlen.de>
Date:   Mon Jun 24 22:04:48 2019 +0200

    xfrm: remove get_mtu indirection from xfrm_type
    
    esp4_get_mtu and esp6_get_mtu are exactly the same, the only difference
    is a single sizeof() (ipv4 vs. ipv6 header).
    
    Merge both into xfrm_state_mtu() and remove the indirection.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index b24cd86a02c3..f10a70388f72 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -275,9 +275,8 @@ bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
 		return false;
 
 	if ((!dev || (dev == xfrm_dst_path(dst)->dev)) &&
-	    (!xdst->child->xfrm && x->type->get_mtu)) {
-		mtu = x->type->get_mtu(x, xdst->child_mtu_cached);
-
+	    (!xdst->child->xfrm)) {
+		mtu = xfrm_state_mtu(x, xdst->child_mtu_cached);
 		if (skb->len <= mtu)
 			goto ok;
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index b24cd86a02c3..ff654306d836 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * xfrm_device.c - IPsec device offloading code.
  *
@@ -5,11 +6,6 @@
  *
  * Author:
  * Steffen Klassert <steffen.klassert@secunet.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 #include <linux/errno.h>

commit c9500d7b7de8ff6ac88ee3e38b782889f1616593
Author: Florian Westphal <fw@strlen.de>
Date:   Fri Mar 29 21:16:32 2019 +0100

    xfrm: store xfrm_mode directly, not its address
    
    This structure is now only 4 bytes, so its more efficient
    to cache a copy rather than its address.
    
    No significant size difference in allmodconfig vmlinux.
    
    With non-modular kernel that has all XFRM options enabled, this
    series reduces vmlinux image size by ~11kb. All xfrm_mode
    indirections are gone and all modes are built-in.
    
    before (ipsec-next master):
        text      data      bss         dec   filename
    21071494   7233140 11104324    39408958   vmlinux.master
    
    after this series:
    21066448   7226772 11104324    39397544   vmlinux.patched
    
    With allmodconfig kernel, the size increase is only 362 bytes,
    even all the xfrm config options removed in this series are
    modular.
    
    before:
        text      data     bss      dec   filename
    15731286   6936912 4046908 26715106   vmlinux.master
    
    after this series:
    15731492   6937068  4046908  26715468 vmlinux
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index a20f376fe71f..b24cd86a02c3 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -53,20 +53,20 @@ static void __xfrm_mode_tunnel_prep(struct xfrm_state *x, struct sk_buff *skb,
 /* Adjust pointers into the packet when IPsec is done at layer2 */
 static void xfrm_outer_mode_prep(struct xfrm_state *x, struct sk_buff *skb)
 {
-	switch (x->outer_mode->encap) {
+	switch (x->outer_mode.encap) {
 	case XFRM_MODE_TUNNEL:
-		if (x->outer_mode->family == AF_INET)
+		if (x->outer_mode.family == AF_INET)
 			return __xfrm_mode_tunnel_prep(x, skb,
 						       sizeof(struct iphdr));
-		if (x->outer_mode->family == AF_INET6)
+		if (x->outer_mode.family == AF_INET6)
 			return __xfrm_mode_tunnel_prep(x, skb,
 						       sizeof(struct ipv6hdr));
 		break;
 	case XFRM_MODE_TRANSPORT:
-		if (x->outer_mode->family == AF_INET)
+		if (x->outer_mode.family == AF_INET)
 			return __xfrm_transport_prep(x, skb,
 						     sizeof(struct iphdr));
-		if (x->outer_mode->family == AF_INET6)
+		if (x->outer_mode.family == AF_INET6)
 			return __xfrm_transport_prep(x, skb,
 						     sizeof(struct ipv6hdr));
 		break;

commit 303c5fab1272888b22088fbdd08cb770205ccb7a
Author: Florian Westphal <fw@strlen.de>
Date:   Fri Mar 29 21:16:26 2019 +0100

    xfrm: remove xmit indirection from xfrm_mode
    
    There are only two versions (tunnel and transport). The ip/ipv6 versions
    are only differ in sizeof(iphdr) vs ipv6hdr.
    
    Place this in the core and use x->outer_mode->encap type to call the
    correct adjustment helper.
    
    Before:
       text   data    bss     dec      filename
    15730311  6937008 4046908 26714227 vmlinux
    
    After:
    15730428  6937008 4046908 26714344 vmlinux
    
    (about 117 byte increase)
    
    v2: use family from x->outer_mode, not inner
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Reviewed-by: Sabrina Dubroca <sd@queasysnail.net>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index e437b60fba51..a20f376fe71f 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -23,6 +23,60 @@
 #include <linux/notifier.h>
 
 #ifdef CONFIG_XFRM_OFFLOAD
+static void __xfrm_transport_prep(struct xfrm_state *x, struct sk_buff *skb,
+				  unsigned int hsize)
+{
+	struct xfrm_offload *xo = xfrm_offload(skb);
+
+	skb_reset_mac_len(skb);
+	pskb_pull(skb, skb->mac_len + hsize + x->props.header_len);
+
+	if (xo->flags & XFRM_GSO_SEGMENT) {
+		skb_reset_transport_header(skb);
+		skb->transport_header -= x->props.header_len;
+	}
+}
+
+static void __xfrm_mode_tunnel_prep(struct xfrm_state *x, struct sk_buff *skb,
+				    unsigned int hsize)
+
+{
+	struct xfrm_offload *xo = xfrm_offload(skb);
+
+	if (xo->flags & XFRM_GSO_SEGMENT)
+		skb->transport_header = skb->network_header + hsize;
+
+	skb_reset_mac_len(skb);
+	pskb_pull(skb, skb->mac_len + x->props.header_len);
+}
+
+/* Adjust pointers into the packet when IPsec is done at layer2 */
+static void xfrm_outer_mode_prep(struct xfrm_state *x, struct sk_buff *skb)
+{
+	switch (x->outer_mode->encap) {
+	case XFRM_MODE_TUNNEL:
+		if (x->outer_mode->family == AF_INET)
+			return __xfrm_mode_tunnel_prep(x, skb,
+						       sizeof(struct iphdr));
+		if (x->outer_mode->family == AF_INET6)
+			return __xfrm_mode_tunnel_prep(x, skb,
+						       sizeof(struct ipv6hdr));
+		break;
+	case XFRM_MODE_TRANSPORT:
+		if (x->outer_mode->family == AF_INET)
+			return __xfrm_transport_prep(x, skb,
+						     sizeof(struct iphdr));
+		if (x->outer_mode->family == AF_INET6)
+			return __xfrm_transport_prep(x, skb,
+						     sizeof(struct ipv6hdr));
+		break;
+	case XFRM_MODE_ROUTEOPTIMIZATION:
+	case XFRM_MODE_IN_TRIGGER:
+	case XFRM_MODE_BEET:
+		break;
+	}
+}
+
 struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t features, bool *again)
 {
 	int err;
@@ -79,7 +133,7 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 
 	if (!skb->next) {
 		esp_features |= skb->dev->gso_partial_features;
-		x->outer_mode->xmit(x, skb);
+		xfrm_outer_mode_prep(x, skb);
 
 		xo->flags |= XFRM_DEV_RESUME;
 
@@ -109,7 +163,7 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 		xo = xfrm_offload(skb2);
 		xo->flags |= XFRM_DEV_RESUME;
 
-		x->outer_mode->xmit(x, skb2);
+		xfrm_outer_mode_prep(x, skb2);
 
 		err = x->type_offload->xmit(x, skb2, esp_features);
 		if (!err) {

commit 65fd2c2afac31a4b46a80150347a1748fa9101cb
Author: Boris Pismenny <borisp@mellanox.com>
Date:   Thu Mar 21 16:41:37 2019 +0200

    xfrm: gso partial offload support
    
    This patch introduces support for gso partial ESP offload.
    
    Signed-off-by: Boris Pismenny <borisp@mellanox.com>
    Signed-off-by: Raed Salem <raeds@mellanox.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 2db1626557c5..e437b60fba51 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -78,6 +78,7 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 	}
 
 	if (!skb->next) {
+		esp_features |= skb->dev->gso_partial_features;
 		x->outer_mode->xmit(x, skb);
 
 		xo->flags |= XFRM_DEV_RESUME;
@@ -101,6 +102,8 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 
 	do {
 		struct sk_buff *nskb = skb2->next;
+
+		esp_features |= skb->dev->gso_partial_features;
 		skb_mark_not_on_list(skb2);
 
 		xo = xfrm_offload(skb2);

commit 4bd97d51a5e602ea1fbdab8c2d653513dea17115
Author: Paolo Abeni <pabeni@redhat.com>
Date:   Wed Mar 20 11:02:04 2019 +0100

    net: dev: rename queue selection helpers.
    
    With the following patches, we are going to use __netdev_pick_tx() in
    many modules. Rename it to netdev_pick_tx(), to make it clear is
    a public API.
    
    Also rename the existing netdev_pick_tx() to netdev_core_pick_tx(),
    to avoid name clashes.
    
    Suggested-by: Eric Dumazet <edumazet@google.com>
    Suggested-by: David Miller <davem@davemloft.net>
    Signed-off-by: Paolo Abeni <pabeni@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index b8736f56e7f7..2db1626557c5 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -247,7 +247,7 @@ void xfrm_dev_resume(struct sk_buff *skb)
 	unsigned long flags;
 
 	rcu_read_lock();
-	txq = netdev_pick_tx(dev, skb, NULL);
+	txq = netdev_core_pick_tx(dev, skb, NULL);
 
 	HARD_TX_LOCK(dev, txq, smp_processor_id());
 	if (!netif_xmit_frozen_or_stopped(txq))

commit 2294be0f11e22b6197d025e5d3ab42888879ec4e
Author: Florian Westphal <fw@strlen.de>
Date:   Tue Dec 18 17:15:20 2018 +0100

    net: use skb_sec_path helper in more places
    
    skb_sec_path gains 'const' qualifier to avoid
    xt_policy.c: 'skb_sec_path' discards 'const' qualifier from pointer target type
    
    same reasoning as previous conversions: Won't need to touch these
    spots anymore when skb->sp is removed.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 144c137886b1..b8736f56e7f7 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -32,6 +32,7 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 	struct softnet_data *sd;
 	netdev_features_t esp_features = features;
 	struct xfrm_offload *xo = xfrm_offload(skb);
+	struct sec_path *sp;
 
 	if (!xo)
 		return skb;
@@ -39,7 +40,8 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 	if (!(features & NETIF_F_HW_ESP))
 		esp_features = features & ~(NETIF_F_SG | NETIF_F_CSUM_MASK);
 
-	x = skb->sp->xvec[skb->sp->len - 1];
+	sp = skb_sec_path(skb);
+	x = sp->xvec[sp->len - 1];
 	if (xo->flags & XFRM_GRO || x->xso.flags & XFRM_OFFLOAD_INBOUND)
 		return skb;
 

commit 2240c12d7d3de741ffbcf22d7a96358a450051ac
Merge: 3bd09b05b068 4a132095dd64
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Oct 1 22:31:17 2018 -0700

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec-next
    
    Steffen Klassert says:
    
    ====================
    pull request (net-next): ipsec-next 2018-10-01
    
    1) Make xfrmi_get_link_net() static to silence a sparse warning.
       From Wei Yongjun.
    
    2) Remove a unused esph pointer definition in esp_input().
       From Haishuang Yan.
    
    3) Allow the NIC driver to quietly refuse xfrm offload
       in case it does not support it, the SA is created
       without offload in this case.
       From Shannon Nelson.
    
    Please pull or let me know if there are problems.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit a8305bff685252e80b7c60f4f5e7dd2e63e38218
Author: David S. Miller <davem@davemloft.net>
Date:   Sun Jul 29 20:42:53 2018 -0700

    net: Add and use skb_mark_not_on_list().
    
    An SKB is not on a list if skb->next is NULL.
    
    Codify this convention into a helper function and use it
    where we are dequeueing an SKB and need to mark it as such.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 5611b7521020..260fbba4f03e 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -99,7 +99,7 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 
 	do {
 		struct sk_buff *nskb = skb2->next;
-		skb2->next = NULL;
+		skb_mark_not_on_list(skb2);
 
 		xo = xfrm_offload(skb2);
 		xo->flags |= XFRM_DEV_RESUME;

commit 4a132095dd64fefabdc5dad1cd9e9809b126e582
Author: Shannon Nelson <shannon.nelson@oracle.com>
Date:   Wed Aug 22 14:38:10 2018 -0700

    xfrm: allow driver to quietly refuse offload
    
    If the "offload" attribute is used to create an IPsec SA
    and the .xdo_dev_state_add() fails, the SA creation fails.
    However, if the "offload" attribute is used on a device that
    doesn't offer it, the attribute is quietly ignored and the SA
    is created without an offload.
    
    Along the same line of that second case, it would be good to
    have a way for the device to refuse to offload an SA without
    failing the whole SA creation.  This patch adds that feature
    by allowing the driver to return -EOPNOTSUPP as a signal that
    the SA may be fine, it just can't be offloaded.
    
    This allows the user a little more flexibility in requesting
    offloads and not needing to know every detail at all times about
    each specific NIC when trying to create SAs.
    
    Signed-off-by: Shannon Nelson <shannon.nelson@oracle.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 5611b7521020..3a1d9d6aefb4 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -192,9 +192,13 @@ int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
 
 	err = dev->xfrmdev_ops->xdo_dev_state_add(x);
 	if (err) {
+		xso->num_exthdrs = 0;
+		xso->flags = 0;
 		xso->dev = NULL;
 		dev_put(dev);
-		return err;
+
+		if (err != -EOPNOTSUPP)
+			return err;
 	}
 
 	return 0;

commit fcb662deeb83bbc6df58b472a3bfe76981a8cc36
Author: Shannon Nelson <shannon.nelson@oracle.com>
Date:   Tue Jun 26 14:19:10 2018 -0700

    xfrm: don't check offload_handle for nonzero
    
    The offload_handle should be an opaque data cookie for the driver
    to use, much like the data cookie for a timer or alarm callback.
    Thus, the XFRM stack should not be checking for non-zero, because
    the driver might use that to store an array reference, which could
    be zero, or some other zero but meaningful value.
    
    We can remove the checks for non-zero because there are plenty
    other attributes also being checked to see if there is an offload
    in place for the SA in question.
    
    Signed-off-by: Shannon Nelson <shannon.nelson@oracle.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 11d56a44e9e8..5611b7521020 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -56,7 +56,7 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 	if (skb_is_gso(skb)) {
 		struct net_device *dev = skb->dev;
 
-		if (unlikely(!x->xso.offload_handle || (x->xso.dev != dev))) {
+		if (unlikely(x->xso.dev != dev)) {
 			struct sk_buff *segs;
 
 			/* Packet got rerouted, fixup features and segment it. */
@@ -211,8 +211,8 @@ bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
 	if (!x->type_offload || x->encap)
 		return false;
 
-	if ((!dev || (x->xso.offload_handle && (dev == xfrm_dst_path(dst)->dev))) &&
-	     (!xdst->child->xfrm && x->type->get_mtu)) {
+	if ((!dev || (dev == xfrm_dst_path(dst)->dev)) &&
+	    (!xdst->child->xfrm && x->type->get_mtu)) {
 		mtu = x->type->get_mtu(x, xdst->child_mtu_cached);
 
 		if (skb->len <= mtu)

commit e4db5b61c572475bbbcf63e3c8a2606bfccf2c9d
Author: Florian Westphal <fw@strlen.de>
Date:   Mon Jun 25 17:26:02 2018 +0200

    xfrm: policy: remove pcpu policy cache
    
    Kristian Evensen says:
      In a project I am involved in, we are running ipsec (Strongswan) on
      different mt7621-based routers. Each router is configured as an
      initiator and has around ~30 tunnels to different responders (running
      on misc. devices). Before the flow cache was removed (kernel 4.9), we
      got a combined throughput of around 70Mbit/s for all tunnels on one
      router. However, we recently switched to kernel 4.14 (4.14.48), and
      the total throughput is somewhere around 57Mbit/s (best-case). I.e., a
      drop of around 20%. Reverting the flow cache removal restores, as
      expected, performance levels to that of kernel 4.9.
    
    When pcpu xdst exists, it has to be validated first before it can be
    used.
    
    A negative hit thus increases cost vs. no-cache.
    
    As number of tunnels increases, hit rate decreases so this pcpu caching
    isn't a viable strategy.
    
    Furthermore, the xdst cache also needs to run with BH off, so when
    removing this the bh disable/enable pairs can be removed too.
    
    Kristian tested a 4.14.y backport of this change and reported
    increased performance:
    
      In our tests, the throughput reduction has been reduced from around -20%
      to -5%. We also see that the overall throughput is independent of the
      number of tunnels, while before the throughput was reduced as the number
      of tunnels increased.
    
    Reported-by: Kristian Evensen <kristian.evensen@gmail.com>
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 16c1230d20fa..11d56a44e9e8 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -307,12 +307,6 @@ static int xfrm_dev_register(struct net_device *dev)
 	return xfrm_api_check(dev);
 }
 
-static int xfrm_dev_unregister(struct net_device *dev)
-{
-	xfrm_policy_cache_flush();
-	return NOTIFY_DONE;
-}
-
 static int xfrm_dev_feat_change(struct net_device *dev)
 {
 	return xfrm_api_check(dev);
@@ -323,7 +317,6 @@ static int xfrm_dev_down(struct net_device *dev)
 	if (dev->features & NETIF_F_HW_ESP)
 		xfrm_dev_state_flush(dev_net(dev), dev, true);
 
-	xfrm_policy_cache_flush();
 	return NOTIFY_DONE;
 }
 
@@ -335,9 +328,6 @@ static int xfrm_dev_event(struct notifier_block *this, unsigned long event, void
 	case NETDEV_REGISTER:
 		return xfrm_dev_register(dev);
 
-	case NETDEV_UNREGISTER:
-		return xfrm_dev_unregister(dev);
-
 	case NETDEV_FEAT_CHANGE:
 		return xfrm_dev_feat_change(dev);
 

commit 9b42c1f179a614e11893ae4619f0304a38f481ae
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Tue Jun 12 12:44:26 2018 +0200

    xfrm: Extend the output_mark to support input direction and masking.
    
    We already support setting an output mark at the xfrm_state,
    unfortunately this does not support the input direction and
    masking the marks that will be applied to the skb. This change
    adds support applying a masked value in both directions.
    
    The existing XFRMA_OUTPUT_MARK number is reused for this purpose
    and as it is now bi-directional, it is renamed to XFRMA_SET_MARK.
    
    An additional XFRMA_SET_MARK_MASK attribute is added for setting the
    mask. If the attribute mask not provided, it is set to 0xffffffff,
    keeping the XFRMA_OUTPUT_MARK existing 'full mask' semantics.
    
    Co-developed-by: Tobias Brunner <tobias@strongswan.org>
    Co-developed-by: Eyal Birger <eyal.birger@gmail.com>
    Co-developed-by: Lorenzo Colitti <lorenzo@google.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>
    Signed-off-by: Tobias Brunner <tobias@strongswan.org>
    Signed-off-by: Eyal Birger <eyal.birger@gmail.com>
    Signed-off-by: Lorenzo Colitti <lorenzo@google.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 175941e15a6e..16c1230d20fa 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -162,7 +162,8 @@ int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
 		}
 
 		dst = __xfrm_dst_lookup(net, 0, 0, saddr, daddr,
-					x->props.family, x->props.output_mark);
+					x->props.family,
+					xfrm_smark_get(0, x));
 		if (IS_ERR(dst))
 			return 0;
 

commit e9a441b6e729e16092fcc18e3962b952a01d1e3c
Author: Kirill Tkhai <ktkhai@virtuozzo.com>
Date:   Thu Mar 29 17:03:25 2018 +0300

    xfrm: Register xfrm_dev_notifier in appropriate place
    
    Currently, driver registers it from pernet_operations::init method,
    and this breaks modularity, because initialization of net namespace
    and netdevice notifiers are orthogonal actions. We don't have
    per-namespace netdevice notifiers; all of them are global for all
    devices in all namespaces.
    
    Signed-off-by: Kirill Tkhai <ktkhai@virtuozzo.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index e87d6c4dd5b6..175941e15a6e 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -350,7 +350,7 @@ static struct notifier_block xfrm_dev_notifier = {
 	.notifier_call	= xfrm_dev_event,
 };
 
-void __net_init xfrm_dev_init(void)
+void __init xfrm_dev_init(void)
 {
 	register_netdevice_notifier(&xfrm_dev_notifier);
 }

commit 779b7931b27bfa80bac46d0115d229259aef580b
Author: Daniel Axtens <dja@axtens.net>
Date:   Thu Mar 1 17:13:37 2018 +1100

    net: rename skb_gso_validate_mtu -> skb_gso_validate_network_len
    
    If you take a GSO skb, and split it into packets, will the network
    length (L3 headers + L4 headers + payload) of those packets be small
    enough to fit within a given MTU?
    
    skb_gso_validate_mtu gives you the answer to that question. However,
    we recently added to add a way to validate the MAC length of a split GSO
    skb (L2+L3+L4+payload), and the names get confusing, so rename
    skb_gso_validate_mtu to skb_gso_validate_network_len
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Reviewed-by: Marcelo Ricardo Leitner <marcelo.leitner@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 8e70291e586a..e87d6c4dd5b6 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -217,7 +217,7 @@ bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
 		if (skb->len <= mtu)
 			goto ok;
 
-		if (skb_is_gso(skb) && skb_gso_validate_mtu(skb, mtu))
+		if (skb_is_gso(skb) && skb_gso_validate_network_len(skb, mtu))
 			goto ok;
 	}
 

commit a81e4affe1789a3d1010f219ad53382a760aa2ea
Merge: 5b09179e7fa2 50bd870a9e5c
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jan 26 10:22:53 2018 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec-next
    
    Steffen Klassert says:
    
    ====================
    pull request (net-next): ipsec-next 2018-01-26
    
    One last patch for this development cycle:
    
    1) Add ESN support for IPSec HW offload.
       From Yossef Efraim.
    
    Please pull or let me know if there are problems.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 955bd1d216c6ce4f40b181cfd369f4116e0627f2
Merge: be1b6e8b5470 5b7d27967dab
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jan 24 23:44:15 2018 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit aa5dd6fa6f5d4bdc82a67e952bba8ad2e98d77e2
Author: Aviad Yehezkel <aviadye@mellanox.com>
Date:   Thu Jan 18 15:41:51 2018 +0200

    xfrm: fix error flow in case of add state fails
    
    If add state fails in case of device offload, netdev refcount
    will be negative since gc task is attempting to dev_free this state.
    This is fixed by putting NULL in state dev field.
    
    Signed-off-by: Aviad Yehezkel <aviadye@mellanox.com>
    Signed-off-by: Boris Pismeny <borisp@mellanox.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 30e5746085b8..ac9477189d1c 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -102,6 +102,7 @@ int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
 
 	err = dev->xfrmdev_ops->xdo_dev_state_add(x);
 	if (err) {
+		xso->dev = NULL;
 		dev_put(dev);
 		return err;
 	}

commit 50bd870a9e5cca9fcf5fb4c130c373643d7d9906
Author: Yossef Efraim <yossefe@mellanox.com>
Date:   Sun Jan 14 11:39:10 2018 +0200

    xfrm: Add ESN support for IPSec HW offload
    
    This patch adds ESN support to IPsec device offload.
    Adding new xfrm device operation to synchronize device ESN.
    
    Signed-off-by: Yossef Efraim <yossefe@mellanox.com>
    Signed-off-by: Shannon Nelson <shannon.nelson@oracle.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 75982506617b..93520106731f 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -147,8 +147,8 @@ int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
 	if (!x->type_offload)
 		return -EINVAL;
 
-	/* We don't yet support UDP encapsulation, TFC padding and ESN. */
-	if (x->encap || x->tfcpad || (x->props.flags & XFRM_STATE_ESN))
+	/* We don't yet support UDP encapsulation and TFC padding. */
+	if (x->encap || x->tfcpad)
 		return -EINVAL;
 
 	dev = dev_get_by_index(net, xuo->ifindex);
@@ -178,6 +178,13 @@ int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
 		return 0;
 	}
 
+	if (x->props.flags & XFRM_STATE_ESN &&
+	    !dev->xfrmdev_ops->xdo_dev_state_advance_esn) {
+		xso->dev = NULL;
+		dev_put(dev);
+		return -EINVAL;
+	}
+
 	xso->dev = dev;
 	xso->num_exthdrs = 1;
 	xso->flags = xuo->flags;

commit 92a2320697f7f07f4ee988077820965a0fbd11d0
Author: Shannon Nelson <shannon.nelson@oracle.com>
Date:   Tue Dec 19 15:35:48 2017 -0800

    xfrm: check for xdo_dev_ops add and delete
    
    This adds a check for the required add and delete functions up front
    at registration time to be sure both are defined.
    
    Since both the features check and the registration check are looking
    at the same things, break out the check for both to call.
    
    Lastly, for some reason the feature check was setting xfrmdev_ops to
    NULL if the NETIF_F_HW_ESP bit was missing, which would probably
    surprise the driver later if the driver turned its NETIF_F_HW_ESP bit
    back on.  We shouldn't be messing with the driver's callback list, so
    we stop doing that with this patch.
    
    Signed-off-by: Shannon Nelson <shannon.nelson@oracle.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 20a96181867a..75982506617b 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -273,17 +273,31 @@ void xfrm_dev_backlog(struct softnet_data *sd)
 }
 #endif
 
-static int xfrm_dev_register(struct net_device *dev)
+static int xfrm_api_check(struct net_device *dev)
 {
-	if ((dev->features & NETIF_F_HW_ESP) && !dev->xfrmdev_ops)
-		return NOTIFY_BAD;
+#ifdef CONFIG_XFRM_OFFLOAD
 	if ((dev->features & NETIF_F_HW_ESP_TX_CSUM) &&
 	    !(dev->features & NETIF_F_HW_ESP))
 		return NOTIFY_BAD;
 
+	if ((dev->features & NETIF_F_HW_ESP) &&
+	    (!(dev->xfrmdev_ops &&
+	       dev->xfrmdev_ops->xdo_dev_state_add &&
+	       dev->xfrmdev_ops->xdo_dev_state_delete)))
+		return NOTIFY_BAD;
+#else
+	if (dev->features & (NETIF_F_HW_ESP | NETIF_F_HW_ESP_TX_CSUM))
+		return NOTIFY_BAD;
+#endif
+
 	return NOTIFY_DONE;
 }
 
+static int xfrm_dev_register(struct net_device *dev)
+{
+	return xfrm_api_check(dev);
+}
+
 static int xfrm_dev_unregister(struct net_device *dev)
 {
 	xfrm_policy_cache_flush();
@@ -292,16 +306,7 @@ static int xfrm_dev_unregister(struct net_device *dev)
 
 static int xfrm_dev_feat_change(struct net_device *dev)
 {
-	if ((dev->features & NETIF_F_HW_ESP) && !dev->xfrmdev_ops)
-		return NOTIFY_BAD;
-	else if (!(dev->features & NETIF_F_HW_ESP))
-		dev->xfrmdev_ops = NULL;
-
-	if ((dev->features & NETIF_F_HW_ESP_TX_CSUM) &&
-	    !(dev->features & NETIF_F_HW_ESP))
-		return NOTIFY_BAD;
-
-	return NOTIFY_DONE;
+	return xfrm_api_check(dev);
 }
 
 static int xfrm_dev_down(struct net_device *dev)

commit 95bff4b580e7e6c895c5ecbc0c9f703635c2972d
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Wed Dec 20 10:41:42 2017 +0100

    xfrm: Allow to use the layer2 IPsec GSO codepath for software crypto.
    
    We now have support for asynchronous crypto operations in the layer 2 TX
    path. This was the missing part to allow the GSO codepath for software
    crypto, so allow this codepath now.
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index fc8ab9f71127..20a96181867a 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -202,8 +202,8 @@ bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
 	if (!x->type_offload || x->encap)
 		return false;
 
-	if ((x->xso.offload_handle && (dev == xfrm_dst_path(dst)->dev)) &&
-	     !xdst->child->xfrm && x->type->get_mtu) {
+	if ((!dev || (x->xso.offload_handle && (dev == xfrm_dst_path(dst)->dev))) &&
+	     (!xdst->child->xfrm && x->type->get_mtu)) {
 		mtu = x->type->get_mtu(x, xdst->child_mtu_cached);
 
 		if (skb->len <= mtu)

commit f53c723902d1ac5f0b0a11d7c9dcbff748dde74e
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Wed Dec 20 10:41:36 2017 +0100

    net: Add asynchronous callbacks for xfrm on layer 2.
    
    This patch implements asynchronous crypto callbacks
    and a backlog handler that can be used when IPsec
    is done at layer 2 in the TX path. It also extends
    the skb validate functions so that we can update
    the driver transmit return codes based on async
    crypto operation or to indicate that we queued the
    packet in a backlog queue.
    
    Joint work with: Aviv Heller <avivh@mellanox.com>
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index a5a7a716c465..fc8ab9f71127 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -23,12 +23,13 @@
 #include <linux/notifier.h>
 
 #ifdef CONFIG_XFRM_OFFLOAD
-struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t features)
+struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t features, bool *again)
 {
 	int err;
-	__u32 seq;
+	unsigned long flags;
 	struct xfrm_state *x;
 	struct sk_buff *skb2;
+	struct softnet_data *sd;
 	netdev_features_t esp_features = features;
 	struct xfrm_offload *xo = xfrm_offload(skb);
 
@@ -42,6 +43,16 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 	if (xo->flags & XFRM_GRO || x->xso.flags & XFRM_OFFLOAD_INBOUND)
 		return skb;
 
+	local_irq_save(flags);
+	sd = this_cpu_ptr(&softnet_data);
+	err = !skb_queue_empty(&sd->xfrm_backlog);
+	local_irq_restore(flags);
+
+	if (err) {
+		*again = true;
+		return skb;
+	}
+
 	if (skb_is_gso(skb)) {
 		struct net_device *dev = skb->dev;
 
@@ -54,23 +65,26 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 
 			segs = skb_gso_segment(skb, esp_features);
 			if (IS_ERR(segs)) {
-				XFRM_INC_STATS(xs_net(x), LINUX_MIB_XFRMOUTSTATEPROTOERROR);
 				kfree_skb(skb);
+				atomic_long_inc(&dev->tx_dropped);
 				return NULL;
 			} else {
 				consume_skb(skb);
 				skb = segs;
 			}
-		} else {
-			return skb;
 		}
 	}
 
 	if (!skb->next) {
 		x->outer_mode->xmit(x, skb);
 
+		xo->flags |= XFRM_DEV_RESUME;
+
 		err = x->type_offload->xmit(x, skb, esp_features);
 		if (err) {
+			if (err == -EINPROGRESS)
+				return NULL;
+
 			XFRM_INC_STATS(xs_net(x), LINUX_MIB_XFRMOUTSTATEPROTOERROR);
 			kfree_skb(skb);
 			return NULL;
@@ -82,36 +96,37 @@ struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t featur
 	}
 
 	skb2 = skb;
-	seq = xo->seq.low;
 
 	do {
 		struct sk_buff *nskb = skb2->next;
+		skb2->next = NULL;
 
 		xo = xfrm_offload(skb2);
-		xo->flags |= XFRM_GSO_SEGMENT;
-		xo->seq.low = seq;
-		xo->seq.hi = xfrm_replay_seqhi(x, seq);
-
-		if(!(features & NETIF_F_HW_ESP))
-			xo->flags |= CRYPTO_FALLBACK;
+		xo->flags |= XFRM_DEV_RESUME;
 
 		x->outer_mode->xmit(x, skb2);
 
 		err = x->type_offload->xmit(x, skb2, esp_features);
-		if (err) {
+		if (!err) {
+			skb2->next = nskb;
+		} else if (err != -EINPROGRESS) {
 			XFRM_INC_STATS(xs_net(x), LINUX_MIB_XFRMOUTSTATEPROTOERROR);
 			skb2->next = nskb;
 			kfree_skb_list(skb2);
 			return NULL;
-		}
+		} else {
+			if (skb == skb2)
+				skb = nskb;
+
+			if (!skb)
+				return NULL;
 
-		if (!skb_is_gso(skb2))
-			seq++;
-		else
-			seq += skb_shinfo(skb2)->gso_segs;
+			goto skip_push;
+		}
 
 		skb_push(skb2, skb2->data - skb_mac_header(skb2));
 
+skip_push:
 		skb2 = nskb;
 	} while (skb2);
 
@@ -207,6 +222,55 @@ bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
 	return true;
 }
 EXPORT_SYMBOL_GPL(xfrm_dev_offload_ok);
+
+void xfrm_dev_resume(struct sk_buff *skb)
+{
+	struct net_device *dev = skb->dev;
+	int ret = NETDEV_TX_BUSY;
+	struct netdev_queue *txq;
+	struct softnet_data *sd;
+	unsigned long flags;
+
+	rcu_read_lock();
+	txq = netdev_pick_tx(dev, skb, NULL);
+
+	HARD_TX_LOCK(dev, txq, smp_processor_id());
+	if (!netif_xmit_frozen_or_stopped(txq))
+		skb = dev_hard_start_xmit(skb, dev, txq, &ret);
+	HARD_TX_UNLOCK(dev, txq);
+
+	if (!dev_xmit_complete(ret)) {
+		local_irq_save(flags);
+		sd = this_cpu_ptr(&softnet_data);
+		skb_queue_tail(&sd->xfrm_backlog, skb);
+		raise_softirq_irqoff(NET_TX_SOFTIRQ);
+		local_irq_restore(flags);
+	}
+	rcu_read_unlock();
+}
+EXPORT_SYMBOL_GPL(xfrm_dev_resume);
+
+void xfrm_dev_backlog(struct softnet_data *sd)
+{
+	struct sk_buff_head *xfrm_backlog = &sd->xfrm_backlog;
+	struct sk_buff_head list;
+	struct sk_buff *skb;
+
+	if (skb_queue_empty(xfrm_backlog))
+		return;
+
+	__skb_queue_head_init(&list);
+
+	spin_lock(&xfrm_backlog->lock);
+	skb_queue_splice_init(xfrm_backlog, &list);
+	spin_unlock(&xfrm_backlog->lock);
+
+	while (!skb_queue_empty(&list)) {
+		skb = __skb_dequeue(&list);
+		xfrm_dev_resume(skb);
+	}
+
+}
 #endif
 
 static int xfrm_dev_register(struct net_device *dev)

commit 3dca3f38cfb8efb8571040568cac7d0025fa5bb1
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Wed Dec 20 10:41:31 2017 +0100

    xfrm: Separate ESP handling from segmentation for GRO packets.
    
    We change the ESP GSO handlers to only segment the packets.
    The ESP handling and encryption is defered to validate_xmit_xfrm()
    where this is done for non GRO packets too. This makes the code
    more robust and prepares for asynchronous crypto handling.
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 00641b611aed..a5a7a716c465 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -23,32 +23,99 @@
 #include <linux/notifier.h>
 
 #ifdef CONFIG_XFRM_OFFLOAD
-int validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t features)
+struct sk_buff *validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t features)
 {
 	int err;
+	__u32 seq;
 	struct xfrm_state *x;
+	struct sk_buff *skb2;
+	netdev_features_t esp_features = features;
 	struct xfrm_offload *xo = xfrm_offload(skb);
 
-	if (skb_is_gso(skb))
-		return 0;
+	if (!xo)
+		return skb;
 
-	if (xo) {
-		x = skb->sp->xvec[skb->sp->len - 1];
-		if (xo->flags & XFRM_GRO || x->xso.flags & XFRM_OFFLOAD_INBOUND)
-			return 0;
+	if (!(features & NETIF_F_HW_ESP))
+		esp_features = features & ~(NETIF_F_SG | NETIF_F_CSUM_MASK);
+
+	x = skb->sp->xvec[skb->sp->len - 1];
+	if (xo->flags & XFRM_GRO || x->xso.flags & XFRM_OFFLOAD_INBOUND)
+		return skb;
+
+	if (skb_is_gso(skb)) {
+		struct net_device *dev = skb->dev;
+
+		if (unlikely(!x->xso.offload_handle || (x->xso.dev != dev))) {
+			struct sk_buff *segs;
+
+			/* Packet got rerouted, fixup features and segment it. */
+			esp_features = esp_features & ~(NETIF_F_HW_ESP
+							| NETIF_F_GSO_ESP);
 
+			segs = skb_gso_segment(skb, esp_features);
+			if (IS_ERR(segs)) {
+				XFRM_INC_STATS(xs_net(x), LINUX_MIB_XFRMOUTSTATEPROTOERROR);
+				kfree_skb(skb);
+				return NULL;
+			} else {
+				consume_skb(skb);
+				skb = segs;
+			}
+		} else {
+			return skb;
+		}
+	}
+
+	if (!skb->next) {
 		x->outer_mode->xmit(x, skb);
 
-		err = x->type_offload->xmit(x, skb, features);
+		err = x->type_offload->xmit(x, skb, esp_features);
 		if (err) {
 			XFRM_INC_STATS(xs_net(x), LINUX_MIB_XFRMOUTSTATEPROTOERROR);
-			return err;
+			kfree_skb(skb);
+			return NULL;
 		}
 
 		skb_push(skb, skb->data - skb_mac_header(skb));
+
+		return skb;
 	}
 
-	return 0;
+	skb2 = skb;
+	seq = xo->seq.low;
+
+	do {
+		struct sk_buff *nskb = skb2->next;
+
+		xo = xfrm_offload(skb2);
+		xo->flags |= XFRM_GSO_SEGMENT;
+		xo->seq.low = seq;
+		xo->seq.hi = xfrm_replay_seqhi(x, seq);
+
+		if(!(features & NETIF_F_HW_ESP))
+			xo->flags |= CRYPTO_FALLBACK;
+
+		x->outer_mode->xmit(x, skb2);
+
+		err = x->type_offload->xmit(x, skb2, esp_features);
+		if (err) {
+			XFRM_INC_STATS(xs_net(x), LINUX_MIB_XFRMOUTSTATEPROTOERROR);
+			skb2->next = nskb;
+			kfree_skb_list(skb2);
+			return NULL;
+		}
+
+		if (!skb_is_gso(skb2))
+			seq++;
+		else
+			seq += skb_shinfo(skb2)->gso_segs;
+
+		skb_push(skb2, skb2->data - skb_mac_header(skb2));
+
+		skb2 = nskb;
+	} while (skb2);
+
+	return skb;
 }
 EXPORT_SYMBOL_GPL(validate_xmit_xfrm);
 

commit 8ce38aeb556ab0e71d8f19c32d302444a56a3a9e
Merge: 3b07d7884ca2 9b7e14dba0c0
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Dec 15 11:10:27 2017 -0500

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec-next
    
    Steffen Klassert says:
    
    ====================
    pull request (net-next): ipsec-next 2017-12-15
    
    1) Currently we can add or update socket policies, but
       not clear them. Support clearing of socket policies
       too. From Lorenzo Colitti.
    
    2) Add documentation for the xfrm device offload api.
       From Shannon Nelson.
    
    3) Fix IPsec extended sequence numbers (ESN) for
       IPsec offloading. From Yossef Efraim.
    
    4) xfrm_dev_state_add function returns success even for
       unsupported options, fix this to fail in such cases.
       From Yossef Efraim.
    
    5) Remove a redundant xfrm_state assignment.
       From Aviv Heller.
    
    Please pull or let me know if there are problems.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 43024b9ccd524ea1ad3e441edf08cb893bcd6d62
Author: Yossef Efraim <yossefe@mellanox.com>
Date:   Tue Nov 28 11:49:29 2017 +0200

    xfrm: Fix xfrm_dev_state_add to fail for unsupported HW SA option
    
    xfrm_dev_state_add function returns success for unsupported HW SA options.
    Resulting the calling function to create SW SA without corrlating HW SA.
    Desipte IPSec device offloading option was chosen.
    These not supported HW SA options are hard coded within xfrm_dev_state_add
    function.
    SW backward compatibility will break if we add any of these option as old
    HW will fail with new SW.
    
    This patch changes the behaviour to return -EINVAL in case unsupported
    option is chosen.
    Notifying user application regarding failure and not breaking backward
    compatibility for newly added HW SA options.
    
    Signed-off-by: Yossef Efraim <yossefe@mellanox.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 30e5746085b8..dc68d9c1fc8f 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -67,7 +67,7 @@ int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
 
 	/* We don't yet support UDP encapsulation, TFC padding and ESN. */
 	if (x->encap || x->tfcpad || (x->props.flags & XFRM_STATE_ESN))
-		return 0;
+		return -EINVAL;
 
 	dev = dev_get_by_index(net, xuo->ifindex);
 	if (!dev) {

commit 0f6c480f23f49b53644b383c5554e579498347f3
Author: David Miller <davem@davemloft.net>
Date:   Tue Nov 28 15:40:46 2017 -0500

    xfrm: Move dst->path into struct xfrm_dst
    
    The first member of an IPSEC route bundle chain sets it's dst->path to
    the underlying ipv4/ipv6 route that carries the bundle.
    
    Stated another way, if one were to follow the xfrm_dst->child chain of
    the bundle, the final non-NULL pointer would be the path and point to
    either an ipv4 or an ipv6 route.
    
    This is largely used to make sure that PMTU events propagate down to
    the correct ipv4 or ipv6 route.
    
    When we don't have the top of an IPSEC bundle 'dst->path == dst'.
    
    Move it down into xfrm_dst and key off of dst->xfrm.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Reviewed-by: Eric Dumazet <edumazet@google.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index c5851ddddd2a..c61a7d46b412 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -120,7 +120,7 @@ bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
 	if (!x->type_offload || x->encap)
 		return false;
 
-	if ((x->xso.offload_handle && (dev == dst->path->dev)) &&
+	if ((x->xso.offload_handle && (dev == xfrm_dst_path(dst)->dev)) &&
 	     !xdst->child->xfrm && x->type->get_mtu) {
 		mtu = x->type->get_mtu(x, xdst->child_mtu_cached);
 

commit b6ca8bd5a9198c70c48297390723e4e56bd6e879
Author: David Miller <davem@davemloft.net>
Date:   Tue Nov 28 15:45:44 2017 -0500

    xfrm: Move child route linkage into xfrm_dst.
    
    XFRM bundle child chains look like this:
    
            xdst1 --> xdst2 --> xdst3 --> path_dst
    
    All of xdstN are xfrm_dst objects and xdst->u.dst.xfrm is non-NULL.
    The final child pointer in the chain, here called 'path_dst', is some
    other kind of route such as an ipv4 or ipv6 one.
    
    The xfrm output path pops routes, one at a time, via the child
    pointer, until we hit one which has a dst->xfrm pointer which
    is NULL.
    
    We can easily preserve the above mechanisms with child sitting
    only in the xfrm_dst structure.  All children in the chain
    before we break out of the xfrm_output() loop have dst->xfrm
    non-NULL and are therefore xfrm_dst objects.
    
    Since we break out of the loop when we find dst->xfrm NULL, we
    will not try to dereference 'dst' as if it were an xfrm_dst.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 30e5746085b8..c5851ddddd2a 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -121,7 +121,7 @@ bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
 		return false;
 
 	if ((x->xso.offload_handle && (dev == dst->path->dev)) &&
-	     !dst->child->xfrm && x->type->get_mtu) {
+	     !xdst->child->xfrm && x->type->get_mtu) {
 		mtu = x->type->get_mtu(x, xdst->child_mtu_cached);
 
 		if (skb->len <= mtu)

commit 67a63387b1417b5954eedb15f638f1f0bee3da49
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Mon Sep 4 10:59:55 2017 +0200

    xfrm: Fix negative device refcount on offload failure.
    
    Reset the offload device at the xfrm_state if the device was
    not able to offload the state. Otherwise we drop the device
    refcount twice.
    
    Fixes: d77e38e612a0 ("xfrm: Add an IPsec hardware offloading API")
    Reported-by: Shannon Nelson <shannon.nelson@oracle.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index acf00104ef31..30e5746085b8 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -91,6 +91,7 @@ int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
 	}
 
 	if (!dev->xfrmdev_ops || !dev->xfrmdev_ops->xdo_dev_state_add) {
+		xso->dev = NULL;
 		dev_put(dev);
 		return 0;
 	}

commit 077fbac405bfc6d41419ad6c1725804ad4e9887c
Author: Lorenzo Colitti <lorenzo@google.com>
Date:   Fri Aug 11 02:11:33 2017 +0900

    net: xfrm: support setting an output mark.
    
    On systems that use mark-based routing it may be necessary for
    routing lookups to use marks in order for packets to be routed
    correctly. An example of such a system is Android, which uses
    socket marks to route packets via different networks.
    
    Currently, routing lookups in tunnel mode always use a mark of
    zero, making routing incorrect on such systems.
    
    This patch adds a new output_mark element to the xfrm state and
    a corresponding XFRMA_OUTPUT_MARK netlink attribute. The output
    mark differs from the existing xfrm mark in two ways:
    
    1. The xfrm mark is used to match xfrm policies and states, while
       the xfrm output mark is used to set the mark (and influence
       the routing) of the packets emitted by those states.
    2. The existing mark is constrained to be a subset of the bits of
       the originating socket or transformed packet, but the output
       mark is arbitrary and depends only on the state.
    
    The use of a separate mark provides additional flexibility. For
    example:
    
    - A packet subject to two transforms (e.g., transport mode inside
      tunnel mode) can have two different output marks applied to it,
      one for the transport mode SA and one for the tunnel mode SA.
    - On a system where socket marks determine routing, the packets
      emitted by an IPsec tunnel can be routed based on a mark that
      is determined by the tunnel, not by the marks of the
      unencrypted packets.
    - Support for setting the output marks can be introduced without
      breaking any existing setups that employ both mark-based
      routing and xfrm tunnel mode. Simply changing the code to use
      the xfrm mark for routing output packets could xfrm mark could
      change behaviour in a way that breaks these setups.
    
    If the output mark is unspecified or set to zero, the mark is not
    set or changed.
    
    Tested: make allyesconfig; make -j64
    Tested: https://android-review.googlesource.com/452776
    Signed-off-by: Lorenzo Colitti <lorenzo@google.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 1904127f5fb8..acf00104ef31 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -79,7 +79,8 @@ int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
 			daddr = &x->props.saddr;
 		}
 
-		dst = __xfrm_dst_lookup(net, 0, 0, saddr, daddr, x->props.family);
+		dst = __xfrm_dst_lookup(net, 0, 0, saddr, daddr,
+					x->props.family, x->props.output_mark);
 		if (IS_ERR(dst))
 			return 0;
 

commit ffdb5211da1c20354f1b40c204b6cf6c29c68161
Author: Ilan Tayari <ilant@mellanox.com>
Date:   Tue Aug 1 12:49:08 2017 +0300

    xfrm: Auto-load xfrm offload modules
    
    IPSec crypto offload depends on the protocol-specific
    offload module (such as esp_offload.ko).
    
    When the user installs an SA with crypto-offload, load
    the offload module automatically, in the same way
    that the protocol module is loaded (such as esp.ko)
    
    Signed-off-by: Ilan Tayari <ilant@mellanox.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 5cd7a244e88d..1904127f5fb8 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -63,7 +63,7 @@ int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
 	xfrm_address_t *daddr;
 
 	if (!x->type_offload)
-		return 0;
+		return -EINVAL;
 
 	/* We don't yet support UDP encapsulation, TFC padding and ESN. */
 	if (x->encap || x->tfcpad || (x->props.flags & XFRM_STATE_ESN))

commit ec30d78c14a813db39a647b6a348b4286ba4abf5
Author: Florian Westphal <fw@strlen.de>
Date:   Mon Jul 17 13:57:27 2017 +0200

    xfrm: add xdst pcpu cache
    
    retain last used xfrm_dst in a pcpu cache.
    On next request, reuse this dst if the policies are the same.
    
    The cache will not help with strict RR workloads as there is no hit.
    
    The cache packet-path part is reasonably small, the notifier part is
    needed so we do not add long hangs when a device is dismantled but some
    pcpu xdst still holds a reference, there are also calls to the flush
    operation when userspace deletes SAs so modules can be removed
    (there is no hit.
    
    We need to run the dst_release on the correct cpu to avoid races with
    packet path.  This is done by adding a work_struct for each cpu and then
    doing the actual test/release on each affected cpu via schedule_work_on().
    
    Test results using 4 network namespaces and null encryption:
    
    ns1           ns2          -> ns3           -> ns4
    netperf -> xfrm/null enc   -> xfrm/null dec -> netserver
    
    what                    TCP_STREAM      UDP_STREAM      UDP_RR
    Flow cache:             14644.61        294.35          327231.64
    No flow cache:          14349.81        242.64          202301.72
    Pcpu cache:             14629.70        292.21          205595.22
    
    UDP tests used 64byte packets, tests ran for one minute each,
    value is average over ten iterations.
    
    'Flow cache' is 'net-next', 'No flow cache' is net-next plus this
    series but without this patch.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 1f9a079e08b0..5cd7a244e88d 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -153,6 +153,7 @@ static int xfrm_dev_register(struct net_device *dev)
 
 static int xfrm_dev_unregister(struct net_device *dev)
 {
+	xfrm_policy_cache_flush();
 	return NOTIFY_DONE;
 }
 
@@ -175,6 +176,7 @@ static int xfrm_dev_down(struct net_device *dev)
 	if (dev->features & NETIF_F_HW_ESP)
 		xfrm_dev_state_flush(dev_net(dev), dev, true);
 
+	xfrm_policy_cache_flush();
 	return NOTIFY_DONE;
 }
 

commit 09c7570480f7544ffbf8e6db365208b0b0c154c6
Author: Florian Westphal <fw@strlen.de>
Date:   Mon Jul 17 13:57:26 2017 +0200

    xfrm: remove flow cache
    
    After rcu conversions performance degradation in forward tests isn't that
    noticeable anymore.
    
    See next patch for some numbers.
    
    A followup patcg could then also remove genid from the policies
    as we do not cache bundles anymore.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 5f7e8bfa0c2d..1f9a079e08b0 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -175,8 +175,6 @@ static int xfrm_dev_down(struct net_device *dev)
 	if (dev->features & NETIF_F_HW_ESP)
 		xfrm_dev_state_flush(dev_net(dev), dev, true);
 
-	xfrm_garbage_collect(dev_net(dev));
-
 	return NOTIFY_DONE;
 }
 

commit b07911593719828cac023bdcf6bf4da1c9ba546f
Merge: 52a623bd6189 4d8a991d460d
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jun 30 12:43:08 2017 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    A set of overlapping changes in macvlan and the rocker
    driver, nothing serious.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 93bbbfbb4a5aa32a2375a86f3a23e48ea75e05db
Merge: 408cf83f70b8 8bafd73093f2
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jun 23 14:17:31 2017 -0400

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/klassert/ipsec-next
    
    Steffen Klassert says:
    
    ====================
    pull request (net-next): ipsec-next 2017-06-23
    
    1) Use memdup_user to spmlify xfrm_user_policy.
       From Geliang Tang.
    
    2) Make xfrm_dev_register static to silence a sparse warning.
       From Wei Yongjun.
    
    3) Use crypto_memneq to check the ICV in the AH protocol.
       From Sabrina Dubroca.
    
    4) Remove some unused variables in esp6.
       From Stephen Hemminger.
    
    5) Extend XFRM MIGRATE to allow to change the UDP encapsulation port.
       From Antony Antony.
    
    6) Include the UDP encapsulation port to km_migrate announcements.
       From Antony Antony.
    
    Please pull or let me know if there are problems.
    ====================
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b81f884a547b5c264c13fdfaa3b65cf994bf1dcf
Author: Hangbin Liu <liuhangbin@gmail.com>
Date:   Thu Jun 1 14:57:56 2017 +0800

    xfrm: fix xfrm_dev_event() missing when compile without CONFIG_XFRM_OFFLOAD
    
    In commit d77e38e612a0 ("xfrm: Add an IPsec hardware offloading API") we
    make xfrm_device.o only compiled when enable option CONFIG_XFRM_OFFLOAD.
    But this will make xfrm_dev_event() missing if we only enable default XFRM
    options.
    
    Then if we set down and unregister an interface with IPsec on it. there
    will no xfrm_garbage_collect(), which will cause dev usage count hold and
    get error like:
    
    unregister_netdevice: waiting for <dev> to become free. Usage count = 4
    
    Fixes: d77e38e612a0 ("xfrm: Add an IPsec hardware offloading API")
    Signed-off-by: Hangbin Liu <liuhangbin@gmail.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 574e6f32f94f..5aba03685d7d 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -22,6 +22,7 @@
 #include <net/xfrm.h>
 #include <linux/notifier.h>
 
+#ifdef CONFIG_XFRM_OFFLOAD
 int validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t features)
 {
 	int err;
@@ -137,6 +138,7 @@ bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
 	return true;
 }
 EXPORT_SYMBOL_GPL(xfrm_dev_offload_ok);
+#endif
 
 int xfrm_dev_register(struct net_device *dev)
 {

commit 24d472e4e497c29d2eb8fcbe6d9b373b66804e01
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Thu May 18 15:51:38 2017 +0000

    xfrm: Make function xfrm_dev_register static
    
    Fixes the following sparse warning:
    
    net/xfrm/xfrm_device.c:141:5: warning:
     symbol 'xfrm_dev_register' was not declared. Should it be static?
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 8ec8a3fcf8d4..50ec73399b48 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -138,7 +138,7 @@ bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
 }
 EXPORT_SYMBOL_GPL(xfrm_dev_offload_ok);
 
-int xfrm_dev_register(struct net_device *dev)
+static int xfrm_dev_register(struct net_device *dev)
 {
 	if ((dev->features & NETIF_F_HW_ESP) && !dev->xfrmdev_ops)
 		return NOTIFY_BAD;

commit 2c1497bbc8fdee897341ab48ee9c9209b421b8c0
Author: Ilan Tayari <ilant@mellanox.com>
Date:   Mon May 8 10:30:18 2017 +0300

    xfrm: Fix NETDEV_DOWN with IPSec offload
    
    Upon NETDEV_DOWN event, all xfrm_state objects which are bound to
    the device are flushed.
    
    The condition for this is wrong, though, testing dev->hw_features
    instead of dev->features. If a device has non-user-modifiable
    NETIF_F_HW_ESP, then its xfrm_state objects are not flushed,
    causing a crash later on after the device is deleted.
    
    Check dev->features instead of dev->hw_features.
    
    Fixes: d77e38e612a0 ("xfrm: Add an IPsec hardware offloading API")
    Signed-off-by: Ilan Tayari <ilant@mellanox.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 8ec8a3fcf8d4..574e6f32f94f 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -170,7 +170,7 @@ static int xfrm_dev_feat_change(struct net_device *dev)
 
 static int xfrm_dev_down(struct net_device *dev)
 {
-	if (dev->hw_features & NETIF_F_HW_ESP)
+	if (dev->features & NETIF_F_HW_ESP)
 		xfrm_dev_state_flush(dev_net(dev), dev, true);
 
 	xfrm_garbage_collect(dev_net(dev));

commit f6e27114a60a0afdec40db1bf7f6da37b565745a
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Fri Apr 14 10:07:28 2017 +0200

    net: Add a xfrm validate function to validate_xmit_skb
    
    When we do IPsec offloading, we need a fallback for
    packets that were targeted to be IPsec offloaded but
    rerouted to a device that does not support IPsec offload.
    For that we add a function that checks the offloading
    features of the sending device and and flags the
    requirement of a fallback before it calls the IPsec
    output function. The IPsec output function adds the IPsec
    trailer and does encryption if needed.
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 9bac2ba9052c..8ec8a3fcf8d4 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -22,6 +22,35 @@
 #include <net/xfrm.h>
 #include <linux/notifier.h>
 
+int validate_xmit_xfrm(struct sk_buff *skb, netdev_features_t features)
+{
+	int err;
+	struct xfrm_state *x;
+	struct xfrm_offload *xo = xfrm_offload(skb);
+
+	if (skb_is_gso(skb))
+		return 0;
+
+	if (xo) {
+		x = skb->sp->xvec[skb->sp->len - 1];
+		if (xo->flags & XFRM_GRO || x->xso.flags & XFRM_OFFLOAD_INBOUND)
+			return 0;
+
+		x->outer_mode->xmit(x, skb);
+
+		err = x->type_offload->xmit(x, skb, features);
+		if (err) {
+			XFRM_INC_STATS(xs_net(x), LINUX_MIB_XFRMOUTSTATEPROTOERROR);
+			return err;
+		}
+
+		skb_push(skb, skb->data - skb_mac_header(skb));
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(validate_xmit_xfrm);
+
 int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
 		       struct xfrm_user_offload *xuo)
 {

commit d77e38e612a017480157fe6d2c1422f42cb5b7e3
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Fri Apr 14 10:06:10 2017 +0200

    xfrm: Add an IPsec hardware offloading API
    
    This patch adds all the bits that are needed to do
    IPsec hardware offload for IPsec states and ESP packets.
    We add xfrmdev_ops to the net_device. xfrmdev_ops has
    function pointers that are needed to manage the xfrm
    states in the hardware and to do a per packet
    offloading decision.
    
    Joint work with:
    Ilan Tayari <ilant@mellanox.com>
    Guy Shapiro <guysh@mellanox.com>
    Yossi Kuperman <yossiku@mellanox.com>
    
    Signed-off-by: Guy Shapiro <guysh@mellanox.com>
    Signed-off-by: Ilan Tayari <ilant@mellanox.com>
    Signed-off-by: Yossi Kuperman <yossiku@mellanox.com>
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
index 34a260a61be9..9bac2ba9052c 100644
--- a/net/xfrm/xfrm_device.c
+++ b/net/xfrm/xfrm_device.c
@@ -22,13 +22,149 @@
 #include <net/xfrm.h>
 #include <linux/notifier.h>
 
+int xfrm_dev_state_add(struct net *net, struct xfrm_state *x,
+		       struct xfrm_user_offload *xuo)
+{
+	int err;
+	struct dst_entry *dst;
+	struct net_device *dev;
+	struct xfrm_state_offload *xso = &x->xso;
+	xfrm_address_t *saddr;
+	xfrm_address_t *daddr;
+
+	if (!x->type_offload)
+		return 0;
+
+	/* We don't yet support UDP encapsulation, TFC padding and ESN. */
+	if (x->encap || x->tfcpad || (x->props.flags & XFRM_STATE_ESN))
+		return 0;
+
+	dev = dev_get_by_index(net, xuo->ifindex);
+	if (!dev) {
+		if (!(xuo->flags & XFRM_OFFLOAD_INBOUND)) {
+			saddr = &x->props.saddr;
+			daddr = &x->id.daddr;
+		} else {
+			saddr = &x->id.daddr;
+			daddr = &x->props.saddr;
+		}
+
+		dst = __xfrm_dst_lookup(net, 0, 0, saddr, daddr, x->props.family);
+		if (IS_ERR(dst))
+			return 0;
+
+		dev = dst->dev;
+
+		dev_hold(dev);
+		dst_release(dst);
+	}
+
+	if (!dev->xfrmdev_ops || !dev->xfrmdev_ops->xdo_dev_state_add) {
+		dev_put(dev);
+		return 0;
+	}
+
+	xso->dev = dev;
+	xso->num_exthdrs = 1;
+	xso->flags = xuo->flags;
+
+	err = dev->xfrmdev_ops->xdo_dev_state_add(x);
+	if (err) {
+		dev_put(dev);
+		return err;
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(xfrm_dev_state_add);
+
+bool xfrm_dev_offload_ok(struct sk_buff *skb, struct xfrm_state *x)
+{
+	int mtu;
+	struct dst_entry *dst = skb_dst(skb);
+	struct xfrm_dst *xdst = (struct xfrm_dst *)dst;
+	struct net_device *dev = x->xso.dev;
+
+	if (!x->type_offload || x->encap)
+		return false;
+
+	if ((x->xso.offload_handle && (dev == dst->path->dev)) &&
+	     !dst->child->xfrm && x->type->get_mtu) {
+		mtu = x->type->get_mtu(x, xdst->child_mtu_cached);
+
+		if (skb->len <= mtu)
+			goto ok;
+
+		if (skb_is_gso(skb) && skb_gso_validate_mtu(skb, mtu))
+			goto ok;
+	}
+
+	return false;
+
+ok:
+	if (dev && dev->xfrmdev_ops && dev->xfrmdev_ops->xdo_dev_offload_ok)
+		return x->xso.dev->xfrmdev_ops->xdo_dev_offload_ok(skb, x);
+
+	return true;
+}
+EXPORT_SYMBOL_GPL(xfrm_dev_offload_ok);
+
+int xfrm_dev_register(struct net_device *dev)
+{
+	if ((dev->features & NETIF_F_HW_ESP) && !dev->xfrmdev_ops)
+		return NOTIFY_BAD;
+	if ((dev->features & NETIF_F_HW_ESP_TX_CSUM) &&
+	    !(dev->features & NETIF_F_HW_ESP))
+		return NOTIFY_BAD;
+
+	return NOTIFY_DONE;
+}
+
+static int xfrm_dev_unregister(struct net_device *dev)
+{
+	return NOTIFY_DONE;
+}
+
+static int xfrm_dev_feat_change(struct net_device *dev)
+{
+	if ((dev->features & NETIF_F_HW_ESP) && !dev->xfrmdev_ops)
+		return NOTIFY_BAD;
+	else if (!(dev->features & NETIF_F_HW_ESP))
+		dev->xfrmdev_ops = NULL;
+
+	if ((dev->features & NETIF_F_HW_ESP_TX_CSUM) &&
+	    !(dev->features & NETIF_F_HW_ESP))
+		return NOTIFY_BAD;
+
+	return NOTIFY_DONE;
+}
+
+static int xfrm_dev_down(struct net_device *dev)
+{
+	if (dev->hw_features & NETIF_F_HW_ESP)
+		xfrm_dev_state_flush(dev_net(dev), dev, true);
+
+	xfrm_garbage_collect(dev_net(dev));
+
+	return NOTIFY_DONE;
+}
+
 static int xfrm_dev_event(struct notifier_block *this, unsigned long event, void *ptr)
 {
 	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
 
 	switch (event) {
+	case NETDEV_REGISTER:
+		return xfrm_dev_register(dev);
+
+	case NETDEV_UNREGISTER:
+		return xfrm_dev_unregister(dev);
+
+	case NETDEV_FEAT_CHANGE:
+		return xfrm_dev_feat_change(dev);
+
 	case NETDEV_DOWN:
-		xfrm_garbage_collect(dev_net(dev));
+		return xfrm_dev_down(dev);
 	}
 	return NOTIFY_DONE;
 }

commit 21f42cc95f07c1d7827b339c04442e147411e44b
Author: Steffen Klassert <steffen.klassert@secunet.com>
Date:   Fri Apr 14 10:05:53 2017 +0200

    xfrm: Move device notifications to a sepatate file
    
    This is needed for the upcomming IPsec device offloading.
    
    Signed-off-by: Steffen Klassert <steffen.klassert@secunet.com>

diff --git a/net/xfrm/xfrm_device.c b/net/xfrm/xfrm_device.c
new file mode 100644
index 000000000000..34a260a61be9
--- /dev/null
+++ b/net/xfrm/xfrm_device.c
@@ -0,0 +1,43 @@
+/*
+ * xfrm_device.c - IPsec device offloading code.
+ *
+ * Copyright (c) 2015 secunet Security Networks AG
+ *
+ * Author:
+ * Steffen Klassert <steffen.klassert@secunet.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <net/dst.h>
+#include <net/xfrm.h>
+#include <linux/notifier.h>
+
+static int xfrm_dev_event(struct notifier_block *this, unsigned long event, void *ptr)
+{
+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);
+
+	switch (event) {
+	case NETDEV_DOWN:
+		xfrm_garbage_collect(dev_net(dev));
+	}
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block xfrm_dev_notifier = {
+	.notifier_call	= xfrm_dev_event,
+};
+
+void __net_init xfrm_dev_init(void)
+{
+	register_netdevice_notifier(&xfrm_dev_notifier);
+}
