commit 03b6fefd9bb4844c75faeb10df8496794e2fd5da
Author: Tuong Lien <tuong.t.lien@dektech.com.au>
Date:   Tue May 26 16:38:37 2020 +0700

    tipc: add support for broadcast rcv stats dumping
    
    This commit enables dumping the statistics of a broadcast-receiver link
    like the traditional 'broadcast-link' one (which is for broadcast-
    sender). The link dumping can be triggered via netlink (e.g. the
    iproute2/tipc tool) by the link flag - 'TIPC_NLA_LINK_BROADCAST' as the
    indicator.
    
    The name of a broadcast-receiver link of a specific peer will be in the
    format: 'broadcast-link:<peer-id>'.
    
    For example:
    
    Link <broadcast-link:1001002>
      Window:50 packets
      RX packets:7841 fragments:2408/440 bundles:0/0
      TX packets:0 fragments:0/0 bundles:0/0
      RX naks:0 defs:124 dups:0
      TX naks:21 acks:0 retrans:0
      Congestion link:0  Send queue max:0 avg:0
    
    In addition, the broadcast-receiver link statistics can be reset in the
    usual way via netlink by specifying that link name in command.
    
    Note: the 'tipc_link_name_ext()' is removed because the link name can
    now be retrieved simply via the 'l->name'.
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Acked-by: Jon Maloy <jmaloy@redhat.com>
    Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 4d0768cf91d5..fc07232c9a12 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -80,7 +80,7 @@ bool tipc_link_create(struct net *net, char *if_name, int bearer_id,
 		      struct sk_buff_head *inputq,
 		      struct sk_buff_head *namedq,
 		      struct tipc_link **link);
-bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer,
+bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer, u8 *peer_id,
 			 int mtu, u32 min_win, u32 max_win, u16 peer_caps,
 			 struct sk_buff_head *inputq,
 			 struct sk_buff_head *namedq,
@@ -111,7 +111,6 @@ u16 tipc_link_rcv_nxt(struct tipc_link *l);
 u16 tipc_link_acked(struct tipc_link *l);
 u32 tipc_link_id(struct tipc_link *l);
 char *tipc_link_name(struct tipc_link *l);
-char *tipc_link_name_ext(struct tipc_link *l, char *buf);
 u32 tipc_link_state(struct tipc_link *l);
 char tipc_link_plane(struct tipc_link *l);
 int tipc_link_prio(struct tipc_link *l);

commit a91d55d162b86fb983b88f44296149752db7efbd
Author: Tuong Lien <tuong.t.lien@dektech.com.au>
Date:   Tue May 26 16:38:36 2020 +0700

    tipc: enable broadcast retrans via unicast
    
    In some environment, broadcast traffic is suppressed at high rate (i.e.
    a kind of bandwidth limit setting). When it is applied, TIPC broadcast
    can still run successfully. However, when it comes to a high load, some
    packets will be dropped first and TIPC tries to retransmit them but the
    packet retransmission is intentionally broadcast too, so making things
    worse and not helpful at all.
    
    This commit enables the broadcast retransmission via unicast which only
    retransmits packets to the specific peer that has really reported a gap
    i.e. not broadcasting to all nodes in the cluster, so will prevent from
    being suppressed, and also reduce some overheads on the other peers due
    to duplicates, finally improve the overall TIPC broadcast performance.
    
    Note: the functionality can be turned on/off via the sysctl file:
    
    echo 1 > /proc/sys/net/tipc/bc_retruni
    echo 0 > /proc/sys/net/tipc/bc_retruni
    
    Default is '0', i.e. the broadcast retransmission still works as usual.
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Acked-by: Jon Maloy <jmaloy@redhat.com>
    Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 0a0fa7350722..4d0768cf91d5 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -147,7 +147,8 @@ u16 tipc_get_gap_ack_blks(struct tipc_gap_ack_blks **ga, struct tipc_link *l,
 			  struct tipc_msg *hdr, bool uc);
 int tipc_link_bc_ack_rcv(struct tipc_link *l, u16 acked, u16 gap,
 			 struct tipc_gap_ack_blks *ga,
-			 struct sk_buff_head *xmitq);
+			 struct sk_buff_head *xmitq,
+			 struct sk_buff_head *retrq);
 void tipc_link_build_bc_sync_msg(struct tipc_link *l,
 				 struct sk_buff_head *xmitq);
 void tipc_link_bc_init_rcv(struct tipc_link *l, struct tipc_msg *hdr);

commit d7626b5acff9227e2a65da636a53e09bdafdc0aa
Author: Tuong Lien <tuong.t.lien@dektech.com.au>
Date:   Tue May 26 16:38:34 2020 +0700

    tipc: introduce Gap ACK blocks for broadcast link
    
    As achieved through commit 9195948fbf34 ("tipc: improve TIPC throughput
    by Gap ACK blocks"), we apply the same mechanism for the broadcast link
    as well. The 'Gap ACK blocks' data field in a 'PROTOCOL/STATE_MSG' will
    consist of two parts built for both the broadcast and unicast types:
    
     31                       16 15                        0
    +-------------+-------------+-------------+-------------+
    |  bgack_cnt  |  ugack_cnt  |            len            |
    +-------------+-------------+-------------+-------------+  -
    |            gap            |            ack            |   |
    +-------------+-------------+-------------+-------------+    > bc gacks
    :                           :                           :   |
    +-------------+-------------+-------------+-------------+  -
    |            gap            |            ack            |   |
    +-------------+-------------+-------------+-------------+    > uc gacks
    :                           :                           :   |
    +-------------+-------------+-------------+-------------+  -
    
    which is "automatically" backward-compatible.
    
    We also increase the max number of Gap ACK blocks to 128, allowing upto
    64 blocks per type (total buffer size = 516 bytes).
    
    Besides, the 'tipc_link_advance_transmq()' function is refactored which
    is applicable for both the unicast and broadcast cases now, so some old
    functions can be removed and the code is optimized.
    
    With the patch, TIPC broadcast is more robust regardless of packet loss
    or disorder, latency, ... in the underlying network. Its performance is
    boost up significantly.
    For example, experiment with a 5% packet loss rate results:
    
    $ time tipc-pipe --mc --rdm --data_size 123 --data_num 1500000
    real    0m 42.46s
    user    0m 1.16s
    sys     0m 17.67s
    
    Without the patch:
    
    $ time tipc-pipe --mc --rdm --data_size 123 --data_num 1500000
    real    8m 27.94s
    user    0m 0.55s
    sys     0m 2.38s
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Acked-by: Jon Maloy <jmaloy@redhat.com>
    Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index d3c1c3fc1659..0a0fa7350722 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -143,8 +143,11 @@ int tipc_link_bc_peers(struct tipc_link *l);
 void tipc_link_set_mtu(struct tipc_link *l, int mtu);
 int tipc_link_mtu(struct tipc_link *l);
 int tipc_link_mss(struct tipc_link *l);
-void tipc_link_bc_ack_rcv(struct tipc_link *l, u16 acked,
-			  struct sk_buff_head *xmitq);
+u16 tipc_get_gap_ack_blks(struct tipc_gap_ack_blks **ga, struct tipc_link *l,
+			  struct tipc_msg *hdr, bool uc);
+int tipc_link_bc_ack_rcv(struct tipc_link *l, u16 acked, u16 gap,
+			 struct tipc_gap_ack_blks *ga,
+			 struct sk_buff_head *xmitq);
 void tipc_link_build_bc_sync_msg(struct tipc_link *l,
 				 struct sk_buff_head *xmitq);
 void tipc_link_bc_init_rcv(struct tipc_link *l, struct tipc_msg *hdr);

commit 16ad3f4022bb53c7541a0bf0410b32d0231ebef9
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Tue Dec 10 00:52:46 2019 +0100

    tipc: introduce variable window congestion control
    
    We introduce a simple variable window congestion control for links.
    The algorithm is inspired by the Reno algorithm, covering both 'slow
    start', 'congestion avoidance', and 'fast recovery' modes.
    
    - We introduce hard lower and upper window limits per link, still
      different and configurable per bearer type.
    
    - We introduce a 'slow start theshold' variable, initially set to
      the maximum window size.
    
    - We let a link start at the minimum congestion window, i.e. in slow
      start mode, and then let is grow rapidly (+1 per rceived ACK) until
      it reaches the slow start threshold and enters congestion avoidance
      mode.
    
    - In congestion avoidance mode we increment the congestion window for
      each window-size number of acked packets, up to a possible maximum
      equal to the configured maximum window.
    
    - For each non-duplicate NACK received, we drop back to fast recovery
      mode, by setting the both the slow start threshold to and the
      congestion window to (current_congestion_window / 2).
    
    - If the timeout handler finds that the transmit queue has not moved
      since the previous timeout, it drops the link back to slow start
      and forces a probe containing the last sent sequence number to the
      sent to the peer, so that this can discover the stale situation.
    
    This change does in reality have effect only on unicast ethernet
    transport, as we have seen that there is no room whatsoever for
    increasing the window max size for the UDP bearer.
    For now, we also choose to keep the limits for the broadcast link
    unchanged and equal.
    
    This algorithm seems to give a 50-100% throughput improvement for
    messages larger than MTU.
    
    Suggested-by: Xin Long <lucien.xin@gmail.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index c09e9d49d0a3..d3c1c3fc1659 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -73,7 +73,7 @@ enum {
 
 bool tipc_link_create(struct net *net, char *if_name, int bearer_id,
 		      int tolerance, char net_plane, u32 mtu, int priority,
-		      int window, u32 session, u32 ownnode,
+		      u32 min_win, u32 max_win, u32 session, u32 ownnode,
 		      u32 peer, u8 *peer_id, u16 peer_caps,
 		      struct tipc_link *bc_sndlink,
 		      struct tipc_link *bc_rcvlink,
@@ -81,7 +81,7 @@ bool tipc_link_create(struct net *net, char *if_name, int bearer_id,
 		      struct sk_buff_head *namedq,
 		      struct tipc_link **link);
 bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer,
-			 int mtu, int window, u16 peer_caps,
+			 int mtu, u32 min_win, u32 max_win, u16 peer_caps,
 			 struct sk_buff_head *inputq,
 			 struct sk_buff_head *namedq,
 			 struct tipc_link *bc_sndlink,
@@ -115,7 +115,8 @@ char *tipc_link_name_ext(struct tipc_link *l, char *buf);
 u32 tipc_link_state(struct tipc_link *l);
 char tipc_link_plane(struct tipc_link *l);
 int tipc_link_prio(struct tipc_link *l);
-int tipc_link_window(struct tipc_link *l);
+int tipc_link_min_win(struct tipc_link *l);
+int tipc_link_max_win(struct tipc_link *l);
 void tipc_link_update_caps(struct tipc_link *l, u16 capabilities);
 bool tipc_link_validate_msg(struct tipc_link *l, struct tipc_msg *hdr);
 unsigned long tipc_link_tolerance(struct tipc_link *l);
@@ -124,7 +125,7 @@ void tipc_link_set_tolerance(struct tipc_link *l, u32 tol,
 void tipc_link_set_prio(struct tipc_link *l, u32 prio,
 			struct sk_buff_head *xmitq);
 void tipc_link_set_abort_limit(struct tipc_link *l, u32 limit);
-void tipc_link_set_queue_limits(struct tipc_link *l, u32 window);
+void tipc_link_set_queue_limits(struct tipc_link *l, u32 min_win, u32 max_win);
 int __tipc_nl_add_link(struct net *net, struct tipc_nl_msg *msg,
 		       struct tipc_link *link, int nlflags);
 int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);

commit fc1b6d6de2208774efd2a20bf0daddb02d18b1e0
Author: Tuong Lien <tuong.t.lien@dektech.com.au>
Date:   Fri Nov 8 12:05:11 2019 +0700

    tipc: introduce TIPC encryption & authentication
    
    This commit offers an option to encrypt and authenticate all messaging,
    including the neighbor discovery messages. The currently most advanced
    algorithm supported is the AEAD AES-GCM (like IPSec or TLS). All
    encryption/decryption is done at the bearer layer, just before leaving
    or after entering TIPC.
    
    Supported features:
    - Encryption & authentication of all TIPC messages (header + data);
    - Two symmetric-key modes: Cluster and Per-node;
    - Automatic key switching;
    - Key-expired revoking (sequence number wrapped);
    - Lock-free encryption/decryption (RCU);
    - Asynchronous crypto, Intel AES-NI supported;
    - Multiple cipher transforms;
    - Logs & statistics;
    
    Two key modes:
    - Cluster key mode: One single key is used for both TX & RX in all
    nodes in the cluster.
    - Per-node key mode: Each nodes in the cluster has one specific TX key.
    For RX, a node requires its peers' TX key to be able to decrypt the
    messages from those peers.
    
    Key setting from user-space is performed via netlink by a user program
    (e.g. the iproute2 'tipc' tool).
    
    Internal key state machine:
    
                                     Attach    Align(RX)
                                         +-+   +-+
                                         | V   | V
            +---------+      Attach     +---------+
            |  IDLE   |---------------->| PENDING |(user = 0)
            +---------+                 +---------+
               A   A                   Switch|  A
               |   |                         |  |
               |   | Free(switch/revoked)    |  |
         (Free)|   +----------------------+  |  |Timeout
               |              (TX)        |  |  |(RX)
               |                          |  |  |
               |                          |  v  |
            +---------+      Switch     +---------+
            | PASSIVE |<----------------| ACTIVE  |
            +---------+       (RX)      +---------+
            (user = 1)                  (user >= 1)
    
    The number of TFMs is 10 by default and can be changed via the procfs
    'net/tipc/max_tfms'. At this moment, as for simplicity, this file is
    also used to print the crypto statistics at runtime:
    
    echo 0xfff1 > /proc/sys/net/tipc/max_tfms
    
    The patch defines a new TIPC version (v7) for the encryption message (-
    backward compatibility as well). The message is basically encapsulated
    as follows:
    
       +----------------------------------------------------------+
       | TIPCv7 encryption  | Original TIPCv2    | Authentication |
       | header             | packet (encrypted) | Tag            |
       +----------------------------------------------------------+
    
    The throughput is about ~40% for small messages (compared with non-
    encryption) and ~9% for large messages. With the support from hardware
    crypto i.e. the Intel AES-NI CPU instructions, the throughput increases
    upto ~85% for small messages and ~55% for large messages.
    
    By default, the new feature is inactive (i.e. no encryption) until user
    sets a key for TIPC. There is however also a new option - "TIPC_CRYPTO"
    in the kernel configuration to enable/disable the new code when needed.
    
    MAINTAINERS | add two new files 'crypto.h' & 'crypto.c' in tipc
    
    Acked-by: Ying Xue <ying.xue@windreiver.com>
    Acked-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index adcad65e761c..c09e9d49d0a3 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -141,6 +141,7 @@ void tipc_link_remove_bc_peer(struct tipc_link *snd_l,
 int tipc_link_bc_peers(struct tipc_link *l);
 void tipc_link_set_mtu(struct tipc_link *l, int mtu);
 int tipc_link_mtu(struct tipc_link *l);
+int tipc_link_mss(struct tipc_link *l);
 void tipc_link_bc_ack_rcv(struct tipc_link *l, u16 acked,
 			  struct sk_buff_head *xmitq);
 void tipc_link_build_bc_sync_msg(struct tipc_link *l,

commit c0b14a0854fab0a0164aabfe49a76aae9216fe97
Author: Tuong Lien <tuong.t.lien@dektech.com.au>
Date:   Thu May 2 17:23:23 2019 +0700

    tipc: fix missing Name entries due to half-failover
    
    TIPC link can temporarily fall into "half-establish" that only one of
    the link endpoints is ESTABLISHED and starts to send traffic, PROTOCOL
    messages, whereas the other link endpoint is not up (e.g. immediately
    when the endpoint receives ACTIVATE_MSG, the network interface goes
    down...).
    
    This is a normal situation and will be settled because the link
    endpoint will be eventually brought down after the link tolerance time.
    
    However, the situation will become worse when the second link is
    established before the first link endpoint goes down,
    For example:
    
       1. Both links <1A-2A>, <1B-2B> down
       2. Link endpoint 2A up, but 1A still down (e.g. due to network
          disturbance, wrong session, etc.)
       3. Link <1B-2B> up
       4. Link endpoint 2A down (e.g. due to link tolerance timeout)
       5. Node B starts failover onto link <1B-2B>
    
       ==> Node A does never start link failover.
    
    When the "half-failover" situation happens, two consequences have been
    observed:
    
    a) Peer link/node gets stuck in FAILINGOVER state;
    b) Traffic or user messages that peer node is trying to failover onto
    the second link can be partially or completely dropped by this node.
    
    The consequence a) was actually solved by commit c140eb166d68 ("tipc:
    fix failover problem"), but that commit didn't cover the b). It's due
    to the fact that the tunnel link endpoint has never been prepared for a
    failover, so the 'l->drop_point' (and the other data...) is not set
    correctly. When a TUNNEL_MSG from peer node arrives on the link,
    depending on the inner message's seqno and the current 'l->drop_point'
    value, the message can be dropped (- treated as a duplicate message) or
    processed.
    At this early stage, the traffic messages from peer are likely to be
    NAME_DISTRIBUTORs, this means some name table entries will be missed on
    the node forever!
    
    The commit resolves the issue by starting the FAILOVER process on this
    node as well. Another benefit from this solution is that we ensure the
    link will not be re-established until the failover ends.
    
    Acked-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 8439e0ee53a8..adcad65e761c 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -90,6 +90,8 @@ void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
 			   int mtyp, struct sk_buff_head *xmitq);
 void tipc_link_create_dummy_tnl_msg(struct tipc_link *tnl,
 				    struct sk_buff_head *xmitq);
+void tipc_link_failover_prepare(struct tipc_link *l, struct tipc_link *tnl,
+				struct sk_buff_head *xmitq);
 void tipc_link_build_reset_msg(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_fsm_evt(struct tipc_link *l, int evt);
 bool tipc_link_is_up(struct tipc_link *l);

commit 26574db0c17fb29fac8b57f94ed1dfd46cc89887
Author: Tuong Lien <tuong.t.lien@dektech.com.au>
Date:   Wed Dec 19 09:17:57 2018 +0700

    tipc: add trace_events for tipc link
    
    The commit adds the new trace_events for TIPC link object:
    
    trace_tipc_link_timeout()
    trace_tipc_link_fsm()
    trace_tipc_link_reset()
    trace_tipc_link_too_silent()
    trace_tipc_link_retrans()
    trace_tipc_link_bc_ack()
    trace_tipc_link_conges()
    
    And the traces for PROTOCOL messages at building and receiving:
    
    trace_tipc_proto_build()
    trace_tipc_proto_rcv()
    
    Note:
    a) The 'tipc_link_too_silent' event will only happen when the
    'silent_intv_cnt' is about to reach the 'abort_limit' value (and the
    event is enabled). The benefit for this kind of event is that we can
    get an early indication about TIPC link loss issue due to timeout, then
    can do some necessary actions for troubleshooting.
    
    For example: To trigger the 'tipc_proto_rcv' when the 'too_silent'
    event occurs:
    
    echo 'enable_event:tipc:tipc_proto_rcv' > \
          events/tipc/tipc_link_too_silent/trigger
    
    And disable it when TIPC link is reset:
    
    echo 'disable_event:tipc:tipc_proto_rcv' > \
          events/tipc/tipc_link_reset/trigger
    
    b) The 'tipc_link_retrans' or 'tipc_link_bc_ack' event is useful to
    trace TIPC retransmission issues.
    
    In addition, the commit adds the 'trace_tipc_list/link_dump()' at the
    'retransmission failure' case. Then, if the issue occurs, the link
    'transmq' along with the link data can be dumped for post-analysis.
    These dump events should be enabled by default since it will only take
    effect when the failure happens.
    
    The same approach is also applied for the faulty case that the
    validation of protocol message is failed.
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Tested-by: Ying Xue <ying.xue@windriver.com>
    Acked-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index e8f692598e4d..8439e0ee53a8 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -148,4 +148,5 @@ int tipc_link_bc_sync_rcv(struct tipc_link *l,   struct tipc_msg *hdr,
 			  struct sk_buff_head *xmitq);
 int tipc_link_bc_nack_rcv(struct tipc_link *l, struct sk_buff *skb,
 			  struct sk_buff_head *xmitq);
+bool tipc_link_too_silent(struct tipc_link *l);
 #endif

commit b4b9771bcbbd5839b0f77aba55e2f85989ed6779
Author: Tuong Lien <tuong.t.lien@dektech.com.au>
Date:   Wed Dec 19 09:17:56 2018 +0700

    tipc: enable tracepoints in tipc
    
    As for the sake of debugging/tracing, the commit enables tracepoints in
    TIPC along with some general trace_events as shown below. It also
    defines some 'tipc_*_dump()' functions that allow to dump TIPC object
    data whenever needed, that is, for general debug purposes, ie. not just
    for the trace_events.
    
    The following trace_events are now available:
    
    - trace_tipc_skb_dump(): allows to trace and dump TIPC msg & skb data,
      e.g. message type, user, droppable, skb truesize, cloned skb, etc.
    
    - trace_tipc_list_dump(): allows to trace and dump any TIPC buffers or
      queues, e.g. TIPC link transmq, socket receive queue, etc.
    
    - trace_tipc_sk_dump(): allows to trace and dump TIPC socket data, e.g.
      sk state, sk type, connection type, rmem_alloc, socket queues, etc.
    
    - trace_tipc_link_dump(): allows to trace and dump TIPC link data, e.g.
      link state, silent_intv_cnt, gap, bc_gap, link queues, etc.
    
    - trace_tipc_node_dump(): allows to trace and dump TIPC node data, e.g.
      node state, active links, capabilities, link entries, etc.
    
    How to use:
    Put the trace functions at any places where we want to dump TIPC data
    or events.
    
    Note:
    a) The dump functions will generate raw data only, that is, to offload
    the trace event's processing, it can require a tool or script to parse
    the data but this should be simple.
    
    b) The trace_tipc_*_dump() should be reserved for a failure cases only
    (e.g. the retransmission failure case) or where we do not expect to
    happen too often, then we can consider enabling these events by default
    since they will almost not take any effects under normal conditions,
    but once the rare condition or failure occurs, we get the dumped data
    fully for post-analysis.
    
    For other trace purposes, we can reuse these trace classes as template
    but different events.
    
    c) A trace_event is only effective when we enable it. To enable the
    TIPC trace_events, echo 1 to 'enable' files in the events/tipc/
    directory in the 'debugfs' file system. Normally, they are located at:
    
    /sys/kernel/debug/tracing/events/tipc/
    
    For example:
    
    To enable the tipc_link_dump event:
    
    echo 1 > /sys/kernel/debug/tracing/events/tipc/tipc_link_dump/enable
    
    To enable all the TIPC trace_events:
    
    echo 1 > /sys/kernel/debug/tracing/events/tipc/enable
    
    To collect the trace data:
    
    cat trace
    
    or
    
    cat trace_pipe > /trace.out &
    
    To disable all the TIPC trace_events:
    
    echo 0 > /sys/kernel/debug/tracing/events/tipc/enable
    
    To clear the trace buffer:
    
    echo > trace
    
    d) Like the other trace_events, the feature like 'filter' or 'trigger'
    is also usable for the tipc trace_events.
    For more details, have a look at:
    
    Documentation/trace/ftrace.txt
    
    MAINTAINERS | add two new files 'trace.h' & 'trace.c' in tipc
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Tested-by: Ying Xue <ying.xue@windriver.com>
    Acked-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: Tuong Lien <tuong.t.lien@dektech.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 90488c538a4e..e8f692598e4d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -109,6 +109,7 @@ u16 tipc_link_rcv_nxt(struct tipc_link *l);
 u16 tipc_link_acked(struct tipc_link *l);
 u32 tipc_link_id(struct tipc_link *l);
 char *tipc_link_name(struct tipc_link *l);
+char *tipc_link_name_ext(struct tipc_link *l, char *buf);
 u32 tipc_link_state(struct tipc_link *l);
 char tipc_link_plane(struct tipc_link *l);
 int tipc_link_prio(struct tipc_link *l);

commit c140eb166d681f66bd7e99fb121357db1a503e7f
Author: LUU Duc Canh <canh.d.luu@dektech.com.au>
Date:   Wed Sep 26 21:00:54 2018 +0200

    tipc: fix failover problem
    
    We see the following scenario:
    1) Link endpoint B on node 1 discovers that its peer endpoint is gone.
       Since there is a second working link, failover procedure is started.
    2) Link endpoint A on node 1 sends a FAILOVER message to peer endpoint
       A on node 2. The node item 1->2 goes to state FAILINGOVER.
    3) Linke endpoint A/2 receives the failover, and is supposed to take
       down its parallell link endpoint B/2, while producing a FAILOVER
       message to send back to A/1.
    4) However, B/2 has already been deleted, so no FAILOVER message can
       created.
    5) Node 1->2 remains in state FAILINGOVER forever, refusing to receive
       any messages that can bring B/1 up again. We are left with a non-
       redundant link between node 1 and 2.
    
    We fix this with letting endpoint A/2 build a dummy FAILOVER message
    to send to back to A/1, so that the situation can be resolved.
    
    Signed-off-by: LUU Duc Canh <canh.d.luu@dektech.com.au>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 7bc494a33fdf..90488c538a4e 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -88,6 +88,8 @@ bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer,
 			 struct tipc_link **link);
 void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
 			   int mtyp, struct sk_buff_head *xmitq);
+void tipc_link_create_dummy_tnl_msg(struct tipc_link *tnl,
+				    struct sk_buff_head *xmitq);
 void tipc_link_build_reset_msg(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_fsm_evt(struct tipc_link *l, int evt);
 bool tipc_link_is_up(struct tipc_link *l);
@@ -107,6 +109,7 @@ u16 tipc_link_rcv_nxt(struct tipc_link *l);
 u16 tipc_link_acked(struct tipc_link *l);
 u32 tipc_link_id(struct tipc_link *l);
 char *tipc_link_name(struct tipc_link *l);
+u32 tipc_link_state(struct tipc_link *l);
 char tipc_link_plane(struct tipc_link *l);
 int tipc_link_prio(struct tipc_link *l);
 int tipc_link_window(struct tipc_link *l);

commit 7ea817f4e8322fa27fb860d15025bf72f68b179f
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Tue Jul 10 01:07:36 2018 +0200

    tipc: check session number before accepting link protocol messages
    
    In some virtual environments we observe a significant higher number of
    packet reordering and delays than we have been used to traditionally.
    
    This makes it necessary with stricter checks on incoming link protocol
    messages' session number, which until now only has been validated for
    RESET messages.
    
    Since the other two message types, ACTIVATE and STATE messages also
    carry this number, it is easy to extend the validation check to those
    messages.
    
    We also introduce a flag indicating if a link has a valid peer session
    number or not. This eliminates the mixing of 32- and 16-bit arithmethics
    we are currently using to achieve this.
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index d56f9c9e5000..7bc494a33fdf 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -111,6 +111,7 @@ char tipc_link_plane(struct tipc_link *l);
 int tipc_link_prio(struct tipc_link *l);
 int tipc_link_window(struct tipc_link *l);
 void tipc_link_update_caps(struct tipc_link *l, u16 capabilities);
+bool tipc_link_validate_msg(struct tipc_link *l, struct tipc_msg *hdr);
 unsigned long tipc_link_tolerance(struct tipc_link *l);
 void tipc_link_set_tolerance(struct tipc_link *l, u32 tol,
 			     struct sk_buff_head *xmitq);

commit 9012de5089560136b849b920ad038b96160ed8f6
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Tue Jul 10 01:07:35 2018 +0200

    tipc: add sequence number check for link STATE messages
    
    Some switch infrastructures produce huge amounts of packet duplicates.
    This becomes a problem if those messages are STATE/NACK protocol
    messages, causing unnecessary retransmissions of already accepted
    packets.
    
    We now introduce a unique sequence number per STATE protocol message
    so that duplicates can be identified and ignored. This will also be
    useful when tracing such cases, and to avert replay attacks when TIPC
    is encrypted.
    
    For compatibility reasons we have to introduce a new capability flag
    TIPC_LINK_PROTO_SEQNO to handle this new feature.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index ec59348a81e8..d56f9c9e5000 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -110,6 +110,7 @@ char *tipc_link_name(struct tipc_link *l);
 char tipc_link_plane(struct tipc_link *l);
 int tipc_link_prio(struct tipc_link *l);
 int tipc_link_window(struct tipc_link *l);
+void tipc_link_update_caps(struct tipc_link *l, u16 capabilities);
 unsigned long tipc_link_tolerance(struct tipc_link *l);
 void tipc_link_set_tolerance(struct tipc_link *l, u32 tol,
 			     struct sk_buff_head *xmitq);

commit 25b0b9c4e835ffaa65b61c3efe2e28acf84d0259
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Thu Mar 22 20:42:51 2018 +0100

    tipc: handle collisions of 32-bit node address hash values
    
    When a 32-bit node address is generated from a 128-bit identifier,
    there is a risk of collisions which must be discovered and handled.
    
    We do this as follows:
    - We don't apply the generated address immediately to the node, but do
      instead initiate a 1 sec trial period to allow other cluster members
      to discover and handle such collisions.
    
    - During the trial period the node periodically sends out a new type
      of message, DSC_TRIAL_MSG, using broadcast or emulated broadcast,
      to all the other nodes in the cluster.
    
    - When a node is receiving such a message, it must check that the
      presented 32-bit identifier either is unused, or was used by the very
      same peer in a previous session. In both cases it accepts the request
      by not responding to it.
    
    - If it finds that the same node has been up before using a different
      address, it responds with a DSC_TRIAL_FAIL_MSG containing that
      address.
    
    - If it finds that the address has already been taken by some other
      node, it generates a new, unused address and returns it to the
      requester.
    
    - During the trial period the requesting node must always be prepared
      to accept a failure message, i.e., a message where a peer suggests a
      different (or equal)  address to the one tried. In those cases it
      must apply the suggested value as trial address and restart the trial
      period.
    
    This algorithm ensures that in the vast majority of cases a node will
    have the same address before and after a reboot. If a legacy user
    configures the address explicitly, there will be no trial period and
    messages, so this protocol addition is completely backwards compatible.
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index d1bd1787a768..ec59348a81e8 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -73,8 +73,8 @@ enum {
 
 bool tipc_link_create(struct net *net, char *if_name, int bearer_id,
 		      int tolerance, char net_plane, u32 mtu, int priority,
-		      int window, u32 session, u32 ownnode, u32 peer,
-		      u16 peer_caps,
+		      int window, u32 session, u32 ownnode,
+		      u32 peer, u8 *peer_id, u16 peer_caps,
 		      struct tipc_link *bc_sndlink,
 		      struct tipc_link *bc_rcvlink,
 		      struct sk_buff_head *inputq,

commit 02d11ca20091fcef904f05defda80c53e5b4e793
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Sep 1 13:52:49 2016 -0400

    tipc: transfer broadcast nacks in link state messages
    
    When we send broadcasts in clusters of more 70-80 nodes, we sometimes
    see the broadcast link resetting because of an excessive number of
    retransmissions. This is caused by a combination of two factors:
    
    1) A 'NACK crunch", where loss of broadcast packets is discovered
       and NACK'ed by several nodes simultaneously, leading to multiple
       redundant broadcast retransmissions.
    
    2) The fact that the NACKS as such also are sent as broadcast, leading
       to excessive load and packet loss on the transmitting switch/bridge.
    
    This commit deals with the latter problem, by moving sending of
    broadcast nacks from the dedicated BCAST_PROTOCOL/NACK message type
    to regular unicast LINK_PROTOCOL/STATE messages. We allocate 10 unused
    bits in word 8 of the said message for this purpose, and introduce a
    new capability bit, TIPC_BCAST_STATE_NACK in order to keep the change
    backwards compatible.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index d7e9d42fcb2d..d1bd1787a768 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -63,7 +63,7 @@ enum {
 enum {
 	TIPC_LINK_UP_EVT       = 1,
 	TIPC_LINK_DOWN_EVT     = (1 << 1),
-	TIPC_LINK_SND_BC_ACK   = (1 << 2)
+	TIPC_LINK_SND_STATE    = (1 << 2)
 };
 
 /* Starting value for maximum packet size negotiation on unicast links
@@ -138,8 +138,8 @@ void tipc_link_bc_ack_rcv(struct tipc_link *l, u16 acked,
 void tipc_link_build_bc_sync_msg(struct tipc_link *l,
 				 struct sk_buff_head *xmitq);
 void tipc_link_bc_init_rcv(struct tipc_link *l, struct tipc_msg *hdr);
-void tipc_link_bc_sync_rcv(struct tipc_link *l,   struct tipc_msg *hdr,
-			   struct sk_buff_head *xmitq);
+int tipc_link_bc_sync_rcv(struct tipc_link *l,   struct tipc_msg *hdr,
+			  struct sk_buff_head *xmitq);
 int tipc_link_bc_nack_rcv(struct tipc_link *l, struct sk_buff *skb,
 			  struct sk_buff_head *xmitq);
 #endif

commit 34b9cd64c889d41eb990aec33fc185cab706c9b0
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Fri Apr 15 13:33:07 2016 -0400

    tipc: let first message on link be a state message
    
    According to the link FSM, a received traffic packet can take a link
    from state ESTABLISHING to ESTABLISHED, but the link can still not be
    fully set up in one atomic operation. This means that even if the the
    very first packet on the link is a traffic packet with sequence number
    1 (one), it has to be dropped and retransmitted.
    
    This can be avoided if we let the mentioned packet be preceded by a
    LINK_PROTOCOL/STATE message, which takes up the endpoint before the
    arrival of the traffic.
    
    We add this small feature in this commit.
    
    This is a fully compatible change.
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 6a94175ee20a..d7e9d42fcb2d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -123,7 +123,7 @@ int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
 int tipc_link_timeout(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_rcv(struct tipc_link *l, struct sk_buff *skb,
 		  struct sk_buff_head *xmitq);
-int tipc_link_build_ack_msg(struct tipc_link *l, struct sk_buff_head *xmitq);
+int tipc_link_build_state_msg(struct tipc_link *l, struct sk_buff_head *xmitq);
 void tipc_link_add_bc_peer(struct tipc_link *snd_l,
 			   struct tipc_link *uc_l,
 			   struct sk_buff_head *xmitq);

commit e74a386d70c793ef44678b44b021c99094b28c47
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Mar 3 14:23:21 2016 -0500

    tipc: remove pre-allocated message header in link struct
    
    Until now, we have kept a pre-allocated protocol message header
    aggregated into struct tipc_link. Apart from adding unnecessary
    footprint to the link instances, this requires extra code both to
    initialize and re-initialize it.
    
    We now remove this sub-optimization. This change also makes it
    possible to clean up the function tipc_build_proto_msg() and remove
    a couple of small functions that were accessing the mentioned header.
    In particular, we can replace all occurrences of the local function
    call link_own_addr(link) with the generic tipc_own_addr(net).
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index b4ee9d6e181d..6a94175ee20a 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -86,7 +86,6 @@ bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer,
 			 struct sk_buff_head *namedq,
 			 struct tipc_link *bc_sndlink,
 			 struct tipc_link **link);
-void tipc_link_reinit(struct tipc_link *l, u32 addr);
 void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
 			   int mtyp, struct sk_buff_head *xmitq);
 void tipc_link_build_reset_msg(struct tipc_link *l, struct sk_buff_head *xmitq);

commit d01332f1acacc0cb43a61f4244dd2b846d4cd585
Author: Richard Alpe <richard.alpe@ericsson.com>
Date:   Mon Feb 1 08:19:56 2016 +0100

    tipc: fix link attribute propagation bug
    
    Changing certain link attributes (link tolerance and link priority)
    from the TIPC management tool is supposed to automatically take
    effect at both endpoints of the affected link.
    
    Currently the media address is not instantiated for the link and is
    used uninstantiated when crafting protocol messages designated for the
    peer endpoint. This means that changing a link property currently
    results in the property being changed on the local machine but the
    protocol message designated for the peer gets lost. Resulting in
    property discrepancy between the endpoints.
    
    In this patch we resolve this by using the media address from the
    link entry and using the bearer transmit function to send it. Hence,
    we can now eliminate the redundant function tipc_link_prot_xmit() and
    the redundant field tipc_link::media_addr.
    
    Fixes: 2af5ae372a4b (tipc: clean up unused code and structures)
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Reported-by: Jason Hu <huzhijiang@gmail.com>
    Signed-off-by: Richard Alpe <richard.alpe@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index b2ae0f4276af..b4ee9d6e181d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -112,8 +112,10 @@ char tipc_link_plane(struct tipc_link *l);
 int tipc_link_prio(struct tipc_link *l);
 int tipc_link_window(struct tipc_link *l);
 unsigned long tipc_link_tolerance(struct tipc_link *l);
-void tipc_link_set_tolerance(struct tipc_link *l, u32 tol);
-void tipc_link_set_prio(struct tipc_link *l, u32 prio);
+void tipc_link_set_tolerance(struct tipc_link *l, u32 tol,
+			     struct sk_buff_head *xmitq);
+void tipc_link_set_prio(struct tipc_link *l, u32 prio,
+			struct sk_buff_head *xmitq);
 void tipc_link_set_abort_limit(struct tipc_link *l, u32 limit);
 void tipc_link_set_queue_limits(struct tipc_link *l, u32 window);
 int __tipc_nl_add_link(struct net *net, struct tipc_nl_msg *msg,

commit 1a90632da8c17a27e0c93538ee987764adee43a5
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Nov 19 14:30:47 2015 -0500

    tipc: eliminate remnants of hungarian notation
    
    The number of variables with Hungarian notation (l_ptr, n_ptr etc.)
    has been significantly reduced over the last couple of years.
    
    We now root out the last traces of this practice.
    There are no functional changes in this commit.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 616fc808f23a..b2ae0f4276af 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -99,7 +99,7 @@ bool tipc_link_is_synching(struct tipc_link *l);
 bool tipc_link_is_failingover(struct tipc_link *l);
 bool tipc_link_is_blocked(struct tipc_link *l);
 void tipc_link_set_active(struct tipc_link *l, bool active);
-void tipc_link_reset(struct tipc_link *l_ptr);
+void tipc_link_reset(struct tipc_link *l);
 void tipc_link_reset_stats(struct tipc_link *l);
 int tipc_link_xmit(struct tipc_link *link, struct sk_buff_head *list,
 		   struct sk_buff_head *xmitq);

commit 38206d5939068415c413ac253be6f364d06e672f
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Nov 19 14:30:46 2015 -0500

    tipc: narrow down interface towards struct tipc_link
    
    We move the definition of struct tipc_link from link.h to link.c in
    order to minimize its exposure to the rest of the code.
    
    When needed, we define new functions to make it possible for external
    entities to access and set data in the link.
    
    Apart from the above, there are no functional changes.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index a7ee806e1ee4..616fc808f23a 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -45,10 +45,6 @@
 */
 #define ELINKCONG EAGAIN	/* link congestion <=> resource unavailable */
 
-/* Out-of-range value for link sequence numbers
- */
-#define INVALID_LINK_SEQ 0x10000
-
 /* Link FSM events:
  */
 enum {
@@ -75,151 +71,6 @@ enum {
  */
 #define MAX_PKT_DEFAULT 1500
 
-struct tipc_stats {
-	u32 sent_info;		/* used in counting # sent packets */
-	u32 recv_info;		/* used in counting # recv'd packets */
-	u32 sent_states;
-	u32 recv_states;
-	u32 sent_probes;
-	u32 recv_probes;
-	u32 sent_nacks;
-	u32 recv_nacks;
-	u32 sent_acks;
-	u32 sent_bundled;
-	u32 sent_bundles;
-	u32 recv_bundled;
-	u32 recv_bundles;
-	u32 retransmitted;
-	u32 sent_fragmented;
-	u32 sent_fragments;
-	u32 recv_fragmented;
-	u32 recv_fragments;
-	u32 link_congs;		/* # port sends blocked by congestion */
-	u32 deferred_recv;
-	u32 duplicates;
-	u32 max_queue_sz;	/* send queue size high water mark */
-	u32 accu_queue_sz;	/* used for send queue size profiling */
-	u32 queue_sz_counts;	/* used for send queue size profiling */
-	u32 msg_length_counts;	/* used for message length profiling */
-	u32 msg_lengths_total;	/* used for message length profiling */
-	u32 msg_length_profile[7]; /* used for msg. length profiling */
-};
-
-/**
- * struct tipc_link - TIPC link data structure
- * @addr: network address of link's peer node
- * @name: link name character string
- * @media_addr: media address to use when sending messages over link
- * @timer: link timer
- * @net: pointer to namespace struct
- * @refcnt: reference counter for permanent references (owner node & timer)
- * @peer_session: link session # being used by peer end of link
- * @peer_bearer_id: bearer id used by link's peer endpoint
- * @bearer_id: local bearer id used by link
- * @tolerance: minimum link continuity loss needed to reset link [in ms]
- * @keepalive_intv: link keepalive timer interval
- * @abort_limit: # of unacknowledged continuity probes needed to reset link
- * @state: current state of link FSM
- * @peer_caps: bitmap describing capabilities of peer node
- * @silent_intv_cnt: # of timer intervals without any reception from peer
- * @proto_msg: template for control messages generated by link
- * @pmsg: convenience pointer to "proto_msg" field
- * @priority: current link priority
- * @net_plane: current link network plane ('A' through 'H')
- * @backlog_limit: backlog queue congestion thresholds (indexed by importance)
- * @exp_msg_count: # of tunnelled messages expected during link changeover
- * @reset_rcv_checkpt: seq # of last acknowledged message at time of link reset
- * @mtu: current maximum packet size for this link
- * @advertised_mtu: advertised own mtu when link is being established
- * @transmitq: queue for sent, non-acked messages
- * @backlogq: queue for messages waiting to be sent
- * @snt_nxt: next sequence number to use for outbound messages
- * @last_retransmitted: sequence number of most recently retransmitted message
- * @stale_count: # of identical retransmit requests made by peer
- * @ackers: # of peers that needs to ack each packet before it can be released
- * @acked: # last packet acked by a certain peer. Used for broadcast.
- * @rcv_nxt: next sequence number to expect for inbound messages
- * @deferred_queue: deferred queue saved OOS b'cast message received from node
- * @unacked_window: # of inbound messages rx'd without ack'ing back to peer
- * @inputq: buffer queue for messages to be delivered upwards
- * @namedq: buffer queue for name table messages to be delivered upwards
- * @next_out: ptr to first unsent outbound message in queue
- * @wakeupq: linked list of wakeup msgs waiting for link congestion to abate
- * @long_msg_seq_no: next identifier to use for outbound fragmented messages
- * @reasm_buf: head of partially reassembled inbound message fragments
- * @bc_rcvr: marks that this is a broadcast receiver link
- * @stats: collects statistics regarding link activity
- */
-struct tipc_link {
-	u32 addr;
-	char name[TIPC_MAX_LINK_NAME];
-	struct tipc_media_addr *media_addr;
-	struct net *net;
-
-	/* Management and link supervision data */
-	u32 peer_session;
-	u32 peer_bearer_id;
-	u32 bearer_id;
-	u32 tolerance;
-	unsigned long keepalive_intv;
-	u32 abort_limit;
-	u32 state;
-	u16 peer_caps;
-	bool active;
-	u32 silent_intv_cnt;
-	struct {
-		unchar hdr[INT_H_SIZE];
-		unchar body[TIPC_MAX_IF_NAME];
-	} proto_msg;
-	struct tipc_msg *pmsg;
-	u32 priority;
-	char net_plane;
-
-	/* Failover/synch */
-	u16 drop_point;
-	struct sk_buff *failover_reasm_skb;
-
-	/* Max packet negotiation */
-	u16 mtu;
-	u16 advertised_mtu;
-
-	/* Sending */
-	struct sk_buff_head transmq;
-	struct sk_buff_head backlogq;
-	struct {
-		u16 len;
-		u16 limit;
-	} backlog[5];
-	u16 snd_nxt;
-	u16 last_retransm;
-	u16 window;
-	u32 stale_count;
-
-	/* Reception */
-	u16 rcv_nxt;
-	u32 rcv_unacked;
-	struct sk_buff_head deferdq;
-	struct sk_buff_head *inputq;
-	struct sk_buff_head *namedq;
-
-	/* Congestion handling */
-	struct sk_buff_head wakeupq;
-
-	/* Fragmentation/reassembly */
-	struct sk_buff *reasm_buf;
-
-	/* Broadcast */
-	u16 ackers;
-	u16 acked;
-	struct tipc_link *bc_rcvlink;
-	struct tipc_link *bc_sndlink;
-	int nack_state;
-	bool bc_peer_is_up;
-
-	/* Statistics */
-	struct tipc_stats stats;
-};
-
 bool tipc_link_create(struct net *net, char *if_name, int bearer_id,
 		      int tolerance, char net_plane, u32 mtu, int priority,
 		      int window, u32 session, u32 ownnode, u32 peer,
@@ -235,11 +86,11 @@ bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer,
 			 struct sk_buff_head *namedq,
 			 struct tipc_link *bc_sndlink,
 			 struct tipc_link **link);
+void tipc_link_reinit(struct tipc_link *l, u32 addr);
 void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
 			   int mtyp, struct sk_buff_head *xmitq);
 void tipc_link_build_reset_msg(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_fsm_evt(struct tipc_link *l, int evt);
-void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 bool tipc_link_is_up(struct tipc_link *l);
 bool tipc_link_peer_is_down(struct tipc_link *l);
 bool tipc_link_is_reset(struct tipc_link *l);
@@ -249,15 +100,24 @@ bool tipc_link_is_failingover(struct tipc_link *l);
 bool tipc_link_is_blocked(struct tipc_link *l);
 void tipc_link_set_active(struct tipc_link *l, bool active);
 void tipc_link_reset(struct tipc_link *l_ptr);
-void link_reset_statistics(struct tipc_link *l);
-int tipc_link_xmit(struct tipc_link *link,	struct sk_buff_head *list,
+void tipc_link_reset_stats(struct tipc_link *l);
+int tipc_link_xmit(struct tipc_link *link, struct sk_buff_head *list,
 		   struct sk_buff_head *xmitq);
-void tipc_link_proto_xmit(struct tipc_link *l, u32 msg_typ, int probe_msg,
-			  u32 gap, u32 tolerance, u32 priority);
+struct sk_buff_head *tipc_link_inputq(struct tipc_link *l);
+u16 tipc_link_rcv_nxt(struct tipc_link *l);
+u16 tipc_link_acked(struct tipc_link *l);
+u32 tipc_link_id(struct tipc_link *l);
+char *tipc_link_name(struct tipc_link *l);
+char tipc_link_plane(struct tipc_link *l);
+int tipc_link_prio(struct tipc_link *l);
+int tipc_link_window(struct tipc_link *l);
+unsigned long tipc_link_tolerance(struct tipc_link *l);
+void tipc_link_set_tolerance(struct tipc_link *l, u32 tol);
+void tipc_link_set_prio(struct tipc_link *l, u32 prio);
+void tipc_link_set_abort_limit(struct tipc_link *l, u32 limit);
 void tipc_link_set_queue_limits(struct tipc_link *l, u32 window);
 int __tipc_nl_add_link(struct net *net, struct tipc_nl_msg *msg,
 		       struct tipc_link *link, int nlflags);
-int tipc_nl_link_dump(struct sk_buff *skb, struct netlink_callback *cb);
 int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
 int tipc_link_timeout(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_rcv(struct tipc_link *l, struct sk_buff *skb,

commit 5be9c086715c10fb9ae3ffc0ef580dc3a165f98a
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Nov 19 14:30:45 2015 -0500

    tipc: narrow down exposure of struct tipc_node
    
    In our effort to have less code and include dependencies between
    entities such as node, link and bearer, we try to narrow down
    the exposed interface towards the node as much as possible.
    
    In this commit, we move the definition of struct tipc_node, along
    with many of its associated function declarations, from node.h to
    node.c. We also move some function definitions from link.c and
    name_distr.c to node.c, since they access fields in struct tipc_node
    that should not be externally visible. The moved functions are renamed
    according to new location, and made static whenever possible.
    
    There are no functional changes in this commit.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 66d859b66c84..a7ee806e1ee4 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -249,14 +249,15 @@ bool tipc_link_is_failingover(struct tipc_link *l);
 bool tipc_link_is_blocked(struct tipc_link *l);
 void tipc_link_set_active(struct tipc_link *l, bool active);
 void tipc_link_reset(struct tipc_link *l_ptr);
+void link_reset_statistics(struct tipc_link *l);
 int tipc_link_xmit(struct tipc_link *link,	struct sk_buff_head *list,
 		   struct sk_buff_head *xmitq);
+void tipc_link_proto_xmit(struct tipc_link *l, u32 msg_typ, int probe_msg,
+			  u32 gap, u32 tolerance, u32 priority);
 void tipc_link_set_queue_limits(struct tipc_link *l, u32 window);
-
+int __tipc_nl_add_link(struct net *net, struct tipc_nl_msg *msg,
+		       struct tipc_link *link, int nlflags);
 int tipc_nl_link_dump(struct sk_buff *skb, struct netlink_callback *cb);
-int tipc_nl_link_get(struct sk_buff *skb, struct genl_info *info);
-int tipc_nl_link_set(struct sk_buff *skb, struct genl_info *info);
-int tipc_nl_link_reset_stats(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
 int tipc_link_timeout(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_rcv(struct tipc_link *l, struct sk_buff *skb,

commit 2af5ae372a4b6d6e2d3314af0e9c865d6d64f8d3
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 22 08:51:48 2015 -0400

    tipc: clean up unused code and structures
    
    After the previous changes in this series, we can now remove some
    unused code and structures, both in the broadcast, link aggregation
    and link code.
    
    There are no functional changes in this commit.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index eb1d7f9d5522..66d859b66c84 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -224,7 +224,6 @@ bool tipc_link_create(struct net *net, char *if_name, int bearer_id,
 		      int tolerance, char net_plane, u32 mtu, int priority,
 		      int window, u32 session, u32 ownnode, u32 peer,
 		      u16 peer_caps,
-		      struct tipc_media_addr *maddr,
 		      struct tipc_link *bc_sndlink,
 		      struct tipc_link *bc_rcvlink,
 		      struct sk_buff_head *inputq,
@@ -249,22 +248,10 @@ bool tipc_link_is_synching(struct tipc_link *l);
 bool tipc_link_is_failingover(struct tipc_link *l);
 bool tipc_link_is_blocked(struct tipc_link *l);
 void tipc_link_set_active(struct tipc_link *l, bool active);
-void tipc_link_purge_queues(struct tipc_link *l_ptr);
-void tipc_link_purge_backlog(struct tipc_link *l);
 void tipc_link_reset(struct tipc_link *l_ptr);
-int __tipc_link_xmit(struct net *net, struct tipc_link *link,
-		     struct sk_buff_head *list);
 int tipc_link_xmit(struct tipc_link *link,	struct sk_buff_head *list,
 		   struct sk_buff_head *xmitq);
-void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
-			  u32 gap, u32 tolerance, u32 priority);
-void tipc_link_push_packets(struct tipc_link *l_ptr);
-u32 tipc_link_defer_pkt(struct sk_buff_head *list, struct sk_buff *buf);
-void tipc_link_set_queue_limits(struct tipc_link *l_ptr, u32 window);
-void tipc_link_retransmit(struct tipc_link *l_ptr,
-			  struct sk_buff *start, u32 retransmits);
-struct sk_buff *tipc_skb_queue_next(const struct sk_buff_head *list,
-				    const struct sk_buff *skb);
+void tipc_link_set_queue_limits(struct tipc_link *l, u32 window);
 
 int tipc_nl_link_dump(struct sk_buff *skb, struct netlink_callback *cb);
 int tipc_nl_link_get(struct sk_buff *skb, struct genl_info *info);

commit c72fa872a23f03b2b9c17e88f3b0a8070924e5f1
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 22 08:51:46 2015 -0400

    tipc: eliminate link's reference to owner node
    
    With the recent commit series, we have established a one-way dependency
    between the link aggregation (struct tipc_node) instances and their
    pertaining tipc_link instances. This has enabled quite significant code
    and structure simplifications.
    
    In this commit, we eliminate the field 'owner', which points to an
    instance of struct tipc_node, from struct tipc_link, and replace it with
    a pointer to struct net, which is the only external reference now needed
    by a link instance.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 9b5198e90fdf..eb1d7f9d5522 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -111,7 +111,7 @@ struct tipc_stats {
  * @name: link name character string
  * @media_addr: media address to use when sending messages over link
  * @timer: link timer
- * @owner: pointer to peer node
+ * @net: pointer to namespace struct
  * @refcnt: reference counter for permanent references (owner node & timer)
  * @peer_session: link session # being used by peer end of link
  * @peer_bearer_id: bearer id used by link's peer endpoint
@@ -154,7 +154,7 @@ struct tipc_link {
 	u32 addr;
 	char name[TIPC_MAX_LINK_NAME];
 	struct tipc_media_addr *media_addr;
-	struct tipc_node *owner;
+	struct net *net;
 
 	/* Management and link supervision data */
 	u32 peer_session;
@@ -165,6 +165,7 @@ struct tipc_link {
 	u32 abort_limit;
 	u32 state;
 	u16 peer_caps;
+	bool active;
 	u32 silent_intv_cnt;
 	struct {
 		unchar hdr[INT_H_SIZE];
@@ -219,7 +220,7 @@ struct tipc_link {
 	struct tipc_stats stats;
 };
 
-bool tipc_link_create(struct tipc_node *n, char *if_name, int bearer_id,
+bool tipc_link_create(struct net *net, char *if_name, int bearer_id,
 		      int tolerance, char net_plane, u32 mtu, int priority,
 		      int window, u32 session, u32 ownnode, u32 peer,
 		      u16 peer_caps,
@@ -229,7 +230,7 @@ bool tipc_link_create(struct tipc_node *n, char *if_name, int bearer_id,
 		      struct sk_buff_head *inputq,
 		      struct sk_buff_head *namedq,
 		      struct tipc_link **link);
-bool tipc_link_bc_create(struct tipc_node *n, u32 ownnode, u32 peer,
+bool tipc_link_bc_create(struct net *net, u32 ownnode, u32 peer,
 			 int mtu, int window, u16 peer_caps,
 			 struct sk_buff_head *inputq,
 			 struct sk_buff_head *namedq,
@@ -247,7 +248,7 @@ bool tipc_link_is_establishing(struct tipc_link *l);
 bool tipc_link_is_synching(struct tipc_link *l);
 bool tipc_link_is_failingover(struct tipc_link *l);
 bool tipc_link_is_blocked(struct tipc_link *l);
-int tipc_link_is_active(struct tipc_link *l_ptr);
+void tipc_link_set_active(struct tipc_link *l, bool active);
 void tipc_link_purge_queues(struct tipc_link *l_ptr);
 void tipc_link_purge_backlog(struct tipc_link *l);
 void tipc_link_reset(struct tipc_link *l_ptr);

commit 959e1781aa230aecc90e4deb80117fd9a53dede7
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 22 08:51:43 2015 -0400

    tipc: introduce jumbo frame support for broadcast
    
    Until now, we have only been supporting a fix MTU size of 1500 bytes
    for all broadcast media, irrespective of their actual capability.
    
    We now make the broadcast MTU adaptable to the carrying media, i.e.,
    we use the smallest MTU supported by any of the interfaces attached
    to TIPC.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 28a6396b6d31..9b5198e90fdf 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -281,6 +281,8 @@ void tipc_link_remove_bc_peer(struct tipc_link *snd_l,
 			      struct tipc_link *rcv_l,
 			      struct sk_buff_head *xmitq);
 int tipc_link_bc_peers(struct tipc_link *l);
+void tipc_link_set_mtu(struct tipc_link *l, int mtu);
+int tipc_link_mtu(struct tipc_link *l);
 void tipc_link_bc_ack_rcv(struct tipc_link *l, u16 acked,
 			  struct sk_buff_head *xmitq);
 void tipc_link_build_bc_sync_msg(struct tipc_link *l,

commit 5266698661401afc5e4a1a521cf9ba10724d10dd
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 22 08:51:41 2015 -0400

    tipc: let broadcast packet reception use new link receive function
    
    The code path for receiving broadcast packets is currently distinct
    from the unicast path. This leads to unnecessary code and data
    duplication, something that can be avoided with some effort.
    
    We now introduce separate per-peer tipc_link instances for handling
    broadcast packet reception. Each receive link keeps a pointer to the
    common, single, broadcast link instance, and can hence handle release
    and retransmission of send buffers as if they belonged to the own
    instance.
    
    Furthermore, we let each unicast link instance keep a reference to both
    the pertaining broadcast receive link, and to the common send link.
    This makes it possible for the unicast links to easily access data for
    broadcast link synchronization, as well as for carrying acknowledges for
    received broadcast packets.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index d23329db4b25..28a6396b6d31 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -66,7 +66,8 @@ enum {
  */
 enum {
 	TIPC_LINK_UP_EVT       = 1,
-	TIPC_LINK_DOWN_EVT     = (1 << 1)
+	TIPC_LINK_DOWN_EVT     = (1 << 1),
+	TIPC_LINK_SND_BC_ACK   = (1 << 2)
 };
 
 /* Starting value for maximum packet size negotiation on unicast links
@@ -209,6 +210,10 @@ struct tipc_link {
 	/* Broadcast */
 	u16 ackers;
 	u16 acked;
+	struct tipc_link *bc_rcvlink;
+	struct tipc_link *bc_sndlink;
+	int nack_state;
+	bool bc_peer_is_up;
 
 	/* Statistics */
 	struct tipc_stats stats;
@@ -217,17 +222,21 @@ struct tipc_link {
 bool tipc_link_create(struct tipc_node *n, char *if_name, int bearer_id,
 		      int tolerance, char net_plane, u32 mtu, int priority,
 		      int window, u32 session, u32 ownnode, u32 peer,
-		      u16 peer_caps, struct tipc_media_addr *maddr,
-		      struct sk_buff_head *inputq, struct sk_buff_head *namedq,
+		      u16 peer_caps,
+		      struct tipc_media_addr *maddr,
+		      struct tipc_link *bc_sndlink,
+		      struct tipc_link *bc_rcvlink,
+		      struct sk_buff_head *inputq,
+		      struct sk_buff_head *namedq,
 		      struct tipc_link **link);
-bool tipc_link_bc_create(struct tipc_node *n, int mtu, int window,
-			 u16 peer_caps, struct sk_buff_head *inputq,
+bool tipc_link_bc_create(struct tipc_node *n, u32 ownnode, u32 peer,
+			 int mtu, int window, u16 peer_caps,
+			 struct sk_buff_head *inputq,
 			 struct sk_buff_head *namedq,
+			 struct tipc_link *bc_sndlink,
 			 struct tipc_link **link);
 void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
 			   int mtyp, struct sk_buff_head *xmitq);
-void tipc_link_build_bcast_sync_msg(struct tipc_link *l,
-				    struct sk_buff_head *xmitq);
 void tipc_link_build_reset_msg(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_fsm_evt(struct tipc_link *l, int evt);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
@@ -264,9 +273,21 @@ int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
 int tipc_link_timeout(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_rcv(struct tipc_link *l, struct sk_buff *skb,
 		  struct sk_buff_head *xmitq);
-void tipc_link_build_ack_msg(struct tipc_link *l, struct sk_buff_head *xmitq);
-void tipc_link_add_bc_peer(struct tipc_link *l);
-void tipc_link_remove_bc_peer(struct tipc_link *l);
+int tipc_link_build_ack_msg(struct tipc_link *l, struct sk_buff_head *xmitq);
+void tipc_link_add_bc_peer(struct tipc_link *snd_l,
+			   struct tipc_link *uc_l,
+			   struct sk_buff_head *xmitq);
+void tipc_link_remove_bc_peer(struct tipc_link *snd_l,
+			      struct tipc_link *rcv_l,
+			      struct sk_buff_head *xmitq);
 int tipc_link_bc_peers(struct tipc_link *l);
-
+void tipc_link_bc_ack_rcv(struct tipc_link *l, u16 acked,
+			  struct sk_buff_head *xmitq);
+void tipc_link_build_bc_sync_msg(struct tipc_link *l,
+				 struct sk_buff_head *xmitq);
+void tipc_link_bc_init_rcv(struct tipc_link *l, struct tipc_msg *hdr);
+void tipc_link_bc_sync_rcv(struct tipc_link *l,   struct tipc_msg *hdr,
+			   struct sk_buff_head *xmitq);
+int tipc_link_bc_nack_rcv(struct tipc_link *l, struct sk_buff *skb,
+			  struct sk_buff_head *xmitq);
 #endif

commit fd556f209af53b9cdc45df8c467feb235376c4df
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 22 08:51:40 2015 -0400

    tipc: introduce capability bit for broadcast synchronization
    
    Until now, we have tried to support both the newer, dedicated broadcast
    synchronization mechanism along with the older, less safe, RESET_MSG/
    ACTIVATE_MSG based one. The latter method has turned out to be a hazard
    in a highly dynamic cluster, so we find it safer to disable it completely
    when we find that the former mechanism is supported by the peer node.
    
    For this purpose, we now introduce a new capabability bit,
    TIPC_BCAST_SYNCH, to inform any peer nodes that dedicated broadcast
    syncronization is supported by the present node. The new bit is conveyed
    between peers in the 'capabilities' field of neighbor discovery messages.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 9c4acc26b3b1..d23329db4b25 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -119,6 +119,7 @@ struct tipc_stats {
  * @keepalive_intv: link keepalive timer interval
  * @abort_limit: # of unacknowledged continuity probes needed to reset link
  * @state: current state of link FSM
+ * @peer_caps: bitmap describing capabilities of peer node
  * @silent_intv_cnt: # of timer intervals without any reception from peer
  * @proto_msg: template for control messages generated by link
  * @pmsg: convenience pointer to "proto_msg" field
@@ -162,6 +163,7 @@ struct tipc_link {
 	unsigned long keepalive_intv;
 	u32 abort_limit;
 	u32 state;
+	u16 peer_caps;
 	u32 silent_intv_cnt;
 	struct {
 		unchar hdr[INT_H_SIZE];
@@ -215,11 +217,11 @@ struct tipc_link {
 bool tipc_link_create(struct tipc_node *n, char *if_name, int bearer_id,
 		      int tolerance, char net_plane, u32 mtu, int priority,
 		      int window, u32 session, u32 ownnode, u32 peer,
-		      struct tipc_media_addr *maddr,
+		      u16 peer_caps, struct tipc_media_addr *maddr,
 		      struct sk_buff_head *inputq, struct sk_buff_head *namedq,
 		      struct tipc_link **link);
 bool tipc_link_bc_create(struct tipc_node *n, int mtu, int window,
-			 struct sk_buff_head *inputq,
+			 u16 peer_caps, struct sk_buff_head *inputq,
 			 struct sk_buff_head *namedq,
 			 struct tipc_link **link);
 void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,

commit 2f566124570625c29c3fd79bac4d9cd97c0c31a1
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 22 08:51:39 2015 -0400

    tipc: let broadcast transmission use new link transmit function
    
    This commit simplifies the broadcast link transmission function, by
    leveraging previous changes to the link transmission function and the
    broadcast transmission link life cycle.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index be24d1fd5132..9c4acc26b3b1 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -262,5 +262,9 @@ int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
 int tipc_link_timeout(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_rcv(struct tipc_link *l, struct sk_buff *skb,
 		  struct sk_buff_head *xmitq);
+void tipc_link_build_ack_msg(struct tipc_link *l, struct sk_buff_head *xmitq);
+void tipc_link_add_bc_peer(struct tipc_link *l);
+void tipc_link_remove_bc_peer(struct tipc_link *l);
+int tipc_link_bc_peers(struct tipc_link *l);
 
 #endif

commit c1ab3f1dea3df566ad38caf98baf69c656679090
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 22 08:51:38 2015 -0400

    tipc: make struct tipc_link generic to support broadcast
    
    Realizing that unicast is just a special case of broadcast, we also see
    that we can go in the other direction, i.e., that modest changes to the
    current unicast link can make it generic enough to support broadcast.
    
    The following changes are introduced here:
    
    - A new counter ("ackers") in struct tipc_link, to indicate how many
      peers need to ack a packet before it can be released.
    - A corresponding counter in the skb user area, to keep track of how
      many peers a are left to ack before a buffer can be released.
    - A new counter ("acked"), to keep persistent track of how far a peer
      has acked at the moment, i.e., where in the transmission queue to
      start updating buffers when the next ack arrives. This is to avoid
      double acknowledgements from a peer, with inadvertent relase of
      packets as a result.
    - A more generic tipc_link_retrans() function, where retransmit starts
      from a given sequence number, instead of the first packet in the
      transmision queue. This is to minimize the number of retransmitted
      packets on the broadcast media.
    
    When the new functionality is taken into use in the next commits,
    we expect it to have minimal effect on unicast mode performance.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 9e4e3673da76..be24d1fd5132 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -134,6 +134,8 @@ struct tipc_stats {
  * @snt_nxt: next sequence number to use for outbound messages
  * @last_retransmitted: sequence number of most recently retransmitted message
  * @stale_count: # of identical retransmit requests made by peer
+ * @ackers: # of peers that needs to ack each packet before it can be released
+ * @acked: # last packet acked by a certain peer. Used for broadcast.
  * @rcv_nxt: next sequence number to expect for inbound messages
  * @deferred_queue: deferred queue saved OOS b'cast message received from node
  * @unacked_window: # of inbound messages rx'd without ack'ing back to peer
@@ -143,6 +145,7 @@ struct tipc_stats {
  * @wakeupq: linked list of wakeup msgs waiting for link congestion to abate
  * @long_msg_seq_no: next identifier to use for outbound fragmented messages
  * @reasm_buf: head of partially reassembled inbound message fragments
+ * @bc_rcvr: marks that this is a broadcast receiver link
  * @stats: collects statistics regarding link activity
  */
 struct tipc_link {
@@ -201,6 +204,10 @@ struct tipc_link {
 	/* Fragmentation/reassembly */
 	struct sk_buff *reasm_buf;
 
+	/* Broadcast */
+	u16 ackers;
+	u16 acked;
+
 	/* Statistics */
 	struct tipc_stats stats;
 };

commit 323019069e8d96d87e9dba51f897060f94999821
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 22 08:51:37 2015 -0400

    tipc: use explicit allocation of broadcast send link
    
    The broadcast link instance (struct tipc_link) used for sending is
    currently aggregated into struct tipc_bclink. This means that we cannot
    use the regular tipc_link_create() function for initiating the link, but
    do instead have to initiate numerous fields directly from the
    bcast_init() function.
    
    We want to reduce dependencies between the broadcast functionality
    and the inner workings of tipc_link. In this commit, we introduce
    a new function tipc_bclink_create() to link.c, and allocate the
    instance of the link separately using this function.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 06bf66df9469..9e4e3673da76 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -211,6 +211,10 @@ bool tipc_link_create(struct tipc_node *n, char *if_name, int bearer_id,
 		      struct tipc_media_addr *maddr,
 		      struct sk_buff_head *inputq, struct sk_buff_head *namedq,
 		      struct tipc_link **link);
+bool tipc_link_bc_create(struct tipc_node *n, int mtu, int window,
+			 struct sk_buff_head *inputq,
+			 struct sk_buff_head *namedq,
+			 struct tipc_link **link);
 void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
 			   int mtyp, struct sk_buff_head *xmitq);
 void tipc_link_build_bcast_sync_msg(struct tipc_link *l,

commit 0e05498e9eae16a6d8c86543e77930ec152e655e
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 22 08:51:36 2015 -0400

    tipc: make link implementation independent from struct tipc_bearer
    
    In reality, the link implementation is already independent from
    struct tipc_bearer, in that it doesn't store any reference to it.
    However, we still pass on a pointer to a bearer instance in the
    function tipc_link_create(), just to have it extract some
    initialization information from it.
    
    I later commits, we need to create instances of tipc_link without
    having any associated struct tipc_bearer. To facilitate this, we
    want to extract the initialization data already in the creator
    function in node.c, before calling tipc_link_create(), and pass
    this info on as individual parameters in the call.
    
    This commit introduces this change.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 0201212cb49a..06bf66df9469 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -205,8 +205,10 @@ struct tipc_link {
 	struct tipc_stats stats;
 };
 
-bool tipc_link_create(struct tipc_node *n, struct tipc_bearer *b, u32 session,
-		      u32 ownnode, u32 peer, struct tipc_media_addr *maddr,
+bool tipc_link_create(struct tipc_node *n, char *if_name, int bearer_id,
+		      int tolerance, char net_plane, u32 mtu, int priority,
+		      int window, u32 session, u32 ownnode, u32 peer,
+		      struct tipc_media_addr *maddr,
 		      struct sk_buff_head *inputq, struct sk_buff_head *namedq,
 		      struct tipc_link **link);
 void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,

commit c819930090fe3f74c822be765c185b3431360193
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 15 14:52:46 2015 -0400

    tipc: update node FSM when peer RESET message is received
    
    The change made in the previous commit revealed a small flaw in the way
    the node FSM is updated. When the function tipc_node_link_down() is
    called for the last link to a node, we should check whether this was
    caused by a local reset or by a received RESET message from the peer.
    In the latter case, we can directly issue a PEER_LOST_CONTACT_EVT to
    the node FSM, so that it is ready to re-establish contact. If this is
    not done, the peer node will sometimes have to go through a second
    establish cycle before the link becomes stable.
    
    We fix this in this commit by conditionally issuing the mentioned
    event in the function tipc_node_link_down(). We also move LINK_RESET
    FSM even away from the link_reset() function and into the caller
    function, partially because it is easier to follow the code when state
    changes are gathered at a limited number of locations, partially
    because there will be cases in future commits where we don't want the
    link to go RESET mode when link_reset() is called.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 5872f090c8d8..0201212cb49a 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -217,6 +217,7 @@ void tipc_link_build_reset_msg(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_fsm_evt(struct tipc_link *l, int evt);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 bool tipc_link_is_up(struct tipc_link *l);
+bool tipc_link_peer_is_down(struct tipc_link *l);
 bool tipc_link_is_reset(struct tipc_link *l);
 bool tipc_link_is_establishing(struct tipc_link *l);
 bool tipc_link_is_synching(struct tipc_link *l);

commit 282b3a056225b35024246f63feb91d769d714dad
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 15 14:52:45 2015 -0400

    tipc: send out RESET immediately when link goes down
    
    When a link is taken down because of a node local event, such as
    disabling of a bearer or an interface, we currently leave it to the
    peer node to discover the broken communication. The default time for
    such failure discovery is 1.5-2 seconds.
    
    If we instead allow the terminating link endpoint to send out a RESET
    message at the moment it is reset, we can achieve the impression that
    both endpoints are going down instantly. Since this is a very common
    scenario, we find it worthwhile to make this small modification.
    
    Apart from letting the link produce the said message, we also have to
    ensure that the interface is able to transmit it before TIPC is
    detached. We do this by performing the disabling of a bearer in three
    steps:
    
    1) Disable reception of TIPC packets from the interface in question.
    2) Take down the links, while allowing them so send out a RESET message.
    3) Disable transmission of TIPC packets on the interface.
    
    Apart from this, we now have to react on the NETDEV_GOING_DOWN event,
    instead of as currently the NEDEV_DOWN event, to ensure that such
    transmission is possible during the teardown phase.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index d42dfc0e7bf5..5872f090c8d8 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -213,6 +213,7 @@ void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
 			   int mtyp, struct sk_buff_head *xmitq);
 void tipc_link_build_bcast_sync_msg(struct tipc_link *l,
 				    struct sk_buff_head *xmitq);
+void tipc_link_build_reset_msg(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_fsm_evt(struct tipc_link *l, int evt);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 bool tipc_link_is_up(struct tipc_link *l);

commit 73f646cec35477b5099d7e952297cb9e1855be45
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 15 14:52:44 2015 -0400

    tipc: delay ESTABLISH state event when link is established
    
    Link establishing, just like link teardown, is a non-atomic action, in
    the sense that discovering that conditions are right to establish a link,
    and the actual adding of the link to one of the node's send slots is done
    in two different lock contexts. The link FSM is designed to help bridging
    the gap between the two contexts in a safe manner.
    
    We have now discovered a weakness in the implementaton of this FSM.
    Because we directly let the link go from state LINK_ESTABLISHING to
    state LINK_ESTABLISHED already in the first lock context, we are unable
    to distinguish between a fully established link, i.e., a link that has
    been added to its slot, and a link that has not yet reached the second
    lock context. It may hence happen that a manual intervention, e.g., when
    disabling an interface, causes the function tipc_node_link_down() to try
    removing the link from the node slots, decrementing its active link
    counter etc, although the link was never added there in the first place.
    
    We solve this by delaying the actual state change until we reach the
    second lock context, inside the function tipc_node_link_up(). This
    makes it possible for potentail callers of __tipc_node_link_down() to
    know if they should proceed or not, and the problem is solved.
    
    Unforunately, the situation described above also has a second problem.
    Since there by necessity is a tipc_node_link_up() call pending once
    the node lock has been released, we must defuse that call by setting
    the link back from LINK_ESTABLISHING to LINK_RESET state. This forces
    us to make a slight modification to the link FSM, which will now look
    as follows.
    
     +------------------------------------+
     |RESET_EVT                           |
     |                                    |
     |                             +--------------+
     |           +-----------------|   SYNCHING   |-----------------+
     |           |FAILURE_EVT      +--------------+   PEER_RESET_EVT|
     |           |                  A            |                  |
     |           |                  |            |                  |
     |           |                  |            |                  |
     |           |                  |SYNCH_      |SYNCH_            |
     |           |                  |BEGIN_EVT   |END_EVT           |
     |           |                  |            |                  |
     |           V                  |            V                  V
     |    +-------------+          +--------------+          +------------+
     |    |  RESETTING  |<---------|  ESTABLISHED |--------->| PEER_RESET |
     |    +-------------+ FAILURE_ +--------------+ PEER_    +------------+
     |           |        EVT        |    A         RESET_EVT       |
     |           |                   |    |                         |
     |           |  +----------------+    |                         |
     |  RESET_EVT|  |RESET_EVT            |                         |
     |           |  |                     |                         |
     |           |  |                     |ESTABLISH_EVT            |
     |           |  |  +-------------+    |                         |
     |           |  |  | RESET_EVT   |    |                         |
     |           |  |  |             |    |                         |
     |           V  V  V             |    |                         |
     |    +-------------+          +--------------+        RESET_EVT|
     +--->|    RESET    |--------->| ESTABLISHING |<----------------+
          +-------------+ PEER_    +--------------+
           |           A  RESET_EVT       |
           |           |                  |
           |           |                  |
           |FAILOVER_  |FAILOVER_         |FAILOVER_
           |BEGIN_EVT  |END_EVT           |BEGIN_EVT
           |           |                  |
           V           |                  |
          +-------------+                 |
          | FAILINGOVER |<----------------+
          +-------------+
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 7a1ad4294b7a..d42dfc0e7bf5 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -217,6 +217,7 @@ int tipc_link_fsm_evt(struct tipc_link *l, int evt);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 bool tipc_link_is_up(struct tipc_link *l);
 bool tipc_link_is_reset(struct tipc_link *l);
+bool tipc_link_is_establishing(struct tipc_link *l);
 bool tipc_link_is_synching(struct tipc_link *l);
 bool tipc_link_is_failingover(struct tipc_link *l);
 bool tipc_link_is_blocked(struct tipc_link *l);

commit 81204c492b05274ade680c54787cd8ba234dcfd7
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Oct 15 14:52:42 2015 -0400

    tipc: improve sequence number checking
    
    The sequence number of an incoming packet is currently only checked
    for less than, equality to, or bigger than the next expected number,
    meaning that the receive window in practice becomes one half sequence
    number cycle, or U16_MAX/2. This does not make sense, and may not even
    be safe if there are extreme delays in the network. Any packet sent by
    the peer during the ongoing cycle must belong inside his current send
    window, or should otherwise be dropped if possible.
    
    Since a link endpoint cannot know its peer's current send window, it
    has to base this sanity check on a worst-case assumption, i.e., that
    the peer is using a maximum sized window of 8191 packets. Using this
    assumption, we now add a check that the sequence number is not bigger
    than next_expected + TIPC_MAX_LINK_WIN. We also re-order the checks
    done, so that the receive window test is performed before the gap test.
    This way, we are guaranteed that no packet with illegal sequence numbers
    are ever added to the deferred queue.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 39ff8b6919a4..7a1ad4294b7a 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -185,7 +185,7 @@ struct tipc_link {
 	} backlog[5];
 	u16 snd_nxt;
 	u16 last_retransm;
-	u32 window;
+	u16 window;
 	u32 stale_count;
 
 	/* Reception */

commit 440d8963cd590ec9387d76a36e60c02da9ed944d
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 30 18:24:26 2015 -0400

    tipc: clean up link creation
    
    We simplify the link creation function tipc_link_create() and the way
    the link struct it is connected to the node struct. In particular, we
    remove the duplicate initialization of some fields which are anyway set
    in tipc_link_reset().
    
    Tested-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 39b8c4c5121e..39ff8b6919a4 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -148,7 +148,7 @@ struct tipc_stats {
 struct tipc_link {
 	u32 addr;
 	char name[TIPC_MAX_LINK_NAME];
-	struct tipc_media_addr media_addr;
+	struct tipc_media_addr *media_addr;
 	struct tipc_node *owner;
 
 	/* Management and link supervision data */
@@ -205,13 +205,10 @@ struct tipc_link {
 	struct tipc_stats stats;
 };
 
-struct tipc_port;
-
-struct tipc_link *tipc_link_create(struct tipc_node *n,
-				   struct tipc_bearer *b,
-				   const struct tipc_media_addr *maddr,
-				   struct sk_buff_head *inputq,
-				   struct sk_buff_head *namedq);
+bool tipc_link_create(struct tipc_node *n, struct tipc_bearer *b, u32 session,
+		      u32 ownnode, u32 peer, struct tipc_media_addr *maddr,
+		      struct sk_buff_head *inputq, struct sk_buff_head *namedq,
+		      struct tipc_link **link);
 void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
 			   int mtyp, struct sk_buff_head *xmitq);
 void tipc_link_build_bcast_sync_msg(struct tipc_link *l,
@@ -246,13 +243,8 @@ int tipc_nl_link_get(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_link_set(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_link_reset_stats(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
-void link_prepare_wakeup(struct tipc_link *l);
 int tipc_link_timeout(struct tipc_link *l, struct sk_buff_head *xmitq);
 int tipc_link_rcv(struct tipc_link *l, struct sk_buff *skb,
 		  struct sk_buff_head *xmitq);
-static inline u32 link_own_addr(struct tipc_link *l)
-{
-	return msg_prevnode(l->pmsg);
-}
 
 #endif

commit 662921cd0a53db4504838dfbb7d996f9e6e94001
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 30 18:24:21 2015 -0400

    tipc: merge link->exec_mode and link->state into one FSM
    
    Until now, we have been handling link failover and synchronization
    by using an additional link state variable, "exec_mode". This variable
    is not independent of the link FSM state, something causing a risk of
    inconsistencies, apart from the fact that it clutters the code.
    
    The conditions are now in place to define a new link FSM that covers
    all existing use cases, including failover and synchronization, and
    eliminate the "exec_mode" field altogether. The FSM must also support
    non-atomic resetting of links, which will be introduced later.
    
    The new link FSM is shown below, with 7 states and 8 events.
    Only events leading to state change are shown as edges.
    
    +------------------------------------+
    |RESET_EVT                           |
    |                                    |
    |                             +--------------+
    |           +-----------------|   SYNCHING   |-----------------+
    |           |FAILURE_EVT      +--------------+   PEER_RESET_EVT|
    |           |                  A            |                  |
    |           |                  |            |                  |
    |           |                  |            |                  |
    |           |                  |SYNCH_      |SYNCH_            |
    |           |                  |BEGIN_EVT   |END_EVT           |
    |           |                  |            |                  |
    |           V                  |            V                  V
    |    +-------------+          +--------------+          +------------+
    |    |  RESETTING  |<---------|  ESTABLISHED |--------->| PEER_RESET |
    |    +-------------+ FAILURE_ +--------------+ PEER_    +------------+
    |           |        EVT        |    A         RESET_EVT       |
    |           |                   |    |                         |
    |           |                   |    |                         |
    |           |    +--------------+    |                         |
    |  RESET_EVT|    |RESET_EVT          |ESTABLISH_EVT            |
    |           |    |                   |                         |
    |           |    |                   |                         |
    |           V    V                   |                         |
    |    +-------------+          +--------------+        RESET_EVT|
    +--->|    RESET    |--------->| ESTABLISHING |<----------------+
         +-------------+ PEER_    +--------------+
          |           A  RESET_EVT       |
          |           |                  |
          |           |                  |
          |FAILOVER_  |FAILOVER_         |FAILOVER_
          |BEGIN_EVT  |END_EVT           |BEGIN_EVT
          |           |                  |
          V           |                  |
         +-------------+                 |
         | FAILINGOVER |<----------------+
         +-------------+
    
    These changes are fully backwards compatible.
    
    Tested-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index b317c4df9079..39b8c4c5121e 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -49,13 +49,17 @@
  */
 #define INVALID_LINK_SEQ 0x10000
 
-
-/* Link endpoint receive states
+/* Link FSM events:
  */
 enum {
-	TIPC_LINK_OPEN,
-	TIPC_LINK_BLOCKED,
-	TIPC_LINK_TUNNEL
+	LINK_ESTABLISH_EVT       = 0xec1ab1e,
+	LINK_PEER_RESET_EVT      = 0x9eed0e,
+	LINK_FAILURE_EVT         = 0xfa110e,
+	LINK_RESET_EVT           = 0x10ca1d0e,
+	LINK_FAILOVER_BEGIN_EVT  = 0xfa110bee,
+	LINK_FAILOVER_END_EVT    = 0xfa110ede,
+	LINK_SYNCH_BEGIN_EVT     = 0xc1ccbee,
+	LINK_SYNCH_END_EVT       = 0xc1ccede
 };
 
 /* Events returned from link at packet reception or at timeout
@@ -120,7 +124,6 @@ struct tipc_stats {
  * @pmsg: convenience pointer to "proto_msg" field
  * @priority: current link priority
  * @net_plane: current link network plane ('A' through 'H')
- * @exec_mode: transmit/receive mode for link endpoint instance
  * @backlog_limit: backlog queue congestion thresholds (indexed by importance)
  * @exp_msg_count: # of tunnelled messages expected during link changeover
  * @reset_rcv_checkpt: seq # of last acknowledged message at time of link reset
@@ -155,7 +158,7 @@ struct tipc_link {
 	u32 tolerance;
 	unsigned long keepalive_intv;
 	u32 abort_limit;
-	int state;
+	u32 state;
 	u32 silent_intv_cnt;
 	struct {
 		unchar hdr[INT_H_SIZE];
@@ -166,7 +169,6 @@ struct tipc_link {
 	char net_plane;
 
 	/* Failover/synch */
-	u8 exec_mode;
 	u16 drop_point;
 	struct sk_buff *failover_reasm_skb;
 
@@ -214,8 +216,13 @@ void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
 			   int mtyp, struct sk_buff_head *xmitq);
 void tipc_link_build_bcast_sync_msg(struct tipc_link *l,
 				    struct sk_buff_head *xmitq);
+int tipc_link_fsm_evt(struct tipc_link *l, int evt);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
-int tipc_link_is_up(struct tipc_link *l_ptr);
+bool tipc_link_is_up(struct tipc_link *l);
+bool tipc_link_is_reset(struct tipc_link *l);
+bool tipc_link_is_synching(struct tipc_link *l);
+bool tipc_link_is_failingover(struct tipc_link *l);
+bool tipc_link_is_blocked(struct tipc_link *l);
 int tipc_link_is_active(struct tipc_link *l_ptr);
 void tipc_link_purge_queues(struct tipc_link *l_ptr);
 void tipc_link_purge_backlog(struct tipc_link *l);

commit 5045f7b9009f1455268b98cecbcc271663934c85
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 30 18:24:20 2015 -0400

    tipc: move protocol message sending away from link FSM
    
    The implementation of the link FSM currently takes decisions about and
    sends out link protocol messages. This is unnecessary, since such
    actions are not the result of any link state change, and are even
    decided based on non-FSM state information ("silent_intv_cnt").
    
    We now move the sending of unicast link protocol messages to the
    function tipc_link_timeout(), and the initial broadcast synchronization
    message to tipc_node_link_up(). The latter is done because a link
    instance should not need to know whether it is the first or second
    link to a destination. Such information is now restricted to and
    handled by the link aggregation layer in node.c
    
    Tested-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index e377d9ba41c5..b317c4df9079 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -212,6 +212,8 @@ struct tipc_link *tipc_link_create(struct tipc_node *n,
 				   struct sk_buff_head *namedq);
 void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
 			   int mtyp, struct sk_buff_head *xmitq);
+void tipc_link_build_bcast_sync_msg(struct tipc_link *l,
+				    struct sk_buff_head *xmitq);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);

commit 6e498158a827fd515b514842e9a06bdf0f75ab86
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 30 18:24:19 2015 -0400

    tipc: move link synch and failover to link aggregation level
    
    Link failover and synchronization have until now been handled by the
    links themselves, forcing them to have knowledge about and to access
    parallel links in order to make the two algorithms work correctly.
    
    In this commit, we move the control part of this functionality to the
    link aggregation level in node.c, which is the right location for this.
    As a result, the two algorithms become easier to follow, and the link
    implementation becomes simpler.
    
    Tested-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index bb1378b7cb59..e377d9ba41c5 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -164,13 +164,11 @@ struct tipc_link {
 	struct tipc_msg *pmsg;
 	u32 priority;
 	char net_plane;
-	u8 exec_mode;
-	u16 synch_point;
 
-	/* Failover */
-	u16 failover_pkts;
-	u16 failover_checkpt;
-	struct sk_buff *failover_skb;
+	/* Failover/synch */
+	u8 exec_mode;
+	u16 drop_point;
+	struct sk_buff *failover_reasm_skb;
 
 	/* Max packet negotiation */
 	u16 mtu;
@@ -212,8 +210,8 @@ struct tipc_link *tipc_link_create(struct tipc_node *n,
 				   const struct tipc_media_addr *maddr,
 				   struct sk_buff_head *inputq,
 				   struct sk_buff_head *namedq);
-void tipc_link_failover_send_queue(struct tipc_link *l_ptr);
-void tipc_link_dup_queue_xmit(struct tipc_link *l_ptr, struct tipc_link *dest);
+void tipc_link_tnl_prepare(struct tipc_link *l, struct tipc_link *tnl,
+			   int mtyp, struct sk_buff_head *xmitq);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);

commit 6144a996a65199480eed7521c1c50590c282e78e
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 30 18:24:16 2015 -0400

    tipc: move all link_reset() calls to link aggregation level
    
    In line with our effort to let the node level have full control over
    its links, we want to move all link reset calls from link.c to node.c.
    Some of the calls can be moved by simply moving the calling function,
    when this is the right thing to do. For the remaining calls we use
    the now established technique of returning a TIPC_LINK_DOWN_EVT
    flag from tipc_link_rcv(), whereafter we perform the reset call when
    the call returns.
    
    This change serves as a preparation for the coming commits.
    
    Tested-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 279196d6baac..bb1378b7cb59 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -212,8 +212,6 @@ struct tipc_link *tipc_link_create(struct tipc_node *n,
 				   const struct tipc_media_addr *maddr,
 				   struct sk_buff_head *inputq,
 				   struct sk_buff_head *namedq);
-void tipc_link_delete(struct tipc_link *link);
-void tipc_link_delete_list(struct net *net, unsigned int bearer_id);
 void tipc_link_failover_send_queue(struct tipc_link *l_ptr);
 void tipc_link_dup_queue_xmit(struct tipc_link *l_ptr, struct tipc_link *dest);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
@@ -221,7 +219,6 @@ int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);
 void tipc_link_purge_queues(struct tipc_link *l_ptr);
 void tipc_link_purge_backlog(struct tipc_link *l);
-void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
 int __tipc_link_xmit(struct net *net, struct tipc_link *link,
 		     struct sk_buff_head *list);

commit cbeb83ca68dcedf69b336fd1c5263658cbe5b51e
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 30 18:24:15 2015 -0400

    tipc: eliminate function tipc_link_activate()
    
    The function tipc_link_activate() is redundant, since it mostly performs
    settings that have already been done in a preceding tipc_link_reset().
    
    There are three exceptions to this:
    - The actual state change to TIPC_LINK_WORKING. This should anyway be done
      in the FSM, and not in a separate function.
    - Registration of the link with the bearer. This should be done by the
      node, since we don't want the link to have any knowledge about its
      specific bearer.
    - Call to tipc_node_link_up() for user access registration. With the new
      role distribution between link aggregation and link level this becomes
      the wrong call order; tipc_node_link_up() should instead be called
      directly as a result of a TIPC_LINK_UP event, hence by the node itself.
    
    This commit implements those changes.
    
    Tested-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 37cfd7d7bf7d..279196d6baac 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -223,7 +223,6 @@ void tipc_link_purge_queues(struct tipc_link *l_ptr);
 void tipc_link_purge_backlog(struct tipc_link *l);
 void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
-void tipc_link_activate(struct tipc_link *link);
 int __tipc_link_xmit(struct net *net, struct tipc_link *link,
 		     struct sk_buff_head *list);
 int tipc_link_xmit(struct tipc_link *link,	struct sk_buff_head *list,

commit d999297c3dbbe7fdd832f7fa4ec84301e170b3e6
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 16 16:54:31 2015 -0400

    tipc: reduce locking scope during packet reception
    
    We convert packet/message reception according to the same principle
    we have been using for message sending and timeout handling:
    
    We move the function tipc_rcv() to node.c, hence handling the initial
    packet reception at the link aggregation level. The function grabs
    the node lock, selects the receiving link, and accesses it via a new
    call tipc_link_rcv(). This function appends buffers to the input
    queue for delivery upwards, but it may also append outgoing packets
    to the xmit queue, just as we do during regular message sending. The
    latter will happen when buffers are forwarded from the link backlog,
    or when retransmission is requested.
    
    Upon return of this function, and after having released the node lock,
    tipc_rcv() delivers/tranmsits the contents of those queues, but it may
    also perform actions such as link activation or reset, as indicated by
    the return flags from the link.
    
    This reduces the number of cpu cycles spent inside the node spinlock,
    and reduces contention on that lock.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 0cf7d2b11803..37cfd7d7bf7d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -58,7 +58,7 @@ enum {
 	TIPC_LINK_TUNNEL
 };
 
-/* Events occurring at packet reception or at timeout
+/* Events returned from link at packet reception or at timeout
  */
 enum {
 	TIPC_LINK_UP_EVT       = 1,
@@ -223,6 +223,7 @@ void tipc_link_purge_queues(struct tipc_link *l_ptr);
 void tipc_link_purge_backlog(struct tipc_link *l);
 void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
+void tipc_link_activate(struct tipc_link *link);
 int __tipc_link_xmit(struct net *net, struct tipc_link *link,
 		     struct sk_buff_head *list);
 int tipc_link_xmit(struct tipc_link *link,	struct sk_buff_head *list,
@@ -244,7 +245,8 @@ int tipc_nl_link_reset_stats(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
 void link_prepare_wakeup(struct tipc_link *l);
 int tipc_link_timeout(struct tipc_link *l, struct sk_buff_head *xmitq);
-
+int tipc_link_rcv(struct tipc_link *l, struct sk_buff *skb,
+		  struct sk_buff_head *xmitq);
 static inline u32 link_own_addr(struct tipc_link *l)
 {
 	return msg_prevnode(l->pmsg);

commit 8a1577c96f122308ac9b5f195f9f9a7dd74ac541
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 16 16:54:29 2015 -0400

    tipc: move link supervision timer to node level
    
    In our effort to move control of the links to the link aggregation
    layer, we move the perodic link supervision timer to struct tipc_node.
    The new timer is shared between all links belonging to the node, thus
    saving resources, while still kicking the FSM on both its pertaining
    links at each expiration.
    
    The current link timer and corresponding functions are removed.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 98507b0f008d..0cf7d2b11803 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -146,9 +146,7 @@ struct tipc_link {
 	u32 addr;
 	char name[TIPC_MAX_LINK_NAME];
 	struct tipc_media_addr media_addr;
-	struct timer_list timer;
 	struct tipc_node *owner;
-	struct kref ref;
 
 	/* Management and link supervision data */
 	u32 peer_session;

commit 333ef69ed2121f535e00ceb26e095d3745584c6e
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 16 16:54:28 2015 -0400

    tipc: simplify link timer implementation
    
    We create a second, simpler, link timer function, tipc_link_timeout().
    The new function  makes use of the new FSM function introduced in the
    previous commit, and just like it, takes a buffer queue as parameter.
    It returns an event bit field and potentially a link protocol packet
    to the caller.
    
    The existing timer function, link_timeout(), is still needed for a
    while, so we redesign it to become a wrapper around the new function.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index ef68424f492d..98507b0f008d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -245,6 +245,7 @@ int tipc_nl_link_set(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_link_reset_stats(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
 void link_prepare_wakeup(struct tipc_link *l);
+int tipc_link_timeout(struct tipc_link *l, struct sk_buff_head *xmitq);
 
 static inline u32 link_own_addr(struct tipc_link *l)
 {

commit 6ab30f9cbe134d19559f48dc748587d036529aaf
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 16 16:54:27 2015 -0400

    tipc: improve link FSM implementation
    
    The link FSM implementation is currently unnecessarily complex.
    It sometimes checks for conditional state outside the FSM data
    before deciding next state, and often performs actions directly
    inside the FSM logics.
    
    In this commit, we create a second, simpler FSM implementation,
    that as far as possible acts only on states and events that it is
    strictly defined for, and postpone any actions until it is finished
    with its decisions. It also returns an event flag field and an a
    buffer queue which may potentially contain a protocol message to
    be sent by the caller.
    
    Unfortunately, we cannot yet make the FSM "clean", in the sense
    that its decisions are only based on FSM state and event, and that
    state changes happen only here. That will have to wait until the
    activate/reset logics has been cleaned up in a future commit.
    
    We also rename the link states as follows:
    
    WORKING_WORKING -> TIPC_LINK_WORKING
    WORKING_UNKNOWN -> TIPC_LINK_PROBING
    RESET_UNKNOWN   -> TIPC_LINK_RESETTING
    RESET_RESET     -> TIPC_LINK_ESTABLISHING
    
    The existing FSM function, link_state_event(), is still needed for
    a while, so we redesign it to make use of the new function.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 0509c6de03cd..ef68424f492d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -58,6 +58,13 @@ enum {
 	TIPC_LINK_TUNNEL
 };
 
+/* Events occurring at packet reception or at timeout
+ */
+enum {
+	TIPC_LINK_UP_EVT       = 1,
+	TIPC_LINK_DOWN_EVT     = (1 << 1)
+};
+
 /* Starting value for maximum packet size negotiation on unicast links
  * (unless bearer MTU is less)
  */

commit d3504c3449fead545e5254bfb11da916f72c4734
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 16 16:54:25 2015 -0400

    tipc: clean up definitions and usage of link flags
    
    The status flag LINK_STOPPED is not needed any more, since the
    mechanism for delayed deletion of links has been removed.
    Likewise, LINK_STARTED and LINK_START_EVT are unnecessary,
    because we can just as well start the link timer directly from
    inside tipc_link_create().
    
    We eliminate these flags in this commit.
    
    Instead of the above flags, we now introduce three new link modes,
    TIPC_LINK_OPEN, TIPC_LINK_BLOCKED and TIPC_LINK_TUNNEL. The values
    indicate whether, and in the case of TIPC_LINK_TUNNEL, which, messages
    the link is allowed to receive in this state. TIPC_LINK_BLOCKED also
    blocks timer-driven protocol messages to be sent out, and any change
    to the link FSM. Since the modes are mutually exclusive, we convert
    them to state values, and rename the 'flags' field in struct tipc_link
    to 'exec_mode'.
    
    Finally, we move the #defines for link FSM states and events from link.h
    into enums inside the file link.c, which is the real usage scope of
    these definitions.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 7add2b90361d..0509c6de03cd 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -49,19 +49,14 @@
  */
 #define INVALID_LINK_SEQ 0x10000
 
-/* Link working states
- */
-#define WORKING_WORKING 560810u
-#define WORKING_UNKNOWN 560811u
-#define RESET_UNKNOWN   560812u
-#define RESET_RESET     560813u
 
-/* Link endpoint execution states
+/* Link endpoint receive states
  */
-#define LINK_STARTED     0x0001
-#define LINK_STOPPED     0x0002
-#define LINK_SYNCHING    0x0004
-#define LINK_FAILINGOVER 0x0008
+enum {
+	TIPC_LINK_OPEN,
+	TIPC_LINK_BLOCKED,
+	TIPC_LINK_TUNNEL
+};
 
 /* Starting value for maximum packet size negotiation on unicast links
  * (unless bearer MTU is less)
@@ -106,7 +101,6 @@ struct tipc_stats {
  * @timer: link timer
  * @owner: pointer to peer node
  * @refcnt: reference counter for permanent references (owner node & timer)
- * @flags: execution state flags for link endpoint instance
  * @peer_session: link session # being used by peer end of link
  * @peer_bearer_id: bearer id used by link's peer endpoint
  * @bearer_id: local bearer id used by link
@@ -119,6 +113,7 @@ struct tipc_stats {
  * @pmsg: convenience pointer to "proto_msg" field
  * @priority: current link priority
  * @net_plane: current link network plane ('A' through 'H')
+ * @exec_mode: transmit/receive mode for link endpoint instance
  * @backlog_limit: backlog queue congestion thresholds (indexed by importance)
  * @exp_msg_count: # of tunnelled messages expected during link changeover
  * @reset_rcv_checkpt: seq # of last acknowledged message at time of link reset
@@ -149,7 +144,6 @@ struct tipc_link {
 	struct kref ref;
 
 	/* Management and link supervision data */
-	unsigned int flags;
 	u32 peer_session;
 	u32 peer_bearer_id;
 	u32 bearer_id;
@@ -165,6 +159,7 @@ struct tipc_link {
 	struct tipc_msg *pmsg;
 	u32 priority;
 	char net_plane;
+	u8 exec_mode;
 	u16 synch_point;
 
 	/* Failover */
@@ -249,27 +244,4 @@ static inline u32 link_own_addr(struct tipc_link *l)
 	return msg_prevnode(l->pmsg);
 }
 
-/*
- * Link status checking routines
- */
-static inline int link_working_working(struct tipc_link *l_ptr)
-{
-	return l_ptr->state == WORKING_WORKING;
-}
-
-static inline int link_working_unknown(struct tipc_link *l_ptr)
-{
-	return l_ptr->state == WORKING_UNKNOWN;
-}
-
-static inline int link_reset_unknown(struct tipc_link *l_ptr)
-{
-	return l_ptr->state == RESET_UNKNOWN;
-}
-
-static inline int link_reset_reset(struct tipc_link *l_ptr)
-{
-	return l_ptr->state == RESET_RESET;
-}
-
 #endif

commit af9b028e270fda6fb812d70d17d902297df1ceb5
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 16 16:54:24 2015 -0400

    tipc: make media xmit call outside node spinlock context
    
    Currently, message sending is performed through a deep call chain,
    where the node spinlock is grabbed and held during a significant
    part of the transmission time. This is clearly detrimental to
    overall throughput performance; it would be better if we could send
    the message after the spinlock has been released.
    
    In this commit, we do instead let the call revert on the stack after
    the buffer chain has been added to the transmission queue, whereafter
    clones of the buffers are transmitted to the device layer outside the
    spinlock scope.
    
    As a further step in our effort to separate the roles of the node
    and link entities we also move the function tipc_link_xmit() to
    node.c, and rename it to tipc_node_xmit().
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 9c71d9e42e93..7add2b90361d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -223,12 +223,10 @@ void tipc_link_purge_queues(struct tipc_link *l_ptr);
 void tipc_link_purge_backlog(struct tipc_link *l);
 void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
-int tipc_link_xmit_skb(struct net *net, struct sk_buff *skb, u32 dest,
-		       u32 selector);
-int tipc_link_xmit(struct net *net, struct sk_buff_head *list, u32 dest,
-		   u32 selector);
 int __tipc_link_xmit(struct net *net, struct tipc_link *link,
 		     struct sk_buff_head *list);
+int tipc_link_xmit(struct tipc_link *link,	struct sk_buff_head *list,
+		   struct sk_buff_head *xmitq);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 			  u32 gap, u32 tolerance, u32 priority);
 void tipc_link_push_packets(struct tipc_link *l_ptr);

commit d39bbd445dc44259c77bbbc8aadcce7dcdba39cc
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Jul 16 16:54:21 2015 -0400

    tipc: move link input queue to tipc_node
    
    At present, the link input queue and the name distributor receive
    queues are fields aggregated in struct tipc_link. This is a hazard,
    because a link might be deleted while a receiving socket still keeps
    reference to one of the queues.
    
    This commit fixes this bug. However, rather than adding yet another
    reference counter to the critical data path, we move the two queues
    to safe ground inside struct tipc_node, which is already protected, and
    let the link code only handle references to the queues. This is also
    in line with planned later changes in this area.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index ae0a0ea572f2..9c71d9e42e93 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -192,8 +192,8 @@ struct tipc_link {
 	u16 rcv_nxt;
 	u32 rcv_unacked;
 	struct sk_buff_head deferdq;
-	struct sk_buff_head inputq;
-	struct sk_buff_head namedq;
+	struct sk_buff_head *inputq;
+	struct sk_buff_head *namedq;
 
 	/* Congestion handling */
 	struct sk_buff_head wakeupq;
@@ -207,9 +207,11 @@ struct tipc_link {
 
 struct tipc_port;
 
-struct tipc_link *tipc_link_create(struct tipc_node *n_ptr,
-			      struct tipc_bearer *b_ptr,
-			      const struct tipc_media_addr *media_addr);
+struct tipc_link *tipc_link_create(struct tipc_node *n,
+				   struct tipc_bearer *b,
+				   const struct tipc_media_addr *maddr,
+				   struct sk_buff_head *inputq,
+				   struct sk_buff_head *namedq);
 void tipc_link_delete(struct tipc_link *link);
 void tipc_link_delete_list(struct net *net, unsigned int bearer_id);
 void tipc_link_failover_send_queue(struct tipc_link *l_ptr);

commit 7d967b673c2ff992205be051ffebc39e1a323400
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Sun Jun 28 09:44:44 2015 -0400

    tipc: purge backlog queue counters when broadcast link is reset
    
    In commit 1f66d161ab3d8b518903fa6c3f9c1f48d6919e74
    ("tipc: introduce starvation free send algorithm")
    we introduced a counter per priority level for buffers
    in the link backlog queue. We also introduced a new
    function tipc_link_purge_backlog(), to reset these
    counters to zero when the link is reset.
    
    Unfortunately, we missed to call this function when
    the broadcast link is reset, with the result that the
    values of these counters might be permanently skewed
    when new nodes are attached. This may in the worst case
    lead to permananent, but spurious, broadcast link
    congestion, where no broadcast packets can be sent at
    all.
    
    We fix this bug with this commit.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 0c02c973e985..ae0a0ea572f2 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -218,6 +218,7 @@ void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);
 void tipc_link_purge_queues(struct tipc_link *l_ptr);
+void tipc_link_purge_backlog(struct tipc_link *l);
 void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
 int tipc_link_xmit_skb(struct net *net, struct sk_buff *skb, u32 dest,

commit cd4eee3c2e3e01590df5cada0d56b396dd726d05
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu May 14 10:46:16 2015 -0400

    tipc: simplify link supervision checkpointing
    
    We change the sequence number checkpointing that is performed
    by the timer in order to discover if the peer is active. Currently,
    we store a checkpoint of the next expected sequence number "rcv_nxt"
    at each timer expiration, and compare it to the current expected
    number at next timeout expiration. Instead, we now use the already
    existing field "silent_intv_cnt" for this task. We step the counter
    at each timeout expiration, and zero it at each valid received packet.
    If no valid packet has been received from the peer after "abort_limit"
    number of silent timer intervals, the link is declared faulty and reset.
    
    We also remove the multiple instances of timer activation from inside
    the FSM function "link_state_event()", and now do it at only one place;
    at the end of the timer function itself.
    
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 74d2d12fc120..0c02c973e985 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -107,7 +107,6 @@ struct tipc_stats {
  * @owner: pointer to peer node
  * @refcnt: reference counter for permanent references (owner node & timer)
  * @flags: execution state flags for link endpoint instance
- * @checkpoint: reference point for triggering link continuity checking
  * @peer_session: link session # being used by peer end of link
  * @peer_bearer_id: bearer id used by link's peer endpoint
  * @bearer_id: local bearer id used by link
@@ -151,7 +150,6 @@ struct tipc_link {
 
 	/* Management and link supervision data */
 	unsigned int flags;
-	u16 checkpoint;
 	u32 peer_session;
 	u32 peer_bearer_id;
 	u32 bearer_id;

commit a97b9d3fa9bce0d78dc83a14a9e1ebb3bf5cc414
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu May 14 10:46:15 2015 -0400

    tipc: rename fields in struct tipc_link
    
    We rename some fields in struct tipc_link, in order to give them more
    descriptive names:
    
    next_in_no -> rcv_nxt
    next_out_no-> snd_nxt
    fsm_msg_cnt-> silent_intv_cnt
    cont_intv  -> keepalive_intv
    last_retransmitted -> last_retransm
    
    There are no functional changes in this commit.
    
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index a65770bf647c..74d2d12fc120 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -112,25 +112,25 @@ struct tipc_stats {
  * @peer_bearer_id: bearer id used by link's peer endpoint
  * @bearer_id: local bearer id used by link
  * @tolerance: minimum link continuity loss needed to reset link [in ms]
- * @cont_intv: link continuity testing interval
+ * @keepalive_intv: link keepalive timer interval
  * @abort_limit: # of unacknowledged continuity probes needed to reset link
  * @state: current state of link FSM
- * @fsm_msg_cnt: # of protocol messages link FSM has sent in current state
+ * @silent_intv_cnt: # of timer intervals without any reception from peer
  * @proto_msg: template for control messages generated by link
  * @pmsg: convenience pointer to "proto_msg" field
  * @priority: current link priority
  * @net_plane: current link network plane ('A' through 'H')
  * @backlog_limit: backlog queue congestion thresholds (indexed by importance)
  * @exp_msg_count: # of tunnelled messages expected during link changeover
- * @reset_checkpoint: seq # of last acknowledged message at time of link reset
+ * @reset_rcv_checkpt: seq # of last acknowledged message at time of link reset
  * @mtu: current maximum packet size for this link
  * @advertised_mtu: advertised own mtu when link is being established
  * @transmitq: queue for sent, non-acked messages
  * @backlogq: queue for messages waiting to be sent
- * @next_out_no: next sequence number to use for outbound messages
+ * @snt_nxt: next sequence number to use for outbound messages
  * @last_retransmitted: sequence number of most recently retransmitted message
  * @stale_count: # of identical retransmit requests made by peer
- * @next_in_no: next sequence number to expect for inbound messages
+ * @rcv_nxt: next sequence number to expect for inbound messages
  * @deferred_queue: deferred queue saved OOS b'cast message received from node
  * @unacked_window: # of inbound messages rx'd without ack'ing back to peer
  * @inputq: buffer queue for messages to be delivered upwards
@@ -156,10 +156,10 @@ struct tipc_link {
 	u32 peer_bearer_id;
 	u32 bearer_id;
 	u32 tolerance;
-	unsigned long cont_intv;
+	unsigned long keepalive_intv;
 	u32 abort_limit;
 	int state;
-	u32 fsm_msg_cnt;
+	u32 silent_intv_cnt;
 	struct {
 		unchar hdr[INT_H_SIZE];
 		unchar body[TIPC_MAX_IF_NAME];
@@ -185,13 +185,13 @@ struct tipc_link {
 		u16 len;
 		u16 limit;
 	} backlog[5];
-	u16 next_out_no;
-	u16 last_retransmitted;
+	u16 snd_nxt;
+	u16 last_retransm;
 	u32 window;
 	u32 stale_count;
 
 	/* Reception */
-	u16 next_in_no;
+	u16 rcv_nxt;
 	u32 rcv_unacked;
 	struct sk_buff_head deferdq;
 	struct sk_buff_head inputq;

commit e4bf4f76962b0869d1048ac6c52a46e7d90eb46f
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu May 14 10:46:14 2015 -0400

    tipc: simplify packet sequence number handling
    
    Although the sequence number in the TIPC protocol is 16 bits, we have
    until now stored it internally as an unsigned 32 bits integer.
    We got around this by always doing explicit modulo-65535 operations
    whenever we need to access a sequence number.
    
    We now make the incoming and outgoing sequence numbers to unsigned
    16-bit integers, and remove the modulo operations where applicable.
    
    We also move the arithmetic inline functions for 16 bit integers
    to core.h, and the function buf_seqno() to msg.h, so they can easily
    be accessed from anywhere in the code.
    
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index dc27bb62b1f5..a65770bf647c 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -151,7 +151,7 @@ struct tipc_link {
 
 	/* Management and link supervision data */
 	unsigned int flags;
-	u32 checkpoint;
+	u16 checkpoint;
 	u32 peer_session;
 	u32 peer_bearer_id;
 	u32 bearer_id;
@@ -185,13 +185,13 @@ struct tipc_link {
 		u16 len;
 		u16 limit;
 	} backlog[5];
-	u32 next_out_no;
+	u16 next_out_no;
+	u16 last_retransmitted;
 	u32 window;
-	u32 last_retransmitted;
 	u32 stale_count;
 
 	/* Reception */
-	u32 next_in_no;
+	u16 next_in_no;
 	u32 rcv_unacked;
 	struct sk_buff_head deferdq;
 	struct sk_buff_head inputq;
@@ -245,39 +245,6 @@ int tipc_nl_link_reset_stats(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
 void link_prepare_wakeup(struct tipc_link *l);
 
-/*
- * Link sequence number manipulation routines (uses modulo 2**16 arithmetic)
- */
-static inline u32 buf_seqno(struct sk_buff *buf)
-{
-	return msg_seqno(buf_msg(buf));
-}
-
-static inline u32 mod(u32 x)
-{
-	return x & 0xffffu;
-}
-
-static inline int less_eq(u32 left, u32 right)
-{
-	return mod(right - left) < 32768u;
-}
-
-static inline int more(u32 left, u32 right)
-{
-	return !less_eq(left, right);
-}
-
-static inline int less(u32 left, u32 right)
-{
-	return less_eq(left, right) && (mod(right) != mod(left));
-}
-
-static inline u32 lesser(u32 left, u32 right)
-{
-	return less_eq(left, right) ? left : right;
-}
-
 static inline u32 link_own_addr(struct tipc_link *l)
 {
 	return msg_prevnode(l->pmsg);

commit b1c29f6b10d5981c89d3ea9b9991ca97141ed6d0
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu May 14 10:46:11 2015 -0400

    tipc: simplify resetting and disabling of bearers
    
    Since commit 4b475e3f2f8e4e241de101c8240f1d74d0470494
    ("tipc: eliminate delayed link deletion at link failover") the extra
    boolean parameter "shutting_down" is not any longer needed for the
    functions bearer_disable() and tipc_link_delete_list().
    
    Furhermore, the function tipc_link_reset_links(), called from
    bearer_reset()  is now unnecessary. We can just as well delete
    all the links, as we do in bearer_disable(), and start over with
    creating new links.
    
    This commit introduces those changes.
    
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index b5b4e3554d4e..dc27bb62b1f5 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -213,8 +213,7 @@ struct tipc_link *tipc_link_create(struct tipc_node *n_ptr,
 			      struct tipc_bearer *b_ptr,
 			      const struct tipc_media_addr *media_addr);
 void tipc_link_delete(struct tipc_link *link);
-void tipc_link_delete_list(struct net *net, unsigned int bearer_id,
-			   bool shutting_down);
+void tipc_link_delete_list(struct net *net, unsigned int bearer_id);
 void tipc_link_failover_send_queue(struct tipc_link *l_ptr);
 void tipc_link_dup_queue_xmit(struct tipc_link *l_ptr, struct tipc_link *dest);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
@@ -223,7 +222,6 @@ int tipc_link_is_active(struct tipc_link *l_ptr);
 void tipc_link_purge_queues(struct tipc_link *l_ptr);
 void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
-void tipc_link_reset_list(struct net *net, unsigned int bearer_id);
 int tipc_link_xmit_skb(struct net *net, struct sk_buff *skb, u32 dest,
 		       u32 selector);
 int tipc_link_xmit(struct net *net, struct sk_buff_head *list, u32 dest,

commit ed193ece2649c194a87a9d8470195760d367c075
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Apr 2 09:33:02 2015 -0400

    tipc: simplify link mtu negotiation
    
    When a link is being established, the two endpoints advertise their
    respective interface MTU in the transmitted RESET and ACTIVATE messages.
    If there is any difference, the lower of the two MTUs will be selected
    for use by both endpoints.
    
    However, as a remnant of earlier attempts to introduce TIPC level
    routing. there also exists an MTU discovery mechanism. If an intermediate
    node has a lower MTU than the two endpoints, they will discover this
    through a bisectional approach, and finally adopt this MTU for common use.
    
    Since there is no TIPC level routing, and probably never will be,
    this mechanism doesn't make any sense, and only serves to make the
    link level protocol unecessarily complex.
    
    In this commit, we eliminate the MTU discovery algorithm,and fall back
    to the simple MTU advertising approach. This change is fully backwards
    compatible.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 6e28f03c7905..b5b4e3554d4e 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -123,9 +123,8 @@ struct tipc_stats {
  * @backlog_limit: backlog queue congestion thresholds (indexed by importance)
  * @exp_msg_count: # of tunnelled messages expected during link changeover
  * @reset_checkpoint: seq # of last acknowledged message at time of link reset
- * @max_pkt: current maximum packet size for this link
- * @max_pkt_target: desired maximum packet size for this link
- * @max_pkt_probes: # of probes based on current (max_pkt, max_pkt_target)
+ * @mtu: current maximum packet size for this link
+ * @advertised_mtu: advertised own mtu when link is being established
  * @transmitq: queue for sent, non-acked messages
  * @backlogq: queue for messages waiting to be sent
  * @next_out_no: next sequence number to use for outbound messages
@@ -176,9 +175,8 @@ struct tipc_link {
 	struct sk_buff *failover_skb;
 
 	/* Max packet negotiation */
-	u32 max_pkt;
-	u32 max_pkt_target;
-	u32 max_pkt_probes;
+	u16 mtu;
+	u16 advertised_mtu;
 
 	/* Sending */
 	struct sk_buff_head transmq;
@@ -233,7 +231,7 @@ int tipc_link_xmit(struct net *net, struct sk_buff_head *list, u32 dest,
 int __tipc_link_xmit(struct net *net, struct tipc_link *link,
 		     struct sk_buff_head *list);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
-			  u32 gap, u32 tolerance, u32 priority, u32 acked_mtu);
+			  u32 gap, u32 tolerance, u32 priority);
 void tipc_link_push_packets(struct tipc_link *l_ptr);
 u32 tipc_link_defer_pkt(struct sk_buff_head *list, struct sk_buff *buf);
 void tipc_link_set_queue_limits(struct tipc_link *l_ptr, u32 window);

commit dff29b1a88524fe6afe296d6c477c491d1e02af0
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Apr 2 09:33:01 2015 -0400

    tipc: eliminate delayed link deletion at link failover
    
    When a bearer is disabled manually, all its links have to be reset
    and deleted. However, if there is a remaining, parallel link ready
    to take over a deleted link's traffic, we currently delay the delete
    of the removed link until the failover procedure is finished. This
    is because the remaining link needs to access state from the reset
    link, such as the last received packet number, and any partially
    reassembled buffer, in order to perform a successful failover.
    
    In this commit, we do instead move the state data over to the new
    link, so that it can fulfill the procedure autonomously, without
    accessing any data on the old link. This means that we can now
    proceed and delete all pertaining links immediately when a bearer
    is disabled. This saves us from some unnecessary complexity in such
    situations.
    
    We also choose to change the confusing definitions CHANGEOVER_PROTOCOL,
    ORIGINAL_MSG and DUPLICATE_MSG to the more descriptive TUNNEL_PROTOCOL,
    FAILOVER_MSG and SYNCH_MSG respectively.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index d2b5663643da..6e28f03c7905 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -58,9 +58,10 @@
 
 /* Link endpoint execution states
  */
-#define LINK_STARTED    0x0001
-#define LINK_STOPPED    0x0002
-#define LINK_SYNCHING   0x0004
+#define LINK_STARTED     0x0001
+#define LINK_STOPPED     0x0002
+#define LINK_SYNCHING    0x0004
+#define LINK_FAILINGOVER 0x0008
 
 /* Starting value for maximum packet size negotiation on unicast links
  * (unless bearer MTU is less)
@@ -167,11 +168,12 @@ struct tipc_link {
 	struct tipc_msg *pmsg;
 	u32 priority;
 	char net_plane;
+	u16 synch_point;
 
-	/* Changeover */
-	u32 exp_msg_count;
-	u32 reset_checkpoint;
-	u32 synch_point;
+	/* Failover */
+	u16 failover_pkts;
+	u16 failover_checkpt;
+	struct sk_buff *failover_skb;
 
 	/* Max packet negotiation */
 	u32 max_pkt;
@@ -201,7 +203,6 @@ struct tipc_link {
 	struct sk_buff_head wakeupq;
 
 	/* Fragmentation/reassembly */
-	u32 long_msg_seq_no;
 	struct sk_buff *reasm_buf;
 
 	/* Statistics */

commit 8b4ed8634f8b3f9aacfc42b4a872d30c36b9e255
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Wed Mar 25 12:07:26 2015 -0400

    tipc: eliminate race condition at dual link establishment
    
    Despite recent improvements, the establishment of dual parallel
    links still has a small glitch where messages can bypass each
    other. When the second link in a dual-link configuration is
    established, part of the first link's traffic will be steered over
    to the new link. Although we do have a mechanism to ensure that
    packets sent before and after the establishment of the new link
    arrive in sequence to the destination node, this is not enough.
    The arriving messages will still be delivered upwards in different
    threads, something entailing a risk of message disordering during
    the transition phase.
    
    To fix this, we introduce a synchronization mechanism between the
    two parallel links, so that traffic arriving on the new link cannot
    be added to its input queue until we are guaranteed that all
    pre-establishment messages have been delivered on the old, parallel
    link.
    
    This problem seems to always have been around, but its occurrence is
    so rare that it has not been noticed until recent intensive testing.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 99543a46095a..d2b5663643da 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -60,6 +60,7 @@
  */
 #define LINK_STARTED    0x0001
 #define LINK_STOPPED    0x0002
+#define LINK_SYNCHING   0x0004
 
 /* Starting value for maximum packet size negotiation on unicast links
  * (unless bearer MTU is less)
@@ -170,6 +171,7 @@ struct tipc_link {
 	/* Changeover */
 	u32 exp_msg_count;
 	u32 reset_checkpoint;
+	u32 synch_point;
 
 	/* Max packet negotiation */
 	u32 max_pkt;

commit 1f66d161ab3d8b518903fa6c3f9c1f48d6919e74
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Wed Mar 25 12:07:24 2015 -0400

    tipc: introduce starvation free send algorithm
    
    Currently, we only use a single counter; the length of the backlog
    queue, to determine whether a message should be accepted to the queue
    or not. Each time a message is being sent, the queue length is compared
    to a threshold value for the message's importance priority. If the queue
    length is beyond this threshold, the message is rejected. This algorithm
    implies a risk of starvation of low importance senders during very high
    load, because it may take a long time before the backlog queue has
    decreased enough to accept a lower level message.
    
    We now eliminate this risk by introducing a counter for each importance
    priority. When a message is sent, we check only the queue level for that
    particular message's priority. If that is ok, the message can be added
    to the backlog, irrespective of the queue level for other priorities.
    This way, each level is guaranteed a certain portion of the total
    bandwidth, and any risk of starvation is eliminated.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index eec3ecf2d450..99543a46095a 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -118,7 +118,7 @@ struct tipc_stats {
  * @pmsg: convenience pointer to "proto_msg" field
  * @priority: current link priority
  * @net_plane: current link network plane ('A' through 'H')
- * @queue_limit: outbound message queue congestion thresholds (indexed by user)
+ * @backlog_limit: backlog queue congestion thresholds (indexed by importance)
  * @exp_msg_count: # of tunnelled messages expected during link changeover
  * @reset_checkpoint: seq # of last acknowledged message at time of link reset
  * @max_pkt: current maximum packet size for this link
@@ -166,7 +166,6 @@ struct tipc_link {
 	struct tipc_msg *pmsg;
 	u32 priority;
 	char net_plane;
-	u32 queue_limit[15];	/* queue_limit[0]==window limit */
 
 	/* Changeover */
 	u32 exp_msg_count;
@@ -180,6 +179,10 @@ struct tipc_link {
 	/* Sending */
 	struct sk_buff_head transmq;
 	struct sk_buff_head backlogq;
+	struct {
+		u16 len;
+		u16 limit;
+	} backlog[5];
 	u32 next_out_no;
 	u32 window;
 	u32 last_retransmitted;

commit 05dcc5aa4dcced4f59f925625cea669e82b75519
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Fri Mar 13 16:08:10 2015 -0400

    tipc: split link outqueue
    
    struct tipc_link contains one single queue for outgoing packets,
    where both transmitted and waiting packets are queued.
    
    This infrastructure is hard to maintain, because we need
    to keep a number of fields to keep track of which packets are
    sent or unsent, and the number of packets in each category.
    
    A lot of code becomes simpler if we split this queue into a transmission
    queue, where sent/unacknowledged packets are kept, and a backlog queue,
    where we keep the not yet sent packets.
    
    In this commit we do this separation.
    
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 7aeb52092bf3..eec3ecf2d450 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -124,7 +124,8 @@ struct tipc_stats {
  * @max_pkt: current maximum packet size for this link
  * @max_pkt_target: desired maximum packet size for this link
  * @max_pkt_probes: # of probes based on current (max_pkt, max_pkt_target)
- * @outqueue: outbound message queue
+ * @transmitq: queue for sent, non-acked messages
+ * @backlogq: queue for messages waiting to be sent
  * @next_out_no: next sequence number to use for outbound messages
  * @last_retransmitted: sequence number of most recently retransmitted message
  * @stale_count: # of identical retransmit requests made by peer
@@ -177,20 +178,21 @@ struct tipc_link {
 	u32 max_pkt_probes;
 
 	/* Sending */
-	struct sk_buff_head outqueue;
+	struct sk_buff_head transmq;
+	struct sk_buff_head backlogq;
 	u32 next_out_no;
+	u32 window;
 	u32 last_retransmitted;
 	u32 stale_count;
 
 	/* Reception */
 	u32 next_in_no;
-	struct sk_buff_head deferred_queue;
-	u32 unacked_window;
+	u32 rcv_unacked;
+	struct sk_buff_head deferdq;
 	struct sk_buff_head inputq;
 	struct sk_buff_head namedq;
 
 	/* Congestion handling */
-	struct sk_buff *next_out;
 	struct sk_buff_head wakeupq;
 
 	/* Fragmentation/reassembly */
@@ -302,9 +304,4 @@ static inline int link_reset_reset(struct tipc_link *l_ptr)
 	return l_ptr->state == RESET_RESET;
 }
 
-static inline int link_congested(struct tipc_link *l_ptr)
-{
-	return skb_queue_len(&l_ptr->outqueue) >= l_ptr->queue_limit[0];
-}
-
 #endif

commit 1817877b3cd7b4dc73e4a1514d5f48eaa3989ec9
Author: Richard Alpe <richard.alpe@ericsson.com>
Date:   Mon Feb 9 09:50:09 2015 +0100

    tipc: convert legacy nl link stat reset to nl compat
    
    Convert TIPC_CMD_RESET_LINK_STATS to compat doit.
    
    Signed-off-by: Richard Alpe <richard.alpe@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 6eb9d606063b..7aeb52092bf3 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -215,9 +215,6 @@ void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);
 void tipc_link_purge_queues(struct tipc_link *l_ptr);
-struct sk_buff *tipc_link_cmd_reset_stats(struct net *net,
-					  const void *req_tlv_area,
-					  int req_tlv_space);
 void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
 void tipc_link_reset_list(struct net *net, unsigned int bearer_id);

commit 37e2d4843f9e2f5aad6bf3be5dad174f2838f375
Author: Richard Alpe <richard.alpe@ericsson.com>
Date:   Mon Feb 9 09:50:08 2015 +0100

    tipc: convert legacy nl link prop set to nl compat
    
    Convert setting of link proprieties to compat doit calls.
    
    Commands converted in this patch:
    TIPC_CMD_SET_LINK_TOL
    TIPC_CMD_SET_LINK_PRI
    TIPC_CMD_SET_LINK_WINDOW
    
    Signed-off-by: Richard Alpe <richard.alpe@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 8c8340cf991f..6eb9d606063b 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -215,8 +215,6 @@ void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);
 void tipc_link_purge_queues(struct tipc_link *l_ptr);
-struct sk_buff *tipc_link_cmd_config(struct net *net, const void *req_tlv_area,
-				     int req_tlv_space, u16 cmd);
 struct sk_buff *tipc_link_cmd_reset_stats(struct net *net,
 					  const void *req_tlv_area,
 					  int req_tlv_space);

commit f2b3b2d4ccbf9666f5f42a21347cd1aaa532b2fa
Author: Richard Alpe <richard.alpe@ericsson.com>
Date:   Mon Feb 9 09:50:06 2015 +0100

    tipc: convert legacy nl link stat to nl compat
    
    Add functionality for safely appending string data to a TLV without
    keeping write count in the caller.
    
    Convert TIPC_CMD_SHOW_LINK_STATS to compat dumpit.
    
    Signed-off-by: Richard Alpe <richard.alpe@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 34d3f55c4cea..8c8340cf991f 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -217,9 +217,6 @@ int tipc_link_is_active(struct tipc_link *l_ptr);
 void tipc_link_purge_queues(struct tipc_link *l_ptr);
 struct sk_buff *tipc_link_cmd_config(struct net *net, const void *req_tlv_area,
 				     int req_tlv_space, u16 cmd);
-struct sk_buff *tipc_link_cmd_show_stats(struct net *net,
-					 const void *req_tlv_area,
-					 int req_tlv_space);
 struct sk_buff *tipc_link_cmd_reset_stats(struct net *net,
 					  const void *req_tlv_area,
 					  int req_tlv_space);

commit c637c1035534867b85b78b453c38c495b58e2c5a
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Feb 5 08:36:41 2015 -0500

    tipc: resolve race problem at unicast message reception
    
    TIPC handles message cardinality and sequencing at the link layer,
    before passing messages upwards to the destination sockets. During the
    upcall from link to socket no locks are held. It is therefore possible,
    and we see it happen occasionally, that messages arriving in different
    threads and delivered in sequence still bypass each other before they
    reach the destination socket. This must not happen, since it violates
    the sequentiality guarantee.
    
    We solve this by adding a new input buffer queue to the link structure.
    Arriving messages are added safely to the tail of that queue by the
    link, while the head of the queue is consumed, also safely, by the
    receiving socket. Sequentiality is secured per socket by only allowing
    buffers to be dequeued inside the socket lock. Since there may be multiple
    simultaneous readers of the queue, we use a 'filter' parameter to reduce
    the risk that they peek the same buffer from the queue, hence also
    reducing the risk of contention on the receiving socket locks.
    
    This solves the sequentiality problem, and seems to cause no measurable
    performance degradation.
    
    A nice side effect of this change is that lock handling in the functions
    tipc_rcv() and tipc_bcast_rcv() now becomes uniform, something that
    will enable future simplifications of those functions.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 5b9a17f26280..34d3f55c4cea 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -131,8 +131,10 @@ struct tipc_stats {
  * @next_in_no: next sequence number to expect for inbound messages
  * @deferred_queue: deferred queue saved OOS b'cast message received from node
  * @unacked_window: # of inbound messages rx'd without ack'ing back to peer
+ * @inputq: buffer queue for messages to be delivered upwards
+ * @namedq: buffer queue for name table messages to be delivered upwards
  * @next_out: ptr to first unsent outbound message in queue
- * @waiting_sks: linked list of sockets waiting for link congestion to abate
+ * @wakeupq: linked list of wakeup msgs waiting for link congestion to abate
  * @long_msg_seq_no: next identifier to use for outbound fragmented messages
  * @reasm_buf: head of partially reassembled inbound message fragments
  * @stats: collects statistics regarding link activity
@@ -184,10 +186,12 @@ struct tipc_link {
 	u32 next_in_no;
 	struct sk_buff_head deferred_queue;
 	u32 unacked_window;
+	struct sk_buff_head inputq;
+	struct sk_buff_head namedq;
 
 	/* Congestion handling */
 	struct sk_buff *next_out;
-	struct sk_buff_head waiting_sks;
+	struct sk_buff_head wakeupq;
 
 	/* Fragmentation/reassembly */
 	u32 long_msg_seq_no;
@@ -228,7 +232,6 @@ int tipc_link_xmit(struct net *net, struct sk_buff_head *list, u32 dest,
 		   u32 selector);
 int __tipc_link_xmit(struct net *net, struct tipc_link *link,
 		     struct sk_buff_head *list);
-void tipc_link_bundle_rcv(struct net *net, struct sk_buff *buf);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 			  u32 gap, u32 tolerance, u32 priority, u32 acked_mtu);
 void tipc_link_push_packets(struct tipc_link *l_ptr);
@@ -244,6 +247,7 @@ int tipc_nl_link_get(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_link_set(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_link_reset_stats(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
+void link_prepare_wakeup(struct tipc_link *l);
 
 /*
  * Link sequence number manipulation routines (uses modulo 2**16 arithmetic)

commit c5898636c440da91d58f10beac00f073e68378df
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Feb 5 08:36:36 2015 -0500

    tipc: reduce usage of context info in socket and link
    
    The most common usage of namespace information is when we fetch the
    own node addess from the net structure. This leads to a lot of
    passing around of a parameter of type 'struct net *' between
    functions just to make them able to obtain this address.
    
    However, in many cases this is unnecessary. The own node address
    is readily available as a member of both struct tipc_sock and
    tipc_link, and can be fetched from there instead.
    The fact that the vast majority of functions in socket.c and link.c
    anyway are maintaining a pointer to their respective base structures
    makes this option even more compelling.
    
    In this commit, we introduce the inline functions tsk_own_node()
    and link_own_node() to make it easy for functions to fetch the node
    address from those structs instead of having to pass along and
    dereference the namespace struct.
    
    In particular, we make calls to the msg_xx() functions in msg.{h,c}
    context independent by directly passing them the own node address
    as parameter when needed. Those functions should be regarded as
    leaves in the code dependency tree, and it is hence desirable to
    keep them namspace unaware.
    
    Apart from a potential positive effect on cache behavior, these
    changes make it easier to introduce the changes that will follow
    later in this series.
    
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 3e3432b3044e..5b9a17f26280 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -278,6 +278,10 @@ static inline u32 lesser(u32 left, u32 right)
 	return less_eq(left, right) ? left : right;
 }
 
+static inline u32 link_own_addr(struct tipc_link *l)
+{
+	return msg_prevnode(l->pmsg);
+}
 
 /*
  * Link status checking routines

commit 7d24dcdb3f3132e0ec36f19c49bd004bc874b8aa
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Tue Feb 3 08:59:18 2015 -0500

    tipc: avoid stale link after aborted failover
    
    During link failover it may happen that the remaining link goes
    down while it is still in the process of taking over traffic
    from a previously failed link. When this happens, we currently
    abort the failover procedure and reset the first failed link to
    non-failover mode, so that it will be ready to re-establish
    contact with its peer when it comes available.
    
    However, if the first link goes down because its bearer was manually
    disabled, it is not enough to reset it; it must also be deleted;
    which is supposed to happen when the failover procedure is finished.
    Otherwise it will remain a zombie link: attached to the owner node
    structure, in mode LINK_STOPPED, and permanently blocking any re-
    establishing of the link to the peer via the interface in question.
    
    We fix this by amending the failover abort procedure. Apart from
    resetting the link to non-failover state, we test if the link is
    also in LINK_STOPPED mode. If so, we delete it, using the conditional
    tipc_link_delete() function introduced in the previous commit.
    
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index f06b779c9f75..3e3432b3044e 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -202,6 +202,7 @@ struct tipc_port;
 struct tipc_link *tipc_link_create(struct tipc_node *n_ptr,
 			      struct tipc_bearer *b_ptr,
 			      const struct tipc_media_addr *media_addr);
+void tipc_link_delete(struct tipc_link *link);
 void tipc_link_delete_list(struct net *net, unsigned int bearer_id,
 			   bool shutting_down);
 void tipc_link_failover_send_queue(struct tipc_link *l_ptr);

commit 2d72d49553d8de113d4eb1f69b2291f449a4c6bc
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Tue Feb 3 08:59:17 2015 -0500

    tipc: add reference count to struct tipc_link
    
    When a bearer is disabled, all pertaining links will be reset and
    deleted. However, if there is a second active link towards a killed
    link's destination, the delete has to be postponed until the failover
    is finished. During this interval, we currently put the link in zombie
    mode, i.e., we take it out of traffic, delete its timer, but leave it
    attached to the owner node structure until all missing packets have
    been received.  When this is done, we detach the link from its node
    and delete it, assuming that the synchronous timer deletion that was
    initiated earlier in a different thread has finished.
    
    This is unsafe, as the failover may finish before del_timer_sync()
    has returned in the other thread.
    
    We fix this by adding an atomic reference counter of type kref in
    struct tipc_link. The counter keeps track of the references kept
    to the link by the owner node and the timer. We then do a conditional
    delete, based on the reference counter, both after the failover has
    been finished and when the timer expires, if applicable. Whoever
    comes last, will actually delete the link. This approach also implies
    that we can make the deletion of the timer asynchronous.
    
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 9df7fa4d3bdd..f06b779c9f75 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -103,6 +103,7 @@ struct tipc_stats {
  * @media_addr: media address to use when sending messages over link
  * @timer: link timer
  * @owner: pointer to peer node
+ * @refcnt: reference counter for permanent references (owner node & timer)
  * @flags: execution state flags for link endpoint instance
  * @checkpoint: reference point for triggering link continuity checking
  * @peer_session: link session # being used by peer end of link
@@ -142,6 +143,7 @@ struct tipc_link {
 	struct tipc_media_addr media_addr;
 	struct timer_list timer;
 	struct tipc_node *owner;
+	struct kref ref;
 
 	/* Management and link supervision data */
 	unsigned int flags;

commit 7f9f95d9d9bcdf253c4149a157b096958013eceb
Author: Ying Xue <ying.xue@windriver.com>
Date:   Fri Jan 9 15:27:06 2015 +0800

    tipc: make bearer list support net namespace
    
    Bearer list defined as a global variable is used to store bearer
    instances. When tipc supports net namespace, bearers created in
    one namespace must be isolated with others allocated in other
    namespaces, which requires us that the bearer list(bearer_list)
    must be moved to tipc_net structure. As a result, a net namespace
    pointer has to be passed to functions which access the bearer list.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Tested-by: Tero Aho <Tero.Aho@coriant.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 380e27ee0f70..9df7fa4d3bdd 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -223,7 +223,8 @@ int tipc_link_xmit_skb(struct net *net, struct sk_buff *skb, u32 dest,
 		       u32 selector);
 int tipc_link_xmit(struct net *net, struct sk_buff_head *list, u32 dest,
 		   u32 selector);
-int __tipc_link_xmit(struct tipc_link *link, struct sk_buff_head *list);
+int __tipc_link_xmit(struct net *net, struct tipc_link *link,
+		     struct sk_buff_head *list);
 void tipc_link_bundle_rcv(struct net *net, struct sk_buff *buf);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 			  u32 gap, u32 tolerance, u32 priority, u32 acked_mtu);

commit f2f9800d4955a96d92896841d8ba9b04201deaa1
Author: Ying Xue <ying.xue@windriver.com>
Date:   Fri Jan 9 15:27:05 2015 +0800

    tipc: make tipc node table aware of net namespace
    
    Global variables associated with node table are below:
    - node table list (node_htable)
    - node hash table list (tipc_node_list)
    - node table lock (node_list_lock)
    - node number counter (tipc_num_nodes)
    - node link number counter (tipc_num_links)
    
    To make node table support namespace, above global variables must be
    moved to tipc_net structure in order to keep secret for different
    namespaces. As a consequence, these variables are allocated and
    initialized when namespace is created, and deallocated when namespace
    is destroyed. After the change, functions associated with these
    variables have to utilize a namespace pointer to access them. So
    adding namespace pointer as a parameter of these functions is the
    major change made in the commit.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Tested-by: Tero Aho <Tero.Aho@coriant.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 692268dca4b9..380e27ee0f70 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -200,27 +200,31 @@ struct tipc_port;
 struct tipc_link *tipc_link_create(struct tipc_node *n_ptr,
 			      struct tipc_bearer *b_ptr,
 			      const struct tipc_media_addr *media_addr);
-void tipc_link_delete_list(unsigned int bearer_id, bool shutting_down);
+void tipc_link_delete_list(struct net *net, unsigned int bearer_id,
+			   bool shutting_down);
 void tipc_link_failover_send_queue(struct tipc_link *l_ptr);
 void tipc_link_dup_queue_xmit(struct tipc_link *l_ptr, struct tipc_link *dest);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);
 void tipc_link_purge_queues(struct tipc_link *l_ptr);
-struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area,
-				     int req_tlv_space,
-				     u16 cmd);
-struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area,
+struct sk_buff *tipc_link_cmd_config(struct net *net, const void *req_tlv_area,
+				     int req_tlv_space, u16 cmd);
+struct sk_buff *tipc_link_cmd_show_stats(struct net *net,
+					 const void *req_tlv_area,
 					 int req_tlv_space);
-struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area,
+struct sk_buff *tipc_link_cmd_reset_stats(struct net *net,
+					  const void *req_tlv_area,
 					  int req_tlv_space);
 void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
-void tipc_link_reset_list(unsigned int bearer_id);
-int tipc_link_xmit_skb(struct sk_buff *skb, u32 dest, u32 selector);
-int tipc_link_xmit(struct sk_buff_head *list, u32 dest, u32 selector);
+void tipc_link_reset_list(struct net *net, unsigned int bearer_id);
+int tipc_link_xmit_skb(struct net *net, struct sk_buff *skb, u32 dest,
+		       u32 selector);
+int tipc_link_xmit(struct net *net, struct sk_buff_head *list, u32 dest,
+		   u32 selector);
 int __tipc_link_xmit(struct tipc_link *link, struct sk_buff_head *list);
-void tipc_link_bundle_rcv(struct sk_buff *buf);
+void tipc_link_bundle_rcv(struct net *net, struct sk_buff *buf);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 			  u32 gap, u32 tolerance, u32 priority, u32 acked_mtu);
 void tipc_link_push_packets(struct tipc_link *l_ptr);

commit 54fef04ad05f15984082c225fe47ce6af8ea1c5c
Author: Ying Xue <ying.xue@windriver.com>
Date:   Fri Jan 9 15:27:03 2015 +0800

    tipc: remove unused tipc_link_get_max_pkt routine
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Tested-by: Tero Aho <Tero.Aho@coriant.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index e96c318f5c73..692268dca4b9 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -220,7 +220,6 @@ void tipc_link_reset_list(unsigned int bearer_id);
 int tipc_link_xmit_skb(struct sk_buff *skb, u32 dest, u32 selector);
 int tipc_link_xmit(struct sk_buff_head *list, u32 dest, u32 selector);
 int __tipc_link_xmit(struct tipc_link *link, struct sk_buff_head *list);
-u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
 void tipc_link_bundle_rcv(struct sk_buff *buf);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 			  u32 gap, u32 tolerance, u32 priority, u32 acked_mtu);

commit 859fc7c0cedca0f84dac471fa31e9512259e1ecd
Author: Ying Xue <ying.xue@windriver.com>
Date:   Fri Jan 9 15:27:01 2015 +0800

    tipc: cleanup core.c and core.h files
    
    Only the works of initializing and shutting down tipc module are done
    in core.h and core.c files, so all stuffs which are not closely
    associated with the two tasks should be moved to appropriate places.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Tested-by: Tero Aho <Tero.Aho@coriant.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 15ca850391df..e96c318f5c73 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -41,6 +41,10 @@
 #include "msg.h"
 #include "node.h"
 
+/* TIPC-specific error codes
+*/
+#define ELINKCONG EAGAIN	/* link congestion <=> resource unavailable */
+
 /* Out-of-range value for link sequence numbers
  */
 #define INVALID_LINK_SEQ 0x10000

commit 2f55c43788df7358be8c6e78ae2a3d3268e7afb6
Author: Ying Xue <ying.xue@windriver.com>
Date:   Fri Jan 9 15:27:00 2015 +0800

    tipc: remove unnecessary wrapper functions of kernel timer APIs
    
    Not only some wrapper function like k_term_timer() is empty, but also
    some others including k_start_timer() and k_cancel_timer() don't return
    back any value to its caller, what's more, there is no any component
    in the kernel world to do such thing. Therefore, these timer interfaces
    defined in tipc module should be purged.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Tested-by: Tero Aho <Tero.Aho@coriant.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 55812e87ca1e..15ca850391df 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -105,7 +105,7 @@ struct tipc_stats {
  * @peer_bearer_id: bearer id used by link's peer endpoint
  * @bearer_id: local bearer id used by link
  * @tolerance: minimum link continuity loss needed to reset link [in ms]
- * @continuity_interval: link continuity testing interval [in ms]
+ * @cont_intv: link continuity testing interval
  * @abort_limit: # of unacknowledged continuity probes needed to reset link
  * @state: current state of link FSM
  * @fsm_msg_cnt: # of protocol messages link FSM has sent in current state
@@ -146,7 +146,7 @@ struct tipc_link {
 	u32 peer_bearer_id;
 	u32 bearer_id;
 	u32 tolerance;
-	u32 continuity_interval;
+	unsigned long cont_intv;
 	u32 abort_limit;
 	int state;
 	u32 fsm_msg_cnt;

commit a6ca109443842e7251c68451f8137ae68ae6d8a6
Author: Ying Xue <ying.xue@windriver.com>
Date:   Wed Nov 26 11:41:55 2014 +0800

    tipc: use generic SKB list APIs to manage TIPC outgoing packet chains
    
    Use standard SKB list APIs associated with struct sk_buff_head to
    manage socket outgoing packet chain and name table outgoing packet
    chain, having relevant code simpler and more readable.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index de7b8833641a..55812e87ca1e 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -213,8 +213,9 @@ struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area,
 void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
 void tipc_link_reset_list(unsigned int bearer_id);
-int tipc_link_xmit(struct sk_buff *buf, u32 dest, u32 selector);
-int __tipc_link_xmit(struct tipc_link *link, struct sk_buff *buf);
+int tipc_link_xmit_skb(struct sk_buff *skb, u32 dest, u32 selector);
+int tipc_link_xmit(struct sk_buff_head *list, u32 dest, u32 selector);
+int __tipc_link_xmit(struct tipc_link *link, struct sk_buff_head *list);
 u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
 void tipc_link_bundle_rcv(struct sk_buff *buf);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,

commit bc6fecd4098df2d21b056486e5b418c84be95032
Author: Ying Xue <ying.xue@windriver.com>
Date:   Wed Nov 26 11:41:53 2014 +0800

    tipc: use generic SKB list APIs to manage deferred queue of link
    
    Use standard SKB list APIs associated with struct sk_buff_head to
    manage link's deferred queue, simplifying relevant code.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 96f1e1bf0798..de7b8833641a 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -124,9 +124,7 @@ struct tipc_stats {
  * @last_retransmitted: sequence number of most recently retransmitted message
  * @stale_count: # of identical retransmit requests made by peer
  * @next_in_no: next sequence number to expect for inbound messages
- * @deferred_inqueue_sz: # of messages in inbound message queue
- * @oldest_deferred_in: ptr to first inbound message in queue
- * @newest_deferred_in: ptr to last inbound message in queue
+ * @deferred_queue: deferred queue saved OOS b'cast message received from node
  * @unacked_window: # of inbound messages rx'd without ack'ing back to peer
  * @next_out: ptr to first unsent outbound message in queue
  * @waiting_sks: linked list of sockets waiting for link congestion to abate
@@ -178,9 +176,7 @@ struct tipc_link {
 
 	/* Reception */
 	u32 next_in_no;
-	u32 deferred_inqueue_sz;
-	struct sk_buff *oldest_deferred_in;
-	struct sk_buff *newest_deferred_in;
+	struct sk_buff_head deferred_queue;
 	u32 unacked_window;
 
 	/* Congestion handling */
@@ -224,8 +220,7 @@ void tipc_link_bundle_rcv(struct sk_buff *buf);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 			  u32 gap, u32 tolerance, u32 priority, u32 acked_mtu);
 void tipc_link_push_packets(struct tipc_link *l_ptr);
-u32 tipc_link_defer_pkt(struct sk_buff **head, struct sk_buff **tail,
-			struct sk_buff *buf);
+u32 tipc_link_defer_pkt(struct sk_buff_head *list, struct sk_buff *buf);
 void tipc_link_set_queue_limits(struct tipc_link *l_ptr, u32 window);
 void tipc_link_retransmit(struct tipc_link *l_ptr,
 			  struct sk_buff *start, u32 retransmits);

commit 58dc55f25631178ee74cd27185956a8f7dcb3e32
Author: Ying Xue <ying.xue@windriver.com>
Date:   Wed Nov 26 11:41:52 2014 +0800

    tipc: use generic SKB list APIs to manage link transmission queue
    
    Use standard SKB list APIs associated with struct sk_buff_head to
    manage link transmission queue, having relevant code more clean.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 771123413d5f..96f1e1bf0798 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -119,9 +119,7 @@ struct tipc_stats {
  * @max_pkt: current maximum packet size for this link
  * @max_pkt_target: desired maximum packet size for this link
  * @max_pkt_probes: # of probes based on current (max_pkt, max_pkt_target)
- * @out_queue_size: # of messages in outbound message queue
- * @first_out: ptr to first outbound message in queue
- * @last_out: ptr to last outbound message in queue
+ * @outqueue: outbound message queue
  * @next_out_no: next sequence number to use for outbound messages
  * @last_retransmitted: sequence number of most recently retransmitted message
  * @stale_count: # of identical retransmit requests made by peer
@@ -173,9 +171,7 @@ struct tipc_link {
 	u32 max_pkt_probes;
 
 	/* Sending */
-	u32 out_queue_size;
-	struct sk_buff *first_out;
-	struct sk_buff *last_out;
+	struct sk_buff_head outqueue;
 	u32 next_out_no;
 	u32 last_retransmitted;
 	u32 stale_count;
@@ -233,6 +229,8 @@ u32 tipc_link_defer_pkt(struct sk_buff **head, struct sk_buff **tail,
 void tipc_link_set_queue_limits(struct tipc_link *l_ptr, u32 window);
 void tipc_link_retransmit(struct tipc_link *l_ptr,
 			  struct sk_buff *start, u32 retransmits);
+struct sk_buff *tipc_skb_queue_next(const struct sk_buff_head *list,
+				    const struct sk_buff *skb);
 
 int tipc_nl_link_dump(struct sk_buff *skb, struct netlink_callback *cb);
 int tipc_nl_link_get(struct sk_buff *skb, struct genl_info *info);
@@ -258,6 +256,11 @@ static inline int less_eq(u32 left, u32 right)
 	return mod(right - left) < 32768u;
 }
 
+static inline int more(u32 left, u32 right)
+{
+	return !less_eq(left, right);
+}
+
 static inline int less(u32 left, u32 right)
 {
 	return less_eq(left, right) && (mod(right) != mod(left));
@@ -294,7 +297,7 @@ static inline int link_reset_reset(struct tipc_link *l_ptr)
 
 static inline int link_congested(struct tipc_link *l_ptr)
 {
-	return l_ptr->out_queue_size >= l_ptr->queue_limit[0];
+	return skb_queue_len(&l_ptr->outqueue) >= l_ptr->queue_limit[0];
 }
 
 #endif

commit 99315ad43d92a8df0e4a30a0694336cdcdb7965f
Author: Ying Xue <ying.xue@windriver.com>
Date:   Wed Nov 26 11:41:50 2014 +0800

    tipc: remove unused between routine
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 1681076cb339..771123413d5f 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -253,15 +253,6 @@ static inline u32 mod(u32 x)
 	return x & 0xffffu;
 }
 
-static inline int between(u32 lower, u32 upper, u32 n)
-{
-	if ((lower < n) && (n < upper))
-		return 1;
-	if ((upper < lower) && ((n > lower) || (n < upper)))
-		return 1;
-	return 0;
-}
-
 static inline int less_eq(u32 left, u32 right)
 {
 	return mod(right - left) < 32768u;

commit 47b4c9a82f2ed0c00aa1c20899b41f54d6f8a07a
Author: Ying Xue <ying.xue@windriver.com>
Date:   Wed Nov 26 11:41:48 2014 +0800

    tipc: clean up the process of link pushing packets
    
    In original tipc_link_push_packet(), it pushes messages from protocol
    message queue, retransmission queue and next_out queue. But as the two
    first queues are removed, we can simplify its relevant code through
    deleting tipc_link_push_queue().
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index cc816aacb16e..1681076cb339 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -227,7 +227,7 @@ u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
 void tipc_link_bundle_rcv(struct sk_buff *buf);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 			  u32 gap, u32 tolerance, u32 priority, u32 acked_mtu);
-void tipc_link_push_queue(struct tipc_link *l_ptr);
+void tipc_link_push_packets(struct tipc_link *l_ptr);
 u32 tipc_link_defer_pkt(struct sk_buff **head, struct sk_buff **tail,
 			struct sk_buff *buf);
 void tipc_link_set_queue_limits(struct tipc_link *l_ptr, u32 window);

commit 7b6f087f98107617e0535a6ed378c561f1ae84d7
Author: Ying Xue <ying.xue@windriver.com>
Date:   Wed Nov 26 11:41:47 2014 +0800

    tipc: remove retransmission queue
    
    TIPC retransmission queue is intended to record which messages
    should be retransmitted when bearer is not congested. However,
    as the retransmission queue becomes useless with the removal of
    bearer congestion mechanism, it should be removed.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index fb3f99b6e928..cc816aacb16e 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -130,8 +130,6 @@ struct tipc_stats {
  * @oldest_deferred_in: ptr to first inbound message in queue
  * @newest_deferred_in: ptr to last inbound message in queue
  * @unacked_window: # of inbound messages rx'd without ack'ing back to peer
- * @retransm_queue_size: number of messages to retransmit
- * @retransm_queue_head: sequence number of first message to retransmit
  * @next_out: ptr to first unsent outbound message in queue
  * @waiting_sks: linked list of sockets waiting for link congestion to abate
  * @long_msg_seq_no: next identifier to use for outbound fragmented messages
@@ -190,8 +188,6 @@ struct tipc_link {
 	u32 unacked_window;
 
 	/* Congestion handling */
-	u32 retransm_queue_size;
-	u32 retransm_queue_head;
 	struct sk_buff *next_out;
 	struct sk_buff_head waiting_sks;
 

commit 8965d250c28f588d2a6dca2a0b00e4bb895b58e0
Author: Ying Xue <ying.xue@windriver.com>
Date:   Wed Nov 26 11:41:46 2014 +0800

    tipc: remove protocol message queue
    
    TIPC protocol message queue is intended to save one protocol message
    when bearer is congested so that the message stored in the queue can
    be immediately transmitted when bearer congestion is released. However,
    as now the protocol queue has no mission any more with the removal of
    bearer congestion mechanism, it should be removed.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index f463e7be801c..fb3f99b6e928 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -130,7 +130,6 @@ struct tipc_stats {
  * @oldest_deferred_in: ptr to first inbound message in queue
  * @newest_deferred_in: ptr to last inbound message in queue
  * @unacked_window: # of inbound messages rx'd without ack'ing back to peer
- * @proto_msg_queue: ptr to (single) outbound control message
  * @retransm_queue_size: number of messages to retransmit
  * @retransm_queue_head: sequence number of first message to retransmit
  * @next_out: ptr to first unsent outbound message in queue
@@ -191,7 +190,6 @@ struct tipc_link {
 	u32 unacked_window;
 
 	/* Congestion handling */
-	struct sk_buff *proto_msg_queue;
 	u32 retransm_queue_size;
 	u32 retransm_queue_head;
 	struct sk_buff *next_out;

commit ae36342b50a91cff188e417201452dc075a8f444
Author: Richard Alpe <richard.alpe@ericsson.com>
Date:   Thu Nov 20 10:29:14 2014 +0100

    tipc: add link stat reset to new netlink api
    
    Add TIPC_NL_LINK_RESET_STATS command to the new netlink API.
    
    This command resets the link statistics for a particular link.
    
    Netlink logical layout of link reset message:
    -> link
        -> name
    
    Signed-off-by: Richard Alpe <richard.alpe@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 3738ba11ce00..f463e7be801c 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -243,6 +243,7 @@ void tipc_link_retransmit(struct tipc_link *l_ptr,
 int tipc_nl_link_dump(struct sk_buff *skb, struct netlink_callback *cb);
 int tipc_nl_link_get(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_link_set(struct sk_buff *skb, struct genl_info *info);
+int tipc_nl_link_reset_stats(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
 
 /*

commit f96ce7a20d6972a834202f3cdd6a53fd0ee26a8e
Author: Richard Alpe <richard.alpe@ericsson.com>
Date:   Thu Nov 20 10:29:13 2014 +0100

    tipc: add link set to new netlink api
    
    Add TIPC_NL_LINK_SET to the new tipc netlink API.
    
    This command can set one or more link properties for a particular
    link.
    
    Netlink logical layout of link set message:
    -> link
        -> name
        -> properties
            [ -> tolerance ]
            [ -> priority ]
            [ -> window ]
    
    Signed-off-by: Richard Alpe <richard.alpe@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 8e3542a4a037..3738ba11ce00 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -242,6 +242,7 @@ void tipc_link_retransmit(struct tipc_link *l_ptr,
 
 int tipc_nl_link_dump(struct sk_buff *skb, struct netlink_callback *cb);
 int tipc_nl_link_get(struct sk_buff *skb, struct genl_info *info);
+int tipc_nl_link_set(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
 
 /*

commit 7be57fc6918470ecacd16b89c0d4f73d8fc265c4
Author: Richard Alpe <richard.alpe@ericsson.com>
Date:   Thu Nov 20 10:29:12 2014 +0100

    tipc: add link get/dump to new netlink api
    
    Add TIPC_NL_LINK_GET command to the new tipc netlink API.
    
    This command supports dumping all information about all links
    (including the broadcast link) or getting all information about a
    specific link (not the broadcast link).
    
    The information about a link includes name, transmission info,
    properties and link statistics.
    
    As the tipc broadcast link is special we unfortunately have to treat
    it specially. It is a deliberate decision not to abstract the
    broadcast link on this (API) level.
    
    Netlink logical layout of link response message:
        -> port
            -> name
            -> MTU
            -> RX
            -> TX
            -> up flag
            -> active flag
            -> properties
               -> priority
               -> tolerance
               -> window
            -> statistics
                -> rx_info
                -> rx_fragments
                -> rx_fragmented
                -> rx_bundles
                -> rx_bundled
                -> tx_info
                -> tx_fragments
                -> tx_fragmented
                -> tx_bundles
                -> tx_bundled
                -> msg_prof_tot
                -> msg_len_cnt
                -> msg_len_tot
                -> msg_len_p0
                -> msg_len_p1
                -> msg_len_p2
                -> msg_len_p3
                -> msg_len_p4
                -> msg_len_p5
                -> msg_len_p6
                -> rx_states
                -> rx_probes
                -> rx_nacks
                -> rx_deferred
                -> tx_states
                -> tx_probes
                -> tx_nacks
                -> tx_acks
                -> retransmitted
                -> duplicates
                -> link_congs
                -> max_queue
                -> avg_queue
    
    Signed-off-by: Richard Alpe <richard.alpe@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 4338294f20d4..8e3542a4a037 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -240,6 +240,8 @@ void tipc_link_set_queue_limits(struct tipc_link *l_ptr, u32 window);
 void tipc_link_retransmit(struct tipc_link *l_ptr,
 			  struct sk_buff *start, u32 retransmits);
 
+int tipc_nl_link_dump(struct sk_buff *skb, struct netlink_callback *cb);
+int tipc_nl_link_get(struct sk_buff *skb, struct genl_info *info);
 int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
 
 /*

commit 0655f6a8635b1b66f2434d5556b1044c14b1ccaf
Author: Richard Alpe <richard.alpe@ericsson.com>
Date:   Thu Nov 20 10:29:07 2014 +0100

    tipc: add bearer disable/enable to new netlink api
    
    A new netlink API for tipc that can disable or enable a tipc bearer.
    
    The new API is separated from the old API because of a bug in the
    user space client (tipc-config). The problem is that older versions
    of tipc-config has a very low receive limit and adding commands to
    the legacy genl_opts struct causes the ctrl_getfamily() response
    message to grow, subsequently breaking the tool.
    
    The new API utilizes netlink policies for input validation. Where the
    top-level netlink attributes are tipc-logical entities, like bearer.
    The top level entities then contain nested attributes. In this case
    a name, nested link properties and a domain.
    
    Netlink commands implemented in this patch:
    TIPC_NL_BEARER_ENABLE
    TIPC_NL_BEARER_DISABLE
    
    Netlink logical layout of bearer enable message:
    -> bearer
        -> name
        [ -> domain ]
        [
        -> properties
            -> priority
        ]
    
    Netlink logical layout of bearer disable message:
    -> bearer
        -> name
    
    Signed-off-by: Richard Alpe <richard.alpe@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index b567a3427fda..4338294f20d4 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -37,6 +37,7 @@
 #ifndef _TIPC_LINK_H
 #define _TIPC_LINK_H
 
+#include <net/genetlink.h>
 #include "msg.h"
 #include "node.h"
 
@@ -239,6 +240,8 @@ void tipc_link_set_queue_limits(struct tipc_link *l_ptr, u32 window);
 void tipc_link_retransmit(struct tipc_link *l_ptr,
 			  struct sk_buff *start, u32 retransmits);
 
+int tipc_nl_parse_link_prop(struct nlattr *prop, struct nlattr *props[]);
+
 /*
  * Link sequence number manipulation routines (uses modulo 2**16 arithmetic)
  */

commit 50100a5e39461b2a61d6040e73c384766c29975d
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Fri Aug 22 18:09:07 2014 -0400

    tipc: use pseudo message to wake up sockets after link congestion
    
    The current link implementation keeps a linked list of blocked ports/
    sockets that is populated when there is link congestion. The purpose
    of this is to let the link know which users to wake up when the
    congestion abates.
    
    This adds unnecessary complexity to the data structure and the code,
    since it forces us to involve the link each time we want to delete
    a socket. It also forces us to grab the spinlock port_lock within
    the scope of node_lock. We want to get rid of this direct dependence,
    as well as the deadlock hazard resulting from the usage of port_lock.
    
    In this commit, we instead let the link keep list of a "wakeup" pseudo
    messages for use in such situations. Those messages are sent to the
    pending sockets via the ordinary message reception path, and wake up
    the socket's owner when they are received.
    
    This enables us to get rid of the 'waiting_ports' linked lists in struct
    tipc_port that manifest this direct reference. As a consequence, we can
    eliminate another BH entry into the socket, and hence the need to grab
    port_lock. This is a further step in our effort to remove port_lock
    altogether.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 782983ccd323..b567a3427fda 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -1,7 +1,7 @@
 /*
  * net/tipc/link.h: Include file for TIPC link code
  *
- * Copyright (c) 1995-2006, 2013, Ericsson AB
+ * Copyright (c) 1995-2006, 2013-2014, Ericsson AB
  * Copyright (c) 2004-2005, 2010-2011, Wind River Systems
  * All rights reserved.
  *
@@ -133,7 +133,7 @@ struct tipc_stats {
  * @retransm_queue_size: number of messages to retransmit
  * @retransm_queue_head: sequence number of first message to retransmit
  * @next_out: ptr to first unsent outbound message in queue
- * @waiting_ports: linked list of ports waiting for link congestion to abate
+ * @waiting_sks: linked list of sockets waiting for link congestion to abate
  * @long_msg_seq_no: next identifier to use for outbound fragmented messages
  * @reasm_buf: head of partially reassembled inbound message fragments
  * @stats: collects statistics regarding link activity
@@ -194,7 +194,7 @@ struct tipc_link {
 	u32 retransm_queue_size;
 	u32 retransm_queue_head;
 	struct sk_buff *next_out;
-	struct list_head waiting_ports;
+	struct sk_buff_head waiting_sks;
 
 	/* Fragmentation/reassembly */
 	u32 long_msg_seq_no;
@@ -235,7 +235,6 @@ void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 void tipc_link_push_queue(struct tipc_link *l_ptr);
 u32 tipc_link_defer_pkt(struct sk_buff **head, struct sk_buff **tail,
 			struct sk_buff *buf);
-void tipc_link_wakeup_ports(struct tipc_link *l_ptr, int all);
 void tipc_link_set_queue_limits(struct tipc_link *l_ptr, u32 window);
 void tipc_link_retransmit(struct tipc_link *l_ptr,
 			  struct sk_buff *start, u32 retransmits);

commit 9fbfb8b120bd4fe89cd70d6c8841e6e1cfab2609
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Wed Jul 16 20:41:03 2014 -0400

    tipc: rename temporarily named functions
    
    After the previous commit, we can now give the functions with temporary
    names, such as tipc_link_xmit2(), tipc_msg_build2() etc., their proper
    names.
    
    There are no functional changes in this commit.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index f0ebeb677a8b..782983ccd323 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -226,8 +226,8 @@ struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area,
 void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
 void tipc_link_reset_list(unsigned int bearer_id);
-int tipc_link_xmit2(struct sk_buff *buf, u32 dest, u32 selector);
-int __tipc_link_xmit2(struct tipc_link *link, struct sk_buff *buf);
+int tipc_link_xmit(struct sk_buff *buf, u32 dest, u32 selector);
+int __tipc_link_xmit(struct tipc_link *link, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
 void tipc_link_bundle_rcv(struct sk_buff *buf);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,

commit c4116e10579c5bbbfc3cd2ad0324ee0d8691e531
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Wed Jul 16 20:41:02 2014 -0400

    tipc: remove unreferenced functions
    
    We can now remove a number of functions which have become obsolete
    and unreferenced through this commit series. There are no functional
    changes in this commit.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 04a59c58d385..f0ebeb677a8b 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -226,15 +226,9 @@ struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area,
 void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
 void tipc_link_reset_list(unsigned int bearer_id);
-int tipc_link_xmit(struct sk_buff *buf, u32 dest, u32 selector);
 int tipc_link_xmit2(struct sk_buff *buf, u32 dest, u32 selector);
-int __tipc_link_xmit(struct tipc_link *l_ptr, struct sk_buff *buf);
 int __tipc_link_xmit2(struct tipc_link *link, struct sk_buff *buf);
-int tipc_link_send_buf(struct tipc_link *l_ptr, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
-int tipc_link_iovec_xmit_fast(struct tipc_port *sender,
-			      struct iovec const *msg_sect,
-			      unsigned int len, u32 destnode);
 void tipc_link_bundle_rcv(struct sk_buff *buf);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 			  u32 gap, u32 tolerance, u32 priority, u32 acked_mtu);

commit dbdf6d24ad37d63938f29a2d134a1a9f6e9e673c
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Wed Jul 16 20:40:58 2014 -0400

    tipc: make name table distributor use new send function
    
    In a previous commit series ("tipc: new unicast transmission code")
    we introduced a new message sending function, tipc_link_xmit2(),
    and moved the unicast data users over to use that function. We now
    let the internal name table distributor do the same.
    
    The interaction between the name distributor and the node/link
    layer also becomes significantly simpler, so we can eliminate
    the function tipc_link_names_xmit().
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 227ff8120897..04a59c58d385 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -228,7 +228,6 @@ void tipc_link_reset(struct tipc_link *l_ptr);
 void tipc_link_reset_list(unsigned int bearer_id);
 int tipc_link_xmit(struct sk_buff *buf, u32 dest, u32 selector);
 int tipc_link_xmit2(struct sk_buff *buf, u32 dest, u32 selector);
-void tipc_link_names_xmit(struct list_head *message_list, u32 dest);
 int __tipc_link_xmit(struct tipc_link *l_ptr, struct sk_buff *buf);
 int __tipc_link_xmit2(struct tipc_link *link, struct sk_buff *buf);
 int tipc_link_send_buf(struct tipc_link *l_ptr, struct sk_buff *buf);

commit 4f1688b2c63cd86f0d7bcf95a9b3040e38bd3c1a
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Wed Jun 25 20:41:32 2014 -0500

    tipc: introduce send functions for chained buffers in link
    
    The current link implementation provides several different transmit
    functions, depending on the characteristics of the message to be
    sent: if it is an iovec or an sk_buff, if it needs fragmentation or
    not, if the caller holds the node_lock or not. The permutation of
    these options gives us an unwanted amount of unnecessarily complex
    code.
    
    As a first step towards simplifying the send path for all messages,
    we introduce two new send functions at link level, tipc_link_xmit2()
    and __tipc_link_xmit2(). The former looks up a link to the message
    destination, and if one is found, it grabs the node lock and calls
    the second function, which works exclusively inside the node lock
    protection. If no link is found, and the destination is on the same
    node, it delivers the message directly to the local destination
    socket.
    
    The new functions take a buffer chain where all packet headers are
    already prepared, and the correct MTU has been used. These two
    functions will later replace all other link-level transmit functions.
    
    The functions are not backwards compatible, so we have added them
    as new functions with temporary names. They are tested, but have no
    users yet. Those will be added later in this series.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 200d518b218e..227ff8120897 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -227,8 +227,10 @@ void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
 void tipc_link_reset_list(unsigned int bearer_id);
 int tipc_link_xmit(struct sk_buff *buf, u32 dest, u32 selector);
+int tipc_link_xmit2(struct sk_buff *buf, u32 dest, u32 selector);
 void tipc_link_names_xmit(struct list_head *message_list, u32 dest);
 int __tipc_link_xmit(struct tipc_link *l_ptr, struct sk_buff *buf);
+int __tipc_link_xmit2(struct tipc_link *link, struct sk_buff *buf);
 int tipc_link_send_buf(struct tipc_link *l_ptr, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
 int tipc_link_iovec_xmit_fast(struct tipc_port *sender,

commit 37e22164a8a3c39bdad45aa463b1e69a1fdf4110
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Wed May 14 05:39:12 2014 -0400

    tipc: rename and move message reassembly function
    
    The function tipc_link_frag_rcv() is in reality a re-entrant generic
    message reassemby function that has nothing in particular to do with
    the link, where it is defined now. This becomes obvious when we see
    the need to call the function from other places in the code.
    
    In this commit rename it to tipc_buf_append() and move it to the file
    msg.c. We also simplify its signature by moving the tail pointer to
    the control block of the head buffer, hence making the head buffer
    self-contained.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 7ba73fa6b81e..200d518b218e 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -40,11 +40,6 @@
 #include "msg.h"
 #include "node.h"
 
-/* Link reassembly status codes
- */
-#define LINK_REASM_ERROR	-1
-#define LINK_REASM_COMPLETE	1
-
 /* Out-of-range value for link sequence numbers
  */
 #define INVALID_LINK_SEQ 0x10000
@@ -140,8 +135,7 @@ struct tipc_stats {
  * @next_out: ptr to first unsent outbound message in queue
  * @waiting_ports: linked list of ports waiting for link congestion to abate
  * @long_msg_seq_no: next identifier to use for outbound fragmented messages
- * @reasm_head: list head of partially reassembled inbound message fragments
- * @reasm_tail: last fragment received
+ * @reasm_buf: head of partially reassembled inbound message fragments
  * @stats: collects statistics regarding link activity
  */
 struct tipc_link {
@@ -204,8 +198,7 @@ struct tipc_link {
 
 	/* Fragmentation/reassembly */
 	u32 long_msg_seq_no;
-	struct sk_buff *reasm_head;
-	struct sk_buff *reasm_tail;
+	struct sk_buff *reasm_buf;
 
 	/* Statistics */
 	struct tipc_stats stats;
@@ -242,9 +235,6 @@ int tipc_link_iovec_xmit_fast(struct tipc_port *sender,
 			      struct iovec const *msg_sect,
 			      unsigned int len, u32 destnode);
 void tipc_link_bundle_rcv(struct sk_buff *buf);
-int tipc_link_frag_rcv(struct sk_buff **reasm_head,
-		       struct sk_buff **reasm_tail,
-		       struct sk_buff **fbuf);
 void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 			  u32 gap, u32 tolerance, u32 priority, u32 acked_mtu);
 void tipc_link_push_queue(struct tipc_link *l_ptr);

commit 3f5a12bd9f9a61d8a12f9adf778b14e4bb8ca050
Author: Ying Xue <ying.xue@windriver.com>
Date:   Mon May 5 08:56:17 2014 +0800

    tipc: avoid to asynchronously reset all links
    
    Postpone the actions of resetting all links until after bclink
    lock is released, avoiding to asynchronously reset all links.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 4b556c181bae..7ba73fa6b81e 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -230,6 +230,7 @@ struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area,
 					 int req_tlv_space);
 struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area,
 					  int req_tlv_space);
+void tipc_link_reset_all(struct tipc_node *node);
 void tipc_link_reset(struct tipc_link *l_ptr);
 void tipc_link_reset_list(unsigned int bearer_id);
 int tipc_link_xmit(struct sk_buff *buf, u32 dest, u32 selector);

commit 7a2f7d18e79b09c5c5a65fb1fa0e31ad046b3116
Author: Ying Xue <ying.xue@windriver.com>
Date:   Mon Apr 21 10:55:46 2014 +0800

    tipc: decouple the relationship between bearer and link
    
    Currently on both paths of message transmission and reception, the
    read lock of tipc_net_lock must be held before bearer is accessed,
    while the write lock of tipc_net_lock has to be taken before bearer
    is configured. Although it can ensure that bearer is always valid on
    the two data paths, link and bearer is closely bound together.
    
    So as the part of effort of removing tipc_net_lock, the locking
    policy of bearer protection will be adjusted as below: on the two
    data paths, RCU is used, and on the configuration path of bearer,
    RTNL lock is applied.
    
    Now RCU just covers the path of message reception. To make it possible
    to protect the path of message transmission with RCU, link should not
    use its stored bearer pointer to access bearer, but it should use the
    bearer identity of its attached bearer as index to get bearer instance
    from bearer_list array, which can help us decouple the relationship
    between bearer and link. As a result, bearer on the path of message
    transmission can be safely protected by RCU when we access bearer_list
    array within RCU lock protection.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Erik Hugne <erik.hugne@ericsson.com>
    Tested-by: Erik Hugne <erik.hugne@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 8c0b49b5b2ee..4b556c181bae 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -107,7 +107,7 @@ struct tipc_stats {
  * @checkpoint: reference point for triggering link continuity checking
  * @peer_session: link session # being used by peer end of link
  * @peer_bearer_id: bearer id used by link's peer endpoint
- * @b_ptr: pointer to bearer used by link
+ * @bearer_id: local bearer id used by link
  * @tolerance: minimum link continuity loss needed to reset link [in ms]
  * @continuity_interval: link continuity testing interval [in ms]
  * @abort_limit: # of unacknowledged continuity probes needed to reset link
@@ -116,6 +116,7 @@ struct tipc_stats {
  * @proto_msg: template for control messages generated by link
  * @pmsg: convenience pointer to "proto_msg" field
  * @priority: current link priority
+ * @net_plane: current link network plane ('A' through 'H')
  * @queue_limit: outbound message queue congestion thresholds (indexed by user)
  * @exp_msg_count: # of tunnelled messages expected during link changeover
  * @reset_checkpoint: seq # of last acknowledged message at time of link reset
@@ -155,7 +156,7 @@ struct tipc_link {
 	u32 checkpoint;
 	u32 peer_session;
 	u32 peer_bearer_id;
-	struct tipc_bearer *b_ptr;
+	u32 bearer_id;
 	u32 tolerance;
 	u32 continuity_interval;
 	u32 abort_limit;
@@ -167,6 +168,7 @@ struct tipc_link {
 	} proto_msg;
 	struct tipc_msg *pmsg;
 	u32 priority;
+	char net_plane;
 	u32 queue_limit[15];	/* queue_limit[0]==window limit */
 
 	/* Changeover */

commit 247f0f3c3176c55b46cb9a20011d3d6757634815
Author: Ying Xue <ying.xue@windriver.com>
Date:   Tue Feb 18 16:06:46 2014 +0800

    tipc: align tipc function names with common naming practice in the network
    
    Rename the following functions, which are shorter and more in line
    with common naming practice in the network subsystem.
    
    tipc_bclink_send_msg->tipc_bclink_xmit
    tipc_bclink_recv_pkt->tipc_bclink_rcv
    tipc_disc_recv_msg->tipc_disc_rcv
    tipc_link_send_proto_msg->tipc_link_proto_xmit
    link_recv_proto_msg->tipc_link_proto_rcv
    link_send_sections_long->tipc_link_iovec_long_xmit
    tipc_link_send_sections_fast->tipc_link_iovec_xmit_fast
    tipc_link_send_sync->tipc_link_sync_xmit
    tipc_link_recv_sync->tipc_link_sync_rcv
    tipc_link_send_buf->__tipc_link_xmit
    tipc_link_send->tipc_link_xmit
    tipc_link_send_names->tipc_link_names_xmit
    tipc_named_recv->tipc_named_rcv
    tipc_link_recv_bundle->tipc_link_bundle_rcv
    tipc_link_dup_send_queue->tipc_link_dup_queue_xmit
    link_send_long_buf->tipc_link_frag_xmit
    
    tipc_multicast->tipc_port_mcast_xmit
    tipc_port_recv_mcast->tipc_port_mcast_rcv
    tipc_port_reject_sections->tipc_port_iovec_reject
    tipc_port_recv_proto_msg->tipc_port_proto_rcv
    tipc_connect->tipc_port_connect
    __tipc_connect->__tipc_port_connect
    __tipc_disconnect->__tipc_port_disconnect
    tipc_disconnect->tipc_port_disconnect
    tipc_shutdown->tipc_port_shutdown
    tipc_port_recv_msg->tipc_port_rcv
    tipc_port_recv_sections->tipc_port_iovec_rcv
    
    release->tipc_release
    accept->tipc_accept
    bind->tipc_bind
    get_name->tipc_getname
    poll->tipc_poll
    send_msg->tipc_sendmsg
    send_packet->tipc_send_packet
    send_stream->tipc_send_stream
    recv_msg->tipc_recvmsg
    recv_stream->tipc_recv_stream
    connect->tipc_connect
    listen->tipc_listen
    shutdown->tipc_shutdown
    setsockopt->tipc_setsockopt
    getsockopt->tipc_getsockopt
    
    Above changes have no impact on current users of the functions.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 45b9cd071c41..8c0b49b5b2ee 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -216,8 +216,7 @@ struct tipc_link *tipc_link_create(struct tipc_node *n_ptr,
 			      const struct tipc_media_addr *media_addr);
 void tipc_link_delete_list(unsigned int bearer_id, bool shutting_down);
 void tipc_link_failover_send_queue(struct tipc_link *l_ptr);
-void tipc_link_dup_send_queue(struct tipc_link *l_ptr,
-			      struct tipc_link *dest);
+void tipc_link_dup_queue_xmit(struct tipc_link *l_ptr, struct tipc_link *dest);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);
@@ -231,23 +230,23 @@ struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area,
 					  int req_tlv_space);
 void tipc_link_reset(struct tipc_link *l_ptr);
 void tipc_link_reset_list(unsigned int bearer_id);
-int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
-void tipc_link_send_names(struct list_head *message_list, u32 dest);
+int tipc_link_xmit(struct sk_buff *buf, u32 dest, u32 selector);
+void tipc_link_names_xmit(struct list_head *message_list, u32 dest);
+int __tipc_link_xmit(struct tipc_link *l_ptr, struct sk_buff *buf);
 int tipc_link_send_buf(struct tipc_link *l_ptr, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
-int tipc_link_send_sections_fast(struct tipc_port *sender,
-				 struct iovec const *msg_sect,
-				 unsigned int len, u32 destnode);
-void tipc_link_recv_bundle(struct sk_buff *buf);
-int  tipc_link_frag_rcv(struct sk_buff **reasm_head,
-			struct sk_buff **reasm_tail,
-			struct sk_buff **fbuf);
-void tipc_link_send_proto_msg(struct tipc_link *l_ptr, u32 msg_typ, int prob,
-			      u32 gap, u32 tolerance, u32 priority,
-			      u32 acked_mtu);
+int tipc_link_iovec_xmit_fast(struct tipc_port *sender,
+			      struct iovec const *msg_sect,
+			      unsigned int len, u32 destnode);
+void tipc_link_bundle_rcv(struct sk_buff *buf);
+int tipc_link_frag_rcv(struct sk_buff **reasm_head,
+		       struct sk_buff **reasm_tail,
+		       struct sk_buff **fbuf);
+void tipc_link_proto_xmit(struct tipc_link *l_ptr, u32 msg_typ, int prob,
+			  u32 gap, u32 tolerance, u32 priority, u32 acked_mtu);
 void tipc_link_push_queue(struct tipc_link *l_ptr);
 u32 tipc_link_defer_pkt(struct sk_buff **head, struct sk_buff **tail,
-		   struct sk_buff *buf);
+			struct sk_buff *buf);
 void tipc_link_wakeup_ports(struct tipc_link *l_ptr, int all);
 void tipc_link_set_queue_limits(struct tipc_link *l_ptr, u32 window);
 void tipc_link_retransmit(struct tipc_link *l_ptr,

commit 7d33939f475d403e79124e3143d7951dcfe8629f
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Feb 13 17:29:16 2014 -0500

    tipc: delay delete of link when failover is needed
    
    When a bearer is disabled, all its attached links are deleted.
    Ideally, we should do link failover to redundant links on other bearers,
    if there are any, in such cases. This would be consistent with current
    behavior when a link is reset, but not deleted. However, due to the
    complexity involved, and the (wrongly) perceived low demand for this
    feature, it was never implemented until now.
    
    We mark the doomed link for deletion with a new flag, but wait until the
    failover process is finished before we actually delete it. With the
    improved link tunnelling/failover code introduced earlier in this commit
    series, it is now easy to identify a spot in the code where the failover
    is finished and it is safe to delete the marked link. Moreover, the test
    for the flag and the deletion can be done synchronously, and outside the
    most time critical data path.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 3340fc1fc299..45b9cd071c41 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -214,7 +214,7 @@ struct tipc_port;
 struct tipc_link *tipc_link_create(struct tipc_node *n_ptr,
 			      struct tipc_bearer *b_ptr,
 			      const struct tipc_media_addr *media_addr);
-void tipc_link_delete_list(unsigned int bearer_id);
+void tipc_link_delete_list(unsigned int bearer_id, bool shutting_down);
 void tipc_link_failover_send_queue(struct tipc_link *l_ptr);
 void tipc_link_dup_send_queue(struct tipc_link *l_ptr,
 			      struct tipc_link *dest);

commit c61dd61dec0b79fa22ded8b5caf2e817dc506c24
Author: Ying Xue <ying.xue@windriver.com>
Date:   Thu Feb 13 17:29:09 2014 -0500

    tipc: remove 'links' list from tipc_bearer struct
    
    In our ongoing effort to simplify the TIPC locking structure,
    we see a need to remove the linked list for tipc_links
    in the bearer. This can be explained as follows.
    
    Currently, we have three different ways to access a link,
    via three different lists/tables:
    
    1: Via a node hash table:
       Used by the time-critical outgoing/incoming data paths.
       (e.g. link_send_sections_fast() and tipc_recv_msg() ):
    
    grab net_lock(read)
       find node from node hash table
       grab node_lock
           select link
           grab bearer_lock
              send_msg()
           release bearer_lock
       release node lock
    release net_lock
    
    2: Via a global linked list for nodes:
       Used by configuration commands (link_cmd_set_value())
    
    grab net_lock(read)
       find node and link from global node list (using link name)
       grab node_lock
           update link
       release node lock
    release net_lock
    
    (Same locking order as above. No problem.)
    
    3: Via the bearer's linked link list:
       Used by notifications from interface (e.g. tipc_disable_bearer() )
    
    grab net_lock(write)
       grab bearer_lock
          get link ptr from bearer's link list
          get node from link
          grab node_lock
             delete link
          release node lock
       release bearer_lock
    release net_lock
    
    (Different order from above, but works because we grab the
    outer net_lock in write mode first, excluding all other access.)
    
    The first major goal in our simplification effort is to get rid
    of the "big" net_lock, replacing it with rcu-locks when accessing
    the node list and node hash array. This will come in a later patch
    series.
    
    But to get there we first need to rewrite access methods ##2 and 3,
    since removal of net_lock would introduce three major problems:
    
    a) In access method #2, we access the link before taking the
       protecting node_lock. This will not work once net_lock is gone,
       so we will have to change the access order. We will deal with
       this in a later commit in this series, "tipc: add node lock
       protection to link found by link_find_link()".
    
    b) When the outer protection from net_lock is gone, taking
       bearer_lock and node_lock in opposite order of method 1) and 2)
       will become an obvious deadlock hazard. This is fixed in the
       commit ("tipc: remove bearer_lock from tipc_bearer struct")
       later in this series.
    
    c) Similar to what is described in problem a), access method #3
       starts with using a link pointer that is unprotected by node_lock,
       in order to via that pointer find the correct node struct and
       lock it. Before we remove net_lock, this access order must be
       altered. This is what we do with this commit.
    
    We can avoid introducing problem problem c) by even here using the
    global node list to find the node, before accessing its links. When
    we loop though the node list we use the own bearer identity as search
    criteria, thus easily finding the links that are associated to the
    resetting/disabling bearer. It should be noted that although this
    method is somewhat slower than the current list traversal, it is in
    no way time critical. This is only about resetting or deleting links,
    something that must be considered relatively infrequent events.
    
    As a bonus, we can get rid of the mutual pointers between links and
    bearers. After this commit, pointer dependency go in one direction
    only: from the link to the bearer.
    
    This commit pre-empts introduction of problem c) as described above.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index a900e74b4f3a..3340fc1fc299 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -59,6 +59,7 @@
 /* Link endpoint execution states
  */
 #define LINK_STARTED    0x0001
+#define LINK_STOPPED    0x0002
 
 /* Starting value for maximum packet size negotiation on unicast links
  * (unless bearer MTU is less)
@@ -102,7 +103,6 @@ struct tipc_stats {
  * @media_addr: media address to use when sending messages over link
  * @timer: link timer
  * @owner: pointer to peer node
- * @link_list: adjacent links in bearer's list of links
  * @flags: execution state flags for link endpoint instance
  * @checkpoint: reference point for triggering link continuity checking
  * @peer_session: link session # being used by peer end of link
@@ -149,7 +149,6 @@ struct tipc_link {
 	struct tipc_media_addr media_addr;
 	struct timer_list timer;
 	struct tipc_node *owner;
-	struct list_head link_list;
 
 	/* Management and link supervision data */
 	unsigned int flags;
@@ -215,11 +214,10 @@ struct tipc_port;
 struct tipc_link *tipc_link_create(struct tipc_node *n_ptr,
 			      struct tipc_bearer *b_ptr,
 			      const struct tipc_media_addr *media_addr);
-void tipc_link_delete(struct tipc_link *l_ptr);
+void tipc_link_delete_list(unsigned int bearer_id);
 void tipc_link_failover_send_queue(struct tipc_link *l_ptr);
 void tipc_link_dup_send_queue(struct tipc_link *l_ptr,
 			      struct tipc_link *dest);
-void tipc_link_delete_list(struct tipc_bearer *b_ptr);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);
@@ -232,7 +230,7 @@ struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area,
 struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area,
 					  int req_tlv_space);
 void tipc_link_reset(struct tipc_link *l_ptr);
-void tipc_link_reset_list(struct tipc_bearer *b_ptr);
+void tipc_link_reset_list(unsigned int bearer_id);
 int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
 void tipc_link_send_names(struct list_head *message_list, u32 dest);
 int tipc_link_send_buf(struct tipc_link *l_ptr, struct sk_buff *buf);

commit 135daee6d3959a6d7c4f59b448ed6f854d88ce27
Author: Ying Xue <ying.xue@windriver.com>
Date:   Thu Feb 13 17:29:08 2014 -0500

    tipc: redefine 'started' flag in struct link to bitmap
    
    Currently, the 'started' field in struct tipc_link represents only a
    binary state, 'started' or 'not started'. We need it to represent
    more link execution states in the coming commits in this series.
    Hence, we rename the field to 'flags', and define the current
    started/non-started state to be represented by the LSB bit of
    that field.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 994ebd16ddc3..a900e74b4f3a 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -1,7 +1,7 @@
 /*
  * net/tipc/link.h: Include file for TIPC link code
  *
- * Copyright (c) 1995-2006, Ericsson AB
+ * Copyright (c) 1995-2006, 2013, Ericsson AB
  * Copyright (c) 2004-2005, 2010-2011, Wind River Systems
  * All rights reserved.
  *
@@ -40,27 +40,27 @@
 #include "msg.h"
 #include "node.h"
 
-/*
- * Link reassembly status codes
+/* Link reassembly status codes
  */
 #define LINK_REASM_ERROR	-1
 #define LINK_REASM_COMPLETE	1
 
-/*
- * Out-of-range value for link sequence numbers
+/* Out-of-range value for link sequence numbers
  */
 #define INVALID_LINK_SEQ 0x10000
 
-/*
- * Link states
+/* Link working states
  */
 #define WORKING_WORKING 560810u
 #define WORKING_UNKNOWN 560811u
 #define RESET_UNKNOWN   560812u
 #define RESET_RESET     560813u
 
-/*
- * Starting value for maximum packet size negotiation on unicast links
+/* Link endpoint execution states
+ */
+#define LINK_STARTED    0x0001
+
+/* Starting value for maximum packet size negotiation on unicast links
  * (unless bearer MTU is less)
  */
 #define MAX_PKT_DEFAULT 1500
@@ -103,7 +103,7 @@ struct tipc_stats {
  * @timer: link timer
  * @owner: pointer to peer node
  * @link_list: adjacent links in bearer's list of links
- * @started: indicates if link has been started
+ * @flags: execution state flags for link endpoint instance
  * @checkpoint: reference point for triggering link continuity checking
  * @peer_session: link session # being used by peer end of link
  * @peer_bearer_id: bearer id used by link's peer endpoint
@@ -152,7 +152,7 @@ struct tipc_link {
 	struct list_head link_list;
 
 	/* Management and link supervision data */
-	int started;
+	unsigned int flags;
 	u32 checkpoint;
 	u32 peer_session;
 	u32 peer_bearer_id;

commit 8d8439b686f15c23faef4d7d67c4a9f30ce0f2b5
Author: Ying Xue <ying.xue@windriver.com>
Date:   Thu Feb 13 17:29:07 2014 -0500

    tipc: move code for deleting links from bearer.c to link.c
    
    We break out the code for deleting attached links in the
    function bearer_disable(), and define a new function named
    tipc_link_delete_list() to do this job.
    
    This commit incurs no functional changes, but makes the code of
    function bearer_disable() cleaner. It is also a preparation
    for a more important change to the bearer code, in a subsequent
    commit in this series.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 73beecb369e2..994ebd16ddc3 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -219,6 +219,7 @@ void tipc_link_delete(struct tipc_link *l_ptr);
 void tipc_link_failover_send_queue(struct tipc_link *l_ptr);
 void tipc_link_dup_send_queue(struct tipc_link *l_ptr,
 			      struct tipc_link *dest);
+void tipc_link_delete_list(struct tipc_bearer *b_ptr);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);

commit e0ca2c30b1e9c1ed8b58bccb95c33d25763a4311
Author: Ying Xue <ying.xue@windriver.com>
Date:   Thu Feb 13 17:29:06 2014 -0500

    tipc: move code for resetting links from bearer.c to link.c
    
    We break out the code for resetting attached links in the
    function tipc_reset_bearer(), and define a new function named
    tipc_link_reset_list() to do this job.
    
    This commit incurs no functional changes, but makes the code
    of function tipc_reset_bearer() cleaner. It is also a preparation
    for a more important change to the bearer code, in a subsequent
    commit in this series.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 8addc5ec5fc6..73beecb369e2 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -231,6 +231,7 @@ struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area,
 struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area,
 					  int req_tlv_space);
 void tipc_link_reset(struct tipc_link *l_ptr);
+void tipc_link_reset_list(struct tipc_bearer *b_ptr);
 int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
 void tipc_link_send_names(struct list_head *message_list, u32 dest);
 int tipc_link_send_buf(struct tipc_link *l_ptr, struct sk_buff *buf);

commit 03b92017933bd22a3dca6830048877dd3162f872
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Thu Feb 13 17:29:05 2014 -0500

    tipc: stricter behavior of message reassembly function
    
    The function tipc_link_recv_fragment(struct sk_buff **buf) currently
    leaves the value of the input buffer pointer undefined when it returns,
    except when the return code indicates that the reassembly is complete.
    This despite the fact that it always consumes the input buffer.
    
    Here, we enforce a stricter behavior by this function, ensuring that
    the returned buffer pointer is non-NULL if and only if the reassembly
    is complete. This makes it possible to test for the buffer pointer as
    criteria for successful reassembly.
    
    We also rename the function to tipc_link_frag_rcv(), which is both
    shorter and more in line with common naming practice in the network
    subsystem.
    
    Apart from the new name, these changes have no impact on current
    users of the function, but makes it more practical for use in some
    planned future commits.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 3b6aa65b608c..8addc5ec5fc6 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -239,9 +239,9 @@ int tipc_link_send_sections_fast(struct tipc_port *sender,
 				 struct iovec const *msg_sect,
 				 unsigned int len, u32 destnode);
 void tipc_link_recv_bundle(struct sk_buff *buf);
-int  tipc_link_recv_fragment(struct sk_buff **reasm_head,
-			     struct sk_buff **reasm_tail,
-			     struct sk_buff **fbuf);
+int  tipc_link_frag_rcv(struct sk_buff **reasm_head,
+			struct sk_buff **reasm_tail,
+			struct sk_buff **fbuf);
 void tipc_link_send_proto_msg(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 			      u32 gap, u32 tolerance, u32 priority,
 			      u32 acked_mtu);

commit 581465fa285863344efc233bc546823bfabd295f
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Tue Jan 7 17:02:44 2014 -0500

    tipc: make link start event synchronous
    
    When a link is created we delay the start event by launching it
    to be executed later in a tasklet. As we hold all the
    necessary locks at the moment of creation, and there is no risk
    of deadlock or contention, this delay serves no purpose in the
    current code.
    
    We remove this obsolete indirection step, and the associated function
    link_start(). At the same time, we rename the function tipc_link_stop()
    to the more appropriate tipc_link_purge_queues().
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 89ab89be848d..3b6aa65b608c 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -222,7 +222,7 @@ void tipc_link_dup_send_queue(struct tipc_link *l_ptr,
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);
-void tipc_link_stop(struct tipc_link *l_ptr);
+void tipc_link_purge_queues(struct tipc_link *l_ptr);
 struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area,
 				     int req_tlv_space,
 				     u16 cmd);

commit 170b3927b4c4f6e105964f81ae985fc9772b1f9b
Author: Jon Paul Maloy <jon.maloy@ericsson.com>
Date:   Tue Jan 7 17:02:41 2014 -0500

    tipc: rename functions related to link failover and improve comments
    
    The functionality related to link addition and failover is unnecessarily
    hard to understand and maintain. We try to improve this by renaming
    some of the functions, at the same time adding or improving the
    explanatory comments around them. Names such as "tipc_rcv()" etc. also
    align better with what is used in other networking components.
    
    The changes in this commit are purely cosmetic, no functional changes
    are made.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Reviewed-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 0636ca95be36..89ab89be848d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -216,15 +216,20 @@ struct tipc_link *tipc_link_create(struct tipc_node *n_ptr,
 			      struct tipc_bearer *b_ptr,
 			      const struct tipc_media_addr *media_addr);
 void tipc_link_delete(struct tipc_link *l_ptr);
-void tipc_link_changeover(struct tipc_link *l_ptr);
-void tipc_link_send_duplicate(struct tipc_link *l_ptr, struct tipc_link *dest);
+void tipc_link_failover_send_queue(struct tipc_link *l_ptr);
+void tipc_link_dup_send_queue(struct tipc_link *l_ptr,
+			      struct tipc_link *dest);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);
 void tipc_link_stop(struct tipc_link *l_ptr);
-struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area, int req_tlv_space, u16 cmd);
-struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area, int req_tlv_space);
-struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, int req_tlv_space);
+struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area,
+				     int req_tlv_space,
+				     u16 cmd);
+struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area,
+					 int req_tlv_space);
+struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area,
+					  int req_tlv_space);
 void tipc_link_reset(struct tipc_link *l_ptr);
 int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
 void tipc_link_send_names(struct list_head *message_list, u32 dest);

commit 9805696399ac4e1a7f59ebccc614cbd5d7dace6d
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Sat Jan 4 13:47:48 2014 -0800

    tipc: make local function static
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 424b1dfe436b..0636ca95be36 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -221,7 +221,6 @@ void tipc_link_send_duplicate(struct tipc_link *l_ptr, struct tipc_link *dest);
 void tipc_link_reset_fragments(struct tipc_link *l_ptr);
 int tipc_link_is_up(struct tipc_link *l_ptr);
 int tipc_link_is_active(struct tipc_link *l_ptr);
-u32 tipc_link_push_packet(struct tipc_link *l_ptr);
 void tipc_link_stop(struct tipc_link *l_ptr);
 struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area, int req_tlv_space, u16 cmd);
 struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area, int req_tlv_space);

commit 77a7e07a78a44d6c015fa8447ab84bcdb360e35d
Author: Ying Xue <ying.xue@windriver.com>
Date:   Tue Dec 10 20:45:44 2013 -0800

    tipc: remove unused 'blocked' flag from tipc_link struct
    
    In early versions of TIPC it was possible to administratively block
    individual links through the use of the member flag 'blocked'. This
    functionality was deemed redundant, and since commit 7368dd ("tipc:
    clean out all instances of #if 0'd unused code"), this flag has been
    unused.
    
    In the current code, a link only needs to be blocked for sending and
    reception if it is subject to an ongoing link failover. In that case,
    it is sufficient to check if the number of expected failover packets
    is non-zero, something which is done via the funtion 'link_blocked()'.
    
    This commit finally removes the redundant 'blocked' flag completely.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 8a6c1026644d..424b1dfe436b 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -112,7 +112,6 @@ struct tipc_stats {
  * @continuity_interval: link continuity testing interval [in ms]
  * @abort_limit: # of unacknowledged continuity probes needed to reset link
  * @state: current state of link FSM
- * @blocked: indicates if link has been administratively blocked
  * @fsm_msg_cnt: # of protocol messages link FSM has sent in current state
  * @proto_msg: template for control messages generated by link
  * @pmsg: convenience pointer to "proto_msg" field
@@ -162,7 +161,6 @@ struct tipc_link {
 	u32 continuity_interval;
 	u32 abort_limit;
 	int state;
-	int blocked;
 	u32 fsm_msg_cnt;
 	struct {
 		unchar hdr[INT_H_SIZE];
@@ -312,11 +310,6 @@ static inline int link_reset_reset(struct tipc_link *l_ptr)
 	return l_ptr->state == RESET_RESET;
 }
 
-static inline int link_blocked(struct tipc_link *l_ptr)
-{
-	return l_ptr->exp_msg_count || l_ptr->blocked;
-}
-
 static inline int link_congested(struct tipc_link *l_ptr)
 {
 	return l_ptr->out_queue_size >= l_ptr->queue_limit[0];

commit 40ba3cdf542a469aaa9083fa041656e59b109b90
Author: Erik Hugne <erik.hugne@ericsson.com>
Date:   Wed Nov 6 09:28:06 2013 +0100

    tipc: message reassembly using fragment chain
    
    When the first fragment of a long data data message is received on a link, a
    reassembly buffer large enough to hold the data from this and all subsequent
    fragments of the message is allocated. The payload of each new fragment is
    copied into this buffer upon arrival. When the last fragment is received, the
    reassembled message is delivered upwards to the port/socket layer.
    
    Not only is this an inefficient approach, but it may also cause bursts of
    reassembly failures in low memory situations. since we may fail to allocate
    the necessary large buffer in the first place. Furthermore, after 100 subsequent
    such failures the link will be reset, something that in reality aggravates the
    situation.
    
    To remedy this problem, this patch introduces a different approach. Instead of
    allocating a big reassembly buffer, we now append the arriving fragments
    to a reassembly chain on the link, and deliver the whole chain up to the
    socket layer once the last fragment has been received. This is safe because
    the retransmission layer of a TIPC link always delivers packets in strict
    uninterrupted order, to the reassembly layer as to all other upper layers.
    Hence there can never be more than one fragment chain pending reassembly at
    any given time in a link, and we can trust (but still verify) that the
    fragments will be chained up in the correct order.
    
    Signed-off-by: Erik Hugne <erik.hugne@ericsson.com>
    Reviewed-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 55cf8554a08b..8a6c1026644d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -40,6 +40,12 @@
 #include "msg.h"
 #include "node.h"
 
+/*
+ * Link reassembly status codes
+ */
+#define LINK_REASM_ERROR	-1
+#define LINK_REASM_COMPLETE	1
+
 /*
  * Out-of-range value for link sequence numbers
  */
@@ -134,7 +140,8 @@ struct tipc_stats {
  * @next_out: ptr to first unsent outbound message in queue
  * @waiting_ports: linked list of ports waiting for link congestion to abate
  * @long_msg_seq_no: next identifier to use for outbound fragmented messages
- * @defragm_buf: list of partially reassembled inbound message fragments
+ * @reasm_head: list head of partially reassembled inbound message fragments
+ * @reasm_tail: last fragment received
  * @stats: collects statistics regarding link activity
  */
 struct tipc_link {
@@ -196,9 +203,10 @@ struct tipc_link {
 	struct sk_buff *next_out;
 	struct list_head waiting_ports;
 
-	/* Fragmentation/defragmentation */
+	/* Fragmentation/reassembly */
 	u32 long_msg_seq_no;
-	struct sk_buff *defragm_buf;
+	struct sk_buff *reasm_head;
+	struct sk_buff *reasm_tail;
 
 	/* Statistics */
 	struct tipc_stats stats;
@@ -229,9 +237,9 @@ int tipc_link_send_sections_fast(struct tipc_port *sender,
 				 struct iovec const *msg_sect,
 				 unsigned int len, u32 destnode);
 void tipc_link_recv_bundle(struct sk_buff *buf);
-int  tipc_link_recv_fragment(struct sk_buff **pending,
-			     struct sk_buff **fb,
-			     struct tipc_msg **msg);
+int  tipc_link_recv_fragment(struct sk_buff **reasm_head,
+			     struct sk_buff **reasm_tail,
+			     struct sk_buff **fbuf);
 void tipc_link_send_proto_msg(struct tipc_link *l_ptr, u32 msg_typ, int prob,
 			      u32 gap, u32 tolerance, u32 priority,
 			      u32 acked_mtu);

commit 9446b87addd90a067b21c726aedd3c42694c1780
Author: Ying Xue <ying.xue@windriver.com>
Date:   Fri Oct 18 07:23:15 2013 +0200

    tipc: remove iovec length parameter from all sending functions
    
    tipc_msg_build() now copies message data from iovec to skb_buff
    using memcpy_fromiovecend(), which doesn't need to be passed the
    iovec length to perform the copying.
    
    So we remove the parameter indicating iovec length in all
    functions where TIPC messages are built and sent.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Reviewed-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index c048ed1cbd76..55cf8554a08b 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -227,9 +227,7 @@ int tipc_link_send_buf(struct tipc_link *l_ptr, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
 int tipc_link_send_sections_fast(struct tipc_port *sender,
 				 struct iovec const *msg_sect,
-				 const u32 num_sect,
-				 unsigned int total_len,
-				 u32 destnode);
+				 unsigned int len, u32 destnode);
 void tipc_link_recv_bundle(struct sk_buff *buf);
 int  tipc_link_recv_fragment(struct sk_buff **pending,
 			     struct sk_buff **fb,

commit 3c294cb374bf7ad6f5c2763f994d75935fb7814d
Author: Ying Xue <ying.xue@windriver.com>
Date:   Thu Nov 15 11:34:45 2012 +0800

    tipc: remove the bearer congestion mechanism
    
    Currently at the TIPC bearer layer there is the following congestion
    mechanism:
    
    Once sending packets has failed via that bearer, the bearer will be
    flagged as being in congested state at once. During bearer congestion,
    all packets arriving at link will be queued on the link's outgoing
    buffer.  When we detect that the state of bearer congestion has
    relaxed (e.g. some packets are received from the bearer) we will try
    our best to push all packets in the link's outgoing buffer until the
    buffer is empty, or until the bearer is congested again.
    
    However, in fact the TIPC bearer never receives any feedback from the
    device layer whether a send was successful or not, so it must always
    assume it was successful. Therefore, the bearer congestion mechanism
    as it exists currently is of no value.
    
    But the bearer blocking state is still useful for us. For example,
    when the physical media goes down/up, we need to change the state of
    the links bound to the bearer.  So the code maintaing the state
    information is not removed.
    
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 6e921121be06..c048ed1cbd76 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -40,9 +40,6 @@
 #include "msg.h"
 #include "node.h"
 
-#define PUSH_FAILED   1
-#define PUSH_FINISHED 2
-
 /*
  * Out-of-range value for link sequence numbers
  */
@@ -82,7 +79,6 @@ struct tipc_stats {
 	u32 recv_fragmented;
 	u32 recv_fragments;
 	u32 link_congs;		/* # port sends blocked by congestion */
-	u32 bearer_congs;
 	u32 deferred_recv;
 	u32 duplicates;
 	u32 max_queue_sz;	/* send queue size high water mark */

commit 869dd4662f90514cb92b44a389e85c737b464e25
Author: Erik Hugne <erik.hugne@ericsson.com>
Date:   Fri Jun 29 00:50:24 2012 -0400

    tipc: remove print_buf and deprecated log buffer code
    
    The internal log buffer handling functions can now safely be
    removed since there is no code using it anymore.  Requests to
    interact with the internal tipc log buffer over netlink (in
    config.c) will report 'obsolete command'.
    
    This represents the final removal of any references to a
    struct print_buf, and the removal of the struct itself.
    We also get rid of a TIPC specific Kconfig in the process.
    
    Finally, log.h is removed since it is not needed anymore.
    
    Signed-off-by: Erik Hugne <erik.hugne@ericsson.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 8024a56a1ebc..6e921121be06 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -37,7 +37,6 @@
 #ifndef _TIPC_LINK_H
 #define _TIPC_LINK_H
 
-#include "log.h"
 #include "msg.h"
 #include "node.h"
 

commit 7e9cab58e8e0b5e52af28145ffa70de329adc459
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed Jul 11 09:40:43 2012 -0400

    tipc: factor stats struct out of the larger link struct
    
    This is done to improve readability, and so that we can give
    the struct a name that will allow us to declare a local
    pointer to it in code, instead of having to always redirect
    through the link struct to get to it.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index d6a60a963ce6..8024a56a1ebc 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -63,6 +63,37 @@
  */
 #define MAX_PKT_DEFAULT 1500
 
+struct tipc_stats {
+	u32 sent_info;		/* used in counting # sent packets */
+	u32 recv_info;		/* used in counting # recv'd packets */
+	u32 sent_states;
+	u32 recv_states;
+	u32 sent_probes;
+	u32 recv_probes;
+	u32 sent_nacks;
+	u32 recv_nacks;
+	u32 sent_acks;
+	u32 sent_bundled;
+	u32 sent_bundles;
+	u32 recv_bundled;
+	u32 recv_bundles;
+	u32 retransmitted;
+	u32 sent_fragmented;
+	u32 sent_fragments;
+	u32 recv_fragmented;
+	u32 recv_fragments;
+	u32 link_congs;		/* # port sends blocked by congestion */
+	u32 bearer_congs;
+	u32 deferred_recv;
+	u32 duplicates;
+	u32 max_queue_sz;	/* send queue size high water mark */
+	u32 accu_queue_sz;	/* used for send queue size profiling */
+	u32 queue_sz_counts;	/* used for send queue size profiling */
+	u32 msg_length_counts;	/* used for message length profiling */
+	u32 msg_lengths_total;	/* used for message length profiling */
+	u32 msg_length_profile[7]; /* used for msg. length profiling */
+};
+
 /**
  * struct tipc_link - TIPC link data structure
  * @addr: network address of link's peer node
@@ -175,36 +206,7 @@ struct tipc_link {
 	struct sk_buff *defragm_buf;
 
 	/* Statistics */
-	struct {
-		u32 sent_info;		/* used in counting # sent packets */
-		u32 recv_info;		/* used in counting # recv'd packets */
-		u32 sent_states;
-		u32 recv_states;
-		u32 sent_probes;
-		u32 recv_probes;
-		u32 sent_nacks;
-		u32 recv_nacks;
-		u32 sent_acks;
-		u32 sent_bundled;
-		u32 sent_bundles;
-		u32 recv_bundled;
-		u32 recv_bundles;
-		u32 retransmitted;
-		u32 sent_fragmented;
-		u32 sent_fragments;
-		u32 recv_fragmented;
-		u32 recv_fragments;
-		u32 link_congs;		/* # port sends blocked by congestion */
-		u32 bearer_congs;
-		u32 deferred_recv;
-		u32 duplicates;
-		u32 max_queue_sz;	/* send queue size high water mark */
-		u32 accu_queue_sz;	/* used for send queue size profiling */
-		u32 queue_sz_counts;	/* used for send queue size profiling */
-		u32 msg_length_counts;	/* used for message length profiling */
-		u32 msg_lengths_total;	/* used for message length profiling */
-		u32 msg_length_profile[7]; /* used for msg. length profiling */
-	} stats;
+	struct tipc_stats stats;
 };
 
 struct tipc_port;

commit 617d3c7a50b3dc15f558d60013047aede79dc055
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Apr 30 15:29:02 2012 -0400

    tipc: compress out gratuitous extra carriage returns
    
    Some of the comment blocks are floating in limbo between two
    functions, or between blocks of code.  Delete the extra line
    feeds between any comment and its associated following block
    of code, to be consistent with the majority of the rest of
    the kernel.  Also delete trailing newlines at EOF and fix
    a couple trivial typos in existing comments.
    
    This is a 100% cosmetic change with no runtime impact.  We get
    rid of over 500 lines of non-code, and being blank line deletes,
    they won't even show up as noise in git blame.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 73c18c140e1d..d6a60a963ce6 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -47,13 +47,11 @@
 /*
  * Out-of-range value for link sequence numbers
  */
-
 #define INVALID_LINK_SEQ 0x10000
 
 /*
  * Link states
  */
-
 #define WORKING_WORKING 560810u
 #define WORKING_UNKNOWN 560811u
 #define RESET_UNKNOWN   560812u
@@ -63,7 +61,6 @@
  * Starting value for maximum packet size negotiation on unicast links
  * (unless bearer MTU is less)
  */
-
 #define MAX_PKT_DEFAULT 1500
 
 /**
@@ -114,7 +111,6 @@
  * @defragm_buf: list of partially reassembled inbound message fragments
  * @stats: collects statistics regarding link activity
  */
-
 struct tipc_link {
 	u32 addr;
 	char name[TIPC_MAX_LINK_NAME];
@@ -255,7 +251,6 @@ void tipc_link_retransmit(struct tipc_link *l_ptr,
 /*
  * Link sequence number manipulation routines (uses modulo 2**16 arithmetic)
  */
-
 static inline u32 buf_seqno(struct sk_buff *buf)
 {
 	return msg_seqno(buf_msg(buf));
@@ -294,7 +289,6 @@ static inline u32 lesser(u32 left, u32 right)
 /*
  * Link status checking routines
  */
-
 static inline int link_working_working(struct tipc_link *l_ptr)
 {
 	return l_ptr->state == WORKING_WORKING;

commit a18c4bc3ea3c23f658655b1eee4f62cb71d51efd
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Dec 29 20:58:42 2011 -0500

    tipc: rename struct link* to struct tipc_link*
    
    This converts the following:
    
            struct link             ->      struct tipc_link
            struct link_req         ->      struct tipc_link_req
            struct link_name        ->      struct tipc_link_name
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index d35b0f3045ea..73c18c140e1d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -67,7 +67,7 @@
 #define MAX_PKT_DEFAULT 1500
 
 /**
- * struct link - TIPC link data structure
+ * struct tipc_link - TIPC link data structure
  * @addr: network address of link's peer node
  * @name: link name character string
  * @media_addr: media address to use when sending messages over link
@@ -115,7 +115,7 @@
  * @stats: collects statistics regarding link activity
  */
 
-struct link {
+struct tipc_link {
 	u32 addr;
 	char name[TIPC_MAX_LINK_NAME];
 	struct tipc_media_addr media_addr;
@@ -213,24 +213,24 @@ struct link {
 
 struct tipc_port;
 
-struct link *tipc_link_create(struct tipc_node *n_ptr,
+struct tipc_link *tipc_link_create(struct tipc_node *n_ptr,
 			      struct tipc_bearer *b_ptr,
 			      const struct tipc_media_addr *media_addr);
-void tipc_link_delete(struct link *l_ptr);
-void tipc_link_changeover(struct link *l_ptr);
-void tipc_link_send_duplicate(struct link *l_ptr, struct link *dest);
-void tipc_link_reset_fragments(struct link *l_ptr);
-int tipc_link_is_up(struct link *l_ptr);
-int tipc_link_is_active(struct link *l_ptr);
-u32 tipc_link_push_packet(struct link *l_ptr);
-void tipc_link_stop(struct link *l_ptr);
+void tipc_link_delete(struct tipc_link *l_ptr);
+void tipc_link_changeover(struct tipc_link *l_ptr);
+void tipc_link_send_duplicate(struct tipc_link *l_ptr, struct tipc_link *dest);
+void tipc_link_reset_fragments(struct tipc_link *l_ptr);
+int tipc_link_is_up(struct tipc_link *l_ptr);
+int tipc_link_is_active(struct tipc_link *l_ptr);
+u32 tipc_link_push_packet(struct tipc_link *l_ptr);
+void tipc_link_stop(struct tipc_link *l_ptr);
 struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area, int req_tlv_space, u16 cmd);
 struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area, int req_tlv_space);
 struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, int req_tlv_space);
-void tipc_link_reset(struct link *l_ptr);
+void tipc_link_reset(struct tipc_link *l_ptr);
 int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
 void tipc_link_send_names(struct list_head *message_list, u32 dest);
-int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf);
+int tipc_link_send_buf(struct tipc_link *l_ptr, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
 int tipc_link_send_sections_fast(struct tipc_port *sender,
 				 struct iovec const *msg_sect,
@@ -241,14 +241,16 @@ void tipc_link_recv_bundle(struct sk_buff *buf);
 int  tipc_link_recv_fragment(struct sk_buff **pending,
 			     struct sk_buff **fb,
 			     struct tipc_msg **msg);
-void tipc_link_send_proto_msg(struct link *l_ptr, u32 msg_typ, int prob, u32 gap,
-			      u32 tolerance, u32 priority, u32 acked_mtu);
-void tipc_link_push_queue(struct link *l_ptr);
+void tipc_link_send_proto_msg(struct tipc_link *l_ptr, u32 msg_typ, int prob,
+			      u32 gap, u32 tolerance, u32 priority,
+			      u32 acked_mtu);
+void tipc_link_push_queue(struct tipc_link *l_ptr);
 u32 tipc_link_defer_pkt(struct sk_buff **head, struct sk_buff **tail,
 		   struct sk_buff *buf);
-void tipc_link_wakeup_ports(struct link *l_ptr, int all);
-void tipc_link_set_queue_limits(struct link *l_ptr, u32 window);
-void tipc_link_retransmit(struct link *l_ptr, struct sk_buff *start, u32 retransmits);
+void tipc_link_wakeup_ports(struct tipc_link *l_ptr, int all);
+void tipc_link_set_queue_limits(struct tipc_link *l_ptr, u32 window);
+void tipc_link_retransmit(struct tipc_link *l_ptr,
+			  struct sk_buff *start, u32 retransmits);
 
 /*
  * Link sequence number manipulation routines (uses modulo 2**16 arithmetic)
@@ -293,32 +295,32 @@ static inline u32 lesser(u32 left, u32 right)
  * Link status checking routines
  */
 
-static inline int link_working_working(struct link *l_ptr)
+static inline int link_working_working(struct tipc_link *l_ptr)
 {
 	return l_ptr->state == WORKING_WORKING;
 }
 
-static inline int link_working_unknown(struct link *l_ptr)
+static inline int link_working_unknown(struct tipc_link *l_ptr)
 {
 	return l_ptr->state == WORKING_UNKNOWN;
 }
 
-static inline int link_reset_unknown(struct link *l_ptr)
+static inline int link_reset_unknown(struct tipc_link *l_ptr)
 {
 	return l_ptr->state == RESET_UNKNOWN;
 }
 
-static inline int link_reset_reset(struct link *l_ptr)
+static inline int link_reset_reset(struct tipc_link *l_ptr)
 {
 	return l_ptr->state == RESET_RESET;
 }
 
-static inline int link_blocked(struct link *l_ptr)
+static inline int link_blocked(struct tipc_link *l_ptr)
 {
 	return l_ptr->exp_msg_count || l_ptr->blocked;
 }
 
-static inline int link_congested(struct link *l_ptr)
+static inline int link_congested(struct tipc_link *l_ptr)
 {
 	return l_ptr->out_queue_size >= l_ptr->queue_limit[0];
 }

commit f905730c7ed97dc2dfcbf6af894acd6ce70a62e7
Author: Allan Stephens <allan.stephens@windriver.com>
Date:   Mon Oct 24 16:03:12 2011 -0400

    tipc: Allow use of buf_seqno() helper routine by unicast links
    
    Migrates the buf_seqno() helper routine from broadcast link level to
    unicast link level so that it can be used both types of TIPC links.
    This is a cosmetic change only, and does not affect the operation of TIPC.
    
    Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 78792399d667..d35b0f3045ea 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -254,6 +254,11 @@ void tipc_link_retransmit(struct link *l_ptr, struct sk_buff *start, u32 retrans
  * Link sequence number manipulation routines (uses modulo 2**16 arithmetic)
  */
 
+static inline u32 buf_seqno(struct sk_buff *buf)
+{
+	return msg_seqno(buf_msg(buf));
+}
+
 static inline u32 mod(u32 x)
 {
 	return x & 0xffffu;

commit 3655959143ebf1fd32e28a448d204be2f7f13e99
Author: Allan Stephens <allan.stephens@windriver.com>
Date:   Mon Oct 24 15:26:24 2011 -0400

    tipc: Ignore broadcast acknowledgements that are out-of-range
    
    Adds checks to TIPC's broadcast link so that it ignores any
    acknowledgement message containing a sequence number that does not
    correspond to an unacknowledged message currently in the broadcast
    link's transmit queue.
    
    This change prevents the broadcast link from becoming stalled if a
    newly booted node receives stale broadcast link acknowledgement
    information from another node that has not yet fully synchronized
    its end of the broadcast link to reflect the current state of the
    new node's end.
    
    Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index e56cb532913e..78792399d667 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -44,6 +44,12 @@
 #define PUSH_FAILED   1
 #define PUSH_FINISHED 2
 
+/*
+ * Out-of-range value for link sequence numbers
+ */
+
+#define INVALID_LINK_SEQ 0x10000
+
 /*
  * Link states
  */

commit 9aa88c2a509e11e6efc466c88b386e0e01bef731
Author: Allan Stephens <allan.stephens@windriver.com>
Date:   Tue May 31 13:38:02 2011 -0400

    tipc: Enhance sending of bulk name table messages
    
    Modifies the initial transfer of name table entries to a new neighboring
    node so that the messages are enqueued as a unit, rather than individually.
    
    The revised algorithm now locates the link carrying the message only once,
    and eliminates unnecessary checks for link congestion, message fragmentation,
    and message bundling that are not required when sending these messages.
    
    Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 74fbecab1ea0..e56cb532913e 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -223,6 +223,7 @@ struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area, int req_tlv_s
 struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, int req_tlv_space);
 void tipc_link_reset(struct link *l_ptr);
 int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
+void tipc_link_send_names(struct list_head *message_list, u32 dest);
 int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
 int tipc_link_send_sections_fast(struct tipc_port *sender,

commit 2689690469c9fd76f9db0afcdf2523f48cce4006
Author: Allan Stephens <Allan.Stephens@windriver.com>
Date:   Thu Apr 21 10:42:07 2011 -0500

    tipc: Avoid recomputation of outgoing message length
    
    Rework TIPC's message sending routines to take advantage of the total
    amount of data value passed to it by the kernel socket infrastructure.
    This change eliminates the need for TIPC to compute the size of outgoing
    messages itself, as well as the check for an oversize message in
    tipc_msg_build().  In addition, this change warrants an explanation:
    
       -     res = send_packet(NULL, sock, &my_msg, 0);
       +     res = send_packet(NULL, sock, &my_msg, bytes_to_send);
    
    Previously, the final argument to send_packet() was ignored (since the
    amount of data being sent was recalculated by a lower-level routine)
    and we could just pass in a dummy value (0). Now that the
    recalculation is being eliminated, the argument value being passed to
    send_packet() is significant and we have to supply the actual amount
    of data we want to send.
    
    Signed-off-by: Allan Stephens <Allan.Stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index e6a30dbe1aaa..74fbecab1ea0 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -228,6 +228,7 @@ u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
 int tipc_link_send_sections_fast(struct tipc_port *sender,
 				 struct iovec const *msg_sect,
 				 const u32 num_sect,
+				 unsigned int total_len,
 				 u32 destnode);
 void tipc_link_recv_bundle(struct sk_buff *buf);
 int  tipc_link_recv_fragment(struct sk_buff **pending,

commit 37b9c08a88f9a82456bb11fa050cccb544e8dc60
Author: Allan Stephens <Allan.Stephens@windriver.com>
Date:   Mon Feb 28 11:32:27 2011 -0500

    tipc: Optimizations to link creation code
    
    Enhances link creation code as follows:
    
    1) Detects illegal attempts to add a requested link earlier in the
       link creation process. This prevents TIPC from wasting time
       initializing a link object it then throws away, and also eliminates
       the code needed to do the throwing away.
    
    2) Passes in the node object associated with the requested link.
       This allows TIPC to eliminate a search to locate the node object,
       as well as code that attempted to create the node if it doesn't
       exist.
    
    Signed-off-by: Allan Stephens <Allan.Stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index a7794e7ede29..e6a30dbe1aaa 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -207,7 +207,8 @@ struct link {
 
 struct tipc_port;
 
-struct link *tipc_link_create(struct tipc_bearer *b_ptr, const u32 peer,
+struct link *tipc_link_create(struct tipc_node *n_ptr,
+			      struct tipc_bearer *b_ptr,
 			      const struct tipc_media_addr *media_addr);
 void tipc_link_delete(struct link *l_ptr);
 void tipc_link_changeover(struct link *l_ptr);

commit 9bd80b60827fe8d84c0e594895acb8a44f2b98b1
Author: Allan Stephens <Allan.Stephens@windriver.com>
Date:   Tue Jan 18 15:02:50 2011 -0500

    tipc: Improve accuracy of link transmit queue maximum size statistic
    
    Enhances TIPC's unicast and broadcast link code to update the transmit
    queue maximum size counter in a single place, namely the routine that
    adds messages to the queue. This ensures that the maximum size statistic
    reported for unicast links is completely accurate, rather than being
    partially based on statistical sampling.
    
    The changes to link.h are just documenting the roles of the variables.
    
    Signed-off-by: Allan Stephens <Allan.Stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index bdb0fa263d20..a7794e7ede29 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -196,18 +196,12 @@ struct link {
 		u32 bearer_congs;
 		u32 deferred_recv;
 		u32 duplicates;
-
-		/* for statistical profiling of send queue size */
-
-		u32 max_queue_sz;
-		u32 accu_queue_sz;
-		u32 queue_sz_counts;
-
-		/* for statistical profiling of message lengths */
-
-		u32 msg_length_counts;
-		u32 msg_lengths_total;
-		u32 msg_length_profile[7];
+		u32 max_queue_sz;	/* send queue size high water mark */
+		u32 accu_queue_sz;	/* used for send queue size profiling */
+		u32 queue_sz_counts;	/* used for send queue size profiling */
+		u32 msg_length_counts;	/* used for message length profiling */
+		u32 msg_lengths_total;	/* used for message length profiling */
+		u32 msg_length_profile[7]; /* used for msg. length profiling */
 	} stats;
 };
 

commit 2d627b92fd1e39d83c3ee0b9d410403f98cb3981
Author: Allan Stephens <Allan.Stephens@windriver.com>
Date:   Fri Jan 7 13:00:11 2011 -0500

    tipc: Combine bearer structure with tipc_bearer structure
    
    Combines two distinct structures containing information about a TIPC bearer
    into a single structure. The structures were previously kept separate so
    that public information about a bearer could be made available to plug-in
    media types using TIPC's native API, while the remaining information was
    kept private for use by TIPC itself. However, now that the native API has
    been removed there is no longer any need for this arrangement.
    
    Since one of the structures was already embedded within the other, the
    change largely involves replacing instances of "publ.foo" with "foo".
    The changes do not otherwise alter the operation of TIPC bearers.
    
    Signed-off-by: Allan Stephens <Allan.Stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 85fd3bcb5ed9..bdb0fa263d20 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -122,7 +122,7 @@ struct link {
 	u32 checkpoint;
 	u32 peer_session;
 	u32 peer_bearer_id;
-	struct bearer *b_ptr;
+	struct tipc_bearer *b_ptr;
 	u32 tolerance;
 	u32 continuity_interval;
 	u32 abort_limit;
@@ -213,7 +213,7 @@ struct link {
 
 struct tipc_port;
 
-struct link *tipc_link_create(struct bearer *b_ptr, const u32 peer,
+struct link *tipc_link_create(struct tipc_bearer *b_ptr, const u32 peer,
 			      const struct tipc_media_addr *media_addr);
 void tipc_link_delete(struct link *l_ptr);
 void tipc_link_changeover(struct link *l_ptr);

commit 23dd4cce387124ec3ea06ca30d17854ae4d9b772
Author: Allan Stephens <Allan.Stephens@windriver.com>
Date:   Fri Jan 7 11:43:40 2011 -0500

    tipc: Combine port structure with tipc_port structure
    
    Merge two distinct structures containing information about a TIPC port
    into a single structure. The structures were previously kept separate
    so that public information about a port could be made available to
    applications using TIPC's native API, while the remaining information
    was kept private for use by TIPC itself. However, now that the native
    API has been removed there is no longer any need for this somewhat
    confusing arrangement.
    
    Since one of the structures was already embedded within the other, the
    change largely involves replacing instances of "publ.foo" with "foo".
    The changes do not otherwise alter the operation of TIPC ports.
    
    Signed-off-by: Allan Stephens <Allan.Stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 70967e637027..85fd3bcb5ed9 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -2,7 +2,7 @@
  * net/tipc/link.h: Include file for TIPC link code
  *
  * Copyright (c) 1995-2006, Ericsson AB
- * Copyright (c) 2004-2005, Wind River Systems
+ * Copyright (c) 2004-2005, 2010-2011, Wind River Systems
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -211,7 +211,7 @@ struct link {
 	} stats;
 };
 
-struct port;
+struct tipc_port;
 
 struct link *tipc_link_create(struct bearer *b_ptr, const u32 peer,
 			      const struct tipc_media_addr *media_addr);
@@ -230,7 +230,7 @@ void tipc_link_reset(struct link *l_ptr);
 int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
 int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
-int tipc_link_send_sections_fast(struct port *sender,
+int tipc_link_send_sections_fast(struct tipc_port *sender,
 				 struct iovec const *msg_sect,
 				 const u32 num_sect,
 				 u32 destnode);

commit 0e65967e33be61e5f67727edd4ea829b47676fc0
Author: Allan Stephens <Allan.Stephens@windriver.com>
Date:   Fri Dec 31 18:59:32 2010 +0000

    tipc: cleanup various cosmetic whitespace issues
    
    Cleans up TIPC's source code to eliminate deviations from generally
    accepted coding conventions relating to leading/trailing white space
    and white space around commas, braces, cases, and sizeof.
    
    These changes are purely cosmetic and do not alter the operation of TIPC
    in any way.
    
    Signed-off-by: Allan Stephens <Allan.Stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index eca19c247b79..70967e637027 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -229,8 +229,8 @@ struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, int req_tlv_
 void tipc_link_reset(struct link *l_ptr);
 int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
 int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf);
-u32 tipc_link_get_max_pkt(u32 dest,u32 selector);
-int tipc_link_send_sections_fast(struct port* sender,
+u32 tipc_link_get_max_pkt(u32 dest, u32 selector);
+int tipc_link_send_sections_fast(struct port *sender,
 				 struct iovec const *msg_sect,
 				 const u32 num_sect,
 				 u32 destnode);

commit 8d64a5ba58157dedc61f3f1f51e1c5d66f32a484
Author: Allan Stephens <Allan.Stephens@windriver.com>
Date:   Fri Dec 31 18:59:27 2010 +0000

    tipc: Prune down link-specific debugging code
    
    Eliminates most link-specific debugging code in TIPC, which is now
    largely unnecessary. All calls to the link-specific debugging macros
    have been removed, as are the macros themselves; in addition, the optional
    allocation of print buffers to hold debugging information for each link
    endpoint has been removed. The ability for TIPC to print out helpful
    diagnostic information when link retransmit failures occur has been
    retained for the time being, as an aid in tracking down the cause of
    such failures.
    
    Signed-off-by: Allan Stephens <Allan.Stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index eeb0c015dba9..eca19c247b79 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -107,7 +107,6 @@
  * @long_msg_seq_no: next identifier to use for outbound fragmented messages
  * @defragm_buf: list of partially reassembled inbound message fragments
  * @stats: collects statistics regarding link activity
- * @print_buf: print buffer used to log link activity
  */
 
 struct link {
@@ -210,8 +209,6 @@ struct link {
 		u32 msg_lengths_total;
 		u32 msg_length_profile[7];
 	} stats;
-
-	struct print_buf print_buf;
 };
 
 struct port;

commit f5e75269f59f7c3816f23314b924895e4ecf8409
Author: Allan Stephens <Allan.Stephens@windriver.com>
Date:   Fri Dec 31 18:59:24 2010 +0000

    tipc: rename dbg.[ch] to log.[ch]
    
    As the first step in removing obsolete debugging code from TIPC the
    files that implement TIPC's non-debug-related log buffer subsystem
    are renamed to better reflect their true nature.
    
    Signed-off-by: Allan Stephens <Allan.Stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index c562888d25da..eeb0c015dba9 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -37,7 +37,7 @@
 #ifndef _TIPC_LINK_H
 #define _TIPC_LINK_H
 
-#include "dbg.h"
+#include "log.h"
 #include "msg.h"
 #include "node.h"
 

commit c80262829769419e19527f972672e8df0480235a
Author: Allan Stephens <allan.stephens@windriver.com>
Date:   Tue Nov 30 12:00:54 2010 +0000

    tipc: Remove obsolete inclusions of header files
    
    Gets rid of #include statements that are no longer required as a
    result of the merging of obsolete native API header file content
    into other TIPC include files.
    
    Signed-off-by: Allan Stephens <Allan.Stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index f98bc613de67..c562888d25da 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -39,7 +39,6 @@
 
 #include "dbg.h"
 #include "msg.h"
-#include "bearer.h"
 #include "node.h"
 
 #define PUSH_FAILED   1

commit 31e3c3f6f1f9b154981a0e6620df700463db30ee
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Wed Oct 13 13:20:35 2010 +0000

    tipc: cleanup function namespace
    
    Do some cleanups of TIPC based on make namespacecheck
      1. Don't export unused symbols
      2. Eliminate dead code
      3. Make functions and variables local
      4. Rename buf_acquire to tipc_buf_acquire since it is used in several files
    
    Compile tested only.
    This make break out of tree kernel modules that depend on TIPC routines.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Acked-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 4e944ef4a540..f98bc613de67 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -225,7 +225,6 @@ void tipc_link_send_duplicate(struct link *l_ptr, struct link *dest);
 void tipc_link_reset_fragments(struct link *l_ptr);
 int tipc_link_is_up(struct link *l_ptr);
 int tipc_link_is_active(struct link *l_ptr);
-void tipc_link_start(struct link *l_ptr);
 u32 tipc_link_push_packet(struct link *l_ptr);
 void tipc_link_stop(struct link *l_ptr);
 struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area, int req_tlv_space, u16 cmd);
@@ -239,9 +238,6 @@ int tipc_link_send_sections_fast(struct port* sender,
 				 struct iovec const *msg_sect,
 				 const u32 num_sect,
 				 u32 destnode);
-int tipc_link_send_long_buf(struct link *l_ptr, struct sk_buff *buf);
-void tipc_link_tunnel(struct link *l_ptr, struct tipc_msg *tnl_hdr,
-		      struct tipc_msg *msg, u32 selector);
 void tipc_link_recv_bundle(struct sk_buff *buf);
 int  tipc_link_recv_fragment(struct sk_buff **pending,
 			     struct sk_buff **fb,

commit 7368ddf144afd79456fd853fa25f33e31da003a9
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Tue Oct 12 14:25:58 2010 +0000

    tipc: clean out all instances of #if 0'd unused code
    
    Remove all instances of legacy, or as yet to be implemented code
    that is currently living within an #if 0 ... #endif block.
    In the rare instance that some of it be needed in the future,
    it can still be dragged out of history, but there is no need
    for it to sit in mainline.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 26151d30589d..4e944ef4a540 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -210,10 +210,6 @@ struct link {
 		u32 msg_length_counts;
 		u32 msg_lengths_total;
 		u32 msg_length_profile[7];
-#if 0
-		u32 sent_tunneled;
-		u32 recv_tunneled;
-#endif
 	} stats;
 
 	struct print_buf print_buf;

commit a02cec2155fbea457eca8881870fd2de1a4c4c76
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Wed Sep 22 20:43:57 2010 +0000

    net: return operator cleanup
    
    Change "return (EXPR);" to "return EXPR;"
    
    return is not a function, parentheses are not required.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 2e5385c47d30..26151d30589d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -279,12 +279,12 @@ static inline int between(u32 lower, u32 upper, u32 n)
 
 static inline int less_eq(u32 left, u32 right)
 {
-	return (mod(right - left) < 32768u);
+	return mod(right - left) < 32768u;
 }
 
 static inline int less(u32 left, u32 right)
 {
-	return (less_eq(left, right) && (mod(right) != mod(left)));
+	return less_eq(left, right) && (mod(right) != mod(left));
 }
 
 static inline u32 lesser(u32 left, u32 right)
@@ -299,32 +299,32 @@ static inline u32 lesser(u32 left, u32 right)
 
 static inline int link_working_working(struct link *l_ptr)
 {
-	return (l_ptr->state == WORKING_WORKING);
+	return l_ptr->state == WORKING_WORKING;
 }
 
 static inline int link_working_unknown(struct link *l_ptr)
 {
-	return (l_ptr->state == WORKING_UNKNOWN);
+	return l_ptr->state == WORKING_UNKNOWN;
 }
 
 static inline int link_reset_unknown(struct link *l_ptr)
 {
-	return (l_ptr->state == RESET_UNKNOWN);
+	return l_ptr->state == RESET_UNKNOWN;
 }
 
 static inline int link_reset_reset(struct link *l_ptr)
 {
-	return (l_ptr->state == RESET_RESET);
+	return l_ptr->state == RESET_RESET;
 }
 
 static inline int link_blocked(struct link *l_ptr)
 {
-	return (l_ptr->exp_msg_count || l_ptr->blocked);
+	return l_ptr->exp_msg_count || l_ptr->blocked;
 }
 
 static inline int link_congested(struct link *l_ptr)
 {
-	return (l_ptr->out_queue_size >= l_ptr->queue_limit[0]);
+	return l_ptr->out_queue_size >= l_ptr->queue_limit[0];
 }
 
 #endif

commit 01fee256a675f6492fc6945bbb9b59640d8705d4
Author: Allan Stephens <allan.stephens@windriver.com>
Date:   Tue May 11 14:30:11 2010 +0000

    tipc: Relocate trivial link status functions to header file
    
    Rather than live in link.c where they can only be used in that file alone,
    these helper routines are better served by being in link.h
    
    Relocated are the following:
    
            link_working_working
            link_working_unknown
            link_reset_unknown
            link_reset_reset
            link_blocked
            link_congested
    
    Signed-off-by: Allan Stephens <allan.stephens@windriver.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 6a51e38ad25c..2e5385c47d30 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -292,4 +292,39 @@ static inline u32 lesser(u32 left, u32 right)
 	return less_eq(left, right) ? left : right;
 }
 
+
+/*
+ * Link status checking routines
+ */
+
+static inline int link_working_working(struct link *l_ptr)
+{
+	return (l_ptr->state == WORKING_WORKING);
+}
+
+static inline int link_working_unknown(struct link *l_ptr)
+{
+	return (l_ptr->state == WORKING_UNKNOWN);
+}
+
+static inline int link_reset_unknown(struct link *l_ptr)
+{
+	return (l_ptr->state == RESET_UNKNOWN);
+}
+
+static inline int link_reset_reset(struct link *l_ptr)
+{
+	return (l_ptr->state == RESET_RESET);
+}
+
+static inline int link_blocked(struct link *l_ptr)
+{
+	return (l_ptr->exp_msg_count || l_ptr->blocked);
+}
+
+static inline int link_congested(struct link *l_ptr)
+{
+	return (l_ptr->out_queue_size >= l_ptr->queue_limit[0]);
+}
+
 #endif

commit 6c00055a819ce8a6e2c3af2f65d4ea1a8559c491
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Sep 2 23:38:32 2008 -0700

    tipc: Don't use structure names which easily globally conflict.
    
    Andrew Morton reported a build failure on sparc32, because TIPC
    uses names like "struct node" and there is a like named data
    structure defined in linux/node.h
    
    This just regexp replaces "struct node*" to "struct tipc_node*"
    to avoid this and any future similar problems.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 52f3e7c1871f..6a51e38ad25c 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -116,7 +116,7 @@ struct link {
 	char name[TIPC_MAX_LINK_NAME];
 	struct tipc_media_addr media_addr;
 	struct timer_list timer;
-	struct node *owner;
+	struct tipc_node *owner;
 	struct list_head link_list;
 
 	/* Management and link supervision data */

commit c43072852649d8382b81237ce51195bcec36f24a
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Feb 9 23:25:21 2007 +0900

    [NET] TIPC: Fix whitespace errors.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 2d3c157f707d..52f3e7c1871f 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -1,6 +1,6 @@
 /*
  * net/tipc/link.h: Include file for TIPC link code
- * 
+ *
  * Copyright (c) 1995-2006, Ericsson AB
  * Copyright (c) 2004-2005, Wind River Systems
  * All rights reserved.
@@ -45,8 +45,8 @@
 #define PUSH_FAILED   1
 #define PUSH_FINISHED 2
 
-/* 
- * Link states 
+/*
+ * Link states
  */
 
 #define WORKING_WORKING 560810u
@@ -54,7 +54,7 @@
 #define RESET_UNKNOWN   560812u
 #define RESET_RESET     560813u
 
-/* 
+/*
  * Starting value for maximum packet size negotiation on unicast links
  * (unless bearer MTU is less)
  */
@@ -74,7 +74,7 @@
  * @peer_session: link session # being used by peer end of link
  * @peer_bearer_id: bearer id used by link's peer endpoint
  * @b_ptr: pointer to bearer used by link
- * @tolerance: minimum link continuity loss needed to reset link [in ms] 
+ * @tolerance: minimum link continuity loss needed to reset link [in ms]
  * @continuity_interval: link continuity testing interval [in ms]
  * @abort_limit: # of unacknowledged continuity probes needed to reset link
  * @state: current state of link FSM
@@ -110,7 +110,7 @@
  * @stats: collects statistics regarding link activity
  * @print_buf: print buffer used to log link activity
  */
- 
+
 struct link {
 	u32 addr;
 	char name[TIPC_MAX_LINK_NAME];
@@ -143,18 +143,18 @@ struct link {
 	u32 exp_msg_count;
 	u32 reset_checkpoint;
 
-        /* Max packet negotiation */
-        u32 max_pkt;
-        u32 max_pkt_target;
-        u32 max_pkt_probes;
+	/* Max packet negotiation */
+	u32 max_pkt;
+	u32 max_pkt_target;
+	u32 max_pkt_probes;
 
 	/* Sending */
 	u32 out_queue_size;
 	struct sk_buff *first_out;
 	struct sk_buff *last_out;
 	u32 next_out_no;
-        u32 last_retransmitted;
-        u32 stale_count;
+	u32 last_retransmitted;
+	u32 stale_count;
 
 	/* Reception */
 	u32 next_in_no;
@@ -174,7 +174,7 @@ struct link {
 	u32 long_msg_seq_no;
 	struct sk_buff *defragm_buf;
 
-        /* Statistics */
+	/* Statistics */
 	struct {
 		u32 sent_info;		/* used in counting # sent packets */
 		u32 recv_info;		/* used in counting # recv'd packets */
@@ -239,9 +239,9 @@ void tipc_link_reset(struct link *l_ptr);
 int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
 int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf);
 u32 tipc_link_get_max_pkt(u32 dest,u32 selector);
-int tipc_link_send_sections_fast(struct port* sender, 
+int tipc_link_send_sections_fast(struct port* sender,
 				 struct iovec const *msg_sect,
-				 const u32 num_sect, 
+				 const u32 num_sect,
 				 u32 destnode);
 int tipc_link_send_long_buf(struct link *l_ptr, struct sk_buff *buf);
 void tipc_link_tunnel(struct link *l_ptr, struct tipc_msg *tnl_hdr,
@@ -250,7 +250,7 @@ void tipc_link_recv_bundle(struct sk_buff *buf);
 int  tipc_link_recv_fragment(struct sk_buff **pending,
 			     struct sk_buff **fb,
 			     struct tipc_msg **msg);
-void tipc_link_send_proto_msg(struct link *l_ptr, u32 msg_typ, int prob, u32 gap, 
+void tipc_link_send_proto_msg(struct link *l_ptr, u32 msg_typ, int prob, u32 gap,
 			      u32 tolerance, u32 priority, u32 acked_mtu);
 void tipc_link_push_queue(struct link *l_ptr);
 u32 tipc_link_defer_pkt(struct sk_buff **head, struct sk_buff **tail,

commit 4323add67792ced172d0d93b8b2e6187023115f1
Author: Per Liden <per.liden@ericsson.com>
Date:   Wed Jan 18 00:38:21 2006 +0100

    [TIPC] Avoid polluting the global namespace
    
    This patch adds a tipc_ prefix to all externally visible symbols.
    
    Signed-off-by: Per Liden <per.liden@ericsson.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index c2553f073757..2d3c157f707d 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -221,44 +221,43 @@ struct link {
 
 struct port;
 
-struct link *link_create(struct bearer *b_ptr, const u32 peer,
-			 const struct tipc_media_addr *media_addr);
-void link_delete(struct link *l_ptr);
-void link_changeover(struct link *l_ptr);
-void link_send_duplicate(struct link *l_ptr, struct link *dest);
-void link_reset_fragments(struct link *l_ptr);
-int link_is_up(struct link *l_ptr);
-int link_is_active(struct link *l_ptr);
-void link_start(struct link *l_ptr);
-u32 link_push_packet(struct link *l_ptr);
-void link_stop(struct link *l_ptr);
-struct sk_buff *link_cmd_config(const void *req_tlv_area, int req_tlv_space, u16 cmd);
-struct sk_buff *link_cmd_show_stats(const void *req_tlv_area, int req_tlv_space);
-struct sk_buff *link_cmd_reset_stats(const void *req_tlv_area, int req_tlv_space);
-void link_reset(struct link *l_ptr);
-int link_send(struct sk_buff *buf, u32 dest, u32 selector);
-int link_send_buf(struct link *l_ptr, struct sk_buff *buf);
-u32 link_get_max_pkt(u32 dest,u32 selector);
-int link_send_sections_fast(struct port* sender, 
-			    struct iovec const *msg_sect,
-			    const u32 num_sect, 
-			    u32 destnode);
-
-int link_send_long_buf(struct link *l_ptr, struct sk_buff *buf);
-void link_tunnel(struct link *l_ptr, struct tipc_msg *tnl_hdr,
-		 struct tipc_msg *msg, u32 selector);
-void link_recv_bundle(struct sk_buff *buf);
-int  link_recv_fragment(struct sk_buff **pending,
-			struct sk_buff **fb,
-			struct tipc_msg **msg);
-void link_send_proto_msg(struct link *l_ptr, u32 msg_typ, int prob, u32 gap, 
-			 u32 tolerance, u32 priority, u32 acked_mtu);
-void link_push_queue(struct link *l_ptr);
-u32 link_defer_pkt(struct sk_buff **head, struct sk_buff **tail,
+struct link *tipc_link_create(struct bearer *b_ptr, const u32 peer,
+			      const struct tipc_media_addr *media_addr);
+void tipc_link_delete(struct link *l_ptr);
+void tipc_link_changeover(struct link *l_ptr);
+void tipc_link_send_duplicate(struct link *l_ptr, struct link *dest);
+void tipc_link_reset_fragments(struct link *l_ptr);
+int tipc_link_is_up(struct link *l_ptr);
+int tipc_link_is_active(struct link *l_ptr);
+void tipc_link_start(struct link *l_ptr);
+u32 tipc_link_push_packet(struct link *l_ptr);
+void tipc_link_stop(struct link *l_ptr);
+struct sk_buff *tipc_link_cmd_config(const void *req_tlv_area, int req_tlv_space, u16 cmd);
+struct sk_buff *tipc_link_cmd_show_stats(const void *req_tlv_area, int req_tlv_space);
+struct sk_buff *tipc_link_cmd_reset_stats(const void *req_tlv_area, int req_tlv_space);
+void tipc_link_reset(struct link *l_ptr);
+int tipc_link_send(struct sk_buff *buf, u32 dest, u32 selector);
+int tipc_link_send_buf(struct link *l_ptr, struct sk_buff *buf);
+u32 tipc_link_get_max_pkt(u32 dest,u32 selector);
+int tipc_link_send_sections_fast(struct port* sender, 
+				 struct iovec const *msg_sect,
+				 const u32 num_sect, 
+				 u32 destnode);
+int tipc_link_send_long_buf(struct link *l_ptr, struct sk_buff *buf);
+void tipc_link_tunnel(struct link *l_ptr, struct tipc_msg *tnl_hdr,
+		      struct tipc_msg *msg, u32 selector);
+void tipc_link_recv_bundle(struct sk_buff *buf);
+int  tipc_link_recv_fragment(struct sk_buff **pending,
+			     struct sk_buff **fb,
+			     struct tipc_msg **msg);
+void tipc_link_send_proto_msg(struct link *l_ptr, u32 msg_typ, int prob, u32 gap, 
+			      u32 tolerance, u32 priority, u32 acked_mtu);
+void tipc_link_push_queue(struct link *l_ptr);
+u32 tipc_link_defer_pkt(struct sk_buff **head, struct sk_buff **tail,
 		   struct sk_buff *buf);
-void link_wakeup_ports(struct link *l_ptr, int all);
-void link_set_queue_limits(struct link *l_ptr, u32 window);
-void link_retransmit(struct link *l_ptr, struct sk_buff *start, u32 retransmits);
+void tipc_link_wakeup_ports(struct link *l_ptr, int all);
+void tipc_link_set_queue_limits(struct link *l_ptr, u32 window);
+void tipc_link_retransmit(struct link *l_ptr, struct sk_buff *start, u32 retransmits);
 
 /*
  * Link sequence number manipulation routines (uses modulo 2**16 arithmetic)

commit 593a5f22d8035b1396a958b6bbde9f13c0f09549
Author: Per Liden <per.liden@nospam.ericsson.com>
Date:   Wed Jan 11 19:14:19 2006 +0100

    [TIPC] More updates of file headers
    
    Updated copyright notice to include the year the file was
    actually created. Information about file creation dates
    was extracted from the files in the old CVS repository
    at tipc.sourceforge.net.
    
    Signed-off-by: Per Liden <per.liden@nospam.ericsson.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index 686eb7d684e0..c2553f073757 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -1,7 +1,7 @@
 /*
  * net/tipc/link.h: Include file for TIPC link code
  * 
- * Copyright (c) 2003-2006, Ericsson AB
+ * Copyright (c) 1995-2006, Ericsson AB
  * Copyright (c) 2004-2005, Wind River Systems
  * All rights reserved.
  *

commit 9da1c8b694f8e72a16f259614caaae50cbcdaf10
Author: Per Liden <per.liden@nospam.ericsson.com>
Date:   Wed Jan 11 18:40:41 2006 +0100

    [TIPC] Update of file headers
    
    The copyright statements from different parts of Ericsson
    have been merged into one.
    
    Signed-off-by: Per Liden <per.liden@nospam.ericsson.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index a67868606eff..686eb7d684e0 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -1,9 +1,8 @@
 /*
  * net/tipc/link.h: Include file for TIPC link code
  * 
- * Copyright (c) 2003-2005, Ericsson Research Canada
+ * Copyright (c) 2003-2006, Ericsson AB
  * Copyright (c) 2004-2005, Wind River Systems
- * Copyright (c) 2005-2006, Ericsson AB
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without

commit 9ea1fd3c1a15c620d1e3d0aa269d34b705477003
Author: Per Liden <per.liden@nospam.ericsson.com>
Date:   Wed Jan 11 13:30:43 2006 +0100

    [TIPC] License header update
    
    The license header in each file now more clearly state that this
    code is licensed under a dual BSD/GPL. Before this was only
    evident if you looked at the MODULE_LICENSE line in core.c.
    
    Signed-off-by: Per Liden <per.liden@nospam.ericsson.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
index e7db3476d84e..a67868606eff 100644
--- a/net/tipc/link.h
+++ b/net/tipc/link.h
@@ -6,28 +6,32 @@
  * Copyright (c) 2005-2006, Ericsson AB
  * All rights reserved.
  *
- * Redistribution and use in source and binary forms, with or without 
+ * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions are met:
  *
- * Redistributions of source code must retain the above copyright notice, this 
- * list of conditions and the following disclaimer.
- * Redistributions in binary form must reproduce the above copyright notice, 
- * this list of conditions and the following disclaimer in the documentation 
- * and/or other materials provided with the distribution.
- * Neither the names of the copyright holders nor the names of its 
- * contributors may be used to endorse or promote products derived from this 
- * software without specific prior written permission.
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the names of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
  *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  * POSSIBILITY OF SUCH DAMAGE.
  */
 

commit b97bf3fd8f6a16966d4f18983b2c40993ff937d4
Author: Per Liden <per.liden@nospam.ericsson.com>
Date:   Mon Jan 2 19:04:38 2006 +0100

    [TIPC] Initial merge
    
    TIPC (Transparent Inter Process Communication) is a protocol designed for
    intra cluster communication. For more information see
    http://tipc.sourceforge.net
    
    Signed-off-by: Per Liden <per.liden@nospam.ericsson.com>

diff --git a/net/tipc/link.h b/net/tipc/link.h
new file mode 100644
index 000000000000..e7db3476d84e
--- /dev/null
+++ b/net/tipc/link.h
@@ -0,0 +1,293 @@
+/*
+ * net/tipc/link.h: Include file for TIPC link code
+ * 
+ * Copyright (c) 2003-2005, Ericsson Research Canada
+ * Copyright (c) 2004-2005, Wind River Systems
+ * Copyright (c) 2005-2006, Ericsson AB
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without 
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * Redistributions of source code must retain the above copyright notice, this 
+ * list of conditions and the following disclaimer.
+ * Redistributions in binary form must reproduce the above copyright notice, 
+ * this list of conditions and the following disclaimer in the documentation 
+ * and/or other materials provided with the distribution.
+ * Neither the names of the copyright holders nor the names of its 
+ * contributors may be used to endorse or promote products derived from this 
+ * software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE 
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS 
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN 
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _TIPC_LINK_H
+#define _TIPC_LINK_H
+
+#include "dbg.h"
+#include "msg.h"
+#include "bearer.h"
+#include "node.h"
+
+#define PUSH_FAILED   1
+#define PUSH_FINISHED 2
+
+/* 
+ * Link states 
+ */
+
+#define WORKING_WORKING 560810u
+#define WORKING_UNKNOWN 560811u
+#define RESET_UNKNOWN   560812u
+#define RESET_RESET     560813u
+
+/* 
+ * Starting value for maximum packet size negotiation on unicast links
+ * (unless bearer MTU is less)
+ */
+
+#define MAX_PKT_DEFAULT 1500
+
+/**
+ * struct link - TIPC link data structure
+ * @addr: network address of link's peer node
+ * @name: link name character string
+ * @media_addr: media address to use when sending messages over link
+ * @timer: link timer
+ * @owner: pointer to peer node
+ * @link_list: adjacent links in bearer's list of links
+ * @started: indicates if link has been started
+ * @checkpoint: reference point for triggering link continuity checking
+ * @peer_session: link session # being used by peer end of link
+ * @peer_bearer_id: bearer id used by link's peer endpoint
+ * @b_ptr: pointer to bearer used by link
+ * @tolerance: minimum link continuity loss needed to reset link [in ms] 
+ * @continuity_interval: link continuity testing interval [in ms]
+ * @abort_limit: # of unacknowledged continuity probes needed to reset link
+ * @state: current state of link FSM
+ * @blocked: indicates if link has been administratively blocked
+ * @fsm_msg_cnt: # of protocol messages link FSM has sent in current state
+ * @proto_msg: template for control messages generated by link
+ * @pmsg: convenience pointer to "proto_msg" field
+ * @priority: current link priority
+ * @queue_limit: outbound message queue congestion thresholds (indexed by user)
+ * @exp_msg_count: # of tunnelled messages expected during link changeover
+ * @reset_checkpoint: seq # of last acknowledged message at time of link reset
+ * @max_pkt: current maximum packet size for this link
+ * @max_pkt_target: desired maximum packet size for this link
+ * @max_pkt_probes: # of probes based on current (max_pkt, max_pkt_target)
+ * @out_queue_size: # of messages in outbound message queue
+ * @first_out: ptr to first outbound message in queue
+ * @last_out: ptr to last outbound message in queue
+ * @next_out_no: next sequence number to use for outbound messages
+ * @last_retransmitted: sequence number of most recently retransmitted message
+ * @stale_count: # of identical retransmit requests made by peer
+ * @next_in_no: next sequence number to expect for inbound messages
+ * @deferred_inqueue_sz: # of messages in inbound message queue
+ * @oldest_deferred_in: ptr to first inbound message in queue
+ * @newest_deferred_in: ptr to last inbound message in queue
+ * @unacked_window: # of inbound messages rx'd without ack'ing back to peer
+ * @proto_msg_queue: ptr to (single) outbound control message
+ * @retransm_queue_size: number of messages to retransmit
+ * @retransm_queue_head: sequence number of first message to retransmit
+ * @next_out: ptr to first unsent outbound message in queue
+ * @waiting_ports: linked list of ports waiting for link congestion to abate
+ * @long_msg_seq_no: next identifier to use for outbound fragmented messages
+ * @defragm_buf: list of partially reassembled inbound message fragments
+ * @stats: collects statistics regarding link activity
+ * @print_buf: print buffer used to log link activity
+ */
+ 
+struct link {
+	u32 addr;
+	char name[TIPC_MAX_LINK_NAME];
+	struct tipc_media_addr media_addr;
+	struct timer_list timer;
+	struct node *owner;
+	struct list_head link_list;
+
+	/* Management and link supervision data */
+	int started;
+	u32 checkpoint;
+	u32 peer_session;
+	u32 peer_bearer_id;
+	struct bearer *b_ptr;
+	u32 tolerance;
+	u32 continuity_interval;
+	u32 abort_limit;
+	int state;
+	int blocked;
+	u32 fsm_msg_cnt;
+	struct {
+		unchar hdr[INT_H_SIZE];
+		unchar body[TIPC_MAX_IF_NAME];
+	} proto_msg;
+	struct tipc_msg *pmsg;
+	u32 priority;
+	u32 queue_limit[15];	/* queue_limit[0]==window limit */
+
+	/* Changeover */
+	u32 exp_msg_count;
+	u32 reset_checkpoint;
+
+        /* Max packet negotiation */
+        u32 max_pkt;
+        u32 max_pkt_target;
+        u32 max_pkt_probes;
+
+	/* Sending */
+	u32 out_queue_size;
+	struct sk_buff *first_out;
+	struct sk_buff *last_out;
+	u32 next_out_no;
+        u32 last_retransmitted;
+        u32 stale_count;
+
+	/* Reception */
+	u32 next_in_no;
+	u32 deferred_inqueue_sz;
+	struct sk_buff *oldest_deferred_in;
+	struct sk_buff *newest_deferred_in;
+	u32 unacked_window;
+
+	/* Congestion handling */
+	struct sk_buff *proto_msg_queue;
+	u32 retransm_queue_size;
+	u32 retransm_queue_head;
+	struct sk_buff *next_out;
+	struct list_head waiting_ports;
+
+	/* Fragmentation/defragmentation */
+	u32 long_msg_seq_no;
+	struct sk_buff *defragm_buf;
+
+        /* Statistics */
+	struct {
+		u32 sent_info;		/* used in counting # sent packets */
+		u32 recv_info;		/* used in counting # recv'd packets */
+		u32 sent_states;
+		u32 recv_states;
+		u32 sent_probes;
+		u32 recv_probes;
+		u32 sent_nacks;
+		u32 recv_nacks;
+		u32 sent_acks;
+		u32 sent_bundled;
+		u32 sent_bundles;
+		u32 recv_bundled;
+		u32 recv_bundles;
+		u32 retransmitted;
+		u32 sent_fragmented;
+		u32 sent_fragments;
+		u32 recv_fragmented;
+		u32 recv_fragments;
+		u32 link_congs;		/* # port sends blocked by congestion */
+		u32 bearer_congs;
+		u32 deferred_recv;
+		u32 duplicates;
+
+		/* for statistical profiling of send queue size */
+
+		u32 max_queue_sz;
+		u32 accu_queue_sz;
+		u32 queue_sz_counts;
+
+		/* for statistical profiling of message lengths */
+
+		u32 msg_length_counts;
+		u32 msg_lengths_total;
+		u32 msg_length_profile[7];
+#if 0
+		u32 sent_tunneled;
+		u32 recv_tunneled;
+#endif
+	} stats;
+
+	struct print_buf print_buf;
+};
+
+struct port;
+
+struct link *link_create(struct bearer *b_ptr, const u32 peer,
+			 const struct tipc_media_addr *media_addr);
+void link_delete(struct link *l_ptr);
+void link_changeover(struct link *l_ptr);
+void link_send_duplicate(struct link *l_ptr, struct link *dest);
+void link_reset_fragments(struct link *l_ptr);
+int link_is_up(struct link *l_ptr);
+int link_is_active(struct link *l_ptr);
+void link_start(struct link *l_ptr);
+u32 link_push_packet(struct link *l_ptr);
+void link_stop(struct link *l_ptr);
+struct sk_buff *link_cmd_config(const void *req_tlv_area, int req_tlv_space, u16 cmd);
+struct sk_buff *link_cmd_show_stats(const void *req_tlv_area, int req_tlv_space);
+struct sk_buff *link_cmd_reset_stats(const void *req_tlv_area, int req_tlv_space);
+void link_reset(struct link *l_ptr);
+int link_send(struct sk_buff *buf, u32 dest, u32 selector);
+int link_send_buf(struct link *l_ptr, struct sk_buff *buf);
+u32 link_get_max_pkt(u32 dest,u32 selector);
+int link_send_sections_fast(struct port* sender, 
+			    struct iovec const *msg_sect,
+			    const u32 num_sect, 
+			    u32 destnode);
+
+int link_send_long_buf(struct link *l_ptr, struct sk_buff *buf);
+void link_tunnel(struct link *l_ptr, struct tipc_msg *tnl_hdr,
+		 struct tipc_msg *msg, u32 selector);
+void link_recv_bundle(struct sk_buff *buf);
+int  link_recv_fragment(struct sk_buff **pending,
+			struct sk_buff **fb,
+			struct tipc_msg **msg);
+void link_send_proto_msg(struct link *l_ptr, u32 msg_typ, int prob, u32 gap, 
+			 u32 tolerance, u32 priority, u32 acked_mtu);
+void link_push_queue(struct link *l_ptr);
+u32 link_defer_pkt(struct sk_buff **head, struct sk_buff **tail,
+		   struct sk_buff *buf);
+void link_wakeup_ports(struct link *l_ptr, int all);
+void link_set_queue_limits(struct link *l_ptr, u32 window);
+void link_retransmit(struct link *l_ptr, struct sk_buff *start, u32 retransmits);
+
+/*
+ * Link sequence number manipulation routines (uses modulo 2**16 arithmetic)
+ */
+
+static inline u32 mod(u32 x)
+{
+	return x & 0xffffu;
+}
+
+static inline int between(u32 lower, u32 upper, u32 n)
+{
+	if ((lower < n) && (n < upper))
+		return 1;
+	if ((upper < lower) && ((n > lower) || (n < upper)))
+		return 1;
+	return 0;
+}
+
+static inline int less_eq(u32 left, u32 right)
+{
+	return (mod(right - left) < 32768u);
+}
+
+static inline int less(u32 left, u32 right)
+{
+	return (less_eq(left, right) && (mod(right) != mod(left)));
+}
+
+static inline u32 lesser(u32 left, u32 right)
+{
+	return less_eq(left, right) ? left : right;
+}
+
+#endif
