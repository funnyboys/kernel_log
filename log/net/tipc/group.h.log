commit a1be5a20f137bdf436bab86c18998229908ce951
Author: GhantaKrishnamurthy MohanKrishna <mohan.krishna.ghanta.krishnamurthy@ericsson.com>
Date:   Fri Jun 29 13:26:18 2018 +0200

    tipc: extend sock diag for group communication
    
    This commit extends the existing TIPC socket diagnostics framework
    for information related to TIPC group communication.
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Acked-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: GhantaKrishnamurthy MohanKrishna <mohan.krishna.ghanta.krishnamurthy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/group.h b/net/tipc/group.h
index 5996af6e9f1d..76b4e5a7b39d 100644
--- a/net/tipc/group.h
+++ b/net/tipc/group.h
@@ -72,4 +72,5 @@ void tipc_group_update_rcv_win(struct tipc_group *grp, int blks, u32 node,
 			       u32 port, struct sk_buff_head *xmitq);
 u16 tipc_group_bc_snd_nxt(struct tipc_group *grp);
 void tipc_group_update_member(struct tipc_member *m, int len);
+int tipc_group_fill_sock_diag(struct tipc_group *grp, struct sk_buff *skb);
 #endif

commit 60c2530696320ee6ffe4491c17079fa403790c98
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Wed Jan 17 16:42:46 2018 +0100

    tipc: fix race between poll() and setsockopt()
    
    Letting tipc_poll() dereference a socket's pointer to struct tipc_group
    entails a race risk, as the group item may be deleted in a concurrent
    tipc_sk_join() or tipc_sk_leave() thread.
    
    We now move the 'open' flag in struct tipc_group to struct tipc_sock,
    and let the former retain only a pointer to the moved field. This will
    eliminate the race risk.
    
    Reported-by: syzbot+799dafde0286795858ac@syzkaller.appspotmail.com
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/group.h b/net/tipc/group.h
index f4a596ed9848..5996af6e9f1d 100644
--- a/net/tipc/group.h
+++ b/net/tipc/group.h
@@ -43,7 +43,8 @@ struct tipc_member;
 struct tipc_msg;
 
 struct tipc_group *tipc_group_create(struct net *net, u32 portid,
-				     struct tipc_group_req *mreq);
+				     struct tipc_group_req *mreq,
+				     bool *group_is_open);
 void tipc_group_join(struct net *net, struct tipc_group *grp, int *sk_rcv_buf);
 void tipc_group_delete(struct net *net, struct tipc_group *grp);
 void tipc_group_add_member(struct tipc_group *grp, u32 node,
@@ -67,7 +68,6 @@ void tipc_group_update_bc_members(struct tipc_group *grp, int len, bool ack);
 bool tipc_group_cong(struct tipc_group *grp, u32 dnode, u32 dport,
 		     int len, struct tipc_member **m);
 bool tipc_group_bc_cong(struct tipc_group *grp, int len);
-bool tipc_group_is_open(struct tipc_group *grp);
 void tipc_group_update_rcv_win(struct tipc_group *grp, int blks, u32 node,
 			       u32 port, struct sk_buff_head *xmitq);
 u16 tipc_group_bc_snd_nxt(struct tipc_group *grp);

commit eb929a91b213d2a72c5a8b4af9a1acf63bfb8287
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Mon Jan 8 21:03:31 2018 +0100

    tipc: improve poll() for group member socket
    
    The current criteria for returning POLLOUT from a group member socket is
    too simplistic. It basically returns POLLOUT as soon as the group has
    external destinations, something obviously leading to a lot of spinning
    during destination congestion situations. At the same time, the internal
    congestion handling is unnecessarily complex.
    
    We now change this as follows.
    
    - We introduce an 'open' flag in  struct tipc_group. This flag is used
      only to help poll() get the setting of POLLOUT right, and *not* for
      congeston handling as such. This means that a user can choose to
      ignore an  EAGAIN for a destination and go on sending messages to
      other destinations in the group if he wants to.
    
    - The flag is set to false every time we return EAGAIN on a send call.
    
    - The flag is set to true every time any member, i.e., not necessarily
      the member that caused EAGAIN, is removed from the small_win list.
    
    - We remove the group member 'usr_pending' flag. The size of the send
      window and presence in the 'small_win' list is sufficient criteria
      for recognizing congestion.
    
    This solution seems to be a reasonable compromise between 'anycast',
    which is normally not waiting for POLLOUT for a specific destination,
    and the other three send modes, which are.
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/group.h b/net/tipc/group.h
index dee79477d499..f4a596ed9848 100644
--- a/net/tipc/group.h
+++ b/net/tipc/group.h
@@ -67,9 +67,9 @@ void tipc_group_update_bc_members(struct tipc_group *grp, int len, bool ack);
 bool tipc_group_cong(struct tipc_group *grp, u32 dnode, u32 dport,
 		     int len, struct tipc_member **m);
 bool tipc_group_bc_cong(struct tipc_group *grp, int len);
+bool tipc_group_is_open(struct tipc_group *grp);
 void tipc_group_update_rcv_win(struct tipc_group *grp, int blks, u32 node,
 			       u32 port, struct sk_buff_head *xmitq);
 u16 tipc_group_bc_snd_nxt(struct tipc_group *grp);
 void tipc_group_update_member(struct tipc_member *m, int len);
-int tipc_group_size(struct tipc_group *grp);
 #endif

commit d12d2e12cec2d66eab6cd58f592dad9fd386b97d
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Mon Jan 8 21:03:28 2018 +0100

    tipc: send out join messages as soon as new member is discovered
    
    When a socket is joining a group, we look up in the binding table to
    find if there are already other members of the group present. This is
    used for being able to return EAGAIN instead of EHOSTUNREACH if the
    user proceeds directly to a send attempt.
    
    However, the information in the binding table can be used to directly
    set the created member in state MBR_PUBLISHED and send a JOIN message
    to the peer, instead of waiting for a topology PUBLISH event to do this.
    When there are many members in a group, the propagation time for such
    events can be significant, and we can save time during the join
    operation if we use the initial lookup result fully.
    
    In this commit, we eliminate the member state MBR_DISCOVERED which has
    been the result of the initial lookup, and do instead go directly to
    MBR_PUBLISHED, which initiates the setup.
    
    After this change, the tipc_member FSM looks as follows:
    
         +-----------+
    ---->| PUBLISHED |-----------------------------------------------+
    PUB- +-----------+                                 LEAVE/WITHRAW |
    LISH       |JOIN                                                 |
               |     +-------------------------------------------+   |
               |     |                            LEAVE/WITHDRAW |   |
               |     |                +------------+             |   |
               |     |   +----------->|  PENDING   |---------+   |   |
               |     |   |msg/maxactv +-+---+------+  LEAVE/ |   |   |
               |     |   |              |   |       WITHDRAW |   |   |
               |     |   |   +----------+   |                |   |   |
               |     |   |   |revert/maxactv|                |   |   |
               |     |   |   V              V                V   V   V
               |   +----------+  msg  +------------+       +-----------+
               +-->|  JOINED  |------>|   ACTIVE   |------>|  LEAVING  |--->
               |   +----------+       +--- -+------+ LEAVE/+-----------+DOWN
               |        A   A               |      WITHDRAW A   A    A   EVT
               |        |   |               |RECLAIM        |   |    |
               |        |   |REMIT          V               |   |    |
               |        |   |== adv   +------------+        |   |    |
               |        |   +---------| RECLAIMING |--------+   |    |
               |        |             +-----+------+  LEAVE/    |    |
               |        |                   |REMIT   WITHDRAW   |    |
               |        |                   |< adv              |    |
               |        |msg/               V            LEAVE/ |    |
               |        |adv==ADV_IDLE+------------+   WITHDRAW |    |
               |        +-------------|  REMITTED  |------------+    |
               |                      +------------+                 |
               |PUBLISH                                              |
    JOIN +-----------+                                LEAVE/WITHDRAW |
    ---->|  JOINING  |-----------------------------------------------+
         +-----------+
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/group.h b/net/tipc/group.h
index 5ffffd0121a2..dee79477d499 100644
--- a/net/tipc/group.h
+++ b/net/tipc/group.h
@@ -44,8 +44,10 @@ struct tipc_msg;
 
 struct tipc_group *tipc_group_create(struct net *net, u32 portid,
 				     struct tipc_group_req *mreq);
+void tipc_group_join(struct net *net, struct tipc_group *grp, int *sk_rcv_buf);
 void tipc_group_delete(struct net *net, struct tipc_group *grp);
-void tipc_group_add_member(struct tipc_group *grp, u32 node, u32 port);
+void tipc_group_add_member(struct tipc_group *grp, u32 node,
+			   u32 port, u32 instance);
 struct tipc_nlist *tipc_group_dests(struct tipc_group *grp);
 void tipc_group_self(struct tipc_group *grp, struct tipc_name_seq *seq,
 		     int *scope);

commit 7ad32bcb7855ae8a60a8cf98e1b9da77cfdba4d0
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Mon Jan 8 21:03:26 2018 +0100

    tipc: create group member event messages when they are needed
    
    In the current implementation, a group socket receiving topology
    events about other members just converts the topology event message
    into a group event message and stores it until it reaches the right
    state to issue it to the user. This complicates the code unnecessarily,
    and becomes impractical when we in the coming commits will need to
    create and issue membership events independently.
    
    In this commit, we change this so that we just notice the type and
    origin of the incoming topology event, and then drop the buffer. Only
    when it is time to actually send a group event to the user do we
    explicitly create a new message and send it upwards.
    
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/group.h b/net/tipc/group.h
index d525e1cd7de5..5ffffd0121a2 100644
--- a/net/tipc/group.h
+++ b/net/tipc/group.h
@@ -54,7 +54,7 @@ void tipc_group_filter_msg(struct tipc_group *grp,
 			   struct sk_buff_head *inputq,
 			   struct sk_buff_head *xmitq);
 void tipc_group_member_evt(struct tipc_group *grp, bool *wakeup,
-			   int *sk_rcvbuf, struct sk_buff *skb,
+			   int *sk_rcvbuf, struct tipc_msg *hdr,
 			   struct sk_buff_head *inputq,
 			   struct sk_buff_head *xmitq);
 void tipc_group_proto_rcv(struct tipc_group *grp, bool *wakeup,

commit 2f487712b89376fce267223bbb0db93d393d4b09
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Fri Oct 13 11:04:31 2017 +0200

    tipc: guarantee that group broadcast doesn't bypass group unicast
    
    We need a mechanism guaranteeing that group unicasts sent out from a
    socket are not bypassed by later sent broadcasts from the same socket.
    We do this as follows:
    
    - Each time a unicast is sent, we set a the broadcast method for the
      socket to "replicast" and "mandatory". This forces the first
      subsequent broadcast message to follow the same network and data path
      as the preceding unicast to a destination, hence preventing it from
      overtaking the latter.
    
    - In order to make the 'same data path' statement above true, we let
      group unicasts pass through the multicast link input queue, instead
      of as previously through the unicast link input queue.
    
    - In the first broadcast following a unicast, we set a new header flag,
      requiring all recipients to immediately acknowledge its reception.
    
    - During the period before all the expected acknowledges are received,
      the socket refuses to accept any more broadcast attempts, i.e., by
      blocking or returning EAGAIN. This period should typically not be
      longer than a few microseconds.
    
    - When all acknowledges have been received, the sending socket will
      open up for subsequent broadcasts, this time giving the link layer
      freedom to itself select the best transmission method.
    
    - The forced and/or abrupt transmission method changes described above
      may lead to broadcasts arriving out of order to the recipients. We
      remedy this by introducing code that checks and if necessary
      re-orders such messages at the receiving end.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/group.h b/net/tipc/group.h
index e432066a211e..d525e1cd7de5 100644
--- a/net/tipc/group.h
+++ b/net/tipc/group.h
@@ -61,7 +61,7 @@ void tipc_group_proto_rcv(struct tipc_group *grp, bool *wakeup,
 			  struct tipc_msg *hdr,
 			  struct sk_buff_head *inputq,
 			  struct sk_buff_head *xmitq);
-void tipc_group_update_bc_members(struct tipc_group *grp, int len);
+void tipc_group_update_bc_members(struct tipc_group *grp, int len, bool ack);
 bool tipc_group_cong(struct tipc_group *grp, u32 dnode, u32 dport,
 		     int len, struct tipc_member **m);
 bool tipc_group_bc_cong(struct tipc_group *grp, int len);
@@ -69,7 +69,5 @@ void tipc_group_update_rcv_win(struct tipc_group *grp, int blks, u32 node,
 			       u32 port, struct sk_buff_head *xmitq);
 u16 tipc_group_bc_snd_nxt(struct tipc_group *grp);
 void tipc_group_update_member(struct tipc_member *m, int len);
-struct tipc_member *tipc_group_find_sender(struct tipc_group *grp,
-					   u32 node, u32 port);
 int tipc_group_size(struct tipc_group *grp);
 #endif

commit ee106d7f942dabce1352e01c6fe9ca4a720c2331
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Fri Oct 13 11:04:28 2017 +0200

    tipc: introduce group anycast messaging
    
    In this commit, we make it possible to send connectionless unicast
    messages to any member corresponding to the given member identity,
    when there is more than one such member. The sender must use a
    TIPC_ADDR_NAME address to achieve this effect.
    
    We also perform load balancing between the destinations, i.e., we
    primarily select one which has advertised sufficient send window
    to not cause a block/EAGAIN delay, if any. This mechanism is
    overlayed on the always present round-robin selection.
    
    Anycast messages are subject to the same start synchronization
    and flow control mechanism as group broadcast messages.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/group.h b/net/tipc/group.h
index 8f77290bb415..e432066a211e 100644
--- a/net/tipc/group.h
+++ b/net/tipc/group.h
@@ -49,6 +49,7 @@ void tipc_group_add_member(struct tipc_group *grp, u32 node, u32 port);
 struct tipc_nlist *tipc_group_dests(struct tipc_group *grp);
 void tipc_group_self(struct tipc_group *grp, struct tipc_name_seq *seq,
 		     int *scope);
+u32 tipc_group_exclude(struct tipc_group *grp);
 void tipc_group_filter_msg(struct tipc_group *grp,
 			   struct sk_buff_head *inputq,
 			   struct sk_buff_head *xmitq);
@@ -68,5 +69,7 @@ void tipc_group_update_rcv_win(struct tipc_group *grp, int blks, u32 node,
 			       u32 port, struct sk_buff_head *xmitq);
 u16 tipc_group_bc_snd_nxt(struct tipc_group *grp);
 void tipc_group_update_member(struct tipc_member *m, int len);
+struct tipc_member *tipc_group_find_sender(struct tipc_group *grp,
+					   u32 node, u32 port);
 int tipc_group_size(struct tipc_group *grp);
 #endif

commit 27bd9ec027f396457d1a147043c92ff22fc4c71e
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Fri Oct 13 11:04:27 2017 +0200

    tipc: introduce group unicast messaging
    
    We now make it possible to send connectionless unicast messages
    within a communication group. To send a message, the sender can use
    either a direct port address, aka port identity, or an indirect port
    name to be looked up.
    
    This type of messages are subject to the same start synchronization
    and flow control mechanism as group broadcast messages.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/group.h b/net/tipc/group.h
index 0e2740e1da90..8f77290bb415 100644
--- a/net/tipc/group.h
+++ b/net/tipc/group.h
@@ -61,9 +61,12 @@ void tipc_group_proto_rcv(struct tipc_group *grp, bool *wakeup,
 			  struct sk_buff_head *inputq,
 			  struct sk_buff_head *xmitq);
 void tipc_group_update_bc_members(struct tipc_group *grp, int len);
+bool tipc_group_cong(struct tipc_group *grp, u32 dnode, u32 dport,
+		     int len, struct tipc_member **m);
 bool tipc_group_bc_cong(struct tipc_group *grp, int len);
 void tipc_group_update_rcv_win(struct tipc_group *grp, int blks, u32 node,
 			       u32 port, struct sk_buff_head *xmitq);
 u16 tipc_group_bc_snd_nxt(struct tipc_group *grp);
+void tipc_group_update_member(struct tipc_member *m, int len);
 int tipc_group_size(struct tipc_group *grp);
 #endif

commit b7d42635517fde2b095deddd0fba37be2302a285
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Fri Oct 13 11:04:26 2017 +0200

    tipc: introduce flow control for group broadcast messages
    
    We introduce an end-to-end flow control mechanism for group broadcast
    messages. This ensures that no messages are ever lost because of
    destination receive buffer overflow, with minimal impact on performance.
    For now, the algorithm is based on the assumption that there is only one
    active transmitter at any moment in time.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/group.h b/net/tipc/group.h
index 5d3f10d28967..0e2740e1da90 100644
--- a/net/tipc/group.h
+++ b/net/tipc/group.h
@@ -52,15 +52,18 @@ void tipc_group_self(struct tipc_group *grp, struct tipc_name_seq *seq,
 void tipc_group_filter_msg(struct tipc_group *grp,
 			   struct sk_buff_head *inputq,
 			   struct sk_buff_head *xmitq);
-void tipc_group_member_evt(struct tipc_group *grp,
-			   struct sk_buff *skb,
+void tipc_group_member_evt(struct tipc_group *grp, bool *wakeup,
+			   int *sk_rcvbuf, struct sk_buff *skb,
 			   struct sk_buff_head *inputq,
 			   struct sk_buff_head *xmitq);
-void tipc_group_proto_rcv(struct tipc_group *grp,
+void tipc_group_proto_rcv(struct tipc_group *grp, bool *wakeup,
 			  struct tipc_msg *hdr,
 			  struct sk_buff_head *inputq,
 			  struct sk_buff_head *xmitq);
-void tipc_group_update_bc_members(struct tipc_group *grp);
+void tipc_group_update_bc_members(struct tipc_group *grp, int len);
+bool tipc_group_bc_cong(struct tipc_group *grp, int len);
+void tipc_group_update_rcv_win(struct tipc_group *grp, int blks, u32 node,
+			       u32 port, struct sk_buff_head *xmitq);
 u16 tipc_group_bc_snd_nxt(struct tipc_group *grp);
 int tipc_group_size(struct tipc_group *grp);
 #endif

commit ae236fb208a6fbbd2e7a6913385e8fb78ac807f8
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Fri Oct 13 11:04:25 2017 +0200

    tipc: receive group membership events via member socket
    
    Like with any other service, group members' availability can be
    subscribed for by connecting to be topology server. However, because
    the events arrive via a different socket than the member socket, there
    is a real risk that membership events my arrive out of synch with the
    actual JOIN/LEAVE action. I.e., it is possible to receive the first
    messages from a new member before the corresponding JOIN event arrives,
    just as it is possible to receive the last messages from a leaving
    member after the LEAVE event has already been received.
    
    Since each member socket is internally also subscribing for membership
    events, we now fix this problem by passing those events on to the user
    via the member socket. We leverage the already present member synch-
    ronization protocol to guarantee correct message/event order. An event
    is delivered to the user as an empty message where the two source
    addresses identify the new/lost member. Furthermore, we set the MSG_OOB
    bit in the message flags to mark it as an event. If the event is an
    indication about a member loss we also set the MSG_EOR bit, so it can
    be distinguished from a member addition event.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/group.h b/net/tipc/group.h
index 9bdf4479fc03..5d3f10d28967 100644
--- a/net/tipc/group.h
+++ b/net/tipc/group.h
@@ -54,9 +54,11 @@ void tipc_group_filter_msg(struct tipc_group *grp,
 			   struct sk_buff_head *xmitq);
 void tipc_group_member_evt(struct tipc_group *grp,
 			   struct sk_buff *skb,
+			   struct sk_buff_head *inputq,
 			   struct sk_buff_head *xmitq);
 void tipc_group_proto_rcv(struct tipc_group *grp,
 			  struct tipc_msg *hdr,
+			  struct sk_buff_head *inputq,
 			  struct sk_buff_head *xmitq);
 void tipc_group_update_bc_members(struct tipc_group *grp);
 u16 tipc_group_bc_snd_nxt(struct tipc_group *grp);

commit 75da2163dbb6af9f2dce1d80056d11d290dd19a5
Author: Jon Maloy <jon.maloy@ericsson.com>
Date:   Fri Oct 13 11:04:23 2017 +0200

    tipc: introduce communication groups
    
    As a preparation for introducing flow control for multicast and datagram
    messaging we need a more strictly defined framework than we have now. A
    socket must be able keep track of exactly how many and which other
    sockets it is allowed to communicate with at any moment, and keep the
    necessary state for those.
    
    We therefore introduce a new concept we have named Communication Group.
    Sockets can join a group via a new setsockopt() call TIPC_GROUP_JOIN.
    The call takes four parameters: 'type' serves as group identifier,
    'instance' serves as an logical member identifier, and 'scope' indicates
    the visibility of the group (node/cluster/zone). Finally, 'flags' makes
    it possible to set certain properties for the member. For now, there is
    only one flag, indicating if the creator of the socket wants to receive
    a copy of broadcast or multicast messages it is sending via the socket,
    and if wants to be eligible as destination for its own anycasts.
    
    A group is closed, i.e., sockets which have not joined a group will
    not be able to send messages to or receive messages from members of
    the group, and vice versa.
    
    Any member of a group can send multicast ('group broadcast') messages
    to all group members, optionally including itself, using the primitive
    send(). The messages are received via the recvmsg() primitive. A socket
    can only be member of one group at a time.
    
    Signed-off-by: Jon Maloy <jon.maloy@ericsson.com>
    Acked-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/tipc/group.h b/net/tipc/group.h
new file mode 100644
index 000000000000..9bdf4479fc03
--- /dev/null
+++ b/net/tipc/group.h
@@ -0,0 +1,64 @@
+/*
+ * net/tipc/group.h: Include file for TIPC group unicast/multicast functions
+ *
+ * Copyright (c) 2017, Ericsson AB
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the names of the copyright holders nor the names of its
+ *    contributors may be used to endorse or promote products derived from
+ *    this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _TIPC_GROUP_H
+#define _TIPC_GROUP_H
+
+#include "core.h"
+
+struct tipc_group;
+struct tipc_member;
+struct tipc_msg;
+
+struct tipc_group *tipc_group_create(struct net *net, u32 portid,
+				     struct tipc_group_req *mreq);
+void tipc_group_delete(struct net *net, struct tipc_group *grp);
+void tipc_group_add_member(struct tipc_group *grp, u32 node, u32 port);
+struct tipc_nlist *tipc_group_dests(struct tipc_group *grp);
+void tipc_group_self(struct tipc_group *grp, struct tipc_name_seq *seq,
+		     int *scope);
+void tipc_group_filter_msg(struct tipc_group *grp,
+			   struct sk_buff_head *inputq,
+			   struct sk_buff_head *xmitq);
+void tipc_group_member_evt(struct tipc_group *grp,
+			   struct sk_buff *skb,
+			   struct sk_buff_head *xmitq);
+void tipc_group_proto_rcv(struct tipc_group *grp,
+			  struct tipc_msg *hdr,
+			  struct sk_buff_head *xmitq);
+void tipc_group_update_bc_members(struct tipc_group *grp);
+u16 tipc_group_bc_snd_nxt(struct tipc_group *grp);
+int tipc_group_size(struct tipc_group *grp);
+#endif
