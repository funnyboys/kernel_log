commit f5dda315b63775fe00f5470687d40ce801ddfb38
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Wed May 6 11:41:07 2020 -0400

    net: hsr: fix incorrect type usage for protocol variable
    
    Fix following sparse checker warning:-
    
    net/hsr/hsr_slave.c:38:18: warning: incorrect type in assignment (different base types)
    net/hsr/hsr_slave.c:38:18:    expected unsigned short [unsigned] [usertype] protocol
    net/hsr/hsr_slave.c:38:18:    got restricted __be16 [usertype] h_proto
    net/hsr/hsr_slave.c:39:25: warning: restricted __be16 degrades to integer
    net/hsr/hsr_slave.c:39:57: warning: restricted __be16 degrades to integer
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Acked-by: Vinicius Costa Gomes <vinicius.gomes@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index f4b9f7a3ce51..25b6ffba26cd 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -18,7 +18,7 @@ static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 {
 	struct sk_buff *skb = *pskb;
 	struct hsr_port *port;
-	u16 protocol;
+	__be16 protocol;
 
 	if (!skb_mac_header_was_set(skb)) {
 		WARN_ONCE(1, "%s: skb invalid", __func__);

commit 9fb16955fb661945ddffce4504dcffbe55cd518a
Merge: 1f074e677a34 1b649e0bcae7
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Mar 25 18:58:11 2020 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/netdev/net
    
    Overlapping header include additions in macsec.c
    
    A bug fix in 'net' overlapping with the removal of 'version'
    string in ena_netdev.c
    
    Overlapping test additions in selftests Makefile
    
    Overlapping PCI ID table adjustments in iwlwifi driver.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 3a303cfdd28d5f930a307c82e8a9d996394d5ebd
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sat Mar 21 06:46:50 2020 +0000

    hsr: fix general protection fault in hsr_addr_is_self()
    
    The port->hsr is used in the hsr_handle_frame(), which is a
    callback of rx_handler.
    hsr master and slaves are initialized in hsr_add_port().
    This function initializes several pointers, which includes port->hsr after
    registering rx_handler.
    So, in the rx_handler routine, un-initialized pointer would be used.
    In order to fix this, pointers should be initialized before
    registering rx_handler.
    
    Test commands:
        ip netns del left
        ip netns del right
        modprobe -rv veth
        modprobe -rv hsr
        killall ping
        modprobe hsr
        ip netns add left
        ip netns add right
        ip link add veth0 type veth peer name veth1
        ip link add veth2 type veth peer name veth3
        ip link add veth4 type veth peer name veth5
        ip link set veth1 netns left
        ip link set veth3 netns right
        ip link set veth4 netns left
        ip link set veth5 netns right
        ip link set veth0 up
        ip link set veth2 up
        ip link set veth0 address fc:00:00:00:00:01
        ip link set veth2 address fc:00:00:00:00:02
        ip netns exec left ip link set veth1 up
        ip netns exec left ip link set veth4 up
        ip netns exec right ip link set veth3 up
        ip netns exec right ip link set veth5 up
        ip link add hsr0 type hsr slave1 veth0 slave2 veth2
        ip a a 192.168.100.1/24 dev hsr0
        ip link set hsr0 up
        ip netns exec left ip link add hsr1 type hsr slave1 veth1 slave2 veth4
        ip netns exec left ip a a 192.168.100.2/24 dev hsr1
        ip netns exec left ip link set hsr1 up
        ip netns exec left ip n a 192.168.100.1 dev hsr1 lladdr \
                fc:00:00:00:00:01 nud permanent
        ip netns exec left ip n r 192.168.100.1 dev hsr1 lladdr \
                fc:00:00:00:00:01 nud permanent
        for i in {1..100}
        do
            ip netns exec left ping 192.168.100.1 &
        done
        ip netns exec left hping3 192.168.100.1 -2 --flood &
        ip netns exec right ip link add hsr2 type hsr slave1 veth3 slave2 veth5
        ip netns exec right ip a a 192.168.100.3/24 dev hsr2
        ip netns exec right ip link set hsr2 up
        ip netns exec right ip n a 192.168.100.1 dev hsr2 lladdr \
                fc:00:00:00:00:02 nud permanent
        ip netns exec right ip n r 192.168.100.1 dev hsr2 lladdr \
                fc:00:00:00:00:02 nud permanent
        for i in {1..100}
        do
            ip netns exec right ping 192.168.100.1 &
        done
        ip netns exec right hping3 192.168.100.1 -2 --flood &
        while :
        do
            ip link add hsr0 type hsr slave1 veth0 slave2 veth2
            ip a a 192.168.100.1/24 dev hsr0
            ip link set hsr0 up
            ip link del hsr0
        done
    
    Splat looks like:
    [  120.954938][    C0] general protection fault, probably for non-canonical address 0xdffffc0000000006: 0000 [#1]I
    [  120.957761][    C0] KASAN: null-ptr-deref in range [0x0000000000000030-0x0000000000000037]
    [  120.959064][    C0] CPU: 0 PID: 1511 Comm: hping3 Not tainted 5.6.0-rc5+ #460
    [  120.960054][    C0] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  120.962261][    C0] RIP: 0010:hsr_addr_is_self+0x65/0x2a0 [hsr]
    [  120.963149][    C0] Code: 44 24 18 70 73 2f c0 48 c1 eb 03 48 8d 04 13 c7 00 f1 f1 f1 f1 c7 40 04 00 f2 f2 f2 4
    [  120.966277][    C0] RSP: 0018:ffff8880d9c09af0 EFLAGS: 00010206
    [  120.967293][    C0] RAX: 0000000000000006 RBX: 1ffff1101b38135f RCX: 0000000000000000
    [  120.968516][    C0] RDX: dffffc0000000000 RSI: ffff8880d17cb208 RDI: 0000000000000000
    [  120.969718][    C0] RBP: 0000000000000030 R08: ffffed101b3c0e3c R09: 0000000000000001
    [  120.972203][    C0] R10: 0000000000000001 R11: ffffed101b3c0e3b R12: 0000000000000000
    [  120.973379][    C0] R13: ffff8880aaf80100 R14: ffff8880aaf800f2 R15: ffff8880aaf80040
    [  120.974410][    C0] FS:  00007f58e693f740(0000) GS:ffff8880d9c00000(0000) knlGS:0000000000000000
    [  120.979794][    C0] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  120.980773][    C0] CR2: 00007ffcb8b38f29 CR3: 00000000afe8e001 CR4: 00000000000606f0
    [  120.981945][    C0] Call Trace:
    [  120.982411][    C0]  <IRQ>
    [  120.982848][    C0]  ? hsr_add_node+0x8c0/0x8c0 [hsr]
    [  120.983522][    C0]  ? rcu_read_lock_held+0x90/0xa0
    [  120.984159][    C0]  ? rcu_read_lock_sched_held+0xc0/0xc0
    [  120.984944][    C0]  hsr_handle_frame+0x1db/0x4e0 [hsr]
    [  120.985597][    C0]  ? hsr_nl_nodedown+0x2b0/0x2b0 [hsr]
    [  120.986289][    C0]  __netif_receive_skb_core+0x6bf/0x3170
    [  120.992513][    C0]  ? check_chain_key+0x236/0x5d0
    [  120.993223][    C0]  ? do_xdp_generic+0x1460/0x1460
    [  120.993875][    C0]  ? register_lock_class+0x14d0/0x14d0
    [  120.994609][    C0]  ? __netif_receive_skb_one_core+0x8d/0x160
    [  120.995377][    C0]  __netif_receive_skb_one_core+0x8d/0x160
    [  120.996204][    C0]  ? __netif_receive_skb_core+0x3170/0x3170
    [ ... ]
    
    Reported-by: syzbot+fcf5dd39282ceb27108d@syzkaller.appspotmail.com
    Fixes: c5a759117210 ("net/hsr: Use list_head (and rcu) instead of array for slave devices.")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index fbfd0db182b7..a9104d42aafb 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -145,16 +145,16 @@ int hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,
 	if (!port)
 		return -ENOMEM;
 
+	port->hsr = hsr;
+	port->dev = dev;
+	port->type = type;
+
 	if (type != HSR_PT_MASTER) {
 		res = hsr_portdev_setup(dev, port);
 		if (res)
 			goto fail_dev_setup;
 	}
 
-	port->hsr = hsr;
-	port->dev = dev;
-	port->type = type;
-
 	list_add_tail_rcu(&port->port_list, &hsr->ports);
 	synchronize_rcu();
 

commit 56dc0a0eac999b77b1d37fe83a3c0409a6066319
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Mar 5 00:02:54 2020 +0000

    hsr: fix refcnt leak of hsr slave interface
    
    In the commit e0a4b99773d3 ("hsr: use upper/lower device infrastructure"),
    dev_get() was removed but dev_put() in the error path wasn't removed.
    So, if creating hsr interface command is failed, the reference counter leak
    of lower interface would occur.
    
    Test commands:
        ip link add dummy0 type dummy
        ip link add ipvlan0 link dummy0 type ipvlan mode l2
        ip link add ipvlan1 link dummy0 type ipvlan mode l2
        ip link add hsr0 type hsr slave1 ipvlan0 slave2 ipvlan1
        ip link del ipvlan0
    
    Result:
    [  633.271992][ T1280] unregister_netdevice: waiting for ipvlan0 to become free. Usage count = -1
    
    Fixes: e0a4b99773d3 ("hsr: use upper/lower device infrastructure")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index 123605cb5420..d3547e8c6d5b 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -108,7 +108,7 @@ static int hsr_portdev_setup(struct hsr_priv *hsr, struct net_device *dev,
 
 	res = dev_set_promiscuity(dev, 1);
 	if (res)
-		goto fail_promiscuity;
+		return res;
 
 	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 	hsr_dev = master->dev;
@@ -128,9 +128,6 @@ static int hsr_portdev_setup(struct hsr_priv *hsr, struct net_device *dev,
 	netdev_upper_dev_unlink(dev, hsr_dev);
 fail_upper_dev_link:
 	dev_set_promiscuity(dev, -1);
-fail_promiscuity:
-	dev_put(dev);
-
 	return res;
 }
 

commit e0a4b99773d3d8d3fb40087805f8fd858a23e582
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Fri Feb 28 18:02:10 2020 +0000

    hsr: use upper/lower device infrastructure
    
    netdev_upper_dev_link() is useful to manage lower/upper interfaces.
    And this function internally validates looping, maximum depth.
    All or most virtual interfaces that could have a real interface
    (e.g. macsec, macvlan, ipvlan etc.) use lower/upper infrastructure.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index 07edc7f626fe..123605cb5420 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -97,19 +97,25 @@ static int hsr_check_dev_ok(struct net_device *dev,
 }
 
 /* Setup device to be added to the HSR bridge. */
-static int hsr_portdev_setup(struct net_device *dev, struct hsr_port *port)
+static int hsr_portdev_setup(struct hsr_priv *hsr, struct net_device *dev,
+			     struct hsr_port *port,
+			     struct netlink_ext_ack *extack)
+
 {
+	struct net_device *hsr_dev;
+	struct hsr_port *master;
 	int res;
 
-	dev_hold(dev);
 	res = dev_set_promiscuity(dev, 1);
 	if (res)
 		goto fail_promiscuity;
 
-	/* FIXME:
-	 * What does net device "adjacency" mean? Should we do
-	 * res = netdev_master_upper_dev_link(port->dev, port->hsr->dev); ?
-	 */
+	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+	hsr_dev = master->dev;
+
+	res = netdev_upper_dev_link(dev, hsr_dev, extack);
+	if (res)
+		goto fail_upper_dev_link;
 
 	res = netdev_rx_handler_register(dev, hsr_handle_frame, port);
 	if (res)
@@ -119,6 +125,8 @@ static int hsr_portdev_setup(struct net_device *dev, struct hsr_port *port)
 	return 0;
 
 fail_rx_handler:
+	netdev_upper_dev_unlink(dev, hsr_dev);
+fail_upper_dev_link:
 	dev_set_promiscuity(dev, -1);
 fail_promiscuity:
 	dev_put(dev);
@@ -147,7 +155,7 @@ int hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,
 		return -ENOMEM;
 
 	if (type != HSR_PT_MASTER) {
-		res = hsr_portdev_setup(dev, port);
+		res = hsr_portdev_setup(hsr, dev, port, extack);
 		if (res)
 			goto fail_dev_setup;
 	}
@@ -180,21 +188,14 @@ void hsr_del_port(struct hsr_port *port)
 	list_del_rcu(&port->port_list);
 
 	if (port != master) {
-		if (master) {
-			netdev_update_features(master->dev);
-			dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
-		}
+		netdev_update_features(master->dev);
+		dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
 		netdev_rx_handler_unregister(port->dev);
 		dev_set_promiscuity(port->dev, -1);
+		netdev_upper_dev_unlink(port->dev, master->dev);
 	}
 
-	/* FIXME?
-	 * netdev_upper_dev_unlink(port->dev, port->hsr->dev);
-	 */
-
 	synchronize_rcu();
 
-	if (port != master)
-		dev_put(port->dev);
 	kfree(port);
 }

commit 81390d0c4e56ac7752c97d7e8209357673d1a8ab
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Fri Feb 28 18:01:56 2020 +0000

    hsr: remove unnecessary rcu_read_lock() in hsr module
    
    In order to access the port list, the hsr_port_get_hsr() is used.
    And this is protected by RTNL and RCU.
    The hsr_fill_info(), hsr_check_carrier(), hsr_dev_open() and
    hsr_get_max_mtu() are protected by RTNL.
    So, rcu_read_lock() in these functions are not necessary.
    The hsr_handle_frame() also uses rcu_read_lock() but this function
    is called by packet path.
    It's already protected by RCU.
    So, the rcu_read_lock() in hsr_handle_frame() can be removed.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index 127ebcc0e28f..07edc7f626fe 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -25,7 +25,6 @@ static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 		return RX_HANDLER_PASS;
 	}
 
-	rcu_read_lock(); /* hsr->node_db, hsr->ports */
 	port = hsr_port_get_rcu(skb->dev);
 	if (!port)
 		goto finish_pass;
@@ -45,11 +44,9 @@ static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 	hsr_forward_skb(skb, port);
 
 finish_consume:
-	rcu_read_unlock(); /* hsr->node_db, hsr->ports */
 	return RX_HANDLER_CONSUMED;
 
 finish_pass:
-	rcu_read_unlock(); /* hsr->node_db, hsr->ports */
 	return RX_HANDLER_PASS;
 }
 

commit 13eeb5fea68e11765020b846ef692809c5fe04aa
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Fri Feb 28 18:01:35 2020 +0000

    hsr: use extack error message instead of netdev_info
    
    If HSR uses the extack instead of netdev_info(), users can get
    error messages immediately without any checking the kernel message.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index fbfd0db182b7..127ebcc0e28f 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -58,33 +58,37 @@ bool hsr_port_exists(const struct net_device *dev)
 	return rcu_access_pointer(dev->rx_handler) == hsr_handle_frame;
 }
 
-static int hsr_check_dev_ok(struct net_device *dev)
+static int hsr_check_dev_ok(struct net_device *dev,
+			    struct netlink_ext_ack *extack)
 {
 	/* Don't allow HSR on non-ethernet like devices */
 	if ((dev->flags & IFF_LOOPBACK) || dev->type != ARPHRD_ETHER ||
 	    dev->addr_len != ETH_ALEN) {
-		netdev_info(dev, "Cannot use loopback or non-ethernet device as HSR slave.\n");
+		NL_SET_ERR_MSG_MOD(extack, "Cannot use loopback or non-ethernet device as HSR slave.");
 		return -EINVAL;
 	}
 
 	/* Don't allow enslaving hsr devices */
 	if (is_hsr_master(dev)) {
-		netdev_info(dev, "Cannot create trees of HSR devices.\n");
+		NL_SET_ERR_MSG_MOD(extack,
+				   "Cannot create trees of HSR devices.");
 		return -EINVAL;
 	}
 
 	if (hsr_port_exists(dev)) {
-		netdev_info(dev, "This device is already a HSR slave.\n");
+		NL_SET_ERR_MSG_MOD(extack,
+				   "This device is already a HSR slave.");
 		return -EINVAL;
 	}
 
 	if (is_vlan_dev(dev)) {
-		netdev_info(dev, "HSR on top of VLAN is not yet supported in this driver.\n");
+		NL_SET_ERR_MSG_MOD(extack, "HSR on top of VLAN is not yet supported in this driver.");
 		return -EINVAL;
 	}
 
 	if (dev->priv_flags & IFF_DONT_BRIDGE) {
-		netdev_info(dev, "This device does not support bridging.\n");
+		NL_SET_ERR_MSG_MOD(extack,
+				   "This device does not support bridging.");
 		return -EOPNOTSUPP;
 	}
 
@@ -126,13 +130,13 @@ static int hsr_portdev_setup(struct net_device *dev, struct hsr_port *port)
 }
 
 int hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,
-		 enum hsr_port_type type)
+		 enum hsr_port_type type, struct netlink_ext_ack *extack)
 {
 	struct hsr_port *port, *master;
 	int res;
 
 	if (type != HSR_PT_MASTER) {
-		res = hsr_check_dev_ok(dev);
+		res = hsr_check_dev_ok(dev, extack);
 		if (res)
 			return res;
 	}

commit 2b5b8251bc9fe2f9118411f037862ee17cf81e97
Author: Eric Dumazet <edumazet@google.com>
Date:   Mon Feb 3 10:15:07 2020 -0800

    net: hsr: fix possible NULL deref in hsr_handle_frame()
    
    hsr_port_get_rcu() can return NULL, so we need to be careful.
    
    general protection fault, probably for non-canonical address 0xdffffc0000000006: 0000 [#1] PREEMPT SMP KASAN
    KASAN: null-ptr-deref in range [0x0000000000000030-0x0000000000000037]
    CPU: 1 PID: 10249 Comm: syz-executor.5 Not tainted 5.5.0-syzkaller #0
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    RIP: 0010:__read_once_size include/linux/compiler.h:199 [inline]
    RIP: 0010:hsr_addr_is_self+0x86/0x330 net/hsr/hsr_framereg.c:44
    Code: 04 00 f3 f3 f3 65 48 8b 04 25 28 00 00 00 48 89 45 d0 31 c0 e8 6b ff 94 f9 4c 89 f2 48 b8 00 00 00 00 00 fc ff df 48 c1 ea 03 <80> 3c 02 00 0f 85 75 02 00 00 48 8b 43 30 49 39 c6 49 89 47 c0 0f
    RSP: 0018:ffffc90000da8a90 EFLAGS: 00010206
    RAX: dffffc0000000000 RBX: 0000000000000000 RCX: ffffffff87e0cc33
    RDX: 0000000000000006 RSI: ffffffff87e035d5 RDI: 0000000000000000
    RBP: ffffc90000da8b20 R08: ffff88808e7de040 R09: ffffed1015d2707c
    R10: ffffed1015d2707b R11: ffff8880ae9383db R12: ffff8880a689bc5e
    R13: 1ffff920001b5153 R14: 0000000000000030 R15: ffffc90000da8af8
    FS:  00007fd7a42be700(0000) GS:ffff8880ae900000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 0000001b32338000 CR3: 00000000a928c000 CR4: 00000000001406e0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     <IRQ>
     hsr_handle_frame+0x1c5/0x630 net/hsr/hsr_slave.c:31
     __netif_receive_skb_core+0xfbc/0x30b0 net/core/dev.c:5099
     __netif_receive_skb_one_core+0xa8/0x1a0 net/core/dev.c:5196
     __netif_receive_skb+0x2c/0x1d0 net/core/dev.c:5312
     process_backlog+0x206/0x750 net/core/dev.c:6144
     napi_poll net/core/dev.c:6582 [inline]
     net_rx_action+0x508/0x1120 net/core/dev.c:6650
     __do_softirq+0x262/0x98c kernel/softirq.c:292
     do_softirq_own_stack+0x2a/0x40 arch/x86/entry/entry_64.S:1082
     </IRQ>
    
    Fixes: c5a759117210 ("net/hsr: Use list_head (and rcu) instead of array for slave devices.")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index ee561297d8a7..fbfd0db182b7 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -27,6 +27,8 @@ static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 
 	rcu_read_lock(); /* hsr->node_db, hsr->ports */
 	port = hsr_port_get_rcu(skb->dev);
+	if (!port)
+		goto finish_pass;
 
 	if (hsr_addr_is_self(port->hsr, eth_hdr(skb)->h_source)) {
 		/* Directly kill frames sent by ourselves */

commit 619afef01f74f3572b5e9a266c1230dc83761eec
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Wed Jul 3 17:21:12 2019 -0700

    hsr: fix a memory leak in hsr_del_port()
    
    hsr_del_port() should release all the resources allocated
    in hsr_add_port().
    
    As a consequence of this change, hsr_for_each_port() is no
    longer safe to work with hsr_del_port(), switch to
    list_for_each_entry_safe() as we always hold RTNL lock.
    
    Cc: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index 88b6705ded83..ee561297d8a7 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -193,4 +193,5 @@ void hsr_del_port(struct hsr_port *port)
 
 	if (port != master)
 		dev_put(port->dev);
+	kfree(port);
 }

commit 0e7623bdf34fff6587f96c27132aebe8c585631d
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:34 2019 -0400

    net: hsr: convert to SPDX identifier
    
    Use SPDX-License-Identifier instead of a verbose license text.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index 07cbc2ead64d..88b6705ded83 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -1,9 +1,5 @@
+// SPDX-License-Identifier: GPL-2.0
 /* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
  *
  * Author(s):
  *	2011-2014 Arvid Brodin, arvid.brodin@alten.se

commit 05ca6e644dc9b733379009137ba4cc7afce2256d
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:28 2019 -0400

    net: hsr: fix NULL checks in the code
    
    This patch replaces all instance of NULL checks such as
        if (foo == NULL) with if (!foo)
    Also
        if (foo != NULL) with if (foo)
    
    This is seen when ran checkpatch.pl -f on files under net/hsr
    and suggestion is to replace as above.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index d506c694ee25..07cbc2ead64d 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -140,11 +140,11 @@ int hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,
 	}
 
 	port = hsr_port_get_hsr(hsr, type);
-	if (port != NULL)
+	if (port)
 		return -EBUSY;	/* This port already exists */
 
 	port = kzalloc(sizeof(*port), GFP_KERNEL);
-	if (port == NULL)
+	if (!port)
 		return -ENOMEM;
 
 	if (type != HSR_PT_MASTER) {
@@ -181,7 +181,7 @@ void hsr_del_port(struct hsr_port *port)
 	list_del_rcu(&port->port_list);
 
 	if (port != master) {
-		if (master != NULL) {
+		if (master) {
 			netdev_update_features(master->dev);
 			dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
 		}

commit 5670342ced28b87f598d97e49d27bd99b38c1665
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:25 2019 -0400

    net: hsr: remove unnecessary paranthesis from the code
    
    This patch fixes unnecessary paranthesis from the code. This is
    seen when ran checkpatch.pl -f option on files under net/hsr.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index 80151c255a1d..d506c694ee25 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -63,8 +63,8 @@ bool hsr_port_exists(const struct net_device *dev)
 static int hsr_check_dev_ok(struct net_device *dev)
 {
 	/* Don't allow HSR on non-ethernet like devices */
-	if ((dev->flags & IFF_LOOPBACK) || (dev->type != ARPHRD_ETHER) ||
-	    (dev->addr_len != ETH_ALEN)) {
+	if ((dev->flags & IFF_LOOPBACK) || dev->type != ARPHRD_ETHER ||
+	    dev->addr_len != ETH_ALEN) {
 		netdev_info(dev, "Cannot use loopback or non-ethernet device as HSR slave.\n");
 		return -EINVAL;
 	}

commit d4730775ed4ba91615f462415ab66f49431ee794
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:24 2019 -0400

    net: hsr: fix multiple blank lines in the code
    
    This patch fixes multiple blank lines in the code. This is seen
    when ran checkpatch.pl -f option for files under net/hsr
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index 56080da4aa77..80151c255a1d 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -18,7 +18,6 @@
 #include "hsr_forward.h"
 #include "hsr_framereg.h"
 
-
 static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 {
 	struct sk_buff *skb = *pskb;
@@ -61,7 +60,6 @@ bool hsr_port_exists(const struct net_device *dev)
 	return rcu_access_pointer(dev->rx_handler) == hsr_handle_frame;
 }
 
-
 static int hsr_check_dev_ok(struct net_device *dev)
 {
 	/* Don't allow HSR on non-ethernet like devices */
@@ -99,7 +97,6 @@ static int hsr_check_dev_ok(struct net_device *dev)
 	return 0;
 }
 
-
 /* Setup device to be added to the HSR bridge. */
 static int hsr_portdev_setup(struct net_device *dev, struct hsr_port *port)
 {

commit d0d7b10b05945f40fefd4e60f457c61aefa3e9a9
Author: Parav Pandit <parav@mellanox.com>
Date:   Sat Feb 4 11:00:49 2017 -0600

    net-next: treewide use is_vlan_dev() helper function.
    
    This patch makes use of is_vlan_dev() function instead of flag
    comparison which is exactly done by is_vlan_dev() helper function.
    
    Signed-off-by: Parav Pandit <parav@mellanox.com>
    Reviewed-by: Daniel Jurgens <danielj@mellanox.com>
    Acked-by: Stephen Hemminger <stephen@networkplumber.org>
    Acked-by: Jon Maxwell <jmaxwell37@gmail.com>
    Acked-by: Johannes Thumshirn <jth@kernel.org>
    Acked-by: Haiyang Zhang <haiyangz@microsoft.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index f5b60388d02f..56080da4aa77 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -12,6 +12,7 @@
 #include "hsr_slave.h"
 #include <linux/etherdevice.h>
 #include <linux/if_arp.h>
+#include <linux/if_vlan.h>
 #include "hsr_main.h"
 #include "hsr_device.h"
 #include "hsr_forward.h"
@@ -81,7 +82,7 @@ static int hsr_check_dev_ok(struct net_device *dev)
 		return -EINVAL;
 	}
 
-	if (dev->priv_flags & IFF_802_1Q_VLAN) {
+	if (is_vlan_dev(dev)) {
 		netdev_info(dev, "HSR on top of VLAN is not yet supported in this driver.\n");
 		return -EINVAL;
 	}

commit ee1c27977284907d40f7f72c2d078d709f15811f
Author: Peter Heise <mail@pheise.de>
Date:   Wed Apr 13 13:52:22 2016 +0200

    net/hsr: Added support for HSR v1
    
    This patch adds support for the newer version 1 of the HSR
    networking standard. Version 0 is still default and the new
    version has to be selected via iproute2.
    
    Main changes are in the supervision frame handling and its
    ethertype field.
    
    Signed-off-by: Peter Heise <peter.heise@airbus.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index 7d37366cc695..f5b60388d02f 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -22,6 +22,7 @@ static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 {
 	struct sk_buff *skb = *pskb;
 	struct hsr_port *port;
+	u16 protocol;
 
 	if (!skb_mac_header_was_set(skb)) {
 		WARN_ONCE(1, "%s: skb invalid", __func__);
@@ -37,7 +38,8 @@ static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 		goto finish_consume;
 	}
 
-	if (eth_hdr(skb)->h_proto != htons(ETH_P_PRP))
+	protocol = eth_hdr(skb)->h_proto;
+	if (protocol != htons(ETH_P_PRP) && protocol != htons(ETH_P_HSR))
 		goto finish_pass;
 
 	skb_push(skb, ETH_HLEN);

commit 56b08fdcf637955d3023d769afd6cdabc526ba22
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Feb 27 21:26:03 2015 +0100

    net/hsr: Fix NULL pointer dereference and refcnt bugs when deleting a HSR interface.
    
    To repeat:
    
    $ sudo ip link del hsr0
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000018
    IP: [<ffffffff8187f495>] hsr_del_port+0x15/0xa0
    etc...
    
    Bug description:
    
    As part of the hsr master device destruction, hsr_del_port() is called for each of
    the hsr ports. At each such call, the master device is updated regarding features
    and mtu. When the master device is freed before the slave interfaces, master will
    be NULL in hsr_del_port(), which led to a NULL pointer dereference.
    
    Additionally, dev_put() was called on the master device itself in hsr_del_port(),
    causing a refcnt error.
    
    A third bug in the same code path was that the rtnl lock was not taken before
    hsr_del_port() was called as part of hsr_dev_destroy().
    
    The reporter (Nicolas Dichtel) also said: "hsr_netdev_notify() supposes that the
    port will always be available when the notification is for an hsr interface. It's
    wrong. For example, netdev_wait_allrefs() may resend NETDEV_UNREGISTER.". As a
    precaution against this, a check for port == NULL was added in hsr_dev_notify().
    
    Reported-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Fixes: 51f3c605318b056a ("net/hsr: Move slave init to hsr_slave.c.")
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index a348dcbcd683..7d37366cc695 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -181,8 +181,10 @@ void hsr_del_port(struct hsr_port *port)
 	list_del_rcu(&port->port_list);
 
 	if (port != master) {
-		netdev_update_features(master->dev);
-		dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
+		if (master != NULL) {
+			netdev_update_features(master->dev);
+			dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
+		}
 		netdev_rx_handler_unregister(port->dev);
 		dev_set_promiscuity(port->dev, -1);
 	}
@@ -192,5 +194,7 @@ void hsr_del_port(struct hsr_port *port)
 	 */
 
 	synchronize_rcu();
-	dev_put(port->dev);
+
+	if (port != master)
+		dev_put(port->dev);
 }

commit f266a683a4804dc499efc6c2206ef68efed029d0
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:41:03 2014 +0200

    net/hsr: Better frame dispatch
    
    This patch removes the separate paths for frames coming from the outside, and
    frames sent from the HSR device, and instead makes all frames go through
    hsr_forward_skb() in hsr_forward.c. This greatly improves code readability and
    also opens up the possibility for future support of the HSR Interlink device
    that is the basis for HSR RedBoxes and HSR QuadBoxes, as well as VLAN
    compatibility.
    
    Other improvements:
    * A reduction in the number of times an skb is copied on machines without
      HAVE_EFFICIENT_UNALIGNED_ACCESS, which improves throughput somewhat.
    * Headers are now created using the standard eth_header(), and using the
      standard hard_header_len.
    * Each HSR slave now gets its own private skb, so slave-specific fields can be
      correctly set.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index 23817d0b765b..a348dcbcd683 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -14,9 +14,51 @@
 #include <linux/if_arp.h>
 #include "hsr_main.h"
 #include "hsr_device.h"
+#include "hsr_forward.h"
 #include "hsr_framereg.h"
 
 
+static rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
+{
+	struct sk_buff *skb = *pskb;
+	struct hsr_port *port;
+
+	if (!skb_mac_header_was_set(skb)) {
+		WARN_ONCE(1, "%s: skb invalid", __func__);
+		return RX_HANDLER_PASS;
+	}
+
+	rcu_read_lock(); /* hsr->node_db, hsr->ports */
+	port = hsr_port_get_rcu(skb->dev);
+
+	if (hsr_addr_is_self(port->hsr, eth_hdr(skb)->h_source)) {
+		/* Directly kill frames sent by ourselves */
+		kfree_skb(skb);
+		goto finish_consume;
+	}
+
+	if (eth_hdr(skb)->h_proto != htons(ETH_P_PRP))
+		goto finish_pass;
+
+	skb_push(skb, ETH_HLEN);
+
+	hsr_forward_skb(skb, port);
+
+finish_consume:
+	rcu_read_unlock(); /* hsr->node_db, hsr->ports */
+	return RX_HANDLER_CONSUMED;
+
+finish_pass:
+	rcu_read_unlock(); /* hsr->node_db, hsr->ports */
+	return RX_HANDLER_PASS;
+}
+
+bool hsr_port_exists(const struct net_device *dev)
+{
+	return rcu_access_pointer(dev->rx_handler) == hsr_handle_frame;
+}
+
+
 static int hsr_check_dev_ok(struct net_device *dev)
 {
 	/* Don't allow HSR on non-ethernet like devices */
@@ -42,6 +84,11 @@ static int hsr_check_dev_ok(struct net_device *dev)
 		return -EINVAL;
 	}
 
+	if (dev->priv_flags & IFF_DONT_BRIDGE) {
+		netdev_info(dev, "This device does not support bridging.\n");
+		return -EOPNOTSUPP;
+	}
+
 	/* HSR over bonded devices has not been tested, but I'm not sure it
 	 * won't work...
 	 */
@@ -50,232 +97,6 @@ static int hsr_check_dev_ok(struct net_device *dev)
 }
 
 
-static struct sk_buff *hsr_pull_tag(struct sk_buff *skb)
-{
-	struct hsr_tag *hsr_tag;
-	struct sk_buff *skb2;
-
-	skb2 = skb_share_check(skb, GFP_ATOMIC);
-	if (unlikely(!skb2))
-		goto err_free;
-	skb = skb2;
-
-	if (unlikely(!pskb_may_pull(skb, HSR_HLEN)))
-		goto err_free;
-
-	hsr_tag = (struct hsr_tag *) skb->data;
-	skb->protocol = hsr_tag->encap_proto;
-	skb_pull(skb, HSR_HLEN);
-
-	return skb;
-
-err_free:
-	kfree_skb(skb);
-	return NULL;
-}
-
-
-/* The uses I can see for these HSR supervision frames are:
- * 1) Use the frames that are sent after node initialization ("HSR_TLV.Type =
- *    22") to reset any sequence_nr counters belonging to that node. Useful if
- *    the other node's counter has been reset for some reason.
- *    --
- *    Or not - resetting the counter and bridging the frame would create a
- *    loop, unfortunately.
- *
- * 2) Use the LifeCheck frames to detect ring breaks. I.e. if no LifeCheck
- *    frame is received from a particular node, we know something is wrong.
- *    We just register these (as with normal frames) and throw them away.
- *
- * 3) Allow different MAC addresses for the two slave interfaces, using the
- *    MacAddressA field.
- */
-static bool is_supervision_frame(struct hsr_priv *hsr, struct sk_buff *skb)
-{
-	struct hsr_sup_tag *hsr_stag;
-
-	if (!ether_addr_equal(eth_hdr(skb)->h_dest,
-			      hsr->sup_multicast_addr))
-		return false;
-
-	hsr_stag = (struct hsr_sup_tag *) skb->data;
-	if (get_hsr_stag_path(hsr_stag) != 0x0f)
-		return false;
-	if ((hsr_stag->HSR_TLV_Type != HSR_TLV_ANNOUNCE) &&
-	    (hsr_stag->HSR_TLV_Type != HSR_TLV_LIFE_CHECK))
-		return false;
-	if (hsr_stag->HSR_TLV_Length != 12)
-		return false;
-
-	return true;
-}
-
-
-/* Implementation somewhat according to IEC-62439-3, p. 43
- */
-rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
-{
-	struct sk_buff *skb = *pskb;
-	struct hsr_port *port, *other_port, *master;
-	struct hsr_priv *hsr;
-	struct hsr_node *node;
-	bool deliver_to_self;
-	struct sk_buff *skb_deliver;
-	bool dup_out;
-	int ret;
-
-	if (eth_hdr(skb)->h_proto != htons(ETH_P_PRP))
-		return RX_HANDLER_PASS;
-
-	rcu_read_lock(); /* ports & node */
-
-	port = hsr_port_get_rcu(skb->dev);
-	hsr = port->hsr;
-	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
-
-	node = hsr_find_node(&hsr->self_node_db, skb);
-	if (node) {
-		/* Always kill frames sent by ourselves */
-		kfree_skb(skb);
-		ret = RX_HANDLER_CONSUMED;
-		goto finish;
-	}
-
-	/* Is this frame a candidate for local reception? */
-	deliver_to_self = false;
-	if ((skb->pkt_type == PACKET_HOST) ||
-	    (skb->pkt_type == PACKET_MULTICAST) ||
-	    (skb->pkt_type == PACKET_BROADCAST))
-		deliver_to_self = true;
-	else if (ether_addr_equal(eth_hdr(skb)->h_dest,
-				  master->dev->dev_addr)) {
-		skb->pkt_type = PACKET_HOST;
-		deliver_to_self = true;
-	}
-
-	node = hsr_find_node(&hsr->node_db, skb);
-
-	if (is_supervision_frame(hsr, skb)) {
-		skb_pull(skb, sizeof(struct hsr_sup_tag));
-		node = hsr_merge_node(node, skb, port);
-		if (!node) {
-			kfree_skb(skb);
-			master->dev->stats.rx_dropped++;
-			ret = RX_HANDLER_CONSUMED;
-			goto finish;
-		}
-		skb_push(skb, sizeof(struct hsr_sup_tag));
-		deliver_to_self = false;
-	}
-
-	if (!node) {
-		/* Source node unknown; this might be a HSR frame from
-		 * another net (different multicast address). Ignore it.
-		 */
-		kfree_skb(skb);
-		ret = RX_HANDLER_CONSUMED;
-		goto finish;
-	}
-
-	if (port->type == HSR_PT_SLAVE_A)
-		other_port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);
-	else
-		other_port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);
-
-	/* Register ALL incoming frames as outgoing through the other interface.
-	 * This allows us to register frames as incoming only if they are valid
-	 * for the receiving interface, without using a specific counter for
-	 * incoming frames.
-	 */
-	if (other_port)
-		dup_out = hsr_register_frame_out(node, other_port, skb);
-	else
-		dup_out = 0;
-	if (!dup_out)
-		hsr_register_frame_in(node, port);
-
-	/* Forward this frame? */
-	if (dup_out || (skb->pkt_type == PACKET_HOST))
-		other_port = NULL;
-
-	if (hsr_register_frame_out(node, master, skb))
-		deliver_to_self = false;
-
-	if (!deliver_to_self && !other_port) {
-		kfree_skb(skb);
-		/* Circulated frame; silently remove it. */
-		ret = RX_HANDLER_CONSUMED;
-		goto finish;
-	}
-
-	skb_deliver = skb;
-	if (deliver_to_self && other_port) {
-		/* skb_clone() is not enough since we will strip the hsr tag
-		 * and do address substitution below
-		 */
-		skb_deliver = pskb_copy(skb, GFP_ATOMIC);
-		if (!skb_deliver) {
-			deliver_to_self = false;
-			master->dev->stats.rx_dropped++;
-		}
-	}
-
-	if (deliver_to_self) {
-		bool multicast_frame;
-
-		skb_deliver = hsr_pull_tag(skb_deliver);
-		if (!skb_deliver) {
-			master->dev->stats.rx_dropped++;
-			goto forward;
-		}
-#if !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
-		/* Move everything in the header that is after the HSR tag,
-		 * to work around alignment problems caused by the 6-byte HSR
-		 * tag. In practice, this removes/overwrites the HSR tag in
-		 * the header and restores a "standard" packet.
-		 */
-		memmove(skb_deliver->data - HSR_HLEN, skb_deliver->data,
-			skb_headlen(skb_deliver));
-
-		/* Adjust skb members so they correspond with the move above.
-		 * This cannot possibly underflow skb->data since hsr_pull_tag()
-		 * above succeeded.
-		 * At this point in the protocol stack, the transport and
-		 * network headers have not been set yet, and we haven't touched
-		 * the mac header nor the head. So we only need to adjust data
-		 * and tail:
-		 */
-		skb_deliver->data -= HSR_HLEN;
-		skb_deliver->tail -= HSR_HLEN;
-#endif
-		skb_deliver->dev = master->dev;
-		hsr_addr_subst_source(hsr, skb_deliver);
-		multicast_frame = (skb_deliver->pkt_type == PACKET_MULTICAST);
-		ret = netif_rx(skb_deliver);
-		if (ret == NET_RX_DROP) {
-			master->dev->stats.rx_dropped++;
-		} else {
-			master->dev->stats.rx_packets++;
-			master->dev->stats.rx_bytes += skb->len;
-			if (multicast_frame)
-				master->dev->stats.multicast++;
-		}
-	}
-
-forward:
-	if (other_port) {
-		skb_push(skb, ETH_HLEN);
-		skb->dev = other_port->dev;
-		dev_queue_xmit(skb);
-	}
-
-	ret = RX_HANDLER_CONSUMED;
-
-finish:
-	rcu_read_unlock();
-	return ret;
-}
-
 /* Setup device to be added to the HSR bridge. */
 static int hsr_portdev_setup(struct net_device *dev, struct hsr_port *port)
 {
@@ -285,16 +106,17 @@ static int hsr_portdev_setup(struct net_device *dev, struct hsr_port *port)
 	res = dev_set_promiscuity(dev, 1);
 	if (res)
 		goto fail_promiscuity;
-	res = netdev_rx_handler_register(dev, hsr_handle_frame, port);
-	if (res)
-		goto fail_rx_handler;
-	dev_disable_lro(dev);
 
 	/* FIXME:
 	 * What does net device "adjacency" mean? Should we do
 	 * res = netdev_master_upper_dev_link(port->dev, port->hsr->dev); ?
 	 */
 
+	res = netdev_rx_handler_register(dev, hsr_handle_frame, port);
+	if (res)
+		goto fail_rx_handler;
+	dev_disable_lro(dev);
+
 	return 0;
 
 fail_rx_handler:
@@ -339,11 +161,6 @@ int hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,
 	synchronize_rcu();
 
 	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
-
-	/* Set required header length */
-	if (dev->hard_header_len + HSR_HLEN > master->dev->hard_header_len)
-		master->dev->hard_header_len = dev->hard_header_len + HSR_HLEN;
-
 	netdev_update_features(master->dev);
 	dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
 

commit 1cc1eb52734bfd2fc57c7b3337a11198e713580d
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:38:57 2014 +0200

    net/hsr: Implemented .ndo_fix_features (better device features handling).
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index fffd69297c3e..23817d0b765b 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -344,6 +344,7 @@ int hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,
 	if (dev->hard_header_len + HSR_HLEN > master->dev->hard_header_len)
 		master->dev->hard_header_len = dev->hard_header_len + HSR_HLEN;
 
+	netdev_update_features(master->dev);
 	dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
 
 	return 0;
@@ -363,6 +364,7 @@ void hsr_del_port(struct hsr_port *port)
 	list_del_rcu(&port->port_list);
 
 	if (port != master) {
+		netdev_update_features(master->dev);
 		dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
 		netdev_rx_handler_unregister(port->dev);
 		dev_set_promiscuity(port->dev, -1);

commit c5a7591172100269e426cf630da0f2dc8138a206
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:38:05 2014 +0200

    net/hsr: Use list_head (and rcu) instead of array for slave devices.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index d676090f7900..fffd69297c3e 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -17,7 +17,7 @@
 #include "hsr_framereg.h"
 
 
-static int check_slave_ok(struct net_device *dev)
+static int hsr_check_dev_ok(struct net_device *dev)
 {
 	/* Don't allow HSR on non-ethernet like devices */
 	if ((dev->flags & IFF_LOOPBACK) || (dev->type != ARPHRD_ETHER) ||
@@ -32,7 +32,7 @@ static int check_slave_ok(struct net_device *dev)
 		return -EINVAL;
 	}
 
-	if (is_hsr_slave(dev)) {
+	if (hsr_port_exists(dev)) {
 		netdev_info(dev, "This device is already a HSR slave.\n");
 		return -EINVAL;
 	}
@@ -116,38 +116,29 @@ static bool is_supervision_frame(struct hsr_priv *hsr, struct sk_buff *skb)
 rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 {
 	struct sk_buff *skb = *pskb;
-	struct net_device *dev = skb->dev;
+	struct hsr_port *port, *other_port, *master;
 	struct hsr_priv *hsr;
-	struct net_device *other_slave;
 	struct hsr_node *node;
 	bool deliver_to_self;
 	struct sk_buff *skb_deliver;
-	enum hsr_dev_idx dev_in_idx, dev_other_idx;
 	bool dup_out;
 	int ret;
 
 	if (eth_hdr(skb)->h_proto != htons(ETH_P_PRP))
 		return RX_HANDLER_PASS;
 
-	hsr = get_hsr_master(dev);
-	if (!hsr) {
-		WARN_ON_ONCE(1);
-		return RX_HANDLER_PASS;
-	}
+	rcu_read_lock(); /* ports & node */
 
-	if (dev == hsr->slave[0]) {
-		dev_in_idx = HSR_DEV_SLAVE_A;
-		dev_other_idx = HSR_DEV_SLAVE_B;
-	} else {
-		dev_in_idx = HSR_DEV_SLAVE_B;
-		dev_other_idx = HSR_DEV_SLAVE_A;
-	}
+	port = hsr_port_get_rcu(skb->dev);
+	hsr = port->hsr;
+	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 
 	node = hsr_find_node(&hsr->self_node_db, skb);
 	if (node) {
 		/* Always kill frames sent by ourselves */
 		kfree_skb(skb);
-		return RX_HANDLER_CONSUMED;
+		ret = RX_HANDLER_CONSUMED;
+		goto finish;
 	}
 
 	/* Is this frame a candidate for local reception? */
@@ -156,23 +147,22 @@ rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 	    (skb->pkt_type == PACKET_MULTICAST) ||
 	    (skb->pkt_type == PACKET_BROADCAST))
 		deliver_to_self = true;
-	else if (ether_addr_equal(eth_hdr(skb)->h_dest, hsr->dev->dev_addr)) {
+	else if (ether_addr_equal(eth_hdr(skb)->h_dest,
+				  master->dev->dev_addr)) {
 		skb->pkt_type = PACKET_HOST;
 		deliver_to_self = true;
 	}
 
-
-	rcu_read_lock(); /* node_db */
 	node = hsr_find_node(&hsr->node_db, skb);
 
 	if (is_supervision_frame(hsr, skb)) {
 		skb_pull(skb, sizeof(struct hsr_sup_tag));
-		node = hsr_merge_node(hsr, node, skb, dev_in_idx);
+		node = hsr_merge_node(node, skb, port);
 		if (!node) {
-			rcu_read_unlock(); /* node_db */
 			kfree_skb(skb);
-			hsr->dev->stats.rx_dropped++;
-			return RX_HANDLER_CONSUMED;
+			master->dev->stats.rx_dropped++;
+			ret = RX_HANDLER_CONSUMED;
+			goto finish;
 		}
 		skb_push(skb, sizeof(struct hsr_sup_tag));
 		deliver_to_self = false;
@@ -182,46 +172,51 @@ rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 		/* Source node unknown; this might be a HSR frame from
 		 * another net (different multicast address). Ignore it.
 		 */
-		rcu_read_unlock(); /* node_db */
 		kfree_skb(skb);
-		return RX_HANDLER_CONSUMED;
+		ret = RX_HANDLER_CONSUMED;
+		goto finish;
 	}
 
+	if (port->type == HSR_PT_SLAVE_A)
+		other_port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);
+	else
+		other_port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);
+
 	/* Register ALL incoming frames as outgoing through the other interface.
 	 * This allows us to register frames as incoming only if they are valid
 	 * for the receiving interface, without using a specific counter for
 	 * incoming frames.
 	 */
-	dup_out = hsr_register_frame_out(node, dev_other_idx, skb);
+	if (other_port)
+		dup_out = hsr_register_frame_out(node, other_port, skb);
+	else
+		dup_out = 0;
 	if (!dup_out)
-		hsr_register_frame_in(node, dev_in_idx);
+		hsr_register_frame_in(node, port);
 
 	/* Forward this frame? */
-	if (!dup_out && (skb->pkt_type != PACKET_HOST))
-		other_slave = get_other_slave(hsr, dev);
-	else
-		other_slave = NULL;
+	if (dup_out || (skb->pkt_type == PACKET_HOST))
+		other_port = NULL;
 
-	if (hsr_register_frame_out(node, HSR_DEV_MASTER, skb))
+	if (hsr_register_frame_out(node, master, skb))
 		deliver_to_self = false;
 
-	rcu_read_unlock(); /* node_db */
-
-	if (!deliver_to_self && !other_slave) {
+	if (!deliver_to_self && !other_port) {
 		kfree_skb(skb);
 		/* Circulated frame; silently remove it. */
-		return RX_HANDLER_CONSUMED;
+		ret = RX_HANDLER_CONSUMED;
+		goto finish;
 	}
 
 	skb_deliver = skb;
-	if (deliver_to_self && other_slave) {
+	if (deliver_to_self && other_port) {
 		/* skb_clone() is not enough since we will strip the hsr tag
 		 * and do address substitution below
 		 */
 		skb_deliver = pskb_copy(skb, GFP_ATOMIC);
 		if (!skb_deliver) {
 			deliver_to_self = false;
-			hsr->dev->stats.rx_dropped++;
+			master->dev->stats.rx_dropped++;
 		}
 	}
 
@@ -230,7 +225,7 @@ rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 
 		skb_deliver = hsr_pull_tag(skb_deliver);
 		if (!skb_deliver) {
-			hsr->dev->stats.rx_dropped++;
+			master->dev->stats.rx_dropped++;
 			goto forward;
 		}
 #if !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
@@ -253,82 +248,130 @@ rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 		skb_deliver->data -= HSR_HLEN;
 		skb_deliver->tail -= HSR_HLEN;
 #endif
-		skb_deliver->dev = hsr->dev;
+		skb_deliver->dev = master->dev;
 		hsr_addr_subst_source(hsr, skb_deliver);
 		multicast_frame = (skb_deliver->pkt_type == PACKET_MULTICAST);
 		ret = netif_rx(skb_deliver);
 		if (ret == NET_RX_DROP) {
-			hsr->dev->stats.rx_dropped++;
+			master->dev->stats.rx_dropped++;
 		} else {
-			hsr->dev->stats.rx_packets++;
-			hsr->dev->stats.rx_bytes += skb->len;
+			master->dev->stats.rx_packets++;
+			master->dev->stats.rx_bytes += skb->len;
 			if (multicast_frame)
-				hsr->dev->stats.multicast++;
+				master->dev->stats.multicast++;
 		}
 	}
 
 forward:
-	if (other_slave) {
+	if (other_port) {
 		skb_push(skb, ETH_HLEN);
-		skb->dev = other_slave;
+		skb->dev = other_port->dev;
 		dev_queue_xmit(skb);
 	}
 
-	return RX_HANDLER_CONSUMED;
+	ret = RX_HANDLER_CONSUMED;
+
+finish:
+	rcu_read_unlock();
+	return ret;
 }
 
-int hsr_add_slave(struct hsr_priv *hsr, struct net_device *dev, int idx)
+/* Setup device to be added to the HSR bridge. */
+static int hsr_portdev_setup(struct net_device *dev, struct hsr_port *port)
 {
 	int res;
 
 	dev_hold(dev);
-
-	res = check_slave_ok(dev);
-	if (res)
-		goto fail;
-
 	res = dev_set_promiscuity(dev, 1);
 	if (res)
-		goto fail;
-
-	res = netdev_rx_handler_register(dev, hsr_handle_frame, hsr);
+		goto fail_promiscuity;
+	res = netdev_rx_handler_register(dev, hsr_handle_frame, port);
 	if (res)
 		goto fail_rx_handler;
+	dev_disable_lro(dev);
 
-
-	hsr->slave[idx] = dev;
-
-	/* Set required header length */
-	if (dev->hard_header_len + HSR_HLEN > hsr->dev->hard_header_len)
-		hsr->dev->hard_header_len = dev->hard_header_len + HSR_HLEN;
-
-	dev_set_mtu(hsr->dev, hsr_get_max_mtu(hsr));
+	/* FIXME:
+	 * What does net device "adjacency" mean? Should we do
+	 * res = netdev_master_upper_dev_link(port->dev, port->hsr->dev); ?
+	 */
 
 	return 0;
 
 fail_rx_handler:
 	dev_set_promiscuity(dev, -1);
-
-fail:
+fail_promiscuity:
 	dev_put(dev);
+
 	return res;
 }
 
-void hsr_del_slave(struct hsr_priv *hsr, int idx)
+int hsr_add_port(struct hsr_priv *hsr, struct net_device *dev,
+		 enum hsr_port_type type)
 {
-	struct net_device *slave;
+	struct hsr_port *port, *master;
+	int res;
 
-	slave = hsr->slave[idx];
-	hsr->slave[idx] = NULL;
+	if (type != HSR_PT_MASTER) {
+		res = hsr_check_dev_ok(dev);
+		if (res)
+			return res;
+	}
+
+	port = hsr_port_get_hsr(hsr, type);
+	if (port != NULL)
+		return -EBUSY;	/* This port already exists */
+
+	port = kzalloc(sizeof(*port), GFP_KERNEL);
+	if (port == NULL)
+		return -ENOMEM;
+
+	if (type != HSR_PT_MASTER) {
+		res = hsr_portdev_setup(dev, port);
+		if (res)
+			goto fail_dev_setup;
+	}
+
+	port->hsr = hsr;
+	port->dev = dev;
+	port->type = type;
+
+	list_add_tail_rcu(&port->port_list, &hsr->ports);
+	synchronize_rcu();
+
+	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+
+	/* Set required header length */
+	if (dev->hard_header_len + HSR_HLEN > master->dev->hard_header_len)
+		master->dev->hard_header_len = dev->hard_header_len + HSR_HLEN;
 
-	netdev_update_features(hsr->dev);
-	dev_set_mtu(hsr->dev, hsr_get_max_mtu(hsr));
+	dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
 
-	if (slave) {
-		netdev_rx_handler_unregister(slave);
-		dev_set_promiscuity(slave, -1);
+	return 0;
+
+fail_dev_setup:
+	kfree(port);
+	return res;
+}
+
+void hsr_del_port(struct hsr_port *port)
+{
+	struct hsr_priv *hsr;
+	struct hsr_port *master;
+
+	hsr = port->hsr;
+	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+	list_del_rcu(&port->port_list);
+
+	if (port != master) {
+		dev_set_mtu(master->dev, hsr_get_max_mtu(hsr));
+		netdev_rx_handler_unregister(port->dev);
+		dev_set_promiscuity(port->dev, -1);
 	}
 
+	/* FIXME?
+	 * netdev_upper_dev_unlink(port->dev, port->hsr->dev);
+	 */
+
 	synchronize_rcu();
-	dev_put(slave);
+	dev_put(port->dev);
 }

commit 51f3c605318b056ac5deb9079bbef2a976558827
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:37:27 2014 +0200

    net/hsr: Move slave init to hsr_slave.c.
    
    Also try to prevent some possible slave dereference race conditions. This is
    finalized in the next patch, which abandons the slave array in favour of
    a list_head list and list RCU.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
index 702814631ee1..d676090f7900 100644
--- a/net/hsr/hsr_slave.c
+++ b/net/hsr/hsr_slave.c
@@ -11,10 +11,45 @@
 
 #include "hsr_slave.h"
 #include <linux/etherdevice.h>
+#include <linux/if_arp.h>
 #include "hsr_main.h"
+#include "hsr_device.h"
 #include "hsr_framereg.h"
 
 
+static int check_slave_ok(struct net_device *dev)
+{
+	/* Don't allow HSR on non-ethernet like devices */
+	if ((dev->flags & IFF_LOOPBACK) || (dev->type != ARPHRD_ETHER) ||
+	    (dev->addr_len != ETH_ALEN)) {
+		netdev_info(dev, "Cannot use loopback or non-ethernet device as HSR slave.\n");
+		return -EINVAL;
+	}
+
+	/* Don't allow enslaving hsr devices */
+	if (is_hsr_master(dev)) {
+		netdev_info(dev, "Cannot create trees of HSR devices.\n");
+		return -EINVAL;
+	}
+
+	if (is_hsr_slave(dev)) {
+		netdev_info(dev, "This device is already a HSR slave.\n");
+		return -EINVAL;
+	}
+
+	if (dev->priv_flags & IFF_802_1Q_VLAN) {
+		netdev_info(dev, "HSR on top of VLAN is not yet supported in this driver.\n");
+		return -EINVAL;
+	}
+
+	/* HSR over bonded devices has not been tested, but I'm not sure it
+	 * won't work...
+	 */
+
+	return 0;
+}
+
+
 static struct sk_buff *hsr_pull_tag(struct sk_buff *skb)
 {
 	struct hsr_tag *hsr_tag;
@@ -241,3 +276,59 @@ rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
 
 	return RX_HANDLER_CONSUMED;
 }
+
+int hsr_add_slave(struct hsr_priv *hsr, struct net_device *dev, int idx)
+{
+	int res;
+
+	dev_hold(dev);
+
+	res = check_slave_ok(dev);
+	if (res)
+		goto fail;
+
+	res = dev_set_promiscuity(dev, 1);
+	if (res)
+		goto fail;
+
+	res = netdev_rx_handler_register(dev, hsr_handle_frame, hsr);
+	if (res)
+		goto fail_rx_handler;
+
+
+	hsr->slave[idx] = dev;
+
+	/* Set required header length */
+	if (dev->hard_header_len + HSR_HLEN > hsr->dev->hard_header_len)
+		hsr->dev->hard_header_len = dev->hard_header_len + HSR_HLEN;
+
+	dev_set_mtu(hsr->dev, hsr_get_max_mtu(hsr));
+
+	return 0;
+
+fail_rx_handler:
+	dev_set_promiscuity(dev, -1);
+
+fail:
+	dev_put(dev);
+	return res;
+}
+
+void hsr_del_slave(struct hsr_priv *hsr, int idx)
+{
+	struct net_device *slave;
+
+	slave = hsr->slave[idx];
+	hsr->slave[idx] = NULL;
+
+	netdev_update_features(hsr->dev);
+	dev_set_mtu(hsr->dev, hsr_get_max_mtu(hsr));
+
+	if (slave) {
+		netdev_rx_handler_unregister(slave);
+		dev_set_promiscuity(slave, -1);
+	}
+
+	synchronize_rcu();
+	dev_put(slave);
+}

commit 81ba6afd6e6443d2bf4bf40f16df1f1f91c603f8
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:35:24 2014 +0200

    net/hsr: Switch from dev_add_pack() to netdev_rx_handler_register()
    
    Also move the frame receive handler to hsr_slave.c.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_slave.c b/net/hsr/hsr_slave.c
new file mode 100644
index 000000000000..702814631ee1
--- /dev/null
+++ b/net/hsr/hsr_slave.c
@@ -0,0 +1,243 @@
+/* Copyright 2011-2014 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
+ */
+
+#include "hsr_slave.h"
+#include <linux/etherdevice.h>
+#include "hsr_main.h"
+#include "hsr_framereg.h"
+
+
+static struct sk_buff *hsr_pull_tag(struct sk_buff *skb)
+{
+	struct hsr_tag *hsr_tag;
+	struct sk_buff *skb2;
+
+	skb2 = skb_share_check(skb, GFP_ATOMIC);
+	if (unlikely(!skb2))
+		goto err_free;
+	skb = skb2;
+
+	if (unlikely(!pskb_may_pull(skb, HSR_HLEN)))
+		goto err_free;
+
+	hsr_tag = (struct hsr_tag *) skb->data;
+	skb->protocol = hsr_tag->encap_proto;
+	skb_pull(skb, HSR_HLEN);
+
+	return skb;
+
+err_free:
+	kfree_skb(skb);
+	return NULL;
+}
+
+
+/* The uses I can see for these HSR supervision frames are:
+ * 1) Use the frames that are sent after node initialization ("HSR_TLV.Type =
+ *    22") to reset any sequence_nr counters belonging to that node. Useful if
+ *    the other node's counter has been reset for some reason.
+ *    --
+ *    Or not - resetting the counter and bridging the frame would create a
+ *    loop, unfortunately.
+ *
+ * 2) Use the LifeCheck frames to detect ring breaks. I.e. if no LifeCheck
+ *    frame is received from a particular node, we know something is wrong.
+ *    We just register these (as with normal frames) and throw them away.
+ *
+ * 3) Allow different MAC addresses for the two slave interfaces, using the
+ *    MacAddressA field.
+ */
+static bool is_supervision_frame(struct hsr_priv *hsr, struct sk_buff *skb)
+{
+	struct hsr_sup_tag *hsr_stag;
+
+	if (!ether_addr_equal(eth_hdr(skb)->h_dest,
+			      hsr->sup_multicast_addr))
+		return false;
+
+	hsr_stag = (struct hsr_sup_tag *) skb->data;
+	if (get_hsr_stag_path(hsr_stag) != 0x0f)
+		return false;
+	if ((hsr_stag->HSR_TLV_Type != HSR_TLV_ANNOUNCE) &&
+	    (hsr_stag->HSR_TLV_Type != HSR_TLV_LIFE_CHECK))
+		return false;
+	if (hsr_stag->HSR_TLV_Length != 12)
+		return false;
+
+	return true;
+}
+
+
+/* Implementation somewhat according to IEC-62439-3, p. 43
+ */
+rx_handler_result_t hsr_handle_frame(struct sk_buff **pskb)
+{
+	struct sk_buff *skb = *pskb;
+	struct net_device *dev = skb->dev;
+	struct hsr_priv *hsr;
+	struct net_device *other_slave;
+	struct hsr_node *node;
+	bool deliver_to_self;
+	struct sk_buff *skb_deliver;
+	enum hsr_dev_idx dev_in_idx, dev_other_idx;
+	bool dup_out;
+	int ret;
+
+	if (eth_hdr(skb)->h_proto != htons(ETH_P_PRP))
+		return RX_HANDLER_PASS;
+
+	hsr = get_hsr_master(dev);
+	if (!hsr) {
+		WARN_ON_ONCE(1);
+		return RX_HANDLER_PASS;
+	}
+
+	if (dev == hsr->slave[0]) {
+		dev_in_idx = HSR_DEV_SLAVE_A;
+		dev_other_idx = HSR_DEV_SLAVE_B;
+	} else {
+		dev_in_idx = HSR_DEV_SLAVE_B;
+		dev_other_idx = HSR_DEV_SLAVE_A;
+	}
+
+	node = hsr_find_node(&hsr->self_node_db, skb);
+	if (node) {
+		/* Always kill frames sent by ourselves */
+		kfree_skb(skb);
+		return RX_HANDLER_CONSUMED;
+	}
+
+	/* Is this frame a candidate for local reception? */
+	deliver_to_self = false;
+	if ((skb->pkt_type == PACKET_HOST) ||
+	    (skb->pkt_type == PACKET_MULTICAST) ||
+	    (skb->pkt_type == PACKET_BROADCAST))
+		deliver_to_self = true;
+	else if (ether_addr_equal(eth_hdr(skb)->h_dest, hsr->dev->dev_addr)) {
+		skb->pkt_type = PACKET_HOST;
+		deliver_to_self = true;
+	}
+
+
+	rcu_read_lock(); /* node_db */
+	node = hsr_find_node(&hsr->node_db, skb);
+
+	if (is_supervision_frame(hsr, skb)) {
+		skb_pull(skb, sizeof(struct hsr_sup_tag));
+		node = hsr_merge_node(hsr, node, skb, dev_in_idx);
+		if (!node) {
+			rcu_read_unlock(); /* node_db */
+			kfree_skb(skb);
+			hsr->dev->stats.rx_dropped++;
+			return RX_HANDLER_CONSUMED;
+		}
+		skb_push(skb, sizeof(struct hsr_sup_tag));
+		deliver_to_self = false;
+	}
+
+	if (!node) {
+		/* Source node unknown; this might be a HSR frame from
+		 * another net (different multicast address). Ignore it.
+		 */
+		rcu_read_unlock(); /* node_db */
+		kfree_skb(skb);
+		return RX_HANDLER_CONSUMED;
+	}
+
+	/* Register ALL incoming frames as outgoing through the other interface.
+	 * This allows us to register frames as incoming only if they are valid
+	 * for the receiving interface, without using a specific counter for
+	 * incoming frames.
+	 */
+	dup_out = hsr_register_frame_out(node, dev_other_idx, skb);
+	if (!dup_out)
+		hsr_register_frame_in(node, dev_in_idx);
+
+	/* Forward this frame? */
+	if (!dup_out && (skb->pkt_type != PACKET_HOST))
+		other_slave = get_other_slave(hsr, dev);
+	else
+		other_slave = NULL;
+
+	if (hsr_register_frame_out(node, HSR_DEV_MASTER, skb))
+		deliver_to_self = false;
+
+	rcu_read_unlock(); /* node_db */
+
+	if (!deliver_to_self && !other_slave) {
+		kfree_skb(skb);
+		/* Circulated frame; silently remove it. */
+		return RX_HANDLER_CONSUMED;
+	}
+
+	skb_deliver = skb;
+	if (deliver_to_self && other_slave) {
+		/* skb_clone() is not enough since we will strip the hsr tag
+		 * and do address substitution below
+		 */
+		skb_deliver = pskb_copy(skb, GFP_ATOMIC);
+		if (!skb_deliver) {
+			deliver_to_self = false;
+			hsr->dev->stats.rx_dropped++;
+		}
+	}
+
+	if (deliver_to_self) {
+		bool multicast_frame;
+
+		skb_deliver = hsr_pull_tag(skb_deliver);
+		if (!skb_deliver) {
+			hsr->dev->stats.rx_dropped++;
+			goto forward;
+		}
+#if !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+		/* Move everything in the header that is after the HSR tag,
+		 * to work around alignment problems caused by the 6-byte HSR
+		 * tag. In practice, this removes/overwrites the HSR tag in
+		 * the header and restores a "standard" packet.
+		 */
+		memmove(skb_deliver->data - HSR_HLEN, skb_deliver->data,
+			skb_headlen(skb_deliver));
+
+		/* Adjust skb members so they correspond with the move above.
+		 * This cannot possibly underflow skb->data since hsr_pull_tag()
+		 * above succeeded.
+		 * At this point in the protocol stack, the transport and
+		 * network headers have not been set yet, and we haven't touched
+		 * the mac header nor the head. So we only need to adjust data
+		 * and tail:
+		 */
+		skb_deliver->data -= HSR_HLEN;
+		skb_deliver->tail -= HSR_HLEN;
+#endif
+		skb_deliver->dev = hsr->dev;
+		hsr_addr_subst_source(hsr, skb_deliver);
+		multicast_frame = (skb_deliver->pkt_type == PACKET_MULTICAST);
+		ret = netif_rx(skb_deliver);
+		if (ret == NET_RX_DROP) {
+			hsr->dev->stats.rx_dropped++;
+		} else {
+			hsr->dev->stats.rx_packets++;
+			hsr->dev->stats.rx_bytes += skb->len;
+			if (multicast_frame)
+				hsr->dev->stats.multicast++;
+		}
+	}
+
+forward:
+	if (other_slave) {
+		skb_push(skb, ETH_HLEN);
+		skb->dev = other_slave;
+		dev_queue_xmit(skb);
+	}
+
+	return RX_HANDLER_CONSUMED;
+}
