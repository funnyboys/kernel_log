commit de0083c7ed7dba036d1ed6e012157649d45313c8
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sun Jun 21 13:46:25 2020 +0000

    hsr: avoid to create proc file after unregister
    
    When an interface is being deleted, "/proc/net/dev_snmp6/<interface name>"
    is deleted.
    The function for this is addrconf_ifdown() in the addrconf_notify() and
    it is called by notification, which is NETDEV_UNREGISTER.
    But, if NETDEV_CHANGEMTU is triggered after NETDEV_UNREGISTER,
    this proc file will be created again.
    This recreated proc file will be deleted by netdev_wati_allrefs().
    Before netdev_wait_allrefs() is called, creating a new HSR interface
    routine can be executed and It tries to create a proc file but it will
    find an un-deleted proc file.
    At this point, it warns about it.
    
    To avoid this situation, it can use ->dellink() instead of
    ->ndo_uninit() to release resources because ->dellink() is called
    before NETDEV_UNREGISTER.
    So, a proc file will not be recreated.
    
    Test commands
        ip link add dummy0 type dummy
        ip link add dummy1 type dummy
        ip link set dummy0 mtu 1300
    
        #SHELL1
        while :
        do
            ip link add hsr0 type hsr slave1 dummy0 slave2 dummy1
        done
    
        #SHELL2
        while :
        do
            ip link del hsr0
        done
    
    Splat looks like:
    [ 9888.980852][ T2752] proc_dir_entry 'dev_snmp6/hsr0' already registered
    [ 9888.981797][    C2] WARNING: CPU: 2 PID: 2752 at fs/proc/generic.c:372 proc_register+0x2d5/0x430
    [ 9888.981798][    C2] Modules linked in: hsr dummy veth openvswitch nsh nf_conncount nf_nat nf_conntrack nf_defrag_ipv6x
    [ 9888.981814][    C2] CPU: 2 PID: 2752 Comm: ip Tainted: G        W         5.8.0-rc1+ #616
    [ 9888.981815][    C2] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [ 9888.981816][    C2] RIP: 0010:proc_register+0x2d5/0x430
    [ 9888.981818][    C2] Code: fc ff df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 65 01 00 00 49 8b b5 e0 00 00 00 48 89 ea 40
    [ 9888.981819][    C2] RSP: 0018:ffff8880628dedf0 EFLAGS: 00010286
    [ 9888.981821][    C2] RAX: dffffc0000000008 RBX: ffff888028c69170 RCX: ffffffffaae09a62
    [ 9888.981822][    C2] RDX: 0000000000000001 RSI: 0000000000000008 RDI: ffff88806c9f75ac
    [ 9888.981823][    C2] RBP: ffff888028c693f4 R08: ffffed100d9401bd R09: ffffed100d9401bd
    [ 9888.981824][    C2] R10: ffffffffaddf406f R11: 0000000000000001 R12: ffff888028c69308
    [ 9888.981825][    C2] R13: ffff8880663584c8 R14: dffffc0000000000 R15: ffffed100518d27e
    [ 9888.981827][    C2] FS:  00007f3876b3b0c0(0000) GS:ffff88806c800000(0000) knlGS:0000000000000000
    [ 9888.981828][    C2] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 9888.981829][    C2] CR2: 00007f387601a8c0 CR3: 000000004101a002 CR4: 00000000000606e0
    [ 9888.981830][    C2] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [ 9888.981831][    C2] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [ 9888.981832][    C2] Call Trace:
    [ 9888.981833][    C2]  ? snmp6_seq_show+0x180/0x180
    [ 9888.981834][    C2]  proc_create_single_data+0x7c/0xa0
    [ 9888.981835][    C2]  snmp6_register_dev+0xb0/0x130
    [ 9888.981836][    C2]  ipv6_add_dev+0x4b7/0xf60
    [ 9888.981837][    C2]  addrconf_notify+0x684/0x1ca0
    [ 9888.981838][    C2]  ? __mutex_unlock_slowpath+0xd0/0x670
    [ 9888.981839][    C2]  ? kasan_unpoison_shadow+0x30/0x40
    [ 9888.981840][    C2]  ? wait_for_completion+0x250/0x250
    [ 9888.981841][    C2]  ? inet6_ifinfo_notify+0x100/0x100
    [ 9888.981842][    C2]  ? dropmon_net_event+0x227/0x410
    [ 9888.981843][    C2]  ? notifier_call_chain+0x90/0x160
    [ 9888.981844][    C2]  ? inet6_ifinfo_notify+0x100/0x100
    [ 9888.981845][    C2]  notifier_call_chain+0x90/0x160
    [ 9888.981846][    C2]  register_netdevice+0xbe5/0x1070
    [ ... ]
    
    Reported-by: syzbot+1d51c8b74efa4c44adeb@syzkaller.appspotmail.com
    Fixes: e0a4b99773d3 ("hsr: use upper/lower device infrastructure")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index e2564de67603..144da15f0a81 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -6,6 +6,7 @@
  */
 
 #include <linux/netdevice.h>
+#include <net/rtnetlink.h>
 #include <linux/rculist.h>
 #include <linux/timer.h>
 #include <linux/etherdevice.h>
@@ -100,8 +101,10 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 			master = hsr_port_get_hsr(port->hsr, HSR_PT_MASTER);
 			hsr_del_port(port);
 			if (hsr_slave_empty(master->hsr)) {
-				unregister_netdevice_queue(master->dev,
-							   &list_kill);
+				const struct rtnl_link_ops *ops;
+
+				ops = master->dev->rtnl_link_ops;
+				ops->dellink(master->dev, &list_kill);
 				unregister_netdevice_many(&list_kill);
 			}
 		}
@@ -144,9 +147,9 @@ static int __init hsr_init(void)
 
 static void __exit hsr_exit(void)
 {
-	unregister_netdevice_notifier(&hsr_nb);
 	hsr_netlink_exit();
 	hsr_debugfs_remove_root();
+	unregister_netdevice_notifier(&hsr_nb);
 }
 
 module_init(hsr_init);

commit 34a9c361dd480041d790fff3d6ea58513c8769e8
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Apr 30 17:37:02 2020 +0000

    hsr: remove hsr interface if all slaves are removed
    
    When all hsr slave interfaces are removed, hsr interface doesn't work.
    At that moment, it's fine to remove an unused hsr interface automatically
    for saving resources.
    That's a common behavior of virtual interfaces.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index 26d6c39f24e1..e2564de67603 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -15,12 +15,23 @@
 #include "hsr_framereg.h"
 #include "hsr_slave.h"
 
+static bool hsr_slave_empty(struct hsr_priv *hsr)
+{
+	struct hsr_port *port;
+
+	hsr_for_each_port(hsr, port)
+		if (port->type != HSR_PT_MASTER)
+			return false;
+	return true;
+}
+
 static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 			     void *ptr)
 {
-	struct net_device *dev;
 	struct hsr_port *port, *master;
+	struct net_device *dev;
 	struct hsr_priv *hsr;
+	LIST_HEAD(list_kill);
 	int mtu_max;
 	int res;
 
@@ -85,8 +96,15 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 		master->dev->mtu = mtu_max;
 		break;
 	case NETDEV_UNREGISTER:
-		if (!is_hsr_master(dev))
+		if (!is_hsr_master(dev)) {
+			master = hsr_port_get_hsr(port->hsr, HSR_PT_MASTER);
 			hsr_del_port(port);
+			if (hsr_slave_empty(master->hsr)) {
+				unregister_netdevice_queue(master->dev,
+							   &list_kill);
+				unregister_netdevice_many(&list_kill);
+			}
+		}
 		break;
 	case NETDEV_PRE_TYPE_CHANGE:
 		/* HSR works only on Ethernet devices. Refuse slave to change

commit e0a4b99773d3d8d3fb40087805f8fd858a23e582
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Fri Feb 28 18:02:10 2020 +0000

    hsr: use upper/lower device infrastructure
    
    netdev_upper_dev_link() is useful to manage lower/upper interfaces.
    And this function internally validates looping, maximum depth.
    All or most virtual interfaces that could have a real interface
    (e.g. macsec, macvlan, ipvlan etc.) use lower/upper infrastructure.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index 9e389accbfc7..26d6c39f24e1 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -85,7 +85,8 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 		master->dev->mtu = mtu_max;
 		break;
 	case NETDEV_UNREGISTER:
-		hsr_del_port(port);
+		if (!is_hsr_master(dev))
+			hsr_del_port(port);
 		break;
 	case NETDEV_PRE_TYPE_CHANGE:
 		/* HSR works only on Ethernet devices. Refuse slave to change

commit 04b69426d846cd04ca9acefff1ea39e1c64d2714
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sat Dec 28 16:28:09 2019 +0000

    hsr: fix slab-out-of-bounds Read in hsr_debugfs_rename()
    
    hsr slave interfaces don't have debugfs directory.
    So, hsr_debugfs_rename() shouldn't be called when hsr slave interface name
    is changed.
    
    Test commands:
        ip link add dummy0 type dummy
        ip link add dummy1 type dummy
        ip link add hsr0 type hsr slave1 dummy0 slave2 dummy1
        ip link set dummy0 name ap
    
    Splat looks like:
    [21071.899367][T22666] ap: renamed from dummy0
    [21071.914005][T22666] ==================================================================
    [21071.919008][T22666] BUG: KASAN: slab-out-of-bounds in hsr_debugfs_rename+0xaa/0xb0 [hsr]
    [21071.923640][T22666] Read of size 8 at addr ffff88805febcd98 by task ip/22666
    [21071.926941][T22666]
    [21071.927750][T22666] CPU: 0 PID: 22666 Comm: ip Not tainted 5.5.0-rc2+ #240
    [21071.929919][T22666] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [21071.935094][T22666] Call Trace:
    [21071.935867][T22666]  dump_stack+0x96/0xdb
    [21071.936687][T22666]  ? hsr_debugfs_rename+0xaa/0xb0 [hsr]
    [21071.937774][T22666]  print_address_description.constprop.5+0x1be/0x360
    [21071.939019][T22666]  ? hsr_debugfs_rename+0xaa/0xb0 [hsr]
    [21071.940081][T22666]  ? hsr_debugfs_rename+0xaa/0xb0 [hsr]
    [21071.940949][T22666]  __kasan_report+0x12a/0x16f
    [21071.941758][T22666]  ? hsr_debugfs_rename+0xaa/0xb0 [hsr]
    [21071.942674][T22666]  kasan_report+0xe/0x20
    [21071.943325][T22666]  hsr_debugfs_rename+0xaa/0xb0 [hsr]
    [21071.944187][T22666]  hsr_netdev_notify+0x1fe/0x9b0 [hsr]
    [21071.945052][T22666]  ? __module_text_address+0x13/0x140
    [21071.945897][T22666]  notifier_call_chain+0x90/0x160
    [21071.946743][T22666]  dev_change_name+0x419/0x840
    [21071.947496][T22666]  ? __read_once_size_nocheck.constprop.6+0x10/0x10
    [21071.948600][T22666]  ? netdev_adjacent_rename_links+0x280/0x280
    [21071.949577][T22666]  ? __read_once_size_nocheck.constprop.6+0x10/0x10
    [21071.950672][T22666]  ? lock_downgrade+0x6e0/0x6e0
    [21071.951345][T22666]  ? do_setlink+0x811/0x2ef0
    [21071.951991][T22666]  do_setlink+0x811/0x2ef0
    [21071.952613][T22666]  ? is_bpf_text_address+0x81/0xe0
    [ ... ]
    
    Reported-by: syzbot+9328206518f08318a5fd@syzkaller.appspotmail.com
    Fixes: 4c2d5e33dcd3 ("hsr: rename debugfs file when interface name is changed")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index d2ee7125a7f1..9e389accbfc7 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -46,7 +46,8 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 		hsr_check_carrier_and_operstate(hsr);
 		break;
 	case NETDEV_CHANGENAME:
-		hsr_debugfs_rename(dev);
+		if (is_hsr_master(dev))
+			hsr_debugfs_rename(dev);
 		break;
 	case NETDEV_CHANGEADDR:
 		if (port->type == HSR_PT_MASTER) {

commit 92a35678ec075100ce666a2fb6969151affb0e5d
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sun Dec 22 11:26:54 2019 +0000

    hsr: fix a race condition in node list insertion and deletion
    
    hsr nodes are protected by RCU and there is no write side lock.
    But node insertions and deletions could be being operated concurrently.
    So write side locking is needed.
    
    Test commands:
        ip netns add nst
        ip link add veth0 type veth peer name veth1
        ip link add veth2 type veth peer name veth3
        ip link set veth1 netns nst
        ip link set veth3 netns nst
        ip link set veth0 up
        ip link set veth2 up
        ip link add hsr0 type hsr slave1 veth0 slave2 veth2
        ip a a 192.168.100.1/24 dev hsr0
        ip link set hsr0 up
        ip netns exec nst ip link set veth1 up
        ip netns exec nst ip link set veth3 up
        ip netns exec nst ip link add hsr1 type hsr slave1 veth1 slave2 veth3
        ip netns exec nst ip a a 192.168.100.2/24 dev hsr1
        ip netns exec nst ip link set hsr1 up
    
        for i in {0..9}
        do
            for j in {0..9}
            do
                for k in {0..9}
                do
                    for l in {0..9}
                    do
                    arping 192.168.100.2 -I hsr0 -s 00:01:3$i:4$j:5$k:6$l -c1 &
                    done
                done
            done
        done
    
    Splat looks like:
    [  236.066091][ T3286] list_add corruption. next->prev should be prev (ffff8880a5940300), but was ffff8880a5940d0.
    [  236.069617][ T3286] ------------[ cut here ]------------
    [  236.070545][ T3286] kernel BUG at lib/list_debug.c:25!
    [  236.071391][ T3286] invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [  236.072343][ T3286] CPU: 0 PID: 3286 Comm: arping Tainted: G        W         5.5.0-rc1+ #209
    [  236.073463][ T3286] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  236.074695][ T3286] RIP: 0010:__list_add_valid+0x74/0xd0
    [  236.075499][ T3286] Code: 48 39 da 75 27 48 39 f5 74 36 48 39 dd 74 31 48 83 c4 08 b8 01 00 00 00 5b 5d c3 48 b
    [  236.078277][ T3286] RSP: 0018:ffff8880aaa97648 EFLAGS: 00010286
    [  236.086991][ T3286] RAX: 0000000000000075 RBX: ffff8880d4624c20 RCX: 0000000000000000
    [  236.088000][ T3286] RDX: 0000000000000075 RSI: 0000000000000008 RDI: ffffed1015552ebf
    [  236.098897][ T3286] RBP: ffff88809b53d200 R08: ffffed101b3c04f9 R09: ffffed101b3c04f9
    [  236.099960][ T3286] R10: 00000000308769a1 R11: ffffed101b3c04f8 R12: ffff8880d4624c28
    [  236.100974][ T3286] R13: ffff8880d4624c20 R14: 0000000040310100 R15: ffff8880ce17ee02
    [  236.138967][ T3286] FS:  00007f23479fa680(0000) GS:ffff8880d9c00000(0000) knlGS:0000000000000000
    [  236.144852][ T3286] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  236.145720][ T3286] CR2: 00007f4a14bab210 CR3: 00000000a61c6001 CR4: 00000000000606f0
    [  236.146776][ T3286] Call Trace:
    [  236.147222][ T3286]  hsr_add_node+0x314/0x490 [hsr]
    [  236.153633][ T3286]  hsr_forward_skb+0x2b6/0x1bc0 [hsr]
    [  236.154362][ T3286]  ? rcu_read_lock_sched_held+0x90/0xc0
    [  236.155091][ T3286]  ? rcu_read_lock_bh_held+0xa0/0xa0
    [  236.156607][ T3286]  hsr_dev_xmit+0x70/0xd0 [hsr]
    [  236.157254][ T3286]  dev_hard_start_xmit+0x160/0x740
    [  236.157941][ T3286]  __dev_queue_xmit+0x1961/0x2e10
    [  236.158565][ T3286]  ? netdev_core_pick_tx+0x2e0/0x2e0
    [ ... ]
    
    Reported-by: syzbot+3924327f9ad5f4d2b343@syzkaller.appspotmail.com
    Fixes: f421436a591d ("net/hsr: Add support for the High-availability Seamless Redundancy protocol (HSRv0)")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index ea23eb7408e4..d2ee7125a7f1 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -67,7 +67,7 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 
 		/* Make sure we recognize frames from ourselves in hsr_rcv() */
 		port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);
-		res = hsr_create_self_node(&hsr->self_node_db,
+		res = hsr_create_self_node(hsr,
 					   master->dev->dev_addr,
 					   port ?
 						port->dev->dev_addr :

commit 4c2d5e33dcd3a6333a7895be3b542ff3d373177c
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sun Dec 22 11:26:39 2019 +0000

    hsr: rename debugfs file when interface name is changed
    
    hsr interface has own debugfs file, which name is same with interface name.
    So, interface name is changed, debugfs file name should be changed too.
    
    Fixes: fc4ecaeebd26 ("net: hsr: add debugfs support for display node list")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index 490896379073..ea23eb7408e4 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -45,6 +45,9 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 	case NETDEV_CHANGE:	/* Link (carrier) state changes */
 		hsr_check_carrier_and_operstate(hsr);
 		break;
+	case NETDEV_CHANGENAME:
+		hsr_debugfs_rename(dev);
+		break;
 	case NETDEV_CHANGEADDR:
 		if (port->type == HSR_PT_MASTER) {
 			/* This should not happen since there's no

commit c6c4ccd7f96993e106dfea7ef18127f972f2db5e
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sun Dec 22 11:26:27 2019 +0000

    hsr: add hsr root debugfs directory
    
    In current hsr code, when hsr interface is created, it creates debugfs
    directory /sys/kernel/debug/<interface name>.
    If there is same directory or file name in there, it fails.
    In order to reduce possibility of failure of creation of debugfs,
    this patch adds root directory.
    
    Test commands:
        ip link add dummy0 type dummy
        ip link add dummy1 type dummy
        ip link add hsr0 type hsr slave1 dummy0 slave2 dummy1
    
    Before this patch:
        /sys/kernel/debug/hsr0/node_table
    
    After this patch:
        /sys/kernel/debug/hsr/hsr0/node_table
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index b9988a662ee1..490896379073 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -123,6 +123,7 @@ static void __exit hsr_exit(void)
 {
 	unregister_netdevice_notifier(&hsr_nb);
 	hsr_netlink_exit();
+	hsr_debugfs_remove_root();
 }
 
 module_init(hsr_init);

commit 0e7623bdf34fff6587f96c27132aebe8c585631d
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:34 2019 -0400

    net: hsr: convert to SPDX identifier
    
    Use SPDX-License-Identifier instead of a verbose license text.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index 84cacf8c1b0a..b9988a662ee1 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -1,9 +1,5 @@
+// SPDX-License-Identifier: GPL-2.0
 /* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
  *
  * Author(s):
  *	2011-2014 Arvid Brodin, arvid.brodin@alten.se

commit 05ca6e644dc9b733379009137ba4cc7afce2256d
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:28 2019 -0400

    net: hsr: fix NULL checks in the code
    
    This patch replaces all instance of NULL checks such as
        if (foo == NULL) with if (!foo)
    Also
        if (foo != NULL) with if (foo)
    
    This is seen when ran checkpatch.pl -f on files under net/hsr
    and suggestion is to replace as above.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index 0d4ab8fc0aa1..84cacf8c1b0a 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -30,12 +30,12 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 
 	dev = netdev_notifier_info_to_dev(ptr);
 	port = hsr_port_get_rtnl(dev);
-	if (port == NULL) {
+	if (!port) {
 		if (!is_hsr_master(dev))
 			return NOTIFY_DONE;	/* Not an HSR device */
 		hsr = netdev_priv(dev);
 		port = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
-		if (port == NULL) {
+		if (!port) {
 			/* Resend of notification concerning removed device? */
 			return NOTIFY_DONE;
 		}

commit d4730775ed4ba91615f462415ab66f49431ee794
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:24 2019 -0400

    net: hsr: fix multiple blank lines in the code
    
    This patch fixes multiple blank lines in the code. This is seen
    when ran checkpatch.pl -f option for files under net/hsr
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index b7a4cf62286b..0d4ab8fc0aa1 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -19,7 +19,6 @@
 #include "hsr_framereg.h"
 #include "hsr_slave.h"
 
-
 static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 			     void *ptr)
 {
@@ -98,7 +97,6 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 	return NOTIFY_DONE;
 }
 
-
 struct hsr_port *hsr_port_get_hsr(struct hsr_priv *hsr, enum hsr_port_type pt)
 {
 	struct hsr_port *port;
@@ -113,7 +111,6 @@ static struct notifier_block hsr_nb = {
 	.notifier_call = hsr_netdev_notify,	/* Slave event notifications */
 };
 
-
 static int __init hsr_init(void)
 {
 	int res;

commit d595b85a6cea56874cee16ddc739289f552a9a2f
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:23 2019 -0400

    net: hsr: fix lines exceeding 80 characters
    
    This patch fixes lines exceeding 80 characters. This is seen
    when ran checkpatch.pl with -f option for files under
    net/hsr.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index cd37d0011b42..b7a4cf62286b 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -63,7 +63,8 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 
 		if (port->type == HSR_PT_SLAVE_A) {
 			ether_addr_copy(master->dev->dev_addr, dev->dev_addr);
-			call_netdevice_notifiers(NETDEV_CHANGEADDR, master->dev);
+			call_netdevice_notifiers(NETDEV_CHANGEADDR,
+						 master->dev);
 		}
 
 		/* Make sure we recognize frames from ourselves in hsr_rcv() */

commit 56b08fdcf637955d3023d769afd6cdabc526ba22
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Feb 27 21:26:03 2015 +0100

    net/hsr: Fix NULL pointer dereference and refcnt bugs when deleting a HSR interface.
    
    To repeat:
    
    $ sudo ip link del hsr0
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000018
    IP: [<ffffffff8187f495>] hsr_del_port+0x15/0xa0
    etc...
    
    Bug description:
    
    As part of the hsr master device destruction, hsr_del_port() is called for each of
    the hsr ports. At each such call, the master device is updated regarding features
    and mtu. When the master device is freed before the slave interfaces, master will
    be NULL in hsr_del_port(), which led to a NULL pointer dereference.
    
    Additionally, dev_put() was called on the master device itself in hsr_del_port(),
    causing a refcnt error.
    
    A third bug in the same code path was that the rtnl lock was not taken before
    hsr_del_port() was called as part of hsr_dev_destroy().
    
    The reporter (Nicolas Dichtel) also said: "hsr_netdev_notify() supposes that the
    port will always be available when the notification is for an hsr interface. It's
    wrong. For example, netdev_wait_allrefs() may resend NETDEV_UNREGISTER.". As a
    precaution against this, a check for port == NULL was added in hsr_dev_notify().
    
    Reported-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Fixes: 51f3c605318b056a ("net/hsr: Move slave init to hsr_slave.c.")
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index 779d28b65417..cd37d0011b42 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -36,6 +36,10 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 			return NOTIFY_DONE;	/* Not an HSR device */
 		hsr = netdev_priv(dev);
 		port = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+		if (port == NULL) {
+			/* Resend of notification concerning removed device? */
+			return NOTIFY_DONE;
+		}
 	} else {
 		hsr = port->hsr;
 	}

commit f266a683a4804dc499efc6c2206ef68efed029d0
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:41:03 2014 +0200

    net/hsr: Better frame dispatch
    
    This patch removes the separate paths for frames coming from the outside, and
    frames sent from the HSR device, and instead makes all frames go through
    hsr_forward_skb() in hsr_forward.c. This greatly improves code readability and
    also opens up the possibility for future support of the HSR Interlink device
    that is the basis for HSR RedBoxes and HSR QuadBoxes, as well as VLAN
    compatibility.
    
    Other improvements:
    * A reduction in the number of times an skb is copied on machines without
      HAVE_EFFICIENT_UNALIGNED_ACCESS, which improves throughput somewhat.
    * Headers are now created using the standard eth_header(), and using the
      standard hard_header_len.
    * Each HSR slave now gets its own private skb, so slave-specific fields can be
      correctly set.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index a06cab57ab68..779d28b65417 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -20,26 +20,6 @@
 #include "hsr_slave.h"
 
 
-/* List of all registered virtual HSR devices */
-static LIST_HEAD(hsr_list);
-
-void register_hsr_master(struct hsr_priv *hsr)
-{
-	list_add_tail_rcu(&hsr->hsr_list, &hsr_list);
-}
-
-void unregister_hsr_master(struct hsr_priv *hsr)
-{
-	struct hsr_priv *hsr_it;
-
-	list_for_each_entry(hsr_it, &hsr_list, hsr_list)
-		if (hsr_it == hsr) {
-			list_del_rcu(&hsr_it->hsr_list);
-			return;
-		}
-}
-
-
 static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 			     void *ptr)
 {

commit c5a7591172100269e426cf630da0f2dc8138a206
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:38:05 2014 +0200

    net/hsr: Use list_head (and rcu) instead of array for slave devices.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index b5abe26f7b4c..a06cab57ab68 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -39,76 +39,25 @@ void unregister_hsr_master(struct hsr_priv *hsr)
 		}
 }
 
-bool is_hsr_slave(struct net_device *dev)
-{
-	struct hsr_priv *hsr_it;
-
-	list_for_each_entry_rcu(hsr_it, &hsr_list, hsr_list) {
-		if (dev == hsr_it->slave[0])
-			return true;
-		if (dev == hsr_it->slave[1])
-			return true;
-	}
-
-	return false;
-}
-
-/* If dev is a HSR slave device, return the virtual master device. Return NULL
- * otherwise.
- */
-struct hsr_priv *get_hsr_master(struct net_device *dev)
-{
-	struct hsr_priv *hsr;
-
-	rcu_read_lock();
-	list_for_each_entry_rcu(hsr, &hsr_list, hsr_list)
-		if ((dev == hsr->slave[0]) ||
-		    (dev == hsr->slave[1])) {
-			rcu_read_unlock();
-			return hsr;
-		}
-
-	rcu_read_unlock();
-	return NULL;
-}
-
-/* If dev is a HSR slave device, return the other slave device. Return NULL
- * otherwise.
- */
-struct net_device *get_other_slave(struct hsr_priv *hsr,
-				   struct net_device *dev)
-{
-	if (dev == hsr->slave[0])
-		return hsr->slave[1];
-	if (dev == hsr->slave[1])
-		return hsr->slave[0];
-
-	return NULL;
-}
-
 
 static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 			     void *ptr)
 {
-	struct net_device *slave, *other_slave;
+	struct net_device *dev;
+	struct hsr_port *port, *master;
 	struct hsr_priv *hsr;
 	int mtu_max;
 	int res;
-	struct net_device *dev;
 
 	dev = netdev_notifier_info_to_dev(ptr);
-
-	hsr = get_hsr_master(dev);
-	if (hsr) {
-		/* dev is a slave device */
-		slave = dev;
-		other_slave = get_other_slave(hsr, slave);
-	} else {
+	port = hsr_port_get_rtnl(dev);
+	if (port == NULL) {
 		if (!is_hsr_master(dev))
-			return NOTIFY_DONE;
+			return NOTIFY_DONE;	/* Not an HSR device */
 		hsr = netdev_priv(dev);
-		slave = hsr->slave[0];
-		other_slave = hsr->slave[1];
+		port = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+	} else {
+		hsr = port->hsr;
 	}
 
 	switch (event) {
@@ -118,48 +67,41 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 		hsr_check_carrier_and_operstate(hsr);
 		break;
 	case NETDEV_CHANGEADDR:
-
-		/* This should not happen since there's no ndo_set_mac_address()
-		 * for HSR devices - i.e. not supported.
-		 */
-		if (dev == hsr->dev)
+		if (port->type == HSR_PT_MASTER) {
+			/* This should not happen since there's no
+			 * ndo_set_mac_address() for HSR devices - i.e. not
+			 * supported.
+			 */
 			break;
+		}
 
-		if (dev == hsr->slave[0]) {
-			ether_addr_copy(hsr->dev->dev_addr, dev->dev_addr);
-			call_netdevice_notifiers(NETDEV_CHANGEADDR, hsr->dev);
+		master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+
+		if (port->type == HSR_PT_SLAVE_A) {
+			ether_addr_copy(master->dev->dev_addr, dev->dev_addr);
+			call_netdevice_notifiers(NETDEV_CHANGEADDR, master->dev);
 		}
 
 		/* Make sure we recognize frames from ourselves in hsr_rcv() */
-		other_slave = hsr->slave[1];
+		port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);
 		res = hsr_create_self_node(&hsr->self_node_db,
-					   hsr->dev->dev_addr,
-					   other_slave ?
-						other_slave->dev_addr :
-						hsr->dev->dev_addr);
+					   master->dev->dev_addr,
+					   port ?
+						port->dev->dev_addr :
+						master->dev->dev_addr);
 		if (res)
-			netdev_warn(hsr->dev,
+			netdev_warn(master->dev,
 				    "Could not update HSR node address.\n");
 		break;
 	case NETDEV_CHANGEMTU:
-		if (dev == hsr->dev)
+		if (port->type == HSR_PT_MASTER)
 			break; /* Handled in ndo_change_mtu() */
-		mtu_max = hsr_get_max_mtu(hsr);
-		if (hsr->dev->mtu > mtu_max)
-			dev_set_mtu(hsr->dev, mtu_max);
+		mtu_max = hsr_get_max_mtu(port->hsr);
+		master = hsr_port_get_hsr(port->hsr, HSR_PT_MASTER);
+		master->dev->mtu = mtu_max;
 		break;
 	case NETDEV_UNREGISTER:
-		if (dev == hsr->slave[0]) {
-			hsr->slave[0] = NULL;
-			hsr_del_slave(hsr, 0);
-		}
-		if (dev == hsr->slave[1]) {
-			hsr->slave[1] = NULL;
-			hsr_del_slave(hsr, 1);
-		}
-
-		/* There should really be a way to set a new slave device... */
-
+		hsr_del_port(port);
 		break;
 	case NETDEV_PRE_TYPE_CHANGE:
 		/* HSR works only on Ethernet devices. Refuse slave to change
@@ -172,6 +114,16 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 }
 
 
+struct hsr_port *hsr_port_get_hsr(struct hsr_priv *hsr, enum hsr_port_type pt)
+{
+	struct hsr_port *port;
+
+	hsr_for_each_port(hsr, port)
+		if (port->type == pt)
+			return port;
+	return NULL;
+}
+
 static struct notifier_block hsr_nb = {
 	.notifier_call = hsr_netdev_notify,	/* Slave event notifications */
 };

commit 51f3c605318b056ac5deb9079bbef2a976558827
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:37:27 2014 +0200

    net/hsr: Move slave init to hsr_slave.c.
    
    Also try to prevent some possible slave dereference race conditions. This is
    finalized in the next patch, which abandons the slave array in favour of
    a list_head list and list RCU.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index 431b528c2447..b5abe26f7b4c 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -17,6 +17,7 @@
 #include "hsr_device.h"
 #include "hsr_netlink.h"
 #include "hsr_framereg.h"
+#include "hsr_slave.h"
 
 
 /* List of all registered virtual HSR devices */
@@ -124,22 +125,21 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 		if (dev == hsr->dev)
 			break;
 
-		if (dev == hsr->slave[0])
-			ether_addr_copy(hsr->dev->dev_addr,
-					hsr->slave[0]->dev_addr);
+		if (dev == hsr->slave[0]) {
+			ether_addr_copy(hsr->dev->dev_addr, dev->dev_addr);
+			call_netdevice_notifiers(NETDEV_CHANGEADDR, hsr->dev);
+		}
 
 		/* Make sure we recognize frames from ourselves in hsr_rcv() */
+		other_slave = hsr->slave[1];
 		res = hsr_create_self_node(&hsr->self_node_db,
 					   hsr->dev->dev_addr,
-					   hsr->slave[1] ?
-						hsr->slave[1]->dev_addr :
+					   other_slave ?
+						other_slave->dev_addr :
 						hsr->dev->dev_addr);
 		if (res)
 			netdev_warn(hsr->dev,
 				    "Could not update HSR node address.\n");
-
-		if (dev == hsr->slave[0])
-			call_netdevice_notifiers(NETDEV_CHANGEADDR, hsr->dev);
 		break;
 	case NETDEV_CHANGEMTU:
 		if (dev == hsr->dev)
@@ -149,10 +149,14 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 			dev_set_mtu(hsr->dev, mtu_max);
 		break;
 	case NETDEV_UNREGISTER:
-		if (dev == hsr->slave[0])
+		if (dev == hsr->slave[0]) {
 			hsr->slave[0] = NULL;
-		if (dev == hsr->slave[1])
+			hsr_del_slave(hsr, 0);
+		}
+		if (dev == hsr->slave[1]) {
 			hsr->slave[1] = NULL;
+			hsr_del_slave(hsr, 1);
+		}
 
 		/* There should really be a way to set a new slave device... */
 

commit e9aae56ea43ef4a32527b9d86c1f6b5eebfbd223
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:36:40 2014 +0200

    net/hsr: Operstate handling cleanup.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index 5f9cd7fdbd93..431b528c2447 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -91,7 +91,6 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 {
 	struct net_device *slave, *other_slave;
 	struct hsr_priv *hsr;
-	int old_operstate;
 	int mtu_max;
 	int res;
 	struct net_device *dev;
@@ -115,13 +114,7 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 	case NETDEV_UP:		/* Administrative state DOWN */
 	case NETDEV_DOWN:	/* Administrative state UP */
 	case NETDEV_CHANGE:	/* Link (carrier) state changes */
-		old_operstate = hsr->dev->operstate;
-		hsr_set_carrier(hsr->dev, slave, other_slave);
-		/* netif_stacked_transfer_operstate() cannot be used here since
-		 * it doesn't set IF_OPER_LOWERLAYERDOWN (?)
-		 */
-		hsr_set_operstate(hsr->dev, slave, other_slave);
-		hsr_check_announce(hsr->dev, old_operstate);
+		hsr_check_carrier_and_operstate(hsr);
 		break;
 	case NETDEV_CHANGEADDR:
 

commit abff7162765cd66ab109c97fd433ef1f39299120
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:35:47 2014 +0200

    net/hsr: Move to per-hsr device prune timer.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index bcda901437bc..5f9cd7fdbd93 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -175,22 +175,6 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 }
 
 
-static struct timer_list prune_timer;
-
-static void prune_nodes_all(unsigned long data)
-{
-	struct hsr_priv *hsr;
-
-	rcu_read_lock();
-	list_for_each_entry_rcu(hsr, &hsr_list, hsr_list)
-		hsr_prune_nodes(hsr);
-	rcu_read_unlock();
-
-	prune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);
-	add_timer(&prune_timer);
-}
-
-
 static struct notifier_block hsr_nb = {
 	.notifier_call = hsr_netdev_notify,	/* Slave event notifications */
 };
@@ -202,14 +186,7 @@ static int __init hsr_init(void)
 
 	BUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_HLEN);
 
-	init_timer(&prune_timer);
-	prune_timer.function = prune_nodes_all;
-	prune_timer.data = 0;
-	prune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);
-	add_timer(&prune_timer);
-
 	register_netdevice_notifier(&hsr_nb);
-
 	res = hsr_netlink_init();
 
 	return res;
@@ -218,7 +195,6 @@ static int __init hsr_init(void)
 static void __exit hsr_exit(void)
 {
 	unregister_netdevice_notifier(&hsr_nb);
-	del_timer_sync(&prune_timer);
 	hsr_netlink_exit();
 }
 

commit 81ba6afd6e6443d2bf4bf40f16df1f1f91c603f8
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:35:24 2014 +0200

    net/hsr: Switch from dev_add_pack() to netdev_rx_handler_register()
    
    Also move the frame receive handler to hsr_slave.c.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index 99b8fc4eca6c..bcda901437bc 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -7,10 +7,6 @@
  *
  * Author(s):
  *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
- *
- * In addition to routines for registering and unregistering HSR support, this
- * file also contains the receive routine that handles all incoming frames with
- * Ethertype (protocol) ETH_P_PRP (HSRv0), and network device event handling.
  */
 
 #include <linux/netdevice.h>
@@ -56,11 +52,10 @@ bool is_hsr_slave(struct net_device *dev)
 	return false;
 }
 
-
 /* If dev is a HSR slave device, return the virtual master device. Return NULL
  * otherwise.
  */
-static struct hsr_priv *get_hsr_master(struct net_device *dev)
+struct hsr_priv *get_hsr_master(struct net_device *dev)
 {
 	struct hsr_priv *hsr;
 
@@ -76,12 +71,11 @@ static struct hsr_priv *get_hsr_master(struct net_device *dev)
 	return NULL;
 }
 
-
 /* If dev is a HSR slave device, return the other slave device. Return NULL
  * otherwise.
  */
-static struct net_device *get_other_slave(struct hsr_priv *hsr,
-					  struct net_device *dev)
+struct net_device *get_other_slave(struct hsr_priv *hsr,
+				   struct net_device *dev)
 {
 	if (dev == hsr->slave[0])
 		return hsr->slave[1];
@@ -197,239 +191,6 @@ static void prune_nodes_all(unsigned long data)
 }
 
 
-static struct sk_buff *hsr_pull_tag(struct sk_buff *skb)
-{
-	struct hsr_tag *hsr_tag;
-	struct sk_buff *skb2;
-
-	skb2 = skb_share_check(skb, GFP_ATOMIC);
-	if (unlikely(!skb2))
-		goto err_free;
-	skb = skb2;
-
-	if (unlikely(!pskb_may_pull(skb, HSR_HLEN)))
-		goto err_free;
-
-	hsr_tag = (struct hsr_tag *) skb->data;
-	skb->protocol = hsr_tag->encap_proto;
-	skb_pull(skb, HSR_HLEN);
-
-	return skb;
-
-err_free:
-	kfree_skb(skb);
-	return NULL;
-}
-
-
-/* The uses I can see for these HSR supervision frames are:
- * 1) Use the frames that are sent after node initialization ("HSR_TLV.Type =
- *    22") to reset any sequence_nr counters belonging to that node. Useful if
- *    the other node's counter has been reset for some reason.
- *    --
- *    Or not - resetting the counter and bridging the frame would create a
- *    loop, unfortunately.
- *
- * 2) Use the LifeCheck frames to detect ring breaks. I.e. if no LifeCheck
- *    frame is received from a particular node, we know something is wrong.
- *    We just register these (as with normal frames) and throw them away.
- *
- * 3) Allow different MAC addresses for the two slave interfaces, using the
- *    MacAddressA field.
- */
-static bool is_supervision_frame(struct hsr_priv *hsr, struct sk_buff *skb)
-{
-	struct hsr_sup_tag *hsr_stag;
-
-	if (!ether_addr_equal(eth_hdr(skb)->h_dest,
-			      hsr->sup_multicast_addr))
-		return false;
-
-	hsr_stag = (struct hsr_sup_tag *) skb->data;
-	if (get_hsr_stag_path(hsr_stag) != 0x0f)
-		return false;
-	if ((hsr_stag->HSR_TLV_Type != HSR_TLV_ANNOUNCE) &&
-	    (hsr_stag->HSR_TLV_Type != HSR_TLV_LIFE_CHECK))
-		return false;
-	if (hsr_stag->HSR_TLV_Length != 12)
-		return false;
-
-	return true;
-}
-
-
-/* Implementation somewhat according to IEC-62439-3, p. 43
- */
-static int hsr_rcv(struct sk_buff *skb, struct net_device *dev,
-		   struct packet_type *pt, struct net_device *orig_dev)
-{
-	struct hsr_priv *hsr;
-	struct net_device *other_slave;
-	struct hsr_node *node;
-	bool deliver_to_self;
-	struct sk_buff *skb_deliver;
-	enum hsr_dev_idx dev_in_idx, dev_other_idx;
-	bool dup_out;
-	int ret;
-
-	hsr = get_hsr_master(dev);
-
-	if (!hsr) {
-		/* Non-HSR-slave device 'dev' is connected to a HSR network */
-		kfree_skb(skb);
-		dev->stats.rx_errors++;
-		return NET_RX_SUCCESS;
-	}
-
-	if (dev == hsr->slave[0]) {
-		dev_in_idx = HSR_DEV_SLAVE_A;
-		dev_other_idx = HSR_DEV_SLAVE_B;
-	} else {
-		dev_in_idx = HSR_DEV_SLAVE_B;
-		dev_other_idx = HSR_DEV_SLAVE_A;
-	}
-
-	node = hsr_find_node(&hsr->self_node_db, skb);
-	if (node) {
-		/* Always kill frames sent by ourselves */
-		kfree_skb(skb);
-		return NET_RX_SUCCESS;
-	}
-
-	/* Is this frame a candidate for local reception? */
-	deliver_to_self = false;
-	if ((skb->pkt_type == PACKET_HOST) ||
-	    (skb->pkt_type == PACKET_MULTICAST) ||
-	    (skb->pkt_type == PACKET_BROADCAST))
-		deliver_to_self = true;
-	else if (ether_addr_equal(eth_hdr(skb)->h_dest,
-				     hsr->dev->dev_addr)) {
-		skb->pkt_type = PACKET_HOST;
-		deliver_to_self = true;
-	}
-
-
-	rcu_read_lock(); /* node_db */
-	node = hsr_find_node(&hsr->node_db, skb);
-
-	if (is_supervision_frame(hsr, skb)) {
-		skb_pull(skb, sizeof(struct hsr_sup_tag));
-		node = hsr_merge_node(hsr, node, skb, dev_in_idx);
-		if (!node) {
-			rcu_read_unlock(); /* node_db */
-			kfree_skb(skb);
-			hsr->dev->stats.rx_dropped++;
-			return NET_RX_DROP;
-		}
-		skb_push(skb, sizeof(struct hsr_sup_tag));
-		deliver_to_self = false;
-	}
-
-	if (!node) {
-		/* Source node unknown; this might be a HSR frame from
-		 * another net (different multicast address). Ignore it.
-		 */
-		rcu_read_unlock(); /* node_db */
-		kfree_skb(skb);
-		return NET_RX_SUCCESS;
-	}
-
-	/* Register ALL incoming frames as outgoing through the other interface.
-	 * This allows us to register frames as incoming only if they are valid
-	 * for the receiving interface, without using a specific counter for
-	 * incoming frames.
-	 */
-	dup_out = hsr_register_frame_out(node, dev_other_idx, skb);
-	if (!dup_out)
-		hsr_register_frame_in(node, dev_in_idx);
-
-	/* Forward this frame? */
-	if (!dup_out && (skb->pkt_type != PACKET_HOST))
-		other_slave = get_other_slave(hsr, dev);
-	else
-		other_slave = NULL;
-
-	if (hsr_register_frame_out(node, HSR_DEV_MASTER, skb))
-		deliver_to_self = false;
-
-	rcu_read_unlock(); /* node_db */
-
-	if (!deliver_to_self && !other_slave) {
-		kfree_skb(skb);
-		/* Circulated frame; silently remove it. */
-		return NET_RX_SUCCESS;
-	}
-
-	skb_deliver = skb;
-	if (deliver_to_self && other_slave) {
-		/* skb_clone() is not enough since we will strip the hsr tag
-		 * and do address substitution below
-		 */
-		skb_deliver = pskb_copy(skb, GFP_ATOMIC);
-		if (!skb_deliver) {
-			deliver_to_self = false;
-			hsr->dev->stats.rx_dropped++;
-		}
-	}
-
-	if (deliver_to_self) {
-		bool multicast_frame;
-
-		skb_deliver = hsr_pull_tag(skb_deliver);
-		if (!skb_deliver) {
-			hsr->dev->stats.rx_dropped++;
-			goto forward;
-		}
-#if !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
-		/* Move everything in the header that is after the HSR tag,
-		 * to work around alignment problems caused by the 6-byte HSR
-		 * tag. In practice, this removes/overwrites the HSR tag in
-		 * the header and restores a "standard" packet.
-		 */
-		memmove(skb_deliver->data - HSR_HLEN, skb_deliver->data,
-			skb_headlen(skb_deliver));
-
-		/* Adjust skb members so they correspond with the move above.
-		 * This cannot possibly underflow skb->data since hsr_pull_tag()
-		 * above succeeded.
-		 * At this point in the protocol stack, the transport and
-		 * network headers have not been set yet, and we haven't touched
-		 * the mac header nor the head. So we only need to adjust data
-		 * and tail:
-		 */
-		skb_deliver->data -= HSR_HLEN;
-		skb_deliver->tail -= HSR_HLEN;
-#endif
-		skb_deliver->dev = hsr->dev;
-		hsr_addr_subst_source(hsr, skb_deliver);
-		multicast_frame = (skb_deliver->pkt_type == PACKET_MULTICAST);
-		ret = netif_rx(skb_deliver);
-		if (ret == NET_RX_DROP) {
-			hsr->dev->stats.rx_dropped++;
-		} else {
-			hsr->dev->stats.rx_packets++;
-			hsr->dev->stats.rx_bytes += skb->len;
-			if (multicast_frame)
-				hsr->dev->stats.multicast++;
-		}
-	}
-
-forward:
-	if (other_slave) {
-		skb_push(skb, ETH_HLEN);
-		skb->dev = other_slave;
-		dev_queue_xmit(skb);
-	}
-
-	return NET_RX_SUCCESS;
-}
-
-
-static struct packet_type hsr_pt __read_mostly = {
-	.type = htons(ETH_P_PRP),
-	.func = hsr_rcv,
-};
-
 static struct notifier_block hsr_nb = {
 	.notifier_call = hsr_netdev_notify,	/* Slave event notifications */
 };
@@ -441,8 +202,6 @@ static int __init hsr_init(void)
 
 	BUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_HLEN);
 
-	dev_add_pack(&hsr_pt);
-
 	init_timer(&prune_timer);
 	prune_timer.function = prune_nodes_all;
 	prune_timer.data = 0;
@@ -461,7 +220,6 @@ static void __exit hsr_exit(void)
 	unregister_netdevice_notifier(&hsr_nb);
 	del_timer_sync(&prune_timer);
 	hsr_netlink_exit();
-	dev_remove_pack(&hsr_pt);
 }
 
 module_init(hsr_init);

commit 70ebe4a47185db15f3c55be9611a1a971237870b
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:34:38 2014 +0200

    net/hsr: Better variable names and update of contact info.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index 3fee5218a691..99b8fc4eca6c 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -1,4 +1,4 @@
-/* Copyright 2011-2013 Autronica Fire and Security AS
+/* Copyright 2011-2014 Autronica Fire and Security AS
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -6,7 +6,7 @@
  * any later version.
  *
  * Author(s):
- *	2011-2013 Arvid Brodin, arvid.brodin@xdin.com
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
  *
  * In addition to routines for registering and unregistering HSR support, this
  * file also contains the receive routine that handles all incoming frames with
@@ -26,30 +26,30 @@
 /* List of all registered virtual HSR devices */
 static LIST_HEAD(hsr_list);
 
-void register_hsr_master(struct hsr_priv *hsr_priv)
+void register_hsr_master(struct hsr_priv *hsr)
 {
-	list_add_tail_rcu(&hsr_priv->hsr_list, &hsr_list);
+	list_add_tail_rcu(&hsr->hsr_list, &hsr_list);
 }
 
-void unregister_hsr_master(struct hsr_priv *hsr_priv)
+void unregister_hsr_master(struct hsr_priv *hsr)
 {
-	struct hsr_priv *hsr_priv_it;
+	struct hsr_priv *hsr_it;
 
-	list_for_each_entry(hsr_priv_it, &hsr_list, hsr_list)
-		if (hsr_priv_it == hsr_priv) {
-			list_del_rcu(&hsr_priv_it->hsr_list);
+	list_for_each_entry(hsr_it, &hsr_list, hsr_list)
+		if (hsr_it == hsr) {
+			list_del_rcu(&hsr_it->hsr_list);
 			return;
 		}
 }
 
 bool is_hsr_slave(struct net_device *dev)
 {
-	struct hsr_priv *hsr_priv_it;
+	struct hsr_priv *hsr_it;
 
-	list_for_each_entry_rcu(hsr_priv_it, &hsr_list, hsr_list) {
-		if (dev == hsr_priv_it->slave[0])
+	list_for_each_entry_rcu(hsr_it, &hsr_list, hsr_list) {
+		if (dev == hsr_it->slave[0])
 			return true;
-		if (dev == hsr_priv_it->slave[1])
+		if (dev == hsr_it->slave[1])
 			return true;
 	}
 
@@ -62,14 +62,14 @@ bool is_hsr_slave(struct net_device *dev)
  */
 static struct hsr_priv *get_hsr_master(struct net_device *dev)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(hsr_priv, &hsr_list, hsr_list)
-		if ((dev == hsr_priv->slave[0]) ||
-		    (dev == hsr_priv->slave[1])) {
+	list_for_each_entry_rcu(hsr, &hsr_list, hsr_list)
+		if ((dev == hsr->slave[0]) ||
+		    (dev == hsr->slave[1])) {
 			rcu_read_unlock();
-			return hsr_priv;
+			return hsr;
 		}
 
 	rcu_read_unlock();
@@ -80,13 +80,13 @@ static struct hsr_priv *get_hsr_master(struct net_device *dev)
 /* If dev is a HSR slave device, return the other slave device. Return NULL
  * otherwise.
  */
-static struct net_device *get_other_slave(struct hsr_priv *hsr_priv,
+static struct net_device *get_other_slave(struct hsr_priv *hsr,
 					  struct net_device *dev)
 {
-	if (dev == hsr_priv->slave[0])
-		return hsr_priv->slave[1];
-	if (dev == hsr_priv->slave[1])
-		return hsr_priv->slave[0];
+	if (dev == hsr->slave[0])
+		return hsr->slave[1];
+	if (dev == hsr->slave[1])
+		return hsr->slave[0];
 
 	return NULL;
 }
@@ -96,7 +96,7 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 			     void *ptr)
 {
 	struct net_device *slave, *other_slave;
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 	int old_operstate;
 	int mtu_max;
 	int res;
@@ -104,68 +104,68 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 
 	dev = netdev_notifier_info_to_dev(ptr);
 
-	hsr_priv = get_hsr_master(dev);
-	if (hsr_priv) {
+	hsr = get_hsr_master(dev);
+	if (hsr) {
 		/* dev is a slave device */
 		slave = dev;
-		other_slave = get_other_slave(hsr_priv, slave);
+		other_slave = get_other_slave(hsr, slave);
 	} else {
 		if (!is_hsr_master(dev))
 			return NOTIFY_DONE;
-		hsr_priv = netdev_priv(dev);
-		slave = hsr_priv->slave[0];
-		other_slave = hsr_priv->slave[1];
+		hsr = netdev_priv(dev);
+		slave = hsr->slave[0];
+		other_slave = hsr->slave[1];
 	}
 
 	switch (event) {
 	case NETDEV_UP:		/* Administrative state DOWN */
 	case NETDEV_DOWN:	/* Administrative state UP */
 	case NETDEV_CHANGE:	/* Link (carrier) state changes */
-		old_operstate = hsr_priv->dev->operstate;
-		hsr_set_carrier(hsr_priv->dev, slave, other_slave);
+		old_operstate = hsr->dev->operstate;
+		hsr_set_carrier(hsr->dev, slave, other_slave);
 		/* netif_stacked_transfer_operstate() cannot be used here since
 		 * it doesn't set IF_OPER_LOWERLAYERDOWN (?)
 		 */
-		hsr_set_operstate(hsr_priv->dev, slave, other_slave);
-		hsr_check_announce(hsr_priv->dev, old_operstate);
+		hsr_set_operstate(hsr->dev, slave, other_slave);
+		hsr_check_announce(hsr->dev, old_operstate);
 		break;
 	case NETDEV_CHANGEADDR:
 
 		/* This should not happen since there's no ndo_set_mac_address()
 		 * for HSR devices - i.e. not supported.
 		 */
-		if (dev == hsr_priv->dev)
+		if (dev == hsr->dev)
 			break;
 
-		if (dev == hsr_priv->slave[0])
-			ether_addr_copy(hsr_priv->dev->dev_addr,
-					hsr_priv->slave[0]->dev_addr);
+		if (dev == hsr->slave[0])
+			ether_addr_copy(hsr->dev->dev_addr,
+					hsr->slave[0]->dev_addr);
 
 		/* Make sure we recognize frames from ourselves in hsr_rcv() */
-		res = hsr_create_self_node(&hsr_priv->self_node_db,
-					   hsr_priv->dev->dev_addr,
-					   hsr_priv->slave[1] ?
-						hsr_priv->slave[1]->dev_addr :
-						hsr_priv->dev->dev_addr);
+		res = hsr_create_self_node(&hsr->self_node_db,
+					   hsr->dev->dev_addr,
+					   hsr->slave[1] ?
+						hsr->slave[1]->dev_addr :
+						hsr->dev->dev_addr);
 		if (res)
-			netdev_warn(hsr_priv->dev,
+			netdev_warn(hsr->dev,
 				    "Could not update HSR node address.\n");
 
-		if (dev == hsr_priv->slave[0])
-			call_netdevice_notifiers(NETDEV_CHANGEADDR, hsr_priv->dev);
+		if (dev == hsr->slave[0])
+			call_netdevice_notifiers(NETDEV_CHANGEADDR, hsr->dev);
 		break;
 	case NETDEV_CHANGEMTU:
-		if (dev == hsr_priv->dev)
+		if (dev == hsr->dev)
 			break; /* Handled in ndo_change_mtu() */
-		mtu_max = hsr_get_max_mtu(hsr_priv);
-		if (hsr_priv->dev->mtu > mtu_max)
-			dev_set_mtu(hsr_priv->dev, mtu_max);
+		mtu_max = hsr_get_max_mtu(hsr);
+		if (hsr->dev->mtu > mtu_max)
+			dev_set_mtu(hsr->dev, mtu_max);
 		break;
 	case NETDEV_UNREGISTER:
-		if (dev == hsr_priv->slave[0])
-			hsr_priv->slave[0] = NULL;
-		if (dev == hsr_priv->slave[1])
-			hsr_priv->slave[1] = NULL;
+		if (dev == hsr->slave[0])
+			hsr->slave[0] = NULL;
+		if (dev == hsr->slave[1])
+			hsr->slave[1] = NULL;
 
 		/* There should really be a way to set a new slave device... */
 
@@ -185,11 +185,11 @@ static struct timer_list prune_timer;
 
 static void prune_nodes_all(unsigned long data)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 
 	rcu_read_lock();
-	list_for_each_entry_rcu(hsr_priv, &hsr_list, hsr_list)
-		hsr_prune_nodes(hsr_priv);
+	list_for_each_entry_rcu(hsr, &hsr_list, hsr_list)
+		hsr_prune_nodes(hsr);
 	rcu_read_unlock();
 
 	prune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);
@@ -207,12 +207,12 @@ static struct sk_buff *hsr_pull_tag(struct sk_buff *skb)
 		goto err_free;
 	skb = skb2;
 
-	if (unlikely(!pskb_may_pull(skb, HSR_TAGLEN)))
+	if (unlikely(!pskb_may_pull(skb, HSR_HLEN)))
 		goto err_free;
 
 	hsr_tag = (struct hsr_tag *) skb->data;
 	skb->protocol = hsr_tag->encap_proto;
-	skb_pull(skb, HSR_TAGLEN);
+	skb_pull(skb, HSR_HLEN);
 
 	return skb;
 
@@ -237,12 +237,12 @@ static struct sk_buff *hsr_pull_tag(struct sk_buff *skb)
  * 3) Allow different MAC addresses for the two slave interfaces, using the
  *    MacAddressA field.
  */
-static bool is_supervision_frame(struct hsr_priv *hsr_priv, struct sk_buff *skb)
+static bool is_supervision_frame(struct hsr_priv *hsr, struct sk_buff *skb)
 {
 	struct hsr_sup_tag *hsr_stag;
 
 	if (!ether_addr_equal(eth_hdr(skb)->h_dest,
-			      hsr_priv->sup_multicast_addr))
+			      hsr->sup_multicast_addr))
 		return false;
 
 	hsr_stag = (struct hsr_sup_tag *) skb->data;
@@ -263,25 +263,25 @@ static bool is_supervision_frame(struct hsr_priv *hsr_priv, struct sk_buff *skb)
 static int hsr_rcv(struct sk_buff *skb, struct net_device *dev,
 		   struct packet_type *pt, struct net_device *orig_dev)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 	struct net_device *other_slave;
-	struct node_entry *node;
+	struct hsr_node *node;
 	bool deliver_to_self;
 	struct sk_buff *skb_deliver;
 	enum hsr_dev_idx dev_in_idx, dev_other_idx;
 	bool dup_out;
 	int ret;
 
-	hsr_priv = get_hsr_master(dev);
+	hsr = get_hsr_master(dev);
 
-	if (!hsr_priv) {
+	if (!hsr) {
 		/* Non-HSR-slave device 'dev' is connected to a HSR network */
 		kfree_skb(skb);
 		dev->stats.rx_errors++;
 		return NET_RX_SUCCESS;
 	}
 
-	if (dev == hsr_priv->slave[0]) {
+	if (dev == hsr->slave[0]) {
 		dev_in_idx = HSR_DEV_SLAVE_A;
 		dev_other_idx = HSR_DEV_SLAVE_B;
 	} else {
@@ -289,7 +289,7 @@ static int hsr_rcv(struct sk_buff *skb, struct net_device *dev,
 		dev_other_idx = HSR_DEV_SLAVE_A;
 	}
 
-	node = hsr_find_node(&hsr_priv->self_node_db, skb);
+	node = hsr_find_node(&hsr->self_node_db, skb);
 	if (node) {
 		/* Always kill frames sent by ourselves */
 		kfree_skb(skb);
@@ -303,22 +303,22 @@ static int hsr_rcv(struct sk_buff *skb, struct net_device *dev,
 	    (skb->pkt_type == PACKET_BROADCAST))
 		deliver_to_self = true;
 	else if (ether_addr_equal(eth_hdr(skb)->h_dest,
-				     hsr_priv->dev->dev_addr)) {
+				     hsr->dev->dev_addr)) {
 		skb->pkt_type = PACKET_HOST;
 		deliver_to_self = true;
 	}
 
 
 	rcu_read_lock(); /* node_db */
-	node = hsr_find_node(&hsr_priv->node_db, skb);
+	node = hsr_find_node(&hsr->node_db, skb);
 
-	if (is_supervision_frame(hsr_priv, skb)) {
+	if (is_supervision_frame(hsr, skb)) {
 		skb_pull(skb, sizeof(struct hsr_sup_tag));
-		node = hsr_merge_node(hsr_priv, node, skb, dev_in_idx);
+		node = hsr_merge_node(hsr, node, skb, dev_in_idx);
 		if (!node) {
 			rcu_read_unlock(); /* node_db */
 			kfree_skb(skb);
-			hsr_priv->dev->stats.rx_dropped++;
+			hsr->dev->stats.rx_dropped++;
 			return NET_RX_DROP;
 		}
 		skb_push(skb, sizeof(struct hsr_sup_tag));
@@ -345,7 +345,7 @@ static int hsr_rcv(struct sk_buff *skb, struct net_device *dev,
 
 	/* Forward this frame? */
 	if (!dup_out && (skb->pkt_type != PACKET_HOST))
-		other_slave = get_other_slave(hsr_priv, dev);
+		other_slave = get_other_slave(hsr, dev);
 	else
 		other_slave = NULL;
 
@@ -368,7 +368,7 @@ static int hsr_rcv(struct sk_buff *skb, struct net_device *dev,
 		skb_deliver = pskb_copy(skb, GFP_ATOMIC);
 		if (!skb_deliver) {
 			deliver_to_self = false;
-			hsr_priv->dev->stats.rx_dropped++;
+			hsr->dev->stats.rx_dropped++;
 		}
 	}
 
@@ -377,7 +377,7 @@ static int hsr_rcv(struct sk_buff *skb, struct net_device *dev,
 
 		skb_deliver = hsr_pull_tag(skb_deliver);
 		if (!skb_deliver) {
-			hsr_priv->dev->stats.rx_dropped++;
+			hsr->dev->stats.rx_dropped++;
 			goto forward;
 		}
 #if !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
@@ -386,7 +386,7 @@ static int hsr_rcv(struct sk_buff *skb, struct net_device *dev,
 		 * tag. In practice, this removes/overwrites the HSR tag in
 		 * the header and restores a "standard" packet.
 		 */
-		memmove(skb_deliver->data - HSR_TAGLEN, skb_deliver->data,
+		memmove(skb_deliver->data - HSR_HLEN, skb_deliver->data,
 			skb_headlen(skb_deliver));
 
 		/* Adjust skb members so they correspond with the move above.
@@ -397,20 +397,20 @@ static int hsr_rcv(struct sk_buff *skb, struct net_device *dev,
 		 * the mac header nor the head. So we only need to adjust data
 		 * and tail:
 		 */
-		skb_deliver->data -= HSR_TAGLEN;
-		skb_deliver->tail -= HSR_TAGLEN;
+		skb_deliver->data -= HSR_HLEN;
+		skb_deliver->tail -= HSR_HLEN;
 #endif
-		skb_deliver->dev = hsr_priv->dev;
-		hsr_addr_subst_source(hsr_priv, skb_deliver);
+		skb_deliver->dev = hsr->dev;
+		hsr_addr_subst_source(hsr, skb_deliver);
 		multicast_frame = (skb_deliver->pkt_type == PACKET_MULTICAST);
 		ret = netif_rx(skb_deliver);
 		if (ret == NET_RX_DROP) {
-			hsr_priv->dev->stats.rx_dropped++;
+			hsr->dev->stats.rx_dropped++;
 		} else {
-			hsr_priv->dev->stats.rx_packets++;
-			hsr_priv->dev->stats.rx_bytes += skb->len;
+			hsr->dev->stats.rx_packets++;
+			hsr->dev->stats.rx_bytes += skb->len;
 			if (multicast_frame)
-				hsr_priv->dev->stats.multicast++;
+				hsr->dev->stats.multicast++;
 		}
 	}
 
@@ -439,7 +439,7 @@ static int __init hsr_init(void)
 {
 	int res;
 
-	BUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_TAGLEN);
+	BUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_HLEN);
 
 	dev_add_pack(&hsr_pt);
 

commit 02f2d5a066a1bc85db3ffe3841282ad2071e2cfe
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Wed Mar 26 22:33:44 2014 +0100

    hsr: replace del_timer by del_timer_sync
    
    Use del_timer_sync to ensure that the timer is stopped on all CPUs before
    the driver exists.
    
    This change was suggested by Thomas Gleixner.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    declarer name module_exit;
    identifier ex;
    @@
    
    module_exit(ex);
    
    @@
    identifier r.ex;
    @@
    
    ex(...) {
      <...
    - del_timer
    + del_timer_sync
        (...)
      ...>
    }
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index 10010c543edf..3fee5218a691 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -459,7 +459,7 @@ static int __init hsr_init(void)
 static void __exit hsr_exit(void)
 {
 	unregister_netdevice_notifier(&hsr_nb);
-	del_timer(&prune_timer);
+	del_timer_sync(&prune_timer);
 	hsr_netlink_exit();
 	dev_remove_pack(&hsr_pt);
 }

commit e83abe37ba492514943f45f7bb1ba6b055eb88b0
Author: Joe Perches <joe@perches.com>
Date:   Tue Feb 18 10:37:20 2014 -0800

    hsr: Use ether_addr_copy
    
    It's slightly smaller/faster for some architectures.
    Make sure def_multicast_addr is __aligned(2)
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
index af68dd83a4e3..10010c543edf 100644
--- a/net/hsr/hsr_main.c
+++ b/net/hsr/hsr_main.c
@@ -138,8 +138,8 @@ static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
 			break;
 
 		if (dev == hsr_priv->slave[0])
-			memcpy(hsr_priv->dev->dev_addr,
-			       hsr_priv->slave[0]->dev_addr, ETH_ALEN);
+			ether_addr_copy(hsr_priv->dev->dev_addr,
+					hsr_priv->slave[0]->dev_addr);
 
 		/* Make sure we recognize frames from ourselves in hsr_rcv() */
 		res = hsr_create_self_node(&hsr_priv->self_node_db,

commit f421436a591d34fa5279b54a96ac07d70250cc8d
Author: Arvid Brodin <Arvid.Brodin@xdin.com>
Date:   Wed Oct 30 21:10:47 2013 +0100

    net/hsr: Add support for the High-availability Seamless Redundancy protocol (HSRv0)
    
    High-availability Seamless Redundancy ("HSR") provides instant failover
    redundancy for Ethernet networks. It requires a special network topology where
    all nodes are connected in a ring (each node having two physical network
    interfaces). It is suited for applications that demand high availability and
    very short reaction time.
    
    HSR acts on the Ethernet layer, using a registered Ethernet protocol type to
    send special HSR frames in both directions over the ring. The driver creates
    virtual network interfaces that can be used just like any ordinary Linux
    network interface, for IP/TCP/UDP traffic etc. All nodes in the network ring
    must be HSR capable.
    
    This code is a "best effort" to comply with the HSR standard as described in
    IEC 62439-3:2010 (HSRv0).
    
    Signed-off-by: Arvid Brodin <arvid.brodin@xdin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_main.c b/net/hsr/hsr_main.c
new file mode 100644
index 000000000000..af68dd83a4e3
--- /dev/null
+++ b/net/hsr/hsr_main.c
@@ -0,0 +1,469 @@
+/* Copyright 2011-2013 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2013 Arvid Brodin, arvid.brodin@xdin.com
+ *
+ * In addition to routines for registering and unregistering HSR support, this
+ * file also contains the receive routine that handles all incoming frames with
+ * Ethertype (protocol) ETH_P_PRP (HSRv0), and network device event handling.
+ */
+
+#include <linux/netdevice.h>
+#include <linux/rculist.h>
+#include <linux/timer.h>
+#include <linux/etherdevice.h>
+#include "hsr_main.h"
+#include "hsr_device.h"
+#include "hsr_netlink.h"
+#include "hsr_framereg.h"
+
+
+/* List of all registered virtual HSR devices */
+static LIST_HEAD(hsr_list);
+
+void register_hsr_master(struct hsr_priv *hsr_priv)
+{
+	list_add_tail_rcu(&hsr_priv->hsr_list, &hsr_list);
+}
+
+void unregister_hsr_master(struct hsr_priv *hsr_priv)
+{
+	struct hsr_priv *hsr_priv_it;
+
+	list_for_each_entry(hsr_priv_it, &hsr_list, hsr_list)
+		if (hsr_priv_it == hsr_priv) {
+			list_del_rcu(&hsr_priv_it->hsr_list);
+			return;
+		}
+}
+
+bool is_hsr_slave(struct net_device *dev)
+{
+	struct hsr_priv *hsr_priv_it;
+
+	list_for_each_entry_rcu(hsr_priv_it, &hsr_list, hsr_list) {
+		if (dev == hsr_priv_it->slave[0])
+			return true;
+		if (dev == hsr_priv_it->slave[1])
+			return true;
+	}
+
+	return false;
+}
+
+
+/* If dev is a HSR slave device, return the virtual master device. Return NULL
+ * otherwise.
+ */
+static struct hsr_priv *get_hsr_master(struct net_device *dev)
+{
+	struct hsr_priv *hsr_priv;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(hsr_priv, &hsr_list, hsr_list)
+		if ((dev == hsr_priv->slave[0]) ||
+		    (dev == hsr_priv->slave[1])) {
+			rcu_read_unlock();
+			return hsr_priv;
+		}
+
+	rcu_read_unlock();
+	return NULL;
+}
+
+
+/* If dev is a HSR slave device, return the other slave device. Return NULL
+ * otherwise.
+ */
+static struct net_device *get_other_slave(struct hsr_priv *hsr_priv,
+					  struct net_device *dev)
+{
+	if (dev == hsr_priv->slave[0])
+		return hsr_priv->slave[1];
+	if (dev == hsr_priv->slave[1])
+		return hsr_priv->slave[0];
+
+	return NULL;
+}
+
+
+static int hsr_netdev_notify(struct notifier_block *nb, unsigned long event,
+			     void *ptr)
+{
+	struct net_device *slave, *other_slave;
+	struct hsr_priv *hsr_priv;
+	int old_operstate;
+	int mtu_max;
+	int res;
+	struct net_device *dev;
+
+	dev = netdev_notifier_info_to_dev(ptr);
+
+	hsr_priv = get_hsr_master(dev);
+	if (hsr_priv) {
+		/* dev is a slave device */
+		slave = dev;
+		other_slave = get_other_slave(hsr_priv, slave);
+	} else {
+		if (!is_hsr_master(dev))
+			return NOTIFY_DONE;
+		hsr_priv = netdev_priv(dev);
+		slave = hsr_priv->slave[0];
+		other_slave = hsr_priv->slave[1];
+	}
+
+	switch (event) {
+	case NETDEV_UP:		/* Administrative state DOWN */
+	case NETDEV_DOWN:	/* Administrative state UP */
+	case NETDEV_CHANGE:	/* Link (carrier) state changes */
+		old_operstate = hsr_priv->dev->operstate;
+		hsr_set_carrier(hsr_priv->dev, slave, other_slave);
+		/* netif_stacked_transfer_operstate() cannot be used here since
+		 * it doesn't set IF_OPER_LOWERLAYERDOWN (?)
+		 */
+		hsr_set_operstate(hsr_priv->dev, slave, other_slave);
+		hsr_check_announce(hsr_priv->dev, old_operstate);
+		break;
+	case NETDEV_CHANGEADDR:
+
+		/* This should not happen since there's no ndo_set_mac_address()
+		 * for HSR devices - i.e. not supported.
+		 */
+		if (dev == hsr_priv->dev)
+			break;
+
+		if (dev == hsr_priv->slave[0])
+			memcpy(hsr_priv->dev->dev_addr,
+			       hsr_priv->slave[0]->dev_addr, ETH_ALEN);
+
+		/* Make sure we recognize frames from ourselves in hsr_rcv() */
+		res = hsr_create_self_node(&hsr_priv->self_node_db,
+					   hsr_priv->dev->dev_addr,
+					   hsr_priv->slave[1] ?
+						hsr_priv->slave[1]->dev_addr :
+						hsr_priv->dev->dev_addr);
+		if (res)
+			netdev_warn(hsr_priv->dev,
+				    "Could not update HSR node address.\n");
+
+		if (dev == hsr_priv->slave[0])
+			call_netdevice_notifiers(NETDEV_CHANGEADDR, hsr_priv->dev);
+		break;
+	case NETDEV_CHANGEMTU:
+		if (dev == hsr_priv->dev)
+			break; /* Handled in ndo_change_mtu() */
+		mtu_max = hsr_get_max_mtu(hsr_priv);
+		if (hsr_priv->dev->mtu > mtu_max)
+			dev_set_mtu(hsr_priv->dev, mtu_max);
+		break;
+	case NETDEV_UNREGISTER:
+		if (dev == hsr_priv->slave[0])
+			hsr_priv->slave[0] = NULL;
+		if (dev == hsr_priv->slave[1])
+			hsr_priv->slave[1] = NULL;
+
+		/* There should really be a way to set a new slave device... */
+
+		break;
+	case NETDEV_PRE_TYPE_CHANGE:
+		/* HSR works only on Ethernet devices. Refuse slave to change
+		 * its type.
+		 */
+		return NOTIFY_BAD;
+	}
+
+	return NOTIFY_DONE;
+}
+
+
+static struct timer_list prune_timer;
+
+static void prune_nodes_all(unsigned long data)
+{
+	struct hsr_priv *hsr_priv;
+
+	rcu_read_lock();
+	list_for_each_entry_rcu(hsr_priv, &hsr_list, hsr_list)
+		hsr_prune_nodes(hsr_priv);
+	rcu_read_unlock();
+
+	prune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);
+	add_timer(&prune_timer);
+}
+
+
+static struct sk_buff *hsr_pull_tag(struct sk_buff *skb)
+{
+	struct hsr_tag *hsr_tag;
+	struct sk_buff *skb2;
+
+	skb2 = skb_share_check(skb, GFP_ATOMIC);
+	if (unlikely(!skb2))
+		goto err_free;
+	skb = skb2;
+
+	if (unlikely(!pskb_may_pull(skb, HSR_TAGLEN)))
+		goto err_free;
+
+	hsr_tag = (struct hsr_tag *) skb->data;
+	skb->protocol = hsr_tag->encap_proto;
+	skb_pull(skb, HSR_TAGLEN);
+
+	return skb;
+
+err_free:
+	kfree_skb(skb);
+	return NULL;
+}
+
+
+/* The uses I can see for these HSR supervision frames are:
+ * 1) Use the frames that are sent after node initialization ("HSR_TLV.Type =
+ *    22") to reset any sequence_nr counters belonging to that node. Useful if
+ *    the other node's counter has been reset for some reason.
+ *    --
+ *    Or not - resetting the counter and bridging the frame would create a
+ *    loop, unfortunately.
+ *
+ * 2) Use the LifeCheck frames to detect ring breaks. I.e. if no LifeCheck
+ *    frame is received from a particular node, we know something is wrong.
+ *    We just register these (as with normal frames) and throw them away.
+ *
+ * 3) Allow different MAC addresses for the two slave interfaces, using the
+ *    MacAddressA field.
+ */
+static bool is_supervision_frame(struct hsr_priv *hsr_priv, struct sk_buff *skb)
+{
+	struct hsr_sup_tag *hsr_stag;
+
+	if (!ether_addr_equal(eth_hdr(skb)->h_dest,
+			      hsr_priv->sup_multicast_addr))
+		return false;
+
+	hsr_stag = (struct hsr_sup_tag *) skb->data;
+	if (get_hsr_stag_path(hsr_stag) != 0x0f)
+		return false;
+	if ((hsr_stag->HSR_TLV_Type != HSR_TLV_ANNOUNCE) &&
+	    (hsr_stag->HSR_TLV_Type != HSR_TLV_LIFE_CHECK))
+		return false;
+	if (hsr_stag->HSR_TLV_Length != 12)
+		return false;
+
+	return true;
+}
+
+
+/* Implementation somewhat according to IEC-62439-3, p. 43
+ */
+static int hsr_rcv(struct sk_buff *skb, struct net_device *dev,
+		   struct packet_type *pt, struct net_device *orig_dev)
+{
+	struct hsr_priv *hsr_priv;
+	struct net_device *other_slave;
+	struct node_entry *node;
+	bool deliver_to_self;
+	struct sk_buff *skb_deliver;
+	enum hsr_dev_idx dev_in_idx, dev_other_idx;
+	bool dup_out;
+	int ret;
+
+	hsr_priv = get_hsr_master(dev);
+
+	if (!hsr_priv) {
+		/* Non-HSR-slave device 'dev' is connected to a HSR network */
+		kfree_skb(skb);
+		dev->stats.rx_errors++;
+		return NET_RX_SUCCESS;
+	}
+
+	if (dev == hsr_priv->slave[0]) {
+		dev_in_idx = HSR_DEV_SLAVE_A;
+		dev_other_idx = HSR_DEV_SLAVE_B;
+	} else {
+		dev_in_idx = HSR_DEV_SLAVE_B;
+		dev_other_idx = HSR_DEV_SLAVE_A;
+	}
+
+	node = hsr_find_node(&hsr_priv->self_node_db, skb);
+	if (node) {
+		/* Always kill frames sent by ourselves */
+		kfree_skb(skb);
+		return NET_RX_SUCCESS;
+	}
+
+	/* Is this frame a candidate for local reception? */
+	deliver_to_self = false;
+	if ((skb->pkt_type == PACKET_HOST) ||
+	    (skb->pkt_type == PACKET_MULTICAST) ||
+	    (skb->pkt_type == PACKET_BROADCAST))
+		deliver_to_self = true;
+	else if (ether_addr_equal(eth_hdr(skb)->h_dest,
+				     hsr_priv->dev->dev_addr)) {
+		skb->pkt_type = PACKET_HOST;
+		deliver_to_self = true;
+	}
+
+
+	rcu_read_lock(); /* node_db */
+	node = hsr_find_node(&hsr_priv->node_db, skb);
+
+	if (is_supervision_frame(hsr_priv, skb)) {
+		skb_pull(skb, sizeof(struct hsr_sup_tag));
+		node = hsr_merge_node(hsr_priv, node, skb, dev_in_idx);
+		if (!node) {
+			rcu_read_unlock(); /* node_db */
+			kfree_skb(skb);
+			hsr_priv->dev->stats.rx_dropped++;
+			return NET_RX_DROP;
+		}
+		skb_push(skb, sizeof(struct hsr_sup_tag));
+		deliver_to_self = false;
+	}
+
+	if (!node) {
+		/* Source node unknown; this might be a HSR frame from
+		 * another net (different multicast address). Ignore it.
+		 */
+		rcu_read_unlock(); /* node_db */
+		kfree_skb(skb);
+		return NET_RX_SUCCESS;
+	}
+
+	/* Register ALL incoming frames as outgoing through the other interface.
+	 * This allows us to register frames as incoming only if they are valid
+	 * for the receiving interface, without using a specific counter for
+	 * incoming frames.
+	 */
+	dup_out = hsr_register_frame_out(node, dev_other_idx, skb);
+	if (!dup_out)
+		hsr_register_frame_in(node, dev_in_idx);
+
+	/* Forward this frame? */
+	if (!dup_out && (skb->pkt_type != PACKET_HOST))
+		other_slave = get_other_slave(hsr_priv, dev);
+	else
+		other_slave = NULL;
+
+	if (hsr_register_frame_out(node, HSR_DEV_MASTER, skb))
+		deliver_to_self = false;
+
+	rcu_read_unlock(); /* node_db */
+
+	if (!deliver_to_self && !other_slave) {
+		kfree_skb(skb);
+		/* Circulated frame; silently remove it. */
+		return NET_RX_SUCCESS;
+	}
+
+	skb_deliver = skb;
+	if (deliver_to_self && other_slave) {
+		/* skb_clone() is not enough since we will strip the hsr tag
+		 * and do address substitution below
+		 */
+		skb_deliver = pskb_copy(skb, GFP_ATOMIC);
+		if (!skb_deliver) {
+			deliver_to_self = false;
+			hsr_priv->dev->stats.rx_dropped++;
+		}
+	}
+
+	if (deliver_to_self) {
+		bool multicast_frame;
+
+		skb_deliver = hsr_pull_tag(skb_deliver);
+		if (!skb_deliver) {
+			hsr_priv->dev->stats.rx_dropped++;
+			goto forward;
+		}
+#if !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+		/* Move everything in the header that is after the HSR tag,
+		 * to work around alignment problems caused by the 6-byte HSR
+		 * tag. In practice, this removes/overwrites the HSR tag in
+		 * the header and restores a "standard" packet.
+		 */
+		memmove(skb_deliver->data - HSR_TAGLEN, skb_deliver->data,
+			skb_headlen(skb_deliver));
+
+		/* Adjust skb members so they correspond with the move above.
+		 * This cannot possibly underflow skb->data since hsr_pull_tag()
+		 * above succeeded.
+		 * At this point in the protocol stack, the transport and
+		 * network headers have not been set yet, and we haven't touched
+		 * the mac header nor the head. So we only need to adjust data
+		 * and tail:
+		 */
+		skb_deliver->data -= HSR_TAGLEN;
+		skb_deliver->tail -= HSR_TAGLEN;
+#endif
+		skb_deliver->dev = hsr_priv->dev;
+		hsr_addr_subst_source(hsr_priv, skb_deliver);
+		multicast_frame = (skb_deliver->pkt_type == PACKET_MULTICAST);
+		ret = netif_rx(skb_deliver);
+		if (ret == NET_RX_DROP) {
+			hsr_priv->dev->stats.rx_dropped++;
+		} else {
+			hsr_priv->dev->stats.rx_packets++;
+			hsr_priv->dev->stats.rx_bytes += skb->len;
+			if (multicast_frame)
+				hsr_priv->dev->stats.multicast++;
+		}
+	}
+
+forward:
+	if (other_slave) {
+		skb_push(skb, ETH_HLEN);
+		skb->dev = other_slave;
+		dev_queue_xmit(skb);
+	}
+
+	return NET_RX_SUCCESS;
+}
+
+
+static struct packet_type hsr_pt __read_mostly = {
+	.type = htons(ETH_P_PRP),
+	.func = hsr_rcv,
+};
+
+static struct notifier_block hsr_nb = {
+	.notifier_call = hsr_netdev_notify,	/* Slave event notifications */
+};
+
+
+static int __init hsr_init(void)
+{
+	int res;
+
+	BUILD_BUG_ON(sizeof(struct hsr_tag) != HSR_TAGLEN);
+
+	dev_add_pack(&hsr_pt);
+
+	init_timer(&prune_timer);
+	prune_timer.function = prune_nodes_all;
+	prune_timer.data = 0;
+	prune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);
+	add_timer(&prune_timer);
+
+	register_netdevice_notifier(&hsr_nb);
+
+	res = hsr_netlink_init();
+
+	return res;
+}
+
+static void __exit hsr_exit(void)
+{
+	unregister_netdevice_notifier(&hsr_nb);
+	del_timer(&prune_timer);
+	hsr_netlink_exit();
+	dev_remove_pack(&hsr_pt);
+}
+
+module_init(hsr_init);
+module_exit(hsr_exit);
+MODULE_LICENSE("GPL");
