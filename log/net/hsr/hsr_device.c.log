commit ccfc9df1352be5b2f391091e18c4b2395d30ce78
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Jul 2 17:06:19 2020 +0000

    hsr: fix interface leak in error path of hsr_dev_finalize()
    
    To release hsr(upper) interface, it should release
    its own lower interfaces first.
    Then, hsr(upper) interface can be released safely.
    In the current code of error path of hsr_dev_finalize(), it releases hsr
    interface before releasing a lower interface.
    So, a warning occurs, which warns about the leak of lower interfaces.
    In order to fix this problem, changing the ordering of the error path of
    hsr_dev_finalize() is needed.
    
    Test commands:
        ip link add dummy0 type dummy
        ip link add dummy1 type dummy
        ip link add dummy2 type dummy
        ip link add hsr0 type hsr slave1 dummy0 slave2 dummy1
        ip link add hsr1 type hsr slave1 dummy2 slave2 dummy0
    
    Splat looks like:
    [  214.923127][    C2] WARNING: CPU: 2 PID: 1093 at net/core/dev.c:8992 rollback_registered_many+0x986/0xcf0
    [  214.923129][    C2] Modules linked in: hsr dummy openvswitch nsh nf_conncount nf_nat nf_conntrack nf_defrag_ipx
    [  214.923154][    C2] CPU: 2 PID: 1093 Comm: ip Not tainted 5.8.0-rc2+ #623
    [  214.923156][    C2] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  214.923157][    C2] RIP: 0010:rollback_registered_many+0x986/0xcf0
    [  214.923160][    C2] Code: 41 8b 4e cc 45 31 c0 31 d2 4c 89 ee 48 89 df e8 e0 47 ff ff 85 c0 0f 84 cd fc ff ff 5
    [  214.923162][    C2] RSP: 0018:ffff8880c5156f28 EFLAGS: 00010287
    [  214.923165][    C2] RAX: ffff8880d1dad458 RBX: ffff8880bd1b9000 RCX: ffffffffb929d243
    [  214.923167][    C2] RDX: 1ffffffff77e63f0 RSI: 0000000000000008 RDI: ffffffffbbf31f80
    [  214.923168][    C2] RBP: dffffc0000000000 R08: fffffbfff77e63f1 R09: fffffbfff77e63f1
    [  214.923170][    C2] R10: ffffffffbbf31f87 R11: 0000000000000001 R12: ffff8880c51570a0
    [  214.923172][    C2] R13: ffff8880bd1b90b8 R14: ffff8880c5157048 R15: ffff8880d1dacc40
    [  214.923174][    C2] FS:  00007fdd257a20c0(0000) GS:ffff8880da200000(0000) knlGS:0000000000000000
    [  214.923175][    C2] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  214.923177][    C2] CR2: 00007ffd78beb038 CR3: 00000000be544005 CR4: 00000000000606e0
    [  214.923179][    C2] Call Trace:
    [  214.923180][    C2]  ? netif_set_real_num_tx_queues+0x780/0x780
    [  214.923182][    C2]  ? dev_validate_mtu+0x140/0x140
    [  214.923183][    C2]  ? synchronize_rcu.part.79+0x85/0xd0
    [  214.923185][    C2]  ? synchronize_rcu_expedited+0xbb0/0xbb0
    [  214.923187][    C2]  rollback_registered+0xc8/0x170
    [  214.923188][    C2]  ? rollback_registered_many+0xcf0/0xcf0
    [  214.923190][    C2]  unregister_netdevice_queue+0x18b/0x240
    [  214.923191][    C2]  hsr_dev_finalize+0x56e/0x6e0 [hsr]
    [  214.923192][    C2]  hsr_newlink+0x36b/0x450 [hsr]
    [  214.923194][    C2]  ? hsr_dellink+0x70/0x70 [hsr]
    [  214.923195][    C2]  ? rtnl_create_link+0x2e4/0xb00
    [  214.923197][    C2]  ? __netlink_ns_capable+0xc3/0xf0
    [  214.923198][    C2]  __rtnl_newlink+0xbdb/0x1270
    [ ... ]
    
    Fixes: e0a4b99773d3 ("hsr: use upper/lower device infrastructure")
    Reported-by: syzbot+7f1c020f68dab95aab59@syzkaller.appspotmail.com
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 478852ef98ef..a6f4e9f65b14 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -415,6 +415,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 		     unsigned char multicast_spec, u8 protocol_version,
 		     struct netlink_ext_ack *extack)
 {
+	bool unregister = false;
 	struct hsr_priv *hsr;
 	int res;
 
@@ -466,25 +467,27 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	if (res)
 		goto err_unregister;
 
+	unregister = true;
+
 	res = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A, extack);
 	if (res)
-		goto err_add_slaves;
+		goto err_unregister;
 
 	res = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B, extack);
 	if (res)
-		goto err_add_slaves;
+		goto err_unregister;
 
 	hsr_debugfs_init(hsr, hsr_dev);
 	mod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));
 
 	return 0;
 
-err_add_slaves:
-	unregister_netdevice(hsr_dev);
 err_unregister:
 	hsr_del_ports(hsr);
 err_add_master:
 	hsr_del_self_node(hsr);
 
+	if (unregister)
+		unregister_netdevice(hsr_dev);
 	return res;
 }

commit de0083c7ed7dba036d1ed6e012157649d45313c8
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sun Jun 21 13:46:25 2020 +0000

    hsr: avoid to create proc file after unregister
    
    When an interface is being deleted, "/proc/net/dev_snmp6/<interface name>"
    is deleted.
    The function for this is addrconf_ifdown() in the addrconf_notify() and
    it is called by notification, which is NETDEV_UNREGISTER.
    But, if NETDEV_CHANGEMTU is triggered after NETDEV_UNREGISTER,
    this proc file will be created again.
    This recreated proc file will be deleted by netdev_wati_allrefs().
    Before netdev_wait_allrefs() is called, creating a new HSR interface
    routine can be executed and It tries to create a proc file but it will
    find an un-deleted proc file.
    At this point, it warns about it.
    
    To avoid this situation, it can use ->dellink() instead of
    ->ndo_uninit() to release resources because ->dellink() is called
    before NETDEV_UNREGISTER.
    So, a proc file will not be recreated.
    
    Test commands
        ip link add dummy0 type dummy
        ip link add dummy1 type dummy
        ip link set dummy0 mtu 1300
    
        #SHELL1
        while :
        do
            ip link add hsr0 type hsr slave1 dummy0 slave2 dummy1
        done
    
        #SHELL2
        while :
        do
            ip link del hsr0
        done
    
    Splat looks like:
    [ 9888.980852][ T2752] proc_dir_entry 'dev_snmp6/hsr0' already registered
    [ 9888.981797][    C2] WARNING: CPU: 2 PID: 2752 at fs/proc/generic.c:372 proc_register+0x2d5/0x430
    [ 9888.981798][    C2] Modules linked in: hsr dummy veth openvswitch nsh nf_conncount nf_nat nf_conntrack nf_defrag_ipv6x
    [ 9888.981814][    C2] CPU: 2 PID: 2752 Comm: ip Tainted: G        W         5.8.0-rc1+ #616
    [ 9888.981815][    C2] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [ 9888.981816][    C2] RIP: 0010:proc_register+0x2d5/0x430
    [ 9888.981818][    C2] Code: fc ff df 48 89 fa 48 c1 ea 03 80 3c 02 00 0f 85 65 01 00 00 49 8b b5 e0 00 00 00 48 89 ea 40
    [ 9888.981819][    C2] RSP: 0018:ffff8880628dedf0 EFLAGS: 00010286
    [ 9888.981821][    C2] RAX: dffffc0000000008 RBX: ffff888028c69170 RCX: ffffffffaae09a62
    [ 9888.981822][    C2] RDX: 0000000000000001 RSI: 0000000000000008 RDI: ffff88806c9f75ac
    [ 9888.981823][    C2] RBP: ffff888028c693f4 R08: ffffed100d9401bd R09: ffffed100d9401bd
    [ 9888.981824][    C2] R10: ffffffffaddf406f R11: 0000000000000001 R12: ffff888028c69308
    [ 9888.981825][    C2] R13: ffff8880663584c8 R14: dffffc0000000000 R15: ffffed100518d27e
    [ 9888.981827][    C2] FS:  00007f3876b3b0c0(0000) GS:ffff88806c800000(0000) knlGS:0000000000000000
    [ 9888.981828][    C2] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [ 9888.981829][    C2] CR2: 00007f387601a8c0 CR3: 000000004101a002 CR4: 00000000000606e0
    [ 9888.981830][    C2] DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    [ 9888.981831][    C2] DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    [ 9888.981832][    C2] Call Trace:
    [ 9888.981833][    C2]  ? snmp6_seq_show+0x180/0x180
    [ 9888.981834][    C2]  proc_create_single_data+0x7c/0xa0
    [ 9888.981835][    C2]  snmp6_register_dev+0xb0/0x130
    [ 9888.981836][    C2]  ipv6_add_dev+0x4b7/0xf60
    [ 9888.981837][    C2]  addrconf_notify+0x684/0x1ca0
    [ 9888.981838][    C2]  ? __mutex_unlock_slowpath+0xd0/0x670
    [ 9888.981839][    C2]  ? kasan_unpoison_shadow+0x30/0x40
    [ 9888.981840][    C2]  ? wait_for_completion+0x250/0x250
    [ 9888.981841][    C2]  ? inet6_ifinfo_notify+0x100/0x100
    [ 9888.981842][    C2]  ? dropmon_net_event+0x227/0x410
    [ 9888.981843][    C2]  ? notifier_call_chain+0x90/0x160
    [ 9888.981844][    C2]  ? inet6_ifinfo_notify+0x100/0x100
    [ 9888.981845][    C2]  notifier_call_chain+0x90/0x160
    [ 9888.981846][    C2]  register_netdevice+0xbe5/0x1070
    [ ... ]
    
    Reported-by: syzbot+1d51c8b74efa4c44adeb@syzkaller.appspotmail.com
    Fixes: e0a4b99773d3 ("hsr: use upper/lower device infrastructure")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index cd99f548e440..478852ef98ef 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -339,7 +339,7 @@ static void hsr_announce(struct timer_list *t)
 	rcu_read_unlock();
 }
 
-static void hsr_del_ports(struct hsr_priv *hsr)
+void hsr_del_ports(struct hsr_priv *hsr)
 {
 	struct hsr_port *port;
 
@@ -356,31 +356,12 @@ static void hsr_del_ports(struct hsr_priv *hsr)
 		hsr_del_port(port);
 }
 
-/* This has to be called after all the readers are gone.
- * Otherwise we would have to check the return value of
- * hsr_port_get_hsr().
- */
-static void hsr_dev_destroy(struct net_device *hsr_dev)
-{
-	struct hsr_priv *hsr = netdev_priv(hsr_dev);
-
-	hsr_debugfs_term(hsr);
-	hsr_del_ports(hsr);
-
-	del_timer_sync(&hsr->prune_timer);
-	del_timer_sync(&hsr->announce_timer);
-
-	hsr_del_self_node(hsr);
-	hsr_del_nodes(&hsr->node_db);
-}
-
 static const struct net_device_ops hsr_device_ops = {
 	.ndo_change_mtu = hsr_dev_change_mtu,
 	.ndo_open = hsr_dev_open,
 	.ndo_stop = hsr_dev_close,
 	.ndo_start_xmit = hsr_dev_xmit,
 	.ndo_fix_features = hsr_fix_features,
-	.ndo_uninit = hsr_dev_destroy,
 };
 
 static struct device_type hsr_type = {

commit f30e472071c827e2c2f191c8a011b7e371e17af5
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Fri Apr 24 12:43:09 2020 +0000

    hsr: remove unnecessary code in hsr_dev_change_mtu()
    
    In the hsr_dev_change_mtu(), the 'dev' and 'master->dev' pointer are
    same. So, the 'master' variable and some code are unnecessary.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index fc7027314ad8..cd99f548e440 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -125,13 +125,11 @@ int hsr_get_max_mtu(struct hsr_priv *hsr)
 static int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct hsr_priv *hsr;
-	struct hsr_port *master;
 
 	hsr = netdev_priv(dev);
-	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 
 	if (new_mtu > hsr_get_max_mtu(hsr)) {
-		netdev_info(master->dev, "A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\n",
+		netdev_info(dev, "A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\n",
 			    HSR_HLEN);
 		return -EINVAL;
 	}

commit e0a4b99773d3d8d3fb40087805f8fd858a23e582
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Fri Feb 28 18:02:10 2020 +0000

    hsr: use upper/lower device infrastructure
    
    netdev_upper_dev_link() is useful to manage lower/upper interfaces.
    And this function internally validates looping, maximum depth.
    All or most virtual interfaces that could have a real interface
    (e.g. macsec, macvlan, ipvlan etc.) use lower/upper infrastructure.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 00532d14fc7c..fc7027314ad8 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -341,22 +341,33 @@ static void hsr_announce(struct timer_list *t)
 	rcu_read_unlock();
 }
 
+static void hsr_del_ports(struct hsr_priv *hsr)
+{
+	struct hsr_port *port;
+
+	port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_A);
+	if (port)
+		hsr_del_port(port);
+
+	port = hsr_port_get_hsr(hsr, HSR_PT_SLAVE_B);
+	if (port)
+		hsr_del_port(port);
+
+	port = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
+	if (port)
+		hsr_del_port(port);
+}
+
 /* This has to be called after all the readers are gone.
  * Otherwise we would have to check the return value of
  * hsr_port_get_hsr().
  */
 static void hsr_dev_destroy(struct net_device *hsr_dev)
 {
-	struct hsr_priv *hsr;
-	struct hsr_port *port;
-	struct hsr_port *tmp;
-
-	hsr = netdev_priv(hsr_dev);
+	struct hsr_priv *hsr = netdev_priv(hsr_dev);
 
 	hsr_debugfs_term(hsr);
-
-	list_for_each_entry_safe(port, tmp, &hsr->ports, port_list)
-		hsr_del_port(port);
+	hsr_del_ports(hsr);
 
 	del_timer_sync(&hsr->prune_timer);
 	del_timer_sync(&hsr->announce_timer);
@@ -426,8 +437,6 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 		     struct netlink_ext_ack *extack)
 {
 	struct hsr_priv *hsr;
-	struct hsr_port *port;
-	struct hsr_port *tmp;
 	int res;
 
 	hsr = netdev_priv(hsr_dev);
@@ -494,8 +503,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 err_add_slaves:
 	unregister_netdevice(hsr_dev);
 err_unregister:
-	list_for_each_entry_safe(port, tmp, &hsr->ports, port_list)
-		hsr_del_port(port);
+	hsr_del_ports(hsr);
 err_add_master:
 	hsr_del_self_node(hsr);
 

commit 81390d0c4e56ac7752c97d7e8209357673d1a8ab
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Fri Feb 28 18:01:56 2020 +0000

    hsr: remove unnecessary rcu_read_lock() in hsr module
    
    In order to access the port list, the hsr_port_get_hsr() is used.
    And this is protected by RTNL and RCU.
    The hsr_fill_info(), hsr_check_carrier(), hsr_dev_open() and
    hsr_get_max_mtu() are protected by RTNL.
    So, rcu_read_lock() in these functions are not necessary.
    The hsr_handle_frame() also uses rcu_read_lock() but this function
    is called by packet path.
    It's already protected by RCU.
    So, the rcu_read_lock() in hsr_handle_frame() can be removed.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index a48f621c2fec..00532d14fc7c 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -57,24 +57,19 @@ static void hsr_set_operstate(struct hsr_port *master, bool has_carrier)
 static bool hsr_check_carrier(struct hsr_port *master)
 {
 	struct hsr_port *port;
-	bool has_carrier;
 
-	has_carrier = false;
+	ASSERT_RTNL();
 
-	rcu_read_lock();
-	hsr_for_each_port(master->hsr, port)
+	hsr_for_each_port(master->hsr, port) {
 		if (port->type != HSR_PT_MASTER && is_slave_up(port->dev)) {
-			has_carrier = true;
-			break;
+			netif_carrier_on(master->dev);
+			return true;
 		}
-	rcu_read_unlock();
+	}
 
-	if (has_carrier)
-		netif_carrier_on(master->dev);
-	else
-		netif_carrier_off(master->dev);
+	netif_carrier_off(master->dev);
 
-	return has_carrier;
+	return false;
 }
 
 static void hsr_check_announce(struct net_device *hsr_dev,
@@ -118,11 +113,9 @@ int hsr_get_max_mtu(struct hsr_priv *hsr)
 	struct hsr_port *port;
 
 	mtu_max = ETH_DATA_LEN;
-	rcu_read_lock();
 	hsr_for_each_port(hsr, port)
 		if (port->type != HSR_PT_MASTER)
 			mtu_max = min(port->dev->mtu, mtu_max);
-	rcu_read_unlock();
 
 	if (mtu_max < HSR_HLEN)
 		return 0;
@@ -157,7 +150,6 @@ static int hsr_dev_open(struct net_device *dev)
 	hsr = netdev_priv(dev);
 	designation = '\0';
 
-	rcu_read_lock();
 	hsr_for_each_port(hsr, port) {
 		if (port->type == HSR_PT_MASTER)
 			continue;
@@ -175,7 +167,6 @@ static int hsr_dev_open(struct net_device *dev)
 			netdev_warn(dev, "Slave %c (%s) is not up; please bring it up to get a fully working HSR network\n",
 				    designation, port->dev->name);
 	}
-	rcu_read_unlock();
 
 	if (designation == '\0')
 		netdev_warn(dev, "No slave devices configured\n");

commit 13eeb5fea68e11765020b846ef692809c5fe04aa
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Fri Feb 28 18:01:35 2020 +0000

    hsr: use extack error message instead of netdev_info
    
    If HSR uses the extack instead of netdev_info(), users can get
    error messages immediately without any checking the kernel message.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index c7bd6c49fadf..a48f621c2fec 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -431,7 +431,8 @@ static const unsigned char def_multicast_addr[ETH_ALEN] __aligned(2) = {
 };
 
 int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
-		     unsigned char multicast_spec, u8 protocol_version)
+		     unsigned char multicast_spec, u8 protocol_version,
+		     struct netlink_ext_ack *extack)
 {
 	struct hsr_priv *hsr;
 	struct hsr_port *port;
@@ -478,7 +479,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	/* Make sure the 1st call to netif_carrier_on() gets through */
 	netif_carrier_off(hsr_dev);
 
-	res = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);
+	res = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER, extack);
 	if (res)
 		goto err_add_master;
 
@@ -486,11 +487,11 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	if (res)
 		goto err_unregister;
 
-	res = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);
+	res = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A, extack);
 	if (res)
 		goto err_add_slaves;
 
-	res = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);
+	res = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B, extack);
 	if (res)
 		goto err_add_slaves;
 

commit 3ed0a1d563903bdb4b4c36c58c4d9c1bcb23a6e6
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sun Dec 22 11:27:08 2019 +0000

    hsr: reset network header when supervision frame is created
    
    The supervision frame is L2 frame.
    When supervision frame is created, hsr module doesn't set network header.
    If tap routine is enabled, dev_queue_xmit_nit() is called and it checks
    network_header. If network_header pointer wasn't set(or invalid),
    it resets network_header and warns.
    In order to avoid unnecessary warning message, resetting network_header
    is needed.
    
    Test commands:
        ip netns add nst
        ip link add veth0 type veth peer name veth1
        ip link add veth2 type veth peer name veth3
        ip link set veth1 netns nst
        ip link set veth3 netns nst
        ip link set veth0 up
        ip link set veth2 up
        ip link add hsr0 type hsr slave1 veth0 slave2 veth2
        ip a a 192.168.100.1/24 dev hsr0
        ip link set hsr0 up
        ip netns exec nst ip link set veth1 up
        ip netns exec nst ip link set veth3 up
        ip netns exec nst ip link add hsr1 type hsr slave1 veth1 slave2 veth3
        ip netns exec nst ip a a 192.168.100.2/24 dev hsr1
        ip netns exec nst ip link set hsr1 up
        tcpdump -nei veth0
    
    Splat looks like:
    [  175.852292][    C3] protocol 88fb is buggy, dev veth0
    
    Fixes: f421436a591d ("net/hsr: Add support for the High-availability Seamless Redundancy protocol (HSRv0)")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 62c03f0d0079..c7bd6c49fadf 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -272,6 +272,8 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 			    skb->dev->dev_addr, skb->len) <= 0)
 		goto out;
 	skb_reset_mac_header(skb);
+	skb_reset_network_header(skb);
+	skb_reset_transport_header(skb);
 
 	if (hsr_ver > 0) {
 		hsr_tag = skb_put(skb, sizeof(struct hsr_tag));

commit 92a35678ec075100ce666a2fb6969151affb0e5d
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sun Dec 22 11:26:54 2019 +0000

    hsr: fix a race condition in node list insertion and deletion
    
    hsr nodes are protected by RCU and there is no write side lock.
    But node insertions and deletions could be being operated concurrently.
    So write side locking is needed.
    
    Test commands:
        ip netns add nst
        ip link add veth0 type veth peer name veth1
        ip link add veth2 type veth peer name veth3
        ip link set veth1 netns nst
        ip link set veth3 netns nst
        ip link set veth0 up
        ip link set veth2 up
        ip link add hsr0 type hsr slave1 veth0 slave2 veth2
        ip a a 192.168.100.1/24 dev hsr0
        ip link set hsr0 up
        ip netns exec nst ip link set veth1 up
        ip netns exec nst ip link set veth3 up
        ip netns exec nst ip link add hsr1 type hsr slave1 veth1 slave2 veth3
        ip netns exec nst ip a a 192.168.100.2/24 dev hsr1
        ip netns exec nst ip link set hsr1 up
    
        for i in {0..9}
        do
            for j in {0..9}
            do
                for k in {0..9}
                do
                    for l in {0..9}
                    do
                    arping 192.168.100.2 -I hsr0 -s 00:01:3$i:4$j:5$k:6$l -c1 &
                    done
                done
            done
        done
    
    Splat looks like:
    [  236.066091][ T3286] list_add corruption. next->prev should be prev (ffff8880a5940300), but was ffff8880a5940d0.
    [  236.069617][ T3286] ------------[ cut here ]------------
    [  236.070545][ T3286] kernel BUG at lib/list_debug.c:25!
    [  236.071391][ T3286] invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [  236.072343][ T3286] CPU: 0 PID: 3286 Comm: arping Tainted: G        W         5.5.0-rc1+ #209
    [  236.073463][ T3286] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  236.074695][ T3286] RIP: 0010:__list_add_valid+0x74/0xd0
    [  236.075499][ T3286] Code: 48 39 da 75 27 48 39 f5 74 36 48 39 dd 74 31 48 83 c4 08 b8 01 00 00 00 5b 5d c3 48 b
    [  236.078277][ T3286] RSP: 0018:ffff8880aaa97648 EFLAGS: 00010286
    [  236.086991][ T3286] RAX: 0000000000000075 RBX: ffff8880d4624c20 RCX: 0000000000000000
    [  236.088000][ T3286] RDX: 0000000000000075 RSI: 0000000000000008 RDI: ffffed1015552ebf
    [  236.098897][ T3286] RBP: ffff88809b53d200 R08: ffffed101b3c04f9 R09: ffffed101b3c04f9
    [  236.099960][ T3286] R10: 00000000308769a1 R11: ffffed101b3c04f8 R12: ffff8880d4624c28
    [  236.100974][ T3286] R13: ffff8880d4624c20 R14: 0000000040310100 R15: ffff8880ce17ee02
    [  236.138967][ T3286] FS:  00007f23479fa680(0000) GS:ffff8880d9c00000(0000) knlGS:0000000000000000
    [  236.144852][ T3286] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  236.145720][ T3286] CR2: 00007f4a14bab210 CR3: 00000000a61c6001 CR4: 00000000000606f0
    [  236.146776][ T3286] Call Trace:
    [  236.147222][ T3286]  hsr_add_node+0x314/0x490 [hsr]
    [  236.153633][ T3286]  hsr_forward_skb+0x2b6/0x1bc0 [hsr]
    [  236.154362][ T3286]  ? rcu_read_lock_sched_held+0x90/0xc0
    [  236.155091][ T3286]  ? rcu_read_lock_bh_held+0xa0/0xa0
    [  236.156607][ T3286]  hsr_dev_xmit+0x70/0xd0 [hsr]
    [  236.157254][ T3286]  dev_hard_start_xmit+0x160/0x740
    [  236.157941][ T3286]  __dev_queue_xmit+0x1961/0x2e10
    [  236.158565][ T3286]  ? netdev_core_pick_tx+0x2e0/0x2e0
    [ ... ]
    
    Reported-by: syzbot+3924327f9ad5f4d2b343@syzkaller.appspotmail.com
    Fixes: f421436a591d ("net/hsr: Add support for the High-availability Seamless Redundancy protocol (HSRv0)")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index e73549075a03..62c03f0d0079 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -368,7 +368,7 @@ static void hsr_dev_destroy(struct net_device *hsr_dev)
 	del_timer_sync(&hsr->prune_timer);
 	del_timer_sync(&hsr->announce_timer);
 
-	hsr_del_self_node(&hsr->self_node_db);
+	hsr_del_self_node(hsr);
 	hsr_del_nodes(&hsr->node_db);
 }
 
@@ -440,11 +440,12 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	INIT_LIST_HEAD(&hsr->ports);
 	INIT_LIST_HEAD(&hsr->node_db);
 	INIT_LIST_HEAD(&hsr->self_node_db);
+	spin_lock_init(&hsr->list_lock);
 
 	ether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);
 
 	/* Make sure we recognize frames from ourselves in hsr_rcv() */
-	res = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,
+	res = hsr_create_self_node(hsr, hsr_dev->dev_addr,
 				   slave[1]->dev_addr);
 	if (res < 0)
 		return res;
@@ -502,7 +503,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	list_for_each_entry_safe(port, tmp, &hsr->ports, port_list)
 		hsr_del_port(port);
 err_add_master:
-	hsr_del_self_node(&hsr->self_node_db);
+	hsr_del_self_node(hsr);
 
 	return res;
 }

commit 1d19e2d53e8ed9e4c98fc95e0067492cda7288b0
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sun Dec 22 11:26:15 2019 +0000

    hsr: fix error handling routine in hsr_dev_finalize()
    
    hsr_dev_finalize() is called to create new hsr interface.
    There are some wrong error handling codes.
    
    1. wrong checking return value of debugfs_create_{dir/file}.
    These function doesn't return NULL. If error occurs in there,
    it returns error pointer.
    So, it should check error pointer instead of NULL.
    
    2. It doesn't unregister interface if it fails to setup hsr interface.
    If it fails to initialize hsr interface after register_netdevice(),
    it should call unregister_netdevice().
    
    3. Ignore failure of creation of debugfs
    If creating of debugfs dir and file is failed, creating hsr interface
    will be failed. But debugfs doesn't affect actual logic of hsr module.
    So, ignoring this is more correct and this behavior is more general.
    
    Fixes: c5a759117210 ("net/hsr: Use list_head (and rcu) instead of array for slave devices.")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index b01e1bae4ddc..e73549075a03 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -477,30 +477,31 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 
 	res = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);
 	if (res)
-		goto err_add_port;
+		goto err_add_master;
 
 	res = register_netdevice(hsr_dev);
 	if (res)
-		goto fail;
+		goto err_unregister;
 
 	res = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);
 	if (res)
-		goto fail;
+		goto err_add_slaves;
+
 	res = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);
 	if (res)
-		goto fail;
+		goto err_add_slaves;
 
+	hsr_debugfs_init(hsr, hsr_dev);
 	mod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));
-	res = hsr_debugfs_init(hsr, hsr_dev);
-	if (res)
-		goto fail;
 
 	return 0;
 
-fail:
+err_add_slaves:
+	unregister_netdevice(hsr_dev);
+err_unregister:
 	list_for_each_entry_safe(port, tmp, &hsr->ports, port_list)
 		hsr_del_port(port);
-err_add_port:
+err_add_master:
 	hsr_del_self_node(&hsr->self_node_db);
 
 	return res;

commit df95467b6d2bfce49667ee4b71c67249b01957f7
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Thu Dec 5 07:23:39 2019 +0000

    hsr: fix a NULL pointer dereference in hsr_dev_xmit()
    
    hsr_dev_xmit() calls hsr_port_get_hsr() to find master node and that would
    return NULL if master node is not existing in the list.
    But hsr_dev_xmit() doesn't check return pointer so a NULL dereference
    could occur.
    
    Test commands:
        ip netns add nst
        ip link add veth0 type veth peer name veth1
        ip link add veth2 type veth peer name veth3
        ip link set veth1 netns nst
        ip link set veth3 netns nst
        ip link set veth0 up
        ip link set veth2 up
        ip link add hsr0 type hsr slave1 veth0 slave2 veth2
        ip a a 192.168.100.1/24 dev hsr0
        ip link set hsr0 up
        ip netns exec nst ip link set veth1 up
        ip netns exec nst ip link set veth3 up
        ip netns exec nst ip link add hsr1 type hsr slave1 veth1 slave2 veth3
        ip netns exec nst ip a a 192.168.100.2/24 dev hsr1
        ip netns exec nst ip link set hsr1 up
        hping3 192.168.100.2 -2 --flood &
        modprobe -rv hsr
    
    Splat looks like:
    [  217.351122][ T1635] kasan: CONFIG_KASAN_INLINE enabled
    [  217.352969][ T1635] kasan: GPF could be caused by NULL-ptr deref or user memory access
    [  217.354297][ T1635] general protection fault: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [  217.355507][ T1635] CPU: 1 PID: 1635 Comm: hping3 Not tainted 5.4.0+ #192
    [  217.356472][ T1635] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  217.357804][ T1635] RIP: 0010:hsr_dev_xmit+0x34/0x90 [hsr]
    [  217.373010][ T1635] Code: 48 8d be 00 0c 00 00 be 04 00 00 00 48 83 ec 08 e8 21 be ff ff 48 8d 78 10 48 ba 00 b
    [  217.376919][ T1635] RSP: 0018:ffff8880cd8af058 EFLAGS: 00010202
    [  217.377571][ T1635] RAX: 0000000000000000 RBX: ffff8880acde6840 RCX: 0000000000000002
    [  217.379465][ T1635] RDX: dffffc0000000000 RSI: 0000000000000004 RDI: 0000000000000010
    [  217.380274][ T1635] RBP: ffff8880acde6840 R08: ffffed101b440d5d R09: 0000000000000001
    [  217.381078][ T1635] R10: 0000000000000001 R11: ffffed101b440d5c R12: ffff8880bffcc000
    [  217.382023][ T1635] R13: ffff8880bffcc088 R14: 0000000000000000 R15: ffff8880ca675c00
    [  217.383094][ T1635] FS:  00007f060d9d1740(0000) GS:ffff8880da000000(0000) knlGS:0000000000000000
    [  217.384289][ T1635] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  217.385009][ T1635] CR2: 00007faf15381dd0 CR3: 00000000d523c001 CR4: 00000000000606e0
    [  217.385940][ T1635] Call Trace:
    [  217.386544][ T1635]  dev_hard_start_xmit+0x160/0x740
    [  217.387114][ T1635]  __dev_queue_xmit+0x1961/0x2e10
    [  217.388118][ T1635]  ? check_object+0xaf/0x260
    [  217.391466][ T1635]  ? __alloc_skb+0xb9/0x500
    [  217.392017][ T1635]  ? init_object+0x6b/0x80
    [  217.392629][ T1635]  ? netdev_core_pick_tx+0x2e0/0x2e0
    [  217.393175][ T1635]  ? __alloc_skb+0xb9/0x500
    [  217.393727][ T1635]  ? rcu_read_lock_sched_held+0x90/0xc0
    [  217.394331][ T1635]  ? rcu_read_lock_bh_held+0xa0/0xa0
    [  217.395013][ T1635]  ? kasan_unpoison_shadow+0x30/0x40
    [  217.395668][ T1635]  ? __kasan_kmalloc.constprop.4+0xa0/0xd0
    [  217.396280][ T1635]  ? __kmalloc_node_track_caller+0x3a8/0x3f0
    [  217.399007][ T1635]  ? __kasan_kmalloc.constprop.4+0xa0/0xd0
    [  217.400093][ T1635]  ? __kmalloc_reserve.isra.46+0x2e/0xb0
    [  217.401118][ T1635]  ? memset+0x1f/0x40
    [  217.402529][ T1635]  ? __alloc_skb+0x317/0x500
    [  217.404915][ T1635]  ? arp_xmit+0xca/0x2c0
    [ ... ]
    
    Fixes: 311633b60406 ("hsr: switch ->dellink() to ->ndo_uninit()")
    Acked-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index f509b495451a..b01e1bae4ddc 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -227,8 +227,13 @@ static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct hsr_port *master;
 
 	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
-	skb->dev = master->dev;
-	hsr_forward_skb(skb, master);
+	if (master) {
+		skb->dev = master->dev;
+		hsr_forward_skb(skb, master);
+	} else {
+		atomic_long_inc(&dev->tx_dropped);
+		dev_kfree_skb_any(skb);
+	}
 	return NETDEV_TX_OK;
 }
 

commit 311633b604063a8a5d3fbc74d0565b42df721f68
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Tue Jul 9 23:24:54 2019 -0700

    hsr: switch ->dellink() to ->ndo_uninit()
    
    Switching from ->priv_destructor to dellink() has an unexpected
    consequence: existing RCU readers, that is, hsr_port_get_hsr()
    callers, may still be able to read the port list.
    
    Instead of checking the return value of each hsr_port_get_hsr(),
    we can just move it to ->ndo_uninit() which is called after
    device unregister and synchronize_net(), and we still have RTNL
    lock there.
    
    Fixes: b9a1e627405d ("hsr: implement dellink to clean up resources")
    Fixes: edf070a0fb45 ("hsr: fix a NULL pointer deref in hsr_dev_xmit()")
    Reported-by: syzbot+097ef84cdc95843fbaa8@syzkaller.appspotmail.com
    Cc: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index f0f9b493c47b..f509b495451a 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -227,13 +227,8 @@ static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct hsr_port *master;
 
 	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
-	if (master) {
-		skb->dev = master->dev;
-		hsr_forward_skb(skb, master);
-	} else {
-		atomic_long_inc(&dev->tx_dropped);
-		dev_kfree_skb_any(skb);
-	}
+	skb->dev = master->dev;
+	hsr_forward_skb(skb, master);
 	return NETDEV_TX_OK;
 }
 
@@ -348,7 +343,11 @@ static void hsr_announce(struct timer_list *t)
 	rcu_read_unlock();
 }
 
-void hsr_dev_destroy(struct net_device *hsr_dev)
+/* This has to be called after all the readers are gone.
+ * Otherwise we would have to check the return value of
+ * hsr_port_get_hsr().
+ */
+static void hsr_dev_destroy(struct net_device *hsr_dev)
 {
 	struct hsr_priv *hsr;
 	struct hsr_port *port;
@@ -364,8 +363,6 @@ void hsr_dev_destroy(struct net_device *hsr_dev)
 	del_timer_sync(&hsr->prune_timer);
 	del_timer_sync(&hsr->announce_timer);
 
-	synchronize_rcu();
-
 	hsr_del_self_node(&hsr->self_node_db);
 	hsr_del_nodes(&hsr->node_db);
 }
@@ -376,6 +373,7 @@ static const struct net_device_ops hsr_device_ops = {
 	.ndo_stop = hsr_dev_close,
 	.ndo_start_xmit = hsr_dev_xmit,
 	.ndo_fix_features = hsr_fix_features,
+	.ndo_uninit = hsr_dev_destroy,
 };
 
 static struct device_type hsr_type = {

commit edf070a0fb45ac845f534baf172fbadbeb5048c6
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Wed Jul 3 17:21:14 2019 -0700

    hsr: fix a NULL pointer deref in hsr_dev_xmit()
    
    hsr_port_get_hsr() could return NULL and kernel
    could crash:
    
     BUG: kernel NULL pointer dereference, address: 0000000000000010
     #PF: supervisor read access in kernel mode
     #PF: error_code(0x0000) - not-present page
     PGD 8000000074b84067 P4D 8000000074b84067 PUD 7057d067 PMD 0
     Oops: 0000 [#1] SMP PTI
     CPU: 0 PID: 754 Comm: a.out Not tainted 5.2.0-rc6+ #718
     Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.12.0-2.fc30 04/01/2014
     RIP: 0010:hsr_dev_xmit+0x20/0x31
     Code: 48 8b 1b eb e0 5b 5d 41 5c c3 66 66 66 66 90 55 48 89 fd 48 8d be 40 0b 00 00 be 04 00 00 00 e8 ee f2 ff ff 48 89 ef 48 89 c6 <48> 8b 40 10 48 89 45 10 e8 6c 1b 00 00 31 c0 5d c3 66 66 66 66 90
     RSP: 0018:ffffb5b400003c48 EFLAGS: 00010246
     RAX: 0000000000000000 RBX: ffff9821b4509a88 RCX: 0000000000000000
     RDX: ffff9821b4509a88 RSI: 0000000000000000 RDI: ffff9821bc3fc7c0
     RBP: ffff9821bc3fc7c0 R08: 0000000000000000 R09: 00000000000c2019
     R10: 0000000000000000 R11: 0000000000000002 R12: ffff9821bc3fc7c0
     R13: ffff9821b4509a88 R14: 0000000000000000 R15: 000000000000006e
     FS:  00007fee112a1800(0000) GS:ffff9821bd800000(0000) knlGS:0000000000000000
     CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
     CR2: 0000000000000010 CR3: 000000006e9ce000 CR4: 00000000000406f0
     Call Trace:
      <IRQ>
      netdev_start_xmit+0x1b/0x38
      dev_hard_start_xmit+0x121/0x21e
      ? validate_xmit_skb.isra.0+0x19/0x1e3
      __dev_queue_xmit+0x74c/0x823
      ? lockdep_hardirqs_on+0x12b/0x17d
      ip6_finish_output2+0x3d3/0x42c
      ? ip6_mtu+0x55/0x5c
      ? mld_sendpack+0x191/0x229
      mld_sendpack+0x191/0x229
      mld_ifc_timer_expire+0x1f7/0x230
      ? mld_dad_timer_expire+0x58/0x58
      call_timer_fn+0x12e/0x273
      __run_timers.part.0+0x174/0x1b5
      ? mld_dad_timer_expire+0x58/0x58
      ? sched_clock_cpu+0x10/0xad
      ? mark_lock+0x26/0x1f2
      ? __lock_is_held+0x40/0x71
      run_timer_softirq+0x26/0x48
      __do_softirq+0x1af/0x392
      irq_exit+0x53/0xa2
      smp_apic_timer_interrupt+0x1c4/0x1d9
      apic_timer_interrupt+0xf/0x20
      </IRQ>
    
    Cc: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 4ea7d54a8262..f0f9b493c47b 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -227,9 +227,13 @@ static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 	struct hsr_port *master;
 
 	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
-	skb->dev = master->dev;
-	hsr_forward_skb(skb, master);
-
+	if (master) {
+		skb->dev = master->dev;
+		hsr_forward_skb(skb, master);
+	} else {
+		atomic_long_inc(&dev->tx_dropped);
+		dev_kfree_skb_any(skb);
+	}
 	return NETDEV_TX_OK;
 }
 

commit b9a1e627405d68d475a3c1f35e685ccfb5bbe668
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Wed Jul 3 17:21:13 2019 -0700

    hsr: implement dellink to clean up resources
    
    hsr_link_ops implements ->newlink() but not ->dellink(),
    which leads that resources not released after removing the device,
    particularly the entries in self_node_db and node_db.
    
    So add ->dellink() implementation to replace the priv_destructor.
    This also makes the code slightly easier to understand.
    
    Reported-by: syzbot+c6167ec3de7def23d1e8@syzkaller.appspotmail.com
    Cc: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index f48b6a275cf0..4ea7d54a8262 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -344,10 +344,7 @@ static void hsr_announce(struct timer_list *t)
 	rcu_read_unlock();
 }
 
-/* According to comments in the declaration of struct net_device, this function
- * is "Called from unregister, can be used to call free_netdev". Ok then...
- */
-static void hsr_dev_destroy(struct net_device *hsr_dev)
+void hsr_dev_destroy(struct net_device *hsr_dev)
 {
 	struct hsr_priv *hsr;
 	struct hsr_port *port;
@@ -357,15 +354,16 @@ static void hsr_dev_destroy(struct net_device *hsr_dev)
 
 	hsr_debugfs_term(hsr);
 
-	rtnl_lock();
 	list_for_each_entry_safe(port, tmp, &hsr->ports, port_list)
 		hsr_del_port(port);
-	rtnl_unlock();
 
 	del_timer_sync(&hsr->prune_timer);
 	del_timer_sync(&hsr->announce_timer);
 
 	synchronize_rcu();
+
+	hsr_del_self_node(&hsr->self_node_db);
+	hsr_del_nodes(&hsr->node_db);
 }
 
 static const struct net_device_ops hsr_device_ops = {
@@ -392,7 +390,6 @@ void hsr_dev_setup(struct net_device *dev)
 	dev->priv_flags |= IFF_NO_QUEUE;
 
 	dev->needs_free_netdev = true;
-	dev->priv_destructor = hsr_dev_destroy;
 
 	dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
 			   NETIF_F_GSO_MASK | NETIF_F_HW_CSUM |
@@ -497,7 +494,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	list_for_each_entry_safe(port, tmp, &hsr->ports, port_list)
 		hsr_del_port(port);
 err_add_port:
-	hsr_del_node(&hsr->self_node_db);
+	hsr_del_self_node(&hsr->self_node_db);
 
 	return res;
 }

commit 619afef01f74f3572b5e9a266c1230dc83761eec
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Wed Jul 3 17:21:12 2019 -0700

    hsr: fix a memory leak in hsr_del_port()
    
    hsr_del_port() should release all the resources allocated
    in hsr_add_port().
    
    As a consequence of this change, hsr_for_each_port() is no
    longer safe to work with hsr_del_port(), switch to
    list_for_each_entry_safe() as we always hold RTNL lock.
    
    Cc: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 15c72065df79..f48b6a275cf0 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -351,13 +351,14 @@ static void hsr_dev_destroy(struct net_device *hsr_dev)
 {
 	struct hsr_priv *hsr;
 	struct hsr_port *port;
+	struct hsr_port *tmp;
 
 	hsr = netdev_priv(hsr_dev);
 
 	hsr_debugfs_term(hsr);
 
 	rtnl_lock();
-	hsr_for_each_port(hsr, port)
+	list_for_each_entry_safe(port, tmp, &hsr->ports, port_list)
 		hsr_del_port(port);
 	rtnl_unlock();
 
@@ -428,6 +429,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 {
 	struct hsr_priv *hsr;
 	struct hsr_port *port;
+	struct hsr_port *tmp;
 	int res;
 
 	hsr = netdev_priv(hsr_dev);
@@ -492,7 +494,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	return 0;
 
 fail:
-	hsr_for_each_port(hsr, port)
+	list_for_each_entry_safe(port, tmp, &hsr->ports, port_list)
 		hsr_del_port(port);
 err_add_port:
 	hsr_del_node(&hsr->self_node_db);

commit 3271273388fb14a4e8c582a8c7eaf5ef958291b1
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Mon Apr 15 11:36:02 2019 -0400

    net: hsr: fix debugfs path to support multiple interfaces
    
    Fix the path of hsr debugfs root directory to use the net device
    name so that it can work with multiple interfaces. While at it,
    also fix some typos.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 58cf500ebf94..15c72065df79 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -485,7 +485,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 		goto fail;
 
 	mod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));
-	res = hsr_debugfs_init(hsr);
+	res = hsr_debugfs_init(hsr, hsr_dev);
 	if (res)
 		goto fail;
 

commit 9c5f8a19b2de2860d4b7764204c52832ac0f4440
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Mon Apr 15 11:36:01 2019 -0400

    net: hsr: fix naming of file and functions
    
    Fix the file name and functions to match with existing implementation.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index b47a621e3f4e..58cf500ebf94 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -354,7 +354,7 @@ static void hsr_dev_destroy(struct net_device *hsr_dev)
 
 	hsr = netdev_priv(hsr_dev);
 
-	hsr_prp_debugfs_term(hsr);
+	hsr_debugfs_term(hsr);
 
 	rtnl_lock();
 	hsr_for_each_port(hsr, port)
@@ -485,7 +485,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 		goto fail;
 
 	mod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));
-	res = hsr_prp_debugfs_init(hsr);
+	res = hsr_debugfs_init(hsr);
 	if (res)
 		goto fail;
 

commit fc4ecaeebd26c77d463c898d9dd3edee234e371c
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:35 2019 -0400

    net: hsr: add debugfs support for display node list
    
    This adds a debugfs interface to allow display the nodes learned
    by the hsr master.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index bb7bf2002040..b47a621e3f4e 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -354,6 +354,8 @@ static void hsr_dev_destroy(struct net_device *hsr_dev)
 
 	hsr = netdev_priv(hsr_dev);
 
+	hsr_prp_debugfs_term(hsr);
+
 	rtnl_lock();
 	hsr_for_each_port(hsr, port)
 		hsr_del_port(port);
@@ -483,6 +485,9 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 		goto fail;
 
 	mod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));
+	res = hsr_prp_debugfs_init(hsr);
+	if (res)
+		goto fail;
 
 	return 0;
 

commit 0e7623bdf34fff6587f96c27132aebe8c585631d
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:34 2019 -0400

    net: hsr: convert to SPDX identifier
    
    Use SPDX-License-Identifier instead of a verbose license text.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 99142226622c..bb7bf2002040 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -1,9 +1,5 @@
+// SPDX-License-Identifier: GPL-2.0
 /* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
  *
  * Author(s):
  *	2011-2014 Arvid Brodin, arvid.brodin@alten.se

commit b1b4aa914080286aa82d4e629d1a646738f2f94c
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:32 2019 -0400

    net: hsr: remove camel case usage in the code
    
    Current driver code uses camel case in many places. This is
    seen when ran checkpatch.pl -f on files under net/hsr. This
    patch fixes the code to remove camel case usage.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 245fc531d39f..99142226622c 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -243,7 +243,7 @@ static const struct header_ops hsr_header_ops = {
 };
 
 static void send_hsr_supervision_frame(struct hsr_port *master,
-				       u8 type, u8 hsrVer)
+				       u8 type, u8 hsr_ver)
 {
 	struct sk_buff *skb;
 	int hlen, tlen;
@@ -264,28 +264,28 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 	skb_reserve(skb, hlen);
 
 	skb->dev = master->dev;
-	skb->protocol = htons(hsrVer ? ETH_P_HSR : ETH_P_PRP);
+	skb->protocol = htons(hsr_ver ? ETH_P_HSR : ETH_P_PRP);
 	skb->priority = TC_PRIO_CONTROL;
 
-	if (dev_hard_header(skb, skb->dev, (hsrVer ? ETH_P_HSR : ETH_P_PRP),
+	if (dev_hard_header(skb, skb->dev, (hsr_ver ? ETH_P_HSR : ETH_P_PRP),
 			    master->hsr->sup_multicast_addr,
 			    skb->dev->dev_addr, skb->len) <= 0)
 		goto out;
 	skb_reset_mac_header(skb);
 
-	if (hsrVer > 0) {
+	if (hsr_ver > 0) {
 		hsr_tag = skb_put(skb, sizeof(struct hsr_tag));
 		hsr_tag->encap_proto = htons(ETH_P_PRP);
 		set_hsr_tag_LSDU_size(hsr_tag, HSR_V1_SUP_LSDUSIZE);
 	}
 
 	hsr_stag = skb_put(skb, sizeof(struct hsr_sup_tag));
-	set_hsr_stag_path(hsr_stag, (hsrVer ? 0x0 : 0xf));
-	set_hsr_stag_HSR_Ver(hsr_stag, hsrVer);
+	set_hsr_stag_path(hsr_stag, (hsr_ver ? 0x0 : 0xf));
+	set_hsr_stag_HSR_ver(hsr_stag, hsr_ver);
 
 	/* From HSRv1 on we have separate supervision sequence numbers. */
 	spin_lock_irqsave(&master->hsr->seqnr_lock, irqflags);
-	if (hsrVer > 0) {
+	if (hsr_ver > 0) {
 		hsr_stag->sequence_nr = htons(master->hsr->sup_sequence_nr);
 		hsr_tag->sequence_nr = htons(master->hsr->sequence_nr);
 		master->hsr->sup_sequence_nr++;
@@ -296,13 +296,14 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 	}
 	spin_unlock_irqrestore(&master->hsr->seqnr_lock, irqflags);
 
-	hsr_stag->HSR_TLV_Type = type;
+	hsr_stag->HSR_TLV_type = type;
 	/* TODO: Why 12 in HSRv0? */
-	hsr_stag->HSR_TLV_Length = hsrVer ? sizeof(struct hsr_sup_payload) : 12;
+	hsr_stag->HSR_TLV_length =
+				hsr_ver ? sizeof(struct hsr_sup_payload) : 12;
 
 	/* Payload: MacAddressA */
 	hsr_sp = skb_put(skb, sizeof(struct hsr_sup_payload));
-	ether_addr_copy(hsr_sp->MacAddressA, master->dev->dev_addr);
+	ether_addr_copy(hsr_sp->macaddress_A, master->dev->dev_addr);
 
 	if (skb_put_padto(skb, ETH_ZLEN + HSR_HLEN))
 		return;
@@ -328,15 +329,15 @@ static void hsr_announce(struct timer_list *t)
 	rcu_read_lock();
 	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 
-	if (hsr->announce_count < 3 && hsr->protVersion == 0) {
+	if (hsr->announce_count < 3 && hsr->prot_version == 0) {
 		send_hsr_supervision_frame(master, HSR_TLV_ANNOUNCE,
-					   hsr->protVersion);
+					   hsr->prot_version);
 		hsr->announce_count++;
 
 		interval = msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
 	} else {
 		send_hsr_supervision_frame(master, HSR_TLV_LIFE_CHECK,
-					   hsr->protVersion);
+					   hsr->prot_version);
 
 		interval = msecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);
 	}
@@ -455,7 +456,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	ether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);
 	hsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
 
-	hsr->protVersion = protocol_version;
+	hsr->prot_version = protocol_version;
 
 	/* FIXME: should I modify the value of these?
 	 *

commit 05ca6e644dc9b733379009137ba4cc7afce2256d
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:28 2019 -0400

    net: hsr: fix NULL checks in the code
    
    This patch replaces all instance of NULL checks such as
        if (foo == NULL) with if (!foo)
    Also
        if (foo != NULL) with if (foo)
    
    This is seen when ran checkpatch.pl -f on files under net/hsr
    and suggestion is to replace as above.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 567c890f08a5..245fc531d39f 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -258,7 +258,7 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 			    sizeof(struct hsr_sup_tag) +
 			    sizeof(struct hsr_sup_payload) + hlen + tlen);
 
-	if (skb == NULL)
+	if (!skb)
 		return;
 
 	skb_reserve(skb, hlen);

commit 0525fc069f03dfd871752eb7afc85075444c8b28
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:27 2019 -0400

    net: hsr: fix lines that ends with a '('
    
    This patch fixes function calls that ends with '(' in a line.
    This is seen when ran checkpatch.pl -f option on files under
    net/hsr.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 0aea1bd09526..567c890f08a5 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -254,10 +254,9 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 
 	hlen = LL_RESERVED_SPACE(master->dev);
 	tlen = master->dev->needed_tailroom;
-	skb = dev_alloc_skb(
-			sizeof(struct hsr_tag) +
-			sizeof(struct hsr_sup_tag) +
-			sizeof(struct hsr_sup_payload) + hlen + tlen);
+	skb = dev_alloc_skb(sizeof(struct hsr_tag) +
+			    sizeof(struct hsr_sup_tag) +
+			    sizeof(struct hsr_sup_payload) + hlen + tlen);
 
 	if (skb == NULL)
 		return;

commit 4fe25bd8c3e74519e3a0682b001d248fdf23838b
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:26 2019 -0400

    net: hsr: fix alignment issues in the code for functions
    
    This patch fixes alignment issues in code for functions. This is
    seen when ran checkpatch.pl -f option on files under net/hsr.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index cf5c3951d35a..0aea1bd09526 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -243,7 +243,7 @@ static const struct header_ops hsr_header_ops = {
 };
 
 static void send_hsr_supervision_frame(struct hsr_port *master,
-		u8 type, u8 hsrVer)
+				       u8 type, u8 hsrVer)
 {
 	struct sk_buff *skb;
 	int hlen, tlen;
@@ -331,13 +331,13 @@ static void hsr_announce(struct timer_list *t)
 
 	if (hsr->announce_count < 3 && hsr->protVersion == 0) {
 		send_hsr_supervision_frame(master, HSR_TLV_ANNOUNCE,
-				hsr->protVersion);
+					   hsr->protVersion);
 		hsr->announce_count++;
 
 		interval = msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
 	} else {
 		send_hsr_supervision_frame(master, HSR_TLV_LIFE_CHECK,
-				hsr->protVersion);
+					   hsr->protVersion);
 
 		interval = msecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);
 	}

commit 5670342ced28b87f598d97e49d27bd99b38c1665
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:25 2019 -0400

    net: hsr: remove unnecessary paranthesis from the code
    
    This patch fixes unnecessary paranthesis from the code. This is
    seen when ran checkpatch.pl -f option on files under net/hsr.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 34b6d6e8020f..cf5c3951d35a 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -67,7 +67,7 @@ static bool hsr_check_carrier(struct hsr_port *master)
 
 	rcu_read_lock();
 	hsr_for_each_port(master->hsr, port)
-		if ((port->type != HSR_PT_MASTER) && is_slave_up(port->dev)) {
+		if (port->type != HSR_PT_MASTER && is_slave_up(port->dev)) {
 			has_carrier = true;
 			break;
 		}
@@ -88,15 +88,14 @@ static void hsr_check_announce(struct net_device *hsr_dev,
 
 	hsr = netdev_priv(hsr_dev);
 
-	if ((hsr_dev->operstate == IF_OPER_UP)
-			&& (old_operstate != IF_OPER_UP)) {
+	if (hsr_dev->operstate == IF_OPER_UP && old_operstate != IF_OPER_UP) {
 		/* Went up */
 		hsr->announce_count = 0;
 		mod_timer(&hsr->announce_timer,
 			  jiffies + msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL));
 	}
 
-	if ((hsr_dev->operstate != IF_OPER_UP) && (old_operstate == IF_OPER_UP))
+	if (hsr_dev->operstate != IF_OPER_UP && old_operstate == IF_OPER_UP)
 		/* Went down */
 		del_timer(&hsr->announce_timer);
 }

commit d4730775ed4ba91615f462415ab66f49431ee794
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:24 2019 -0400

    net: hsr: fix multiple blank lines in the code
    
    This patch fixes multiple blank lines in the code. This is seen
    when ran checkpatch.pl -f option for files under net/hsr
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index a97bf326b231..34b6d6e8020f 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -23,7 +23,6 @@
 #include "hsr_main.h"
 #include "hsr_forward.h"
 
-
 static bool is_admin_up(struct net_device *dev)
 {
 	return dev && (dev->flags & IFF_UP);
@@ -82,7 +81,6 @@ static bool hsr_check_carrier(struct hsr_port *master)
 	return has_carrier;
 }
 
-
 static void hsr_check_announce(struct net_device *hsr_dev,
 			       unsigned char old_operstate)
 {
@@ -136,7 +134,6 @@ int hsr_get_max_mtu(struct hsr_priv *hsr)
 	return mtu_max - HSR_HLEN;
 }
 
-
 static int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct hsr_priv *hsr;
@@ -191,14 +188,12 @@ static int hsr_dev_open(struct net_device *dev)
 	return 0;
 }
 
-
 static int hsr_dev_close(struct net_device *dev)
 {
 	/* Nothing to do here. */
 	return 0;
 }
 
-
 static netdev_features_t hsr_features_recompute(struct hsr_priv *hsr,
 						netdev_features_t features)
 {
@@ -231,7 +226,6 @@ static netdev_features_t hsr_fix_features(struct net_device *dev,
 	return hsr_features_recompute(hsr, features);
 }
 
-
 static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct hsr_priv *hsr = netdev_priv(dev);
@@ -244,7 +238,6 @@ static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 	return NETDEV_TX_OK;
 }
 
-
 static const struct header_ops hsr_header_ops = {
 	.create	 = eth_header,
 	.parse	 = eth_header_parse,
@@ -324,7 +317,6 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 	kfree_skb(skb);
 }
 
-
 /* Announce (supervision frame) timer function
  */
 static void hsr_announce(struct timer_list *t)
@@ -357,7 +349,6 @@ static void hsr_announce(struct timer_list *t)
 	rcu_read_unlock();
 }
 
-
 /* According to comments in the declaration of struct net_device, this function
  * is "Called from unregister, can be used to call free_netdev". Ok then...
  */
@@ -423,7 +414,6 @@ void hsr_dev_setup(struct net_device *dev)
 	dev->features |= NETIF_F_NETNS_LOCAL;
 }
 
-
 /* Return true if dev is a HSR master; return false otherwise.
  */
 inline bool is_hsr_master(struct net_device *dev)

commit 1e027960edfaa6a43f9ca31081729b716598112b
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Mar 7 09:36:33 2019 -0800

    net/hsr: fix possible crash in add_timer()
    
    syzbot found another add_timer() issue, this time in net/hsr [1]
    
    Let's use mod_timer() which is safe.
    
    [1]
    kernel BUG at kernel/time/timer.c:1136!
    invalid opcode: 0000 [#1] PREEMPT SMP KASAN
    CPU: 0 PID: 15909 Comm: syz-executor.3 Not tainted 5.0.0+ #97
    Hardware name: Google Google Compute Engine/Google Compute Engine, BIOS Google 01/01/2011
    kobject: 'loop2' (00000000f5629718): kobject_uevent_env
    RIP: 0010:add_timer kernel/time/timer.c:1136 [inline]
    RIP: 0010:add_timer+0x654/0xbe0 kernel/time/timer.c:1134
    Code: 0f 94 c5 31 ff 44 89 ee e8 09 61 0f 00 45 84 ed 0f 84 77 fd ff ff e8 bb 5f 0f 00 e8 07 10 a0 ff e9 68 fd ff ff e8 ac 5f 0f 00 <0f> 0b e8 a5 5f 0f 00 0f 0b e8 9e 5f 0f 00 4c 89 b5 58 ff ff ff e9
    RSP: 0018:ffff8880656eeca0 EFLAGS: 00010246
    kobject: 'loop2' (00000000f5629718): fill_kobj_path: path = '/devices/virtual/block/loop2'
    RAX: 0000000000040000 RBX: 1ffff1100caddd9a RCX: ffffc9000c436000
    RDX: 0000000000040000 RSI: ffffffff816056c4 RDI: ffff88806a2f6cc8
    RBP: ffff8880656eed58 R08: ffff888067f4a300 R09: ffff888067f4abc8
    R10: 0000000000000000 R11: 0000000000000000 R12: ffff88806a2f6cc0
    R13: dffffc0000000000 R14: 0000000000000001 R15: ffff8880656eed30
    FS:  00007fc2019bf700(0000) GS:ffff8880ae800000(0000) knlGS:0000000000000000
    CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    CR2: 0000000000738000 CR3: 0000000067e8e000 CR4: 00000000001406f0
    DR0: 0000000000000000 DR1: 0000000000000000 DR2: 0000000000000000
    DR3: 0000000000000000 DR6: 00000000fffe0ff0 DR7: 0000000000000400
    Call Trace:
     hsr_check_announce net/hsr/hsr_device.c:99 [inline]
     hsr_check_carrier_and_operstate+0x567/0x6f0 net/hsr/hsr_device.c:120
     hsr_netdev_notify+0x297/0xa00 net/hsr/hsr_main.c:51
     notifier_call_chain+0xc7/0x240 kernel/notifier.c:93
     __raw_notifier_call_chain kernel/notifier.c:394 [inline]
     raw_notifier_call_chain+0x2e/0x40 kernel/notifier.c:401
     call_netdevice_notifiers_info+0x3f/0x90 net/core/dev.c:1739
     call_netdevice_notifiers_extack net/core/dev.c:1751 [inline]
     call_netdevice_notifiers net/core/dev.c:1765 [inline]
     dev_open net/core/dev.c:1436 [inline]
     dev_open+0x143/0x160 net/core/dev.c:1424
     team_port_add drivers/net/team/team.c:1203 [inline]
     team_add_slave+0xa07/0x15d0 drivers/net/team/team.c:1933
     do_set_master net/core/rtnetlink.c:2358 [inline]
     do_set_master+0x1d4/0x230 net/core/rtnetlink.c:2332
     do_setlink+0x966/0x3510 net/core/rtnetlink.c:2493
     rtnl_setlink+0x271/0x3b0 net/core/rtnetlink.c:2747
     rtnetlink_rcv_msg+0x465/0xb00 net/core/rtnetlink.c:5192
     netlink_rcv_skb+0x17a/0x460 net/netlink/af_netlink.c:2485
     rtnetlink_rcv+0x1d/0x30 net/core/rtnetlink.c:5210
     netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]
     netlink_unicast+0x536/0x720 net/netlink/af_netlink.c:1336
     netlink_sendmsg+0x8ae/0xd70 net/netlink/af_netlink.c:1925
     sock_sendmsg_nosec net/socket.c:622 [inline]
     sock_sendmsg+0xdd/0x130 net/socket.c:632
     sock_write_iter+0x27c/0x3e0 net/socket.c:923
     call_write_iter include/linux/fs.h:1869 [inline]
     do_iter_readv_writev+0x5e0/0x8e0 fs/read_write.c:680
     do_iter_write fs/read_write.c:956 [inline]
     do_iter_write+0x184/0x610 fs/read_write.c:937
     vfs_writev+0x1b3/0x2f0 fs/read_write.c:1001
     do_writev+0xf6/0x290 fs/read_write.c:1036
     __do_sys_writev fs/read_write.c:1109 [inline]
     __se_sys_writev fs/read_write.c:1106 [inline]
     __x64_sys_writev+0x75/0xb0 fs/read_write.c:1106
     do_syscall_64+0x103/0x610 arch/x86/entry/common.c:290
     entry_SYSCALL_64_after_hwframe+0x49/0xbe
    RIP: 0033:0x457f29
    Code: ad b8 fb ff c3 66 2e 0f 1f 84 00 00 00 00 00 66 90 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 <48> 3d 01 f0 ff ff 0f 83 7b b8 fb ff c3 66 2e 0f 1f 84 00 00 00 00
    RSP: 002b:00007fc2019bec78 EFLAGS: 00000246 ORIG_RAX: 0000000000000014
    RAX: ffffffffffffffda RBX: 0000000000000003 RCX: 0000000000457f29
    RDX: 0000000000000001 RSI: 00000000200000c0 RDI: 0000000000000003
    RBP: 000000000073bf00 R08: 0000000000000000 R09: 0000000000000000
    R10: 0000000000000000 R11: 0000000000000246 R12: 00007fc2019bf6d4
    R13: 00000000004c4a60 R14: 00000000004dd218 R15: 00000000ffffffff
    
    Fixes: f421436a591d ("net/hsr: Add support for the High-availability Seamless Redundancy protocol (HSRv0)")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Cc: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index c4676bacb8db..a97bf326b231 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -94,9 +94,8 @@ static void hsr_check_announce(struct net_device *hsr_dev,
 			&& (old_operstate != IF_OPER_UP)) {
 		/* Went up */
 		hsr->announce_count = 0;
-		hsr->announce_timer.expires = jiffies +
-				msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
-		add_timer(&hsr->announce_timer);
+		mod_timer(&hsr->announce_timer,
+			  jiffies + msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL));
 	}
 
 	if ((hsr_dev->operstate != IF_OPER_UP) && (old_operstate == IF_OPER_UP))
@@ -332,6 +331,7 @@ static void hsr_announce(struct timer_list *t)
 {
 	struct hsr_priv *hsr;
 	struct hsr_port *master;
+	unsigned long interval;
 
 	hsr = from_timer(hsr, t, announce_timer);
 
@@ -343,18 +343,16 @@ static void hsr_announce(struct timer_list *t)
 				hsr->protVersion);
 		hsr->announce_count++;
 
-		hsr->announce_timer.expires = jiffies +
-				msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
+		interval = msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
 	} else {
 		send_hsr_supervision_frame(master, HSR_TLV_LIFE_CHECK,
 				hsr->protVersion);
 
-		hsr->announce_timer.expires = jiffies +
-				msecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);
+		interval = msecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);
 	}
 
 	if (is_admin_up(master->dev))
-		add_timer(&hsr->announce_timer);
+		mod_timer(&hsr->announce_timer, jiffies + interval);
 
 	rcu_read_unlock();
 }

commit 6caabe7f197d3466d238f70915d65301f1716626
Author: Mao Wenan <maowenan@huawei.com>
Date:   Wed Mar 6 22:45:01 2019 +0800

    net: hsr: fix memory leak in hsr_dev_finalize()
    
    If hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER) failed to
    add port, it directly returns res and forgets to free the node
    that allocated in hsr_create_self_node(), and forgets to delete
    the node->mac_list linked in hsr->self_node_db.
    
    BUG: memory leak
    unreferenced object 0xffff8881cfa0c780 (size 64):
      comm "syz-executor.0", pid 2077, jiffies 4294717969 (age 2415.377s)
      hex dump (first 32 bytes):
        e0 c7 a0 cf 81 88 ff ff 00 02 00 00 00 00 ad de  ................
        00 e6 49 cd 81 88 ff ff c0 9b 87 d0 81 88 ff ff  ..I.............
      backtrace:
        [<00000000e2ff5070>] hsr_dev_finalize+0x736/0x960 [hsr]
        [<000000003ed2e597>] hsr_newlink+0x2b2/0x3e0 [hsr]
        [<000000003fa8c6b6>] __rtnl_newlink+0xf1f/0x1600 net/core/rtnetlink.c:3182
        [<000000001247a7ad>] rtnl_newlink+0x66/0x90 net/core/rtnetlink.c:3240
        [<00000000e7d1b61d>] rtnetlink_rcv_msg+0x54e/0xb90 net/core/rtnetlink.c:5130
        [<000000005556bd3a>] netlink_rcv_skb+0x129/0x340 net/netlink/af_netlink.c:2477
        [<00000000741d5ee6>] netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]
        [<00000000741d5ee6>] netlink_unicast+0x49a/0x650 net/netlink/af_netlink.c:1336
        [<000000009d56f9b7>] netlink_sendmsg+0x88b/0xdf0 net/netlink/af_netlink.c:1917
        [<0000000046b35c59>] sock_sendmsg_nosec net/socket.c:621 [inline]
        [<0000000046b35c59>] sock_sendmsg+0xc3/0x100 net/socket.c:631
        [<00000000d208adc9>] __sys_sendto+0x33e/0x560 net/socket.c:1786
        [<00000000b582837a>] __do_sys_sendto net/socket.c:1798 [inline]
        [<00000000b582837a>] __se_sys_sendto net/socket.c:1794 [inline]
        [<00000000b582837a>] __x64_sys_sendto+0xdd/0x1b0 net/socket.c:1794
        [<00000000c866801d>] do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
        [<00000000fea382d9>] entry_SYSCALL_64_after_hwframe+0x49/0xbe
        [<00000000e01dacb3>] 0xffffffffffffffff
    
    Fixes: c5a759117210 ("net/hsr: Use list_head (and rcu) instead of array for slave devices.")
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Mao Wenan <maowenan@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index b8cd43c9ed5b..c4676bacb8db 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -486,7 +486,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 
 	res = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);
 	if (res)
-		return res;
+		goto err_add_port;
 
 	res = register_netdevice(hsr_dev);
 	if (res)
@@ -506,6 +506,8 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 fail:
 	hsr_for_each_port(hsr, port)
 		hsr_del_port(port);
+err_add_port:
+	hsr_del_node(&hsr->self_node_db);
 
 	return res;
 }

commit dda436b7accffd5313e8fd8338f724376c6fcda2
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 01:46:16 2017 -0700

    net: hsr: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Arvid Brodin <arvid.brodin@alten.se>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 172d8309f89e..b8cd43c9ed5b 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -328,12 +328,12 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 
 /* Announce (supervision frame) timer function
  */
-static void hsr_announce(unsigned long data)
+static void hsr_announce(struct timer_list *t)
 {
 	struct hsr_priv *hsr;
 	struct hsr_port *master;
 
-	hsr = (struct hsr_priv *) data;
+	hsr = from_timer(hsr, t, announce_timer);
 
 	rcu_read_lock();
 	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
@@ -463,9 +463,8 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	hsr->sequence_nr = HSR_SEQNR_START;
 	hsr->sup_sequence_nr = HSR_SUP_SEQNR_START;
 
-	setup_timer(&hsr->announce_timer, hsr_announce, (unsigned long)hsr);
-
-	setup_timer(&hsr->prune_timer, hsr_prune_nodes, (unsigned long)hsr);
+	timer_setup(&hsr->announce_timer, hsr_announce, 0);
+	timer_setup(&hsr->prune_timer, hsr_prune_nodes, 0);
 
 	ether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);
 	hsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;

commit 414e7d76af6d3ec2dd4e9079927dbe0e2e4ca914
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Aug 21 12:59:10 2017 -0700

    net/hsr: Check skb_put_padto() return value
    
    skb_put_padto() will free the sk_buff passed as reference in case of
    errors, but we still need to check its return value and decide what to
    do.
    
    Detected by CoverityScan, CID#1416688 ("CHECKED_RETURN")
    
    Fixes: ee1c27977284 ("net/hsr: Added support for HSR v1")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 4e7bdb213cd0..172d8309f89e 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -314,7 +314,8 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 	hsr_sp = skb_put(skb, sizeof(struct hsr_sup_payload));
 	ether_addr_copy(hsr_sp->MacAddressA, master->dev->dev_addr);
 
-	skb_put_padto(skb, ETH_ZLEN + HSR_HLEN);
+	if (skb_put_padto(skb, ETH_ZLEN + HSR_HLEN))
+		return;
 
 	hsr_forward_skb(skb, master);
 	return;

commit b952f4dff2751252db073c27c0f8a16a416a2ddc
Author: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
Date:   Sun Jun 18 22:52:04 2017 +0800

    net: manual clean code which call skb_put_[data:zero]
    
    Signed-off-by: yuan linyu <Linyu.Yuan@alcatel-sbell.com.cn>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 0a0a392dc2bd..4e7bdb213cd0 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -284,12 +284,12 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 	skb_reset_mac_header(skb);
 
 	if (hsrVer > 0) {
-		hsr_tag = (typeof(hsr_tag)) skb_put(skb, sizeof(struct hsr_tag));
+		hsr_tag = skb_put(skb, sizeof(struct hsr_tag));
 		hsr_tag->encap_proto = htons(ETH_P_PRP);
 		set_hsr_tag_LSDU_size(hsr_tag, HSR_V1_SUP_LSDUSIZE);
 	}
 
-	hsr_stag = (typeof(hsr_stag)) skb_put(skb, sizeof(struct hsr_sup_tag));
+	hsr_stag = skb_put(skb, sizeof(struct hsr_sup_tag));
 	set_hsr_stag_path(hsr_stag, (hsrVer ? 0x0 : 0xf));
 	set_hsr_stag_HSR_Ver(hsr_stag, hsrVer);
 
@@ -311,7 +311,7 @@ static void send_hsr_supervision_frame(struct hsr_port *master,
 	hsr_stag->HSR_TLV_Length = hsrVer ? sizeof(struct hsr_sup_payload) : 12;
 
 	/* Payload: MacAddressA */
-	hsr_sp = (typeof(hsr_sp)) skb_put(skb, sizeof(struct hsr_sup_payload));
+	hsr_sp = skb_put(skb, sizeof(struct hsr_sup_payload));
 	ether_addr_copy(hsr_sp->MacAddressA, master->dev->dev_addr);
 
 	skb_put_padto(skb, ETH_ZLEN + HSR_HLEN);

commit cf124db566e6b036b8bcbe8decbed740bdfac8c6
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 8 12:52:56 2017 -0400

    net: Fix inconsistent teardown and release of private netdev state.
    
    Network devices can allocate reasources and private memory using
    netdev_ops->ndo_init().  However, the release of these resources
    can occur in one of two different places.
    
    Either netdev_ops->ndo_uninit() or netdev->destructor().
    
    The decision of which operation frees the resources depends upon
    whether it is necessary for all netdev refs to be released before it
    is safe to perform the freeing.
    
    netdev_ops->ndo_uninit() presumably can occur right after the
    NETDEV_UNREGISTER notifier completes and the unicast and multicast
    address lists are flushed.
    
    netdev->destructor(), on the other hand, does not run until the
    netdev references all go away.
    
    Further complicating the situation is that netdev->destructor()
    almost universally does also a free_netdev().
    
    This creates a problem for the logic in register_netdevice().
    Because all callers of register_netdevice() manage the freeing
    of the netdev, and invoke free_netdev(dev) if register_netdevice()
    fails.
    
    If netdev_ops->ndo_init() succeeds, but something else fails inside
    of register_netdevice(), it does call ndo_ops->ndo_uninit().  But
    it is not able to invoke netdev->destructor().
    
    This is because netdev->destructor() will do a free_netdev() and
    then the caller of register_netdevice() will do the same.
    
    However, this means that the resources that would normally be released
    by netdev->destructor() will not be.
    
    Over the years drivers have added local hacks to deal with this, by
    invoking their destructor parts by hand when register_netdevice()
    fails.
    
    Many drivers do not try to deal with this, and instead we have leaks.
    
    Let's close this hole by formalizing the distinction between what
    private things need to be freed up by netdev->destructor() and whether
    the driver needs unregister_netdevice() to perform the free_netdev().
    
    netdev->priv_destructor() performs all actions to free up the private
    resources that used to be freed by netdev->destructor(), except for
    free_netdev().
    
    netdev->needs_free_netdev is a boolean that indicates whether
    free_netdev() should be done at the end of unregister_netdevice().
    
    Now, register_netdevice() can sanely release all resources after
    ndo_ops->ndo_init() succeeds, by invoking both ndo_ops->ndo_uninit()
    and netdev->priv_destructor().
    
    And at the end of unregister_netdevice(), we invoke
    netdev->priv_destructor() and optionally call free_netdev().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index c73160fb11e7..0a0a392dc2bd 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -378,7 +378,6 @@ static void hsr_dev_destroy(struct net_device *hsr_dev)
 	del_timer_sync(&hsr->announce_timer);
 
 	synchronize_rcu();
-	free_netdev(hsr_dev);
 }
 
 static const struct net_device_ops hsr_device_ops = {
@@ -404,7 +403,8 @@ void hsr_dev_setup(struct net_device *dev)
 	SET_NETDEV_DEVTYPE(dev, &hsr_type);
 	dev->priv_flags |= IFF_NO_QUEUE;
 
-	dev->destructor = hsr_dev_destroy;
+	dev->needs_free_netdev = true;
+	dev->priv_destructor = hsr_dev_destroy;
 
 	dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
 			   NETIF_F_GSO_MASK | NETIF_F_HW_CSUM |

commit d4af4c0ad0a4d070ef756010a2a10d96ff53d73d
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Tue Feb 21 14:04:59 2017 +0100

    net/hsr: use eth_hw_addr_random()
    
    Use eth_hw_addr_random() to set a random MAC address in order to make sure
    dev->addr_assign_type will be properly set to NET_ADDR_RANDOM.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index fc65b145f6e7..c73160fb11e7 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -395,7 +395,7 @@ static struct device_type hsr_type = {
 
 void hsr_dev_setup(struct net_device *dev)
 {
-	random_ether_addr(dev->dev_addr);
+	eth_hw_addr_random(dev);
 
 	ether_setup(dev);
 	dev->min_mtu = 0;

commit b3e3893e1253692c3d2b8e8ebd5a26183ed30443
Author: Jarod Wilson <jarod@redhat.com>
Date:   Thu Oct 20 13:55:22 2016 -0400

    net: use core MTU range checking in misc drivers
    
    firewire-net:
    - set min/max_mtu
    - remove fwnet_change_mtu
    
    nes:
    - set max_mtu
    - clean up nes_netdev_change_mtu
    
    xpnet:
    - set min/max_mtu
    - remove xpnet_dev_change_mtu
    
    hippi:
    - set min/max_mtu
    - remove hippi_change_mtu
    
    batman-adv:
    - set max_mtu
    - remove batadv_interface_change_mtu
    - initialization is a little async, not 100% certain that max_mtu is set
      in the optimal place, don't have hardware to test with
    
    rionet:
    - set min/max_mtu
    - remove rionet_change_mtu
    
    slip:
    - set min/max_mtu
    - streamline sl_change_mtu
    
    um/net_kern:
    - remove pointless ndo_change_mtu
    
    hsi/clients/ssi_protocol:
    - use core MTU range checking
    - remove now redundant ssip_pn_set_mtu
    
    ipoib:
    - set a default max MTU value
    - Note: ipoib's actual max MTU can vary, depending on if the device is in
      connected mode or not, so we'll just set the max_mtu value to the max
      possible, and let the ndo_change_mtu function continue to validate any new
      MTU change requests with checks for CM or not. Note that ipoib has no
      min_mtu set, and thus, the network core's mtu > 0 check is the only lower
      bounds here.
    
    mptlan:
    - use net core MTU range checking
    - remove now redundant mpt_lan_change_mtu
    
    fddi:
    - min_mtu = 21, max_mtu = 4470
    - remove now redundant fddi_change_mtu (including export)
    
    fjes:
    - min_mtu = 8192, max_mtu = 65536
    - The max_mtu value is actually one over IP_MAX_MTU here, but the idea is to
      get past the core net MTU range checks so fjes_change_mtu can validate a
      new MTU against what it supports (see fjes_support_mtu in fjes_hw.c)
    
    hsr:
    - min_mtu = 0 (calls ether_setup, max_mtu is 1500)
    
    f_phonet:
    - min_mtu = 6, max_mtu = 65541
    
    u_ether:
    - min_mtu = 14, max_mtu = 15412
    
    phonet/pep-gprs:
    - min_mtu = 576, max_mtu = 65530
    - remove redundant gprs_set_mtu
    
    CC: netdev@vger.kernel.org
    CC: linux-rdma@vger.kernel.org
    CC: Stefan Richter <stefanr@s5r6.in-berlin.de>
    CC: Faisal Latif <faisal.latif@intel.com>
    CC: linux-rdma@vger.kernel.org
    CC: Cliff Whickman <cpw@sgi.com>
    CC: Robin Holt <robinmholt@gmail.com>
    CC: Jes Sorensen <jes@trained-monkey.org>
    CC: Marek Lindner <mareklindner@neomailbox.ch>
    CC: Simon Wunderlich <sw@simonwunderlich.de>
    CC: Antonio Quartulli <a@unstable.cc>
    CC: Sathya Prakash <sathya.prakash@broadcom.com>
    CC: Chaitra P B <chaitra.basappa@broadcom.com>
    CC: Suganath Prabu Subramani <suganath-prabu.subramani@broadcom.com>
    CC: MPT-FusionLinux.pdl@broadcom.com
    CC: Sebastian Reichel <sre@kernel.org>
    CC: Felipe Balbi <balbi@kernel.org>
    CC: Arvid Brodin <arvid.brodin@alten.se>
    CC: Remi Denis-Courmont <courmisch@gmail.com>
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 16737cd8dae8..fc65b145f6e7 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -398,6 +398,7 @@ void hsr_dev_setup(struct net_device *dev)
 	random_ether_addr(dev->dev_addr);
 
 	ether_setup(dev);
+	dev->min_mtu = 0;
 	dev->header_ops = &hsr_header_ops;
 	dev->netdev_ops = &hsr_device_ops;
 	SET_NETDEV_DEVTYPE(dev, &hsr_type);

commit 15db6e0dc73ebdbf42c35f2f64907a5f4e154be1
Author: Muhammad Falak R Wani <falakreyaz@gmail.com>
Date:   Sun May 15 19:37:44 2016 +0530

    net/hsr: Use setup_timer and mod_timer.
    
    The function setup_timer combines the initialization of a timer with the
    initialization of the timer's function and data fields. The mulitiline
    code for timer initialization is now replaced with function setup_timer.
    
    Also, quoting the mod_timer() function comment:
    -> mod_timer() is a more efficient way to update the expire field of an
       active timer (if the timer is inactive it will be activated).
    
    Use setup_timer() and mod_timer() to setup and arm a timer, making the
    code compact and aid readablity.
    
    Signed-off-by: Muhammad Falak R Wani <falakreyaz@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 386cbce7bc51..16737cd8dae8 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -461,13 +461,9 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	hsr->sequence_nr = HSR_SEQNR_START;
 	hsr->sup_sequence_nr = HSR_SUP_SEQNR_START;
 
-	init_timer(&hsr->announce_timer);
-	hsr->announce_timer.function = hsr_announce;
-	hsr->announce_timer.data = (unsigned long) hsr;
+	setup_timer(&hsr->announce_timer, hsr_announce, (unsigned long)hsr);
 
-	init_timer(&hsr->prune_timer);
-	hsr->prune_timer.function = hsr_prune_nodes;
-	hsr->prune_timer.data = (unsigned long) hsr;
+	setup_timer(&hsr->prune_timer, hsr_prune_nodes, (unsigned long)hsr);
 
 	ether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);
 	hsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
@@ -502,8 +498,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	if (res)
 		goto fail;
 
-	hsr->prune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);
-	add_timer(&hsr->prune_timer);
+	mod_timer(&hsr->prune_timer, jiffies + msecs_to_jiffies(PRUNE_PERIOD));
 
 	return 0;
 

commit ee1c27977284907d40f7f72c2d078d709f15811f
Author: Peter Heise <mail@pheise.de>
Date:   Wed Apr 13 13:52:22 2016 +0200

    net/hsr: Added support for HSR v1
    
    This patch adds support for the newer version 1 of the HSR
    networking standard. Version 0 is still default and the new
    version has to be selected via iproute2.
    
    Main changes are in the supervision frame handling and its
    ethertype field.
    
    Signed-off-by: Peter Heise <peter.heise@airbus.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index c7d1adca30d8..386cbce7bc51 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -90,7 +90,8 @@ static void hsr_check_announce(struct net_device *hsr_dev,
 
 	hsr = netdev_priv(hsr_dev);
 
-	if ((hsr_dev->operstate == IF_OPER_UP) && (old_operstate != IF_OPER_UP)) {
+	if ((hsr_dev->operstate == IF_OPER_UP)
+			&& (old_operstate != IF_OPER_UP)) {
 		/* Went up */
 		hsr->announce_count = 0;
 		hsr->announce_timer.expires = jiffies +
@@ -250,31 +251,22 @@ static const struct header_ops hsr_header_ops = {
 	.parse	 = eth_header_parse,
 };
 
-
-/* HSR:2010 supervision frames should be padded so that the whole frame,
- * including headers and FCS, is 64 bytes (without VLAN).
- */
-static int hsr_pad(int size)
-{
-	const int min_size = ETH_ZLEN - HSR_HLEN - ETH_HLEN;
-
-	if (size >= min_size)
-		return size;
-	return min_size;
-}
-
-static void send_hsr_supervision_frame(struct hsr_port *master, u8 type)
+static void send_hsr_supervision_frame(struct hsr_port *master,
+		u8 type, u8 hsrVer)
 {
 	struct sk_buff *skb;
 	int hlen, tlen;
+	struct hsr_tag *hsr_tag;
 	struct hsr_sup_tag *hsr_stag;
 	struct hsr_sup_payload *hsr_sp;
 	unsigned long irqflags;
 
 	hlen = LL_RESERVED_SPACE(master->dev);
 	tlen = master->dev->needed_tailroom;
-	skb = alloc_skb(hsr_pad(sizeof(struct hsr_sup_payload)) + hlen + tlen,
-			GFP_ATOMIC);
+	skb = dev_alloc_skb(
+			sizeof(struct hsr_tag) +
+			sizeof(struct hsr_sup_tag) +
+			sizeof(struct hsr_sup_payload) + hlen + tlen);
 
 	if (skb == NULL)
 		return;
@@ -282,32 +274,48 @@ static void send_hsr_supervision_frame(struct hsr_port *master, u8 type)
 	skb_reserve(skb, hlen);
 
 	skb->dev = master->dev;
-	skb->protocol = htons(ETH_P_PRP);
+	skb->protocol = htons(hsrVer ? ETH_P_HSR : ETH_P_PRP);
 	skb->priority = TC_PRIO_CONTROL;
 
-	if (dev_hard_header(skb, skb->dev, ETH_P_PRP,
+	if (dev_hard_header(skb, skb->dev, (hsrVer ? ETH_P_HSR : ETH_P_PRP),
 			    master->hsr->sup_multicast_addr,
 			    skb->dev->dev_addr, skb->len) <= 0)
 		goto out;
 	skb_reset_mac_header(skb);
 
-	hsr_stag = (typeof(hsr_stag)) skb_put(skb, sizeof(*hsr_stag));
+	if (hsrVer > 0) {
+		hsr_tag = (typeof(hsr_tag)) skb_put(skb, sizeof(struct hsr_tag));
+		hsr_tag->encap_proto = htons(ETH_P_PRP);
+		set_hsr_tag_LSDU_size(hsr_tag, HSR_V1_SUP_LSDUSIZE);
+	}
 
-	set_hsr_stag_path(hsr_stag, 0xf);
-	set_hsr_stag_HSR_Ver(hsr_stag, 0);
+	hsr_stag = (typeof(hsr_stag)) skb_put(skb, sizeof(struct hsr_sup_tag));
+	set_hsr_stag_path(hsr_stag, (hsrVer ? 0x0 : 0xf));
+	set_hsr_stag_HSR_Ver(hsr_stag, hsrVer);
 
+	/* From HSRv1 on we have separate supervision sequence numbers. */
 	spin_lock_irqsave(&master->hsr->seqnr_lock, irqflags);
-	hsr_stag->sequence_nr = htons(master->hsr->sequence_nr);
-	master->hsr->sequence_nr++;
+	if (hsrVer > 0) {
+		hsr_stag->sequence_nr = htons(master->hsr->sup_sequence_nr);
+		hsr_tag->sequence_nr = htons(master->hsr->sequence_nr);
+		master->hsr->sup_sequence_nr++;
+		master->hsr->sequence_nr++;
+	} else {
+		hsr_stag->sequence_nr = htons(master->hsr->sequence_nr);
+		master->hsr->sequence_nr++;
+	}
 	spin_unlock_irqrestore(&master->hsr->seqnr_lock, irqflags);
 
 	hsr_stag->HSR_TLV_Type = type;
-	hsr_stag->HSR_TLV_Length = 12;
+	/* TODO: Why 12 in HSRv0? */
+	hsr_stag->HSR_TLV_Length = hsrVer ? sizeof(struct hsr_sup_payload) : 12;
 
 	/* Payload: MacAddressA */
-	hsr_sp = (typeof(hsr_sp)) skb_put(skb, sizeof(*hsr_sp));
+	hsr_sp = (typeof(hsr_sp)) skb_put(skb, sizeof(struct hsr_sup_payload));
 	ether_addr_copy(hsr_sp->MacAddressA, master->dev->dev_addr);
 
+	skb_put_padto(skb, ETH_ZLEN + HSR_HLEN);
+
 	hsr_forward_skb(skb, master);
 	return;
 
@@ -329,19 +337,20 @@ static void hsr_announce(unsigned long data)
 	rcu_read_lock();
 	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 
-	if (hsr->announce_count < 3) {
-		send_hsr_supervision_frame(master, HSR_TLV_ANNOUNCE);
+	if (hsr->announce_count < 3 && hsr->protVersion == 0) {
+		send_hsr_supervision_frame(master, HSR_TLV_ANNOUNCE,
+				hsr->protVersion);
 		hsr->announce_count++;
-	} else {
-		send_hsr_supervision_frame(master, HSR_TLV_LIFE_CHECK);
-	}
 
-	if (hsr->announce_count < 3)
 		hsr->announce_timer.expires = jiffies +
 				msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
-	else
+	} else {
+		send_hsr_supervision_frame(master, HSR_TLV_LIFE_CHECK,
+				hsr->protVersion);
+
 		hsr->announce_timer.expires = jiffies +
 				msecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);
+	}
 
 	if (is_admin_up(master->dev))
 		add_timer(&hsr->announce_timer);
@@ -428,7 +437,7 @@ static const unsigned char def_multicast_addr[ETH_ALEN] __aligned(2) = {
 };
 
 int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
-		     unsigned char multicast_spec)
+		     unsigned char multicast_spec, u8 protocol_version)
 {
 	struct hsr_priv *hsr;
 	struct hsr_port *port;
@@ -450,6 +459,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	spin_lock_init(&hsr->seqnr_lock);
 	/* Overflow soon to find bugs easier: */
 	hsr->sequence_nr = HSR_SEQNR_START;
+	hsr->sup_sequence_nr = HSR_SUP_SEQNR_START;
 
 	init_timer(&hsr->announce_timer);
 	hsr->announce_timer.function = hsr_announce;
@@ -462,6 +472,8 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	ether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);
 	hsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
 
+	hsr->protVersion = protocol_version;
+
 	/* FIXME: should I modify the value of these?
 	 *
 	 * - hsr_dev->flags - i.e.

commit 3d1a54e801b661fdc7a409cfc350b6ee555e00fc
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Sat Nov 21 13:34:12 2015 +0300

    net/hsr: fix a warning message
    
    WARN_ON_ONCE() takes a condition, it doesn't take an error message.  I
    have converted this to WARN() instead.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 35a9788bb3ae..c7d1adca30d8 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -312,7 +312,7 @@ static void send_hsr_supervision_frame(struct hsr_port *master, u8 type)
 	return;
 
 out:
-	WARN_ON_ONCE("HSR: Could not send supervision frame\n");
+	WARN_ONCE(1, "HSR: Could not send supervision frame\n");
 	kfree_skb(skb);
 }
 

commit 9ad09c5c05f7ce718d135ba8b55f9af733fc9b3f
Author: Phil Sutter <phil@nwl.cc>
Date:   Tue Aug 18 10:30:45 2015 +0200

    net: hsr: convert to using IFF_NO_QUEUE
    
    Signed-off-by: Phil Sutter <phil@nwl.cc>
    Cc: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 44d27469ae55..35a9788bb3ae 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -392,7 +392,7 @@ void hsr_dev_setup(struct net_device *dev)
 	dev->header_ops = &hsr_header_ops;
 	dev->netdev_ops = &hsr_device_ops;
 	SET_NETDEV_DEVTYPE(dev, &hsr_type);
-	dev->tx_queue_len = 0;
+	dev->priv_flags |= IFF_NO_QUEUE;
 
 	dev->destructor = hsr_dev_destroy;
 

commit 56b08fdcf637955d3023d769afd6cdabc526ba22
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Feb 27 21:26:03 2015 +0100

    net/hsr: Fix NULL pointer dereference and refcnt bugs when deleting a HSR interface.
    
    To repeat:
    
    $ sudo ip link del hsr0
    BUG: unable to handle kernel NULL pointer dereference at 0000000000000018
    IP: [<ffffffff8187f495>] hsr_del_port+0x15/0xa0
    etc...
    
    Bug description:
    
    As part of the hsr master device destruction, hsr_del_port() is called for each of
    the hsr ports. At each such call, the master device is updated regarding features
    and mtu. When the master device is freed before the slave interfaces, master will
    be NULL in hsr_del_port(), which led to a NULL pointer dereference.
    
    Additionally, dev_put() was called on the master device itself in hsr_del_port(),
    causing a refcnt error.
    
    A third bug in the same code path was that the rtnl lock was not taken before
    hsr_del_port() was called as part of hsr_dev_destroy().
    
    The reporter (Nicolas Dichtel) also said: "hsr_netdev_notify() supposes that the
    port will always be available when the notification is for an hsr interface. It's
    wrong. For example, netdev_wait_allrefs() may resend NETDEV_UNREGISTER.". As a
    precaution against this, a check for port == NULL was added in hsr_dev_notify().
    
    Reported-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Fixes: 51f3c605318b056a ("net/hsr: Move slave init to hsr_slave.c.")
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index a138d75751df..44d27469ae55 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -359,8 +359,11 @@ static void hsr_dev_destroy(struct net_device *hsr_dev)
 	struct hsr_port *port;
 
 	hsr = netdev_priv(hsr_dev);
+
+	rtnl_lock();
 	hsr_for_each_port(hsr, port)
 		hsr_del_port(port);
+	rtnl_unlock();
 
 	del_timer_sync(&hsr->prune_timer);
 	del_timer_sync(&hsr->announce_timer);

commit f266a683a4804dc499efc6c2206ef68efed029d0
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:41:03 2014 +0200

    net/hsr: Better frame dispatch
    
    This patch removes the separate paths for frames coming from the outside, and
    frames sent from the HSR device, and instead makes all frames go through
    hsr_forward_skb() in hsr_forward.c. This greatly improves code readability and
    also opens up the possibility for future support of the HSR Interlink device
    that is the basis for HSR RedBoxes and HSR QuadBoxes, as well as VLAN
    compatibility.
    
    Other improvements:
    * A reduction in the number of times an skb is copied on machines without
      HAVE_EFFICIENT_UNALIGNED_ACCESS, which improves throughput somewhat.
    * Headers are now created using the standard eth_header(), and using the
      standard hard_header_len.
    * Each HSR slave now gets its own private skb, so slave-specific fields can be
      correctly set.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index c2ae54924a0f..a138d75751df 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -21,6 +21,7 @@
 #include "hsr_slave.h"
 #include "hsr_framereg.h"
 #include "hsr_main.h"
+#include "hsr_forward.h"
 
 
 static bool is_admin_up(struct net_device *dev)
@@ -231,141 +232,21 @@ static netdev_features_t hsr_fix_features(struct net_device *dev,
 }
 
 
-static void hsr_fill_tag(struct hsr_ethhdr *hsr_ethhdr, struct hsr_priv *hsr)
-{
-	unsigned long irqflags;
-
-	/* IEC 62439-1:2010, p 48, says the 4-bit "path" field can take values
-	 * between 0001-1001 ("ring identifier", for regular HSR frames),
-	 * or 1111 ("HSR management", supervision frames). Unfortunately, the
-	 * spec writers forgot to explain what a "ring identifier" is, or
-	 * how it is used. So we just set this to 0001 for regular frames,
-	 * and 1111 for supervision frames.
-	 */
-	set_hsr_tag_path(&hsr_ethhdr->hsr_tag, 0x1);
-
-	/* IEC 62439-1:2010, p 12: "The link service data unit in an Ethernet
-	 * frame is the content of the frame located between the Length/Type
-	 * field and the Frame Check Sequence."
-	 *
-	 * IEC 62439-3, p 48, specifies the "original LPDU" to include the
-	 * original "LT" field (what "LT" means is not explained anywhere as
-	 * far as I can see - perhaps "Length/Type"?). So LSDU_size might
-	 * equal original length + 2.
-	 *   Also, the fact that this field is not used anywhere (might be used
-	 * by a RedBox connecting HSR and PRP nets?) means I cannot test its
-	 * correctness. Instead of guessing, I set this to 0 here, to make any
-	 * problems immediately apparent. Anyone using this driver with PRP/HSR
-	 * RedBoxes might need to fix this...
-	 */
-	set_hsr_tag_LSDU_size(&hsr_ethhdr->hsr_tag, 0);
-
-	spin_lock_irqsave(&hsr->seqnr_lock, irqflags);
-	hsr_ethhdr->hsr_tag.sequence_nr = htons(hsr->sequence_nr);
-	hsr->sequence_nr++;
-	spin_unlock_irqrestore(&hsr->seqnr_lock, irqflags);
-
-	hsr_ethhdr->hsr_tag.encap_proto = hsr_ethhdr->ethhdr.h_proto;
-
-	hsr_ethhdr->ethhdr.h_proto = htons(ETH_P_PRP);
-}
-
-static int slave_xmit(struct hsr_priv *hsr, struct sk_buff *skb,
-		      enum hsr_port_type type)
-{
-	struct hsr_port *port;
-	struct hsr_ethhdr *hsr_ethhdr;
-
-	hsr_ethhdr = (struct hsr_ethhdr *) skb->data;
-
-	rcu_read_lock();
-	port = hsr_port_get_hsr(hsr, type);
-	if (!port) {
-		rcu_read_unlock();
-		return NET_XMIT_DROP;
-	}
-	skb->dev = port->dev;
-
-	hsr_addr_subst_dest(port->hsr, &hsr_ethhdr->ethhdr, port);
-	rcu_read_unlock();
-
-	/* Address substitution (IEC62439-3 pp 26, 50): replace mac
-	 * address of outgoing frame with that of the outgoing slave's.
-	 */
-	ether_addr_copy(hsr_ethhdr->ethhdr.h_source, skb->dev->dev_addr);
-
-	return dev_queue_xmit(skb);
-}
-
 static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct hsr_priv *hsr;
+	struct hsr_priv *hsr = netdev_priv(dev);
 	struct hsr_port *master;
-	struct hsr_ethhdr *hsr_ethhdr;
-	struct sk_buff *skb2;
-	int res1, res2;
-
-	hsr = netdev_priv(dev);
-	hsr_ethhdr = (struct hsr_ethhdr *) skb->data;
-
-	if ((skb->protocol != htons(ETH_P_PRP)) ||
-	    (hsr_ethhdr->ethhdr.h_proto != htons(ETH_P_PRP))) {
-		hsr_fill_tag(hsr_ethhdr, hsr);
-		skb->protocol = htons(ETH_P_PRP);
-	}
 
-	skb2 = pskb_copy(skb, GFP_ATOMIC);
-
-	res1 = slave_xmit(hsr, skb, HSR_PT_SLAVE_A);
-	if (skb2)
-		res2 = slave_xmit(hsr, skb2, HSR_PT_SLAVE_B);
-	else
-		res2 = NET_XMIT_DROP;
-
-	rcu_read_lock();
 	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
-	if (likely(res1 == NET_XMIT_SUCCESS || res1 == NET_XMIT_CN ||
-		   res2 == NET_XMIT_SUCCESS || res2 == NET_XMIT_CN)) {
-		master->dev->stats.tx_packets++;
-		master->dev->stats.tx_bytes += skb->len;
-	} else {
-		master->dev->stats.tx_dropped++;
-	}
-	rcu_read_unlock();
+	skb->dev = master->dev;
+	hsr_forward_skb(skb, master);
 
 	return NETDEV_TX_OK;
 }
 
 
-static int hsr_header_create(struct sk_buff *skb, struct net_device *dev,
-			     unsigned short type, const void *daddr,
-			     const void *saddr, unsigned int len)
-{
-	int res;
-
-	/* Make room for the HSR tag now. We will fill it in later (in
-	 * hsr_dev_xmit)
-	 */
-	if (skb_headroom(skb) < HSR_HLEN + ETH_HLEN)
-		return -ENOBUFS;
-	skb_push(skb, HSR_HLEN);
-
-	/* To allow VLAN/HSR combos we should probably use
-	 * res = dev_hard_header(skb, dev, type, daddr, saddr, len + HSR_HLEN);
-	 * here instead. It would require other changes too, though - e.g.
-	 * separate headers for each slave etc...
-	 */
-	res = eth_header(skb, dev, type, daddr, saddr, len + HSR_HLEN);
-	if (res <= 0)
-		return res;
-	skb_reset_mac_header(skb);
-
-	return res + HSR_HLEN;
-}
-
-
 static const struct header_ops hsr_header_ops = {
-	.create	 = hsr_header_create,
+	.create	 = eth_header,
 	.parse	 = eth_header_parse,
 };
 
@@ -382,19 +263,13 @@ static int hsr_pad(int size)
 	return min_size;
 }
 
-static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
+static void send_hsr_supervision_frame(struct hsr_port *master, u8 type)
 {
-	struct hsr_priv *hsr;
-	struct hsr_port *master;
 	struct sk_buff *skb;
 	int hlen, tlen;
 	struct hsr_sup_tag *hsr_stag;
 	struct hsr_sup_payload *hsr_sp;
 	unsigned long irqflags;
-	int res;
-
-	hsr = netdev_priv(hsr_dev);
-	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 
 	hlen = LL_RESERVED_SPACE(master->dev);
 	tlen = master->dev->needed_tailroom;
@@ -410,33 +285,30 @@ static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
 	skb->protocol = htons(ETH_P_PRP);
 	skb->priority = TC_PRIO_CONTROL;
 
-	res = dev_hard_header(skb, skb->dev, ETH_P_PRP,
-			      hsr->sup_multicast_addr,
-			      skb->dev->dev_addr, skb->len);
-	if (res <= 0)
+	if (dev_hard_header(skb, skb->dev, ETH_P_PRP,
+			    master->hsr->sup_multicast_addr,
+			    skb->dev->dev_addr, skb->len) <= 0)
 		goto out;
+	skb_reset_mac_header(skb);
 
-	skb_pull(skb, sizeof(struct ethhdr));
-	hsr_stag = (typeof(hsr_stag)) skb->data;
+	hsr_stag = (typeof(hsr_stag)) skb_put(skb, sizeof(*hsr_stag));
 
 	set_hsr_stag_path(hsr_stag, 0xf);
 	set_hsr_stag_HSR_Ver(hsr_stag, 0);
 
-	spin_lock_irqsave(&hsr->seqnr_lock, irqflags);
-	hsr_stag->sequence_nr = htons(hsr->sequence_nr);
-	hsr->sequence_nr++;
-	spin_unlock_irqrestore(&hsr->seqnr_lock, irqflags);
+	spin_lock_irqsave(&master->hsr->seqnr_lock, irqflags);
+	hsr_stag->sequence_nr = htons(master->hsr->sequence_nr);
+	master->hsr->sequence_nr++;
+	spin_unlock_irqrestore(&master->hsr->seqnr_lock, irqflags);
 
 	hsr_stag->HSR_TLV_Type = type;
 	hsr_stag->HSR_TLV_Length = 12;
 
-	skb_push(skb, sizeof(struct ethhdr));
-
 	/* Payload: MacAddressA */
 	hsr_sp = (typeof(hsr_sp)) skb_put(skb, sizeof(*hsr_sp));
 	ether_addr_copy(hsr_sp->MacAddressA, master->dev->dev_addr);
 
-	dev_queue_xmit(skb);
+	hsr_forward_skb(skb, master);
 	return;
 
 out:
@@ -453,13 +325,15 @@ static void hsr_announce(unsigned long data)
 	struct hsr_port *master;
 
 	hsr = (struct hsr_priv *) data;
+
+	rcu_read_lock();
 	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 
 	if (hsr->announce_count < 3) {
-		send_hsr_supervision_frame(master->dev, HSR_TLV_ANNOUNCE);
+		send_hsr_supervision_frame(master, HSR_TLV_ANNOUNCE);
 		hsr->announce_count++;
 	} else {
-		send_hsr_supervision_frame(master->dev, HSR_TLV_LIFE_CHECK);
+		send_hsr_supervision_frame(master, HSR_TLV_LIFE_CHECK);
 	}
 
 	if (hsr->announce_count < 3)
@@ -471,6 +345,8 @@ static void hsr_announce(unsigned long data)
 
 	if (is_admin_up(master->dev))
 		add_timer(&hsr->announce_timer);
+
+	rcu_read_unlock();
 }
 
 
@@ -570,7 +446,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 
 	spin_lock_init(&hsr->seqnr_lock);
 	/* Overflow soon to find bugs easier: */
-	hsr->sequence_nr = USHRT_MAX - 1024;
+	hsr->sequence_nr = HSR_SEQNR_START;
 
 	init_timer(&hsr->announce_timer);
 	hsr->announce_timer.function = hsr_announce;

commit 4c3477dca2fde1e3ab748387d736d40afe0df21d
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:39:42 2014 +0200

    net/hsr: Added SET_NETDEV_DEVTYPE and features |= NETIF_F_NETNS_LOCAL to dev_setup.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index c489aed98df4..c2ae54924a0f 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -501,15 +501,19 @@ static const struct net_device_ops hsr_device_ops = {
 	.ndo_fix_features = hsr_fix_features,
 };
 
+static struct device_type hsr_type = {
+	.name = "hsr",
+};
 
 void hsr_dev_setup(struct net_device *dev)
 {
 	random_ether_addr(dev->dev_addr);
 
 	ether_setup(dev);
-	dev->header_ops		 = &hsr_header_ops;
-	dev->netdev_ops		 = &hsr_device_ops;
-	dev->tx_queue_len	 = 0;
+	dev->header_ops = &hsr_header_ops;
+	dev->netdev_ops = &hsr_device_ops;
+	SET_NETDEV_DEVTYPE(dev, &hsr_type);
+	dev->tx_queue_len = 0;
 
 	dev->destructor = hsr_dev_destroy;
 
@@ -525,6 +529,10 @@ void hsr_dev_setup(struct net_device *dev)
 	 * hsr_header_create() etc.
 	 */
 	dev->features |= NETIF_F_VLAN_CHALLENGED;
+	/* Not sure about this. Taken from bridge code. netdev_features.h says
+	 * it means "Does not change network namespaces".
+	 */
+	dev->features |= NETIF_F_NETNS_LOCAL;
 }
 
 

commit 1cc1eb52734bfd2fc57c7b3337a11198e713580d
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:38:57 2014 +0200

    net/hsr: Implemented .ndo_fix_features (better device features handling).
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 1fc4ea20752e..c489aed98df4 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -198,6 +198,39 @@ static int hsr_dev_close(struct net_device *dev)
 }
 
 
+static netdev_features_t hsr_features_recompute(struct hsr_priv *hsr,
+						netdev_features_t features)
+{
+	netdev_features_t mask;
+	struct hsr_port *port;
+
+	mask = features;
+
+	/* Mask out all features that, if supported by one device, should be
+	 * enabled for all devices (see NETIF_F_ONE_FOR_ALL).
+	 *
+	 * Anything that's off in mask will not be enabled - so only things
+	 * that were in features originally, and also is in NETIF_F_ONE_FOR_ALL,
+	 * may become enabled.
+	 */
+	features &= ~NETIF_F_ONE_FOR_ALL;
+	hsr_for_each_port(hsr, port)
+		features = netdev_increment_features(features,
+						     port->dev->features,
+						     mask);
+
+	return features;
+}
+
+static netdev_features_t hsr_fix_features(struct net_device *dev,
+					  netdev_features_t features)
+{
+	struct hsr_priv *hsr = netdev_priv(dev);
+
+	return hsr_features_recompute(hsr, features);
+}
+
+
 static void hsr_fill_tag(struct hsr_ethhdr *hsr_ethhdr, struct hsr_priv *hsr)
 {
 	unsigned long irqflags;
@@ -465,6 +498,7 @@ static const struct net_device_ops hsr_device_ops = {
 	.ndo_open = hsr_dev_open,
 	.ndo_stop = hsr_dev_close,
 	.ndo_start_xmit = hsr_dev_xmit,
+	.ndo_fix_features = hsr_fix_features,
 };
 
 
@@ -478,6 +512,19 @@ void hsr_dev_setup(struct net_device *dev)
 	dev->tx_queue_len	 = 0;
 
 	dev->destructor = hsr_dev_destroy;
+
+	dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
+			   NETIF_F_GSO_MASK | NETIF_F_HW_CSUM |
+			   NETIF_F_HW_VLAN_CTAG_TX;
+
+	dev->features = dev->hw_features;
+
+	/* Prevent recursive tx locking */
+	dev->features |= NETIF_F_LLTX;
+	/* VLAN on top of HSR needs testing and probably some work on
+	 * hsr_header_create() etc.
+	 */
+	dev->features |= NETIF_F_VLAN_CHALLENGED;
 }
 
 
@@ -513,14 +560,6 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	if (res < 0)
 		return res;
 
-	hsr_dev->features = slave[0]->features & slave[1]->features;
-	/* Prevent recursive tx locking */
-	hsr_dev->features |= NETIF_F_LLTX;
-	/* VLAN on top of HSR needs testing and probably some work on
-	 * hsr_header_create() etc.
-	 */
-	hsr_dev->features |= NETIF_F_VLAN_CHALLENGED;
-
 	spin_lock_init(&hsr->seqnr_lock);
 	/* Overflow soon to find bugs easier: */
 	hsr->sequence_nr = USHRT_MAX - 1024;

commit c5a7591172100269e426cf630da0f2dc8138a206
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:38:05 2014 +0200

    net/hsr: Use list_head (and rcu) instead of array for slave devices.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 1f8869cb70ae..1fc4ea20752e 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -45,29 +45,38 @@ static void __hsr_set_operstate(struct net_device *dev, int transition)
 	}
 }
 
-static void hsr_set_operstate(struct net_device *hsr_dev, bool has_carrier)
+static void hsr_set_operstate(struct hsr_port *master, bool has_carrier)
 {
-	if (!is_admin_up(hsr_dev)) {
-		__hsr_set_operstate(hsr_dev, IF_OPER_DOWN);
+	if (!is_admin_up(master->dev)) {
+		__hsr_set_operstate(master->dev, IF_OPER_DOWN);
 		return;
 	}
 
 	if (has_carrier)
-		__hsr_set_operstate(hsr_dev, IF_OPER_UP);
+		__hsr_set_operstate(master->dev, IF_OPER_UP);
 	else
-		__hsr_set_operstate(hsr_dev, IF_OPER_LOWERLAYERDOWN);
+		__hsr_set_operstate(master->dev, IF_OPER_LOWERLAYERDOWN);
 }
 
-static bool hsr_check_carrier(struct hsr_priv *hsr)
+static bool hsr_check_carrier(struct hsr_port *master)
 {
+	struct hsr_port *port;
 	bool has_carrier;
 
-	has_carrier = (is_slave_up(hsr->slave[0]) || is_slave_up(hsr->slave[1]));
+	has_carrier = false;
+
+	rcu_read_lock();
+	hsr_for_each_port(master->hsr, port)
+		if ((port->type != HSR_PT_MASTER) && is_slave_up(port->dev)) {
+			has_carrier = true;
+			break;
+		}
+	rcu_read_unlock();
 
 	if (has_carrier)
-		netif_carrier_on(hsr->dev);
+		netif_carrier_on(master->dev);
 	else
-		netif_carrier_off(hsr->dev);
+		netif_carrier_off(master->dev);
 
 	return has_carrier;
 }
@@ -95,31 +104,30 @@ static void hsr_check_announce(struct net_device *hsr_dev,
 
 void hsr_check_carrier_and_operstate(struct hsr_priv *hsr)
 {
+	struct hsr_port *master;
 	unsigned char old_operstate;
 	bool has_carrier;
 
+	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 	/* netif_stacked_transfer_operstate() cannot be used here since
 	 * it doesn't set IF_OPER_LOWERLAYERDOWN (?)
 	 */
-	old_operstate = hsr->dev->operstate;
-	has_carrier = hsr_check_carrier(hsr);
-	hsr_set_operstate(hsr->dev, has_carrier);
-	hsr_check_announce(hsr->dev, old_operstate);
+	old_operstate = master->dev->operstate;
+	has_carrier = hsr_check_carrier(master);
+	hsr_set_operstate(master, has_carrier);
+	hsr_check_announce(master->dev, old_operstate);
 }
 
 int hsr_get_max_mtu(struct hsr_priv *hsr)
 {
 	unsigned int mtu_max;
-	struct net_device *slave;
+	struct hsr_port *port;
 
 	mtu_max = ETH_DATA_LEN;
 	rcu_read_lock();
-	slave = hsr->slave[0];
-	if (slave)
-		mtu_max = min(slave->mtu, mtu_max);
-	slave = hsr->slave[1];
-	if (slave)
-		mtu_max = min(slave->mtu, mtu_max);
+	hsr_for_each_port(hsr, port)
+		if (port->type != HSR_PT_MASTER)
+			mtu_max = min(port->dev->mtu, mtu_max);
 	rcu_read_unlock();
 
 	if (mtu_max < HSR_HLEN)
@@ -131,11 +139,13 @@ int hsr_get_max_mtu(struct hsr_priv *hsr)
 static int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct hsr_priv *hsr;
+	struct hsr_port *master;
 
 	hsr = netdev_priv(dev);
+	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 
 	if (new_mtu > hsr_get_max_mtu(hsr)) {
-		netdev_info(hsr->dev, "A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\n",
+		netdev_info(master->dev, "A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\n",
 			    HSR_HLEN);
 		return -EINVAL;
 	}
@@ -148,35 +158,42 @@ static int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)
 static int hsr_dev_open(struct net_device *dev)
 {
 	struct hsr_priv *hsr;
-	struct net_device *slave;
-	int i;
-	char *slave_name;
+	struct hsr_port *port;
+	char designation;
 
 	hsr = netdev_priv(dev);
+	designation = '\0';
 
-	for (i = 0; i < HSR_MAX_SLAVE; i++) {
-		slave = hsr->slave[i];
-		if (slave)
-			slave_name = slave->name;
-		else
-			slave_name = "null";
-
-		if (!is_slave_up(slave))
-			netdev_warn(dev, "Slave %c (%s) is not up; please bring it up to get a working HSR network\n",
-				    'A' + i, slave_name);
+	rcu_read_lock();
+	hsr_for_each_port(hsr, port) {
+		if (port->type == HSR_PT_MASTER)
+			continue;
+		switch (port->type) {
+		case HSR_PT_SLAVE_A:
+			designation = 'A';
+			break;
+		case HSR_PT_SLAVE_B:
+			designation = 'B';
+			break;
+		default:
+			designation = '?';
+		}
+		if (!is_slave_up(port->dev))
+			netdev_warn(dev, "Slave %c (%s) is not up; please bring it up to get a fully working HSR network\n",
+				    designation, port->dev->name);
 	}
+	rcu_read_unlock();
+
+	if (designation == '\0')
+		netdev_warn(dev, "No slave devices configured\n");
 
 	return 0;
 }
 
+
 static int hsr_dev_close(struct net_device *dev)
 {
-	/* Nothing to do here. We could try to restore the state of the slaves
-	 * to what they were before being changed by the hsr master dev's state,
-	 * but they might have been changed manually in the mean time too, so
-	 * taking them up or down here might be confusing and is probably not a
-	 * good idea.
-	 */
+	/* Nothing to do here. */
 	return 0;
 }
 
@@ -220,18 +237,24 @@ static void hsr_fill_tag(struct hsr_ethhdr *hsr_ethhdr, struct hsr_priv *hsr)
 	hsr_ethhdr->ethhdr.h_proto = htons(ETH_P_PRP);
 }
 
-static int slave_xmit(struct sk_buff *skb, struct hsr_priv *hsr,
-		      enum hsr_dev_idx dev_idx)
+static int slave_xmit(struct hsr_priv *hsr, struct sk_buff *skb,
+		      enum hsr_port_type type)
 {
+	struct hsr_port *port;
 	struct hsr_ethhdr *hsr_ethhdr;
 
 	hsr_ethhdr = (struct hsr_ethhdr *) skb->data;
 
-	skb->dev = hsr->slave[dev_idx];
-	if (unlikely(!skb->dev))
+	rcu_read_lock();
+	port = hsr_port_get_hsr(hsr, type);
+	if (!port) {
+		rcu_read_unlock();
 		return NET_XMIT_DROP;
+	}
+	skb->dev = port->dev;
 
-	hsr_addr_subst_dest(hsr, &hsr_ethhdr->ethhdr, dev_idx);
+	hsr_addr_subst_dest(port->hsr, &hsr_ethhdr->ethhdr, port);
+	rcu_read_unlock();
 
 	/* Address substitution (IEC62439-3 pp 26, 50): replace mac
 	 * address of outgoing frame with that of the outgoing slave's.
@@ -241,10 +264,10 @@ static int slave_xmit(struct sk_buff *skb, struct hsr_priv *hsr,
 	return dev_queue_xmit(skb);
 }
 
-
 static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct hsr_priv *hsr;
+	struct hsr_port *master;
 	struct hsr_ethhdr *hsr_ethhdr;
 	struct sk_buff *skb2;
 	int res1, res2;
@@ -259,16 +282,23 @@ static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 	}
 
 	skb2 = pskb_copy(skb, GFP_ATOMIC);
-	res1 = slave_xmit(skb, hsr, HSR_DEV_SLAVE_A);
-	res2 = slave_xmit(skb2, hsr, HSR_DEV_SLAVE_B);
 
+	res1 = slave_xmit(hsr, skb, HSR_PT_SLAVE_A);
+	if (skb2)
+		res2 = slave_xmit(hsr, skb2, HSR_PT_SLAVE_B);
+	else
+		res2 = NET_XMIT_DROP;
+
+	rcu_read_lock();
+	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 	if (likely(res1 == NET_XMIT_SUCCESS || res1 == NET_XMIT_CN ||
 		   res2 == NET_XMIT_SUCCESS || res2 == NET_XMIT_CN)) {
-		hsr->dev->stats.tx_packets++;
-		hsr->dev->stats.tx_bytes += skb->len;
+		master->dev->stats.tx_packets++;
+		master->dev->stats.tx_bytes += skb->len;
 	} else {
-		hsr->dev->stats.tx_dropped++;
+		master->dev->stats.tx_dropped++;
 	}
+	rcu_read_unlock();
 
 	return NETDEV_TX_OK;
 }
@@ -322,31 +352,35 @@ static int hsr_pad(int size)
 static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
 {
 	struct hsr_priv *hsr;
+	struct hsr_port *master;
 	struct sk_buff *skb;
 	int hlen, tlen;
 	struct hsr_sup_tag *hsr_stag;
 	struct hsr_sup_payload *hsr_sp;
 	unsigned long irqflags;
+	int res;
+
+	hsr = netdev_priv(hsr_dev);
+	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 
-	hlen = LL_RESERVED_SPACE(hsr_dev);
-	tlen = hsr_dev->needed_tailroom;
+	hlen = LL_RESERVED_SPACE(master->dev);
+	tlen = master->dev->needed_tailroom;
 	skb = alloc_skb(hsr_pad(sizeof(struct hsr_sup_payload)) + hlen + tlen,
 			GFP_ATOMIC);
 
 	if (skb == NULL)
 		return;
 
-	hsr = netdev_priv(hsr_dev);
-
 	skb_reserve(skb, hlen);
 
-	skb->dev = hsr_dev;
+	skb->dev = master->dev;
 	skb->protocol = htons(ETH_P_PRP);
 	skb->priority = TC_PRIO_CONTROL;
 
-	if (dev_hard_header(skb, skb->dev, ETH_P_PRP,
-			    hsr->sup_multicast_addr,
-			    skb->dev->dev_addr, skb->len) < 0)
+	res = dev_hard_header(skb, skb->dev, ETH_P_PRP,
+			      hsr->sup_multicast_addr,
+			      skb->dev->dev_addr, skb->len);
+	if (res <= 0)
 		goto out;
 
 	skb_pull(skb, sizeof(struct ethhdr));
@@ -367,12 +401,13 @@ static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
 
 	/* Payload: MacAddressA */
 	hsr_sp = (typeof(hsr_sp)) skb_put(skb, sizeof(*hsr_sp));
-	ether_addr_copy(hsr_sp->MacAddressA, hsr_dev->dev_addr);
+	ether_addr_copy(hsr_sp->MacAddressA, master->dev->dev_addr);
 
 	dev_queue_xmit(skb);
 	return;
 
 out:
+	WARN_ON_ONCE("HSR: Could not send supervision frame\n");
 	kfree_skb(skb);
 }
 
@@ -382,14 +417,16 @@ static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
 static void hsr_announce(unsigned long data)
 {
 	struct hsr_priv *hsr;
+	struct hsr_port *master;
 
 	hsr = (struct hsr_priv *) data;
+	master = hsr_port_get_hsr(hsr, HSR_PT_MASTER);
 
 	if (hsr->announce_count < 3) {
-		send_hsr_supervision_frame(hsr->dev, HSR_TLV_ANNOUNCE);
+		send_hsr_supervision_frame(master->dev, HSR_TLV_ANNOUNCE);
 		hsr->announce_count++;
 	} else {
-		send_hsr_supervision_frame(hsr->dev, HSR_TLV_LIFE_CHECK);
+		send_hsr_supervision_frame(master->dev, HSR_TLV_LIFE_CHECK);
 	}
 
 	if (hsr->announce_count < 3)
@@ -399,43 +436,28 @@ static void hsr_announce(unsigned long data)
 		hsr->announce_timer.expires = jiffies +
 				msecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);
 
-	if (is_admin_up(hsr->dev))
+	if (is_admin_up(master->dev))
 		add_timer(&hsr->announce_timer);
 }
 
 
-static void restore_slaves(struct net_device *hsr_dev)
-{
-	struct hsr_priv *hsr;
-
-	hsr = netdev_priv(hsr_dev);
-	hsr_del_slave(hsr, 1);
-	hsr_del_slave(hsr, 0);
-}
-
-static void reclaim_hsr_dev(struct rcu_head *rh)
-{
-	struct hsr_priv *hsr;
-
-	hsr = container_of(rh, struct hsr_priv, rcu_head);
-	free_netdev(hsr->dev);
-}
-
-
 /* According to comments in the declaration of struct net_device, this function
  * is "Called from unregister, can be used to call free_netdev". Ok then...
  */
 static void hsr_dev_destroy(struct net_device *hsr_dev)
 {
 	struct hsr_priv *hsr;
+	struct hsr_port *port;
 
 	hsr = netdev_priv(hsr_dev);
+	hsr_for_each_port(hsr, port)
+		hsr_del_port(port);
 
 	del_timer_sync(&hsr->prune_timer);
 	del_timer_sync(&hsr->announce_timer);
-	unregister_hsr_master(hsr);    /* calls list_del_rcu on hsr */
-	restore_slaves(hsr_dev);
-	call_rcu(&hsr->rcu_head, reclaim_hsr_dev);   /* reclaim hsr */
+
+	synchronize_rcu();
+	free_netdev(hsr_dev);
 }
 
 static const struct net_device_ops hsr_device_ops = {
@@ -461,12 +483,11 @@ void hsr_dev_setup(struct net_device *dev)
 
 /* Return true if dev is a HSR master; return false otherwise.
  */
-bool is_hsr_master(struct net_device *dev)
+inline bool is_hsr_master(struct net_device *dev)
 {
 	return (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);
 }
 
-
 /* Default multicast address for HSR Supervision frames */
 static const unsigned char def_multicast_addr[ETH_ALEN] __aligned(2) = {
 	0x01, 0x15, 0x4e, 0x00, 0x01, 0x00
@@ -476,12 +497,11 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 		     unsigned char multicast_spec)
 {
 	struct hsr_priv *hsr;
+	struct hsr_port *port;
 	int res;
 
 	hsr = netdev_priv(hsr_dev);
-	hsr->dev = hsr_dev;
-	hsr->slave[0] = NULL;
-	hsr->slave[1] = NULL;
+	INIT_LIST_HEAD(&hsr->ports);
 	INIT_LIST_HEAD(&hsr->node_db);
 	INIT_LIST_HEAD(&hsr->self_node_db);
 
@@ -516,36 +536,42 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	ether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);
 	hsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
 
-/* FIXME: should I modify the value of these?
- *
- * - hsr_dev->flags - i.e.
- *			IFF_MASTER/SLAVE?
- * - hsr_dev->priv_flags - i.e.
- *			IFF_EBRIDGE?
- *			IFF_TX_SKB_SHARING?
- *			IFF_HSR_MASTER/SLAVE?
- */
+	/* FIXME: should I modify the value of these?
+	 *
+	 * - hsr_dev->flags - i.e.
+	 *			IFF_MASTER/SLAVE?
+	 * - hsr_dev->priv_flags - i.e.
+	 *			IFF_EBRIDGE?
+	 *			IFF_TX_SKB_SHARING?
+	 *			IFF_HSR_MASTER/SLAVE?
+	 */
 
 	/* Make sure the 1st call to netif_carrier_on() gets through */
 	netif_carrier_off(hsr_dev);
 
-	res = register_netdevice(hsr_dev);
+	res = hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER);
 	if (res)
 		return res;
 
-	res = hsr_add_slave(hsr, slave[0], 0);
+	res = register_netdevice(hsr_dev);
 	if (res)
-		return res;
-	res = hsr_add_slave(hsr, slave[1], 1);
-	if (res) {
-		hsr_del_slave(hsr, 0);
-		return res;
-	}
+		goto fail;
+
+	res = hsr_add_port(hsr, slave[0], HSR_PT_SLAVE_A);
+	if (res)
+		goto fail;
+	res = hsr_add_port(hsr, slave[1], HSR_PT_SLAVE_B);
+	if (res)
+		goto fail;
 
 	hsr->prune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);
 	add_timer(&hsr->prune_timer);
 
-	register_hsr_master(hsr);
-
 	return 0;
+
+fail:
+	hsr_for_each_port(hsr, port)
+		hsr_del_port(port);
+
+	return res;
 }

commit 51f3c605318b056ac5deb9079bbef2a976558827
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:37:27 2014 +0200

    net/hsr: Move slave init to hsr_slave.c.
    
    Also try to prevent some possible slave dereference race conditions. This is
    finalized in the next patch, which abandons the slave array in favour of
    a list_head list and list RCU.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 8936b3c2bb84..1f8869cb70ae 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -15,7 +15,6 @@
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
 #include <linux/etherdevice.h>
-#include <linux/if_arp.h>
 #include <linux/rtnetlink.h>
 #include <linux/pkt_sched.h>
 #include "hsr_device.h"
@@ -108,23 +107,27 @@ void hsr_check_carrier_and_operstate(struct hsr_priv *hsr)
 	hsr_check_announce(hsr->dev, old_operstate);
 }
 
-
 int hsr_get_max_mtu(struct hsr_priv *hsr)
 {
-	int mtu_max;
-
-	if (hsr->slave[0] && hsr->slave[1])
-		mtu_max = min(hsr->slave[0]->mtu, hsr->slave[1]->mtu);
-	else if (hsr->slave[0])
-		mtu_max = hsr->slave[0]->mtu;
-	else if (hsr->slave[1])
-		mtu_max = hsr->slave[1]->mtu;
-	else
-		mtu_max = HSR_HLEN;
-
+	unsigned int mtu_max;
+	struct net_device *slave;
+
+	mtu_max = ETH_DATA_LEN;
+	rcu_read_lock();
+	slave = hsr->slave[0];
+	if (slave)
+		mtu_max = min(slave->mtu, mtu_max);
+	slave = hsr->slave[1];
+	if (slave)
+		mtu_max = min(slave->mtu, mtu_max);
+	rcu_read_unlock();
+
+	if (mtu_max < HSR_HLEN)
+		return 0;
 	return mtu_max - HSR_HLEN;
 }
 
+
 static int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)
 {
 	struct hsr_priv *hsr;
@@ -145,18 +148,20 @@ static int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)
 static int hsr_dev_open(struct net_device *dev)
 {
 	struct hsr_priv *hsr;
+	struct net_device *slave;
 	int i;
 	char *slave_name;
 
 	hsr = netdev_priv(dev);
 
 	for (i = 0; i < HSR_MAX_SLAVE; i++) {
-		if (hsr->slave[i])
-			slave_name = hsr->slave[i]->name;
+		slave = hsr->slave[i];
+		if (slave)
+			slave_name = slave->name;
 		else
 			slave_name = "null";
 
-		if (!is_slave_up(hsr->slave[i]))
+		if (!is_slave_up(slave))
 			netdev_warn(dev, "Slave %c (%s) is not up; please bring it up to get a working HSR network\n",
 				    'A' + i, slave_name);
 	}
@@ -223,6 +228,8 @@ static int slave_xmit(struct sk_buff *skb, struct hsr_priv *hsr,
 	hsr_ethhdr = (struct hsr_ethhdr *) skb->data;
 
 	skb->dev = hsr->slave[dev_idx];
+	if (unlikely(!skb->dev))
+		return NET_XMIT_DROP;
 
 	hsr_addr_subst_dest(hsr, &hsr_ethhdr->ethhdr, dev_idx);
 
@@ -252,14 +259,8 @@ static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 	}
 
 	skb2 = pskb_copy(skb, GFP_ATOMIC);
-
-	res1 = NET_XMIT_DROP;
-	if (likely(hsr->slave[HSR_DEV_SLAVE_A]))
-		res1 = slave_xmit(skb, hsr, HSR_DEV_SLAVE_A);
-
-	res2 = NET_XMIT_DROP;
-	if (likely(skb2 && hsr->slave[HSR_DEV_SLAVE_B]))
-		res2 = slave_xmit(skb2, hsr, HSR_DEV_SLAVE_B);
+	res1 = slave_xmit(skb, hsr, HSR_DEV_SLAVE_A);
+	res2 = slave_xmit(skb2, hsr, HSR_DEV_SLAVE_B);
 
 	if (likely(res1 == NET_XMIT_SUCCESS || res1 == NET_XMIT_CN ||
 		   res2 == NET_XMIT_SUCCESS || res2 == NET_XMIT_CN)) {
@@ -406,28 +407,10 @@ static void hsr_announce(unsigned long data)
 static void restore_slaves(struct net_device *hsr_dev)
 {
 	struct hsr_priv *hsr;
-	int i;
-	int res;
 
 	hsr = netdev_priv(hsr_dev);
-
-	rtnl_lock();
-
-	for (i = 0; i < HSR_MAX_SLAVE; i++) {
-		if (!hsr->slave[i])
-			continue;
-		res = dev_set_promiscuity(hsr->slave[i], -1);
-		if (res)
-			netdev_info(hsr_dev,
-				    "Cannot restore slave promiscuity (%s, %d)\n",
-				    hsr->slave[i]->name, res);
-
-		if (hsr->slave[i]->rx_handler == hsr_handle_frame)
-			netdev_rx_handler_unregister(hsr->slave[i]);
-	}
-
-
-	rtnl_unlock();
+	hsr_del_slave(hsr, 1);
+	hsr_del_slave(hsr, 0);
 }
 
 static void reclaim_hsr_dev(struct rcu_head *rh)
@@ -483,38 +466,6 @@ bool is_hsr_master(struct net_device *dev)
 	return (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);
 }
 
-static int check_slave_ok(struct net_device *dev)
-{
-	/* Don't allow HSR on non-ethernet like devices */
-	if ((dev->flags & IFF_LOOPBACK) || (dev->type != ARPHRD_ETHER) ||
-	    (dev->addr_len != ETH_ALEN)) {
-		netdev_info(dev, "Cannot use loopback or non-ethernet device as HSR slave.\n");
-		return -EINVAL;
-	}
-
-	/* Don't allow enslaving hsr devices */
-	if (is_hsr_master(dev)) {
-		netdev_info(dev, "Cannot create trees of HSR devices.\n");
-		return -EINVAL;
-	}
-
-	if (is_hsr_slave(dev)) {
-		netdev_info(dev, "This device is already a HSR slave.\n");
-		return -EINVAL;
-	}
-
-	if (dev->priv_flags & IFF_802_1Q_VLAN) {
-		netdev_info(dev, "HSR on top of VLAN is not yet supported in this driver.\n");
-		return -EINVAL;
-	}
-
-	/* HSR over bonded devices has not been tested, but I'm not sure it
-	 * won't work...
-	 */
-
-	return 0;
-}
-
 
 /* Default multicast address for HSR Supervision frames */
 static const unsigned char def_multicast_addr[ETH_ALEN] __aligned(2) = {
@@ -525,15 +476,30 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 		     unsigned char multicast_spec)
 {
 	struct hsr_priv *hsr;
-	int i;
 	int res;
 
 	hsr = netdev_priv(hsr_dev);
 	hsr->dev = hsr_dev;
+	hsr->slave[0] = NULL;
+	hsr->slave[1] = NULL;
 	INIT_LIST_HEAD(&hsr->node_db);
 	INIT_LIST_HEAD(&hsr->self_node_db);
-	for (i = 0; i < HSR_MAX_SLAVE; i++)
-		hsr->slave[i] = slave[i];
+
+	ether_addr_copy(hsr_dev->dev_addr, slave[0]->dev_addr);
+
+	/* Make sure we recognize frames from ourselves in hsr_rcv() */
+	res = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,
+				   slave[1]->dev_addr);
+	if (res < 0)
+		return res;
+
+	hsr_dev->features = slave[0]->features & slave[1]->features;
+	/* Prevent recursive tx locking */
+	hsr_dev->features |= NETIF_F_LLTX;
+	/* VLAN on top of HSR needs testing and probably some work on
+	 * hsr_header_create() etc.
+	 */
+	hsr_dev->features |= NETIF_F_VLAN_CHALLENGED;
 
 	spin_lock_init(&hsr->seqnr_lock);
 	/* Overflow soon to find bugs easier: */
@@ -560,65 +526,21 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
  *			IFF_HSR_MASTER/SLAVE?
  */
 
-	for (i = 0; i < HSR_MAX_SLAVE; i++) {
-		res = check_slave_ok(slave[i]);
-		if (res)
-			return res;
-	}
-
-	hsr_dev->features = slave[0]->features & slave[1]->features;
-	/* Prevent recursive tx locking */
-	hsr_dev->features |= NETIF_F_LLTX;
-	/* VLAN on top of HSR needs testing and probably some work on
-	 * hsr_header_create() etc.
-	 */
-	hsr_dev->features |= NETIF_F_VLAN_CHALLENGED;
-
-	/* Set hsr_dev's MAC address to that of mac_slave1 */
-	ether_addr_copy(hsr_dev->dev_addr, hsr->slave[0]->dev_addr);
-
-	/* Set required header length */
-	for (i = 0; i < HSR_MAX_SLAVE; i++) {
-		if (slave[i]->hard_header_len + HSR_HLEN >
-						hsr_dev->hard_header_len)
-			hsr_dev->hard_header_len =
-					slave[i]->hard_header_len + HSR_HLEN;
-	}
-
-	/* MTU */
-	for (i = 0; i < HSR_MAX_SLAVE; i++)
-		if (slave[i]->mtu - HSR_HLEN < hsr_dev->mtu)
-			hsr_dev->mtu = slave[i]->mtu - HSR_HLEN;
-
 	/* Make sure the 1st call to netif_carrier_on() gets through */
 	netif_carrier_off(hsr_dev);
 
-	/* Promiscuity */
-	for (i = 0; i < HSR_MAX_SLAVE; i++) {
-		res = dev_set_promiscuity(slave[i], 1);
-		if (res) {
-			netdev_info(hsr_dev, "Cannot set slave promiscuity (%s, %d)\n",
-				    slave[i]->name, res);
-			goto fail;
-		}
-	}
-
-	for (i = 0; i < HSR_MAX_SLAVE; i++) {
-		res = netdev_rx_handler_register(slave[i], hsr_handle_frame,
-						 hsr);
-		if (res)
-			goto fail;
-	}
-
-	/* Make sure we recognize frames from ourselves in hsr_rcv() */
-	res = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,
-				   hsr->slave[1]->dev_addr);
-	if (res < 0)
-		goto fail;
-
 	res = register_netdevice(hsr_dev);
 	if (res)
-		goto fail;
+		return res;
+
+	res = hsr_add_slave(hsr, slave[0], 0);
+	if (res)
+		return res;
+	res = hsr_add_slave(hsr, slave[1], 1);
+	if (res) {
+		hsr_del_slave(hsr, 0);
+		return res;
+	}
 
 	hsr->prune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);
 	add_timer(&hsr->prune_timer);
@@ -626,8 +548,4 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	register_hsr_master(hsr);
 
 	return 0;
-
-fail:
-	restore_slaves(hsr_dev);
-	return res;
 }

commit e9aae56ea43ef4a32527b9d86c1f6b5eebfbd223
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:36:40 2014 +0200

    net/hsr: Operstate handling cleanup.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index f224067153e4..8936b3c2bb84 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -46,31 +46,36 @@ static void __hsr_set_operstate(struct net_device *dev, int transition)
 	}
 }
 
-void hsr_set_operstate(struct net_device *hsr_dev, struct net_device *slave1,
-		       struct net_device *slave2)
+static void hsr_set_operstate(struct net_device *hsr_dev, bool has_carrier)
 {
 	if (!is_admin_up(hsr_dev)) {
 		__hsr_set_operstate(hsr_dev, IF_OPER_DOWN);
 		return;
 	}
 
-	if (is_slave_up(slave1) || is_slave_up(slave2))
+	if (has_carrier)
 		__hsr_set_operstate(hsr_dev, IF_OPER_UP);
 	else
 		__hsr_set_operstate(hsr_dev, IF_OPER_LOWERLAYERDOWN);
 }
 
-void hsr_set_carrier(struct net_device *hsr_dev, struct net_device *slave1,
-		     struct net_device *slave2)
+static bool hsr_check_carrier(struct hsr_priv *hsr)
 {
-	if (is_slave_up(slave1) || is_slave_up(slave2))
-		netif_carrier_on(hsr_dev);
+	bool has_carrier;
+
+	has_carrier = (is_slave_up(hsr->slave[0]) || is_slave_up(hsr->slave[1]));
+
+	if (has_carrier)
+		netif_carrier_on(hsr->dev);
 	else
-		netif_carrier_off(hsr_dev);
+		netif_carrier_off(hsr->dev);
+
+	return has_carrier;
 }
 
 
-void hsr_check_announce(struct net_device *hsr_dev, int old_operstate)
+static void hsr_check_announce(struct net_device *hsr_dev,
+			       unsigned char old_operstate)
 {
 	struct hsr_priv *hsr;
 
@@ -89,6 +94,20 @@ void hsr_check_announce(struct net_device *hsr_dev, int old_operstate)
 		del_timer(&hsr->announce_timer);
 }
 
+void hsr_check_carrier_and_operstate(struct hsr_priv *hsr)
+{
+	unsigned char old_operstate;
+	bool has_carrier;
+
+	/* netif_stacked_transfer_operstate() cannot be used here since
+	 * it doesn't set IF_OPER_LOWERLAYERDOWN (?)
+	 */
+	old_operstate = hsr->dev->operstate;
+	has_carrier = hsr_check_carrier(hsr);
+	hsr_set_operstate(hsr->dev, has_carrier);
+	hsr_check_announce(hsr->dev, old_operstate);
+}
+
 
 int hsr_get_max_mtu(struct hsr_priv *hsr)
 {

commit abff7162765cd66ab109c97fd433ef1f39299120
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:35:47 2014 +0200

    net/hsr: Move to per-hsr device prune timer.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 4e5d92a8f079..f224067153e4 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -429,7 +429,8 @@ static void hsr_dev_destroy(struct net_device *hsr_dev)
 
 	hsr = netdev_priv(hsr_dev);
 
-	del_timer(&hsr->announce_timer);
+	del_timer_sync(&hsr->prune_timer);
+	del_timer_sync(&hsr->announce_timer);
 	unregister_hsr_master(hsr);    /* calls list_del_rcu on hsr */
 	restore_slaves(hsr_dev);
 	call_rcu(&hsr->rcu_head, reclaim_hsr_dev);   /* reclaim hsr */
@@ -523,6 +524,10 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	hsr->announce_timer.function = hsr_announce;
 	hsr->announce_timer.data = (unsigned long) hsr;
 
+	init_timer(&hsr->prune_timer);
+	hsr->prune_timer.function = hsr_prune_nodes;
+	hsr->prune_timer.data = (unsigned long) hsr;
+
 	ether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);
 	hsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
 
@@ -596,6 +601,9 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	if (res)
 		goto fail;
 
+	hsr->prune_timer.expires = jiffies + msecs_to_jiffies(PRUNE_PERIOD);
+	add_timer(&hsr->prune_timer);
+
 	register_hsr_master(hsr);
 
 	return 0;

commit 81ba6afd6e6443d2bf4bf40f16df1f1f91c603f8
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:35:24 2014 +0200

    net/hsr: Switch from dev_add_pack() to netdev_rx_handler_register()
    
    Also move the frame receive handler to hsr_slave.c.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index 4dc2a4207ee2..4e5d92a8f079 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -19,6 +19,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/pkt_sched.h>
 #include "hsr_device.h"
+#include "hsr_slave.h"
 #include "hsr_framereg.h"
 #include "hsr_main.h"
 
@@ -393,7 +394,6 @@ static void restore_slaves(struct net_device *hsr_dev)
 
 	rtnl_lock();
 
-	/* Restore promiscuity */
 	for (i = 0; i < HSR_MAX_SLAVE; i++) {
 		if (!hsr->slave[i])
 			continue;
@@ -402,8 +402,12 @@ static void restore_slaves(struct net_device *hsr_dev)
 			netdev_info(hsr_dev,
 				    "Cannot restore slave promiscuity (%s, %d)\n",
 				    hsr->slave[i]->name, res);
+
+		if (hsr->slave[i]->rx_handler == hsr_handle_frame)
+			netdev_rx_handler_unregister(hsr->slave[i]);
 	}
 
+
 	rtnl_unlock();
 }
 
@@ -575,6 +579,13 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 		}
 	}
 
+	for (i = 0; i < HSR_MAX_SLAVE; i++) {
+		res = netdev_rx_handler_register(slave[i], hsr_handle_frame,
+						 hsr);
+		if (res)
+			goto fail;
+	}
+
 	/* Make sure we recognize frames from ourselves in hsr_rcv() */
 	res = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,
 				   hsr->slave[1]->dev_addr);

commit 70ebe4a47185db15f3c55be9611a1a971237870b
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:34:38 2014 +0200

    net/hsr: Better variable names and update of contact info.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index e5302b7f7ca9..4dc2a4207ee2 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -1,4 +1,4 @@
-/* Copyright 2011-2013 Autronica Fire and Security AS
+/* Copyright 2011-2014 Autronica Fire and Security AS
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -6,7 +6,7 @@
  * any later version.
  *
  * Author(s):
- *	2011-2013 Arvid Brodin, arvid.brodin@xdin.com
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
  *
  * This file contains device methods for creating, using and destroying
  * virtual HSR devices.
@@ -71,49 +71,49 @@ void hsr_set_carrier(struct net_device *hsr_dev, struct net_device *slave1,
 
 void hsr_check_announce(struct net_device *hsr_dev, int old_operstate)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 
-	hsr_priv = netdev_priv(hsr_dev);
+	hsr = netdev_priv(hsr_dev);
 
 	if ((hsr_dev->operstate == IF_OPER_UP) && (old_operstate != IF_OPER_UP)) {
 		/* Went up */
-		hsr_priv->announce_count = 0;
-		hsr_priv->announce_timer.expires = jiffies +
+		hsr->announce_count = 0;
+		hsr->announce_timer.expires = jiffies +
 				msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
-		add_timer(&hsr_priv->announce_timer);
+		add_timer(&hsr->announce_timer);
 	}
 
 	if ((hsr_dev->operstate != IF_OPER_UP) && (old_operstate == IF_OPER_UP))
 		/* Went down */
-		del_timer(&hsr_priv->announce_timer);
+		del_timer(&hsr->announce_timer);
 }
 
 
-int hsr_get_max_mtu(struct hsr_priv *hsr_priv)
+int hsr_get_max_mtu(struct hsr_priv *hsr)
 {
 	int mtu_max;
 
-	if (hsr_priv->slave[0] && hsr_priv->slave[1])
-		mtu_max = min(hsr_priv->slave[0]->mtu, hsr_priv->slave[1]->mtu);
-	else if (hsr_priv->slave[0])
-		mtu_max = hsr_priv->slave[0]->mtu;
-	else if (hsr_priv->slave[1])
-		mtu_max = hsr_priv->slave[1]->mtu;
+	if (hsr->slave[0] && hsr->slave[1])
+		mtu_max = min(hsr->slave[0]->mtu, hsr->slave[1]->mtu);
+	else if (hsr->slave[0])
+		mtu_max = hsr->slave[0]->mtu;
+	else if (hsr->slave[1])
+		mtu_max = hsr->slave[1]->mtu;
 	else
-		mtu_max = HSR_TAGLEN;
+		mtu_max = HSR_HLEN;
 
-	return mtu_max - HSR_TAGLEN;
+	return mtu_max - HSR_HLEN;
 }
 
 static int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 
-	hsr_priv = netdev_priv(dev);
+	hsr = netdev_priv(dev);
 
-	if (new_mtu > hsr_get_max_mtu(hsr_priv)) {
-		netdev_info(hsr_priv->dev, "A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\n",
-			    HSR_TAGLEN);
+	if (new_mtu > hsr_get_max_mtu(hsr)) {
+		netdev_info(hsr->dev, "A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\n",
+			    HSR_HLEN);
 		return -EINVAL;
 	}
 
@@ -124,19 +124,19 @@ static int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)
 
 static int hsr_dev_open(struct net_device *dev)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 	int i;
 	char *slave_name;
 
-	hsr_priv = netdev_priv(dev);
+	hsr = netdev_priv(dev);
 
 	for (i = 0; i < HSR_MAX_SLAVE; i++) {
-		if (hsr_priv->slave[i])
-			slave_name = hsr_priv->slave[i]->name;
+		if (hsr->slave[i])
+			slave_name = hsr->slave[i]->name;
 		else
 			slave_name = "null";
 
-		if (!is_slave_up(hsr_priv->slave[i]))
+		if (!is_slave_up(hsr->slave[i]))
 			netdev_warn(dev, "Slave %c (%s) is not up; please bring it up to get a working HSR network\n",
 				    'A' + i, slave_name);
 	}
@@ -156,7 +156,7 @@ static int hsr_dev_close(struct net_device *dev)
 }
 
 
-static void hsr_fill_tag(struct hsr_ethhdr *hsr_ethhdr, struct hsr_priv *hsr_priv)
+static void hsr_fill_tag(struct hsr_ethhdr *hsr_ethhdr, struct hsr_priv *hsr)
 {
 	unsigned long irqflags;
 
@@ -185,26 +185,26 @@ static void hsr_fill_tag(struct hsr_ethhdr *hsr_ethhdr, struct hsr_priv *hsr_pri
 	 */
 	set_hsr_tag_LSDU_size(&hsr_ethhdr->hsr_tag, 0);
 
-	spin_lock_irqsave(&hsr_priv->seqnr_lock, irqflags);
-	hsr_ethhdr->hsr_tag.sequence_nr = htons(hsr_priv->sequence_nr);
-	hsr_priv->sequence_nr++;
-	spin_unlock_irqrestore(&hsr_priv->seqnr_lock, irqflags);
+	spin_lock_irqsave(&hsr->seqnr_lock, irqflags);
+	hsr_ethhdr->hsr_tag.sequence_nr = htons(hsr->sequence_nr);
+	hsr->sequence_nr++;
+	spin_unlock_irqrestore(&hsr->seqnr_lock, irqflags);
 
 	hsr_ethhdr->hsr_tag.encap_proto = hsr_ethhdr->ethhdr.h_proto;
 
 	hsr_ethhdr->ethhdr.h_proto = htons(ETH_P_PRP);
 }
 
-static int slave_xmit(struct sk_buff *skb, struct hsr_priv *hsr_priv,
+static int slave_xmit(struct sk_buff *skb, struct hsr_priv *hsr,
 		      enum hsr_dev_idx dev_idx)
 {
 	struct hsr_ethhdr *hsr_ethhdr;
 
 	hsr_ethhdr = (struct hsr_ethhdr *) skb->data;
 
-	skb->dev = hsr_priv->slave[dev_idx];
+	skb->dev = hsr->slave[dev_idx];
 
-	hsr_addr_subst_dest(hsr_priv, &hsr_ethhdr->ethhdr, dev_idx);
+	hsr_addr_subst_dest(hsr, &hsr_ethhdr->ethhdr, dev_idx);
 
 	/* Address substitution (IEC62439-3 pp 26, 50): replace mac
 	 * address of outgoing frame with that of the outgoing slave's.
@@ -217,36 +217,36 @@ static int slave_xmit(struct sk_buff *skb, struct hsr_priv *hsr_priv,
 
 static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 	struct hsr_ethhdr *hsr_ethhdr;
 	struct sk_buff *skb2;
 	int res1, res2;
 
-	hsr_priv = netdev_priv(dev);
+	hsr = netdev_priv(dev);
 	hsr_ethhdr = (struct hsr_ethhdr *) skb->data;
 
 	if ((skb->protocol != htons(ETH_P_PRP)) ||
 	    (hsr_ethhdr->ethhdr.h_proto != htons(ETH_P_PRP))) {
-		hsr_fill_tag(hsr_ethhdr, hsr_priv);
+		hsr_fill_tag(hsr_ethhdr, hsr);
 		skb->protocol = htons(ETH_P_PRP);
 	}
 
 	skb2 = pskb_copy(skb, GFP_ATOMIC);
 
 	res1 = NET_XMIT_DROP;
-	if (likely(hsr_priv->slave[HSR_DEV_SLAVE_A]))
-		res1 = slave_xmit(skb, hsr_priv, HSR_DEV_SLAVE_A);
+	if (likely(hsr->slave[HSR_DEV_SLAVE_A]))
+		res1 = slave_xmit(skb, hsr, HSR_DEV_SLAVE_A);
 
 	res2 = NET_XMIT_DROP;
-	if (likely(skb2 && hsr_priv->slave[HSR_DEV_SLAVE_B]))
-		res2 = slave_xmit(skb2, hsr_priv, HSR_DEV_SLAVE_B);
+	if (likely(skb2 && hsr->slave[HSR_DEV_SLAVE_B]))
+		res2 = slave_xmit(skb2, hsr, HSR_DEV_SLAVE_B);
 
 	if (likely(res1 == NET_XMIT_SUCCESS || res1 == NET_XMIT_CN ||
 		   res2 == NET_XMIT_SUCCESS || res2 == NET_XMIT_CN)) {
-		hsr_priv->dev->stats.tx_packets++;
-		hsr_priv->dev->stats.tx_bytes += skb->len;
+		hsr->dev->stats.tx_packets++;
+		hsr->dev->stats.tx_bytes += skb->len;
 	} else {
-		hsr_priv->dev->stats.tx_dropped++;
+		hsr->dev->stats.tx_dropped++;
 	}
 
 	return NETDEV_TX_OK;
@@ -262,21 +262,21 @@ static int hsr_header_create(struct sk_buff *skb, struct net_device *dev,
 	/* Make room for the HSR tag now. We will fill it in later (in
 	 * hsr_dev_xmit)
 	 */
-	if (skb_headroom(skb) < HSR_TAGLEN + ETH_HLEN)
+	if (skb_headroom(skb) < HSR_HLEN + ETH_HLEN)
 		return -ENOBUFS;
-	skb_push(skb, HSR_TAGLEN);
+	skb_push(skb, HSR_HLEN);
 
 	/* To allow VLAN/HSR combos we should probably use
-	 * res = dev_hard_header(skb, dev, type, daddr, saddr, len + HSR_TAGLEN);
+	 * res = dev_hard_header(skb, dev, type, daddr, saddr, len + HSR_HLEN);
 	 * here instead. It would require other changes too, though - e.g.
 	 * separate headers for each slave etc...
 	 */
-	res = eth_header(skb, dev, type, daddr, saddr, len + HSR_TAGLEN);
+	res = eth_header(skb, dev, type, daddr, saddr, len + HSR_HLEN);
 	if (res <= 0)
 		return res;
 	skb_reset_mac_header(skb);
 
-	return res + HSR_TAGLEN;
+	return res + HSR_HLEN;
 }
 
 
@@ -291,7 +291,7 @@ static const struct header_ops hsr_header_ops = {
  */
 static int hsr_pad(int size)
 {
-	const int min_size = ETH_ZLEN - HSR_TAGLEN - ETH_HLEN;
+	const int min_size = ETH_ZLEN - HSR_HLEN - ETH_HLEN;
 
 	if (size >= min_size)
 		return size;
@@ -300,7 +300,7 @@ static int hsr_pad(int size)
 
 static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 	struct sk_buff *skb;
 	int hlen, tlen;
 	struct hsr_sup_tag *hsr_stag;
@@ -315,7 +315,7 @@ static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
 	if (skb == NULL)
 		return;
 
-	hsr_priv = netdev_priv(hsr_dev);
+	hsr = netdev_priv(hsr_dev);
 
 	skb_reserve(skb, hlen);
 
@@ -324,7 +324,7 @@ static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
 	skb->priority = TC_PRIO_CONTROL;
 
 	if (dev_hard_header(skb, skb->dev, ETH_P_PRP,
-			    hsr_priv->sup_multicast_addr,
+			    hsr->sup_multicast_addr,
 			    skb->dev->dev_addr, skb->len) < 0)
 		goto out;
 
@@ -334,10 +334,10 @@ static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
 	set_hsr_stag_path(hsr_stag, 0xf);
 	set_hsr_stag_HSR_Ver(hsr_stag, 0);
 
-	spin_lock_irqsave(&hsr_priv->seqnr_lock, irqflags);
-	hsr_stag->sequence_nr = htons(hsr_priv->sequence_nr);
-	hsr_priv->sequence_nr++;
-	spin_unlock_irqrestore(&hsr_priv->seqnr_lock, irqflags);
+	spin_lock_irqsave(&hsr->seqnr_lock, irqflags);
+	hsr_stag->sequence_nr = htons(hsr->sequence_nr);
+	hsr->sequence_nr++;
+	spin_unlock_irqrestore(&hsr->seqnr_lock, irqflags);
 
 	hsr_stag->HSR_TLV_Type = type;
 	hsr_stag->HSR_TLV_Length = 12;
@@ -360,48 +360,48 @@ static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
  */
 static void hsr_announce(unsigned long data)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 
-	hsr_priv = (struct hsr_priv *) data;
+	hsr = (struct hsr_priv *) data;
 
-	if (hsr_priv->announce_count < 3) {
-		send_hsr_supervision_frame(hsr_priv->dev, HSR_TLV_ANNOUNCE);
-		hsr_priv->announce_count++;
+	if (hsr->announce_count < 3) {
+		send_hsr_supervision_frame(hsr->dev, HSR_TLV_ANNOUNCE);
+		hsr->announce_count++;
 	} else {
-		send_hsr_supervision_frame(hsr_priv->dev, HSR_TLV_LIFE_CHECK);
+		send_hsr_supervision_frame(hsr->dev, HSR_TLV_LIFE_CHECK);
 	}
 
-	if (hsr_priv->announce_count < 3)
-		hsr_priv->announce_timer.expires = jiffies +
+	if (hsr->announce_count < 3)
+		hsr->announce_timer.expires = jiffies +
 				msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
 	else
-		hsr_priv->announce_timer.expires = jiffies +
+		hsr->announce_timer.expires = jiffies +
 				msecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);
 
-	if (is_admin_up(hsr_priv->dev))
-		add_timer(&hsr_priv->announce_timer);
+	if (is_admin_up(hsr->dev))
+		add_timer(&hsr->announce_timer);
 }
 
 
 static void restore_slaves(struct net_device *hsr_dev)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 	int i;
 	int res;
 
-	hsr_priv = netdev_priv(hsr_dev);
+	hsr = netdev_priv(hsr_dev);
 
 	rtnl_lock();
 
 	/* Restore promiscuity */
 	for (i = 0; i < HSR_MAX_SLAVE; i++) {
-		if (!hsr_priv->slave[i])
+		if (!hsr->slave[i])
 			continue;
-		res = dev_set_promiscuity(hsr_priv->slave[i], -1);
+		res = dev_set_promiscuity(hsr->slave[i], -1);
 		if (res)
 			netdev_info(hsr_dev,
 				    "Cannot restore slave promiscuity (%s, %d)\n",
-				    hsr_priv->slave[i]->name, res);
+				    hsr->slave[i]->name, res);
 	}
 
 	rtnl_unlock();
@@ -409,10 +409,10 @@ static void restore_slaves(struct net_device *hsr_dev)
 
 static void reclaim_hsr_dev(struct rcu_head *rh)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 
-	hsr_priv = container_of(rh, struct hsr_priv, rcu_head);
-	free_netdev(hsr_priv->dev);
+	hsr = container_of(rh, struct hsr_priv, rcu_head);
+	free_netdev(hsr->dev);
 }
 
 
@@ -421,14 +421,14 @@ static void reclaim_hsr_dev(struct rcu_head *rh)
  */
 static void hsr_dev_destroy(struct net_device *hsr_dev)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 
-	hsr_priv = netdev_priv(hsr_dev);
+	hsr = netdev_priv(hsr_dev);
 
-	del_timer(&hsr_priv->announce_timer);
-	unregister_hsr_master(hsr_priv);    /* calls list_del_rcu on hsr_priv */
+	del_timer(&hsr->announce_timer);
+	unregister_hsr_master(hsr);    /* calls list_del_rcu on hsr */
 	restore_slaves(hsr_dev);
-	call_rcu(&hsr_priv->rcu_head, reclaim_hsr_dev);   /* reclaim hsr_priv */
+	call_rcu(&hsr->rcu_head, reclaim_hsr_dev);   /* reclaim hsr */
 }
 
 static const struct net_device_ops hsr_device_ops = {
@@ -500,27 +500,27 @@ static const unsigned char def_multicast_addr[ETH_ALEN] __aligned(2) = {
 int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 		     unsigned char multicast_spec)
 {
-	struct hsr_priv *hsr_priv;
+	struct hsr_priv *hsr;
 	int i;
 	int res;
 
-	hsr_priv = netdev_priv(hsr_dev);
-	hsr_priv->dev = hsr_dev;
-	INIT_LIST_HEAD(&hsr_priv->node_db);
-	INIT_LIST_HEAD(&hsr_priv->self_node_db);
+	hsr = netdev_priv(hsr_dev);
+	hsr->dev = hsr_dev;
+	INIT_LIST_HEAD(&hsr->node_db);
+	INIT_LIST_HEAD(&hsr->self_node_db);
 	for (i = 0; i < HSR_MAX_SLAVE; i++)
-		hsr_priv->slave[i] = slave[i];
+		hsr->slave[i] = slave[i];
 
-	spin_lock_init(&hsr_priv->seqnr_lock);
+	spin_lock_init(&hsr->seqnr_lock);
 	/* Overflow soon to find bugs easier: */
-	hsr_priv->sequence_nr = USHRT_MAX - 1024;
+	hsr->sequence_nr = USHRT_MAX - 1024;
 
-	init_timer(&hsr_priv->announce_timer);
-	hsr_priv->announce_timer.function = hsr_announce;
-	hsr_priv->announce_timer.data = (unsigned long) hsr_priv;
+	init_timer(&hsr->announce_timer);
+	hsr->announce_timer.function = hsr_announce;
+	hsr->announce_timer.data = (unsigned long) hsr;
 
-	ether_addr_copy(hsr_priv->sup_multicast_addr, def_multicast_addr);
-	hsr_priv->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
+	ether_addr_copy(hsr->sup_multicast_addr, def_multicast_addr);
+	hsr->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
 
 /* FIXME: should I modify the value of these?
  *
@@ -547,20 +547,20 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	hsr_dev->features |= NETIF_F_VLAN_CHALLENGED;
 
 	/* Set hsr_dev's MAC address to that of mac_slave1 */
-	ether_addr_copy(hsr_dev->dev_addr, hsr_priv->slave[0]->dev_addr);
+	ether_addr_copy(hsr_dev->dev_addr, hsr->slave[0]->dev_addr);
 
 	/* Set required header length */
 	for (i = 0; i < HSR_MAX_SLAVE; i++) {
-		if (slave[i]->hard_header_len + HSR_TAGLEN >
+		if (slave[i]->hard_header_len + HSR_HLEN >
 						hsr_dev->hard_header_len)
 			hsr_dev->hard_header_len =
-					slave[i]->hard_header_len + HSR_TAGLEN;
+					slave[i]->hard_header_len + HSR_HLEN;
 	}
 
 	/* MTU */
 	for (i = 0; i < HSR_MAX_SLAVE; i++)
-		if (slave[i]->mtu - HSR_TAGLEN < hsr_dev->mtu)
-			hsr_dev->mtu = slave[i]->mtu - HSR_TAGLEN;
+		if (slave[i]->mtu - HSR_HLEN < hsr_dev->mtu)
+			hsr_dev->mtu = slave[i]->mtu - HSR_HLEN;
 
 	/* Make sure the 1st call to netif_carrier_on() gets through */
 	netif_carrier_off(hsr_dev);
@@ -576,9 +576,8 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	}
 
 	/* Make sure we recognize frames from ourselves in hsr_rcv() */
-	res = hsr_create_self_node(&hsr_priv->self_node_db,
-					hsr_dev->dev_addr,
-					hsr_priv->slave[1]->dev_addr);
+	res = hsr_create_self_node(&hsr->self_node_db, hsr_dev->dev_addr,
+				   hsr->slave[1]->dev_addr);
 	if (res < 0)
 		goto fail;
 
@@ -586,7 +585,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	if (res)
 		goto fail;
 
-	register_hsr_master(hsr_priv);
+	register_hsr_master(hsr);
 
 	return 0;
 

commit e83abe37ba492514943f45f7bb1ba6b055eb88b0
Author: Joe Perches <joe@perches.com>
Date:   Tue Feb 18 10:37:20 2014 -0800

    hsr: Use ether_addr_copy
    
    It's slightly smaller/faster for some architectures.
    Make sure def_multicast_addr is __aligned(2)
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
index cac505f166d5..e5302b7f7ca9 100644
--- a/net/hsr/hsr_device.c
+++ b/net/hsr/hsr_device.c
@@ -209,7 +209,7 @@ static int slave_xmit(struct sk_buff *skb, struct hsr_priv *hsr_priv,
 	/* Address substitution (IEC62439-3 pp 26, 50): replace mac
 	 * address of outgoing frame with that of the outgoing slave's.
 	 */
-	memcpy(hsr_ethhdr->ethhdr.h_source, skb->dev->dev_addr, ETH_ALEN);
+	ether_addr_copy(hsr_ethhdr->ethhdr.h_source, skb->dev->dev_addr);
 
 	return dev_queue_xmit(skb);
 }
@@ -346,7 +346,7 @@ static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
 
 	/* Payload: MacAddressA */
 	hsr_sp = (typeof(hsr_sp)) skb_put(skb, sizeof(*hsr_sp));
-	memcpy(hsr_sp->MacAddressA, hsr_dev->dev_addr, ETH_ALEN);
+	ether_addr_copy(hsr_sp->MacAddressA, hsr_dev->dev_addr);
 
 	dev_queue_xmit(skb);
 	return;
@@ -493,7 +493,7 @@ static int check_slave_ok(struct net_device *dev)
 
 
 /* Default multicast address for HSR Supervision frames */
-static const unsigned char def_multicast_addr[ETH_ALEN] = {
+static const unsigned char def_multicast_addr[ETH_ALEN] __aligned(2) = {
 	0x01, 0x15, 0x4e, 0x00, 0x01, 0x00
 };
 
@@ -519,7 +519,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	hsr_priv->announce_timer.function = hsr_announce;
 	hsr_priv->announce_timer.data = (unsigned long) hsr_priv;
 
-	memcpy(hsr_priv->sup_multicast_addr, def_multicast_addr, ETH_ALEN);
+	ether_addr_copy(hsr_priv->sup_multicast_addr, def_multicast_addr);
 	hsr_priv->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
 
 /* FIXME: should I modify the value of these?
@@ -547,7 +547,7 @@ int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
 	hsr_dev->features |= NETIF_F_VLAN_CHALLENGED;
 
 	/* Set hsr_dev's MAC address to that of mac_slave1 */
-	memcpy(hsr_dev->dev_addr, hsr_priv->slave[0]->dev_addr, ETH_ALEN);
+	ether_addr_copy(hsr_dev->dev_addr, hsr_priv->slave[0]->dev_addr);
 
 	/* Set required header length */
 	for (i = 0; i < HSR_MAX_SLAVE; i++) {

commit f421436a591d34fa5279b54a96ac07d70250cc8d
Author: Arvid Brodin <Arvid.Brodin@xdin.com>
Date:   Wed Oct 30 21:10:47 2013 +0100

    net/hsr: Add support for the High-availability Seamless Redundancy protocol (HSRv0)
    
    High-availability Seamless Redundancy ("HSR") provides instant failover
    redundancy for Ethernet networks. It requires a special network topology where
    all nodes are connected in a ring (each node having two physical network
    interfaces). It is suited for applications that demand high availability and
    very short reaction time.
    
    HSR acts on the Ethernet layer, using a registered Ethernet protocol type to
    send special HSR frames in both directions over the ring. The driver creates
    virtual network interfaces that can be used just like any ordinary Linux
    network interface, for IP/TCP/UDP traffic etc. All nodes in the network ring
    must be HSR capable.
    
    This code is a "best effort" to comply with the HSR standard as described in
    IEC 62439-3:2010 (HSRv0).
    
    Signed-off-by: Arvid Brodin <arvid.brodin@xdin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_device.c b/net/hsr/hsr_device.c
new file mode 100644
index 000000000000..cac505f166d5
--- /dev/null
+++ b/net/hsr/hsr_device.c
@@ -0,0 +1,596 @@
+/* Copyright 2011-2013 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2013 Arvid Brodin, arvid.brodin@xdin.com
+ *
+ * This file contains device methods for creating, using and destroying
+ * virtual HSR devices.
+ */
+
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/etherdevice.h>
+#include <linux/if_arp.h>
+#include <linux/rtnetlink.h>
+#include <linux/pkt_sched.h>
+#include "hsr_device.h"
+#include "hsr_framereg.h"
+#include "hsr_main.h"
+
+
+static bool is_admin_up(struct net_device *dev)
+{
+	return dev && (dev->flags & IFF_UP);
+}
+
+static bool is_slave_up(struct net_device *dev)
+{
+	return dev && is_admin_up(dev) && netif_oper_up(dev);
+}
+
+static void __hsr_set_operstate(struct net_device *dev, int transition)
+{
+	write_lock_bh(&dev_base_lock);
+	if (dev->operstate != transition) {
+		dev->operstate = transition;
+		write_unlock_bh(&dev_base_lock);
+		netdev_state_change(dev);
+	} else {
+		write_unlock_bh(&dev_base_lock);
+	}
+}
+
+void hsr_set_operstate(struct net_device *hsr_dev, struct net_device *slave1,
+		       struct net_device *slave2)
+{
+	if (!is_admin_up(hsr_dev)) {
+		__hsr_set_operstate(hsr_dev, IF_OPER_DOWN);
+		return;
+	}
+
+	if (is_slave_up(slave1) || is_slave_up(slave2))
+		__hsr_set_operstate(hsr_dev, IF_OPER_UP);
+	else
+		__hsr_set_operstate(hsr_dev, IF_OPER_LOWERLAYERDOWN);
+}
+
+void hsr_set_carrier(struct net_device *hsr_dev, struct net_device *slave1,
+		     struct net_device *slave2)
+{
+	if (is_slave_up(slave1) || is_slave_up(slave2))
+		netif_carrier_on(hsr_dev);
+	else
+		netif_carrier_off(hsr_dev);
+}
+
+
+void hsr_check_announce(struct net_device *hsr_dev, int old_operstate)
+{
+	struct hsr_priv *hsr_priv;
+
+	hsr_priv = netdev_priv(hsr_dev);
+
+	if ((hsr_dev->operstate == IF_OPER_UP) && (old_operstate != IF_OPER_UP)) {
+		/* Went up */
+		hsr_priv->announce_count = 0;
+		hsr_priv->announce_timer.expires = jiffies +
+				msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
+		add_timer(&hsr_priv->announce_timer);
+	}
+
+	if ((hsr_dev->operstate != IF_OPER_UP) && (old_operstate == IF_OPER_UP))
+		/* Went down */
+		del_timer(&hsr_priv->announce_timer);
+}
+
+
+int hsr_get_max_mtu(struct hsr_priv *hsr_priv)
+{
+	int mtu_max;
+
+	if (hsr_priv->slave[0] && hsr_priv->slave[1])
+		mtu_max = min(hsr_priv->slave[0]->mtu, hsr_priv->slave[1]->mtu);
+	else if (hsr_priv->slave[0])
+		mtu_max = hsr_priv->slave[0]->mtu;
+	else if (hsr_priv->slave[1])
+		mtu_max = hsr_priv->slave[1]->mtu;
+	else
+		mtu_max = HSR_TAGLEN;
+
+	return mtu_max - HSR_TAGLEN;
+}
+
+static int hsr_dev_change_mtu(struct net_device *dev, int new_mtu)
+{
+	struct hsr_priv *hsr_priv;
+
+	hsr_priv = netdev_priv(dev);
+
+	if (new_mtu > hsr_get_max_mtu(hsr_priv)) {
+		netdev_info(hsr_priv->dev, "A HSR master's MTU cannot be greater than the smallest MTU of its slaves minus the HSR Tag length (%d octets).\n",
+			    HSR_TAGLEN);
+		return -EINVAL;
+	}
+
+	dev->mtu = new_mtu;
+
+	return 0;
+}
+
+static int hsr_dev_open(struct net_device *dev)
+{
+	struct hsr_priv *hsr_priv;
+	int i;
+	char *slave_name;
+
+	hsr_priv = netdev_priv(dev);
+
+	for (i = 0; i < HSR_MAX_SLAVE; i++) {
+		if (hsr_priv->slave[i])
+			slave_name = hsr_priv->slave[i]->name;
+		else
+			slave_name = "null";
+
+		if (!is_slave_up(hsr_priv->slave[i]))
+			netdev_warn(dev, "Slave %c (%s) is not up; please bring it up to get a working HSR network\n",
+				    'A' + i, slave_name);
+	}
+
+	return 0;
+}
+
+static int hsr_dev_close(struct net_device *dev)
+{
+	/* Nothing to do here. We could try to restore the state of the slaves
+	 * to what they were before being changed by the hsr master dev's state,
+	 * but they might have been changed manually in the mean time too, so
+	 * taking them up or down here might be confusing and is probably not a
+	 * good idea.
+	 */
+	return 0;
+}
+
+
+static void hsr_fill_tag(struct hsr_ethhdr *hsr_ethhdr, struct hsr_priv *hsr_priv)
+{
+	unsigned long irqflags;
+
+	/* IEC 62439-1:2010, p 48, says the 4-bit "path" field can take values
+	 * between 0001-1001 ("ring identifier", for regular HSR frames),
+	 * or 1111 ("HSR management", supervision frames). Unfortunately, the
+	 * spec writers forgot to explain what a "ring identifier" is, or
+	 * how it is used. So we just set this to 0001 for regular frames,
+	 * and 1111 for supervision frames.
+	 */
+	set_hsr_tag_path(&hsr_ethhdr->hsr_tag, 0x1);
+
+	/* IEC 62439-1:2010, p 12: "The link service data unit in an Ethernet
+	 * frame is the content of the frame located between the Length/Type
+	 * field and the Frame Check Sequence."
+	 *
+	 * IEC 62439-3, p 48, specifies the "original LPDU" to include the
+	 * original "LT" field (what "LT" means is not explained anywhere as
+	 * far as I can see - perhaps "Length/Type"?). So LSDU_size might
+	 * equal original length + 2.
+	 *   Also, the fact that this field is not used anywhere (might be used
+	 * by a RedBox connecting HSR and PRP nets?) means I cannot test its
+	 * correctness. Instead of guessing, I set this to 0 here, to make any
+	 * problems immediately apparent. Anyone using this driver with PRP/HSR
+	 * RedBoxes might need to fix this...
+	 */
+	set_hsr_tag_LSDU_size(&hsr_ethhdr->hsr_tag, 0);
+
+	spin_lock_irqsave(&hsr_priv->seqnr_lock, irqflags);
+	hsr_ethhdr->hsr_tag.sequence_nr = htons(hsr_priv->sequence_nr);
+	hsr_priv->sequence_nr++;
+	spin_unlock_irqrestore(&hsr_priv->seqnr_lock, irqflags);
+
+	hsr_ethhdr->hsr_tag.encap_proto = hsr_ethhdr->ethhdr.h_proto;
+
+	hsr_ethhdr->ethhdr.h_proto = htons(ETH_P_PRP);
+}
+
+static int slave_xmit(struct sk_buff *skb, struct hsr_priv *hsr_priv,
+		      enum hsr_dev_idx dev_idx)
+{
+	struct hsr_ethhdr *hsr_ethhdr;
+
+	hsr_ethhdr = (struct hsr_ethhdr *) skb->data;
+
+	skb->dev = hsr_priv->slave[dev_idx];
+
+	hsr_addr_subst_dest(hsr_priv, &hsr_ethhdr->ethhdr, dev_idx);
+
+	/* Address substitution (IEC62439-3 pp 26, 50): replace mac
+	 * address of outgoing frame with that of the outgoing slave's.
+	 */
+	memcpy(hsr_ethhdr->ethhdr.h_source, skb->dev->dev_addr, ETH_ALEN);
+
+	return dev_queue_xmit(skb);
+}
+
+
+static int hsr_dev_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct hsr_priv *hsr_priv;
+	struct hsr_ethhdr *hsr_ethhdr;
+	struct sk_buff *skb2;
+	int res1, res2;
+
+	hsr_priv = netdev_priv(dev);
+	hsr_ethhdr = (struct hsr_ethhdr *) skb->data;
+
+	if ((skb->protocol != htons(ETH_P_PRP)) ||
+	    (hsr_ethhdr->ethhdr.h_proto != htons(ETH_P_PRP))) {
+		hsr_fill_tag(hsr_ethhdr, hsr_priv);
+		skb->protocol = htons(ETH_P_PRP);
+	}
+
+	skb2 = pskb_copy(skb, GFP_ATOMIC);
+
+	res1 = NET_XMIT_DROP;
+	if (likely(hsr_priv->slave[HSR_DEV_SLAVE_A]))
+		res1 = slave_xmit(skb, hsr_priv, HSR_DEV_SLAVE_A);
+
+	res2 = NET_XMIT_DROP;
+	if (likely(skb2 && hsr_priv->slave[HSR_DEV_SLAVE_B]))
+		res2 = slave_xmit(skb2, hsr_priv, HSR_DEV_SLAVE_B);
+
+	if (likely(res1 == NET_XMIT_SUCCESS || res1 == NET_XMIT_CN ||
+		   res2 == NET_XMIT_SUCCESS || res2 == NET_XMIT_CN)) {
+		hsr_priv->dev->stats.tx_packets++;
+		hsr_priv->dev->stats.tx_bytes += skb->len;
+	} else {
+		hsr_priv->dev->stats.tx_dropped++;
+	}
+
+	return NETDEV_TX_OK;
+}
+
+
+static int hsr_header_create(struct sk_buff *skb, struct net_device *dev,
+			     unsigned short type, const void *daddr,
+			     const void *saddr, unsigned int len)
+{
+	int res;
+
+	/* Make room for the HSR tag now. We will fill it in later (in
+	 * hsr_dev_xmit)
+	 */
+	if (skb_headroom(skb) < HSR_TAGLEN + ETH_HLEN)
+		return -ENOBUFS;
+	skb_push(skb, HSR_TAGLEN);
+
+	/* To allow VLAN/HSR combos we should probably use
+	 * res = dev_hard_header(skb, dev, type, daddr, saddr, len + HSR_TAGLEN);
+	 * here instead. It would require other changes too, though - e.g.
+	 * separate headers for each slave etc...
+	 */
+	res = eth_header(skb, dev, type, daddr, saddr, len + HSR_TAGLEN);
+	if (res <= 0)
+		return res;
+	skb_reset_mac_header(skb);
+
+	return res + HSR_TAGLEN;
+}
+
+
+static const struct header_ops hsr_header_ops = {
+	.create	 = hsr_header_create,
+	.parse	 = eth_header_parse,
+};
+
+
+/* HSR:2010 supervision frames should be padded so that the whole frame,
+ * including headers and FCS, is 64 bytes (without VLAN).
+ */
+static int hsr_pad(int size)
+{
+	const int min_size = ETH_ZLEN - HSR_TAGLEN - ETH_HLEN;
+
+	if (size >= min_size)
+		return size;
+	return min_size;
+}
+
+static void send_hsr_supervision_frame(struct net_device *hsr_dev, u8 type)
+{
+	struct hsr_priv *hsr_priv;
+	struct sk_buff *skb;
+	int hlen, tlen;
+	struct hsr_sup_tag *hsr_stag;
+	struct hsr_sup_payload *hsr_sp;
+	unsigned long irqflags;
+
+	hlen = LL_RESERVED_SPACE(hsr_dev);
+	tlen = hsr_dev->needed_tailroom;
+	skb = alloc_skb(hsr_pad(sizeof(struct hsr_sup_payload)) + hlen + tlen,
+			GFP_ATOMIC);
+
+	if (skb == NULL)
+		return;
+
+	hsr_priv = netdev_priv(hsr_dev);
+
+	skb_reserve(skb, hlen);
+
+	skb->dev = hsr_dev;
+	skb->protocol = htons(ETH_P_PRP);
+	skb->priority = TC_PRIO_CONTROL;
+
+	if (dev_hard_header(skb, skb->dev, ETH_P_PRP,
+			    hsr_priv->sup_multicast_addr,
+			    skb->dev->dev_addr, skb->len) < 0)
+		goto out;
+
+	skb_pull(skb, sizeof(struct ethhdr));
+	hsr_stag = (typeof(hsr_stag)) skb->data;
+
+	set_hsr_stag_path(hsr_stag, 0xf);
+	set_hsr_stag_HSR_Ver(hsr_stag, 0);
+
+	spin_lock_irqsave(&hsr_priv->seqnr_lock, irqflags);
+	hsr_stag->sequence_nr = htons(hsr_priv->sequence_nr);
+	hsr_priv->sequence_nr++;
+	spin_unlock_irqrestore(&hsr_priv->seqnr_lock, irqflags);
+
+	hsr_stag->HSR_TLV_Type = type;
+	hsr_stag->HSR_TLV_Length = 12;
+
+	skb_push(skb, sizeof(struct ethhdr));
+
+	/* Payload: MacAddressA */
+	hsr_sp = (typeof(hsr_sp)) skb_put(skb, sizeof(*hsr_sp));
+	memcpy(hsr_sp->MacAddressA, hsr_dev->dev_addr, ETH_ALEN);
+
+	dev_queue_xmit(skb);
+	return;
+
+out:
+	kfree_skb(skb);
+}
+
+
+/* Announce (supervision frame) timer function
+ */
+static void hsr_announce(unsigned long data)
+{
+	struct hsr_priv *hsr_priv;
+
+	hsr_priv = (struct hsr_priv *) data;
+
+	if (hsr_priv->announce_count < 3) {
+		send_hsr_supervision_frame(hsr_priv->dev, HSR_TLV_ANNOUNCE);
+		hsr_priv->announce_count++;
+	} else {
+		send_hsr_supervision_frame(hsr_priv->dev, HSR_TLV_LIFE_CHECK);
+	}
+
+	if (hsr_priv->announce_count < 3)
+		hsr_priv->announce_timer.expires = jiffies +
+				msecs_to_jiffies(HSR_ANNOUNCE_INTERVAL);
+	else
+		hsr_priv->announce_timer.expires = jiffies +
+				msecs_to_jiffies(HSR_LIFE_CHECK_INTERVAL);
+
+	if (is_admin_up(hsr_priv->dev))
+		add_timer(&hsr_priv->announce_timer);
+}
+
+
+static void restore_slaves(struct net_device *hsr_dev)
+{
+	struct hsr_priv *hsr_priv;
+	int i;
+	int res;
+
+	hsr_priv = netdev_priv(hsr_dev);
+
+	rtnl_lock();
+
+	/* Restore promiscuity */
+	for (i = 0; i < HSR_MAX_SLAVE; i++) {
+		if (!hsr_priv->slave[i])
+			continue;
+		res = dev_set_promiscuity(hsr_priv->slave[i], -1);
+		if (res)
+			netdev_info(hsr_dev,
+				    "Cannot restore slave promiscuity (%s, %d)\n",
+				    hsr_priv->slave[i]->name, res);
+	}
+
+	rtnl_unlock();
+}
+
+static void reclaim_hsr_dev(struct rcu_head *rh)
+{
+	struct hsr_priv *hsr_priv;
+
+	hsr_priv = container_of(rh, struct hsr_priv, rcu_head);
+	free_netdev(hsr_priv->dev);
+}
+
+
+/* According to comments in the declaration of struct net_device, this function
+ * is "Called from unregister, can be used to call free_netdev". Ok then...
+ */
+static void hsr_dev_destroy(struct net_device *hsr_dev)
+{
+	struct hsr_priv *hsr_priv;
+
+	hsr_priv = netdev_priv(hsr_dev);
+
+	del_timer(&hsr_priv->announce_timer);
+	unregister_hsr_master(hsr_priv);    /* calls list_del_rcu on hsr_priv */
+	restore_slaves(hsr_dev);
+	call_rcu(&hsr_priv->rcu_head, reclaim_hsr_dev);   /* reclaim hsr_priv */
+}
+
+static const struct net_device_ops hsr_device_ops = {
+	.ndo_change_mtu = hsr_dev_change_mtu,
+	.ndo_open = hsr_dev_open,
+	.ndo_stop = hsr_dev_close,
+	.ndo_start_xmit = hsr_dev_xmit,
+};
+
+
+void hsr_dev_setup(struct net_device *dev)
+{
+	random_ether_addr(dev->dev_addr);
+
+	ether_setup(dev);
+	dev->header_ops		 = &hsr_header_ops;
+	dev->netdev_ops		 = &hsr_device_ops;
+	dev->tx_queue_len	 = 0;
+
+	dev->destructor = hsr_dev_destroy;
+}
+
+
+/* Return true if dev is a HSR master; return false otherwise.
+ */
+bool is_hsr_master(struct net_device *dev)
+{
+	return (dev->netdev_ops->ndo_start_xmit == hsr_dev_xmit);
+}
+
+static int check_slave_ok(struct net_device *dev)
+{
+	/* Don't allow HSR on non-ethernet like devices */
+	if ((dev->flags & IFF_LOOPBACK) || (dev->type != ARPHRD_ETHER) ||
+	    (dev->addr_len != ETH_ALEN)) {
+		netdev_info(dev, "Cannot use loopback or non-ethernet device as HSR slave.\n");
+		return -EINVAL;
+	}
+
+	/* Don't allow enslaving hsr devices */
+	if (is_hsr_master(dev)) {
+		netdev_info(dev, "Cannot create trees of HSR devices.\n");
+		return -EINVAL;
+	}
+
+	if (is_hsr_slave(dev)) {
+		netdev_info(dev, "This device is already a HSR slave.\n");
+		return -EINVAL;
+	}
+
+	if (dev->priv_flags & IFF_802_1Q_VLAN) {
+		netdev_info(dev, "HSR on top of VLAN is not yet supported in this driver.\n");
+		return -EINVAL;
+	}
+
+	/* HSR over bonded devices has not been tested, but I'm not sure it
+	 * won't work...
+	 */
+
+	return 0;
+}
+
+
+/* Default multicast address for HSR Supervision frames */
+static const unsigned char def_multicast_addr[ETH_ALEN] = {
+	0x01, 0x15, 0x4e, 0x00, 0x01, 0x00
+};
+
+int hsr_dev_finalize(struct net_device *hsr_dev, struct net_device *slave[2],
+		     unsigned char multicast_spec)
+{
+	struct hsr_priv *hsr_priv;
+	int i;
+	int res;
+
+	hsr_priv = netdev_priv(hsr_dev);
+	hsr_priv->dev = hsr_dev;
+	INIT_LIST_HEAD(&hsr_priv->node_db);
+	INIT_LIST_HEAD(&hsr_priv->self_node_db);
+	for (i = 0; i < HSR_MAX_SLAVE; i++)
+		hsr_priv->slave[i] = slave[i];
+
+	spin_lock_init(&hsr_priv->seqnr_lock);
+	/* Overflow soon to find bugs easier: */
+	hsr_priv->sequence_nr = USHRT_MAX - 1024;
+
+	init_timer(&hsr_priv->announce_timer);
+	hsr_priv->announce_timer.function = hsr_announce;
+	hsr_priv->announce_timer.data = (unsigned long) hsr_priv;
+
+	memcpy(hsr_priv->sup_multicast_addr, def_multicast_addr, ETH_ALEN);
+	hsr_priv->sup_multicast_addr[ETH_ALEN - 1] = multicast_spec;
+
+/* FIXME: should I modify the value of these?
+ *
+ * - hsr_dev->flags - i.e.
+ *			IFF_MASTER/SLAVE?
+ * - hsr_dev->priv_flags - i.e.
+ *			IFF_EBRIDGE?
+ *			IFF_TX_SKB_SHARING?
+ *			IFF_HSR_MASTER/SLAVE?
+ */
+
+	for (i = 0; i < HSR_MAX_SLAVE; i++) {
+		res = check_slave_ok(slave[i]);
+		if (res)
+			return res;
+	}
+
+	hsr_dev->features = slave[0]->features & slave[1]->features;
+	/* Prevent recursive tx locking */
+	hsr_dev->features |= NETIF_F_LLTX;
+	/* VLAN on top of HSR needs testing and probably some work on
+	 * hsr_header_create() etc.
+	 */
+	hsr_dev->features |= NETIF_F_VLAN_CHALLENGED;
+
+	/* Set hsr_dev's MAC address to that of mac_slave1 */
+	memcpy(hsr_dev->dev_addr, hsr_priv->slave[0]->dev_addr, ETH_ALEN);
+
+	/* Set required header length */
+	for (i = 0; i < HSR_MAX_SLAVE; i++) {
+		if (slave[i]->hard_header_len + HSR_TAGLEN >
+						hsr_dev->hard_header_len)
+			hsr_dev->hard_header_len =
+					slave[i]->hard_header_len + HSR_TAGLEN;
+	}
+
+	/* MTU */
+	for (i = 0; i < HSR_MAX_SLAVE; i++)
+		if (slave[i]->mtu - HSR_TAGLEN < hsr_dev->mtu)
+			hsr_dev->mtu = slave[i]->mtu - HSR_TAGLEN;
+
+	/* Make sure the 1st call to netif_carrier_on() gets through */
+	netif_carrier_off(hsr_dev);
+
+	/* Promiscuity */
+	for (i = 0; i < HSR_MAX_SLAVE; i++) {
+		res = dev_set_promiscuity(slave[i], 1);
+		if (res) {
+			netdev_info(hsr_dev, "Cannot set slave promiscuity (%s, %d)\n",
+				    slave[i]->name, res);
+			goto fail;
+		}
+	}
+
+	/* Make sure we recognize frames from ourselves in hsr_rcv() */
+	res = hsr_create_self_node(&hsr_priv->self_node_db,
+					hsr_dev->dev_addr,
+					hsr_priv->slave[1]->dev_addr);
+	if (res < 0)
+		goto fail;
+
+	res = register_netdevice(hsr_dev);
+	if (res)
+		goto fail;
+
+	register_hsr_master(hsr_priv);
+
+	return 0;
+
+fail:
+	restore_slaves(hsr_dev);
+	return res;
+}
