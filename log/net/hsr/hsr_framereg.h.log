commit 92a35678ec075100ce666a2fb6969151affb0e5d
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Sun Dec 22 11:26:54 2019 +0000

    hsr: fix a race condition in node list insertion and deletion
    
    hsr nodes are protected by RCU and there is no write side lock.
    But node insertions and deletions could be being operated concurrently.
    So write side locking is needed.
    
    Test commands:
        ip netns add nst
        ip link add veth0 type veth peer name veth1
        ip link add veth2 type veth peer name veth3
        ip link set veth1 netns nst
        ip link set veth3 netns nst
        ip link set veth0 up
        ip link set veth2 up
        ip link add hsr0 type hsr slave1 veth0 slave2 veth2
        ip a a 192.168.100.1/24 dev hsr0
        ip link set hsr0 up
        ip netns exec nst ip link set veth1 up
        ip netns exec nst ip link set veth3 up
        ip netns exec nst ip link add hsr1 type hsr slave1 veth1 slave2 veth3
        ip netns exec nst ip a a 192.168.100.2/24 dev hsr1
        ip netns exec nst ip link set hsr1 up
    
        for i in {0..9}
        do
            for j in {0..9}
            do
                for k in {0..9}
                do
                    for l in {0..9}
                    do
                    arping 192.168.100.2 -I hsr0 -s 00:01:3$i:4$j:5$k:6$l -c1 &
                    done
                done
            done
        done
    
    Splat looks like:
    [  236.066091][ T3286] list_add corruption. next->prev should be prev (ffff8880a5940300), but was ffff8880a5940d0.
    [  236.069617][ T3286] ------------[ cut here ]------------
    [  236.070545][ T3286] kernel BUG at lib/list_debug.c:25!
    [  236.071391][ T3286] invalid opcode: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [  236.072343][ T3286] CPU: 0 PID: 3286 Comm: arping Tainted: G        W         5.5.0-rc1+ #209
    [  236.073463][ T3286] Hardware name: innotek GmbH VirtualBox/VirtualBox, BIOS VirtualBox 12/01/2006
    [  236.074695][ T3286] RIP: 0010:__list_add_valid+0x74/0xd0
    [  236.075499][ T3286] Code: 48 39 da 75 27 48 39 f5 74 36 48 39 dd 74 31 48 83 c4 08 b8 01 00 00 00 5b 5d c3 48 b
    [  236.078277][ T3286] RSP: 0018:ffff8880aaa97648 EFLAGS: 00010286
    [  236.086991][ T3286] RAX: 0000000000000075 RBX: ffff8880d4624c20 RCX: 0000000000000000
    [  236.088000][ T3286] RDX: 0000000000000075 RSI: 0000000000000008 RDI: ffffed1015552ebf
    [  236.098897][ T3286] RBP: ffff88809b53d200 R08: ffffed101b3c04f9 R09: ffffed101b3c04f9
    [  236.099960][ T3286] R10: 00000000308769a1 R11: ffffed101b3c04f8 R12: ffff8880d4624c28
    [  236.100974][ T3286] R13: ffff8880d4624c20 R14: 0000000040310100 R15: ffff8880ce17ee02
    [  236.138967][ T3286] FS:  00007f23479fa680(0000) GS:ffff8880d9c00000(0000) knlGS:0000000000000000
    [  236.144852][ T3286] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  236.145720][ T3286] CR2: 00007f4a14bab210 CR3: 00000000a61c6001 CR4: 00000000000606f0
    [  236.146776][ T3286] Call Trace:
    [  236.147222][ T3286]  hsr_add_node+0x314/0x490 [hsr]
    [  236.153633][ T3286]  hsr_forward_skb+0x2b6/0x1bc0 [hsr]
    [  236.154362][ T3286]  ? rcu_read_lock_sched_held+0x90/0xc0
    [  236.155091][ T3286]  ? rcu_read_lock_bh_held+0xa0/0xa0
    [  236.156607][ T3286]  hsr_dev_xmit+0x70/0xd0 [hsr]
    [  236.157254][ T3286]  dev_hard_start_xmit+0x160/0x740
    [  236.157941][ T3286]  __dev_queue_xmit+0x1961/0x2e10
    [  236.158565][ T3286]  ? netdev_core_pick_tx+0x2e0/0x2e0
    [ ... ]
    
    Reported-by: syzbot+3924327f9ad5f4d2b343@syzkaller.appspotmail.com
    Fixes: f421436a591d ("net/hsr: Add support for the High-availability Seamless Redundancy protocol (HSRv0)")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index 89a3ce38151d..0f0fa12b4329 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -12,10 +12,8 @@
 
 struct hsr_node;
 
-void hsr_del_self_node(struct list_head *self_node_db);
+void hsr_del_self_node(struct hsr_priv *hsr);
 void hsr_del_nodes(struct list_head *node_db);
-struct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],
-			      u16 seq_out);
 struct hsr_node *hsr_get_node(struct hsr_port *port, struct sk_buff *skb,
 			      bool is_sup);
 void hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,
@@ -33,7 +31,7 @@ int hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,
 
 void hsr_prune_nodes(struct timer_list *t);
 
-int hsr_create_self_node(struct list_head *self_node_db,
+int hsr_create_self_node(struct hsr_priv *hsr,
 			 unsigned char addr_a[ETH_ALEN],
 			 unsigned char addr_b[ETH_ALEN]);
 

commit b9a1e627405d68d475a3c1f35e685ccfb5bbe668
Author: Cong Wang <xiyou.wangcong@gmail.com>
Date:   Wed Jul 3 17:21:13 2019 -0700

    hsr: implement dellink to clean up resources
    
    hsr_link_ops implements ->newlink() but not ->dellink(),
    which leads that resources not released after removing the device,
    particularly the entries in self_node_db and node_db.
    
    So add ->dellink() implementation to replace the priv_destructor.
    This also makes the code slightly easier to understand.
    
    Reported-by: syzbot+c6167ec3de7def23d1e8@syzkaller.appspotmail.com
    Cc: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: Cong Wang <xiyou.wangcong@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index a3bdcdab469d..89a3ce38151d 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -12,7 +12,8 @@
 
 struct hsr_node;
 
-void hsr_del_node(struct list_head *self_node_db);
+void hsr_del_self_node(struct list_head *self_node_db);
+void hsr_del_nodes(struct list_head *node_db);
 struct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],
 			      u16 seq_out);
 struct hsr_node *hsr_get_node(struct hsr_port *port, struct sk_buff *skb,

commit fc4ecaeebd26c77d463c898d9dd3edee234e371c
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:35 2019 -0400

    net: hsr: add debugfs support for display node list
    
    This adds a debugfs interface to allow display the nodes learned
    by the hsr master.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index 5f515d4cd088..a3bdcdab469d 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -48,4 +48,16 @@ int hsr_get_node_data(struct hsr_priv *hsr,
 		      int *if2_age,
 		      u16 *if2_seq);
 
+struct hsr_node {
+	struct list_head	mac_list;
+	unsigned char		macaddress_A[ETH_ALEN];
+	unsigned char		macaddress_B[ETH_ALEN];
+	/* Local slave through which AddrB frames are received from this node */
+	enum hsr_port_type	addr_B_port;
+	unsigned long		time_in[HSR_PT_PORTS];
+	bool			time_in_stale[HSR_PT_PORTS];
+	u16			seq_out[HSR_PT_PORTS];
+	struct rcu_head		rcu_head;
+};
+
 #endif /* __HSR_FRAMEREG_H */

commit 0e7623bdf34fff6587f96c27132aebe8c585631d
Author: Murali Karicheri <m-karicheri2@ti.com>
Date:   Fri Apr 5 13:31:34 2019 -0400

    net: hsr: convert to SPDX identifier
    
    Use SPDX-License-Identifier instead of a verbose license text.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index 531fd3dfcac1..5f515d4cd088 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -1,9 +1,5 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /* Copyright 2011-2014 Autronica Fire and Security AS
- *
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the Free
- * Software Foundation; either version 2 of the License, or (at your option)
- * any later version.
  *
  * Author(s):
  *	2011-2014 Arvid Brodin, arvid.brodin@alten.se

commit 6caabe7f197d3466d238f70915d65301f1716626
Author: Mao Wenan <maowenan@huawei.com>
Date:   Wed Mar 6 22:45:01 2019 +0800

    net: hsr: fix memory leak in hsr_dev_finalize()
    
    If hsr_add_port(hsr, hsr_dev, HSR_PT_MASTER) failed to
    add port, it directly returns res and forgets to free the node
    that allocated in hsr_create_self_node(), and forgets to delete
    the node->mac_list linked in hsr->self_node_db.
    
    BUG: memory leak
    unreferenced object 0xffff8881cfa0c780 (size 64):
      comm "syz-executor.0", pid 2077, jiffies 4294717969 (age 2415.377s)
      hex dump (first 32 bytes):
        e0 c7 a0 cf 81 88 ff ff 00 02 00 00 00 00 ad de  ................
        00 e6 49 cd 81 88 ff ff c0 9b 87 d0 81 88 ff ff  ..I.............
      backtrace:
        [<00000000e2ff5070>] hsr_dev_finalize+0x736/0x960 [hsr]
        [<000000003ed2e597>] hsr_newlink+0x2b2/0x3e0 [hsr]
        [<000000003fa8c6b6>] __rtnl_newlink+0xf1f/0x1600 net/core/rtnetlink.c:3182
        [<000000001247a7ad>] rtnl_newlink+0x66/0x90 net/core/rtnetlink.c:3240
        [<00000000e7d1b61d>] rtnetlink_rcv_msg+0x54e/0xb90 net/core/rtnetlink.c:5130
        [<000000005556bd3a>] netlink_rcv_skb+0x129/0x340 net/netlink/af_netlink.c:2477
        [<00000000741d5ee6>] netlink_unicast_kernel net/netlink/af_netlink.c:1310 [inline]
        [<00000000741d5ee6>] netlink_unicast+0x49a/0x650 net/netlink/af_netlink.c:1336
        [<000000009d56f9b7>] netlink_sendmsg+0x88b/0xdf0 net/netlink/af_netlink.c:1917
        [<0000000046b35c59>] sock_sendmsg_nosec net/socket.c:621 [inline]
        [<0000000046b35c59>] sock_sendmsg+0xc3/0x100 net/socket.c:631
        [<00000000d208adc9>] __sys_sendto+0x33e/0x560 net/socket.c:1786
        [<00000000b582837a>] __do_sys_sendto net/socket.c:1798 [inline]
        [<00000000b582837a>] __se_sys_sendto net/socket.c:1794 [inline]
        [<00000000b582837a>] __x64_sys_sendto+0xdd/0x1b0 net/socket.c:1794
        [<00000000c866801d>] do_syscall_64+0x147/0x600 arch/x86/entry/common.c:290
        [<00000000fea382d9>] entry_SYSCALL_64_after_hwframe+0x49/0xbe
        [<00000000e01dacb3>] 0xffffffffffffffff
    
    Fixes: c5a759117210 ("net/hsr: Use list_head (and rcu) instead of array for slave devices.")
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Mao Wenan <maowenan@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index 370b45998121..531fd3dfcac1 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -16,6 +16,7 @@
 
 struct hsr_node;
 
+void hsr_del_node(struct list_head *self_node_db);
 struct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],
 			      u16 seq_out);
 struct hsr_node *hsr_get_node(struct hsr_port *port, struct sk_buff *skb,

commit dda436b7accffd5313e8fd8338f724376c6fcda2
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Oct 24 01:46:16 2017 -0700

    net: hsr: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Arvid Brodin <arvid.brodin@alten.se>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index 4e04f0e868e9..370b45998121 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -33,7 +33,7 @@ void hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port,
 int hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,
 			   u16 sequence_nr);
 
-void hsr_prune_nodes(unsigned long data);
+void hsr_prune_nodes(struct timer_list *t);
 
 int hsr_create_self_node(struct list_head *self_node_db,
 			 unsigned char addr_a[ETH_ALEN],

commit 675c8da049fd6556eb2d6cdd745fe812752f07a8
Author: Karicheri, Muralidharan <m-karicheri2@ti.com>
Date:   Mon Jun 12 15:06:26 2017 -0400

    hsr: fix incorrect warning
    
    When HSR interface is setup using ip link command, an annoying warning
    appears with the trace as below:-
    
    [  203.019828] hsr_get_node: Non-HSR frame
    [  203.019833] Modules linked in:
    [  203.019848] CPU: 0 PID: 158 Comm: sd-resolve Tainted: G        W       4.12.0-rc3-00052-g9fa6bf70 #2
    [  203.019853] Hardware name: Generic DRA74X (Flattened Device Tree)
    [  203.019869] [<c0110280>] (unwind_backtrace) from [<c010c2f4>] (show_stack+0x10/0x14)
    [  203.019880] [<c010c2f4>] (show_stack) from [<c04b9f64>] (dump_stack+0xac/0xe0)
    [  203.019894] [<c04b9f64>] (dump_stack) from [<c01374e8>] (__warn+0xd8/0x104)
    [  203.019907] [<c01374e8>] (__warn) from [<c0137548>] (warn_slowpath_fmt+0x34/0x44)
    root@am57xx-evm:~# [  203.019921] [<c0137548>] (warn_slowpath_fmt) from [<c081126c>] (hsr_get_node+0x148/0x170)
    [  203.019932] [<c081126c>] (hsr_get_node) from [<c0814240>] (hsr_forward_skb+0x110/0x7c0)
    [  203.019942] [<c0814240>] (hsr_forward_skb) from [<c0811d64>] (hsr_dev_xmit+0x2c/0x34)
    [  203.019954] [<c0811d64>] (hsr_dev_xmit) from [<c06c0828>] (dev_hard_start_xmit+0xc4/0x3bc)
    [  203.019963] [<c06c0828>] (dev_hard_start_xmit) from [<c06c13d8>] (__dev_queue_xmit+0x7c4/0x98c)
    [  203.019974] [<c06c13d8>] (__dev_queue_xmit) from [<c0782f54>] (ip6_finish_output2+0x330/0xc1c)
    [  203.019983] [<c0782f54>] (ip6_finish_output2) from [<c0788f0c>] (ip6_output+0x58/0x454)
    [  203.019994] [<c0788f0c>] (ip6_output) from [<c07b16cc>] (mld_sendpack+0x420/0x744)
    
    As this is an expected path to hsr_get_node() with frame coming from
    the master interface, add a check to ensure packet is not from the
    master port and then warn.
    
    Signed-off-by: Murali Karicheri <m-karicheri2@ti.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index 438b40f98f5a..4e04f0e868e9 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -18,7 +18,7 @@ struct hsr_node;
 
 struct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],
 			      u16 seq_out);
-struct hsr_node *hsr_get_node(struct list_head *node_db, struct sk_buff *skb,
+struct hsr_node *hsr_get_node(struct hsr_port *port, struct sk_buff *skb,
 			      bool is_sup);
 void hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,
 			  struct hsr_port *port);

commit f266a683a4804dc499efc6c2206ef68efed029d0
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:41:03 2014 +0200

    net/hsr: Better frame dispatch
    
    This patch removes the separate paths for frames coming from the outside, and
    frames sent from the HSR device, and instead makes all frames go through
    hsr_forward_skb() in hsr_forward.c. This greatly improves code readability and
    also opens up the possibility for future support of the HSR Interlink device
    that is the basis for HSR RedBoxes and HSR QuadBoxes, as well as VLAN
    compatibility.
    
    Other improvements:
    * A reduction in the number of times an skb is copied on machines without
      HAVE_EFFICIENT_UNALIGNED_ACCESS, which improves throughput somewhat.
    * Headers are now created using the standard eth_header(), and using the
      standard hard_header_len.
    * Each HSR slave now gets its own private skb, so slave-specific fields can be
      correctly set.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index c87f36fc154c..438b40f98f5a 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -16,19 +16,22 @@
 
 struct hsr_node;
 
-struct hsr_node *hsr_find_node(struct list_head *node_db, struct sk_buff *skb);
-
-struct hsr_node *hsr_merge_node(struct hsr_node *node, struct sk_buff *skb,
-				struct hsr_port *port);
-
-void hsr_addr_subst_source(struct hsr_priv *hsr, struct sk_buff *skb);
-void hsr_addr_subst_dest(struct hsr_priv *hsr, struct ethhdr *ethhdr,
+struct hsr_node *hsr_add_node(struct list_head *node_db, unsigned char addr[],
+			      u16 seq_out);
+struct hsr_node *hsr_get_node(struct list_head *node_db, struct sk_buff *skb,
+			      bool is_sup);
+void hsr_handle_sup_frame(struct sk_buff *skb, struct hsr_node *node_curr,
+			  struct hsr_port *port);
+bool hsr_addr_is_self(struct hsr_priv *hsr, unsigned char *addr);
+
+void hsr_addr_subst_source(struct hsr_node *node, struct sk_buff *skb);
+void hsr_addr_subst_dest(struct hsr_node *node_src, struct sk_buff *skb,
 			 struct hsr_port *port);
 
-void hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port);
-
-int hsr_register_frame_out(struct hsr_node *node, struct hsr_port *port,
-			   struct sk_buff *skb);
+void hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port,
+			   u16 sequence_nr);
+int hsr_register_frame_out(struct hsr_port *port, struct hsr_node *node,
+			   u16 sequence_nr);
 
 void hsr_prune_nodes(unsigned long data);
 

commit c5a7591172100269e426cf630da0f2dc8138a206
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:38:05 2014 +0200

    net/hsr: Use list_head (and rcu) instead of array for slave devices.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index ccb09cf4ec5b..c87f36fc154c 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -18,18 +18,16 @@ struct hsr_node;
 
 struct hsr_node *hsr_find_node(struct list_head *node_db, struct sk_buff *skb);
 
-struct hsr_node *hsr_merge_node(struct hsr_priv *hsr,
-				struct hsr_node *node,
-				struct sk_buff *skb,
-				enum hsr_dev_idx dev_idx);
+struct hsr_node *hsr_merge_node(struct hsr_node *node, struct sk_buff *skb,
+				struct hsr_port *port);
 
 void hsr_addr_subst_source(struct hsr_priv *hsr, struct sk_buff *skb);
 void hsr_addr_subst_dest(struct hsr_priv *hsr, struct ethhdr *ethhdr,
-			 enum hsr_dev_idx dev_idx);
+			 struct hsr_port *port);
 
-void hsr_register_frame_in(struct hsr_node *node, enum hsr_dev_idx dev_idx);
+void hsr_register_frame_in(struct hsr_node *node, struct hsr_port *port);
 
-int hsr_register_frame_out(struct hsr_node *node, enum hsr_dev_idx dev_idx,
+int hsr_register_frame_out(struct hsr_node *node, struct hsr_port *port,
 			   struct sk_buff *skb);
 
 void hsr_prune_nodes(unsigned long data);

commit abff7162765cd66ab109c97fd433ef1f39299120
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:35:47 2014 +0200

    net/hsr: Move to per-hsr device prune timer.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index 3675139df379..ccb09cf4ec5b 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -32,7 +32,7 @@ void hsr_register_frame_in(struct hsr_node *node, enum hsr_dev_idx dev_idx);
 int hsr_register_frame_out(struct hsr_node *node, enum hsr_dev_idx dev_idx,
 			   struct sk_buff *skb);
 
-void hsr_prune_nodes(struct hsr_priv *hsr);
+void hsr_prune_nodes(unsigned long data);
 
 int hsr_create_self_node(struct list_head *self_node_db,
 			 unsigned char addr_a[ETH_ALEN],

commit 70ebe4a47185db15f3c55be9611a1a971237870b
Author: Arvid Brodin <arvid.brodin@alten.se>
Date:   Fri Jul 4 23:34:38 2014 +0200

    net/hsr: Better variable names and update of contact info.
    
    Signed-off-by: Arvid Brodin <arvid.brodin@alten.se>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
index e6c4022030ad..3675139df379 100644
--- a/net/hsr/hsr_framereg.h
+++ b/net/hsr/hsr_framereg.h
@@ -1,4 +1,4 @@
-/* Copyright 2011-2013 Autronica Fire and Security AS
+/* Copyright 2011-2014 Autronica Fire and Security AS
  *
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the Free
@@ -6,42 +6,42 @@
  * any later version.
  *
  * Author(s):
- *	2011-2013 Arvid Brodin, arvid.brodin@xdin.com
+ *	2011-2014 Arvid Brodin, arvid.brodin@alten.se
  */
 
-#ifndef _HSR_FRAMEREG_H
-#define _HSR_FRAMEREG_H
+#ifndef __HSR_FRAMEREG_H
+#define __HSR_FRAMEREG_H
 
 #include "hsr_main.h"
 
-struct node_entry;
+struct hsr_node;
 
-struct node_entry *hsr_find_node(struct list_head *node_db, struct sk_buff *skb);
+struct hsr_node *hsr_find_node(struct list_head *node_db, struct sk_buff *skb);
 
-struct node_entry *hsr_merge_node(struct hsr_priv *hsr_priv,
-				  struct node_entry *node,
-				  struct sk_buff *skb,
-				  enum hsr_dev_idx dev_idx);
+struct hsr_node *hsr_merge_node(struct hsr_priv *hsr,
+				struct hsr_node *node,
+				struct sk_buff *skb,
+				enum hsr_dev_idx dev_idx);
 
-void hsr_addr_subst_source(struct hsr_priv *hsr_priv, struct sk_buff *skb);
-void hsr_addr_subst_dest(struct hsr_priv *hsr_priv, struct ethhdr *ethhdr,
+void hsr_addr_subst_source(struct hsr_priv *hsr, struct sk_buff *skb);
+void hsr_addr_subst_dest(struct hsr_priv *hsr, struct ethhdr *ethhdr,
 			 enum hsr_dev_idx dev_idx);
 
-void hsr_register_frame_in(struct node_entry *node, enum hsr_dev_idx dev_idx);
+void hsr_register_frame_in(struct hsr_node *node, enum hsr_dev_idx dev_idx);
 
-int hsr_register_frame_out(struct node_entry *node, enum hsr_dev_idx dev_idx,
+int hsr_register_frame_out(struct hsr_node *node, enum hsr_dev_idx dev_idx,
 			   struct sk_buff *skb);
 
-void hsr_prune_nodes(struct hsr_priv *hsr_priv);
+void hsr_prune_nodes(struct hsr_priv *hsr);
 
 int hsr_create_self_node(struct list_head *self_node_db,
 			 unsigned char addr_a[ETH_ALEN],
 			 unsigned char addr_b[ETH_ALEN]);
 
-void *hsr_get_next_node(struct hsr_priv *hsr_priv, void *_pos,
+void *hsr_get_next_node(struct hsr_priv *hsr, void *_pos,
 			unsigned char addr[ETH_ALEN]);
 
-int hsr_get_node_data(struct hsr_priv *hsr_priv,
+int hsr_get_node_data(struct hsr_priv *hsr,
 		      const unsigned char *addr,
 		      unsigned char addr_b[ETH_ALEN],
 		      unsigned int *addr_b_ifindex,
@@ -50,4 +50,4 @@ int hsr_get_node_data(struct hsr_priv *hsr_priv,
 		      int *if2_age,
 		      u16 *if2_seq);
 
-#endif /* _HSR_FRAMEREG_H */
+#endif /* __HSR_FRAMEREG_H */

commit f421436a591d34fa5279b54a96ac07d70250cc8d
Author: Arvid Brodin <Arvid.Brodin@xdin.com>
Date:   Wed Oct 30 21:10:47 2013 +0100

    net/hsr: Add support for the High-availability Seamless Redundancy protocol (HSRv0)
    
    High-availability Seamless Redundancy ("HSR") provides instant failover
    redundancy for Ethernet networks. It requires a special network topology where
    all nodes are connected in a ring (each node having two physical network
    interfaces). It is suited for applications that demand high availability and
    very short reaction time.
    
    HSR acts on the Ethernet layer, using a registered Ethernet protocol type to
    send special HSR frames in both directions over the ring. The driver creates
    virtual network interfaces that can be used just like any ordinary Linux
    network interface, for IP/TCP/UDP traffic etc. All nodes in the network ring
    must be HSR capable.
    
    This code is a "best effort" to comply with the HSR standard as described in
    IEC 62439-3:2010 (HSRv0).
    
    Signed-off-by: Arvid Brodin <arvid.brodin@xdin.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/hsr/hsr_framereg.h b/net/hsr/hsr_framereg.h
new file mode 100644
index 000000000000..e6c4022030ad
--- /dev/null
+++ b/net/hsr/hsr_framereg.h
@@ -0,0 +1,53 @@
+/* Copyright 2011-2013 Autronica Fire and Security AS
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * Author(s):
+ *	2011-2013 Arvid Brodin, arvid.brodin@xdin.com
+ */
+
+#ifndef _HSR_FRAMEREG_H
+#define _HSR_FRAMEREG_H
+
+#include "hsr_main.h"
+
+struct node_entry;
+
+struct node_entry *hsr_find_node(struct list_head *node_db, struct sk_buff *skb);
+
+struct node_entry *hsr_merge_node(struct hsr_priv *hsr_priv,
+				  struct node_entry *node,
+				  struct sk_buff *skb,
+				  enum hsr_dev_idx dev_idx);
+
+void hsr_addr_subst_source(struct hsr_priv *hsr_priv, struct sk_buff *skb);
+void hsr_addr_subst_dest(struct hsr_priv *hsr_priv, struct ethhdr *ethhdr,
+			 enum hsr_dev_idx dev_idx);
+
+void hsr_register_frame_in(struct node_entry *node, enum hsr_dev_idx dev_idx);
+
+int hsr_register_frame_out(struct node_entry *node, enum hsr_dev_idx dev_idx,
+			   struct sk_buff *skb);
+
+void hsr_prune_nodes(struct hsr_priv *hsr_priv);
+
+int hsr_create_self_node(struct list_head *self_node_db,
+			 unsigned char addr_a[ETH_ALEN],
+			 unsigned char addr_b[ETH_ALEN]);
+
+void *hsr_get_next_node(struct hsr_priv *hsr_priv, void *_pos,
+			unsigned char addr[ETH_ALEN]);
+
+int hsr_get_node_data(struct hsr_priv *hsr_priv,
+		      const unsigned char *addr,
+		      unsigned char addr_b[ETH_ALEN],
+		      unsigned int *addr_b_ifindex,
+		      int *if1_age,
+		      u16 *if1_seq,
+		      int *if2_age,
+		      u16 *if2_seq);
+
+#endif /* _HSR_FRAMEREG_H */
