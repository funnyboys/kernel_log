commit 61fad6816fc10fb8793a925d5c1256d1c3db0cd2
Author: Willem de Bruijn <willemb@google.com>
Date:   Fri Mar 13 12:18:09 2020 -0400

    net/packet: tpacket_rcv: avoid a producer race condition
    
    PACKET_RX_RING can cause multiple writers to access the same slot if a
    fast writer wraps the ring while a slow writer is still copying. This
    is particularly likely with few, large, slots (e.g., GSO packets).
    
    Synchronize kernel thread ownership of rx ring slots with a bitmap.
    
    Writers acquire a slot race-free by testing tp_status TP_STATUS_KERNEL
    while holding the sk receive queue lock. They release this lock before
    copying and set tp_status to TP_STATUS_USER to release to userspace
    when done. During copying, another writer may take the lock, also see
    TP_STATUS_KERNEL, and start writing to the same slot.
    
    Introduce a new rx_owner_map bitmap with a bit per slot. To acquire a
    slot, test and set with the lock held. To release race-free, update
    tp_status and owner bit as a transaction, so take the lock again.
    
    This is the one of a variety of discussed options (see Link below):
    
    * instead of a shadow ring, embed the data in the slot itself, such as
    in tp_padding. But any test for this field may match a value left by
    userspace, causing deadlock.
    
    * avoid the lock on release. This leaves a small race if releasing the
    shadow slot before setting TP_STATUS_USER. The below reproducer showed
    that this race is not academic. If releasing the slot after tp_status,
    the race is more subtle. See the first link for details.
    
    * add a new tp_status TP_KERNEL_OWNED to avoid the transactional store
    of two fields. But, legacy applications may interpret all non-zero
    tp_status as owned by the user. As libpcap does. So this is possible
    only opt-in by newer processes. It can be added as an optional mode.
    
    * embed the struct at the tail of pg_vec to avoid extra allocation.
    The implementation proved no less complex than a separate field.
    
    The additional locking cost on release adds contention, no different
    than scaling on multicore or multiqueue h/w. In practice, below
    reproducer nor small packet tcpdump showed a noticeable change in
    perf report in cycles spent in spinlock. Where contention is
    problematic, packet sockets support mitigation through PACKET_FANOUT.
    And we can consider adding opt-in state TP_KERNEL_OWNED.
    
    Easy to reproduce by running multiple netperf or similar TCP_STREAM
    flows concurrently with `tcpdump -B 129 -n greater 60000`.
    
    Based on an earlier patchset by Jon Rosen. See links below.
    
    I believe this issue goes back to the introduction of tpacket_rcv,
    which predates git history.
    
    Link: https://www.mail-archive.com/netdev@vger.kernel.org/msg237222.html
    Suggested-by: Jon Rosen <jrosen@cisco.com>
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: Jon Rosen <jrosen@cisco.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 82fb2b10f790..907f4cd2a718 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -70,7 +70,10 @@ struct packet_ring_buffer {
 
 	unsigned int __percpu	*pending_refcnt;
 
-	struct tpacket_kbdq_core	prb_bdqc;
+	union {
+		unsigned long			*rx_owner_map;
+		struct tpacket_kbdq_core	prb_bdqc;
+	};
 };
 
 extern struct mutex fanout_mutex;

commit d96ff269a04be286989ead13bf8b4be55bdee8ee
Merge: 3a49584477ff 556e2f6020bf
Author: David S. Miller <davem@davemloft.net>
Date:   Thu Jun 27 21:06:39 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    The new route handling in ip_mc_finish_output() from 'net' overlapped
    with the new support for returning congestion notifications from BPF
    programs.
    
    In order to handle this I had to take the dev_loopback_xmit() calls
    out of the switch statement.
    
    The aquantia driver conflicts were simple overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 89ed5b519004a7706f50b70f611edbd3aaacff2c
Author: Neil Horman <nhorman@tuxdriver.com>
Date:   Tue Jun 25 17:57:49 2019 -0400

    af_packet: Block execution of tasks waiting for transmit to complete in AF_PACKET
    
    When an application is run that:
    a) Sets its scheduler to be SCHED_FIFO
    and
    b) Opens a memory mapped AF_PACKET socket, and sends frames with the
    MSG_DONTWAIT flag cleared, its possible for the application to hang
    forever in the kernel.  This occurs because when waiting, the code in
    tpacket_snd calls schedule, which under normal circumstances allows
    other tasks to run, including ksoftirqd, which in some cases is
    responsible for freeing the transmitted skb (which in AF_PACKET calls a
    destructor that flips the status bit of the transmitted frame back to
    available, allowing the transmitting task to complete).
    
    However, when the calling application is SCHED_FIFO, its priority is
    such that the schedule call immediately places the task back on the cpu,
    preventing ksoftirqd from freeing the skb, which in turn prevents the
    transmitting task from detecting that the transmission is complete.
    
    We can fix this by converting the schedule call to a completion
    mechanism.  By using a completion queue, we force the calling task, when
    it detects there are no more frames to send, to schedule itself off the
    cpu until such time as the last transmitted skb is freed, allowing
    forward progress to be made.
    
    Tested by myself and the reporter, with good results
    
    Change Notes:
    
    V1->V2:
            Enhance the sleep logic to support being interruptible and
    allowing for honoring to SK_SNDTIMEO (Willem de Bruijn)
    
    V2->V3:
            Rearrage the point at which we wait for the completion queue, to
    avoid needing to check for ph/skb being null at the end of the loop.
    Also move the complete call to the skb destructor to avoid needing to
    modify __packet_set_status.  Also gate calling complete on
    packet_read_pending returning zero to avoid multiple calls to complete.
    (Willem de Bruijn)
    
            Move timeo computation within loop, to re-fetch the socket
    timeout since we also use the timeo variable to record the return code
    from the wait_for_complete call (Neil Horman)
    
    V3->V4:
            Willem has requested that the control flow be restored to the
    previous state.  Doing so lets us eliminate the need for the
    po->wait_on_complete flag variable, and lets us get rid of the
    packet_next_frame function, but introduces another complexity.
    Specifically, but using the packet pending count, we can, if an
    applications calls sendmsg multiple times with MSG_DONTWAIT set, each
    set of transmitted frames, when complete, will cause
    tpacket_destruct_skb to issue a complete call, for which there will
    never be a wait_on_completion call.  This imbalance will lead to any
    future call to wait_for_completion here to return early, when the frames
    they sent may not have completed.  To correct this, we need to re-init
    the completion queue on every call to tpacket_snd before we enter the
    loop so as to ensure we wait properly for the frames we send in this
    iteration.
    
            Change the timeout and interrupted gotos to out_put rather than
    out_status so that we don't try to free a non-existant skb
            Clean up some extra newlines (Willem de Bruijn)
    
    Reviewed-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: Neil Horman <nhorman@tuxdriver.com>
    Reported-by: Matteo Croce <mcroce@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 3bb7c5fb3bff..c70a2794456f 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -128,6 +128,7 @@ struct packet_sock {
 	unsigned int		tp_hdrlen;
 	unsigned int		tp_reserve;
 	unsigned int		tp_tstamp;
+	struct completion	skb_completion;
 	struct net_device __rcu	*cached_dev;
 	int			(*xmit)(struct sk_buff *skb);
 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;

commit 8e8e2951e3095732d7e780c241f61ea130955a57
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Jun 12 09:52:30 2019 -0700

    net/packet: make tp_drops atomic
    
    Under DDOS, we want to be able to increment tp_drops without
    touching the spinlock. This will help readers to drain
    the receive queue slightly faster :/
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 3bb7c5fb3bff..b5bcff2b7a43 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -131,6 +131,7 @@ struct packet_sock {
 	struct net_device __rcu	*cached_dev;
 	int			(*xmit)(struct sk_buff *skb);
 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
+	atomic_t		tp_drops ____cacheline_aligned_in_smp;
 };
 
 static struct packet_sock *pkt_sk(struct sock *sk)

commit 3a7ad0634f0986d807772ba74f66f7c3a73612e5
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 29 11:50:12 2018 -0700

    Revert "packet: switch kvzalloc to allocate memory"
    
    This reverts commit 71e41286203c017d24f041a7cd71abea7ca7b1e0.
    
    mmap()/munmap() can not be backed by kmalloced pages :
    
    We fault in :
    
        VM_BUG_ON_PAGE(PageSlab(page), page);
    
        unmap_single_vma+0x8a/0x110
        unmap_vmas+0x4b/0x90
        unmap_region+0xc9/0x140
        do_munmap+0x274/0x360
        vm_munmap+0x81/0xc0
        SyS_munmap+0x2b/0x40
        do_syscall_64+0x13e/0x1c0
        entry_SYSCALL_64_after_hwframe+0x42/0xb7
    
    Fixes: 71e41286203c ("packet: switch kvzalloc to allocate memory")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Reported-by: John Sperbeck <jsperbeck@google.com>
    Bisected-by: John Sperbeck <jsperbeck@google.com>
    Cc: Zhang Yu <zhangyu31@baidu.com>
    Cc: Li RongQing <lirongqing@baidu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 8f50036f62f0..3bb7c5fb3bff 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -64,6 +64,7 @@ struct packet_ring_buffer {
 	unsigned int		frame_size;
 	unsigned int		frame_max;
 
+	unsigned int		pg_vec_order;
 	unsigned int		pg_vec_pages;
 	unsigned int		pg_vec_len;
 

commit 71e41286203c017d24f041a7cd71abea7ca7b1e0
Author: Li RongQing <lirongqing@baidu.com>
Date:   Mon Aug 13 10:42:46 2018 +0800

    packet: switch kvzalloc to allocate memory
    
    The patches includes following change:
    
    *Use modern kvzalloc()/kvfree() instead of custom allocations.
    
    *Remove order argument for alloc_pg_vec, it can get from req.
    
    *Remove order argument for free_pg_vec, free_pg_vec now uses
    kvfree which does not need order argument.
    
    *Remove pg_vec_order from struct packet_ring_buffer, no longer
    need to save/restore 'order'
    
    *Remove variable 'order' for packet_set_ring, it is now unused
    
    Signed-off-by: Zhang Yu <zhangyu31@baidu.com>
    Signed-off-by: Li RongQing <lirongqing@baidu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 3bb7c5fb3bff..8f50036f62f0 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -64,7 +64,6 @@ struct packet_ring_buffer {
 	unsigned int		frame_size;
 	unsigned int		frame_max;
 
-	unsigned int		pg_vec_order;
 	unsigned int		pg_vec_pages;
 	unsigned int		pg_vec_len;
 

commit a6361f0ca4b25460f2cdf3235ebe8115f622901e
Author: Willem de Bruijn <willemb@google.com>
Date:   Mon Apr 23 17:37:03 2018 -0400

    packet: fix bitfield update race
    
    Updates to the bitfields in struct packet_sock are not atomic.
    Serialize these read-modify-write cycles.
    
    Move po->running into a separate variable. Its writes are protected by
    po->bind_lock (except for one startup case at packet_create). Also
    replace a textual precondition warning with lockdep annotation.
    
    All others are set only in packet_setsockopt. Serialize these
    updates by holding the socket lock. Analogous to other field updates,
    also hold the lock when testing whether a ring is active (pg_vec).
    
    Fixes: 8dc419447415 ("[PACKET]: Add optional checksum computation for recvmsg")
    Reported-by: DaeRyong Jeong <threeearcat@gmail.com>
    Reported-by: Byoungyoung Lee <byoungyoung@purdue.edu>
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index a1d2b2319ae9..3bb7c5fb3bff 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -112,10 +112,12 @@ struct packet_sock {
 	int			copy_thresh;
 	spinlock_t		bind_lock;
 	struct mutex		pg_vec_lock;
-	unsigned int		running:1,	/* prot_hook is attached*/
-				auxdata:1,
+	unsigned int		running;	/* bind_lock must be held */
+	unsigned int		auxdata:1,	/* writer must hold sock lock */
 				origdev:1,
-				has_vnet_hdr:1;
+				has_vnet_hdr:1,
+				tp_loss:1,
+				tp_tx_has_off:1;
 	int			pressure;
 	int			ifindex;	/* bound device		*/
 	__be16			num;
@@ -125,8 +127,6 @@ struct packet_sock {
 	enum tpacket_versions	tp_version;
 	unsigned int		tp_hdrlen;
 	unsigned int		tp_reserve;
-	unsigned int		tp_loss:1;
-	unsigned int		tp_tx_has_off:1;
 	unsigned int		tp_tstamp;
 	struct net_device __rcu	*cached_dev;
 	int			(*xmit)(struct sk_buff *skb);

commit 57f015f5eccf25fd4a3336fe3cbbee920a8fba6f
Author: Mike Maloney <maloney@google.com>
Date:   Tue Nov 28 10:44:29 2017 -0500

    packet: fix crash in fanout_demux_rollover()
    
    syzkaller found a race condition fanout_demux_rollover() while removing
    a packet socket from a fanout group.
    
    po->rollover is read and operated on during packet_rcv_fanout(), via
    fanout_demux_rollover(), but the pointer is currently cleared before the
    synchronization in packet_release().   It is safer to delay the cleanup
    until after synchronize_net() has been called, ensuring all calls to
    packet_rcv_fanout() for this socket have finished.
    
    To further simplify synchronization around the rollover structure, set
    po->rollover in fanout_add() only if there are no errors.  This removes
    the need for rcu in the struct and in the call to
    packet_getsockopt(..., PACKET_ROLLOVER_STATS, ...).
    
    Crashing stack trace:
     fanout_demux_rollover+0xb6/0x4d0 net/packet/af_packet.c:1392
     packet_rcv_fanout+0x649/0x7c8 net/packet/af_packet.c:1487
     dev_queue_xmit_nit+0x835/0xc10 net/core/dev.c:1953
     xmit_one net/core/dev.c:2975 [inline]
     dev_hard_start_xmit+0x16b/0xac0 net/core/dev.c:2995
     __dev_queue_xmit+0x17a4/0x2050 net/core/dev.c:3476
     dev_queue_xmit+0x17/0x20 net/core/dev.c:3509
     neigh_connected_output+0x489/0x720 net/core/neighbour.c:1379
     neigh_output include/net/neighbour.h:482 [inline]
     ip6_finish_output2+0xad1/0x22a0 net/ipv6/ip6_output.c:120
     ip6_finish_output+0x2f9/0x920 net/ipv6/ip6_output.c:146
     NF_HOOK_COND include/linux/netfilter.h:239 [inline]
     ip6_output+0x1f4/0x850 net/ipv6/ip6_output.c:163
     dst_output include/net/dst.h:459 [inline]
     NF_HOOK.constprop.35+0xff/0x630 include/linux/netfilter.h:250
     mld_sendpack+0x6a8/0xcc0 net/ipv6/mcast.c:1660
     mld_send_initial_cr.part.24+0x103/0x150 net/ipv6/mcast.c:2072
     mld_send_initial_cr net/ipv6/mcast.c:2056 [inline]
     ipv6_mc_dad_complete+0x99/0x130 net/ipv6/mcast.c:2079
     addrconf_dad_completed+0x595/0x970 net/ipv6/addrconf.c:4039
     addrconf_dad_work+0xac9/0x1160 net/ipv6/addrconf.c:3971
     process_one_work+0xbf0/0x1bc0 kernel/workqueue.c:2113
     worker_thread+0x223/0x1990 kernel/workqueue.c:2247
     kthread+0x35e/0x430 kernel/kthread.c:231
     ret_from_fork+0x2a/0x40 arch/x86/entry/entry_64.S:432
    
    Fixes: 0648ab70afe6 ("packet: rollover prepare: per-socket state")
    Fixes: 509c7a1ecc860 ("packet: avoid panic in packet_getsockopt()")
    Reported-by: syzbot <syzkaller@googlegroups.com>
    Signed-off-by: Mike Maloney <maloney@google.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 562fbc155006..a1d2b2319ae9 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -95,7 +95,6 @@ struct packet_fanout {
 
 struct packet_rollover {
 	int			sock;
-	struct rcu_head		rcu;
 	atomic_long_t		num;
 	atomic_long_t		num_huge;
 	atomic_long_t		num_failed;

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 94d1d405a116..562fbc155006 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __PACKET_INTERNAL_H__
 #define __PACKET_INTERNAL_H__
 

commit fb5c2c17a556d9b00798d6a6b9e624281ee2eb28
Author: Reshetova, Elena <elena.reshetova@intel.com>
Date:   Fri Jun 30 13:08:10 2017 +0300

    net: convert packet_fanout.sk_ref from atomic_t to refcount_t
    
    refcount_t type and corresponding API should be
    used instead of atomic_t when the variable is used as
    a reference counter. This allows to avoid accidental
    refcounter overflows that might lead to use-after-free
    situations.
    
    Signed-off-by: Elena Reshetova <elena.reshetova@intel.com>
    Signed-off-by: Hans Liljestrand <ishkamiel@gmail.com>
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: David Windsor <dwindsor@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 9ee46314b7d7..94d1d405a116 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -1,6 +1,8 @@
 #ifndef __PACKET_INTERNAL_H__
 #define __PACKET_INTERNAL_H__
 
+#include <linux/refcount.h>
+
 struct packet_mclist {
 	struct packet_mclist	*next;
 	int			ifindex;
@@ -86,7 +88,7 @@ struct packet_fanout {
 	struct list_head	list;
 	struct sock		*arr[PACKET_FANOUT_MAX];
 	spinlock_t		lock;
-	atomic_t		sk_ref;
+	refcount_t		sk_ref;
 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
 };
 

commit 47dceb8ecdc1c3ad1818dfea3d659a05b74c3fc2
Author: Willem de Bruijn <willemb@google.com>
Date:   Fri Aug 14 22:31:34 2015 -0400

    packet: add classic BPF fanout mode
    
    Add fanout mode PACKET_FANOUT_CBPF that accepts a classic BPF program
    to select a socket.
    
    This avoids having to keep adding special case fanout modes. One
    example use case is application layer load balancing. The QUIC
    protocol, for instance, encodes a connection ID in UDP payload.
    
    Also add socket option SOL_PACKET/PACKET_FANOUT_DATA that updates data
    associated with the socket group. Fanout mode PACKET_FANOUT_CBPF is the
    only user so far.
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Acked-by: Alexei Starovoitov <ast@plumgrid.com>
    Acked-by: Daniel Borkmann <daniel@iogearbox.net>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index e20b3e8829b8..9ee46314b7d7 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -79,7 +79,10 @@ struct packet_fanout {
 	u16			id;
 	u8			type;
 	u8			flags;
-	atomic_t		rr_cur;
+	union {
+		atomic_t		rr_cur;
+		struct bpf_prog __rcu	*bpf_prog;
+	};
 	struct list_head	list;
 	struct sock		*arr[PACKET_FANOUT_MAX];
 	spinlock_t		lock;

commit 59f211181b5b10d4a95e1b9226febb0c0b6497c6
Author: Willem de Bruijn <willemb@google.com>
Date:   Tue Jun 16 12:51:37 2015 -0400

    packet: free packet_rollover after synchronize_net
    
    Destruction of the po->rollover must be delayed until there are no
    more packets in flight that can access it. The field is destroyed in
    packet_release, before synchronize_net. Delay using rcu.
    
    Fixes: 0648ab70afe6 ("packet: rollover prepare: per-socket state")
    
    Suggested-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index c035d263c1e8..e20b3e8829b8 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -89,6 +89,7 @@ struct packet_fanout {
 
 struct packet_rollover {
 	int			sock;
+	struct rcu_head		rcu;
 	atomic_long_t		num;
 	atomic_long_t		num_huge;
 	atomic_long_t		num_failed;

commit a9b6391814d5d6b8668fca2dace86949b7244e2e
Author: Willem de Bruijn <willemb@google.com>
Date:   Tue May 12 11:56:50 2015 -0400

    packet: rollover statistics
    
    Rollover indicates exceptional conditions. Export a counter to inform
    socket owners of this state.
    
    If no socket with sufficient room is found, rollover fails. Also count
    these events.
    
    Finally, also count when flows are rolled over early thanks to huge
    flow detection, to validate its correctness.
    
    Tested:
      Read counters in bench_rollover on all other tests in the patchset
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index a9d30a17c714..c035d263c1e8 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -89,6 +89,9 @@ struct packet_fanout {
 
 struct packet_rollover {
 	int			sock;
+	atomic_long_t		num;
+	atomic_long_t		num_huge;
+	atomic_long_t		num_failed;
 #define ROLLOVER_HLEN	(L1_CACHE_BYTES / sizeof(u32))
 	u32			history[ROLLOVER_HLEN] ____cacheline_aligned;
 } ____cacheline_aligned_in_smp;

commit 3b3a5b0aab5b9ad345d4beb9a364a7dd02c23d40
Author: Willem de Bruijn <willemb@google.com>
Date:   Tue May 12 11:56:49 2015 -0400

    packet: rollover huge flows before small flows
    
    Migrate flows from a socket to another socket in the fanout group not
    only when the socket is full. Start migrating huge flows early, to
    divert possible 4-tuple attacks without affecting normal traffic.
    
    Introduce fanout_flow_is_huge(). This detects huge flows, which are
    defined as taking up more than half the load. It does so cheaply, by
    storing the rxhashes of the N most recent packets. If over half of
    these are the same rxhash as the current packet, then drop it. This
    only protects against 4-tuple attacks. N is chosen to fit all data in
    a single cache line.
    
    Tested:
      Ran bench_rollover for 10 sec with 1.5 Mpps of single flow input.
    
        lpbb5:/export/hda3/willemb# ./bench_rollover -l 1000 -r -s
        cpu         rx       rx.k     drop.k   rollover     r.huge   r.failed
          0         14         14          0          0          0          0
          1         20         20          0          0          0          0
          2         16         16          0          0          0          0
          3    6168824    6168824          0    4867721    4867721          0
          4    4867741    4867741          0          0          0          0
          5         12         12          0          0          0          0
          6         15         15          0          0          0          0
          7         17         17          0          0          0          0
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 22d7d778c5b7..a9d30a17c714 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -89,6 +89,8 @@ struct packet_fanout {
 
 struct packet_rollover {
 	int			sock;
+#define ROLLOVER_HLEN	(L1_CACHE_BYTES / sizeof(u32))
+	u32			history[ROLLOVER_HLEN] ____cacheline_aligned;
 } ____cacheline_aligned_in_smp;
 
 struct packet_sock {

commit 2ccdbaa6d55b0656244ba57c4b56765a0af76c0a
Author: Willem de Bruijn <willemb@google.com>
Date:   Tue May 12 11:56:48 2015 -0400

    packet: rollover lock contention avoidance
    
    Rollover has to call packet_rcv_has_room on sockets in the fanout
    group to find a socket to migrate to. This operation is expensive
    especially if the packet sockets use rings, when a lock has to be
    acquired.
    
    Avoid pounding on the lock by all sockets by temporarily marking a
    socket as "under memory pressure" when such pressure is detected.
    While set, only the socket owner may call packet_rcv_has_room on the
    socket. Once it detects normal conditions, it clears the flag. The
    socket is not used as a victim by any other socket in the meantime.
    
    Under reasonably balanced load, each socket writer frequently calls
    packet_rcv_has_room and clears its own pressure field. As a backup
    for when the socket is rarely written to, also clear the flag on
    reading (packet_recvmsg, packet_poll) if this can be done cheaply
    (i.e., without calling packet_rcv_has_room). This is only for
    edge cases.
    
    Tested:
      Ran bench_rollover: a process with 8 sockets in a single fanout
      group, each pinned to a single cpu that receives one nic recv
      interrupt. RPS and RFS are disabled. The benchmark uses packet
      rx_ring, which has to take a lock when determining whether a
      socket has room.
    
      Sent 3.5 Mpps of UDP traffic with sufficient entropy to spread
      uniformly across the packet sockets (and inserted an iptables
      rule to drop in PREROUTING to avoid protocol stack processing).
    
      Without this patch, all sockets try to migrate traffic to
      neighbors, causing lock contention when searching for a non-
      empty neighbor. The lock is the top 9 entries.
    
        perf record -a -g sleep 5
    
        -  17.82%   bench_rollover  [kernel.kallsyms]    [k] _raw_spin_lock
           - _raw_spin_lock
              - 99.00% spin_lock
             + 81.77% packet_rcv_has_room.isra.41
             + 18.23% tpacket_rcv
              + 0.84% packet_rcv_has_room.isra.41
        +   5.20%      ksoftirqd/6  [kernel.kallsyms]    [k] _raw_spin_lock
        +   5.15%      ksoftirqd/1  [kernel.kallsyms]    [k] _raw_spin_lock
        +   5.14%      ksoftirqd/2  [kernel.kallsyms]    [k] _raw_spin_lock
        +   5.12%      ksoftirqd/7  [kernel.kallsyms]    [k] _raw_spin_lock
        +   5.12%      ksoftirqd/5  [kernel.kallsyms]    [k] _raw_spin_lock
        +   5.10%      ksoftirqd/4  [kernel.kallsyms]    [k] _raw_spin_lock
        +   4.66%      ksoftirqd/0  [kernel.kallsyms]    [k] _raw_spin_lock
        +   4.45%      ksoftirqd/3  [kernel.kallsyms]    [k] _raw_spin_lock
        +   1.55%   bench_rollover  [kernel.kallsyms]    [k] packet_rcv_has_room.isra.41
    
      On net-next with this patch, this lock contention is no longer a
      top entry. Most time is spent in the actual read function. Next up
      are other locks:
    
        +  15.52%  bench_rollover  bench_rollover     [.] reader
        +   4.68%         swapper  [kernel.kallsyms]  [k] memcpy_erms
        +   2.77%         swapper  [kernel.kallsyms]  [k] packet_lookup_frame.isra.51
        +   2.56%     ksoftirqd/1  [kernel.kallsyms]  [k] memcpy_erms
        +   2.16%         swapper  [kernel.kallsyms]  [k] tpacket_rcv
        +   1.93%         swapper  [kernel.kallsyms]  [k] mlx4_en_process_rx_cq
    
      Looking closer at the remaining _raw_spin_lock, the cost of probing
      in rollover is now comparable to the cost of taking the lock later
      in tpacket_rcv.
    
        -   1.51%         swapper  [kernel.kallsyms]  [k] _raw_spin_lock
           - _raw_spin_lock
              + 33.41% packet_rcv_has_room
              + 28.15% tpacket_rcv
              + 19.54% enqueue_to_backlog
              + 6.45% __free_pages_ok
              + 2.78% packet_rcv_fanout
              + 2.13% fanout_demux_rollover
              + 2.01% netif_receive_skb_internal
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index a9d33a28a019..22d7d778c5b7 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -105,6 +105,7 @@ struct packet_sock {
 				auxdata:1,
 				origdev:1,
 				has_vnet_hdr:1;
+	int			pressure;
 	int			ifindex;	/* bound device		*/
 	__be16			num;
 	struct packet_rollover	*rollover;

commit 0648ab70afe6c3bf2369a6d779b44a85121c063d
Author: Willem de Bruijn <willemb@google.com>
Date:   Tue May 12 11:56:46 2015 -0400

    packet: rollover prepare: per-socket state
    
    Replace rollover state per fanout group with state per socket. Future
    patches will add fields to the new structure.
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index fe6e20caea1d..a9d33a28a019 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -82,12 +82,15 @@ struct packet_fanout {
 	atomic_t		rr_cur;
 	struct list_head	list;
 	struct sock		*arr[PACKET_FANOUT_MAX];
-	int			next[PACKET_FANOUT_MAX];
 	spinlock_t		lock;
 	atomic_t		sk_ref;
 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
 };
 
+struct packet_rollover {
+	int			sock;
+} ____cacheline_aligned_in_smp;
+
 struct packet_sock {
 	/* struct sock has to be the first member of packet_sock */
 	struct sock		sk;
@@ -104,6 +107,7 @@ struct packet_sock {
 				has_vnet_hdr:1;
 	int			ifindex;	/* bound device		*/
 	__be16			num;
+	struct packet_rollover	*rollover;
 	struct packet_mclist	*mclist;
 	atomic_t		mapped;
 	enum tpacket_versions	tp_version;

commit 0c5c9fb55106333e773de8c9dd321fa8240caeb3
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed Mar 11 23:06:44 2015 -0500

    net: Introduce possible_net_t
    
    Having to say
    > #ifdef CONFIG_NET_NS
    >       struct net *net;
    > #endif
    
    in structures is a little bit wordy and a little bit error prone.
    
    Instead it is possible to say:
    > typedef struct {
    > #ifdef CONFIG_NET_NS
    >       struct net *net;
    > #endif
    > } possible_net_t;
    
    And then in a header say:
    
    >       possible_net_t net;
    
    Which is cleaner and easier to use and easier to test, as the
    possible_net_t is always there no matter what the compile options.
    
    Further this allows read_pnet and write_pnet to be functions in all
    cases which is better at catching typos.
    
    This change adds possible_net_t, updates the definitions of read_pnet
    and write_pnet, updates optional struct net * variables that
    write_pnet uses on to have the type possible_net_t, and finally fixes
    up the b0rked users of read_pnet and write_pnet.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Acked-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index cdddf6a30399..fe6e20caea1d 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -74,9 +74,7 @@ extern struct mutex fanout_mutex;
 #define PACKET_FANOUT_MAX	256
 
 struct packet_fanout {
-#ifdef CONFIG_NET_NS
-	struct net		*net;
-#endif
+	possible_net_t		net;
 	unsigned int		num_members;
 	u16			id;
 	u8			type;

commit dc808110bb62b64a448696ecac3938902c92e1ab
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Aug 15 09:16:04 2014 -0700

    packet: handle too big packets for PACKET_V3
    
    af_packet can currently overwrite kernel memory by out of bound
    accesses, because it assumed a [new] block can always hold one frame.
    
    This is not generally the case, even if most existing tools do it right.
    
    This patch clamps too long frames as API permits, and issue a one time
    error on syslog.
    
    [  394.357639] tpacket_rcv: packet too big, clamped from 5042 to 3966. macoff=82
    
    In this example, packet header tp_snaplen was set to 3966,
    and tp_len was set to 5042 (skb->len)
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Fixes: f6fb8f100b80 ("af-packet: TPACKET_V3 flexible buffer implementation.")
    Acked-by: Daniel Borkmann <dborkman@redhat.com>
    Acked-by: Neil Horman <nhorman@tuxdriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index eb9580a6b25f..cdddf6a30399 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -29,6 +29,7 @@ struct tpacket_kbdq_core {
 	char		*pkblk_start;
 	char		*pkblk_end;
 	int		kblk_size;
+	unsigned int	max_frame_len;
 	unsigned int	knum_blocks;
 	uint64_t	knxt_seq_num;
 	char		*prev;

commit b013840810c221f2b0cf641d01531526052dc1fb
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Wed Jan 15 16:25:36 2014 +0100

    packet: use percpu mmap tx frame pending refcount
    
    In PF_PACKET's packet mmap(), we can avoid using one atomic_inc()
    and one atomic_dec() call in skb destructor and use a percpu
    reference count instead in order to determine if packets are
    still pending to be sent out. Micro-benchmark with [1] that has
    been slightly modified (that is, protcol = 0 in socket(2) and
    bind(2)), example on a rather crappy testing machine; I expect
    it to scale and have even better results on bigger machines:
    
    ./packet_mm_tx -s7000 -m7200 -z700000 em1, avg over 2500 runs:
    
    With patch:    4,022,015 cyc
    Without patch: 4,812,994 cyc
    
    time ./packet_mm_tx -s64 -c10000000 em1 > /dev/null, stable:
    
    With patch:
      real         1m32.241s
      user         0m0.287s
      sys          1m29.316s
    
    Without patch:
      real         1m38.386s
      user         0m0.265s
      sys          1m35.572s
    
    In function tpacket_snd(), it is okay to use packet_read_pending()
    since in fast-path we short-circuit the condition already with
    ph != NULL, since we have next frames to process. In case we have
    MSG_DONTWAIT, we also do not execute this path as need_wait is
    false here anyway, and in case of _no_ MSG_DONTWAIT flag, it is
    okay to call a packet_read_pending(), because when we ever reach
    that path, we're done processing outgoing frames anyway and only
    look if there are skbs still outstanding to be orphaned. We can
    stay lockless in this percpu counter since it's acceptable when we
    reach this path for the sum to be imprecise first, but we'll level
    out at 0 after all pending frames have reached the skb destructor
    eventually through tx reclaim. When people pin a tx process to
    particular CPUs, we expect overflows to happen in the reference
    counter as on one CPU we expect heavy increase; and distributed
    through ksoftirqd on all CPUs a decrease, for example. As
    David Laight points out, since the C language doesn't define the
    result of signed int overflow (i.e. rather than wrap, it is
    allowed to saturate as a possible outcome), we have to use
    unsigned int as reference count. The sum over all CPUs when tx
    is complete will result in 0 again.
    
    The BUG_ON() in tpacket_destruct_skb() we can remove as well. It
    can _only_ be set from inside tpacket_snd() path and we made sure
    to increase tx_ring.pending in any case before we called po->xmit(skb).
    So testing for tx_ring.pending == 0 is not too useful. Instead, it
    would rather have been useful to test if lower layers didn't orphan
    the skb so that we're missing ring slots being put back to
    TP_STATUS_AVAILABLE. But such a bug will be caught in user space
    already as we end up realizing that we do not have any
    TP_STATUS_AVAILABLE slots left anymore. Therefore, we're all set.
    
    Btw, in case of RX_RING path, we do not make use of the pending
    member, therefore we also don't need to use up any percpu memory
    here. Also note that __alloc_percpu() already returns a zero-filled
    percpu area, so initialization is done already.
    
      [1] http://wiki.ipxwarzone.com/index.php5?title=Linux_packet_mmap
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 0a87d7b36c9e..eb9580a6b25f 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -64,7 +64,7 @@ struct packet_ring_buffer {
 	unsigned int		pg_vec_pages;
 	unsigned int		pg_vec_len;
 
-	atomic_t		pending;
+	unsigned int __percpu	*pending_refcnt;
 
 	struct tpacket_kbdq_core	prb_bdqc;
 };

commit d346a3fae3ff1d99f5d0c819bf86edf9094a26a1
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Fri Dec 6 11:36:17 2013 +0100

    packet: introduce PACKET_QDISC_BYPASS socket option
    
    This patch introduces a PACKET_QDISC_BYPASS socket option, that
    allows for using a similar xmit() function as in pktgen instead
    of taking the dev_queue_xmit() path. This can be very useful when
    PF_PACKET applications are required to be used in a similar
    scenario as pktgen, but with full, flexible packet payload that
    needs to be provided, for example.
    
    On default, nothing changes in behaviour for normal PF_PACKET
    TX users, so everything stays as is for applications. New users,
    however, can now set PACKET_QDISC_BYPASS if needed to prevent
    own packets from i) reentering packet_rcv() and ii) to directly
    push the frame to the driver.
    
    In doing so we can increase pps (here 64 byte packets) for
    PF_PACKET a bit:
    
      # CPUs -- QDISC_BYPASS   -- qdisc path -- qdisc path[**]
      1 CPU  ==  1,509,628 pps --  1,208,708 --  1,247,436
      2 CPUs ==  3,198,659 pps --  2,536,012 --  1,605,779
      3 CPUs ==  4,787,992 pps --  3,788,740 --  1,735,610
      4 CPUs ==  6,173,956 pps --  4,907,799 --  1,909,114
      5 CPUs ==  7,495,676 pps --  5,956,499 --  2,014,422
      6 CPUs ==  9,001,496 pps --  7,145,064 --  2,155,261
      7 CPUs == 10,229,776 pps --  8,190,596 --  2,220,619
      8 CPUs == 11,040,732 pps --  9,188,544 --  2,241,879
      9 CPUs == 12,009,076 pps -- 10,275,936 --  2,068,447
     10 CPUs == 11,380,052 pps -- 11,265,337 --  1,578,689
     11 CPUs == 11,672,676 pps -- 11,845,344 --  1,297,412
     [...]
     20 CPUs == 11,363,192 pps -- 11,014,933 --  1,245,081
    
     [**]: qdisc path with packet_rcv(), how probably most people
           seem to use it (hopefully not anymore if not needed)
    
    The test was done using a modified trafgen, sending a simple
    static 64 bytes packet, on all CPUs.  The trick in the fast
    "qdisc path" case, is to avoid reentering packet_rcv() by
    setting the RAW socket protocol to zero, like:
    socket(PF_PACKET, SOCK_RAW, 0);
    
    Tradeoffs are documented as well in this patch, clearly, if
    queues are busy, we will drop more packets, tc disciplines are
    ignored, and these packets are not visible to taps anymore. For
    a pktgen like scenario, we argue that this is acceptable.
    
    The pointer to the xmit function has been placed in packet
    socket structure hole between cached_dev and prot_hook that
    is hot anyway as we're working on cached_dev in each send path.
    
    Done in joint work together with Jesper Dangaard Brouer.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Jesper Dangaard Brouer <brouer@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 1035fa2d909c..0a87d7b36c9e 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -114,6 +114,7 @@ struct packet_sock {
 	unsigned int		tp_tx_has_off:1;
 	unsigned int		tp_tstamp;
 	struct net_device __rcu	*cached_dev;
+	int			(*xmit)(struct sk_buff *skb);
 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
 };
 

commit e40526cb20b5ee53419452e1f03d97092f144418
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Thu Nov 21 16:50:58 2013 +0100

    packet: fix use after free race in send path when dev is released
    
    Salam reported a use after free bug in PF_PACKET that occurs when
    we're sending out frames on a socket bound device and suddenly the
    net device is being unregistered. It appears that commit 827d9780
    introduced a possible race condition between {t,}packet_snd() and
    packet_notifier(). In the case of a bound socket, packet_notifier()
    can drop the last reference to the net_device and {t,}packet_snd()
    might end up suddenly sending a packet over a freed net_device.
    
    To avoid reverting 827d9780 and thus introducing a performance
    regression compared to the current state of things, we decided to
    hold a cached RCU protected pointer to the net device and maintain
    it on write side via bind spin_lock protected register_prot_hook()
    and __unregister_prot_hook() calls.
    
    In {t,}packet_snd() path, we access this pointer under rcu_read_lock
    through packet_cached_dev_get() that holds reference to the device
    to prevent it from being freed through packet_notifier() while
    we're in send path. This is okay to do as dev_put()/dev_hold() are
    per-cpu counters, so this should not be a performance issue. Also,
    the code simplifies a bit as we don't need need_rls_dev anymore.
    
    Fixes: 827d978037d7 ("af-packet: Use existing netdev reference for bound sockets.")
    Reported-by: Salam Noureddine <noureddine@aristanetworks.com>
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: Salam Noureddine <noureddine@aristanetworks.com>
    Cc: Ben Greear <greearb@candelatech.com>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index c4e4b4561207..1035fa2d909c 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -113,6 +113,7 @@ struct packet_sock {
 	unsigned int		tp_loss:1;
 	unsigned int		tp_tx_has_off:1;
 	unsigned int		tp_tstamp;
+	struct net_device __rcu	*cached_dev;
 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
 };
 

commit ee80fbf301adac644d0c9465194a7ec87bcd4a07
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Fri Apr 19 06:12:29 2013 +0000

    packet: account statistics only in tpacket_stats_u
    
    Currently, packet_sock has a struct tpacket_stats stats member for
    TPACKET_V1 and TPACKET_V2 statistic accounting, and with TPACKET_V3
    ``union tpacket_stats_u stats_u'' was introduced, where however only
    statistics for TPACKET_V3 are held, and when copied to user space,
    TPACKET_V3 does some hackery and access also tpacket_stats' stats,
    although everything could have been done within the union itself.
    
    Unify accounting within the tpacket_stats_u union so that we can
    remove 8 bytes from packet_sock that are there unnecessary. Note that
    even if we switch to TPACKET_V3 and would use non mmap(2)ed option,
    this still works due to the union with same types + offsets, that are
    exposed to the user space.
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 650751b9a7ee..c4e4b4561207 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -93,8 +93,7 @@ struct packet_sock {
 	/* struct sock has to be the first member of packet_sock */
 	struct sock		sk;
 	struct packet_fanout	*fanout;
-	struct tpacket_stats	stats;
-	union  tpacket_stats_u	stats_u;
+	union  tpacket_stats_u	stats;
 	struct packet_ring_buffer	rx_ring;
 	struct packet_ring_buffer	tx_ring;
 	int			copy_thresh;

commit 0578edc5604e3e192980f406f9e1040aa6434ca4
Author: Daniel Borkmann <dborkman@redhat.com>
Date:   Fri Apr 19 06:12:28 2013 +0000

    packet: reorder a member in packet_ring_buffer
    
    There's a 4 byte hole in packet_ring_buffer structure before
    prb_bdqc, that can be filled with 'pending' member, thus we can
    reduce the overall structure size from 224 bytes to 216 bytes.
    This also has the side-effect, that in struct packet_sock 2*4 byte
    holes after the embedded packet_ring_buffer members are removed,
    and overall, packet_sock can be reduced by 1 cacheline:
    
    Before: size: 1344, cachelines: 21, members: 24
    After:  size: 1280, cachelines: 20, members: 24
    
    Signed-off-by: Daniel Borkmann <dborkman@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index e891f025a1b9..650751b9a7ee 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -54,6 +54,7 @@ struct pgv {
 
 struct packet_ring_buffer {
 	struct pgv		*pg_vec;
+
 	unsigned int		head;
 	unsigned int		frames_per_block;
 	unsigned int		frame_size;
@@ -63,8 +64,9 @@ struct packet_ring_buffer {
 	unsigned int		pg_vec_pages;
 	unsigned int		pg_vec_len;
 
-	struct tpacket_kbdq_core	prb_bdqc;
 	atomic_t		pending;
+
+	struct tpacket_kbdq_core	prb_bdqc;
 };
 
 extern struct mutex fanout_mutex;

commit 77f65ebdca506870d99bfabe52bde222511022ec
Author: Willem de Bruijn <willemb@google.com>
Date:   Tue Mar 19 10:18:11 2013 +0000

    packet: packet fanout rollover during socket overload
    
    Changes:
      v3->v2: rebase (no other changes)
              passes selftest
      v2->v1: read f->num_members only once
              fix bug: test rollover mode + flag
    
    Minimize packet drop in a fanout group. If one socket is full,
    roll over packets to another from the group. Maintain flow
    affinity during normal load using an rxhash fanout policy, while
    dispersing unexpected traffic storms that hit a single cpu, such
    as spoofed-source DoS flows. Rollover breaks affinity for flows
    arriving at saturated sockets during those conditions.
    
    The patch adds a fanout policy ROLLOVER that rotates between sockets,
    filling each socket before moving to the next. It also adds a fanout
    flag ROLLOVER. If passed along with any other fanout policy, the
    primary policy is applied until the chosen socket is full. Then,
    rollover selects another socket, to delay packet drop until the
    entire system is saturated.
    
    Probing sockets is not free. Selecting the last used socket, as
    rollover does, is a greedy approach that maximizes chance of
    success, at the cost of extreme load imbalance. In practice, with
    sufficiently long queues to absorb bursts, sockets are drained in
    parallel and load balance looks uniform in `top`.
    
    To avoid contention, scales counters with number of sockets and
    accesses them lockfree. Values are bounds checked to ensure
    correctness.
    
    Tested using an application with 9 threads pinned to CPUs, one socket
    per thread and sufficient busywork per packet operation to limits each
    thread to handling 32 Kpps. When sent 500 Kpps single UDP stream
    packets, a FANOUT_CPU setup processes 32 Kpps in total without this
    patch, 270 Kpps with the patch. Tested with read() and with a packet
    ring (V1).
    
    Also, passes psock_fanout.c unit test added to selftests.
    
    Signed-off-by: Willem de Bruijn <willemb@google.com>
    Reviewed-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index e84cab8cb7a9..e891f025a1b9 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -77,10 +77,11 @@ struct packet_fanout {
 	unsigned int		num_members;
 	u16			id;
 	u8			type;
-	u8			defrag;
+	u8			flags;
 	atomic_t		rr_cur;
 	struct list_head	list;
 	struct sock		*arr[PACKET_FANOUT_MAX];
+	int			next[PACKET_FANOUT_MAX];
 	spinlock_t		lock;
 	atomic_t		sk_ref;
 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;

commit 5920cd3a41f1aefc30e9ce86384fc2fe9f5fe0c0
Author: Paul Chavent <Paul.Chavent@onera.fr>
Date:   Tue Nov 6 23:10:47 2012 +0000

    packet: tx_ring: allow the user to choose tx data offset
    
    The tx data offset of packet mmap tx ring used to be :
    (TPACKET2_HDRLEN - sizeof(struct sockaddr_ll))
    
    The problem is that, with SOCK_RAW socket, the payload (14 bytes after
    the beginning of the user data) is misaligned.
    
    This patch allows to let the user gives an offset for it's tx data if
    he desires.
    
    Set sock option PACKET_TX_HAS_OFF to 1, then specify in each frame of
    your tx ring tp_net for SOCK_DGRAM, or tp_mac for SOCK_RAW.
    
    Signed-off-by: Paul Chavent <paul.chavent@onera.fr>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 44945f6b7252..e84cab8cb7a9 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -109,6 +109,7 @@ struct packet_sock {
 	unsigned int		tp_hdrlen;
 	unsigned int		tp_reserve;
 	unsigned int		tp_loss:1;
+	unsigned int		tp_tx_has_off:1;
 	unsigned int		tp_tstamp;
 	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
 };

commit fff3321d75b1a18231876a1aceb36eacbbf6221e
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Thu Aug 16 05:36:48 2012 +0000

    packet: Report fanout status via diag engine
    
    Reported value is the same reported by the FANOUT getsockoption, but
    unlike it, the absent fanout setup results in absent nlattr, rather
    than in nlattr with zero value. This is done so, since zero fanout
    report may mean both -- no fanout, and fanout with both id and type zero.
    
    Signed-off-by: Pavel Emelyanov <xemul@parallels.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
index 2c5fca28b242..44945f6b7252 100644
--- a/net/packet/internal.h
+++ b/net/packet/internal.h
@@ -67,7 +67,25 @@ struct packet_ring_buffer {
 	atomic_t		pending;
 };
 
-struct packet_fanout;
+extern struct mutex fanout_mutex;
+#define PACKET_FANOUT_MAX	256
+
+struct packet_fanout {
+#ifdef CONFIG_NET_NS
+	struct net		*net;
+#endif
+	unsigned int		num_members;
+	u16			id;
+	u8			type;
+	u8			defrag;
+	atomic_t		rr_cur;
+	struct list_head	list;
+	struct sock		*arr[PACKET_FANOUT_MAX];
+	spinlock_t		lock;
+	atomic_t		sk_ref;
+	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
+};
+
 struct packet_sock {
 	/* struct sock has to be the first member of packet_sock */
 	struct sock		sk;

commit 2787b04b6c5e7607510e8248b38b0aeacb5505f6
Author: Pavel Emelyanov <xemul@parallels.com>
Date:   Mon Aug 13 05:49:39 2012 +0000

    packet: Introduce net/packet/internal.h header
    
    The diag module will need to access some private packet_sock data, so
    move it to a header in advance. This file will be shared between the
    af_packet.c and the diag.c
    
    Signed-off-by: Pavel Emelyanov <xemul@parallels.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/packet/internal.h b/net/packet/internal.h
new file mode 100644
index 000000000000..2c5fca28b242
--- /dev/null
+++ b/net/packet/internal.h
@@ -0,0 +1,103 @@
+#ifndef __PACKET_INTERNAL_H__
+#define __PACKET_INTERNAL_H__
+
+struct packet_mclist {
+	struct packet_mclist	*next;
+	int			ifindex;
+	int			count;
+	unsigned short		type;
+	unsigned short		alen;
+	unsigned char		addr[MAX_ADDR_LEN];
+};
+
+/* kbdq - kernel block descriptor queue */
+struct tpacket_kbdq_core {
+	struct pgv	*pkbdq;
+	unsigned int	feature_req_word;
+	unsigned int	hdrlen;
+	unsigned char	reset_pending_on_curr_blk;
+	unsigned char   delete_blk_timer;
+	unsigned short	kactive_blk_num;
+	unsigned short	blk_sizeof_priv;
+
+	/* last_kactive_blk_num:
+	 * trick to see if user-space has caught up
+	 * in order to avoid refreshing timer when every single pkt arrives.
+	 */
+	unsigned short	last_kactive_blk_num;
+
+	char		*pkblk_start;
+	char		*pkblk_end;
+	int		kblk_size;
+	unsigned int	knum_blocks;
+	uint64_t	knxt_seq_num;
+	char		*prev;
+	char		*nxt_offset;
+	struct sk_buff	*skb;
+
+	atomic_t	blk_fill_in_prog;
+
+	/* Default is set to 8ms */
+#define DEFAULT_PRB_RETIRE_TOV	(8)
+
+	unsigned short  retire_blk_tov;
+	unsigned short  version;
+	unsigned long	tov_in_jiffies;
+
+	/* timer to retire an outstanding block */
+	struct timer_list retire_blk_timer;
+};
+
+struct pgv {
+	char *buffer;
+};
+
+struct packet_ring_buffer {
+	struct pgv		*pg_vec;
+	unsigned int		head;
+	unsigned int		frames_per_block;
+	unsigned int		frame_size;
+	unsigned int		frame_max;
+
+	unsigned int		pg_vec_order;
+	unsigned int		pg_vec_pages;
+	unsigned int		pg_vec_len;
+
+	struct tpacket_kbdq_core	prb_bdqc;
+	atomic_t		pending;
+};
+
+struct packet_fanout;
+struct packet_sock {
+	/* struct sock has to be the first member of packet_sock */
+	struct sock		sk;
+	struct packet_fanout	*fanout;
+	struct tpacket_stats	stats;
+	union  tpacket_stats_u	stats_u;
+	struct packet_ring_buffer	rx_ring;
+	struct packet_ring_buffer	tx_ring;
+	int			copy_thresh;
+	spinlock_t		bind_lock;
+	struct mutex		pg_vec_lock;
+	unsigned int		running:1,	/* prot_hook is attached*/
+				auxdata:1,
+				origdev:1,
+				has_vnet_hdr:1;
+	int			ifindex;	/* bound device		*/
+	__be16			num;
+	struct packet_mclist	*mclist;
+	atomic_t		mapped;
+	enum tpacket_versions	tp_version;
+	unsigned int		tp_hdrlen;
+	unsigned int		tp_reserve;
+	unsigned int		tp_loss:1;
+	unsigned int		tp_tstamp;
+	struct packet_type	prot_hook ____cacheline_aligned_in_smp;
+};
+
+static struct packet_sock *pkt_sk(struct sock *sk)
+{
+	return (struct packet_sock *)sk;
+}
+
+#endif
