commit 6955a76fbcd56d27c84c01353101048e366d070f
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed May 13 08:46:58 2020 +0200

    bpfilter: switch to kernel_write
    
    While pipes don't really need sb_writers projection, __kernel_write is an
    interface better kept private, and the additional rw_verify_area does not
    hurt here.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index c0f0990f30b6..1905e01c3aa9 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -50,7 +50,7 @@ static int __bpfilter_process_sockopt(struct sock *sk, int optname,
 	req.len = optlen;
 	if (!bpfilter_ops.info.pid)
 		goto out;
-	n = __kernel_write(bpfilter_ops.info.pipe_to_umh, &req, sizeof(req),
+	n = kernel_write(bpfilter_ops.info.pipe_to_umh, &req, sizeof(req),
 			   &pos);
 	if (n != sizeof(req)) {
 		pr_err("write fail %zd\n", n);

commit 1dfd1711de2952fd1bfeea7152bd1687a4eea771
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Wed May 15 12:23:03 2019 -0500

    signal/bpfilter: Fix bpfilter_kernl to use send_sig not force_sig
    
    The locking in force_sig_info is not prepared to deal with
    a task that exits or execs (as sighand may change).  As force_sig
    is only built to handle synchronous exceptions.
    
    Further the function force_sig_info changes the signal state if the
    signal is ignored, or blocked or if SIGNAL_UNKILLABLE will prevent the
    delivery of the signal.  The signal SIGKILL can not be ignored and can
    not be blocked and SIGNAL_UNKILLABLE won't prevent it from being
    delivered.
    
    So using force_sig rather than send_sig for SIGKILL is pointless.
    
    Because it won't impact the sending of the signal and and because
    using force_sig is wrong, replace force_sig with send_sig.
    
    Cc: Alexei Starovoitov <ast@kernel.org>
    Cc: David S. Miller <davem@davemloft.net>
    Fixes: d2ba09c17a06 ("net: add skeleton of bpfilter kernel module")
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index 7ee4fea93637..c0f0990f30b6 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -22,7 +22,7 @@ static void shutdown_umh(void)
 
 	tsk = get_pid_task(find_vpid(bpfilter_ops.info.pid), PIDTYPE_PID);
 	if (tsk) {
-		force_sig(SIGKILL, tsk);
+		send_sig(SIGKILL, tsk, 1);
 		put_task_struct(tsk);
 	}
 }

commit 71a8508402b570127d6500c1ad456bbd33ccf187
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Jan 9 02:25:10 2019 +0900

    net: bpfilter: disallow to remove bpfilter module while being used
    
    The bpfilter.ko module can be removed while functions of the bpfilter.ko
    are executing. so panic can occurred. in order to protect that, locks can
    be used. a bpfilter_lock protects routines in the
    __bpfilter_process_sockopt() but it's not enough because __exit routine
    can be executed concurrently.
    
    Now, the bpfilter_umh can not run in parallel.
    So, the module do not removed while it's being used and it do not
    double-create UMH process.
    The members of the umh_info and the bpfilter_umh_ops are protected by
    the bpfilter_umh_ops.lock.
    
    test commands:
       while :
       do
            iptables -I FORWARD -m string --string ap --algo kmp &
            modprobe -rv bpfilter &
       done
    
    splat looks like:
    [  298.623435] BUG: unable to handle kernel paging request at fffffbfff807440b
    [  298.628512] #PF error: [normal kernel read fault]
    [  298.633018] PGD 124327067 P4D 124327067 PUD 11c1a3067 PMD 119eb2067 PTE 0
    [  298.638859] Oops: 0000 [#1] SMP DEBUG_PAGEALLOC KASAN PTI
    [  298.638859] CPU: 0 PID: 2997 Comm: iptables Not tainted 4.20.0+ #154
    [  298.638859] RIP: 0010:__mutex_lock+0x6b9/0x16a0
    [  298.638859] Code: c0 00 00 e8 89 82 ff ff 80 bd 8f fc ff ff 00 0f 85 d9 05 00 00 48 8b 85 80 fc ff ff 48 bf 00 00 00 00 00 fc ff df 48 c1 e8 03 <80> 3c 38 00 0f 85 1d 0e 00 00 48 8b 85 c8 fc ff ff 49 39 47 58 c6
    [  298.638859] RSP: 0018:ffff88810e7777a0 EFLAGS: 00010202
    [  298.638859] RAX: 1ffffffff807440b RBX: ffff888111bd4d80 RCX: 0000000000000000
    [  298.638859] RDX: 1ffff110235ff806 RSI: ffff888111bd5538 RDI: dffffc0000000000
    [  298.638859] RBP: ffff88810e777b30 R08: 0000000080000002 R09: 0000000000000000
    [  298.638859] R10: 0000000000000000 R11: 0000000000000000 R12: fffffbfff168a42c
    [  298.638859] R13: ffff888111bd4d80 R14: ffff8881040e9a05 R15: ffffffffc03a2000
    [  298.638859] FS:  00007f39e3758700(0000) GS:ffff88811ae00000(0000) knlGS:0000000000000000
    [  298.638859] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [  298.638859] CR2: fffffbfff807440b CR3: 000000011243e000 CR4: 00000000001006f0
    [  298.638859] Call Trace:
    [  298.638859]  ? mutex_lock_io_nested+0x1560/0x1560
    [  298.638859]  ? kasan_kmalloc+0xa0/0xd0
    [  298.638859]  ? kmem_cache_alloc+0x1c2/0x260
    [  298.638859]  ? __alloc_file+0x92/0x3c0
    [  298.638859]  ? alloc_empty_file+0x43/0x120
    [  298.638859]  ? alloc_file_pseudo+0x220/0x330
    [  298.638859]  ? sock_alloc_file+0x39/0x160
    [  298.638859]  ? __sys_socket+0x113/0x1d0
    [  298.638859]  ? __x64_sys_socket+0x6f/0xb0
    [  298.638859]  ? do_syscall_64+0x138/0x560
    [  298.638859]  ? entry_SYSCALL_64_after_hwframe+0x49/0xbe
    [  298.638859]  ? __alloc_file+0x92/0x3c0
    [  298.638859]  ? init_object+0x6b/0x80
    [  298.638859]  ? cyc2ns_read_end+0x10/0x10
    [  298.638859]  ? cyc2ns_read_end+0x10/0x10
    [  298.638859]  ? hlock_class+0x140/0x140
    [  298.638859]  ? sched_clock_local+0xd4/0x140
    [  298.638859]  ? sched_clock_local+0xd4/0x140
    [  298.638859]  ? check_flags.part.37+0x440/0x440
    [  298.638859]  ? __lock_acquire+0x4f90/0x4f90
    [  298.638859]  ? set_rq_offline.part.89+0x140/0x140
    [ ... ]
    
    Fixes: d2ba09c17a06 ("net: add skeleton of bpfilter kernel module")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index c0fcde910a7a..7ee4fea93637 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -13,9 +13,6 @@
 extern char bpfilter_umh_start;
 extern char bpfilter_umh_end;
 
-/* since ip_getsockopt() can run in parallel, serialize access to umh */
-static DEFINE_MUTEX(bpfilter_lock);
-
 static void shutdown_umh(void)
 {
 	struct task_struct *tsk;
@@ -36,13 +33,6 @@ static void __stop_umh(void)
 		shutdown_umh();
 }
 
-static void stop_umh(void)
-{
-	mutex_lock(&bpfilter_lock);
-	__stop_umh();
-	mutex_unlock(&bpfilter_lock);
-}
-
 static int __bpfilter_process_sockopt(struct sock *sk, int optname,
 				      char __user *optval,
 				      unsigned int optlen, bool is_set)
@@ -58,7 +48,6 @@ static int __bpfilter_process_sockopt(struct sock *sk, int optname,
 	req.cmd = optname;
 	req.addr = (long __force __user)optval;
 	req.len = optlen;
-	mutex_lock(&bpfilter_lock);
 	if (!bpfilter_ops.info.pid)
 		goto out;
 	n = __kernel_write(bpfilter_ops.info.pipe_to_umh, &req, sizeof(req),
@@ -80,7 +69,6 @@ static int __bpfilter_process_sockopt(struct sock *sk, int optname,
 	}
 	ret = reply.status;
 out:
-	mutex_unlock(&bpfilter_lock);
 	return ret;
 }
 
@@ -99,7 +87,7 @@ static int start_umh(void)
 
 	/* health check that usermode process started correctly */
 	if (__bpfilter_process_sockopt(NULL, 0, NULL, 0, 0) != 0) {
-		stop_umh();
+		shutdown_umh();
 		return -EFAULT;
 	}
 
@@ -110,24 +98,30 @@ static int __init load_umh(void)
 {
 	int err;
 
-	if (!bpfilter_ops.stop)
-		return -EFAULT;
+	mutex_lock(&bpfilter_ops.lock);
+	if (!bpfilter_ops.stop) {
+		err = -EFAULT;
+		goto out;
+	}
 	err = start_umh();
 	if (!err && IS_ENABLED(CONFIG_INET)) {
 		bpfilter_ops.sockopt = &__bpfilter_process_sockopt;
 		bpfilter_ops.start = &start_umh;
 	}
-
+out:
+	mutex_unlock(&bpfilter_ops.lock);
 	return err;
 }
 
 static void __exit fini_umh(void)
 {
+	mutex_lock(&bpfilter_ops.lock);
 	if (IS_ENABLED(CONFIG_INET)) {
+		shutdown_umh();
 		bpfilter_ops.start = NULL;
 		bpfilter_ops.sockopt = NULL;
 	}
-	stop_umh();
+	mutex_unlock(&bpfilter_ops.lock);
 }
 module_init(load_umh);
 module_exit(fini_umh);

commit 61fbf5933d42b02f552123af5a87a06335a3b4db
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Jan 9 02:24:53 2019 +0900

    net: bpfilter: restart bpfilter_umh when error occurred
    
    The bpfilter_umh will be stopped via __stop_umh() when the bpfilter
    error occurred.
    The bpfilter_umh() couldn't start again because there is no restart
    routine.
    
    The section of the bpfilter_umh_{start/end} is no longer .init.rodata
    because these area should be reused in the restart routine. hence
    the section name is changed to .bpfilter_umh.
    
    The bpfilter_ops->start() is restart callback. it will be called when
    bpfilter_umh is stopped.
    The stop bit means bpfilter_umh is stopped. this bit is set by both
    start and stop routine.
    
    Before this patch,
    Test commands:
       $ iptables -vnL
       $ kill -9 <pid of bpfilter_umh>
       $ iptables -vnL
       [  480.045136] bpfilter: write fail -32
       $ iptables -vnL
    
    All iptables commands will fail.
    
    After this patch,
    Test commands:
       $ iptables -vnL
       $ kill -9 <pid of bpfilter_umh>
       $ iptables -vnL
       $ iptables -vnL
    
    Now, all iptables commands will work.
    
    Fixes: d2ba09c17a06 ("net: add skeleton of bpfilter kernel module")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index a68940b74c01..c0fcde910a7a 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -16,13 +16,14 @@ extern char bpfilter_umh_end;
 /* since ip_getsockopt() can run in parallel, serialize access to umh */
 static DEFINE_MUTEX(bpfilter_lock);
 
-static void shutdown_umh(struct umh_info *info)
+static void shutdown_umh(void)
 {
 	struct task_struct *tsk;
 
-	if (!info->pid)
+	if (bpfilter_ops.stop)
 		return;
-	tsk = get_pid_task(find_vpid(info->pid), PIDTYPE_PID);
+
+	tsk = get_pid_task(find_vpid(bpfilter_ops.info.pid), PIDTYPE_PID);
 	if (tsk) {
 		force_sig(SIGKILL, tsk);
 		put_task_struct(tsk);
@@ -31,10 +32,8 @@ static void shutdown_umh(struct umh_info *info)
 
 static void __stop_umh(void)
 {
-	if (IS_ENABLED(CONFIG_INET)) {
-		bpfilter_ops.sockopt = NULL;
-		shutdown_umh(&bpfilter_ops.info);
-	}
+	if (IS_ENABLED(CONFIG_INET))
+		shutdown_umh();
 }
 
 static void stop_umh(void)
@@ -85,7 +84,7 @@ static int __bpfilter_process_sockopt(struct sock *sk, int optname,
 	return ret;
 }
 
-static int __init load_umh(void)
+static int start_umh(void)
 {
 	int err;
 
@@ -95,6 +94,7 @@ static int __init load_umh(void)
 				 &bpfilter_ops.info);
 	if (err)
 		return err;
+	bpfilter_ops.stop = false;
 	pr_info("Loaded bpfilter_umh pid %d\n", bpfilter_ops.info.pid);
 
 	/* health check that usermode process started correctly */
@@ -102,14 +102,31 @@ static int __init load_umh(void)
 		stop_umh();
 		return -EFAULT;
 	}
-	if (IS_ENABLED(CONFIG_INET))
-		bpfilter_ops.sockopt = &__bpfilter_process_sockopt;
 
 	return 0;
 }
 
+static int __init load_umh(void)
+{
+	int err;
+
+	if (!bpfilter_ops.stop)
+		return -EFAULT;
+	err = start_umh();
+	if (!err && IS_ENABLED(CONFIG_INET)) {
+		bpfilter_ops.sockopt = &__bpfilter_process_sockopt;
+		bpfilter_ops.start = &start_umh;
+	}
+
+	return err;
+}
+
 static void __exit fini_umh(void)
 {
+	if (IS_ENABLED(CONFIG_INET)) {
+		bpfilter_ops.start = NULL;
+		bpfilter_ops.sockopt = NULL;
+	}
 	stop_umh();
 }
 module_init(load_umh);

commit 5b4cb650e569db2e6a09d2fa0ef8eb789a0ac5d8
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Jan 9 02:24:34 2019 +0900

    net: bpfilter: use cleanup callback to release umh_info
    
    Now, UMH process is killed, do_exit() calls the umh_info->cleanup callback
    to release members of the umh_info.
    This patch makes bpfilter_umh's cleanup routine to use the
    umh_info->cleanup callback.
    
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index 7acfc83087d5..a68940b74c01 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -13,7 +13,6 @@
 extern char bpfilter_umh_start;
 extern char bpfilter_umh_end;
 
-static struct umh_info info;
 /* since ip_getsockopt() can run in parallel, serialize access to umh */
 static DEFINE_MUTEX(bpfilter_lock);
 
@@ -28,16 +27,13 @@ static void shutdown_umh(struct umh_info *info)
 		force_sig(SIGKILL, tsk);
 		put_task_struct(tsk);
 	}
-	fput(info->pipe_to_umh);
-	fput(info->pipe_from_umh);
-	info->pid = 0;
 }
 
 static void __stop_umh(void)
 {
 	if (IS_ENABLED(CONFIG_INET)) {
-		bpfilter_process_sockopt = NULL;
-		shutdown_umh(&info);
+		bpfilter_ops.sockopt = NULL;
+		shutdown_umh(&bpfilter_ops.info);
 	}
 }
 
@@ -64,9 +60,10 @@ static int __bpfilter_process_sockopt(struct sock *sk, int optname,
 	req.addr = (long __force __user)optval;
 	req.len = optlen;
 	mutex_lock(&bpfilter_lock);
-	if (!info.pid)
+	if (!bpfilter_ops.info.pid)
 		goto out;
-	n = __kernel_write(info.pipe_to_umh, &req, sizeof(req), &pos);
+	n = __kernel_write(bpfilter_ops.info.pipe_to_umh, &req, sizeof(req),
+			   &pos);
 	if (n != sizeof(req)) {
 		pr_err("write fail %zd\n", n);
 		__stop_umh();
@@ -74,7 +71,8 @@ static int __bpfilter_process_sockopt(struct sock *sk, int optname,
 		goto out;
 	}
 	pos = 0;
-	n = kernel_read(info.pipe_from_umh, &reply, sizeof(reply), &pos);
+	n = kernel_read(bpfilter_ops.info.pipe_from_umh, &reply, sizeof(reply),
+			&pos);
 	if (n != sizeof(reply)) {
 		pr_err("read fail %zd\n", n);
 		__stop_umh();
@@ -92,13 +90,12 @@ static int __init load_umh(void)
 	int err;
 
 	/* fork usermode process */
-	info.cmdline = "bpfilter_umh";
 	err = fork_usermode_blob(&bpfilter_umh_start,
 				 &bpfilter_umh_end - &bpfilter_umh_start,
-				 &info);
+				 &bpfilter_ops.info);
 	if (err)
 		return err;
-	pr_info("Loaded bpfilter_umh pid %d\n", info.pid);
+	pr_info("Loaded bpfilter_umh pid %d\n", bpfilter_ops.info.pid);
 
 	/* health check that usermode process started correctly */
 	if (__bpfilter_process_sockopt(NULL, 0, NULL, 0, 0) != 0) {
@@ -106,7 +103,7 @@ static int __init load_umh(void)
 		return -EFAULT;
 	}
 	if (IS_ENABLED(CONFIG_INET))
-		bpfilter_process_sockopt = &__bpfilter_process_sockopt;
+		bpfilter_ops.sockopt = &__bpfilter_process_sockopt;
 
 	return 0;
 }

commit 4b78030b8f2ca29c267b4ca38e900d92428c412e
Author: Olivier Brunel <jjk@jjacky.com>
Date:   Sat Oct 20 19:39:57 2018 +0200

    net: bpfilter: Set user mode helper's command line
    
    Signed-off-by: Olivier Brunel <jjk@jjacky.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index 94e88f510c5b..7acfc83087d5 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -92,6 +92,7 @@ static int __init load_umh(void)
 	int err;
 
 	/* fork usermode process */
+	info.cmdline = "bpfilter_umh";
 	err = fork_usermode_blob(&bpfilter_umh_start,
 				 &bpfilter_umh_end - &bpfilter_umh_start,
 				 &info);

commit 84258438e8ce12d6888b68a1238bba9cb25307e2
Author: Taehee Yoo <ap420073@gmail.com>
Date:   Wed Oct 17 00:35:10 2018 +0900

    net: bpfilter: use get_pid_task instead of pid_task
    
    pid_task() dereferences rcu protected tasks array.
    But there is no rcu_read_lock() in shutdown_umh() routine so that
    rcu_read_lock() is needed.
    get_pid_task() is wrapper function of pid_task. it holds rcu_read_lock()
    then calls pid_task(). if task isn't NULL, it increases reference count
    of task.
    
    test commands:
       %modprobe bpfilter
       %modprobe -rv bpfilter
    
    splat looks like:
    [15102.030932] =============================
    [15102.030957] WARNING: suspicious RCU usage
    [15102.030985] 4.19.0-rc7+ #21 Not tainted
    [15102.031010] -----------------------------
    [15102.031038] kernel/pid.c:330 suspicious rcu_dereference_check() usage!
    [15102.031063]
                   other info that might help us debug this:
    
    [15102.031332]
                   rcu_scheduler_active = 2, debug_locks = 1
    [15102.031363] 1 lock held by modprobe/1570:
    [15102.031389]  #0: 00000000580ef2b0 (bpfilter_lock){+.+.}, at: stop_umh+0x13/0x52 [bpfilter]
    [15102.031552]
                   stack backtrace:
    [15102.031583] CPU: 1 PID: 1570 Comm: modprobe Not tainted 4.19.0-rc7+ #21
    [15102.031607] Hardware name: To be filled by O.E.M. To be filled by O.E.M./Aptio CRB, BIOS 5.6.5 07/08/2015
    [15102.031628] Call Trace:
    [15102.031676]  dump_stack+0xc9/0x16b
    [15102.031723]  ? show_regs_print_info+0x5/0x5
    [15102.031801]  ? lockdep_rcu_suspicious+0x117/0x160
    [15102.031855]  pid_task+0x134/0x160
    [15102.031900]  ? find_vpid+0xf0/0xf0
    [15102.032017]  shutdown_umh.constprop.1+0x1e/0x53 [bpfilter]
    [15102.032055]  stop_umh+0x46/0x52 [bpfilter]
    [15102.032092]  __x64_sys_delete_module+0x47e/0x570
    [ ... ]
    
    Fixes: d2ba09c17a06 ("net: add skeleton of bpfilter kernel module")
    Signed-off-by: Taehee Yoo <ap420073@gmail.com>
    Acked-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index b64e1649993b..94e88f510c5b 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -23,9 +23,11 @@ static void shutdown_umh(struct umh_info *info)
 
 	if (!info->pid)
 		return;
-	tsk = pid_task(find_vpid(info->pid), PIDTYPE_PID);
-	if (tsk)
+	tsk = get_pid_task(find_vpid(info->pid), PIDTYPE_PID);
+	if (tsk) {
 		force_sig(SIGKILL, tsk);
+		put_task_struct(tsk);
+	}
 	fput(info->pipe_to_umh);
 	fput(info->pipe_from_umh);
 	info->pid = 0;

commit 33aa8da1f8a7dc050b9d68f1db761ab787621065
Author: Shanthosh RK <shanthosh.rk@gmail.com>
Date:   Fri Oct 5 20:57:48 2018 +0530

    net: bpfilter: Fix type cast and pointer warnings
    
    Fixes the following Sparse warnings:
    
    net/bpfilter/bpfilter_kern.c:62:21: warning: cast removes address space
    of expression
    net/bpfilter/bpfilter_kern.c:101:49: warning: Using plain integer as
    NULL pointer
    
    Signed-off-by: Shanthosh RK <shanthosh.rk@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index f0fc182d3db7..b64e1649993b 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -59,7 +59,7 @@ static int __bpfilter_process_sockopt(struct sock *sk, int optname,
 	req.is_set = is_set;
 	req.pid = current->pid;
 	req.cmd = optname;
-	req.addr = (long)optval;
+	req.addr = (long __force __user)optval;
 	req.len = optlen;
 	mutex_lock(&bpfilter_lock);
 	if (!info.pid)
@@ -98,7 +98,7 @@ static int __init load_umh(void)
 	pr_info("Loaded bpfilter_umh pid %d\n", info.pid);
 
 	/* health check that usermode process started correctly */
-	if (__bpfilter_process_sockopt(NULL, 0, 0, 0, 0) != 0) {
+	if (__bpfilter_process_sockopt(NULL, 0, NULL, 0, 0) != 0) {
 		stop_umh();
 		return -EFAULT;
 	}

commit 8e75887d321d102200abf3a9fa621e2c10ff4cc5
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Jun 26 20:13:48 2018 -0700

    bpfilter: include bpfilter_umh in assembly instead of using objcopy
    
    What we want here is to embed a user-space program into the kernel.
    Instead of the complex ELF magic, let's simply wrap it in the assembly
    with the '.incbin' directive.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index 09522573f611..f0fc182d3db7 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -10,11 +10,8 @@
 #include <linux/file.h>
 #include "msgfmt.h"
 
-#define UMH_start _binary_net_bpfilter_bpfilter_umh_start
-#define UMH_end _binary_net_bpfilter_bpfilter_umh_end
-
-extern char UMH_start;
-extern char UMH_end;
+extern char bpfilter_umh_start;
+extern char bpfilter_umh_end;
 
 static struct umh_info info;
 /* since ip_getsockopt() can run in parallel, serialize access to umh */
@@ -93,7 +90,9 @@ static int __init load_umh(void)
 	int err;
 
 	/* fork usermode process */
-	err = fork_usermode_blob(&UMH_start, &UMH_end - &UMH_start, &info);
+	err = fork_usermode_blob(&bpfilter_umh_start,
+				 &bpfilter_umh_end - &bpfilter_umh_start,
+				 &info);
 	if (err)
 		return err;
 	pr_info("Loaded bpfilter_umh pid %d\n", info.pid);

commit 66e58e0ef80a56a1d7857b6ce121141563cdd93e
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Thu Jun 7 15:31:14 2018 -0700

    bpfilter: fix race in pipe access
    
    syzbot reported the following crash
    [  338.293946] bpfilter: read fail -512
    [  338.304515] kasan: GPF could be caused by NULL-ptr deref or user memory access
    [  338.311863] general protection fault: 0000 [#1] SMP KASAN
    [  338.344360] RIP: 0010:__vfs_write+0x4a6/0x960
    [  338.426363] Call Trace:
    [  338.456967]  __kernel_write+0x10c/0x380
    [  338.460928]  __bpfilter_process_sockopt+0x1d8/0x35b
    [  338.487103]  bpfilter_mbox_request+0x4d/0xb0
    [  338.491492]  bpfilter_ip_get_sockopt+0x6b/0x90
    
    This can happen when multiple cpus trying to talk to user mode process
    via bpfilter_mbox_request(). One cpu grabs the mutex while another goes to
    sleep on the same mutex. Then former cpu sees that umh pipe is down and
    shuts down the pipes. Later cpu finally acquires the mutex and crashes
    on freed pipe.
    Fix the race by using info.pid as an indicator that umh and pipes are healthy
    and check it after acquiring the mutex.
    
    Fixes: d2ba09c17a06 ("net: add skeleton of bpfilter kernel module")
    Reported-by: syzbot+7ade6c94abb2774c0fee@syzkaller.appspotmail.com
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index b13d058f8c34..09522573f611 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -24,17 +24,19 @@ static void shutdown_umh(struct umh_info *info)
 {
 	struct task_struct *tsk;
 
+	if (!info->pid)
+		return;
 	tsk = pid_task(find_vpid(info->pid), PIDTYPE_PID);
 	if (tsk)
 		force_sig(SIGKILL, tsk);
 	fput(info->pipe_to_umh);
 	fput(info->pipe_from_umh);
+	info->pid = 0;
 }
 
 static void __stop_umh(void)
 {
-	if (IS_ENABLED(CONFIG_INET) &&
-	    bpfilter_process_sockopt) {
+	if (IS_ENABLED(CONFIG_INET)) {
 		bpfilter_process_sockopt = NULL;
 		shutdown_umh(&info);
 	}
@@ -55,7 +57,7 @@ static int __bpfilter_process_sockopt(struct sock *sk, int optname,
 	struct mbox_reply reply;
 	loff_t pos;
 	ssize_t n;
-	int ret;
+	int ret = -EFAULT;
 
 	req.is_set = is_set;
 	req.pid = current->pid;
@@ -63,6 +65,8 @@ static int __bpfilter_process_sockopt(struct sock *sk, int optname,
 	req.addr = (long)optval;
 	req.len = optlen;
 	mutex_lock(&bpfilter_lock);
+	if (!info.pid)
+		goto out;
 	n = __kernel_write(info.pipe_to_umh, &req, sizeof(req), &pos);
 	if (n != sizeof(req)) {
 		pr_err("write fail %zd\n", n);

commit d71dbdaa2d94d425fff4a59e10eb5be9f61a2661
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue May 29 11:55:06 2018 +0200

    bpfilter: fix building without CONFIG_INET
    
    bpfilter_process_sockopt is a callback that gets called from
    ip_setsockopt() and ip_getsockopt(). However, when CONFIG_INET is
    disabled, it never gets called at all, and assigning a function to the
    callback pointer results in a link failure:
    
    net/bpfilter/bpfilter_kern.o: In function `__stop_umh':
    bpfilter_kern.c:(.text.unlikely+0x3): undefined reference to `bpfilter_process_sockopt'
    net/bpfilter/bpfilter_kern.o: In function `load_umh':
    bpfilter_kern.c:(.init.text+0x73): undefined reference to `bpfilter_process_sockopt'
    
    Since there is no caller in this configuration, I assume we can
    simply make the assignment conditional.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
index 7596314b61c7..b13d058f8c34 100644
--- a/net/bpfilter/bpfilter_kern.c
+++ b/net/bpfilter/bpfilter_kern.c
@@ -33,7 +33,8 @@ static void shutdown_umh(struct umh_info *info)
 
 static void __stop_umh(void)
 {
-	if (bpfilter_process_sockopt) {
+	if (IS_ENABLED(CONFIG_INET) &&
+	    bpfilter_process_sockopt) {
 		bpfilter_process_sockopt = NULL;
 		shutdown_umh(&info);
 	}
@@ -98,7 +99,9 @@ static int __init load_umh(void)
 		stop_umh();
 		return -EFAULT;
 	}
-	bpfilter_process_sockopt = &__bpfilter_process_sockopt;
+	if (IS_ENABLED(CONFIG_INET))
+		bpfilter_process_sockopt = &__bpfilter_process_sockopt;
+
 	return 0;
 }
 

commit d2ba09c17a0647f899d6c20a11bab9e6d3382f07
Author: Alexei Starovoitov <ast@kernel.org>
Date:   Mon May 21 19:22:30 2018 -0700

    net: add skeleton of bpfilter kernel module
    
    bpfilter.ko consists of bpfilter_kern.c (normal kernel module code)
    and user mode helper code that is embedded into bpfilter.ko
    
    The steps to build bpfilter.ko are the following:
    - main.c is compiled by HOSTCC into the bpfilter_umh elf executable file
    - with quite a bit of objcopy and Makefile magic the bpfilter_umh elf file
      is converted into bpfilter_umh.o object file
      with _binary_net_bpfilter_bpfilter_umh_start and _end symbols
      Example:
      $ nm ./bld_x64/net/bpfilter/bpfilter_umh.o
      0000000000004cf8 T _binary_net_bpfilter_bpfilter_umh_end
      0000000000004cf8 A _binary_net_bpfilter_bpfilter_umh_size
      0000000000000000 T _binary_net_bpfilter_bpfilter_umh_start
    - bpfilter_umh.o and bpfilter_kern.o are linked together into bpfilter.ko
    
    bpfilter_kern.c is a normal kernel module code that calls
    the fork_usermode_blob() helper to execute part of its own data
    as a user mode process.
    
    Notice that _binary_net_bpfilter_bpfilter_umh_start - end
    is placed into .init.rodata section, so it's freed as soon as __init
    function of bpfilter.ko is finished.
    As part of __init the bpfilter.ko does first request/reply action
    via two unix pipe provided by fork_usermode_blob() helper to
    make sure that umh is healthy. If not it will kill it via pid.
    
    Later bpfilter_process_sockopt() will be called from bpfilter hooks
    in get/setsockopt() to pass iptable commands into umh via bpfilter.ko
    
    If admin does 'rmmod bpfilter' the __exit code bpfilter.ko will
    kill umh as well.
    
    Signed-off-by: Alexei Starovoitov <ast@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/bpfilter/bpfilter_kern.c b/net/bpfilter/bpfilter_kern.c
new file mode 100644
index 000000000000..7596314b61c7
--- /dev/null
+++ b/net/bpfilter/bpfilter_kern.c
@@ -0,0 +1,111 @@
+// SPDX-License-Identifier: GPL-2.0
+#define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/umh.h>
+#include <linux/bpfilter.h>
+#include <linux/sched.h>
+#include <linux/sched/signal.h>
+#include <linux/fs.h>
+#include <linux/file.h>
+#include "msgfmt.h"
+
+#define UMH_start _binary_net_bpfilter_bpfilter_umh_start
+#define UMH_end _binary_net_bpfilter_bpfilter_umh_end
+
+extern char UMH_start;
+extern char UMH_end;
+
+static struct umh_info info;
+/* since ip_getsockopt() can run in parallel, serialize access to umh */
+static DEFINE_MUTEX(bpfilter_lock);
+
+static void shutdown_umh(struct umh_info *info)
+{
+	struct task_struct *tsk;
+
+	tsk = pid_task(find_vpid(info->pid), PIDTYPE_PID);
+	if (tsk)
+		force_sig(SIGKILL, tsk);
+	fput(info->pipe_to_umh);
+	fput(info->pipe_from_umh);
+}
+
+static void __stop_umh(void)
+{
+	if (bpfilter_process_sockopt) {
+		bpfilter_process_sockopt = NULL;
+		shutdown_umh(&info);
+	}
+}
+
+static void stop_umh(void)
+{
+	mutex_lock(&bpfilter_lock);
+	__stop_umh();
+	mutex_unlock(&bpfilter_lock);
+}
+
+static int __bpfilter_process_sockopt(struct sock *sk, int optname,
+				      char __user *optval,
+				      unsigned int optlen, bool is_set)
+{
+	struct mbox_request req;
+	struct mbox_reply reply;
+	loff_t pos;
+	ssize_t n;
+	int ret;
+
+	req.is_set = is_set;
+	req.pid = current->pid;
+	req.cmd = optname;
+	req.addr = (long)optval;
+	req.len = optlen;
+	mutex_lock(&bpfilter_lock);
+	n = __kernel_write(info.pipe_to_umh, &req, sizeof(req), &pos);
+	if (n != sizeof(req)) {
+		pr_err("write fail %zd\n", n);
+		__stop_umh();
+		ret = -EFAULT;
+		goto out;
+	}
+	pos = 0;
+	n = kernel_read(info.pipe_from_umh, &reply, sizeof(reply), &pos);
+	if (n != sizeof(reply)) {
+		pr_err("read fail %zd\n", n);
+		__stop_umh();
+		ret = -EFAULT;
+		goto out;
+	}
+	ret = reply.status;
+out:
+	mutex_unlock(&bpfilter_lock);
+	return ret;
+}
+
+static int __init load_umh(void)
+{
+	int err;
+
+	/* fork usermode process */
+	err = fork_usermode_blob(&UMH_start, &UMH_end - &UMH_start, &info);
+	if (err)
+		return err;
+	pr_info("Loaded bpfilter_umh pid %d\n", info.pid);
+
+	/* health check that usermode process started correctly */
+	if (__bpfilter_process_sockopt(NULL, 0, 0, 0, 0) != 0) {
+		stop_umh();
+		return -EFAULT;
+	}
+	bpfilter_process_sockopt = &__bpfilter_process_sockopt;
+	return 0;
+}
+
+static void __exit fini_umh(void)
+{
+	stop_umh();
+}
+module_init(load_umh);
+module_exit(fini_umh);
+MODULE_LICENSE("GPL");
