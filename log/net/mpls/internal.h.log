commit 86ae579cefffe18cb08928505d90fbc87367e8f5
Author: Eli Cohen <eli@mellanox.com>
Date:   Wed May 27 08:35:03 2020 +0300

    net: Make mpls_entry_encode() available for generic users
    
    Move mpls_entry_encode() from net/mpls/internal.h to include/net/mpls.h
    and make it available for other users. Specifically, hardware driver that
    offload MPLS can benefit from that.
    
    Suggested-by: Jakub Kicinski <kuba@kernel.org>
    Suggested-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: Eli Cohen <eli@mellanox.com>
    Signed-off-by: Saeed Mahameed <saeedm@mellanox.com>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 0e9aa94adc07..838cdfc10e47 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -172,17 +172,6 @@ struct mpls_route { /* next hop label forwarding entry */
 
 #define endfor_nexthops(rt) }
 
-static inline struct mpls_shim_hdr mpls_entry_encode(u32 label, unsigned ttl, unsigned tc, bool bos)
-{
-	struct mpls_shim_hdr result;
-	result.label_stack_entry =
-		cpu_to_be32((label << MPLS_LS_LABEL_SHIFT) |
-			    (tc << MPLS_LS_TC_SHIFT) |
-			    (bos ? (1 << MPLS_LS_S_SHIFT) : 0) |
-			    (ttl << MPLS_LS_TTL_SHIFT));
-	return result;
-}
-
 static inline struct mpls_entry_decoded mpls_entry_decode(struct mpls_shim_hdr *hdr)
 {
 	struct mpls_entry_decoded result;

commit 680a93166e80e43e3ff85be06005c5cfa492d852
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Fri Feb 28 07:26:15 2020 -0600

    net: mpls: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 768a302879b4..0e9aa94adc07 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -98,7 +98,7 @@ struct mpls_nh { /* next hop label forwarding entry */
 	u8			nh_via_table;
 	u8			nh_reserved1;
 
-	u32			nh_label[0];
+	u32			nh_label[];
 };
 
 /* offset of via from beginning of mpls_nh */
@@ -154,7 +154,7 @@ struct mpls_route { /* next hop label forwarding entry */
 	u8			rt_nh_size;
 	u8			rt_via_offset;
 	u8			rt_reserved1;
-	struct mpls_nh		rt_nh[0];
+	struct mpls_nh		rt_nh[];
 };
 
 #define for_nexthops(rt) {						\

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index cf65aec2e551..768a302879b4 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef MPLS_INTERNAL_H
 #define MPLS_INTERNAL_H
 #include <net/mpls.h>

commit d4e7256007b0763614a41c9c0a5a943dc1095b22
Author: David Ahern <dsahern@gmail.com>
Date:   Sat May 27 16:19:32 2017 -0600

    net: mpls: Make nla_get_via in af_mpls.c
    
    nla_get_via is only used in af_mpls.c. Remove declaration from internal.h
    and move up in af_mpls.c before first use. Code move only; no
    functional change intended.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index a015a6a1143b..cf65aec2e551 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -204,8 +204,6 @@ int nla_put_labels(struct sk_buff *skb, int attrtype,  u8 labels,
 		   const u32 label[]);
 int nla_get_labels(const struct nlattr *nla, u8 max_labels, u8 *labels,
 		   u32 label[], struct netlink_ext_ack *extack);
-int nla_get_via(const struct nlattr *nla, u8 *via_alen, u8 *via_table,
-		u8 via[], struct netlink_ext_ack *extack);
 bool mpls_output_possible(const struct net_device *dev);
 unsigned int mpls_dev_mtu(const struct net_device *dev);
 bool mpls_pkt_too_big(const struct sk_buff *skb, unsigned int mtu);

commit 074350e2ebcab9cf62528984a617cc0a05b24fff
Author: David Ahern <dsahern@gmail.com>
Date:   Sat May 27 16:19:31 2017 -0600

    net: mpls: Add extack messages for route add and delete failures
    
    Add error messages for failures in adding and deleting mpls routes.
    This covers most of the annoying EINVAL errors.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index e59f299ceb3f..a015a6a1143b 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -205,7 +205,7 @@ int nla_put_labels(struct sk_buff *skb, int attrtype,  u8 labels,
 int nla_get_labels(const struct nlattr *nla, u8 max_labels, u8 *labels,
 		   u32 label[], struct netlink_ext_ack *extack);
 int nla_get_via(const struct nlattr *nla, u8 *via_alen, u8 *via_table,
-		u8 via[]);
+		u8 via[], struct netlink_ext_ack *extack);
 bool mpls_output_possible(const struct net_device *dev);
 unsigned int mpls_dev_mtu(const struct net_device *dev);
 bool mpls_pkt_too_big(const struct sk_buff *skb, unsigned int mtu);

commit a1f10abe12b6d70f8b02dedccb48c9d234a57b67
Author: David Ahern <dsahern@gmail.com>
Date:   Sat May 27 16:19:29 2017 -0600

    net: Fill in extack for mpls lwt encap
    
    Fill in extack for errors in build_state for mpls lwt encap including
    passing extack to nla_get_labels and adding error messages for failures
    in it.
    
    Signed-off-by: David Ahern <dsahern@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 4db6a5971322..e59f299ceb3f 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -203,7 +203,7 @@ static inline struct mpls_dev *mpls_dev_get(const struct net_device *dev)
 int nla_put_labels(struct sk_buff *skb, int attrtype,  u8 labels,
 		   const u32 label[]);
 int nla_get_labels(const struct nlattr *nla, u8 max_labels, u8 *labels,
-		   u32 label[]);
+		   u32 label[], struct netlink_ext_ack *extack);
 int nla_get_via(const struct nlattr *nla, u8 *via_alen, u8 *via_table,
 		u8 via[]);
 bool mpls_output_possible(const struct net_device *dev);

commit 1511009cd68015c2e04135bfefa4bf5020baa8d9
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Fri Mar 31 07:14:04 2017 -0700

    net: mpls: Increase max number of labels for lwt encap
    
    Alow users to push down more labels per MPLS encap. Similar to LSR case,
    move label array to the end of mpls_iptunnel_encap and allocate based on
    the number of labels for the route.
    
    For consistency with the LSR case, re-use the same maximum number of
    labels.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index c5d2f5bc37ec..4db6a5971322 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -2,6 +2,11 @@
 #define MPLS_INTERNAL_H
 #include <net/mpls.h>
 
+/* put a reasonable limit on the number of labels
+ * we will accept from userspace
+ */
+#define MAX_NEW_LABELS 30
+
 struct mpls_entry_decoded {
 	u32 label;
 	u8 ttl;

commit a4ac8c986d3f72ccbaf6d6782511fb645e568306
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Fri Mar 31 07:14:03 2017 -0700

    net: mpls: bump maximum number of labels
    
    Allow users to push down more labels per MPLS route. With the previous
    patches, no memory allocations are based on MAX_NEW_LABELS; the limit
    is only used to keep userspace in check.
    
    At this point MAX_NEW_LABELS is only used for mpls_route_config (copying
    route data from userspace) and processing nexthops looking for the max
    number of labels across the route spec.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index cc324c022049..c5d2f5bc37ec 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -197,7 +197,7 @@ static inline struct mpls_dev *mpls_dev_get(const struct net_device *dev)
 
 int nla_put_labels(struct sk_buff *skb, int attrtype,  u8 labels,
 		   const u32 label[]);
-int nla_get_labels(const struct nlattr *nla, u32 max_labels, u8 *labels,
+int nla_get_labels(const struct nlattr *nla, u8 max_labels, u8 *labels,
 		   u32 label[]);
 int nla_get_via(const struct nlattr *nla, u8 *via_alen, u8 *via_table,
 		u8 via[]);

commit 59b209667a3bef240ca5da111ce1931f29fa179f
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Fri Mar 31 07:14:01 2017 -0700

    net: mpls: change mpls_route layout
    
    Move labels to the end of mpls_nh as a 0-sized array and within mpls_route
    move the via for a nexthop after the mpls_nh. The new layout becomes:
    
       +----------------------+
       | mpls_route           |
       +----------------------+
       | mpls_nh 0            |
       +----------------------+
       | alignment padding    |   4 bytes for odd number of labels; 0 for even
       +----------------------+
       | via[rt_max_alen] 0   |
       +----------------------+
       | alignment padding    |   via's aligned on sizeof(unsigned long)
       +----------------------+
       | ...                  |
       +----------------------+
       | mpls_nh n-1          |
       +----------------------+
       | via[rt_max_alen] n-1 |
       +----------------------+
    
    Memory allocated for nexthop + via is constant across all nexthops and
    their via. It is based on the maximum number of labels across all nexthops
    and the maximum via length. The size is saved in the mpls_route as
    rt_nh_size. Accessing a nexthop becomes rt->rt_nh + index * rt->rt_nh_size.
    
    The offset of the via address from a nexthop is saved as rt_via_offset
    so that given an mpls_nh pointer the via for that hop is simply
    nh + rt->rt_via_offset.
    
    With prior code, memory allocated per mpls_route with 1 nexthop:
         via is an ethernet address - 64 bytes
         via is an ipv4 address     - 64
         via is an ipv6 address     - 72
    
    With this patch set, memory allocated per mpls_route with 1 nexthop and
    1 or 2 labels:
         via is an ethernet address - 56 bytes
         via is an ipv4 address     - 56
         via is an ipv6 address     - 64
    
    The 8-byte reduction is due to the previous patch; the change introduced
    by this patch has no impact on the size of allocations for 1 or 2 labels.
    
    Performance impact of this change was examined using network namespaces
    with veth pairs connecting namespaces. ns0 inserts the packet to the
    label-switched path using an lwt route with encap mpls. ns1 adds 1 or 2
    labels depending on test, ns2 (and ns3 for 2-label test) pops the label
    and forwards. ns3 (or ns4) for a 2-label is the destination. Similar
    series of namespaces used for 2-nexthop test.
    
    Intent is to measure changes to latency (overhead in manipulating the
    packet) in the forwarding path. Tests used netperf with UDP_RR.
    
    IPv4:                     current   patches
       1 label, 1 nexthop      29908     30115
       2 label, 1 nexthop      29071     29612
       1 label, 2 nexthop      29582     29776
       2 label, 2 nexthop      29086     29149
    
    IPv6:                     current   patches
       1 label, 1 nexthop      24502     24960
       2 label, 1 nexthop      24041     24407
       1 label, 2 nexthop      23795     23899
       2 label, 2 nexthop      23074     22959
    
    In short, the change has no effect to a modest increase in performance.
    This is expected since this patch does not really have an impact on routes
    with 1 or 2 labels (the current limit) and 1 or 2 nexthops.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 2ac97433c3b7..cc324c022049 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -64,7 +64,6 @@ struct mpls_dev {
 struct sk_buff;
 
 #define LABEL_NOT_SPECIFIED (1 << 20)
-#define MAX_NEW_LABELS 2
 
 /* This maximum ha length copied from the definition of struct neighbour */
 #define VIA_ALEN_ALIGN sizeof(unsigned long)
@@ -88,12 +87,26 @@ struct mpls_nh { /* next hop label forwarding entry */
 	 * modified handling netdev events with rtnl lock held
 	 */
 	unsigned int		nh_flags;
-	u32			nh_label[MAX_NEW_LABELS];
 	u8			nh_labels;
 	u8			nh_via_alen;
 	u8			nh_via_table;
+	u8			nh_reserved1;
+
+	u32			nh_label[0];
 };
 
+/* offset of via from beginning of mpls_nh */
+#define MPLS_NH_VIA_OFF(num_labels) \
+		ALIGN(sizeof(struct mpls_nh) + (num_labels) * sizeof(u32), \
+		      VIA_ALEN_ALIGN)
+
+/* all nexthops within a route have the same size based on the
+ * max number of labels and max via length across all nexthops
+ */
+#define MPLS_NH_SIZE(num_labels, max_via_alen)		\
+		(MPLS_NH_VIA_OFF((num_labels)) +	\
+		ALIGN((max_via_alen), VIA_ALEN_ALIGN))
+
 enum mpls_ttl_propagation {
 	MPLS_TTL_PROP_DEFAULT,
 	MPLS_TTL_PROP_ENABLED,
@@ -108,16 +121,16 @@ enum mpls_ttl_propagation {
  * +----------------------+
  * | mpls_nh 0            |
  * +----------------------+
- * | ...                  |
- * +----------------------+
- * | mpls_nh n-1          |
- * +----------------------+
- * | alignment padding    |
+ * | alignment padding    |   4 bytes for odd number of labels
  * +----------------------+
  * | via[rt_max_alen] 0   |
  * +----------------------+
+ * | alignment padding    |   via's aligned on sizeof(unsigned long)
+ * +----------------------+
  * | ...                  |
  * +----------------------+
+ * | mpls_nh n-1          |
+ * +----------------------+
  * | via[rt_max_alen] n-1 |
  * +----------------------+
  */
@@ -128,26 +141,28 @@ struct mpls_route { /* next hop label forwarding entry */
 	u8			rt_max_alen;
 	u8			rt_ttl_propagate;
 	u8			rt_nhn;
-
 	/* rt_nhn_alive is accessed under RCU in the packet path; it
 	 * is modified handling netdev events with rtnl lock held
 	 */
 	u8			rt_nhn_alive;
-	u16			rt_reserved1;
+	u8			rt_nh_size;
+	u8			rt_via_offset;
+	u8			rt_reserved1;
 	struct mpls_nh		rt_nh[0];
 };
 
 #define for_nexthops(rt) {						\
-	int nhsel; struct mpls_nh *nh;			\
-	for (nhsel = 0, nh = (rt)->rt_nh;				\
+	int nhsel; struct mpls_nh *nh;  u8 *__nh;			\
+	for (nhsel = 0, nh = (rt)->rt_nh, __nh = (u8 *)((rt)->rt_nh);	\
 	     nhsel < (rt)->rt_nhn;					\
-	     nh++, nhsel++)
+	     __nh += rt->rt_nh_size, nh = (struct mpls_nh *)__nh, nhsel++)
 
 #define change_nexthops(rt) {						\
-	int nhsel; struct mpls_nh *nh;				\
-	for (nhsel = 0,	nh = (struct mpls_nh *)((rt)->rt_nh);	\
+	int nhsel; struct mpls_nh *nh; u8 *__nh;			\
+	for (nhsel = 0, nh = (struct mpls_nh *)((rt)->rt_nh),		\
+			__nh = (u8 *)((rt)->rt_nh);			\
 	     nhsel < (rt)->rt_nhn;					\
-	     nh++, nhsel++)
+	     __nh += rt->rt_nh_size, nh = (struct mpls_nh *)__nh, nhsel++)
 
 #define endfor_nexthops(rt) }
 

commit 77ef013aadadd248843ad90022f36ba177b24e7f
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Fri Mar 31 07:14:00 2017 -0700

    net: mpls: Convert number of nexthops to u8
    
    Number of nexthops and number of alive nexthops are tracked using an
    unsigned int. A route should never have more than 255 nexthops so
    convert both to u8. Update all references and intermediate variables
    to consistently use u8 as well.
    
    Shrinks the size of mpls_route from 32 bytes to 24 bytes with a 2-byte
    hole before the nexthops.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 91419fe63464..2ac97433c3b7 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -127,12 +127,13 @@ struct mpls_route { /* next hop label forwarding entry */
 	u8			rt_payload_type;
 	u8			rt_max_alen;
 	u8			rt_ttl_propagate;
-	unsigned int		rt_nhn;
+	u8			rt_nhn;
 
 	/* rt_nhn_alive is accessed under RCU in the packet path; it
 	 * is modified handling netdev events with rtnl lock held
 	 */
-	unsigned int		rt_nhn_alive;
+	u8			rt_nhn_alive;
+	u16			rt_reserved1;
 	struct mpls_nh		rt_nh[0];
 };
 

commit 39eb8cd1758886072ceb93607827722a11592ba2
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Fri Mar 31 07:13:59 2017 -0700

    net: mpls: rt_nhn_alive and nh_flags should be accessed using READ_ONCE
    
    The number of alive nexthops for a route (rt->rt_nhn_alive) and the
    flags for a next hop (nh->nh_flags) are modified by netdev event
    handlers. The event handlers run with rtnl_lock held so updates are
    always done with the lock held. The packet path accesses the fields
    under the rcu lock. Since those fields can change at any moment in
    the packet path, both fields should be accessed using READ_ONCE. Updates
    to both fields should use WRITE_ONCE.
    
    Update mpls_select_multipath (packet path) and mpls_ifdown and mpls_ifup
    (event handlers) accordingly.
    
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 62928d8fabd1..91419fe63464 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -83,6 +83,10 @@ enum mpls_payload_type {
 
 struct mpls_nh { /* next hop label forwarding entry */
 	struct net_device __rcu *nh_dev;
+
+	/* nh_flags is accessed under RCU in the packet path; it is
+	 * modified handling netdev events with rtnl lock held
+	 */
 	unsigned int		nh_flags;
 	u32			nh_label[MAX_NEW_LABELS];
 	u8			nh_labels;
@@ -124,6 +128,10 @@ struct mpls_route { /* next hop label forwarding entry */
 	u8			rt_max_alen;
 	u8			rt_ttl_propagate;
 	unsigned int		rt_nhn;
+
+	/* rt_nhn_alive is accessed under RCU in the packet path; it
+	 * is modified handling netdev events with rtnl lock held
+	 */
 	unsigned int		rt_nhn_alive;
 	struct mpls_nh		rt_nh[0];
 };

commit 5b441ac8784c1e7f3c619f14da4c3f52e87348d5
Author: Robert Shearman <rshearma@brocade.com>
Date:   Fri Mar 10 20:43:24 2017 +0000

    mpls: allow TTL propagation to IP packets to be configured
    
    Provide the ability to control on a per-route basis whether the TTL
    value from an MPLS packet is propagated to an IPv4/IPv6 packet when
    the last label is popped as per the theoretical model in RFC 3443
    through a new route attribute, RTA_TTL_PROPAGATE which can be 0 to
    mean disable propagation and 1 to mean enable propagation.
    
    In order to provide the ability to change the behaviour for packets
    arriving with IPv4/IPv6 Explicit Null labels and to provide an easy
    way for a user to change the behaviour for all existing routes without
    having to reprogram them, a global knob is provided. This is done
    through the addition of a new per-namespace sysctl,
    "net.mpls.ip_ttl_propagate", which defaults to enabled. If the
    per-route attribute is set (either enabled or disabled) then it
    overrides the global configuration.
    
    Signed-off-by: Robert Shearman <rshearma@brocade.com>
    Acked-by: David Ahern <dsa@cumulusnetworks.com>
    Tested-by: David Ahern <dsa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 76360d8b9579..62928d8fabd1 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -90,6 +90,12 @@ struct mpls_nh { /* next hop label forwarding entry */
 	u8			nh_via_table;
 };
 
+enum mpls_ttl_propagation {
+	MPLS_TTL_PROP_DEFAULT,
+	MPLS_TTL_PROP_ENABLED,
+	MPLS_TTL_PROP_DISABLED,
+};
+
 /* The route, nexthops and vias are stored together in the same memory
  * block:
  *
@@ -116,6 +122,7 @@ struct mpls_route { /* next hop label forwarding entry */
 	u8			rt_protocol;
 	u8			rt_payload_type;
 	u8			rt_max_alen;
+	u8			rt_ttl_propagate;
 	unsigned int		rt_nhn;
 	unsigned int		rt_nhn_alive;
 	struct mpls_nh		rt_nh[0];

commit 24045a03b8796e3e1ddb370dfe4bc592a9f5f301
Author: David Ahern <dsa@cumulusnetworks.com>
Date:   Mon Feb 20 08:03:30 2017 -0800

    net: mpls: Add support for netconf
    
    Add netconf support to MPLS. Allows userpsace to learn and be notified
    of changes to 'input' enable setting per interface.
    
    Acked-by: Nicolas Dichtel <nicolas.dichtel@6wind.com>
    Signed-off-by: David Ahern <dsa@cumulusnetworks.com>
    Acked-by: Robert Shearman <rshearma@brocade.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index d97243034605..76360d8b9579 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -16,7 +16,7 @@ struct mpls_pcpu_stats {
 
 struct mpls_dev {
 	int				input_enabled;
-
+	struct net_device		*dev;
 	struct mpls_pcpu_stats __percpu	*stats;
 
 	struct ctl_table_header		*sysctl;

commit 27d691056bde4a6feca5e83fd92b787332c46302
Author: Robert Shearman <rshearma@brocade.com>
Date:   Mon Jan 16 14:16:37 2017 +0000

    mpls: Packet stats
    
    Having MPLS packet stats is useful for observing network operation and
    for diagnosing network problems. In the absence of anything better,
    RFC2863 and RFC3813 are used for guidance for which stats to expose
    and the semantics of them. In particular rx_noroutes maps to in
    unknown protos in RFC2863. The stats are exposed to userspace via
    AF_MPLS attributes embedded in the IFLA_STATS_AF_SPEC attribute of
    RTM_GETSTATS messages.
    
    All the introduced fields are 64-bit, even error ones, to ensure no
    overflow with long uptimes. Per-CPU counters are used to avoid
    cache-line contention on the commonly used fields. The other fields
    have also been made per-CPU for code to avoid performance problems in
    error conditions on the assumption that on some platforms the cost of
    atomic operations could be more expensive than sending the packet
    (which is what would be done in the success case). If that's not the
    case, we could instead not use per-CPU counters for these fields.
    
    Only unicast and non-fragment are exposed at the moment, but other
    counters can be exposed in the future either by adding to the end of
    struct mpls_link_stats or by additional netlink attributes in the
    AF_MPLS IFLA_STATS_AF_SPEC nested attribute.
    
    Signed-off-by: Robert Shearman <rshearma@brocade.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index bdfef6c3271a..d97243034605 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -9,13 +9,58 @@ struct mpls_entry_decoded {
 	u8 bos;
 };
 
+struct mpls_pcpu_stats {
+	struct mpls_link_stats	stats;
+	struct u64_stats_sync	syncp;
+};
+
 struct mpls_dev {
-	int			input_enabled;
+	int				input_enabled;
 
-	struct ctl_table_header *sysctl;
-	struct rcu_head		rcu;
+	struct mpls_pcpu_stats __percpu	*stats;
+
+	struct ctl_table_header		*sysctl;
+	struct rcu_head			rcu;
 };
 
+#if BITS_PER_LONG == 32
+
+#define MPLS_INC_STATS_LEN(mdev, len, pkts_field, bytes_field)		\
+	do {								\
+		__typeof__(*(mdev)->stats) *ptr =			\
+			raw_cpu_ptr((mdev)->stats);			\
+		local_bh_disable();					\
+		u64_stats_update_begin(&ptr->syncp);			\
+		ptr->stats.pkts_field++;				\
+		ptr->stats.bytes_field += (len);			\
+		u64_stats_update_end(&ptr->syncp);			\
+		local_bh_enable();					\
+	} while (0)
+
+#define MPLS_INC_STATS(mdev, field)					\
+	do {								\
+		__typeof__(*(mdev)->stats) *ptr =			\
+			raw_cpu_ptr((mdev)->stats);			\
+		local_bh_disable();					\
+		u64_stats_update_begin(&ptr->syncp);			\
+		ptr->stats.field++;					\
+		u64_stats_update_end(&ptr->syncp);			\
+		local_bh_enable();					\
+	} while (0)
+
+#else
+
+#define MPLS_INC_STATS_LEN(mdev, len, pkts_field, bytes_field)		\
+	do {								\
+		this_cpu_inc((mdev)->stats->stats.pkts_field);		\
+		this_cpu_add((mdev)->stats->stats.bytes_field, (len));	\
+	} while (0)
+
+#define MPLS_INC_STATS(mdev, field)			\
+	this_cpu_inc((mdev)->stats->stats.field)
+
+#endif
+
 struct sk_buff;
 
 #define LABEL_NOT_SPECIFIED (1 << 20)
@@ -114,6 +159,11 @@ static inline struct mpls_entry_decoded mpls_entry_decode(struct mpls_shim_hdr *
 	return result;
 }
 
+static inline struct mpls_dev *mpls_dev_get(const struct net_device *dev)
+{
+	return rcu_dereference_rtnl(dev->mpls_ptr);
+}
+
 int nla_put_labels(struct sk_buff *skb, int attrtype,  u8 labels,
 		   const u32 label[]);
 int nla_get_labels(const struct nlattr *nla, u32 max_labels, u8 *labels,
@@ -123,5 +173,7 @@ int nla_get_via(const struct nlattr *nla, u8 *via_alen, u8 *via_table,
 bool mpls_output_possible(const struct net_device *dev);
 unsigned int mpls_dev_mtu(const struct net_device *dev);
 bool mpls_pkt_too_big(const struct sk_buff *skb, unsigned int mtu);
+void mpls_stats_inc_outucastpkts(struct net_device *dev,
+				 const struct sk_buff *skb);
 
 #endif /* MPLS_INTERNAL_H */

commit 9095e10edd28e1e4a10ba5ca61fb54d9f74f8968
Author: Jiri Benc <jbenc@redhat.com>
Date:   Fri Sep 30 19:08:06 2016 +0200

    mpls: move mpls_hdr to a common location
    
    This will be also used by openvswitch.
    
    Signed-off-by: Jiri Benc <jbenc@redhat.com>
    Acked-by: David Ahern <dsa@cumulusnetworks.com>
    Acked-by: Pravin B Shelar <pshelar@ovn.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 732a5c17e986..bdfef6c3271a 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -1,9 +1,6 @@
 #ifndef MPLS_INTERNAL_H
 #define MPLS_INTERNAL_H
-
-struct mpls_shim_hdr {
-	__be32 label_stack_entry;
-};
+#include <net/mpls.h>
 
 struct mpls_entry_decoded {
 	u32 label;
@@ -93,11 +90,6 @@ struct mpls_route { /* next hop label forwarding entry */
 
 #define endfor_nexthops(rt) }
 
-static inline struct mpls_shim_hdr *mpls_hdr(const struct sk_buff *skb)
-{
-	return (struct mpls_shim_hdr *)skb_network_header(skb);
-}
-
 static inline struct mpls_shim_hdr mpls_entry_encode(u32 label, unsigned ttl, unsigned tc, bool bos)
 {
 	struct mpls_shim_hdr result;

commit c89359a42e2a49656451569c382eed63e781153c
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Tue Dec 1 22:18:11 2015 -0800

    mpls: support for dead routes
    
    Adds support for RTNH_F_DEAD and RTNH_F_LINKDOWN flags on mpls
    routes due to link events. Also adds code to ignore dead
    routes during route selection.
    
    Unlike ip routes, mpls routes are not deleted when the route goes
    dead. This is current mpls behaviour and this patch does not change
    that. With this patch however, routes will be marked dead.
    dead routes are not notified to userspace (this is consistent with ipv4
    routes).
    
    dead routes:
    -----------
    $ip -f mpls route show
    100
        nexthop as to 200 via inet 10.1.1.2  dev swp1
        nexthop as to 700 via inet 10.1.1.6  dev swp2
    
    $ip link set dev swp1 down
    
    $ip link show dev swp1
    4: swp1: <BROADCAST,MULTICAST> mtu 1500 qdisc pfifo_fast state DOWN mode
    DEFAULT group default qlen 1000
        link/ether 00:02:00:00:00:01 brd ff:ff:ff:ff:ff:ff
    
    $ip -f mpls route show
    100
        nexthop as to 200 via inet 10.1.1.2  dev swp1 dead linkdown
        nexthop as to 700 via inet 10.1.1.6  dev swp2
    
    linkdown routes:
    ----------------
    $ip -f mpls route show
    100
        nexthop as to 200 via inet 10.1.1.2  dev swp1
        nexthop as to 700 via inet 10.1.1.6  dev swp2
    
    $ip link show dev swp1
    4: swp1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast
    state UP mode DEFAULT group default qlen 1000
        link/ether 00:02:00:00:00:01 brd ff:ff:ff:ff:ff:ff
    
    /* carrier goes down */
    $ip link show dev swp1
    4: swp1: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast
    state DOWN mode DEFAULT group default qlen 1000
        link/ether 00:02:00:00:00:01 brd ff:ff:ff:ff:ff:ff
    
    $ip -f mpls route show
    100
        nexthop as to 200 via inet 10.1.1.2  dev swp1 linkdown
        nexthop as to 700 via inet 10.1.1.6  dev swp2
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Acked-by: Robert Shearman <rshearma@brocade.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index bde52ce88c94..732a5c17e986 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -41,6 +41,7 @@ enum mpls_payload_type {
 
 struct mpls_nh { /* next hop label forwarding entry */
 	struct net_device __rcu *nh_dev;
+	unsigned int		nh_flags;
 	u32			nh_label[MAX_NEW_LABELS];
 	u8			nh_labels;
 	u8			nh_via_alen;
@@ -74,6 +75,7 @@ struct mpls_route { /* next hop label forwarding entry */
 	u8			rt_payload_type;
 	u8			rt_max_alen;
 	unsigned int		rt_nhn;
+	unsigned int		rt_nhn_alive;
 	struct mpls_nh		rt_nh[0];
 };
 

commit cf4b24f0024fc2e3fbc653a659356d224b5b9172
Author: Robert Shearman <rshearma@brocade.com>
Date:   Tue Oct 27 00:37:36 2015 +0000

    mpls: reduce memory usage of routes
    
    Nexthops for MPLS routes have a via address field sized for the
    largest via address that is expected, which is 32 bytes. This means
    that in the most common case of having ipv4 via addresses, 28 bytes of
    memory more than required are used per nexthop. In the other common
    case of an ipv6 nexthop then 16 bytes more than required are
    used. With large numbers of MPLS routes this extra memory usage could
    start to become significant.
    
    To avoid allocating memory for a maximum length via address when not
    all of it is required and to allow for ease of iterating over
    nexthops, then the via addresses are changed to be stored in the same
    memory block as the route and nexthops, but in an array after the end
    of the array of nexthops. New accessors are provided to retrieve a
    pointer to the via address.
    
    To allow for O(1) access without having to store a pointer or offset
    per nh, the via address for each nexthop is sized according to the
    maximum via address for any nexthop in the route, which is stored in a
    new route field, rt_max_alen, but this is in an existing hole in
    struct mpls_route so it doesn't increase the size of the
    structure. Each via address is ensured to be aligned to VIA_ALEN_ALIGN
    to account for architectures that don't allow unaligned accesses.
    
    Signed-off-by: Robert Shearman <rshearma@brocade.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index d7757be39877..bde52ce88c94 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -25,7 +25,8 @@ struct sk_buff;
 #define MAX_NEW_LABELS 2
 
 /* This maximum ha length copied from the definition of struct neighbour */
-#define MAX_VIA_ALEN (ALIGN(MAX_ADDR_LEN, sizeof(unsigned long)))
+#define VIA_ALEN_ALIGN sizeof(unsigned long)
+#define MAX_VIA_ALEN (ALIGN(MAX_ADDR_LEN, VIA_ALEN_ALIGN))
 
 enum mpls_payload_type {
 	MPT_UNSPEC, /* IPv4 or IPv6 */
@@ -44,14 +45,35 @@ struct mpls_nh { /* next hop label forwarding entry */
 	u8			nh_labels;
 	u8			nh_via_alen;
 	u8			nh_via_table;
-	u8			nh_via[MAX_VIA_ALEN];
 };
 
+/* The route, nexthops and vias are stored together in the same memory
+ * block:
+ *
+ * +----------------------+
+ * | mpls_route           |
+ * +----------------------+
+ * | mpls_nh 0            |
+ * +----------------------+
+ * | ...                  |
+ * +----------------------+
+ * | mpls_nh n-1          |
+ * +----------------------+
+ * | alignment padding    |
+ * +----------------------+
+ * | via[rt_max_alen] 0   |
+ * +----------------------+
+ * | ...                  |
+ * +----------------------+
+ * | via[rt_max_alen] n-1 |
+ * +----------------------+
+ */
 struct mpls_route { /* next hop label forwarding entry */
 	struct rcu_head		rt_rcu;
 	u8			rt_protocol;
 	u8			rt_payload_type;
-	int			rt_nhn;
+	u8			rt_max_alen;
+	unsigned int		rt_nhn;
 	struct mpls_nh		rt_nh[0];
 };
 

commit f8efb73c97e2fa0abbe2e07c5c5df07800312643
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Fri Oct 23 06:03:27 2015 -0700

    mpls: multipath route support
    
    This patch adds support for MPLS multipath routes.
    
    Includes following changes to support multipath:
    - splits struct mpls_route into 'struct mpls_route + struct mpls_nh'
    
    - 'struct mpls_nh' represents a mpls nexthop label forwarding entry
    
    - moves mpls route and nexthop structures into internal.h
    
    - A mpls_route can point to multiple mpls_nh structs
    
    - the nexthops are maintained as a array (similar to ipv4 fib)
    
    - In the process of restructuring, this patch also consistently changes
      all labels to u8
    
    - Adds support to parse/fill RTA_MULTIPATH netlink attribute for
    multipath routes similar to ipv4/v6 fib
    
    - In this patch, the multipath route nexthop selection algorithm
    simply returns the first nexthop. It is replaced by a
    hash based algorithm from Robert Shearman in the next patch
    
    - mpls_route_update cleanup: remove 'dev' handling in mpls_route_update.
    mpls_route_update though implemented to update based on dev, it was
    never used that way. And the dev handling gets tricky with multiple
    nexthops. Cannot match against any single nexthops dev. So, this patch
    removes the unused 'dev' handling in mpls_route_update.
    
    - dead route/path handling will be implemented in a subsequent patch
    
    Example:
    
    $ip -f mpls route add 100 nexthop as 200 via inet 10.1.1.2 dev swp1 \
                    nexthop as 700 via inet 10.1.1.6 dev swp2 \
                    nexthop as 800 via inet 40.1.1.2 dev swp3
    
    $ip  -f mpls route show
    100
            nexthop as to 200 via inet 10.1.1.2  dev swp1
            nexthop as to 700 via inet 10.1.1.6  dev swp2
            nexthop as to 800 via inet 40.1.1.2  dev swp3
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Acked-by: Robert Shearman <rshearma@brocade.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 2681a4ba6c37..d7757be39877 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -21,6 +21,54 @@ struct mpls_dev {
 
 struct sk_buff;
 
+#define LABEL_NOT_SPECIFIED (1 << 20)
+#define MAX_NEW_LABELS 2
+
+/* This maximum ha length copied from the definition of struct neighbour */
+#define MAX_VIA_ALEN (ALIGN(MAX_ADDR_LEN, sizeof(unsigned long)))
+
+enum mpls_payload_type {
+	MPT_UNSPEC, /* IPv4 or IPv6 */
+	MPT_IPV4 = 4,
+	MPT_IPV6 = 6,
+
+	/* Other types not implemented:
+	 *  - Pseudo-wire with or without control word (RFC4385)
+	 *  - GAL (RFC5586)
+	 */
+};
+
+struct mpls_nh { /* next hop label forwarding entry */
+	struct net_device __rcu *nh_dev;
+	u32			nh_label[MAX_NEW_LABELS];
+	u8			nh_labels;
+	u8			nh_via_alen;
+	u8			nh_via_table;
+	u8			nh_via[MAX_VIA_ALEN];
+};
+
+struct mpls_route { /* next hop label forwarding entry */
+	struct rcu_head		rt_rcu;
+	u8			rt_protocol;
+	u8			rt_payload_type;
+	int			rt_nhn;
+	struct mpls_nh		rt_nh[0];
+};
+
+#define for_nexthops(rt) {						\
+	int nhsel; struct mpls_nh *nh;			\
+	for (nhsel = 0, nh = (rt)->rt_nh;				\
+	     nhsel < (rt)->rt_nhn;					\
+	     nh++, nhsel++)
+
+#define change_nexthops(rt) {						\
+	int nhsel; struct mpls_nh *nh;				\
+	for (nhsel = 0,	nh = (struct mpls_nh *)((rt)->rt_nh);	\
+	     nhsel < (rt)->rt_nhn;					\
+	     nh++, nhsel++)
+
+#define endfor_nexthops(rt) }
+
 static inline struct mpls_shim_hdr *mpls_hdr(const struct sk_buff *skb)
 {
 	return (struct mpls_shim_hdr *)skb_network_header(skb);
@@ -52,8 +100,10 @@ static inline struct mpls_entry_decoded mpls_entry_decode(struct mpls_shim_hdr *
 
 int nla_put_labels(struct sk_buff *skb, int attrtype,  u8 labels,
 		   const u32 label[]);
-int nla_get_labels(const struct nlattr *nla, u32 max_labels, u32 *labels,
+int nla_get_labels(const struct nlattr *nla, u32 max_labels, u8 *labels,
 		   u32 label[]);
+int nla_get_via(const struct nlattr *nla, u8 *via_alen, u8 *via_table,
+		u8 via[]);
 bool mpls_output_possible(const struct net_device *dev);
 unsigned int mpls_dev_mtu(const struct net_device *dev);
 bool mpls_pkt_too_big(const struct sk_buff *skb, unsigned int mtu);

commit face0188e31b3cfc598d8dc3470e28e00fb3b07c
Author: Roopa Prabhu <roopa@cumulusnetworks.com>
Date:   Tue Jul 21 10:43:52 2015 +0200

    mpls: export mpls functions for use by mpls iptunnels
    
    Signed-off-by: Roopa Prabhu <roopa@cumulusnetworks.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 8cabeb5a1cb9..2681a4ba6c37 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -50,7 +50,12 @@ static inline struct mpls_entry_decoded mpls_entry_decode(struct mpls_shim_hdr *
 	return result;
 }
 
-int nla_put_labels(struct sk_buff *skb, int attrtype,  u8 labels, const u32 label[]);
-int nla_get_labels(const struct nlattr *nla, u32 max_labels, u32 *labels, u32 label[]);
+int nla_put_labels(struct sk_buff *skb, int attrtype,  u8 labels,
+		   const u32 label[]);
+int nla_get_labels(const struct nlattr *nla, u32 max_labels, u32 *labels,
+		   u32 label[]);
+bool mpls_output_possible(const struct net_device *dev);
+unsigned int mpls_dev_mtu(const struct net_device *dev);
+bool mpls_pkt_too_big(const struct sk_buff *skb, unsigned int mtu);
 
 #endif /* MPLS_INTERNAL_H */

commit 25cc8f0763c972911b1a65099cd10d9f8a45a7b0
Author: Robert Shearman <rshearma@brocade.com>
Date:   Fri Jun 5 18:54:45 2015 +0100

    mpls: fix possible use after free of device
    
    The mpls device is used in an RCU read context without a lock being
    held. As the memory is freed without waiting for the RCU grace period
    to elapse, the freed memory could still be in use.
    
    Address this by using kfree_rcu to free the memory for the mpls device
    after the RCU grace period has elapsed.
    
    Fixes: 03c57747a702 ("mpls: Per-device MPLS state")
    Signed-off-by: Robert Shearman <rshearma@brocade.com>
    Acked-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index b064c345042c..8cabeb5a1cb9 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -16,6 +16,7 @@ struct mpls_dev {
 	int			input_enabled;
 
 	struct ctl_table_header *sysctl;
+	struct rcu_head		rcu;
 };
 
 struct sk_buff;

commit c967a0873a7836c7a77bf611f1c7d3f47c554c45
Author: Tom Herbert <tom@herbertland.com>
Date:   Tue May 5 09:06:30 2015 -0700

    mpls: Move reserved label definitions
    
    Move to include/uapi/linux/mpls.h to be externally visibile.
    
    Signed-off-by: Tom Herbert <tom@herbertland.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 693877d69606..b064c345042c 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -1,16 +1,6 @@
 #ifndef MPLS_INTERNAL_H
 #define MPLS_INTERNAL_H
 
-#define LABEL_IPV4_EXPLICIT_NULL	0 /* RFC3032 */
-#define LABEL_ROUTER_ALERT_LABEL	1 /* RFC3032 */
-#define LABEL_IPV6_EXPLICIT_NULL	2 /* RFC3032 */
-#define LABEL_IMPLICIT_NULL		3 /* RFC3032 */
-#define LABEL_ENTROPY_INDICATOR		7 /* RFC6790 */
-#define LABEL_GAL			13 /* RFC5586 */
-#define LABEL_OAM_ALERT			14 /* RFC3429 */
-#define LABEL_EXTENSION			15 /* RFC7274 */
-
-
 struct mpls_shim_hdr {
 	__be32 label_stack_entry;
 };

commit 37bde79979c3862c79294c62ddcef7efc477e4bf
Author: Robert Shearman <rshearma@brocade.com>
Date:   Wed Apr 22 11:14:38 2015 +0100

    mpls: Per-device enabling of packet input
    
    An MPLS network is a single trust domain where the edges must be in
    control of what labels make their way into the core. The simplest way
    of ensuring this is for the edge device to always impose the labels,
    and not allow forward labeled traffic from untrusted neighbours. This
    is achieved by allowing a per-device configuration of whether MPLS
    traffic input from that interface should be processed or not.
    
    To be secure by default, the default state is changed to MPLS being
    disabled on all interfaces unless explicitly enabled and no global
    option is provided to change the default. Whilst this differs from
    other protocols (e.g. IPv6), network operators are used to explicitly
    enabling MPLS forwarding on interfaces, and with the number of links
    to the MPLS core typically fairly low this doesn't present too much of
    a burden on operators.
    
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Robert Shearman <rshearma@brocade.com>
    Reviewed-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index 8090cb3099b4..693877d69606 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -23,6 +23,9 @@ struct mpls_entry_decoded {
 };
 
 struct mpls_dev {
+	int			input_enabled;
+
+	struct ctl_table_header *sysctl;
 };
 
 struct sk_buff;

commit 03c57747a7020a28a200e7e920fb48ecdc9b0fb8
Author: Robert Shearman <rshearma@brocade.com>
Date:   Wed Apr 22 11:14:37 2015 +0100

    mpls: Per-device MPLS state
    
    Add per-device MPLS state to supported interfaces. Use the presence of
    this state in mpls_route_add to determine that this is a supported
    interface.
    
    Use the presence of mpls_dev to drop packets that arrived on an
    unsupported interface - previously they were allowed through.
    
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: Robert Shearman <rshearma@brocade.com>
    Reviewed-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index fb6de92052c4..8090cb3099b4 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -22,6 +22,9 @@ struct mpls_entry_decoded {
 	u8 bos;
 };
 
+struct mpls_dev {
+};
+
 struct sk_buff;
 
 static inline struct mpls_shim_hdr *mpls_hdr(const struct sk_buff *skb)

commit 966bae3349da22bb6286f6f3874c279177b8633f
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Mar 3 19:13:19 2015 -0600

    mpls: Functions for reading and wrinting mpls labels over netlink
    
    Reading and writing addresses in network byte order in netlink is
    traditional and I see no reason to change that.  MPLS is interesting
    as effectively it has variabely length addresses (the MPLS label
    stack).  To represent these variable length addresses in netlink
    I use a valid MPLS label stack (complete with stop bit).
    
    This achieves two things: a well defined existing format is used,
    and the data can be interpreted without looking at it's length.
    
    Not needed to look at the length to decode the variable length
    network representation allows existing userspace functions
    such as inet_ntop to be used without needed to change their
    prototype.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
index c2944cb84d48..fb6de92052c4 100644
--- a/net/mpls/internal.h
+++ b/net/mpls/internal.h
@@ -53,4 +53,7 @@ static inline struct mpls_entry_decoded mpls_entry_decode(struct mpls_shim_hdr *
 	return result;
 }
 
+int nla_put_labels(struct sk_buff *skb, int attrtype,  u8 labels, const u32 label[]);
+int nla_get_labels(const struct nlattr *nla, u32 max_labels, u32 *labels, u32 label[]);
+
 #endif /* MPLS_INTERNAL_H */

commit 0189197f441602acdca3f97750d392a895b778fd
Author: Eric W. Biederman <ebiederm@xmission.com>
Date:   Tue Mar 3 19:10:47 2015 -0600

    mpls: Basic routing support
    
    This change adds a new Kconfig option MPLS_ROUTING.
    
    The core of this change is the code to look at an mpls packet received
    from another machine.  Look that packet up in a routing table and
    forward the packet on.
    
    Support of MPLS over ATM is not considered or attempted here.  This
    implemntation follows RFC3032 and implements the MPLS shim header that
    can pass over essentially any network.
    
    What RFC3021 refers to as the as the Incoming Label Map (ILM) I call
    net->mpls.platform_label[].  What RFC3031 refers to as the Next Label
    Hop Forwarding Entry (NHLFE) I call mpls_route.  Though calling it the
    label fordwarding information base (lfib) might also be valid.
    
    Further the implemntation forwards packets as described in RFC3032.
    There is no need and given the original motivation for MPLS a strong
    discincentive to have a flexible label forwarding path.  In essence
    the logic is the topmost label is read, looked up, removed, and
    replaced by 0 or more new lables and the sent out the specified
    interface to it's next hop.
    
    Quite a few optional features are not implemented here.  Among them
    are generation of ICMP errors when the TTL is exceeded or the packet
    is larger than the next hop MTU (those conditions are detected and the
    packets are dropped instead of generating an icmp error).  The traffic
    class field is always set to 0.  The implementation focuses on IP over
    MPLS and does not handle egress of other kinds of protocols.
    
    Instead of implementing coordination with the neighbour table and
    sorting out how to input next hops in a different address family (for
    which there is value).  I was lazy and implemented a next hop mac
    address instead.  The code is simpler and there are flavor of MPLS
    such as MPLS-TP where neither an IPv4 nor an IPv6 next hop is
    appropriate so a next hop by mac address would need to be implemented
    at some point.
    
    Two new definitions AF_MPLS and PF_MPLS are exposed to userspace.
    
    Decoding the mpls header must be done by first byeswapping a 32bit bit
    endian word into the local cpu endian and then bit shifting to extract
    the pieces.  There is no C bit-field that can represent a wire format
    mpls header on a little endian machine as the low bits of the 20bit
    label wind up in the wrong half of third byte.  Therefore internally
    everything is deal with in cpu native byte order except when writing
    to and reading from a packet.
    
    For management simplicity if a label is configured to forward out
    an interface that is down the packet is dropped early.  Similarly
    if an network interface is removed rt_dev is updated to NULL
    (so no reference is preserved) and any packets for that label
    are dropped.  Keeping the label entries in the kernel allows
    the kernel label table to function as the definitive source
    of which labels are allocated and which are not.
    
    Signed-off-by: "Eric W. Biederman" <ebiederm@xmission.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mpls/internal.h b/net/mpls/internal.h
new file mode 100644
index 000000000000..c2944cb84d48
--- /dev/null
+++ b/net/mpls/internal.h
@@ -0,0 +1,56 @@
+#ifndef MPLS_INTERNAL_H
+#define MPLS_INTERNAL_H
+
+#define LABEL_IPV4_EXPLICIT_NULL	0 /* RFC3032 */
+#define LABEL_ROUTER_ALERT_LABEL	1 /* RFC3032 */
+#define LABEL_IPV6_EXPLICIT_NULL	2 /* RFC3032 */
+#define LABEL_IMPLICIT_NULL		3 /* RFC3032 */
+#define LABEL_ENTROPY_INDICATOR		7 /* RFC6790 */
+#define LABEL_GAL			13 /* RFC5586 */
+#define LABEL_OAM_ALERT			14 /* RFC3429 */
+#define LABEL_EXTENSION			15 /* RFC7274 */
+
+
+struct mpls_shim_hdr {
+	__be32 label_stack_entry;
+};
+
+struct mpls_entry_decoded {
+	u32 label;
+	u8 ttl;
+	u8 tc;
+	u8 bos;
+};
+
+struct sk_buff;
+
+static inline struct mpls_shim_hdr *mpls_hdr(const struct sk_buff *skb)
+{
+	return (struct mpls_shim_hdr *)skb_network_header(skb);
+}
+
+static inline struct mpls_shim_hdr mpls_entry_encode(u32 label, unsigned ttl, unsigned tc, bool bos)
+{
+	struct mpls_shim_hdr result;
+	result.label_stack_entry =
+		cpu_to_be32((label << MPLS_LS_LABEL_SHIFT) |
+			    (tc << MPLS_LS_TC_SHIFT) |
+			    (bos ? (1 << MPLS_LS_S_SHIFT) : 0) |
+			    (ttl << MPLS_LS_TTL_SHIFT));
+	return result;
+}
+
+static inline struct mpls_entry_decoded mpls_entry_decode(struct mpls_shim_hdr *hdr)
+{
+	struct mpls_entry_decoded result;
+	unsigned entry = be32_to_cpu(hdr->label_stack_entry);
+
+	result.label = (entry & MPLS_LS_LABEL_MASK) >> MPLS_LS_LABEL_SHIFT;
+	result.ttl = (entry & MPLS_LS_TTL_MASK) >> MPLS_LS_TTL_SHIFT;
+	result.tc =  (entry & MPLS_LS_TC_MASK) >> MPLS_LS_TC_SHIFT;
+	result.bos = (entry & MPLS_LS_S_MASK) >> MPLS_LS_S_SHIFT;
+
+	return result;
+}
+
+#endif /* MPLS_INTERNAL_H */
