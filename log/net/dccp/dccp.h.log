commit df346f1aac6cef551b69d788b022a942270dc17b
Author: YueHaibing <yuehaibing@huawei.com>
Date:   Fri Apr 24 21:13:34 2020 +0800

    dccp: remove unused inline function dccp_set_seqno
    
    There's no callers in-tree since commit 792b48780e8b ("dccp: Implement
    both feature-local and feature-remote Sequence Window feature")
    
    Signed-off-by: YueHaibing <yuehaibing@huawei.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 9c3b27c257bb..7dce4f6c7025 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -108,11 +108,6 @@ extern int  sysctl_dccp_sync_ratelimit;
 #define ADD48(a, b)	 (((a) + (b)) & UINT48_MAX)
 #define SUB48(a, b)	 ADD48((a), COMPLEMENT48(b))
 
-static inline void dccp_set_seqno(u64 *seqno, u64 value)
-{
-	*seqno = value & UINT48_MAX;
-}
-
 static inline void dccp_inc_seqno(u64 *seqno)
 {
 	*seqno = ADD48(*seqno, 1);

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index f91e3816806b..9c3b27c257bb 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 #ifndef _DCCP_H
 #define _DCCP_H
 /*
@@ -6,10 +7,6 @@
  *  An implementation of the DCCP protocol
  *  Copyright (c) 2005 Arnaldo Carvalho de Melo <acme@conectiva.com.br>
  *  Copyright (c) 2005-6 Ian McDonald <ian.mcdonald@jandi.co.nz>
- *
- *	This program is free software; you can redistribute it and/or modify it
- *	under the terms of the GNU General Public License version 2 as
- *	published by the Free Software Foundation.
  */
 
 #include <linux/dccp.h>

commit a11e1d432b51f63ba698d044441284a661f01144
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 28 09:43:44 2018 -0700

    Revert changes to convert to ->poll_mask() and aio IOCB_CMD_POLL
    
    The poll() changes were not well thought out, and completely
    unexplained.  They also caused a huge performance regression, because
    "->poll()" was no longer a trivial file operation that just called down
    to the underlying file operations, but instead did at least two indirect
    calls.
    
    Indirect calls are sadly slow now with the Spectre mitigation, but the
    performance problem could at least be largely mitigated by changing the
    "->get_poll_head()" operation to just have a per-file-descriptor pointer
    to the poll head instead.  That gets rid of one of the new indirections.
    
    But that doesn't fix the new complexity that is completely unwarranted
    for the regular case.  The (undocumented) reason for the poll() changes
    was some alleged AIO poll race fixing, but we don't make the common case
    slower and more complex for some uncommon special case, so this all
    really needs way more explanations and most likely a fundamental
    redesign.
    
    [ This revert is a revert of about 30 different commits, not reverted
      individually because that would just be unnecessarily messy  - Linus ]
    
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 0ea2ee56ac1b..f91e3816806b 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -316,7 +316,8 @@ int dccp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,
 		 int flags, int *addr_len);
 void dccp_shutdown(struct sock *sk, int how);
 int inet_dccp_listen(struct socket *sock, int backlog);
-__poll_t dccp_poll_mask(struct socket *sock, __poll_t events);
+__poll_t dccp_poll(struct file *file, struct socket *sock,
+		       poll_table *wait);
 int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
 void dccp_req_err(struct sock *sk, u64 seq);
 

commit f4335f52bb9e4e257e5a6426cdecef786f5739b7
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Dec 31 16:34:24 2017 +0100

    net/dccp: convert to ->poll_mask
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index f91e3816806b..0ea2ee56ac1b 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -316,8 +316,7 @@ int dccp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,
 		 int flags, int *addr_len);
 void dccp_shutdown(struct sock *sk, int how);
 int inet_dccp_listen(struct socket *sock, int backlog);
-__poll_t dccp_poll(struct file *file, struct socket *sock,
-		       poll_table *wait);
+__poll_t dccp_poll_mask(struct socket *sock, __poll_t events);
 int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
 void dccp_req_err(struct sock *sk, u64 seq);
 

commit ade994f4f6c8c3ef4c3bfc2d02166262fb9d089c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Jul 3 00:01:49 2017 -0400

    net: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 0c55ffb859bf..f91e3816806b 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -316,7 +316,7 @@ int dccp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,
 		 int flags, int *addr_len);
 void dccp_shutdown(struct sock *sk, int how);
 int inet_dccp_listen(struct socket *sock, int backlog);
-unsigned int dccp_poll(struct file *file, struct socket *sock,
+__poll_t dccp_poll(struct file *file, struct socket *sock,
 		       poll_table *wait);
 int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
 void dccp_req_err(struct sock *sk, u64 seq);

commit 13415e46c5915e2dac089de516369005fbc045f9
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Apr 27 16:44:43 2016 -0700

    net: snmp: kill STATS_BH macros
    
    There is nothing related to BH in SNMP counters anymore,
    since linux-3.0.
    
    Rename helpers to use __ prefix instead of _BH prefix,
    for contexts where preemption is disabled.
    
    This more closely matches convention used to update
    percpu variables.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index a4c6e2fed91c..0c55ffb859bf 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -199,7 +199,7 @@ struct dccp_mib {
 
 DECLARE_SNMP_STAT(struct dccp_mib, dccp_statistics);
 #define DCCP_INC_STATS(field)	SNMP_INC_STATS(dccp_statistics, field)
-#define __DCCP_INC_STATS(field)	SNMP_INC_STATS_BH(dccp_statistics, field)
+#define __DCCP_INC_STATS(field)	__SNMP_INC_STATS(dccp_statistics, field)
 #define DCCP_DEC_STATS(field)	SNMP_DEC_STATS(dccp_statistics, field)
 
 /*

commit aa62d76b6e1a7c927a9e0ca39de8a93b751f3b8c
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Apr 27 16:44:28 2016 -0700

    dccp: rename DCCP_INC_STATS_BH()
    
    Rename DCCP_INC_STATS_BH() to __DCCP_INC_STATS()
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index b0e28d24e1a7..a4c6e2fed91c 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -198,9 +198,9 @@ struct dccp_mib {
 };
 
 DECLARE_SNMP_STAT(struct dccp_mib, dccp_statistics);
-#define DCCP_INC_STATS(field)	    SNMP_INC_STATS(dccp_statistics, field)
-#define DCCP_INC_STATS_BH(field)    SNMP_INC_STATS_BH(dccp_statistics, field)
-#define DCCP_DEC_STATS(field)	    SNMP_DEC_STATS(dccp_statistics, field)
+#define DCCP_INC_STATS(field)	SNMP_INC_STATS(dccp_statistics, field)
+#define __DCCP_INC_STATS(field)	SNMP_INC_STATS_BH(dccp_statistics, field)
+#define DCCP_DEC_STATS(field)	SNMP_DEC_STATS(dccp_statistics, field)
 
 /*
  * 	Checksumming routines

commit 5e0724d027f0548511a2165a209572d48fe7a4c8
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Oct 22 08:20:46 2015 -0700

    tcp/dccp: fix hashdance race for passive sessions
    
    Multiple cpus can process duplicates of incoming ACK messages
    matching a SYN_RECV request socket. This is a rare event under
    normal operations, but definitely can happen.
    
    Only one must win the race, otherwise corruption would occur.
    
    To fix this without adding new atomic ops, we use logic in
    inet_ehash_nolisten() to detect the request was present in the same
    ehash bucket where we try to insert the new child.
    
    If request socket was not found, we have to undo the child creation.
    
    This actually removes a spin_lock()/spin_unlock() pair in
    reqsk_queue_unlink() for the fast path.
    
    Fixes: e994b2f0fb92 ("tcp: do not lock listener to process SYN packets")
    Fixes: 079096f103fa ("tcp/dccp: install syn_recv requests into ehash table")
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 923f5a180134..b0e28d24e1a7 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -278,7 +278,9 @@ int dccp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);
 
 struct sock *dccp_v4_request_recv_sock(const struct sock *sk, struct sk_buff *skb,
 				       struct request_sock *req,
-				       struct dst_entry *dst);
+				       struct dst_entry *dst,
+				       struct request_sock *req_unhash,
+				       bool *own_req);
 struct sock *dccp_check_req(struct sock *sk, struct sk_buff *skb,
 			    struct request_sock *req);
 

commit 45ae74f56162e7a017c3a4e130cf1bcd8d2d17cc
Author: Yaowei Bai <bywxiaobai@163.com>
Date:   Thu Oct 8 21:28:59 2015 +0800

    net/dccp: dccp_bad_service_code can be boolean
    
    This patch makes dccp_bad_service_code return bool due to these
    particular functions only using either one or zero as their return
    value.
    
    dccp_list_has_service is also been made return bool in this patchset.
    
    No functional change.
    
    Signed-off-by: Yaowei Bai <bywxiaobai@163.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e1f823451565..923f5a180134 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -325,13 +325,13 @@ void dccp_send_close(struct sock *sk, const int active);
 int dccp_invalid_packet(struct sk_buff *skb);
 u32 dccp_sample_rtt(struct sock *sk, long delta);
 
-static inline int dccp_bad_service_code(const struct sock *sk,
+static inline bool dccp_bad_service_code(const struct sock *sk,
 					const __be32 service)
 {
 	const struct dccp_sock *dp = dccp_sk(sk);
 
 	if (dp->dccps_service == service)
-		return 0;
+		return false;
 	return !dccp_list_has_service(dp->dccps_service_list, service);
 }
 

commit 0c27171e66d94f9121fc00e87407ca7103bb6649
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Sep 29 07:42:48 2015 -0700

    tcp/dccp: constify syn_recv_sock() method sock argument
    
    We'll soon no longer hold listener socket lock, these
    functions do not modify the socket in any way.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 2409619b7043..e1f823451565 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -276,7 +276,7 @@ struct sock *dccp_create_openreq_child(const struct sock *sk,
 
 int dccp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);
 
-struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,
+struct sock *dccp_v4_request_recv_sock(const struct sock *sk, struct sk_buff *skb,
 				       struct request_sock *req,
 				       struct dst_entry *dst);
 struct sock *dccp_check_req(struct sock *sk, struct sk_buff *skb,

commit 54105f98f544ec5305bf1fad292ca454ad55ef67
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Sep 29 07:42:46 2015 -0700

    dccp: constify dccp_create_openreq_child() sock argument
    
    socket no longer needs to be read/write
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 8ed1df2771bd..2409619b7043 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -270,7 +270,7 @@ int dccp_reqsk_init(struct request_sock *rq, struct dccp_sock const *dp,
 
 int dccp_v4_conn_request(struct sock *sk, struct sk_buff *skb);
 
-struct sock *dccp_create_openreq_child(struct sock *sk,
+struct sock *dccp_create_openreq_child(const struct sock *sk,
 				       const struct request_sock *req,
 				       const struct sk_buff *skb);
 

commit a00e74442bac5ad19a929d097370da7e07540ea6
Author: Eric Dumazet <edumazet@google.com>
Date:   Tue Sep 29 07:42:39 2015 -0700

    tcp/dccp: constify send_synack and send_reset socket argument
    
    None of these functions need to change the socket, make it
    const.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 31e96df500d1..8ed1df2771bd 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -229,7 +229,7 @@ void dccp_v4_send_check(struct sock *sk, struct sk_buff *skb);
 int dccp_retransmit_skb(struct sock *sk);
 
 void dccp_send_ack(struct sock *sk);
-void dccp_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
+void dccp_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,
 			 struct request_sock *rsk);
 
 void dccp_send_sync(struct sock *sk, const u64 seq,

commit 802885fc0400d0166a6b65d1844b61696aecbb10
Author: Eric Dumazet <edumazet@google.com>
Date:   Fri Sep 25 07:39:22 2015 -0700

    dccp: constify dccp_make_response() socket argument
    
    Like tcp_make_synack() the only time we might change the socket is
    when calling sock_wmalloc(), which is using atomic operation to
    update sk->sk_wmem_alloc
    
    Also use MAX_DCCP_HEADER as both IPv4/IPv6 use this value for max_header.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index bebc735f5afc..31e96df500d1 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -293,7 +293,7 @@ int dccp_init_sock(struct sock *sk, const __u8 ctl_sock_initialized);
 void dccp_destroy_sock(struct sock *sk);
 
 void dccp_close(struct sock *sk, long timeout);
-struct sk_buff *dccp_make_response(struct sock *sk, struct dst_entry *dst,
+struct sk_buff *dccp_make_response(const struct sock *sk, struct dst_entry *dst,
 				   struct request_sock *req);
 
 int dccp_connect(struct sock *sk);

commit 85645bab57bfc6b0b43bb96a301c4ef83925c07d
Author: Eric Dumazet <edumazet@google.com>
Date:   Sun Mar 22 10:22:24 2015 -0700

    ipv4: dccp: handle ICMP messages on DCCP_NEW_SYN_RECV request sockets
    
    dccp_v4_err() can restrict lookups to ehash table, and not to listeners.
    
    Note this patch creates the infrastructure, but this means that ICMP
    messages for request sockets are ignored until complete conversion.
    
    New dccp_req_err() helper is exported so that we can use it in IPv6
    in following patch.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 2396f50c5b04..bebc735f5afc 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -317,6 +317,7 @@ int inet_dccp_listen(struct socket *sock, int backlog);
 unsigned int dccp_poll(struct file *file, struct socket *sock,
 		       poll_table *wait);
 int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
+void dccp_req_err(struct sock *sk, u64 seq);
 
 struct sk_buff *dccp_ctl_make_reset(struct sock *sk, struct sk_buff *skb);
 int dccp_send_reset(struct sock *sk, enum dccp_reset_codes code);

commit 52452c542559ac980b48dbf22a30ee7fa0af507c
Author: Eric Dumazet <edumazet@google.com>
Date:   Thu Mar 19 19:04:19 2015 -0700

    inet: drop prev pointer handling in request sock
    
    When request sock are put in ehash table, the whole notion
    of having a previous request to update dl_next is pointless.
    
    Also, following patch will get rid of big purge timer,
    so we want to delete a request sock without holding listener lock.
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 3b1d64d6e093..2396f50c5b04 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -280,8 +280,7 @@ struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,
 				       struct request_sock *req,
 				       struct dst_entry *dst);
 struct sock *dccp_check_req(struct sock *sk, struct sk_buff *skb,
-			    struct request_sock *req,
-			    struct request_sock **prev);
+			    struct request_sock *req);
 
 int dccp_child_process(struct sock *parent, struct sock *child,
 		       struct sk_buff *skb);

commit 1b784140474e4fc94281a49e96c67d29df0efbde
Author: Ying Xue <ying.xue@windriver.com>
Date:   Mon Mar 2 15:37:48 2015 +0800

    net: Remove iocb argument from sendmsg and recvmsg
    
    After TIPC doesn't depend on iocb argument in its internal
    implementations of sendmsg() and recvmsg() hooks defined in proto
    structure, no any user is using iocb argument in them at all now.
    Then we can drop the redundant iocb argument completely from kinds of
    implementations of both sendmsg() and recvmsg() in the entire
    networking stack.
    
    Cc: Christoph Hellwig <hch@lst.de>
    Suggested-by: Al Viro <viro@ZenIV.linux.org.uk>
    Signed-off-by: Ying Xue <ying.xue@windriver.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e4c144fa706f..3b1d64d6e093 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -310,11 +310,9 @@ int compat_dccp_setsockopt(struct sock *sk, int level, int optname,
 			   char __user *optval, unsigned int optlen);
 #endif
 int dccp_ioctl(struct sock *sk, int cmd, unsigned long arg);
-int dccp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-		 size_t size);
-int dccp_recvmsg(struct kiocb *iocb, struct sock *sk,
-		 struct msghdr *msg, size_t len, int nonblock, int flags,
-		 int *addr_len);
+int dccp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size);
+int dccp_recvmsg(struct sock *sk, struct msghdr *msg, size_t len, int nonblock,
+		 int flags, int *addr_len);
 void dccp_shutdown(struct sock *sk, int how);
 int inet_dccp_listen(struct socket *sock, int backlog);
 unsigned int dccp_poll(struct file *file, struct socket *sock,

commit c0560b9c523341516eabf0f3b51832256caa7bbb
Author: Joe Perches <joe@perches.com>
Date:   Thu Nov 6 12:53:41 2014 -0800

    dccp: Convert DCCP_WARN to net_warn_ratelimited
    
    Remove the dependency on the "warning" sysctl (net_msg_warn)
    which is only used by the LIMIT_NETDEBUG macro.
    
    Convert the LIMIT_NETDEBUG use in DCCP_WARN to the more
    common net_warn_ratelimited mechanism.
    
    This still ratelimits based on the net_ratelimit()
    function, but removes the check for the sysctl.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index c67816647cce..e4c144fa706f 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -22,8 +22,8 @@
 /*
  * 	DCCP - specific warning and debugging macros.
  */
-#define DCCP_WARN(fmt, a...) LIMIT_NETDEBUG(KERN_WARNING "%s: " fmt,       \
-							__func__, ##a)
+#define DCCP_WARN(fmt, ...)						\
+	net_warn_ratelimited("%s: " fmt, __func__, ##__VA_ARGS__)
 #define DCCP_CRIT(fmt, a...) printk(KERN_CRIT fmt " at %s:%d/%s()\n", ##a, \
 					 __FILE__, __LINE__, __func__)
 #define DCCP_BUG(a...)       do { DCCP_CRIT("BUG: " a); dump_stack(); } while(0)

commit fd34d627aee8f32d6e54fdc0347be7a18e2d65ee
Author: stephen hemminger <stephen@networkplumber.org>
Date:   Sat Jan 4 13:46:11 2014 -0800

    dccp: remove obsolete code
    
    This function is defined but not used.
    Remove it now, can be resurrected if ever needed.
    
    Signed-off-by: Stephen Hemminger <stephen@networkplumber.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 30948784dd58..c67816647cce 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -479,7 +479,6 @@ void dccp_feat_list_purge(struct list_head *fn_list);
 
 int dccp_insert_options(struct sock *sk, struct sk_buff *skb);
 int dccp_insert_options_rsk(struct dccp_request_sock *, struct sk_buff *);
-int dccp_insert_option_elapsed_time(struct sk_buff *skb, u32 elapsed);
 u32 dccp_timestamp(void);
 void dccp_timestamping_init(void);
 int dccp_insert_option(struct sk_buff *skb, unsigned char option,

commit a402a5aa9b4cbb42cc41bf573d2e5c4713541af0
Author: Joe Perches <joe@perches.com>
Date:   Fri Oct 18 13:48:23 2013 -0700

    net: dccp: Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 708e75bf623d..30948784dd58 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -53,7 +53,7 @@ extern struct inet_hashinfo dccp_hashinfo;
 
 extern struct percpu_counter dccp_orphan_count;
 
-extern void dccp_time_wait(struct sock *sk, int state, int timeo);
+void dccp_time_wait(struct sock *sk, int state, int timeo);
 
 /*
  *  Set safe upper bounds for header and option length. Since Data Offset is 8
@@ -224,114 +224,108 @@ static inline void dccp_csum_outgoing(struct sk_buff *skb)
 	skb->csum = skb_checksum(skb, 0, (cov > skb->len)? skb->len : cov, 0);
 }
 
-extern void dccp_v4_send_check(struct sock *sk, struct sk_buff *skb);
+void dccp_v4_send_check(struct sock *sk, struct sk_buff *skb);
 
-extern int  dccp_retransmit_skb(struct sock *sk);
+int dccp_retransmit_skb(struct sock *sk);
 
-extern void dccp_send_ack(struct sock *sk);
-extern void dccp_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
-				struct request_sock *rsk);
+void dccp_send_ack(struct sock *sk);
+void dccp_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
+			 struct request_sock *rsk);
 
-extern void dccp_send_sync(struct sock *sk, const u64 seq,
-			   const enum dccp_pkt_type pkt_type);
+void dccp_send_sync(struct sock *sk, const u64 seq,
+		    const enum dccp_pkt_type pkt_type);
 
 /*
  * TX Packet Dequeueing Interface
  */
-extern void		dccp_qpolicy_push(struct sock *sk, struct sk_buff *skb);
-extern bool		dccp_qpolicy_full(struct sock *sk);
-extern void		dccp_qpolicy_drop(struct sock *sk, struct sk_buff *skb);
-extern struct sk_buff	*dccp_qpolicy_top(struct sock *sk);
-extern struct sk_buff	*dccp_qpolicy_pop(struct sock *sk);
-extern bool		dccp_qpolicy_param_ok(struct sock *sk, __be32 param);
+void dccp_qpolicy_push(struct sock *sk, struct sk_buff *skb);
+bool dccp_qpolicy_full(struct sock *sk);
+void dccp_qpolicy_drop(struct sock *sk, struct sk_buff *skb);
+struct sk_buff *dccp_qpolicy_top(struct sock *sk);
+struct sk_buff *dccp_qpolicy_pop(struct sock *sk);
+bool dccp_qpolicy_param_ok(struct sock *sk, __be32 param);
 
 /*
  * TX Packet Output and TX Timers
  */
-extern void   dccp_write_xmit(struct sock *sk);
-extern void   dccp_write_space(struct sock *sk);
-extern void   dccp_flush_write_queue(struct sock *sk, long *time_budget);
+void dccp_write_xmit(struct sock *sk);
+void dccp_write_space(struct sock *sk);
+void dccp_flush_write_queue(struct sock *sk, long *time_budget);
 
-extern void dccp_init_xmit_timers(struct sock *sk);
+void dccp_init_xmit_timers(struct sock *sk);
 static inline void dccp_clear_xmit_timers(struct sock *sk)
 {
 	inet_csk_clear_xmit_timers(sk);
 }
 
-extern unsigned int dccp_sync_mss(struct sock *sk, u32 pmtu);
+unsigned int dccp_sync_mss(struct sock *sk, u32 pmtu);
 
-extern const char *dccp_packet_name(const int type);
+const char *dccp_packet_name(const int type);
 
-extern void dccp_set_state(struct sock *sk, const int state);
-extern void dccp_done(struct sock *sk);
+void dccp_set_state(struct sock *sk, const int state);
+void dccp_done(struct sock *sk);
 
-extern int  dccp_reqsk_init(struct request_sock *rq, struct dccp_sock const *dp,
-			    struct sk_buff const *skb);
+int dccp_reqsk_init(struct request_sock *rq, struct dccp_sock const *dp,
+		    struct sk_buff const *skb);
 
-extern int dccp_v4_conn_request(struct sock *sk, struct sk_buff *skb);
+int dccp_v4_conn_request(struct sock *sk, struct sk_buff *skb);
 
-extern struct sock *dccp_create_openreq_child(struct sock *sk,
-					      const struct request_sock *req,
-					      const struct sk_buff *skb);
+struct sock *dccp_create_openreq_child(struct sock *sk,
+				       const struct request_sock *req,
+				       const struct sk_buff *skb);
 
-extern int dccp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);
+int dccp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);
 
-extern struct sock *dccp_v4_request_recv_sock(struct sock *sk,
-					      struct sk_buff *skb,
-					      struct request_sock *req,
-					      struct dst_entry *dst);
-extern struct sock *dccp_check_req(struct sock *sk, struct sk_buff *skb,
-				   struct request_sock *req,
-				   struct request_sock **prev);
+struct sock *dccp_v4_request_recv_sock(struct sock *sk, struct sk_buff *skb,
+				       struct request_sock *req,
+				       struct dst_entry *dst);
+struct sock *dccp_check_req(struct sock *sk, struct sk_buff *skb,
+			    struct request_sock *req,
+			    struct request_sock **prev);
 
-extern int dccp_child_process(struct sock *parent, struct sock *child,
-			      struct sk_buff *skb);
-extern int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
-				  struct dccp_hdr *dh, unsigned int len);
-extern int dccp_rcv_established(struct sock *sk, struct sk_buff *skb,
-				const struct dccp_hdr *dh, const unsigned int len);
+int dccp_child_process(struct sock *parent, struct sock *child,
+		       struct sk_buff *skb);
+int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
+			   struct dccp_hdr *dh, unsigned int len);
+int dccp_rcv_established(struct sock *sk, struct sk_buff *skb,
+			 const struct dccp_hdr *dh, const unsigned int len);
 
-extern int dccp_init_sock(struct sock *sk, const __u8 ctl_sock_initialized);
-extern void dccp_destroy_sock(struct sock *sk);
+int dccp_init_sock(struct sock *sk, const __u8 ctl_sock_initialized);
+void dccp_destroy_sock(struct sock *sk);
 
-extern void		dccp_close(struct sock *sk, long timeout);
-extern struct sk_buff	*dccp_make_response(struct sock *sk,
-					    struct dst_entry *dst,
-					    struct request_sock *req);
+void dccp_close(struct sock *sk, long timeout);
+struct sk_buff *dccp_make_response(struct sock *sk, struct dst_entry *dst,
+				   struct request_sock *req);
 
-extern int	   dccp_connect(struct sock *sk);
-extern int	   dccp_disconnect(struct sock *sk, int flags);
-extern int	   dccp_getsockopt(struct sock *sk, int level, int optname,
-				   char __user *optval, int __user *optlen);
-extern int	   dccp_setsockopt(struct sock *sk, int level, int optname,
-				   char __user *optval, unsigned int optlen);
+int dccp_connect(struct sock *sk);
+int dccp_disconnect(struct sock *sk, int flags);
+int dccp_getsockopt(struct sock *sk, int level, int optname,
+		    char __user *optval, int __user *optlen);
+int dccp_setsockopt(struct sock *sk, int level, int optname,
+		    char __user *optval, unsigned int optlen);
 #ifdef CONFIG_COMPAT
-extern int	   compat_dccp_getsockopt(struct sock *sk,
-				int level, int optname,
-				char __user *optval, int __user *optlen);
-extern int	   compat_dccp_setsockopt(struct sock *sk,
-				int level, int optname,
-				char __user *optval, unsigned int optlen);
+int compat_dccp_getsockopt(struct sock *sk, int level, int optname,
+			   char __user *optval, int __user *optlen);
+int compat_dccp_setsockopt(struct sock *sk, int level, int optname,
+			   char __user *optval, unsigned int optlen);
 #endif
-extern int	   dccp_ioctl(struct sock *sk, int cmd, unsigned long arg);
-extern int	   dccp_sendmsg(struct kiocb *iocb, struct sock *sk,
-				struct msghdr *msg, size_t size);
-extern int	   dccp_recvmsg(struct kiocb *iocb, struct sock *sk,
-				struct msghdr *msg, size_t len, int nonblock,
-				int flags, int *addr_len);
-extern void	   dccp_shutdown(struct sock *sk, int how);
-extern int	   inet_dccp_listen(struct socket *sock, int backlog);
-extern unsigned int dccp_poll(struct file *file, struct socket *sock,
-			     poll_table *wait);
-extern int	   dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr,
-				   int addr_len);
-
-extern struct sk_buff *dccp_ctl_make_reset(struct sock *sk,
-					   struct sk_buff *skb);
-extern int	   dccp_send_reset(struct sock *sk, enum dccp_reset_codes code);
-extern void	   dccp_send_close(struct sock *sk, const int active);
-extern int	   dccp_invalid_packet(struct sk_buff *skb);
-extern u32	   dccp_sample_rtt(struct sock *sk, long delta);
+int dccp_ioctl(struct sock *sk, int cmd, unsigned long arg);
+int dccp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+		 size_t size);
+int dccp_recvmsg(struct kiocb *iocb, struct sock *sk,
+		 struct msghdr *msg, size_t len, int nonblock, int flags,
+		 int *addr_len);
+void dccp_shutdown(struct sock *sk, int how);
+int inet_dccp_listen(struct socket *sock, int backlog);
+unsigned int dccp_poll(struct file *file, struct socket *sock,
+		       poll_table *wait);
+int dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);
+
+struct sk_buff *dccp_ctl_make_reset(struct sock *sk, struct sk_buff *skb);
+int dccp_send_reset(struct sock *sk, enum dccp_reset_codes code);
+void dccp_send_close(struct sock *sk, const int active);
+int dccp_invalid_packet(struct sk_buff *skb);
+u32 dccp_sample_rtt(struct sock *sk, long delta);
 
 static inline int dccp_bad_service_code(const struct sock *sk,
 					const __be32 service)
@@ -475,25 +469,25 @@ static inline int dccp_ack_pending(const struct sock *sk)
 	return dccp_ackvec_pending(sk) || inet_csk_ack_scheduled(sk);
 }
 
-extern int  dccp_feat_signal_nn_change(struct sock *sk, u8 feat, u64 nn_val);
-extern int  dccp_feat_finalise_settings(struct dccp_sock *dp);
-extern int  dccp_feat_server_ccid_dependencies(struct dccp_request_sock *dreq);
-extern int  dccp_feat_insert_opts(struct dccp_sock*, struct dccp_request_sock*,
-				  struct sk_buff *skb);
-extern int  dccp_feat_activate_values(struct sock *sk, struct list_head *fn);
-extern void dccp_feat_list_purge(struct list_head *fn_list);
-
-extern int dccp_insert_options(struct sock *sk, struct sk_buff *skb);
-extern int dccp_insert_options_rsk(struct dccp_request_sock*, struct sk_buff*);
-extern int dccp_insert_option_elapsed_time(struct sk_buff *skb, u32 elapsed);
-extern u32 dccp_timestamp(void);
-extern void dccp_timestamping_init(void);
-extern int dccp_insert_option(struct sk_buff *skb, unsigned char option,
-			      const void *value, unsigned char len);
+int dccp_feat_signal_nn_change(struct sock *sk, u8 feat, u64 nn_val);
+int dccp_feat_finalise_settings(struct dccp_sock *dp);
+int dccp_feat_server_ccid_dependencies(struct dccp_request_sock *dreq);
+int dccp_feat_insert_opts(struct dccp_sock*, struct dccp_request_sock*,
+			  struct sk_buff *skb);
+int dccp_feat_activate_values(struct sock *sk, struct list_head *fn);
+void dccp_feat_list_purge(struct list_head *fn_list);
+
+int dccp_insert_options(struct sock *sk, struct sk_buff *skb);
+int dccp_insert_options_rsk(struct dccp_request_sock *, struct sk_buff *);
+int dccp_insert_option_elapsed_time(struct sk_buff *skb, u32 elapsed);
+u32 dccp_timestamp(void);
+void dccp_timestamping_init(void);
+int dccp_insert_option(struct sk_buff *skb, unsigned char option,
+		       const void *value, unsigned char len);
 
 #ifdef CONFIG_SYSCTL
-extern int dccp_sysctl_init(void);
-extern void dccp_sysctl_exit(void);
+int dccp_sysctl_init(void);
+void dccp_sysctl_exit(void);
 #else
 static inline int dccp_sysctl_init(void)
 {

commit 2c53040f018b6c36a46eec75b9b937aaa5f78e6d
Author: Ben Hutchings <bhutchings@solarflare.com>
Date:   Tue Jul 10 10:55:09 2012 +0000

    net: Fix (nearly-)kernel-doc comments for various functions
    
    Fix incorrect start markers, wrapped summary lines, missing section
    breaks, incorrect separators, and some name mismatches.
    
    Signed-off-by: Ben Hutchings <bhutchings@solarflare.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 9040be049d8c..708e75bf623d 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -352,6 +352,7 @@ static inline int dccp_bad_service_code(const struct sock *sk,
  * @dccpd_opt_len: total length of all options (5.8) in the packet
  * @dccpd_seq: sequence number
  * @dccpd_ack_seq: acknowledgment number subheader field value
+ *
  * This is used for transmission as well as for reception.
  */
 struct dccp_skb_cb {

commit 95c961747284a6b83a5e2d81240e214b0fa3464d
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Sun Apr 15 05:58:06 2012 +0000

    net: cleanup unsigned to unsigned int
    
    Use of "unsigned int" is preferred to bare "unsigned" in net tree.
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 29d6bb629a6c..9040be049d8c 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -75,7 +75,7 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 				     * state, about 60 seconds */
 
 /* RFC 1122, 4.2.3.1 initial RTO value */
-#define DCCP_TIMEOUT_INIT ((unsigned)(3 * HZ))
+#define DCCP_TIMEOUT_INIT ((unsigned int)(3 * HZ))
 
 /*
  * The maximum back-off value for retransmissions. This is needed for
@@ -84,7 +84,7 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
  *  - feature-negotiation retransmission (sec. 6.6.3),
  *  - Acks in client-PARTOPEN state (sec. 8.1.5).
  */
-#define DCCP_RTO_MAX ((unsigned)(64 * HZ))
+#define DCCP_RTO_MAX ((unsigned int)(64 * HZ))
 
 /*
  * RTT sampling: sanity bounds and fallback RTT value from RFC 4340, section 3.4
@@ -287,9 +287,9 @@ extern struct sock *dccp_check_req(struct sock *sk, struct sk_buff *skb,
 extern int dccp_child_process(struct sock *parent, struct sock *child,
 			      struct sk_buff *skb);
 extern int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
-				  struct dccp_hdr *dh, unsigned len);
+				  struct dccp_hdr *dh, unsigned int len);
 extern int dccp_rcv_established(struct sock *sk, struct sk_buff *skb,
-				const struct dccp_hdr *dh, const unsigned len);
+				const struct dccp_hdr *dh, const unsigned int len);
 
 extern int dccp_init_sock(struct sock *sk, const __u8 ctl_sock_initialized);
 extern void dccp_destroy_sock(struct sock *sk);

commit eb93992207dadb946a3b5cf4544957dc924a6f58
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Dec 19 14:08:01 2011 +0000

    module_param: make bool parameters really bool (net & drivers/net)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    (Thanks to Joe Perches for suggesting coccinelle for 0/1 -> true/false).
    
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: netdev@vger.kernel.org
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 5818032e35a9..29d6bb629a6c 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -39,7 +39,7 @@
 						  "%s: " fmt, __func__, ##a)
 
 #ifdef CONFIG_IP_DCCP_DEBUG
-extern int dccp_debug;
+extern bool dccp_debug;
 #define dccp_pr_debug(format, a...)	  DCCP_PR_DEBUG(dccp_debug, format, ##a)
 #define dccp_pr_debug_cat(format, a...)   DCCP_PRINTK(dccp_debug, format, ##a)
 #define dccp_debug(fmt, a...)		  dccp_pr_debug_cat(KERN_DEBUG fmt, ##a)

commit dfd56b8b38fff3586f36232db58e1e9f7885a605
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Sat Dec 10 09:48:31 2011 +0000

    net: use IS_ENABLED(CONFIG_IPV6)
    
    Instead of testing defined(CONFIG_IPV6) || defined(CONFIG_IPV6_MODULE)
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 583490aaf56f..5818032e35a9 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -357,7 +357,7 @@ static inline int dccp_bad_service_code(const struct sock *sk,
 struct dccp_skb_cb {
 	union {
 		struct inet_skb_parm	h4;
-#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
+#if IS_ENABLED(CONFIG_IPV6)
 		struct inet6_skb_parm	h6;
 #endif
 	} header;

commit d6916f87ca5e566786f1a935a7cabba54774bbda
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Jul 24 20:22:29 2011 -0600

    dccp: support for the exchange of NN options in established state 1/2
    
    In contrast to static feature negotiation at the begin of a connection, this
    patch introduces support for exchange of dynamically changing options.
    
    Such an update/exchange is necessary in at least two cases:
     * CCID-2's Ack Ratio (RFC 4341, 6.1.2) which changes during the connection;
     * Sequence Window values that, as per RFC 4340, 7.5.2, should be sent "as
       the connection progresses".
    
    Both are non-negotiable (NN) features, which means that no new capabilities
    are negotiated, but rather that changes in known parameters are brought
    up-to-date at either end.
    
    Thse characteristics are reflected by the implementation:
     * only NN options can be exchanged after connection setup;
     * an ack is scheduled directly after activation to speed up the update;
     * CCIDs may request changes to an NN feature even if a negotiation for that
       feature is already underway: this is required by CCID-2, where changes in
       cwnd necessitate Ack Ratio changes, such that the previous Ack Ratio (which
       is still being negotiated) would cause irrecoverable RTO timeouts (thanks
       to work by Samuel Jero).
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Samuel Jero <sj323707@ohio.edu>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 5fdb07229017..583490aaf56f 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -474,6 +474,7 @@ static inline int dccp_ack_pending(const struct sock *sk)
 	return dccp_ackvec_pending(sk) || inet_csk_ack_scheduled(sk);
 }
 
+extern int  dccp_feat_signal_nn_change(struct sock *sk, u8 feat, u64 nn_val);
 extern int  dccp_feat_finalise_settings(struct dccp_sock *dp);
 extern int  dccp_feat_server_ccid_dependencies(struct dccp_request_sock *dreq);
 extern int  dccp_feat_insert_opts(struct dccp_sock*, struct dccp_request_sock*,

commit 763dadd47c884853a22f2f19ea27e58431303ff3
Author: Samuel Jero <sj323707@ohio.edu>
Date:   Thu Dec 30 12:15:41 2010 +0100

    dccp: fix bug in updating the GSR
    
    Currently dccp_check_seqno allows any valid packet to update the Greatest
    Sequence Number Received, even if that packet's sequence number is less than
    the current GSR. This patch adds a check to make sure that the new packet's
    sequence number is greater than GSR.
    
    Signed-off-by: Samuel Jero <sj323707@ohio.edu>
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 45087052d894..5fdb07229017 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -426,7 +426,8 @@ static inline void dccp_update_gsr(struct sock *sk, u64 seq)
 {
 	struct dccp_sock *dp = dccp_sk(sk);
 
-	dp->dccps_gsr = seq;
+	if (after48(seq, dp->dccps_gsr))
+		dp->dccps_gsr = seq;
 	/* Sequence validity window depends on remote Sequence Window (7.5.1) */
 	dp->dccps_swl = SUB48(ADD48(dp->dccps_gsr, 1), dp->dccps_r_seq_win / 4);
 	/*

commit b7ec19af63b467e30189984fb24e6157603608e3
Author: Shan Wei <shanwei@cn.fujitsu.com>
Date:   Fri Dec 10 12:49:23 2010 +0100

    dccp: remove unused macros
    
    Remove macros which have been unused since the initial implementation
    (commit 7c657876b63cb1d8a2ec06f8fc6c37bb8412e66c, [DCCP]: Initial
     implementation from Tue Aug 9 20:14:34 2005 -0700).
    
    Signed-off-by: Shan Wei <shanwei@cn.fujitsu.com>
    Acked-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 48ad5d9da7cb..45087052d894 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -93,9 +93,6 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 #define DCCP_FALLBACK_RTT	(USEC_PER_SEC / 5)
 #define DCCP_SANE_RTT_MAX	(3 * USEC_PER_SEC)
 
-/* Maximal interval between probes for local resources.  */
-#define DCCP_RESOURCE_PROBE_INTERVAL ((unsigned)(HZ / 2U))
-
 /* sysctl variables for DCCP */
 extern int  sysctl_dccp_request_retries;
 extern int  sysctl_dccp_retries1;
@@ -203,12 +200,7 @@ struct dccp_mib {
 DECLARE_SNMP_STAT(struct dccp_mib, dccp_statistics);
 #define DCCP_INC_STATS(field)	    SNMP_INC_STATS(dccp_statistics, field)
 #define DCCP_INC_STATS_BH(field)    SNMP_INC_STATS_BH(dccp_statistics, field)
-#define DCCP_INC_STATS_USER(field)  SNMP_INC_STATS_USER(dccp_statistics, field)
 #define DCCP_DEC_STATS(field)	    SNMP_DEC_STATS(dccp_statistics, field)
-#define DCCP_ADD_STATS_BH(field, val) \
-			SNMP_ADD_STATS_BH(dccp_statistics, field, val)
-#define DCCP_ADD_STATS_USER(field, val)	\
-			SNMP_ADD_STATS_USER(dccp_statistics, field, val)
 
 /*
  * 	Checksumming routines

commit 04910265078f08a73208beab70ed2a3cce4a919f
Author: Tomasz Grobelny <tomasz@grobelny.oswiecenia.net>
Date:   Sat Dec 4 13:39:13 2010 +0100

    dccp qpolicy: Parameter checking of cmsg qpolicy parameters
    
    Ensure that cmsg->cmsg_type value is valid for qpolicy
    that is currently in use.
    
    Signed-off-by: Tomasz Grobelny <tomasz@grobelny.oswiecenia.net>
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index d008da91cec2..48ad5d9da7cb 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -251,6 +251,7 @@ extern bool		dccp_qpolicy_full(struct sock *sk);
 extern void		dccp_qpolicy_drop(struct sock *sk, struct sk_buff *skb);
 extern struct sk_buff	*dccp_qpolicy_top(struct sock *sk);
 extern struct sk_buff	*dccp_qpolicy_pop(struct sock *sk);
+extern bool		dccp_qpolicy_param_ok(struct sock *sk, __be32 param);
 
 /*
  * TX Packet Output and TX Timers

commit 871a2c16c21b988688b4ab1a78eadd969765c0a3
Author: Tomasz Grobelny <tomasz@grobelny.oswiecenia.net>
Date:   Sat Dec 4 13:38:01 2010 +0100

    dccp: Policy-based packet dequeueing infrastructure
    
    This patch adds a generic infrastructure for policy-based dequeueing of
    TX packets and provides two policies:
     * a simple FIFO policy (which is the default) and
     * a priority based policy (set via socket options).
    Both policies honour the tx_qlen sysctl for the maximum size of the write
    queue (can be overridden via socket options).
    
    The priority policy uses skb->priority internally to assign an u32 priority
    identifier, using the same ranking as SO_PRIORITY. The skb->priority field
    is set to 0 when the packet leaves DCCP. The priority is supplied as ancillary
    data using cmsg(3), the patch also provides the requisite parsing routines.
    
    Signed-off-by: Tomasz Grobelny <tomasz@grobelny.oswiecenia.net>
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 19fafd597465..d008da91cec2 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -243,6 +243,18 @@ extern void dccp_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
 extern void dccp_send_sync(struct sock *sk, const u64 seq,
 			   const enum dccp_pkt_type pkt_type);
 
+/*
+ * TX Packet Dequeueing Interface
+ */
+extern void		dccp_qpolicy_push(struct sock *sk, struct sk_buff *skb);
+extern bool		dccp_qpolicy_full(struct sock *sk);
+extern void		dccp_qpolicy_drop(struct sock *sk, struct sk_buff *skb);
+extern struct sk_buff	*dccp_qpolicy_top(struct sock *sk);
+extern struct sk_buff	*dccp_qpolicy_pop(struct sock *sk);
+
+/*
+ * TX Packet Output and TX Timers
+ */
 extern void   dccp_write_xmit(struct sock *sk);
 extern void   dccp_write_space(struct sock *sk);
 extern void   dccp_flush_write_queue(struct sock *sk, long *time_budget);

commit b3d14bff12a38ad13a174eb0cc83d2ac7169eee4
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Nov 10 21:21:35 2010 +0100

    dccp ccid-2: Implementation of circular Ack Vector buffer with overflow handling
    
    This completes the implementation of a circular buffer for Ack Vectors, by
    extending the current (linear array-based) implementation.  The changes are:
    
     (a) An `overflow' flag to deal with the case of overflow. As before, dynamic
         growth of the buffer will not be supported; but code will be added to deal
         robustly with overflowing Ack Vector buffers.
    
     (b) A `tail_seqno' field. When naively implementing the algorithm of Appendix A
         in RFC 4340, problems arise whenever subsequent Ack Vector records overlap,
         which can bring the entire run length calculation completely out of synch.
         (This is documented on http://www.erg.abdn.ac.uk/users/gerrit/dccp/notes/\
                                                 ack_vectors/tracking_tail_ackno/ .)
     (c) The buffer length is now computed dynamically (i.e. current fill level),
         as the span between head to tail.
    
    As a result, dccp_ackvec_pending() is now simpler - the #ifdef is no longer
    necessary since buf_empty is always true when IP_DCCP_ACKVEC is not configured.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index a8ed459508b2..19fafd597465 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -457,12 +457,15 @@ static inline void dccp_update_gss(struct sock *sk, u64 seq)
 	dp->dccps_awh = dp->dccps_gss;
 }
 
+static inline int dccp_ackvec_pending(const struct sock *sk)
+{
+	return dccp_sk(sk)->dccps_hc_rx_ackvec != NULL &&
+	       !dccp_ackvec_is_empty(dccp_sk(sk)->dccps_hc_rx_ackvec);
+}
+
 static inline int dccp_ack_pending(const struct sock *sk)
 {
-	const struct dccp_sock *dp = dccp_sk(sk);
-	return (dp->dccps_hc_rx_ackvec != NULL &&
-		dccp_ackvec_pending(dp->dccps_hc_rx_ackvec)) ||
-	       inet_csk_ack_scheduled(sk);
+	return dccp_ackvec_pending(sk) || inet_csk_ack_scheduled(sk);
 }
 
 extern int  dccp_feat_finalise_settings(struct dccp_sock *dp);

commit b1fcf55eea541af9efa5d39f5a0d1aec8ceca55d
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Oct 27 19:16:27 2010 +0000

    dccp: Refine the wait-for-ccid mechanism
    
    This extends the existing wait-for-ccid routine so that it may be used with
    different types of CCID, addressing the following problems:
    
     1) The queue-drain mechanism only works with rate-based CCIDs. If CCID-2 for
        example has a full TX queue and becomes network-limited just as the
        application wants to close, then waiting for CCID-2 to become unblocked
        could lead to an indefinite  delay (i.e., application "hangs").
     2) Since each TX CCID in turn uses a feedback mechanism, there may be changes
        in its sending policy while the queue is being drained. This can lead to
        further delays during which the application will not be able to terminate.
     3) The minimum wait time for CCID-3/4 can be expected to be the queue length
        times the current inter-packet delay. For example if tx_qlen=100 and a delay
        of 15 ms is used for each packet, then the application would have to wait
        for a minimum of 1.5 seconds before being allowed to exit.
     4) There is no way for the user/application to control this behaviour. It would
        be good to use the timeout argument of dccp_close() as an upper bound. Then
        the maximum time that an application is willing to wait for its CCIDs to can
        be set via the SO_LINGER option.
    
    These problems are addressed by giving the CCID a grace period of up to the
    `timeout' value.
    
    The wait-for-ccid function is, as before, used when the application
     (a) has read all the data in its receive buffer and
     (b) if SO_LINGER was set with a non-zero linger time, or
     (c) the socket is either in the OPEN (active close) or in the PASSIVE_CLOSEREQ
         state (client application closes after receiving CloseReq).
    
    In addition, there is a catch-all case of __skb_queue_purge() after waiting for
    the CCID. This is necessary since the write queue may still have data when
     (a) the host has been passively-closed,
     (b) abnormal termination (unread data, zero linger time),
     (c) wait-for-ccid could not finish within the given time limit.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 3eb264b60823..a8ed459508b2 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -243,8 +243,9 @@ extern void dccp_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
 extern void dccp_send_sync(struct sock *sk, const u64 seq,
 			   const enum dccp_pkt_type pkt_type);
 
-extern void dccp_write_xmit(struct sock *sk, int block);
-extern void dccp_write_space(struct sock *sk);
+extern void   dccp_write_xmit(struct sock *sk);
+extern void   dccp_write_space(struct sock *sk);
+extern void   dccp_flush_write_queue(struct sock *sk, long *time_budget);
 
 extern void dccp_init_xmit_timers(struct sock *sk);
 static inline void dccp_clear_xmit_timers(struct sock *sk)

commit ecdfbdabbe4e0cf0443cbbea2df1bf51bf67f3f3
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Oct 11 20:41:13 2010 +0200

    dccp: schedule an Ack when receiving timestamps
    
    This schedules an Ack when receiving a timestamp, exploiting the
    existing inet_csk_schedule_ack() function, saving one case in the
    `dccp_ack_pending()' function.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 60f4f9622ab3..3eb264b60823 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -459,8 +459,7 @@ static inline void dccp_update_gss(struct sock *sk, u64 seq)
 static inline int dccp_ack_pending(const struct sock *sk)
 {
 	const struct dccp_sock *dp = dccp_sk(sk);
-	return dp->dccps_timestamp_echo != 0 ||
-	       (dp->dccps_hc_rx_ackvec != NULL &&
+	return (dp->dccps_hc_rx_ackvec != NULL &&
 		dccp_ackvec_pending(dp->dccps_hc_rx_ackvec)) ||
 	       inet_csk_ack_scheduled(sk);
 }

commit d196c9a5d4e150cdff675662214c80c69b906958
Author: Ivo Calado <ivocalado@embedded.ufcg.edu.br>
Date:   Mon Oct 11 20:40:04 2010 +0200

    dccp: generalise data-loss condition
    
    This patch generalises the task of determining data loss from RFC 4340, 7.7.1.
    
    Let S_A, S_B be sequence numbers such that S_B is "after" S_A, and let
    N_B be the NDP count of packet S_B. Then, using modulo-2^48 arithmetic,
     D = S_B - S_A - 1  is an upper bound of the number of lost data packets,
     D - N_B            is an approximation of the number of lost data packets
                        (there are cases where this is not exact).
    
    The patch implements this as
     dccp_loss_count(S_A, S_B, N_B) := max(S_B - S_A - 1 - N_B, 0)
    
    Signed-off-by: Ivo Calado <ivocalado@embedded.ufcg.edu.br>
    Signed-off-by: Erivaldo Xavier <desadoc@gmail.com>
    Signed-off-by: Leandro Sales <leandroal@gmail.com>
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e051c774ef5c..60f4f9622ab3 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -153,18 +153,27 @@ static inline u64 max48(const u64 seq1, const u64 seq2)
 }
 
 /**
- * dccp_loss_free  -  Evaluates condition for data loss from RFC 4340, 7.7.1
- * @s1:	 start sequence number
- * @s2:  end sequence number
+ * dccp_loss_count - Approximate the number of lost data packets in a burst loss
+ * @s1:  last known sequence number before the loss ('hole')
+ * @s2:  first sequence number seen after the 'hole'
  * @ndp: NDP count on packet with sequence number @s2
- * Returns true if the sequence range s1...s2 has no data loss.
  */
-static inline bool dccp_loss_free(const u64 s1, const u64 s2, const u64 ndp)
+static inline u64 dccp_loss_count(const u64 s1, const u64 s2, const u64 ndp)
 {
 	s64 delta = dccp_delta_seqno(s1, s2);
 
 	WARN_ON(delta < 0);
-	return (u64)delta <= ndp + 1;
+	delta -= ndp + 1;
+
+	return delta > 0 ? delta : 0;
+}
+
+/**
+ * dccp_loss_free - Evaluate condition for data loss from RFC 4340, 7.7.1
+ */
+static inline bool dccp_loss_free(const u64 s1, const u64 s2, const u64 ndp)
+{
+	return dccp_loss_count(s1, s2, ndp) == 0;
 }
 
 enum {

commit 0b53d4604ac2b4f2faa9a62a04ea9b383ad2efe0
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Oct 11 20:35:40 2010 +0200

    dccp: fix the adjustments to AWL and SWL
    
    This fixes a problem and a potential loophole with regard to seqno/ackno
    validity: currently the initial adjustments to AWL/SWL are only performed
    once at the begin of the connection, during the handshake.
    
    Since the Sequence Window feature is always greater than Wmin=32 (7.5.2),
    it is however necessary to perform these adjustments at least for the first
    W/W' (variables as per 7.5.1) packets in the lifetime of a connection.
    
    This requirement is complicated by the fact that W/W' can change at any time
    during the lifetime of a connection.
    
    Therefore it is better to perform that safety check each time SWL/AWL are
    updated, as implemented by the patch.
    
    A second problem solved by this patch is that the remote/local Sequence Window
    feature values (which set the bounds for AWL/SWL/SWH) are undefined until the
    feature negotiation has completed.
    
    During the initial handshake we have more stringent sequence number protection;
    the changes added by this patch effect that {A,S}W{L,H} are within the correct
    bounds at the instant that feature negotiation completes (since the SeqWin
    feature activation handlers call dccp_update_gsr/gss()).
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 019d6ffee354..e051c774ef5c 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -414,6 +414,23 @@ static inline void dccp_update_gsr(struct sock *sk, u64 seq)
 	dp->dccps_gsr = seq;
 	/* Sequence validity window depends on remote Sequence Window (7.5.1) */
 	dp->dccps_swl = SUB48(ADD48(dp->dccps_gsr, 1), dp->dccps_r_seq_win / 4);
+	/*
+	 * Adjust SWL so that it is not below ISR. In contrast to RFC 4340,
+	 * 7.5.1 we perform this check beyond the initial handshake: W/W' are
+	 * always > 32, so for the first W/W' packets in the lifetime of a
+	 * connection we always have to adjust SWL.
+	 * A second reason why we are doing this is that the window depends on
+	 * the feature-remote value of Sequence Window: nothing stops the peer
+	 * from updating this value while we are busy adjusting SWL for the
+	 * first W packets (we would have to count from scratch again then).
+	 * Therefore it is safer to always make sure that the Sequence Window
+	 * is not artificially extended by a peer who grows SWL downwards by
+	 * continually updating the feature-remote Sequence-Window.
+	 * If sequence numbers wrap it is bad luck. But that will take a while
+	 * (48 bit), and this measure prevents Sequence-number attacks.
+	 */
+	if (before48(dp->dccps_swl, dp->dccps_isr))
+		dp->dccps_swl = dp->dccps_isr;
 	dp->dccps_swh = ADD48(dp->dccps_gsr, (3 * dp->dccps_r_seq_win) / 4);
 }
 
@@ -424,6 +441,9 @@ static inline void dccp_update_gss(struct sock *sk, u64 seq)
 	dp->dccps_gss = seq;
 	/* Ack validity window depends on local Sequence Window value (7.5.1) */
 	dp->dccps_awl = SUB48(ADD48(dp->dccps_gss, 1), dp->dccps_l_seq_win);
+	/* Adjust AWL so that it is not below ISS - see comment above for SWL */
+	if (before48(dp->dccps_awl, dp->dccps_iss))
+		dp->dccps_awl = dp->dccps_iss;
 	dp->dccps_awh = dp->dccps_gss;
 }
 

commit 1f4f0f645cc1d7f1187fcdb0ac22c2e69bd68050
Author: stephen hemminger <shemminger@vyatta.com>
Date:   Tue Oct 5 04:24:09 2010 +0000

    dccp: Kill dead code and add static markers.
    
    Remove dead code and make some functions static.
    Compile tested only.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 3ccef1b70fee..019d6ffee354 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -246,7 +246,6 @@ static inline void dccp_clear_xmit_timers(struct sock *sk)
 extern unsigned int dccp_sync_mss(struct sock *sk, u32 pmtu);
 
 extern const char *dccp_packet_name(const int type);
-extern const char *dccp_state_name(const int state);
 
 extern void dccp_set_state(struct sock *sk, const int state);
 extern void dccp_done(struct sock *sk);
@@ -449,7 +448,6 @@ extern int dccp_insert_options_rsk(struct dccp_request_sock*, struct sk_buff*);
 extern int dccp_insert_option_elapsed_time(struct sk_buff *skb, u32 elapsed);
 extern u32 dccp_timestamp(void);
 extern void dccp_timestamping_init(void);
-extern int dccp_insert_option_timestamp(struct sk_buff *skb);
 extern int dccp_insert_option(struct sk_buff *skb, unsigned char option,
 			      const void *value, unsigned char len);
 

commit a7d13fbf85375698879d16f118af77fbfcc2de44
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Jun 22 01:14:34 2010 +0000

    dccp: remove unused function argument
    
    This removes an unused 'sk' argument from several option-inserting functions.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index a10a61a1ded2..3ccef1b70fee 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -446,16 +446,12 @@ extern void dccp_feat_list_purge(struct list_head *fn_list);
 
 extern int dccp_insert_options(struct sock *sk, struct sk_buff *skb);
 extern int dccp_insert_options_rsk(struct dccp_request_sock*, struct sk_buff*);
-extern int dccp_insert_option_elapsed_time(struct sock *sk,
-					    struct sk_buff *skb,
-					    u32 elapsed_time);
+extern int dccp_insert_option_elapsed_time(struct sk_buff *skb, u32 elapsed);
 extern u32 dccp_timestamp(void);
 extern void dccp_timestamping_init(void);
-extern int dccp_insert_option_timestamp(struct sock *sk,
-					 struct sk_buff *skb);
-extern int dccp_insert_option(struct sock *sk, struct sk_buff *skb,
-			       unsigned char option,
-			       const void *value, unsigned char len);
+extern int dccp_insert_option_timestamp(struct sk_buff *skb);
+extern int dccp_insert_option(struct sk_buff *skb, unsigned char option,
+			      const void *value, unsigned char len);
 
 #ifdef CONFIG_SYSCTL
 extern int dccp_sysctl_init(void);

commit bb29624614c2afe2873ee8ee97cf09df42701694
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sun Apr 11 02:15:55 2010 +0000

    inet: Remove unused send_check length argument
    
    inet: Remove unused send_check length argument
    
    This patch removes the unused length argument from the send_check
    function in struct inet_connection_sock_af_ops.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Tested-by: Yinghai <yinghai.lu@oracle.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 53f8e12d0c10..a10a61a1ded2 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -223,7 +223,7 @@ static inline void dccp_csum_outgoing(struct sk_buff *skb)
 	skb->csum = skb_checksum(skb, 0, (cov > skb->len)? skb->len : cov, 0);
 }
 
-extern void dccp_v4_send_check(struct sock *sk, int len, struct sk_buff *skb);
+extern void dccp_v4_send_check(struct sock *sk, struct sk_buff *skb);
 
 extern int  dccp_retransmit_skb(struct sock *sk);
 

commit ec733b15a3ef0b5759141a177f8044a2f40c41e7
Author: Eric Dumazet <eric.dumazet@gmail.com>
Date:   Thu Mar 18 20:36:06 2010 +0000

    net: snmp mib cleanup
    
    There is no point to align or pad mibs to cache lines, they are per cpu
    allocated with a 8 bytes alignment anyway.
    This wastes space for no gain. This patch removes __SNMP_MIB_ALIGN__
    
    Since SNMP mibs contain "unsigned long" fields only, we can relax the
    allocation alignment from "unsigned long long" to "unsigned long"
    
    Signed-off-by: Eric Dumazet <eric.dumazet@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 5ef32c2f0d6a..53f8e12d0c10 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -189,7 +189,7 @@ enum {
 #define DCCP_MIB_MAX	__DCCP_MIB_MAX
 struct dccp_mib {
 	unsigned long	mibs[DCCP_MIB_MAX];
-} __SNMP_MIB_ALIGN__;
+};
 
 DECLARE_SNMP_STAT(struct dccp_mib, dccp_statistics);
 #define DCCP_INC_STATS(field)	    SNMP_INC_STATS(dccp_statistics, field)

commit b7058842c940ad2c08dd829b21e5c92ebe3b8758
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Sep 30 16:12:20 2009 -0700

    net: Make setsockopt() optlen be unsigned.
    
    This provides safety against negative optlen at the type
    level instead of depending upon (sometimes non-trivial)
    checks against this sprinkled all over the the place, in
    each and every implementation.
    
    Based upon work done by Arjan van de Ven and feedback
    from Linus Torvalds.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index d6bc47363b1c..5ef32c2f0d6a 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -290,14 +290,14 @@ extern int	   dccp_disconnect(struct sock *sk, int flags);
 extern int	   dccp_getsockopt(struct sock *sk, int level, int optname,
 				   char __user *optval, int __user *optlen);
 extern int	   dccp_setsockopt(struct sock *sk, int level, int optname,
-				   char __user *optval, int optlen);
+				   char __user *optval, unsigned int optlen);
 #ifdef CONFIG_COMPAT
 extern int	   compat_dccp_getsockopt(struct sock *sk,
 				int level, int optname,
 				char __user *optval, int __user *optlen);
 extern int	   compat_dccp_setsockopt(struct sock *sk,
 				int level, int optname,
-				char __user *optval, int optlen);
+				char __user *optval, unsigned int optlen);
 #endif
 extern int	   dccp_ioctl(struct sock *sk, int cmd, unsigned long arg);
 extern int	   dccp_sendmsg(struct kiocb *iocb, struct sock *sk,

commit 86739fb96e8c8269fc5b3d300c959bede272a6f6
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Feb 27 22:38:29 2009 +0000

    dccp: Do not let initial option overhead shrink the MPS
    
    This fixes a problem caused by the overlap of the connection-setup and
    established-state phases of DCCP connections.
    
    During connection setup, the client retransmits Confirm Feature-Negotiation
    options until a response from the server signals that it can move from the
    half-established PARTOPEN into the OPEN state, whereupon the connection is
    fully established on both ends (RFC 4340, 8.1.5).
    
    However, since the client may already send data while it is in the PARTOPEN
    state, consequences arise for the Maximum Packet Size: the problem is that the
    initial option overhead is much higher than for the subsequent established
    phase, as it involves potentially many variable-length list-type options
    (server-priority options, RFC 4340, 6.4).
    
    Applying the standard MPS is insufficient here: especially with larger
    payloads this can lead to annoying, counter-intuitive EMSGSIZE errors.
    
    On the other hand, reducing the MPS available for the established phase by
    the added initial overhead is highly wasteful and inefficient.
    
    The solution chosen therefore is a two-phase strategy:
    
       If the payload length of the DataAck in PARTOPEN is too large, an Ack is sent
       to carry the options, and the feature-negotiation list is then flushed.
    
       This means that the server gets two Acks for one Response. If both Acks get
       lost, it is probably better to restart the connection anyway and devising yet
       another special-case does not seem worth the extra complexity.
    
    The result is a higher utilisation of the available packet space for the data
    transmission phase (established state) of a connection.
    
    The patch (over-)estimates the initial overhead to be 32*4 bytes -- commonly
    seen values were around 90 bytes for initial feature-negotiation options.
    
    It uses sizeof(u32) to mean "aligned units of 4 bytes".
    For consistency, another use of 4-byte alignment is adapted.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 08a569ff02d1..d6bc47363b1c 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -63,11 +63,14 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
  *    - DCCP-Reset    with ACK Subheader and 4 bytes of Reset Code fields
  *  Hence a safe upper bound for the maximum option length is 1020-28 = 992
  */
-#define MAX_DCCP_SPECIFIC_HEADER (255 * sizeof(int))
+#define MAX_DCCP_SPECIFIC_HEADER (255 * sizeof(uint32_t))
 #define DCCP_MAX_PACKET_HDR 28
 #define DCCP_MAX_OPT_LEN (MAX_DCCP_SPECIFIC_HEADER - DCCP_MAX_PACKET_HDR)
 #define MAX_DCCP_HEADER (MAX_DCCP_SPECIFIC_HEADER + MAX_HEADER)
 
+/* Upper bound for initial feature-negotiation overhead (padded to 32 bits) */
+#define DCCP_FEATNEG_OVERHEAD	 (32 * sizeof(uint32_t))
+
 #define DCCP_TIMEWAIT_LEN (60 * HZ) /* how long to wait to destroy TIME-WAIT
 				     * state, about 60 seconds */
 

commit f3f3abb62ccb1a1c77bcce855c04e12356e6ac95
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Jan 16 23:36:33 2009 +0000

    dccp: Debugging functions for feature negotiation
    
    Since all feature-negotiation processing now takes place in feat.c,
    functions for producing verbose debugging output are concentrated
    there.
    
    New functions to print out values, entry records, and options are
    provided, and also a macro is defined to not always have the function
    name in the output line.
    
    Thanks a lot to Wei Yongjun and Giuseppe Galeota for help and
    discussion with an earlier revision of this patch.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 44a5bc6f6785..08a569ff02d1 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -42,9 +42,11 @@
 extern int dccp_debug;
 #define dccp_pr_debug(format, a...)	  DCCP_PR_DEBUG(dccp_debug, format, ##a)
 #define dccp_pr_debug_cat(format, a...)   DCCP_PRINTK(dccp_debug, format, ##a)
+#define dccp_debug(fmt, a...)		  dccp_pr_debug_cat(KERN_DEBUG fmt, ##a)
 #else
 #define dccp_pr_debug(format, a...)
 #define dccp_pr_debug_cat(format, a...)
+#define dccp_debug(format, a...)
 #endif
 
 extern struct inet_hashinfo dccp_hashinfo;

commit 883ca833e5fb814fb03426c9d35e5489ce43e8da
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Jan 16 23:36:32 2009 +0000

    dccp: Initialisation and type-checking of feature sysctls
    
    This patch takes care of initialising and type-checking sysctls
    related to feature negotiation. Type checking is important since some
    of the sysctls now directly impact the feature-negotiation process.
    
    The sysctls are initialised with the known default values for each
    feature.  For the type-checking the value constraints from RFC 4340
    are used:
    
     * Sequence Window uses the specified Wmin=32, the maximum is ulong (4 bytes),
       tested and confirmed that it works up to 4294967295 - for Gbps speed;
     * Ack Ratio is between 0 .. 0xffff (2-byte unsigned integer);
     * CCIDs are between 0 .. 255;
     * request_retries, retries1, retries2 also between 0..255 for good measure;
     * tx_qlen is checked to be non-negative;
     * sync_ratelimit remains as before.
    
    Notes:
    ------
     1. Die s@sysctl_dccp_feat@sysctl_dccp@g since the sysctls are now in feat.c.
     2. As pointed out by Arnaldo, the pattern of type-checking repeats itself in
        other places, sometimes with exactly the same kind of definitions (e.g.
        "static int zero;"). It may be a good idea (kernel janitors?) to consolidate
        type checking. For the sake of keeping the changeset small and in order not
        to affect other subsystems, I have not strived to generalise here.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 04ae91898a68..44a5bc6f6785 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -95,9 +95,6 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 extern int  sysctl_dccp_request_retries;
 extern int  sysctl_dccp_retries1;
 extern int  sysctl_dccp_retries2;
-extern int  sysctl_dccp_feat_sequence_window;
-extern int  sysctl_dccp_feat_rx_ccid;
-extern int  sysctl_dccp_feat_tx_ccid;
 extern int  sysctl_dccp_tx_qlen;
 extern int  sysctl_dccp_sync_ratelimit;
 

commit 792b48780e8b6435d017cef4b5c304876a48653e
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Jan 16 23:36:31 2009 +0000

    dccp: Implement both feature-local and feature-remote Sequence Window feature
    
    This adds full support for local/remote Sequence Window feature, from which the
      * sequence-number-validity (W) and
      * acknowledgment-number-validity (W') windows
    derive as specified in RFC 4340, 7.5.3.
    
    Specifically, the following is contained in this patch:
      * integrated new socket fields into dccp_sk;
      * updated the update_gsr/gss routines with regard to these fields;
      * updated handler code: the Sequence Window feature is located at the TX side,
        so the local feature is meant if the handler-rx flag is false;
      * the initialisation of `rcv_wnd' in reqsk is removed, since
        - rcv_wnd is not used by the code anywhere;
        - sequence number checks are not done in the LISTEN state (cf. 7.5.3);
        - dccp_check_req checks the Ack number validity more rigorously;
      * the `struct dccp_minisock' became empty and is now removed.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index f2230fc168e1..04ae91898a68 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -409,23 +409,21 @@ static inline void dccp_hdr_set_ack(struct dccp_hdr_ack_bits *dhack,
 static inline void dccp_update_gsr(struct sock *sk, u64 seq)
 {
 	struct dccp_sock *dp = dccp_sk(sk);
-	const struct dccp_minisock *dmsk = dccp_msk(sk);
 
 	dp->dccps_gsr = seq;
-	dccp_set_seqno(&dp->dccps_swl,
-		       dp->dccps_gsr + 1 - (dmsk->dccpms_sequence_window / 4));
-	dccp_set_seqno(&dp->dccps_swh,
-		       dp->dccps_gsr + (3 * dmsk->dccpms_sequence_window) / 4);
+	/* Sequence validity window depends on remote Sequence Window (7.5.1) */
+	dp->dccps_swl = SUB48(ADD48(dp->dccps_gsr, 1), dp->dccps_r_seq_win / 4);
+	dp->dccps_swh = ADD48(dp->dccps_gsr, (3 * dp->dccps_r_seq_win) / 4);
 }
 
 static inline void dccp_update_gss(struct sock *sk, u64 seq)
 {
 	struct dccp_sock *dp = dccp_sk(sk);
 
-	dp->dccps_awh = dp->dccps_gss = seq;
-	dccp_set_seqno(&dp->dccps_awl,
-		       (dp->dccps_gss -
-			dccp_msk(sk)->dccpms_sequence_window + 1));
+	dp->dccps_gss = seq;
+	/* Ack validity window depends on local Sequence Window value (7.5.1) */
+	dp->dccps_awl = SUB48(ADD48(dp->dccps_gss, 1), dp->dccps_l_seq_win);
+	dp->dccps_awh = dp->dccps_gss;
 }
 
 static inline int dccp_ack_pending(const struct sock *sk)

commit ddebc973c56b51b4e5d84d606f0430d81b895d67
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Jan 4 21:42:53 2009 -0800

    dccp: Lockless integration of CCID congestion-control plugins
    
    Based on Arnaldo's earlier patch, this patch integrates the standardised
    CCID congestion control plugins (CCID-2 and CCID-3) of DCCP with dccp.ko:
    
     * enables a faster connection path by eliminating the need to always go
       through the CCID registration lock;
    
     * updates the implementation to use only a single array whose size equals
       the number of configured CCIDs instead of the maximum (256);
    
     * since the CCIDs are now fixed array elements, synchronization is no
       longer needed, simplifying use and implementation.
    
    CCID-2 is suggested as minimum for a basic DCCP implementation (RFC 4340, 10);
    CCID-3 is a standards-track CCID supported by RFC 4342 and RFC 5348.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 0bc4c9a02e19..f2230fc168e1 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -432,10 +432,8 @@ static inline int dccp_ack_pending(const struct sock *sk)
 {
 	const struct dccp_sock *dp = dccp_sk(sk);
 	return dp->dccps_timestamp_echo != 0 ||
-#ifdef CONFIG_IP_DCCP_ACKVEC
 	       (dp->dccps_hc_rx_ackvec != NULL &&
 		dccp_ackvec_pending(dp->dccps_hc_rx_ackvec)) ||
-#endif
 	       inet_csk_ack_scheduled(sk);
 }
 

commit 6fdd34d43bff8be9bb925b49d87a0ee144d2ab07
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Dec 8 01:19:06 2008 -0800

    dccp ccid-2: Phase out the use of boolean Ack Vector sysctl
    
    This removes the use of the sysctl and the minisock variable for the Send Ack
    Vector feature, as it now is handled fully dynamically via feature negotiation
    (i.e. when CCID-2 is enabled, Ack Vectors are automatically enabled as per
     RFC 4341, 4.).
    
    Using a sysctl in parallel to this implementation would open the door to
    crashes, since much of the code relies on tests of the boolean minisock /
    sysctl variable. Thus, this patch replaces all tests of type
    
            if (dccp_msk(sk)->dccpms_send_ack_vector)
                    /* ... */
    with
            if (dp->dccps_hc_rx_ackvec != NULL)
                    /* ... */
    
    The dccps_hc_rx_ackvec is allocated by the dccp_hdlr_ackvec() when feature
    negotiation concluded that Ack Vectors are to be used on the half-connection.
    Otherwise, it is NULL (due to dccp_init_sock/dccp_create_openreq_child),
    so that the test is a valid one.
    
    The activation handler for Ack Vectors is called as soon as the feature
    negotiation has concluded at the
     * server when the Ack marking the transition RESPOND => OPEN arrives;
     * client after it has sent its ACK, marking the transition REQUEST => PARTOPEN.
    
    Adding the sequence number of the Response packet to the Ack Vector has been
    removed, since
     (a) connection establishment implies that the Response has been received;
     (b) the CCIDs only look at packets received in the (PART)OPEN state, i.e.
         this entry will always be ignored;
     (c) it can not be used for anything useful - to detect loss for instance, only
         packets received after the loss can serve as pseudo-dupacks.
    
    There was a FIXME to change the error code when dccp_ackvec_add() fails.
    I removed this after finding out that:
     * the check whether ackno < ISN is already made earlier,
     * this Response is likely the 1st packet with an Ackno that the client gets,
     * so when dccp_ackvec_add() fails, the reason is likely not a packet error.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e0759d098b9a..0bc4c9a02e19 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -98,7 +98,6 @@ extern int  sysctl_dccp_retries2;
 extern int  sysctl_dccp_feat_sequence_window;
 extern int  sysctl_dccp_feat_rx_ccid;
 extern int  sysctl_dccp_feat_tx_ccid;
-extern int  sysctl_dccp_feat_send_ack_vector;
 extern int  sysctl_dccp_tx_qlen;
 extern int  sysctl_dccp_sync_ratelimit;
 
@@ -434,7 +433,7 @@ static inline int dccp_ack_pending(const struct sock *sk)
 	const struct dccp_sock *dp = dccp_sk(sk);
 	return dp->dccps_timestamp_echo != 0 ||
 #ifdef CONFIG_IP_DCCP_ACKVEC
-	       (dccp_msk(sk)->dccpms_send_ack_vector &&
+	       (dp->dccps_hc_rx_ackvec != NULL &&
 		dccp_ackvec_pending(dp->dccps_hc_rx_ackvec)) ||
 #endif
 	       inet_csk_ack_scheduled(sk);

commit 4098dce5be537a157eed4a326efd464109825b8b
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Dec 8 01:18:37 2008 -0800

    dccp: Remove manual influence on NDP Count feature
    
    Updating the NDP count feature is handled automatically now:
     * for CCID-2 it is disabled, since the code does not use NDP counts;
     * for CCID-3 it is enabled, as NDP counts are used to determine loss lengths.
    
    Allowing the user to change NDP values leads to unpredictable and failing
    behaviour, since it is then possible to disable NDP counts even when they
    are needed (e.g. in CCID-3).
    
    This means that only those user settings are sensible that agree with the
    values for Send NDP Count implied by the choice of CCID. But those settings
    are already activated by the feature negotiation (CCID dependency tracking),
    hence this form of support is redundant.
    
    At startup the initialisation of the NDP count feature uses the default
    value of 0, which is done implicitly by the zeroing-out of the socket when
    it is allocated. If the choice of CCID or feature negotiation enables NDP
    count, this will then be updated via the NDP activation handler.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 94f6785f81ec..e0759d098b9a 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -99,7 +99,6 @@ extern int  sysctl_dccp_feat_sequence_window;
 extern int  sysctl_dccp_feat_rx_ccid;
 extern int  sysctl_dccp_feat_tx_ccid;
 extern int  sysctl_dccp_feat_send_ack_vector;
-extern int  sysctl_dccp_feat_send_ndp_count;
 extern int  sysctl_dccp_tx_qlen;
 extern int  sysctl_dccp_sync_ratelimit;
 

commit 422d9cdcb85b3622d08a590fed66021af7aea333
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Dec 1 23:34:01 2008 -0800

    dccp: Feature activation handlers
    
    This patch provides the post-processing of feature negotiation state, after
    the negotiation has completed.
    
    To this purpose, handlers are used and added to the dccp_feat_table. Each
    handler is passed a boolean flag whether the RX or TX side of the feature
    is meant.
    
    Several handlers are provided already, new handlers can easily be added.
    
    The initialisation is now fully dynamic, i.e. CCIDs are activated only
    after the feature negotiation. The integration of this dynamic activation
    is done in the subsequent patches.
    
    Thanks to Wei Yongjun for pointing out the necessity of skipping over empty
    Confirm options while copying the negotiated feature values.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 4ed7c5936bcf..94f6785f81ec 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -445,6 +445,7 @@ extern int  dccp_feat_finalise_settings(struct dccp_sock *dp);
 extern int  dccp_feat_server_ccid_dependencies(struct dccp_request_sock *dreq);
 extern int  dccp_feat_insert_opts(struct dccp_sock*, struct dccp_request_sock*,
 				  struct sk_buff *skb);
+extern int  dccp_feat_activate_values(struct sock *sk, struct list_head *fn);
 extern void dccp_feat_list_purge(struct list_head *fn_list);
 
 extern int dccp_insert_options(struct sock *sk, struct sk_buff *skb);

commit 0971d17ca3d80f61863f4750091a64448bf91600
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Dec 1 23:27:31 2008 -0800

    dccp: Insert feature-negotiation options into skb
    
    This patch replaces the earlier insertion routine from options.c, so that
    code specific to feature negotiation can remain in feat.c. This is possible
    by calling a function already existing in options.c.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 33a1127270c1..4ed7c5936bcf 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -443,6 +443,8 @@ static inline int dccp_ack_pending(const struct sock *sk)
 
 extern int  dccp_feat_finalise_settings(struct dccp_sock *dp);
 extern int  dccp_feat_server_ccid_dependencies(struct dccp_request_sock *dreq);
+extern int  dccp_feat_insert_opts(struct dccp_sock*, struct dccp_request_sock*,
+				  struct sk_buff *skb);
 extern void dccp_feat_list_purge(struct list_head *fn_list);
 
 extern int dccp_insert_options(struct sock *sk, struct sk_buff *skb);

commit dd24c00191d5e4a1ae896aafe33c6b8095ab4bd1
Author: Eric Dumazet <dada1@cosmosbay.com>
Date:   Tue Nov 25 21:17:14 2008 -0800

    net: Use a percpu_counter for orphan_count
    
    Instead of using one atomic_t per protocol, use a percpu_counter
    for "orphan_count", to reduce cache line contention on
    heavy duty network servers.
    
    Signed-off-by: Eric Dumazet <dada1@cosmosbay.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 031ce350d3c1..33a1127270c1 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -49,7 +49,7 @@ extern int dccp_debug;
 
 extern struct inet_hashinfo dccp_hashinfo;
 
-extern atomic_t dccp_orphan_count;
+extern struct percpu_counter dccp_orphan_count;
 
 extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 

commit dd9c0e363cef32b7d6f23d4c87e8dfe4f91fd1c5
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Nov 16 22:55:08 2008 -0800

    dccp: Deprecate Ack Ratio sysctl
    
    This patch deprecates the Ack Ratio sysctl, since
     * Ack Ratio is entirely ignored by CCID-3 and CCID-4,
     * Ack Ratio currently doesn't work in CCID-2 (i.e. is always set to 1);
     * even if it would work in CCID-2, there is no point for a user to change it:
       - Ack Ratio is constrained by cwnd (RFC 4341, 6.1.2),
       - if Ack Ratio > cwnd, the system resorts to spurious RTO timeouts
         (since waiting for Acks which will never arrive in this window),
       - cwnd is not a user-configurable value.
    
    The only reasonable place for Ack Ratio is to print it for debugging. It is
    planned to do this later on, as part of e.g. dccp_probe.
    
    With this patch Ack Ratio is now under full control of feature negotiation:
     * Ack Ratio is resolved as a dependency of the selected CCID;
     * if the chosen CCID supports it (i.e. CCID == CCID-2), Ack Ratio is set to
       the default of 2, following RFC 4340, 11.3 - "New connections start with Ack
       Ratio 2 for both endpoints";
     * what happens then is part of another patch set, since it concerns the
       dynamic update of Ack Ratio while the connection is in full flight.
    
    Thanks to Tomasz Grobelny for discussion leading up to this patch.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e656dafb5d96..031ce350d3c1 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -98,7 +98,6 @@ extern int  sysctl_dccp_retries2;
 extern int  sysctl_dccp_feat_sequence_window;
 extern int  sysctl_dccp_feat_rx_ccid;
 extern int  sysctl_dccp_feat_tx_ccid;
-extern int  sysctl_dccp_feat_ack_ratio;
 extern int  sysctl_dccp_feat_send_ack_vector;
 extern int  sysctl_dccp_feat_send_ndp_count;
 extern int  sysctl_dccp_tx_qlen;

commit 0c1168398ecbfacbb27203b281bde20ec9f78017
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Nov 16 22:49:52 2008 -0800

    dccp: Mechanism to resolve CCID dependencies
    
    This adds a hook to resolve features whose value depends on the choice of
    CCID. It is done at the server since it can only be done after the CCID
    values have been negotiated; i.e. the client will add its CCID preference
    list on the Change options sent in the Request, which will be reconciled
    with the local preference list of the server.
    
    The concept is documented on
    http://www.erg.abdn.ac.uk/users/gerrit/dccp/notes/feature_negotiation/\
                                    implementation_notes.html#ccid_dependencies
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 1881527bdcd7..e656dafb5d96 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -443,6 +443,7 @@ static inline int dccp_ack_pending(const struct sock *sk)
 }
 
 extern int  dccp_feat_finalise_settings(struct dccp_sock *dp);
+extern int  dccp_feat_server_ccid_dependencies(struct dccp_request_sock *dreq);
 extern void dccp_feat_list_purge(struct list_head *fn_list);
 
 extern int dccp_insert_options(struct sock *sk, struct sk_buff *skb);

commit 9eca0a47dee201a73967026985b5f0a79a46bd36
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Nov 12 00:48:44 2008 -0800

    dccp: Resolve dependencies of features on choice of CCID
    
    This provides a missing link in the code chain, as several features implicitly
    depend and/or rely on the choice of CCID. Most notably, this is the Send Ack Vector
    feature, but also Ack Ratio and Send Loss Event Rate (also taken care of).
    
    For Send Ack Vector, the situation is as follows:
     * since CCID2 mandates the use of Ack Vectors, there is no point in allowing
       endpoints which use CCID2 to disable Ack Vector features such a connection;
    
     * a peer with a TX CCID of CCID2 will always expect Ack Vectors, and a peer
       with a RX CCID of CCID2 must always send Ack Vectors (RFC 4341, sec. 4);
    
     * for all other CCIDs, the use of (Send) Ack Vector is optional and thus
       negotiable. However, this implies that the code negotiating the use of Ack
       Vectors also supports it (i.e. is able to supply and to either parse or
       ignore received Ack Vectors). Since this is not the case (CCID-3 has no Ack
       Vector support), the use of Ack Vectors is here disabled, with a comment
       in the source code.
    
    An analogous consideration arises for the Send Loss Event Rate feature,
    since the CCID-3 implementation does not support the loss interval options
    of RFC 4342. To make such use explicit, corresponding feature-negotiation
    options are inserted which signal the use of the loss event rate option,
    as it is used by the CCID3 code.
    
    Lastly, the values of the Ack Ratio feature are matched to the choice of CCID.
    
    The patch implements this as a function which is called after the user has
    made all other registrations for changing default values of features.
    
    The table is variable-length, the reserved (and hence for feature-negotiation
    invalid, confirmed by considering section 19.4 of RFC 4340) feature number `0'
    is used to mark the end of the table.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index dee4a90886d6..1881527bdcd7 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -442,6 +442,7 @@ static inline int dccp_ack_pending(const struct sock *sk)
 	       inet_csk_ack_scheduled(sk);
 }
 
+extern int  dccp_feat_finalise_settings(struct dccp_sock *dp);
 extern void dccp_feat_list_purge(struct list_head *fn_list);
 
 extern int dccp_insert_options(struct sock *sk, struct sk_buff *skb);

commit ac75773c2742d82cbcb078708df406e9017224b7
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Nov 4 23:55:49 2008 -0800

    dccp: Per-socket initialisation of feature negotiation
    
    This provides feature-negotiation initialisation for both DCCP sockets
    and DCCP request_sockets, to support feature negotiation during
    connection setup.
    
    It also resolves a FIXME regarding the congestion control
    initialisation.
    
    Thanks to Wei Yongjun for help with the IPv6 side of this patch.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index d6fed595a3ff..dee4a90886d6 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -252,7 +252,8 @@ extern const char *dccp_state_name(const int state);
 extern void dccp_set_state(struct sock *sk, const int state);
 extern void dccp_done(struct sock *sk);
 
-extern void dccp_reqsk_init(struct request_sock *req, struct sk_buff *skb);
+extern int  dccp_reqsk_init(struct request_sock *rq, struct dccp_sock const *dp,
+			    struct sk_buff const *skb);
 
 extern int dccp_v4_conn_request(struct sock *sk, struct sk_buff *skb);
 

commit 61e6473efbd6087e1db3aaa93a5266c5bfd8aa99
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Nov 4 23:54:04 2008 -0800

    dccp: List management for new feature negotiation
    
    This adds list initial fields and list management functions for the
    new feature negotiation implementation.
    
    Thanks to Arnaldo for suggestions and improvements.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index b4bc6e095a0e..d6fed595a3ff 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -441,6 +441,8 @@ static inline int dccp_ack_pending(const struct sock *sk)
 	       inet_csk_ack_scheduled(sk);
 }
 
+extern void dccp_feat_list_purge(struct list_head *fn_list);
+
 extern int dccp_insert_options(struct sock *sk, struct sk_buff *skb);
 extern int dccp_insert_options_rsk(struct dccp_request_sock*, struct sk_buff*);
 extern int dccp_insert_option_elapsed_time(struct sock *sk,

commit 6edafaaf6f5e70ef1e620ff01bd6bacebe1e0718
Author: Gui Jianfeng <guijianfeng@cn.fujitsu.com>
Date:   Wed Aug 6 23:50:04 2008 -0700

    tcp: Fix kernel panic when calling tcp_v(4/6)_md5_do_lookup
    
    If the following packet flow happen, kernel will panic.
    MathineA                        MathineB
                    SYN
            ---------------------->
                    SYN+ACK
            <----------------------
                    ACK(bad seq)
            ---------------------->
    When a bad seq ACK is received, tcp_v4_md5_do_lookup(skb->sk, ip_hdr(skb)->daddr))
    is finally called by tcp_v4_reqsk_send_ack(), but the first parameter(skb->sk) is
    NULL at that moment, so kernel panic happens.
    This patch fixes this bug.
    
    OOPS output is as following:
    [  302.812793] IP: [<c05cfaa6>] tcp_v4_md5_do_lookup+0x12/0x42
    [  302.817075] Oops: 0000 [#1] SMP
    [  302.819815] Modules linked in: ipv6 loop dm_multipath rtc_cmos rtc_core rtc_lib pcspkr pcnet32 mii i2c_piix4 parport_pc i2c_core parport ac button ata_piix libata dm_mod mptspi mptscsih mptbase scsi_transport_spi sd_mod scsi_mod crc_t10dif ext3 jbd mbcache uhci_hcd ohci_hcd ehci_hcd [last unloaded: scsi_wait_scan]
    [  302.849946]
    [  302.851198] Pid: 0, comm: swapper Not tainted (2.6.27-rc1-guijf #5)
    [  302.855184] EIP: 0060:[<c05cfaa6>] EFLAGS: 00010296 CPU: 0
    [  302.858296] EIP is at tcp_v4_md5_do_lookup+0x12/0x42
    [  302.861027] EAX: 0000001e EBX: 00000000 ECX: 00000046 EDX: 00000046
    [  302.864867] ESI: ceb69e00 EDI: 1467a8c0 EBP: cf75f180 ESP: c0792e54
    [  302.868333]  DS: 007b ES: 007b FS: 00d8 GS: 0000 SS: 0068
    [  302.871287] Process swapper (pid: 0, ti=c0792000 task=c0712340 task.ti=c0746000)
    [  302.875592] Stack: c06f413a 00000000 cf75f180 ceb69e00 00000000 c05d0d86 000016d0 ceac5400
    [  302.883275]        c05d28f8 000016d0 ceb69e00 ceb69e20 681bf6e3 00001000 00000000 0a67a8c0
    [  302.890971]        ceac5400 c04250a3 c06f413a c0792eb0 c0792edc cf59a620 cf59a620 cf59a634
    [  302.900140] Call Trace:
    [  302.902392]  [<c05d0d86>] tcp_v4_reqsk_send_ack+0x17/0x35
    [  302.907060]  [<c05d28f8>] tcp_check_req+0x156/0x372
    [  302.910082]  [<c04250a3>] printk+0x14/0x18
    [  302.912868]  [<c05d0aa1>] tcp_v4_do_rcv+0x1d3/0x2bf
    [  302.917423]  [<c05d26be>] tcp_v4_rcv+0x563/0x5b9
    [  302.920453]  [<c05bb20f>] ip_local_deliver_finish+0xe8/0x183
    [  302.923865]  [<c05bb10a>] ip_rcv_finish+0x286/0x2a3
    [  302.928569]  [<c059e438>] dev_alloc_skb+0x11/0x25
    [  302.931563]  [<c05a211f>] netif_receive_skb+0x2d6/0x33a
    [  302.934914]  [<d0917941>] pcnet32_poll+0x333/0x680 [pcnet32]
    [  302.938735]  [<c05a3b48>] net_rx_action+0x5c/0xfe
    [  302.941792]  [<c042856b>] __do_softirq+0x5d/0xc1
    [  302.944788]  [<c042850e>] __do_softirq+0x0/0xc1
    [  302.948999]  [<c040564b>] do_softirq+0x55/0x88
    [  302.951870]  [<c04501b1>] handle_fasteoi_irq+0x0/0xa4
    [  302.954986]  [<c04284da>] irq_exit+0x35/0x69
    [  302.959081]  [<c0405717>] do_IRQ+0x99/0xae
    [  302.961896]  [<c040422b>] common_interrupt+0x23/0x28
    [  302.966279]  [<c040819d>] default_idle+0x2a/0x3d
    [  302.969212]  [<c0402552>] cpu_idle+0xb2/0xd2
    [  302.972169]  =======================
    [  302.974274] Code: fc ff 84 d2 0f 84 df fd ff ff e9 34 fe ff ff 83 c4 0c 5b 5e 5f 5d c3 90 90 57 89 d7 56 53 89 c3 50 68 3a 41 6f c0 e8 e9 55 e5 ff <8b> 93 9c 04 00 00 58 85 d2 59 74 1e 8b 72 10 31 db 31 c9 85 f6
    [  303.011610] EIP: [<c05cfaa6>] tcp_v4_md5_do_lookup+0x12/0x42 SS:ESP 0068:c0792e54
    [  303.018360] Kernel panic - not syncing: Fatal exception in interrupt
    
    Signed-off-by: Gui Jianfeng <guijianfeng@cn.fujitsu.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 1c2e3ec2eb57..b4bc6e095a0e 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -229,7 +229,8 @@ extern void dccp_v4_send_check(struct sock *sk, int len, struct sk_buff *skb);
 extern int  dccp_retransmit_skb(struct sock *sk);
 
 extern void dccp_send_ack(struct sock *sk);
-extern void dccp_reqsk_send_ack(struct sk_buff *sk, struct request_sock *rsk);
+extern void dccp_reqsk_send_ack(struct sock *sk, struct sk_buff *skb,
+				struct request_sock *rsk);
 
 extern void dccp_send_sync(struct sock *sk, const u64 seq,
 			   const enum dccp_pkt_type pkt_type);

commit 59435444a13ed52d3444c5df26b73d3086bcd57b
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sat Jul 26 11:59:09 2008 +0100

    dccp: Allow to distinguish original and retransmitted packets
    
    This patch allows the sender to distinguish original and retransmitted packets,
    which is in particular needed for the retransmission of DCCP-Requests:
     * the first Request uses ISS (generated in net/dccp/ip*.c), and sets GSS = ISS;
     * all retransmitted Requests use GSS' = GSS + 1, so that the n-th retransmitted
       Request has sequence number ISS + n (mod 48).
    
    To add generic support, the patch reorganises existing code so that:
     * icsk_retransmits == 0     for the original packet and
     * icsk_retransmits = n > 0  for the n-th retransmitted packet
    at the time dccp_transmit_skb() is called, via dccp_retransmit_skb().
    
    Thanks to Wei Yongjun for pointing this problem out.
    
    Further changes:
    ----------------
     * removed the `skb' argument from dccp_retransmit_skb(), since sk_send_head
       is used for all retransmissions (the exception is client-Acks in PARTOPEN
       state, but these do not use sk_send_head);
     * since sk_send_head always contains the original skb (via dccp_entail()),
       skb_cloned() never evaluated to true and thus pskb_copy() was never used.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 743d85fcd651..1c2e3ec2eb57 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -226,7 +226,7 @@ static inline void dccp_csum_outgoing(struct sk_buff *skb)
 
 extern void dccp_v4_send_check(struct sock *sk, int len, struct sk_buff *skb);
 
-extern int  dccp_retransmit_skb(struct sock *sk, struct sk_buff *skb);
+extern int  dccp_retransmit_skb(struct sock *sk);
 
 extern void dccp_send_ack(struct sock *sk);
 extern void dccp_reqsk_send_ack(struct sk_buff *sk, struct request_sock *rsk);

commit 547b792cac0a038b9dbf958d3c120df3740b5572
Author: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
Date:   Fri Jul 25 21:43:18 2008 -0700

    net: convert BUG_TRAP to generic WARN_ON
    
    Removes legacy reinvent-the-wheel type thing. The generic
    machinery integrates much better to automated debugging aids
    such as kerneloops.org (and others), and is unambiguous due to
    better naming. Non-intuively BUG_TRAP() is actually equal to
    WARN_ON() rather than BUG_ON() though some might actually be
    promoted to BUG_ON() but I left that to future.
    
    I could make at least one BUILD_BUG_ON conversion.
    
    Signed-off-by: Ilpo Jrvinen <ilpo.jarvinen@helsinki.fi>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 32617e0576cb..743d85fcd651 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -164,7 +164,7 @@ static inline bool dccp_loss_free(const u64 s1, const u64 s2, const u64 ndp)
 {
 	s64 delta = dccp_delta_seqno(s1, s2);
 
-	BUG_TRAP(delta >= 0);
+	WARN_ON(delta < 0);
 	return (u64)delta <= ndp + 1;
 }
 

commit 2013c7e35aeba39777f9b3eef8a70207b3931152
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Jul 13 11:51:40 2008 +0100

    dccp ccid-3: Fix error in loss detection
    
    The TFRC loss detection code used the wrong loss condition (RFC 4340, 7.7.1):
     * the difference between sequence numbers s1 and s2 instead of
     * the number of packets missing between s1 and s2 (one less than the distance).
    
    Since this condition appears in many places of the code, it has been put into a
    separate function, dccp_loss_free().
    
    Further changes:
    ----------------
     * tidied up incorrect typing (it was using `int' for u64/s64 types);
     * optimised conditional statements for common case of non-reordered packets;
     * rewrote comments/documentation to match the changes.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 1b2cea244e12..32617e0576cb 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -153,6 +153,21 @@ static inline u64 max48(const u64 seq1, const u64 seq2)
 	return after48(seq1, seq2) ? seq1 : seq2;
 }
 
+/**
+ * dccp_loss_free  -  Evaluates condition for data loss from RFC 4340, 7.7.1
+ * @s1:	 start sequence number
+ * @s2:  end sequence number
+ * @ndp: NDP count on packet with sequence number @s2
+ * Returns true if the sequence range s1...s2 has no data loss.
+ */
+static inline bool dccp_loss_free(const u64 s1, const u64 s2, const u64 ndp)
+{
+	s64 delta = dccp_delta_seqno(s1, s2);
+
+	BUG_TRAP(delta >= 0);
+	return (u64)delta <= ndp + 1;
+}
+
 enum {
 	DCCP_MIB_NUM = 0,
 	DCCP_MIB_ACTIVEOPENS,			/* ActiveOpens */

commit 7d06b2e053d2d536348e3a0f6bb02982a41bea37
Author: Brian Haley <brian.haley@hp.com>
Date:   Sat Jun 14 17:04:49 2008 -0700

    net: change proto destroy method to return void
    
    Change struct proto destroy function pointer to return void.  Noticed
    by Al Viro.
    
    Signed-off-by: Brian Haley <brian.haley@hp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index f44d492d3b74..1b2cea244e12 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -262,7 +262,7 @@ extern int dccp_rcv_established(struct sock *sk, struct sk_buff *skb,
 				const struct dccp_hdr *dh, const unsigned len);
 
 extern int dccp_init_sock(struct sock *sk, const __u8 ctl_sock_initialized);
-extern int dccp_destroy_sock(struct sock *sk);
+extern void dccp_destroy_sock(struct sock *sk);
 
 extern void		dccp_close(struct sock *sk, long timeout);
 extern struct sk_buff	*dccp_make_response(struct sock *sk,

commit df39e8ba56a788733d369068c7319e04b1da3cd5
Merge: f5572855ec49 159d83363b62
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Apr 14 02:30:23 2008 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
    
            drivers/net/ehea/ehea_main.c
            drivers/net/wireless/iwlwifi/Kconfig
            drivers/net/wireless/rt2x00/rt61pci.c
            net/ipv4/inet_timewait_sock.c
            net/ipv6/raw.c
            net/mac80211/ieee80211_sta.c

commit 028b027524b162eef90839a92ba4b8bddf23e06c
Author: Patrick McHardy <kaber@trash.net>
Date:   Sat Apr 12 18:35:41 2008 -0700

    [DCCP]: Fix skb->cb conflicts with IP
    
    dev_queue_xmit() and the other IP output functions expect to get a skb
    with clear or properly initialized skb->cb. Unlike TCP and UDP, the
    dccp_skb_cb doesn't contain a struct inet_skb_parm at the beginning,
    so the DCCP-specific data is interpreted by the IP output functions.
    This can cause false negatives for the conditional POST_ROUTING hook
    invocation, making the packet bypass the hook.
    
    Add a inet_skb_parm/inet6_skb_parm union to the beginning of
    dccp_skb_cb to avoid clashes. Also add a BUILD_BUG_ON to make
    sure it fits in the cb.
    
    [ Combined with patch from Gerrit Renker to remove two now unnecessary
      memsets of IPCB(skb)->opt ]
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Acked-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 287a62bc2e0f..ba2ef94a2302 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -325,6 +325,12 @@ static inline int dccp_bad_service_code(const struct sock *sk,
  * This is used for transmission as well as for reception.
  */
 struct dccp_skb_cb {
+	union {
+		struct inet_skb_parm	h4;
+#if defined(CONFIG_IPV6) || defined (CONFIG_IPV6_MODULE)
+		struct inet6_skb_parm	h6;
+#endif
+	} header;
 	__u8  dccpd_type:4;
 	__u8  dccpd_ccval:4;
 	__u8  dccpd_reset_code,

commit 7630f026810a63464e47391ab1e03674c33eb1b8
Author: Denis V. Lunev <den@openvz.org>
Date:   Thu Apr 3 14:20:52 2008 -0700

    [DCCP]: Replace socket with sock for reset sending.
    
    Replace dccp_v(4|6)_ctl_socket with sock to unify a code with TCP/ICMP.
    
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Acked-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e1b7c9c6a623..fe7726b0018f 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -296,7 +296,7 @@ extern unsigned int dccp_poll(struct file *file, struct socket *sock,
 extern int	   dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr,
 				   int addr_len);
 
-extern struct sk_buff *dccp_ctl_make_reset(struct socket *ctl,
+extern struct sk_buff *dccp_ctl_make_reset(struct sock *sk,
 					   struct sk_buff *skb);
 extern int	   dccp_send_reset(struct sock *sk, enum dccp_reset_codes code);
 extern void	   dccp_send_close(struct sock *sk, const int active);

commit 0dc47877a3de00ceadea0005189656ae8dc52669
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Mar 5 20:47:47 2008 -0800

    net: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 287a62bc2e0f..e1b7c9c6a623 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -23,9 +23,9 @@
  * 	DCCP - specific warning and debugging macros.
  */
 #define DCCP_WARN(fmt, a...) LIMIT_NETDEBUG(KERN_WARNING "%s: " fmt,       \
-							__FUNCTION__, ##a)
+							__func__, ##a)
 #define DCCP_CRIT(fmt, a...) printk(KERN_CRIT fmt " at %s:%d/%s()\n", ##a, \
-					 __FILE__, __LINE__, __FUNCTION__)
+					 __FILE__, __LINE__, __func__)
 #define DCCP_BUG(a...)       do { DCCP_CRIT("BUG: " a); dump_stack(); } while(0)
 #define DCCP_BUG_ON(cond)    do { if (unlikely((cond) != 0))		   \
 				     DCCP_BUG("\"%s\" holds (exception!)", \
@@ -36,7 +36,7 @@
 							printk(fmt, ##args); \
 						} while(0)
 #define DCCP_PR_DEBUG(enable, fmt, a...)	DCCP_PRINTK(enable, KERN_DEBUG \
-						  "%s: " fmt, __FUNCTION__, ##a)
+						  "%s: " fmt, __func__, ##a)
 
 #ifdef CONFIG_IP_DCCP_DEBUG
 extern int dccp_debug;

commit ab1e0a13d70299e792fd0527cefd070c1405fa5b
Author: Arnaldo Carvalho de Melo <acme@redhat.com>
Date:   Sun Feb 3 04:06:04 2008 -0800

    [SOCK] proto: Add hashinfo member to struct proto
    
    This way we can remove TCP and DCCP specific versions of
    
    sk->sk_prot->get_port: both v4 and v6 use inet_csk_get_port
    sk->sk_prot->hash:     inet_hash is directly used, only v6 need
                           a specific version to deal with mapped sockets
    sk->sk_prot->unhash:   both v4 and v6 use inet_hash directly
    
    struct inet_connection_sock_af_ops also gets a new member, bind_conflict, so
    that inet_csk_get_port can find the per family routine.
    
    Now only the lookup routines receive as a parameter a struct inet_hashtable.
    
    With this we further reuse code, reducing the difference among INET transport
    protocols.
    
    Eventually work has to be done on UDP and SCTP to make them share this
    infrastructure and get as a bonus inet_diag interfaces so that iproute can be
    used with these protocols.
    
    net-2.6/net/ipv4/inet_hashtables.c:
      struct proto                       |   +8
      struct inet_connection_sock_af_ops |   +8
     2 structs changed
      __inet_hash_nolisten               |  +18
      __inet_hash                        | -210
      inet_put_port                      |   +8
      inet_bind_bucket_create            |   +1
      __inet_hash_connect                |   -8
     5 functions changed, 27 bytes added, 218 bytes removed, diff: -191
    
    net-2.6/net/core/sock.c:
      proto_seq_show                     |   +3
     1 function changed, 3 bytes added, diff: +3
    
    net-2.6/net/ipv4/inet_connection_sock.c:
      inet_csk_get_port                  |  +15
     1 function changed, 15 bytes added, diff: +15
    
    net-2.6/net/ipv4/tcp.c:
      tcp_set_state                      |   -7
     1 function changed, 7 bytes removed, diff: -7
    
    net-2.6/net/ipv4/tcp_ipv4.c:
      tcp_v4_get_port                    |  -31
      tcp_v4_hash                        |  -48
      tcp_v4_destroy_sock                |   -7
      tcp_v4_syn_recv_sock               |   -2
      tcp_unhash                         | -179
     5 functions changed, 267 bytes removed, diff: -267
    
    net-2.6/net/ipv6/inet6_hashtables.c:
      __inet6_hash |   +8
     1 function changed, 8 bytes added, diff: +8
    
    net-2.6/net/ipv4/inet_hashtables.c:
      inet_unhash                        | +190
      inet_hash                          | +242
     2 functions changed, 432 bytes added, diff: +432
    
    vmlinux:
     16 functions changed, 485 bytes added, 492 bytes removed, diff: -7
    
    /home/acme/git/net-2.6/net/ipv6/tcp_ipv6.c:
      tcp_v6_get_port                    |  -31
      tcp_v6_hash                        |   -7
      tcp_v6_syn_recv_sock               |   -9
     3 functions changed, 47 bytes removed, diff: -47
    
    /home/acme/git/net-2.6/net/dccp/proto.c:
      dccp_destroy_sock                  |   -7
      dccp_unhash                        | -179
      dccp_hash                          |  -49
      dccp_set_state                     |   -7
      dccp_done                          |   +1
     5 functions changed, 1 bytes added, 242 bytes removed, diff: -241
    
    /home/acme/git/net-2.6/net/dccp/ipv4.c:
      dccp_v4_get_port                   |  -31
      dccp_v4_request_recv_sock          |   -2
     2 functions changed, 33 bytes removed, diff: -33
    
    /home/acme/git/net-2.6/net/dccp/ipv6.c:
      dccp_v6_get_port                   |  -31
      dccp_v6_hash                       |   -7
      dccp_v6_request_recv_sock          |   +5
     3 functions changed, 5 bytes added, 38 bytes removed, diff: -33
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index ebe59d98721a..287a62bc2e0f 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -271,8 +271,6 @@ extern struct sk_buff	*dccp_make_response(struct sock *sk,
 
 extern int	   dccp_connect(struct sock *sk);
 extern int	   dccp_disconnect(struct sock *sk, int flags);
-extern void	   dccp_hash(struct sock *sk);
-extern void	   dccp_unhash(struct sock *sk);
 extern int	   dccp_getsockopt(struct sock *sk, int level, int optname,
 				   char __user *optval, int __user *optlen);
 extern int	   dccp_setsockopt(struct sock *sk, int level, int optname,

commit a07a5a86d091699fd5e791765b8a79e6b1ef96cb
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Dec 17 12:58:04 2007 -0200

    [DCCP]: Remove unused inline function
    
    The function follows48(), which is a special-case of dccp_delta_seqno(),
    is nowhere used in the DCCP code, thus removed by this patch.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index b138e2019d78..ebe59d98721a 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -153,12 +153,6 @@ static inline u64 max48(const u64 seq1, const u64 seq2)
 	return after48(seq1, seq2) ? seq1 : seq2;
 }
 
-/* is seq1 next seqno after seq2 */
-static inline int follows48(const u64 seq1, const u64 seq2)
-{
-	return dccp_delta_seqno(seq2, seq1) == 1;
-}
-
 enum {
 	DCCP_MIB_NUM = 0,
 	DCCP_MIB_ACTIVEOPENS,			/* ActiveOpens */

commit af3b867e2f6b72422bc7aacb1f1e26f47a9649bc
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Thu Dec 13 12:38:11 2007 -0200

    [DCCP]: Support inserting options during the 3-way handshake
    
    This provides a separate routine to insert options during the initial handshake.
    The main purpose is to conduct feature negotiation, for the moment the only user
    is the timestamp echo needed for the (CCID3) handshake RTT sample.
    
    Padding of options has been put into a small separate routine, to be shared among
    the two functions. This could also be used as a generic routine to finish inserting
    options.
    
    Also removed an `XXX' comment since its content was obvious.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 3af3320194f0..b138e2019d78 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -428,6 +428,7 @@ static inline int dccp_ack_pending(const struct sock *sk)
 }
 
 extern int dccp_insert_options(struct sock *sk, struct sk_buff *skb);
+extern int dccp_insert_options_rsk(struct dccp_request_sock*, struct sk_buff*);
 extern int dccp_insert_option_elapsed_time(struct sock *sk,
 					    struct sk_buff *skb,
 					    u32 elapsed_time);

commit 28be5440044d5b19b0331f79fb3e81845ad6d77e
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Thu Dec 13 12:16:23 2007 -0200

    [DCCP]: Use maximum-RTO backoff from DCCP spec
    
    This removes another Fixme, using the TCP maximum RTO rather than the value
    specified by the DCCP specification. Across the sections in RFC 4340, 64
    seconds is consistently suggested as maximum RTO backoff value; and this is
    the value which is now used.
    
    I have checked both termination cases for retransmissions of Close/CloseReq:
    with the default value 15 of `retries2', and an initial icsk_retransmit = 0,
    it takes about 614 seconds to declare a non-responding peer as dead, after
    which the final terminating Reset is sent. With the TCP maximum RTO value of
    120 seconds it takes (as might be expected) almost twice as long, about 23
    minutes.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 07dcbe73b50c..3af3320194f0 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -72,7 +72,14 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 /* RFC 1122, 4.2.3.1 initial RTO value */
 #define DCCP_TIMEOUT_INIT ((unsigned)(3 * HZ))
 
-#define DCCP_RTO_MAX ((unsigned)(120 * HZ)) /* FIXME: using TCP value */
+/*
+ * The maximum back-off value for retransmissions. This is needed for
+ *  - retransmitting client-Requests (sec. 8.1.1),
+ *  - retransmitting Close/CloseReq when closing (sec. 8.3),
+ *  - feature-negotiation retransmission (sec. 6.6.3),
+ *  - Acks in client-PARTOPEN state (sec. 8.1.5).
+ */
+#define DCCP_RTO_MAX ((unsigned)(64 * HZ))
 
 /*
  * RTT sampling: sanity bounds and fallback RTT value from RFC 4340, section 3.4

commit 954c2db868ce896325dced91d5fba5e2226897a4
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Dec 12 14:06:14 2007 -0200

    [CCID3]: Interface CCID3 code with newer Loss Intervals Database
    
    This hooks up the TFRC Loss Interval database with CCID 3 packet reception.
    In addition, it makes the CCID-specific computation of the first loss
    interval (which requires access to all the guts of CCID3) local to ccid3.c.
    
    The patch also fixes an omission in the DCCP code, that of a default /
    fallback RTT value (defined in section 3.4 of RFC 4340 as 0.2 sec); while
    at it, the  upper bound of 4 seconds for an RTT sample has  been reduced to
    match the initial TCP RTO value of 3 seconds from[RFC 1122, 4.2.3.1].
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index f4a5ea116e34..07dcbe73b50c 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -74,9 +74,12 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 
 #define DCCP_RTO_MAX ((unsigned)(120 * HZ)) /* FIXME: using TCP value */
 
-/* bounds for sampled RTT values from packet exchanges (in usec) */
+/*
+ * RTT sampling: sanity bounds and fallback RTT value from RFC 4340, section 3.4
+ */
 #define DCCP_SANE_RTT_MIN	100
-#define DCCP_SANE_RTT_MAX	(4 * USEC_PER_SEC)
+#define DCCP_FALLBACK_RTT	(USEC_PER_SEC / 5)
+#define DCCP_SANE_RTT_MAX	(3 * USEC_PER_SEC)
 
 /* Maximal interval between probes for local resources.  */
 #define DCCP_RESOURCE_PROBE_INTERVAL ((unsigned)(HZ / 2U))

commit 2180c41ca5c1a36c67f4140e80154699333109d2
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Thu Dec 6 12:27:15 2007 -0200

    [DCCP]: Introduce generic function to test for `data packets'
    
    as per  RFC 4340, sec. 7.7.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index ee97950d77d1..f4a5ea116e34 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -334,6 +334,7 @@ struct dccp_skb_cb {
 
 #define DCCP_SKB_CB(__skb) ((struct dccp_skb_cb *)&((__skb)->cb[0]))
 
+/* RFC 4340, sec. 7.7 */
 static inline int dccp_non_data_packet(const struct sk_buff *skb)
 {
 	const __u8 type = DCCP_SKB_CB(skb)->dccpd_type;
@@ -346,6 +347,17 @@ static inline int dccp_non_data_packet(const struct sk_buff *skb)
 	       type == DCCP_PKT_SYNCACK;
 }
 
+/* RFC 4340, sec. 7.7 */
+static inline int dccp_data_packet(const struct sk_buff *skb)
+{
+	const __u8 type = DCCP_SKB_CB(skb)->dccpd_type;
+
+	return type == DCCP_PKT_DATA	 ||
+	       type == DCCP_PKT_DATAACK  ||
+	       type == DCCP_PKT_REQUEST  ||
+	       type == DCCP_PKT_RESPONSE;
+}
+
 static inline int dccp_packet_without_ack(const struct sk_buff *skb)
 {
 	const __u8 type = DCCP_SKB_CB(skb)->dccpd_type;

commit e356d37a096a990ea1a74c44c15640122e56110b
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Sep 26 14:35:19 2007 -0300

    [DCCP]: Factor out common code for generating Resets
    
    This factors code common to dccp_v{4,6}_ctl_send_reset into a separate function,
    and adds support for filling in the Data 1 ... Data 3 fields from RFC 4340, 5.6.
    
    It is useful to have this separate, since the following Reset codes will always
    be generated from the control socket rather than via dccp_send_reset:
     * Code 3, "No Connection", cf. 8.3.1;
     * Code 4, "Packet Error" (identification for Data 1 added);
     * Code 5, "Option Error" (identification for Data 1..3 added, will be used later);
     * Code 6, "Mandatory Error" (same as Option Error);
     * Code 7, "Connection Refused" (what on Earth is the difference to "No Connection"?);
     * Code 8, "Bad Service Code";
     * Code 9, "Too Busy";
     * Code 10, "Bad Init Cookie" (not used).
    
    Code 0 is not recommended by the RFC, the following codes would be used in
    dccp_send_reset() instead, since they all relate to an established DCCP connection:
     * Code 1, "Closed";
     * Code 2, "Aborted";
     * Code 11, "Aggression Penalty" (12.3).
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index a602d9212c64..ee97950d77d1 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -294,6 +294,8 @@ extern unsigned int dccp_poll(struct file *file, struct socket *sock,
 extern int	   dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr,
 				   int addr_len);
 
+extern struct sk_buff *dccp_ctl_make_reset(struct socket *ctl,
+					   struct sk_buff *skb);
 extern int	   dccp_send_reset(struct sock *sk, enum dccp_reset_codes code);
 extern void	   dccp_send_close(struct sock *sk, const int active);
 extern int	   dccp_invalid_packet(struct sk_buff *skb);

commit a94f0f970549e63e54c80c4509db299c514d8c11
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Sep 26 11:31:49 2007 -0300

    [DCCP]: Rate-limit DCCP-Syncs
    
    This implements a SHOULD from RFC 4340, 7.5.4:
     "To protect against denial-of-service attacks, DCCP implementations SHOULD
      impose a rate limit on DCCP-Syncs sent in response to sequence-invalid packets,
      such as not more than eight DCCP-Syncs per second."
    
    The rate-limit is maintained on a per-socket basis. This is a more stringent
    policy than enforcing the rate-limit on a per-source-address basis and
    protects against attacks with forged source addresses.
    
    Moreover, the mechanism is deliberately kept simple. In contrast to
    xrlim_allow(), bursts of Sync packets in reply to sequence-invalid packets
    are not supported.  This foils such attacks where the receipt of a Sync
    triggers further sequence-invalid packets. (I have tested this mechanism against
    xrlim_allow algorithm for Syncs, permitting bursts just increases the problems.)
    
    In order to keep flexibility, the timeout parameter can be set via sysctl; and
    the whole mechanism can even be disabled (which is however not recommended).
    
    The algorithm in this patch has been improved with regard to wrapping issues
    thanks to a suggestion by Arnaldo.
    
    Commiter note: Rate limited the step 6 DCCP_WARN too, as it says we're
                   sending a sync.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e28220183208..a602d9212c64 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -92,6 +92,7 @@ extern int  sysctl_dccp_feat_ack_ratio;
 extern int  sysctl_dccp_feat_send_ack_vector;
 extern int  sysctl_dccp_feat_send_ndp_count;
 extern int  sysctl_dccp_tx_qlen;
+extern int  sysctl_dccp_sync_ratelimit;
 
 /*
  *	48-bit sequence number arithmetic (signed and unsigned)

commit 0430ee3451f4589b68f522552b1896825f2043b3
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Sep 26 11:27:56 2007 -0300

    [DCCP]: Add Support for Data 1 .. 3 fields of Reset packets
    
    This adds fields to support the informational Data 1..3 fields of the
    DCCP-Reset packets (RFC 4340, 5.6), and makes minor cosmetic changes
    to documentation.
    Code which fills in these fields follows in subsequent patches, it is
    primarily used for reporting option-processing and feature-negotiation
    errors.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index f62eeb374931..e28220183208 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -308,10 +308,22 @@ static inline int dccp_bad_service_code(const struct sock *sk,
 	return !dccp_list_has_service(dp->dccps_service_list, service);
 }
 
+/**
+ * dccp_skb_cb  -  DCCP per-packet control information
+ * @dccpd_type: one of %dccp_pkt_type (or unknown)
+ * @dccpd_ccval: CCVal field (5.1), see e.g. RFC 4342, 8.1
+ * @dccpd_reset_code: one of %dccp_reset_codes
+ * @dccpd_reset_data: Data1..3 fields (depend on @dccpd_reset_code)
+ * @dccpd_opt_len: total length of all options (5.8) in the packet
+ * @dccpd_seq: sequence number
+ * @dccpd_ack_seq: acknowledgment number subheader field value
+ * This is used for transmission as well as for reception.
+ */
 struct dccp_skb_cb {
 	__u8  dccpd_type:4;
 	__u8  dccpd_ccval:4;
-	__u8  dccpd_reset_code;
+	__u8  dccpd_reset_code,
+	      dccpd_reset_data[3];
 	__u16 dccpd_opt_len;
 	__u64 dccpd_seq;
 	__u64 dccpd_ack_seq;

commit 727ecc5faaf6e976fc841649821c865ebd1e822d
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Sep 26 11:26:04 2007 -0300

    [DCCP]: Add FIXME for send_delayed_ack
    
    This adds a FIXME to signal that the function dccp_send_delayed_ack is nowhere
    used in the entire DCCP/CCID code.
    
    Using a delayed Ack timer is suggested in 11.3 of RFC 4340, but it has also
    rather subtle implications for the Ack-Ratio-accounting.
    
    CCID2 does not use this (maybe it should).
    
    I think leaving the function in is good, in case someone wants to implement
    this.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index bd4645b3a36c..f62eeb374931 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -209,7 +209,6 @@ extern void dccp_v4_send_check(struct sock *sk, int len, struct sk_buff *skb);
 extern int  dccp_retransmit_skb(struct sock *sk, struct sk_buff *skb);
 
 extern void dccp_send_ack(struct sock *sk);
-extern void dccp_send_delayed_ack(struct sock *sk);
 extern void dccp_reqsk_send_ack(struct sk_buff *sk, struct request_sock *rsk);
 
 extern void dccp_send_sync(struct sock *sk, const u64 seq,

commit 3393da8241ae3a53e183ba15f8bd822995ec97cd
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Sep 25 22:40:44 2007 -0700

    [DCCP]: Simplify interface of dccp_sample_rtt
    
    The third parameter of dccp_sample_rtt now becomes useless and is removed.
    
    Also combined the subtraction of the timestamp echo and the elapsed time.
    This is safe, since (a) presence of timestamp echo is tested first and (b)
    elapsed time is either present and non-zero or it is not set and equals 0
    due to the memset in dccp_parse_options.
    
    To avoid measuring option-processing time, the timestamp for measuring the
    initial Request/Response RTT sample is taken directly when the function is
    called (the Linux implementation always adds a timestamp on the Request,
    so there is no loss in doing this).
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index a75c740ae6c0..bd4645b3a36c 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -297,8 +297,7 @@ extern int	   dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr,
 extern int	   dccp_send_reset(struct sock *sk, enum dccp_reset_codes code);
 extern void	   dccp_send_close(struct sock *sk, const int active);
 extern int	   dccp_invalid_packet(struct sk_buff *skb);
-extern u32	   dccp_sample_rtt(struct sock *sk, ktime_t t_recv,
-				   ktime_t *t_history);
+extern u32	   dccp_sample_rtt(struct sock *sk, long delta);
 
 static inline int dccp_bad_service_code(const struct sock *sk,
 					const __be32 service)

commit 4c70f383e0c0273c4092c4efdb414be0966978b7
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Sep 25 22:40:13 2007 -0700

    [DCCP]: Provide 10s of microsecond timesource
    
    This provides a timesource, conveniently used for DCCP timestamps, which
    returns the elapsed time in 10s of microseconds since initialisation.
    This makes for a wrap-around time of about 11.9 hours, which should be
    sufficient for most applications.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index ddacc23be5e8..a75c740ae6c0 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -396,6 +396,8 @@ extern int dccp_insert_options(struct sock *sk, struct sk_buff *skb);
 extern int dccp_insert_option_elapsed_time(struct sock *sk,
 					    struct sk_buff *skb,
 					    u32 elapsed_time);
+extern u32 dccp_timestamp(void);
+extern void dccp_timestamping_init(void);
 extern int dccp_insert_option_timestamp(struct sock *sk,
 					 struct sk_buff *skb);
 extern int dccp_insert_option(struct sock *sk, struct sk_buff *skb,

commit 6168b96c07d8d40f83622cfb488ca27e4178a603
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Sun Aug 19 17:19:44 2007 -0700

    [DCCP]: Nuke the timeval helpers now that we fully converted to ktime_t
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 6fbe293bb271..ddacc23be5e8 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -402,45 +402,6 @@ extern int dccp_insert_option(struct sock *sk, struct sk_buff *skb,
 			       unsigned char option,
 			       const void *value, unsigned char len);
 
-static inline suseconds_t timeval_usecs(const struct timeval *tv)
-{
-	return tv->tv_sec * USEC_PER_SEC + tv->tv_usec;
-}
-
-static inline suseconds_t timeval_delta(const struct timeval *large,
-					const struct timeval *small)
-{
-	time_t	    secs  = large->tv_sec  - small->tv_sec;
-	suseconds_t usecs = large->tv_usec - small->tv_usec;
-
-	if (usecs < 0) {
-		secs--;
-		usecs += USEC_PER_SEC;
-	}
-	return secs * USEC_PER_SEC + usecs;
-}
-
-static inline void timeval_add_usecs(struct timeval *tv,
-				     const suseconds_t usecs)
-{
-	tv->tv_usec += usecs;
-	while (tv->tv_usec >= USEC_PER_SEC) {
-		tv->tv_sec++;
-		tv->tv_usec -= USEC_PER_SEC;
-	}
-}
-
-static inline void timeval_sub_usecs(struct timeval *tv,
-				     const suseconds_t usecs)
-{
-	tv->tv_usec -= usecs;
-	while (tv->tv_usec < 0) {
-		tv->tv_sec--;
-		tv->tv_usec += USEC_PER_SEC;
-	}
-	DCCP_BUG_ON(tv->tv_sec < 0);
-}
-
 #ifdef CONFIG_SYSCTL
 extern int dccp_sysctl_init(void);
 extern void dccp_sysctl_exit(void);

commit 8fb8354af9b92ce3bd41083995f1fe26024d0959
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Sun Aug 19 17:19:21 2007 -0700

    [DCCP]: Nuke dccp_timestamp and dccps_epoch, not used anymore
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 20a7bedfe996..6fbe293bb271 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -402,8 +402,6 @@ extern int dccp_insert_option(struct sock *sk, struct sk_buff *skb,
 			       unsigned char option,
 			       const void *value, unsigned char len);
 
-extern void dccp_timestamp(const struct sock *sk, struct timeval *tv);
-
 static inline suseconds_t timeval_usecs(const struct timeval *tv)
 {
 	return tv->tv_sec * USEC_PER_SEC + tv->tv_usec;

commit 9823b7b5542858afe5b6a1e2df83b3847c28f3d6
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Sun Aug 19 17:16:35 2007 -0700

    [DCCP]: Convert dccp_sample_rtt to ktime_t
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e2d74cd7eeeb..20a7bedfe996 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -13,6 +13,7 @@
  */
 
 #include <linux/dccp.h>
+#include <linux/ktime.h>
 #include <net/snmp.h>
 #include <net/sock.h>
 #include <net/tcp.h>
@@ -296,8 +297,8 @@ extern int	   dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr,
 extern int	   dccp_send_reset(struct sock *sk, enum dccp_reset_codes code);
 extern void	   dccp_send_close(struct sock *sk, const int active);
 extern int	   dccp_invalid_packet(struct sk_buff *skb);
-extern u32	   dccp_sample_rtt(struct sock *sk, struct timeval *t_recv,
-						    struct timeval *t_history);
+extern u32	   dccp_sample_rtt(struct sock *sk, ktime_t t_recv,
+				   ktime_t *t_history);
 
 static inline int dccp_bad_service_code(const struct sock *sk,
 					const __be32 service)

commit e961811fcde4202ae5c3c9ce81dcfc244e8959bb
Author: Ian McDonald <ian.mcdonald@jandi.co.nz>
Date:   Mon May 28 16:32:26 2007 -0300

    Fix dccp_sum_coverage
    
    When compiling with EXTRA_CFLAGS=-W notice that we have signed/unsigned issue
    in dccp.h.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index d8ad27bfe01a..e2d74cd7eeeb 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -184,7 +184,7 @@ DECLARE_SNMP_STAT(struct dccp_mib, dccp_statistics);
 /*
  * 	Checksumming routines
  */
-static inline int dccp_csum_coverage(const struct sk_buff *skb)
+static inline unsigned int dccp_csum_coverage(const struct sk_buff *skb)
 {
 	const struct dccp_hdr* dh = dccp_hdr(skb);
 
@@ -195,7 +195,7 @@ static inline int dccp_csum_coverage(const struct sk_buff *skb)
 
 static inline void dccp_csum_outgoing(struct sk_buff *skb)
 {
-	int cov = dccp_csum_coverage(skb);
+	unsigned int cov = dccp_csum_coverage(skb);
 
 	if (cov >= skb->len)
 		dccp_hdr(skb)->dccph_cscov = 0;

commit 4712a792ee661921374c163eb6a4d06e33fd305f
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Mar 20 15:23:18 2007 -0300

    [DCCP]: Provide function for RTT sampling
    
    A recurring problem, in particular in the CCID code, is that RTT samples
    from packets with timestamp echo and elapsed time options need to be taken.
    
    This service is provided via a new function dccp_sample_rtt in this patch.
    Furthermore, to protect against `insane' RTT samples, the sampled value
    is bounded between 100 microseconds and 4 seconds - for which u32 is sufficient.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 292f18ef4f61..d8ad27bfe01a 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -71,11 +71,15 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 /* RFC 1122, 4.2.3.1 initial RTO value */
 #define DCCP_TIMEOUT_INIT ((unsigned)(3 * HZ))
 
+#define DCCP_RTO_MAX ((unsigned)(120 * HZ)) /* FIXME: using TCP value */
+
+/* bounds for sampled RTT values from packet exchanges (in usec) */
+#define DCCP_SANE_RTT_MIN	100
+#define DCCP_SANE_RTT_MAX	(4 * USEC_PER_SEC)
+
 /* Maximal interval between probes for local resources.  */
 #define DCCP_RESOURCE_PROBE_INTERVAL ((unsigned)(HZ / 2U))
 
-#define DCCP_RTO_MAX ((unsigned)(120 * HZ)) /* FIXME: using TCP value */
-
 /* sysctl variables for DCCP */
 extern int  sysctl_dccp_request_retries;
 extern int  sysctl_dccp_retries1;
@@ -292,6 +296,8 @@ extern int	   dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr,
 extern int	   dccp_send_reset(struct sock *sk, enum dccp_reset_codes code);
 extern void	   dccp_send_close(struct sock *sk, const int active);
 extern int	   dccp_invalid_packet(struct sk_buff *skb);
+extern u32	   dccp_sample_rtt(struct sock *sk, struct timeval *t_recv,
+						    struct timeval *t_history);
 
 static inline int dccp_bad_service_code(const struct sock *sk,
 					const __be32 service)

commit ac12b0c49571fe4c3a2f4957ed494da316d558be
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Mar 20 14:59:23 2007 -0300

    [DCCP]: Always use debug-toggle parameters
    
    Currently debugging output (when configured) is automatically enabled when
    DCCP modules are compiled into the kernel rather than built as loadable modules.
    This is not necessary, since the module parameters in this case become kernel
    commandline parameters, e.g. DCCP or CCID3 debug output can be enabled for a
    static build by appending the following at the boot prompt:
    
            dccp.dccp_debug=1       dccp_ccid3.ccid3_debug=1
    
    This patch therefore does away with the more complicated way of always enabling
    debug output for static builds
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index c66a4581348f..292f18ef4f61 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -31,13 +31,9 @@
 					      __stringify(cond));          \
 			     } while (0)
 
-#ifdef MODULE
 #define DCCP_PRINTK(enable, fmt, args...)	do { if (enable)	     \
 							printk(fmt, ##args); \
 						} while(0)
-#else
-#define DCCP_PRINTK(enable, fmt, args...)	printk(fmt, ##args)
-#endif
 #define DCCP_PR_DEBUG(enable, fmt, a...)	DCCP_PRINTK(enable, KERN_DEBUG \
 						  "%s: " fmt, __FUNCTION__, ##a)
 

commit b16be51b5e5d75cec71b18ebc75f15a4734c62ad
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Mar 20 13:03:47 2007 -0300

    [DCCP]: Fix for follows48
    
    The follows48 relation identifies whether 48-bit sequence number
    x is the direct successor of y. Currently, it does not handle cases
    of the following type correctly:
    
            follows48(0x(prefix)10000LL, 0x(prefix)0FFFFLL)
    
    where prefix is an arbitrary hex sequence of up to 7 digits.
    
    This is fixed by reusing the new dccp_delta_seqno function.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 1615986a8d92..c66a4581348f 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -144,9 +144,7 @@ static inline u64 max48(const u64 seq1, const u64 seq2)
 /* is seq1 next seqno after seq2 */
 static inline int follows48(const u64 seq1, const u64 seq2)
 {
-	int diff = (seq1 & 0xFFFF) - (seq2 & 0xFFFF);
-
-	return diff==1;
+	return dccp_delta_seqno(seq2, seq1) == 1;
 }
 
 enum {

commit d52de17b8cf36d43a9d6977e7861a9f415541c6b
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Mar 20 13:00:26 2007 -0300

    [DCCP]: Make `before' relation unambiguous
    
    Problem:

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index afb313ff216e..1615986a8d92 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -124,14 +124,11 @@ static inline s64 dccp_delta_seqno(const u64 seqno1, const u64 seqno2)
 /* is seq1 < seq2 ? */
 static inline int before48(const u64 seq1, const u64 seq2)
 {
-	return (s64)((seq1 << 16) - (seq2 << 16)) < 0;
+	return (s64)((seq2 << 16) - (seq1 << 16)) > 0;
 }
 
 /* is seq1 > seq2 ? */
-static inline int after48(const u64 seq1, const u64 seq2)
-{
-	return (s64)((seq2 << 16) - (seq1 << 16)) < 0;
-}
+#define after48(seq1, seq2)	before48(seq2, seq1)
 
 /* is seq2 <= seq1 <= seq3 ? */
 static inline int between48(const u64 seq1, const u64 seq2, const u64 seq3)

commit 0aec51c86986f61de26dd04913667af544a8b8eb
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Mar 20 12:45:59 2007 -0300

    [DCCP]: Make dccp_delta_seqno return signed numbers
    
    Problem:

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index a2c20a265b25..afb313ff216e 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -113,9 +113,12 @@ static inline void dccp_inc_seqno(u64 *seqno)
 	*seqno = ADD48(*seqno, 1);
 }
 
-static inline u64 dccp_delta_seqno(u64 seqno1, u64 seqno2)
+/* signed mod-2^48 distance: pos. if seqno1 < seqno2, neg. if seqno1 > seqno2 */
+static inline s64 dccp_delta_seqno(const u64 seqno1, const u64 seqno2)
 {
-	return ((seqno2 << 16) - (seqno1 << 16)) >> 16;
+	u64 delta = SUB48(seqno2, seqno1);
+
+	return TO_SIGNED48(delta);
 }
 
 /* is seq1 < seq2 ? */

commit 6b811d43f6cc9eccdfc011a99f8571df2abc46d1
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Mar 20 12:26:51 2007 -0300

    [DCCP]: 48-bit sequence number arithmetic
    
    This patch
     * organizes the sequence arithmetic functions into one corner of dccp.h
     * performs a small modification of dccp_set_seqno to make it more widely reusable
       (now it is safe to use any number, since it performs modulo-2^48 assignment)
     * adds functions and generic macros for 48-bit sequence arithmetic:
            --48 bit complement
            --modulo-48 addition and modulo-48 subtraction
            --dccp_inc_seqno now a special case of add48
    Constants renamed following a suggestion by Arnaldo.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e33a9edb4036..a2c20a265b25 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -92,6 +92,32 @@ extern int  sysctl_dccp_feat_send_ack_vector;
 extern int  sysctl_dccp_feat_send_ndp_count;
 extern int  sysctl_dccp_tx_qlen;
 
+/*
+ *	48-bit sequence number arithmetic (signed and unsigned)
+ */
+#define INT48_MIN	  0x800000000000LL		/* 2^47	    */
+#define UINT48_MAX	  0xFFFFFFFFFFFFLL		/* 2^48 - 1 */
+#define COMPLEMENT48(x)	 (0x1000000000000LL - (x))	/* 2^48 - x */
+#define TO_SIGNED48(x)	 (((x) < INT48_MIN)? (x) : -COMPLEMENT48( (x)))
+#define TO_UNSIGNED48(x) (((x) >= 0)?	     (x) :  COMPLEMENT48(-(x)))
+#define ADD48(a, b)	 (((a) + (b)) & UINT48_MAX)
+#define SUB48(a, b)	 ADD48((a), COMPLEMENT48(b))
+
+static inline void dccp_set_seqno(u64 *seqno, u64 value)
+{
+	*seqno = value & UINT48_MAX;
+}
+
+static inline void dccp_inc_seqno(u64 *seqno)
+{
+	*seqno = ADD48(*seqno, 1);
+}
+
+static inline u64 dccp_delta_seqno(u64 seqno1, u64 seqno2)
+{
+	return ((seqno2 << 16) - (seqno1 << 16)) >> 16;
+}
+
 /* is seq1 < seq2 ? */
 static inline int before48(const u64 seq1, const u64 seq2)
 {
@@ -313,26 +339,7 @@ static inline int dccp_packet_without_ack(const struct sk_buff *skb)
 	return type == DCCP_PKT_DATA || type == DCCP_PKT_REQUEST;
 }
 
-#define DCCP_MAX_SEQNO ((((u64)1) << 48) - 1)
-#define DCCP_PKT_WITHOUT_ACK_SEQ (DCCP_MAX_SEQNO << 2)
-
-static inline void dccp_set_seqno(u64 *seqno, u64 value)
-{
-	if (value > DCCP_MAX_SEQNO)
-		value -= DCCP_MAX_SEQNO + 1;
-	*seqno = value;
-}
-
-static inline u64 dccp_delta_seqno(u64 seqno1, u64 seqno2)
-{
-	return ((seqno2 << 16) - (seqno1 << 16)) >> 16;
-}
-
-static inline void dccp_inc_seqno(u64 *seqno)
-{
-	if (++*seqno > DCCP_MAX_SEQNO)
-		*seqno = 0;
-}
+#define DCCP_PKT_WITHOUT_ACK_SEQ (UINT48_MAX << 2)
 
 static inline void dccp_hdr_set_seq(struct dccp_hdr *dh, const u64 gss)
 {

commit c93a882ebe673b5e6da0a70fd433f7517e032d23
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat Mar 24 21:01:31 2007 -0700

    [DCCP]: make dccp_write_xmit_timer() static again
    
    dccp_write_xmit_timer() needlessly became global.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index a0e7cd183a5d..e33a9edb4036 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -191,7 +191,6 @@ extern void dccp_send_sync(struct sock *sk, const u64 seq,
 			   const enum dccp_pkt_type pkt_type);
 
 extern void dccp_write_xmit(struct sock *sk, int block);
-extern void dccp_write_xmit_timer(unsigned long data);
 extern void dccp_write_space(struct sock *sk);
 
 extern void dccp_init_xmit_timers(struct sock *sk);

commit aabb601b0f08b909b650f1a7bfa1e8d9b5a8d999
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Mar 9 13:47:58 2007 -0800

    [DCCP]: Initialise write_xmit_timer also on passive sockets
    
    The TX CCID needs the write_xmit_timer for delaying packet sends. Previously
    this timer was only activated on active (connecting) sockets.
    
    This patch initialises the write_xmit_timer in sync with the other timers, i.e.
    the timer will be ready on any socket. This is used by applications with a
    listening socket which start to stream after receiving an initiation by the
    client.  The write_xmit_timer is stopped when the application closes, as before.
    
    Was tested to work and to remove the timer bug reported on dccp@vger.
    
    Also moved timer initialisation into timer.c (static).
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e33a9edb4036..a0e7cd183a5d 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -191,6 +191,7 @@ extern void dccp_send_sync(struct sock *sk, const u64 seq,
 			   const enum dccp_pkt_type pkt_type);
 
 extern void dccp_write_xmit(struct sock *sk, int block);
+extern void dccp_write_xmit_timer(unsigned long data);
 extern void dccp_write_space(struct sock *sk);
 
 extern void dccp_init_xmit_timers(struct sock *sk);

commit c9eaf17341834de00351bf79f16b2d879c8aea96
Author: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
Date:   Fri Feb 9 23:24:38 2007 +0900

    [NET] DCCP: Fix whitespace errors.
    
    Signed-off-by: YOSHIFUJI Hideaki <yoshfuji@linux-ipv6.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index a0900bf98e6b..e33a9edb4036 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -22,7 +22,7 @@
  * 	DCCP - specific warning and debugging macros.
  */
 #define DCCP_WARN(fmt, a...) LIMIT_NETDEBUG(KERN_WARNING "%s: " fmt,       \
-						        __FUNCTION__, ##a)
+							__FUNCTION__, ##a)
 #define DCCP_CRIT(fmt, a...) printk(KERN_CRIT fmt " at %s:%d/%s()\n", ##a, \
 					 __FILE__, __LINE__, __FUNCTION__)
 #define DCCP_BUG(a...)       do { DCCP_CRIT("BUG: " a); dump_stack(); } while(0)
@@ -34,7 +34,7 @@
 #ifdef MODULE
 #define DCCP_PRINTK(enable, fmt, args...)	do { if (enable)	     \
 							printk(fmt, ##args); \
-					 	} while(0)
+						} while(0)
 #else
 #define DCCP_PRINTK(enable, fmt, args...)	printk(fmt, ##args)
 #endif
@@ -128,7 +128,7 @@ enum {
 	DCCP_MIB_ACTIVEOPENS,			/* ActiveOpens */
 	DCCP_MIB_ESTABRESETS,			/* EstabResets */
 	DCCP_MIB_CURRESTAB,			/* CurrEstab */
-	DCCP_MIB_OUTSEGS,			/* OutSegs */ 
+	DCCP_MIB_OUTSEGS,			/* OutSegs */
 	DCCP_MIB_OUTRSTS,
 	DCCP_MIB_ABORTONTIMEOUT,
 	DCCP_MIB_TIMEOUTS,
@@ -372,7 +372,7 @@ static inline void dccp_update_gss(struct sock *sk, u64 seq)
 		       (dp->dccps_gss -
 			dccp_msk(sk)->dccpms_sequence_window + 1));
 }
-				
+
 static inline int dccp_ack_pending(const struct sock *sk)
 {
 	const struct dccp_sock *dp = dccp_sk(sk);

commit 0f9e5b573f7249b0e04a03457b55081d1f60f2bf
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Sun Dec 10 00:03:51 2006 -0200

    [DCCP]: Debug timeval operations
    
    Problem:
    
     Most target types in the CCID3 code are u32, so subtle conversion errors
     can occur if signed time calculations yield negative results: the original
     values are lost in the conversion to unsigned, calculation errors go undetected.
    
     This patch therefore
       * sets all critical time types from unsigned to suseconds_t
       * avoids comparison between signed/unsigned via type-casting
       * provides ample warning messages in case time calculations are negative
    
     These warning messages can be removed at a later stage when the code
     has undergone more testing.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Acked-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 44829d636c93..a0900bf98e6b 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -432,6 +432,7 @@ static inline void timeval_sub_usecs(struct timeval *tv,
 		tv->tv_sec--;
 		tv->tv_usec += USEC_PER_SEC;
 	}
+	DCCP_BUG_ON(tv->tv_sec < 0);
 }
 
 #ifdef CONFIG_SYSCTL

commit 5cc3741d6cc9f07d8ddd9c45cb5088460ce3364f
Author: Ian McDonald <ian.mcdonald@jandi.co.nz>
Date:   Sat Dec 9 23:56:09 2006 -0200

    [DCCP]: Remove timeo from output.c
    
    It simplifies waiting for the CCID module to signal that a packet
    is ready to be sent.  Other simplifications flow on from this such as
    removing constants.
    
    As a result of this EAGAIN is not returned any more by dccp_wait_for_ccid
    (which would otherwise lead to unnecessarily discarding the packet in
    dccp_write_xmit).
    
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 68886986c8e4..44829d636c93 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -80,8 +80,6 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 
 #define DCCP_RTO_MAX ((unsigned)(120 * HZ)) /* FIXME: using TCP value */
 
-#define DCCP_XMIT_TIMEO 30000 /* Time/msecs for blocking transmit per packet */
-
 /* sysctl variables for DCCP */
 extern int  sysctl_dccp_request_retries;
 extern int  sysctl_dccp_retries1;

commit 59348b19efebfd6a8d0791ff81d207b16594c94b
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Nov 20 18:39:23 2006 -0200

    [DCCP]: Simplified conditions due to use of enum:8 states
    
    This reaps the benefit of the earlier patch, which changed the type of
    CCID 3 states to use enums, in that many conditions are now simplified
    and the number of possible (unexpected) values is greatly reduced.
    
    In a few instances, this also allowed to simplify pre-conditions; where
    care has been taken to retain logical equivalence.
    
    [DCCP]: Introduce a consistent BUG/WARN message scheme
    
    This refines the existing set of DCCP messages so that
     * BUG(), BUG_ON(), WARN_ON() have meaningful DCCP-specific counterparts
     * DCCP_CRIT (for severe warnings) is not rate-limited
     * DCCP_WARN() is introduced as rate-limited wrapper
    
    Using these allows a faster and cleaner transition to their original
    counterparts once the code has matured into a full DCCP implementation.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 3a94625a1af3..68886986c8e4 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -18,12 +18,17 @@
 #include <net/tcp.h>
 #include "ackvec.h"
 
-#define DCCP_CRIT(fmt, a...) LIMIT_NETDEBUG(KERN_CRIT fmt " at %s:%d/%s()\n",  \
- 					 ##a, __FILE__, __LINE__, __FUNCTION__)
-#define DCCP_BUG(fmt, a...)  do { DCCP_CRIT(fmt, ##a); dump_stack(); } while (0)
-#define DCCP_BUG_ON(cond)    do { if (unlikely((cond) == 0))                   \
-					DCCP_BUG("BUG: condition \"%s\" fails",\
-						 __stringify((cond)));	       \
+/*
+ * 	DCCP - specific warning and debugging macros.
+ */
+#define DCCP_WARN(fmt, a...) LIMIT_NETDEBUG(KERN_WARNING "%s: " fmt,       \
+						        __FUNCTION__, ##a)
+#define DCCP_CRIT(fmt, a...) printk(KERN_CRIT fmt " at %s:%d/%s()\n", ##a, \
+					 __FILE__, __LINE__, __FUNCTION__)
+#define DCCP_BUG(a...)       do { DCCP_CRIT("BUG: " a); dump_stack(); } while(0)
+#define DCCP_BUG_ON(cond)    do { if (unlikely((cond) != 0))		   \
+				     DCCP_BUG("\"%s\" holds (exception!)", \
+					      __stringify(cond));          \
 			     } while (0)
 
 #ifdef MODULE

commit b1308dc015eb09cf094ca169296738a13ae049ad
Author: Ian McDonald <ian.mcdonald@jandi.co.nz>
Date:   Mon Nov 20 18:30:17 2006 -0200

    [DCCP]: Set TX Queue Length Bounds via Sysctl
    
    Previously the transmit queue was unbounded.
    
    This patch:
            * puts a limit on transmit queue length
              and sends back EAGAIN if the buffer is full
            * sets the TX queue length to a sensible default
            * implements tx buffer sysctls for DCCP
    
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 33d86f53138b..3a94625a1af3 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -87,6 +87,7 @@ extern int  sysctl_dccp_feat_tx_ccid;
 extern int  sysctl_dccp_feat_ack_ratio;
 extern int  sysctl_dccp_feat_send_ack_vector;
 extern int  sysctl_dccp_feat_send_ndp_count;
+extern int  sysctl_dccp_tx_qlen;
 
 /* is seq1 < seq2 ? */
 static inline int before48(const u64 seq1, const u64 seq2)

commit 84116716cc9404356f775443b460f76766f08f65
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Nov 20 18:26:03 2006 -0200

    [DCCP]: enable debug messages also for static builds
    
    This patch
      * makes debugging (when configured) work both for static / module build
      * provides generic debugging macros for use in other DCCP / CCID modules
      * adds missing information about debug parameters to Kconfig
      * performs some code tidy-up
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index ecb4e7bd1a84..33d86f53138b 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -26,15 +26,20 @@
 						 __stringify((cond)));	       \
 			     } while (0)
 
+#ifdef MODULE
+#define DCCP_PRINTK(enable, fmt, args...)	do { if (enable)	     \
+							printk(fmt, ##args); \
+					 	} while(0)
+#else
+#define DCCP_PRINTK(enable, fmt, args...)	printk(fmt, ##args)
+#endif
+#define DCCP_PR_DEBUG(enable, fmt, a...)	DCCP_PRINTK(enable, KERN_DEBUG \
+						  "%s: " fmt, __FUNCTION__, ##a)
+
 #ifdef CONFIG_IP_DCCP_DEBUG
 extern int dccp_debug;
-
-#define dccp_pr_debug(format, a...) \
-	do { if (dccp_debug) \
-		printk(KERN_DEBUG "%s: " format, __FUNCTION__ , ##a); \
-	} while (0)
-#define dccp_pr_debug_cat(format, a...) do { if (dccp_debug) \
-					     printk(format, ##a); } while (0)
+#define dccp_pr_debug(format, a...)	  DCCP_PR_DEBUG(dccp_debug, format, ##a)
+#define dccp_pr_debug_cat(format, a...)   DCCP_PRINTK(dccp_debug, format, ##a)
 #else
 #define dccp_pr_debug(format, a...)
 #define dccp_pr_debug_cat(format, a...)

commit 3c6952624a8f600f9a0fbc1f5db5560a7ef9b13e
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Wed Nov 15 21:27:47 2006 -0200

    [DCCP]: Introduce DCCP_{BUG{_ON},CRIT} macros, use enum:8 for the ccid3 states
    
    This patch tackles the following problem:
           * the ccid3_hc_{t,r}x_sock define ccid3hc{t,r}x_state as `u8', but
             in reality there can only be a few, pre-defined enum names
           * this necessitates addiditional checking for unexpected values
             which would otherwise be caught by the compiler
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 363fa520056e..ecb4e7bd1a84 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -18,6 +18,14 @@
 #include <net/tcp.h>
 #include "ackvec.h"
 
+#define DCCP_CRIT(fmt, a...) LIMIT_NETDEBUG(KERN_CRIT fmt " at %s:%d/%s()\n",  \
+ 					 ##a, __FILE__, __LINE__, __FUNCTION__)
+#define DCCP_BUG(fmt, a...)  do { DCCP_CRIT(fmt, ##a); dump_stack(); } while (0)
+#define DCCP_BUG_ON(cond)    do { if (unlikely((cond) == 0))                   \
+					DCCP_BUG("BUG: condition \"%s\" fails",\
+						 __stringify((cond)));	       \
+			     } while (0)
+
 #ifdef CONFIG_IP_DCCP_DEBUG
 extern int dccp_debug;
 

commit afb0a34dd3e20b3f534de19993271b8664cf10bb
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Nov 13 13:25:41 2006 -0200

    [DCCP]: Introduce a consistent naming scheme for sysctls
    
    In order to make their function clearer and obtain a consistent naming
    scheme to identify sysctls, all existing DCCP sysctls have been prefixed
    with `sysctl_dccp', following the same convention as used by TCP.
    
    Feature-specific sysctls retain the `feat' in the middle, although the
    `default' has been dropped, since it is obvious from use.
    
    Also removed a duplicate `dccp_feat_default_sequence_window' in ipv4.c.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e7b96074a1b1..363fa520056e 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -68,12 +68,12 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 extern int  sysctl_dccp_request_retries;
 extern int  sysctl_dccp_retries1;
 extern int  sysctl_dccp_retries2;
-extern int  dccp_feat_default_sequence_window;
-extern int  dccp_feat_default_rx_ccid;
-extern int  dccp_feat_default_tx_ccid;
-extern int  dccp_feat_default_ack_ratio;
-extern int  dccp_feat_default_send_ack_vector;
-extern int  dccp_feat_default_send_ndp_count;
+extern int  sysctl_dccp_feat_sequence_window;
+extern int  sysctl_dccp_feat_rx_ccid;
+extern int  sysctl_dccp_feat_tx_ccid;
+extern int  sysctl_dccp_feat_ack_ratio;
+extern int  sysctl_dccp_feat_send_ack_vector;
+extern int  sysctl_dccp_feat_send_ndp_count;
 
 /* is seq1 < seq2 ? */
 static inline int before48(const u64 seq1, const u64 seq2)

commit 2e2e9e92bd723244ea20fa488b1780111f2b05e1
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Mon Nov 13 13:23:52 2006 -0200

    [DCCP]: Add sysctls to control retransmission behaviour
    
    This adds 3 sysctls which govern the retransmission behaviour of DCCP control
    packets (3way handshake, feature negotiation).
    
    It removes 4 FIXMEs from the code.
    
    The close resemblance of sysctl variables to their TCP analogues is emphasised
    not only by their name, but also by giving them the same initial values.
    This is useful since there is not much practical experience with DCCP yet.
    
    Furthermore, with regard to the previous patch, it is now possible to limit
    the number of keepalive-Responses by setting net.dccp.default.request_retries
    (also a bit like in TCP).
    
    Lastly, added documentation of all existing DCCP sysctls.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index d5c414bf7819..e7b96074a1b1 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -64,6 +64,17 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 
 #define DCCP_XMIT_TIMEO 30000 /* Time/msecs for blocking transmit per packet */
 
+/* sysctl variables for DCCP */
+extern int  sysctl_dccp_request_retries;
+extern int  sysctl_dccp_retries1;
+extern int  sysctl_dccp_retries2;
+extern int  dccp_feat_default_sequence_window;
+extern int  dccp_feat_default_rx_ccid;
+extern int  dccp_feat_default_tx_ccid;
+extern int  dccp_feat_default_ack_ratio;
+extern int  dccp_feat_default_send_ack_vector;
+extern int  dccp_feat_default_send_ndp_count;
+
 /* is seq1 < seq2 ? */
 static inline int before48(const u64 seq1, const u64 seq2)
 {

commit 6f4e5fff1e4d46714ea554fd83e44eab534e8b11
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Nov 10 17:43:06 2006 -0200

    [DCCP]: Support for partial checksums (RFC 4340, sec. 9.2)
    
    This patch does the following:
      a) introduces variable-length checksums as specified in [RFC 4340, sec. 9.2]
      b) provides necessary socket options and documentation as to how to use them
      c) basic support and infrastructure for the Minimum Checksum Coverage feature
         [RFC 4340, sec. 9.2.1]: acceptability tests, user notification and user
         interface
    
    In addition, it
    
     (1) fixes two bugs in the DCCPv4 checksum computation:
            * pseudo-header used checksum_len instead of skb->len
            * incorrect checksum coverage calculation based on dccph_x
     (2) removes dccp_v4_verify_checksum() since it reduplicates code of the
         checksum computation; code calling this function is updated accordingly.
     (3) now uses skb_checksum(), which is safer than checksum_partial() if the
         sk_buff has is a non-linear buffer (has pages attached to it).
     (4) fixes an outstanding TODO item:
            * If P.CsCov is too large for the packet size, drop packet and return.
    
    The code has been tested with applications, the latest version of tcpdump now
    comes with support for partial DCCP checksums.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 2990bfb12587..d5c414bf7819 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -129,6 +129,30 @@ DECLARE_SNMP_STAT(struct dccp_mib, dccp_statistics);
 #define DCCP_ADD_STATS_USER(field, val)	\
 			SNMP_ADD_STATS_USER(dccp_statistics, field, val)
 
+/*
+ * 	Checksumming routines
+ */
+static inline int dccp_csum_coverage(const struct sk_buff *skb)
+{
+	const struct dccp_hdr* dh = dccp_hdr(skb);
+
+	if (dh->dccph_cscov == 0)
+		return skb->len;
+	return (dh->dccph_doff + dh->dccph_cscov - 1) * sizeof(u32);
+}
+
+static inline void dccp_csum_outgoing(struct sk_buff *skb)
+{
+	int cov = dccp_csum_coverage(skb);
+
+	if (cov >= skb->len)
+		dccp_hdr(skb)->dccph_cscov = 0;
+
+	skb->csum = skb_checksum(skb, 0, (cov > skb->len)? skb->len : cov, 0);
+}
+
+extern void dccp_v4_send_check(struct sock *sk, int len, struct sk_buff *skb);
+
 extern int  dccp_retransmit_skb(struct sock *sk, struct sk_buff *skb);
 
 extern void dccp_send_ack(struct sock *sk);
@@ -214,14 +238,9 @@ extern void	   dccp_shutdown(struct sock *sk, int how);
 extern int	   inet_dccp_listen(struct socket *sock, int backlog);
 extern unsigned int dccp_poll(struct file *file, struct socket *sock,
 			     poll_table *wait);
-extern void	   dccp_v4_send_check(struct sock *sk, int len,
-				      struct sk_buff *skb);
 extern int	   dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr,
 				   int addr_len);
 
-extern int	   dccp_v4_checksum(const struct sk_buff *skb,
-				    const __be32 saddr, const __be32 daddr);
-
 extern int	   dccp_send_reset(struct sock *sk, enum dccp_reset_codes code);
 extern void	   dccp_send_close(struct sock *sk, const int active);
 extern int	   dccp_invalid_packet(struct sk_buff *skb);

commit cf557926f6955b4c3fa55e81fdb3675e752e8eed
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Nov 10 16:08:37 2006 -0200

    [DCCP]: tidy up dccp_v{4,6}_conn_request
    
    This is a code simplification to remove reduplicated code
    by concentrating and abstracting shared code.
    
    Detailed Changes:

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 7b859a723826..2990bfb12587 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -155,18 +155,7 @@ extern const char *dccp_state_name(const int state);
 extern void dccp_set_state(struct sock *sk, const int state);
 extern void dccp_done(struct sock *sk);
 
-static inline void dccp_openreq_init(struct request_sock *req,
-				     struct dccp_sock *dp,
-				     struct sk_buff *skb)
-{
-	/*
-	 * FIXME: fill in the other req fields from the DCCP options
-	 * received
-	 */
-	inet_rsk(req)->rmt_port = dccp_hdr(skb)->dccph_sport;
-	inet_rsk(req)->acked	= 0;
-	req->rcv_wnd = 0;
-}
+extern void dccp_reqsk_init(struct request_sock *req, struct sk_buff *skb);
 
 extern int dccp_v4_conn_request(struct sock *sk, struct sk_buff *skb);
 

commit f45b3ec481581f24719d8ab0bc812c02fcedc2bc
Author: Ian McDonald <ian.mcdonald@jandi.co.nz>
Date:   Fri Nov 10 13:09:10 2006 -0200

    [DCCP]: Fix logfile overflow
    
    This patch fixes data being spewed into the logs continually. As the
    code stood if there was a large queue and long delays timeo would go
    down to zero and never get reset.
    
    This fixes it by resetting timeo. Put constant into header as well.
    
    Signed-off-by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 3d4b4a908d11..7b859a723826 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -62,6 +62,8 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 
 #define DCCP_RTO_MAX ((unsigned)(120 * HZ)) /* FIXME: using TCP value */
 
+#define DCCP_XMIT_TIMEO 30000 /* Time/msecs for blocking transmit per packet */
+
 /* is seq1 < seq2 ? */
 static inline int before48(const u64 seq1, const u64 seq2)
 {

commit 8a73cd09d96aa01743316657fc4e6864fe79b703
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Nov 10 12:32:01 2006 -0200

    [DCCP]: calling dccp_v{4,6}_reqsk_send_ack is a BUG
    
    This patch removes two functions, the send_ack functions of request_sock,
    which are not called/used by the DCCP code. It is correct that these
    functions are not called, below is a justification why calling these
    functions (on a passive socket in the LISTEN/RESPOND state) would mean
    a DCCP protocol violation.
    
    A) Background: using request_sock in TCP:

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 8964b188aba3..3d4b4a908d11 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -131,6 +131,8 @@ extern int  dccp_retransmit_skb(struct sock *sk, struct sk_buff *skb);
 
 extern void dccp_send_ack(struct sock *sk);
 extern void dccp_send_delayed_ack(struct sock *sk);
+extern void dccp_reqsk_send_ack(struct sk_buff *sk, struct request_sock *rsk);
+
 extern void dccp_send_sync(struct sock *sk, const u64 seq,
 			   const enum dccp_pkt_type pkt_type);
 

commit f6484f7c7ad22e4bb018875c386d6a7aaa441426
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Fri Nov 10 12:01:52 2006 -0200

    [DCCP] timewait: Remove leftover extern declarations
    
    Gerrit Renker noticed dccp_tw_deschedule and submitted a patch with a FIXME,
    but as he suggests in the same patch the best thing is to just ditch this
    declaration, while doing that also noticed that tcp_tw_count is as well not
    defined anywhere, so ditch it too.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 9f00dd807e04..8964b188aba3 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -35,8 +35,6 @@ extern int dccp_debug;
 extern struct inet_hashinfo dccp_hashinfo;
 
 extern atomic_t dccp_orphan_count;
-extern int dccp_tw_count;
-extern void dccp_tw_deschedule(struct inet_timewait_sock *tw);
 
 extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 

commit 60361be1be7854cbffb6dc268d1bc094da33431c
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Fri Nov 10 02:13:56 2006 -0200

    [DCCP]: set safe upper bound for option length
    
    This is a re-send from
    http://www.mail-archive.com/dccp@vger.kernel.org/msg00553.html
    
    It is the same patch as before, but I have built in Arnaldo's suggestions
    pointed out in that posting.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 272e8584564e..9f00dd807e04 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -40,12 +40,18 @@ extern void dccp_tw_deschedule(struct inet_timewait_sock *tw);
 
 extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 
-/* FIXME: Right size this */
-#define DCCP_MAX_OPT_LEN 128
-
-#define DCCP_MAX_PACKET_HDR 32
-
-#define MAX_DCCP_HEADER  (DCCP_MAX_PACKET_HDR + DCCP_MAX_OPT_LEN + MAX_HEADER)
+/*
+ *  Set safe upper bounds for header and option length. Since Data Offset is 8
+ *  bits (RFC 4340, sec. 5.1), the total header length can never be more than
+ *  4 * 255 = 1020 bytes. The largest possible header length is 28 bytes (X=1):
+ *    - DCCP-Response with ACK Subheader and 4 bytes of Service code      OR
+ *    - DCCP-Reset    with ACK Subheader and 4 bytes of Reset Code fields
+ *  Hence a safe upper bound for the maximum option length is 1020-28 = 992
+ */
+#define MAX_DCCP_SPECIFIC_HEADER (255 * sizeof(int))
+#define DCCP_MAX_PACKET_HDR 28
+#define DCCP_MAX_OPT_LEN (MAX_DCCP_SPECIFIC_HEADER - DCCP_MAX_PACKET_HDR)
+#define MAX_DCCP_HEADER (MAX_DCCP_SPECIFIC_HEADER + MAX_HEADER)
 
 #define DCCP_TIMEWAIT_LEN (60 * HZ) /* how long to wait to destroy TIME-WAIT
 				     * state, about 60 seconds */

commit 0e64e94e477f8ed04e9295b11a5898d443c28a47
Author: Gerrit Renker <gerrit@erg.abdn.ac.uk>
Date:   Tue Oct 24 16:17:51 2006 -0700

    [DCCP]: Update documentation references.
    
    Updates the references to spec documents throughout the code, taking into
    account that
    
    * the DCCP, CCID 2, and CCID 3 drafts all became RFCs in March this year
    
    * RFC 1063 was obsoleted by RFC 1191
    
    * draft-ietf-tcpimpl-pmtud-0x.txt was published as an Informational
      RFC, RFC 2923 on 2000-09-22.
    
    All references verified.
    
    Signed-off-by: Gerrit Renker <gerrit@erg.abdn.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 0a21be437ed3..272e8584564e 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -50,7 +50,7 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 #define DCCP_TIMEWAIT_LEN (60 * HZ) /* how long to wait to destroy TIME-WAIT
 				     * state, about 60 seconds */
 
-/* draft-ietf-dccp-spec-11.txt initial RTO value */
+/* RFC 1122, 4.2.3.1 initial RTO value */
 #define DCCP_TIMEOUT_INIT ((unsigned)(3 * HZ))
 
 /* Maximal interval between probes for local resources.  */

commit 97e5848dd39e7e76bd6077735ebb5473763ab9c5
Author: Ian McDonald <ian.mcdonald@jandi.co.nz>
Date:   Sat Aug 26 19:16:45 2006 -0700

    [DCCP]: Introduce tx buffering
    
    This adds transmit buffering to DCCP.
    
    I have tested with CCID2/3 and with loss and rate limiting.
    
    Signed off by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index a5c5475724c0..0a21be437ed3 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -130,7 +130,7 @@ extern void dccp_send_delayed_ack(struct sock *sk);
 extern void dccp_send_sync(struct sock *sk, const u64 seq,
 			   const enum dccp_pkt_type pkt_type);
 
-extern int dccp_write_xmit(struct sock *sk, struct sk_buff *skb, long *timeo);
+extern void dccp_write_xmit(struct sock *sk, int block);
 extern void dccp_write_space(struct sock *sk);
 
 extern void dccp_init_xmit_timers(struct sock *sk);

commit 837d107cd101fbf734e9ea2bbb5c7336a329e432
Author: Ian McDonald <ian.mcdonald@jandi.co.nz>
Date:   Sat Aug 26 19:06:42 2006 -0700

    [DCCP]: Introduces follows48 function
    
    This adds a new function to see if two sequence numbers follow each
    other.
    
    Signed off by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index b8931d33bec3..a5c5475724c0 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -81,6 +81,14 @@ static inline u64 max48(const u64 seq1, const u64 seq2)
 	return after48(seq1, seq2) ? seq1 : seq2;
 }
 
+/* is seq1 next seqno after seq2 */
+static inline int follows48(const u64 seq1, const u64 seq2)
+{
+	int diff = (seq1 & 0xFFFF) - (seq2 & 0xFFFF);
+
+	return diff==1;
+}
+
 enum {
 	DCCP_MIB_NUM = 0,
 	DCCP_MIB_ACTIVEOPENS,			/* ActiveOpens */

commit e6bccd357343e98db9e1fd0d487f4f924e1a7921
Author: Ian McDonald <ian.mcdonald@jandi.co.nz>
Date:   Sat Aug 26 19:01:30 2006 -0700

    [DCCP]: Update contact details and copyright
    
    Just updating copyright and contacts
    
    Signed off by: Ian McDonald <ian.mcdonald@jandi.co.nz>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index d00a2f4ee5dd..b8931d33bec3 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -5,7 +5,7 @@
  *
  *  An implementation of the DCCP protocol
  *  Copyright (c) 2005 Arnaldo Carvalho de Melo <acme@conectiva.com.br>
- *  Copyright (c) 2005 Ian McDonald <iam4@cs.waikato.ac.nz>
+ *  Copyright (c) 2005-6 Ian McDonald <ian.mcdonald@jandi.co.nz>
  *
  *	This program is free software; you can redistribute it and/or modify it
  *	under the terms of the GNU General Public License version 2 as

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 1fe509148689..d00a2f4ee5dd 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -12,7 +12,6 @@
  *	published by the Free Software Foundation.
  */
 
-#include <linux/config.h>
 #include <linux/dccp.h>
 #include <net/snmp.h>
 #include <net/sock.h>

commit a4bf3902427a128455b8de299ff0918072b2e974
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 22:50:58 2006 -0800

    [DCCP] minisock: Rename struct dccp_options to struct dccp_minisock
    
    This will later be included in struct dccp_request_sock so that we can
    have per connection feature negotiation state while in the 3way
    handshake, when we clone the DCCP_ROLE_LISTEN socket (in
    dccp_create_openreq_child) we'll just copy this state from
    dreq_minisock to dccps_minisock.
    
    Also the feature negotiation and option parsing code will mostly touch
    dccps_minisock, which will simplify some stuff.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 47de17208d7a..1fe509148689 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -303,14 +303,13 @@ static inline void dccp_hdr_set_ack(struct dccp_hdr_ack_bits *dhack,
 static inline void dccp_update_gsr(struct sock *sk, u64 seq)
 {
 	struct dccp_sock *dp = dccp_sk(sk);
+	const struct dccp_minisock *dmsk = dccp_msk(sk);
 
 	dp->dccps_gsr = seq;
 	dccp_set_seqno(&dp->dccps_swl,
-		       (dp->dccps_gsr + 1 -
-		        (dp->dccps_options.dccpo_sequence_window / 4)));
+		       dp->dccps_gsr + 1 - (dmsk->dccpms_sequence_window / 4));
 	dccp_set_seqno(&dp->dccps_swh,
-		       (dp->dccps_gsr +
-			(3 * dp->dccps_options.dccpo_sequence_window) / 4));
+		       dp->dccps_gsr + (3 * dmsk->dccpms_sequence_window) / 4);
 }
 
 static inline void dccp_update_gss(struct sock *sk, u64 seq)
@@ -320,7 +319,7 @@ static inline void dccp_update_gss(struct sock *sk, u64 seq)
 	dp->dccps_awh = dp->dccps_gss = seq;
 	dccp_set_seqno(&dp->dccps_awl,
 		       (dp->dccps_gss -
-			dp->dccps_options.dccpo_sequence_window + 1));
+			dccp_msk(sk)->dccpms_sequence_window + 1));
 }
 				
 static inline int dccp_ack_pending(const struct sock *sk)
@@ -328,7 +327,7 @@ static inline int dccp_ack_pending(const struct sock *sk)
 	const struct dccp_sock *dp = dccp_sk(sk);
 	return dp->dccps_timestamp_echo != 0 ||
 #ifdef CONFIG_IP_DCCP_ACKVEC
-	       (dp->dccps_options.dccpo_send_ack_vector &&
+	       (dccp_msk(sk)->dccpms_send_ack_vector &&
 		dccp_ackvec_pending(dp->dccps_hc_rx_ackvec)) ||
 #endif
 	       inet_csk_ack_scheduled(sk);

commit 3fdadf7d27e3fbcf72930941884387d1f4936f04
Author: Dmitry Mishin <dim@openvz.org>
Date:   Mon Mar 20 22:45:21 2006 -0800

    [NET]: {get|set}sockopt compatibility layer
    
    This patch extends {get|set}sockopt compatibility layer in order to
    move protocol specific parts to their place and avoid huge universal
    net/compat.c file in the future.
    
    Signed-off-by: Dmitry Mishin <dim@openvz.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 34e70fb89d4a..47de17208d7a 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -192,6 +192,14 @@ extern int	   dccp_getsockopt(struct sock *sk, int level, int optname,
 				   char __user *optval, int __user *optlen);
 extern int	   dccp_setsockopt(struct sock *sk, int level, int optname,
 				   char __user *optval, int optlen);
+#ifdef CONFIG_COMPAT
+extern int	   compat_dccp_getsockopt(struct sock *sk,
+				int level, int optname,
+				char __user *optval, int __user *optlen);
+extern int	   compat_dccp_setsockopt(struct sock *sk,
+				int level, int optname,
+				char __user *optval, int optlen);
+#endif
 extern int	   dccp_ioctl(struct sock *sk, int cmd, unsigned long arg);
 extern int	   dccp_sendmsg(struct kiocb *iocb, struct sock *sk,
 				struct msghdr *msg, size_t size);

commit 2d0817d11eaec57435feb61493331a763f732a2b
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 22:32:06 2006 -0800

    [DCCP] options: Make dccp_insert_options & friends yell on error
    
    And not the silly LIMIT_NETDEBUG and silently return without inserting
    the option requested.
    
    Also drop some old debugging messages associated to option insertion.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 7f5be0822f3a..34e70fb89d4a 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -326,13 +326,13 @@ static inline int dccp_ack_pending(const struct sock *sk)
 	       inet_csk_ack_scheduled(sk);
 }
 
-extern void dccp_insert_options(struct sock *sk, struct sk_buff *skb);
-extern void dccp_insert_option_elapsed_time(struct sock *sk,
+extern int dccp_insert_options(struct sock *sk, struct sk_buff *skb);
+extern int dccp_insert_option_elapsed_time(struct sock *sk,
 					    struct sk_buff *skb,
 					    u32 elapsed_time);
-extern void dccp_insert_option_timestamp(struct sock *sk,
+extern int dccp_insert_option_timestamp(struct sock *sk,
 					 struct sk_buff *skb);
-extern void dccp_insert_option(struct sock *sk, struct sk_buff *skb,
+extern int dccp_insert_option(struct sock *sk, struct sk_buff *skb,
 			       unsigned char option,
 			       const void *value, unsigned char len);
 

commit 110bae4efb5ed5565257a0fb9f6d26e6125a1c4b
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 22:31:46 2006 -0800

    [DCCP]: Remove leftover dccp_send_response prototype
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index d57d21351149..7f5be0822f3a 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -118,7 +118,6 @@ DECLARE_SNMP_STAT(struct dccp_mib, dccp_statistics);
 
 extern int  dccp_retransmit_skb(struct sock *sk, struct sk_buff *skb);
 
-extern int dccp_send_response(struct sock *sk);
 extern void dccp_send_ack(struct sock *sk);
 extern void dccp_send_delayed_ack(struct sock *sk);
 extern void dccp_send_sync(struct sock *sk, const u64 seq,

commit 72478873571d869906f7a250b09e12fa5b65e321
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 22:00:37 2006 -0800

    [DCCP] ipv6: Add missing ipv6 control socket
    
    I guess I forgot to add it, nah, now it just works:
    
    18:04:33.274066 IP6 ::1.1476 > ::1.5001: request (service=0)
    18:04:33.334482 IP6 ::1.5001 > ::1.1476: reset (code=bad_service_code)
    
    Ditched IP_DCCP_UNLOAD_HACK, as now we would have to do it for both
    IPv6 and IPv4, so I'll come up with another way for freeing the
    control sockets in upcoming changesets.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 6fcc9d47ae8c..d57d21351149 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -177,7 +177,7 @@ extern int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 extern int dccp_rcv_established(struct sock *sk, struct sk_buff *skb,
 				const struct dccp_hdr *dh, const unsigned len);
 
-extern int dccp_init_sock(struct sock *sk);
+extern int dccp_init_sock(struct sock *sk, const __u8 ctl_sock_initialized);
 extern int dccp_destroy_sock(struct sock *sk);
 
 extern void		dccp_close(struct sock *sk, long timeout);
@@ -337,8 +337,6 @@ extern void dccp_insert_option(struct sock *sk, struct sk_buff *skb,
 			       unsigned char option,
 			       const void *value, unsigned char len);
 
-extern struct socket *dccp_ctl_socket;
-
 extern void dccp_timestamp(const struct sock *sk, struct timeval *tv);
 
 static inline suseconds_t timeval_usecs(const struct timeval *tv)

commit c25a18ba347f091d1ce620ba33e6772b60a528e1
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 21:58:56 2006 -0800

    [DCCP]: Uninline some functions
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 46aa4814d65f..6fcc9d47ae8c 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -138,53 +138,8 @@ extern unsigned int dccp_sync_mss(struct sock *sk, u32 pmtu);
 extern const char *dccp_packet_name(const int type);
 extern const char *dccp_state_name(const int state);
 
-static inline void dccp_set_state(struct sock *sk, const int state)
-{
-	const int oldstate = sk->sk_state;
-
-	dccp_pr_debug("%s(%p) %-10.10s -> %s\n",
-		      dccp_role(sk), sk,
-		      dccp_state_name(oldstate), dccp_state_name(state));
-	WARN_ON(state == oldstate);
-
-	switch (state) {
-	case DCCP_OPEN:
-		if (oldstate != DCCP_OPEN)
-			DCCP_INC_STATS(DCCP_MIB_CURRESTAB);
-		break;
-
-	case DCCP_CLOSED:
-		if (oldstate == DCCP_CLOSING || oldstate == DCCP_OPEN)
-			DCCP_INC_STATS(DCCP_MIB_ESTABRESETS);
-
-		sk->sk_prot->unhash(sk);
-		if (inet_csk(sk)->icsk_bind_hash != NULL &&
-		    !(sk->sk_userlocks & SOCK_BINDPORT_LOCK))
-			inet_put_port(&dccp_hashinfo, sk);
-		/* fall through */
-	default:
-		if (oldstate == DCCP_OPEN)
-			DCCP_DEC_STATS(DCCP_MIB_CURRESTAB);
-	}
-
-	/* Change state AFTER socket is unhashed to avoid closed
-	 * socket sitting in hash tables.
-	 */
-	sk->sk_state = state;
-}
-
-static inline void dccp_done(struct sock *sk)
-{
-	dccp_set_state(sk, DCCP_CLOSED);
-	dccp_clear_xmit_timers(sk);
-
-	sk->sk_shutdown = SHUTDOWN_MASK;
-
-	if (!sock_flag(sk, SOCK_DEAD))
-		sk->sk_state_change(sk);
-	else
-		inet_csk_destroy_sock(sk);
-}
+extern void dccp_set_state(struct sock *sk, const int state);
+extern void dccp_done(struct sock *sk);
 
 static inline void dccp_openreq_init(struct request_sock *req,
 				     struct dccp_sock *dp,

commit b61fafc4ef3faf54236d57e3b230ca19167663bf
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 21:25:11 2006 -0800

    [DCCP]: Move the IPv4 specific bits from proto.c to ipv4.c
    
    With this patch in place we can break down the complexity by better
    compartmentalizing the code that is common to ipv6 and ipv4.
    
    Now we have these modules:
    Module                  Size  Used by
    dccp_diag               1344  0
    inet_diag               9448  1 dccp_diag
    dccp_ccid3             15856  0
    dccp_tfrc_lib          12320  1 dccp_ccid3
    dccp_ccid2              5764  0
    dccp_ipv4              16996  2
    dccp                   48208  4 dccp_diag,dccp_ccid3,dccp_ccid2,dccp_ipv4
    
    dccp_ipv6 still requires dccp_ipv4 due to dccp_ipv6_mapped, that is
    the next target to work on the "hey, ipv4 is legacy, I only want ipv6
    dude!" direction.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index b6ea4cc12608..46aa4814d65f 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -59,8 +59,6 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 
 #define DCCP_RTO_MAX ((unsigned)(120 * HZ)) /* FIXME: using TCP value */
 
-extern struct proto dccp_prot;
-
 /* is seq1 < seq2 ? */
 static inline int before48(const u64 seq1, const u64 seq2)
 {
@@ -209,10 +207,6 @@ extern struct sock *dccp_create_openreq_child(struct sock *sk,
 
 extern int dccp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);
 
-extern void dccp_v4_err(struct sk_buff *skb, u32);
-
-extern int dccp_v4_rcv(struct sk_buff *skb);
-
 extern struct sock *dccp_v4_request_recv_sock(struct sock *sk,
 					      struct sk_buff *skb,
 					      struct request_sock *req,

commit c985ed705ffc682ce40d46a5f7bf98db86b27899
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 21:23:39 2006 -0800

    [DCCP]: Move dccp_[un]hash from ipv4.c to the core
    
    As this is used by both ipv4 and ipv6 and is not ipv4 specific.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 8f3903be5598..b6ea4cc12608 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -238,6 +238,7 @@ extern struct sk_buff	*dccp_make_response(struct sock *sk,
 
 extern int	   dccp_connect(struct sock *sk);
 extern int	   dccp_disconnect(struct sock *sk, int flags);
+extern void	   dccp_hash(struct sock *sk);
 extern void	   dccp_unhash(struct sock *sk);
 extern int	   dccp_getsockopt(struct sock *sk, int level, int optname,
 				   char __user *optval, int __user *optlen);

commit 3e0fadc51f2fde01e0e22f481370a9b5f073bfc3
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 21:23:15 2006 -0800

    [DCCP]: Move dccp_v4_{init,destroy}_sock to the core
    
    Removing one more ipv6 uses ipv4 stuff case in dccp land.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index cd7c5d069ae4..8f3903be5598 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -228,8 +228,8 @@ extern int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 extern int dccp_rcv_established(struct sock *sk, struct sk_buff *skb,
 				const struct dccp_hdr *dh, const unsigned len);
 
-extern int dccp_v4_init_sock(struct sock *sk);
-extern int dccp_v4_destroy_sock(struct sock *sk);
+extern int dccp_init_sock(struct sock *sk);
+extern int dccp_destroy_sock(struct sock *sk);
 
 extern void		dccp_close(struct sock *sk, long timeout);
 extern struct sk_buff	*dccp_make_response(struct sock *sk,

commit 017487d7d1e905a5bb529f6a2bc8cf8ea14e2307
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 19:25:24 2006 -0800

    [DCCP]: Generalize dccp_v4_send_reset
    
    Renaming it to dccp_send_reset and moving it from the ipv4 specific
    code to the core dccp code.
    
    This fixes some bugs in IPV6 where timers would send v4 resets, etc.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index f059541f5a1d..cd7c5d069ae4 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -235,9 +235,6 @@ extern void		dccp_close(struct sock *sk, long timeout);
 extern struct sk_buff	*dccp_make_response(struct sock *sk,
 					    struct dst_entry *dst,
 					    struct request_sock *req);
-extern struct sk_buff	*dccp_make_reset(struct sock *sk,
-					 struct dst_entry *dst,
-					 enum dccp_reset_codes code);
 
 extern int	   dccp_connect(struct sock *sk);
 extern int	   dccp_disconnect(struct sock *sk, int flags);
@@ -264,8 +261,7 @@ extern int	   dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr,
 extern int	   dccp_v4_checksum(const struct sk_buff *skb,
 				    const __be32 saddr, const __be32 daddr);
 
-extern int	   dccp_v4_send_reset(struct sock *sk,
-				      enum dccp_reset_codes code);
+extern int	   dccp_send_reset(struct sock *sk, enum dccp_reset_codes code);
 extern void	   dccp_send_close(struct sock *sk, const int active);
 extern int	   dccp_invalid_packet(struct sk_buff *skb);
 

commit e55d912f5b75723159348a7fc7692f869a86636a
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Mar 20 19:25:02 2006 -0800

    [DCCP] feat: Introduce sysctls for the default features
    
    [root@qemu ~]# for a in /proc/sys/net/dccp/default/* ; do echo $a ; cat $a ; done
    /proc/sys/net/dccp/default/ack_ratio
    2
    /proc/sys/net/dccp/default/rx_ccid
    3
    /proc/sys/net/dccp/default/send_ackvec
    1
    /proc/sys/net/dccp/default/send_ndp
    1
    /proc/sys/net/dccp/default/seq_window
    100
    /proc/sys/net/dccp/default/tx_ccid
    3
    [root@qemu ~]#
    
    So if wanting to test ccid3 as the tx CCID one can just do:
    
    [root@qemu ~]# echo 3 > /proc/sys/net/dccp/default/tx_ccid
    [root@qemu ~]# echo 2 > /proc/sys/net/dccp/default/rx_ccid
    [root@qemu ~]# cat /proc/sys/net/dccp/default/[tr]x_ccid
    2
    3
    [root@qemu ~]#
    
    Of course we also need the setsockopt for each app to tell its preferences, but
    for testing or defining something other than CCID2 as the default for apps that
    don't explicitely set their preference the sysctl interface is handy.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 1764adb4f15e..f059541f5a1d 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -433,4 +433,18 @@ static inline void timeval_sub_usecs(struct timeval *tv,
 	}
 }
 
+#ifdef CONFIG_SYSCTL
+extern int dccp_sysctl_init(void);
+extern void dccp_sysctl_exit(void);
+#else
+static inline int dccp_sysctl_init(void)
+{
+	return 0;
+}
+
+static inline void dccp_sysctl_exit(void)
+{
+}
+#endif
+
 #endif /* _DCCP_H */

commit 60fe62e789076ae7c13f7ffb35fec4b24802530d
Author: Andrea Bittau <a.bittau@cs.ucl.ac.uk>
Date:   Mon Mar 20 19:23:32 2006 -0800

    [DCCP]: sparse endianness annotations
    
    This also fixes the layout of dccp_hdr short sequence numbers, problem
    was not fatal now as we only support long (48 bits) sequence numbers.
    
    Signed-off-by: Andrea Bittau <a.bittau@cs.ucl.ac.uk>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 93f26dd6e6cb..1764adb4f15e 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -262,7 +262,7 @@ extern int	   dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr,
 				   int addr_len);
 
 extern int	   dccp_v4_checksum(const struct sk_buff *skb,
-				    const u32 saddr, const u32 daddr);
+				    const __be32 saddr, const __be32 daddr);
 
 extern int	   dccp_v4_send_reset(struct sock *sk,
 				      enum dccp_reset_codes code);
@@ -270,7 +270,7 @@ extern void	   dccp_send_close(struct sock *sk, const int active);
 extern int	   dccp_invalid_packet(struct sk_buff *skb);
 
 static inline int dccp_bad_service_code(const struct sock *sk,
-					const __u32 service)
+					const __be32 service)
 {
 	const struct dccp_sock *dp = dccp_sk(sk);
 
@@ -334,27 +334,16 @@ static inline void dccp_hdr_set_seq(struct dccp_hdr *dh, const u64 gss)
 {
 	struct dccp_hdr_ext *dhx = (struct dccp_hdr_ext *)((void *)dh +
 							   sizeof(*dh));
-
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	dh->dccph_seq	   = htonl((gss >> 32)) >> 8;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	dh->dccph_seq	   = htonl((gss >> 32));
-#else
-#error  "Adjust your <asm/byteorder.h> defines"
-#endif
+	dh->dccph_seq2 = 0;
+	dh->dccph_seq = htons((gss >> 32) & 0xfffff);
 	dhx->dccph_seq_low = htonl(gss & 0xffffffff);
 }
 
 static inline void dccp_hdr_set_ack(struct dccp_hdr_ack_bits *dhack,
 				    const u64 gsr)
 {
-#if defined(__LITTLE_ENDIAN_BITFIELD)
-	dhack->dccph_ack_nr_high = htonl((gsr >> 32)) >> 8;
-#elif defined(__BIG_ENDIAN_BITFIELD)
-	dhack->dccph_ack_nr_high = htonl((gsr >> 32));
-#else
-#error  "Adjust your <asm/byteorder.h> defines"
-#endif
+	dhack->dccph_reserved1 = 0;
+	dhack->dccph_ack_nr_high = htons(gsr >> 32);
 	dhack->dccph_ack_nr_low  = htonl(gsr & 0xffffffff);
 }
 

commit f21e68caa0ddffddf98a1e729e734a470957b6ec
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Dec 13 23:24:16 2005 -0800

    [DCCP]: Prepare the AF agnostic core for the introduction of DCCPv6
    
    Basically exports a similar set of functions as the one exported by
    the non-AF specific TCP code.
    
    In the process moved some non-AF specific code from dccp_v4_connect to
    dccp_connect_init and moved the checksum verification from
    dccp_invalid_packet to dccp_v4_rcv, so as to use it in dccp_v6_rcv
    too.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index e711f850053b..93f26dd6e6cb 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -228,6 +228,9 @@ extern int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 extern int dccp_rcv_established(struct sock *sk, struct sk_buff *skb,
 				const struct dccp_hdr *dh, const unsigned len);
 
+extern int dccp_v4_init_sock(struct sock *sk);
+extern int dccp_v4_destroy_sock(struct sock *sk);
+
 extern void		dccp_close(struct sock *sk, long timeout);
 extern struct sk_buff	*dccp_make_response(struct sock *sk,
 					    struct dst_entry *dst,
@@ -238,6 +241,7 @@ extern struct sk_buff	*dccp_make_reset(struct sock *sk,
 
 extern int	   dccp_connect(struct sock *sk);
 extern int	   dccp_disconnect(struct sock *sk, int flags);
+extern void	   dccp_unhash(struct sock *sk);
 extern int	   dccp_getsockopt(struct sock *sk, int level, int optname,
 				   char __user *optval, int __user *optlen);
 extern int	   dccp_setsockopt(struct sock *sk, int level, int optname,
@@ -249,6 +253,13 @@ extern int	   dccp_recvmsg(struct kiocb *iocb, struct sock *sk,
 				struct msghdr *msg, size_t len, int nonblock,
 				int flags, int *addr_len);
 extern void	   dccp_shutdown(struct sock *sk, int how);
+extern int	   inet_dccp_listen(struct socket *sock, int backlog);
+extern unsigned int dccp_poll(struct file *file, struct socket *sock,
+			     poll_table *wait);
+extern void	   dccp_v4_send_check(struct sock *sk, int len,
+				      struct sk_buff *skb);
+extern int	   dccp_v4_connect(struct sock *sk, struct sockaddr *uaddr,
+				   int addr_len);
 
 extern int	   dccp_v4_checksum(const struct sk_buff *skb,
 				    const u32 saddr, const u32 daddr);
@@ -256,6 +267,17 @@ extern int	   dccp_v4_checksum(const struct sk_buff *skb,
 extern int	   dccp_v4_send_reset(struct sock *sk,
 				      enum dccp_reset_codes code);
 extern void	   dccp_send_close(struct sock *sk, const int active);
+extern int	   dccp_invalid_packet(struct sk_buff *skb);
+
+static inline int dccp_bad_service_code(const struct sock *sk,
+					const __u32 service)
+{
+	const struct dccp_sock *dp = dccp_sk(sk);
+
+	if (dp->dccps_service == service)
+		return 0;
+	return !dccp_list_has_service(dp->dccps_service_list, service);
+}
 
 struct dccp_skb_cb {
 	__u8  dccpd_type:4;

commit 34ca6860810342441f801226b19ae6c9e0ecb34f
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Dec 13 23:23:32 2005 -0800

    [DCCP]: Just rename dccp_v4_prot to dccp_prot
    
    To match TCP equivalent.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index f97b85d55ad8..e711f850053b 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -59,7 +59,7 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 
 #define DCCP_RTO_MAX ((unsigned)(120 * HZ)) /* FIXME: using TCP value */
 
-extern struct proto dccp_v4_prot;
+extern struct proto dccp_prot;
 
 /* is seq1 < seq2 ? */
 static inline int before48(const u64 seq1, const u64 seq2)

commit 48918a4dbd6c599d6af30bd64cb355fadca708eb
Author: Herbert Xu <herbert@gondor.apana.org.au>
Date:   Sun Oct 30 11:20:59 2005 +1100

    [DCCP]: Simplify skb_set_owner_w semantics
    
    While we're at it let's reorganise the set_owner_w calls a little so that:
    
    1) dccp_transmit_skb sets the owner for all packets except data packets.
    2) Add dccp_skb_entail to set owner for packets queued for retransmission.
    3) Make dccp_transmit_skb static.
    
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 5871c027f9dc..f97b85d55ad8 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -118,7 +118,6 @@ DECLARE_SNMP_STAT(struct dccp_mib, dccp_statistics);
 #define DCCP_ADD_STATS_USER(field, val)	\
 			SNMP_ADD_STATS_USER(dccp_statistics, field, val)
 
-extern int  dccp_transmit_skb(struct sock *sk, struct sk_buff *skb);
 extern int  dccp_retransmit_skb(struct sock *sk, struct sk_buff *skb);
 
 extern int dccp_send_response(struct sock *sk);

commit ae31c3399d17b1f7bc1742724f70476b5417744f
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sun Sep 18 00:17:51 2005 -0700

    [DCCP]: Move the ack vector code to net/dccp/ackvec.[ch]
    
    Isolating it, that will be used when we introduce a CCID2 (TCP-Like)
    implementation.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index be7a660b6b24..5871c027f9dc 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -17,6 +17,7 @@
 #include <net/snmp.h>
 #include <net/sock.h>
 #include <net/tcp.h>
+#include "ackvec.h"
 
 #ifdef CONFIG_IP_DCCP_DEBUG
 extern int dccp_debug;
@@ -358,6 +359,17 @@ static inline void dccp_update_gss(struct sock *sk, u64 seq)
 		       (dp->dccps_gss -
 			dp->dccps_options.dccpo_sequence_window + 1));
 }
+				
+static inline int dccp_ack_pending(const struct sock *sk)
+{
+	const struct dccp_sock *dp = dccp_sk(sk);
+	return dp->dccps_timestamp_echo != 0 ||
+#ifdef CONFIG_IP_DCCP_ACKVEC
+	       (dp->dccps_options.dccpo_send_ack_vector &&
+		dccp_ackvec_pending(dp->dccps_hc_rx_ackvec)) ||
+#endif
+	       inet_csk_ack_scheduled(sk);
+}
 
 extern void dccp_insert_options(struct sock *sk, struct sk_buff *skb);
 extern void dccp_insert_option_elapsed_time(struct sock *sk,
@@ -371,65 +383,6 @@ extern void dccp_insert_option(struct sock *sk, struct sk_buff *skb,
 
 extern struct socket *dccp_ctl_socket;
 
-#define DCCP_ACKPKTS_STATE_RECEIVED	0
-#define DCCP_ACKPKTS_STATE_ECN_MARKED	(1 << 6)
-#define DCCP_ACKPKTS_STATE_NOT_RECEIVED	(3 << 6)
-
-#define DCCP_ACKPKTS_STATE_MASK		0xC0 /* 11000000 */
-#define DCCP_ACKPKTS_LEN_MASK		0x3F /* 00111111 */
-
-/** struct dccp_ackpkts - acknowledgeable packets
- *
- * This data structure is the one defined in the DCCP draft
- * Appendix A.
- *
- * @dccpap_buf_head - circular buffer head
- * @dccpap_buf_tail - circular buffer tail
- * @dccpap_buf_ackno - ack # of the most recent packet acknowledgeable in the
- * 		       buffer (i.e. %dccpap_buf_head)
- * @dccpap_buf_nonce - the one-bit sum of the ECN Nonces on all packets acked
- * 		       by the buffer with State 0
- *
- * Additionally, the HC-Receiver must keep some information about the
- * Ack Vectors it has recently sent. For each packet sent carrying an
- * Ack Vector, it remembers four variables:
- *
- * @dccpap_ack_seqno - the Sequence Number used for the packet
- * 		       (HC-Receiver seqno)
- * @dccpap_ack_ptr - the value of buf_head at the time of acknowledgement.
- * @dccpap_ack_ackno - the Acknowledgement Number used for the packet
- * 		       (HC-Sender seqno)
- * @dccpap_ack_nonce - the one-bit sum of the ECN Nonces for all State 0.
- *
- * @dccpap_buf_len - circular buffer length
- * @dccpap_time		- the time in usecs
- * @dccpap_buf - circular buffer of acknowledgeable packets
- */
-struct dccp_ackpkts {
-	unsigned int		dccpap_buf_head;
-	unsigned int		dccpap_buf_tail;
-	u64			dccpap_buf_ackno;
-	u64			dccpap_ack_seqno;
-	u64			dccpap_ack_ackno;
-	unsigned int		dccpap_ack_ptr;
-	unsigned int		dccpap_buf_vector_len;
-	unsigned int		dccpap_ack_vector_len;
-	unsigned int		dccpap_buf_len;
-	struct timeval		dccpap_time;
-	u8			dccpap_buf_nonce;
-	u8			dccpap_ack_nonce;
-	u8			dccpap_buf[0];
-};
-
-extern struct dccp_ackpkts *
-		dccp_ackpkts_alloc(unsigned int len,
-				  const unsigned int __nocast priority);
-extern void dccp_ackpkts_free(struct dccp_ackpkts *ap);
-extern int dccp_ackpkts_add(struct dccp_ackpkts *ap, const struct sock *sk,
-			    u64 ackno, u8 state);
-extern void dccp_ackpkts_check_rcv_ackno(struct dccp_ackpkts *ap,
-					 struct sock *sk, u64 ackno);
-
 extern void dccp_timestamp(const struct sock *sk, struct timeval *tv);
 
 static inline suseconds_t timeval_usecs(const struct timeval *tv)
@@ -470,15 +423,4 @@ static inline void timeval_sub_usecs(struct timeval *tv,
 	}
 }
 
-#ifdef CONFIG_IP_DCCP_DEBUG
-extern void dccp_ackvector_print(const u64 ackno,
-				 const unsigned char *vector, int len);
-extern void dccp_ackpkts_print(const struct dccp_ackpkts *ap);
-#else
-static inline void dccp_ackvector_print(const u64 ackno,
-					const unsigned char *vector,
-					int len) { }
-static inline void dccp_ackpkts_print(const struct dccp_ackpkts *ap) { }
-#endif
-
 #endif /* _DCCP_H */

commit 67e6b629212fa9ffb7420e8a88a41806af637e28
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Fri Sep 16 16:58:40 2005 -0700

    [DCCP]: Introduce DCCP_SOCKOPT_SERVICE
    
    As discussed in the dccp@vger mailing list:
    
    Now applications have to use setsockopt(DCCP_SOCKOPT_SERVICE, service[s]),
    prior to calling listen() and connect().
    
    An array of unsigned ints can be passed meaning that the listening sock accepts
    connection requests for several services.
    
    With this we can ditch struct sockaddr_dccp and use only sockaddr_in (and
    sockaddr_in6 in the future).
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 95c4630b3b18..be7a660b6b24 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -258,13 +258,12 @@ extern int	   dccp_v4_send_reset(struct sock *sk,
 extern void	   dccp_send_close(struct sock *sk, const int active);
 
 struct dccp_skb_cb {
-	__u8 dccpd_type;
-	__u8 dccpd_reset_code;
-	__u8 dccpd_service;
-	__u8 dccpd_ccval;
+	__u8  dccpd_type:4;
+	__u8  dccpd_ccval:4;
+	__u8  dccpd_reset_code;
+	__u16 dccpd_opt_len;
 	__u64 dccpd_seq;
 	__u64 dccpd_ack_seq;
-	int  dccpd_opt_len;
 };
 
 #define DCCP_SKB_CB(__skb) ((struct dccp_skb_cb *)&((__skb)->cb[0]))

commit b0e567806d16586629468c824dfb2e71155df7da
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Fri Sep 9 02:38:35 2005 -0300

    [DCCP] Introduce dccp_timestamp
    
    To start the timestamps with 0.0ms, easing the integer maths in the CCIDs, this
    probably will be reworked to use the to be introduced struct timeval_offset
    infrastructure out of skb_get_timestamp, etc.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 33456c0d5937..95c4630b3b18 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -426,10 +426,13 @@ extern struct dccp_ackpkts *
 		dccp_ackpkts_alloc(unsigned int len,
 				  const unsigned int __nocast priority);
 extern void dccp_ackpkts_free(struct dccp_ackpkts *ap);
-extern int dccp_ackpkts_add(struct dccp_ackpkts *ap, u64 ackno, u8 state);
+extern int dccp_ackpkts_add(struct dccp_ackpkts *ap, const struct sock *sk,
+			    u64 ackno, u8 state);
 extern void dccp_ackpkts_check_rcv_ackno(struct dccp_ackpkts *ap,
 					 struct sock *sk, u64 ackno);
 
+extern void dccp_timestamp(const struct sock *sk, struct timeval *tv);
+
 static inline suseconds_t timeval_usecs(const struct timeval *tv)
 {
 	return tv->tv_sec * USEC_PER_SEC + tv->tv_usec;
@@ -468,17 +471,6 @@ static inline void timeval_sub_usecs(struct timeval *tv,
 	}
 }
 
-/*
- * Returns the difference in usecs between timeval
- * passed in and current time
- */
-static inline suseconds_t timeval_now_delta(const struct timeval *tv)
-{
-	struct timeval now;
-	do_gettimeofday(&now);
-	return timeval_delta(&now, tv);
-}
-
 #ifdef CONFIG_IP_DCCP_DEBUG
 extern void dccp_ackvector_print(const u64 ackno,
 				 const unsigned char *vector, int len);

commit c530cfb1ce1e8f230744c3f3bd86771f50725053
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Mon Aug 29 02:15:54 2005 -0300

    [CCID3]: Call sk->sk_write_space(sk) when receiving a feedback packet
    
    This makes the send rate calculations behave way more closely to what
    is specified, with the jitter previously seen on x and x_recv
    disappearing completely on non lossy setups.
    
    This resembles the tcp_data_snd_check code, that possibly we'll end up
    using in DCCP as well, perhaps moving this code to
    inet_connection_sock.
    
    For now I'm doing the simplest implementation tho.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 5cd9e794bbe2..33456c0d5937 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -127,6 +127,7 @@ extern void dccp_send_sync(struct sock *sk, const u64 seq,
 			   const enum dccp_pkt_type pkt_type);
 
 extern int dccp_write_xmit(struct sock *sk, struct sk_buff *skb, long *timeo);
+extern void dccp_write_space(struct sock *sk);
 
 extern void dccp_init_xmit_timers(struct sock *sk);
 static inline void dccp_clear_xmit_timers(struct sock *sk)

commit b6ee3d4ada4e85d9b9b9164c1327ef0850c79d5e
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sat Aug 27 18:18:18 2005 -0300

    [CCID3]: Reorganise timeval handling
    
    Introducing functions to add to or subtract from a timeval variable
    and renaming now_delta to timeval_new_delta that calls do_gettimeofday
    and then timeval_delta, that should be used when there are several
    deltas made relative to the current time or setting variables to it,
    so as to avoid calling do_gettimeofday excessively.
    
    I'm leaving these "timeval_" prefixed funcions internal to DCCP for a
    while till we're sure there are no subtle bugs in it.
    
    It also is more correct as it checks if the number of usecs added to
    or subtracted from a tv_usec field is more than 2 seconds.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 6ba21509e797..5cd9e794bbe2 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -429,17 +429,53 @@ extern int dccp_ackpkts_add(struct dccp_ackpkts *ap, u64 ackno, u8 state);
 extern void dccp_ackpkts_check_rcv_ackno(struct dccp_ackpkts *ap,
 					 struct sock *sk, u64 ackno);
 
+static inline suseconds_t timeval_usecs(const struct timeval *tv)
+{
+	return tv->tv_sec * USEC_PER_SEC + tv->tv_usec;
+}
+
+static inline suseconds_t timeval_delta(const struct timeval *large,
+					const struct timeval *small)
+{
+	time_t	    secs  = large->tv_sec  - small->tv_sec;
+	suseconds_t usecs = large->tv_usec - small->tv_usec;
+
+	if (usecs < 0) {
+		secs--;
+		usecs += USEC_PER_SEC;
+	}
+	return secs * USEC_PER_SEC + usecs;
+}
+
+static inline void timeval_add_usecs(struct timeval *tv,
+				     const suseconds_t usecs)
+{
+	tv->tv_usec += usecs;
+	while (tv->tv_usec >= USEC_PER_SEC) {
+		tv->tv_sec++;
+		tv->tv_usec -= USEC_PER_SEC;
+	}
+}
+
+static inline void timeval_sub_usecs(struct timeval *tv,
+				     const suseconds_t usecs)
+{
+	tv->tv_usec -= usecs;
+	while (tv->tv_usec < 0) {
+		tv->tv_sec--;
+		tv->tv_usec += USEC_PER_SEC;
+	}
+}
+
 /*
  * Returns the difference in usecs between timeval
  * passed in and current time
  */
-static inline u32 now_delta(struct timeval tv)
+static inline suseconds_t timeval_now_delta(const struct timeval *tv)
 {
 	struct timeval now;
-	
 	do_gettimeofday(&now);
-	return (now.tv_sec  - tv.tv_sec) * USEC_PER_SEC +
-	       (now.tv_usec - tv.tv_usec);
+	return timeval_delta(&now, tv);
 }
 
 #ifdef CONFIG_IP_DCCP_DEBUG

commit d6809c12b3334a929c39bf08ea63bd819e0500f7
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sat Aug 27 03:06:35 2005 -0300

    [DCCP]: Introduce dccp_wait_for_ccid and use it in dccp_write_xmit
    
    This is not quite what I think we should have long term but improves
    performance for now, so lets use it till we get CCID3 working well,
    then we can think about using sk_write_queue, perhaps using some ideas
    from Juwen Lai's old stack for 2.4.20.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index c6ba07ea1a9f..6ba21509e797 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -126,8 +126,7 @@ extern void dccp_send_delayed_ack(struct sock *sk);
 extern void dccp_send_sync(struct sock *sk, const u64 seq,
 			   const enum dccp_pkt_type pkt_type);
 
-extern int dccp_write_xmit(struct sock *sk, struct sk_buff *skb,
-			   const int len);
+extern int dccp_write_xmit(struct sock *sk, struct sk_buff *skb, long *timeo);
 
 extern void dccp_init_xmit_timers(struct sock *sk);
 static inline void dccp_clear_xmit_timers(struct sock *sk)

commit d4b81ff70547b40c9b0742b163e8354560003cc0
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Aug 23 21:51:36 2005 -0700

    [DCCP]: Export dccp_insert_option_timestamp to CCIDs
    
    And don't insert a TIMESTAMP option in all packets, leave the decision
    to the CCIDs.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 53994f10ced5..c6ba07ea1a9f 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -364,6 +364,8 @@ extern void dccp_insert_options(struct sock *sk, struct sk_buff *skb);
 extern void dccp_insert_option_elapsed_time(struct sock *sk,
 					    struct sk_buff *skb,
 					    u32 elapsed_time);
+extern void dccp_insert_option_timestamp(struct sock *sk,
+					 struct sk_buff *skb);
 extern void dccp_insert_option(struct sock *sk, struct sk_buff *skb,
 			       unsigned char option,
 			       const void *value, unsigned char len);

commit 7ad07e7cf343181002c10c39d3f57a88e4903d4f
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Aug 23 21:50:06 2005 -0700

    [DCCP]: Implement the CLOSING timer
    
    So that we retransmit CLOSE/CLOSEREQ packets till they elicit an
    answer or we hit a timeout.
    
    Most of the machinery uses TCP approaches, this code has to be
    polished & audited, but this is better than we had before.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 33968a9422f2..53994f10ced5 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -255,7 +255,7 @@ extern int	   dccp_v4_checksum(const struct sk_buff *skb,
 
 extern int	   dccp_v4_send_reset(struct sock *sk,
 				      enum dccp_reset_codes code);
-extern void	   dccp_send_close(struct sock *sk);
+extern void	   dccp_send_close(struct sock *sk, const int active);
 
 struct dccp_skb_cb {
 	__u8 dccpd_type;

commit 03ace394ac9bcad38043a381ae5f4860b9c9fa1c
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sun Aug 21 05:36:45 2005 -0300

    [DCCP]: Fix the ACK and SEQ window variables settings
    
    This is from a first audit, more eyeballs are more than welcome.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index aab72b8d0703..33968a9422f2 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -340,13 +340,11 @@ static inline void dccp_hdr_set_ack(struct dccp_hdr_ack_bits *dhack,
 static inline void dccp_update_gsr(struct sock *sk, u64 seq)
 {
 	struct dccp_sock *dp = dccp_sk(sk);
-	u64 tmp_gsr;
 
-	dccp_set_seqno(&tmp_gsr,
+	dp->dccps_gsr = seq;
+	dccp_set_seqno(&dp->dccps_swl,
 		       (dp->dccps_gsr + 1 -
 		        (dp->dccps_options.dccpo_sequence_window / 4)));
-	dp->dccps_gsr = seq;
-	dccp_set_seqno(&dp->dccps_swl, max48(tmp_gsr, dp->dccps_isr));
 	dccp_set_seqno(&dp->dccps_swh,
 		       (dp->dccps_gsr +
 			(3 * dp->dccps_options.dccpo_sequence_window) / 4));
@@ -355,13 +353,11 @@ static inline void dccp_update_gsr(struct sock *sk, u64 seq)
 static inline void dccp_update_gss(struct sock *sk, u64 seq)
 {
 	struct dccp_sock *dp = dccp_sk(sk);
-	u64 tmp_gss;
 
-	dccp_set_seqno(&tmp_gss,
+	dp->dccps_awh = dp->dccps_gss = seq;
+	dccp_set_seqno(&dp->dccps_awl,
 		       (dp->dccps_gss -
 			dp->dccps_options.dccpo_sequence_window + 1));
-	dp->dccps_awl = max48(tmp_gss, dp->dccps_iss);
-	dp->dccps_awh = dp->dccps_gss = seq;
 }
 
 extern void dccp_insert_options(struct sock *sk, struct sk_buff *skb);

commit 1bc0986957b63a2fbbc46ab95d3d1d72830bda83
Author: Ian McDonald <iam4@cs.waikato.ac.nz>
Date:   Sat Aug 20 00:23:43 2005 -0300

    [DCCP]: Fix the timestamp options
    
    This changes timestamp, timestamp echo, and elapsed time to use units of 10
    usecs as per DCCP spec. This has been tested to verify that times are correct.
    Also fixed up length and used hton/ntoh more.
    
    Still to add in later patches:
    - actually use elapsed time to adjust RTT
    (commented out as was prior to this patch)
    - send options at times more closely following the spec
    (content is now correct)
    
    Signed-off-by: Ian McDonald <iam4@cs.waikato.ac.nz>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 4efdce47000b..aab72b8d0703 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -4,7 +4,8 @@
  *  net/dccp/dccp.h
  *
  *  An implementation of the DCCP protocol
- *  Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *  Copyright (c) 2005 Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *  Copyright (c) 2005 Ian McDonald <iam4@cs.waikato.ac.nz>
  *
  *	This program is free software; you can redistribute it and/or modify it
  *	under the terms of the GNU General Public License version 2 as
@@ -404,6 +405,7 @@ extern struct socket *dccp_ctl_socket;
  * @dccpap_ack_nonce - the one-bit sum of the ECN Nonces for all State 0.
  *
  * @dccpap_buf_len - circular buffer length
+ * @dccpap_time		- the time in usecs
  * @dccpap_buf - circular buffer of acknowledgeable packets
  */
 struct dccp_ackpkts {
@@ -416,7 +418,7 @@ struct dccp_ackpkts {
 	unsigned int		dccpap_buf_vector_len;
 	unsigned int		dccpap_ack_vector_len;
 	unsigned int		dccpap_buf_len;
-	unsigned long           dccpap_time;
+	struct timeval		dccpap_time;
 	u8			dccpap_buf_nonce;
 	u8			dccpap_ack_nonce;
 	u8			dccpap_buf[0];
@@ -430,6 +432,19 @@ extern int dccp_ackpkts_add(struct dccp_ackpkts *ap, u64 ackno, u8 state);
 extern void dccp_ackpkts_check_rcv_ackno(struct dccp_ackpkts *ap,
 					 struct sock *sk, u64 ackno);
 
+/*
+ * Returns the difference in usecs between timeval
+ * passed in and current time
+ */
+static inline u32 now_delta(struct timeval tv)
+{
+	struct timeval now;
+	
+	do_gettimeofday(&now);
+	return (now.tv_sec  - tv.tv_sec) * USEC_PER_SEC +
+	       (now.tv_usec - tv.tv_usec);
+}
+
 #ifdef CONFIG_IP_DCCP_DEBUG
 extern void dccp_ackvector_print(const u64 ackno,
 				 const unsigned char *vector, int len);

commit e92ae93a8aa66aea12935420cb22d4df1c18d023
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Wed Aug 17 03:10:59 2005 -0300

    [DCCP]: Send SYNCACK packets in response to SYNC packets
    
    Also fix step 6 when receiving SYNC or SYNCACK packets, i.e. we were not using
    the updated swl.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index fff794c8dfff..4efdce47000b 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -122,7 +122,8 @@ extern int  dccp_retransmit_skb(struct sock *sk, struct sk_buff *skb);
 extern int dccp_send_response(struct sock *sk);
 extern void dccp_send_ack(struct sock *sk);
 extern void dccp_send_delayed_ack(struct sock *sk);
-extern void dccp_send_sync(struct sock *sk, u64 seq);
+extern void dccp_send_sync(struct sock *sk, const u64 seq,
+			   const enum dccp_pkt_type pkt_type);
 
 extern int dccp_write_xmit(struct sock *sk, struct sk_buff *skb,
 			   const int len);

commit a10cedd4b905236603c6c4fd77cf338ebbfb1a60
Author: Patrick McHardy <kaber@trash.net>
Date:   Sun Aug 14 21:05:53 2005 -0300

    [DCCP]: Fix compiler warnings
    
    may be a false warning if there always is something on ccid3hcrx_hist:
    
    net/dccp/ccids/ccid3.c: In function 'ccid3_hc_rx_packet_recv':
    net/dccp/ccids/ccid3.c:1634: warning: 'tstamp.tv_usec' may be used uninitialized in this function
    net/dccp/ccids/ccid3.c:1634: warning: 'tstamp.tv_sec' may be used uninitialized in this function
    
    const on inline functions doesn't have any effect:
    
    net/dccp/dccp.h:64: warning: type qualifiers ignored on function return type
    net/dccp/dccp.h:70: warning: type qualifiers ignored on function return type
    net/dccp/dccp.h:76: warning: type qualifiers ignored on function return type
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 148e8a65a10c..fff794c8dfff 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -60,20 +60,19 @@ extern void dccp_time_wait(struct sock *sk, int state, int timeo);
 extern struct proto dccp_v4_prot;
 
 /* is seq1 < seq2 ? */
-static inline const  int before48(const u64 seq1, const u64 seq2)
+static inline int before48(const u64 seq1, const u64 seq2)
 {
-	return (const s64)((seq1 << 16) - (seq2 << 16)) < 0;
+	return (s64)((seq1 << 16) - (seq2 << 16)) < 0;
 }
 
 /* is seq1 > seq2 ? */
-static inline const  int after48(const u64 seq1, const u64 seq2)
+static inline int after48(const u64 seq1, const u64 seq2)
 {
-	return (const s64)((seq2 << 16) - (seq1 << 16)) < 0;
+	return (s64)((seq2 << 16) - (seq1 << 16)) < 0;
 }
 
 /* is seq2 <= seq1 <= seq3 ? */
-static inline const int between48(const u64 seq1, const u64 seq2,
-				  const u64 seq3)
+static inline int between48(const u64 seq1, const u64 seq2, const u64 seq3)
 {
 	return (seq3 << 16) - (seq2 << 16) >= (seq1 << 16) - (seq2 << 16);
 }

commit a1d3a35518779df0579dd9de0121354b49c68ddc
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sat Aug 13 22:42:25 2005 -0300

    [DCCP]: Fix sparse warnings
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 270f19439964..148e8a65a10c 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -231,19 +231,22 @@ extern void		dccp_close(struct sock *sk, long timeout);
 extern struct sk_buff	*dccp_make_response(struct sock *sk,
 					    struct dst_entry *dst,
 					    struct request_sock *req);
+extern struct sk_buff	*dccp_make_reset(struct sock *sk,
+					 struct dst_entry *dst,
+					 enum dccp_reset_codes code);
 
 extern int	   dccp_connect(struct sock *sk);
 extern int	   dccp_disconnect(struct sock *sk, int flags);
 extern int	   dccp_getsockopt(struct sock *sk, int level, int optname,
-				   char *optval, int *optlen);
+				   char __user *optval, int __user *optlen);
+extern int	   dccp_setsockopt(struct sock *sk, int level, int optname,
+				   char __user *optval, int optlen);
 extern int	   dccp_ioctl(struct sock *sk, int cmd, unsigned long arg);
 extern int	   dccp_sendmsg(struct kiocb *iocb, struct sock *sk,
 				struct msghdr *msg, size_t size);
 extern int	   dccp_recvmsg(struct kiocb *iocb, struct sock *sk,
 				struct msghdr *msg, size_t len, int nonblock,
 				int flags, int *addr_len);
-extern int	   dccp_setsockopt(struct sock *sk, int level, int optname,
-				   char *optval, int optlen);
 extern void	   dccp_shutdown(struct sock *sk, int how);
 
 extern int	   dccp_v4_checksum(const struct sk_buff *skb,
@@ -419,7 +422,9 @@ struct dccp_ackpkts {
 	u8			dccpap_buf[0];
 };
 
-extern struct dccp_ackpkts *dccp_ackpkts_alloc(unsigned int len, int priority);
+extern struct dccp_ackpkts *
+		dccp_ackpkts_alloc(unsigned int len,
+				  const unsigned int __nocast priority);
 extern void dccp_ackpkts_free(struct dccp_ackpkts *ap);
 extern int dccp_ackpkts_add(struct dccp_ackpkts *ap, u64 ackno, u8 state);
 extern void dccp_ackpkts_check_rcv_ackno(struct dccp_ackpkts *ap,

commit 725ba8eee3881e619c8e5a0116f1bdb6480ac2d9
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sat Aug 13 20:35:39 2005 -0300

    [DCCP]: Introduce the DCCP Kernel hacking menu
    
    Only available if CONFIG_DEBUG_KERNEL is enabled in the "Kernel
    Hacking" Menu.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 62e735f1807d..270f19439964 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -11,14 +11,13 @@
  *	published by the Free Software Foundation.
  */
 
+#include <linux/config.h>
 #include <linux/dccp.h>
 #include <net/snmp.h>
 #include <net/sock.h>
 #include <net/tcp.h>
 
-#define DCCP_DEBUG
-
-#ifdef DCCP_DEBUG
+#ifdef CONFIG_IP_DCCP_DEBUG
 extern int dccp_debug;
 
 #define dccp_pr_debug(format, a...) \
@@ -426,7 +425,7 @@ extern int dccp_ackpkts_add(struct dccp_ackpkts *ap, u64 ackno, u8 state);
 extern void dccp_ackpkts_check_rcv_ackno(struct dccp_ackpkts *ap,
 					 struct sock *sk, u64 ackno);
 
-#ifdef DCCP_DEBUG
+#ifdef CONFIG_IP_DCCP_DEBUG
 extern void dccp_ackvector_print(const u64 ackno,
 				 const unsigned char *vector, int len);
 extern void dccp_ackpkts_print(const struct dccp_ackpkts *ap);

commit 7690af3fff7633e40b1b9950eb8489129251d074
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Sat Aug 13 20:34:54 2005 -0300

    [DCCP]: Just reflow the source code to fit in 80 columns
    
    Andrew Morton should be happy now 8)
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 8a0d7af649e4..62e735f1807d 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -25,7 +25,8 @@ extern int dccp_debug;
 	do { if (dccp_debug) \
 		printk(KERN_DEBUG "%s: " format, __FUNCTION__ , ##a); \
 	} while (0)
-#define dccp_pr_debug_cat(format, a...) do { if (dccp_debug) printk(format, ##a); } while (0)
+#define dccp_pr_debug_cat(format, a...) do { if (dccp_debug) \
+					     printk(format, ##a); } while (0)
 #else
 #define dccp_pr_debug(format, a...)
 #define dccp_pr_debug_cat(format, a...)
@@ -72,7 +73,8 @@ static inline const  int after48(const u64 seq1, const u64 seq2)
 }
 
 /* is seq2 <= seq1 <= seq3 ? */
-static inline const int between48(const u64 seq1, const u64 seq2, const u64 seq3)
+static inline const int between48(const u64 seq1, const u64 seq2,
+				  const u64 seq3)
 {
 	return (seq3 << 16) - (seq2 << 16) >= (seq1 << 16) - (seq2 << 16);
 }
@@ -107,12 +109,14 @@ struct dccp_mib {
 } __SNMP_MIB_ALIGN__;
 
 DECLARE_SNMP_STAT(struct dccp_mib, dccp_statistics);
-#define DCCP_INC_STATS(field)		SNMP_INC_STATS(dccp_statistics, field)
-#define DCCP_INC_STATS_BH(field)	SNMP_INC_STATS_BH(dccp_statistics, field)
-#define DCCP_INC_STATS_USER(field) 	SNMP_INC_STATS_USER(dccp_statistics, field)
-#define DCCP_DEC_STATS(field)		SNMP_DEC_STATS(dccp_statistics, field)
-#define DCCP_ADD_STATS_BH(field, val)	SNMP_ADD_STATS_BH(dccp_statistics, field, val)
-#define DCCP_ADD_STATS_USER(field, val)	SNMP_ADD_STATS_USER(dccp_statistics, field, val)
+#define DCCP_INC_STATS(field)	    SNMP_INC_STATS(dccp_statistics, field)
+#define DCCP_INC_STATS_BH(field)    SNMP_INC_STATS_BH(dccp_statistics, field)
+#define DCCP_INC_STATS_USER(field)  SNMP_INC_STATS_USER(dccp_statistics, field)
+#define DCCP_DEC_STATS(field)	    SNMP_DEC_STATS(dccp_statistics, field)
+#define DCCP_ADD_STATS_BH(field, val) \
+			SNMP_ADD_STATS_BH(dccp_statistics, field, val)
+#define DCCP_ADD_STATS_USER(field, val)	\
+			SNMP_ADD_STATS_USER(dccp_statistics, field, val)
 
 extern int  dccp_transmit_skb(struct sock *sk, struct sk_buff *skb);
 extern int  dccp_retransmit_skb(struct sock *sk, struct sk_buff *skb);
@@ -234,8 +238,8 @@ extern int	   dccp_disconnect(struct sock *sk, int flags);
 extern int	   dccp_getsockopt(struct sock *sk, int level, int optname,
 				   char *optval, int *optlen);
 extern int	   dccp_ioctl(struct sock *sk, int cmd, unsigned long arg);
-extern int	   dccp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
-				size_t size);
+extern int	   dccp_sendmsg(struct kiocb *iocb, struct sock *sk,
+				struct msghdr *msg, size_t size);
 extern int	   dccp_recvmsg(struct kiocb *iocb, struct sock *sk,
 				struct msghdr *msg, size_t len, int nonblock,
 				int flags, int *addr_len);
@@ -246,7 +250,8 @@ extern void	   dccp_shutdown(struct sock *sk, int how);
 extern int	   dccp_v4_checksum(const struct sk_buff *skb,
 				    const u32 saddr, const u32 daddr);
 
-extern int	   dccp_v4_send_reset(struct sock *sk, enum dccp_reset_codes code);
+extern int	   dccp_v4_send_reset(struct sock *sk,
+				      enum dccp_reset_codes code);
 extern void	   dccp_send_close(struct sock *sk);
 
 struct dccp_skb_cb {
@@ -303,7 +308,8 @@ static inline void dccp_inc_seqno(u64 *seqno)
 
 static inline void dccp_hdr_set_seq(struct dccp_hdr *dh, const u64 gss)
 {
-	struct dccp_hdr_ext *dhx = (struct dccp_hdr_ext *)((void *)dh + sizeof(*dh));
+	struct dccp_hdr_ext *dhx = (struct dccp_hdr_ext *)((void *)dh +
+							   sizeof(*dh));
 
 #if defined(__LITTLE_ENDIAN_BITFIELD)
 	dh->dccph_seq	   = htonl((gss >> 32)) >> 8;
@@ -315,7 +321,8 @@ static inline void dccp_hdr_set_seq(struct dccp_hdr *dh, const u64 gss)
 	dhx->dccph_seq_low = htonl(gss & 0xffffffff);
 }
 
-static inline void dccp_hdr_set_ack(struct dccp_hdr_ack_bits *dhack, const u64 gsr)
+static inline void dccp_hdr_set_ack(struct dccp_hdr_ack_bits *dhack,
+				    const u64 gsr)
 {
 #if defined(__LITTLE_ENDIAN_BITFIELD)
 	dhack->dccph_ack_nr_high = htonl((gsr >> 32)) >> 8;
@@ -332,11 +339,14 @@ static inline void dccp_update_gsr(struct sock *sk, u64 seq)
 	struct dccp_sock *dp = dccp_sk(sk);
 	u64 tmp_gsr;
 
-	dccp_set_seqno(&tmp_gsr, dp->dccps_gsr + 1 - (dp->dccps_options.dccpo_sequence_window / 4));
+	dccp_set_seqno(&tmp_gsr,
+		       (dp->dccps_gsr + 1 -
+		        (dp->dccps_options.dccpo_sequence_window / 4)));
 	dp->dccps_gsr = seq;
 	dccp_set_seqno(&dp->dccps_swl, max48(tmp_gsr, dp->dccps_isr));
 	dccp_set_seqno(&dp->dccps_swh,
-		       dp->dccps_gsr + (3 * dp->dccps_options.dccpo_sequence_window) / 4);
+		       (dp->dccps_gsr +
+			(3 * dp->dccps_options.dccpo_sequence_window) / 4));
 }
 
 static inline void dccp_update_gss(struct sock *sk, u64 seq)
@@ -344,7 +354,9 @@ static inline void dccp_update_gss(struct sock *sk, u64 seq)
 	struct dccp_sock *dp = dccp_sk(sk);
 	u64 tmp_gss;
 
-	dccp_set_seqno(&tmp_gss, dp->dccps_gss - dp->dccps_options.dccpo_sequence_window + 1);
+	dccp_set_seqno(&tmp_gss,
+		       (dp->dccps_gss -
+			dp->dccps_options.dccpo_sequence_window + 1));
 	dp->dccps_awl = max48(tmp_gss, dp->dccps_iss);
 	dp->dccps_awh = dp->dccps_gss = seq;
 }
@@ -373,16 +385,20 @@ extern struct socket *dccp_ctl_socket;
  *
  * @dccpap_buf_head - circular buffer head
  * @dccpap_buf_tail - circular buffer tail
- * @dccpap_buf_ackno - ack # of the most recent packet acknoldgeable in the buffer (i.e. %dccpap_buf_head)
- * @dccpap_buf_nonce - the one-bit sum of the ECN Nonces on all packets acked by the buffer with State 0
+ * @dccpap_buf_ackno - ack # of the most recent packet acknowledgeable in the
+ * 		       buffer (i.e. %dccpap_buf_head)
+ * @dccpap_buf_nonce - the one-bit sum of the ECN Nonces on all packets acked
+ * 		       by the buffer with State 0
  *
  * Additionally, the HC-Receiver must keep some information about the
  * Ack Vectors it has recently sent. For each packet sent carrying an
  * Ack Vector, it remembers four variables:
  *
- * @dccpap_ack_seqno - the Sequence Number used for the packet (HC-Receiver seqno)
+ * @dccpap_ack_seqno - the Sequence Number used for the packet
+ * 		       (HC-Receiver seqno)
  * @dccpap_ack_ptr - the value of buf_head at the time of acknowledgement.
- * @dccpap_ack_ackno - the Acknowledgement Number used for the packet (HC-Sender seqno)
+ * @dccpap_ack_ackno - the Acknowledgement Number used for the packet
+ * 		       (HC-Sender seqno)
  * @dccpap_ack_nonce - the one-bit sum of the ECN Nonces for all State 0.
  *
  * @dccpap_buf_len - circular buffer length

commit 27258ee54f8cd4a43d09319aa5448145afc2cb8d
Author: Arnaldo Carvalho de Melo <acme@mandriva.com>
Date:   Tue Aug 9 20:30:56 2005 -0700

    [DCCP]: Introduce dccp_write_xmit from code in dccp_sendmsg
    
    This way it gets closer to the TCP flow, where congestion window
    checks are done, it seems we can map ccid_hc_tx_send_packet in
    dccp_write_xmit to tcp_snd_wnd_test in tcp_write_xmit, a CCID2
    decision should just fit in here as well...
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@mandriva.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index 55b690ab61ae..8a0d7af649e4 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -122,6 +122,9 @@ extern void dccp_send_ack(struct sock *sk);
 extern void dccp_send_delayed_ack(struct sock *sk);
 extern void dccp_send_sync(struct sock *sk, u64 seq);
 
+extern int dccp_write_xmit(struct sock *sk, struct sk_buff *skb,
+			   const int len);
+
 extern void dccp_init_xmit_timers(struct sock *sk);
 static inline void dccp_clear_xmit_timers(struct sock *sk)
 {
@@ -194,8 +197,6 @@ static inline void dccp_openreq_init(struct request_sock *req,
 	req->rcv_wnd = 0;
 }
 
-extern void dccp_v4_send_check(struct sock *sk, struct dccp_hdr *dh, int len, 
-			       struct sk_buff *skb);
 extern int dccp_v4_conn_request(struct sock *sk, struct sk_buff *skb);
 
 extern struct sock *dccp_create_openreq_child(struct sock *sk,

commit 95b81ef794278c835b321f6376b0522cd5df59b7
Author: Yoshifumi Nishida <nishida@csl.sony.co.jp>
Date:   Tue Aug 9 20:15:35 2005 -0700

    [DCCP]: Fix checksum routines
    
    Signed-off-by: Yoshifumi Nishida <nishida@csl.sony.co.jp>
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
index fb83454102c1..55b690ab61ae 100644
--- a/net/dccp/dccp.h
+++ b/net/dccp/dccp.h
@@ -242,7 +242,8 @@ extern int	   dccp_setsockopt(struct sock *sk, int level, int optname,
 				   char *optval, int optlen);
 extern void	   dccp_shutdown(struct sock *sk, int how);
 
-extern int	   dccp_v4_checksum(struct sk_buff *skb);
+extern int	   dccp_v4_checksum(const struct sk_buff *skb,
+				    const u32 saddr, const u32 daddr);
 
 extern int	   dccp_v4_send_reset(struct sock *sk, enum dccp_reset_codes code);
 extern void	   dccp_send_close(struct sock *sk);

commit 7c657876b63cb1d8a2ec06f8fc6c37bb8412e66c
Author: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
Date:   Tue Aug 9 20:14:34 2005 -0700

    [DCCP]: Initial implementation
    
    Development to this point was done on a subversion repository at:
    
    http://oops.ghostprotocols.net:81/cgi-bin/viewcvs.cgi/dccp-2.6/
    
    This repository will be kept at this site for the foreseable future,
    so that interested parties can see the history of this code,
    attributions, etc.
    
    If I ever decide to take this offline I'll provide the full history at
    some other suitable place.
    
    Signed-off-by: Arnaldo Carvalho de Melo <acme@ghostprotocols.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dccp/dccp.h b/net/dccp/dccp.h
new file mode 100644
index 000000000000..fb83454102c1
--- /dev/null
+++ b/net/dccp/dccp.h
@@ -0,0 +1,422 @@
+#ifndef _DCCP_H
+#define _DCCP_H
+/*
+ *  net/dccp/dccp.h
+ *
+ *  An implementation of the DCCP protocol
+ *  Arnaldo Carvalho de Melo <acme@conectiva.com.br>
+ *
+ *	This program is free software; you can redistribute it and/or modify it
+ *	under the terms of the GNU General Public License version 2 as
+ *	published by the Free Software Foundation.
+ */
+
+#include <linux/dccp.h>
+#include <net/snmp.h>
+#include <net/sock.h>
+#include <net/tcp.h>
+
+#define DCCP_DEBUG
+
+#ifdef DCCP_DEBUG
+extern int dccp_debug;
+
+#define dccp_pr_debug(format, a...) \
+	do { if (dccp_debug) \
+		printk(KERN_DEBUG "%s: " format, __FUNCTION__ , ##a); \
+	} while (0)
+#define dccp_pr_debug_cat(format, a...) do { if (dccp_debug) printk(format, ##a); } while (0)
+#else
+#define dccp_pr_debug(format, a...)
+#define dccp_pr_debug_cat(format, a...)
+#endif
+
+extern struct inet_hashinfo dccp_hashinfo;
+
+extern atomic_t dccp_orphan_count;
+extern int dccp_tw_count;
+extern void dccp_tw_deschedule(struct inet_timewait_sock *tw);
+
+extern void dccp_time_wait(struct sock *sk, int state, int timeo);
+
+/* FIXME: Right size this */
+#define DCCP_MAX_OPT_LEN 128
+
+#define DCCP_MAX_PACKET_HDR 32
+
+#define MAX_DCCP_HEADER  (DCCP_MAX_PACKET_HDR + DCCP_MAX_OPT_LEN + MAX_HEADER)
+
+#define DCCP_TIMEWAIT_LEN (60 * HZ) /* how long to wait to destroy TIME-WAIT
+				     * state, about 60 seconds */
+
+/* draft-ietf-dccp-spec-11.txt initial RTO value */
+#define DCCP_TIMEOUT_INIT ((unsigned)(3 * HZ))
+
+/* Maximal interval between probes for local resources.  */
+#define DCCP_RESOURCE_PROBE_INTERVAL ((unsigned)(HZ / 2U))
+
+#define DCCP_RTO_MAX ((unsigned)(120 * HZ)) /* FIXME: using TCP value */
+
+extern struct proto dccp_v4_prot;
+
+/* is seq1 < seq2 ? */
+static inline const  int before48(const u64 seq1, const u64 seq2)
+{
+	return (const s64)((seq1 << 16) - (seq2 << 16)) < 0;
+}
+
+/* is seq1 > seq2 ? */
+static inline const  int after48(const u64 seq1, const u64 seq2)
+{
+	return (const s64)((seq2 << 16) - (seq1 << 16)) < 0;
+}
+
+/* is seq2 <= seq1 <= seq3 ? */
+static inline const int between48(const u64 seq1, const u64 seq2, const u64 seq3)
+{
+	return (seq3 << 16) - (seq2 << 16) >= (seq1 << 16) - (seq2 << 16);
+}
+
+static inline u64 max48(const u64 seq1, const u64 seq2)
+{
+	return after48(seq1, seq2) ? seq1 : seq2;
+}
+
+enum {
+	DCCP_MIB_NUM = 0,
+	DCCP_MIB_ACTIVEOPENS,			/* ActiveOpens */
+	DCCP_MIB_ESTABRESETS,			/* EstabResets */
+	DCCP_MIB_CURRESTAB,			/* CurrEstab */
+	DCCP_MIB_OUTSEGS,			/* OutSegs */ 
+	DCCP_MIB_OUTRSTS,
+	DCCP_MIB_ABORTONTIMEOUT,
+	DCCP_MIB_TIMEOUTS,
+	DCCP_MIB_ABORTFAILED,
+	DCCP_MIB_PASSIVEOPENS,
+	DCCP_MIB_ATTEMPTFAILS,
+	DCCP_MIB_OUTDATAGRAMS,
+	DCCP_MIB_INERRS,
+	DCCP_MIB_OPTMANDATORYERROR,
+	DCCP_MIB_INVALIDOPT,
+	__DCCP_MIB_MAX
+};
+
+#define DCCP_MIB_MAX	__DCCP_MIB_MAX
+struct dccp_mib {
+	unsigned long	mibs[DCCP_MIB_MAX];
+} __SNMP_MIB_ALIGN__;
+
+DECLARE_SNMP_STAT(struct dccp_mib, dccp_statistics);
+#define DCCP_INC_STATS(field)		SNMP_INC_STATS(dccp_statistics, field)
+#define DCCP_INC_STATS_BH(field)	SNMP_INC_STATS_BH(dccp_statistics, field)
+#define DCCP_INC_STATS_USER(field) 	SNMP_INC_STATS_USER(dccp_statistics, field)
+#define DCCP_DEC_STATS(field)		SNMP_DEC_STATS(dccp_statistics, field)
+#define DCCP_ADD_STATS_BH(field, val)	SNMP_ADD_STATS_BH(dccp_statistics, field, val)
+#define DCCP_ADD_STATS_USER(field, val)	SNMP_ADD_STATS_USER(dccp_statistics, field, val)
+
+extern int  dccp_transmit_skb(struct sock *sk, struct sk_buff *skb);
+extern int  dccp_retransmit_skb(struct sock *sk, struct sk_buff *skb);
+
+extern int dccp_send_response(struct sock *sk);
+extern void dccp_send_ack(struct sock *sk);
+extern void dccp_send_delayed_ack(struct sock *sk);
+extern void dccp_send_sync(struct sock *sk, u64 seq);
+
+extern void dccp_init_xmit_timers(struct sock *sk);
+static inline void dccp_clear_xmit_timers(struct sock *sk)
+{
+	inet_csk_clear_xmit_timers(sk);
+}
+
+extern unsigned int dccp_sync_mss(struct sock *sk, u32 pmtu);
+
+extern const char *dccp_packet_name(const int type);
+extern const char *dccp_state_name(const int state);
+
+static inline void dccp_set_state(struct sock *sk, const int state)
+{
+	const int oldstate = sk->sk_state;
+
+	dccp_pr_debug("%s(%p) %-10.10s -> %s\n",
+		      dccp_role(sk), sk,
+		      dccp_state_name(oldstate), dccp_state_name(state));
+	WARN_ON(state == oldstate);
+
+	switch (state) {
+	case DCCP_OPEN:
+		if (oldstate != DCCP_OPEN)
+			DCCP_INC_STATS(DCCP_MIB_CURRESTAB);
+		break;
+
+	case DCCP_CLOSED:
+		if (oldstate == DCCP_CLOSING || oldstate == DCCP_OPEN)
+			DCCP_INC_STATS(DCCP_MIB_ESTABRESETS);
+
+		sk->sk_prot->unhash(sk);
+		if (inet_csk(sk)->icsk_bind_hash != NULL &&
+		    !(sk->sk_userlocks & SOCK_BINDPORT_LOCK))
+			inet_put_port(&dccp_hashinfo, sk);
+		/* fall through */
+	default:
+		if (oldstate == DCCP_OPEN)
+			DCCP_DEC_STATS(DCCP_MIB_CURRESTAB);
+	}
+
+	/* Change state AFTER socket is unhashed to avoid closed
+	 * socket sitting in hash tables.
+	 */
+	sk->sk_state = state;
+}
+
+static inline void dccp_done(struct sock *sk)
+{
+	dccp_set_state(sk, DCCP_CLOSED);
+	dccp_clear_xmit_timers(sk);
+
+	sk->sk_shutdown = SHUTDOWN_MASK;
+
+	if (!sock_flag(sk, SOCK_DEAD))
+		sk->sk_state_change(sk);
+	else
+		inet_csk_destroy_sock(sk);
+}
+
+static inline void dccp_openreq_init(struct request_sock *req,
+				     struct dccp_sock *dp,
+				     struct sk_buff *skb)
+{
+	/*
+	 * FIXME: fill in the other req fields from the DCCP options
+	 * received
+	 */
+	inet_rsk(req)->rmt_port = dccp_hdr(skb)->dccph_sport;
+	inet_rsk(req)->acked	= 0;
+	req->rcv_wnd = 0;
+}
+
+extern void dccp_v4_send_check(struct sock *sk, struct dccp_hdr *dh, int len, 
+			       struct sk_buff *skb);
+extern int dccp_v4_conn_request(struct sock *sk, struct sk_buff *skb);
+
+extern struct sock *dccp_create_openreq_child(struct sock *sk,
+					      const struct request_sock *req,
+					      const struct sk_buff *skb);
+
+extern int dccp_v4_do_rcv(struct sock *sk, struct sk_buff *skb);
+
+extern void dccp_v4_err(struct sk_buff *skb, u32);
+
+extern int dccp_v4_rcv(struct sk_buff *skb);
+
+extern struct sock *dccp_v4_request_recv_sock(struct sock *sk,
+					      struct sk_buff *skb,
+					      struct request_sock *req,
+					      struct dst_entry *dst);
+extern struct sock *dccp_check_req(struct sock *sk, struct sk_buff *skb,
+				   struct request_sock *req,
+				   struct request_sock **prev);
+
+extern int dccp_child_process(struct sock *parent, struct sock *child,
+			      struct sk_buff *skb);
+extern int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
+				  struct dccp_hdr *dh, unsigned len);
+extern int dccp_rcv_established(struct sock *sk, struct sk_buff *skb,
+				const struct dccp_hdr *dh, const unsigned len);
+
+extern void		dccp_close(struct sock *sk, long timeout);
+extern struct sk_buff	*dccp_make_response(struct sock *sk,
+					    struct dst_entry *dst,
+					    struct request_sock *req);
+
+extern int	   dccp_connect(struct sock *sk);
+extern int	   dccp_disconnect(struct sock *sk, int flags);
+extern int	   dccp_getsockopt(struct sock *sk, int level, int optname,
+				   char *optval, int *optlen);
+extern int	   dccp_ioctl(struct sock *sk, int cmd, unsigned long arg);
+extern int	   dccp_sendmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
+				size_t size);
+extern int	   dccp_recvmsg(struct kiocb *iocb, struct sock *sk,
+				struct msghdr *msg, size_t len, int nonblock,
+				int flags, int *addr_len);
+extern int	   dccp_setsockopt(struct sock *sk, int level, int optname,
+				   char *optval, int optlen);
+extern void	   dccp_shutdown(struct sock *sk, int how);
+
+extern int	   dccp_v4_checksum(struct sk_buff *skb);
+
+extern int	   dccp_v4_send_reset(struct sock *sk, enum dccp_reset_codes code);
+extern void	   dccp_send_close(struct sock *sk);
+
+struct dccp_skb_cb {
+	__u8 dccpd_type;
+	__u8 dccpd_reset_code;
+	__u8 dccpd_service;
+	__u8 dccpd_ccval;
+	__u64 dccpd_seq;
+	__u64 dccpd_ack_seq;
+	int  dccpd_opt_len;
+};
+
+#define DCCP_SKB_CB(__skb) ((struct dccp_skb_cb *)&((__skb)->cb[0]))
+
+static inline int dccp_non_data_packet(const struct sk_buff *skb)
+{
+	const __u8 type = DCCP_SKB_CB(skb)->dccpd_type;
+
+	return type == DCCP_PKT_ACK	 ||
+	       type == DCCP_PKT_CLOSE	 ||
+	       type == DCCP_PKT_CLOSEREQ ||
+	       type == DCCP_PKT_RESET	 ||
+	       type == DCCP_PKT_SYNC	 ||
+	       type == DCCP_PKT_SYNCACK;
+}
+
+static inline int dccp_packet_without_ack(const struct sk_buff *skb)
+{
+	const __u8 type = DCCP_SKB_CB(skb)->dccpd_type;
+
+	return type == DCCP_PKT_DATA || type == DCCP_PKT_REQUEST;
+}
+
+#define DCCP_MAX_SEQNO ((((u64)1) << 48) - 1)
+#define DCCP_PKT_WITHOUT_ACK_SEQ (DCCP_MAX_SEQNO << 2)
+
+static inline void dccp_set_seqno(u64 *seqno, u64 value)
+{
+	if (value > DCCP_MAX_SEQNO)
+		value -= DCCP_MAX_SEQNO + 1;
+	*seqno = value;
+}
+
+static inline u64 dccp_delta_seqno(u64 seqno1, u64 seqno2)
+{
+	return ((seqno2 << 16) - (seqno1 << 16)) >> 16;
+}
+
+static inline void dccp_inc_seqno(u64 *seqno)
+{
+	if (++*seqno > DCCP_MAX_SEQNO)
+		*seqno = 0;
+}
+
+static inline void dccp_hdr_set_seq(struct dccp_hdr *dh, const u64 gss)
+{
+	struct dccp_hdr_ext *dhx = (struct dccp_hdr_ext *)((void *)dh + sizeof(*dh));
+
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	dh->dccph_seq	   = htonl((gss >> 32)) >> 8;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	dh->dccph_seq	   = htonl((gss >> 32));
+#else
+#error  "Adjust your <asm/byteorder.h> defines"
+#endif
+	dhx->dccph_seq_low = htonl(gss & 0xffffffff);
+}
+
+static inline void dccp_hdr_set_ack(struct dccp_hdr_ack_bits *dhack, const u64 gsr)
+{
+#if defined(__LITTLE_ENDIAN_BITFIELD)
+	dhack->dccph_ack_nr_high = htonl((gsr >> 32)) >> 8;
+#elif defined(__BIG_ENDIAN_BITFIELD)
+	dhack->dccph_ack_nr_high = htonl((gsr >> 32));
+#else
+#error  "Adjust your <asm/byteorder.h> defines"
+#endif
+	dhack->dccph_ack_nr_low  = htonl(gsr & 0xffffffff);
+}
+
+static inline void dccp_update_gsr(struct sock *sk, u64 seq)
+{
+	struct dccp_sock *dp = dccp_sk(sk);
+	u64 tmp_gsr;
+
+	dccp_set_seqno(&tmp_gsr, dp->dccps_gsr + 1 - (dp->dccps_options.dccpo_sequence_window / 4));
+	dp->dccps_gsr = seq;
+	dccp_set_seqno(&dp->dccps_swl, max48(tmp_gsr, dp->dccps_isr));
+	dccp_set_seqno(&dp->dccps_swh,
+		       dp->dccps_gsr + (3 * dp->dccps_options.dccpo_sequence_window) / 4);
+}
+
+static inline void dccp_update_gss(struct sock *sk, u64 seq)
+{
+	struct dccp_sock *dp = dccp_sk(sk);
+	u64 tmp_gss;
+
+	dccp_set_seqno(&tmp_gss, dp->dccps_gss - dp->dccps_options.dccpo_sequence_window + 1);
+	dp->dccps_awl = max48(tmp_gss, dp->dccps_iss);
+	dp->dccps_awh = dp->dccps_gss = seq;
+}
+
+extern void dccp_insert_options(struct sock *sk, struct sk_buff *skb);
+extern void dccp_insert_option_elapsed_time(struct sock *sk,
+					    struct sk_buff *skb,
+					    u32 elapsed_time);
+extern void dccp_insert_option(struct sock *sk, struct sk_buff *skb,
+			       unsigned char option,
+			       const void *value, unsigned char len);
+
+extern struct socket *dccp_ctl_socket;
+
+#define DCCP_ACKPKTS_STATE_RECEIVED	0
+#define DCCP_ACKPKTS_STATE_ECN_MARKED	(1 << 6)
+#define DCCP_ACKPKTS_STATE_NOT_RECEIVED	(3 << 6)
+
+#define DCCP_ACKPKTS_STATE_MASK		0xC0 /* 11000000 */
+#define DCCP_ACKPKTS_LEN_MASK		0x3F /* 00111111 */
+
+/** struct dccp_ackpkts - acknowledgeable packets
+ *
+ * This data structure is the one defined in the DCCP draft
+ * Appendix A.
+ *
+ * @dccpap_buf_head - circular buffer head
+ * @dccpap_buf_tail - circular buffer tail
+ * @dccpap_buf_ackno - ack # of the most recent packet acknoldgeable in the buffer (i.e. %dccpap_buf_head)
+ * @dccpap_buf_nonce - the one-bit sum of the ECN Nonces on all packets acked by the buffer with State 0
+ *
+ * Additionally, the HC-Receiver must keep some information about the
+ * Ack Vectors it has recently sent. For each packet sent carrying an
+ * Ack Vector, it remembers four variables:
+ *
+ * @dccpap_ack_seqno - the Sequence Number used for the packet (HC-Receiver seqno)
+ * @dccpap_ack_ptr - the value of buf_head at the time of acknowledgement.
+ * @dccpap_ack_ackno - the Acknowledgement Number used for the packet (HC-Sender seqno)
+ * @dccpap_ack_nonce - the one-bit sum of the ECN Nonces for all State 0.
+ *
+ * @dccpap_buf_len - circular buffer length
+ * @dccpap_buf - circular buffer of acknowledgeable packets
+ */
+struct dccp_ackpkts {
+	unsigned int		dccpap_buf_head;
+	unsigned int		dccpap_buf_tail;
+	u64			dccpap_buf_ackno;
+	u64			dccpap_ack_seqno;
+	u64			dccpap_ack_ackno;
+	unsigned int		dccpap_ack_ptr;
+	unsigned int		dccpap_buf_vector_len;
+	unsigned int		dccpap_ack_vector_len;
+	unsigned int		dccpap_buf_len;
+	unsigned long           dccpap_time;
+	u8			dccpap_buf_nonce;
+	u8			dccpap_ack_nonce;
+	u8			dccpap_buf[0];
+};
+
+extern struct dccp_ackpkts *dccp_ackpkts_alloc(unsigned int len, int priority);
+extern void dccp_ackpkts_free(struct dccp_ackpkts *ap);
+extern int dccp_ackpkts_add(struct dccp_ackpkts *ap, u64 ackno, u8 state);
+extern void dccp_ackpkts_check_rcv_ackno(struct dccp_ackpkts *ap,
+					 struct sock *sk, u64 ackno);
+
+#ifdef DCCP_DEBUG
+extern void dccp_ackvector_print(const u64 ackno,
+				 const unsigned char *vector, int len);
+extern void dccp_ackpkts_print(const struct dccp_ackpkts *ap);
+#else
+static inline void dccp_ackvector_print(const u64 ackno,
+					const unsigned char *vector,
+					int len) { }
+static inline void dccp_ackpkts_print(const struct dccp_ackpkts *ap) { }
+#endif
+
+#endif /* _DCCP_H */
