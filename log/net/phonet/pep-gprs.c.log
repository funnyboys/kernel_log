commit 2b27bdcc20958d644d04f9f12d683e52b37a5427
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:50 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 336
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin st fifth floor boston ma 02110
      1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 246 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.674189849@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 2c9337946e30..1f5df0432d37 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * File: pep-gprs.c
  *
@@ -6,20 +7,6 @@
  * Copyright (C) 2008 Nokia Corporation.
  *
  * Author: Rémi Denis-Courmont
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
- * 02110-1301 USA
  */
 
 #include <linux/kernel.h>

commit cf124db566e6b036b8bcbe8decbed740bdfac8c6
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 8 12:52:56 2017 -0400

    net: Fix inconsistent teardown and release of private netdev state.
    
    Network devices can allocate reasources and private memory using
    netdev_ops->ndo_init().  However, the release of these resources
    can occur in one of two different places.
    
    Either netdev_ops->ndo_uninit() or netdev->destructor().
    
    The decision of which operation frees the resources depends upon
    whether it is necessary for all netdev refs to be released before it
    is safe to perform the freeing.
    
    netdev_ops->ndo_uninit() presumably can occur right after the
    NETDEV_UNREGISTER notifier completes and the unicast and multicast
    address lists are flushed.
    
    netdev->destructor(), on the other hand, does not run until the
    netdev references all go away.
    
    Further complicating the situation is that netdev->destructor()
    almost universally does also a free_netdev().
    
    This creates a problem for the logic in register_netdevice().
    Because all callers of register_netdevice() manage the freeing
    of the netdev, and invoke free_netdev(dev) if register_netdevice()
    fails.
    
    If netdev_ops->ndo_init() succeeds, but something else fails inside
    of register_netdevice(), it does call ndo_ops->ndo_uninit().  But
    it is not able to invoke netdev->destructor().
    
    This is because netdev->destructor() will do a free_netdev() and
    then the caller of register_netdevice() will do the same.
    
    However, this means that the resources that would normally be released
    by netdev->destructor() will not be.
    
    Over the years drivers have added local hacks to deal with this, by
    invoking their destructor parts by hand when register_netdevice()
    fails.
    
    Many drivers do not try to deal with this, and instead we have leaks.
    
    Let's close this hole by formalizing the distinction between what
    private things need to be freed up by netdev->destructor() and whether
    the driver needs unregister_netdevice() to perform the free_netdev().
    
    netdev->priv_destructor() performs all actions to free up the private
    resources that used to be freed by netdev->destructor(), except for
    free_netdev().
    
    netdev->needs_free_netdev is a boolean that indicates whether
    free_netdev() should be done at the end of unregister_netdevice().
    
    Now, register_netdevice() can sanely release all resources after
    ndo_ops->ndo_init() succeeds, by invoking both ndo_ops->ndo_uninit()
    and netdev->priv_destructor().
    
    And at the end of unregister_netdevice(), we invoke
    netdev->priv_destructor() and optionally call free_netdev().
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 21c28b51be94..2c9337946e30 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -236,7 +236,7 @@ static void gprs_setup(struct net_device *dev)
 	dev->tx_queue_len	= 10;
 
 	dev->netdev_ops		= &gprs_netdev_ops;
-	dev->destructor		= free_netdev;
+	dev->needs_free_netdev	= true;
 }
 
 /*

commit b3e3893e1253692c3d2b8e8ebd5a26183ed30443
Author: Jarod Wilson <jarod@redhat.com>
Date:   Thu Oct 20 13:55:22 2016 -0400

    net: use core MTU range checking in misc drivers
    
    firewire-net:
    - set min/max_mtu
    - remove fwnet_change_mtu
    
    nes:
    - set max_mtu
    - clean up nes_netdev_change_mtu
    
    xpnet:
    - set min/max_mtu
    - remove xpnet_dev_change_mtu
    
    hippi:
    - set min/max_mtu
    - remove hippi_change_mtu
    
    batman-adv:
    - set max_mtu
    - remove batadv_interface_change_mtu
    - initialization is a little async, not 100% certain that max_mtu is set
      in the optimal place, don't have hardware to test with
    
    rionet:
    - set min/max_mtu
    - remove rionet_change_mtu
    
    slip:
    - set min/max_mtu
    - streamline sl_change_mtu
    
    um/net_kern:
    - remove pointless ndo_change_mtu
    
    hsi/clients/ssi_protocol:
    - use core MTU range checking
    - remove now redundant ssip_pn_set_mtu
    
    ipoib:
    - set a default max MTU value
    - Note: ipoib's actual max MTU can vary, depending on if the device is in
      connected mode or not, so we'll just set the max_mtu value to the max
      possible, and let the ndo_change_mtu function continue to validate any new
      MTU change requests with checks for CM or not. Note that ipoib has no
      min_mtu set, and thus, the network core's mtu > 0 check is the only lower
      bounds here.
    
    mptlan:
    - use net core MTU range checking
    - remove now redundant mpt_lan_change_mtu
    
    fddi:
    - min_mtu = 21, max_mtu = 4470
    - remove now redundant fddi_change_mtu (including export)
    
    fjes:
    - min_mtu = 8192, max_mtu = 65536
    - The max_mtu value is actually one over IP_MAX_MTU here, but the idea is to
      get past the core net MTU range checks so fjes_change_mtu can validate a
      new MTU against what it supports (see fjes_support_mtu in fjes_hw.c)
    
    hsr:
    - min_mtu = 0 (calls ether_setup, max_mtu is 1500)
    
    f_phonet:
    - min_mtu = 6, max_mtu = 65541
    
    u_ether:
    - min_mtu = 14, max_mtu = 15412
    
    phonet/pep-gprs:
    - min_mtu = 576, max_mtu = 65530
    - remove redundant gprs_set_mtu
    
    CC: netdev@vger.kernel.org
    CC: linux-rdma@vger.kernel.org
    CC: Stefan Richter <stefanr@s5r6.in-berlin.de>
    CC: Faisal Latif <faisal.latif@intel.com>
    CC: linux-rdma@vger.kernel.org
    CC: Cliff Whickman <cpw@sgi.com>
    CC: Robin Holt <robinmholt@gmail.com>
    CC: Jes Sorensen <jes@trained-monkey.org>
    CC: Marek Lindner <mareklindner@neomailbox.ch>
    CC: Simon Wunderlich <sw@simonwunderlich.de>
    CC: Antonio Quartulli <a@unstable.cc>
    CC: Sathya Prakash <sathya.prakash@broadcom.com>
    CC: Chaitra P B <chaitra.basappa@broadcom.com>
    CC: Suganath Prabu Subramani <suganath-prabu.subramani@broadcom.com>
    CC: MPT-FusionLinux.pdl@broadcom.com
    CC: Sebastian Reichel <sre@kernel.org>
    CC: Felipe Balbi <balbi@kernel.org>
    CC: Arvid Brodin <arvid.brodin@alten.se>
    CC: Remi Denis-Courmont <courmisch@gmail.com>
    Signed-off-by: Jarod Wilson <jarod@redhat.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index fa8237fdc57b..21c28b51be94 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -217,20 +217,10 @@ static netdev_tx_t gprs_xmit(struct sk_buff *skb, struct net_device *dev)
 	return NETDEV_TX_OK;
 }
 
-static int gprs_set_mtu(struct net_device *dev, int new_mtu)
-{
-	if ((new_mtu < 576) || (new_mtu > (PHONET_MAX_MTU - 11)))
-		return -EINVAL;
-
-	dev->mtu = new_mtu;
-	return 0;
-}
-
 static const struct net_device_ops gprs_netdev_ops = {
 	.ndo_open	= gprs_open,
 	.ndo_stop	= gprs_close,
 	.ndo_start_xmit	= gprs_xmit,
-	.ndo_change_mtu	= gprs_set_mtu,
 };
 
 static void gprs_setup(struct net_device *dev)
@@ -239,6 +229,8 @@ static void gprs_setup(struct net_device *dev)
 	dev->type		= ARPHRD_PHONET_PIPE;
 	dev->flags		= IFF_POINTOPOINT | IFF_NOARP;
 	dev->mtu		= GPRS_DEFAULT_MTU;
+	dev->min_mtu		= 576;
+	dev->max_mtu		= (PHONET_MAX_MTU - 11);
 	dev->hard_header_len	= 0;
 	dev->addr_len		= 0;
 	dev->tx_queue_len	= 10;

commit ba7a46f16dd29f93303daeb1fee8af316c5a07f4
Author: Joe Perches <joe@perches.com>
Date:   Tue Nov 11 10:59:17 2014 -0800

    net: Convert LIMIT_NETDEBUG to net_dbg_ratelimited
    
    Use the more common dynamic_debug capable net_dbg_ratelimited
    and remove the LIMIT_NETDEBUG macro.
    
    All messages are still ratelimited.
    
    Some KERN_<LEVEL> uses are changed to KERN_DEBUG.
    
    This may have some negative impact on messages that were
    emitted at KERN_INFO that are not not enabled at all unless
    DEBUG is defined or dynamic_debug is enabled.  Even so,
    these messages are now _not_ emitted by default.
    
    This also eliminates the use of the net_msg_warn sysctl
    "/proc/sys/net/core/warnings".  For backward compatibility,
    the sysctl is not removed, but it has no function.  The extern
    declaration of net_msg_warn is removed from sock.h and made
    static in net/core/sysctl_net_core.c
    
    Miscellanea:
    
    o Update the sysctl documentation
    o Remove the embedded uses of pr_fmt
    o Coalesce format fragments
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index e9a83a637185..fa8237fdc57b 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -203,8 +203,7 @@ static netdev_tx_t gprs_xmit(struct sk_buff *skb, struct net_device *dev)
 	len = skb->len;
 	err = pep_write(sk, skb);
 	if (err) {
-		LIMIT_NETDEBUG(KERN_WARNING"%s: TX error (%d)\n",
-				dev->name, err);
+		net_dbg_ratelimited("%s: TX error (%d)\n", dev->name, err);
 		dev->stats.tx_aborted_errors++;
 		dev->stats.tx_errors++;
 	} else {

commit c835a677331495cf137a7f8a023463afd9f032f8
Author: Tom Gundersen <teg@jklm.no>
Date:   Mon Jul 14 16:37:24 2014 +0200

    net: set name_assign_type in alloc_netdev()
    
    Extend alloc_netdev{,_mq{,s}}() to take name_assign_type as argument, and convert
    all users to pass NET_NAME_UNKNOWN.
    
    Coccinelle patch:
    
    @@
    expression sizeof_priv, name, setup, txqs, rxqs, count;
    @@
    
    (
    -alloc_netdev_mqs(sizeof_priv, name, setup, txqs, rxqs)
    +alloc_netdev_mqs(sizeof_priv, name, NET_NAME_UNKNOWN, setup, txqs, rxqs)
    |
    -alloc_netdev_mq(sizeof_priv, name, setup, count)
    +alloc_netdev_mq(sizeof_priv, name, NET_NAME_UNKNOWN, setup, count)
    |
    -alloc_netdev(sizeof_priv, name, setup)
    +alloc_netdev(sizeof_priv, name, NET_NAME_UNKNOWN, setup)
    )
    
    v9: move comments here from the wrong commit
    
    Signed-off-by: Tom Gundersen <teg@jklm.no>
    Reviewed-by: David Herrmann <dh.herrmann@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 66dc65e7c6a1..e9a83a637185 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -267,7 +267,7 @@ int gprs_attach(struct sock *sk)
 		return -EINVAL; /* need packet boundaries */
 
 	/* Create net device */
-	dev = alloc_netdev(sizeof(*gp), ifname, gprs_setup);
+	dev = alloc_netdev(sizeof(*gp), ifname, NET_NAME_UNKNOWN, gprs_setup);
 	if (!dev)
 		return -ENOMEM;
 	gp = netdev_priv(dev);

commit 676d23690fb62b5d51ba5d659935e9f7d9da9f8e
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Apr 11 16:15:36 2014 -0400

    net: Fix use after free by removing length arg from sk_data_ready callbacks.
    
    Several spots in the kernel perform a sequence like:
    
            skb_queue_tail(&sk->s_receive_queue, skb);
            sk->sk_data_ready(sk, skb->len);
    
    But at the moment we place the SKB onto the socket receive queue it
    can be consumed and freed up.  So this skb->len access is potentially
    to freed up memory.
    
    Furthermore, the skb->len can be modified by the consumer so it is
    possible that the value isn't accurate.
    
    And finally, no actual implementation of this callback actually uses
    the length argument.  And since nobody actually cared about it's
    value, lots of call sites pass arbitrary values in such as '0' and
    even '1'.
    
    So just remove the length argument from the callback, that way there
    is no confusion whatsoever and all of these use-after-free cases get
    fixed as a side effect.
    
    Based upon a patch by Eric Dumazet and his suggestion to audit this
    issue tree-wide.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index a2fba7edfd1f..66dc65e7c6a1 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -37,7 +37,7 @@
 struct gprs_dev {
 	struct sock		*sk;
 	void			(*old_state_change)(struct sock *);
-	void			(*old_data_ready)(struct sock *, int);
+	void			(*old_data_ready)(struct sock *);
 	void			(*old_write_space)(struct sock *);
 
 	struct net_device	*dev;
@@ -146,7 +146,7 @@ static int gprs_recv(struct gprs_dev *gp, struct sk_buff *skb)
 	return err;
 }
 
-static void gprs_data_ready(struct sock *sk, int len)
+static void gprs_data_ready(struct sock *sk)
 {
 	struct gprs_dev *gp = sk->sk_user_data;
 	struct sk_buff *skb;

commit 31fdc5553b42abd7e29bb7b89f6ba07514eb4763
Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
Date:   Wed Jun 13 22:29:03 2012 +0000

    net: remove my future former mail address
    
    Signed-off-by: Rémi Denis-Courmont <remi@remlab.net>
    Cc: Sakari Ailus <sakari.ailus@nokia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index d01208968c83..a2fba7edfd1f 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -5,7 +5,7 @@
  *
  * Copyright (C) 2008 Nokia Corporation.
  *
- * Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
+ * Author: Rémi Denis-Courmont
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License

commit fc6a110754476362f9f4fa3199a637f2331c5993
Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
Date:   Mon Jan 4 02:02:47 2010 +0000

    Phonet: zero-copy aligned GPRS RX
    
    Newer Nokia cellular modems can use aligned payload for their GPRS pipe.
    
    Signed-off-by: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index d183509d3fa6..d01208968c83 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -96,11 +96,11 @@ static int gprs_recv(struct gprs_dev *gp, struct sk_buff *skb)
 		goto drop;
 	}
 
-	if (likely(skb_headroom(skb) & 3)) {
+	if (skb_headroom(skb) & 3) {
 		struct sk_buff *rskb, *fs;
 		int flen = 0;
 
-		/* Phonet Pipe data header is misaligned (3 bytes),
+		/* Phonet Pipe data header may be misaligned (3 bytes),
 		 * so wrap the IP packet as a single fragment of an head-less
 		 * socket buffer. The network stack will pull what it needs,
 		 * but at least, the whole IP payload is not memcpy'd. */

commit 424efe9caf6047ffbcd6b383ff4d2347254aabf1
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Aug 31 19:50:51 2009 +0000

    netdev: convert pseudo drivers to netdev_tx_t
    
    These are all drivers that don't touch real hardware.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 4667af51ed71..d183509d3fa6 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -183,7 +183,7 @@ static int gprs_close(struct net_device *dev)
 	return 0;
 }
 
-static int gprs_xmit(struct sk_buff *skb, struct net_device *dev)
+static netdev_tx_t gprs_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct gprs_dev *gp = netdev_priv(dev);
 	struct sock *sk = gp->sk;

commit 6ed106549d17474ca17a16057f4c0ed4eba5a7ca
Author: Patrick McHardy <kaber@trash.net>
Date:   Tue Jun 23 06:03:08 2009 +0000

    net: use NETDEV_TX_OK instead of 0 in ndo_start_xmit() functions
    
    This patch is the result of an automatic spatch transformation to convert
    all ndo_start_xmit() return values of 0 to NETDEV_TX_OK.
    
    Some occurences are missed by the automatic conversion, those will be
    handled in a seperate patch.
    
    Signed-off-by: Patrick McHardy <kaber@trash.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 480839dfc560..4667af51ed71 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -195,7 +195,7 @@ static int gprs_xmit(struct sk_buff *skb, struct net_device *dev)
 		break;
 	default:
 		dev_kfree_skb(skb);
-		return 0;
+		return NETDEV_TX_OK;
 	}
 
 	skb_orphan(skb);
@@ -215,7 +215,7 @@ static int gprs_xmit(struct sk_buff *skb, struct net_device *dev)
 	netif_stop_queue(dev);
 	if (pep_writeable(sk))
 		netif_wake_queue(dev);
-	return 0;
+	return NETDEV_TX_OK;
 }
 
 static int gprs_set_mtu(struct net_device *dev, int new_mtu)

commit 5c313e9a7773ec4d7ac554e841fba583f7c63aba
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 9 00:21:58 2009 -0700

    phonet: Use frag list abstraction interfaces.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 851f6a3f8ddd..480839dfc560 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -115,10 +115,10 @@ static int gprs_recv(struct gprs_dev *gp, struct sk_buff *skb)
 		rskb->truesize += rskb->len;
 
 		/* Avoid nested fragments */
-		for (fs = skb_shinfo(skb)->frag_list; fs; fs = fs->next)
+		skb_walk_frags(skb, fs)
 			flen += fs->len;
 		skb->next = skb_shinfo(skb)->frag_list;
-		skb_shinfo(skb)->frag_list = NULL;
+		skb_frag_list_init(skb);
 		skb->len -= flen;
 		skb->data_len -= flen;
 		skb->truesize -= flen;

commit bbd5898d39ab9f855c732f6f07e40e95b05cf52a
Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
Date:   Mon Jun 1 00:35:16 2009 +0000

    Phonet: fix accounting race between gprs_writeable() and gprs_xmit()
    
    In the unlikely event that gprs_writeable() and gprs_xmit() check for
    writeability at the same, we could stop the device queue forever.
    
    Signed-off-by: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 4aa888584d20..851f6a3f8ddd 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -212,8 +212,9 @@ static int gprs_xmit(struct sk_buff *skb, struct net_device *dev)
 		dev->stats.tx_bytes += len;
 	}
 
-	if (!pep_writeable(sk))
-		netif_stop_queue(dev);
+	netif_stop_queue(dev);
+	if (pep_writeable(sk))
+		netif_wake_queue(dev);
 	return 0;
 }
 

commit a2bf4538714f83fc83ac175c4de296510ae596ae
Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
Date:   Tue Feb 10 17:14:31 2009 -0800

    Phonet: fix double free in GPRS outbound packet error path
    
    Signed-off-by: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 6a91a32a80c1..4aa888584d20 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -207,7 +207,6 @@ static int gprs_xmit(struct sk_buff *skb, struct net_device *dev)
 				dev->name, err);
 		dev->stats.tx_aborted_errors++;
 		dev->stats.tx_errors++;
-		dev_kfree_skb(skb);
 	} else {
 		dev->stats.tx_packets++;
 		dev->stats.tx_bytes += len;

commit ab638e69ff7d4882ac152ada17eab340c93df080
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Wed Jan 7 17:24:34 2009 -0800

    phonet: update to net_device_ops
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index b0ceac2d6cd1..6a91a32a80c1 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -227,6 +227,13 @@ static int gprs_set_mtu(struct net_device *dev, int new_mtu)
 	return 0;
 }
 
+static const struct net_device_ops gprs_netdev_ops = {
+	.ndo_open	= gprs_open,
+	.ndo_stop	= gprs_close,
+	.ndo_start_xmit	= gprs_xmit,
+	.ndo_change_mtu	= gprs_set_mtu,
+};
+
 static void gprs_setup(struct net_device *dev)
 {
 	dev->features		= NETIF_F_FRAGLIST;
@@ -237,11 +244,8 @@ static void gprs_setup(struct net_device *dev)
 	dev->addr_len		= 0;
 	dev->tx_queue_len	= 10;
 
+	dev->netdev_ops		= &gprs_netdev_ops;
 	dev->destructor		= free_netdev;
-	dev->open		= gprs_open;
-	dev->stop		= gprs_close;
-	dev->hard_start_xmit	= gprs_xmit; /* mandatory */
-	dev->change_mtu		= gprs_set_mtu;
 }
 
 /*

commit 893873f3965ae0173a9315534bec7628162d2243
Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
Date:   Wed Dec 17 15:48:50 2008 -0800

    Phonet: get rid of deferred work on the transmission path
    
    Signed-off-by: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index a2873203dff2..b0ceac2d6cd1 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -41,11 +41,6 @@ struct gprs_dev {
 	void			(*old_write_space)(struct sock *);
 
 	struct net_device	*dev;
-
-	struct sk_buff_head	tx_queue;
-	struct work_struct	tx_work;
-	spinlock_t		tx_lock;
-	unsigned		tx_max;
 };
 
 static __be16 gprs_type_trans(struct sk_buff *skb)
@@ -66,6 +61,14 @@ static __be16 gprs_type_trans(struct sk_buff *skb)
 	return htons(0);
 }
 
+static void gprs_writeable(struct gprs_dev *gp)
+{
+	struct net_device *dev = gp->dev;
+
+	if (pep_writeable(gp->sk))
+		netif_wake_queue(dev);
+}
+
 /*
  * Socket callbacks
  */
@@ -157,14 +160,9 @@ static void gprs_data_ready(struct sock *sk, int len)
 static void gprs_write_space(struct sock *sk)
 {
 	struct gprs_dev *gp = sk->sk_user_data;
-	struct net_device *dev = gp->dev;
-	unsigned credits = pep_writeable(sk);
 
-	spin_lock_bh(&gp->tx_lock);
-	gp->tx_max = credits;
-	if (credits > skb_queue_len(&gp->tx_queue) && netif_running(dev))
-		netif_wake_queue(dev);
-	spin_unlock_bh(&gp->tx_lock);
+	if (netif_running(gp->dev))
+		gprs_writeable(gp);
 }
 
 /*
@@ -175,22 +173,21 @@ static int gprs_open(struct net_device *dev)
 {
 	struct gprs_dev *gp = netdev_priv(dev);
 
-	gprs_write_space(gp->sk);
+	gprs_writeable(gp);
 	return 0;
 }
 
 static int gprs_close(struct net_device *dev)
 {
-	struct gprs_dev *gp = netdev_priv(dev);
-
 	netif_stop_queue(dev);
-	flush_work(&gp->tx_work);
 	return 0;
 }
 
 static int gprs_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct gprs_dev *gp = netdev_priv(dev);
+	struct sock *sk = gp->sk;
+	int len, err;
 
 	switch (skb->protocol) {
 	case  htons(ETH_P_IP):
@@ -201,51 +198,24 @@ static int gprs_xmit(struct sk_buff *skb, struct net_device *dev)
 		return 0;
 	}
 
-	spin_lock(&gp->tx_lock);
-	if (likely(skb_queue_len(&gp->tx_queue) < gp->tx_max)) {
-		skb_queue_tail(&gp->tx_queue, skb);
-		skb = NULL;
-	}
-	if (skb_queue_len(&gp->tx_queue) >= gp->tx_max)
-		netif_stop_queue(dev);
-	spin_unlock(&gp->tx_lock);
-
-	schedule_work(&gp->tx_work);
-	if (unlikely(skb))
+	skb_orphan(skb);
+	skb_set_owner_w(skb, sk);
+	len = skb->len;
+	err = pep_write(sk, skb);
+	if (err) {
+		LIMIT_NETDEBUG(KERN_WARNING"%s: TX error (%d)\n",
+				dev->name, err);
+		dev->stats.tx_aborted_errors++;
+		dev->stats.tx_errors++;
 		dev_kfree_skb(skb);
-	return 0;
-}
-
-static void gprs_tx(struct work_struct *work)
-{
-	struct gprs_dev *gp = container_of(work, struct gprs_dev, tx_work);
-	struct net_device *dev = gp->dev;
-	struct sock *sk = gp->sk;
-	struct sk_buff *skb;
-
-	while ((skb = skb_dequeue(&gp->tx_queue)) != NULL) {
-		int err;
-
-		dev->stats.tx_bytes += skb->len;
+	} else {
 		dev->stats.tx_packets++;
-
-		skb_orphan(skb);
-		skb_set_owner_w(skb, sk);
-
-		lock_sock(sk);
-		err = pep_write(sk, skb);
-		if (err) {
-			LIMIT_NETDEBUG(KERN_WARNING"%s: TX error (%d)\n",
-					dev->name, err);
-			dev->stats.tx_aborted_errors++;
-			dev->stats.tx_errors++;
-		}
-		release_sock(sk);
+		dev->stats.tx_bytes += len;
 	}
 
-	lock_sock(sk);
-	gprs_write_space(sk);
-	release_sock(sk);
+	if (!pep_writeable(sk))
+		netif_stop_queue(dev);
+	return 0;
 }
 
 static int gprs_set_mtu(struct net_device *dev, int new_mtu)
@@ -297,11 +267,8 @@ int gprs_attach(struct sock *sk)
 	if (!dev)
 		return -ENOMEM;
 	gp = netdev_priv(dev);
+	gp->sk = sk;
 	gp->dev = dev;
-	gp->tx_max = 0;
-	spin_lock_init(&gp->tx_lock);
-	skb_queue_head_init(&gp->tx_queue);
-	INIT_WORK(&gp->tx_work, gprs_tx);
 
 	netif_stop_queue(dev);
 	err = register_netdev(dev);
@@ -328,9 +295,7 @@ int gprs_attach(struct sock *sk)
 	sk->sk_data_ready	= gprs_data_ready;
 	sk->sk_write_space	= gprs_write_space;
 	release_sock(sk);
-
 	sock_hold(sk);
-	gp->sk = sk;
 
 	printk(KERN_DEBUG"%s: attached\n", dev->name);
 	return dev->ifindex;

commit 57c81fffc863fb4c1804bc963bcbfb82d736c6df
Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
Date:   Wed Dec 17 15:47:48 2008 -0800

    Phonet: allocate separate ARP type for GPRS over a Phonet pipe
    
    A separate xmit lock class supports GPRS over a Phonet pipe over a TUN
    device (type ARPHRD_NONE).
    
    Signed-off-by: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 0b640b0fce0c..a2873203dff2 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -260,7 +260,7 @@ static int gprs_set_mtu(struct net_device *dev, int new_mtu)
 static void gprs_setup(struct net_device *dev)
 {
 	dev->features		= NETIF_F_FRAGLIST;
-	dev->type		= ARPHRD_NONE;
+	dev->type		= ARPHRD_PHONET_PIPE;
 	dev->flags		= IFF_POINTOPOINT | IFF_NOARP;
 	dev->mtu		= GPRS_DEFAULT_MTU;
 	dev->hard_header_len	= 0;

commit 09a2c3c0d3d3550675b766aa5edc28ffee79d7ab
Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
Date:   Tue Dec 16 01:18:31 2008 -0800

    Phonet: improve GPRS variable names
    
    Signed-off-by: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 22848dd7d67a..0b640b0fce0c 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -40,7 +40,7 @@ struct gprs_dev {
 	void			(*old_data_ready)(struct sock *, int);
 	void			(*old_write_space)(struct sock *);
 
-	struct net_device	*net;
+	struct net_device	*dev;
 
 	struct sk_buff_head	tx_queue;
 	struct work_struct	tx_work;
@@ -72,17 +72,19 @@ static __be16 gprs_type_trans(struct sk_buff *skb)
 
 static void gprs_state_change(struct sock *sk)
 {
-	struct gprs_dev *dev = sk->sk_user_data;
+	struct gprs_dev *gp = sk->sk_user_data;
 
 	if (sk->sk_state == TCP_CLOSE_WAIT) {
-		netif_stop_queue(dev->net);
-		netif_carrier_off(dev->net);
+		struct net_device *dev = gp->dev;
+
+		netif_stop_queue(dev);
+		netif_carrier_off(dev);
 	}
 }
 
-static int gprs_recv(struct gprs_dev *dev, struct sk_buff *skb)
+static int gprs_recv(struct gprs_dev *gp, struct sk_buff *skb)
 {
-	struct net_device *net = dev->net;
+	struct net_device *dev = gp->dev;
 	int err = 0;
 	__be16 protocol = gprs_type_trans(skb);
 
@@ -99,7 +101,7 @@ static int gprs_recv(struct gprs_dev *dev, struct sk_buff *skb)
 		 * so wrap the IP packet as a single fragment of an head-less
 		 * socket buffer. The network stack will pull what it needs,
 		 * but at least, the whole IP payload is not memcpy'd. */
-		rskb = netdev_alloc_skb(net, 0);
+		rskb = netdev_alloc_skb(dev, 0);
 		if (!rskb) {
 			err = -ENOBUFS;
 			goto drop;
@@ -123,11 +125,11 @@ static int gprs_recv(struct gprs_dev *dev, struct sk_buff *skb)
 
 	skb->protocol = protocol;
 	skb_reset_mac_header(skb);
-	skb->dev = net;
+	skb->dev = dev;
 
-	if (likely(net->flags & IFF_UP)) {
-		net->stats.rx_packets++;
-		net->stats.rx_bytes += skb->len;
+	if (likely(dev->flags & IFF_UP)) {
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += skb->len;
 		netif_rx(skb);
 		skb = NULL;
 	} else
@@ -136,33 +138,33 @@ static int gprs_recv(struct gprs_dev *dev, struct sk_buff *skb)
 drop:
 	if (skb) {
 		dev_kfree_skb(skb);
-		net->stats.rx_dropped++;
+		dev->stats.rx_dropped++;
 	}
 	return err;
 }
 
 static void gprs_data_ready(struct sock *sk, int len)
 {
-	struct gprs_dev *dev = sk->sk_user_data;
+	struct gprs_dev *gp = sk->sk_user_data;
 	struct sk_buff *skb;
 
 	while ((skb = pep_read(sk)) != NULL) {
 		skb_orphan(skb);
-		gprs_recv(dev, skb);
+		gprs_recv(gp, skb);
 	}
 }
 
 static void gprs_write_space(struct sock *sk)
 {
-	struct gprs_dev *dev = sk->sk_user_data;
-	struct net_device *net = dev->net;
+	struct gprs_dev *gp = sk->sk_user_data;
+	struct net_device *dev = gp->dev;
 	unsigned credits = pep_writeable(sk);
 
-	spin_lock_bh(&dev->tx_lock);
-	dev->tx_max = credits;
-	if (credits > skb_queue_len(&dev->tx_queue) && netif_running(net))
-		netif_wake_queue(net);
-	spin_unlock_bh(&dev->tx_lock);
+	spin_lock_bh(&gp->tx_lock);
+	gp->tx_max = credits;
+	if (credits > skb_queue_len(&gp->tx_queue) && netif_running(dev))
+		netif_wake_queue(dev);
+	spin_unlock_bh(&gp->tx_lock);
 }
 
 /*
@@ -186,9 +188,9 @@ static int gprs_close(struct net_device *dev)
 	return 0;
 }
 
-static int gprs_xmit(struct sk_buff *skb, struct net_device *net)
+static int gprs_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct gprs_dev *dev = netdev_priv(net);
+	struct gprs_dev *gp = netdev_priv(dev);
 
 	switch (skb->protocol) {
 	case  htons(ETH_P_IP):
@@ -199,16 +201,16 @@ static int gprs_xmit(struct sk_buff *skb, struct net_device *net)
 		return 0;
 	}
 
-	spin_lock(&dev->tx_lock);
-	if (likely(skb_queue_len(&dev->tx_queue) < dev->tx_max)) {
-		skb_queue_tail(&dev->tx_queue, skb);
+	spin_lock(&gp->tx_lock);
+	if (likely(skb_queue_len(&gp->tx_queue) < gp->tx_max)) {
+		skb_queue_tail(&gp->tx_queue, skb);
 		skb = NULL;
 	}
-	if (skb_queue_len(&dev->tx_queue) >= dev->tx_max)
-		netif_stop_queue(net);
-	spin_unlock(&dev->tx_lock);
+	if (skb_queue_len(&gp->tx_queue) >= gp->tx_max)
+		netif_stop_queue(dev);
+	spin_unlock(&gp->tx_lock);
 
-	schedule_work(&dev->tx_work);
+	schedule_work(&gp->tx_work);
 	if (unlikely(skb))
 		dev_kfree_skb(skb);
 	return 0;
@@ -216,16 +218,16 @@ static int gprs_xmit(struct sk_buff *skb, struct net_device *net)
 
 static void gprs_tx(struct work_struct *work)
 {
-	struct gprs_dev *dev = container_of(work, struct gprs_dev, tx_work);
-	struct net_device *net = dev->net;
-	struct sock *sk = dev->sk;
+	struct gprs_dev *gp = container_of(work, struct gprs_dev, tx_work);
+	struct net_device *dev = gp->dev;
+	struct sock *sk = gp->sk;
 	struct sk_buff *skb;
 
-	while ((skb = skb_dequeue(&dev->tx_queue)) != NULL) {
+	while ((skb = skb_dequeue(&gp->tx_queue)) != NULL) {
 		int err;
 
-		net->stats.tx_bytes += skb->len;
-		net->stats.tx_packets++;
+		dev->stats.tx_bytes += skb->len;
+		dev->stats.tx_packets++;
 
 		skb_orphan(skb);
 		skb_set_owner_w(skb, sk);
@@ -234,9 +236,9 @@ static void gprs_tx(struct work_struct *work)
 		err = pep_write(sk, skb);
 		if (err) {
 			LIMIT_NETDEBUG(KERN_WARNING"%s: TX error (%d)\n",
-					net->name, err);
-			net->stats.tx_aborted_errors++;
-			net->stats.tx_errors++;
+					dev->name, err);
+			dev->stats.tx_aborted_errors++;
+			dev->stats.tx_errors++;
 		}
 		release_sock(sk);
 	}
@@ -246,30 +248,30 @@ static void gprs_tx(struct work_struct *work)
 	release_sock(sk);
 }
 
-static int gprs_set_mtu(struct net_device *net, int new_mtu)
+static int gprs_set_mtu(struct net_device *dev, int new_mtu)
 {
 	if ((new_mtu < 576) || (new_mtu > (PHONET_MAX_MTU - 11)))
 		return -EINVAL;
 
-	net->mtu = new_mtu;
+	dev->mtu = new_mtu;
 	return 0;
 }
 
-static void gprs_setup(struct net_device *net)
+static void gprs_setup(struct net_device *dev)
 {
-	net->features		= NETIF_F_FRAGLIST;
-	net->type		= ARPHRD_NONE;
-	net->flags		= IFF_POINTOPOINT | IFF_NOARP;
-	net->mtu		= GPRS_DEFAULT_MTU;
-	net->hard_header_len	= 0;
-	net->addr_len		= 0;
-	net->tx_queue_len	= 10;
-
-	net->destructor		= free_netdev;
-	net->open		= gprs_open;
-	net->stop		= gprs_close;
-	net->hard_start_xmit	= gprs_xmit; /* mandatory */
-	net->change_mtu		= gprs_set_mtu;
+	dev->features		= NETIF_F_FRAGLIST;
+	dev->type		= ARPHRD_NONE;
+	dev->flags		= IFF_POINTOPOINT | IFF_NOARP;
+	dev->mtu		= GPRS_DEFAULT_MTU;
+	dev->hard_header_len	= 0;
+	dev->addr_len		= 0;
+	dev->tx_queue_len	= 10;
+
+	dev->destructor		= free_netdev;
+	dev->open		= gprs_open;
+	dev->stop		= gprs_close;
+	dev->hard_start_xmit	= gprs_xmit; /* mandatory */
+	dev->change_mtu		= gprs_set_mtu;
 }
 
 /*
@@ -283,28 +285,28 @@ static void gprs_setup(struct net_device *net)
 int gprs_attach(struct sock *sk)
 {
 	static const char ifname[] = "gprs%d";
-	struct gprs_dev *dev;
-	struct net_device *net;
+	struct gprs_dev *gp;
+	struct net_device *dev;
 	int err;
 
 	if (unlikely(sk->sk_type == SOCK_STREAM))
 		return -EINVAL; /* need packet boundaries */
 
 	/* Create net device */
-	net = alloc_netdev(sizeof(*dev), ifname, gprs_setup);
-	if (!net)
+	dev = alloc_netdev(sizeof(*gp), ifname, gprs_setup);
+	if (!dev)
 		return -ENOMEM;
-	dev = netdev_priv(net);
-	dev->net = net;
-	dev->tx_max = 0;
-	spin_lock_init(&dev->tx_lock);
-	skb_queue_head_init(&dev->tx_queue);
-	INIT_WORK(&dev->tx_work, gprs_tx);
-
-	netif_stop_queue(net);
-	err = register_netdev(net);
+	gp = netdev_priv(dev);
+	gp->dev = dev;
+	gp->tx_max = 0;
+	spin_lock_init(&gp->tx_lock);
+	skb_queue_head_init(&gp->tx_queue);
+	INIT_WORK(&gp->tx_work, gprs_tx);
+
+	netif_stop_queue(dev);
+	err = register_netdev(dev);
 	if (err) {
-		free_netdev(net);
+		free_netdev(dev);
 		return err;
 	}
 
@@ -318,40 +320,40 @@ int gprs_attach(struct sock *sk)
 		err = -EINVAL;
 		goto out_rel;
 	}
-	sk->sk_user_data	= dev;
-	dev->old_state_change	= sk->sk_state_change;
-	dev->old_data_ready	= sk->sk_data_ready;
-	dev->old_write_space	= sk->sk_write_space;
+	sk->sk_user_data	= gp;
+	gp->old_state_change	= sk->sk_state_change;
+	gp->old_data_ready	= sk->sk_data_ready;
+	gp->old_write_space	= sk->sk_write_space;
 	sk->sk_state_change	= gprs_state_change;
 	sk->sk_data_ready	= gprs_data_ready;
 	sk->sk_write_space	= gprs_write_space;
 	release_sock(sk);
 
 	sock_hold(sk);
-	dev->sk = sk;
+	gp->sk = sk;
 
-	printk(KERN_DEBUG"%s: attached\n", net->name);
-	return net->ifindex;
+	printk(KERN_DEBUG"%s: attached\n", dev->name);
+	return dev->ifindex;
 
 out_rel:
 	release_sock(sk);
-	unregister_netdev(net);
+	unregister_netdev(dev);
 	return err;
 }
 
 void gprs_detach(struct sock *sk)
 {
-	struct gprs_dev *dev = sk->sk_user_data;
-	struct net_device *net = dev->net;
+	struct gprs_dev *gp = sk->sk_user_data;
+	struct net_device *dev = gp->dev;
 
 	lock_sock(sk);
 	sk->sk_user_data	= NULL;
-	sk->sk_state_change	= dev->old_state_change;
-	sk->sk_data_ready	= dev->old_data_ready;
-	sk->sk_write_space	= dev->old_write_space;
+	sk->sk_state_change	= gp->old_state_change;
+	sk->sk_data_ready	= gp->old_data_ready;
+	sk->sk_write_space	= gp->old_write_space;
 	release_sock(sk);
 
-	printk(KERN_DEBUG"%s: detached\n", net->name);
-	unregister_netdev(net);
+	printk(KERN_DEBUG"%s: detached\n", dev->name);
+	unregister_netdev(dev);
 	sock_put(sk);
 }

commit eb14f019597cd86c21a6c601d7e900f40030c2e7
Merge: 9a4a84294b0d a3dd15444baa
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Dec 15 20:03:50 2008 -0800

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
    
            drivers/net/e1000e/ich8lan.c

commit 4798a2b84ea5a98e4f36a815a646cb48ff521684
Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
Date:   Mon Dec 15 00:53:57 2008 -0800

    Phonet: keep TX queue disabled when the device is off
    
    Signed-off-by: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 9978afbd9f2a..803eeef0aa85 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -155,12 +155,13 @@ static void gprs_data_ready(struct sock *sk, int len)
 static void gprs_write_space(struct sock *sk)
 {
 	struct gprs_dev *dev = sk->sk_user_data;
+	struct net_device *net = dev->net;
 	unsigned credits = pep_writeable(sk);
 
 	spin_lock_bh(&dev->tx_lock);
 	dev->tx_max = credits;
-	if (credits > skb_queue_len(&dev->tx_queue))
-		netif_wake_queue(dev->net);
+	if (credits > skb_queue_len(&dev->tx_queue) && netif_running(net))
+		netif_wake_queue(net);
 	spin_unlock_bh(&dev->tx_lock);
 }
 
@@ -168,6 +169,23 @@ static void gprs_write_space(struct sock *sk)
  * Network device callbacks
  */
 
+static int gprs_open(struct net_device *dev)
+{
+	struct gprs_dev *gp = netdev_priv(dev);
+
+	gprs_write_space(gp->sk);
+	return 0;
+}
+
+static int gprs_close(struct net_device *dev)
+{
+	struct gprs_dev *gp = netdev_priv(dev);
+
+	netif_stop_queue(dev);
+	flush_work(&gp->tx_work);
+	return 0;
+}
+
 static int gprs_xmit(struct sk_buff *skb, struct net_device *net)
 {
 	struct gprs_dev *dev = netdev_priv(net);
@@ -254,6 +272,8 @@ static void gprs_setup(struct net_device *net)
 	net->tx_queue_len	= 10;
 
 	net->destructor		= free_netdev;
+	net->open		= gprs_open;
+	net->stop		= gprs_close;
 	net->hard_start_xmit	= gprs_xmit; /* mandatory */
 	net->change_mtu		= gprs_set_mtu;
 	net->get_stats		= gprs_get_stats;
@@ -318,7 +338,6 @@ int gprs_attach(struct sock *sk)
 	dev->sk = sk;
 
 	printk(KERN_DEBUG"%s: attached\n", net->name);
-	gprs_write_space(sk); /* kick off TX */
 	return net->ifindex;
 
 out_rel:
@@ -341,7 +360,5 @@ void gprs_detach(struct sock *sk)
 
 	printk(KERN_DEBUG"%s: detached\n", net->name);
 	unregister_netdev(net);
-	flush_scheduled_work();
 	sock_put(sk);
-	skb_queue_purge(&dev->tx_queue);
 }

commit 9b1582d4513a2102c68fe12ac1106595f3c09120
Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
Date:   Mon Nov 10 16:21:05 2008 -0800

    Phonet: use net_device built-in stats for GPRS
    
    Signed-off-by: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index a4324075355f..e6e8e44852e5 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -41,7 +41,6 @@ struct gprs_dev {
 	void			(*old_write_space)(struct sock *);
 
 	struct net_device	*net;
-	struct net_device_stats	stats;
 
 	struct sk_buff_head	tx_queue;
 	struct work_struct	tx_work;
@@ -83,6 +82,7 @@ static void gprs_state_change(struct sock *sk)
 
 static int gprs_recv(struct gprs_dev *dev, struct sk_buff *skb)
 {
+	struct net_device *net = dev->net;
 	int err = 0;
 	__be16 protocol = gprs_type_trans(skb);
 
@@ -99,7 +99,7 @@ static int gprs_recv(struct gprs_dev *dev, struct sk_buff *skb)
 		 * so wrap the IP packet as a single fragment of an head-less
 		 * socket buffer. The network stack will pull what it needs,
 		 * but at least, the whole IP payload is not memcpy'd. */
-		rskb = netdev_alloc_skb(dev->net, 0);
+		rskb = netdev_alloc_skb(net, 0);
 		if (!rskb) {
 			err = -ENOBUFS;
 			goto drop;
@@ -123,11 +123,11 @@ static int gprs_recv(struct gprs_dev *dev, struct sk_buff *skb)
 
 	skb->protocol = protocol;
 	skb_reset_mac_header(skb);
-	skb->dev = dev->net;
+	skb->dev = net;
 
-	if (likely(dev->net->flags & IFF_UP)) {
-		dev->stats.rx_packets++;
-		dev->stats.rx_bytes += skb->len;
+	if (likely(net->flags & IFF_UP)) {
+		net->stats.rx_packets++;
+		net->stats.rx_bytes += skb->len;
 		netif_rx(skb);
 		skb = NULL;
 	} else
@@ -136,7 +136,7 @@ static int gprs_recv(struct gprs_dev *dev, struct sk_buff *skb)
 drop:
 	if (skb) {
 		dev_kfree_skb(skb);
-		dev->stats.rx_dropped++;
+		net->stats.rx_dropped++;
 	}
 	return err;
 }
@@ -199,14 +199,15 @@ static int gprs_xmit(struct sk_buff *skb, struct net_device *net)
 static void gprs_tx(struct work_struct *work)
 {
 	struct gprs_dev *dev = container_of(work, struct gprs_dev, tx_work);
+	struct net_device *net = dev->net;
 	struct sock *sk = dev->sk;
 	struct sk_buff *skb;
 
 	while ((skb = skb_dequeue(&dev->tx_queue)) != NULL) {
 		int err;
 
-		dev->stats.tx_bytes += skb->len;
-		dev->stats.tx_packets++;
+		net->stats.tx_bytes += skb->len;
+		net->stats.tx_packets++;
 
 		skb_orphan(skb);
 		skb_set_owner_w(skb, sk);
@@ -215,9 +216,9 @@ static void gprs_tx(struct work_struct *work)
 		err = pep_write(sk, skb);
 		if (err) {
 			LIMIT_NETDEBUG(KERN_WARNING"%s: TX error (%d)\n",
-					dev->net->name, err);
-			dev->stats.tx_aborted_errors++;
-			dev->stats.tx_errors++;
+					net->name, err);
+			net->stats.tx_aborted_errors++;
+			net->stats.tx_errors++;
 		}
 		release_sock(sk);
 	}
@@ -236,13 +237,6 @@ static int gprs_set_mtu(struct net_device *net, int new_mtu)
 	return 0;
 }
 
-static struct net_device_stats *gprs_get_stats(struct net_device *net)
-{
-	struct gprs_dev *dev = netdev_priv(net);
-
-	return &dev->stats;
-}
-
 static void gprs_setup(struct net_device *net)
 {
 	net->features		= NETIF_F_FRAGLIST;
@@ -256,7 +250,6 @@ static void gprs_setup(struct net_device *net)
 	net->destructor		= free_netdev;
 	net->hard_start_xmit	= gprs_xmit; /* mandatory */
 	net->change_mtu		= gprs_set_mtu;
-	net->get_stats		= gprs_get_stats;
 }
 
 /*

commit 5c7f0333584128c745fbda845abbe3a32c22d467
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Nov 6 23:10:50 2008 -0800

    phonet: sparse annotations of protocol, remove forward declaration
    
    net/phonet/af_phonet.c:38:36: error: marked inline, but without a definition
    net/phonet/pep-gprs.c:63:10: warning: incorrect type in return expression (different base types)
    net/phonet/pep-gprs.c:63:10:    expected int
    net/phonet/pep-gprs.c:63:10:    got restricted __be16 [usertype] <noident>
    net/phonet/pep-gprs.c:65:10: warning: incorrect type in return expression (different base types)
    net/phonet/pep-gprs.c:65:10:    expected int
    net/phonet/pep-gprs.c:65:10:    got restricted __be16 [usertype] <noident>
    net/phonet/pep-gprs.c:124:16: warning: incorrect type in assignment (different base types)
    net/phonet/pep-gprs.c:124:16:    expected restricted __be16 [usertype] protocol
    net/phonet/pep-gprs.c:124:16:    got unsigned short [unsigned] [usertype] protocol
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
index 9978afbd9f2a..a4324075355f 100644
--- a/net/phonet/pep-gprs.c
+++ b/net/phonet/pep-gprs.c
@@ -49,14 +49,14 @@ struct gprs_dev {
 	unsigned		tx_max;
 };
 
-static int gprs_type_trans(struct sk_buff *skb)
+static __be16 gprs_type_trans(struct sk_buff *skb)
 {
 	const u8 *pvfc;
 	u8 buf;
 
 	pvfc = skb_header_pointer(skb, 0, 1, &buf);
 	if (!pvfc)
-		return 0;
+		return htons(0);
 	/* Look at IP version field */
 	switch (*pvfc >> 4) {
 	case 4:
@@ -64,7 +64,7 @@ static int gprs_type_trans(struct sk_buff *skb)
 	case 6:
 		return htons(ETH_P_IPV6);
 	}
-	return 0;
+	return htons(0);
 }
 
 /*
@@ -84,7 +84,7 @@ static void gprs_state_change(struct sock *sk)
 static int gprs_recv(struct gprs_dev *dev, struct sk_buff *skb)
 {
 	int err = 0;
-	u16 protocol = gprs_type_trans(skb);
+	__be16 protocol = gprs_type_trans(skb);
 
 	if (!protocol) {
 		err = -EINVAL;

commit 02a47617cdce440f60c71a51f3a93f9f5fcc5a7a
Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
Date:   Sun Oct 5 11:16:16 2008 -0700

    Phonet: implement GPRS virtual interface over PEP socket
    
    Signed-off-by: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/phonet/pep-gprs.c b/net/phonet/pep-gprs.c
new file mode 100644
index 000000000000..9978afbd9f2a
--- /dev/null
+++ b/net/phonet/pep-gprs.c
@@ -0,0 +1,347 @@
+/*
+ * File: pep-gprs.c
+ *
+ * GPRS over Phonet pipe end point socket
+ *
+ * Copyright (C) 2008 Nokia Corporation.
+ *
+ * Author: Rémi Denis-Courmont <remi.denis-courmont@nokia.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
+ * 02110-1301 USA
+ */
+
+#include <linux/kernel.h>
+#include <linux/netdevice.h>
+#include <linux/if_ether.h>
+#include <linux/if_arp.h>
+#include <net/sock.h>
+
+#include <linux/if_phonet.h>
+#include <net/tcp_states.h>
+#include <net/phonet/gprs.h>
+
+#define GPRS_DEFAULT_MTU 1400
+
+struct gprs_dev {
+	struct sock		*sk;
+	void			(*old_state_change)(struct sock *);
+	void			(*old_data_ready)(struct sock *, int);
+	void			(*old_write_space)(struct sock *);
+
+	struct net_device	*net;
+	struct net_device_stats	stats;
+
+	struct sk_buff_head	tx_queue;
+	struct work_struct	tx_work;
+	spinlock_t		tx_lock;
+	unsigned		tx_max;
+};
+
+static int gprs_type_trans(struct sk_buff *skb)
+{
+	const u8 *pvfc;
+	u8 buf;
+
+	pvfc = skb_header_pointer(skb, 0, 1, &buf);
+	if (!pvfc)
+		return 0;
+	/* Look at IP version field */
+	switch (*pvfc >> 4) {
+	case 4:
+		return htons(ETH_P_IP);
+	case 6:
+		return htons(ETH_P_IPV6);
+	}
+	return 0;
+}
+
+/*
+ * Socket callbacks
+ */
+
+static void gprs_state_change(struct sock *sk)
+{
+	struct gprs_dev *dev = sk->sk_user_data;
+
+	if (sk->sk_state == TCP_CLOSE_WAIT) {
+		netif_stop_queue(dev->net);
+		netif_carrier_off(dev->net);
+	}
+}
+
+static int gprs_recv(struct gprs_dev *dev, struct sk_buff *skb)
+{
+	int err = 0;
+	u16 protocol = gprs_type_trans(skb);
+
+	if (!protocol) {
+		err = -EINVAL;
+		goto drop;
+	}
+
+	if (likely(skb_headroom(skb) & 3)) {
+		struct sk_buff *rskb, *fs;
+		int flen = 0;
+
+		/* Phonet Pipe data header is misaligned (3 bytes),
+		 * so wrap the IP packet as a single fragment of an head-less
+		 * socket buffer. The network stack will pull what it needs,
+		 * but at least, the whole IP payload is not memcpy'd. */
+		rskb = netdev_alloc_skb(dev->net, 0);
+		if (!rskb) {
+			err = -ENOBUFS;
+			goto drop;
+		}
+		skb_shinfo(rskb)->frag_list = skb;
+		rskb->len += skb->len;
+		rskb->data_len += rskb->len;
+		rskb->truesize += rskb->len;
+
+		/* Avoid nested fragments */
+		for (fs = skb_shinfo(skb)->frag_list; fs; fs = fs->next)
+			flen += fs->len;
+		skb->next = skb_shinfo(skb)->frag_list;
+		skb_shinfo(skb)->frag_list = NULL;
+		skb->len -= flen;
+		skb->data_len -= flen;
+		skb->truesize -= flen;
+
+		skb = rskb;
+	}
+
+	skb->protocol = protocol;
+	skb_reset_mac_header(skb);
+	skb->dev = dev->net;
+
+	if (likely(dev->net->flags & IFF_UP)) {
+		dev->stats.rx_packets++;
+		dev->stats.rx_bytes += skb->len;
+		netif_rx(skb);
+		skb = NULL;
+	} else
+		err = -ENODEV;
+
+drop:
+	if (skb) {
+		dev_kfree_skb(skb);
+		dev->stats.rx_dropped++;
+	}
+	return err;
+}
+
+static void gprs_data_ready(struct sock *sk, int len)
+{
+	struct gprs_dev *dev = sk->sk_user_data;
+	struct sk_buff *skb;
+
+	while ((skb = pep_read(sk)) != NULL) {
+		skb_orphan(skb);
+		gprs_recv(dev, skb);
+	}
+}
+
+static void gprs_write_space(struct sock *sk)
+{
+	struct gprs_dev *dev = sk->sk_user_data;
+	unsigned credits = pep_writeable(sk);
+
+	spin_lock_bh(&dev->tx_lock);
+	dev->tx_max = credits;
+	if (credits > skb_queue_len(&dev->tx_queue))
+		netif_wake_queue(dev->net);
+	spin_unlock_bh(&dev->tx_lock);
+}
+
+/*
+ * Network device callbacks
+ */
+
+static int gprs_xmit(struct sk_buff *skb, struct net_device *net)
+{
+	struct gprs_dev *dev = netdev_priv(net);
+
+	switch (skb->protocol) {
+	case  htons(ETH_P_IP):
+	case  htons(ETH_P_IPV6):
+		break;
+	default:
+		dev_kfree_skb(skb);
+		return 0;
+	}
+
+	spin_lock(&dev->tx_lock);
+	if (likely(skb_queue_len(&dev->tx_queue) < dev->tx_max)) {
+		skb_queue_tail(&dev->tx_queue, skb);
+		skb = NULL;
+	}
+	if (skb_queue_len(&dev->tx_queue) >= dev->tx_max)
+		netif_stop_queue(net);
+	spin_unlock(&dev->tx_lock);
+
+	schedule_work(&dev->tx_work);
+	if (unlikely(skb))
+		dev_kfree_skb(skb);
+	return 0;
+}
+
+static void gprs_tx(struct work_struct *work)
+{
+	struct gprs_dev *dev = container_of(work, struct gprs_dev, tx_work);
+	struct sock *sk = dev->sk;
+	struct sk_buff *skb;
+
+	while ((skb = skb_dequeue(&dev->tx_queue)) != NULL) {
+		int err;
+
+		dev->stats.tx_bytes += skb->len;
+		dev->stats.tx_packets++;
+
+		skb_orphan(skb);
+		skb_set_owner_w(skb, sk);
+
+		lock_sock(sk);
+		err = pep_write(sk, skb);
+		if (err) {
+			LIMIT_NETDEBUG(KERN_WARNING"%s: TX error (%d)\n",
+					dev->net->name, err);
+			dev->stats.tx_aborted_errors++;
+			dev->stats.tx_errors++;
+		}
+		release_sock(sk);
+	}
+
+	lock_sock(sk);
+	gprs_write_space(sk);
+	release_sock(sk);
+}
+
+static int gprs_set_mtu(struct net_device *net, int new_mtu)
+{
+	if ((new_mtu < 576) || (new_mtu > (PHONET_MAX_MTU - 11)))
+		return -EINVAL;
+
+	net->mtu = new_mtu;
+	return 0;
+}
+
+static struct net_device_stats *gprs_get_stats(struct net_device *net)
+{
+	struct gprs_dev *dev = netdev_priv(net);
+
+	return &dev->stats;
+}
+
+static void gprs_setup(struct net_device *net)
+{
+	net->features		= NETIF_F_FRAGLIST;
+	net->type		= ARPHRD_NONE;
+	net->flags		= IFF_POINTOPOINT | IFF_NOARP;
+	net->mtu		= GPRS_DEFAULT_MTU;
+	net->hard_header_len	= 0;
+	net->addr_len		= 0;
+	net->tx_queue_len	= 10;
+
+	net->destructor		= free_netdev;
+	net->hard_start_xmit	= gprs_xmit; /* mandatory */
+	net->change_mtu		= gprs_set_mtu;
+	net->get_stats		= gprs_get_stats;
+}
+
+/*
+ * External interface
+ */
+
+/*
+ * Attach a GPRS interface to a datagram socket.
+ * Returns the interface index on success, negative error code on error.
+ */
+int gprs_attach(struct sock *sk)
+{
+	static const char ifname[] = "gprs%d";
+	struct gprs_dev *dev;
+	struct net_device *net;
+	int err;
+
+	if (unlikely(sk->sk_type == SOCK_STREAM))
+		return -EINVAL; /* need packet boundaries */
+
+	/* Create net device */
+	net = alloc_netdev(sizeof(*dev), ifname, gprs_setup);
+	if (!net)
+		return -ENOMEM;
+	dev = netdev_priv(net);
+	dev->net = net;
+	dev->tx_max = 0;
+	spin_lock_init(&dev->tx_lock);
+	skb_queue_head_init(&dev->tx_queue);
+	INIT_WORK(&dev->tx_work, gprs_tx);
+
+	netif_stop_queue(net);
+	err = register_netdev(net);
+	if (err) {
+		free_netdev(net);
+		return err;
+	}
+
+	lock_sock(sk);
+	if (unlikely(sk->sk_user_data)) {
+		err = -EBUSY;
+		goto out_rel;
+	}
+	if (unlikely((1 << sk->sk_state & (TCPF_CLOSE|TCPF_LISTEN)) ||
+			sock_flag(sk, SOCK_DEAD))) {
+		err = -EINVAL;
+		goto out_rel;
+	}
+	sk->sk_user_data	= dev;
+	dev->old_state_change	= sk->sk_state_change;
+	dev->old_data_ready	= sk->sk_data_ready;
+	dev->old_write_space	= sk->sk_write_space;
+	sk->sk_state_change	= gprs_state_change;
+	sk->sk_data_ready	= gprs_data_ready;
+	sk->sk_write_space	= gprs_write_space;
+	release_sock(sk);
+
+	sock_hold(sk);
+	dev->sk = sk;
+
+	printk(KERN_DEBUG"%s: attached\n", net->name);
+	gprs_write_space(sk); /* kick off TX */
+	return net->ifindex;
+
+out_rel:
+	release_sock(sk);
+	unregister_netdev(net);
+	return err;
+}
+
+void gprs_detach(struct sock *sk)
+{
+	struct gprs_dev *dev = sk->sk_user_data;
+	struct net_device *net = dev->net;
+
+	lock_sock(sk);
+	sk->sk_user_data	= NULL;
+	sk->sk_state_change	= dev->old_state_change;
+	sk->sk_data_ready	= dev->old_data_ready;
+	sk->sk_write_space	= dev->old_write_space;
+	release_sock(sk);
+
+	printk(KERN_DEBUG"%s: detached\n", net->name);
+	unregister_netdev(net);
+	flush_scheduled_work();
+	sock_put(sk);
+	skb_queue_purge(&dev->tx_queue);
+}
