commit 1ed9ec9b08addbd8d3e36d5f4a652d8590a6ddb7
Author: Daniel Mack <daniel@zonque.org>
Date:   Sat Jun 20 21:39:25 2020 +0200

    dsa: Allow forwarding of redirected IGMP traffic
    
    The driver for Marvell switches puts all ports in IGMP snooping mode
    which results in all IGMP/MLD frames that ingress on the ports to be
    forwarded to the CPU only.
    
    The bridge code in the kernel can then interpret these frames and act
    upon them, for instance by updating the mdb in the switch to reflect
    multicast memberships of stations connected to the ports. However,
    the IGMP/MLD frames must then also be forwarded to other ports of the
    bridge so external IGMP queriers can track membership reports, and
    external multicast clients can receive query reports from foreign IGMP
    queriers.
    
    Currently, this is impossible as the EDSA tagger sets offload_fwd_mark
    on the skb when it unwraps the tagged frames, and that will make the
    switchdev layer prevent the skb from egressing on any other port of
    the same switch.
    
    To fix that, look at the To_CPU code in the DSA header and make
    forwarding of the frame possible for trapped IGMP packets.
    
    Introduce some #defines for the frame types to make the code a bit more
    comprehensive.
    
    This was tested on a Marvell 88E6352 variant.
    
    Signed-off-by: Daniel Mack <daniel@zonque.org>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index e8eaa804ccb9..d6200ff98200 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -13,6 +13,16 @@
 #define DSA_HLEN	4
 #define EDSA_HLEN	8
 
+#define FRAME_TYPE_TO_CPU	0x00
+#define FRAME_TYPE_FORWARD	0x03
+
+#define TO_CPU_CODE_MGMT_TRAP		0x00
+#define TO_CPU_CODE_FRAME2REG		0x01
+#define TO_CPU_CODE_IGMP_MLD_TRAP	0x02
+#define TO_CPU_CODE_POLICY_TRAP		0x03
+#define TO_CPU_CODE_ARP_MIRROR		0x04
+#define TO_CPU_CODE_POLICY_MIRROR	0x05
+
 static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct dsa_port *dp = dsa_slave_to_port(dev);
@@ -77,6 +87,8 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 				struct packet_type *pt)
 {
 	u8 *edsa_header;
+	int frame_type;
+	int code;
 	int source_device;
 	int source_port;
 
@@ -91,8 +103,29 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	/*
 	 * Check that frame type is either TO_CPU or FORWARD.
 	 */
-	if ((edsa_header[0] & 0xc0) != 0x00 && (edsa_header[0] & 0xc0) != 0xc0)
+	frame_type = edsa_header[0] >> 6;
+
+	switch (frame_type) {
+	case FRAME_TYPE_TO_CPU:
+		code = (edsa_header[1] & 0x6) | ((edsa_header[2] >> 4) & 1);
+
+		/*
+		 * Mark the frame to never egress on any port of the same switch
+		 * unless it's a trapped IGMP/MLD packet, in which case the
+		 * bridge might want to forward it.
+		 */
+		if (code != TO_CPU_CODE_IGMP_MLD_TRAP)
+			skb->offload_fwd_mark = 1;
+
+		break;
+
+	case FRAME_TYPE_FORWARD:
+		skb->offload_fwd_mark = 1;
+		break;
+
+	default:
 		return NULL;
+	}
 
 	/*
 	 * Determine source device and port.
@@ -156,8 +189,6 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 			2 * ETH_ALEN);
 	}
 
-	skb->offload_fwd_mark = 1;
-
 	return skb;
 }
 

commit f81a43e8da07ccd91c4d923a44ffffaeee39dcc8
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:21 2019 +0200

    dsa: Cleanup unneeded table and make tag structures static
    
    Now that tag drivers dynamically register, we don't need the static
    table. Remove it. This also means the tag driver structures can be
    made static.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 76bf3db4e9d4..e8eaa804ccb9 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -169,7 +169,7 @@ static int edsa_tag_flow_dissect(const struct sk_buff *skb, __be16 *proto,
 	return 0;
 }
 
-const struct dsa_device_ops edsa_netdev_ops = {
+static const struct dsa_device_ops edsa_netdev_ops = {
 	.name	= "edsa",
 	.proto	= DSA_TAG_PROTO_EDSA,
 	.xmit	= edsa_xmit,

commit d3b8c04988ca1685700e345a82a1396df79e6291
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:15 2019 +0200

    dsa: Add boilerplate helper to register DSA tag driver modules
    
    A DSA tag driver module will need to register the tag protocols it
    implements with the DSA core. Add macros containing this boiler plate.
    
    The registration/unregistration code is currently just a stub. A Later
    patch will add the real implementation.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    
    v2
    Fix indent of #endif
    Rewrite to move list pointer into a new structure
    v3
    Move kdoc next to macro
    Fix THIS_MODULE indentation
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 866d4e684511..76bf3db4e9d4 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -180,3 +180,5 @@ const struct dsa_device_ops edsa_netdev_ops = {
 
 MODULE_LICENSE("GPL");
 MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_EDSA);
+
+module_dsa_tag_driver(edsa_netdev_ops);

commit 056eed2fb071c11535527fc792bdfb985a9a3e26
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:14 2019 +0200

    dsa: Add TAG protocol to tag ops
    
    In order that we can match the tagging protocol a switch driver
    request to the tagger, we need to know what protocol the tagger
    supports. Add this information to the ops structure.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    
    v2
    More tag protocol to end of structure to keep hot members at the beginning.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index c4fddf7292cf..866d4e684511 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -171,6 +171,7 @@ static int edsa_tag_flow_dissect(const struct sk_buff *skb, __be16 *proto,
 
 const struct dsa_device_ops edsa_netdev_ops = {
 	.name	= "edsa",
+	.proto	= DSA_TAG_PROTO_EDSA,
 	.xmit	= edsa_xmit,
 	.rcv	= edsa_rcv,
 	.flow_dissect   = edsa_tag_flow_dissect,

commit f18bba50d24d014f22e439702c19b069d7e2b159
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:13 2019 +0200

    dsa: Add MODULE_LICENSE to tag drivers
    
    All the tag drivers are some variant of GPL. Add a MODULE_LICENSE()
    indicating this, so the drivers can later be compiled as modules.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index bad12e760f3d..c4fddf7292cf 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -177,4 +177,5 @@ const struct dsa_device_ops edsa_netdev_ops = {
 	.overhead = EDSA_HLEN,
 };
 
+MODULE_LICENSE("GPL");
 MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_EDSA);

commit 0b42f03363706609d621c31324fae5c1250f579f
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:12 2019 +0200

    dsa: Add MODULE_ALIAS to taggers in preparation to become modules
    
    When the tag drivers become modules, we will need to dynamically load
    them based on what the switch drivers need. Add aliases to map between
    the TAG protocol and the driver.
    
    In order to do this, we need the tag protocol number as something
    which the C pre-processor can stringinfy. Only the compiler knows the
    value of an enum, CPP cannot use them. So add #defines.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index b936b4660b71..bad12e760f3d 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -176,3 +176,5 @@ const struct dsa_device_ops edsa_netdev_ops = {
 	.flow_dissect   = edsa_tag_flow_dissect,
 	.overhead = EDSA_HLEN,
 };
+
+MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_EDSA);

commit 875138f81d71af3cfa80df57e32fe9efbc4f95bc
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:11 2019 +0200

    dsa: Move tagger name into its ops structure
    
    Rather than keep a list to map a tagger ops to a name, place the name
    into the ops structure. This removes the hard coded list, a step
    towards making the taggers more dynamic.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    
    v2:
    Move name to end of structure, keeping the hot entries at the beginning.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index df879445f658..b936b4660b71 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -170,6 +170,7 @@ static int edsa_tag_flow_dissect(const struct sk_buff *skb, __be16 *proto,
 }
 
 const struct dsa_device_ops edsa_netdev_ops = {
+	.name	= "edsa",
 	.xmit	= edsa_xmit,
 	.rcv	= edsa_rcv,
 	.flow_dissect   = edsa_tag_flow_dissect,

commit dfedd3b62441f4dfc56d191ac0ab63ec55a675e2
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:10 2019 +0200

    dsa: Add SPDX header to tag drivers.
    
    Add an SPDX header, and remove the license boilerplate text.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 234585ec116e..df879445f658 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -1,11 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * net/dsa/tag_edsa.c - Ethertype DSA tagging
  * Copyright (c) 2008-2009 Marvell Semiconductor
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #include <linux/etherdevice.h>

commit 57fd967838c665544f425c4a66ead1259a9ad0dc
Author: Rundong Ge <rdong.ge@gmail.com>
Date:   Sat Feb 16 08:35:24 2019 +0000

    net: dsa: Implement flow_dissect callback for tag_dsa.
    
    RPS not work for DSA devices since the 'skb_get_hash'
    will always get the invalid hash for dsa tagged packets.
    
    "[PATCH] tag_mtk: add flow_dissect callback to the ops struct"
    introduced the flow_dissect callback to get the right hash for
    MTK tagged packet. Tag_dsa and tag_edsa  also need to implement
    the callback.
    
    Signed-off-by: Rundong Ge <rdong.ge@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index f5b87ee5c94e..234585ec116e 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -165,8 +165,17 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	return skb;
 }
 
+static int edsa_tag_flow_dissect(const struct sk_buff *skb, __be16 *proto,
+				 int *offset)
+{
+	*offset = 8;
+	*proto = ((__be16 *)skb->data)[3];
+	return 0;
+}
+
 const struct dsa_device_ops edsa_netdev_ops = {
 	.xmit	= edsa_xmit,
 	.rcv	= edsa_rcv,
+	.flow_dissect   = edsa_tag_flow_dissect,
 	.overhead = EDSA_HLEN,
 };

commit a5dd308778a4e05e7b0b927cf18b89d1ebbff59c
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Thu Dec 6 11:36:04 2018 +0100

    net: dsa: Add overhead to tag protocol ops.
    
    Each DSA tag protocol needs to add additional headers to the Ethernet
    frame in order to direct it towards a specific switch egress port. It
    must also remove the head from a frame received from a
    switch. Indicate the maximum size of these headers in the tag protocol
    ops structure, so the core can take these overheads into account.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 4083326b806e..f5b87ee5c94e 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -168,4 +168,5 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 const struct dsa_device_ops edsa_netdev_ops = {
 	.xmit	= edsa_xmit,
 	.rcv	= edsa_rcv,
+	.overhead = EDSA_HLEN,
 };

commit 13edbdb6ed8b829ab3198a8c7b978c37184317b5
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Thu Nov 9 22:29:52 2017 +0100

    net: dsa: {e}dsa: set offload_fwd_mark on received packets
    
    The software bridge needs to know if a packet has already been bridged
    by hardware offload to ports in the same hardware offload, in order
    that it does not re-flood them, causing duplicates. This is
    particularly true for broadcast and multicast traffic which the host
    has requested.
    
    By setting offload_fwd_mark in the skb the bridge will only flood to
    ports in other offloads and other netifs. Set this flag in the DSA and
    EDSA tag driver.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index f38a626b3a05..4083326b806e 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -160,6 +160,8 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 			2 * ETH_ALEN);
 	}
 
+	skb->offload_fwd_mark = 1;
+
 	return skb;
 }
 

commit 2231c43b560403675217f52204b18c1c59c0ee76
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Oct 16 11:12:17 2017 -0400

    net: dsa: rename dsa_master_get_slave
    
    The dsa_master_get_slave is slightly confusing since the idiomatic "get"
    term often suggests reference counting, in symmetry to "put".
    
    Rename it to dsa_master_find_slave to make the look up operation clear.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index c683e240bafc..f38a626b3a05 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -104,7 +104,7 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	source_device = edsa_header[0] & 0x1f;
 	source_port = (edsa_header[1] >> 3) & 0x1f;
 
-	skb->dev = dsa_master_get_slave(dev, source_device, source_port);
+	skb->dev = dsa_master_find_slave(dev, source_device, source_port);
 	if (!skb->dev)
 		return NULL;
 

commit d945097bb19501bd95790d8220d4eeb418b6ebb2
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Oct 16 11:12:15 2017 -0400

    net: dsa: add slave to port helper
    
    Many portions of DSA core code require to get the dsa_port structure
    corresponding to a slave net_device. For this purpose, introduce a
    dsa_slave_to_port() helper.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 0b83cbe0c9e8..c683e240bafc 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -19,7 +19,7 @@
 
 static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct dsa_slave_priv *p = netdev_priv(dev);
+	struct dsa_port *dp = dsa_slave_to_port(dev);
 	u8 *edsa_header;
 
 	/*
@@ -43,8 +43,8 @@ static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 		edsa_header[1] = ETH_P_EDSA & 0xff;
 		edsa_header[2] = 0x00;
 		edsa_header[3] = 0x00;
-		edsa_header[4] = 0x60 | p->dp->ds->index;
-		edsa_header[5] = p->dp->index << 3;
+		edsa_header[4] = 0x60 | dp->ds->index;
+		edsa_header[5] = dp->index << 3;
 
 		/*
 		 * Move CFI field from byte 6 to byte 5.
@@ -68,8 +68,8 @@ static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 		edsa_header[1] = ETH_P_EDSA & 0xff;
 		edsa_header[2] = 0x00;
 		edsa_header[3] = 0x00;
-		edsa_header[4] = 0x40 | p->dp->ds->index;
-		edsa_header[5] = p->dp->index << 3;
+		edsa_header[4] = 0x40 | dp->ds->index;
+		edsa_header[5] = dp->index << 3;
 		edsa_header[6] = 0x00;
 		edsa_header[7] = 0x00;
 	}

commit 3775b1b7f0c330e59c434d1852d7762ae0a9c164
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Sep 29 17:19:15 2017 -0400

    net: dsa: add master helper to look up slaves
    
    The DSA tagging code does not need to know about the DSA architecture,
    it only needs to return the slave device corresponding to the source
    port index (and eventually the source device index for cascade-capable
    switches) parsed from the frame received on the master device.
    
    For this purpose, provide an inline dsa_master_get_slave helper which
    validates the device and port indexes and look up the slave device.
    
    This makes the tagging rcv functions more concise and robust, and also
    makes dsa_get_cpu_port obsolete.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 76367ba1b2e2..0b83cbe0c9e8 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -80,8 +80,6 @@ static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 				struct packet_type *pt)
 {
-	struct dsa_switch_tree *dst = dev->dsa_ptr;
-	struct dsa_switch *ds;
 	u8 *edsa_header;
 	int source_device;
 	int source_port;
@@ -106,18 +104,8 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	source_device = edsa_header[0] & 0x1f;
 	source_port = (edsa_header[1] >> 3) & 0x1f;
 
-	/*
-	 * Check that the source device exists and that the source
-	 * port is a registered DSA port.
-	 */
-	if (source_device >= DSA_MAX_SWITCHES)
-		return NULL;
-
-	ds = dst->ds[source_device];
-	if (!ds)
-		return NULL;
-
-	if (source_port >= ds->num_ports || !ds->ports[source_port].netdev)
+	skb->dev = dsa_master_get_slave(dev, source_device, source_port);
+	if (!skb->dev)
 		return NULL;
 
 	/*
@@ -172,8 +160,6 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 			2 * ETH_ALEN);
 	}
 
-	skb->dev = ds->ports[source_port].netdev;
-
 	return skb;
 }
 

commit 89e49506bc62520f93e64a278293444319a6aebb
Author: Florian Westphal <fw@strlen.de>
Date:   Thu Aug 17 16:47:00 2017 +0200

    dsa: remove unused net_device arg from handlers
    
    compile tested only, but saw no warnings/errors with
    allmodconfig build.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 67a9d26f9075..76367ba1b2e2 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -78,8 +78,7 @@ static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 }
 
 static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
-				struct packet_type *pt,
-				struct net_device *orig_dev)
+				struct packet_type *pt)
 {
 	struct dsa_switch_tree *dst = dev->dsa_ptr;
 	struct dsa_switch *ds;

commit fe47d563065c91cd30088d9b118b79d44905be6f
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Thu Jun 1 16:07:15 2017 -0400

    net: dsa: factor skb freeing on xmit
    
    As of a86d8becc3f0 ("net: dsa: Factor bottom tag receive functions"),
    the rcv caller frees the original SKB in case or error.
    
    Be symmetric with that and make the xmit caller do the same.
    
    At the same time, fix the checkpatch NULL comparison check:
    
            CHECK: Comparison to NULL could be written "!nskb"
        #208: FILE: net/dsa/tag_trailer.c:35:
        +   if (nskb == NULL)
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index a7eed1d43d80..67a9d26f9075 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -30,7 +30,7 @@ static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 	 */
 	if (skb->protocol == htons(ETH_P_8021Q)) {
 		if (skb_cow_head(skb, DSA_HLEN) < 0)
-			goto out_free;
+			return NULL;
 		skb_push(skb, DSA_HLEN);
 
 		memmove(skb->data, skb->data + DSA_HLEN, 2 * ETH_ALEN);
@@ -55,7 +55,7 @@ static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 		}
 	} else {
 		if (skb_cow_head(skb, EDSA_HLEN) < 0)
-			goto out_free;
+			return NULL;
 		skb_push(skb, EDSA_HLEN);
 
 		memmove(skb->data, skb->data + EDSA_HLEN, 2 * ETH_ALEN);
@@ -75,10 +75,6 @@ static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 	}
 
 	return skb;
-
-out_free:
-	kfree_skb(skb);
-	return NULL;
 }
 
 static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,

commit 5470979585d81271d4338c2accfd5e71dafa4af6
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Thu Jun 1 16:07:14 2017 -0400

    net: dsa: remove out_drop label in taggers rcv
    
    Many rcv functions from net/dsa/tag_*.c have a useless out_drop goto
    label which simply returns NULL. Kill it in favor of the obvious.
    
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index f95cafd05702..a7eed1d43d80 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -92,7 +92,7 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	int source_port;
 
 	if (unlikely(!pskb_may_pull(skb, EDSA_HLEN)))
-		goto out_drop;
+		return NULL;
 
 	/*
 	 * Skip the two null bytes after the ethertype.
@@ -103,7 +103,7 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	 * Check that frame type is either TO_CPU or FORWARD.
 	 */
 	if ((edsa_header[0] & 0xc0) != 0x00 && (edsa_header[0] & 0xc0) != 0xc0)
-		goto out_drop;
+		return NULL;
 
 	/*
 	 * Determine source device and port.
@@ -116,14 +116,14 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	 * port is a registered DSA port.
 	 */
 	if (source_device >= DSA_MAX_SWITCHES)
-		goto out_drop;
+		return NULL;
 
 	ds = dst->ds[source_device];
 	if (!ds)
-		goto out_drop;
+		return NULL;
 
 	if (source_port >= ds->num_ports || !ds->ports[source_port].netdev)
-		goto out_drop;
+		return NULL;
 
 	/*
 	 * If the 'tagged' bit is set, convert the DSA tag to a 802.1q
@@ -180,9 +180,6 @@ static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	skb->dev = ds->ports[source_port].netdev;
 
 	return skb;
-
-out_drop:
-	return NULL;
 }
 
 const struct dsa_device_ops edsa_netdev_ops = {

commit ea5dd34be1cfb2400587a24d1de75e538e77ce74
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Wed May 17 15:46:03 2017 -0400

    net: dsa: include dsa.h only once
    
    The public include/net/dsa.h file is meant for DSA drivers, while all
    DSA core files share a common private header net/dsa/dsa_priv.h file.
    
    Ensure that dsa_priv.h is the only DSA core file to include net/dsa.h,
    and add a new line to separate absolute and relative headers at the same
    time.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index d9c668aa5e54..f95cafd05702 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -11,7 +11,7 @@
 #include <linux/etherdevice.h>
 #include <linux/list.h>
 #include <linux/slab.h>
-#include <net/dsa.h>
+
 #include "dsa_priv.h"
 
 #define DSA_HLEN	4

commit a86d8becc3f04a5e350b5a17530e6a01495c00a5
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sat Apr 8 08:55:23 2017 -0700

    net: dsa: Factor bottom tag receive functions
    
    All DSA tag receive functions do strictly the same thing after they have located
    the originating source port from their tag specific protocol:
    
    - push ETH_HLEN bytes
    - set pkt_type to PACKET_HOST
    - call eth_type_trans()
    - bump up counters
    - call netif_receive_skb()
    
    Factor all of that into dsa_switch_rcv(). This also makes us return a pointer to
    a sk_buff, which makes us symetric with the xmit function.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index b87009672b40..d9c668aa5e54 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -81,8 +81,9 @@ static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 	return NULL;
 }
 
-static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
-		    struct packet_type *pt, struct net_device *orig_dev)
+static struct sk_buff *edsa_rcv(struct sk_buff *skb, struct net_device *dev,
+				struct packet_type *pt,
+				struct net_device *orig_dev)
 {
 	struct dsa_switch_tree *dst = dev->dsa_ptr;
 	struct dsa_switch *ds;
@@ -177,20 +178,11 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	}
 
 	skb->dev = ds->ports[source_port].netdev;
-	skb_push(skb, ETH_HLEN);
-	skb->pkt_type = PACKET_HOST;
-	skb->protocol = eth_type_trans(skb, skb->dev);
 
-	skb->dev->stats.rx_packets++;
-	skb->dev->stats.rx_bytes += skb->len;
-
-	netif_receive_skb(skb);
-
-	return 0;
+	return skb;
 
 out_drop:
-	kfree_skb(skb);
-	return 0;
+	return NULL;
 }
 
 const struct dsa_device_ops edsa_netdev_ops = {

commit 16c5dcb13a371feae0e680e6518775b5335b37d8
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sat Apr 8 08:55:22 2017 -0700

    net: dsa: Move skb_unshare() to dsa_switch_rcv()
    
    All DSA tag receive functions need to unshare the skb before mangling it, move
    this to the generic dsa_switch_rcv() function which will allow us to make the
    tag receive function return their mangled skb without caring about freeing a
    NULL skb.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 30520ff9c9a2..b87009672b40 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -90,10 +90,6 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	int source_device;
 	int source_port;
 
-	skb = skb_unshare(skb, GFP_ATOMIC);
-	if (skb == NULL)
-		goto out;
-
 	if (unlikely(!pskb_may_pull(skb, EDSA_HLEN)))
 		goto out_drop;
 
@@ -194,7 +190,6 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 
 out_drop:
 	kfree_skb(skb);
-out:
 	return 0;
 }
 

commit 9d7f9c4f78e95dd9d17199a53d903262530be62e
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sat Apr 8 08:55:21 2017 -0700

    net: dsa: Do not check for NULL dst in tag parsers
    
    dsa_switch_rcv() already tests for dst == NULL, so there is no need to duplicate
    the same check within the tag receive functions.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 6a9b7a9e4e15..30520ff9c9a2 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -90,9 +90,6 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	int source_device;
 	int source_port;
 
-	if (unlikely(dst == NULL))
-		goto out_drop;
-
 	skb = skb_unshare(skb, GFP_ATOMIC);
 	if (skb == NULL)
 		goto out;

commit c6e970a04bdceb7ef1fdbac6be3bd4cd0a0a02bd
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Tue Mar 28 23:45:06 2017 +0200

    net: break include loop netdevice.h, dsa.h, devlink.h
    
    There is an include loop between netdevice.h, dsa.h, devlink.h because
    of NETDEV_ALIGN, making it impossible to use devlink structures in
    dsa.h.
    
    Break this loop by taking dsa.h out of netdevice.h, add a forward
    declaration of dsa_switch_tree and netdev_set_default_ethtool_ops()
    function, which is what netdevice.h requires.
    
    No longer having dsa.h in netdevice.h means the includes in dsa.h no
    longer get included. This breaks a few other files which depend on
    these includes. Add these directly in the affected file.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 648c051817a1..6a9b7a9e4e15 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -11,6 +11,7 @@
 #include <linux/etherdevice.h>
 #include <linux/list.h>
 #include <linux/slab.h>
+#include <net/dsa.h>
 #include "dsa_priv.h"
 
 #define DSA_HLEN	4

commit afdcf151c1f7346207dcee3f8d6d82991dbbb7e5
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Jan 27 15:29:39 2017 -0500

    net: dsa: store a dsa_port in dsa_slave_priv
    
    Store a pointer to the dsa_port structure in the dsa_slave_priv
    structure, instead of the switch/port index.
    
    This will allow to store more information such as the bridge device,
    needed in DSA drivers for multi-chip configuration.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 929de581a846..648c051817a1 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -42,8 +42,8 @@ static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 		edsa_header[1] = ETH_P_EDSA & 0xff;
 		edsa_header[2] = 0x00;
 		edsa_header[3] = 0x00;
-		edsa_header[4] = 0x60 | p->parent->index;
-		edsa_header[5] = p->port << 3;
+		edsa_header[4] = 0x60 | p->dp->ds->index;
+		edsa_header[5] = p->dp->index << 3;
 
 		/*
 		 * Move CFI field from byte 6 to byte 5.
@@ -67,8 +67,8 @@ static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 		edsa_header[1] = ETH_P_EDSA & 0xff;
 		edsa_header[2] = 0x00;
 		edsa_header[3] = 0x00;
-		edsa_header[4] = 0x40 | p->parent->index;
-		edsa_header[5] = p->port << 3;
+		edsa_header[4] = 0x40 | p->dp->ds->index;
+		edsa_header[5] = p->dp->index << 3;
 		edsa_header[6] = 0x00;
 		edsa_header[7] = 0x00;
 	}

commit 26895e299cfb583d304553e9c259e694a7e83397
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Jan 27 15:29:37 2017 -0500

    net: dsa: use ds->num_ports when possible
    
    The dsa_switch structure contains the number of ports. Use it where the
    structure is valid instead of the DSA_MAX_PORTS value.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 6c1720e88537..929de581a846 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -127,7 +127,7 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	if (!ds)
 		goto out_drop;
 
-	if (source_port >= DSA_MAX_PORTS || !ds->ports[source_port].netdev)
+	if (source_port >= ds->num_ports || !ds->ports[source_port].netdev)
 		goto out_drop;
 
 	/*

commit c8b098086b4c744084350d2757a637ad756adf34
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Jun 4 21:16:57 2016 +0200

    net: dsa: Add a ports structure and use it in the switch structure
    
    There are going to be more per-port members added to the switch
    structure. So add a port structure and move the netdev into it.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 3890aac8190f..6c1720e88537 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -127,7 +127,7 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	if (!ds)
 		goto out_drop;
 
-	if (source_port >= DSA_MAX_PORTS || ds->ports[source_port] == NULL)
+	if (source_port >= DSA_MAX_PORTS || !ds->ports[source_port].netdev)
 		goto out_drop;
 
 	/*
@@ -182,7 +182,7 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 			2 * ETH_ALEN);
 	}
 
-	skb->dev = ds->ports[source_port];
+	skb->dev = ds->ports[source_port].netdev;
 	skb_push(skb, ETH_HLEN);
 	skb->pkt_type = PACKET_HOST;
 	skb->protocol = eth_type_trans(skb, skb->dev);

commit 149cafd790573294752787f5ce1dc0f99e4088d3
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Jun 4 21:16:56 2016 +0200

    net: dsa: tag_{e}dsa.c: Remove dependency on platform data
    
    The platform data nr_chips is used when validating a received packet,
    to ensure it comes from a know switch chip. The number of possible
    switches is limited to DSA_MAX_SWITCHES, so use this as the first
    validation step. The new binding allows holes in the dst->ds[] array,
    so also ensure ensure there is a valid dsa_switch for this packet.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 2288c8098c42..3890aac8190f 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -120,9 +120,13 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	 * Check that the source device exists and that the source
 	 * port is a registered DSA port.
 	 */
-	if (source_device >= dst->pd->nr_chips)
+	if (source_device >= DSA_MAX_SWITCHES)
 		goto out_drop;
+
 	ds = dst->ds[source_device];
+	if (!ds)
+		goto out_drop;
+
 	if (source_port >= DSA_MAX_PORTS || ds->ports[source_port] == NULL)
 		goto out_drop;
 

commit 4ed70ce9f01c998999e48642a768d9013bee2c4f
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Jul 31 11:42:56 2015 -0700

    net: dsa: Refactor transmit path to eliminate duplication
    
    All tagging protocols do the same thing: increment device statistics,
    make room for the tag to be inserted, create the tag, invoke the parent
    network device transmit function.
    
    In order to prepare for adding netpoll support, which requires the tag
    creation, but not using the parent network device transmit function, do
    some little refactoring which eliminates duplication between the 4
    tagging protocols supported.
    
    We need to return a sk_buff pointer back to the caller because the tag
    specific transmit function may have to reallocate the original skb (e.g:
    tag_trailer.c) and this is the one we should be transmitting, not the
    original sk_buff we were passed.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 9aeda596f7ec..2288c8098c42 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -16,14 +16,11 @@
 #define DSA_HLEN	4
 #define EDSA_HLEN	8
 
-static netdev_tx_t edsa_xmit(struct sk_buff *skb, struct net_device *dev)
+static struct sk_buff *edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct dsa_slave_priv *p = netdev_priv(dev);
 	u8 *edsa_header;
 
-	dev->stats.tx_packets++;
-	dev->stats.tx_bytes += skb->len;
-
 	/*
 	 * Convert the outermost 802.1q tag to a DSA tag and prepend
 	 * a DSA ethertype field is the packet is tagged, or insert
@@ -76,14 +73,11 @@ static netdev_tx_t edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 		edsa_header[7] = 0x00;
 	}
 
-	skb->dev = p->parent->dst->master_netdev;
-	dev_queue_xmit(skb);
-
-	return NETDEV_TX_OK;
+	return skb;
 
 out_free:
 	kfree_skb(skb);
-	return NETDEV_TX_OK;
+	return NULL;
 }
 
 static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,

commit 734cbb5b6bf9ee42ab4d71690fabf486b1f44502
Author: Guenter Roeck <linux@roeck-us.net>
Date:   Wed Oct 29 10:44:53 2014 -0700

    net: dsa: Don't set skb->protocol on outgoing tagged packets
    
    Setting skb->protocol to a private protocol type may result in warning
    messages such as
            e1000e 0000:00:19.0 em1: checksum_partial proto=dada!
    
    This happens if the L3 protocol is IP or IPv6 and skb->ip_summed is set
    to CHECKSUM_PARTIAL. Looking through the code, it appears that changing
    skb->protocol for transmitted packets is not necessary and may actually
    be harmful. For example, it prevents purposely unmodified (from a DSA
    perspective) network drivers from properly setting up their transmit
    checksum offload pointers since they inspect skb->protocol to set up the
    IPv4 header or IPv6 header pointers. So don't unnecessarily change the
    protocol field.
    
    Signed-off-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 94fcce778679..9aeda596f7ec 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -76,8 +76,6 @@ static netdev_tx_t edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 		edsa_header[7] = 0x00;
 	}
 
-	skb->protocol = htons(ETH_P_EDSA);
-
 	skb->dev = p->parent->dst->master_netdev;
 	dev_queue_xmit(skb);
 

commit 5075314e4e4b559cc37675ad8a721a89bccd6284
Author: Alexander Duyck <alexander.h.duyck@intel.com>
Date:   Mon Sep 15 13:00:19 2014 -0400

    dsa: Split ops up, and avoid assigning tag_protocol and receive separately
    
    This change addresses several issues.
    
    First, it was possible to set tag_protocol without setting the ops pointer.
    To correct that I have reordered things so that rcv is now populated before
    we set tag_protocol.
    
    Second, it didn't make much sense to keep setting the device ops each time a
    new slave was registered.  So by moving the receive portion out into root
    switch initialization that issue should be addressed.
    
    Third, I wanted to avoid sending tags if the rcv pointer was not registered
    so I changed the tag check to verify if the rcv function pointer is set on
    the root tree.  If it is then we start sending DSA tagged frames.
    
    Finally I split the device ops pointer in the structures into two spots.  I
    placed the rcv function pointer in the root switch since this makes it
    easiest to access from there, and I placed the xmit function pointer in the
    slave for the same reason.
    
    Signed-off-by: Alexander Duyck <alexander.h.duyck@intel.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 6b30abe89183..94fcce778679 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -10,7 +10,6 @@
 
 #include <linux/etherdevice.h>
 #include <linux/list.h>
-#include <linux/netdevice.h>
 #include <linux/slab.h>
 #include "dsa_priv.h"
 

commit 3e8a72d1dae374cf6fc1dba97cec663585845ff9
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Wed Aug 27 17:04:46 2014 -0700

    net: dsa: reduce number of protocol hooks
    
    DSA is currently registering one packet_type function per EtherType it
    needs to intercept in the receive path of a DSA-enabled Ethernet device.
    Right now we have three of them: trailer, DSA and eDSA, and there might
    be more in the future, this will not scale to the addition of new
    protocols.
    
    This patch proceeds with adding a new layer of abstraction and two new
    functions:
    
    dsa_switch_rcv() which will dispatch into the tag-protocol specific
    receive function implemented by net/dsa/tag_*.c
    
    dsa_slave_xmit() which will dispatch into the tag-protocol specific
    transmit function implemented by net/dsa/tag_*.c
    
    When we do create the per-port slave network devices, we iterate over
    the switch protocol to assign the DSA-specific receive and transmit
    operations.
    
    A new fake ethertype value is used: ETH_P_XDSA to illustrate the fact
    that this is no longer going to look like ETH_P_DSA or ETH_P_TRAILER
    like it used to be.
    
    This allows us to greatly simplify the check in eth_type_trans() and
    always override the skb->protocol with ETH_P_XDSA for Ethernet switches
    tagged protocol, while also reducing the number repetitive slave
    netdevice_ops assignments.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index e70c43c25e64..6b30abe89183 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -17,7 +17,7 @@
 #define DSA_HLEN	4
 #define EDSA_HLEN	8
 
-netdev_tx_t edsa_xmit(struct sk_buff *skb, struct net_device *dev)
+static netdev_tx_t edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct dsa_slave_priv *p = netdev_priv(dev);
 	u8 *edsa_header;
@@ -205,7 +205,7 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	return 0;
 }
 
-struct packet_type edsa_packet_type __read_mostly = {
-	.type	= cpu_to_be16(ETH_P_EDSA),
-	.func	= edsa_rcv,
+const struct dsa_device_ops edsa_netdev_ops = {
+	.xmit	= edsa_xmit,
+	.rcv	= edsa_rcv,
 };

commit 7df899c36cf09678bdef1824ce591ef4ac0e9864
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Fri Nov 25 14:35:02 2011 +0000

    dsa: Combine core and tagging code
    
    These files have circular dependencies, so if we make DSA modular then
    they must be built into the same module.  Therefore, link them
    together and merge their respective module init and exit functions.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 6f383322ad25..e70c43c25e64 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -205,20 +205,7 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	return 0;
 }
 
-static struct packet_type edsa_packet_type __read_mostly = {
+struct packet_type edsa_packet_type __read_mostly = {
 	.type	= cpu_to_be16(ETH_P_EDSA),
 	.func	= edsa_rcv,
 };
-
-static int __init edsa_init_module(void)
-{
-	dev_add_pack(&edsa_packet_type);
-	return 0;
-}
-module_init(edsa_init_module);
-
-static void __exit edsa_cleanup_module(void)
-{
-	dev_remove_pack(&edsa_packet_type);
-}
-module_exit(edsa_cleanup_module);

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 8f53948cff4f..6f383322ad25 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -11,6 +11,7 @@
 #include <linux/etherdevice.h>
 #include <linux/list.h>
 #include <linux/netdevice.h>
+#include <linux/slab.h>
 #include "dsa_priv.h"
 
 #define DSA_HLEN	4

commit 6fef4c0c8eeff7de13007a5f56113475444a253d
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Aug 31 19:50:41 2009 +0000

    netdev: convert pseudo-devices to netdev_tx_t
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 815607bd286f..8f53948cff4f 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -16,7 +16,7 @@
 #define DSA_HLEN	4
 #define EDSA_HLEN	8
 
-int edsa_xmit(struct sk_buff *skb, struct net_device *dev)
+netdev_tx_t edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 {
 	struct dsa_slave_priv *p = netdev_priv(dev);
 	u8 *edsa_header;

commit e84665c9cb4db963393fafad6fefe5efdd7e4a09
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Fri Mar 20 09:52:09 2009 +0000

    dsa: add switch chip cascading support
    
    The initial version of the DSA driver only supported a single switch
    chip per network interface, while DSA-capable switch chips can be
    interconnected to form a tree of switch chips.  This patch adds support
    for multiple switch chips on a network interface.
    
    An example topology for a 16-port device with an embedded CPU is as
    follows:
    
            +-----+          +--------+       +--------+
            |     |eth0    10| switch |9    10| switch |
            | CPU +----------+        +-------+        |
            |     |          | chip 0 |       | chip 1 |
            +-----+          +---++---+       +---++---+
                                 ||               ||
                                 ||               ||
                                 ||1000baseT      ||1000baseT
                                 ||ports 1-8      ||ports 9-16
    
    This requires a couple of interdependent changes in the DSA layer:
    
    - The dsa platform driver data needs to be extended: there is still
      only one netdevice per DSA driver instance (eth0 in the example
      above), but each of the switch chips in the tree needs its own
      mii_bus device pointer, MII management bus address, and port name
      array. (include/net/dsa.h)  The existing in-tree dsa users need
      some small changes to deal with this. (arch/arm)
    
    - The DSA and Ethertype DSA tagging modules need to be extended to
      use the DSA device ID field on receive and demultiplex the packet
      accordingly, and fill in the DSA device ID field on transmit
      according to which switch chip the packet is heading to.
      (net/dsa/tag_{dsa,edsa}.c)
    
    - The concept of "CPU port", which is the switch chip port that the
      CPU is connected to (port 10 on switch chip 0 in the example), needs
      to be extended with the concept of "upstream port", which is the
      port on the switch chip that will bring us one hop closer to the CPU
      (port 10 for both switch chips in the example above).
    
    - The dsa platform data needs to specify which ports on which switch
      chips are links to other switch chips, so that we can enable DSA
      tagging mode on them.  (For inter-switch links, we always use
      non-EtherType DSA tagging, since it has lower overhead.  The CPU
      link uses dsa or edsa tagging depending on what the 'root' switch
      chip supports.)  This is done by specifying "dsa" for the given
      port in the port array.
    
    - The dsa platform data needs to be extended with information on via
      which port to reach any given switch chip from any given switch chip.
      This info is specified via the per-switch chip data struct ->rtable[]
      array, which gives the nexthop ports for each of the other switches
      in the tree.
    
    For the example topology above, the dsa platform data would look
    something like this:
    
            static struct dsa_chip_data sw[2] = {
                    {
                            .mii_bus        = &foo,
                            .sw_addr        = 1,
                            .port_names[0]  = "p1",
                            .port_names[1]  = "p2",
                            .port_names[2]  = "p3",
                            .port_names[3]  = "p4",
                            .port_names[4]  = "p5",
                            .port_names[5]  = "p6",
                            .port_names[6]  = "p7",
                            .port_names[7]  = "p8",
                            .port_names[9]  = "dsa",
                            .port_names[10] = "cpu",
                            .rtable         = (s8 []){ -1, 9, },
                    }, {
                            .mii_bus        = &foo,
                            .sw_addr        = 2,
                            .port_names[0]  = "p9",
                            .port_names[1]  = "p10",
                            .port_names[2]  = "p11",
                            .port_names[3]  = "p12",
                            .port_names[4]  = "p13",
                            .port_names[5]  = "p14",
                            .port_names[6]  = "p15",
                            .port_names[7]  = "p16",
                            .port_names[10] = "dsa",
                            .rtable         = (s8 []){ 10, -1, },
                    },
            },
    
            static struct dsa_platform_data pd = {
                    .netdev         = &foo,
                    .nr_switches    = 2,
                    .sw             = sw,
            };
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Tested-by: Gary Thomas <gary@mlbassoc.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 16fcb6d196d4..815607bd286f 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -1,6 +1,6 @@
 /*
  * net/dsa/tag_edsa.c - Ethertype DSA tagging
- * Copyright (c) 2008 Marvell Semiconductor
+ * Copyright (c) 2008-2009 Marvell Semiconductor
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -45,7 +45,7 @@ int edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 		edsa_header[1] = ETH_P_EDSA & 0xff;
 		edsa_header[2] = 0x00;
 		edsa_header[3] = 0x00;
-		edsa_header[4] = 0x60;
+		edsa_header[4] = 0x60 | p->parent->index;
 		edsa_header[5] = p->port << 3;
 
 		/*
@@ -70,7 +70,7 @@ int edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 		edsa_header[1] = ETH_P_EDSA & 0xff;
 		edsa_header[2] = 0x00;
 		edsa_header[3] = 0x00;
-		edsa_header[4] = 0x40;
+		edsa_header[4] = 0x40 | p->parent->index;
 		edsa_header[5] = p->port << 3;
 		edsa_header[6] = 0x00;
 		edsa_header[7] = 0x00;
@@ -78,7 +78,7 @@ int edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	skb->protocol = htons(ETH_P_EDSA);
 
-	skb->dev = p->parent->master_netdev;
+	skb->dev = p->parent->dst->master_netdev;
 	dev_queue_xmit(skb);
 
 	return NETDEV_TX_OK;
@@ -91,11 +91,13 @@ int edsa_xmit(struct sk_buff *skb, struct net_device *dev)
 static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 		    struct packet_type *pt, struct net_device *orig_dev)
 {
-	struct dsa_switch *ds = dev->dsa_ptr;
+	struct dsa_switch_tree *dst = dev->dsa_ptr;
+	struct dsa_switch *ds;
 	u8 *edsa_header;
+	int source_device;
 	int source_port;
 
-	if (unlikely(ds == NULL))
+	if (unlikely(dst == NULL))
 		goto out_drop;
 
 	skb = skb_unshare(skb, GFP_ATOMIC);
@@ -111,16 +113,24 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	edsa_header = skb->data + 2;
 
 	/*
-	 * Check that frame type is either TO_CPU or FORWARD, and
-	 * that the source device is zero.
+	 * Check that frame type is either TO_CPU or FORWARD.
 	 */
-	if ((edsa_header[0] & 0xdf) != 0x00 && (edsa_header[0] & 0xdf) != 0xc0)
+	if ((edsa_header[0] & 0xc0) != 0x00 && (edsa_header[0] & 0xc0) != 0xc0)
 		goto out_drop;
 
 	/*
-	 * Check that the source port is a registered DSA port.
+	 * Determine source device and port.
 	 */
+	source_device = edsa_header[0] & 0x1f;
 	source_port = (edsa_header[1] >> 3) & 0x1f;
+
+	/*
+	 * Check that the source device exists and that the source
+	 * port is a registered DSA port.
+	 */
+	if (source_device >= dst->pd->nr_chips)
+		goto out_drop;
+	ds = dst->ds[source_device];
 	if (source_port >= DSA_MAX_PORTS || ds->ports[source_port] == NULL)
 		goto out_drop;
 

commit 7546dd97d27306d939c13e03318aae695badaa88
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Mon Mar 9 08:18:29 2009 +0000

    net: convert usage of packet_type to read_mostly
    
    Protocols that use packet_type can be __read_mostly section for better
    locality. Elminate any unnecessary initializations of NULL.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 6197f9a7ef42..16fcb6d196d4 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -194,7 +194,7 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	return 0;
 }
 
-static struct packet_type edsa_packet_type = {
+static struct packet_type edsa_packet_type __read_mostly = {
 	.type	= cpu_to_be16(ETH_P_EDSA),
 	.func	= edsa_rcv,
 };

commit 09640e6365c679b5642b1c41b6d7078f51689ddf
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Sun Feb 1 00:45:17 2009 -0800

    net: replace uses of __constant_{endian}
    
    Base versions handle constant folding now.
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index 328ec957f786..6197f9a7ef42 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -195,7 +195,7 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 }
 
 static struct packet_type edsa_packet_type = {
-	.type	= __constant_htons(ETH_P_EDSA),
+	.type	= cpu_to_be16(ETH_P_EDSA),
 	.func	= edsa_rcv,
 };
 

commit 7e452baf6b96b5aeba097afd91501d33d390cc97
Merge: 3ac38c3a2e7d f21f237cf554
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Nov 11 15:43:02 2008 -0800

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
    
            drivers/message/fusion/mptlan.c
            drivers/net/sfc/ethtool.c
            net/mac80211/debugfs_sta.c

commit 14ee6742b1b5df275cd2d771b4562b4f808c9419
Author: Lennert Buytenhek <buytenh@marvell.com>
Date:   Mon Nov 10 21:52:42 2008 -0800

    dsa: fix skb->pkt_type when mac address of slave interface differs
    
    When a dsa slave interface has a mac address that differs from that
    of the master interface, eth_type_trans() won't explicitly set
    skb->pkt_type back to PACKET_HOST -- we need to do this ourselves
    before calling eth_type_trans().
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index f985ea993843..9f4ce55eae59 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -178,6 +178,7 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 
 	skb->dev = ds->ports[source_port];
 	skb_push(skb, ETH_HLEN);
+	skb->pkt_type = PACKET_HOST;
 	skb->protocol = eth_type_trans(skb, skb->dev);
 
 	skb->dev->last_rx = jiffies;

commit d2ad3ca88da02baeccd5216780f1fe983c6953ba
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Nov 3 22:01:07 2008 -0800

    net/: Kill now superfluous ->last_rx stores.
    
    The generic packet receive code takes care of setting
    netdev->last_rx when necessary, for the sake of the
    bonding ARP monitor.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
index f985ea993843..24b1c76fa7a4 100644
--- a/net/dsa/tag_edsa.c
+++ b/net/dsa/tag_edsa.c
@@ -180,7 +180,6 @@ static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
 	skb_push(skb, ETH_HLEN);
 	skb->protocol = eth_type_trans(skb, skb->dev);
 
-	skb->dev->last_rx = jiffies;
 	skb->dev->stats.rx_packets++;
 	skb->dev->stats.rx_bytes += skb->len;
 

commit 91da11f870f00a3322b81c73042291d7f0be5a17
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Tue Oct 7 13:44:02 2008 +0000

    net: Distributed Switch Architecture protocol support
    
    Distributed Switch Architecture is a protocol for managing hardware
    switch chips.  It consists of a set of MII management registers and
    commands to configure the switch, and an ethernet header format to
    signal which of the ports of the switch a packet was received from
    or is intended to be sent to.
    
    The switches that this driver supports are typically embedded in
    access points and routers, and a typical setup with a DSA switch
    looks something like this:
    
            +-----------+       +-----------+
            |           | RGMII |           |
            |           +-------+           +------ 1000baseT MDI ("WAN")
            |           |       |  6-port   +------ 1000baseT MDI ("LAN1")
            |    CPU    |       |  ethernet +------ 1000baseT MDI ("LAN2")
            |           |MIImgmt|  switch   +------ 1000baseT MDI ("LAN3")
            |           +-------+  w/5 PHYs +------ 1000baseT MDI ("LAN4")
            |           |       |           |
            +-----------+       +-----------+
    
    The switch driver presents each port on the switch as a separate
    network interface to Linux, polls the switch to maintain software
    link state of those ports, forwards MII management interface
    accesses to those network interfaces (e.g. as done by ethtool) to
    the switch, and exposes the switch's hardware statistics counters
    via the appropriate Linux kernel interfaces.
    
    This initial patch supports the MII management interface register
    layout of the Marvell 88E6123, 88E6161 and 88E6165 switch chips, and
    supports the "Ethertype DSA" packet tagging format.
    
    (There is no officially registered ethertype for the Ethertype DSA
    packet format, so we just grab a random one.  The ethertype to use
    is programmed into the switch, and the switch driver uses the value
    of ETH_P_EDSA for this, so this define can be changed at any time in
    the future if the one we chose is allocated to another protocol or
    if Ethertype DSA gets its own officially registered ethertype, and
    everything will continue to work.)
    
    Signed-off-by: Lennert Buytenhek <buytenh@marvell.com>
    Tested-by: Nicolas Pitre <nico@marvell.com>
    Tested-by: Byron Bradley <byron.bbradley@gmail.com>
    Tested-by: Tim Ellis <tim.ellis@mac.com>
    Tested-by: Peter van Valderen <linux@ddcrew.com>
    Tested-by: Dirk Teurlings <dirk@upexia.nl>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_edsa.c b/net/dsa/tag_edsa.c
new file mode 100644
index 000000000000..f985ea993843
--- /dev/null
+++ b/net/dsa/tag_edsa.c
@@ -0,0 +1,213 @@
+/*
+ * net/dsa/tag_edsa.c - Ethertype DSA tagging
+ * Copyright (c) 2008 Marvell Semiconductor
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/list.h>
+#include <linux/netdevice.h>
+#include "dsa_priv.h"
+
+#define DSA_HLEN	4
+#define EDSA_HLEN	8
+
+int edsa_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct dsa_slave_priv *p = netdev_priv(dev);
+	u8 *edsa_header;
+
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
+
+	/*
+	 * Convert the outermost 802.1q tag to a DSA tag and prepend
+	 * a DSA ethertype field is the packet is tagged, or insert
+	 * a DSA ethertype plus DSA tag between the addresses and the
+	 * current ethertype field if the packet is untagged.
+	 */
+	if (skb->protocol == htons(ETH_P_8021Q)) {
+		if (skb_cow_head(skb, DSA_HLEN) < 0)
+			goto out_free;
+		skb_push(skb, DSA_HLEN);
+
+		memmove(skb->data, skb->data + DSA_HLEN, 2 * ETH_ALEN);
+
+		/*
+		 * Construct tagged FROM_CPU DSA tag from 802.1q tag.
+		 */
+		edsa_header = skb->data + 2 * ETH_ALEN;
+		edsa_header[0] = (ETH_P_EDSA >> 8) & 0xff;
+		edsa_header[1] = ETH_P_EDSA & 0xff;
+		edsa_header[2] = 0x00;
+		edsa_header[3] = 0x00;
+		edsa_header[4] = 0x60;
+		edsa_header[5] = p->port << 3;
+
+		/*
+		 * Move CFI field from byte 6 to byte 5.
+		 */
+		if (edsa_header[6] & 0x10) {
+			edsa_header[5] |= 0x01;
+			edsa_header[6] &= ~0x10;
+		}
+	} else {
+		if (skb_cow_head(skb, EDSA_HLEN) < 0)
+			goto out_free;
+		skb_push(skb, EDSA_HLEN);
+
+		memmove(skb->data, skb->data + EDSA_HLEN, 2 * ETH_ALEN);
+
+		/*
+		 * Construct untagged FROM_CPU DSA tag.
+		 */
+		edsa_header = skb->data + 2 * ETH_ALEN;
+		edsa_header[0] = (ETH_P_EDSA >> 8) & 0xff;
+		edsa_header[1] = ETH_P_EDSA & 0xff;
+		edsa_header[2] = 0x00;
+		edsa_header[3] = 0x00;
+		edsa_header[4] = 0x40;
+		edsa_header[5] = p->port << 3;
+		edsa_header[6] = 0x00;
+		edsa_header[7] = 0x00;
+	}
+
+	skb->protocol = htons(ETH_P_EDSA);
+
+	skb->dev = p->parent->master_netdev;
+	dev_queue_xmit(skb);
+
+	return NETDEV_TX_OK;
+
+out_free:
+	kfree_skb(skb);
+	return NETDEV_TX_OK;
+}
+
+static int edsa_rcv(struct sk_buff *skb, struct net_device *dev,
+		    struct packet_type *pt, struct net_device *orig_dev)
+{
+	struct dsa_switch *ds = dev->dsa_ptr;
+	u8 *edsa_header;
+	int source_port;
+
+	if (unlikely(ds == NULL))
+		goto out_drop;
+
+	skb = skb_unshare(skb, GFP_ATOMIC);
+	if (skb == NULL)
+		goto out;
+
+	if (unlikely(!pskb_may_pull(skb, EDSA_HLEN)))
+		goto out_drop;
+
+	/*
+	 * Skip the two null bytes after the ethertype.
+	 */
+	edsa_header = skb->data + 2;
+
+	/*
+	 * Check that frame type is either TO_CPU or FORWARD, and
+	 * that the source device is zero.
+	 */
+	if ((edsa_header[0] & 0xdf) != 0x00 && (edsa_header[0] & 0xdf) != 0xc0)
+		goto out_drop;
+
+	/*
+	 * Check that the source port is a registered DSA port.
+	 */
+	source_port = (edsa_header[1] >> 3) & 0x1f;
+	if (source_port >= DSA_MAX_PORTS || ds->ports[source_port] == NULL)
+		goto out_drop;
+
+	/*
+	 * If the 'tagged' bit is set, convert the DSA tag to a 802.1q
+	 * tag and delete the ethertype part.  If the 'tagged' bit is
+	 * clear, delete the ethertype and the DSA tag parts.
+	 */
+	if (edsa_header[0] & 0x20) {
+		u8 new_header[4];
+
+		/*
+		 * Insert 802.1q ethertype and copy the VLAN-related
+		 * fields, but clear the bit that will hold CFI (since
+		 * DSA uses that bit location for another purpose).
+		 */
+		new_header[0] = (ETH_P_8021Q >> 8) & 0xff;
+		new_header[1] = ETH_P_8021Q & 0xff;
+		new_header[2] = edsa_header[2] & ~0x10;
+		new_header[3] = edsa_header[3];
+
+		/*
+		 * Move CFI bit from its place in the DSA header to
+		 * its 802.1q-designated place.
+		 */
+		if (edsa_header[1] & 0x01)
+			new_header[2] |= 0x10;
+
+		skb_pull_rcsum(skb, DSA_HLEN);
+
+		/*
+		 * Update packet checksum if skb is CHECKSUM_COMPLETE.
+		 */
+		if (skb->ip_summed == CHECKSUM_COMPLETE) {
+			__wsum c = skb->csum;
+			c = csum_add(c, csum_partial(new_header + 2, 2, 0));
+			c = csum_sub(c, csum_partial(edsa_header + 2, 2, 0));
+			skb->csum = c;
+		}
+
+		memcpy(edsa_header, new_header, DSA_HLEN);
+
+		memmove(skb->data - ETH_HLEN,
+			skb->data - ETH_HLEN - DSA_HLEN,
+			2 * ETH_ALEN);
+	} else {
+		/*
+		 * Remove DSA tag and update checksum.
+		 */
+		skb_pull_rcsum(skb, EDSA_HLEN);
+		memmove(skb->data - ETH_HLEN,
+			skb->data - ETH_HLEN - EDSA_HLEN,
+			2 * ETH_ALEN);
+	}
+
+	skb->dev = ds->ports[source_port];
+	skb_push(skb, ETH_HLEN);
+	skb->protocol = eth_type_trans(skb, skb->dev);
+
+	skb->dev->last_rx = jiffies;
+	skb->dev->stats.rx_packets++;
+	skb->dev->stats.rx_bytes += skb->len;
+
+	netif_receive_skb(skb);
+
+	return 0;
+
+out_drop:
+	kfree_skb(skb);
+out:
+	return 0;
+}
+
+static struct packet_type edsa_packet_type = {
+	.type	= __constant_htons(ETH_P_EDSA),
+	.func	= edsa_rcv,
+};
+
+static int __init edsa_init_module(void)
+{
+	dev_add_pack(&edsa_packet_type);
+	return 0;
+}
+module_init(edsa_init_module);
+
+static void __exit edsa_cleanup_module(void)
+{
+	dev_remove_pack(&edsa_packet_type);
+}
+module_exit(edsa_cleanup_module);
