commit 4249c507f4cbedbe0afc75a43a8808ee072f87b9
Author: Michael Grzeschik <m.grzeschik@pengutronix.de>
Date:   Wed Dec 18 17:01:39 2019 +0100

    net: dsa: ksz: use common define for tag len
    
    Remove special taglen define KSZ8795_INGRESS_TAG_LEN
    and use generic KSZ_INGRESS_TAG_LEN instead.
    
    Signed-off-by: Michael Grzeschik <m.grzeschik@pengutronix.de>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 73605bcbb385..90d055c4df9e 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -84,8 +84,6 @@ static struct sk_buff *ksz_common_rcv(struct sk_buff *skb,
  *	  (eg, 0x00=port1, 0x02=port3, 0x06=port7)
  */
 
-#define KSZ8795_INGRESS_TAG_LEN		1
-
 #define KSZ8795_TAIL_TAG_OVERRIDE	BIT(6)
 #define KSZ8795_TAIL_TAG_LOOKUP		BIT(7)
 
@@ -96,12 +94,12 @@ static struct sk_buff *ksz8795_xmit(struct sk_buff *skb, struct net_device *dev)
 	u8 *tag;
 	u8 *addr;
 
-	nskb = ksz_common_xmit(skb, dev, KSZ8795_INGRESS_TAG_LEN);
+	nskb = ksz_common_xmit(skb, dev, KSZ_INGRESS_TAG_LEN);
 	if (!nskb)
 		return NULL;
 
 	/* Tag encoding */
-	tag = skb_put(nskb, KSZ8795_INGRESS_TAG_LEN);
+	tag = skb_put(nskb, KSZ_INGRESS_TAG_LEN);
 	addr = skb_mac_header(nskb);
 
 	*tag = 1 << dp->index;
@@ -124,7 +122,7 @@ static const struct dsa_device_ops ksz8795_netdev_ops = {
 	.proto	= DSA_TAG_PROTO_KSZ8795,
 	.xmit	= ksz8795_xmit,
 	.rcv	= ksz8795_rcv,
-	.overhead = KSZ8795_INGRESS_TAG_LEN,
+	.overhead = KSZ_INGRESS_TAG_LEN,
 };
 
 DSA_TAG_DRIVER(ksz8795_netdev_ops);

commit 016e43a26bab0126e33c9682f9d9d05eca9f0386
Author: Tristram Ha <Tristram.Ha@microchip.com>
Date:   Mon Jul 29 19:49:46 2019 +0200

    net: dsa: ksz: Add KSZ8795 tag code
    
    Add DSA tag code for Microchip KSZ8795 switch. The switch is simpler
    and the tag is only 1 byte, instead of 2 as is the case with KSZ9477.
    
    Signed-off-by: Tristram Ha <Tristram.Ha@microchip.com>
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Tristram Ha <Tristram.Ha@microchip.com>
    Cc: Vivien Didelot <vivien.didelot@gmail.com>
    Cc: Woojung Huh <woojung.huh@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index b4872b87d4a6..73605bcbb385 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -69,6 +69,67 @@ static struct sk_buff *ksz_common_rcv(struct sk_buff *skb,
 	return skb;
 }
 
+/*
+ * For Ingress (Host -> KSZ8795), 1 byte is added before FCS.
+ * ---------------------------------------------------------------------------
+ * DA(6bytes)|SA(6bytes)|....|Data(nbytes)|tag(1byte)|FCS(4bytes)
+ * ---------------------------------------------------------------------------
+ * tag : each bit represents port (eg, 0x01=port1, 0x02=port2, 0x10=port5)
+ *
+ * For Egress (KSZ8795 -> Host), 1 byte is added before FCS.
+ * ---------------------------------------------------------------------------
+ * DA(6bytes)|SA(6bytes)|....|Data(nbytes)|tag0(1byte)|FCS(4bytes)
+ * ---------------------------------------------------------------------------
+ * tag0 : zero-based value represents port
+ *	  (eg, 0x00=port1, 0x02=port3, 0x06=port7)
+ */
+
+#define KSZ8795_INGRESS_TAG_LEN		1
+
+#define KSZ8795_TAIL_TAG_OVERRIDE	BIT(6)
+#define KSZ8795_TAIL_TAG_LOOKUP		BIT(7)
+
+static struct sk_buff *ksz8795_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct dsa_port *dp = dsa_slave_to_port(dev);
+	struct sk_buff *nskb;
+	u8 *tag;
+	u8 *addr;
+
+	nskb = ksz_common_xmit(skb, dev, KSZ8795_INGRESS_TAG_LEN);
+	if (!nskb)
+		return NULL;
+
+	/* Tag encoding */
+	tag = skb_put(nskb, KSZ8795_INGRESS_TAG_LEN);
+	addr = skb_mac_header(nskb);
+
+	*tag = 1 << dp->index;
+	if (is_link_local_ether_addr(addr))
+		*tag |= KSZ8795_TAIL_TAG_OVERRIDE;
+
+	return nskb;
+}
+
+static struct sk_buff *ksz8795_rcv(struct sk_buff *skb, struct net_device *dev,
+				  struct packet_type *pt)
+{
+	u8 *tag = skb_tail_pointer(skb) - KSZ_EGRESS_TAG_LEN;
+
+	return ksz_common_rcv(skb, dev, tag[0] & 7, KSZ_EGRESS_TAG_LEN);
+}
+
+static const struct dsa_device_ops ksz8795_netdev_ops = {
+	.name	= "ksz8795",
+	.proto	= DSA_TAG_PROTO_KSZ8795,
+	.xmit	= ksz8795_xmit,
+	.rcv	= ksz8795_rcv,
+	.overhead = KSZ8795_INGRESS_TAG_LEN,
+};
+
+DSA_TAG_DRIVER(ksz8795_netdev_ops);
+MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_KSZ8795);
+
 /*
  * For Ingress (Host -> KSZ9477), 2 bytes are added before FCS.
  * ---------------------------------------------------------------------------
@@ -183,6 +244,7 @@ DSA_TAG_DRIVER(ksz9893_netdev_ops);
 MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_KSZ9893);
 
 static struct dsa_tag_driver *dsa_tag_driver_array[] = {
+	&DSA_TAG_DRIVER_NAME(ksz8795_netdev_ops),
 	&DSA_TAG_DRIVER_NAME(ksz9477_netdev_ops),
 	&DSA_TAG_DRIVER_NAME(ksz9893_netdev_ops),
 };

commit f81a43e8da07ccd91c4d923a44ffffaeee39dcc8
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:21 2019 +0200

    dsa: Cleanup unneeded table and make tag structures static
    
    Now that tag drivers dynamically register, we don't need the static
    table. Remove it. This also means the tag driver structures can be
    made static.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 02689ac6f9da..b4872b87d4a6 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -133,7 +133,7 @@ static struct sk_buff *ksz9477_rcv(struct sk_buff *skb, struct net_device *dev,
 	return ksz_common_rcv(skb, dev, port, len);
 }
 
-const struct dsa_device_ops ksz9477_netdev_ops = {
+static const struct dsa_device_ops ksz9477_netdev_ops = {
 	.name	= "ksz9477",
 	.proto	= DSA_TAG_PROTO_KSZ9477,
 	.xmit	= ksz9477_xmit,
@@ -171,7 +171,7 @@ static struct sk_buff *ksz9893_xmit(struct sk_buff *skb,
 	return nskb;
 }
 
-const struct dsa_device_ops ksz9893_netdev_ops = {
+static const struct dsa_device_ops ksz9893_netdev_ops = {
 	.name	= "ksz9893",
 	.proto	= DSA_TAG_PROTO_KSZ9893,
 	.xmit	= ksz9893_xmit,

commit d3b8c04988ca1685700e345a82a1396df79e6291
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:15 2019 +0200

    dsa: Add boilerplate helper to register DSA tag driver modules
    
    A DSA tag driver module will need to register the tag protocols it
    implements with the DSA core. Add macros containing this boiler plate.
    
    The registration/unregistration code is currently just a stub. A Later
    patch will add the real implementation.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    
    v2
    Fix indent of #endif
    Rewrite to move list pointer into a new structure
    v3
    Move kdoc next to macro
    Fix THIS_MODULE indentation
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 5f5c8f9a6141..02689ac6f9da 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -141,6 +141,7 @@ const struct dsa_device_ops ksz9477_netdev_ops = {
 	.overhead = KSZ9477_INGRESS_TAG_LEN,
 };
 
+DSA_TAG_DRIVER(ksz9477_netdev_ops);
 MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_KSZ9477);
 
 #define KSZ9893_TAIL_TAG_OVERRIDE	BIT(5)
@@ -178,5 +179,14 @@ const struct dsa_device_ops ksz9893_netdev_ops = {
 	.overhead = KSZ_INGRESS_TAG_LEN,
 };
 
-MODULE_LICENSE("GPL");
+DSA_TAG_DRIVER(ksz9893_netdev_ops);
 MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_KSZ9893);
+
+static struct dsa_tag_driver *dsa_tag_driver_array[] = {
+	&DSA_TAG_DRIVER_NAME(ksz9477_netdev_ops),
+	&DSA_TAG_DRIVER_NAME(ksz9893_netdev_ops),
+};
+
+module_dsa_tag_drivers(dsa_tag_driver_array);
+
+MODULE_LICENSE("GPL");

commit 056eed2fb071c11535527fc792bdfb985a9a3e26
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:14 2019 +0200

    dsa: Add TAG protocol to tag ops
    
    In order that we can match the tagging protocol a switch driver
    request to the tagger, we need to know what protocol the tagger
    supports. Add this information to the ops structure.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    
    v2
    More tag protocol to end of structure to keep hot members at the beginning.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 6d78d88270fc..5f5c8f9a6141 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -135,6 +135,7 @@ static struct sk_buff *ksz9477_rcv(struct sk_buff *skb, struct net_device *dev,
 
 const struct dsa_device_ops ksz9477_netdev_ops = {
 	.name	= "ksz9477",
+	.proto	= DSA_TAG_PROTO_KSZ9477,
 	.xmit	= ksz9477_xmit,
 	.rcv	= ksz9477_rcv,
 	.overhead = KSZ9477_INGRESS_TAG_LEN,
@@ -171,6 +172,7 @@ static struct sk_buff *ksz9893_xmit(struct sk_buff *skb,
 
 const struct dsa_device_ops ksz9893_netdev_ops = {
 	.name	= "ksz9893",
+	.proto	= DSA_TAG_PROTO_KSZ9893,
 	.xmit	= ksz9893_xmit,
 	.rcv	= ksz9477_rcv,
 	.overhead = KSZ_INGRESS_TAG_LEN,

commit f18bba50d24d014f22e439702c19b069d7e2b159
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:13 2019 +0200

    dsa: Add MODULE_LICENSE to tag drivers
    
    All the tag drivers are some variant of GPL. Add a MODULE_LICENSE()
    indicating this, so the drivers can later be compiled as modules.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 9be0f5f12afb..6d78d88270fc 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -176,4 +176,5 @@ const struct dsa_device_ops ksz9893_netdev_ops = {
 	.overhead = KSZ_INGRESS_TAG_LEN,
 };
 
+MODULE_LICENSE("GPL");
 MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_KSZ9893);

commit 0b42f03363706609d621c31324fae5c1250f579f
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:12 2019 +0200

    dsa: Add MODULE_ALIAS to taggers in preparation to become modules
    
    When the tag drivers become modules, we will need to dynamically load
    them based on what the switch drivers need. Add aliases to map between
    the TAG protocol and the driver.
    
    In order to do this, we need the tag protocol number as something
    which the C pre-processor can stringinfy. Only the compiler knows the
    value of an enum, CPP cannot use them. So add #defines.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 631094599514..9be0f5f12afb 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -140,6 +140,8 @@ const struct dsa_device_ops ksz9477_netdev_ops = {
 	.overhead = KSZ9477_INGRESS_TAG_LEN,
 };
 
+MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_KSZ9477);
+
 #define KSZ9893_TAIL_TAG_OVERRIDE	BIT(5)
 #define KSZ9893_TAIL_TAG_LOOKUP		BIT(6)
 
@@ -173,3 +175,5 @@ const struct dsa_device_ops ksz9893_netdev_ops = {
 	.rcv	= ksz9477_rcv,
 	.overhead = KSZ_INGRESS_TAG_LEN,
 };
+
+MODULE_ALIAS_DSA_TAG_DRIVER(DSA_TAG_PROTO_KSZ9893);

commit 875138f81d71af3cfa80df57e32fe9efbc4f95bc
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:11 2019 +0200

    dsa: Move tagger name into its ops structure
    
    Rather than keep a list to map a tagger ops to a name, place the name
    into the ops structure. This removes the hard coded list, a step
    towards making the taggers more dynamic.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    
    v2:
    Move name to end of structure, keeping the hot entries at the beginning.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 12b2f58786ee..631094599514 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -134,6 +134,7 @@ static struct sk_buff *ksz9477_rcv(struct sk_buff *skb, struct net_device *dev,
 }
 
 const struct dsa_device_ops ksz9477_netdev_ops = {
+	.name	= "ksz9477",
 	.xmit	= ksz9477_xmit,
 	.rcv	= ksz9477_rcv,
 	.overhead = KSZ9477_INGRESS_TAG_LEN,
@@ -167,6 +168,7 @@ static struct sk_buff *ksz9893_xmit(struct sk_buff *skb,
 }
 
 const struct dsa_device_ops ksz9893_netdev_ops = {
+	.name	= "ksz9893",
 	.xmit	= ksz9893_xmit,
 	.rcv	= ksz9477_rcv,
 	.overhead = KSZ_INGRESS_TAG_LEN,

commit dfedd3b62441f4dfc56d191ac0ab63ec55a675e2
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:10 2019 +0200

    dsa: Add SPDX header to tag drivers.
    
    Add an SPDX header, and remove the license boilerplate text.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index de246c93d3bb..12b2f58786ee 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -1,11 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0+
 /*
  * net/dsa/tag_ksz.c - Microchip KSZ Switch tag format handling
  * Copyright (c) 2017 Microchip Technology
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #include <linux/etherdevice.h>

commit 88b573af91dafd60ba35b2dc6af3f9d8d7168146
Author: Tristram Ha <Tristram.Ha@microchip.com>
Date:   Thu Feb 28 19:57:23 2019 -0800

    net: dsa: add KSZ9893 switch tagging support
    
    KSZ9893 switch is similar to KSZ9477 switch except the ingress tail tag
    has 1 byte instead of 2 bytes.  The size of the portmap is smaller and
    so the override and lookup bits are also moved.
    
    Signed-off-by: Tristram Ha <Tristram.Ha@microchip.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 927e9c86f745..de246c93d3bb 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -16,6 +16,7 @@
 
 /* Typically only one byte is used for tail tag. */
 #define KSZ_EGRESS_TAG_LEN		1
+#define KSZ_INGRESS_TAG_LEN		1
 
 static struct sk_buff *ksz_common_xmit(struct sk_buff *skb,
 				       struct net_device *dev, int len)
@@ -141,3 +142,36 @@ const struct dsa_device_ops ksz9477_netdev_ops = {
 	.rcv	= ksz9477_rcv,
 	.overhead = KSZ9477_INGRESS_TAG_LEN,
 };
+
+#define KSZ9893_TAIL_TAG_OVERRIDE	BIT(5)
+#define KSZ9893_TAIL_TAG_LOOKUP		BIT(6)
+
+static struct sk_buff *ksz9893_xmit(struct sk_buff *skb,
+				    struct net_device *dev)
+{
+	struct dsa_port *dp = dsa_slave_to_port(dev);
+	struct sk_buff *nskb;
+	u8 *addr;
+	u8 *tag;
+
+	nskb = ksz_common_xmit(skb, dev, KSZ_INGRESS_TAG_LEN);
+	if (!nskb)
+		return NULL;
+
+	/* Tag encoding */
+	tag = skb_put(nskb, KSZ_INGRESS_TAG_LEN);
+	addr = skb_mac_header(nskb);
+
+	*tag = BIT(dp->index);
+
+	if (is_link_local_ether_addr(addr))
+		*tag |= KSZ9893_TAIL_TAG_OVERRIDE;
+
+	return nskb;
+}
+
+const struct dsa_device_ops ksz9893_netdev_ops = {
+	.xmit	= ksz9893_xmit,
+	.rcv	= ksz9477_rcv,
+	.overhead = KSZ_INGRESS_TAG_LEN,
+};

commit cbd72b485214f085a022b56a3051524577d891fe
Author: Tristram Ha <Tristram.Ha@microchip.com>
Date:   Thu Feb 7 20:05:58 2019 -0800

    net: dsa: microchip: add switch offload forwarding support
    
    The flag offload_fwd_mark is set as the switch can forward frames by
    itself.
    
    This can be considered a fix to a problem introduced in commit
    c2e866911e254067 where the port membership are not set in sync.  The flag
    offload_fwd_mark just needs to be set in tag_ksz.c to prevent the software
    bridge from forwarding duplicate multicast frames.
    
    Fixes: c2e866911e254067 ("microchip: break KSZ9477 DSA driver into two files")
    Signed-off-by: Tristram Ha <Tristram.Ha@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index da71b9e2af52..927e9c86f745 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -67,6 +67,8 @@ static struct sk_buff *ksz_common_rcv(struct sk_buff *skb,
 
 	pskb_trim_rcsum(skb, skb->len - len);
 
+	skb->offload_fwd_mark = true;
+
 	return skb;
 }
 

commit 8a75b9d4c9d32c88b487bd98bf8019f029215165
Author: Marek Vasut <marex@denx.de>
Date:   Sat Dec 15 01:58:06 2018 +0100

    net: dsa: ksz: Add STP multicast handling
    
    In case the destination address is link local, add override bit into the
    switch tag to let such a packet through the switch even if the port is
    blocked.
    
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Tristram Ha <Tristram.Ha@microchip.com>
    Cc: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Cc: Woojung Huh <woojung.huh@microchip.com>
    Cc: David S. Miller <davem@davemloft.net>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index c98b53f691bd..da71b9e2af52 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -110,6 +110,10 @@ static struct sk_buff *ksz9477_xmit(struct sk_buff *skb,
 	addr = skb_mac_header(nskb);
 
 	*tag = BIT(dp->index);
+
+	if (is_link_local_ether_addr(addr))
+		*tag |= KSZ9477_TAIL_TAG_OVERRIDE;
+
 	*tag = cpu_to_be16(*tag);
 
 	return nskb;

commit bafe9ba7d908f6240b3ca898b167072c55502609
Author: Tristram Ha <Tristram.Ha@microchip.com>
Date:   Sat Dec 15 01:58:05 2018 +0100

    net: dsa: ksz: Factor out common tag code
    
    Factor out common code from the tag_ksz , so that the code can be used
    with other KSZ family switches which use differenly sized tags.
    
    Signed-off-by: Tristram Ha <Tristram.Ha@microchip.com>
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Cc: Woojung Huh <woojung.huh@microchip.com>
    Cc: David S. Miller <davem@davemloft.net>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index c24a333e55bd..c98b53f691bd 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -14,34 +14,18 @@
 #include <net/dsa.h>
 #include "dsa_priv.h"
 
-/* For Ingress (Host -> KSZ), 2 bytes are added before FCS.
- * ---------------------------------------------------------------------------
- * DA(6bytes)|SA(6bytes)|....|Data(nbytes)|tag0(1byte)|tag1(1byte)|FCS(4bytes)
- * ---------------------------------------------------------------------------
- * tag0 : Prioritization (not used now)
- * tag1 : each bit represents port (eg, 0x01=port1, 0x02=port2, 0x10=port5)
- *
- * For Egress (KSZ -> Host), 1 byte is added before FCS.
- * ---------------------------------------------------------------------------
- * DA(6bytes)|SA(6bytes)|....|Data(nbytes)|tag0(1byte)|FCS(4bytes)
- * ---------------------------------------------------------------------------
- * tag0 : zero-based value represents port
- *	  (eg, 0x00=port1, 0x02=port3, 0x06=port7)
- */
+/* Typically only one byte is used for tail tag. */
+#define KSZ_EGRESS_TAG_LEN		1
 
-#define	KSZ_INGRESS_TAG_LEN	2
-#define	KSZ_EGRESS_TAG_LEN	1
-
-static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
+static struct sk_buff *ksz_common_xmit(struct sk_buff *skb,
+				       struct net_device *dev, int len)
 {
-	struct dsa_port *dp = dsa_slave_to_port(dev);
 	struct sk_buff *nskb;
 	int padlen;
-	u8 *tag;
 
 	padlen = (skb->len >= ETH_ZLEN) ? 0 : ETH_ZLEN - skb->len;
 
-	if (skb_tailroom(skb) >= padlen + KSZ_INGRESS_TAG_LEN) {
+	if (skb_tailroom(skb) >= padlen + len) {
 		/* Let dsa_slave_xmit() free skb */
 		if (__skb_put_padto(skb, skb->len + padlen, false))
 			return NULL;
@@ -49,7 +33,7 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 		nskb = skb;
 	} else {
 		nskb = alloc_skb(NET_IP_ALIGN + skb->len +
-				 padlen + KSZ_INGRESS_TAG_LEN, GFP_ATOMIC);
+				 padlen + len, GFP_ATOMIC);
 		if (!nskb)
 			return NULL;
 		skb_reserve(nskb, NET_IP_ALIGN);
@@ -70,34 +54,84 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 		consume_skb(skb);
 	}
 
-	tag = skb_put(nskb, KSZ_INGRESS_TAG_LEN);
-	tag[0] = 0;
-	tag[1] = 1 << dp->index; /* destination port */
-
 	return nskb;
 }
 
-static struct sk_buff *ksz_rcv(struct sk_buff *skb, struct net_device *dev,
-			       struct packet_type *pt)
+static struct sk_buff *ksz_common_rcv(struct sk_buff *skb,
+				      struct net_device *dev,
+				      unsigned int port, unsigned int len)
 {
-	u8 *tag;
-	int source_port;
+	skb->dev = dsa_master_find_slave(dev, 0, port);
+	if (!skb->dev)
+		return NULL;
 
-	tag = skb_tail_pointer(skb) - KSZ_EGRESS_TAG_LEN;
+	pskb_trim_rcsum(skb, skb->len - len);
 
-	source_port = tag[0] & 7;
+	return skb;
+}
 
-	skb->dev = dsa_master_find_slave(dev, 0, source_port);
-	if (!skb->dev)
+/*
+ * For Ingress (Host -> KSZ9477), 2 bytes are added before FCS.
+ * ---------------------------------------------------------------------------
+ * DA(6bytes)|SA(6bytes)|....|Data(nbytes)|tag0(1byte)|tag1(1byte)|FCS(4bytes)
+ * ---------------------------------------------------------------------------
+ * tag0 : Prioritization (not used now)
+ * tag1 : each bit represents port (eg, 0x01=port1, 0x02=port2, 0x10=port5)
+ *
+ * For Egress (KSZ9477 -> Host), 1 byte is added before FCS.
+ * ---------------------------------------------------------------------------
+ * DA(6bytes)|SA(6bytes)|....|Data(nbytes)|tag0(1byte)|FCS(4bytes)
+ * ---------------------------------------------------------------------------
+ * tag0 : zero-based value represents port
+ *	  (eg, 0x00=port1, 0x02=port3, 0x06=port7)
+ */
+
+#define KSZ9477_INGRESS_TAG_LEN		2
+#define KSZ9477_PTP_TAG_LEN		4
+#define KSZ9477_PTP_TAG_INDICATION	0x80
+
+#define KSZ9477_TAIL_TAG_OVERRIDE	BIT(9)
+#define KSZ9477_TAIL_TAG_LOOKUP		BIT(10)
+
+static struct sk_buff *ksz9477_xmit(struct sk_buff *skb,
+				    struct net_device *dev)
+{
+	struct dsa_port *dp = dsa_slave_to_port(dev);
+	struct sk_buff *nskb;
+	u16 *tag;
+	u8 *addr;
+
+	nskb = ksz_common_xmit(skb, dev, KSZ9477_INGRESS_TAG_LEN);
+	if (!nskb)
 		return NULL;
 
-	pskb_trim_rcsum(skb, skb->len - KSZ_EGRESS_TAG_LEN);
+	/* Tag encoding */
+	tag = skb_put(nskb, KSZ9477_INGRESS_TAG_LEN);
+	addr = skb_mac_header(nskb);
 
-	return skb;
+	*tag = BIT(dp->index);
+	*tag = cpu_to_be16(*tag);
+
+	return nskb;
+}
+
+static struct sk_buff *ksz9477_rcv(struct sk_buff *skb, struct net_device *dev,
+				   struct packet_type *pt)
+{
+	/* Tag decoding */
+	u8 *tag = skb_tail_pointer(skb) - KSZ_EGRESS_TAG_LEN;
+	unsigned int port = tag[0] & 7;
+	unsigned int len = KSZ_EGRESS_TAG_LEN;
+
+	/* Extra 4-bytes PTP timestamp */
+	if (tag[0] & KSZ9477_PTP_TAG_INDICATION)
+		len += KSZ9477_PTP_TAG_LEN;
+
+	return ksz_common_rcv(skb, dev, port, len);
 }
 
 const struct dsa_device_ops ksz9477_netdev_ops = {
-	.xmit	= ksz_xmit,
-	.rcv	= ksz_rcv,
-	.overhead = KSZ_INGRESS_TAG_LEN,
+	.xmit	= ksz9477_xmit,
+	.rcv	= ksz9477_rcv,
+	.overhead = KSZ9477_INGRESS_TAG_LEN,
 };

commit 39d6b96f9fc2d99c4619954f462ba32e5d48502e
Author: Tristram Ha <Tristram.Ha@microchip.com>
Date:   Sat Dec 15 01:58:04 2018 +0100

    net: dsa: ksz: Rename NET_DSA_TAG_KSZ to _KSZ9477
    
    Rename the tag Kconfig option and related macros in preparation for
    addition of new KSZ family switches with different tag formats.
    
    Signed-off-by: Tristram Ha <Tristram.Ha@microchip.com>
    Signed-off-by: Marek Vasut <marex@denx.de>
    Cc: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Cc: Woojung Huh <woojung.huh@microchip.com>
    Cc: David S. Miller <davem@davemloft.net>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 96411f70ab9f..c24a333e55bd 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -96,7 +96,7 @@ static struct sk_buff *ksz_rcv(struct sk_buff *skb, struct net_device *dev,
 	return skb;
 }
 
-const struct dsa_device_ops ksz_netdev_ops = {
+const struct dsa_device_ops ksz9477_netdev_ops = {
 	.xmit	= ksz_xmit,
 	.rcv	= ksz_rcv,
 	.overhead = KSZ_INGRESS_TAG_LEN,

commit a5dd308778a4e05e7b0b927cf18b89d1ebbff59c
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Thu Dec 6 11:36:04 2018 +0100

    net: dsa: Add overhead to tag protocol ops.
    
    Each DSA tag protocol needs to add additional headers to the Ethernet
    frame in order to direct it towards a specific switch egress port. It
    must also remove the head from a frame received from a
    switch. Indicate the maximum size of these headers in the tag protocol
    ops structure, so the core can take these overheads into account.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 0f62effad88f..96411f70ab9f 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -99,4 +99,5 @@ static struct sk_buff *ksz_rcv(struct sk_buff *skb, struct net_device *dev,
 const struct dsa_device_ops ksz_netdev_ops = {
 	.xmit	= ksz_xmit,
 	.rcv	= ksz_rcv,
+	.overhead = KSZ_INGRESS_TAG_LEN,
 };

commit 2231c43b560403675217f52204b18c1c59c0ee76
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Oct 16 11:12:17 2017 -0400

    net: dsa: rename dsa_master_get_slave
    
    The dsa_master_get_slave is slightly confusing since the idiomatic "get"
    term often suggests reference counting, in symmetry to "put".
    
    Rename it to dsa_master_find_slave to make the look up operation clear.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 66e443fd7675..0f62effad88f 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -87,7 +87,7 @@ static struct sk_buff *ksz_rcv(struct sk_buff *skb, struct net_device *dev,
 
 	source_port = tag[0] & 7;
 
-	skb->dev = dsa_master_get_slave(dev, 0, source_port);
+	skb->dev = dsa_master_find_slave(dev, 0, source_port);
 	if (!skb->dev)
 		return NULL;
 

commit d945097bb19501bd95790d8220d4eeb418b6ebb2
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Oct 16 11:12:15 2017 -0400

    net: dsa: add slave to port helper
    
    Many portions of DSA core code require to get the dsa_port structure
    corresponding to a slave net_device. For this purpose, introduce a
    dsa_slave_to_port() helper.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index b241c990cde0..66e443fd7675 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -34,7 +34,7 @@
 
 static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 {
-	struct dsa_slave_priv *p = netdev_priv(dev);
+	struct dsa_port *dp = dsa_slave_to_port(dev);
 	struct sk_buff *nskb;
 	int padlen;
 	u8 *tag;
@@ -72,7 +72,7 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 
 	tag = skb_put(nskb, KSZ_INGRESS_TAG_LEN);
 	tag[0] = 0;
-	tag[1] = 1 << p->dp->index; /* destination port */
+	tag[1] = 1 << dp->index; /* destination port */
 
 	return nskb;
 }

commit 3775b1b7f0c330e59c434d1852d7762ae0a9c164
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Sep 29 17:19:15 2017 -0400

    net: dsa: add master helper to look up slaves
    
    The DSA tagging code does not need to know about the DSA architecture,
    it only needs to return the slave device corresponding to the source
    port index (and eventually the source device index for cascade-capable
    switches) parsed from the frame received on the master device.
    
    For this purpose, provide an inline dsa_master_get_slave helper which
    validates the device and port indexes and look up the slave device.
    
    This makes the tagging rcv functions more concise and robust, and also
    makes dsa_get_cpu_port obsolete.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 010ca0a336c4..b241c990cde0 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -80,22 +80,19 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 static struct sk_buff *ksz_rcv(struct sk_buff *skb, struct net_device *dev,
 			       struct packet_type *pt)
 {
-	struct dsa_switch_tree *dst = dev->dsa_ptr;
-	struct dsa_port *cpu_dp = dsa_get_cpu_port(dst);
-	struct dsa_switch *ds = cpu_dp->ds;
 	u8 *tag;
 	int source_port;
 
 	tag = skb_tail_pointer(skb) - KSZ_EGRESS_TAG_LEN;
 
 	source_port = tag[0] & 7;
-	if (source_port >= ds->num_ports || !ds->ports[source_port].netdev)
+
+	skb->dev = dsa_master_get_slave(dev, 0, source_port);
+	if (!skb->dev)
 		return NULL;
 
 	pskb_trim_rcsum(skb, skb->len - KSZ_EGRESS_TAG_LEN);
 
-	skb->dev = ds->ports[source_port].netdev;
-
 	return skb;
 }
 

commit 6026e043d09012c6269f9a96a808d52d9c498224
Merge: 4cc5b44b29a9 138e4ad67afd
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Sep 1 17:42:05 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Three cases of simple overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 2b33bc8aa236b75d6e86a8a79126fd9739e4a5bd
Author: Eric Dumazet <edumazet@google.com>
Date:   Wed Aug 23 21:40:32 2017 -0700

    net: dsa: use consume_skb()
    
    Two kfree_skb() should be consume_skb(), to be friend with drop monitor
    (perf record ... -e skb:kfree_skb)
    
    Signed-off-by: Eric Dumazet <edumazet@google.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 3bd6e2a83125..fcd90f79458e 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -67,7 +67,7 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 		if (skb_put_padto(nskb, nskb->len + padlen))
 			return NULL;
 
-		kfree_skb(skb);
+		consume_skb(skb);
 	}
 
 	tag = skb_put(nskb, KSZ_INGRESS_TAG_LEN);

commit 49716679248a0bf64d8914711b2d1ea48751853e
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Aug 22 15:12:15 2017 -0700

    net: dsa: skb_put_padto() already frees nskb
    
    The first call of skb_put_padto() will free up the SKB on error, but we
    return NULL which tells dsa_slave_xmit() that the original SKB should be
    freed so this would lead to a double free here.
    
    The second skb_put_padto() already frees the passed sk_buff reference
    upon error, so calling kfree_skb() on it again is not necessary.
    
    Detected by CoverityScan, CID#1416687 ("USE_AFTER_FREE")
    
    Fixes: e71cb9e00922 ("net: dsa: ksz: fix skb freeing")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Woojung Huh <Woojung.Huh@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index de66ca8e6201..3bd6e2a83125 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -42,7 +42,8 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 	padlen = (skb->len >= ETH_ZLEN) ? 0 : ETH_ZLEN - skb->len;
 
 	if (skb_tailroom(skb) >= padlen + KSZ_INGRESS_TAG_LEN) {
-		if (skb_put_padto(skb, skb->len + padlen))
+		/* Let dsa_slave_xmit() free skb */
+		if (__skb_put_padto(skb, skb->len + padlen, false))
 			return NULL;
 
 		nskb = skb;
@@ -60,10 +61,11 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 					 skb_transport_header(skb) - skb->head);
 		skb_copy_and_csum_dev(skb, skb_put(nskb, skb->len));
 
-		if (skb_put_padto(nskb, nskb->len + padlen)) {
-			kfree_skb(nskb);
+		/* Let skb_put_padto() free nskb, and let dsa_slave_xmit() free
+		 * skb
+		 */
+		if (skb_put_padto(nskb, nskb->len + padlen))
 			return NULL;
-		}
 
 		kfree_skb(skb);
 	}

commit 89e49506bc62520f93e64a278293444319a6aebb
Author: Florian Westphal <fw@strlen.de>
Date:   Thu Aug 17 16:47:00 2017 +0200

    dsa: remove unused net_device arg from handlers
    
    compile tested only, but saw no warnings/errors with
    allmodconfig build.
    
    Signed-off-by: Florian Westphal <fw@strlen.de>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index de66ca8e6201..17f30675c15c 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -76,8 +76,7 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 }
 
 static struct sk_buff *ksz_rcv(struct sk_buff *skb, struct net_device *dev,
-			       struct packet_type *pt,
-			       struct net_device *orig_dev)
+			       struct packet_type *pt)
 {
 	struct dsa_switch_tree *dst = dev->dsa_ptr;
 	struct dsa_port *cpu_dp = dsa_get_cpu_port(dst);

commit e71cb9e00922902ba0519f37d09145f117dc02b3
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Wed Aug 9 16:46:09 2017 -0400

    net: dsa: ksz: fix skb freeing
    
    The DSA layer frees the original skb when an xmit function returns NULL,
    meaning an error occurred. But if the tagging code copied the original
    skb, it is responsible of freeing the copy if an error occurs.
    
    The ksz tagging code currently has two issues: if skb_put_padto fails,
    the skb copy is not freed, and the original skb will be freed twice.
    
    To fix that, move skb_put_padto inside both branches of the skb_tailroom
    condition, before freeing the original skb, and free the copy on error.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Woojung Huh <woojung.huh@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index fab41de8e983..de66ca8e6201 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -42,6 +42,9 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 	padlen = (skb->len >= ETH_ZLEN) ? 0 : ETH_ZLEN - skb->len;
 
 	if (skb_tailroom(skb) >= padlen + KSZ_INGRESS_TAG_LEN) {
+		if (skb_put_padto(skb, skb->len + padlen))
+			return NULL;
+
 		nskb = skb;
 	} else {
 		nskb = alloc_skb(NET_IP_ALIGN + skb->len +
@@ -56,13 +59,15 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 		skb_set_transport_header(nskb,
 					 skb_transport_header(skb) - skb->head);
 		skb_copy_and_csum_dev(skb, skb_put(nskb, skb->len));
+
+		if (skb_put_padto(nskb, nskb->len + padlen)) {
+			kfree_skb(nskb);
+			return NULL;
+		}
+
 		kfree_skb(skb);
 	}
 
-	/* skb is freed when it fails */
-	if (skb_put_padto(nskb, nskb->len + padlen))
-		return NULL;
-
 	tag = skb_put(nskb, KSZ_INGRESS_TAG_LEN);
 	tag[0] = 0;
 	tag[1] = 1 << p->dp->index; /* destination port */

commit 3cc9f2573cdcbc6991aa2d1c8e04a4b9190487f8
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jun 13 13:27:22 2017 -0700

    net: dsa: Introduce dsa_get_cpu_port()
    
    Introduce a helper function which will return a reference to the CPU
    port used in a dsa_switch_tree. Right now this is a singleton, but this
    will change once we introduce multi-CPU port support, so ease the
    transition by converting the affected code paths.
    
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index b94a334a1d02..fab41de8e983 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -75,12 +75,11 @@ static struct sk_buff *ksz_rcv(struct sk_buff *skb, struct net_device *dev,
 			       struct net_device *orig_dev)
 {
 	struct dsa_switch_tree *dst = dev->dsa_ptr;
-	struct dsa_switch *ds;
+	struct dsa_port *cpu_dp = dsa_get_cpu_port(dst);
+	struct dsa_switch *ds = cpu_dp->ds;
 	u8 *tag;
 	int source_port;
 
-	ds = dst->cpu_dp->ds;
-
 	tag = skb_tail_pointer(skb) - KSZ_EGRESS_TAG_LEN;
 
 	source_port = tag[0] & 7;

commit fe47d563065c91cd30088d9b118b79d44905be6f
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Thu Jun 1 16:07:15 2017 -0400

    net: dsa: factor skb freeing on xmit
    
    As of a86d8becc3f0 ("net: dsa: Factor bottom tag receive functions"),
    the rcv caller frees the original SKB in case or error.
    
    Be symmetric with that and make the xmit caller do the same.
    
    At the same time, fix the checkpatch NULL comparison check:
    
            CHECK: Comparison to NULL could be written "!nskb"
        #208: FILE: net/dsa/tag_trailer.c:35:
        +   if (nskb == NULL)
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index dfcd2fff5b13..b94a334a1d02 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -46,10 +46,8 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 	} else {
 		nskb = alloc_skb(NET_IP_ALIGN + skb->len +
 				 padlen + KSZ_INGRESS_TAG_LEN, GFP_ATOMIC);
-		if (!nskb) {
-			kfree_skb(skb);
+		if (!nskb)
 			return NULL;
-		}
 		skb_reserve(nskb, NET_IP_ALIGN);
 
 		skb_reset_mac_header(nskb);

commit 7b954ed7529b6bae8712345dd9d22afa57b96dca
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Jun 1 13:22:42 2017 +0100

    net: dsa: make function ksz_rcv static
    
    function ksz_rcv can be made static as it does not need to be
    in global scope. Reformat arguments to make it checkpatch warning
    free too.
    
    Cleans up sparse warning: "symbol 'ksz_rcv' was not declared. Should
    it be static?"
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Woojung Huh <Woojung.Huh@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
index 0b08a40b493a..dfcd2fff5b13 100644
--- a/net/dsa/tag_ksz.c
+++ b/net/dsa/tag_ksz.c
@@ -72,8 +72,9 @@ static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
 	return nskb;
 }
 
-struct sk_buff *ksz_rcv(struct sk_buff *skb, struct net_device *dev,
-			struct packet_type *pt, struct net_device *orig_dev)
+static struct sk_buff *ksz_rcv(struct sk_buff *skb, struct net_device *dev,
+			       struct packet_type *pt,
+			       struct net_device *orig_dev)
 {
 	struct dsa_switch_tree *dst = dev->dsa_ptr;
 	struct dsa_switch *ds;

commit 8b8010fb7876e816300ddd60fa089e9ceb209f3e
Author: Woojung Huh <Woojung.Huh@microchip.com>
Date:   Wed May 31 20:19:06 2017 +0000

    dsa: add support for Microchip KSZ tail tagging
    
    Adding support for the Microchip KSZ switch family tail tagging.
    
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Woojung Huh <Woojung.Huh@microchip.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/tag_ksz.c b/net/dsa/tag_ksz.c
new file mode 100644
index 000000000000..0b08a40b493a
--- /dev/null
+++ b/net/dsa/tag_ksz.c
@@ -0,0 +1,101 @@
+/*
+ * net/dsa/tag_ksz.c - Microchip KSZ Switch tag format handling
+ * Copyright (c) 2017 Microchip Technology
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/etherdevice.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <net/dsa.h>
+#include "dsa_priv.h"
+
+/* For Ingress (Host -> KSZ), 2 bytes are added before FCS.
+ * ---------------------------------------------------------------------------
+ * DA(6bytes)|SA(6bytes)|....|Data(nbytes)|tag0(1byte)|tag1(1byte)|FCS(4bytes)
+ * ---------------------------------------------------------------------------
+ * tag0 : Prioritization (not used now)
+ * tag1 : each bit represents port (eg, 0x01=port1, 0x02=port2, 0x10=port5)
+ *
+ * For Egress (KSZ -> Host), 1 byte is added before FCS.
+ * ---------------------------------------------------------------------------
+ * DA(6bytes)|SA(6bytes)|....|Data(nbytes)|tag0(1byte)|FCS(4bytes)
+ * ---------------------------------------------------------------------------
+ * tag0 : zero-based value represents port
+ *	  (eg, 0x00=port1, 0x02=port3, 0x06=port7)
+ */
+
+#define	KSZ_INGRESS_TAG_LEN	2
+#define	KSZ_EGRESS_TAG_LEN	1
+
+static struct sk_buff *ksz_xmit(struct sk_buff *skb, struct net_device *dev)
+{
+	struct dsa_slave_priv *p = netdev_priv(dev);
+	struct sk_buff *nskb;
+	int padlen;
+	u8 *tag;
+
+	padlen = (skb->len >= ETH_ZLEN) ? 0 : ETH_ZLEN - skb->len;
+
+	if (skb_tailroom(skb) >= padlen + KSZ_INGRESS_TAG_LEN) {
+		nskb = skb;
+	} else {
+		nskb = alloc_skb(NET_IP_ALIGN + skb->len +
+				 padlen + KSZ_INGRESS_TAG_LEN, GFP_ATOMIC);
+		if (!nskb) {
+			kfree_skb(skb);
+			return NULL;
+		}
+		skb_reserve(nskb, NET_IP_ALIGN);
+
+		skb_reset_mac_header(nskb);
+		skb_set_network_header(nskb,
+				       skb_network_header(skb) - skb->head);
+		skb_set_transport_header(nskb,
+					 skb_transport_header(skb) - skb->head);
+		skb_copy_and_csum_dev(skb, skb_put(nskb, skb->len));
+		kfree_skb(skb);
+	}
+
+	/* skb is freed when it fails */
+	if (skb_put_padto(nskb, nskb->len + padlen))
+		return NULL;
+
+	tag = skb_put(nskb, KSZ_INGRESS_TAG_LEN);
+	tag[0] = 0;
+	tag[1] = 1 << p->dp->index; /* destination port */
+
+	return nskb;
+}
+
+struct sk_buff *ksz_rcv(struct sk_buff *skb, struct net_device *dev,
+			struct packet_type *pt, struct net_device *orig_dev)
+{
+	struct dsa_switch_tree *dst = dev->dsa_ptr;
+	struct dsa_switch *ds;
+	u8 *tag;
+	int source_port;
+
+	ds = dst->cpu_dp->ds;
+
+	tag = skb_tail_pointer(skb) - KSZ_EGRESS_TAG_LEN;
+
+	source_port = tag[0] & 7;
+	if (source_port >= ds->num_ports || !ds->ports[source_port].netdev)
+		return NULL;
+
+	pskb_trim_rcsum(skb, skb->len - KSZ_EGRESS_TAG_LEN);
+
+	skb->dev = ds->ports[source_port].netdev;
+
+	return skb;
+}
+
+const struct dsa_device_ops ksz_netdev_ops = {
+	.xmit	= ksz_xmit,
+	.rcv	= ksz_rcv,
+};
