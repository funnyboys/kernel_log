commit 3b7bc1f09101ccace330d105c13c2946bf3be6d5
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sun May 10 19:37:42 2020 +0300

    net: dsa: introduce a dsa_switch_find function
    
    Somewhat similar to dsa_tree_find, dsa_switch_find returns a dsa_switch
    structure pointer by searching for its tree index and switch index (the
    parameters from dsa,member). To be used, for example, by drivers who
    implement .crosschip_bridge_join and need a reference to the other
    switch indicated to by the tree_index and sw_index arguments.
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Jakub Kicinski <kuba@kernel.org>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index d90665b465b8..076908fdd29b 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -24,6 +24,27 @@ LIST_HEAD(dsa_tree_list);
 static const struct devlink_ops dsa_devlink_ops = {
 };
 
+struct dsa_switch *dsa_switch_find(int tree_index, int sw_index)
+{
+	struct dsa_switch_tree *dst;
+	struct dsa_port *dp;
+
+	list_for_each_entry(dst, &dsa_tree_list, list) {
+		if (dst->index != tree_index)
+			continue;
+
+		list_for_each_entry(dp, &dst->ports, list) {
+			if (dp->ds->index != sw_index)
+				continue;
+
+			return dp->ds;
+		}
+	}
+
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(dsa_switch_find);
+
 static struct dsa_switch_tree *dsa_tree_find(int index)
 {
 	struct dsa_switch_tree *dst;

commit 86f8b1c01a0a537a73d2996615133be63cdf75db
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sun May 3 20:50:57 2020 -0700

    net: dsa: Do not make user port errors fatal
    
    Prior to 1d27732f411d ("net: dsa: setup and teardown ports"), we would
    not treat failures to set-up an user port as fatal, but after this
    commit we would, which is a regression for some systems where interfaces
    may be declared in the Device Tree, but the underlying hardware may not
    be present (pluggable daughter cards for instance).
    
    Fixes: 1d27732f411d ("net: dsa: setup and teardown ports")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 9a271a58a41d..d90665b465b8 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -459,7 +459,7 @@ static int dsa_tree_setup_switches(struct dsa_switch_tree *dst)
 	list_for_each_entry(dp, &dst->ports, list) {
 		err = dsa_port_setup(dp);
 		if (err)
-			goto teardown;
+			continue;
 	}
 
 	return 0;

commit bff33f7e2ae2e805a4b0af597b58422185c68900
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Fri Mar 27 21:55:43 2020 +0200

    net: dsa: implement auto-normalization of MTU for bridge hardware datapath
    
    Many switches don't have an explicit knob for configuring the MTU
    (maximum transmission unit per interface).  Instead, they do the
    length-based packet admission checks on the ingress interface, for
    reasons that are easy to understand (why would you accept a packet in
    the queuing subsystem if you know you're going to drop it anyway).
    
    So it is actually the MRU that these switches permit configuring.
    
    In Linux there only exists the IFLA_MTU netlink attribute and the
    associated dev_set_mtu function. The comments like to play blind and say
    that it's changing the "maximum transfer unit", which is to say that
    there isn't any directionality in the meaning of the MTU word. So that
    is the interpretation that this patch is giving to things: MTU == MRU.
    
    When 2 interfaces having different MTUs are bridged, the bridge driver
    MTU auto-adjustment logic kicks in: what br_mtu_auto_adjust() does is it
    adjusts the MTU of the bridge net device itself (and not that of the
    slave net devices) to the minimum value of all slave interfaces, in
    order for forwarded packets to not exceed the MTU regardless of the
    interface they are received and send on.
    
    The idea behind this behavior, and why the slave MTUs are not adjusted,
    is that normal termination from Linux over the L2 forwarding domain
    should happen over the bridge net device, which _is_ properly limited by
    the minimum MTU. And termination over individual slave devices is
    possible even if those are bridged. But that is not "forwarding", so
    there's no reason to do normalization there, since only a single
    interface sees that packet.
    
    The problem with those switches that can only control the MRU is with
    the offloaded data path, where a packet received on an interface with
    MRU 9000 would still be forwarded to an interface with MRU 1500. And the
    br_mtu_auto_adjust() function does not really help, since the MTU
    configured on the bridge net device is ignored.
    
    In order to enforce the de-facto MTU == MRU rule for these switches, we
    need to do MTU normalization, which means: in order for no packet larger
    than the MTU configured on this port to be sent, then we need to limit
    the MRU on all ports that this packet could possibly come from. AKA
    since we are configuring the MRU via MTU, it means that all ports within
    a bridge forwarding domain should have the same MTU.
    
    And that is exactly what this patch is trying to do.
    
    >From an implementation perspective, we try to follow the intent of the
    user, otherwise there is a risk that we might livelock them (they try to
    change the MTU on an already-bridged interface, but we just keep
    changing it back in an attempt to keep the MTU normalized). So the MTU
    that the bridge is normalized to is either:
    
     - The most recently changed one:
    
       ip link set dev swp0 master br0
       ip link set dev swp1 master br0
       ip link set dev swp0 mtu 1400
    
       This sequence will make swp1 inherit MTU 1400 from swp0.
    
     - The one of the most recently added interface to the bridge:
    
       ip link set dev swp0 master br0
       ip link set dev swp1 mtu 1400
       ip link set dev swp1 master br0
    
       The above sequence will make swp0 inherit MTU 1400 as well.
    
    Suggested-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index e7c30b472034..9a271a58a41d 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -18,8 +18,8 @@
 
 #include "dsa_priv.h"
 
-static LIST_HEAD(dsa_tree_list);
 static DEFINE_MUTEX(dsa2_mutex);
+LIST_HEAD(dsa_tree_list);
 
 static const struct devlink_ops dsa_devlink_ops = {
 };

commit 6dc43cd3aae0ffeeaebe427e1bf5e5faf9de7d42
Author: Vladimir Oltean <vladimir.oltean@nxp.com>
Date:   Sat Jan 25 23:01:11 2020 +0200

    net: dsa: Fix use-after-free in probing of DSA switch tree
    
    DSA sets up a switch tree little by little. Every switch of the N
    members of the tree calls dsa_register_switch, and (N - 1) will just
    touch the dst->ports list with their ports and quickly exit. Only the
    last switch that calls dsa_register_switch will find all DSA links
    complete in dsa_tree_setup_routing_table, and not return zero as a
    result but instead go ahead and set up the entire DSA switch tree
    (practically on behalf of the other switches too).
    
    The trouble is that the (N - 1) switches don't clean up after themselves
    after they get an error such as EPROBE_DEFER. Their footprint left in
    dst->ports by dsa_switch_touch_ports is still there. And switch N, the
    one responsible with actually setting up the tree, is going to work with
    those stale dp, dp->ds and dp->ds->dev pointers. In particular ds and
    ds->dev might get freed by the device driver.
    
    Be there a 2-switch tree and the following calling order:
    - Switch 1 calls dsa_register_switch
      - Calls dsa_switch_touch_ports, populates dst->ports
      - Calls dsa_port_parse_cpu, gets -EPROBE_DEFER, exits.
    - Switch 2 calls dsa_register_switch
      - Calls dsa_switch_touch_ports, populates dst->ports
      - Probe doesn't get deferred, so it goes ahead.
      - Calls dsa_tree_setup_routing_table, which returns "complete == true"
        due to Switch 1 having called dsa_switch_touch_ports before.
      - Because the DSA links are complete, it calls dsa_tree_setup_switches
        now.
      - dsa_tree_setup_switches iterates through dst->ports, initializing
        the Switch 1 ds structure (invalid) and the Switch 2 ds structure
        (valid).
      - Undefined behavior (use after free, sometimes NULL pointers, etc).
    
    Real example below (debugging prints added by me, as well as guards
    against NULL pointers):
    
    [    5.477947] dsa_tree_setup_switches: Setting up port 0 of switch ffffff803df0b980 (dev ffffff803f775c00)
    [    6.313002] dsa_tree_setup_switches: Setting up port 1 of switch ffffff803df0b980 (dev ffffff803f775c00)
    [    6.319932] dsa_tree_setup_switches: Setting up port 2 of switch ffffff803df0b980 (dev ffffff803f775c00)
    [    6.329693] dsa_tree_setup_switches: Setting up port 3 of switch ffffff803df0b980 (dev ffffff803f775c00)
    [    6.339458] dsa_tree_setup_switches: Setting up port 4 of switch ffffff803df0b980 (dev ffffff803f775c00)
    [    6.349226] dsa_tree_setup_switches: Setting up port 5 of switch ffffff803df0b980 (dev ffffff803f775c00)
    [    6.358991] dsa_tree_setup_switches: Setting up port 6 of switch ffffff803df0b980 (dev ffffff803f775c00)
    [    6.368758] dsa_tree_setup_switches: Setting up port 7 of switch ffffff803df0b980 (dev ffffff803f775c00)
    [    6.378524] dsa_tree_setup_switches: Setting up port 8 of switch ffffff803df0b980 (dev ffffff803f775c00)
    [    6.388291] dsa_tree_setup_switches: Setting up port 9 of switch ffffff803df0b980 (dev ffffff803f775c00)
    [    6.398057] dsa_tree_setup_switches: Setting up port 10 of switch ffffff803df0b980 (dev ffffff803f775c00)
    [    6.407912] dsa_tree_setup_switches: Setting up port 0 of switch ffffff803da02f80 (dev 0000000000000000)
    [    6.417682] dsa_tree_setup_switches: Setting up port 1 of switch ffffff803da02f80 (dev 0000000000000000)
    [    6.427446] dsa_tree_setup_switches: Setting up port 2 of switch ffffff803da02f80 (dev 0000000000000000)
    [    6.437212] dsa_tree_setup_switches: Setting up port 3 of switch ffffff803da02f80 (dev 0000000000000000)
    [    6.446979] dsa_tree_setup_switches: Setting up port 4 of switch ffffff803da02f80 (dev 0000000000000000)
    [    6.456744] dsa_tree_setup_switches: Setting up port 5 of switch ffffff803da02f80 (dev 0000000000000000)
    [    6.466512] dsa_tree_setup_switches: Setting up port 6 of switch ffffff803da02f80 (dev 0000000000000000)
    [    6.476277] dsa_tree_setup_switches: Setting up port 7 of switch ffffff803da02f80 (dev 0000000000000000)
    [    6.486043] dsa_tree_setup_switches: Setting up port 8 of switch ffffff803da02f80 (dev 0000000000000000)
    [    6.495810] dsa_tree_setup_switches: Setting up port 9 of switch ffffff803da02f80 (dev 0000000000000000)
    [    6.505577] dsa_tree_setup_switches: Setting up port 10 of switch ffffff803da02f80 (dev 0000000000000000)
    [    6.515433] dsa_tree_setup_switches: Setting up port 0 of switch ffffff803db15b80 (dev ffffff803d8e4800)
    [    7.354120] dsa_tree_setup_switches: Setting up port 1 of switch ffffff803db15b80 (dev ffffff803d8e4800)
    [    7.361045] dsa_tree_setup_switches: Setting up port 2 of switch ffffff803db15b80 (dev ffffff803d8e4800)
    [    7.370805] dsa_tree_setup_switches: Setting up port 3 of switch ffffff803db15b80 (dev ffffff803d8e4800)
    [    7.380571] dsa_tree_setup_switches: Setting up port 4 of switch ffffff803db15b80 (dev ffffff803d8e4800)
    [    7.390337] dsa_tree_setup_switches: Setting up port 5 of switch ffffff803db15b80 (dev ffffff803d8e4800)
    [    7.400104] dsa_tree_setup_switches: Setting up port 6 of switch ffffff803db15b80 (dev ffffff803d8e4800)
    [    7.409872] dsa_tree_setup_switches: Setting up port 7 of switch ffffff803db15b80 (dev ffffff803d8e4800)
    [    7.419637] dsa_tree_setup_switches: Setting up port 8 of switch ffffff803db15b80 (dev ffffff803d8e4800)
    [    7.429403] dsa_tree_setup_switches: Setting up port 9 of switch ffffff803db15b80 (dev ffffff803d8e4800)
    [    7.439169] dsa_tree_setup_switches: Setting up port 10 of switch ffffff803db15b80 (dev ffffff803d8e4800)
    
    The solution is to recognize that the functions that call
    dsa_switch_touch_ports (dsa_switch_parse_of, dsa_switch_parse) have side
    effects, and therefore one should clean up their side effects on error
    path. The cleanup of dst->ports was taken from dsa_switch_remove and
    moved into a dedicated dsa_switch_release_ports function, which should
    really be per-switch (free only the members of dst->ports that are also
    members of ds, instead of all switch ports).
    
    Signed-off-by: Vladimir Oltean <vladimir.oltean@nxp.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index c6d81f2baf4e..e7c30b472034 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -849,6 +849,19 @@ static int dsa_switch_parse(struct dsa_switch *ds, struct dsa_chip_data *cd)
 	return dsa_switch_parse_ports(ds, cd);
 }
 
+static void dsa_switch_release_ports(struct dsa_switch *ds)
+{
+	struct dsa_switch_tree *dst = ds->dst;
+	struct dsa_port *dp, *next;
+
+	list_for_each_entry_safe(dp, next, &dst->ports, list) {
+		if (dp->ds != ds)
+			continue;
+		list_del(&dp->list);
+		kfree(dp);
+	}
+}
+
 static int dsa_switch_probe(struct dsa_switch *ds)
 {
 	struct dsa_switch_tree *dst;
@@ -865,12 +878,17 @@ static int dsa_switch_probe(struct dsa_switch *ds)
 	if (!ds->num_ports)
 		return -EINVAL;
 
-	if (np)
+	if (np) {
 		err = dsa_switch_parse_of(ds, np);
-	else if (pdata)
+		if (err)
+			dsa_switch_release_ports(ds);
+	} else if (pdata) {
 		err = dsa_switch_parse(ds, pdata);
-	else
+		if (err)
+			dsa_switch_release_ports(ds);
+	} else {
 		err = -ENODEV;
+	}
 
 	if (err)
 		return err;
@@ -878,8 +896,10 @@ static int dsa_switch_probe(struct dsa_switch *ds)
 	dst = ds->dst;
 	dsa_tree_get(dst);
 	err = dsa_tree_setup(dst);
-	if (err)
+	if (err) {
+		dsa_switch_release_ports(ds);
 		dsa_tree_put(dst);
+	}
 
 	return err;
 }
@@ -900,15 +920,9 @@ EXPORT_SYMBOL_GPL(dsa_register_switch);
 static void dsa_switch_remove(struct dsa_switch *ds)
 {
 	struct dsa_switch_tree *dst = ds->dst;
-	struct dsa_port *dp, *next;
 
 	dsa_tree_teardown(dst);
-
-	list_for_each_entry_safe(dp, next, &dst->ports, list) {
-		list_del(&dp->list);
-		kfree(dp);
-	}
-
+	dsa_switch_release_ports(ds);
 	dsa_tree_put(dst);
 }
 

commit 4d776482ecc689bdd68627985ac4cb5a6f325953
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jan 7 21:06:05 2020 -0800

    net: dsa: Get information about stacked DSA protocol
    
    It is possible to stack multiple DSA switches in a way that they are not
    part of the tree (disjoint) but the DSA master of a switch is a DSA
    slave of another. When that happens switch drivers may have to know this
    is the case so as to determine whether their tagging protocol has a
    remove chance of working.
    
    This is useful for specific switch drivers such as b53 where devices
    have been known to be stacked in the wild without the Broadcom tag
    protocol supporting that feature. This allows b53 to continue supporting
    those devices by forcing the disabling of Broadcom tags on the outermost
    switches if necessary.
    
    The get_tag_protocol() function is therefore updated to gain an
    additional enum dsa_tag_protocol argument which denotes the current
    tagging protocol used by the DSA master we are attached to, else
    DSA_TAG_PROTO_NONE for the top of the dsa_switch_tree.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index c66abbed4daf..c6d81f2baf4e 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -614,6 +614,32 @@ static int dsa_port_parse_dsa(struct dsa_port *dp)
 	return 0;
 }
 
+static enum dsa_tag_protocol dsa_get_tag_protocol(struct dsa_port *dp,
+						  struct net_device *master)
+{
+	enum dsa_tag_protocol tag_protocol = DSA_TAG_PROTO_NONE;
+	struct dsa_switch *mds, *ds = dp->ds;
+	unsigned int mdp_upstream;
+	struct dsa_port *mdp;
+
+	/* It is possible to stack DSA switches onto one another when that
+	 * happens the switch driver may want to know if its tagging protocol
+	 * is going to work in such a configuration.
+	 */
+	if (dsa_slave_dev_check(master)) {
+		mdp = dsa_slave_to_port(master);
+		mds = mdp->ds;
+		mdp_upstream = dsa_upstream_port(mds, mdp->index);
+		tag_protocol = mds->ops->get_tag_protocol(mds, mdp_upstream,
+							  DSA_TAG_PROTO_NONE);
+	}
+
+	/* If the master device is not itself a DSA slave in a disjoint DSA
+	 * tree, then return immediately.
+	 */
+	return ds->ops->get_tag_protocol(ds, dp->index, tag_protocol);
+}
+
 static int dsa_port_parse_cpu(struct dsa_port *dp, struct net_device *master)
 {
 	struct dsa_switch *ds = dp->ds;
@@ -621,20 +647,21 @@ static int dsa_port_parse_cpu(struct dsa_port *dp, struct net_device *master)
 	const struct dsa_device_ops *tag_ops;
 	enum dsa_tag_protocol tag_protocol;
 
-	tag_protocol = ds->ops->get_tag_protocol(ds, dp->index);
+	tag_protocol = dsa_get_tag_protocol(dp, master);
 	tag_ops = dsa_tag_driver_get(tag_protocol);
 	if (IS_ERR(tag_ops)) {
 		if (PTR_ERR(tag_ops) == -ENOPROTOOPT)
 			return -EPROBE_DEFER;
 		dev_warn(ds->dev, "No tagger for this switch\n");
+		dp->master = NULL;
 		return PTR_ERR(tag_ops);
 	}
 
+	dp->master = master;
 	dp->type = DSA_PORT_TYPE_CPU;
 	dp->filter = tag_ops->filter;
 	dp->rcv = tag_ops->rcv;
 	dp->tag_ops = tag_ops;
-	dp->master = master;
 	dp->dst = dst;
 
 	return 0;

commit 4e2ce6e55050125d313408770d20dbf387dfc79c
Author: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
Date:   Tue Dec 17 11:20:38 2019 +0000

    net: dsa: make unexported dsa_link_touch() static
    
    dsa_link_touch() is not exported, or defined outside of the
    file it is in so make it static to avoid the following warning:
    
    net/dsa/dsa2.c:127:17: warning: symbol 'dsa_link_touch' was not declared. Should it be static?
    
    Signed-off-by: Ben Dooks (Codethink) <ben.dooks@codethink.co.uk>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 9ef2caa13f27..c66abbed4daf 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -124,7 +124,8 @@ static struct dsa_port *dsa_tree_find_port_by_node(struct dsa_switch_tree *dst,
 	return NULL;
 }
 
-struct dsa_link *dsa_link_touch(struct dsa_port *dp, struct dsa_port *link_dp)
+static struct dsa_link *dsa_link_touch(struct dsa_port *dp,
+				       struct dsa_port *link_dp)
 {
 	struct dsa_switch *ds = dp->ds;
 	struct dsa_switch_tree *dst;

commit c058f6dfeb1c645e77dc89d1690848ca06f45735
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sat Nov 2 20:13:26 2019 -0700

    net: dsa: Fix use after free in dsa_switch_remove()
    
    The order in which the ports are deleted from the list and freed and the
    call to dsa_switch_remove() is done is reversed, which leads to an
    use after free condition. Reverse the two: first tear down the ports and
    switch from the fabric, then free the ports associated with that switch
    fabric.
    
    Fixes: 05f294a85235 ("net: dsa: allocate ports on touch")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index ff2fa3950c62..9ef2caa13f27 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -874,12 +874,13 @@ static void dsa_switch_remove(struct dsa_switch *ds)
 	struct dsa_switch_tree *dst = ds->dst;
 	struct dsa_port *dp, *next;
 
+	dsa_tree_teardown(dst);
+
 	list_for_each_entry_safe(dp, next, &dst->ports, list) {
 		list_del(&dp->list);
 		kfree(dp);
 	}
 
-	dsa_tree_teardown(dst);
 	dsa_tree_put(dst);
 }
 

commit 27d4d19d7c82b3fd9d09ac9e2cd73c70ed4ca4b2
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Wed Oct 30 22:09:18 2019 -0400

    net: dsa: remove limitation of switch index value
    
    Because there is no static array describing the links between switches
    anymore, we have no reason to force a limitation of the index value
    set by the device tree.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 371f15042dad..ff2fa3950c62 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -711,8 +711,6 @@ static int dsa_switch_parse_member_of(struct dsa_switch *ds,
 		return sz;
 
 	ds->index = m[1];
-	if (ds->index >= DSA_MAX_SWITCHES)
-		return -EINVAL;
 
 	ds->dst = dsa_tree_touch(m[0]);
 	if (!ds->dst)

commit 8e5cb84c67e085ad4d8005dcecba3201f2b54504
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Wed Oct 30 22:09:17 2019 -0400

    net: dsa: remove tree functions related to switches
    
    The DSA fabric setup code has been simplified a lot so get rid of
    the dsa_tree_remove_switch, dsa_tree_add_switch and dsa_switch_add
    helpers, and keep the code simple with only the dsa_switch_probe and
    dsa_switch_remove functions.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 92e71b12b729..371f15042dad 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -573,29 +573,6 @@ static void dsa_tree_teardown(struct dsa_switch_tree *dst)
 	dst->setup = false;
 }
 
-static void dsa_tree_remove_switch(struct dsa_switch_tree *dst,
-				   unsigned int index)
-{
-	dsa_tree_teardown(dst);
-
-	dsa_tree_put(dst);
-}
-
-static int dsa_tree_add_switch(struct dsa_switch_tree *dst,
-			       struct dsa_switch *ds)
-{
-	int err;
-
-	dsa_tree_get(dst);
-
-	err = dsa_tree_setup(dst);
-	if (err) {
-		dsa_tree_put(dst);
-	}
-
-	return err;
-}
-
 static struct dsa_port *dsa_port_touch(struct dsa_switch *ds, int index)
 {
 	struct dsa_switch_tree *dst = ds->dst;
@@ -846,15 +823,9 @@ static int dsa_switch_parse(struct dsa_switch *ds, struct dsa_chip_data *cd)
 	return dsa_switch_parse_ports(ds, cd);
 }
 
-static int dsa_switch_add(struct dsa_switch *ds)
-{
-	struct dsa_switch_tree *dst = ds->dst;
-
-	return dsa_tree_add_switch(dst, ds);
-}
-
 static int dsa_switch_probe(struct dsa_switch *ds)
 {
+	struct dsa_switch_tree *dst;
 	struct dsa_chip_data *pdata;
 	struct device_node *np;
 	int err;
@@ -878,7 +849,13 @@ static int dsa_switch_probe(struct dsa_switch *ds)
 	if (err)
 		return err;
 
-	return dsa_switch_add(ds);
+	dst = ds->dst;
+	dsa_tree_get(dst);
+	err = dsa_tree_setup(dst);
+	if (err)
+		dsa_tree_put(dst);
+
+	return err;
 }
 
 int dsa_register_switch(struct dsa_switch *ds)
@@ -897,7 +874,6 @@ EXPORT_SYMBOL_GPL(dsa_register_switch);
 static void dsa_switch_remove(struct dsa_switch *ds)
 {
 	struct dsa_switch_tree *dst = ds->dst;
-	unsigned int index = ds->index;
 	struct dsa_port *dp, *next;
 
 	list_for_each_entry_safe(dp, next, &dst->ports, list) {
@@ -905,7 +881,8 @@ static void dsa_switch_remove(struct dsa_switch *ds)
 		kfree(dp);
 	}
 
-	dsa_tree_remove_switch(dst, index);
+	dsa_tree_teardown(dst);
+	dsa_tree_put(dst);
 }
 
 void dsa_unregister_switch(struct dsa_switch *ds)

commit 9c8ad1ab66b577526a4c89e4a222e0fac431a2d6
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Wed Oct 30 22:09:16 2019 -0400

    net: dsa: remove the dst->ds array
    
    Now that the DSA ports are listed in the switch fabric, there is
    no need to store the dsa_switch structures from the drivers in the
    fabric anymore. So get rid of the dst->ds static array.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index a887231fff13..92e71b12b729 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -578,25 +578,18 @@ static void dsa_tree_remove_switch(struct dsa_switch_tree *dst,
 {
 	dsa_tree_teardown(dst);
 
-	dst->ds[index] = NULL;
 	dsa_tree_put(dst);
 }
 
 static int dsa_tree_add_switch(struct dsa_switch_tree *dst,
 			       struct dsa_switch *ds)
 {
-	unsigned int index = ds->index;
 	int err;
 
-	if (dst->ds[index])
-		return -EBUSY;
-
 	dsa_tree_get(dst);
-	dst->ds[index] = ds;
 
 	err = dsa_tree_setup(dst);
 	if (err) {
-		dst->ds[index] = NULL;
 		dsa_tree_put(dst);
 	}
 

commit 3774ecdb8ca201af770288d57997dbf6445eb3c8
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Wed Oct 30 22:09:15 2019 -0400

    net: dsa: remove switch routing table setup code
    
    The dsa_switch structure has no routing table specific data to setup,
    so the switch fabric can directly walk its ports and initialize its
    routing table from them.
    
    This allows us to remove the dsa_switch_setup_routing_table function.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index efd7453f308e..a887231fff13 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -176,14 +176,13 @@ static bool dsa_port_setup_routing_table(struct dsa_port *dp)
 	return true;
 }
 
-static bool dsa_switch_setup_routing_table(struct dsa_switch *ds)
+static bool dsa_tree_setup_routing_table(struct dsa_switch_tree *dst)
 {
-	struct dsa_switch_tree *dst = ds->dst;
 	bool complete = true;
 	struct dsa_port *dp;
 
 	list_for_each_entry(dp, &dst->ports, list) {
-		if (dp->ds == ds && dsa_port_is_dsa(dp)) {
+		if (dsa_port_is_dsa(dp)) {
 			complete = dsa_port_setup_routing_table(dp);
 			if (!complete)
 				break;
@@ -193,25 +192,6 @@ static bool dsa_switch_setup_routing_table(struct dsa_switch *ds)
 	return complete;
 }
 
-static bool dsa_tree_setup_routing_table(struct dsa_switch_tree *dst)
-{
-	struct dsa_switch *ds;
-	bool complete = true;
-	int device;
-
-	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
-		ds = dst->ds[device];
-		if (!ds)
-			continue;
-
-		complete = dsa_switch_setup_routing_table(ds);
-		if (!complete)
-			break;
-	}
-
-	return complete;
-}
-
 static struct dsa_port *dsa_tree_find_first_cpu(struct dsa_switch_tree *dst)
 {
 	struct dsa_port *dp;

commit 96252b8e05326df072cd321159878aa4725c5bd4
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Wed Oct 30 22:09:14 2019 -0400

    net: dsa: remove ds->rtable
    
    Drivers do not use the ds->rtable static arrays anymore, get rid of it.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 222d7dbfcfea..efd7453f308e 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -181,10 +181,6 @@ static bool dsa_switch_setup_routing_table(struct dsa_switch *ds)
 	struct dsa_switch_tree *dst = ds->dst;
 	bool complete = true;
 	struct dsa_port *dp;
-	int i;
-
-	for (i = 0; i < DSA_MAX_SWITCHES; i++)
-		ds->rtable[i] = DSA_RTABLE_NONE;
 
 	list_for_each_entry(dp, &dst->ports, list) {
 		if (dp->ds == ds && dsa_port_is_dsa(dp)) {

commit c5f51765a1f60b701840544faf3ca63204b8dc3c
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Wed Oct 30 22:09:13 2019 -0400

    net: dsa: list DSA links in the fabric
    
    Implement a new list of DSA links in the switch fabric itself, to
    provide an alterative to the ds->rtable static arrays.
    
    At the same time, provide a new dsa_routing_port() helper to abstract
    the usage of ds->rtable in drivers. If there's no port to reach a
    given device, return the first invalid port, ds->num_ports. This avoids
    potential signedness errors or the need to define special values.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index e7aae96b54bb..222d7dbfcfea 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -45,6 +45,8 @@ static struct dsa_switch_tree *dsa_tree_alloc(int index)
 
 	dst->index = index;
 
+	INIT_LIST_HEAD(&dst->rtable);
+
 	INIT_LIST_HEAD(&dst->ports);
 
 	INIT_LIST_HEAD(&dst->list);
@@ -122,6 +124,31 @@ static struct dsa_port *dsa_tree_find_port_by_node(struct dsa_switch_tree *dst,
 	return NULL;
 }
 
+struct dsa_link *dsa_link_touch(struct dsa_port *dp, struct dsa_port *link_dp)
+{
+	struct dsa_switch *ds = dp->ds;
+	struct dsa_switch_tree *dst;
+	struct dsa_link *dl;
+
+	dst = ds->dst;
+
+	list_for_each_entry(dl, &dst->rtable, list)
+		if (dl->dp == dp && dl->link_dp == link_dp)
+			return dl;
+
+	dl = kzalloc(sizeof(*dl), GFP_KERNEL);
+	if (!dl)
+		return NULL;
+
+	dl->dp = dp;
+	dl->link_dp = link_dp;
+
+	INIT_LIST_HEAD(&dl->list);
+	list_add_tail(&dl->list, &dst->rtable);
+
+	return dl;
+}
+
 static bool dsa_port_setup_routing_table(struct dsa_port *dp)
 {
 	struct dsa_switch *ds = dp->ds;
@@ -129,6 +156,7 @@ static bool dsa_port_setup_routing_table(struct dsa_port *dp)
 	struct device_node *dn = dp->dn;
 	struct of_phandle_iterator it;
 	struct dsa_port *link_dp;
+	struct dsa_link *dl;
 	int err;
 
 	of_for_each_phandle(&it, err, dn, "link", NULL, 0) {
@@ -138,7 +166,11 @@ static bool dsa_port_setup_routing_table(struct dsa_port *dp)
 			return false;
 		}
 
-		ds->rtable[link_dp->ds->index] = dp->index;
+		dl = dsa_link_touch(dp, link_dp);
+		if (!dl) {
+			of_node_put(it.node);
+			return false;
+		}
 	}
 
 	return true;
@@ -544,6 +576,8 @@ static int dsa_tree_setup(struct dsa_switch_tree *dst)
 
 static void dsa_tree_teardown(struct dsa_switch_tree *dst)
 {
+	struct dsa_link *dl, *next;
+
 	if (!dst->setup)
 		return;
 
@@ -553,6 +587,11 @@ static void dsa_tree_teardown(struct dsa_switch_tree *dst)
 
 	dsa_tree_teardown_default_cpu(dst);
 
+	list_for_each_entry_safe(dl, next, &dst->rtable, list) {
+		list_del(&dl->list);
+		kfree(dl);
+	}
+
 	pr_info("DSA: tree %d torn down\n", dst->index);
 
 	dst->setup = false;

commit 6b297524234ccf3954b54609ab6bc2e8c4d3f677
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Fri Oct 25 01:03:51 2019 +0200

    net: dsa: Add support for devlink device parameters
    
    Add plumbing to allow DSA drivers to register parameters with devlink.
    
    To keep with the abstraction, the DSA drivers pass the ds structure to
    these helpers, and the DSA core then translates that to the devlink
    structure associated to the device.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 214dd703b0cc..e7aae96b54bb 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -349,6 +349,7 @@ static void dsa_port_teardown(struct dsa_port *dp)
 
 static int dsa_switch_setup(struct dsa_switch *ds)
 {
+	struct dsa_devlink_priv *dl_priv;
 	int err;
 
 	if (ds->setup)
@@ -364,9 +365,11 @@ static int dsa_switch_setup(struct dsa_switch *ds)
 	/* Add the switch to devlink before calling setup, so that setup can
 	 * add dpipe tables
 	 */
-	ds->devlink = devlink_alloc(&dsa_devlink_ops, 0);
+	ds->devlink = devlink_alloc(&dsa_devlink_ops, sizeof(*dl_priv));
 	if (!ds->devlink)
 		return -ENOMEM;
+	dl_priv = devlink_priv(ds->devlink);
+	dl_priv->ds = ds;
 
 	err = devlink_register(ds->devlink, ds->dev);
 	if (err)
@@ -380,6 +383,8 @@ static int dsa_switch_setup(struct dsa_switch *ds)
 	if (err < 0)
 		goto unregister_notifier;
 
+	devlink_params_publish(ds->devlink);
+
 	if (!ds->slave_mii_bus && ds->ops->phy_read) {
 		ds->slave_mii_bus = devm_mdiobus_alloc(ds->dev);
 		if (!ds->slave_mii_bus) {

commit 556f124fb30621df3089d624ac57f13744712753
Author: Colin Ian King <colin.king@canonical.com>
Date:   Thu Oct 24 11:32:18 2019 +0100

    net: dsa: fix dereference on ds->dev before null check error
    
    Currently ds->dev is dereferenced on the assignments of pdata and
    np before ds->dev is null checked, hence there is a potential null
    pointer dereference on ds->dev.  Fix this by assigning pdata and
    np after the ds->dev null pointer sanity check.
    
    Addresses-Coverity: ("Dereference before null check")
    Fixes: 7e99e3470172 ("net: dsa: remove dsa_switch_alloc helper")
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reported-by: kbuild test robot <lkp@intel.com>
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 1e3ac9b56c89..214dd703b0cc 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -842,13 +842,16 @@ static int dsa_switch_add(struct dsa_switch *ds)
 
 static int dsa_switch_probe(struct dsa_switch *ds)
 {
-	struct dsa_chip_data *pdata = ds->dev->platform_data;
-	struct device_node *np = ds->dev->of_node;
+	struct dsa_chip_data *pdata;
+	struct device_node *np;
 	int err;
 
 	if (!ds->dev)
 		return -ENODEV;
 
+	pdata = ds->dev->platform_data;
+	np = ds->dev->of_node;
+
 	if (!ds->num_ports)
 		return -EINVAL;
 

commit 7e99e34701728d54ccd0466eccf377a42b9db215
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Oct 21 16:51:30 2019 -0400

    net: dsa: remove dsa_switch_alloc helper
    
    Now that ports are dynamically listed in the fabric, there is no need
    to provide a special helper to allocate the dsa_switch structure. This
    will give more flexibility to drivers to embed this structure as they
    wish in their private structure.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 83cba4623698..1e3ac9b56c89 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -846,6 +846,12 @@ static int dsa_switch_probe(struct dsa_switch *ds)
 	struct device_node *np = ds->dev->of_node;
 	int err;
 
+	if (!ds->dev)
+		return -ENODEV;
+
+	if (!ds->num_ports)
+		return -EINVAL;
+
 	if (np)
 		err = dsa_switch_parse_of(ds, np);
 	else if (pdata)
@@ -859,21 +865,6 @@ static int dsa_switch_probe(struct dsa_switch *ds)
 	return dsa_switch_add(ds);
 }
 
-struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
-{
-	struct dsa_switch *ds;
-
-	ds = devm_kzalloc(dev, sizeof(*ds), GFP_KERNEL);
-	if (!ds)
-		return NULL;
-
-	ds->dev = dev;
-	ds->num_ports = n;
-
-	return ds;
-}
-EXPORT_SYMBOL_GPL(dsa_switch_alloc);
-
 int dsa_register_switch(struct dsa_switch *ds)
 {
 	int err;

commit 05f294a852358a46d9236cc777901f49a4f0ae85
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Oct 21 16:51:29 2019 -0400

    net: dsa: allocate ports on touch
    
    Allocate the struct dsa_port the first time it is accessed with
    dsa_port_touch, and remove the static dsa_port array from the
    dsa_switch structure.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index bf8b4e0fcb4f..83cba4623698 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -588,7 +588,13 @@ static struct dsa_port *dsa_port_touch(struct dsa_switch *ds, int index)
 	struct dsa_switch_tree *dst = ds->dst;
 	struct dsa_port *dp;
 
-	dp = &ds->ports[index];
+	list_for_each_entry(dp, &dst->ports, list)
+		if (dp->ds == ds && dp->index == index)
+			return dp;
+
+	dp = kzalloc(sizeof(*dp), GFP_KERNEL);
+	if (!dp)
+		return NULL;
 
 	dp->ds = ds;
 	dp->index = index;
@@ -857,7 +863,7 @@ struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
 {
 	struct dsa_switch *ds;
 
-	ds = devm_kzalloc(dev, struct_size(ds, ports, n), GFP_KERNEL);
+	ds = devm_kzalloc(dev, sizeof(*ds), GFP_KERNEL);
 	if (!ds)
 		return NULL;
 
@@ -885,6 +891,12 @@ static void dsa_switch_remove(struct dsa_switch *ds)
 {
 	struct dsa_switch_tree *dst = ds->dst;
 	unsigned int index = ds->index;
+	struct dsa_port *dp, *next;
+
+	list_for_each_entry_safe(dp, next, &dst->ports, list) {
+		list_del(&dp->list);
+		kfree(dp);
+	}
 
 	dsa_tree_remove_switch(dst, index);
 }

commit da4561cda2ea6240fc61442eeb2acc47e2e0cae3
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Oct 21 16:51:24 2019 -0400

    net: dsa: use ports list to setup default CPU port
    
    Use the new ports list instead of iterating over switches and their
    ports when setting up the default CPU port. Unassign it on teardown.
    
    Now that we can iterate over multiple CPU ports, remove dst->cpu_dp.
    
    At the same time, provide a better error message for CPU-less tree.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 80191c7702a9..bf8b4e0fcb4f 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -197,38 +197,29 @@ static struct dsa_port *dsa_tree_find_first_cpu(struct dsa_switch_tree *dst)
 
 static int dsa_tree_setup_default_cpu(struct dsa_switch_tree *dst)
 {
-	struct dsa_switch *ds;
-	struct dsa_port *dp;
-	int device, port;
+	struct dsa_port *cpu_dp, *dp;
 
-	/* DSA currently only supports a single CPU port */
-	dst->cpu_dp = dsa_tree_find_first_cpu(dst);
-	if (!dst->cpu_dp) {
-		pr_warn("Tree has no master device\n");
+	cpu_dp = dsa_tree_find_first_cpu(dst);
+	if (!cpu_dp) {
+		pr_err("DSA: tree %d has no CPU port\n", dst->index);
 		return -EINVAL;
 	}
 
 	/* Assign the default CPU port to all ports of the fabric */
-	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
-		ds = dst->ds[device];
-		if (!ds)
-			continue;
-
-		for (port = 0; port < ds->num_ports; port++) {
-			dp = &ds->ports[port];
-
-			if (dsa_port_is_user(dp) || dsa_port_is_dsa(dp))
-				dp->cpu_dp = dst->cpu_dp;
-		}
-	}
+	list_for_each_entry(dp, &dst->ports, list)
+		if (dsa_port_is_user(dp) || dsa_port_is_dsa(dp))
+			dp->cpu_dp = cpu_dp;
 
 	return 0;
 }
 
 static void dsa_tree_teardown_default_cpu(struct dsa_switch_tree *dst)
 {
-	/* DSA currently only supports a single CPU port */
-	dst->cpu_dp = NULL;
+	struct dsa_port *dp;
+
+	list_for_each_entry(dp, &dst->ports, list)
+		if (dsa_port_is_user(dp) || dsa_port_is_dsa(dp))
+			dp->cpu_dp = NULL;
 }
 
 static int dsa_port_setup(struct dsa_port *dp)

commit c0b736282ccf6d9450f3bed55a134f2123a7a565
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Oct 21 16:51:23 2019 -0400

    net: dsa: use ports list to find first CPU port
    
    Use the new ports list instead of iterating over switches and their
    ports when looking up the first CPU port in the tree.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 514c0195e2e8..80191c7702a9 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -186,22 +186,11 @@ static bool dsa_tree_setup_routing_table(struct dsa_switch_tree *dst)
 
 static struct dsa_port *dsa_tree_find_first_cpu(struct dsa_switch_tree *dst)
 {
-	struct dsa_switch *ds;
 	struct dsa_port *dp;
-	int device, port;
-
-	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
-		ds = dst->ds[device];
-		if (!ds)
-			continue;
 
-		for (port = 0; port < ds->num_ports; port++) {
-			dp = &ds->ports[port];
-
-			if (dsa_port_is_cpu(dp))
-				return dp;
-		}
-	}
+	list_for_each_entry(dp, &dst->ports, list)
+		if (dsa_port_is_cpu(dp))
+			return dp;
 
 	return NULL;
 }

commit 0cfec588ec210e82e6572d1fb10db195fcc41a87
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Oct 21 16:51:22 2019 -0400

    net: dsa: use ports list to setup multiple master devices
    
    Now that we have a potential list of CPU ports, make use of it instead
    of only configuring the master device of an unique CPU port.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index a4de7ff8b19b..514c0195e2e8 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -493,19 +493,27 @@ static void dsa_tree_teardown_switches(struct dsa_switch_tree *dst)
 
 static int dsa_tree_setup_master(struct dsa_switch_tree *dst)
 {
-	struct dsa_port *cpu_dp = dst->cpu_dp;
-	struct net_device *master = cpu_dp->master;
+	struct dsa_port *dp;
+	int err;
 
-	/* DSA currently supports a single pair of CPU port and master device */
-	return dsa_master_setup(master, cpu_dp);
+	list_for_each_entry(dp, &dst->ports, list) {
+		if (dsa_port_is_cpu(dp)) {
+			err = dsa_master_setup(dp->master, dp);
+			if (err)
+				return err;
+		}
+	}
+
+	return 0;
 }
 
 static void dsa_tree_teardown_master(struct dsa_switch_tree *dst)
 {
-	struct dsa_port *cpu_dp = dst->cpu_dp;
-	struct net_device *master = cpu_dp->master;
+	struct dsa_port *dp;
 
-	return dsa_master_teardown(master);
+	list_for_each_entry(dp, &dst->ports, list)
+		if (dsa_port_is_cpu(dp))
+			dsa_master_teardown(dp->master);
 }
 
 static int dsa_tree_setup(struct dsa_switch_tree *dst)

commit 764b7e624284c3f41bdd15bd4e077d8ec5b8c686
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Oct 21 16:51:21 2019 -0400

    net: dsa: use ports list to find a port by node
    
    Use the new ports list instead of iterating over switches and their
    ports to find a port from a given node.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 623805ba8e1a..a4de7ff8b19b 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -113,22 +113,11 @@ static bool dsa_port_is_user(struct dsa_port *dp)
 static struct dsa_port *dsa_tree_find_port_by_node(struct dsa_switch_tree *dst,
 						   struct device_node *dn)
 {
-	struct dsa_switch *ds;
 	struct dsa_port *dp;
-	int device, port;
-
-	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
-		ds = dst->ds[device];
-		if (!ds)
-			continue;
 
-		for (port = 0; port < ds->num_ports; port++) {
-			dp = &ds->ports[port];
-
-			if (dp->dn == dn)
-				return dp;
-		}
-	}
+	list_for_each_entry(dp, &dst->ports, list)
+		if (dp->dn == dn)
+			return dp;
 
 	return NULL;
 }

commit 86bfb2c1f4337d3306d235f615d35ba8bbbe4650
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Oct 21 16:51:20 2019 -0400

    net: dsa: use ports list for routing table setup
    
    Use the new ports list instead of accessing the dsa_switch array
    of ports when iterating over DSA ports of a switch to set up the
    routing table.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 01b6047d9b7b..623805ba8e1a 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -157,6 +157,7 @@ static bool dsa_port_setup_routing_table(struct dsa_port *dp)
 
 static bool dsa_switch_setup_routing_table(struct dsa_switch *ds)
 {
+	struct dsa_switch_tree *dst = ds->dst;
 	bool complete = true;
 	struct dsa_port *dp;
 	int i;
@@ -164,10 +165,8 @@ static bool dsa_switch_setup_routing_table(struct dsa_switch *ds)
 	for (i = 0; i < DSA_MAX_SWITCHES; i++)
 		ds->rtable[i] = DSA_RTABLE_NONE;
 
-	for (i = 0; i < ds->num_ports; i++) {
-		dp = &ds->ports[i];
-
-		if (dsa_port_is_dsa(dp)) {
+	list_for_each_entry(dp, &dst->ports, list) {
+		if (dp->ds == ds && dsa_port_is_dsa(dp)) {
 			complete = dsa_port_setup_routing_table(dp);
 			if (!complete)
 				break;

commit fb35c60cbacc67a6075fb8e3d98fa348665662fe
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Oct 21 16:51:19 2019 -0400

    net: dsa: use ports list to setup switches
    
    Use the new ports list instead of iterating over switches and their
    ports when setting up the switches and their ports.
    
    At the same time, provide setup states and messages for ports and
    switches as it is done for the trees.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index ba27ff8b4445..01b6047d9b7b 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -267,6 +267,9 @@ static int dsa_port_setup(struct dsa_port *dp)
 	bool dsa_port_enabled = false;
 	int err = 0;
 
+	if (dp->setup)
+		return 0;
+
 	switch (dp->type) {
 	case DSA_PORT_TYPE_UNUSED:
 		dsa_port_disable(dp);
@@ -335,14 +338,21 @@ static int dsa_port_setup(struct dsa_port *dp)
 		dsa_port_link_unregister_of(dp);
 	if (err && devlink_port_registered)
 		devlink_port_unregister(dlp);
+	if (err)
+		return err;
 
-	return err;
+	dp->setup = true;
+
+	return 0;
 }
 
 static void dsa_port_teardown(struct dsa_port *dp)
 {
 	struct devlink_port *dlp = &dp->devlink_port;
 
+	if (!dp->setup)
+		return;
+
 	switch (dp->type) {
 	case DSA_PORT_TYPE_UNUSED:
 		break;
@@ -365,11 +375,16 @@ static void dsa_port_teardown(struct dsa_port *dp)
 		}
 		break;
 	}
+
+	dp->setup = false;
 }
 
 static int dsa_switch_setup(struct dsa_switch *ds)
 {
-	int err = 0;
+	int err;
+
+	if (ds->setup)
+		return 0;
 
 	/* Initialize ds->phys_mii_mask before registering the slave MDIO bus
 	 * driver and before ops->setup() has run, since the switch drivers and
@@ -411,6 +426,8 @@ static int dsa_switch_setup(struct dsa_switch *ds)
 			goto unregister_notifier;
 	}
 
+	ds->setup = true;
+
 	return 0;
 
 unregister_notifier:
@@ -426,6 +443,9 @@ static int dsa_switch_setup(struct dsa_switch *ds)
 
 static void dsa_switch_teardown(struct dsa_switch *ds)
 {
+	if (!ds->setup)
+		return;
+
 	if (ds->slave_mii_bus && ds->ops->phy_read)
 		mdiobus_unregister(ds->slave_mii_bus);
 
@@ -440,78 +460,47 @@ static void dsa_switch_teardown(struct dsa_switch *ds)
 		ds->devlink = NULL;
 	}
 
+	ds->setup = false;
 }
 
 static int dsa_tree_setup_switches(struct dsa_switch_tree *dst)
 {
-	struct dsa_switch *ds;
 	struct dsa_port *dp;
-	int device, port, i;
-	int err = 0;
-
-	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
-		ds = dst->ds[device];
-		if (!ds)
-			continue;
+	int err;
 
-		err = dsa_switch_setup(ds);
+	list_for_each_entry(dp, &dst->ports, list) {
+		err = dsa_switch_setup(dp->ds);
 		if (err)
-			goto switch_teardown;
-
-		for (port = 0; port < ds->num_ports; port++) {
-			dp = &ds->ports[port];
+			goto teardown;
+	}
 
-			err = dsa_port_setup(dp);
-			if (err)
-				goto ports_teardown;
-		}
+	list_for_each_entry(dp, &dst->ports, list) {
+		err = dsa_port_setup(dp);
+		if (err)
+			goto teardown;
 	}
 
 	return 0;
 
-ports_teardown:
-	for (i = 0; i < port; i++)
-		dsa_port_teardown(&ds->ports[i]);
-
-	dsa_switch_teardown(ds);
-
-switch_teardown:
-	for (i = 0; i < device; i++) {
-		ds = dst->ds[i];
-		if (!ds)
-			continue;
-
-		for (port = 0; port < ds->num_ports; port++) {
-			dp = &ds->ports[port];
-
-			dsa_port_teardown(dp);
-		}
+teardown:
+	list_for_each_entry(dp, &dst->ports, list)
+		dsa_port_teardown(dp);
 
-		dsa_switch_teardown(ds);
-	}
+	list_for_each_entry(dp, &dst->ports, list)
+		dsa_switch_teardown(dp->ds);
 
 	return err;
 }
 
 static void dsa_tree_teardown_switches(struct dsa_switch_tree *dst)
 {
-	struct dsa_switch *ds;
 	struct dsa_port *dp;
-	int device, port;
 
-	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
-		ds = dst->ds[device];
-		if (!ds)
-			continue;
+	list_for_each_entry(dp, &dst->ports, list)
+		dsa_port_teardown(dp);
 
-		for (port = 0; port < ds->num_ports; port++) {
-			dp = &ds->ports[port];
-
-			dsa_port_teardown(dp);
-		}
-
-		dsa_switch_teardown(ds);
-	}
+	list_for_each_entry(dp, &dst->ports, list)
+		dsa_switch_teardown(dp->ds);
 }
 
 static int dsa_tree_setup_master(struct dsa_switch_tree *dst)

commit ab8ccae122a41530a89bc899ace0e46defb156a8
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Oct 21 16:51:16 2019 -0400

    net: dsa: add ports list in the switch fabric
    
    Add a list of switch ports within the switch fabric. This will help the
    lookup of a port inside the whole fabric, and it is the first step
    towards supporting multiple CPU ports, before deprecating the usage of
    the unique dst->cpu_dp pointer.
    
    In preparation for a future allocation of the dsa_port structures,
    return -ENOMEM in case no structure is returned, even though this
    error cannot be reached yet.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 1716535167ee..ba27ff8b4445 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -45,6 +45,8 @@ static struct dsa_switch_tree *dsa_tree_alloc(int index)
 
 	dst->index = index;
 
+	INIT_LIST_HEAD(&dst->ports);
+
 	INIT_LIST_HEAD(&dst->list);
 	list_add_tail(&dst->list, &dsa_tree_list);
 
@@ -616,6 +618,22 @@ static int dsa_tree_add_switch(struct dsa_switch_tree *dst,
 	return err;
 }
 
+static struct dsa_port *dsa_port_touch(struct dsa_switch *ds, int index)
+{
+	struct dsa_switch_tree *dst = ds->dst;
+	struct dsa_port *dp;
+
+	dp = &ds->ports[index];
+
+	dp->ds = ds;
+	dp->index = index;
+
+	INIT_LIST_HEAD(&dp->list);
+	list_add_tail(&dp->list, &dst->ports);
+
+	return dp;
+}
+
 static int dsa_port_parse_user(struct dsa_port *dp, const char *name)
 {
 	if (!name)
@@ -742,6 +760,20 @@ static int dsa_switch_parse_member_of(struct dsa_switch *ds,
 	return 0;
 }
 
+static int dsa_switch_touch_ports(struct dsa_switch *ds)
+{
+	struct dsa_port *dp;
+	int port;
+
+	for (port = 0; port < ds->num_ports; port++) {
+		dp = dsa_port_touch(ds, port);
+		if (!dp)
+			return -ENOMEM;
+	}
+
+	return 0;
+}
+
 static int dsa_switch_parse_of(struct dsa_switch *ds, struct device_node *dn)
 {
 	int err;
@@ -750,6 +782,10 @@ static int dsa_switch_parse_of(struct dsa_switch *ds, struct device_node *dn)
 	if (err)
 		return err;
 
+	err = dsa_switch_touch_ports(ds);
+	if (err)
+		return err;
+
 	return dsa_switch_parse_ports_of(ds, dn);
 }
 
@@ -807,6 +843,8 @@ static int dsa_switch_parse_ports(struct dsa_switch *ds,
 
 static int dsa_switch_parse(struct dsa_switch *ds, struct dsa_chip_data *cd)
 {
+	int err;
+
 	ds->cd = cd;
 
 	/* We don't support interconnected switches nor multiple trees via
@@ -817,6 +855,10 @@ static int dsa_switch_parse(struct dsa_switch *ds, struct dsa_chip_data *cd)
 	if (!ds->dst)
 		return -ENOMEM;
 
+	err = dsa_switch_touch_ports(ds);
+	if (err)
+		return err;
+
 	return dsa_switch_parse_ports(ds, cd);
 }
 
@@ -849,7 +891,6 @@ static int dsa_switch_probe(struct dsa_switch *ds)
 struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
 {
 	struct dsa_switch *ds;
-	int i;
 
 	ds = devm_kzalloc(dev, struct_size(ds, ports, n), GFP_KERNEL);
 	if (!ds)
@@ -858,11 +899,6 @@ struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
 	ds->dev = dev;
 	ds->num_ports = n;
 
-	for (i = 0; i < ds->num_ports; ++i) {
-		ds->ports[i].index = i;
-		ds->ports[i].ds = ds;
-	}
-
 	return ds;
 }
 EXPORT_SYMBOL_GPL(dsa_switch_alloc);

commit 68bb8ea8ad0d497c28ed47423246b1ab20f26976
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Oct 21 16:51:15 2019 -0400

    net: dsa: use dsa_to_port helper everywhere
    
    Do not let the drivers access the ds->ports static array directly
    while there is a dsa_to_port helper for this purpose.
    
    At the same time, un-const this helper since the SJA1105 driver
    assigns the priv member of the returned dsa_port structure.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Jakub Kicinski <jakub.kicinski@netronome.com>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 716d265ba8ca..1716535167ee 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -708,7 +708,7 @@ static int dsa_switch_parse_ports_of(struct dsa_switch *ds,
 			goto out_put_node;
 		}
 
-		dp = &ds->ports[reg];
+		dp = dsa_to_port(ds, reg);
 
 		err = dsa_port_parse_of(dp, port);
 		if (err)
@@ -787,7 +787,7 @@ static int dsa_switch_parse_ports(struct dsa_switch *ds,
 	for (i = 0; i < DSA_MAX_PORTS; i++) {
 		name = cd->port_names[i];
 		dev = cd->netdev[i];
-		dp = &ds->ports[i];
+		dp = dsa_to_port(ds, i);
 
 		if (!name)
 			continue;

commit 50c7d2ba9de20f60a2d527ad6928209ef67e4cdd
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Fri Oct 18 17:02:46 2019 -0400

    net: dsa: fix switch tree list
    
    If there are multiple switch trees on the device, only the last one
    will be listed, because the arguments of list_add_tail are swapped.
    
    Fixes: 83c0afaec7b7 ("net: dsa: Add new binding implementation")
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 73002022c9d8..716d265ba8ca 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -46,7 +46,7 @@ static struct dsa_switch_tree *dsa_tree_alloc(int index)
 	dst->index = index;
 
 	INIT_LIST_HEAD(&dst->list);
-	list_add_tail(&dsa_tree_list, &dst->list);
+	list_add_tail(&dst->list, &dsa_tree_list);
 
 	kref_init(&dst->refcount);
 

commit 1bab8d4c488be22d57f9dd09968c90a0ddc413bf
Merge: 990925fad5c2 00b368502d18
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Sep 17 23:51:10 2019 +0200

    Merge ra.kernel.org:/pub/scm/linux/kernel/git/netdev/net
    
    Pull in bug fixes from 'net' tree for the merge window.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 23426a25e55a417dc104df08781b6eff95e65f3f
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Thu Sep 12 15:16:45 2019 +0200

    net: dsa: Fix load order between DSA drivers and taggers
    
    The DSA core, DSA taggers and DSA drivers all make use of
    module_init(). Hence they get initialised at device_initcall() time.
    The ordering is non-deterministic. It can be a DSA driver is bound to
    a device before the needed tag driver has been initialised, resulting
    in the message:
    
    No tagger for this switch
    
    Rather than have this be fatal, return -EPROBE_DEFER so that it is
    tried again later once all the needed drivers have been loaded.
    
    Fixes: d3b8c04988ca ("dsa: Add boilerplate helper to register DSA tag driver modules")
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 3abd173ebacb..96f787cf9b6e 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -623,6 +623,8 @@ static int dsa_port_parse_cpu(struct dsa_port *dp, struct net_device *master)
 	tag_protocol = ds->ops->get_tag_protocol(ds, dp->index);
 	tag_ops = dsa_tag_driver_get(tag_protocol);
 	if (IS_ERR(tag_ops)) {
+		if (PTR_ERR(tag_ops) == -ENOPROTOOPT)
+			return -EPROBE_DEFER;
 		dev_warn(ds->dev, "No tagger for this switch\n");
 		return PTR_ERR(tag_ops);
 	}

commit 4ba0ebbc6cdecb9fad7c551a3d97b172ebc7b2fa
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Aug 31 15:46:19 2019 +0300

    net: dsa: Fix off-by-one number of calls to devlink_port_unregister
    
    When a function such as dsa_slave_create fails, currently the following
    stack trace can be seen:
    
    [    2.038342] sja1105 spi0.1: Probed switch chip: SJA1105T
    [    2.054556] sja1105 spi0.1: Reset switch and programmed static config
    [    2.063837] sja1105 spi0.1: Enabled switch tagging
    [    2.068706] fsl-gianfar soc:ethernet@2d90000 eth2: error -19 setting up slave phy
    [    2.076371] ------------[ cut here ]------------
    [    2.080973] WARNING: CPU: 1 PID: 21 at net/core/devlink.c:6184 devlink_free+0x1b4/0x1c0
    [    2.088954] Modules linked in:
    [    2.092005] CPU: 1 PID: 21 Comm: kworker/1:1 Not tainted 5.3.0-rc6-01360-g41b52e38d2b6-dirty #1746
    [    2.100912] Hardware name: Freescale LS1021A
    [    2.105162] Workqueue: events deferred_probe_work_func
    [    2.110287] [<c03133a4>] (unwind_backtrace) from [<c030d8cc>] (show_stack+0x10/0x14)
    [    2.117992] [<c030d8cc>] (show_stack) from [<c10b08d8>] (dump_stack+0xb4/0xc8)
    [    2.125180] [<c10b08d8>] (dump_stack) from [<c0349d04>] (__warn+0xe0/0xf8)
    [    2.132018] [<c0349d04>] (__warn) from [<c0349e34>] (warn_slowpath_null+0x40/0x48)
    [    2.139549] [<c0349e34>] (warn_slowpath_null) from [<c0f19d74>] (devlink_free+0x1b4/0x1c0)
    [    2.147772] [<c0f19d74>] (devlink_free) from [<c1064fc0>] (dsa_switch_teardown+0x60/0x6c)
    [    2.155907] [<c1064fc0>] (dsa_switch_teardown) from [<c1065950>] (dsa_register_switch+0x8e4/0xaa8)
    [    2.164821] [<c1065950>] (dsa_register_switch) from [<c0ba7fe4>] (sja1105_probe+0x21c/0x2ec)
    [    2.173216] [<c0ba7fe4>] (sja1105_probe) from [<c0b35948>] (spi_drv_probe+0x80/0xa4)
    [    2.180920] [<c0b35948>] (spi_drv_probe) from [<c0a4c1cc>] (really_probe+0x108/0x400)
    [    2.188711] [<c0a4c1cc>] (really_probe) from [<c0a4c694>] (driver_probe_device+0x78/0x1bc)
    [    2.196933] [<c0a4c694>] (driver_probe_device) from [<c0a4a3dc>] (bus_for_each_drv+0x58/0xb8)
    [    2.205414] [<c0a4a3dc>] (bus_for_each_drv) from [<c0a4c024>] (__device_attach+0xd0/0x168)
    [    2.213637] [<c0a4c024>] (__device_attach) from [<c0a4b1d0>] (bus_probe_device+0x84/0x8c)
    [    2.221772] [<c0a4b1d0>] (bus_probe_device) from [<c0a4b72c>] (deferred_probe_work_func+0x84/0xc4)
    [    2.230686] [<c0a4b72c>] (deferred_probe_work_func) from [<c03650a4>] (process_one_work+0x218/0x510)
    [    2.239772] [<c03650a4>] (process_one_work) from [<c03660d8>] (worker_thread+0x2a8/0x5c0)
    [    2.247908] [<c03660d8>] (worker_thread) from [<c036b348>] (kthread+0x148/0x150)
    [    2.255265] [<c036b348>] (kthread) from [<c03010e8>] (ret_from_fork+0x14/0x2c)
    [    2.262444] Exception stack(0xea965fb0 to 0xea965ff8)
    [    2.267466] 5fa0:                                     00000000 00000000 00000000 00000000
    [    2.275598] 5fc0: 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000
    [    2.283729] 5fe0: 00000000 00000000 00000000 00000000 00000013 00000000
    [    2.290333] ---[ end trace ca5d506728a0581a ]---
    
    devlink_free is complaining right here:
    
            WARN_ON(!list_empty(&devlink->port_list));
    
    This happens because devlink_port_unregister is no longer done right
    away in dsa_port_setup when a DSA_PORT_TYPE_USER has failed.
    Vivien said about this change that:
    
        Also no need to call devlink_port_unregister from within dsa_port_setup
        as this step is inconditionally handled by dsa_port_teardown on error.
    
    which is not really true. The devlink_port_unregister function _is_
    being called unconditionally from within dsa_port_setup, but not for
    this port that just failed, just for the previous ones which were set
    up.
    
    ports_teardown:
            for (i = 0; i < port; i++)
                    dsa_port_teardown(&ds->ports[i]);
    
    Initially I was tempted to fix this by extending the "for" loop to also
    cover the port that failed during setup. But this could have potentially
    unforeseen consequences unrelated to devlink_port or even other types of
    ports than user ports, which I can't really test for. For example, if
    for some reason devlink_port_register itself would fail, then
    unconditionally unregistering it in dsa_port_teardown would not be a
    smart idea. The list might go on.
    
    So just make dsa_port_setup undo the setup it had done upon failure, and
    let the for loop undo the work of setting up the previous ports, which
    are guaranteed to be brought up to a consistent state.
    
    Fixes: 955222ca5281 ("net: dsa: use a single switch statement for port setup")
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index f8445fa73448..b501c90aabe4 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -259,8 +259,11 @@ static int dsa_port_setup(struct dsa_port *dp)
 	const unsigned char *id = (const unsigned char *)&dst->index;
 	const unsigned char len = sizeof(dst->index);
 	struct devlink_port *dlp = &dp->devlink_port;
+	bool dsa_port_link_registered = false;
+	bool devlink_port_registered = false;
 	struct devlink *dl = ds->devlink;
-	int err;
+	bool dsa_port_enabled = false;
+	int err = 0;
 
 	switch (dp->type) {
 	case DSA_PORT_TYPE_UNUSED:
@@ -272,15 +275,19 @@ static int dsa_port_setup(struct dsa_port *dp)
 				       dp->index, false, 0, id, len);
 		err = devlink_port_register(dl, dlp, dp->index);
 		if (err)
-			return err;
+			break;
+		devlink_port_registered = true;
 
 		err = dsa_port_link_register_of(dp);
 		if (err)
-			return err;
+			break;
+		dsa_port_link_registered = true;
 
 		err = dsa_port_enable(dp, NULL);
 		if (err)
-			return err;
+			break;
+		dsa_port_enabled = true;
+
 		break;
 	case DSA_PORT_TYPE_DSA:
 		memset(dlp, 0, sizeof(*dlp));
@@ -288,15 +295,19 @@ static int dsa_port_setup(struct dsa_port *dp)
 				       dp->index, false, 0, id, len);
 		err = devlink_port_register(dl, dlp, dp->index);
 		if (err)
-			return err;
+			break;
+		devlink_port_registered = true;
 
 		err = dsa_port_link_register_of(dp);
 		if (err)
-			return err;
+			break;
+		dsa_port_link_registered = true;
 
 		err = dsa_port_enable(dp, NULL);
 		if (err)
-			return err;
+			break;
+		dsa_port_enabled = true;
+
 		break;
 	case DSA_PORT_TYPE_USER:
 		memset(dlp, 0, sizeof(*dlp));
@@ -304,18 +315,26 @@ static int dsa_port_setup(struct dsa_port *dp)
 				       dp->index, false, 0, id, len);
 		err = devlink_port_register(dl, dlp, dp->index);
 		if (err)
-			return err;
+			break;
+		devlink_port_registered = true;
 
 		dp->mac = of_get_mac_address(dp->dn);
 		err = dsa_slave_create(dp);
 		if (err)
-			return err;
+			break;
 
 		devlink_port_type_eth_set(dlp, dp->slave);
 		break;
 	}
 
-	return 0;
+	if (err && dsa_port_enabled)
+		dsa_port_disable(dp);
+	if (err && dsa_port_link_registered)
+		dsa_port_link_unregister_of(dp);
+	if (err && devlink_port_registered)
+		devlink_port_unregister(dlp);
+
+	return err;
 }
 
 static void dsa_port_teardown(struct dsa_port *dp)

commit e65d45cc351ac5f1c11e6bac5669e536df753664
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Sun Aug 25 13:25:15 2019 -0400

    net: dsa: remove bitmap operations
    
    The bitmap operations were introduced to simplify the switch drivers
    in the future, since most of them could implement the common VLAN and
    MDB operations (add, del, dump) with simple functions taking all target
    ports at once, and thus limiting the number of hardware accesses.
    
    Programming an MDB or VLAN this way in a single operation would clearly
    simplify the drivers a lot but would require a new get-set interface
    in DSA. The usage of such bitmap from the stack also raised concerned
    in the past, leading to the dynamic allocation of a new ds->_bitmap
    member in the dsa_switch structure. So let's get rid of them for now.
    
    This commit nicely wraps the ds->ops->port_{mdb,vlan}_{prepare,add}
    switch operations into new dsa_switch_{mdb,vlan}_{prepare,add}
    variants not using any bitmap argument anymore.
    
    New dsa_switch_{mdb,vlan}_match helpers have been introduced to make
    clear which local port of a switch must be programmed with the target
    object. While the targeted user port is an obvious candidate, the
    DSA links must also be programmed, as well as the CPU port for VLANs.
    
    While at it, also remove local variables that are only used once.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 8c4eccb0cfe6..f8445fa73448 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -834,20 +834,6 @@ struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
 	if (!ds)
 		return NULL;
 
-	/* We avoid allocating memory outside dsa_switch
-	 * if it is not needed.
-	 */
-	if (n <= sizeof(ds->_bitmap) * 8) {
-		ds->bitmap = &ds->_bitmap;
-	} else {
-		ds->bitmap = devm_kcalloc(dev,
-					  BITS_TO_LONGS(n),
-					  sizeof(unsigned long),
-					  GFP_KERNEL);
-		if (unlikely(!ds->bitmap))
-			return NULL;
-	}
-
 	ds->dev = dev;
 	ds->num_ports = n;
 

commit 0394a63acfe2a6e1c08af0eb1a9133ee8650d7bd
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Aug 19 16:00:50 2019 -0400

    net: dsa: enable and disable all ports
    
    Call the .port_enable and .port_disable functions for all ports,
    not only the user ports, so that drivers may optimize the power
    consumption of all ports after a successful setup.
    
    Unused ports are now disabled on setup. CPU and DSA ports are now
    enabled on setup and disabled on teardown. User ports were already
    enabled at slave creation and disabled at slave destruction.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 405552ac4c08..8c4eccb0cfe6 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -264,6 +264,7 @@ static int dsa_port_setup(struct dsa_port *dp)
 
 	switch (dp->type) {
 	case DSA_PORT_TYPE_UNUSED:
+		dsa_port_disable(dp);
 		break;
 	case DSA_PORT_TYPE_CPU:
 		memset(dlp, 0, sizeof(*dlp));
@@ -274,6 +275,10 @@ static int dsa_port_setup(struct dsa_port *dp)
 			return err;
 
 		err = dsa_port_link_register_of(dp);
+		if (err)
+			return err;
+
+		err = dsa_port_enable(dp, NULL);
 		if (err)
 			return err;
 		break;
@@ -286,6 +291,10 @@ static int dsa_port_setup(struct dsa_port *dp)
 			return err;
 
 		err = dsa_port_link_register_of(dp);
+		if (err)
+			return err;
+
+		err = dsa_port_enable(dp, NULL);
 		if (err)
 			return err;
 		break;
@@ -317,11 +326,13 @@ static void dsa_port_teardown(struct dsa_port *dp)
 	case DSA_PORT_TYPE_UNUSED:
 		break;
 	case DSA_PORT_TYPE_CPU:
+		dsa_port_disable(dp);
 		dsa_tag_driver_put(dp->tag_ops);
 		devlink_port_unregister(dlp);
 		dsa_port_link_unregister_of(dp);
 		break;
 	case DSA_PORT_TYPE_DSA:
+		dsa_port_disable(dp);
 		devlink_port_unregister(dlp);
 		dsa_port_link_unregister_of(dp);
 		break;

commit 955222ca5281ee7ded6b899605c055b147a15c73
Author: Vivien Didelot <vivien.didelot@gmail.com>
Date:   Mon Aug 19 16:00:48 2019 -0400

    net: dsa: use a single switch statement for port setup
    
    It is currently difficult to read the different steps involved in the
    setup and teardown of ports in the DSA code. Keep it simple with a
    single switch statement for each port type: UNUSED, CPU, DSA, or USER.
    
    Also no need to call devlink_port_unregister from within dsa_port_setup
    as this step is inconditionally handled by dsa_port_teardown on error.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 3abd173ebacb..405552ac4c08 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -254,88 +254,79 @@ static void dsa_tree_teardown_default_cpu(struct dsa_switch_tree *dst)
 
 static int dsa_port_setup(struct dsa_port *dp)
 {
-	enum devlink_port_flavour flavour;
 	struct dsa_switch *ds = dp->ds;
 	struct dsa_switch_tree *dst = ds->dst;
-	int err = 0;
-
-	if (dp->type == DSA_PORT_TYPE_UNUSED)
-		return 0;
-
-	memset(&dp->devlink_port, 0, sizeof(dp->devlink_port));
-	dp->mac = of_get_mac_address(dp->dn);
-
-	switch (dp->type) {
-	case DSA_PORT_TYPE_CPU:
-		flavour = DEVLINK_PORT_FLAVOUR_CPU;
-		break;
-	case DSA_PORT_TYPE_DSA:
-		flavour = DEVLINK_PORT_FLAVOUR_DSA;
-		break;
-	case DSA_PORT_TYPE_USER: /* fall-through */
-	default:
-		flavour = DEVLINK_PORT_FLAVOUR_PHYSICAL;
-		break;
-	}
-
-	/* dp->index is used now as port_number. However
-	 * CPU and DSA ports should have separate numbering
-	 * independent from front panel port numbers.
-	 */
-	devlink_port_attrs_set(&dp->devlink_port, flavour,
-			       dp->index, false, 0,
-			       (const char *) &dst->index, sizeof(dst->index));
-	err = devlink_port_register(ds->devlink, &dp->devlink_port,
-				    dp->index);
-	if (err)
-		return err;
+	const unsigned char *id = (const unsigned char *)&dst->index;
+	const unsigned char len = sizeof(dst->index);
+	struct devlink_port *dlp = &dp->devlink_port;
+	struct devlink *dl = ds->devlink;
+	int err;
 
 	switch (dp->type) {
 	case DSA_PORT_TYPE_UNUSED:
 		break;
 	case DSA_PORT_TYPE_CPU:
+		memset(dlp, 0, sizeof(*dlp));
+		devlink_port_attrs_set(dlp, DEVLINK_PORT_FLAVOUR_CPU,
+				       dp->index, false, 0, id, len);
+		err = devlink_port_register(dl, dlp, dp->index);
+		if (err)
+			return err;
+
 		err = dsa_port_link_register_of(dp);
 		if (err)
-			dev_err(ds->dev, "failed to setup link for port %d.%d\n",
-				ds->index, dp->index);
+			return err;
 		break;
 	case DSA_PORT_TYPE_DSA:
+		memset(dlp, 0, sizeof(*dlp));
+		devlink_port_attrs_set(dlp, DEVLINK_PORT_FLAVOUR_DSA,
+				       dp->index, false, 0, id, len);
+		err = devlink_port_register(dl, dlp, dp->index);
+		if (err)
+			return err;
+
 		err = dsa_port_link_register_of(dp);
 		if (err)
-			dev_err(ds->dev, "failed to setup link for port %d.%d\n",
-				ds->index, dp->index);
+			return err;
 		break;
 	case DSA_PORT_TYPE_USER:
+		memset(dlp, 0, sizeof(*dlp));
+		devlink_port_attrs_set(dlp, DEVLINK_PORT_FLAVOUR_PHYSICAL,
+				       dp->index, false, 0, id, len);
+		err = devlink_port_register(dl, dlp, dp->index);
+		if (err)
+			return err;
+
+		dp->mac = of_get_mac_address(dp->dn);
 		err = dsa_slave_create(dp);
 		if (err)
-			dev_err(ds->dev, "failed to create slave for port %d.%d\n",
-				ds->index, dp->index);
-		else
-			devlink_port_type_eth_set(&dp->devlink_port, dp->slave);
+			return err;
+
+		devlink_port_type_eth_set(dlp, dp->slave);
 		break;
 	}
 
-	if (err)
-		devlink_port_unregister(&dp->devlink_port);
-
-	return err;
+	return 0;
 }
 
 static void dsa_port_teardown(struct dsa_port *dp)
 {
-	if (dp->type != DSA_PORT_TYPE_UNUSED)
-		devlink_port_unregister(&dp->devlink_port);
+	struct devlink_port *dlp = &dp->devlink_port;
 
 	switch (dp->type) {
 	case DSA_PORT_TYPE_UNUSED:
 		break;
 	case DSA_PORT_TYPE_CPU:
 		dsa_tag_driver_put(dp->tag_ops);
-		/* fall-through */
+		devlink_port_unregister(dlp);
+		dsa_port_link_unregister_of(dp);
+		break;
 	case DSA_PORT_TYPE_DSA:
+		devlink_port_unregister(dlp);
 		dsa_port_link_unregister_of(dp);
 		break;
 	case DSA_PORT_TYPE_USER:
+		devlink_port_unregister(dlp);
 		if (dp->slave) {
 			dsa_slave_destroy(dp->slave);
 			dp->slave = NULL;

commit 5e3f847a02aabfecea519d7b2fd48f4d6f551be6
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sat Jun 8 15:04:28 2019 +0300

    net: dsa: Add teardown callback for drivers
    
    This is helpful for e.g. draining per-driver (not per-port) tagger
    queues.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 38d11c863b57..3abd173ebacb 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -408,6 +408,9 @@ static void dsa_switch_teardown(struct dsa_switch *ds)
 
 	dsa_switch_unregister_notifier(ds);
 
+	if (ds->ops->teardown)
+		ds->ops->teardown(ds);
+
 	if (ds->devlink) {
 		devlink_unregister(ds->devlink);
 		devlink_free(ds->devlink);

commit a6cdeeb16bff89c8486324f53577db058cbe81ba
Merge: 96524ea4be04 1e1d92636954
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Jun 7 11:00:14 2019 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Some ISDN files that got removed in net-next had some changes
    done in mainline, take the removals.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit e70c7aad7a95f4f9fd3f00caef1a1ceb57a4b5a4
Author: Ioana Ciornei <ioana.ciornei@nxp.com>
Date:   Thu May 30 09:09:07 2019 +0300

    net: dsa: Add error path handling in dsa_tree_setup()
    
    In case a call to dsa_tree_setup() fails, an attempt to cleanup is made
    by calling dsa_tree_remove_switch(), which should take care of
    removing/unregistering any resources previously allocated. This does not
    happen because it is conditioned by dst->setup being true, which is set
    only after _all_ setup steps were performed successfully.
    
    This is especially interesting when the internal MDIO bus is registered
    but afterwards, a port setup fails and the mdiobus_unregister() is never
    called. This leads to a BUG_ON() complaining about the fact that it's
    trying to free an MDIO bus that's still registered.
    
    Add proper error handling in all functions branching from
    dsa_tree_setup().
    
    Signed-off-by: Ioana Ciornei <ioana.ciornei@nxp.com>
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 3b5f434cad3f..b70befe8a3c8 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -261,7 +261,7 @@ static int dsa_port_setup(struct dsa_port *dp)
 	enum devlink_port_flavour flavour;
 	struct dsa_switch *ds = dp->ds;
 	struct dsa_switch_tree *dst = ds->dst;
-	int err;
+	int err = 0;
 
 	if (dp->type == DSA_PORT_TYPE_UNUSED)
 		return 0;
@@ -299,19 +299,15 @@ static int dsa_port_setup(struct dsa_port *dp)
 		break;
 	case DSA_PORT_TYPE_CPU:
 		err = dsa_port_link_register_of(dp);
-		if (err) {
+		if (err)
 			dev_err(ds->dev, "failed to setup link for port %d.%d\n",
 				ds->index, dp->index);
-			return err;
-		}
 		break;
 	case DSA_PORT_TYPE_DSA:
 		err = dsa_port_link_register_of(dp);
-		if (err) {
+		if (err)
 			dev_err(ds->dev, "failed to setup link for port %d.%d\n",
 				ds->index, dp->index);
-			return err;
-		}
 		break;
 	case DSA_PORT_TYPE_USER:
 		err = dsa_slave_create(dp);
@@ -323,7 +319,10 @@ static int dsa_port_setup(struct dsa_port *dp)
 		break;
 	}
 
-	return 0;
+	if (err)
+		devlink_port_unregister(&dp->devlink_port);
+
+	return err;
 }
 
 static void dsa_port_teardown(struct dsa_port *dp)
@@ -351,7 +350,7 @@ static void dsa_port_teardown(struct dsa_port *dp)
 
 static int dsa_switch_setup(struct dsa_switch *ds)
 {
-	int err;
+	int err = 0;
 
 	/* Initialize ds->phys_mii_mask before registering the slave MDIO bus
 	 * driver and before ops->setup() has run, since the switch drivers and
@@ -369,29 +368,41 @@ static int dsa_switch_setup(struct dsa_switch *ds)
 
 	err = devlink_register(ds->devlink, ds->dev);
 	if (err)
-		return err;
+		goto free_devlink;
 
 	err = dsa_switch_register_notifier(ds);
 	if (err)
-		return err;
+		goto unregister_devlink;
 
 	err = ds->ops->setup(ds);
 	if (err < 0)
-		return err;
+		goto unregister_notifier;
 
 	if (!ds->slave_mii_bus && ds->ops->phy_read) {
 		ds->slave_mii_bus = devm_mdiobus_alloc(ds->dev);
-		if (!ds->slave_mii_bus)
-			return -ENOMEM;
+		if (!ds->slave_mii_bus) {
+			err = -ENOMEM;
+			goto unregister_notifier;
+		}
 
 		dsa_slave_mii_bus_init(ds);
 
 		err = mdiobus_register(ds->slave_mii_bus);
 		if (err < 0)
-			return err;
+			goto unregister_notifier;
 	}
 
 	return 0;
+
+unregister_notifier:
+	dsa_switch_unregister_notifier(ds);
+unregister_devlink:
+	devlink_unregister(ds->devlink);
+free_devlink:
+	devlink_free(ds->devlink);
+	ds->devlink = NULL;
+
+	return err;
 }
 
 static void dsa_switch_teardown(struct dsa_switch *ds)
@@ -413,8 +424,8 @@ static int dsa_tree_setup_switches(struct dsa_switch_tree *dst)
 {
 	struct dsa_switch *ds;
 	struct dsa_port *dp;
-	int device, port;
-	int err;
+	int device, port, i;
+	int err = 0;
 
 	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
 		ds = dst->ds[device];
@@ -423,18 +434,41 @@ static int dsa_tree_setup_switches(struct dsa_switch_tree *dst)
 
 		err = dsa_switch_setup(ds);
 		if (err)
-			return err;
+			goto switch_teardown;
 
 		for (port = 0; port < ds->num_ports; port++) {
 			dp = &ds->ports[port];
 
 			err = dsa_port_setup(dp);
 			if (err)
-				return err;
+				goto ports_teardown;
 		}
 	}
 
 	return 0;
+
+ports_teardown:
+	for (i = 0; i < port; i++)
+		dsa_port_teardown(&ds->ports[i]);
+
+	dsa_switch_teardown(ds);
+
+switch_teardown:
+	for (i = 0; i < device; i++) {
+		ds = dst->ds[i];
+		if (!ds)
+			continue;
+
+		for (port = 0; port < ds->num_ports; port++) {
+			dp = &ds->ports[port];
+
+			dsa_port_teardown(dp);
+		}
+
+		dsa_switch_teardown(ds);
+	}
+
+	return err;
 }
 
 static void dsa_tree_teardown_switches(struct dsa_switch_tree *dst)
@@ -496,17 +530,24 @@ static int dsa_tree_setup(struct dsa_switch_tree *dst)
 
 	err = dsa_tree_setup_switches(dst);
 	if (err)
-		return err;
+		goto teardown_default_cpu;
 
 	err = dsa_tree_setup_master(dst);
 	if (err)
-		return err;
+		goto teardown_switches;
 
 	dst->setup = true;
 
 	pr_info("DSA: tree %d setup\n", dst->index);
 
 	return 0;
+
+teardown_switches:
+	dsa_tree_teardown_switches(dst);
+teardown_default_cpu:
+	dsa_tree_teardown_default_cpu(dst);
+
+	return err;
 }
 
 static void dsa_tree_teardown(struct dsa_switch_tree *dst)
@@ -547,8 +588,10 @@ static int dsa_tree_add_switch(struct dsa_switch_tree *dst,
 	dst->ds[index] = ds;
 
 	err = dsa_tree_setup(dst);
-	if (err)
-		dsa_tree_remove_switch(dst, index);
+	if (err) {
+		dst->ds[index] = NULL;
+		dsa_tree_put(dst);
+	}
 
 	return err;
 }

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 3b5f434cad3f..820dd8da57fc 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -1,13 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * net/dsa/dsa2.c - Hardware switch handling, binding version 2
  * Copyright (c) 2008-2009 Marvell Semiconductor
  * Copyright (c) 2013 Florian Fainelli <florian@openwrt.org>
  * Copyright (c) 2016 Andrew Lunn <andrew@lunn.ch>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
  */
 
 #include <linux/device.h>

commit cc1939e4b3aaf534fb2f3706820012036825731c
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sun May 5 13:19:23 2019 +0300

    net: dsa: Allow drivers to filter packets they can decode source port from
    
    Frames get processed by DSA and redirected to switch port net devices
    based on the ETH_P_XDSA multiplexed packet_type handler found by the
    network stack when calling eth_type_trans().
    
    The running assumption is that once the DSA .rcv function is called, DSA
    is always able to decode the switch tag in order to change the skb->dev
    from its master.
    
    However there are tagging protocols (such as the new DSA_TAG_PROTO_SJA1105,
    user of DSA_TAG_PROTO_8021Q) where this assumption is not completely
    true, since switch tagging piggybacks on the absence of a vlan_filtering
    bridge. Moreover, management traffic (BPDU, PTP) for this switch doesn't
    rely on switch tagging, but on a different mechanism. So it would make
    sense to at least be able to terminate that.
    
    Having DSA receive traffic it can't decode would put it in an impossible
    situation: the eth_type_trans() function would invoke the DSA .rcv(),
    which could not change skb->dev, then eth_type_trans() would be invoked
    again, which again would call the DSA .rcv, and the packet would never
    be able to exit the DSA filter and would spiral in a loop until the
    whole system dies.
    
    This happens because eth_type_trans() doesn't actually look at the skb
    (so as to identify a potential tag) when it deems it as being
    ETH_P_XDSA. It just checks whether skb->dev has a DSA private pointer
    installed (therefore it's a DSA master) and that there exists a .rcv
    callback (everybody except DSA_TAG_PROTO_NONE has that). This is
    understandable as there are many switch tags out there, and exhaustively
    checking for all of them is far from ideal.
    
    The solution lies in introducing a filtering function for each tagging
    protocol. In the absence of a filtering function, all traffic is passed
    to the .rcv DSA callback. The tagging protocol should see the filtering
    function as a pre-validation that it can decode the incoming skb. The
    traffic that doesn't match the filter will bypass the DSA .rcv callback
    and be left on the master netdevice, which wasn't previously possible.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index f1ad80851616..3b5f434cad3f 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -586,6 +586,7 @@ static int dsa_port_parse_cpu(struct dsa_port *dp, struct net_device *master)
 	}
 
 	dp->type = DSA_PORT_TYPE_CPU;
+	dp->filter = tag_ops->filter;
 	dp->rcv = tag_ops->rcv;
 	dp->tag_ops = tag_ops;
 	dp->master = master;

commit b2243b369c7862e29cc9163184fef00d0fb0842a
Author: Vladimir Oltean <olteanv@gmail.com>
Date:   Sun May 5 13:19:20 2019 +0300

    net: dsa: Call driver's setup callback after setting up its switchdev notifier
    
    This allows the driver to perform some manipulations of its own during
    setup, using generic switchdev calls. Having the notifiers registered at
    setup time is important because otherwise any switchdev transaction
    emitted during this time would be ignored (dispatched to an empty call
    chain).
    
    One current usage scenario is for the driver to request DSA to set up
    802.1Q based switch tagging for its ports.
    
    There is no danger for the driver setup code to start racing now with
    switchdev events emitted from the network stack (such as bridge core)
    even if the notifier is registered earlier. This is because the network
    stack needs a net_device as a vehicle to perform switchdev operations,
    and the slave net_devices are registered later than the core driver
    setup anyway (ds->ops->setup in dsa_switch_setup vs dsa_port_setup).
    
    Luckily DSA doesn't need a net_device to carry out switchdev callbacks,
    and therefore drivers shouldn't assume either that net_devices are
    available at the time their switchdev callbacks get invoked.
    
    Signed-off-by: Vladimir Oltean <olteanv@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Vivien Didelot <vivien.didelot@gmail.com>-
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index bbc9f56e89b9..f1ad80851616 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -371,14 +371,14 @@ static int dsa_switch_setup(struct dsa_switch *ds)
 	if (err)
 		return err;
 
-	err = ds->ops->setup(ds);
-	if (err < 0)
-		return err;
-
 	err = dsa_switch_register_notifier(ds);
 	if (err)
 		return err;
 
+	err = ds->ops->setup(ds);
+	if (err < 0)
+		return err;
+
 	if (!ds->slave_mii_bus && ds->ops->phy_read) {
 		ds->slave_mii_bus = devm_mdiobus_alloc(ds->dev);
 		if (!ds->slave_mii_bus)

commit 4dad81ee14479c74973ee669612a367b3a675743
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:19 2019 +0200

    dsa: Add stub tag driver put method
    
    When a DSA switch driver is unloaded, the lock on the tag driver
    should be released so the module can be unloaded. Add the needed calls,
    but leave the actual release code as a stub.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    
    v2
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index ba91bda8bdd3..bbc9f56e89b9 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -335,6 +335,8 @@ static void dsa_port_teardown(struct dsa_port *dp)
 	case DSA_PORT_TYPE_UNUSED:
 		break;
 	case DSA_PORT_TYPE_CPU:
+		dsa_tag_driver_put(dp->tag_ops);
+		/* fall-through */
 	case DSA_PORT_TYPE_DSA:
 		dsa_port_link_unregister_of(dp);
 		break;

commit c39e2a1d71ade2e59c92280fb2b4daf06b0e240f
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sun Apr 28 19:37:18 2019 +0200

    dsa: Rename dsa_resolve_tag_protocol() to _get ready for locking
    
    dsa_resolve_tag_protocol() is used to find the tagging driver needed
    by a switch driver. When the tagging drivers become modules, it will
    be necassary to take a reference on the module to prevent it being
    unloaded. So rename this function to _get() to indicate it has some
    locking properties.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index d122f1bcdab2..ba91bda8bdd3 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -577,7 +577,7 @@ static int dsa_port_parse_cpu(struct dsa_port *dp, struct net_device *master)
 	enum dsa_tag_protocol tag_protocol;
 
 	tag_protocol = ds->ops->get_tag_protocol(ds, dp->index);
-	tag_ops = dsa_resolve_tag_protocol(tag_protocol);
+	tag_ops = dsa_tag_driver_get(tag_protocol);
 	if (IS_ERR(tag_ops)) {
 		dev_warn(ds->dev, "No tagger for this switch\n");
 		return PTR_ERR(tag_ops);

commit 15b04aceeb83086ea3109c331cb7d8c2767fa0c6
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Wed Apr 3 14:24:26 2019 +0200

    dsa: pass switch ID through devlink_port_attrs_set()
    
    Pass the switch ID down the to devlink through devlink_port_attrs_set()
    so it can be used by devlink_compat_switch_id_get(). Leave
    ndo_get_port_parent_id implementation only for legacy.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 4493b2ff3438..d122f1bcdab2 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -260,6 +260,7 @@ static int dsa_port_setup(struct dsa_port *dp)
 {
 	enum devlink_port_flavour flavour;
 	struct dsa_switch *ds = dp->ds;
+	struct dsa_switch_tree *dst = ds->dst;
 	int err;
 
 	if (dp->type == DSA_PORT_TYPE_UNUSED)
@@ -286,7 +287,8 @@ static int dsa_port_setup(struct dsa_port *dp)
 	 * independent from front panel port numbers.
 	 */
 	devlink_port_attrs_set(&dp->devlink_port, flavour,
-			       dp->index, false, 0, NULL, 0);
+			       dp->index, false, 0,
+			       (const char *) &dst->index, sizeof(dst->index));
 	err = devlink_port_register(ds->devlink, &dp->devlink_port,
 				    dp->index);
 	if (err)

commit bec5267cded268acdf679b651778c300d204e9f2
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Wed Apr 3 14:24:16 2019 +0200

    net: devlink: extend port attrs for switch ID
    
    Extend devlink_port_attrs_set() to pass switch ID for ports which are
    part of switch and store it in port attrs. For other ports, this is
    NULL.
    
    Note that this allows the driver to group devlink ports into one or more
    switches according to the actual topology.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 0e1cce460406..4493b2ff3438 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -286,7 +286,7 @@ static int dsa_port_setup(struct dsa_port *dp)
 	 * independent from front panel port numbers.
 	 */
 	devlink_port_attrs_set(&dp->devlink_port, flavour,
-			       dp->index, false, 0);
+			       dp->index, false, 0, NULL, 0);
 	err = devlink_port_register(ds->devlink, &dp->devlink_port,
 				    dp->index);
 	if (err)

commit a2c7023f7075ca9b80f944d3f20f60e6574538e2
Author: Xiaofei Shen <xiaofeis@codeaurora.org>
Date:   Fri Mar 29 11:04:58 2019 +0530

    net: dsa: read mac address from DT for slave device
    
    Before creating a slave netdevice, get the mac address from DTS and
    apply in case it is valid.
    
    Signed-off-by: Xiaofei Shen <xiaofeis@codeaurora.org>
    Signed-off-by: Vinod Koul <vkoul@kernel.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index fe0a6197db9c..0e1cce460406 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -266,6 +266,7 @@ static int dsa_port_setup(struct dsa_port *dp)
 		return 0;
 
 	memset(&dp->devlink_port, 0, sizeof(dp->devlink_port));
+	dp->mac = of_get_mac_address(dp->dn);
 
 	switch (dp->type) {
 	case DSA_PORT_TYPE_CPU:

commit d8ba36204cc74c727f6653abc47310d513634e2e
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Sun Mar 24 11:14:32 2019 +0100

    dsa: move devlink_port_attrs_set() call before register
    
    Since attrs are static during the existence of devlink port, set the
    before registration of the port.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 4558de672b4f..fe0a6197db9c 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -258,14 +258,36 @@ static void dsa_tree_teardown_default_cpu(struct dsa_switch_tree *dst)
 
 static int dsa_port_setup(struct dsa_port *dp)
 {
+	enum devlink_port_flavour flavour;
 	struct dsa_switch *ds = dp->ds;
-	int err = 0;
+	int err;
+
+	if (dp->type == DSA_PORT_TYPE_UNUSED)
+		return 0;
 
 	memset(&dp->devlink_port, 0, sizeof(dp->devlink_port));
 
-	if (dp->type != DSA_PORT_TYPE_UNUSED)
-		err = devlink_port_register(ds->devlink, &dp->devlink_port,
-					    dp->index);
+	switch (dp->type) {
+	case DSA_PORT_TYPE_CPU:
+		flavour = DEVLINK_PORT_FLAVOUR_CPU;
+		break;
+	case DSA_PORT_TYPE_DSA:
+		flavour = DEVLINK_PORT_FLAVOUR_DSA;
+		break;
+	case DSA_PORT_TYPE_USER: /* fall-through */
+	default:
+		flavour = DEVLINK_PORT_FLAVOUR_PHYSICAL;
+		break;
+	}
+
+	/* dp->index is used now as port_number. However
+	 * CPU and DSA ports should have separate numbering
+	 * independent from front panel port numbers.
+	 */
+	devlink_port_attrs_set(&dp->devlink_port, flavour,
+			       dp->index, false, 0);
+	err = devlink_port_register(ds->devlink, &dp->devlink_port,
+				    dp->index);
 	if (err)
 		return err;
 
@@ -273,13 +295,6 @@ static int dsa_port_setup(struct dsa_port *dp)
 	case DSA_PORT_TYPE_UNUSED:
 		break;
 	case DSA_PORT_TYPE_CPU:
-		/* dp->index is used now as port_number. However
-		 * CPU ports should have separate numbering
-		 * independent from front panel port numbers.
-		 */
-		devlink_port_attrs_set(&dp->devlink_port,
-				       DEVLINK_PORT_FLAVOUR_CPU,
-				       dp->index, false, 0);
 		err = dsa_port_link_register_of(dp);
 		if (err) {
 			dev_err(ds->dev, "failed to setup link for port %d.%d\n",
@@ -288,13 +303,6 @@ static int dsa_port_setup(struct dsa_port *dp)
 		}
 		break;
 	case DSA_PORT_TYPE_DSA:
-		/* dp->index is used now as port_number. However
-		 * DSA ports should have separate numbering
-		 * independent from front panel port numbers.
-		 */
-		devlink_port_attrs_set(&dp->devlink_port,
-				       DEVLINK_PORT_FLAVOUR_DSA,
-				       dp->index, false, 0);
 		err = dsa_port_link_register_of(dp);
 		if (err) {
 			dev_err(ds->dev, "failed to setup link for port %d.%d\n",
@@ -303,9 +311,6 @@ static int dsa_port_setup(struct dsa_port *dp)
 		}
 		break;
 	case DSA_PORT_TYPE_USER:
-		devlink_port_attrs_set(&dp->devlink_port,
-				       DEVLINK_PORT_FLAVOUR_PHYSICAL,
-				       dp->index, false, 0);
 		err = dsa_slave_create(dp);
 		if (err)
 			dev_err(ds->dev, "failed to create slave for port %d.%d\n",

commit 402f99e550c6f7df835dde707920038591384d20
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Sun Mar 24 11:14:26 2019 +0100

    dsa: add missing net/devlink.h include
    
    devlink functions are in use, so include the related header file.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index c00ee464afc7..4558de672b4f 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -18,6 +18,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/of.h>
 #include <linux/of_net.h>
+#include <net/devlink.h>
 
 #include "dsa_priv.h"
 

commit 9eb359140cd307f8a14f61c19b155ffca5291057
Merge: cf29576fee60 07f12b26e21a
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Mar 2 12:54:35 2019 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net

commit 9919a363a5cb57c2b64c4803b4d2dd45e90bf230
Author: Wen Yang <wen.yang99@zte.com.cn>
Date:   Mon Feb 25 15:22:19 2019 +0800

    net: dsa: fix a leaked reference by adding missing of_node_put
    
    The call to of_parse_phandle returns a node pointer with refcount
    incremented thus it must be explicitly decremented after the last
    usage.
    
    Detected by coccinelle with the following warnings:
    ./net/dsa/port.c:294:1-7: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 284, but without a corresponding object release within this function.
    ./net/dsa/dsa2.c:627:3-9: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 618, but without a corresponding object release within this function.
    ./net/dsa/dsa2.c:630:3-9: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 618, but without a corresponding object release within this function.
    ./net/dsa/dsa2.c:636:3-9: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 618, but without a corresponding object release within this function.
    ./net/dsa/dsa2.c:639:1-7: ERROR: missing of_node_put; acquired a node pointer with refcount incremented on line 618, but without a corresponding object release within this function.
    
    Signed-off-by: Wen Yang <wen.yang99@zte.com.cn>
    Reviewed-by: Vivien Didelot <vivien.didelot@gmail.com>
    Cc: Andrew Lunn <andrew@lunn.ch>
    Cc: Vivien Didelot <vivien.didelot@gmail.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Vivien Didelot <vivien.didelot@gmail.com>
    Cc: netdev@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index a1917025e155..410f19148106 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -612,8 +612,8 @@ static int dsa_switch_parse_ports_of(struct dsa_switch *ds,
 {
 	struct device_node *ports, *port;
 	struct dsa_port *dp;
+	int err = 0;
 	u32 reg;
-	int err;
 
 	ports = of_get_child_by_name(dn, "ports");
 	if (!ports) {
@@ -624,19 +624,23 @@ static int dsa_switch_parse_ports_of(struct dsa_switch *ds,
 	for_each_available_child_of_node(ports, port) {
 		err = of_property_read_u32(port, "reg", &reg);
 		if (err)
-			return err;
+			goto out_put_node;
 
-		if (reg >= ds->num_ports)
-			return -EINVAL;
+		if (reg >= ds->num_ports) {
+			err = -EINVAL;
+			goto out_put_node;
+		}
 
 		dp = &ds->ports[reg];
 
 		err = dsa_port_parse_of(dp, port);
 		if (err)
-			return err;
+			goto out_put_node;
 	}
 
-	return 0;
+out_put_node:
+	of_node_put(ports);
+	return err;
 }
 
 static int dsa_switch_parse_member_of(struct dsa_switch *ds,

commit 33b363e004fdb6abf12a5b0c51dc2c221d352cac
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Feb 7 19:16:03 2019 -0600

    net: dsa: use struct_size() in devm_kzalloc()
    
    One of the more common cases of allocation size calculations is finding
    the size of a structure that has a zero-sized array at the end, along
    with memory for some number of elements for that array. For example:
    
    struct foo {
        int stuff;
        struct boo entry[];
    };
    
    size = sizeof(struct foo) + count * sizeof(struct boo);
    instance = alloc(size, GFP_KERNEL)
    
    Instead of leaving these open-coded and prone to type mistakes, we can
    now use the new struct_size() helper:
    
    instance = alloc(struct_size(instance, entry, count), GFP_KERNEL)
    
    Notice that, in this case, variable size is not necessary, hence it is
    removed.
    
    This code was detected with the help of Coccinelle.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index a1917025e155..8c431e0f3627 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -767,11 +767,10 @@ static int dsa_switch_probe(struct dsa_switch *ds)
 
 struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
 {
-	size_t size = sizeof(struct dsa_switch) + n * sizeof(struct dsa_port);
 	struct dsa_switch *ds;
 	int i;
 
-	ds = devm_kzalloc(dev, size, GFP_KERNEL);
+	ds = devm_kzalloc(dev, struct_size(ds, ports, n), GFP_KERNEL);
 	if (!ds)
 		return NULL;
 

commit 0015b80abccecca82622d9e9d48eb210572a0c3b
Author: Salvatore Mesoraca <s.mesoraca16@gmail.com>
Date:   Mon Jul 16 21:10:34 2018 -0700

    net: dsa: Remove VLA usage
    
    We avoid 2 VLAs by using a pre-allocated field in dsa_switch. We also
    try to avoid dynamic allocation whenever possible (when using fewer than
    bits-per-long ports, which is the common case).
    
    Link: http://lkml.kernel.org/r/CA+55aFzCG-zNmZwX4A2FQpadafLfEzK6CC=qPXydAacU1RqZWA@mail.gmail.com
    Link: http://lkml.kernel.org/r/20180505185145.GB32630@lunn.ch
    Signed-off-by: Salvatore Mesoraca <s.mesoraca16@gmail.com>
    [kees: tweak commit subject and message slightly]
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index dc5d9af3dc80..a1917025e155 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -775,6 +775,20 @@ struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
 	if (!ds)
 		return NULL;
 
+	/* We avoid allocating memory outside dsa_switch
+	 * if it is not needed.
+	 */
+	if (n <= sizeof(ds->_bitmap) * 8) {
+		ds->bitmap = &ds->_bitmap;
+	} else {
+		ds->bitmap = devm_kcalloc(dev,
+					  BITS_TO_LONGS(n),
+					  sizeof(unsigned long),
+					  GFP_KERNEL);
+		if (unlikely(!ds->bitmap))
+			return NULL;
+	}
+
 	ds->dev = dev;
 	ds->num_ports = n;
 

commit 6f6e434aa267a6030477876d89444fe3a6b7a48d
Merge: 44c752fe584d 6741c4bb389d
Author: David S. Miller <davem@davemloft.net>
Date:   Mon May 21 16:01:54 2018 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    S390 bpf_jit.S is removed in net-next and had changes in 'net',
    since that code isn't used any more take the removal.
    
    TLS data structures split the TX and RX components in 'net-next',
    put the new struct members from the bug fix in 'net' into the RX
    part.
    
    The 'net-next' tree had some reworking of how the ERSPAN code works in
    the GRE tunneling code, overlapping with a one-line headroom
    calculation fix in 'net'.
    
    Overlapping changes in __sock_map_ctx_update_elem(), keep the bits
    that read the prog members via READ_ONCE() into local variables
    before using them.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit da077392486b2f87c384bc12b27a16b29620c5e4
Author: Jiri Pirko <jiri@mellanox.com>
Date:   Fri May 18 09:29:03 2018 +0200

    dsa: set devlink port attrs for dsa ports
    
    Set the attrs and allow to expose port flavour to user via devlink.
    
    Signed-off-by: Jiri Pirko <jiri@mellanox.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index adf50fbc4c13..00126cda4319 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -270,7 +270,28 @@ static int dsa_port_setup(struct dsa_port *dp)
 	case DSA_PORT_TYPE_UNUSED:
 		break;
 	case DSA_PORT_TYPE_CPU:
+		/* dp->index is used now as port_number. However
+		 * CPU ports should have separate numbering
+		 * independent from front panel port numbers.
+		 */
+		devlink_port_attrs_set(&dp->devlink_port,
+				       DEVLINK_PORT_FLAVOUR_CPU,
+				       dp->index, false, 0);
+		err = dsa_port_link_register_of(dp);
+		if (err) {
+			dev_err(ds->dev, "failed to setup link for port %d.%d\n",
+				ds->index, dp->index);
+			return err;
+		}
+		break;
 	case DSA_PORT_TYPE_DSA:
+		/* dp->index is used now as port_number. However
+		 * DSA ports should have separate numbering
+		 * independent from front panel port numbers.
+		 */
+		devlink_port_attrs_set(&dp->devlink_port,
+				       DEVLINK_PORT_FLAVOUR_DSA,
+				       dp->index, false, 0);
 		err = dsa_port_link_register_of(dp);
 		if (err) {
 			dev_err(ds->dev, "failed to setup link for port %d.%d\n",
@@ -279,6 +300,9 @@ static int dsa_port_setup(struct dsa_port *dp)
 		}
 		break;
 	case DSA_PORT_TYPE_USER:
+		devlink_port_attrs_set(&dp->devlink_port,
+				       DEVLINK_PORT_FLAVOUR_PHYSICAL,
+				       dp->index, false, 0);
 		err = dsa_slave_create(dp);
 		if (err)
 			dev_err(ds->dev, "failed to create slave for port %d.%d\n",

commit 5447d78623da2eded06d4cd9469d1a71eba43bc4
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu May 17 16:55:39 2018 -0700

    net: dsa: Do not register devlink for unused ports
    
    Even if commit 1d27732f411d ("net: dsa: setup and teardown ports") indicated
    that registering a devlink instance for unused ports is not a problem, and this
    is true, this can be confusing nonetheless, so let's not do it.
    
    Fixes: 1d27732f411d ("net: dsa: setup and teardown ports")
    Reported-by: Jiri Pirko <jiri@resnulli.us>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index adf50fbc4c13..47725250b4ca 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -258,11 +258,13 @@ static void dsa_tree_teardown_default_cpu(struct dsa_switch_tree *dst)
 static int dsa_port_setup(struct dsa_port *dp)
 {
 	struct dsa_switch *ds = dp->ds;
-	int err;
+	int err = 0;
 
 	memset(&dp->devlink_port, 0, sizeof(dp->devlink_port));
 
-	err = devlink_port_register(ds->devlink, &dp->devlink_port, dp->index);
+	if (dp->type != DSA_PORT_TYPE_UNUSED)
+		err = devlink_port_register(ds->devlink, &dp->devlink_port,
+					    dp->index);
 	if (err)
 		return err;
 
@@ -293,7 +295,8 @@ static int dsa_port_setup(struct dsa_port *dp)
 
 static void dsa_port_teardown(struct dsa_port *dp)
 {
-	devlink_port_unregister(&dp->devlink_port);
+	if (dp->type != DSA_PORT_TYPE_UNUSED)
+		devlink_port_unregister(&dp->devlink_port);
 
 	switch (dp->type) {
 	case DSA_PORT_TYPE_UNUSED:

commit 33615367f378fed87aeba27cf86f83bb8d214eaf
Author: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
Date:   Tue Jan 23 16:03:46 2018 +0100

    net: dsa: Support internal phy on 'cpu' port
    
    This adds support for enabling the internal PHY for a 'cpu' port.
    It has been tested on GE B850v3,  B650v3 and B450v3, which have a
    built-in MV88E6240 switch hardwired to a PCIe based network card.
    On these machines the internal PHY of the i210 network card and
    the Marvell switch are connected to each other and must be enabled
    for properly using the switch. While the i210 PHY will be enabled
    when the network interface is enabled, the switch's port is not
    exposed as network interface. Additionally the mv88e6xxx driver
    resets the chip during probe, so the PHY is disabled without this
    patch.
    
    Signed-off-by: Sebastian Reichel <sebastian.reichel@collabora.co.uk>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 21f9bed11988..adf50fbc4c13 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -271,13 +271,12 @@ static int dsa_port_setup(struct dsa_port *dp)
 		break;
 	case DSA_PORT_TYPE_CPU:
 	case DSA_PORT_TYPE_DSA:
-		err = dsa_port_fixed_link_register_of(dp);
+		err = dsa_port_link_register_of(dp);
 		if (err) {
-			dev_err(ds->dev, "failed to register fixed link for port %d.%d\n",
+			dev_err(ds->dev, "failed to setup link for port %d.%d\n",
 				ds->index, dp->index);
 			return err;
 		}
-
 		break;
 	case DSA_PORT_TYPE_USER:
 		err = dsa_slave_create(dp);
@@ -301,7 +300,7 @@ static void dsa_port_teardown(struct dsa_port *dp)
 		break;
 	case DSA_PORT_TYPE_CPU:
 	case DSA_PORT_TYPE_DSA:
-		dsa_port_fixed_link_unregister_of(dp);
+		dsa_port_link_unregister_of(dp);
 		break;
 	case DSA_PORT_TYPE_USER:
 		if (dp->slave) {

commit 986d7ccf7e4ba2bc0c0929acfe54b6d41dec0805
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Tue Dec 5 15:34:12 2017 -0500

    net: dsa: assign a CPU port to DSA port
    
    DSA ports also need to have a dedicated CPU port assigned to them,
    because they need to know where to egress frames targeting the CPU,
    e.g. To_Cpu frames received on a Marvell Tag port.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 1e287420ff49..21f9bed11988 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -241,7 +241,7 @@ static int dsa_tree_setup_default_cpu(struct dsa_switch_tree *dst)
 		for (port = 0; port < ds->num_ports; port++) {
 			dp = &ds->ports[port];
 
-			if (dsa_port_is_user(dp))
+			if (dsa_port_is_user(dp) || dsa_port_is_dsa(dp))
 				dp->cpu_dp = dst->cpu_dp;
 		}
 	}

commit 9e741045faea17e28663f14a45f7f3304827c968
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Nov 24 11:36:06 2017 -0500

    net: dsa: fix 'increment on 0' warning
    
    Setting the refcount to 0 when allocating a tree to match the number of
    switch devices it holds may cause an 'increment on 0; use-after-free',
    if CONFIG_REFCOUNT_FULL is enabled.
    
    To fix this, do not decrement the refcount of a newly allocated tree,
    increment it when an already allocated tree is found, and decrement it
    after the probing of a switch, as done with the previous behavior.
    
    At the same time, make dsa_tree_get and dsa_tree_put accept a NULL
    argument to simplify callers, and return the tree after incrementation,
    as most kref users like of_node_get and of_node_put do.
    
    Fixes: 8e5bf9759a06 ("net: dsa: simplify tree reference counting")
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 44e3fb7dec8c..1e287420ff49 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -51,9 +51,7 @@ static struct dsa_switch_tree *dsa_tree_alloc(int index)
 	INIT_LIST_HEAD(&dst->list);
 	list_add_tail(&dsa_tree_list, &dst->list);
 
-	/* Initialize the reference counter to the number of switches, not 1 */
 	kref_init(&dst->refcount);
-	refcount_set(&dst->refcount.refcount, 0);
 
 	return dst;
 }
@@ -64,20 +62,23 @@ static void dsa_tree_free(struct dsa_switch_tree *dst)
 	kfree(dst);
 }
 
-static struct dsa_switch_tree *dsa_tree_touch(int index)
+static struct dsa_switch_tree *dsa_tree_get(struct dsa_switch_tree *dst)
 {
-	struct dsa_switch_tree *dst;
-
-	dst = dsa_tree_find(index);
-	if (!dst)
-		dst = dsa_tree_alloc(index);
+	if (dst)
+		kref_get(&dst->refcount);
 
 	return dst;
 }
 
-static void dsa_tree_get(struct dsa_switch_tree *dst)
+static struct dsa_switch_tree *dsa_tree_touch(int index)
 {
-	kref_get(&dst->refcount);
+	struct dsa_switch_tree *dst;
+
+	dst = dsa_tree_find(index);
+	if (dst)
+		return dsa_tree_get(dst);
+	else
+		return dsa_tree_alloc(index);
 }
 
 static void dsa_tree_release(struct kref *ref)
@@ -91,7 +92,8 @@ static void dsa_tree_release(struct kref *ref)
 
 static void dsa_tree_put(struct dsa_switch_tree *dst)
 {
-	kref_put(&dst->refcount, dsa_tree_release);
+	if (dst)
+		kref_put(&dst->refcount, dsa_tree_release);
 }
 
 static bool dsa_port_is_dsa(struct dsa_port *port)
@@ -765,6 +767,7 @@ int dsa_register_switch(struct dsa_switch *ds)
 
 	mutex_lock(&dsa2_mutex);
 	err = dsa_switch_probe(ds);
+	dsa_tree_put(ds->dst);
 	mutex_unlock(&dsa2_mutex);
 
 	return err;

commit 5ed4e3eb021762fee584ce65620bc822131c7aa0
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Nov 10 15:22:52 2017 -0800

    net: dsa: Pass a port to get_tag_protocol()
    
    A number of drivers want to check whether the configured CPU port is a
    possible configuration for enabling tagging, pass down the CPU port
    number so they verify that.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index fd54a8e17986..44e3fb7dec8c 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -539,7 +539,7 @@ static int dsa_port_parse_cpu(struct dsa_port *dp, struct net_device *master)
 	const struct dsa_device_ops *tag_ops;
 	enum dsa_tag_protocol tag_protocol;
 
-	tag_protocol = ds->ops->get_tag_protocol(ds);
+	tag_protocol = ds->ops->get_tag_protocol(ds, dp->index);
 	tag_ops = dsa_resolve_tag_protocol(tag_protocol);
 	if (IS_ERR(tag_ops)) {
 		dev_warn(ds->dev, "No tagger for this switch\n");

commit b4fbb347fe4cd7988d0f9453a7e3ab0cd1b4a75a
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Nov 6 16:11:53 2017 -0500

    net: dsa: rename probe and remove switch functions
    
    This commit brings no functional changes. It gets rid of the underscore
    prefixed _dsa_register_switch and _dsa_unregister_switch functions in
    favor of dsa_switch_probe() which parses and adds a switch to a tree and
    dsa_switch_remove() which removes a switch from a tree.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 3db50e68640e..fd54a8e17986 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -718,7 +718,7 @@ static int dsa_switch_add(struct dsa_switch *ds)
 	return dsa_tree_add_switch(dst, ds);
 }
 
-static int _dsa_register_switch(struct dsa_switch *ds)
+static int dsa_switch_probe(struct dsa_switch *ds)
 {
 	struct dsa_chip_data *pdata = ds->dev->platform_data;
 	struct device_node *np = ds->dev->of_node;
@@ -764,14 +764,14 @@ int dsa_register_switch(struct dsa_switch *ds)
 	int err;
 
 	mutex_lock(&dsa2_mutex);
-	err = _dsa_register_switch(ds);
+	err = dsa_switch_probe(ds);
 	mutex_unlock(&dsa2_mutex);
 
 	return err;
 }
 EXPORT_SYMBOL_GPL(dsa_register_switch);
 
-static void _dsa_unregister_switch(struct dsa_switch *ds)
+static void dsa_switch_remove(struct dsa_switch *ds)
 {
 	struct dsa_switch_tree *dst = ds->dst;
 	unsigned int index = ds->index;
@@ -782,7 +782,7 @@ static void _dsa_unregister_switch(struct dsa_switch *ds)
 void dsa_unregister_switch(struct dsa_switch *ds)
 {
 	mutex_lock(&dsa2_mutex);
-	_dsa_unregister_switch(ds);
+	dsa_switch_remove(ds);
 	mutex_unlock(&dsa2_mutex);
 }
 EXPORT_SYMBOL_GPL(dsa_unregister_switch);

commit 308173546ac4342103541e8d4e4ce83d1a5e7eba
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Nov 6 16:11:52 2017 -0500

    net: dsa: setup a tree when adding a switch to it
    
    Now that the tree setup is centralized, we can simplify the code a bit
    more by setting up or tearing down the tree directly when adding or
    removing a switch to/from it.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 44d26b5977cd..3db50e68640e 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -489,6 +489,8 @@ static void dsa_tree_teardown(struct dsa_switch_tree *dst)
 static void dsa_tree_remove_switch(struct dsa_switch_tree *dst,
 				   unsigned int index)
 {
+	dsa_tree_teardown(dst);
+
 	dst->ds[index] = NULL;
 	dsa_tree_put(dst);
 }
@@ -497,6 +499,7 @@ static int dsa_tree_add_switch(struct dsa_switch_tree *dst,
 			       struct dsa_switch *ds)
 {
 	unsigned int index = ds->index;
+	int err;
 
 	if (dst->ds[index])
 		return -EBUSY;
@@ -504,7 +507,11 @@ static int dsa_tree_add_switch(struct dsa_switch_tree *dst,
 	dsa_tree_get(dst);
 	dst->ds[index] = ds;
 
-	return 0;
+	err = dsa_tree_setup(dst);
+	if (err)
+		dsa_tree_remove_switch(dst, index);
+
+	return err;
 }
 
 static int dsa_port_parse_user(struct dsa_port *dp, const char *name)
@@ -704,12 +711,17 @@ static int dsa_switch_parse(struct dsa_switch *ds, struct dsa_chip_data *cd)
 	return dsa_switch_parse_ports(ds, cd);
 }
 
+static int dsa_switch_add(struct dsa_switch *ds)
+{
+	struct dsa_switch_tree *dst = ds->dst;
+
+	return dsa_tree_add_switch(dst, ds);
+}
+
 static int _dsa_register_switch(struct dsa_switch *ds)
 {
 	struct dsa_chip_data *pdata = ds->dev->platform_data;
 	struct device_node *np = ds->dev->of_node;
-	struct dsa_switch_tree *dst;
-	unsigned int index;
 	int err;
 
 	if (np)
@@ -722,20 +734,7 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 	if (err)
 		return err;
 
-	index = ds->index;
-	dst = ds->dst;
-
-	err = dsa_tree_add_switch(dst, ds);
-	if (err)
-		return err;
-
-	err = dsa_tree_setup(dst);
-	if (err) {
-		dsa_tree_teardown(dst);
-		dsa_tree_remove_switch(dst, index);
-	}
-
-	return err;
+	return dsa_switch_add(ds);
 }
 
 struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
@@ -777,8 +776,6 @@ static void _dsa_unregister_switch(struct dsa_switch *ds)
 	struct dsa_switch_tree *dst = ds->dst;
 	unsigned int index = ds->index;
 
-	dsa_tree_teardown(dst);
-
 	dsa_tree_remove_switch(dst, index);
 }
 

commit 34c09a8916fb52aac948dfc861b33c0b3b37ac29
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Nov 6 16:11:51 2017 -0500

    net: dsa: setup routing table
    
    The *_complete() functions take too much arguments to do only one thing:
    they try to fetch the dsa_port structures corresponding to device nodes
    under the "link" list property of DSA ports, and use them to setup the
    routing table of switches.
    
    This patch simplifies them by providing instead simpler
    dsa_{port,switch,tree}_setup_routing_table functions which return a
    boolean value, true if the tree is complete.
    
    dsa_tree_setup_routing_table is called inside dsa_tree_setup which
    simplifies the switch registering function as well.
    
    A switch's routing table is now initialized before its setup.
    
    This also makes dsa_port_is_valid obsolete, remove it.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 25ed41262ead..44d26b5977cd 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -94,14 +94,6 @@ static void dsa_tree_put(struct dsa_switch_tree *dst)
 	kref_put(&dst->refcount, dsa_tree_release);
 }
 
-/* For platform data configurations, we need to have a valid name argument to
- * differentiate a disabled port from an enabled one
- */
-static bool dsa_port_is_valid(struct dsa_port *port)
-{
-	return port->type != DSA_PORT_TYPE_UNUSED;
-}
-
 static bool dsa_port_is_dsa(struct dsa_port *port)
 {
 	return port->type == DSA_PORT_TYPE_DSA;
@@ -140,14 +132,12 @@ static struct dsa_port *dsa_tree_find_port_by_node(struct dsa_switch_tree *dst,
 	return NULL;
 }
 
-static int dsa_port_complete(struct dsa_switch_tree *dst,
-			     struct dsa_switch *src_ds,
-			     struct dsa_port *port,
-			     u32 src_port)
+static bool dsa_port_setup_routing_table(struct dsa_port *dp)
 {
-	struct device_node *dn = port->dn;
+	struct dsa_switch *ds = dp->ds;
+	struct dsa_switch_tree *dst = ds->dst;
+	struct device_node *dn = dp->dn;
 	struct of_phandle_iterator it;
-	struct dsa_switch *dst_ds;
 	struct dsa_port *link_dp;
 	int err;
 
@@ -155,66 +145,54 @@ static int dsa_port_complete(struct dsa_switch_tree *dst,
 		link_dp = dsa_tree_find_port_by_node(dst, it.node);
 		if (!link_dp) {
 			of_node_put(it.node);
-			return 1;
+			return false;
 		}
 
-		dst_ds = link_dp->ds;
-
-		src_ds->rtable[dst_ds->index] = src_port;
+		ds->rtable[link_dp->ds->index] = dp->index;
 	}
 
-	return 0;
+	return true;
 }
 
-/* A switch is complete if all the DSA ports phandles point to ports
- * known in the tree. A return value of 1 means the tree is not
- * complete. This is not an error condition. A value of 0 is
- * success.
- */
-static int dsa_ds_complete(struct dsa_switch_tree *dst, struct dsa_switch *ds)
+static bool dsa_switch_setup_routing_table(struct dsa_switch *ds)
 {
-	struct dsa_port *port;
-	u32 index;
-	int err;
+	bool complete = true;
+	struct dsa_port *dp;
+	int i;
 
-	for (index = 0; index < ds->num_ports; index++) {
-		port = &ds->ports[index];
-		if (!dsa_port_is_valid(port))
-			continue;
+	for (i = 0; i < DSA_MAX_SWITCHES; i++)
+		ds->rtable[i] = DSA_RTABLE_NONE;
 
-		if (!dsa_port_is_dsa(port))
-			continue;
+	for (i = 0; i < ds->num_ports; i++) {
+		dp = &ds->ports[i];
 
-		err = dsa_port_complete(dst, ds, port, index);
-		if (err != 0)
-			return err;
+		if (dsa_port_is_dsa(dp)) {
+			complete = dsa_port_setup_routing_table(dp);
+			if (!complete)
+				break;
+		}
 	}
 
-	return 0;
+	return complete;
 }
 
-/* A tree is complete if all the DSA ports phandles point to ports
- * known in the tree. A return value of 1 means the tree is not
- * complete. This is not an error condition. A value of 0 is
- * success.
- */
-static int dsa_dst_complete(struct dsa_switch_tree *dst)
+static bool dsa_tree_setup_routing_table(struct dsa_switch_tree *dst)
 {
 	struct dsa_switch *ds;
-	u32 index;
-	int err;
+	bool complete = true;
+	int device;
 
-	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
-		ds = dst->ds[index];
+	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
+		ds = dst->ds[device];
 		if (!ds)
 			continue;
 
-		err = dsa_ds_complete(dst, ds);
-		if (err != 0)
-			return err;
+		complete = dsa_switch_setup_routing_table(ds);
+		if (!complete)
+			break;
 	}
 
-	return 0;
+	return complete;
 }
 
 static struct dsa_port *dsa_tree_find_first_cpu(struct dsa_switch_tree *dst)
@@ -460,6 +438,7 @@ static void dsa_tree_teardown_master(struct dsa_switch_tree *dst)
 
 static int dsa_tree_setup(struct dsa_switch_tree *dst)
 {
+	bool complete;
 	int err;
 
 	if (dst->setup) {
@@ -468,6 +447,10 @@ static int dsa_tree_setup(struct dsa_switch_tree *dst)
 		return -EEXIST;
 	}
 
+	complete = dsa_tree_setup_routing_table(dst);
+	if (!complete)
+		return 0;
+
 	err = dsa_tree_setup_default_cpu(dst);
 	if (err)
 		return err;
@@ -727,7 +710,7 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 	struct device_node *np = ds->dev->of_node;
 	struct dsa_switch_tree *dst;
 	unsigned int index;
-	int i, err;
+	int err;
 
 	if (np)
 		err = dsa_switch_parse_of(ds, np);
@@ -742,33 +725,16 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 	index = ds->index;
 	dst = ds->dst;
 
-	/* Initialize the routing table */
-	for (i = 0; i < DSA_MAX_SWITCHES; ++i)
-		ds->rtable[i] = DSA_RTABLE_NONE;
-
 	err = dsa_tree_add_switch(dst, ds);
 	if (err)
 		return err;
 
-	err = dsa_dst_complete(dst);
-	if (err < 0)
-		goto out_del_dst;
-
-	/* Not all switches registered yet */
-	if (err == 1)
-		return 0;
-
 	err = dsa_tree_setup(dst);
 	if (err) {
 		dsa_tree_teardown(dst);
-		goto out_del_dst;
+		dsa_tree_remove_switch(dst, index);
 	}
 
-	return 0;
-
-out_del_dst:
-	dsa_tree_remove_switch(dst, index);
-
 	return err;
 }
 

commit c52866655558e5fc87ceae8aac528a7e410c8a77
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Nov 6 16:11:50 2017 -0500

    net: dsa: use of_for_each_phandle
    
    The OF code provides a of_for_each_phandle() helper to iterate over
    phandles. Use it instead of arbitrary iterating ourselves over the list
    of phandles hanging to the "link" property of the port's device node.
    
    The of_phandle_iterator_next() helper calls of_node_put() itself on
    it.node. Thus We must only do it ourselves if we break the loop.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 0f6f8c1701f9..25ed41262ead 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -145,21 +145,18 @@ static int dsa_port_complete(struct dsa_switch_tree *dst,
 			     struct dsa_port *port,
 			     u32 src_port)
 {
-	struct device_node *link;
-	int index;
+	struct device_node *dn = port->dn;
+	struct of_phandle_iterator it;
 	struct dsa_switch *dst_ds;
 	struct dsa_port *link_dp;
+	int err;
 
-	for (index = 0;; index++) {
-		link = of_parse_phandle(port->dn, "link", index);
-		if (!link)
-			break;
-
-		link_dp = dsa_tree_find_port_by_node(dst, link);
-		of_node_put(link);
-
-		if (!link_dp)
+	of_for_each_phandle(&it, err, dn, "link", NULL, 0) {
+		link_dp = dsa_tree_find_port_by_node(dst, it.node);
+		if (!link_dp) {
+			of_node_put(it.node);
 			return 1;
+		}
 
 		dst_ds = link_dp->ds;
 

commit f163da8853aa9d8060157a96ed314299b87ba070
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Nov 6 16:11:49 2017 -0500

    net: dsa: add find port by node helper
    
    Instead of having two dsa_ds_find_port_dn (which returns a bool) and
    dsa_dst_find_port_dn (which returns a switch) functions, provide a more
    explicit dsa_tree_find_port_by_node function which returns a matching
    port.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 676c0bc943dd..0f6f8c1701f9 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -117,30 +117,24 @@ static bool dsa_port_is_user(struct dsa_port *dp)
 	return dp->type == DSA_PORT_TYPE_USER;
 }
 
-static bool dsa_ds_find_port_dn(struct dsa_switch *ds,
-				struct device_node *port)
-{
-	u32 index;
-
-	for (index = 0; index < ds->num_ports; index++)
-		if (ds->ports[index].dn == port)
-			return true;
-	return false;
-}
-
-static struct dsa_switch *dsa_dst_find_port_dn(struct dsa_switch_tree *dst,
-					       struct device_node *port)
+static struct dsa_port *dsa_tree_find_port_by_node(struct dsa_switch_tree *dst,
+						   struct device_node *dn)
 {
 	struct dsa_switch *ds;
-	u32 index;
+	struct dsa_port *dp;
+	int device, port;
 
-	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
-		ds = dst->ds[index];
+	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
+		ds = dst->ds[device];
 		if (!ds)
 			continue;
 
-		if (dsa_ds_find_port_dn(ds, port))
-			return ds;
+		for (port = 0; port < ds->num_ports; port++) {
+			dp = &ds->ports[port];
+
+			if (dp->dn == dn)
+				return dp;
+		}
 	}
 
 	return NULL;
@@ -154,18 +148,21 @@ static int dsa_port_complete(struct dsa_switch_tree *dst,
 	struct device_node *link;
 	int index;
 	struct dsa_switch *dst_ds;
+	struct dsa_port *link_dp;
 
 	for (index = 0;; index++) {
 		link = of_parse_phandle(port->dn, "link", index);
 		if (!link)
 			break;
 
-		dst_ds = dsa_dst_find_port_dn(dst, link);
+		link_dp = dsa_tree_find_port_by_node(dst, link);
 		of_node_put(link);
 
-		if (!dst_ds)
+		if (!link_dp)
 			return 1;
 
+		dst_ds = link_dp->ds;
+
 		src_ds->rtable[dst_ds->index] = src_port;
 	}
 

commit 1d27732f411d57f0168af30be2adb504b8b7749d
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Nov 6 16:11:48 2017 -0500

    net: dsa: setup and teardown ports
    
    The dsa_dsa_port_apply and dsa_cpu_port_apply functions do exactly the
    same. The dsa_user_port_apply function does not try to register a fixed
    link but try to create a slave.
    
    This commit factorizes and scopes all that in two convenient
    dsa_port_setup and dsa_port_teardown functions.
    
    It won't hurt to register a devlink_port for unused port as well.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 2b3b2a86791d..676c0bc943dd 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -281,91 +281,65 @@ static void dsa_tree_teardown_default_cpu(struct dsa_switch_tree *dst)
 	dst->cpu_dp = NULL;
 }
 
-static int dsa_dsa_port_apply(struct dsa_port *port)
+static int dsa_port_setup(struct dsa_port *dp)
 {
-	struct dsa_switch *ds = port->ds;
+	struct dsa_switch *ds = dp->ds;
 	int err;
 
-	err = dsa_port_fixed_link_register_of(port);
-	if (err) {
-		dev_warn(ds->dev, "Failed to setup dsa port %d: %d\n",
-			 port->index, err);
-		return err;
-	}
-
-	memset(&port->devlink_port, 0, sizeof(port->devlink_port));
-
-	return devlink_port_register(ds->devlink, &port->devlink_port,
-				     port->index);
-}
-
-static void dsa_dsa_port_unapply(struct dsa_port *port)
-{
-	devlink_port_unregister(&port->devlink_port);
-	dsa_port_fixed_link_unregister_of(port);
-}
-
-static int dsa_cpu_port_apply(struct dsa_port *port)
-{
-	struct dsa_switch *ds = port->ds;
-	int err;
+	memset(&dp->devlink_port, 0, sizeof(dp->devlink_port));
 
-	err = dsa_port_fixed_link_register_of(port);
-	if (err) {
-		dev_warn(ds->dev, "Failed to setup cpu port %d: %d\n",
-			 port->index, err);
+	err = devlink_port_register(ds->devlink, &dp->devlink_port, dp->index);
+	if (err)
 		return err;
-	}
-
-	memset(&port->devlink_port, 0, sizeof(port->devlink_port));
-	err = devlink_port_register(ds->devlink, &port->devlink_port,
-				    port->index);
-	return err;
-}
-
-static void dsa_cpu_port_unapply(struct dsa_port *port)
-{
-	devlink_port_unregister(&port->devlink_port);
-	dsa_port_fixed_link_unregister_of(port);
-}
 
-static int dsa_user_port_apply(struct dsa_port *port)
-{
-	struct dsa_switch *ds = port->ds;
-	int err;
+	switch (dp->type) {
+	case DSA_PORT_TYPE_UNUSED:
+		break;
+	case DSA_PORT_TYPE_CPU:
+	case DSA_PORT_TYPE_DSA:
+		err = dsa_port_fixed_link_register_of(dp);
+		if (err) {
+			dev_err(ds->dev, "failed to register fixed link for port %d.%d\n",
+				ds->index, dp->index);
+			return err;
+		}
 
-	err = dsa_slave_create(port);
-	if (err) {
-		dev_warn(ds->dev, "Failed to create slave %d: %d\n",
-			 port->index, err);
-		port->slave = NULL;
-		return err;
+		break;
+	case DSA_PORT_TYPE_USER:
+		err = dsa_slave_create(dp);
+		if (err)
+			dev_err(ds->dev, "failed to create slave for port %d.%d\n",
+				ds->index, dp->index);
+		else
+			devlink_port_type_eth_set(&dp->devlink_port, dp->slave);
+		break;
 	}
 
-	memset(&port->devlink_port, 0, sizeof(port->devlink_port));
-	err = devlink_port_register(ds->devlink, &port->devlink_port,
-				    port->index);
-	if (err)
-		return err;
-
-	devlink_port_type_eth_set(&port->devlink_port, port->slave);
-
 	return 0;
 }
 
-static void dsa_user_port_unapply(struct dsa_port *port)
+static void dsa_port_teardown(struct dsa_port *dp)
 {
-	devlink_port_unregister(&port->devlink_port);
-	if (port->slave) {
-		dsa_slave_destroy(port->slave);
-		port->slave = NULL;
+	devlink_port_unregister(&dp->devlink_port);
+
+	switch (dp->type) {
+	case DSA_PORT_TYPE_UNUSED:
+		break;
+	case DSA_PORT_TYPE_CPU:
+	case DSA_PORT_TYPE_DSA:
+		dsa_port_fixed_link_unregister_of(dp);
+		break;
+	case DSA_PORT_TYPE_USER:
+		if (dp->slave) {
+			dsa_slave_destroy(dp->slave);
+			dp->slave = NULL;
+		}
+		break;
 	}
 }
 
 static int dsa_switch_setup(struct dsa_switch *ds)
 {
-	struct dsa_port *port;
-	u32 index;
 	int err;
 
 	/* Initialize ds->phys_mii_mask before registering the slave MDIO bus
@@ -406,56 +380,11 @@ static int dsa_switch_setup(struct dsa_switch *ds)
 			return err;
 	}
 
-	for (index = 0; index < ds->num_ports; index++) {
-		port = &ds->ports[index];
-		if (!dsa_port_is_valid(port))
-			continue;
-
-		if (dsa_port_is_dsa(port)) {
-			err = dsa_dsa_port_apply(port);
-			if (err)
-				return err;
-			continue;
-		}
-
-		if (dsa_port_is_cpu(port)) {
-			err = dsa_cpu_port_apply(port);
-			if (err)
-				return err;
-			continue;
-		}
-
-		err = dsa_user_port_apply(port);
-		if (err)
-			continue;
-	}
-
 	return 0;
 }
 
 static void dsa_switch_teardown(struct dsa_switch *ds)
 {
-	struct dsa_port *port;
-	u32 index;
-
-	for (index = 0; index < ds->num_ports; index++) {
-		port = &ds->ports[index];
-		if (!dsa_port_is_valid(port))
-			continue;
-
-		if (dsa_port_is_dsa(port)) {
-			dsa_dsa_port_unapply(port);
-			continue;
-		}
-
-		if (dsa_port_is_cpu(port)) {
-			dsa_cpu_port_unapply(port);
-			continue;
-		}
-
-		dsa_user_port_unapply(port);
-	}
-
 	if (ds->slave_mii_bus && ds->ops->phy_read)
 		mdiobus_unregister(ds->slave_mii_bus);
 
@@ -472,7 +401,8 @@ static void dsa_switch_teardown(struct dsa_switch *ds)
 static int dsa_tree_setup_switches(struct dsa_switch_tree *dst)
 {
 	struct dsa_switch *ds;
-	int device;
+	struct dsa_port *dp;
+	int device, port;
 	int err;
 
 	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
@@ -483,6 +413,14 @@ static int dsa_tree_setup_switches(struct dsa_switch_tree *dst)
 		err = dsa_switch_setup(ds);
 		if (err)
 			return err;
+
+		for (port = 0; port < ds->num_ports; port++) {
+			dp = &ds->ports[port];
+
+			err = dsa_port_setup(dp);
+			if (err)
+				return err;
+		}
 	}
 
 	return 0;
@@ -491,13 +429,20 @@ static int dsa_tree_setup_switches(struct dsa_switch_tree *dst)
 static void dsa_tree_teardown_switches(struct dsa_switch_tree *dst)
 {
 	struct dsa_switch *ds;
-	int device;
+	struct dsa_port *dp;
+	int device, port;
 
 	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
 		ds = dst->ds[device];
 		if (!ds)
 			continue;
 
+		for (port = 0; port < ds->num_ports; port++) {
+			dp = &ds->ports[port];
+
+			dsa_port_teardown(dp);
+		}
+
 		dsa_switch_teardown(ds);
 	}
 }

commit 1f08f9e9cbc63d92c246f40ae4221cba86ef8ec6
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Nov 6 16:11:47 2017 -0500

    net: dsa: setup and teardown switches
    
    This patches brings no functional changes. It removes the unused dst
    argument from the dsa_ds_apply and dsa_ds_unapply functions, rename them
    to dsa_switch_setup and dsa_switch_teardown for a more explicit scope.
    
    This clarifies the steps of the setup or teardown of a switch fabric.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 1a8df0a177b5..2b3b2a86791d 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -362,7 +362,7 @@ static void dsa_user_port_unapply(struct dsa_port *port)
 	}
 }
 
-static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
+static int dsa_switch_setup(struct dsa_switch *ds)
 {
 	struct dsa_port *port;
 	u32 index;
@@ -433,7 +433,7 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	return 0;
 }
 
-static void dsa_ds_unapply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
+static void dsa_switch_teardown(struct dsa_switch *ds)
 {
 	struct dsa_port *port;
 	u32 index;
@@ -469,6 +469,39 @@ static void dsa_ds_unapply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 
 }
 
+static int dsa_tree_setup_switches(struct dsa_switch_tree *dst)
+{
+	struct dsa_switch *ds;
+	int device;
+	int err;
+
+	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
+		ds = dst->ds[device];
+		if (!ds)
+			continue;
+
+		err = dsa_switch_setup(ds);
+		if (err)
+			return err;
+	}
+
+	return 0;
+}
+
+static void dsa_tree_teardown_switches(struct dsa_switch_tree *dst)
+{
+	struct dsa_switch *ds;
+	int device;
+
+	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
+		ds = dst->ds[device];
+		if (!ds)
+			continue;
+
+		dsa_switch_teardown(ds);
+	}
+}
+
 static int dsa_tree_setup_master(struct dsa_switch_tree *dst)
 {
 	struct dsa_port *cpu_dp = dst->cpu_dp;
@@ -488,8 +521,6 @@ static void dsa_tree_teardown_master(struct dsa_switch_tree *dst)
 
 static int dsa_tree_setup(struct dsa_switch_tree *dst)
 {
-	struct dsa_switch *ds;
-	u32 index;
 	int err;
 
 	if (dst->setup) {
@@ -502,15 +533,9 @@ static int dsa_tree_setup(struct dsa_switch_tree *dst)
 	if (err)
 		return err;
 
-	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
-		ds = dst->ds[index];
-		if (!ds)
-			continue;
-
-		err = dsa_ds_apply(dst, ds);
-		if (err)
-			return err;
-	}
+	err = dsa_tree_setup_switches(dst);
+	if (err)
+		return err;
 
 	err = dsa_tree_setup_master(dst);
 	if (err)
@@ -525,21 +550,12 @@ static int dsa_tree_setup(struct dsa_switch_tree *dst)
 
 static void dsa_tree_teardown(struct dsa_switch_tree *dst)
 {
-	struct dsa_switch *ds;
-	u32 index;
-
 	if (!dst->setup)
 		return;
 
 	dsa_tree_teardown_master(dst);
 
-	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
-		ds = dst->ds[index];
-		if (!ds)
-			continue;
-
-		dsa_ds_unapply(dst, ds);
-	}
+	dsa_tree_teardown_switches(dst);
 
 	dsa_tree_teardown_default_cpu(dst);
 

commit ec15dd4269d0cbf947c9a2dfdcf08a917098fab1
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Nov 6 16:11:46 2017 -0500

    net: dsa: setup and teardown tree
    
    This commit provides better scope for the DSA tree setup and teardown
    functions. It renames the "applied" bool to "setup" and print a message
    when the tree is setup, as it is done during teardown.
    
    At the same time, check dst->setup in dsa_tree_setup, where it is set to
    true.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index c9b50339fcac..1a8df0a177b5 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -486,12 +486,18 @@ static void dsa_tree_teardown_master(struct dsa_switch_tree *dst)
 	return dsa_master_teardown(master);
 }
 
-static int dsa_dst_apply(struct dsa_switch_tree *dst)
+static int dsa_tree_setup(struct dsa_switch_tree *dst)
 {
 	struct dsa_switch *ds;
 	u32 index;
 	int err;
 
+	if (dst->setup) {
+		pr_err("DSA: tree %d already setup! Disjoint trees?\n",
+		       dst->index);
+		return -EEXIST;
+	}
+
 	err = dsa_tree_setup_default_cpu(dst);
 	if (err)
 		return err;
@@ -510,17 +516,19 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 	if (err)
 		return err;
 
-	dst->applied = true;
+	dst->setup = true;
+
+	pr_info("DSA: tree %d setup\n", dst->index);
 
 	return 0;
 }
 
-static void dsa_dst_unapply(struct dsa_switch_tree *dst)
+static void dsa_tree_teardown(struct dsa_switch_tree *dst)
 {
 	struct dsa_switch *ds;
 	u32 index;
 
-	if (!dst->applied)
+	if (!dst->setup)
 		return;
 
 	dsa_tree_teardown_master(dst);
@@ -535,8 +543,9 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 
 	dsa_tree_teardown_default_cpu(dst);
 
-	pr_info("DSA: tree %d unapplied\n", dst->index);
-	dst->applied = false;
+	pr_info("DSA: tree %d torn down\n", dst->index);
+
+	dst->setup = false;
 }
 
 static void dsa_tree_remove_switch(struct dsa_switch_tree *dst,
@@ -794,14 +803,9 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 	if (err == 1)
 		return 0;
 
-	if (dst->applied) {
-		pr_info("DSA: Disjoint trees?\n");
-		return -EINVAL;
-	}
-
-	err = dsa_dst_apply(dst);
+	err = dsa_tree_setup(dst);
 	if (err) {
-		dsa_dst_unapply(dst);
+		dsa_tree_teardown(dst);
 		goto out_del_dst;
 	}
 
@@ -852,7 +856,7 @@ static void _dsa_unregister_switch(struct dsa_switch *ds)
 	struct dsa_switch_tree *dst = ds->dst;
 	unsigned int index = ds->index;
 
-	dsa_dst_unapply(dst);
+	dsa_tree_teardown(dst);
 
 	dsa_tree_remove_switch(dst, index);
 }

commit 17a22fcfc84a422d98a0f54e67d4ee8ee3875849
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Nov 6 16:11:45 2017 -0500

    net: dsa: setup and teardown master device
    
    Add DSA helpers to setup and teardown a master net device wired to its
    CPU port. This centralizes the dsa_ptr assignment.
    
    This also makes the master ethtool helpers static at the same time.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 0a63a2119cd0..c9b50339fcac 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -469,6 +469,23 @@ static void dsa_ds_unapply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 
 }
 
+static int dsa_tree_setup_master(struct dsa_switch_tree *dst)
+{
+	struct dsa_port *cpu_dp = dst->cpu_dp;
+	struct net_device *master = cpu_dp->master;
+
+	/* DSA currently supports a single pair of CPU port and master device */
+	return dsa_master_setup(master, cpu_dp);
+}
+
+static void dsa_tree_teardown_master(struct dsa_switch_tree *dst)
+{
+	struct dsa_port *cpu_dp = dst->cpu_dp;
+	struct net_device *master = cpu_dp->master;
+
+	return dsa_master_teardown(master);
+}
+
 static int dsa_dst_apply(struct dsa_switch_tree *dst)
 {
 	struct dsa_switch *ds;
@@ -489,14 +506,7 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 			return err;
 	}
 
-	/* If we use a tagging format that doesn't have an ethertype
-	 * field, make sure that all packets from this point on get
-	 * sent to the tag format's receive function.
-	 */
-	wmb();
-	dst->cpu_dp->master->dsa_ptr = dst->cpu_dp;
-
-	err = dsa_master_ethtool_setup(dst->cpu_dp->master);
+	err = dsa_tree_setup_master(dst);
 	if (err)
 		return err;
 
@@ -513,15 +523,7 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 	if (!dst->applied)
 		return;
 
-	dsa_master_ethtool_restore(dst->cpu_dp->master);
-
-	dst->cpu_dp->master->dsa_ptr = NULL;
-
-	/* If we used a tagging format that doesn't have an ethertype
-	 * field, make sure that all packets from this point get sent
-	 * without the tag and go through the regular receive path.
-	 */
-	wmb();
+	dsa_tree_teardown_master(dst);
 
 	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
 		ds = dst->ds[index];

commit f070464cf000131928b2c3fd592efd1946610eea
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Nov 6 16:11:44 2017 -0500

    net: dsa: setup and teardown default CPU port
    
    The dsa_dst_parse function called just before dsa_dst_apply does not
    parse the tree but does only one thing: it assigns the default CPU port
    to dst->cpu_dp and to each user ports.
    
    This patch simplifies this by calling a dsa_tree_setup_default_cpu
    function at the beginning of dsa_dst_apply directly.
    
    A dsa_port_is_user helper is added for convenience.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 283104e5ca6a..0a63a2119cd0 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -112,6 +112,11 @@ static bool dsa_port_is_cpu(struct dsa_port *port)
 	return port->type == DSA_PORT_TYPE_CPU;
 }
 
+static bool dsa_port_is_user(struct dsa_port *dp)
+{
+	return dp->type == DSA_PORT_TYPE_USER;
+}
+
 static bool dsa_ds_find_port_dn(struct dsa_switch *ds,
 				struct device_node *port)
 {
@@ -218,6 +223,64 @@ static int dsa_dst_complete(struct dsa_switch_tree *dst)
 	return 0;
 }
 
+static struct dsa_port *dsa_tree_find_first_cpu(struct dsa_switch_tree *dst)
+{
+	struct dsa_switch *ds;
+	struct dsa_port *dp;
+	int device, port;
+
+	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
+		ds = dst->ds[device];
+		if (!ds)
+			continue;
+
+		for (port = 0; port < ds->num_ports; port++) {
+			dp = &ds->ports[port];
+
+			if (dsa_port_is_cpu(dp))
+				return dp;
+		}
+	}
+
+	return NULL;
+}
+
+static int dsa_tree_setup_default_cpu(struct dsa_switch_tree *dst)
+{
+	struct dsa_switch *ds;
+	struct dsa_port *dp;
+	int device, port;
+
+	/* DSA currently only supports a single CPU port */
+	dst->cpu_dp = dsa_tree_find_first_cpu(dst);
+	if (!dst->cpu_dp) {
+		pr_warn("Tree has no master device\n");
+		return -EINVAL;
+	}
+
+	/* Assign the default CPU port to all ports of the fabric */
+	for (device = 0; device < DSA_MAX_SWITCHES; device++) {
+		ds = dst->ds[device];
+		if (!ds)
+			continue;
+
+		for (port = 0; port < ds->num_ports; port++) {
+			dp = &ds->ports[port];
+
+			if (dsa_port_is_user(dp))
+				dp->cpu_dp = dst->cpu_dp;
+		}
+	}
+
+	return 0;
+}
+
+static void dsa_tree_teardown_default_cpu(struct dsa_switch_tree *dst)
+{
+	/* DSA currently only supports a single CPU port */
+	dst->cpu_dp = NULL;
+}
+
 static int dsa_dsa_port_apply(struct dsa_port *port)
 {
 	struct dsa_switch *ds = port->ds;
@@ -412,6 +475,10 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 	u32 index;
 	int err;
 
+	err = dsa_tree_setup_default_cpu(dst);
+	if (err)
+		return err;
+
 	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
 		ds = dst->ds[index];
 		if (!ds)
@@ -464,7 +531,7 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 		dsa_ds_unapply(dst, ds);
 	}
 
-	dst->cpu_dp = NULL;
+	dsa_tree_teardown_default_cpu(dst);
 
 	pr_info("DSA: tree %d unapplied\n", dst->index);
 	dst->applied = false;
@@ -532,86 +599,6 @@ static int dsa_port_parse_cpu(struct dsa_port *dp, struct net_device *master)
 	return 0;
 }
 
-static int dsa_cpu_parse(struct dsa_port *port, u32 index,
-			 struct dsa_switch_tree *dst,
-			 struct dsa_switch *ds)
-{
-	if (!dst->cpu_dp)
-		dst->cpu_dp = port;
-
-	return 0;
-}
-
-static int dsa_ds_parse(struct dsa_switch_tree *dst, struct dsa_switch *ds)
-{
-	struct dsa_port *port;
-	u32 index;
-	int err;
-
-	for (index = 0; index < ds->num_ports; index++) {
-		port = &ds->ports[index];
-		if (!dsa_port_is_valid(port) ||
-		    dsa_port_is_dsa(port))
-			continue;
-
-		if (dsa_port_is_cpu(port)) {
-			err = dsa_cpu_parse(port, index, dst, ds);
-			if (err)
-				return err;
-		}
-
-	}
-
-	pr_info("DSA: switch %d %d parsed\n", dst->index, ds->index);
-
-	return 0;
-}
-
-static int dsa_dst_parse(struct dsa_switch_tree *dst)
-{
-	struct dsa_switch *ds;
-	struct dsa_port *dp;
-	u32 index;
-	int port;
-	int err;
-
-	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
-		ds = dst->ds[index];
-		if (!ds)
-			continue;
-
-		err = dsa_ds_parse(dst, ds);
-		if (err)
-			return err;
-	}
-
-	if (!dst->cpu_dp) {
-		pr_warn("Tree has no master device\n");
-		return -EINVAL;
-	}
-
-	/* Assign the default CPU port to all ports of the fabric */
-	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
-		ds = dst->ds[index];
-		if (!ds)
-			continue;
-
-		for (port = 0; port < ds->num_ports; port++) {
-			dp = &ds->ports[port];
-			if (!dsa_port_is_valid(dp) ||
-			    dsa_port_is_dsa(dp) ||
-			    dsa_port_is_cpu(dp))
-				continue;
-
-			dp->cpu_dp = dst->cpu_dp;
-		}
-	}
-
-	pr_info("DSA: tree %d parsed\n", dst->index);
-
-	return 0;
-}
-
 static int dsa_port_parse_of(struct dsa_port *dp, struct device_node *dn)
 {
 	struct device_node *ethernet = of_parse_phandle(dn, "ethernet", 0);
@@ -810,10 +797,6 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 		return -EINVAL;
 	}
 
-	err = dsa_dst_parse(dst);
-	if (err)
-		goto out_del_dst;
-
 	err = dsa_dst_apply(dst);
 	if (err) {
 		dsa_dst_unapply(dst);

commit 7354fcb0a3a3a5518107f8de117a6ce5ce08cc7c
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Nov 3 19:05:30 2017 -0400

    net: dsa: resolve tagging protocol at parse time
    
    Extend the dsa_port_parse_cpu() function to resolve the tagging protocol
    at port parsing time, instead of waiting for the whole tree to be
    complete.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 271a97ef5bf6..283104e5ca6a 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -511,8 +511,23 @@ static int dsa_port_parse_dsa(struct dsa_port *dp)
 
 static int dsa_port_parse_cpu(struct dsa_port *dp, struct net_device *master)
 {
+	struct dsa_switch *ds = dp->ds;
+	struct dsa_switch_tree *dst = ds->dst;
+	const struct dsa_device_ops *tag_ops;
+	enum dsa_tag_protocol tag_protocol;
+
+	tag_protocol = ds->ops->get_tag_protocol(ds);
+	tag_ops = dsa_resolve_tag_protocol(tag_protocol);
+	if (IS_ERR(tag_ops)) {
+		dev_warn(ds->dev, "No tagger for this switch\n");
+		return PTR_ERR(tag_ops);
+	}
+
 	dp->type = DSA_PORT_TYPE_CPU;
+	dp->rcv = tag_ops->rcv;
+	dp->tag_ops = tag_ops;
 	dp->master = master;
+	dp->dst = dst;
 
 	return 0;
 }
@@ -521,25 +536,9 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 			 struct dsa_switch_tree *dst,
 			 struct dsa_switch *ds)
 {
-	const struct dsa_device_ops *tag_ops;
-	enum dsa_tag_protocol tag_protocol;
-
 	if (!dst->cpu_dp)
 		dst->cpu_dp = port;
 
-	tag_protocol = ds->ops->get_tag_protocol(ds);
-	tag_ops = dsa_resolve_tag_protocol(tag_protocol);
-	if (IS_ERR(tag_ops)) {
-		dev_warn(ds->dev, "No tagger for this switch\n");
-		return PTR_ERR(tag_ops);
-	}
-
-	dst->cpu_dp->tag_ops = tag_ops;
-
-	/* Make a few copies for faster access in master receive hot path */
-	dst->cpu_dp->rcv = dst->cpu_dp->tag_ops->rcv;
-	dst->cpu_dp->dst = dst;
-
 	return 0;
 }
 

commit 06e24d0868a361774fc46d0819450915e63a2815
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Nov 3 19:05:29 2017 -0400

    net: dsa: add one port parsing function per type
    
    Add dsa_port_parse_user, dsa_port_parse_dsa and dsa_port_parse_cpu
    functions to factorize the code shared by both OF and pdata parsing.
    
    They don't do much for the moment but will be extended later to support
    tagging protocol resolution for example.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 06bcdb6bc796..271a97ef5bf6 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -491,6 +491,32 @@ static int dsa_tree_add_switch(struct dsa_switch_tree *dst,
 	return 0;
 }
 
+static int dsa_port_parse_user(struct dsa_port *dp, const char *name)
+{
+	if (!name)
+		name = "eth%d";
+
+	dp->type = DSA_PORT_TYPE_USER;
+	dp->name = name;
+
+	return 0;
+}
+
+static int dsa_port_parse_dsa(struct dsa_port *dp)
+{
+	dp->type = DSA_PORT_TYPE_DSA;
+
+	return 0;
+}
+
+static int dsa_port_parse_cpu(struct dsa_port *dp, struct net_device *master)
+{
+	dp->type = DSA_PORT_TYPE_CPU;
+	dp->master = master;
+
+	return 0;
+}
+
 static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 			 struct dsa_switch_tree *dst,
 			 struct dsa_switch *ds)
@@ -593,6 +619,8 @@ static int dsa_port_parse_of(struct dsa_port *dp, struct device_node *dn)
 	const char *name = of_get_property(dn, "label", NULL);
 	bool link = of_property_read_bool(dn, "link");
 
+	dp->dn = dn;
+
 	if (ethernet) {
 		struct net_device *master;
 
@@ -600,21 +628,13 @@ static int dsa_port_parse_of(struct dsa_port *dp, struct device_node *dn)
 		if (!master)
 			return -EPROBE_DEFER;
 
-		dp->type = DSA_PORT_TYPE_CPU;
-		dp->master = master;
-	} else if (link) {
-		dp->type = DSA_PORT_TYPE_DSA;
-	} else {
-		if (!name)
-			name = "eth%d";
-
-		dp->type = DSA_PORT_TYPE_USER;
-		dp->name = name;
+		return dsa_port_parse_cpu(dp, master);
 	}
 
-	dp->dn = dn;
+	if (link)
+		return dsa_port_parse_dsa(dp);
 
-	return 0;
+	return dsa_port_parse_user(dp, name);
 }
 
 static int dsa_switch_parse_ports_of(struct dsa_switch *ds,
@@ -694,17 +714,13 @@ static int dsa_port_parse(struct dsa_port *dp, const char *name,
 
 		dev_put(master);
 
-		dp->type = DSA_PORT_TYPE_CPU;
-		dp->master = master;
-	} else if (!strcmp(name, "dsa")) {
-		dp->type = DSA_PORT_TYPE_DSA;
-	} else {
-		dp->type = DSA_PORT_TYPE_USER;
+		return dsa_port_parse_cpu(dp, master);
 	}
 
-	dp->name = name;
+	if (!strcmp(name, "dsa"))
+		return dsa_port_parse_dsa(dp);
 
-	return 0;
+	return dsa_port_parse_user(dp, name);
 }
 
 static int dsa_switch_parse_ports(struct dsa_switch *ds,

commit 54df6fa9541752b3b28106eb1a9764dcda815fd2
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Nov 3 19:05:28 2017 -0400

    net: dsa: only check presence of link property
    
    When parsing a port, simply use of_property_read_bool which checks the
    presence of a given property, instead of parsing the link phandle.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index dfcb6247f2f2..06bcdb6bc796 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -590,8 +590,8 @@ static int dsa_dst_parse(struct dsa_switch_tree *dst)
 static int dsa_port_parse_of(struct dsa_port *dp, struct device_node *dn)
 {
 	struct device_node *ethernet = of_parse_phandle(dn, "ethernet", 0);
-	struct device_node *link = of_parse_phandle(dn, "link", 0);
 	const char *name = of_get_property(dn, "label", NULL);
+	bool link = of_property_read_bool(dn, "link");
 
 	if (ethernet) {
 		struct net_device *master;

commit 975e6e32215e6cbc09b65d762865b1a46e8e9103
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Nov 3 19:05:27 2017 -0400

    net: dsa: rework switch parsing
    
    When parsing a switch, we have to identify to which tree it belongs and
    parse its ports. Provide two functions to separate the OF and platform
    data specific paths.
    
    Also use the of_property_read_variable_u32_array function to parse the
    OF member array instead of calling of_property_read_u32_index twice.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 5918fbddb0ab..dfcb6247f2f2 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -617,7 +617,8 @@ static int dsa_port_parse_of(struct dsa_port *dp, struct device_node *dn)
 	return 0;
 }
 
-static int dsa_parse_ports_of(struct device_node *dn, struct dsa_switch *ds)
+static int dsa_switch_parse_ports_of(struct dsa_switch *ds,
+				     struct device_node *dn)
 {
 	struct device_node *ports, *port;
 	struct dsa_port *dp;
@@ -648,6 +649,39 @@ static int dsa_parse_ports_of(struct device_node *dn, struct dsa_switch *ds)
 	return 0;
 }
 
+static int dsa_switch_parse_member_of(struct dsa_switch *ds,
+				      struct device_node *dn)
+{
+	u32 m[2] = { 0, 0 };
+	int sz;
+
+	/* Don't error out if this optional property isn't found */
+	sz = of_property_read_variable_u32_array(dn, "dsa,member", m, 2, 2);
+	if (sz < 0 && sz != -EINVAL)
+		return sz;
+
+	ds->index = m[1];
+	if (ds->index >= DSA_MAX_SWITCHES)
+		return -EINVAL;
+
+	ds->dst = dsa_tree_touch(m[0]);
+	if (!ds->dst)
+		return -ENOMEM;
+
+	return 0;
+}
+
+static int dsa_switch_parse_of(struct dsa_switch *ds, struct device_node *dn)
+{
+	int err;
+
+	err = dsa_switch_parse_member_of(ds, dn);
+	if (err)
+		return err;
+
+	return dsa_switch_parse_ports_of(ds, dn);
+}
+
 static int dsa_port_parse(struct dsa_port *dp, const char *name,
 			  struct device *dev)
 {
@@ -673,7 +707,8 @@ static int dsa_port_parse(struct dsa_port *dp, const char *name,
 	return 0;
 }
 
-static int dsa_parse_ports(struct dsa_chip_data *cd, struct dsa_switch *ds)
+static int dsa_switch_parse_ports(struct dsa_switch *ds,
+				  struct dsa_chip_data *cd)
 {
 	bool valid_name_found = false;
 	struct dsa_port *dp;
@@ -703,40 +738,19 @@ static int dsa_parse_ports(struct dsa_chip_data *cd, struct dsa_switch *ds)
 	return 0;
 }
 
-static int dsa_parse_member_dn(struct device_node *np, u32 *tree, u32 *index)
-{
-	int err;
-
-	*tree = *index = 0;
-
-	err = of_property_read_u32_index(np, "dsa,member", 0, tree);
-	if (err) {
-		/* Does not exist, but it is optional */
-		if (err == -EINVAL)
-			return 0;
-		return err;
-	}
-
-	err = of_property_read_u32_index(np, "dsa,member", 1, index);
-	if (err)
-		return err;
-
-	if (*index >= DSA_MAX_SWITCHES)
-		return -EINVAL;
-
-	return 0;
-}
-
-static int dsa_parse_member(struct dsa_chip_data *pd, u32 *tree, u32 *index)
+static int dsa_switch_parse(struct dsa_switch *ds, struct dsa_chip_data *cd)
 {
-	if (!pd)
-		return -ENODEV;
+	ds->cd = cd;
 
-	/* We do not support complex trees with dsa_chip_data */
-	*tree = 0;
-	*index = 0;
+	/* We don't support interconnected switches nor multiple trees via
+	 * platform data, so this is the unique switch of the tree.
+	 */
+	ds->index = 0;
+	ds->dst = dsa_tree_touch(0);
+	if (!ds->dst)
+		return -ENOMEM;
 
-	return 0;
+	return dsa_switch_parse_ports(ds, cd);
 }
 
 static int _dsa_register_switch(struct dsa_switch *ds)
@@ -744,36 +758,21 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 	struct dsa_chip_data *pdata = ds->dev->platform_data;
 	struct device_node *np = ds->dev->of_node;
 	struct dsa_switch_tree *dst;
-	u32 tree, index;
+	unsigned int index;
 	int i, err;
 
-	if (np) {
-		err = dsa_parse_member_dn(np, &tree, &index);
-		if (err)
-			return err;
-	} else {
-		err = dsa_parse_member(pdata, &tree, &index);
-		if (err)
-			return err;
-	}
+	if (np)
+		err = dsa_switch_parse_of(ds, np);
+	else if (pdata)
+		err = dsa_switch_parse(ds, pdata);
+	else
+		err = -ENODEV;
 
-	dst = dsa_tree_touch(tree);
-	if (!dst)
-		return -ENOMEM;
-
-	ds->dst = dst;
-	ds->index = index;
-	ds->cd = pdata;
+	if (err)
+		return err;
 
-	if (np) {
-		err = dsa_parse_ports_of(np, ds);
-		if (err)
-			return err;
-	} else {
-		err = dsa_parse_ports(pdata, ds);
-		if (err)
-			return err;
-	}
+	index = ds->index;
+	dst = ds->dst;
 
 	/* Initialize the routing table */
 	for (i = 0; i < DSA_MAX_SWITCHES; ++i)

commit 0eefe2c1730020c6207bc9695fd466e558301dbb
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Nov 3 19:05:26 2017 -0400

    net: dsa: get tree before parsing ports
    
    We will need a reference to the dsa_switch_tree when parsing a CPU port,
    so fetch it right after parsing the member and before parsing ports.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 5b6a3dad8015..5918fbddb0ab 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -751,18 +751,10 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 		err = dsa_parse_member_dn(np, &tree, &index);
 		if (err)
 			return err;
-
-		err = dsa_parse_ports_of(np, ds);
-		if (err)
-			return err;
 	} else {
 		err = dsa_parse_member(pdata, &tree, &index);
 		if (err)
 			return err;
-
-		err = dsa_parse_ports(pdata, ds);
-		if (err)
-			return err;
 	}
 
 	dst = dsa_tree_touch(tree);
@@ -773,6 +765,16 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 	ds->index = index;
 	ds->cd = pdata;
 
+	if (np) {
+		err = dsa_parse_ports_of(np, ds);
+		if (err)
+			return err;
+	} else {
+		err = dsa_parse_ports(pdata, ds);
+		if (err)
+			return err;
+	}
+
 	/* Initialize the routing table */
 	for (i = 0; i < DSA_MAX_SWITCHES; ++i)
 		ds->rtable[i] = DSA_RTABLE_NONE;

commit 6da2a940ac6a0680e50b3aaf945e409cea03c346
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Nov 3 19:05:25 2017 -0400

    net: dsa: rework switch addition and removal
    
    This patch removes the unnecessary index argument from the
    dsa_dst_add_ds and dsa_dst_del_ds functions and renames them to
    dsa_tree_add_switch and dsa_tree_remove_switch respectively.
    
    In addition to a more explicit scope, we now check the presence of an
    existing switch with the same index directly within dsa_tree_add_switch.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index bda222cfc02c..5b6a3dad8015 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -94,20 +94,6 @@ static void dsa_tree_put(struct dsa_switch_tree *dst)
 	kref_put(&dst->refcount, dsa_tree_release);
 }
 
-static void dsa_dst_add_ds(struct dsa_switch_tree *dst,
-			   struct dsa_switch *ds, u32 index)
-{
-	dsa_tree_get(dst);
-	dst->ds[index] = ds;
-}
-
-static void dsa_dst_del_ds(struct dsa_switch_tree *dst,
-			   struct dsa_switch *ds, u32 index)
-{
-	dst->ds[index] = NULL;
-	dsa_tree_put(dst);
-}
-
 /* For platform data configurations, we need to have a valid name argument to
  * differentiate a disabled port from an enabled one
  */
@@ -484,6 +470,27 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 	dst->applied = false;
 }
 
+static void dsa_tree_remove_switch(struct dsa_switch_tree *dst,
+				   unsigned int index)
+{
+	dst->ds[index] = NULL;
+	dsa_tree_put(dst);
+}
+
+static int dsa_tree_add_switch(struct dsa_switch_tree *dst,
+			       struct dsa_switch *ds)
+{
+	unsigned int index = ds->index;
+
+	if (dst->ds[index])
+		return -EBUSY;
+
+	dsa_tree_get(dst);
+	dst->ds[index] = ds;
+
+	return 0;
+}
+
 static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 			 struct dsa_switch_tree *dst,
 			 struct dsa_switch *ds)
@@ -762,9 +769,6 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 	if (!dst)
 		return -ENOMEM;
 
-	if (dst->ds[index])
-		return -EBUSY;
-
 	ds->dst = dst;
 	ds->index = index;
 	ds->cd = pdata;
@@ -773,7 +777,9 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 	for (i = 0; i < DSA_MAX_SWITCHES; ++i)
 		ds->rtable[i] = DSA_RTABLE_NONE;
 
-	dsa_dst_add_ds(dst, ds, index);
+	err = dsa_tree_add_switch(dst, ds);
+	if (err)
+		return err;
 
 	err = dsa_dst_complete(dst);
 	if (err < 0)
@@ -801,7 +807,7 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 	return 0;
 
 out_del_dst:
-	dsa_dst_del_ds(dst, ds, ds->index);
+	dsa_tree_remove_switch(dst, index);
 
 	return err;
 }
@@ -843,10 +849,11 @@ EXPORT_SYMBOL_GPL(dsa_register_switch);
 static void _dsa_unregister_switch(struct dsa_switch *ds)
 {
 	struct dsa_switch_tree *dst = ds->dst;
+	unsigned int index = ds->index;
 
 	dsa_dst_unapply(dst);
 
-	dsa_dst_del_ds(dst, ds, ds->index);
+	dsa_tree_remove_switch(dst, index);
 }
 
 void dsa_unregister_switch(struct dsa_switch *ds)

commit 1ca28ec9abff927178b1ea9d6431e4c320145b10
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Nov 3 19:05:24 2017 -0400

    net: dsa: provide a find or new tree helper
    
    Rename dsa_get_dst to dsa_tree_find since it doesn't increment the
    reference counter, rename dsa_add_dst to dsa_tree_alloc for symmetry
    with dsa_tree_free, and provide a convenient dsa_tree_touch function to
    find or allocate a new tree.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 609d92684505..bda222cfc02c 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -21,33 +21,35 @@
 
 #include "dsa_priv.h"
 
-static LIST_HEAD(dsa_switch_trees);
+static LIST_HEAD(dsa_tree_list);
 static DEFINE_MUTEX(dsa2_mutex);
 
 static const struct devlink_ops dsa_devlink_ops = {
 };
 
-static struct dsa_switch_tree *dsa_get_dst(unsigned int index)
+static struct dsa_switch_tree *dsa_tree_find(int index)
 {
 	struct dsa_switch_tree *dst;
 
-	list_for_each_entry(dst, &dsa_switch_trees, list)
+	list_for_each_entry(dst, &dsa_tree_list, list)
 		if (dst->index == index)
 			return dst;
 
 	return NULL;
 }
 
-static struct dsa_switch_tree *dsa_add_dst(unsigned int index)
+static struct dsa_switch_tree *dsa_tree_alloc(int index)
 {
 	struct dsa_switch_tree *dst;
 
 	dst = kzalloc(sizeof(*dst), GFP_KERNEL);
 	if (!dst)
 		return NULL;
+
 	dst->index = index;
+
 	INIT_LIST_HEAD(&dst->list);
-	list_add_tail(&dsa_switch_trees, &dst->list);
+	list_add_tail(&dsa_tree_list, &dst->list);
 
 	/* Initialize the reference counter to the number of switches, not 1 */
 	kref_init(&dst->refcount);
@@ -62,6 +64,17 @@ static void dsa_tree_free(struct dsa_switch_tree *dst)
 	kfree(dst);
 }
 
+static struct dsa_switch_tree *dsa_tree_touch(int index)
+{
+	struct dsa_switch_tree *dst;
+
+	dst = dsa_tree_find(index);
+	if (!dst)
+		dst = dsa_tree_alloc(index);
+
+	return dst;
+}
+
 static void dsa_tree_get(struct dsa_switch_tree *dst)
 {
 	kref_get(&dst->refcount);
@@ -745,12 +758,9 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 			return err;
 	}
 
-	dst = dsa_get_dst(tree);
-	if (!dst) {
-		dst = dsa_add_dst(tree);
-		if (!dst)
-			return -ENOMEM;
-	}
+	dst = dsa_tree_touch(tree);
+	if (!dst)
+		return -ENOMEM;
 
 	if (dst->ds[index])
 		return -EBUSY;

commit 65254108b4655dc55e8d8f62ee895960085e73f4
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Nov 3 19:05:23 2017 -0400

    net: dsa: get and put tree reference counting
    
    Provide convenient dsa_tree_get and dsa_tree_put functions scoping a DSA
    tree used to increment and decrement its reference counter, instead of
    poking directly its kref structure.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index d3f1a7607463..609d92684505 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -38,15 +38,6 @@ static struct dsa_switch_tree *dsa_get_dst(unsigned int index)
 	return NULL;
 }
 
-static void dsa_free_dst(struct kref *ref)
-{
-	struct dsa_switch_tree *dst = container_of(ref, struct dsa_switch_tree,
-						   refcount);
-
-	list_del(&dst->list);
-	kfree(dst);
-}
-
 static struct dsa_switch_tree *dsa_add_dst(unsigned int index)
 {
 	struct dsa_switch_tree *dst;
@@ -65,10 +56,35 @@ static struct dsa_switch_tree *dsa_add_dst(unsigned int index)
 	return dst;
 }
 
+static void dsa_tree_free(struct dsa_switch_tree *dst)
+{
+	list_del(&dst->list);
+	kfree(dst);
+}
+
+static void dsa_tree_get(struct dsa_switch_tree *dst)
+{
+	kref_get(&dst->refcount);
+}
+
+static void dsa_tree_release(struct kref *ref)
+{
+	struct dsa_switch_tree *dst;
+
+	dst = container_of(ref, struct dsa_switch_tree, refcount);
+
+	dsa_tree_free(dst);
+}
+
+static void dsa_tree_put(struct dsa_switch_tree *dst)
+{
+	kref_put(&dst->refcount, dsa_tree_release);
+}
+
 static void dsa_dst_add_ds(struct dsa_switch_tree *dst,
 			   struct dsa_switch *ds, u32 index)
 {
-	kref_get(&dst->refcount);
+	dsa_tree_get(dst);
 	dst->ds[index] = ds;
 }
 
@@ -76,7 +92,7 @@ static void dsa_dst_del_ds(struct dsa_switch_tree *dst,
 			   struct dsa_switch *ds, u32 index)
 {
 	dst->ds[index] = NULL;
-	kref_put(&dst->refcount, dsa_free_dst);
+	dsa_tree_put(dst);
 }
 
 /* For platform data configurations, we need to have a valid name argument to

commit 8e5bf9759a06be2251fa96cfd8b412f1808c62f9
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Nov 3 19:05:22 2017 -0400

    net: dsa: simplify tree reference counting
    
    DSA trees have a refcount used to automatically free the dsa_switch_tree
    structure once there is no switch devices inside of it.
    
    The refcount is incremented when a switch is added to the tree, and
    decremented when it is removed from it.
    
    But because of kref_init, the refcount is also incremented at
    initialization, and when looking up the tree from the list for symmetry.
    
    Thus the current code stores the number of switches plus one, and makes
    the switch registration more complex.
    
    To simplify the switch registration function, we reset the refcount to
    zero after initialization and don't increment it when looking up a tree.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 8b68dc2f5707..d3f1a7607463 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -32,10 +32,9 @@ static struct dsa_switch_tree *dsa_get_dst(unsigned int index)
 	struct dsa_switch_tree *dst;
 
 	list_for_each_entry(dst, &dsa_switch_trees, list)
-		if (dst->index == index) {
-			kref_get(&dst->refcount);
+		if (dst->index == index)
 			return dst;
-		}
+
 	return NULL;
 }
 
@@ -48,11 +47,6 @@ static void dsa_free_dst(struct kref *ref)
 	kfree(dst);
 }
 
-static void dsa_put_dst(struct dsa_switch_tree *dst)
-{
-	kref_put(&dst->refcount, dsa_free_dst);
-}
-
 static struct dsa_switch_tree *dsa_add_dst(unsigned int index)
 {
 	struct dsa_switch_tree *dst;
@@ -63,7 +57,10 @@ static struct dsa_switch_tree *dsa_add_dst(unsigned int index)
 	dst->index = index;
 	INIT_LIST_HEAD(&dst->list);
 	list_add_tail(&dsa_switch_trees, &dst->list);
+
+	/* Initialize the reference counter to the number of switches, not 1 */
 	kref_init(&dst->refcount);
+	refcount_set(&dst->refcount.refcount, 0);
 
 	return dst;
 }
@@ -739,10 +736,8 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 			return -ENOMEM;
 	}
 
-	if (dst->ds[index]) {
-		err = -EBUSY;
-		goto out;
-	}
+	if (dst->ds[index])
+		return -EBUSY;
 
 	ds->dst = dst;
 	ds->index = index;
@@ -758,11 +753,9 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 	if (err < 0)
 		goto out_del_dst;
 
-	if (err == 1) {
-		/* Not all switches registered yet */
-		err = 0;
-		goto out;
-	}
+	/* Not all switches registered yet */
+	if (err == 1)
+		return 0;
 
 	if (dst->applied) {
 		pr_info("DSA: Disjoint trees?\n");
@@ -779,13 +772,10 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 		goto out_del_dst;
 	}
 
-	dsa_put_dst(dst);
 	return 0;
 
 out_del_dst:
 	dsa_dst_del_ds(dst, ds, ds->index);
-out:
-	dsa_put_dst(dst);
 
 	return err;
 }

commit 49463b7f2da1a115404b02c5533bc2c2125833a3
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Nov 3 19:05:21 2017 -0400

    net: dsa: make tree index unsigned
    
    Similarly to a DSA switch and port, rename the tree index from "tree" to
    "index" and make it an unsigned int because it isn't supposed to be less
    than 0.
    
    u32 is an OF specific data used to retrieve the value and has no need to
    be propagated up to the tree index.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 797d1156b4e6..8b68dc2f5707 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -27,12 +27,12 @@ static DEFINE_MUTEX(dsa2_mutex);
 static const struct devlink_ops dsa_devlink_ops = {
 };
 
-static struct dsa_switch_tree *dsa_get_dst(u32 tree)
+static struct dsa_switch_tree *dsa_get_dst(unsigned int index)
 {
 	struct dsa_switch_tree *dst;
 
 	list_for_each_entry(dst, &dsa_switch_trees, list)
-		if (dst->tree == tree) {
+		if (dst->index == index) {
 			kref_get(&dst->refcount);
 			return dst;
 		}
@@ -53,14 +53,14 @@ static void dsa_put_dst(struct dsa_switch_tree *dst)
 	kref_put(&dst->refcount, dsa_free_dst);
 }
 
-static struct dsa_switch_tree *dsa_add_dst(u32 tree)
+static struct dsa_switch_tree *dsa_add_dst(unsigned int index)
 {
 	struct dsa_switch_tree *dst;
 
 	dst = kzalloc(sizeof(*dst), GFP_KERNEL);
 	if (!dst)
 		return NULL;
-	dst->tree = tree;
+	dst->index = index;
 	INIT_LIST_HEAD(&dst->list);
 	list_add_tail(&dsa_switch_trees, &dst->list);
 	kref_init(&dst->refcount);
@@ -454,7 +454,7 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 
 	dst->cpu_dp = NULL;
 
-	pr_info("DSA: tree %d unapplied\n", dst->tree);
+	pr_info("DSA: tree %d unapplied\n", dst->index);
 	dst->applied = false;
 }
 
@@ -504,7 +504,7 @@ static int dsa_ds_parse(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 
 	}
 
-	pr_info("DSA: switch %d %d parsed\n", dst->tree, ds->index);
+	pr_info("DSA: switch %d %d parsed\n", dst->index, ds->index);
 
 	return 0;
 }
@@ -549,7 +549,7 @@ static int dsa_dst_parse(struct dsa_switch_tree *dst)
 		}
 	}
 
-	pr_info("DSA: tree %d parsed\n", dst->tree);
+	pr_info("DSA: tree %d parsed\n", dst->index);
 
 	return 0;
 }

commit 951259aa60180e2897d28b538bf68a3a213da471
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Oct 27 15:55:19 2017 -0400

    net: dsa: remove name arg from slave create
    
    Now that slave dsa_port always have their name set, there is no need to
    pass it to dsa_slave_create() anymore. Remove this argument.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 3c134ff26863..797d1156b4e6 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -257,10 +257,9 @@ static void dsa_cpu_port_unapply(struct dsa_port *port)
 static int dsa_user_port_apply(struct dsa_port *port)
 {
 	struct dsa_switch *ds = port->ds;
-	const char *name = port->name;
 	int err;
 
-	err = dsa_slave_create(port, name);
+	err = dsa_slave_create(port);
 	if (err) {
 		dev_warn(ds->dev, "Failed to create slave %d: %d\n",
 			 port->index, err);

commit 1838fa89a22cbc9ec87e995683e241a82d87e6df
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Oct 27 15:55:18 2017 -0400

    net: dsa: get port name at parse time
    
    Get the optional "label" property and assign a default one directly at
    parse time instead of doing it when creating the slave.
    
    For legacy, simply assign the port name stored in cd->port_names.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 8cd84c1b3dc0..3c134ff26863 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -260,11 +260,6 @@ static int dsa_user_port_apply(struct dsa_port *port)
 	const char *name = port->name;
 	int err;
 
-	if (port->dn)
-		name = of_get_property(port->dn, "label", NULL);
-	if (!name)
-		name = "eth%d";
-
 	err = dsa_slave_create(port, name);
 	if (err) {
 		dev_warn(ds->dev, "Failed to create slave %d: %d\n",
@@ -564,6 +559,7 @@ static int dsa_port_parse_of(struct dsa_port *dp, struct device_node *dn)
 {
 	struct device_node *ethernet = of_parse_phandle(dn, "ethernet", 0);
 	struct device_node *link = of_parse_phandle(dn, "link", 0);
+	const char *name = of_get_property(dn, "label", NULL);
 
 	if (ethernet) {
 		struct net_device *master;
@@ -577,7 +573,11 @@ static int dsa_port_parse_of(struct dsa_port *dp, struct device_node *dn)
 	} else if (link) {
 		dp->type = DSA_PORT_TYPE_DSA;
 	} else {
+		if (!name)
+			name = "eth%d";
+
 		dp->type = DSA_PORT_TYPE_USER;
+		dp->name = name;
 	}
 
 	dp->dn = dn;

commit cbabb0ac01052f79cf96d7b7e3d3451ffd275864
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Oct 27 15:55:17 2017 -0400

    net: dsa: get master device at port parsing time
    
    Fetching the master device can be done directly when a port is parsed
    from device tree or pdata, instead of waiting until dsa_dst_parse.
    
    Now that -EPROBE_DEFER is returned before we add the switch to the tree,
    there is no need to check for this error after dsa_dst_parse.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 895c38427ef0..8cd84c1b3dc0 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -470,27 +470,9 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 {
 	const struct dsa_device_ops *tag_ops;
 	enum dsa_tag_protocol tag_protocol;
-	struct net_device *ethernet_dev;
-	struct device_node *ethernet;
 
-	if (port->dn) {
-		ethernet = of_parse_phandle(port->dn, "ethernet", 0);
-		if (!ethernet)
-			return -EINVAL;
-		ethernet_dev = of_find_net_device_by_node(ethernet);
-		if (!ethernet_dev)
-			return -EPROBE_DEFER;
-	} else {
-		ethernet_dev = dsa_dev_to_net_device(ds->cd->netdev[index]);
-		if (!ethernet_dev)
-			return -EPROBE_DEFER;
-		dev_put(ethernet_dev);
-	}
-
-	if (!dst->cpu_dp) {
+	if (!dst->cpu_dp)
 		dst->cpu_dp = port;
-		dst->cpu_dp->master = ethernet_dev;
-	}
 
 	tag_protocol = ds->ops->get_tag_protocol(ds);
 	tag_ops = dsa_resolve_tag_protocol(tag_protocol);
@@ -584,7 +566,14 @@ static int dsa_port_parse_of(struct dsa_port *dp, struct device_node *dn)
 	struct device_node *link = of_parse_phandle(dn, "link", 0);
 
 	if (ethernet) {
+		struct net_device *master;
+
+		master = of_find_net_device_by_node(ethernet);
+		if (!master)
+			return -EPROBE_DEFER;
+
 		dp->type = DSA_PORT_TYPE_CPU;
+		dp->master = master;
 	} else if (link) {
 		dp->type = DSA_PORT_TYPE_DSA;
 	} else {
@@ -631,7 +620,16 @@ static int dsa_port_parse(struct dsa_port *dp, const char *name,
 			  struct device *dev)
 {
 	if (!strcmp(name, "cpu")) {
+		struct net_device *master;
+
+		master = dsa_dev_to_net_device(dev);
+		if (!master)
+			return -EPROBE_DEFER;
+
+		dev_put(master);
+
 		dp->type = DSA_PORT_TYPE_CPU;
+		dp->master = master;
 	} else if (!strcmp(name, "dsa")) {
 		dp->type = DSA_PORT_TYPE_DSA;
 	} else {
@@ -773,14 +771,8 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 	}
 
 	err = dsa_dst_parse(dst);
-	if (err) {
-		if (err == -EPROBE_DEFER) {
-			dsa_dst_del_ds(dst, ds, ds->index);
-			return err;
-		}
-
+	if (err)
 		goto out_del_dst;
-	}
 
 	err = dsa_dst_apply(dst);
 	if (err) {

commit 6d4e5c570c2d66c806ecc6bd851fcf881fe8a38e
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Oct 27 15:55:15 2017 -0400

    net: dsa: get port type at parse time
    
    Assign a port's type at parsed time instead of waiting for the tree to
    be completed.
    
    Because this is now done earlier, we can use the port's type in
    dsa_port_is_* helpers instead of digging again in topology description.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index a0ee91cd3814..895c38427ef0 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -87,23 +87,17 @@ static void dsa_dst_del_ds(struct dsa_switch_tree *dst,
  */
 static bool dsa_port_is_valid(struct dsa_port *port)
 {
-	return !!(port->dn || port->name);
+	return port->type != DSA_PORT_TYPE_UNUSED;
 }
 
 static bool dsa_port_is_dsa(struct dsa_port *port)
 {
-	if (port->name && !strcmp(port->name, "dsa"))
-		return true;
-	else
-		return !!of_parse_phandle(port->dn, "link", 0);
+	return port->type == DSA_PORT_TYPE_DSA;
 }
 
 static bool dsa_port_is_cpu(struct dsa_port *port)
 {
-	if (port->name && !strcmp(port->name, "cpu"))
-		return true;
-	else
-		return !!of_parse_phandle(port->dn, "ethernet", 0);
+	return port->type == DSA_PORT_TYPE_CPU;
 }
 
 static bool dsa_ds_find_port_dn(struct dsa_switch *ds,
@@ -183,8 +177,6 @@ static int dsa_ds_complete(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 		err = dsa_port_complete(dst, ds, port, index);
 		if (err != 0)
 			return err;
-
-		port->type = DSA_PORT_TYPE_DSA;
 	}
 
 	return 0;
@@ -500,8 +492,6 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 		dst->cpu_dp->master = ethernet_dev;
 	}
 
-	port->type = DSA_PORT_TYPE_CPU;
-
 	tag_protocol = ds->ops->get_tag_protocol(ds);
 	tag_ops = dsa_resolve_tag_protocol(tag_protocol);
 	if (IS_ERR(tag_ops)) {
@@ -534,8 +524,6 @@ static int dsa_ds_parse(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 			err = dsa_cpu_parse(port, index, dst, ds);
 			if (err)
 				return err;
-		} else {
-			port->type = DSA_PORT_TYPE_USER;
 		}
 
 	}
@@ -592,6 +580,17 @@ static int dsa_dst_parse(struct dsa_switch_tree *dst)
 
 static int dsa_port_parse_of(struct dsa_port *dp, struct device_node *dn)
 {
+	struct device_node *ethernet = of_parse_phandle(dn, "ethernet", 0);
+	struct device_node *link = of_parse_phandle(dn, "link", 0);
+
+	if (ethernet) {
+		dp->type = DSA_PORT_TYPE_CPU;
+	} else if (link) {
+		dp->type = DSA_PORT_TYPE_DSA;
+	} else {
+		dp->type = DSA_PORT_TYPE_USER;
+	}
+
 	dp->dn = dn;
 
 	return 0;
@@ -631,6 +630,14 @@ static int dsa_parse_ports_of(struct device_node *dn, struct dsa_switch *ds)
 static int dsa_port_parse(struct dsa_port *dp, const char *name,
 			  struct device *dev)
 {
+	if (!strcmp(name, "cpu")) {
+		dp->type = DSA_PORT_TYPE_CPU;
+	} else if (!strcmp(name, "dsa")) {
+		dp->type = DSA_PORT_TYPE_DSA;
+	} else {
+		dp->type = DSA_PORT_TYPE_USER;
+	}
+
 	dp->name = name;
 
 	return 0;

commit fd223e2e66eb076b5dda586db9a5a3c99f76f99a
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Oct 27 15:55:14 2017 -0400

    net: dsa: add port parse functions
    
    Add symmetrical DSA port parsing functions for pdata and device tree,
    used to parse and validate a given port node or platform data.
    
    They don't do much for the moment but will be extended later on to
    assign a port type and get device references.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 9d57f8dee9a1..a0ee91cd3814 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -590,9 +590,17 @@ static int dsa_dst_parse(struct dsa_switch_tree *dst)
 	return 0;
 }
 
+static int dsa_port_parse_of(struct dsa_port *dp, struct device_node *dn)
+{
+	dp->dn = dn;
+
+	return 0;
+}
+
 static int dsa_parse_ports_of(struct device_node *dn, struct dsa_switch *ds)
 {
 	struct device_node *ports, *port;
+	struct dsa_port *dp;
 	u32 reg;
 	int err;
 
@@ -610,22 +618,45 @@ static int dsa_parse_ports_of(struct device_node *dn, struct dsa_switch *ds)
 		if (reg >= ds->num_ports)
 			return -EINVAL;
 
-		ds->ports[reg].dn = port;
+		dp = &ds->ports[reg];
+
+		err = dsa_port_parse_of(dp, port);
+		if (err)
+			return err;
 	}
 
 	return 0;
 }
 
+static int dsa_port_parse(struct dsa_port *dp, const char *name,
+			  struct device *dev)
+{
+	dp->name = name;
+
+	return 0;
+}
+
 static int dsa_parse_ports(struct dsa_chip_data *cd, struct dsa_switch *ds)
 {
 	bool valid_name_found = false;
+	struct dsa_port *dp;
+	struct device *dev;
+	const char *name;
 	unsigned int i;
+	int err;
 
 	for (i = 0; i < DSA_MAX_PORTS; i++) {
-		if (!cd->port_names[i])
+		name = cd->port_names[i];
+		dev = cd->netdev[i];
+		dp = &ds->ports[i];
+
+		if (!name)
 			continue;
 
-		ds->ports[i].name = cd->port_names[i];
+		err = dsa_port_parse(dp, name, dev);
+		if (err)
+			return err;
+
 		valid_name_found = true;
 	}
 

commit 5b32fe070c2ddf31adc42c26dab8af346b652538
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Oct 27 15:55:13 2017 -0400

    net: dsa: get ports within parsing code
    
    There is no point into hiding the -EINVAL error code in ERR_PTR from a
    dsa_get_ports function, simply get the "ports" node directly from within
    the dsa_parse_ports_dn function.
    
    This also has the effect to make the pdata and device tree handling code
    symmetrical inside _dsa_register_switch.
    
    At the same time, rename dsa_parse_ports_dn to dsa_parse_ports_of
    because _of is a more common suffix for device tree parsing functions.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 4d1ccf87c59c..9d57f8dee9a1 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -590,11 +590,17 @@ static int dsa_dst_parse(struct dsa_switch_tree *dst)
 	return 0;
 }
 
-static int dsa_parse_ports_dn(struct device_node *ports, struct dsa_switch *ds)
+static int dsa_parse_ports_of(struct device_node *dn, struct dsa_switch *ds)
 {
-	struct device_node *port;
-	int err;
+	struct device_node *ports, *port;
 	u32 reg;
+	int err;
+
+	ports = of_get_child_by_name(dn, "ports");
+	if (!ports) {
+		dev_err(ds->dev, "no ports child node found\n");
+		return -EINVAL;
+	}
 
 	for_each_available_child_of_node(ports, port) {
 		err = of_property_read_u32(port, "reg", &reg);
@@ -665,26 +671,11 @@ static int dsa_parse_member(struct dsa_chip_data *pd, u32 *tree, u32 *index)
 	return 0;
 }
 
-static struct device_node *dsa_get_ports(struct dsa_switch *ds,
-					 struct device_node *np)
-{
-	struct device_node *ports;
-
-	ports = of_get_child_by_name(np, "ports");
-	if (!ports) {
-		dev_err(ds->dev, "no ports child node found\n");
-		return ERR_PTR(-EINVAL);
-	}
-
-	return ports;
-}
-
 static int _dsa_register_switch(struct dsa_switch *ds)
 {
 	struct dsa_chip_data *pdata = ds->dev->platform_data;
 	struct device_node *np = ds->dev->of_node;
 	struct dsa_switch_tree *dst;
-	struct device_node *ports;
 	u32 tree, index;
 	int i, err;
 
@@ -693,11 +684,7 @@ static int _dsa_register_switch(struct dsa_switch *ds)
 		if (err)
 			return err;
 
-		ports = dsa_get_ports(ds, np);
-		if (IS_ERR(ports))
-			return PTR_ERR(ports);
-
-		err = dsa_parse_ports_dn(ports, ds);
+		err = dsa_parse_ports_of(np, ds);
 		if (err)
 			return err;
 	} else {

commit e1ea2f9856b765a2eaabb403a6751f70efc9ba4c
Merge: aad93c70b9a3 0b07194bb55e
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Oct 30 14:10:01 2017 +0900

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Several conflicts here.
    
    NFP driver bug fix adding nfp_netdev_is_nfp_repr() check to
    nfp_fl_output() needed some adjustments because the code block is in
    an else block now.
    
    Parallel additions to net/pkt_cls.h and net/sch_generic.h
    
    A bug fix in __tcp_retransmit_skb() conflicted with some of
    the rbtree changes in net-next.
    
    The tc action RCU callback fixes in 'net' had some overlap with some
    of the recent tcf_block reworking.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 57ab1ca215971702df534ae93cd76c15ca084c77
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Thu Oct 26 10:50:07 2017 -0400

    net: dsa: move fixed link registration helpers
    
    The new bindings (dsa2.c) and the old bindings (legacy.c) share two
    helpers dsa_cpu_dsa_setup and dsa_cpu_dsa_destroy, used to register or
    deregister a fixed PHY if a given port has a corresponding device node.
    
    Unclutter the code by moving them into two new port.c helpers,
    dsa_port_fixed_link_register_of and dsa_port_fixed_link_(un)register_of.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index ec58654a71cd..de91c48b6806 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -219,7 +219,7 @@ static int dsa_dsa_port_apply(struct dsa_port *port)
 	struct dsa_switch *ds = port->ds;
 	int err;
 
-	err = dsa_cpu_dsa_setup(port);
+	err = dsa_port_fixed_link_register_of(port);
 	if (err) {
 		dev_warn(ds->dev, "Failed to setup dsa port %d: %d\n",
 			 port->index, err);
@@ -235,7 +235,7 @@ static int dsa_dsa_port_apply(struct dsa_port *port)
 static void dsa_dsa_port_unapply(struct dsa_port *port)
 {
 	devlink_port_unregister(&port->devlink_port);
-	dsa_cpu_dsa_destroy(port);
+	dsa_port_fixed_link_unregister_of(port);
 }
 
 static int dsa_cpu_port_apply(struct dsa_port *port)
@@ -243,7 +243,7 @@ static int dsa_cpu_port_apply(struct dsa_port *port)
 	struct dsa_switch *ds = port->ds;
 	int err;
 
-	err = dsa_cpu_dsa_setup(port);
+	err = dsa_port_fixed_link_register_of(port);
 	if (err) {
 		dev_warn(ds->dev, "Failed to setup cpu port %d: %d\n",
 			 port->index, err);
@@ -259,7 +259,7 @@ static int dsa_cpu_port_apply(struct dsa_port *port)
 static void dsa_cpu_port_unapply(struct dsa_port *port)
 {
 	devlink_port_unregister(&port->devlink_port);
-	dsa_cpu_dsa_destroy(port);
+	dsa_port_fixed_link_unregister_of(port);
 }
 
 static int dsa_user_port_apply(struct dsa_port *port)

commit 5749f0f3772b9d98f37e3a92539f49fafaa64eca
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Thu Oct 26 11:22:59 2017 -0400

    net: dsa: remove port masks
    
    Now that DSA core provides port types, there is no need to keep this
    information at the switch level. This is a static information that is
    part of a DSA core dsa_port structure. Remove them.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index dd6f35b92937..ec58654a71cd 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -184,7 +184,6 @@ static int dsa_ds_complete(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 		if (err != 0)
 			return err;
 
-		ds->dsa_port_mask |= BIT(index);
 		port->type = DSA_PORT_TYPE_DSA;
 	}
 
@@ -500,11 +499,6 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 		dst->cpu_dp->master = ethernet_dev;
 	}
 
-	/* Initialize cpu_port_mask now for drv->setup()
-	 * to have access to a correct value, just like what
-	 * net/dsa/dsa.c::dsa_switch_setup_one does.
-	 */
-	ds->cpu_port_mask |= BIT(index);
 	port->type = DSA_PORT_TYPE_CPU;
 
 	tag_protocol = ds->ops->get_tag_protocol(ds);
@@ -540,11 +534,6 @@ static int dsa_ds_parse(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 			if (err)
 				return err;
 		} else {
-			/* Initialize enabled_port_mask now for drv->setup()
-			 * to have access to a correct value, just like what
-			 * net/dsa/dsa.c::dsa_switch_setup_one does.
-			 */
-			ds->enabled_port_mask |= BIT(index);
 			port->type = DSA_PORT_TYPE_USER;
 		}
 

commit 057cad2c59d73b0c4a6638546f3099d6fb444094
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Thu Oct 26 11:22:57 2017 -0400

    net: dsa: define port types
    
    Introduce an enumerated type for ports, which will be way more explicit
    to identify a port type instead of digging into switch port masks.
    
    A port can be of type CPU, DSA, user, or unused by default. This is a
    static parsed information that cannot be changed at runtime.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index d43c59c91058..dd6f35b92937 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -185,6 +185,7 @@ static int dsa_ds_complete(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 			return err;
 
 		ds->dsa_port_mask |= BIT(index);
+		port->type = DSA_PORT_TYPE_DSA;
 	}
 
 	return 0;
@@ -504,6 +505,7 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 	 * net/dsa/dsa.c::dsa_switch_setup_one does.
 	 */
 	ds->cpu_port_mask |= BIT(index);
+	port->type = DSA_PORT_TYPE_CPU;
 
 	tag_protocol = ds->ops->get_tag_protocol(ds);
 	tag_ops = dsa_resolve_tag_protocol(tag_protocol);
@@ -543,6 +545,7 @@ static int dsa_ds_parse(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 			 * net/dsa/dsa.c::dsa_switch_setup_one does.
 			 */
 			ds->enabled_port_mask |= BIT(index);
+			port->type = DSA_PORT_TYPE_USER;
 		}
 
 	}

commit 02bc6e546e858b209c3ebe380a13a73b333b1b3f
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Thu Oct 26 11:22:56 2017 -0400

    net: dsa: introduce dsa_user_ports helper
    
    Introduce a dsa_user_ports() helper to return the ds->enabled_port_mask
    mask which is more explicit. This will also minimize diffs when touching
    this internal mask.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 62485a57dbfc..d43c59c91058 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -312,7 +312,7 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	 * the slave MDIO bus driver rely on these values for probing PHY
 	 * devices or not
 	 */
-	ds->phys_mii_mask = ds->enabled_port_mask;
+	ds->phys_mii_mask |= dsa_user_ports(ds);
 
 	/* Add the switch to devlink before calling setup, so that setup can
 	 * add dpipe tables

commit eaac97466ee4e0ab6ed67afbf9fc400862e64986
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Oct 23 14:17:31 2017 -0400

    net: dsa: don't unmask port bitmaps
    
    The unapply functions are called on the error path.
    
    As for dsa_port_mask, enabled_port_mask and cpu_port_mask won't be used
    after so there's no need to unmask the corresponding port bit from them.
    
    This makes dsa_cpu_port_unapply() and dsa_dsa_port_unapply() identical,
    which can be factorized later.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 9e8b8aab049d..62485a57dbfc 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -260,8 +260,6 @@ static void dsa_cpu_port_unapply(struct dsa_port *port)
 {
 	devlink_port_unregister(&port->devlink_port);
 	dsa_cpu_dsa_destroy(port);
-	port->ds->cpu_port_mask &= ~BIT(port->index);
-
 }
 
 static int dsa_user_port_apply(struct dsa_port *port)
@@ -300,7 +298,6 @@ static void dsa_user_port_unapply(struct dsa_port *port)
 	if (port->slave) {
 		dsa_slave_destroy(port->slave);
 		port->slave = NULL;
-		port->ds->enabled_port_mask &= ~(1 << port->index);
 	}
 }
 
@@ -512,7 +509,6 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 	tag_ops = dsa_resolve_tag_protocol(tag_protocol);
 	if (IS_ERR(tag_ops)) {
 		dev_warn(ds->dev, "No tagger for this switch\n");
-		ds->cpu_port_mask &= ~BIT(index);
 		return PTR_ERR(tag_ops);
 	}
 

commit 3eb8feeb1708c7dbfd2e97df92a2a407c116606e
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Tue Oct 24 16:37:19 2017 -0400

    net: dsa: check master device before put
    
    In the case of pdata, the dsa_cpu_parse function calls dev_put() before
    making sure it isn't NULL. Fix this.
    
    Fixes: 71e0bbde0d88 ("net: dsa: Add support for platform data")
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 873af0108e24..045d8a176279 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -496,14 +496,15 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 		if (!ethernet)
 			return -EINVAL;
 		ethernet_dev = of_find_net_device_by_node(ethernet);
+		if (!ethernet_dev)
+			return -EPROBE_DEFER;
 	} else {
 		ethernet_dev = dsa_dev_to_net_device(ds->cd->netdev[index]);
+		if (!ethernet_dev)
+			return -EPROBE_DEFER;
 		dev_put(ethernet_dev);
 	}
 
-	if (!ethernet_dev)
-		return -EPROBE_DEFER;
-
 	if (!dst->cpu_dp) {
 		dst->cpu_dp = port;
 		dst->cpu_dp->netdev = ethernet_dev;

commit f8b8b1cd5aadd221742b45eb0ee3c8a80abf036a
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Oct 16 11:12:18 2017 -0400

    net: dsa: split dsa_port's netdev member
    
    The dsa_port structure has a "netdev" member, which can be used for
    either the master device, or the slave device, depending on its type.
    
    It is true that today, CPU port are not exposed to userspace, thus the
    port's netdev member can be used to point to its master interface.
    
    But it is still slightly confusing, so split it into more explicit
    "master" and "slave" members inside an anonymous union.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 6ac9e11d385c..9e8b8aab049d 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -279,7 +279,7 @@ static int dsa_user_port_apply(struct dsa_port *port)
 	if (err) {
 		dev_warn(ds->dev, "Failed to create slave %d: %d\n",
 			 port->index, err);
-		port->netdev = NULL;
+		port->slave = NULL;
 		return err;
 	}
 
@@ -289,7 +289,7 @@ static int dsa_user_port_apply(struct dsa_port *port)
 	if (err)
 		return err;
 
-	devlink_port_type_eth_set(&port->devlink_port, port->netdev);
+	devlink_port_type_eth_set(&port->devlink_port, port->slave);
 
 	return 0;
 }
@@ -297,9 +297,9 @@ static int dsa_user_port_apply(struct dsa_port *port)
 static void dsa_user_port_unapply(struct dsa_port *port)
 {
 	devlink_port_unregister(&port->devlink_port);
-	if (port->netdev) {
-		dsa_slave_destroy(port->netdev);
-		port->netdev = NULL;
+	if (port->slave) {
+		dsa_slave_destroy(port->slave);
+		port->slave = NULL;
 		port->ds->enabled_port_mask &= ~(1 << port->index);
 	}
 }
@@ -432,9 +432,9 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 	 * sent to the tag format's receive function.
 	 */
 	wmb();
-	dst->cpu_dp->netdev->dsa_ptr = dst->cpu_dp;
+	dst->cpu_dp->master->dsa_ptr = dst->cpu_dp;
 
-	err = dsa_master_ethtool_setup(dst->cpu_dp->netdev);
+	err = dsa_master_ethtool_setup(dst->cpu_dp->master);
 	if (err)
 		return err;
 
@@ -451,9 +451,9 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 	if (!dst->applied)
 		return;
 
-	dsa_master_ethtool_restore(dst->cpu_dp->netdev);
+	dsa_master_ethtool_restore(dst->cpu_dp->master);
 
-	dst->cpu_dp->netdev->dsa_ptr = NULL;
+	dst->cpu_dp->master->dsa_ptr = NULL;
 
 	/* If we used a tagging format that doesn't have an ethertype
 	 * field, make sure that all packets from this point get sent
@@ -499,7 +499,7 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 
 	if (!dst->cpu_dp) {
 		dst->cpu_dp = port;
-		dst->cpu_dp->netdev = ethernet_dev;
+		dst->cpu_dp->master = ethernet_dev;
 	}
 
 	/* Initialize cpu_port_mask now for drv->setup()

commit 841f4f24053acad69240c6ab7427a1d24bc29491
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Oct 13 14:18:09 2017 -0400

    net: dsa: remove .set_addr
    
    Now that there is no user for the .set_addr function, remove it from
    DSA. If a switch supports this feature (like mv88e6xxx), the
    implementation can be done in the driver setup.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 54ed054777bd..6ac9e11d385c 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -336,12 +336,6 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	if (err)
 		return err;
 
-	if (ds->ops->set_addr) {
-		err = ds->ops->set_addr(ds, dst->cpu_dp->netdev->dev_addr);
-		if (err < 0)
-			return err;
-	}
-
 	if (!ds->slave_mii_bus && ds->ops->phy_read) {
 		ds->slave_mii_bus = devm_mdiobus_alloc(ds->dev);
 		if (!ds->slave_mii_bus)

commit aa193d9b1d7ea6893ce24a9d141f676950563987
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Sep 29 17:19:21 2017 -0400

    net: dsa: remove tag ops from the switch tree
    
    Now that the dsa_ptr is a dsa_port instance, there is no need to keep
    the tag operations in the dsa_switch_tree structure. Remove it.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 62302558f38c..54ed054777bd 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -523,11 +523,9 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 	}
 
 	dst->cpu_dp->tag_ops = tag_ops;
-	dst->tag_ops = tag_ops;
 
 	/* Make a few copies for faster access in master receive hot path */
 	dst->cpu_dp->rcv = dst->cpu_dp->tag_ops->rcv;
-	dst->rcv = dst->tag_ops->rcv;
 	dst->cpu_dp->dst = dst;
 
 	return 0;

commit 2f657a600409f1961d67642fe384a9d4be71d36a
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Sep 29 17:19:20 2017 -0400

    net: dsa: change dsa_ptr for a dsa_port
    
    With DSA, a master net device (CPU facing interface) has a dsa_ptr
    pointer to which hangs a dsa_switch_tree. This is not correct because a
    master interface is wired to a dedicated switch port, and because we can
    theoretically have several master interfaces pointing to several CPU
    ports of the same switch fabric.
    
    Change the master interface's dsa_ptr for the CPU dsa_port pointer.
    This is a step towards supporting multiple CPU ports.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index b71e3bb478e4..62302558f38c 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -438,7 +438,7 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 	 * sent to the tag format's receive function.
 	 */
 	wmb();
-	dst->cpu_dp->netdev->dsa_ptr = dst;
+	dst->cpu_dp->netdev->dsa_ptr = dst->cpu_dp;
 
 	err = dsa_master_ethtool_setup(dst->cpu_dp->netdev);
 	if (err)

commit 3e41f93b358a8800194b87995ad076fc50919719
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Sep 29 17:19:19 2017 -0400

    net: dsa: prepare master receive hot path
    
    In preparation to make DSA master devices point to their corresponding
    CPU port instead of the whole tree, add copies of dst and rcv in the
    dsa_port structure so that we keep fast access in the receive hot path.
    
    Also keep the copies at the beginning of the dsa_port structure in order
    to ensure they are available in cacheline 1.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 9eac4726dc0c..b71e3bb478e4 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -524,7 +524,11 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 
 	dst->cpu_dp->tag_ops = tag_ops;
 	dst->tag_ops = tag_ops;
+
+	/* Make a few copies for faster access in master receive hot path */
+	dst->cpu_dp->rcv = dst->cpu_dp->tag_ops->rcv;
 	dst->rcv = dst->tag_ops->rcv;
+	dst->cpu_dp->dst = dst;
 
 	return 0;
 }

commit 152402483ed75b167d5628d414e876ffa7a6d4c4
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Sep 29 17:19:18 2017 -0400

    net: dsa: add tagging ops to port
    
    The DSA tagging protocol operations are specific to each CPU port,
    thus the dsa_device_ops pointer belongs to the dsa_port structure.
    
    >From now on assign a slave's xmit copy from its CPU port tagging
    operations. This will ease the future support for multiple CPU ports.
    
    Also keep the tag_ops at the beginning of the dsa_port structure so that
    we ensure copies for hot path are in cacheline 1.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 6a10c5c1639f..9eac4726dc0c 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -522,6 +522,7 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 		return PTR_ERR(tag_ops);
 	}
 
+	dst->cpu_dp->tag_ops = tag_ops;
 	dst->tag_ops = tag_ops;
 	dst->rcv = dst->tag_ops->rcv;
 

commit 62fc95876298987c35e9fb10badd467f4787aae7
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Sep 29 17:19:17 2017 -0400

    net: dsa: use temporary dsa_device_ops variable
    
    When resolving the DSA tagging protocol used by a CPU switch, use a
    temporary "tag_ops" variable to store the dsa_device_ops instead of
    using directly dst->tag_ops. This will make the future patches moving
    this pointer around easier to read.
    
    There is no functional changes.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index dcccaebde708..6a10c5c1639f 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -485,6 +485,7 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 			 struct dsa_switch_tree *dst,
 			 struct dsa_switch *ds)
 {
+	const struct dsa_device_ops *tag_ops;
 	enum dsa_tag_protocol tag_protocol;
 	struct net_device *ethernet_dev;
 	struct device_node *ethernet;
@@ -514,13 +515,14 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 	ds->cpu_port_mask |= BIT(index);
 
 	tag_protocol = ds->ops->get_tag_protocol(ds);
-	dst->tag_ops = dsa_resolve_tag_protocol(tag_protocol);
-	if (IS_ERR(dst->tag_ops)) {
+	tag_ops = dsa_resolve_tag_protocol(tag_protocol);
+	if (IS_ERR(tag_ops)) {
 		dev_warn(ds->dev, "No tagger for this switch\n");
 		ds->cpu_port_mask &= ~BIT(index);
-		return PTR_ERR(dst->tag_ops);
+		return PTR_ERR(tag_ops);
 	}
 
+	dst->tag_ops = tag_ops;
 	dst->rcv = dst->tag_ops->rcv;
 
 	return 0;

commit f2f2356685bcaf1063859356fc65a5ac808b1382
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Tue Sep 19 11:57:00 2017 -0400

    net: dsa: move master ethtool code
    
    DSA overrides the master device ethtool ops, so that it can inject stats
    from its dedicated switch CPU port as well.
    
    The related code is currently split in dsa.c and slave.c, but it only
    scopes the master net device. Move it to a new master.c DSA core file.
    
    This file will be later extented with master net device specific code.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 032f8bc3e788..dcccaebde708 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -440,7 +440,7 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 	wmb();
 	dst->cpu_dp->netdev->dsa_ptr = dst;
 
-	err = dsa_cpu_port_ethtool_setup(dst->cpu_dp);
+	err = dsa_master_ethtool_setup(dst->cpu_dp->netdev);
 	if (err)
 		return err;
 
@@ -457,7 +457,7 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 	if (!dst->applied)
 		return;
 
-	dsa_cpu_port_ethtool_restore(dst->cpu_dp);
+	dsa_master_ethtool_restore(dst->cpu_dp->netdev);
 
 	dst->cpu_dp->netdev->dsa_ptr = NULL;
 

commit 1943563dfd4b3a1f9dc102f056813112d29bb60f
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Tue Sep 19 11:56:59 2017 -0400

    net: dsa: setup master ethtool after dsa_ptr
    
    DSA overrides the master's ethtool ops so that we can inject its CPU
    port's statistics. Because of that, we need to setup the ethtool ops
    after the master's dsa_ptr pointer has been assigned, not before.
    
    This patch setups the ethtool ops after dsa_ptr is assigned, and
    restores them before it gets cleared.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index bd19304f862f..032f8bc3e788 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -433,16 +433,17 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 			return err;
 	}
 
-	err = dsa_cpu_port_ethtool_setup(dst->cpu_dp);
-	if (err)
-		return err;
-
 	/* If we use a tagging format that doesn't have an ethertype
 	 * field, make sure that all packets from this point on get
 	 * sent to the tag format's receive function.
 	 */
 	wmb();
 	dst->cpu_dp->netdev->dsa_ptr = dst;
+
+	err = dsa_cpu_port_ethtool_setup(dst->cpu_dp);
+	if (err)
+		return err;
+
 	dst->applied = true;
 
 	return 0;
@@ -456,6 +457,8 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 	if (!dst->applied)
 		return;
 
+	dsa_cpu_port_ethtool_restore(dst->cpu_dp);
+
 	dst->cpu_dp->netdev->dsa_ptr = NULL;
 
 	/* If we used a tagging format that doesn't have an ethertype
@@ -472,7 +475,6 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 		dsa_ds_unapply(dst, ds);
 	}
 
-	dsa_cpu_port_ethtool_restore(dst->cpu_dp);
 	dst->cpu_dp = NULL;
 
 	pr_info("DSA: tree %d unapplied\n", dst->tree);

commit cd8d7dd41bfddaa02e34db35abfab14ce4584dee
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Tue Sep 19 11:56:58 2017 -0400

    net: dsa: setup master ethtool unconditionally
    
    When a DSA switch tree is meant to be applied, it already has a CPU
    port. Thus remove the condition of dst->cpu_dp.
    
    Moreover, the next lines access dst->cpu_dp unconditionally.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 873af0108e24..bd19304f862f 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -433,11 +433,9 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 			return err;
 	}
 
-	if (dst->cpu_dp) {
-		err = dsa_cpu_port_ethtool_setup(dst->cpu_dp);
-		if (err)
-			return err;
-	}
+	err = dsa_cpu_port_ethtool_setup(dst->cpu_dp);
+	if (err)
+		return err;
 
 	/* If we use a tagging format that doesn't have an ethertype
 	 * field, make sure that all packets from this point on get
@@ -474,10 +472,8 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 		dsa_ds_unapply(dst, ds);
 	}
 
-	if (dst->cpu_dp) {
-		dsa_cpu_port_ethtool_restore(dst->cpu_dp);
-		dst->cpu_dp = NULL;
-	}
+	dsa_cpu_port_ethtool_restore(dst->cpu_dp);
+	dst->cpu_dp = NULL;
 
 	pr_info("DSA: tree %d unapplied\n", dst->tree);
 	dst->applied = false;

commit 6026e043d09012c6269f9a96a808d52d9c498224
Merge: 4cc5b44b29a9 138e4ad67afd
Author: David S. Miller <davem@davemloft.net>
Date:   Fri Sep 1 17:42:05 2017 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Three cases of simple overlapping changes.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit c7848399ec7612c2fa4dc0c2eeb9e0b89d00afef
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Aug 28 17:10:51 2017 -0700

    net: dsa: Don't dereference dst->cpu_dp->netdev
    
    If we do not have a master network device attached dst->cpu_dp will be
    NULL and accessing cpu_dp->netdev will create a trace similar to the one
    below. The correct check is on dst->cpu_dp period.
    
    [    1.004650] DSA: switch 0 0 parsed
    [    1.008078] Unable to handle kernel NULL pointer dereference at
    virtual address 00000010
    [    1.016195] pgd = c0003000
    [    1.018918] [00000010] *pgd=80000000004003, *pmd=00000000
    [    1.024349] Internal error: Oops: 206 [#1] SMP ARM
    [    1.029157] Modules linked in:
    [    1.032228] CPU: 0 PID: 1 Comm: swapper/0 Not tainted
    4.13.0-rc6-00071-g45b45afab9bd-dirty #7
    [    1.040772] Hardware name: Broadcom STB (Flattened Device Tree)
    [    1.046704] task: ee08f840 task.stack: ee090000
    [    1.051258] PC is at dsa_register_switch+0x5e0/0x9dc
    [    1.056234] LR is at dsa_register_switch+0x5d0/0x9dc
    [    1.061211] pc : [<c08fb28c>]    lr : [<c08fb27c>]    psr: 60000213
    [    1.067491] sp : ee091d88  ip : 00000000  fp : 0000000c
    [    1.072728] r10: 00000000  r9 : 00000001  r8 : ee208010
    [    1.077965] r7 : ee2b57b0  r6 : ee2b5780  r5 : 00000000  r4 :
    ee208e0c
    [    1.084506] r3 : 00000000  r2 : 00040d00  r1 : 2d1b2000  r0 :
    00000016
    [    1.091050] Flags: nZCv  IRQs on  FIQs on  Mode SVC_32  ISA ARM
    Segment user
    [    1.098199] Control: 32c5387d  Table: 00003000  DAC: fffffffd
    [    1.103957] Process swapper/0 (pid: 1, stack limit = 0xee090210)
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Fixes: 6d3c8c0dd88a ("net: dsa: Remove master_netdev and use dst->cpu_dp->netdev")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index c442051d5a55..20bc9c56fca0 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -577,7 +577,7 @@ static int dsa_dst_parse(struct dsa_switch_tree *dst)
 			return err;
 	}
 
-	if (!dst->cpu_dp->netdev) {
+	if (!dst->cpu_dp) {
 		pr_warn("Tree has no master device\n");
 		return -EINVAL;
 	}

commit 4cfbf09cf97f265c82f48ca2bd7ea704b6a21a90
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Sat Aug 5 16:20:19 2017 -0400

    net: dsa: remove useless args of dsa_slave_create
    
    dsa_slave_create currently takes 4 arguments while it only needs the
    related dsa_port and its name. Remove all other arguments.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 2a0120493cf1..cceaa4dd9f53 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -275,7 +275,7 @@ static int dsa_user_port_apply(struct dsa_port *port)
 	if (!name)
 		name = "eth%d";
 
-	err = dsa_slave_create(ds, ds->dev, port->index, name);
+	err = dsa_slave_create(port, name);
 	if (err) {
 		dev_warn(ds->dev, "Failed to create slave %d: %d\n",
 			 port->index, err);

commit 47d0dcc35412feb354aace4c5dcc07c03cb4ccb0
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Sat Aug 5 16:20:18 2017 -0400

    net: dsa: remove useless args of dsa_cpu_dsa_setup
    
    dsa_cpu_dsa_setup currently takes 4 arguments but they are all available
    from the dsa_port argument. Remove all others.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index c442051d5a55..2a0120493cf1 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -219,7 +219,7 @@ static int dsa_dsa_port_apply(struct dsa_port *port)
 	struct dsa_switch *ds = port->ds;
 	int err;
 
-	err = dsa_cpu_dsa_setup(ds, ds->dev, port, port->index);
+	err = dsa_cpu_dsa_setup(port);
 	if (err) {
 		dev_warn(ds->dev, "Failed to setup dsa port %d: %d\n",
 			 port->index, err);
@@ -243,7 +243,7 @@ static int dsa_cpu_port_apply(struct dsa_port *port)
 	struct dsa_switch *ds = port->ds;
 	int err;
 
-	err = dsa_cpu_dsa_setup(ds, ds->dev, port, port->index);
+	err = dsa_cpu_dsa_setup(port);
 	if (err) {
 		dev_warn(ds->dev, "Failed to setup cpu port %d: %d\n",
 			 port->index, err);

commit 9f9e772da2db279c8d8c9206d271b8009c9093f4
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Jul 24 10:49:23 2017 -0700

    net: dsa: Initialize ds->cpu_port_mask earlier
    
    The mt7530 driver has its dsa_switch_ops::get_tag_protocol function
    check ds->cpu_port_mask to issue a warning in case the configured CPU
    port is not capable of supporting tags.
    
    After commit 14be36c2c96c ("net: dsa: Initialize all CPU and enabled
    ports masks in dsa_ds_parse()") we slightly re-arranged the
    initialization such that this was no longer working. Just make sure that
    ds->cpu_port_mask is set prior to the first call to get_tag_protocol,
    thus restoring the expected contract. In case of error, the CPU port bit
    is cleared.
    
    Fixes: 14be36c2c96c ("net: dsa: Initialize all CPU and enabled ports masks in dsa_ds_parse()")
    Reported-by: Sean Wang <sean.wang@mediatek.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 56e46090526b..c442051d5a55 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -509,21 +509,22 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 		dst->cpu_dp->netdev = ethernet_dev;
 	}
 
+	/* Initialize cpu_port_mask now for drv->setup()
+	 * to have access to a correct value, just like what
+	 * net/dsa/dsa.c::dsa_switch_setup_one does.
+	 */
+	ds->cpu_port_mask |= BIT(index);
+
 	tag_protocol = ds->ops->get_tag_protocol(ds);
 	dst->tag_ops = dsa_resolve_tag_protocol(tag_protocol);
 	if (IS_ERR(dst->tag_ops)) {
 		dev_warn(ds->dev, "No tagger for this switch\n");
+		ds->cpu_port_mask &= ~BIT(index);
 		return PTR_ERR(dst->tag_ops);
 	}
 
 	dst->rcv = dst->tag_ops->rcv;
 
-	/* Initialize cpu_port_mask now for drv->setup()
-	 * to have access to a correct value, just like what
-	 * net/dsa/dsa.c::dsa_switch_setup_one does.
-	 */
-	ds->cpu_port_mask |= BIT(index);
-
 	return 0;
 }
 

commit e4b7778769c25f773c514dcc99afcf7c74a9b3e4
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Thu Jun 15 15:06:54 2017 -0400

    net: dsa: assign default CPU port to all ports
    
    The current code only assigns the default cpu_dp to all user ports of
    the switch to which the CPU port belongs. The user ports of the other
    switches of the fabric thus don't have a default CPU port.
    
    This patch fixes this by assigning the cpu_dp of all user ports of all
    switches of the fabric when the tree is fully parsed.
    
    Fixes: a29342e73911 ("net: dsa: Associate slave network device with CPU port")
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 52af8401af07..56e46090526b 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -490,8 +490,6 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 	enum dsa_tag_protocol tag_protocol;
 	struct net_device *ethernet_dev;
 	struct device_node *ethernet;
-	struct dsa_port *p;
-	unsigned int i;
 
 	if (port->dn) {
 		ethernet = of_parse_phandle(port->dn, "ethernet", 0);
@@ -509,15 +507,6 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 	if (!dst->cpu_dp) {
 		dst->cpu_dp = port;
 		dst->cpu_dp->netdev = ethernet_dev;
-
-		for (i = 0; i < ds->num_ports; i++) {
-			p = &ds->ports[i];
-			if (!dsa_port_is_valid(p) ||
-			    i == index)
-				continue;
-
-			p->cpu_dp = port;
-		}
 	}
 
 	tag_protocol = ds->ops->get_tag_protocol(ds);
@@ -572,7 +561,9 @@ static int dsa_ds_parse(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 static int dsa_dst_parse(struct dsa_switch_tree *dst)
 {
 	struct dsa_switch *ds;
+	struct dsa_port *dp;
 	u32 index;
+	int port;
 	int err;
 
 	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
@@ -590,6 +581,23 @@ static int dsa_dst_parse(struct dsa_switch_tree *dst)
 		return -EINVAL;
 	}
 
+	/* Assign the default CPU port to all ports of the fabric */
+	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
+		ds = dst->ds[index];
+		if (!ds)
+			continue;
+
+		for (port = 0; port < ds->num_ports; port++) {
+			dp = &ds->ports[port];
+			if (!dsa_port_is_valid(dp) ||
+			    dsa_port_is_dsa(dp) ||
+			    dsa_port_is_cpu(dp))
+				continue;
+
+			dp->cpu_dp = dst->cpu_dp;
+		}
+	}
+
 	pr_info("DSA: tree %d parsed\n", dst->tree);
 
 	return 0;

commit a29342e739115211615acc33616e547b2d3e0663
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jun 13 13:27:21 2017 -0700

    net: dsa: Associate slave network device with CPU port
    
    In preparation for supporting multiple CPU ports with DSA, have the
    dsa_port structure know which CPU it is associated with. This will be
    important in order to make sure the correct CPU is used for transmission
    of the frames. If not for functional reasons, for performance (e.g: load
    balancing) and forwarding decisions.
    
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index ab48c4f989da..52af8401af07 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -490,6 +490,8 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 	enum dsa_tag_protocol tag_protocol;
 	struct net_device *ethernet_dev;
 	struct device_node *ethernet;
+	struct dsa_port *p;
+	unsigned int i;
 
 	if (port->dn) {
 		ethernet = of_parse_phandle(port->dn, "ethernet", 0);
@@ -507,6 +509,15 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 	if (!dst->cpu_dp) {
 		dst->cpu_dp = port;
 		dst->cpu_dp->netdev = ethernet_dev;
+
+		for (i = 0; i < ds->num_ports; i++) {
+			p = &ds->ports[i];
+			if (!dsa_port_is_valid(p) ||
+			    i == index)
+				continue;
+
+			p->cpu_dp = port;
+		}
 	}
 
 	tag_protocol = ds->ops->get_tag_protocol(ds);

commit 6d3c8c0dd88a5ffc7e3695997641e4b6d4c11065
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jun 13 13:27:19 2017 -0700

    net: dsa: Remove master_netdev and use dst->cpu_dp->netdev
    
    In preparation for supporting multiple CPU ports, remove
    dst->master_netdev and ds->master_netdev and replace them with only one
    instance of the common object we have for a port: struct
    dsa_port::netdev. ds->master_netdev is currently write only and would be
    helpful in the case where we have two switches, both with CPU ports, and
    also connected within each other, which the multi-CPU port patch series
    would address.
    
    While at it, introduce a helper function used in net/dsa/slave.c to
    immediately get a reference on the master network device called
    dsa_master_netdev().
    
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index f88e1dddb74a..ab48c4f989da 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -337,7 +337,7 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 		return err;
 
 	if (ds->ops->set_addr) {
-		err = ds->ops->set_addr(ds, dst->master_netdev->dev_addr);
+		err = ds->ops->set_addr(ds, dst->cpu_dp->netdev->dev_addr);
 		if (err < 0)
 			return err;
 	}
@@ -444,7 +444,7 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 	 * sent to the tag format's receive function.
 	 */
 	wmb();
-	dst->master_netdev->dsa_ptr = dst;
+	dst->cpu_dp->netdev->dsa_ptr = dst;
 	dst->applied = true;
 
 	return 0;
@@ -458,7 +458,7 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 	if (!dst->applied)
 		return;
 
-	dst->master_netdev->dsa_ptr = NULL;
+	dst->cpu_dp->netdev->dsa_ptr = NULL;
 
 	/* If we used a tagging format that doesn't have an ethertype
 	 * field, make sure that all packets from this point get sent
@@ -504,14 +504,10 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 	if (!ethernet_dev)
 		return -EPROBE_DEFER;
 
-	if (!ds->master_netdev)
-		ds->master_netdev = ethernet_dev;
-
-	if (!dst->master_netdev)
-		dst->master_netdev = ethernet_dev;
-
-	if (!dst->cpu_dp)
+	if (!dst->cpu_dp) {
 		dst->cpu_dp = port;
+		dst->cpu_dp->netdev = ethernet_dev;
+	}
 
 	tag_protocol = ds->ops->get_tag_protocol(ds);
 	dst->tag_ops = dsa_resolve_tag_protocol(tag_protocol);
@@ -578,7 +574,7 @@ static int dsa_dst_parse(struct dsa_switch_tree *dst)
 			return err;
 	}
 
-	if (!dst->master_netdev) {
+	if (!dst->cpu_dp->netdev) {
 		pr_warn("Tree has no master device\n");
 		return -EINVAL;
 	}

commit 216fe8f021e33c36e3b27c49c9f1951f6b037d7f
Merge: 9747e2313838 b29794ec95c6
Author: David S. Miller <davem@davemloft.net>
Date:   Tue Jun 6 22:20:08 2017 -0400

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Just some simple overlapping changes in marvell PHY driver
    and the DSA core code.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit b07ac9894644202614ca87c69f3f45e424a82fef
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Jun 2 22:05:23 2017 -0700

    net: dsa: Fix stale cpu_switch reference after unbind then bind
    
    Commit 9520ed8fb841 ("net: dsa: use cpu_switch instead of ds[0]")
    replaced the use of dst->ds[0] with dst->cpu_switch since that is
    functionally equivalent, however, we can now run into an use after free
    scenario after unbinding then rebinding the switch driver.
    
    The use after free happens because we do correctly initialize
    dst->cpu_switch the first time we probe in dsa_cpu_parse(), then we
    unbind the driver: dsa_dst_unapply() is called, and we rebind again.
    dst->cpu_switch now points to a freed "ds" structure, and so when we
    finally dereference it in dsa_cpu_port_ethtool_setup(), we oops.
    
    To fix this, simply set dst->cpu_switch to NULL in dsa_dst_unapply()
    which guarantees that we always correctly re-assign dst->cpu_switch in
    dsa_cpu_parse().
    
    Fixes: 9520ed8fb841 ("net: dsa: use cpu_switch instead of ds[0]")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 033b3bfb63dc..7796580e99ee 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -484,8 +484,10 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 		dsa_ds_unapply(dst, ds);
 	}
 
-	if (dst->cpu_switch)
+	if (dst->cpu_switch) {
 		dsa_cpu_port_ethtool_restore(dst->cpu_switch);
+		dst->cpu_switch = NULL;
+	}
 
 	pr_info("DSA: tree %d unapplied\n", dst->tree);
 	dst->applied = false;

commit 14be36c2c96cd18cfa036f230b57ea78d82a303f
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Jun 2 12:31:23 2017 -0700

    net: dsa: Initialize all CPU and enabled ports masks in dsa_ds_parse()
    
    There was no reason for duplicating the code that initializes
    ds->enabled_port_mask in both dsa_parse_ports_dn() and
    dsa_parse_ports(), instead move this to dsa_ds_parse() which is early
    enough before ops->setup() has run.
    
    While at it, we can now make dsa_is_cpu_port() check ds->cpu_port_mask
    which is a step towards being multi-CPU port capable.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 067daec644c1..cd13bb54a30c 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -250,8 +250,6 @@ static int dsa_cpu_port_apply(struct dsa_port *port)
 		return err;
 	}
 
-	ds->cpu_port_mask |= BIT(port->index);
-
 	memset(&port->devlink_port, 0, sizeof(port->devlink_port));
 	err = devlink_port_register(ds->devlink, &port->devlink_port,
 				    port->index);
@@ -522,6 +520,12 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 
 	dst->rcv = dst->tag_ops->rcv;
 
+	/* Initialize cpu_port_mask now for drv->setup()
+	 * to have access to a correct value, just like what
+	 * net/dsa/dsa.c::dsa_switch_setup_one does.
+	 */
+	ds->cpu_port_mask |= BIT(index);
+
 	return 0;
 }
 
@@ -533,14 +537,22 @@ static int dsa_ds_parse(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 
 	for (index = 0; index < ds->num_ports; index++) {
 		port = &ds->ports[index];
-		if (!dsa_port_is_valid(port))
+		if (!dsa_port_is_valid(port) ||
+		    dsa_port_is_dsa(port))
 			continue;
 
 		if (dsa_port_is_cpu(port)) {
 			err = dsa_cpu_parse(port, index, dst, ds);
 			if (err)
 				return err;
+		} else {
+			/* Initialize enabled_port_mask now for drv->setup()
+			 * to have access to a correct value, just like what
+			 * net/dsa/dsa.c::dsa_switch_setup_one does.
+			 */
+			ds->enabled_port_mask |= BIT(index);
 		}
+
 	}
 
 	pr_info("DSA: switch %d %d parsed\n", dst->tree, ds->index);
@@ -589,13 +601,6 @@ static int dsa_parse_ports_dn(struct device_node *ports, struct dsa_switch *ds)
 			return -EINVAL;
 
 		ds->ports[reg].dn = port;
-
-		/* Initialize enabled_port_mask now for ops->setup()
-		 * to have access to a correct value, just like what
-		 * net/dsa/dsa.c::dsa_switch_setup_one does.
-		 */
-		if (!dsa_port_is_cpu(&ds->ports[reg]))
-			ds->enabled_port_mask |= 1 << reg;
 	}
 
 	return 0;
@@ -611,14 +616,6 @@ static int dsa_parse_ports(struct dsa_chip_data *cd, struct dsa_switch *ds)
 			continue;
 
 		ds->ports[i].name = cd->port_names[i];
-
-		/* Initialize enabled_port_mask now for drv->setup()
-		 * to have access to a correct value, just like what
-		 * net/dsa/dsa.c::dsa_switch_setup_one does.
-		 */
-		if (!dsa_port_is_cpu(&ds->ports[i]))
-			ds->enabled_port_mask |= 1 << i;
-
 		valid_name_found = true;
 	}
 

commit e41c1b5030e279c6626d3d052c3ca5ce5e2508df
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Jun 2 12:31:22 2017 -0700

    net: dsa: Consistently use dsa_port for dsa_*_port_{apply, unapply}
    
    We have all the information we need in dsa_port, so use it instead of
    repeating the same arguments over and over again.
    
    Suggested-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 7f9bf1456a65..067daec644c1 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -214,66 +214,61 @@ static int dsa_dst_complete(struct dsa_switch_tree *dst)
 	return 0;
 }
 
-static int dsa_dsa_port_apply(struct dsa_port *port, u32 index,
-			      struct dsa_switch *ds)
+static int dsa_dsa_port_apply(struct dsa_port *port)
 {
+	struct dsa_switch *ds = port->ds;
 	int err;
 
-	err = dsa_cpu_dsa_setup(ds, ds->dev, port, index);
+	err = dsa_cpu_dsa_setup(ds, ds->dev, port, port->index);
 	if (err) {
 		dev_warn(ds->dev, "Failed to setup dsa port %d: %d\n",
-			 index, err);
+			 port->index, err);
 		return err;
 	}
 
-	memset(&ds->ports[index].devlink_port, 0,
-	       sizeof(ds->ports[index].devlink_port));
+	memset(&port->devlink_port, 0, sizeof(port->devlink_port));
 
-	return devlink_port_register(ds->devlink,
-				     &ds->ports[index].devlink_port,
-				     index);
+	return devlink_port_register(ds->devlink, &port->devlink_port,
+				     port->index);
 }
 
-static void dsa_dsa_port_unapply(struct dsa_port *port, u32 index,
-				 struct dsa_switch *ds)
+static void dsa_dsa_port_unapply(struct dsa_port *port)
 {
-	devlink_port_unregister(&ds->ports[index].devlink_port);
+	devlink_port_unregister(&port->devlink_port);
 	dsa_cpu_dsa_destroy(port);
 }
 
-static int dsa_cpu_port_apply(struct dsa_port *port, u32 index,
-			      struct dsa_switch *ds)
+static int dsa_cpu_port_apply(struct dsa_port *port)
 {
+	struct dsa_switch *ds = port->ds;
 	int err;
 
-	err = dsa_cpu_dsa_setup(ds, ds->dev, port, index);
+	err = dsa_cpu_dsa_setup(ds, ds->dev, port, port->index);
 	if (err) {
 		dev_warn(ds->dev, "Failed to setup cpu port %d: %d\n",
-			 index, err);
+			 port->index, err);
 		return err;
 	}
 
-	ds->cpu_port_mask |= BIT(index);
+	ds->cpu_port_mask |= BIT(port->index);
 
-	memset(&ds->ports[index].devlink_port, 0,
-	       sizeof(ds->ports[index].devlink_port));
-	err = devlink_port_register(ds->devlink, &ds->ports[index].devlink_port,
-				    index);
+	memset(&port->devlink_port, 0, sizeof(port->devlink_port));
+	err = devlink_port_register(ds->devlink, &port->devlink_port,
+				    port->index);
 	return err;
 }
 
-static void dsa_cpu_port_unapply(struct dsa_port *port, u32 index,
-				 struct dsa_switch *ds)
+static void dsa_cpu_port_unapply(struct dsa_port *port)
 {
-	devlink_port_unregister(&ds->ports[index].devlink_port);
+	devlink_port_unregister(&port->devlink_port);
 	dsa_cpu_dsa_destroy(port);
-	ds->cpu_port_mask &= ~BIT(index);
+	port->ds->cpu_port_mask &= ~BIT(port->index);
 
 }
 
-static int dsa_user_port_apply(struct dsa_port *port, u32 index,
-			       struct dsa_switch *ds)
+static int dsa_user_port_apply(struct dsa_port *port)
 {
+	struct dsa_switch *ds = port->ds;
 	const char *name = port->name;
 	int err;
 
@@ -282,35 +277,32 @@ static int dsa_user_port_apply(struct dsa_port *port, u32 index,
 	if (!name)
 		name = "eth%d";
 
-	err = dsa_slave_create(ds, ds->dev, index, name);
+	err = dsa_slave_create(ds, ds->dev, port->index, name);
 	if (err) {
 		dev_warn(ds->dev, "Failed to create slave %d: %d\n",
-			 index, err);
-		ds->ports[index].netdev = NULL;
+			 port->index, err);
+		port->netdev = NULL;
 		return err;
 	}
 
-	memset(&ds->ports[index].devlink_port, 0,
-	       sizeof(ds->ports[index].devlink_port));
-	err = devlink_port_register(ds->devlink, &ds->ports[index].devlink_port,
-				    index);
+	memset(&port->devlink_port, 0, sizeof(port->devlink_port));
+	err = devlink_port_register(ds->devlink, &port->devlink_port,
+				    port->index);
 	if (err)
 		return err;
 
-	devlink_port_type_eth_set(&ds->ports[index].devlink_port,
-				  ds->ports[index].netdev);
+	devlink_port_type_eth_set(&port->devlink_port, port->netdev);
 
 	return 0;
 }
 
-static void dsa_user_port_unapply(struct dsa_port *port, u32 index,
-				  struct dsa_switch *ds)
+static void dsa_user_port_unapply(struct dsa_port *port)
 {
-	devlink_port_unregister(&ds->ports[index].devlink_port);
-	if (ds->ports[index].netdev) {
-		dsa_slave_destroy(ds->ports[index].netdev);
-		ds->ports[index].netdev = NULL;
-		ds->enabled_port_mask &= ~(1 << index);
+	devlink_port_unregister(&port->devlink_port);
+	if (port->netdev) {
+		dsa_slave_destroy(port->netdev);
+		port->netdev = NULL;
+		port->ds->enabled_port_mask &= ~(1 << port->index);
 	}
 }
 
@@ -370,20 +362,20 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 			continue;
 
 		if (dsa_port_is_dsa(port)) {
-			err = dsa_dsa_port_apply(port, index, ds);
+			err = dsa_dsa_port_apply(port);
 			if (err)
 				return err;
 			continue;
 		}
 
 		if (dsa_port_is_cpu(port)) {
-			err = dsa_cpu_port_apply(port, index, ds);
+			err = dsa_cpu_port_apply(port);
 			if (err)
 				return err;
 			continue;
 		}
 
-		err = dsa_user_port_apply(port, index, ds);
+		err = dsa_user_port_apply(port);
 		if (err)
 			continue;
 	}
@@ -402,16 +394,16 @@ static void dsa_ds_unapply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 			continue;
 
 		if (dsa_port_is_dsa(port)) {
-			dsa_dsa_port_unapply(port, index, ds);
+			dsa_dsa_port_unapply(port);
 			continue;
 		}
 
 		if (dsa_port_is_cpu(port)) {
-			dsa_cpu_port_unapply(port, index, ds);
+			dsa_cpu_port_unapply(port);
 			continue;
 		}
 
-		dsa_user_port_unapply(port, index, ds);
+		dsa_user_port_unapply(port);
 	}
 
 	if (ds->slave_mii_bus && ds->ops->phy_read)

commit 937c7df85ce7ce6b2319894f6ad3376f15dff186
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Fri Jun 2 12:31:21 2017 -0700

    net: dsa: Pass dsa_port reference to ethtool setup/restore
    
    We do not need to have a reference to a dsa_switch, instead we should
    pass a reference to a CPU dsa_port, change that. This is a preliminary
    change to better support multiple CPU ports.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 21b44a9828f6..7f9bf1456a65 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -444,7 +444,7 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 	}
 
 	if (dst->cpu_dp) {
-		err = dsa_cpu_port_ethtool_setup(dst->cpu_dp->ds);
+		err = dsa_cpu_port_ethtool_setup(dst->cpu_dp);
 		if (err)
 			return err;
 	}
@@ -485,7 +485,7 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 	}
 
 	if (dst->cpu_dp)
-		dsa_cpu_port_ethtool_restore(dst->cpu_dp->ds);
+		dsa_cpu_port_ethtool_restore(dst->cpu_dp);
 
 	pr_info("DSA: tree %d unapplied\n", dst->tree);
 	dst->applied = false;

commit 02f840cbc9fa9ee147d882edb96b203999c3ac62
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Thu Jun 1 16:07:12 2017 -0400

    net: dsa: do not cast dst
    
    dsa_ptr is not a void pointer anymore since Nov 2011, as of cf50dcc24f82
    ("dsa: Change dsa_uses_{dsa, trailer}_tags() into inline functions"),
    but an explicit dsa_switch_tree pointer, thus remove the (void *) cast.
    
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index c0a4576db4a2..21b44a9828f6 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -454,7 +454,7 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 	 * sent to the tag format's receive function.
 	 */
 	wmb();
-	dst->master_netdev->dsa_ptr = (void *)dst;
+	dst->master_netdev->dsa_ptr = dst;
 	dst->applied = true;
 
 	return 0;

commit 23c9ee4934e7a79b49151d0f05c24117d69c73fe
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri May 26 18:12:51 2017 -0400

    net: dsa: remove dev arg of dsa_register_switch
    
    The current dsa_register_switch function takes a useless struct device
    pointer argument, which always equals ds->dev.
    
    Drivers either call it with ds->dev, or with the same device pointer
    passed to dsa_switch_alloc, which ends up being assigned to ds->dev.
    
    This patch removes the second argument of the dsa_register_switch and
    _dsa_register_switch functions.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 4301f52e4f5a..c0a4576db4a2 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -686,10 +686,10 @@ static struct device_node *dsa_get_ports(struct dsa_switch *ds,
 	return ports;
 }
 
-static int _dsa_register_switch(struct dsa_switch *ds, struct device *dev)
+static int _dsa_register_switch(struct dsa_switch *ds)
 {
-	struct dsa_chip_data *pdata = dev->platform_data;
-	struct device_node *np = dev->of_node;
+	struct dsa_chip_data *pdata = ds->dev->platform_data;
+	struct device_node *np = ds->dev->of_node;
 	struct dsa_switch_tree *dst;
 	struct device_node *ports;
 	u32 tree, index;
@@ -803,12 +803,12 @@ struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
 }
 EXPORT_SYMBOL_GPL(dsa_switch_alloc);
 
-int dsa_register_switch(struct dsa_switch *ds, struct device *dev)
+int dsa_register_switch(struct dsa_switch *ds)
 {
 	int err;
 
 	mutex_lock(&dsa2_mutex);
-	err = _dsa_register_switch(ds, dev);
+	err = _dsa_register_switch(ds);
 	mutex_unlock(&dsa2_mutex);
 
 	return err;

commit ea5dd34be1cfb2400587a24d1de75e538e77ce74
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Wed May 17 15:46:03 2017 -0400

    net: dsa: include dsa.h only once
    
    The public include/net/dsa.h file is meant for DSA drivers, while all
    DSA core files share a common private header net/dsa/dsa_priv.h file.
    
    Ensure that dsa_priv.h is the only DSA core file to include net/dsa.h,
    and add a new line to separate absolute and relative headers at the same
    time.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 2ac62349ba12..4301f52e4f5a 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -18,7 +18,7 @@
 #include <linux/rtnetlink.h>
 #include <linux/of.h>
 #include <linux/of_net.h>
-#include <net/dsa.h>
+
 #include "dsa_priv.h"
 
 static LIST_HEAD(dsa_switch_trees);

commit 8b0d3ea555876533b6aa61479335be2c9bdb47e7
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Tue May 16 14:10:33 2017 -0400

    net: dsa: store CPU port pointer in the tree
    
    A dsa_switch_tree instance holds a dsa_switch pointer and a port index
    to identify the switch port to which the CPU is attached.
    
    Now that the DSA layer has a dsa_port structure to hold this data, use
    it to point the switch CPU port.
    
    This patch simply substitutes s/dst->cpu_switch/dst->cpu_dp->ds/ and
    s/dst->cpu_port/dst->cpu_dp->index/.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 033b3bfb63dc..2ac62349ba12 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -443,8 +443,8 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 			return err;
 	}
 
-	if (dst->cpu_switch) {
-		err = dsa_cpu_port_ethtool_setup(dst->cpu_switch);
+	if (dst->cpu_dp) {
+		err = dsa_cpu_port_ethtool_setup(dst->cpu_dp->ds);
 		if (err)
 			return err;
 	}
@@ -484,8 +484,8 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 		dsa_ds_unapply(dst, ds);
 	}
 
-	if (dst->cpu_switch)
-		dsa_cpu_port_ethtool_restore(dst->cpu_switch);
+	if (dst->cpu_dp)
+		dsa_cpu_port_ethtool_restore(dst->cpu_dp->ds);
 
 	pr_info("DSA: tree %d unapplied\n", dst->tree);
 	dst->applied = false;
@@ -518,10 +518,8 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 	if (!dst->master_netdev)
 		dst->master_netdev = ethernet_dev;
 
-	if (!dst->cpu_switch) {
-		dst->cpu_switch = ds;
-		dst->cpu_port = index;
-	}
+	if (!dst->cpu_dp)
+		dst->cpu_dp = port;
 
 	tag_protocol = ds->ops->get_tag_protocol(ds);
 	dst->tag_ops = dsa_resolve_tag_protocol(tag_protocol);

commit 96567d5dacf47fd628bc3115c8a7d81866674cd3
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Tue Mar 28 23:45:07 2017 +0200

    net: dsa: dsa2: Add basic support of devlink
    
    Register the switch and its ports with devlink.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Tested-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index d039c8d7adfd..033b3bfb63dc 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -24,6 +24,9 @@
 static LIST_HEAD(dsa_switch_trees);
 static DEFINE_MUTEX(dsa2_mutex);
 
+static const struct devlink_ops dsa_devlink_ops = {
+};
+
 static struct dsa_switch_tree *dsa_get_dst(u32 tree)
 {
 	struct dsa_switch_tree *dst;
@@ -223,12 +226,18 @@ static int dsa_dsa_port_apply(struct dsa_port *port, u32 index,
 		return err;
 	}
 
-	return 0;
+	memset(&ds->ports[index].devlink_port, 0,
+	       sizeof(ds->ports[index].devlink_port));
+
+	return devlink_port_register(ds->devlink,
+				     &ds->ports[index].devlink_port,
+				     index);
 }
 
 static void dsa_dsa_port_unapply(struct dsa_port *port, u32 index,
 				 struct dsa_switch *ds)
 {
+	devlink_port_unregister(&ds->ports[index].devlink_port);
 	dsa_cpu_dsa_destroy(port);
 }
 
@@ -246,12 +255,17 @@ static int dsa_cpu_port_apply(struct dsa_port *port, u32 index,
 
 	ds->cpu_port_mask |= BIT(index);
 
-	return 0;
+	memset(&ds->ports[index].devlink_port, 0,
+	       sizeof(ds->ports[index].devlink_port));
+	err = devlink_port_register(ds->devlink, &ds->ports[index].devlink_port,
+				    index);
+	return err;
 }
 
 static void dsa_cpu_port_unapply(struct dsa_port *port, u32 index,
 				 struct dsa_switch *ds)
 {
+	devlink_port_unregister(&ds->ports[index].devlink_port);
 	dsa_cpu_dsa_destroy(port);
 	ds->cpu_port_mask &= ~BIT(index);
 
@@ -276,12 +290,23 @@ static int dsa_user_port_apply(struct dsa_port *port, u32 index,
 		return err;
 	}
 
+	memset(&ds->ports[index].devlink_port, 0,
+	       sizeof(ds->ports[index].devlink_port));
+	err = devlink_port_register(ds->devlink, &ds->ports[index].devlink_port,
+				    index);
+	if (err)
+		return err;
+
+	devlink_port_type_eth_set(&ds->ports[index].devlink_port,
+				  ds->ports[index].netdev);
+
 	return 0;
 }
 
 static void dsa_user_port_unapply(struct dsa_port *port, u32 index,
 				  struct dsa_switch *ds)
 {
+	devlink_port_unregister(&ds->ports[index].devlink_port);
 	if (ds->ports[index].netdev) {
 		dsa_slave_destroy(ds->ports[index].netdev);
 		ds->ports[index].netdev = NULL;
@@ -302,6 +327,17 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	 */
 	ds->phys_mii_mask = ds->enabled_port_mask;
 
+	/* Add the switch to devlink before calling setup, so that setup can
+	 * add dpipe tables
+	 */
+	ds->devlink = devlink_alloc(&dsa_devlink_ops, 0);
+	if (!ds->devlink)
+		return -ENOMEM;
+
+	err = devlink_register(ds->devlink, ds->dev);
+	if (err)
+		return err;
+
 	err = ds->ops->setup(ds);
 	if (err < 0)
 		return err;
@@ -382,6 +418,13 @@ static void dsa_ds_unapply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 		mdiobus_unregister(ds->slave_mii_bus);
 
 	dsa_switch_unregister_notifier(ds);
+
+	if (ds->devlink) {
+		devlink_unregister(ds->devlink);
+		devlink_free(ds->devlink);
+		ds->devlink = NULL;
+	}
+
 }
 
 static int dsa_dst_apply(struct dsa_switch_tree *dst)

commit c6e970a04bdceb7ef1fdbac6be3bd4cd0a0a02bd
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Tue Mar 28 23:45:06 2017 +0200

    net: break include loop netdevice.h, dsa.h, devlink.h
    
    There is an include loop between netdevice.h, dsa.h, devlink.h because
    of NETDEV_ALIGN, making it impossible to use devlink structures in
    dsa.h.
    
    Break this loop by taking dsa.h out of netdevice.h, add a forward
    declaration of dsa_switch_tree and netdev_set_default_ethtool_ops()
    function, which is what netdevice.h requires.
    
    No longer having dsa.h in netdevice.h means the includes in dsa.h no
    longer get included. This breaks a few other files which depend on
    these includes. Add these directly in the affected file.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 737be6470c7f..d039c8d7adfd 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -13,11 +13,12 @@
 #include <linux/device.h>
 #include <linux/err.h>
 #include <linux/list.h>
+#include <linux/netdevice.h>
 #include <linux/slab.h>
 #include <linux/rtnetlink.h>
-#include <net/dsa.h>
 #include <linux/of.h>
 #include <linux/of_net.h>
+#include <net/dsa.h>
 #include "dsa_priv.h"
 
 static LIST_HEAD(dsa_switch_trees);

commit 35eeacf1820a08305c2b0960febfa190f5a6dd63
Merge: bed45f79a2af 1ee18329fae9
Author: David S. Miller <davem@davemloft.net>
Date:   Sat Feb 11 02:31:11 2017 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net

commit 382e1eea2d983cd2343482c6a638f497bb44a636
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Feb 7 23:10:13 2017 -0800

    net: dsa: Do not destroy invalid network devices
    
    dsa_slave_create() can fail, and dsa_user_port_unapply() will properly check
    for the network device not being NULL before attempting to destroy it. We were
    not setting the slave network device as NULL if dsa_slave_create() failed, so
    we would later on be calling dsa_slave_destroy() on a now free'd and
    unitialized network device, causing crashes in dsa_slave_destroy().
    
    Fixes: 83c0afaec7b7 ("net: dsa: Add new binding implementation")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index da3862124545..0f99297b2fb3 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -273,6 +273,7 @@ static int dsa_user_port_apply(struct device_node *port, u32 index,
 	if (err) {
 		dev_warn(ds->dev, "Failed to create slave %d: %d\n",
 			 index, err);
+		ds->ports[index].netdev = NULL;
 		return err;
 	}
 

commit 71e0bbde0d88047f66b25721f69a441d46083748
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Sat Feb 4 13:02:43 2017 -0800

    net: dsa: Add support for platform data
    
    Allow drivers to use the new DSA API with platform data. Most of the
    code in net/dsa/dsa2.c does not rely so much on device_nodes and can get
    the same information from platform_data instead.
    
    We purposely do not support distributed configurations with platform
    data, so drivers should be providing a pointer to a 'struct
    dsa_chip_data' structure if they wish to communicate per-port layout.
    
    Multiple CPUs port could potentially be supported and dsa_chip_data is
    extended to receive up to one reference to an upstream network device
    per port described by a dsa_chip_data structure.
    
    dsa_dev_to_net_device() increments the network device's reference count,
    so we intentionally call dev_put() to be consistent with the DT-enabled
    path, until we have a generic notifier based solution.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 1c546b6621ee..6f5f0a2ad256 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -78,19 +78,28 @@ static void dsa_dst_del_ds(struct dsa_switch_tree *dst,
 	kref_put(&dst->refcount, dsa_free_dst);
 }
 
+/* For platform data configurations, we need to have a valid name argument to
+ * differentiate a disabled port from an enabled one
+ */
 static bool dsa_port_is_valid(struct dsa_port *port)
 {
-	return !!port->dn;
+	return !!(port->dn || port->name);
 }
 
 static bool dsa_port_is_dsa(struct dsa_port *port)
 {
-	return !!of_parse_phandle(port->dn, "link", 0);
+	if (port->name && !strcmp(port->name, "dsa"))
+		return true;
+	else
+		return !!of_parse_phandle(port->dn, "link", 0);
 }
 
 static bool dsa_port_is_cpu(struct dsa_port *port)
 {
-	return !!of_parse_phandle(port->dn, "ethernet", 0);
+	if (port->name && !strcmp(port->name, "cpu"))
+		return true;
+	else
+		return !!of_parse_phandle(port->dn, "ethernet", 0);
 }
 
 static bool dsa_ds_find_port_dn(struct dsa_switch *ds,
@@ -250,10 +259,11 @@ static void dsa_cpu_port_unapply(struct dsa_port *port, u32 index,
 static int dsa_user_port_apply(struct dsa_port *port, u32 index,
 			       struct dsa_switch *ds)
 {
-	const char *name;
+	const char *name = port->name;
 	int err;
 
-	name = of_get_property(port->dn, "label", NULL);
+	if (port->dn)
+		name = of_get_property(port->dn, "label", NULL);
 	if (!name)
 		name = "eth%d";
 
@@ -444,11 +454,16 @@ static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 	struct net_device *ethernet_dev;
 	struct device_node *ethernet;
 
-	ethernet = of_parse_phandle(port->dn, "ethernet", 0);
-	if (!ethernet)
-		return -EINVAL;
+	if (port->dn) {
+		ethernet = of_parse_phandle(port->dn, "ethernet", 0);
+		if (!ethernet)
+			return -EINVAL;
+		ethernet_dev = of_find_net_device_by_node(ethernet);
+	} else {
+		ethernet_dev = dsa_dev_to_net_device(ds->cd->netdev[index]);
+		dev_put(ethernet_dev);
+	}
 
-	ethernet_dev = of_find_net_device_by_node(ethernet);
 	if (!ethernet_dev)
 		return -EPROBE_DEFER;
 
@@ -551,6 +566,33 @@ static int dsa_parse_ports_dn(struct device_node *ports, struct dsa_switch *ds)
 	return 0;
 }
 
+static int dsa_parse_ports(struct dsa_chip_data *cd, struct dsa_switch *ds)
+{
+	bool valid_name_found = false;
+	unsigned int i;
+
+	for (i = 0; i < DSA_MAX_PORTS; i++) {
+		if (!cd->port_names[i])
+			continue;
+
+		ds->ports[i].name = cd->port_names[i];
+
+		/* Initialize enabled_port_mask now for drv->setup()
+		 * to have access to a correct value, just like what
+		 * net/dsa/dsa.c::dsa_switch_setup_one does.
+		 */
+		if (!dsa_port_is_cpu(&ds->ports[i]))
+			ds->enabled_port_mask |= 1 << i;
+
+		valid_name_found = true;
+	}
+
+	if (!valid_name_found && i == DSA_MAX_PORTS)
+		return -EINVAL;
+
+	return 0;
+}
+
 static int dsa_parse_member_dn(struct device_node *np, u32 *tree, u32 *index)
 {
 	int err;
@@ -575,6 +617,18 @@ static int dsa_parse_member_dn(struct device_node *np, u32 *tree, u32 *index)
 	return 0;
 }
 
+static int dsa_parse_member(struct dsa_chip_data *pd, u32 *tree, u32 *index)
+{
+	if (!pd)
+		return -ENODEV;
+
+	/* We do not support complex trees with dsa_chip_data */
+	*tree = 0;
+	*index = 0;
+
+	return 0;
+}
+
 static struct device_node *dsa_get_ports(struct dsa_switch *ds,
 					 struct device_node *np)
 {
@@ -591,23 +645,34 @@ static struct device_node *dsa_get_ports(struct dsa_switch *ds,
 
 static int _dsa_register_switch(struct dsa_switch *ds, struct device *dev)
 {
+	struct dsa_chip_data *pdata = dev->platform_data;
 	struct device_node *np = dev->of_node;
 	struct dsa_switch_tree *dst;
 	struct device_node *ports;
 	u32 tree, index;
 	int i, err;
 
-	err = dsa_parse_member_dn(np, &tree, &index);
-	if (err)
-		return err;
+	if (np) {
+		err = dsa_parse_member_dn(np, &tree, &index);
+		if (err)
+			return err;
 
-	ports = dsa_get_ports(ds, np);
-	if (IS_ERR(ports))
-		return PTR_ERR(ports);
+		ports = dsa_get_ports(ds, np);
+		if (IS_ERR(ports))
+			return PTR_ERR(ports);
 
-	err = dsa_parse_ports_dn(ports, ds);
-	if (err)
-		return err;
+		err = dsa_parse_ports_dn(ports, ds);
+		if (err)
+			return err;
+	} else {
+		err = dsa_parse_member(pdata, &tree, &index);
+		if (err)
+			return err;
+
+		err = dsa_parse_ports(pdata, ds);
+		if (err)
+			return err;
+	}
 
 	dst = dsa_get_dst(tree);
 	if (!dst) {
@@ -623,6 +688,7 @@ static int _dsa_register_switch(struct dsa_switch *ds, struct device *dev)
 
 	ds->dst = dst;
 	ds->index = index;
+	ds->cd = pdata;
 
 	/* Initialize the routing table */
 	for (i = 0; i < DSA_MAX_SWITCHES; ++i)

commit f515f192ab4f45bb695146b82432d63d98775787
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Feb 3 13:20:20 2017 -0500

    net: dsa: add switch notifier
    
    Add a notifier block per DSA switch, registered against a notifier head
    in the switch fabric they belong to.
    
    This infrastructure will allow to propagate fabric-wide events such as
    port bridging, VLAN configuration, etc. If a DSA switch driver cares
    about cross-chip configuration, such events can be caught.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 9f8cc26be9ea..1c546b6621ee 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -294,6 +294,10 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	if (err < 0)
 		return err;
 
+	err = dsa_switch_register_notifier(ds);
+	if (err)
+		return err;
+
 	if (ds->ops->set_addr) {
 		err = ds->ops->set_addr(ds, dst->master_netdev->dev_addr);
 		if (err < 0)
@@ -364,6 +368,8 @@ static void dsa_ds_unapply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 
 	if (ds->slave_mii_bus && ds->ops->phy_read)
 		mdiobus_unregister(ds->slave_mii_bus);
+
+	dsa_switch_unregister_notifier(ds);
 }
 
 static int dsa_dst_apply(struct dsa_switch_tree *dst)

commit 818be8489d6fc8f4cc2c7699bbfd8e1983080f10
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Jan 27 15:29:38 2017 -0500

    net: dsa: add ds and index to dsa_port
    
    Add the physical switch instance and port index a DSA port belongs to to
    the dsa_port structure.
    
    That can be used later to retrieve information about a physical port
    when configuring a switch fabric, or lighten up struct dsa_slave_priv.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 6e7b3e88b778..9f8cc26be9ea 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -670,6 +670,7 @@ struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
 {
 	size_t size = sizeof(struct dsa_switch) + n * sizeof(struct dsa_port);
 	struct dsa_switch *ds;
+	int i;
 
 	ds = devm_kzalloc(dev, size, GFP_KERNEL);
 	if (!ds)
@@ -678,6 +679,11 @@ struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
 	ds->dev = dev;
 	ds->num_ports = n;
 
+	for (i = 0; i < ds->num_ports; ++i) {
+		ds->ports[i].index = i;
+		ds->ports[i].ds = ds;
+	}
+
 	return ds;
 }
 EXPORT_SYMBOL_GPL(dsa_switch_alloc);

commit 26895e299cfb583d304553e9c259e694a7e83397
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Jan 27 15:29:37 2017 -0500

    net: dsa: use ds->num_ports when possible
    
    The dsa_switch structure contains the number of ports. Use it where the
    structure is valid instead of the DSA_MAX_PORTS value.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 4b3a44bec5c8..6e7b3e88b778 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -98,7 +98,7 @@ static bool dsa_ds_find_port_dn(struct dsa_switch *ds,
 {
 	u32 index;
 
-	for (index = 0; index < DSA_MAX_PORTS; index++)
+	for (index = 0; index < ds->num_ports; index++)
 		if (ds->ports[index].dn == port)
 			return true;
 	return false;
@@ -159,7 +159,7 @@ static int dsa_ds_complete(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	u32 index;
 	int err;
 
-	for (index = 0; index < DSA_MAX_PORTS; index++) {
+	for (index = 0; index < ds->num_ports; index++) {
 		port = &ds->ports[index];
 		if (!dsa_port_is_valid(port))
 			continue;
@@ -312,7 +312,7 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 			return err;
 	}
 
-	for (index = 0; index < DSA_MAX_PORTS; index++) {
+	for (index = 0; index < ds->num_ports; index++) {
 		port = &ds->ports[index];
 		if (!dsa_port_is_valid(port))
 			continue;
@@ -344,7 +344,7 @@ static void dsa_ds_unapply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	struct dsa_port *port;
 	u32 index;
 
-	for (index = 0; index < DSA_MAX_PORTS; index++) {
+	for (index = 0; index < ds->num_ports; index++) {
 		port = &ds->ports[index];
 		if (!dsa_port_is_valid(port))
 			continue;
@@ -475,7 +475,7 @@ static int dsa_ds_parse(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	u32 index;
 	int err;
 
-	for (index = 0; index < DSA_MAX_PORTS; index++) {
+	for (index = 0; index < ds->num_ports; index++) {
 		port = &ds->ports[index];
 		if (!dsa_port_is_valid(port))
 			continue;
@@ -529,7 +529,7 @@ static int dsa_parse_ports_dn(struct device_node *ports, struct dsa_switch *ds)
 		if (err)
 			return err;
 
-		if (reg >= DSA_MAX_PORTS)
+		if (reg >= ds->num_ports)
 			return -EINVAL;
 
 		ds->ports[reg].dn = port;

commit a0c02161ecfc2f40a0837926efac5376bc6fd6d3
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Fri Jan 27 15:29:36 2017 -0500

    net: dsa: variable number of ports
    
    Change the ports[DSA_MAX_PORTS] array of the dsa_switch structure for a
    zero-length array, allocated at the same time as the dsa_switch
    structure itself. A dsa_switch_alloc() helper is provided for that.
    
    This commit brings no functional change yet since we pass DSA_MAX_PORTS
    as the number of ports for the moment. Future patches can update the DSA
    drivers separately to support dynamic number of ports.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 75f5d1f8554b..4b3a44bec5c8 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -666,6 +666,22 @@ static int _dsa_register_switch(struct dsa_switch *ds, struct device *dev)
 	return err;
 }
 
+struct dsa_switch *dsa_switch_alloc(struct device *dev, size_t n)
+{
+	size_t size = sizeof(struct dsa_switch) + n * sizeof(struct dsa_port);
+	struct dsa_switch *ds;
+
+	ds = devm_kzalloc(dev, size, GFP_KERNEL);
+	if (!ds)
+		return NULL;
+
+	ds->dev = dev;
+	ds->num_ports = n;
+
+	return ds;
+}
+EXPORT_SYMBOL_GPL(dsa_switch_alloc);
+
 int dsa_register_switch(struct dsa_switch *ds, struct device *dev)
 {
 	int err;

commit bc1727d242fa595c84e8f42b292e82151ba8cf06
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Jan 26 10:45:54 2017 -0800

    net: dsa: Move ports assignment closer to error checking
    
    Move the assignment of ports in _dsa_register_switch() closer to where
    it is checked, no functional change. Re-order declarations to be
    preserve the inverted christmas tree style.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 4c11619a818b..75f5d1f8554b 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -586,8 +586,8 @@ static struct device_node *dsa_get_ports(struct dsa_switch *ds,
 static int _dsa_register_switch(struct dsa_switch *ds, struct device *dev)
 {
 	struct device_node *np = dev->of_node;
-	struct device_node *ports = dsa_get_ports(ds, np);
 	struct dsa_switch_tree *dst;
+	struct device_node *ports;
 	u32 tree, index;
 	int i, err;
 
@@ -595,6 +595,7 @@ static int _dsa_register_switch(struct dsa_switch *ds, struct device *dev)
 	if (err)
 		return err;
 
+	ports = dsa_get_ports(ds, np);
 	if (IS_ERR(ports))
 		return PTR_ERR(ports);
 

commit 3512a8e95e6acb51d4cd04480689ac484ed538c2
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Jan 26 10:45:53 2017 -0800

    net: dsa: Suffix function manipulating device_node with _dn
    
    Make it clear that these functions take a device_node structure pointer
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 56c43ca7c049..4c11619a818b 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -93,8 +93,8 @@ static bool dsa_port_is_cpu(struct dsa_port *port)
 	return !!of_parse_phandle(port->dn, "ethernet", 0);
 }
 
-static bool dsa_ds_find_port(struct dsa_switch *ds,
-			     struct device_node *port)
+static bool dsa_ds_find_port_dn(struct dsa_switch *ds,
+				struct device_node *port)
 {
 	u32 index;
 
@@ -104,8 +104,8 @@ static bool dsa_ds_find_port(struct dsa_switch *ds,
 	return false;
 }
 
-static struct dsa_switch *dsa_dst_find_port(struct dsa_switch_tree *dst,
-					    struct device_node *port)
+static struct dsa_switch *dsa_dst_find_port_dn(struct dsa_switch_tree *dst,
+					       struct device_node *port)
 {
 	struct dsa_switch *ds;
 	u32 index;
@@ -115,7 +115,7 @@ static struct dsa_switch *dsa_dst_find_port(struct dsa_switch_tree *dst,
 		if (!ds)
 			continue;
 
-		if (dsa_ds_find_port(ds, port))
+		if (dsa_ds_find_port_dn(ds, port))
 			return ds;
 	}
 
@@ -136,7 +136,7 @@ static int dsa_port_complete(struct dsa_switch_tree *dst,
 		if (!link)
 			break;
 
-		dst_ds = dsa_dst_find_port(dst, link);
+		dst_ds = dsa_dst_find_port_dn(dst, link);
 		of_node_put(link);
 
 		if (!dst_ds)
@@ -545,7 +545,7 @@ static int dsa_parse_ports_dn(struct device_node *ports, struct dsa_switch *ds)
 	return 0;
 }
 
-static int dsa_parse_member(struct device_node *np, u32 *tree, u32 *index)
+static int dsa_parse_member_dn(struct device_node *np, u32 *tree, u32 *index)
 {
 	int err;
 
@@ -591,7 +591,7 @@ static int _dsa_register_switch(struct dsa_switch *ds, struct device *dev)
 	u32 tree, index;
 	int i, err;
 
-	err = dsa_parse_member(np, &tree, &index);
+	err = dsa_parse_member_dn(np, &tree, &index);
 	if (err)
 		return err;
 

commit 293784a8f856e854b4742be4aacf435062d91e9c
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Jan 26 10:45:52 2017 -0800

    net: dsa: Make most functions take a dsa_port argument
    
    In preparation for allowing platform data, and therefore no valid
    device_node pointer, make most DSA functions takes a pointer to a
    dsa_port structure whenever possible. While at it, introduce a
    dsa_port_is_valid() helper function which checks whether port->dn is
    NULL or not at the moment.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 2cf489c5e90f..56c43ca7c049 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -78,14 +78,19 @@ static void dsa_dst_del_ds(struct dsa_switch_tree *dst,
 	kref_put(&dst->refcount, dsa_free_dst);
 }
 
-static bool dsa_port_is_dsa(struct device_node *port)
+static bool dsa_port_is_valid(struct dsa_port *port)
 {
-	return !!of_parse_phandle(port, "link", 0);
+	return !!port->dn;
 }
 
-static bool dsa_port_is_cpu(struct device_node *port)
+static bool dsa_port_is_dsa(struct dsa_port *port)
 {
-	return !!of_parse_phandle(port, "ethernet", 0);
+	return !!of_parse_phandle(port->dn, "link", 0);
+}
+
+static bool dsa_port_is_cpu(struct dsa_port *port)
+{
+	return !!of_parse_phandle(port->dn, "ethernet", 0);
 }
 
 static bool dsa_ds_find_port(struct dsa_switch *ds,
@@ -119,7 +124,7 @@ static struct dsa_switch *dsa_dst_find_port(struct dsa_switch_tree *dst,
 
 static int dsa_port_complete(struct dsa_switch_tree *dst,
 			     struct dsa_switch *src_ds,
-			     struct device_node *port,
+			     struct dsa_port *port,
 			     u32 src_port)
 {
 	struct device_node *link;
@@ -127,7 +132,7 @@ static int dsa_port_complete(struct dsa_switch_tree *dst,
 	struct dsa_switch *dst_ds;
 
 	for (index = 0;; index++) {
-		link = of_parse_phandle(port, "link", index);
+		link = of_parse_phandle(port->dn, "link", index);
 		if (!link)
 			break;
 
@@ -150,13 +155,13 @@ static int dsa_port_complete(struct dsa_switch_tree *dst,
  */
 static int dsa_ds_complete(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 {
-	struct device_node *port;
+	struct dsa_port *port;
 	u32 index;
 	int err;
 
 	for (index = 0; index < DSA_MAX_PORTS; index++) {
-		port = ds->ports[index].dn;
-		if (!port)
+		port = &ds->ports[index];
+		if (!dsa_port_is_valid(port))
 			continue;
 
 		if (!dsa_port_is_dsa(port))
@@ -196,7 +201,7 @@ static int dsa_dst_complete(struct dsa_switch_tree *dst)
 	return 0;
 }
 
-static int dsa_dsa_port_apply(struct device_node *port, u32 index,
+static int dsa_dsa_port_apply(struct dsa_port *port, u32 index,
 			      struct dsa_switch *ds)
 {
 	int err;
@@ -211,13 +216,13 @@ static int dsa_dsa_port_apply(struct device_node *port, u32 index,
 	return 0;
 }
 
-static void dsa_dsa_port_unapply(struct device_node *port, u32 index,
+static void dsa_dsa_port_unapply(struct dsa_port *port, u32 index,
 				 struct dsa_switch *ds)
 {
 	dsa_cpu_dsa_destroy(port);
 }
 
-static int dsa_cpu_port_apply(struct device_node *port, u32 index,
+static int dsa_cpu_port_apply(struct dsa_port *port, u32 index,
 			      struct dsa_switch *ds)
 {
 	int err;
@@ -234,7 +239,7 @@ static int dsa_cpu_port_apply(struct device_node *port, u32 index,
 	return 0;
 }
 
-static void dsa_cpu_port_unapply(struct device_node *port, u32 index,
+static void dsa_cpu_port_unapply(struct dsa_port *port, u32 index,
 				 struct dsa_switch *ds)
 {
 	dsa_cpu_dsa_destroy(port);
@@ -242,13 +247,13 @@ static void dsa_cpu_port_unapply(struct device_node *port, u32 index,
 
 }
 
-static int dsa_user_port_apply(struct device_node *port, u32 index,
+static int dsa_user_port_apply(struct dsa_port *port, u32 index,
 			       struct dsa_switch *ds)
 {
 	const char *name;
 	int err;
 
-	name = of_get_property(port, "label", NULL);
+	name = of_get_property(port->dn, "label", NULL);
 	if (!name)
 		name = "eth%d";
 
@@ -262,7 +267,7 @@ static int dsa_user_port_apply(struct device_node *port, u32 index,
 	return 0;
 }
 
-static void dsa_user_port_unapply(struct device_node *port, u32 index,
+static void dsa_user_port_unapply(struct dsa_port *port, u32 index,
 				  struct dsa_switch *ds)
 {
 	if (ds->ports[index].netdev) {
@@ -274,7 +279,7 @@ static void dsa_user_port_unapply(struct device_node *port, u32 index,
 
 static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 {
-	struct device_node *port;
+	struct dsa_port *port;
 	u32 index;
 	int err;
 
@@ -308,8 +313,8 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	}
 
 	for (index = 0; index < DSA_MAX_PORTS; index++) {
-		port = ds->ports[index].dn;
-		if (!port)
+		port = &ds->ports[index];
+		if (!dsa_port_is_valid(port))
 			continue;
 
 		if (dsa_port_is_dsa(port)) {
@@ -336,12 +341,12 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 
 static void dsa_ds_unapply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 {
-	struct device_node *port;
+	struct dsa_port *port;
 	u32 index;
 
 	for (index = 0; index < DSA_MAX_PORTS; index++) {
-		port = ds->ports[index].dn;
-		if (!port)
+		port = &ds->ports[index];
+		if (!dsa_port_is_valid(port))
 			continue;
 
 		if (dsa_port_is_dsa(port)) {
@@ -425,7 +430,7 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 	dst->applied = false;
 }
 
-static int dsa_cpu_parse(struct device_node *port, u32 index,
+static int dsa_cpu_parse(struct dsa_port *port, u32 index,
 			 struct dsa_switch_tree *dst,
 			 struct dsa_switch *ds)
 {
@@ -433,7 +438,7 @@ static int dsa_cpu_parse(struct device_node *port, u32 index,
 	struct net_device *ethernet_dev;
 	struct device_node *ethernet;
 
-	ethernet = of_parse_phandle(port, "ethernet", 0);
+	ethernet = of_parse_phandle(port->dn, "ethernet", 0);
 	if (!ethernet)
 		return -EINVAL;
 
@@ -466,13 +471,13 @@ static int dsa_cpu_parse(struct device_node *port, u32 index,
 
 static int dsa_ds_parse(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 {
-	struct device_node *port;
+	struct dsa_port *port;
 	u32 index;
 	int err;
 
 	for (index = 0; index < DSA_MAX_PORTS; index++) {
-		port = ds->ports[index].dn;
-		if (!port)
+		port = &ds->ports[index];
+		if (!dsa_port_is_valid(port))
 			continue;
 
 		if (dsa_port_is_cpu(port)) {
@@ -533,7 +538,7 @@ static int dsa_parse_ports_dn(struct device_node *ports, struct dsa_switch *ds)
 		 * to have access to a correct value, just like what
 		 * net/dsa/dsa.c::dsa_switch_setup_one does.
 		 */
-		if (!dsa_port_is_cpu(port))
+		if (!dsa_port_is_cpu(&ds->ports[reg]))
 			ds->enabled_port_mask |= 1 << reg;
 	}
 

commit 55ed0ce0898e15fec30d2ca2a563d7934b082375
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Thu Jan 26 10:45:51 2017 -0800

    net: dsa: Pass device pointer to dsa_register_switch
    
    In preparation for allowing dsa_register_switch() to be supplied with
    device/platform data, pass down a struct device pointer instead of a
    struct device_node.
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 866222a8f9bf..2cf489c5e90f 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -578,8 +578,9 @@ static struct device_node *dsa_get_ports(struct dsa_switch *ds,
 	return ports;
 }
 
-static int _dsa_register_switch(struct dsa_switch *ds, struct device_node *np)
+static int _dsa_register_switch(struct dsa_switch *ds, struct device *dev)
 {
+	struct device_node *np = dev->of_node;
 	struct device_node *ports = dsa_get_ports(ds, np);
 	struct dsa_switch_tree *dst;
 	u32 tree, index;
@@ -659,12 +660,12 @@ static int _dsa_register_switch(struct dsa_switch *ds, struct device_node *np)
 	return err;
 }
 
-int dsa_register_switch(struct dsa_switch *ds, struct device_node *np)
+int dsa_register_switch(struct dsa_switch *ds, struct device *dev)
 {
 	int err;
 
 	mutex_lock(&dsa2_mutex);
-	err = _dsa_register_switch(ds, np);
+	err = _dsa_register_switch(ds, dev);
 	mutex_unlock(&dsa2_mutex);
 
 	return err;

commit 9520ed8fb8410dcb6babf751561a08f73ca03812
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Tue Jan 17 20:41:39 2017 -0500

    net: dsa: use cpu_switch instead of ds[0]
    
    Now that the DSA Ethernet switches are true Linux devices, the CPU
    switch is not necessarily the first one. If its address is higher than
    the second switch on the same MDIO bus, its index will be 1, not 0.
    
    Avoid any confusion by using dst->cpu_switch instead of dst->ds[0].
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 020e072b4299..866222a8f9bf 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -377,8 +377,8 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 			return err;
 	}
 
-	if (dst->ds[0]) {
-		err = dsa_cpu_port_ethtool_setup(dst->ds[0]);
+	if (dst->cpu_switch) {
+		err = dsa_cpu_port_ethtool_setup(dst->cpu_switch);
 		if (err)
 			return err;
 	}
@@ -418,8 +418,8 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 		dsa_ds_unapply(dst, ds);
 	}
 
-	if (dst->ds[0])
-		dsa_cpu_port_ethtool_restore(dst->ds[0]);
+	if (dst->cpu_switch)
+		dsa_cpu_port_ethtool_restore(dst->cpu_switch);
 
 	pr_info("DSA: tree %d unapplied\n", dst->tree);
 	dst->applied = false;

commit b22de490869da354116ea4cbbaa09dcbc260b2b4
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Tue Jan 17 20:41:38 2017 -0500

    net: dsa: store CPU switch structure in the tree
    
    Store a dsa_switch pointer to the CPU switch in the tree instead of only
    its index. This avoids the need to initialize it to -1.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 42a41d84053c..020e072b4299 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -57,7 +57,6 @@ static struct dsa_switch_tree *dsa_add_dst(u32 tree)
 	if (!dst)
 		return NULL;
 	dst->tree = tree;
-	dst->cpu_switch = -1;
 	INIT_LIST_HEAD(&dst->list);
 	list_add_tail(&dsa_switch_trees, &dst->list);
 	kref_init(&dst->refcount);
@@ -448,8 +447,8 @@ static int dsa_cpu_parse(struct device_node *port, u32 index,
 	if (!dst->master_netdev)
 		dst->master_netdev = ethernet_dev;
 
-	if (dst->cpu_switch == -1) {
-		dst->cpu_switch = ds->index;
+	if (!dst->cpu_switch) {
+		dst->cpu_switch = ds;
 		dst->cpu_port = index;
 	}
 

commit 02ac5d1487115d160fab4c3e61b7edc20a945af9
Merge: 265592a1dfc3 ba836a6f5ab1
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Jan 11 14:43:39 2017 -0500

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Two AF_* families adding entries to the lockdep tables
    at the same time.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit 9f91484f6fcc28f9b5ebe11755e7488e39ea75e4
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Mon Jan 9 18:13:51 2017 -0500

    net: dsa: make "label" property optional for dsa2
    
    In the new DTS bindings for DSA (dsa2), the "ethernet" and "link"
    phandles are respectively mandatory and exclusive to CPU port and DSA
    link device tree nodes.
    
    Simplify dsa2.c a bit by checking the presence of such phandle instead
    of checking the redundant "label" property.
    
    Then the Linux philosophy for Ethernet switch ports is to expose them to
    userspace as standard NICs by default. Thus use the standard enumerated
    "eth%d" device name if no "label" property is provided for a user port.
    This allows to save DTS files from subjective net device names.
    
    If one wants to rename an interface, udev rules can be used as usual.
    
    Of course the current behavior is unchanged, and the optional "label"
    property for user ports has precedence over the enumerated name.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Acked-by: Uwe Kleine-König <uwe@kleine-koenig.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index bad119cee2a3..9526bdf2a34a 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -81,30 +81,12 @@ static void dsa_dst_del_ds(struct dsa_switch_tree *dst,
 
 static bool dsa_port_is_dsa(struct device_node *port)
 {
-	const char *name;
-
-	name = of_get_property(port, "label", NULL);
-	if (!name)
-		return false;
-
-	if (!strcmp(name, "dsa"))
-		return true;
-
-	return false;
+	return !!of_parse_phandle(port, "link", 0);
 }
 
 static bool dsa_port_is_cpu(struct device_node *port)
 {
-	const char *name;
-
-	name = of_get_property(port, "label", NULL);
-	if (!name)
-		return false;
-
-	if (!strcmp(name, "cpu"))
-		return true;
-
-	return false;
+	return !!of_parse_phandle(port, "ethernet", 0);
 }
 
 static bool dsa_ds_find_port(struct dsa_switch *ds,
@@ -268,6 +250,8 @@ static int dsa_user_port_apply(struct device_node *port, u32 index,
 	int err;
 
 	name = of_get_property(port, "label", NULL);
+	if (!name)
+		name = "eth%d";
 
 	err = dsa_slave_create(ds, ds->dev, index, name);
 	if (err) {

commit faf3a932fbeb77860226a8323eacb835edc98648
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Mon Jan 9 11:58:34 2017 -0800

    net: dsa: Ensure validity of dst->ds[0]
    
    It is perfectly possible to have non zero indexed switches being present
    in a DSA switch tree, in such a case, we will be deferencing a NULL
    pointer while dsa_cpu_port_ethtool_{setup,restore}. Be more defensive
    and ensure that dst->ds[0] is valid before doing anything with it.
    
    Fixes: 0c73c523cf73 ("net: dsa: Initialize CPU port ethtool ops per tree")
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 5fff951a0a49..da3862124545 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -394,9 +394,11 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 			return err;
 	}
 
-	err = dsa_cpu_port_ethtool_setup(dst->ds[0]);
-	if (err)
-		return err;
+	if (dst->ds[0]) {
+		err = dsa_cpu_port_ethtool_setup(dst->ds[0]);
+		if (err)
+			return err;
+	}
 
 	/* If we use a tagging format that doesn't have an ethertype
 	 * field, make sure that all packets from this point on get
@@ -433,7 +435,8 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 		dsa_ds_unapply(dst, ds);
 	}
 
-	dsa_cpu_port_ethtool_restore(dst->ds[0]);
+	if (dst->ds[0])
+		dsa_cpu_port_ethtool_restore(dst->ds[0]);
 
 	pr_info("DSA: tree %d unapplied\n", dst->tree);
 	dst->applied = false;

commit 5e6eb456983c994a8e582127a300b6552e5a1768
Author: Volodymyr Bendiuga <volodymyr.bendiuga@gmail.com>
Date:   Thu Jan 5 11:10:13 2017 +0100

    net:dsa: check for EPROBE_DEFER from dsa_dst_parse()
    
    Since there can be multiple dsa switches stacked together but
    not all of devicetree nodes available at the time of calling
    dsa_dst_parse(), EPROBE_DEFER can be returned by it. When this
    happens, only the last dsa switch has to be deleted by
    dsa_dst_del_ds(), but not the whole list, because next time linux
    cames back to this function it will try to add only the last dsa
    switch which returned EPROBE_DEFER.
    
    Signed-off-by: Volodymyr Bendiuga <volodymyr.bendiuga@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 5fff951a0a49..bad119cee2a3 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -647,8 +647,14 @@ static int _dsa_register_switch(struct dsa_switch *ds, struct device_node *np)
 	}
 
 	err = dsa_dst_parse(dst);
-	if (err)
+	if (err) {
+		if (err == -EPROBE_DEFER) {
+			dsa_dst_del_ds(dst, ds, ds->index);
+			return err;
+		}
+
 		goto out_del_dst;
+	}
 
 	err = dsa_dst_apply(dst);
 	if (err) {

commit 7a99cd6e213685b78118382e6a8fed506c82ccb2
Author: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
Date:   Mon Nov 28 09:48:48 2016 +0300

    net: dsa: fix unbalanced dsa_switch_tree reference counting
    
    _dsa_register_switch() gets a dsa_switch_tree object either via
    dsa_get_dst() or via dsa_add_dst(). Former path does not increase kref
    in returned object (resulting into caller not owning a reference),
    while later path does create a new object (resulting into caller owning
    a reference).
    
    The rest of _dsa_register_switch() assumes that it owns a reference, and
    calls dsa_put_dst().
    
    This causes a memory breakage if first switch in the tree initialized
    successfully, but second failed to initialize. In particular, freed
    dsa_swith_tree object is left referenced by switch that was initialized,
    and later access to sysfs attributes of that switch cause OOPS.
    
    To fix, need to add kref_get() call to dsa_get_dst().
    
    Fixes: 83c0afaec7b7 ("net: dsa: Add new binding implementation")
    Signed-off-by: Nikita Yushchenko <nikita.yoush@cogentembedded.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index f8a7d9aab437..5fff951a0a49 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -28,8 +28,10 @@ static struct dsa_switch_tree *dsa_get_dst(u32 tree)
 	struct dsa_switch_tree *dst;
 
 	list_for_each_entry(dst, &dsa_switch_trees, list)
-		if (dst->tree == tree)
+		if (dst->tree == tree) {
+			kref_get(&dst->refcount);
 			return dst;
+		}
 	return NULL;
 }
 

commit 092183df0fa1f4b49baad3a980c55d55de07dfb7
Author: John Crispin <john@phrozen.org>
Date:   Mon Sep 19 15:28:01 2016 +0200

    net-next: dsa: make the set_addr() operation optional
    
    Only 1 of the 3 drivers currently has a set_addr() operation. Make the
    set_addr() callback optional to reduce the amount of empty stubs inside
    the drivers.
    
    Signed-off-by: John Crispin <john@phrozen.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index cffc19e972a1..f8a7d9aab437 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -304,9 +304,11 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	if (err < 0)
 		return err;
 
-	err = ds->ops->set_addr(ds, dst->master_netdev->dev_addr);
-	if (err < 0)
-		return err;
+	if (ds->ops->set_addr) {
+		err = ds->ops->set_addr(ds, dst->master_netdev->dev_addr);
+		if (err < 0)
+			return err;
+	}
 
 	if (!ds->slave_mii_bus && ds->ops->phy_read) {
 		ds->slave_mii_bus = devm_mdiobus_alloc(ds->dev);

commit 06f8ec9041f02d44bb0b75d47668e2fe00d5e0c3
Author: John Crispin <john@phrozen.org>
Date:   Mon Sep 19 15:28:00 2016 +0200

    net-next: dsa: fix duplicate invocation of set_addr()
    
    commit 83c0afaec7b730b ("net: dsa: Add new binding implementation")
    has a duplicate invocation of the set_addr() operation callback. Remove one
    of them.
    
    Signed-off-by: John Crispin <john@phrozen.org>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 8278385dcd21..cffc19e972a1 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -308,10 +308,6 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	if (err < 0)
 		return err;
 
-	err = ds->ops->set_addr(ds, dst->master_netdev->dev_addr);
-	if (err < 0)
-		return err;
-
 	if (!ds->slave_mii_bus && ds->ops->phy_read) {
 		ds->slave_mii_bus = devm_mdiobus_alloc(ds->dev);
 		if (!ds->slave_mii_bus)

commit 9d490b4ee4d7d495a4f4908ea998d2a7355e0807
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Tue Aug 23 12:38:56 2016 -0400

    net: dsa: rename switch operations structure
    
    Now that the dsa_switch_driver structure contains only function pointers
    as it is supposed to, rename it to the more appropriate dsa_switch_ops,
    uniformly to any other operations structure in the kernel.
    
    No functional changes here, basically just the result of something like:
    s/dsa_switch_driver *drv/dsa_switch_ops *ops/g
    
    However keep the {un,}register_switch_driver functions and their
    dsa_switch_drivers list as is, since they represent the -- likely to be
    deprecated soon -- legacy DSA registration framework.
    
    In the meantime, also fix the following checks from checkpatch.pl to
    make it happy with this patch:
    
        CHECK: Comparison to NULL could be written "!ops"
        #403: FILE: net/dsa/dsa.c:470:
        +   if (ops == NULL) {
    
        CHECK: Comparison to NULL could be written "ds->ops->get_strings"
        #773: FILE: net/dsa/slave.c:697:
        +           if (ds->ops->get_strings != NULL)
    
        CHECK: Comparison to NULL could be written "ds->ops->get_ethtool_stats"
        #824: FILE: net/dsa/slave.c:785:
        +   if (ds->ops->get_ethtool_stats != NULL)
    
        CHECK: Comparison to NULL could be written "ds->ops->get_sset_count"
        #835: FILE: net/dsa/slave.c:798:
        +           if (ds->ops->get_sset_count != NULL)
    
        total: 0 errors, 0 warnings, 4 checks, 784 lines checked
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 2e343221464c..8278385dcd21 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -294,25 +294,25 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	int err;
 
 	/* Initialize ds->phys_mii_mask before registering the slave MDIO bus
-	 * driver and before drv->setup() has run, since the switch drivers and
+	 * driver and before ops->setup() has run, since the switch drivers and
 	 * the slave MDIO bus driver rely on these values for probing PHY
 	 * devices or not
 	 */
 	ds->phys_mii_mask = ds->enabled_port_mask;
 
-	err = ds->drv->setup(ds);
+	err = ds->ops->setup(ds);
 	if (err < 0)
 		return err;
 
-	err = ds->drv->set_addr(ds, dst->master_netdev->dev_addr);
+	err = ds->ops->set_addr(ds, dst->master_netdev->dev_addr);
 	if (err < 0)
 		return err;
 
-	err = ds->drv->set_addr(ds, dst->master_netdev->dev_addr);
+	err = ds->ops->set_addr(ds, dst->master_netdev->dev_addr);
 	if (err < 0)
 		return err;
 
-	if (!ds->slave_mii_bus && ds->drv->phy_read) {
+	if (!ds->slave_mii_bus && ds->ops->phy_read) {
 		ds->slave_mii_bus = devm_mdiobus_alloc(ds->dev);
 		if (!ds->slave_mii_bus)
 			return -ENOMEM;
@@ -374,7 +374,7 @@ static void dsa_ds_unapply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 		dsa_user_port_unapply(port, index, ds);
 	}
 
-	if (ds->slave_mii_bus && ds->drv->phy_read)
+	if (ds->slave_mii_bus && ds->ops->phy_read)
 		mdiobus_unregister(ds->slave_mii_bus);
 }
 
@@ -466,7 +466,7 @@ static int dsa_cpu_parse(struct device_node *port, u32 index,
 		dst->cpu_port = index;
 	}
 
-	tag_protocol = ds->drv->get_tag_protocol(ds);
+	tag_protocol = ds->ops->get_tag_protocol(ds);
 	dst->tag_ops = dsa_resolve_tag_protocol(tag_protocol);
 	if (IS_ERR(dst->tag_ops)) {
 		dev_warn(ds->dev, "No tagger for this switch\n");
@@ -543,7 +543,7 @@ static int dsa_parse_ports_dn(struct device_node *ports, struct dsa_switch *ds)
 
 		ds->ports[reg].dn = port;
 
-		/* Initialize enabled_port_mask now for drv->setup()
+		/* Initialize enabled_port_mask now for ops->setup()
 		 * to have access to a correct value, just like what
 		 * net/dsa/dsa.c::dsa_switch_setup_one does.
 		 */

commit 7b314362a2344feaafbdf6aa8f3d57077728e37a
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Mon Aug 22 16:01:01 2016 +0200

    net: dsa: Allow the DSA driver to indicate the tag protocol
    
    DSA drivers may drive different families of switches which need
    different tag protocol. Rather than hard code the tag protocol in the
    driver structure, have a callback for the DSA core to call.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index f30bad9678f0..2e343221464c 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -443,6 +443,7 @@ static int dsa_cpu_parse(struct device_node *port, u32 index,
 			 struct dsa_switch_tree *dst,
 			 struct dsa_switch *ds)
 {
+	enum dsa_tag_protocol tag_protocol;
 	struct net_device *ethernet_dev;
 	struct device_node *ethernet;
 
@@ -465,7 +466,8 @@ static int dsa_cpu_parse(struct device_node *port, u32 index,
 		dst->cpu_port = index;
 	}
 
-	dst->tag_ops = dsa_resolve_tag_protocol(ds->drv->tag_protocol);
+	tag_protocol = ds->drv->get_tag_protocol(ds);
+	dst->tag_ops = dsa_resolve_tag_protocol(tag_protocol);
 	if (IS_ERR(dst->tag_ops)) {
 		dev_warn(ds->dev, "No tagger for this switch\n");
 		return PTR_ERR(dst->tag_ops);

commit 85c22bad56ec0d0d8d8518414f97106233132e43
Author: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
Date:   Tue Jul 12 15:24:10 2016 +0000

    net: dsa: Fix non static symbol warning
    
    Fixes the following sparse warning:
    
    net/dsa/dsa2.c:680:6: warning:
     symbol '_dsa_unregister_switch' was not declared. Should it be static?
    
    Signed-off-by: Wei Yongjun <yongjun_wei@trendmicro.com.cn>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 78e4c0131c30..f30bad9678f0 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -677,7 +677,7 @@ int dsa_register_switch(struct dsa_switch *ds, struct device_node *np)
 }
 EXPORT_SYMBOL_GPL(dsa_register_switch);
 
-void _dsa_unregister_switch(struct dsa_switch *ds)
+static void _dsa_unregister_switch(struct dsa_switch *ds)
 {
 	struct dsa_switch_tree *dst = ds->dst;
 

commit d390238c4fba7c87a3bcd859ce3373c864eb7b02
Author: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
Date:   Wed Jul 6 20:03:54 2016 -0400

    net: dsa: initialize the routing table
    
    The routing table of every switch in a tree is currently initialized to
    all zeros. This is an issue since 0 is a valid port number.
    
    Add a DSA_RTABLE_NONE=-1 constant to initialize the signed values of the
    routing table pointing to other switches.
    
    This fixes the device mapping of the mv88e6xxx driver where the port
    pointing to the switch itself and to non-existent switches was wrongly
    configured to be 0. It is now set to the expected 0xf value.
    
    Signed-off-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 83b95fc4cede..78e4c0131c30 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -595,7 +595,7 @@ static int _dsa_register_switch(struct dsa_switch *ds, struct device_node *np)
 	struct device_node *ports = dsa_get_ports(ds, np);
 	struct dsa_switch_tree *dst;
 	u32 tree, index;
-	int err;
+	int i, err;
 
 	err = dsa_parse_member(np, &tree, &index);
 	if (err)
@@ -622,6 +622,11 @@ static int _dsa_register_switch(struct dsa_switch *ds, struct device_node *np)
 
 	ds->dst = dst;
 	ds->index = index;
+
+	/* Initialize the routing table */
+	for (i = 0; i < DSA_MAX_SWITCHES; ++i)
+		ds->rtable[i] = DSA_RTABLE_NONE;
+
 	dsa_dst_add_ds(dst, ds, index);
 
 	err = dsa_dst_complete(dst);

commit 0c73c523cf737b5d446705392e0e14ee0411a351
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jun 7 16:32:42 2016 -0700

    net: dsa: Initialize CPU port ethtool ops per tree
    
    Now that we can properly support multiple distinct trees in the system,
    using a global variable: dsa_cpu_port_ethtool_ops is getting clobbered
    as soon as the second switch tree gets probed, and we don't want that.
    
    We need to move this to be dynamically allocated, and since we can't
    really be comparing addresses anymore to determine first time
    initialization versus any other times, just move this to dsa.c and
    dsa2.c where the remainder of the dst/ds initialization happens.
    
    The operations teardown restores the master netdev's ethtool_ops to its
    original ethtool_ops pointer (typically within the Ethernet driver)
    
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 4e0f3c268103..83b95fc4cede 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -394,6 +394,10 @@ static int dsa_dst_apply(struct dsa_switch_tree *dst)
 			return err;
 	}
 
+	err = dsa_cpu_port_ethtool_setup(dst->ds[0]);
+	if (err)
+		return err;
+
 	/* If we use a tagging format that doesn't have an ethertype
 	 * field, make sure that all packets from this point on get
 	 * sent to the tag format's receive function.
@@ -429,6 +433,8 @@ static void dsa_dst_unapply(struct dsa_switch_tree *dst)
 		dsa_ds_unapply(dst, ds);
 	}
 
+	dsa_cpu_port_ethtool_restore(dst->ds[0]);
+
 	pr_info("DSA: tree %d unapplied\n", dst->tree);
 	dst->applied = false;
 }

commit 1eb59443e72c69edbb836626f9f7f7e82427eeac
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jun 7 16:32:40 2016 -0700

    net: dsa: Provide a slave MII bus if needed
    
    Mimic what net/dsa/dsa.c does and provide a slave MII bus by default
    which will be created if the driver implements a phy_read method.
    
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Vivien Didelot <vivien.didelot@savoirfairelinux.com>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 921a36fd139d..4e0f3c268103 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -312,6 +312,18 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	if (err < 0)
 		return err;
 
+	if (!ds->slave_mii_bus && ds->drv->phy_read) {
+		ds->slave_mii_bus = devm_mdiobus_alloc(ds->dev);
+		if (!ds->slave_mii_bus)
+			return -ENOMEM;
+
+		dsa_slave_mii_bus_init(ds);
+
+		err = mdiobus_register(ds->slave_mii_bus);
+		if (err < 0)
+			return err;
+	}
+
 	for (index = 0; index < DSA_MAX_PORTS; index++) {
 		port = ds->ports[index].dn;
 		if (!port)
@@ -361,6 +373,9 @@ static void dsa_ds_unapply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 
 		dsa_user_port_unapply(port, index, ds);
 	}
+
+	if (ds->slave_mii_bus && ds->drv->phy_read)
+		mdiobus_unregister(ds->slave_mii_bus);
 }
 
 static int dsa_dst_apply(struct dsa_switch_tree *dst)

commit 6e830d8f0deca91fcb84d3156dcebb20384a9e2d
Author: Florian Fainelli <f.fainelli@gmail.com>
Date:   Tue Jun 7 16:32:39 2016 -0700

    net: dsa: Initialize ds->enabled_port_mask and ds->phys_mii_mask
    
    Some drivers rely on these two bitmasks to contain the correct values
    for them to successfully probe and initialize at drv->setup() time,
    calculate correct values to put in both masks as early as possible in
    dsa_get_ports_dn().
    
    Reviewed-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
index 80dfe08db825..921a36fd139d 100644
--- a/net/dsa/dsa2.c
+++ b/net/dsa/dsa2.c
@@ -283,6 +283,7 @@ static void dsa_user_port_unapply(struct device_node *port, u32 index,
 	if (ds->ports[index].netdev) {
 		dsa_slave_destroy(ds->ports[index].netdev);
 		ds->ports[index].netdev = NULL;
+		ds->enabled_port_mask &= ~(1 << index);
 	}
 }
 
@@ -292,6 +293,13 @@ static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
 	u32 index;
 	int err;
 
+	/* Initialize ds->phys_mii_mask before registering the slave MDIO bus
+	 * driver and before drv->setup() has run, since the switch drivers and
+	 * the slave MDIO bus driver rely on these values for probing PHY
+	 * devices or not
+	 */
+	ds->phys_mii_mask = ds->enabled_port_mask;
+
 	err = ds->drv->setup(ds);
 	if (err < 0)
 		return err;
@@ -511,6 +519,13 @@ static int dsa_parse_ports_dn(struct device_node *ports, struct dsa_switch *ds)
 			return -EINVAL;
 
 		ds->ports[reg].dn = port;
+
+		/* Initialize enabled_port_mask now for drv->setup()
+		 * to have access to a correct value, just like what
+		 * net/dsa/dsa.c::dsa_switch_setup_one does.
+		 */
+		if (!dsa_port_is_cpu(port))
+			ds->enabled_port_mask |= 1 << reg;
 	}
 
 	return 0;

commit 83c0afaec7b730b16c518aecc8e6246ec91b265e
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Sat Jun 4 21:17:07 2016 +0200

    net: dsa: Add new binding implementation
    
    The existing DSA binding has a number of limitations and problems. The
    main problem is that it cannot represent a switch as a linux device,
    hanging off some bus. It is limited to one CPU port. The DSA platform
    device is artificial, and does not really represent hardware.
    
    Implement a new binding which can be embedded into any type of node on
    a bus to represent one switch device, and its links to other switches.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/dsa/dsa2.c b/net/dsa/dsa2.c
new file mode 100644
index 000000000000..80dfe08db825
--- /dev/null
+++ b/net/dsa/dsa2.c
@@ -0,0 +1,654 @@
+/*
+ * net/dsa/dsa2.c - Hardware switch handling, binding version 2
+ * Copyright (c) 2008-2009 Marvell Semiconductor
+ * Copyright (c) 2013 Florian Fainelli <florian@openwrt.org>
+ * Copyright (c) 2016 Andrew Lunn <andrew@lunn.ch>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/slab.h>
+#include <linux/rtnetlink.h>
+#include <net/dsa.h>
+#include <linux/of.h>
+#include <linux/of_net.h>
+#include "dsa_priv.h"
+
+static LIST_HEAD(dsa_switch_trees);
+static DEFINE_MUTEX(dsa2_mutex);
+
+static struct dsa_switch_tree *dsa_get_dst(u32 tree)
+{
+	struct dsa_switch_tree *dst;
+
+	list_for_each_entry(dst, &dsa_switch_trees, list)
+		if (dst->tree == tree)
+			return dst;
+	return NULL;
+}
+
+static void dsa_free_dst(struct kref *ref)
+{
+	struct dsa_switch_tree *dst = container_of(ref, struct dsa_switch_tree,
+						   refcount);
+
+	list_del(&dst->list);
+	kfree(dst);
+}
+
+static void dsa_put_dst(struct dsa_switch_tree *dst)
+{
+	kref_put(&dst->refcount, dsa_free_dst);
+}
+
+static struct dsa_switch_tree *dsa_add_dst(u32 tree)
+{
+	struct dsa_switch_tree *dst;
+
+	dst = kzalloc(sizeof(*dst), GFP_KERNEL);
+	if (!dst)
+		return NULL;
+	dst->tree = tree;
+	dst->cpu_switch = -1;
+	INIT_LIST_HEAD(&dst->list);
+	list_add_tail(&dsa_switch_trees, &dst->list);
+	kref_init(&dst->refcount);
+
+	return dst;
+}
+
+static void dsa_dst_add_ds(struct dsa_switch_tree *dst,
+			   struct dsa_switch *ds, u32 index)
+{
+	kref_get(&dst->refcount);
+	dst->ds[index] = ds;
+}
+
+static void dsa_dst_del_ds(struct dsa_switch_tree *dst,
+			   struct dsa_switch *ds, u32 index)
+{
+	dst->ds[index] = NULL;
+	kref_put(&dst->refcount, dsa_free_dst);
+}
+
+static bool dsa_port_is_dsa(struct device_node *port)
+{
+	const char *name;
+
+	name = of_get_property(port, "label", NULL);
+	if (!name)
+		return false;
+
+	if (!strcmp(name, "dsa"))
+		return true;
+
+	return false;
+}
+
+static bool dsa_port_is_cpu(struct device_node *port)
+{
+	const char *name;
+
+	name = of_get_property(port, "label", NULL);
+	if (!name)
+		return false;
+
+	if (!strcmp(name, "cpu"))
+		return true;
+
+	return false;
+}
+
+static bool dsa_ds_find_port(struct dsa_switch *ds,
+			     struct device_node *port)
+{
+	u32 index;
+
+	for (index = 0; index < DSA_MAX_PORTS; index++)
+		if (ds->ports[index].dn == port)
+			return true;
+	return false;
+}
+
+static struct dsa_switch *dsa_dst_find_port(struct dsa_switch_tree *dst,
+					    struct device_node *port)
+{
+	struct dsa_switch *ds;
+	u32 index;
+
+	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
+		ds = dst->ds[index];
+		if (!ds)
+			continue;
+
+		if (dsa_ds_find_port(ds, port))
+			return ds;
+	}
+
+	return NULL;
+}
+
+static int dsa_port_complete(struct dsa_switch_tree *dst,
+			     struct dsa_switch *src_ds,
+			     struct device_node *port,
+			     u32 src_port)
+{
+	struct device_node *link;
+	int index;
+	struct dsa_switch *dst_ds;
+
+	for (index = 0;; index++) {
+		link = of_parse_phandle(port, "link", index);
+		if (!link)
+			break;
+
+		dst_ds = dsa_dst_find_port(dst, link);
+		of_node_put(link);
+
+		if (!dst_ds)
+			return 1;
+
+		src_ds->rtable[dst_ds->index] = src_port;
+	}
+
+	return 0;
+}
+
+/* A switch is complete if all the DSA ports phandles point to ports
+ * known in the tree. A return value of 1 means the tree is not
+ * complete. This is not an error condition. A value of 0 is
+ * success.
+ */
+static int dsa_ds_complete(struct dsa_switch_tree *dst, struct dsa_switch *ds)
+{
+	struct device_node *port;
+	u32 index;
+	int err;
+
+	for (index = 0; index < DSA_MAX_PORTS; index++) {
+		port = ds->ports[index].dn;
+		if (!port)
+			continue;
+
+		if (!dsa_port_is_dsa(port))
+			continue;
+
+		err = dsa_port_complete(dst, ds, port, index);
+		if (err != 0)
+			return err;
+
+		ds->dsa_port_mask |= BIT(index);
+	}
+
+	return 0;
+}
+
+/* A tree is complete if all the DSA ports phandles point to ports
+ * known in the tree. A return value of 1 means the tree is not
+ * complete. This is not an error condition. A value of 0 is
+ * success.
+ */
+static int dsa_dst_complete(struct dsa_switch_tree *dst)
+{
+	struct dsa_switch *ds;
+	u32 index;
+	int err;
+
+	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
+		ds = dst->ds[index];
+		if (!ds)
+			continue;
+
+		err = dsa_ds_complete(dst, ds);
+		if (err != 0)
+			return err;
+	}
+
+	return 0;
+}
+
+static int dsa_dsa_port_apply(struct device_node *port, u32 index,
+			      struct dsa_switch *ds)
+{
+	int err;
+
+	err = dsa_cpu_dsa_setup(ds, ds->dev, port, index);
+	if (err) {
+		dev_warn(ds->dev, "Failed to setup dsa port %d: %d\n",
+			 index, err);
+		return err;
+	}
+
+	return 0;
+}
+
+static void dsa_dsa_port_unapply(struct device_node *port, u32 index,
+				 struct dsa_switch *ds)
+{
+	dsa_cpu_dsa_destroy(port);
+}
+
+static int dsa_cpu_port_apply(struct device_node *port, u32 index,
+			      struct dsa_switch *ds)
+{
+	int err;
+
+	err = dsa_cpu_dsa_setup(ds, ds->dev, port, index);
+	if (err) {
+		dev_warn(ds->dev, "Failed to setup cpu port %d: %d\n",
+			 index, err);
+		return err;
+	}
+
+	ds->cpu_port_mask |= BIT(index);
+
+	return 0;
+}
+
+static void dsa_cpu_port_unapply(struct device_node *port, u32 index,
+				 struct dsa_switch *ds)
+{
+	dsa_cpu_dsa_destroy(port);
+	ds->cpu_port_mask &= ~BIT(index);
+
+}
+
+static int dsa_user_port_apply(struct device_node *port, u32 index,
+			       struct dsa_switch *ds)
+{
+	const char *name;
+	int err;
+
+	name = of_get_property(port, "label", NULL);
+
+	err = dsa_slave_create(ds, ds->dev, index, name);
+	if (err) {
+		dev_warn(ds->dev, "Failed to create slave %d: %d\n",
+			 index, err);
+		return err;
+	}
+
+	return 0;
+}
+
+static void dsa_user_port_unapply(struct device_node *port, u32 index,
+				  struct dsa_switch *ds)
+{
+	if (ds->ports[index].netdev) {
+		dsa_slave_destroy(ds->ports[index].netdev);
+		ds->ports[index].netdev = NULL;
+	}
+}
+
+static int dsa_ds_apply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
+{
+	struct device_node *port;
+	u32 index;
+	int err;
+
+	err = ds->drv->setup(ds);
+	if (err < 0)
+		return err;
+
+	err = ds->drv->set_addr(ds, dst->master_netdev->dev_addr);
+	if (err < 0)
+		return err;
+
+	err = ds->drv->set_addr(ds, dst->master_netdev->dev_addr);
+	if (err < 0)
+		return err;
+
+	for (index = 0; index < DSA_MAX_PORTS; index++) {
+		port = ds->ports[index].dn;
+		if (!port)
+			continue;
+
+		if (dsa_port_is_dsa(port)) {
+			err = dsa_dsa_port_apply(port, index, ds);
+			if (err)
+				return err;
+			continue;
+		}
+
+		if (dsa_port_is_cpu(port)) {
+			err = dsa_cpu_port_apply(port, index, ds);
+			if (err)
+				return err;
+			continue;
+		}
+
+		err = dsa_user_port_apply(port, index, ds);
+		if (err)
+			continue;
+	}
+
+	return 0;
+}
+
+static void dsa_ds_unapply(struct dsa_switch_tree *dst, struct dsa_switch *ds)
+{
+	struct device_node *port;
+	u32 index;
+
+	for (index = 0; index < DSA_MAX_PORTS; index++) {
+		port = ds->ports[index].dn;
+		if (!port)
+			continue;
+
+		if (dsa_port_is_dsa(port)) {
+			dsa_dsa_port_unapply(port, index, ds);
+			continue;
+		}
+
+		if (dsa_port_is_cpu(port)) {
+			dsa_cpu_port_unapply(port, index, ds);
+			continue;
+		}
+
+		dsa_user_port_unapply(port, index, ds);
+	}
+}
+
+static int dsa_dst_apply(struct dsa_switch_tree *dst)
+{
+	struct dsa_switch *ds;
+	u32 index;
+	int err;
+
+	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
+		ds = dst->ds[index];
+		if (!ds)
+			continue;
+
+		err = dsa_ds_apply(dst, ds);
+		if (err)
+			return err;
+	}
+
+	/* If we use a tagging format that doesn't have an ethertype
+	 * field, make sure that all packets from this point on get
+	 * sent to the tag format's receive function.
+	 */
+	wmb();
+	dst->master_netdev->dsa_ptr = (void *)dst;
+	dst->applied = true;
+
+	return 0;
+}
+
+static void dsa_dst_unapply(struct dsa_switch_tree *dst)
+{
+	struct dsa_switch *ds;
+	u32 index;
+
+	if (!dst->applied)
+		return;
+
+	dst->master_netdev->dsa_ptr = NULL;
+
+	/* If we used a tagging format that doesn't have an ethertype
+	 * field, make sure that all packets from this point get sent
+	 * without the tag and go through the regular receive path.
+	 */
+	wmb();
+
+	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
+		ds = dst->ds[index];
+		if (!ds)
+			continue;
+
+		dsa_ds_unapply(dst, ds);
+	}
+
+	pr_info("DSA: tree %d unapplied\n", dst->tree);
+	dst->applied = false;
+}
+
+static int dsa_cpu_parse(struct device_node *port, u32 index,
+			 struct dsa_switch_tree *dst,
+			 struct dsa_switch *ds)
+{
+	struct net_device *ethernet_dev;
+	struct device_node *ethernet;
+
+	ethernet = of_parse_phandle(port, "ethernet", 0);
+	if (!ethernet)
+		return -EINVAL;
+
+	ethernet_dev = of_find_net_device_by_node(ethernet);
+	if (!ethernet_dev)
+		return -EPROBE_DEFER;
+
+	if (!ds->master_netdev)
+		ds->master_netdev = ethernet_dev;
+
+	if (!dst->master_netdev)
+		dst->master_netdev = ethernet_dev;
+
+	if (dst->cpu_switch == -1) {
+		dst->cpu_switch = ds->index;
+		dst->cpu_port = index;
+	}
+
+	dst->tag_ops = dsa_resolve_tag_protocol(ds->drv->tag_protocol);
+	if (IS_ERR(dst->tag_ops)) {
+		dev_warn(ds->dev, "No tagger for this switch\n");
+		return PTR_ERR(dst->tag_ops);
+	}
+
+	dst->rcv = dst->tag_ops->rcv;
+
+	return 0;
+}
+
+static int dsa_ds_parse(struct dsa_switch_tree *dst, struct dsa_switch *ds)
+{
+	struct device_node *port;
+	u32 index;
+	int err;
+
+	for (index = 0; index < DSA_MAX_PORTS; index++) {
+		port = ds->ports[index].dn;
+		if (!port)
+			continue;
+
+		if (dsa_port_is_cpu(port)) {
+			err = dsa_cpu_parse(port, index, dst, ds);
+			if (err)
+				return err;
+		}
+	}
+
+	pr_info("DSA: switch %d %d parsed\n", dst->tree, ds->index);
+
+	return 0;
+}
+
+static int dsa_dst_parse(struct dsa_switch_tree *dst)
+{
+	struct dsa_switch *ds;
+	u32 index;
+	int err;
+
+	for (index = 0; index < DSA_MAX_SWITCHES; index++) {
+		ds = dst->ds[index];
+		if (!ds)
+			continue;
+
+		err = dsa_ds_parse(dst, ds);
+		if (err)
+			return err;
+	}
+
+	if (!dst->master_netdev) {
+		pr_warn("Tree has no master device\n");
+		return -EINVAL;
+	}
+
+	pr_info("DSA: tree %d parsed\n", dst->tree);
+
+	return 0;
+}
+
+static int dsa_parse_ports_dn(struct device_node *ports, struct dsa_switch *ds)
+{
+	struct device_node *port;
+	int err;
+	u32 reg;
+
+	for_each_available_child_of_node(ports, port) {
+		err = of_property_read_u32(port, "reg", &reg);
+		if (err)
+			return err;
+
+		if (reg >= DSA_MAX_PORTS)
+			return -EINVAL;
+
+		ds->ports[reg].dn = port;
+	}
+
+	return 0;
+}
+
+static int dsa_parse_member(struct device_node *np, u32 *tree, u32 *index)
+{
+	int err;
+
+	*tree = *index = 0;
+
+	err = of_property_read_u32_index(np, "dsa,member", 0, tree);
+	if (err) {
+		/* Does not exist, but it is optional */
+		if (err == -EINVAL)
+			return 0;
+		return err;
+	}
+
+	err = of_property_read_u32_index(np, "dsa,member", 1, index);
+	if (err)
+		return err;
+
+	if (*index >= DSA_MAX_SWITCHES)
+		return -EINVAL;
+
+	return 0;
+}
+
+static struct device_node *dsa_get_ports(struct dsa_switch *ds,
+					 struct device_node *np)
+{
+	struct device_node *ports;
+
+	ports = of_get_child_by_name(np, "ports");
+	if (!ports) {
+		dev_err(ds->dev, "no ports child node found\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	return ports;
+}
+
+static int _dsa_register_switch(struct dsa_switch *ds, struct device_node *np)
+{
+	struct device_node *ports = dsa_get_ports(ds, np);
+	struct dsa_switch_tree *dst;
+	u32 tree, index;
+	int err;
+
+	err = dsa_parse_member(np, &tree, &index);
+	if (err)
+		return err;
+
+	if (IS_ERR(ports))
+		return PTR_ERR(ports);
+
+	err = dsa_parse_ports_dn(ports, ds);
+	if (err)
+		return err;
+
+	dst = dsa_get_dst(tree);
+	if (!dst) {
+		dst = dsa_add_dst(tree);
+		if (!dst)
+			return -ENOMEM;
+	}
+
+	if (dst->ds[index]) {
+		err = -EBUSY;
+		goto out;
+	}
+
+	ds->dst = dst;
+	ds->index = index;
+	dsa_dst_add_ds(dst, ds, index);
+
+	err = dsa_dst_complete(dst);
+	if (err < 0)
+		goto out_del_dst;
+
+	if (err == 1) {
+		/* Not all switches registered yet */
+		err = 0;
+		goto out;
+	}
+
+	if (dst->applied) {
+		pr_info("DSA: Disjoint trees?\n");
+		return -EINVAL;
+	}
+
+	err = dsa_dst_parse(dst);
+	if (err)
+		goto out_del_dst;
+
+	err = dsa_dst_apply(dst);
+	if (err) {
+		dsa_dst_unapply(dst);
+		goto out_del_dst;
+	}
+
+	dsa_put_dst(dst);
+	return 0;
+
+out_del_dst:
+	dsa_dst_del_ds(dst, ds, ds->index);
+out:
+	dsa_put_dst(dst);
+
+	return err;
+}
+
+int dsa_register_switch(struct dsa_switch *ds, struct device_node *np)
+{
+	int err;
+
+	mutex_lock(&dsa2_mutex);
+	err = _dsa_register_switch(ds, np);
+	mutex_unlock(&dsa2_mutex);
+
+	return err;
+}
+EXPORT_SYMBOL_GPL(dsa_register_switch);
+
+void _dsa_unregister_switch(struct dsa_switch *ds)
+{
+	struct dsa_switch_tree *dst = ds->dst;
+
+	dsa_dst_unapply(dst);
+
+	dsa_dst_del_ds(dst, ds, ds->index);
+}
+
+void dsa_unregister_switch(struct dsa_switch *ds)
+{
+	mutex_lock(&dsa2_mutex);
+	_dsa_unregister_switch(ds);
+	mutex_unlock(&dsa2_mutex);
+}
+EXPORT_SYMBOL_GPL(dsa_unregister_switch);
