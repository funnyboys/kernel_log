commit 6cb5f3ea4654faf8c28b901266e960b1a4787b26
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Apr 23 11:13:49 2020 +0200

    mac80211: populate debugfs only after cfg80211 init
    
    When fixing the initialization race, we neglected to account for
    the fact that debugfs is initialized in wiphy_register(), and
    some debugfs things went missing (or rather were rerooted to the
    global debugfs root).
    
    Fix this by adding debugfs entries only after wiphy_register().
    This requires some changes in the rate control code since it
    currently adds debugfs at alloc time, which can no longer be
    done after the reordering.
    
    Reported-by: Jouni Malinen <j@w1.fi>
    Reported-by: kernel test robot <rong.a.chen@intel.com>
    Reported-by: Hauke Mehrtens <hauke@hauke-m.de>
    Reported-by: Felix Fietkau <nbd@nbd.name>
    Cc: stable@vger.kernel.org
    Fixes: 52e04b4ce5d0 ("mac80211: fix race in ieee80211_register_hw()")
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Acked-by: Sumit Garg <sumit.garg@linaro.org>
    Link: https://lore.kernel.org/r/20200423111344.0e00d3346f12.Iadc76a03a55093d94391fc672e996a458702875d@changeid
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 5397c6dad056..79b44d3db171 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -60,6 +60,29 @@ static inline void rate_control_add_sta_debugfs(struct sta_info *sta)
 #endif
 }
 
+extern const struct file_operations rcname_ops;
+
+static inline void rate_control_add_debugfs(struct ieee80211_local *local)
+{
+#ifdef CONFIG_MAC80211_DEBUGFS
+	struct dentry *debugfsdir;
+
+	if (!local->rate_ctrl)
+		return;
+
+	if (!local->rate_ctrl->ops->add_debugfs)
+		return;
+
+	debugfsdir = debugfs_create_dir("rc", local->hw.wiphy->debugfsdir);
+	local->debugfs.rcdir = debugfsdir;
+	debugfs_create_file("name", 0400, debugfsdir,
+			    local->rate_ctrl, &rcname_ops);
+
+	local->rate_ctrl->ops->add_debugfs(&local->hw, local->rate_ctrl->priv,
+					   debugfsdir);
+#endif
+}
+
 void ieee80211_check_rate_mask(struct ieee80211_sub_if_data *sdata);
 
 /* Get a reference to the rate control algorithm. If `name' is NULL, get the

commit 612fcfd9b31f08858d2a2e1279adda367e1ade00
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Jun 12 16:26:58 2019 +0200

    mac80211: remove unused and unneeded remove_sta_debugfs callback
    
    The remove_sta_debugfs callback in struct rate_control_ops is no longer
    used by any driver, as there is no need for it (the debugfs directory is
    already removed recursivly by the mac80211 core.)  Because no one needs
    it, just remove it to keep anyone else from accidentally using it in the
    future.
    
    Cc: Johannes Berg <johannes@sipsolutions.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: linux-wireless@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Link: https://lore.kernel.org/r/20190612142658.12792-5-gregkh@linuxfoundation.org
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 5d5348bc41ec..5397c6dad056 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -60,15 +60,6 @@ static inline void rate_control_add_sta_debugfs(struct sta_info *sta)
 #endif
 }
 
-static inline void rate_control_remove_sta_debugfs(struct sta_info *sta)
-{
-#ifdef CONFIG_MAC80211_DEBUGFS
-	struct rate_control_ref *ref = sta->rate_ctrl;
-	if (ref && ref->ops->remove_sta_debugfs)
-		ref->ops->remove_sta_debugfs(ref->priv, sta->rate_ctrl_priv);
-#endif
-}
-
 void ieee80211_check_rate_mask(struct ieee80211_sub_if_data *sdata);
 
 /* Get a reference to the rate control algorithm. If `name' is NULL, get the

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index d59198191a79..5d5348bc41ec 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -1,11 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright 2002-2005, Instant802 Networks, Inc.
  * Copyright 2005, Devicescape Software, Inc.
  * Copyright (c) 2006 Jiri Benc <jbenc@suse.cz>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef IEEE80211_RATE_H

commit b1c4f68337fa6b7c09154bb2bf2ec6f0d30ab652
Author: Felix Fietkau <nbd@nbd.name>
Date:   Sat Oct 6 19:35:01 2018 +0200

    mac80211: minstrel: merge with minstrel_ht, always enable VHT support
    
    Legacy-only devices are not very common and the overhead of the extra
    code for HT and VHT rates is not big enough to justify all those extra
    lines of code to make it optional.
    
    Signed-off-by: Felix Fietkau <nbd@nbd.name>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 8212bfeb71d6..d59198191a79 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -95,18 +95,5 @@ static inline void rc80211_minstrel_exit(void)
 }
 #endif
 
-#ifdef CONFIG_MAC80211_RC_MINSTREL_HT
-int rc80211_minstrel_ht_init(void);
-void rc80211_minstrel_ht_exit(void);
-#else
-static inline int rc80211_minstrel_ht_init(void)
-{
-	return 0;
-}
-static inline void rc80211_minstrel_ht_exit(void)
-{
-}
-#endif
-
 
 #endif /* IEEE80211_RATE_H */

commit 18fb84d986b398c59be6729f38f1c4bbbe8c4e9a
Author: Felix Fietkau <nbd@nbd.name>
Date:   Wed Apr 26 17:11:35 2017 +0200

    mac80211: make rate control tx status API more extensible
    
    Rename .tx_status_noskb to .tx_status_ext and pass a new on-stack
    struct ieee80211_tx_status instead of struct ieee80211_tx_info.
    
    This struct can be used to pass extra information, e.g. for dynamic tx
    power control
    
    Signed-off-by: Felix Fietkau <nbd@nbd.name>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index f7825ef5f871..8212bfeb71d6 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -28,47 +28,9 @@ void rate_control_get_rate(struct ieee80211_sub_if_data *sdata,
 			   struct sta_info *sta,
 			   struct ieee80211_tx_rate_control *txrc);
 
-static inline void rate_control_tx_status(struct ieee80211_local *local,
-					  struct ieee80211_supported_band *sband,
-					  struct sta_info *sta,
-					  struct sk_buff *skb)
-{
-	struct rate_control_ref *ref = local->rate_ctrl;
-	struct ieee80211_sta *ista = &sta->sta;
-	void *priv_sta = sta->rate_ctrl_priv;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-
-	if (!ref || !test_sta_flag(sta, WLAN_STA_RATE_CONTROL))
-		return;
-
-	spin_lock_bh(&sta->rate_ctrl_lock);
-	if (ref->ops->tx_status)
-		ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
-	else
-		ref->ops->tx_status_noskb(ref->priv, sband, ista, priv_sta, info);
-	spin_unlock_bh(&sta->rate_ctrl_lock);
-}
-
-static inline void
-rate_control_tx_status_noskb(struct ieee80211_local *local,
-			     struct ieee80211_supported_band *sband,
-			     struct sta_info *sta,
-			     struct ieee80211_tx_info *info)
-{
-	struct rate_control_ref *ref = local->rate_ctrl;
-	struct ieee80211_sta *ista = &sta->sta;
-	void *priv_sta = sta->rate_ctrl_priv;
-
-	if (!ref || !test_sta_flag(sta, WLAN_STA_RATE_CONTROL))
-		return;
-
-	if (WARN_ON_ONCE(!ref->ops->tx_status_noskb))
-		return;
-
-	spin_lock_bh(&sta->rate_ctrl_lock);
-	ref->ops->tx_status_noskb(ref->priv, sband, ista, priv_sta, info);
-	spin_unlock_bh(&sta->rate_ctrl_lock);
-}
+void rate_control_tx_status(struct ieee80211_local *local,
+			    struct ieee80211_supported_band *sband,
+			    struct ieee80211_tx_status *st);
 
 void rate_control_rate_init(struct sta_info *sta);
 void rate_control_rate_update(struct ieee80211_local *local,

commit e8e4f5280ddd0a7b43a795f90a0758e3c99df6a6
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Mar 8 11:12:10 2017 +0100

    mac80211: reject/clear user rate mask if not usable
    
    If the user rate mask results in no (basic) rates being usable,
    clear it. Also, if we're already operating when it's set, reject
    it instead.
    
    Technically, selecting basic rates as the criterion is a bit too
    restrictive, but calculating the usable rates over all stations
    (e.g. in AP mode) is harder, and all stations must support the
    basic rates. Similarly, in client mode, the basic rates will be
    used anyway for control frames.
    
    This fixes the "no supported rates (...) in rate_mask ..." warning
    that occurs on TX when you've selected a rate mask that's not
    compatible with the connection (e.g. an AP that enables only the
    rates 36, 48, 54 and you've selected only 6, 9, 12.)
    
    Reported-by: Kirtika Ruchandani <kirtika@google.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index d51a1cce4d4a..f7825ef5f871 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -110,6 +110,8 @@ static inline void rate_control_remove_sta_debugfs(struct sta_info *sta)
 #endif
 }
 
+void ieee80211_check_rate_mask(struct ieee80211_sub_if_data *sdata);
+
 /* Get a reference to the rate control algorithm. If `name' is NULL, get the
  * first available algorithm. */
 int ieee80211_init_rate_ctrl_alg(struct ieee80211_local *local,

commit a858958b689211dcfe54cdd94c93160d2d659eba
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Feb 15 15:02:07 2017 +0100

    mac80211: remove local pointer from rate_ctrl_ref
    
    This pointer really isn't needed, so remove it.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 8d3260785b94..d51a1cce4d4a 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -20,7 +20,6 @@
 #include "driver-ops.h"
 
 struct rate_control_ref {
-	struct ieee80211_local *local;
 	const struct rate_control_ops *ops;
 	void *priv;
 };

commit fc4a25c5b741ecb4ef4d0f1802775e8a88d7e0a7
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Apr 5 11:59:05 2016 +0200

    mac80211: remove sta_info debugfs sub-struct
    
    Since the previous patch, the struct only has a single member,
    so remove the struct and leave just the single member.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 624fe5b81615..8d3260785b94 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -96,9 +96,9 @@ static inline void rate_control_add_sta_debugfs(struct sta_info *sta)
 {
 #ifdef CONFIG_MAC80211_DEBUGFS
 	struct rate_control_ref *ref = sta->rate_ctrl;
-	if (ref && sta->debugfs.dir && ref->ops->add_sta_debugfs)
+	if (ref && sta->debugfs_dir && ref->ops->add_sta_debugfs)
 		ref->ops->add_sta_debugfs(ref->priv, sta->rate_ctrl_priv,
-					  sta->debugfs.dir);
+					  sta->debugfs_dir);
 #endif
 }
 

commit eb6d9293dfed245a114cad7d975259963e1e04c2
Author: Denys Vlasenko <dvlasenk@redhat.com>
Date:   Wed Jul 15 14:56:06 2015 +0200

    mac80211: deinline rate_control_rate_init, rate_control_rate_update
    
    With this .config: http://busybox.net/~vda/kernel_config,
    after deinlining these functions have sizes and callsite counts
    as follows:
    
    rate_control_rate_init: 554 bytes, 8 calls
    rate_control_rate_update: 1596 bytes, 5 calls
    
    Total size reduction: about 11 kbytes.
    
    Signed-off-by: Denys Vlasenko <dvlasenk@redhat.com>
    CC: John Linville <linville@tuxdriver.com>
    CC: Michal Kazior <michal.kazior@tieto.com>
    CC: Johannes Berg <johannes.berg@intel.com>
    Cc: linux-wireless@vger.kernel.org
    Cc: netdev@vger.kernel.org
    CC: linux-kernel@vger.kernel.org
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 25c9be5dd7fd..624fe5b81615 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -71,64 +71,10 @@ rate_control_tx_status_noskb(struct ieee80211_local *local,
 	spin_unlock_bh(&sta->rate_ctrl_lock);
 }
 
-static inline void rate_control_rate_init(struct sta_info *sta)
-{
-	struct ieee80211_local *local = sta->sdata->local;
-	struct rate_control_ref *ref = sta->rate_ctrl;
-	struct ieee80211_sta *ista = &sta->sta;
-	void *priv_sta = sta->rate_ctrl_priv;
-	struct ieee80211_supported_band *sband;
-	struct ieee80211_chanctx_conf *chanctx_conf;
-
-	ieee80211_sta_set_rx_nss(sta);
-
-	if (!ref)
-		return;
-
-	rcu_read_lock();
-
-	chanctx_conf = rcu_dereference(sta->sdata->vif.chanctx_conf);
-	if (WARN_ON(!chanctx_conf)) {
-		rcu_read_unlock();
-		return;
-	}
-
-	sband = local->hw.wiphy->bands[chanctx_conf->def.chan->band];
-
-	spin_lock_bh(&sta->rate_ctrl_lock);
-	ref->ops->rate_init(ref->priv, sband, &chanctx_conf->def, ista,
-			    priv_sta);
-	spin_unlock_bh(&sta->rate_ctrl_lock);
-	rcu_read_unlock();
-	set_sta_flag(sta, WLAN_STA_RATE_CONTROL);
-}
-
-static inline void rate_control_rate_update(struct ieee80211_local *local,
+void rate_control_rate_init(struct sta_info *sta);
+void rate_control_rate_update(struct ieee80211_local *local,
 				    struct ieee80211_supported_band *sband,
-				    struct sta_info *sta, u32 changed)
-{
-	struct rate_control_ref *ref = local->rate_ctrl;
-	struct ieee80211_sta *ista = &sta->sta;
-	void *priv_sta = sta->rate_ctrl_priv;
-	struct ieee80211_chanctx_conf *chanctx_conf;
-
-	if (ref && ref->ops->rate_update) {
-		rcu_read_lock();
-
-		chanctx_conf = rcu_dereference(sta->sdata->vif.chanctx_conf);
-		if (WARN_ON(!chanctx_conf)) {
-			rcu_read_unlock();
-			return;
-		}
-
-		spin_lock_bh(&sta->rate_ctrl_lock);
-		ref->ops->rate_update(ref->priv, sband, &chanctx_conf->def,
-				      ista, priv_sta, changed);
-		spin_unlock_bh(&sta->rate_ctrl_lock);
-		rcu_read_unlock();
-	}
-	drv_sta_rc_update(local, sta->sdata, &sta->sta, changed);
-}
+				    struct sta_info *sta, u32 changed);
 
 static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,
 					   struct sta_info *sta, gfp_t gfp)

commit 35c347ac53040daba955fa06fcd5f909bee85017
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Mar 5 16:10:08 2015 +0100

    mac80211: lock rate control
    
    Both minstrel (reported by Sven Eckelmann) and the iwlwifi rate
    control aren't properly taking concurrency into account. It's
    likely that the same is true for other rate control algorithms.
    
    In the case of minstrel this manifests itself in crashes when an
    update and other data access are run concurrently, for example
    when the stations change bandwidth or similar. In iwlwifi, this
    can cause firmware crashes.
    
    Since fixing all rate control algorithms will be very difficult,
    just provide locking for invocations. This protects the internal
    data structures the algorithms maintain.
    
    I've manipulated hostapd to test this, by having it change its
    advertised bandwidth roughly ever 150ms. At the same time, I'm
    running a flood ping between the client and the AP, which causes
    this race of update vs. get_rate/status to easily happen on the
    client. With this change, the system survives this test.
    
    Reported-by: Sven Eckelmann <sven@open-mesh.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 38652f09feaf..25c9be5dd7fd 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -42,10 +42,12 @@ static inline void rate_control_tx_status(struct ieee80211_local *local,
 	if (!ref || !test_sta_flag(sta, WLAN_STA_RATE_CONTROL))
 		return;
 
+	spin_lock_bh(&sta->rate_ctrl_lock);
 	if (ref->ops->tx_status)
 		ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
 	else
 		ref->ops->tx_status_noskb(ref->priv, sband, ista, priv_sta, info);
+	spin_unlock_bh(&sta->rate_ctrl_lock);
 }
 
 static inline void
@@ -64,7 +66,9 @@ rate_control_tx_status_noskb(struct ieee80211_local *local,
 	if (WARN_ON_ONCE(!ref->ops->tx_status_noskb))
 		return;
 
+	spin_lock_bh(&sta->rate_ctrl_lock);
 	ref->ops->tx_status_noskb(ref->priv, sband, ista, priv_sta, info);
+	spin_unlock_bh(&sta->rate_ctrl_lock);
 }
 
 static inline void rate_control_rate_init(struct sta_info *sta)
@@ -91,8 +95,10 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 
 	sband = local->hw.wiphy->bands[chanctx_conf->def.chan->band];
 
+	spin_lock_bh(&sta->rate_ctrl_lock);
 	ref->ops->rate_init(ref->priv, sband, &chanctx_conf->def, ista,
 			    priv_sta);
+	spin_unlock_bh(&sta->rate_ctrl_lock);
 	rcu_read_unlock();
 	set_sta_flag(sta, WLAN_STA_RATE_CONTROL);
 }
@@ -115,18 +121,20 @@ static inline void rate_control_rate_update(struct ieee80211_local *local,
 			return;
 		}
 
+		spin_lock_bh(&sta->rate_ctrl_lock);
 		ref->ops->rate_update(ref->priv, sband, &chanctx_conf->def,
 				      ista, priv_sta, changed);
+		spin_unlock_bh(&sta->rate_ctrl_lock);
 		rcu_read_unlock();
 	}
 	drv_sta_rc_update(local, sta->sdata, &sta->sta, changed);
 }
 
 static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,
-					   struct ieee80211_sta *sta,
-					   gfp_t gfp)
+					   struct sta_info *sta, gfp_t gfp)
 {
-	return ref->ops->alloc_sta(ref->priv, sta, gfp);
+	spin_lock_init(&sta->rate_ctrl_lock);
+	return ref->ops->alloc_sta(ref->priv, &sta->sta, gfp);
 }
 
 static inline void rate_control_free_sta(struct sta_info *sta)

commit f027c2aca0cf43e0f15fc8de8841f7b566163d94
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Wed Nov 19 20:08:13 2014 +0100

    mac80211: add ieee80211_tx_status_noskb
    
    This can be used by drivers that cannot reliably map tx status
    information onto specific skbs.
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index dd25964a300a..38652f09feaf 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -48,6 +48,24 @@ static inline void rate_control_tx_status(struct ieee80211_local *local,
 		ref->ops->tx_status_noskb(ref->priv, sband, ista, priv_sta, info);
 }
 
+static inline void
+rate_control_tx_status_noskb(struct ieee80211_local *local,
+			     struct ieee80211_supported_band *sband,
+			     struct sta_info *sta,
+			     struct ieee80211_tx_info *info)
+{
+	struct rate_control_ref *ref = local->rate_ctrl;
+	struct ieee80211_sta *ista = &sta->sta;
+	void *priv_sta = sta->rate_ctrl_priv;
+
+	if (!ref || !test_sta_flag(sta, WLAN_STA_RATE_CONTROL))
+		return;
+
+	if (WARN_ON_ONCE(!ref->ops->tx_status_noskb))
+		return;
+
+	ref->ops->tx_status_noskb(ref->priv, sband, ista, priv_sta, info);
+}
 
 static inline void rate_control_rate_init(struct sta_info *sta)
 {

commit f684565e0af43586bfc3e005d173f94b0f902a5d
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Wed Nov 19 20:08:08 2014 +0100

    mac80211: add tx_status_noskb to rate_control_ops
    
    This op works like .tx_status, except it does not need access to the
    skb. This will be used by drivers that cannot match tx status
    information to specific packets.
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 18babe302832..dd25964a300a 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -37,11 +37,15 @@ static inline void rate_control_tx_status(struct ieee80211_local *local,
 	struct rate_control_ref *ref = local->rate_ctrl;
 	struct ieee80211_sta *ista = &sta->sta;
 	void *priv_sta = sta->rate_ctrl_priv;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 
 	if (!ref || !test_sta_flag(sta, WLAN_STA_RATE_CONTROL))
 		return;
 
-	ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
+	if (ref->ops->tx_status)
+		ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
+	else
+		ref->ops->tx_status_noskb(ref->priv, sband, ista, priv_sta, info);
 }
 
 

commit 20edb50e593dca7522b4f3a95b801dbf99f24c52
Author: John W. Linville <linville@tuxdriver.com>
Date:   Fri May 30 10:47:28 2014 -0400

    mac80211: remove PID rate control
    
    Minstrel has long since proven its worth.
    
    Signed-off-by: John W. Linville <linville@tuxdriver.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 9aa2a1190a86..18babe302832 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -143,19 +143,6 @@ void rate_control_deinitialize(struct ieee80211_local *local);
 
 
 /* Rate control algorithms */
-#ifdef CONFIG_MAC80211_RC_PID
-int rc80211_pid_init(void);
-void rc80211_pid_exit(void);
-#else
-static inline int rc80211_pid_init(void)
-{
-	return 0;
-}
-static inline void rc80211_pid_exit(void)
-{
-}
-#endif
-
 #ifdef CONFIG_MAC80211_RC_MINSTREL
 int rc80211_minstrel_init(void);
 void rc80211_minstrel_exit(void);

commit 631ad703ba3a585e96acbfd2ac8c0f0fee1ad99b
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Jan 20 23:29:34 2014 +0100

    mac80211: make rate control ops const
    
    Change the code to allow making all the rate control ops
    const, nothing ever needs to change them. Also change all
    drivers to make use of this and mark the ops const.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index b95e16c07081..9aa2a1190a86 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -21,7 +21,7 @@
 
 struct rate_control_ref {
 	struct ieee80211_local *local;
-	struct rate_control_ops *ops;
+	const struct rate_control_ops *ops;
 	void *priv;
 };
 

commit 4b074b07625f603d40d4d04937f8874a00415dc4
Merge: 7d68849f40cd ddcc347b70f2
Author: John W. Linville <linville@tuxdriver.com>
Date:   Mon Dec 2 14:25:38 2013 -0500

    Merge branch 'for-john' of git://git.kernel.org/pub/scm/linux/kernel/git/jberg/mac80211-next

commit ddcc347b70f298f9d624cd0e250581d831d915fb
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Mon Dec 2 11:54:07 2013 +0100

    mac80211: fix rx_nss calculation for drivers with hw rc
    
    Drivers with hardware rate control were given
    sta->rx_nss set to 0. This was because rx_nss
    calculation procedure was protected by hw/sw rate
    control check.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 5dedc56c94db..32cdbd22c5f1 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -54,6 +54,8 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 	struct ieee80211_supported_band *sband;
 	struct ieee80211_chanctx_conf *chanctx_conf;
 
+	ieee80211_sta_set_rx_nss(sta);
+
 	if (!ref)
 		return;
 
@@ -67,8 +69,6 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 
 	sband = local->hw.wiphy->bands[chanctx_conf->def.chan->band];
 
-	ieee80211_sta_set_rx_nss(sta);
-
 	ref->ops->rate_init(ref->priv, sband, &chanctx_conf->def, ista,
 			    priv_sta);
 	rcu_read_unlock();

commit c1b1203d65955c179fec617ff17a21273f33a414
Author: Joe Perches <joe@perches.com>
Date:   Fri Oct 18 13:48:25 2013 -0700

    net: misc: Remove extern from function prototypes
    
    There are a mix of function prototypes with and without extern
    in the kernel sources.  Standardize on not using extern for
    function prototypes.
    
    Function prototypes don't need to be written with extern.
    extern is assumed by the compiler.  Its use is as unnecessary as
    using auto to declare automatic/local variables in a block.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 5dedc56c94db..505bc0dea074 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -144,8 +144,8 @@ void rate_control_deinitialize(struct ieee80211_local *local);
 
 /* Rate control algorithms */
 #ifdef CONFIG_MAC80211_RC_PID
-extern int rc80211_pid_init(void);
-extern void rc80211_pid_exit(void);
+int rc80211_pid_init(void);
+void rc80211_pid_exit(void);
 #else
 static inline int rc80211_pid_init(void)
 {
@@ -157,8 +157,8 @@ static inline void rc80211_pid_exit(void)
 #endif
 
 #ifdef CONFIG_MAC80211_RC_MINSTREL
-extern int rc80211_minstrel_init(void);
-extern void rc80211_minstrel_exit(void);
+int rc80211_minstrel_init(void);
+void rc80211_minstrel_exit(void);
 #else
 static inline int rc80211_minstrel_init(void)
 {
@@ -170,8 +170,8 @@ static inline void rc80211_minstrel_exit(void)
 #endif
 
 #ifdef CONFIG_MAC80211_RC_MINSTREL_HT
-extern int rc80211_minstrel_ht_init(void);
-extern void rc80211_minstrel_ht_exit(void);
+int rc80211_minstrel_ht_init(void);
+void rc80211_minstrel_ht_exit(void);
 #else
 static inline int rc80211_minstrel_ht_init(void)
 {

commit 3de805cf965d69c8d3d7d69368d5fd2c925a2d5a
Author: Simon Wunderlich <simon.wunderlich@s2003.tu-chemnitz.de>
Date:   Mon Jul 8 16:55:50 2013 +0200

    mac80211/rc80211: add chandef to rate initialization
    
    5 and 10 MHz support needs to know the current operating channel width,
    add the chandef to the rate control API.
    
    Signed-off-by: Simon Wunderlich <siwu@hrz.tu-chemnitz.de>
    Signed-off-by: Mathias Kretschmer <mathias.kretschmer@fokus.fraunhofer.de>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index d35a5dd3fb13..5dedc56c94db 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -66,11 +66,12 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 	}
 
 	sband = local->hw.wiphy->bands[chanctx_conf->def.chan->band];
-	rcu_read_unlock();
 
 	ieee80211_sta_set_rx_nss(sta);
 
-	ref->ops->rate_init(ref->priv, sband, ista, priv_sta);
+	ref->ops->rate_init(ref->priv, sband, &chanctx_conf->def, ista,
+			    priv_sta);
+	rcu_read_unlock();
 	set_sta_flag(sta, WLAN_STA_RATE_CONTROL);
 }
 
@@ -81,10 +82,21 @@ static inline void rate_control_rate_update(struct ieee80211_local *local,
 	struct rate_control_ref *ref = local->rate_ctrl;
 	struct ieee80211_sta *ista = &sta->sta;
 	void *priv_sta = sta->rate_ctrl_priv;
+	struct ieee80211_chanctx_conf *chanctx_conf;
+
+	if (ref && ref->ops->rate_update) {
+		rcu_read_lock();
 
-	if (ref && ref->ops->rate_update)
-		ref->ops->rate_update(ref->priv, sband, ista,
-				      priv_sta, changed);
+		chanctx_conf = rcu_dereference(sta->sdata->vif.chanctx_conf);
+		if (WARN_ON(!chanctx_conf)) {
+			rcu_read_unlock();
+			return;
+		}
+
+		ref->ops->rate_update(ref->priv, sband, &chanctx_conf->def,
+				      ista, priv_sta, changed);
+		rcu_read_unlock();
+	}
 	drv_sta_rc_update(local, sta->sdata, &sta->sta, changed);
 }
 

commit 8921d04e8df7475d733d853564bdb001e83bf33f
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Dec 27 18:26:42 2012 +0100

    mac80211: track number of spatial streams
    
    With VHT, a station can change the number of spatial
    streams it can receive on the fly, not unlike spatial
    multiplexing in HT. Prepare for that by tracking the
    maximum number of spatial streams it can receive when
    the connection is established.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 301386dabf88..d35a5dd3fb13 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -68,6 +68,8 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 	sband = local->hw.wiphy->bands[chanctx_conf->def.chan->band];
 	rcu_read_unlock();
 
+	ieee80211_sta_set_rx_nss(sta);
+
 	ref->ops->rate_init(ref->priv, sband, ista, priv_sta);
 	set_sta_flag(sta, WLAN_STA_RATE_CONTROL);
 }

commit 4bf88530be971bf95a7830ca61b4120980bf4347
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Nov 9 11:39:59 2012 +0100

    mac80211: convert to channel definition struct
    
    Convert mac80211 (and where necessary, some drivers a
    little bit) to the new channel definition struct.
    
    This will allow extending mac80211 for VHT, which is
    currently restricted to channel contexts since there
    are no drivers using that which makes it easier. As
    I also don't care about VHT for drivers not using the
    channel context API, I won't convert the previous API
    to VHT support.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index ec198ef6aa8a..301386dabf88 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -65,7 +65,7 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 		return;
 	}
 
-	sband = local->hw.wiphy->bands[chanctx_conf->channel->band];
+	sband = local->hw.wiphy->bands[chanctx_conf->def.chan->band];
 	rcu_read_unlock();
 
 	ref->ops->rate_init(ref->priv, sband, ista, priv_sta);

commit 55de908ab292c03f1eb280f51170ddb9c6b57e31
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Jul 26 17:24:39 2012 +0200

    mac80211: use channel contexts
    
    Instead of operating on a single channel only,
    use the new channel context infrastructure in
    all mac80211 code.
    
    This enables drivers that want to use the new
    channel context infrastructure to use multiple
    channels, while nothing should change for all
    the other drivers that don't support it.
    
    Right now this disables both TX power settings
    and spatial multiplexing powersave. Both need
    to be re-enabled on a channel context basis.
    
    Additionally, when channel contexts are used
    drop the connection when channel switch is
    received rather than trying to handle it. This
    will have to be improved later.
    
    [With fixes from Eliad and Emmanuel incorporated]
    Signed-off-by: Eliad Peller <eliad@wizery.com>
    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 10de668eb9f6..ec198ef6aa8a 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -52,11 +52,21 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 	struct ieee80211_sta *ista = &sta->sta;
 	void *priv_sta = sta->rate_ctrl_priv;
 	struct ieee80211_supported_band *sband;
+	struct ieee80211_chanctx_conf *chanctx_conf;
 
 	if (!ref)
 		return;
 
-	sband = local->hw.wiphy->bands[local->oper_channel->band];
+	rcu_read_lock();
+
+	chanctx_conf = rcu_dereference(sta->sdata->vif.chanctx_conf);
+	if (WARN_ON(!chanctx_conf)) {
+		rcu_read_unlock();
+		return;
+	}
+
+	sband = local->hw.wiphy->bands[chanctx_conf->channel->band];
+	rcu_read_unlock();
 
 	ref->ops->rate_init(ref->priv, sband, ista, priv_sta);
 	set_sta_flag(sta, WLAN_STA_RATE_CONTROL);

commit f9e6e95b63758202fe2ce43bd7c922db2ff50f80
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Jul 23 14:29:21 2012 +0200

    mac80211: use oper_channel in rate init
    
    Using hw.conf.channel is wrong as it could be the
    temporary channel if the station is added from the
    workqueue while the device is already on another
    channel. Use oper_channel instead.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 6e4fd32c6617..10de668eb9f6 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -56,7 +56,7 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 	if (!ref)
 		return;
 
-	sband = local->hw.wiphy->bands[local->hw.conf.channel->band];
+	sband = local->hw.wiphy->bands[local->oper_channel->band];
 
 	ref->ops->rate_init(ref->priv, sband, ista, priv_sta);
 	set_sta_flag(sta, WLAN_STA_RATE_CONTROL);

commit 8f727ef3c4859f2c397a7609beb845dcd66729f5
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Mar 30 08:43:32 2012 +0200

    mac80211: notify driver of rate control updates
    
    Devices that have internal rate control need to be
    notified when the bandwidth or SMPS state changes
    just like external rate control algorithms get a
    notification now.
    
    Add this notification and clarify the change bits
    while at it, the HT_CHANGED bit really meant only
    bandwidth changed.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 27b66be8ac8f..6e4fd32c6617 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -17,6 +17,7 @@
 #include <net/mac80211.h>
 #include "ieee80211_i.h"
 #include "sta_info.h"
+#include "driver-ops.h"
 
 struct rate_control_ref {
 	struct ieee80211_local *local;
@@ -72,6 +73,7 @@ static inline void rate_control_rate_update(struct ieee80211_local *local,
 	if (ref && ref->ops->rate_update)
 		ref->ops->rate_update(ref->priv, sband, ista,
 				      priv_sta, changed);
+	drv_sta_rc_update(local, sta->sdata, &sta->sta, changed);
 }
 
 static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,

commit 64f68e5d15bee47e0d6d0c57a1cf52cedd9b3527
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Mar 28 10:58:37 2012 +0200

    mac80211: remove channel type argument from rate_update
    
    The channel type argument to the rate_update()
    callback isn't really the correct way to give
    the rate control algorithm about the desired
    RX bandwidth of the peer.
    
    Remove this argument, and instead update the
    STA capabilities with 20/40 appropriately. The
    SMPS update done by this callback works in the
    same way, so this makes the callback cleaner.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index fbb1efdc4d04..27b66be8ac8f 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -63,8 +63,7 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 
 static inline void rate_control_rate_update(struct ieee80211_local *local,
 				    struct ieee80211_supported_band *sband,
-				    struct sta_info *sta, u32 changed,
-				    enum nl80211_channel_type oper_chan_type)
+				    struct sta_info *sta, u32 changed)
 {
 	struct rate_control_ref *ref = local->rate_ctrl;
 	struct ieee80211_sta *ista = &sta->sta;
@@ -72,7 +71,7 @@ static inline void rate_control_rate_update(struct ieee80211_local *local,
 
 	if (ref && ref->ops->rate_update)
 		ref->ops->rate_update(ref->priv, sband, ista,
-				      priv_sta, changed, oper_chan_type);
+				      priv_sta, changed);
 }
 
 static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,

commit 2cfc6fc584a65db87935ca4e4d5e1ad89d5192ee
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Wed Feb 8 19:17:11 2012 +0100

    mac80211: do not call rate control .tx_status before .rate_init
    
    Most rate control implementations assume .get_rate and .tx_status are only
    called once the per-station data has been fully initialized.
    minstrel_ht crashes if this assumption is violated.
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Tested-by: Arend van Spriel <arend@broadcom.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 5fc3135a6b45..fbb1efdc4d04 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -37,7 +37,7 @@ static inline void rate_control_tx_status(struct ieee80211_local *local,
 	struct ieee80211_sta *ista = &sta->sta;
 	void *priv_sta = sta->rate_ctrl_priv;
 
-	if (!ref)
+	if (!ref || !test_sta_flag(sta, WLAN_STA_RATE_CONTROL))
 		return;
 
 	ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);

commit e1936e9407138b483e6d1332dd944afec8131f30
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jan 20 13:55:23 2012 +0100

    mac80211: call rate control only after init
    
    There are situations where we don't have the
    necessary rate control information yet for
    station entries, e.g. when associating. This
    currently doesn't really happen due to the
    dummy station handling; explicitly disabling
    rate control when it's not initialised will
    allow us to remove dummy stations.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 8268457bd143..5fc3135a6b45 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -58,6 +58,7 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 	sband = local->hw.wiphy->bands[local->hw.conf.channel->band];
 
 	ref->ops->rate_init(ref->priv, sband, ista, priv_sta);
+	set_sta_flag(sta, WLAN_STA_RATE_CONTROL);
 }
 
 static inline void rate_control_rate_update(struct ieee80211_local *local,

commit 889cbb911a195b832745f77240f547cb2a2885bc
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Jan 17 10:33:29 2012 +0100

    mac80211: clean up rate control code
    
    It seems exceedingly unlikely that we'll ever
    support swapping rate control algorithms at
    runtime, so remove the unused refcounting code.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 168427b0ffdc..8268457bd143 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -14,7 +14,6 @@
 #include <linux/netdevice.h>
 #include <linux/skbuff.h>
 #include <linux/types.h>
-#include <linux/kref.h>
 #include <net/mac80211.h>
 #include "ieee80211_i.h"
 #include "sta_info.h"
@@ -23,14 +22,11 @@ struct rate_control_ref {
 	struct ieee80211_local *local;
 	struct rate_control_ops *ops;
 	void *priv;
-	struct kref kref;
 };
 
 void rate_control_get_rate(struct ieee80211_sub_if_data *sdata,
 			   struct sta_info *sta,
 			   struct ieee80211_tx_rate_control *txrc);
-struct rate_control_ref *rate_control_get(struct rate_control_ref *ref);
-void rate_control_put(struct rate_control_ref *ref);
 
 static inline void rate_control_tx_status(struct ieee80211_local *local,
 					  struct ieee80211_supported_band *sband,

commit ec8aa669b8393b6789b1954d587c63264af7ff99
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Thu May 13 16:48:03 2010 +0200

    mac80211: add the minstrel_ht rate control algorithm
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 065a96190e32..168427b0ffdc 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -147,5 +147,18 @@ static inline void rc80211_minstrel_exit(void)
 }
 #endif
 
+#ifdef CONFIG_MAC80211_RC_MINSTREL_HT
+extern int rc80211_minstrel_ht_init(void);
+extern void rc80211_minstrel_ht_exit(void);
+#else
+static inline int rc80211_minstrel_ht_init(void)
+{
+	return 0;
+}
+static inline void rc80211_minstrel_ht_exit(void)
+{
+}
+#endif
+
 
 #endif /* IEEE80211_RATE_H */

commit 4fa004373133ece3d9b1c0a7e243b0e53760b165
Author: Sujith <Sujith.Manoharan@atheros.com>
Date:   Mon Mar 1 14:42:57 2010 +0530

    mac80211: Fix HT rate control configuration
    
    Handling HT configuration changes involved setting the channel
    with the new HT parameters and then issuing a rate_update()
    notification to the driver.
    
    This behavior changed after the off-channel changes. Now, the channel
    is not updated with the new HT params in enable_ht() - instead, it
    is now done when the scan work terminates. This results in the driver
    depending on stale information, defaulting to non-HT mode always.
    
    Fix this by passing the new channel type to the driver.
    
    Cc: stable@kernel.org
    Signed-off-by: Sujith <Sujith.Manoharan@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index b6108bca96d4..065a96190e32 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -66,7 +66,8 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 
 static inline void rate_control_rate_update(struct ieee80211_local *local,
 				    struct ieee80211_supported_band *sband,
-				    struct sta_info *sta, u32 changed)
+				    struct sta_info *sta, u32 changed,
+				    enum nl80211_channel_type oper_chan_type)
 {
 	struct rate_control_ref *ref = local->rate_ctrl;
 	struct ieee80211_sta *ista = &sta->sta;
@@ -74,7 +75,7 @@ static inline void rate_control_rate_update(struct ieee80211_local *local,
 
 	if (ref && ref->ops->rate_update)
 		ref->ops->rate_update(ref->priv, sband, ista,
-				      priv_sta, changed);
+				      priv_sta, changed, oper_chan_type);
 }
 
 static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,

commit 209c671db7a917740ab9873d442b10ae7e369937
Author: Andres Salomon <dilinger@collabora.co.uk>
Date:   Sun Feb 7 21:47:50 2010 -0500

    mac80211: make rate_control_alloc static
    
    rate_control_alloc is not used by anything outside of
    ieee80211_init_rate_ctrl_alg.  Both are in rate.c; there's no reason to make
    rate_control_alloc visible outside of it.
    
    Signed-off-by: Andres Salomon <dilinger@collabora.co.uk>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 998cf7a935b6..b6108bca96d4 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -26,10 +26,6 @@ struct rate_control_ref {
 	struct kref kref;
 };
 
-/* Get a reference to the rate control algorithm. If `name' is NULL, get the
- * first available algorithm. */
-struct rate_control_ref *rate_control_alloc(const char *name,
-					    struct ieee80211_local *local);
 void rate_control_get_rate(struct ieee80211_sub_if_data *sdata,
 			   struct sta_info *sta,
 			   struct ieee80211_tx_rate_control *txrc);
@@ -116,7 +112,8 @@ static inline void rate_control_remove_sta_debugfs(struct sta_info *sta)
 #endif
 }
 
-/* functions for rate control related to a device */
+/* Get a reference to the rate control algorithm. If `name' is NULL, get the
+ * first available algorithm. */
 int ieee80211_init_rate_ctrl_alg(struct ieee80211_local *local,
 				 const char *name);
 void rate_control_deinitialize(struct ieee80211_local *local);

commit 3c384053ce4cb1949f5575c28e30e6ceea8cb39b
Author: Vasanthakumar <vasanth@atheros.com>
Date:   Mon Feb 1 18:49:07 2010 +0530

    mac80211: Don't call rate control when HW handles it
    
    Rate control should not be called to update the tx status
    when HW does the RC.
    
    Signed-off-by: Vasanthakumar <vasanth@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 669dddd40521..998cf7a935b6 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -44,6 +44,10 @@ static inline void rate_control_tx_status(struct ieee80211_local *local,
 	struct rate_control_ref *ref = local->rate_ctrl;
 	struct ieee80211_sta *ista = &sta->sta;
 	void *priv_sta = sta->rate_ctrl_priv;
+
+	if (!ref)
+		return;
+
 	ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
 }
 

commit 37eb0b164cf9fa9f70c8500926f5cde7c652f48e
Author: Jouni Malinen <jouni.malinen@atheros.com>
Date:   Wed Jan 6 13:09:08 2010 +0200

    cfg80211/mac80211: Use more generic bitrate mask for rate control
    
    Extend struct cfg80211_bitrate_mask to actually use a bitfield mask
    instead of just a single fixed or maximum rate index. This change
    itself does not modify the behavior (except for debugfs files), but it
    prepares cfg80211 and mac80211 for a new nl80211 command for setting
    which rates can be used in TX rate control.
    
    Since frames are now going through the rate control algorithm
    unconditionally, the internal IEEE80211_TX_INTFL_RCALGO flag can now
    be removed. The RC implementations can use the rate_idx_mask value to
    optimize their behavior if only a single rate is enabled.
    
    The old max_rate_idx in struct ieee80211_tx_rate_control is maintained
    (but commented as deprecated) for backwards compatibility with existing
    RC implementations. Once these implementations have been updated to
    use the more generic rate_idx_mask, the max_rate_idx value can be
    removed.
    
    Signed-off-by: Jouni Malinen <jouni.malinen@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index cb9bd1f65e27..669dddd40521 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -44,10 +44,7 @@ static inline void rate_control_tx_status(struct ieee80211_local *local,
 	struct rate_control_ref *ref = local->rate_ctrl;
 	struct ieee80211_sta *ista = &sta->sta;
 	void *priv_sta = sta->rate_ctrl_priv;
-	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
-
-	if (likely(info->flags & IEEE80211_TX_INTFL_RCALGO))
-		ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
+	ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
 }
 
 

commit af65cd96dd4ea8ea5adc6ee850e61a407cd1067a
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Nov 17 18:18:36 2009 +0100

    mac80211: make software rate control optional
    
    Some devices implement the entire rate control in
    firmware in some way, like wl1271 or like iwlwifi
    which does some things in software but not a lot.
    Therefore generic software rate control is rather
    useless for them and just adds avoidable overhead
    to the transmit path.
    
    It's fairly simple to let drivers indicate that
    they do not need rate control, but they need to
    fulfil a number of conditions that we encode in
    WARN_ONs.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 2ab5ad9e71ce..cb9bd1f65e27 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -59,6 +59,9 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 	void *priv_sta = sta->rate_ctrl_priv;
 	struct ieee80211_supported_band *sband;
 
+	if (!ref)
+		return;
+
 	sband = local->hw.wiphy->bands[local->hw.conf.channel->band];
 
 	ref->ops->rate_init(ref->priv, sband, ista, priv_sta);
@@ -72,7 +75,7 @@ static inline void rate_control_rate_update(struct ieee80211_local *local,
 	struct ieee80211_sta *ista = &sta->sta;
 	void *priv_sta = sta->rate_ctrl_priv;
 
-	if (ref->ops->rate_update)
+	if (ref && ref->ops->rate_update)
 		ref->ops->rate_update(ref->priv, sband, ista,
 				      priv_sta, changed);
 }
@@ -97,7 +100,7 @@ static inline void rate_control_add_sta_debugfs(struct sta_info *sta)
 {
 #ifdef CONFIG_MAC80211_DEBUGFS
 	struct rate_control_ref *ref = sta->rate_ctrl;
-	if (sta->debugfs.dir && ref->ops->add_sta_debugfs)
+	if (ref && sta->debugfs.dir && ref->ops->add_sta_debugfs)
 		ref->ops->add_sta_debugfs(ref->priv, sta->rate_ctrl_priv,
 					  sta->debugfs.dir);
 #endif
@@ -107,7 +110,7 @@ static inline void rate_control_remove_sta_debugfs(struct sta_info *sta)
 {
 #ifdef CONFIG_MAC80211_DEBUGFS
 	struct rate_control_ref *ref = sta->rate_ctrl;
-	if (ref->ops->remove_sta_debugfs)
+	if (ref && ref->ops->remove_sta_debugfs)
 		ref->ops->remove_sta_debugfs(ref->priv, sta->rate_ctrl_priv);
 #endif
 }

commit 2b874e83c970b45c328ab12239b066a43505454c
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Mar 23 14:10:22 2009 +0100

    mac80211: rate control status only for controlled packets
    
    This patch changes mac80211 to not notify the rate control algorithm's
    tx_status() method when reporting status for a packet that didn't go
    through the rate control algorithm's get_rate() method.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index b9164c9a9563..2ab5ad9e71ce 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -44,8 +44,10 @@ static inline void rate_control_tx_status(struct ieee80211_local *local,
 	struct rate_control_ref *ref = local->rate_ctrl;
 	struct ieee80211_sta *ista = &sta->sta;
 	void *priv_sta = sta->rate_ctrl_priv;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
 
-	ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
+	if (likely(info->flags & IEEE80211_TX_INTFL_RCALGO))
+		ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
 }
 
 

commit 81cb7623ad3b408f871fa36b774fc20d8dfccac0
Author: Sujith <Sujith.Manoharan@atheros.com>
Date:   Thu Feb 12 11:38:37 2009 +0530

    mac80211: Extend the rate control API with an update callback
    
    The AP can switch dynamically between 20/40 Mhz channel width,
    in which case we switch the local operating channel, but the
    rate control algorithm is not notified. This patch adds a new callback
    to indicate such changes to the RC algorithm.
    
    Currently, HT channel width change is notified, but this callback
    can be used to indicate any new requirements that might come up later on.
    
    Signed-off-by: Sujith <Sujith.Manoharan@atheros.com>
    Acked-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 928da625e281..b9164c9a9563 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -62,6 +62,18 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 	ref->ops->rate_init(ref->priv, sband, ista, priv_sta);
 }
 
+static inline void rate_control_rate_update(struct ieee80211_local *local,
+				    struct ieee80211_supported_band *sband,
+				    struct sta_info *sta, u32 changed)
+{
+	struct rate_control_ref *ref = local->rate_ctrl;
+	struct ieee80211_sta *ista = &sta->sta;
+	void *priv_sta = sta->rate_ctrl_priv;
+
+	if (ref->ops->rate_update)
+		ref->ops->rate_update(ref->priv, sband, ista,
+				      priv_sta, changed);
+}
 
 static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,
 					   struct ieee80211_sta *sta,

commit 50fb2e4572141770380f5919793c6e575fa3474b
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Oct 16 11:21:49 2008 +0200

    mac80211: remove rate_control_clear
    
    "Clearing" the rate control algorithm is pointless, none of
    the algorithms actually uses this operation and it's not even
    invoked properly for all channel switching. Also, there's no
    need to since rate control algorithms work per station.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 7c25edf9ac55..928da625e281 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -63,12 +63,6 @@ static inline void rate_control_rate_init(struct sta_info *sta)
 }
 
 
-static inline void rate_control_clear(struct ieee80211_local *local)
-{
-	struct rate_control_ref *ref = local->rate_ctrl;
-	ref->ops->clear(ref->priv);
-}
-
 static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,
 					   struct ieee80211_sta *sta,
 					   gfp_t gfp)

commit e6a9854b05c1a6af1308fe2b8c68f35abf28a3ee
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Oct 21 12:40:02 2008 +0200

    mac80211/drivers: rewrite the rate control API
    
    So after the previous changes we were still unhappy with how
    convoluted the API is and decided to make things simpler for
    everybody. This completely changes the rate control API, now
    taking into account 802.11n with MCS rates and more control,
    most drivers don't support that though.
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index d0092f847f82..7c25edf9ac55 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -31,9 +31,8 @@ struct rate_control_ref {
 struct rate_control_ref *rate_control_alloc(const char *name,
 					    struct ieee80211_local *local);
 void rate_control_get_rate(struct ieee80211_sub_if_data *sdata,
-			   struct ieee80211_supported_band *sband,
-			   struct sta_info *sta, struct sk_buff *skb,
-			   struct rate_selection *sel);
+			   struct sta_info *sta,
+			   struct ieee80211_tx_rate_control *txrc);
 struct rate_control_ref *rate_control_get(struct rate_control_ref *ref);
 void rate_control_put(struct rate_control_ref *ref);
 

commit cccf129f820e431d84690729254a32f1709328fb
Author: Felix Fietkau <nbd@openwrt.org>
Date:   Sun Oct 5 18:07:45 2008 +0200

    mac80211: add the 'minstrel' rate control algorithm
    
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index eb94e584d24e..d0092f847f82 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -125,4 +125,18 @@ static inline void rc80211_pid_exit(void)
 }
 #endif
 
+#ifdef CONFIG_MAC80211_RC_MINSTREL
+extern int rc80211_minstrel_init(void);
+extern void rc80211_minstrel_exit(void);
+#else
+static inline int rc80211_minstrel_init(void)
+{
+	return 0;
+}
+static inline void rc80211_minstrel_exit(void)
+{
+}
+#endif
+
+
 #endif /* IEEE80211_RATE_H */

commit 4b7679a561e552eeda1e3567119bef2bca99b66e
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Sep 18 18:14:18 2008 +0200

    mac80211: clean up rate control API
    
    Long awaited, hard work. This patch totally cleans up the rate control
    API to remove the requirement to include internal headers outside of
    net/mac80211/.
    
    There's one internal use in the PID algorithm left for mesh networking,
    we'll have to figure out a way to clean that one up and decide how to
    do the peer link evaluation, possibly independent of the rate control
    algorithm or via new API.
    
    Additionally, ath9k is left using the cross-inclusion hack for now, we
    will add new API where necessary to make this work properly, but right
    now I'm not expert enough to do it. It's still off better than before.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 5f18c27eb900..eb94e584d24e 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -19,77 +19,48 @@
 #include "ieee80211_i.h"
 #include "sta_info.h"
 
-/**
- * struct rate_selection - rate selection for rate control algos
- * @rate: selected transmission rate index
- * @nonerp: Non-ERP rate to use instead if ERP cannot be used
- * @probe: rate for probing (or -1)
- *
- */
-struct rate_selection {
-	s8 rate_idx, nonerp_idx, probe_idx;
-};
-
-struct rate_control_ops {
-	struct module *module;
-	const char *name;
-	void (*tx_status)(void *priv, struct net_device *dev,
-			  struct sk_buff *skb);
-	void (*get_rate)(void *priv, struct net_device *dev,
-			 struct ieee80211_supported_band *band,
-			 struct sk_buff *skb,
-			 struct rate_selection *sel);
-	void (*rate_init)(void *priv, void *priv_sta,
-			  struct ieee80211_local *local, struct sta_info *sta);
-	void (*clear)(void *priv);
-
-	void *(*alloc)(struct ieee80211_local *local);
-	void (*free)(void *priv);
-	void *(*alloc_sta)(void *priv, gfp_t gfp);
-	void (*free_sta)(void *priv, void *priv_sta);
-
-	int (*add_attrs)(void *priv, struct kobject *kobj);
-	void (*remove_attrs)(void *priv, struct kobject *kobj);
-	void (*add_sta_debugfs)(void *priv, void *priv_sta,
-				struct dentry *dir);
-	void (*remove_sta_debugfs)(void *priv, void *priv_sta);
-};
-
 struct rate_control_ref {
+	struct ieee80211_local *local;
 	struct rate_control_ops *ops;
 	void *priv;
 	struct kref kref;
 };
 
-int ieee80211_rate_control_register(struct rate_control_ops *ops);
-void ieee80211_rate_control_unregister(struct rate_control_ops *ops);
-
 /* Get a reference to the rate control algorithm. If `name' is NULL, get the
  * first available algorithm. */
 struct rate_control_ref *rate_control_alloc(const char *name,
 					    struct ieee80211_local *local);
-void rate_control_get_rate(struct net_device *dev,
+void rate_control_get_rate(struct ieee80211_sub_if_data *sdata,
 			   struct ieee80211_supported_band *sband,
-			   struct sk_buff *skb,
+			   struct sta_info *sta, struct sk_buff *skb,
 			   struct rate_selection *sel);
 struct rate_control_ref *rate_control_get(struct rate_control_ref *ref);
 void rate_control_put(struct rate_control_ref *ref);
 
-static inline void rate_control_tx_status(struct net_device *dev,
+static inline void rate_control_tx_status(struct ieee80211_local *local,
+					  struct ieee80211_supported_band *sband,
+					  struct sta_info *sta,
 					  struct sk_buff *skb)
 {
-	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
 	struct rate_control_ref *ref = local->rate_ctrl;
+	struct ieee80211_sta *ista = &sta->sta;
+	void *priv_sta = sta->rate_ctrl_priv;
 
-	ref->ops->tx_status(ref->priv, dev, skb);
+	ref->ops->tx_status(ref->priv, sband, ista, priv_sta, skb);
 }
 
 
-static inline void rate_control_rate_init(struct sta_info *sta,
-					  struct ieee80211_local *local)
+static inline void rate_control_rate_init(struct sta_info *sta)
 {
+	struct ieee80211_local *local = sta->sdata->local;
 	struct rate_control_ref *ref = sta->rate_ctrl;
-	ref->ops->rate_init(ref->priv, sta->rate_ctrl_priv, local, sta);
+	struct ieee80211_sta *ista = &sta->sta;
+	void *priv_sta = sta->rate_ctrl_priv;
+	struct ieee80211_supported_band *sband;
+
+	sband = local->hw.wiphy->bands[local->hw.conf.channel->band];
+
+	ref->ops->rate_init(ref->priv, sband, ista, priv_sta);
 }
 
 
@@ -100,15 +71,19 @@ static inline void rate_control_clear(struct ieee80211_local *local)
 }
 
 static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,
+					   struct ieee80211_sta *sta,
 					   gfp_t gfp)
 {
-	return ref->ops->alloc_sta(ref->priv, gfp);
+	return ref->ops->alloc_sta(ref->priv, sta, gfp);
 }
 
-static inline void rate_control_free_sta(struct rate_control_ref *ref,
-					 void *priv)
+static inline void rate_control_free_sta(struct sta_info *sta)
 {
-	ref->ops->free_sta(ref->priv, priv);
+	struct rate_control_ref *ref = sta->rate_ctrl;
+	struct ieee80211_sta *ista = &sta->sta;
+	void *priv_sta = sta->rate_ctrl_priv;
+
+	ref->ops->free_sta(ref->priv, ista, priv_sta);
 }
 
 static inline void rate_control_add_sta_debugfs(struct sta_info *sta)
@@ -130,31 +105,6 @@ static inline void rate_control_remove_sta_debugfs(struct sta_info *sta)
 #endif
 }
 
-static inline int rate_supported(struct sta_info *sta,
-				 enum ieee80211_band band,
-				 int index)
-{
-	return (sta == NULL || sta->sta.supp_rates[band] & BIT(index));
-}
-
-static inline s8
-rate_lowest_index(struct ieee80211_local *local,
-		  struct ieee80211_supported_band *sband,
-		  struct sta_info *sta)
-{
-	int i;
-
-	for (i = 0; i < sband->n_bitrates; i++)
-		if (rate_supported(sta, sband->band, i))
-			return i;
-
-	/* warn when we cannot find a rate. */
-	WARN_ON(1);
-
-	return 0;
-}
-
-
 /* functions for rate control related to a device */
 int ieee80211_init_rate_ctrl_alg(struct ieee80211_local *local,
 				 const char *name);

commit 323ce79a9cdbf838ea577677b1ddace8e0b4d4c6
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu Sep 11 02:45:11 2008 +0200

    mac80211: share sta->supp_rates
    
    As more preparation for a saner rate control algorithm API,
    share the supported rates bitmap in the public API.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index ede7ab56f65b..5f18c27eb900 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -134,7 +134,7 @@ static inline int rate_supported(struct sta_info *sta,
 				 enum ieee80211_band band,
 				 int index)
 {
-	return (sta == NULL || sta->supp_rates[band] & BIT(index));
+	return (sta == NULL || sta->sta.supp_rates[band] & BIT(index));
 }
 
 static inline s8

commit e5f5e7339cd95d07937e6f8081b46fba86c742a7
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jun 26 13:38:13 2008 +0300

    build algorithms into the mac80211 module
    
    The old infrastructure was:
    - the default algorithm is built into mac80211
    - other algorithms get into their own modules
    
    The implementation of this complicated scheme was horrible
    (just look at net/mac80211/Makefile), and anyone adding a new
    algorithm would most likely not get it right at his first attempt.
    
    This patch therefore builds all enabled algorithms into the mac80211
    module.
    
    The user interface for the rate control algorithms changes as follows:
    - first the user can choose which algorithms to enable (currently only
      MAC80211_RC_PID is available)
    - if more than one algorithm is enabled (currently not possible since
      only one algorithm is present) the user then chooses the default one
    
    Note:
    - MAC80211_RC_PID is always enables for CONFIG_EMBEDDED=n
    
    Technical changes:
    - all selected algorithms get into the mac80211 module
    - net/mac80211/Makefile can now become much less complicated
    - support for rc80211_pid_algo.c being modular is no longer required
    - this includes unexporting mesh_plink_broken
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 0ed9c8a2f56f..ede7ab56f65b 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -162,9 +162,7 @@ void rate_control_deinitialize(struct ieee80211_local *local);
 
 
 /* Rate control algorithms */
-#if defined(RC80211_PID_COMPILE) || \
-	(defined(CONFIG_MAC80211_RC_PID) && \
-	 !defined(CONFIG_MAC80211_RC_PID_MODULE))
+#ifdef CONFIG_MAC80211_RC_PID
 extern int rc80211_pid_init(void);
 extern void rc80211_pid_exit(void);
 #else

commit e039fa4a4195ac4ee895e6f3d1334beed63256fe
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu May 15 12:55:29 2008 +0200

    mac80211: move TX info into skb->cb
    
    This patch converts mac80211 and all drivers to have transmit
    information and status in skb->cb rather than allocating extra
    memory for it and copying all the data around. To make it fit,
    a union is used where only data that is necessary for all steps
    is kept outside of the union.
    
    A number of fixes were done by Ivo, as well as the rt2x00 part
    of this patch.
    
    Signed-off-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index a29148dcca99..0ed9c8a2f56f 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -34,8 +34,7 @@ struct rate_control_ops {
 	struct module *module;
 	const char *name;
 	void (*tx_status)(void *priv, struct net_device *dev,
-			  struct sk_buff *skb,
-			  struct ieee80211_tx_status *status);
+			  struct sk_buff *skb);
 	void (*get_rate)(void *priv, struct net_device *dev,
 			 struct ieee80211_supported_band *band,
 			 struct sk_buff *skb,
@@ -77,13 +76,12 @@ struct rate_control_ref *rate_control_get(struct rate_control_ref *ref);
 void rate_control_put(struct rate_control_ref *ref);
 
 static inline void rate_control_tx_status(struct net_device *dev,
-					  struct sk_buff *skb,
-					  struct ieee80211_tx_status *status)
+					  struct sk_buff *skb)
 {
 	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
 	struct rate_control_ref *ref = local->rate_ctrl;
 
-	ref->ops->tx_status(ref->priv, dev, skb, status);
+	ref->ops->tx_status(ref->priv, dev, skb);
 }
 
 

commit 2e92e6f2c50b4baf85cca968f0e6f1b5c0df7d39
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu May 15 12:55:27 2008 +0200

    mac80211: use rate index in TX control
    
    This patch modifies struct ieee80211_tx_control to give band
    info and the rate index (instead of rate pointers) to drivers.
    This mostly serves to reduce the TX control structure size to
    make it fit into skb->cb so that the fragmentation code can
    put it there and we can think about passing it to drivers that
    way in the future.
    
    The rt2x00 driver update was done by Ivo, thanks.
    
    Signed-off-by: Ivo van Doorn <IvDoorn@gmail.com>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
index 5b45f33cb766..a29148dcca99 100644
--- a/net/mac80211/rate.h
+++ b/net/mac80211/rate.h
@@ -19,14 +19,15 @@
 #include "ieee80211_i.h"
 #include "sta_info.h"
 
-/* TODO: kdoc */
+/**
+ * struct rate_selection - rate selection for rate control algos
+ * @rate: selected transmission rate index
+ * @nonerp: Non-ERP rate to use instead if ERP cannot be used
+ * @probe: rate for probing (or -1)
+ *
+ */
 struct rate_selection {
-	/* Selected transmission rate */
-	struct ieee80211_rate *rate;
-	/* Non-ERP rate to use if mac80211 decides it cannot use an ERP rate */
-	struct ieee80211_rate *nonerp;
-	/* probe with this rate, or NULL for no probing */
-	struct ieee80211_rate *probe;
+	s8 rate_idx, nonerp_idx, probe_idx;
 };
 
 struct rate_control_ops {
@@ -138,7 +139,7 @@ static inline int rate_supported(struct sta_info *sta,
 	return (sta == NULL || sta->supp_rates[band] & BIT(index));
 }
 
-static inline int
+static inline s8
 rate_lowest_index(struct ieee80211_local *local,
 		  struct ieee80211_supported_band *sband,
 		  struct sta_info *sta)
@@ -155,14 +156,6 @@ rate_lowest_index(struct ieee80211_local *local,
 	return 0;
 }
 
-static inline struct ieee80211_rate *
-rate_lowest(struct ieee80211_local *local,
-	    struct ieee80211_supported_band *sband,
-	    struct sta_info *sta)
-{
-	return &sband->bitrates[rate_lowest_index(local, sband, sta)];
-}
-
 
 /* functions for rate control related to a device */
 int ieee80211_init_rate_ctrl_alg(struct ieee80211_local *local,

commit 2c8dccc77420fb7433da5674818959d3499d35be
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Apr 8 15:14:40 2008 -0400

    mac80211: rename files
    
    This patch renames all mac80211 files (except ieee80211_i.h) to get rid
    of the useless ieee80211_ prefix.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/rate.h b/net/mac80211/rate.h
new file mode 100644
index 000000000000..5b45f33cb766
--- /dev/null
+++ b/net/mac80211/rate.h
@@ -0,0 +1,189 @@
+/*
+ * Copyright 2002-2005, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ * Copyright (c) 2006 Jiri Benc <jbenc@suse.cz>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef IEEE80211_RATE_H
+#define IEEE80211_RATE_H
+
+#include <linux/netdevice.h>
+#include <linux/skbuff.h>
+#include <linux/types.h>
+#include <linux/kref.h>
+#include <net/mac80211.h>
+#include "ieee80211_i.h"
+#include "sta_info.h"
+
+/* TODO: kdoc */
+struct rate_selection {
+	/* Selected transmission rate */
+	struct ieee80211_rate *rate;
+	/* Non-ERP rate to use if mac80211 decides it cannot use an ERP rate */
+	struct ieee80211_rate *nonerp;
+	/* probe with this rate, or NULL for no probing */
+	struct ieee80211_rate *probe;
+};
+
+struct rate_control_ops {
+	struct module *module;
+	const char *name;
+	void (*tx_status)(void *priv, struct net_device *dev,
+			  struct sk_buff *skb,
+			  struct ieee80211_tx_status *status);
+	void (*get_rate)(void *priv, struct net_device *dev,
+			 struct ieee80211_supported_band *band,
+			 struct sk_buff *skb,
+			 struct rate_selection *sel);
+	void (*rate_init)(void *priv, void *priv_sta,
+			  struct ieee80211_local *local, struct sta_info *sta);
+	void (*clear)(void *priv);
+
+	void *(*alloc)(struct ieee80211_local *local);
+	void (*free)(void *priv);
+	void *(*alloc_sta)(void *priv, gfp_t gfp);
+	void (*free_sta)(void *priv, void *priv_sta);
+
+	int (*add_attrs)(void *priv, struct kobject *kobj);
+	void (*remove_attrs)(void *priv, struct kobject *kobj);
+	void (*add_sta_debugfs)(void *priv, void *priv_sta,
+				struct dentry *dir);
+	void (*remove_sta_debugfs)(void *priv, void *priv_sta);
+};
+
+struct rate_control_ref {
+	struct rate_control_ops *ops;
+	void *priv;
+	struct kref kref;
+};
+
+int ieee80211_rate_control_register(struct rate_control_ops *ops);
+void ieee80211_rate_control_unregister(struct rate_control_ops *ops);
+
+/* Get a reference to the rate control algorithm. If `name' is NULL, get the
+ * first available algorithm. */
+struct rate_control_ref *rate_control_alloc(const char *name,
+					    struct ieee80211_local *local);
+void rate_control_get_rate(struct net_device *dev,
+			   struct ieee80211_supported_band *sband,
+			   struct sk_buff *skb,
+			   struct rate_selection *sel);
+struct rate_control_ref *rate_control_get(struct rate_control_ref *ref);
+void rate_control_put(struct rate_control_ref *ref);
+
+static inline void rate_control_tx_status(struct net_device *dev,
+					  struct sk_buff *skb,
+					  struct ieee80211_tx_status *status)
+{
+	struct ieee80211_local *local = wdev_priv(dev->ieee80211_ptr);
+	struct rate_control_ref *ref = local->rate_ctrl;
+
+	ref->ops->tx_status(ref->priv, dev, skb, status);
+}
+
+
+static inline void rate_control_rate_init(struct sta_info *sta,
+					  struct ieee80211_local *local)
+{
+	struct rate_control_ref *ref = sta->rate_ctrl;
+	ref->ops->rate_init(ref->priv, sta->rate_ctrl_priv, local, sta);
+}
+
+
+static inline void rate_control_clear(struct ieee80211_local *local)
+{
+	struct rate_control_ref *ref = local->rate_ctrl;
+	ref->ops->clear(ref->priv);
+}
+
+static inline void *rate_control_alloc_sta(struct rate_control_ref *ref,
+					   gfp_t gfp)
+{
+	return ref->ops->alloc_sta(ref->priv, gfp);
+}
+
+static inline void rate_control_free_sta(struct rate_control_ref *ref,
+					 void *priv)
+{
+	ref->ops->free_sta(ref->priv, priv);
+}
+
+static inline void rate_control_add_sta_debugfs(struct sta_info *sta)
+{
+#ifdef CONFIG_MAC80211_DEBUGFS
+	struct rate_control_ref *ref = sta->rate_ctrl;
+	if (sta->debugfs.dir && ref->ops->add_sta_debugfs)
+		ref->ops->add_sta_debugfs(ref->priv, sta->rate_ctrl_priv,
+					  sta->debugfs.dir);
+#endif
+}
+
+static inline void rate_control_remove_sta_debugfs(struct sta_info *sta)
+{
+#ifdef CONFIG_MAC80211_DEBUGFS
+	struct rate_control_ref *ref = sta->rate_ctrl;
+	if (ref->ops->remove_sta_debugfs)
+		ref->ops->remove_sta_debugfs(ref->priv, sta->rate_ctrl_priv);
+#endif
+}
+
+static inline int rate_supported(struct sta_info *sta,
+				 enum ieee80211_band band,
+				 int index)
+{
+	return (sta == NULL || sta->supp_rates[band] & BIT(index));
+}
+
+static inline int
+rate_lowest_index(struct ieee80211_local *local,
+		  struct ieee80211_supported_band *sband,
+		  struct sta_info *sta)
+{
+	int i;
+
+	for (i = 0; i < sband->n_bitrates; i++)
+		if (rate_supported(sta, sband->band, i))
+			return i;
+
+	/* warn when we cannot find a rate. */
+	WARN_ON(1);
+
+	return 0;
+}
+
+static inline struct ieee80211_rate *
+rate_lowest(struct ieee80211_local *local,
+	    struct ieee80211_supported_band *sband,
+	    struct sta_info *sta)
+{
+	return &sband->bitrates[rate_lowest_index(local, sband, sta)];
+}
+
+
+/* functions for rate control related to a device */
+int ieee80211_init_rate_ctrl_alg(struct ieee80211_local *local,
+				 const char *name);
+void rate_control_deinitialize(struct ieee80211_local *local);
+
+
+/* Rate control algorithms */
+#if defined(RC80211_PID_COMPILE) || \
+	(defined(CONFIG_MAC80211_RC_PID) && \
+	 !defined(CONFIG_MAC80211_RC_PID_MODULE))
+extern int rc80211_pid_init(void);
+extern void rc80211_pid_exit(void);
+#else
+static inline int rc80211_pid_init(void)
+{
+	return 0;
+}
+static inline void rc80211_pid_exit(void)
+{
+}
+#endif
+
+#endif /* IEEE80211_RATE_H */
