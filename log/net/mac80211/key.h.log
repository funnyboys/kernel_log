commit e5473e80d46767ebc64dac4958f30299a3b14b1b
Author: Jouni Malinen <jouni@codeaurora.org>
Date:   Sat Feb 22 15:25:44 2020 +0200

    mac80211: Support BIGTK configuration for Beacon protection
    
    Extend mac80211 key configuration to support the new BIGTK with key
    index values 6 and 7. Support for actually protecting Beacon frames
    (adding the MME in AP mode and checking it in STA mode) is covered in
    separate commits.
    
    Signed-off-by: Jouni Malinen <jouni@codeaurora.org>
    Link: https://lore.kernel.org/r/20200222132548.20835-3-jouni@codeaurora.org
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index d6d6e89cf7dd..7ad72e9b4991 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -17,6 +17,7 @@
 
 #define NUM_DEFAULT_KEYS 4
 #define NUM_DEFAULT_MGMT_KEYS 2
+#define NUM_DEFAULT_BEACON_KEYS 2
 #define INVALID_PTK_KEYIDX 2 /* Keyidx always pointing to a NULL key for PTK */
 
 struct ieee80211_local;
@@ -153,6 +154,8 @@ void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx,
 			       bool uni, bool multi);
 void ieee80211_set_default_mgmt_key(struct ieee80211_sub_if_data *sdata,
 				    int idx);
+void ieee80211_set_default_beacon_key(struct ieee80211_sub_if_data *sdata,
+				      int idx);
 void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata,
 			 bool force_synchronize);
 void ieee80211_free_sta_keys(struct ieee80211_local *local,

commit 624ff4b210ecccb0a39387993302b1a6af74176e
Author: Lior Cohen <lior2.cohen@intel.com>
Date:   Fri Aug 30 14:24:49 2019 +0300

    mac80211: clear crypto tx tailroom counter upon keys enable
    
    In case we got a fw restart while roaming from encrypted AP to
    non-encrypted one, we might end up with hitting a warning on the pending
    counter crypto_tx_tailroom_pending_dec having a non-zero value.
    
    The following comment taken from net/mac80211/key.c explains the rational
    for the delayed tailroom needed:
    
            /*
            * The reason for the delayed tailroom needed decrementing is to
            * make roaming faster: during roaming, all keys are first deleted
            * and then new keys are installed. The first new key causes the
            * crypto_tx_tailroom_needed_cnt to go from 0 to 1, which invokes
            * the cost of synchronize_net() (which can be slow). Avoid this
            * by deferring the crypto_tx_tailroom_needed_cnt decrementing on
            * key removal for a while, so if we roam the value is larger than
            * zero and no 0->1 transition happens.
            *
            * The cost is that if the AP switching was from an AP with keys
            * to one without, we still allocate tailroom while it would no
            * longer be needed. However, in the typical (fast) roaming case
            * within an ESS this usually won't happen.
            */
    
    The next flow lead to the warning eventually reported as a bug:
    1. Disconnect from encrypted AP
    2. Set crypto_tx_tailroom_pending_dec = 1 for the key
    3. Schedule work
    4. Reconnect to non-encrypted AP
    5. Add a new key, setting the tailroom counter = 1
    6. Got FW restart while pending counter is set ---> hit the warning
    
    While on it, the ieee80211_reset_crypto_tx_tailroom() func was merged into
    its single caller ieee80211_reenable_keys (previously called
    ieee80211_enable_keys). Also, we reset the crypto_tx_tailroom_pending_dec
    and remove the counters warning as we just reset both.
    
    Signed-off-by: Lior Cohen <lior2.cohen@intel.com>
    Signed-off-by: Luca Coelho <luciano.coelho@intel.com>
    Link: https://lore.kernel.org/r/20190830112451.21655-7-luca@coelho.fi
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index b8b9cd743bf4..d6d6e89cf7dd 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -2,6 +2,7 @@
 /*
  * Copyright 2002-2004, Instant802 Networks, Inc.
  * Copyright 2005, Devicescape Software, Inc.
+ * Copyright (C) 2019 Intel Corporation
  */
 
 #ifndef IEEE80211_KEY_H
@@ -156,8 +157,7 @@ void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata,
 			 bool force_synchronize);
 void ieee80211_free_sta_keys(struct ieee80211_local *local,
 			     struct sta_info *sta);
-void ieee80211_enable_keys(struct ieee80211_sub_if_data *sdata);
-void ieee80211_reset_crypto_tx_tailroom(struct ieee80211_sub_if_data *sdata);
+void ieee80211_reenable_keys(struct ieee80211_sub_if_data *sdata);
 
 #define key_mtx_dereference(local, ref) \
 	rcu_dereference_protected(ref, lockdep_is_held(&((local)->key_mtx)))

commit 4d2fa8b44b891f0da5ceda3e5a1402ccf0ab6f26
Merge: 8b68150883ca f3880a23564e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 8 20:57:08 2019 -0700

    Merge branch 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6
    
    Pull crypto updates from Herbert Xu:
     "Here is the crypto update for 5.3:
    
      API:
       - Test shash interface directly in testmgr
       - cra_driver_name is now mandatory
    
      Algorithms:
       - Replace arc4 crypto_cipher with library helper
       - Implement 5 way interleave for ECB, CBC and CTR on arm64
       - Add xxhash
       - Add continuous self-test on noise source to drbg
       - Update jitter RNG
    
      Drivers:
       - Add support for SHA204A random number generator
       - Add support for 7211 in iproc-rng200
       - Fix fuzz test failures in inside-secure
       - Fix fuzz test failures in talitos
       - Fix fuzz test failures in qat"
    
    * 'linus' of git://git.kernel.org/pub/scm/linux/kernel/git/herbert/crypto-2.6: (143 commits)
      crypto: stm32/hash - remove interruptible condition for dma
      crypto: stm32/hash - Fix hmac issue more than 256 bytes
      crypto: stm32/crc32 - rename driver file
      crypto: amcc - remove memset after dma_alloc_coherent
      crypto: ccp - Switch to SPDX license identifiers
      crypto: ccp - Validate the the error value used to index error messages
      crypto: doc - Fix formatting of new crypto engine content
      crypto: doc - Add parameter documentation
      crypto: arm64/aes-ce - implement 5 way interleave for ECB, CBC and CTR
      crypto: arm64/aes-ce - add 5 way interleave routines
      crypto: talitos - drop icv_ool
      crypto: talitos - fix hash on SEC1.
      crypto: talitos - move struct talitos_edesc into talitos.h
      lib/scatterlist: Fix mapping iterator when sg->offset is greater than PAGE_SIZE
      crypto/NX: Set receive window credits to max number of CRBs in RxFIFO
      crypto: asymmetric_keys - select CRYPTO_HASH where needed
      crypto: serpent - mark __serpent_setkey_sbox noinline
      crypto: testmgr - dynamically allocate crypto_shash
      crypto: testmgr - dynamically allocate testvec_config
      crypto: talitos - eliminate unneeded 'done' functions at build time
      ...

commit 5fdb373570b2119abf00d909a277ebf4ea2c078f
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Wed Jun 12 18:19:54 2019 +0200

    net/mac80211: move WEP handling to ARC4 library interface
    
    The WEP code in the mac80211 subsystem currently uses the crypto
    API to access the arc4 (RC4) cipher, which is overly complicated,
    and doesn't really have an upside in this particular case, since
    ciphers are always synchronous and therefore always implemented in
    software. Given that we have no accelerated software implementations
    either, it is much more straightforward to invoke a generic library
    interface directly.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Herbert Xu <herbert@gondor.apana.org.au>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index f06fbd03d235..6c5bbaebd02c 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -14,6 +14,7 @@
 #include <linux/list.h>
 #include <linux/crypto.h>
 #include <linux/rcupdate.h>
+#include <crypto/arc4.h>
 #include <net/mac80211.h>
 
 #define NUM_DEFAULT_KEYS 4

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index f06fbd03d235..be118c39433f 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -1,10 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright 2002-2004, Instant802 Networks, Inc.
  * Copyright 2005, Devicescape Software, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef IEEE80211_KEY_H

commit 96fc6efb9ad9d0cd8cbb4462f0eb2a07092649e6
Author: Alexander Wetzel <alexander@wetzel-home.de>
Date:   Tue Mar 19 21:34:08 2019 +0100

    mac80211: IEEE 802.11 Extended Key ID support
    
    Add support for Extended Key ID as defined in IEEE 802.11-2016.
    
     - Implement the nl80211 API for Extended Key ID
     - Extend mac80211 API to allow drivers to support Extended Key ID
     - Enable Extended Key ID by default for drivers only supporting SW
       crypto (e.g. mac80211_hwsim)
     - Allow unicast Tx usage to be supressed (IEEE80211_KEY_FLAG_NO_AUTO_TX)
     - Select the decryption key based on the MPDU keyid
     - Enforce existing assumptions in the code that rekeys don't change the
       cipher
    
    Signed-off-by: Alexander Wetzel <alexander@wetzel-home.de>
    [remove module parameter]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index ebdb80b85dc3..f06fbd03d235 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -18,6 +18,7 @@
 
 #define NUM_DEFAULT_KEYS 4
 #define NUM_DEFAULT_MGMT_KEYS 2
+#define INVALID_PTK_KEYIDX 2 /* Keyidx always pointing to a NULL key for PTK */
 
 struct ieee80211_local;
 struct ieee80211_sub_if_data;
@@ -146,6 +147,7 @@ ieee80211_key_alloc(u32 cipher, int idx, size_t key_len,
 int ieee80211_key_link(struct ieee80211_key *key,
 		       struct ieee80211_sub_if_data *sdata,
 		       struct sta_info *sta);
+int ieee80211_set_tx_key(struct ieee80211_key *key);
 void ieee80211_key_free(struct ieee80211_key *key, bool delay_tailroom);
 void ieee80211_key_free_unused(struct ieee80211_key *key);
 void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx,

commit 26717828b75dd5c46e97f7f4a9b937d038bb2852
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Mon Feb 6 10:49:28 2017 +0000

    mac80211: aes-cmac: switch to shash CMAC driver
    
    Instead of open coding the CMAC algorithm in the mac80211 driver using
    byte wide xors and calls into the crypto layer for each block of data,
    instantiate a cmac(aes) synchronous hash and pass all the data into it
    directly. This does not only simplify the code, it also allows the use
    of more efficient and more secure implementations, especially on
    platforms where SIMD ciphers have a considerable setup cost.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 4aa20cef0859..ebdb80b85dc3 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -93,7 +93,7 @@ struct ieee80211_key {
 		} ccmp;
 		struct {
 			u8 rx_pn[IEEE80211_CMAC_PN_LEN];
-			struct crypto_cipher *tfm;
+			struct crypto_shash *tfm;
 			u32 replays; /* dot11RSNAStatsCMACReplays */
 			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
 		} aes_cmac;

commit f8079d43cf0f1f0171606e75fcef6fe17bb183f2
Author: Eliad Peller <eliad@wizery.com>
Date:   Sun Feb 14 13:56:35 2016 +0200

    mac80211: move TKIP TX IVs to public part of key struct
    
    Some drivers/devices might want to set the IVs by
    themselves (and still let mac80211 generate MMIC).
    
    Specifically, this is needed when the device does
    offloading at certain times, and the driver has
    to make sure that the IVs of new tx frames (from
    the host) are synchronized with IVs that were
    potentially used during the offloading.
    
    Similarly to CCMP, move the TX IVs of TKIP keys to the
    public part of the key struct, and export a function
    to add the IV right into the crypto header.
    
    The public tx_pn field is defined as atomic64, so define
    TKIP_PN_TO_IV16/32 helper macros to convert it to iv16/32
    when needed.
    
    Since the iv32 used for the p1k cache is taken
    directly from the frame, we can safely remove
    iv16/32 from being protected by tkip.txlock.
    
    Signed-off-by: Eliad Peller <eliadx.peller@intel.com>
    Signed-off-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 9951ef06323e..4aa20cef0859 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -44,13 +44,17 @@ enum ieee80211_internal_tkip_state {
 };
 
 struct tkip_ctx {
-	u32 iv32;	/* current iv32 */
-	u16 iv16;	/* current iv16 */
 	u16 p1k[5];	/* p1k cache */
 	u32 p1k_iv32;	/* iv32 for which p1k computed */
 	enum ieee80211_internal_tkip_state state;
 };
 
+struct tkip_ctx_rx {
+	struct tkip_ctx ctx;
+	u32 iv32;	/* current iv32 */
+	u16 iv16;	/* current iv16 */
+};
+
 struct ieee80211_key {
 	struct ieee80211_local *local;
 	struct ieee80211_sub_if_data *sdata;
@@ -71,7 +75,7 @@ struct ieee80211_key {
 			struct tkip_ctx tx;
 
 			/* last received RSC */
-			struct tkip_ctx rx[IEEE80211_NUM_TIDS];
+			struct tkip_ctx_rx rx[IEEE80211_NUM_TIDS];
 
 			/* number of mic failures */
 			u32 mic_failures;

commit 77c96404a4cf16ffa0720a3fbf45839cc16018ac
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Jun 12 14:40:45 2015 +0200

    mac80211: remove key TX/RX counter
    
    This counter is inherently racy (since it can be incremented by RX
    as well as by concurrent TX) and only available in debugfs. Instead
    of fixing it to be per-CPU or similar, remove it for now. If needed
    it should be added without races and with proper nl80211, perhaps
    even addressing the threshold reporting TODO item that's been there
    since the code was originally added.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 3f4f9eaac140..9951ef06323e 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -115,9 +115,6 @@ struct ieee80211_key {
 		} gen;
 	} u;
 
-	/* number of times this key has been used */
-	int tx_rx_count;
-
 #ifdef CONFIG_MAC80211_DEBUGFS
 	struct {
 		struct dentry *stalink;

commit 206c59d1d7d42bcafc1d7f1e476e87e4427e2345
Merge: 5ec596c41bba c3eee1fb1d30
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Jun 10 12:44:58 2015 +0200

    Merge remote-tracking branch 'net-next/master' into mac80211-next
    
    Merge back net-next to get wireless driver changes (from Kalle)
    to be able to create the API change across all trees properly.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

commit db388a567ff9600debc2433c1fddf79a8fc38b21
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Jun 1 15:36:51 2015 +0200

    mac80211: move TX PN to public part of key struct
    
    For drivers supporting TSO or similar features, but that still have
    PN assignment in software, there's a need to have some memory to
    store the current PN value. As mac80211 already stores this and it's
    somewhat complicated to add a per-driver area to the key struct (due
    to the dynamic sizing thereof) it makes sense to just move the TX PN
    to the keyconf, i.e. the public part of the key struct.
    
    As TKIP is more complicated and we won't able to offload it in this
    way right now (fast-xmit is skipped for TKIP unless the HW does it
    all, and our hardware needs MMIC calculation in software) I've not
    moved that for now - it's possible but requires exposing a lot of
    the internal TKIP state.
    
    As an bonus side effect, we can remove a lot of code by assuming the
    keyseq struct has a certain layout - with BUILD_BUG_ON to verify it.
    
    This might also improve performance, since now TX and RX no longer
    share a cacheline.
    
    Reviewed-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index df430a618764..ac747e442139 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -77,7 +77,6 @@ struct ieee80211_key {
 			u32 mic_failures;
 		} tkip;
 		struct {
-			atomic64_t tx_pn;
 			/*
 			 * Last received packet number. The first
 			 * IEEE80211_NUM_TIDS counters are used with Data
@@ -89,21 +88,18 @@ struct ieee80211_key {
 			u32 replays; /* dot11RSNAStatsCCMPReplays */
 		} ccmp;
 		struct {
-			atomic64_t tx_pn;
 			u8 rx_pn[IEEE80211_CMAC_PN_LEN];
 			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCMACReplays */
 			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
 		} aes_cmac;
 		struct {
-			atomic64_t tx_pn;
 			u8 rx_pn[IEEE80211_GMAC_PN_LEN];
 			struct crypto_aead *tfm;
 			u32 replays; /* dot11RSNAStatsCMACReplays */
 			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
 		} aes_gmac;
 		struct {
-			atomic64_t tx_pn;
 			/* Last received packet number. The first
 			 * IEEE80211_NUM_TIDS counters are used with Data
 			 * frames and the last counter is used with Robust

commit dda922c831d1661c11a3ae1051b7160236f6ffb0
Merge: db3397b9aa30 c46a024ea5eb
Author: David S. Miller <davem@davemloft.net>
Date:   Mon Jun 1 22:33:25 2015 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/davem/net
    
    Conflicts:
            drivers/net/phy/amd-xgbe-phy.c
            drivers/net/wireless/iwlwifi/Kconfig
            include/net/mac80211.h
    
    iwlwifi/Kconfig and mac80211.h were both trivial overlapping
    changes.
    
    The drivers/net/phy/amd-xgbe-phy.c file got removed in 'net-next' and
    the bug fix that happened on the 'net' side is already integrated
    into the rest of the amd-xgbe driver.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

commit f9dca80b98caac8b4bfb43a2edf1e9f877ccf322
Author: Michal Kazior <michal.kazior@tieto.com>
Date:   Wed May 13 09:16:48 2015 +0000

    mac80211: fix AP_VLAN crypto tailroom calculation
    
    Some splats I was seeing:
    
     (a) WARNING: CPU: 1 PID: 0 at /devel/src/linux/net/mac80211/wep.c:102 ieee80211_wep_add_iv
     (b) WARNING: CPU: 1 PID: 0 at /devel/src/linux/net/mac80211/wpa.c:73 ieee80211_tx_h_michael_mic_add
     (c) WARNING: CPU: 3 PID: 0 at /devel/src/linux/net/mac80211/wpa.c:433 ieee80211_crypto_ccmp_encrypt
    
    I've seen (a) and (b) with ath9k hw crypto and (c)
    with ath9k sw crypto. All of them were related to
    insufficient skb tailroom and I was able to
    trigger these with ping6 program.
    
    AP_VLANs may inherit crypto keys from parent AP.
    This wasn't considered and yielded problems in
    some setups resulting in inability to transmit
    data because mac80211 wouldn't resize skbs when
    necessary and subsequently drop some packets due
    to insufficient tailroom.
    
    For efficiency purposes don't inspect both AP_VLAN
    and AP sdata looking for tailroom counter. Instead
    update AP_VLAN tailroom counters whenever their
    master AP tailroom counter changes.
    
    Signed-off-by: Michal Kazior <michal.kazior@tieto.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index c5a31835be0e..96557dd1e77d 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -161,6 +161,7 @@ void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata,
 void ieee80211_free_sta_keys(struct ieee80211_local *local,
 			     struct sta_info *sta);
 void ieee80211_enable_keys(struct ieee80211_sub_if_data *sdata);
+void ieee80211_reset_crypto_tx_tailroom(struct ieee80211_sub_if_data *sdata);
 
 #define key_mtx_dereference(local, ref) \
 	rcu_dereference_protected(ref, lockdep_is_held(&((local)->key_mtx)))

commit a31cf1c69e89e0c2d5515b04aca313f1014a714d
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Mon Apr 20 18:21:58 2015 +0200

    mac80211: extend get_key() to return PN for all ciphers
    
    For ciphers not supported by mac80211, the function currently
    doesn't return any PN data. Fix this by extending the driver's
    get_key_seq() a little more to allow moving arbitrary PN data.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index c5a31835be0e..df430a618764 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -18,7 +18,6 @@
 
 #define NUM_DEFAULT_KEYS 4
 #define NUM_DEFAULT_MGMT_KEYS 2
-#define MAX_PN_LEN 16
 
 struct ieee80211_local;
 struct ieee80211_sub_if_data;
@@ -116,7 +115,7 @@ struct ieee80211_key {
 		} gcmp;
 		struct {
 			/* generic cipher scheme */
-			u8 rx_pn[IEEE80211_NUM_TIDS + 1][MAX_PN_LEN];
+			u8 rx_pn[IEEE80211_NUM_TIDS + 1][IEEE80211_MAX_PN_LEN];
 		} gen;
 	} u;
 

commit c7ef38e0ccca25050efed56a35df2e1e93c0b469
Author: Cedric Izoard <Cedric.Izoard@ceva-dsp.com>
Date:   Tue Mar 17 10:47:33 2015 +0000

    mac80211: Get IV len from key conf and not cipher scheme
    
    When a key is installed using a cipher scheme, set a new
    internal key flag (KEY_FLAG_CIPHER_SCHEME) on it, to allow
    distinguishing such keys more easily.
    
    In particular, use this flag on the TX path instead of
    testing the sta->cipher_scheme pointer, as the station is
    NULL for broad-/multicast message, and use the key's iv_len
    instead of the cipher scheme information.
    
    Signed-off-by: Cedric Izoard <cedric.izoard@ceva-dsp.com>
    [add missing documentation, rewrite commit message]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index d57a9915494f..c5a31835be0e 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -30,10 +30,12 @@ struct sta_info;
  * @KEY_FLAG_UPLOADED_TO_HARDWARE: Indicates that this key is present
  *	in the hardware for TX crypto hardware acceleration.
  * @KEY_FLAG_TAINTED: Key is tainted and packets should be dropped.
+ * @KEY_FLAG_CIPHER_SCHEME: This key is for a hardware cipher scheme
  */
 enum ieee80211_internal_key_flags {
 	KEY_FLAG_UPLOADED_TO_HARDWARE	= BIT(0),
 	KEY_FLAG_TAINTED		= BIT(1),
+	KEY_FLAG_CIPHER_SCHEME		= BIT(2),
 };
 
 enum ieee80211_internal_tkip_state {

commit 8ade538bf39b1ee53418528fdacd36b8e65621b9
Author: Jouni Malinen <jouni@qca.qualcomm.com>
Date:   Sat Jan 24 19:52:09 2015 +0200

    mac80111: Add BIP-GMAC-128 and BIP-GMAC-256 ciphers
    
    This allows mac80211 to configure BIP-GMAC-128 and BIP-GMAC-256 to the
    driver and also use software-implementation within mac80211 when the
    driver does not support this with hardware accelaration.
    
    Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 27580da851c8..d57a9915494f 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -94,6 +94,13 @@ struct ieee80211_key {
 			u32 replays; /* dot11RSNAStatsCMACReplays */
 			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
 		} aes_cmac;
+		struct {
+			atomic64_t tx_pn;
+			u8 rx_pn[IEEE80211_GMAC_PN_LEN];
+			struct crypto_aead *tfm;
+			u32 replays; /* dot11RSNAStatsCMACReplays */
+			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
+		} aes_gmac;
 		struct {
 			atomic64_t tx_pn;
 			/* Last received packet number. The first

commit 00b9cfa3ff38401bd70c34b250ca13e5ea347b4a
Author: Jouni Malinen <jouni@qca.qualcomm.com>
Date:   Sat Jan 24 19:52:06 2015 +0200

    mac80111: Add GCMP and GCMP-256 ciphers
    
    This allows mac80211 to configure GCMP and GCMP-256 to the driver and
    also use software-implementation within mac80211 when the driver does
    not support this with hardware accelaration.
    
    Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
    [remove a spurious newline]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 19db68663d75..27580da851c8 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -94,6 +94,17 @@ struct ieee80211_key {
 			u32 replays; /* dot11RSNAStatsCMACReplays */
 			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
 		} aes_cmac;
+		struct {
+			atomic64_t tx_pn;
+			/* Last received packet number. The first
+			 * IEEE80211_NUM_TIDS counters are used with Data
+			 * frames and the last counter is used with Robust
+			 * Management frames.
+			 */
+			u8 rx_pn[IEEE80211_NUM_TIDS + 1][IEEE80211_GCMP_PN_LEN];
+			struct crypto_aead *tfm;
+			u32 replays; /* dot11RSNAStatsGCMPReplays */
+		} gcmp;
 		struct {
 			/* generic cipher scheme */
 			u8 rx_pn[IEEE80211_NUM_TIDS + 1][MAX_PN_LEN];

commit 7907c7d33c3733b2265dadc6385fe028af72b4c7
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Dec 4 23:47:09 2013 +0100

    mac80211: free all AP/VLAN keys at once
    
    When the AP interface is stopped, free all AP and VLAN keys at
    once to only require synchronize_net() once. Since that does
    synchronize_net(), also move two such calls into the function
    (using the new force_synchronize parameter) to avoid doing it
    twice.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 0aebb889caba..19db68663d75 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -136,7 +136,8 @@ void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx,
 			       bool uni, bool multi);
 void ieee80211_set_default_mgmt_key(struct ieee80211_sub_if_data *sdata,
 				    int idx);
-void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata);
+void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata,
+			 bool force_synchronize);
 void ieee80211_free_sta_keys(struct ieee80211_local *local,
 			     struct sta_info *sta);
 void ieee80211_enable_keys(struct ieee80211_sub_if_data *sdata);

commit 2475b1cc0d5283a33144b79f3eba6d401d873962
Author: Max Stepanov <Max.Stepanov@intel.com>
Date:   Sun Mar 24 14:23:27 2013 +0200

    mac80211: add generic cipher scheme support
    
    This adds generic cipher scheme support to mac80211, such schemes
    are fully under control by the driver. On hw registration drivers
    may specify additional HW ciphers with a scheme how these ciphers
    have to be handled by mac80211 TX/RR. A cipher scheme specifies a
    cipher suite value, a size of the security header to be added to
    or stripped from frames and how the PN is to be verified on RX.
    
    Signed-off-by: Max Stepanov <Max.Stepanov@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index aaae0ed37004..0aebb889caba 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -18,6 +18,7 @@
 
 #define NUM_DEFAULT_KEYS 4
 #define NUM_DEFAULT_MGMT_KEYS 2
+#define MAX_PN_LEN 16
 
 struct ieee80211_local;
 struct ieee80211_sub_if_data;
@@ -93,6 +94,10 @@ struct ieee80211_key {
 			u32 replays; /* dot11RSNAStatsCMACReplays */
 			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
 		} aes_cmac;
+		struct {
+			/* generic cipher scheme */
+			u8 rx_pn[IEEE80211_NUM_TIDS + 1][MAX_PN_LEN];
+		} gen;
 	} u;
 
 	/* number of times this key has been used */
@@ -113,9 +118,11 @@ struct ieee80211_key {
 	struct ieee80211_key_conf conf;
 };
 
-struct ieee80211_key *ieee80211_key_alloc(u32 cipher, int idx, size_t key_len,
-					  const u8 *key_data,
-					  size_t seq_len, const u8 *seq);
+struct ieee80211_key *
+ieee80211_key_alloc(u32 cipher, int idx, size_t key_len,
+		    const u8 *key_data,
+		    size_t seq_len, const u8 *seq,
+		    const struct ieee80211_cipher_scheme *cs);
 /*
  * Insert a key into data structures (sdata, sta if necessary)
  * to make it used, free old key. On failure, also free the new key.

commit 7ec7c4a9a686c608315739ab6a2b0527a240883c
Author: Ard Biesheuvel <ard.biesheuvel@linaro.org>
Date:   Thu Oct 10 09:55:20 2013 +0200

    mac80211: port CCMP to cryptoapi's CCM driver
    
    Use the generic CCM aead chaining mode driver rather than a local
    implementation that sits right on top of the core AES cipher.
    
    This allows the use of accelerated implementations of either
    CCM as a whole or the CTR mode which it encapsulates.
    
    Signed-off-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 036d57e76a5e..aaae0ed37004 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -83,7 +83,7 @@ struct ieee80211_key {
 			 * Management frames.
 			 */
 			u8 rx_pn[IEEE80211_NUM_TIDS + 1][IEEE80211_CCMP_PN_LEN];
-			struct crypto_cipher *tfm;
+			struct crypto_aead *tfm;
 			u32 replays; /* dot11RSNAStatsCCMPReplays */
 		} ccmp;
 		struct {

commit 4325f6caad98c075b39f0eaaac6693a0dd43f646
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed May 8 13:09:08 2013 +0200

    wireless: move crypto constants to ieee80211.h
    
    mac80211 and the Intel drivers all define crypto
    constants, move them to ieee80211.h instead.
    
    Reviewed-by: Emmanuel Grumbach <emmanuel.grumbach@intel.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index e8de3e6d7804..036d57e76a5e 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -19,17 +19,6 @@
 #define NUM_DEFAULT_KEYS 4
 #define NUM_DEFAULT_MGMT_KEYS 2
 
-#define WEP_IV_LEN		4
-#define WEP_ICV_LEN		4
-#define ALG_CCMP_KEY_LEN	16
-#define CCMP_HDR_LEN		8
-#define CCMP_MIC_LEN		8
-#define CCMP_TK_LEN		16
-#define CCMP_PN_LEN		6
-#define TKIP_IV_LEN		8
-#define TKIP_ICV_LEN		4
-#define CMAC_PN_LEN		6
-
 struct ieee80211_local;
 struct ieee80211_sub_if_data;
 struct sta_info;
@@ -93,13 +82,13 @@ struct ieee80211_key {
 			 * frames and the last counter is used with Robust
 			 * Management frames.
 			 */
-			u8 rx_pn[IEEE80211_NUM_TIDS + 1][CCMP_PN_LEN];
+			u8 rx_pn[IEEE80211_NUM_TIDS + 1][IEEE80211_CCMP_PN_LEN];
 			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCCMPReplays */
 		} ccmp;
 		struct {
 			atomic64_t tx_pn;
-			u8 rx_pn[CMAC_PN_LEN];
+			u8 rx_pn[IEEE80211_CMAC_PN_LEN];
 			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCMACReplays */
 			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */

commit 6d10e46be5ac1d0ae787babd3dafd52b30686db5
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Mar 6 23:09:11 2013 +0100

    mac80211: batch key free synchronize_net()
    
    Instead of calling synchronize_net() for every key
    on an interface or when a station is removed, do it
    only once for all keys in both of these cases.
    
    As a side-effect, removing station keys now always
    calls synchronize_net() even if there are no keys,
    which fixes an issue with station removal happening
    in the driver while the station could still be used
    for TX.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index a353ddd63b5b..e8de3e6d7804 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -141,6 +141,8 @@ void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx,
 void ieee80211_set_default_mgmt_key(struct ieee80211_sub_if_data *sdata,
 				    int idx);
 void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata);
+void ieee80211_free_sta_keys(struct ieee80211_local *local,
+			     struct sta_info *sta);
 void ieee80211_enable_keys(struct ieee80211_sub_if_data *sdata);
 
 #define key_mtx_dereference(local, ref) \

commit 3b8d9c290364c86fc9f4baff7c82264a96f706d6
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Mar 6 22:58:23 2013 +0100

    mac80211: remove underscores from some key functions
    
    Some key function don't exist without underscores, so
    remove the underscores from those.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 8ef56cdfe3d7..a353ddd63b5b 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -134,7 +134,7 @@ struct ieee80211_key *ieee80211_key_alloc(u32 cipher, int idx, size_t key_len,
 int ieee80211_key_link(struct ieee80211_key *key,
 		       struct ieee80211_sub_if_data *sdata,
 		       struct sta_info *sta);
-void __ieee80211_key_free(struct ieee80211_key *key, bool delay_tailroom);
+void ieee80211_key_free(struct ieee80211_key *key, bool delay_tailroom);
 void ieee80211_key_free_unused(struct ieee80211_key *key);
 void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx,
 			       bool uni, bool multi);

commit 79cf2dfa362f3e6368ad8ecb10aa82b39678fedc
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Mar 6 22:53:52 2013 +0100

    mac80211: clean up key freeing a bit
    
    When a key is allocated but not really added, there's no
    need to go through the entire teardown process. Also, if
    adding a key fails, ieee80211_key_link() can take care of
    freeing it instead of the (only) caller.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 2a682d81cee9..8ef56cdfe3d7 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -129,14 +129,13 @@ struct ieee80211_key *ieee80211_key_alloc(u32 cipher, int idx, size_t key_len,
 					  size_t seq_len, const u8 *seq);
 /*
  * Insert a key into data structures (sdata, sta if necessary)
- * to make it used, free old key.
+ * to make it used, free old key. On failure, also free the new key.
  */
-int __must_check ieee80211_key_link(struct ieee80211_key *key,
-				    struct ieee80211_sub_if_data *sdata,
-				    struct sta_info *sta);
+int ieee80211_key_link(struct ieee80211_key *key,
+		       struct ieee80211_sub_if_data *sdata,
+		       struct sta_info *sta);
 void __ieee80211_key_free(struct ieee80211_key *key, bool delay_tailroom);
-void ieee80211_key_free(struct ieee80211_local *local,
-			struct ieee80211_key *key);
+void ieee80211_key_free_unused(struct ieee80211_key *key);
 void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx,
 			       bool uni, bool multi);
 void ieee80211_set_default_mgmt_key(struct ieee80211_sub_if_data *sdata,

commit 8d1f7ecd2af55c0c82ffd2bff0ef0b26f16ea69f
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Sat Feb 23 00:59:03 2013 +0100

    mac80211: defer tailroom counter manipulation when roaming
    
    During roaming, the crypto_tx_tailroom_needed_cnt counter
    will often take values 2,1,0,1,2 because first keys are
    removed and then new keys are added. This is inefficient
    because during the 0->1 transition, synchronize_net must
    be called to avoid packet races, although typically no
    packets would be flowing during that time.
    
    To avoid that, defer the decrement (2->1, 1->0) when keys
    are removed (by half a second). This means the counter
    will really have the values 2,2,2,3,4 ... 2, thus never
    reaching 0 and having to do the 0->1 transition.
    
    Note that this patch entirely disregards the drivers for
    which this optimisation was done to start with, for them
    the key removal itself will be expensive because it has
    to synchronize_net() after the counter is incremented to
    remove the key from HW crypto. For them the sequence will
    look like this: 0,1,0,1,0,1,0,1,0 (*) which is clearly a
    lot more inefficient. This could be addressed separately,
    during key removal the 0->1->0 sequence isn't necessary.
    
    (*) it starts at 0 because HW crypto is on, then goes to
        1 when HW crypto is disabled for a key, then back to
        0 because the key is deleted; this happens for both
        keys in the example. When new keys are added, it goes
        to 1 first because they're added in software; when a
        key is moved to hardware it goes back to 0
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 8b037307a586..2a682d81cee9 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -134,7 +134,7 @@ struct ieee80211_key *ieee80211_key_alloc(u32 cipher, int idx, size_t key_len,
 int __must_check ieee80211_key_link(struct ieee80211_key *key,
 				    struct ieee80211_sub_if_data *sdata,
 				    struct sta_info *sta);
-void __ieee80211_key_free(struct ieee80211_key *key);
+void __ieee80211_key_free(struct ieee80211_key *key, bool delay_tailroom);
 void ieee80211_key_free(struct ieee80211_local *local,
 			struct ieee80211_key *key);
 void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx,
@@ -147,4 +147,6 @@ void ieee80211_enable_keys(struct ieee80211_sub_if_data *sdata);
 #define key_mtx_dereference(local, ref) \
 	rcu_dereference_protected(ref, lockdep_is_held(&((local)->key_mtx)))
 
+void ieee80211_delayed_tailroom_dec(struct work_struct *wk);
+
 #endif /* IEEE80211_KEY_H */

commit 12e7f517029dad819c45eca9ca01fdb9ba57616b
Author: Stanislaw Gruszka <sgruszka@redhat.com>
Date:   Thu Feb 28 10:55:26 2013 +0100

    mac80211: cleanup generic suspend/resume procedures
    
    Since now we disconnect before suspend, various code which save
    connection state can now be removed from suspend and resume
    procedure. Cleanup on resume side is smaller as ieee80211_reconfig()
    is also used for H/W restart.
    
    Signed-off-by: Stanislaw Gruszka <sgruszka@redhat.com>
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 382dc44ed330..8b037307a586 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -143,7 +143,6 @@ void ieee80211_set_default_mgmt_key(struct ieee80211_sub_if_data *sdata,
 				    int idx);
 void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata);
 void ieee80211_enable_keys(struct ieee80211_sub_if_data *sdata);
-void ieee80211_disable_keys(struct ieee80211_sub_if_data *sdata);
 
 #define key_mtx_dereference(local, ref) \
 	rcu_dereference_protected(ref, lockdep_is_held(&((local)->key_mtx)))

commit b98ea05861d76f458029096e8b2939fcb58e9530
Author: Saravana <saravanad@posedge.com>
Date:   Tue Dec 4 19:47:42 2012 +0530

    mac80211: add debug file for mic failure
    
    The mic failure count provides the number of mic failures that
    have happened on a given key (without a countermeasure being
    started, since that would remove the key).
    
    Signed-off-by: Saravana <saravanad@posedge.com>
    [fix NULL pointer issues]
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 7cff0d3a519c..382dc44ed330 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -81,6 +81,9 @@ struct ieee80211_key {
 
 			/* last received RSC */
 			struct tkip_ctx rx[IEEE80211_NUM_TIDS];
+
+			/* number of mic failures */
+			u32 mic_failures;
 		} tkip;
 		struct {
 			atomic64_t tx_pn;

commit 5a306f5887d5fd840beb8ea872897fa89e8fcdef
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Nov 14 23:22:21 2012 +0100

    mac80211: introduce IEEE80211_NUM_TIDS and use it
    
    Introduce IEEE80211_NUM_TIDS in the generic 802.11
    header file and use it in place of STA_TID_NUM and
    NUM_RX_DATA_QUEUES which are both really the number
    of TIDs.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 7d4e31f037d7..7cff0d3a519c 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -30,8 +30,6 @@
 #define TKIP_ICV_LEN		4
 #define CMAC_PN_LEN		6
 
-#define NUM_RX_DATA_QUEUES	16
-
 struct ieee80211_local;
 struct ieee80211_sub_if_data;
 struct sta_info;
@@ -82,17 +80,17 @@ struct ieee80211_key {
 			struct tkip_ctx tx;
 
 			/* last received RSC */
-			struct tkip_ctx rx[NUM_RX_DATA_QUEUES];
+			struct tkip_ctx rx[IEEE80211_NUM_TIDS];
 		} tkip;
 		struct {
 			atomic64_t tx_pn;
 			/*
 			 * Last received packet number. The first
-			 * NUM_RX_DATA_QUEUES counters are used with Data
+			 * IEEE80211_NUM_TIDS counters are used with Data
 			 * frames and the last counter is used with Robust
 			 * Management frames.
 			 */
-			u8 rx_pn[NUM_RX_DATA_QUEUES + 1][CCMP_PN_LEN];
+			u8 rx_pn[IEEE80211_NUM_TIDS + 1][CCMP_PN_LEN];
 			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCCMPReplays */
 		} ccmp;

commit 95acac61ba66c4abd40e038dae8c1ed2e176c7b1
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Jul 12 12:30:59 2011 +0200

    mac80211: allow driver to disconnect after resume
    
    In WoWLAN, devices may use crypto keys for TX/RX
    and could also implement GTK rekeying. If the
    driver isn't able to retrieve replay counters and
    similar information from the device upon resume,
    or if the device isn't responsive due to platform
    issues, it isn't safe to keep the connection up
    as GTK rekey messages from during the sleep time
    could be replayed against it.
    
    The only protection against that is disconnecting
    from the AP. Modifying mac80211 to do that while
    it is resuming would be very complex and invasive
    in the case that the driver requires a reconfig,
    so do it after it has resumed completely. In that
    case, however, packets might be replayed since it
    can then only happen after TX/RX are up again, so
    mark keys for interfaces that need to disconnect
    as "tainted" and drop all packets that are sent
    or received with those keys.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 86b216b01415..7d4e31f037d7 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -41,9 +41,11 @@ struct sta_info;
  *
  * @KEY_FLAG_UPLOADED_TO_HARDWARE: Indicates that this key is present
  *	in the hardware for TX crypto hardware acceleration.
+ * @KEY_FLAG_TAINTED: Key is tainted and packets should be dropped.
  */
 enum ieee80211_internal_key_flags {
 	KEY_FLAG_UPLOADED_TO_HARDWARE	= BIT(0),
+	KEY_FLAG_TAINTED		= BIT(1),
 };
 
 enum ieee80211_internal_tkip_state {

commit 3ea542d3c2862142ae511fac5ce2dfc7419dcc53
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Jul 7 18:58:00 2011 +0200

    mac80211: allow drivers to access key sequence counter
    
    In order to implement GTK rekeying, the device needs
    to be able to encrypt frames with the right PN/IV and
    check the PN/IV in RX frames. To be able to tell it
    about all those counters, we need to be able to get
    them from mac80211, this adds the required API.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index beb9c20ff48c..86b216b01415 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -28,6 +28,7 @@
 #define CCMP_PN_LEN		6
 #define TKIP_IV_LEN		8
 #define TKIP_ICV_LEN		4
+#define CMAC_PN_LEN		6
 
 #define NUM_RX_DATA_QUEUES	16
 
@@ -89,13 +90,13 @@ struct ieee80211_key {
 			 * frames and the last counter is used with Robust
 			 * Management frames.
 			 */
-			u8 rx_pn[NUM_RX_DATA_QUEUES + 1][6];
+			u8 rx_pn[NUM_RX_DATA_QUEUES + 1][CCMP_PN_LEN];
 			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCCMPReplays */
 		} ccmp;
 		struct {
 			atomic64_t tx_pn;
-			u8 rx_pn[6];
+			u8 rx_pn[CMAC_PN_LEN];
 			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCMACReplays */
 			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */

commit 9e26297a56453315ae6829aec609b5a6309af7b4
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Jul 7 18:45:03 2011 +0200

    mac80211: simplify RX PN/IV handling
    
    The current rx->queue value is slightly confusing.
    It is set to 16 on non-QoS frames, including data,
    and then used for sequence number and PN/IV checks.
    Until recently, we had a TKIP IV checking bug that
    had been introduced in 2008 to fix a seqno issue.
    Before that, we always used TID 0 for checking the
    PN or IV on non-QoS packets.
    
    Go back to the old status for PN/IV checks using
    the TID 0 counter for non-QoS by splitting up the
    rx->queue value into "seqno_idx" and "security_idx"
    in order to avoid confusion in the future. They
    each have special rules on the value used for non-
    QoS data frames.
    
    Since the handling is now unified, also revert the
    special TKIP handling from my patch
    "mac80211: fix TKIP replay vulnerability".
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 05abab05b0aa..beb9c20ff48c 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -29,7 +29,7 @@
 #define TKIP_IV_LEN		8
 #define TKIP_ICV_LEN		4
 
-#define NUM_RX_DATA_QUEUES	17
+#define NUM_RX_DATA_QUEUES	16
 
 struct ieee80211_local;
 struct ieee80211_sub_if_data;

commit 0cd20a278e1ef9da9f6a987942794c9d65af8c4d
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Jul 6 22:02:14 2011 +0200

    mac80211: use AES_BLOCK_SIZE
    
    mac80211 has a defnition of AES_BLOCK_SIZE and
    multiple definitions of AES_BLOCK_LEN. Remove
    them all and use crypto/aes.h.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index fcb52eb2f92f..05abab05b0aa 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -92,9 +92,6 @@ struct ieee80211_key {
 			u8 rx_pn[NUM_RX_DATA_QUEUES + 1][6];
 			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCCMPReplays */
-#ifndef AES_BLOCK_LEN
-#define AES_BLOCK_LEN 16
-#endif
 		} ccmp;
 		struct {
 			atomic64_t tx_pn;

commit 75396ae6d433b49482e377e6f8dbf1f42ad53f3a
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Jul 6 22:00:35 2011 +0200

    mac80211: fix CMAC races
    
    Just like TKIP and CCMP, CMAC has the PN race.
    It might not actually be possible to hit it now
    since there aren't multiple ACs for management
    frames, but fix it anyway.
    
    Also move scratch buffers onto the stack.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 05ce4c0203fc..fcb52eb2f92f 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -97,14 +97,11 @@ struct ieee80211_key {
 #endif
 		} ccmp;
 		struct {
-			u8 tx_pn[6];
+			atomic64_t tx_pn;
 			u8 rx_pn[6];
 			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCMACReplays */
 			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
-			/* scratch buffers for virt_to_page() (crypto API) */
-			u8 tx_crypto_buf[2 * AES_BLOCK_LEN];
-			u8 rx_crypto_buf[2 * AES_BLOCK_LEN];
 		} aes_cmac;
 	} u;
 

commit aba83a0b301c32dbb91c017f33307611e1a1d384
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Wed Jul 6 21:59:39 2011 +0200

    mac80211: fix CCMP races
    
    Since we can process multiple packets at the
    same time for different ACs, but the PN is
    allocated from a single counter, we need to
    use an atomic value there. Use atomic64_t to
    make this cheaper on 64-bit platforms, other
    platforms will support this through software
    emulation, see lib/atomic64.c.
    
    We also need to use an on-stack scratch buf
    so that multiple packets won't corrupt each
    others scratch buffers.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 1493c3e56b9f..05ce4c0203fc 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -82,7 +82,7 @@ struct ieee80211_key {
 			struct tkip_ctx rx[NUM_RX_DATA_QUEUES];
 		} tkip;
 		struct {
-			u8 tx_pn[6];
+			atomic64_t tx_pn;
 			/*
 			 * Last received packet number. The first
 			 * NUM_RX_DATA_QUEUES counters are used with Data
@@ -92,12 +92,9 @@ struct ieee80211_key {
 			u8 rx_pn[NUM_RX_DATA_QUEUES + 1][6];
 			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCCMPReplays */
-			/* scratch buffers for virt_to_page() (crypto API) */
 #ifndef AES_BLOCK_LEN
 #define AES_BLOCK_LEN 16
 #endif
-			u8 tx_crypto_buf[6 * AES_BLOCK_LEN];
-			u8 rx_crypto_buf[6 * AES_BLOCK_LEN];
 		} ccmp;
 		struct {
 			u8 tx_pn[6];

commit 523b02ea23b175dd3e46e3daf1bc9354376640a3
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Jul 7 22:28:01 2011 +0200

    mac80211: fix TKIP races, make API easier to use
    
    Our current TKIP code races against itself on TX
    since we can process multiple packets at the same
    time on different ACs, but they all share the TX
    context for TKIP. This can lead to bad IVs etc.
    
    Also, the crypto offload helper code just obtains
    the P1K/P2K from the cache, and can update it as
    well, but there's no guarantee that packets are
    really processed in order.
    
    To fix these issues, first introduce a spinlock
    that will protect the IV16/IV32 values in the TX
    context. This first step makes sure that we don't
    assign the same IV multiple times or get confused
    in other ways.
    
    Secondly, change the way the P1K cache works. I
    add a field "p1k_iv32" that stores the value of
    the IV32 when the P1K was last recomputed, and
    if different from the last time, then a new P1K
    is recomputed. This can cause the P1K computation
    to flip back and forth if packets are processed
    out of order. All this also happens under the new
    spinlock.
    
    Finally, because there are argument differences,
    split up the ieee80211_get_tkip_key() API into
    ieee80211_get_tkip_p1k() and ieee80211_get_tkip_p2k()
    and give them the correct arguments.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index d801d5351336..1493c3e56b9f 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -52,9 +52,10 @@ enum ieee80211_internal_tkip_state {
 };
 
 struct tkip_ctx {
-	u32 iv32;
-	u16 iv16;
-	u16 p1k[5];
+	u32 iv32;	/* current iv32 */
+	u16 iv16;	/* current iv16 */
+	u16 p1k[5];	/* p1k cache */
+	u32 p1k_iv32;	/* iv32 for which p1k computed */
 	enum ieee80211_internal_tkip_state state;
 };
 
@@ -71,6 +72,9 @@ struct ieee80211_key {
 
 	union {
 		struct {
+			/* protects tx context */
+			spinlock_t txlock;
+
 			/* last used TSC */
 			struct tkip_ctx tx;
 

commit 40b275b69ee660274b77fb612b0db31fd282fc3f
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri May 13 14:15:49 2011 +0200

    mac80211: sparse RCU annotations
    
    This adds sparse RCU annotations to most of
    mac80211, only the mesh code remains to be
    done.
    
    Due the the previous patches, the annotations
    are pretty simple. The only thing that this
    actually changes is removing the RCU usage of
    key->sta in debugfs since this pointer isn't
    actually an RCU-managed pointer (it only has
    a single assignment done before the key even
    goes live). As that is otherwise harmless, I
    decided to make it part of this patch.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index e5432ef8b203..d801d5351336 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -146,4 +146,7 @@ void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata);
 void ieee80211_enable_keys(struct ieee80211_sub_if_data *sdata);
 void ieee80211_disable_keys(struct ieee80211_sub_if_data *sdata);
 
+#define key_mtx_dereference(local, ref) \
+	rcu_dereference_protected(ref, lockdep_is_held(&((local)->key_mtx)))
+
 #endif /* IEEE80211_KEY_H */

commit 5c0c36412b2dc6b1e243c7e9115306fe286583b7
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu May 12 14:31:49 2011 +0200

    mac80211: make key locking clearer
    
    The code in ieee80211_del_key() doesn't acquire the
    key_mtx properly when it dereferences the keys. It
    turns out that isn't actually necessary since the
    key_mtx itself seems to be redundant since all key
    manipulations are done under the RTNL, but as long
    as we have the key_mtx we should use it the right
    way too.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 4ddbe27eb570..e5432ef8b203 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -135,6 +135,7 @@ struct ieee80211_key *ieee80211_key_alloc(u32 cipher, int idx, size_t key_len,
 int __must_check ieee80211_key_link(struct ieee80211_key *key,
 				    struct ieee80211_sub_if_data *sdata,
 				    struct sta_info *sta);
+void __ieee80211_key_free(struct ieee80211_key *key);
 void ieee80211_key_free(struct ieee80211_local *local,
 			struct ieee80211_key *key);
 void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx,

commit 2d0123a5d635e336dbab21eba62e8dd4eb3e39a0
Author: Shan Wei <shanwei@cn.fujitsu.com>
Date:   Fri Mar 4 15:14:16 2011 +0800

    mac80211: remove unused macros
    
    Compile test only.
    
    Signed-off-by: Shan Wei <shanwei@cn.fujitsu.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 8106aa1b7466..4ddbe27eb570 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -21,7 +21,6 @@
 
 #define WEP_IV_LEN		4
 #define WEP_ICV_LEN		4
-#define ALG_TKIP_KEY_LEN	32
 #define ALG_CCMP_KEY_LEN	16
 #define CCMP_HDR_LEN		8
 #define CCMP_MIC_LEN		8

commit f7e0104c1a4e77cc4f23d5969b0677bdc4f62c63
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Thu Dec 9 19:49:02 2010 +0100

    mac80211: support separate default keys
    
    Add support for split default keys (unicast
    and multicast) in mac80211.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 0db1c0f5f697..8106aa1b7466 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -138,7 +138,8 @@ int __must_check ieee80211_key_link(struct ieee80211_key *key,
 				    struct sta_info *sta);
 void ieee80211_key_free(struct ieee80211_local *local,
 			struct ieee80211_key *key);
-void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx);
+void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx,
+			       bool uni, bool multi);
 void ieee80211_set_default_mgmt_key(struct ieee80211_sub_if_data *sdata,
 				    int idx);
 void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata);

commit e31b82136d1adc7a599b6e99d3321e5831841f5a
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Oct 5 19:39:30 2010 +0200

    cfg80211/mac80211: allow per-station GTKs
    
    This adds API to allow adding per-station GTKs,
    updates mac80211 to support it, and also allows
    drivers to remove a key from hwaccel again when
    this may be necessary due to multiple GTKs.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index cb9a4a65cc68..0db1c0f5f697 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -16,6 +16,9 @@
 #include <linux/rcupdate.h>
 #include <net/mac80211.h>
 
+#define NUM_DEFAULT_KEYS 4
+#define NUM_DEFAULT_MGMT_KEYS 2
+
 #define WEP_IV_LEN		4
 #define WEP_ICV_LEN		4
 #define ALG_TKIP_KEY_LEN	32

commit 3ffc2a905b1faae4c0fe39d66f0752c3a4cbb3c7
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Fri Aug 27 14:26:52 2010 +0300

    mac80211: allow vendor specific cipher suites
    
    Allow drivers to specify their own set of cipher
    suites to advertise vendor-specific ciphers. The
    driver is then required to implement hardware
    crypto offload for it.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: Juuso Oikarinen <juuso.oikarinen@nokia.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 53b5ce12536f..cb9a4a65cc68 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -130,9 +130,9 @@ struct ieee80211_key *ieee80211_key_alloc(u32 cipher, int idx, size_t key_len,
  * Insert a key into data structures (sdata, sta if necessary)
  * to make it used, free old key.
  */
-void ieee80211_key_link(struct ieee80211_key *key,
-			struct ieee80211_sub_if_data *sdata,
-			struct sta_info *sta);
+int __must_check ieee80211_key_link(struct ieee80211_key *key,
+				    struct ieee80211_sub_if_data *sdata,
+				    struct sta_info *sta);
 void ieee80211_key_free(struct ieee80211_local *local,
 			struct ieee80211_key *key);
 void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx);

commit 97359d1235eaf634fe706c9faa6e40181cc95fb8
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Aug 10 09:46:38 2010 +0200

    mac80211: use cipher suite selectors
    
    Currently, mac80211 translates the cfg80211
    cipher suite selectors into ALG_* values.
    That isn't all too useful, and some drivers
    benefit from the distinction between WEP40
    and WEP104 as well. Therefore, convert it
    all to use the cipher suite selectors.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Acked-by: Gertjan van Wingerde <gwingerde@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index b665bbb7a471..53b5ce12536f 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -123,9 +123,7 @@ struct ieee80211_key {
 	struct ieee80211_key_conf conf;
 };
 
-struct ieee80211_key *ieee80211_key_alloc(enum ieee80211_key_alg alg,
-					  int idx,
-					  size_t key_len,
+struct ieee80211_key *ieee80211_key_alloc(u32 cipher, int idx, size_t key_len,
 					  const u8 *key_data,
 					  size_t seq_len, const u8 *seq);
 /*

commit 32162a4dab0e6a4ca7f886a01173b5f9b80843be
Author: Jouni Malinen <j@w1.fi>
Date:   Mon Jul 26 15:52:03 2010 -0700

    mac80211: Fix key freeing to handle unlinked keys
    
    Key locking simplification removed key->sdata != NULL verification from
    ieee80211_key_free(). While that is fine for most use cases, there is one
    path where this function can be called with an unlinked key (i.e.,
    key->sdata == NULL && key->local == NULL). This results in a NULL pointer
    dereference with the current implementation. This is known to happen at
    least with FT protocol when wpa_supplicant tries to configure the key
    before association.
    
    Avoid the issue by passing in the local pointer to
    ieee80211_key_free(). In addition, do not clear the key from hw_accel
    or debugfs if it has not yet been added. At least the hw_accel one could
    trigger another NULL pointer dereference.
    
    Signed-off-by: Jouni Malinen <j@w1.fi>
    Reviewed-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index a3849fa3fce8..b665bbb7a471 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -135,7 +135,8 @@ struct ieee80211_key *ieee80211_key_alloc(enum ieee80211_key_alg alg,
 void ieee80211_key_link(struct ieee80211_key *key,
 			struct ieee80211_sub_if_data *sdata,
 			struct sta_info *sta);
-void ieee80211_key_free(struct ieee80211_key *key);
+void ieee80211_key_free(struct ieee80211_local *local,
+			struct ieee80211_key *key);
 void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx);
 void ieee80211_set_default_mgmt_key(struct ieee80211_sub_if_data *sdata,
 				    int idx);

commit 9190252c952a33efa1ceff4ef35188f8a27b81cb
Author: Jouni Malinen <jouni.malinen@atheros.com>
Date:   Fri Jun 11 10:27:33 2010 -0700

    mac80211: Use a separate CCMP PN receive counter for management frames
    
    When management frame protection (IEEE 802.11w) is used, we must use a
    separate counter for tracking received CCMP packet number for the
    management frames. The previously used NUM_RX_DATA_QUEUESth queue was
    shared with data frames when QoS was not used and that can cause
    problems in detecting replays incorrectly for robust management frames.
    Add a new counter just for robust management frames to avoid this issue.
    
    Signed-off-by: Jouni Malinen <jouni.malinen@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 9996e3be6e63..a3849fa3fce8 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -77,7 +77,13 @@ struct ieee80211_key {
 		} tkip;
 		struct {
 			u8 tx_pn[6];
-			u8 rx_pn[NUM_RX_DATA_QUEUES][6];
+			/*
+			 * Last received packet number. The first
+			 * NUM_RX_DATA_QUEUES counters are used with Data
+			 * frames and the last counter is used with Robust
+			 * Management frames.
+			 */
+			u8 rx_pn[NUM_RX_DATA_QUEUES + 1][6];
 			struct crypto_cipher *tfm;
 			u32 replays; /* dot11RSNAStatsCCMPReplays */
 			/* scratch buffers for virt_to_page() (crypto API) */

commit ad0e2b5a00dbec303e4682b403bb6703d11dcdb2
Author: Johannes Berg <johannes.berg@intel.com>
Date:   Tue Jun 1 10:19:19 2010 +0200

    mac80211: simplify key locking
    
    Since I recently made station management able
    to sleep, I can now rework key management as
    well; since it will no longer need a spinlock
    and can also use a mutex instead, a bunch of
    code to allow drivers' set_key to sleep while
    key management is protected by a spinlock can
    now be removed.
    
    Signed-off-by: Johannes Berg <johannes.berg@intel.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index bdc2968c2bbe..9996e3be6e63 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -38,25 +38,9 @@ struct sta_info;
  *
  * @KEY_FLAG_UPLOADED_TO_HARDWARE: Indicates that this key is present
  *	in the hardware for TX crypto hardware acceleration.
- * @KEY_FLAG_TODO_DELETE: Key is marked for deletion and will, after an
- *	RCU grace period, no longer be reachable other than from the
- *	todo list.
- * @KEY_FLAG_TODO_HWACCEL_ADD: Key needs to be added to hardware acceleration.
- * @KEY_FLAG_TODO_HWACCEL_REMOVE: Key needs to be removed from hardware
- *	acceleration.
- * @KEY_FLAG_TODO_DEFKEY: Key is default key and debugfs needs to be updated.
- * @KEY_FLAG_TODO_ADD_DEBUGFS: Key needs to be added to debugfs.
- * @KEY_FLAG_TODO_DEFMGMTKEY: Key is default management key and debugfs needs
- *	to be updated.
  */
 enum ieee80211_internal_key_flags {
 	KEY_FLAG_UPLOADED_TO_HARDWARE	= BIT(0),
-	KEY_FLAG_TODO_DELETE		= BIT(1),
-	KEY_FLAG_TODO_HWACCEL_ADD	= BIT(2),
-	KEY_FLAG_TODO_HWACCEL_REMOVE	= BIT(3),
-	KEY_FLAG_TODO_DEFKEY		= BIT(4),
-	KEY_FLAG_TODO_ADD_DEBUGFS	= BIT(5),
-	KEY_FLAG_TODO_DEFMGMTKEY	= BIT(6),
 };
 
 enum ieee80211_internal_tkip_state {
@@ -79,10 +63,8 @@ struct ieee80211_key {
 
 	/* for sdata list */
 	struct list_head list;
-	/* for todo list */
-	struct list_head todo;
 
-	/* protected by todo lock! */
+	/* protected by key mutex */
 	unsigned int flags;
 
 	union {
@@ -155,6 +137,4 @@ void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata);
 void ieee80211_enable_keys(struct ieee80211_sub_if_data *sdata);
 void ieee80211_disable_keys(struct ieee80211_sub_if_data *sdata);
 
-void ieee80211_key_todo(void);
-
 #endif /* IEEE80211_KEY_H */

commit ca99861d5421c91f5a8fd3a77acb4b7be14f119d
Author: gregor kowski <gregor.kowski@gmail.com>
Date:   Wed Dec 9 23:25:05 2009 +0100

    mac80211 : fix a race with update_tkip_key
    
    The mac80211 tkip code won't call update_tkip_key, if rx packets
    are received without KEY_FLAG_UPLOADED_TO_HARDWARE. This can happen on
    first packet because the hardware key stuff is called asynchronously with
    todo workqueue.
    
    This patch workaround that by tracking if we sent the key to the driver.
    
    Signed-off-by: Gregor Kowski <gregor.kowski@gmail.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index a49f93b79e92..bdc2968c2bbe 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -59,11 +59,17 @@ enum ieee80211_internal_key_flags {
 	KEY_FLAG_TODO_DEFMGMTKEY	= BIT(6),
 };
 
+enum ieee80211_internal_tkip_state {
+	TKIP_STATE_NOT_INIT,
+	TKIP_STATE_PHASE1_DONE,
+	TKIP_STATE_PHASE1_HW_UPLOADED,
+};
+
 struct tkip_ctx {
 	u32 iv32;
 	u16 iv16;
 	u16 p1k[5];
-	int initialized;
+	enum ieee80211_internal_tkip_state state;
 };
 
 struct ieee80211_key {

commit 7bcfaf2f431c09c51fe776fc06638b25d3b421c5
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Oct 27 12:59:03 2009 +0100

    cfg80211/mac80211: use debugfs_remove_recursive
    
    We can save a lot of code and pointers in the structs
    by using debugfs_remove_recursive().
    
    First, change cfg80211 to use debugfs_remove_recursive()
    so that drivers do not need to clean up any files they
    added to the per-wiphy debugfs (if and only if they are
    ok to be accessed until after wiphy_unregister!).
    
    Then also make mac80211 use debugfs_remove_recursive()
    where necessary -- it need not remove per-wiphy files
    as cfg80211 now removes those, but netdev etc. files
    still need to be handled but can now be removed without
    needing struct dentry pointers to all of them.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 9572e00f532c..a49f93b79e92 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -118,18 +118,6 @@ struct ieee80211_key {
 	struct {
 		struct dentry *stalink;
 		struct dentry *dir;
-		struct dentry *keylen;
-		struct dentry *flags;
-		struct dentry *keyidx;
-		struct dentry *hw_key_idx;
-		struct dentry *tx_rx_count;
-		struct dentry *algorithm;
-		struct dentry *tx_spec;
-		struct dentry *rx_spec;
-		struct dentry *replays;
-		struct dentry *icverrors;
-		struct dentry *key;
-		struct dentry *ifindex;
 		int cnt;
 	} debugfs;
 #endif

commit faa8fdc85347cc76d87b43ea718785661c54f656
Author: Jouni Malinen <jouni.malinen@atheros.com>
Date:   Mon May 11 21:57:58 2009 +0300

    nl80211: Add RSC configuration for new keys
    
    When setting a key with NL80211_CMD_NEW_KEY, we should allow the key
    sequence number (RSC) to be set in order to allow replay protection to
    work correctly for group keys. This patch documents this use for
    nl80211 and adds the couple of missing pieces in nl80211/cfg80211 and
    mac80211 to support this. In addition, WEXT SIOCSIWENCODEEXT compat
    processing in cfg80211 is extended to handle the RSC (this was already
    specified in WEXT, but just not implemented in cfg80211/mac80211).
    
    Signed-off-by: Jouni Malinen <jouni.malinen@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 215d3ef42a4f..9572e00f532c 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -144,7 +144,8 @@ struct ieee80211_key {
 struct ieee80211_key *ieee80211_key_alloc(enum ieee80211_key_alg alg,
 					  int idx,
 					  size_t key_len,
-					  const u8 *key_data);
+					  const u8 *key_data,
+					  size_t seq_len, const u8 *seq);
 /*
  * Insert a key into data structures (sdata, sta if necessary)
  * to make it used, free old key.

commit 3cfcf6ac6d69dc290e96416731eea5c88ac7d426
Author: Jouni Malinen <j@w1.fi>
Date:   Thu Jan 8 13:32:02 2009 +0200

    mac80211: 802.11w - Use BIP (AES-128-CMAC)
    
    Add mechanism for managing BIP keys (IGTK) and integrate BIP into the
    TX/RX paths.
    
    Signed-off-by: Jouni Malinen <j@w1.fi>
    Acked-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 73ac28ca2ede..215d3ef42a4f 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -46,6 +46,8 @@ struct sta_info;
  *	acceleration.
  * @KEY_FLAG_TODO_DEFKEY: Key is default key and debugfs needs to be updated.
  * @KEY_FLAG_TODO_ADD_DEBUGFS: Key needs to be added to debugfs.
+ * @KEY_FLAG_TODO_DEFMGMTKEY: Key is default management key and debugfs needs
+ *	to be updated.
  */
 enum ieee80211_internal_key_flags {
 	KEY_FLAG_UPLOADED_TO_HARDWARE	= BIT(0),
@@ -54,6 +56,7 @@ enum ieee80211_internal_key_flags {
 	KEY_FLAG_TODO_HWACCEL_REMOVE	= BIT(3),
 	KEY_FLAG_TODO_DEFKEY		= BIT(4),
 	KEY_FLAG_TODO_ADD_DEBUGFS	= BIT(5),
+	KEY_FLAG_TODO_DEFMGMTKEY	= BIT(6),
 };
 
 struct tkip_ctx {
@@ -124,6 +127,7 @@ struct ieee80211_key {
 		struct dentry *tx_spec;
 		struct dentry *rx_spec;
 		struct dentry *replays;
+		struct dentry *icverrors;
 		struct dentry *key;
 		struct dentry *ifindex;
 		int cnt;
@@ -150,6 +154,8 @@ void ieee80211_key_link(struct ieee80211_key *key,
 			struct sta_info *sta);
 void ieee80211_key_free(struct ieee80211_key *key);
 void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx);
+void ieee80211_set_default_mgmt_key(struct ieee80211_sub_if_data *sdata,
+				    int idx);
 void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata);
 void ieee80211_enable_keys(struct ieee80211_sub_if_data *sdata);
 void ieee80211_disable_keys(struct ieee80211_sub_if_data *sdata);

commit 765cb46a3fc856245ea68a7c961ac87c77e4ae2d
Author: Jouni Malinen <j@w1.fi>
Date:   Thu Jan 8 13:32:01 2009 +0200

    mac80211: 802.11w - Add BIP (AES-128-CMAC)
    
    Implement Broadcast/Multicast Integrity Protocol for management frame
    protection. This patch adds the needed definitions for the new
    information element (MMIE) and implementation for the new "encryption"
    type (though, BIP is actually not encrypting data, it provides only
    integrity protection). These routines will be used by a follow-on patch
    that enables BIP for multicast/broadcast robust management frames.
    
    Signed-off-by: Jouni Malinen <j@w1.fi>
    Acked-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 425816e0996c..73ac28ca2ede 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -96,6 +96,16 @@ struct ieee80211_key {
 			u8 tx_crypto_buf[6 * AES_BLOCK_LEN];
 			u8 rx_crypto_buf[6 * AES_BLOCK_LEN];
 		} ccmp;
+		struct {
+			u8 tx_pn[6];
+			u8 rx_pn[6];
+			struct crypto_cipher *tfm;
+			u32 replays; /* dot11RSNAStatsCMACReplays */
+			u32 icverrors; /* dot11RSNAStatsCMACICVErrors */
+			/* scratch buffers for virt_to_page() (crypto API) */
+			u8 tx_crypto_buf[2 * AES_BLOCK_LEN];
+			u8 rx_crypto_buf[2 * AES_BLOCK_LEN];
+		} aes_cmac;
 	} u;
 
 	/* number of times this key has been used */

commit ffd7891dc909b3648e87f7cf8f84a6dc12fc1cc6
Author: Luis R. Rodriguez <lrodriguez@atheros.com>
Date:   Sat Jun 21 10:02:46 2008 -0400

    mac80211: Let drivers have access to TKIP key offets for TX and RX MIC
    
    Some drivers may want to to use the TKIP key offsets for TX and RX
    MIC so lets move this out. Lets also clear up a bit how this is used
    internally in mac80211.
    
    Signed-off-by: Luis R. Rodriguez <lrodriguez@atheros.com>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index a0f774aafa45..425816e0996c 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -16,31 +16,18 @@
 #include <linux/rcupdate.h>
 #include <net/mac80211.h>
 
-/* ALG_TKIP
- * struct ieee80211_key::key is encoded as a 256-bit (32 byte) data block:
- * Temporal Encryption Key (128 bits)
- * Temporal Authenticator Tx MIC Key (64 bits)
- * Temporal Authenticator Rx MIC Key (64 bits)
- */
-
-#define WEP_IV_LEN 4
-#define WEP_ICV_LEN 4
-
-#define ALG_TKIP_KEY_LEN 32
-/* Starting offsets for each key */
-#define ALG_TKIP_TEMP_ENCR_KEY 0
-#define ALG_TKIP_TEMP_AUTH_TX_MIC_KEY 16
-#define ALG_TKIP_TEMP_AUTH_RX_MIC_KEY 24
-#define TKIP_IV_LEN 8
-#define TKIP_ICV_LEN 4
-
-#define ALG_CCMP_KEY_LEN 16
-#define CCMP_HDR_LEN 8
-#define CCMP_MIC_LEN 8
-#define CCMP_TK_LEN 16
-#define CCMP_PN_LEN 6
-
-#define NUM_RX_DATA_QUEUES 17
+#define WEP_IV_LEN		4
+#define WEP_ICV_LEN		4
+#define ALG_TKIP_KEY_LEN	32
+#define ALG_CCMP_KEY_LEN	16
+#define CCMP_HDR_LEN		8
+#define CCMP_MIC_LEN		8
+#define CCMP_TK_LEN		16
+#define CCMP_PN_LEN		6
+#define TKIP_IV_LEN		8
+#define TKIP_ICV_LEN		4
+
+#define NUM_RX_DATA_QUEUES	17
 
 struct ieee80211_local;
 struct ieee80211_sub_if_data;

commit b0f76b335f8b1c324b4b2be06369d391b26a7cc9
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed May 14 16:26:19 2008 -0700

    mac80211: add a struct to hold tkip context
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: "John W. Linville" <linville@tuxdriver.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index f52c3df1fe9a..a0f774aafa45 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -69,6 +69,13 @@ enum ieee80211_internal_key_flags {
 	KEY_FLAG_TODO_ADD_DEBUGFS	= BIT(5),
 };
 
+struct tkip_ctx {
+	u32 iv32;
+	u16 iv16;
+	u16 p1k[5];
+	int initialized;
+};
+
 struct ieee80211_key {
 	struct ieee80211_local *local;
 	struct ieee80211_sub_if_data *sdata;
@@ -85,16 +92,10 @@ struct ieee80211_key {
 	union {
 		struct {
 			/* last used TSC */
-			u32 iv32;
-			u16 iv16;
-			u16 p1k[5];
-			int tx_initialized;
+			struct tkip_ctx tx;
 
 			/* last received RSC */
-			u32 iv32_rx[NUM_RX_DATA_QUEUES];
-			u16 iv16_rx[NUM_RX_DATA_QUEUES];
-			u16 p1k_rx[NUM_RX_DATA_QUEUES][5];
-			int rx_initialized[NUM_RX_DATA_QUEUES];
+			struct tkip_ctx rx[NUM_RX_DATA_QUEUES];
 		} tkip;
 		struct {
 			u8 tx_pn[6];

commit 3a245766901a9dfdc3f53457a7954b369b50f281
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Wed Apr 9 16:45:37 2008 +0200

    mac80211: fix key hwaccel race
    
    The previous key locking patch left a small race: it would be possible
    to add a key and take the interface down before the key todo is run so
    that hwaccel for that key is enabled on an interface that is down. Avoid
    this by running the todo list when an interface is brought up or down.
    
    This patch also fixes a small bug: before this change, a few functions
    used the key list without the lock that protects it.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 5d48518985b3..f52c3df1fe9a 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -54,16 +54,19 @@ struct sta_info;
  * @KEY_FLAG_TODO_DELETE: Key is marked for deletion and will, after an
  *	RCU grace period, no longer be reachable other than from the
  *	todo list.
- * @KEY_FLAG_TODO_HWACCEL: Key needs to be added to hardware acceleration.
+ * @KEY_FLAG_TODO_HWACCEL_ADD: Key needs to be added to hardware acceleration.
+ * @KEY_FLAG_TODO_HWACCEL_REMOVE: Key needs to be removed from hardware
+ *	acceleration.
  * @KEY_FLAG_TODO_DEFKEY: Key is default key and debugfs needs to be updated.
  * @KEY_FLAG_TODO_ADD_DEBUGFS: Key needs to be added to debugfs.
  */
 enum ieee80211_internal_key_flags {
 	KEY_FLAG_UPLOADED_TO_HARDWARE	= BIT(0),
 	KEY_FLAG_TODO_DELETE		= BIT(1),
-	KEY_FLAG_TODO_HWACCEL		= BIT(2),
-	KEY_FLAG_TODO_DEFKEY		= BIT(3),
-	KEY_FLAG_TODO_ADD_DEBUGFS	= BIT(4),
+	KEY_FLAG_TODO_HWACCEL_ADD	= BIT(2),
+	KEY_FLAG_TODO_HWACCEL_REMOVE	= BIT(3),
+	KEY_FLAG_TODO_DEFKEY		= BIT(4),
+	KEY_FLAG_TODO_ADD_DEBUGFS	= BIT(5),
 };
 
 struct ieee80211_key {

commit d9c58f30b08bfe1e689537af5bc855a76d0fae25
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Apr 8 16:46:36 2008 -0400

    mac80211: fix key debugfs default_key link
    
    The default_key symlink points to the key index rather than
    they key counter, fix it.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
index 467890c6fe81..5d48518985b3 100644
--- a/net/mac80211/key.h
+++ b/net/mac80211/key.h
@@ -125,6 +125,7 @@ struct ieee80211_key {
 		struct dentry *replays;
 		struct dentry *key;
 		struct dentry *ifindex;
+		int cnt;
 	} debugfs;
 #endif
 

commit 2c8dccc77420fb7433da5674818959d3499d35be
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Tue Apr 8 15:14:40 2008 -0400

    mac80211: rename files
    
    This patch renames all mac80211 files (except ieee80211_i.h) to get rid
    of the useless ieee80211_ prefix.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: John W. Linville <linville@tuxdriver.com>

diff --git a/net/mac80211/key.h b/net/mac80211/key.h
new file mode 100644
index 000000000000..467890c6fe81
--- /dev/null
+++ b/net/mac80211/key.h
@@ -0,0 +1,157 @@
+/*
+ * Copyright 2002-2004, Instant802 Networks, Inc.
+ * Copyright 2005, Devicescape Software, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef IEEE80211_KEY_H
+#define IEEE80211_KEY_H
+
+#include <linux/types.h>
+#include <linux/list.h>
+#include <linux/crypto.h>
+#include <linux/rcupdate.h>
+#include <net/mac80211.h>
+
+/* ALG_TKIP
+ * struct ieee80211_key::key is encoded as a 256-bit (32 byte) data block:
+ * Temporal Encryption Key (128 bits)
+ * Temporal Authenticator Tx MIC Key (64 bits)
+ * Temporal Authenticator Rx MIC Key (64 bits)
+ */
+
+#define WEP_IV_LEN 4
+#define WEP_ICV_LEN 4
+
+#define ALG_TKIP_KEY_LEN 32
+/* Starting offsets for each key */
+#define ALG_TKIP_TEMP_ENCR_KEY 0
+#define ALG_TKIP_TEMP_AUTH_TX_MIC_KEY 16
+#define ALG_TKIP_TEMP_AUTH_RX_MIC_KEY 24
+#define TKIP_IV_LEN 8
+#define TKIP_ICV_LEN 4
+
+#define ALG_CCMP_KEY_LEN 16
+#define CCMP_HDR_LEN 8
+#define CCMP_MIC_LEN 8
+#define CCMP_TK_LEN 16
+#define CCMP_PN_LEN 6
+
+#define NUM_RX_DATA_QUEUES 17
+
+struct ieee80211_local;
+struct ieee80211_sub_if_data;
+struct sta_info;
+
+/**
+ * enum ieee80211_internal_key_flags - internal key flags
+ *
+ * @KEY_FLAG_UPLOADED_TO_HARDWARE: Indicates that this key is present
+ *	in the hardware for TX crypto hardware acceleration.
+ * @KEY_FLAG_TODO_DELETE: Key is marked for deletion and will, after an
+ *	RCU grace period, no longer be reachable other than from the
+ *	todo list.
+ * @KEY_FLAG_TODO_HWACCEL: Key needs to be added to hardware acceleration.
+ * @KEY_FLAG_TODO_DEFKEY: Key is default key and debugfs needs to be updated.
+ * @KEY_FLAG_TODO_ADD_DEBUGFS: Key needs to be added to debugfs.
+ */
+enum ieee80211_internal_key_flags {
+	KEY_FLAG_UPLOADED_TO_HARDWARE	= BIT(0),
+	KEY_FLAG_TODO_DELETE		= BIT(1),
+	KEY_FLAG_TODO_HWACCEL		= BIT(2),
+	KEY_FLAG_TODO_DEFKEY		= BIT(3),
+	KEY_FLAG_TODO_ADD_DEBUGFS	= BIT(4),
+};
+
+struct ieee80211_key {
+	struct ieee80211_local *local;
+	struct ieee80211_sub_if_data *sdata;
+	struct sta_info *sta;
+
+	/* for sdata list */
+	struct list_head list;
+	/* for todo list */
+	struct list_head todo;
+
+	/* protected by todo lock! */
+	unsigned int flags;
+
+	union {
+		struct {
+			/* last used TSC */
+			u32 iv32;
+			u16 iv16;
+			u16 p1k[5];
+			int tx_initialized;
+
+			/* last received RSC */
+			u32 iv32_rx[NUM_RX_DATA_QUEUES];
+			u16 iv16_rx[NUM_RX_DATA_QUEUES];
+			u16 p1k_rx[NUM_RX_DATA_QUEUES][5];
+			int rx_initialized[NUM_RX_DATA_QUEUES];
+		} tkip;
+		struct {
+			u8 tx_pn[6];
+			u8 rx_pn[NUM_RX_DATA_QUEUES][6];
+			struct crypto_cipher *tfm;
+			u32 replays; /* dot11RSNAStatsCCMPReplays */
+			/* scratch buffers for virt_to_page() (crypto API) */
+#ifndef AES_BLOCK_LEN
+#define AES_BLOCK_LEN 16
+#endif
+			u8 tx_crypto_buf[6 * AES_BLOCK_LEN];
+			u8 rx_crypto_buf[6 * AES_BLOCK_LEN];
+		} ccmp;
+	} u;
+
+	/* number of times this key has been used */
+	int tx_rx_count;
+
+#ifdef CONFIG_MAC80211_DEBUGFS
+	struct {
+		struct dentry *stalink;
+		struct dentry *dir;
+		struct dentry *keylen;
+		struct dentry *flags;
+		struct dentry *keyidx;
+		struct dentry *hw_key_idx;
+		struct dentry *tx_rx_count;
+		struct dentry *algorithm;
+		struct dentry *tx_spec;
+		struct dentry *rx_spec;
+		struct dentry *replays;
+		struct dentry *key;
+		struct dentry *ifindex;
+	} debugfs;
+#endif
+
+	/*
+	 * key config, must be last because it contains key
+	 * material as variable length member
+	 */
+	struct ieee80211_key_conf conf;
+};
+
+struct ieee80211_key *ieee80211_key_alloc(enum ieee80211_key_alg alg,
+					  int idx,
+					  size_t key_len,
+					  const u8 *key_data);
+/*
+ * Insert a key into data structures (sdata, sta if necessary)
+ * to make it used, free old key.
+ */
+void ieee80211_key_link(struct ieee80211_key *key,
+			struct ieee80211_sub_if_data *sdata,
+			struct sta_info *sta);
+void ieee80211_key_free(struct ieee80211_key *key);
+void ieee80211_set_default_key(struct ieee80211_sub_if_data *sdata, int idx);
+void ieee80211_free_keys(struct ieee80211_sub_if_data *sdata);
+void ieee80211_enable_keys(struct ieee80211_sub_if_data *sdata);
+void ieee80211_disable_keys(struct ieee80211_sub_if_data *sdata);
+
+void ieee80211_key_todo(void);
+
+#endif /* IEEE80211_KEY_H */
