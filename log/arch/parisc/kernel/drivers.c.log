commit 4f80b70e1953cb846dbdd1ce72cb17333d4c8d11
Author: Krzysztof Kozlowski <krzk@kernel.org>
Date:   Fri Jan 3 17:39:25 2020 +0100

    parisc: Use proper printk format for resource_size_t
    
    resource_size_t should be printed with its own size-independent format
    to fix warnings when compiling on 64-bit platform (e.g. with
    COMPILE_TEST):
    
        arch/parisc/kernel/drivers.c: In function 'print_parisc_device':
        arch/parisc/kernel/drivers.c:892:9: warning:
            format '%p' expects argument of type 'void *',
            but argument 4 has type 'resource_size_t {aka unsigned int}' [-Wformat=]
    
    Signed-off-by: Krzysztof Kozlowski <krzk@kernel.org>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index a6c9f49c6612..a5f3e50fe976 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -889,8 +889,8 @@ static void print_parisc_device(struct parisc_device *dev)
 	static int count;
 
 	print_pa_hwpath(dev, hw_path);
-	pr_info("%d. %s at 0x%px [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }",
-		++count, dev->name, (void*) dev->hpa.start, hw_path, dev->id.hw_type,
+	pr_info("%d. %s at %pap [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }",
+		++count, dev->name, &(dev->hpa.start), hw_path, dev->id.hw_type,
 		dev->id.hversion_rev, dev->id.hversion, dev->id.sversion);
 
 	if (dev->num_addrs) {

commit aeea5eae4fd54e94d820ed17ea3b238160be723e
Author: Sven Schnelle <svens@stackframe.org>
Date:   Sun Dec 15 20:09:27 2019 +0100

    parisc: add missing __init annotation
    
    compilation failed with:
    
    MODPOST vmlinux.o
    WARNING: vmlinux.o(.text.unlikely+0xa0c): Section mismatch in reference from the function walk_lower_bus() to the function .init.text:walk_native_bus()
    The function walk_lower_bus() references
    the function __init walk_native_bus().
    This is often because walk_lower_bus lacks a __init
    annotation or the annotation of walk_native_bus is wrong.
    
    FATAL: modpost: Section mismatches detected.
    Set CONFIG_SECTION_MISMATCH_WARN_ONLY=y to allow them.
    make[2]: *** [/home/svens/linux/parisc-linux/src/scripts/Makefile.modpost:64: __modpost] Error 1
    make[1]: *** [/home/svens/linux/parisc-linux/src/Makefile:1077: vmlinux] Error 2
    make[1]: Leaving directory '/home/svens/linux/parisc-linux/build'
    make: *** [Makefile:179: sub-make] Error 2
    
    Signed-off-by: Sven Schnelle <svens@stackframe.org>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 3b330e58a4f0..a6c9f49c6612 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -810,7 +810,7 @@ EXPORT_SYMBOL(device_to_hwpath);
 static void walk_native_bus(unsigned long io_io_low, unsigned long io_io_high,
                             struct device *parent);
 
-static void walk_lower_bus(struct parisc_device *dev)
+static void __init walk_lower_bus(struct parisc_device *dev)
 {
 	unsigned long io_io_low, io_io_high;
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 00a181f1ecc6..3b330e58a4f0 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -1,11 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * drivers.c
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
  * Copyright (c) 1999 The Puffin Group
  * Copyright (c) 2001 Matthew Wilcox for Hewlett Packard
  * Copyright (c) 2001 Helge Deller <deller@gmx.de>

commit 9aa8848a751fec5f655f4409875baaee1ca3e3e8
Author: Helge Deller <deller@gmx.de>
Date:   Fri May 10 20:49:16 2019 +0200

    parisc: Use __ro_after_init in drivers.c
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 15e7b3be7b6b..00a181f1ecc6 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -41,7 +41,7 @@
 #include <asm/ropes.h>
 
 /* See comments in include/asm-parisc/pci.h */
-const struct dma_map_ops *hppa_dma_ops __read_mostly;
+const struct dma_map_ops *hppa_dma_ops __ro_after_init;
 EXPORT_SYMBOL(hppa_dma_ops);
 
 static struct device root = {

commit b37d1c1898b288c69f3dc9267bc2c41af06f4a4b
Author: Mikulas Patocka <mpatocka@redhat.com>
Date:   Sun Apr 28 00:09:53 2019 +0200

    parisc: Use per-pagetable spinlock
    
    PA-RISC uses a global spinlock to protect pagetable updates in the TLB
    fault handlers. When multiple cores are taking TLB faults simultaneously,
    the cache line containing the spinlock becomes a bottleneck.
    
    This patch embeds the spinlock in the top level page directory, so that
    every process has its own lock. It improves performance by 30% when
    doing parallel compilations.
    
    At least on the N class systems, only one PxTLB inter processor
    broadcast can be active at any one time on the Merced bus. If a Merced
    bus is found, this patch serializes the TLB flushes with the
    pa_tlb_flush_lock spinlock.
    
    v1: Initial patch by Mikulas
    v2: Added Merced detection by Helge
    v3: Revised TLB serialization by Dave & Helge
    
    Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
    Signed-off-by: John David Anglin <dave.anglin@bell.net>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 5eb979d04b90..15e7b3be7b6b 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -38,6 +38,7 @@
 #include <asm/io.h>
 #include <asm/pdc.h>
 #include <asm/parisc-device.h>
+#include <asm/ropes.h>
 
 /* See comments in include/asm-parisc/pci.h */
 const struct dma_map_ops *hppa_dma_ops __read_mostly;
@@ -257,6 +258,30 @@ static struct parisc_device *find_device_by_addr(unsigned long hpa)
 	return ret ? d.dev : NULL;
 }
 
+static int __init is_IKE_device(struct device *dev, void *data)
+{
+	struct parisc_device *pdev = to_parisc_device(dev);
+
+	if (!check_dev(dev))
+		return 0;
+	if (pdev->id.hw_type != HPHW_BCPORT)
+		return 0;
+	if (IS_IKE(pdev) ||
+		(pdev->id.hversion == REO_MERCED_PORT) ||
+		(pdev->id.hversion == REOG_MERCED_PORT)) {
+			return 1;
+	}
+	return 0;
+}
+
+int __init machine_has_merced_bus(void)
+{
+	int ret;
+
+	ret = for_each_padev(is_IKE_device, NULL);
+	return ret ? 1 : 0;
+}
+
 /**
  * find_pa_parent_type - Find a parent of a specific type
  * @dev: The device to start searching from

commit 5e791d2e4785f9ec7da4a02b9e8d00dace9e6917
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Tue May 29 22:38:01 2018 +0300

    parisc: Convert printk(KERN_LEVEL) to pr_lvl()
    
    Convert printk(KERN_LEVEL) type of calls to pr_lvl() macros.
    
    While here,
      - convert printk() to pr_info()
      - join back string literal to be on one line
      - use %*phN (note, it gives 1 byte more for sake of simplicity)
    
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index e0e1c9775c32..5eb979d04b90 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -154,17 +154,14 @@ int register_parisc_driver(struct parisc_driver *driver)
 {
 	/* FIXME: we need this because apparently the sti
 	 * driver can be registered twice */
-	if(driver->drv.name) {
-		printk(KERN_WARNING 
-		       "BUG: skipping previously registered driver %s\n",
-		       driver->name);
+	if (driver->drv.name) {
+		pr_warn("BUG: skipping previously registered driver %s\n",
+			driver->name);
 		return 1;
 	}
 
 	if (!driver->probe) {
-		printk(KERN_WARNING 
-		       "BUG: driver %s has no probe routine\n",
-		       driver->name);
+		pr_warn("BUG: driver %s has no probe routine\n", driver->name);
 		return 1;
 	}
 
@@ -491,12 +488,9 @@ alloc_pa_dev(unsigned long hpa, struct hardware_path *mod_path)
 
 	dev = create_parisc_device(mod_path);
 	if (dev->id.hw_type != HPHW_FAULTY) {
-		printk(KERN_ERR "Two devices have hardware path [%s].  "
-				"IODC data for second device: "
-				"%02x%02x%02x%02x%02x%02x\n"
-				"Rearranging GSC cards sometimes helps\n",
-			parisc_pathname(dev), iodc_data[0], iodc_data[1],
-			iodc_data[3], iodc_data[4], iodc_data[5], iodc_data[6]);
+		pr_err("Two devices have hardware path [%s].  IODC data for second device: %7phN\n"
+		       "Rearranging GSC cards sometimes helps\n",
+			parisc_pathname(dev), iodc_data);
 		return NULL;
 	}
 
@@ -528,8 +522,7 @@ alloc_pa_dev(unsigned long hpa, struct hardware_path *mod_path)
 	 * the keyboard controller
 	 */
 	if ((hpa & 0xfff) == 0 && insert_resource(&iomem_resource, &dev->hpa))
-		printk("Unable to claim HPA %lx for device %s\n",
-				hpa, name);
+		pr_warn("Unable to claim HPA %lx for device %s\n", hpa, name);
 
 	return dev;
 }
@@ -875,7 +868,7 @@ static void print_parisc_device(struct parisc_device *dev)
 	static int count;
 
 	print_pa_hwpath(dev, hw_path);
-	printk(KERN_INFO "%d. %s at 0x%px [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }",
+	pr_info("%d. %s at 0x%px [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }",
 		++count, dev->name, (void*) dev->hpa.start, hw_path, dev->id.hw_type,
 		dev->id.hversion_rev, dev->id.hversion, dev->id.sversion);
 

commit 3faf5246f0cd2c1fe82a2c4ba5ad857fa6941909
Author: Helge Deller <deller@gmx.de>
Date:   Fri May 18 16:08:10 2018 +0200

    parisc: Move find_pa_parent_type() out of init section
    
    The 0-DAY kernel test infrastructure reported that inet_put_port() may
    reference the find_pa_parent_type() function, so it can't be moved into the
    init section.
    
    Fixes: b86db40e1ecc ("parisc: Move various functions and strings to init section")
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index ee5a78a151a6..e0e1c9775c32 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -268,7 +268,7 @@ static struct parisc_device *find_device_by_addr(unsigned long hpa)
  * Walks up the device tree looking for a device of the specified type.
  * If it finds it, it returns it.  If not, it returns NULL.
  */
-const struct parisc_device * __init
+const struct parisc_device *
 find_pa_parent_type(const struct parisc_device *padev, int type)
 {
 	const struct device *dev = &padev->dev;

commit b819439fea305a0bfd6ca23a7994fd1a8847c0d8
Author: Helge Deller <deller@gmx.de>
Date:   Fri Apr 20 23:19:17 2018 +0200

    parisc: drivers.c: Fix section mismatches
    
    Fix two section mismatches in drivers.c:
    1) Section mismatch in reference from the function alloc_tree_node() to
       the function .init.text:create_tree_node().
    2) Section mismatch in reference from the function walk_native_bus() to
       the function .init.text:alloc_pa_dev().
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 3b8507f71050..ee5a78a151a6 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -448,7 +448,8 @@ static int match_by_id(struct device * dev, void * data)
  * Checks all the children of @parent for a matching @id.  If none
  * found, it allocates a new device and returns it.
  */
-static struct parisc_device * alloc_tree_node(struct device *parent, char id)
+static struct parisc_device * __init alloc_tree_node(
+			struct device *parent, char id)
 {
 	struct match_id_data d = {
 		.id = id,
@@ -825,8 +826,8 @@ static void walk_lower_bus(struct parisc_device *dev)
  * devices which are not physically connected (such as extra serial &
  * keyboard ports).  This problem is not yet solved.
  */
-static void walk_native_bus(unsigned long io_io_low, unsigned long io_io_high,
-                            struct device *parent)
+static void __init walk_native_bus(unsigned long io_io_low,
+	unsigned long io_io_high, struct device *parent)
 {
 	int i, devices_found = 0;
 	unsigned long hpa = io_io_low;

commit 615b2665fd20c327b631ff1e79426775de748094
Author: Helge Deller <deller@gmx.de>
Date:   Sun Mar 25 23:53:22 2018 +0200

    parisc: Fix out of array access in match_pci_device()
    
    As found by the ubsan checker, the value of the 'index' variable can be
    out of range for the bc[] array:
    
    UBSAN: Undefined behaviour in arch/parisc/kernel/drivers.c:655:21
    index 6 is out of range for type 'char [6]'
    Backtrace:
     [<104fa850>] __ubsan_handle_out_of_bounds+0x68/0x80
     [<1019d83c>] check_parent+0xc0/0x170
     [<1019d91c>] descend_children+0x30/0x6c
     [<1059e164>] device_for_each_child+0x60/0x98
     [<1019cd54>] parse_tree_node+0x40/0x54
     [<1019d86c>] check_parent+0xf0/0x170
     [<1019d91c>] descend_children+0x30/0x6c
     [<1059e164>] device_for_each_child+0x60/0x98
     [<1019d938>] descend_children+0x4c/0x6c
     [<1059e164>] device_for_each_child+0x60/0x98
     [<1019cd54>] parse_tree_node+0x40/0x54
     [<1019cffc>] hwpath_to_device+0xa4/0xc4
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Cc: stable@vger.kernel.org

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 6afb595e0d86..3b8507f71050 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -651,6 +651,10 @@ static int match_pci_device(struct device *dev, int index,
 					(modpath->mod == PCI_FUNC(devfn)));
 	}
 
+	/* index might be out of bounds for bc[] */
+	if (index >= 6)
+		return 0;
+
 	id = PCI_SLOT(pdev->devfn) | (PCI_FUNC(pdev->devfn) << 5);
 	return (modpath->bc[index] == id);
 }

commit a77ab0e7ce232a62adac3d85b9ae66d0f48385ac
Author: Helge Deller <deller@gmx.de>
Date:   Sun Mar 25 18:52:58 2018 +0200

    parisc: Add code generator for Qemu/SeaBIOS machine info
    
    Qemu now supports emulating PA-RISC machines. For that a forked version
    of SeaBIOS available at https://github.com/hdeller/seabios-hppa is used
    which requires some information about the emulated machine.
    
    This patch adds code to generate a header file with the necessary
    information for SeaBIOS. The information is extracted from the firmware
    the current kernel is running on.
    
    Tested on a B160L workstation.
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index d4256145b74c..6afb595e0d86 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -895,6 +895,171 @@ void __init init_parisc_bus(void)
 	get_device(&root);
 }
 
+static __init void qemu_header(void)
+{
+	int num;
+	unsigned long *p;
+
+	pr_info("--- cut here ---\n");
+	pr_info("/* AUTO-GENERATED HEADER FILE FOR SEABIOS FIRMWARE */\n");
+	pr_cont("/* generated with Linux kernel */\n");
+	pr_cont("/* search for PARISC_QEMU_MACHINE_HEADER in Linux */\n\n");
+
+	pr_info("#define PARISC_MODEL \"%s\"\n\n",
+			boot_cpu_data.pdc.sys_model_name);
+
+	pr_info("#define PARISC_PDC_MODEL 0x%lx, 0x%lx, 0x%lx, "
+		"0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx, 0x%lx\n\n",
+	#define p ((unsigned long *)&boot_cpu_data.pdc.model)
+		p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7], p[8]);
+	#undef p
+
+	pr_info("#define PARISC_PDC_VERSION 0x%04lx\n\n",
+			boot_cpu_data.pdc.versions);
+
+	pr_info("#define PARISC_PDC_CPUID 0x%04lx\n\n",
+			boot_cpu_data.pdc.cpuid);
+
+	pr_info("#define PARISC_PDC_CAPABILITIES 0x%04lx\n\n",
+			boot_cpu_data.pdc.capabilities);
+
+	pr_info("#define PARISC_PDC_ENTRY_ORG 0x%04lx\n\n",
+#ifdef CONFIG_64BIT
+		(unsigned long)(PAGE0->mem_pdc_hi) << 32 |
+#endif
+		(unsigned long)PAGE0->mem_pdc);
+
+	pr_info("#define PARISC_PDC_CACHE_INFO");
+	p = (unsigned long *) &cache_info;
+	for (num = 0; num < sizeof(cache_info); num += sizeof(unsigned long)) {
+		if (((num % 5) == 0)) {
+			pr_cont(" \\\n");
+			pr_info("\t");
+		}
+		pr_cont("%s0x%04lx",
+			num?", ":"", *p++);
+	}
+	pr_cont("\n\n");
+}
+
+static __init int qemu_print_hpa(struct device *lin_dev, void *data)
+{
+	struct parisc_device *dev = to_parisc_device(lin_dev);
+	unsigned long hpa = dev->hpa.start;
+
+	pr_cont("\t{\t.hpa = 0x%08lx,\\\n", hpa);
+	pr_cont("\t\t.iodc = &iodc_data_hpa_%08lx,\\\n", hpa);
+	pr_cont("\t\t.mod_info = &mod_info_hpa_%08lx,\\\n", hpa);
+	pr_cont("\t\t.mod_path = &mod_path_hpa_%08lx,\\\n", hpa);
+	pr_cont("\t\t.num_addr = HPA_%08lx_num_addr,\\\n", hpa);
+	pr_cont("\t\t.add_addr = { HPA_%08lx_add_addr } },\\\n", hpa);
+	return 0;
+}
+
+
+static __init void qemu_footer(void)
+{
+	pr_info("\n\n#define PARISC_DEVICE_LIST \\\n");
+	for_each_padev(qemu_print_hpa, NULL);
+	pr_cont("\t{ 0, }\n");
+	pr_info("--- cut here ---\n");
+}
+
+/* print iodc data of the various hpa modules for qemu inclusion */
+static __init int qemu_print_iodc_data(struct device *lin_dev, void *data)
+{
+	struct parisc_device *dev = to_parisc_device(lin_dev);
+	unsigned long count;
+	unsigned long hpa = dev->hpa.start;
+	int status;
+	struct pdc_iodc iodc_data;
+
+	int mod_index;
+	struct pdc_system_map_mod_info pdc_mod_info;
+	struct pdc_module_path mod_path;
+
+	status = pdc_iodc_read(&count, hpa, 0,
+		&iodc_data, sizeof(iodc_data));
+	if (status != PDC_OK) {
+		pr_info("No IODC data for hpa 0x%08lx\n", hpa);
+		return 0;
+	}
+
+	pr_info("\n");
+
+	pr_info("#define HPA_%08lx_DESCRIPTION \"%s\"\n",
+		hpa, parisc_hardware_description(&dev->id));
+
+	mod_index = 0;
+	do {
+		status = pdc_system_map_find_mods(&pdc_mod_info,
+				&mod_path, mod_index++);
+	} while (status == PDC_OK && pdc_mod_info.mod_addr != hpa);
+
+	pr_info("static struct pdc_system_map_mod_info"
+		" mod_info_hpa_%08lx = {\n", hpa);
+	#define DO(member) \
+		pr_cont("\t." #member " = 0x%x,\n", \
+			(unsigned int)pdc_mod_info.member)
+	DO(mod_addr);
+	DO(mod_pgs);
+	DO(add_addrs);
+	pr_cont("};\n");
+	#undef DO
+	pr_info("static struct pdc_module_path "
+		"mod_path_hpa_%08lx = {\n", hpa);
+	pr_cont("\t.path = { ");
+	pr_cont(".flags = 0x%x, ", mod_path.path.flags);
+	pr_cont(".bc = { 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x }, ",
+		(unsigned char)mod_path.path.bc[0],
+		(unsigned char)mod_path.path.bc[1],
+		(unsigned char)mod_path.path.bc[2],
+		(unsigned char)mod_path.path.bc[3],
+		(unsigned char)mod_path.path.bc[4],
+		(unsigned char)mod_path.path.bc[5]);
+	pr_cont(".mod = 0x%x ", mod_path.path.mod);
+	pr_cont(" },\n");
+	pr_cont("\t.layers = { 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x }\n",
+		mod_path.layers[0], mod_path.layers[1], mod_path.layers[2],
+		mod_path.layers[3], mod_path.layers[4], mod_path.layers[5]);
+	pr_cont("};\n");
+
+	pr_info("static struct pdc_iodc iodc_data_hpa_%08lx = {\n", hpa);
+	#define DO(member) \
+		pr_cont("\t." #member " = 0x%04lx,\n", \
+			(unsigned long)iodc_data.member)
+	DO(hversion_model);
+	DO(hversion);
+	DO(spa);
+	DO(type);
+	DO(sversion_rev);
+	DO(sversion_model);
+	DO(sversion_opt);
+	DO(rev);
+	DO(dep);
+	DO(features);
+	DO(checksum);
+	DO(length);
+	#undef DO
+	pr_cont("\t/* pad: 0x%04x, 0x%04x */\n",
+		iodc_data.pad[0], iodc_data.pad[1]);
+	pr_cont("};\n");
+
+	pr_info("#define HPA_%08lx_num_addr %d\n", hpa, dev->num_addrs);
+	pr_info("#define HPA_%08lx_add_addr ", hpa);
+	count = 0;
+	if (dev->num_addrs == 0)
+		pr_cont("0");
+	while (count < dev->num_addrs) {
+		pr_cont("0x%08lx, ", dev->addr[count]);
+		count++;
+	}
+	pr_cont("\n\n");
+
+	return 0;
+}
+
+
 
 static int print_one_device(struct device * dev, void * data)
 {
@@ -911,4 +1076,10 @@ static int print_one_device(struct device * dev, void * data)
 void __init print_parisc_devices(void)
 {
 	for_each_padev(print_one_device, NULL);
+	#define PARISC_QEMU_MACHINE_HEADER 0
+	if (PARISC_QEMU_MACHINE_HEADER) {
+		qemu_header();
+		for_each_padev(qemu_print_iodc_data, NULL);
+		qemu_footer();
+	}
 }

commit b86db40e1ecc910c73b6bed8368816d9ae378fb6
Author: Helge Deller <deller@gmx.de>
Date:   Sun Mar 4 22:26:11 2018 +0100

    parisc: Move various functions and strings to init section
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 29b99b8964aa..d4256145b74c 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -135,7 +135,7 @@ static int parisc_driver_probe(struct device *dev)
 	return rc;
 }
 
-static int parisc_driver_remove(struct device *dev)
+static int __exit parisc_driver_remove(struct device *dev)
 {
 	struct parisc_device *pa_dev = to_parisc_device(dev);
 	struct parisc_driver *pa_drv = to_parisc_driver(dev->driver);
@@ -205,7 +205,7 @@ static int match_and_count(struct device * dev, void * data)
  * Use by IOMMU support to "guess" the right size IOPdir.
  * Formula is something like memsize/(num_iommu * entry_size).
  */
-int count_parisc_driver(struct parisc_driver *driver)
+int __init count_parisc_driver(struct parisc_driver *driver)
 {
 	struct match_count m = {
 		.driver	= driver,
@@ -268,7 +268,7 @@ static struct parisc_device *find_device_by_addr(unsigned long hpa)
  * Walks up the device tree looking for a device of the specified type.
  * If it finds it, it returns it.  If not, it returns NULL.
  */
-const struct parisc_device *
+const struct parisc_device * __init
 find_pa_parent_type(const struct parisc_device *padev, int type)
 {
 	const struct device *dev = &padev->dev;
@@ -397,7 +397,7 @@ static void setup_bus_id(struct parisc_device *padev)
 	dev_set_name(&padev->dev, name);
 }
 
-struct parisc_device * create_tree_node(char id, struct device *parent)
+struct parisc_device * __init create_tree_node(char id, struct device *parent)
 {
 	struct parisc_device *dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev)
@@ -471,7 +471,7 @@ static struct parisc_device *create_parisc_device(struct hardware_path *modpath)
 	return alloc_tree_node(parent, modpath->mod);
 }
 
-struct parisc_device *
+struct parisc_device * __init
 alloc_pa_dev(unsigned long hpa, struct hardware_path *mod_path)
 {
 	int status;
@@ -609,7 +609,7 @@ struct bus_type parisc_bus_type = {
 	.uevent = parisc_uevent,
 	.dev_groups = parisc_device_groups,
 	.probe = parisc_driver_probe,
-	.remove = parisc_driver_remove,
+	.remove = __exit_p(parisc_driver_remove),
 };
 
 /**
@@ -619,7 +619,7 @@ struct bus_type parisc_bus_type = {
  * Search the driver list for a driver that is willing to manage
  * this device.
  */
-int register_parisc_device(struct parisc_device *dev)
+int __init register_parisc_device(struct parisc_device *dev)
 {
 	if (!dev)
 		return 0;
@@ -791,7 +791,7 @@ EXPORT_SYMBOL(device_to_hwpath);
 static void walk_native_bus(unsigned long io_io_low, unsigned long io_io_high,
                             struct device *parent);
 
-void walk_lower_bus(struct parisc_device *dev)
+static void walk_lower_bus(struct parisc_device *dev)
 {
 	unsigned long io_io_low, io_io_high;
 
@@ -857,7 +857,7 @@ static void walk_native_bus(unsigned long io_io_low, unsigned long io_io_high,
  * PDC doesn't tell us about all devices in the system.  This routine
  * finds devices connected to the central bus.
  */
-void walk_central_bus(void)
+void __init walk_central_bus(void)
 {
 	walk_native_bus(CENTRAL_BUS_ADDR,
 			CENTRAL_BUS_ADDR + (MAX_NATIVE_DEVICES * NATIVE_DEVICE_OFFSET),
@@ -886,7 +886,7 @@ static void print_parisc_device(struct parisc_device *dev)
 /**
  * init_parisc_bus - Some preparation to be done before inventory
  */
-void init_parisc_bus(void)
+void __init init_parisc_bus(void)
 {
 	if (bus_register(&parisc_bus_type))
 		panic("Could not register PA-RISC bus type\n");
@@ -908,7 +908,7 @@ static int print_one_device(struct device * dev, void * data)
 /**
  * print_parisc_devices - Print out a list of devices found in this system
  */
-void print_parisc_devices(void)
+void __init print_parisc_devices(void)
 {
 	for_each_padev(print_one_device, NULL);
 }

commit 0ae60d0c4f191c4241377cc3fc5931dc90ca3bbd
Author: Helge Deller <deller@gmx.de>
Date:   Tue Jan 2 20:40:21 2018 +0100

    parisc: Show unhashed hardware inventory
    
    Fixes: ad67b74d2469d9b8 ("printk: hash addresses printed with %p")
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index d8f77358e2ba..29b99b8964aa 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -870,7 +870,7 @@ static void print_parisc_device(struct parisc_device *dev)
 	static int count;
 
 	print_pa_hwpath(dev, hw_path);
-	printk(KERN_INFO "%d. %s at 0x%p [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }",
+	printk(KERN_INFO "%d. %s at 0x%px [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }",
 		++count, dev->name, (void*) dev->hpa.start, hw_path, dev->id.hw_type,
 		dev->id.hversion_rev, dev->id.hversion, dev->id.sversion);
 

commit 9b7c6682270043415921ee73e584bdc4ee289fdf
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jun 6 14:16:38 2017 +0200

    parisc: parisc_bus_type: use dev_groups and not dev_attrs for bus_type
    
    The dev_attrs field has long been "depreciated" and is finally being
    removed, so move the driver to use the "correct" dev_groups field
    instead for struct bus_type.
    
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Bart Van Assche <bart.vanassche@sandisk.com>
    Cc: Doug Ledford <dledford@redhat.com>
    Cc: <linux-parisc@vger.kernel.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index fa78419100c8..d8f77358e2ba 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -575,7 +575,8 @@ static ssize_t name##_show(struct device *dev, struct device_attribute *attr, ch
 {									\
 	struct parisc_device *padev = to_parisc_device(dev);		\
 	return sprintf(buf, format_string, padev->field);		\
-}
+}									\
+static DEVICE_ATTR_RO(name);
 
 #define pa_dev_attr_id(field, format) pa_dev_attr(field, id.field, format)
 
@@ -589,22 +590,24 @@ static ssize_t modalias_show(struct device *dev, struct device_attribute *attr,
 {
 	return make_modalias(dev, buf);
 }
+static DEVICE_ATTR_RO(modalias);
 
-static struct device_attribute parisc_device_attrs[] = {
-	__ATTR_RO(irq),
-	__ATTR_RO(hw_type),
-	__ATTR_RO(rev),
-	__ATTR_RO(hversion),
-	__ATTR_RO(sversion),
-	__ATTR_RO(modalias),
-	__ATTR_NULL,
+static struct attribute *parisc_device_attrs[] = {
+	&dev_attr_irq.attr,
+	&dev_attr_hw_type.attr,
+	&dev_attr_rev.attr,
+	&dev_attr_hversion.attr,
+	&dev_attr_sversion.attr,
+	&dev_attr_modalias.attr,
+	NULL,
 };
+ATTRIBUTE_GROUPS(parisc_device);
 
 struct bus_type parisc_bus_type = {
 	.name = "parisc",
 	.match = parisc_generic_match,
 	.uevent = parisc_uevent,
-	.dev_attrs = parisc_device_attrs,
+	.dev_groups = parisc_device_groups,
 	.probe = parisc_driver_probe,
 	.remove = parisc_driver_remove,
 };

commit 5299709d0a87342dadc1fc9850484fadeb488bf8
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Fri Jan 20 13:04:01 2017 -0800

    treewide: Constify most dma_map_ops structures
    
    Most dma_map_ops structures are never modified. Constify these
    structures such that these can be write-protected. This patch
    has been generated as follows:
    
    git grep -l 'struct dma_map_ops' |
      xargs -d\\n sed -i \
        -e 's/struct dma_map_ops/const struct dma_map_ops/g' \
        -e 's/const struct dma_map_ops {/struct dma_map_ops {/g' \
        -e 's/^const struct dma_map_ops;$/struct dma_map_ops;/' \
        -e 's/const const struct dma_map_ops /const struct dma_map_ops /g';
    sed -i -e 's/const \(struct dma_map_ops intel_dma_ops\)/\1/' \
      $(git grep -l 'struct dma_map_ops intel_dma_ops');
    sed -i -e 's/const \(struct dma_map_ops dma_iommu_ops\)/\1/' \
      $(git grep -l 'struct dma_map_ops' | grep ^arch/powerpc);
    sed -i -e '/^struct vmd_dev {$/,/^};$/ s/const \(struct dma_map_ops[[:blank:]]dma_ops;\)/\1/' \
           -e '/^static void vmd_setup_dma_ops/,/^}$/ s/const \(struct dma_map_ops \*dest\)/\1/' \
           -e 's/const \(struct dma_map_ops \*dest = \&vmd->dma_ops\)/\1/' \
        drivers/pci/host/*.c
    sed -i -e '/^void __init pci_iommu_alloc(void)$/,/^}$/ s/dma_ops->/intel_dma_ops./' arch/ia64/kernel/pci-dma.c
    sed -i -e 's/static const struct dma_map_ops sn_dma_ops/static struct dma_map_ops sn_dma_ops/' arch/ia64/sn/pci/pci_dma.c
    sed -i -e 's/(const struct dma_map_ops \*)//' drivers/misc/mic/bus/vop_bus.c
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Boris Ostrovsky <boris.ostrovsky@oracle.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: linux-arch@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: x86@kernel.org
    Signed-off-by: Doug Ledford <dledford@redhat.com>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 700e2d2da096..fa78419100c8 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -40,7 +40,7 @@
 #include <asm/parisc-device.h>
 
 /* See comments in include/asm-parisc/pci.h */
-struct dma_map_ops *hppa_dma_ops __read_mostly;
+const struct dma_map_ops *hppa_dma_ops __read_mostly;
 EXPORT_SYMBOL(hppa_dma_ops);
 
 static struct device root = {

commit 6f63d0f6be4e48b3042df9541694f6f2c405017e
Author: Helge Deller <deller@gmx.de>
Date:   Fri Oct 28 20:56:07 2016 +0200

    parisc: use KERN_CONT when printing device inventory
    
    Recent changes to printk require KERN_CONT uses to continue logging messages.
    So add KERN_CONT to output of device inventory.
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index f8150669b8c6..700e2d2da096 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -873,11 +873,11 @@ static void print_parisc_device(struct parisc_device *dev)
 
 	if (dev->num_addrs) {
 		int k;
-		printk(", additional addresses: ");
+		pr_cont(", additional addresses: ");
 		for (k = 0; k < dev->num_addrs; k++)
-			printk("0x%lx ", dev->addr[k]);
+			pr_cont("0x%lx ", dev->addr[k]);
 	}
-	printk("\n");
+	pr_cont("\n");
 }
 
 /**

commit 79387179e2e4fede52326e4c4e26145dbd6b505c
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 20 15:01:47 2016 -0800

    parisc: convert to dma_map_ops
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Helge Deller <deller@gmx.de>
    Acked-by: Helge Deller <deller@gmx.de>
    Cc: Christian Borntraeger <borntraeger@de.ibm.com>
    Cc: Joerg Roedel <jroedel@suse.de>
    Cc: Sebastian Ott <sebott@linux.vnet.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index dba508fe1683..f8150669b8c6 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -40,7 +40,7 @@
 #include <asm/parisc-device.h>
 
 /* See comments in include/asm-parisc/pci.h */
-struct hppa_dma_ops *hppa_dma_ops __read_mostly;
+struct dma_map_ops *hppa_dma_ops __read_mostly;
 EXPORT_SYMBOL(hppa_dma_ops);
 
 static struct device root = {

commit b0acbb9d36e66fc773d4b1375cfaede1356de422
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Thu Dec 5 19:59:38 2013 +0800

    parisc/PCI: Use dev_is_pci() to identify PCI devices
    
    Use dev_is_pci() instead of equivalent local function.
    
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 14285caec71a..dba508fe1683 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -282,18 +282,6 @@ find_pa_parent_type(const struct parisc_device *padev, int type)
 	return NULL;
 }
 
-#ifdef CONFIG_PCI
-static inline int is_pci_dev(struct device *dev)
-{
-	return dev->bus == &pci_bus_type;
-}
-#else
-static inline int is_pci_dev(struct device *dev)
-{
-	return 0;
-}
-#endif
-
 /*
  * get_node_path fills in @path with the firmware path to the device.
  * Note that if @node is a parisc device, we don't fill in the 'mod' field.
@@ -306,7 +294,7 @@ static void get_node_path(struct device *dev, struct hardware_path *path)
 	int i = 5;
 	memset(&path->bc, -1, 6);
 
-	if (is_pci_dev(dev)) {
+	if (dev_is_pci(dev)) {
 		unsigned int devfn = to_pci_dev(dev)->devfn;
 		path->mod = PCI_FUNC(devfn);
 		path->bc[i--] = PCI_SLOT(devfn);
@@ -314,7 +302,7 @@ static void get_node_path(struct device *dev, struct hardware_path *path)
 	}
 
 	while (dev != &root) {
-		if (is_pci_dev(dev)) {
+		if (dev_is_pci(dev)) {
 			unsigned int devfn = to_pci_dev(dev)->devfn;
 			path->bc[i--] = PCI_SLOT(devfn) | (PCI_FUNC(devfn)<< 5);
 		} else if (dev->bus == &parisc_bus_type) {
@@ -695,7 +683,7 @@ static int check_parent(struct device * dev, void * data)
 		if (dev->bus == &parisc_bus_type) {
 			if (match_parisc_device(dev, d->index, d->modpath))
 				d->dev = dev;
-		} else if (is_pci_dev(dev)) {
+		} else if (dev_is_pci(dev)) {
 			if (match_pci_device(dev, d->index, d->modpath))
 				d->dev = dev;
 		} else if (dev->bus == NULL) {
@@ -753,7 +741,7 @@ struct device *hwpath_to_device(struct hardware_path *modpath)
 		if (!parent)
 			return NULL;
 	}
-	if (is_pci_dev(parent)) /* pci devices already parse MOD */
+	if (dev_is_pci(parent)) /* pci devices already parse MOD */
 		return parent;
 	else
 		return parse_tree_node(parent, 6, modpath);
@@ -772,7 +760,7 @@ void device_to_hwpath(struct device *dev, struct hardware_path *path)
 		padev = to_parisc_device(dev);
 		get_node_path(dev->parent, path);
 		path->mod = padev->hw_path;
-	} else if (is_pci_dev(dev)) {
+	} else if (dev_is_pci(dev)) {
 		get_node_path(dev, path);
 	}
 }

commit 3f108de96ba449a8df3d7e3c053bf890fee2cb95
Author: Chen Gang <gang.chen@asianux.com>
Date:   Mon May 27 04:57:09 2013 +0000

    parisc: memory overflow, 'name' length is too short for using
    
    'path.bc[i]' can be asigned by PCI_SLOT() which can '> 10', so sizeof(6
    * "%u:" + "%u" + '\0') may be 21.
    
    Since 'name' length is 20, it may be memory overflow.
    
    And 'path.bc[i]' is 'unsigned char' for printing, we can be sure the
    max length of 'name' must be less than 28.
    
    So simplify thinking, we can use 28 instead of 20 directly, and do not
    think of whether 'patchc.bc[i]' can '> 100'.
    
    Signed-off-by: Chen Gang <gang.chen@asianux.com>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 5709c5e59be8..14285caec71a 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -394,7 +394,7 @@ EXPORT_SYMBOL(print_pci_hwpath);
 static void setup_bus_id(struct parisc_device *padev)
 {
 	struct hardware_path path;
-	char name[20];
+	char name[28];
 	char *output = name;
 	int i;
 

commit a87df54ea3c82369b4b1cb94886449a6bc2e16a2
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Aug 1 13:12:26 2011 -0400

    parisc: Add export.h to files needing EXPORT_SYMBOL/THIS_MODULE
    
    These guys were getting it implicitly via module.h before,
    when module.h was everywhere.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 994bcd980909..5709c5e59be8 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -33,6 +33,7 @@
 #include <linux/pci.h>
 #include <linux/spinlock.h>
 #include <linux/string.h>
+#include <linux/export.h>
 #include <asm/hardware.h>
 #include <asm/io.h>
 #include <asm/pdc.h>

commit 7246c31e45021bc68688c4a8fd2bbb70b485d1ef
Author: Helge Deller <deller@gmx.de>
Date:   Thu Dec 25 20:04:00 2008 +0000

    parisc: add uevent helper for parisc bus
    
    parisc: add uevent helper for parisc bus
    
    udev device-driver auto detection was failing to work on the GSC bus, since
    udev didn't knew wich driver to load due to a missing MODALIAS environment
    variable from kernel.
    
    This patch fixes this by adding the MODALIAS environment variable to the
    uevent kernel notifications.
    Since modalias_show() generated the modalias string already, I splitted this
    out and created a new static function make_modalias() which is now used by
    modalias_show() and the new parisc_uevent() function.
    
    Tested on 715/64 and c3000.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 884b7ce16a3b..994bcd980909 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -549,6 +549,38 @@ static int parisc_generic_match(struct device *dev, struct device_driver *drv)
 	return match_device(to_parisc_driver(drv), to_parisc_device(dev));
 }
 
+static ssize_t make_modalias(struct device *dev, char *buf)
+{
+	const struct parisc_device *padev = to_parisc_device(dev);
+	const struct parisc_device_id *id = &padev->id;
+
+	return sprintf(buf, "parisc:t%02Xhv%04Xrev%02Xsv%08X\n",
+		(u8)id->hw_type, (u16)id->hversion, (u8)id->hversion_rev,
+		(u32)id->sversion);
+}
+
+static int parisc_uevent(struct device *dev, struct kobj_uevent_env *env)
+{
+	const struct parisc_device *padev;
+	char modalias[40];
+
+	if (!dev)
+		return -ENODEV;
+
+	padev = to_parisc_device(dev);
+	if (!padev)
+		return -ENODEV;
+
+	if (add_uevent_var(env, "PARISC_NAME=%s", padev->name))
+		return -ENOMEM;
+
+	make_modalias(dev, modalias);
+	if (add_uevent_var(env, "MODALIAS=%s", modalias))
+		return -ENOMEM;
+
+	return 0;
+}
+
 #define pa_dev_attr(name, field, format_string)				\
 static ssize_t name##_show(struct device *dev, struct device_attribute *attr, char *buf)		\
 {									\
@@ -566,12 +598,7 @@ pa_dev_attr_id(sversion, "0x%05x\n");
 
 static ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)
 {
-	struct parisc_device *padev = to_parisc_device(dev);
-	struct parisc_device_id *id = &padev->id;
-
-	return sprintf(buf, "parisc:t%02Xhv%04Xrev%02Xsv%08X\n",
-		(u8)id->hw_type, (u16)id->hversion, (u8)id->hversion_rev,
-		(u32)id->sversion);
+	return make_modalias(dev, buf);
 }
 
 static struct device_attribute parisc_device_attrs[] = {
@@ -587,6 +614,7 @@ static struct device_attribute parisc_device_attrs[] = {
 struct bus_type parisc_bus_type = {
 	.name = "parisc",
 	.match = parisc_generic_match,
+	.uevent = parisc_uevent,
 	.dev_attrs = parisc_device_attrs,
 	.probe = parisc_driver_probe,
 	.remove = parisc_driver_remove,

commit 90f671301a5e2678cdc99f611cd842161c3bb87f
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Nov 7 01:42:46 2008 +0100

    parisc: struct device - replace bus_id with dev_name(), dev_set_name()
    
    (I did not compile or test it, please let me know, or help fixing
     it, if something is wrong with the conversion)
    
    This patch is part of a larger patch series which will remove
    the "char bus_id[20]" name string from struct device. The device
    name is managed in the kobject anyway, and without any size
    limitation, and just needlessly copied into "struct device".
    
    To set and read the device name dev_name(dev) and dev_set_name(dev)
    must be used. If your code uses static kobjects, which it shouldn't
    do, "const char *init_name" can be used to statically provide the
    name the registered device should have. At registration time, the
    init_name field is cleared, to enforce the use of dev_name(dev) to
    access the device name at a later time.
    
    We need to get rid of all occurrences of bus_id in the entire tree
    to be able to enable the new interface. Please apply this patch,
    and possibly convert any remaining remaining occurrences of bus_id.
    
    We want to submit a patch to -next, which will remove bus_id from
    "struct device", to find the remaining pieces to convert, and finally
    switch over to the new api, which will remove the 20 bytes array
    and does no longer have a size limitation.
    
    Thanks,
    Kay
    
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: linux-parisc@vger.kernel.org
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 2ca654bd6322..884b7ce16a3b 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -43,7 +43,7 @@ struct hppa_dma_ops *hppa_dma_ops __read_mostly;
 EXPORT_SYMBOL(hppa_dma_ops);
 
 static struct device root = {
-	.bus_id = "parisc",
+	.init_name = "parisc",
 };
 
 static inline int check_dev(struct device *dev)
@@ -393,7 +393,8 @@ EXPORT_SYMBOL(print_pci_hwpath);
 static void setup_bus_id(struct parisc_device *padev)
 {
 	struct hardware_path path;
-	char *output = padev->dev.bus_id;
+	char name[20];
+	char *output = name;
 	int i;
 
 	get_node_path(padev->dev.parent, &path);
@@ -404,6 +405,7 @@ static void setup_bus_id(struct parisc_device *padev)
 		output += sprintf(output, "%u:", (unsigned char) path.bc[i]);
 	}
 	sprintf(output, "%u", (unsigned char) padev->hw_path);
+	dev_set_name(&padev->dev, name);
 }
 
 struct parisc_device * create_tree_node(char id, struct device *parent)

commit a04b0605384e019c6fd77cfd4e4ffce8eb50785f
Author: Kyle McMartin <kyle@mako.i.cabal.ca>
Date:   Sat Jan 13 14:56:50 2007 -0500

    [PARISC] display parisc device modalias in sysfs
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 6274cd268e6a..2ca654bd6322 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -562,12 +562,23 @@ pa_dev_attr(rev, id.hversion_rev, "0x%x\n");
 pa_dev_attr_id(hversion, "0x%03x\n");
 pa_dev_attr_id(sversion, "0x%05x\n");
 
+static ssize_t modalias_show(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	struct parisc_device *padev = to_parisc_device(dev);
+	struct parisc_device_id *id = &padev->id;
+
+	return sprintf(buf, "parisc:t%02Xhv%04Xrev%02Xsv%08X\n",
+		(u8)id->hw_type, (u16)id->hversion, (u8)id->hversion_rev,
+		(u32)id->sversion);
+}
+
 static struct device_attribute parisc_device_attrs[] = {
 	__ATTR_RO(irq),
 	__ATTR_RO(hw_type),
 	__ATTR_RO(rev),
 	__ATTR_RO(hversion),
 	__ATTR_RO(sversion),
+	__ATTR_RO(modalias),
 	__ATTR_NULL,
 };
 

commit 3ee8f5e2cdd83b869f1b55e08eb26a87889b62f9
Author: Helge Deller <deller@gmx.de>
Date:   Sat Oct 14 20:02:15 2006 +0200

    [PARISC] avoid compiler warnings when compiling 64bit
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index d6c486e9501c..6274cd268e6a 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -689,7 +689,9 @@ parse_tree_node(struct device *parent, int index, struct hardware_path *modpath)
 		.fn	= check_parent,
 	};
 
-	device_for_each_child(parent, &recurse_data, descend_children);
+	if (device_for_each_child(parent, &recurse_data, descend_children))
+		/* nothing */;
+
 	return d.dev;
 }
 
@@ -835,8 +837,8 @@ static void print_parisc_device(struct parisc_device *dev)
 	static int count;
 
 	print_pa_hwpath(dev, hw_path);
-	printk(KERN_INFO "%d. %s at 0x%lx [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }",
-		++count, dev->name, dev->hpa.start, hw_path, dev->id.hw_type,
+	printk(KERN_INFO "%d. %s at 0x%p [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }",
+		++count, dev->name, (void*) dev->hpa.start, hw_path, dev->id.hw_type,
 		dev->id.hversion_rev, dev->id.hversion, dev->id.sversion);
 
 	if (dev->num_addrs) {

commit ba0e427f215b1c58881a737f46d30ae03b83178c
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Wed Oct 4 22:57:28 2006 -0600

    [PA-RISC] Fix boot breakage
    
    Conditionals were the wrong way around.  Turns out I was booting the
    wrong kernel when testing the original fix.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 2b257e4f17df..d6c486e9501c 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -424,7 +424,7 @@ struct parisc_device * create_tree_node(char id, struct device *parent)
 	/* make the generic dma mask a pointer to the parisc one */
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.coherent_dma_mask = dev->dma_mask;
-	if (!device_register(&dev->dev)) {
+	if (device_register(&dev->dev)) {
 		kfree(dev);
 		return NULL;
 	}
@@ -853,9 +853,9 @@ static void print_parisc_device(struct parisc_device *dev)
  */
 void init_parisc_bus(void)
 {
-	if (!bus_register(&parisc_bus_type))
+	if (bus_register(&parisc_bus_type))
 		panic("Could not register PA-RISC bus type\n");
-	if (!device_register(&root))
+	if (device_register(&root))
 		panic("Could not register PA-RISC root device\n");
 	get_device(&root);
 }

commit 1070c9655b90016ec4c9b59c402292e57ee15885
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Wed Oct 4 13:37:41 2006 -0600

    [PA-RISC] Fix must_check warnings in drivers.c
    
    Panic if we can't register the parisc bus or the root parisc device.
    There's no way we can boot without them, so let the user know ASAP.
    
    If we can't register a parisc device, handle the failure gracefully.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 3d569a485a1a..2b257e4f17df 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -424,7 +424,10 @@ struct parisc_device * create_tree_node(char id, struct device *parent)
 	/* make the generic dma mask a pointer to the parisc one */
 	dev->dev.dma_mask = &dev->dma_mask;
 	dev->dev.coherent_dma_mask = dev->dma_mask;
-	device_register(&dev->dev);
+	if (!device_register(&dev->dev)) {
+		kfree(dev);
+		return NULL;
+	}
 
 	return dev;
 }
@@ -850,8 +853,10 @@ static void print_parisc_device(struct parisc_device *dev)
  */
 void init_parisc_bus(void)
 {
-	bus_register(&parisc_bus_type);
-	device_register(&root);
+	if (!bus_register(&parisc_bus_type))
+		panic("Could not register PA-RISC bus type\n");
+	if (!device_register(&root))
+		panic("Could not register PA-RISC root device\n");
 	get_device(&root);
 }
 

commit cb6fc18e9ca615f03d18e60c49855b434ca2e51e
Author: Helge Deller <deller@parisc-linux.org>
Date:   Tue Jan 17 12:40:40 2006 -0700

    [PARISC] Use kzalloc and other janitor-style cleanups
    
    Helge,
      o Convert a bunch of kmalloc/memset uses to kzalloc.
      o pci.c: Add some __read_mostly annotations.
      o pci.c: Move constant pci_post_reset_delay to asm/pci.h
      o grfioctl.h: Add A4450A to comment of CRT_ID_VISUALIZE_EG.
      o Add some consts to perf.c/perf_images.h
    
    Matthew,
      o sticore.c: Add some consts to suppress compile warnings.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 2d804e2d16d1..3d569a485a1a 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -408,11 +408,10 @@ static void setup_bus_id(struct parisc_device *padev)
 
 struct parisc_device * create_tree_node(char id, struct device *parent)
 {
-	struct parisc_device *dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	struct parisc_device *dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 	if (!dev)
 		return NULL;
 
-	memset(dev, 0, sizeof(*dev));
 	dev->hw_path = id;
 	dev->id.hw_type = HPHW_FAULTY;
 

commit ad3ed31c682d956d2187e562635c55c8c74c1021
Author: Russell King <rmk@arm.linux.org.uk>
Date:   Thu Jan 5 14:34:38 2006 +0000

    [PATCH] Add parisc_bus_type probe and remove methods
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 1eaa0d37f677..2d804e2d16d1 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -173,8 +173,6 @@ int register_parisc_driver(struct parisc_driver *driver)
 	WARN_ON(driver->drv.probe != NULL);
 	WARN_ON(driver->drv.remove != NULL);
 
-	driver->drv.probe = parisc_driver_probe;
-	driver->drv.remove = parisc_driver_remove;
 	driver->drv.name = driver->name;
 
 	return driver_register(&driver->drv);
@@ -575,6 +573,8 @@ struct bus_type parisc_bus_type = {
 	.name = "parisc",
 	.match = parisc_generic_match,
 	.dev_attrs = parisc_device_attrs,
+	.probe = parisc_driver_probe,
+	.remove = parisc_driver_remove,
 };
 
 /**

commit a01c8cb126cb5f5a592f01b08ff8859508c75ba1
Author: Matthew Wilcox <willy@parisc-linux.org>
Date:   Tue Jan 10 20:47:53 2006 -0500

    [PARISC] Fix GSC graphics cards with 64MB regions
    
    Make knapps work with its 64MB gfx card.  I probably just broke another
    machine in the process, but assuming 64MB when 64MB aligned is probably
    safer than assuming 32MB all the time.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 041524d24ef1..1eaa0d37f677 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -515,8 +515,13 @@ alloc_pa_dev(unsigned long hpa, struct hardware_path *mod_path)
 			(iodc_data[5] << 8) | iodc_data[6];
 	dev->hpa.name = parisc_pathname(dev);
 	dev->hpa.start = hpa;
-	if (hpa == 0xf4000000 || hpa == 0xf6000000 ||
-	    hpa == 0xf8000000 || hpa == 0xfa000000) {
+	/* This is awkward.  The STI spec says that gfx devices may occupy
+	 * 32MB or 64MB.  Unfortunately, we don't know how to tell whether
+	 * it's the former or the latter.  Assumptions either way can hurt us.
+	 */
+	if (hpa == 0xf4000000 || hpa == 0xf8000000) {
+		dev->hpa.end = hpa + 0x03ffffff;
+	} else if (hpa == 0xf6000000 || hpa == 0xfa000000) {
 		dev->hpa.end = hpa + 0x01ffffff;
 	} else {
 		dev->hpa.end = hpa + 0xfff;
@@ -834,7 +839,7 @@ static void print_parisc_device(struct parisc_device *dev)
 
 	if (dev->num_addrs) {
 		int k;
-		printk(",  additional addresses: ");
+		printk(", additional addresses: ");
 		for (k = 0; k < dev->num_addrs; k++)
 			printk("0x%lx ", dev->addr[k]);
 	}

commit 8039de10aae3cd4cf0ef0ccebd58aff0e8810df2
Author: Helge Deller <deller@parisc-linux.org>
Date:   Tue Jan 10 20:35:03 2006 -0500

    [PARISC] Add __read_mostly section for parisc
    
    Flag a whole bunch of things as __read_mostly on parisc. Also flag a few
    branches as unlikely() and cleanup a bit of code.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index d016d672ec2b..041524d24ef1 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -39,7 +39,7 @@
 #include <asm/parisc-device.h>
 
 /* See comments in include/asm-parisc/pci.h */
-struct hppa_dma_ops *hppa_dma_ops;
+struct hppa_dma_ops *hppa_dma_ops __read_mostly;
 EXPORT_SYMBOL(hppa_dma_ops);
 
 static struct device root = {

commit 4269b0d371c43bc8f3c9e183847a08258587cf06
Author: Matthew Wilcox <willy@parisc-linux.org>
Date:   Thu Nov 17 16:33:56 2005 -0500

    [PARISC] Improve the error message when we get a clashing mod path
    
    Improve the error message when we get a clashing mod path, and
    actually display the IODC data and path for the conflicting device.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index 988844a169e6..d016d672ec2b 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -499,8 +499,12 @@ alloc_pa_dev(unsigned long hpa, struct hardware_path *mod_path)
 
 	dev = create_parisc_device(mod_path);
 	if (dev->id.hw_type != HPHW_FAULTY) {
-		printk("Two devices have hardware path %s.  Please file a bug with HP.\n"
-			"In the meantime, you could try rearranging your cards.\n", parisc_pathname(dev));
+		printk(KERN_ERR "Two devices have hardware path [%s].  "
+				"IODC data for second device: "
+				"%02x%02x%02x%02x%02x%02x\n"
+				"Rearranging GSC cards sometimes helps\n",
+			parisc_pathname(dev), iodc_data[0], iodc_data[1],
+			iodc_data[3], iodc_data[4], iodc_data[5], iodc_data[6]);
 		return NULL;
 	}
 

commit 5658374766d9e0249bd04e9d62bdb8456b916b64
Author: Matthew Wilcox <willy@parisc-linux.org>
Date:   Fri Oct 21 22:33:38 2005 -0400

    [PARISC] Convert parisc_device tree to use struct device klists
    
    Fix parse_tree_node.  much more needs to be done to fix this file.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Make drivers.c compile based on a patch from Pat Mochel.
    
    From: Patrick Mochel <mochel@digitalimplant.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>
    
    Fix drivers.c to create new device tree nodes when no match is found.
    
    Signed-off-by: Richard Hirst <rhirst@parisc-linux.org>
    
    Do a proper depth-first search returning parents before children, using the
    new klist infrastructure.
    
    Signed-off-by: Richard Hirst <rhirst@parisc-linux.org>
    
    Fixed parisc_device traversal so that pdc_stable works again
    Fixed check_dev so it doesn't dereference a parisc_device until it
    has verified the bus type
    
    Signed-off-by: Randolph Chung <tausq@parisc-linux.org>
    
    Convert pa_dev->hpa from an unsigned long to a struct resource.
    Use insert_resource() instead of request_mem_region().
    Request resources at bus walk time instead of driver probe time.
    Don't release the resources as we don't have any hotplug parisc_device
    support yet.
    Add parisc_pathname() to conveniently get the textual representation
    of the hwpath used in sysfs.
    Inline the remnants of claim_device() into its caller.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    I noticed that some of the STI regions weren't showing up in iomem.
    Reading the STI spec indicated that all STI devices occupy at least 32MB.
    So check for STI HPAs and give them 32MB instead of 4kB.
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index d34bbe7ae0e3..988844a169e6 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -46,36 +46,51 @@ static struct device root = {
 	.bus_id = "parisc",
 };
 
-#define for_each_padev(padev) \
-	for (padev = next_dev(&root); padev != NULL; \
-			padev = next_dev(&padev->dev))
+static inline int check_dev(struct device *dev)
+{
+	if (dev->bus == &parisc_bus_type) {
+		struct parisc_device *pdev;
+		pdev = to_parisc_device(dev);
+		return pdev->id.hw_type != HPHW_FAULTY;
+	}
+	return 1;
+}
+
+static struct device *
+parse_tree_node(struct device *parent, int index, struct hardware_path *modpath);
 
-#define check_dev(padev) \
-	(padev->id.hw_type != HPHW_FAULTY) ? padev : next_dev(&padev->dev)
+struct recurse_struct {
+	void * obj;
+	int (*fn)(struct device *, void *);
+};
+
+static int descend_children(struct device * dev, void * data)
+{
+	struct recurse_struct * recurse_data = (struct recurse_struct *)data;
+
+	if (recurse_data->fn(dev, recurse_data->obj))
+		return 1;
+	else
+		return device_for_each_child(dev, recurse_data, descend_children);
+}
 
 /**
- * next_dev - enumerates registered devices
- * @dev: the previous device returned from next_dev
+ *	for_each_padev - Iterate over all devices in the tree
+ *	@fn:	Function to call for each device.
+ *	@data:	Data to pass to the called function.
  *
- * next_dev does a depth-first search of the tree, returning parents
- * before children.  Returns NULL when there are no more devices.
+ *	This performs a depth-first traversal of the tree, calling the
+ *	function passed for each node.  It calls the function for parents
+ *	before children.
  */
-static struct parisc_device *next_dev(struct device *dev)
-{
-	if (!list_empty(&dev->children)) {
-		dev = list_to_dev(dev->children.next);
-		return check_dev(to_parisc_device(dev));
-	}
 
-	while (dev != &root) {
-		if (dev->node.next != &dev->parent->children) {
-			dev = list_to_dev(dev->node.next);
-			return to_parisc_device(dev);
-		}
-		dev = dev->parent;
-	}
-
-	return NULL;
+static int for_each_padev(int (*fn)(struct device *, void *), void * data)
+{
+	struct recurse_struct recurse_data = {
+		.obj	= data,
+		.fn	= fn,
+	};
+	return device_for_each_child(&root, &recurse_data, descend_children);
 }
 
 /**
@@ -105,12 +120,6 @@ static int match_device(struct parisc_driver *driver, struct parisc_device *dev)
 	return 0;
 }
 
-static void claim_device(struct parisc_driver *driver, struct parisc_device *dev)
-{
-	dev->driver = driver;
-	request_mem_region(dev->hpa, 0x1000, driver->name);
-}
-
 static int parisc_driver_probe(struct device *dev)
 {
 	int rc;
@@ -119,8 +128,8 @@ static int parisc_driver_probe(struct device *dev)
 
 	rc = pa_drv->probe(pa_dev);
 
-	if(!rc)
-		claim_device(pa_drv, pa_dev);
+	if (!rc)
+		pa_dev->driver = pa_drv;
 
 	return rc;
 }
@@ -131,7 +140,6 @@ static int parisc_driver_remove(struct device *dev)
 	struct parisc_driver *pa_drv = to_parisc_driver(dev->driver);
 	if (pa_drv->remove)
 		pa_drv->remove(pa_dev);
-	release_mem_region(pa_dev->hpa, 0x1000);
 
 	return 0;
 }
@@ -173,6 +181,24 @@ int register_parisc_driver(struct parisc_driver *driver)
 }
 EXPORT_SYMBOL(register_parisc_driver);
 
+
+struct match_count {
+	struct parisc_driver * driver;
+	int count;
+};
+
+static int match_and_count(struct device * dev, void * data)
+{
+	struct match_count * m = data;
+	struct parisc_device * pdev = to_parisc_device(dev);
+
+	if (check_dev(dev)) {
+		if (match_device(m->driver, pdev))
+			m->count++;
+	}
+	return 0;
+}
+
 /**
  * count_parisc_driver - count # of devices this driver would match
  * @driver: the PA-RISC driver to try
@@ -182,15 +208,14 @@ EXPORT_SYMBOL(register_parisc_driver);
  */
 int count_parisc_driver(struct parisc_driver *driver)
 {
-	struct parisc_device *device;
-	int cnt = 0;
+	struct match_count m = {
+		.driver	= driver,
+		.count	= 0,
+	};
 
-	for_each_padev(device) {
-		if (match_device(driver, device))
-			cnt++;
-	}
+	for_each_padev(match_and_count, &m);
 
-	return cnt;
+	return m.count;
 }
 
 
@@ -206,14 +231,34 @@ int unregister_parisc_driver(struct parisc_driver *driver)
 }
 EXPORT_SYMBOL(unregister_parisc_driver);
 
-static struct parisc_device *find_device_by_addr(unsigned long hpa)
+struct find_data {
+	unsigned long hpa;
+	struct parisc_device * dev;
+};
+
+static int find_device(struct device * dev, void * data)
 {
-	struct parisc_device *dev;
-	for_each_padev(dev) {
-		if (dev->hpa == hpa)
-			return dev;
+	struct parisc_device * pdev = to_parisc_device(dev);
+	struct find_data * d = (struct find_data*)data;
+
+	if (check_dev(dev)) {
+		if (pdev->hpa.start == d->hpa) {
+			d->dev = pdev;
+			return 1;
+		}
 	}
-	return NULL;
+	return 0;
+}
+
+static struct parisc_device *find_device_by_addr(unsigned long hpa)
+{
+	struct find_data d = {
+		.hpa	= hpa,
+	};
+	int ret;
+
+	ret = for_each_padev(find_device, &d);
+	return ret ? d.dev : NULL;
 }
 
 /**
@@ -387,6 +432,23 @@ struct parisc_device * create_tree_node(char id, struct device *parent)
 	return dev;
 }
 
+struct match_id_data {
+	char id;
+	struct parisc_device * dev;
+};
+
+static int match_by_id(struct device * dev, void * data)
+{
+	struct parisc_device * pdev = to_parisc_device(dev);
+	struct match_id_data * d = data;
+
+	if (pdev->hw_path == d->id) {
+		d->dev = pdev;
+		return 1;
+	}
+	return 0;
+}
+
 /**
  * alloc_tree_node - returns a device entry in the iotree
  * @parent: the parent node in the tree
@@ -397,15 +459,13 @@ struct parisc_device * create_tree_node(char id, struct device *parent)
  */
 static struct parisc_device * alloc_tree_node(struct device *parent, char id)
 {
-	struct device *dev;
-
-	list_for_each_entry(dev, &parent->children, node) {
-		struct parisc_device *padev = to_parisc_device(dev);
-		if (padev->hw_path == id)
-			return padev;
-	}
-
-	return create_tree_node(id, parent);
+	struct match_id_data d = {
+		.id = id,
+	};
+	if (device_for_each_child(parent, &d, match_by_id))
+		return d.dev;
+	else
+		return create_tree_node(id, parent);
 }
 
 static struct parisc_device *create_parisc_device(struct hardware_path *modpath)
@@ -439,10 +499,8 @@ alloc_pa_dev(unsigned long hpa, struct hardware_path *mod_path)
 
 	dev = create_parisc_device(mod_path);
 	if (dev->id.hw_type != HPHW_FAULTY) {
-		char p[64];
-		print_pa_hwpath(dev, p);
 		printk("Two devices have hardware path %s.  Please file a bug with HP.\n"
-			"In the meantime, you could try rearranging your cards.\n", p);
+			"In the meantime, you could try rearranging your cards.\n", parisc_pathname(dev));
 		return NULL;
 	}
 
@@ -451,12 +509,27 @@ alloc_pa_dev(unsigned long hpa, struct hardware_path *mod_path)
 	dev->id.hversion_rev = iodc_data[1] & 0x0f;
 	dev->id.sversion = ((iodc_data[4] & 0x0f) << 16) |
 			(iodc_data[5] << 8) | iodc_data[6];
-	dev->hpa = hpa;
+	dev->hpa.name = parisc_pathname(dev);
+	dev->hpa.start = hpa;
+	if (hpa == 0xf4000000 || hpa == 0xf6000000 ||
+	    hpa == 0xf8000000 || hpa == 0xfa000000) {
+		dev->hpa.end = hpa + 0x01ffffff;
+	} else {
+		dev->hpa.end = hpa + 0xfff;
+	}
+	dev->hpa.flags = IORESOURCE_MEM;
 	name = parisc_hardware_description(&dev->id);
 	if (name) {
 		strlcpy(dev->name, name, sizeof(dev->name));
 	}
 
+	/* Silently fail things like mouse ports which are subsumed within
+	 * the keyboard controller
+	 */
+	if ((hpa & 0xfff) == 0 && insert_resource(&iomem_resource, &dev->hpa))
+		printk("Unable to claim HPA %lx for device %s\n",
+				hpa, name);
+
 	return dev;
 }
 
@@ -555,6 +628,33 @@ static int match_parisc_device(struct device *dev, int index,
 	return (curr->hw_path == id);
 }
 
+struct parse_tree_data {
+	int index;
+	struct hardware_path * modpath;
+	struct device * dev;
+};
+
+static int check_parent(struct device * dev, void * data)
+{
+	struct parse_tree_data * d = data;
+
+	if (check_dev(dev)) {
+		if (dev->bus == &parisc_bus_type) {
+			if (match_parisc_device(dev, d->index, d->modpath))
+				d->dev = dev;
+		} else if (is_pci_dev(dev)) {
+			if (match_pci_device(dev, d->index, d->modpath))
+				d->dev = dev;
+		} else if (dev->bus == NULL) {
+			/* we are on a bus bridge */
+			struct device *new = parse_tree_node(dev, d->index, d->modpath);
+			if (new)
+				d->dev = new;
+		}
+	}
+	return d->dev != NULL;
+}
+
 /**
  * parse_tree_node - returns a device entry in the iotree
  * @parent: the parent node in the tree
@@ -568,24 +668,18 @@ static int match_parisc_device(struct device *dev, int index,
 static struct device *
 parse_tree_node(struct device *parent, int index, struct hardware_path *modpath)
 {
-	struct device *device;
-	 
-	list_for_each_entry(device, &parent->children, node) {
-		if (device->bus == &parisc_bus_type) {
-			if (match_parisc_device(device, index, modpath))
-				return device;
-		} else if (is_pci_dev(device)) {
-			if (match_pci_device(device, index, modpath))
-				return device;
-		} else if (device->bus == NULL) {
-			/* we are on a bus bridge */
-			struct device *new = parse_tree_node(device, index, modpath);
-			if (new)
-				return new;
-		}
-	}
+	struct parse_tree_data d = {
+		.index          = index,
+		.modpath        = modpath,
+	};
 
-	return NULL;
+	struct recurse_struct recurse_data = {
+		.obj	= &d,
+		.fn	= check_parent,
+	};
+
+	device_for_each_child(parent, &recurse_data, descend_children);
+	return d.dev;
 }
 
 /**
@@ -636,7 +730,7 @@ EXPORT_SYMBOL(device_to_hwpath);
         ((dev->id.hw_type == HPHW_IOA) || (dev->id.hw_type == HPHW_BCPORT))
 
 #define IS_LOWER_PORT(dev) \
-        ((gsc_readl(dev->hpa + offsetof(struct bc_module, io_status)) \
+        ((gsc_readl(dev->hpa.start + offsetof(struct bc_module, io_status)) \
                 & BC_PORT_MASK) == BC_LOWER_PORT)
 
 #define MAX_NATIVE_DEVICES 64
@@ -645,8 +739,8 @@ EXPORT_SYMBOL(device_to_hwpath);
 #define FLEX_MASK 	F_EXTEND(0xfffc0000)
 #define IO_IO_LOW	offsetof(struct bc_module, io_io_low)
 #define IO_IO_HIGH	offsetof(struct bc_module, io_io_high)
-#define READ_IO_IO_LOW(dev)  (unsigned long)(signed int)gsc_readl(dev->hpa + IO_IO_LOW)
-#define READ_IO_IO_HIGH(dev) (unsigned long)(signed int)gsc_readl(dev->hpa + IO_IO_HIGH)
+#define READ_IO_IO_LOW(dev)  (unsigned long)(signed int)gsc_readl(dev->hpa.start + IO_IO_LOW)
+#define READ_IO_IO_HIGH(dev) (unsigned long)(signed int)gsc_readl(dev->hpa.start + IO_IO_HIGH)
 
 static void walk_native_bus(unsigned long io_io_low, unsigned long io_io_high,
                             struct device *parent);
@@ -655,10 +749,10 @@ void walk_lower_bus(struct parisc_device *dev)
 {
 	unsigned long io_io_low, io_io_high;
 
-	if(!BUS_CONVERTER(dev) || IS_LOWER_PORT(dev))
+	if (!BUS_CONVERTER(dev) || IS_LOWER_PORT(dev))
 		return;
 
-	if(dev->id.hw_type == HPHW_IOA) {
+	if (dev->id.hw_type == HPHW_IOA) {
 		io_io_low = (unsigned long)(signed int)(READ_IO_IO_LOW(dev) << 16);
 		io_io_high = io_io_low + MAX_NATIVE_DEVICES * NATIVE_DEVICE_OFFSET;
 	} else {
@@ -731,7 +825,7 @@ static void print_parisc_device(struct parisc_device *dev)
 
 	print_pa_hwpath(dev, hw_path);
 	printk(KERN_INFO "%d. %s at 0x%lx [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }",
-		++count, dev->name, dev->hpa, hw_path, dev->id.hw_type,
+		++count, dev->name, dev->hpa.start, hw_path, dev->id.hw_type,
 		dev->id.hversion_rev, dev->id.hversion, dev->id.sversion);
 
 	if (dev->num_addrs) {
@@ -753,13 +847,20 @@ void init_parisc_bus(void)
 	get_device(&root);
 }
 
+
+static int print_one_device(struct device * dev, void * data)
+{
+	struct parisc_device * pdev = to_parisc_device(dev);
+
+	if (check_dev(dev))
+		print_parisc_device(pdev);
+	return 0;
+}
+
 /**
  * print_parisc_devices - Print out a list of devices found in this system
  */
 void print_parisc_devices(void)
 {
-	struct parisc_device *dev;
-	for_each_padev(dev) {
-		print_parisc_device(dev);
-	}
+	for_each_padev(print_one_device, NULL);
 }

commit ff381d2223a30ee70752791fd9c3588d8f1cab77
Author: Yani Ioannou <yani.ioannou@gmail.com>
Date:   Tue May 17 06:40:51 2005 -0400

    [PATCH] Driver Core: arch: update device attribute callbacks
    
    Signed-off-by: Yani Ioannou <yani.ioannou@gmail.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
index ebf186656afb..d34bbe7ae0e3 100644
--- a/arch/parisc/kernel/drivers.c
+++ b/arch/parisc/kernel/drivers.c
@@ -466,7 +466,7 @@ static int parisc_generic_match(struct device *dev, struct device_driver *drv)
 }
 
 #define pa_dev_attr(name, field, format_string)				\
-static ssize_t name##_show(struct device *dev, char *buf)		\
+static ssize_t name##_show(struct device *dev, struct device_attribute *attr, char *buf)		\
 {									\
 	struct parisc_device *padev = to_parisc_device(dev);		\
 	return sprintf(buf, format_string, padev->field);		\

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/parisc/kernel/drivers.c b/arch/parisc/kernel/drivers.c
new file mode 100644
index 000000000000..ebf186656afb
--- /dev/null
+++ b/arch/parisc/kernel/drivers.c
@@ -0,0 +1,765 @@
+/*
+ * drivers.c
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * Copyright (c) 1999 The Puffin Group
+ * Copyright (c) 2001 Matthew Wilcox for Hewlett Packard
+ * Copyright (c) 2001 Helge Deller <deller@gmx.de>
+ * Copyright (c) 2001,2002 Ryan Bradetich 
+ * Copyright (c) 2004-2005 Thibaut VARENE <varenet@parisc-linux.org>
+ * 
+ * The file handles registering devices and drivers, then matching them.
+ * It's the closest we get to a dating agency.
+ *
+ * If you're thinking about modifying this file, here are some gotchas to
+ * bear in mind:
+ *  - 715/Mirage device paths have a dummy device between Lasi and its children
+ *  - The EISA adapter may show up as a sibling or child of Wax
+ *  - Dino has an optionally functional serial port.  If firmware enables it,
+ *    it shows up as a child of Dino.  If firmware disables it, the buswalk
+ *    finds it and it shows up as a child of Cujo
+ *  - Dino has both parisc and pci devices as children
+ *  - parisc devices are discovered in a random order, including children
+ *    before parents in some cases.
+ */
+
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/spinlock.h>
+#include <linux/string.h>
+#include <asm/hardware.h>
+#include <asm/io.h>
+#include <asm/pdc.h>
+#include <asm/parisc-device.h>
+
+/* See comments in include/asm-parisc/pci.h */
+struct hppa_dma_ops *hppa_dma_ops;
+EXPORT_SYMBOL(hppa_dma_ops);
+
+static struct device root = {
+	.bus_id = "parisc",
+};
+
+#define for_each_padev(padev) \
+	for (padev = next_dev(&root); padev != NULL; \
+			padev = next_dev(&padev->dev))
+
+#define check_dev(padev) \
+	(padev->id.hw_type != HPHW_FAULTY) ? padev : next_dev(&padev->dev)
+
+/**
+ * next_dev - enumerates registered devices
+ * @dev: the previous device returned from next_dev
+ *
+ * next_dev does a depth-first search of the tree, returning parents
+ * before children.  Returns NULL when there are no more devices.
+ */
+static struct parisc_device *next_dev(struct device *dev)
+{
+	if (!list_empty(&dev->children)) {
+		dev = list_to_dev(dev->children.next);
+		return check_dev(to_parisc_device(dev));
+	}
+
+	while (dev != &root) {
+		if (dev->node.next != &dev->parent->children) {
+			dev = list_to_dev(dev->node.next);
+			return to_parisc_device(dev);
+		}
+		dev = dev->parent;
+	}
+
+	return NULL;
+}
+
+/**
+ * match_device - Report whether this driver can handle this device
+ * @driver: the PA-RISC driver to try
+ * @dev: the PA-RISC device to try
+ */
+static int match_device(struct parisc_driver *driver, struct parisc_device *dev)
+{
+	const struct parisc_device_id *ids;
+
+	for (ids = driver->id_table; ids->sversion; ids++) {
+		if ((ids->sversion != SVERSION_ANY_ID) &&
+		    (ids->sversion != dev->id.sversion))
+			continue;
+
+		if ((ids->hw_type != HWTYPE_ANY_ID) &&
+		    (ids->hw_type != dev->id.hw_type))
+			continue;
+
+		if ((ids->hversion != HVERSION_ANY_ID) &&
+		    (ids->hversion != dev->id.hversion))
+			continue;
+
+		return 1;
+	}
+	return 0;
+}
+
+static void claim_device(struct parisc_driver *driver, struct parisc_device *dev)
+{
+	dev->driver = driver;
+	request_mem_region(dev->hpa, 0x1000, driver->name);
+}
+
+static int parisc_driver_probe(struct device *dev)
+{
+	int rc;
+	struct parisc_device *pa_dev = to_parisc_device(dev);
+	struct parisc_driver *pa_drv = to_parisc_driver(dev->driver);
+
+	rc = pa_drv->probe(pa_dev);
+
+	if(!rc)
+		claim_device(pa_drv, pa_dev);
+
+	return rc;
+}
+
+static int parisc_driver_remove(struct device *dev)
+{
+	struct parisc_device *pa_dev = to_parisc_device(dev);
+	struct parisc_driver *pa_drv = to_parisc_driver(dev->driver);
+	if (pa_drv->remove)
+		pa_drv->remove(pa_dev);
+	release_mem_region(pa_dev->hpa, 0x1000);
+
+	return 0;
+}
+	
+
+/**
+ * register_parisc_driver - Register this driver if it can handle a device
+ * @driver: the PA-RISC driver to try
+ */
+int register_parisc_driver(struct parisc_driver *driver)
+{
+	/* FIXME: we need this because apparently the sti
+	 * driver can be registered twice */
+	if(driver->drv.name) {
+		printk(KERN_WARNING 
+		       "BUG: skipping previously registered driver %s\n",
+		       driver->name);
+		return 1;
+	}
+
+	if (!driver->probe) {
+		printk(KERN_WARNING 
+		       "BUG: driver %s has no probe routine\n",
+		       driver->name);
+		return 1;
+	}
+
+	driver->drv.bus = &parisc_bus_type;
+
+	/* We install our own probe and remove routines */
+	WARN_ON(driver->drv.probe != NULL);
+	WARN_ON(driver->drv.remove != NULL);
+
+	driver->drv.probe = parisc_driver_probe;
+	driver->drv.remove = parisc_driver_remove;
+	driver->drv.name = driver->name;
+
+	return driver_register(&driver->drv);
+}
+EXPORT_SYMBOL(register_parisc_driver);
+
+/**
+ * count_parisc_driver - count # of devices this driver would match
+ * @driver: the PA-RISC driver to try
+ *
+ * Use by IOMMU support to "guess" the right size IOPdir.
+ * Formula is something like memsize/(num_iommu * entry_size).
+ */
+int count_parisc_driver(struct parisc_driver *driver)
+{
+	struct parisc_device *device;
+	int cnt = 0;
+
+	for_each_padev(device) {
+		if (match_device(driver, device))
+			cnt++;
+	}
+
+	return cnt;
+}
+
+
+
+/**
+ * unregister_parisc_driver - Unregister this driver from the list of drivers
+ * @driver: the PA-RISC driver to unregister
+ */
+int unregister_parisc_driver(struct parisc_driver *driver)
+{
+	driver_unregister(&driver->drv);
+	return 0;
+}
+EXPORT_SYMBOL(unregister_parisc_driver);
+
+static struct parisc_device *find_device_by_addr(unsigned long hpa)
+{
+	struct parisc_device *dev;
+	for_each_padev(dev) {
+		if (dev->hpa == hpa)
+			return dev;
+	}
+	return NULL;
+}
+
+/**
+ * find_pa_parent_type - Find a parent of a specific type
+ * @dev: The device to start searching from
+ * @type: The device type to search for.
+ *
+ * Walks up the device tree looking for a device of the specified type.
+ * If it finds it, it returns it.  If not, it returns NULL.
+ */
+const struct parisc_device *
+find_pa_parent_type(const struct parisc_device *padev, int type)
+{
+	const struct device *dev = &padev->dev;
+	while (dev != &root) {
+		struct parisc_device *candidate = to_parisc_device(dev);
+		if (candidate->id.hw_type == type)
+			return candidate;
+		dev = dev->parent;
+	}
+
+	return NULL;
+}
+
+#ifdef CONFIG_PCI
+static inline int is_pci_dev(struct device *dev)
+{
+	return dev->bus == &pci_bus_type;
+}
+#else
+static inline int is_pci_dev(struct device *dev)
+{
+	return 0;
+}
+#endif
+
+/*
+ * get_node_path fills in @path with the firmware path to the device.
+ * Note that if @node is a parisc device, we don't fill in the 'mod' field.
+ * This is because both callers pass the parent and fill in the mod
+ * themselves.  If @node is a PCI device, we do fill it in, even though this
+ * is inconsistent.
+ */
+static void get_node_path(struct device *dev, struct hardware_path *path)
+{
+	int i = 5;
+	memset(&path->bc, -1, 6);
+
+	if (is_pci_dev(dev)) {
+		unsigned int devfn = to_pci_dev(dev)->devfn;
+		path->mod = PCI_FUNC(devfn);
+		path->bc[i--] = PCI_SLOT(devfn);
+		dev = dev->parent;
+	}
+
+	while (dev != &root) {
+		if (is_pci_dev(dev)) {
+			unsigned int devfn = to_pci_dev(dev)->devfn;
+			path->bc[i--] = PCI_SLOT(devfn) | (PCI_FUNC(devfn)<< 5);
+		} else if (dev->bus == &parisc_bus_type) {
+			path->bc[i--] = to_parisc_device(dev)->hw_path;
+		}
+		dev = dev->parent;
+	}
+}
+
+static char *print_hwpath(struct hardware_path *path, char *output)
+{
+	int i;
+	for (i = 0; i < 6; i++) {
+		if (path->bc[i] == -1)
+			continue;
+		output += sprintf(output, "%u/", (unsigned char) path->bc[i]);
+	}
+	output += sprintf(output, "%u", (unsigned char) path->mod);
+	return output;
+}
+
+/**
+ * print_pa_hwpath - Returns hardware path for PA devices
+ * dev: The device to return the path for
+ * output: Pointer to a previously-allocated array to place the path in.
+ *
+ * This function fills in the output array with a human-readable path
+ * to a PA device.  This string is compatible with that used by PDC, and
+ * may be printed on the outside of the box.
+ */
+char *print_pa_hwpath(struct parisc_device *dev, char *output)
+{
+	struct hardware_path path;
+
+	get_node_path(dev->dev.parent, &path);
+	path.mod = dev->hw_path;
+	return print_hwpath(&path, output);
+}
+EXPORT_SYMBOL(print_pa_hwpath);
+
+#if defined(CONFIG_PCI) || defined(CONFIG_ISA)
+/**
+ * get_pci_node_path - Determines the hardware path for a PCI device
+ * @pdev: The device to return the path for
+ * @path: Pointer to a previously-allocated array to place the path in.
+ *
+ * This function fills in the hardware_path structure with the route to
+ * the specified PCI device.  This structure is suitable for passing to
+ * PDC calls.
+ */
+void get_pci_node_path(struct pci_dev *pdev, struct hardware_path *path)
+{
+	get_node_path(&pdev->dev, path);
+}
+EXPORT_SYMBOL(get_pci_node_path);
+
+/**
+ * print_pci_hwpath - Returns hardware path for PCI devices
+ * dev: The device to return the path for
+ * output: Pointer to a previously-allocated array to place the path in.
+ *
+ * This function fills in the output array with a human-readable path
+ * to a PCI device.  This string is compatible with that used by PDC, and
+ * may be printed on the outside of the box.
+ */
+char *print_pci_hwpath(struct pci_dev *dev, char *output)
+{
+	struct hardware_path path;
+
+	get_pci_node_path(dev, &path);
+	return print_hwpath(&path, output);
+}
+EXPORT_SYMBOL(print_pci_hwpath);
+
+#endif /* defined(CONFIG_PCI) || defined(CONFIG_ISA) */
+
+static void setup_bus_id(struct parisc_device *padev)
+{
+	struct hardware_path path;
+	char *output = padev->dev.bus_id;
+	int i;
+
+	get_node_path(padev->dev.parent, &path);
+
+	for (i = 0; i < 6; i++) {
+		if (path.bc[i] == -1)
+			continue;
+		output += sprintf(output, "%u:", (unsigned char) path.bc[i]);
+	}
+	sprintf(output, "%u", (unsigned char) padev->hw_path);
+}
+
+struct parisc_device * create_tree_node(char id, struct device *parent)
+{
+	struct parisc_device *dev = kmalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return NULL;
+
+	memset(dev, 0, sizeof(*dev));
+	dev->hw_path = id;
+	dev->id.hw_type = HPHW_FAULTY;
+
+	dev->dev.parent = parent;
+	setup_bus_id(dev);
+
+	dev->dev.bus = &parisc_bus_type;
+	dev->dma_mask = 0xffffffffUL;	/* PARISC devices are 32-bit */
+
+	/* make the generic dma mask a pointer to the parisc one */
+	dev->dev.dma_mask = &dev->dma_mask;
+	dev->dev.coherent_dma_mask = dev->dma_mask;
+	device_register(&dev->dev);
+
+	return dev;
+}
+
+/**
+ * alloc_tree_node - returns a device entry in the iotree
+ * @parent: the parent node in the tree
+ * @id: the element of the module path for this entry
+ *
+ * Checks all the children of @parent for a matching @id.  If none
+ * found, it allocates a new device and returns it.
+ */
+static struct parisc_device * alloc_tree_node(struct device *parent, char id)
+{
+	struct device *dev;
+
+	list_for_each_entry(dev, &parent->children, node) {
+		struct parisc_device *padev = to_parisc_device(dev);
+		if (padev->hw_path == id)
+			return padev;
+	}
+
+	return create_tree_node(id, parent);
+}
+
+static struct parisc_device *create_parisc_device(struct hardware_path *modpath)
+{
+	int i;
+	struct device *parent = &root;
+	for (i = 0; i < 6; i++) {
+		if (modpath->bc[i] == -1)
+			continue;
+		parent = &alloc_tree_node(parent, modpath->bc[i])->dev;
+	}
+	return alloc_tree_node(parent, modpath->mod);
+}
+
+struct parisc_device *
+alloc_pa_dev(unsigned long hpa, struct hardware_path *mod_path)
+{
+	int status;
+	unsigned long bytecnt;
+	u8 iodc_data[32];
+	struct parisc_device *dev;
+	const char *name;
+
+	/* Check to make sure this device has not already been added - Ryan */
+	if (find_device_by_addr(hpa) != NULL)
+		return NULL;
+
+	status = pdc_iodc_read(&bytecnt, hpa, 0, &iodc_data, 32);
+	if (status != PDC_OK)
+		return NULL;
+
+	dev = create_parisc_device(mod_path);
+	if (dev->id.hw_type != HPHW_FAULTY) {
+		char p[64];
+		print_pa_hwpath(dev, p);
+		printk("Two devices have hardware path %s.  Please file a bug with HP.\n"
+			"In the meantime, you could try rearranging your cards.\n", p);
+		return NULL;
+	}
+
+	dev->id.hw_type = iodc_data[3] & 0x1f;
+	dev->id.hversion = (iodc_data[0] << 4) | ((iodc_data[1] & 0xf0) >> 4);
+	dev->id.hversion_rev = iodc_data[1] & 0x0f;
+	dev->id.sversion = ((iodc_data[4] & 0x0f) << 16) |
+			(iodc_data[5] << 8) | iodc_data[6];
+	dev->hpa = hpa;
+	name = parisc_hardware_description(&dev->id);
+	if (name) {
+		strlcpy(dev->name, name, sizeof(dev->name));
+	}
+
+	return dev;
+}
+
+static int parisc_generic_match(struct device *dev, struct device_driver *drv)
+{
+	return match_device(to_parisc_driver(drv), to_parisc_device(dev));
+}
+
+#define pa_dev_attr(name, field, format_string)				\
+static ssize_t name##_show(struct device *dev, char *buf)		\
+{									\
+	struct parisc_device *padev = to_parisc_device(dev);		\
+	return sprintf(buf, format_string, padev->field);		\
+}
+
+#define pa_dev_attr_id(field, format) pa_dev_attr(field, id.field, format)
+
+pa_dev_attr(irq, irq, "%u\n");
+pa_dev_attr_id(hw_type, "0x%02x\n");
+pa_dev_attr(rev, id.hversion_rev, "0x%x\n");
+pa_dev_attr_id(hversion, "0x%03x\n");
+pa_dev_attr_id(sversion, "0x%05x\n");
+
+static struct device_attribute parisc_device_attrs[] = {
+	__ATTR_RO(irq),
+	__ATTR_RO(hw_type),
+	__ATTR_RO(rev),
+	__ATTR_RO(hversion),
+	__ATTR_RO(sversion),
+	__ATTR_NULL,
+};
+
+struct bus_type parisc_bus_type = {
+	.name = "parisc",
+	.match = parisc_generic_match,
+	.dev_attrs = parisc_device_attrs,
+};
+
+/**
+ * register_parisc_device - Locate a driver to manage this device.
+ * @dev: The parisc device.
+ *
+ * Search the driver list for a driver that is willing to manage
+ * this device.
+ */
+int register_parisc_device(struct parisc_device *dev)
+{
+	if (!dev)
+		return 0;
+
+	if (dev->driver)
+		return 1;
+
+	return 0;
+}
+
+/**
+ * match_pci_device - Matches a pci device against a given hardware path
+ * entry.
+ * @dev: the generic device (known to be contained by a pci_dev).
+ * @index: the current BC index
+ * @modpath: the hardware path.
+ * @return: true if the device matches the hardware path.
+ */
+static int match_pci_device(struct device *dev, int index,
+		struct hardware_path *modpath)
+{
+	struct pci_dev *pdev = to_pci_dev(dev);
+	int id;
+
+	if (index == 5) {
+		/* we are at the end of the path, and on the actual device */
+		unsigned int devfn = pdev->devfn;
+		return ((modpath->bc[5] == PCI_SLOT(devfn)) &&
+					(modpath->mod == PCI_FUNC(devfn)));
+	}
+
+	id = PCI_SLOT(pdev->devfn) | (PCI_FUNC(pdev->devfn) << 5);
+	return (modpath->bc[index] == id);
+}
+
+/**
+ * match_parisc_device - Matches a parisc device against a given hardware
+ * path entry.
+ * @dev: the generic device (known to be contained by a parisc_device).
+ * @index: the current BC index
+ * @modpath: the hardware path.
+ * @return: true if the device matches the hardware path.
+ */
+static int match_parisc_device(struct device *dev, int index,
+		struct hardware_path *modpath)
+{
+	struct parisc_device *curr = to_parisc_device(dev);
+	char id = (index == 6) ? modpath->mod : modpath->bc[index];
+
+	return (curr->hw_path == id);
+}
+
+/**
+ * parse_tree_node - returns a device entry in the iotree
+ * @parent: the parent node in the tree
+ * @index: the current BC index
+ * @modpath: the hardware_path struct to match a device against
+ * @return: The corresponding device if found, NULL otherwise.
+ *
+ * Checks all the children of @parent for a matching @id.  If none
+ * found, it returns NULL.
+ */
+static struct device *
+parse_tree_node(struct device *parent, int index, struct hardware_path *modpath)
+{
+	struct device *device;
+	 
+	list_for_each_entry(device, &parent->children, node) {
+		if (device->bus == &parisc_bus_type) {
+			if (match_parisc_device(device, index, modpath))
+				return device;
+		} else if (is_pci_dev(device)) {
+			if (match_pci_device(device, index, modpath))
+				return device;
+		} else if (device->bus == NULL) {
+			/* we are on a bus bridge */
+			struct device *new = parse_tree_node(device, index, modpath);
+			if (new)
+				return new;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * hwpath_to_device - Finds the generic device corresponding to a given hardware path.
+ * @modpath: the hardware path.
+ * @return: The target device, NULL if not found.
+ */
+struct device *hwpath_to_device(struct hardware_path *modpath)
+{
+	int i;
+	struct device *parent = &root;
+	for (i = 0; i < 6; i++) {
+		if (modpath->bc[i] == -1)
+			continue;
+		parent = parse_tree_node(parent, i, modpath);
+		if (!parent)
+			return NULL;
+	}
+	if (is_pci_dev(parent)) /* pci devices already parse MOD */
+		return parent;
+	else
+		return parse_tree_node(parent, 6, modpath);
+}
+EXPORT_SYMBOL(hwpath_to_device);
+
+/**
+ * device_to_hwpath - Populates the hwpath corresponding to the given device.
+ * @param dev the target device
+ * @param path pointer to a previously allocated hwpath struct to be filled in
+ */
+void device_to_hwpath(struct device *dev, struct hardware_path *path)
+{
+	struct parisc_device *padev;
+	if (dev->bus == &parisc_bus_type) {
+		padev = to_parisc_device(dev);
+		get_node_path(dev->parent, path);
+		path->mod = padev->hw_path;
+	} else if (is_pci_dev(dev)) {
+		get_node_path(dev, path);
+	}
+}
+EXPORT_SYMBOL(device_to_hwpath);
+
+#define BC_PORT_MASK 0x8
+#define BC_LOWER_PORT 0x8
+
+#define BUS_CONVERTER(dev) \
+        ((dev->id.hw_type == HPHW_IOA) || (dev->id.hw_type == HPHW_BCPORT))
+
+#define IS_LOWER_PORT(dev) \
+        ((gsc_readl(dev->hpa + offsetof(struct bc_module, io_status)) \
+                & BC_PORT_MASK) == BC_LOWER_PORT)
+
+#define MAX_NATIVE_DEVICES 64
+#define NATIVE_DEVICE_OFFSET 0x1000
+
+#define FLEX_MASK 	F_EXTEND(0xfffc0000)
+#define IO_IO_LOW	offsetof(struct bc_module, io_io_low)
+#define IO_IO_HIGH	offsetof(struct bc_module, io_io_high)
+#define READ_IO_IO_LOW(dev)  (unsigned long)(signed int)gsc_readl(dev->hpa + IO_IO_LOW)
+#define READ_IO_IO_HIGH(dev) (unsigned long)(signed int)gsc_readl(dev->hpa + IO_IO_HIGH)
+
+static void walk_native_bus(unsigned long io_io_low, unsigned long io_io_high,
+                            struct device *parent);
+
+void walk_lower_bus(struct parisc_device *dev)
+{
+	unsigned long io_io_low, io_io_high;
+
+	if(!BUS_CONVERTER(dev) || IS_LOWER_PORT(dev))
+		return;
+
+	if(dev->id.hw_type == HPHW_IOA) {
+		io_io_low = (unsigned long)(signed int)(READ_IO_IO_LOW(dev) << 16);
+		io_io_high = io_io_low + MAX_NATIVE_DEVICES * NATIVE_DEVICE_OFFSET;
+	} else {
+		io_io_low = (READ_IO_IO_LOW(dev) + ~FLEX_MASK) & FLEX_MASK;
+		io_io_high = (READ_IO_IO_HIGH(dev)+ ~FLEX_MASK) & FLEX_MASK;
+	}
+
+	walk_native_bus(io_io_low, io_io_high, &dev->dev);
+}
+
+/**
+ * walk_native_bus -- Probe a bus for devices
+ * @io_io_low: Base address of this bus.
+ * @io_io_high: Last address of this bus.
+ * @parent: The parent bus device.
+ * 
+ * A native bus (eg Runway or GSC) may have up to 64 devices on it,
+ * spaced at intervals of 0x1000 bytes.  PDC may not inform us of these
+ * devices, so we have to probe for them.  Unfortunately, we may find
+ * devices which are not physically connected (such as extra serial &
+ * keyboard ports).  This problem is not yet solved.
+ */
+static void walk_native_bus(unsigned long io_io_low, unsigned long io_io_high,
+                            struct device *parent)
+{
+	int i, devices_found = 0;
+	unsigned long hpa = io_io_low;
+	struct hardware_path path;
+
+	get_node_path(parent, &path);
+	do {
+		for(i = 0; i < MAX_NATIVE_DEVICES; i++, hpa += NATIVE_DEVICE_OFFSET) {
+			struct parisc_device *dev;
+
+			/* Was the device already added by Firmware? */
+			dev = find_device_by_addr(hpa);
+			if (!dev) {
+				path.mod = i;
+				dev = alloc_pa_dev(hpa, &path);
+				if (!dev)
+					continue;
+
+				register_parisc_device(dev);
+				devices_found++;
+			}
+			walk_lower_bus(dev);
+		}
+	} while(!devices_found && hpa < io_io_high);
+}
+
+#define CENTRAL_BUS_ADDR F_EXTEND(0xfff80000)
+
+/**
+ * walk_central_bus - Find devices attached to the central bus
+ *
+ * PDC doesn't tell us about all devices in the system.  This routine
+ * finds devices connected to the central bus.
+ */
+void walk_central_bus(void)
+{
+	walk_native_bus(CENTRAL_BUS_ADDR,
+			CENTRAL_BUS_ADDR + (MAX_NATIVE_DEVICES * NATIVE_DEVICE_OFFSET),
+			&root);
+}
+
+static void print_parisc_device(struct parisc_device *dev)
+{
+	char hw_path[64];
+	static int count;
+
+	print_pa_hwpath(dev, hw_path);
+	printk(KERN_INFO "%d. %s at 0x%lx [%s] { %d, 0x%x, 0x%.3x, 0x%.5x }",
+		++count, dev->name, dev->hpa, hw_path, dev->id.hw_type,
+		dev->id.hversion_rev, dev->id.hversion, dev->id.sversion);
+
+	if (dev->num_addrs) {
+		int k;
+		printk(",  additional addresses: ");
+		for (k = 0; k < dev->num_addrs; k++)
+			printk("0x%lx ", dev->addr[k]);
+	}
+	printk("\n");
+}
+
+/**
+ * init_parisc_bus - Some preparation to be done before inventory
+ */
+void init_parisc_bus(void)
+{
+	bus_register(&parisc_bus_type);
+	device_register(&root);
+	get_device(&root);
+}
+
+/**
+ * print_parisc_devices - Print out a list of devices found in this system
+ */
+void print_parisc_devices(void)
+{
+	struct parisc_device *dev;
+	for_each_padev(dev) {
+		print_parisc_device(dev);
+	}
+}
