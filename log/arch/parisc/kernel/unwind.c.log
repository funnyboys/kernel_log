commit 47293774c49c174c9863a60a757b825299ddf649
Author: Helge Deller <deller@gmx.de>
Date:   Fri May 10 20:55:51 2019 +0200

    parisc: Use __ro_after_init in unwind.c
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 2d14f17838d2..87ae476d1c4f 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -40,7 +40,7 @@ static DEFINE_SPINLOCK(unwind_lock);
  * we can call unwind_init as early in the bootup process as 
  * possible (before the slab allocator is initialized)
  */
-static struct unwind_table kernel_unwind_table __read_mostly;
+static struct unwind_table kernel_unwind_table __ro_after_init;
 static LIST_HEAD(unwind_tables);
 
 static inline const struct unwind_table_entry *

commit cf8afe5c53621eda385be961bc72329a2adcd767
Author: Helge Deller <deller@gmx.de>
Date:   Tue Oct 16 08:21:48 2018 +0200

    parisc: Fix uninitialized variable usage in unwind.c
    
    As noticed by Dave Anglin, the last commit introduced a small bug where
    the potentially uninitialized r struct is used instead of the regs
    pointer as input for unwind_frame_init(). Fix it.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Reported-by: John David Anglin <dave.anglin@bell.net>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index f329b466e68f..2d14f17838d2 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -426,7 +426,7 @@ void unwind_frame_init_task(struct unwind_frame_info *info,
 			r.gr[30] = get_parisc_stackpointer();
 			regs = &r;
 		}
-		unwind_frame_init(info, task, &r);
+		unwind_frame_init(info, task, regs);
 	} else {
 		unwind_frame_init_from_blocked_task(info, task);
 	}

commit 8801ccb9fa524c195322c26b6d44e99827772bde
Author: Helge Deller <deller@gmx.de>
Date:   Tue Aug 21 14:31:32 2018 +0200

    parisc: Fix boot failure of 64-bit kernel
    
    Commit c8921d72e390 ("parisc: Fix and improve kernel stack unwinding")
    broke booting of 64-bit kernels. On 64-bit kernels function pointers are
    actually function descriptors which require dereferencing. In this patch
    we instead declare functions in assembly code which are referenced from
    C-code as external data pointers with the ENTRY() macro and thus can use
    a simple external reference to the functions.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Fixes: c8921d72e390 ("parisc: Fix and improve kernel stack unwinding")

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 5578a325a730..f329b466e68f 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -209,6 +209,8 @@ static int unwind_special(struct unwind_frame_info *info, unsigned long pc, int
 	 * We have to use void * instead of a function pointer, because
 	 * function pointers aren't a pointer to the function on 64-bit.
 	 * Make them const so the compiler knows they live in .text
+	 * Note: We could use dereference_kernel_function_descriptor()
+	 * instead but we want to keep it simple here.
 	 */
 	extern void * const handle_interruption;
 	extern void * const ret_from_kernel_thread;
@@ -216,7 +218,7 @@ static int unwind_special(struct unwind_frame_info *info, unsigned long pc, int
 	extern void * const intr_return;
 	extern void * const _switch_to_ret;
 #ifdef CONFIG_IRQSTACKS
-	extern void * const call_on_stack;
+	extern void * const _call_on_stack;
 #endif /* CONFIG_IRQSTACKS */
 
 	if (pc == (unsigned long) &handle_interruption) {
@@ -251,7 +253,7 @@ static int unwind_special(struct unwind_frame_info *info, unsigned long pc, int
 	}
 
 #ifdef CONFIG_IRQSTACKS
-	if (pc == (unsigned long) &call_on_stack) {
+	if (pc == (unsigned long) &_call_on_stack) {
 		info->prev_sp = *(unsigned long *)(info->sp - FRAME_SIZE - REG_SZ);
 		info->prev_ip = *(unsigned long *)(info->sp - FRAME_SIZE - RP_OFFSET);
 		return 1;

commit 9e0d5c451f9e559dd06af3fff49a0d2068c634c4
Author: Helge Deller <deller@gmx.de>
Date:   Fri Aug 17 17:00:08 2018 +0200

    parisc: Consolidate unwind initialization calls
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 5cdf13069dd9..5578a325a730 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -403,9 +403,31 @@ void unwind_frame_init_from_blocked_task(struct unwind_frame_info *info, struct
 	kfree(r2);
 }
 
-void unwind_frame_init_running(struct unwind_frame_info *info, struct pt_regs *regs)
+#define get_parisc_stackpointer() ({ \
+	unsigned long sp; \
+	__asm__("copy %%r30, %0" : "=r"(sp)); \
+	(sp); \
+})
+
+void unwind_frame_init_task(struct unwind_frame_info *info,
+	struct task_struct *task, struct pt_regs *regs)
 {
-	unwind_frame_init(info, current, regs);
+	task = task ? task : current;
+
+	if (task == current) {
+		struct pt_regs r;
+
+		if (!regs) {
+			memset(&r, 0, sizeof(r));
+			r.iaoq[0] =  _THIS_IP_;
+			r.gr[2] = _RET_IP_;
+			r.gr[30] = get_parisc_stackpointer();
+			regs = &r;
+		}
+		unwind_frame_init(info, task, &r);
+	} else {
+		unwind_frame_init_from_blocked_task(info, task);
+	}
 }
 
 int unwind_once(struct unwind_frame_info *next_frame)
@@ -442,19 +464,12 @@ int unwind_to_user(struct unwind_frame_info *info)
 unsigned long return_address(unsigned int level)
 {
 	struct unwind_frame_info info;
-	struct pt_regs r;
-	unsigned long sp;
 
 	/* initialize unwind info */
-	asm volatile ("copy %%r30, %0" : "=r"(sp));
-	memset(&r, 0, sizeof(struct pt_regs));
-	r.iaoq[0] = _THIS_IP_;
-	r.gr[2] = _RET_IP_;
-	r.gr[30] = sp;
-	unwind_frame_init(&info, current, &r);
+	unwind_frame_init_task(&info, current, NULL);
 
 	/* unwind stack */
-	++level;
+	level += 2;
 	do {
 		if (unwind_once(&info) < 0 || info.ip == 0)
 			return 0;

commit c8921d72e390cb6fca3fb2b0c2badfda851647eb
Author: Helge Deller <deller@gmx.de>
Date:   Sun Aug 5 00:03:29 2018 +0200

    parisc: Fix and improve kernel stack unwinding
    
    This patchset fixes and improves stack unwinding a lot:
    1. Show backward stack traces with up to 30 callsites
    2. Add callinfo to ENTRY_CFI() such that every assembler function will get an
       entry in the unwind table
    3. Use constants instead of numbers in call_on_stack()
    4. Do not depend on CONFIG_KALLSYMS to generate backtraces.
    5. Speed up backtrace generation
    
    Make sure you have this patch to GNU as installed:
    https://sourceware.org/ml/binutils/2018-07/msg00474.html
    Without this patch, unwind info in the kernel is often wrong for various
    functions.
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index a4b430f440a9..5cdf13069dd9 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -13,7 +13,6 @@
 #include <linux/init.h>
 #include <linux/sched.h>
 #include <linux/slab.h>
-#include <linux/kallsyms.h>
 #include <linux/sort.h>
 
 #include <linux/uaccess.h>
@@ -117,7 +116,8 @@ unwind_table_init(struct unwind_table *table, const char *name,
 	for (; start <= end; start++) {
 		if (start < end && 
 		    start->region_end > (start+1)->region_start) {
-			printk("WARNING: Out of order unwind entry! %p and %p\n", start, start+1);
+			pr_warn("Out of order unwind entry! %px and %px\n",
+				start, start+1);
 		}
 
 		start->region_start += base_addr;
@@ -203,25 +203,60 @@ int __init unwind_init(void)
 	return 0;
 }
 
-#ifdef CONFIG_64BIT
-#define get_func_addr(fptr) fptr[2]
-#else
-#define get_func_addr(fptr) fptr[0]
-#endif
-
 static int unwind_special(struct unwind_frame_info *info, unsigned long pc, int frame_size)
 {
-	extern void handle_interruption(int, struct pt_regs *);
-	static unsigned long *hi = (unsigned long *)&handle_interruption;
-
-	if (pc == get_func_addr(hi)) {
+	/*
+	 * We have to use void * instead of a function pointer, because
+	 * function pointers aren't a pointer to the function on 64-bit.
+	 * Make them const so the compiler knows they live in .text
+	 */
+	extern void * const handle_interruption;
+	extern void * const ret_from_kernel_thread;
+	extern void * const syscall_exit;
+	extern void * const intr_return;
+	extern void * const _switch_to_ret;
+#ifdef CONFIG_IRQSTACKS
+	extern void * const call_on_stack;
+#endif /* CONFIG_IRQSTACKS */
+
+	if (pc == (unsigned long) &handle_interruption) {
 		struct pt_regs *regs = (struct pt_regs *)(info->sp - frame_size - PT_SZ_ALGN);
 		dbg("Unwinding through handle_interruption()\n");
 		info->prev_sp = regs->gr[30];
 		info->prev_ip = regs->iaoq[0];
+		return 1;
+	}
+
+	if (pc == (unsigned long) &ret_from_kernel_thread ||
+	    pc == (unsigned long) &syscall_exit) {
+		info->prev_sp = info->prev_ip = 0;
+		return 1;
+	}
+
+	if (pc == (unsigned long) &intr_return) {
+		struct pt_regs *regs;
+
+		dbg("Found intr_return()\n");
+		regs = (struct pt_regs *)(info->sp - PT_SZ_ALGN);
+		info->prev_sp = regs->gr[30];
+		info->prev_ip = regs->iaoq[0];
+		info->rp = regs->gr[2];
+		return 1;
+	}
+
+	if (pc == (unsigned long) &_switch_to_ret) {
+		info->prev_sp = info->sp - CALLEE_SAVE_FRAME_SIZE;
+		info->prev_ip = *(unsigned long *)(info->prev_sp - RP_OFFSET);
+		return 1;
+	}
 
+#ifdef CONFIG_IRQSTACKS
+	if (pc == (unsigned long) &call_on_stack) {
+		info->prev_sp = *(unsigned long *)(info->sp - FRAME_SIZE - REG_SZ);
+		info->prev_ip = *(unsigned long *)(info->sp - FRAME_SIZE - RP_OFFSET);
 		return 1;
 	}
+#endif
 
 	return 0;
 }
@@ -238,34 +273,8 @@ static void unwind_frame_regs(struct unwind_frame_info *info)
 	if (e == NULL) {
 		unsigned long sp;
 
-		dbg("Cannot find unwind entry for 0x%lx; forced unwinding\n", info->ip);
-
-#ifdef CONFIG_KALLSYMS
-		/* Handle some frequent special cases.... */
-		{
-			char symname[KSYM_NAME_LEN];
-			char *modname;
-
-			kallsyms_lookup(info->ip, NULL, NULL, &modname,
-				symname);
-
-			dbg("info->ip = 0x%lx, name = %s\n", info->ip, symname);
-
-			if (strcmp(symname, "_switch_to_ret") == 0) {
-				info->prev_sp = info->sp - CALLEE_SAVE_FRAME_SIZE;
-				info->prev_ip = *(unsigned long *)(info->prev_sp - RP_OFFSET);
-				dbg("_switch_to_ret @ %lx - setting "
-				    "prev_sp=%lx prev_ip=%lx\n", 
-				    info->ip, info->prev_sp, 
-				    info->prev_ip);
-				return;
-			} else if (strcmp(symname, "ret_from_kernel_thread") == 0 ||
-				   strcmp(symname, "syscall_exit") == 0) {
-				info->prev_ip = info->prev_sp = 0;
-				return;
-			}
-		}
-#endif
+		dbg("Cannot find unwind entry for %pS; forced unwinding\n",
+			(void *) info->ip);
 
 		/* Since we are doing the unwinding blind, we don't know if
 		   we are adjusting the stack correctly or extracting the rp

commit 4a53ec1ccf932f86845c96a5092ba4507621c84d
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Wed Aug 1 11:22:56 2018 -0700

    parisc: prefer _THIS_IP_ and _RET_IP_ statement expressions
    
    As part of the effort to reduce the code duplication between _THIS_IP_
    and current_text_addr(), let's consolidate callers of
    current_text_addr() to use _THIS_IP_.
    
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 2ef83d78eec4..a4b430f440a9 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -439,8 +439,8 @@ unsigned long return_address(unsigned int level)
 	/* initialize unwind info */
 	asm volatile ("copy %%r30, %0" : "=r"(sp));
 	memset(&r, 0, sizeof(struct pt_regs));
-	r.iaoq[0] = (unsigned long) current_text_addr();
-	r.gr[2] = (unsigned long) __builtin_return_address(0);
+	r.iaoq[0] = _THIS_IP_;
+	r.gr[2] = _RET_IP_;
 	r.gr[30] = sp;
 	unwind_frame_init(&info, current, &r);
 

commit 63ba82c0e63f1dd400d84e12f2142c2cb691aec1
Author: Helge Deller <deller@gmx.de>
Date:   Thu Jun 28 22:21:24 2018 +0200

    parisc: Reduce debug output in unwind code
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 143f90e2f9f3..2ef83d78eec4 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -25,7 +25,7 @@
 
 /* #define DEBUG 1 */
 #ifdef DEBUG
-#define dbg(x...) printk(x)
+#define dbg(x...) pr_debug(x)
 #else
 #define dbg(x...)
 #endif
@@ -182,7 +182,7 @@ int __init unwind_init(void)
 	start = (long)&__start___unwind[0];
 	stop = (long)&__stop___unwind[0];
 
-	printk("unwind_init: start = 0x%lx, end = 0x%lx, entries = %lu\n", 
+	dbg("unwind_init: start = 0x%lx, end = 0x%lx, entries = %lu\n",
 	    start, stop,
 	    (stop - start) / sizeof(struct unwind_table_entry));
 

commit 6a16fc322085bb3163d7d6e44856adfda06a8001
Author: Pravin Shedge <pravin.shedge4linux@gmail.com>
Date:   Sun Dec 10 23:54:33 2017 +0530

    parisc: remove duplicate includes
    
    These duplicate includes have been found with scripts/checkincludes.pl
    but they have been removed manually to avoid removing false positives.
    
    Signed-off-by: Pravin Shedge <pravin.shedge4linux@gmail.com>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 5a657986ebbf..143f90e2f9f3 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -15,7 +15,6 @@
 #include <linux/slab.h>
 #include <linux/kallsyms.h>
 #include <linux/sort.h>
-#include <linux/sched.h>
 
 #include <linux/uaccess.h>
 #include <asm/assembly.h>

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index caab39dfa95d..5a657986ebbf 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * Kernel unwinding support
  *

commit e77900abfd8be4e207412d8b7752dbb9838e2571
Author: Helge Deller <deller@gmx.de>
Date:   Sun Sep 17 21:05:02 2017 +0200

    parisc: Stop unwinding at start of stack
    
    Check stack pointer if we are reaching the stack end and stop unwinding
    if we do. This fixes early backtraces and avoids showing unrealistic
    call stacks.
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 48dc7d4d20bb..caab39dfa95d 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -14,6 +14,7 @@
 #include <linux/slab.h>
 #include <linux/kallsyms.h>
 #include <linux/sort.h>
+#include <linux/sched.h>
 
 #include <linux/uaccess.h>
 #include <asm/assembly.h>
@@ -279,6 +280,17 @@ static void unwind_frame_regs(struct unwind_frame_info *info)
 
 			info->prev_sp = sp - 64;
 			info->prev_ip = 0;
+
+			/* The stack is at the end inside the thread_union
+			 * struct. If we reach data, we have reached the
+			 * beginning of the stack and should stop unwinding. */
+			if (info->prev_sp >= (unsigned long) task_thread_info(info->t) &&
+			    info->prev_sp < ((unsigned long) task_thread_info(info->t)
+						+ THREAD_SZ_ALGN)) {
+				info->prev_sp = 0;
+				break;
+			}
+
 			if (get_user(tmp, (unsigned long *)(info->prev_sp - RP_OFFSET))) 
 				break;
 			info->prev_ip = tmp;

commit 76cffeb6ccace1ae487e58d8d72b4519861a9d9e
Author: Helge Deller <deller@gmx.de>
Date:   Fri Aug 4 23:54:19 2017 +0200

    parisc: Static initialization of spinlocks in perf and unwind code
    
    While testing UBSAN I saw this BUG:
     BUG: spinlock bad magic on CPU#0, swapper/0
    in unwind code. Let's avoid that by static initialization.
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 1b73690477c5..48dc7d4d20bb 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -34,7 +34,7 @@
 extern struct unwind_table_entry __start___unwind[];
 extern struct unwind_table_entry __stop___unwind[];
 
-static spinlock_t unwind_lock;
+static DEFINE_SPINLOCK(unwind_lock);
 /*
  * the kernel unwind block is not dynamically allocated so that
  * we can call unwind_init as early in the bootup process as 
@@ -181,8 +181,6 @@ int __init unwind_init(void)
 	start = (long)&__start___unwind[0];
 	stop = (long)&__stop___unwind[0];
 
-	spin_lock_init(&unwind_lock);
-
 	printk("unwind_init: start = 0x%lx, end = 0x%lx, entries = %lu\n", 
 	    start, stop,
 	    (stop - start) / sizeof(struct unwind_table_entry));

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index e278a87f43cc..1b73690477c5 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -15,7 +15,7 @@
 #include <linux/kallsyms.h>
 #include <linux/sort.h>
 
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/assembly.h>
 #include <asm/asm-offsets.h>
 #include <asm/ptrace.h>

commit be24a89700eef61bedaba40f3b05ef07f5806e38
Author: Mikulas Patocka <mpatocka@redhat.com>
Date:   Wed Jun 29 00:48:19 2011 +0200

    parisc: Fix backtrace on PA-RISC
    
    This patch fixes backtrace on PA-RISC
    
    There were several problems:
    
    1) The code that decodes instructions handles instructions that subtract
    from the stack pointer incorrectly. If the instruction subtracts the
    number X from the stack pointer the code increases the frame size by
    (0x100000000-X).  This results in invalid accesses to memory and
    recursive page faults.
    
    2) Because gcc reorders blocks, handling instructions that subtract from
    the frame pointer is incorrect. For example, this function
            int f(int a)
            {
                    if (__builtin_expect(a, 1))
                            return a;
                    g();
                    return a;
            }
    is compiled in such a way, that the code that decreases the stack
    pointer for the first "return a" is placed before the code for "g" call.
    If we recognize this decrement, we mistakenly believe that the frame
    size for the "g" call is zero.
    
    To fix problems 1) and 2), the patch doesn't recognize instructions that
    decrease the stack pointer at all. To further safeguard the unwind code
    against nonsense values, we don't allow frame size larger than
    Total_frame_size.
    
    3) The backtrace is not locked. If stack dump races with module unload,
    invalid table can be accessed.
    
    This patch adds a spinlock when processing module tables.
    
    Note, that for correct backtrace, you need recent binutils.
    Binutils 2.18 from Debian 5 produce garbage unwind tables.
    Binutils 2.21 work better (it sometimes forgets function frames, but at
    least it doesn't generate garbage).
    
    Signed-off-by: Mikulas Patocka <mpatocka@redhat.com>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index ddd988b267a9..e278a87f43cc 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -75,7 +75,10 @@ find_unwind_entry(unsigned long addr)
 	if (addr >= kernel_unwind_table.start && 
 	    addr <= kernel_unwind_table.end)
 		e = find_unwind_entry_in_table(&kernel_unwind_table, addr);
-	else 
+	else {
+		unsigned long flags;
+
+		spin_lock_irqsave(&unwind_lock, flags);
 		list_for_each_entry(table, &unwind_tables, list) {
 			if (addr >= table->start && 
 			    addr <= table->end)
@@ -86,6 +89,8 @@ find_unwind_entry(unsigned long addr)
 				break;
 			}
 		}
+		spin_unlock_irqrestore(&unwind_lock, flags);
+	}
 
 	return e;
 }
@@ -303,18 +308,16 @@ static void unwind_frame_regs(struct unwind_frame_info *info)
 
 			insn = *(unsigned int *)npc;
 
-			if ((insn & 0xffffc000) == 0x37de0000 ||
-			    (insn & 0xffe00000) == 0x6fc00000) {
+			if ((insn & 0xffffc001) == 0x37de0000 ||
+			    (insn & 0xffe00001) == 0x6fc00000) {
 				/* ldo X(sp), sp, or stwm X,D(sp) */
-				frame_size += (insn & 0x1 ? -1 << 13 : 0) | 
-					((insn & 0x3fff) >> 1);
+				frame_size += (insn & 0x3fff) >> 1;
 				dbg("analyzing func @ %lx, insn=%08x @ "
 				    "%lx, frame_size = %ld\n", info->ip,
 				    insn, npc, frame_size);
-			} else if ((insn & 0xffe00008) == 0x73c00008) {
+			} else if ((insn & 0xffe00009) == 0x73c00008) {
 				/* std,ma X,D(sp) */
-				frame_size += (insn & 0x1 ? -1 << 13 : 0) | 
-					(((insn >> 4) & 0x3ff) << 3);
+				frame_size += ((insn >> 4) & 0x3ff) << 3;
 				dbg("analyzing func @ %lx, insn=%08x @ "
 				    "%lx, frame_size = %ld\n", info->ip,
 				    insn, npc, frame_size);
@@ -333,6 +336,9 @@ static void unwind_frame_regs(struct unwind_frame_info *info)
 			}
 		}
 
+		if (frame_size > e->Total_frame_size << 3)
+			frame_size = e->Total_frame_size << 3;
+
 		if (!unwind_special(info, e->region_start, frame_size)) {
 			info->prev_sp = info->sp - frame_size;
 			if (e->Millicode)

commit c790b41bac83512dc67da89b582daa6f4e1fab07
Author: Helge Deller <deller@gmx.de>
Date:   Sat Nov 30 21:23:20 2013 +0100

    parisc: use kernel_text_address() in unwind functions
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 76ed62ed785b..ddd988b267a9 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -168,7 +168,7 @@ void unwind_table_remove(struct unwind_table *table)
 }
 
 /* Called from setup_arch to import the kernel unwind info */
-int unwind_init(void)
+int __init unwind_init(void)
 {
 	long start, stop;
 	register unsigned long gp __asm__ ("r27");
@@ -233,7 +233,6 @@ static void unwind_frame_regs(struct unwind_frame_info *info)
 	e = find_unwind_entry(info->ip);
 	if (e == NULL) {
 		unsigned long sp;
-		extern char _stext[], _etext[];
 
 		dbg("Cannot find unwind entry for 0x%lx; forced unwinding\n", info->ip);
 
@@ -281,8 +280,7 @@ static void unwind_frame_regs(struct unwind_frame_info *info)
 				break;
 			info->prev_ip = tmp;
 			sp = info->prev_sp;
-		} while (info->prev_ip < (unsigned long)_stext ||
-			 info->prev_ip > (unsigned long)_etext);
+		} while (!kernel_text_address(info->prev_ip));
 
 		info->rp = 0;
 
@@ -435,9 +433,8 @@ unsigned long return_address(unsigned int level)
 	do {
 		if (unwind_once(&info) < 0 || info.ip == 0)
 			return 0;
-		if (!__kernel_text_address(info.ip)) {
+		if (!kernel_text_address(info.ip))
 			return 0;
-		}
 	} while (info.ip && level--);
 
 	return info.ip;

commit b1b1d4a6f244eb9513f006a188f7ed30d5014de5
Author: Phil Carmody <ext-phil.2.carmody@nokia.com>
Date:   Fri Sep 10 13:47:59 2010 +0300

    parisc: unwind - optimise linked-list searches for modules
    
    Having many dozens of modules, the searches down the linked
    list of sections would dominate the lookup time, dwarfing
    any savings from the binary search within the section.
    
    A simple move-to-front optimisation exploits the commonality
    of the code paths taken, and in simple real-world tests
    on other architectures reduced the number of steps in the
    search to barely more than 1.
    
    Signed-off-by: Phil Carmody <ext-phil.2.carmody@nokia.com>
    Signed-off-by: Kyle McMartin <kyle@redhat.com>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index d58eac1a8288..76ed62ed785b 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -80,8 +80,11 @@ find_unwind_entry(unsigned long addr)
 			if (addr >= table->start && 
 			    addr <= table->end)
 				e = find_unwind_entry_in_table(table, addr);
-			if (e)
+			if (e) {
+				/* Move-to-front to exploit common traces */
+				list_move(&table->list, &unwind_tables);
 				break;
+			}
 		}
 
 	return e;

commit 8f78df872d463ac43315916663b3e688ebb2422f
Author: Helge Deller <deller@gmx.de>
Date:   Fri Nov 6 23:07:42 2009 +0000

    parisc: use sort() instead of home-made implementation (v2)
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Randolph Chung <tausq@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index f03f6fb0ec83..d58eac1a8288 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -13,6 +13,7 @@
 #include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/kallsyms.h>
+#include <linux/sort.h>
 
 #include <asm/uaccess.h>
 #include <asm/assembly.h>
@@ -115,24 +116,18 @@ unwind_table_init(struct unwind_table *table, const char *name,
 	}
 }
 
+static int cmp_unwind_table_entry(const void *a, const void *b)
+{
+	return ((const struct unwind_table_entry *)a)->region_start
+	     - ((const struct unwind_table_entry *)b)->region_start;
+}
+
 static void
 unwind_table_sort(struct unwind_table_entry *start,
 		  struct unwind_table_entry *finish)
 {
-	struct unwind_table_entry el, *p, *q;
-
-	for (p = start + 1; p < finish; ++p) {
-		if (p[0].region_start < p[-1].region_start) {
-			el = *p;
-			q = p;
-			do {
-				q[0] = q[-1];
-				--q;
-			} while (q > start && 
-				 el.region_start < q[-1].region_start);
-			*q = el;
-		}
-	}
+	sort(start, finish - start, sizeof(struct unwind_table_entry),
+	     cmp_unwind_table_entry, NULL);
 }
 
 struct unwind_table *

commit 11e178091f6a9c5ca479f8a276b9dd0dfacf8fc4
Author: Helge Deller <deller@gmx.de>
Date:   Sun Oct 25 21:48:36 2009 +0000

    parisc: add CALLER_ADDR{0-6} macros
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index a36799e85693..f03f6fb0ec83 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -417,3 +417,30 @@ int unwind_to_user(struct unwind_frame_info *info)
 
 	return ret;
 }
+
+unsigned long return_address(unsigned int level)
+{
+	struct unwind_frame_info info;
+	struct pt_regs r;
+	unsigned long sp;
+
+	/* initialize unwind info */
+	asm volatile ("copy %%r30, %0" : "=r"(sp));
+	memset(&r, 0, sizeof(struct pt_regs));
+	r.iaoq[0] = (unsigned long) current_text_addr();
+	r.gr[2] = (unsigned long) __builtin_return_address(0);
+	r.gr[30] = sp;
+	unwind_frame_init(&info, current, &r);
+
+	/* unwind stack */
+	++level;
+	do {
+		if (unwind_once(&info) < 0 || info.ip == 0)
+			return 0;
+		if (!__kernel_text_address(info.ip)) {
+			return 0;
+		}
+	} while (info.ip && level--);
+
+	return info.ip;
+}

commit 33a932d14323b957a4e17a6c8428d3f048a30822
Author: Helge Deller <deller@gmx.de>
Date:   Sat Nov 28 20:33:11 2009 +0000

    parisc: fix unwind with recent gcc versions
    
    kernel unwinding is broken with gcc >= 4.x.  Part of the problem is that
    binutils seems very sensitive to where the unwind information is stored.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 69dad5a850a8..a36799e85693 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -28,7 +28,7 @@
 #define dbg(x...)
 #endif
 
-#define KERNEL_START (KERNEL_BINARY_TEXT_START - 0x1000)
+#define KERNEL_START (KERNEL_BINARY_TEXT_START)
 
 extern struct unwind_table_entry __start___unwind[];
 extern struct unwind_table_entry __stop___unwind[];

commit e0e7ed4811ce32d48ca8ee9fd136357d093243a9
Author: Helge Deller <deller@gmx.de>
Date:   Wed Dec 17 23:57:34 2008 +0100

    parisc: fix GFP_KERNEL use while atomic in unwinder
    
    Since unwind_frame_init_from_blocked_task() may be called from
    interrupt/in_atomic context, it needs to kmalloc() memory with
    GFP_ATOMIC instead of GFP_KERNEL.
    
    This fixes this warning (ShowTasks called from sysrq handler):
    
    BUG: sleeping function called from invalid context at mm/slab.c:3044
    in_atomic(): 1, irqs_disabled(): 1, pid: 2119, name: miniruby
    Backtrace:
     [<10132e78>] __might_sleep+0x4c/0x118
     [<1018f644>] kmem_cache_alloc+0x2c/0xb4
     [<1011bae0>] unwind_frame_init_from_blocked_task+0x30/0xa0
     [<1010fd3c>] parisc_show_stack+0x3c/0xac
     [<10132c7c>] show_state_filter+0x80/0xd8
     [<102f4074>] __handle_sysrq+0xd0/0x1b0
     [<102f9558>] receive_chars+0x22c/0x318
     [<102f9940>] serial8250_handle_port+0x40/0x88
     [<102f9a8c>] serial8250_interrupt+0x104/0x10c
     [<10161920>] handle_IRQ_event+0x44/0x94
     [<10161acc>] __do_IRQ+0x15c/0x1dc
     [<102c442c>] superio_interrupt+0x74/0xa8
     [<10161920>] handle_IRQ_event+0x44/0x94
     [<10161acc>] __do_IRQ+0x15c/0x1dc
     [<10110fb4>] do_cpu_irq_mask+0x90/0xbc
     [<10114068>] intr_return+0x0/0x4
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 6773c582e457..69dad5a850a8 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -372,7 +372,7 @@ void unwind_frame_init_from_blocked_task(struct unwind_frame_info *info, struct
 	struct pt_regs *r = &t->thread.regs;
 	struct pt_regs *r2;
 
-	r2 = kmalloc(sizeof(struct pt_regs), GFP_KERNEL);
+	r2 = kmalloc(sizeof(struct pt_regs), GFP_ATOMIC);
 	if (!r2)
 		return;
 	*r2 = *r;

commit f0514ae323f19ba1ad4bea4174ea274c812f7eee
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Thu Sep 11 10:17:23 2008 -0400

    parisc: initialize unwinder much earlier
    
    The unwinder was being initialized way too late to be any use
    debugging early boot crashes. Instead of relying on module_init
    initcalls to initialize it, let's do it explicitly as early as
    we can.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 701b2d2d8882..6773c582e457 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -170,7 +170,7 @@ void unwind_table_remove(struct unwind_table *table)
 }
 
 /* Called from setup_arch to import the kernel unwind info */
-static int unwind_init(void)
+int unwind_init(void)
 {
 	long start, stop;
 	register unsigned long gp __asm__ ("r27");
@@ -417,5 +417,3 @@ int unwind_to_user(struct unwind_frame_info *info)
 
 	return ret;
 }
-
-module_init(unwind_init);

commit 7819994312fd4c3c04456abb6a64c810ecde3db4
Author: Kyle McMartin <kyle@mcmartin.ca>
Date:   Thu Oct 18 00:03:56 2007 -0700

    [PARISC] Kill incorrect cast warning in unwinder
    
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index cf780cb3b916..701b2d2d8882 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -209,8 +209,8 @@ static int unwind_init(void)
 
 static int unwind_special(struct unwind_frame_info *info, unsigned long pc, int frame_size)
 {
-	void handle_interruption(int, struct pt_regs *);
-	static unsigned long *hi = (unsigned long)&handle_interruption;
+	extern void handle_interruption(int, struct pt_regs *);
+	static unsigned long *hi = (unsigned long *)&handle_interruption;
 
 	if (pc == get_func_addr(hi)) {
 		struct pt_regs *regs = (struct pt_regs *)(info->sp - frame_size - PT_SZ_ALGN);

commit 9281acea6a3687ff0f262e0be31eac34895b95d7
Author: Tejun Heo <htejun@gmail.com>
Date:   Tue Jul 17 04:03:51 2007 -0700

    kallsyms: make KSYM_NAME_LEN include space for trailing '\0'
    
    KSYM_NAME_LEN is peculiar in that it does not include the space for the
    trailing '\0', forcing all users to use KSYM_NAME_LEN + 1 when allocating
    buffer.  This is nonsense and error-prone.  Moreover, when the caller
    forgets that it's very likely to subtly bite back by corrupting the stack
    because the last position of the buffer is always cleared to zero.
    
    This patch increments KSYM_NAME_LEN by one and updates code accordingly.
    
    * off-by-one bug in asm-powerpc/kprobes.h::kprobe_lookup_name() macro
      is fixed.
    
    * Where MODULE_NAME_LEN and KSYM_NAME_LEN were used together,
      MODULE_NAME_LEN was treated as if it didn't include space for the
      trailing '\0'.  Fix it.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Acked-by: Paulo Marques <pmarques@grupopie.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 322167737de7..cf780cb3b916 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -242,7 +242,7 @@ static void unwind_frame_regs(struct unwind_frame_info *info)
 #ifdef CONFIG_KALLSYMS
 		/* Handle some frequent special cases.... */
 		{
-			char symname[KSYM_NAME_LEN+1];
+			char symname[KSYM_NAME_LEN];
 			char *modname;
 
 			kallsyms_lookup(info->ip, NULL, NULL, &modname,

commit 05dc16d6a175139a5872d08db56ee277ec90df5b
Author: Randolph Chung <tausq@debian.org>
Date:   Tue Jun 12 14:27:32 2007 +0800

    [PARISC] unwinder improvements
    
    Add special-case handling for "handle_interruption" so that we can rewind
    past the interruption. This is useful for seeing what caused a BUG() or
    WARN_ON(); otherwise the unwind stops at the interruption.
    
    Signed-off-by: Randolph Chung <tausq@debian.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index cad9d78312e0..322167737de7 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -16,6 +16,8 @@
 
 #include <asm/uaccess.h>
 #include <asm/assembly.h>
+#include <asm/asm-offsets.h>
+#include <asm/ptrace.h>
 
 #include <asm/unwind.h>
 
@@ -199,6 +201,29 @@ static int unwind_init(void)
 	return 0;
 }
 
+#ifdef CONFIG_64BIT
+#define get_func_addr(fptr) fptr[2]
+#else
+#define get_func_addr(fptr) fptr[0]
+#endif
+
+static int unwind_special(struct unwind_frame_info *info, unsigned long pc, int frame_size)
+{
+	void handle_interruption(int, struct pt_regs *);
+	static unsigned long *hi = (unsigned long)&handle_interruption;
+
+	if (pc == get_func_addr(hi)) {
+		struct pt_regs *regs = (struct pt_regs *)(info->sp - frame_size - PT_SZ_ALGN);
+		dbg("Unwinding through handle_interruption()\n");
+		info->prev_sp = regs->gr[30];
+		info->prev_ip = regs->iaoq[0];
+
+		return 1;
+	}
+
+	return 0;
+}
+
 static void unwind_frame_regs(struct unwind_frame_info *info)
 {
 	const struct unwind_table_entry *e;
@@ -312,13 +337,15 @@ static void unwind_frame_regs(struct unwind_frame_info *info)
 			}
 		}
 
-		info->prev_sp = info->sp - frame_size;
-		if (e->Millicode)
-			info->rp = info->r31;
-		else if (rpoffset)
-			info->rp = *(unsigned long *)(info->prev_sp - rpoffset);
-		info->prev_ip = info->rp;
-		info->rp = 0;
+		if (!unwind_special(info, e->region_start, frame_size)) {
+			info->prev_sp = info->sp - frame_size;
+			if (e->Millicode)
+				info->rp = info->r31;
+			else if (rpoffset)
+				info->rp = *(unsigned long *)(info->prev_sp - rpoffset);
+			info->prev_ip = info->rp;
+			info->rp = 0;
+		}
 
 		dbg("analyzing func @ %lx, setting prev_sp=%lx "
 		    "prev_ip=%lx npc=%lx\n", info->ip, info->prev_sp, 

commit e036306aa1832963cd147849b282259a32f5ac08
Author: Randolph Chung <tausq@debian.org>
Date:   Tue Jun 12 14:27:32 2007 +0800

    [PARISC] Fix unwinder on 64-bit kernels
    
    The unwinder was broken by the shift of PAGE_OFFSET in order to increase the
    size of the vmalloc area on 64-bit kernels.
    
    Signed-off-by: Randolph Chung <tausq@debian.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index e70f57e27643..cad9d78312e0 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -26,6 +26,8 @@
 #define dbg(x...)
 #endif
 
+#define KERNEL_START (KERNEL_BINARY_TEXT_START - 0x1000)
+
 extern struct unwind_table_entry __start___unwind[];
 extern struct unwind_table_entry __stop___unwind[];
 

commit cb9577958d85896303561d9cc8544885deb272be
Author: Kyle McMartin <kyle@parisc-linux.org>
Date:   Wed May 30 02:24:28 2007 -0400

    [PARISC] fix null ptr deref in unwind.c
    
    commit ffb45122766db220d0bf3d01848d575fbbcb6430 removed one too many args.
    kallsyms_lookup is not safe to call with a NULL *modname. Paper bag over the
    problem for the time being.
    
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 89c03707eccc..e70f57e27643 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -216,8 +216,10 @@ static void unwind_frame_regs(struct unwind_frame_info *info)
 		/* Handle some frequent special cases.... */
 		{
 			char symname[KSYM_NAME_LEN+1];
+			char *modname;
 
-			kallsyms_lookup(info->ip, NULL, NULL, NULL, symname);
+			kallsyms_lookup(info->ip, NULL, NULL, &modname,
+				symname);
 
 			dbg("info->ip = 0x%lx, name = %s\n", info->ip, symname);
 

commit ffb45122766db220d0bf3d01848d575fbbcb6430
Author: Alexey Dobriyan <adobriyan@sw.ru>
Date:   Tue May 8 00:28:41 2007 -0700

    Simplify kallsyms_lookup()
    
    Several kallsyms_lookup() pass dummy arguments but only need, say, module's
    name.  Make kallsyms_lookup() accept NULLs where possible.
    
    Also, makes picture clearer about what interfaces are needed for all symbol
    resolving business.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@sw.ru>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 5f75b3e65986..89c03707eccc 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -216,11 +216,8 @@ static void unwind_frame_regs(struct unwind_frame_info *info)
 		/* Handle some frequent special cases.... */
 		{
 			char symname[KSYM_NAME_LEN+1];
-			char *modname;
-			unsigned long symsize, offset;
 
-			kallsyms_lookup(info->ip, &symsize, &offset,
-					&modname, symname);
+			kallsyms_lookup(info->ip, NULL, NULL, NULL, symname);
 
 			dbg("info->ip = 0x%lx, name = %s\n", info->ip, symname);
 

commit e6fc0449be45a0e7520da6a17a64520743b9aa20
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Dec 15 09:34:36 2006 -0700

    [PARISC] Remove sched.h from uaccess.h on parisc
    
    Al Viro did this for x86-64 and reduced the number of dependencies on
    sched.h significantly.  We had a couple of files which were relying on
    uaccess.h pulling in sched.h, so they need explicit dependencies added.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index c10ab47d81fa..5f75b3e65986 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -10,6 +10,7 @@
 
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/sched.h>
 #include <linux/slab.h>
 #include <linux/kallsyms.h>
 

commit 5cbded585d129d0226cb48ac4202b253c781be26
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:35:56 2006 -0800

    [PATCH] getting rid of all casts of k[cmz]alloc() calls
    
    Run this:
    
            #!/bin/sh
            for f in $(grep -Erl "\([^\)]*\) *k[cmz]alloc" *) ; do
              echo "De-casting $f..."
              perl -pi -e "s/ ?= ?\([^\)]*\) *(k[cmz]alloc) *\(/ = \1\(/" $f
            done
    
    And then go through and reinstate those cases where code is casting pointers
    to non-pointers.
    
    And then drop a few hunks which conflicted with outstanding work.
    
    Cc: Russell King <rmk@arm.linux.org.uk>, Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index 920bdbf8404f..c10ab47d81fa 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -343,7 +343,7 @@ void unwind_frame_init_from_blocked_task(struct unwind_frame_info *info, struct
 	struct pt_regs *r = &t->thread.regs;
 	struct pt_regs *r2;
 
-	r2 = (struct pt_regs *)kmalloc(sizeof(struct pt_regs), GFP_KERNEL);
+	r2 = kmalloc(sizeof(struct pt_regs), GFP_KERNEL);
 	if (!r2)
 		return;
 	*r2 = *r;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index cc1c1afc3187..920bdbf8404f 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -8,7 +8,6 @@
  * understand what is happening here
  */
 
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/slab.h>

commit 8039de10aae3cd4cf0ef0ccebd58aff0e8810df2
Author: Helge Deller <deller@parisc-linux.org>
Date:   Tue Jan 10 20:35:03 2006 -0500

    [PARISC] Add __read_mostly section for parisc
    
    Flag a whole bunch of things as __read_mostly on parisc. Also flag a few
    branches as unlikely() and cleanup a bit of code.
    
    Signed-off-by: Helge Deller <deller@parisc-linux.org>
    Signed-off-by: Kyle McMartin <kyle@parisc-linux.org>

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
index db141108412e..cc1c1afc3187 100644
--- a/arch/parisc/kernel/unwind.c
+++ b/arch/parisc/kernel/unwind.c
@@ -35,7 +35,7 @@ static spinlock_t unwind_lock;
  * we can call unwind_init as early in the bootup process as 
  * possible (before the slab allocator is initialized)
  */
-static struct unwind_table kernel_unwind_table;
+static struct unwind_table kernel_unwind_table __read_mostly;
 static LIST_HEAD(unwind_tables);
 
 static inline const struct unwind_table_entry *

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/parisc/kernel/unwind.c b/arch/parisc/kernel/unwind.c
new file mode 100644
index 000000000000..db141108412e
--- /dev/null
+++ b/arch/parisc/kernel/unwind.c
@@ -0,0 +1,393 @@
+/*
+ * Kernel unwinding support
+ *
+ * (c) 2002-2004 Randolph Chung <tausq@debian.org>
+ *
+ * Derived partially from the IA64 implementation. The PA-RISC
+ * Runtime Architecture Document is also a useful reference to
+ * understand what is happening here
+ */
+
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/kallsyms.h>
+
+#include <asm/uaccess.h>
+#include <asm/assembly.h>
+
+#include <asm/unwind.h>
+
+/* #define DEBUG 1 */
+#ifdef DEBUG
+#define dbg(x...) printk(x)
+#else
+#define dbg(x...)
+#endif
+
+extern struct unwind_table_entry __start___unwind[];
+extern struct unwind_table_entry __stop___unwind[];
+
+static spinlock_t unwind_lock;
+/*
+ * the kernel unwind block is not dynamically allocated so that
+ * we can call unwind_init as early in the bootup process as 
+ * possible (before the slab allocator is initialized)
+ */
+static struct unwind_table kernel_unwind_table;
+static LIST_HEAD(unwind_tables);
+
+static inline const struct unwind_table_entry *
+find_unwind_entry_in_table(const struct unwind_table *table, unsigned long addr)
+{
+	const struct unwind_table_entry *e = NULL;
+	unsigned long lo, hi, mid;
+
+	lo = 0; 
+	hi = table->length - 1; 
+	
+	while (lo <= hi) {
+		mid = (hi - lo) / 2 + lo;
+		e = &table->table[mid];
+		if (addr < e->region_start)
+			hi = mid - 1;
+		else if (addr > e->region_end)
+			lo = mid + 1;
+		else
+			return e;
+	}
+
+	return NULL;
+}
+
+static const struct unwind_table_entry *
+find_unwind_entry(unsigned long addr)
+{
+	struct unwind_table *table;
+	const struct unwind_table_entry *e = NULL;
+
+	if (addr >= kernel_unwind_table.start && 
+	    addr <= kernel_unwind_table.end)
+		e = find_unwind_entry_in_table(&kernel_unwind_table, addr);
+	else 
+		list_for_each_entry(table, &unwind_tables, list) {
+			if (addr >= table->start && 
+			    addr <= table->end)
+				e = find_unwind_entry_in_table(table, addr);
+			if (e)
+				break;
+		}
+
+	return e;
+}
+
+static void
+unwind_table_init(struct unwind_table *table, const char *name,
+		  unsigned long base_addr, unsigned long gp,
+		  void *table_start, void *table_end)
+{
+	struct unwind_table_entry *start = table_start;
+	struct unwind_table_entry *end = 
+		(struct unwind_table_entry *)table_end - 1;
+
+	table->name = name;
+	table->base_addr = base_addr;
+	table->gp = gp;
+	table->start = base_addr + start->region_start;
+	table->end = base_addr + end->region_end;
+	table->table = (struct unwind_table_entry *)table_start;
+	table->length = end - start + 1;
+	INIT_LIST_HEAD(&table->list);
+
+	for (; start <= end; start++) {
+		if (start < end && 
+		    start->region_end > (start+1)->region_start) {
+			printk("WARNING: Out of order unwind entry! %p and %p\n", start, start+1);
+		}
+
+		start->region_start += base_addr;
+		start->region_end += base_addr;
+	}
+}
+
+static void
+unwind_table_sort(struct unwind_table_entry *start,
+		  struct unwind_table_entry *finish)
+{
+	struct unwind_table_entry el, *p, *q;
+
+	for (p = start + 1; p < finish; ++p) {
+		if (p[0].region_start < p[-1].region_start) {
+			el = *p;
+			q = p;
+			do {
+				q[0] = q[-1];
+				--q;
+			} while (q > start && 
+				 el.region_start < q[-1].region_start);
+			*q = el;
+		}
+	}
+}
+
+struct unwind_table *
+unwind_table_add(const char *name, unsigned long base_addr, 
+		 unsigned long gp,
+                 void *start, void *end)
+{
+	struct unwind_table *table;
+	unsigned long flags;
+	struct unwind_table_entry *s = (struct unwind_table_entry *)start;
+	struct unwind_table_entry *e = (struct unwind_table_entry *)end;
+
+	unwind_table_sort(s, e);
+
+	table = kmalloc(sizeof(struct unwind_table), GFP_USER);
+	if (table == NULL)
+		return NULL;
+	unwind_table_init(table, name, base_addr, gp, start, end);
+	spin_lock_irqsave(&unwind_lock, flags);
+	list_add_tail(&table->list, &unwind_tables);
+	spin_unlock_irqrestore(&unwind_lock, flags);
+
+	return table;
+}
+
+void unwind_table_remove(struct unwind_table *table)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&unwind_lock, flags);
+	list_del(&table->list);
+	spin_unlock_irqrestore(&unwind_lock, flags);
+
+	kfree(table);
+}
+
+/* Called from setup_arch to import the kernel unwind info */
+static int unwind_init(void)
+{
+	long start, stop;
+	register unsigned long gp __asm__ ("r27");
+
+	start = (long)&__start___unwind[0];
+	stop = (long)&__stop___unwind[0];
+
+	spin_lock_init(&unwind_lock);
+
+	printk("unwind_init: start = 0x%lx, end = 0x%lx, entries = %lu\n", 
+	    start, stop,
+	    (stop - start) / sizeof(struct unwind_table_entry));
+
+	unwind_table_init(&kernel_unwind_table, "kernel", KERNEL_START,
+			  gp, 
+			  &__start___unwind[0], &__stop___unwind[0]);
+#if 0
+	{
+		int i;
+		for (i = 0; i < 10; i++)
+		{
+			printk("region 0x%x-0x%x\n", 
+				__start___unwind[i].region_start, 
+				__start___unwind[i].region_end);
+		}
+	}
+#endif
+	return 0;
+}
+
+static void unwind_frame_regs(struct unwind_frame_info *info)
+{
+	const struct unwind_table_entry *e;
+	unsigned long npc;
+	unsigned int insn;
+	long frame_size = 0;
+	int looking_for_rp, rpoffset = 0;
+
+	e = find_unwind_entry(info->ip);
+	if (e == NULL) {
+		unsigned long sp;
+		extern char _stext[], _etext[];
+
+		dbg("Cannot find unwind entry for 0x%lx; forced unwinding\n", info->ip);
+
+#ifdef CONFIG_KALLSYMS
+		/* Handle some frequent special cases.... */
+		{
+			char symname[KSYM_NAME_LEN+1];
+			char *modname;
+			unsigned long symsize, offset;
+
+			kallsyms_lookup(info->ip, &symsize, &offset,
+					&modname, symname);
+
+			dbg("info->ip = 0x%lx, name = %s\n", info->ip, symname);
+
+			if (strcmp(symname, "_switch_to_ret") == 0) {
+				info->prev_sp = info->sp - CALLEE_SAVE_FRAME_SIZE;
+				info->prev_ip = *(unsigned long *)(info->prev_sp - RP_OFFSET);
+				dbg("_switch_to_ret @ %lx - setting "
+				    "prev_sp=%lx prev_ip=%lx\n", 
+				    info->ip, info->prev_sp, 
+				    info->prev_ip);
+				return;
+			} else if (strcmp(symname, "ret_from_kernel_thread") == 0 ||
+				   strcmp(symname, "syscall_exit") == 0) {
+				info->prev_ip = info->prev_sp = 0;
+				return;
+			}
+		}
+#endif
+
+		/* Since we are doing the unwinding blind, we don't know if
+		   we are adjusting the stack correctly or extracting the rp
+		   correctly. The rp is checked to see if it belongs to the
+		   kernel text section, if not we assume we don't have a 
+		   correct stack frame and we continue to unwind the stack.
+		   This is not quite correct, and will fail for loadable
+		   modules. */
+		sp = info->sp & ~63;
+		do {
+			unsigned long tmp;
+
+			info->prev_sp = sp - 64;
+			info->prev_ip = 0;
+			if (get_user(tmp, (unsigned long *)(info->prev_sp - RP_OFFSET))) 
+				break;
+			info->prev_ip = tmp;
+			sp = info->prev_sp;
+		} while (info->prev_ip < (unsigned long)_stext ||
+			 info->prev_ip > (unsigned long)_etext);
+
+		info->rp = 0;
+
+		dbg("analyzing func @ %lx with no unwind info, setting "
+		    "prev_sp=%lx prev_ip=%lx\n", info->ip, 
+		    info->prev_sp, info->prev_ip);
+	} else {
+		dbg("e->start = 0x%x, e->end = 0x%x, Save_SP = %d, "
+		    "Save_RP = %d, Millicode = %d size = %u\n", 
+		    e->region_start, e->region_end, e->Save_SP, e->Save_RP, 
+		    e->Millicode, e->Total_frame_size);
+
+		looking_for_rp = e->Save_RP;
+
+		for (npc = e->region_start; 
+		     (frame_size < (e->Total_frame_size << 3) || 
+		      looking_for_rp) && 
+		     npc < info->ip; 
+		     npc += 4) {
+
+			insn = *(unsigned int *)npc;
+
+			if ((insn & 0xffffc000) == 0x37de0000 ||
+			    (insn & 0xffe00000) == 0x6fc00000) {
+				/* ldo X(sp), sp, or stwm X,D(sp) */
+				frame_size += (insn & 0x1 ? -1 << 13 : 0) | 
+					((insn & 0x3fff) >> 1);
+				dbg("analyzing func @ %lx, insn=%08x @ "
+				    "%lx, frame_size = %ld\n", info->ip,
+				    insn, npc, frame_size);
+			} else if ((insn & 0xffe00008) == 0x73c00008) {
+				/* std,ma X,D(sp) */
+				frame_size += (insn & 0x1 ? -1 << 13 : 0) | 
+					(((insn >> 4) & 0x3ff) << 3);
+				dbg("analyzing func @ %lx, insn=%08x @ "
+				    "%lx, frame_size = %ld\n", info->ip,
+				    insn, npc, frame_size);
+			} else if (insn == 0x6bc23fd9) { 
+				/* stw rp,-20(sp) */
+				rpoffset = 20;
+				looking_for_rp = 0;
+				dbg("analyzing func @ %lx, insn=stw rp,"
+				    "-20(sp) @ %lx\n", info->ip, npc);
+			} else if (insn == 0x0fc212c1) {
+				/* std rp,-16(sr0,sp) */
+				rpoffset = 16;
+				looking_for_rp = 0;
+				dbg("analyzing func @ %lx, insn=std rp,"
+				    "-16(sp) @ %lx\n", info->ip, npc);
+			}
+		}
+
+		info->prev_sp = info->sp - frame_size;
+		if (e->Millicode)
+			info->rp = info->r31;
+		else if (rpoffset)
+			info->rp = *(unsigned long *)(info->prev_sp - rpoffset);
+		info->prev_ip = info->rp;
+		info->rp = 0;
+
+		dbg("analyzing func @ %lx, setting prev_sp=%lx "
+		    "prev_ip=%lx npc=%lx\n", info->ip, info->prev_sp, 
+		    info->prev_ip, npc);
+	}
+}
+
+void unwind_frame_init(struct unwind_frame_info *info, struct task_struct *t, 
+		       struct pt_regs *regs)
+{
+	memset(info, 0, sizeof(struct unwind_frame_info));
+	info->t = t;
+	info->sp = regs->gr[30];
+	info->ip = regs->iaoq[0];
+	info->rp = regs->gr[2];
+	info->r31 = regs->gr[31];
+
+	dbg("(%d) Start unwind from sp=%08lx ip=%08lx\n", 
+	    t ? (int)t->pid : -1, info->sp, info->ip);
+}
+
+void unwind_frame_init_from_blocked_task(struct unwind_frame_info *info, struct task_struct *t)
+{
+	struct pt_regs *r = &t->thread.regs;
+	struct pt_regs *r2;
+
+	r2 = (struct pt_regs *)kmalloc(sizeof(struct pt_regs), GFP_KERNEL);
+	if (!r2)
+		return;
+	*r2 = *r;
+	r2->gr[30] = r->ksp;
+	r2->iaoq[0] = r->kpc;
+	unwind_frame_init(info, t, r2);
+	kfree(r2);
+}
+
+void unwind_frame_init_running(struct unwind_frame_info *info, struct pt_regs *regs)
+{
+	unwind_frame_init(info, current, regs);
+}
+
+int unwind_once(struct unwind_frame_info *next_frame)
+{
+	unwind_frame_regs(next_frame);
+
+	if (next_frame->prev_sp == 0 ||
+	    next_frame->prev_ip == 0)
+		return -1;
+
+	next_frame->sp = next_frame->prev_sp;
+	next_frame->ip = next_frame->prev_ip;
+	next_frame->prev_sp = 0;
+	next_frame->prev_ip = 0;
+
+	dbg("(%d) Continue unwind to sp=%08lx ip=%08lx\n", 
+	    next_frame->t ? (int)next_frame->t->pid : -1, 
+	    next_frame->sp, next_frame->ip);
+
+	return 0;
+}
+
+int unwind_to_user(struct unwind_frame_info *info)
+{
+	int ret;
+	
+	do {
+		ret = unwind_once(info);
+	} while (!ret && !(info->ip & 3));
+
+	return ret;
+}
+
+module_init(unwind_init);
