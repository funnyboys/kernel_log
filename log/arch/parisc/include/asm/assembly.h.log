commit de6cc6515a445d5d81cad2dee899a0be1a6317f8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 153
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details you should have received a
      copy of the gnu general public license along with this program if
      not write to the free software foundation inc 675 mass ave cambridge
      ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 77 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.837555891@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/parisc/include/asm/assembly.h b/arch/parisc/include/asm/assembly.h
index d85738a7bbe6..a39250cb7dfc 100644
--- a/arch/parisc/include/asm/assembly.h
+++ b/arch/parisc/include/asm/assembly.h
@@ -1,21 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Copyright (C) 1999 Hewlett-Packard (Frank Rowand)
  * Copyright (C) 1999 Philipp Rumpf <prumpf@tux.org>
  * Copyright (C) 1999 SuSE GmbH
- *
- *    This program is free software; you can redistribute it and/or modify
- *    it under the terms of the GNU General Public License as published by
- *    the Free Software Foundation; either version 2, or (at your option)
- *    any later version.
- *
- *    This program is distributed in the hope that it will be useful,
- *    but WITHOUT ANY WARRANTY; without even the implied warranty of
- *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *    GNU General Public License for more details.
- *
- *    You should have received a copy of the GNU General Public License
- *    along with this program; if not, write to the Free Software
- *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #ifndef _PARISC_ASSEMBLY_H

commit 1829dda0e87f4462782ca81be474c7890efe31ce
Author: Helge Deller <deller@gmx.de>
Date:   Sun May 5 23:54:34 2019 +0200

    parisc: Rename LEVEL to PA_ASM_LEVEL to avoid name clash with DRBD code
    
    LEVEL is a very common word, and now after many years it suddenly
    clashed with another LEVEL define in the DRBD code.
    Rename it to PA_ASM_LEVEL instead.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Helge Deller <deller@gmx.de>
    Cc: <stable@vger.kernel.org>

diff --git a/arch/parisc/include/asm/assembly.h b/arch/parisc/include/asm/assembly.h
index c17ec0ee6e7c..d85738a7bbe6 100644
--- a/arch/parisc/include/asm/assembly.h
+++ b/arch/parisc/include/asm/assembly.h
@@ -61,14 +61,14 @@
 #define LDCW		ldcw,co
 #define BL		b,l
 # ifdef CONFIG_64BIT
-#  define LEVEL		2.0w
+#  define PA_ASM_LEVEL	2.0w
 # else
-#  define LEVEL		2.0
+#  define PA_ASM_LEVEL	2.0
 # endif
 #else
 #define LDCW		ldcw
 #define BL		bl
-#define LEVEL		1.1
+#define PA_ASM_LEVEL	1.1
 #endif
 
 #ifdef __ASSEMBLY__

commit a45a01160f1d46a3021755a2cf2f433aec008e38
Author: Helge Deller <deller@gmx.de>
Date:   Fri Oct 19 20:31:20 2018 +0200

    parisc: Use zdep for shlw macro on PA1.1 and PA2.0
    
    The zdep and depw,z mnemonics generate the same code. The assembler will
    accept the depw,z mnemonic when generating PA 1.x code. The zdep
    mnemonic is okay when generating PA 2.0 code. This patch changes depw,z
    to zdep in the current shlw macro, while the binary code will be the
    same.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: John David Anglin <dave.anglin@bell.net>

diff --git a/arch/parisc/include/asm/assembly.h b/arch/parisc/include/asm/assembly.h
index e9c6385ef0d1..c17ec0ee6e7c 100644
--- a/arch/parisc/include/asm/assembly.h
+++ b/arch/parisc/include/asm/assembly.h
@@ -129,15 +129,8 @@
 	.macro	debug value
 	.endm
 
-
-	/* Shift Left - note the r and t can NOT be the same! */
-	.macro shl r, sa, t
-	dep,z	\r, 31-(\sa), 32-(\sa), \t
-	.endm
-
-	/* The PA 2.0 shift left */
 	.macro shlw r, sa, t
-	depw,z	\r, 31-(\sa), 32-(\sa), \t
+	zdep	\r, 31-(\sa), 32-(\sa), \t
 	.endm
 
 	/* And the PA 2.0W shift left */

commit c8921d72e390cb6fca3fb2b0c2badfda851647eb
Author: Helge Deller <deller@gmx.de>
Date:   Sun Aug 5 00:03:29 2018 +0200

    parisc: Fix and improve kernel stack unwinding
    
    This patchset fixes and improves stack unwinding a lot:
    1. Show backward stack traces with up to 30 callsites
    2. Add callinfo to ENTRY_CFI() such that every assembler function will get an
       entry in the unwind table
    3. Use constants instead of numbers in call_on_stack()
    4. Do not depend on CONFIG_KALLSYMS to generate backtraces.
    5. Speed up backtrace generation
    
    Make sure you have this patch to GNU as installed:
    https://sourceware.org/ml/binutils/2018-07/msg00474.html
    Without this patch, unwind info in the kernel is often wrong for various
    functions.
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/include/asm/assembly.h b/arch/parisc/include/asm/assembly.h
index 60e6f07b7e32..e9c6385ef0d1 100644
--- a/arch/parisc/include/asm/assembly.h
+++ b/arch/parisc/include/asm/assembly.h
@@ -36,6 +36,7 @@
 #define RP_OFFSET	16
 #define FRAME_SIZE	128
 #define CALLEE_REG_FRAME_SIZE	144
+#define REG_SZ		8
 #define ASM_ULONG_INSN	.dword
 #else	/* CONFIG_64BIT */
 #define LDREG	ldw
@@ -50,6 +51,7 @@
 #define RP_OFFSET	20
 #define FRAME_SIZE	64
 #define CALLEE_REG_FRAME_SIZE	128
+#define REG_SZ		4
 #define ASM_ULONG_INSN	.word
 #endif
 

commit 0de798584bdedfdad19db21e3c7aec84f252f4f3
Author: Helge Deller <deller@gmx.de>
Date:   Wed Mar 23 16:00:46 2016 +0100

    parisc: Use generic extable search and sort routines
    
    Switch to the generic extable search and sort routines which were introduced
    with commit a272858 from Ard Biesheuvel. This saves quite some memory in the
    vmlinux binary with the 64bit kernel.
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/include/asm/assembly.h b/arch/parisc/include/asm/assembly.h
index b3069fd83468..60e6f07b7e32 100644
--- a/arch/parisc/include/asm/assembly.h
+++ b/arch/parisc/include/asm/assembly.h
@@ -523,7 +523,7 @@
 	 */
 #define ASM_EXCEPTIONTABLE_ENTRY(fault_addr, except_addr)	\
 	.section __ex_table,"aw"			!	\
-	ASM_ULONG_INSN	fault_addr, except_addr		!	\
+	.word (fault_addr - .), (except_addr - .)	!	\
 	.previous
 
 

commit 61dbbaeb86c2181c79efae2d186193e0f8008af1
Author: Helge Deller <deller@gmx.de>
Date:   Sun Oct 13 21:11:30 2013 +0200

    parisc: provide macro to create exception table entries
    
    Provide a macro ASM_EXCEPTIONTABLE_ENTRY() to create exception table
    entries and convert all open-coded places to use that macro.
    
    This patch is a first step toward creating a exception table which only
    holds 32bit pointers even on a 64bit kernel. That way in my own kernel
    I was able to reduce the in-kernel exception table from 44kB to 22kB.
    
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/include/asm/assembly.h b/arch/parisc/include/asm/assembly.h
index 0da848232344..b3069fd83468 100644
--- a/arch/parisc/include/asm/assembly.h
+++ b/arch/parisc/include/asm/assembly.h
@@ -515,5 +515,17 @@
 	nop	/* 7 */
 	.endm
 
+	/*
+	 * ASM_EXCEPTIONTABLE_ENTRY
+	 *
+	 * Creates an exception table entry.
+	 * Do not convert to a assembler macro. This won't work.
+	 */
+#define ASM_EXCEPTIONTABLE_ENTRY(fault_addr, except_addr)	\
+	.section __ex_table,"aw"			!	\
+	ASM_ULONG_INSN	fault_addr, except_addr		!	\
+	.previous
+
+
 #endif /* __ASSEMBLY__ */
 #endif

commit b63a2bbc0b9b106a93e11952ab057e2408f2eb02
Author: John David Anglin <dave.anglin@bell.net>
Date:   Mon May 20 16:42:53 2013 +0000

    parisc: make interrupt and interruption stack allocation reentrant
    
    The get_stack_use_cr30 and get_stack_use_r30 macros allocate a stack
    frame for external interrupts and interruptions requiring a stack frame.
    They are currently not reentrant in that they save register context
    before the stack is set or adjusted.
    
    I have observed a number of system crashes where there was clear
    evidence of stack corruption during interrupt processing, and as a
    result register corruption. Some interruptions can still occur during
    interruption processing, however external interrupts are disabled and
    data TLB misses don't occur for absolute accesses. So, it's not entirely
    clear what triggers this issue. Also, if an interruption occurs when
    Q=0, it is generally not possible to recover as the shadowed registers
    are not copied.
    
    The attached patch reworks the get_stack_use_cr30 and get_stack_use_r30
    macros to allocate stack before doing register saves. The new code is a
    couple of instructions shorter than the old implementation. Thus, it's
    an improvement even if it doesn't fully resolve the stack corruption
    issue. Based on limited testing, it improves SMP system stability.
    
    Signed-off-by: John David Anglin <dave.anglin@bell.net>
    Signed-off-by: Helge Deller <deller@gmx.de>

diff --git a/arch/parisc/include/asm/assembly.h b/arch/parisc/include/asm/assembly.h
index 89fb40005e3f..0da848232344 100644
--- a/arch/parisc/include/asm/assembly.h
+++ b/arch/parisc/include/asm/assembly.h
@@ -438,7 +438,6 @@
 	SAVE_SP  (%sr4, PT_SR4 (\regs))
 	SAVE_SP  (%sr5, PT_SR5 (\regs))
 	SAVE_SP  (%sr6, PT_SR6 (\regs))
-	SAVE_SP  (%sr7, PT_SR7 (\regs))
 
 	SAVE_CR  (%cr17, PT_IASQ0(\regs))
 	mtctl	 %r0,	%cr17

commit c1da90fd099531e9449019dc53a5a02a5eaef2b4
Author: Helge Deller <deller@gmx.de>
Date:   Mon Jan 26 22:24:38 2009 +0100

    parisc: fix 64bit build
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/arch/parisc/include/asm/assembly.h b/arch/parisc/include/asm/assembly.h
index ab7cc373ee56..89fb40005e3f 100644
--- a/arch/parisc/include/asm/assembly.h
+++ b/arch/parisc/include/asm/assembly.h
@@ -79,6 +79,7 @@
 
 #include <asm/asm-offsets.h>
 #include <asm/page.h>
+#include <asm/types.h>
 
 #include <asm/asmregs.h>
 

commit 2cfeb9a6755d4d7be1026422b6aced48e3bad492
Author: Helge Deller <deller@gmx.de>
Date:   Sun Jan 18 18:13:53 2009 +0100

    parisc: add braces around arguments in assembler macros
    
    Add braces around the macro arguments, else for example
    "shl %r1, 5-3, %r2" would not expand to what you would assume.
    
    Signed-off-by: Helge Deller <deller@gmx.de>
    Signed-off-by: Kyle McMartin <kyle@mcmartin.ca>

diff --git a/arch/parisc/include/asm/assembly.h b/arch/parisc/include/asm/assembly.h
index ffb208840ecc..ab7cc373ee56 100644
--- a/arch/parisc/include/asm/assembly.h
+++ b/arch/parisc/include/asm/assembly.h
@@ -129,27 +129,27 @@
 
 	/* Shift Left - note the r and t can NOT be the same! */
 	.macro shl r, sa, t
-	dep,z	\r, 31-\sa, 32-\sa, \t
+	dep,z	\r, 31-(\sa), 32-(\sa), \t
 	.endm
 
 	/* The PA 2.0 shift left */
 	.macro shlw r, sa, t
-	depw,z	\r, 31-\sa, 32-\sa, \t
+	depw,z	\r, 31-(\sa), 32-(\sa), \t
 	.endm
 
 	/* And the PA 2.0W shift left */
 	.macro shld r, sa, t
-	depd,z	\r, 63-\sa, 64-\sa, \t
+	depd,z	\r, 63-(\sa), 64-(\sa), \t
 	.endm
 
 	/* Shift Right - note the r and t can NOT be the same! */
 	.macro shr r, sa, t
-	extru \r, 31-\sa, 32-\sa, \t
+	extru \r, 31-(\sa), 32-(\sa), \t
 	.endm
 
 	/* pa20w version of shift right */
 	.macro shrd r, sa, t
-	extrd,u \r, 63-\sa, 64-\sa, \t
+	extrd,u \r, 63-(\sa), 64-(\sa), \t
 	.endm
 
 	/* load 32-bit 'value' into 'reg' compensating for the ldil

commit deae26bf6a10e47983606f5df080b91e97650ead
Author: Kyle McMartin <kyle@mcmartin.ca>
Date:   Mon Jul 28 23:02:13 2008 -0400

    parisc: move include/asm-parisc to arch/parisc/include/asm

diff --git a/arch/parisc/include/asm/assembly.h b/arch/parisc/include/asm/assembly.h
new file mode 100644
index 000000000000..ffb208840ecc
--- /dev/null
+++ b/arch/parisc/include/asm/assembly.h
@@ -0,0 +1,519 @@
+/*
+ * Copyright (C) 1999 Hewlett-Packard (Frank Rowand)
+ * Copyright (C) 1999 Philipp Rumpf <prumpf@tux.org>
+ * Copyright (C) 1999 SuSE GmbH
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; either version 2, or (at your option)
+ *    any later version.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *    GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#ifndef _PARISC_ASSEMBLY_H
+#define _PARISC_ASSEMBLY_H
+
+#define CALLEE_FLOAT_FRAME_SIZE	80
+
+#ifdef CONFIG_64BIT
+#define LDREG	ldd
+#define STREG	std
+#define LDREGX  ldd,s
+#define LDREGM	ldd,mb
+#define STREGM	std,ma
+#define SHRREG	shrd
+#define SHLREG	shld
+#define ANDCM   andcm,*
+#define	COND(x)	* ## x
+#define RP_OFFSET	16
+#define FRAME_SIZE	128
+#define CALLEE_REG_FRAME_SIZE	144
+#define ASM_ULONG_INSN	.dword
+#else	/* CONFIG_64BIT */
+#define LDREG	ldw
+#define STREG	stw
+#define LDREGX  ldwx,s
+#define LDREGM	ldwm
+#define STREGM	stwm
+#define SHRREG	shr
+#define SHLREG	shlw
+#define ANDCM   andcm
+#define COND(x)	x
+#define RP_OFFSET	20
+#define FRAME_SIZE	64
+#define CALLEE_REG_FRAME_SIZE	128
+#define ASM_ULONG_INSN	.word
+#endif
+
+#define CALLEE_SAVE_FRAME_SIZE (CALLEE_REG_FRAME_SIZE + CALLEE_FLOAT_FRAME_SIZE)
+
+#ifdef CONFIG_PA20
+#define LDCW		ldcw,co
+#define BL		b,l
+# ifdef CONFIG_64BIT
+#  define LEVEL		2.0w
+# else
+#  define LEVEL		2.0
+# endif
+#else
+#define LDCW		ldcw
+#define BL		bl
+#define LEVEL		1.1
+#endif
+
+#ifdef __ASSEMBLY__
+
+#ifdef CONFIG_64BIT
+/* the 64-bit pa gnu assembler unfortunately defaults to .level 1.1 or 2.0 so
+ * work around that for now... */
+	.level 2.0w
+#endif
+
+#include <asm/asm-offsets.h>
+#include <asm/page.h>
+
+#include <asm/asmregs.h>
+
+	sp	=	30
+	gp	=	27
+	ipsw	=	22
+
+	/*
+	 * We provide two versions of each macro to convert from physical
+	 * to virtual and vice versa. The "_r1" versions take one argument
+	 * register, but trashes r1 to do the conversion. The other
+	 * version takes two arguments: a src and destination register.
+	 * However, the source and destination registers can not be
+	 * the same register.
+	 */
+
+	.macro  tophys  grvirt, grphys
+	ldil    L%(__PAGE_OFFSET), \grphys
+	sub     \grvirt, \grphys, \grphys
+	.endm
+	
+	.macro  tovirt  grphys, grvirt
+	ldil    L%(__PAGE_OFFSET), \grvirt
+	add     \grphys, \grvirt, \grvirt
+	.endm
+
+	.macro  tophys_r1  gr
+	ldil    L%(__PAGE_OFFSET), %r1
+	sub     \gr, %r1, \gr
+	.endm
+	
+	.macro  tovirt_r1  gr
+	ldil    L%(__PAGE_OFFSET), %r1
+	add     \gr, %r1, \gr
+	.endm
+
+	.macro delay value
+	ldil	L%\value, 1
+	ldo	R%\value(1), 1
+	addib,UV,n -1,1,.
+	addib,NUV,n -1,1,.+8
+	nop
+	.endm
+
+	.macro	debug value
+	.endm
+
+
+	/* Shift Left - note the r and t can NOT be the same! */
+	.macro shl r, sa, t
+	dep,z	\r, 31-\sa, 32-\sa, \t
+	.endm
+
+	/* The PA 2.0 shift left */
+	.macro shlw r, sa, t
+	depw,z	\r, 31-\sa, 32-\sa, \t
+	.endm
+
+	/* And the PA 2.0W shift left */
+	.macro shld r, sa, t
+	depd,z	\r, 63-\sa, 64-\sa, \t
+	.endm
+
+	/* Shift Right - note the r and t can NOT be the same! */
+	.macro shr r, sa, t
+	extru \r, 31-\sa, 32-\sa, \t
+	.endm
+
+	/* pa20w version of shift right */
+	.macro shrd r, sa, t
+	extrd,u \r, 63-\sa, 64-\sa, \t
+	.endm
+
+	/* load 32-bit 'value' into 'reg' compensating for the ldil
+	 * sign-extension when running in wide mode.
+	 * WARNING!! neither 'value' nor 'reg' can be expressions
+	 * containing '.'!!!! */
+	.macro	load32 value, reg
+	ldil	L%\value, \reg
+	ldo	R%\value(\reg), \reg
+	.endm
+
+	.macro loadgp
+#ifdef CONFIG_64BIT
+	ldil		L%__gp, %r27
+	ldo		R%__gp(%r27), %r27
+#else
+	ldil		L%$global$, %r27
+	ldo		R%$global$(%r27), %r27
+#endif
+	.endm
+
+#define SAVE_SP(r, where) mfsp r, %r1 ! STREG %r1, where
+#define REST_SP(r, where) LDREG where, %r1 ! mtsp %r1, r
+#define SAVE_CR(r, where) mfctl r, %r1 ! STREG %r1, where
+#define REST_CR(r, where) LDREG where, %r1 ! mtctl %r1, r
+
+	.macro	save_general	regs
+	STREG %r1, PT_GR1 (\regs)
+	STREG %r2, PT_GR2 (\regs)
+	STREG %r3, PT_GR3 (\regs)
+	STREG %r4, PT_GR4 (\regs)
+	STREG %r5, PT_GR5 (\regs)
+	STREG %r6, PT_GR6 (\regs)
+	STREG %r7, PT_GR7 (\regs)
+	STREG %r8, PT_GR8 (\regs)
+	STREG %r9, PT_GR9 (\regs)
+	STREG %r10, PT_GR10(\regs)
+	STREG %r11, PT_GR11(\regs)
+	STREG %r12, PT_GR12(\regs)
+	STREG %r13, PT_GR13(\regs)
+	STREG %r14, PT_GR14(\regs)
+	STREG %r15, PT_GR15(\regs)
+	STREG %r16, PT_GR16(\regs)
+	STREG %r17, PT_GR17(\regs)
+	STREG %r18, PT_GR18(\regs)
+	STREG %r19, PT_GR19(\regs)
+	STREG %r20, PT_GR20(\regs)
+	STREG %r21, PT_GR21(\regs)
+	STREG %r22, PT_GR22(\regs)
+	STREG %r23, PT_GR23(\regs)
+	STREG %r24, PT_GR24(\regs)
+	STREG %r25, PT_GR25(\regs)
+	/* r26 is saved in get_stack and used to preserve a value across virt_map */
+	STREG %r27, PT_GR27(\regs)
+	STREG %r28, PT_GR28(\regs)
+	/* r29 is saved in get_stack and used to point to saved registers */
+	/* r30 stack pointer saved in get_stack */
+	STREG %r31, PT_GR31(\regs)
+	.endm
+
+	.macro	rest_general	regs
+	/* r1 used as a temp in rest_stack and is restored there */
+	LDREG PT_GR2 (\regs), %r2
+	LDREG PT_GR3 (\regs), %r3
+	LDREG PT_GR4 (\regs), %r4
+	LDREG PT_GR5 (\regs), %r5
+	LDREG PT_GR6 (\regs), %r6
+	LDREG PT_GR7 (\regs), %r7
+	LDREG PT_GR8 (\regs), %r8
+	LDREG PT_GR9 (\regs), %r9
+	LDREG PT_GR10(\regs), %r10
+	LDREG PT_GR11(\regs), %r11
+	LDREG PT_GR12(\regs), %r12
+	LDREG PT_GR13(\regs), %r13
+	LDREG PT_GR14(\regs), %r14
+	LDREG PT_GR15(\regs), %r15
+	LDREG PT_GR16(\regs), %r16
+	LDREG PT_GR17(\regs), %r17
+	LDREG PT_GR18(\regs), %r18
+	LDREG PT_GR19(\regs), %r19
+	LDREG PT_GR20(\regs), %r20
+	LDREG PT_GR21(\regs), %r21
+	LDREG PT_GR22(\regs), %r22
+	LDREG PT_GR23(\regs), %r23
+	LDREG PT_GR24(\regs), %r24
+	LDREG PT_GR25(\regs), %r25
+	LDREG PT_GR26(\regs), %r26
+	LDREG PT_GR27(\regs), %r27
+	LDREG PT_GR28(\regs), %r28
+	/* r29 points to register save area, and is restored in rest_stack */
+	/* r30 stack pointer restored in rest_stack */
+	LDREG PT_GR31(\regs), %r31
+	.endm
+
+	.macro	save_fp 	regs
+	fstd,ma  %fr0, 8(\regs)
+	fstd,ma	 %fr1, 8(\regs)
+	fstd,ma	 %fr2, 8(\regs)
+	fstd,ma	 %fr3, 8(\regs)
+	fstd,ma	 %fr4, 8(\regs)
+	fstd,ma	 %fr5, 8(\regs)
+	fstd,ma	 %fr6, 8(\regs)
+	fstd,ma	 %fr7, 8(\regs)
+	fstd,ma	 %fr8, 8(\regs)
+	fstd,ma	 %fr9, 8(\regs)
+	fstd,ma	%fr10, 8(\regs)
+	fstd,ma	%fr11, 8(\regs)
+	fstd,ma	%fr12, 8(\regs)
+	fstd,ma	%fr13, 8(\regs)
+	fstd,ma	%fr14, 8(\regs)
+	fstd,ma	%fr15, 8(\regs)
+	fstd,ma	%fr16, 8(\regs)
+	fstd,ma	%fr17, 8(\regs)
+	fstd,ma	%fr18, 8(\regs)
+	fstd,ma	%fr19, 8(\regs)
+	fstd,ma	%fr20, 8(\regs)
+	fstd,ma	%fr21, 8(\regs)
+	fstd,ma	%fr22, 8(\regs)
+	fstd,ma	%fr23, 8(\regs)
+	fstd,ma	%fr24, 8(\regs)
+	fstd,ma	%fr25, 8(\regs)
+	fstd,ma	%fr26, 8(\regs)
+	fstd,ma	%fr27, 8(\regs)
+	fstd,ma	%fr28, 8(\regs)
+	fstd,ma	%fr29, 8(\regs)
+	fstd,ma	%fr30, 8(\regs)
+	fstd	%fr31, 0(\regs)
+	.endm
+
+	.macro	rest_fp 	regs
+	fldd	0(\regs),	 %fr31
+	fldd,mb	-8(\regs),       %fr30
+	fldd,mb	-8(\regs),       %fr29
+	fldd,mb	-8(\regs),       %fr28
+	fldd,mb	-8(\regs),       %fr27
+	fldd,mb	-8(\regs),       %fr26
+	fldd,mb	-8(\regs),       %fr25
+	fldd,mb	-8(\regs),       %fr24
+	fldd,mb	-8(\regs),       %fr23
+	fldd,mb	-8(\regs),       %fr22
+	fldd,mb	-8(\regs),       %fr21
+	fldd,mb	-8(\regs),       %fr20
+	fldd,mb	-8(\regs),       %fr19
+	fldd,mb	-8(\regs),       %fr18
+	fldd,mb	-8(\regs),       %fr17
+	fldd,mb	-8(\regs),       %fr16
+	fldd,mb	-8(\regs),       %fr15
+	fldd,mb	-8(\regs),       %fr14
+	fldd,mb	-8(\regs),       %fr13
+	fldd,mb	-8(\regs),       %fr12
+	fldd,mb	-8(\regs),       %fr11
+	fldd,mb	-8(\regs),       %fr10
+	fldd,mb	-8(\regs),       %fr9
+	fldd,mb	-8(\regs),       %fr8
+	fldd,mb	-8(\regs),       %fr7
+	fldd,mb	-8(\regs),       %fr6
+	fldd,mb	-8(\regs),       %fr5
+	fldd,mb	-8(\regs),       %fr4
+	fldd,mb	-8(\regs),       %fr3
+	fldd,mb	-8(\regs),       %fr2
+	fldd,mb	-8(\regs),       %fr1
+	fldd,mb	-8(\regs),       %fr0
+	.endm
+
+	.macro	callee_save_float
+	fstd,ma	 %fr12,	8(%r30)
+	fstd,ma	 %fr13,	8(%r30)
+	fstd,ma	 %fr14,	8(%r30)
+	fstd,ma	 %fr15,	8(%r30)
+	fstd,ma	 %fr16,	8(%r30)
+	fstd,ma	 %fr17,	8(%r30)
+	fstd,ma	 %fr18,	8(%r30)
+	fstd,ma	 %fr19,	8(%r30)
+	fstd,ma	 %fr20,	8(%r30)
+	fstd,ma	 %fr21,	8(%r30)
+	.endm
+
+	.macro	callee_rest_float
+	fldd,mb	-8(%r30),   %fr21
+	fldd,mb	-8(%r30),   %fr20
+	fldd,mb	-8(%r30),   %fr19
+	fldd,mb	-8(%r30),   %fr18
+	fldd,mb	-8(%r30),   %fr17
+	fldd,mb	-8(%r30),   %fr16
+	fldd,mb	-8(%r30),   %fr15
+	fldd,mb	-8(%r30),   %fr14
+	fldd,mb	-8(%r30),   %fr13
+	fldd,mb	-8(%r30),   %fr12
+	.endm
+
+#ifdef CONFIG_64BIT
+	.macro	callee_save
+	std,ma	  %r3,	 CALLEE_REG_FRAME_SIZE(%r30)
+	mfctl	  %cr27, %r3
+	std	  %r4,	-136(%r30)
+	std	  %r5,	-128(%r30)
+	std	  %r6,	-120(%r30)
+	std	  %r7,	-112(%r30)
+	std	  %r8,	-104(%r30)
+	std	  %r9,	 -96(%r30)
+	std	 %r10,	 -88(%r30)
+	std	 %r11,	 -80(%r30)
+	std	 %r12,	 -72(%r30)
+	std	 %r13,	 -64(%r30)
+	std	 %r14,	 -56(%r30)
+	std	 %r15,	 -48(%r30)
+	std	 %r16,	 -40(%r30)
+	std	 %r17,	 -32(%r30)
+	std	 %r18,	 -24(%r30)
+	std	  %r3,	 -16(%r30)
+	.endm
+
+	.macro	callee_rest
+	ldd	 -16(%r30),    %r3
+	ldd	 -24(%r30),   %r18
+	ldd	 -32(%r30),   %r17
+	ldd	 -40(%r30),   %r16
+	ldd	 -48(%r30),   %r15
+	ldd	 -56(%r30),   %r14
+	ldd	 -64(%r30),   %r13
+	ldd	 -72(%r30),   %r12
+	ldd	 -80(%r30),   %r11
+	ldd	 -88(%r30),   %r10
+	ldd	 -96(%r30),    %r9
+	ldd	-104(%r30),    %r8
+	ldd	-112(%r30),    %r7
+	ldd	-120(%r30),    %r6
+	ldd	-128(%r30),    %r5
+	ldd	-136(%r30),    %r4
+	mtctl	%r3, %cr27
+	ldd,mb	-CALLEE_REG_FRAME_SIZE(%r30),    %r3
+	.endm
+
+#else /* ! CONFIG_64BIT */
+
+	.macro	callee_save
+	stw,ma	 %r3,	CALLEE_REG_FRAME_SIZE(%r30)
+	mfctl	 %cr27, %r3
+	stw	 %r4,	-124(%r30)
+	stw	 %r5,	-120(%r30)
+	stw	 %r6,	-116(%r30)
+	stw	 %r7,	-112(%r30)
+	stw	 %r8,	-108(%r30)
+	stw	 %r9,	-104(%r30)
+	stw	 %r10,	-100(%r30)
+	stw	 %r11,	 -96(%r30)
+	stw	 %r12,	 -92(%r30)
+	stw	 %r13,	 -88(%r30)
+	stw	 %r14,	 -84(%r30)
+	stw	 %r15,	 -80(%r30)
+	stw	 %r16,	 -76(%r30)
+	stw	 %r17,	 -72(%r30)
+	stw	 %r18,	 -68(%r30)
+	stw	  %r3,	 -64(%r30)
+	.endm
+
+	.macro	callee_rest
+	ldw	 -64(%r30),    %r3
+	ldw	 -68(%r30),   %r18
+	ldw	 -72(%r30),   %r17
+	ldw	 -76(%r30),   %r16
+	ldw	 -80(%r30),   %r15
+	ldw	 -84(%r30),   %r14
+	ldw	 -88(%r30),   %r13
+	ldw	 -92(%r30),   %r12
+	ldw	 -96(%r30),   %r11
+	ldw	-100(%r30),   %r10
+	ldw	-104(%r30),   %r9
+	ldw	-108(%r30),   %r8
+	ldw	-112(%r30),   %r7
+	ldw	-116(%r30),   %r6
+	ldw	-120(%r30),   %r5
+	ldw	-124(%r30),   %r4
+	mtctl	%r3, %cr27
+	ldw,mb	-CALLEE_REG_FRAME_SIZE(%r30),   %r3
+	.endm
+#endif /* ! CONFIG_64BIT */
+
+	.macro	save_specials	regs
+
+	SAVE_SP  (%sr0, PT_SR0 (\regs))
+	SAVE_SP  (%sr1, PT_SR1 (\regs))
+	SAVE_SP  (%sr2, PT_SR2 (\regs))
+	SAVE_SP  (%sr3, PT_SR3 (\regs))
+	SAVE_SP  (%sr4, PT_SR4 (\regs))
+	SAVE_SP  (%sr5, PT_SR5 (\regs))
+	SAVE_SP  (%sr6, PT_SR6 (\regs))
+	SAVE_SP  (%sr7, PT_SR7 (\regs))
+
+	SAVE_CR  (%cr17, PT_IASQ0(\regs))
+	mtctl	 %r0,	%cr17
+	SAVE_CR  (%cr17, PT_IASQ1(\regs))
+
+	SAVE_CR  (%cr18, PT_IAOQ0(\regs))
+	mtctl	 %r0,	%cr18
+	SAVE_CR  (%cr18, PT_IAOQ1(\regs))
+
+#ifdef CONFIG_64BIT
+	/* cr11 (sar) is a funny one.  5 bits on PA1.1 and 6 bit on PA2.0
+	 * For PA2.0 mtsar or mtctl always write 6 bits, but mfctl only
+	 * reads 5 bits.  Use mfctl,w to read all six bits.  Otherwise
+	 * we lose the 6th bit on a save/restore over interrupt.
+	 */
+	mfctl,w  %cr11, %r1
+	STREG    %r1, PT_SAR (\regs)
+#else
+	SAVE_CR  (%cr11, PT_SAR  (\regs))
+#endif
+	SAVE_CR  (%cr19, PT_IIR  (\regs))
+
+	/*
+	 * Code immediately following this macro (in intr_save) relies
+	 * on r8 containing ipsw.
+	 */
+	mfctl    %cr22, %r8
+	STREG    %r8,   PT_PSW(\regs)
+	.endm
+
+	.macro	rest_specials	regs
+
+	REST_SP  (%sr0, PT_SR0 (\regs))
+	REST_SP  (%sr1, PT_SR1 (\regs))
+	REST_SP  (%sr2, PT_SR2 (\regs))
+	REST_SP  (%sr3, PT_SR3 (\regs))
+	REST_SP  (%sr4, PT_SR4 (\regs))
+	REST_SP  (%sr5, PT_SR5 (\regs))
+	REST_SP  (%sr6, PT_SR6 (\regs))
+	REST_SP  (%sr7, PT_SR7 (\regs))
+
+	REST_CR	(%cr17, PT_IASQ0(\regs))
+	REST_CR	(%cr17, PT_IASQ1(\regs))
+
+	REST_CR	(%cr18, PT_IAOQ0(\regs))
+	REST_CR	(%cr18, PT_IAOQ1(\regs))
+
+	REST_CR (%cr11, PT_SAR	(\regs))
+
+	REST_CR	(%cr22, PT_PSW	(\regs))
+	.endm
+
+
+	/* First step to create a "relied upon translation"
+	 * See PA 2.0 Arch. page F-4 and F-5.
+	 *
+	 * The ssm was originally necessary due to a "PCxT bug".
+	 * But someone decided it needed to be added to the architecture
+	 * and this "feature" went into rev3 of PA-RISC 1.1 Arch Manual.
+	 * It's been carried forward into PA 2.0 Arch as well. :^(
+	 *
+	 * "ssm 0,%r0" is a NOP with side effects (prefetch barrier).
+	 * rsm/ssm prevents the ifetch unit from speculatively fetching
+	 * instructions past this line in the code stream.
+	 * PA 2.0 processor will single step all insn in the same QUAD (4 insn).
+	 */
+	.macro	pcxt_ssm_bug
+	rsm	PSW_SM_I,%r0
+	nop	/* 1 */
+	nop	/* 2 */
+	nop	/* 3 */
+	nop	/* 4 */
+	nop	/* 5 */
+	nop	/* 6 */
+	nop	/* 7 */
+	.endm
+
+#endif /* __ASSEMBLY__ */
+#endif
