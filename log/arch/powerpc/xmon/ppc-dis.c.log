commit d135b9cf600d0161a568fdf4da31098eeb3d2be9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 22 09:51:22 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 76
    
    Based on 1 normalized pattern(s):
    
      gdb gas and the gnu binutils are free software you can redistribute
      them and or modify them under the terms of the gnu general public
      license as published by the free software foundation either version
      2 or at your option any later version gdb gas and the gnu binutils
      are distributed in the hope that they will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this file see the file copying if not
      write to the free software foundation 51 franklin street fifth floor
      boston ma 02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 2 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190520075210.666183009@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/xmon/ppc-dis.c b/arch/powerpc/xmon/ppc-dis.c
index 27f1e6415036..75fa98221d48 100644
--- a/arch/powerpc/xmon/ppc-dis.c
+++ b/arch/powerpc/xmon/ppc-dis.c
@@ -1,22 +1,11 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /* ppc-dis.c -- Disassemble PowerPC instructions
    Copyright (C) 1994-2016 Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Support
 
 This file is part of GDB, GAS, and the GNU binutils.
 
-GDB, GAS, and the GNU binutils are free software; you can redistribute
-them and/or modify them under the terms of the GNU General Public
-License as published by the Free Software Foundation; either version
-2, or (at your option) any later version.
-
-GDB, GAS, and the GNU binutils are distributed in the hope that they
-will be useful, but WITHOUT ANY WARRANTY; without even the implied
-warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
-the GNU General Public License for more details.
-
-You should have received a copy of the GNU General Public License
-along with this file; see the file COPYING.  If not, write to the Free
-Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
+ */
 
 #include <asm/cputable.h>
 #include <asm/cpu_has_feature.h>

commit e7140639b1de65bba435a6bd772d134901141f86
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Mon Feb 25 22:38:55 2019 -0700

    powerpc/xmon: Fix opcode being uninitialized in print_insn_powerpc
    
    When building with -Wsometimes-uninitialized, Clang warns:
    
      arch/powerpc/xmon/ppc-dis.c:157:7: warning: variable 'opcode' is used
      uninitialized whenever 'if' condition is false
      [-Wsometimes-uninitialized]
        if (cpu_has_feature(CPU_FTRS_POWER9))
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      arch/powerpc/xmon/ppc-dis.c:167:7: note: uninitialized use occurs here
        if (opcode == NULL)
            ^~~~~~
      arch/powerpc/xmon/ppc-dis.c:157:3: note: remove the 'if' if its
      condition is always true
        if (cpu_has_feature(CPU_FTRS_POWER9))
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
      arch/powerpc/xmon/ppc-dis.c:132:38: note: initialize the variable
      'opcode' to silence this warning
        const struct powerpc_opcode *opcode;
                                           ^
                                            = NULL
      1 warning generated.
    
    This warning seems to make no sense on the surface because opcode is set
    to NULL right below this statement. However, there is a comma instead of
    semicolon to end the dialect assignment, meaning that the opcode
    assignment only happens in the if statement. Properly terminate that
    line so that Clang no longer warns.
    
    Fixes: 5b102782c7f4 ("powerpc/xmon: Enable disassembly files (compilation changes)")
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Reviewed-by: Nick Desaulniers <ndesaulniers@google.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/xmon/ppc-dis.c b/arch/powerpc/xmon/ppc-dis.c
index 9deea5ee13f6..27f1e6415036 100644
--- a/arch/powerpc/xmon/ppc-dis.c
+++ b/arch/powerpc/xmon/ppc-dis.c
@@ -158,7 +158,7 @@ int print_insn_powerpc (unsigned long insn, unsigned long memaddr)
     dialect |= (PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_POWER7
 		| PPC_OPCODE_POWER8 | PPC_OPCODE_POWER9 | PPC_OPCODE_HTM
 		| PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2
-		| PPC_OPCODE_VSX | PPC_OPCODE_VSX3),
+		| PPC_OPCODE_VSX | PPC_OPCODE_VSX3);
 
   /* Get the major opcode of the insn.  */
   opcode = NULL;

commit 104d55ae4df928c205268c1eb83b806b53027e13
Author: Mathieu Malaterre <malat@debian.org>
Date:   Tue Dec 26 14:25:47 2017 +0100

    powerpc/xmon: Do not compute/store the major opcode
    
    In commit 5b102782c7f4 ("powerpc/xmon: Enable disassembly files (compilation
    changes)") usage of variable `op` has been removed. Completely remove opcode
    computation since not used anymore.
    
    Fix fatal warning:
    
    arch/powerpc/xmon/ppc-dis.c: In function ‘lookup_powerpc’:
    arch/powerpc/xmon/ppc-dis.c:96:17: error: variable ‘op’ set but not used [-Werror=unused-but-set-variable]
       unsigned long op;
                     ^~
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/xmon/ppc-dis.c b/arch/powerpc/xmon/ppc-dis.c
index 31db8c072acd..9deea5ee13f6 100644
--- a/arch/powerpc/xmon/ppc-dis.c
+++ b/arch/powerpc/xmon/ppc-dis.c
@@ -93,10 +93,6 @@ lookup_powerpc (unsigned long insn, ppc_cpu_t dialect)
 {
   const struct powerpc_opcode *opcode;
   const struct powerpc_opcode *opcode_end;
-  unsigned long op;
-
-  /* Get the major opcode of the instruction.  */
-  op = PPC_OP (insn);
 
   opcode_end = powerpc_opcodes + powerpc_num_opcodes;
   /* Find the first match in the opcode table for this major opcode.  */

commit 5b102782c7f460d88b42d504c78755eeb030894a
Author: Balbir Singh <bsingharora@gmail.com>
Date:   Thu Feb 2 10:33:44 2017 +0530

    powerpc/xmon: Enable disassembly files (compilation changes)
    
    After updating ppc-dis.c, ppc-opc.c and ppc.h the following changes were
    made to enable compilation and working of xmon:
    
      1.  Remove all disassembler_info
      2.  Use xmon's printf/print_address to output data and addresses
          respectively.
      3.  All bfd_* types and casts have been removed.
      4.  Optimizations related to opcd_indices have been removed.
      5.  The dialect is set based on cpu features.
      6.  PPC_OPCODE_CLASSIC is no longer supported in the new
          disassembler.
      7.  VLE opcode parsing and printing has been stripped.
      8.  Coding style conventions used for those routines has
          been retained and it does not match our CodingStyle.
      9.  The highest supported dialect is POWER9.
      10. Defined ATTRIBUTE_UNUSED in ppc-dis.c.
      11. Defined _(x) in ppc-dis.c.
    
    Finally, we remove the dependency on BROKEN so that XMON_DISASSEMBLY can
    be enabled again.
    
    Signed-off-by: Balbir Singh <bsingharora@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/xmon/ppc-dis.c b/arch/powerpc/xmon/ppc-dis.c
index c382d13c88a3..31db8c072acd 100644
--- a/arch/powerpc/xmon/ppc-dis.c
+++ b/arch/powerpc/xmon/ppc-dis.c
@@ -18,418 +18,18 @@ You should have received a copy of the GNU General Public License
 along with this file; see the file COPYING.  If not, write to the Free
 Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
 
-#include "sysdep.h"
-#include <stdio.h>
+#include <asm/cputable.h>
+#include <asm/cpu_has_feature.h>
+#include "nonstdio.h"
+#include "ansidecl.h"
+#include "ppc.h"
 #include "dis-asm.h"
-#include "elf-bfd.h"
-#include "elf/ppc.h"
-#include "opintl.h"
-#include "opcode/ppc.h"
 
 /* This file provides several disassembler functions, all of which use
    the disassembler interface defined in dis-asm.h.  Several functions
    are provided because this file handles disassembly for the PowerPC
    in both big and little endian mode and also for the POWER (RS/6000)
    chip.  */
-static int print_insn_powerpc (bfd_vma, struct disassemble_info *, int,
-			       ppc_cpu_t);
-
-struct dis_private
-{
-  /* Stash the result of parsing disassembler_options here.  */
-  ppc_cpu_t dialect;
-} private;
-
-#define POWERPC_DIALECT(INFO) \
-  (((struct dis_private *) ((INFO)->private_data))->dialect)
-
-struct ppc_mopt {
-  const char *opt;
-  ppc_cpu_t cpu;
-  ppc_cpu_t sticky;
-};
-
-struct ppc_mopt ppc_opts[] = {
-  { "403",     PPC_OPCODE_PPC | PPC_OPCODE_403,
-    0 },
-  { "405",     PPC_OPCODE_PPC | PPC_OPCODE_403 | PPC_OPCODE_405,
-    0 },
-  { "440",     (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_440
-		| PPC_OPCODE_ISEL | PPC_OPCODE_RFMCI),
-    0 },
-  { "464",     (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_440
-		| PPC_OPCODE_ISEL | PPC_OPCODE_RFMCI),
-    0 },
-  { "476",     (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_440
-		| PPC_OPCODE_476 | PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5),
-    0 },
-  { "601",     PPC_OPCODE_PPC | PPC_OPCODE_601,
-    0 },
-  { "603",     PPC_OPCODE_PPC,
-    0 },
-  { "604",     PPC_OPCODE_PPC,
-    0 },
-  { "620",     PPC_OPCODE_PPC | PPC_OPCODE_64,
-    0 },
-  { "7400",    PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC,
-    0 },
-  { "7410",    PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC,
-    0 },
-  { "7450",    PPC_OPCODE_PPC | PPC_OPCODE_7450 | PPC_OPCODE_ALTIVEC,
-    0 },
-  { "7455",    PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC,
-    0 },
-  { "750cl",   PPC_OPCODE_PPC | PPC_OPCODE_750 | PPC_OPCODE_PPCPS
-    , 0 },
-  { "821",     PPC_OPCODE_PPC | PPC_OPCODE_860,
-    0 },
-  { "850",     PPC_OPCODE_PPC | PPC_OPCODE_860,
-    0 },
-  { "860",     PPC_OPCODE_PPC | PPC_OPCODE_860,
-    0 },
-  { "a2",      (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_POWER4
-		| PPC_OPCODE_POWER5 | PPC_OPCODE_CACHELCK | PPC_OPCODE_64
-		| PPC_OPCODE_A2),
-    0 },
-  { "altivec", PPC_OPCODE_PPC,
-    PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2 },
-  { "any",     0,
-    PPC_OPCODE_ANY },
-  { "booke",   PPC_OPCODE_PPC | PPC_OPCODE_BOOKE,
-    0 },
-  { "booke32", PPC_OPCODE_PPC | PPC_OPCODE_BOOKE,
-    0 },
-  { "cell",    (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
-		| PPC_OPCODE_CELL | PPC_OPCODE_ALTIVEC),
-    0 },
-  { "com",     PPC_OPCODE_COMMON,
-    0 },
-  { "e200z4",  (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE| PPC_OPCODE_SPE
-		| PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
-		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
-		| PPC_OPCODE_E500 | PPC_OPCODE_E200Z4),
-    PPC_OPCODE_VLE },
-  { "e300",    PPC_OPCODE_PPC | PPC_OPCODE_E300,
-    0 },
-  { "e500",    (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
-		| PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
-		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
-		| PPC_OPCODE_E500),
-    0 },
-  { "e500mc",  (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_ISEL
-		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
-		| PPC_OPCODE_E500MC),
-    0 },
-  { "e500mc64",  (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_ISEL
-		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
-		| PPC_OPCODE_E500MC | PPC_OPCODE_64 | PPC_OPCODE_POWER5
-		| PPC_OPCODE_POWER6 | PPC_OPCODE_POWER7),
-    0 },
-  { "e5500",    (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_ISEL
-		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
-		| PPC_OPCODE_E500MC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
-		| PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
-		| PPC_OPCODE_POWER7),
-    0 },
-  { "e6500",   (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_ISEL
-		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
-		| PPC_OPCODE_E500MC | PPC_OPCODE_64 | PPC_OPCODE_ALTIVEC
-		| PPC_OPCODE_ALTIVEC2 | PPC_OPCODE_E6500 | PPC_OPCODE_POWER4
-		| PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_POWER7),
-    0 },
-  { "e500x2",  (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
-		| PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
-		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
-		| PPC_OPCODE_E500),
-    0 },
-  { "efs",     PPC_OPCODE_PPC | PPC_OPCODE_EFS,
-    0 },
-  { "power4",  PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4,
-    0 },
-  { "power5",  (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
-		| PPC_OPCODE_POWER5),
-    0 },
-  { "power6",  (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
-		| PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_ALTIVEC),
-    0 },
-  { "power7",  (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
-		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
-		| PPC_OPCODE_POWER7 | PPC_OPCODE_ALTIVEC | PPC_OPCODE_VSX),
-    0 },
-  { "power8",  (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
-		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
-		| PPC_OPCODE_POWER7 | PPC_OPCODE_POWER8 | PPC_OPCODE_HTM
-		| PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2 | PPC_OPCODE_VSX),
-    0 },
-  { "power9",  (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
-		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
-		| PPC_OPCODE_POWER7 | PPC_OPCODE_POWER8 | PPC_OPCODE_POWER9
-		| PPC_OPCODE_HTM | PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2
-		| PPC_OPCODE_VSX | PPC_OPCODE_VSX3 ),
-    0 },
-  { "ppc",     PPC_OPCODE_PPC,
-    0 },
-  { "ppc32",   PPC_OPCODE_PPC,
-    0 },
-  { "ppc64",   PPC_OPCODE_PPC | PPC_OPCODE_64,
-    0 },
-  { "ppc64bridge", PPC_OPCODE_PPC | PPC_OPCODE_64_BRIDGE,
-    0 },
-  { "ppcps",   PPC_OPCODE_PPC | PPC_OPCODE_PPCPS,
-    0 },
-  { "pwr",     PPC_OPCODE_POWER,
-    0 },
-  { "pwr2",    PPC_OPCODE_POWER | PPC_OPCODE_POWER2,
-    0 },
-  { "pwr4",    PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4,
-    0 },
-  { "pwr5",    (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
-		| PPC_OPCODE_POWER5),
-    0 },
-  { "pwr5x",   (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
-		| PPC_OPCODE_POWER5),
-    0 },
-  { "pwr6",    (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
-		| PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_ALTIVEC),
-    0 },
-  { "pwr7",    (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
-		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
-		| PPC_OPCODE_POWER7 | PPC_OPCODE_ALTIVEC | PPC_OPCODE_VSX),
-    0 },
-  { "pwr8",    (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
-		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
-		| PPC_OPCODE_POWER7 | PPC_OPCODE_POWER8 | PPC_OPCODE_HTM
-		| PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2 | PPC_OPCODE_VSX),
-    0 },
-  { "pwr9",    (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
-		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
-		| PPC_OPCODE_POWER7 | PPC_OPCODE_POWER8 | PPC_OPCODE_POWER9
-		| PPC_OPCODE_HTM | PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2
-		| PPC_OPCODE_VSX | PPC_OPCODE_VSX3 ),
-    0 },
-  { "pwrx",    PPC_OPCODE_POWER | PPC_OPCODE_POWER2,
-    0 },
-  { "spe",     PPC_OPCODE_PPC | PPC_OPCODE_EFS,
-    PPC_OPCODE_SPE },
-  { "titan",   (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_PMR
-		| PPC_OPCODE_RFMCI | PPC_OPCODE_TITAN),
-    0 },
-  { "vle",     (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE| PPC_OPCODE_SPE
-		| PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
-		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
-		| PPC_OPCODE_E500),
-    PPC_OPCODE_VLE },
-  { "vsx",     PPC_OPCODE_PPC,
-    PPC_OPCODE_VSX | PPC_OPCODE_VSX3 },
-  { "htm",     PPC_OPCODE_PPC,
-    PPC_OPCODE_HTM },
-};
-
-/* Switch between Booke and VLE dialects for interlinked dumps.  */
-static ppc_cpu_t
-get_powerpc_dialect (struct disassemble_info *info)
-{
-  ppc_cpu_t dialect = 0;
-
-  dialect = POWERPC_DIALECT (info);
-
-  /* Disassemble according to the section headers flags for VLE-mode.  */
-  if (dialect & PPC_OPCODE_VLE
-      && info->section->owner != NULL
-      && bfd_get_flavour (info->section->owner) == bfd_target_elf_flavour
-      && elf_object_id (info->section->owner) == PPC32_ELF_DATA
-      && (elf_section_flags (info->section) & SHF_PPC_VLE) != 0)
-    return dialect;
-  else
-    return dialect & ~ PPC_OPCODE_VLE;
-}
-
-/* Handle -m and -M options that set cpu type, and .machine arg.  */
-
-ppc_cpu_t
-ppc_parse_cpu (ppc_cpu_t ppc_cpu, ppc_cpu_t *sticky, const char *arg)
-{
-  unsigned int i;
-
-  for (i = 0; i < sizeof (ppc_opts) / sizeof (ppc_opts[0]); i++)
-    if (strcmp (ppc_opts[i].opt, arg) == 0)
-      {
-	if (ppc_opts[i].sticky)
-	  {
-	    *sticky |= ppc_opts[i].sticky;
-	    if ((ppc_cpu & ~*sticky) != 0)
-	      break;
-	  }
-	ppc_cpu = ppc_opts[i].cpu;
-	break;
-      }
-  if (i >= sizeof (ppc_opts) / sizeof (ppc_opts[0]))
-    return 0;
-
-  ppc_cpu |= *sticky;
-  return ppc_cpu;
-}
-
-/* Determine which set of machines to disassemble for.  */
-
-static void
-powerpc_init_dialect (struct disassemble_info *info)
-{
-  ppc_cpu_t dialect = 0;
-  ppc_cpu_t sticky = 0;
-  char *arg;
-  struct dis_private *priv = calloc (sizeof (*priv), 1);
-
-  if (priv == NULL)
-    priv = &private;
-
-  switch (info->mach)
-    {
-    case bfd_mach_ppc_403:
-    case bfd_mach_ppc_403gc:
-      dialect = ppc_parse_cpu (dialect, &sticky, "403");
-      break;
-    case bfd_mach_ppc_405:
-      dialect = ppc_parse_cpu (dialect, &sticky, "405");
-      break;
-    case bfd_mach_ppc_601:
-      dialect = ppc_parse_cpu (dialect, &sticky, "601");
-      break;
-    case bfd_mach_ppc_a35:
-    case bfd_mach_ppc_rs64ii:
-    case bfd_mach_ppc_rs64iii:
-      dialect = ppc_parse_cpu (dialect, &sticky, "pwr2") | PPC_OPCODE_64;
-      break;
-    case bfd_mach_ppc_e500:
-      dialect = ppc_parse_cpu (dialect, &sticky, "e500");
-      break;
-    case bfd_mach_ppc_e500mc:
-      dialect = ppc_parse_cpu (dialect, &sticky, "e500mc");
-      break;
-    case bfd_mach_ppc_e500mc64:
-      dialect = ppc_parse_cpu (dialect, &sticky, "e500mc64");
-      break;
-    case bfd_mach_ppc_e5500:
-      dialect = ppc_parse_cpu (dialect, &sticky, "e5500");
-      break;
-    case bfd_mach_ppc_e6500:
-      dialect = ppc_parse_cpu (dialect, &sticky, "e6500");
-      break;
-    case bfd_mach_ppc_titan:
-      dialect = ppc_parse_cpu (dialect, &sticky, "titan");
-      break;
-    case bfd_mach_ppc_vle:
-      dialect = ppc_parse_cpu (dialect, &sticky, "vle");
-      break;
-    default:
-      dialect = ppc_parse_cpu (dialect, &sticky, "power9") | PPC_OPCODE_ANY;
-    }
-
-  arg = info->disassembler_options;
-  while (arg != NULL)
-    {
-      ppc_cpu_t new_cpu = 0;
-      char *end = strchr (arg, ',');
-
-      if (end != NULL)
-	*end = 0;
-
-      if ((new_cpu = ppc_parse_cpu (dialect, &sticky, arg)) != 0)
-	dialect = new_cpu;
-      else if (strcmp (arg, "32") == 0)
-	dialect &= ~(ppc_cpu_t) PPC_OPCODE_64;
-      else if (strcmp (arg, "64") == 0)
-	dialect |= PPC_OPCODE_64;
-      else
-	fprintf (stderr, _("warning: ignoring unknown -M%s option\n"), arg);
-
-      if (end != NULL)
-	*end++ = ',';
-      arg = end;
-    }
-
-  info->private_data = priv;
-  POWERPC_DIALECT(info) = dialect;
-}
-
-#define PPC_OPCD_SEGS 64
-static unsigned short powerpc_opcd_indices[PPC_OPCD_SEGS+1];
-#define VLE_OPCD_SEGS 32
-static unsigned short vle_opcd_indices[VLE_OPCD_SEGS+1];
-
-/* Calculate opcode table indices to speed up disassembly,
-   and init dialect.  */
-
-void
-disassemble_init_powerpc (struct disassemble_info *info)
-{
-  int i;
-  unsigned short last;
-
-  if (powerpc_opcd_indices[PPC_OPCD_SEGS] == 0)
-    {
-
-      i = powerpc_num_opcodes;
-      while (--i >= 0)
-        {
-          unsigned op = PPC_OP (powerpc_opcodes[i].opcode);
-
-          powerpc_opcd_indices[op] = i;
-        }
-
-      last = powerpc_num_opcodes;
-      for (i = PPC_OPCD_SEGS; i > 0; --i)
-        {
-          if (powerpc_opcd_indices[i] == 0)
-	    powerpc_opcd_indices[i] = last;
-          last = powerpc_opcd_indices[i];
-        }
-
-      i = vle_num_opcodes;
-      while (--i >= 0)
-        {
-          unsigned op = VLE_OP (vle_opcodes[i].opcode, vle_opcodes[i].mask);
-          unsigned seg = VLE_OP_TO_SEG (op);
-
-          vle_opcd_indices[seg] = i;
-        }
-
-      last = vle_num_opcodes;
-      for (i = VLE_OPCD_SEGS; i > 0; --i)
-        {
-          if (vle_opcd_indices[i] == 0)
-	    vle_opcd_indices[i] = last;
-          last = vle_opcd_indices[i];
-        }
-    }
-
-  if (info->arch == bfd_arch_powerpc)
-    powerpc_init_dialect (info);
-}
-
-/* Print a big endian PowerPC instruction.  */
-
-int
-print_insn_big_powerpc (bfd_vma memaddr, struct disassemble_info *info)
-{
-  return print_insn_powerpc (memaddr, info, 1, get_powerpc_dialect (info));
-}
-
-/* Print a little endian PowerPC instruction.  */
-
-int
-print_insn_little_powerpc (bfd_vma memaddr, struct disassemble_info *info)
-{
-  return print_insn_powerpc (memaddr, info, 0, get_powerpc_dialect (info));
-}
-
-/* Print a POWER (RS/6000) instruction.  */
-
-int
-print_insn_rs6000 (bfd_vma memaddr, struct disassemble_info *info)
-{
-  return print_insn_powerpc (memaddr, info, 1, PPC_OPCODE_POWER);
-}
 
 /* Extract the operand value from the PowerPC or POWER instruction.  */
 
@@ -498,11 +98,9 @@ lookup_powerpc (unsigned long insn, ppc_cpu_t dialect)
   /* Get the major opcode of the instruction.  */
   op = PPC_OP (insn);
 
+  opcode_end = powerpc_opcodes + powerpc_num_opcodes;
   /* Find the first match in the opcode table for this major opcode.  */
-  opcode_end = powerpc_opcodes + powerpc_opcd_indices[op + 1];
-  for (opcode = powerpc_opcodes + powerpc_opcd_indices[op];
-       opcode < opcode_end;
-       ++opcode)
+  for (opcode = powerpc_opcodes; opcode < opcode_end; ++opcode)
     {
       const unsigned char *opindex;
       const struct powerpc_operand *operand;
@@ -531,110 +129,45 @@ lookup_powerpc (unsigned long insn, ppc_cpu_t dialect)
   return NULL;
 }
 
-/* Find a match for INSN in the VLE opcode table.  */
+/* Print a PowerPC or POWER instruction.  */
 
-static const struct powerpc_opcode *
-lookup_vle (unsigned long insn)
+int print_insn_powerpc (unsigned long insn, unsigned long memaddr)
 {
   const struct powerpc_opcode *opcode;
-  const struct powerpc_opcode *opcode_end;
-  unsigned op, seg;
-
-  op = PPC_OP (insn);
-  if (op >= 0x20 && op <= 0x37)
-    {
-      /* This insn has a 4-bit opcode.  */
-      op &= 0x3c;
-    }
-  seg = VLE_OP_TO_SEG (op);
-
-  /* Find the first match in the opcode table for this major opcode.  */
-  opcode_end = vle_opcodes + vle_opcd_indices[seg + 1];
-  for (opcode = vle_opcodes + vle_opcd_indices[seg];
-       opcode < opcode_end;
-       ++opcode)
-    {
-      unsigned long table_opcd = opcode->opcode;
-      unsigned long table_mask = opcode->mask;
-      bfd_boolean table_op_is_short = PPC_OP_SE_VLE(table_mask);
-      unsigned long insn2;
-      const unsigned char *opindex;
-      const struct powerpc_operand *operand;
-      int invalid;
-
-      insn2 = insn;
-      if (table_op_is_short)
-	insn2 >>= 16;
-      if ((insn2 & table_mask) != table_opcd)
-	continue;
+  bool insn_is_short;
+  ppc_cpu_t dialect;
 
-      /* Check validity of operands.  */
-      invalid = 0;
-      for (opindex = opcode->operands; *opindex != 0; ++opindex)
-	{
-	  operand = powerpc_operands + *opindex;
-	  if (operand->extract)
-	    (*operand->extract) (insn, (ppc_cpu_t)0, &invalid);
-	}
-      if (invalid)
-	continue;
+  dialect = PPC_OPCODE_PPC | PPC_OPCODE_COMMON
+            | PPC_OPCODE_64 | PPC_OPCODE_POWER4 | PPC_OPCODE_ALTIVEC;
 
-      return opcode;
-    }
+  if (cpu_has_feature(CPU_FTRS_POWER5))
+    dialect |= PPC_OPCODE_POWER5;
 
-  return NULL;
-}
+  if (cpu_has_feature(CPU_FTRS_CELL))
+    dialect |= (PPC_OPCODE_CELL | PPC_OPCODE_ALTIVEC);
 
-/* Print a PowerPC or POWER instruction.  */
+  if (cpu_has_feature(CPU_FTRS_POWER6))
+    dialect |= (PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_ALTIVEC);
 
-static int
-print_insn_powerpc (bfd_vma memaddr,
-		    struct disassemble_info *info,
-		    int bigendian,
-		    ppc_cpu_t dialect)
-{
-  bfd_byte buffer[4];
-  int status;
-  unsigned long insn;
-  const struct powerpc_opcode *opcode;
-  bfd_boolean insn_is_short;
+  if (cpu_has_feature(CPU_FTRS_POWER7))
+    dialect |= (PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_POWER7
+                | PPC_OPCODE_ALTIVEC | PPC_OPCODE_VSX);
 
-  status = (*info->read_memory_func) (memaddr, buffer, 4, info);
-  if (status != 0)
-    {
-      /* The final instruction may be a 2-byte VLE insn.  */
-      if ((dialect & PPC_OPCODE_VLE) != 0)
-        {
-          /* Clear buffer so unused bytes will not have garbage in them.  */
-          buffer[0] = buffer[1] = buffer[2] = buffer[3] = 0;
-          status = (*info->read_memory_func) (memaddr, buffer, 2, info);
-          if (status != 0)
-            {
-              (*info->memory_error_func) (status, memaddr, info);
-              return -1;
-            }
-        }
-      else
-        {
-          (*info->memory_error_func) (status, memaddr, info);
-          return -1;
-        }
-    }
+  if (cpu_has_feature(CPU_FTRS_POWER8))
+    dialect |= (PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_POWER7
+		| PPC_OPCODE_POWER8 | PPC_OPCODE_HTM
+		| PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2 | PPC_OPCODE_VSX);
 
-  if (bigendian)
-    insn = bfd_getb32 (buffer);
-  else
-    insn = bfd_getl32 (buffer);
+  if (cpu_has_feature(CPU_FTRS_POWER9))
+    dialect |= (PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_POWER7
+		| PPC_OPCODE_POWER8 | PPC_OPCODE_POWER9 | PPC_OPCODE_HTM
+		| PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2
+		| PPC_OPCODE_VSX | PPC_OPCODE_VSX3),
 
   /* Get the major opcode of the insn.  */
   opcode = NULL;
-  insn_is_short = FALSE;
-  if ((dialect & PPC_OPCODE_VLE) != 0)
-    {
-      opcode = lookup_vle (insn);
-      if (opcode != NULL)
-	insn_is_short = PPC_OP_SE_VLE(opcode->mask);
-    }
+  insn_is_short = false;
+
   if (opcode == NULL)
     opcode = lookup_powerpc (insn, dialect);
   if (opcode == NULL && (dialect & PPC_OPCODE_ANY) != 0)
@@ -649,9 +182,9 @@ print_insn_powerpc (bfd_vma memaddr,
       int skip_optional;
 
       if (opcode->operands[0] != 0)
-	(*info->fprintf_func) (info->stream, "%-7s ", opcode->name);
+	printf("%-7s ", opcode->name);
       else
-	(*info->fprintf_func) (info->stream, "%s", opcode->name);
+	printf("%s", opcode->name);
 
       if (insn_is_short)
         /* The operands will be fetched out of the 16-bit instruction.  */
@@ -688,34 +221,34 @@ print_insn_powerpc (bfd_vma memaddr,
 
 	  if (need_comma)
 	    {
-	      (*info->fprintf_func) (info->stream, ",");
+	      printf(",");
 	      need_comma = 0;
 	    }
 
 	  /* Print the operand as directed by the flags.  */
 	  if ((operand->flags & PPC_OPERAND_GPR) != 0
 	      || ((operand->flags & PPC_OPERAND_GPR_0) != 0 && value != 0))
-	    (*info->fprintf_func) (info->stream, "r%ld", value);
+	    printf("r%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_FPR) != 0)
-	    (*info->fprintf_func) (info->stream, "f%ld", value);
+	    printf("f%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_VR) != 0)
-	    (*info->fprintf_func) (info->stream, "v%ld", value);
+	    printf("v%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_VSR) != 0)
-	    (*info->fprintf_func) (info->stream, "vs%ld", value);
+	    printf("vs%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0)
-	    (*info->print_address_func) (memaddr + value, info);
+	    print_address(memaddr + value);
 	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
-	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
+	    print_address(value & 0xffffffff);
 	  else if ((operand->flags & PPC_OPERAND_FSL) != 0)
-	    (*info->fprintf_func) (info->stream, "fsl%ld", value);
+	    printf("fsl%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_FCR) != 0)
-	    (*info->fprintf_func) (info->stream, "fcr%ld", value);
+	    printf("fcr%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_UDI) != 0)
-	    (*info->fprintf_func) (info->stream, "%ld", value);
+	    printf("%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_CR_REG) != 0
 		   && (((dialect & PPC_OPCODE_PPC) != 0)
 		       || ((dialect & PPC_OPCODE_VLE) != 0)))
-	    (*info->fprintf_func) (info->stream, "cr%ld", value);
+	    printf("cr%ld", value);
 	  else if (((operand->flags & PPC_OPERAND_CR_BIT) != 0)
 		   && (((dialect & PPC_OPCODE_PPC) != 0)
 		       || ((dialect & PPC_OPCODE_VLE) != 0)))
@@ -726,16 +259,16 @@ print_insn_powerpc (bfd_vma memaddr,
 
 	      cr = value >> 2;
 	      if (cr != 0)
-		(*info->fprintf_func) (info->stream, "4*cr%d+", cr);
+		printf("4*cr%d+", cr);
 	      cc = value & 3;
-	      (*info->fprintf_func) (info->stream, "%s", cbnames[cc]);
+	      printf("%s", cbnames[cc]);
 	    }
 	  else
-	    (*info->fprintf_func) (info->stream, "%d", (int) value);
+	    printf("%d", (int) value);
 
 	  if (need_paren)
 	    {
-	      (*info->fprintf_func) (info->stream, ")");
+	      printf(")");
 	      need_paren = 0;
 	    }
 
@@ -743,7 +276,7 @@ print_insn_powerpc (bfd_vma memaddr,
 	    need_comma = 1;
 	  else
 	    {
-	      (*info->fprintf_func) (info->stream, "(");
+	      printf("(");
 	      need_paren = 1;
 	    }
 	}
@@ -761,28 +294,7 @@ print_insn_powerpc (bfd_vma memaddr,
     }
 
   /* We could not find a match.  */
-  (*info->fprintf_func) (info->stream, ".long 0x%lx", insn);
+  printf(".long 0x%lx", insn);
 
   return 4;
 }
-
-void
-print_ppc_disassembler_options (FILE *stream)
-{
-  unsigned int i, col;
-
-  fprintf (stream, _("\n\
-The following PPC specific disassembler options are supported for use with\n\
-the -M switch:\n"));
-
-  for (col = 0, i = 0; i < sizeof (ppc_opts) / sizeof (ppc_opts[0]); i++)
-    {
-      col += fprintf (stream, " %s,", ppc_opts[i].opt);
-      if (col > 66)
-	{
-	  fprintf (stream, "\n");
-	  col = 0;
-	}
-    }
-  fprintf (stream, " 32, 64\n");
-}

commit 08d96e0b127e07c3b90e10f1939caf70b456793e
Author: Balbir Singh <bsingharora@gmail.com>
Date:   Thu Feb 2 10:33:43 2017 +0530

    powerpc/xmon: Apply binutils changes to upgrade disassembly
    
    The following commit-ids from the binutils project were applied on the
    xmon branch and relicensed with the permission of the authors under
    GPLv2 for the following files:
    
      ppc-opc.c
      ppc-dis.c
      ppc.h
    
    Working off of binutils commit 65b650b4c746 we have now moved up to
    binutils commit a5721ba270dd.
    
    Some commit logs have been taken verbatim, some are summarized for ease
    of understanding.
    
    Here is a summary of the commits:
    
     33e8d5ac613d PPC7450 New.  (powerpc_opcodes): Use it in dcba.
     c3d65c1ced61 New opcodes and mask
     8dbcd839b1bb Instruction Sorting
     91eb7075e370 (powerpc_opcodes): Fix the first two operands of dquaiq.
     548b1dcfcbab ppc-opc.c (powerpc_opcodes): Remove the dcffix and dcffix.
     930bb4cfae30 Support optional L form mtmsr.
     de866fccd87d (powerpc_opcodes): Order and format.
     19a6653ce8c6 ppc e500mc support
     fa452fa6833c (ppc_cpu_t): New typedef.
     c8187e1509b2 (parse_cpu): Handle -m464.
     081ba1b3c08b Define. (PPC_OPERAND_FSL, PPC_OPERAND_FCR, PPC_OPERAND_UDI)
     9b4e57660d38 Rename altivec_or_spe to retain_flags. Handle -mvsx and -mpower7.
     899d85beadd0 (powerpc_opcodes): Enable rfci, mfpmr, mtpmr for e300.
     e1c93c699b7d (extract_sprg): Correct operand range check.
     2f3bb96af796 (powerpc_init_dialect): Do not set PPC_OPCODE_BOOKE
     1cb0a7674666 (ppc_setup_opcodes): Remove PPC_OPCODE_NOPOWER4 test
     21169fcfadfa (print_insn_powerpc): Skip insn if it is deprecated
     80890a619b85 ("dcbt", "dcbtst")
     0e55be1624c2 ("lfdepx", "stfdepx")
     066be9f7bd8e (parse_cpu): Extend -mpower7 to accept power7 and isel instructions.
     c72ab5f2c55d (powerpc_opcodes): Reorder the opcode table so that instructions
     69fe9ce501f5 (ppc_parse_cpu): New function.    (powerpc_init_dialect)
     e401b04ca7cd (powerpc_opcodes) <"dcbzl">: Merge the POWER4 and E500MC entries.
     70dc4e324b9a (powerpc_init_dialect): Do not choose a default dialect due to -many/-Many.
     858d7a6db20b (powerpc_opcodes) <"tlbilxlpid", "tlbilxpid", "tlbilxva", "tlbilx"
     bdc7fcfe59f1 (powerpc_macros <extrdi>): Allow n+b of 64
     e0d602ecffb0 (md_show_usage): Document -mpcca2
     b961e85b6ebe (ppc_cpu_t): Typedef to uint64_t
     8765b5569284 (powerpc_opcodes): Remove support for the the "lxsdux", "lxvd2ux"
     634b50f2a623 Rename "ppca2" to "a2"
     9fe54b1ca1c0 (md_show_usage): Document -m476
     0dc9305793c8 Add bfd_mach_ppc_e500mc64
     ce3d2015b21b Define. bfd/      * archures.c (bfd_mach_ppc_titan)
     cdc51b0748c4 Add -mpwr4, -mpwr5, -mpwr5x, -mpwr6 and -mpwr7
     63d0fa4e9e57 Add PPC_OPCODE_E500MC for "e500mc64"
     cee62821d472 New Define. ("dccci"): Enable for PPCA2
     85d4ac0b3c0b Correct wclr encoding.
     51b5d4a8c5e5 (powerpc_opcodes): Enable divdeu, devweu, divde, divwe, divdeuo
     e01d869a3be2 (md_assemble): Emit APUinfo section for PPC_OPCODE_E500
     09a8ad8d8f56 (powerpc_opcodes): Revert deprecation of mfocrf, mtcrf and mtocrf on EFS.
     f2bae120dcef (PPC_OPCODE_COMMON): Expand comment.
     81a0b7e2ae09 (PPCPWR2): Add PPC_OPCODE_COMMON. (powerpc_opcodes): Add "subc"
     bdc70b4a03fd (PPC_OPCODE_32, PPC_OPCODE_BOOKE64, PPC_OPCODE_CLASSIC)
     7102e95e4943 (ppc_set_cpu): Cast PPC_OPCODE_xxx to ppc_cpu_t before inverting
     f383de6633cb (powerpc_opcodes) [lswx,lswi,stswx,stswi]: Deprecate on E500 and E500MC
     6b069ee70de3 Remove PPC_OPCODE_PPCPS
     2f7f77101279 (powerpc_opcodes): Enable icswx for POWER7
     989993d80a97 (insert_nbi, insert_rbx, FRAp, FRBp, FRSp, FRTp, NBI, RAX, RBX)
     a08fc94222d1 <drrndq, drrndq., dtstexq, dctqpq, dctqpq., dctfixq, dctfixq.
     8ebac3aae962 (ISA_V2): Define and use for relevant BO field tests
     aea77599d0db Add PPC_OPCODE_ALTIVEC2, PPC_OPCODE_E6500, PPC_OPCODE_TMR
     b240011aba98 (disassemble_init_for_target): Handle ppc init.
     d668828207c2 (powerpc_opcd_indices): Bump array size
     b9c361e0ad33 Add support for PowerPC VLE.
     e1dad58d73dc (has_tls_reloc, has_tls_get_addr_call, has_vle_insns, is_ppc_vle)
     df7b86aa4cb6 Add check that sysdep.h has been included before
     98c76446ea6b (extract_sprg): Use ALLOW8_SPRG to include VLE.
     a4ebc835cbcb (powerpc_macros): Add entries for e_extlwi to e_clrlslwi
     94caa966375d (has_vle_insns, is_ppc_vle): Delete
     c7a8dbf91f37 Change RA to RA0
     d908c8af5a1d Add necessary casts for printing integer values
     03edbe3bfb93 Add/remove PPCVLE for some 32-bit insns
     9f6a6cc022e1 <xnop, yield, mdoio, mdoom>: New extended mnemonics
     588925d06545 <RSQ, RTQ>: Use PPC_OPERAND_GPR
     8baf7b78b5d9 <"lswx">: Use RAX for the second and RBX for the third operand
     e67ed0e885d6 Changed opcode for vabsdub, vabsduh, vabsduw, mviwsplt
     fb048c26f19f (UIMM4, UIMM3, UIMM2, VXVA_MASK, VXVB_MASK, VXVAVB_MASK, VXVDVA_MASK
     382c72e90441 (VXASHB_MASK): New define
     c7a5aa9c64fc (ppc_opts) <altivec>: Use PPC_OPCODE_ALTIVEC2
     ab4437c3224f <vcfpsxws>: Fix opcode spelling
     62082a42b9cd "lfdp" and "stfdp" use DS offset.
     776fc41826bb (ppc_parse_cpu): Update prototype
     943d398f4c52 (insert_sci8, extract_sci8): Rewrite.
     5817ffd1f81c New define (PPC_OPCODE_HTM/POWER8)
     9f0682fe89d9 (extract_vlesi): Properly sign extend
     c0637f3af686 (powerpc_init_dialect): Set default dialect to power8.
     58ae08f29af8 (powerpc_opcodes): Add tdui, twui, tdu, twu, tui, tu
     4f6ffcd38d90 (powerpc_init_dialect): Use ppc_parse_cpu() to set dialect
     4b95cf5c0c75 Update copyright years
     a47622ac1bad Allow both signed and unsigned fields in PowerPC cmpli insn
     12e87fac5c76 ppc: enable msgclr and msgsnd on Power8
     8514e4db84cc Don't deprecate powerpc mftb insn
     db76a70026ab Power4 should treat mftb as extended mfspr mnemonic
     b90efa5b79ac ChangeLog rotatation and copyright year update
     c4e676f19656 powerpc: Add slbfee. instruction
     27c49e9a8fc0 powerpc: Only initialise opcode indices once
     4fff86c517ab DCBT_EO): New define
     4bc0608a8b69 Fix some PPC assembler errors
     dc302c00611b Add hwsync extended mnemonic
     99a2c5612124 Remove unused MTMSRD_L macro and re-add accidentally deleted comment
     11a0cf2ec0ed Allow for optional operands with non-zero default values
     7b9341139a69 PPC sync instruction accepts invalid and incompatible operands
     ef5a96d564a2 Remove ppc860, ppc750cl, ppc7450 insns from common ppc
     43e65147c07b Remove trailing spaces in opcodes
     6dca4fd141fd Add dscr and ctrl SPR mnemonics
     b6518b387185 Fix compile time warnings generated when compiling with clang
     36f7a9411dcd Patches for illegal ppc 500 instructions
     a680de9a980e Add assembler, disassembler and linker support for power9
     dd2887fc3de4 Reorder some power9 insns
     b817670b52b7 Enable 2 operand form of powerpc mfcr with -many
     6f2750feaf28 Copyright update for binutils
     afa8d4054b8e Delete opcodes that have been removed from ISA 3.0
     1178da445ad5 Accept valid one byte signed and unsigned values for the IMM8 operand
     e43de63c8fd1 Fix powerpc subis range
     514e58b72633 Correct "Fix powerpc subis range"
     19dfcc89e8d9 Add support for new POWER ISA 3.0 instructions
     1fe0971e41a4 add more extern C
     026122a67044 Re-add support for lbarx, lharx, stbcx. and sthcx. insns back to the E6500 cpu
     14b57c7c6a53 PowerPC VLE
     6fd3a02da554 Add support for yet some more new ISA 3.0 instructions
     dfdaec14b0db Fix some PowerPC VLE BFD issues and add some PowerPC VLE instructions
     fd486b633e87 Modify POWER9 support to match final ISA 3.0 documentation
     a5721ba270dd Disallow 3-operand cmp[l][i] for ppc64
    
    This updates the disassembly capabilities to add support for newer
    processors.
    
    Signed-off-by: Balbir Singh <bsingharora@gmail.com>
    [mpe: Reformat commit list for brevity]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/xmon/ppc-dis.c b/arch/powerpc/xmon/ppc-dis.c
index 2545a36f21a5..c382d13c88a3 100644
--- a/arch/powerpc/xmon/ppc-dis.c
+++ b/arch/powerpc/xmon/ppc-dis.c
@@ -1,6 +1,5 @@
 /* ppc-dis.c -- Disassemble PowerPC instructions
-   Copyright 1994, 1995, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
-   Free Software Foundation, Inc.
+   Copyright (C) 1994-2016 Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Support
 
 This file is part of GDB, GAS, and the GNU binutils.
@@ -19,9 +18,12 @@ You should have received a copy of the GNU General Public License
 along with this file; see the file COPYING.  If not, write to the Free
 Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
 
-#include <stdio.h>
 #include "sysdep.h"
+#include <stdio.h>
 #include "dis-asm.h"
+#include "elf-bfd.h"
+#include "elf/ppc.h"
+#include "opintl.h"
 #include "opcode/ppc.h"
 
 /* This file provides several disassembler functions, all of which use
@@ -29,76 +31,380 @@ Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, US
    are provided because this file handles disassembly for the PowerPC
    in both big and little endian mode and also for the POWER (RS/6000)
    chip.  */
+static int print_insn_powerpc (bfd_vma, struct disassemble_info *, int,
+			       ppc_cpu_t);
 
-static int print_insn_powerpc (bfd_vma, struct disassemble_info *, int, int);
+struct dis_private
+{
+  /* Stash the result of parsing disassembler_options here.  */
+  ppc_cpu_t dialect;
+} private;
+
+#define POWERPC_DIALECT(INFO) \
+  (((struct dis_private *) ((INFO)->private_data))->dialect)
+
+struct ppc_mopt {
+  const char *opt;
+  ppc_cpu_t cpu;
+  ppc_cpu_t sticky;
+};
+
+struct ppc_mopt ppc_opts[] = {
+  { "403",     PPC_OPCODE_PPC | PPC_OPCODE_403,
+    0 },
+  { "405",     PPC_OPCODE_PPC | PPC_OPCODE_403 | PPC_OPCODE_405,
+    0 },
+  { "440",     (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_440
+		| PPC_OPCODE_ISEL | PPC_OPCODE_RFMCI),
+    0 },
+  { "464",     (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_440
+		| PPC_OPCODE_ISEL | PPC_OPCODE_RFMCI),
+    0 },
+  { "476",     (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_440
+		| PPC_OPCODE_476 | PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5),
+    0 },
+  { "601",     PPC_OPCODE_PPC | PPC_OPCODE_601,
+    0 },
+  { "603",     PPC_OPCODE_PPC,
+    0 },
+  { "604",     PPC_OPCODE_PPC,
+    0 },
+  { "620",     PPC_OPCODE_PPC | PPC_OPCODE_64,
+    0 },
+  { "7400",    PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC,
+    0 },
+  { "7410",    PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC,
+    0 },
+  { "7450",    PPC_OPCODE_PPC | PPC_OPCODE_7450 | PPC_OPCODE_ALTIVEC,
+    0 },
+  { "7455",    PPC_OPCODE_PPC | PPC_OPCODE_ALTIVEC,
+    0 },
+  { "750cl",   PPC_OPCODE_PPC | PPC_OPCODE_750 | PPC_OPCODE_PPCPS
+    , 0 },
+  { "821",     PPC_OPCODE_PPC | PPC_OPCODE_860,
+    0 },
+  { "850",     PPC_OPCODE_PPC | PPC_OPCODE_860,
+    0 },
+  { "860",     PPC_OPCODE_PPC | PPC_OPCODE_860,
+    0 },
+  { "a2",      (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_POWER4
+		| PPC_OPCODE_POWER5 | PPC_OPCODE_CACHELCK | PPC_OPCODE_64
+		| PPC_OPCODE_A2),
+    0 },
+  { "altivec", PPC_OPCODE_PPC,
+    PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2 },
+  { "any",     0,
+    PPC_OPCODE_ANY },
+  { "booke",   PPC_OPCODE_PPC | PPC_OPCODE_BOOKE,
+    0 },
+  { "booke32", PPC_OPCODE_PPC | PPC_OPCODE_BOOKE,
+    0 },
+  { "cell",    (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
+		| PPC_OPCODE_CELL | PPC_OPCODE_ALTIVEC),
+    0 },
+  { "com",     PPC_OPCODE_COMMON,
+    0 },
+  { "e200z4",  (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE| PPC_OPCODE_SPE
+		| PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
+		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
+		| PPC_OPCODE_E500 | PPC_OPCODE_E200Z4),
+    PPC_OPCODE_VLE },
+  { "e300",    PPC_OPCODE_PPC | PPC_OPCODE_E300,
+    0 },
+  { "e500",    (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
+		| PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
+		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
+		| PPC_OPCODE_E500),
+    0 },
+  { "e500mc",  (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_ISEL
+		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
+		| PPC_OPCODE_E500MC),
+    0 },
+  { "e500mc64",  (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_ISEL
+		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
+		| PPC_OPCODE_E500MC | PPC_OPCODE_64 | PPC_OPCODE_POWER5
+		| PPC_OPCODE_POWER6 | PPC_OPCODE_POWER7),
+    0 },
+  { "e5500",    (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_ISEL
+		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
+		| PPC_OPCODE_E500MC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
+		| PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
+		| PPC_OPCODE_POWER7),
+    0 },
+  { "e6500",   (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_ISEL
+		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
+		| PPC_OPCODE_E500MC | PPC_OPCODE_64 | PPC_OPCODE_ALTIVEC
+		| PPC_OPCODE_ALTIVEC2 | PPC_OPCODE_E6500 | PPC_OPCODE_POWER4
+		| PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_POWER7),
+    0 },
+  { "e500x2",  (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_SPE
+		| PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
+		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
+		| PPC_OPCODE_E500),
+    0 },
+  { "efs",     PPC_OPCODE_PPC | PPC_OPCODE_EFS,
+    0 },
+  { "power4",  PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4,
+    0 },
+  { "power5",  (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
+		| PPC_OPCODE_POWER5),
+    0 },
+  { "power6",  (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
+		| PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_ALTIVEC),
+    0 },
+  { "power7",  (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
+		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
+		| PPC_OPCODE_POWER7 | PPC_OPCODE_ALTIVEC | PPC_OPCODE_VSX),
+    0 },
+  { "power8",  (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
+		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
+		| PPC_OPCODE_POWER7 | PPC_OPCODE_POWER8 | PPC_OPCODE_HTM
+		| PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2 | PPC_OPCODE_VSX),
+    0 },
+  { "power9",  (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
+		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
+		| PPC_OPCODE_POWER7 | PPC_OPCODE_POWER8 | PPC_OPCODE_POWER9
+		| PPC_OPCODE_HTM | PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2
+		| PPC_OPCODE_VSX | PPC_OPCODE_VSX3 ),
+    0 },
+  { "ppc",     PPC_OPCODE_PPC,
+    0 },
+  { "ppc32",   PPC_OPCODE_PPC,
+    0 },
+  { "ppc64",   PPC_OPCODE_PPC | PPC_OPCODE_64,
+    0 },
+  { "ppc64bridge", PPC_OPCODE_PPC | PPC_OPCODE_64_BRIDGE,
+    0 },
+  { "ppcps",   PPC_OPCODE_PPC | PPC_OPCODE_PPCPS,
+    0 },
+  { "pwr",     PPC_OPCODE_POWER,
+    0 },
+  { "pwr2",    PPC_OPCODE_POWER | PPC_OPCODE_POWER2,
+    0 },
+  { "pwr4",    PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4,
+    0 },
+  { "pwr5",    (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
+		| PPC_OPCODE_POWER5),
+    0 },
+  { "pwr5x",   (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
+		| PPC_OPCODE_POWER5),
+    0 },
+  { "pwr6",    (PPC_OPCODE_PPC | PPC_OPCODE_64 | PPC_OPCODE_POWER4
+		| PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_ALTIVEC),
+    0 },
+  { "pwr7",    (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
+		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
+		| PPC_OPCODE_POWER7 | PPC_OPCODE_ALTIVEC | PPC_OPCODE_VSX),
+    0 },
+  { "pwr8",    (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
+		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
+		| PPC_OPCODE_POWER7 | PPC_OPCODE_POWER8 | PPC_OPCODE_HTM
+		| PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2 | PPC_OPCODE_VSX),
+    0 },
+  { "pwr9",    (PPC_OPCODE_PPC | PPC_OPCODE_ISEL | PPC_OPCODE_64
+		| PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6
+		| PPC_OPCODE_POWER7 | PPC_OPCODE_POWER8 | PPC_OPCODE_POWER9
+		| PPC_OPCODE_HTM | PPC_OPCODE_ALTIVEC | PPC_OPCODE_ALTIVEC2
+		| PPC_OPCODE_VSX | PPC_OPCODE_VSX3 ),
+    0 },
+  { "pwrx",    PPC_OPCODE_POWER | PPC_OPCODE_POWER2,
+    0 },
+  { "spe",     PPC_OPCODE_PPC | PPC_OPCODE_EFS,
+    PPC_OPCODE_SPE },
+  { "titan",   (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE | PPC_OPCODE_PMR
+		| PPC_OPCODE_RFMCI | PPC_OPCODE_TITAN),
+    0 },
+  { "vle",     (PPC_OPCODE_PPC | PPC_OPCODE_BOOKE| PPC_OPCODE_SPE
+		| PPC_OPCODE_ISEL | PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
+		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK | PPC_OPCODE_RFMCI
+		| PPC_OPCODE_E500),
+    PPC_OPCODE_VLE },
+  { "vsx",     PPC_OPCODE_PPC,
+    PPC_OPCODE_VSX | PPC_OPCODE_VSX3 },
+  { "htm",     PPC_OPCODE_PPC,
+    PPC_OPCODE_HTM },
+};
+
+/* Switch between Booke and VLE dialects for interlinked dumps.  */
+static ppc_cpu_t
+get_powerpc_dialect (struct disassemble_info *info)
+{
+  ppc_cpu_t dialect = 0;
 
-/* Determine which set of machines to disassemble for.  PPC403/601 or
-   BookE.  For convenience, also disassemble instructions supported
-   by the AltiVec vector unit.  */
+  dialect = POWERPC_DIALECT (info);
 
-static int
-powerpc_dialect (struct disassemble_info *info)
-{
-  int dialect = PPC_OPCODE_PPC;
-
-  if (BFD_DEFAULT_TARGET_SIZE == 64)
-    dialect |= PPC_OPCODE_64;
-
-  if (info->disassembler_options
-      && strstr (info->disassembler_options, "booke") != NULL)
-    dialect |= PPC_OPCODE_BOOKE | PPC_OPCODE_BOOKE64;
-  else if ((info->mach == bfd_mach_ppc_e500)
-	   || (info->disassembler_options
-	       && strstr (info->disassembler_options, "e500") != NULL))
-    dialect |= (PPC_OPCODE_BOOKE
-		| PPC_OPCODE_SPE | PPC_OPCODE_ISEL
-		| PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
-		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
-		| PPC_OPCODE_RFMCI);
-  else if (info->disassembler_options
-	   && strstr (info->disassembler_options, "efs") != NULL)
-    dialect |= PPC_OPCODE_EFS;
-  else if (info->disassembler_options
-	   && strstr (info->disassembler_options, "e300") != NULL)
-    dialect |= PPC_OPCODE_E300 | PPC_OPCODE_CLASSIC | PPC_OPCODE_COMMON;
-  else if (info->disassembler_options
-	   && strstr (info->disassembler_options, "440") != NULL)
-    dialect |= PPC_OPCODE_BOOKE | PPC_OPCODE_32
-      | PPC_OPCODE_440 | PPC_OPCODE_ISEL | PPC_OPCODE_RFMCI;
+  /* Disassemble according to the section headers flags for VLE-mode.  */
+  if (dialect & PPC_OPCODE_VLE
+      && info->section->owner != NULL
+      && bfd_get_flavour (info->section->owner) == bfd_target_elf_flavour
+      && elf_object_id (info->section->owner) == PPC32_ELF_DATA
+      && (elf_section_flags (info->section) & SHF_PPC_VLE) != 0)
+    return dialect;
   else
-    dialect |= (PPC_OPCODE_403 | PPC_OPCODE_601 | PPC_OPCODE_CLASSIC
-		| PPC_OPCODE_COMMON | PPC_OPCODE_ALTIVEC);
+    return dialect & ~ PPC_OPCODE_VLE;
+}
+
+/* Handle -m and -M options that set cpu type, and .machine arg.  */
 
-  if (info->disassembler_options
-      && strstr (info->disassembler_options, "power4") != NULL)
-    dialect |= PPC_OPCODE_POWER4;
+ppc_cpu_t
+ppc_parse_cpu (ppc_cpu_t ppc_cpu, ppc_cpu_t *sticky, const char *arg)
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof (ppc_opts) / sizeof (ppc_opts[0]); i++)
+    if (strcmp (ppc_opts[i].opt, arg) == 0)
+      {
+	if (ppc_opts[i].sticky)
+	  {
+	    *sticky |= ppc_opts[i].sticky;
+	    if ((ppc_cpu & ~*sticky) != 0)
+	      break;
+	  }
+	ppc_cpu = ppc_opts[i].cpu;
+	break;
+      }
+  if (i >= sizeof (ppc_opts) / sizeof (ppc_opts[0]))
+    return 0;
+
+  ppc_cpu |= *sticky;
+  return ppc_cpu;
+}
 
-  if (info->disassembler_options
-      && strstr (info->disassembler_options, "power5") != NULL)
-    dialect |= PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5;
+/* Determine which set of machines to disassemble for.  */
 
-  if (info->disassembler_options
-      && strstr (info->disassembler_options, "cell") != NULL)
-    dialect |= PPC_OPCODE_POWER4 | PPC_OPCODE_CELL | PPC_OPCODE_ALTIVEC;
+static void
+powerpc_init_dialect (struct disassemble_info *info)
+{
+  ppc_cpu_t dialect = 0;
+  ppc_cpu_t sticky = 0;
+  char *arg;
+  struct dis_private *priv = calloc (sizeof (*priv), 1);
 
-  if (info->disassembler_options
-      && strstr (info->disassembler_options, "power6") != NULL)
-    dialect |= PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_ALTIVEC;
+  if (priv == NULL)
+    priv = &private;
 
-  if (info->disassembler_options
-      && strstr (info->disassembler_options, "any") != NULL)
-    dialect |= PPC_OPCODE_ANY;
+  switch (info->mach)
+    {
+    case bfd_mach_ppc_403:
+    case bfd_mach_ppc_403gc:
+      dialect = ppc_parse_cpu (dialect, &sticky, "403");
+      break;
+    case bfd_mach_ppc_405:
+      dialect = ppc_parse_cpu (dialect, &sticky, "405");
+      break;
+    case bfd_mach_ppc_601:
+      dialect = ppc_parse_cpu (dialect, &sticky, "601");
+      break;
+    case bfd_mach_ppc_a35:
+    case bfd_mach_ppc_rs64ii:
+    case bfd_mach_ppc_rs64iii:
+      dialect = ppc_parse_cpu (dialect, &sticky, "pwr2") | PPC_OPCODE_64;
+      break;
+    case bfd_mach_ppc_e500:
+      dialect = ppc_parse_cpu (dialect, &sticky, "e500");
+      break;
+    case bfd_mach_ppc_e500mc:
+      dialect = ppc_parse_cpu (dialect, &sticky, "e500mc");
+      break;
+    case bfd_mach_ppc_e500mc64:
+      dialect = ppc_parse_cpu (dialect, &sticky, "e500mc64");
+      break;
+    case bfd_mach_ppc_e5500:
+      dialect = ppc_parse_cpu (dialect, &sticky, "e5500");
+      break;
+    case bfd_mach_ppc_e6500:
+      dialect = ppc_parse_cpu (dialect, &sticky, "e6500");
+      break;
+    case bfd_mach_ppc_titan:
+      dialect = ppc_parse_cpu (dialect, &sticky, "titan");
+      break;
+    case bfd_mach_ppc_vle:
+      dialect = ppc_parse_cpu (dialect, &sticky, "vle");
+      break;
+    default:
+      dialect = ppc_parse_cpu (dialect, &sticky, "power9") | PPC_OPCODE_ANY;
+    }
 
-  if (info->disassembler_options)
+  arg = info->disassembler_options;
+  while (arg != NULL)
     {
-      if (strstr (info->disassembler_options, "32") != NULL)
-	dialect &= ~PPC_OPCODE_64;
-      else if (strstr (info->disassembler_options, "64") != NULL)
+      ppc_cpu_t new_cpu = 0;
+      char *end = strchr (arg, ',');
+
+      if (end != NULL)
+	*end = 0;
+
+      if ((new_cpu = ppc_parse_cpu (dialect, &sticky, arg)) != 0)
+	dialect = new_cpu;
+      else if (strcmp (arg, "32") == 0)
+	dialect &= ~(ppc_cpu_t) PPC_OPCODE_64;
+      else if (strcmp (arg, "64") == 0)
 	dialect |= PPC_OPCODE_64;
+      else
+	fprintf (stderr, _("warning: ignoring unknown -M%s option\n"), arg);
+
+      if (end != NULL)
+	*end++ = ',';
+      arg = end;
+    }
+
+  info->private_data = priv;
+  POWERPC_DIALECT(info) = dialect;
+}
+
+#define PPC_OPCD_SEGS 64
+static unsigned short powerpc_opcd_indices[PPC_OPCD_SEGS+1];
+#define VLE_OPCD_SEGS 32
+static unsigned short vle_opcd_indices[VLE_OPCD_SEGS+1];
+
+/* Calculate opcode table indices to speed up disassembly,
+   and init dialect.  */
+
+void
+disassemble_init_powerpc (struct disassemble_info *info)
+{
+  int i;
+  unsigned short last;
+
+  if (powerpc_opcd_indices[PPC_OPCD_SEGS] == 0)
+    {
+
+      i = powerpc_num_opcodes;
+      while (--i >= 0)
+        {
+          unsigned op = PPC_OP (powerpc_opcodes[i].opcode);
+
+          powerpc_opcd_indices[op] = i;
+        }
+
+      last = powerpc_num_opcodes;
+      for (i = PPC_OPCD_SEGS; i > 0; --i)
+        {
+          if (powerpc_opcd_indices[i] == 0)
+	    powerpc_opcd_indices[i] = last;
+          last = powerpc_opcd_indices[i];
+        }
+
+      i = vle_num_opcodes;
+      while (--i >= 0)
+        {
+          unsigned op = VLE_OP (vle_opcodes[i].opcode, vle_opcodes[i].mask);
+          unsigned seg = VLE_OP_TO_SEG (op);
+
+          vle_opcd_indices[seg] = i;
+        }
+
+      last = vle_num_opcodes;
+      for (i = VLE_OPCD_SEGS; i > 0; --i)
+        {
+          if (vle_opcd_indices[i] == 0)
+	    vle_opcd_indices[i] = last;
+          last = vle_opcd_indices[i];
+        }
     }
 
-  info->private_data = (char *) 0 + dialect;
-  return dialect;
+  if (info->arch == bfd_arch_powerpc)
+    powerpc_init_dialect (info);
 }
 
 /* Print a big endian PowerPC instruction.  */
@@ -106,8 +412,7 @@ powerpc_dialect (struct disassemble_info *info)
 int
 print_insn_big_powerpc (bfd_vma memaddr, struct disassemble_info *info)
 {
-  int dialect = (char *) info->private_data - (char *) 0;
-  return print_insn_powerpc (memaddr, info, 1, dialect);
+  return print_insn_powerpc (memaddr, info, 1, get_powerpc_dialect (info));
 }
 
 /* Print a little endian PowerPC instruction.  */
@@ -115,8 +420,7 @@ print_insn_big_powerpc (bfd_vma memaddr, struct disassemble_info *info)
 int
 print_insn_little_powerpc (bfd_vma memaddr, struct disassemble_info *info)
 {
-  int dialect = (char *) info->private_data - (char *) 0;
-  return print_insn_powerpc (memaddr, info, 0, dialect);
+  return print_insn_powerpc (memaddr, info, 0, get_powerpc_dialect (info));
 }
 
 /* Print a POWER (RS/6000) instruction.  */
@@ -131,7 +435,7 @@ print_insn_rs6000 (bfd_vma memaddr, struct disassemble_info *info)
 
 static long
 operand_value_powerpc (const struct powerpc_operand *operand,
-		       unsigned long insn, int dialect)
+		       unsigned long insn, ppc_cpu_t dialect)
 {
   long value;
   int invalid;
@@ -140,11 +444,14 @@ operand_value_powerpc (const struct powerpc_operand *operand,
     value = (*operand->extract) (insn, dialect, &invalid);
   else
     {
-      value = (insn >> operand->shift) & operand->bitm;
+      if (operand->shift >= 0)
+	value = (insn >> operand->shift) & operand->bitm;
+      else
+	value = (insn << -operand->shift) & operand->bitm;
       if ((operand->flags & PPC_OPERAND_SIGNED) != 0)
 	{
 	  /* BITM is always some number of zeros followed by some
-	     number of ones, followed by some numer of zeros.  */
+	     number of ones, followed by some number of zeros.  */
 	  unsigned long top = operand->bitm;
 	  /* top & -top gives the rightmost 1 bit, so this
 	     fills in any trailing zeros.  */
@@ -161,7 +468,7 @@ operand_value_powerpc (const struct powerpc_operand *operand,
 
 static int
 skip_optional_operands (const unsigned char *opindex,
-			unsigned long insn, int dialect)
+			unsigned long insn, ppc_cpu_t dialect)
 {
   const struct powerpc_operand *operand;
 
@@ -170,36 +477,148 @@ skip_optional_operands (const unsigned char *opindex,
       operand = &powerpc_operands[*opindex];
       if ((operand->flags & PPC_OPERAND_NEXT) != 0
 	  || ((operand->flags & PPC_OPERAND_OPTIONAL) != 0
-	      && operand_value_powerpc (operand, insn, dialect) != 0))
+	      && operand_value_powerpc (operand, insn, dialect) !=
+		 ppc_optional_operand_value (operand)))
 	return 0;
     }
 
   return 1;
 }
 
+/* Find a match for INSN in the opcode table, given machine DIALECT.
+   A DIALECT of -1 is special, matching all machine opcode variations.  */
+
+static const struct powerpc_opcode *
+lookup_powerpc (unsigned long insn, ppc_cpu_t dialect)
+{
+  const struct powerpc_opcode *opcode;
+  const struct powerpc_opcode *opcode_end;
+  unsigned long op;
+
+  /* Get the major opcode of the instruction.  */
+  op = PPC_OP (insn);
+
+  /* Find the first match in the opcode table for this major opcode.  */
+  opcode_end = powerpc_opcodes + powerpc_opcd_indices[op + 1];
+  for (opcode = powerpc_opcodes + powerpc_opcd_indices[op];
+       opcode < opcode_end;
+       ++opcode)
+    {
+      const unsigned char *opindex;
+      const struct powerpc_operand *operand;
+      int invalid;
+
+      if ((insn & opcode->mask) != opcode->opcode
+	  || (dialect != (ppc_cpu_t) -1
+	      && ((opcode->flags & dialect) == 0
+		  || (opcode->deprecated & dialect) != 0)))
+	continue;
+
+      /* Check validity of operands.  */
+      invalid = 0;
+      for (opindex = opcode->operands; *opindex != 0; opindex++)
+	{
+	  operand = powerpc_operands + *opindex;
+	  if (operand->extract)
+	    (*operand->extract) (insn, dialect, &invalid);
+	}
+      if (invalid)
+	continue;
+
+      return opcode;
+    }
+
+  return NULL;
+}
+
+/* Find a match for INSN in the VLE opcode table.  */
+
+static const struct powerpc_opcode *
+lookup_vle (unsigned long insn)
+{
+  const struct powerpc_opcode *opcode;
+  const struct powerpc_opcode *opcode_end;
+  unsigned op, seg;
+
+  op = PPC_OP (insn);
+  if (op >= 0x20 && op <= 0x37)
+    {
+      /* This insn has a 4-bit opcode.  */
+      op &= 0x3c;
+    }
+  seg = VLE_OP_TO_SEG (op);
+
+  /* Find the first match in the opcode table for this major opcode.  */
+  opcode_end = vle_opcodes + vle_opcd_indices[seg + 1];
+  for (opcode = vle_opcodes + vle_opcd_indices[seg];
+       opcode < opcode_end;
+       ++opcode)
+    {
+      unsigned long table_opcd = opcode->opcode;
+      unsigned long table_mask = opcode->mask;
+      bfd_boolean table_op_is_short = PPC_OP_SE_VLE(table_mask);
+      unsigned long insn2;
+      const unsigned char *opindex;
+      const struct powerpc_operand *operand;
+      int invalid;
+
+      insn2 = insn;
+      if (table_op_is_short)
+	insn2 >>= 16;
+      if ((insn2 & table_mask) != table_opcd)
+	continue;
+
+      /* Check validity of operands.  */
+      invalid = 0;
+      for (opindex = opcode->operands; *opindex != 0; ++opindex)
+	{
+	  operand = powerpc_operands + *opindex;
+	  if (operand->extract)
+	    (*operand->extract) (insn, (ppc_cpu_t)0, &invalid);
+	}
+      if (invalid)
+	continue;
+
+      return opcode;
+    }
+
+  return NULL;
+}
+
 /* Print a PowerPC or POWER instruction.  */
 
 static int
 print_insn_powerpc (bfd_vma memaddr,
 		    struct disassemble_info *info,
 		    int bigendian,
-		    int dialect)
+		    ppc_cpu_t dialect)
 {
   bfd_byte buffer[4];
   int status;
   unsigned long insn;
   const struct powerpc_opcode *opcode;
-  const struct powerpc_opcode *opcode_end;
-  unsigned long op;
-
-  if (dialect == 0)
-    dialect = powerpc_dialect (info);
+  bfd_boolean insn_is_short;
 
   status = (*info->read_memory_func) (memaddr, buffer, 4, info);
   if (status != 0)
     {
-      (*info->memory_error_func) (status, memaddr, info);
-      return -1;
+      /* The final instruction may be a 2-byte VLE insn.  */
+      if ((dialect & PPC_OPCODE_VLE) != 0)
+        {
+          /* Clear buffer so unused bytes will not have garbage in them.  */
+          buffer[0] = buffer[1] = buffer[2] = buffer[3] = 0;
+          status = (*info->read_memory_func) (memaddr, buffer, 2, info);
+          if (status != 0)
+            {
+              (*info->memory_error_func) (status, memaddr, info);
+              return -1;
+            }
+        }
+      else
+        {
+          (*info->memory_error_func) (status, memaddr, info);
+          return -1;
+        }
     }
 
   if (bigendian)
@@ -207,52 +626,37 @@ print_insn_powerpc (bfd_vma memaddr,
   else
     insn = bfd_getl32 (buffer);
 
-  /* Get the major opcode of the instruction.  */
-  op = PPC_OP (insn);
+  /* Get the major opcode of the insn.  */
+  opcode = NULL;
+  insn_is_short = FALSE;
+  if ((dialect & PPC_OPCODE_VLE) != 0)
+    {
+      opcode = lookup_vle (insn);
+      if (opcode != NULL)
+	insn_is_short = PPC_OP_SE_VLE(opcode->mask);
+    }
+  if (opcode == NULL)
+    opcode = lookup_powerpc (insn, dialect);
+  if (opcode == NULL && (dialect & PPC_OPCODE_ANY) != 0)
+    opcode = lookup_powerpc (insn, (ppc_cpu_t) -1);
 
-  /* Find the first match in the opcode table.  We could speed this up
-     a bit by doing a binary search on the major opcode.  */
-  opcode_end = powerpc_opcodes + powerpc_num_opcodes;
- again:
-  for (opcode = powerpc_opcodes; opcode < opcode_end; opcode++)
+  if (opcode != NULL)
     {
-      unsigned long table_op;
       const unsigned char *opindex;
       const struct powerpc_operand *operand;
-      int invalid;
       int need_comma;
       int need_paren;
       int skip_optional;
 
-      table_op = PPC_OP (opcode->opcode);
-      if (op < table_op)
-	break;
-      if (op > table_op)
-	continue;
-
-      if ((insn & opcode->mask) != opcode->opcode
-	  || (opcode->flags & dialect) == 0)
-	continue;
-
-      /* Make two passes over the operands.  First see if any of them
-	 have extraction functions, and, if they do, make sure the
-	 instruction is valid.  */
-      invalid = 0;
-      for (opindex = opcode->operands; *opindex != 0; opindex++)
-	{
-	  operand = powerpc_operands + *opindex;
-	  if (operand->extract)
-	    (*operand->extract) (insn, dialect, &invalid);
-	}
-      if (invalid)
-	continue;
-
-      /* The instruction is valid.  */
       if (opcode->operands[0] != 0)
 	(*info->fprintf_func) (info->stream, "%-7s ", opcode->name);
       else
 	(*info->fprintf_func) (info->stream, "%s", opcode->name);
 
+      if (insn_is_short)
+        /* The operands will be fetched out of the 16-bit instruction.  */
+        insn >>= 16;
+
       /* Now extract and print the operands.  */
       need_comma = 0;
       need_paren = 0;
@@ -296,30 +700,38 @@ print_insn_powerpc (bfd_vma memaddr,
 	    (*info->fprintf_func) (info->stream, "f%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_VR) != 0)
 	    (*info->fprintf_func) (info->stream, "v%ld", value);
+	  else if ((operand->flags & PPC_OPERAND_VSR) != 0)
+	    (*info->fprintf_func) (info->stream, "vs%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0)
 	    (*info->print_address_func) (memaddr + value, info);
 	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
 	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
-	  else if ((operand->flags & PPC_OPERAND_CR) == 0
-		   || (dialect & PPC_OPCODE_PPC) == 0)
+	  else if ((operand->flags & PPC_OPERAND_FSL) != 0)
+	    (*info->fprintf_func) (info->stream, "fsl%ld", value);
+	  else if ((operand->flags & PPC_OPERAND_FCR) != 0)
+	    (*info->fprintf_func) (info->stream, "fcr%ld", value);
+	  else if ((operand->flags & PPC_OPERAND_UDI) != 0)
 	    (*info->fprintf_func) (info->stream, "%ld", value);
-	  else
+	  else if ((operand->flags & PPC_OPERAND_CR_REG) != 0
+		   && (((dialect & PPC_OPCODE_PPC) != 0)
+		       || ((dialect & PPC_OPCODE_VLE) != 0)))
+	    (*info->fprintf_func) (info->stream, "cr%ld", value);
+	  else if (((operand->flags & PPC_OPERAND_CR_BIT) != 0)
+		   && (((dialect & PPC_OPCODE_PPC) != 0)
+		       || ((dialect & PPC_OPCODE_VLE) != 0)))
 	    {
-	      if (operand->bitm == 7)
-		(*info->fprintf_func) (info->stream, "cr%ld", value);
-	      else
-		{
-		  static const char *cbnames[4] = { "lt", "gt", "eq", "so" };
-		  int cr;
-		  int cc;
-
-		  cr = value >> 2;
-		  if (cr != 0)
-		    (*info->fprintf_func) (info->stream, "4*cr%d+", cr);
-		  cc = value & 3;
-		  (*info->fprintf_func) (info->stream, "%s", cbnames[cc]);
-		}
+	      static const char *cbnames[4] = { "lt", "gt", "eq", "so" };
+	      int cr;
+	      int cc;
+
+	      cr = value >> 2;
+	      if (cr != 0)
+		(*info->fprintf_func) (info->stream, "4*cr%d+", cr);
+	      cc = value & 3;
+	      (*info->fprintf_func) (info->stream, "%s", cbnames[cc]);
 	    }
+	  else
+	    (*info->fprintf_func) (info->stream, "%d", (int) value);
 
 	  if (need_paren)
 	    {
@@ -336,14 +748,16 @@ print_insn_powerpc (bfd_vma memaddr,
 	    }
 	}
 
-      /* We have found and printed an instruction; return.  */
-      return 4;
-    }
-
-  if ((dialect & PPC_OPCODE_ANY) != 0)
-    {
-      dialect = ~PPC_OPCODE_ANY;
-      goto again;
+      /* We have found and printed an instruction.
+         If it was a short VLE instruction we have more to do.  */
+      if (insn_is_short)
+        {
+          memaddr += 2;
+          return 2;
+        }
+      else
+        /* Otherwise, return.  */
+        return 4;
     }
 
   /* We could not find a match.  */
@@ -355,18 +769,20 @@ print_insn_powerpc (bfd_vma memaddr,
 void
 print_ppc_disassembler_options (FILE *stream)
 {
-  fprintf (stream, "\n\
+  unsigned int i, col;
+
+  fprintf (stream, _("\n\
 The following PPC specific disassembler options are supported for use with\n\
-the -M switch:\n");
-
-  fprintf (stream, "  booke|booke32|booke64    Disassemble the BookE instructions\n");
-  fprintf (stream, "  e300                     Disassemble the e300 instructions\n");
-  fprintf (stream, "  e500|e500x2              Disassemble the e500 instructions\n");
-  fprintf (stream, "  440                      Disassemble the 440 instructions\n");
-  fprintf (stream, "  efs                      Disassemble the EFS instructions\n");
-  fprintf (stream, "  power4                   Disassemble the Power4 instructions\n");
-  fprintf (stream, "  power5                   Disassemble the Power5 instructions\n");
-  fprintf (stream, "  power6                   Disassemble the Power6 instructions\n");
-  fprintf (stream, "  32                       Do not disassemble 64-bit instructions\n");
-  fprintf (stream, "  64                       Allow disassembly of 64-bit instructions\n");
+the -M switch:\n"));
+
+  for (col = 0, i = 0; i < sizeof (ppc_opts) / sizeof (ppc_opts[0]); i++)
+    {
+      col += fprintf (stream, " %s,", ppc_opts[i].opt);
+      if (col > 66)
+	{
+	  fprintf (stream, "\n");
+	  col = 0;
+	}
+    }
+  fprintf (stream, " 32, 64\n");
 }

commit cc7639ce18b950086c7b06e00350652db3732183
Author: Balbir Singh <bsingharora@gmail.com>
Date:   Thu Feb 2 10:33:42 2017 +0530

    powerpc/xmon: Update ppc-dis/opc.c and ppc.h
    
    Upgrade ppc-opc.c, ppc-dis.c and ppc.h to the versions belonging to the
    following binutils commit:
    
      65b650b4c7463f4508bed523c24ab0031a5ae5cd
      * ppc-dis.c (print_insn_powerpc): Don't skip all operands after
        setting skip_optional.
    
    That is the last version of those files that were licensed under GPLv2.
    
    This leaves the code in a state that does not compile, because the
    binutils code needs to be tweaked to work in the kernel. We don't fix
    that in this commit, because we want to import more binutils changes in
    subsequent commits. So for now we mark XMON_DISASSEMBLY as BROKEN, so it
    can't be built.
    
    Signed-off-by: Balbir Singh <bsingharora@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/xmon/ppc-dis.c b/arch/powerpc/xmon/ppc-dis.c
index ee9891734149..2545a36f21a5 100644
--- a/arch/powerpc/xmon/ppc-dis.c
+++ b/arch/powerpc/xmon/ppc-dis.c
@@ -1,5 +1,5 @@
 /* ppc-dis.c -- Disassemble PowerPC instructions
-   Copyright 1994, 1995, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Copyright 1994, 1995, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
    Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Support
 
@@ -19,34 +19,193 @@ You should have received a copy of the GNU General Public License
 along with this file; see the file COPYING.  If not, write to the Free
 Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
 
-#include <asm/cputable.h>
-#include <asm/cpu_has_feature.h>
-#include "nonstdio.h"
-#include "ansidecl.h"
-#include "ppc.h"
+#include <stdio.h>
+#include "sysdep.h"
 #include "dis-asm.h"
+#include "opcode/ppc.h"
 
-/* Print a PowerPC or POWER instruction.  */
+/* This file provides several disassembler functions, all of which use
+   the disassembler interface defined in dis-asm.h.  Several functions
+   are provided because this file handles disassembly for the PowerPC
+   in both big and little endian mode and also for the POWER (RS/6000)
+   chip.  */
+
+static int print_insn_powerpc (bfd_vma, struct disassemble_info *, int, int);
+
+/* Determine which set of machines to disassemble for.  PPC403/601 or
+   BookE.  For convenience, also disassemble instructions supported
+   by the AltiVec vector unit.  */
+
+static int
+powerpc_dialect (struct disassemble_info *info)
+{
+  int dialect = PPC_OPCODE_PPC;
+
+  if (BFD_DEFAULT_TARGET_SIZE == 64)
+    dialect |= PPC_OPCODE_64;
+
+  if (info->disassembler_options
+      && strstr (info->disassembler_options, "booke") != NULL)
+    dialect |= PPC_OPCODE_BOOKE | PPC_OPCODE_BOOKE64;
+  else if ((info->mach == bfd_mach_ppc_e500)
+	   || (info->disassembler_options
+	       && strstr (info->disassembler_options, "e500") != NULL))
+    dialect |= (PPC_OPCODE_BOOKE
+		| PPC_OPCODE_SPE | PPC_OPCODE_ISEL
+		| PPC_OPCODE_EFS | PPC_OPCODE_BRLOCK
+		| PPC_OPCODE_PMR | PPC_OPCODE_CACHELCK
+		| PPC_OPCODE_RFMCI);
+  else if (info->disassembler_options
+	   && strstr (info->disassembler_options, "efs") != NULL)
+    dialect |= PPC_OPCODE_EFS;
+  else if (info->disassembler_options
+	   && strstr (info->disassembler_options, "e300") != NULL)
+    dialect |= PPC_OPCODE_E300 | PPC_OPCODE_CLASSIC | PPC_OPCODE_COMMON;
+  else if (info->disassembler_options
+	   && strstr (info->disassembler_options, "440") != NULL)
+    dialect |= PPC_OPCODE_BOOKE | PPC_OPCODE_32
+      | PPC_OPCODE_440 | PPC_OPCODE_ISEL | PPC_OPCODE_RFMCI;
+  else
+    dialect |= (PPC_OPCODE_403 | PPC_OPCODE_601 | PPC_OPCODE_CLASSIC
+		| PPC_OPCODE_COMMON | PPC_OPCODE_ALTIVEC);
+
+  if (info->disassembler_options
+      && strstr (info->disassembler_options, "power4") != NULL)
+    dialect |= PPC_OPCODE_POWER4;
+
+  if (info->disassembler_options
+      && strstr (info->disassembler_options, "power5") != NULL)
+    dialect |= PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5;
+
+  if (info->disassembler_options
+      && strstr (info->disassembler_options, "cell") != NULL)
+    dialect |= PPC_OPCODE_POWER4 | PPC_OPCODE_CELL | PPC_OPCODE_ALTIVEC;
+
+  if (info->disassembler_options
+      && strstr (info->disassembler_options, "power6") != NULL)
+    dialect |= PPC_OPCODE_POWER4 | PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_ALTIVEC;
+
+  if (info->disassembler_options
+      && strstr (info->disassembler_options, "any") != NULL)
+    dialect |= PPC_OPCODE_ANY;
+
+  if (info->disassembler_options)
+    {
+      if (strstr (info->disassembler_options, "32") != NULL)
+	dialect &= ~PPC_OPCODE_64;
+      else if (strstr (info->disassembler_options, "64") != NULL)
+	dialect |= PPC_OPCODE_64;
+    }
+
+  info->private_data = (char *) 0 + dialect;
+  return dialect;
+}
+
+/* Print a big endian PowerPC instruction.  */
+
+int
+print_insn_big_powerpc (bfd_vma memaddr, struct disassemble_info *info)
+{
+  int dialect = (char *) info->private_data - (char *) 0;
+  return print_insn_powerpc (memaddr, info, 1, dialect);
+}
+
+/* Print a little endian PowerPC instruction.  */
 
 int
-print_insn_powerpc (unsigned long insn, unsigned long memaddr)
+print_insn_little_powerpc (bfd_vma memaddr, struct disassemble_info *info)
+{
+  int dialect = (char *) info->private_data - (char *) 0;
+  return print_insn_powerpc (memaddr, info, 0, dialect);
+}
+
+/* Print a POWER (RS/6000) instruction.  */
+
+int
+print_insn_rs6000 (bfd_vma memaddr, struct disassemble_info *info)
+{
+  return print_insn_powerpc (memaddr, info, 1, PPC_OPCODE_POWER);
+}
+
+/* Extract the operand value from the PowerPC or POWER instruction.  */
+
+static long
+operand_value_powerpc (const struct powerpc_operand *operand,
+		       unsigned long insn, int dialect)
+{
+  long value;
+  int invalid;
+  /* Extract the value from the instruction.  */
+  if (operand->extract)
+    value = (*operand->extract) (insn, dialect, &invalid);
+  else
+    {
+      value = (insn >> operand->shift) & operand->bitm;
+      if ((operand->flags & PPC_OPERAND_SIGNED) != 0)
+	{
+	  /* BITM is always some number of zeros followed by some
+	     number of ones, followed by some numer of zeros.  */
+	  unsigned long top = operand->bitm;
+	  /* top & -top gives the rightmost 1 bit, so this
+	     fills in any trailing zeros.  */
+	  top |= (top & -top) - 1;
+	  top &= ~(top >> 1);
+	  value = (value ^ top) - top;
+	}
+    }
+
+  return value;
+}
+
+/* Determine whether the optional operand(s) should be printed.  */
+
+static int
+skip_optional_operands (const unsigned char *opindex,
+			unsigned long insn, int dialect)
+{
+  const struct powerpc_operand *operand;
+
+  for (; *opindex != 0; opindex++)
+    {
+      operand = &powerpc_operands[*opindex];
+      if ((operand->flags & PPC_OPERAND_NEXT) != 0
+	  || ((operand->flags & PPC_OPERAND_OPTIONAL) != 0
+	      && operand_value_powerpc (operand, insn, dialect) != 0))
+	return 0;
+    }
+
+  return 1;
+}
+
+/* Print a PowerPC or POWER instruction.  */
+
+static int
+print_insn_powerpc (bfd_vma memaddr,
+		    struct disassemble_info *info,
+		    int bigendian,
+		    int dialect)
 {
+  bfd_byte buffer[4];
+  int status;
+  unsigned long insn;
   const struct powerpc_opcode *opcode;
   const struct powerpc_opcode *opcode_end;
   unsigned long op;
-  int dialect;
-
-  dialect = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_COMMON
-	      | PPC_OPCODE_64 | PPC_OPCODE_POWER4 | PPC_OPCODE_ALTIVEC;
 
-  if (cpu_has_feature(CPU_FTRS_POWER5))
-    dialect |= PPC_OPCODE_POWER5;
+  if (dialect == 0)
+    dialect = powerpc_dialect (info);
 
-  if (cpu_has_feature(CPU_FTRS_CELL))
-    dialect |= PPC_OPCODE_CELL | PPC_OPCODE_ALTIVEC;
+  status = (*info->read_memory_func) (memaddr, buffer, 4, info);
+  if (status != 0)
+    {
+      (*info->memory_error_func) (status, memaddr, info);
+      return -1;
+    }
 
-  if (cpu_has_feature(CPU_FTRS_POWER6))
-    dialect |= PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_ALTIVEC;
+  if (bigendian)
+    insn = bfd_getb32 (buffer);
+  else
+    insn = bfd_getl32 (buffer);
 
   /* Get the major opcode of the instruction.  */
   op = PPC_OP (insn);
@@ -63,6 +222,7 @@ print_insn_powerpc (unsigned long insn, unsigned long memaddr)
       int invalid;
       int need_comma;
       int need_paren;
+      int skip_optional;
 
       table_op = PPC_OP (opcode->opcode);
       if (op < table_op)
@@ -88,13 +248,15 @@ print_insn_powerpc (unsigned long insn, unsigned long memaddr)
 	continue;
 
       /* The instruction is valid.  */
-      printf("%s", opcode->name);
       if (opcode->operands[0] != 0)
-	printf("\t");
+	(*info->fprintf_func) (info->stream, "%-7s ", opcode->name);
+      else
+	(*info->fprintf_func) (info->stream, "%s", opcode->name);
 
       /* Now extract and print the operands.  */
       need_comma = 0;
       need_paren = 0;
+      skip_optional = -1;
       for (opindex = opcode->operands; *opindex != 0; opindex++)
 	{
 	  long value;
@@ -107,49 +269,44 @@ print_insn_powerpc (unsigned long insn, unsigned long memaddr)
 	  if ((operand->flags & PPC_OPERAND_FAKE) != 0)
 	    continue;
 
-	  /* Extract the value from the instruction.  */
-	  if (operand->extract)
-	    value = (*operand->extract) (insn, dialect, &invalid);
-	  else
+	  /* If all of the optional operands have the value zero,
+	     then don't print any of them.  */
+	  if ((operand->flags & PPC_OPERAND_OPTIONAL) != 0)
 	    {
-	      value = (insn >> operand->shift) & ((1 << operand->bits) - 1);
-	      if ((operand->flags & PPC_OPERAND_SIGNED) != 0
-		  && (value & (1 << (operand->bits - 1))) != 0)
-		value -= 1 << operand->bits;
+	      if (skip_optional < 0)
+		skip_optional = skip_optional_operands (opindex, insn,
+							dialect);
+	      if (skip_optional)
+		continue;
 	    }
 
-	  /* If the operand is optional, and the value is zero, don't
-	     print anything.  */
-	  if ((operand->flags & PPC_OPERAND_OPTIONAL) != 0
-	      && (operand->flags & PPC_OPERAND_NEXT) == 0
-	      && value == 0)
-	    continue;
+	  value = operand_value_powerpc (operand, insn, dialect);
 
 	  if (need_comma)
 	    {
-	      printf(",");
+	      (*info->fprintf_func) (info->stream, ",");
 	      need_comma = 0;
 	    }
 
 	  /* Print the operand as directed by the flags.  */
 	  if ((operand->flags & PPC_OPERAND_GPR) != 0
 	      || ((operand->flags & PPC_OPERAND_GPR_0) != 0 && value != 0))
-	    printf("r%ld", value);
+	    (*info->fprintf_func) (info->stream, "r%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_FPR) != 0)
-	    printf("f%ld", value);
+	    (*info->fprintf_func) (info->stream, "f%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_VR) != 0)
-	    printf("v%ld", value);
+	    (*info->fprintf_func) (info->stream, "v%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0)
-	    print_address (memaddr + value);
+	    (*info->print_address_func) (memaddr + value, info);
 	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
-	    print_address (value & 0xffffffff);
+	    (*info->print_address_func) ((bfd_vma) value & 0xffffffff, info);
 	  else if ((operand->flags & PPC_OPERAND_CR) == 0
 		   || (dialect & PPC_OPCODE_PPC) == 0)
-	    printf("%ld", value);
+	    (*info->fprintf_func) (info->stream, "%ld", value);
 	  else
 	    {
-	      if (operand->bits == 3)
-		printf("cr%ld", value);
+	      if (operand->bitm == 7)
+		(*info->fprintf_func) (info->stream, "cr%ld", value);
 	      else
 		{
 		  static const char *cbnames[4] = { "lt", "gt", "eq", "so" };
@@ -158,15 +315,15 @@ print_insn_powerpc (unsigned long insn, unsigned long memaddr)
 
 		  cr = value >> 2;
 		  if (cr != 0)
-		    printf("4*cr%d+", cr);
+		    (*info->fprintf_func) (info->stream, "4*cr%d+", cr);
 		  cc = value & 3;
-		  printf("%s", cbnames[cc]);
+		  (*info->fprintf_func) (info->stream, "%s", cbnames[cc]);
 		}
 	    }
 
 	  if (need_paren)
 	    {
-	      printf(")");
+	      (*info->fprintf_func) (info->stream, ")");
 	      need_paren = 0;
 	    }
 
@@ -174,7 +331,7 @@ print_insn_powerpc (unsigned long insn, unsigned long memaddr)
 	    need_comma = 1;
 	  else
 	    {
-	      printf("(");
+	      (*info->fprintf_func) (info->stream, "(");
 	      need_paren = 1;
 	    }
 	}
@@ -190,7 +347,26 @@ print_insn_powerpc (unsigned long insn, unsigned long memaddr)
     }
 
   /* We could not find a match.  */
-  printf(".long 0x%lx", insn);
+  (*info->fprintf_func) (info->stream, ".long 0x%lx", insn);
 
   return 4;
 }
+
+void
+print_ppc_disassembler_options (FILE *stream)
+{
+  fprintf (stream, "\n\
+The following PPC specific disassembler options are supported for use with\n\
+the -M switch:\n");
+
+  fprintf (stream, "  booke|booke32|booke64    Disassemble the BookE instructions\n");
+  fprintf (stream, "  e300                     Disassemble the e300 instructions\n");
+  fprintf (stream, "  e500|e500x2              Disassemble the e500 instructions\n");
+  fprintf (stream, "  440                      Disassemble the 440 instructions\n");
+  fprintf (stream, "  efs                      Disassemble the EFS instructions\n");
+  fprintf (stream, "  power4                   Disassemble the Power4 instructions\n");
+  fprintf (stream, "  power5                   Disassemble the Power5 instructions\n");
+  fprintf (stream, "  power6                   Disassemble the Power6 instructions\n");
+  fprintf (stream, "  32                       Do not disassemble 64-bit instructions\n");
+  fprintf (stream, "  64                       Allow disassembly of 64-bit instructions\n");
+}

commit b92a226e528423b8d249dd09bb450d53361fbfcb
Author: Kevin Hao <haokexin@gmail.com>
Date:   Sat Jul 23 14:42:40 2016 +0530

    powerpc: Move cpu_has_feature() to a separate file
    
    We plan to use jump label for cpu_has_feature(). In order to implement
    this we need to include the linux/jump_label.h in asm/cputable.h.
    
    Unfortunately if we do that it leads to an include loop. The root of the
    problem seems to be that reg.h needs cputable.h (for CPU_FTRs), and then
    cputable.h via jump_label.h eventually pulls in hw_irq.h which needs
    reg.h (for MSR_EE).
    
    So move cpu_has_feature() to a separate file on its own.
    
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    [mpe: Rename to cpu_has_feature.h and flesh out change log]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/xmon/ppc-dis.c b/arch/powerpc/xmon/ppc-dis.c
index 89098f320ad5..ee9891734149 100644
--- a/arch/powerpc/xmon/ppc-dis.c
+++ b/arch/powerpc/xmon/ppc-dis.c
@@ -20,6 +20,7 @@ along with this file; see the file COPYING.  If not, write to the Free
 Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
 
 #include <asm/cputable.h>
+#include <asm/cpu_has_feature.h>
 #include "nonstdio.h"
 #include "ansidecl.h"
 #include "ppc.h"

commit 897f112bb42ed9e220ce441e7e52aba3a144a7d6
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Nov 23 00:46:47 2006 +0100

    [POWERPC] Import updated version of ppc disassembly code for xmon
    
    This includes:
     * version 1.24 of ppc-dis.c
     * version 1.88 of ppc-opc.c
     * version 1.23 of ppc.h
    
    I can't vouch for the accuracy etc. of these changes, but it brings
    us into line with binutils - and from a cursory test appears to work
    fine.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>

diff --git a/arch/powerpc/xmon/ppc-dis.c b/arch/powerpc/xmon/ppc-dis.c
index 08652742fa77..89098f320ad5 100644
--- a/arch/powerpc/xmon/ppc-dis.c
+++ b/arch/powerpc/xmon/ppc-dis.c
@@ -1,5 +1,6 @@
 /* ppc-dis.c -- Disassemble PowerPC instructions
-   Copyright 1994 Free Software Foundation, Inc.
+   Copyright 1994, 1995, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
    Written by Ian Lance Taylor, Cygnus Support
 
 This file is part of GDB, GAS, and the GNU binutils.
@@ -16,8 +17,9 @@ the GNU General Public License for more details.
 
 You should have received a copy of the GNU General Public License
 along with this file; see the file COPYING.  If not, write to the Free
-Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
 
+#include <asm/cputable.h>
 #include "nonstdio.h"
 #include "ansidecl.h"
 #include "ppc.h"
@@ -36,6 +38,15 @@ print_insn_powerpc (unsigned long insn, unsigned long memaddr)
   dialect = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_COMMON
 	      | PPC_OPCODE_64 | PPC_OPCODE_POWER4 | PPC_OPCODE_ALTIVEC;
 
+  if (cpu_has_feature(CPU_FTRS_POWER5))
+    dialect |= PPC_OPCODE_POWER5;
+
+  if (cpu_has_feature(CPU_FTRS_CELL))
+    dialect |= PPC_OPCODE_CELL | PPC_OPCODE_ALTIVEC;
+
+  if (cpu_has_feature(CPU_FTRS_POWER6))
+    dialect |= PPC_OPCODE_POWER5 | PPC_OPCODE_POWER6 | PPC_OPCODE_ALTIVEC;
+
   /* Get the major opcode of the instruction.  */
   op = PPC_OP (insn);
 
@@ -120,7 +131,8 @@ print_insn_powerpc (unsigned long insn, unsigned long memaddr)
 	    }
 
 	  /* Print the operand as directed by the flags.  */
-	  if ((operand->flags & PPC_OPERAND_GPR) != 0)
+	  if ((operand->flags & PPC_OPERAND_GPR) != 0
+	      || ((operand->flags & PPC_OPERAND_GPR_0) != 0 && value != 0))
 	    printf("r%ld", value);
 	  else if ((operand->flags & PPC_OPERAND_FPR) != 0)
 	    printf("f%ld", value);
@@ -136,7 +148,7 @@ print_insn_powerpc (unsigned long insn, unsigned long memaddr)
 	  else
 	    {
 	      if (operand->bits == 3)
-		printf("cr%d", value);
+		printf("cr%ld", value);
 	      else
 		{
 		  static const char *cbnames[4] = { "lt", "gt", "eq", "so" };

commit e0426047cb684842700f0098f74842a38260dbae
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Nov 23 00:46:45 2006 +0100

    [POWERPC] Make xmon disassembly optional
    
    While adding spu disassembly support it struck me that we're actually
    carrying quite a lot of code around, just to do disassembly in the case
    of a crash.
    
    While on large systems it's not an issue, on smaller ones it might be
    nice to have xmon - but without the weight of the disassembly support.
    For a Cell build this saves ~230KB (!), and for pSeries ~195KB.
    
    We still support the 'di' and 'sdi' commands, however they just dump
    the instruction in hex.
    
    Move the definitions into a header to clean xmon.c just a tiny bit.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>

diff --git a/arch/powerpc/xmon/ppc-dis.c b/arch/powerpc/xmon/ppc-dis.c
index 3b67bee4830b..08652742fa77 100644
--- a/arch/powerpc/xmon/ppc-dis.c
+++ b/arch/powerpc/xmon/ppc-dis.c
@@ -21,8 +21,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  *
 #include "nonstdio.h"
 #include "ansidecl.h"
 #include "ppc.h"
-
-extern void print_address (unsigned long memaddr);
+#include "dis-asm.h"
 
 /* Print a PowerPC or POWER instruction.  */
 

commit 4c4c8723684b1b2cd0dfdf5e0685f35642bde253
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Nov 23 00:46:42 2006 +0100

    [POWERPC] Prepare for spu disassembly in xmon
    
    In order to do disassembly of spu binaries in xmon, we need to abstract
    the disassembly function from ppc_inst_dump.
    
    We do this by making the actual disassembly function a function pointer
    that we pass to ppc_inst_dump(). To save updating all the callers, we
    turn ppc_inst_dump() into generic_inst_dump() and make ppc_inst_dump()
    a wrapper which always uses print_insn_powerpc().
    
    Currently we pass the dialect into print_insn_powerpc(), but we always
    pass 0 - so just make it a local.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>

diff --git a/arch/powerpc/xmon/ppc-dis.c b/arch/powerpc/xmon/ppc-dis.c
index ac0a9d2427e0..3b67bee4830b 100644
--- a/arch/powerpc/xmon/ppc-dis.c
+++ b/arch/powerpc/xmon/ppc-dis.c
@@ -27,14 +27,14 @@ extern void print_address (unsigned long memaddr);
 /* Print a PowerPC or POWER instruction.  */
 
 int
-print_insn_powerpc (unsigned long insn, unsigned long memaddr, int dialect)
+print_insn_powerpc (unsigned long insn, unsigned long memaddr)
 {
   const struct powerpc_opcode *opcode;
   const struct powerpc_opcode *opcode_end;
   unsigned long op;
+  int dialect;
 
-  if (dialect == 0)
-    dialect = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_COMMON
+  dialect = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_COMMON
 	      | PPC_OPCODE_64 | PPC_OPCODE_POWER4 | PPC_OPCODE_ALTIVEC;
 
   /* Get the major opcode of the instruction.  */

commit f78541dcec327b0c46b150ee7d727f3db80275c4
Author: Paul Mackerras <paulus@samba.org>
Date:   Fri Oct 28 22:53:37 2005 +1000

    powerpc: Merge xmon
    
    The merged version follows the ppc64 version pretty closely mostly,
    and in fact ARCH=ppc64 now uses the arch/powerpc/xmon version.
    The main difference for ppc64 is that the 'p' command to call
    show_state (which was always pretty dodgy) has been replaced by
    the ppc32 'p' command, which calls a given procedure (so in fact
    the old 'p' command behaviour can be achieved with 'p $show_state').
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/xmon/ppc-dis.c b/arch/powerpc/xmon/ppc-dis.c
new file mode 100644
index 000000000000..ac0a9d2427e0
--- /dev/null
+++ b/arch/powerpc/xmon/ppc-dis.c
@@ -0,0 +1,184 @@
+/* ppc-dis.c -- Disassemble PowerPC instructions
+   Copyright 1994 Free Software Foundation, Inc.
+   Written by Ian Lance Taylor, Cygnus Support
+
+This file is part of GDB, GAS, and the GNU binutils.
+
+GDB, GAS, and the GNU binutils are free software; you can redistribute
+them and/or modify them under the terms of the GNU General Public
+License as published by the Free Software Foundation; either version
+2, or (at your option) any later version.
+
+GDB, GAS, and the GNU binutils are distributed in the hope that they
+will be useful, but WITHOUT ANY WARRANTY; without even the implied
+warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See
+the GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this file; see the file COPYING.  If not, write to the Free
+Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "nonstdio.h"
+#include "ansidecl.h"
+#include "ppc.h"
+
+extern void print_address (unsigned long memaddr);
+
+/* Print a PowerPC or POWER instruction.  */
+
+int
+print_insn_powerpc (unsigned long insn, unsigned long memaddr, int dialect)
+{
+  const struct powerpc_opcode *opcode;
+  const struct powerpc_opcode *opcode_end;
+  unsigned long op;
+
+  if (dialect == 0)
+    dialect = PPC_OPCODE_PPC | PPC_OPCODE_CLASSIC | PPC_OPCODE_COMMON
+	      | PPC_OPCODE_64 | PPC_OPCODE_POWER4 | PPC_OPCODE_ALTIVEC;
+
+  /* Get the major opcode of the instruction.  */
+  op = PPC_OP (insn);
+
+  /* Find the first match in the opcode table.  We could speed this up
+     a bit by doing a binary search on the major opcode.  */
+  opcode_end = powerpc_opcodes + powerpc_num_opcodes;
+ again:
+  for (opcode = powerpc_opcodes; opcode < opcode_end; opcode++)
+    {
+      unsigned long table_op;
+      const unsigned char *opindex;
+      const struct powerpc_operand *operand;
+      int invalid;
+      int need_comma;
+      int need_paren;
+
+      table_op = PPC_OP (opcode->opcode);
+      if (op < table_op)
+	break;
+      if (op > table_op)
+	continue;
+
+      if ((insn & opcode->mask) != opcode->opcode
+	  || (opcode->flags & dialect) == 0)
+	continue;
+
+      /* Make two passes over the operands.  First see if any of them
+	 have extraction functions, and, if they do, make sure the
+	 instruction is valid.  */
+      invalid = 0;
+      for (opindex = opcode->operands; *opindex != 0; opindex++)
+	{
+	  operand = powerpc_operands + *opindex;
+	  if (operand->extract)
+	    (*operand->extract) (insn, dialect, &invalid);
+	}
+      if (invalid)
+	continue;
+
+      /* The instruction is valid.  */
+      printf("%s", opcode->name);
+      if (opcode->operands[0] != 0)
+	printf("\t");
+
+      /* Now extract and print the operands.  */
+      need_comma = 0;
+      need_paren = 0;
+      for (opindex = opcode->operands; *opindex != 0; opindex++)
+	{
+	  long value;
+
+	  operand = powerpc_operands + *opindex;
+
+	  /* Operands that are marked FAKE are simply ignored.  We
+	     already made sure that the extract function considered
+	     the instruction to be valid.  */
+	  if ((operand->flags & PPC_OPERAND_FAKE) != 0)
+	    continue;
+
+	  /* Extract the value from the instruction.  */
+	  if (operand->extract)
+	    value = (*operand->extract) (insn, dialect, &invalid);
+	  else
+	    {
+	      value = (insn >> operand->shift) & ((1 << operand->bits) - 1);
+	      if ((operand->flags & PPC_OPERAND_SIGNED) != 0
+		  && (value & (1 << (operand->bits - 1))) != 0)
+		value -= 1 << operand->bits;
+	    }
+
+	  /* If the operand is optional, and the value is zero, don't
+	     print anything.  */
+	  if ((operand->flags & PPC_OPERAND_OPTIONAL) != 0
+	      && (operand->flags & PPC_OPERAND_NEXT) == 0
+	      && value == 0)
+	    continue;
+
+	  if (need_comma)
+	    {
+	      printf(",");
+	      need_comma = 0;
+	    }
+
+	  /* Print the operand as directed by the flags.  */
+	  if ((operand->flags & PPC_OPERAND_GPR) != 0)
+	    printf("r%ld", value);
+	  else if ((operand->flags & PPC_OPERAND_FPR) != 0)
+	    printf("f%ld", value);
+	  else if ((operand->flags & PPC_OPERAND_VR) != 0)
+	    printf("v%ld", value);
+	  else if ((operand->flags & PPC_OPERAND_RELATIVE) != 0)
+	    print_address (memaddr + value);
+	  else if ((operand->flags & PPC_OPERAND_ABSOLUTE) != 0)
+	    print_address (value & 0xffffffff);
+	  else if ((operand->flags & PPC_OPERAND_CR) == 0
+		   || (dialect & PPC_OPCODE_PPC) == 0)
+	    printf("%ld", value);
+	  else
+	    {
+	      if (operand->bits == 3)
+		printf("cr%d", value);
+	      else
+		{
+		  static const char *cbnames[4] = { "lt", "gt", "eq", "so" };
+		  int cr;
+		  int cc;
+
+		  cr = value >> 2;
+		  if (cr != 0)
+		    printf("4*cr%d+", cr);
+		  cc = value & 3;
+		  printf("%s", cbnames[cc]);
+		}
+	    }
+
+	  if (need_paren)
+	    {
+	      printf(")");
+	      need_paren = 0;
+	    }
+
+	  if ((operand->flags & PPC_OPERAND_PARENS) == 0)
+	    need_comma = 1;
+	  else
+	    {
+	      printf("(");
+	      need_paren = 1;
+	    }
+	}
+
+      /* We have found and printed an instruction; return.  */
+      return 4;
+    }
+
+  if ((dialect & PPC_OPCODE_ANY) != 0)
+    {
+      dialect = ~PPC_OPCODE_ANY;
+      goto again;
+    }
+
+  /* We could not find a match.  */
+  printf(".long 0x%lx", insn);
+
+  return 4;
+}
