commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index a11132865504..0fb528c2b3a1 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * PPC 64 oprofile support:
  * Copyright (C) 2004 Anton Blanchard <anton@au.ibm.com>, IBM
@@ -6,11 +7,6 @@
  *	Author: Andy Fleming
  *
  * Based on alpha version.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 #include <linux/oprofile.h>

commit d7cceda96badc1bd444cff27ab9c375a1277c1e3
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Sat Nov 17 10:24:56 2018 +0000

    powerpc: change CONFIG_6xx to CONFIG_PPC_BOOK3S_32
    
    Today we have:
    
    config PPC_BOOK3S_32
            bool "512x/52xx/6xx/7xx/74xx/82xx/83xx/86xx"
            [depends on PPC32 within a choice]
    
    config PPC_BOOK3S
            def_bool y
            depends on PPC_BOOK3S_32 || PPC_BOOK3S_64
    
    config 6xx
            def_bool y
            depends on PPC32 && PPC_BOOK3S
    
    6xx is therefore redundant with PPC_BOOK3S_32.
    
    In order to make the code clearer, lets use preferably PPC_BOOK3S_32.
    This will allow to remove CONFIG_6xx in a later patch.
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index bf094c5a4bd9..a11132865504 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -212,7 +212,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 			model = &op_model_pa6t;
 			break;
 #endif
-#ifdef CONFIG_6xx
+#ifdef CONFIG_PPC_BOOK3S_32
 		case PPC_OPROFILE_G4:
 			model = &op_model_7450;
 			break;

commit 086dddc15fad9db098fc50a030c514696584ddfe
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Jul 10 12:29:23 2014 +1000

    powerpc: Remove oprofile RS64 support
    
    We no longer support these cpus, so we don't need oprofile support for
    them either.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index c77348c5d463..bf094c5a4bd9 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -205,9 +205,6 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 			ops->sync_stop = model->sync_stop;
 			break;
 #endif
-		case PPC_OPROFILE_RS64:
-			model = &op_model_rs64;
-			break;
 		case PPC_OPROFILE_POWER4:
 			model = &op_model_power4;
 			break;

commit 6af4ea0ba708172be8caf1ba5047b2b8a9d2fea3
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jul 19 16:10:36 2013 +0400

    oprofilefs_create_...() do not need superblock argument
    
    same story as with oprofilefs_mkdir()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 60a286b367fc..c77348c5d463 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -128,9 +128,9 @@ static int op_powerpc_create_files(struct dentry *root)
 	 * There is one mmcr0, mmcr1 and mmcra for setting the events for
 	 * all of the counters.
 	 */
-	oprofilefs_create_ulong(root->d_sb, root, "mmcr0", &sys.mmcr0);
-	oprofilefs_create_ulong(root->d_sb, root, "mmcr1", &sys.mmcr1);
-	oprofilefs_create_ulong(root->d_sb, root, "mmcra", &sys.mmcra);
+	oprofilefs_create_ulong(root, "mmcr0", &sys.mmcr0);
+	oprofilefs_create_ulong(root, "mmcr1", &sys.mmcr1);
+	oprofilefs_create_ulong(root, "mmcra", &sys.mmcra);
 #ifdef CONFIG_OPROFILE_CELL
 	/* create a file the user tool can check to see what level of profiling
 	 * support exits with this kernel. Initialize bit mask to indicate
@@ -142,7 +142,7 @@ static int op_powerpc_create_files(struct dentry *root)
 	 * If the file does not exist, then the kernel only supports SPU
 	 * cycle profiling, PPU event and cycle profiling.
 	 */
-	oprofilefs_create_ulong(root->d_sb, root, "cell_support", &sys.cell_support);
+	oprofilefs_create_ulong(root, "cell_support", &sys.cell_support);
 	sys.cell_support = 0x1; /* Note, the user OProfile tool must check
 				 * that this bit is set before attempting to
 				 * user SPU event profiling.  Older kernels
@@ -162,9 +162,9 @@ static int op_powerpc_create_files(struct dentry *root)
 		snprintf(buf, sizeof buf, "%d", i);
 		dir = oprofilefs_mkdir(root, buf);
 
-		oprofilefs_create_ulong(root->d_sb, dir, "enabled", &ctr[i].enabled);
-		oprofilefs_create_ulong(root->d_sb, dir, "event", &ctr[i].event);
-		oprofilefs_create_ulong(root->d_sb, dir, "count", &ctr[i].count);
+		oprofilefs_create_ulong(dir, "enabled", &ctr[i].enabled);
+		oprofilefs_create_ulong(dir, "event", &ctr[i].event);
+		oprofilefs_create_ulong(dir, "count", &ctr[i].count);
 
 		/*
 		 * Classic PowerPC doesn't support per-counter
@@ -173,14 +173,14 @@ static int op_powerpc_create_files(struct dentry *root)
 		 * Book-E style performance monitors, we do
 		 * support them.
 		 */
-		oprofilefs_create_ulong(root->d_sb, dir, "kernel", &ctr[i].kernel);
-		oprofilefs_create_ulong(root->d_sb, dir, "user", &ctr[i].user);
+		oprofilefs_create_ulong(dir, "kernel", &ctr[i].kernel);
+		oprofilefs_create_ulong(dir, "user", &ctr[i].user);
 
-		oprofilefs_create_ulong(root->d_sb, dir, "unit_mask", &ctr[i].unit_mask);
+		oprofilefs_create_ulong(dir, "unit_mask", &ctr[i].unit_mask);
 	}
 
-	oprofilefs_create_ulong(root->d_sb, root, "enable_kernel", &sys.enable_kernel);
-	oprofilefs_create_ulong(root->d_sb, root, "enable_user", &sys.enable_user);
+	oprofilefs_create_ulong(root, "enable_kernel", &sys.enable_kernel);
+	oprofilefs_create_ulong(root, "enable_user", &sys.enable_user);
 
 	/* Default to tracing both kernel and user */
 	sys.enable_kernel = 1;

commit ecde28237e10de3750a97579f42bc2ec65b8a0e1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jul 19 15:58:27 2013 +0400

    oprofilefs_mkdir() doesn't need superblock argument
    
    it's always equal to ->d_sb of the second argument (parent dentry),
    due to either being literally that, or ->d_sb of parent's parent.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index addc62317f45..60a286b367fc 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -160,7 +160,7 @@ static int op_powerpc_create_files(struct dentry *root)
 		char buf[4];
 
 		snprintf(buf, sizeof buf, "%d", i);
-		dir = oprofilefs_mkdir(root->d_sb, root, buf);
+		dir = oprofilefs_mkdir(root, buf);
 
 		oprofilefs_create_ulong(root->d_sb, dir, "enabled", &ctr[i].enabled);
 		oprofilefs_create_ulong(root->d_sb, dir, "event", &ctr[i].event);

commit ef7bca1456e7f65e66b9466c3b149601fe32eec0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Jul 19 15:52:42 2013 +0400

    oprofile: don't bother with passing superblock to ->create_files()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 4f51025f5b00..addc62317f45 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -119,7 +119,7 @@ static void op_powerpc_stop(void)
                 model->global_stop();
 }
 
-static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
+static int op_powerpc_create_files(struct dentry *root)
 {
 	int i;
 
@@ -128,9 +128,9 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 	 * There is one mmcr0, mmcr1 and mmcra for setting the events for
 	 * all of the counters.
 	 */
-	oprofilefs_create_ulong(sb, root, "mmcr0", &sys.mmcr0);
-	oprofilefs_create_ulong(sb, root, "mmcr1", &sys.mmcr1);
-	oprofilefs_create_ulong(sb, root, "mmcra", &sys.mmcra);
+	oprofilefs_create_ulong(root->d_sb, root, "mmcr0", &sys.mmcr0);
+	oprofilefs_create_ulong(root->d_sb, root, "mmcr1", &sys.mmcr1);
+	oprofilefs_create_ulong(root->d_sb, root, "mmcra", &sys.mmcra);
 #ifdef CONFIG_OPROFILE_CELL
 	/* create a file the user tool can check to see what level of profiling
 	 * support exits with this kernel. Initialize bit mask to indicate
@@ -142,7 +142,7 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 	 * If the file does not exist, then the kernel only supports SPU
 	 * cycle profiling, PPU event and cycle profiling.
 	 */
-	oprofilefs_create_ulong(sb, root, "cell_support", &sys.cell_support);
+	oprofilefs_create_ulong(root->d_sb, root, "cell_support", &sys.cell_support);
 	sys.cell_support = 0x1; /* Note, the user OProfile tool must check
 				 * that this bit is set before attempting to
 				 * user SPU event profiling.  Older kernels
@@ -160,11 +160,11 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 		char buf[4];
 
 		snprintf(buf, sizeof buf, "%d", i);
-		dir = oprofilefs_mkdir(sb, root, buf);
+		dir = oprofilefs_mkdir(root->d_sb, root, buf);
 
-		oprofilefs_create_ulong(sb, dir, "enabled", &ctr[i].enabled);
-		oprofilefs_create_ulong(sb, dir, "event", &ctr[i].event);
-		oprofilefs_create_ulong(sb, dir, "count", &ctr[i].count);
+		oprofilefs_create_ulong(root->d_sb, dir, "enabled", &ctr[i].enabled);
+		oprofilefs_create_ulong(root->d_sb, dir, "event", &ctr[i].event);
+		oprofilefs_create_ulong(root->d_sb, dir, "count", &ctr[i].count);
 
 		/*
 		 * Classic PowerPC doesn't support per-counter
@@ -173,14 +173,14 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 		 * Book-E style performance monitors, we do
 		 * support them.
 		 */
-		oprofilefs_create_ulong(sb, dir, "kernel", &ctr[i].kernel);
-		oprofilefs_create_ulong(sb, dir, "user", &ctr[i].user);
+		oprofilefs_create_ulong(root->d_sb, dir, "kernel", &ctr[i].kernel);
+		oprofilefs_create_ulong(root->d_sb, dir, "user", &ctr[i].user);
 
-		oprofilefs_create_ulong(sb, dir, "unit_mask", &ctr[i].unit_mask);
+		oprofilefs_create_ulong(root->d_sb, dir, "unit_mask", &ctr[i].unit_mask);
 	}
 
-	oprofilefs_create_ulong(sb, root, "enable_kernel", &sys.enable_kernel);
-	oprofilefs_create_ulong(sb, root, "enable_user", &sys.enable_user);
+	oprofilefs_create_ulong(root->d_sb, root, "enable_kernel", &sys.enable_kernel);
+	oprofilefs_create_ulong(root->d_sb, root, "enable_user", &sys.enable_user);
 
 	/* Default to tracing both kernel and user */
 	sys.enable_kernel = 1;

commit ae3a197e3d0bfe3f4bf1693723e82dc018c096f3
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for PowerPC
    
    Disintegrate asm/system.h for PowerPC.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    cc: linuxppc-dev@lists.ozlabs.org

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 6f01624f317f..4f51025f5b00 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -18,7 +18,6 @@
 #include <linux/smp.h>
 #include <linux/errno.h>
 #include <asm/ptrace.h>
-#include <asm/system.h>
 #include <asm/pmc.h>
 #include <asm/cputable.h>
 #include <asm/oprofile_impl.h>

commit f5339277eb8d3aed37f12a27988366f68ab68930
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Mar 15 18:18:00 2012 +0000

    powerpc: Remove FW_FEATURE ISERIES from arch code
    
    This is no longer selectable, so just remove all the dependent code.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index d65e68f3cb25..6f01624f317f 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -195,9 +195,6 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	if (!cur_cpu_spec->oprofile_cpu_type)
 		return -ENODEV;
 
-	if (firmware_has_feature(FW_FEATURE_ISERIES))
-		return -ENODEV;
-
 	switch (cur_cpu_spec->oprofile_type) {
 #ifdef CONFIG_PPC_BOOK3S_64
 #ifdef CONFIG_OPROFILE_CELL

commit 1caca371e80b0d40352512806368f6ff43e2cf52
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Jul 9 15:18:44 2010 +1000

    powerpc/oprofile: Don't build server oprofile drivers on 64-bit BookE
    
    They will fail to build due to the lack of mtmsrd, and wouldn't
    be useful anyways
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 21f16edf6c8d..d65e68f3cb25 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -199,7 +199,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 		return -ENODEV;
 
 	switch (cur_cpu_spec->oprofile_type) {
-#ifdef CONFIG_PPC64
+#ifdef CONFIG_PPC_BOOK3S_64
 #ifdef CONFIG_OPROFILE_CELL
 		case PPC_OPROFILE_CELL:
 			if (firmware_has_feature(FW_FEATURE_LPAR))

commit 883823291d22e06736f1056da6d8303291d6bbf9
Author: Carl Love <cel@us.ibm.com>
Date:   Mon Dec 1 16:18:36 2008 -0800

    powerpc/oprofile: IBM CELL: add SPU event profiling support
    
    This patch adds the SPU event based profiling funcitonality for the
    IBM Cell processor.  Previously, the CELL OProfile kernel code supported
    PPU event, PPU cycle profiling and SPU cycle profiling.   The addition of
    SPU event profiling allows the users to identify where in their SPU code
    various SPU evnets are occuring.  This should help users further identify
    issues with their code.  Note, SPU profiling has some limitations due to HW
    constraints.  Only one event at a time can be used for profiling and SPU event
    profiling must be time sliced across all of the SPUs in a node.
    
    The patch adds a new arch specific file to the OProfile file system. The
    file has bit 0 set to indicate that the kernel supports SPU event profiling.
    The user tool must check this file/bit to make sure the kernel supports
    SPU event profiling before trying to do SPU event profiling.  The user tool
    check is part of the user tool patch for SPU event profiling.
    
    Signed-off-by: Carl Love <carll@us.ibm.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 17807acb05d9..21f16edf6c8d 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -132,6 +132,28 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 	oprofilefs_create_ulong(sb, root, "mmcr0", &sys.mmcr0);
 	oprofilefs_create_ulong(sb, root, "mmcr1", &sys.mmcr1);
 	oprofilefs_create_ulong(sb, root, "mmcra", &sys.mmcra);
+#ifdef CONFIG_OPROFILE_CELL
+	/* create a file the user tool can check to see what level of profiling
+	 * support exits with this kernel. Initialize bit mask to indicate
+	 * what support the kernel has:
+	 * bit 0      -  Supports SPU event profiling in addition to PPU
+	 *               event and cycles; and SPU cycle profiling
+	 * bits 1-31  -  Currently unused.
+	 *
+	 * If the file does not exist, then the kernel only supports SPU
+	 * cycle profiling, PPU event and cycle profiling.
+	 */
+	oprofilefs_create_ulong(sb, root, "cell_support", &sys.cell_support);
+	sys.cell_support = 0x1; /* Note, the user OProfile tool must check
+				 * that this bit is set before attempting to
+				 * user SPU event profiling.  Older kernels
+				 * will not have this file, hence the user
+				 * tool is not allowed to do SPU event
+				 * profiling on older kernels.  Older kernels
+				 * will accept SPU events but collected data
+				 * is garbage.
+				 */
+#endif
 #endif
 
 	for (i = 0; i < model->num_counters; ++i) {

commit 15c8b6c1aaaf1c4edd67e2f02e4d8e1bd1a51c0d
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Fri May 9 09:39:44 2008 +0200

    on_each_cpu(): kill unused 'retry' parameter
    
    It's not even passed on to smp_call_function() anymore, since that
    was removed. So kill it.
    
    Acked-by: Jeremy Fitzhardinge <jeremy.fitzhardinge@citrix.com>
    Reviewed-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 4908dc98f9ca..17807acb05d9 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -65,7 +65,7 @@ static int op_powerpc_setup(void)
 
 	/* Configure the registers on all cpus.	 If an error occurs on one
 	 * of the cpus, op_per_cpu_rc will be set to the error */
-	on_each_cpu(op_powerpc_cpu_setup, NULL, 0, 1);
+	on_each_cpu(op_powerpc_cpu_setup, NULL, 1);
 
 out:	if (op_per_cpu_rc) {
 		/* error on setup release the performance counter hardware */
@@ -100,7 +100,7 @@ static int op_powerpc_start(void)
 	if (model->global_start)
 		return model->global_start(ctr);
 	if (model->start) {
-		on_each_cpu(op_powerpc_cpu_start, NULL, 0, 1);
+		on_each_cpu(op_powerpc_cpu_start, NULL, 1);
 		return op_per_cpu_rc;
 	}
 	return -EIO; /* No start function is defined for this
@@ -115,7 +115,7 @@ static inline void op_powerpc_cpu_stop(void *dummy)
 static void op_powerpc_stop(void)
 {
 	if (model->stop)
-		on_each_cpu(op_powerpc_cpu_stop, NULL, 0, 1);
+		on_each_cpu(op_powerpc_cpu_stop, NULL, 1);
         if (model->global_stop)
                 model->global_stop();
 }

commit 39aef685af431c032ffd2763ec8782b13c32520c
Author: Andy Fleming <afleming@freescale.com>
Date:   Mon Feb 4 18:27:55 2008 -0600

    [POWERPC] Made FSL Book-E PMC support more generic
    
    Some of the more recent e300 cores have the same performance monitor
    implementation as the e500.  e300 isn't book-e, so the name isn't
    really appropriate.  In preparation for e300 support, rename a bunch
    of fsl_booke things to say fsl_emb (Freescale Embedded Performance Monitors).
    
    Signed-off-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index a28cce1d6c24..4908dc98f9ca 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -202,9 +202,9 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 			model = &op_model_7450;
 			break;
 #endif
-#ifdef CONFIG_FSL_BOOKE
-		case PPC_OPROFILE_BOOKE:
-			model = &op_model_fsl_booke;
+#if defined(CONFIG_FSL_EMB_PERFMON)
+		case PPC_OPROFILE_FSL_EMB:
+			model = &op_model_fsl_emb;
 			break;
 #endif
 		default:

commit 1474855d0878cced6f39f51f3c2bd7428b44cb1e
Author: Bob Nelson <rrnelson@linux.vnet.ibm.com>
Date:   Fri Jul 20 21:39:53 2007 +0200

    [CELL] oprofile: add support to OProfile for profiling CELL BE SPUs
    
    From: Maynard Johnson <mpjohn@us.ibm.com>
    
    This patch updates the existing arch/powerpc/oprofile/op_model_cell.c
    to add in the SPU profiling capabilities.  In addition, a 'cell' subdirectory
    was added to arch/powerpc/oprofile to hold Cell-specific SPU profiling code.
    Exports spu_set_profile_private_kref and spu_get_profile_private_kref which
    are used by OProfile to store private profile information in spufs data
    structures.
    
    Also incorporated several fixes from other patches (rrn).  Check pointer
    returned from kzalloc.  Eliminated unnecessary cast.  Better error
    handling and cleanup in the related area.  64-bit unsigned long parameter
    was being demoted to 32-bit unsigned int and eventually promoted back to
    unsigned long.
    
    Signed-off-by: Carl Love <carll@us.ibm.com>
    Signed-off-by: Maynard Johnson <mpjohn@us.ibm.com>
    Signed-off-by: Bob Nelson <rrnelson@us.ibm.com>
    Signed-off-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>
    Acked-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 1a7ef7e246d2..a28cce1d6c24 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -29,6 +29,8 @@ static struct op_powerpc_model *model;
 static struct op_counter_config ctr[OP_MAX_COUNTER];
 static struct op_system_config sys;
 
+static int op_per_cpu_rc;
+
 static void op_handle_interrupt(struct pt_regs *regs)
 {
 	model->handle_interrupt(regs, ctr);
@@ -36,25 +38,41 @@ static void op_handle_interrupt(struct pt_regs *regs)
 
 static void op_powerpc_cpu_setup(void *dummy)
 {
-	model->cpu_setup(ctr);
+	int ret;
+
+	ret = model->cpu_setup(ctr);
+
+	if (ret != 0)
+		op_per_cpu_rc = ret;
 }
 
 static int op_powerpc_setup(void)
 {
 	int err;
 
+	op_per_cpu_rc = 0;
+
 	/* Grab the hardware */
 	err = reserve_pmc_hardware(op_handle_interrupt);
 	if (err)
 		return err;
 
 	/* Pre-compute the values to stuff in the hardware registers.  */
-	model->reg_setup(ctr, &sys, model->num_counters);
+	op_per_cpu_rc = model->reg_setup(ctr, &sys, model->num_counters);
 
-	/* Configure the registers on all cpus.  */
+	if (op_per_cpu_rc)
+		goto out;
+
+	/* Configure the registers on all cpus.	 If an error occurs on one
+	 * of the cpus, op_per_cpu_rc will be set to the error */
 	on_each_cpu(op_powerpc_cpu_setup, NULL, 0, 1);
 
-	return 0;
+out:	if (op_per_cpu_rc) {
+		/* error on setup release the performance counter hardware */
+		release_pmc_hardware();
+	}
+
+	return op_per_cpu_rc;
 }
 
 static void op_powerpc_shutdown(void)
@@ -64,16 +82,29 @@ static void op_powerpc_shutdown(void)
 
 static void op_powerpc_cpu_start(void *dummy)
 {
-	model->start(ctr);
+	/* If any of the cpus have return an error, set the
+	 * global flag to the error so it can be returned
+	 * to the generic OProfile caller.
+	 */
+	int ret;
+
+	ret = model->start(ctr);
+	if (ret != 0)
+		op_per_cpu_rc = ret;
 }
 
 static int op_powerpc_start(void)
 {
+	op_per_cpu_rc = 0;
+
 	if (model->global_start)
-		model->global_start(ctr);
-	if (model->start)
+		return model->global_start(ctr);
+	if (model->start) {
 		on_each_cpu(op_powerpc_cpu_start, NULL, 0, 1);
-	return 0;
+		return op_per_cpu_rc;
+	}
+	return -EIO; /* No start function is defined for this
+			power architecture */
 }
 
 static inline void op_powerpc_cpu_stop(void *dummy)
@@ -147,11 +178,13 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 
 	switch (cur_cpu_spec->oprofile_type) {
 #ifdef CONFIG_PPC64
-#ifdef CONFIG_PPC_CELL_NATIVE
+#ifdef CONFIG_OPROFILE_CELL
 		case PPC_OPROFILE_CELL:
 			if (firmware_has_feature(FW_FEATURE_LPAR))
 				return -ENODEV;
 			model = &op_model_cell;
+			ops->sync_start = model->sync_start;
+			ops->sync_stop = model->sync_stop;
 			break;
 #endif
 		case PPC_OPROFILE_RS64:

commit 25fc530eed1ca9ccde2a1e96d0b2060867f76bb2
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Apr 18 16:38:21 2007 +1000

    [POWERPC] pasemi: PA6T oprofile support
    
    Oprofile support for PA6T, kernel side.
    
    Also rename the PA6T_SPRN.* defines to SPRN_PA6T.*.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index fbd62eacfdf4..1a7ef7e246d2 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -160,6 +160,9 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 		case PPC_OPROFILE_POWER4:
 			model = &op_model_power4;
 			break;
+		case PPC_OPROFILE_PA6T:
+			model = &op_model_pa6t;
+			break;
 #endif
 #ifdef CONFIG_6xx
 		case PPC_OPROFILE_G4:

commit ef66f796751a214dc8fadaef2f068c3baa8969fa
Author: Ishizaki Kou <kou.ishizaki@toshiba.co.jp>
Date:   Fri Jan 12 09:56:44 2007 +0900

    [POWERPC] Fix oprofile support on Cell LPAR
    
    Op_model_cell supports native Cell. By returning -EINVAL, oprofile
    uses timer interrupt on Cell LPAR.
    
    Signed-off-by: Kou Ishizaki <kou.ishizaki@toshiba.co.jp>
    Acked-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index b6d82390b6a6..fbd62eacfdf4 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -149,6 +149,8 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 #ifdef CONFIG_PPC64
 #ifdef CONFIG_PPC_CELL_NATIVE
 		case PPC_OPROFILE_CELL:
+			if (firmware_has_feature(FW_FEATURE_LPAR))
+				return -ENODEV;
 			model = &op_model_cell;
 			break;
 #endif

commit e22ba7e38144c1cccac5024cfd6ec88bb64d3e1f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Nov 27 19:18:57 2006 +0100

    [POWERPC] ps3: multiplatform build fixes
    
    A few code paths need to check whether or not they are running
    on the PS3's LV1 hypervisor before making hcalls. This introduces
    a new firmware feature bit for this, FW_FEATURE_PS3_LV1.
    
    Now when both PS3 and IBM_CELL_BLADE are enabled, but not PSERIES,
    FW_FEATURE_PS3_LV1 and FW_FEATURE_LPAR get enabled at compile time,
    which is a bug. The same problem can also happen for (PPC_ISERIES &&
    !PPC_PSERIES && PPC_SOMETHING_ELSE). In order to solve this, I
    introduce a new CONFIG_PPC_NATIVE option that is set when at least
    one platform is selected that can run without a hypervisor and then
    turns the firmware feature check into a run-time option.
    
    The new cell oprofile support that was recently merged does not
    work on hypervisor based platforms like the PS3, therefore make
    it depend on PPC_CELL_NATIVE instead of PPC_CELL. This may change
    if we get oprofile support for PS3.
    
    Signed-off-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 7a423437977c..b6d82390b6a6 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -147,7 +147,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 
 	switch (cur_cpu_spec->oprofile_type) {
 #ifdef CONFIG_PPC64
-#ifdef CONFIG_PPC_CELL
+#ifdef CONFIG_PPC_CELL_NATIVE
 		case PPC_OPROFILE_CELL:
 			model = &op_model_cell;
 			break;

commit 18f2190d796198fbb5d4bc4c87511acf3ced7d47
Author: Maynard Johnson <maynardj@us.ibm.com>
Date:   Mon Nov 20 18:45:16 2006 +0100

    [POWERPC] cell: Add oprofile support
    
    Add PPU event-based and cycle-based profiling support to Oprofile for Cell.
    
    Oprofile is expected to collect data on all CPUs simultaneously.
    However, there is one set of performance counters per node.  There are
    two hardware threads or virtual CPUs on each node.  Hence, OProfile must
    multiplex in time the performance counter collection on the two virtual
    CPUs.
    
    The multiplexing of the performance counters is done by a virtual
    counter routine.  Initially, the counters are configured to collect data
    on the even CPUs in the system, one CPU per node.  In order to capture
    the PC for the virtual CPU when the performance counter interrupt occurs
    (the specified number of events between samples has occurred), the even
    processors are configured to handle the performance counter interrupts
    for their node.  The virtual counter routine is called via a kernel
    timer after the virtual sample time.  The routine stops the counters,
    saves the current counts, loads the last counts for the other virtual
    CPU on the node, sets interrupts to be handled by the other virtual CPU
    and restarts the counters, the virtual timer routine is scheduled to run
    again.  The virtual sample time is kept relatively small to make sure
    sampling occurs on both CPUs on the node with a relatively small
    granularity.  Whenever the counters overflow, the performance counter
    interrupt is called to collect the PC for the CPU where data is being
    collected.
    
    The oprofile driver relies on a firmware RTAS call to setup the debug bus
    to route the desired signals to the performance counter hardware to be
    counted.  The RTAS call must set the routing registers appropriately in
    each of the islands to pass the signals down the debug bus as well as
    routing the signals from a particular island onto the bus.  There is a
    second firmware RTAS call to reset the debug bus to the non pass thru
    state when the counters are not in use.
    
    Signed-off-by: Carl Love <carll@us.ibm.com>
    Signed-off-by: Maynard Johnson <mpjohn@us.ibm.com>
    Signed-off-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 63bbef3b63f1..7a423437977c 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -69,7 +69,10 @@ static void op_powerpc_cpu_start(void *dummy)
 
 static int op_powerpc_start(void)
 {
-	on_each_cpu(op_powerpc_cpu_start, NULL, 0, 1);
+	if (model->global_start)
+		model->global_start(ctr);
+	if (model->start)
+		on_each_cpu(op_powerpc_cpu_start, NULL, 0, 1);
 	return 0;
 }
 
@@ -80,7 +83,10 @@ static inline void op_powerpc_cpu_stop(void *dummy)
 
 static void op_powerpc_stop(void)
 {
-	on_each_cpu(op_powerpc_cpu_stop, NULL, 0, 1);
+	if (model->stop)
+		on_each_cpu(op_powerpc_cpu_stop, NULL, 0, 1);
+        if (model->global_stop)
+                model->global_stop();
 }
 
 static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
@@ -141,6 +147,11 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 
 	switch (cur_cpu_spec->oprofile_type) {
 #ifdef CONFIG_PPC64
+#ifdef CONFIG_PPC_CELL
+		case PPC_OPROFILE_CELL:
+			model = &op_model_cell;
+			break;
+#endif
 		case PPC_OPROFILE_RS64:
 			model = &op_model_rs64;
 			break;

commit dd6c89f686bdb2a5de72fab636fc839e5a0add6d
Author: Andy Fleming <afleming@freescale.com>
Date:   Fri Oct 27 15:06:32 2006 -0500

    [POWERPC] Fix oprofile support for e500 in arch/powerpc
    
    Fixed a compile error in building the 85xx support with oprofile, and in
    the process cleaned up some issues with the fsl_booke performance monitor
    code.
    
    * Reorganized FSL Book-E performance monitoring code so that the 7450
      wouldn't be built if the e500 was, and cleaned it up so it was more
      self-contained.
    
    * Added a cpu_setup function for FSL Book-E.  The original
      cpu_setup function prototype had no arguments, assuming that
      the reg_setup function would copy the required information into
      variables which represented the registers.  This was silly for
      e500, since it has 1 register per counter (rather than 3 for
      all counters), so the code has been restructured to have
      cpu_setup take the current counter config array as an argument,
      with op_powerpc_setup() invoking op_powerpc_cpu_setup() through
      on_each_cpu(), and op_powerpc_cpu_setup() invoking the
      model-specific cpu_setup function with an argument.  The
      argument is ignored on all other platforms at present.
    
    * Fixed a confusing line where a trinary operator only had two
      arguments
    
    Signed-off-by: Andrew Fleming <afleming@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index fd0bbbe7a4de..63bbef3b63f1 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -34,6 +34,11 @@ static void op_handle_interrupt(struct pt_regs *regs)
 	model->handle_interrupt(regs, ctr);
 }
 
+static void op_powerpc_cpu_setup(void *dummy)
+{
+	model->cpu_setup(ctr);
+}
+
 static int op_powerpc_setup(void)
 {
 	int err;
@@ -47,7 +52,7 @@ static int op_powerpc_setup(void)
 	model->reg_setup(ctr, &sys, model->num_counters);
 
 	/* Configure the registers on all cpus.  */
-	on_each_cpu(model->cpu_setup, NULL, 0, 1);
+	on_each_cpu(op_powerpc_cpu_setup, NULL, 0, 1);
 
 	return 0;
 }
@@ -142,7 +147,8 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 		case PPC_OPROFILE_POWER4:
 			model = &op_model_power4;
 			break;
-#else
+#endif
+#ifdef CONFIG_6xx
 		case PPC_OPROFILE_G4:
 			model = &op_model_7450;
 			break;

commit 0c6856f702732d3cfc33eb59303e998ad6961de8
Author: Markus Armbruster <armbru@redhat.com>
Date:   Mon Jun 26 00:24:34 2006 -0700

    [PATCH] oprofile: Fix unnecessary cleverness
    
    nmi_create_files() in arch/i386/oprofile/nmi_int.c depends on
    model->num_counters (number of performance counters) being less than 10.
    While this is currently the case, it's too clever by half.
    
    Other archs aren't quite as clever: they assume 100.  I suggest to
    normalize them all to 1000.
    
    Cc: Philippe Elie <phil.el@wanadoo.fr>
    Cc: John Levon <levon@movementarian.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 27ad56bd227e..fd0bbbe7a4de 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -94,7 +94,7 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 
 	for (i = 0; i < model->num_counters; ++i) {
 		struct dentry *dir;
-		char buf[3];
+		char buf[4];
 
 		snprintf(buf, sizeof buf, "%d", i);
 		dir = oprofilefs_mkdir(sb, root, buf);

commit 2191fe3e39159e3375f4b7ec1420df149f154101
Author: Kelly Daly <kelly@au1.ibm.com>
Date:   Wed Jun 21 13:52:55 2006 +1000

    [POWERPC] re-enable OProfile for iSeries, using timer interrupt
    
    This patch removes the changes from an earlier patch that disables
    oProfile for iSeries within the oProfile KConfig (submitted Feb 23,
    2006).  Checks within the arch init for iSeries, still allowing profiling
    for timer interrupts (using firmware_has_feature).
    
    Signed-off-by: Kelly Daly <kelly@au.ibm.com>
    Acked-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 38a2f9c17187..27ad56bd227e 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -22,6 +22,7 @@
 #include <asm/pmc.h>
 #include <asm/cputable.h>
 #include <asm/oprofile_impl.h>
+#include <asm/firmware.h>
 
 static struct op_powerpc_model *model;
 
@@ -130,6 +131,9 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	if (!cur_cpu_spec->oprofile_cpu_type)
 		return -ENODEV;
 
+	if (firmware_has_feature(FW_FEATURE_ISERIES))
+		return -ENODEV;
+
 	switch (cur_cpu_spec->oprofile_type) {
 #ifdef CONFIG_PPC64
 		case PPC_OPROFILE_RS64:

commit 5e1415c3f7d3ad133edb7ce9ca90641cf0f5fe79
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Apr 12 15:29:00 2006 -0500

    [PATCH] powerpc: Quiet oprofile output at boot
    
    No need to always print out which performance monitoring type is used
    on the console at every boot.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 5b1de7e8041e..38a2f9c17187 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -162,7 +162,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	ops->stop = op_powerpc_stop;
 	ops->backtrace = op_powerpc_backtrace;
 
-	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
+	printk(KERN_DEBUG "oprofile: using %s performance monitoring.\n",
 	       ops->cpu_type);
 
 	return 0;

commit 15e812ad849e142e3dfc984d33c4d8042389f148
Author: Anton Blanchard <anton@samba.org>
Date:   Mon Mar 27 12:00:45 2006 +1100

    [PATCH] powerpc: Remove oprofile spinlock backtrace code
    
    Remove oprofile spinlock backtrace code now we have proper calltrace
    support. Also make MMCRA sihv and sipr bits a variable since they may
    change in future cpus. Finally, MMCRA should be a 64bit quantity.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 2b9143b0f6ba..5b1de7e8041e 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -117,17 +117,10 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 
 	oprofilefs_create_ulong(sb, root, "enable_kernel", &sys.enable_kernel);
 	oprofilefs_create_ulong(sb, root, "enable_user", &sys.enable_user);
-#ifdef CONFIG_PPC64
-	oprofilefs_create_ulong(sb, root, "backtrace_spinlocks",
-				&sys.backtrace_spinlocks);
-#endif
 
 	/* Default to tracing both kernel and user */
 	sys.enable_kernel = 1;
 	sys.enable_user = 1;
-#ifdef CONFIG_PPC64
-	sys.backtrace_spinlocks = 0;
-#endif
 
 	return 0;
 }

commit 6c6bd754bf43d59756f094de144ecac239629dda
Author: Brian Rogan <bcr6@cornell.edu>
Date:   Mon Mar 27 11:57:01 2006 +1100

    [PATCH] powerpc: Add oprofile calltrace support
    
    Add oprofile calltrace support to powerpc. Disable spinlock backtracing
    now we can use calltrace info.
    
    (Updated to work on both 32bit and 64bit by me).
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index cc2535be3a73..2b9143b0f6ba 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -126,8 +126,7 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 	sys.enable_kernel = 1;
 	sys.enable_user = 1;
 #ifdef CONFIG_PPC64
-	/* Turn on backtracing through spinlocks by default */
-	sys.backtrace_spinlocks = 1;
+	sys.backtrace_spinlocks = 0;
 #endif
 
 	return 0;
@@ -168,6 +167,7 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	ops->shutdown = op_powerpc_shutdown;
 	ops->start = op_powerpc_start;
 	ops->stop = op_powerpc_stop;
+	ops->backtrace = op_powerpc_backtrace;
 
 	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
 	       ops->cpu_type);

commit 7a45fb19cef93574230827e6e2c97ad5760ddecd
Author: Andy Whitcroft <apw@shadowen.org>
Date:   Fri Jan 13 12:35:49 2006 +0000

    [PATCH] powerpc: oprofile cpu type names clash with other code
    
    In 2.6.15-git6 a change was commited in the oprofile support in
    the powerpc architecture.  It introduced the powerpc_oprofile_type
    which contains the define G4.  This causes a name clash with the
    existing wacom usb tablet driver.
    
          CC [M]  drivers/usb/input/wacom.o
        drivers/usb/input/wacom.c:98: error: conflicting types for `G4'
        include/asm/cputable.h:37: error: previous declaration of `G4'
          CC [M]  drivers/usb/mon/mon_text.o
        make[3]: *** [drivers/usb/input/wacom.o] Error 1
        make[2]: *** [drivers/usb/input] Error 2
    
    The elements of an enum declared in global scope are effectivly
    global identifiers themselves.  As such we need to ensure the names
    are unique.  This patch updates the later oprofile support to use
    unique names.
    
    Signed-off-by: Andy Whitcroft <apw@shadowen.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 71615eb70b2b..cc2535be3a73 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -140,19 +140,19 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 
 	switch (cur_cpu_spec->oprofile_type) {
 #ifdef CONFIG_PPC64
-		case RS64:
+		case PPC_OPROFILE_RS64:
 			model = &op_model_rs64;
 			break;
-		case POWER4:
+		case PPC_OPROFILE_POWER4:
 			model = &op_model_power4;
 			break;
 #else
-		case G4:
+		case PPC_OPROFILE_G4:
 			model = &op_model_7450;
 			break;
 #endif
 #ifdef CONFIG_FSL_BOOKE
-		case BOOKE:
+		case PPC_OPROFILE_BOOKE:
 			model = &op_model_fsl_booke;
 			break;
 #endif

commit 32a33994d513606d29e87e152deb67ba5f3c8e82
Author: Anton Blanchard <anton@samba.org>
Date:   Mon Jan 9 15:41:31 2006 +1100

    [PATCH] ppc64: Fix oprofile when compiled as a module
    
    My recent changes to oprofile broke it when built as a module. Fix it by
    using an enum instead of a function pointer. This way we still retain
    the oprofile configuration in the cputable.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index a370778b68dd..71615eb70b2b 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -135,9 +135,31 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
-	if (!cur_cpu_spec->oprofile_model || !cur_cpu_spec->oprofile_cpu_type)
+	if (!cur_cpu_spec->oprofile_cpu_type)
 		return -ENODEV;
-	model = cur_cpu_spec->oprofile_model;
+
+	switch (cur_cpu_spec->oprofile_type) {
+#ifdef CONFIG_PPC64
+		case RS64:
+			model = &op_model_rs64;
+			break;
+		case POWER4:
+			model = &op_model_power4;
+			break;
+#else
+		case G4:
+			model = &op_model_7450;
+			break;
+#endif
+#ifdef CONFIG_FSL_BOOKE
+		case BOOKE:
+			model = &op_model_fsl_booke;
+			break;
+#endif
+		default:
+			return -ENODEV;
+	}
+
 	model->num_counters = cur_cpu_spec->num_pmcs;
 
 	ops->cpu_type = cur_cpu_spec->oprofile_cpu_type;

commit 555d97ac87aef08bb55dff6f05e68fe2987d6f6d
Author: Andy Fleming <afleming@freescale.com>
Date:   Thu Dec 15 20:02:04 2005 -0600

    [PATCH] powerpc: G4+ oprofile support
    
    This patch adds oprofile support for the 7450 and all its multitudinous
    derivatives.
    
    * Added 7450 (and derivatives) support for oprofile
    * Changed e500 cputable to have oprofile model and cpu_type fields
    * Added support for classic 32-bit performance monitor interrupt
    * Cleaned up common powerpc oprofile code to be as common as possible
    * Cleaned up oprofile_impl.h to reflect 32 bit classic code
    * Added 32-bit MMCRx bitfield definitions and SPR numbers
    
    Signed-off-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index af2c05d20ba5..a370778b68dd 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -14,9 +14,6 @@
  */
 
 #include <linux/oprofile.h>
-#ifndef __powerpc64__
-#include <linux/slab.h>
-#endif /* ! __powerpc64__ */
 #include <linux/init.h>
 #include <linux/smp.h>
 #include <linux/errno.h>
@@ -31,10 +28,6 @@ static struct op_powerpc_model *model;
 static struct op_counter_config ctr[OP_MAX_COUNTER];
 static struct op_system_config sys;
 
-#ifndef __powerpc64__
-static char *cpu_type;
-#endif /* ! __powerpc64__ */
-
 static void op_handle_interrupt(struct pt_regs *regs)
 {
 	model->handle_interrupt(regs, ctr);
@@ -53,14 +46,7 @@ static int op_powerpc_setup(void)
 	model->reg_setup(ctr, &sys, model->num_counters);
 
 	/* Configure the registers on all cpus.  */
-#ifdef __powerpc64__
 	on_each_cpu(model->cpu_setup, NULL, 0, 1);
-#else /* __powerpc64__ */
-#if 0
-	/* FIXME: Make multi-cpu work */
-	on_each_cpu(model->reg_setup, NULL, 0, 1);
-#endif
-#endif /* __powerpc64__ */
 
 	return 0;
 }
@@ -95,7 +81,7 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 {
 	int i;
 
-#ifdef __powerpc64__
+#ifdef CONFIG_PPC64
 	/*
 	 * There is one mmcr0, mmcr1 and mmcra for setting the events for
 	 * all of the counters.
@@ -103,7 +89,7 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 	oprofilefs_create_ulong(sb, root, "mmcr0", &sys.mmcr0);
 	oprofilefs_create_ulong(sb, root, "mmcr1", &sys.mmcr1);
 	oprofilefs_create_ulong(sb, root, "mmcra", &sys.mmcra);
-#endif /* __powerpc64__ */
+#endif
 
 	for (i = 0; i < model->num_counters; ++i) {
 		struct dentry *dir;
@@ -115,65 +101,46 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 		oprofilefs_create_ulong(sb, dir, "enabled", &ctr[i].enabled);
 		oprofilefs_create_ulong(sb, dir, "event", &ctr[i].event);
 		oprofilefs_create_ulong(sb, dir, "count", &ctr[i].count);
-#ifdef __powerpc64__
+
 		/*
-		 * We dont support per counter user/kernel selection, but
-		 * we leave the entries because userspace expects them
+		 * Classic PowerPC doesn't support per-counter
+		 * control like this, but the options are
+		 * expected, so they remain.  For Freescale
+		 * Book-E style performance monitors, we do
+		 * support them.
 		 */
-#endif /* __powerpc64__ */
 		oprofilefs_create_ulong(sb, dir, "kernel", &ctr[i].kernel);
 		oprofilefs_create_ulong(sb, dir, "user", &ctr[i].user);
 
-#ifndef __powerpc64__
-		/* FIXME: Not sure if this is used */
-#endif /* ! __powerpc64__ */
 		oprofilefs_create_ulong(sb, dir, "unit_mask", &ctr[i].unit_mask);
 	}
 
 	oprofilefs_create_ulong(sb, root, "enable_kernel", &sys.enable_kernel);
 	oprofilefs_create_ulong(sb, root, "enable_user", &sys.enable_user);
-#ifdef __powerpc64__
+#ifdef CONFIG_PPC64
 	oprofilefs_create_ulong(sb, root, "backtrace_spinlocks",
 				&sys.backtrace_spinlocks);
-#endif /* __powerpc64__ */
+#endif
 
 	/* Default to tracing both kernel and user */
 	sys.enable_kernel = 1;
 	sys.enable_user = 1;
-#ifdef __powerpc64__
+#ifdef CONFIG_PPC64
 	/* Turn on backtracing through spinlocks by default */
 	sys.backtrace_spinlocks = 1;
-#endif /* __powerpc64__ */
+#endif
 
 	return 0;
 }
 
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
-#ifndef __powerpc64__
-#ifdef CONFIG_FSL_BOOKE
-	model = &op_model_fsl_booke;
-#else
-	return -ENODEV;
-#endif
-
-	cpu_type = kmalloc(32, GFP_KERNEL);
-	if (NULL == cpu_type)
-		return -ENOMEM;
-
-	sprintf(cpu_type, "ppc/%s", cur_cpu_spec->cpu_name);
-
-	model->num_counters = cur_cpu_spec->num_pmcs;
-
-	ops->cpu_type = cpu_type;
-#else /* __powerpc64__ */
 	if (!cur_cpu_spec->oprofile_model || !cur_cpu_spec->oprofile_cpu_type)
 		return -ENODEV;
 	model = cur_cpu_spec->oprofile_model;
 	model->num_counters = cur_cpu_spec->num_pmcs;
 
 	ops->cpu_type = cur_cpu_spec->oprofile_cpu_type;
-#endif /* __powerpc64__ */
 	ops->create_files = op_powerpc_create_files;
 	ops->setup = op_powerpc_setup;
 	ops->shutdown = op_powerpc_shutdown;
@@ -188,8 +155,4 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 
 void oprofile_arch_exit(void)
 {
-#ifndef __powerpc64__
-	kfree(cpu_type);
-	cpu_type = NULL;
-#endif /* ! __powerpc64__ */
 }

commit f7f6f4fea68d9981d65f99a589ad85f510924d99
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Wed Oct 19 14:53:32 2005 +1000

    [PATCH] powerpc: Merge ppc64 pmc.[ch] with ppc32 perfmon.[ch]
    
    This patches the ppc32 and ppc64 versions of the headers and .c files
    with helper functions for manipulating the performance counting
    hardware.  As a side effect, it removes use of the term "perfmon" from
    ppc32, thus avoiding confusion with the unrelated performance counter
    interface from HP Labs also called "perfmon".
    
    Built, but not booted, for g5, pSeries, iSeries, and 32-bit Powermac
    with both ARCH=powerpc and ARCH=ppc{,64} as appropriate.
    
    Signed-off-by: David Gibson <dwg@au1.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 0ec12c8f2c01..af2c05d20ba5 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -22,11 +22,7 @@
 #include <linux/errno.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
-#ifdef __powerpc64__
 #include <asm/pmc.h>
-#else /* __powerpc64__ */
-#include <asm/perfmon.h>
-#endif /* __powerpc64__ */
 #include <asm/cputable.h>
 #include <asm/oprofile_impl.h>
 

commit 400d221274426958f1e1c7081a247bea9cede696
Author: Kumar Gala <galak@freescale.com>
Date:   Tue Sep 27 15:13:12 2005 -0500

    [PATCH] ppc32: make cur_cpu_spec a single pointer instead of an array
    
    Changed ppc32 so that cur_cpu_spec is just a single pointer for all CPUs.
    Additionally, made call_setup_cpu check to see if the cpu_setup pointer
    is NULL or not before calling the function.  This lets remove the dummy
    cpu_setup calls that just return.
    
    Signed-off-by: Kumar Gala <kumar.gala@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 88b4118fd0c5..0ec12c8f2c01 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -155,8 +155,6 @@ static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
 int __init oprofile_arch_init(struct oprofile_operations *ops)
 {
 #ifndef __powerpc64__
-	int cpu_id = smp_processor_id();
-
 #ifdef CONFIG_FSL_BOOKE
 	model = &op_model_fsl_booke;
 #else
@@ -167,9 +165,9 @@ int __init oprofile_arch_init(struct oprofile_operations *ops)
 	if (NULL == cpu_type)
 		return -ENOMEM;
 
-	sprintf(cpu_type, "ppc/%s", cur_cpu_spec[cpu_id]->cpu_name);
+	sprintf(cpu_type, "ppc/%s", cur_cpu_spec->cpu_name);
 
-	model->num_counters = cur_cpu_spec[cpu_id]->num_pmcs;
+	model->num_counters = cur_cpu_spec->num_pmcs;
 
 	ops->cpu_type = cpu_type;
 #else /* __powerpc64__ */

commit 82cd02c16be99cba6a97d38488aee8807580a202
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Mon Sep 19 23:28:21 2005 +1000

    [PATCH] powerpc: reduce oprofile/common.c differences
    
    Rename and slightly modify {request,free}_perfmon_irq in the ppc code.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
index 486314a0defd..88b4118fd0c5 100644
--- a/arch/powerpc/oprofile/common.c
+++ b/arch/powerpc/oprofile/common.c
@@ -46,19 +46,12 @@ static void op_handle_interrupt(struct pt_regs *regs)
 
 static int op_powerpc_setup(void)
 {
-#ifdef __powerpc64__
 	int err;
 
 	/* Grab the hardware */
 	err = reserve_pmc_hardware(op_handle_interrupt);
 	if (err)
 		return err;
-#else /* __powerpc64__ */
-	/* Install our interrupt handler into the existing hook.  */
-	if (request_perfmon_irq(&op_handle_interrupt))
-		return -EBUSY;
-	mb();
-#endif /* __powerpc64__ */
 
 	/* Pre-compute the values to stuff in the hardware registers.  */
 	model->reg_setup(ctr, &sys, model->num_counters);
@@ -78,13 +71,7 @@ static int op_powerpc_setup(void)
 
 static void op_powerpc_shutdown(void)
 {
-#ifdef __powerpc64__
 	release_pmc_hardware();
-#else /* __powerpc64__ */
-	mb();
-	/* Remove our interrupt handler. We may be removing this module. */
-	free_perfmon_irq();
-#endif /* __powerpc64__ */
 }
 
 static void op_powerpc_cpu_start(void *dummy)

commit 86a5cddbd9676b129cfa2ed7a1a11759d3b2b512
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Mon Sep 19 23:24:08 2005 +1000

    [PATCH] powerpc: merge the rest of arch/ppc*/oprofile
    
    - merge common.c
    - move model specific files
    - remove stub Makefiles
    - clean up arch/ppc*/Makefile
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/oprofile/common.c b/arch/powerpc/oprofile/common.c
new file mode 100644
index 000000000000..486314a0defd
--- /dev/null
+++ b/arch/powerpc/oprofile/common.c
@@ -0,0 +1,214 @@
+/*
+ * PPC 64 oprofile support:
+ * Copyright (C) 2004 Anton Blanchard <anton@au.ibm.com>, IBM
+ * PPC 32 oprofile support: (based on PPC 64 support)
+ * Copyright (C) Freescale Semiconductor, Inc 2004
+ *	Author: Andy Fleming
+ *
+ * Based on alpha version.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/oprofile.h>
+#ifndef __powerpc64__
+#include <linux/slab.h>
+#endif /* ! __powerpc64__ */
+#include <linux/init.h>
+#include <linux/smp.h>
+#include <linux/errno.h>
+#include <asm/ptrace.h>
+#include <asm/system.h>
+#ifdef __powerpc64__
+#include <asm/pmc.h>
+#else /* __powerpc64__ */
+#include <asm/perfmon.h>
+#endif /* __powerpc64__ */
+#include <asm/cputable.h>
+#include <asm/oprofile_impl.h>
+
+static struct op_powerpc_model *model;
+
+static struct op_counter_config ctr[OP_MAX_COUNTER];
+static struct op_system_config sys;
+
+#ifndef __powerpc64__
+static char *cpu_type;
+#endif /* ! __powerpc64__ */
+
+static void op_handle_interrupt(struct pt_regs *regs)
+{
+	model->handle_interrupt(regs, ctr);
+}
+
+static int op_powerpc_setup(void)
+{
+#ifdef __powerpc64__
+	int err;
+
+	/* Grab the hardware */
+	err = reserve_pmc_hardware(op_handle_interrupt);
+	if (err)
+		return err;
+#else /* __powerpc64__ */
+	/* Install our interrupt handler into the existing hook.  */
+	if (request_perfmon_irq(&op_handle_interrupt))
+		return -EBUSY;
+	mb();
+#endif /* __powerpc64__ */
+
+	/* Pre-compute the values to stuff in the hardware registers.  */
+	model->reg_setup(ctr, &sys, model->num_counters);
+
+	/* Configure the registers on all cpus.  */
+#ifdef __powerpc64__
+	on_each_cpu(model->cpu_setup, NULL, 0, 1);
+#else /* __powerpc64__ */
+#if 0
+	/* FIXME: Make multi-cpu work */
+	on_each_cpu(model->reg_setup, NULL, 0, 1);
+#endif
+#endif /* __powerpc64__ */
+
+	return 0;
+}
+
+static void op_powerpc_shutdown(void)
+{
+#ifdef __powerpc64__
+	release_pmc_hardware();
+#else /* __powerpc64__ */
+	mb();
+	/* Remove our interrupt handler. We may be removing this module. */
+	free_perfmon_irq();
+#endif /* __powerpc64__ */
+}
+
+static void op_powerpc_cpu_start(void *dummy)
+{
+	model->start(ctr);
+}
+
+static int op_powerpc_start(void)
+{
+	on_each_cpu(op_powerpc_cpu_start, NULL, 0, 1);
+	return 0;
+}
+
+static inline void op_powerpc_cpu_stop(void *dummy)
+{
+	model->stop();
+}
+
+static void op_powerpc_stop(void)
+{
+	on_each_cpu(op_powerpc_cpu_stop, NULL, 0, 1);
+}
+
+static int op_powerpc_create_files(struct super_block *sb, struct dentry *root)
+{
+	int i;
+
+#ifdef __powerpc64__
+	/*
+	 * There is one mmcr0, mmcr1 and mmcra for setting the events for
+	 * all of the counters.
+	 */
+	oprofilefs_create_ulong(sb, root, "mmcr0", &sys.mmcr0);
+	oprofilefs_create_ulong(sb, root, "mmcr1", &sys.mmcr1);
+	oprofilefs_create_ulong(sb, root, "mmcra", &sys.mmcra);
+#endif /* __powerpc64__ */
+
+	for (i = 0; i < model->num_counters; ++i) {
+		struct dentry *dir;
+		char buf[3];
+
+		snprintf(buf, sizeof buf, "%d", i);
+		dir = oprofilefs_mkdir(sb, root, buf);
+
+		oprofilefs_create_ulong(sb, dir, "enabled", &ctr[i].enabled);
+		oprofilefs_create_ulong(sb, dir, "event", &ctr[i].event);
+		oprofilefs_create_ulong(sb, dir, "count", &ctr[i].count);
+#ifdef __powerpc64__
+		/*
+		 * We dont support per counter user/kernel selection, but
+		 * we leave the entries because userspace expects them
+		 */
+#endif /* __powerpc64__ */
+		oprofilefs_create_ulong(sb, dir, "kernel", &ctr[i].kernel);
+		oprofilefs_create_ulong(sb, dir, "user", &ctr[i].user);
+
+#ifndef __powerpc64__
+		/* FIXME: Not sure if this is used */
+#endif /* ! __powerpc64__ */
+		oprofilefs_create_ulong(sb, dir, "unit_mask", &ctr[i].unit_mask);
+	}
+
+	oprofilefs_create_ulong(sb, root, "enable_kernel", &sys.enable_kernel);
+	oprofilefs_create_ulong(sb, root, "enable_user", &sys.enable_user);
+#ifdef __powerpc64__
+	oprofilefs_create_ulong(sb, root, "backtrace_spinlocks",
+				&sys.backtrace_spinlocks);
+#endif /* __powerpc64__ */
+
+	/* Default to tracing both kernel and user */
+	sys.enable_kernel = 1;
+	sys.enable_user = 1;
+#ifdef __powerpc64__
+	/* Turn on backtracing through spinlocks by default */
+	sys.backtrace_spinlocks = 1;
+#endif /* __powerpc64__ */
+
+	return 0;
+}
+
+int __init oprofile_arch_init(struct oprofile_operations *ops)
+{
+#ifndef __powerpc64__
+	int cpu_id = smp_processor_id();
+
+#ifdef CONFIG_FSL_BOOKE
+	model = &op_model_fsl_booke;
+#else
+	return -ENODEV;
+#endif
+
+	cpu_type = kmalloc(32, GFP_KERNEL);
+	if (NULL == cpu_type)
+		return -ENOMEM;
+
+	sprintf(cpu_type, "ppc/%s", cur_cpu_spec[cpu_id]->cpu_name);
+
+	model->num_counters = cur_cpu_spec[cpu_id]->num_pmcs;
+
+	ops->cpu_type = cpu_type;
+#else /* __powerpc64__ */
+	if (!cur_cpu_spec->oprofile_model || !cur_cpu_spec->oprofile_cpu_type)
+		return -ENODEV;
+	model = cur_cpu_spec->oprofile_model;
+	model->num_counters = cur_cpu_spec->num_pmcs;
+
+	ops->cpu_type = cur_cpu_spec->oprofile_cpu_type;
+#endif /* __powerpc64__ */
+	ops->create_files = op_powerpc_create_files;
+	ops->setup = op_powerpc_setup;
+	ops->shutdown = op_powerpc_shutdown;
+	ops->start = op_powerpc_start;
+	ops->stop = op_powerpc_stop;
+
+	printk(KERN_INFO "oprofile: using %s performance monitoring.\n",
+	       ops->cpu_type);
+
+	return 0;
+}
+
+void oprofile_arch_exit(void)
+{
+#ifndef __powerpc64__
+	kfree(cpu_type);
+	cpu_type = NULL;
+#endif /* ! __powerpc64__ */
+}
