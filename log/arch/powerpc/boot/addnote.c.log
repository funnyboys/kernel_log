commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/boot/addnote.c b/arch/powerpc/boot/addnote.c
index 3da3e2b1b51b..53b3b2621457 100644
--- a/arch/powerpc/boot/addnote.c
+++ b/arch/powerpc/boot/addnote.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Program to hack in a PT_NOTE program header entry in an ELF file.
  * This is needed for OF on RS/6000s to load an image correctly.
@@ -8,11 +9,6 @@
  *
  * Adapted for 64 bit little endian images by Andrew Tauferner.
  *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
- *
  * Usage: addnote zImage
  */
 #include <stdio.h>

commit 5d085ec04a000fefb5182d3b03ee46ca96d8389b
Author: Bo YU <tsu.yubo@gmail.com>
Date:   Tue Oct 30 09:21:55 2018 -0400

    powerpc/boot: Fix missing check of lseek() return value
    
    This is detected by Coverity scan: CID: 1440481
    
    Signed-off-by: Bo YU <tsu.yubo@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/boot/addnote.c b/arch/powerpc/boot/addnote.c
index 9d9f6f334d3c..3da3e2b1b51b 100644
--- a/arch/powerpc/boot/addnote.c
+++ b/arch/powerpc/boot/addnote.c
@@ -223,7 +223,11 @@ main(int ac, char **av)
 	PUT_16(E_PHNUM, np + 2);
 
 	/* write back */
-	lseek(fd, (long) 0, SEEK_SET);
+	i = lseek(fd, (long) 0, SEEK_SET);
+	if (i < 0) {
+		perror("lseek");
+		exit(1);
+	}
 	i = write(fd, buf, n);
 	if (i < 0) {
 		perror("write");

commit 284b52c4c6e32870cacbd16872a7ed9e522cde0d
Author: Cédric Le Goater <clg@fr.ibm.com>
Date:   Thu Apr 24 09:23:34 2014 +0200

    powerpc/boot: Add 64bit and little endian support to addnote
    
    It could certainly be improved using Elf macros and byteswapping
    routines, but the initial version of the code is organised to be a
    single file program with limited dependencies. yaboot is the same.
    
    Please scream if you want a total rewrite.
    
    Signed-off-by: Cédric Le Goater <clg@fr.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/boot/addnote.c b/arch/powerpc/boot/addnote.c
index 349b5530d2c4..9d9f6f334d3c 100644
--- a/arch/powerpc/boot/addnote.c
+++ b/arch/powerpc/boot/addnote.c
@@ -6,6 +6,8 @@
  *
  * Copyright 2000 Paul Mackerras.
  *
+ * Adapted for 64 bit little endian images by Andrew Tauferner.
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version
@@ -55,36 +57,61 @@ unsigned int rpanote[N_RPA_DESCR] = {
 
 #define ROUNDUP(len)	(((len) + 3) & ~3)
 
-unsigned char buf[512];
+unsigned char buf[1024];
+#define ELFDATA2LSB     1
+#define ELFDATA2MSB     2
+static int e_data = ELFDATA2MSB;
+#define ELFCLASS32      1
+#define ELFCLASS64      2
+static int e_class = ELFCLASS32;
 
 #define GET_16BE(off)	((buf[off] << 8) + (buf[(off)+1]))
-#define GET_32BE(off)	((GET_16BE(off) << 16) + GET_16BE((off)+2))
-
-#define PUT_16BE(off, v)	(buf[off] = ((v) >> 8) & 0xff, \
-				 buf[(off) + 1] = (v) & 0xff)
-#define PUT_32BE(off, v)	(PUT_16BE((off), (v) >> 16), \
-				 PUT_16BE((off) + 2, (v)))
+#define GET_32BE(off)	((GET_16BE(off) << 16U) + GET_16BE((off)+2U))
+#define GET_64BE(off)	((((unsigned long long)GET_32BE(off)) << 32ULL) + \
+			((unsigned long long)GET_32BE((off)+4ULL)))
+#define PUT_16BE(off, v)(buf[off] = ((v) >> 8) & 0xff, \
+			 buf[(off) + 1] = (v) & 0xff)
+#define PUT_32BE(off, v)(PUT_16BE((off), (v) >> 16L), PUT_16BE((off) + 2, (v)))
+#define PUT_64BE(off, v)((PUT_32BE((off), (v) >> 32L), \
+			  PUT_32BE((off) + 4, (v))))
+
+#define GET_16LE(off)	((buf[off]) + (buf[(off)+1] << 8))
+#define GET_32LE(off)	(GET_16LE(off) + (GET_16LE((off)+2U) << 16U))
+#define GET_64LE(off)	((unsigned long long)GET_32LE(off) + \
+			(((unsigned long long)GET_32LE((off)+4ULL)) << 32ULL))
+#define PUT_16LE(off, v) (buf[off] = (v) & 0xff, \
+			  buf[(off) + 1] = ((v) >> 8) & 0xff)
+#define PUT_32LE(off, v) (PUT_16LE((off), (v)), PUT_16LE((off) + 2, (v) >> 16L))
+#define PUT_64LE(off, v) (PUT_32LE((off), (v)), PUT_32LE((off) + 4, (v) >> 32L))
+
+#define GET_16(off)	(e_data == ELFDATA2MSB ? GET_16BE(off) : GET_16LE(off))
+#define GET_32(off)	(e_data == ELFDATA2MSB ? GET_32BE(off) : GET_32LE(off))
+#define GET_64(off)	(e_data == ELFDATA2MSB ? GET_64BE(off) : GET_64LE(off))
+#define PUT_16(off, v)	(e_data == ELFDATA2MSB ? PUT_16BE(off, v) : \
+			 PUT_16LE(off, v))
+#define PUT_32(off, v)  (e_data == ELFDATA2MSB ? PUT_32BE(off, v) : \
+			 PUT_32LE(off, v))
+#define PUT_64(off, v)  (e_data == ELFDATA2MSB ? PUT_64BE(off, v) : \
+			 PUT_64LE(off, v))
 
 /* Structure of an ELF file */
 #define E_IDENT		0	/* ELF header */
-#define	E_PHOFF		28
-#define E_PHENTSIZE	42
-#define E_PHNUM		44
-#define E_HSIZE		52	/* size of ELF header */
+#define	E_PHOFF		(e_class == ELFCLASS32 ? 28 : 32)
+#define E_PHENTSIZE	(e_class == ELFCLASS32 ? 42 : 54)
+#define E_PHNUM		(e_class == ELFCLASS32 ? 44 : 56)
+#define E_HSIZE		(e_class == ELFCLASS32 ? 52 : 64)
 
 #define EI_MAGIC	0	/* offsets in E_IDENT area */
 #define EI_CLASS	4
 #define EI_DATA		5
 
 #define PH_TYPE		0	/* ELF program header */
-#define PH_OFFSET	4
-#define PH_FILESZ	16
-#define PH_HSIZE	32	/* size of program header */
+#define PH_OFFSET	(e_class == ELFCLASS32 ? 4 : 8)
+#define PH_FILESZ	(e_class == ELFCLASS32 ? 16 : 32)
+#define PH_HSIZE	(e_class == ELFCLASS32 ? 32 : 56)
 
 #define PT_NOTE		4	/* Program header type = note */
 
-#define ELFCLASS32	1
-#define ELFDATA2MSB	2
 
 unsigned char elf_magic[4] = { 0x7f, 'E', 'L', 'F' };
 
@@ -92,8 +119,8 @@ int
 main(int ac, char **av)
 {
 	int fd, n, i;
-	int ph, ps, np;
-	int nnote, nnote2, ns;
+	unsigned long ph, ps, np;
+	long nnote, nnote2, ns;
 
 	if (ac != 2) {
 		fprintf(stderr, "Usage: %s elf-file\n", av[0]);
@@ -114,26 +141,27 @@ main(int ac, char **av)
 		exit(1);
 	}
 
-	if (n < E_HSIZE || memcmp(&buf[E_IDENT+EI_MAGIC], elf_magic, 4) != 0)
+	if (memcmp(&buf[E_IDENT+EI_MAGIC], elf_magic, 4) != 0)
+		goto notelf;
+	e_class = buf[E_IDENT+EI_CLASS];
+	if (e_class != ELFCLASS32 && e_class != ELFCLASS64)
+		goto notelf;
+	e_data = buf[E_IDENT+EI_DATA];
+	if (e_data != ELFDATA2MSB && e_data != ELFDATA2LSB)
+		goto notelf;
+	if (n < E_HSIZE)
 		goto notelf;
 
-	if (buf[E_IDENT+EI_CLASS] != ELFCLASS32
-	    || buf[E_IDENT+EI_DATA] != ELFDATA2MSB) {
-		fprintf(stderr, "%s is not a big-endian 32-bit ELF image\n",
-			av[1]);
-		exit(1);
-	}
-
-	ph = GET_32BE(E_PHOFF);
-	ps = GET_16BE(E_PHENTSIZE);
-	np = GET_16BE(E_PHNUM);
+	ph = (e_class == ELFCLASS32 ? GET_32(E_PHOFF) : GET_64(E_PHOFF));
+	ps = GET_16(E_PHENTSIZE);
+	np = GET_16(E_PHNUM);
 	if (ph < E_HSIZE || ps < PH_HSIZE || np < 1)
 		goto notelf;
 	if (ph + (np + 2) * ps + nnote + nnote2 > n)
 		goto nospace;
 
 	for (i = 0; i < np; ++i) {
-		if (GET_32BE(ph + PH_TYPE) == PT_NOTE) {
+		if (GET_32(ph + PH_TYPE) == PT_NOTE) {
 			fprintf(stderr, "%s already has a note entry\n",
 				av[1]);
 			exit(0);
@@ -148,15 +176,22 @@ main(int ac, char **av)
 
 	/* fill in the program header entry */
 	ns = ph + 2 * ps;
-	PUT_32BE(ph + PH_TYPE, PT_NOTE);
-	PUT_32BE(ph + PH_OFFSET, ns);
-	PUT_32BE(ph + PH_FILESZ, nnote);
+	PUT_32(ph + PH_TYPE, PT_NOTE);
+	if (e_class == ELFCLASS32)
+		PUT_32(ph + PH_OFFSET, ns);
+	else
+		PUT_64(ph + PH_OFFSET, ns);
+
+	if (e_class == ELFCLASS32)
+		PUT_32(ph + PH_FILESZ, nnote);
+	else
+		PUT_64(ph + PH_FILESZ, nnote);
 
 	/* fill in the note area we point to */
 	/* XXX we should probably make this a proper section */
-	PUT_32BE(ns, strlen(arch) + 1);
-	PUT_32BE(ns + 4, N_DESCR * 4);
-	PUT_32BE(ns + 8, 0x1275);
+	PUT_32(ns, strlen(arch) + 1);
+	PUT_32(ns + 4, N_DESCR * 4);
+	PUT_32(ns + 8, 0x1275);
 	strcpy((char *) &buf[ns + 12], arch);
 	ns += 12 + strlen(arch) + 1;
 	for (i = 0; i < N_DESCR; ++i, ns += 4)
@@ -164,21 +199,28 @@ main(int ac, char **av)
 
 	/* fill in the second program header entry and the RPA note area */
 	ph += ps;
-	PUT_32BE(ph + PH_TYPE, PT_NOTE);
-	PUT_32BE(ph + PH_OFFSET, ns);
-	PUT_32BE(ph + PH_FILESZ, nnote2);
+	PUT_32(ph + PH_TYPE, PT_NOTE);
+	if (e_class == ELFCLASS32)
+		PUT_32(ph + PH_OFFSET, ns);
+	else
+		PUT_64(ph + PH_OFFSET, ns);
+
+	if (e_class == ELFCLASS32)
+		PUT_32(ph + PH_FILESZ, nnote);
+	else
+		PUT_64(ph + PH_FILESZ, nnote2);
 
 	/* fill in the note area we point to */
-	PUT_32BE(ns, strlen(rpaname) + 1);
-	PUT_32BE(ns + 4, sizeof(rpanote));
-	PUT_32BE(ns + 8, 0x12759999);
+	PUT_32(ns, strlen(rpaname) + 1);
+	PUT_32(ns + 4, sizeof(rpanote));
+	PUT_32(ns + 8, 0x12759999);
 	strcpy((char *) &buf[ns + 12], rpaname);
 	ns += 12 + ROUNDUP(strlen(rpaname) + 1);
 	for (i = 0; i < N_RPA_DESCR; ++i, ns += 4)
 		PUT_32BE(ns, rpanote[i]);
 
 	/* Update the number of program headers */
-	PUT_16BE(E_PHNUM, np + 2);
+	PUT_16(E_PHNUM, np + 2);
 
 	/* write back */
 	lseek(fd, (long) 0, SEEK_SET);

commit 4e74fd7d0a6eda70f9356c113450182a844abcf1
Author: Joe Perches <joe@perches.com>
Date:   Mon Sep 13 09:47:40 2010 +0000

    powerpc: Use static const char arrays
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Reviewed-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/boot/addnote.c b/arch/powerpc/boot/addnote.c
index b1e5611b2ab1..349b5530d2c4 100644
--- a/arch/powerpc/boot/addnote.c
+++ b/arch/powerpc/boot/addnote.c
@@ -20,7 +20,7 @@
 #include <string.h>
 
 /* CHRP note section */
-char arch[] = "PowerPC";
+static const char arch[] = "PowerPC";
 
 #define N_DESCR	6
 unsigned int descr[N_DESCR] = {
@@ -33,7 +33,7 @@ unsigned int descr[N_DESCR] = {
 };
 
 /* RPA note section */
-char rpaname[] = "IBM,RPA-Client-Config";
+static const char rpaname[] = "IBM,RPA-Client-Config";
 
 /*
  * Note: setting ignore_my_client_config *should* mean that OF ignores

commit 5663a1232bd557b4b2141ad345dd56785fa51c2a
Author: Paul Mackerras <paulus@samba.org>
Date:   Fri Oct 31 22:27:17 2008 +1100

    Revert "powerpc: Sync RPA note in zImage with kernel's RPA note"
    
    This reverts commit 91a00302959545a9ae423e99732b1e46eb19e877, plus
    commit 0dcd440120ef12879ff34fc78d7e4abf171c79e4 ("powerpc: Revert CHRP
    boot wrapper to real-base = 12MB on 32-bit") which depended on it.
    
    Commit 91a00302 was causing NVRAM corruption on some pSeries machines,
    for as-yet unknown reasons, so this reverts it until the cause is
    identified.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/addnote.c b/arch/powerpc/boot/addnote.c
index 3091d1d21aef..b1e5611b2ab1 100644
--- a/arch/powerpc/boot/addnote.c
+++ b/arch/powerpc/boot/addnote.c
@@ -11,12 +11,7 @@
  * as published by the Free Software Foundation; either version
  * 2 of the License, or (at your option) any later version.
  *
- * Usage: addnote [-r realbase] zImage [note.elf]
- *
- * If note.elf is supplied, it is the name of an ELF file that contains
- * an RPA note to use instead of the built-in one.  Alternatively, the
- * note.elf file may be empty, in which case the built-in RPA note is
- * used (this is to simplify how this is invoked from the wrapper script).
+ * Usage: addnote zImage
  */
 #include <stdio.h>
 #include <stdlib.h>
@@ -48,29 +43,27 @@ char rpaname[] = "IBM,RPA-Client-Config";
  */
 #define N_RPA_DESCR	8
 unsigned int rpanote[N_RPA_DESCR] = {
-	1,			/* lparaffinity */
-	128,			/* min_rmo_size */
+	0,			/* lparaffinity */
+	64,			/* min_rmo_size */
 	0,			/* min_rmo_percent */
-	46,			/* max_pft_size */
+	40,			/* max_pft_size */
 	1,			/* splpar */
 	-1,			/* min_load */
-	1,			/* new_mem_def */
-	0,			/* ignore_my_client_config */
+	0,			/* new_mem_def */
+	1,			/* ignore_my_client_config */
 };
 
 #define ROUNDUP(len)	(((len) + 3) & ~3)
 
 unsigned char buf[512];
-unsigned char notebuf[512];
 
-#define GET_16BE(b, off)	(((b)[off] << 8) + ((b)[(off)+1]))
-#define GET_32BE(b, off)	((GET_16BE((b), (off)) << 16) + \
-				 GET_16BE((b), (off)+2))
+#define GET_16BE(off)	((buf[off] << 8) + (buf[(off)+1]))
+#define GET_32BE(off)	((GET_16BE(off) << 16) + GET_16BE((off)+2))
 
-#define PUT_16BE(b, off, v)	((b)[off] = ((v) >> 8) & 0xff, \
-				 (b)[(off) + 1] = (v) & 0xff)
-#define PUT_32BE(b, off, v)	(PUT_16BE((b), (off), (v) >> 16), \
-				 PUT_16BE((b), (off) + 2, (v)))
+#define PUT_16BE(off, v)	(buf[off] = ((v) >> 8) & 0xff, \
+				 buf[(off) + 1] = (v) & 0xff)
+#define PUT_32BE(off, v)	(PUT_16BE((off), (v) >> 16), \
+				 PUT_16BE((off) + 2, (v)))
 
 /* Structure of an ELF file */
 #define E_IDENT		0	/* ELF header */
@@ -95,95 +88,25 @@ unsigned char notebuf[512];
 
 unsigned char elf_magic[4] = { 0x7f, 'E', 'L', 'F' };
 
-unsigned char *read_rpanote(const char *fname, int *nnp)
-{
-	int notefd, nr, i;
-	int ph, ps, np;
-	int note, notesize;
-
-	notefd = open(fname, O_RDONLY);
-	if (notefd < 0) {
-		perror(fname);
-		exit(1);
-	}
-	nr = read(notefd, notebuf, sizeof(notebuf));
-	if (nr < 0) {
-		perror("read note");
-		exit(1);
-	}
-	if (nr == 0)		/* empty file */
-		return NULL;
-	if (nr < E_HSIZE ||
-	    memcmp(&notebuf[E_IDENT+EI_MAGIC], elf_magic, 4) != 0 ||
-	    notebuf[E_IDENT+EI_CLASS] != ELFCLASS32 ||
-	    notebuf[E_IDENT+EI_DATA] != ELFDATA2MSB)
-		goto notelf;
-	close(notefd);
-
-	/* now look for the RPA-note */
-	ph = GET_32BE(notebuf, E_PHOFF);
-	ps = GET_16BE(notebuf, E_PHENTSIZE);
-	np = GET_16BE(notebuf, E_PHNUM);
-	if (ph < E_HSIZE || ps < PH_HSIZE || np < 1)
-		goto notelf;
-
-	for (i = 0; i < np; ++i, ph += ps) {
-		if (GET_32BE(notebuf, ph + PH_TYPE) != PT_NOTE)
-			continue;
-		note = GET_32BE(notebuf, ph + PH_OFFSET);
-		notesize = GET_32BE(notebuf, ph + PH_FILESZ);
-		if (notesize < 34 || note + notesize > nr)
-			continue;
-		if (GET_32BE(notebuf, note) != strlen(rpaname) + 1 ||
-		    GET_32BE(notebuf, note + 8) != 0x12759999 ||
-		    strcmp((char *)&notebuf[note + 12], rpaname) != 0)
-			continue;
-		/* looks like an RPA note, return it */
-		*nnp = notesize;
-		return &notebuf[note];
-	}
-	/* no RPA note found */
-	return NULL;
-
- notelf:
-	fprintf(stderr, "%s is not a big-endian 32-bit ELF image\n", fname);
-	exit(1);
-}
-
 int
 main(int ac, char **av)
 {
-	int fd, n, i, ai;
+	int fd, n, i;
 	int ph, ps, np;
 	int nnote, nnote2, ns;
-	unsigned char *rpap;
-	char *p, *endp;
-
-	ai = 1;
-	if (ac >= ai + 2 && strcmp(av[ai], "-r") == 0) {
-		/* process -r realbase */
-		p = av[ai + 1];
-		descr[1] = strtol(p, &endp, 16);
-		if (endp == p || *endp != 0) {
-			fprintf(stderr, "Can't parse -r argument '%s' as hex\n",
-				p);
-			exit(1);
-		}
-		ai += 2;
-	}
-	if (ac != ai + 1 && ac != ai + 2) {
-		fprintf(stderr, "Usage: %s [-r realbase] elf-file [rpanote.elf]\n", av[0]);
+
+	if (ac != 2) {
+		fprintf(stderr, "Usage: %s elf-file\n", av[0]);
 		exit(1);
 	}
-	fd = open(av[ai], O_RDWR);
+	fd = open(av[1], O_RDWR);
 	if (fd < 0) {
-		perror(av[ai]);
+		perror(av[1]);
 		exit(1);
 	}
 
 	nnote = 12 + ROUNDUP(strlen(arch) + 1) + sizeof(descr);
 	nnote2 = 12 + ROUNDUP(strlen(rpaname) + 1) + sizeof(rpanote);
-	rpap = NULL;
 
 	n = read(fd, buf, sizeof(buf));
 	if (n < 0) {
@@ -197,25 +120,22 @@ main(int ac, char **av)
 	if (buf[E_IDENT+EI_CLASS] != ELFCLASS32
 	    || buf[E_IDENT+EI_DATA] != ELFDATA2MSB) {
 		fprintf(stderr, "%s is not a big-endian 32-bit ELF image\n",
-			av[ai]);
+			av[1]);
 		exit(1);
 	}
 
-	if (ac == ai + 2)
-		rpap = read_rpanote(av[ai + 1], &nnote2);
-
-	ph = GET_32BE(buf, E_PHOFF);
-	ps = GET_16BE(buf, E_PHENTSIZE);
-	np = GET_16BE(buf, E_PHNUM);
+	ph = GET_32BE(E_PHOFF);
+	ps = GET_16BE(E_PHENTSIZE);
+	np = GET_16BE(E_PHNUM);
 	if (ph < E_HSIZE || ps < PH_HSIZE || np < 1)
 		goto notelf;
 	if (ph + (np + 2) * ps + nnote + nnote2 > n)
 		goto nospace;
 
 	for (i = 0; i < np; ++i) {
-		if (GET_32BE(buf, ph + PH_TYPE) == PT_NOTE) {
+		if (GET_32BE(ph + PH_TYPE) == PT_NOTE) {
 			fprintf(stderr, "%s already has a note entry\n",
-				av[ai]);
+				av[1]);
 			exit(0);
 		}
 		ph += ps;
@@ -228,42 +148,37 @@ main(int ac, char **av)
 
 	/* fill in the program header entry */
 	ns = ph + 2 * ps;
-	PUT_32BE(buf, ph + PH_TYPE, PT_NOTE);
-	PUT_32BE(buf, ph + PH_OFFSET, ns);
-	PUT_32BE(buf, ph + PH_FILESZ, nnote);
+	PUT_32BE(ph + PH_TYPE, PT_NOTE);
+	PUT_32BE(ph + PH_OFFSET, ns);
+	PUT_32BE(ph + PH_FILESZ, nnote);
 
 	/* fill in the note area we point to */
 	/* XXX we should probably make this a proper section */
-	PUT_32BE(buf, ns, strlen(arch) + 1);
-	PUT_32BE(buf, ns + 4, N_DESCR * 4);
-	PUT_32BE(buf, ns + 8, 0x1275);
+	PUT_32BE(ns, strlen(arch) + 1);
+	PUT_32BE(ns + 4, N_DESCR * 4);
+	PUT_32BE(ns + 8, 0x1275);
 	strcpy((char *) &buf[ns + 12], arch);
 	ns += 12 + strlen(arch) + 1;
 	for (i = 0; i < N_DESCR; ++i, ns += 4)
-		PUT_32BE(buf, ns, descr[i]);
+		PUT_32BE(ns, descr[i]);
 
 	/* fill in the second program header entry and the RPA note area */
 	ph += ps;
-	PUT_32BE(buf, ph + PH_TYPE, PT_NOTE);
-	PUT_32BE(buf, ph + PH_OFFSET, ns);
-	PUT_32BE(buf, ph + PH_FILESZ, nnote2);
+	PUT_32BE(ph + PH_TYPE, PT_NOTE);
+	PUT_32BE(ph + PH_OFFSET, ns);
+	PUT_32BE(ph + PH_FILESZ, nnote2);
 
 	/* fill in the note area we point to */
-	if (rpap) {
-		/* RPA note supplied in file, just copy the whole thing over */
-		memcpy(buf + ns, rpap, nnote2);
-	} else {
-		PUT_32BE(buf, ns, strlen(rpaname) + 1);
-		PUT_32BE(buf, ns + 4, sizeof(rpanote));
-		PUT_32BE(buf, ns + 8, 0x12759999);
-		strcpy((char *) &buf[ns + 12], rpaname);
-		ns += 12 + ROUNDUP(strlen(rpaname) + 1);
-		for (i = 0; i < N_RPA_DESCR; ++i, ns += 4)
-			PUT_32BE(buf, ns, rpanote[i]);
-	}
+	PUT_32BE(ns, strlen(rpaname) + 1);
+	PUT_32BE(ns + 4, sizeof(rpanote));
+	PUT_32BE(ns + 8, 0x12759999);
+	strcpy((char *) &buf[ns + 12], rpaname);
+	ns += 12 + ROUNDUP(strlen(rpaname) + 1);
+	for (i = 0; i < N_RPA_DESCR; ++i, ns += 4)
+		PUT_32BE(ns, rpanote[i]);
 
 	/* Update the number of program headers */
-	PUT_16BE(buf, E_PHNUM, np + 2);
+	PUT_16BE(E_PHNUM, np + 2);
 
 	/* write back */
 	lseek(fd, (long) 0, SEEK_SET);
@@ -273,18 +188,18 @@ main(int ac, char **av)
 		exit(1);
 	}
 	if (i < n) {
-		fprintf(stderr, "%s: write truncated\n", av[ai]);
+		fprintf(stderr, "%s: write truncated\n", av[1]);
 		exit(1);
 	}
 
 	exit(0);
 
  notelf:
-	fprintf(stderr, "%s does not appear to be an ELF file\n", av[ai]);
+	fprintf(stderr, "%s does not appear to be an ELF file\n", av[1]);
 	exit(1);
 
  nospace:
 	fprintf(stderr, "sorry, I can't find space in %s to put the note\n",
-		av[ai]);
+		av[1]);
 	exit(1);
 }

commit 0dcd440120ef12879ff34fc78d7e4abf171c79e4
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Oct 20 17:42:42 2008 +0000

    powerpc: Revert CHRP boot wrapper to real-base = 12MB on 32-bit
    
    Commit 9b09c6d909dfd8de96b99b9b9c808b94b0a71614 ("powerpc: Change the
    default link address for pSeries zImage kernels") changed the
    real-base value in the CHRP note added by addnote to the zImage from
    12MB to 32MB.  It turns out that this causes unnecessary extra reboots
    on old 32-bit CHRP machines.  This therefore adds a -r flag to addnote
    to allow us to specify what real-base value it should put in the CHRP
    note, and adjusts the wrapper script to pass -r c00000 to addnote when
    making a zImage for a CHRP machine.  Also, CHRP machines ignore the
    RPA note, so we don't need to arrange for it to be the same as the
    kernel's.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/boot/addnote.c b/arch/powerpc/boot/addnote.c
index dcc9ab2ca823..3091d1d21aef 100644
--- a/arch/powerpc/boot/addnote.c
+++ b/arch/powerpc/boot/addnote.c
@@ -11,7 +11,7 @@
  * as published by the Free Software Foundation; either version
  * 2 of the License, or (at your option) any later version.
  *
- * Usage: addnote zImage [note.elf]
+ * Usage: addnote [-r realbase] zImage [note.elf]
  *
  * If note.elf is supplied, it is the name of an ELF file that contains
  * an RPA note to use instead of the built-in one.  Alternatively, the
@@ -153,18 +153,31 @@ unsigned char *read_rpanote(const char *fname, int *nnp)
 int
 main(int ac, char **av)
 {
-	int fd, n, i;
+	int fd, n, i, ai;
 	int ph, ps, np;
 	int nnote, nnote2, ns;
 	unsigned char *rpap;
-
-	if (ac != 2 && ac != 3) {
-		fprintf(stderr, "Usage: %s elf-file [rpanote.elf]\n", av[0]);
+	char *p, *endp;
+
+	ai = 1;
+	if (ac >= ai + 2 && strcmp(av[ai], "-r") == 0) {
+		/* process -r realbase */
+		p = av[ai + 1];
+		descr[1] = strtol(p, &endp, 16);
+		if (endp == p || *endp != 0) {
+			fprintf(stderr, "Can't parse -r argument '%s' as hex\n",
+				p);
+			exit(1);
+		}
+		ai += 2;
+	}
+	if (ac != ai + 1 && ac != ai + 2) {
+		fprintf(stderr, "Usage: %s [-r realbase] elf-file [rpanote.elf]\n", av[0]);
 		exit(1);
 	}
-	fd = open(av[1], O_RDWR);
+	fd = open(av[ai], O_RDWR);
 	if (fd < 0) {
-		perror(av[1]);
+		perror(av[ai]);
 		exit(1);
 	}
 
@@ -184,12 +197,12 @@ main(int ac, char **av)
 	if (buf[E_IDENT+EI_CLASS] != ELFCLASS32
 	    || buf[E_IDENT+EI_DATA] != ELFDATA2MSB) {
 		fprintf(stderr, "%s is not a big-endian 32-bit ELF image\n",
-			av[1]);
+			av[ai]);
 		exit(1);
 	}
 
-	if (ac == 3)
-		rpap = read_rpanote(av[2], &nnote2);
+	if (ac == ai + 2)
+		rpap = read_rpanote(av[ai + 1], &nnote2);
 
 	ph = GET_32BE(buf, E_PHOFF);
 	ps = GET_16BE(buf, E_PHENTSIZE);
@@ -202,7 +215,7 @@ main(int ac, char **av)
 	for (i = 0; i < np; ++i) {
 		if (GET_32BE(buf, ph + PH_TYPE) == PT_NOTE) {
 			fprintf(stderr, "%s already has a note entry\n",
-				av[1]);
+				av[ai]);
 			exit(0);
 		}
 		ph += ps;
@@ -260,18 +273,18 @@ main(int ac, char **av)
 		exit(1);
 	}
 	if (i < n) {
-		fprintf(stderr, "%s: write truncated\n", av[1]);
+		fprintf(stderr, "%s: write truncated\n", av[ai]);
 		exit(1);
 	}
 
 	exit(0);
 
  notelf:
-	fprintf(stderr, "%s does not appear to be an ELF file\n", av[1]);
+	fprintf(stderr, "%s does not appear to be an ELF file\n", av[ai]);
 	exit(1);
 
  nospace:
 	fprintf(stderr, "sorry, I can't find space in %s to put the note\n",
-		av[1]);
+		av[ai]);
 	exit(1);
 }

commit 91a00302959545a9ae423e99732b1e46eb19e877
Author: Paul Mackerras <paulus@samba.org>
Date:   Wed Oct 8 14:03:29 2008 +0000

    powerpc: Sync RPA note in zImage with kernel's RPA note
    
    Commit 9b09c6d909dfd8de96b99b9b9c808b94b0a71614 ("powerpc: Change the
    default link address for pSeries zImage kernels") changed the
    real-base value in the CHRP note added by the addnote program from
    12MB to 32MB to give more space for Open Firmware to load the zImage.
    (The real-base value says where we want OF to position itself in
    memory.)  However, this change was ineffective on most pSeries
    machines, because the RPA note added by addnote has the "ignore me"
    flag set to 1.  This was intended to tell OF to ignore just the RPA
    note, but has the side effect of also making OF ignore the CHRP note
    (at least on most pSeries machines).
    
    To solve this we have to set the "ignore me" flag to 0 in the RPA
    note.  (We can't just omit the RPA note because that is equivalent to
    having an RPA note with default values, and the default values are not
    what we want.)  However, then we have to make sure the values in the
    zImage's RPA note match up with the values that the kernel supplies
    later in prom_init.c with either the ibm,client-architecture-support
    call or the process-elf-header call in prom_send_capabilities().
    
    So this sets the "ignore me" flag in the RPA note in addnote to 0, and
    adjusts the RPA note values in addnote.c and in prom_init.c to be
    consistent with each other and with the values in ibm_architecture_vec.
    
    However, since the wrapper is independent of the kernel, this doesn't
    ensure that the notes will stay consistent.  To ensure that, this adds
    code to addnote.c so that it can extract the kernel's RPA note from
    the kernel binary and put that in the zImage.  To that end, we put the
    kernel's fake ELF header (which contains the kernel's RPA note) into
    its own section, and arrange for wrapper to pull out that section with
    objcopy and pass it to addnote, which then extracts the RPA note from
    it and transfers it to the zImage.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/boot/addnote.c b/arch/powerpc/boot/addnote.c
index b1e5611b2ab1..dcc9ab2ca823 100644
--- a/arch/powerpc/boot/addnote.c
+++ b/arch/powerpc/boot/addnote.c
@@ -11,7 +11,12 @@
  * as published by the Free Software Foundation; either version
  * 2 of the License, or (at your option) any later version.
  *
- * Usage: addnote zImage
+ * Usage: addnote zImage [note.elf]
+ *
+ * If note.elf is supplied, it is the name of an ELF file that contains
+ * an RPA note to use instead of the built-in one.  Alternatively, the
+ * note.elf file may be empty, in which case the built-in RPA note is
+ * used (this is to simplify how this is invoked from the wrapper script).
  */
 #include <stdio.h>
 #include <stdlib.h>
@@ -43,27 +48,29 @@ char rpaname[] = "IBM,RPA-Client-Config";
  */
 #define N_RPA_DESCR	8
 unsigned int rpanote[N_RPA_DESCR] = {
-	0,			/* lparaffinity */
-	64,			/* min_rmo_size */
+	1,			/* lparaffinity */
+	128,			/* min_rmo_size */
 	0,			/* min_rmo_percent */
-	40,			/* max_pft_size */
+	46,			/* max_pft_size */
 	1,			/* splpar */
 	-1,			/* min_load */
-	0,			/* new_mem_def */
-	1,			/* ignore_my_client_config */
+	1,			/* new_mem_def */
+	0,			/* ignore_my_client_config */
 };
 
 #define ROUNDUP(len)	(((len) + 3) & ~3)
 
 unsigned char buf[512];
+unsigned char notebuf[512];
 
-#define GET_16BE(off)	((buf[off] << 8) + (buf[(off)+1]))
-#define GET_32BE(off)	((GET_16BE(off) << 16) + GET_16BE((off)+2))
+#define GET_16BE(b, off)	(((b)[off] << 8) + ((b)[(off)+1]))
+#define GET_32BE(b, off)	((GET_16BE((b), (off)) << 16) + \
+				 GET_16BE((b), (off)+2))
 
-#define PUT_16BE(off, v)	(buf[off] = ((v) >> 8) & 0xff, \
-				 buf[(off) + 1] = (v) & 0xff)
-#define PUT_32BE(off, v)	(PUT_16BE((off), (v) >> 16), \
-				 PUT_16BE((off) + 2, (v)))
+#define PUT_16BE(b, off, v)	((b)[off] = ((v) >> 8) & 0xff, \
+				 (b)[(off) + 1] = (v) & 0xff)
+#define PUT_32BE(b, off, v)	(PUT_16BE((b), (off), (v) >> 16), \
+				 PUT_16BE((b), (off) + 2, (v)))
 
 /* Structure of an ELF file */
 #define E_IDENT		0	/* ELF header */
@@ -88,15 +95,71 @@ unsigned char buf[512];
 
 unsigned char elf_magic[4] = { 0x7f, 'E', 'L', 'F' };
 
+unsigned char *read_rpanote(const char *fname, int *nnp)
+{
+	int notefd, nr, i;
+	int ph, ps, np;
+	int note, notesize;
+
+	notefd = open(fname, O_RDONLY);
+	if (notefd < 0) {
+		perror(fname);
+		exit(1);
+	}
+	nr = read(notefd, notebuf, sizeof(notebuf));
+	if (nr < 0) {
+		perror("read note");
+		exit(1);
+	}
+	if (nr == 0)		/* empty file */
+		return NULL;
+	if (nr < E_HSIZE ||
+	    memcmp(&notebuf[E_IDENT+EI_MAGIC], elf_magic, 4) != 0 ||
+	    notebuf[E_IDENT+EI_CLASS] != ELFCLASS32 ||
+	    notebuf[E_IDENT+EI_DATA] != ELFDATA2MSB)
+		goto notelf;
+	close(notefd);
+
+	/* now look for the RPA-note */
+	ph = GET_32BE(notebuf, E_PHOFF);
+	ps = GET_16BE(notebuf, E_PHENTSIZE);
+	np = GET_16BE(notebuf, E_PHNUM);
+	if (ph < E_HSIZE || ps < PH_HSIZE || np < 1)
+		goto notelf;
+
+	for (i = 0; i < np; ++i, ph += ps) {
+		if (GET_32BE(notebuf, ph + PH_TYPE) != PT_NOTE)
+			continue;
+		note = GET_32BE(notebuf, ph + PH_OFFSET);
+		notesize = GET_32BE(notebuf, ph + PH_FILESZ);
+		if (notesize < 34 || note + notesize > nr)
+			continue;
+		if (GET_32BE(notebuf, note) != strlen(rpaname) + 1 ||
+		    GET_32BE(notebuf, note + 8) != 0x12759999 ||
+		    strcmp((char *)&notebuf[note + 12], rpaname) != 0)
+			continue;
+		/* looks like an RPA note, return it */
+		*nnp = notesize;
+		return &notebuf[note];
+	}
+	/* no RPA note found */
+	return NULL;
+
+ notelf:
+	fprintf(stderr, "%s is not a big-endian 32-bit ELF image\n", fname);
+	exit(1);
+}
+
 int
 main(int ac, char **av)
 {
 	int fd, n, i;
 	int ph, ps, np;
 	int nnote, nnote2, ns;
+	unsigned char *rpap;
 
-	if (ac != 2) {
-		fprintf(stderr, "Usage: %s elf-file\n", av[0]);
+	if (ac != 2 && ac != 3) {
+		fprintf(stderr, "Usage: %s elf-file [rpanote.elf]\n", av[0]);
 		exit(1);
 	}
 	fd = open(av[1], O_RDWR);
@@ -107,6 +170,7 @@ main(int ac, char **av)
 
 	nnote = 12 + ROUNDUP(strlen(arch) + 1) + sizeof(descr);
 	nnote2 = 12 + ROUNDUP(strlen(rpaname) + 1) + sizeof(rpanote);
+	rpap = NULL;
 
 	n = read(fd, buf, sizeof(buf));
 	if (n < 0) {
@@ -124,16 +188,19 @@ main(int ac, char **av)
 		exit(1);
 	}
 
-	ph = GET_32BE(E_PHOFF);
-	ps = GET_16BE(E_PHENTSIZE);
-	np = GET_16BE(E_PHNUM);
+	if (ac == 3)
+		rpap = read_rpanote(av[2], &nnote2);
+
+	ph = GET_32BE(buf, E_PHOFF);
+	ps = GET_16BE(buf, E_PHENTSIZE);
+	np = GET_16BE(buf, E_PHNUM);
 	if (ph < E_HSIZE || ps < PH_HSIZE || np < 1)
 		goto notelf;
 	if (ph + (np + 2) * ps + nnote + nnote2 > n)
 		goto nospace;
 
 	for (i = 0; i < np; ++i) {
-		if (GET_32BE(ph + PH_TYPE) == PT_NOTE) {
+		if (GET_32BE(buf, ph + PH_TYPE) == PT_NOTE) {
 			fprintf(stderr, "%s already has a note entry\n",
 				av[1]);
 			exit(0);
@@ -148,37 +215,42 @@ main(int ac, char **av)
 
 	/* fill in the program header entry */
 	ns = ph + 2 * ps;
-	PUT_32BE(ph + PH_TYPE, PT_NOTE);
-	PUT_32BE(ph + PH_OFFSET, ns);
-	PUT_32BE(ph + PH_FILESZ, nnote);
+	PUT_32BE(buf, ph + PH_TYPE, PT_NOTE);
+	PUT_32BE(buf, ph + PH_OFFSET, ns);
+	PUT_32BE(buf, ph + PH_FILESZ, nnote);
 
 	/* fill in the note area we point to */
 	/* XXX we should probably make this a proper section */
-	PUT_32BE(ns, strlen(arch) + 1);
-	PUT_32BE(ns + 4, N_DESCR * 4);
-	PUT_32BE(ns + 8, 0x1275);
+	PUT_32BE(buf, ns, strlen(arch) + 1);
+	PUT_32BE(buf, ns + 4, N_DESCR * 4);
+	PUT_32BE(buf, ns + 8, 0x1275);
 	strcpy((char *) &buf[ns + 12], arch);
 	ns += 12 + strlen(arch) + 1;
 	for (i = 0; i < N_DESCR; ++i, ns += 4)
-		PUT_32BE(ns, descr[i]);
+		PUT_32BE(buf, ns, descr[i]);
 
 	/* fill in the second program header entry and the RPA note area */
 	ph += ps;
-	PUT_32BE(ph + PH_TYPE, PT_NOTE);
-	PUT_32BE(ph + PH_OFFSET, ns);
-	PUT_32BE(ph + PH_FILESZ, nnote2);
+	PUT_32BE(buf, ph + PH_TYPE, PT_NOTE);
+	PUT_32BE(buf, ph + PH_OFFSET, ns);
+	PUT_32BE(buf, ph + PH_FILESZ, nnote2);
 
 	/* fill in the note area we point to */
-	PUT_32BE(ns, strlen(rpaname) + 1);
-	PUT_32BE(ns + 4, sizeof(rpanote));
-	PUT_32BE(ns + 8, 0x12759999);
-	strcpy((char *) &buf[ns + 12], rpaname);
-	ns += 12 + ROUNDUP(strlen(rpaname) + 1);
-	for (i = 0; i < N_RPA_DESCR; ++i, ns += 4)
-		PUT_32BE(ns, rpanote[i]);
+	if (rpap) {
+		/* RPA note supplied in file, just copy the whole thing over */
+		memcpy(buf + ns, rpap, nnote2);
+	} else {
+		PUT_32BE(buf, ns, strlen(rpaname) + 1);
+		PUT_32BE(buf, ns + 4, sizeof(rpanote));
+		PUT_32BE(buf, ns + 8, 0x12759999);
+		strcpy((char *) &buf[ns + 12], rpaname);
+		ns += 12 + ROUNDUP(strlen(rpaname) + 1);
+		for (i = 0; i < N_RPA_DESCR; ++i, ns += 4)
+			PUT_32BE(buf, ns, rpanote[i]);
+	}
 
 	/* Update the number of program headers */
-	PUT_16BE(E_PHNUM, np + 2);
+	PUT_16BE(buf, E_PHNUM, np + 2);
 
 	/* write back */
 	lseek(fd, (long) 0, SEEK_SET);

commit 9b09c6d909dfd8de96b99b9b9c808b94b0a71614
Author: Tony Breeds <tony@bakeyournoodle.com>
Date:   Tue Jun 24 14:20:29 2008 +1000

    powerpc: Change the default link address for pSeries zImage kernels
    
    Currently we set the start of the .text section to be 4Mb for pSeries.
    In situations where the zImage is > 8Mb we'll fail to boot (due to
    overlapping with OF).  Move .text in a zImage from 4MB to 64MB
    (well past OF).
    
    We still will not be able to load large zImage unless we also move OF,
    to that end, add a note to the zImage ELF to move OF to 32Mb.  If this
    is the very first kernel booted then we'll need to move OF manually by
    setting real-base.
    
    Signed-off-by: Tony Breeds <tony@bakeyournoodle.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/addnote.c b/arch/powerpc/boot/addnote.c
index 8041a9845ab7..b1e5611b2ab1 100644
--- a/arch/powerpc/boot/addnote.c
+++ b/arch/powerpc/boot/addnote.c
@@ -25,7 +25,7 @@ char arch[] = "PowerPC";
 #define N_DESCR	6
 unsigned int descr[N_DESCR] = {
 	0xffffffff,		/* real-mode = true */
-	0x00c00000,		/* real-base, i.e. where we expect OF to be */
+	0x02000000,		/* real-base, i.e. where we expect OF to be */
 	0xffffffff,		/* real-size */
 	0xffffffff,		/* virt-base */
 	0xffffffff,		/* virt-size */

commit 94b212c29f685ca54b5689a8e89ac7671c43d651
Author: Paul Mackerras <paulus@samba.org>
Date:   Wed Nov 16 13:38:21 2005 +1100

    powerpc: Move ppc64 boot wrapper code over to arch/powerpc
    
    This also extends the code to handle 32-bit ELF vmlinux files as well
    as 64-bit ones.  This is sufficient for booting on new-world 32-bit
    powermacs (i.e. all recent machines).
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/addnote.c b/arch/powerpc/boot/addnote.c
new file mode 100644
index 000000000000..8041a9845ab7
--- /dev/null
+++ b/arch/powerpc/boot/addnote.c
@@ -0,0 +1,205 @@
+/*
+ * Program to hack in a PT_NOTE program header entry in an ELF file.
+ * This is needed for OF on RS/6000s to load an image correctly.
+ * Note that OF needs a program header entry for the note, not an
+ * ELF section.
+ *
+ * Copyright 2000 Paul Mackerras.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ *
+ * Usage: addnote zImage
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+
+/* CHRP note section */
+char arch[] = "PowerPC";
+
+#define N_DESCR	6
+unsigned int descr[N_DESCR] = {
+	0xffffffff,		/* real-mode = true */
+	0x00c00000,		/* real-base, i.e. where we expect OF to be */
+	0xffffffff,		/* real-size */
+	0xffffffff,		/* virt-base */
+	0xffffffff,		/* virt-size */
+	0x4000,			/* load-base */
+};
+
+/* RPA note section */
+char rpaname[] = "IBM,RPA-Client-Config";
+
+/*
+ * Note: setting ignore_my_client_config *should* mean that OF ignores
+ * all the other fields, but there is a firmware bug which means that
+ * it looks at the splpar field at least.  So these values need to be
+ * reasonable.
+ */
+#define N_RPA_DESCR	8
+unsigned int rpanote[N_RPA_DESCR] = {
+	0,			/* lparaffinity */
+	64,			/* min_rmo_size */
+	0,			/* min_rmo_percent */
+	40,			/* max_pft_size */
+	1,			/* splpar */
+	-1,			/* min_load */
+	0,			/* new_mem_def */
+	1,			/* ignore_my_client_config */
+};
+
+#define ROUNDUP(len)	(((len) + 3) & ~3)
+
+unsigned char buf[512];
+
+#define GET_16BE(off)	((buf[off] << 8) + (buf[(off)+1]))
+#define GET_32BE(off)	((GET_16BE(off) << 16) + GET_16BE((off)+2))
+
+#define PUT_16BE(off, v)	(buf[off] = ((v) >> 8) & 0xff, \
+				 buf[(off) + 1] = (v) & 0xff)
+#define PUT_32BE(off, v)	(PUT_16BE((off), (v) >> 16), \
+				 PUT_16BE((off) + 2, (v)))
+
+/* Structure of an ELF file */
+#define E_IDENT		0	/* ELF header */
+#define	E_PHOFF		28
+#define E_PHENTSIZE	42
+#define E_PHNUM		44
+#define E_HSIZE		52	/* size of ELF header */
+
+#define EI_MAGIC	0	/* offsets in E_IDENT area */
+#define EI_CLASS	4
+#define EI_DATA		5
+
+#define PH_TYPE		0	/* ELF program header */
+#define PH_OFFSET	4
+#define PH_FILESZ	16
+#define PH_HSIZE	32	/* size of program header */
+
+#define PT_NOTE		4	/* Program header type = note */
+
+#define ELFCLASS32	1
+#define ELFDATA2MSB	2
+
+unsigned char elf_magic[4] = { 0x7f, 'E', 'L', 'F' };
+
+int
+main(int ac, char **av)
+{
+	int fd, n, i;
+	int ph, ps, np;
+	int nnote, nnote2, ns;
+
+	if (ac != 2) {
+		fprintf(stderr, "Usage: %s elf-file\n", av[0]);
+		exit(1);
+	}
+	fd = open(av[1], O_RDWR);
+	if (fd < 0) {
+		perror(av[1]);
+		exit(1);
+	}
+
+	nnote = 12 + ROUNDUP(strlen(arch) + 1) + sizeof(descr);
+	nnote2 = 12 + ROUNDUP(strlen(rpaname) + 1) + sizeof(rpanote);
+
+	n = read(fd, buf, sizeof(buf));
+	if (n < 0) {
+		perror("read");
+		exit(1);
+	}
+
+	if (n < E_HSIZE || memcmp(&buf[E_IDENT+EI_MAGIC], elf_magic, 4) != 0)
+		goto notelf;
+
+	if (buf[E_IDENT+EI_CLASS] != ELFCLASS32
+	    || buf[E_IDENT+EI_DATA] != ELFDATA2MSB) {
+		fprintf(stderr, "%s is not a big-endian 32-bit ELF image\n",
+			av[1]);
+		exit(1);
+	}
+
+	ph = GET_32BE(E_PHOFF);
+	ps = GET_16BE(E_PHENTSIZE);
+	np = GET_16BE(E_PHNUM);
+	if (ph < E_HSIZE || ps < PH_HSIZE || np < 1)
+		goto notelf;
+	if (ph + (np + 2) * ps + nnote + nnote2 > n)
+		goto nospace;
+
+	for (i = 0; i < np; ++i) {
+		if (GET_32BE(ph + PH_TYPE) == PT_NOTE) {
+			fprintf(stderr, "%s already has a note entry\n",
+				av[1]);
+			exit(0);
+		}
+		ph += ps;
+	}
+
+	/* XXX check that the area we want to use is all zeroes */
+	for (i = 0; i < 2 * ps + nnote + nnote2; ++i)
+		if (buf[ph + i] != 0)
+			goto nospace;
+
+	/* fill in the program header entry */
+	ns = ph + 2 * ps;
+	PUT_32BE(ph + PH_TYPE, PT_NOTE);
+	PUT_32BE(ph + PH_OFFSET, ns);
+	PUT_32BE(ph + PH_FILESZ, nnote);
+
+	/* fill in the note area we point to */
+	/* XXX we should probably make this a proper section */
+	PUT_32BE(ns, strlen(arch) + 1);
+	PUT_32BE(ns + 4, N_DESCR * 4);
+	PUT_32BE(ns + 8, 0x1275);
+	strcpy((char *) &buf[ns + 12], arch);
+	ns += 12 + strlen(arch) + 1;
+	for (i = 0; i < N_DESCR; ++i, ns += 4)
+		PUT_32BE(ns, descr[i]);
+
+	/* fill in the second program header entry and the RPA note area */
+	ph += ps;
+	PUT_32BE(ph + PH_TYPE, PT_NOTE);
+	PUT_32BE(ph + PH_OFFSET, ns);
+	PUT_32BE(ph + PH_FILESZ, nnote2);
+
+	/* fill in the note area we point to */
+	PUT_32BE(ns, strlen(rpaname) + 1);
+	PUT_32BE(ns + 4, sizeof(rpanote));
+	PUT_32BE(ns + 8, 0x12759999);
+	strcpy((char *) &buf[ns + 12], rpaname);
+	ns += 12 + ROUNDUP(strlen(rpaname) + 1);
+	for (i = 0; i < N_RPA_DESCR; ++i, ns += 4)
+		PUT_32BE(ns, rpanote[i]);
+
+	/* Update the number of program headers */
+	PUT_16BE(E_PHNUM, np + 2);
+
+	/* write back */
+	lseek(fd, (long) 0, SEEK_SET);
+	i = write(fd, buf, n);
+	if (i < 0) {
+		perror("write");
+		exit(1);
+	}
+	if (i < n) {
+		fprintf(stderr, "%s: write truncated\n", av[1]);
+		exit(1);
+	}
+
+	exit(0);
+
+ notelf:
+	fprintf(stderr, "%s does not appear to be an ELF file\n", av[1]);
+	exit(1);
+
+ nospace:
+	fprintf(stderr, "sorry, I can't find space in %s to put the note\n",
+		av[1]);
+	exit(1);
+}
