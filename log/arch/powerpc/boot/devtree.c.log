commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index a7e21a35c03a..5d91036ad626 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * devtree.c - convenience functions for device tree manipulation
  * Copyright 2007 David Gibson, IBM Corporation.
@@ -5,11 +6,6 @@
  *
  * Authors: David Gibson <david@gibson.dropbear.id.au>
  *	    Scott Wood <scottwood@freescale.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 #include <stdarg.h>
 #include <stddef.h>

commit 49e6e3f1aec2d46f5865d3ada38fe9a5d660ef5d
Author: Scott Wood <scottwood@freescale.com>
Date:   Fri Dec 19 10:13:09 2008 +0000

    powerpc/bootwrapper: Use the child-bus #address-cells to decide which range entry to use
    
    The correct #address-cells was still used for the actual translation,
    so the impact is only a possibility of choosing the wrong range entry
    or failing to find any match.  Most common cases were not affected.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index 5d12336dc360..a7e21a35c03a 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -213,7 +213,7 @@ static int find_range(u32 *reg, u32 *ranges, int nregaddr,
 		u32 range_addr[MAX_ADDR_CELLS];
 		u32 range_size[MAX_ADDR_CELLS];
 
-		copy_val(range_addr, ranges + i, naddr);
+		copy_val(range_addr, ranges + i, nregaddr);
 		copy_val(range_size, ranges + i + nregaddr + naddr, nsize);
 
 		if (compare_reg(reg, range_addr, range_size))

commit da0a5f0c65913e4ec0a70a5019ce0a7bcaab21c9
Author: Laurent Pinchart <laurentp@cse-semaphore.com>
Date:   Thu Apr 10 17:03:04 2008 +0200

    [POWERPC] Add bootwrapper function to get virtual reg from the device tree.
    
    This patch adds a new generic device tree processing function that retrieves
    virtual reg addresses from the device tree to the bootwrapper code. It also
    updates the bootwrapper code to use the new function.
    
    dt_get_virtual_reg() retrieves the virtual reg addresses from the
    "virtual-reg" property. If the property can't be found, it uses the "reg"
    property and walks the tree to translate it to absolute addresses.
    
    Signed-off-by: Laurent Pinchart <laurentp@cse-semaphore.com>
    Acked-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index 60f561e307a9..5d12336dc360 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -350,3 +350,23 @@ int dt_is_compatible(void *node, const char *compat)
 
 	return 0;
 }
+
+int dt_get_virtual_reg(void *node, void **addr, int nres)
+{
+	unsigned long xaddr;
+	int n;
+
+	n = getprop(node, "virtual-reg", addr, nres * 4);
+	if (n > 0)
+		return n / 4;
+
+	for (n = 0; n < nres; n++) {
+		if (!dt_xlate_reg(node, n, &xaddr, NULL))
+			break;
+
+		addr[n] = (void *)xaddr;
+	}
+
+	return n;
+}
+

commit ad160681c8caa0a73e6abd3ac606cd857608f94a
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Tue Jan 15 09:30:32 2008 -0600

    [POWERPC] bootwrapper: Add find_node_by_alias and dt_fixup_mac_address_by_alias
    
    Add the ability to set the mac address given the alias for the device.
    Removes the need for having a linux,network-index property.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index e5dfe4497313..60f561e307a9 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -88,6 +88,20 @@ void dt_fixup_clock(const char *path, u32 freq)
 	}
 }
 
+void dt_fixup_mac_address_by_alias(const char *alias, const u8 *addr)
+{
+	void *devp = find_node_by_alias(alias);
+
+	if (devp) {
+		printf("%s: local-mac-address <-"
+		       " %02x:%02x:%02x:%02x:%02x:%02x\n\r", alias,
+		       addr[0], addr[1], addr[2],
+		       addr[3], addr[4], addr[5]);
+
+		setprop(devp, "local-mac-address", addr, 6);
+	}
+}
+
 void dt_fixup_mac_address(u32 index, const u8 *addr)
 {
 	void *devp = find_node_by_prop_value(NULL, "linux,network-index",

commit 27ff35d9026b5d41d66ed95b65d7819db4cf5fb1
Author: Scott Wood <scottwood@freescale.com>
Date:   Tue Sep 25 06:09:11 2007 +1000

    [POWERPC] bootwrapper: Factor out dt_set_mac_address()
    
    This allows callers to set addresses one at a time when that would be more
    convenient.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Acked-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index 549463bf5eec..e5dfe4497313 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -88,29 +88,32 @@ void dt_fixup_clock(const char *path, u32 freq)
 	}
 }
 
+void dt_fixup_mac_address(u32 index, const u8 *addr)
+{
+	void *devp = find_node_by_prop_value(NULL, "linux,network-index",
+	                                     (void*)&index, sizeof(index));
+
+	if (devp) {
+		printf("ENET%d: local-mac-address <-"
+		       " %02x:%02x:%02x:%02x:%02x:%02x\n\r", index,
+		       addr[0], addr[1], addr[2],
+		       addr[3], addr[4], addr[5]);
+
+		setprop(devp, "local-mac-address", addr, 6);
+	}
+}
+
 void __dt_fixup_mac_addresses(u32 startindex, ...)
 {
 	va_list ap;
 	u32 index = startindex;
-	void *devp;
 	const u8 *addr;
 
 	va_start(ap, startindex);
-	while ((addr = va_arg(ap, const u8 *))) {
-		devp = find_node_by_prop_value(NULL, "linux,network-index",
-					       (void*)&index, sizeof(index));
 
-		if (devp) {
-			printf("ENET%d: local-mac-address <-"
-			       " %02x:%02x:%02x:%02x:%02x:%02x\n\r", index,
-			       addr[0], addr[1], addr[2],
-			       addr[3], addr[4], addr[5]);
+	while ((addr = va_arg(ap, const u8 *)))
+		dt_fixup_mac_address(index++, addr);
 
-			setprop(devp, "local-mac-address", addr, 6);
-		}
-
-		index++;
-	}
 	va_end(ap);
 }
 

commit 96ebc3bfb6ddedd5a400d5653b50551d5a3de439
Author: Scott Wood <scottwood@freescale.com>
Date:   Thu Sep 6 05:21:18 2007 +1000

    [POWERPC] bootwrapper: Only print MAC addresses when the node is actually present
    
    Some firmwares (such as PlanetCore) only provide a base MAC address, and
    expect the kernel to set certain bits to generate the addresses for the
    other ports.  As such, MAC addresses are generated that may not correspond
    to actual hardware.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Acked-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index e1b8122b4393..549463bf5eec 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -100,12 +100,14 @@ void __dt_fixup_mac_addresses(u32 startindex, ...)
 		devp = find_node_by_prop_value(NULL, "linux,network-index",
 					       (void*)&index, sizeof(index));
 
-		printf("ENET%d: local-mac-address <-"
-		       " %02x:%02x:%02x:%02x:%02x:%02x\n\r", index,
-		       addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+		if (devp) {
+			printf("ENET%d: local-mac-address <-"
+			       " %02x:%02x:%02x:%02x:%02x:%02x\n\r", index,
+			       addr[0], addr[1], addr[2],
+			       addr[3], addr[4], addr[5]);
 
-		if (devp)
 			setprop(devp, "local-mac-address", addr, 6);
+		}
 
 		index++;
 	}

commit e5d8d54db25790524da34b0143f4e0176fb7677b
Author: Scott Wood <scottwood@freescale.com>
Date:   Tue Aug 21 03:40:02 2007 +1000

    [POWERPC] bootwrapper: Add PowerQUICC II (82xx with CPM) cuboot support
    
    This allows booting on legacy, non-device-tree aware versions of U-boot.
    
    It also fixes up the hardware to match the PCI and chipselect information
    in the device tree, as u-boot is inconsistent in setting these up
    correctly (or at all).
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Acked-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index 3a18bfe0fdf7..e1b8122b4393 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -114,7 +114,7 @@ void __dt_fixup_mac_addresses(u32 startindex, ...)
 
 #define MAX_ADDR_CELLS 4
 
-static void get_reg_format(void *node, u32 *naddr, u32 *nsize)
+void dt_get_reg_format(void *node, u32 *naddr, u32 *nsize)
 {
 	if (getprop(node, "#address-cells", naddr, 4) != 4)
 		*naddr = 2;
@@ -224,7 +224,7 @@ static int dt_xlate(void *node, int res, int reglen, unsigned long *addr,
 	if (!parent)
 		return 0;
 
-	get_reg_format(parent, &naddr, &nsize);
+	dt_get_reg_format(parent, &naddr, &nsize);
 
 	if (nsize > 2)
 		return 0;
@@ -252,7 +252,7 @@ static int dt_xlate(void *node, int res, int reglen, unsigned long *addr,
 		if (!parent)
 			break;
 
-		get_reg_format(parent, &naddr, &nsize);
+		dt_get_reg_format(parent, &naddr, &nsize);
 
 		buflen = getprop(node, "ranges", prop_buf,
 				sizeof(prop_buf));

commit a73ac50c4787b1b28d5c94bb18c60352f5dd7d6f
Author: Scott Wood <scottwood@freescale.com>
Date:   Tue Aug 21 03:39:48 2007 +1000

    [POWERPC] bootwrapper: Add dt_is_compatible()
    
    This can be used rather than doing a simple strcmp, which will fail to
    handle multiple compatible entries.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Acked-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index 129e6d9b8d43..3a18bfe0fdf7 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -113,7 +113,6 @@ void __dt_fixup_mac_addresses(u32 startindex, ...)
 }
 
 #define MAX_ADDR_CELLS 4
-#define MAX_RANGES 8
 
 static void get_reg_format(void *node, u32 *naddr, u32 *nsize)
 {
@@ -209,7 +208,7 @@ static int find_range(u32 *reg, u32 *ranges, int nregaddr,
  * In particular, PCI is not supported.  Also, only the beginning of the
  * reg block is tracked; size is ignored except in ranges.
  */
-static u32 dt_xlate_buf[MAX_ADDR_CELLS * MAX_RANGES * 3];
+static u32 prop_buf[MAX_PROP_LEN / 4];
 
 static int dt_xlate(void *node, int res, int reglen, unsigned long *addr,
 		unsigned long *size)
@@ -233,15 +232,15 @@ static int dt_xlate(void *node, int res, int reglen, unsigned long *addr,
 	offset = (naddr + nsize) * res;
 
 	if (reglen < offset + naddr + nsize ||
-	    sizeof(dt_xlate_buf) < (offset + naddr + nsize) * 4)
+	    MAX_PROP_LEN < (offset + naddr + nsize) * 4)
 		return 0;
 
-	copy_val(last_addr, dt_xlate_buf + offset, naddr);
+	copy_val(last_addr, prop_buf + offset, naddr);
 
-	ret_size = dt_xlate_buf[offset + naddr];
+	ret_size = prop_buf[offset + naddr];
 	if (nsize == 2) {
 		ret_size <<= 32;
-		ret_size |= dt_xlate_buf[offset + naddr + 1];
+		ret_size |= prop_buf[offset + naddr + 1];
 	}
 
 	for (;;) {
@@ -255,25 +254,25 @@ static int dt_xlate(void *node, int res, int reglen, unsigned long *addr,
 
 		get_reg_format(parent, &naddr, &nsize);
 
-		buflen = getprop(node, "ranges", dt_xlate_buf,
-				sizeof(dt_xlate_buf));
+		buflen = getprop(node, "ranges", prop_buf,
+				sizeof(prop_buf));
 		if (buflen == 0)
 			continue;
-		if (buflen < 0 || buflen > sizeof(dt_xlate_buf))
+		if (buflen < 0 || buflen > sizeof(prop_buf))
 			return 0;
 
-		offset = find_range(last_addr, dt_xlate_buf, prev_naddr,
+		offset = find_range(last_addr, prop_buf, prev_naddr,
 		                    naddr, prev_nsize, buflen / 4);
 
 		if (offset < 0)
 			return 0;
 
-		copy_val(this_addr, dt_xlate_buf + offset, prev_naddr);
+		copy_val(this_addr, prop_buf + offset, prev_naddr);
 
 		if (!sub_reg(last_addr, this_addr))
 			return 0;
 
-		copy_val(this_addr, dt_xlate_buf + offset + prev_naddr, naddr);
+		copy_val(this_addr, prop_buf + offset + prev_naddr, naddr);
 
 		if (!add_reg(last_addr, this_addr, naddr))
 			return 0;
@@ -300,16 +299,35 @@ int dt_xlate_reg(void *node, int res, unsigned long *addr, unsigned long *size)
 {
 	int reglen;
 
-	reglen = getprop(node, "reg", dt_xlate_buf, sizeof(dt_xlate_buf)) / 4;
+	reglen = getprop(node, "reg", prop_buf, sizeof(prop_buf)) / 4;
 	return dt_xlate(node, res, reglen, addr, size);
 }
 
 int dt_xlate_addr(void *node, u32 *buf, int buflen, unsigned long *xlated_addr)
 {
 
-	if (buflen > sizeof(dt_xlate_buf))
+	if (buflen > sizeof(prop_buf))
 		return 0;
 
-	memcpy(dt_xlate_buf, buf, buflen);
+	memcpy(prop_buf, buf, buflen);
 	return dt_xlate(node, 0, buflen / 4, xlated_addr, NULL);
 }
+
+int dt_is_compatible(void *node, const char *compat)
+{
+	char *buf = (char *)prop_buf;
+	int len, pos;
+
+	len = getprop(node, "compatible", buf, MAX_PROP_LEN);
+	if (len < 0)
+		return 0;
+
+	for (pos = 0; pos < len; pos++) {
+		if (!strcmp(buf + pos, compat))
+			return 1;
+
+		pos += strnlen(&buf[pos], len - pos);
+	}
+
+	return 0;
+}

commit 0602801c22ea1767cd0298b11da140bd5cb764d2
Author: Scott Wood <scottwood@freescale.com>
Date:   Tue Aug 21 03:39:46 2007 +1000

    [POWERPC] bootwrapper: dt_xlate_range() bugfixes
    
    1. The check whether ranges fits in the buffer was using elements rather
    than bytes.
    2. Empty ranges were not properly treated as transparent, and missing
    ranges were treated as transparent.
    3. The loop terminated when translating from the root rather than to.  Once
    bug #2 was fixed, it failed due to a missing ranges in the root node.
    4. In decoding the ranges property, the #size-cells used was that of
    the parent, not the child.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Acked-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index ae8b886f5a1d..129e6d9b8d43 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -218,7 +218,7 @@ static int dt_xlate(void *node, int res, int reglen, unsigned long *addr,
 	u32 this_addr[MAX_ADDR_CELLS];
 	void *parent;
 	u64 ret_addr, ret_size;
-	u32 naddr, nsize, prev_naddr;
+	u32 naddr, nsize, prev_naddr, prev_nsize;
 	int buflen, offset;
 
 	parent = get_parent(node);
@@ -233,7 +233,7 @@ static int dt_xlate(void *node, int res, int reglen, unsigned long *addr,
 	offset = (naddr + nsize) * res;
 
 	if (reglen < offset + naddr + nsize ||
-	    sizeof(dt_xlate_buf) < offset + naddr + nsize)
+	    sizeof(dt_xlate_buf) < (offset + naddr + nsize) * 4)
 		return 0;
 
 	copy_val(last_addr, dt_xlate_buf + offset, naddr);
@@ -244,20 +244,26 @@ static int dt_xlate(void *node, int res, int reglen, unsigned long *addr,
 		ret_size |= dt_xlate_buf[offset + naddr + 1];
 	}
 
-	while ((node = get_parent(node))) {
+	for (;;) {
 		prev_naddr = naddr;
+		prev_nsize = nsize;
+		node = parent;
 
-		get_reg_format(node, &naddr, &nsize);
+		parent = get_parent(node);
+		if (!parent)
+			break;
+
+		get_reg_format(parent, &naddr, &nsize);
 
 		buflen = getprop(node, "ranges", dt_xlate_buf,
 				sizeof(dt_xlate_buf));
-		if (buflen < 0)
+		if (buflen == 0)
 			continue;
-		if (buflen > sizeof(dt_xlate_buf))
+		if (buflen < 0 || buflen > sizeof(dt_xlate_buf))
 			return 0;
 
 		offset = find_range(last_addr, dt_xlate_buf, prev_naddr,
-		                    naddr, nsize, buflen / 4);
+		                    naddr, prev_nsize, buflen / 4);
 
 		if (offset < 0)
 			return 0;

commit 643d3c139b0a5289d7f0ba19fdcb24be6d7e768f
Author: Scott Wood <scottwood@freescale.com>
Date:   Tue Aug 21 03:39:45 2007 +1000

    [POWERPC] bootwrapper: Set timebase_period_ns from dt_fixup_cpu_clocks
    
    This lets udelay() work properly on platforms which use dt_fixup_cpu_clocks.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Acked-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index c9951550ed2c..ae8b886f5a1d 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -74,6 +74,8 @@ void dt_fixup_cpu_clocks(u32 cpu, u32 tb, u32 bus)
 		if (bus > 0)
 			setprop_val(devp, "bus-frequency", bus);
 	}
+
+	timebase_period_ns = 1000000000 / tb;
 }
 
 void dt_fixup_clock(const char *path, u32 freq)

commit 8895ea483e144f8acca16adfff7c60a993e77b7d
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Sat Apr 28 06:48:24 2007 +1000

    [POWERPC] Add dt_xlate_addr() to bootwrapper
    
    dt_xlate_reg() looks up the 'reg' property in the specified node
    to get the address and size to translate.  Add dt_xlate_addr()
    which is passed in the address and size to translate.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index ac4b5ee92d58..c9951550ed2c 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -207,12 +207,13 @@ static int find_range(u32 *reg, u32 *ranges, int nregaddr,
  * In particular, PCI is not supported.  Also, only the beginning of the
  * reg block is tracked; size is ignored except in ranges.
  */
-int dt_xlate_reg(void *node, int res, unsigned long *addr,
-                 unsigned long *size)
+static u32 dt_xlate_buf[MAX_ADDR_CELLS * MAX_RANGES * 3];
+
+static int dt_xlate(void *node, int res, int reglen, unsigned long *addr,
+		unsigned long *size)
 {
 	u32 last_addr[MAX_ADDR_CELLS];
 	u32 this_addr[MAX_ADDR_CELLS];
-	u32 buf[MAX_ADDR_CELLS * MAX_RANGES * 3];
 	void *parent;
 	u64 ret_addr, ret_size;
 	u32 naddr, nsize, prev_naddr;
@@ -227,19 +228,18 @@ int dt_xlate_reg(void *node, int res, unsigned long *addr,
 	if (nsize > 2)
 		return 0;
 
-	buflen = getprop(node, "reg", buf, sizeof(buf)) / 4;
 	offset = (naddr + nsize) * res;
 
-	if (buflen < offset + naddr + nsize ||
-	    sizeof(buf) < offset + naddr + nsize)
+	if (reglen < offset + naddr + nsize ||
+	    sizeof(dt_xlate_buf) < offset + naddr + nsize)
 		return 0;
 
-	copy_val(last_addr, buf + offset, naddr);
+	copy_val(last_addr, dt_xlate_buf + offset, naddr);
 
-	ret_size = buf[offset + naddr];
+	ret_size = dt_xlate_buf[offset + naddr];
 	if (nsize == 2) {
 		ret_size <<= 32;
-		ret_size |= buf[offset + naddr + 1];
+		ret_size |= dt_xlate_buf[offset + naddr + 1];
 	}
 
 	while ((node = get_parent(node))) {
@@ -247,24 +247,25 @@ int dt_xlate_reg(void *node, int res, unsigned long *addr,
 
 		get_reg_format(node, &naddr, &nsize);
 
-		buflen = getprop(node, "ranges", buf, sizeof(buf));
+		buflen = getprop(node, "ranges", dt_xlate_buf,
+				sizeof(dt_xlate_buf));
 		if (buflen < 0)
 			continue;
-		if (buflen > sizeof(buf))
+		if (buflen > sizeof(dt_xlate_buf))
 			return 0;
 
-		offset = find_range(last_addr, buf, prev_naddr,
+		offset = find_range(last_addr, dt_xlate_buf, prev_naddr,
 		                    naddr, nsize, buflen / 4);
 
 		if (offset < 0)
 			return 0;
 
-		copy_val(this_addr, buf + offset, prev_naddr);
+		copy_val(this_addr, dt_xlate_buf + offset, prev_naddr);
 
 		if (!sub_reg(last_addr, this_addr))
 			return 0;
 
-		copy_val(this_addr, buf + offset + prev_naddr, naddr);
+		copy_val(this_addr, dt_xlate_buf + offset + prev_naddr, naddr);
 
 		if (!add_reg(last_addr, this_addr, naddr))
 			return 0;
@@ -286,3 +287,21 @@ int dt_xlate_reg(void *node, int res, unsigned long *addr,
 
 	return 1;
 }
+
+int dt_xlate_reg(void *node, int res, unsigned long *addr, unsigned long *size)
+{
+	int reglen;
+
+	reglen = getprop(node, "reg", dt_xlate_buf, sizeof(dt_xlate_buf)) / 4;
+	return dt_xlate(node, res, reglen, addr, size);
+}
+
+int dt_xlate_addr(void *node, u32 *buf, int buflen, unsigned long *xlated_addr)
+{
+
+	if (buflen > sizeof(dt_xlate_buf))
+		return 0;
+
+	memcpy(dt_xlate_buf, buf, buflen);
+	return dt_xlate(node, 0, buflen / 4, xlated_addr, NULL);
+}

commit e4bb688d9f11d7fee927312cc97d443472c7c212
Author: Scott Wood <scottwood@freescale.com>
Date:   Fri Apr 27 03:08:13 2007 +1000

    [POWERPC] bootwrapper: Fix array handling in dt_xlate_reg().
    
    This fixes a few bugs in how dt_xlate_reg() handles address arrays:
    
    1. copy_val() was copying into the wrong end of the array, resulting
    in random stack garbage at the other end.
    2. dt_xlate_reg() was getting the result from the wrong end of the array.
    3. add_reg() and sub_reg() were treating the arrays as
    little-endian rather than big-endian.
    4. add_reg() only returned an error on a carry out of the entire
    array, rather than out of the naddr portion.
    5. The requested reg resource was checked to see if it exceeded
    the size of the reg property, but not to see if it exceeded the
    size of the buffer.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index 23492d7fb556..ac4b5ee92d58 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -123,15 +123,17 @@ static void get_reg_format(void *node, u32 *naddr, u32 *nsize)
 
 static void copy_val(u32 *dest, u32 *src, int naddr)
 {
-	memset(dest, 0, (MAX_ADDR_CELLS - naddr) * 4);
-	memcpy(dest, src, naddr * 4);
+	int pad = MAX_ADDR_CELLS - naddr;
+
+	memset(dest, 0, pad * 4);
+	memcpy(dest + pad, src, naddr * 4);
 }
 
 static int sub_reg(u32 *reg, u32 *sub)
 {
 	int i, borrow = 0;
 
-	for (i = 0; i < MAX_ADDR_CELLS; i++) {
+	for (i = MAX_ADDR_CELLS - 1; i >= 0; i--) {
 		int prev_borrow = borrow;
 		borrow = reg[i] < sub[i] + prev_borrow;
 		reg[i] -= sub[i] + prev_borrow;
@@ -140,11 +142,11 @@ static int sub_reg(u32 *reg, u32 *sub)
 	return !borrow;
 }
 
-static int add_reg(u32 *reg, u32 *add)
+static int add_reg(u32 *reg, u32 *add, int naddr)
 {
 	int i, carry = 0;
 
-	for (i = 0; i < MAX_ADDR_CELLS; i++) {
+	for (i = MAX_ADDR_CELLS - 1; i >= MAX_ADDR_CELLS - naddr; i--) {
 		u64 tmp = (u64)reg[i] + add[i] + carry;
 		carry = tmp >> 32;
 		reg[i] = (u32)tmp;
@@ -228,7 +230,8 @@ int dt_xlate_reg(void *node, int res, unsigned long *addr,
 	buflen = getprop(node, "reg", buf, sizeof(buf)) / 4;
 	offset = (naddr + nsize) * res;
 
-	if (buflen < offset + naddr + nsize)
+	if (buflen < offset + naddr + nsize ||
+	    sizeof(buf) < offset + naddr + nsize)
 		return 0;
 
 	copy_val(last_addr, buf + offset, naddr);
@@ -263,18 +266,14 @@ int dt_xlate_reg(void *node, int res, unsigned long *addr,
 
 		copy_val(this_addr, buf + offset + prev_naddr, naddr);
 
-		if (!add_reg(last_addr, this_addr))
+		if (!add_reg(last_addr, this_addr, naddr))
 			return 0;
 	}
 
 	if (naddr > 2)
 		return 0;
 
-	ret_addr = last_addr[0];
-	if (naddr == 2) {
-		ret_addr <<= 32;
-		ret_addr |= last_addr[1];
-	}
+	ret_addr = ((u64)last_addr[2] << 32) | last_addr[3];
 
 	if (sizeof(void *) == 4 &&
 	    (ret_addr >= 0x100000000ULL || ret_size > 0x100000000ULL ||

commit 6e1af384f1c1742ae6d86bbf779d4fa020c509bc
Author: Scott Wood <scottwood@freescale.com>
Date:   Mon Mar 26 15:52:24 2007 -0500

    [POWERPC] bootwrapper: Add dt_xlate_reg(), and use it to find serial registers.
    
    dt_xlate_reg() uses the ranges properties of a node's parentage to find
    the absolute physical address of the node's registers.
    
    The ns16550 driver uses this when no virtual-reg property is found.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
index 708cadebeb46..23492d7fb556 100644
--- a/arch/powerpc/boot/devtree.c
+++ b/arch/powerpc/boot/devtree.c
@@ -109,3 +109,181 @@ void __dt_fixup_mac_addresses(u32 startindex, ...)
 	}
 	va_end(ap);
 }
+
+#define MAX_ADDR_CELLS 4
+#define MAX_RANGES 8
+
+static void get_reg_format(void *node, u32 *naddr, u32 *nsize)
+{
+	if (getprop(node, "#address-cells", naddr, 4) != 4)
+		*naddr = 2;
+	if (getprop(node, "#size-cells", nsize, 4) != 4)
+		*nsize = 1;
+}
+
+static void copy_val(u32 *dest, u32 *src, int naddr)
+{
+	memset(dest, 0, (MAX_ADDR_CELLS - naddr) * 4);
+	memcpy(dest, src, naddr * 4);
+}
+
+static int sub_reg(u32 *reg, u32 *sub)
+{
+	int i, borrow = 0;
+
+	for (i = 0; i < MAX_ADDR_CELLS; i++) {
+		int prev_borrow = borrow;
+		borrow = reg[i] < sub[i] + prev_borrow;
+		reg[i] -= sub[i] + prev_borrow;
+	}
+
+	return !borrow;
+}
+
+static int add_reg(u32 *reg, u32 *add)
+{
+	int i, carry = 0;
+
+	for (i = 0; i < MAX_ADDR_CELLS; i++) {
+		u64 tmp = (u64)reg[i] + add[i] + carry;
+		carry = tmp >> 32;
+		reg[i] = (u32)tmp;
+	}
+
+	return !carry;
+}
+
+/* It is assumed that if the first byte of reg fits in a
+ * range, then the whole reg block fits.
+ */
+static int compare_reg(u32 *reg, u32 *range, u32 *rangesize)
+{
+	int i;
+	u32 end;
+
+	for (i = 0; i < MAX_ADDR_CELLS; i++) {
+		if (reg[i] < range[i])
+			return 0;
+		if (reg[i] > range[i])
+			break;
+	}
+
+	for (i = 0; i < MAX_ADDR_CELLS; i++) {
+		end = range[i] + rangesize[i];
+
+		if (reg[i] < end)
+			break;
+		if (reg[i] > end)
+			return 0;
+	}
+
+	return reg[i] != end;
+}
+
+/* reg must be MAX_ADDR_CELLS */
+static int find_range(u32 *reg, u32 *ranges, int nregaddr,
+                      int naddr, int nsize, int buflen)
+{
+	int nrange = nregaddr + naddr + nsize;
+	int i;
+
+	for (i = 0; i + nrange <= buflen; i += nrange) {
+		u32 range_addr[MAX_ADDR_CELLS];
+		u32 range_size[MAX_ADDR_CELLS];
+
+		copy_val(range_addr, ranges + i, naddr);
+		copy_val(range_size, ranges + i + nregaddr + naddr, nsize);
+
+		if (compare_reg(reg, range_addr, range_size))
+			return i;
+	}
+
+	return -1;
+}
+
+/* Currently only generic buses without special encodings are supported.
+ * In particular, PCI is not supported.  Also, only the beginning of the
+ * reg block is tracked; size is ignored except in ranges.
+ */
+int dt_xlate_reg(void *node, int res, unsigned long *addr,
+                 unsigned long *size)
+{
+	u32 last_addr[MAX_ADDR_CELLS];
+	u32 this_addr[MAX_ADDR_CELLS];
+	u32 buf[MAX_ADDR_CELLS * MAX_RANGES * 3];
+	void *parent;
+	u64 ret_addr, ret_size;
+	u32 naddr, nsize, prev_naddr;
+	int buflen, offset;
+
+	parent = get_parent(node);
+	if (!parent)
+		return 0;
+
+	get_reg_format(parent, &naddr, &nsize);
+
+	if (nsize > 2)
+		return 0;
+
+	buflen = getprop(node, "reg", buf, sizeof(buf)) / 4;
+	offset = (naddr + nsize) * res;
+
+	if (buflen < offset + naddr + nsize)
+		return 0;
+
+	copy_val(last_addr, buf + offset, naddr);
+
+	ret_size = buf[offset + naddr];
+	if (nsize == 2) {
+		ret_size <<= 32;
+		ret_size |= buf[offset + naddr + 1];
+	}
+
+	while ((node = get_parent(node))) {
+		prev_naddr = naddr;
+
+		get_reg_format(node, &naddr, &nsize);
+
+		buflen = getprop(node, "ranges", buf, sizeof(buf));
+		if (buflen < 0)
+			continue;
+		if (buflen > sizeof(buf))
+			return 0;
+
+		offset = find_range(last_addr, buf, prev_naddr,
+		                    naddr, nsize, buflen / 4);
+
+		if (offset < 0)
+			return 0;
+
+		copy_val(this_addr, buf + offset, prev_naddr);
+
+		if (!sub_reg(last_addr, this_addr))
+			return 0;
+
+		copy_val(this_addr, buf + offset + prev_naddr, naddr);
+
+		if (!add_reg(last_addr, this_addr))
+			return 0;
+	}
+
+	if (naddr > 2)
+		return 0;
+
+	ret_addr = last_addr[0];
+	if (naddr == 2) {
+		ret_addr <<= 32;
+		ret_addr |= last_addr[1];
+	}
+
+	if (sizeof(void *) == 4 &&
+	    (ret_addr >= 0x100000000ULL || ret_size > 0x100000000ULL ||
+	     ret_addr + ret_size > 0x100000000ULL))
+		return 0;
+
+	*addr = ret_addr;
+	if (size)
+		*size = ret_size;
+
+	return 1;
+}

commit 27fbaa9702e548e74dffd21855769f6cedad42bd
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Thu Mar 22 17:02:21 2007 +1100

    [POWERPC] Add device tree utility functions to zImage
    
    This patch adds a library of useful device tree manipulation functions
    to the zImage library, for use by platform code.  These functions are
    based on the hooks already in dt_ops, so they're not dependent on a
    particular device tree implementation.  This patch also slightly
    streamlines the code in main.c using these new functions.
    
    This is a consolidation of my work in this area with Scott Wood's
    patches to a very similar end.
    
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/devtree.c b/arch/powerpc/boot/devtree.c
new file mode 100644
index 000000000000..708cadebeb46
--- /dev/null
+++ b/arch/powerpc/boot/devtree.c
@@ -0,0 +1,111 @@
+/*
+ * devtree.c - convenience functions for device tree manipulation
+ * Copyright 2007 David Gibson, IBM Corporation.
+ * Copyright (c) 2007 Freescale Semiconductor, Inc.
+ *
+ * Authors: David Gibson <david@gibson.dropbear.id.au>
+ *	    Scott Wood <scottwood@freescale.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+#include <stdarg.h>
+#include <stddef.h>
+#include "types.h"
+#include "string.h"
+#include "stdio.h"
+#include "ops.h"
+
+void dt_fixup_memory(u64 start, u64 size)
+{
+	void *root, *memory;
+	int naddr, nsize, i;
+	u32 memreg[4];
+
+	root = finddevice("/");
+	if (getprop(root, "#address-cells", &naddr, sizeof(naddr)) < 0)
+		naddr = 2;
+	if (naddr < 1 || naddr > 2)
+		fatal("Can't cope with #address-cells == %d in /\n\r", naddr);
+
+	if (getprop(root, "#size-cells", &nsize, sizeof(nsize)) < 0)
+		nsize = 1;
+	if (nsize < 1 || nsize > 2)
+		fatal("Can't cope with #size-cells == %d in /\n\r", nsize);
+
+	i = 0;
+	if (naddr == 2)
+		memreg[i++] = start >> 32;
+	memreg[i++] = start & 0xffffffff;
+	if (nsize == 2)
+		memreg[i++] = size >> 32;
+	memreg[i++] = size & 0xffffffff;
+
+	memory = finddevice("/memory");
+	if (! memory) {
+		memory = create_node(NULL, "memory");
+		setprop_str(memory, "device_type", "memory");
+	}
+
+	printf("Memory <- <0x%x", memreg[0]);
+	for (i = 1; i < (naddr + nsize); i++)
+		printf(" 0x%x", memreg[i]);
+	printf("> (%ldMB)\n\r", (unsigned long)(size >> 20));
+
+	setprop(memory, "reg", memreg, (naddr + nsize)*sizeof(u32));
+}
+
+#define MHZ(x)	((x + 500000) / 1000000)
+
+void dt_fixup_cpu_clocks(u32 cpu, u32 tb, u32 bus)
+{
+	void *devp = NULL;
+
+	printf("CPU clock-frequency <- 0x%x (%dMHz)\n\r", cpu, MHZ(cpu));
+	printf("CPU timebase-frequency <- 0x%x (%dMHz)\n\r", tb, MHZ(tb));
+	if (bus > 0)
+		printf("CPU bus-frequency <- 0x%x (%dMHz)\n\r", bus, MHZ(bus));
+
+	while ((devp = find_node_by_devtype(devp, "cpu"))) {
+		setprop_val(devp, "clock-frequency", cpu);
+		setprop_val(devp, "timebase-frequency", tb);
+		if (bus > 0)
+			setprop_val(devp, "bus-frequency", bus);
+	}
+}
+
+void dt_fixup_clock(const char *path, u32 freq)
+{
+	void *devp = finddevice(path);
+
+	if (devp) {
+		printf("%s: clock-frequency <- %x (%dMHz)\n\r", path, freq, MHZ(freq));
+		setprop_val(devp, "clock-frequency", freq);
+	}
+}
+
+void __dt_fixup_mac_addresses(u32 startindex, ...)
+{
+	va_list ap;
+	u32 index = startindex;
+	void *devp;
+	const u8 *addr;
+
+	va_start(ap, startindex);
+	while ((addr = va_arg(ap, const u8 *))) {
+		devp = find_node_by_prop_value(NULL, "linux,network-index",
+					       (void*)&index, sizeof(index));
+
+		printf("ENET%d: local-mac-address <-"
+		       " %02x:%02x:%02x:%02x:%02x:%02x\n\r", index,
+		       addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);
+
+		if (devp)
+			setprop(devp, "local-mac-address", addr, 6);
+
+		index++;
+	}
+	va_end(ap);
+}
