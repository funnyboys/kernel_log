commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index 7ca910cb2fc6..2fbd4ae60ec9 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -1,10 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) Paul Mackerras 1997.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 #include <stdarg.h>
 #include <stddef.h>

commit 034e55e6c2f8e2a9ea37901ea87bac8a08464441
Author: Cédric Le Goater <clg@fr.ibm.com>
Date:   Thu Apr 24 09:23:30 2014 +0200

    powerpc/boot: Rework of_claim() to make it 64bit friendly
    
    This patch fixes 64bit compile warnings and updates the wrapper code
    to converge the kernel code in prom_init.
    
    Signed-off-by: Cédric Le Goater <clg@fr.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index 62e2f43ec1df..7ca910cb2fc6 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -40,8 +40,8 @@ static void *of_try_claim(unsigned long size)
 #ifdef DEBUG
 		printf("    trying: 0x%08lx\n\r", claim_base);
 #endif
-		addr = (unsigned long)of_claim(claim_base, size, 0);
-		if ((void *)addr != (void *)-1)
+		addr = (unsigned long) of_claim(claim_base, size, 0);
+		if (addr != PROM_ERROR)
 			break;
 	}
 	if (addr == 0)

commit 0c9fa29149d3726e14262aeb0c8461a948cc9d56
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Sep 24 16:10:38 2013 +1000

    powerpc/zImage: make the "OF" wrapper support ePAPR boot
    
    This makes the "OF" zImage wrapper (zImage.pseries, zImage.pmac,
    zImage.maple) work if booted via a flat device-tree (ePAPR boot
    mode), and thus potentially usable with kexec.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index 61d9899aa0d0..62e2f43ec1df 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -26,6 +26,9 @@
 
 static unsigned long claim_base;
 
+void epapr_platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+			 unsigned long r6, unsigned long r7);
+
 static void *of_try_claim(unsigned long size)
 {
 	unsigned long addr = 0;
@@ -61,7 +64,7 @@ static void of_image_hdr(const void *hdr)
 	}
 }
 
-void platform_init(unsigned long a1, unsigned long a2, void *promptr)
+static void of_platform_init(unsigned long a1, unsigned long a2, void *promptr)
 {
 	platform_ops.image_hdr = of_image_hdr;
 	platform_ops.malloc = of_try_claim;
@@ -81,3 +84,14 @@ void platform_init(unsigned long a1, unsigned long a2, void *promptr)
 		loader_info.initrd_size = a2;
 	}
 }
+
+void platform_init(unsigned long r3, unsigned long r4, unsigned long r5,
+		   unsigned long r6, unsigned long r7)
+{
+	/* Detect OF vs. ePAPR boot */
+	if (r5)
+		of_platform_init(r3, r4, (void *)r5);
+	else
+		epapr_platform_init(r3, r4, r5, r6, r7);
+}
+

commit 2f1d4899321be87bc5f0c4ee0e62c9d9ced05f80
Author: Scott Wood <scottwood@freescale.com>
Date:   Tue Aug 21 03:39:58 2007 +1000

    [POWERPC] bootwrapper: Move linker symbols into ops.h
    
    Most of these were previously used by numerous C files and
    redeclared in each one.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index 385e08b83b7e..61d9899aa0d0 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -17,8 +17,6 @@
 
 #include "of.h"
 
-extern char _end[];
-
 /* Value picked to match that used by yaboot */
 #define PROG_START	0x01400000	/* only used on 64-bit systems */
 #define RAM_END		(512<<20)	/* Fixme: use OF */

commit 084647125227b870267859d544c91c03743816dc
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Wed Jun 27 16:54:58 2007 +1000

    [POWERPC] Make more OF-related bootwrapper functions available to non-OF platforms
    
    Commit 2e6016133755eb3cc44e8efab92573d23ed75888 split up
    arch/powerpc/boot/of.c so that some OF functions can be used on
    platforms that don't want to use the overall OF platform boot code.
    This is useful on things like PReP which can have an OF implementation
    which is useful for debugging output, but inadequate for booting.
    
    However, that commit didn't export quite enough things to make a
    usable OF console on a non-OF system.  In particular, the device tree
    manipulation performed to initialize the OF console code must
    explicitly use the OF device tree, rather than the flattened device
    tree, even if the system is otherwise booting using a flattened device
    tree.  This makes it so.
    
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index 6108aef28f03..385e08b83b7e 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -63,36 +63,6 @@ static void of_image_hdr(const void *hdr)
 	}
 }
 
-static void *of_vmlinux_alloc(unsigned long size)
-{
-	void *p = malloc(size);
-
-	if (!p)
-		fatal("Can't allocate memory for kernel image!\n\r");
-
-	return p;
-}
-
-/*
- * OF device tree routines
- */
-static void *of_finddevice(const char *name)
-{
-	return (phandle) of_call_prom("finddevice", 1, 1, name);
-}
-
-static int of_getprop(const void *phandle, const char *name, void *buf,
-		const int buflen)
-{
-	return of_call_prom("getprop", 4, 1, phandle, name, buf, buflen);
-}
-
-static int of_setprop(const void *phandle, const char *name, const void *buf,
-		const int buflen)
-{
-	return of_call_prom("setprop", 4, 1, phandle, name, buf, buflen);
-}
-
 void platform_init(unsigned long a1, unsigned long a2, void *promptr)
 {
 	platform_ops.image_hdr = of_image_hdr;

commit 2e6016133755eb3cc44e8efab92573d23ed75888
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Wed Jun 13 14:52:54 2007 +1000

    [POWERPC] Split low-level OF-related bootloader code into separate files
    
    Currently, all OF-related code in the bootloader is contained in of.c.
    of.c also provides the platform specific things necessary to boot on
    an OF platform.
    
    However, there are platforms (such as PReP) which can include an OF
    implementation, but are not bootable as pure OF systems.  For use by
    such platforms, this patch splits out the low-level parts of the OF
    code (call_prom() and various wrappers thereof) into a new oflib.c
    file.  In addition, the code related to bootwrapper console output via
    OF are moved to a new ofconsole.c file.  Both these files are included
    in the wrapper.a library where they can be used by both full-OF and
    partial OF platforms.
    
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index d16ee3e3f868..6108aef28f03 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -15,8 +15,7 @@
 #include "page.h"
 #include "ops.h"
 
-typedef void *ihandle;
-typedef void *phandle;
+#include "of.h"
 
 extern char _end[];
 
@@ -25,154 +24,10 @@ extern char _end[];
 #define RAM_END		(512<<20)	/* Fixme: use OF */
 #define	ONE_MB		0x100000
 
-int (*prom) (void *);
 
 
 static unsigned long claim_base;
 
-static int call_prom(const char *service, int nargs, int nret, ...)
-{
-	int i;
-	struct prom_args {
-		const char *service;
-		int nargs;
-		int nret;
-		unsigned int args[12];
-	} args;
-	va_list list;
-
-	args.service = service;
-	args.nargs = nargs;
-	args.nret = nret;
-
-	va_start(list, nret);
-	for (i = 0; i < nargs; i++)
-		args.args[i] = va_arg(list, unsigned int);
-	va_end(list);
-
-	for (i = 0; i < nret; i++)
-		args.args[nargs+i] = 0;
-
-	if (prom(&args) < 0)
-		return -1;
-
-	return (nret > 0)? args.args[nargs]: 0;
-}
-
-static int call_prom_ret(const char *service, int nargs, int nret,
-		  unsigned int *rets, ...)
-{
-	int i;
-	struct prom_args {
-		const char *service;
-		int nargs;
-		int nret;
-		unsigned int args[12];
-	} args;
-	va_list list;
-
-	args.service = service;
-	args.nargs = nargs;
-	args.nret = nret;
-
-	va_start(list, rets);
-	for (i = 0; i < nargs; i++)
-		args.args[i] = va_arg(list, unsigned int);
-	va_end(list);
-
-	for (i = 0; i < nret; i++)
-		args.args[nargs+i] = 0;
-
-	if (prom(&args) < 0)
-		return -1;
-
-	if (rets != (void *) 0)
-		for (i = 1; i < nret; ++i)
-			rets[i-1] = args.args[nargs+i];
-
-	return (nret > 0)? args.args[nargs]: 0;
-}
-
-/*
- * Older OF's require that when claiming a specific range of addresses,
- * we claim the physical space in the /memory node and the virtual
- * space in the chosen mmu node, and then do a map operation to
- * map virtual to physical.
- */
-static int need_map = -1;
-static ihandle chosen_mmu;
-static phandle memory;
-
-/* returns true if s2 is a prefix of s1 */
-static int string_match(const char *s1, const char *s2)
-{
-	for (; *s2; ++s2)
-		if (*s1++ != *s2)
-			return 0;
-	return 1;
-}
-
-static int check_of_version(void)
-{
-	phandle oprom, chosen;
-	char version[64];
-
-	oprom = finddevice("/openprom");
-	if (oprom == (phandle) -1)
-		return 0;
-	if (getprop(oprom, "model", version, sizeof(version)) <= 0)
-		return 0;
-	version[sizeof(version)-1] = 0;
-	printf("OF version = '%s'\r\n", version);
-	if (!string_match(version, "Open Firmware, 1.")
-	    && !string_match(version, "FirmWorks,3."))
-		return 0;
-	chosen = finddevice("/chosen");
-	if (chosen == (phandle) -1) {
-		chosen = finddevice("/chosen@0");
-		if (chosen == (phandle) -1) {
-			printf("no chosen\n");
-			return 0;
-		}
-	}
-	if (getprop(chosen, "mmu", &chosen_mmu, sizeof(chosen_mmu)) <= 0) {
-		printf("no mmu\n");
-		return 0;
-	}
-	memory = (ihandle) call_prom("open", 1, 1, "/memory");
-	if (memory == (ihandle) -1) {
-		memory = (ihandle) call_prom("open", 1, 1, "/memory@0");
-		if (memory == (ihandle) -1) {
-			printf("no memory node\n");
-			return 0;
-		}
-	}
-	printf("old OF detected\r\n");
-	return 1;
-}
-
-static void *claim(unsigned long virt, unsigned long size, unsigned long align)
-{
-	int ret;
-	unsigned int result;
-
-	if (need_map < 0)
-		need_map = check_of_version();
-	if (align || !need_map)
-		return (void *) call_prom("claim", 3, 1, virt, size, align);
-
-	ret = call_prom_ret("call-method", 5, 2, &result, "claim", memory,
-			    align, size, virt);
-	if (ret != 0 || result == -1)
-		return (void *) -1;
-	ret = call_prom_ret("call-method", 5, 2, &result, "claim", chosen_mmu,
-			    align, size, virt);
-	/* 0x12 == coherent + read/write */
-	ret = call_prom("call-method", 6, 1, "map", chosen_mmu,
-			0x12, size, virt, virt);
-	return (void *) virt;
-}
-
 static void *of_try_claim(unsigned long size)
 {
 	unsigned long addr = 0;
@@ -184,7 +39,7 @@ static void *of_try_claim(unsigned long size)
 #ifdef DEBUG
 		printf("    trying: 0x%08lx\n\r", claim_base);
 #endif
-		addr = (unsigned long)claim(claim_base, size, 0);
+		addr = (unsigned long)of_claim(claim_base, size, 0);
 		if ((void *)addr != (void *)-1)
 			break;
 	}
@@ -218,52 +73,24 @@ static void *of_vmlinux_alloc(unsigned long size)
 	return p;
 }
 
-static void of_exit(void)
-{
-	call_prom("exit", 0, 0);
-}
-
 /*
  * OF device tree routines
  */
 static void *of_finddevice(const char *name)
 {
-	return (phandle) call_prom("finddevice", 1, 1, name);
+	return (phandle) of_call_prom("finddevice", 1, 1, name);
 }
 
 static int of_getprop(const void *phandle, const char *name, void *buf,
 		const int buflen)
 {
-	return call_prom("getprop", 4, 1, phandle, name, buf, buflen);
+	return of_call_prom("getprop", 4, 1, phandle, name, buf, buflen);
 }
 
 static int of_setprop(const void *phandle, const char *name, const void *buf,
 		const int buflen)
 {
-	return call_prom("setprop", 4, 1, phandle, name, buf, buflen);
-}
-
-/*
- * OF console routines
- */
-static void *of_stdout_handle;
-
-static int of_console_open(void)
-{
-	void *devp;
-
-	if (((devp = finddevice("/chosen")) != NULL)
-			&& (getprop(devp, "stdout", &of_stdout_handle,
-				sizeof(of_stdout_handle))
-				== sizeof(of_stdout_handle)))
-		return 0;
-
-	return -1;
-}
-
-static void of_console_write(char *buf, int len)
-{
-	call_prom("write", 3, 1, of_stdout_handle, buf, len);
+	return of_call_prom("setprop", 4, 1, phandle, name, buf, buflen);
 }
 
 void platform_init(unsigned long a1, unsigned long a2, void *promptr)
@@ -277,10 +104,9 @@ void platform_init(unsigned long a1, unsigned long a2, void *promptr)
 	dt_ops.getprop = of_getprop;
 	dt_ops.setprop = of_setprop;
 
-	console_ops.open = of_console_open;
-	console_ops.write = of_console_write;
+	of_console_init();
 
-	prom = (int (*)(void *))promptr;
+	of_init(promptr);
 	loader_info.promptr = promptr;
 	if (a1 && a2 && a2 != 0xdeadbeef) {
 		loader_info.initrd_addr = a1;

commit 4ca478e6066ce57f7cc856af36aaf1a2d64417cb
Author: Geert Uytterhoeven <Geert.Uytterhoeven@eu.sony.com>
Date:   Wed Apr 18 19:24:12 2007 +1000

    [POWERPC] bootwrapper: Use `unsigned long' for malloc sizes
    
    Use `unsigned long' for malloc sizes, to match common practice and types used
    by most callers and callees.
    Also use `unsigned long' for integers representing pointers in simple_alloc.
    
    Signed-off-by: Geert Uytterhoeven <Geert.Uytterhoeven@eu.sony.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index 8fb42b63ec53..d16ee3e3f868 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -173,7 +173,7 @@ static void *claim(unsigned long virt, unsigned long size, unsigned long align)
 	return (void *) virt;
 }
 
-static void *of_try_claim(u32 size)
+static void *of_try_claim(unsigned long size)
 {
 	unsigned long addr = 0;
 

commit 390cbb56a731546edc0f35fbc4c5045676467581
Author: Paul Mackerras <paulus@samba.org>
Date:   Fri Apr 13 10:46:21 2007 +1000

    [POWERPC] Fix detection of loader-supplied initrd on OF platforms
    
    Commit 79c8541924a220964f9f2cbed31eaa9fdb042eab introduced code to move
    the initrd if it was in a place where it would get overwritten by the
    kernel image.  Unfortunately this exposed the fact that the code that
    checks whether the values passed in r3 and r4 are intended to indicate
    the start address and size of an initrd image was not as thorough as the
    kernel's checks.  The symptom is that on OF-based platforms, the
    bootwrapper can cause an exception which causes the system to drop back
    into OF.
    
    Previously it didn't matter so much if the code incorrectly thought that
    there was an initrd, since the values for start and size were just passed
    through to the kernel.  Now the bootwrapper needs to apply the same checks
    as the kernel since it is now using the initrd data itself (in the process
    of copying it if necessary).  This adds the code to do that.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index 2cec5c17fb60..8fb42b63ec53 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -282,6 +282,8 @@ void platform_init(unsigned long a1, unsigned long a2, void *promptr)
 
 	prom = (int (*)(void *))promptr;
 	loader_info.promptr = promptr;
-	loader_info.initrd_addr = a1;
-	loader_info.initrd_size = a2;
+	if (a1 && a2 && a2 != 0xdeadbeef) {
+		loader_info.initrd_addr = a1;
+		loader_info.initrd_size = a2;
+	}
 }

commit 6a923216aac01d0f3eeea606377b81541f1a2773
Author: Milton Miller <miltonm@bga.com>
Date:   Wed Mar 21 09:02:44 2007 -0600

    [POWERPC] bootwrapper: Add a fatal error helper
    
    Add a macro fatal that calls printf then exit.  User must include stdio.h.
    
    Typically replaces 3 lines with 1, although I added back some whitespace.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index c6f0d9701485..2cec5c17fb60 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -212,10 +212,9 @@ static void *of_vmlinux_alloc(unsigned long size)
 {
 	void *p = malloc(size);
 
-	if (!p) {
-		printf("Can't allocate memory for kernel image!\n\r");
-		exit();
-	}
+	if (!p)
+		fatal("Can't allocate memory for kernel image!\n\r");
+
 	return p;
 }
 

commit cd197ffcf10bcc1a260efe5c09a3188fd9228c83
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Mon Mar 5 14:24:52 2007 +1100

    [POWERPC] zImage: Cleanup and improve zImage entry point
    
    This patch re-organises the way the zImage wrapper code is entered, to
    allow more flexibility on platforms with unusual entry conditions.
    After this patch, a platform .o file has two options:
    
    1) It can define a _zimage_start, in which case the platform code gets
       control from the very beginning of execution.  In this case the
       platform code is responsible for relocating the zImage if necessary,
       clearing the BSS, performing any platform specific initialization, and
       finally calling start() to load and enter the kernel.
    
    2) It can define platform_init().  In this case the generic crt0.S
       handles initial entry, and calls platform_init() before calling
       start().  The signature of platform_init() is changed, however, to
       take up to 5 parameters (in r3..r7) as they come from the platform's
       initial loader, instead of a fixed set of parameters based on OF's
       usage.
    
       When using the generic crt0.S, the platform .o can optionally
       supply a custom stack to use, using the BSS_STACK() macro.  If this
       is not supplied, the crt0.S will assume that the loader has
       supplied a usable stack.
    
    In either case, the platform code communicates information to the
    generic code (specifically, a PROM pointer for OF systems, and/or an
    initrd image address supplied by the bootloader) via a global
    structure "loader_info".
    
    In addition the wrapper script is rearranged to ensure that the
    platform .o is always linked first.  This means that platforms where
    the zImage entry point is at a fixed address or offset, rather than
    being encoded in the binary header can be supported using option (1).
    
    Signed-off-by: David Gibson <dwg@au1.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index 044f34770b96..c6f0d9701485 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -267,7 +267,7 @@ static void of_console_write(char *buf, int len)
 	call_prom("write", 3, 1, of_stdout_handle, buf, len);
 }
 
-int platform_init(void *promptr, char *dt_blob_start, char *dt_blob_end)
+void platform_init(unsigned long a1, unsigned long a2, void *promptr)
 {
 	platform_ops.image_hdr = of_image_hdr;
 	platform_ops.malloc = of_try_claim;
@@ -282,5 +282,7 @@ int platform_init(void *promptr, char *dt_blob_start, char *dt_blob_end)
 	console_ops.write = of_console_write;
 
 	prom = (int (*)(void *))promptr;
-	return 0;
+	loader_info.promptr = promptr;
+	loader_info.initrd_addr = a1;
+	loader_info.initrd_size = a2;
 }

commit 79c8541924a220964f9f2cbed31eaa9fdb042eab
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Mon Mar 5 14:24:52 2007 +1100

    [POWERPC] zImage: Cleanup and improve prep_kernel()
    
    This patch rewrites prep_kernel() in the zImage wrapper code to be
    clearer and more flexible.  Notable changes:
    
            - Handling of the initrd image from prep_kernel() has moved
    into a new prep_initrd() function.
            - The address of the initrd image is now added as device tree
    properties, as the kernel expects.
            - We only copy a packaged initrd image to a new location if it
    is in danger of being clobbered when the kernel moves to its final
    location, instead of always.
            - By default we decompress the kernel directly to address 0,
    instead of requiring it to relocate itself.  Platforms (such as OF)
    where doing this could clobber still-live firmware data structures can
    override the vmlinux_alloc hook to provide an alternate place to
    decompress the kernel.
            - We no longer pass lots of information between functions in
    global variables.
    
    Signed-off-by: David Gibson <dwg@au1.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index 0182f384f3e6..044f34770b96 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -208,6 +208,17 @@ static void of_image_hdr(const void *hdr)
 	}
 }
 
+static void *of_vmlinux_alloc(unsigned long size)
+{
+	void *p = malloc(size);
+
+	if (!p) {
+		printf("Can't allocate memory for kernel image!\n\r");
+		exit();
+	}
+	return p;
+}
+
 static void of_exit(void)
 {
 	call_prom("exit", 0, 0);
@@ -261,6 +272,7 @@ int platform_init(void *promptr, char *dt_blob_start, char *dt_blob_end)
 	platform_ops.image_hdr = of_image_hdr;
 	platform_ops.malloc = of_try_claim;
 	platform_ops.exit = of_exit;
+	platform_ops.vmlinux_alloc = of_vmlinux_alloc;
 
 	dt_ops.finddevice = of_finddevice;
 	dt_ops.getprop = of_getprop;

commit c888554bf95a5a0a6ac3e2389c6bf1e03e9480ba
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Mon Oct 16 13:49:27 2006 -0700

    [POWERPC] More bootwrapper reorganization
    
    More reorganization of the bootwrapper:
    - Add dtb section to zImage
    - ft_init now called by platform_init
    - Pack a flat dt before calling kernel
    - Remove size parameter from free
    - printf only calls console_ops.write it its not NULL
    - Some cleanup
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index 3a71845afc6c..0182f384f3e6 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -256,24 +256,18 @@ static void of_console_write(char *buf, int len)
 	call_prom("write", 3, 1, of_stdout_handle, buf, len);
 }
 
-int platform_init(void *promptr)
+int platform_init(void *promptr, char *dt_blob_start, char *dt_blob_end)
 {
-	platform_ops.fixups = NULL;
 	platform_ops.image_hdr = of_image_hdr;
 	platform_ops.malloc = of_try_claim;
-	platform_ops.free = NULL;
 	platform_ops.exit = of_exit;
 
 	dt_ops.finddevice = of_finddevice;
 	dt_ops.getprop = of_getprop;
 	dt_ops.setprop = of_setprop;
-	dt_ops.translate_addr = NULL;
 
 	console_ops.open = of_console_open;
 	console_ops.write = of_console_write;
-	console_ops.edit_cmdline = NULL;
-	console_ops.close = NULL;
-	console_ops.data = NULL;
 
 	prom = (int (*)(void *))promptr;
 	return 0;

commit c998de146061db17787c1a31a3db1989f1341fdf
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Oct 5 14:18:46 2006 +1000

    [POWERPC] Fix zImage decompress location
    
    The zImage wrapper has a "hack" that force the decompression to happen
    above 20Mb for 64 bits kernels, to work around issues with some
    firmwares on the field. However, the new wrapper has a bug which makes
    that hack not work properly. This fixes it.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
index fd99f789a37b..3a71845afc6c 100644
--- a/arch/powerpc/boot/of.c
+++ b/arch/powerpc/boot/of.c
@@ -176,12 +176,9 @@ static void *claim(unsigned long virt, unsigned long size, unsigned long align)
 static void *of_try_claim(u32 size)
 {
 	unsigned long addr = 0;
-	static u8 first_time = 1;
 
-	if (first_time) {
+	if (claim_base == 0)
 		claim_base = _ALIGN_UP((unsigned long)_end, ONE_MB);
-		first_time = 0;
-	}
 
 	for(; claim_base < RAM_END; claim_base += ONE_MB) {
 #ifdef DEBUG

commit b2c5f61920eeee9c4e78698de4fde4586fe5ae79
Author: Mark A. Greer <mgreer@mvista.com>
Date:   Tue Sep 19 14:05:08 2006 +1000

    [POWERPC] Start arch/powerpc/boot code reorganization
    
    This abstracts the operations used in the bootwrapper, and defines
    the operations needed for the bootwrapper to run on an OF platform.
    
    The operations have been divided up into platform ops (platform_ops),
    firmware ops (fw_ops), device tree ops (dt_ops), and console ops
    (console_ops).
    
    The proper operations will be hooked up at runtime to provide the
    functionality that you need.
    
    Signed-off-by: Mark A. Greer <mgreer@mvista.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/boot/of.c b/arch/powerpc/boot/of.c
new file mode 100644
index 000000000000..fd99f789a37b
--- /dev/null
+++ b/arch/powerpc/boot/of.c
@@ -0,0 +1,283 @@
+/*
+ * Copyright (C) Paul Mackerras 1997.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+#include <stdarg.h>
+#include <stddef.h>
+#include "types.h"
+#include "elf.h"
+#include "string.h"
+#include "stdio.h"
+#include "page.h"
+#include "ops.h"
+
+typedef void *ihandle;
+typedef void *phandle;
+
+extern char _end[];
+
+/* Value picked to match that used by yaboot */
+#define PROG_START	0x01400000	/* only used on 64-bit systems */
+#define RAM_END		(512<<20)	/* Fixme: use OF */
+#define	ONE_MB		0x100000
+
+int (*prom) (void *);
+
+
+static unsigned long claim_base;
+
+static int call_prom(const char *service, int nargs, int nret, ...)
+{
+	int i;
+	struct prom_args {
+		const char *service;
+		int nargs;
+		int nret;
+		unsigned int args[12];
+	} args;
+	va_list list;
+
+	args.service = service;
+	args.nargs = nargs;
+	args.nret = nret;
+
+	va_start(list, nret);
+	for (i = 0; i < nargs; i++)
+		args.args[i] = va_arg(list, unsigned int);
+	va_end(list);
+
+	for (i = 0; i < nret; i++)
+		args.args[nargs+i] = 0;
+
+	if (prom(&args) < 0)
+		return -1;
+
+	return (nret > 0)? args.args[nargs]: 0;
+}
+
+static int call_prom_ret(const char *service, int nargs, int nret,
+		  unsigned int *rets, ...)
+{
+	int i;
+	struct prom_args {
+		const char *service;
+		int nargs;
+		int nret;
+		unsigned int args[12];
+	} args;
+	va_list list;
+
+	args.service = service;
+	args.nargs = nargs;
+	args.nret = nret;
+
+	va_start(list, rets);
+	for (i = 0; i < nargs; i++)
+		args.args[i] = va_arg(list, unsigned int);
+	va_end(list);
+
+	for (i = 0; i < nret; i++)
+		args.args[nargs+i] = 0;
+
+	if (prom(&args) < 0)
+		return -1;
+
+	if (rets != (void *) 0)
+		for (i = 1; i < nret; ++i)
+			rets[i-1] = args.args[nargs+i];
+
+	return (nret > 0)? args.args[nargs]: 0;
+}
+
+/*
+ * Older OF's require that when claiming a specific range of addresses,
+ * we claim the physical space in the /memory node and the virtual
+ * space in the chosen mmu node, and then do a map operation to
+ * map virtual to physical.
+ */
+static int need_map = -1;
+static ihandle chosen_mmu;
+static phandle memory;
+
+/* returns true if s2 is a prefix of s1 */
+static int string_match(const char *s1, const char *s2)
+{
+	for (; *s2; ++s2)
+		if (*s1++ != *s2)
+			return 0;
+	return 1;
+}
+
+static int check_of_version(void)
+{
+	phandle oprom, chosen;
+	char version[64];
+
+	oprom = finddevice("/openprom");
+	if (oprom == (phandle) -1)
+		return 0;
+	if (getprop(oprom, "model", version, sizeof(version)) <= 0)
+		return 0;
+	version[sizeof(version)-1] = 0;
+	printf("OF version = '%s'\r\n", version);
+	if (!string_match(version, "Open Firmware, 1.")
+	    && !string_match(version, "FirmWorks,3."))
+		return 0;
+	chosen = finddevice("/chosen");
+	if (chosen == (phandle) -1) {
+		chosen = finddevice("/chosen@0");
+		if (chosen == (phandle) -1) {
+			printf("no chosen\n");
+			return 0;
+		}
+	}
+	if (getprop(chosen, "mmu", &chosen_mmu, sizeof(chosen_mmu)) <= 0) {
+		printf("no mmu\n");
+		return 0;
+	}
+	memory = (ihandle) call_prom("open", 1, 1, "/memory");
+	if (memory == (ihandle) -1) {
+		memory = (ihandle) call_prom("open", 1, 1, "/memory@0");
+		if (memory == (ihandle) -1) {
+			printf("no memory node\n");
+			return 0;
+		}
+	}
+	printf("old OF detected\r\n");
+	return 1;
+}
+
+static void *claim(unsigned long virt, unsigned long size, unsigned long align)
+{
+	int ret;
+	unsigned int result;
+
+	if (need_map < 0)
+		need_map = check_of_version();
+	if (align || !need_map)
+		return (void *) call_prom("claim", 3, 1, virt, size, align);
+
+	ret = call_prom_ret("call-method", 5, 2, &result, "claim", memory,
+			    align, size, virt);
+	if (ret != 0 || result == -1)
+		return (void *) -1;
+	ret = call_prom_ret("call-method", 5, 2, &result, "claim", chosen_mmu,
+			    align, size, virt);
+	/* 0x12 == coherent + read/write */
+	ret = call_prom("call-method", 6, 1, "map", chosen_mmu,
+			0x12, size, virt, virt);
+	return (void *) virt;
+}
+
+static void *of_try_claim(u32 size)
+{
+	unsigned long addr = 0;
+	static u8 first_time = 1;
+
+	if (first_time) {
+		claim_base = _ALIGN_UP((unsigned long)_end, ONE_MB);
+		first_time = 0;
+	}
+
+	for(; claim_base < RAM_END; claim_base += ONE_MB) {
+#ifdef DEBUG
+		printf("    trying: 0x%08lx\n\r", claim_base);
+#endif
+		addr = (unsigned long)claim(claim_base, size, 0);
+		if ((void *)addr != (void *)-1)
+			break;
+	}
+	if (addr == 0)
+		return NULL;
+	claim_base = PAGE_ALIGN(claim_base + size);
+	return (void *)addr;
+}
+
+static void of_image_hdr(const void *hdr)
+{
+	const Elf64_Ehdr *elf64 = hdr;
+
+	if (elf64->e_ident[EI_CLASS] == ELFCLASS64) {
+		/*
+		 * Maintain a "magic" minimum address. This keeps some older
+		 * firmware platforms running.
+		 */
+		if (claim_base < PROG_START)
+			claim_base = PROG_START;
+	}
+}
+
+static void of_exit(void)
+{
+	call_prom("exit", 0, 0);
+}
+
+/*
+ * OF device tree routines
+ */
+static void *of_finddevice(const char *name)
+{
+	return (phandle) call_prom("finddevice", 1, 1, name);
+}
+
+static int of_getprop(const void *phandle, const char *name, void *buf,
+		const int buflen)
+{
+	return call_prom("getprop", 4, 1, phandle, name, buf, buflen);
+}
+
+static int of_setprop(const void *phandle, const char *name, const void *buf,
+		const int buflen)
+{
+	return call_prom("setprop", 4, 1, phandle, name, buf, buflen);
+}
+
+/*
+ * OF console routines
+ */
+static void *of_stdout_handle;
+
+static int of_console_open(void)
+{
+	void *devp;
+
+	if (((devp = finddevice("/chosen")) != NULL)
+			&& (getprop(devp, "stdout", &of_stdout_handle,
+				sizeof(of_stdout_handle))
+				== sizeof(of_stdout_handle)))
+		return 0;
+
+	return -1;
+}
+
+static void of_console_write(char *buf, int len)
+{
+	call_prom("write", 3, 1, of_stdout_handle, buf, len);
+}
+
+int platform_init(void *promptr)
+{
+	platform_ops.fixups = NULL;
+	platform_ops.image_hdr = of_image_hdr;
+	platform_ops.malloc = of_try_claim;
+	platform_ops.free = NULL;
+	platform_ops.exit = of_exit;
+
+	dt_ops.finddevice = of_finddevice;
+	dt_ops.getprop = of_getprop;
+	dt_ops.setprop = of_setprop;
+	dt_ops.translate_addr = NULL;
+
+	console_ops.open = of_console_open;
+	console_ops.write = of_console_write;
+	console_ops.edit_cmdline = NULL;
+	console_ops.close = NULL;
+	console_ops.data = NULL;
+
+	prom = (int (*)(void *))promptr;
+	return 0;
+}
