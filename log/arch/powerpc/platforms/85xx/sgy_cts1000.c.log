commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/platforms/85xx/sgy_cts1000.c b/arch/powerpc/platforms/85xx/sgy_cts1000.c
index 21d6aaa5c3e4..98ae64075193 100644
--- a/arch/powerpc/platforms/85xx/sgy_cts1000.c
+++ b/arch/powerpc/platforms/85xx/sgy_cts1000.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Servergy CTS-1000 Setup
  *
  * Maintained by Ben Collins <ben.c@servergy.com>
  *
  * Copyright 2012 by Servergy, Inc.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 
 #include <linux/platform_device.h>

commit 625f3eea40024d0fc6562fc737761bba696c662b
Author: Andrey Smirnov <andrew.smirnov@gmail.com>
Date:   Mon Jul 25 21:45:01 2016 -0700

    powerpc/sgy_cts1000: Fix gpio_halt_cb()'s signature
    
    Halt callback in struct machdep_calls is declared with __noreturn
    attribute, so omitting that attribute in gpio_halt_cb()'s signatrue
    results in compilation error.
    
    Change the signature to address the problem as well as change the code
    of the function to avoid ever returning from the function.
    
    Signed-off-by: Andrey Smirnov <andrew.smirnov@gmail.com>
    Signed-off-by: Scott Wood <oss@buserror.net>

diff --git a/arch/powerpc/platforms/85xx/sgy_cts1000.c b/arch/powerpc/platforms/85xx/sgy_cts1000.c
index 79fd0dfd4b82..21d6aaa5c3e4 100644
--- a/arch/powerpc/platforms/85xx/sgy_cts1000.c
+++ b/arch/powerpc/platforms/85xx/sgy_cts1000.c
@@ -38,18 +38,18 @@ static void gpio_halt_wfn(struct work_struct *work)
 }
 static DECLARE_WORK(gpio_halt_wq, gpio_halt_wfn);
 
-static void gpio_halt_cb(void)
+static void __noreturn gpio_halt_cb(void)
 {
 	enum of_gpio_flags flags;
 	int trigger, gpio;
 
 	if (!halt_node)
-		return;
+		panic("No reset GPIO information was provided in DT\n");
 
 	gpio = of_get_gpio_flags(halt_node, 0, &flags);
 
 	if (!gpio_is_valid(gpio))
-		return;
+		panic("Provided GPIO is invalid\n");
 
 	trigger = (flags == OF_GPIO_ACTIVE_LOW);
 
@@ -57,6 +57,8 @@ static void gpio_halt_cb(void)
 
 	/* Probably wont return */
 	gpio_set_value(gpio, trigger);
+
+	panic("Halt failed\n");
 }
 
 /* This IRQ means someone pressed the power button and it is waiting for us

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 9178ba294b6839eeff1a91bed95515d783f3ee6c
Author: Alexander Graf <agraf@suse.de>
Date:   Mon Oct 13 16:01:09 2014 +0200

    powerpc: Convert power off logic to pm_power_off
    
    The generic Linux framework to power off the machine is a function pointer
    called pm_power_off. The trick about this pointer is that device drivers can
    potentially implement it rather than board files.
    
    Today on powerpc we set pm_power_off to invoke our generic full machine power
    off logic which then calls ppc_md.power_off to invoke machine specific power
    off.
    
    However, when we want to add a power off GPIO via the "gpio-poweroff" driver,
    this card house falls apart. That driver only registers itself if pm_power_off
    is NULL to ensure it doesn't override board specific logic. However, since we
    always set pm_power_off to the generic power off logic (which will just not
    power off the machine if no ppc_md.power_off call is implemented), we can't
    implement power off via the generic GPIO power off driver.
    
    To fix this up, let's get rid of the ppc_md.power_off logic and just always use
    pm_power_off as was intended. Then individual drivers such as the GPIO power off
    driver can implement power off logic via that function pointer.
    
    With this patch set applied and a few patches on top of QEMU that implement a
    power off GPIO on the virt e500 machine, I can successfully turn off my virtual
    machine after halt.
    
    Signed-off-by: Alexander Graf <agraf@suse.de>
    [mpe: Squash into one patch and update changelog based on cover letter]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/85xx/sgy_cts1000.c b/arch/powerpc/platforms/85xx/sgy_cts1000.c
index 8162b0412117..e149c9ec26ae 100644
--- a/arch/powerpc/platforms/85xx/sgy_cts1000.c
+++ b/arch/powerpc/platforms/85xx/sgy_cts1000.c
@@ -120,7 +120,7 @@ static int gpio_halt_probe(struct platform_device *pdev)
 
 	/* Register our halt function */
 	ppc_md.halt = gpio_halt_cb;
-	ppc_md.power_off = gpio_halt_cb;
+	pm_power_off = gpio_halt_cb;
 
 	printk(KERN_INFO "gpio-halt: registered GPIO %d (%d trigger, %d"
 	       " irq).\n", gpio, trigger, irq);
@@ -137,7 +137,7 @@ static int gpio_halt_remove(struct platform_device *pdev)
 		free_irq(irq, halt_node);
 
 		ppc_md.halt = NULL;
-		ppc_md.power_off = NULL;
+		pm_power_off = NULL;
 
 		gpio_free(gpio);
 

commit 4a0b0cee81478b07966412514577dd30dec05d1d
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:11 2014 +0200

    powerpc: platforms: 85xx: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/arch/powerpc/platforms/85xx/sgy_cts1000.c b/arch/powerpc/platforms/85xx/sgy_cts1000.c
index 8162b0412117..26bacf0ed146 100644
--- a/arch/powerpc/platforms/85xx/sgy_cts1000.c
+++ b/arch/powerpc/platforms/85xx/sgy_cts1000.c
@@ -161,7 +161,6 @@ MODULE_DEVICE_TABLE(of, gpio_halt_match);
 static struct platform_driver gpio_halt_driver = {
 	.driver = {
 		.name		= "gpio-halt",
-		.owner		= THIS_MODULE,
 		.of_match_table = gpio_halt_match,
 	},
 	.probe		= gpio_halt_probe,

commit ce6d73c94d7cfbdc3dc31860fe14af2f37d1b4fe
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Sep 10 21:56:38 2014 +0200

    powerpc: make of_device_ids const
    
    of_device_ids (i.e. compatible strings and the respective data) are not
    supposed to change at runtime. All functions working with of_device_ids
    provided by <linux/of.h> work with const of_device_ids. This allows to
    mark all struct of_device_id const, too.
    
    While touching these line also put the __init annotation at the right
    position where necessary.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/85xx/sgy_cts1000.c b/arch/powerpc/platforms/85xx/sgy_cts1000.c
index bb75add67084..8162b0412117 100644
--- a/arch/powerpc/platforms/85xx/sgy_cts1000.c
+++ b/arch/powerpc/platforms/85xx/sgy_cts1000.c
@@ -24,7 +24,7 @@
 
 static struct device_node *halt_node;
 
-static struct of_device_id child_match[] = {
+static const struct of_device_id child_match[] = {
 	{
 		.compatible = "sgy,gpio-halt",
 	},
@@ -147,7 +147,7 @@ static int gpio_halt_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static struct of_device_id gpio_halt_match[] = {
+static const struct of_device_id gpio_halt_match[] = {
 	/* We match on the gpio bus itself and scan the children since they
 	 * wont be matched against us. We know the bus wont match until it
 	 * has been registered too. */

commit c141611fb1ee2cfc374cf9be5327e97f361c4bed
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Jan 9 00:44:29 2014 -0500

    powerpc: Delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    The one instance where we add an include for init.h covers off
    a case where that file was implicitly getting it from another
    header which itself didn't need it.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/85xx/sgy_cts1000.c b/arch/powerpc/platforms/85xx/sgy_cts1000.c
index b9197cea1854..bb75add67084 100644
--- a/arch/powerpc/platforms/85xx/sgy_cts1000.c
+++ b/arch/powerpc/platforms/85xx/sgy_cts1000.c
@@ -14,7 +14,6 @@
 #include <linux/platform_device.h>
 #include <linux/device.h>
 #include <linux/module.h>
-#include <linux/init.h>
 #include <linux/of_gpio.h>
 #include <linux/of_irq.h>
 #include <linux/workqueue.h>

commit c11eede69b6ad0ac44ebc1e021a8d2699c5f1f8f
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Sun Nov 10 23:19:08 2013 -0600

    powerpc: add missing explicit OF includes for ppc
    
    Commit b5b4bb3f6a11f9 (of: only include prom.h on sparc) removed implicit
    includes of of_*.h headers by powerpc's prom.h. Some components were
    missed in initial clean-up patch, so add the necessary includes to fix
    powerpc builds.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Matt Mackall <mpm@selenic.com>
    Cc: Herbert Xu <herbert@gondor.apana.org.au>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Vinod Koul <vinod.koul@intel.com>
    Cc: Dan Williams <dan.j.williams@intel.com>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-ide@vger.kernel.org
    Cc: linux-crypto@vger.kernel.org

diff --git a/arch/powerpc/platforms/85xx/sgy_cts1000.c b/arch/powerpc/platforms/85xx/sgy_cts1000.c
index 7179726ba5c5..b9197cea1854 100644
--- a/arch/powerpc/platforms/85xx/sgy_cts1000.c
+++ b/arch/powerpc/platforms/85xx/sgy_cts1000.c
@@ -16,6 +16,7 @@
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/of_gpio.h>
+#include <linux/of_irq.h>
 #include <linux/workqueue.h>
 #include <linux/reboot.h>
 #include <linux/interrupt.h>

commit 9997d08806062cb7ba471ab12fa2742cfec2f413
Author: Ben Collins <benmcollins13@gmail.com>
Date:   Mon Mar 18 19:19:07 2013 -0400

    sgy-cts1000: Remove __dev* attributes
    
    Somehow the driver snuck in with these still in it.
    
    Signed-off-by: Ben Collins <ben.c@servergy.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/platforms/85xx/sgy_cts1000.c b/arch/powerpc/platforms/85xx/sgy_cts1000.c
index 611e92f291c4..7179726ba5c5 100644
--- a/arch/powerpc/platforms/85xx/sgy_cts1000.c
+++ b/arch/powerpc/platforms/85xx/sgy_cts1000.c
@@ -69,7 +69,7 @@ static irqreturn_t gpio_halt_irq(int irq, void *__data)
         return IRQ_HANDLED;
 };
 
-static int __devinit gpio_halt_probe(struct platform_device *pdev)
+static int gpio_halt_probe(struct platform_device *pdev)
 {
 	enum of_gpio_flags flags;
 	struct device_node *node = pdev->dev.of_node;
@@ -128,7 +128,7 @@ static int __devinit gpio_halt_probe(struct platform_device *pdev)
 	return 0;
 }
 
-static int __devexit gpio_halt_remove(struct platform_device *pdev)
+static int gpio_halt_remove(struct platform_device *pdev)
 {
 	if (halt_node) {
 		int gpio = of_get_gpio(halt_node, 0);
@@ -165,7 +165,7 @@ static struct platform_driver gpio_halt_driver = {
 		.of_match_table = gpio_halt_match,
 	},
 	.probe		= gpio_halt_probe,
-	.remove		= __devexit_p(gpio_halt_remove),
+	.remove		= gpio_halt_remove,
 };
 
 module_platform_driver(gpio_halt_driver);

commit 5611fe48c545a22e62273428ed74c9bfae4a9406
Author: Benjamin Collins <ben.c@servergy.com>
Date:   Mon Dec 17 04:19:28 2012 +0000

    powerpc: Add support for CTS-1000 GPIO controlled system poweroff
    
    CTS-1000 is based on P4080. GPIO 27 is used to signal the FPGA to
    switch off power, and also associates IRQ 8 with front-panel button
    press (which we use to call orderly_poweroff()).
    
    The relevant device-tree looks like this:
    
            gpio0: gpio@130000 {
                    compatible = "fsl,qoriq-gpio";
                    reg = <0x130000 0x1000>;
                    interrupts = <55 2 0 0>;
                    #gpio-cells = <2>;
                    gpio-controller;
    
                    /* Allows powering off the system via GPIO signal. */
                    gpio-halt@27 {
                            compatible = "sgy,gpio-halt";
                            gpios = <&gpio0 27 0>;
                            interrupts = <8 1 0 0>;
                    };
            };
    
    Because the driver cannot match on sgy,gpio-halt (because the node is never
    processed through of_platform), it matches on fsl,qoriq-gpio and then
    checks child nodes for the matching sgy,gpio-halt. This also ensures that
    the GPIO controller is detected prior to sgy_cts1000's probe callback,
    since that node wont match via of_platform until the controller is
    registered.
    
    Also, because the GPIO handler for triggering system poweroff might sleep,
    the IRQ uses a workqueue to call orderly_poweroff().
    
    As a final note, this driver may be expanded for other features specific to
    the CTS-1000.
    
    Signed-off-by: Ben Collins <ben.c@servergy.com>
    Cc: Jack Smith <jack.s@servergy.com>
    Cc: Vihar Rai <vihar.r@servergy.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/85xx/sgy_cts1000.c b/arch/powerpc/platforms/85xx/sgy_cts1000.c
new file mode 100644
index 000000000000..611e92f291c4
--- /dev/null
+++ b/arch/powerpc/platforms/85xx/sgy_cts1000.c
@@ -0,0 +1,176 @@
+/*
+ * Servergy CTS-1000 Setup
+ *
+ * Maintained by Ben Collins <ben.c@servergy.com>
+ *
+ * Copyright 2012 by Servergy, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/of_gpio.h>
+#include <linux/workqueue.h>
+#include <linux/reboot.h>
+#include <linux/interrupt.h>
+
+#include <asm/machdep.h>
+
+static struct device_node *halt_node;
+
+static struct of_device_id child_match[] = {
+	{
+		.compatible = "sgy,gpio-halt",
+	},
+	{},
+};
+
+static void gpio_halt_wfn(struct work_struct *work)
+{
+	/* Likely wont return */
+	orderly_poweroff(true);
+}
+static DECLARE_WORK(gpio_halt_wq, gpio_halt_wfn);
+
+static void gpio_halt_cb(void)
+{
+	enum of_gpio_flags flags;
+	int trigger, gpio;
+
+	if (!halt_node)
+		return;
+
+	gpio = of_get_gpio_flags(halt_node, 0, &flags);
+
+	if (!gpio_is_valid(gpio))
+		return;
+
+	trigger = (flags == OF_GPIO_ACTIVE_LOW);
+
+	printk(KERN_INFO "gpio-halt: triggering GPIO.\n");
+
+	/* Probably wont return */
+	gpio_set_value(gpio, trigger);
+}
+
+/* This IRQ means someone pressed the power button and it is waiting for us
+ * to handle the shutdown/poweroff. */
+static irqreturn_t gpio_halt_irq(int irq, void *__data)
+{
+	printk(KERN_INFO "gpio-halt: shutdown due to power button IRQ.\n");
+	schedule_work(&gpio_halt_wq);
+
+        return IRQ_HANDLED;
+};
+
+static int __devinit gpio_halt_probe(struct platform_device *pdev)
+{
+	enum of_gpio_flags flags;
+	struct device_node *node = pdev->dev.of_node;
+	int gpio, err, irq;
+	int trigger;
+
+	if (!node)
+		return -ENODEV;
+
+	/* If there's no matching child, this isn't really an error */
+	halt_node = of_find_matching_node(node, child_match);
+	if (!halt_node)
+		return 0;
+
+	/* Technically we could just read the first one, but punish
+	 * DT writers for invalid form. */
+	if (of_gpio_count(halt_node) != 1)
+		return -EINVAL;
+
+	/* Get the gpio number relative to the dynamic base. */
+	gpio = of_get_gpio_flags(halt_node, 0, &flags);
+	if (!gpio_is_valid(gpio))
+		return -EINVAL;
+
+	err = gpio_request(gpio, "gpio-halt");
+	if (err) {
+		printk(KERN_ERR "gpio-halt: error requesting GPIO %d.\n",
+		       gpio);
+		halt_node = NULL;
+		return err;
+	}
+
+	trigger = (flags == OF_GPIO_ACTIVE_LOW);
+
+	gpio_direction_output(gpio, !trigger);
+
+	/* Now get the IRQ which tells us when the power button is hit */
+	irq = irq_of_parse_and_map(halt_node, 0);
+	err = request_irq(irq, gpio_halt_irq, IRQF_TRIGGER_RISING |
+			  IRQF_TRIGGER_FALLING, "gpio-halt", halt_node);
+	if (err) {
+		printk(KERN_ERR "gpio-halt: error requesting IRQ %d for "
+		       "GPIO %d.\n", irq, gpio);
+		gpio_free(gpio);
+		halt_node = NULL;
+		return err;
+	}
+
+	/* Register our halt function */
+	ppc_md.halt = gpio_halt_cb;
+	ppc_md.power_off = gpio_halt_cb;
+
+	printk(KERN_INFO "gpio-halt: registered GPIO %d (%d trigger, %d"
+	       " irq).\n", gpio, trigger, irq);
+
+	return 0;
+}
+
+static int __devexit gpio_halt_remove(struct platform_device *pdev)
+{
+	if (halt_node) {
+		int gpio = of_get_gpio(halt_node, 0);
+		int irq = irq_of_parse_and_map(halt_node, 0);
+
+		free_irq(irq, halt_node);
+
+		ppc_md.halt = NULL;
+		ppc_md.power_off = NULL;
+
+		gpio_free(gpio);
+
+		halt_node = NULL;
+	}
+
+	return 0;
+}
+
+static struct of_device_id gpio_halt_match[] = {
+	/* We match on the gpio bus itself and scan the children since they
+	 * wont be matched against us. We know the bus wont match until it
+	 * has been registered too. */
+	{
+		.compatible = "fsl,qoriq-gpio",
+	},
+	{},
+};
+MODULE_DEVICE_TABLE(of, gpio_halt_match);
+
+static struct platform_driver gpio_halt_driver = {
+	.driver = {
+		.name		= "gpio-halt",
+		.owner		= THIS_MODULE,
+		.of_match_table = gpio_halt_match,
+	},
+	.probe		= gpio_halt_probe,
+	.remove		= __devexit_p(gpio_halt_remove),
+};
+
+module_platform_driver(gpio_halt_driver);
+
+MODULE_DESCRIPTION("Driver to support GPIO triggered system halt for Servergy CTS-1000 Systems.");
+MODULE_VERSION("1.0");
+MODULE_AUTHOR("Ben Collins <ben.c@servergy.com>");
+MODULE_LICENSE("GPL");
