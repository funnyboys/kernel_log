commit b4f00d5b2098320a0d4c4a6d31099bc0c9a85b02
Author: afzal mohammed <afzal.mohd.ma@gmail.com>
Date:   Thu Mar 12 12:12:55 2020 +0530

    powerpc: Replace setup_irq() by request_irq()
    
    request_irq() is preferred over setup_irq(). Invocations of setup_irq()
    occur after memory allocators are ready.
    
    Per tglx[1], setup_irq() existed in olden days when allocators were not
    ready by the time early interrupts were initialized.
    
    Hence replace setup_irq() by request_irq().
    
    [1] https://lkml.kernel.org/r/alpine.DEB.2.20.1710191609480.1971@nanos
    
    Signed-off-by: afzal mohammed <afzal.mohd.ma@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20200312064256.18735-1-afzal.mohd.ma@gmail.com

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index f1c805c8adbc..df4d57d07f9a 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -39,12 +39,6 @@ static irqreturn_t timebase_interrupt(int irq, void *dev)
 	return IRQ_HANDLED;
 }
 
-static struct irqaction tbint_irqaction = {
-	.handler = timebase_interrupt,
-	.flags = IRQF_NO_THREAD,
-	.name = "tbint",
-};
-
 /* per-board overridable init_internal_rtc() function. */
 void __init __attribute__ ((weak))
 init_internal_rtc(void)
@@ -157,7 +151,8 @@ void __init mpc8xx_calibrate_decr(void)
 					(TBSCR_TBF | TBSCR_TBE));
 	immr_unmap(sys_tmr2);
 
-	if (setup_irq(virq, &tbint_irqaction))
+	if (request_irq(virq, timebase_interrupt, IRQF_NO_THREAD, "tbint",
+			NULL))
 		panic("Could not allocate timer IRQ!");
 }
 

commit 38959a091e4a79efcd693a19cf589997c6b39d3b
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 13:41:31 2018 -0500

    powerpc: 8xx: get cpu node with of_get_cpu_node
    
    "device_type" use is deprecated for FDT though it has continued to be used
    for nodes like cpu nodes. Use of_get_cpu_node() instead which works using
    node names by default. This will allow the eventually removal of cpu
    device_type properties.
    
    Also, fix a leaked reference and add a missing of_node_put.
    
    Cc: Vitaly Bordug <vitb@kernel.crashing.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 027c42d8966c..f1c805c8adbc 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -66,7 +66,7 @@ static int __init get_freq(char *name, unsigned long *val)
 	int found = 0;
 
 	/* The cpu node should have timebase and clock frequency properties */
-	cpu = of_find_node_by_type(NULL, "cpu");
+	cpu = of_get_cpu_node(0, NULL);
 
 	if (cpu) {
 		fp = of_get_property(cpu, name, NULL);
@@ -147,8 +147,9 @@ void __init mpc8xx_calibrate_decr(void)
 	 * we have to enable the timebase).  The decrementer interrupt
 	 * is wired into the vector table, nothing to do here for that.
 	 */
-	cpu = of_find_node_by_type(NULL, "cpu");
+	cpu = of_get_cpu_node(0, NULL);
 	virq= irq_of_parse_and_map(cpu, 0);
+	of_node_put(cpu);
 	irq = virq_to_hw(virq);
 
 	sys_tmr2 = immr_map(im_sit);

commit 5235afa89a246c9d5ab35996bc38681c474c3ed7
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 23 10:36:41 2018 +0200

    powerpc: use time64_t in update_persistent_clock
    
    update_persistent_clock() is deprecated because it suffers from overflow
    in 2038 on 32-bit architectures. This changes powerpc to use the
    update_persistent_clock64() replacement, and to pass down 64-bit
    timestamps consistently.
    
    This is now simpler, as we no longer have to worry about the offset
    numbers in tm_year and tm_mon that are different between the Linux
    conventions and RTAS.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index d76daa90647b..027c42d8966c 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -169,15 +169,14 @@ int mpc8xx_set_rtc_time(struct rtc_time *tm)
 {
 	sitk8xx_t __iomem *sys_tmr1;
 	sit8xx_t __iomem *sys_tmr2;
-	int time;
+	time64_t time;
 
 	sys_tmr1 = immr_map(im_sitk);
 	sys_tmr2 = immr_map(im_sit);
-	time = mktime(tm->tm_year+1900, tm->tm_mon+1, tm->tm_mday,
-	              tm->tm_hour, tm->tm_min, tm->tm_sec);
+	time = rtc_tm_to_time64(tm);
 
 	out_be32(&sys_tmr1->sitk_rtck, KAPWR_KEY);
-	out_be32(&sys_tmr2->sit_rtc, time);
+	out_be32(&sys_tmr2->sit_rtc, (u32)time);
 	out_be32(&sys_tmr1->sitk_rtck, ~KAPWR_KEY);
 
 	immr_unmap(sys_tmr2);

commit 5bfd643583b2e2a203163fd6b617cd9027054200
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 23 10:36:40 2018 +0200

    powerpc: use time64_t in read_persistent_clock
    
    Looking through the remaining users of the deprecated mktime()
    function, I found the powerpc rtc handlers, which use it in
    place of rtc_tm_to_time64().
    
    To clean this up, I'm changing over the read_persistent_clock()
    function to the read_persistent_clock64() variant, and change
    all the platform specific handlers along with it.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 2188d691a40f..d76daa90647b 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -192,9 +192,7 @@ void mpc8xx_get_rtc_time(struct rtc_time *tm)
 
 	/* Get time from the RTC. */
 	data = in_be32(&sys_tmr->sit_rtc);
-	to_tm(data, tm);
-	tm->tm_year -= 1900;
-	tm->tm_mon -= 1;
+	rtc_time64_to_tm(data, tm);
 	immr_unmap(sys_tmr);
 	return;
 }

commit c554ac91ce2213faa91c51c45423770218cccce3
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Tue Feb 27 12:25:55 2018 +0100

    powerpc/8xx: fix cpm_cascade() dual end of interrupt
    
    cpm_cascade() doesn't have to call eoi() as it is already called
    by handle_fasteoi_irq()
    
    And cpm_get_irq() will always return an unsigned int so the test
    is useless
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index e1274db53d48..2188d691a40f 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -217,13 +217,7 @@ void __noreturn mpc8xx_restart(char *cmd)
 
 static void cpm_cascade(struct irq_desc *desc)
 {
-	struct irq_chip *chip = irq_desc_get_chip(desc);
-	int cascade_irq = cpm_get_irq();
-
-	if (cascade_irq >= 0)
-		generic_handle_irq(cascade_irq);
-
-	chip->irq_eoi(&desc->irq_data);
+	generic_handle_irq(cpm_get_irq());
 }
 
 /* Initialize the internal interrupt controllers.  The number of

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 1917d69f84df..e1274db53d48 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  Copyright (C) 1995  Linus Torvalds
  *  Adapted from 'alpha' version by Gary Thomas

commit de41ef6e4d70f2d30f96ca959fdde3200403d167
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Tue Aug 8 13:58:48 2017 +0200

    powerpc/8xx: Move mpc8xx_pic.c from sysdev to platform/8xx
    
    mpc8xx_pic.c is dedicated to the 8xx, so move it to platform/8xx
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index f81069f79a94..1917d69f84df 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -23,7 +23,7 @@
 #include <asm/fs_pd.h>
 #include <mm/mmu_decl.h>
 
-#include <sysdev/mpc8xx_pic.h>
+#include "pic.h"
 
 #include "mpc8xx.h"
 

commit ef24ba7091517d2bbf9ba2cb4256c0dccd51d248
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Sep 6 21:53:24 2016 +1000

    powerpc: Remove all usages of NO_IRQ
    
    NO_IRQ has been == 0 on powerpc for just over ten years (since commit
    0ebfff1491ef ("[POWERPC] Add new interrupt mapping core and change
    platforms to use it")). It's also 0 on most other arches.
    
    Although it's fairly harmless, every now and then it causes confusion
    when a driver is built on powerpc and another arch which doesn't define
    NO_IRQ. There's at least 6 definitions of NO_IRQ in drivers/, at least
    some of which are to work around that problem.
    
    So we'd like to remove it. This is fairly trivial in the arch code, we
    just convert:
    
        if (irq == NO_IRQ)  to      if (!irq)
        if (irq != NO_IRQ)  to      if (irq)
        irq = NO_IRQ;       to      irq = 0;
        return NO_IRQ;      to      return 0;
    
    And a few other odd cases as well.
    
    At least for now we keep the #define NO_IRQ, because there is driver
    code that uses NO_IRQ and the fixes to remove those will go via other
    trees.
    
    Note we also change some occurrences in PPC sound drivers, drivers/ps3,
    and drivers/macintosh.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index b1ab6e96cb31..f81069f79a94 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -241,6 +241,6 @@ void __init mpc8xx_pics_init(void)
 	}
 
 	irq = cpm_pic_init();
-	if (irq != NO_IRQ)
+	if (irq)
 		irq_set_chained_handler(irq, cpm_cascade);
 }

commit 95ec77c06e8e63fff50c497eca0668bf6da39813
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Jul 12 10:54:52 2016 +1000

    powerpc: Make ppc_md.{halt, restart} __noreturn
    
    powernv marks it's halt and restart calls as __noreturn. However,
    ppc_md does not have this annotation. Add the annotation to ppc_md,
    and then to every halt/restart function that is missing it.
    
    Additionally, I have verified that all of these functions do not
    return. Occasionally I have added a spin loop to be sure.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index c289fc77b4ba..b1ab6e96cb31 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -198,7 +198,7 @@ void mpc8xx_get_rtc_time(struct rtc_time *tm)
 	return;
 }
 
-void mpc8xx_restart(char *cmd)
+void __noreturn mpc8xx_restart(char *cmd)
 {
 	car8xx_t __iomem *clk_r = immr_map(im_clkrst);
 

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index d3037747031d..c289fc77b4ba 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -214,7 +214,7 @@ void mpc8xx_restart(char *cmd)
 	panic("Restart failed\n");
 }
 
-static void cpm_cascade(unsigned int irq, struct irq_desc *desc)
+static void cpm_cascade(struct irq_desc *desc)
 {
 	struct irq_chip *chip = irq_desc_get_chip(desc);
 	int cascade_irq = cpm_get_irq();

commit 087dfae3fe3fe6f8b18285890eb9255ec8478d52
Author: Scott Wood <scottwood@freescale.com>
Date:   Fri Jun 20 19:55:33 2014 -0500

    powerpc/8xx: Remove empty asm/mpc8xx.h
    
    m8xx_pcmcia_ops was the only thing in this file (other than a comment
    that describes a usage that doesn't match the file's contents); now
    that m8xx_pcmcia_ops is gone, remove the empty file.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Cc: Pantelis Antoniou <pantelis.antoniou@gmail.com>
    Cc: Vitaly Bordug <vitb@kernel.crashing.org>
    Cc: netdev@vger.kernel.org

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 623bb43f2b48..d3037747031d 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -18,7 +18,6 @@
 #include <linux/fsl_devices.h>
 
 #include <asm/io.h>
-#include <asm/mpc8xx.h>
 #include <asm/8xx_immap.h>
 #include <asm/prom.h>
 #include <asm/fs_pd.h>

commit 39eb56da2b53bec6720181ed6dc29390a1d91f25
Author: Scott Wood <scottwood@freescale.com>
Date:   Fri Jun 20 19:42:59 2014 -0500

    pcmcia: Remove m8xx_pcmcia driver
    
    This driver doesn't build, and apparently has not built since
    arch/ppc was removed in 2008 (when mk_int_int_mask was removed
    from asm/irq.h, among other build errors).
    
    A few weeks ago I asked whether anyone was actively maintaining
    this code, and got no positive response:
    http://patchwork.ozlabs.org/patch/352082/
    
    So, let's remove it.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Cc: Vitaly Bordug <vitb@kernel.crashing.org>
    Cc: linux-pcmcia@lists.infradead.org
    Cc: Paul Bolle <pebolle@tiscali.nl>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 587a2828b06c..623bb43f2b48 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -28,8 +28,6 @@
 
 #include "mpc8xx.h"
 
-struct mpc8xx_pcmcia_ops m8xx_pcmcia_ops;
-
 extern int cpm_pic_init(void);
 extern int cpm_get_irq(void);
 

commit 7601f59765a48bef329a429101eabcb0e2503634
Author: LEROY Christophe <christophe.leroy@c-s.fr>
Date:   Thu Apr 18 07:26:11 2013 +0200

    powerpc/8xx: Erroneous double irq_eoi() on CPM IRQ in MPC8xx
    
    irq_eoi() is already called by generic_handle_irq() so
    it shall not be called a again
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Scott Wood <scottwood@freescale.com>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 806cbbd86ec6..587a2828b06c 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -219,19 +219,12 @@ void mpc8xx_restart(char *cmd)
 
 static void cpm_cascade(unsigned int irq, struct irq_desc *desc)
 {
-	struct irq_chip *chip;
-	int cascade_irq;
-
-	if ((cascade_irq = cpm_get_irq()) >= 0) {
-		struct irq_desc *cdesc = irq_to_desc(cascade_irq);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
+	int cascade_irq = cpm_get_irq();
 
+	if (cascade_irq >= 0)
 		generic_handle_irq(cascade_irq);
 
-		chip = irq_desc_get_chip(cdesc);
-		chip->irq_eoi(&cdesc->irq_data);
-	}
-
-	chip = irq_desc_get_chip(desc);
 	chip->irq_eoi(&desc->irq_data);
 }
 

commit e80034047bee9ceacfc1bfff873ebfdd049817ca
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Feb 13 23:38:51 2013 +0100

    powerpc: Mark low level irq handlers NO_THREAD
    
    These low level handlers cannot be threaded. Mark them NO_THREAD
    
    Reported-by: leroy christophe <christophe.leroy@c-s.fr>
    Tested-by: leroy christophe <christophe.leroy@c-s.fr>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 1e121088826f..806cbbd86ec6 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -43,6 +43,7 @@ static irqreturn_t timebase_interrupt(int irq, void *dev)
 
 static struct irqaction tbint_irqaction = {
 	.handler = timebase_interrupt,
+	.flags = IRQF_NO_THREAD,
 	.name = "tbint",
 };
 

commit 476eb4912601a8c01e6702b9a029f476b4b131d2
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed May 4 15:02:15 2011 +1000

    powerpc/irq: Stop exporting irq_map
    
    First step in eliminating irq_map[] table entirely
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 9ecce995dd4b..1e121088826f 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -150,7 +150,7 @@ void __init mpc8xx_calibrate_decr(void)
 	 */
 	cpu = of_find_node_by_type(NULL, "cpu");
 	virq= irq_of_parse_and_map(cpu, 0);
-	irq = irq_map[virq].hwirq;
+	irq = virq_to_hw(virq);
 
 	sys_tmr2 = immr_map(im_sit);
 	out_be16(&sys_tmr2->sit_tbscr, ((1 << (7 - (irq/2))) << 8) |

commit ec775d0e70eb6b7116406b3441cb8501c2849dd2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 25 16:45:20 2011 +0100

    powerpc: Convert to new irq_* function names
    
    Scripted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index fabb108e8744..9ecce995dd4b 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -226,11 +226,11 @@ static void cpm_cascade(unsigned int irq, struct irq_desc *desc)
 
 		generic_handle_irq(cascade_irq);
 
-		chip = get_irq_desc_chip(cdesc);
+		chip = irq_desc_get_chip(cdesc);
 		chip->irq_eoi(&cdesc->irq_data);
 	}
 
-	chip = get_irq_desc_chip(desc);
+	chip = irq_desc_get_chip(desc);
 	chip->irq_eoi(&desc->irq_data);
 }
 
@@ -251,5 +251,5 @@ void __init mpc8xx_pics_init(void)
 
 	irq = cpm_pic_init();
 	if (irq != NO_IRQ)
-		set_irq_chained_handler(irq, cpm_cascade);
+		irq_set_chained_handler(irq, cpm_cascade);
 }

commit cfe4a109940db985b567105bb8f25ebebf953370
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Mar 7 13:59:25 2011 +0000

    powerpc: platforms/8xx irq_data conversion.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 60168c1f98fe..fabb108e8744 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -218,15 +218,20 @@ void mpc8xx_restart(char *cmd)
 
 static void cpm_cascade(unsigned int irq, struct irq_desc *desc)
 {
+	struct irq_chip *chip;
 	int cascade_irq;
 
 	if ((cascade_irq = cpm_get_irq()) >= 0) {
 		struct irq_desc *cdesc = irq_to_desc(cascade_irq);
 
 		generic_handle_irq(cascade_irq);
-		cdesc->chip->eoi(cascade_irq);
+
+		chip = get_irq_desc_chip(cdesc);
+		chip->irq_eoi(&cdesc->irq_data);
 	}
-	desc->chip->eoi(irq);
+
+	chip = get_irq_desc_chip(desc);
+	chip->irq_eoi(&desc->irq_data);
 }
 
 /* Initialize the internal interrupt controllers.  The number of

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 242954c4293f..60168c1f98fe 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -11,7 +11,6 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/slab.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/time.h>

commit 588e050887c5f00a39b056848ea58c8b496beab0
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Oct 30 16:59:44 2009 +1100

    powerpc/8xx: Fix build breakage with sparse irq changes
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 385acfc48397..242954c4293f 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -222,7 +222,7 @@ static void cpm_cascade(unsigned int irq, struct irq_desc *desc)
 	int cascade_irq;
 
 	if ((cascade_irq = cpm_get_irq()) >= 0) {
-		struct irq_desc *cdesc = irq_desc + cascade_irq;
+		struct irq_desc *cdesc = irq_to_desc(cascade_irq);
 
 		generic_handle_irq(cascade_irq);
 		cdesc->chip->eoi(cascade_irq);

commit 1a8a51004a18b627ea81444201f7867875212f46
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Mon Mar 30 22:05:13 2009 -0600

    cpumask: remove references to struct irqaction's mask field.
    
    Impact: cleanup
    
    It's unused, since about 1995.  So remove all initialization of it in
    preparation for actually removing the field.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 0d9f75c74f8c..385acfc48397 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -44,7 +44,6 @@ static irqreturn_t timebase_interrupt(int irq, void *dev)
 
 static struct irqaction tbint_irqaction = {
 	.handler = timebase_interrupt,
-	.mask = CPU_MASK_NONE,
 	.name = "tbint",
 };
 

commit 50530378161fa8d7837243119ed9140ee65e55d4
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Fri Feb 22 06:45:08 2008 +1100

    [POWERPC] 8xx: Timebase frequency should not depend on bus-frequency
    
    m8xx_setup.c says:
       /* Force all 8xx processors to use divide by 16 processor clock. */
    
    And at the same time it is using bus-frequency for calculating
    timebase.  It is okay for most setups because bus-frequency is
    equal to clock-frequency.
    
    The problem emerges when cpu frequency is > 66MHz, quoting
    u-boot/cpu/mpc8xx/speed.c:
    
            if (gd->cpu_clk <= 66000000) {
                    sccr_reg |= SCCR_EBDF00;        /* bus division factor = 1 */
                    gd->bus_clk = gd->cpu_clk;
            } else {
                    sccr_reg |= SCCR_EBDF01;        /* bus division factor = 2 */
                    gd->bus_clk = gd->cpu_clk / 2;
            }
    
    So in case of cpu clock > 66MHz, bus_clk = cpu_clk / 2. An then, from
    Linux, we calculate timebase frequency as tb_freq = bus_clk / 16,
    that is cpu_clk / 2 / 16, which is wrong.
    
    This fixes the system time drifting problem on the EP885C board
    running at 133MHz.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 184f998d1be2..0d9f75c74f8c 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -111,17 +111,12 @@ void __init mpc8xx_calibrate_decr(void)
 
 	/* Processor frequency is MHz.
 	 */
-	ppc_tb_freq = 50000000;
-	if (!get_freq("bus-frequency", &ppc_tb_freq)) {
-		printk(KERN_ERR "WARNING: Estimating decrementer frequency "
-		                "(not found)\n");
-	}
-	ppc_tb_freq /= 16;
 	ppc_proc_freq = 50000000;
 	if (!get_freq("clock-frequency", &ppc_proc_freq))
 		printk(KERN_ERR "WARNING: Estimating processor frequency "
 		                "(not found)\n");
 
+	ppc_tb_freq = ppc_proc_freq / 16;
 	printk("Decrementer Frequency = 0x%lx\n", ppc_tb_freq);
 
 	/* Perform some more timer/timebase initialization.  This used

commit 02753cb608cc2c35dbe670b466eb3b88d063b42e
Author: Jochen Friedrich <jochen@scram.de>
Date:   Thu Jan 24 16:19:01 2008 +0100

    [POWERPC] 8xx: Get rid of conditional includes of board specific setup
    
    Directly include mpc885ads.h from mpc885ads_setup.c. Now we can get rid
    of the arch dependent includes in mpc8xx.h.
    
    Signed-off-by: Jochen Friedrich <jochen@scram.de>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 1867a07d0faa..184f998d1be2 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/time.h>
 #include <linux/rtc.h>
+#include <linux/fsl_devices.h>
 
 #include <asm/io.h>
 #include <asm/mpc8xx.h>
@@ -28,9 +29,7 @@
 
 #include "mpc8xx.h"
 
-#ifdef CONFIG_PCMCIA_M8XX
 struct mpc8xx_pcmcia_ops m8xx_pcmcia_ops;
-#endif
 
 extern int cpm_pic_init(void);
 extern int cpm_get_irq(void);

commit 49b51545ff33734ac1c7e0a28c16ca1f49e51b8a
Author: Jochen Friedrich <jochen@scram.de>
Date:   Thu Jan 24 16:18:32 2008 +0100

    [POWERPC] 8xx: Remove sysdev/commproc.h
    
    Move cpm1 specific prototypes to asm/commproc.h and mpc8xx specific
    prototypes to asm/mpc8xx.h. Adjust includes accordingly. Remove now
    unneeded sysdev/commproc.h.
    
    Signed-off-by: Jochen Friedrich <jochen@scram.de>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 85abd61a8140..1867a07d0faa 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -25,7 +25,8 @@
 #include <mm/mmu_decl.h>
 
 #include <sysdev/mpc8xx_pic.h>
-#include <sysdev/commproc.h>
+
+#include "mpc8xx.h"
 
 #ifdef CONFIG_PCMCIA_M8XX
 struct mpc8xx_pcmcia_ops m8xx_pcmcia_ops;

commit 9e8f38b0388144c0a400499abd0f8370abc88ced
Author: Jochen Friedrich <jochen@scram.de>
Date:   Thu Jan 24 16:18:03 2008 +0100

    [POWERPC] 8xx: Remove unneeded and misspelled prototype m8xx_calibrate_decr
    
    m8xx_calibrate_decr seems to be a misspelled prototype for
    mpc8xx_calibrate_decr. As it's not needed anyways, just remove it.
    
    Signed-off-by: Jochen Friedrich <jochen@scram.de>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 13374574502d..85abd61a8140 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -31,7 +31,6 @@
 struct mpc8xx_pcmcia_ops m8xx_pcmcia_ops;
 #endif
 
-void m8xx_calibrate_decr(void);
 extern int cpm_pic_init(void);
 extern int cpm_get_irq(void);
 

commit d0a02a06bcdf4525638863d4f18326e5b2bcf279
Author: Jochen Friedrich <jochen@scram.de>
Date:   Thu Jan 24 16:17:32 2008 +0100

    [POWERPC] 8xx: Rename m8xx_pic_init to mpc8xx_pics_init
    
    m8xx_pic_init calls both mpc8xx_pic_init and cpm_pic_init. Renaming the
    function to use the same name space as the rest of the mpc8xx
    specific funtions and to be more meaningful.
    
    m8xx_pic_init is declared in ppc8xx_pic.h but defined nowhere in the ppc
    tree. Remove it.
    
    Signed-off-by: Jochen Friedrich <jochen@scram.de>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index ba645c2b63f6..13374574502d 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -237,13 +237,13 @@ static void cpm_cascade(unsigned int irq, struct irq_desc *desc)
 	desc->chip->eoi(irq);
 }
 
-/* Initialize the internal interrupt controller.  The number of
+/* Initialize the internal interrupt controllers.  The number of
  * interrupts supported can vary with the processor type, and the
  * 82xx family can have up to 64.
  * External interrupts can be either edge or level triggered, and
  * need to be initialized by the appropriate driver.
  */
-void __init m8xx_pic_init(void)
+void __init mpc8xx_pics_init(void)
 {
 	int irq;
 

commit df3c9019ed20dbd46b945adeec09c0e82034252a
Author: joe@perches.com <joe@perches.com>
Date:   Tue Nov 20 12:47:55 2007 +1100

    [POWERPC] Add missing spaces in printk formats
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index d35eda80e9e6..ba645c2b63f6 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -120,7 +120,7 @@ void __init mpc8xx_calibrate_decr(void)
 	ppc_tb_freq /= 16;
 	ppc_proc_freq = 50000000;
 	if (!get_freq("clock-frequency", &ppc_proc_freq))
-		printk(KERN_ERR "WARNING: Estimating processor frequency"
+		printk(KERN_ERR "WARNING: Estimating processor frequency "
 		                "(not found)\n");
 
 	printk("Decrementer Frequency = 0x%lx\n", ppc_tb_freq);

commit fb533d0c5a9783ecafa9a177bace6384c47282a9
Author: Scott Wood <scottwood@freescale.com>
Date:   Fri Sep 14 14:22:36 2007 -0500

    [POWERPC] 8xx: Infrastructure code cleanup.
    
    1. Keep a global mpc8xx_immr mapping, rather than constantly
    creating temporary mappings.
    2. Look for new fsl,cpm1 and fsl,cpm1-pic names.
    3. Always reset the CPM when not using the udbg console;
    this is required in case the firmware initialized a device
    that is incompatible with one that the kernel is about to
    use.
    4. Remove some superfluous casts and header includes.
    5. Change a usage of IMAP_ADDR to get_immrbase().
    6. Use phys_addr_t, not uint, for dpram_pbase.
    7. Various sparse-related fixes, such as __iomem annotations.
    8. Remove mpc8xx_show_cpuinfo, which doesn't provide anything
    useful beyond the generic cpuinfo handler.
    9. Move prototypes for 8xx support functions from board files
    to sysdev/commproc.h.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index b2b98dd8be6a..d35eda80e9e6 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -10,57 +10,33 @@
  * bootup setup stuff..
  */
 
-#include <linux/errno.h>
-#include <linux/sched.h>
 #include <linux/kernel.h>
-#include <linux/mm.h>
-#include <linux/stddef.h>
-#include <linux/unistd.h>
-#include <linux/ptrace.h>
 #include <linux/slab.h>
-#include <linux/user.h>
-#include <linux/a.out.h>
-#include <linux/tty.h>
-#include <linux/major.h>
 #include <linux/interrupt.h>
-#include <linux/reboot.h>
 #include <linux/init.h>
-#include <linux/initrd.h>
-#include <linux/ioport.h>
-#include <linux/bootmem.h>
-#include <linux/seq_file.h>
-#include <linux/root_dev.h>
 #include <linux/time.h>
 #include <linux/rtc.h>
-#include <linux/fsl_devices.h>
 
-#include <asm/mmu.h>
-#include <asm/reg.h>
 #include <asm/io.h>
-#include <asm/pgtable.h>
 #include <asm/mpc8xx.h>
 #include <asm/8xx_immap.h>
-#include <asm/machdep.h>
-#include <asm/time.h>
 #include <asm/prom.h>
 #include <asm/fs_pd.h>
 #include <mm/mmu_decl.h>
 
-#include "sysdev/mpc8xx_pic.h"
+#include <sysdev/mpc8xx_pic.h>
+#include <sysdev/commproc.h>
 
 #ifdef CONFIG_PCMCIA_M8XX
 struct mpc8xx_pcmcia_ops m8xx_pcmcia_ops;
 #endif
 
 void m8xx_calibrate_decr(void);
-#ifdef CONFIG_8xx_WDT
-extern void m8xx_wdt_handler_install(bd_t *bp);
-#endif
 extern int cpm_pic_init(void);
 extern int cpm_get_irq(void);
 
 /* A place holder for time base interrupts, if they are ever enabled. */
-irqreturn_t timebase_interrupt(int irq, void * dev)
+static irqreturn_t timebase_interrupt(int irq, void *dev)
 {
 	printk ("timebase_interrupt()\n");
 
@@ -77,7 +53,7 @@ static struct irqaction tbint_irqaction = {
 void __init __attribute__ ((weak))
 init_internal_rtc(void)
 {
-	sit8xx_t *sys_tmr = (sit8xx_t *) immr_map(im_sit);
+	sit8xx_t __iomem *sys_tmr = immr_map(im_sit);
 
 	/* Disable the RTC one second and alarm interrupts. */
 	clrbits16(&sys_tmr->sit_rtcsc, (RTCSC_SIE | RTCSC_ALE));
@@ -116,13 +92,13 @@ static int __init get_freq(char *name, unsigned long *val)
 void __init mpc8xx_calibrate_decr(void)
 {
 	struct device_node *cpu;
-	cark8xx_t *clk_r1;
-	car8xx_t *clk_r2;
-	sitk8xx_t *sys_tmr1;
-	sit8xx_t *sys_tmr2;
+	cark8xx_t __iomem *clk_r1;
+	car8xx_t __iomem *clk_r2;
+	sitk8xx_t __iomem *sys_tmr1;
+	sit8xx_t __iomem *sys_tmr2;
 	int irq, virq;
 
-	clk_r1 = (cark8xx_t *) immr_map(im_clkrstk);
+	clk_r1 = immr_map(im_clkrstk);
 
 	/* Unlock the SCCR. */
 	out_be32(&clk_r1->cark_sccrk, ~KAPWR_KEY);
@@ -130,7 +106,7 @@ void __init mpc8xx_calibrate_decr(void)
 	immr_unmap(clk_r1);
 
 	/* Force all 8xx processors to use divide by 16 processor clock. */
-	clk_r2 = (car8xx_t *) immr_map(im_clkrst);
+	clk_r2 = immr_map(im_clkrst);
 	setbits32(&clk_r2->car_sccr, 0x02000000);
 	immr_unmap(clk_r2);
 
@@ -164,7 +140,7 @@ void __init mpc8xx_calibrate_decr(void)
 	 * we guarantee the registers are locked, then we unlock them
 	 * for our use.
 	 */
-	sys_tmr1 = (sitk8xx_t *) immr_map(im_sitk);
+	sys_tmr1 = immr_map(im_sitk);
 	out_be32(&sys_tmr1->sitk_tbscrk, ~KAPWR_KEY);
 	out_be32(&sys_tmr1->sitk_rtcsck, ~KAPWR_KEY);
 	out_be32(&sys_tmr1->sitk_tbk, ~KAPWR_KEY);
@@ -184,20 +160,13 @@ void __init mpc8xx_calibrate_decr(void)
 	virq= irq_of_parse_and_map(cpu, 0);
 	irq = irq_map[virq].hwirq;
 
-	sys_tmr2 = (sit8xx_t *) immr_map(im_sit);
+	sys_tmr2 = immr_map(im_sit);
 	out_be16(&sys_tmr2->sit_tbscr, ((1 << (7 - (irq/2))) << 8) |
 					(TBSCR_TBF | TBSCR_TBE));
 	immr_unmap(sys_tmr2);
 
 	if (setup_irq(virq, &tbint_irqaction))
 		panic("Could not allocate timer IRQ!");
-
-#ifdef CONFIG_8xx_WDT
-	/* Install watchdog timer handler early because it might be
-	 * already enabled by the bootloader
-	 */
-	m8xx_wdt_handler_install(binfo);
-#endif
 }
 
 /* The RTC on the MPC8xx is an internal register.
@@ -207,12 +176,12 @@ void __init mpc8xx_calibrate_decr(void)
 
 int mpc8xx_set_rtc_time(struct rtc_time *tm)
 {
-	sitk8xx_t *sys_tmr1;
-	sit8xx_t *sys_tmr2;
+	sitk8xx_t __iomem *sys_tmr1;
+	sit8xx_t __iomem *sys_tmr2;
 	int time;
 
-	sys_tmr1 = (sitk8xx_t *) immr_map(im_sitk);
-	sys_tmr2 = (sit8xx_t *) immr_map(im_sit);
+	sys_tmr1 = immr_map(im_sitk);
+	sys_tmr2 = immr_map(im_sit);
 	time = mktime(tm->tm_year+1900, tm->tm_mon+1, tm->tm_mday,
 	              tm->tm_hour, tm->tm_min, tm->tm_sec);
 
@@ -228,7 +197,7 @@ int mpc8xx_set_rtc_time(struct rtc_time *tm)
 void mpc8xx_get_rtc_time(struct rtc_time *tm)
 {
 	unsigned long data;
-	sit8xx_t *sys_tmr = (sit8xx_t *) immr_map(im_sit);
+	sit8xx_t __iomem *sys_tmr = immr_map(im_sit);
 
 	/* Get time from the RTC. */
 	data = in_be32(&sys_tmr->sit_rtc);
@@ -241,8 +210,7 @@ void mpc8xx_get_rtc_time(struct rtc_time *tm)
 
 void mpc8xx_restart(char *cmd)
 {
-	__volatile__ unsigned char dummy;
-	car8xx_t * clk_r = (car8xx_t *) immr_map(im_clkrst);
+	car8xx_t __iomem *clk_r = immr_map(im_clkrst);
 
 
 	local_irq_disable();
@@ -252,26 +220,8 @@ void mpc8xx_restart(char *cmd)
 	*/
 	mtmsr(mfmsr() & ~0x1000);
 
-	dummy = in_8(&clk_r->res[0]);
-	printk("Restart failed\n");
-	while(1);
-}
-
-void mpc8xx_show_cpuinfo(struct seq_file *m)
-{
-	struct device_node *root;
-	uint memsize = total_memory;
-	const char *model = "";
-
-	seq_printf(m, "Vendor\t\t: Freescale Semiconductor\n");
-
-	root = of_find_node_by_path("/");
-	if (root)
-		model = of_get_property(root, "model", NULL);
-	seq_printf(m, "Machine\t\t: %s\n", model);
-	of_node_put(root);
-
-	seq_printf(m, "Memory\t\t: %d MB\n", memsize / (1024 * 1024));
+	in_8(&clk_r->res[0]);
+	panic("Restart failed\n");
 }
 
 static void cpm_cascade(unsigned int irq, struct irq_desc *desc)

commit ed16c20da6f500bc2dfad933078d2987636a7b60
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Fri Aug 17 01:47:39 2007 -0500

    [POWERPC] Remove old includes from arch/ppc
    
    Remove includes of files that existed in arch/ppc that we dont need in
    arch/powerpc anymore.  The following includes were removed:
    
     <asm/amigappc.h>
     <asm/bootinfo.h>
     <asm/ppcboot.h>
     <asm/ppc_sys.h>
     <asm/residual.h>
     <asm/m8260_pci.h>
    
    This also caused platforms/embedded6xx/mpc7448_hpc2.h to no longer be
    needed and thus removed.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 601b389b570b..b2b98dd8be6a 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -36,13 +36,11 @@
 
 #include <asm/mmu.h>
 #include <asm/reg.h>
-#include <asm/residual.h>
 #include <asm/io.h>
 #include <asm/pgtable.h>
 #include <asm/mpc8xx.h>
 #include <asm/8xx_immap.h>
 #include <asm/machdep.h>
-#include <asm/bootinfo.h>
 #include <asm/time.h>
 #include <asm/prom.h>
 #include <asm/fs_pd.h>
@@ -55,7 +53,9 @@ struct mpc8xx_pcmcia_ops m8xx_pcmcia_ops;
 #endif
 
 void m8xx_calibrate_decr(void);
+#ifdef CONFIG_8xx_WDT
 extern void m8xx_wdt_handler_install(bd_t *bp);
+#endif
 extern int cpm_pic_init(void);
 extern int cpm_get_irq(void);
 

commit 4b218e9bb2fbbc57b5a05de41d77c056a134528c
Author: Scott Wood <scottwood@freescale.com>
Date:   Tue Aug 21 02:36:19 2007 +1000

    [POWERPC] Whitespace cleanup in arch/powerpc
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index f1693550c70c..601b389b570b 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -89,24 +89,24 @@ init_internal_rtc(void)
 
 static int __init get_freq(char *name, unsigned long *val)
 {
-        struct device_node *cpu;
-        const unsigned int *fp;
-        int found = 0;
+	struct device_node *cpu;
+	const unsigned int *fp;
+	int found = 0;
 
-        /* The cpu node should have timebase and clock frequency properties */
-        cpu = of_find_node_by_type(NULL, "cpu");
+	/* The cpu node should have timebase and clock frequency properties */
+	cpu = of_find_node_by_type(NULL, "cpu");
 
-        if (cpu) {
-                fp = of_get_property(cpu, name, NULL);
-                if (fp) {
-                        found = 1;
-                        *val = *fp;
-                }
+	if (cpu) {
+		fp = of_get_property(cpu, name, NULL);
+		if (fp) {
+			found = 1;
+			*val = *fp;
+		}
 
-                of_node_put(cpu);
-        }
+		of_node_put(cpu);
+	}
 
-        return found;
+	return found;
 }
 
 /* The decrementer counts at the system (internal) clock frequency divided by
@@ -122,7 +122,7 @@ void __init mpc8xx_calibrate_decr(void)
 	sit8xx_t *sys_tmr2;
 	int irq, virq;
 
-        clk_r1 = (cark8xx_t *) immr_map(im_clkrstk);
+	clk_r1 = (cark8xx_t *) immr_map(im_clkrstk);
 
 	/* Unlock the SCCR. */
 	out_be32(&clk_r1->cark_sccrk, ~KAPWR_KEY);
@@ -130,24 +130,24 @@ void __init mpc8xx_calibrate_decr(void)
 	immr_unmap(clk_r1);
 
 	/* Force all 8xx processors to use divide by 16 processor clock. */
-        clk_r2 = (car8xx_t *) immr_map(im_clkrst);
+	clk_r2 = (car8xx_t *) immr_map(im_clkrst);
 	setbits32(&clk_r2->car_sccr, 0x02000000);
 	immr_unmap(clk_r2);
 
 	/* Processor frequency is MHz.
 	 */
-        ppc_tb_freq = 50000000;
-        if (!get_freq("bus-frequency", &ppc_tb_freq)) {
-                printk(KERN_ERR "WARNING: Estimating decrementer frequency "
-                                "(not found)\n");
-        }
-        ppc_tb_freq /= 16;
-        ppc_proc_freq = 50000000;
-        if (!get_freq("clock-frequency", &ppc_proc_freq))
-                printk(KERN_ERR "WARNING: Estimating processor frequency"
-                                "(not found)\n");
-
-        printk("Decrementer Frequency = 0x%lx\n", ppc_tb_freq);
+	ppc_tb_freq = 50000000;
+	if (!get_freq("bus-frequency", &ppc_tb_freq)) {
+		printk(KERN_ERR "WARNING: Estimating decrementer frequency "
+		                "(not found)\n");
+	}
+	ppc_tb_freq /= 16;
+	ppc_proc_freq = 50000000;
+	if (!get_freq("clock-frequency", &ppc_proc_freq))
+		printk(KERN_ERR "WARNING: Estimating processor frequency"
+		                "(not found)\n");
+
+	printk("Decrementer Frequency = 0x%lx\n", ppc_tb_freq);
 
 	/* Perform some more timer/timebase initialization.  This used
 	 * to be done elsewhere, but other changes caused it to get
@@ -164,7 +164,7 @@ void __init mpc8xx_calibrate_decr(void)
 	 * we guarantee the registers are locked, then we unlock them
 	 * for our use.
 	 */
-        sys_tmr1 = (sitk8xx_t *) immr_map(im_sitk);
+	sys_tmr1 = (sitk8xx_t *) immr_map(im_sitk);
 	out_be32(&sys_tmr1->sitk_tbscrk, ~KAPWR_KEY);
 	out_be32(&sys_tmr1->sitk_rtcsck, ~KAPWR_KEY);
 	out_be32(&sys_tmr1->sitk_tbk, ~KAPWR_KEY);
@@ -180,8 +180,8 @@ void __init mpc8xx_calibrate_decr(void)
 	 * we have to enable the timebase).  The decrementer interrupt
 	 * is wired into the vector table, nothing to do here for that.
 	 */
-        cpu = of_find_node_by_type(NULL, "cpu");
-        virq= irq_of_parse_and_map(cpu, 0);
+	cpu = of_find_node_by_type(NULL, "cpu");
+	virq= irq_of_parse_and_map(cpu, 0);
 	irq = irq_map[virq].hwirq;
 
 	sys_tmr2 = (sit8xx_t *) immr_map(im_sit);
@@ -211,10 +211,10 @@ int mpc8xx_set_rtc_time(struct rtc_time *tm)
 	sit8xx_t *sys_tmr2;
 	int time;
 
-        sys_tmr1 = (sitk8xx_t *) immr_map(im_sitk);
+	sys_tmr1 = (sitk8xx_t *) immr_map(im_sitk);
 	sys_tmr2 = (sit8xx_t *) immr_map(im_sit);
 	time = mktime(tm->tm_year+1900, tm->tm_mon+1, tm->tm_mday,
-                      tm->tm_hour, tm->tm_min, tm->tm_sec);
+	              tm->tm_hour, tm->tm_min, tm->tm_sec);
 
 	out_be32(&sys_tmr1->sitk_rtck, KAPWR_KEY);
 	out_be32(&sys_tmr2->sit_rtc, time);
@@ -233,8 +233,8 @@ void mpc8xx_get_rtc_time(struct rtc_time *tm)
 	/* Get time from the RTC. */
 	data = in_be32(&sys_tmr->sit_rtc);
 	to_tm(data, tm);
-        tm->tm_year -= 1900;
-        tm->tm_mon -= 1;
+	tm->tm_year -= 1900;
+	tm->tm_mon -= 1;
 	immr_unmap(sys_tmr);
 	return;
 }
@@ -298,7 +298,7 @@ void __init m8xx_pic_init(void)
 	int irq;
 
 	if (mpc8xx_pic_init()) {
-                printk(KERN_ERR "Failed interrupt 8xx controller  initialization\n");
+		printk(KERN_ERR "Failed interrupt 8xx controller  initialization\n");
 		return;
 	}
 

commit 80128ff79d282cf71b1819dbca9b8dd47d8ed3e8
Author: Vitaly Bordug <vitb@kernel.crashing.org>
Date:   Mon Jul 9 11:37:35 2007 -0700

    [POWERPC] 8xx: mpc885ads pcmcia support
    
    Adds support for PowerQuicc on-chip PCMCIA.  The driver is implemented as
    of_device, so only arch/powerpc stuff is capable to use it, which now implies
    only mpc885ads reference board.
    
    To cope with the code that should be hooked inside driver, but is really board
    specific (like set_voltage), global structure mpc8xx_pcmcia_ops holds
    necessary function pointers that are filled in the BSP code.
    
    [akpm@linux-foundation.org: whitespace diddles]
    Signed-off-by: Vitaly Bordug <vitb@kernel.crashing.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Olof Johansson <olof@lixom.net>
    Cc: Dominik Brodowski <linux@dominikbrodowski.net>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 0901dbada350..f1693550c70c 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -32,6 +32,7 @@
 #include <linux/root_dev.h>
 #include <linux/time.h>
 #include <linux/rtc.h>
+#include <linux/fsl_devices.h>
 
 #include <asm/mmu.h>
 #include <asm/reg.h>
@@ -49,6 +50,10 @@
 
 #include "sysdev/mpc8xx_pic.h"
 
+#ifdef CONFIG_PCMCIA_M8XX
+struct mpc8xx_pcmcia_ops m8xx_pcmcia_ops;
+#endif
+
 void m8xx_calibrate_decr(void);
 extern void m8xx_wdt_handler_install(bd_t *bp);
 extern int cpm_pic_init(void);

commit e2eb63927bfcb54232163bfec32440246fd44457
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 3 22:26:41 2007 +1000

    [POWERPC] Rename get_property to of_get_property: arch/powerpc
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
index 9ed7125f0150..0901dbada350 100644
--- a/arch/powerpc/platforms/8xx/m8xx_setup.c
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -85,17 +85,17 @@ init_internal_rtc(void)
 static int __init get_freq(char *name, unsigned long *val)
 {
         struct device_node *cpu;
-        unsigned int *fp;
+        const unsigned int *fp;
         int found = 0;
 
         /* The cpu node should have timebase and clock frequency properties */
         cpu = of_find_node_by_type(NULL, "cpu");
 
         if (cpu) {
-                fp = (unsigned int *)get_property(cpu, name, NULL);
+                fp = of_get_property(cpu, name, NULL);
                 if (fp) {
                         found = 1;
-                        *val = *fp++;
+                        *val = *fp;
                 }
 
                 of_node_put(cpu);
@@ -262,7 +262,7 @@ void mpc8xx_show_cpuinfo(struct seq_file *m)
 
 	root = of_find_node_by_path("/");
 	if (root)
-		model = get_property(root, "model", NULL);
+		model = of_get_property(root, "model", NULL);
 	seq_printf(m, "Machine\t\t: %s\n", model);
 	of_node_put(root);
 

commit df34403dcaacef541a67c955aebc37c51f53ca7c
Author: Vitaly Bordug <vbordug@ru.mvista.com>
Date:   Wed Jan 24 22:41:42 2007 +0300

    [POWERPC] 8xx: Add mpc885ads support and common mpc8xx files
    
    This adds the core 8xx stuff and specifically mpc885ads board-specific
    bits to arch/powerpc. Respective Kconfig has been cleaned up from the stuff
    not yet ported over to avoid confusion. Updated and cleaned version.
    
    Signed-off-by: Vitaly Bordug <vbordug@ru.mvista.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/8xx/m8xx_setup.c b/arch/powerpc/platforms/8xx/m8xx_setup.c
new file mode 100644
index 000000000000..9ed7125f0150
--- /dev/null
+++ b/arch/powerpc/platforms/8xx/m8xx_setup.c
@@ -0,0 +1,303 @@
+/*
+ *  Copyright (C) 1995  Linus Torvalds
+ *  Adapted from 'alpha' version by Gary Thomas
+ *  Modified by Cort Dougan (cort@cs.nmt.edu)
+ *  Modified for MBX using prep/chrp/pmac functions by Dan (dmalek@jlc.net)
+ *  Further modified for generic 8xx by Dan.
+ */
+
+/*
+ * bootup setup stuff..
+ */
+
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/stddef.h>
+#include <linux/unistd.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/user.h>
+#include <linux/a.out.h>
+#include <linux/tty.h>
+#include <linux/major.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <linux/init.h>
+#include <linux/initrd.h>
+#include <linux/ioport.h>
+#include <linux/bootmem.h>
+#include <linux/seq_file.h>
+#include <linux/root_dev.h>
+#include <linux/time.h>
+#include <linux/rtc.h>
+
+#include <asm/mmu.h>
+#include <asm/reg.h>
+#include <asm/residual.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/mpc8xx.h>
+#include <asm/8xx_immap.h>
+#include <asm/machdep.h>
+#include <asm/bootinfo.h>
+#include <asm/time.h>
+#include <asm/prom.h>
+#include <asm/fs_pd.h>
+#include <mm/mmu_decl.h>
+
+#include "sysdev/mpc8xx_pic.h"
+
+void m8xx_calibrate_decr(void);
+extern void m8xx_wdt_handler_install(bd_t *bp);
+extern int cpm_pic_init(void);
+extern int cpm_get_irq(void);
+
+/* A place holder for time base interrupts, if they are ever enabled. */
+irqreturn_t timebase_interrupt(int irq, void * dev)
+{
+	printk ("timebase_interrupt()\n");
+
+	return IRQ_HANDLED;
+}
+
+static struct irqaction tbint_irqaction = {
+	.handler = timebase_interrupt,
+	.mask = CPU_MASK_NONE,
+	.name = "tbint",
+};
+
+/* per-board overridable init_internal_rtc() function. */
+void __init __attribute__ ((weak))
+init_internal_rtc(void)
+{
+	sit8xx_t *sys_tmr = (sit8xx_t *) immr_map(im_sit);
+
+	/* Disable the RTC one second and alarm interrupts. */
+	clrbits16(&sys_tmr->sit_rtcsc, (RTCSC_SIE | RTCSC_ALE));
+
+	/* Enable the RTC */
+	setbits16(&sys_tmr->sit_rtcsc, (RTCSC_RTF | RTCSC_RTE));
+	immr_unmap(sys_tmr);
+}
+
+static int __init get_freq(char *name, unsigned long *val)
+{
+        struct device_node *cpu;
+        unsigned int *fp;
+        int found = 0;
+
+        /* The cpu node should have timebase and clock frequency properties */
+        cpu = of_find_node_by_type(NULL, "cpu");
+
+        if (cpu) {
+                fp = (unsigned int *)get_property(cpu, name, NULL);
+                if (fp) {
+                        found = 1;
+                        *val = *fp++;
+                }
+
+                of_node_put(cpu);
+        }
+
+        return found;
+}
+
+/* The decrementer counts at the system (internal) clock frequency divided by
+ * sixteen, or external oscillator divided by four.  We force the processor
+ * to use system clock divided by sixteen.
+ */
+void __init mpc8xx_calibrate_decr(void)
+{
+	struct device_node *cpu;
+	cark8xx_t *clk_r1;
+	car8xx_t *clk_r2;
+	sitk8xx_t *sys_tmr1;
+	sit8xx_t *sys_tmr2;
+	int irq, virq;
+
+        clk_r1 = (cark8xx_t *) immr_map(im_clkrstk);
+
+	/* Unlock the SCCR. */
+	out_be32(&clk_r1->cark_sccrk, ~KAPWR_KEY);
+	out_be32(&clk_r1->cark_sccrk, KAPWR_KEY);
+	immr_unmap(clk_r1);
+
+	/* Force all 8xx processors to use divide by 16 processor clock. */
+        clk_r2 = (car8xx_t *) immr_map(im_clkrst);
+	setbits32(&clk_r2->car_sccr, 0x02000000);
+	immr_unmap(clk_r2);
+
+	/* Processor frequency is MHz.
+	 */
+        ppc_tb_freq = 50000000;
+        if (!get_freq("bus-frequency", &ppc_tb_freq)) {
+                printk(KERN_ERR "WARNING: Estimating decrementer frequency "
+                                "(not found)\n");
+        }
+        ppc_tb_freq /= 16;
+        ppc_proc_freq = 50000000;
+        if (!get_freq("clock-frequency", &ppc_proc_freq))
+                printk(KERN_ERR "WARNING: Estimating processor frequency"
+                                "(not found)\n");
+
+        printk("Decrementer Frequency = 0x%lx\n", ppc_tb_freq);
+
+	/* Perform some more timer/timebase initialization.  This used
+	 * to be done elsewhere, but other changes caused it to get
+	 * called more than once....that is a bad thing.
+	 *
+	 * First, unlock all of the registers we are going to modify.
+	 * To protect them from corruption during power down, registers
+	 * that are maintained by keep alive power are "locked".  To
+	 * modify these registers we have to write the key value to
+	 * the key location associated with the register.
+	 * Some boards power up with these unlocked, while others
+	 * are locked.  Writing anything (including the unlock code?)
+	 * to the unlocked registers will lock them again.  So, here
+	 * we guarantee the registers are locked, then we unlock them
+	 * for our use.
+	 */
+        sys_tmr1 = (sitk8xx_t *) immr_map(im_sitk);
+	out_be32(&sys_tmr1->sitk_tbscrk, ~KAPWR_KEY);
+	out_be32(&sys_tmr1->sitk_rtcsck, ~KAPWR_KEY);
+	out_be32(&sys_tmr1->sitk_tbk, ~KAPWR_KEY);
+	out_be32(&sys_tmr1->sitk_tbscrk, KAPWR_KEY);
+	out_be32(&sys_tmr1->sitk_rtcsck, KAPWR_KEY);
+	out_be32(&sys_tmr1->sitk_tbk, KAPWR_KEY);
+	immr_unmap(sys_tmr1);
+
+	init_internal_rtc();
+
+	/* Enabling the decrementer also enables the timebase interrupts
+	 * (or from the other point of view, to get decrementer interrupts
+	 * we have to enable the timebase).  The decrementer interrupt
+	 * is wired into the vector table, nothing to do here for that.
+	 */
+        cpu = of_find_node_by_type(NULL, "cpu");
+        virq= irq_of_parse_and_map(cpu, 0);
+	irq = irq_map[virq].hwirq;
+
+	sys_tmr2 = (sit8xx_t *) immr_map(im_sit);
+	out_be16(&sys_tmr2->sit_tbscr, ((1 << (7 - (irq/2))) << 8) |
+					(TBSCR_TBF | TBSCR_TBE));
+	immr_unmap(sys_tmr2);
+
+	if (setup_irq(virq, &tbint_irqaction))
+		panic("Could not allocate timer IRQ!");
+
+#ifdef CONFIG_8xx_WDT
+	/* Install watchdog timer handler early because it might be
+	 * already enabled by the bootloader
+	 */
+	m8xx_wdt_handler_install(binfo);
+#endif
+}
+
+/* The RTC on the MPC8xx is an internal register.
+ * We want to protect this during power down, so we need to unlock,
+ * modify, and re-lock.
+ */
+
+int mpc8xx_set_rtc_time(struct rtc_time *tm)
+{
+	sitk8xx_t *sys_tmr1;
+	sit8xx_t *sys_tmr2;
+	int time;
+
+        sys_tmr1 = (sitk8xx_t *) immr_map(im_sitk);
+	sys_tmr2 = (sit8xx_t *) immr_map(im_sit);
+	time = mktime(tm->tm_year+1900, tm->tm_mon+1, tm->tm_mday,
+                      tm->tm_hour, tm->tm_min, tm->tm_sec);
+
+	out_be32(&sys_tmr1->sitk_rtck, KAPWR_KEY);
+	out_be32(&sys_tmr2->sit_rtc, time);
+	out_be32(&sys_tmr1->sitk_rtck, ~KAPWR_KEY);
+
+	immr_unmap(sys_tmr2);
+	immr_unmap(sys_tmr1);
+	return 0;
+}
+
+void mpc8xx_get_rtc_time(struct rtc_time *tm)
+{
+	unsigned long data;
+	sit8xx_t *sys_tmr = (sit8xx_t *) immr_map(im_sit);
+
+	/* Get time from the RTC. */
+	data = in_be32(&sys_tmr->sit_rtc);
+	to_tm(data, tm);
+        tm->tm_year -= 1900;
+        tm->tm_mon -= 1;
+	immr_unmap(sys_tmr);
+	return;
+}
+
+void mpc8xx_restart(char *cmd)
+{
+	__volatile__ unsigned char dummy;
+	car8xx_t * clk_r = (car8xx_t *) immr_map(im_clkrst);
+
+
+	local_irq_disable();
+
+	setbits32(&clk_r->car_plprcr, 0x00000080);
+	/* Clear the ME bit in MSR to cause checkstop on machine check
+	*/
+	mtmsr(mfmsr() & ~0x1000);
+
+	dummy = in_8(&clk_r->res[0]);
+	printk("Restart failed\n");
+	while(1);
+}
+
+void mpc8xx_show_cpuinfo(struct seq_file *m)
+{
+	struct device_node *root;
+	uint memsize = total_memory;
+	const char *model = "";
+
+	seq_printf(m, "Vendor\t\t: Freescale Semiconductor\n");
+
+	root = of_find_node_by_path("/");
+	if (root)
+		model = get_property(root, "model", NULL);
+	seq_printf(m, "Machine\t\t: %s\n", model);
+	of_node_put(root);
+
+	seq_printf(m, "Memory\t\t: %d MB\n", memsize / (1024 * 1024));
+}
+
+static void cpm_cascade(unsigned int irq, struct irq_desc *desc)
+{
+	int cascade_irq;
+
+	if ((cascade_irq = cpm_get_irq()) >= 0) {
+		struct irq_desc *cdesc = irq_desc + cascade_irq;
+
+		generic_handle_irq(cascade_irq);
+		cdesc->chip->eoi(cascade_irq);
+	}
+	desc->chip->eoi(irq);
+}
+
+/* Initialize the internal interrupt controller.  The number of
+ * interrupts supported can vary with the processor type, and the
+ * 82xx family can have up to 64.
+ * External interrupts can be either edge or level triggered, and
+ * need to be initialized by the appropriate driver.
+ */
+void __init m8xx_pic_init(void)
+{
+	int irq;
+
+	if (mpc8xx_pic_init()) {
+                printk(KERN_ERR "Failed interrupt 8xx controller  initialization\n");
+		return;
+	}
+
+	irq = cpm_pic_init();
+	if (irq != NO_IRQ)
+		set_irq_chained_handler(irq, cpm_cascade);
+}
