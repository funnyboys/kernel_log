commit e31cf2f4ca422ac9b14ecc4a1295b8977a20f812
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:33 2020 -0700

    mm: don't include asm/pgtable.h if linux/mm.h is already included
    
    Patch series "mm: consolidate definitions of page table accessors", v2.
    
    The low level page table accessors (pXY_index(), pXY_offset()) are
    duplicated across all architectures and sometimes more than once.  For
    instance, we have 31 definition of pgd_offset() for 25 supported
    architectures.
    
    Most of these definitions are actually identical and typically it boils
    down to, e.g.
    
    static inline unsigned long pmd_index(unsigned long address)
    {
            return (address >> PMD_SHIFT) & (PTRS_PER_PMD - 1);
    }
    
    static inline pmd_t *pmd_offset(pud_t *pud, unsigned long address)
    {
            return (pmd_t *)pud_page_vaddr(*pud) + pmd_index(address);
    }
    
    These definitions can be shared among 90% of the arches provided
    XYZ_SHIFT, PTRS_PER_XYZ and xyz_page_vaddr() are defined.
    
    For architectures that really need a custom version there is always
    possibility to override the generic version with the usual ifdefs magic.
    
    These patches introduce include/linux/pgtable.h that replaces
    include/asm-generic/pgtable.h and add the definitions of the page table
    accessors to the new header.
    
    This patch (of 12):
    
    The linux/mm.h header includes <asm/pgtable.h> to allow inlining of the
    functions involving page table manipulations, e.g.  pte_alloc() and
    pmd_alloc().  So, there is no point to explicitly include <asm/pgtable.h>
    in the files that include <linux/mm.h>.
    
    The include statements in such cases are remove with a simple loop:
    
            for f in $(git grep -l "include <linux/mm.h>") ; do
                    sed -i -e '/include <asm\/pgtable.h>/ d' $f
            done
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Mike Rapoport <rppt@kernel.org>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-1-rppt@kernel.org
    Link: http://lkml.kernel.org/r/20200514170327.31389-2-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 95fb4feb6ccc..f002b0fa69b8 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -51,7 +51,6 @@
 #include <asm/reg.h>
 #include <asm/sections.h>
 #include <asm/prom.h>
-#include <asm/pgtable.h>
 #include <asm/io.h>
 #include <asm/pci-bridge.h>
 #include <asm/ohare.h>

commit b77afad84e1eedca03658ae1478ce5b8ed5aa18c
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Nov 25 11:20:33 2019 +0200

    powerpc/32: drop unused ISA_DMA_THRESHOLD
    
    The ISA_DMA_THRESHOLD variable is set by several platforms but never
    referenced.
    Remove it.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20191125092033.20014-1-rppt@kernel.org

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index c6d5333729ed..95fb4feb6ccc 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -586,7 +586,6 @@ static int __init pmac_probe(void)
 
 #ifdef CONFIG_PPC32
 	/* isa_io_base gets set in pmac_pci_init */
-	ISA_DMA_THRESHOLD = ~0L;
 	DMA_MODE_READ = 1;
 	DMA_MODE_WRITE = 2;
 #endif /* CONFIG_PPC32 */

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index b7efcf336589..c6d5333729ed 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  Powermac setup and early boot code plus other random bits.
  *
@@ -11,12 +12,6 @@
  *    Copyright (C) 1995 Linus Torvalds
  *
  *  Maintained by Benjamin Herrenschmidt (benh@kernel.crashing.org)
- *
- *  This program is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU General Public License
- *  as published by the Free Software Foundation; either version
- *  2 of the License, or (at your option) any later version.
- *
  */
 
 /*

commit 20e07af71f34d9d1f18aefde6ed234d775fa62bc
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Jan 15 15:18:56 2019 +1100

    powerpc: Adopt nvram module for PPC64
    
    Adopt nvram module to reduce code duplication. This means CONFIG_NVRAM
    becomes available to PPC64 builds. Previously it was only available to
    PPC32 builds because it depended on CONFIG_GENERIC_NVRAM.
    
    The IOC_NVRAM_GET_OFFSET ioctl as implemented on PPC64 validates the
    offset returned by pmac_get_partition(). Do the same in the nvram module.
    
    Note that the old PPC32 generic_nvram module lacked this test.
    So when CONFIG_PPC32 && CONFIG_PPC_PMAC, the IOC_NVRAM_GET_OFFSET ioctl
    would have returned 0 (always). But when CONFIG_PPC64 && CONFIG_PPC_PMAC,
    the IOC_NVRAM_GET_OFFSET ioctl would have returned -1 (which is -EPERM)
    when the requested partition was not found.
    
    With this patch, the result is now -EINVAL on both PPC32 and PPC64 when
    the requested PowerMac NVRAM partition is not found. This is a userspace-
    visible change, in the non-existent partition case, which would be in
    an error path for an IOC_NVRAM_GET_OFFSET ioctl syscall.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index b47f49cf9c4d..b7efcf336589 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -316,7 +316,7 @@ static void __init pmac_setup_arch(void)
 	find_via_pmu();
 	smu_init();
 
-#if IS_ENABLED(CONFIG_NVRAM) || defined(CONFIG_PPC64)
+#if IS_ENABLED(CONFIG_NVRAM)
 	pmac_nvram_init();
 #endif
 #ifdef CONFIG_PPC32

commit f9c3a570f5fc584f2ca2dd222d1b8c8537fc55f6
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Jan 15 15:18:56 2019 +1100

    powerpc: Enable HAVE_ARCH_NVRAM_OPS and disable GENERIC_NVRAM
    
    Switch PPC32 kernels from the generic_nvram module to the nvram module.
    
    Also fix a theoretical bug where CHRP omits the chrp_nvram_init() call
    when CONFIG_NVRAM_MODULE=m.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 2e8221e20ee8..b47f49cf9c4d 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -316,8 +316,7 @@ static void __init pmac_setup_arch(void)
 	find_via_pmu();
 	smu_init();
 
-#if defined(CONFIG_NVRAM) || defined(CONFIG_NVRAM_MODULE) || \
-    defined(CONFIG_PPC64)
+#if IS_ENABLED(CONFIG_NVRAM) || defined(CONFIG_PPC64)
 	pmac_nvram_init();
 #endif
 #ifdef CONFIG_PPC32

commit 2c8e65b595cf0bf7c1413404dff9b928a64d27cb
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 5 13:50:18 2018 -0600

    powerpc: Use of_node_name_eq for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    A couple of open coded iterating thru the child node names are converted
    to use for_each_child_of_node() instead.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 2f00e3daafb0..2e8221e20ee8 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -560,15 +560,9 @@ static int __init check_pmac_serial_console(void)
 	}
 	pr_debug("stdout is %pOF\n", prom_stdout);
 
-	name = of_get_property(prom_stdout, "name", NULL);
-	if (!name) {
-		pr_debug(" stdout package has no name !\n");
-		goto not_found;
-	}
-
-	if (strcmp(name, "ch-a") == 0)
+	if (of_node_name_eq(prom_stdout, "ch-a"))
 		offset = 0;
-	else if (strcmp(name, "ch-b") == 0)
+	else if (of_node_name_eq(prom_stdout, "ch-b"))
 		offset = 1;
 	else
 		goto not_found;

commit a94fe366340ac4d19f8bd88850ab681d9022f3ae
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 27 12:24:09 2018 -0500

    powerpc: use for_each_of_cpu_node iterator
    
    Use the for_each_of_cpu_node iterator to iterate over cpu nodes. This
    has the side effect of defaulting to iterating using "cpu" node names in
    preference to the deprecated (for FDT) device_type == "cpu".
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Rob Herring <robh@kernel.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 3a529fcdae97..2f00e3daafb0 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -243,10 +243,9 @@ static void __init l2cr_init(void)
 {
 	/* Checks "l2cr-value" property in the registry */
 	if (cpu_has_feature(CPU_FTR_L2CR)) {
-		struct device_node *np = of_find_node_by_name(NULL, "cpus");
-		if (!np)
-			np = of_find_node_by_type(NULL, "cpu");
-		if (np) {
+		struct device_node *np;
+
+		for_each_of_cpu_node(np) {
 			const unsigned int *l2cr =
 				of_get_property(np, "l2cr-value", NULL);
 			if (l2cr) {
@@ -256,6 +255,7 @@ static void __init l2cr_init(void)
 				_set_L2CR(ppc_override_l2cr_value);
 			}
 			of_node_put(np);
+			break;
 		}
 	}
 
@@ -279,8 +279,8 @@ static void __init pmac_setup_arch(void)
 	/* Set loops_per_jiffy to a half-way reasonable value,
 	   for use until calibrate_delay gets called. */
 	loops_per_jiffy = 50000000 / HZ;
-	cpu = of_find_node_by_type(NULL, "cpu");
-	if (cpu != NULL) {
+
+	for_each_of_cpu_node(cpu) {
 		fp = of_get_property(cpu, "clock-frequency", NULL);
 		if (fp != NULL) {
 			if (pvr >= 0x30 && pvr < 0x80)
@@ -292,8 +292,9 @@ static void __init pmac_setup_arch(void)
 			else
 				/* 601, 603, etc. */
 				loops_per_jiffy = *fp / (2 * HZ);
+			of_node_put(cpu);
+			break;
 		}
-		of_node_put(cpu);
 	}
 
 	/* See if newworld or oldworld */

commit f72cf3f1d49f2c35d6cb682af2e8c93550f264e4
Author: Mathieu Malaterre <malat@debian.org>
Date:   Wed Apr 4 22:13:05 2018 +0200

    powerpc/powermac: Add missing prototype for note_bootable_part()
    
    Add a missing prototype for function `note_bootable_part` to silence a
    warning treated as error with W=1:
    
      arch/powerpc/platforms/powermac/setup.c:361:12: error: no previous prototype for ‘note_bootable_part’ [-Werror=missing-prototypes]
    
    Suggested-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index f40e87ca180b..3a529fcdae97 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -352,6 +352,7 @@ static int pmac_late_init(void)
 }
 machine_late_initcall(powermac, pmac_late_init);
 
+void note_bootable_part(dev_t dev, int part, int goodness);
 /*
  * This is __ref because we check for "initializing" before
  * touching any of the __init sensitive things and "initializing"

commit d8731527acee53b4d46d59ff0b5fc36931ad0451
Author: Mathieu Malaterre <malat@debian.org>
Date:   Fri Apr 13 20:41:43 2018 +0200

    powerpc/sparse: Fix plain integer as NULL pointer warning
    
    Trivial fix to remove the following sparse warnings:
    
      arch/powerpc/kernel/module_32.c:112:74: warning: Using plain integer as NULL pointer
      arch/powerpc/kernel/module_32.c:117:74: warning: Using plain integer as NULL pointer
      drivers/macintosh/via-pmu.c:1155:28: warning: Using plain integer as NULL pointer
      drivers/macintosh/via-pmu.c:1230:20: warning: Using plain integer as NULL pointer
      drivers/macintosh/via-pmu.c:1385:36: warning: Using plain integer as NULL pointer
      drivers/macintosh/via-pmu.c:1752:23: warning: Using plain integer as NULL pointer
      drivers/macintosh/via-pmu.c:2084:19: warning: Using plain integer as NULL pointer
      drivers/macintosh/via-pmu.c:2110:32: warning: Using plain integer as NULL pointer
      drivers/macintosh/via-pmu.c:2167:19: warning: Using plain integer as NULL pointer
      drivers/macintosh/via-pmu.c:2183:19: warning: Using plain integer as NULL pointer
      drivers/macintosh/via-pmu.c:277:20: warning: Using plain integer as NULL pointer
      arch/powerpc/platforms/powermac/setup.c:155:67: warning: Using plain integer as NULL pointer
      arch/powerpc/platforms/powermac/setup.c:247:27: warning: Using plain integer as NULL pointer
      arch/powerpc/platforms/powermac/setup.c:249:27: warning: Using plain integer as NULL pointer
      arch/powerpc/platforms/powermac/setup.c:252:37: warning: Using plain integer as NULL pointer
      arch/powerpc/mm/tlb_hash32.c:127:21: warning: Using plain integer as NULL pointer
      arch/powerpc/mm/tlb_hash32.c:148:21: warning: Using plain integer as NULL pointer
      arch/powerpc/mm/tlb_hash32.c:44:21: warning: Using plain integer as NULL pointer
      arch/powerpc/mm/tlb_hash32.c:57:21: warning: Using plain integer as NULL pointer
      arch/powerpc/mm/tlb_hash32.c:87:21: warning: Using plain integer as NULL pointer
      arch/powerpc/kernel/btext.c:160:31: warning: Using plain integer as NULL pointer
      arch/powerpc/kernel/btext.c:167:22: warning: Using plain integer as NULL pointer
      arch/powerpc/kernel/btext.c:274:21: warning: Using plain integer as NULL pointer
      arch/powerpc/kernel/btext.c:285:31: warning: Using plain integer as NULL pointer
      arch/powerpc/include/asm/hugetlb.h:204:16: warning: Using plain integer as NULL pointer
      arch/powerpc/mm/ppc_mmu_32.c:170:21: warning: Using plain integer as NULL pointer
      arch/powerpc/platforms/powermac/pci.c:1227:23: warning: Using plain integer as NULL pointer
      arch/powerpc/platforms/powermac/pci.c:65:24: warning: Using plain integer as NULL pointer
    
    Also use `--fix` command line option from `script/checkpatch --strict` to
    remove the following:
    
      CHECK: Comparison to NULL could be written "!dispDeviceBase"
      #72: FILE: arch/powerpc/kernel/btext.c:160:
      +     if (dispDeviceBase == NULL)
    
      CHECK: Comparison to NULL could be written "!vbase"
      #80: FILE: arch/powerpc/kernel/btext.c:167:
      +     if (vbase == NULL)
    
      CHECK: Comparison to NULL could be written "!base"
      #89: FILE: arch/powerpc/kernel/btext.c:274:
      +     if (base == NULL)
    
      CHECK: Comparison to NULL could be written "!dispDeviceBase"
      #98: FILE: arch/powerpc/kernel/btext.c:285:
      +     if (dispDeviceBase == NULL)
    
      CHECK: Comparison to NULL could be written "strstr"
      #117: FILE: arch/powerpc/kernel/module_32.c:117:
      +             if (strstr(secstrings + sechdrs[i].sh_name, ".debug") != NULL)
    
      CHECK: Comparison to NULL could be written "!Hash"
      #130: FILE: arch/powerpc/mm/ppc_mmu_32.c:170:
      +     if (Hash == NULL)
    
      CHECK: Comparison to NULL could be written "Hash"
      #143: FILE: arch/powerpc/mm/tlb_hash32.c:44:
      +     if (Hash != NULL) {
    
      CHECK: Comparison to NULL could be written "!Hash"
      #152: FILE: arch/powerpc/mm/tlb_hash32.c:57:
      +     if (Hash == NULL) {
    
      CHECK: Comparison to NULL could be written "!Hash"
      #161: FILE: arch/powerpc/mm/tlb_hash32.c:87:
      +     if (Hash == NULL) {
    
      CHECK: Comparison to NULL could be written "!Hash"
      #170: FILE: arch/powerpc/mm/tlb_hash32.c:127:
      +     if (Hash == NULL) {
    
      CHECK: Comparison to NULL could be written "!Hash"
      #179: FILE: arch/powerpc/mm/tlb_hash32.c:148:
      +     if (Hash == NULL) {
    
      ERROR: space required after that ';' (ctx:VxV)
      #192: FILE: arch/powerpc/platforms/powermac/pci.c:65:
      +     for (; node != NULL;node = node->sibling) {
    
      CHECK: Comparison to NULL could be written "node"
      #192: FILE: arch/powerpc/platforms/powermac/pci.c:65:
      +     for (; node != NULL;node = node->sibling) {
    
      CHECK: Comparison to NULL could be written "!region"
      #201: FILE: arch/powerpc/platforms/powermac/pci.c:1227:
      +     if (region == NULL)
    
      CHECK: Comparison to NULL could be written "of_get_property"
      #214: FILE: arch/powerpc/platforms/powermac/setup.c:155:
      +             if (of_get_property(np, "cache-unified", NULL) != NULL && dc) {
    
      CHECK: Comparison to NULL could be written "!np"
      #223: FILE: arch/powerpc/platforms/powermac/setup.c:247:
      +             if (np == NULL)
    
      CHECK: Comparison to NULL could be written "np"
      #226: FILE: arch/powerpc/platforms/powermac/setup.c:249:
      +             if (np != NULL) {
    
      CHECK: Comparison to NULL could be written "l2cr"
      #230: FILE: arch/powerpc/platforms/powermac/setup.c:252:
      +                     if (l2cr != NULL) {
    
      CHECK: Comparison to NULL could be written "via"
      #243: FILE: drivers/macintosh/via-pmu.c:277:
      +     if (via != NULL)
    
      CHECK: Comparison to NULL could be written "current_req"
      #252: FILE: drivers/macintosh/via-pmu.c:1155:
      +     if (current_req != NULL) {
    
      CHECK: Comparison to NULL could be written "!req"
      #261: FILE: drivers/macintosh/via-pmu.c:1230:
      +     if (req == NULL || pmu_state != idle
    
      CHECK: Comparison to NULL could be written "!req"
      #270: FILE: drivers/macintosh/via-pmu.c:1385:
      +                     if (req == NULL) {
    
      CHECK: Comparison to NULL could be written "!pp"
      #288: FILE: drivers/macintosh/via-pmu.c:2084:
      +     if (pp == NULL)
    
      CHECK: Comparison to NULL could be written "!pp"
      #297: FILE: drivers/macintosh/via-pmu.c:2110:
      +     if (count < 1 || pp == NULL)
    
      CHECK: Comparison to NULL could be written "!pp"
      #306: FILE: drivers/macintosh/via-pmu.c:2167:
      +     if (pp == NULL)
    
      CHECK: Comparison to NULL could be written "pp"
      #315: FILE: drivers/macintosh/via-pmu.c:2183:
      +     if (pp != NULL) {
    
    Link: https://github.com/linuxppc/linux/issues/37
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index ab668cb72263..f40e87ca180b 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -152,7 +152,7 @@ static void pmac_show_cpuinfo(struct seq_file *m)
 			of_get_property(np, "d-cache-size", NULL);
 		seq_printf(m, "L2 cache\t:");
 		has_l2cache = 1;
-		if (of_get_property(np, "cache-unified", NULL) != 0 && dc) {
+		if (of_get_property(np, "cache-unified", NULL) && dc) {
 			seq_printf(m, " %dK unified", *dc / 1024);
 		} else {
 			if (ic)
@@ -244,12 +244,12 @@ static void __init l2cr_init(void)
 	/* Checks "l2cr-value" property in the registry */
 	if (cpu_has_feature(CPU_FTR_L2CR)) {
 		struct device_node *np = of_find_node_by_name(NULL, "cpus");
-		if (np == 0)
+		if (!np)
 			np = of_find_node_by_type(NULL, "cpu");
-		if (np != 0) {
+		if (np) {
 			const unsigned int *l2cr =
 				of_get_property(np, "l2cr-value", NULL);
-			if (l2cr != 0) {
+			if (l2cr) {
 				ppc_override_l2cr = 1;
 				ppc_override_l2cr_value = *l2cr;
 				_set_L2CR(0);

commit b7c670d673d1186e9a6aafaad36aace34046bb6b
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 21 10:16:47 2017 -0500

    powerpc: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Anatolij Gustschin <agust@denx.de>
    Cc: Scott Wood <oss@buserror.net>
    Cc: Kumar Gala <galak@kernel.crashing.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linuxppc-dev@lists.ozlabs.org
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 6b4e9d181126..ab668cb72263 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -556,7 +556,7 @@ static int __init check_pmac_serial_console(void)
 		pr_debug(" can't find stdout package %s !\n", name);
 		return -ENODEV;
 	}
-	pr_debug("stdout is %s\n", prom_stdout->full_name);
+	pr_debug("stdout is %pOF\n", prom_stdout);
 
 	name = of_get_property(prom_stdout, "name", NULL);
 	if (!name) {

commit bd721ea73e1f965569b40620538c942001f76294
Author: Fabian Frederick <fabf@skynet.be>
Date:   Tue Aug 2 14:03:33 2016 -0700

    treewide: replace obsolete _refok by __ref
    
    There was only one use of __initdata_refok and __exit_refok
    
    __init_refok was used 46 times against 82 for __ref.
    
    Those definitions are obsolete since commit 312b1485fb50 ("Introduce new
    section reference annotations tags: __ref, __refdata, __refconst")
    
    This patch removes the following compatibility definitions and replaces
    them treewide.
    
    /* compatibility defines */
    #define __init_refok     __ref
    #define __initdata_refok __refdata
    #define __exit_refok     __ref
    
    I can also provide separate patches if necessary.
    (One patch per tree and check in 1 month or 2 to remove old definitions)
    
    [akpm@linux-foundation.org: coding-style fixes]
    Link: http://lkml.kernel.org/r/1466796271-3043-1-git-send-email-fabf@skynet.be
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 3de4a7c85140..6b4e9d181126 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -353,12 +353,12 @@ static int pmac_late_init(void)
 machine_late_initcall(powermac, pmac_late_init);
 
 /*
- * This is __init_refok because we check for "initializing" before
+ * This is __ref because we check for "initializing" before
  * touching any of the __init sensitive things and "initializing"
  * will be false after __init time. This can't be __init because it
  * can be called whenever a disk is first accessed.
  */
-void __init_refok note_bootable_part(dev_t dev, int part, int goodness)
+void __ref note_bootable_part(dev_t dev, int part, int goodness)
 {
 	char *p;
 

commit f2d576948d6cec16e4aae201d738c4f22039a551
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:04:06 2016 +1000

    powerpc: Get rid of ppc_md.init_early()
    
    It is now called right after platform probe, so the probe function
    can just do the job.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 60ca40ac3519..3de4a7c85140 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -452,7 +452,7 @@ pmac_halt(void)
 /* 
  * Early initialization.
  */
-static void __init pmac_init_early(void)
+static void __init pmac_init(void)
 {
 	/* Enable early btext debug if requested */
 	if (strstr(boot_command_line, "btextdbg")) {
@@ -603,6 +603,8 @@ static int __init pmac_probe(void)
 
 	pm_power_off = pmac_power_off;
 
+	pmac_init();
+
 	return 1;
 }
 
@@ -610,7 +612,6 @@ define_machine(powermac) {
 	.name			= "PowerMac",
 	.probe			= pmac_probe,
 	.setup_arch		= pmac_setup_arch,
-	.init_early		= pmac_init_early,
 	.show_cpuinfo		= pmac_show_cpuinfo,
 	.init_IRQ		= pmac_pic_init,
 	.get_irq		= NULL,	/* changed later */

commit 565713840445b7ccafb28dc1230d57d40bcb42a5
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:04:05 2016 +1000

    powerpc: Move 32-bit probe() machine to later in the boot process
    
    This converts all the 32-bit platforms to use the expanded device-tree
    which is a pretty mechanical change. Unlike 64-bit, the 32-bit kernel
    didn't rely on platform initializations to setup the MMU since it
    sets it up entirely before probe_machine() so the move has comparatively
    less consequences though it's a bigger patch.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 0872f9837cf5..60ca40ac3519 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -590,17 +590,9 @@ console_initcall(check_pmac_serial_console);
  */
 static int __init pmac_probe(void)
 {
-#ifdef CONFIG_PPC32
-	unsigned long root = of_get_flat_dt_root();
-
-	if (!of_flat_dt_is_compatible(root, "Power Macintosh") &&
-	    !of_flat_dt_is_compatible(root, "MacRISC"))
-		return 0;
-#else
 	if (!of_machine_is_compatible("Power Macintosh") &&
 	    !of_machine_is_compatible("MacRISC"))
 		return 0;
-#endif
 
 #ifdef CONFIG_PPC32
 	/* isa_io_base gets set in pmac_pci_init */

commit 406b0b6ae3fcd5c7946a68a9e43b470c79d292a2
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:04:00 2016 +1000

    powerpc/64: Move 64-bit probe_machine() to later in the boot process
    
    We no long need the machine type that early, so we can move probe_machine()
    to after the device-tree has been expanded. This will allow further
    consolidation.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 8fffe1c4b6f5..0872f9837cf5 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -590,11 +590,17 @@ console_initcall(check_pmac_serial_console);
  */
 static int __init pmac_probe(void)
 {
+#ifdef CONFIG_PPC32
 	unsigned long root = of_get_flat_dt_root();
 
 	if (!of_flat_dt_is_compatible(root, "Power Macintosh") &&
 	    !of_flat_dt_is_compatible(root, "MacRISC"))
 		return 0;
+#else
+	if (!of_machine_is_compatible("Power Macintosh") &&
+	    !of_machine_is_compatible("MacRISC"))
+		return 0;
+#endif
 
 #ifdef CONFIG_PPC32
 	/* isa_io_base gets set in pmac_pci_init */

commit b521f576df6c49fcc06fbc06a349f7590f223a38
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:03:57 2016 +1000

    powerpc/pmac: Remove spurrious machine type test
    
    pmac_declare_of_platform_devices() is already a machine initcall, thus
    it won't be called on a non-powermac machine. Testing for chrp there
    is pointless.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 795bf8cfddd9..8fffe1c4b6f5 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -484,9 +484,6 @@ static int __init pmac_declare_of_platform_devices(void)
 {
 	struct device_node *np;
 
-	if (machine_is(chrp))
-		return -1;
-
 	np = of_find_node_by_name(NULL, "valkyrie");
 	if (np) {
 		of_platform_device_create(np, "valkyrie", NULL);

commit 166dd7d3fbf2df183926f0e4b4855f6cbd8da945
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:03:51 2016 +1000

    powerpc/64: Move MMU backend selection out of platform code
    
    We move it into early_mmu_init() based on firmware features. For PS3,
    we have to move the setting of these into early_init_devtree().
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 4ad61687c670..795bf8cfddd9 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -599,10 +599,6 @@ static int __init pmac_probe(void)
 	    !of_flat_dt_is_compatible(root, "MacRISC"))
 		return 0;
 
-#ifdef CONFIG_PPC64
-	hpte_init_native();
-#endif
-
 #ifdef CONFIG_PPC32
 	/* isa_io_base gets set in pmac_pci_init */
 	ISA_DMA_THRESHOLD = ~0L;

commit 91b6fad5cf16c5fcf0ab2a08fcdbd1483d871d43
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:03:50 2016 +1000

    powerpc/pmac: Remove early allocation of the SMU command buffer
    
    The SMU command buffer needs to be allocated below 2G using memblock.
    
    In the past, this had to be done very early from the arch code as
    memblock wasn't available past that point. That is no longer the
    case though, smu_init() is called from setup_arch() when memblock
    is still functional these days. So move the allocation to the
    SMU driver itself.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index fc0b69f6e3d4..4ad61687c670 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -52,7 +52,6 @@
 #include <linux/suspend.h>
 #include <linux/of_device.h>
 #include <linux/of_platform.h>
-#include <linux/memblock.h>
 
 #include <asm/reg.h>
 #include <asm/sections.h>
@@ -97,11 +96,6 @@ int sccdbg;
 sys_ctrler_t sys_ctrler = SYS_CTRLER_UNKNOWN;
 EXPORT_SYMBOL(sys_ctrler);
 
-#ifdef CONFIG_PMAC_SMU
-unsigned long smu_cmdbuf_abs;
-EXPORT_SYMBOL(smu_cmdbuf_abs);
-#endif
-
 static void pmac_show_cpuinfo(struct seq_file *m)
 {
 	struct device_node *np;
@@ -325,7 +319,6 @@ static void __init pmac_setup_arch(void)
     defined(CONFIG_PPC64)
 	pmac_nvram_init();
 #endif
-
 #ifdef CONFIG_PPC32
 #ifdef CONFIG_BLK_DEV_INITRD
 	if (initrd_start)
@@ -617,15 +610,6 @@ static int __init pmac_probe(void)
 	DMA_MODE_WRITE = 2;
 #endif /* CONFIG_PPC32 */
 
-#ifdef CONFIG_PMAC_SMU
-	/*
-	 * SMU based G5s need some memory below 2Gb, at least the current
-	 * driver needs that. We have to allocate it now. We allocate 4k
-	 * (1 small page) for now.
-	 */
-	smu_cmdbuf_abs = memblock_alloc_base(4096, 4096, 0x80000000UL);
-#endif /* CONFIG_PMAC_SMU */
-
 	pm_power_off = pmac_power_off;
 
 	return 1;

commit c40785ad305b32e9b0b5fbc888f1f5d57f29bf44
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:03:47 2016 +1000

    powerpc/dart: Use a cachable DART
    
    Instead of punching a hole in the linear mapping, just use normal
    cachable memory, and apply the flush sequence documented in the
    CPC625 (aka U3) user manual.
    
    This allows us to remove quite a bit of code related to the early
    allocation of the DART and the hole in the linear mapping. We can
    also get rid of the copy of the DART for suspend/resume as the
    original memory can just be saved/restored now, as long as we
    properly sync the caches.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    [mpe: Integrate dart_init() fix to return ENODEV when DART disabled]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index bd83b52c9830..fc0b69f6e3d4 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -607,14 +607,6 @@ static int __init pmac_probe(void)
 		return 0;
 
 #ifdef CONFIG_PPC64
-	/*
-	 * On U3, the DART (iommu) must be allocated now since it
-	 * has an impact on htab_initialize (due to the large page it
-	 * occupies having to be broken up so the DART itself is not
-	 * part of the cacheable linar mapping
-	 */
-	alloc_dart_table();
-
 	hpte_init_native();
 #endif
 

commit 95ec77c06e8e63fff50c497eca0668bf6da39813
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Jul 12 10:54:52 2016 +1000

    powerpc: Make ppc_md.{halt, restart} __noreturn
    
    powernv marks it's halt and restart calls as __noreturn. However,
    ppc_md does not have this annotation. Add the annotation to ppc_md,
    and then to every halt/restart function that is missing it.
    
    Additionally, I have verified that all of these functions do not
    return. Occasionally I have added a spin loop to be sure.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 8dd78f4e1af4..bd83b52c9830 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -383,7 +383,7 @@ void __init_refok note_bootable_part(dev_t dev, int part, int goodness)
 }
 
 #ifdef CONFIG_ADB_CUDA
-static void cuda_restart(void)
+static void __noreturn cuda_restart(void)
 {
 	struct adb_request req;
 
@@ -392,7 +392,7 @@ static void cuda_restart(void)
 		cuda_poll();
 }
 
-static void cuda_shutdown(void)
+static void __noreturn cuda_shutdown(void)
 {
 	struct adb_request req;
 
@@ -416,7 +416,7 @@ static void cuda_shutdown(void)
 #define smu_shutdown()
 #endif
 
-static void pmac_restart(char *cmd)
+static void __noreturn pmac_restart(char *cmd)
 {
 	switch (sys_ctrler) {
 	case SYS_CTRLER_CUDA:
@@ -430,9 +430,10 @@ static void pmac_restart(char *cmd)
 		break;
 	default: ;
 	}
+	while (1) ;
 }
 
-static void pmac_power_off(void)
+static void __noreturn pmac_power_off(void)
 {
 	switch (sys_ctrler) {
 	case SYS_CTRLER_CUDA:
@@ -446,9 +447,10 @@ static void pmac_power_off(void)
 		break;
 	default: ;
 	}
+	while (1) ;
 }
 
-static void
+static void __noreturn
 pmac_halt(void)
 {
 	pmac_power_off();

commit e63f26d3757fb8c00116b7f7c75d2a2e15bb5549
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Mar 31 16:00:49 2015 +1100

    powerpc/powermac: Move controller ops from ppc_md to controller_ops
    
    This moves the Power Mac platform to use the pci_controller_ops
    structure rather than ppc_md for PCI controller operations.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 71a353c07d0c..8dd78f4e1af4 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -473,7 +473,7 @@ static void __init pmac_init_early(void)
 	udbg_adb_init(!!strstr(boot_command_line, "btextdbg"));
 
 #ifdef CONFIG_PPC64
-	iommu_init_early_dart(NULL);
+	iommu_init_early_dart(&pmac_pci_controller_ops);
 #endif
 
 	/* SMP Init has to be done early as we need to patch up
@@ -656,12 +656,10 @@ define_machine(powermac) {
 	.feature_call		= pmac_do_feature_call,
 	.progress		= udbg_progress,
 #ifdef CONFIG_PPC64
-	.pci_probe_mode		= pmac_pci_probe_mode,
 	.power_save		= power4_idle,
 	.enable_pmcs		= power4_enable_pmcs,
 #endif /* CONFIG_PPC64 */
 #ifdef CONFIG_PPC32
-	.pcibios_enable_device_hook = pmac_pci_enable_device_hook,
 	.pcibios_after_init	= pmac_pcibios_after_init,
 	.phys_mem_access_prot	= pci_phys_mem_access_prot,
 #endif

commit 798248a3c083a4cf0ead44a85e66c6a18647abea
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Mar 31 16:00:48 2015 +1100

    powerpc: dart_iommu: optionally populate controller_ops on init
    
    If a pci_controller_ops struct is provided to iommu_init_early_dart,
    populate that with the DMA setup ops, rather than ppc_md. If NULL is
    provided, populate ppc_md as before.
    
    This also patches the call sites for Maple and Power Mac to pass
    NULL, so existing behaviour is preserved.
    
    The benefit of making this optional is that it means we don't have
    to change dart, Maple and Power Mac over to the controller_ops
    system in one fell swoop.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index efe172db5f8e..71a353c07d0c 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -473,7 +473,7 @@ static void __init pmac_init_early(void)
 	udbg_adb_init(!!strstr(boot_command_line, "btextdbg"));
 
 #ifdef CONFIG_PPC64
-	iommu_init_early_dart();
+	iommu_init_early_dart(NULL);
 #endif
 
 	/* SMP Init has to be done early as we need to patch up

commit ba9c8f227358bcbc80fca19e7a339883cbc956a5
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Mar 31 16:00:40 2015 +1100

    powerpc/powermac: move pmac_pci_probe_mode from setup.c to pci.c
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 713d36d45d1d..efe172db5f8e 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -637,24 +637,6 @@ static int __init pmac_probe(void)
 	return 1;
 }
 
-#ifdef CONFIG_PPC64
-/* Move that to pci.c */
-static int pmac_pci_probe_mode(struct pci_bus *bus)
-{
-	struct device_node *node = pci_bus_to_OF_node(bus);
-
-	/* We need to use normal PCI probing for the AGP bus,
-	 * since the device for the AGP bridge isn't in the tree.
-	 * Same for the PCIe host on U4 and the HT host bridge.
-	 */
-	if (bus->self == NULL && (of_device_is_compatible(node, "u3-agp") ||
-				  of_device_is_compatible(node, "u4-pcie") ||
-				  of_device_is_compatible(node, "u3-ht")))
-		return PCI_PROBE_NORMAL;
-	return PCI_PROBE_DEVTREE;
-}
-#endif /* CONFIG_PPC64 */
-
 define_machine(powermac) {
 	.name			= "PowerMac",
 	.probe			= pmac_probe,

commit 9178ba294b6839eeff1a91bed95515d783f3ee6c
Author: Alexander Graf <agraf@suse.de>
Date:   Mon Oct 13 16:01:09 2014 +0200

    powerpc: Convert power off logic to pm_power_off
    
    The generic Linux framework to power off the machine is a function pointer
    called pm_power_off. The trick about this pointer is that device drivers can
    potentially implement it rather than board files.
    
    Today on powerpc we set pm_power_off to invoke our generic full machine power
    off logic which then calls ppc_md.power_off to invoke machine specific power
    off.
    
    However, when we want to add a power off GPIO via the "gpio-poweroff" driver,
    this card house falls apart. That driver only registers itself if pm_power_off
    is NULL to ensure it doesn't override board specific logic. However, since we
    always set pm_power_off to the generic power off logic (which will just not
    power off the machine if no ppc_md.power_off call is implemented), we can't
    implement power off via the generic GPIO power off driver.
    
    To fix this up, let's get rid of the ppc_md.power_off logic and just always use
    pm_power_off as was intended. Then individual drivers such as the GPIO power off
    driver can implement power off logic via that function pointer.
    
    With this patch set applied and a few patches on top of QEMU that implement a
    power off GPIO on the virt e500 machine, I can successfully turn off my virtual
    machine after halt.
    
    Signed-off-by: Alexander Graf <agraf@suse.de>
    [mpe: Squash into one patch and update changelog based on cover letter]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index b127a29ac526..713d36d45d1d 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -632,6 +632,8 @@ static int __init pmac_probe(void)
 	smu_cmdbuf_abs = memblock_alloc_base(4096, 4096, 0x80000000UL);
 #endif /* CONFIG_PMAC_SMU */
 
+	pm_power_off = pmac_power_off;
+
 	return 1;
 }
 
@@ -663,7 +665,6 @@ define_machine(powermac) {
 	.get_irq		= NULL,	/* changed later */
 	.pci_irq_fixup		= pmac_pci_irq_fixup,
 	.restart		= pmac_restart,
-	.power_off		= pmac_power_off,
 	.halt			= pmac_halt,
 	.time_init		= pmac_time_init,
 	.get_boot_time		= pmac_get_boot_time,

commit 3e47d1474c2b4099f0fadd12a6553fdb2e8feaae
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Sep 17 14:39:36 2014 +1000

    powerpc: Remove powerpc specific cmd_line
    
    There is no need for yet another copy of the command line, just
    use boot_command_line like everyone else.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 141f8899a633..b127a29ac526 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -336,7 +336,7 @@ static void __init pmac_setup_arch(void)
 #endif
 
 #ifdef CONFIG_ADB
-	if (strstr(cmd_line, "adb_sync")) {
+	if (strstr(boot_command_line, "adb_sync")) {
 		extern int __adb_probe_sync;
 		__adb_probe_sync = 1;
 	}
@@ -460,7 +460,7 @@ pmac_halt(void)
 static void __init pmac_init_early(void)
 {
 	/* Enable early btext debug if requested */
-	if (strstr(cmd_line, "btextdbg")) {
+	if (strstr(boot_command_line, "btextdbg")) {
 		udbg_adb_init_early();
 		register_early_udbg_console();
 	}
@@ -469,8 +469,8 @@ static void __init pmac_init_early(void)
 	pmac_feature_init();
 
 	/* Initialize debug stuff */
-	udbg_scc_init(!!strstr(cmd_line, "sccdbg"));
-	udbg_adb_init(!!strstr(cmd_line, "btextdbg"));
+	udbg_scc_init(!!strstr(boot_command_line, "sccdbg"));
+	udbg_adb_init(!!strstr(boot_command_line, "btextdbg"));
 
 #ifdef CONFIG_PPC64
 	iommu_init_early_dart();

commit ae3a197e3d0bfe3f4bf1693723e82dc018c096f3
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for PowerPC
    
    Disintegrate asm/system.h for PowerPC.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    cc: linuxppc-dev@lists.ozlabs.org

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 970ea1de4298..141f8899a633 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -57,7 +57,6 @@
 #include <asm/reg.h>
 #include <asm/sections.h>
 #include <asm/prom.h>
-#include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/io.h>
 #include <asm/pci-bridge.h>

commit 3631cb83ddb13dee08923103e837130069a9944b
Author: Julia Lawall <julia@diku.dk>
Date:   Sun Aug 21 06:10:01 2011 +0000

    powerpc/powermac: Add missing of_node_put
    
    np is initialized to the result of calling a function that calls
    of_node_get, so of_node_put should be called before the pointer is dropped.
    
    The semantic match that finds this problem is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression e,e1,e2;
    @@
    
    * e = \(of_find_node_by_type\|of_find_node_by_name\)(...)
      ... when != of_node_put(e)
          when != true e == NULL
          when != e2 = e
      e = e1
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 96580b189ec2..970ea1de4298 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -494,11 +494,15 @@ static int __init pmac_declare_of_platform_devices(void)
 		return -1;
 
 	np = of_find_node_by_name(NULL, "valkyrie");
-	if (np)
+	if (np) {
 		of_platform_device_create(np, "valkyrie", NULL);
+		of_node_put(np);
+	}
 	np = of_find_node_by_name(NULL, "platinum");
-	if (np)
+	if (np) {
 		of_platform_device_create(np, "platinum", NULL);
+		of_node_put(np);
+	}
         np = of_find_node_by_type(NULL, "smu");
         if (np) {
 		of_platform_device_create(np, "smu", NULL);

commit 66b15db69c2553036cc25f6e2e74fe7e3aa2761e
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 10:46:24 2011 -0400

    powerpc: add export.h to files making use of EXPORT_SYMBOL
    
    With module.h being implicitly everywhere via device.h, the absence
    of explicitly including something for EXPORT_SYMBOL went unnoticed.
    Since we are heading to fix things up and clean module.h from the
    device.h file, we need to explicitly include these files now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index a028f08309d6..96580b189ec2 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -31,6 +31,7 @@
 #include <linux/stddef.h>
 #include <linux/unistd.h>
 #include <linux/ptrace.h>
+#include <linux/export.h>
 #include <linux/user.h>
 #include <linux/tty.h>
 #include <linux/string.h>

commit 2773fcc8c48b947c997ff345f3e453917883cdb5
Author: Dave Carroll <dcarroll@astekcorp.com>
Date:   Sat Jun 18 07:36:39 2011 +0000

    powerpc: Move free_initmem to common code
    
    The free_initmem function is basically duplicated in mm/init_32,
    and init_64, and is moved to the common 32/64-bit mm/mem.c.
    
    All other sections except init were removed in v2.6.15 by
    6c45ab992e4299c869fb26427944a8f8ea177024 (powerpc: Remove section
    free() and linker script bits), and therefore the bulk of the executed
    code is identical.
    
    This patch also removes updating ppc_md.progress to NULL in the powermac
    late_initcall.
    
    Suggested-by: Milton Miller <miltonm@bga.com>
    Suggested-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Dave Carroll <dcarroll@astekcorp.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index aa45281bd296..a028f08309d6 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -355,9 +355,6 @@ static int initializing = 1;
 static int pmac_late_init(void)
 {
 	initializing = 0;
-	/* this is udbg (which is __init) and we can later use it during
-	 * cpu hotplug (in smp_core99_kick_cpu) */
-	ppc_md.progress = NULL;
 	return 0;
 }
 machine_late_initcall(powermac, pmac_late_init);

commit 4c6130d9bba78e7ac44584378660a1204c5297d1
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Feb 11 14:03:20 2011 +1100

    powerpc/pmac/smp: Consolidate 32-bit and 64-bit PowerMac cpu_die in one file
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index d5aceb7fb125..aa45281bd296 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -650,51 +650,6 @@ static int pmac_pci_probe_mode(struct pci_bus *bus)
 		return PCI_PROBE_NORMAL;
 	return PCI_PROBE_DEVTREE;
 }
-
-#ifdef CONFIG_HOTPLUG_CPU
-/* access per cpu vars from generic smp.c */
-DECLARE_PER_CPU(int, cpu_state);
-
-static void pmac64_cpu_die(void)
-{
-	/*
-	 * turn off as much as possible, we'll be
-	 * kicked out as this will only be invoked
-	 * on core99 platforms for now ...
-	 */
-
-	printk(KERN_INFO "CPU#%d offline\n", smp_processor_id());
-	__get_cpu_var(cpu_state) = CPU_DEAD;
-	smp_wmb();
-
-	/*
-	 * during the path that leads here preemption is disabled,
-	 * reenable it now so that when coming up preempt count is
-	 * zero correctly
-	 */
-	preempt_enable();
-
-	/*
-	 * hard-disable interrupts for the non-NAP case, the NAP code
-	 * needs to re-enable interrupts (but soft-disables them)
-	 */
-	hard_irq_disable();
-
-	while (1) {
-		/* let's not take timer interrupts too often ... */
-		set_dec(0x7fffffff);
-
-		/* should always be true at this point */
-		if (cpu_has_feature(CPU_FTR_CAN_NAP))
-			power4_cpu_offline_powersave();
-		else {
-			HMT_low();
-			HMT_very_low();
-		}
-	}
-}
-#endif /* CONFIG_HOTPLUG_CPU */
-
 #endif /* CONFIG_PPC64 */
 
 define_machine(powermac) {
@@ -726,15 +681,4 @@ define_machine(powermac) {
 	.pcibios_after_init	= pmac_pcibios_after_init,
 	.phys_mem_access_prot	= pci_phys_mem_access_prot,
 #endif
-#ifdef CONFIG_HOTPLUG_CPU
-#ifdef CONFIG_PPC64
-	.cpu_die		= pmac64_cpu_die,
-#endif
-#ifdef CONFIG_PPC32
-	.cpu_die		= pmac32_cpu_die,
-#endif
-#endif
-#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC32)
-	.cpu_die		= generic_mach_cpu_die,
-#endif
 };

commit 98b14d6b290d96b24ae993ceaccc59b2aa4b130c
Author: Marc Zyngier <maz@misterjones.org>
Date:   Sun Dec 5 05:05:37 2010 +0000

    powerpc/powermac: Make auto-loading of therm_pm72 possible
    
    The therm_pm72 driver, used on the PowerMac G5 range, cannot be
    auto-loaded, since the driver itself creates both the device node
    and the driver instance.
    
    Moving the device node creation to the platform setup code and
    adding the necessary MODULE_DEVICE_TABLE() information allows the
    driver to be automatically loaded by udev on any semi-modern
    distribution.
    
    It "fixes" a major source of problem on G5 machines where the
    driver wasn't explicitely loaded by default, and the system
    would automatically shutdown under load.
    
    Tested on an Xserve G5.
    
    Signed-off-by: Marc Zyngier <maz@misterjones.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 9deb274841f1..d5aceb7fb125 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -506,6 +506,15 @@ static int __init pmac_declare_of_platform_devices(void)
 		of_platform_device_create(np, "smu", NULL);
 		of_node_put(np);
 	}
+	np = of_find_node_by_type(NULL, "fcu");
+	if (np == NULL) {
+		/* Some machines have strangely broken device-tree */
+		np = of_find_node_by_path("/u3@0,f8000000/i2c@f8001000/fan@15e");
+	}
+	if (np) {
+		of_platform_device_create(np, "temperature", NULL);
+		of_node_put(np);
+	}
 
 	return 0;
 }

commit 95f72d1ed41a66f1c1c29c24d479de81a0bea36f
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jul 12 14:36:09 2010 +1000

    lmb: rename to memblock
    
    via following scripts
    
          FILES=$(find * -type f | grep -vE 'oprofile|[^K]config')
    
          sed -i \
            -e 's/lmb/memblock/g' \
            -e 's/LMB/MEMBLOCK/g' \
            $FILES
    
          for N in $(find . -name lmb.[ch]); do
            M=$(echo $N | sed 's/lmb/memblock/g')
            mv $N $M
          done
    
    and remove some wrong change like lmbench and dlmb etc.
    
    also move memblock.c from lib/ to mm/
    
    Suggested-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: "H. Peter Anvin" <hpa@zytor.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index f1d0132ebcc7..9deb274841f1 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -51,7 +51,7 @@
 #include <linux/suspend.h>
 #include <linux/of_device.h>
 #include <linux/of_platform.h>
-#include <linux/lmb.h>
+#include <linux/memblock.h>
 
 #include <asm/reg.h>
 #include <asm/sections.h>
@@ -619,7 +619,7 @@ static int __init pmac_probe(void)
 	 * driver needs that. We have to allocate it now. We allocate 4k
 	 * (1 small page) for now.
 	 */
-	smu_cmdbuf_abs = lmb_alloc_base(4096, 4096, 0x80000000UL);
+	smu_cmdbuf_abs = memblock_alloc_base(4096, 4096, 0x80000000UL);
 #endif /* CONFIG_PMAC_SMU */
 
 	return 1;

commit abb17f9c3a92c5acf30e749efdf0419b7f50a5b8
Author: Milton Miller <miltonm@bga.com>
Date:   Wed May 19 02:56:29 2010 +0000

    powerpc: Use common cpu_die (fixes SMP+SUSPEND build)
    
    Configuring a powerpc 32 bit kernel for both SMP and SUSPEND turns on
    CPU_HOTPLUG to enable disable_nonboot_cpus to be called by the common
    suspend code.  Previously the definition of cpu_die for ppc32 was in
    the powermac platform code, causing it to be undefined if that platform
    as not selected.
    
    arch/powerpc/kernel/built-in.o: In function 'cpu_idle':
    arch/powerpc/kernel/idle.c:98: undefined reference to 'cpu_die'
    
    Move the code from setup_64 to smp.c and rename the power mac
    versions to their specific names.
    
    Note that this does not setup the cpu_die pointers in either
    smp_ops (request a given cpu die) or ppc_md (make this cpu die),
    for other platforms but there are generic versions in smp.c.
    
    Reported-by: Matt Sealey <matt@genesi-usa.com>
    Reported-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Signed-off-by: Anton Vorontsov <avorontsov@mvista.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 47a2b4488557..f1d0132ebcc7 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -646,7 +646,7 @@ static int pmac_pci_probe_mode(struct pci_bus *bus)
 /* access per cpu vars from generic smp.c */
 DECLARE_PER_CPU(int, cpu_state);
 
-static void pmac_cpu_die(void)
+static void pmac64_cpu_die(void)
 {
 	/*
 	 * turn off as much as possible, we'll be
@@ -717,8 +717,13 @@ define_machine(powermac) {
 	.pcibios_after_init	= pmac_pcibios_after_init,
 	.phys_mem_access_prot	= pci_phys_mem_access_prot,
 #endif
-#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC64)
-	.cpu_die		= pmac_cpu_die,
+#ifdef CONFIG_HOTPLUG_CPU
+#ifdef CONFIG_PPC64
+	.cpu_die		= pmac64_cpu_die,
+#endif
+#ifdef CONFIG_PPC32
+	.cpu_die		= pmac32_cpu_die,
+#endif
 #endif
 #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC32)
 	.cpu_die		= generic_mach_cpu_die,

commit 828a69869ba266cabb486a6b59ea8643d56b33ce
Author: Anton Blanchard <anton@samba.org>
Date:   Mon Apr 26 15:32:44 2010 +0000

    powerpc/cpumask: Update some comments
    
    Since the *_map cpumask variants are deprecated, change the comments to
    instead refer to *_mask.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 15c2241f9c72..47a2b4488557 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -480,7 +480,7 @@ static void __init pmac_init_early(void)
 #endif
 
 	/* SMP Init has to be done early as we need to patch up
-	 * cpu_possible_map before interrupt stacks are allocated
+	 * cpu_possible_mask before interrupt stacks are allocated
 	 * or kaboom...
 	 */
 #ifdef CONFIG_SMP

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index c20522656367..15c2241f9c72 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -31,7 +31,6 @@
 #include <linux/stddef.h>
 #include <linux/unistd.h>
 #include <linux/ptrace.h>
-#include <linux/slab.h>
 #include <linux/user.h>
 #include <linux/tty.h>
 #include <linux/string.h>

commit 7ccbe504b5ee766d33211a507189a06f3079b29b
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Jun 18 23:30:07 2009 +0000

    powerpc/pmac: Fix issues with PowerMac "PowerSurge" SMP
    
    The old PowerSurge SMP (ie, dual or quad 604 machines) code has
    numerous issues in modern world.
    
    One is cpu_possible_map is set too late (the device-tree is bogus)
    so we fail to allocate the interrupt stacks and crash. Another
    problem is the fact the timebase is frozen by the bringup of the
    second CPU so the delays in the generic code will hang, we need
    to move some of the calling procedure to inside the powermac code.
    
    This makes it boot again for me
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 86f69a4eb49b..c20522656367 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -103,11 +103,6 @@ unsigned long smu_cmdbuf_abs;
 EXPORT_SYMBOL(smu_cmdbuf_abs);
 #endif
 
-#ifdef CONFIG_SMP
-extern struct smp_ops_t psurge_smp_ops;
-extern struct smp_ops_t core99_smp_ops;
-#endif /* CONFIG_SMP */
-
 static void pmac_show_cpuinfo(struct seq_file *m)
 {
 	struct device_node *np;
@@ -341,34 +336,6 @@ static void __init pmac_setup_arch(void)
 		ROOT_DEV = DEFAULT_ROOT_DEVICE;
 #endif
 
-#ifdef CONFIG_SMP
-	/* Check for Core99 */
-	ic = of_find_node_by_name(NULL, "uni-n");
-	if (!ic)
-		ic = of_find_node_by_name(NULL, "u3");
-	if (!ic)
-		ic = of_find_node_by_name(NULL, "u4");
-	if (ic) {
-		of_node_put(ic);
-		smp_ops = &core99_smp_ops;
-	}
-#ifdef CONFIG_PPC32
-	else {
-		/*
-		 * We have to set bits in cpu_possible_map here since the
-		 * secondary CPU(s) aren't in the device tree, and
-		 * setup_per_cpu_areas only allocates per-cpu data for
-		 * CPUs in the cpu_possible_map.
-		 */
-		int cpu;
-
-		for (cpu = 1; cpu < 4 && cpu < NR_CPUS; ++cpu)
-			cpu_set(cpu, cpu_possible_map);
-		smp_ops = &psurge_smp_ops;
-	}
-#endif
-#endif /* CONFIG_SMP */
-
 #ifdef CONFIG_ADB
 	if (strstr(cmd_line, "adb_sync")) {
 		extern int __adb_probe_sync;
@@ -512,6 +479,14 @@ static void __init pmac_init_early(void)
 #ifdef CONFIG_PPC64
 	iommu_init_early_dart();
 #endif
+
+	/* SMP Init has to be done early as we need to patch up
+	 * cpu_possible_map before interrupt stacks are allocated
+	 * or kaboom...
+	 */
+#ifdef CONFIG_SMP
+	pmac_setup_smp();
+#endif
 }
 
 static int __init pmac_declare_of_platform_devices(void)

commit 95272262aa43a85ad134c2ceeacb28e8b755ede1
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Thu Apr 30 03:10:13 2009 +0000

    powerpc/pci: Clean up direct access to sysdata by powermac platforms
    
    We shouldn't directly access sysdata to get the device node but call
    pci_bus_to_OF_node() for this purpose.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 45936c9ed0ec..86f69a4eb49b 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -655,7 +655,7 @@ static int __init pmac_probe(void)
 /* Move that to pci.c */
 static int pmac_pci_probe_mode(struct pci_bus *bus)
 {
-	struct device_node *node = bus->sysdata;
+	struct device_node *node = pci_bus_to_OF_node(bus);
 
 	/* We need to use normal PCI probing for the AGP bus,
 	 * since the device for the AGP bridge isn't in the tree.

commit 4c4ece3cf8391e842f2c67a4760885e0acb3a461
Author: Giuliano Pochini <pochini@shiny.it>
Date:   Sat Feb 21 12:21:25 2009 +0000

    powerpc/powermac: Hotplug /sys entries are missing
    
    On Wed, 18 Feb 2009 22:18:21 +0100
    Giuliano Pochini <pochini@shiny.it> wrote:
    
    Since 2.6.28, /sys/devices/system/cpu/cpu*/online don't exist anymore
    on 32-bit PowerMacs due to change in the generic powerpc code.
    
    Signed-off-by: Giuliano Pochini <pochini@shiny.it>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 9b78f5300c24..45936c9ed0ec 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -746,4 +746,7 @@ define_machine(powermac) {
 #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC64)
 	.cpu_die		= pmac_cpu_die,
 #endif
+#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC32)
+	.cpu_die		= generic_mach_cpu_die,
+#endif
 };

commit 5be8554875bf3a1a42b7f04d5999b36e7c2fa88b
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Dec 16 06:23:08 2008 +0000

    powerpc: Remove default kexec/crash_kernel ops assignments
    
    Default ops are implicit now.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 12937725f869..9b78f5300c24 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -60,7 +60,6 @@
 #include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/io.h>
-#include <asm/kexec.h>
 #include <asm/pci-bridge.h>
 #include <asm/ohare.h>
 #include <asm/mediabay.h>
@@ -738,11 +737,6 @@ define_machine(powermac) {
 	.pci_probe_mode		= pmac_pci_probe_mode,
 	.power_save		= power4_idle,
 	.enable_pmcs		= power4_enable_pmcs,
-#ifdef CONFIG_KEXEC
-	.machine_kexec		= default_machine_kexec,
-	.machine_kexec_prepare	= default_machine_kexec_prepare,
-	.machine_crash_shutdown	= default_machine_crash_shutdown,
-#endif
 #endif /* CONFIG_PPC64 */
 #ifdef CONFIG_PPC32
 	.pcibios_enable_device_hook = pmac_pci_enable_device_hook,

commit 22059a90b82d6cd02d488c48c27a4d0ad976c919
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Wed Nov 12 18:20:43 2008 +0000

    powerpc/pmac: Use of_find_node_with_property() in pmac_setup_arch()
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 82c14d203d8b..12937725f869 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -310,9 +310,7 @@ static void __init pmac_setup_arch(void)
 	}
 
 	/* See if newworld or oldworld */
-	for (ic = NULL; (ic = of_find_all_nodes(ic)) != NULL; )
-		if (of_get_property(ic, "interrupt-controller", NULL))
-			break;
+	ic = of_find_node_with_property(NULL, "interrupt-controller");
 	if (ic) {
 		pmac_newworld = 1;
 		of_node_put(ic);

commit 9d5a9e74655b9d04d0ec9c8e47801163b7b74211
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Jun 28 00:12:52 2008 +0300

    Remove asm/a.out.h files for all architectures without a.out support.
    
    This patch also includes the required removal of (unused) inclusion of
    <asm/a.out.h> <linux/a.out.h>'s in the arch/ code for these
    architectures.
    
    [dwmw2: updated for 2.6.27-rc]
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 88ccf3a08a9c..82c14d203d8b 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -33,7 +33,6 @@
 #include <linux/ptrace.h>
 #include <linux/slab.h>
 #include <linux/user.h>
-#include <linux/a.out.h>
 #include <linux/tty.h>
 #include <linux/string.h>
 #include <linux/delay.h>

commit 025d7917a5ede982a5669c6735ef73a227b9827e
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jul 28 13:49:15 2008 +1000

    powerpc/powermac: Fixup default serial port device for pmac_zilog
    
    This removes the non-working code in legacy_serial that tried to handle
    the powermac SCC ports, and instead add a (now working) function to the
    powermac platform code to find the default serial console if any.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 31635446901a..88ccf3a08a9c 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -541,6 +541,78 @@ static int __init pmac_declare_of_platform_devices(void)
 }
 machine_device_initcall(powermac, pmac_declare_of_platform_devices);
 
+#ifdef CONFIG_SERIAL_PMACZILOG_CONSOLE
+/*
+ * This is called very early, as part of console_init() (typically just after
+ * time_init()). This function is respondible for trying to find a good
+ * default console on serial ports. It tries to match the open firmware
+ * default output with one of the available serial console drivers.
+ */
+static int __init check_pmac_serial_console(void)
+{
+	struct device_node *prom_stdout = NULL;
+	int offset = 0;
+	const char *name;
+#ifdef CONFIG_SERIAL_PMACZILOG_TTYS
+	char *devname = "ttyS";
+#else
+	char *devname = "ttyPZ";
+#endif
+
+	pr_debug(" -> check_pmac_serial_console()\n");
+
+	/* The user has requested a console so this is already set up. */
+	if (strstr(boot_command_line, "console=")) {
+		pr_debug(" console was specified !\n");
+		return -EBUSY;
+	}
+
+	if (!of_chosen) {
+		pr_debug(" of_chosen is NULL !\n");
+		return -ENODEV;
+	}
+
+	/* We are getting a weird phandle from OF ... */
+	/* ... So use the full path instead */
+	name = of_get_property(of_chosen, "linux,stdout-path", NULL);
+	if (name == NULL) {
+		pr_debug(" no linux,stdout-path !\n");
+		return -ENODEV;
+	}
+	prom_stdout = of_find_node_by_path(name);
+	if (!prom_stdout) {
+		pr_debug(" can't find stdout package %s !\n", name);
+		return -ENODEV;
+	}
+	pr_debug("stdout is %s\n", prom_stdout->full_name);
+
+	name = of_get_property(prom_stdout, "name", NULL);
+	if (!name) {
+		pr_debug(" stdout package has no name !\n");
+		goto not_found;
+	}
+
+	if (strcmp(name, "ch-a") == 0)
+		offset = 0;
+	else if (strcmp(name, "ch-b") == 0)
+		offset = 1;
+	else
+		goto not_found;
+	of_node_put(prom_stdout);
+
+	pr_debug("Found serial console at %s%d\n", devname, offset);
+
+	return add_preferred_console(devname, offset, NULL);
+
+ not_found:
+	pr_debug("No preferred console found !\n");
+	of_node_put(prom_stdout);
+	return -ENODEV;
+}
+console_initcall(check_pmac_serial_console);
+
+#endif /* CONFIG_SERIAL_PMACZILOG_CONSOLE */
+
 /*
  * Called very early, MMU is off, device-tree isn't unflattened
  */

commit 17ce452f7ea3df760b7f9f42453b6f6acd765217
Author: Jason Wessel <jason.wessel@windriver.com>
Date:   Wed Jul 23 11:30:15 2008 -0500

    kgdb, powerpc: arch specific powerpc kgdb support
    
    This patch removes the old kgdb reminants from ARCH=powerpc and
    implements the new style arch specific stub for the common kgdb core
    interface.
    
    It is possible to have xmon and kgdb in the same kernel, but you
    cannot use both at the same time because there is only one set of
    debug hooks.
    
    The arch specific kgdb implementation saves the previous state of the
    debug hooks and restores them if you unconfigure the kgdb I/O driver.
    Kgdb should have no impact on a kernel that has no kgdb I/O driver
    configured.
    
    Signed-off-by: Jason Wessel <jason.wessel@windriver.com>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 00bd0166d07f..31635446901a 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -97,8 +97,6 @@ extern struct machdep_calls pmac_md;
 int sccdbg;
 #endif
 
-extern void zs_kgdb_hook(int tty_num);
-
 sys_ctrler_t sys_ctrler = SYS_CTRLER_UNKNOWN;
 EXPORT_SYMBOL(sys_ctrler);
 
@@ -329,10 +327,6 @@ static void __init pmac_setup_arch(void)
 	l2cr_init();
 #endif /* CONFIG_PPC32 */
 
-#ifdef CONFIG_KGDB
-	zs_kgdb_hook(0);
-#endif
-
 	find_via_cuda();
 	find_via_pmu();
 	smu_init();

commit 21e38dfee53a2159d14a24a3d2277ae757599efa
Author: Tony Breeds <tony@bakeyournoodle.com>
Date:   Tue Apr 29 11:42:32 2008 +1000

    [POWERPC] Fix building of pmac32 when CONFIG_NVRAM=m
    
    Kamalesh Babulal (kamalesh@linux.vnet.ibm.com) reports that CONFIG_NVRAM=m
    is valid in terms of Kconfig but fails to build with:
      Building modules, stage 2.
      MODPOST 1401 modules
    ERROR: "pmac_newworld" [arch/powerpc/platforms/powermac/nvram.ko] undefined!
    ERROR: "__alloc_bootmem" [arch/powerpc/platforms/powermac/nvram.ko] undefined!
    make[1]: *** [__modpost] Error
    
    The arch/powerpc/platforms/powermac/nvram.c code really needs to be
    builtin, but as its compilation is dependent on a generic Kconfig
    symbol we force nvram.c to be builtin if CONFIG_NVRAM is 'y' or 'm'.
    
    Signed-off-by: Tony Breeds <tony@bakeyournoodle.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index bf44c5441a36..00bd0166d07f 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -337,7 +337,8 @@ static void __init pmac_setup_arch(void)
 	find_via_pmu();
 	smu_init();
 
-#if defined(CONFIG_NVRAM) || defined(CONFIG_PPC64)
+#if defined(CONFIG_NVRAM) || defined(CONFIG_NVRAM_MODULE) || \
+    defined(CONFIG_PPC64)
 	pmac_nvram_init();
 #endif
 

commit 9a64388d83f6ef08dfff405a9d122e3dbcb6bf38
Merge: e80ab411e589 14b3ca4022f0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 21 15:50:49 2008 -0700

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc
    
    * 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc: (202 commits)
      [POWERPC] Fix compile breakage for 64-bit UP configs
      [POWERPC] Define copy_siginfo_from_user32
      [POWERPC] Add compat handler for PTRACE_GETSIGINFO
      [POWERPC] i2c: Fix build breakage introduced by OF helpers
      [POWERPC] Optimize fls64() on 64-bit processors
      [POWERPC] irqtrace support for 64-bit powerpc
      [POWERPC] Stacktrace support for lockdep
      [POWERPC] Move stackframe definitions to common header
      [POWERPC] Fix device-tree locking vs. interrupts
      [POWERPC] Make pci_bus_to_host()'s struct pci_bus * argument const
      [POWERPC] Remove unused __max_memory variable
      [POWERPC] Simplify xics direct/lpar irq_host setup
      [POWERPC] Use pseries_setup_i8259_cascade() in pseries_mpic_init_IRQ()
      [POWERPC] Turn xics_setup_8259_cascade() into a generic pseries_setup_i8259_cascade()
      [POWERPC] Move xics_setup_8259_cascade() into platforms/pseries/setup.c
      [POWERPC] Use asm-generic/bitops/find.h in bitops.h
      [POWERPC] 83xx: mpc8315 - fix USB UTMI Host setup
      [POWERPC] 85xx: Fix the size of qe muram for MPC8568E
      [POWERPC] 86xx: mpc86xx_hpcn - Temporarily accept old dts node identifier.
      [POWERPC] 86xx: mark functions static, other minor cleanups
      ...

commit 5c58666fae58cd69f862beaeb88d293ad00f6e37
Author: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
Date:   Fri Apr 18 00:46:29 2008 +0200

    ppc/pmac: remove ppc_ide_md hooks
    
    * Add pmac_ide_init_ports() helper and use it instead of
      pmac_ide_init_hwif_ports().
    
    * Remove ppc_ide_md hooks - no need for them
      (IDE pmac host driver takes care of all this setup).
    
    * Then remove no longer needed <linux/ide.h> include
      from arch/powerpc/platforms/powermac/pmac.h.
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 36ff1b6b7fac..2693fc371eab 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -574,14 +574,6 @@ static int __init pmac_probe(void)
 	ISA_DMA_THRESHOLD = ~0L;
 	DMA_MODE_READ = 1;
 	DMA_MODE_WRITE = 2;
-
-#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
-#ifdef CONFIG_BLK_DEV_IDE_PMAC
-        ppc_ide_md.ide_init_hwif	= pmac_ide_init_hwif_ports;
-        ppc_ide_md.default_io_base	= pmac_ide_get_base;
-#endif /* CONFIG_BLK_DEV_IDE_PMAC */
-#endif /* defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE) */
-
 #endif /* CONFIG_PPC32 */
 
 #ifdef CONFIG_PMAC_SMU

commit d9b2b2a277219d4812311d995054ce4f95067725
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Feb 13 16:56:49 2008 -0800

    [LIB]: Make PowerPC LMB code generic so sparc64 can use it too.
    
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 36ff1b6b7fac..59404baf911f 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -53,6 +53,7 @@
 #include <linux/suspend.h>
 #include <linux/of_device.h>
 #include <linux/of_platform.h>
+#include <linux/lmb.h>
 
 #include <asm/reg.h>
 #include <asm/sections.h>
@@ -74,7 +75,6 @@
 #include <asm/iommu.h>
 #include <asm/smu.h>
 #include <asm/pmc.h>
-#include <asm/lmb.h>
 #include <asm/udbg.h>
 
 #include "pmac.h"

commit d518b71784c6fa4c8eafb334236883f763f8e296
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jan 3 06:14:28 2008 +1100

    [POWERPC] powermac: Use machine_*_initcall() hooks in platform code
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index adad4e976381..36ff1b6b7fac 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -397,17 +397,13 @@ static int initializing = 1;
 
 static int pmac_late_init(void)
 {
-	if (!machine_is(powermac))
-		return -ENODEV;
-
 	initializing = 0;
 	/* this is udbg (which is __init) and we can later use it during
 	 * cpu hotplug (in smp_core99_kick_cpu) */
 	ppc_md.progress = NULL;
 	return 0;
 }
-
-late_initcall(pmac_late_init);
+machine_late_initcall(powermac, pmac_late_init);
 
 /*
  * This is __init_refok because we check for "initializing" before
@@ -534,9 +530,6 @@ static int __init pmac_declare_of_platform_devices(void)
 	if (machine_is(chrp))
 		return -1;
 
-	if (!machine_is(powermac))
-		return 0;
-
 	np = of_find_node_by_name(NULL, "valkyrie");
 	if (np)
 		of_platform_device_create(np, "valkyrie", NULL);
@@ -551,8 +544,7 @@ static int __init pmac_declare_of_platform_devices(void)
 
 	return 0;
 }
-
-device_initcall(pmac_declare_of_platform_devices);
+machine_device_initcall(powermac, pmac_declare_of_platform_devices);
 
 /*
  * Called very early, MMU is off, device-tree isn't unflattened

commit 05ead01554f876b030f4745b2d58db3e53f76ca9
Author: Lucas Woods <woodzy@gmail.com>
Date:   Thu Dec 13 15:56:06 2007 -0800

    [POWERPC] arch/powerpc: Remove duplicate includes
    
    Signed-off-by: Lucas Woods <woodzy@gmail.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 869ca45cf919..adad4e976381 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -94,7 +94,6 @@ extern struct machdep_calls pmac_md;
 #define DEFAULT_ROOT_DEVICE Root_SDA1	/* sda1 - slightly silly choice */
 
 #ifdef CONFIG_PPC64
-#include <asm/udbg.h>
 int sccdbg;
 #endif
 

commit 444532d44aa6bc4d6e3ca74d8ad99c36f3b4d9f0
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Dec 20 14:55:01 2007 +1100

    [POWERPC] Enable self-view of the HT host bridge on PowerMac G5
    
    This enables the PCI code to see the device that represents the
    HT host bridge on the PowerMac G5.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 3acb59d5cdf5..869ca45cf919 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -613,9 +613,11 @@ static int pmac_pci_probe_mode(struct pci_bus *bus)
 
 	/* We need to use normal PCI probing for the AGP bus,
 	 * since the device for the AGP bridge isn't in the tree.
+	 * Same for the PCIe host on U4 and the HT host bridge.
 	 */
 	if (bus->self == NULL && (of_device_is_compatible(node, "u3-agp") ||
-				  of_device_is_compatible(node, "u4-pcie")))
+				  of_device_is_compatible(node, "u4-pcie") ||
+				  of_device_is_compatible(node, "u3-ht")))
 		return PCI_PROBE_NORMAL;
 	return PCI_PROBE_DEVTREE;
 }

commit 5f867dc7989023935317d0dc5c04215ea0592bfc
Author: Jon Loeliger <jdl@freescale.com>
Date:   Wed Nov 14 04:13:03 2007 +1100

    [POWERPC] Clean out asm/of_{platform, device}.h
    
    Convert #include of asm/of_{platform, device}.h into
    linux/of_{platform,device}.h for a few scattered platforms.
    
    Signed-off-by: Jon Loeliger <jdl@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 02c533096627..3acb59d5cdf5 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -51,6 +51,8 @@
 #include <linux/root_dev.h>
 #include <linux/bitops.h>
 #include <linux/suspend.h>
+#include <linux/of_device.h>
+#include <linux/of_platform.h>
 
 #include <asm/reg.h>
 #include <asm/sections.h>
@@ -68,8 +70,6 @@
 #include <asm/btext.h>
 #include <asm/pmac_feature.h>
 #include <asm/time.h>
-#include <asm/of_device.h>
-#include <asm/of_platform.h>
 #include <asm/mmu_context.h>
 #include <asm/iommu.h>
 #include <asm/smu.h>

commit 6ee0d9f744d4417f20aabd9a4e40fac93f2c9d76
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Oct 4 13:47:06 2007 +1000

    [POWERPC] Remove unused old code from powermac setup code
    
    Since bootdevice never gets initialized, it's always NULL, and hence a
    whole pile of code in arch/powerpc/platforms/setup.c never gets used.
    (This was the code that originally was there so that the automatic
    root partition selection mechanism would prefer a rootish-looking
    partition on the device that OF loaded the kernel from over a similar
    partition on other devices.)
    
    This removes the unused code.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 840f5b45384d..02c533096627 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -387,69 +387,13 @@ static void __init pmac_setup_arch(void)
 #endif /* CONFIG_ADB */
 }
 
-char *bootpath;
-char *bootdevice;
-void *boot_host;
-int boot_target;
-int boot_part;
-static dev_t boot_dev;
-
 #ifdef CONFIG_SCSI
 void note_scsi_host(struct device_node *node, void *host)
 {
-	int l;
-	char *p;
-
-	l = strlen(node->full_name);
-	if (bootpath != NULL && bootdevice != NULL
-	    && strncmp(node->full_name, bootdevice, l) == 0
-	    && (bootdevice[l] == '/' || bootdevice[l] == 0)) {
-		boot_host = host;
-		/*
-		 * There's a bug in OF 1.0.5.  (Why am I not surprised.)
-		 * If you pass a path like scsi/sd@1:0 to canon, it returns
-		 * something like /bandit@F2000000/gc@10/53c94@10000/sd@0,0
-		 * That is, the scsi target number doesn't get preserved.
-		 * So we pick the target number out of bootpath and use that.
-		 */
-		p = strstr(bootpath, "/sd@");
-		if (p != NULL) {
-			p += 4;
-			boot_target = simple_strtoul(p, NULL, 10);
-			p = strchr(p, ':');
-			if (p != NULL)
-				boot_part = simple_strtoul(p + 1, NULL, 10);
-		}
-	}
 }
 EXPORT_SYMBOL(note_scsi_host);
 #endif
 
-#if defined(CONFIG_BLK_DEV_IDE) && defined(CONFIG_BLK_DEV_IDE_PMAC)
-static dev_t __init find_ide_boot(void)
-{
-	char *p;
-	int n;
-	dev_t __init pmac_find_ide_boot(char *bootdevice, int n);
-
-	if (bootdevice == NULL)
-		return 0;
-	p = strrchr(bootdevice, '/');
-	if (p == NULL)
-		return 0;
-	n = p - bootdevice;
-
-	return pmac_find_ide_boot(bootdevice, n);
-}
-#endif /* CONFIG_BLK_DEV_IDE && CONFIG_BLK_DEV_IDE_PMAC */
-
-static void __init find_boot_device(void)
-{
-#if defined(CONFIG_BLK_DEV_IDE) && defined(CONFIG_BLK_DEV_IDE_PMAC)
-	boot_dev = find_ide_boot();
-#endif
-}
-
 static int initializing = 1;
 
 static int pmac_late_init(void)
@@ -474,7 +418,6 @@ late_initcall(pmac_late_init);
  */
 void __init_refok note_bootable_part(dev_t dev, int part, int goodness)
 {
-	static int found_boot = 0;
 	char *p;
 
 	if (!initializing)
@@ -486,15 +429,8 @@ void __init_refok note_bootable_part(dev_t dev, int part, int goodness)
 	if (p != NULL && (p == boot_command_line || p[-1] == ' '))
 		return;
 
-	if (!found_boot) {
-		find_boot_device();
-		found_boot = 1;
-	}
-	if (!boot_dev || dev == boot_dev) {
-		ROOT_DEV = dev + part;
-		boot_dev = 0;
-		current_root_goodness = goodness;
-	}
+	ROOT_DEV = dev + part;
+	current_root_goodness = goodness;
 }
 
 #ifdef CONFIG_ADB_CUDA

commit d7418031cf10fe82e16aa2057a702a2d1dab6f4a
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Oct 4 12:00:28 2007 +1000

    [POWERPC] Remove some more section mismatch warnings
    
    WARNING: vmlinux.o(.text+0x2ff5c): Section mismatch: reference to .init.text:.pmac_find_ide_boot (between '.note_bootable_part' and '.note_scsi_host')
    
    >From holly_defconfig:
    WARNING: vmlinux.o(.text+0x164fe): Section mismatch: reference to .init.data:boot_command_line (between 'note_bootable_part' and 'find_via_pmu')
    WARNING: vmlinux.o(.text+0x16506): Section mismatch: reference to .init.data:boot_command_line (between 'note_bootable_part' and 'find_via_pmu')
    
    >From linkstation_defconfig:
    WARNING: vmlinux.o(.text+0x158fe): Section mismatch: reference to .init.data:boot_command_line (between 'note_bootable_part' and 'find_via_pmu')
    WARNING: vmlinux.o(.text+0x15906): Section mismatch: reference to .init.data:boot_command_line (between 'note_bootable_part' and 'find_via_pmu')
    
    >From mpc7448_hpc2_defconfig:
    WARNING: vmlinux.o(.text+0x1583e): Section mismatch: reference to .init.data:boot_command_line (between 'note_bootable_part' and 'find_via_pmu')
    WARNING: vmlinux.o(.text+0x15846): Section mismatch: reference to .init.data:boot_command_line (between 'note_bootable_part' and 'find_via_pmu')
    
    >From pmac32_defconfig:
    WARNING: vmlinux.o(.text+0x154ca): Section mismatch: reference to .init.data:boot_command_line (between 'note_bootable_part' and 'note_scsi_host')
    WARNING: vmlinux.o(.text+0x154d2): Section mismatch: reference to .init.data:boot_command_line (between 'note_bootable_part' and 'note_scsi_host')
    WARNING: vmlinux.o(.text+0x1553c): Section mismatch: reference to .init.text:pmac_find_ide_boot (between 'note_bootable_part' and 'note_scsi_host')
    
    >From ppc64_defconfig:
    WARNING: vmlinux.o(.text+0x3acdc): Section mismatch: reference to .init.text:.pmac_find_ide_boot (between '.note_bootable_part' and '.note_scsi_host')
    
    >From prpmc2800_defconfig:
    WARNING: vmlinux.o(.text+0x1611e): Section mismatch: reference to .init.data:boot_command_line (between 'note_bootable_part' and 'find_via_pmu')
    WARNING: vmlinux.o(.text+0x16126): Section mismatch: reference to .init.data:boot_command_line (between 'note_bootable_part' and 'find_via_pmu')
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 7ccb9236e8b4..840f5b45384d 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -466,8 +466,13 @@ static int pmac_late_init(void)
 
 late_initcall(pmac_late_init);
 
-/* can't be __init - can be called whenever a disk is first accessed */
-void note_bootable_part(dev_t dev, int part, int goodness)
+/*
+ * This is __init_refok because we check for "initializing" before
+ * touching any of the __init sensitive things and "initializing"
+ * will be false after __init time. This can't be __init because it
+ * can be called whenever a disk is first accessed.
+ */
+void __init_refok note_bootable_part(dev_t dev, int part, int goodness)
 {
 	static int found_boot = 0;
 	char *p;

commit c5f226c7e95bf318879fb6ae02fc0dfb0f6d408c
Author: Tony Breeds <tony@bakeyournoodle.com>
Date:   Wed Jun 20 15:17:29 2007 +1000

    [POWERPC] Fix powermac late initcall to only run on powermac
    
    Current ppc64_defconfig kernel fails to boot on iSeries, dying with:
    
    Unable to handle kernel paging request for data at address 0x00000000
    Faulting instruction address: 0xc00000000071b258
    Oops: Kernel access of bad area, sig: 11 [#1]
    SMP NR_CPUS=32 iSeries
    <snip>
    NIP [c00000000071b258] .iSeries_src_init+0x34/0x64
    LR [c000000000701bb4] .kernel_init+0x1fc/0x3bc
    Call Trace:
    [c000000007d0be30] [0000000000008000] 0x8000 (unreliable)
    [c000000007d0bea0] [c000000000701bb4] .kernel_init+0x1fc/0x3bc
    [c000000007d0bf90] [c0000000000262d4] .kernel_thread+0x4c/0x68
    Instruction dump:
    e922cba8 3880ffff 78840420 f8010010 f821ff91 60000000 e8090000 78095fe3
    4182002c e922cb58 e862cbb0 e9290140 <e8090000> f8410028 7c0903a6 e9690010
    Kernel panic - not syncing: Attempted to kill init!
    
    This happens because some powermac code unconditionally sets
    ppc_md.progress to NULL.  This patch makes sure the powermac late
    initcall is only run on powermac machines.
    
    Signed-off-by: Tony Breeds <tony@bakeyournoodle.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 956571526a57..7ccb9236e8b4 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -454,6 +454,9 @@ static int initializing = 1;
 
 static int pmac_late_init(void)
 {
+	if (!machine_is(powermac))
+		return -ENODEV;
+
 	initializing = 0;
 	/* this is udbg (which is __init) and we can later use it during
 	 * cpu hotplug (in smp_core99_kick_cpu) */

commit c63c4faa8cf055319c7ed557d2050c1c3776fac5
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Jun 7 22:42:19 2007 +1000

    [POWERPC] Fix per-cpu allocation on oldworld SMP powermacs
    
    The per-cpu area(a) for the secondary CPU(s) isn't getting allocated
    on old SMP powermacs that don't have the secondary CPU(s) listed in
    the device tree, as per-cpu areas are now only allocated for CPUs in
    the cpu_possible_map, and we aren't setting the bits for the secondary
    CPU(s) until smp_prepare_cpus(), which is after per-cpu allocation.
    Therefore this sets the bits for CPUs 1..3 in cpu_possible_map in
    pmac_setup_arch, so they get per-cpu data allocated.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 07b1c4ec428d..956571526a57 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -363,8 +363,19 @@ static void __init pmac_setup_arch(void)
 		smp_ops = &core99_smp_ops;
 	}
 #ifdef CONFIG_PPC32
-	else
+	else {
+		/*
+		 * We have to set bits in cpu_possible_map here since the
+		 * secondary CPU(s) aren't in the device tree, and
+		 * setup_per_cpu_areas only allocates per-cpu data for
+		 * CPUs in the cpu_possible_map.
+		 */
+		int cpu;
+
+		for (cpu = 1; cpu < 4 && cpu < NR_CPUS; ++cpu)
+			cpu_set(cpu, cpu_possible_map);
 		smp_ops = &psurge_smp_ops;
+	}
 #endif
 #endif /* CONFIG_SMP */
 

commit 405861a0429113f8e426092af09dd05ec6209410
Author: Li Yang <leoli@freescale.com>
Date:   Wed May 23 11:28:03 2007 +0800

    [POWERPC] Fix Section mismatch warnings
    
    This patch fix the following Section mismatch warnings in powerpc code.
    
    WARNING: arch/powerpc/platforms/built-in.o - Section mismatch: reference to .init.data:mv643xx_eth_pd_devs from .text between 'mv643xx_eth_add_pds' (at offset 0x9ed2) and 'gg2_read_config'
    WARNING: arch/powerpc/platforms/built-in.o - Section mismatch: reference to .init.data:mv643xx_eth_pd_devs from .text between 'mv643xx_eth_add_pds' (at offset 0x9ed6) and 'gg2_read_config'
    WARNING: arch/powerpc/platforms/built-in.o - Section mismatch: reference to .init.text:note_scsi_host from __ksymtab between '__ksymtab_note_scsi_host' (at offset 0x8) and '__ksymtab_sys_ctrler'
    
    Signed-off-by: Li Yang <leoli@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index a410bc76a8a8..07b1c4ec428d 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -384,7 +384,7 @@ int boot_part;
 static dev_t boot_dev;
 
 #ifdef CONFIG_SCSI
-void __init note_scsi_host(struct device_node *node, void *host)
+void note_scsi_host(struct device_node *node, void *host)
 {
 	int l;
 	char *p;

commit 55b61fec22caa3e7872caea6c4100fc75cb8f49b
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu May 3 17:26:52 2007 +1000

    [POWERPC] Rename device_is_compatible to of_device_is_compatible
    
    for consistency with other Open Firmware interfaces (and Sparc).
    
    This is just a straight replacement.
    
    This leaves the compatibility define in place.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index e365bff74d83..a410bc76a8a8 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -659,8 +659,8 @@ static int pmac_pci_probe_mode(struct pci_bus *bus)
 	/* We need to use normal PCI probing for the AGP bus,
 	 * since the device for the AGP bridge isn't in the tree.
 	 */
-	if (bus->self == NULL && (device_is_compatible(node, "u3-agp") ||
-				  device_is_compatible(node, "u4-pcie")))
+	if (bus->self == NULL && (of_device_is_compatible(node, "u3-agp") ||
+				  of_device_is_compatible(node, "u4-pcie")))
 		return PCI_PROBE_NORMAL;
 	return PCI_PROBE_DEVTREE;
 }

commit d9333afd6a714760c13f76ba275a32ec7bd979c1
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu May 3 06:33:51 2007 +1000

    [POWERPC] powermac: Support G5 CPU hotplug
    
    This allows "hotplugging" of CPUs on G5 machines.  CPUs that are
    disabled are put into an idle loop with the decrementer frequency set
    to minimum.  To wake them up again we kick them just like when bringing
    them up.  To stop those CPUs from messing with any global state we stop
    them from entering the timer interrupt.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 5ae57e17d2ba..e365bff74d83 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -444,6 +444,9 @@ static int initializing = 1;
 static int pmac_late_init(void)
 {
 	initializing = 0;
+	/* this is udbg (which is __init) and we can later use it during
+	 * cpu hotplug (in smp_core99_kick_cpu) */
+	ppc_md.progress = NULL;
 	return 0;
 }
 
@@ -661,7 +664,52 @@ static int pmac_pci_probe_mode(struct pci_bus *bus)
 		return PCI_PROBE_NORMAL;
 	return PCI_PROBE_DEVTREE;
 }
-#endif
+
+#ifdef CONFIG_HOTPLUG_CPU
+/* access per cpu vars from generic smp.c */
+DECLARE_PER_CPU(int, cpu_state);
+
+static void pmac_cpu_die(void)
+{
+	/*
+	 * turn off as much as possible, we'll be
+	 * kicked out as this will only be invoked
+	 * on core99 platforms for now ...
+	 */
+
+	printk(KERN_INFO "CPU#%d offline\n", smp_processor_id());
+	__get_cpu_var(cpu_state) = CPU_DEAD;
+	smp_wmb();
+
+	/*
+	 * during the path that leads here preemption is disabled,
+	 * reenable it now so that when coming up preempt count is
+	 * zero correctly
+	 */
+	preempt_enable();
+
+	/*
+	 * hard-disable interrupts for the non-NAP case, the NAP code
+	 * needs to re-enable interrupts (but soft-disables them)
+	 */
+	hard_irq_disable();
+
+	while (1) {
+		/* let's not take timer interrupts too often ... */
+		set_dec(0x7fffffff);
+
+		/* should always be true at this point */
+		if (cpu_has_feature(CPU_FTR_CAN_NAP))
+			power4_cpu_offline_powersave();
+		else {
+			HMT_low();
+			HMT_very_low();
+		}
+	}
+}
+#endif /* CONFIG_HOTPLUG_CPU */
+
+#endif /* CONFIG_PPC64 */
 
 define_machine(powermac) {
 	.name			= "PowerMac",
@@ -698,6 +746,6 @@ define_machine(powermac) {
 	.phys_mem_access_prot	= pci_phys_mem_access_prot,
 #endif
 #if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC64)
-	.cpu_die		= generic_mach_cpu_die,
+	.cpu_die		= pmac_cpu_die,
 #endif
 };

commit be9c94dd7776467813419f49fabe8017bc2d4c81
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Mon Apr 30 21:37:15 2007 +1000

    [POWERPC] Fix suspend states again
    
    In commit 0fba3a1f39f8b0a50b56c8b068fa52131cbc84c2 (a very long time ago,
    May 2006), I fixed a bug that caused powermacs to crash when you tried
    entering standby/mem suspend states.
    
    As I'm now getting more familiar with the suspend code I notice a few
    more things:
     1. we previously misunderstood what pm_ops is for, it isn't supposed to be
        for doing platform dependent suspend/resume stuff that needs to be done
        for suspend to disk (as we currently try to use it!), it is instead for
        entering platform dependent suspend states ("standby", "mem").
     2. due to the first point, we never properly save FPU and altivec states
        when suspending to disk. It probably hasn't hurt yet because the process
        that writes the "disk" to /sys/power/state uses neither and its context
        is used.
    
    This patch addresses these points as follows:
     1. remove all pm_ops from powermac, powermac suspend to ram isn't currently
        usable via /sys/power/state but is done via the PMU instead.
     2. move the code responsible for storing FPU/altivec state into
        save_processor_state and the set_context() call to restore_processor_state.
     3. add a call to kernel_enable_spe()
    
    It may look like there is some code removal missing but that is
    actually because the new suspend.h file overrides the ppc/suspend.h
    one which was previously used.
    
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index b820cabac697..5ae57e17d2ba 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -439,76 +439,11 @@ static void __init find_boot_device(void)
 #endif
 }
 
-/* TODO: Merge the suspend-to-ram with the common code !!!
- * currently, this is a stub implementation for suspend-to-disk
- * only
- */
-
-#ifdef CONFIG_SOFTWARE_SUSPEND
-
-static int pmac_pm_prepare(suspend_state_t state)
-{
-	printk(KERN_DEBUG "%s(%d)\n", __FUNCTION__, state);
-
-	return 0;
-}
-
-static int pmac_pm_enter(suspend_state_t state)
-{
-	printk(KERN_DEBUG "%s(%d)\n", __FUNCTION__, state);
-
-	/* Giveup the lazy FPU & vec so we don't have to back them
-	 * up from the low level code
-	 */
-	enable_kernel_fp();
-
-#ifdef CONFIG_ALTIVEC
-	if (cur_cpu_spec->cpu_features & CPU_FTR_ALTIVEC)
-		enable_kernel_altivec();
-#endif /* CONFIG_ALTIVEC */
-
-	return 0;
-}
-
-static int pmac_pm_finish(suspend_state_t state)
-{
-	printk(KERN_DEBUG "%s(%d)\n", __FUNCTION__, state);
-
-	/* Restore userland MMU context */
-	set_context(current->active_mm->context.id, current->active_mm->pgd);
-
-	return 0;
-}
-
-static int pmac_pm_valid(suspend_state_t state)
-{
-	switch (state) {
-	case PM_SUSPEND_DISK:
-		return 1;
-	/* can't do any other states via generic mechanism yet */
-	default:
-		return 0;
-	}
-}
-
-static struct pm_ops pmac_pm_ops = {
-	.pm_disk_mode	= PM_DISK_SHUTDOWN,
-	.prepare	= pmac_pm_prepare,
-	.enter		= pmac_pm_enter,
-	.finish		= pmac_pm_finish,
-	.valid		= pmac_pm_valid,
-};
-
-#endif /* CONFIG_SOFTWARE_SUSPEND */
-
 static int initializing = 1;
 
 static int pmac_late_init(void)
 {
 	initializing = 0;
-#ifdef CONFIG_SOFTWARE_SUSPEND
-	pm_set_ops(&pmac_pm_ops);
-#endif /* CONFIG_SOFTWARE_SUSPEND */
 	return 0;
 }
 

commit 8d8a0241eb019ce9648a77b55f9f76a834207cbb
Author: Olaf Hering <olaf@aepfle.de>
Date:   Thu Apr 26 06:36:56 2007 +1000

    [POWERPC] Generic check_legacy_ioport
    
    check_legacy_ioport makes only sense on PREP, CHRP and pSeries.
    They may have an isa node with PS/2, parport, floppy and serial ports.
    
    Remove the check_legacy_ioport call from ppc_md, it's not needed
    anymore.  Hardware capabilities come from the device-tree.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 0444e07e8d7a..b820cabac697 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -635,15 +635,6 @@ static void __init pmac_init_early(void)
 #endif
 }
 
-/*
- * pmac has no legacy IO, anything calling this function has to
- * fail or bad things will happen
- */
-static int pmac_check_legacy_ioport(unsigned int baseport)
-{
-	return -ENODEV;
-}
-
 static int __init pmac_declare_of_platform_devices(void)
 {
 	struct device_node *np;
@@ -755,7 +746,6 @@ define_machine(powermac) {
 	.get_rtc_time		= pmac_get_rtc_time,
 	.calibrate_decr		= pmac_calibrate_decr,
 	.feature_call		= pmac_do_feature_call,
-	.check_legacy_ioport	= pmac_check_legacy_ioport,
 	.progress		= udbg_progress,
 #ifdef CONFIG_PPC64
 	.pci_probe_mode		= pmac_pci_probe_mode,

commit 30686ba6d56858657829d3eb524ed73e5dc98d2b
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 24 13:53:04 2007 +1000

    [POWERPC] Remove old interface find_devices
    
    Replace uses with of_find_node_by_name and for_each_node_by_name.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index ae37d3e23783..0444e07e8d7a 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -193,8 +193,11 @@ static void pmac_show_cpuinfo(struct seq_file *m)
 #ifndef CONFIG_ADB_CUDA
 int find_via_cuda(void)
 {
-	if (!find_devices("via-cuda"))
+	struct device_node *dn = of_find_node_by_name(NULL, "via-cuda");
+
+	if (!dn)
 		return 0;
+	of_node_put(dn);
 	printk("WARNING ! Your machine is CUDA-based but your kernel\n");
 	printk("          wasn't compiled with CONFIG_ADB_CUDA option !\n");
 	return 0;
@@ -204,8 +207,11 @@ int find_via_cuda(void)
 #ifndef CONFIG_ADB_PMU
 int find_via_pmu(void)
 {
-	if (!find_devices("via-pmu"))
+	struct device_node *dn = of_find_node_by_name(NULL, "via-pmu");
+
+	if (!dn)
 		return 0;
+	of_node_put(dn);
 	printk("WARNING ! Your machine is PMU-based but your kernel\n");
 	printk("          wasn't compiled with CONFIG_ADB_PMU option !\n");
 	return 0;
@@ -225,6 +231,8 @@ static volatile u32 *sysctrl_regs;
 
 static void __init ohare_init(void)
 {
+	struct device_node *dn;
+
 	/* this area has the CPU identification register
 	   and some registers used by smp boards */
 	sysctrl_regs = (volatile u32 *) ioremap(0xf8000000, 0x1000);
@@ -234,7 +242,9 @@ static void __init ohare_init(void)
 	 * We assume that we have a PSX memory controller iff
 	 * we have an ohare I/O controller.
 	 */
-	if (find_devices("ohare") != NULL) {
+	dn = of_find_node_by_name(NULL, "ohare");
+	if (dn) {
+		of_node_put(dn);
 		if (((sysctrl_regs[2] >> 24) & 0xf) >= 3) {
 			if (sysctrl_regs[4] & 0x10)
 				sysctrl_regs[4] |= 0x04000020;
@@ -343,8 +353,15 @@ static void __init pmac_setup_arch(void)
 
 #ifdef CONFIG_SMP
 	/* Check for Core99 */
-	if (find_devices("uni-n") || find_devices("u3") || find_devices("u4"))
+	ic = of_find_node_by_name(NULL, "uni-n");
+	if (!ic)
+		ic = of_find_node_by_name(NULL, "u3");
+	if (!ic)
+		ic = of_find_node_by_name(NULL, "u4");
+	if (ic) {
+		of_node_put(ic);
 		smp_ops = &core99_smp_ops;
+	}
 #ifdef CONFIG_PPC32
 	else
 		smp_ops = &psurge_smp_ops;

commit 1658ab66781d918f604c6069c5cf9a94b6f52f84
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 24 13:51:59 2007 +1000

    [POWERPC] Remove old interface find_type_devices
    
    Replaced by of_find_node_by_type.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 8c96f2461e9a..ae37d3e23783 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -250,9 +250,9 @@ static void __init l2cr_init(void)
 {
 	/* Checks "l2cr-value" property in the registry */
 	if (cpu_has_feature(CPU_FTR_L2CR)) {
-		struct device_node *np = find_devices("cpus");
+		struct device_node *np = of_find_node_by_name(NULL, "cpus");
 		if (np == 0)
-			np = find_type_devices("cpu");
+			np = of_find_node_by_type(NULL, "cpu");
 		if (np != 0) {
 			const unsigned int *l2cr =
 				of_get_property(np, "l2cr-value", NULL);
@@ -262,6 +262,7 @@ static void __init l2cr_init(void)
 				_set_L2CR(0);
 				_set_L2CR(ppc_override_l2cr_value);
 			}
+			of_node_put(np);
 		}
 	}
 

commit e2eb63927bfcb54232163bfec32440246fd44457
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 3 22:26:41 2007 +1000

    [POWERPC] Rename get_property to of_get_property: arch/powerpc
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index f2a3063980eb..8c96f2461e9a 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -134,12 +134,12 @@ static void pmac_show_cpuinfo(struct seq_file *m)
 	seq_printf(m, "machine\t\t: ");
 	np = of_find_node_by_path("/");
 	if (np != NULL) {
-		pp = get_property(np, "model", NULL);
+		pp = of_get_property(np, "model", NULL);
 		if (pp != NULL)
 			seq_printf(m, "%s\n", pp);
 		else
 			seq_printf(m, "PowerMac\n");
-		pp = get_property(np, "compatible", &plen);
+		pp = of_get_property(np, "compatible", &plen);
 		if (pp != NULL) {
 			seq_printf(m, "motherboard\t:");
 			while (plen > 0) {
@@ -163,11 +163,13 @@ static void pmac_show_cpuinfo(struct seq_file *m)
 	if (np == NULL)
 		np = of_find_node_by_type(NULL, "cache");
 	if (np != NULL) {
-		const unsigned int *ic = get_property(np, "i-cache-size", NULL);
-		const unsigned int *dc = get_property(np, "d-cache-size", NULL);
+		const unsigned int *ic =
+			of_get_property(np, "i-cache-size", NULL);
+		const unsigned int *dc =
+			of_get_property(np, "d-cache-size", NULL);
 		seq_printf(m, "L2 cache\t:");
 		has_l2cache = 1;
-		if (get_property(np, "cache-unified", NULL) != 0 && dc) {
+		if (of_get_property(np, "cache-unified", NULL) != 0 && dc) {
 			seq_printf(m, " %dK unified", *dc / 1024);
 		} else {
 			if (ic)
@@ -176,7 +178,7 @@ static void pmac_show_cpuinfo(struct seq_file *m)
 				seq_printf(m, "%s %dK data",
 					   (ic? " +": ""), *dc / 1024);
 		}
-		pp = get_property(np, "ram-type", NULL);
+		pp = of_get_property(np, "ram-type", NULL);
 		if (pp)
 			seq_printf(m, " %s", pp);
 		seq_printf(m, "\n");
@@ -253,7 +255,7 @@ static void __init l2cr_init(void)
 			np = find_type_devices("cpu");
 		if (np != 0) {
 			const unsigned int *l2cr =
-				get_property(np, "l2cr-value", NULL);
+				of_get_property(np, "l2cr-value", NULL);
 			if (l2cr != 0) {
 				ppc_override_l2cr = 1;
 				ppc_override_l2cr_value = *l2cr;
@@ -285,7 +287,7 @@ static void __init pmac_setup_arch(void)
 	loops_per_jiffy = 50000000 / HZ;
 	cpu = of_find_node_by_type(NULL, "cpu");
 	if (cpu != NULL) {
-		fp = get_property(cpu, "clock-frequency", NULL);
+		fp = of_get_property(cpu, "clock-frequency", NULL);
 		if (fp != NULL) {
 			if (pvr >= 0x30 && pvr < 0x80)
 				/* PPC970 etc. */
@@ -302,7 +304,7 @@ static void __init pmac_setup_arch(void)
 
 	/* See if newworld or oldworld */
 	for (ic = NULL; (ic = of_find_all_nodes(ic)) != NULL; )
-		if (get_property(ic, "interrupt-controller", NULL))
+		if (of_get_property(ic, "interrupt-controller", NULL))
 			break;
 	if (ic) {
 		pmac_newworld = 1;

commit 8545cd201134860b1eb72578419f5cbd4c0789c0
Author: Olaf Hering <olaf@aepfle.de>
Date:   Fri Mar 23 01:11:59 2007 +0100

    [POWERPC] Remove unused inclusion of linux/ide.h
    
    Remove unneeded inclusion of linux/ide.h
    It does not compile with CONFIG_BLOCK=n.
    
    Remove asm/ide.h from ksyms file, it gets included earlier via
    linux/ide.h.
    
    Compile tested with all defconfig files.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 651fa424ea06..f2a3063980eb 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -42,7 +42,6 @@
 #include <linux/initrd.h>
 #include <linux/vt_kern.h>
 #include <linux/console.h>
-#include <linux/ide.h>
 #include <linux/pci.h>
 #include <linux/adb.h>
 #include <linux/cuda.h>

commit b8757b21f7628c57cb20e55be324fdef283a56e9
Author: Alon Bar-Lev <alon.barlev@gmail.com>
Date:   Mon Feb 12 00:54:17 2007 -0800

    [PATCH] Dynamic kernel command-line: powerpc
    
    Rename saved_command_line into boot_command_line.
    
    Signed-off-by: Alon Bar-Lev <alon.barlev@gmail.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index d949e9df41ef..651fa424ea06 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -506,8 +506,8 @@ void note_bootable_part(dev_t dev, int part, int goodness)
 	if ((goodness <= current_root_goodness) &&
 	    ROOT_DEV != DEFAULT_ROOT_DEVICE)
 		return;
-	p = strstr(saved_command_line, "root=");
-	if (p != NULL && (p == saved_command_line || p[-1] == ' '))
+	p = strstr(boot_command_line, "root=");
+	if (p != NULL && (p == boot_command_line || p[-1] == ' '))
 		return;
 
 	if (!found_boot) {

commit 68a64357d15ae4f596e92715719071952006e83c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Nov 13 09:27:39 2006 +1100

    [POWERPC] Merge 32 and 64 bits asm-powerpc/io.h
    
    powerpc: Merge 32 and 64 bits asm-powerpc/io.h
    
    The rework on io.h done for the new hookable accessors made it easier,
    so I just finished the work and merged 32 and 64 bits io.h for arch/powerpc.
    
    arch/ppc still uses the old version in asm-ppc, there is just too much gunk
    in there that I really can't be bothered trying to cleanup.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 4ec6a5a65f30..d949e9df41ef 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -677,8 +677,6 @@ static int __init pmac_probe(void)
 
 #ifdef CONFIG_PPC32
 	/* isa_io_base gets set in pmac_pci_init */
-	isa_mem_base = PMAC_ISA_MEM_BASE;
-	pci_dram_offset = PMAC_PCI_DRAM_OFFSET;
 	ISA_DMA_THRESHOLD = ~0L;
 	DMA_MODE_READ = 1;
 	DMA_MODE_WRITE = 2;

commit 7eebde700fe6fd6573e80bd8e5ed82b4ae705575
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat Nov 11 17:24:59 2006 +1100

    [POWERPC] Souped-up of_platform_device support
    
    This patch first splits of_device.c and of_platform.c, the later containing
    the bits relative to of_platform_device's. On the "breaks" side of things,
    drivers uisng of_platform_device(s) need to include asm/of_platform.h now
    and of_(un)register_driver is now of_(un)register_platform_driver.
    
    In addition to a few utility functions to locate of_platform_device(s),
    the main new addition is of_platform_bus_probe() which allows the platform
    code to trigger an automatic creation of of_platform_devices for a whole
    tree of devices.
    
    The function acts based on the type of the various "parent" devices encountered
    from a provided root, using either a default known list of bus types that can be
    "probed" or a passed-in list. It will only register devices on busses matching
    that list, which mean that typically, it will not register PCI devices, as
    expected (since they will be picked up by the PCI layer).
    
    This will be used by Cell platforms using 4xx-type IOs in the Axon bridge
    and can be used by any embedded-type device as well.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 805791d76fdf..4ec6a5a65f30 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -70,6 +70,7 @@
 #include <asm/pmac_feature.h>
 #include <asm/time.h>
 #include <asm/of_device.h>
+#include <asm/of_platform.h>
 #include <asm/mmu_context.h>
 #include <asm/iommu.h>
 #include <asm/smu.h>

commit f90bb153b1493719d18b4529a46ebfe43220ea6c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat Nov 11 17:24:51 2006 +1100

    [POWERPC] Make pci_read_irq_line the default
    
    This patch reworks the way IRQs are fixed up on PCI for arch powerpc.
    
    It makes pci_read_irq_line() called by default in the PCI code for
    devices that are probed, and add an optional per-device fixup in
    ppc_md for platforms that really need to correct what they obtain
    from pci_read_irq_line().
    
    It also removes ppc_md.irq_bus_setup which was only used by pSeries
    and should not be needed anymore.
    
    I've also removed the pSeries s7a workaround as it can't work with
    the current interrupt code anyway. I'm trying to get one of these
    machines working so I can test a proper fix for that problem.
    
    I also haven't updated the old-style fixup code from 85xx_cds.c
    because it's actually buggy :) It assigns pci_dev->irq hard coded
    numbers which is no good with the new IRQ mapping code. It should
    at least use irq_create_mapping(NULL, hard_coded_number); and possibly
    also set_irq_type() to set them as level low.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index cb1c342061e2..805791d76fdf 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -727,7 +727,7 @@ define_machine(powermac) {
 	.show_cpuinfo		= pmac_show_cpuinfo,
 	.init_IRQ		= pmac_pic_init,
 	.get_irq		= NULL,	/* changed later */
-	.pcibios_fixup		= pmac_pcibios_fixup,
+	.pci_irq_fixup		= pmac_pci_irq_fixup,
 	.restart		= pmac_restart,
 	.power_off		= pmac_power_off,
 	.halt			= pmac_halt,

commit fd6e7d2d6a0231ebfa08e1f9a323497ea548da7d
Author: s.hauer@pengutronix.de <s.hauer@pengutronix.de>
Date:   Thu Nov 2 13:56:10 2006 +0100

    [PATCH] Clean up usage of boot_dev
    
    dev_t boot_dev is declared in arch/powerpc/kernel/setup_32.c
    and in arch/powerpc/kernel/setup_64.c but not used in these files.
    It is only used in arch/powerpc/platforms/powermac/setup.c, so make
    it static in this file.
    
    Signed-off-by: Sascha Hauer <s.hauer@pengutronix.de>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 824a618396ab..cb1c342061e2 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -361,7 +361,7 @@ char *bootdevice;
 void *boot_host;
 int boot_target;
 int boot_part;
-extern dev_t boot_dev;
+static dev_t boot_dev;
 
 #ifdef CONFIG_SCSI
 void __init note_scsi_host(struct device_node *node, void *host)

commit 018a3d1db7cdb6127656c1622ee1d2302e16436d
Author: Jeremy Kerr <jk@ozlabs.org>
Date:   Wed Jul 12 15:40:29 2006 +1000

    [POWERPC] powermac: Constify & voidify get_property()
    
    Now that get_property() returns a void *, there's no need to cast its
    return value. Also, treat the return value as const, so we can
    constify get_property later.
    
    powermac platform & macintosh driver changes.
    
    Built for pmac32_defconfig, g5_defconfig
    
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 31a9da769fa2..824a618396ab 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -116,7 +116,7 @@ extern struct smp_ops_t core99_smp_ops;
 static void pmac_show_cpuinfo(struct seq_file *m)
 {
 	struct device_node *np;
-	char *pp;
+	const char *pp;
 	int plen;
 	int mbmodel;
 	unsigned int mbflags;
@@ -134,12 +134,12 @@ static void pmac_show_cpuinfo(struct seq_file *m)
 	seq_printf(m, "machine\t\t: ");
 	np = of_find_node_by_path("/");
 	if (np != NULL) {
-		pp = (char *) get_property(np, "model", NULL);
+		pp = get_property(np, "model", NULL);
 		if (pp != NULL)
 			seq_printf(m, "%s\n", pp);
 		else
 			seq_printf(m, "PowerMac\n");
-		pp = (char *) get_property(np, "compatible", &plen);
+		pp = get_property(np, "compatible", &plen);
 		if (pp != NULL) {
 			seq_printf(m, "motherboard\t:");
 			while (plen > 0) {
@@ -163,10 +163,8 @@ static void pmac_show_cpuinfo(struct seq_file *m)
 	if (np == NULL)
 		np = of_find_node_by_type(NULL, "cache");
 	if (np != NULL) {
-		unsigned int *ic = (unsigned int *)
-			get_property(np, "i-cache-size", NULL);
-		unsigned int *dc = (unsigned int *)
-			get_property(np, "d-cache-size", NULL);
+		const unsigned int *ic = get_property(np, "i-cache-size", NULL);
+		const unsigned int *dc = get_property(np, "d-cache-size", NULL);
 		seq_printf(m, "L2 cache\t:");
 		has_l2cache = 1;
 		if (get_property(np, "cache-unified", NULL) != 0 && dc) {
@@ -254,7 +252,7 @@ static void __init l2cr_init(void)
 		if (np == 0)
 			np = find_type_devices("cpu");
 		if (np != 0) {
-			unsigned int *l2cr = (unsigned int *)
+			const unsigned int *l2cr =
 				get_property(np, "l2cr-value", NULL);
 			if (l2cr != 0) {
 				ppc_override_l2cr = 1;
@@ -277,7 +275,7 @@ static void __init l2cr_init(void)
 static void __init pmac_setup_arch(void)
 {
 	struct device_node *cpu, *ic;
-	int *fp;
+	const int *fp;
 	unsigned long pvr;
 
 	pvr = PVR_VER(mfspr(SPRN_PVR));
@@ -287,7 +285,7 @@ static void __init pmac_setup_arch(void)
 	loops_per_jiffy = 50000000 / HZ;
 	cpu = of_find_node_by_type(NULL, "cpu");
 	if (cpu != NULL) {
-		fp = (int *) get_property(cpu, "clock-frequency", NULL);
+		fp = get_property(cpu, "clock-frequency", NULL);
 		if (fp != NULL) {
 			if (pvr >= 0x30 && pvr < 0x80)
 				/* PPC970 etc. */

commit 0ebfff1491ef85d41ddf9c633834838be144f69f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jul 3 21:36:01 2006 +1000

    [POWERPC] Add new interrupt mapping core and change platforms to use it
    
    This adds the new irq remapper core and removes the old one.  Because
    there are some fundamental conflicts with the old code, like the value
    of NO_IRQ which I'm now setting to 0 (as per discussions with Linus),
    etc..., this commit also changes the relevant platform and driver code
    over to use the new remapper (so as not to cause difficulties later
    in bisecting).
    
    This patch removes the old pre-parsing of the open firmware interrupt
    tree along with all the bogus assumptions it made to try to renumber
    interrupts according to the platform. This is all to be handled by the
    new code now.
    
    For the pSeries XICS interrupt controller, a single remapper host is
    created for the whole machine regardless of how many interrupt
    presentation and source controllers are found, and it's set to match
    any device node that isn't a 8259.  That works fine on pSeries and
    avoids having to deal with some of the complexities of split source
    controllers vs. presentation controllers in the pSeries device trees.
    
    The powerpc i8259 PIC driver now always requests the legacy interrupt
    range. It also has the feature of being able to match any device node
    (including NULL) if passed no device node as an input. That will help
    porting over platforms with broken device-trees like Pegasos who don't
    have a proper interrupt tree.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 8654b5f07836..31a9da769fa2 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -613,9 +613,6 @@ static void __init pmac_init_early(void)
 	udbg_adb_init(!!strstr(cmd_line, "btextdbg"));
 
 #ifdef CONFIG_PPC64
-	/* Setup interrupt mapping options */
-	ppc64_interrupt_controller = IC_OPEN_PIC;
-
 	iommu_init_early_dart();
 #endif
 }

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 89c5775f83be..8654b5f07836 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -23,7 +23,6 @@
  * bootup setup stuff..
  */
 
-#include <linux/config.h>
 #include <linux/init.h>
 #include <linux/errno.h>
 #include <linux/sched.h>

commit 7d0daae4ae1a3e80d78b83cddf414a3b98a962f4
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Fri Jun 23 18:16:38 2006 +1000

    [POWERPC] powerpc: Initialise ppc_md htab pointers earlier
    
    Initialise the ppc_md htab callbacks earlier, in the probe routines. This
    allows us to call htab_finish_init() from htab_initialize(), and makes it
    private to hash_utils_64.c. Move htab_finish_init() and make_bl() above
    htab_initialize() to avoid forward declarations.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 9cc7db7a8bdc..89c5775f83be 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -600,13 +600,6 @@ pmac_halt(void)
  */
 static void __init pmac_init_early(void)
 {
-#ifdef CONFIG_PPC64
-	/* Initialize hash table, from now on, we can take hash faults
-	 * and call ioremap
-	 */
-	hpte_init_native();
-#endif
-
 	/* Enable early btext debug if requested */
 	if (strstr(cmd_line, "btextdbg")) {
 		udbg_adb_init_early();
@@ -683,6 +676,8 @@ static int __init pmac_probe(void)
 	 * part of the cacheable linar mapping
 	 */
 	alloc_dart_table();
+
+	hpte_init_native();
 #endif
 
 #ifdef CONFIG_PPC32

commit 6218a761bbc27acc65248c80024875bcc06d52b1
Author: Paul Mackerras <paulus@samba.org>
Date:   Sun Jun 11 14:15:17 2006 +1000

    powerpc: add context.vdso_base for 32-bit too
    
    This adds a vdso_base element to the mm_context_t for 32-bit compiles
    (both for ARCH=powerpc and ARCH=ppc).  This fixes the compile errors
    that have been reported in arch/powerpc/kernel/signal_32.c.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index b9200fb07815..9cc7db7a8bdc 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -458,7 +458,7 @@ static int pmac_pm_finish(suspend_state_t state)
 	printk(KERN_DEBUG "%s(%d)\n", __FUNCTION__, state);
 
 	/* Restore userland MMU context */
-	set_context(current->active_mm->context, current->active_mm->pgd);
+	set_context(current->active_mm->context.id, current->active_mm->pgd);
 
 	return 0;
 }

commit 0fba3a1f39f8b0a50b56c8b068fa52131cbc84c2
Author: Johannes Berg <johannes@sipsolutions.net>
Date:   Thu May 25 18:44:24 2006 -0700

    [PATCH] PowerMac: force only suspend-to-disk to be valid
    
    For a very long time, echoing 'standby' or 'mem' into /sys/power/state has
    killed the machine on powerpc.  This patch fixes that.
    
    This patch adds the .valid callback to pm_ops on PowerMac so that only the
    suspend to disk state can be entered.  Note that just returning 0 would
    suffice since the upper layers don't pass PM_SUSPEND_DISK down, but we
    handle it there regardless just in case that changes.
    
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Johannes Berg <johannes@sipsolutions.net>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 4d15e396655c..b9200fb07815 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -463,11 +463,23 @@ static int pmac_pm_finish(suspend_state_t state)
 	return 0;
 }
 
+static int pmac_pm_valid(suspend_state_t state)
+{
+	switch (state) {
+	case PM_SUSPEND_DISK:
+		return 1;
+	/* can't do any other states via generic mechanism yet */
+	default:
+		return 0;
+	}
+}
+
 static struct pm_ops pmac_pm_ops = {
 	.pm_disk_mode	= PM_DISK_SHUTDOWN,
 	.prepare	= pmac_pm_prepare,
 	.enter		= pmac_pm_enter,
 	.finish		= pmac_pm_finish,
+	.valid		= pmac_pm_valid,
 };
 
 #endif /* CONFIG_SOFTWARE_SUSPEND */

commit e8222502ee6157e2713da9e0792c21f4ad458d50
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Mar 28 23:15:54 2006 +1100

    [PATCH] powerpc: Kill _machine and hard-coded platform numbers
    
    This removes statically assigned platform numbers and reworks the
    powerpc platform probe code to use a better mechanism.  With this,
    board support files can simply declare a new machine type with a
    macro, and implement a probe() function that uses the flattened
    device-tree to detect if they apply for a given machine.
    
    We now have a machine_is() macro that replaces the comparisons of
    _machine with the various PLATFORM_* constants.  This commit also
    changes various drivers to use the new macro instead of looking at
    _machine.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index c2696d00672a..4d15e396655c 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -350,6 +350,13 @@ static void __init pmac_setup_arch(void)
 		smp_ops = &psurge_smp_ops;
 #endif
 #endif /* CONFIG_SMP */
+
+#ifdef CONFIG_ADB
+	if (strstr(cmd_line, "adb_sync")) {
+		extern int __adb_probe_sync;
+		__adb_probe_sync = 1;
+	}
+#endif /* CONFIG_ADB */
 }
 
 char *bootpath;
@@ -576,30 +583,6 @@ pmac_halt(void)
 	pmac_power_off();
 }
 
-#ifdef CONFIG_PPC32
-void __init pmac_init(void)
-{
-	/* isa_io_base gets set in pmac_pci_init */
-	isa_mem_base = PMAC_ISA_MEM_BASE;
-	pci_dram_offset = PMAC_PCI_DRAM_OFFSET;
-	ISA_DMA_THRESHOLD = ~0L;
-	DMA_MODE_READ = 1;
-	DMA_MODE_WRITE = 2;
-
-	ppc_md = pmac_md;
-
-#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
-#ifdef CONFIG_BLK_DEV_IDE_PMAC
-        ppc_ide_md.ide_init_hwif	= pmac_ide_init_hwif_ports;
-        ppc_ide_md.default_io_base	= pmac_ide_get_base;
-#endif /* CONFIG_BLK_DEV_IDE_PMAC */
-#endif /* defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE) */
-
-	if (ppc_md.progress) ppc_md.progress("pmac_init(): exit", 0);
-
-}
-#endif
-
 /* 
  * Early initialization.
  */
@@ -646,6 +629,12 @@ static int __init pmac_declare_of_platform_devices(void)
 {
 	struct device_node *np;
 
+	if (machine_is(chrp))
+		return -1;
+
+	if (!machine_is(powermac))
+		return 0;
+
 	np = of_find_node_by_name(NULL, "valkyrie");
 	if (np)
 		of_platform_device_create(np, "valkyrie", NULL);
@@ -666,12 +655,15 @@ device_initcall(pmac_declare_of_platform_devices);
 /*
  * Called very early, MMU is off, device-tree isn't unflattened
  */
-static int __init pmac_probe(int platform)
+static int __init pmac_probe(void)
 {
-#ifdef CONFIG_PPC64
-	if (platform != PLATFORM_POWERMAC)
+	unsigned long root = of_get_flat_dt_root();
+
+	if (!of_flat_dt_is_compatible(root, "Power Macintosh") &&
+	    !of_flat_dt_is_compatible(root, "MacRISC"))
 		return 0;
 
+#ifdef CONFIG_PPC64
 	/*
 	 * On U3, the DART (iommu) must be allocated now since it
 	 * has an impact on htab_initialize (due to the large page it
@@ -681,6 +673,23 @@ static int __init pmac_probe(int platform)
 	alloc_dart_table();
 #endif
 
+#ifdef CONFIG_PPC32
+	/* isa_io_base gets set in pmac_pci_init */
+	isa_mem_base = PMAC_ISA_MEM_BASE;
+	pci_dram_offset = PMAC_PCI_DRAM_OFFSET;
+	ISA_DMA_THRESHOLD = ~0L;
+	DMA_MODE_READ = 1;
+	DMA_MODE_WRITE = 2;
+
+#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
+#ifdef CONFIG_BLK_DEV_IDE_PMAC
+        ppc_ide_md.ide_init_hwif	= pmac_ide_init_hwif_ports;
+        ppc_ide_md.default_io_base	= pmac_ide_get_base;
+#endif /* CONFIG_BLK_DEV_IDE_PMAC */
+#endif /* defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE) */
+
+#endif /* CONFIG_PPC32 */
+
 #ifdef CONFIG_PMAC_SMU
 	/*
 	 * SMU based G5s need some memory below 2Gb, at least the current
@@ -709,10 +718,8 @@ static int pmac_pci_probe_mode(struct pci_bus *bus)
 }
 #endif
 
-struct machdep_calls __initdata pmac_md = {
-#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC64)
-	.cpu_die		= generic_mach_cpu_die,
-#endif
+define_machine(powermac) {
+	.name			= "PowerMac",
 	.probe			= pmac_probe,
 	.setup_arch		= pmac_setup_arch,
 	.init_early		= pmac_init_early,
@@ -746,4 +753,7 @@ struct machdep_calls __initdata pmac_md = {
 	.pcibios_after_init	= pmac_pcibios_after_init,
 	.phys_mem_access_prot	= pci_phys_mem_access_prot,
 #endif
+#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC64)
+	.cpu_die		= generic_mach_cpu_die,
+#endif
 };

commit a0652fc9a28c3ef8cd59264bfcb089c44d1b0e06
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Mar 27 15:03:03 2006 +1100

    powerpc: Unify the 32 and 64 bit idle loops
    
    This unifies the 32-bit (ARCH=ppc and ARCH=powerpc) and 64-bit idle
    loops.  It brings over the concept of having a ppc_md.power_save
    function from 32-bit to ARCH=powerpc, which lets us get rid of
    native_idle().  With this we will also be able to simplify the idle
    handling for pSeries and cell.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 385aab90c4d2..c2696d00672a 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -733,7 +733,7 @@ struct machdep_calls __initdata pmac_md = {
 	.progress		= udbg_progress,
 #ifdef CONFIG_PPC64
 	.pci_probe_mode		= pmac_pci_probe_mode,
-	.idle_loop		= native_idle,
+	.power_save		= power4_idle,
 	.enable_pmcs		= power4_enable_pmcs,
 #ifdef CONFIG_KEXEC
 	.machine_kexec		= default_machine_kexec,

commit 23dd64011285010ac291f7dddf6e287bdb43a0ad
Merge: 516450179454 485ff0999041
Author: Paul Mackerras <paulus@samba.org>
Date:   Fri Mar 17 12:01:19 2006 +1100

    Merge ../linux-2.6

commit c6cb3b5f368bae67c0b258cfebc0b9dbd8e1d929
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sun Mar 12 10:55:01 2006 +1100

    [PATCH] powerpc: enable NAP only on cpus who support it to avoid memory corruption
    
    This patch fixes incorrect setting of powersave_nap to 1 on all
    PowerMacs, potentially causing memory corruption on some models. This
    bug was introuced by me during the 32/64 bits merge.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 1955462f4082..29c2946f1c77 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -621,10 +621,6 @@ static void __init pmac_init_early(void)
 	/* Probe motherboard chipset */
 	pmac_feature_init();
 
-	/* We can NAP */
-	powersave_nap = 1;
-	printk(KERN_INFO "Using native/NAP idle loop\n");
-
 	/* Initialize debug stuff */
 	udbg_scc_init(!!strstr(cmd_line, "sccdbg"));
 	udbg_adb_init(!!strstr(cmd_line, "btextdbg"));

commit d6d93856cb90eeb07062ad938bd26f554bf1b9b9
Merge: 8f75015f33c3 ad71f123a9e9
Author: Paul Mackerras <paulus@samba.org>
Date:   Fri Feb 10 16:51:29 2006 +1100

    Merge ../powerpc-merge

commit 4fb7d9827e89cc0a4ad2fde32ffa08f77cc0b7fe
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Dec 21 13:24:46 2005 -0500

    [PATCH] drive_info removal outside of arch/i386
    
    drive_info is used only by hd.c and that happens under #ifdef __i386__.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 89c4c3636161..1955462f4082 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -82,8 +82,6 @@
 
 #undef SHOW_GATWICK_IRQS
 
-unsigned char drive_info;
-
 int ppc_override_l2cr = 0;
 int ppc_override_l2cr_value;
 int has_l2cache = 0;

commit d2515c806ea2b602e99b9aa19448577c7f0318fb
Author: Olaf Hering <olh@suse.de>
Date:   Sun Jan 22 22:19:02 2006 +0100

    [PATCH] powerpc: cleanup pmac_newworld variable usage
    
    remove extern declarations of pmac_newworld
    move pmac_newworld to bss
    if there is any "interrupt-controller" device, then it is newworld.
    
    Signed-off-by: Olaf Hering <olh@suse.de>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 89c4c3636161..616b1e3ebe04 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -88,11 +88,10 @@ int ppc_override_l2cr = 0;
 int ppc_override_l2cr_value;
 int has_l2cache = 0;
 
-int pmac_newworld = 1;
+int pmac_newworld;
 
 static int current_root_goodness = -1;
 
-extern int pmac_newworld;
 extern struct machdep_calls pmac_md;
 
 #define DEFAULT_ROOT_DEVICE Root_SDA1	/* sda1 - slightly silly choice */
@@ -310,9 +309,10 @@ static void __init pmac_setup_arch(void)
 	for (ic = NULL; (ic = of_find_all_nodes(ic)) != NULL; )
 		if (get_property(ic, "interrupt-controller", NULL))
 			break;
-	pmac_newworld = (ic != NULL);
-	if (ic)
+	if (ic) {
+		pmac_newworld = 1;
 		of_node_put(ic);
+	}
 
 	/* Lookup PCI hosts */
 	pmac_pci_init();

commit ff38e7c80a92de91b34e483478d81eb3d1cf1b37
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 11 00:00:03 2006 +0000

    [PATCH] powerpc: pmac namespace cleanup
    
    pmac_setup_arch is only used in the file that it is defined in,
    so it should not be in the global namespace.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 3b1a9d4fcbc6..89c4c3636161 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -278,7 +278,7 @@ static void __init l2cr_init(void)
 }
 #endif
 
-void __init pmac_setup_arch(void)
+static void __init pmac_setup_arch(void)
 {
 	struct device_node *cpu, *ic;
 	int *fp;

commit a28d3af2a26c89aaa6470ca36edb212e05143d67
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat Jan 7 11:35:26 2006 +1100

    [PATCH] 2/5 powerpc: Rework PowerMac i2c part 2
    
    This is the continuation of the previous patch. This one removes the old
    PowerMac i2c drivers (i2c-keywest and i2c-pmac-smu) and replaces them
    both with a single stub driver that uses the new PowerMac low i2c layer.
    
    Now that i2c-keywest is gone, the low-i2c code is extended to support
    interrupt driver transfers. All i2c busses now appear as platform
    devices. Compatibility with existing drivers should be maintained as the
    i2c bus names have been kept identical, except for the SMU bus but in
    that later case, all users has been fixed.
    
    With that patch added, matching a device node to an i2c_adapter becomes
    trivial.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index dc5cdc1484e8..3b1a9d4fcbc6 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -650,7 +650,7 @@ static int pmac_check_legacy_ioport(unsigned int baseport)
 
 static int __init pmac_declare_of_platform_devices(void)
 {
-	struct device_node *np, *npp;
+	struct device_node *np;
 
 	np = of_find_node_by_name(NULL, "valkyrie");
 	if (np)
@@ -658,22 +658,6 @@ static int __init pmac_declare_of_platform_devices(void)
 	np = of_find_node_by_name(NULL, "platinum");
 	if (np)
 		of_platform_device_create(np, "platinum", NULL);
-	npp = of_find_node_by_name(NULL, "uni-n");
-	if (npp == NULL)
-		npp = of_find_node_by_name(NULL, "u3");
-	if (npp == NULL)
-		npp = of_find_node_by_name(NULL, "u4");
-	if (npp) {
-		for (np = NULL; (np = of_get_next_child(npp, np)) != NULL;) {
-			if (strncmp(np->name, "i2c", 3) == 0) {
-				of_platform_device_create(np, "uni-n-i2c",
-							  NULL);
-				of_node_put(np);
-				break;
-			}
-		}
-		of_node_put(npp);
-	}
         np = of_find_node_by_type(NULL, "smu");
         if (np) {
 		of_platform_device_create(np, "smu", NULL);

commit 730745a5c45093982112ddc94cee6a9973455641
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat Jan 7 11:30:44 2006 +1100

    [PATCH] 1/5 powerpc: Rework PowerMac i2c part 1
    
    This is the first part of a rework of the PowerMac i2c code. It
    completely reworks the "low_i2c" layer. It is now more flexible,
    supports KeyWest, SMU and PMU i2c busses, and provides functions to
    match device nodes to i2c busses and adapters.
    
    This patch also extends & fix some bugs in the SMU driver related to i2c
    support and removes the clock spreading hacks from the pmac feature code
    rather than adapting them to the new API since they'll be replaced by
    the platform function code completely in patch 3/5
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index e5a5bdbdda7a..dc5cdc1484e8 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -652,27 +652,22 @@ static int __init pmac_declare_of_platform_devices(void)
 {
 	struct device_node *np, *npp;
 
-	np = find_devices("uni-n");
-	if (np) {
-		for (np = np->child; np != NULL; np = np->sibling)
-			if (strncmp(np->name, "i2c", 3) == 0) {
-				of_platform_device_create(np, "uni-n-i2c",
-							  NULL);
-				break;
-			}
-	}
-	np = find_devices("valkyrie");
+	np = of_find_node_by_name(NULL, "valkyrie");
 	if (np)
 		of_platform_device_create(np, "valkyrie", NULL);
-	np = find_devices("platinum");
+	np = of_find_node_by_name(NULL, "platinum");
 	if (np)
 		of_platform_device_create(np, "platinum", NULL);
-
-	npp = of_find_node_by_name(NULL, "u3");
+	npp = of_find_node_by_name(NULL, "uni-n");
+	if (npp == NULL)
+		npp = of_find_node_by_name(NULL, "u3");
+	if (npp == NULL)
+		npp = of_find_node_by_name(NULL, "u4");
 	if (npp) {
 		for (np = NULL; (np = of_get_next_child(npp, np)) != NULL;) {
 			if (strncmp(np->name, "i2c", 3) == 0) {
-				of_platform_device_create(np, "u3-i2c", NULL);
+				of_platform_device_create(np, "uni-n-i2c",
+							  NULL);
 				of_node_put(np);
 				break;
 			}

commit be6b843918394067e93ebbacb834245251a6f18a
Author: Kumar Gala <galak@gate.crashing.org>
Date:   Tue Dec 20 16:37:07 2005 -0600

    [PATCH] powerpc: added a udbg_progress
    
    Added a common udbg_progress for use by ppc_md.progress()
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 1daa5a06e9ea..e5a5bdbdda7a 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -639,12 +639,6 @@ static void __init pmac_init_early(void)
 #endif
 }
 
-static void __init pmac_progress(char *s, unsigned short hex)
-{
-	udbg_puts(s);
-	udbg_puts("\n");
-}
-
 /*
  * pmac has no legacy IO, anything calling this function has to
  * fail or bad things will happen
@@ -763,7 +757,7 @@ struct machdep_calls __initdata pmac_md = {
 	.calibrate_decr		= pmac_calibrate_decr,
 	.feature_call		= pmac_do_feature_call,
 	.check_legacy_ioport	= pmac_check_legacy_ioport,
-	.progress		= pmac_progress,
+	.progress		= udbg_progress,
 #ifdef CONFIG_PPC64
 	.pci_probe_mode		= pmac_pci_probe_mode,
 	.idle_loop		= native_idle,

commit 1beb6a7d6cbed3ac03500ce9b5b9bb632c512039
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Dec 14 13:10:10 2005 +1100

    [PATCH] powerpc: Experimental support for new G5 Macs (#2)
    
    This adds some very basic support for the new machines, including the
    Quad G5 (tested), and other new dual core based machines and iMac G5
    iSight (untested). This is still experimental !  There is no thermal
    control yet, there is no proper handing of MSIs, etc.. but it
    boots, I have all 4 cores up on my machine. Compared to the previous
    version of this patch, this one adds DART IOMMU support for the U4
    chipset and thus should work fine on setups with more than 2Gb of RAM.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 18c5620f87fa..1daa5a06e9ea 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -345,7 +345,7 @@ void __init pmac_setup_arch(void)
 
 #ifdef CONFIG_SMP
 	/* Check for Core99 */
-	if (find_devices("uni-n") || find_devices("u3"))
+	if (find_devices("uni-n") || find_devices("u3") || find_devices("u4"))
 		smp_ops = &core99_smp_ops;
 #ifdef CONFIG_PPC32
 	else
@@ -635,7 +635,7 @@ static void __init pmac_init_early(void)
 	/* Setup interrupt mapping options */
 	ppc64_interrupt_controller = IC_OPEN_PIC;
 
-	iommu_init_early_u3();
+	iommu_init_early_dart();
 #endif
 }
 
@@ -711,7 +711,7 @@ static int __init pmac_probe(int platform)
 	 * occupies having to be broken up so the DART itself is not
 	 * part of the cacheable linar mapping
 	 */
-	alloc_u3_dart_table();
+	alloc_dart_table();
 #endif
 
 #ifdef CONFIG_PMAC_SMU
@@ -733,10 +733,11 @@ static int pmac_pci_probe_mode(struct pci_bus *bus)
 	struct device_node *node = bus->sysdata;
 
 	/* We need to use normal PCI probing for the AGP bus,
-	   since the device for the AGP bridge isn't in the tree. */
-	if (bus->self == NULL && device_is_compatible(node, "u3-agp"))
+	 * since the device for the AGP bridge isn't in the tree.
+	 */
+	if (bus->self == NULL && (device_is_compatible(node, "u3-agp") ||
+				  device_is_compatible(node, "u4-pcie")))
 		return PCI_PROBE_NORMAL;
-
 	return PCI_PROBE_DEVTREE;
 }
 #endif

commit cc5d0189b9ba95260857a5018a1c2fef90008507
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Dec 13 18:01:21 2005 +1100

    [PATCH] powerpc: Remove device_node addrs/n_addr
    
    The pre-parsed addrs/n_addrs fields in struct device_node are finally
    gone. Remove the dodgy heuristics that did that parsing at boot and
    remove the fields themselves since we now have a good replacement with
    the new OF parsing code. This patch also fixes a bunch of drivers to use
    the new code instead, so that at least pmac32, pseries, iseries and g5
    defconfigs build.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index c0638e47c298..18c5620f87fa 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -75,7 +75,6 @@
 #include <asm/iommu.h>
 #include <asm/smu.h>
 #include <asm/pmc.h>
-#include <asm/mpic.h>
 #include <asm/lmb.h>
 #include <asm/udbg.h>
 
@@ -751,7 +750,7 @@ struct machdep_calls __initdata pmac_md = {
 	.init_early		= pmac_init_early,
 	.show_cpuinfo		= pmac_show_cpuinfo,
 	.init_IRQ		= pmac_pic_init,
-	.get_irq		= mpic_get_irq,	/* changed later */
+	.get_irq		= NULL,	/* changed later */
 	.pcibios_fixup		= pmac_pcibios_fixup,
 	.restart		= pmac_restart,
 	.power_off		= pmac_power_off,

commit cc53291521701f9c7c7265bbb3c140563174d8b2
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Sun Dec 4 18:39:43 2005 +1100

    [PATCH] powerpc: Add arch dependent basic infrastructure for Kdump.
    
    Implementing the machine_crash_shutdown which will be called by
    crash_kexec (called in case of a panic, sysrq etc.). Disable the
    interrupts, shootdown cpus using debugger IPI and collect regs
    for all CPUs.
    
    elfcorehdr= specifies the location of elf core header stored by
    the crashed kernel. This command line option will be passed by
    the kexec-tools to capture kernel.
    
    savemaxmem= specifies the actual memory size that the first kernel
    has and this value will be used for dumping in the capture kernel.
    This command line option will be passed by the kexec-tools to
    capture kernel.
    
    Signed-off-by: Haren Myneni <haren@us.ibm.com>
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 6ee620fe5195..c0638e47c298 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -771,6 +771,7 @@ struct machdep_calls __initdata pmac_md = {
 #ifdef CONFIG_KEXEC
 	.machine_kexec		= default_machine_kexec,
 	.machine_kexec_prepare	= default_machine_kexec_prepare,
+	.machine_crash_shutdown	= default_machine_crash_shutdown,
 #endif
 #endif /* CONFIG_PPC64 */
 #ifdef CONFIG_PPC32

commit 51d3082fe6e55aecfa17113dbe98077c749f724c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Nov 23 17:57:25 2005 +1100

    [PATCH] powerpc: Unify udbg (#2)
    
    This patch unifies udbg for both ppc32 and ppc64 when building the
    merged achitecture. xmon now has a single "back end". The powermac udbg
    stuff gets enriched with some ADB capabilities and btext output. In
    addition, the early_init callback is now called on ppc32 as well,
    approx. in the same order as ppc64 regarding device-tree manipulations.
    The init sequences of ppc32 and ppc64 are getting closer, I'll unify
    them in a later patch.
    
    For now, you can force udbg to the scc using "sccdbg" or to btext using
    "btextdbg" on powermacs. I'll implement a cleaner way of forcing udbg
    output to something else than the autodetected OF output device in a
    later patch.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 3b7a492d9b68..6ee620fe5195 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -77,6 +77,7 @@
 #include <asm/pmc.h>
 #include <asm/mpic.h>
 #include <asm/lmb.h>
+#include <asm/udbg.h>
 
 #include "pmac.h"
 
@@ -322,16 +323,6 @@ void __init pmac_setup_arch(void)
 	l2cr_init();
 #endif /* CONFIG_PPC32 */
 
-#ifdef CONFIG_PPC64
-	/* Probe motherboard chipset */
-	/* this is done earlier in setup_arch for 32-bit */
-	pmac_feature_init();
-
-	/* We can NAP */
-	powersave_nap = 1;
-	printk(KERN_INFO "Using native/NAP idle loop\n");
-#endif
-
 #ifdef CONFIG_KGDB
 	zs_kgdb_hook(0);
 #endif
@@ -622,13 +613,26 @@ static void __init pmac_init_early(void)
 	 * and call ioremap
 	 */
 	hpte_init_native();
+#endif
 
-	/* Init SCC */
-	if (strstr(cmd_line, "sccdbg")) {
-		sccdbg = 1;
-		udbg_init_scc(NULL);
+	/* Enable early btext debug if requested */
+	if (strstr(cmd_line, "btextdbg")) {
+		udbg_adb_init_early();
+		register_early_udbg_console();
 	}
 
+	/* Probe motherboard chipset */
+	pmac_feature_init();
+
+	/* We can NAP */
+	powersave_nap = 1;
+	printk(KERN_INFO "Using native/NAP idle loop\n");
+
+	/* Initialize debug stuff */
+	udbg_scc_init(!!strstr(cmd_line, "sccdbg"));
+	udbg_adb_init(!!strstr(cmd_line, "btextdbg"));
+
+#ifdef CONFIG_PPC64
 	/* Setup interrupt mapping options */
 	ppc64_interrupt_controller = IC_OPEN_PIC;
 
@@ -638,19 +642,8 @@ static void __init pmac_init_early(void)
 
 static void __init pmac_progress(char *s, unsigned short hex)
 {
-#ifdef CONFIG_PPC64
-	if (sccdbg) {
-		udbg_puts(s);
-		udbg_puts("\n");
-		return;
-	}
-#endif
-#ifdef CONFIG_BOOTX_TEXT
-	if (boot_text_mapped) {
-		btext_drawstring(s);
-		btext_drawchar('\n');
-	}
-#endif /* CONFIG_BOOTX_TEXT */
+	udbg_puts(s);
+	udbg_puts("\n");
 }
 
 /*
@@ -735,7 +728,8 @@ static int __init pmac_probe(int platform)
 }
 
 #ifdef CONFIG_PPC64
-static int pmac_probe_mode(struct pci_bus *bus)
+/* Move that to pci.c */
+static int pmac_pci_probe_mode(struct pci_bus *bus)
 {
 	struct device_node *node = bus->sysdata;
 
@@ -771,7 +765,7 @@ struct machdep_calls __initdata pmac_md = {
 	.check_legacy_ioport	= pmac_check_legacy_ioport,
 	.progress		= pmac_progress,
 #ifdef CONFIG_PPC64
-	.pci_probe_mode		= pmac_probe_mode,
+	.pci_probe_mode		= pmac_pci_probe_mode,
 	.idle_loop		= native_idle,
 	.enable_pmcs		= power4_enable_pmcs,
 #ifdef CONFIG_KEXEC

commit 3d1229d6ae92ed1994f4411b8493327ef8f4b76f
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Mon Nov 14 23:35:00 2005 +1100

    [PATCH] powerpc: Merge kexec
    
    This patch merges, to some extent, the PPC32 and PPC64 kexec implementations.
    
    We adopt the PPC32 approach of having ppc_md callbacks for the kexec functions.
    The current PPC64 implementation becomes the "default" implementation for PPC64
    which platforms can select if they need no special treatment.
    
    I've added these default callbacks to pseries/maple/cell/powermac, this means
    iSeries no longer supports kexec - but it never worked anyway.
    
    I've renamed PPC32's machine_kexec_simple to default_machine_kexec, inline with
    PPC64. Judging by the comments it might be better named machine_kexec_non_of,
    or something, but at the moment it's the only implementation for PPC32 so it's
    the "default".
    
    Kexec requires machine_shutdown(), which is in machine_kexec.c on PPC32, but we
    already have in setup-common.c on powerpc. All this does is call
    ppc_md.nvram_sync, which only powermac implements, so instead make
    machine_shutdown a ppc_md member and have it call core99_nvram_sync directly
    on powermac.
    
    I've also stuck relocate_kernel.S into misc_32.S for powerpc.
    
    Built for ARCH=ppc, and 32 & 64 bit ARCH=powerpc, with KEXEC=y/n. Booted on
    P5 LPAR and successfully kexec'ed.
    
    Should apply on top of 493f25ef4087395891c99fcfe2c72e62e293e89f.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 7acb0546671f..3b7a492d9b68 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -60,6 +60,7 @@
 #include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/io.h>
+#include <asm/kexec.h>
 #include <asm/pci-bridge.h>
 #include <asm/ohare.h>
 #include <asm/mediabay.h>
@@ -773,7 +774,11 @@ struct machdep_calls __initdata pmac_md = {
 	.pci_probe_mode		= pmac_probe_mode,
 	.idle_loop		= native_idle,
 	.enable_pmcs		= power4_enable_pmcs,
+#ifdef CONFIG_KEXEC
+	.machine_kexec		= default_machine_kexec,
+	.machine_kexec_prepare	= default_machine_kexec_prepare,
 #endif
+#endif /* CONFIG_PPC64 */
 #ifdef CONFIG_PPC32
 	.pcibios_enable_device_hook = pmac_pci_enable_device_hook,
 	.pcibios_after_init	= pmac_pcibios_after_init,

commit 4350147a816b9c5b40fa59e4fa23f17490630b79
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Nov 7 14:27:33 2005 +1100

    [PATCH] ppc64: SMU based macs cpufreq support
    
    CPU freq support using 970FX powertune facility for iMac G5 and SMU
    based single CPU desktop.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 80b58c1ec412..7acb0546671f 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -193,18 +193,6 @@ static void pmac_show_cpuinfo(struct seq_file *m)
 		   pmac_newworld ? "NewWorld" : "OldWorld");
 }
 
-static void pmac_show_percpuinfo(struct seq_file *m, int i)
-{
-#ifdef CONFIG_CPU_FREQ_PMAC
-	extern unsigned int pmac_get_one_cpufreq(int i);
-	unsigned int freq = pmac_get_one_cpufreq(i);
-	if (freq != 0) {
-		seq_printf(m, "clock\t\t: %dMHz\n", freq/1000);
-		return;
-	}
-#endif /* CONFIG_CPU_FREQ_PMAC */
-}
-
 #ifndef CONFIG_ADB_CUDA
 int find_via_cuda(void)
 {
@@ -767,7 +755,6 @@ struct machdep_calls __initdata pmac_md = {
 	.setup_arch		= pmac_setup_arch,
 	.init_early		= pmac_init_early,
 	.show_cpuinfo		= pmac_show_cpuinfo,
-	.show_percpuinfo	= pmac_show_percpuinfo,
 	.init_IRQ		= pmac_pic_init,
 	.get_irq		= mpic_get_irq,	/* changed later */
 	.pcibios_fixup		= pmac_pcibios_fixup,

commit 91c33d28cda0d3ee1df0cdf399610dbb4e846a45
Author: David Woodhouse <dwmw2@infradead.org>
Date:   Wed Nov 2 16:54:46 2005 +0000

    [PATCH] powerpc: always init nvram on 64-bit powermac
    
    Currently there is no Kconfig symbol to indicate that we want nvram
    support on 64-bit kernels; it's assumed we always want it, so make
    the powermac setup code always initialize the pmac nvram code if
    64-bit.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index d8bdaaf74c9b..80b58c1ec412 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -351,7 +351,7 @@ void __init pmac_setup_arch(void)
 	find_via_pmu();
 	smu_init();
 
-#ifdef CONFIG_NVRAM
+#if defined(CONFIG_NVRAM) || defined(CONFIG_PPC64)
 	pmac_nvram_init();
 #endif
 

commit fbf1769d08a8b085834dceb228540153ac2cd534
Author: Paul Mackerras <paulus@samba.org>
Date:   Wed Nov 2 16:07:22 2005 +1100

    powerpc: include lmb.h in arch/powerpc/platforms/powermac/setup.c
    
    since it uses the lmb stuff in one place.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 6f62af597291..d8bdaaf74c9b 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -75,6 +75,7 @@
 #include <asm/smu.h>
 #include <asm/pmc.h>
 #include <asm/mpic.h>
+#include <asm/lmb.h>
 
 #include "pmac.h"
 

commit bfab1019b7e8b499dfc471a0dfc98b587420dda9
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Oct 27 22:45:33 2005 +1000

    powerpc: Fix new-world powermac detection
    
    My G5 was being reported as an OldWorld in /proc/cpuinfo, which is
    obviously not right... :)
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 72cd503d3d33..6f62af597291 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -317,7 +317,9 @@ void __init pmac_setup_arch(void)
 	}
 
 	/* See if newworld or oldworld */
-	ic = of_find_node_by_name(NULL, "interrupt-controller");
+	for (ic = NULL; (ic = of_find_all_nodes(ic)) != NULL; )
+		if (get_property(ic, "interrupt-controller", NULL))
+			break;
 	pmac_newworld = (ic != NULL);
 	if (ic)
 		of_node_put(ic);

commit 6d7f58b04d824843f7539a132e1ad8220bbe589a
Author: Kumar Gala <galak@freescale.com>
Date:   Tue Oct 25 23:57:33 2005 -0500

    [PATCH] powerpc: Some minor cleanups to setup_32.c
    
    * Removed of_show_percpuinfo and just report CPU frequency in generic
      show_cpuinfo code.
    * Killed OCP and PPC_SYS related code which doesn't belong in the
      merge tree
    
    Signed-off-by: Kumar K. Gala <kumar.gala@freescale.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 908e4921bac4..72cd503d3d33 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -202,9 +202,6 @@ static void pmac_show_percpuinfo(struct seq_file *m, int i)
 		return;
 	}
 #endif /* CONFIG_CPU_FREQ_PMAC */
-#ifdef CONFIG_PPC32
-	of_show_percpuinfo(m, i);
-#endif
 }
 
 #ifndef CONFIG_ADB_CUDA

commit a575b807172ca7d8850e6e979c8e83d4258e8c43
Author: Paul Mackerras <paulus@samba.org>
Date:   Sun Oct 23 17:23:21 2005 +1000

    powerpc: Run on old powermacs.
    
    Old powermacs have a number of differences from current machines:
    - there is no interrupt tree in the device tree, just interrupt
      or AAPL,interrupt properties
    - the chosen node in the device tree is called /chosen@0
    - the OF claim method doesn't map the memory, so we have to do
      an explicit map call as well
    - there is no /chosen/cpu property on SMP machines
    - the NVRAM isn't structured as a set of partitions.
    
    This adapts the merged powermac support code to cope with these
    issues.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 50f5dd787900..908e4921bac4 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -225,7 +225,7 @@ int find_via_pmu(void)
 		return 0;
 	printk("WARNING ! Your machine is PMU-based but your kernel\n");
 	printk("          wasn't compiled with CONFIG_ADB_PMU option !\n");
-	return;
+	return 0;
 }
 #endif
 
@@ -293,7 +293,7 @@ static void __init l2cr_init(void)
 
 void __init pmac_setup_arch(void)
 {
-	struct device_node *cpu;
+	struct device_node *cpu, *ic;
 	int *fp;
 	unsigned long pvr;
 
@@ -319,6 +319,12 @@ void __init pmac_setup_arch(void)
 		of_node_put(cpu);
 	}
 
+	/* See if newworld or oldworld */
+	ic = of_find_node_by_name(NULL, "interrupt-controller");
+	pmac_newworld = (ic != NULL);
+	if (ic)
+		of_node_put(ic);
+
 	/* Lookup PCI hosts */
 	pmac_pci_init();
 

commit 985990137e81ca9fd6561cd0f7d1a9695ec57d5a
Merge: 834289447542 63172cb3d5ef
Author: Paul Mackerras <paulus@samba.org>
Date:   Sat Oct 22 16:51:34 2005 +1000

    Merge changes from linux-2.6 by hand

commit 35499c0195e46f479cf6ac16ad8d3f394b5fcc10
Author: Paul Mackerras <paulus@samba.org>
Date:   Sat Oct 22 16:02:39 2005 +1000

    powerpc: Merge in 64-bit powermac support.
    
    This brings in a lot of changes from arch/ppc64/kernel/pmac_*.c to
    arch/powerpc/platforms/powermac/*.c and makes various minor tweaks
    elsewhere.  On the powermac we now initialize ppc_md by copying
    the whole pmac_md structure into it, which required some changes in
    the ordering of initializations of individual fields of it.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 0bad53fa36ef..da0cb165dfc6 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -1,11 +1,11 @@
 /*
- *  arch/ppc/platforms/setup.c
+ *  Powermac setup and early boot code plus other random bits.
  *
  *  PowerPC version
  *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)
  *
  *  Adapted for Power Macintosh by Paul Mackerras
- *    Copyright (C) 1996 Paul Mackerras (paulus@cs.anu.edu.au)
+ *    Copyright (C) 1996 Paul Mackerras (paulus@samba.org)
  *
  *  Derived from "arch/alpha/kernel/setup.c"
  *    Copyright (C) 1995 Linus Torvalds
@@ -65,13 +65,16 @@
 #include <asm/mediabay.h>
 #include <asm/machdep.h>
 #include <asm/dma.h>
-#include <asm/bootx.h>
 #include <asm/cputable.h>
 #include <asm/btext.h>
 #include <asm/pmac_feature.h>
 #include <asm/time.h>
 #include <asm/of_device.h>
 #include <asm/mmu_context.h>
+#include <asm/iommu.h>
+#include <asm/smu.h>
+#include <asm/pmc.h>
+#include <asm/mpic.h>
 
 #include "pmac.h"
 
@@ -88,16 +91,24 @@ int pmac_newworld = 1;
 static int current_root_goodness = -1;
 
 extern int pmac_newworld;
+extern struct machdep_calls pmac_md;
 
 #define DEFAULT_ROOT_DEVICE Root_SDA1	/* sda1 - slightly silly choice */
 
-extern void zs_kgdb_hook(int tty_num);
-static void ohare_init(void);
-#ifdef CONFIG_BOOTX_TEXT
-static void pmac_progress(char *s, unsigned short hex);
+#ifdef CONFIG_PPC64
+#include <asm/udbg.h>
+int sccdbg;
 #endif
 
+extern void zs_kgdb_hook(int tty_num);
+
 sys_ctrler_t sys_ctrler = SYS_CTRLER_UNKNOWN;
+EXPORT_SYMBOL(sys_ctrler);
+
+#ifdef CONFIG_PMAC_SMU
+unsigned long smu_cmdbuf_abs;
+EXPORT_SYMBOL(smu_cmdbuf_abs);
+#endif
 
 #ifdef CONFIG_SMP
 extern struct smp_ops_t psurge_smp_ops;
@@ -191,44 +202,69 @@ static void pmac_show_percpuinfo(struct seq_file *m, int i)
 		return;
 	}
 #endif /* CONFIG_CPU_FREQ_PMAC */
+#ifdef CONFIG_PPC32
 	of_show_percpuinfo(m, i);
+#endif
 }
 
-static volatile u32 *sysctrl_regs;
+#ifndef CONFIG_ADB_CUDA
+int find_via_cuda(void)
+{
+	if (!find_devices("via-cuda"))
+		return 0;
+	printk("WARNING ! Your machine is CUDA-based but your kernel\n");
+	printk("          wasn't compiled with CONFIG_ADB_CUDA option !\n");
+	return 0;
+}
+#endif
 
-void __init
-pmac_setup_arch(void)
+#ifndef CONFIG_ADB_PMU
+int find_via_pmu(void)
 {
-	struct device_node *cpu;
-	int *fp;
-	unsigned long pvr;
+	if (!find_devices("via-pmu"))
+		return 0;
+	printk("WARNING ! Your machine is PMU-based but your kernel\n");
+	printk("          wasn't compiled with CONFIG_ADB_PMU option !\n");
+	return;
+}
+#endif
 
-	pvr = PVR_VER(mfspr(SPRN_PVR));
+#ifndef CONFIG_PMAC_SMU
+int smu_init(void)
+{
+	/* should check and warn if SMU is present */
+	return 0;
+}
+#endif
 
-	/* Set loops_per_jiffy to a half-way reasonable value,
-	   for use until calibrate_delay gets called. */
-	cpu = find_type_devices("cpu");
-	if (cpu != 0) {
-		fp = (int *) get_property(cpu, "clock-frequency", NULL);
-		if (fp != 0) {
-			if (pvr == 4 || pvr >= 8)
-				/* 604, G3, G4 etc. */
-				loops_per_jiffy = *fp / HZ;
-			else
-				/* 601, 603, etc. */
-				loops_per_jiffy = *fp / (2*HZ);
-		} else
-			loops_per_jiffy = 50000000 / HZ;
-	}
+#ifdef CONFIG_PPC32
+static volatile u32 *sysctrl_regs;
 
+static void __init ohare_init(void)
+{
 	/* this area has the CPU identification register
 	   and some registers used by smp boards */
 	sysctrl_regs = (volatile u32 *) ioremap(0xf8000000, 0x1000);
-	ohare_init();
 
-	/* Lookup PCI hosts */
-	pmac_find_bridges();
+	/*
+	 * Turn on the L2 cache.
+	 * We assume that we have a PSX memory controller iff
+	 * we have an ohare I/O controller.
+	 */
+	if (find_devices("ohare") != NULL) {
+		if (((sysctrl_regs[2] >> 24) & 0xf) >= 3) {
+			if (sysctrl_regs[4] & 0x10)
+				sysctrl_regs[4] |= 0x04000020;
+			else
+				sysctrl_regs[4] |= 0x04000000;
+			if(has_l2cache)
+				printk(KERN_INFO "Level 2 cache enabled\n");
+		}
+	}
+}
 
+static void __init l2cr_init(void)
+{
 	/* Checks "l2cr-value" property in the registry */
 	if (cpu_has_feature(CPU_FTR_L2CR)) {
 		struct device_node *np = find_devices("cpus");
@@ -247,68 +283,90 @@ pmac_setup_arch(void)
 	}
 
 	if (ppc_override_l2cr)
-		printk(KERN_INFO "L2CR overriden (0x%x), backside cache is %s\n",
-			ppc_override_l2cr_value, (ppc_override_l2cr_value & 0x80000000)
+		printk(KERN_INFO "L2CR overridden (0x%x), "
+		       "backside cache is %s\n",
+		       ppc_override_l2cr_value,
+		       (ppc_override_l2cr_value & 0x80000000)
 				? "enabled" : "disabled");
+}
+#endif
+
+void __init pmac_setup_arch(void)
+{
+	struct device_node *cpu;
+	int *fp;
+	unsigned long pvr;
+
+	pvr = PVR_VER(mfspr(SPRN_PVR));
+
+	/* Set loops_per_jiffy to a half-way reasonable value,
+	   for use until calibrate_delay gets called. */
+	loops_per_jiffy = 50000000 / HZ;
+	cpu = of_find_node_by_type(NULL, "cpu");
+	if (cpu != NULL) {
+		fp = (int *) get_property(cpu, "clock-frequency", NULL);
+		if (fp != NULL) {
+			if (pvr >= 0x30 && pvr < 0x80)
+				/* PPC970 etc. */
+				loops_per_jiffy = *fp / (3 * HZ);
+			else if (pvr == 4 || pvr >= 8)
+				/* 604, G3, G4 etc. */
+				loops_per_jiffy = *fp / HZ;
+			else
+				/* 601, 603, etc. */
+				loops_per_jiffy = *fp / (2 * HZ);
+		}
+		of_node_put(cpu);
+	}
+
+	/* Lookup PCI hosts */
+	pmac_pci_init();
+
+#ifdef CONFIG_PPC32
+	ohare_init();
+	l2cr_init();
+#endif /* CONFIG_PPC32 */
+
+#ifdef CONFIG_PPC64
+	/* Probe motherboard chipset */
+	/* this is done earlier in setup_arch for 32-bit */
+	pmac_feature_init();
+
+	/* We can NAP */
+	powersave_nap = 1;
+	printk(KERN_INFO "Using native/NAP idle loop\n");
+#endif
 
 #ifdef CONFIG_KGDB
 	zs_kgdb_hook(0);
 #endif
 
-#ifdef CONFIG_ADB_CUDA
 	find_via_cuda();
-#else
-	if (find_devices("via-cuda")) {
-		printk("WARNING ! Your machine is Cuda based but your kernel\n");
-		printk("          wasn't compiled with CONFIG_ADB_CUDA option !\n");
-	}
-#endif
-#ifdef CONFIG_ADB_PMU
 	find_via_pmu();
-#else
-	if (find_devices("via-pmu")) {
-		printk("WARNING ! Your machine is PMU based but your kernel\n");
-		printk("          wasn't compiled with CONFIG_ADB_PMU option !\n");
-	}
-#endif
+	smu_init();
+
 #ifdef CONFIG_NVRAM
 	pmac_nvram_init();
 #endif
+
+#ifdef CONFIG_PPC32
 #ifdef CONFIG_BLK_DEV_INITRD
 	if (initrd_start)
 		ROOT_DEV = Root_RAM0;
 	else
 #endif
 		ROOT_DEV = DEFAULT_ROOT_DEVICE;
+#endif
 
 #ifdef CONFIG_SMP
 	/* Check for Core99 */
 	if (find_devices("uni-n") || find_devices("u3"))
 		smp_ops = &core99_smp_ops;
+#ifdef CONFIG_PPC32
 	else
 		smp_ops = &psurge_smp_ops;
+#endif
 #endif /* CONFIG_SMP */
-
-	pci_create_OF_bus_map();
-}
-
-static void __init ohare_init(void)
-{
-	/*
-	 * Turn on the L2 cache.
-	 * We assume that we have a PSX memory controller iff
-	 * we have an ohare I/O controller.
-	 */
-	if (find_devices("ohare") != NULL) {
-		if (((sysctrl_regs[2] >> 24) & 0xf) >= 3) {
-			if (sysctrl_regs[4] & 0x10)
-				sysctrl_regs[4] |= 0x04000020;
-			else
-				sysctrl_regs[4] |= 0x04000000;
-			if(has_l2cache)
-				printk(KERN_INFO "Level 2 cache enabled\n");
-		}
-	}
 }
 
 char *bootpath;
@@ -319,8 +377,7 @@ int boot_part;
 extern dev_t boot_dev;
 
 #ifdef CONFIG_SCSI
-void __init
-note_scsi_host(struct device_node *node, void *host)
+void __init note_scsi_host(struct device_node *node, void *host)
 {
 	int l;
 	char *p;
@@ -351,8 +408,7 @@ EXPORT_SYMBOL(note_scsi_host);
 #endif
 
 #if defined(CONFIG_BLK_DEV_IDE) && defined(CONFIG_BLK_DEV_IDE_PMAC)
-static dev_t __init
-find_ide_boot(void)
+static dev_t __init find_ide_boot(void)
 {
 	char *p;
 	int n;
@@ -369,15 +425,13 @@ find_ide_boot(void)
 }
 #endif /* CONFIG_BLK_DEV_IDE && CONFIG_BLK_DEV_IDE_PMAC */
 
-static void __init
-find_boot_device(void)
+static void __init find_boot_device(void)
 {
 #if defined(CONFIG_BLK_DEV_IDE) && defined(CONFIG_BLK_DEV_IDE_PMAC)
 	boot_dev = find_ide_boot();
 #endif
 }
 
-static int initializing = 1;
 /* TODO: Merge the suspend-to-ram with the common code !!!
  * currently, this is a stub implementation for suspend-to-disk
  * only
@@ -428,6 +482,8 @@ static struct pm_ops pmac_pm_ops = {
 
 #endif /* CONFIG_SOFTWARE_SUSPEND */
 
+static int initializing = 1;
+
 static int pmac_late_init(void)
 {
 	initializing = 0;
@@ -440,8 +496,7 @@ static int pmac_late_init(void)
 late_initcall(pmac_late_init);
 
 /* can't be __init - can be called whenever a disk is first accessed */
-void
-note_bootable_part(dev_t dev, int part, int goodness)
+void note_bootable_part(dev_t dev, int part, int goodness)
 {
 	static int found_boot = 0;
 	char *p;
@@ -466,52 +521,68 @@ note_bootable_part(dev_t dev, int part, int goodness)
 	}
 }
 
-static void
-pmac_restart(char *cmd)
-{
 #ifdef CONFIG_ADB_CUDA
+static void cuda_restart(void)
+{
 	struct adb_request req;
-#endif /* CONFIG_ADB_CUDA */
 
+	cuda_request(&req, NULL, 2, CUDA_PACKET, CUDA_RESET_SYSTEM);
+	for (;;)
+		cuda_poll();
+}
+
+static void cuda_shutdown(void)
+{
+	struct adb_request req;
+
+	cuda_request(&req, NULL, 2, CUDA_PACKET, CUDA_POWERDOWN);
+	for (;;)
+		cuda_poll();
+}
+
+#else
+#define cuda_restart()
+#define cuda_shutdown()
+#endif
+
+#ifndef CONFIG_ADB_PMU
+#define pmu_restart()
+#define pmu_shutdown()
+#endif
+
+#ifndef CONFIG_PMAC_SMU
+#define smu_restart()
+#define smu_shutdown()
+#endif
+
+static void pmac_restart(char *cmd)
+{
 	switch (sys_ctrler) {
-#ifdef CONFIG_ADB_CUDA
 	case SYS_CTRLER_CUDA:
-		cuda_request(&req, NULL, 2, CUDA_PACKET,
-			     CUDA_RESET_SYSTEM);
-		for (;;)
-			cuda_poll();
+		cuda_restart();
 		break;
-#endif /* CONFIG_ADB_CUDA */
-#ifdef CONFIG_ADB_PMU
 	case SYS_CTRLER_PMU:
 		pmu_restart();
 		break;
-#endif /* CONFIG_ADB_PMU */
+	case SYS_CTRLER_SMU:
+		smu_restart();
+		break;
 	default: ;
 	}
 }
 
-static void
-pmac_power_off(void)
+static void pmac_power_off(void)
 {
-#ifdef CONFIG_ADB_CUDA
-	struct adb_request req;
-#endif /* CONFIG_ADB_CUDA */
-
 	switch (sys_ctrler) {
-#ifdef CONFIG_ADB_CUDA
 	case SYS_CTRLER_CUDA:
-		cuda_request(&req, NULL, 2, CUDA_PACKET,
-			     CUDA_POWERDOWN);
-		for (;;)
-			cuda_poll();
+		cuda_shutdown();
 		break;
-#endif /* CONFIG_ADB_CUDA */
-#ifdef CONFIG_ADB_PMU
 	case SYS_CTRLER_PMU:
 		pmu_shutdown();
 		break;
-#endif /* CONFIG_ADB_PMU */
+	case SYS_CTRLER_SMU:
+		smu_shutdown();
+		break;
 	default: ;
 	}
 }
@@ -522,37 +593,17 @@ pmac_halt(void)
 	pmac_power_off();
 }
 
+#ifdef CONFIG_PPC32
 void __init pmac_init(void)
 {
-	/* isa_io_base gets set in pmac_find_bridges */
+	/* isa_io_base gets set in pmac_pci_init */
 	isa_mem_base = PMAC_ISA_MEM_BASE;
 	pci_dram_offset = PMAC_PCI_DRAM_OFFSET;
 	ISA_DMA_THRESHOLD = ~0L;
 	DMA_MODE_READ = 1;
 	DMA_MODE_WRITE = 2;
 
-	ppc_md.setup_arch     = pmac_setup_arch;
-	ppc_md.show_cpuinfo   = pmac_show_cpuinfo;
-	ppc_md.show_percpuinfo = pmac_show_percpuinfo;
-	ppc_md.init_IRQ       = pmac_pic_init;
-	ppc_md.get_irq        = pmac_get_irq; /* Changed later on ... */
-
-	ppc_md.pcibios_fixup  = pmac_pcibios_fixup;
-	ppc_md.pcibios_enable_device_hook = pmac_pci_enable_device_hook;
-	ppc_md.pcibios_after_init = pmac_pcibios_after_init;
-	ppc_md.phys_mem_access_prot = pci_phys_mem_access_prot;
-
-	ppc_md.restart        = pmac_restart;
-	ppc_md.power_off      = pmac_power_off;
-	ppc_md.halt           = pmac_halt;
-
-	ppc_md.time_init      = pmac_time_init;
-	ppc_md.set_rtc_time   = pmac_set_rtc_time;
-	ppc_md.get_rtc_time   = pmac_get_rtc_time;
-	ppc_md.get_boot_time  = pmac_get_boot_time;
-	ppc_md.calibrate_decr = pmac_calibrate_decr;
-
-	ppc_md.feature_call   = pmac_do_feature_call;
+	ppc_md = pmac_md;
 
 #if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
 #ifdef CONFIG_BLK_DEV_IDE_PMAC
@@ -561,27 +612,62 @@ void __init pmac_init(void)
 #endif /* CONFIG_BLK_DEV_IDE_PMAC */
 #endif /* defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE) */
 
-#ifdef CONFIG_BOOTX_TEXT
-	ppc_md.progress = pmac_progress;
-#endif /* CONFIG_BOOTX_TEXT */
-
 	if (ppc_md.progress) ppc_md.progress("pmac_init(): exit", 0);
 
 }
+#endif
 
-#ifdef CONFIG_BOOTX_TEXT
-static void __init
-pmac_progress(char *s, unsigned short hex)
+/* 
+ * Early initialization.
+ */
+static void __init pmac_init_early(void)
+{
+#ifdef CONFIG_PPC64
+	/* Initialize hash table, from now on, we can take hash faults
+	 * and call ioremap
+	 */
+	hpte_init_native();
+
+	/* Init SCC */
+	if (strstr(cmd_line, "sccdbg")) {
+		sccdbg = 1;
+		udbg_init_scc(NULL);
+	}
+
+	/* Setup interrupt mapping options */
+	ppc64_interrupt_controller = IC_OPEN_PIC;
+
+	iommu_init_early_u3();
+#endif
+}
+
+static void __init pmac_progress(char *s, unsigned short hex)
 {
+#ifdef CONFIG_PPC64
+	if (sccdbg) {
+		udbg_puts(s);
+		udbg_puts("\n");
+		return;
+	}
+#endif
+#ifdef CONFIG_BOOTX_TEXT
 	if (boot_text_mapped) {
 		btext_drawstring(s);
 		btext_drawchar('\n');
 	}
-}
 #endif /* CONFIG_BOOTX_TEXT */
+}
 
-static int __init
-pmac_declare_of_platform_devices(void)
+/*
+ * pmac has no legacy IO, anything calling this function has to
+ * fail or bad things will happen
+ */
+static int pmac_check_legacy_ioport(unsigned int baseport)
+{
+	return -ENODEV;
+}
+
+static int __init pmac_declare_of_platform_devices(void)
 {
 	struct device_node *np;
 
@@ -594,6 +680,13 @@ pmac_declare_of_platform_devices(void)
 				break;
 			}
 	}
+	np = find_devices("valkyrie");
+	if (np)
+		of_platform_device_create(np, "valkyrie", NULL);
+	np = find_devices("platinum");
+	if (np)
+		of_platform_device_create(np, "platinum", NULL);
+
 	np = find_devices("u3");
 	if (np) {
 		for (np = np->child; np != NULL; np = np->sibling)
@@ -603,15 +696,92 @@ pmac_declare_of_platform_devices(void)
 				break;
 			}
 	}
-
-	np = find_devices("valkyrie");
-	if (np)
-		of_platform_device_create(np, "valkyrie", NULL);
-	np = find_devices("platinum");
-	if (np)
-		of_platform_device_create(np, "platinum", NULL);
+        np = of_find_node_by_type(NULL, "smu");
+        if (np) {
+		of_platform_device_create(np, "smu", NULL);
+		of_node_put(np);
+	}
 
 	return 0;
 }
 
 device_initcall(pmac_declare_of_platform_devices);
+
+/*
+ * Called very early, MMU is off, device-tree isn't unflattened
+ */
+static int __init pmac_probe(int platform)
+{
+#ifdef CONFIG_PPC64
+	if (platform != PLATFORM_POWERMAC)
+		return 0;
+
+	/*
+	 * On U3, the DART (iommu) must be allocated now since it
+	 * has an impact on htab_initialize (due to the large page it
+	 * occupies having to be broken up so the DART itself is not
+	 * part of the cacheable linar mapping
+	 */
+	alloc_u3_dart_table();
+#endif
+
+#ifdef CONFIG_PMAC_SMU
+	/*
+	 * SMU based G5s need some memory below 2Gb, at least the current
+	 * driver needs that. We have to allocate it now. We allocate 4k
+	 * (1 small page) for now.
+	 */
+	smu_cmdbuf_abs = lmb_alloc_base(4096, 4096, 0x80000000UL);
+#endif /* CONFIG_PMAC_SMU */
+
+	return 1;
+}
+
+#ifdef CONFIG_PPC64
+static int pmac_probe_mode(struct pci_bus *bus)
+{
+	struct device_node *node = bus->sysdata;
+
+	/* We need to use normal PCI probing for the AGP bus,
+	   since the device for the AGP bridge isn't in the tree. */
+	if (bus->self == NULL && device_is_compatible(node, "u3-agp"))
+		return PCI_PROBE_NORMAL;
+
+	return PCI_PROBE_DEVTREE;
+}
+#endif
+
+struct machdep_calls __initdata pmac_md = {
+#if defined(CONFIG_HOTPLUG_CPU) && defined(CONFIG_PPC64)
+	.cpu_die		= generic_mach_cpu_die,
+#endif
+	.probe			= pmac_probe,
+	.setup_arch		= pmac_setup_arch,
+	.init_early		= pmac_init_early,
+	.show_cpuinfo		= pmac_show_cpuinfo,
+	.show_percpuinfo	= pmac_show_percpuinfo,
+	.init_IRQ		= pmac_pic_init,
+	.get_irq		= mpic_get_irq,	/* changed later */
+	.pcibios_fixup		= pmac_pcibios_fixup,
+	.restart		= pmac_restart,
+	.power_off		= pmac_power_off,
+	.halt			= pmac_halt,
+	.time_init		= pmac_time_init,
+	.get_boot_time		= pmac_get_boot_time,
+	.set_rtc_time		= pmac_set_rtc_time,
+	.get_rtc_time		= pmac_get_rtc_time,
+	.calibrate_decr		= pmac_calibrate_decr,
+	.feature_call		= pmac_do_feature_call,
+	.check_legacy_ioport	= pmac_check_legacy_ioport,
+	.progress		= pmac_progress,
+#ifdef CONFIG_PPC64
+	.pci_probe_mode		= pmac_probe_mode,
+	.idle_loop		= native_idle,
+	.enable_pmcs		= power4_enable_pmcs,
+#endif
+#ifdef CONFIG_PPC32
+	.pcibios_enable_device_hook = pmac_pci_enable_device_hook,
+	.pcibios_after_init	= pmac_pcibios_after_init,
+	.phys_mem_access_prot	= pci_phys_mem_access_prot,
+#endif
+};

commit 0dd194d02d2584c34e06ddd26c7a7896a5fa1974
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Oct 20 20:48:19 2005 +1000

    powerpc: Fix places where ppc_md.show_[per]cpuinfo was treated as int
    
    I missed a few places where ppc code was still assuming that the
    ppc_md.show_[per]cpuinfo functions returned int.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index b6414e7c37d4..0bad53fa36ef 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -104,24 +104,26 @@ extern struct smp_ops_t psurge_smp_ops;
 extern struct smp_ops_t core99_smp_ops;
 #endif /* CONFIG_SMP */
 
-static int
-pmac_show_cpuinfo(struct seq_file *m)
+static void pmac_show_cpuinfo(struct seq_file *m)
 {
 	struct device_node *np;
 	char *pp;
 	int plen;
-	int mbmodel = pmac_call_feature(PMAC_FTR_GET_MB_INFO,
-		NULL, PMAC_MB_INFO_MODEL, 0);
-	unsigned int mbflags = (unsigned int)pmac_call_feature(PMAC_FTR_GET_MB_INFO,
-		NULL, PMAC_MB_INFO_FLAGS, 0);
+	int mbmodel;
+	unsigned int mbflags;
 	char* mbname;
 
-	if (pmac_call_feature(PMAC_FTR_GET_MB_INFO, NULL, PMAC_MB_INFO_NAME, (int)&mbname) != 0)
+	mbmodel = pmac_call_feature(PMAC_FTR_GET_MB_INFO, NULL,
+				    PMAC_MB_INFO_MODEL, 0);
+	mbflags = pmac_call_feature(PMAC_FTR_GET_MB_INFO, NULL,
+				    PMAC_MB_INFO_FLAGS, 0);
+	if (pmac_call_feature(PMAC_FTR_GET_MB_INFO, NULL, PMAC_MB_INFO_NAME,
+			      (long) &mbname) != 0)
 		mbname = "Unknown";
 
 	/* find motherboard type */
 	seq_printf(m, "machine\t\t: ");
-	np = find_devices("device-tree");
+	np = of_find_node_by_path("/");
 	if (np != NULL) {
 		pp = (char *) get_property(np, "model", NULL);
 		if (pp != NULL)
@@ -139,6 +141,7 @@ pmac_show_cpuinfo(struct seq_file *m)
 			}
 			seq_printf(m, "\n");
 		}
+		of_node_put(np);
 	} else
 		seq_printf(m, "PowerMac\n");
 
@@ -147,10 +150,10 @@ pmac_show_cpuinfo(struct seq_file *m)
 	seq_printf(m, "pmac flags\t: %08x\n", mbflags);
 
 	/* find l2 cache info */
-	np = find_devices("l2-cache");
-	if (np == 0)
-		np = find_type_devices("cache");
-	if (np != 0) {
+	np = of_find_node_by_name(NULL, "l2-cache");
+	if (np == NULL)
+		np = of_find_node_by_type(NULL, "cache");
+	if (np != NULL) {
 		unsigned int *ic = (unsigned int *)
 			get_property(np, "i-cache-size", NULL);
 		unsigned int *dc = (unsigned int *)
@@ -170,56 +173,25 @@ pmac_show_cpuinfo(struct seq_file *m)
 		if (pp)
 			seq_printf(m, " %s", pp);
 		seq_printf(m, "\n");
-	}
-
-	/* find ram info */
-	np = find_devices("memory");
-	if (np != 0) {
-		int n;
-		struct reg_property *reg = (struct reg_property *)
-			get_property(np, "reg", &n);
-
-		if (reg != 0) {
-			unsigned long total = 0;
-
-			for (n /= sizeof(struct reg_property); n > 0; --n)
-				total += (reg++)->size;
-			seq_printf(m, "memory\t\t: %luMB\n", total >> 20);
-		}
-	}
-
-	/* Checks "l2cr-value" property in the registry */
-	np = find_devices("cpus");
-	if (np == 0)
-		np = find_type_devices("cpu");
-	if (np != 0) {
-		unsigned int *l2cr = (unsigned int *)
-			get_property(np, "l2cr-value", NULL);
-		if (l2cr != 0) {
-			seq_printf(m, "l2cr override\t: 0x%x\n", *l2cr);
-		}
+		of_node_put(np);
 	}
 
 	/* Indicate newworld/oldworld */
 	seq_printf(m, "pmac-generation\t: %s\n",
 		   pmac_newworld ? "NewWorld" : "OldWorld");
-
-
-	return 0;
 }
 
-static int
-pmac_show_percpuinfo(struct seq_file *m, int i)
+static void pmac_show_percpuinfo(struct seq_file *m, int i)
 {
 #ifdef CONFIG_CPU_FREQ_PMAC
 	extern unsigned int pmac_get_one_cpufreq(int i);
 	unsigned int freq = pmac_get_one_cpufreq(i);
 	if (freq != 0) {
 		seq_printf(m, "clock\t\t: %dMHz\n", freq/1000);
-		return 0;
+		return;
 	}
 #endif /* CONFIG_CPU_FREQ_PMAC */
-	return of_show_percpuinfo(m, i);
+	of_show_percpuinfo(m, i);
 }
 
 static volatile u32 *sysctrl_regs;

commit 143a1dec7e04e0a9712ff93e779aabfb21dfd97c
Author: Paul Mackerras <paulus@samba.org>
Date:   Wed Oct 19 23:11:21 2005 +1000

    powerpc: Merge machdep.h
    
    A few things change for consistency between ppc32 and ppc64:
    idle functions return void; *_get_boot_time functions return
    unsigned long (i.e. time_t) rather than filling in a struct rtc_time
    (since that's useful to the callers and easier for pmac to
    generate); *_get_rtc_time and *_set_rtc_time functions take
    a struct rtc_time; irq_canonicalize is gone; nvram_sync returns
    void.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 7eb0c34b6994..b6414e7c37d4 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -562,7 +562,6 @@ void __init pmac_init(void)
 	ppc_md.setup_arch     = pmac_setup_arch;
 	ppc_md.show_cpuinfo   = pmac_show_cpuinfo;
 	ppc_md.show_percpuinfo = pmac_show_percpuinfo;
-	ppc_md.irq_canonicalize = NULL;
 	ppc_md.init_IRQ       = pmac_pic_init;
 	ppc_md.get_irq        = pmac_get_irq; /* Changed later on ... */
 
@@ -578,6 +577,7 @@ void __init pmac_init(void)
 	ppc_md.time_init      = pmac_time_init;
 	ppc_md.set_rtc_time   = pmac_set_rtc_time;
 	ppc_md.get_rtc_time   = pmac_get_rtc_time;
+	ppc_md.get_boot_time  = pmac_get_boot_time;
 	ppc_md.calibrate_decr = pmac_calibrate_decr;
 
 	ppc_md.feature_call   = pmac_do_feature_call;

commit 7ed476d17f04473f70d796cb6c172bdcfcc9b8e5
Author: Paul Mackerras <paulus@samba.org>
Date:   Wed Oct 19 21:44:51 2005 +1000

    ppc: Minor smp changes for consistency with ppc64
    
    This makes platform code use the smp_ops variable directly instead
    of ppc_md.smp_ops, removes the two unused `data' and `wait' arguments
    from the *_message_pass() functions, and removes the call to the
    never-implemented smp_ops->space_timers() function.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 9416fcaa6daa..7eb0c34b6994 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -312,9 +312,9 @@ pmac_setup_arch(void)
 #ifdef CONFIG_SMP
 	/* Check for Core99 */
 	if (find_devices("uni-n") || find_devices("u3"))
-		ppc_md.smp_ops = &core99_smp_ops;
+		smp_ops = &core99_smp_ops;
 	else
-		ppc_md.smp_ops = &psurge_smp_ops;
+		smp_ops = &psurge_smp_ops;
 #endif /* CONFIG_SMP */
 
 	pci_create_OF_bus_map();

commit 3c3f42d63a11f2e22dbff6bb4d170f92dbd39316
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Oct 10 22:58:41 2005 +1000

    powerpc: Start merging 64-bit support into powermac files
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
index 1b12bf9956cb..9416fcaa6daa 100644
--- a/arch/powerpc/platforms/powermac/setup.c
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -73,28 +73,10 @@
 #include <asm/of_device.h>
 #include <asm/mmu_context.h>
 
-#include "pmac_pic.h"
+#include "pmac.h"
 
 #undef SHOW_GATWICK_IRQS
 
-extern long pmac_time_init(void);
-extern unsigned long pmac_get_rtc_time(void);
-extern int pmac_set_rtc_time(unsigned long nowtime);
-extern void pmac_read_rtc_time(void);
-extern void pmac_calibrate_decr(void);
-extern void pmac_pcibios_fixup(void);
-extern void pmac_find_bridges(void);
-extern unsigned long pmac_ide_get_base(int index);
-extern void pmac_ide_init_hwif_ports(hw_regs_t *hw,
-	unsigned long data_port, unsigned long ctrl_port, int *irq);
-
-extern void pmac_nvram_update(void);
-extern unsigned char pmac_nvram_read_byte(int addr);
-extern void pmac_nvram_write_byte(int addr, unsigned char val);
-extern int pmac_pci_enable_device_hook(struct pci_dev *dev, int initial);
-extern void pmac_pcibios_after_init(void);
-extern int of_show_percpuinfo(struct seq_file *m, int i);
-
 unsigned char drive_info;
 
 int ppc_override_l2cr = 0;

commit f6d57916db2009bd7e220472200cd131fc010d64
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Oct 10 22:13:53 2005 +1000

    powerpc: rename powermac files to remove pmac_ prefix
    
    Since the files are now in arch/powerpc/platforms/powermac, the
    pmac_ prefix that they had is redundant.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/powermac/setup.c b/arch/powerpc/platforms/powermac/setup.c
new file mode 100644
index 000000000000..1b12bf9956cb
--- /dev/null
+++ b/arch/powerpc/platforms/powermac/setup.c
@@ -0,0 +1,663 @@
+/*
+ *  arch/ppc/platforms/setup.c
+ *
+ *  PowerPC version
+ *    Copyright (C) 1995-1996 Gary Thomas (gdt@linuxppc.org)
+ *
+ *  Adapted for Power Macintosh by Paul Mackerras
+ *    Copyright (C) 1996 Paul Mackerras (paulus@cs.anu.edu.au)
+ *
+ *  Derived from "arch/alpha/kernel/setup.c"
+ *    Copyright (C) 1995 Linus Torvalds
+ *
+ *  Maintained by Benjamin Herrenschmidt (benh@kernel.crashing.org)
+ *
+ *  This program is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU General Public License
+ *  as published by the Free Software Foundation; either version
+ *  2 of the License, or (at your option) any later version.
+ *
+ */
+
+/*
+ * bootup setup stuff..
+ */
+
+#include <linux/config.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/stddef.h>
+#include <linux/unistd.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/user.h>
+#include <linux/a.out.h>
+#include <linux/tty.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+#include <linux/ioport.h>
+#include <linux/major.h>
+#include <linux/initrd.h>
+#include <linux/vt_kern.h>
+#include <linux/console.h>
+#include <linux/ide.h>
+#include <linux/pci.h>
+#include <linux/adb.h>
+#include <linux/cuda.h>
+#include <linux/pmu.h>
+#include <linux/irq.h>
+#include <linux/seq_file.h>
+#include <linux/root_dev.h>
+#include <linux/bitops.h>
+#include <linux/suspend.h>
+
+#include <asm/reg.h>
+#include <asm/sections.h>
+#include <asm/prom.h>
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/io.h>
+#include <asm/pci-bridge.h>
+#include <asm/ohare.h>
+#include <asm/mediabay.h>
+#include <asm/machdep.h>
+#include <asm/dma.h>
+#include <asm/bootx.h>
+#include <asm/cputable.h>
+#include <asm/btext.h>
+#include <asm/pmac_feature.h>
+#include <asm/time.h>
+#include <asm/of_device.h>
+#include <asm/mmu_context.h>
+
+#include "pmac_pic.h"
+
+#undef SHOW_GATWICK_IRQS
+
+extern long pmac_time_init(void);
+extern unsigned long pmac_get_rtc_time(void);
+extern int pmac_set_rtc_time(unsigned long nowtime);
+extern void pmac_read_rtc_time(void);
+extern void pmac_calibrate_decr(void);
+extern void pmac_pcibios_fixup(void);
+extern void pmac_find_bridges(void);
+extern unsigned long pmac_ide_get_base(int index);
+extern void pmac_ide_init_hwif_ports(hw_regs_t *hw,
+	unsigned long data_port, unsigned long ctrl_port, int *irq);
+
+extern void pmac_nvram_update(void);
+extern unsigned char pmac_nvram_read_byte(int addr);
+extern void pmac_nvram_write_byte(int addr, unsigned char val);
+extern int pmac_pci_enable_device_hook(struct pci_dev *dev, int initial);
+extern void pmac_pcibios_after_init(void);
+extern int of_show_percpuinfo(struct seq_file *m, int i);
+
+unsigned char drive_info;
+
+int ppc_override_l2cr = 0;
+int ppc_override_l2cr_value;
+int has_l2cache = 0;
+
+int pmac_newworld = 1;
+
+static int current_root_goodness = -1;
+
+extern int pmac_newworld;
+
+#define DEFAULT_ROOT_DEVICE Root_SDA1	/* sda1 - slightly silly choice */
+
+extern void zs_kgdb_hook(int tty_num);
+static void ohare_init(void);
+#ifdef CONFIG_BOOTX_TEXT
+static void pmac_progress(char *s, unsigned short hex);
+#endif
+
+sys_ctrler_t sys_ctrler = SYS_CTRLER_UNKNOWN;
+
+#ifdef CONFIG_SMP
+extern struct smp_ops_t psurge_smp_ops;
+extern struct smp_ops_t core99_smp_ops;
+#endif /* CONFIG_SMP */
+
+static int
+pmac_show_cpuinfo(struct seq_file *m)
+{
+	struct device_node *np;
+	char *pp;
+	int plen;
+	int mbmodel = pmac_call_feature(PMAC_FTR_GET_MB_INFO,
+		NULL, PMAC_MB_INFO_MODEL, 0);
+	unsigned int mbflags = (unsigned int)pmac_call_feature(PMAC_FTR_GET_MB_INFO,
+		NULL, PMAC_MB_INFO_FLAGS, 0);
+	char* mbname;
+
+	if (pmac_call_feature(PMAC_FTR_GET_MB_INFO, NULL, PMAC_MB_INFO_NAME, (int)&mbname) != 0)
+		mbname = "Unknown";
+
+	/* find motherboard type */
+	seq_printf(m, "machine\t\t: ");
+	np = find_devices("device-tree");
+	if (np != NULL) {
+		pp = (char *) get_property(np, "model", NULL);
+		if (pp != NULL)
+			seq_printf(m, "%s\n", pp);
+		else
+			seq_printf(m, "PowerMac\n");
+		pp = (char *) get_property(np, "compatible", &plen);
+		if (pp != NULL) {
+			seq_printf(m, "motherboard\t:");
+			while (plen > 0) {
+				int l = strlen(pp) + 1;
+				seq_printf(m, " %s", pp);
+				plen -= l;
+				pp += l;
+			}
+			seq_printf(m, "\n");
+		}
+	} else
+		seq_printf(m, "PowerMac\n");
+
+	/* print parsed model */
+	seq_printf(m, "detected as\t: %d (%s)\n", mbmodel, mbname);
+	seq_printf(m, "pmac flags\t: %08x\n", mbflags);
+
+	/* find l2 cache info */
+	np = find_devices("l2-cache");
+	if (np == 0)
+		np = find_type_devices("cache");
+	if (np != 0) {
+		unsigned int *ic = (unsigned int *)
+			get_property(np, "i-cache-size", NULL);
+		unsigned int *dc = (unsigned int *)
+			get_property(np, "d-cache-size", NULL);
+		seq_printf(m, "L2 cache\t:");
+		has_l2cache = 1;
+		if (get_property(np, "cache-unified", NULL) != 0 && dc) {
+			seq_printf(m, " %dK unified", *dc / 1024);
+		} else {
+			if (ic)
+				seq_printf(m, " %dK instruction", *ic / 1024);
+			if (dc)
+				seq_printf(m, "%s %dK data",
+					   (ic? " +": ""), *dc / 1024);
+		}
+		pp = get_property(np, "ram-type", NULL);
+		if (pp)
+			seq_printf(m, " %s", pp);
+		seq_printf(m, "\n");
+	}
+
+	/* find ram info */
+	np = find_devices("memory");
+	if (np != 0) {
+		int n;
+		struct reg_property *reg = (struct reg_property *)
+			get_property(np, "reg", &n);
+
+		if (reg != 0) {
+			unsigned long total = 0;
+
+			for (n /= sizeof(struct reg_property); n > 0; --n)
+				total += (reg++)->size;
+			seq_printf(m, "memory\t\t: %luMB\n", total >> 20);
+		}
+	}
+
+	/* Checks "l2cr-value" property in the registry */
+	np = find_devices("cpus");
+	if (np == 0)
+		np = find_type_devices("cpu");
+	if (np != 0) {
+		unsigned int *l2cr = (unsigned int *)
+			get_property(np, "l2cr-value", NULL);
+		if (l2cr != 0) {
+			seq_printf(m, "l2cr override\t: 0x%x\n", *l2cr);
+		}
+	}
+
+	/* Indicate newworld/oldworld */
+	seq_printf(m, "pmac-generation\t: %s\n",
+		   pmac_newworld ? "NewWorld" : "OldWorld");
+
+
+	return 0;
+}
+
+static int
+pmac_show_percpuinfo(struct seq_file *m, int i)
+{
+#ifdef CONFIG_CPU_FREQ_PMAC
+	extern unsigned int pmac_get_one_cpufreq(int i);
+	unsigned int freq = pmac_get_one_cpufreq(i);
+	if (freq != 0) {
+		seq_printf(m, "clock\t\t: %dMHz\n", freq/1000);
+		return 0;
+	}
+#endif /* CONFIG_CPU_FREQ_PMAC */
+	return of_show_percpuinfo(m, i);
+}
+
+static volatile u32 *sysctrl_regs;
+
+void __init
+pmac_setup_arch(void)
+{
+	struct device_node *cpu;
+	int *fp;
+	unsigned long pvr;
+
+	pvr = PVR_VER(mfspr(SPRN_PVR));
+
+	/* Set loops_per_jiffy to a half-way reasonable value,
+	   for use until calibrate_delay gets called. */
+	cpu = find_type_devices("cpu");
+	if (cpu != 0) {
+		fp = (int *) get_property(cpu, "clock-frequency", NULL);
+		if (fp != 0) {
+			if (pvr == 4 || pvr >= 8)
+				/* 604, G3, G4 etc. */
+				loops_per_jiffy = *fp / HZ;
+			else
+				/* 601, 603, etc. */
+				loops_per_jiffy = *fp / (2*HZ);
+		} else
+			loops_per_jiffy = 50000000 / HZ;
+	}
+
+	/* this area has the CPU identification register
+	   and some registers used by smp boards */
+	sysctrl_regs = (volatile u32 *) ioremap(0xf8000000, 0x1000);
+	ohare_init();
+
+	/* Lookup PCI hosts */
+	pmac_find_bridges();
+
+	/* Checks "l2cr-value" property in the registry */
+	if (cpu_has_feature(CPU_FTR_L2CR)) {
+		struct device_node *np = find_devices("cpus");
+		if (np == 0)
+			np = find_type_devices("cpu");
+		if (np != 0) {
+			unsigned int *l2cr = (unsigned int *)
+				get_property(np, "l2cr-value", NULL);
+			if (l2cr != 0) {
+				ppc_override_l2cr = 1;
+				ppc_override_l2cr_value = *l2cr;
+				_set_L2CR(0);
+				_set_L2CR(ppc_override_l2cr_value);
+			}
+		}
+	}
+
+	if (ppc_override_l2cr)
+		printk(KERN_INFO "L2CR overriden (0x%x), backside cache is %s\n",
+			ppc_override_l2cr_value, (ppc_override_l2cr_value & 0x80000000)
+				? "enabled" : "disabled");
+
+#ifdef CONFIG_KGDB
+	zs_kgdb_hook(0);
+#endif
+
+#ifdef CONFIG_ADB_CUDA
+	find_via_cuda();
+#else
+	if (find_devices("via-cuda")) {
+		printk("WARNING ! Your machine is Cuda based but your kernel\n");
+		printk("          wasn't compiled with CONFIG_ADB_CUDA option !\n");
+	}
+#endif
+#ifdef CONFIG_ADB_PMU
+	find_via_pmu();
+#else
+	if (find_devices("via-pmu")) {
+		printk("WARNING ! Your machine is PMU based but your kernel\n");
+		printk("          wasn't compiled with CONFIG_ADB_PMU option !\n");
+	}
+#endif
+#ifdef CONFIG_NVRAM
+	pmac_nvram_init();
+#endif
+#ifdef CONFIG_BLK_DEV_INITRD
+	if (initrd_start)
+		ROOT_DEV = Root_RAM0;
+	else
+#endif
+		ROOT_DEV = DEFAULT_ROOT_DEVICE;
+
+#ifdef CONFIG_SMP
+	/* Check for Core99 */
+	if (find_devices("uni-n") || find_devices("u3"))
+		ppc_md.smp_ops = &core99_smp_ops;
+	else
+		ppc_md.smp_ops = &psurge_smp_ops;
+#endif /* CONFIG_SMP */
+
+	pci_create_OF_bus_map();
+}
+
+static void __init ohare_init(void)
+{
+	/*
+	 * Turn on the L2 cache.
+	 * We assume that we have a PSX memory controller iff
+	 * we have an ohare I/O controller.
+	 */
+	if (find_devices("ohare") != NULL) {
+		if (((sysctrl_regs[2] >> 24) & 0xf) >= 3) {
+			if (sysctrl_regs[4] & 0x10)
+				sysctrl_regs[4] |= 0x04000020;
+			else
+				sysctrl_regs[4] |= 0x04000000;
+			if(has_l2cache)
+				printk(KERN_INFO "Level 2 cache enabled\n");
+		}
+	}
+}
+
+char *bootpath;
+char *bootdevice;
+void *boot_host;
+int boot_target;
+int boot_part;
+extern dev_t boot_dev;
+
+#ifdef CONFIG_SCSI
+void __init
+note_scsi_host(struct device_node *node, void *host)
+{
+	int l;
+	char *p;
+
+	l = strlen(node->full_name);
+	if (bootpath != NULL && bootdevice != NULL
+	    && strncmp(node->full_name, bootdevice, l) == 0
+	    && (bootdevice[l] == '/' || bootdevice[l] == 0)) {
+		boot_host = host;
+		/*
+		 * There's a bug in OF 1.0.5.  (Why am I not surprised.)
+		 * If you pass a path like scsi/sd@1:0 to canon, it returns
+		 * something like /bandit@F2000000/gc@10/53c94@10000/sd@0,0
+		 * That is, the scsi target number doesn't get preserved.
+		 * So we pick the target number out of bootpath and use that.
+		 */
+		p = strstr(bootpath, "/sd@");
+		if (p != NULL) {
+			p += 4;
+			boot_target = simple_strtoul(p, NULL, 10);
+			p = strchr(p, ':');
+			if (p != NULL)
+				boot_part = simple_strtoul(p + 1, NULL, 10);
+		}
+	}
+}
+EXPORT_SYMBOL(note_scsi_host);
+#endif
+
+#if defined(CONFIG_BLK_DEV_IDE) && defined(CONFIG_BLK_DEV_IDE_PMAC)
+static dev_t __init
+find_ide_boot(void)
+{
+	char *p;
+	int n;
+	dev_t __init pmac_find_ide_boot(char *bootdevice, int n);
+
+	if (bootdevice == NULL)
+		return 0;
+	p = strrchr(bootdevice, '/');
+	if (p == NULL)
+		return 0;
+	n = p - bootdevice;
+
+	return pmac_find_ide_boot(bootdevice, n);
+}
+#endif /* CONFIG_BLK_DEV_IDE && CONFIG_BLK_DEV_IDE_PMAC */
+
+static void __init
+find_boot_device(void)
+{
+#if defined(CONFIG_BLK_DEV_IDE) && defined(CONFIG_BLK_DEV_IDE_PMAC)
+	boot_dev = find_ide_boot();
+#endif
+}
+
+static int initializing = 1;
+/* TODO: Merge the suspend-to-ram with the common code !!!
+ * currently, this is a stub implementation for suspend-to-disk
+ * only
+ */
+
+#ifdef CONFIG_SOFTWARE_SUSPEND
+
+static int pmac_pm_prepare(suspend_state_t state)
+{
+	printk(KERN_DEBUG "%s(%d)\n", __FUNCTION__, state);
+
+	return 0;
+}
+
+static int pmac_pm_enter(suspend_state_t state)
+{
+	printk(KERN_DEBUG "%s(%d)\n", __FUNCTION__, state);
+
+	/* Giveup the lazy FPU & vec so we don't have to back them
+	 * up from the low level code
+	 */
+	enable_kernel_fp();
+
+#ifdef CONFIG_ALTIVEC
+	if (cur_cpu_spec->cpu_features & CPU_FTR_ALTIVEC)
+		enable_kernel_altivec();
+#endif /* CONFIG_ALTIVEC */
+
+	return 0;
+}
+
+static int pmac_pm_finish(suspend_state_t state)
+{
+	printk(KERN_DEBUG "%s(%d)\n", __FUNCTION__, state);
+
+	/* Restore userland MMU context */
+	set_context(current->active_mm->context, current->active_mm->pgd);
+
+	return 0;
+}
+
+static struct pm_ops pmac_pm_ops = {
+	.pm_disk_mode	= PM_DISK_SHUTDOWN,
+	.prepare	= pmac_pm_prepare,
+	.enter		= pmac_pm_enter,
+	.finish		= pmac_pm_finish,
+};
+
+#endif /* CONFIG_SOFTWARE_SUSPEND */
+
+static int pmac_late_init(void)
+{
+	initializing = 0;
+#ifdef CONFIG_SOFTWARE_SUSPEND
+	pm_set_ops(&pmac_pm_ops);
+#endif /* CONFIG_SOFTWARE_SUSPEND */
+	return 0;
+}
+
+late_initcall(pmac_late_init);
+
+/* can't be __init - can be called whenever a disk is first accessed */
+void
+note_bootable_part(dev_t dev, int part, int goodness)
+{
+	static int found_boot = 0;
+	char *p;
+
+	if (!initializing)
+		return;
+	if ((goodness <= current_root_goodness) &&
+	    ROOT_DEV != DEFAULT_ROOT_DEVICE)
+		return;
+	p = strstr(saved_command_line, "root=");
+	if (p != NULL && (p == saved_command_line || p[-1] == ' '))
+		return;
+
+	if (!found_boot) {
+		find_boot_device();
+		found_boot = 1;
+	}
+	if (!boot_dev || dev == boot_dev) {
+		ROOT_DEV = dev + part;
+		boot_dev = 0;
+		current_root_goodness = goodness;
+	}
+}
+
+static void
+pmac_restart(char *cmd)
+{
+#ifdef CONFIG_ADB_CUDA
+	struct adb_request req;
+#endif /* CONFIG_ADB_CUDA */
+
+	switch (sys_ctrler) {
+#ifdef CONFIG_ADB_CUDA
+	case SYS_CTRLER_CUDA:
+		cuda_request(&req, NULL, 2, CUDA_PACKET,
+			     CUDA_RESET_SYSTEM);
+		for (;;)
+			cuda_poll();
+		break;
+#endif /* CONFIG_ADB_CUDA */
+#ifdef CONFIG_ADB_PMU
+	case SYS_CTRLER_PMU:
+		pmu_restart();
+		break;
+#endif /* CONFIG_ADB_PMU */
+	default: ;
+	}
+}
+
+static void
+pmac_power_off(void)
+{
+#ifdef CONFIG_ADB_CUDA
+	struct adb_request req;
+#endif /* CONFIG_ADB_CUDA */
+
+	switch (sys_ctrler) {
+#ifdef CONFIG_ADB_CUDA
+	case SYS_CTRLER_CUDA:
+		cuda_request(&req, NULL, 2, CUDA_PACKET,
+			     CUDA_POWERDOWN);
+		for (;;)
+			cuda_poll();
+		break;
+#endif /* CONFIG_ADB_CUDA */
+#ifdef CONFIG_ADB_PMU
+	case SYS_CTRLER_PMU:
+		pmu_shutdown();
+		break;
+#endif /* CONFIG_ADB_PMU */
+	default: ;
+	}
+}
+
+static void
+pmac_halt(void)
+{
+	pmac_power_off();
+}
+
+void __init pmac_init(void)
+{
+	/* isa_io_base gets set in pmac_find_bridges */
+	isa_mem_base = PMAC_ISA_MEM_BASE;
+	pci_dram_offset = PMAC_PCI_DRAM_OFFSET;
+	ISA_DMA_THRESHOLD = ~0L;
+	DMA_MODE_READ = 1;
+	DMA_MODE_WRITE = 2;
+
+	ppc_md.setup_arch     = pmac_setup_arch;
+	ppc_md.show_cpuinfo   = pmac_show_cpuinfo;
+	ppc_md.show_percpuinfo = pmac_show_percpuinfo;
+	ppc_md.irq_canonicalize = NULL;
+	ppc_md.init_IRQ       = pmac_pic_init;
+	ppc_md.get_irq        = pmac_get_irq; /* Changed later on ... */
+
+	ppc_md.pcibios_fixup  = pmac_pcibios_fixup;
+	ppc_md.pcibios_enable_device_hook = pmac_pci_enable_device_hook;
+	ppc_md.pcibios_after_init = pmac_pcibios_after_init;
+	ppc_md.phys_mem_access_prot = pci_phys_mem_access_prot;
+
+	ppc_md.restart        = pmac_restart;
+	ppc_md.power_off      = pmac_power_off;
+	ppc_md.halt           = pmac_halt;
+
+	ppc_md.time_init      = pmac_time_init;
+	ppc_md.set_rtc_time   = pmac_set_rtc_time;
+	ppc_md.get_rtc_time   = pmac_get_rtc_time;
+	ppc_md.calibrate_decr = pmac_calibrate_decr;
+
+	ppc_md.feature_call   = pmac_do_feature_call;
+
+#if defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE)
+#ifdef CONFIG_BLK_DEV_IDE_PMAC
+        ppc_ide_md.ide_init_hwif	= pmac_ide_init_hwif_ports;
+        ppc_ide_md.default_io_base	= pmac_ide_get_base;
+#endif /* CONFIG_BLK_DEV_IDE_PMAC */
+#endif /* defined(CONFIG_BLK_DEV_IDE) || defined(CONFIG_BLK_DEV_IDE_MODULE) */
+
+#ifdef CONFIG_BOOTX_TEXT
+	ppc_md.progress = pmac_progress;
+#endif /* CONFIG_BOOTX_TEXT */
+
+	if (ppc_md.progress) ppc_md.progress("pmac_init(): exit", 0);
+
+}
+
+#ifdef CONFIG_BOOTX_TEXT
+static void __init
+pmac_progress(char *s, unsigned short hex)
+{
+	if (boot_text_mapped) {
+		btext_drawstring(s);
+		btext_drawchar('\n');
+	}
+}
+#endif /* CONFIG_BOOTX_TEXT */
+
+static int __init
+pmac_declare_of_platform_devices(void)
+{
+	struct device_node *np;
+
+	np = find_devices("uni-n");
+	if (np) {
+		for (np = np->child; np != NULL; np = np->sibling)
+			if (strncmp(np->name, "i2c", 3) == 0) {
+				of_platform_device_create(np, "uni-n-i2c",
+							  NULL);
+				break;
+			}
+	}
+	np = find_devices("u3");
+	if (np) {
+		for (np = np->child; np != NULL; np = np->sibling)
+			if (strncmp(np->name, "i2c", 3) == 0) {
+				of_platform_device_create(np, "u3-i2c",
+							  NULL);
+				break;
+			}
+	}
+
+	np = find_devices("valkyrie");
+	if (np)
+		of_platform_device_create(np, "valkyrie", NULL);
+	np = find_devices("platinum");
+	if (np)
+		of_platform_device_create(np, "platinum", NULL);
+
+	return 0;
+}
+
+device_initcall(pmac_declare_of_platform_devices);
