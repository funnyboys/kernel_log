commit 4bdd39460b5f57d4f165c4a05b22e66eb3a490ae
Author: Anju T Sudhakar <anju@linux.vnet.ibm.com>
Date:   Fri Mar 13 11:22:38 2020 +0530

    powerpc/powernv: Re-enable imc trace-mode in kernel
    
    commit <249fad734a25> ""powerpc/perf: Disable trace_imc pmu"
    disables IMC(In-Memory Collection) trace-mode in kernel, since frequent
    mode switching between accumulation mode and trace mode via the spr LDBAR
    in the hardware can trigger a checkstop(system crash).
    
    Patch to re-enable imc-trace mode in kernel.
    
    The previous patch(1/2) in this series will address the mode switching issue
    by implementing a global lock, and will restrict the usage of
    accumulation and trace-mode at a time.
    
    Signed-off-by: Anju T Sudhakar <anju@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20200313055238.8656-2-anju@linux.vnet.ibm.com

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 968b9a4d1cd9..7824cc364bc4 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -268,14 +268,7 @@ static int opal_imc_counters_probe(struct platform_device *pdev)
 			domain = IMC_DOMAIN_THREAD;
 			break;
 		case IMC_TYPE_TRACE:
-			/*
-			 * FIXME. Using trace_imc events to monitor application
-			 * or KVM thread performance can cause a checkstop
-			 * (system crash).
-			 * Disable it for now.
-			 */
-			pr_info_once("IMC: disabling trace_imc PMU\n");
-			domain = -1;
+			domain = IMC_DOMAIN_TRACE;
 			break;
 		default:
 			pr_warn("IMC Unknown Device type \n");

commit f344f0ab993987ae29cb39cc52054d7346db082f
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Sun Feb 9 11:59:01 2020 +0100

    powerpc/powernv: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Reviewed-by: Oliver O'Halloran <oohall@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20200209105901.1620958-6-gregkh@linuxfoundation.org

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 000b350d4060..968b9a4d1cd9 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -35,11 +35,10 @@ static int imc_mem_set(void *data, u64 val)
 }
 DEFINE_DEBUGFS_ATTRIBUTE(fops_imc_x64, imc_mem_get, imc_mem_set, "0x%016llx\n");
 
-static struct dentry *imc_debugfs_create_x64(const char *name, umode_t mode,
-					     struct dentry *parent, u64  *value)
+static void imc_debugfs_create_x64(const char *name, umode_t mode,
+				   struct dentry *parent, u64  *value)
 {
-	return debugfs_create_file_unsafe(name, mode, parent,
-					  value, &fops_imc_x64);
+	debugfs_create_file_unsafe(name, mode, parent, value, &fops_imc_x64);
 }
 
 /*
@@ -59,9 +58,6 @@ static void export_imc_mode_and_cmd(struct device_node *node,
 
 	imc_debugfs_parent = debugfs_create_dir("imc", powerpc_debugfs_root);
 
-	if (!imc_debugfs_parent)
-		return;
-
 	if (of_property_read_u32(node, "cb_offset", &cb_offset))
 		cb_offset = IMC_CNTL_BLK_OFFSET;
 
@@ -69,21 +65,15 @@ static void export_imc_mode_and_cmd(struct device_node *node,
 		loc = (u64)(ptr->vbase) + cb_offset;
 		imc_mode_addr = (u64 *)(loc + IMC_CNTL_BLK_MODE_OFFSET);
 		sprintf(mode, "imc_mode_%d", (u32)(ptr->id));
-		if (!imc_debugfs_create_x64(mode, 0600, imc_debugfs_parent,
-					    imc_mode_addr))
-			goto err;
+		imc_debugfs_create_x64(mode, 0600, imc_debugfs_parent,
+				       imc_mode_addr);
 
 		imc_cmd_addr = (u64 *)(loc + IMC_CNTL_BLK_CMD_OFFSET);
 		sprintf(cmd, "imc_cmd_%d", (u32)(ptr->id));
-		if (!imc_debugfs_create_x64(cmd, 0600, imc_debugfs_parent,
-					    imc_cmd_addr))
-			goto err;
+		imc_debugfs_create_x64(cmd, 0600, imc_debugfs_parent,
+				       imc_cmd_addr);
 		ptr++;
 	}
-	return;
-
-err:
-	debugfs_remove_recursive(imc_debugfs_parent);
 }
 
 /*

commit 249fad734a25889a4f23ed014d43634af6798063
Author: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
Date:   Mon Nov 18 09:14:52 2019 +0530

    powerpc/perf: Disable trace_imc pmu
    
    When a root user or a user with CAP_SYS_ADMIN privilege uses any
    trace_imc performance monitoring unit events, to monitor application
    or KVM threads, it may result in a checkstop (System crash).
    
    The cause is frequent switching of the "trace/accumulation" mode of
    the In-Memory Collection hardware (LDBAR).
    
    This patch disables the trace_imc PMU unit entirely to avoid
    triggering the checkstop. A future patch will reenable it at a later
    stage once a workaround has been developed.
    
    Fixes: 012ae244845f ("powerpc/perf: Trace imc PMU functions")
    Cc: stable@vger.kernel.org # v5.2+
    Signed-off-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    Tested-by: Hariharan T.S. <hari@linux.ibm.com>
    [mpe: Add pr_info_once() so dmesg shows the PMU has been disabled]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20191118034452.9939-1-maddy@linux.vnet.ibm.com

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 3b4518f4b643..000b350d4060 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -278,7 +278,14 @@ static int opal_imc_counters_probe(struct platform_device *pdev)
 			domain = IMC_DOMAIN_THREAD;
 			break;
 		case IMC_TYPE_TRACE:
-			domain = IMC_DOMAIN_TRACE;
+			/*
+			 * FIXME. Using trace_imc events to monitor application
+			 * or KVM thread performance can cause a checkstop
+			 * (system crash).
+			 * Disable it for now.
+			 */
+			pr_info_once("IMC: disabling trace_imc PMU\n");
+			domain = -1;
 			break;
 		default:
 			pr_warn("IMC Unknown Device type \n");

commit 48e626ac85b43cc589dd1b3b8004f7f85f03544d
Author: Anju T Sudhakar <anju@linux.vnet.ibm.com>
Date:   Wed Nov 27 12:50:35 2019 +0530

    powerpc/powernv: Avoid re-registration of imc debugfs directory
    
    export_imc_mode_and_cmd() function which creates the debugfs interface
    for imc-mode and imc-command, is invoked when each nest pmu units is
    registered.
    
    When the first nest pmu unit is registered, export_imc_mode_and_cmd()
    creates 'imc' directory under `/debug/powerpc/`. In the subsequent
    invocations debugfs_create_dir() function returns, since the directory
    already exists.
    
    The recent commit <c33d442328f55> (debugfs: make error message a bit
    more verbose), throws a warning if we try to invoke
    `debugfs_create_dir()` with an already existing directory name.
    
    Address this warning by making the debugfs directory registration in
    the opal_imc_counters_probe() function, i.e invoke
    export_imc_mode_and_cmd() function from the probe function.
    
    Signed-off-by: Anju T Sudhakar <anju@linux.vnet.ibm.com>
    Tested-by: Nageswara R Sastry <nasastry@in.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20191127072035.4283-1-anju@linux.vnet.ibm.com

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index e04b20625cb9..3b4518f4b643 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -59,10 +59,6 @@ static void export_imc_mode_and_cmd(struct device_node *node,
 
 	imc_debugfs_parent = debugfs_create_dir("imc", powerpc_debugfs_root);
 
-	/*
-	 * Return here, either because 'imc' directory already exists,
-	 * Or failed to create a new one.
-	 */
 	if (!imc_debugfs_parent)
 		return;
 
@@ -135,7 +131,6 @@ static int imc_get_mem_addr_nest(struct device_node *node,
 	}
 
 	pmu_ptr->imc_counter_mmaped = true;
-	export_imc_mode_and_cmd(node, pmu_ptr);
 	kfree(base_addr_arr);
 	kfree(chipid_arr);
 	return 0;
@@ -151,7 +146,7 @@ static int imc_get_mem_addr_nest(struct device_node *node,
  *		    and domain as the inputs.
  * Allocates memory for the struct imc_pmu, sets up its domain, size and offsets
  */
-static int imc_pmu_create(struct device_node *parent, int pmu_index, int domain)
+static struct imc_pmu *imc_pmu_create(struct device_node *parent, int pmu_index, int domain)
 {
 	int ret = 0;
 	struct imc_pmu *pmu_ptr;
@@ -159,27 +154,23 @@ static int imc_pmu_create(struct device_node *parent, int pmu_index, int domain)
 
 	/* Return for unknown domain */
 	if (domain < 0)
-		return -EINVAL;
+		return NULL;
 
 	/* memory for pmu */
 	pmu_ptr = kzalloc(sizeof(*pmu_ptr), GFP_KERNEL);
 	if (!pmu_ptr)
-		return -ENOMEM;
+		return NULL;
 
 	/* Set the domain */
 	pmu_ptr->domain = domain;
 
 	ret = of_property_read_u32(parent, "size", &pmu_ptr->counter_mem_size);
-	if (ret) {
-		ret = -EINVAL;
+	if (ret)
 		goto free_pmu;
-	}
 
 	if (!of_property_read_u32(parent, "offset", &offset)) {
-		if (imc_get_mem_addr_nest(parent, pmu_ptr, offset)) {
-			ret = -EINVAL;
+		if (imc_get_mem_addr_nest(parent, pmu_ptr, offset))
 			goto free_pmu;
-		}
 	}
 
 	/* Function to register IMC pmu */
@@ -190,14 +181,14 @@ static int imc_pmu_create(struct device_node *parent, int pmu_index, int domain)
 		if (pmu_ptr->domain == IMC_DOMAIN_NEST)
 			kfree(pmu_ptr->mem_info);
 		kfree(pmu_ptr);
-		return ret;
+		return NULL;
 	}
 
-	return 0;
+	return pmu_ptr;
 
 free_pmu:
 	kfree(pmu_ptr);
-	return ret;
+	return NULL;
 }
 
 static void disable_nest_pmu_counters(void)
@@ -254,6 +245,7 @@ int get_max_nest_dev(void)
 static int opal_imc_counters_probe(struct platform_device *pdev)
 {
 	struct device_node *imc_dev = pdev->dev.of_node;
+	struct imc_pmu *pmu;
 	int pmu_count = 0, domain;
 	bool core_imc_reg = false, thread_imc_reg = false;
 	u32 type;
@@ -269,6 +261,7 @@ static int opal_imc_counters_probe(struct platform_device *pdev)
 	}
 
 	for_each_compatible_node(imc_dev, NULL, IMC_DTB_UNIT_COMPAT) {
+		pmu = NULL;
 		if (of_property_read_u32(imc_dev, "type", &type)) {
 			pr_warn("IMC Device without type property\n");
 			continue;
@@ -293,9 +286,13 @@ static int opal_imc_counters_probe(struct platform_device *pdev)
 			break;
 		}
 
-		if (!imc_pmu_create(imc_dev, pmu_count, domain)) {
-			if (domain == IMC_DOMAIN_NEST)
+		pmu = imc_pmu_create(imc_dev, pmu_count, domain);
+		if (pmu != NULL) {
+			if (domain == IMC_DOMAIN_NEST) {
+				if (!imc_debugfs_parent)
+					export_imc_mode_and_cmd(imc_dev, pmu);
 				pmu_count++;
+			}
 			if (domain == IMC_DOMAIN_CORE)
 				core_imc_reg = true;
 			if (domain == IMC_DOMAIN_THREAD)
@@ -303,10 +300,6 @@ static int opal_imc_counters_probe(struct platform_device *pdev)
 		}
 	}
 
-	/* If none of the nest units are registered, remove debugfs interface */
-	if (pmu_count == 0)
-		debugfs_remove_recursive(imc_debugfs_parent);
-
 	/* If core imc is not registered, unregister thread-imc */
 	if (!core_imc_reg && thread_imc_reg)
 		unregister_thread_imc();

commit 41ba17f20ea835c489e77bd54e2da73184e22060
Author: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
Date:   Tue Aug 27 15:46:35 2019 +0530

    powerpc/imc: Dont create debugfs files for cpu-less nodes
    
    Commit <684d984038aa> ('powerpc/powernv: Add debugfs interface for
    imc-mode and imc') added debugfs interface for the nest imc pmu
    devices to support changing of different ucode modes. Primarily adding
    this capability for debug. But when doing so, the code did not
    consider the case of cpu-less nodes. So when reading the _cmd_ or
    _mode_ file of a cpu-less node will create this crash.
    
      Faulting instruction address: 0xc0000000000d0d58
      Oops: Kernel access of bad area, sig: 11 [#1]
      ...
      CPU: 67 PID: 5301 Comm: cat Not tainted 5.2.0-rc6-next-20190627+ #19
      NIP:  c0000000000d0d58 LR: c00000000049aa18 CTR:c0000000000d0d50
      REGS: c00020194548f9e0 TRAP: 0300   Not tainted  (5.2.0-rc6-next-20190627+)
      MSR:  9000000000009033 <SF,HV,EE,ME,IR,DR,RI,LE>  CR:28022822  XER: 00000000
      CFAR: c00000000049aa14 DAR: 000000000003fc08 DSISR:40000000 IRQMASK: 0
      ...
      NIP imc_mem_get+0x8/0x20
      LR  simple_attr_read+0x118/0x170
      Call Trace:
        simple_attr_read+0x70/0x170 (unreliable)
        debugfs_attr_read+0x6c/0xb0
        __vfs_read+0x3c/0x70
         vfs_read+0xbc/0x1a0
        ksys_read+0x7c/0x140
        system_call+0x5c/0x70
    
    Patch fixes the issue with a more robust check for vbase to NULL.
    
    Before patch, ls output for the debugfs imc directory
    
      # ls /sys/kernel/debug/powerpc/imc/
      imc_cmd_0    imc_cmd_251  imc_cmd_253  imc_cmd_255  imc_mode_0    imc_mode_251  imc_mode_253  imc_mode_255
      imc_cmd_250  imc_cmd_252  imc_cmd_254  imc_cmd_8    imc_mode_250  imc_mode_252  imc_mode_254  imc_mode_8
    
    After patch, ls output for the debugfs imc directory
    
      # ls /sys/kernel/debug/powerpc/imc/
      imc_cmd_0  imc_cmd_8  imc_mode_0  imc_mode_8
    
    Actual bug here is that, we have two loops with potentially different
    loop counts. That is, in imc_get_mem_addr_nest(), loop count is
    obtained from the dt entries. But in case of export_imc_mode_and_cmd(),
    loop was based on for_each_nid() count. Patch fixes the loop count in
    latter based on the struct mem_info. Ideally it would be better to
    have array size in struct imc_pmu.
    
    Fixes: 684d984038aa ('powerpc/powernv: Add debugfs interface for imc-mode and imc')
    Reported-by: Qian Cai <cai@lca.pw>
    Suggested-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20190827101635.6942-1-maddy@linux.vnet.ibm.com

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 186109bdd41b..e04b20625cb9 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -53,9 +53,9 @@ static void export_imc_mode_and_cmd(struct device_node *node,
 				    struct imc_pmu *pmu_ptr)
 {
 	static u64 loc, *imc_mode_addr, *imc_cmd_addr;
-	int chip = 0, nid;
 	char mode[16], cmd[16];
 	u32 cb_offset;
+	struct imc_mem_info *ptr = pmu_ptr->mem_info;
 
 	imc_debugfs_parent = debugfs_create_dir("imc", powerpc_debugfs_root);
 
@@ -69,20 +69,20 @@ static void export_imc_mode_and_cmd(struct device_node *node,
 	if (of_property_read_u32(node, "cb_offset", &cb_offset))
 		cb_offset = IMC_CNTL_BLK_OFFSET;
 
-	for_each_node(nid) {
-		loc = (u64)(pmu_ptr->mem_info[chip].vbase) + cb_offset;
+	while (ptr->vbase != NULL) {
+		loc = (u64)(ptr->vbase) + cb_offset;
 		imc_mode_addr = (u64 *)(loc + IMC_CNTL_BLK_MODE_OFFSET);
-		sprintf(mode, "imc_mode_%d", nid);
+		sprintf(mode, "imc_mode_%d", (u32)(ptr->id));
 		if (!imc_debugfs_create_x64(mode, 0600, imc_debugfs_parent,
 					    imc_mode_addr))
 			goto err;
 
 		imc_cmd_addr = (u64 *)(loc + IMC_CNTL_BLK_CMD_OFFSET);
-		sprintf(cmd, "imc_cmd_%d", nid);
+		sprintf(cmd, "imc_cmd_%d", (u32)(ptr->id));
 		if (!imc_debugfs_create_x64(cmd, 0600, imc_debugfs_parent,
 					    imc_cmd_addr))
 			goto err;
-		chip++;
+		ptr++;
 	}
 	return;
 

commit 460b48a0fefce25beb0fc0139e721c5691d65d7f
Merge: b44a1dd3f648 8b909e354870
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 2 10:21:04 2019 -0700

    Merge tag 'powerpc-5.2-3' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc fixes from Michael Ellerman:
     "A minor fix to our IMC PMU code to print a less confusing error
      message when the driver can't initialise properly.
    
      A fix for a bug where a user requesting an unsupported branch sampling
      filter can corrupt PMU state, preventing the PMU from counting
      properly.
    
      And finally a fix for a bug in our support for kexec_file_load(),
      which prevented loading a kernel and initramfs. Most versions of kexec
      don't yet use kexec_file_load().
    
      Thanks to: Anju T Sudhakar, Dave Young, Madhavan Srinivasan, Ravi
      Bangoria, Thiago Jung Bauermann"
    
    * tag 'powerpc-5.2-3' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux:
      powerpc/kexec: Fix loading of kernel + initramfs with kexec_file_load()
      powerpc/perf: Fix MMCRA corruption by bhrb_filter
      powerpc/powernv: Return for invalid IMC domain

commit f4344b19fa2d081a24d802dbab99223751e19bcd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:49 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 112
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or
      later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 4 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091650.480557885@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 3e497b91d210..1b6932890a73 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * OPAL IMC interface detection driver
  * Supported on POWERNV platform
@@ -5,11 +6,6 @@
  * Copyright	(C) 2017 Madhavan Srinivasan, IBM Corporation.
  *		(C) 2017 Anju T Sudhakar, IBM Corporation.
  *		(C) 2017 Hemant K Shaw, IBM Corporation.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or later version.
  */
 #include <linux/kernel.h>
 #include <linux/platform_device.h>

commit b59bd3527fe3c1939340df558d7f9d568fc9f882
Author: Anju T Sudhakar <anju@linux.vnet.ibm.com>
Date:   Mon May 20 14:27:53 2019 +0530

    powerpc/powernv: Return for invalid IMC domain
    
    Currently init_imc_pmu() can fail either because we try to register an
    IMC unit with an invalid domain (i.e an IMC node not supported by the
    kernel) or something went wrong while registering a valid IMC unit. In
    both the cases kernel provides a 'Register failed' error message.
    
    For example when trace-imc node is not supported by the kernel, but
    skiboot advertises a trace-imc node we print:
    
      IMC Unknown Device type
      IMC PMU (null) Register failed
    
    To avoid confusion just print the unknown device type message, before
    attempting PMU registration, so the second message isn't printed.
    
    Fixes: 8f95faaac56c ("powerpc/powernv: Detect and create IMC device")
    Reported-by: Pavaman Subramaniyam <pavsubra@in.ibm.com>
    Signed-off-by: Anju T Sudhakar <anju@linux.vnet.ibm.com>
    Reviewed-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    [mpe: Reword change log a bit]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 3e497b91d210..52e9e159bb70 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -161,6 +161,10 @@ static int imc_pmu_create(struct device_node *parent, int pmu_index, int domain)
 	struct imc_pmu *pmu_ptr;
 	u32 offset;
 
+	/* Return for unknown domain */
+	if (domain < 0)
+		return -EINVAL;
+
 	/* memory for pmu */
 	pmu_ptr = kzalloc(sizeof(*pmu_ptr), GFP_KERNEL);
 	if (!pmu_ptr)

commit 72c69dcddce103338de558c5c6e9ef9e4f607ce1
Author: Anju T Sudhakar <anju@linux.vnet.ibm.com>
Date:   Tue Apr 16 15:18:30 2019 +0530

    powerpc/perf: Trace imc events detection and cpuhotplug
    
    Patch detects trace-imc events, does memory initilizations for each online
    cpu, and registers cpuhotplug call-backs.
    
    Signed-off-by: Anju T Sudhakar <anju@linux.vnet.ibm.com>
    Reviewed-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 3d27f02695e4..3e497b91d210 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -284,6 +284,9 @@ static int opal_imc_counters_probe(struct platform_device *pdev)
 		case IMC_TYPE_THREAD:
 			domain = IMC_DOMAIN_THREAD;
 			break;
+		case IMC_TYPE_TRACE:
+			domain = IMC_DOMAIN_TRACE;
+			break;
 		default:
 			pr_warn("IMC Unknown Device type \n");
 			domain = -1;

commit 860b7d2286236170a36f94946d03ca9888d32571
Author: Anju T Sudhakar <anju@linux.vnet.ibm.com>
Date:   Tue Dec 18 11:50:41 2018 +0530

    powerpc/perf: Fix loop exit condition in nest_imc_event_init
    
    The data structure (i.e struct imc_mem_info) to hold the memory address
    information for nest imc units is allocated based on the number of nodes
    in the system.
    
    nest_imc_event_init() traverse this struct array to calculate the memory
    base address for the event-cpu. If we fail to find a match for the event
    cpu's chip-id in imc_mem_info struct array, then the do-while loop will
    iterate until we crash.
    
    Fix this by changing the loop exit condition based on the number of
    non zero vbase elements in the array, since the allocation is done for
    nr_chips + 1.
    
    Reported-by: Dan Carpenter <dan.carpenter@oracle.com>
    Fixes: 885dcd709ba91 ("powerpc/perf: Add nest IMC PMU support")
    Signed-off-by: Anju T Sudhakar <anju@linux.vnet.ibm.com>
    Reviewed-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 58a07948c76e..3d27f02695e4 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -127,7 +127,7 @@ static int imc_get_mem_addr_nest(struct device_node *node,
 								nr_chips))
 		goto error;
 
-	pmu_ptr->mem_info = kcalloc(nr_chips, sizeof(*pmu_ptr->mem_info),
+	pmu_ptr->mem_info = kcalloc(nr_chips + 1, sizeof(*pmu_ptr->mem_info),
 				    GFP_KERNEL);
 	if (!pmu_ptr->mem_info)
 		goto error;

commit 25af86b2aeb60dd52bd18a875124490e23bd4515
Author: Anju T Sudhakar <anju@linux.vnet.ibm.com>
Date:   Tue May 22 14:42:37 2018 +0530

    powerpc/perf: Unregister thread-imc if core-imc not supported
    
    Since thread-imc internally use the core-imc hardware infrastructure
    and is depended on it, having thread-imc in the kernel in the
    absence of core-imc is trivial. Patch disables thread-imc, if
    core-imc is not registered.
    
    Signed-off-by: Anju T Sudhakar <anju@linux.vnet.ibm.com>
    Reviewed-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 490bb721879f..58a07948c76e 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -255,6 +255,7 @@ static int opal_imc_counters_probe(struct platform_device *pdev)
 {
 	struct device_node *imc_dev = pdev->dev.of_node;
 	int pmu_count = 0, domain;
+	bool core_imc_reg = false, thread_imc_reg = false;
 	u32 type;
 
 	/*
@@ -292,6 +293,10 @@ static int opal_imc_counters_probe(struct platform_device *pdev)
 		if (!imc_pmu_create(imc_dev, pmu_count, domain)) {
 			if (domain == IMC_DOMAIN_NEST)
 				pmu_count++;
+			if (domain == IMC_DOMAIN_CORE)
+				core_imc_reg = true;
+			if (domain == IMC_DOMAIN_THREAD)
+				thread_imc_reg = true;
 		}
 	}
 
@@ -299,6 +304,10 @@ static int opal_imc_counters_probe(struct platform_device *pdev)
 	if (pmu_count == 0)
 		debugfs_remove_recursive(imc_debugfs_parent);
 
+	/* If core imc is not registered, unregister thread-imc */
+	if (!core_imc_reg && thread_imc_reg)
+		unregister_thread_imc();
+
 	return 0;
 }
 

commit cb094fa5af7c9623084aa4c3cf529b196f5c3b5c
Author: Anju T Sudhakar <anju@linux.vnet.ibm.com>
Date:   Tue May 22 14:42:34 2018 +0530

    powerpc/perf: Rearrange memory freeing in imc init
    
    When any of the IMC (In-Memory Collection counter) devices fail
    to initialize, imc_common_mem_free() frees set of memory. In doing so,
    pmu_ptr pointer is also freed. But pmu_ptr pointer is used in subsequent
    function (imc_common_cpuhp_mem_free()) which is wrong. Patch here reorders
    the code to avoid such access.
    
    Also free the memory which is dynamically allocated during imc
    initialization, wherever required.
    
    Signed-off-by: Anju T Sudhakar <anju@linux.vnet.ibm.com>
    Reviewed-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 2a14fda5ea26..490bb721879f 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -115,8 +115,10 @@ static int imc_get_mem_addr_nest(struct device_node *node,
 		return -ENOMEM;
 
 	chipid_arr = kcalloc(nr_chips, sizeof(*chipid_arr), GFP_KERNEL);
-	if (!chipid_arr)
+	if (!chipid_arr) {
+		kfree(base_addr_arr);
 		return -ENOMEM;
+	}
 
 	if (of_property_read_u32_array(node, "chip-id", chipid_arr, nr_chips))
 		goto error;
@@ -143,7 +145,6 @@ static int imc_get_mem_addr_nest(struct device_node *node,
 	return 0;
 
 error:
-	kfree(pmu_ptr->mem_info);
 	kfree(base_addr_arr);
 	kfree(chipid_arr);
 	return -1;
@@ -183,8 +184,14 @@ static int imc_pmu_create(struct device_node *parent, int pmu_index, int domain)
 
 	/* Function to register IMC pmu */
 	ret = init_imc_pmu(parent, pmu_ptr, pmu_index);
-	if (ret)
+	if (ret) {
 		pr_err("IMC PMU %s Register failed\n", pmu_ptr->pmu.name);
+		kfree(pmu_ptr->pmu.name);
+		if (pmu_ptr->domain == IMC_DOMAIN_NEST)
+			kfree(pmu_ptr->mem_info);
+		kfree(pmu_ptr);
+		return ret;
+	}
 
 	return 0;
 

commit a0828cf57acce9bf941539e1f633e9a91f9df57d
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Thu Jan 19 17:15:30 2017 +0100

    powerpc: Use sizeof(*foo) rather than sizeof(struct foo)
    
    It's slightly less error prone to use sizeof(*foo) rather than
    specifying the type.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    [mpe: Consolidate into one patch, rewrite change log]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index f6f55ab4980e..2a14fda5ea26 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -110,11 +110,11 @@ static int imc_get_mem_addr_nest(struct device_node *node,
 	if (nr_chips <= 0)
 		return -ENODEV;
 
-	base_addr_arr = kcalloc(nr_chips, sizeof(u64), GFP_KERNEL);
+	base_addr_arr = kcalloc(nr_chips, sizeof(*base_addr_arr), GFP_KERNEL);
 	if (!base_addr_arr)
 		return -ENOMEM;
 
-	chipid_arr = kcalloc(nr_chips, sizeof(u32), GFP_KERNEL);
+	chipid_arr = kcalloc(nr_chips, sizeof(*chipid_arr), GFP_KERNEL);
 	if (!chipid_arr)
 		return -ENOMEM;
 
@@ -125,8 +125,8 @@ static int imc_get_mem_addr_nest(struct device_node *node,
 								nr_chips))
 		goto error;
 
-	pmu_ptr->mem_info = kcalloc(nr_chips, sizeof(struct imc_mem_info),
-								GFP_KERNEL);
+	pmu_ptr->mem_info = kcalloc(nr_chips, sizeof(*pmu_ptr->mem_info),
+				    GFP_KERNEL);
 	if (!pmu_ptr->mem_info)
 		goto error;
 
@@ -161,7 +161,7 @@ static int imc_pmu_create(struct device_node *parent, int pmu_index, int domain)
 	u32 offset;
 
 	/* memory for pmu */
-	pmu_ptr = kzalloc(sizeof(struct imc_pmu), GFP_KERNEL);
+	pmu_ptr = kzalloc(sizeof(*pmu_ptr), GFP_KERNEL);
 	if (!pmu_ptr)
 		return -ENOMEM;
 

commit e7bde88cdb4f0e432398a7d29ca2a15d2c18952a
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Tue Feb 13 17:45:11 2018 +1000

    powerpc/powernv: IMC fix out of bounds memory access at shutdown
    
    The OPAL IMC driver's shutdown handler disables nest PMU counters by
    walking nodes and taking the first CPU out of their cpumask, which is
    used to index into the paca (get_hard_smp_processor_id()). This does
    not always do the right thing, and in particular for CPU-less nodes it
    returns NR_CPUS and that overruns the paca and dereferences random
    memory.
    
    Fix it by being more careful about checking returned CPU, and only
    using online CPUs. It's not clear this shutdown code makes sense after
    commit 885dcd709b ("powerpc/perf: Add nest IMC PMU support"), but this
    should not make things worse
    
    Currently the bug causes us to call OPAL with a junk CPU number. A
    separate patch in development to change the way pacas are allocated
    escalates this bug into a crash:
    
      Unable to handle kernel paging request for data at address 0x2a21af1eeb000076
      Faulting instruction address: 0xc0000000000a5468
      Oops: Kernel access of bad area, sig: 11 [#1]
      ...
      NIP opal_imc_counters_shutdown+0x148/0x1d0
      LR  opal_imc_counters_shutdown+0x134/0x1d0
      Call Trace:
       opal_imc_counters_shutdown+0x134/0x1d0 (unreliable)
       platform_drv_shutdown+0x44/0x60
       device_shutdown+0x1f8/0x350
       kernel_restart_prepare+0x54/0x70
       kernel_restart+0x28/0xc0
       SyS_reboot+0x1d0/0x2c0
       system_call+0x58/0x6c
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index dd4c9b8b8a81..f6f55ab4980e 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -199,9 +199,11 @@ static void disable_nest_pmu_counters(void)
 	const struct cpumask *l_cpumask;
 
 	get_online_cpus();
-	for_each_online_node(nid) {
+	for_each_node_with_cpus(nid) {
 		l_cpumask = cpumask_of_node(nid);
-		cpu = cpumask_first(l_cpumask);
+		cpu = cpumask_first_and(l_cpumask, cpu_online_mask);
+		if (cpu >= nr_cpu_ids)
+			continue;
 		opal_imc_counters_stop(OPAL_IMC_COUNTERS_NEST,
 				       get_hard_smp_processor_id(cpu));
 	}

commit 684d984038aa2b8ec3ab4b9d314257879a3fbfbd
Author: Anju T Sudhakar <anju@linux.vnet.ibm.com>
Date:   Wed Dec 13 11:39:54 2017 +0530

    powerpc/powernv: Add debugfs interface for imc-mode and imc-command
    
    In memory Collection (IMC) counter pmu driver controls the ucode's
    execution state. At the system boot, IMC perf driver pause the ucode.
    Ucode state is changed to "running" only when any of the nest units
    are monitored or profiled using perf tool.
    
    Nest units support only limited set of hardware counters and ucode is
    always programmed in the "production mode" ("accumulation") mode. This
    mode is configured to provide key performance metric data for most of
    the nest units.
    
    But ucode also supports other modes which would be used for "debug" to
    drill down specific nest units. That is, ucode when switched to
    "powerbus" debug mode (for example), will dynamically reconfigure the
    nest counters to target only "powerbus" related events in the hardware
    counters. This allows the IMC nest unit to focus on powerbus related
    transactions in the system in more detail. At this point, production
    mode events may or may not be counted.
    
    IMC nest counters has both in-band (ucode access) and out of band
    access to it. Since not all nest counter configurations are supported
    by ucode, out of band tools are used to characterize other nest
    counter configurations.
    
    Patch provides an interface via "debugfs" to enable the switching of
    ucode modes in the system. To switch ucode mode, one has to first
    pause the microcode (imc_cmd), and then write the target mode value to
    the "imc_mode" file.
    
    Proposed Approach:
    
    In the proposed approach, the function (export_imc_mode_and_cmd) which
    creates the debugfs interface for imc mode and command is implemented
    in opal-imc.c. Thus we can use imc_get_mem_addr() to get the homer
    base address for each chip.
    
    The interface to expose imc mode and command is required only if we
    have nest pmu units registered. Employing the existing data structures
    to track whether we have any nest units registered will require to
    extend data from perf side to opal-imc.c. Instead an integer is
    introduced to hold that information by counting successful nest unit
    registration. Debugfs interface is removed based on the integer count.
    
    Example for the interface:
    
      $ ls /sys/kernel/debug/imc
      imc_cmd_0  imc_cmd_8  imc_mode_0  imc_mode_8
    
    Signed-off-by: Anju T Sudhakar <anju@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 465ea105b771..dd4c9b8b8a81 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -21,6 +21,78 @@
 #include <asm/io.h>
 #include <asm/imc-pmu.h>
 #include <asm/cputhreads.h>
+#include <asm/debugfs.h>
+
+static struct dentry *imc_debugfs_parent;
+
+/* Helpers to export imc command and mode via debugfs */
+static int imc_mem_get(void *data, u64 *val)
+{
+	*val = cpu_to_be64(*(u64 *)data);
+	return 0;
+}
+
+static int imc_mem_set(void *data, u64 val)
+{
+	*(u64 *)data = cpu_to_be64(val);
+	return 0;
+}
+DEFINE_DEBUGFS_ATTRIBUTE(fops_imc_x64, imc_mem_get, imc_mem_set, "0x%016llx\n");
+
+static struct dentry *imc_debugfs_create_x64(const char *name, umode_t mode,
+					     struct dentry *parent, u64  *value)
+{
+	return debugfs_create_file_unsafe(name, mode, parent,
+					  value, &fops_imc_x64);
+}
+
+/*
+ * export_imc_mode_and_cmd: Create a debugfs interface
+ *                     for imc_cmd and imc_mode
+ *                     for each node in the system.
+ *  imc_mode and imc_cmd can be changed by echo into
+ *  this interface.
+ */
+static void export_imc_mode_and_cmd(struct device_node *node,
+				    struct imc_pmu *pmu_ptr)
+{
+	static u64 loc, *imc_mode_addr, *imc_cmd_addr;
+	int chip = 0, nid;
+	char mode[16], cmd[16];
+	u32 cb_offset;
+
+	imc_debugfs_parent = debugfs_create_dir("imc", powerpc_debugfs_root);
+
+	/*
+	 * Return here, either because 'imc' directory already exists,
+	 * Or failed to create a new one.
+	 */
+	if (!imc_debugfs_parent)
+		return;
+
+	if (of_property_read_u32(node, "cb_offset", &cb_offset))
+		cb_offset = IMC_CNTL_BLK_OFFSET;
+
+	for_each_node(nid) {
+		loc = (u64)(pmu_ptr->mem_info[chip].vbase) + cb_offset;
+		imc_mode_addr = (u64 *)(loc + IMC_CNTL_BLK_MODE_OFFSET);
+		sprintf(mode, "imc_mode_%d", nid);
+		if (!imc_debugfs_create_x64(mode, 0600, imc_debugfs_parent,
+					    imc_mode_addr))
+			goto err;
+
+		imc_cmd_addr = (u64 *)(loc + IMC_CNTL_BLK_CMD_OFFSET);
+		sprintf(cmd, "imc_cmd_%d", nid);
+		if (!imc_debugfs_create_x64(cmd, 0600, imc_debugfs_parent,
+					    imc_cmd_addr))
+			goto err;
+		chip++;
+	}
+	return;
+
+err:
+	debugfs_remove_recursive(imc_debugfs_parent);
+}
 
 /*
  * imc_get_mem_addr_nest: Function to get nest counter memory region
@@ -65,6 +137,7 @@ static int imc_get_mem_addr_nest(struct device_node *node,
 	}
 
 	pmu_ptr->imc_counter_mmaped = true;
+	export_imc_mode_and_cmd(node, pmu_ptr);
 	kfree(base_addr_arr);
 	kfree(chipid_arr);
 	return 0;
@@ -213,6 +286,10 @@ static int opal_imc_counters_probe(struct platform_device *pdev)
 		}
 	}
 
+	/* If none of the nest units are registered, remove debugfs interface */
+	if (pmu_count == 0)
+		debugfs_remove_recursive(imc_debugfs_parent);
+
 	return 0;
 }
 

commit 73ce9aec65b17433e18163d07eb5cb6bf114bd6c
Author: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
Date:   Wed Nov 22 10:45:39 2017 +0530

    powerpc/perf: Fix IMC_MAX_PMU macro
    
    IMC_MAX_PMU is used for static storage (per_nest_pmu_arr) which holds
    nest pmu information. Current value for the macro is 32 based on
    the initial number of nest pmu units supported by the nest microcode.
    But going forward, microcode could support more nest units. Instead
    of static storage, patch to fix the code to dynamically allocate an
    array based on the number of nest imc units found in the device tree.
    
    Fixes:8f95faaac56c1 ('powerpc/powernv: Detect and create IMC device')
    Signed-off-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index b150f4deaccf..465ea105b771 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -153,6 +153,22 @@ static void disable_core_pmu_counters(void)
 	put_online_cpus();
 }
 
+int get_max_nest_dev(void)
+{
+	struct device_node *node;
+	u32 pmu_units = 0, type;
+
+	for_each_compatible_node(node, NULL, IMC_DTB_UNIT_COMPAT) {
+		if (of_property_read_u32(node, "type", &type))
+			continue;
+
+		if (type == IMC_TYPE_CHIP)
+			pmu_units++;
+	}
+
+	return pmu_units;
+}
+
 static int opal_imc_counters_probe(struct platform_device *pdev)
 {
 	struct device_node *imc_dev = pdev->dev.of_node;

commit de34787f1096cce38e2590be0013b44418d14546
Author: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
Date:   Wed Nov 22 10:45:38 2017 +0530

    powerpc/perf: Fix pmu_count to count only nest imc pmus
    
    "pmu_count" in opal_imc_counters_probe() is intended to hold
    the number of successful nest imc pmu registerations. But
    current code also counts other imc units like core_imc and
    thread_imc. Patch add a check to count only nest imc pmus.
    
    Signed-off-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index 21f6531fae20..b150f4deaccf 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -191,8 +191,10 @@ static int opal_imc_counters_probe(struct platform_device *pdev)
 			break;
 		}
 
-		if (!imc_pmu_create(imc_dev, pmu_count, domain))
-			pmu_count++;
+		if (!imc_pmu_create(imc_dev, pmu_count, domain)) {
+			if (domain == IMC_DOMAIN_NEST)
+				pmu_count++;
+		}
 	}
 
 	return 0;

commit 6538ac30841638b2fd345725a9fd155c6fe1768a
Author: LABBE Corentin <clabbe.montjoie@gmail.com>
Date:   Wed Aug 16 14:34:44 2017 +0200

    powerpc/powernv: Fix build error in opal-imc.c when NUMA=n
    
    When building a random powerpc kernel I hit this build error:
    
      arch/powerpc/platforms/powernv/opal-imc.c:130:13: error : assignment
      discards « const » qualifier from pointer target type
      [-Werror=discarded-qualifiers]
         l_cpumask = cpumask_of_node(nid);
                 ^
    
    This happens because when CONFIG_NUMA=n cpumask_of_node() returns a
    const pointer.
    
    This patch simply adds const to l_cpumask to fix this issue.
    
    Signed-off-by: Corentin Labbe <clabbe.montjoie@gmail.com>
    Reviewed-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    [mpe: Flesh out change log]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index b903bf5e6006..21f6531fae20 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -123,7 +123,7 @@ static int imc_pmu_create(struct device_node *parent, int pmu_index, int domain)
 static void disable_nest_pmu_counters(void)
 {
 	int nid, cpu;
-	struct cpumask *l_cpumask;
+	const struct cpumask *l_cpumask;
 
 	get_online_cpus();
 	for_each_online_node(nid) {

commit 885dcd709ba9120b9935415b8b0f9d1b94e5826b
Author: Anju T Sudhakar <anju@linux.vnet.ibm.com>
Date:   Wed Jul 19 03:06:34 2017 +0530

    powerpc/perf: Add nest IMC PMU support
    
    Add support to register Nest In-Memory Collection PMU counters.
    Patch adds a new device file called "imc-pmu.c" under powerpc/perf
    folder to contain all the device PMU functions.
    
    Device tree parser code added to parse the PMU events information
    and create sysfs event attributes for the PMU.
    
    Cpumask attribute added along with Cpu hotplug online/offline functions
    specific for nest PMU. A new state "CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE"
    added for the cpu hotplug callbacks. Error handle path frees the memory
    and unregisters the CPU hotplug callbacks.
    
    Signed-off-by: Anju T Sudhakar <anju@linux.vnet.ibm.com>
    Signed-off-by: Hemant Kumar <hemant@linux.vnet.ibm.com>
    Signed-off-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
index f57a6fbd3f57..b903bf5e6006 100644
--- a/arch/powerpc/platforms/powernv/opal-imc.c
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -108,6 +108,11 @@ static int imc_pmu_create(struct device_node *parent, int pmu_index, int domain)
 		}
 	}
 
+	/* Function to register IMC pmu */
+	ret = init_imc_pmu(parent, pmu_ptr, pmu_index);
+	if (ret)
+		pr_err("IMC PMU %s Register failed\n", pmu_ptr->pmu.name);
+
 	return 0;
 
 free_pmu:

commit 8f95faaac56c18b32d0e23ace55417a440abdb7e
Author: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
Date:   Wed Jul 19 03:06:33 2017 +0530

    powerpc/powernv: Detect and create IMC device
    
    Code to create platform device for the In-Memory Collection (IMC)
    counters. Platform devices are created based on the IMC compatibility.
    New header file created to contain the data structures and macros
    needed for In-Memory Collection (IMC) counter pmu devices.
    
    The device tree for IMC counters starts at the node "imc-counters".
    This node contains all the IMC PMU nodes and event nodes for these IMC
    PMUs. Device probe() parses the device to locate three possible IMC
    device types (Nest/Core/Thread). Function then branch to parse each
    unit nodes to populate vital information such as device memory sizes,
    event nodes information, base address for reserve memory access (if
    any) and so on. Simple bare-minimum shutdown function added which only
    "stops" the engines.
    
    Signed-off-by: Anju T Sudhakar <anju@linux.vnet.ibm.com>
    Signed-off-by: Hemant Kumar <hemant@linux.vnet.ibm.com>
    Signed-off-by: Madhavan Srinivasan <maddy@linux.vnet.ibm.com>
    [mpe: Fix build with CONFIG_PERF_EVENTS=n]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/opal-imc.c b/arch/powerpc/platforms/powernv/opal-imc.c
new file mode 100644
index 000000000000..f57a6fbd3f57
--- /dev/null
+++ b/arch/powerpc/platforms/powernv/opal-imc.c
@@ -0,0 +1,221 @@
+/*
+ * OPAL IMC interface detection driver
+ * Supported on POWERNV platform
+ *
+ * Copyright	(C) 2017 Madhavan Srinivasan, IBM Corporation.
+ *		(C) 2017 Anju T Sudhakar, IBM Corporation.
+ *		(C) 2017 Hemant K Shaw, IBM Corporation.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or later version.
+ */
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/crash_dump.h>
+#include <asm/opal.h>
+#include <asm/io.h>
+#include <asm/imc-pmu.h>
+#include <asm/cputhreads.h>
+
+/*
+ * imc_get_mem_addr_nest: Function to get nest counter memory region
+ * for each chip
+ */
+static int imc_get_mem_addr_nest(struct device_node *node,
+				 struct imc_pmu *pmu_ptr,
+				 u32 offset)
+{
+	int nr_chips = 0, i;
+	u64 *base_addr_arr, baddr;
+	u32 *chipid_arr;
+
+	nr_chips = of_property_count_u32_elems(node, "chip-id");
+	if (nr_chips <= 0)
+		return -ENODEV;
+
+	base_addr_arr = kcalloc(nr_chips, sizeof(u64), GFP_KERNEL);
+	if (!base_addr_arr)
+		return -ENOMEM;
+
+	chipid_arr = kcalloc(nr_chips, sizeof(u32), GFP_KERNEL);
+	if (!chipid_arr)
+		return -ENOMEM;
+
+	if (of_property_read_u32_array(node, "chip-id", chipid_arr, nr_chips))
+		goto error;
+
+	if (of_property_read_u64_array(node, "base-addr", base_addr_arr,
+								nr_chips))
+		goto error;
+
+	pmu_ptr->mem_info = kcalloc(nr_chips, sizeof(struct imc_mem_info),
+								GFP_KERNEL);
+	if (!pmu_ptr->mem_info)
+		goto error;
+
+	for (i = 0; i < nr_chips; i++) {
+		pmu_ptr->mem_info[i].id = chipid_arr[i];
+		baddr = base_addr_arr[i] + offset;
+		pmu_ptr->mem_info[i].vbase = phys_to_virt(baddr);
+	}
+
+	pmu_ptr->imc_counter_mmaped = true;
+	kfree(base_addr_arr);
+	kfree(chipid_arr);
+	return 0;
+
+error:
+	kfree(pmu_ptr->mem_info);
+	kfree(base_addr_arr);
+	kfree(chipid_arr);
+	return -1;
+}
+
+/*
+ * imc_pmu_create : Takes the parent device which is the pmu unit, pmu_index
+ *		    and domain as the inputs.
+ * Allocates memory for the struct imc_pmu, sets up its domain, size and offsets
+ */
+static int imc_pmu_create(struct device_node *parent, int pmu_index, int domain)
+{
+	int ret = 0;
+	struct imc_pmu *pmu_ptr;
+	u32 offset;
+
+	/* memory for pmu */
+	pmu_ptr = kzalloc(sizeof(struct imc_pmu), GFP_KERNEL);
+	if (!pmu_ptr)
+		return -ENOMEM;
+
+	/* Set the domain */
+	pmu_ptr->domain = domain;
+
+	ret = of_property_read_u32(parent, "size", &pmu_ptr->counter_mem_size);
+	if (ret) {
+		ret = -EINVAL;
+		goto free_pmu;
+	}
+
+	if (!of_property_read_u32(parent, "offset", &offset)) {
+		if (imc_get_mem_addr_nest(parent, pmu_ptr, offset)) {
+			ret = -EINVAL;
+			goto free_pmu;
+		}
+	}
+
+	return 0;
+
+free_pmu:
+	kfree(pmu_ptr);
+	return ret;
+}
+
+static void disable_nest_pmu_counters(void)
+{
+	int nid, cpu;
+	struct cpumask *l_cpumask;
+
+	get_online_cpus();
+	for_each_online_node(nid) {
+		l_cpumask = cpumask_of_node(nid);
+		cpu = cpumask_first(l_cpumask);
+		opal_imc_counters_stop(OPAL_IMC_COUNTERS_NEST,
+				       get_hard_smp_processor_id(cpu));
+	}
+	put_online_cpus();
+}
+
+static void disable_core_pmu_counters(void)
+{
+	cpumask_t cores_map;
+	int cpu, rc;
+
+	get_online_cpus();
+	/* Disable the IMC Core functions */
+	cores_map = cpu_online_cores_map();
+	for_each_cpu(cpu, &cores_map) {
+		rc = opal_imc_counters_stop(OPAL_IMC_COUNTERS_CORE,
+					    get_hard_smp_processor_id(cpu));
+		if (rc)
+			pr_err("%s: Failed to stop Core (cpu = %d)\n",
+				__FUNCTION__, cpu);
+	}
+	put_online_cpus();
+}
+
+static int opal_imc_counters_probe(struct platform_device *pdev)
+{
+	struct device_node *imc_dev = pdev->dev.of_node;
+	int pmu_count = 0, domain;
+	u32 type;
+
+	/*
+	 * Check whether this is kdump kernel. If yes, force the engines to
+	 * stop and return.
+	 */
+	if (is_kdump_kernel()) {
+		disable_nest_pmu_counters();
+		disable_core_pmu_counters();
+		return -ENODEV;
+	}
+
+	for_each_compatible_node(imc_dev, NULL, IMC_DTB_UNIT_COMPAT) {
+		if (of_property_read_u32(imc_dev, "type", &type)) {
+			pr_warn("IMC Device without type property\n");
+			continue;
+		}
+
+		switch (type) {
+		case IMC_TYPE_CHIP:
+			domain = IMC_DOMAIN_NEST;
+			break;
+		case IMC_TYPE_CORE:
+			domain =IMC_DOMAIN_CORE;
+			break;
+		case IMC_TYPE_THREAD:
+			domain = IMC_DOMAIN_THREAD;
+			break;
+		default:
+			pr_warn("IMC Unknown Device type \n");
+			domain = -1;
+			break;
+		}
+
+		if (!imc_pmu_create(imc_dev, pmu_count, domain))
+			pmu_count++;
+	}
+
+	return 0;
+}
+
+static void opal_imc_counters_shutdown(struct platform_device *pdev)
+{
+	/*
+	 * Function only stops the engines which is bare minimum.
+	 * TODO: Need to handle proper memory cleanup and pmu
+	 * unregister.
+	 */
+	disable_nest_pmu_counters();
+	disable_core_pmu_counters();
+}
+
+static const struct of_device_id opal_imc_match[] = {
+	{ .compatible = IMC_DTB_COMPAT },
+	{},
+};
+
+static struct platform_driver opal_imc_driver = {
+	.driver = {
+		.name = "opal-imc-counters",
+		.of_match_table = opal_imc_match,
+	},
+	.probe = opal_imc_counters_probe,
+	.shutdown = opal_imc_counters_shutdown,
+};
+
+builtin_platform_driver(opal_imc_driver);
