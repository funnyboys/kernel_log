commit 68e0aa8ec5cedec48dd5b11df84afc956c8f85be
Author: Claudio Carvalho <cclaudio@linux.ibm.com>
Date:   Wed Aug 28 23:05:21 2019 +1000

    powerpc/powernv: Add ultravisor message log interface
    
    The ultravisor (UV) provides an in-memory console which follows the
    OPAL in-memory console structure.
    
    This patch extends the OPAL msglog code to initialize the UV memory
    console and provide the "/sys/firmware/ultravisor/msglog" interface
    for userspace to view the UV message log.
    
    Signed-off-by: Claudio Carvalho <cclaudio@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Tested-by: Claudio Carvalho <cclaudio@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20190828130521.26764-2-mpe@ellerman.id.au

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index fd4a1c5a6369..1aa51c4fa904 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -30,4 +30,9 @@ extern void opal_event_shutdown(void);
 
 bool cpu_core_split_required(void);
 
+struct memcons;
+ssize_t memcons_copy(struct memcons *mc, char *to, loff_t pos, size_t count);
+u32 memcons_get_size(struct memcons *mc);
+struct memcons *memcons_init(struct device_node *node, const char *mc_prop_name);
+
 #endif /* _POWERNV_H */

commit 56c0b48b1e443efa5d6f4d60513302c934e55b17
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Fri May 11 03:20:05 2018 +1000

    powerpc/powernv: process all OPAL event interrupts with kopald
    
    Using irq_work for processing OPAL event interrupts is not necessary.
    irq_work is typically used to schedule work from NMI context, a
    softirq may be more appropriate. However OPAL events are not
    particularly performance or latency critical, so they can all be
    invoked by kopald.
    
    This patch removes the irq_work queueing, and instead wakes up
    kopald when there is an event to be processed. kopald processes
    interrupts individually, enabling irqs and calling cond_resched
    between each one to minimise latencies.
    
    Event handlers themselves should still use threaded handlers,
    workqueues, etc. as necessary to avoid high interrupts-off latencies
    within any single interrupt.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 94f17ab1374b..fd4a1c5a6369 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -24,7 +24,8 @@ extern u32 pnv_get_supported_cpuidle_states(void);
 
 extern void pnv_lpc_init(void);
 
-extern void opal_handle_events(uint64_t events);
+extern void opal_handle_events(void);
+extern bool opal_have_pending_events(void);
 extern void opal_event_shutdown(void);
 
 bool cpu_core_split_required(void);

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index a159d48573d7..94f17ab1374b 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef _POWERNV_H
 #define _POWERNV_H
 

commit b746e3e01e70d23ef53dcde1203ab78a1b7ac514
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Jul 19 16:59:10 2017 +1000

    powerpc/powernv: Flush console before platform error reboot
    
    Unrecovered MCE and HMI errors are sent through a special restart OPAL
    call to log the platform error. The downside is that they don't go
    through normal Linux crash paths, so they don't give much information
    to the Linux console.
    
    Change this by providing a special crash function which does some of
    the console flushing from the panic() path before calling firmware to
    reboot.
    
    The downside of this is a little more code to execute before reaching
    the firmware reboot. However in practice, it's critical to get the
    Linux console messages output in order to debug a problem. So this is
    a desirable tradeoff.
    
    Note on the implementation: It is difficult to plumb a custom reboot
    handler into the panic path, because panic does a little bit too much
    work. For example, it will try to delay with the timebase, but that
    may be corrupted in some cases resulting in a hang without reaching
    the platform reboot. Another problem is that panic can invoke the
    crash dump code which is not what we want in the case of a hardware
    platform error. Long-term the best solution will be to rework the
    panic path so it can be suitable for this kind of panic, but for now
    we just duplicate a bit of the code.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Reviewed-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 6dbc0a1da1f6..a159d48573d7 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -7,6 +7,8 @@ extern void pnv_smp_init(void);
 static inline void pnv_smp_init(void) { }
 #endif
 
+extern void pnv_platform_error_reboot(struct pt_regs *regs, const char *msg) __noreturn;
+
 struct pci_dev;
 
 #ifdef CONFIG_PCI

commit a7cd88da97040513e17cd77ae3e57764e854bae4
Author: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
Date:   Wed Mar 22 20:34:14 2017 +0530

    powerpc/powernv: Move CPU-Offline idle state invocation from smp.c to idle.c
    
    Move the piece of code in powernv/smp.c::pnv_smp_cpu_kill_self() which
    transitions the CPU to the deepest available platform idle state to a
    new function named pnv_cpu_offline() in powernv/idle.c. The rationale
    behind this code movement is that the data required to determine the
    deepest available platform state resides in powernv/idle.c.
    
    Reviewed-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 613052232475..6dbc0a1da1f6 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -18,8 +18,6 @@ static inline void pnv_pci_shutdown(void) { }
 #endif
 
 extern u32 pnv_get_supported_cpuidle_states(void);
-extern u64 pnv_deepest_stop_psscr_val;
-extern u64 pnv_deepest_stop_psscr_mask;
 
 extern void pnv_lpc_init(void);
 

commit 09206b600c76f20984e80d99f3b5343c79332a97
Author: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
Date:   Wed Jan 25 14:06:28 2017 +0530

    powernv: Pass PSSCR value and mask to power9_idle_stop
    
    The power9_idle_stop method currently takes only the requested stop
    level as a parameter and picks up the rest of the PSSCR bits from a
    hand-coded macro. This is not a very flexible design, especially when
    the firmware has the capability to communicate the psscr value and the
    mask associated with a particular stop state via device tree.
    
    This patch modifies the power9_idle_stop API to take as parameters the
    PSSCR value and the PSSCR mask corresponding to the stop state that
    needs to be set. These PSSCR value and mask are respectively obtained
    by parsing the "ibm,cpu-idle-state-psscr" and
    "ibm,cpu-idle-state-psscr-mask" fields from the device tree.
    
    In addition to this, the patch adds support for handling stop states
    for which ESL and EC bits in the PSSCR are zero. As per the
    architecture, a wakeup from these stop states resumes execution from
    the subsequent instruction as opposed to waking up at the System
    Vector.
    
    The older firmware sets only the Requested Level (RL) field in the
    psscr and psscr-mask exposed in the device tree. For older firmware
    where psscr-mask=0xf, this patch will set the default sane values that
    the set for for remaining PSSCR fields (i.e PSLL, MTL, ESL, EC, and
    TR). For the new firmware, the patch will validate that the invariants
    required by the ISA for the psscr values are maintained by the
    firmware.
    
    This skiboot patch that exports fully populated PSSCR values and the
    mask for all the stop states can be found here:
    https://lists.ozlabs.org/pipermail/skiboot/2016-September/004869.html
    
    [Optimize the number of instructions before entering STOP with
    ESL=EC=0, validate the PSSCR values provided by the firimware
    maintains the invariants required as per the ISA suggested by Balbir
    Singh]
    
    Acked-by: Balbir Singh <bsingharora@gmail.com>
    Signed-off-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index da7c843ac7f1..613052232475 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -18,7 +18,8 @@ static inline void pnv_pci_shutdown(void) { }
 #endif
 
 extern u32 pnv_get_supported_cpuidle_states(void);
-extern u64 pnv_deepest_stop_state;
+extern u64 pnv_deepest_stop_psscr_val;
+extern u64 pnv_deepest_stop_psscr_mask;
 
 extern void pnv_lpc_init(void);
 

commit c0691f9dd2066087524d2b4498c0c9331f26dcd5
Author: Shreyas B. Prabhu <shreyas@linux.vnet.ibm.com>
Date:   Fri Jul 8 11:50:53 2016 +0530

    powerpc/powernv: Use deepest stop state when cpu is offlined
    
    If hardware supports stop state, use the deepest stop state when
    the cpu is offlined.
    
    Reviewed-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
    Signed-off-by: Shreyas B. Prabhu <shreyas@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 6dbc0a1da1f6..da7c843ac7f1 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -18,6 +18,7 @@ static inline void pnv_pci_shutdown(void) { }
 #endif
 
 extern u32 pnv_get_supported_cpuidle_states(void);
+extern u64 pnv_deepest_stop_state;
 
 extern void pnv_lpc_init(void);
 

commit 53522982fc3c254bb4444c336cb005c8636930c8
Author: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
Date:   Fri Aug 7 13:45:54 2015 +1000

    powerpc/powernv: move dma_get_required_mask from pnv_phb to pci_controller_ops
    
    Simplify the dma_get_required_mask call chain by moving it from pnv_phb to
    pci_controller_ops, similar to commit 763d2d8df1ee ("powerpc/powernv:
    Move dma_set_mask from pnv_phb to pci_controller_ops").
    
    Previous call chain:
    
      0) call dma_get_required_mask() (kernel/dma.c)
      1) call ppc_md.dma_get_required_mask, if it exists. On powernv, that
         points to pnv_dma_get_required_mask() (platforms/powernv/setup.c)
      2) device is PCI, therefore call pnv_pci_dma_get_required_mask()
         (platforms/powernv/pci.c)
      3) call phb->dma_get_required_mask if it exists
      4) it only exists in the ioda case, where it points to
           pnv_pci_ioda_dma_get_required_mask() (platforms/powernv/pci-ioda.c)
    
    New call chain:
    
      0) call dma_get_required_mask() (kernel/dma.c)
      1) device is PCI, therefore call pci_controller_ops.dma_get_required_mask
         if it exists
      2) in the ioda case, that points to pnv_pci_ioda_dma_get_required_mask()
         (platforms/powernv/pci-ioda.c)
    
    In the p5ioc2 case, the call chain remains the same -
    dma_get_required_mask() does not find either a ppc_md call or
    pci_controller_ops call, so it calls __dma_get_required_mask().
    
    Signed-off-by: Andrew Donnellan <andrew.donnellan@au1.ibm.com>
    Reviewed-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 9269e30e4ca0..6dbc0a1da1f6 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -12,15 +12,9 @@ struct pci_dev;
 #ifdef CONFIG_PCI
 extern void pnv_pci_init(void);
 extern void pnv_pci_shutdown(void);
-extern u64 pnv_pci_dma_get_required_mask(struct pci_dev *pdev);
 #else
 static inline void pnv_pci_init(void) { }
 static inline void pnv_pci_shutdown(void) { }
-
-static inline u64 pnv_pci_dma_get_required_mask(struct pci_dev *pdev)
-{
-	return 0;
-}
 #endif
 
 extern u32 pnv_get_supported_cpuidle_states(void);

commit 763d2d8df1ee2b92ff09cd58f6034021e2cabf6d
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Apr 28 15:12:07 2015 +1000

    powerpc/powernv: Move dma_set_mask() from pnv_phb to pci_controller_ops
    
    Previously, dma_set_mask() on powernv was convoluted:
     0) Call dma_set_mask() (a/p/kernel/dma.c)
     1) In dma_set_mask(), ppc_md.dma_set_mask() exists, so call it.
     2) On powernv, that function pointer is pnv_dma_set_mask().
        In pnv_dma_set_mask(), the device is pci, so call pnv_pci_dma_set_mask().
     3) In pnv_pci_dma_set_mask(), call pnv_phb->set_dma_mask() if it exists.
     4) It only exists in the ioda case, where it points to
        pnv_pci_ioda_dma_set_mask(), which is the final function.
    
    So the call chain is:
     dma_set_mask() ->
      pnv_dma_set_mask() ->
       pnv_pci_dma_set_mask() ->
        pnv_pci_ioda_dma_set_mask()
    
    Both ppc_md and pnv_phb function pointers are used.
    
    Rip out the ppc_md call, pnv_dma_set_mask() and pnv_pci_dma_set_mask().
    
    Instead:
     0) Call dma_set_mask() (a/p/kernel/dma.c)
     1) In dma_set_mask(), the device is pci, and pci_controller_ops.dma_set_mask()
        exists, so call pci_controller_ops.dma_set_mask()
     2) In the ioda case, that points to pnv_pci_ioda_dma_set_mask().
    
    The new call chain is
     dma_set_mask() ->
      pnv_pci_ioda_dma_set_mask()
    
    Now only the pci_controller_ops function pointer is used.
    
    The fallback paths for p5ioc2 are the same.
    
    Previously, pnv_pci_dma_set_mask() would find no pnv_phb->set_dma_mask()
    function, to it would call __set_dma_mask().
    
    Now, dma_set_mask() finds no ppc_md call or pci_controller_ops call,
    so it calls __set_dma_mask().
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index addd15cdbabc..9269e30e4ca0 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -12,17 +12,11 @@ struct pci_dev;
 #ifdef CONFIG_PCI
 extern void pnv_pci_init(void);
 extern void pnv_pci_shutdown(void);
-extern int pnv_pci_dma_set_mask(struct pci_dev *pdev, u64 dma_mask);
 extern u64 pnv_pci_dma_get_required_mask(struct pci_dev *pdev);
 #else
 static inline void pnv_pci_init(void) { }
 static inline void pnv_pci_shutdown(void) { }
 
-static inline int pnv_pci_dma_set_mask(struct pci_dev *pdev, u64 dma_mask)
-{
-	return -ENODEV;
-}
-
 static inline u64 pnv_pci_dma_get_required_mask(struct pci_dev *pdev)
 {
 	return 0;

commit 92ae03532619dc24fdb7a5ae8ea63785fbd39f86
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Apr 28 15:12:05 2015 +1000

    powerpc/powernv: Specialise pci_controller_ops for each controller type
    
    Remove powernv generic PCI controller operations. Replace it with
    controller ops for each of the two supported PHBs.
    
    As an added bonus, make the two new structs const, which will help
    guard against bugs such as the one introduced in 65ebf4b63
    ("powerpc/powernv: Move controller ops from ppc_md to controller_ops")
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index f907f0a494da..addd15cdbabc 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -29,8 +29,6 @@ static inline u64 pnv_pci_dma_get_required_mask(struct pci_dev *pdev)
 }
 #endif
 
-extern struct pci_controller_ops pnv_pci_controller_ops;
-
 extern u32 pnv_get_supported_cpuidle_states(void);
 
 extern void pnv_lpc_init(void);

commit 81f2f7ce4c5bb688ad691cb3ee37e81ca26a8a3b
Author: Alistair Popple <alistair@popple.id.au>
Date:   Fri May 15 14:06:44 2015 +1000

    opal: Remove events notifier
    
    All users of the old opal events notifier have been converted over to
    the irq domain so remove the event notifier functions.
    
    Signed-off-by: Alistair Popple <alistair@popple.id.au>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 221d4c827fc5..f907f0a494da 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -35,7 +35,6 @@ extern u32 pnv_get_supported_cpuidle_states(void);
 
 extern void pnv_lpc_init(void);
 
-extern void opal_do_notifier(uint64_t events);
 extern void opal_handle_events(uint64_t events);
 extern void opal_event_shutdown(void);
 

commit 9f0fd0499d30dbd61632463f293e2e826fa363b1
Author: Alistair Popple <alistair@popple.id.au>
Date:   Fri May 15 14:06:37 2015 +1000

    powerpc/powernv: Add a virtual irqchip for opal events
    
    Whenever an interrupt is received for opal the linux kernel gets a
    bitfield indicating certain events that have occurred and need handling
    by the various device drivers. Currently this is handled using a
    notifier interface where we call every device driver that has
    registered to receive opal events.
    
    This approach has several drawbacks. For example each driver has to do
    its own checking to see if the event is relevant as well as event
    masking. There is also no easy method of recording the number of times
    we receive particular events.
    
    This patch solves these issues by exposing opal events via the
    standard interrupt APIs by adding a new interrupt chip and
    domain. Drivers can then register for the appropriate events using
    standard kernel calls such as irq_of_parse_and_map().
    
    Signed-off-by: Alistair Popple <alistair@popple.id.au>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 826d2c9bea56..221d4c827fc5 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -35,6 +35,10 @@ extern u32 pnv_get_supported_cpuidle_states(void);
 
 extern void pnv_lpc_init(void);
 
+extern void opal_do_notifier(uint64_t events);
+extern void opal_handle_events(uint64_t events);
+extern void opal_event_shutdown(void);
+
 bool cpu_core_split_required(void);
 
 #endif /* _POWERNV_H */

commit 65ebf4b6370e8eabbf31076de022e49926dd4573
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Mar 31 16:00:51 2015 +1100

    powerpc/powernv: Move controller ops from ppc_md to controller_ops
    
    This moves the PowerNV platform to use the pci_controller_ops
    structure rather than ppc_md for PCI controller operations.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 604c48e7879a..826d2c9bea56 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -29,6 +29,8 @@ static inline u64 pnv_pci_dma_get_required_mask(struct pci_dev *pdev)
 }
 #endif
 
+extern struct pci_controller_ops pnv_pci_controller_ops;
+
 extern u32 pnv_get_supported_cpuidle_states(void);
 
 extern void pnv_lpc_init(void);

commit 8eb8ac89a364305d05ad16be983b7890eb462cc3
Author: Shreyas B. Prabhu <shreyas@linux.vnet.ibm.com>
Date:   Wed Dec 10 00:26:51 2014 +0530

    powerpc/powernv: Enable Offline CPUs to enter deep idle states
    
    The secondary threads should enter deep idle states so as to gain maximum
    powersavings when the entire core is offline. To do so the offline path
    must be made aware of the available deepest idle state. Hence probe the
    device tree for the possible idle states in powernv core code and
    expose the deepest idle state through flags.
    
    Since the  device tree is probed by the cpuidle driver as well, move
    the parameters required to discover the idle states into an appropriate
    common place to both the driver and the powernv core code.
    
    Another point is that fastsleep idle state may require workarounds in
    the kernel to function properly. This workaround is introduced in the
    subsequent patches. However neither the cpuidle driver or the hotplug
    path need be bothered about this workaround.
    
    They will be taken care of by the core powernv code.
    
    Originally-by: Srivatsa S. Bhat <srivatsa@mit.edu>
    Signed-off-by: Preeti U. Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Shreyas B. Prabhu <shreyas@linux.vnet.ibm.com>
    Reviewed-by: Paul Mackerras <paulus@samba.org>
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: linux-pm@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 6c8e2d188cd0..604c48e7879a 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -29,6 +29,8 @@ static inline u64 pnv_pci_dma_get_required_mask(struct pci_dev *pdev)
 }
 #endif
 
+extern u32 pnv_get_supported_cpuidle_states(void);
+
 extern void pnv_lpc_init(void);
 
 bool cpu_core_split_required(void);

commit fe7e85c6f5ff63a8cd081deb35e58a0bd47589cd
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue Sep 30 12:39:10 2014 +1000

    powerpc/powernv: Override dma_get_required_mask()
    
    The dma_get_required_mask() function is used by some drivers to
    query the platform about what DMA mask is needed to cover all of
    memory. This is a bit of a strange semantic when we have to choose
    between IOMMU translation or bypass, but essentially what it means
    is "what DMA mask will give best performances".
    
    Currently, our IOMMU backend always returns a 32-bit mask here, we
    don't do anything special to it when we have bypass available. This
    causes some drivers to choose a 32-bit mask, thus losing the ability
    to use the bypass window, thinking this is more efficient. The problem
    was reported from the driver of following device:
    
    0004:03:00.0 0107: 1000:0087 (rev 05)
    0004:03:00.0 Serial Attached SCSI controller: LSI Logic / Symbios \
                 Logic SAS2308 PCI-Express Fusion-MPT SAS-2 (rev 05)
    
    This patch adds an override of that function in order to, instead,
    return a 64-bit mask whenever a bypass window is available in order
    for drivers to prefer this configuration.
    
    Reported-by: Murali N. Iyer <mniyer@us.ibm.com>
    Suggested-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 75501bfede7f..6c8e2d188cd0 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -13,6 +13,7 @@ struct pci_dev;
 extern void pnv_pci_init(void);
 extern void pnv_pci_shutdown(void);
 extern int pnv_pci_dma_set_mask(struct pci_dev *pdev, u64 dma_mask);
+extern u64 pnv_pci_dma_get_required_mask(struct pci_dev *pdev);
 #else
 static inline void pnv_pci_init(void) { }
 static inline void pnv_pci_shutdown(void) { }
@@ -21,6 +22,11 @@ static inline int pnv_pci_dma_set_mask(struct pci_dev *pdev, u64 dma_mask)
 {
 	return -ENODEV;
 }
+
+static inline u64 pnv_pci_dma_get_required_mask(struct pci_dev *pdev)
+{
+	return 0;
+}
 #endif
 
 extern void pnv_lpc_init(void);

commit e2186023f2d81ee7bb42d2a7dec3d889df7cdace
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Fri May 23 18:15:30 2014 +1000

    powerpc/powernv: Add support for POWER8 split core on powernv
    
    Upcoming POWER8 chips support a concept called split core. This is where the
    core can be split into subcores that although not full cores, are able to
    appear as full cores to a guest.
    
    The splitting & unsplitting procedure is mildly complicated, and explained at
    length in the comments within the patch.
    
    One notable detail is that when splitting or unsplitting we need to pull
    offline cpus out of their offline state to do work as part of the procedure.
    
    The interface for changing the split mode is via a sysfs file, eg:
    
     $ echo 2 > /sys/devices/system/cpu/subcores_per_core
    
    Currently supported values are '1', '2' and '4'. And indicate respectively that
    the core should be unsplit, split in half, and split in quarters. These modes
    correspond to threads_per_subcore of 8, 4 and 2.
    
    We do not allow changing the split mode while KVM VMs are active. This is to
    prevent the value changing while userspace is configuring the VM, and also to
    prevent the mode being changed in such a way that existing guests are unable to
    be run.
    
    CPU hotplug fixes by Srivatsa.  max_cpus fixes by Mahesh.  cpuset fixes by
    benh.  Fix for irq race by paulus.  The rest by mikey and mpe.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 0051e108ef0f..75501bfede7f 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -25,4 +25,6 @@ static inline int pnv_pci_dma_set_mask(struct pci_dev *pdev, u64 dma_mask)
 
 extern void pnv_lpc_init(void);
 
+bool cpu_core_split_required(void);
+
 #endif /* _POWERNV_H */

commit cd15b048445d0a54f7147c35a86c5a16ef231554
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Feb 11 11:32:38 2014 +1100

    powerpc/powernv: Add iommu DMA bypass support for IODA2
    
    This patch adds the support for to create a direct iommu "bypass"
    window on IODA2 bridges (such as Power8) allowing to bypass iommu
    page translation completely for 64-bit DMA capable devices, thus
    significantly improving DMA performances.
    
    Additionally, this adds a hook to the struct iommu_table so that
    the IOMMU API / VFIO can disable the bypass when external ownership
    is requested, since in that case, the device will be used by an
    environment such as userspace or a KVM guest which must not be
    allowed to bypass translations.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index de6819be1f95..0051e108ef0f 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -7,12 +7,20 @@ extern void pnv_smp_init(void);
 static inline void pnv_smp_init(void) { }
 #endif
 
+struct pci_dev;
+
 #ifdef CONFIG_PCI
 extern void pnv_pci_init(void);
 extern void pnv_pci_shutdown(void);
+extern int pnv_pci_dma_set_mask(struct pci_dev *pdev, u64 dma_mask);
 #else
 static inline void pnv_pci_init(void) { }
 static inline void pnv_pci_shutdown(void) { }
+
+static inline int pnv_pci_dma_set_mask(struct pci_dev *pdev, u64 dma_mask)
+{
+	return -ENODEV;
+}
 #endif
 
 extern void pnv_lpc_init(void);

commit 3fafe9c202321a3edc47386d2071af89555c9f45
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jul 15 13:03:11 2013 +1000

    powerpc/powernv: Add PIO accessors for Power8 LPC bus
    
    This uses the hooks provided by CONFIG_PPC_INDIRECT_PIO to
    implement a set of hooks for IO port access to use the LPC
    bus via OPAL calls for the first 64K of IO space
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index a1c6f83fc391..de6819be1f95 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -15,4 +15,6 @@ static inline void pnv_pci_init(void) { }
 static inline void pnv_pci_shutdown(void) { }
 #endif
 
+extern void pnv_lpc_init(void);
+
 #endif /* _POWERNV_H */

commit 73ed148aea9dc0508be7e30e7a447f55c1b2f378
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri May 10 16:59:18 2013 +1000

    powerpc/powernv: Improve kexec reliability
    
    We add a machine_shutdown hook that frees the OPAL interrupts
    (so they get masked at the source and don't fire while kexec'ing)
    and which triggers an IODA reset on all the PCIe host bridges
    which will have the effect of blocking all DMAs and subsequent
    PCIs interrupts.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 8a9df7f9667e..a1c6f83fc391 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -9,8 +9,10 @@ static inline void pnv_smp_init(void) { }
 
 #ifdef CONFIG_PCI
 extern void pnv_pci_init(void);
+extern void pnv_pci_shutdown(void);
 #else
 static inline void pnv_pci_init(void) { }
+static inline void pnv_pci_shutdown(void) { }
 #endif
 
 #endif /* _POWERNV_H */

commit 61305a96fad622ae0f0e78cb06f67ad721d378f9
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Sep 19 17:45:05 2011 +0000

    powerpc/powernv: Add support for p5ioc2 PCI-X and PCIe
    
    This adds support for PCI-X and PCIe on the p5ioc2 IO hub using
    OPAL. This includes allocating & setting up TCE tables and config
    space access routines.
    
    This also supports fallbacks via RTAS when OPAL is absent, using
    legacy TCE format pre-allocated via the device-tree (BML style)
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
index 35b716008cd3..8a9df7f9667e 100644
--- a/arch/powerpc/platforms/powernv/powernv.h
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -7,4 +7,10 @@ extern void pnv_smp_init(void);
 static inline void pnv_smp_init(void) { }
 #endif
 
+#ifdef CONFIG_PCI
+extern void pnv_pci_init(void);
+#else
+static inline void pnv_pci_init(void) { }
+#endif
+
 #endif /* _POWERNV_H */

commit 55190f88789ab62a42c3ee050090406b0bcefff8
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Sep 19 17:44:52 2011 +0000

    powerpc: Add skeleton PowerNV platform
    
    This adds a skeletton for the new Power "Non Virtualized"
    platform which will be used by machines supporting running
    without an hypervisor, for example in order to run KVM.
    
    These machines will be using a new firmware called OPAL
    for which the support will be provided by later patches.
    
    The PowerNV platform is intended to be also usable under
    the BML environment used internally for early CPU bringup
    which is why the code also supports using RTAS instead of
    OPAL in various places.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/powernv/powernv.h b/arch/powerpc/platforms/powernv/powernv.h
new file mode 100644
index 000000000000..35b716008cd3
--- /dev/null
+++ b/arch/powerpc/platforms/powernv/powernv.h
@@ -0,0 +1,10 @@
+#ifndef _POWERNV_H
+#define _POWERNV_H
+
+#ifdef CONFIG_SMP
+extern void pnv_smp_init(void);
+#else
+static inline void pnv_smp_init(void) { }
+#endif
+
+#endif /* _POWERNV_H */
