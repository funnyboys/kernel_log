commit e31cf2f4ca422ac9b14ecc4a1295b8977a20f812
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:33 2020 -0700

    mm: don't include asm/pgtable.h if linux/mm.h is already included
    
    Patch series "mm: consolidate definitions of page table accessors", v2.
    
    The low level page table accessors (pXY_index(), pXY_offset()) are
    duplicated across all architectures and sometimes more than once.  For
    instance, we have 31 definition of pgd_offset() for 25 supported
    architectures.
    
    Most of these definitions are actually identical and typically it boils
    down to, e.g.
    
    static inline unsigned long pmd_index(unsigned long address)
    {
            return (address >> PMD_SHIFT) & (PTRS_PER_PMD - 1);
    }
    
    static inline pmd_t *pmd_offset(pud_t *pud, unsigned long address)
    {
            return (pmd_t *)pud_page_vaddr(*pud) + pmd_index(address);
    }
    
    These definitions can be shared among 90% of the arches provided
    XYZ_SHIFT, PTRS_PER_XYZ and xyz_page_vaddr() are defined.
    
    For architectures that really need a custom version there is always
    possibility to override the generic version with the usual ifdefs magic.
    
    These patches introduce include/linux/pgtable.h that replaces
    include/asm-generic/pgtable.h and add the definitions of the page table
    accessors to the new header.
    
    This patch (of 12):
    
    The linux/mm.h header includes <asm/pgtable.h> to allow inlining of the
    functions involving page table manipulations, e.g.  pte_alloc() and
    pmd_alloc().  So, there is no point to explicitly include <asm/pgtable.h>
    in the files that include <linux/mm.h>.
    
    The include statements in such cases are remove with a simple loop:
    
            for f in $(git grep -l "include <linux/mm.h>") ; do
                    sed -i -e '/include <asm\/pgtable.h>/ d' $f
            done
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Mike Rapoport <rppt@kernel.org>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-1-rppt@kernel.org
    Link: http://lkml.kernel.org/r/20200514170327.31389-2-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 64d18f4bf093..2db8469e475f 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -43,7 +43,6 @@
 #include <asm/mmu.h>
 #include <asm/processor.h>
 #include <asm/io.h>
-#include <asm/pgtable.h>
 #include <asm/prom.h>
 #include <asm/rtas.h>
 #include <asm/pci-bridge.h>

commit 7368b38b21bfa39df637701a480262c15ab1a49e
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Fri May 8 14:33:57 2020 +1000

    powerpc/pseries/ras: Avoid calling rtas_token() in NMI paths
    
    In the interest of reducing code and possible failures in the
    machine check and system reset paths, grab the "ibm,nmi-interlock"
    token at init time.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Reviewed-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Reviewed-by: Mahesh Salgaonkar <mahesh@linux.ibm.com>
    Link: https://lore.kernel.org/r/20200508043408.886394-6-npiggin@gmail.com

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 1b55e804927d..64d18f4bf093 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -84,6 +84,7 @@ unsigned long CMO_PageSize = (ASM_CONST(1) << IOMMU_PAGE_SHIFT_4K);
 EXPORT_SYMBOL(CMO_PageSize);
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
+int ibm_nmi_interlock_token;
 
 static void pSeries_show_cpuinfo(struct seq_file *m)
 {
@@ -114,9 +115,14 @@ static void __init fwnmi_init(void)
 	struct slb_entry *slb_ptr;
 	size_t size;
 #endif
+	int ibm_nmi_register_token;
 
-	int ibm_nmi_register = rtas_token("ibm,nmi-register");
-	if (ibm_nmi_register == RTAS_UNKNOWN_SERVICE)
+	ibm_nmi_register_token = rtas_token("ibm,nmi-register");
+	if (ibm_nmi_register_token == RTAS_UNKNOWN_SERVICE)
+		return;
+
+	ibm_nmi_interlock_token = rtas_token("ibm,nmi-interlock");
+	if (WARN_ON(ibm_nmi_interlock_token == RTAS_UNKNOWN_SERVICE))
 		return;
 
 	/* If the kernel's not linked at zero we point the firmware at low
@@ -124,8 +130,8 @@ static void __init fwnmi_init(void)
 	system_reset_addr  = __pa(system_reset_fwnmi) - PHYSICAL_START;
 	machine_check_addr = __pa(machine_check_fwnmi) - PHYSICAL_START;
 
-	if (0 == rtas_call(ibm_nmi_register, 2, 1, NULL, system_reset_addr,
-				machine_check_addr))
+	if (0 == rtas_call(ibm_nmi_register_token, 2, 1, NULL,
+			   system_reset_addr, machine_check_addr))
 		fwnmi_active = 1;
 
 	/*

commit dc8afce5f45b099e3ea52a16b2f90e92f90f3af0
Author: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
Date:   Tue Apr 7 14:17:41 2020 +0530

    powerpc/pseries: Account for SPURR ticks on idle CPUs
    
    On Pseries LPARs, to calculate utilization, we need to know the
    [S]PURR ticks when the CPUs were busy or idle.
    
    Via pseries_idle_prolog(), pseries_idle_epilog(), we track the idle
    PURR ticks in the VPA variable "wait_state_cycles". This patch extends
    the support to account for the idle SPURR ticks.
    
    Signed-off-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/1586249263-14048-4-git-send-email-ego@linux.vnet.ibm.com

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 4905c965e111..1b55e804927d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -318,7 +318,9 @@ static int alloc_dispatch_log_kmem_cache(void)
 }
 machine_early_initcall(pseries, alloc_dispatch_log_kmem_cache);
 
+DEFINE_PER_CPU(u64, idle_spurr_cycles);
 DEFINE_PER_CPU(u64, idle_entry_purr_snap);
+DEFINE_PER_CPU(u64, idle_entry_spurr_snap);
 static void pseries_lpar_idle(void)
 {
 	/*

commit c4019198cfa81224d32846915cd401e981f81b81
Author: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
Date:   Tue Apr 7 14:17:40 2020 +0530

    powerpc/idle: Store PURR snapshot in a per-cpu global variable
    
    Currently when CPU goes idle, we take a snapshot of PURR via
    pseries_idle_prolog() which is used at the CPU idle exit to compute
    the idle PURR cycles via the function pseries_idle_epilog().  Thus,
    the value of idle PURR cycle thus read before pseries_idle_prolog() and
    after pseries_idle_epilog() is always correct.
    
    However, if we were to read the idle PURR cycles from an interrupt
    context between pseries_idle_prolog() and pseries_idle_epilog() (this
    will be done in a future patch), then, the value of the idle PURR thus
    read will not include the cycles spent in the most recent idle period.
    Thus, in that interrupt context, we will need access to the snapshot
    of the PURR before going idle, in order to compute the idle PURR
    cycles for the latest idle duration.
    
    In this patch, we save the snapshot of PURR in pseries_idle_prolog()
    in a per-cpu variable, instead of on the stack, so that it can be
    accessed from an interrupt context.
    
    Signed-off-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/1586249263-14048-3-git-send-email-ego@linux.vnet.ibm.com

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 2f53e6b031a7..4905c965e111 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -318,10 +318,9 @@ static int alloc_dispatch_log_kmem_cache(void)
 }
 machine_early_initcall(pseries, alloc_dispatch_log_kmem_cache);
 
+DEFINE_PER_CPU(u64, idle_entry_purr_snap);
 static void pseries_lpar_idle(void)
 {
-	unsigned long in_purr;
-
 	/*
 	 * Default handler to go into low thread priority and possibly
 	 * low power mode by ceding processor to hypervisor
@@ -331,7 +330,7 @@ static void pseries_lpar_idle(void)
 		return;
 
 	/* Indicate to hypervisor that we are idle. */
-	pseries_idle_prolog(&in_purr);
+	pseries_idle_prolog();
 
 	/*
 	 * Yield the processor to the hypervisor.  We return if
@@ -342,7 +341,7 @@ static void pseries_lpar_idle(void)
 	 */
 	cede_processor();
 
-	pseries_idle_epilog(in_purr);
+	pseries_idle_epilog();
 }
 
 /*

commit e4a884cc28fa3f5d8b81de46998ffe29b4ad169e
Author: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
Date:   Tue Apr 7 14:17:39 2020 +0530

    powerpc: Move idle_loop_prolog()/epilog() functions to header file
    
    Currently prior to entering an idle state on a Linux Guest, the
    pseries cpuidle driver implement an idle_loop_prolog() and
    idle_loop_epilog() functions which ensure that idle_purr is correctly
    computed, and the hypervisor is informed that the CPU cycles have been
    donated.
    
    These prolog and epilog functions are also required in the default
    idle call, i.e pseries_lpar_idle(). Hence move these accessor
    functions to a common header file and call them from
    pseries_lpar_idle(). Since the existing header files such as
    asm/processor.h have enough clutter, create a new header file
    asm/idle.h. Finally rename idle_loop_prolog() and idle_loop_epilog()
    to pseries_idle_prolog() and pseries_idle_epilog() as they are only
    relavent for on pseries guests.
    
    Signed-off-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/1586249263-14048-2-git-send-email-ego@linux.vnet.ibm.com

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 0c8421dd01ab..2f53e6b031a7 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -68,6 +68,7 @@
 #include <asm/isa-bridge.h>
 #include <asm/security_features.h>
 #include <asm/asm-const.h>
+#include <asm/idle.h>
 #include <asm/swiotlb.h>
 #include <asm/svm.h>
 
@@ -319,6 +320,8 @@ machine_early_initcall(pseries, alloc_dispatch_log_kmem_cache);
 
 static void pseries_lpar_idle(void)
 {
+	unsigned long in_purr;
+
 	/*
 	 * Default handler to go into low thread priority and possibly
 	 * low power mode by ceding processor to hypervisor
@@ -328,7 +331,7 @@ static void pseries_lpar_idle(void)
 		return;
 
 	/* Indicate to hypervisor that we are idle. */
-	get_lppaca()->idle = 1;
+	pseries_idle_prolog(&in_purr);
 
 	/*
 	 * Yield the processor to the hypervisor.  We return if
@@ -339,7 +342,7 @@ static void pseries_lpar_idle(void)
 	 */
 	cede_processor();
 
-	get_lppaca()->idle = 0;
+	pseries_idle_epilog(in_purr);
 }
 
 /*

commit 14c73bd344da60abaf7da3ea2e7733ddda35bbac
Author: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
Date:   Thu Dec 5 14:02:17 2019 +0530

    powerpc/vcpu: Assume dedicated processors as non-preempt
    
    With commit 247f2f6f3c70 ("sched/core: Don't schedule threads on
    pre-empted vCPUs"), the scheduler avoids preempted vCPUs to schedule
    tasks on wakeup. This leads to wrong choice of CPU, which in-turn
    leads to larger wakeup latencies. Eventually, it leads to performance
    regression in latency sensitive benchmarks like soltp, schbench etc.
    
    On Powerpc, vcpu_is_preempted() only looks at yield_count. If the
    yield_count is odd, the vCPU is assumed to be preempted. However
    yield_count is increased whenever the LPAR enters CEDE state (idle).
    So any CPU that has entered CEDE state is assumed to be preempted.
    
    Even if vCPU of dedicated LPAR is preempted/donated, it should have
    right of first-use since they are supposed to own the vCPU.
    
    On a Power9 System with 32 cores:
      # lscpu
      Architecture:        ppc64le
      Byte Order:          Little Endian
      CPU(s):              128
      On-line CPU(s) list: 0-127
      Thread(s) per core:  8
      Core(s) per socket:  1
      Socket(s):           16
      NUMA node(s):        2
      Model:               2.2 (pvr 004e 0202)
      Model name:          POWER9 (architected), altivec supported
      Hypervisor vendor:   pHyp
      Virtualization type: para
      L1d cache:           32K
      L1i cache:           32K
      L2 cache:            512K
      L3 cache:            10240K
      NUMA node0 CPU(s):   0-63
      NUMA node1 CPU(s):   64-127
    
      # perf stat -a -r 5 ./schbench
      v5.4                               v5.4 + patch
      Latency percentiles (usec)         Latency percentiles (usec)
            50.0000th: 45                      50.0th: 45
            75.0000th: 62                      75.0th: 63
            90.0000th: 71                      90.0th: 74
            95.0000th: 77                      95.0th: 78
            *99.0000th: 91                     *99.0th: 82
            99.5000th: 707                     99.5th: 83
            99.9000th: 6920                    99.9th: 86
            min=0, max=10048                   min=0, max=96
      Latency percentiles (usec)         Latency percentiles (usec)
            50.0000th: 45                      50.0th: 46
            75.0000th: 61                      75.0th: 64
            90.0000th: 72                      90.0th: 75
            95.0000th: 79                      95.0th: 79
            *99.0000th: 691                    *99.0th: 83
            99.5000th: 3972                    99.5th: 85
            99.9000th: 8368                    99.9th: 91
            min=0, max=16606                   min=0, max=117
      Latency percentiles (usec)         Latency percentiles (usec)
            50.0000th: 45                      50.0th: 46
            75.0000th: 61                      75.0th: 64
            90.0000th: 71                      90.0th: 75
            95.0000th: 77                      95.0th: 79
            *99.0000th: 106                    *99.0th: 83
            99.5000th: 2364                    99.5th: 84
            99.9000th: 7480                    99.9th: 90
            min=0, max=10001                   min=0, max=95
      Latency percentiles (usec)         Latency percentiles (usec)
            50.0000th: 45                      50.0th: 47
            75.0000th: 62                      75.0th: 65
            90.0000th: 72                      90.0th: 75
            95.0000th: 78                      95.0th: 79
            *99.0000th: 93                     *99.0th: 84
            99.5000th: 108                     99.5th: 85
            99.9000th: 6792                    99.9th: 90
            min=0, max=17681                   min=0, max=117
      Latency percentiles (usec)         Latency percentiles (usec)
            50.0000th: 46                      50.0th: 45
            75.0000th: 62                      75.0th: 64
            90.0000th: 73                      90.0th: 75
            95.0000th: 79                      95.0th: 79
            *99.0000th: 113                    *99.0th: 82
            99.5000th: 2724                    99.5th: 83
            99.9000th: 6184                    99.9th: 93
            min=0, max=9887                    min=0, max=111
    
       Performance counter stats for 'system wide' (5 runs):
    
      context-switches    43,373  ( +-  0.40% )   44,597 ( +-  0.55% )
      cpu-migrations       1,211  ( +-  5.04% )      220 ( +-  6.23% )
      page-faults         15,983  ( +-  5.21% )   15,360 ( +-  3.38% )
    
    Waiman Long suggested using static_keys.
    
    Fixes: 247f2f6f3c70 ("sched/core: Don't schedule threads on pre-empted vCPUs")
    Cc: stable@vger.kernel.org # v4.18+
    Reported-by: Parth Shah <parth@linux.ibm.com>
    Reported-by: Ihor Pasichnyk <Ihor.Pasichnyk@ibm.com>
    Tested-by: Juri Lelli <juri.lelli@redhat.com>
    Acked-by: Waiman Long <longman@redhat.com>
    Reviewed-by: Gautham R. Shenoy <ego@linux.vnet.ibm.com>
    Signed-off-by: Srikar Dronamraju <srikar@linux.vnet.ibm.com>
    Acked-by: Phil Auld <pauld@redhat.com>
    Reviewed-by: Vaidyanathan Srinivasan <svaidy@linux.ibm.com>
    Tested-by: Parth Shah <parth@linux.ibm.com>
    [mpe: Move the key and setting of the key to pseries/setup.c]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20191213035036.6913-1-mpe@ellerman.id.au

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 0a40201f315f..0c8421dd01ab 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -74,6 +74,9 @@
 #include "pseries.h"
 #include "../../../../drivers/pci/pci.h"
 
+DEFINE_STATIC_KEY_FALSE(shared_processor);
+EXPORT_SYMBOL_GPL(shared_processor);
+
 int CMO_PrPSP = -1;
 int CMO_SecPSP = -1;
 unsigned long CMO_PageSize = (ASM_CONST(1) << IOMMU_PAGE_SHIFT_4K);
@@ -758,6 +761,10 @@ static void __init pSeries_setup_arch(void)
 
 	if (firmware_has_feature(FW_FEATURE_LPAR)) {
 		vpa_init(boot_cpuid);
+
+		if (lppaca_shared_proc(get_lppaca()))
+			static_branch_enable(&shared_processor);
+
 		ppc_md.power_save = pseries_lpar_idle;
 		ppc_md.enable_pmcs = pseries_lpar_enable_pmcs;
 #ifdef CONFIG_PCI_IOV

commit 1211ee61b4a8e60d6dc77211cdcf01906915bfba
Author: Laurent Dufour <ldufour@linux.ibm.com>
Date:   Fri Sep 20 15:05:22 2019 +0200

    powerpc/pseries: Read TLB Block Invalidate Characteristics
    
    The PAPR document specifies the TLB Block Invalidate Characteristics
    which tells for each pair of segment base page size, actual page size,
    the size of the block the hcall H_BLOCK_REMOVE supports.
    
    These characteristics are loaded at boot time in a new table
    hblkr_size. The table is separate from the mmu_psize_def because this
    is specific to the pseries platform.
    
    A new init function, pseries_lpar_read_hblkrm_characteristics() is
    added to read the characteristics. It is called from
    pSeries_setup_arch().
    
    Fixes: ba2dd8a26baa ("powerpc/pseries/mm: call H_BLOCK_REMOVE")
    Signed-off-by: Laurent Dufour <ldufour@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20190920130523.20441-2-ldufour@linux.ibm.com

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f8adcd0e4589..0a40201f315f 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -744,6 +744,7 @@ static void __init pSeries_setup_arch(void)
 
 	pseries_setup_rfi_flush();
 	setup_stf_barrier();
+	pseries_lpar_read_hblkrm_characteristics();
 
 	/* By default, only probe PCI (can be overridden by rtas_pci) */
 	pci_add_flags(PCI_PROBE_ONLY);

commit 92c94dfb69e350471473fd3075c74bc68150879e
Author: Nathan Lynch <nathanl@linux.ibm.com>
Date:   Tue Sep 10 17:52:44 2019 -0500

    powerpc/pseries: correctly track irq state in default idle
    
    prep_irq_for_idle() is intended to be called before entering
    H_CEDE (and it is used by the pseries cpuidle driver). However the
    default pseries idle routine does not call it, leading to mismanaged
    lazy irq state when the cpuidle driver isn't in use. Manifestations of
    this include:
    
    * Dropped IPIs in the time immediately after a cpu comes
      online (before it has installed the cpuidle handler), making the
      online operation block indefinitely waiting for the new cpu to
      respond.
    
    * Hitting this WARN_ON in arch_local_irq_restore():
            /*
             * We should already be hard disabled here. We had bugs
             * where that wasn't the case so let's dbl check it and
             * warn if we are wrong. Only do that when IRQ tracing
             * is enabled as mfmsr() can be costly.
             */
            if (WARN_ON_ONCE(mfmsr() & MSR_EE))
                    __hard_irq_disable();
    
    Call prep_irq_for_idle() from pseries_lpar_idle() and honor its
    result.
    
    Fixes: 363edbe2614a ("powerpc: Default arch idle could cede processor on pseries")
    Signed-off-by: Nathan Lynch <nathanl@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20190910225244.25056-1-nathanl@linux.ibm.com

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b955d54628ff..f8adcd0e4589 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -321,6 +321,9 @@ static void pseries_lpar_idle(void)
 	 * low power mode by ceding processor to hypervisor
 	 */
 
+	if (!prep_irq_for_idle())
+		return;
+
 	/* Indicate to hypervisor that we are idle. */
 	get_lppaca()->idle = 1;
 

commit 7290f3b3d3e66b54720f23079ffc60e0b7bbb0cc
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Fri Aug 2 20:56:33 2019 +1000

    powerpc/64s/powernv: machine check dump SLB contents
    
    Re-use the code introduced in pseries to save and dump the contents
    of the SLB in the case of an SLB involved machine check exception.
    
    This patch also avoids allocating the SLB save array on pseries radix.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20190802105709.27696-9-npiggin@gmail.com

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index d8930c3a8a11..b955d54628ff 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -142,17 +142,19 @@ static void __init fwnmi_init(void)
 	}
 
 #ifdef CONFIG_PPC_BOOK3S_64
-	/* Allocate per cpu slb area to save old slb contents during MCE */
-	size = sizeof(struct slb_entry) * mmu_slb_size * nr_cpus;
-	slb_ptr = memblock_alloc_try_nid_raw(size, sizeof(struct slb_entry),
-					MEMBLOCK_LOW_LIMIT, ppc64_rma_size,
-					NUMA_NO_NODE);
-	if (!slb_ptr)
-		panic("Failed to allocate %zu bytes below %pa for slb area\n",
-		      size, &ppc64_rma_size);
-
-	for_each_possible_cpu(i)
-		paca_ptrs[i]->mce_faulty_slbs = slb_ptr + (mmu_slb_size * i);
+	if (!radix_enabled()) {
+		/* Allocate per cpu area to save old slb contents during MCE */
+		size = sizeof(struct slb_entry) * mmu_slb_size * nr_cpus;
+		slb_ptr = memblock_alloc_try_nid_raw(size,
+				sizeof(struct slb_entry), MEMBLOCK_LOW_LIMIT,
+				ppc64_rma_size, NUMA_NO_NODE);
+		if (!slb_ptr)
+			panic("Failed to allocate %zu bytes below %pa for slb area\n",
+			      size, &ppc64_rma_size);
+
+		for_each_possible_cpu(i)
+			paca_ptrs[i]->mce_faulty_slbs = slb_ptr + (mmu_slb_size * i);
+	}
 #endif
 }
 

commit d5394c059da9786043934bed474562cde124e7d3
Author: Anshuman Khandual <khandual@linux.vnet.ibm.com>
Date:   Mon Aug 19 23:13:19 2019 -0300

    powerpc/pseries/svm: Use shared memory for Debug Trace Log (DTL)
    
    Secure guests need to share the DTL buffers with the hypervisor. To that
    end, use a kmem_cache constructor which converts the underlying buddy
    allocated SLUB cache pages into shared memory.
    
    Signed-off-by: Anshuman Khandual <khandual@linux.vnet.ibm.com>
    Signed-off-by: Thiago Jung Bauermann <bauerman@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20190820021326.6884-10-bauerman@linux.ibm.com

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f5940cc71c37..d8930c3a8a11 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -69,6 +69,7 @@
 #include <asm/security_features.h>
 #include <asm/asm-const.h>
 #include <asm/swiotlb.h>
+#include <asm/svm.h>
 
 #include "pseries.h"
 #include "../../../../drivers/pci/pci.h"
@@ -297,8 +298,10 @@ static inline int alloc_dispatch_logs(void)
 
 static int alloc_dispatch_log_kmem_cache(void)
 {
+	void (*ctor)(void *) = get_dtl_cache_ctor();
+
 	dtl_cache = kmem_cache_create("dtl", DISPATCH_LOG_BYTES,
-						DISPATCH_LOG_BYTES, 0, NULL);
+						DISPATCH_LOG_BYTES, 0, ctor);
 	if (!dtl_cache) {
 		pr_warn("Failed to create dispatch trace log buffer cache\n");
 		pr_warn("Stolen time statistics will be unreliable\n");

commit 192f0f8e9db7efe4ac98d47f5fa4334e43c1204d
Merge: ec9249752465 f5a9e488d623
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 13 16:08:36 2019 -0700

    Merge tag 'powerpc-5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc updates from Michael Ellerman:
     "Notable changes:
    
       - Removal of the NPU DMA code, used by the out-of-tree Nvidia driver,
         as well as some other functions only used by drivers that haven't
         (yet?) made it upstream.
    
       - A fix for a bug in our handling of hardware watchpoints (eg. perf
         record -e mem: ...) which could lead to register corruption and
         kernel crashes.
    
       - Enable HAVE_ARCH_HUGE_VMAP, which allows us to use large pages for
         vmalloc when using the Radix MMU.
    
       - A large but incremental rewrite of our exception handling code to
         use gas macros rather than multiple levels of nested CPP macros.
    
      And the usual small fixes, cleanups and improvements.
    
      Thanks to: Alastair D'Silva, Alexey Kardashevskiy, Andreas Schwab,
      Aneesh Kumar K.V, Anju T Sudhakar, Anton Blanchard, Arnd Bergmann,
      Athira Rajeev, CÃ©dric Le Goater, Christian Lamparter, Christophe
      Leroy, Christophe Lombard, Christoph Hellwig, Daniel Axtens, Denis
      Efremov, Enrico Weigelt, Frederic Barrat, Gautham R. Shenoy, Geert
      Uytterhoeven, Geliang Tang, Gen Zhang, Greg Kroah-Hartman, Greg Kurz,
      Gustavo Romero, Krzysztof Kozlowski, Madhavan Srinivasan, Masahiro
      Yamada, Mathieu Malaterre, Michael Neuling, Nathan Lynch, Naveen N.
      Rao, Nicholas Piggin, Nishad Kamdar, Oliver O'Halloran, Qian Cai, Ravi
      Bangoria, Sachin Sant, Sam Bobroff, Satheesh Rajendran, Segher
      Boessenkool, Shaokun Zhang, Shawn Anastasio, Stewart Smith, Suraj
      Jitindar Singh, Thiago Jung Bauermann, YueHaibing"
    
    * tag 'powerpc-5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (163 commits)
      powerpc/powernv/idle: Fix restore of SPRN_LDBAR for POWER9 stop state.
      powerpc/eeh: Handle hugepages in ioremap space
      ocxl: Update for AFU descriptor template version 1.1
      powerpc/boot: pass CONFIG options in a simpler and more robust way
      powerpc/boot: add {get, put}_unaligned_be32 to xz_config.h
      powerpc/irq: Don't WARN continuously in arch_local_irq_restore()
      powerpc/module64: Use symbolic instructions names.
      powerpc/module32: Use symbolic instructions names.
      powerpc: Move PPC_HA() PPC_HI() and PPC_LO() to ppc-opcode.h
      powerpc/module64: Fix comment in R_PPC64_ENTRY handling
      powerpc/boot: Add lzo support for uImage
      powerpc/boot: Add lzma support for uImage
      powerpc/boot: don't force gzipped uImage
      powerpc/8xx: Add microcode patch to move SMC parameter RAM.
      powerpc/8xx: Use IO accessors in microcode programming.
      powerpc/8xx: replace #ifdefs by IS_ENABLED() in microcode.c
      powerpc/8xx: refactor programming of microcode CPM params.
      powerpc/8xx: refactor printing of microcode patch name.
      powerpc/8xx: Refactor microcode write
      powerpc/8xx: refactor writing of CPM microcode arrays
      ...

commit 18a593c8b5426f6a08bcb353636d761a83f78d9e
Author: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
Date:   Wed Jul 3 22:34:01 2019 +0530

    powerpc/pseries: Protect against hogging the cpu while setting up the stats
    
    When enabling or disabling the vcpu dispatch statistics, we do a lot of
    work including allocating/deallocating memory across all possible cpus
    for the DTL buffer. In order to guard against hogging the cpu for too
    long, track the time we're taking and yield the processor if necessary.
    
    Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 9d106494cc2d..cb418d2bb1ac 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -285,7 +285,7 @@ static int alloc_dispatch_logs(void)
 	if (!dtl_cache)
 		return 0;
 
-	alloc_dtl_buffers();
+	alloc_dtl_buffers(0);
 
 	/* Register the DTL for the current (boot) cpu */
 	register_dtl_buffer(smp_processor_id());

commit 1c85a2a1945cbafcd2e7cebc6e23d0e206aeda3d
Author: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
Date:   Wed Jul 3 22:33:56 2019 +0530

    powerpc/pseries: Factor out DTL buffer allocation and registration routines
    
    Introduce new helpers for DTL buffer allocation and registration and
    have the existing code use those.
    
    Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    [mpe: Don't split error messages across lines, for grepability]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e2cb29e96fa4..9d106494cc2d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -279,46 +279,16 @@ struct kmem_cache *dtl_cache;
  */
 static int alloc_dispatch_logs(void)
 {
-	int cpu, ret;
-	struct paca_struct *pp;
-	struct dtl_entry *dtl;
-
 	if (!firmware_has_feature(FW_FEATURE_SPLPAR))
 		return 0;
 
 	if (!dtl_cache)
 		return 0;
 
-	for_each_possible_cpu(cpu) {
-		pp = paca_ptrs[cpu];
-		dtl = kmem_cache_alloc(dtl_cache, GFP_KERNEL);
-		if (!dtl) {
-			pr_warn("Failed to allocate dispatch trace log for cpu %d\n",
-				cpu);
-			pr_warn("Stolen time statistics will be unreliable\n");
-			break;
-		}
-
-		pp->dtl_ridx = 0;
-		pp->dispatch_log = dtl;
-		pp->dispatch_log_end = dtl + N_DISPATCH_LOG;
-		pp->dtl_curr = dtl;
-	}
+	alloc_dtl_buffers();
 
 	/* Register the DTL for the current (boot) cpu */
-	dtl = get_paca()->dispatch_log;
-	get_paca()->dtl_ridx = 0;
-	get_paca()->dtl_curr = dtl;
-	get_paca()->lppaca_ptr->dtl_idx = 0;
-
-	/* hypervisor reads buffer length from this field */
-	dtl->enqueue_to_dispatch_time = cpu_to_be32(DISPATCH_LOG_BYTES);
-	ret = register_dtl(hard_smp_processor_id(), __pa(dtl));
-	if (ret)
-		pr_err("WARNING: DTL registration of cpu %d (hw %d) failed "
-		       "with %d\n", smp_processor_id(),
-		       hard_smp_processor_id(), ret);
-	get_paca()->lppaca_ptr->dtl_enable_mask = DTL_LOG_PREEMPT;
+	register_dtl_buffer(smp_processor_id());
 
 	return 0;
 }

commit 515bbc8ab488e4bc16fe26df097502c04d3649d4
Author: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
Date:   Wed Jul 3 22:33:54 2019 +0530

    powerpc/pseries: Use macros for referring to the DTL enable mask
    
    Introduce macros to encode the DTL enable mask fields and use those
    instead of hardcoding numbers.
    
    Acked-by: Nathan Lynch <nathanl@linux.ibm.com>
    Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 30d72b587ac5..e2cb29e96fa4 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -318,7 +318,7 @@ static int alloc_dispatch_logs(void)
 		pr_err("WARNING: DTL registration of cpu %d (hw %d) failed "
 		       "with %d\n", smp_processor_id(),
 		       hard_smp_processor_id(), ret);
-	get_paca()->lppaca_ptr->dtl_enable_mask = 2;
+	get_paca()->lppaca_ptr->dtl_enable_mask = DTL_LOG_PREEMPT;
 
 	return 0;
 }

commit 1a047cc7e53cb10e4706c09f6e92b2fa911a2bf2
Author: Alexey Kardashevskiy <aik@ozlabs.ru>
Date:   Tue May 7 16:25:59 2019 +1000

    powerpc/pseries/dma: Enable SWIOTLB
    
    So far the pseries platforms has always been using IOMMU making
    SWIOTLB unnecessary. Now we want secure guests which means devices can
    only access certain areas of guest physical memory; we are going to
    use SWIOTLB for this purpose.
    
    This allows SWIOTLB for pseries. By default there is no change in
    behavior.
    
    This enables SWIOTLB when the "swiotlb" kernel parameter is set to
    "force".
    
    With the SWIOTLB enabled, the kernel creates a directly mapped DMA
    window (using the usual DDW mechanism) and implements SWIOTLB on top
    of that.
    
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e4f0dfd4ae33..30d72b587ac5 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -42,6 +42,7 @@
 #include <linux/of.h>
 #include <linux/of_pci.h>
 #include <linux/memblock.h>
+#include <linux/swiotlb.h>
 
 #include <asm/mmu.h>
 #include <asm/processor.h>
@@ -71,6 +72,7 @@
 #include <asm/isa-bridge.h>
 #include <asm/security_features.h>
 #include <asm/asm-const.h>
+#include <asm/swiotlb.h>
 
 #include "pseries.h"
 #include "../../../../drivers/pci/pci.h"
@@ -797,6 +799,9 @@ static void __init pSeries_setup_arch(void)
 	}
 
 	ppc_md.pcibios_root_bridge_prepare = pseries_root_bridge_prepare;
+
+	if (swiotlb_force == SWIOTLB_FORCE)
+		ppc_swiotlb_enable = 1;
 }
 
 static void pseries_panic(char *str)

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e4f0dfd4ae33..8fa012a65a71 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  64-bit pSeries and RS/6000 setup code.
  *
@@ -5,11 +6,6 @@
  *  Adapted from 'alpha' version by Gary Thomas
  *  Modified by Cort Dougan (cort@cs.nmt.edu)
  *  Modified by PPC64 Team, IBM Corp
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 /*

commit f806714f7048715cc18f16ebe26a761e09b2f210
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Thu Mar 7 16:30:48 2019 -0800

    powerpc: prefer memblock APIs returning virtual address
    
    Patch series "memblock: simplify several early memory allocation", v4.
    
    These patches simplify some of the early memory allocations by replacing
    usage of older memblock APIs with newer and shinier ones.
    
    Quite a few places in the arch/ code allocated memory using a memblock
    API that returns a physical address of the allocated area, then
    converted this physical address to a virtual one and then used memset(0)
    to clear the allocated range.
    
    More recent memblock APIs do all the three steps in one call and their
    usage simplifies the code.
    
    It's important to note that regardless of API used, the core allocation
    is nearly identical for any set of memblock allocators: first it tries
    to find a free memory with all the constraints specified by the caller
    and then falls back to the allocation with some or all constraints
    disabled.
    
    The first three patches perform the conversion of call sites that have
    exact requirements for the node and the possible memory range.
    
    The fourth patch is a bit one-off as it simplifies openrisc's
    implementation of pte_alloc_one_kernel(), and not only the memblock
    usage.
    
    The fifth patch takes care of simpler cases when the allocation can be
    satisfied with a simple call to memblock_alloc().
    
    The sixth patch removes one-liner wrappers for memblock_alloc on arm and
    unicore32, as suggested by Christoph.
    
    This patch (of 6):
    
    There are a several places that allocate memory using memblock APIs that
    return a physical address, convert the returned address to the virtual
    address and frequently also memset(0) the allocated range.
    
    Update these places to use memblock allocators already returning a
    virtual address.  Use memblock functions that clear the allocated memory
    instead of calling memset(0) where appropriate.
    
    The calls to memblock_alloc_base() that were not followed by memset(0)
    are replaced with memblock_alloc_try_nid_raw().  Since the latter does
    not panic() when the allocation fails, the appropriate panic() calls are
    added to the call sites.
    
    Link: http://lkml.kernel.org/r/1546248566-14910-2-git-send-email-rppt@linux.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Christoph Hellwig <hch@infradead.org>
    Cc: Michal Simek <michal.simek@xilinx.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 41f62ca27c63..e4f0dfd4ae33 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -130,8 +130,13 @@ static void __init fwnmi_init(void)
 	 * It will be used in real mode mce handler, hence it needs to be
 	 * below RMA.
 	 */
-	mce_data_buf = __va(memblock_alloc_base(RTAS_ERROR_LOG_MAX * nr_cpus,
-					RTAS_ERROR_LOG_MAX, ppc64_rma_size));
+	mce_data_buf = memblock_alloc_try_nid_raw(RTAS_ERROR_LOG_MAX * nr_cpus,
+					RTAS_ERROR_LOG_MAX, MEMBLOCK_LOW_LIMIT,
+					ppc64_rma_size, NUMA_NO_NODE);
+	if (!mce_data_buf)
+		panic("Failed to allocate %d bytes below %pa for MCE buffer\n",
+		      RTAS_ERROR_LOG_MAX * nr_cpus, &ppc64_rma_size);
+
 	for_each_possible_cpu(i) {
 		paca_ptrs[i]->mce_data_buf = mce_data_buf +
 						(RTAS_ERROR_LOG_MAX * i);
@@ -140,8 +145,13 @@ static void __init fwnmi_init(void)
 #ifdef CONFIG_PPC_BOOK3S_64
 	/* Allocate per cpu slb area to save old slb contents during MCE */
 	size = sizeof(struct slb_entry) * mmu_slb_size * nr_cpus;
-	slb_ptr = __va(memblock_alloc_base(size, sizeof(struct slb_entry),
-					   ppc64_rma_size));
+	slb_ptr = memblock_alloc_try_nid_raw(size, sizeof(struct slb_entry),
+					MEMBLOCK_LOW_LIMIT, ppc64_rma_size,
+					NUMA_NO_NODE);
+	if (!slb_ptr)
+		panic("Failed to allocate %zu bytes below %pa for slb area\n",
+		      size, &ppc64_rma_size);
+
 	for_each_possible_cpu(i)
 		paca_ptrs[i]->mce_faulty_slbs = slb_ptr + (mmu_slb_size * i);
 #endif

commit 2c8e65b595cf0bf7c1413404dff9b928a64d27cb
Author: Rob Herring <robh@kernel.org>
Date:   Wed Dec 5 13:50:18 2018 -0600

    powerpc: Use of_node_name_eq for node name comparisons
    
    Convert string compares of DT node names to use of_node_name_eq helper
    instead. This removes direct access to the node name pointer.
    
    A couple of open coded iterating thru the child node names are converted
    to use for_each_child_of_node() instead.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 4078a05fa5c0..41f62ca27c63 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -190,7 +190,7 @@ static void __init pseries_setup_i8259_cascade(void)
 		of_node_put(old);
 		if (np == NULL)
 			break;
-		if (strcmp(np->name, "pci") != 0)
+		if (!of_node_name_eq(np, "pci"))
 			continue;
 		addrp = of_get_property(np, "8259-interrupt-acknowledge", NULL);
 		if (addrp == NULL)

commit e5480bdcc4429e4c172d450ee1db1934d84482ef
Author: Rob Herring <robh@kernel.org>
Date:   Fri Nov 16 16:11:00 2018 -0600

    powerpc: Use device_type helpers to access the node type
    
    Remove directly accessing device_node.type pointer and use the
    accessors instead. This will eventually allow removing the type
    pointer.
    
    Replace the open coded iterating over child nodes with
    for_each_child_of_node() while we're here.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 0f553dcfa548..4078a05fa5c0 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -469,8 +469,8 @@ static void __init find_and_init_phbs(void)
 	struct device_node *root = of_find_node_by_path("/");
 
 	for_each_child_of_node(root, node) {
-		if (node->type == NULL || (strcmp(node->type, "pci") != 0 &&
-					   strcmp(node->type, "pciex") != 0))
+		if (!of_node_is_type(node, "pci") &&
+		    !of_node_is_type(node, "pciex"))
 			continue;
 
 		phb = pcibios_alloc_controller(node);
@@ -978,11 +978,7 @@ static void pseries_power_off(void)
 
 static int __init pSeries_probe(void)
 {
-	const char *dtype = of_get_property(of_root, "device_type", NULL);
-
- 	if (dtype == NULL)
- 		return 0;
- 	if (strcmp(dtype, "chrp"))
+	if (!of_node_is_type(of_root, "chrp"))
 		return 0;
 
 	/* Cell blades firmware claims to be chrp while it's not. Until this

commit c6d15258cdf1c197cad7b11b9848e79068dd21e0
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Tue Sep 11 19:57:15 2018 +0530

    powerpc/pseries: Dump the SLB contents on SLB MCE errors.
    
    If we get a machine check exceptions due to SLB errors then dump the
    current SLB contents which will be very much helpful in debugging the
    root cause of SLB errors. Introduce an exclusive buffer per cpu to hold
    faulty SLB entries. In real mode mce handler saves the old SLB contents
    into this buffer accessible through paca and print it out later in virtual
    mode.
    
    With this patch the console will log SLB contents like below on SLB MCE
    errors:
    
    [  507.297236] SLB contents of cpu 0x1
    [  507.297237] Last SLB entry inserted at slot 16
    [  507.297238] 00 c000000008000000 400ea1b217000500
    [  507.297239]   1T  ESID=   c00000  VSID=      ea1b217 LLP:100
    [  507.297240] 01 d000000008000000 400d43642f000510
    [  507.297242]   1T  ESID=   d00000  VSID=      d43642f LLP:110
    [  507.297243] 11 f000000008000000 400a86c85f000500
    [  507.297244]   1T  ESID=   f00000  VSID=      a86c85f LLP:100
    [  507.297245] 12 00007f0008000000 4008119624000d90
    [  507.297246]   1T  ESID=       7f  VSID=      8119624 LLP:110
    [  507.297247] 13 0000000018000000 00092885f5150d90
    [  507.297247]  256M ESID=        1  VSID=   92885f5150 LLP:110
    [  507.297248] 14 0000010008000000 4009e7cb50000d90
    [  507.297249]   1T  ESID=        1  VSID=      9e7cb50 LLP:110
    [  507.297250] 15 d000000008000000 400d43642f000510
    [  507.297251]   1T  ESID=   d00000  VSID=      d43642f LLP:110
    [  507.297252] 16 d000000008000000 400d43642f000510
    [  507.297253]   1T  ESID=   d00000  VSID=      d43642f LLP:110
    [  507.297253] ----------------------------------
    [  507.297254] SLB cache ptr value = 3
    [  507.297254] Valid SLB cache entries:
    [  507.297255] 00 EA[0-35]=    7f000
    [  507.297256] 01 EA[0-35]=        1
    [  507.297257] 02 EA[0-35]=     1000
    [  507.297257] Rest of SLB cache entries:
    [  507.297258] 03 EA[0-35]=    7f000
    [  507.297258] 04 EA[0-35]=        1
    [  507.297259] 05 EA[0-35]=     1000
    [  507.297260] 06 EA[0-35]=       12
    [  507.297260] 07 EA[0-35]=    7f000
    
    Suggested-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Suggested-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Reviewed-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e03f62a78649..0f553dcfa548 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -107,6 +107,10 @@ static void __init fwnmi_init(void)
 	u8 *mce_data_buf;
 	unsigned int i;
 	int nr_cpus = num_possible_cpus();
+#ifdef CONFIG_PPC_BOOK3S_64
+	struct slb_entry *slb_ptr;
+	size_t size;
+#endif
 
 	int ibm_nmi_register = rtas_token("ibm,nmi-register");
 	if (ibm_nmi_register == RTAS_UNKNOWN_SERVICE)
@@ -132,6 +136,15 @@ static void __init fwnmi_init(void)
 		paca_ptrs[i]->mce_data_buf = mce_data_buf +
 						(RTAS_ERROR_LOG_MAX * i);
 	}
+
+#ifdef CONFIG_PPC_BOOK3S_64
+	/* Allocate per cpu slb area to save old slb contents during MCE */
+	size = sizeof(struct slb_entry) * mmu_slb_size * nr_cpus;
+	slb_ptr = __va(memblock_alloc_base(size, sizeof(struct slb_entry),
+					   ppc64_rma_size));
+	for_each_possible_cpu(i)
+		paca_ptrs[i]->mce_faulty_slbs = slb_ptr + (mmu_slb_size * i);
+#endif
 }
 
 static void pseries_8259_cascade(struct irq_desc *desc)

commit a43c1590426c44a5c6bbaf51b70a36a5c6d86914
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Tue Sep 11 19:57:00 2018 +0530

    powerpc/pseries: Flush SLB contents on SLB MCE errors.
    
    On pseries, as of today system crashes if we get a machine check
    exceptions due to SLB errors. These are soft errors and can be fixed
    by flushing the SLBs so the kernel can continue to function instead of
    system crash. We do this in real mode before turning on MMU. Otherwise
    we would run into nested machine checks. This patch now fetches the
    rtas error log in real mode and flushes the SLBs on SLB/ERAT errors.
    
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Michal Suchanek <msuchanek@suse.com>
    Reviewed-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index ba1791fd3234..e03f62a78649 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -1017,6 +1017,7 @@ define_machine(pseries) {
 	.calibrate_decr		= generic_calibrate_decr,
 	.progress		= rtas_progress,
 	.system_reset_exception = pSeries_system_reset_exception,
+	.machine_check_early	= pseries_machine_check_realmode,
 	.machine_check_exception = pSeries_machine_check_exception,
 #ifdef CONFIG_KEXEC_CORE
 	.machine_kexec          = pSeries_machine_kexec,

commit 5e2d059b52e397d9ac42f4c4d9d9a841887b5818
Merge: d190775206d0 a2dc009afa9a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Aug 17 11:32:50 2018 -0700

    Merge tag 'powerpc-4.19-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc updates from Michael Ellerman:
     "Notable changes:
    
       - A fix for a bug in our page table fragment allocator, where a page
         table page could be freed and reallocated for something else while
         still in use, leading to memory corruption etc. The fix reuses
         pt_mm in struct page (x86 only) for a powerpc only refcount.
    
       - Fixes to our pkey support. Several are user-visible changes, but
         bring us in to line with x86 behaviour and/or fix outright bugs.
         Thanks to Florian Weimer for reporting many of these.
    
       - A series to improve the hvc driver & related OPAL console code,
         which have been seen to cause hardlockups at times. The hvc driver
         changes in particular have been in linux-next for ~month.
    
       - Increase our MAX_PHYSMEM_BITS to 128TB when SPARSEMEM_VMEMMAP=y.
    
       - Remove Power8 DD1 and Power9 DD1 support, neither chip should be in
         use anywhere other than as a paper weight.
    
       - An optimised memcmp implementation using Power7-or-later VMX
         instructions
    
       - Support for barrier_nospec on some NXP CPUs.
    
       - Support for flushing the count cache on context switch on some IBM
         CPUs (controlled by firmware), as a Spectre v2 mitigation.
    
       - A series to enhance the information we print on unhandled signals
         to bring it into line with other arches, including showing the
         offending VMA and dumping the instructions around the fault.
    
      Thanks to: Aaro Koskinen, Akshay Adiga, Alastair D'Silva, Alexey
      Kardashevskiy, Alexey Spirkov, Alistair Popple, Andrew Donnellan,
      Aneesh Kumar K.V, Anju T Sudhakar, Arnd Bergmann, Bartosz Golaszewski,
      Benjamin Herrenschmidt, Bharat Bhushan, Bjoern Noetel, Boqun Feng,
      Breno Leitao, Bryant G. Ly, Camelia Groza, Christophe Leroy, Christoph
      Hellwig, Cyril Bur, Dan Carpenter, Daniel Klamt, Darren Stevens, Dave
      Young, David Gibson, Diana Craciun, Finn Thain, Florian Weimer,
      Frederic Barrat, Gautham R. Shenoy, Geert Uytterhoeven, Geoff Levand,
      Guenter Roeck, Gustavo Romero, Haren Myneni, Hari Bathini, Joel
      Stanley, Jonathan NeuschÃ¤fer, Kees Cook, Madhavan Srinivasan, Mahesh
      Salgaonkar, Markus Elfring, Mathieu Malaterre, Mauro S. M. Rodrigues,
      Michael Hanselmann, Michael Neuling, Michael Schmitz, Mukesh Ojha,
      Murilo Opsfelder Araujo, Nicholas Piggin, Parth Y Shah, Paul
      Mackerras, Paul Menzel, Ram Pai, Randy Dunlap, Rashmica Gupta, Reza
      Arbab, Rodrigo R. Galvao, Russell Currey, Sam Bobroff, Scott Wood,
      Shilpasri G Bhat, Simon Guo, Souptick Joarder, Stan Johnson, Thiago
      Jung Bauermann, Tyrel Datwyler, Vaibhav Jain, Vasant Hegde, Venkat
      Rao, zhong jiang"
    
    * tag 'powerpc-4.19-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (234 commits)
      powerpc/mm/book3s/radix: Add mapping statistics
      powerpc/uaccess: Enable get_user(u64, *p) on 32-bit
      powerpc/mm/hash: Remove unnecessary do { } while(0) loop
      powerpc/64s: move machine check SLB flushing to mm/slb.c
      powerpc/powernv/idle: Fix build error
      powerpc/mm/tlbflush: update the mmu_gather page size while iterating address range
      powerpc/mm: remove warning about âtypeâ being set
      powerpc/32: Include setup.h header file to fix warnings
      powerpc: Move `path` variable inside DEBUG_PROM
      powerpc/powermac: Make some functions static
      powerpc/powermac: Remove variable x that's never read
      cxl: remove a dead branch
      powerpc/powermac: Add missing include of header pmac.h
      powerpc/kexec: Use common error handling code in setup_new_fdt()
      powerpc/xmon: Add address lookup for percpu symbols
      powerpc/mm: remove huge_pte_offset_and_shift() prototype
      powerpc/lib: Use patch_site to patch copy_32 functions once cache is enabled
      powerpc/pseries: Fix endianness while restoring of r3 in MCE handler.
      powerpc/fadump: merge adjacent memory ranges to reduce PT_LOAD segements
      powerpc/fadump: handle crash memory ranges array index overflow
      ...

commit ba72dc171954b782a79d25e0f4b3ed91090c3b1e
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Jul 24 01:07:55 2018 +1000

    powerpc/pseries: Query hypervisor for count cache flush settings
    
    Use the existing hypercall to determine the appropriate settings for
    the count cache flush, and then call the generic powerpc code to set
    it up based on the security feature flags.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 08f0c5de5b09..395cfe320141 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -501,6 +501,12 @@ static void init_cpu_char_feature_flags(struct h_cpu_char_result *result)
 	if (result->character & H_CPU_CHAR_COUNT_CACHE_DISABLED)
 		security_ftr_set(SEC_FTR_COUNT_CACHE_DISABLED);
 
+	if (result->character & H_CPU_CHAR_BCCTR_FLUSH_ASSIST)
+		security_ftr_set(SEC_FTR_BCCTR_FLUSH_ASSIST);
+
+	if (result->behaviour & H_CPU_BEHAV_FLUSH_COUNT_CACHE)
+		security_ftr_set(SEC_FTR_FLUSH_COUNT_CACHE);
+
 	/*
 	 * The features below are enabled by default, so we instead look to see
 	 * if firmware has *disabled* them, and clear them if so.
@@ -551,6 +557,7 @@ void pseries_setup_rfi_flush(void)
 		 security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR);
 
 	setup_rfi_flush(types, enable);
+	setup_count_cache_flush();
 }
 
 #ifdef CONFIG_PCI_IOV

commit af375eefbfb27cbb5b831984e66d724a40d26b5c
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Sat Jul 28 09:06:35 2018 +1000

    powerpc/64: Call setup_barrier_nospec() from setup_arch()
    
    Currently we require platform code to call setup_barrier_nospec(). But
    if we add an empty definition for the !CONFIG_PPC_BARRIER_NOSPEC case
    then we can call it in setup_arch().
    
    Signed-off-by: Diana Craciun <diana.craciun@nxp.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b411a74b861d..08f0c5de5b09 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -551,7 +551,6 @@ void pseries_setup_rfi_flush(void)
 		 security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR);
 
 	setup_rfi_flush(types, enable);
-	setup_barrier_nospec();
 }
 
 #ifdef CONFIG_PCI_IOV

commit 94675cceacaec27a30eefb142c4c59a9d3131742
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Wed Jul 4 23:27:21 2018 +0530

    powerpc/pseries: Defer the logging of rtas error to irq work queue.
    
    rtas_log_buf is a buffer to hold RTAS event data that are communicated
    to kernel by hypervisor. This buffer is then used to pass RTAS event
    data to user through proc fs. This buffer is allocated from
    vmalloc (non-linear mapping) area.
    
    On Machine check interrupt, register r3 points to RTAS extended event
    log passed by hypervisor that contains the MCE event. The pseries
    machine check handler then logs this error into rtas_log_buf. The
    rtas_log_buf is a vmalloc-ed (non-linear) buffer we end up taking up a
    page fault (vector 0x300) while accessing it. Since machine check
    interrupt handler runs in NMI context we can not afford to take any
    page fault. Page faults are not honored in NMI context and causes
    kernel panic. Apart from that, as Nick pointed out,
    pSeries_log_error() also takes a spin_lock while logging error which
    is not safe in NMI context. It may endup in deadlock if we get another
    MCE before releasing the lock. Fix this by deferring the logging of
    rtas error to irq work queue.
    
    Current implementation uses two different buffers to hold rtas error
    log depending on whether extended log is provided or not. This makes
    bit difficult to identify which buffer has valid data that needs to
    logged later in irq work. Simplify this using single buffer, one per
    paca, and copy rtas log to it irrespective of whether extended log is
    provided or not. Allocate this buffer below RMA region so that it can
    be accessed in real mode mce handler.
    
    Fixes: b96672dd840f ("powerpc: Machine check interrupt is a non-maskable interrupt")
    Cc: stable@vger.kernel.org # v4.14+
    Reviewed-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 9948ad16f788..b411a74b861d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -41,6 +41,7 @@
 #include <linux/root_dev.h>
 #include <linux/of.h>
 #include <linux/of_pci.h>
+#include <linux/memblock.h>
 
 #include <asm/mmu.h>
 #include <asm/processor.h>
@@ -102,6 +103,9 @@ static void pSeries_show_cpuinfo(struct seq_file *m)
 static void __init fwnmi_init(void)
 {
 	unsigned long system_reset_addr, machine_check_addr;
+	u8 *mce_data_buf;
+	unsigned int i;
+	int nr_cpus = num_possible_cpus();
 
 	int ibm_nmi_register = rtas_token("ibm,nmi-register");
 	if (ibm_nmi_register == RTAS_UNKNOWN_SERVICE)
@@ -115,6 +119,18 @@ static void __init fwnmi_init(void)
 	if (0 == rtas_call(ibm_nmi_register, 2, 1, NULL, system_reset_addr,
 				machine_check_addr))
 		fwnmi_active = 1;
+
+	/*
+	 * Allocate a chunk for per cpu buffer to hold rtas errorlog.
+	 * It will be used in real mode mce handler, hence it needs to be
+	 * below RMA.
+	 */
+	mce_data_buf = __va(memblock_alloc_base(RTAS_ERROR_LOG_MAX * nr_cpus,
+					RTAS_ERROR_LOG_MAX, ppc64_rma_size));
+	for_each_possible_cpu(i) {
+		paca_ptrs[i]->mce_data_buf = mce_data_buf +
+						(RTAS_ERROR_LOG_MAX * i);
+	}
 }
 
 static void pseries_8259_cascade(struct irq_desc *desc)

commit 44bda4b7d26e9fffed6d7152d98a2e9edaeb2a76
Author: Hari Vyas <hari.vyas@broadcom.com>
Date:   Tue Jul 3 14:35:41 2018 +0530

    PCI: Fix is_added/is_busmaster race condition
    
    When a PCI device is detected, pdev->is_added is set to 1 and proc and
    sysfs entries are created.
    
    When the device is removed, pdev->is_added is checked for one and then
    device is detached with clearing of proc and sys entries and at end,
    pdev->is_added is set to 0.
    
    is_added and is_busmaster are bit fields in pci_dev structure sharing same
    memory location.
    
    A strange issue was observed with multiple removal and rescan of a PCIe
    NVMe device using sysfs commands where is_added flag was observed as zero
    instead of one while removing device and proc,sys entries are not cleared.
    This causes issue in later device addition with warning message
    "proc_dir_entry" already registered.
    
    Debugging revealed a race condition between the PCI core setting the
    is_added bit in pci_bus_add_device() and the NVMe driver reset work-queue
    setting the is_busmaster bit in pci_set_master().  As these fields are not
    handled atomically, that clears the is_added bit.
    
    Move the is_added bit to a separate private flag variable and use atomic
    functions to set and retrieve the device addition state.  This avoids the
    race because is_added no longer shares a memory location with is_busmaster.
    
    Link: https://bugzilla.kernel.org/show_bug.cgi?id=200283
    Signed-off-by: Hari Vyas <hari.vyas@broadcom.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Lukas Wunner <lukas@wunner.de>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 139f0af6c3d9..8a4868a3964b 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -71,6 +71,7 @@
 #include <asm/security_features.h>
 
 #include "pseries.h"
+#include "../../../../drivers/pci/pci.h"
 
 int CMO_PrPSP = -1;
 int CMO_SecPSP = -1;
@@ -664,7 +665,7 @@ static void pseries_pci_fixup_iov_resources(struct pci_dev *pdev)
 	const int *indexes;
 	struct device_node *dn = pci_device_to_OF_node(pdev);
 
-	if (!pdev->is_physfn || pdev->is_added)
+	if (!pdev->is_physfn || pci_dev_is_added(pdev))
 		return;
 	/*Firmware must support open sriov otherwise dont configure*/
 	indexes = of_get_property(dn, "ibm,open-sriov-vf-bar-info", NULL);

commit b87b9cf4935325c98522823caeddd333022a1c62
Author: Sam Bobroff <sbobroff@linux.ibm.com>
Date:   Mon Jul 30 11:59:14 2018 +1000

    powerpc/pseries: fix EEH recovery of some IOV devices
    
    EEH recovery currently fails on pSeries for some IOV capable PCI
    devices, if CONFIG_PCI_IOV is on and the hypervisor doesn't provide
    certain device tree properties for the device. (Found on an IOV
    capable device using the ipr driver.)
    
    Recovery fails in pci_enable_resources() at the check on r->parent,
    because r->flags is set and r->parent is not.  This state is due to
    sriov_init() setting the start, end and flags members of the IOV BARs
    but the parent not being set later in
    pseries_pci_fixup_iov_resources(), because the
    "ibm,open-sriov-vf-bar-info" property is missing.
    
    Correct this by zeroing the resource flags for IOV BARs when they
    can't be configured (this is the same method used by sriov_init() and
    __pci_read_base()).
    
    VFs cleared this way can't be enabled later, because that requires
    another device tree property, "ibm,number-of-configurable-vfs" as well
    as support for the RTAS function "ibm_map_pes". These are all part of
    hypervisor support for IOV and it seems unlikely that a hypervisor
    would ever partially, but not fully, support it. (None are currently
    provided by QEMU/KVM.)
    
    Signed-off-by: Sam Bobroff <sbobroff@linux.ibm.com>
    Reviewed-by: Bryant G. Ly <bryantly@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e14ccf32a97d..9948ad16f788 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -647,6 +647,15 @@ void of_pci_parse_iov_addrs(struct pci_dev *dev, const int *indexes)
 	}
 }
 
+static void pseries_disable_sriov_resources(struct pci_dev *pdev)
+{
+	int i;
+
+	pci_warn(pdev, "No hypervisor support for SR-IOV on this device, IOV BARs disabled.\n");
+	for (i = 0; i < PCI_SRIOV_NUM_BARS; i++)
+		pdev->resource[i + PCI_IOV_RESOURCES].flags = 0;
+}
+
 static void pseries_pci_fixup_resources(struct pci_dev *pdev)
 {
 	const int *indexes;
@@ -654,10 +663,10 @@ static void pseries_pci_fixup_resources(struct pci_dev *pdev)
 
 	/*Firmware must support open sriov otherwise dont configure*/
 	indexes = of_get_property(dn, "ibm,open-sriov-vf-bar-info", NULL);
-	if (!indexes)
-		return;
-	/* Assign the addresses from device tree*/
-	of_pci_set_vf_bar_size(pdev, indexes);
+	if (indexes)
+		of_pci_set_vf_bar_size(pdev, indexes);
+	else
+		pseries_disable_sriov_resources(pdev);
 }
 
 static void pseries_pci_fixup_iov_resources(struct pci_dev *pdev)
@@ -669,10 +678,10 @@ static void pseries_pci_fixup_iov_resources(struct pci_dev *pdev)
 		return;
 	/*Firmware must support open sriov otherwise dont configure*/
 	indexes = of_get_property(dn, "ibm,open-sriov-vf-bar-info", NULL);
-	if (!indexes)
-		return;
-	/* Assign the addresses from device tree*/
-	of_pci_parse_iov_addrs(pdev, indexes);
+	if (indexes)
+		of_pci_parse_iov_addrs(pdev, indexes);
+	else
+		pseries_disable_sriov_resources(pdev);
 }
 
 static resource_size_t pseries_pci_iov_resource_alignment(struct pci_dev *pdev,

commit ec0c464cdbf38bf6ddabec8bfa595bd421cab203
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Jul 5 16:24:57 2018 +0000

    powerpc: move ASM_CONST and stringify_in_c() into asm-const.h
    
    This patch moves ASM_CONST() and stringify_in_c() into
    dedicated asm-const.h, then cleans all related inclusions.
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    [mpe: asm-compat.h should include asm-const.h]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 139f0af6c3d9..e14ccf32a97d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -69,6 +69,7 @@
 #include <asm/kexec.h>
 #include <asm/isa-bridge.h>
 #include <asm/security_features.h>
+#include <asm/asm-const.h>
 
 #include "pseries.h"
 

commit c90fca951e90ba470a3dc6087667edffcf8db21b
Merge: c0ab85267e25 ff5bc793e47b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 7 10:23:33 2018 -0700

    Merge tag 'powerpc-4.18-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc updates from Michael Ellerman:
     "Notable changes:
    
       - Support for split PMD page table lock on 64-bit Book3S (Power8/9).
    
       - Add support for HAVE_RELIABLE_STACKTRACE, so we properly support
         live patching again.
    
       - Add support for patching barrier_nospec in copy_from_user() and
         syscall entry.
    
       - A couple of fixes for our data breakpoints on Book3S.
    
       - A series from Nick optimising TLB/mm handling with the Radix MMU.
    
       - Numerous small cleanups to squash sparse/gcc warnings from Mathieu
         Malaterre.
    
       - Several series optimising various parts of the 32-bit code from
         Christophe Leroy.
    
       - Removal of support for two old machines, "SBC834xE" and "C2K"
         ("GEFanuc,C2K"), which is why the diffstat has so many deletions.
    
      And many other small improvements & fixes.
    
      There's a few out-of-area changes. Some minor ftrace changes OK'ed by
      Steve, and a fix to our powernv cpuidle driver. Then there's a series
      touching mm, x86 and fs/proc/task_mmu.c, which cleans up some details
      around pkey support. It was ack'ed/reviewed by Ingo & Dave and has
      been in next for several weeks.
    
      Thanks to: Akshay Adiga, Alastair D'Silva, Alexey Kardashevskiy, Al
      Viro, Andrew Donnellan, Aneesh Kumar K.V, Anju T Sudhakar, Arnd
      Bergmann, Balbir Singh, CÃ©dric Le Goater, Christophe Leroy, Christophe
      Lombard, Colin Ian King, Dave Hansen, Fabio Estevam, Finn Thain,
      Frederic Barrat, Gautham R. Shenoy, Haren Myneni, Hari Bathini, Ingo
      Molnar, Jonathan NeuschÃ¤fer, Josh Poimboeuf, Kamalesh Babulal,
      Madhavan Srinivasan, Mahesh Salgaonkar, Mark Greer, Mathieu Malaterre,
      Matthew Wilcox, Michael Neuling, Michal Suchanek, Naveen N. Rao,
      Nicholas Piggin, Nicolai Stange, Olof Johansson, Paul Gortmaker, Paul
      Mackerras, Peter Rosin, Pridhiviraj Paidipeddi, Ram Pai, Rashmica
      Gupta, Ravi Bangoria, Russell Currey, Sam Bobroff, Samuel
      Mendoza-Jonas, Segher Boessenkool, Shilpasri G Bhat, Simon Guo,
      Souptick Joarder, Stewart Smith, Thiago Jung Bauermann, Torsten Duwe,
      Vaibhav Jain, Wei Yongjun, Wolfram Sang, Yisheng Xie, YueHaibing"
    
    * tag 'powerpc-4.18-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (251 commits)
      powerpc/64s/radix: Fix missing ptesync in flush_cache_vmap
      cpuidle: powernv: Fix promotion from snooze if next state disabled
      powerpc: fix build failure by disabling attribute-alias warning in pci_32
      ocxl: Fix missing unlock on error in afu_ioctl_enable_p9_wait()
      powerpc-opal: fix spelling mistake "Uniterrupted" -> "Uninterrupted"
      powerpc: fix spelling mistake: "Usupported" -> "Unsupported"
      powerpc/pkeys: Detach execute_only key on !PROT_EXEC
      powerpc/powernv: copy/paste - Mask SO bit in CR
      powerpc: Remove core support for Marvell mv64x60 hostbridges
      powerpc/boot: Remove core support for Marvell mv64x60 hostbridges
      powerpc/boot: Remove support for Marvell mv64x60 i2c controller
      powerpc/boot: Remove support for Marvell MPSC serial controller
      powerpc/embedded6xx: Remove C2K board support
      powerpc/lib: optimise PPC32 memcmp
      powerpc/lib: optimise 32 bits __clear_user()
      powerpc/time: inline arch_vtime_task_switch()
      powerpc/Makefile: set -mcpu=860 flag for the 8xx
      powerpc: Implement csum_ipv6_magic in assembly
      powerpc/32: Optimise __csum_partial()
      powerpc/lib: Adjust .balign inside string functions for PPC32
      ...

commit cb3d6759a93c6d0aea1c10deb6d00e111c29c19c
Author: Michal Suchanek <msuchanek@suse.de>
Date:   Tue Apr 24 14:15:57 2018 +1000

    powerpc/64s: Enable barrier_nospec based on firmware settings
    
    Check what firmware told us and enable/disable the barrier_nospec as
    appropriate.
    
    We err on the side of enabling the barrier, as it's no-op on older
    systems, see the comment for more detail.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b55ad4286dc7..63b1f0d10ef0 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -534,6 +534,7 @@ void pseries_setup_rfi_flush(void)
 		 security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR);
 
 	setup_rfi_flush(types, enable);
+	setup_barrier_nospec();
 }
 
 #ifdef CONFIG_PCI_IOV

commit a048a07d7f4535baa4cbad6bc024f175317ab938
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Tue May 22 09:00:00 2018 +1000

    powerpc/64s: Add support for a store forwarding barrier at kernel entry/exit
    
    On some CPUs we can prevent a vulnerability related to store-to-load
    forwarding by preventing store forwarding between privilege domains,
    by inserting a barrier in kernel entry and exit paths.
    
    This is known to be the case on at least Power7, Power8 and Power9
    powerpc CPUs.
    
    Barriers must be inserted generally before the first load after moving
    to a higher privilege, and after the last store before moving to a
    lower privilege, HV and PR privilege transitions must be protected.
    
    Barriers are added as patch sections, with all kernel/hypervisor entry
    points patched, and the exit points to lower privilge levels patched
    similarly to the RFI flush patching.
    
    Firmware advertisement is not implemented yet, so CPU flush types
    are hard coded.
    
    Thanks to Michal SuchÃ¡nek for bug fixes and review.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Michal SuchÃ¡nek <msuchanek@suse.de>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b55ad4286dc7..fdb32e056ef4 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -710,6 +710,7 @@ static void __init pSeries_setup_arch(void)
 	fwnmi_init();
 
 	pseries_setup_rfi_flush();
+	setup_stf_barrier();
 
 	/* By default, only probe PCI (can be overridden by rtas_pci) */
 	pci_add_flags(PCI_PROBE_ONLY);

commit 6232774f1599028a15418179d17f7df47ede770a
Author: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
Date:   Fri Mar 30 14:28:25 2018 -0300

    powerpc/pseries: Restore default security feature flags on setup
    
    After migration the security feature flags might have changed (e.g.,
    destination system with unpatched firmware), but some flags are not
    set/clear again in init_cpu_char_feature_flags() because it assumes
    the security flags to be the defaults.
    
    Additionally, if the H_GET_CPU_CHARACTERISTICS hypercall fails then
    init_cpu_char_feature_flags() does not run again, which potentially
    might leave the system in an insecure or sub-optimal configuration.
    
    So, just restore the security feature flags to the defaults assumed
    by init_cpu_char_feature_flags() so it can set/clear them correctly,
    and to ensure safe settings are in place in case the hypercall fail.
    
    Fixes: f636c14790ea ("powerpc/pseries: Set or clear security feature flags")
    Depends-on: 19887d6a28e2 ("powerpc: Move default security feature flags")
    Signed-off-by: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 98bca8d9c9e0..b55ad4286dc7 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -462,6 +462,10 @@ static void __init find_and_init_phbs(void)
 
 static void init_cpu_char_feature_flags(struct h_cpu_char_result *result)
 {
+	/*
+	 * The features below are disabled by default, so we instead look to see
+	 * if firmware has *enabled* them, and set them if so.
+	 */
 	if (result->character & H_CPU_CHAR_SPEC_BAR_ORI31)
 		security_ftr_set(SEC_FTR_SPEC_BAR_ORI31);
 
@@ -501,6 +505,13 @@ void pseries_setup_rfi_flush(void)
 	bool enable;
 	long rc;
 
+	/*
+	 * Set features to the defaults assumed by init_cpu_char_feature_flags()
+	 * so it can set/clear again any features that might have changed after
+	 * migration, and in case the hypercall fails and it is not even called.
+	 */
+	powerpc_security_features = SEC_FTR_DEFAULT;
+
 	rc = plpar_get_cpu_characteristics(&result);
 	if (rc == H_SUCCESS)
 		init_cpu_char_feature_flags(&result);

commit f437c51748fa1dd423a878c870ad203843a51c8d
Merge: 872a100a49c3 29ab6c4708a5
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Sat Mar 31 00:11:24 2018 +1100

    Merge branch 'topic/paca' into next
    
    Bring in yet another series that touches KVM code, and might need to
    be merged into the kvm-ppc branch to resolve conflicts.
    
    This required some changes in pnv_power9_force_smt4_catch/release()
    due to the paca array becomming an array of pointers.

commit 0f9bdfe3c77091e8704d2e510eb7c2c2c6cde524
Author: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
Date:   Thu Mar 29 15:32:11 2018 -0300

    powerpc/pseries: Fix clearing of security feature flags
    
    The H_CPU_BEHAV_* flags should be checked for in the 'behaviour' field
    of 'struct h_cpu_char_result' -- 'character' is for H_CPU_CHAR_*
    flags.
    
    Found by playing around with QEMU's implementation of the hypercall:
    
      H_CPU_CHAR=0xf000000000000000
      H_CPU_BEHAV=0x0000000000000000
    
      This clears H_CPU_BEHAV_FAVOUR_SECURITY and H_CPU_BEHAV_L1D_FLUSH_PR
      so pseries_setup_rfi_flush() disables 'rfi_flush'; and it also
      clears H_CPU_CHAR_L1D_THREAD_PRIV flag. So there is no RFI flush
      mitigation at all for cpu_show_meltdown() to report; but currently
      it does:
    
      Original kernel:
    
        # cat /sys/devices/system/cpu/vulnerabilities/meltdown
        Mitigation: RFI Flush
    
      Patched kernel:
    
        # cat /sys/devices/system/cpu/vulnerabilities/meltdown
        Not affected
    
      H_CPU_CHAR=0x0000000000000000
      H_CPU_BEHAV=0xf000000000000000
    
      This sets H_CPU_BEHAV_BNDS_CHK_SPEC_BAR so cpu_show_spectre_v1() should
      report vulnerable; but currently it doesn't:
    
      Original kernel:
    
        # cat /sys/devices/system/cpu/vulnerabilities/spectre_v1
        Not affected
    
      Patched kernel:
    
        # cat /sys/devices/system/cpu/vulnerabilities/spectre_v1
        Vulnerable
    
    Brown-paper-bag-by: Michael Ellerman <mpe@ellerman.id.au>
    Fixes: f636c14790ea ("powerpc/pseries: Set or clear security feature flags")
    Signed-off-by: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 1f122359cd8f..b11564f2a4c7 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -484,13 +484,13 @@ static void init_cpu_char_feature_flags(struct h_cpu_char_result *result)
 	 * The features below are enabled by default, so we instead look to see
 	 * if firmware has *disabled* them, and clear them if so.
 	 */
-	if (!(result->character & H_CPU_BEHAV_FAVOUR_SECURITY))
+	if (!(result->behaviour & H_CPU_BEHAV_FAVOUR_SECURITY))
 		security_ftr_clear(SEC_FTR_FAVOUR_SECURITY);
 
-	if (!(result->character & H_CPU_BEHAV_L1D_FLUSH_PR))
+	if (!(result->behaviour & H_CPU_BEHAV_L1D_FLUSH_PR))
 		security_ftr_clear(SEC_FTR_L1D_FLUSH_PR);
 
-	if (!(result->character & H_CPU_BEHAV_BNDS_CHK_SPEC_BAR))
+	if (!(result->behaviour & H_CPU_BEHAV_BNDS_CHK_SPEC_BAR))
 		security_ftr_clear(SEC_FTR_BNDS_CHK_SPEC_BAR);
 }
 

commit d2e60075a3d4422dc54b919f3b125d8066b839d4
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Feb 14 01:08:12 2018 +1000

    powerpc/64: Use array of paca pointers and allocate pacas individually
    
    Change the paca array into an array of pointers to pacas. Allocate
    pacas individually.
    
    This allows flexibility in where the PACAs are allocated. Future work
    will allocate them node-local. Platforms that don't have address limits
    on PACAs would be able to defer PACA allocations until later in boot
    rather than allocate all possible ones up-front then freeing unused.
    
    This is slightly more overhead (one additional indirection) for cross
    CPU paca references, but those aren't too common.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 372d7ada1a0c..a66005a25c55 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -246,7 +246,7 @@ static int alloc_dispatch_logs(void)
 		return 0;
 
 	for_each_possible_cpu(cpu) {
-		pp = &paca[cpu];
+		pp = paca_ptrs[cpu];
 		dtl = kmem_cache_alloc(dtl_cache, GFP_KERNEL);
 		if (!dtl) {
 			pr_warn("Failed to allocate dispatch trace log for cpu %d\n",

commit 2e4a16161fcd324b1f9bf6cb6856529f7eaf0689
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Mar 27 23:01:51 2018 +1100

    powerpc/pseries: Use the security flags in pseries_setup_rfi_flush()
    
    Now that we have the security flags we can simplify the code in
    pseries_setup_rfi_flush() because the security flags have pessimistic
    defaults.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index fb84c1df6ed7..1f122359cd8f 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -501,30 +501,27 @@ void pseries_setup_rfi_flush(void)
 	bool enable;
 	long rc;
 
-	/* Enable by default */
-	enable = true;
-	types = L1D_FLUSH_FALLBACK;
-
 	rc = plpar_get_cpu_characteristics(&result);
-	if (rc == H_SUCCESS) {
+	if (rc == H_SUCCESS)
 		init_cpu_char_feature_flags(&result);
 
-		if (result.character & H_CPU_CHAR_L1D_FLUSH_TRIG2)
-			types |= L1D_FLUSH_MTTRIG;
-		if (result.character & H_CPU_CHAR_L1D_FLUSH_ORI30)
-			types |= L1D_FLUSH_ORI;
-
-		if ((!(result.behaviour & H_CPU_BEHAV_L1D_FLUSH_PR)) ||
-		    (!(result.behaviour & H_CPU_BEHAV_FAVOUR_SECURITY)))
-			enable = false;
-	}
-
 	/*
 	 * We're the guest so this doesn't apply to us, clear it to simplify
 	 * handling of it elsewhere.
 	 */
 	security_ftr_clear(SEC_FTR_L1D_FLUSH_HV);
 
+	types = L1D_FLUSH_FALLBACK;
+
+	if (security_ftr_enabled(SEC_FTR_L1D_FLUSH_TRIG2))
+		types |= L1D_FLUSH_MTTRIG;
+
+	if (security_ftr_enabled(SEC_FTR_L1D_FLUSH_ORI30))
+		types |= L1D_FLUSH_ORI;
+
+	enable = security_ftr_enabled(SEC_FTR_FAVOUR_SECURITY) && \
+		 security_ftr_enabled(SEC_FTR_L1D_FLUSH_PR);
+
 	setup_rfi_flush(types, enable);
 }
 

commit f636c14790ead6cc22cf62279b1f8d7e11a67116
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Mar 27 23:01:46 2018 +1100

    powerpc/pseries: Set or clear security feature flags
    
    Now that we have feature flags for security related things, set or
    clear them based on what we receive from the hypercall.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f34f9081ec60..fb84c1df6ed7 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -68,6 +68,7 @@
 #include <asm/plpar_wrappers.h>
 #include <asm/kexec.h>
 #include <asm/isa-bridge.h>
+#include <asm/security_features.h>
 
 #include "pseries.h"
 
@@ -459,6 +460,40 @@ static void __init find_and_init_phbs(void)
 	of_pci_check_probe_only();
 }
 
+static void init_cpu_char_feature_flags(struct h_cpu_char_result *result)
+{
+	if (result->character & H_CPU_CHAR_SPEC_BAR_ORI31)
+		security_ftr_set(SEC_FTR_SPEC_BAR_ORI31);
+
+	if (result->character & H_CPU_CHAR_BCCTRL_SERIALISED)
+		security_ftr_set(SEC_FTR_BCCTRL_SERIALISED);
+
+	if (result->character & H_CPU_CHAR_L1D_FLUSH_ORI30)
+		security_ftr_set(SEC_FTR_L1D_FLUSH_ORI30);
+
+	if (result->character & H_CPU_CHAR_L1D_FLUSH_TRIG2)
+		security_ftr_set(SEC_FTR_L1D_FLUSH_TRIG2);
+
+	if (result->character & H_CPU_CHAR_L1D_THREAD_PRIV)
+		security_ftr_set(SEC_FTR_L1D_THREAD_PRIV);
+
+	if (result->character & H_CPU_CHAR_COUNT_CACHE_DISABLED)
+		security_ftr_set(SEC_FTR_COUNT_CACHE_DISABLED);
+
+	/*
+	 * The features below are enabled by default, so we instead look to see
+	 * if firmware has *disabled* them, and clear them if so.
+	 */
+	if (!(result->character & H_CPU_BEHAV_FAVOUR_SECURITY))
+		security_ftr_clear(SEC_FTR_FAVOUR_SECURITY);
+
+	if (!(result->character & H_CPU_BEHAV_L1D_FLUSH_PR))
+		security_ftr_clear(SEC_FTR_L1D_FLUSH_PR);
+
+	if (!(result->character & H_CPU_BEHAV_BNDS_CHK_SPEC_BAR))
+		security_ftr_clear(SEC_FTR_BNDS_CHK_SPEC_BAR);
+}
+
 void pseries_setup_rfi_flush(void)
 {
 	struct h_cpu_char_result result;
@@ -472,6 +507,8 @@ void pseries_setup_rfi_flush(void)
 
 	rc = plpar_get_cpu_characteristics(&result);
 	if (rc == H_SUCCESS) {
+		init_cpu_char_feature_flags(&result);
+
 		if (result.character & H_CPU_CHAR_L1D_FLUSH_TRIG2)
 			types |= L1D_FLUSH_MTTRIG;
 		if (result.character & H_CPU_CHAR_L1D_FLUSH_ORI30)
@@ -482,6 +519,12 @@ void pseries_setup_rfi_flush(void)
 			enable = false;
 	}
 
+	/*
+	 * We're the guest so this doesn't apply to us, clear it to simplify
+	 * handling of it elsewhere.
+	 */
+	security_ftr_clear(SEC_FTR_L1D_FLUSH_HV);
+
 	setup_rfi_flush(types, enable);
 }
 

commit 921bc6cf807ceb2ab8005319cf39f33494d6b100
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Wed Mar 14 19:40:42 2018 -0300

    powerpc/rfi-flush: Call setup_rfi_flush() after LPM migration
    
    We might have migrated to a machine that uses a different flush type,
    or doesn't need flushing at all.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b20d1074acb9..f34f9081ec60 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -459,7 +459,7 @@ static void __init find_and_init_phbs(void)
 	of_pci_check_probe_only();
 }
 
-static void pseries_setup_rfi_flush(void)
+void pseries_setup_rfi_flush(void)
 {
 	struct h_cpu_char_result result;
 	enum l1d_flush_type types;

commit 84749a58b6e382f109abf1e734bc4dd43c2c25bb
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Wed Mar 14 19:40:40 2018 -0300

    powerpc/rfi-flush: Always enable fallback flush on pseries
    
    This ensures the fallback flush area is always allocated on pseries,
    so in case a LPAR is migrated from a patched to an unpatched system,
    it is possible to enable the fallback flush in the target system.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 4642e48d1c2e..b20d1074acb9 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -468,26 +468,18 @@ static void pseries_setup_rfi_flush(void)
 
 	/* Enable by default */
 	enable = true;
+	types = L1D_FLUSH_FALLBACK;
 
 	rc = plpar_get_cpu_characteristics(&result);
 	if (rc == H_SUCCESS) {
-		types = L1D_FLUSH_NONE;
-
 		if (result.character & H_CPU_CHAR_L1D_FLUSH_TRIG2)
 			types |= L1D_FLUSH_MTTRIG;
 		if (result.character & H_CPU_CHAR_L1D_FLUSH_ORI30)
 			types |= L1D_FLUSH_ORI;
 
-		/* Use fallback if nothing set in hcall */
-		if (types == L1D_FLUSH_NONE)
-			types = L1D_FLUSH_FALLBACK;
-
 		if ((!(result.behaviour & H_CPU_BEHAV_L1D_FLUSH_PR)) ||
 		    (!(result.behaviour & H_CPU_BEHAV_FAVOUR_SECURITY)))
 			enable = false;
-	} else {
-		/* Default to fallback if case hcall is not available */
-		types = L1D_FLUSH_FALLBACK;
 	}
 
 	setup_rfi_flush(types, enable);

commit 7c09c1869c9ceb8b356e23161d2ceb0ed0849ac5
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Mar 8 13:54:41 2018 +1100

    powerpc: Rename plapr routines to plpar
    
    Back in 2013 we added some hypercall wrappers which misspelled
    "plpar" (P-series Logical PARtition) as "plapr".
    
    Visually they're hard to distinguish and it almost doesn't matter, but
    it is confusing when grepping to miss some calls because of the typo.
    
    They've also started spreading, so before they take over let's fix
    them all to be "plpar".
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 1a527625acf7..4642e48d1c2e 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -739,7 +739,7 @@ static int pseries_set_dawr(unsigned long dawr, unsigned long dawrx)
 	/* PAPR says we can't set HYP */
 	dawrx &= ~DAWRX_HYP;
 
-	return  plapr_set_watchpoint0(dawr, dawrx);
+	return  plpar_set_watchpoint0(dawr, dawrx);
 }
 
 #define CMO_CHARACTERISTICS_TOKEN 44

commit 582605a429e20ae68fd0b041b2e840af296edd08
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Feb 22 23:58:49 2018 +1100

    powerpc/pseries: Support firmware disable of RFI flush
    
    Some versions of firmware will have a setting that can be configured
    to disable the RFI flush, add support for it.
    
    Fixes: 8989d56878a7 ("powerpc/pseries: Query hypervisor for RFI flush settings")
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 372d7ada1a0c..1a527625acf7 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -482,7 +482,8 @@ static void pseries_setup_rfi_flush(void)
 		if (types == L1D_FLUSH_NONE)
 			types = L1D_FLUSH_FALLBACK;
 
-		if (!(result.behaviour & H_CPU_BEHAV_L1D_FLUSH_PR))
+		if ((!(result.behaviour & H_CPU_BEHAV_L1D_FLUSH_PR)) ||
+		    (!(result.behaviour & H_CPU_BEHAV_FAVOUR_SECURITY)))
 			enable = false;
 	} else {
 		/* Default to fallback if case hcall is not available */

commit fc5f622163637308a3d520a315527481cff023f5
Author: Bryant G. Ly <bryantly@linux.vnet.ibm.com>
Date:   Fri Jan 5 10:45:52 2018 -0600

    powerpc/pseries: Add Initialization of VF Bars
    
    When enabling SR-IOV in pseries platform, the VF bar properties for a
    PF are reported on the device node in the device tree.
    
    This patch adds the IOV Bar resources to Linux structures from the
    device tree for later use when configuring SR-IOV by PF driver.
    
    Signed-off-by: Bryant G. Ly <bryantly@linux.vnet.ibm.com>
    Signed-off-by: Juan J. Alvarez <jjalvare@linux.vnet.ibm.com>
    Acked-by: Russell Currey <ruscur@russell.cc>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 42e9cf0b3180..372d7ada1a0c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -492,6 +492,162 @@ static void pseries_setup_rfi_flush(void)
 	setup_rfi_flush(types, enable);
 }
 
+#ifdef CONFIG_PCI_IOV
+enum rtas_iov_fw_value_map {
+	NUM_RES_PROPERTY  = 0, /* Number of Resources */
+	LOW_INT           = 1, /* Lowest 32 bits of Address */
+	START_OF_ENTRIES  = 2, /* Always start of entry */
+	APERTURE_PROPERTY = 2, /* Start of entry+ to  Aperture Size */
+	WDW_SIZE_PROPERTY = 4, /* Start of entry+ to Window Size */
+	NEXT_ENTRY        = 7  /* Go to next entry on array */
+};
+
+enum get_iov_fw_value_index {
+	BAR_ADDRS     = 1,    /*  Get Bar Address */
+	APERTURE_SIZE = 2,    /*  Get Aperture Size */
+	WDW_SIZE      = 3     /*  Get Window Size */
+};
+
+resource_size_t pseries_get_iov_fw_value(struct pci_dev *dev, int resno,
+					 enum get_iov_fw_value_index value)
+{
+	const int *indexes;
+	struct device_node *dn = pci_device_to_OF_node(dev);
+	int i, num_res, ret = 0;
+
+	indexes = of_get_property(dn, "ibm,open-sriov-vf-bar-info", NULL);
+	if (!indexes)
+		return  0;
+
+	/*
+	 * First element in the array is the number of Bars
+	 * returned.  Search through the list to find the matching
+	 * bar
+	 */
+	num_res = of_read_number(&indexes[NUM_RES_PROPERTY], 1);
+	if (resno >= num_res)
+		return 0; /* or an errror */
+
+	i = START_OF_ENTRIES + NEXT_ENTRY * resno;
+	switch (value) {
+	case BAR_ADDRS:
+		ret = of_read_number(&indexes[i], 2);
+		break;
+	case APERTURE_SIZE:
+		ret = of_read_number(&indexes[i + APERTURE_PROPERTY], 2);
+		break;
+	case WDW_SIZE:
+		ret = of_read_number(&indexes[i + WDW_SIZE_PROPERTY], 2);
+		break;
+	}
+
+	return ret;
+}
+
+void of_pci_set_vf_bar_size(struct pci_dev *dev, const int *indexes)
+{
+	struct resource *res;
+	resource_size_t base, size;
+	int i, r, num_res;
+
+	num_res = of_read_number(&indexes[NUM_RES_PROPERTY], 1);
+	num_res = min_t(int, num_res, PCI_SRIOV_NUM_BARS);
+	for (i = START_OF_ENTRIES, r = 0; r < num_res && r < PCI_SRIOV_NUM_BARS;
+	     i += NEXT_ENTRY, r++) {
+		res = &dev->resource[r + PCI_IOV_RESOURCES];
+		base = of_read_number(&indexes[i], 2);
+		size = of_read_number(&indexes[i + APERTURE_PROPERTY], 2);
+		res->flags = pci_parse_of_flags(of_read_number
+						(&indexes[i + LOW_INT], 1), 0);
+		res->flags |= (IORESOURCE_MEM_64 | IORESOURCE_PCI_FIXED);
+		res->name = pci_name(dev);
+		res->start = base;
+		res->end = base + size - 1;
+	}
+}
+
+void of_pci_parse_iov_addrs(struct pci_dev *dev, const int *indexes)
+{
+	struct resource *res, *root, *conflict;
+	resource_size_t base, size;
+	int i, r, num_res;
+
+	/*
+	 * First element in the array is the number of Bars
+	 * returned.  Search through the list to find the matching
+	 * bars assign them from firmware into resources structure.
+	 */
+	num_res = of_read_number(&indexes[NUM_RES_PROPERTY], 1);
+	for (i = START_OF_ENTRIES, r = 0; r < num_res && r < PCI_SRIOV_NUM_BARS;
+	     i += NEXT_ENTRY, r++) {
+		res = &dev->resource[r + PCI_IOV_RESOURCES];
+		base = of_read_number(&indexes[i], 2);
+		size = of_read_number(&indexes[i + WDW_SIZE_PROPERTY], 2);
+		res->name = pci_name(dev);
+		res->start = base;
+		res->end = base + size - 1;
+		root = &iomem_resource;
+		dev_dbg(&dev->dev,
+			"pSeries IOV BAR %d: trying firmware assignment %pR\n",
+			 r + PCI_IOV_RESOURCES, res);
+		conflict = request_resource_conflict(root, res);
+		if (conflict) {
+			dev_info(&dev->dev,
+				 "BAR %d: %pR conflicts with %s %pR\n",
+				 r + PCI_IOV_RESOURCES, res,
+				 conflict->name, conflict);
+			res->flags |= IORESOURCE_UNSET;
+		}
+	}
+}
+
+static void pseries_pci_fixup_resources(struct pci_dev *pdev)
+{
+	const int *indexes;
+	struct device_node *dn = pci_device_to_OF_node(pdev);
+
+	/*Firmware must support open sriov otherwise dont configure*/
+	indexes = of_get_property(dn, "ibm,open-sriov-vf-bar-info", NULL);
+	if (!indexes)
+		return;
+	/* Assign the addresses from device tree*/
+	of_pci_set_vf_bar_size(pdev, indexes);
+}
+
+static void pseries_pci_fixup_iov_resources(struct pci_dev *pdev)
+{
+	const int *indexes;
+	struct device_node *dn = pci_device_to_OF_node(pdev);
+
+	if (!pdev->is_physfn || pdev->is_added)
+		return;
+	/*Firmware must support open sriov otherwise dont configure*/
+	indexes = of_get_property(dn, "ibm,open-sriov-vf-bar-info", NULL);
+	if (!indexes)
+		return;
+	/* Assign the addresses from device tree*/
+	of_pci_parse_iov_addrs(pdev, indexes);
+}
+
+static resource_size_t pseries_pci_iov_resource_alignment(struct pci_dev *pdev,
+							  int resno)
+{
+	const __be32 *reg;
+	struct device_node *dn = pci_device_to_OF_node(pdev);
+
+	/*Firmware must support open sriov otherwise report regular alignment*/
+	reg = of_get_property(dn, "ibm,is-open-sriov-pf", NULL);
+	if (!reg)
+		return pci_iov_resource_size(pdev, resno);
+
+	if (!pdev->is_physfn)
+		return 0;
+	return pseries_get_iov_fw_value(pdev,
+					resno - PCI_IOV_RESOURCES,
+					APERTURE_SIZE);
+}
+#endif
+
 static void __init pSeries_setup_arch(void)
 {
 	set_arch_panic_timeout(10, ARCH_PANIC_TIMEOUT);
@@ -525,6 +681,14 @@ static void __init pSeries_setup_arch(void)
 		vpa_init(boot_cpuid);
 		ppc_md.power_save = pseries_lpar_idle;
 		ppc_md.enable_pmcs = pseries_lpar_enable_pmcs;
+#ifdef CONFIG_PCI_IOV
+		ppc_md.pcibios_fixup_resources =
+			pseries_pci_fixup_resources;
+		ppc_md.pcibios_fixup_sriov =
+			pseries_pci_fixup_iov_resources;
+		ppc_md.pcibios_iov_resource_alignment =
+			pseries_pci_iov_resource_alignment;
+#endif
 	} else {
 		/* No special idle routine */
 		ppc_md.enable_pmcs = power4_enable_pmcs;

commit 35adacd6fc48d658419522f192a3c8b2785612da
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Sun Dec 24 02:49:23 2017 +1000

    powerpc/pseries, ps3: panic flush kernel messages before halting system
    
    Platforms with a panic handler that halts the system can have problems
    getting kernel messages out, because the panic notifiers are called
    before kernel/panic.c does its flushing of printk buffers an console
    etc.
    
    This was attempted to be solved with commit a3b2cb30f252 ("powerpc: Do
    not call ppc_md.panic in fadump panic notifier"), but that wasn't the
    right approach and caused other problems, and was reverted by commit
    ab9dbf771ff9.
    
    Instead, the powernv shutdown paths have already had a similar
    problem, fixed by taking the message flushing sequence from
    kernel/panic.c. That's a little bit ugly, but while we have the code
    duplicated, it will work for this case as well. So have ppc panic
    handlers do the same flushing before they terminate.
    
    Without this patch, a qemu pseries_le_defconfig guest stops silently
    when issued the nmi command when xmon is off and no crash dumpers
    enabled. Afterwards, an oops is printed by each CPU as expected.
    
    Fixes: ab9dbf771ff9 ("Revert "powerpc: Do not call ppc_md.panic in fadump panic notifier"")
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index db76963e693d..42e9cf0b3180 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -533,6 +533,12 @@ static void __init pSeries_setup_arch(void)
 	ppc_md.pcibios_root_bridge_prepare = pseries_root_bridge_prepare;
 }
 
+static void pseries_panic(char *str)
+{
+	panic_flush_kmsg_end();
+	rtas_os_term(str);
+}
+
 static int __init pSeries_init_panel(void)
 {
 	/* Manually leave the kernel version on the panel. */
@@ -761,7 +767,7 @@ define_machine(pseries) {
 	.pcibios_fixup		= pSeries_final_fixup,
 	.restart		= rtas_restart,
 	.halt			= rtas_halt,
-	.panic			= rtas_os_term,
+	.panic			= pseries_panic,
 	.get_boot_time		= rtas_get_boot_time,
 	.get_rtc_time		= rtas_get_rtc_time,
 	.set_rtc_time		= rtas_set_rtc_time,

commit ebf0b6a8b1e445d2be66087732aafcda12ab9f59
Merge: 5400fc229e60 1b689a95ce74
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Sun Jan 21 23:21:14 2018 +1100

    Merge branch 'fixes' into next
    
    Merge our fixes branch from the 4.15 cycle.
    
    Unusually the fixes branch saw some significant features merged,
    notably the RFI flush patches, so we want the code in next to be
    tested against that, to avoid any surprises when the two are merged.
    
    There's also some other work on the panic handling that was reverted
    in fixes and we now want to do properly in next, which would conflict.
    
    And we also fix a few other minor merge conflicts.

commit 8989d56878a7735dfdb234707a2fee6faf631085
Author: Michael Neuling <mikey@neuling.org>
Date:   Wed Jan 10 03:07:15 2018 +1100

    powerpc/pseries: Query hypervisor for RFI flush settings
    
    A new hypervisor call is available which tells the guest settings
    related to the RFI flush. Use it to query the appropriate flush
    instruction(s), and whether the flush is required.
    
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index a8531e012658..ae4f596273b5 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -459,6 +459,39 @@ static void __init find_and_init_phbs(void)
 	of_pci_check_probe_only();
 }
 
+static void pseries_setup_rfi_flush(void)
+{
+	struct h_cpu_char_result result;
+	enum l1d_flush_type types;
+	bool enable;
+	long rc;
+
+	/* Enable by default */
+	enable = true;
+
+	rc = plpar_get_cpu_characteristics(&result);
+	if (rc == H_SUCCESS) {
+		types = L1D_FLUSH_NONE;
+
+		if (result.character & H_CPU_CHAR_L1D_FLUSH_TRIG2)
+			types |= L1D_FLUSH_MTTRIG;
+		if (result.character & H_CPU_CHAR_L1D_FLUSH_ORI30)
+			types |= L1D_FLUSH_ORI;
+
+		/* Use fallback if nothing set in hcall */
+		if (types == L1D_FLUSH_NONE)
+			types = L1D_FLUSH_FALLBACK;
+
+		if (!(result.behaviour & H_CPU_BEHAV_L1D_FLUSH_PR))
+			enable = false;
+	} else {
+		/* Default to fallback if case hcall is not available */
+		types = L1D_FLUSH_FALLBACK;
+	}
+
+	setup_rfi_flush(types, enable);
+}
+
 static void __init pSeries_setup_arch(void)
 {
 	set_arch_panic_timeout(10, ARCH_PANIC_TIMEOUT);
@@ -476,6 +509,8 @@ static void __init pSeries_setup_arch(void)
 
 	fwnmi_init();
 
+	pseries_setup_rfi_flush();
+
 	/* By default, only probe PCI (can be overridden by rtas_pci) */
 	pci_add_flags(PCI_PROBE_ONLY);
 

commit ab9dbf771ff9b6b7e814e759213ed01d7f0de320
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Mon Dec 4 16:27:25 2017 +1100

    Revert "powerpc: Do not call ppc_md.panic in fadump panic notifier"
    
    This reverts commit a3b2cb30f252b21a6f962e0dd107c8b897ca65e4.
    
    That commit tried to fix problems with panic on powerpc in certain
    circumstances, where some output from the generic panic code was being
    dropped.
    
    Unfortunately, it breaks things worse in other circumstances. In
    particular when running a PAPR guest, it will now attempt to reboot
    instead of informing the hypervisor (KVM or PowerVM) that the guest
    has crashed. The crash notification is important to some
    virtualization management layers.
    
    Revert it for now until we can come up with a better solution.
    
    Fixes: a3b2cb30f252 ("powerpc: Do not call ppc_md.panic in fadump panic notifier")
    Cc: stable@vger.kernel.org # v4.14+
    Signed-off-by: David Gibson <david@gibson.dropbear.id.au>
    [mpe: Tweak change log a bit]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 5f1beb8367ac..a8531e012658 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -726,6 +726,7 @@ define_machine(pseries) {
 	.pcibios_fixup		= pSeries_final_fixup,
 	.restart		= rtas_restart,
 	.halt			= rtas_halt,
+	.panic			= rtas_os_term,
 	.get_boot_time		= rtas_get_boot_time,
 	.get_rtc_time		= rtas_get_rtc_time,
 	.set_rtc_time		= rtas_set_rtc_time,

commit f2c2cbcc35d47f1471a04155ac357521f5170371
Author: Joe Perches <joe@perches.com>
Date:   Mon Oct 24 21:00:08 2016 -0700

    powerpc: Use pr_warn instead of pr_warning
    
    At some point, pr_warning will be removed so all logging messages use
    a consistent <prefix>_warn style.
    
    Update arch/powerpc/
    
    Miscellanea:
    
    o Coalesce formats
    o Realign arguments
    o Use %s, __func__ instead of embedded function names
    o Remove unnecessary line continuations
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Geoff Levand <geoff@infradead.org>
    [mpe: Rebase due to some %pOF changes.]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 5f1beb8367ac..1d6e2de2445c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -371,8 +371,8 @@ void pseries_disable_reloc_on_exc(void)
 		mdelay(get_longbusy_msecs(rc));
 	}
 	if (rc != H_SUCCESS)
-		pr_warning("Warning: Failed to disable relocation on "
-			   "exceptions: %ld\n", rc);
+		pr_warn("Warning: Failed to disable relocation on exceptions: %ld\n",
+			rc);
 }
 EXPORT_SYMBOL(pseries_disable_reloc_on_exc);
 

commit eac1e731b59ee3b5f5e641a7765c7ed41ed26226
Author: CÃ©dric Le Goater <clg@kaod.org>
Date:   Wed Aug 30 21:46:11 2017 +0200

    powerpc/xive: guest exploitation of the XIVE interrupt controller
    
    This is the framework for using XIVE in a PowerVM guest. The support
    is very similar to the native one in a much simpler form.
    
    Each source is associated with an Event State Buffer (ESB). This is a
    two bit state machine which is used to trigger events. The bits are
    named "P" (pending) and "Q" (queued) and can be controlled by MMIO.
    The Guest OS registers event (or notifications) queues on which the HW
    will post event data for a target to notify.
    
    Instead of OPAL calls, a set of Hypervisors call are used to configure
    the interrupt sources and the event/notification queues of the guest:
    
     - H_INT_GET_SOURCE_INFO
    
       used to obtain the address of the MMIO page of the Event State
       Buffer (PQ bits) entry associated with the source.
    
     - H_INT_SET_SOURCE_CONFIG
    
       assigns a source to a "target".
    
     - H_INT_GET_SOURCE_CONFIG
    
       determines to which "target" and "priority" is assigned to a source
    
     - H_INT_GET_QUEUE_INFO
    
       returns the address of the notification management page associated
       with the specified "target" and "priority".
    
     - H_INT_SET_QUEUE_CONFIG
    
       sets or resets the event queue for a given "target" and "priority".
       It is also used to set the notification config associated with the
       queue, only unconditional notification for the moment.  Reset is
       performed with a queue size of 0 and queueing is disabled in that
       case.
    
     - H_INT_GET_QUEUE_CONFIG
    
       returns the queue settings for a given "target" and "priority".
    
     - H_INT_RESET
    
       resets all of the partition's interrupt exploitation structures to
       their initial state, losing all configuration set via the hcalls
       H_INT_SET_SOURCE_CONFIG and H_INT_SET_QUEUE_CONFIG.
    
     - H_INT_SYNC
    
       issue a synchronisation on a source to make sure sure all
       notifications have reached their queue.
    
    As for XICS, the XIVE interface for the guest is described in the
    device tree under the "interrupt-controller" node. A couple of new
    properties are specific to XIVE :
    
     - "reg"
    
       contains the base address and size of the thread interrupt
       managnement areas (TIMA), also called rings, for the User level and
       for the Guest OS level. Only the Guest OS level is taken into
       account today.
    
     - "ibm,xive-eq-sizes"
    
       the size of the event queues. One cell per size supported, contains
       log2 of size, in ascending order.
    
     - "ibm,xive-lisn-ranges"
    
       the interrupt numbers ranges assigned to the guest. These are
       allocated using a simple bitmap.
    
    and also :
    
     - "/ibm,plat-res-int-priorities"
    
       contains a list of priorities that the hypervisor has reserved for
       its own use.
    
    Tested with a QEMU XIVE model for pseries and with the Power hypervisor.
    
    Signed-off-by: CÃ©dric Le Goater <clg@kaod.org>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b5b650910cf5..5f1beb8367ac 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -57,6 +57,7 @@
 #include <asm/nvram.h>
 #include <asm/pmc.h>
 #include <asm/xics.h>
+#include <asm/xive.h>
 #include <asm/ppc-pci.h>
 #include <asm/i8259.h>
 #include <asm/udbg.h>
@@ -176,8 +177,11 @@ static void __init pseries_setup_i8259_cascade(void)
 
 static void __init pseries_init_irq(void)
 {
-	xics_init();
-	pseries_setup_i8259_cascade();
+	/* Try using a XIVE if available, otherwise use a XICS */
+	if (!xive_spapr_init()) {
+		xics_init();
+		pseries_setup_i8259_cascade();
+	}
 }
 
 static void pseries_lpar_enable_pmcs(void)

commit a3b2cb30f252b21a6f962e0dd107c8b897ca65e4
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Jul 5 13:56:25 2017 +1000

    powerpc: Do not call ppc_md.panic in fadump panic notifier
    
    If fadump is not registered, and no other crash or debug handlers are
    registered, the powerpc panic handler stops the guest before the
    generic panic code can push out debug information to the console.
    
    Currently, system reset injection causes the guest to silently stop.
    
    Stop calling ppc_md.panic in the panic notifier. crash_fadump already
    does rtas_os_term() to terminate the guest if fadump is registered.
    
    Remove ppc_md.panic. Move fadump panic notifier into fadump code.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Reviewed-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b5d86426e97b..b5b650910cf5 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -722,7 +722,6 @@ define_machine(pseries) {
 	.pcibios_fixup		= pSeries_final_fixup,
 	.restart		= rtas_restart,
 	.halt			= rtas_halt,
-	.panic			= rtas_os_term,
 	.get_boot_time		= rtas_get_boot_time,
 	.get_rtc_time		= rtas_get_rtc_time,
 	.set_rtc_time		= rtas_set_rtc_time,

commit 3a4c26011da3ed8df1f4f93af82bd5f2b420751f
Author: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Date:   Tue Mar 21 22:59:55 2017 +0530

    powerpc/mm: Add translation mode information in /proc/cpuinfo
    
    With this we have on powernv and pseries /proc/cpuinfo reporting
    
    timebase        : 512000000
    platform        : PowerNV
    model           : 8247-22L
    machine         : PowerNV 8247-22L
    firmware        : OPAL
    MMU             : Hash
    
    Reviewed-by: Paul Mackerras <paulus@ozlabs.org>
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b4d362ed03a1..b5d86426e97b 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -87,6 +87,10 @@ static void pSeries_show_cpuinfo(struct seq_file *m)
 		model = of_get_property(root, "model", NULL);
 	seq_printf(m, "machine\t\t: CHRP %s\n", model);
 	of_node_put(root);
+	if (radix_enabled())
+		seq_printf(m, "MMU\t\t: Radix\n");
+	else
+		seq_printf(m, "MMU\t\t: Hash\n");
 }
 
 /* Initialize firmware assisted non-maskable interrupts if

commit 38e9d36bc149932964dcd25818c7f7283239592d
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jan 30 18:11:55 2017 +1100

    powerpc: Move isa bridge definitions to separate include
    
    We'll be adding non-PCI isa bridge support so let's not
    have all the definition in pci-bridge.h
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 7736352f7279..b4d362ed03a1 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -66,6 +66,7 @@
 #include <asm/reg.h>
 #include <asm/plpar_wrappers.h>
 #include <asm/kexec.h>
+#include <asm/isa-bridge.h>
 
 #include "pseries.h"
 

commit da6658859b9c734fee36570f3a7d51764c6c3838
Author: Thiago Jung Bauermann <bauerman@linux.vnet.ibm.com>
Date:   Tue Nov 29 23:45:50 2016 +1100

    powerpc: Change places using CONFIG_KEXEC to use CONFIG_KEXEC_CORE instead.
    
    Commit 2965faa5e03d ("kexec: split kexec_load syscall from kexec core
    code") introduced CONFIG_KEXEC_CORE so that CONFIG_KEXEC means whether
    the kexec_load system call should be compiled-in and CONFIG_KEXEC_FILE
    means whether the kexec_file_load system call should be compiled-in.
    These options can be set independently from each other.
    
    Since until now powerpc only supported kexec_load, CONFIG_KEXEC and
    CONFIG_KEXEC_CORE were synonyms. That is not the case anymore, so we
    need to make a distinction. Almost all places where CONFIG_KEXEC was
    being used should be using CONFIG_KEXEC_CORE instead, since
    kexec_file_load also needs that code compiled in.
    
    Signed-off-by: Thiago Jung Bauermann <bauerman@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 97aa3f332f24..7736352f7279 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -367,7 +367,7 @@ void pseries_disable_reloc_on_exc(void)
 }
 EXPORT_SYMBOL(pseries_disable_reloc_on_exc);
 
-#ifdef CONFIG_KEXEC
+#ifdef CONFIG_KEXEC_CORE
 static void pSeries_machine_kexec(struct kimage *image)
 {
 	if (firmware_has_feature(FW_FEATURE_SET_MODE))
@@ -725,7 +725,7 @@ define_machine(pseries) {
 	.progress		= rtas_progress,
 	.system_reset_exception = pSeries_system_reset_exception,
 	.machine_check_exception = pSeries_machine_check_exception,
-#ifdef CONFIG_KEXEC
+#ifdef CONFIG_KEXEC_CORE
 	.machine_kexec          = pSeries_machine_kexec,
 	.kexec_cpu_down         = pseries_kexec_cpu_down,
 #endif

commit 07021b43597f506cc525d139ed1a94e79cf184f2
Merge: d1f5323370fc b7b7013cac55
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 7 20:19:31 2016 -0700

    Merge tag 'powerpc-4.9-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc updates from Michael Ellerman:
     "Highlights:
       - Major rework of Book3S 64-bit exception vectors (Nicholas Piggin)
       - Use gas sections for arranging exception vectors et. al.
       - Large set of TM cleanups and selftests (Cyril Bur)
       - Enable transactional memory (TM) lazily for userspace (Cyril Bur)
       - Support for XZ compression in the zImage wrapper (Oliver
         O'Halloran)
       - Add support for bpf constant blinding (Naveen N. Rao)
       - Beginnings of upstream support for PA Semi Nemo motherboards
         (Darren Stevens)
    
      Fixes:
       - Ensure .mem(init|exit).text are within _stext/_etext (Michael
         Ellerman)
       - xmon: Don't use ld on 32-bit (Michael Ellerman)
       - vdso64: Use double word compare on pointers (Anton Blanchard)
       - powerpc/nvram: Fix an incorrect partition merge (Pan Xinhui)
       - powerpc: Fix usage of _PAGE_RO in hugepage (Christophe Leroy)
       - powerpc/mm: Update FORCE_MAX_ZONEORDER range to allow hugetlb w/4K
         (Aneesh Kumar K.V)
       - Fix memory leak in queue_hotplug_event() error path (Andrew
         Donnellan)
       - Replay hypervisor maintenance interrupt first (Nicholas Piggin)
    
      Various performance optimisations (Anton Blanchard):
       - Align hot loops of memset() and backwards_memcpy()
       - During context switch, check before setting mm_cpumask
       - Remove static branch prediction in atomic{, 64}_add_unless
       - Only disable HAVE_EFFICIENT_UNALIGNED_ACCESS on POWER7 little
         endian
       - Set default CPU type to POWER8 for little endian builds
    
      Cleanups & features:
       - Sparse fixes/cleanups (Daniel Axtens)
       - Preserve CFAR value on SLB miss caused by access to bogus address
         (Paul Mackerras)
       - Radix MMU fixups for POWER9 (Aneesh Kumar K.V)
       - Support for setting used_(vsr|vr|spe) in sigreturn path (for CRIU)
         (Simon Guo)
       - Optimise syscall entry for virtual, relocatable case (Nicholas
         Piggin)
       - Optimise MSR handling in exception handling (Nicholas Piggin)
       - Support for kexec with Radix MMU (Benjamin Herrenschmidt)
       - powernv EEH fixes (Russell Currey)
       - Suprise PCI hotplug support for powernv (Gavin Shan)
       - Endian/sparse fixes for powernv PCI (Gavin Shan)
       - Defconfig updates (Anton Blanchard)
       - KVM: PPC: Book3S HV: Migrate pinned pages out of CMA (Balbir Singh)
       - cxl: Flush PSL cache before resetting the adapter (Frederic Barrat)
       - cxl: replace loop with for_each_child_of_node(), remove unneeded
         of_node_put() (Andrew Donnellan)
       - Fix HV facility unavailable to use correct handler (Nicholas
         Piggin)
       - Remove unnecessary syscall trampoline (Nicholas Piggin)
       - fadump: Fix build break when CONFIG_PROC_VMCORE=n (Michael
         Ellerman)
       - Quieten EEH message when no adapters are found (Anton Blanchard)
       - powernv: Add PHB register dump debugfs handle (Russell Currey)
       - Use kprobe blacklist for exception handlers & asm functions
         (Nicholas Piggin)
       - Document the syscall ABI (Nicholas Piggin)
       - MAINTAINERS: Update cxl maintainers (Michael Neuling)
       - powerpc: Remove all usages of NO_IRQ (Michael Ellerman)
    
      Minor cleanups:
       - Andrew Donnellan, Christophe Leroy, Colin Ian King, Cyril Bur,
         Frederic Barrat, Pan Xinhui, PrasannaKumar Muralidharan, Rui Teng,
         Simon Guo"
    
    * tag 'powerpc-4.9-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (156 commits)
      powerpc/bpf: Add support for bpf constant blinding
      powerpc/bpf: Implement support for tail calls
      powerpc/bpf: Introduce accessors for using the tmp local stack space
      powerpc/fadump: Fix build break when CONFIG_PROC_VMCORE=n
      powerpc: tm: Enable transactional memory (TM) lazily for userspace
      powerpc/tm: Add TM Unavailable Exception
      powerpc: Remove do_load_up_transact_{fpu,altivec}
      powerpc: tm: Rename transct_(*) to ck(\1)_state
      powerpc: tm: Always use fp_state and vr_state to store live registers
      selftests/powerpc: Add checks for transactional VSXs in signal contexts
      selftests/powerpc: Add checks for transactional VMXs in signal contexts
      selftests/powerpc: Add checks for transactional FPUs in signal contexts
      selftests/powerpc: Add checks for transactional GPRs in signal contexts
      selftests/powerpc: Check that signals always get delivered
      selftests/powerpc: Add TM tcheck helpers in C
      selftests/powerpc: Allow tests to extend their kill timeout
      selftests/powerpc: Introduce GPR asm helper header file
      selftests/powerpc: Move VMX stack frame macros to header file
      selftests/powerpc: Rework FPU stack placement macros and move to header file
      selftests/powerpc: Check for VSX preservation across userspace preemption
      ...

commit ef24ba7091517d2bbf9ba2cb4256c0dccd51d248
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Sep 6 21:53:24 2016 +1000

    powerpc: Remove all usages of NO_IRQ
    
    NO_IRQ has been == 0 on powerpc for just over ten years (since commit
    0ebfff1491ef ("[POWERPC] Add new interrupt mapping core and change
    platforms to use it")). It's also 0 on most other arches.
    
    Although it's fairly harmless, every now and then it causes confusion
    when a driver is built on powerpc and another arch which doesn't define
    NO_IRQ. There's at least 6 definitions of NO_IRQ in drivers/, at least
    some of which are to work around that problem.
    
    So we'd like to remove it. This is fairly trivial in the arch code, we
    just convert:
    
        if (irq == NO_IRQ)  to      if (!irq)
        if (irq != NO_IRQ)  to      if (irq)
        irq = NO_IRQ;       to      irq = 0;
        return NO_IRQ;      to      return 0;
    
    And a few other odd cases as well.
    
    At least for now we keep the #define NO_IRQ, because there is driver
    code that uses NO_IRQ and the fixes to remove those will go via other
    trees.
    
    Note we also change some occurrences in PPC sound drivers, drivers/ps3,
    and drivers/macintosh.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 4ffcaa6f8670..776900043e2a 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -114,7 +114,7 @@ static void pseries_8259_cascade(struct irq_desc *desc)
 	struct irq_chip *chip = irq_desc_get_chip(desc);
 	unsigned int cascade_irq = i8259_irq();
 
-	if (cascade_irq != NO_IRQ)
+	if (cascade_irq)
 		generic_handle_irq(cascade_irq);
 
 	chip->irq_eoi(&desc->irq_data);
@@ -141,7 +141,7 @@ static void __init pseries_setup_i8259_cascade(void)
 	}
 
 	cascade = irq_of_parse_and_map(found, 0);
-	if (cascade == NO_IRQ) {
+	if (!cascade) {
 		printk(KERN_ERR "pic: failed to map cascade interrupt");
 		return;
 	}

commit d81d8258218228d3137055afe8acf981c3ebed46
Author: Thiago Jung Bauermann <bauerman@linux.vnet.ibm.com>
Date:   Tue Aug 23 19:57:39 2016 -0300

    powerpc/pseries: Fix little endian build with CONFIG_KEXEC=n
    
    On ppc64le, builds with CONFIG_KEXEC=n fail with:
    
    arch/powerpc/platforms/pseries/setup.c: In function âpseries_big_endian_exceptionsâ:
    arch/powerpc/platforms/pseries/setup.c:403:13: error: implicit declaration of function âkdump_in_progressâ
      if (rc && !kdump_in_progress())
    
    This is because pseries/setup.c includes <linux/kexec.h>, but
    kdump_in_progress() is defined in <asm/kexec.h>. This is a problem
    because the former only includes the latter if CONFIG_KEXEC_CORE=y.
    
    Fix it by including <asm/kexec.h> directly, as is done in powernv/setup.c.
    
    Fixes: d3cbff1b5a90 ("powerpc: Put exception configuration in a common place")
    Signed-off-by: Thiago Jung Bauermann <bauerman@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 4ffcaa6f8670..a39d20e8623d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -41,7 +41,6 @@
 #include <linux/root_dev.h>
 #include <linux/of.h>
 #include <linux/of_pci.h>
-#include <linux/kexec.h>
 
 #include <asm/mmu.h>
 #include <asm/processor.h>
@@ -66,6 +65,7 @@
 #include <asm/eeh.h>
 #include <asm/reg.h>
 #include <asm/plpar_wrappers.h>
+#include <asm/kexec.h>
 
 #include "pseries.h"
 

commit f2d576948d6cec16e4aae201d738c4f22039a551
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:04:06 2016 +1000

    powerpc: Get rid of ppc_md.init_early()
    
    It is now called right after platform probe, so the probe function
    can just do the job.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 6988b9dc3d3b..4ffcaa6f8670 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -620,9 +620,9 @@ static void pSeries_cmo_feature_init(void)
 /*
  * Early initialization.  Relocation is on but do not reference unbolted pages
  */
-static void __init pSeries_init_early(void)
+static void __init pseries_init(void)
 {
-	pr_debug(" -> pSeries_init_early()\n");
+	pr_debug(" -> pseries_init()\n");
 
 #ifdef CONFIG_HVC_CONSOLE
 	if (firmware_has_feature(FW_FEATURE_LPAR))
@@ -639,7 +639,7 @@ static void __init pSeries_init_early(void)
 	pSeries_cmo_feature_init();
 	iommu_init_early_pSeries();
 
-	pr_debug(" <- pSeries_init_early()\n");
+	pr_debug(" <- pseries_init()\n");
 }
 
 /**
@@ -691,6 +691,8 @@ static int __init pSeries_probe(void)
 	pr_debug("Machine is%s LPAR !\n",
 	         (powerpc_firmware_features & FW_FEATURE_LPAR) ? "" : " not");
 
+	pseries_init();
+
 	return 1;
 }
 
@@ -709,7 +711,6 @@ define_machine(pseries) {
 	.name			= "pSeries",
 	.probe			= pSeries_probe,
 	.setup_arch		= pSeries_setup_arch,
-	.init_early		= pSeries_init_early,
 	.init_IRQ		= pseries_init_irq,
 	.show_cpuinfo		= pSeries_show_cpuinfo,
 	.log_error		= pSeries_log_error,

commit 406b0b6ae3fcd5c7946a68a9e43b470c79d292a2
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:04:00 2016 +1000

    powerpc/64: Move 64-bit probe_machine() to later in the boot process
    
    We no long need the machine type that early, so we can move probe_machine()
    to after the device-tree has been expanded. This will allow further
    consolidation.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 240721348ebc..6988b9dc3d3b 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -672,8 +672,7 @@ static void pseries_power_off(void)
 
 static int __init pSeries_probe(void)
 {
-	unsigned long root = of_get_flat_dt_root();
-	const char *dtype = of_get_flat_dt_prop(root, "device_type", NULL);
+	const char *dtype = of_get_property(of_root, "device_type", NULL);
 
  	if (dtype == NULL)
  		return 0;
@@ -683,8 +682,8 @@ static int __init pSeries_probe(void)
 	/* Cell blades firmware claims to be chrp while it's not. Until this
 	 * is fixed, we need to avoid those here.
 	 */
-	if (of_flat_dt_is_compatible(root, "IBM,CPBW-1.0") ||
-	    of_flat_dt_is_compatible(root, "IBM,CBEA"))
+	if (of_machine_is_compatible("IBM,CPBW-1.0") ||
+	    of_machine_is_compatible("IBM,CBEA"))
 		return 0;
 
 	pm_power_off = pseries_power_off;

commit 166dd7d3fbf2df183926f0e4b4855f6cbd8da945
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:03:51 2016 +1000

    powerpc/64: Move MMU backend selection out of platform code
    
    We move it into early_mmu_init() based on firmware features. For PS3,
    we have to move the setting of these into early_init_devtree().
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index ba7dc126b5e5..240721348ebc 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -687,13 +687,6 @@ static int __init pSeries_probe(void)
 	    of_flat_dt_is_compatible(root, "IBM,CBEA"))
 		return 0;
 
-	pr_debug("pSeries detected, looking for LPAR capability...\n");
-
-	if (firmware_has_feature(FW_FEATURE_LPAR))
-		hpte_init_lpar();
-	else
-		hpte_init_native();
-
 	pm_power_off = pseries_power_off;
 
 	pr_debug("Machine is%s LPAR !\n",

commit d3cbff1b5a90afe6cb201aa2187c9609e21f92ad
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:03:49 2016 +1000

    powerpc: Put exception configuration in a common place
    
    The various calls to establish exception endianness and AIL are
    now done from a single point using already established CPU and FW
    feature bits to decide what to do.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 9cc9b88fce79..ba7dc126b5e5 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -319,15 +319,23 @@ static void pseries_lpar_idle(void)
  * to ever be a problem in practice we can move this into a kernel thread to
  * finish off the process later in boot.
  */
-long pSeries_enable_reloc_on_exc(void)
+void pseries_enable_reloc_on_exc(void)
 {
 	long rc;
 	unsigned int delay, total_delay = 0;
 
 	while (1) {
 		rc = enable_reloc_on_exceptions();
-		if (!H_IS_LONG_BUSY(rc))
-			return rc;
+		if (!H_IS_LONG_BUSY(rc)) {
+			if (rc == H_P2) {
+				pr_info("Relocation on exceptions not"
+					" supported\n");
+			} else if (rc != H_SUCCESS) {
+				pr_warn("Unable to enable relocation"
+					" on exceptions: %ld\n", rc);
+			}
+			break;
+		}
 
 		delay = get_longbusy_msecs(rc);
 		total_delay += delay;
@@ -335,66 +343,81 @@ long pSeries_enable_reloc_on_exc(void)
 			pr_warn("Warning: Giving up waiting to enable "
 				"relocation on exceptions (%u msec)!\n",
 				total_delay);
-			return rc;
+			return;
 		}
 
 		mdelay(delay);
 	}
 }
-EXPORT_SYMBOL(pSeries_enable_reloc_on_exc);
+EXPORT_SYMBOL(pseries_enable_reloc_on_exc);
 
-long pSeries_disable_reloc_on_exc(void)
+void pseries_disable_reloc_on_exc(void)
 {
 	long rc;
 
 	while (1) {
 		rc = disable_reloc_on_exceptions();
 		if (!H_IS_LONG_BUSY(rc))
-			return rc;
+			break;
 		mdelay(get_longbusy_msecs(rc));
 	}
+	if (rc != H_SUCCESS)
+		pr_warning("Warning: Failed to disable relocation on "
+			   "exceptions: %ld\n", rc);
 }
-EXPORT_SYMBOL(pSeries_disable_reloc_on_exc);
+EXPORT_SYMBOL(pseries_disable_reloc_on_exc);
 
 #ifdef CONFIG_KEXEC
 static void pSeries_machine_kexec(struct kimage *image)
 {
-	long rc;
-
-	if (firmware_has_feature(FW_FEATURE_SET_MODE)) {
-		rc = pSeries_disable_reloc_on_exc();
-		if (rc != H_SUCCESS)
-			pr_warning("Warning: Failed to disable relocation on "
-				   "exceptions: %ld\n", rc);
-	}
+	if (firmware_has_feature(FW_FEATURE_SET_MODE))
+		pseries_disable_reloc_on_exc();
 
 	default_machine_kexec(image);
 }
 #endif
 
 #ifdef __LITTLE_ENDIAN__
-long pseries_big_endian_exceptions(void)
+void pseries_big_endian_exceptions(void)
 {
 	long rc;
 
 	while (1) {
 		rc = enable_big_endian_exceptions();
 		if (!H_IS_LONG_BUSY(rc))
-			return rc;
+			break;
 		mdelay(get_longbusy_msecs(rc));
 	}
+
+	/*
+	 * At this point it is unlikely panic() will get anything
+	 * out to the user, since this is called very late in kexec
+	 * but at least this will stop us from continuing on further
+	 * and creating an even more difficult to debug situation.
+	 *
+	 * There is a known problem when kdump'ing, if cpus are offline
+	 * the above call will fail. Rather than panicking again, keep
+	 * going and hope the kdump kernel is also little endian, which
+	 * it usually is.
+	 */
+	if (rc && !kdump_in_progress())
+		panic("Could not enable big endian exceptions");
 }
 
-static long pseries_little_endian_exceptions(void)
+void pseries_little_endian_exceptions(void)
 {
 	long rc;
 
 	while (1) {
 		rc = enable_little_endian_exceptions();
 		if (!H_IS_LONG_BUSY(rc))
-			return rc;
+			break;
 		mdelay(get_longbusy_msecs(rc));
 	}
+	if (rc) {
+		ppc_md.progress("H_SET_MODE LE exception fail", 0);
+		panic("Could not enable little endian exceptions");
+	}
 }
 #endif
 
@@ -464,18 +487,6 @@ static void __init pSeries_setup_arch(void)
 	}
 
 	ppc_md.pcibios_root_bridge_prepare = pseries_root_bridge_prepare;
-
-	if (firmware_has_feature(FW_FEATURE_SET_MODE)) {
-		long rc;
-
-		rc = pSeries_enable_reloc_on_exc();
-		if (rc == H_P2) {
-			pr_info("Relocation on exceptions not supported\n");
-		} else if (rc != H_SUCCESS) {
-			pr_warn("Unable to enable relocation on exceptions: "
-				"%ld\n", rc);
-		}
-	}
 }
 
 static int __init pSeries_init_panel(void)
@@ -678,23 +689,6 @@ static int __init pSeries_probe(void)
 
 	pr_debug("pSeries detected, looking for LPAR capability...\n");
 
-
-#ifdef __LITTLE_ENDIAN__
-	if (firmware_has_feature(FW_FEATURE_SET_MODE)) {
-		long rc;
-		/*
-		 * Tell the hypervisor that we want our exceptions to
-		 * be taken in little endian mode. If this fails we don't
-		 * want to use BUG() because it will trigger an exception.
-		 */
-		rc = pseries_little_endian_exceptions();
-		if (rc) {
-			ppc_md.progress("H_SET_MODE LE exception fail", 0);
-			panic("Could not enable little endian exceptions");
-		}
-	}
-#endif
-
 	if (firmware_has_feature(FW_FEATURE_LPAR))
 		hpte_init_lpar();
 	else

commit 3808a88985b4f5f5e947c364debce4441a380fb8
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:03:48 2016 +1000

    powerpc: Move FW feature probing out of pseries probe()
    
    We move the function itself to pseries/firmware.c and call it along
    with almost all other flat device-tree parsers from early_init_devtree()
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    [mpe: Move #ifdefs into the header by providing pseries_probe_fw_features()]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e61e9b986e21..9cc9b88fce79 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -659,45 +659,6 @@ static void pseries_power_off(void)
 	for (;;);
 }
 
-/*
- * Called very early, MMU is off, device-tree isn't unflattened
- */
-
-static int __init pseries_probe_fw_features(unsigned long node,
-					    const char *uname, int depth,
-					    void *data)
-{
-	const char *prop;
-	int len;
-	static int hypertas_found;
-	static int vec5_found;
-
-	if (depth != 1)
-		return 0;
-
-	if (!strcmp(uname, "rtas") || !strcmp(uname, "rtas@0")) {
-		prop = of_get_flat_dt_prop(node, "ibm,hypertas-functions",
-					   &len);
-		if (prop) {
-			powerpc_firmware_features |= FW_FEATURE_LPAR;
-			fw_hypertas_feature_init(prop, len);
-		}
-
-		hypertas_found = 1;
-	}
-
-	if (!strcmp(uname, "chosen")) {
-		prop = of_get_flat_dt_prop(node, "ibm,architecture-vec-5",
-					   &len);
-		if (prop)
-			fw_vec5_feature_init(prop, len);
-
-		vec5_found = 1;
-	}
-
-	return hypertas_found && vec5_found;
-}
-
 static int __init pSeries_probe(void)
 {
 	unsigned long root = of_get_flat_dt_root();
@@ -717,8 +678,6 @@ static int __init pSeries_probe(void)
 
 	pr_debug("pSeries detected, looking for LPAR capability...\n");
 
-	/* Now try to figure out if we are running on LPAR */
-	of_scan_flat_dt(pseries_probe_fw_features, NULL);
 
 #ifdef __LITTLE_ENDIAN__
 	if (firmware_has_feature(FW_FEATURE_SET_MODE)) {

commit 8cc7581cdb84a232468c41bc417183a423dfbb07
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Fri May 20 16:41:37 2016 +1000

    powerpc/pci: Delay populating pdn
    
    The pdn (struct pci_dn) instances are allocated from memblock or
    bootmem when creating PCI controller (hoses) in setup_arch(). PCI
    hotplug, which will be supported by proceeding patches, releases
    PCI device nodes and their corresponding pdn on unplugging event.
    The memory chunks for pdn instances allocated from memblock or
    bootmem are hard to reused after being released.
    
    This delays creating pdn by pci_devs_phb_init() from setup_arch()
    to core_initcall() so that they are allocated from slab. The memory
    consumed by pdn can be released to system without problem during
    PCI unplugging time. It indicates that pci_dn is unavailable in
    setup_arch() and the the fixup on pdn (like AGP's) can't be carried
    out that time. We have to do that in pcibios_root_bridge_prepare()
    on maple/pasemi/powermac platforms where/when the pdn is available.
    pcibios_root_bridge_prepare is called from subsys_initcall() which
    is executed after core_initcall() so the code flow does not change.
    
    At the mean while, the EEH device is created when pdn is populated,
    meaning pdn and EEH device have same life cycle. In turn, we needn't
    call eeh_dev_init() to create EEH device explicitly.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 34668f9bc57b..e61e9b986e21 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -195,11 +195,8 @@ static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long act
 	case OF_RECONFIG_ATTACH_NODE:
 		parent = of_get_parent(np);
 		pdn = parent ? PCI_DN(parent) : NULL;
-		if (pdn) {
-			/* Create pdn and EEH device */
+		if (pdn)
 			pci_add_device_node_info(pdn->phb, np);
-			eeh_dev_init(PCI_DN(np), pdn->phb);
-		}
 
 		of_node_put(parent);
 		break;
@@ -422,7 +419,6 @@ static void __init find_and_init_phbs(void)
 	}
 
 	of_node_put(root);
-	pci_devs_phb_init();
 
 	/*
 	 * PCI_PROBE_ONLY and PCI_REASSIGN_ALL_BUS can be set via properties

commit d739d2caa3d3e283ca4d41716cd317684e066ef9
Author: Rashmica Gupta <rashmicy@gmail.com>
Date:   Mon May 30 16:18:13 2016 +1000

    powerpc/pseries: Remove MPIC from pseries kexec
    
    MPIC was only used by Power3 which is now unsupported, so remove MPIC
    code. XICS is now the only supported interrupt controller for
    pSeries so do some cleanups too.
    
    Signed-off-by: Rashmica Gupta <rashmicy@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 4b94a1e75bcf..34668f9bc57b 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -436,7 +436,6 @@ static void __init pSeries_setup_arch(void)
 	set_arch_panic_timeout(10, ARCH_PANIC_TIMEOUT);
 
 	/* Discover PIC type and setup ppc_md accordingly */
-	setup_kexec_cpu_down_xics();
 	smp_init_pseries();
 
 
@@ -786,6 +785,7 @@ define_machine(pseries) {
 	.machine_check_exception = pSeries_machine_check_exception,
 #ifdef CONFIG_KEXEC
 	.machine_kexec          = pSeries_machine_kexec,
+	.kexec_cpu_down         = pseries_kexec_cpu_down,
 #endif
 #ifdef CONFIG_MEMORY_HOTPLUG_SPARSE
 	.memory_block_size	= pseries_memory_block_size,

commit 86425bedd5b69ea5969ff11bb07c8e5ff7117976
Author: Rashmica Gupta <rashmicy@gmail.com>
Date:   Mon May 30 16:18:12 2016 +1000

    powerpc/pseries: Remove MPIC from pseries smp
    
    MPIC was only used by Power3 which is now unsupported, so remove MPIC
    code. XICS is now the only supported interrupt controller for
    pSeries so do some cleanups too.
    
    Signed-off-by: Rashmica Gupta <rashmicy@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 39f21fb3c609..4b94a1e75bcf 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -437,7 +437,7 @@ static void __init pSeries_setup_arch(void)
 
 	/* Discover PIC type and setup ppc_md accordingly */
 	setup_kexec_cpu_down_xics();
-	smp_init_pseries_xics();
+	smp_init_pseries();
 
 
 	/* openpic global configuration register (64-bit format). */

commit e7da5dac4e9067a526136db2f23cc8696a5d4649
Author: Rashmica Gupta <rashmicy@gmail.com>
Date:   Mon May 30 16:18:11 2016 +1000

    powerpc/pseries: Drop support for MPIC in pseries
    
    MPIC was only used by Power3 which is now unsupported, so drop support
    for MPIC. XICS is now the only supported interrupt controller for
    pSeries so make the XICS functions generic.
    
    Signed-off-by: Rashmica Gupta <rashmicy@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 9a79c2753a22..39f21fb3c609 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -57,7 +57,6 @@
 #include <asm/time.h>
 #include <asm/nvram.h>
 #include <asm/pmc.h>
-#include <asm/mpic.h>
 #include <asm/xics.h>
 #include <asm/ppc-pci.h>
 #include <asm/i8259.h>
@@ -77,8 +76,6 @@ EXPORT_SYMBOL(CMO_PageSize);
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 
-static struct device_node *pSeries_mpic_node;
-
 static void pSeries_show_cpuinfo(struct seq_file *m)
 {
 	struct device_node *root;
@@ -172,48 +169,7 @@ static void __init pseries_setup_i8259_cascade(void)
 	irq_set_chained_handler(cascade, pseries_8259_cascade);
 }
 
-static void __init pseries_mpic_init_IRQ(void)
-{
-	struct device_node *np;
-	const unsigned int *opprop;
-	unsigned long openpic_addr = 0;
-	int naddr, n, i, opplen;
-	struct mpic *mpic;
-
-	np = of_find_node_by_path("/");
-	naddr = of_n_addr_cells(np);
-	opprop = of_get_property(np, "platform-open-pic", &opplen);
-	if (opprop != NULL) {
-		openpic_addr = of_read_number(opprop, naddr);
-		printk(KERN_DEBUG "OpenPIC addr: %lx\n", openpic_addr);
-	}
-	of_node_put(np);
-
-	BUG_ON(openpic_addr == 0);
-
-	/* Setup the openpic driver */
-	mpic = mpic_alloc(pSeries_mpic_node, openpic_addr,
-			MPIC_NO_RESET, 16, 0, " MPIC     ");
-	BUG_ON(mpic == NULL);
-
-	/* Add ISUs */
-	opplen /= sizeof(u32);
-	for (n = 0, i = naddr; i < opplen; i += naddr, n++) {
-		unsigned long isuaddr = of_read_number(opprop + i, naddr);
-		mpic_assign_isu(mpic, n, isuaddr);
-	}
-
-	/* Setup top-level get_irq */
-	ppc_md.get_irq = mpic_get_irq;
-
-	/* All ISUs are setup, complete initialization */
-	mpic_init(mpic);
-
-	/* Look for cascade */
-	pseries_setup_i8259_cascade();
-}
-
-static void __init pseries_xics_init_IRQ(void)
+static void __init pseries_init_irq(void)
 {
 	xics_init();
 	pseries_setup_i8259_cascade();
@@ -228,32 +184,6 @@ static void pseries_lpar_enable_pmcs(void)
 	plpar_hcall_norets(H_PERFMON, set, reset);
 }
 
-static void __init pseries_discover_pic(void)
-{
-	struct device_node *np;
-	const char *typep;
-
-	for_each_node_by_name(np, "interrupt-controller") {
-		typep = of_get_property(np, "compatible", NULL);
-		if (!typep)
-			continue;
-		if (strstr(typep, "open-pic")) {
-			pSeries_mpic_node = of_node_get(np);
-			ppc_md.init_IRQ       = pseries_mpic_init_IRQ;
-			setup_kexec_cpu_down_mpic();
-			smp_init_pseries_mpic();
-			return;
-		} else if (strstr(typep, "ppc-xicp")) {
-			ppc_md.init_IRQ       = pseries_xics_init_IRQ;
-			setup_kexec_cpu_down_xics();
-			smp_init_pseries_xics();
-			return;
-		}
-	}
-	printk(KERN_ERR "pSeries_discover_pic: failed to recognize"
-	       " interrupt-controller\n");
-}
-
 static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long action, void *data)
 {
 	struct of_reconfig_data *rd = data;
@@ -506,7 +436,9 @@ static void __init pSeries_setup_arch(void)
 	set_arch_panic_timeout(10, ARCH_PANIC_TIMEOUT);
 
 	/* Discover PIC type and setup ppc_md accordingly */
-	pseries_discover_pic();
+	setup_kexec_cpu_down_xics();
+	smp_init_pseries_xics();
+
 
 	/* openpic global configuration register (64-bit format). */
 	/* openpic Interrupt Source Unit pointer (64-bit format). */
@@ -838,6 +770,7 @@ define_machine(pseries) {
 	.probe			= pSeries_probe,
 	.setup_arch		= pSeries_setup_arch,
 	.init_early		= pSeries_init_early,
+	.init_IRQ		= pseries_init_irq,
 	.show_cpuinfo		= pSeries_show_cpuinfo,
 	.log_error		= pSeries_log_error,
 	.pcibios_fixup		= pSeries_final_fixup,

commit 027dfac694fc27ef0273afb810d9b1f9da57d6e1
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Wed Jun 1 16:34:37 2016 +1000

    powerpc: Various typo fixes
    
    Signed-off-by: Andrea Gelmini <andrea.gelmini@gelma.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 9883bc7ea007..9a79c2753a22 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -367,7 +367,7 @@ static void pseries_lpar_idle(void)
 {
 	/*
 	 * Default handler to go into low thread priority and possibly
-	 * low power mode by cedeing processor to hypervisor
+	 * low power mode by ceding processor to hypervisor
 	 */
 
 	/* Indicate to hypervisor that we are idle. */

commit d8f66f411e2dc1c27413f0ba73f49bccfa998f1b
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue May 3 15:41:40 2016 +1000

    powerpc/pci: Export pci_add_device_node_info()
    
    This renames update_dn_pci_info() to pci_add_device_node_info()
    with corresponding adjustment on the parameter type and exports it.
    The function is used to create pdn (struct pci_dn) for the indicated
    device node. Another function add_pdn(), almost wrapper of
    pci_add_device_node_info(), to be used in traverse_pci_devices(). No
    logical changes introduced.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index fa734943bcbc..9883bc7ea007 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -267,7 +267,7 @@ static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long act
 		pdn = parent ? PCI_DN(parent) : NULL;
 		if (pdn) {
 			/* Create pdn and EEH device */
-			update_dn_pci_info(np, pdn->phb);
+			pci_add_device_node_info(pdn->phb, np);
 			eeh_dev_init(PCI_DN(np), pdn->phb);
 		}
 

commit b2ed059642875a699a195cb136b2e57e7e07cedf
Author: Suraj Jitindar Singh <sjitindarsingh@gmail.com>
Date:   Thu Apr 28 15:53:45 2016 +1000

    powerpc/pseries: Add null property check to pseries_discover_pic()
    
    The return value of of_get_property() isn't checked before it is passed
    to the strstr() function, if it happens that the return value is null
    then this will result in a null pointer being dereferenced.
    
    Add a check to see if the return value of of_get_property() is null and
    if it is continue straight on to the next node.
    
    Signed-off-by: Suraj Jitindar Singh <sjitindarsingh@gmail.com>
    Reviewed-by: Chris Smart <chris@distroguy.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 6e944fc6e5f9..fa734943bcbc 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -235,6 +235,8 @@ static void __init pseries_discover_pic(void)
 
 	for_each_node_by_name(np, "interrupt-controller") {
 		typep = of_get_property(np, "compatible", NULL);
+		if (!typep)
+			continue;
 		if (strstr(typep, "open-pic")) {
 			pSeries_mpic_node = of_node_get(np);
 			ppc_md.init_IRQ       = pseries_mpic_init_IRQ;

commit 446957ba5127141ee007fc61509e24a9e60853d9
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Wed Feb 24 10:51:11 2016 -0800

    powerpc: Fix misspellings in comments.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 36df46eaba24..6e944fc6e5f9 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -515,7 +515,7 @@ static void __init pSeries_setup_arch(void)
 
 	fwnmi_init();
 
-	/* By default, only probe PCI (can be overriden by rtas_pci) */
+	/* By default, only probe PCI (can be overridden by rtas_pci) */
 	pci_add_flags(PCI_PROBE_ONLY);
 
 	/* Find and initialize PCI host bridges */

commit 3c87b791880a2e0dad281c6494b94968d412bfa3
Merge: 0280d1a099da 7225107e1582
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Nov 6 11:29:53 2015 -0800

    Merge tag 'pci-v4.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "Resource management:
       - Add support for Enhanced Allocation devices (Sean O. Stalley)
       - Add Enhanced Allocation register entries (Sean O. Stalley)
       - Handle IORESOURCE_PCI_FIXED when sizing resources (David Daney)
       - Handle IORESOURCE_PCI_FIXED when assigning resources (David Daney)
       - Handle Enhanced Allocation capability for SR-IOV devices (David Daney)
       - Clear IORESOURCE_UNSET when reverting to firmware-assigned address (Bjorn Helgaas)
       - Make Enhanced Allocation bitmasks more obvious (Bjorn Helgaas)
       - Expand Enhanced Allocation BAR output (Bjorn Helgaas)
       - Add of_pci_check_probe_only to parse "linux,pci-probe-only" (Marc Zyngier)
       - Fix lookup of linux,pci-probe-only property (Marc Zyngier)
       - Add sparc mem64 resource parsing for root bus (Yinghai Lu)
    
      PCI device hotplug:
       - pciehp: Queue power work requests in dedicated function (Guenter Roeck)
    
      Driver binding:
       - Add builtin_pci_driver() to avoid registration boilerplate (Paul Gortmaker)
    
      Virtualization:
       - Set SR-IOV NumVFs to zero after enumeration (Alexander Duyck)
       - Remove redundant validation of SR-IOV offset/stride registers (Alexander Duyck)
       - Remove VFs in reverse order if virtfn_add() fails (Alexander Duyck)
       - Reorder pcibios_sriov_disable() (Alexander Duyck)
       - Wait 1 second between disabling VFs and clearing NumVFs (Alexander Duyck)
       - Fix sriov_enable() error path for pcibios_enable_sriov() failures (Alexander Duyck)
       - Enable SR-IOV ARI Capable Hierarchy before reading TotalVFs (Ben Shelton)
       - Don't try to restore VF BARs (Wei Yang)
    
      MSI:
       - Don't alloc pcibios-irq when MSI is enabled (Joerg Roedel)
       - Add msi_controller setup_irqs() method for special multivector setup (Lucas Stach)
       - Export all remapped MSIs to sysfs attributes (Romain Bezut)
       - Disable MSI on SiS 761 (Ondrej Zary)
    
      AER:
       - Clear error status registers during enumeration and restore (Taku Izumi)
    
      Generic host bridge driver:
       - Fix lookup of linux,pci-probe-only property (Marc Zyngier)
       - Allow multiple hosts with different map_bus() methods (David Daney)
       - Pass starting bus number to pci_scan_root_bus() (David Daney)
       - Fix address window calculation for non-zero starting bus (David Daney)
    
      Altera host bridge driver:
       - Add msi.h to ARM Kbuild (Ley Foon Tan)
       - Add Altera PCIe host controller driver (Ley Foon Tan)
       - Add Altera PCIe MSI driver (Ley Foon Tan)
    
      APM X-Gene host bridge driver:
       - Remove msi_controller assignment (Duc Dang)
    
      Broadcom iProc host bridge driver:
       - Fix header comment "Corporation" misspelling (Florian Fainelli)
       - Fix code comment to match code (Ray Jui)
       - Remove unused struct iproc_pcie.irqs[] (Ray Jui)
       - Call pci_fixup_irqs() for ARM64 as well as ARM (Ray Jui)
       - Fix PCIe reset logic (Ray Jui)
       - Improve link detection logic (Ray Jui)
       - Update PCIe device tree bindings (Ray Jui)
       - Add outbound mapping support (Ray Jui)
    
      Freescale i.MX6 host bridge driver:
       - Return real error code from imx6_add_pcie_port() (Fabio Estevam)
       - Add PCIE_PHY_RX_ASIC_OUT_VALID definition (Fabio Estevam)
    
      Freescale Layerscape host bridge driver:
       - Remove ls_pcie_establish_link() (Minghuan Lian)
       - Ignore PCIe controllers in Endpoint mode (Minghuan Lian)
       - Factor out SCFG related function (Minghuan Lian)
       - Update ls_add_pcie_port() (Minghuan Lian)
       - Remove unused fields from struct ls_pcie (Minghuan Lian)
       - Add support for LS1043a and LS2080a (Minghuan Lian)
       - Add ls_pcie_msi_host_init() (Minghuan Lian)
    
      HiSilicon host bridge driver:
       - Add HiSilicon SoC Hip05 PCIe driver (Zhou Wang)
    
      Marvell MVEBU host bridge driver:
       - Return zero for reserved or unimplemented config space (Russell King)
       - Use exact config access size; don't read/modify/write (Russell King)
       - Use of_get_available_child_count() (Russell King)
       - Use for_each_available_child_of_node() to walk child nodes (Russell King)
       - Report full node name when reporting a DT error (Russell King)
       - Use port->name rather than "PCIe%d.%d" (Russell King)
       - Move port parsing and resource claiming to  separate function (Russell King)
       - Fix memory leaks and refcount leaks (Russell King)
       - Split port parsing and resource claiming from  port setup (Russell King)
       - Use gpio_set_value_cansleep() (Russell King)
       - Use devm_kcalloc() to allocate an array (Russell King)
       - Use gpio_desc to carry around gpio (Russell King)
       - Improve clock/reset handling (Russell King)
       - Add PCI Express root complex capability block (Russell King)
       - Remove code restricting accesses to slot 0 (Russell King)
    
      NVIDIA Tegra host bridge driver:
       - Wrap static pgprot_t initializer with __pgprot() (Ard Biesheuvel)
    
      Renesas R-Car host bridge driver:
       - Build pci-rcar-gen2.c only on ARM (Geert Uytterhoeven)
       - Build pcie-rcar.c only on ARM (Geert Uytterhoeven)
       - Make PCI aware of the I/O resources (Phil Edworthy)
       - Remove dependency on ARM-specific struct hw_pci (Phil Edworthy)
       - Set root bus nr to that provided in DT (Phil Edworthy)
       - Fix I/O offset for multiple host bridges (Phil Edworthy)
    
      ST Microelectronics SPEAr13xx host bridge driver:
       - Fix dw_pcie_cfg_read/write() usage (Gabriele Paoloni)
    
      Synopsys DesignWare host bridge driver:
       - Make "clocks" and "clock-names" optional DT properties (Bhupesh Sharma)
       - Use exact access size in dw_pcie_cfg_read() (Gabriele Paoloni)
       - Simplify dw_pcie_cfg_read/write() interfaces (Gabriele Paoloni)
       - Require config accesses to be naturally aligned (Gabriele Paoloni)
       - Make "num-lanes" an optional DT property (Gabriele Paoloni)
       - Move calculation of bus addresses to DRA7xx (Gabriele Paoloni)
       - Replace ARM pci_sys_data->align_resource with global function pointer (Gabriele Paoloni)
       - Factor out MSI msg setup (Lucas Stach)
       - Implement multivector MSI IRQ setup (Lucas Stach)
       - Make get_msi_addr() return phys_addr_t, not u32 (Lucas Stach)
       - Set up high part of MSI target address (Lucas Stach)
       - Fix PORT_LOGIC_LINK_WIDTH_MASK (Zhou Wang)
       - Revert "PCI: designware: Program ATU with untranslated address" (Zhou Wang)
       - Use of_pci_get_host_bridge_resources() to parse DT (Zhou Wang)
       - Make driver arch-agnostic (Zhou Wang)
    
      Miscellaneous:
       - Make x86 pci_subsys_init() static (Alexander Kuleshov)
       - Turn off Request Attributes to avoid Chelsio T5 Completion erratum (Hariprasad Shenai)"
    
    * tag 'pci-v4.4-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (94 commits)
      PCI: altera: Add Altera PCIe MSI driver
      PCI: hisi: Add HiSilicon SoC Hip05 PCIe driver
      PCI: layerscape: Add ls_pcie_msi_host_init()
      PCI: layerscape: Add support for LS1043a and LS2080a
      PCI: layerscape: Remove unused fields from struct ls_pcie
      PCI: layerscape: Update ls_add_pcie_port()
      PCI: layerscape: Factor out SCFG related function
      PCI: layerscape: Ignore PCIe controllers in Endpoint mode
      PCI: layerscape: Remove ls_pcie_establish_link()
      PCI: designware: Make "clocks" and "clock-names" optional DT properties
      PCI: designware: Make driver arch-agnostic
      ARM/PCI: Replace pci_sys_data->align_resource with global function pointer
      PCI: designware: Use of_pci_get_host_bridge_resources() to parse DT
      Revert "PCI: designware: Program ATU with untranslated address"
      PCI: designware: Move calculation of bus addresses to DRA7xx
      PCI: designware: Make "num-lanes" an optional DT property
      PCI: designware: Require config accesses to be naturally aligned
      PCI: designware: Simplify dw_pcie_cfg_read/write() interfaces
      PCI: designware: Use exact access size in dw_pcie_cfg_read()
      PCI: spear: Fix dw_pcie_cfg_read/write() usage
      ...

commit 84eb9e612b022c8357980bbdba653d9626be2be8
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Thu Oct 1 16:44:32 2015 +1000

    powerpc/pseries: Remove use of CONFIG_PCI
    
    Now that we always have CONFIG_PCI=y for pseries, we can stop guarding
    code with CONFIG_PCI ifdefs.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 9a83eb71b030..9e524c26db14 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -837,10 +837,6 @@ static int pSeries_pci_probe_mode(struct pci_bus *bus)
 	return PCI_PROBE_NORMAL;
 }
 
-#ifndef CONFIG_PCI
-void pSeries_final_fixup(void) { }
-#endif
-
 struct pci_controller_ops pseries_pci_controller_ops = {
 	.probe_mode		= pSeries_pci_probe_mode,
 };

commit 705a7b474ed929a8c86733ad230dd9c820e84a7b
Author: Marc Zyngier <marc.zyngier@arm.com>
Date:   Fri Sep 4 17:50:10 2015 +0100

    powerpc/PCI: Fix lookup of linux,pci-probe-only property
    
    When find_and_init_phbs() looks for the probe-only property, it seems to
    trust the firmware to be correctly written, and assumes that there is a
    parameter to the property.
    
    It is conceivable that the firmware could not be that perfect, and it could
    expose this property naked (at least one arm64 platform seems to exhibit
    this exact behaviour).  The setup code the ends up making a decision based
    on whatever the property pointer points to, which is likely to be junk.
    
    Instead, switch to the common of_pci.c implementation that doesn't suffer
    from this problem and ignore the property if the firmware couldn't make up
    its mind.
    
    Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Rob Herring <robh@kernel.org>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 39a74fad3e04..60167096fd10 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -40,6 +40,7 @@
 #include <linux/seq_file.h>
 #include <linux/root_dev.h>
 #include <linux/of.h>
+#include <linux/of_pci.h>
 #include <linux/kexec.h>
 
 #include <asm/mmu.h>
@@ -495,18 +496,7 @@ static void __init find_and_init_phbs(void)
 	 * PCI_PROBE_ONLY and PCI_REASSIGN_ALL_BUS can be set via properties
 	 * in chosen.
 	 */
-	if (of_chosen) {
-		const int *prop;
-
-		prop = of_get_property(of_chosen,
-				"linux,pci-probe-only", NULL);
-		if (prop) {
-			if (*prop)
-				pci_add_flags(PCI_PROBE_ONLY);
-			else
-				pci_clear_flags(PCI_PROBE_ONLY);
-		}
-	}
+	of_pci_check_probe_only();
 }
 
 static void __init pSeries_setup_arch(void)

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 39a74fad3e04..9a83eb71b030 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -111,7 +111,7 @@ static void __init fwnmi_init(void)
 		fwnmi_active = 1;
 }
 
-static void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc)
+static void pseries_8259_cascade(struct irq_desc *desc)
 {
 	struct irq_chip *chip = irq_desc_get_chip(desc);
 	unsigned int cascade_irq = i8259_irq();

commit ea0f8acf4d44727f7d3a38072566029bf5e17b44
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Thu Aug 27 14:12:37 2015 +1000

    powerpc/pseries: Cleanup on pci_dn_reconfig_notifier()
    
    This applies cleanup on pci_dn_reconfig_notifier(), no functional
    changes:
    
       * Rename variable "pci" to "pdn" to indicate its purpose clearly.
       * The parent node can be released at any time. So it should be
         hold with of_get_parent() before accessing it.
       * The device node doesn't have to have parent node in theory.
         More check on this.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e6e8b241d717..39a74fad3e04 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -254,24 +254,26 @@ static void __init pseries_discover_pic(void)
 static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long action, void *data)
 {
 	struct of_reconfig_data *rd = data;
-	struct device_node *np = rd->dn;
-	struct pci_dn *pci = NULL;
+	struct device_node *parent, *np = rd->dn;
+	struct pci_dn *pdn;
 	int err = NOTIFY_OK;
 
 	switch (action) {
 	case OF_RECONFIG_ATTACH_NODE:
-		pci = np->parent->data;
-		if (pci) {
-			update_dn_pci_info(np, pci->phb);
-
-			/* Create EEH device for the OF node */
-			eeh_dev_init(PCI_DN(np), pci->phb);
+		parent = of_get_parent(np);
+		pdn = parent ? PCI_DN(parent) : NULL;
+		if (pdn) {
+			/* Create pdn and EEH device */
+			update_dn_pci_info(np, pdn->phb);
+			eeh_dev_init(PCI_DN(np), pdn->phb);
 		}
+
+		of_node_put(parent);
 		break;
 	case OF_RECONFIG_DETACH_NODE:
-		pci = PCI_DN(np);
-		if (pci)
-			list_del(&pci->list);
+		pdn = PCI_DN(np);
+		if (pdn)
+			list_del(&pdn->list);
 		break;
 	default:
 		err = NOTIFY_DONE;

commit 590c7567a2895f939525ead57b0334c6d47986f0
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Thu Aug 27 14:12:36 2015 +1000

    powerpc/pseries: Fix corrupted pdn list
    
    Commit cca87d30 ("powerpc/pci: Refactor pci_dn") introduced pdn
    list for SRIOV VFs. It means the pdn is be put into the child list
    of its parent pdn when the pdn is created. When doing PCI hot
    unplugging on pSeries, the PCI device node as well as its pdn are
    released through procfs entry "powerpc/ofdt". Some one else grabs
    the memory chunk of the pdn and update it accordingly. At the same
    time, the pdn is still tracked in the child list of parent pdn. It
    leads to corrupted child list in the parent pdn.
    
    This fixes above issue by removing the pdn from the child list of
    its parent pdn when the device node is detached from the system.
    Note the pdn is free'd when the device node is released if the
    device node is dynamic one. Otherwise, the device node as well
    as the pdn won't be released.
    
    Fixes: cca87d30 ("powerpc/pci: Refactor pci_dn")
    Cc: stable@vger.kernel.org # 4.1+
    Reported-by: Santwana Samantray <santwana.samantray@in.ibm.com>
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index df6a7041922b..e6e8b241d717 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -268,6 +268,11 @@ static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long act
 			eeh_dev_init(PCI_DN(np), pci->phb);
 		}
 		break;
+	case OF_RECONFIG_DETACH_NODE:
+		pci = PCI_DN(np);
+		if (pci)
+			list_del(&pci->list);
+		break;
 	default:
 		err = NOTIFY_DONE;
 		break;

commit ff7a2adac50873aaba71759779505693806adcc1
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Apr 14 10:16:47 2015 +1000

    powerpc: Remove PPC32 code from pseries specific find_and_init_phbs()
    
    In bdc728a849a7 ("powerpc: move find_and_init_phbs() to pSeries
    specific code"), find_and_init_phbs() was moved into a pseries
    specific file, but PPC32 code wasn't removed. Remove it.
    
    See https://lkml.kernel.org/r/552C0AA6.4010403@fau.de
    
    Reported-by: Andreas Ruprecht <andreas.ruprecht@fau.de>
    Fixes: bdc728a849a7
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 1044b8b4da71..df6a7041922b 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -499,13 +499,6 @@ static void __init find_and_init_phbs(void)
 			else
 				pci_clear_flags(PCI_PROBE_ONLY);
 		}
-
-#ifdef CONFIG_PPC32 /* Will be made generic soon */
-		prop = of_get_property(of_chosen,
-				"linux,pci-assign-all-buses", NULL);
-		if (prop && *prop)
-			pci_add_flags(PCI_REASSIGN_ALL_BUS);
-#endif /* CONFIG_PPC32 */
 	}
 }
 

commit 38ae9ec40f06f3aef5c25314f432113cf2c1340a
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Mar 31 16:00:50 2015 +1100

    powerpc/pseries: Move controller ops from ppc_md to controller_ops
    
    This moves the pSeries platform to use the pci_controller_ops structure,
    rather than ppc_md for PCI controller operations.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index bcc6d24c77aa..1044b8b4da71 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -478,6 +478,7 @@ static void __init find_and_init_phbs(void)
 		rtas_setup_phb(phb);
 		pci_process_bridge_OF_ranges(phb, node, 0);
 		isa_bridge_find_early(phb);
+		phb->controller_ops = pseries_pci_controller_ops;
 	}
 
 	of_node_put(root);
@@ -840,6 +841,10 @@ static int pSeries_pci_probe_mode(struct pci_bus *bus)
 void pSeries_final_fixup(void) { }
 #endif
 
+struct pci_controller_ops pseries_pci_controller_ops = {
+	.probe_mode		= pSeries_pci_probe_mode,
+};
+
 define_machine(pseries) {
 	.name			= "pSeries",
 	.probe			= pSeries_probe,
@@ -848,7 +853,6 @@ define_machine(pseries) {
 	.show_cpuinfo		= pSeries_show_cpuinfo,
 	.log_error		= pSeries_log_error,
 	.pcibios_fixup		= pSeries_final_fixup,
-	.pci_probe_mode		= pSeries_pci_probe_mode,
 	.restart		= rtas_restart,
 	.halt			= rtas_halt,
 	.panic			= rtas_os_term,

commit bdc728a849a7047e55014c6f968aa300cc9f57fa
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Mar 31 16:00:39 2015 +1100

    powerpc: move find_and_init_phbs() to pSeries specific code
    
    Previously, find_and_init_phbs() was used in both PowerNV and pSeries
    setup. However, since RTAS support has been dropped from PowerNV, we
    can move it into a platform-specific file.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 70304070a260..bcc6d24c77aa 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -461,6 +461,53 @@ static long pseries_little_endian_exceptions(void)
 }
 #endif
 
+static void __init find_and_init_phbs(void)
+{
+	struct device_node *node;
+	struct pci_controller *phb;
+	struct device_node *root = of_find_node_by_path("/");
+
+	for_each_child_of_node(root, node) {
+		if (node->type == NULL || (strcmp(node->type, "pci") != 0 &&
+					   strcmp(node->type, "pciex") != 0))
+			continue;
+
+		phb = pcibios_alloc_controller(node);
+		if (!phb)
+			continue;
+		rtas_setup_phb(phb);
+		pci_process_bridge_OF_ranges(phb, node, 0);
+		isa_bridge_find_early(phb);
+	}
+
+	of_node_put(root);
+	pci_devs_phb_init();
+
+	/*
+	 * PCI_PROBE_ONLY and PCI_REASSIGN_ALL_BUS can be set via properties
+	 * in chosen.
+	 */
+	if (of_chosen) {
+		const int *prop;
+
+		prop = of_get_property(of_chosen,
+				"linux,pci-probe-only", NULL);
+		if (prop) {
+			if (*prop)
+				pci_add_flags(PCI_PROBE_ONLY);
+			else
+				pci_clear_flags(PCI_PROBE_ONLY);
+		}
+
+#ifdef CONFIG_PPC32 /* Will be made generic soon */
+		prop = of_get_property(of_chosen,
+				"linux,pci-assign-all-buses", NULL);
+		if (prop && *prop)
+			pci_add_flags(PCI_REASSIGN_ALL_BUS);
+#endif /* CONFIG_PPC32 */
+	}
+}
+
 static void __init pSeries_setup_arch(void)
 {
 	set_arch_panic_timeout(10, ARCH_PANIC_TIMEOUT);

commit e8e9b34cef237d4d6fdc0d350cd8a95d1adb9ee9
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue Mar 17 16:15:05 2015 +1100

    powerpc/eeh: Create eeh_dev from pci_dn instead of device_node
    
    The patch adds function traverse_pci_dn(), which is similar to
    traverse_pci_devices() except it takes pci_dn, not device_node
    as parameter. The pci_dev.c has been reworked to create eeh_dev
    from pci_dn, instead of device_node.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e445b6701f50..70304070a260 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -265,7 +265,7 @@ static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long act
 			update_dn_pci_info(np, pci->phb);
 
 			/* Create EEH device for the OF node */
-			eeh_dev_init(np, pci->phb);
+			eeh_dev_init(PCI_DN(np), pci->phb);
 		}
 		break;
 	default:

commit 140cd7fb04a4a2bc09a30980bc8104cc89e09330
Merge: 27afc5dbda52 56548fc0e86c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 11 17:48:14 2014 -0800

    Merge tag 'powerpc-3.19-1' of git://git.kernel.org/pub/scm/linux/kernel/git/mpe/linux
    
    Pull powerpc updates from Michael Ellerman:
     "Some nice cleanups like removing bootmem, and removal of
      __get_cpu_var().
    
      There is one patch to mm/gup.c.  This is the generic GUP
      implementation, but is only used by us and arm(64).  We have an ack
      from Steve Capper, and although we didn't get an ack from Andrew he
      told us to take the patch through the powerpc tree.
    
      There's one cxl patch.  This is in drivers/misc, but Greg said he was
      happy for us to manage fixes for it.
    
      There is an infrastructure patch to support an IPMI driver for OPAL.
    
      There is also an RTC driver for OPAL.  We weren't able to get any
      response from the RTC maintainer, Alessandro Zummo, so in the end we
      just merged the driver.
    
      The usual batch of Freescale updates from Scott"
    
    * tag 'powerpc-3.19-1' of git://git.kernel.org/pub/scm/linux/kernel/git/mpe/linux: (101 commits)
      powerpc/powernv: Return to cpu offline loop when finished in KVM guest
      powerpc/book3s: Fix partial invalidation of TLBs in MCE code.
      powerpc/mm: don't do tlbie for updatepp request with NO HPTE fault
      powerpc/xmon: Cleanup the breakpoint flags
      powerpc/xmon: Enable HW instruction breakpoint on POWER8
      powerpc/mm/thp: Use tlbiel if possible
      powerpc/mm/thp: Remove code duplication
      powerpc/mm/hugetlb: Sanity check gigantic hugepage count
      powerpc/oprofile: Disable pagefaults during user stack read
      powerpc/mm: Check for matching hpte without taking hpte lock
      powerpc: Drop useless warning in eeh_init()
      powerpc/powernv: Cleanup unused MCE definitions/declarations.
      powerpc/eeh: Dump PHB diag-data early
      powerpc/eeh: Recover EEH error on ownership change for BCM5719
      powerpc/eeh: Set EEH_PE_RESET on PE reset
      powerpc/eeh: Refactor eeh_reset_pe()
      powerpc: Remove more traces of bootmem
      powerpc/pseries: Initialise nvram_pstore_info's buf_lock
      cxl: Name interrupts in /proc/interrupt
      cxl: Return error to PSL if IRQ demultiplexing fails & print clearer warning
      ...

commit f5242e5a883bf1c1aba6bfd87b85e7dda0e62191
Author: Grant Likely <grant.likely@linaro.org>
Date:   Mon Nov 24 17:58:01 2014 +0000

    of/reconfig: Always use the same structure for notifiers
    
    The OF_RECONFIG notifier callback uses a different structure depending
    on whether it is a node change or a property change. This is silly, and
    not very safe. Rework the code to use the same data structure regardless
    of the type of notifier.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Pantelis Antoniou <pantelis.antoniou@konsulko.com>
    Cc: <linuxppc-dev@lists.ozlabs.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 125c589eeef5..ed8a90022a3d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -251,9 +251,10 @@ static void __init pseries_discover_pic(void)
 	       " interrupt-controller\n");
 }
 
-static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long action, void *node)
+static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long action, void *data)
 {
-	struct device_node *np = node;
+	struct of_reconfig_data *rd = data;
+	struct device_node *np = rd->dn;
 	struct pci_dn *pci = NULL;
 	int err = NOTIFY_OK;
 

commit 20f1aae6cb0120fa54c0fe81614f6983df3b420a
Author: Anton Blanchard <anton@samba.org>
Date:   Mon Nov 3 08:34:01 2014 +1100

    powerpc/pseries: Quieten relocation on exceptions warning
    
    The H_SET_MODE hcall returns H_P2 if a function is not implemented
    and all callers should handle this case.
    
    The call to enable relocation on exceptions currently prints an error
    message if the feature is not implemented. While H_SET_MODE was
    first introduced on POWER8 (which has relocation on exceptions), it
    has been now added on some POWER7 configurations (which does not).
    
    Check for H_P2 and print an informational message instead.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index db0fc0c07568..8b8fb19a4097 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -499,7 +499,11 @@ static void __init pSeries_setup_arch(void)
 
 	if (firmware_has_feature(FW_FEATURE_SET_MODE)) {
 		long rc;
-		if ((rc = pSeries_enable_reloc_on_exc()) != H_SUCCESS) {
+
+		rc = pSeries_enable_reloc_on_exc();
+		if (rc == H_P2) {
+			pr_info("Relocation on exceptions not supported\n");
+		} else if (rc != H_SUCCESS) {
 			pr_warn("Unable to enable relocation on exceptions: "
 				"%ld\n", rc);
 		}

commit 9178ba294b6839eeff1a91bed95515d783f3ee6c
Author: Alexander Graf <agraf@suse.de>
Date:   Mon Oct 13 16:01:09 2014 +0200

    powerpc: Convert power off logic to pm_power_off
    
    The generic Linux framework to power off the machine is a function pointer
    called pm_power_off. The trick about this pointer is that device drivers can
    potentially implement it rather than board files.
    
    Today on powerpc we set pm_power_off to invoke our generic full machine power
    off logic which then calls ppc_md.power_off to invoke machine specific power
    off.
    
    However, when we want to add a power off GPIO via the "gpio-poweroff" driver,
    this card house falls apart. That driver only registers itself if pm_power_off
    is NULL to ensure it doesn't override board specific logic. However, since we
    always set pm_power_off to the generic power off logic (which will just not
    power off the machine if no ppc_md.power_off call is implemented), we can't
    implement power off via the generic GPIO power off driver.
    
    To fix this up, let's get rid of the ppc_md.power_off logic and just always use
    pm_power_off as was intended. Then individual drivers such as the GPIO power off
    driver can implement power off logic via that function pointer.
    
    With this patch set applied and a few patches on top of QEMU that implement a
    power off GPIO on the virt e500 machine, I can successfully turn off my virtual
    machine after halt.
    
    Signed-off-by: Alexander Graf <agraf@suse.de>
    [mpe: Squash into one patch and update changelog based on cover letter]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 125c589eeef5..db0fc0c07568 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -659,6 +659,34 @@ static void __init pSeries_init_early(void)
 	pr_debug(" <- pSeries_init_early()\n");
 }
 
+/**
+ * pseries_power_off - tell firmware about how to power off the system.
+ *
+ * This function calls either the power-off rtas token in normal cases
+ * or the ibm,power-off-ups token (if present & requested) in case of
+ * a power failure. If power-off token is used, power on will only be
+ * possible with power button press. If ibm,power-off-ups token is used
+ * it will allow auto poweron after power is restored.
+ */
+static void pseries_power_off(void)
+{
+	int rc;
+	int rtas_poweroff_ups_token = rtas_token("ibm,power-off-ups");
+
+	if (rtas_flash_term_hook)
+		rtas_flash_term_hook(SYS_POWER_OFF);
+
+	if (rtas_poweron_auto == 0 ||
+		rtas_poweroff_ups_token == RTAS_UNKNOWN_SERVICE) {
+		rc = rtas_call(rtas_token("power-off"), 2, 1, NULL, -1, -1);
+		printk(KERN_INFO "RTAS power-off returned %d\n", rc);
+	} else {
+		rc = rtas_call(rtas_poweroff_ups_token, 0, 1, NULL);
+		printk(KERN_INFO "RTAS ibm,power-off-ups returned %d\n", rc);
+	}
+	for (;;);
+}
+
 /*
  * Called very early, MMU is off, device-tree isn't unflattened
  */
@@ -741,6 +769,8 @@ static int __init pSeries_probe(void)
 	else
 		hpte_init_native();
 
+	pm_power_off = pseries_power_off;
+
 	pr_debug("Machine is%s LPAR !\n",
 	         (powerpc_firmware_features & FW_FEATURE_LPAR) ? "" : " not");
 
@@ -754,34 +784,6 @@ static int pSeries_pci_probe_mode(struct pci_bus *bus)
 	return PCI_PROBE_NORMAL;
 }
 
-/**
- * pSeries_power_off - tell firmware about how to power off the system.
- *
- * This function calls either the power-off rtas token in normal cases
- * or the ibm,power-off-ups token (if present & requested) in case of
- * a power failure. If power-off token is used, power on will only be
- * possible with power button press. If ibm,power-off-ups token is used
- * it will allow auto poweron after power is restored.
- */
-static void pSeries_power_off(void)
-{
-	int rc;
-	int rtas_poweroff_ups_token = rtas_token("ibm,power-off-ups");
-
-	if (rtas_flash_term_hook)
-		rtas_flash_term_hook(SYS_POWER_OFF);
-
-	if (rtas_poweron_auto == 0 ||
-		rtas_poweroff_ups_token == RTAS_UNKNOWN_SERVICE) {
-		rc = rtas_call(rtas_token("power-off"), 2, 1, NULL, -1, -1);
-		printk(KERN_INFO "RTAS power-off returned %d\n", rc);
-	} else {
-		rc = rtas_call(rtas_poweroff_ups_token, 0, 1, NULL);
-		printk(KERN_INFO "RTAS ibm,power-off-ups returned %d\n", rc);
-	}
-	for (;;);
-}
-
 #ifndef CONFIG_PCI
 void pSeries_final_fixup(void) { }
 #endif
@@ -796,7 +798,6 @@ define_machine(pseries) {
 	.pcibios_fixup		= pSeries_final_fixup,
 	.pci_probe_mode		= pSeries_pci_probe_mode,
 	.restart		= rtas_restart,
-	.power_off		= pSeries_power_off,
 	.halt			= rtas_halt,
 	.panic			= rtas_os_term,
 	.get_boot_time		= rtas_get_boot_time,

commit e51df2c170efaeadce4d416e1825b0830de0a795
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Aug 20 08:55:18 2014 +1000

    powerpc: Make a bunch of things static
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e724d3186e73..125c589eeef5 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -561,7 +561,7 @@ void pSeries_coalesce_init(void)
  * fw_cmo_feature_init - FW_FEATURE_CMO is not stored in ibm,hypertas-functions,
  * handle that here. (Stolen from parse_system_parameter_string)
  */
-void pSeries_cmo_feature_init(void)
+static void pSeries_cmo_feature_init(void)
 {
 	char *ptr, *key, *value, *end;
 	int call_status;

commit ae36e95cf81c98b111b84317adeb358aaffa80e2
Merge: cc8a44c671fd 663d3f7c2e5e
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Aug 14 09:53:39 2014 -0600

    Merge tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux
    
    Pull device tree updates from Grant Likely:
     "The branch contains the following device tree changes the v3.17 merge
      window:
    
      Group changes to the device tree.  In preparation for adding device
      tree overlay support, OF_DYNAMIC is reworked so that a set of device
      tree changes can be prepared and applied to the tree all at once.
      OF_RECONFIG notifiers see the most significant change here so that
      users always get a consistent view of the tree.  Notifiers generation
      is moved from before a change to after it, and notifiers for a group
      of changes are emitted after the entire block of changes have been
      applied
    
      Automatic console selection from DT.  Console drivers can now use
      of_console_check() to see if the device node is specified as a console
      device.  If so then it gets added as a preferred console.  UART
      devices get this support automatically when uart_add_one_port() is
      called.
    
      DT unit tests no longer depend on pre-loaded data in the device tree.
      Data is loaded dynamically at the start of unit tests, and then
      unloaded again when the tests have completed.
    
      Also contains a few bugfixes for reserved regions and early memory
      setup"
    
    * tag 'devicetree-for-linus' of git://git.secretlab.ca/git/linux: (21 commits)
      of: Fixing OF Selftest build error
      drivers: of: add automated assignment of reserved regions to client devices
      of: Use proper types for checking memory overflow
      of: typo fix in __of_prop_dup()
      Adding selftest testdata dynamically into live tree
      of: Add todo tasklist for Devicetree
      of: Transactional DT support.
      of: Reorder device tree changes and notifiers
      of: Move dynamic node fixups out of powerpc and into common code
      of: Make sure attached nodes don't carry along extra children
      of: Make devicetree sysfs update functions consistent.
      of: Create unlocked versions of node and property add/remove functions
      OF: Utility helper functions for dynamic nodes
      of: Move CONFIG_OF_DYNAMIC code into a separate file
      of: rename of_aliases_mutex to just of_mutex
      of/platform: Fix of_platform_device_destroy iteration of devices
      of: Migrate of_find_node_by_name() users to for_each_node_by_name()
      tty: Update hypervisor tty drivers to use core stdout parsing code.
      arm/versatile: Add the uart as the stdout device.
      of: Enable console on serial ports specified by /chosen/stdout-path
      ...

commit 8e83e9053f23cd036b73ae246d86c50cbb3ca73e
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Wed Jul 16 12:02:43 2014 +1000

    powerpc/pseries: Switch pseries drivers to use machine_xxx_initcall()
    
    A lot of the code in platforms/pseries is using non-machine initcalls.
    That means if a kernel built with pseries support runs on another
    platform, for example powernv, the initcalls will still run.
    
    Most of these cases are OK, though sometimes only due to luck. Some were
    having more effect:
    
     * hcall_inst_init
      - Checking FW_FEATURE_LPAR which is set on ps3 & celleb.
     * mobility_sysfs_init
      - created sysfs files unconditionally
      - but no effect due to ENOSYS from rtas_ibm_suspend_me()
     * apo_pm_init
      - created sysfs, allows write
      - nothing checks the value written to though
     * alloc_dispatch_log_kmem_cache
      - creating kmem_cache on non-pseries machines
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f2f40e64658f..cfe8a6389a51 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -351,7 +351,7 @@ static int alloc_dispatch_log_kmem_cache(void)
 
 	return alloc_dispatch_logs();
 }
-early_initcall(alloc_dispatch_log_kmem_cache);
+machine_early_initcall(pseries, alloc_dispatch_log_kmem_cache);
 
 static void pseries_lpar_idle(void)
 {

commit ccdb8ed3b3c739fe99a6f2f474f7ffad3203485d
Author: Grant Likely <grant.likely@linaro.org>
Date:   Wed Jun 4 16:42:26 2014 +0100

    of: Migrate of_find_node_by_name() users to for_each_node_by_name()
    
    There are a bunch of users open coding the for_each_node_by_name() by
    calling of_find_node_by_name() directly instead of using the macro. This
    is getting in the way of some cleanups, and the possibility of removing
    of_find_node_by_name() entirely. Clean it up so that all the users are
    consistent.
    
    Signed-off-by: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Takashi Iwai <tiwai@suse.de>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f2f40e64658f..cd6b4cde0de3 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -232,8 +232,7 @@ static void __init pseries_discover_pic(void)
 	struct device_node *np;
 	const char *typep;
 
-	for (np = NULL; (np = of_find_node_by_name(np,
-						   "interrupt-controller"));) {
+	for_each_node_by_name(np, "interrupt-controller") {
 		typep = of_get_property(np, "compatible", NULL);
 		if (strstr(typep, "open-pic")) {
 			pSeries_mpic_node = of_node_get(np);

commit c5aec4c76af1a2d89ee2f2d4d5463b2ad2d85de5
Merge: 2937f5efa575 0c0a3e5a100b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 10 18:54:22 2014 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    Pull powerpc updates from Ben Herrenschmidt:
     "Here is the bulk of the powerpc changes for this merge window.  It got
      a bit delayed in part because I wasn't paying attention, and in part
      because I discovered I had a core PCI change without a PCI maintainer
      ack in it.  Bjorn eventually agreed it was ok to merge it though we'll
      probably improve it later and I didn't want to rebase to add his ack.
    
      There is going to be a bit more next week, essentially fixes that I
      still want to sort through and test.
    
      The biggest item this time is the support to build the ppc64 LE kernel
      with our new v2 ABI.  We previously supported v2 userspace but the
      kernel itself was a tougher nut to crack.  This is now sorted mostly
      thanks to Anton and Rusty.
    
      We also have a fairly big series from Cedric that add support for
      64-bit LE zImage boot wrapper.  This was made harder by the fact that
      traditionally our zImage wrapper was always 32-bit, but our new LE
      toolchains don't really support 32-bit anymore (it's somewhat there
      but not really "supported") so we didn't want to rely on it.  This
      meant more churn that just endian fixes.
    
      This brings some more LE bits as well, such as the ability to run in
      LE mode without a hypervisor (ie. under OPAL firmware) by doing the
      right OPAL call to reinitialize the CPU to take HV interrupts in the
      right mode and the usual pile of endian fixes.
    
      There's another series from Gavin adding EEH improvements (one day we
      *will* have a release with less than 20 EEH patches, I promise!).
    
      Another highlight is the support for the "Split core" functionality on
      P8 by Michael.  This allows a P8 core to be split into "sub cores" of
      4 threads which allows the subcores to run different guests under KVM
      (the HW still doesn't support a partition per thread).
    
      And then the usual misc bits and fixes ..."
    
    [ Further delayed by gmail deciding that BenH is a dirty spammer.
      Google knows.  ]
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (155 commits)
      powerpc/powernv: Add missing include to LPC code
      selftests/powerpc: Test the THP bug we fixed in the previous commit
      powerpc/mm: Check paca psize is up to date for huge mappings
      powerpc/powernv: Pass buffer size to OPAL validate flash call
      powerpc/pseries: hcall functions are exported to modules, need _GLOBAL_TOC()
      powerpc: Exported functions __clear_user and copy_page use r2 so need _GLOBAL_TOC()
      powerpc/powernv: Set memory_block_size_bytes to 256MB
      powerpc: Allow ppc_md platform hook to override memory_block_size_bytes
      powerpc/powernv: Fix endian issues in memory error handling code
      powerpc/eeh: Skip eeh sysfs when eeh is disabled
      powerpc: 64bit sendfile is capped at 2GB
      powerpc/powernv: Provide debugfs access to the LPC bus via OPAL
      powerpc/serial: Use saner flags when creating legacy ports
      powerpc: Add cpu family documentation
      powerpc/xmon: Fix up xmon format strings
      powerpc/powernv: Add calls to support little endian host
      powerpc: Document sysfs DSCR interface
      powerpc: Fix regression of per-CPU DSCR setting
      powerpc: Split __SYSFS_SPRSETUP macro
      arch: powerpc/fadump: Cleaning up inconsistent NULL checks
      ...

commit a5d862576a64cb3e0c22dc9cc2170e4d750714f9
Author: Anton Blanchard <anton@au1.ibm.com>
Date:   Wed Jun 4 17:50:47 2014 +1000

    powerpc: Allow ppc_md platform hook to override memory_block_size_bytes
    
    The pseries platform code unconditionally overrides
    memory_block_size_bytes regardless of the running platform.
    
    Create a ppc_md hook that so each platform can choose to
    do what it wants.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 215c3c269617..adc21a0e3410 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -810,4 +810,7 @@ define_machine(pseries) {
 #ifdef CONFIG_KEXEC
 	.machine_kexec          = pSeries_machine_kexec,
 #endif
+#ifdef CONFIG_MEMORY_HOTPLUG_SPARSE
+	.memory_block_size	= pseries_memory_block_size,
+#endif
 };

commit 983d8a6dda1d477f3ffa23a04cc2fa4d66fd93d1
Author: Tony Breeds <tony@bakeyournoodle.com>
Date:   Wed Mar 12 19:17:07 2014 +1100

    powerpc/le: Show the endianess of the LPAR under PowerVM.
    
    Signed-off-by: Tony Breeds <tony@bakeyournoodle.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 2db8cc691bf4..215c3c269617 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -510,7 +510,11 @@ static void __init pSeries_setup_arch(void)
 static int __init pSeries_init_panel(void)
 {
 	/* Manually leave the kernel version on the panel. */
+#ifdef __BIG_ENDIAN__
 	ppc_md.progress("Linux ppc64\n", 0);
+#else
+	ppc_md.progress("Linux ppc64le\n", 0);
+#endif
 	ppc_md.progress(init_utsname()->version, 0);
 
 	return 0;

commit 9d0c4dfedd96ee54fc075b16d02f82499c8cc3a6
Author: Rob Herring <robh@kernel.org>
Date:   Tue Apr 1 23:49:03 2014 -0500

    of/fdt: update of_get_flat_dt_prop in prep for libfdt
    
    Make of_get_flat_dt_prop arguments compatible with libfdt fdt_getprop
    call in preparation to convert FDT code to use libfdt. Make the return
    value const and the property length ptr type an int.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Tested-by: Michal Simek <michal.simek@xilinx.com>
    Tested-by: Grant Likely <grant.likely@linaro.org>
    Tested-by: Stephen Chivers <schivers@csc.com>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 2db8cc691bf4..099d2df976a2 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -665,7 +665,7 @@ static int __init pseries_probe_fw_features(unsigned long node,
 					    void *data)
 {
 	const char *prop;
-	unsigned long len;
+	int len;
 	static int hypertas_found;
 	static int vec5_found;
 
@@ -698,7 +698,7 @@ static int __init pseries_probe_fw_features(unsigned long node,
 static int __init pSeries_probe(void)
 {
 	unsigned long root = of_get_flat_dt_root();
- 	char *dtype = of_get_flat_dt_prop(root, "device_type", NULL);
+	const char *dtype = of_get_flat_dt_prop(root, "device_type", NULL);
 
  	if (dtype == NULL)
  		return 0;

commit d97a860c4f3de98ba5040a22f305b7159fe17cff
Merge: 3f67d962c64d d158fc7f36a2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Feb 21 21:36:40 2014 +0100

    Merge branch 'linus' into sched/core
    
    Reason: Bring bakc upstream modification to resolve conflicts
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

commit d8c6ad3184ca6516a5cf457af1afaa293d8f09c0
Author: Nicolas Pitre <nicolas.pitre@linaro.org>
Date:   Wed Jan 29 12:45:10 2014 -0500

    sched/idle, PPC: Remove redundant cpuidle_idle_call()
    
    The core idle loop now takes care of it.  However a few things need
    checking:
    
    - Invocation of cpuidle_idle_call() in pseries_lpar_idle() happened
      through arch_cpu_idle() and was therefore always preceded by a call
      to ppc64_runlatch_off().  To preserve this property now that
      cpuidle_idle_call() is invoked directly from core code, a call to
      ppc64_runlatch_off() has been added to idle_loop_prolog() in
      platforms/pseries/processor_idle.c.
    
    - Similarly, cpuidle_idle_call() was followed by ppc64_runlatch_off()
      so a call to the later has been added to idle_loop_epilog().
    
    - And since arch_cpu_idle() always made sure to re-enable IRQs if they
      were not enabled, this is now
      done in idle_loop_epilog() as well.
    
    The above was made in order to keep the execution flow close to the
    original.  I don't know if that was strictly necessary. Someone well
    aquainted with the platform details might find some room for possible
    optimizations.
    
    Signed-off-by: Nicolas Pitre <nico@linaro.org>
    Reviewed-by: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Daniel Lezcano <daniel.lezcano@linaro.org>
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: linux-sh@vger.kernel.org
    Cc: linux-pm@vger.kernel.org
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: linaro-kernel@lists.linaro.org
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/n/tip-47o4m03citrfg9y1vxic5asb@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 8e639d7cbda7..c737d554571a 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -39,7 +39,6 @@
 #include <linux/irq.h>
 #include <linux/seq_file.h>
 #include <linux/root_dev.h>
-#include <linux/cpuidle.h>
 #include <linux/of.h>
 #include <linux/kexec.h>
 
@@ -356,29 +355,24 @@ early_initcall(alloc_dispatch_log_kmem_cache);
 
 static void pseries_lpar_idle(void)
 {
-	/* This would call on the cpuidle framework, and the back-end pseries
-	 * driver to  go to idle states
+	/*
+	 * Default handler to go into low thread priority and possibly
+	 * low power mode by cedeing processor to hypervisor
 	 */
-	if (cpuidle_idle_call()) {
-		/* On error, execute default handler
-		 * to go into low thread priority and possibly
-		 * low power mode by cedeing processor to hypervisor
-		 */
 
-		/* Indicate to hypervisor that we are idle. */
-		get_lppaca()->idle = 1;
+	/* Indicate to hypervisor that we are idle. */
+	get_lppaca()->idle = 1;
 
-		/*
-		 * Yield the processor to the hypervisor.  We return if
-		 * an external interrupt occurs (which are driven prior
-		 * to returning here) or if a prod occurs from another
-		 * processor. When returning here, external interrupts
-		 * are enabled.
-		 */
-		cede_processor();
+	/*
+	 * Yield the processor to the hypervisor.  We return if
+	 * an external interrupt occurs (which are driven prior
+	 * to returning here) or if a prod occurs from another
+	 * processor. When returning here, external interrupts
+	 * are enabled.
+	 */
+	cede_processor();
 
-		get_lppaca()->idle = 0;
-	}
+	get_lppaca()->idle = 0;
 }
 
 /*

commit 3ec8b78fcc5aa7745026d8d85a4e9ab52c922765
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Fri Jan 31 00:30:45 2014 +0530

    powerpc/pseries: Disable relocation on exception while going down during crash.
    
    Disable relocation on exception while going down even in kdump case. This
    is because we are about clear htab mappings while kexec-ing into kdump
    kernel and we may run into issues if we still have AIL ON.
    
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 8e639d7cbda7..972df0ffd4dc 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -430,8 +430,7 @@ static void pSeries_machine_kexec(struct kimage *image)
 {
 	long rc;
 
-	if (firmware_has_feature(FW_FEATURE_SET_MODE) &&
-	    (image->type != KEXEC_TYPE_CRASH)) {
+	if (firmware_has_feature(FW_FEATURE_SET_MODE)) {
 		rc = pSeries_disable_reloc_on_exc();
 		if (rc != H_SUCCESS)
 			pr_warning("Warning: Failed to disable relocation on "

commit 1b17366d695c8ab03f98d0155357e97a427e1dce
Merge: d12de1ef5eba 7179ba52889b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jan 27 21:11:26 2014 -0800

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    Pull powerpc updates from Ben Herrenschmidt:
     "So here's my next branch for powerpc.  A bit late as I was on vacation
      last week.  It's mostly the same stuff that was in next already, I
      just added two patches today which are the wiring up of lockref for
      powerpc, which for some reason fell through the cracks last time and
      is trivial.
    
      The highlights are, in addition to a bunch of bug fixes:
    
       - Reworked Machine Check handling on kernels running without a
         hypervisor (or acting as a hypervisor).  Provides hooks to handle
         some errors in real mode such as TLB errors, handle SLB errors,
         etc...
    
       - Support for retrieving memory error information from the service
         processor on IBM servers running without a hypervisor and routing
         them to the memory poison infrastructure.
    
       - _PAGE_NUMA support on server processors
    
       - 32-bit BookE relocatable kernel support
    
       - FSL e6500 hardware tablewalk support
    
       - A bunch of new/revived board support
    
       - FSL e6500 deeper idle states and altivec powerdown support
    
      You'll notice a generic mm change here, it has been acked by the
      relevant authorities and is a pre-req for our _PAGE_NUMA support"
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (121 commits)
      powerpc: Implement arch_spin_is_locked() using arch_spin_value_unlocked()
      powerpc: Add support for the optimised lockref implementation
      powerpc/powernv: Call OPAL sync before kexec'ing
      powerpc/eeh: Escalate error on non-existing PE
      powerpc/eeh: Handle multiple EEH errors
      powerpc: Fix transactional FP/VMX/VSX unavailable handlers
      powerpc: Don't corrupt transactional state when using FP/VMX in kernel
      powerpc: Reclaim two unused thread_info flag bits
      powerpc: Fix races with irq_work
      Move precessing of MCE queued event out from syscall exit path.
      pseries/cpuidle: Remove redundant call to ppc64_runlatch_off() in cpu idle routines
      powerpc: Make add_system_ram_resources() __init
      powerpc: add SATA_MV to ppc64_defconfig
      powerpc/powernv: Increase candidate fw image size
      powerpc: Add debug checks to catch invalid cpu-to-node mappings
      powerpc: Fix the setup of CPU-to-Node mappings during CPU online
      powerpc/iommu: Don't detach device without IOMMU group
      powerpc/eeh: Hotplug improvement
      powerpc/eeh: Call opal_pci_reinit() on powernv for restoring config space
      powerpc/eeh: Add restore_config operation
      ...

commit e589a4404fa06730355de204d3d136ed9bbc7dea
Author: Alistair Popple <alistair@popple.id.au>
Date:   Mon Dec 9 18:17:01 2013 +1100

    powerpc/iommu: Update constant names to reflect their hardcoded page size
    
    The powerpc iommu uses a hardcoded page size of 4K. This patch changes
    the name of the IOMMU_PAGE_* macros to reflect the hardcoded values. A
    future patch will use the existing names to support dynamic page
    sizes.
    
    Signed-off-by: Alistair Popple <alistair@popple.id.au>
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index c1f190858701..49cd16e6b450 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -72,7 +72,7 @@
 
 int CMO_PrPSP = -1;
 int CMO_SecPSP = -1;
-unsigned long CMO_PageSize = (ASM_CONST(1) << IOMMU_PAGE_SHIFT);
+unsigned long CMO_PageSize = (ASM_CONST(1) << IOMMU_PAGE_SHIFT_4K);
 EXPORT_SYMBOL(CMO_PageSize);
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
@@ -569,7 +569,7 @@ void pSeries_cmo_feature_init(void)
 {
 	char *ptr, *key, *value, *end;
 	int call_status;
-	int page_order = IOMMU_PAGE_SHIFT;
+	int page_order = IOMMU_PAGE_SHIFT_4K;
 
 	pr_debug(" -> fw_cmo_feature_init()\n");
 	spin_lock(&rtas_data_buf_lock);

commit b71d47c14fba6270c0b5a0d56639bf042017025b
Author: Jason Baron <jbaron@akamai.com>
Date:   Mon Nov 25 23:23:11 2013 +0000

    powerpc: Clean up panic_timeout usage
    
    Default CONFIG_PANIC_TIMEOUT to 180 seconds on powerpc. The
    pSeries continue to set the timeout to 10 seconds at run-time.
    
    Thus, there's a small window where we don't have the correct
    value on pSeries, but if this is only run-time discoverable we
    don't have a better option. In any case, if the user changes the
    default setting of 180 seconds, we honor that user setting.
    
    Signed-off-by: Jason Baron <jbaron@akamai.com>
    Cc: benh@kernel.crashing.org
    Cc: paulus@samba.org
    Cc: ralf@linux-mips.org
    Cc: mpe@ellerman.id.au
    Cc: felipe.contreras@gmail.com
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/705bbe0f70fb20759151642ba0176a6414ec9f7a.1385418410.git.jbaron@akamai.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index c1f190858701..6f76ae417f47 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -470,7 +470,7 @@ static long pseries_little_endian_exceptions(void)
 
 static void __init pSeries_setup_arch(void)
 {
-	panic_timeout = 10;
+	set_arch_panic_timeout(10, ARCH_PANIC_TIMEOUT);
 
 	/* Discover PIC type and setup ppc_md accordingly */
 	pseries_discover_pic();

commit e844b1eeae42dc93bf13e67812a95ee7b58be8c7
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Nov 20 22:14:59 2013 +1100

    pseries: Add H_SET_MODE to change exception endianness
    
    On little endian builds call H_SET_MODE so exceptions have the
    correct endianness. We need to reset the endian during kexec
    so do that in the MMU hashtable clear callback.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 1f97e2b87a62..c1f190858701 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -442,6 +442,32 @@ static void pSeries_machine_kexec(struct kimage *image)
 }
 #endif
 
+#ifdef __LITTLE_ENDIAN__
+long pseries_big_endian_exceptions(void)
+{
+	long rc;
+
+	while (1) {
+		rc = enable_big_endian_exceptions();
+		if (!H_IS_LONG_BUSY(rc))
+			return rc;
+		mdelay(get_longbusy_msecs(rc));
+	}
+}
+
+static long pseries_little_endian_exceptions(void)
+{
+	long rc;
+
+	while (1) {
+		rc = enable_little_endian_exceptions();
+		if (!H_IS_LONG_BUSY(rc))
+			return rc;
+		mdelay(get_longbusy_msecs(rc));
+	}
+}
+#endif
+
 static void __init pSeries_setup_arch(void)
 {
 	panic_timeout = 10;
@@ -698,6 +724,22 @@ static int __init pSeries_probe(void)
 	/* Now try to figure out if we are running on LPAR */
 	of_scan_flat_dt(pseries_probe_fw_features, NULL);
 
+#ifdef __LITTLE_ENDIAN__
+	if (firmware_has_feature(FW_FEATURE_SET_MODE)) {
+		long rc;
+		/*
+		 * Tell the hypervisor that we want our exceptions to
+		 * be taken in little endian mode. If this fails we don't
+		 * want to use BUG() because it will trigger an exception.
+		 */
+		rc = pseries_little_endian_exceptions();
+		if (rc) {
+			ppc_md.progress("H_SET_MODE LE exception fail", 0);
+			panic("Could not enable little endian exceptions");
+		}
+	}
+#endif
+
 	if (firmware_has_feature(FW_FEATURE_LPAR))
 		hpte_init_lpar();
 	else

commit 363edbe2614aa90df706c0f19ccfa2a6c06af0be
Author: Vaidyanathan Srinivasan <svaidy@linux.vnet.ibm.com>
Date:   Fri Sep 6 00:25:06 2013 +0530

    powerpc: Default arch idle could cede processor on pseries
    
    When adding cpuidle support to pSeries, we introduced two
    regressions:
    
      - The new cpuidle backend driver only works under hypervisors
        supporting the "SLPLAR" option, which isn't the case of the
        old POWER4 hypervisor and the HV "light" used on js2x blades
    
      - The cpuidle driver registers fairly late, meaning that for
        a significant portion of the boot process, we end up having
        all threads spinning. This slows down the boot process and
        increases the overall resource usage if the hypervisor has
        shared processors.
    
    This fixes both by implementing a "default" idle that will cede
    to the hypervisor when possible, in a very simple way without
    all the bells and whisles of cpuidle.
    
    Reported-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Vaidyanathan Srinivasan <svaidy@linux.vnet.ibm.com>
    Acked-by: Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: <stable@vger.kernel.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index d64feb3ea0be..1f97e2b87a62 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -354,7 +354,7 @@ static int alloc_dispatch_log_kmem_cache(void)
 }
 early_initcall(alloc_dispatch_log_kmem_cache);
 
-static void pSeries_idle(void)
+static void pseries_lpar_idle(void)
 {
 	/* This would call on the cpuidle framework, and the back-end pseries
 	 * driver to  go to idle states
@@ -362,10 +362,22 @@ static void pSeries_idle(void)
 	if (cpuidle_idle_call()) {
 		/* On error, execute default handler
 		 * to go into low thread priority and possibly
-		 * low power mode.
+		 * low power mode by cedeing processor to hypervisor
 		 */
-		HMT_low();
-		HMT_very_low();
+
+		/* Indicate to hypervisor that we are idle. */
+		get_lppaca()->idle = 1;
+
+		/*
+		 * Yield the processor to the hypervisor.  We return if
+		 * an external interrupt occurs (which are driven prior
+		 * to returning here) or if a prod occurs from another
+		 * processor. When returning here, external interrupts
+		 * are enabled.
+		 */
+		cede_processor();
+
+		get_lppaca()->idle = 0;
 	}
 }
 
@@ -456,15 +468,14 @@ static void __init pSeries_setup_arch(void)
 
 	pSeries_nvram_init();
 
-	if (firmware_has_feature(FW_FEATURE_SPLPAR)) {
+	if (firmware_has_feature(FW_FEATURE_LPAR)) {
 		vpa_init(boot_cpuid);
-		ppc_md.power_save = pSeries_idle;
-	}
-
-	if (firmware_has_feature(FW_FEATURE_LPAR))
+		ppc_md.power_save = pseries_lpar_idle;
 		ppc_md.enable_pmcs = pseries_lpar_enable_pmcs;
-	else
+	} else {
+		/* No special idle routine */
 		ppc_md.enable_pmcs = power4_enable_pmcs;
+	}
 
 	ppc_md.pcibios_root_bridge_prepare = pseries_root_bridge_prepare;
 

commit 212bebb4097837ec0b601c42be839c1314994dc2
Author: Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
Date:   Thu Aug 22 15:23:52 2013 +0530

    pseries: Move plpar_wrapper.h to powerpc common include/asm location.
    
    As a part of pseries_idle backend driver cleanup to make
    the code common to both pseries and powernv platforms, it
    is necessary to move the backend-driver code to drivers/cpuidle.
    
    As a pre-requisite for that, it is essential to move plpar_wrapper.h
    to include/asm.
    
    Signed-off-by: Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 33d619665cb7..d64feb3ea0be 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -66,8 +66,8 @@
 #include <asm/firmware.h>
 #include <asm/eeh.h>
 #include <asm/reg.h>
+#include <asm/plpar_wrappers.h>
 
-#include "plpar_wrappers.h"
 #include "pseries.h"
 
 int CMO_PrPSP = -1;

commit 7ffcf8ec26f4b94b95b1297131d223b121d951e5
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Aug 7 02:01:46 2013 +1000

    powerpc: Fix little endian lppaca, slb_shadow and dtl_entry
    
    The lppaca, slb_shadow and dtl_entry hypervisor structures are
    big endian, so we have to byte swap them in little endian builds.
    
    LE KVM hosts will also need to be fixed but for now add an #error
    to remind us.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b19cd8334630..33d619665cb7 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -323,7 +323,7 @@ static int alloc_dispatch_logs(void)
 	get_paca()->lppaca_ptr->dtl_idx = 0;
 
 	/* hypervisor reads buffer length from this field */
-	dtl->enqueue_to_dispatch_time = DISPATCH_LOG_BYTES;
+	dtl->enqueue_to_dispatch_time = cpu_to_be32(DISPATCH_LOG_BYTES);
 	ret = register_dtl(hard_smp_processor_id(), __pa(dtl));
 	if (ret)
 		pr_err("WARNING: DTL registration of cpu %d (hw %d) failed "

commit b0d436c739b0d4afcdfe2e97d4d1ee41ea2db62e
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Aug 7 02:01:24 2013 +1000

    powerpc: Fix a number of sparse warnings
    
    Address some of the trivial sparse warnings in arch/powerpc.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index c11c8238797c..b19cd8334630 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -183,7 +183,7 @@ static void __init pseries_mpic_init_IRQ(void)
 	np = of_find_node_by_path("/");
 	naddr = of_n_addr_cells(np);
 	opprop = of_get_property(np, "platform-open-pic", &opplen);
-	if (opprop != 0) {
+	if (opprop != NULL) {
 		openpic_addr = of_read_number(opprop, naddr);
 		printk(KERN_DEBUG "OpenPIC addr: %lx\n", openpic_addr);
 	}

commit d82fb31abc46620b7c22758c75707069f2763646
Author: Kleber Sacilotto de Souza <klebers@linux.vnet.ibm.com>
Date:   Fri May 3 12:43:12 2013 +0000

    powerpc/pseries: Perform proper max_bus_speed detection
    
    On pseries machines the detection for max_bus_speed should be done
    through an OpenFirmware property. This patch adds a function to perform
    this detection and a hook to perform dynamic adding of the function only
    for pseries. This is done by overwriting the weak
    pcibios_root_bridge_prepare function which is called by
    pci_create_root_bus().
    
    From: Lucas Kannebley Tavares <lucaskt@linux.vnet.ibm.com>
    Signed-off-by: Kleber Sacilotto de Souza <klebers@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index ac932a9eb440..c11c8238797c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -466,6 +466,8 @@ static void __init pSeries_setup_arch(void)
 	else
 		ppc_md.enable_pmcs = power4_enable_pmcs;
 
+	ppc_md.pcibios_root_bridge_prepare = pseries_root_bridge_prepare;
+
 	if (firmware_has_feature(FW_FEATURE_SET_MODE)) {
 		long rc;
 		if ((rc = pSeries_enable_reloc_on_exc()) != H_SUCCESS) {

commit f0ff7eb483b4c9b24b83aa682c4f42db256f9bdb
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Wed Apr 24 05:57:18 2013 +0000

    powerpc/pseries: Update firmware_has_feature() to check architecture vector 5 bits
    
    The firmware_has_feature() function makes it easy to check for supported
    features of the hypervisor. This patch extends the capability of
    firmware_has_feature() to include checking for specified bits
    in vector 5 of the architecture vector as reported in the device tree.
    
    As part of this the #defines used for the architecture vector are re-defined
    such that each option has the index into vector 5 and the feature bit encoded
    into it. This makes checking for architecture bits when initiating data
    for firmware_has_feature much easier.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 8bcc9ca6682f..ac932a9eb440 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -628,25 +628,39 @@ static void __init pSeries_init_early(void)
  * Called very early, MMU is off, device-tree isn't unflattened
  */
 
-static int __init pSeries_probe_hypertas(unsigned long node,
-					 const char *uname, int depth,
-					 void *data)
+static int __init pseries_probe_fw_features(unsigned long node,
+					    const char *uname, int depth,
+					    void *data)
 {
-	const char *hypertas;
+	const char *prop;
 	unsigned long len;
+	static int hypertas_found;
+	static int vec5_found;
 
-	if (depth != 1 ||
-	    (strcmp(uname, "rtas") != 0 && strcmp(uname, "rtas@0") != 0))
+	if (depth != 1)
 		return 0;
 
-	hypertas = of_get_flat_dt_prop(node, "ibm,hypertas-functions", &len);
-	if (!hypertas)
-		return 1;
+	if (!strcmp(uname, "rtas") || !strcmp(uname, "rtas@0")) {
+		prop = of_get_flat_dt_prop(node, "ibm,hypertas-functions",
+					   &len);
+		if (prop) {
+			powerpc_firmware_features |= FW_FEATURE_LPAR;
+			fw_hypertas_feature_init(prop, len);
+		}
 
-	powerpc_firmware_features |= FW_FEATURE_LPAR;
-	fw_feature_init(hypertas, len);
+		hypertas_found = 1;
+	}
 
-	return 1;
+	if (!strcmp(uname, "chosen")) {
+		prop = of_get_flat_dt_prop(node, "ibm,architecture-vec-5",
+					   &len);
+		if (prop)
+			fw_vec5_feature_init(prop, len);
+
+		vec5_found = 1;
+	}
+
+	return hypertas_found && vec5_found;
 }
 
 static int __init pSeries_probe(void)
@@ -669,7 +683,7 @@ static int __init pSeries_probe(void)
 	pr_debug("pSeries detected, looking for LPAR capability...\n");
 
 	/* Now try to figure out if we are running on LPAR */
-	of_scan_flat_dt(pSeries_probe_hypertas, NULL);
+	of_scan_flat_dt(pseries_probe_fw_features, NULL);
 
 	if (firmware_has_feature(FW_FEATURE_LPAR))
 		hpte_init_lpar();

commit 9d3cae26acb471d5954cfdc25d1438b32060babe
Merge: df24eef3e794 8520e443aa56
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 23 17:09:55 2013 -0800

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    Pull powerpc updates from Benjamin Herrenschmidt:
     "So from the depth of frozen Minnesota, here's the powerpc pull request
      for 3.9.  It has a few interesting highlights, in addition to the
      usual bunch of bug fixes, minor updates, embedded device tree updates
      and new boards:
    
       - Hand tuned asm implementation of SHA1 (by Paulus & Michael
         Ellerman)
    
       - Support for Doorbell interrupts on Power8 (kind of fast
         thread-thread IPIs) by Ian Munsie
    
       - Long overdue cleanup of the way we handle relocation of our open
         firmware trampoline (prom_init.c) on 64-bit by Anton Blanchard
    
       - Support for saving/restoring & context switching the PPR (Processor
         Priority Register) on server processors that support it.  This
         allows the kernel to preserve thread priorities established by
         userspace.  By Haren Myneni.
    
       - DAWR (new watchpoint facility) support on Power8 by Michael Neuling
    
       - Ability to change the DSCR (Data Stream Control Register) which
         controls cache prefetching on a running process via ptrace by
         Alexey Kardashevskiy
    
       - Support for context switching the TAR register on Power8 (new
         branch target register meant to be used by some new specific
         userspace perf event interrupt facility which is yet to be enabled)
         by Ian Munsie.
    
       - Improve preservation of the CFAR register (which captures the
         origin of a branch) on various exception conditions by Paulus.
    
       - Move the Bestcomm DMA driver from arch powerpc to drivers/dma where
         it belongs by Philippe De Muyter
    
       - Support for Transactional Memory on Power8 by Michael Neuling
         (based on original work by Matt Evans).  For those curious about
         the feature, the patch contains a pretty good description."
    
    (See commit db8ff907027b: "powerpc: Documentation for transactional
    memory on powerpc" for the mentioned description added to the file
    Documentation/powerpc/transactional_memory.txt)
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (140 commits)
      powerpc/kexec: Disable hard IRQ before kexec
      powerpc/85xx: l2sram - Add compatible string for BSC9131 platform
      powerpc/85xx: bsc9131 - Correct typo in SDHC device node
      powerpc/e500/qemu-e500: enable coreint
      powerpc/mpic: allow coreint to be determined by MPIC version
      powerpc/fsl_pci: Store the pci ctlr device ptr in the pci ctlr struct
      powerpc/85xx: Board support for ppa8548
      powerpc/fsl: remove extraneous DIU platform functions
      arch/powerpc/platforms/85xx/p1022_ds.c: adjust duplicate test
      powerpc: Documentation for transactional memory on powerpc
      powerpc: Add transactional memory to pseries and ppc64 defconfigs
      powerpc: Add config option for transactional memory
      powerpc: Add transactional memory to POWER8 cpu features
      powerpc: Add new transactional memory state to the signal context
      powerpc: Hook in new transactional memory code
      powerpc: Routines for FP/VSX/VMX unavailable during a transaction
      powerpc: Add transactional memory unavaliable execption handler
      powerpc: Add reclaim and recheckpoint functions for context switching transactional memory processes
      powerpc: Add FP/VSX and VMX register load functions for transactional memory
      powerpc: Add helper functions for transactional memory context switching
      ...

commit abf917cd91cbb73952758f9741e2fa65002a48ee
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Jul 25 07:56:04 2012 +0200

    cputime: Generic on-demand virtual cputime accounting
    
    If we want to stop the tick further idle, we need to be
    able to account the cputime without using the tick.
    
    Virtual based cputime accounting solves that problem by
    hooking into kernel/user boundaries.
    
    However implementing CONFIG_VIRT_CPU_ACCOUNTING require
    low level hooks and involves more overhead. But we already
    have a generic context tracking subsystem that is required
    for RCU needs by archs which plan to shut down the tick
    outside idle.
    
    This patch implements a generic virtual based cputime
    accounting that relies on these generic kernel/user hooks.
    
    There are some upsides of doing this:
    
    - This requires no arch code to implement CONFIG_VIRT_CPU_ACCOUNTING
    if context tracking is already built (already necessary for RCU in full
    tickless mode).
    
    - We can rely on the generic context tracking subsystem to dynamically
    (de)activate the hooks, so that we can switch anytime between virtual
    and tick based accounting. This way we don't have the overhead
    of the virtual accounting when the tick is running periodically.
    
    And one downside:
    
    - There is probably more overhead than a native virtual based cputime
    accounting. But this relies on hooks that are already set anyway.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Li Zhong <zhong@linux.vnet.ibm.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index ca55882465d6..527e12c9573b 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -281,7 +281,7 @@ static struct notifier_block pci_dn_reconfig_nb = {
 
 struct kmem_cache *dtl_cache;
 
-#ifdef CONFIG_VIRT_CPU_ACCOUNTING
+#ifdef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE
 /*
  * Allocate space for the dispatch trace log for all possible cpus
  * and register the buffers with the hypervisor.  This is used for
@@ -332,12 +332,12 @@ static int alloc_dispatch_logs(void)
 
 	return 0;
 }
-#else /* !CONFIG_VIRT_CPU_ACCOUNTING */
+#else /* !CONFIG_VIRT_CPU_ACCOUNTING_NATIVE */
 static inline int alloc_dispatch_logs(void)
 {
 	return 0;
 }
-#endif /* CONFIG_VIRT_CPU_ACCOUNTING */
+#endif /* CONFIG_VIRT_CPU_ACCOUNTING_NATIVE */
 
 static int alloc_dispatch_log_kmem_cache(void)
 {

commit bf99de36e48678c61adb697496e0364c610bbbfc
Author: Michael Neuling <mikey@neuling.org>
Date:   Thu Dec 20 14:06:45 2012 +0000

    powerpc: Add the DAWR support to the set_break()
    
    This adds DAWR supoprt to the set_break().
    
    It does both bare metal and PAPR versions of setting the DAWR.
    
    There is still some work we can do to make full use of the watchpoint but that
    will come later.
    
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 1890730354bb..b1f60d162bb6 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -65,6 +65,7 @@
 #include <asm/smp.h>
 #include <asm/firmware.h>
 #include <asm/eeh.h>
+#include <asm/reg.h>
 
 #include "plpar_wrappers.h"
 #include "pseries.h"
@@ -500,6 +501,14 @@ static int pseries_set_xdabr(unsigned long dabr, unsigned long dabrx)
 	return plpar_hcall_norets(H_SET_XDABR, dabr, dabrx);
 }
 
+static int pseries_set_dawr(unsigned long dawr, unsigned long dawrx)
+{
+	/* PAPR says we can't set HYP */
+	dawrx &= ~DAWRX_HYP;
+
+	return  plapr_set_watchpoint0(dawr, dawrx);
+}
+
 #define CMO_CHARACTERISTICS_TOKEN 44
 #define CMO_MAXLENGTH 1026
 
@@ -606,6 +615,9 @@ static void __init pSeries_init_early(void)
 	else if (firmware_has_feature(FW_FEATURE_DABR))
 		ppc_md.set_dabr = pseries_set_dabr;
 
+	if (firmware_has_feature(FW_FEATURE_SET_MODE))
+		ppc_md.set_dawr = pseries_set_dawr;
+
 	pSeries_cmo_feature_init();
 	iommu_init_early_pSeries();
 

commit a413f474a0ff29404bf1af5c024215476ed6ca01
Author: Ian Munsie <imunsie@au1.ibm.com>
Date:   Mon Dec 3 18:36:13 2012 +0000

    powerpc: Disable relocation on exceptions whenever PR KVM is active
    
    For PR KVM we allow userspace to map 0xc000000000000000. Because
    transitioning from userspace to the guest kernel may use the relocated
    exception vectors we have to disable relocation on exceptions whenever
    PR KVM is active as we cannot trust that address.
    
    This issue does not apply to HV KVM, since changing from a guest to the
    hypervisor will never use the relocated exception vectors.
    
    Currently the hypervisor interface only allows us to toggle relocation
    on exceptions on a partition wide scope, so we need to globally disable
    relocation on exceptions when the first PR KVM instance is started and
    only re-enable them when all PR KVM instances have been destroyed.
    
    It's a bit heavy handed, but until the hypervisor gives us a lightweight
    way to toggle relocation on exceptions on a single thread it's only real
    option.
    
    Signed-off-by: Ian Munsie <imunsie@au1.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index ca55882465d6..1890730354bb 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -375,7 +375,7 @@ static void pSeries_idle(void)
  * to ever be a problem in practice we can move this into a kernel thread to
  * finish off the process later in boot.
  */
-static int __init pSeries_enable_reloc_on_exc(void)
+long pSeries_enable_reloc_on_exc(void)
 {
 	long rc;
 	unsigned int delay, total_delay = 0;
@@ -397,9 +397,9 @@ static int __init pSeries_enable_reloc_on_exc(void)
 		mdelay(delay);
 	}
 }
+EXPORT_SYMBOL(pSeries_enable_reloc_on_exc);
 
-#ifdef CONFIG_KEXEC
-static long pSeries_disable_reloc_on_exc(void)
+long pSeries_disable_reloc_on_exc(void)
 {
 	long rc;
 
@@ -410,7 +410,9 @@ static long pSeries_disable_reloc_on_exc(void)
 		mdelay(get_longbusy_msecs(rc));
 	}
 }
+EXPORT_SYMBOL(pSeries_disable_reloc_on_exc);
 
+#ifdef CONFIG_KEXEC
 static void pSeries_machine_kexec(struct kimage *image)
 {
 	long rc;

commit cedddd812a79a4fda3885a15711aee3de78c4a24
Author: Ian Munsie <imunsie@au1.ibm.com>
Date:   Thu Nov 8 16:40:28 2012 +1100

    powerpc: Disable relocation on exceptions when kexecing
    
    Since we don't know if they new kernel we are kexecing into has been
    built to support relocation on exceptions, we disable them before we
    kexec.
    
    We do NOT disable them if we are execing a kdump kernel, because we
    want to change as little state as possible and it is likely that we are
    execing ourselves and will be able to handle them anyway.
    
    Signed-off-by: Ian Munsie <imunsie@au1.ibm.com>
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 5d97553e5c22..ca55882465d6 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -41,6 +41,7 @@
 #include <linux/root_dev.h>
 #include <linux/cpuidle.h>
 #include <linux/of.h>
+#include <linux/kexec.h>
 
 #include <asm/mmu.h>
 #include <asm/processor.h>
@@ -397,6 +398,35 @@ static int __init pSeries_enable_reloc_on_exc(void)
 	}
 }
 
+#ifdef CONFIG_KEXEC
+static long pSeries_disable_reloc_on_exc(void)
+{
+	long rc;
+
+	while (1) {
+		rc = disable_reloc_on_exceptions();
+		if (!H_IS_LONG_BUSY(rc))
+			return rc;
+		mdelay(get_longbusy_msecs(rc));
+	}
+}
+
+static void pSeries_machine_kexec(struct kimage *image)
+{
+	long rc;
+
+	if (firmware_has_feature(FW_FEATURE_SET_MODE) &&
+	    (image->type != KEXEC_TYPE_CRASH)) {
+		rc = pSeries_disable_reloc_on_exc();
+		if (rc != H_SUCCESS)
+			pr_warning("Warning: Failed to disable relocation on "
+				   "exceptions: %ld\n", rc);
+	}
+
+	default_machine_kexec(image);
+}
+#endif
+
 static void __init pSeries_setup_arch(void)
 {
 	panic_timeout = 10;
@@ -697,4 +727,7 @@ define_machine(pseries) {
 	.progress		= rtas_progress,
 	.system_reset_exception = pSeries_system_reset_exception,
 	.machine_check_exception = pSeries_machine_check_exception,
+#ifdef CONFIG_KEXEC
+	.machine_kexec          = pSeries_machine_kexec,
+#endif
 };

commit fc8effa4e46fb7bd8a3c5e293efc56b74a54b7a5
Author: Ian Munsie <imunsie@au1.ibm.com>
Date:   Thu Nov 8 16:03:14 2012 +1100

    powerpc: Enable relocation on during exceptions at boot
    
    We currently do this synchronously at boot from setup_arch. On a large
    system this could hypothetically take a little while to complete, so
    currently we will give up if we are asked to wait for more than a second
    in total.
    
    If we actually start hitting that timeout in practice we can always move
    this code into a kernel thread to take care of it in the background.
    
    Signed-off-by: Ian Munsie <imunsie@au1.ibm.com>
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e1a5b8a32d25..5d97553e5c22 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -367,6 +367,36 @@ static void pSeries_idle(void)
 	}
 }
 
+/*
+ * Enable relocation on during exceptions. This has partition wide scope and
+ * may take a while to complete, if it takes longer than one second we will
+ * just give up rather than wasting any more time on this - if that turns out
+ * to ever be a problem in practice we can move this into a kernel thread to
+ * finish off the process later in boot.
+ */
+static int __init pSeries_enable_reloc_on_exc(void)
+{
+	long rc;
+	unsigned int delay, total_delay = 0;
+
+	while (1) {
+		rc = enable_reloc_on_exceptions();
+		if (!H_IS_LONG_BUSY(rc))
+			return rc;
+
+		delay = get_longbusy_msecs(rc);
+		total_delay += delay;
+		if (total_delay > 1000) {
+			pr_warn("Warning: Giving up waiting to enable "
+				"relocation on exceptions (%u msec)!\n",
+				total_delay);
+			return rc;
+		}
+
+		mdelay(delay);
+	}
+}
+
 static void __init pSeries_setup_arch(void)
 {
 	panic_timeout = 10;
@@ -402,6 +432,14 @@ static void __init pSeries_setup_arch(void)
 		ppc_md.enable_pmcs = pseries_lpar_enable_pmcs;
 	else
 		ppc_md.enable_pmcs = power4_enable_pmcs;
+
+	if (firmware_has_feature(FW_FEATURE_SET_MODE)) {
+		long rc;
+		if ((rc = pSeries_enable_reloc_on_exc()) != H_SUCCESS) {
+			pr_warn("Unable to enable relocation on exceptions: "
+				"%ld\n", rc);
+		}
+	}
 }
 
 static int __init pSeries_init_panel(void)

commit 1cf3d8b3d24cd383ddfd5442c83ec5c355ffc2f7
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Tue Oct 2 16:57:57 2012 +0000

    powerpc+of: Add of node/property notification chain for adds and removes
    
    This patch moves the notification chain for updates to the device tree
    from the powerpc/pseries code to the base OF code. This makes this
    functionality available to all architectures.
    
    Additionally the notification chain is updated to allow notifications
    for property add/remove/update. To make this work a pointer to a new
    struct (of_prop_reconfig) is passed to the routines in the notification chain.
    The of_prop_reconfig property contains a pointer to the node containing the
    property and a pointer to the property itself. In the case of property
    updates, the property pointer refers to the new property.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Acked-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e3cb7ae61658..e1a5b8a32d25 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -40,6 +40,7 @@
 #include <linux/seq_file.h>
 #include <linux/root_dev.h>
 #include <linux/cpuidle.h>
+#include <linux/of.h>
 
 #include <asm/mmu.h>
 #include <asm/processor.h>
@@ -63,7 +64,6 @@
 #include <asm/smp.h>
 #include <asm/firmware.h>
 #include <asm/eeh.h>
-#include <asm/pSeries_reconfig.h>
 
 #include "plpar_wrappers.h"
 #include "pseries.h"
@@ -258,7 +258,7 @@ static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long act
 	int err = NOTIFY_OK;
 
 	switch (action) {
-	case PSERIES_RECONFIG_ADD:
+	case OF_RECONFIG_ATTACH_NODE:
 		pci = np->parent->data;
 		if (pci) {
 			update_dn_pci_info(np, pci->phb);
@@ -389,7 +389,7 @@ static void __init pSeries_setup_arch(void)
 	/* Find and initialize PCI host bridges */
 	init_pci_config_tokens();
 	find_and_init_phbs();
-	pSeries_reconfig_notifier_register(&pci_dn_reconfig_nb);
+	of_reconfig_notifier_register(&pci_dn_reconfig_nb);
 
 	pSeries_nvram_init();
 

commit cd14457304c9d232267a3a76a2a43f1f791e545d
Author: Michael Neuling <mikey@neuling.org>
Date:   Thu Sep 6 21:24:57 2012 +0000

    powerpc: Dynamically calculate the dabrx based on kernel/user/hypervisor
    
    Currently we mark the DABRX to interrupt on all matches
    (hypervisor/kernel/user and then filter in software.  We can be a lot
    smarter now that we can set the DABRX dynamically.
    
    This sets the DABRX based on the flags passed by the user.
    
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index a3a69658a6ec..e3cb7ae61658 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -425,7 +425,7 @@ static int pseries_set_xdabr(unsigned long dabr, unsigned long dabrx)
 	if (dabrx == 0 && dabr == 0)
 		dabrx = DABRX_USER;
 	/* PAPR says we can only set kernel and user bits */
-	dabrx &= H_DABRX_KERNEL | H_DABRX_USER;
+	dabrx &= DABRX_KERNEL | DABRX_USER;
 
 	return plpar_hcall_norets(H_SET_XDABR, dabr, dabrx);
 }

commit 4474ef055c5d8cb8eaf002d69e49af71e3aa3a88
Author: Michael Neuling <mikey@neuling.org>
Date:   Thu Sep 6 21:24:56 2012 +0000

    powerpc: Rework set_dabr so it can take a DABRX value as well
    
    Rework set_dabr to take a DABRX value as well.
    
    Both the pseries and PS3 hypervisors do some checks on the DABRX
    values that are passed in the hcall.  This patch stops bogus values
    from being passed to hypervisor.  Also, in the case where we are
    clearing the breakpoint, where DABR and DABRX are zero, we modify the
    DABRX value to make it valid so that the hcall won't fail.
    
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 4a2cd48b21f6..a3a69658a6ec 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -414,16 +414,20 @@ static int __init pSeries_init_panel(void)
 }
 machine_arch_initcall(pseries, pSeries_init_panel);
 
-static int pseries_set_dabr(unsigned long dabr)
+static int pseries_set_dabr(unsigned long dabr, unsigned long dabrx)
 {
 	return plpar_hcall_norets(H_SET_DABR, dabr);
 }
 
-static int pseries_set_xdabr(unsigned long dabr)
+static int pseries_set_xdabr(unsigned long dabr, unsigned long dabrx)
 {
-	/* We want to catch accesses from kernel and userspace */
-	return plpar_hcall_norets(H_SET_XDABR, dabr,
-			H_DABRX_KERNEL | H_DABRX_USER);
+	/* Have to set at least one bit in the DABRX according to PAPR */
+	if (dabrx == 0 && dabr == 0)
+		dabrx = DABRX_USER;
+	/* PAPR says we can only set kernel and user bits */
+	dabrx &= H_DABRX_KERNEL | H_DABRX_USER;
+
+	return plpar_hcall_norets(H_SET_XDABR, dabr, dabrx);
 }
 
 #define CMO_CHARACTERISTICS_TOKEN 44

commit 35e5cfe27e674e4580408b34e7fc97e18460e048
Author: Gavin Shan <shangw@linux.vnet.ibm.com>
Date:   Fri Sep 7 22:44:02 2012 +0000

    powerpc/eeh: Move EEH initialization around
    
    Currently, we have 3 phases for EEH initialization on pSeries platform.
    All of them are done through builtin functions: platform initialization,
    EEH device creation, and EEH subsystem enablement. All of them are done
    no later than ppc_md.setup_arch. That means that the slab/slub isn't ready
    yet, so we have to allocate memory chunks on basis of PAGE_SIZE for those
    dynamically created EEH devices. That's pretty expensive.
    
    In order to utilize slab/slub for memory allocation, we have to move the EEH
    initialization functions around, but all of them should be called after slab
    is ready.
    
    Signed-off-by: Gavin Shan <shangw@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 36b774442b5c..4a2cd48b21f6 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -388,10 +388,8 @@ static void __init pSeries_setup_arch(void)
 
 	/* Find and initialize PCI host bridges */
 	init_pci_config_tokens();
-	eeh_pseries_init();
 	find_and_init_phbs();
 	pSeries_reconfig_notifier_register(&pci_dn_reconfig_nb);
-	eeh_init();
 
 	pSeries_nvram_init();
 

commit 06c887666803608c3efe3807eba0e362307db7c4
Author: Michael Neuling <mikey@neuling.org>
Date:   Wed Sep 5 19:17:49 2012 +0000

    powerpc: Use the XDABR hcall
    
    We never use the XDABR hcall since we check for DABR hcall first.
    XDABR syscall is better since it allows us to also set the DABRX.
    
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 51ecac920dd8..36b774442b5c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -529,10 +529,10 @@ static void __init pSeries_init_early(void)
 	if (firmware_has_feature(FW_FEATURE_LPAR))
 		hvc_vio_init_early();
 #endif
-	if (firmware_has_feature(FW_FEATURE_DABR))
-		ppc_md.set_dabr = pseries_set_dabr;
-	else if (firmware_has_feature(FW_FEATURE_XDABR))
+	if (firmware_has_feature(FW_FEATURE_XDABR))
 		ppc_md.set_dabr = pseries_set_xdabr;
+	else if (firmware_has_feature(FW_FEATURE_DABR))
+		ppc_md.set_dabr = pseries_set_dabr;
 
 	pSeries_cmo_feature_init();
 	iommu_init_early_pSeries();

commit 475c77edf826333aa61625f49d6a2bec26ecb5a6
Merge: 934e18b5cb45 1488d5158dcd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 23 14:02:12 2012 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci
    
    Pull PCI changes (including maintainer change) from Jesse Barnes:
     "This pull has some good cleanups from Bjorn and Yinghai, as well as
      some more code from Yinghai to better handle resource re-allocation
      when enabled.
    
      There's also a new initcall_debug feature from Arjan which will print
      out quirk timing information to help identify slow quirks for fixing
      or refinement (Yinghai sent in a few patches to do just that once the
      new debug code landed).
    
      Beyond that, I'm handing off PCI maintainership to Bjorn Helgaas.
      He's been a core PCI and Linux contributor for some time now, and has
      kindly volunteered to take over.  I just don't feel I have the time
      for PCI review and work that it deserves lately (I've taken on some
      other projects), and haven't been as responsive lately as I'd like, so
      I approached Bjorn asking if he'd like to manage things.  He's going
      to give it a try, and I'm confident he'll do at least as well as I
      have in keeping the tree managed, patches flowing, and keeping things
      stable."
    
    Fix up some fairly trivial conflicts due to other cleanups (mips device
    resource fixup cleanups clashing with list handling cleanup, ppc iseries
    removal clashing with pci_probe_only cleanup etc)
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci: (112 commits)
      PCI: Bjorn gets PCI hotplug too
      PCI: hand PCI maintenance over to Bjorn Helgaas
      unicore32/PCI: move <asm-generic/pci-bridge.h> include to asm/pci.h
      sparc/PCI: convert devtree and arch-probed bus addresses to resource
      powerpc/PCI: allow reallocation on PA Semi
      powerpc/PCI: convert devtree bus addresses to resource
      powerpc/PCI: compute I/O space bus-to-resource offset consistently
      arm/PCI: don't export pci_flags
      PCI: fix bridge I/O window bus-to-resource conversion
      x86/PCI: add spinlock held check to 'pcibios_fwaddrmap_lookup()'
      PCI / PCIe: Introduce command line option to disable ARI
      PCI: make acpihp use __pci_remove_bus_device instead
      PCI: export __pci_remove_bus_device
      PCI: Rename pci_remove_behind_bridge to pci_stop_and_remove_behind_bridge
      PCI: Rename pci_remove_bus_device to pci_stop_and_remove_bus_device
      PCI: print out PCI device info along with duration
      PCI: Move "pci reassigndev resource alignment" out of quirks.c
      PCI: Use class for quirk for usb host controller fixup
      PCI: Use class for quirk for ti816x class fixup
      PCI: Use class for quirk for intel e100 interrupt fixup
      ...

commit eb740b5f3e6559a8f1c22e2505914d07f9632881
Author: Gavin Shan <shangw@linux.vnet.ibm.com>
Date:   Mon Feb 27 20:04:04 2012 +0000

    powerpc/eeh: Introduce EEH device
    
    Original EEH implementation depends on struct pci_dn heavily. However,
    EEH shouldn't depend on that actually because EEH needn't share much
    information with other PCI components. That's to say, EEH should have
    worked independently.
    
    The patch introduces struct eeh_dev so that EEH core components needn't
    be working based on struct pci_dn in future. Also, struct pci_dn, struct
    eeh_dev instances are created in dynamic fasion and the binding with EEH
    device, OF node, PCI device is implemented as well.
    
    The EEH devices are created after PHBs are detected and initialized, but
    PCI emunation hasn't started yet. Apart from that, PHB might be created
    dynamically through DLPAR component and the EEH devices should be creatd
    as well. Another case might be OF node is created dynamically by DR
    (Dynamic Reconfiguration), which has been defined by PAPR. For those OF
    nodes created by DR, EEH devices should be also created accordingly. The
    binding between EEH device and OF node is done while the EEH device is
    initially created.
    
    The binding between EEH device and PCI device should be done after PCI
    emunation is done. Besides, PCI hotplug also needs the binding so that
    the EEH devices could be traced from the newly coming PCI buses or PCI
    devices.
    
    Signed-off-by: Gavin Shan <shangw@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 62b827626ca6..8f137af616af 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -260,8 +260,12 @@ static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long act
 	switch (action) {
 	case PSERIES_RECONFIG_ADD:
 		pci = np->parent->data;
-		if (pci)
+		if (pci) {
 			update_dn_pci_info(np, pci->phb);
+
+			/* Create EEH device for the OF node */
+			eeh_dev_init(np, pci->phb);
+		}
 		break;
 	default:
 		err = NOTIFY_DONE;

commit aa1e6374ae11788752535ae0c8c6395c9cad1393
Author: Gavin Shan <shangw@linux.vnet.ibm.com>
Date:   Mon Feb 27 20:03:53 2012 +0000

    powerpc/eeh: Platform dependent EEH operations
    
    EEH has been implemented on RTAS-compliant pSeries platform.
    That's to say, the EEH operations will be implemented through RTAS
    calls eventually. The situation limited feasible extension on EEH.
    In order to support EEH on multiple platforms like pseries and powernv
    simutaneously. We have to split the platform dependent EEH options
    up out of current implementation.
    
    The patch addresses supporting EEH on multiple platforms. The pseries
    platform dependent EEH operations will be abstracted by struct eeh_ops.
    EEH core components will be built based on the registered EEH operations.
    With the mechanism, what the individual platform needs to do is implement
    platform dependent EEH operations.
    
    For now, the pseries platform is covered under the mechanism. That means
    we have to think about other platforms to support EEH, like powernv.
    Besides, we only have framework for the mechanism and we have to implement
    it for pseries platform later.
    
    Signed-off-by: Gavin Shan <shangw@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index d928412cfb32..62b827626ca6 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -381,6 +381,7 @@ static void __init pSeries_setup_arch(void)
 
 	/* Find and initialize PCI host bridges */
 	init_pci_config_tokens();
+	eeh_pseries_init();
 	find_and_init_phbs();
 	pSeries_reconfig_notifier_register(&pci_dn_reconfig_nb);
 	eeh_init();

commit 673c975624895c4db2edff32601d9c6475b2d39e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:18:58 2012 -0700

    powerpc/PCI: replace pci_probe_only with pci_flags
    
    We already use pci_flags, so this just sets pci_flags directly and removes
    the intermediate step of figuring out pci_probe_only, then using it to set
    pci_flags.
    
    The PCI core provides a pci_flags definition (currently __weak), so drop
    the powerpc definitions in favor of that.
    
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 386e2656c231..fc2a6f60f665 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -380,8 +380,8 @@ static void __init pSeries_setup_arch(void)
 
 	fwnmi_init();
 
-	/* By default, only probe PCI (can be overriden by rtas_pci */
-	pci_probe_only = 1;
+	/* By default, only probe PCI (can be overriden by rtas_pci) */
+	pci_add_flags(PCI_PROBE_ONLY);
 
 	/* Find and initialize PCI host bridges */
 	init_pci_config_tokens();

commit 3c13be017abe041e495862d50dbd83093e09cd6a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:18:58 2012 -0700

    powerpc/PCI: make pci_probe_only default to 0
    
    pci_probe_only is set on ppc64 to prevent resource re-allocation
    by the core. It's meant to be used in very specific circumstances
    such as when operating under a hypervisor that may prevent such
    re-allocation.
    
    Instead of default to 1, we make it default to 0 and explicitly
    set it in the few cases where we need it.
    
    This fixes FSL PCI which wants it clear among others.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f79f1278dfca..386e2656c231 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -380,6 +380,9 @@ static void __init pSeries_setup_arch(void)
 
 	fwnmi_init();
 
+	/* By default, only probe PCI (can be overriden by rtas_pci */
+	pci_probe_only = 1;
+
 	/* Find and initialize PCI host bridges */
 	init_pci_config_tokens();
 	find_and_init_phbs();

commit e55d7f737d3daf4aaf41945c1829138c608662e9
Author: Kyle Moffett <Kyle.D.Moffett@boeing.com>
Date:   Thu Dec 22 10:19:14 2011 +0000

    powerpc/mpic: Remove duplicate MPIC_WANTS_RESET flag
    
    There are two separate flags controlling whether or not the MPIC is
    reset during initialization, which is completely unnecessary, and only
    one of them can be specified in the device tree.
    
    Also, most platforms in-tree right now do actually want to reset the
    MPIC during initialization anyways, which means lots of duplicate code
    passing the MPIC_WANTS_RESET flag.
    
    Fix all of the callers which currently do not pass the MPIC_WANTS_RESET
    flag to pass the MPIC_NO_RESET flag, then remove the MPIC_WANTS_RESET
    flag and make the code reset the MPIC by default.
    
    Signed-off-by: Kyle Moffett <Kyle.D.Moffett@boeing.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 6d0a5dfbb9fc..d928412cfb32 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -190,7 +190,8 @@ static void __init pseries_mpic_init_IRQ(void)
 	BUG_ON(openpic_addr == 0);
 
 	/* Setup the openpic driver */
-	mpic = mpic_alloc(pSeries_mpic_node, openpic_addr, 0, 16, 0, " MPIC     ");
+	mpic = mpic_alloc(pSeries_mpic_node, openpic_addr,
+			MPIC_NO_RESET, 16, 0, " MPIC     ");
 	BUG_ON(mpic == NULL);
 
 	/* Add ISUs */

commit 5019609fce965dbdc66a7d947385fe92ca522231
Author: Kyle Moffett <Kyle.D.Moffett@boeing.com>
Date:   Thu Dec 22 10:19:12 2011 +0000

    powerpc/mpic: Remove MPIC_BROKEN_FRR_NIRQS and duplicate irq_count
    
    The mpic->irq_count variable is only used as a software error-checking
    limit to determine whether or not an IRQ number is valid.  In board code
    which does not manually specify an IRQ count to mpic_alloc(), i.e. 0, it
    is automatically detected from the number of ISUs and the ISU size.
    
    In practice, all hardware ends up with irq_count == num_sources, so all
    of the runtime checks on mpic->irq_count should just check the value of
    mpic->num_sources instead.
    
    When platform hardware does not correctly report the number of IRQs,
    which only happens on the MPC85xx/MPC86xx, the MPIC_BROKEN_FRR_NIRQS
    flag is used to override the detected value of num_sources with the
    manual irq_count parameter.  Since there's no need to manually specify
    the number of IRQs except in this case, the extra flag can be eliminated
    and the test changed to "irq_count != 0".
    
    Signed-off-by: Kyle Moffett <Kyle.D.Moffett@boeing.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f79f1278dfca..6d0a5dfbb9fc 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -190,9 +190,7 @@ static void __init pseries_mpic_init_IRQ(void)
 	BUG_ON(openpic_addr == 0);
 
 	/* Setup the openpic driver */
-	mpic = mpic_alloc(pSeries_mpic_node, openpic_addr, 0,
-			  16, 250, /* isu size, irq count */
-			  " MPIC     ");
+	mpic = mpic_alloc(pSeries_mpic_node, openpic_addr, 0, 16, 0, " MPIC     ");
 	BUG_ON(mpic == NULL);
 
 	/* Add ISUs */

commit 43ca5d347acc0dcae988dbd38b5bb5a930744a75
Merge: efdad722ef4d 2440c01e10f0
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Dec 16 11:09:21 2011 +1100

    Merge branch 'kexec' into next

commit a934904d8ac2411ca329fc50daa29ab35a8f198b
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Nov 30 00:23:14 2011 +0000

    powerpc: Reduce pseries panic timeout from 180s to 10s
    
    We've had a 180 second panic timeout on ppc64 for as long as I
    can remember. This patch reduces it to 10 seconds on pseries for a few
    reasons:
    
    - Almost all pseries machines have a hypervisor console so panic
      output will be available in a scrollback buffer.
    
    - The 180 seconds impacts our availability, users (other than
      kernel hackers) just want the box to come back around so it
      can continue its work.
    
    - I spend a lot of my life staring at the 180 second panic timeout.
      Many pseries machines take minutes to power cycle, so it's quicker
      to sit through the 180 seconds than it is to power cycle.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 01df08dbc43c..992d797e07da 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -353,6 +353,8 @@ early_initcall(alloc_dispatch_log_kmem_cache);
 
 static void __init pSeries_setup_arch(void)
 {
+	panic_timeout = 10;
+
 	/* Discover PIC type and setup ppc_md accordingly */
 	pseries_discover_pic();
 

commit e179816ce60033ce560b28e01bc555ed5116cbe9
Author: Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
Date:   Wed Nov 30 02:46:55 2011 +0000

    powerpc/cpuidle: Enable cpuidle and directly call cpuidle_idle_call() for pSeries
    
    This patch enables cpuidle for pSeries and pSeries_idle is
    directly called from the idle loop. As a result of pSeries_idle, cpuidle
    driver registered with cpuidle subsystem comes into action. On
    failure of loading of the driver or cpuidle framework default idle
    is executed as part of the function. This patch
    also removes the routines pseries_shared_idle_sleep and
    pseries_dedicated_idle_sleep as they are now implemented as part of
    pseries_idle cpuidle driver.
    
    Signed-off-by: Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
    Signed-off-by: Trinabh Gupta <g.trinabh@gmail.com>
    Signed-off-by: Arun R Bharadwaj <arun.r.bharadwaj@gmail.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f2446da7f2d5..164839cb9fcd 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -39,6 +39,7 @@
 #include <linux/irq.h>
 #include <linux/seq_file.h>
 #include <linux/root_dev.h>
+#include <linux/cpuidle.h>
 
 #include <asm/mmu.h>
 #include <asm/processor.h>
@@ -74,9 +75,6 @@ EXPORT_SYMBOL(CMO_PageSize);
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 
-static void pseries_shared_idle_sleep(void);
-static void pseries_dedicated_idle_sleep(void);
-
 static struct device_node *pSeries_mpic_node;
 
 static void pSeries_show_cpuinfo(struct seq_file *m)
@@ -351,6 +349,21 @@ static int alloc_dispatch_log_kmem_cache(void)
 }
 early_initcall(alloc_dispatch_log_kmem_cache);
 
+static void pSeries_idle(void)
+{
+	/* This would call on the cpuidle framework, and the back-end pseries
+	 * driver to  go to idle states
+	 */
+	if (cpuidle_idle_call()) {
+		/* On error, execute default handler
+		 * to go into low thread priority and possibly
+		 * low power mode.
+		 */
+		HMT_low();
+		HMT_very_low();
+	}
+}
+
 static void __init pSeries_setup_arch(void)
 {
 	/* Discover PIC type and setup ppc_md accordingly */
@@ -373,18 +386,9 @@ static void __init pSeries_setup_arch(void)
 
 	pSeries_nvram_init();
 
-	/* Choose an idle loop */
 	if (firmware_has_feature(FW_FEATURE_SPLPAR)) {
 		vpa_init(boot_cpuid);
-		if (get_lppaca()->shared_proc) {
-			printk(KERN_DEBUG "Using shared processor idle loop\n");
-			ppc_md.power_save = pseries_shared_idle_sleep;
-		} else {
-			printk(KERN_DEBUG "Using dedicated idle loop\n");
-			ppc_md.power_save = pseries_dedicated_idle_sleep;
-		}
-	} else {
-		printk(KERN_DEBUG "Using default idle loop\n");
+		ppc_md.power_save = pSeries_idle;
 	}
 
 	if (firmware_has_feature(FW_FEATURE_LPAR))
@@ -585,77 +589,6 @@ static int __init pSeries_probe(void)
 	return 1;
 }
 
-static void pseries_dedicated_idle_sleep(void)
-{ 
-	unsigned int cpu = smp_processor_id();
-	unsigned long start_snooze;
-	unsigned long in_purr, out_purr;
-	long snooze = __get_cpu_var(smt_snooze_delay);
-
-	/*
-	 * Indicate to the HV that we are idle. Now would be
-	 * a good time to find other work to dispatch.
-	 */
-	get_lppaca()->idle = 1;
-	get_lppaca()->donate_dedicated_cpu = 1;
-	in_purr = mfspr(SPRN_PURR);
-
-	/*
-	 * We come in with interrupts disabled, and need_resched()
-	 * has been checked recently.  If we should poll for a little
-	 * while, do so.
-	 */
-	if (snooze) {
-		start_snooze = get_tb() + snooze * tb_ticks_per_usec;
-		local_irq_enable();
-		set_thread_flag(TIF_POLLING_NRFLAG);
-
-		while ((snooze < 0) || (get_tb() < start_snooze)) {
-			if (need_resched() || cpu_is_offline(cpu))
-				goto out;
-			ppc64_runlatch_off();
-			HMT_low();
-			HMT_very_low();
-		}
-
-		HMT_medium();
-		clear_thread_flag(TIF_POLLING_NRFLAG);
-		smp_mb();
-		local_irq_disable();
-		if (need_resched() || cpu_is_offline(cpu))
-			goto out;
-	}
-
-	cede_processor();
-
-out:
-	HMT_medium();
-	out_purr = mfspr(SPRN_PURR);
-	get_lppaca()->wait_state_cycles += out_purr - in_purr;
-	get_lppaca()->donate_dedicated_cpu = 0;
-	get_lppaca()->idle = 0;
-}
-
-static void pseries_shared_idle_sleep(void)
-{
-	/*
-	 * Indicate to the HV that we are idle. Now would be
-	 * a good time to find other work to dispatch.
-	 */
-	get_lppaca()->idle = 1;
-
-	/*
-	 * Yield the processor to the hypervisor.  We return if
-	 * an external interrupt occurs (which are driven prior
-	 * to returning here) or if a prod occurs from another
-	 * processor. When returning here, external interrupts
-	 * are enabled.
-	 */
-	cede_processor();
-
-	get_lppaca()->idle = 0;
-}
-
 static int pSeries_pci_probe_mode(struct pci_bus *bus)
 {
 	if (firmware_has_feature(FW_FEATURE_LPAR))

commit 707827f3387d9b260d50fa697885a4042cea3bf4
Author: Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
Date:   Wed Nov 30 02:46:42 2011 +0000

    powerpc/cpuidle: cpuidle driver for pSeries
    
    This patch implements a back-end cpuidle driver for pSeries
    based on pseries_dedicated_idle_loop and pseries_shared_idle_loop
    routines.  The driver is built only if CONFIG_CPU_IDLE is set. This
    cpuidle driver uses global registration of idle states and
    not per-cpu.
    
    Signed-off-by: Deepthi Dharwar <deepthi@linux.vnet.ibm.com>
    Signed-off-by: Trinabh Gupta <g.trinabh@gmail.com>
    Signed-off-by: Arun R Bharadwaj <arun.r.bharadwaj@gmail.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 01df08dbc43c..f2446da7f2d5 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -585,9 +585,6 @@ static int __init pSeries_probe(void)
 	return 1;
 }
 
-
-DECLARE_PER_CPU(long, smt_snooze_delay);
-
 static void pseries_dedicated_idle_sleep(void)
 { 
 	unsigned int cpu = smp_processor_id();

commit be8bec56dfac0574c4c08a50cd37e09bea941e3f
Author: Kyle Moffett <Kyle.D.Moffett@boeing.com>
Date:   Fri Dec 2 06:28:03 2011 +0000

    powerpc/mpic: Invert the meaning of MPIC_PRIMARY
    
    It turns out that there are only 2 in-tree platforms which use MPICs
    which are not "primary":  IBM Cell and PowerMac.  To reduce the
    complexity of the typical board setup code, invert the MPIC_PRIMARY bit
    into MPIC_SECONDARY.
    
    Signed-off-by: Kyle Moffett <Kyle.D.Moffett@boeing.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index c3408ca8855e..01df08dbc43c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -192,8 +192,7 @@ static void __init pseries_mpic_init_IRQ(void)
 	BUG_ON(openpic_addr == 0);
 
 	/* Setup the openpic driver */
-	mpic = mpic_alloc(pSeries_mpic_node, openpic_addr,
-			  MPIC_PRIMARY,
+	mpic = mpic_alloc(pSeries_mpic_node, openpic_addr, 0,
 			  16, 250, /* isu size, irq count */
 			  " MPIC     ");
 	BUG_ON(mpic == NULL);

commit 4b16f8e2d6d64249f0ed3ca7fe2a319d0dde2719
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri Jul 22 18:24:23 2011 -0400

    powerpc: various straight conversions from module.h --> export.h
    
    All these files were including module.h just for the basic
    EXPORT_SYMBOL infrastructure.  We can shift them off to the
    export.h header which is a way smaller footprint and thus
    realize some compile time gains.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 0969fd98c4fa..c3408ca8855e 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -34,7 +34,7 @@
 #include <linux/pci.h>
 #include <linux/utsname.h>
 #include <linux/adb.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/delay.h>
 #include <linux/irq.h>
 #include <linux/seq_file.h>

commit 711ef84e80ec6f937ad59c7a00490421a5c92867
Author: Anton Blanchard <anton@samba.org>
Date:   Mon Jul 25 01:46:33 2011 +0000

    powerpc/pseries: Cleanup VPA registration and deregistration errors
    
    Make the VPA, SLB shadow and DTL registration and deregistration
    functions print consistent messages on error. I needed the firmware
    error code while chasing a kexec bug but we weren't printing it.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index d00e52926b71..0969fd98c4fa 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -324,8 +324,9 @@ static int alloc_dispatch_logs(void)
 	dtl->enqueue_to_dispatch_time = DISPATCH_LOG_BYTES;
 	ret = register_dtl(hard_smp_processor_id(), __pa(dtl));
 	if (ret)
-		pr_warn("DTL registration failed for boot cpu %d (%d)\n",
-			smp_processor_id(), ret);
+		pr_err("WARNING: DTL registration of cpu %d (hw %d) failed "
+		       "with %d\n", smp_processor_id(),
+		       hard_smp_processor_id(), ret);
 	get_paca()->lppaca_ptr->dtl_enable_mask = 2;
 
 	return 0;

commit 4d2bb3f5003617cb42b89faefd0009c505c3abd5
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu May 12 13:46:38 2011 +1000

    powerpc/pseries: Re-implement HVSI as part of hvc_vio
    
    On pseries machines, consoles are provided by the hypervisor using
    a low level get_chars/put_chars type interface. However, this is
    really just a transport to the service processor which implements
    them either as "raw" console (networked consoles, HMC, ...) or as
    "hvsi" serial ports.
    
    The later is a simple packet protocol on top of the raw character
    interface that is supposed to convey additional "serial port" style
    semantics. In practice however, all it does is provide a way to
    read the CD line and set/clear our DTR line, that's it.
    
    We currently implement the "raw" protocol as an hvc console backend
    (/dev/hvcN) and the "hvsi" protocol using a separate tty driver
    (/dev/hvsi0).
    
    However this is quite impractical. The arbitrary difference between
    the two type of devices has been a major source of user (and distro)
    confusion. Additionally, there's an additional mini -hvsi implementation
    in the pseries platform code for our low level debug console and early
    boot kernel messages, which means code duplication, though that low
    level variant is impractical as it's incapable of doing the initial
    protocol negociation to establish the link to the FSP.
    
    This essentially replaces the dedicated hvsi driver and the platform
    udbg code completely by extending the existing hvc_vio backend used
    in "raw" mode so that:
    
     - It now supports HVSI as well
     - We add support for hvc backend providing tiocm{get,set}
     - It also provides a udbg interface for early debug and boot console
    
    This is overall less code, though this will only be obvious once we
    remove the old "hvsi" driver, which is still available for now. When
    the old driver is enabled, the new code still kicks in for the low
    level udbg console, replacing the old mini implementation in the platform
    code, it just doesn't provide the higher level "hvc" interface.
    
    In addition to producing generally simler code, this has several benefits
    over our current situation:
    
     - The user/distro only has to deal with /dev/hvcN for the hypervisor
    console, avoiding all sort of confusion that has plagued us in the past
    
     - The tty, kernel and low level debug console all use the same code
    base which supports the full protocol establishment process, thus the
    console is now available much earlier than it used to be with the
    old HVSI driver. The kernel console works much earlier and udbg is
    available much earlier too. Hackers can enable a hard coded very-early
    debug console as well that works with HVSI (previously that was only
    supported for the "raw" mode).
    
    I've tried to keep the same semantics as hvsi relative to how I react
    to things like CD changes, with some subtle differences though:
    
     - I clear DTR on close if HUPCL is set
    
     - Current hvsi triggers a hangup if it detects a up->down transition
       on CD (you can still open a console with CD down). My new implementation
       triggers a hangup if the link to the FSP is severed, and severs it upon
       detecting a up->down transition on CD.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 593acceeff96..d00e52926b71 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -512,9 +512,10 @@ static void __init pSeries_init_early(void)
 {
 	pr_debug(" -> pSeries_init_early()\n");
 
+#ifdef CONFIG_HVC_CONSOLE
 	if (firmware_has_feature(FW_FEATURE_LPAR))
-		find_udbg_vterm();
-
+		hvc_vio_init_early();
+#endif
 	if (firmware_has_feature(FW_FEATURE_DABR))
 		ppc_md.set_dabr = pseries_set_dabr;
 	else if (firmware_has_feature(FW_FEATURE_XDABR))

commit af442a1baa6d00117cc7e7377ce7e6a545268684
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Wed May 4 12:54:16 2011 +0000

    powerpc: Ensure dtl buffers do not cross 4k boundary
    
    Future releases of fimrware will enforce a requirement that DTL buffers
    do not cross a 4k boundary. Commit
    127493d5dc73589cbe00ea5ec8357cc2a4c0d82a satisfies this requirement for
    CONFIG_VIRT_CPU_ACCOUNTING=y kernels, but if !CONFIG_VIRT_CPU_ACCOUNTING
    && CONFIG_DTL=y, the current code will fail at dtl registration time.
    Fix this by making the kmem cache from
    127493d5dc73589cbe00ea5ec8357cc2a4c0d82a visible outside of setup.c and
    using the same cache in both dtl.c and setup.c. This requires a bit of
    reorganization to ensure ordering of the kmem cache and buffer
    allocations.
    
    Note: Since firmware now limits the size of the buffer, I made
    dtl_buf_entries read-only in debugfs.
    
    Tested with upcoming firmware with the 4 combinations of
    CONFIG_VIRT_CPU_ACCOUNTING and CONFIG_DTL.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 1689adccc6d7..593acceeff96 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -278,6 +278,8 @@ static struct notifier_block pci_dn_reconfig_nb = {
 	.notifier_call = pci_dn_reconfig_notifier,
 };
 
+struct kmem_cache *dtl_cache;
+
 #ifdef CONFIG_VIRT_CPU_ACCOUNTING
 /*
  * Allocate space for the dispatch trace log for all possible cpus
@@ -289,18 +291,12 @@ static int alloc_dispatch_logs(void)
 	int cpu, ret;
 	struct paca_struct *pp;
 	struct dtl_entry *dtl;
-	struct kmem_cache *dtl_cache;
 
 	if (!firmware_has_feature(FW_FEATURE_SPLPAR))
 		return 0;
 
-	dtl_cache = kmem_cache_create("dtl", DISPATCH_LOG_BYTES,
-						DISPATCH_LOG_BYTES, 0, NULL);
-	if (!dtl_cache) {
-		pr_warn("Failed to create dispatch trace log buffer cache\n");
-		pr_warn("Stolen time statistics will be unreliable\n");
+	if (!dtl_cache)
 		return 0;
-	}
 
 	for_each_possible_cpu(cpu) {
 		pp = &paca[cpu];
@@ -334,10 +330,27 @@ static int alloc_dispatch_logs(void)
 
 	return 0;
 }
-
-early_initcall(alloc_dispatch_logs);
+#else /* !CONFIG_VIRT_CPU_ACCOUNTING */
+static inline int alloc_dispatch_logs(void)
+{
+	return 0;
+}
 #endif /* CONFIG_VIRT_CPU_ACCOUNTING */
 
+static int alloc_dispatch_log_kmem_cache(void)
+{
+	dtl_cache = kmem_cache_create("dtl", DISPATCH_LOG_BYTES,
+						DISPATCH_LOG_BYTES, 0, NULL);
+	if (!dtl_cache) {
+		pr_warn("Failed to create dispatch trace log buffer cache\n");
+		pr_warn("Stolen time statistics will be unreliable\n");
+		return 0;
+	}
+
+	return alloc_dispatch_logs();
+}
+early_initcall(alloc_dispatch_log_kmem_cache);
+
 static void __init pSeries_setup_arch(void)
 {
 	/* Discover PIC type and setup ppc_md accordingly */

commit 9ee820fa005254dfc816330f6654f14dcb2beee1
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Wed May 4 16:01:20 2011 +1000

    powerpc/pseries: Add page coalescing support
    
    Adds support for page coalescing, which is a feature on IBM Power servers
    which allows for coalescing identical pages between logical partitions.
    Hint text pages as coalesce candidates, since they are the most likely
    pages to be able to be coalesced between partitions. This patch also
    exports some page coalescing statistics available from firmware via
    lparcfg.
    
    [BenH: Moved a couple of things around to fix compile problems]
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index ab73ad2ff59d..1689adccc6d7 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -405,6 +405,16 @@ static int pseries_set_xdabr(unsigned long dabr)
 #define CMO_CHARACTERISTICS_TOKEN 44
 #define CMO_MAXLENGTH 1026
 
+void pSeries_coalesce_init(void)
+{
+	struct hvcall_mpp_x_data mpp_x_data;
+
+	if (firmware_has_feature(FW_FEATURE_CMO) && !h_get_mpp_x(&mpp_x_data))
+		powerpc_firmware_features |= FW_FEATURE_XCMO;
+	else
+		powerpc_firmware_features &= ~FW_FEATURE_XCMO;
+}
+
 /**
  * fw_cmo_feature_init - FW_FEATURE_CMO is not stored in ibm,hypertas-functions,
  * handle that here. (Stolen from parse_system_parameter_string)
@@ -474,6 +484,7 @@ void pSeries_cmo_feature_init(void)
 		pr_debug("CMO enabled, PrPSP=%d, SecPSP=%d\n", CMO_PrPSP,
 		         CMO_SecPSP);
 		powerpc_firmware_features |= FW_FEATURE_CMO;
+		pSeries_coalesce_init();
 	} else
 		pr_debug("CMO not enabled, PrPSP=%d, SecPSP=%d\n", CMO_PrPSP,
 		         CMO_SecPSP);

commit 0b05ac6e24807f0c26f763b3a546c0bcbf84125f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Apr 4 13:46:58 2011 +1000

    powerpc/xics: Rewrite XICS driver
    
    This is a significant rework of the XICS driver, too significant to
    conveniently break it up into a series of smaller patches to be honest.
    
    The driver is moved to a more generic location to allow new platforms
    to use it, and is broken up into separate ICP and ICS "backends". For
    now we have the native and "hypervisor" ICP backends and one common
    RTAS ICS backend.
    
    The driver supports one ICP backend instanciation, and many ICS ones,
    in order to accomodate future platforms with multiple possibly different
    interrupt "sources" mechanisms.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 6c42cfde8415..ab73ad2ff59d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -53,9 +53,9 @@
 #include <asm/irq.h>
 #include <asm/time.h>
 #include <asm/nvram.h>
-#include "xics.h"
 #include <asm/pmc.h>
 #include <asm/mpic.h>
+#include <asm/xics.h>
 #include <asm/ppc-pci.h>
 #include <asm/i8259.h>
 #include <asm/udbg.h>
@@ -205,6 +205,9 @@ static void __init pseries_mpic_init_IRQ(void)
 		mpic_assign_isu(mpic, n, isuaddr);
 	}
 
+	/* Setup top-level get_irq */
+	ppc_md.get_irq = mpic_get_irq;
+
 	/* All ISUs are setup, complete initialization */
 	mpic_init(mpic);
 
@@ -214,7 +217,7 @@ static void __init pseries_mpic_init_IRQ(void)
 
 static void __init pseries_xics_init_IRQ(void)
 {
-	xics_init_IRQ();
+	xics_init();
 	pseries_setup_i8259_cascade();
 }
 
@@ -238,7 +241,6 @@ static void __init pseries_discover_pic(void)
 		if (strstr(typep, "open-pic")) {
 			pSeries_mpic_node = of_node_get(np);
 			ppc_md.init_IRQ       = pseries_mpic_init_IRQ;
-			ppc_md.get_irq        = mpic_get_irq;
 			setup_kexec_cpu_down_mpic();
 			smp_init_pseries_mpic();
 			return;

commit 127493d5dc73589cbe00ea5ec8357cc2a4c0d82a
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Wed Apr 13 19:45:59 2011 +0000

    powerpc/pseries: Use a kmem cache for DTL buffers
    
    PAPR specifies that DTL buffers can not cross AMS environments (aka CMO
    in the PAPR) and can not cross a memory entitlement granule boundary
    (4k). This is found in section 14.11.3.2 H_REGISTER_VPA of the PAPR.
    kmalloc does not guarantee an alignment of the allocation, though,
    beyond 8 bytes (at least in my understanding). Create a special kmem
    cache for DTL buffers with the alignment requirement.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 000724149089..6c42cfde8415 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -287,14 +287,22 @@ static int alloc_dispatch_logs(void)
 	int cpu, ret;
 	struct paca_struct *pp;
 	struct dtl_entry *dtl;
+	struct kmem_cache *dtl_cache;
 
 	if (!firmware_has_feature(FW_FEATURE_SPLPAR))
 		return 0;
 
+	dtl_cache = kmem_cache_create("dtl", DISPATCH_LOG_BYTES,
+						DISPATCH_LOG_BYTES, 0, NULL);
+	if (!dtl_cache) {
+		pr_warn("Failed to create dispatch trace log buffer cache\n");
+		pr_warn("Stolen time statistics will be unreliable\n");
+		return 0;
+	}
+
 	for_each_possible_cpu(cpu) {
 		pp = &paca[cpu];
-		dtl = kmalloc_node(DISPATCH_LOG_BYTES, GFP_KERNEL,
-				   cpu_to_node(cpu));
+		dtl = kmem_cache_alloc(dtl_cache, GFP_KERNEL);
 		if (!dtl) {
 			pr_warn("Failed to allocate dispatch trace log for cpu %d\n",
 				cpu);

commit f86d6b9b36a5d0923fa2abaacd425e328668fe16
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Thu Mar 31 18:49:45 2011 +0000

    powerpc/pseries: Don't register global initcall
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index c319d04aa799..000724149089 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -378,7 +378,7 @@ static int __init pSeries_init_panel(void)
 
 	return 0;
 }
-arch_initcall(pSeries_init_panel);
+machine_arch_initcall(pseries, pSeries_init_panel);
 
 static int pseries_set_dabr(unsigned long dabr)
 {

commit ec775d0e70eb6b7116406b3441cb8501c2849dd2
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Mar 25 16:45:20 2011 +0100

    powerpc: Convert to new irq_* function names
    
    Scripted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 2a0089a2c829..c319d04aa799 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -114,7 +114,7 @@ static void __init fwnmi_init(void)
 
 static void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc)
 {
-	struct irq_chip *chip = get_irq_desc_chip(desc);
+	struct irq_chip *chip = irq_desc_get_chip(desc);
 	unsigned int cascade_irq = i8259_irq();
 
 	if (cascade_irq != NO_IRQ)
@@ -169,7 +169,7 @@ static void __init pseries_setup_i8259_cascade(void)
 		printk(KERN_DEBUG "pic: PCI 8259 intack at 0x%016lx\n", intack);
 	i8259_init(found, intack);
 	of_node_put(found);
-	set_irq_chained_handler(cascade, pseries_8259_cascade);
+	irq_set_chained_handler(cascade, pseries_8259_cascade);
 }
 
 static void __init pseries_mpic_init_IRQ(void)

commit 79f26c268ebad29bd75d078cfc09d3d82b30ccbd
Author: Lennert Buytenhek <buytenh@wantstofly.org>
Date:   Mon Mar 7 13:59:45 2011 +0000

    powerpc: platforms/pseries irq_data conversion.
    
    Signed-off-by: Lennert Buytenhek <buytenh@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index d345bfd56bbe..2a0089a2c829 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -114,10 +114,13 @@ static void __init fwnmi_init(void)
 
 static void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc)
 {
+	struct irq_chip *chip = get_irq_desc_chip(desc);
 	unsigned int cascade_irq = i8259_irq();
+
 	if (cascade_irq != NO_IRQ)
 		generic_handle_irq(cascade_irq);
-	desc->chip->eoi(irq);
+
+	chip->irq_eoi(&desc->irq_data);
 }
 
 static void __init pseries_setup_i8259_cascade(void)

commit cf9efce0ce3136fa076f53e53154e98455229514
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Aug 26 19:56:43 2010 +0000

    powerpc: Account time using timebase rather than PURR
    
    Currently, when CONFIG_VIRT_CPU_ACCOUNTING is enabled, we use the
    PURR register for measuring the user and system time used by
    processes, as well as other related times such as hardirq and
    softirq times.  This turns out to be quite confusing for users
    because it means that a program will often be measured as taking
    less time when run on a multi-threaded processor (SMT2 or SMT4 mode)
    than it does when run on a single-threaded processor (ST mode), even
    though the program takes longer to finish.  The discrepancy is
    accounted for as stolen time, which is also confusing, particularly
    when there are no other partitions running.
    
    This changes the accounting to use the timebase instead, meaning that
    the reported user and system times are the actual number of real-time
    seconds that the program was executing on the processor thread,
    regardless of which SMT mode the processor is in.  Thus a program will
    generally show greater user and system times when run on a
    multi-threaded processor than on a single-threaded processor.
    
    On pSeries systems on POWER5 or later processors, we measure the
    stolen time (time when this partition wasn't running) using the
    hypervisor dispatch trace log.  We check for new entries in the
    log on every entry from user mode and on every transition from
    kernel process context to soft or hard IRQ context (i.e. when
    account_system_vtime() gets called).  So that we can correctly
    distinguish time stolen from user time and time stolen from system
    time, without having to check the log on every exit to user mode,
    we store separate timestamps for exit to user mode and entry from
    user mode.
    
    On systems that have a SPURR (POWER6 and POWER7), we read the SPURR
    in account_system_vtime() (as before), and then apportion the SPURR
    ticks since the last time we read it between scaled user time and
    scaled system time according to the relative proportions of user
    time and system time over the same interval.  This avoids having to
    read the SPURR on every kernel entry and exit.  On systems that have
    PURR but not SPURR (i.e., POWER5), we do the same using the PURR
    rather than the SPURR.
    
    This disables the DTL user interface in /sys/debug/kernel/powerpc/dtl
    for now since it conflicts with the use of the dispatch trace log
    by the time accounting code.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index a6d19e3a505e..d345bfd56bbe 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -273,6 +273,58 @@ static struct notifier_block pci_dn_reconfig_nb = {
 	.notifier_call = pci_dn_reconfig_notifier,
 };
 
+#ifdef CONFIG_VIRT_CPU_ACCOUNTING
+/*
+ * Allocate space for the dispatch trace log for all possible cpus
+ * and register the buffers with the hypervisor.  This is used for
+ * computing time stolen by the hypervisor.
+ */
+static int alloc_dispatch_logs(void)
+{
+	int cpu, ret;
+	struct paca_struct *pp;
+	struct dtl_entry *dtl;
+
+	if (!firmware_has_feature(FW_FEATURE_SPLPAR))
+		return 0;
+
+	for_each_possible_cpu(cpu) {
+		pp = &paca[cpu];
+		dtl = kmalloc_node(DISPATCH_LOG_BYTES, GFP_KERNEL,
+				   cpu_to_node(cpu));
+		if (!dtl) {
+			pr_warn("Failed to allocate dispatch trace log for cpu %d\n",
+				cpu);
+			pr_warn("Stolen time statistics will be unreliable\n");
+			break;
+		}
+
+		pp->dtl_ridx = 0;
+		pp->dispatch_log = dtl;
+		pp->dispatch_log_end = dtl + N_DISPATCH_LOG;
+		pp->dtl_curr = dtl;
+	}
+
+	/* Register the DTL for the current (boot) cpu */
+	dtl = get_paca()->dispatch_log;
+	get_paca()->dtl_ridx = 0;
+	get_paca()->dtl_curr = dtl;
+	get_paca()->lppaca_ptr->dtl_idx = 0;
+
+	/* hypervisor reads buffer length from this field */
+	dtl->enqueue_to_dispatch_time = DISPATCH_LOG_BYTES;
+	ret = register_dtl(hard_smp_processor_id(), __pa(dtl));
+	if (ret)
+		pr_warn("DTL registration failed for boot cpu %d (%d)\n",
+			smp_processor_id(), ret);
+	get_paca()->lppaca_ptr->dtl_enable_mask = 2;
+
+	return 0;
+}
+
+early_initcall(alloc_dispatch_logs);
+#endif /* CONFIG_VIRT_CPU_ACCOUNTING */
+
 static void __init pSeries_setup_arch(void)
 {
 	/* Discover PIC type and setup ppc_md accordingly */

commit b878dc00595440586874952dd85ce9b803360b87
Author: Anton Blanchard <anton@samba.org>
Date:   Sun May 16 20:02:39 2010 +0000

    powerpc: Use smt_snooze_delay=-1 to always busy loop
    
    Right now if we want to busy loop and not give up any time to the hypervisor
    we put a very large value into smt_snooze_delay. This is sometimes useful
    when running a single partition and you want to avoid any latencies due
    to the hypervisor or CPU power state transitions. While this works, it's a bit
    ugly - how big a number is enough now we have NO_HZ and can be idle for a very
    long time.
    
    The patch below makes smt_snooze_delay signed, and a negative value means loop
    forever:
    
    echo -1 > /sys/devices/system/cpu/cpu0/smt_snooze_delay
    
    This change shouldn't affect the existing userspace tools (eg ppc64_cpu), but
    I'm cc-ing Nathan just to be sure.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 6710761bf60f..a6d19e3a505e 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -496,13 +496,14 @@ static int __init pSeries_probe(void)
 }
 
 
-DECLARE_PER_CPU(unsigned long, smt_snooze_delay);
+DECLARE_PER_CPU(long, smt_snooze_delay);
 
 static void pseries_dedicated_idle_sleep(void)
 { 
 	unsigned int cpu = smp_processor_id();
 	unsigned long start_snooze;
 	unsigned long in_purr, out_purr;
+	long snooze = __get_cpu_var(smt_snooze_delay);
 
 	/*
 	 * Indicate to the HV that we are idle. Now would be
@@ -517,13 +518,12 @@ static void pseries_dedicated_idle_sleep(void)
 	 * has been checked recently.  If we should poll for a little
 	 * while, do so.
 	 */
-	if (__get_cpu_var(smt_snooze_delay)) {
-		start_snooze = get_tb() +
-			__get_cpu_var(smt_snooze_delay) * tb_ticks_per_usec;
+	if (snooze) {
+		start_snooze = get_tb() + snooze * tb_ticks_per_usec;
 		local_irq_enable();
 		set_thread_flag(TIF_POLLING_NRFLAG);
 
-		while (get_tb() < start_snooze) {
+		while ((snooze < 0) || (get_tb() < start_snooze)) {
 			if (need_resched() || cpu_is_offline(cpu))
 				goto out;
 			ppc64_runlatch_off();

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index ca5f2e10972c..6710761bf60f 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -23,7 +23,6 @@
 #include <linux/mm.h>
 #include <linux/stddef.h>
 #include <linux/unistd.h>
-#include <linux/slab.h>
 #include <linux/user.h>
 #include <linux/tty.h>
 #include <linux/major.h>

commit a6dbf93a2ad853585409e715eb96dca9177e3c39
Author: Paul Mackerras <paulus@samba.org>
Date:   Wed Sep 9 01:26:03 2009 +0000

    powerpc: Fix bug where perf_counters breaks oprofile
    
    Currently there is a bug where if you use oprofile on a pSeries
    machine, then use perf_counters, then use oprofile again, oprofile
    will not work correctly; it will lose the PMU configuration the next
    time the hypervisor does a partition context switch, and thereafter
    won't count anything.
    
    Maynard Johnson identified the sequence causing the problem:
    - oprofile setup calls ppc_enable_pmcs(), which calls
      pseries_lpar_enable_pmcs, which tells the hypervisor that we want
      to use the PMU, and sets the "PMU in use" flag in the lppaca.
      This flag tells the hypervisor whether it needs to save and restore
      the PMU config.
    - The perf_counter code sets and clears the "PMU in use" flag directly
      as it context-switches the PMU between tasks, and leaves it clear
      when it finishes.
    - oprofile setup, called for a new oprofile run, calls ppc_enable_pmcs,
      which does nothing because it has already been called.  In particular
      it doesn't set the "PMU in use" flag.
    
    This fixes the problem by arranging for ppc_enable_pmcs to always set
    the "PMU in use" flag.  It makes the perf_counter code call
    ppc_enable_pmcs also rather than calling the lower-level function
    directly, and removes the setting of the "PMU in use" flag from
    pseries_lpar_enable_pmcs, since that is now done in its caller.
    
    This also removes the declaration of pasemi_enable_pmcs because it
    isn't defined anywhere.
    
    Reported-by: Maynard Johnson <mpjohn@us.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Cc: <stable@kernel.org)
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 8d75ea21296f..ca5f2e10972c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -223,10 +223,6 @@ static void pseries_lpar_enable_pmcs(void)
 	set = 1UL << 63;
 	reset = 0;
 	plpar_hcall_norets(H_PERFMON, set, reset);
-
-	/* instruct hypervisor to maintain PMCs */
-	if (firmware_has_feature(FW_FEATURE_SPLPAR))
-		get_lppaca()->pmcregs_in_use = 1;
 }
 
 static void __init pseries_discover_pic(void)

commit 2eb4afb69ff3cdd357d5e68ed82cd131916bd8a7
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Thu Apr 30 09:26:21 2009 +0000

    powerpc/pci: Move pseries code into pseries platform specific area
    
    There doesn't appear to be any specific reason that we need to setup the
    pseries specific notifier in generic arch pci code.  Move it into pseries
    land.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index ec341707e41b..8d75ea21296f 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -63,6 +63,7 @@
 #include <asm/smp.h>
 #include <asm/firmware.h>
 #include <asm/eeh.h>
+#include <asm/pSeries_reconfig.h>
 
 #include "plpar_wrappers.h"
 #include "pseries.h"
@@ -254,6 +255,29 @@ static void __init pseries_discover_pic(void)
 	       " interrupt-controller\n");
 }
 
+static int pci_dn_reconfig_notifier(struct notifier_block *nb, unsigned long action, void *node)
+{
+	struct device_node *np = node;
+	struct pci_dn *pci = NULL;
+	int err = NOTIFY_OK;
+
+	switch (action) {
+	case PSERIES_RECONFIG_ADD:
+		pci = np->parent->data;
+		if (pci)
+			update_dn_pci_info(np, pci->phb);
+		break;
+	default:
+		err = NOTIFY_DONE;
+		break;
+	}
+	return err;
+}
+
+static struct notifier_block pci_dn_reconfig_nb = {
+	.notifier_call = pci_dn_reconfig_notifier,
+};
+
 static void __init pSeries_setup_arch(void)
 {
 	/* Discover PIC type and setup ppc_md accordingly */
@@ -271,6 +295,7 @@ static void __init pSeries_setup_arch(void)
 	/* Find and initialize PCI host bridges */
 	init_pci_config_tokens();
 	find_and_init_phbs();
+	pSeries_reconfig_notifier_register(&pci_dn_reconfig_nb);
 	eeh_init();
 
 	pSeries_nvram_init();

commit 9d5a9e74655b9d04d0ec9c8e47801163b7b74211
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Jun 28 00:12:52 2008 +0300

    Remove asm/a.out.h files for all architectures without a.out support.
    
    This patch also includes the required removal of (unused) inclusion of
    <asm/a.out.h> <linux/a.out.h>'s in the arch/ code for these
    architectures.
    
    [dwmw2: updated for 2.6.27-rc]
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 7b01d67b4e48..ec341707e41b 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -25,7 +25,6 @@
 #include <linux/unistd.h>
 #include <linux/slab.h>
 #include <linux/user.h>
-#include <linux/a.out.h>
 #include <linux/tty.h>
 #include <linux/major.h>
 #include <linux/interrupt.h>

commit d617a40227705eb0d7b7692bbb974d077f0219a9
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Aug 21 11:16:26 2008 +1000

    powerpc: Export CMO_PageSize
    
    This fixes an error building powerpc allmodconfig:
    
    ERROR: "CMO_PageSize" [arch/powerpc/platforms/pseries/cmm.ko] undefined!
    
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 3ce8a139b85d..7b01d67b4e48 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -71,6 +71,7 @@
 int CMO_PrPSP = -1;
 int CMO_SecPSP = -1;
 unsigned long CMO_PageSize = (ASM_CONST(1) << IOMMU_PAGE_SHIFT);
+EXPORT_SYMBOL(CMO_PageSize);
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 

commit 81f14997e8e8a10eb75ca593674d2b0c94129a21
Author: Robert Jennings <rcj@linux.vnet.ibm.com>
Date:   Sat Aug 16 05:07:31 2008 +1000

    powerpc: Make CMO paging space pool ID and page size available
    
    During platform setup, save off the primary/secondary paging space
    pool IDs and the page size.  Added accessors in hvcall.h for these
    variables.  This is needed for a subsequent fix.
    
    Submitted-by: Robert Jennings <rcj@linux.vnet.ibm.com>
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 063a0d2fba30..3ce8a139b85d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -68,6 +68,9 @@
 #include "plpar_wrappers.h"
 #include "pseries.h"
 
+int CMO_PrPSP = -1;
+int CMO_SecPSP = -1;
+unsigned long CMO_PageSize = (ASM_CONST(1) << IOMMU_PAGE_SHIFT);
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 
@@ -325,8 +328,7 @@ void pSeries_cmo_feature_init(void)
 {
 	char *ptr, *key, *value, *end;
 	int call_status;
-	int PrPSP = -1;
-	int SecPSP = -1;
+	int page_order = IOMMU_PAGE_SHIFT;
 
 	pr_debug(" -> fw_cmo_feature_init()\n");
 	spin_lock(&rtas_data_buf_lock);
@@ -365,21 +367,31 @@ void pSeries_cmo_feature_init(void)
 				break;
 			}
 
-			if (0 == strcmp(key, "PrPSP"))
-				PrPSP = simple_strtol(value, NULL, 10);
+			if (0 == strcmp(key, "CMOPageSize"))
+				page_order = simple_strtol(value, NULL, 10);
+			else if (0 == strcmp(key, "PrPSP"))
+				CMO_PrPSP = simple_strtol(value, NULL, 10);
 			else if (0 == strcmp(key, "SecPSP"))
-				SecPSP = simple_strtol(value, NULL, 10);
+				CMO_SecPSP = simple_strtol(value, NULL, 10);
 			value = key = ptr + 1;
 		}
 		ptr++;
 	}
 
-	if (PrPSP != -1 || SecPSP != -1) {
+	/* Page size is returned as the power of 2 of the page size,
+	 * convert to the page size in bytes before returning
+	 */
+	CMO_PageSize = 1 << page_order;
+	pr_debug("CMO_PageSize = %lu\n", CMO_PageSize);
+
+	if (CMO_PrPSP != -1 || CMO_SecPSP != -1) {
 		pr_info("CMO enabled\n");
-		pr_debug("CMO enabled, PrPSP=%d, SecPSP=%d\n", PrPSP, SecPSP);
+		pr_debug("CMO enabled, PrPSP=%d, SecPSP=%d\n", CMO_PrPSP,
+		         CMO_SecPSP);
 		powerpc_firmware_features |= FW_FEATURE_CMO;
 	} else
-		pr_debug("CMO not enabled, PrPSP=%d, SecPSP=%d\n", PrPSP, SecPSP);
+		pr_debug("CMO not enabled, PrPSP=%d, SecPSP=%d\n", CMO_PrPSP,
+		         CMO_SecPSP);
 	spin_unlock(&rtas_data_buf_lock);
 	pr_debug(" <- fw_cmo_feature_init()\n");
 }

commit e46de429cb954d30a5642fba81d516ede518c65e
Author: Robert Jennings <rcj@linux.vnet.ibm.com>
Date:   Thu Jul 24 04:29:03 2008 +1000

    powerpc/pseries: Enable CMO feature during platform setup
    
    For Cooperative Memory Overcommitment (CMO), set the FW_FEATURE_CMO
    flag in powerpc_firmware_features from the rtas ibm,get-system-parameters
    table prior to calling iommu_init_early_pSeries.
    
    With this, any CMO specific functionality can be controlled by checking:
     firmware_has_feature(FW_FEATURE_CMO)
    
    Signed-off-by: Robert Jennings <rcj@linux.vnet.ibm.com>
    Acked-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 90beb444e1dd..063a0d2fba30 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -314,6 +314,76 @@ static int pseries_set_xdabr(unsigned long dabr)
 			H_DABRX_KERNEL | H_DABRX_USER);
 }
 
+#define CMO_CHARACTERISTICS_TOKEN 44
+#define CMO_MAXLENGTH 1026
+
+/**
+ * fw_cmo_feature_init - FW_FEATURE_CMO is not stored in ibm,hypertas-functions,
+ * handle that here. (Stolen from parse_system_parameter_string)
+ */
+void pSeries_cmo_feature_init(void)
+{
+	char *ptr, *key, *value, *end;
+	int call_status;
+	int PrPSP = -1;
+	int SecPSP = -1;
+
+	pr_debug(" -> fw_cmo_feature_init()\n");
+	spin_lock(&rtas_data_buf_lock);
+	memset(rtas_data_buf, 0, RTAS_DATA_BUF_SIZE);
+	call_status = rtas_call(rtas_token("ibm,get-system-parameter"), 3, 1,
+				NULL,
+				CMO_CHARACTERISTICS_TOKEN,
+				__pa(rtas_data_buf),
+				RTAS_DATA_BUF_SIZE);
+
+	if (call_status != 0) {
+		spin_unlock(&rtas_data_buf_lock);
+		pr_debug("CMO not available\n");
+		pr_debug(" <- fw_cmo_feature_init()\n");
+		return;
+	}
+
+	end = rtas_data_buf + CMO_MAXLENGTH - 2;
+	ptr = rtas_data_buf + 2;	/* step over strlen value */
+	key = value = ptr;
+
+	while (*ptr && (ptr <= end)) {
+		/* Separate the key and value by replacing '=' with '\0' and
+		 * point the value at the string after the '='
+		 */
+		if (ptr[0] == '=') {
+			ptr[0] = '\0';
+			value = ptr + 1;
+		} else if (ptr[0] == '\0' || ptr[0] == ',') {
+			/* Terminate the string containing the key/value pair */
+			ptr[0] = '\0';
+
+			if (key == value) {
+				pr_debug("Malformed key/value pair\n");
+				/* Never found a '=', end processing */
+				break;
+			}
+
+			if (0 == strcmp(key, "PrPSP"))
+				PrPSP = simple_strtol(value, NULL, 10);
+			else if (0 == strcmp(key, "SecPSP"))
+				SecPSP = simple_strtol(value, NULL, 10);
+			value = key = ptr + 1;
+		}
+		ptr++;
+	}
+
+	if (PrPSP != -1 || SecPSP != -1) {
+		pr_info("CMO enabled\n");
+		pr_debug("CMO enabled, PrPSP=%d, SecPSP=%d\n", PrPSP, SecPSP);
+		powerpc_firmware_features |= FW_FEATURE_CMO;
+	} else
+		pr_debug("CMO not enabled, PrPSP=%d, SecPSP=%d\n", PrPSP, SecPSP);
+	spin_unlock(&rtas_data_buf_lock);
+	pr_debug(" <- fw_cmo_feature_init()\n");
+}
+
 /*
  * Early initialization.  Relocation is on but do not reference unbolted pages
  */
@@ -329,6 +399,7 @@ static void __init pSeries_init_early(void)
 	else if (firmware_has_feature(FW_FEATURE_XDABR))
 		ppc_md.set_dabr = pseries_set_xdabr;
 
+	pSeries_cmo_feature_init();
 	iommu_init_early_pSeries();
 
 	pr_debug(" <- pSeries_init_early()\n");

commit 541b2755c2ef7dd2242ac606c115daa11e43ef69
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu May 8 14:27:23 2008 +1000

    [POWERPC] Fix sparse warnings in arch/powerpc/platforms/pseries
    
    Don't return void in pseries/iommu.c
    Make mce_data_buf static in pseries/ras.c
    Make things static in pseries/rtasd.c
    Make things static in pseries/setup.c
    vtermno may as well be static in platforms/pseries/lpar.c
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f5d29f5b13c1..90beb444e1dd 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -109,7 +109,7 @@ static void __init fwnmi_init(void)
 		fwnmi_active = 1;
 }
 
-void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc)
+static void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc)
 {
 	unsigned int cascade_irq = i8259_irq();
 	if (cascade_irq != NO_IRQ)
@@ -482,7 +482,7 @@ static int pSeries_pci_probe_mode(struct pci_bus *bus)
  * possible with power button press. If ibm,power-off-ups token is used
  * it will allow auto poweron after power is restored.
  */
-void pSeries_power_off(void)
+static void pSeries_power_off(void)
 {
 	int rc;
 	int rtas_poweroff_ups_token = rtas_token("ibm,power-off-ups");

commit 36f8a2c4c61e3559a95190e457b431c6900859b4
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Apr 24 15:13:21 2008 +1000

    [POWERPC] Add CONFIG_PPC_PSERIES_DEBUG to enable debugging for platforms/pseries
    
    Add a DEBUG config setting which turns on all (most) of the debugging
    under platforms/pseries.
    
    To have this take effect we need to remove all the #undef DEBUG's, in
    various files. We leave the #undef DEBUG in platforms/pseries/lpar.c,
    as this enables debugging printks from the low-level hash table routines,
    and tends to make your system unusable. If you want those enabled you
    still have to turn them on by hand.
    
    Also some of the RAS code has a DEBUG block which causes a functional
    change, so I've keyed this off a different (non-existant) debug #define.
    
    This is only enabled if you have PPC_EARLY_DEBUG enabled also.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 65e87951eda3..f5d29f5b13c1 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -16,8 +16,6 @@
  * bootup setup stuff..
  */
 
-#undef DEBUG
-
 #include <linux/cpu.h>
 #include <linux/errno.h>
 #include <linux/sched.h>

commit f7ebf352b2e04ee89efb426e33dd450d8f1cfcd5
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Apr 24 15:13:19 2008 +1000

    [POWERPC] Convert from DBG() to pr_debug() in platforms/pseries/
    
    In pseries/lpar.c, fix some printf specifier mismatches, and add
    a newline to one printk.
    
    In pseries/rtasd.c add "rtasd" to some messages to make it clear
    where they're coming from.
    
    In pseries/scanlog.c remove the hand-rolled runtime debugging support
    in there. This file has been largely unchanged for eons, if we need to
    debug it in future we can recompile.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f66aa9c3b135..65e87951eda3 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -70,11 +70,6 @@
 #include "plpar_wrappers.h"
 #include "pseries.h"
 
-#ifdef DEBUG
-#define DBG(fmt...) udbg_printf(fmt)
-#else
-#define DBG(fmt...)
-#endif
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 
@@ -326,7 +321,7 @@ static int pseries_set_xdabr(unsigned long dabr)
  */
 static void __init pSeries_init_early(void)
 {
-	DBG(" -> pSeries_init_early()\n");
+	pr_debug(" -> pSeries_init_early()\n");
 
 	if (firmware_has_feature(FW_FEATURE_LPAR))
 		find_udbg_vterm();
@@ -338,7 +333,7 @@ static void __init pSeries_init_early(void)
 
 	iommu_init_early_pSeries();
 
-	DBG(" <- pSeries_init_early()\n");
+	pr_debug(" <- pSeries_init_early()\n");
 }
 
 /*
@@ -383,7 +378,7 @@ static int __init pSeries_probe(void)
 	    of_flat_dt_is_compatible(root, "IBM,CBEA"))
 		return 0;
 
-	DBG("pSeries detected, looking for LPAR capability...\n");
+	pr_debug("pSeries detected, looking for LPAR capability...\n");
 
 	/* Now try to figure out if we are running on LPAR */
 	of_scan_flat_dt(pSeries_probe_hypertas, NULL);
@@ -393,8 +388,8 @@ static int __init pSeries_probe(void)
 	else
 		hpte_init_native();
 
-	DBG("Machine is%s LPAR !\n",
-	    (powerpc_firmware_features & FW_FEATURE_LPAR) ? "" : " not");
+	pr_debug("Machine is%s LPAR !\n",
+	         (powerpc_firmware_features & FW_FEATURE_LPAR) ? "" : " not");
 
 	return 1;
 }

commit f01567d6d5688f8f613cd23da31aaf02d9538525
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue Apr 1 17:42:26 2008 +1100

    [POWERPC] Use pseries_setup_i8259_cascade() in pseries_mpic_init_IRQ()
    
    pseries_mpic_init_IRQ() implements the same logic as the xics code did to
    find the i8259 cascade irq.  Now that we've pulled that logic out into
    pseries_setup_i8259_cascade() we can use it in the mpic code.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index eb079521fbf1..f66aa9c3b135 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -175,12 +175,9 @@ static void __init pseries_setup_i8259_cascade(void)
 
 static void __init pseries_mpic_init_IRQ(void)
 {
-	struct device_node *np, *old, *cascade = NULL;
-        const unsigned int *addrp;
-	unsigned long intack = 0;
+	struct device_node *np;
 	const unsigned int *opprop;
 	unsigned long openpic_addr = 0;
-	unsigned int cascade_irq;
 	int naddr, n, i, opplen;
 	struct mpic *mpic;
 
@@ -213,43 +210,7 @@ static void __init pseries_mpic_init_IRQ(void)
 	mpic_init(mpic);
 
 	/* Look for cascade */
-	for_each_node_by_type(np, "interrupt-controller")
-		if (of_device_is_compatible(np, "chrp,iic")) {
-			cascade = np;
-			break;
-		}
-	if (cascade == NULL)
-		return;
-
-	cascade_irq = irq_of_parse_and_map(cascade, 0);
-	if (cascade_irq == NO_IRQ) {
-		printk(KERN_ERR "mpic: failed to map cascade interrupt");
-		return;
-	}
-
-	/* Check ACK type */
-	for (old = of_node_get(cascade); old != NULL ; old = np) {
-		np = of_get_parent(old);
-		of_node_put(old);
-		if (np == NULL)
-			break;
-		if (strcmp(np->name, "pci") != 0)
-			continue;
-		addrp = of_get_property(np, "8259-interrupt-acknowledge",
-					    NULL);
-		if (addrp == NULL)
-			continue;
-		naddr = of_n_addr_cells(np);
-		intack = addrp[naddr-1];
-		if (naddr > 1)
-			intack |= ((unsigned long)addrp[naddr-2]) << 32;
-	}
-	if (intack)
-		printk(KERN_DEBUG "mpic: PCI 8259 intack at 0x%016lx\n",
-		       intack);
-	i8259_init(cascade, intack);
-	of_node_put(cascade);
-	set_irq_chained_handler(cascade_irq, pseries_8259_cascade);
+	pseries_setup_i8259_cascade();
 }
 
 static void __init pseries_xics_init_IRQ(void)

commit 30d6ad251b5dcf497a266c4dc7d38fcde7185422
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue Apr 1 17:42:25 2008 +1100

    [POWERPC] Turn xics_setup_8259_cascade() into a generic pseries_setup_i8259_cascade()
    
    Remove the xics references from xics_setup_8259_cascade(), and merge the
    good bits from the almost identical logic in pseries_mpic_init_IRQ().
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index bef4f683285d..eb079521fbf1 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -124,28 +124,32 @@ void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc)
 	desc->chip->eoi(irq);
 }
 
-static void __init xics_setup_8259_cascade(void)
+static void __init pseries_setup_i8259_cascade(void)
 {
 	struct device_node *np, *old, *found = NULL;
-	int cascade, naddr;
+	unsigned int cascade;
 	const u32 *addrp;
 	unsigned long intack = 0;
+	int naddr;
 
-	for_each_node_by_type(np, "interrupt-controller")
+	for_each_node_by_type(np, "interrupt-controller") {
 		if (of_device_is_compatible(np, "chrp,iic")) {
 			found = np;
 			break;
 		}
+	}
+
 	if (found == NULL) {
-		printk(KERN_DEBUG "xics: no ISA interrupt controller\n");
+		printk(KERN_DEBUG "pic: no ISA interrupt controller\n");
 		return;
 	}
+
 	cascade = irq_of_parse_and_map(found, 0);
 	if (cascade == NO_IRQ) {
-		printk(KERN_ERR "xics: failed to map cascade interrupt");
+		printk(KERN_ERR "pic: failed to map cascade interrupt");
 		return;
 	}
-	pr_debug("xics: cascade mapped to irq %d\n", cascade);
+	pr_debug("pic: cascade mapped to irq %d\n", cascade);
 
 	for (old = of_node_get(found); old != NULL ; old = np) {
 		np = of_get_parent(old);
@@ -163,7 +167,7 @@ static void __init xics_setup_8259_cascade(void)
 			intack |= ((unsigned long)addrp[naddr-2]) << 32;
 	}
 	if (intack)
-		printk(KERN_DEBUG "xics: PCI 8259 intack at 0x%016lx\n", intack);
+		printk(KERN_DEBUG "pic: PCI 8259 intack at 0x%016lx\n", intack);
 	i8259_init(found, intack);
 	of_node_put(found);
 	set_irq_chained_handler(cascade, pseries_8259_cascade);
@@ -251,7 +255,7 @@ static void __init pseries_mpic_init_IRQ(void)
 static void __init pseries_xics_init_IRQ(void)
 {
 	xics_init_IRQ();
-	xics_setup_8259_cascade();
+	pseries_setup_i8259_cascade();
 }
 
 static void pseries_lpar_enable_pmcs(void)

commit 032ace7e17f141a5cf350e4ec0c5bf4f5faf1c49
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue Apr 1 17:42:25 2008 +1100

    [POWERPC] Move xics_setup_8259_cascade() into platforms/pseries/setup.c
    
    The code in xics.c to setup the i8259 cascaded irq handler is not really
    xics specific, so move it into setup.c - we will clean this up further in
    a subsequent patch.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index fccca89ee04e..bef4f683285d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -124,6 +124,51 @@ void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc)
 	desc->chip->eoi(irq);
 }
 
+static void __init xics_setup_8259_cascade(void)
+{
+	struct device_node *np, *old, *found = NULL;
+	int cascade, naddr;
+	const u32 *addrp;
+	unsigned long intack = 0;
+
+	for_each_node_by_type(np, "interrupt-controller")
+		if (of_device_is_compatible(np, "chrp,iic")) {
+			found = np;
+			break;
+		}
+	if (found == NULL) {
+		printk(KERN_DEBUG "xics: no ISA interrupt controller\n");
+		return;
+	}
+	cascade = irq_of_parse_and_map(found, 0);
+	if (cascade == NO_IRQ) {
+		printk(KERN_ERR "xics: failed to map cascade interrupt");
+		return;
+	}
+	pr_debug("xics: cascade mapped to irq %d\n", cascade);
+
+	for (old = of_node_get(found); old != NULL ; old = np) {
+		np = of_get_parent(old);
+		of_node_put(old);
+		if (np == NULL)
+			break;
+		if (strcmp(np->name, "pci") != 0)
+			continue;
+		addrp = of_get_property(np, "8259-interrupt-acknowledge", NULL);
+		if (addrp == NULL)
+			continue;
+		naddr = of_n_addr_cells(np);
+		intack = addrp[naddr-1];
+		if (naddr > 1)
+			intack |= ((unsigned long)addrp[naddr-2]) << 32;
+	}
+	if (intack)
+		printk(KERN_DEBUG "xics: PCI 8259 intack at 0x%016lx\n", intack);
+	i8259_init(found, intack);
+	of_node_put(found);
+	set_irq_chained_handler(cascade, pseries_8259_cascade);
+}
+
 static void __init pseries_mpic_init_IRQ(void)
 {
 	struct device_node *np, *old, *cascade = NULL;
@@ -203,6 +248,12 @@ static void __init pseries_mpic_init_IRQ(void)
 	set_irq_chained_handler(cascade_irq, pseries_8259_cascade);
 }
 
+static void __init pseries_xics_init_IRQ(void)
+{
+	xics_init_IRQ();
+	xics_setup_8259_cascade();
+}
+
 static void pseries_lpar_enable_pmcs(void)
 {
 	unsigned long set, reset;
@@ -232,7 +283,7 @@ static void __init pseries_discover_pic(void)
 			smp_init_pseries_mpic();
 			return;
 		} else if (strstr(typep, "ppc-xicp")) {
-			ppc_md.init_IRQ       = xics_init_IRQ;
+			ppc_md.init_IRQ       = pseries_xics_init_IRQ;
 			setup_kexec_cpu_down_xics();
 			smp_init_pseries_xics();
 			return;

commit 21cf91338fabe649ae3744429e13b61da2a17a6a
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Wed Apr 16 13:51:48 2008 +1000

    [POWERPC] Move prototype for find_udbg_vterm() into a header file
    
    Move the prototype for find_udbg_vterm() into pseries.h, removing
    it from setup.c.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 90555a39fe62..fccca89ee04e 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -76,9 +76,6 @@
 #define DBG(fmt...)
 #endif
 
-/* move those away to a .h */
-extern void find_udbg_vterm(void);
-
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 
 static void pseries_shared_idle_sleep(void);

commit 96366a8d3f17ee964802378d4a1f51fda86f070e
Author: Tony Breeds <tony@bakeyournoodle.com>
Date:   Mon Mar 17 16:23:29 2008 +1100

    [POWERPC] Update wait_state_cycles in the VPA
    
    The hypervisor can look at the value in the wait_state_cycles field of
    the VPA for an estimate of how busy dedicated processors are.
    Currently, as the kernel never touches this field, we appear to be
    100% busy.  This records the duration the kernel is in powersave and
    passes that to the HV to provide a reasonable indication of
    utilisation.
    
    Signed-off-by: Tony Breeds <tony@bakeyournoodle.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index fdb9b1c8f977..90555a39fe62 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -393,6 +393,7 @@ static void pseries_dedicated_idle_sleep(void)
 { 
 	unsigned int cpu = smp_processor_id();
 	unsigned long start_snooze;
+	unsigned long in_purr, out_purr;
 
 	/*
 	 * Indicate to the HV that we are idle. Now would be
@@ -400,6 +401,7 @@ static void pseries_dedicated_idle_sleep(void)
 	 */
 	get_lppaca()->idle = 1;
 	get_lppaca()->donate_dedicated_cpu = 1;
+	in_purr = mfspr(SPRN_PURR);
 
 	/*
 	 * We come in with interrupts disabled, and need_resched()
@@ -432,6 +434,8 @@ static void pseries_dedicated_idle_sleep(void)
 
 out:
 	HMT_medium();
+	out_purr = mfspr(SPRN_PURR);
+	get_lppaca()->wait_state_cycles += out_purr - in_purr;
 	get_lppaca()->donate_dedicated_cpu = 0;
 	get_lppaca()->idle = 0;
 }

commit 8f51506164655ce9af14970ce4f765f28c7970e9
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Dec 3 09:30:04 2007 +1100

    Revert "[POWERPC] Fix RTAS os-term usage on kernel panic"
    
    This reverts commit a2b51812a4dc5db09ab4d4638d4d8ed456e2457e.
    
    It turns out that this change caused some machines to fail to come
    back up when being rebooted, and generated an error in the hypervisor
    error log on some machines.  The platform architecture (PAPR) is a
    little unclear on exactly when the RTAS ibm,os-term function should be
    called.  Until that is clarified I'm reverting this commit.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index fdeefe54ea91..fdb9b1c8f977 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -507,8 +507,7 @@ define_machine(pseries) {
 	.restart		= rtas_restart,
 	.power_off		= pSeries_power_off,
 	.halt			= rtas_halt,
-	.panic			= rtas_panic_msg,
-	.machine_shutdown	= rtas_os_term,
+	.panic			= rtas_os_term,
 	.get_boot_time		= rtas_get_boot_time,
 	.get_rtc_time		= rtas_get_rtc_time,
 	.set_rtc_time		= rtas_set_rtc_time,

commit a2b51812a4dc5db09ab4d4638d4d8ed456e2457e
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Tue Nov 20 12:28:15 2007 +1100

    [POWERPC] Fix RTAS os-term usage on kernel panic
    
    The rtas_os_term() routine was being called at the wrong time.
    The actual rtas call "os-term" will not ever return, and so
    calling it from the panic notifier is too early.  Instead,
    call it from the machine_reset() call.
    
    This splits the rtas_os_term() routine into two: one part to capture
    the kernel panic message, invoked during the panic notifier, and
    another part that is invoked during machine_reset().
    
    Prior to this patch, the os-term call was never being made,
    because panic_timeout was always non-zero.  Calling os-term
    helps keep the hypervisor happy!  We have to keep the hypervisor
    happy to avoid service, dump and error reporting problems.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index fdb9b1c8f977..fdeefe54ea91 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -507,7 +507,8 @@ define_machine(pseries) {
 	.restart		= rtas_restart,
 	.power_off		= pSeries_power_off,
 	.halt			= rtas_halt,
-	.panic			= rtas_os_term,
+	.panic			= rtas_panic_msg,
+	.machine_shutdown	= rtas_os_term,
 	.get_boot_time		= rtas_get_boot_time,
 	.get_rtc_time		= rtas_get_rtc_time,
 	.set_rtc_time		= rtas_set_rtc_time,

commit 745e1027751acbc1f14f8bbef378b491242b9c83
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Oct 11 04:48:28 2007 +1000

    [POWERPC] Platforms shouldn't mess with ROOT_DEV
    
    There is no good reason for board platform code to mess with the
    ROOT_DEV.  Remove it from all in-tree platforms except powermac.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f0b7146a110f..fdb9b1c8f977 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -257,11 +257,6 @@ static void __init pSeries_setup_arch(void)
 	/* init to some ~sane value until calibrate_delay() runs */
 	loops_per_jiffy = 50000000;
 
-	if (ROOT_DEV == 0) {
-		printk("No ramdisk, default root is /dev/sda2\n");
-		ROOT_DEV = Root_SDA2;
-	}
-
 	fwnmi_init();
 
 	/* Find and initialize PCI host bridges */

commit ca8ffc974d43033be6e1d4277a45822d2c3656f4
Author: Michael Neuling <mikey@neuling.org>
Date:   Thu Jul 19 07:56:32 2007 +1000

    [POWERPC] Fix future firmware feature fixups function failure
    
    Move firmware feature initialisation from pSeries_init_early to the
    earlier pSeries_probe_hypertas so they are initialised before firmware
    feature fixups are applied.
    
    Currently firmware feature sections are only used for iSeries which
    initialises the these features much earlier.  This is a bug in waiting
    on pSeries.
    
    Also adds some whitespace fixups.
    
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 59e69f085cb4..f0b7146a110f 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -320,8 +320,6 @@ static void __init pSeries_init_early(void)
 {
 	DBG(" -> pSeries_init_early()\n");
 
-	fw_feature_init();
-
 	if (firmware_has_feature(FW_FEATURE_LPAR))
 		find_udbg_vterm();
 
@@ -343,14 +341,21 @@ static int __init pSeries_probe_hypertas(unsigned long node,
 					 const char *uname, int depth,
 					 void *data)
 {
+	const char *hypertas;
+	unsigned long len;
+
 	if (depth != 1 ||
 	    (strcmp(uname, "rtas") != 0 && strcmp(uname, "rtas@0") != 0))
- 		return 0;
+		return 0;
+
+	hypertas = of_get_flat_dt_prop(node, "ibm,hypertas-functions", &len);
+	if (!hypertas)
+		return 1;
 
-	if (of_get_flat_dt_prop(node, "ibm,hypertas-functions", NULL) != NULL)
- 		powerpc_firmware_features |= FW_FEATURE_LPAR;
+	powerpc_firmware_features |= FW_FEATURE_LPAR;
+	fw_feature_init(hypertas, len);
 
- 	return 1;
+	return 1;
 }
 
 static int __init pSeries_probe(void)

commit 489de30259e667d7bc47da9da44a0270b050cd97
Merge: 1f1c2881f673 bf22f6fe2d72
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Jul 16 17:58:08 2007 -0700

    Merge branch 'merge' of git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc
    
    * 'merge' of git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc: (209 commits)
      [POWERPC] Create add_rtc() function to enable the RTC CMOS driver
      [POWERPC] Add H_ILLAN_ATTRIBUTES hcall number
      [POWERPC] xilinxfb: Parameterize xilinxfb platform device registration
      [POWERPC] Oprofile support for Power 5++
      [POWERPC] Enable arbitary speed tty ioctls and split input/output speed
      [POWERPC] Make drivers/char/hvc_console.c:khvcd() static
      [POWERPC] Remove dead code for preventing pread() and pwrite() calls
      [POWERPC] Remove unnecessary #undef printk from prom.c
      [POWERPC] Fix typo in Ebony default DTS
      [POWERPC] Check for NULL ppc_md.init_IRQ() before calling
      [POWERPC] Remove extra return statement
      [POWERPC] pasemi: Don't auto-select CONFIG_EMBEDDED
      [POWERPC] pasemi: Rename platform
      [POWERPC] arch/powerpc/kernel/sysfs.c: Move NUMA exports
      [POWERPC] Add __read_mostly support for powerpc
      [POWERPC] Modify sched_clock() to make CONFIG_PRINTK_TIME more sane
      [POWERPC] Create a dummy zImage if no valid platform has been selected
      [POWERPC] PS3: Bootwrapper support.
      [POWERPC] powermac i2c: Use mutex
      [POWERPC] Schedule removal of arch/ppc
      ...
    
    Fixed up conflicts manually in:
    
            Documentation/feature-removal-schedule.txt
            arch/powerpc/kernel/pci_32.c
            arch/powerpc/kernel/pci_64.c
            include/asm-powerpc/pci.h
    
    and asked the powerpc people to double-check the result..

commit 0e81c666dbf95546b3d9ea6ff7d29ea19b988950
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sun Jul 15 20:59:41 2007 +0100

    the wrong variable checked after request_irq()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 470db6efaeb6..a031d99becb7 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -176,7 +176,7 @@ static void __init pseries_mpic_init_IRQ(void)
 		return;
 
 	cascade_irq = irq_of_parse_and_map(cascade, 0);
-	if (cascade == NO_IRQ) {
+	if (cascade_irq == NO_IRQ) {
 		printk(KERN_ERR "mpic: failed to map cascade interrupt");
 		return;
 	}

commit d8c391a5593aca5bea002bcaaec16c7bbd6ec853
Author: Jake Moilanen <moilanen@austin.ibm.com>
Date:   Fri Jun 8 07:27:11 2007 +1000

    [POWERPC] Donate idle CPU cycles on dedicated partitions
    
    A Power6 can give up CPU cycles on a dedicated CPU (as opposed to a
    shared CPU) to other shared processors if the administrator asks for it
    (via the HMC).
    
    This enables that to work properly on P6.
    
    This just involves setting a bit in the CAS structure as well as the
    VPA.  To donate cycles, a CPU has to have all SMT threads idle and
    have the donate bit set in the VPA.  Then call H_CEDE.
    
    The reason why shared processors just aren't used is because dedicated
    CPUs are guaranteed an actual processor, yet the system is still able to
    increase the capacity of the shared CPU pool.
    
    Also rename the VPA's cpuctls_task_attrs field to a more accurate name.
    
    Signed-off-by: Jake Moilanen <moilanen@austin.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 470db6efaeb6..de6c2efd0479 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -399,6 +399,7 @@ static void pseries_dedicated_idle_sleep(void)
 	 * a good time to find other work to dispatch.
 	 */
 	get_lppaca()->idle = 1;
+	get_lppaca()->donate_dedicated_cpu = 1;
 
 	/*
 	 * We come in with interrupts disabled, and need_resched()
@@ -431,6 +432,7 @@ static void pseries_dedicated_idle_sleep(void)
 
 out:
 	HMT_medium();
+	get_lppaca()->donate_dedicated_cpu = 0;
 	get_lppaca()->idle = 0;
 }
 

commit 55b61fec22caa3e7872caea6c4100fc75cb8f49b
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu May 3 17:26:52 2007 +1000

    [POWERPC] Rename device_is_compatible to of_device_is_compatible
    
    for consistency with other Open Firmware interfaces (and Sparc).
    
    This is just a straight replacement.
    
    This leaves the compatibility define in place.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 33eec2822c66..470db6efaeb6 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -168,7 +168,7 @@ static void __init pseries_mpic_init_IRQ(void)
 
 	/* Look for cascade */
 	for_each_node_by_type(np, "interrupt-controller")
-		if (device_is_compatible(np, "chrp,iic")) {
+		if (of_device_is_compatible(np, "chrp,iic")) {
 			cascade = np;
 			break;
 		}

commit 8d8a0241eb019ce9648a77b55f9f76a834207cbb
Author: Olaf Hering <olaf@aepfle.de>
Date:   Thu Apr 26 06:36:56 2007 +1000

    [POWERPC] Generic check_legacy_ioport
    
    check_legacy_ioport makes only sense on PREP, CHRP and pSeries.
    They may have an isa node with PS/2, parport, floppy and serial ports.
    
    Remove the check_legacy_ioport call from ppc_md, it's not needed
    anymore.  Hardware capabilities come from the device-tree.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e2fcd2307e67..33eec2822c66 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -335,32 +335,6 @@ static void __init pSeries_init_early(void)
 	DBG(" <- pSeries_init_early()\n");
 }
 
-
-static int pSeries_check_legacy_ioport(unsigned int baseport)
-{
-	struct device_node *np;
-
-#define I8042_DATA_REG	0x60
-#define FDC_BASE	0x3f0
-
-
-	switch(baseport) {
-	case I8042_DATA_REG:
-		np = of_find_node_by_type(NULL, "8042");
-		if (np == NULL)
-			return -ENODEV;
-		of_node_put(np);
-		break;
-	case FDC_BASE:
-		np = of_find_node_by_type(NULL, "fdc");
-		if (np == NULL)
-			return -ENODEV;
-		of_node_put(np);
-		break;
-	}
-	return 0;
-}
-
 /*
  * Called very early, MMU is off, device-tree isn't unflattened
  */
@@ -537,7 +511,6 @@ define_machine(pseries) {
 	.set_rtc_time		= rtas_set_rtc_time,
 	.calibrate_decr		= generic_calibrate_decr,
 	.progress		= rtas_progress,
-	.check_legacy_ioport	= pSeries_check_legacy_ioport,
 	.system_reset_exception = pSeries_system_reset_exception,
 	.machine_check_exception = pSeries_machine_check_exception,
 };

commit e2eb63927bfcb54232163bfec32440246fd44457
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 3 22:26:41 2007 +1000

    [POWERPC] Rename get_property to of_get_property: arch/powerpc
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 54e93eb8a8ee..e2fcd2307e67 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -93,7 +93,7 @@ static void pSeries_show_cpuinfo(struct seq_file *m)
 
 	root = of_find_node_by_path("/");
 	if (root)
-		model = get_property(root, "model", NULL);
+		model = of_get_property(root, "model", NULL);
 	seq_printf(m, "machine\t\t: CHRP %s\n", model);
 	of_node_put(root);
 }
@@ -140,7 +140,7 @@ static void __init pseries_mpic_init_IRQ(void)
 
 	np = of_find_node_by_path("/");
 	naddr = of_n_addr_cells(np);
-	opprop = get_property(np, "platform-open-pic", &opplen);
+	opprop = of_get_property(np, "platform-open-pic", &opplen);
 	if (opprop != 0) {
 		openpic_addr = of_read_number(opprop, naddr);
 		printk(KERN_DEBUG "OpenPIC addr: %lx\n", openpic_addr);
@@ -189,7 +189,7 @@ static void __init pseries_mpic_init_IRQ(void)
 			break;
 		if (strcmp(np->name, "pci") != 0)
 			continue;
-		addrp = get_property(np, "8259-interrupt-acknowledge",
+		addrp = of_get_property(np, "8259-interrupt-acknowledge",
 					    NULL);
 		if (addrp == NULL)
 			continue;
@@ -226,7 +226,7 @@ static void __init pseries_discover_pic(void)
 
 	for (np = NULL; (np = of_find_node_by_name(np,
 						   "interrupt-controller"));) {
-		typep = get_property(np, "compatible", NULL);
+		typep = of_get_property(np, "compatible", NULL);
 		if (strstr(typep, "open-pic")) {
 			pSeries_mpic_node = of_node_get(np);
 			ppc_md.init_IRQ       = pseries_mpic_init_IRQ;

commit a8bda5dd4f99d6469f3c0dc362db3cce8a4d6416
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Apr 3 10:56:50 2007 +1000

    [POWERPC] Rename prom_n_addr_cells to of_n_addr_cells
    
    This is more consistent and gets us closer to the Sparc code.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index ff87b1ad8ce9..54e93eb8a8ee 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -139,7 +139,7 @@ static void __init pseries_mpic_init_IRQ(void)
 	struct mpic *mpic;
 
 	np = of_find_node_by_path("/");
-	naddr = prom_n_addr_cells(np);
+	naddr = of_n_addr_cells(np);
 	opprop = get_property(np, "platform-open-pic", &opplen);
 	if (opprop != 0) {
 		openpic_addr = of_read_number(opprop, naddr);
@@ -193,7 +193,7 @@ static void __init pseries_mpic_init_IRQ(void)
 					    NULL);
 		if (addrp == NULL)
 			continue;
-		naddr = prom_n_addr_cells(np);
+		naddr = of_n_addr_cells(np);
 		intack = addrp[naddr-1];
 		if (naddr > 1)
 			intack |= ((unsigned long)addrp[naddr-2]) << 32;

commit bed59275810a55500e885cbdc5c2a0507f13c00e
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Sun Mar 4 17:04:44 2007 +1100

    [POWERPC] Allow pSeries to build without CONFIG_PCI
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 34aff47b1f55..ff87b1ad8ce9 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -65,6 +65,7 @@
 #include <asm/udbg.h>
 #include <asm/smp.h>
 #include <asm/firmware.h>
+#include <asm/eeh.h>
 
 #include "plpar_wrappers.h"
 #include "pseries.h"
@@ -514,6 +515,10 @@ void pSeries_power_off(void)
 	for (;;);
 }
 
+#ifndef CONFIG_PCI
+void pSeries_final_fixup(void) { }
+#endif
+
 define_machine(pseries) {
 	.name			= "pSeries",
 	.probe			= pSeries_probe,

commit 5d30bf309717a518d0c4180af41650d4dcd3bb38
Author: Manish Ahuja <ahuja@austin.ibm.com>
Date:   Thu Feb 8 16:01:17 2007 -0600

    [POWERPC] pseries: Enabling auto poweron after power is restored.
    
    During power outages, the UPS notifies the system for a shutdown.
    In the current setup, it isn't possible to poweron when power is
    restored.  This patch fixes the issue by calling the right
    ibm,power-off-ups token during such events.  It also adds a sysfs
    interface so userspace can specify whether or not to power on when
    power is restored.
    
    Signed-off-by: Manish Ahuja <ahuja@austin.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 435a04596526..34aff47b1f55 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -486,6 +486,34 @@ static int pSeries_pci_probe_mode(struct pci_bus *bus)
 	return PCI_PROBE_NORMAL;
 }
 
+/**
+ * pSeries_power_off - tell firmware about how to power off the system.
+ *
+ * This function calls either the power-off rtas token in normal cases
+ * or the ibm,power-off-ups token (if present & requested) in case of
+ * a power failure. If power-off token is used, power on will only be
+ * possible with power button press. If ibm,power-off-ups token is used
+ * it will allow auto poweron after power is restored.
+ */
+void pSeries_power_off(void)
+{
+	int rc;
+	int rtas_poweroff_ups_token = rtas_token("ibm,power-off-ups");
+
+	if (rtas_flash_term_hook)
+		rtas_flash_term_hook(SYS_POWER_OFF);
+
+	if (rtas_poweron_auto == 0 ||
+		rtas_poweroff_ups_token == RTAS_UNKNOWN_SERVICE) {
+		rc = rtas_call(rtas_token("power-off"), 2, 1, NULL, -1, -1);
+		printk(KERN_INFO "RTAS power-off returned %d\n", rc);
+	} else {
+		rc = rtas_call(rtas_poweroff_ups_token, 0, 1, NULL);
+		printk(KERN_INFO "RTAS ibm,power-off-ups returned %d\n", rc);
+	}
+	for (;;);
+}
+
 define_machine(pseries) {
 	.name			= "pSeries",
 	.probe			= pSeries_probe,
@@ -496,7 +524,7 @@ define_machine(pseries) {
 	.pcibios_fixup		= pSeries_final_fixup,
 	.pci_probe_mode		= pSeries_pci_probe_mode,
 	.restart		= rtas_restart,
-	.power_off		= rtas_power_off,
+	.power_off		= pSeries_power_off,
 	.halt			= rtas_halt,
 	.panic			= rtas_os_term,
 	.get_boot_time		= rtas_get_boot_time,

commit dce623e0827e8d0ad60ce7f385c3394bf1b0bae0
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Feb 8 18:33:55 2007 +1100

    [POWERPC] Cleanup pseries kexec code
    
    Move all the pseries kexec code into one file, platforms/pseries/kexec.c
    Provide helpers for setting up ppc_md.kexec_cpu_down, so that we don't
    have to have #ifdef CONFIG_KEXEC in setup.c
    
    Move the initialisation of the ppc_md kexec callbacks into an init routine.
    This is well and truly early enough to cause no change in behaviour, we
    can't kexec until userspace has given us a kernel to kexec into.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 769815680be1..435a04596526 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -55,7 +55,6 @@
 #include <asm/dma.h>
 #include <asm/machdep.h>
 #include <asm/irq.h>
-#include <asm/kexec.h>
 #include <asm/time.h>
 #include <asm/nvram.h>
 #include "xics.h"
@@ -219,42 +218,6 @@ static void pseries_lpar_enable_pmcs(void)
 		get_lppaca()->pmcregs_in_use = 1;
 }
 
-#ifdef CONFIG_KEXEC
-static void pseries_kexec_cpu_down(int crash_shutdown, int secondary)
-{
-	/* Don't risk a hypervisor call if we're crashing */
-	if (firmware_has_feature(FW_FEATURE_SPLPAR) && !crash_shutdown) {
-		unsigned long addr;
-
-		addr = __pa(get_slb_shadow());
-		if (unregister_slb_shadow(hard_smp_processor_id(), addr))
-			printk("SLB shadow buffer deregistration of "
-			       "cpu %u (hw_cpu_id %d) failed\n",
-			       smp_processor_id(),
-			       hard_smp_processor_id());
-
-		addr = __pa(get_lppaca());
-		if (unregister_vpa(hard_smp_processor_id(), addr)) {
-			printk("VPA deregistration of cpu %u (hw_cpu_id %d) "
-					"failed\n", smp_processor_id(),
-					hard_smp_processor_id());
-		}
-	}
-}
-
-static void pseries_kexec_cpu_down_mpic(int crash_shutdown, int secondary)
-{
-	pseries_kexec_cpu_down(crash_shutdown, secondary);
-	mpic_teardown_this_cpu(secondary);
-}
-
-static void pseries_kexec_cpu_down_xics(int crash_shutdown, int secondary)
-{
-	pseries_kexec_cpu_down(crash_shutdown, secondary);
-	xics_teardown_cpu(secondary);
-}
-#endif /* CONFIG_KEXEC */
-
 static void __init pseries_discover_pic(void)
 {
 	struct device_node *np;
@@ -267,16 +230,12 @@ static void __init pseries_discover_pic(void)
 			pSeries_mpic_node = of_node_get(np);
 			ppc_md.init_IRQ       = pseries_mpic_init_IRQ;
 			ppc_md.get_irq        = mpic_get_irq;
-#ifdef CONFIG_KEXEC
-			ppc_md.kexec_cpu_down = pseries_kexec_cpu_down_mpic;
-#endif
+			setup_kexec_cpu_down_mpic();
 			smp_init_pseries_mpic();
 			return;
 		} else if (strstr(typep, "ppc-xicp")) {
 			ppc_md.init_IRQ       = xics_init_IRQ;
-#ifdef CONFIG_KEXEC
-			ppc_md.kexec_cpu_down = pseries_kexec_cpu_down_xics;
-#endif
+			setup_kexec_cpu_down_xics();
 			smp_init_pseries_xics();
 			return;
 		}
@@ -548,9 +507,4 @@ define_machine(pseries) {
 	.check_legacy_ioport	= pSeries_check_legacy_ioport,
 	.system_reset_exception = pSeries_system_reset_exception,
 	.machine_check_exception = pSeries_machine_check_exception,
-#ifdef CONFIG_KEXEC
-	.machine_kexec		= default_machine_kexec,
-	.machine_kexec_prepare	= default_machine_kexec_prepare,
-	.machine_crash_shutdown	= default_machine_crash_shutdown,
-#endif
 };

commit 8feaeca23ab8f520e7af2a862fd6ea8e7bfd8854
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Feb 8 18:33:55 2007 +1100

    [POWERPC] Cleanup pseries smp initialisation code
    
    Move some extern declarations from setup.c into the new pseries.h.
    While we're at it, provide dummy implementations for !SMP, to avoid
    cluttering the C file with more #ifdefs.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index a28264ce1044..769815680be1 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -77,8 +77,6 @@
 #endif
 
 /* move those away to a .h */
-extern void smp_init_pseries_mpic(void);
-extern void smp_init_pseries_xics(void);
 extern void find_udbg_vterm(void);
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
@@ -272,18 +270,14 @@ static void __init pseries_discover_pic(void)
 #ifdef CONFIG_KEXEC
 			ppc_md.kexec_cpu_down = pseries_kexec_cpu_down_mpic;
 #endif
-#ifdef CONFIG_SMP
 			smp_init_pseries_mpic();
-#endif
 			return;
 		} else if (strstr(typep, "ppc-xicp")) {
 			ppc_md.init_IRQ       = xics_init_IRQ;
 #ifdef CONFIG_KEXEC
 			ppc_md.kexec_cpu_down = pseries_kexec_cpu_down_xics;
 #endif
-#ifdef CONFIG_SMP
 			smp_init_pseries_xics();
-#endif
 			return;
 		}
 	}

commit 577830b034bc11c93d4b9e21e8782900d5485e7f
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Feb 8 18:33:51 2007 +1100

    [POWERPC] Consolidate pseries platform header files into pseries.h
    
    Following the example of platforms/pasemi, consolidate a couple of
    tiny header files in platforms/pseries into pseries.h.
    
    This gives us a convenient place to put things that need to be
    available to the platform code, but not public. And hopefully will
    help people resist the temptation of sticking externs in C files.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 042ecae107ac..a28264ce1044 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -65,10 +65,10 @@
 #include <asm/i8259.h>
 #include <asm/udbg.h>
 #include <asm/smp.h>
+#include <asm/firmware.h>
 
 #include "plpar_wrappers.h"
-#include "ras.h"
-#include "firmware.h"
+#include "pseries.h"
 
 #ifdef DEBUG
 #define DBG(fmt...) udbg_printf(fmt)

commit a223535425eb28082a0925b0ce2f02f962936cf4
Author: Anton Blanchard <anton@samba.org>
Date:   Fri Dec 8 18:22:09 2006 +1100

    [POWERPC] dont allow pSeries_probe to succeed without initialising MMU
    
    pSeries_probe can decide that we are a pseries but then fail to
    initialise the MMU. If an rtas node doesnt exist, we continually fall
    out of pSeries_probe_hypertas early and never get to the MMU init code.
    
    While pseries without RTAS is an illegal combination, the way we
    currently fail is a pain to track down, and can happen if your flattened
    device tree code has issues (like mine did :).
    
    With the following patch we init the MMU, come up and print some
    warnings about RTAS not existing, instead of looping on 0x400 exceptions.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 3e2f7467057d..042ecae107ac 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -422,11 +422,6 @@ static int __init pSeries_probe_hypertas(unsigned long node,
 	if (of_get_flat_dt_prop(node, "ibm,hypertas-functions", NULL) != NULL)
  		powerpc_firmware_features |= FW_FEATURE_LPAR;
 
-	if (firmware_has_feature(FW_FEATURE_LPAR))
-		hpte_init_lpar();
-	else
-		hpte_init_native();
-
  	return 1;
 }
 
@@ -452,6 +447,11 @@ static int __init pSeries_probe(void)
 	/* Now try to figure out if we are running on LPAR */
 	of_scan_flat_dt(pSeries_probe_hypertas, NULL);
 
+	if (firmware_has_feature(FW_FEATURE_LPAR))
+		hpte_init_lpar();
+	else
+		hpte_init_native();
+
 	DBG("Machine is%s LPAR !\n",
 	    (powerpc_firmware_features & FW_FEATURE_LPAR) ? "" : " not");
 

commit 5773bbcdec54b7258cb9e2aa6f3459b4cbfd9dc5
Author: Anton Blanchard <anton@samba.org>
Date:   Fri Dec 8 18:08:37 2006 +1100

    [POWERPC] micro optimise pSeries_probe
    
    We find the OF root the line before, we may as well use it.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 6090d753c44c..3e2f7467057d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -433,8 +433,8 @@ static int __init pSeries_probe_hypertas(unsigned long node,
 static int __init pSeries_probe(void)
 {
 	unsigned long root = of_get_flat_dt_root();
- 	char *dtype = of_get_flat_dt_prop(of_get_flat_dt_root(),
- 					  "device_type", NULL);
+ 	char *dtype = of_get_flat_dt_prop(root, "device_type", NULL);
+
  	if (dtype == NULL)
  		return 0;
  	if (strcmp(dtype, "chrp"))

commit 04da6af960194ecdee4c29cd3f86e766903418ca
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue Dec 5 17:52:37 2006 +1100

    [POWERPC] Move pSeries_mach_cpu_die() into platforms/pseries/hotplug-cpu.c
    
    Move pSeries_mach_cpu_die() into platforms/pseries/hotplug-cpu.c,
    this allows rtas_stop_self() to be static so remove the prototype.
    
    Wire up pSeries_mach_cpu_die() in the initcall, rather than statically
    in setup.c, the initcall will still run prior to the cpu hotplug code
    being callable, so there should be no change in behaviour.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 0dc2548ca9bc..6090d753c44c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -347,21 +347,6 @@ static int __init pSeries_init_panel(void)
 }
 arch_initcall(pSeries_init_panel);
 
-#ifdef CONFIG_HOTPLUG_CPU
-static void pSeries_mach_cpu_die(void)
-{
-	local_irq_disable();
-	idle_task_exit();
-	xics_teardown_cpu(0);
-	rtas_stop_self();
-	/* Should never get here... */
-	BUG();
-	for(;;);
-}
-#else
-#define pSeries_mach_cpu_die NULL
-#endif
-
 static int pseries_set_dabr(unsigned long dabr)
 {
 	return plpar_hcall_norets(H_SET_DABR, dabr);
@@ -561,7 +546,6 @@ define_machine(pseries) {
 	.power_off		= rtas_power_off,
 	.halt			= rtas_halt,
 	.panic			= rtas_os_term,
-	.cpu_die		= pSeries_mach_cpu_die,
 	.get_boot_time		= rtas_get_boot_time,
 	.get_rtc_time		= rtas_get_rtc_time,
 	.set_rtc_time		= rtas_set_rtc_time,

commit 088df4d256227b3d927bb6ed57e66d138da0565c
Author: Linas Vepstas <linas@austin.ibm.com>
Date:   Thu Nov 16 15:41:15 2006 -0600

    [POWERPC] Wrap cpu_die() with CONFIG_HOTPLUG_CPU
    
    Per email discussion, it appears that rtas_stop_self()
    and pSeries_mach_cpu_die() should not be compiled if
    CONFIG_HOTPLUG_CPU is not defined. This patch adds
    #ifdefs around these bits of code.
    
    Signed-off-by: Linas Vepstas <linas@austin.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index a8f3812aa38e..0dc2548ca9bc 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -347,6 +347,7 @@ static int __init pSeries_init_panel(void)
 }
 arch_initcall(pSeries_init_panel);
 
+#ifdef CONFIG_HOTPLUG_CPU
 static void pSeries_mach_cpu_die(void)
 {
 	local_irq_disable();
@@ -357,6 +358,9 @@ static void pSeries_mach_cpu_die(void)
 	BUG();
 	for(;;);
 }
+#else
+#define pSeries_mach_cpu_die NULL
+#endif
 
 static int pseries_set_dabr(unsigned long dabr)
 {

commit f90bb153b1493719d18b4529a46ebfe43220ea6c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat Nov 11 17:24:51 2006 +1100

    [POWERPC] Make pci_read_irq_line the default
    
    This patch reworks the way IRQs are fixed up on PCI for arch powerpc.
    
    It makes pci_read_irq_line() called by default in the PCI code for
    devices that are probed, and add an optional per-device fixup in
    ppc_md for platforms that really need to correct what they obtain
    from pci_read_irq_line().
    
    It also removes ppc_md.irq_bus_setup which was only used by pSeries
    and should not be needed anymore.
    
    I've also removed the pSeries s7a workaround as it can't work with
    the current interrupt code anyway. I'm trying to get one of these
    machines working so I can test a proper fix for that problem.
    
    I also haven't updated the old-style fixup code from 85xx_cds.c
    because it's actually buggy :) It assigns pci_dev->irq hard coded
    numbers which is no good with the new IRQ mapping code. It should
    at least use irq_create_mapping(NULL, hard_coded_number); and possibly
    also set_irq_type() to set them as level low.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 89a8119f988d..a8f3812aa38e 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -553,7 +553,6 @@ define_machine(pseries) {
 	.log_error		= pSeries_log_error,
 	.pcibios_fixup		= pSeries_final_fixup,
 	.pci_probe_mode		= pSeries_pci_probe_mode,
-	.irq_bus_setup		= pSeries_irq_bus_setup,
 	.restart		= rtas_restart,
 	.power_off		= rtas_power_off,
 	.halt			= rtas_halt,

commit 35a84c2f56e0f77ea2c5a4327b17104705f4c8c7
Author: Olaf Hering <olaf@aepfle.de>
Date:   Sat Oct 7 22:08:26 2006 +1000

    [POWERPC] Fix up after irq changes
    
    Remove struct pt_regs * from all handlers.
    Also remove the regs argument from get_irq() functions.
    Compile tested with arch/powerpc/config/* and
    arch/ppc/configs/prep_defconfig
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index ad9aec2c6fee..89a8119f988d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -123,7 +123,7 @@ static void __init fwnmi_init(void)
 
 void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc)
 {
-	unsigned int cascade_irq = i8259_irq(get_irq_regs());
+	unsigned int cascade_irq = i8259_irq();
 	if (cascade_irq != NO_IRQ)
 		generic_handle_irq(cascade_irq);
 	desc->chip->eoi(irq);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f82b13e531a3..ad9aec2c6fee 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -121,12 +121,11 @@ static void __init fwnmi_init(void)
 		fwnmi_active = 1;
 }
 
-void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc,
-			  struct pt_regs *regs)
+void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc)
 {
-	unsigned int cascade_irq = i8259_irq(regs);
+	unsigned int cascade_irq = i8259_irq(get_irq_regs());
 	if (cascade_irq != NO_IRQ)
-		generic_handle_irq(cascade_irq, regs);
+		generic_handle_irq(cascade_irq);
 	desc->chip->eoi(irq);
 }
 

commit 586da2cc78131d194ecacaf4de26b49691de5fd3
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue Oct 3 14:48:43 2006 +1000

    [POWERPC] Fix a printk in pseries_mpic_init_IRQ
    
    This should probably say "mpic" to save confusion.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 43dbf737698c..f82b13e531a3 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -180,7 +180,7 @@ static void __init pseries_mpic_init_IRQ(void)
 
 	cascade_irq = irq_of_parse_and_map(cascade, 0);
 	if (cascade == NO_IRQ) {
-		printk(KERN_ERR "xics: failed to map cascade interrupt");
+		printk(KERN_ERR "mpic: failed to map cascade interrupt");
 		return;
 	}
 

commit ccaa36f73544163ef6e15eb29a620130755f6001
Merge: b4a9071af62f 5e9808235816
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Oct 3 08:52:26 2006 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/paulus/powerpc: (29 commits)
      [POWERPC] Fix rheap alignment problem
      [POWERPC] Use check_legacy_ioport() for ISAPnP
      [POWERPC] Avoid NULL pointer in gpio1_interrupt
      [POWERPC] Enable generic rtc hook for the MPC8349 mITX
      [POWERPC] Add powerpc get/set_rtc_time interface to new generic rtc class
      [POWERPC] Create a "wrapper" script and use it in arch/powerpc/boot
      [POWERPC] fix spin lock nesting in hvc_iseries
      [POWERPC] EEH failure to mark pci slot as frozen.
      [POWERPC] update powerpc defconfig files after libata kconfig breakage
      [POWERPC] enable sysrq in pmac32_defconfig
      [POWERPC] UPIO_TSI cleanup
      [POWERPC] rewrite mkprep and mkbugboot in sane C
      [POWERPC] maple/pci iomem annotations
      [POWERPC] powerpc oprofile __user annotations
      [POWERPC] cell spufs iomem annotations
      [POWERPC] NULL noise removal: spufs
      [POWERPC] ppc math-emu needs -fno-builtin-fabs for math.c and fabs.c
      [POWERPC] update mpc8349_itx_defconfig and remove some debug settings
      [POWERPC] Always call cede in pseries dedicated idle loop
      [POWERPC] Fix loop logic in irq_alloc_virt()
      ...

commit 873ef76bdc56561df75ef5c3f3842c3a64da795d
Author: Olaf Hering <olaf@aepfle.de>
Date:   Tue Oct 3 01:13:56 2006 -0700

    [PATCH] restore parport_pc probing on powermac
    
    The last change for partport_pc did fix the common case for all PowerMacs,
    but it broke the case for PCI multiport IO cards.  In fact, the config
    option CONFIG_PARPORT_PC_SUPERIO=y lead to a hard crash when cups probed
    the parport driver.  It enables the winbond and smsc probing.
    
    Remove the PARPORT_BASE check again, parport_pc_find_nonpci_ports() will
    take care of it.  All powerpc configs should have
    CONFIG_PARPORT_PC_SUPERIO=n, the code did not find anything on the chrp
    boards we tested it on.
    
    Tested on a G4/466 with a PCI card:
    
    0001:10:13.0 Serial controller: Timedia Technology Co Ltd PCI2S550 (Dual 16550 UART) (rev 01) (prog-if 02 [16550])
            Subsystem: Timedia Technology Co Ltd Unknown device 5079
            Control: I/O+ Mem- BusMaster- SpecCycle- MemWINV- VGASnoop- ParErr- Stepping+ SERR- FastB2B-
            Status: Cap- 66MHz- UDF- FastB2B+ ParErr- DEVSEL=medium >TAbort- <TAbort- <MAbort- >SERR- <PERR-
            Interrupt: pin A routed to IRQ 53
            Region 0: I/O ports at f2000800 [size=32]
            Region 2: I/O ports at f2000870 [size=8]
            Region 3: I/O ports at f2000860 [size=8]
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 98189d8efaca..4f0097f31bdb 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -415,12 +415,6 @@ static int pSeries_check_legacy_ioport(unsigned int baseport)
 			return -ENODEV;
 		of_node_put(np);
 		break;
-	case PARALLEL_BASE:
-		np = of_find_node_by_type(NULL, "parallel");
-		if (np == NULL)
-			return -ENODEV;
-		of_node_put(np);
-		break;
 	}
 	return 0;
 }

commit 96b644bdec977b97a45133e5b4466ba47a7a5e65
Author: Serge E. Hallyn <serue@us.ibm.com>
Date:   Mon Oct 2 02:18:13 2006 -0700

    [PATCH] namespaces: utsname: use init_utsname when appropriate
    
    In some places, particularly drivers and __init code, the init utsns is the
    appropriate one to use.  This patch replaces those with a the init_utsname
    helper.
    
    Changes: Removed several uses of init_utsname().  Hope I picked all the
            right ones in net/ipv4/ipconfig.c.  These are now changed to
            utsname() (the per-process namespace utsname) in the previous
            patch (2/7)
    
    [akpm@osdl.org: CIFS fix]
    Signed-off-by: Serge E. Hallyn <serue@us.ibm.com>
    Cc: Kirill Korotaev <dev@openvz.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Herbert Poetzl <herbert@13thfloor.at>
    Cc: Andrey Savochkin <saw@sw.ru>
    Cc: Serge Hallyn <serue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 8ed362140452..98189d8efaca 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -342,7 +342,7 @@ static int __init pSeries_init_panel(void)
 {
 	/* Manually leave the kernel version on the panel. */
 	ppc_md.progress("Linux ppc64\n", 0);
-	ppc_md.progress(system_utsname.release, 0);
+	ppc_md.progress(init_utsname()->version, 0);
 
 	return 0;
 }

commit 30cbc22217bb3d5d4c74c88127fbf595460bdb76
Author: Olaf Hering <olaf@aepfle.de>
Date:   Sat Sep 30 23:27:57 2006 -0700

    [PATCH] update legacy io handling for pmac
    
    ppc can boot one single binary on prep, chrp and pmac boards.  ppc64 can
    boot one single binary on pseries and G5 boards.  pmac has no legacy io,
    probing for PC style legacy hardware (or accessing the legacy io area
    regulary) may lead to a hard crash:
    
    * add check for parport_pc, exit on pmac.  32bit chrp has no
      ->check_legacy_ioport, the probe is always called.  64bit chrp has
      check_legacy_ioport, check for a "parallel" node
    
    * add check for isapnp, only PReP boards may have real ISA slots.  32bit
      PReP will have no ->check_legacy_ioport, the probe is always called.
    
    * update code in i8042_platform_init.  Run ->check_legacy_ioport first,
      always call request_region.  No functional change.  Remove whitespace
      before i8042_reset init.
    
    Signed-off-by: Olaf Hering <olaf@aepfle.de>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Adam Belay <ambx1@neo.rr.com>
    Cc: Dmitry Torokhov <dtor@mail.ru>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index a6398fbe530d..8ed362140452 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -415,6 +415,12 @@ static int pSeries_check_legacy_ioport(unsigned int baseport)
 			return -ENODEV;
 		of_node_put(np);
 		break;
+	case PARALLEL_BASE:
+		np = of_find_node_by_type(NULL, "parallel");
+		if (np == NULL)
+			return -ENODEV;
+		of_node_put(np);
+		break;
 	}
 	return 0;
 }

commit 0ddd3e7d07d6adc4e905ee869a85db5184a02c17
Author: Anton Blanchard <anton@samba.org>
Date:   Fri Sep 22 20:30:14 2006 +1000

    [POWERPC] Always call cede in pseries dedicated idle loop
    
    The smt_snooze_delay logic changed a bit when the idle loops were
    consolidated. A value of 0 used to mean we always polled, now it means
    we always sleep. Instead of restoring the old behaviour, lets put a
    reasonable default in smt_snooze_delay. This means we spin for a bit
    (in case an external interrupt comes in) and then sleep.
    
    Also the pseries dedicated idle loop currently does not cede both
    threads in an SMT pair. The hypervisor wants us to call in so it can
    power manage, so lets do that.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index a6398fbe530d..2551da46b2a6 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -477,7 +477,6 @@ static void pseries_dedicated_idle_sleep(void)
 { 
 	unsigned int cpu = smp_processor_id();
 	unsigned long start_snooze;
-	unsigned long *smt_snooze_delay = &__get_cpu_var(smt_snooze_delay);
 
 	/*
 	 * Indicate to the HV that we are idle. Now would be
@@ -490,9 +489,9 @@ static void pseries_dedicated_idle_sleep(void)
 	 * has been checked recently.  If we should poll for a little
 	 * while, do so.
 	 */
-	if (*smt_snooze_delay) {
+	if (__get_cpu_var(smt_snooze_delay)) {
 		start_snooze = get_tb() +
-			*smt_snooze_delay * tb_ticks_per_usec;
+			__get_cpu_var(smt_snooze_delay) * tb_ticks_per_usec;
 		local_irq_enable();
 		set_thread_flag(TIF_POLLING_NRFLAG);
 
@@ -512,24 +511,7 @@ static void pseries_dedicated_idle_sleep(void)
 			goto out;
 	}
 
-	/*
-	 * If not SMT, cede processor.  If CPU is running SMT
-	 * cede if the other thread is not idle, so that it can
-	 * go single-threaded.  If the other thread is idle,
-	 * we ask the hypervisor if it has pending work it
-	 * wants to do and cede if it does.  Otherwise we keep
-	 * polling in order to reduce interrupt latency.
-	 *
-	 * Doing the cede when the other thread is active will
-	 * result in this thread going dormant, meaning the other
-	 * thread gets to run in single-threaded (ST) mode, which
-	 * is slightly faster than SMT mode with this thread at
-	 * very low priority.  The cede enables interrupts, which
-	 * doesn't matter here.
-	 */
-	if (!cpu_has_feature(CPU_FTR_SMT) || !lppaca[cpu ^ 1].idle
-	    || poll_pending() == H_PENDING)
-		cede_processor();
+	cede_processor();
 
 out:
 	HMT_medium();

commit f50d4cfc98d70f919afb2924b1b53c36b2f4e62f
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Aug 24 16:54:08 2006 +1000

    [POWERPC] Split out vpa unregister logic from pseries_kexec_cpu_down_xics()
    
    As part of the new irq code pseries_kexec_cpu_down() was split into a
    xics and mpic version. The vpa unregister logic is now only done in the
    xics routine, and although that's ok in practice (we don't have SPLPAR
    machines with mpic), I'd rather have the two concepts stay separate.
    
    So move the vpa unregister into pseries_kexec_cpu_down(), which gets called
    by both the xics and mpic routines. This also gives us an obvious place to
    put any new kexec-down logic needed in future.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 1587efc51057..a6398fbe530d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -223,12 +223,7 @@ static void pseries_lpar_enable_pmcs(void)
 }
 
 #ifdef CONFIG_KEXEC
-static void pseries_kexec_cpu_down_mpic(int crash_shutdown, int secondary)
-{
-	mpic_teardown_this_cpu(secondary);
-}
-
-static void pseries_kexec_cpu_down_xics(int crash_shutdown, int secondary)
+static void pseries_kexec_cpu_down(int crash_shutdown, int secondary)
 {
 	/* Don't risk a hypervisor call if we're crashing */
 	if (firmware_has_feature(FW_FEATURE_SPLPAR) && !crash_shutdown) {
@@ -248,6 +243,17 @@ static void pseries_kexec_cpu_down_xics(int crash_shutdown, int secondary)
 					hard_smp_processor_id());
 		}
 	}
+}
+
+static void pseries_kexec_cpu_down_mpic(int crash_shutdown, int secondary)
+{
+	pseries_kexec_cpu_down(crash_shutdown, secondary);
+	mpic_teardown_this_cpu(secondary);
+}
+
+static void pseries_kexec_cpu_down_xics(int crash_shutdown, int secondary)
+{
+	pseries_kexec_cpu_down(crash_shutdown, secondary);
 	xics_teardown_cpu(secondary);
 }
 #endif /* CONFIG_KEXEC */

commit 32bc6e095d75233e7c87cc6fa0e07942b124d194
Merge: 5cf13911b1e7 81b73dd92b97
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Aug 8 17:09:11 2006 +1000

    Merge branch 'merge'

commit 2f6093c84730b4bad65bcd0f2f904a5769b1dfc5
Author: Michael Neuling <mikey@neuling.org>
Date:   Mon Aug 7 16:19:19 2006 +1000

    [POWERPC] Implement SLB shadow buffer
    
    This adds a shadow buffer for the SLBs and regsiters it with PHYP.
    Only the bolted SLB entries (top 3) are shadowed.
    
    The SLB shadow buffer tells the hypervisor what the kernel needs to
    have in the SLB for the kernel to be able to function.  The hypervisor
    can use this information to speed up partition context switches.
    
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index de214d86ff44..6ebeecfd6bcb 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -234,9 +234,17 @@ static void pseries_kexec_cpu_down_xics(int crash_shutdown, int secondary)
 {
 	/* Don't risk a hypervisor call if we're crashing */
 	if (firmware_has_feature(FW_FEATURE_SPLPAR) && !crash_shutdown) {
-		unsigned long vpa = __pa(get_lppaca());
+		unsigned long addr;
 
-		if (unregister_vpa(hard_smp_processor_id(), vpa)) {
+		addr = __pa(get_slb_shadow());
+		if (unregister_slb_shadow(hard_smp_processor_id(), addr))
+			printk("SLB shadow buffer deregistration of "
+			       "cpu %u (hw_cpu_id %d) failed\n",
+			       smp_processor_id(),
+			       hard_smp_processor_id());
+
+		addr = __pa(get_lppaca());
+		if (unregister_vpa(hard_smp_processor_id(), addr)) {
 			printk("VPA deregistration of cpu %u (hw_cpu_id %d) "
 					"failed\n", smp_processor_id(),
 					hard_smp_processor_id());

commit dcc42f483d6808ba4d04af9da35e7e47b711f6c2
Author: Sonny Rao <sonny@burdell.org>
Date:   Wed Aug 2 00:20:09 2006 -0400

    [POWERPC] fix PMU initialization on pseries lpar
    
    We should not be calling power4_enable_pmcs() in
    pseries_lpar_enable_pmcs(); just doing the hypercall is sufficient.
    Prior to 2.6.15 we did not call power4_enable_pmcs() for an lpar.
    
    power4_enable_pmcs() tries to read the hid0 register which is no
    longer legal for an lpar in newer Power processors.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 71c634e0b87c..31867a701fcb 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -213,8 +213,6 @@ static void pseries_lpar_enable_pmcs(void)
 {
 	unsigned long set, reset;
 
-	power4_enable_pmcs();
-
 	set = 1UL << 63;
 	reset = 0;
 	plpar_hcall_norets(H_PERFMON, set, reset);

commit 57cad8084e0837e0f2c97da789ec9b3f36809be9
Merge: cb18bd40030c 49b1e3ea19b1
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Aug 1 10:37:25 2006 +1000

    Merge branch 'merge'

commit 954a46e2d5aec6f59976ddeb1d232b486e59b54a
Author: Jeremy Kerr <jk@ozlabs.org>
Date:   Wed Jul 12 15:39:43 2006 +1000

    [POWERPC] pseries: Constify & voidify get_property()
    
    Now that get_property() returns a void *, there's no need to cast its
    return value. Also, treat the return value as const, so we can
    constify get_property later.
    
    pseries platform changes.
    
    Built for pseries_defconfig
    
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 54a52437265c..927e0a423b87 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -133,9 +133,9 @@ void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc,
 static void __init pseries_mpic_init_IRQ(void)
 {
 	struct device_node *np, *old, *cascade = NULL;
-        unsigned int *addrp;
+        const unsigned int *addrp;
 	unsigned long intack = 0;
-	unsigned int *opprop;
+	const unsigned int *opprop;
 	unsigned long openpic_addr = 0;
 	unsigned int cascade_irq;
 	int naddr, n, i, opplen;
@@ -143,7 +143,7 @@ static void __init pseries_mpic_init_IRQ(void)
 
 	np = of_find_node_by_path("/");
 	naddr = prom_n_addr_cells(np);
-	opprop = (unsigned int *) get_property(np, "platform-open-pic", &opplen);
+	opprop = get_property(np, "platform-open-pic", &opplen);
 	if (opprop != 0) {
 		openpic_addr = of_read_number(opprop, naddr);
 		printk(KERN_DEBUG "OpenPIC addr: %lx\n", openpic_addr);
@@ -192,7 +192,7 @@ static void __init pseries_mpic_init_IRQ(void)
 			break;
 		if (strcmp(np->name, "pci") != 0)
 			continue;
-		addrp = (u32 *)get_property(np, "8259-interrupt-acknowledge",
+		addrp = get_property(np, "8259-interrupt-acknowledge",
 					    NULL);
 		if (addrp == NULL)
 			continue;
@@ -249,11 +249,11 @@ static void pseries_kexec_cpu_down_xics(int crash_shutdown, int secondary)
 static void __init pseries_discover_pic(void)
 {
 	struct device_node *np;
-	char *typep;
+	const char *typep;
 
 	for (np = NULL; (np = of_find_node_by_name(np,
 						   "interrupt-controller"));) {
-		typep = (char *)get_property(np, "compatible", NULL);
+		typep = get_property(np, "compatible", NULL);
 		if (strstr(typep, "open-pic")) {
 			pSeries_mpic_node = of_node_get(np);
 			ppc_md.init_IRQ       = pseries_mpic_init_IRQ;

commit 9b9b72fe703bd5b89533815eb7eb682cdaf60a6e
Author: Jake Moilanen <moilanen@austin.ibm.com>
Date:   Tue Jul 25 15:11:47 2006 -0500

    [POWERPC] Use H_CEDE on non-SMT
    
    On the JS21 systems, they have the SPLPAR hypertas set, but are not SMT
    capable.  So, they are not making the H_CEDE call.  This is causing the
    hypervisor to have to queue up work for the hdecr, taking an excessive
    amount of time in maintenance code, and causing jitter on the box.
    
    Making the H_CEDE call helps alleviate that problem.
    
    Signed-off-by: Jake Moilanen <moilanen@austin.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 54a52437265c..71c634e0b87c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -501,7 +501,8 @@ static void pseries_dedicated_idle_sleep(void)
 	}
 
 	/*
-	 * Cede if the other thread is not idle, so that it can
+	 * If not SMT, cede processor.  If CPU is running SMT
+	 * cede if the other thread is not idle, so that it can
 	 * go single-threaded.  If the other thread is idle,
 	 * we ask the hypervisor if it has pending work it
 	 * wants to do and cede if it does.  Otherwise we keep
@@ -514,7 +515,8 @@ static void pseries_dedicated_idle_sleep(void)
 	 * very low priority.  The cede enables interrupts, which
 	 * doesn't matter here.
 	 */
-	if (!lppaca[cpu ^ 1].idle || poll_pending() == H_PENDING)
+	if (!cpu_has_feature(CPU_FTR_SMT) || !lppaca[cpu ^ 1].idle
+	    || poll_pending() == H_PENDING)
 		cede_processor();
 
 out:

commit 0ebfff1491ef85d41ddf9c633834838be144f69f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jul 3 21:36:01 2006 +1000

    [POWERPC] Add new interrupt mapping core and change platforms to use it
    
    This adds the new irq remapper core and removes the old one.  Because
    there are some fundamental conflicts with the old code, like the value
    of NO_IRQ which I'm now setting to 0 (as per discussions with Linus),
    etc..., this commit also changes the relevant platform and driver code
    over to use the new remapper (so as not to cause difficulties later
    in bisecting).
    
    This patch removes the old pre-parsing of the open firmware interrupt
    tree along with all the bogus assumptions it made to try to renumber
    interrupts according to the platform. This is all to be handled by the
    new code now.
    
    For the pSeries XICS interrupt controller, a single remapper host is
    created for the whole machine regardless of how many interrupt
    presentation and source controllers are found, and it's set to match
    any device node that isn't a 8259.  That works fine on pSeries and
    avoids having to deal with some of the complexities of split source
    controllers vs. presentation controllers in the pSeries device trees.
    
    The powerpc i8259 PIC driver now always requests the legacy interrupt
    range. It also has the feature of being able to match any device node
    (including NULL) if passed no device node as an input. That will help
    porting over platforms with broken device-trees like Pegasos who don't
    have a proper interrupt tree.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 476b564a208b..54a52437265c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -76,6 +76,9 @@
 #define DBG(fmt...)
 #endif
 
+/* move those away to a .h */
+extern void smp_init_pseries_mpic(void);
+extern void smp_init_pseries_xics(void);
 extern void find_udbg_vterm(void);
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
@@ -83,7 +86,7 @@ int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 static void pseries_shared_idle_sleep(void);
 static void pseries_dedicated_idle_sleep(void);
 
-struct mpic *pSeries_mpic;
+static struct device_node *pSeries_mpic_node;
 
 static void pSeries_show_cpuinfo(struct seq_file *m)
 {
@@ -118,78 +121,92 @@ static void __init fwnmi_init(void)
 		fwnmi_active = 1;
 }
 
-void pSeries_8259_cascade(unsigned int irq, struct irq_desc *desc,
+void pseries_8259_cascade(unsigned int irq, struct irq_desc *desc,
 			  struct pt_regs *regs)
 {
-	unsigned int max = 100;
-
-	while(max--) {
-		int cascade_irq = i8259_irq(regs);
-		if (max == 99)
-			desc->chip->eoi(irq);
-		if (cascade_irq < 0)
-			break;
+	unsigned int cascade_irq = i8259_irq(regs);
+	if (cascade_irq != NO_IRQ)
 		generic_handle_irq(cascade_irq, regs);
-	};
+	desc->chip->eoi(irq);
 }
 
-static void __init pSeries_init_mpic(void)
+static void __init pseries_mpic_init_IRQ(void)
 {
+	struct device_node *np, *old, *cascade = NULL;
         unsigned int *addrp;
-	struct device_node *np;
 	unsigned long intack = 0;
-
-	/* All ISUs are setup, complete initialization */
-	mpic_init(pSeries_mpic);
-
-	/* Check what kind of cascade ACK we have */
-        if (!(np = of_find_node_by_name(NULL, "pci"))
-            || !(addrp = (unsigned int *)
-                 get_property(np, "8259-interrupt-acknowledge", NULL)))
-                printk(KERN_ERR "Cannot find pci to get ack address\n");
-        else
-		intack = addrp[prom_n_addr_cells(np)-1];
-	of_node_put(np);
-
-	/* Setup the legacy interrupts & controller */
-	i8259_init(intack, 0);
-
-	/* Hook cascade to mpic */
-	set_irq_chained_handler(NUM_ISA_INTERRUPTS, pSeries_8259_cascade);
-}
-
-static void __init pSeries_setup_mpic(void)
-{
 	unsigned int *opprop;
 	unsigned long openpic_addr = 0;
-        unsigned char senses[NR_IRQS - NUM_ISA_INTERRUPTS];
-        struct device_node *root;
-	int irq_count;
+	unsigned int cascade_irq;
+	int naddr, n, i, opplen;
+	struct mpic *mpic;
 
-	/* Find the Open PIC if present */
-	root = of_find_node_by_path("/");
-	opprop = (unsigned int *) get_property(root, "platform-open-pic", NULL);
+	np = of_find_node_by_path("/");
+	naddr = prom_n_addr_cells(np);
+	opprop = (unsigned int *) get_property(np, "platform-open-pic", &opplen);
 	if (opprop != 0) {
-		int n = prom_n_addr_cells(root);
-
-		for (openpic_addr = 0; n > 0; --n)
-			openpic_addr = (openpic_addr << 32) + *opprop++;
+		openpic_addr = of_read_number(opprop, naddr);
 		printk(KERN_DEBUG "OpenPIC addr: %lx\n", openpic_addr);
 	}
-	of_node_put(root);
+	of_node_put(np);
 
 	BUG_ON(openpic_addr == 0);
 
-	/* Get the sense values from OF */
-	prom_get_irq_senses(senses, NUM_ISA_INTERRUPTS, NR_IRQS);
-	
 	/* Setup the openpic driver */
-	irq_count = NR_IRQS - NUM_ISA_INTERRUPTS - 4; /* leave room for IPIs */
-	pSeries_mpic = mpic_alloc(openpic_addr, MPIC_PRIMARY,
-				  16, 16, irq_count, /* isu size, irq offset, irq count */ 
-				  NR_IRQS - 4, /* ipi offset */
-				  senses, irq_count, /* sense & sense size */
-				  " MPIC     ");
+	mpic = mpic_alloc(pSeries_mpic_node, openpic_addr,
+			  MPIC_PRIMARY,
+			  16, 250, /* isu size, irq count */
+			  " MPIC     ");
+	BUG_ON(mpic == NULL);
+
+	/* Add ISUs */
+	opplen /= sizeof(u32);
+	for (n = 0, i = naddr; i < opplen; i += naddr, n++) {
+		unsigned long isuaddr = of_read_number(opprop + i, naddr);
+		mpic_assign_isu(mpic, n, isuaddr);
+	}
+
+	/* All ISUs are setup, complete initialization */
+	mpic_init(mpic);
+
+	/* Look for cascade */
+	for_each_node_by_type(np, "interrupt-controller")
+		if (device_is_compatible(np, "chrp,iic")) {
+			cascade = np;
+			break;
+		}
+	if (cascade == NULL)
+		return;
+
+	cascade_irq = irq_of_parse_and_map(cascade, 0);
+	if (cascade == NO_IRQ) {
+		printk(KERN_ERR "xics: failed to map cascade interrupt");
+		return;
+	}
+
+	/* Check ACK type */
+	for (old = of_node_get(cascade); old != NULL ; old = np) {
+		np = of_get_parent(old);
+		of_node_put(old);
+		if (np == NULL)
+			break;
+		if (strcmp(np->name, "pci") != 0)
+			continue;
+		addrp = (u32 *)get_property(np, "8259-interrupt-acknowledge",
+					    NULL);
+		if (addrp == NULL)
+			continue;
+		naddr = prom_n_addr_cells(np);
+		intack = addrp[naddr-1];
+		if (naddr > 1)
+			intack |= ((unsigned long)addrp[naddr-2]) << 32;
+	}
+	if (intack)
+		printk(KERN_DEBUG "mpic: PCI 8259 intack at 0x%016lx\n",
+		       intack);
+	i8259_init(cascade, intack);
+	of_node_put(cascade);
+	set_irq_chained_handler(cascade_irq, pseries_8259_cascade);
 }
 
 static void pseries_lpar_enable_pmcs(void)
@@ -207,21 +224,67 @@ static void pseries_lpar_enable_pmcs(void)
 		get_lppaca()->pmcregs_in_use = 1;
 }
 
-static void __init pSeries_setup_arch(void)
+#ifdef CONFIG_KEXEC
+static void pseries_kexec_cpu_down_mpic(int crash_shutdown, int secondary)
 {
-	/* Fixup ppc_md depending on the type of interrupt controller */
-	if (ppc64_interrupt_controller == IC_OPEN_PIC) {
-		ppc_md.init_IRQ       = pSeries_init_mpic;
-		ppc_md.get_irq        = mpic_get_irq;
-		/* Allocate the mpic now, so that find_and_init_phbs() can
-		 * fill the ISUs */
-		pSeries_setup_mpic();
-	} else
-		ppc_md.init_IRQ       = xics_init_IRQ;
+	mpic_teardown_this_cpu(secondary);
+}
 
+static void pseries_kexec_cpu_down_xics(int crash_shutdown, int secondary)
+{
+	/* Don't risk a hypervisor call if we're crashing */
+	if (firmware_has_feature(FW_FEATURE_SPLPAR) && !crash_shutdown) {
+		unsigned long vpa = __pa(get_lppaca());
+
+		if (unregister_vpa(hard_smp_processor_id(), vpa)) {
+			printk("VPA deregistration of cpu %u (hw_cpu_id %d) "
+					"failed\n", smp_processor_id(),
+					hard_smp_processor_id());
+		}
+	}
+	xics_teardown_cpu(secondary);
+}
+#endif /* CONFIG_KEXEC */
+
+static void __init pseries_discover_pic(void)
+{
+	struct device_node *np;
+	char *typep;
+
+	for (np = NULL; (np = of_find_node_by_name(np,
+						   "interrupt-controller"));) {
+		typep = (char *)get_property(np, "compatible", NULL);
+		if (strstr(typep, "open-pic")) {
+			pSeries_mpic_node = of_node_get(np);
+			ppc_md.init_IRQ       = pseries_mpic_init_IRQ;
+			ppc_md.get_irq        = mpic_get_irq;
+#ifdef CONFIG_KEXEC
+			ppc_md.kexec_cpu_down = pseries_kexec_cpu_down_mpic;
+#endif
 #ifdef CONFIG_SMP
-	smp_init_pSeries();
+			smp_init_pseries_mpic();
 #endif
+			return;
+		} else if (strstr(typep, "ppc-xicp")) {
+			ppc_md.init_IRQ       = xics_init_IRQ;
+#ifdef CONFIG_KEXEC
+			ppc_md.kexec_cpu_down = pseries_kexec_cpu_down_xics;
+#endif
+#ifdef CONFIG_SMP
+			smp_init_pseries_xics();
+#endif
+			return;
+		}
+	}
+	printk(KERN_ERR "pSeries_discover_pic: failed to recognize"
+	       " interrupt-controller\n");
+}
+
+static void __init pSeries_setup_arch(void)
+{
+	/* Discover PIC type and setup ppc_md accordingly */
+	pseries_discover_pic();
+
 	/* openpic global configuration register (64-bit format). */
 	/* openpic Interrupt Source Unit pointer (64-bit format). */
 	/* python0 facility area (mmio) (64-bit format) REAL address. */
@@ -273,33 +336,6 @@ static int __init pSeries_init_panel(void)
 }
 arch_initcall(pSeries_init_panel);
 
-static  void __init pSeries_discover_pic(void)
-{
-	struct device_node *np;
-	char *typep;
-
-	/*
-	 * Setup interrupt mapping options that are needed for finish_device_tree
-	 * to properly parse the OF interrupt tree & do the virtual irq mapping
-	 */
-	__irq_offset_value = NUM_ISA_INTERRUPTS;
-	ppc64_interrupt_controller = IC_INVALID;
-	for (np = NULL; (np = of_find_node_by_name(np, "interrupt-controller"));) {
-		typep = (char *)get_property(np, "compatible", NULL);
-		if (strstr(typep, "open-pic")) {
-			ppc64_interrupt_controller = IC_OPEN_PIC;
-			break;
-		} else if (strstr(typep, "ppc-xicp")) {
-			ppc64_interrupt_controller = IC_PPC_XIC;
-			break;
-		}
-	}
-	if (ppc64_interrupt_controller == IC_INVALID)
-		printk("pSeries_discover_pic: failed to recognize"
-			" interrupt-controller\n");
-
-}
-
 static void pSeries_mach_cpu_die(void)
 {
 	local_irq_disable();
@@ -342,8 +378,6 @@ static void __init pSeries_init_early(void)
 
 	iommu_init_early_pSeries();
 
-	pSeries_discover_pic();
-
 	DBG(" <- pSeries_init_early()\n");
 }
 
@@ -515,27 +549,6 @@ static int pSeries_pci_probe_mode(struct pci_bus *bus)
 	return PCI_PROBE_NORMAL;
 }
 
-#ifdef CONFIG_KEXEC
-static void pseries_kexec_cpu_down(int crash_shutdown, int secondary)
-{
-	/* Don't risk a hypervisor call if we're crashing */
-	if (firmware_has_feature(FW_FEATURE_SPLPAR) && !crash_shutdown) {
-		unsigned long vpa = __pa(get_lppaca());
-
-		if (unregister_vpa(hard_smp_processor_id(), vpa)) {
-			printk("VPA deregistration of cpu %u (hw_cpu_id %d) "
-					"failed\n", smp_processor_id(),
-					hard_smp_processor_id());
-		}
-	}
-
-	if (ppc64_interrupt_controller == IC_OPEN_PIC)
-		mpic_teardown_this_cpu(secondary);
-	else
-		xics_teardown_cpu(secondary);
-}
-#endif
-
 define_machine(pseries) {
 	.name			= "pSeries",
 	.probe			= pSeries_probe,
@@ -560,7 +573,6 @@ define_machine(pseries) {
 	.system_reset_exception = pSeries_system_reset_exception,
 	.machine_check_exception = pSeries_machine_check_exception,
 #ifdef CONFIG_KEXEC
-	.kexec_cpu_down		= pseries_kexec_cpu_down,
 	.machine_kexec		= default_machine_kexec,
 	.machine_kexec_prepare	= default_machine_kexec_prepare,
 	.machine_crash_shutdown	= default_machine_crash_shutdown,

commit b9e5b4e6a991a5a6d521f2e20a65835404b4169f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jul 3 19:32:51 2006 +1000

    [POWERPC] Use the genirq framework
    
    This adapts the generic powerpc interrupt handling code, and all of
    the platforms except for the embedded 6xx machines, to use the new
    genirq framework.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 999509d28af8..476b564a208b 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -118,6 +118,21 @@ static void __init fwnmi_init(void)
 		fwnmi_active = 1;
 }
 
+void pSeries_8259_cascade(unsigned int irq, struct irq_desc *desc,
+			  struct pt_regs *regs)
+{
+	unsigned int max = 100;
+
+	while(max--) {
+		int cascade_irq = i8259_irq(regs);
+		if (max == 99)
+			desc->chip->eoi(irq);
+		if (cascade_irq < 0)
+			break;
+		generic_handle_irq(cascade_irq, regs);
+	};
+}
+
 static void __init pSeries_init_mpic(void)
 {
         unsigned int *addrp;
@@ -140,7 +155,7 @@ static void __init pSeries_init_mpic(void)
 	i8259_init(intack, 0);
 
 	/* Hook cascade to mpic */
-	mpic_setup_cascade(NUM_ISA_INTERRUPTS, i8259_irq_cascade, NULL);
+	set_irq_chained_handler(NUM_ISA_INTERRUPTS, pSeries_8259_cascade);
 }
 
 static void __init pSeries_setup_mpic(void)
@@ -201,10 +216,8 @@ static void __init pSeries_setup_arch(void)
 		/* Allocate the mpic now, so that find_and_init_phbs() can
 		 * fill the ISUs */
 		pSeries_setup_mpic();
-	} else {
+	} else
 		ppc_md.init_IRQ       = xics_init_IRQ;
-		ppc_md.get_irq        = xics_get_irq;
-	}
 
 #ifdef CONFIG_SMP
 	smp_init_pSeries();
@@ -291,10 +304,7 @@ static void pSeries_mach_cpu_die(void)
 {
 	local_irq_disable();
 	idle_task_exit();
-	/* Some hardware requires clearing the CPPR, while other hardware does not
-	 * it is safe either way
-	 */
-	pSeriesLP_cppr_info(0, 0);
+	xics_teardown_cpu(0);
 	rtas_stop_self();
 	/* Should never get here... */
 	BUG();

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: JÃ¶rn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: JÃ¶rn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b3197ff156c6..999509d28af8 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -18,7 +18,6 @@
 
 #undef DEBUG
 
-#include <linux/config.h>
 #include <linux/cpu.h>
 #include <linux/errno.h>
 #include <linux/sched.h>

commit 7d0daae4ae1a3e80d78b83cddf414a3b98a962f4
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Fri Jun 23 18:16:38 2006 +1000

    [POWERPC] powerpc: Initialise ppc_md htab pointers earlier
    
    Initialise the ppc_md htab callbacks earlier, in the probe routines. This
    allows us to call htab_finish_init() from htab_initialize(), and makes it
    private to hash_utils_64.c. Move htab_finish_init() and make_bl() above
    htab_initialize() to avoid forward declarations.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 1e28518c6121..b3197ff156c6 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -322,11 +322,6 @@ static void __init pSeries_init_early(void)
 	DBG(" -> pSeries_init_early()\n");
 
 	fw_feature_init();
-	
-	if (firmware_has_feature(FW_FEATURE_LPAR))
-		hpte_init_lpar();
-	else
-		hpte_init_native();
 
 	if (firmware_has_feature(FW_FEATURE_LPAR))
 		find_udbg_vterm();
@@ -384,6 +379,11 @@ static int __init pSeries_probe_hypertas(unsigned long node,
 	if (of_get_flat_dt_prop(node, "ibm,hypertas-functions", NULL) != NULL)
  		powerpc_firmware_features |= FW_FEATURE_LPAR;
 
+	if (firmware_has_feature(FW_FEATURE_LPAR))
+		hpte_init_lpar();
+	else
+		hpte_init_native();
+
  	return 1;
 }
 

commit 7a0c58d0513c246ac5438ef4a55ce8b93395ae0e
Merge: 6218a761bbc2 289a1e995e74
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Jun 12 17:53:34 2006 +1000

    Merge branch 'merge'

commit 133dda1e4f757e036fa838cba6804d0344931c4a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jun 7 12:04:18 2006 +1000

    [PATCH] powerpc: Fix cell blade detection
    
    The IBM Cell blade firmware might confuse the kernel to think it's a
    pSeries machine. This fixes it for now. With a bit of luck, the firmware
    will be updated to avoid that in the future but currently that patch is
    needed.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 5f79f01c44f2..3ba87835757e 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -389,6 +389,7 @@ static int __init pSeries_probe_hypertas(unsigned long node,
 
 static int __init pSeries_probe(void)
 {
+	unsigned long root = of_get_flat_dt_root();
  	char *dtype = of_get_flat_dt_prop(of_get_flat_dt_root(),
  					  "device_type", NULL);
  	if (dtype == NULL)
@@ -396,6 +397,13 @@ static int __init pSeries_probe(void)
  	if (strcmp(dtype, "chrp"))
 		return 0;
 
+	/* Cell blades firmware claims to be chrp while it's not. Until this
+	 * is fixed, we need to avoid those here.
+	 */
+	if (of_flat_dt_is_compatible(root, "IBM,CPBW-1.0") ||
+	    of_flat_dt_is_compatible(root, "IBM,CBEA"))
+		return 0;
+
 	DBG("pSeries detected, looking for LPAR capability...\n");
 
 	/* Now try to figure out if we are running on LPAR */

commit 3c06da5ae5358e9d325d541a053e1059e9654bcc
Merge: 4d1f3f25d9c3 a54c9d30dbb0
Author: Paul Mackerras <paulus@samba.org>
Date:   Fri May 19 15:02:42 2006 +1000

    Merge ../linux-2.6

commit 3de620e8394406fd01f450b8c6e3e74464e81a78
Author: Anton Blanchard <anton@samba.org>
Date:   Wed May 10 13:05:54 2006 +1000

    [PATCH] powerpc: fix kernel version display on pseries boxes
    
    We are displaying the wrong thing on the operator panel (2x40
    character LCD).  This got broken in commit cebb21b5, when UTS_RELEASE
    got changed to system_utsname.version.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 5eb55ef1c91c..5f79f01c44f2 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -255,7 +255,7 @@ static int __init pSeries_init_panel(void)
 {
 	/* Manually leave the kernel version on the panel. */
 	ppc_md.progress("Linux ppc64\n", 0);
-	ppc_md.progress(system_utsname.version, 0);
+	ppc_md.progress(system_utsname.release, 0);
 
 	return 0;
 }

commit 4baaf0cfda7279e1adaedc203d7a09e8e44597ab
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Apr 12 15:23:22 2006 -0500

    [PATCH] powerpc: Don't print chosen idle loop at every boot
    
    No need to write out what idle loop is used on every boot.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 5eb55ef1c91c..9118d79b7b46 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -235,14 +235,14 @@ static void __init pSeries_setup_arch(void)
 	if (firmware_has_feature(FW_FEATURE_SPLPAR)) {
 		vpa_init(boot_cpuid);
 		if (get_lppaca()->shared_proc) {
-			printk(KERN_INFO "Using shared processor idle loop\n");
+			printk(KERN_DEBUG "Using shared processor idle loop\n");
 			ppc_md.power_save = pseries_shared_idle_sleep;
 		} else {
-			printk(KERN_INFO "Using dedicated idle loop\n");
+			printk(KERN_DEBUG "Using dedicated idle loop\n");
 			ppc_md.power_save = pseries_dedicated_idle_sleep;
 		}
 	} else {
-		printk(KERN_INFO "Using default idle loop\n");
+		printk(KERN_DEBUG "Using default idle loop\n");
 	}
 
 	if (firmware_has_feature(FW_FEATURE_LPAR))

commit 706c8c93ba4865a19e981b9770151a7a63c15794
Author: Segher Boessenkool <segher@kernel.crashing.org>
Date:   Thu Mar 30 14:49:40 2006 +0200

    [PATCH] powerpc/pseries: Change H_StudlyCaps to H_SHOUTING_CAPS
    
    Also cleans up some nearby whitespace problems.
    
    Signed-off-by: Segher Boessenkool <segher@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b2fbf8ba8fbb..5eb55ef1c91c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -463,7 +463,7 @@ static void pseries_dedicated_idle_sleep(void)
 	 * very low priority.  The cede enables interrupts, which
 	 * doesn't matter here.
 	 */
-	if (!lppaca[cpu ^ 1].idle || poll_pending() == H_Pending)
+	if (!lppaca[cpu ^ 1].idle || poll_pending() == H_PENDING)
 		cede_processor();
 
 out:

commit e8222502ee6157e2713da9e0792c21f4ad458d50
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Mar 28 23:15:54 2006 +1100

    [PATCH] powerpc: Kill _machine and hard-coded platform numbers
    
    This removes statically assigned platform numbers and reworks the
    powerpc platform probe code to use a better mechanism.  With this,
    board support files can simply declare a new machine type with a
    macro, and implement a probe() function that uses the flattened
    device-tree to detect if they apply for a given machine.
    
    We now have a machine_is() macro that replaces the comparisons of
    _machine with the various PLATFORM_* constants.  This commit also
    changes various drivers to use the new macro instead of looking at
    _machine.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 1b0c4c034a26..b2fbf8ba8fbb 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -372,24 +372,42 @@ static int pSeries_check_legacy_ioport(unsigned int baseport)
 /*
  * Called very early, MMU is off, device-tree isn't unflattened
  */
-extern struct machdep_calls pSeries_md;
 
-static int __init pSeries_probe(int platform)
+static int __init pSeries_probe_hypertas(unsigned long node,
+					 const char *uname, int depth,
+					 void *data)
 {
-	if (platform != PLATFORM_PSERIES &&
-	    platform != PLATFORM_PSERIES_LPAR)
+	if (depth != 1 ||
+	    (strcmp(uname, "rtas") != 0 && strcmp(uname, "rtas@0") != 0))
+ 		return 0;
+
+	if (of_get_flat_dt_prop(node, "ibm,hypertas-functions", NULL) != NULL)
+ 		powerpc_firmware_features |= FW_FEATURE_LPAR;
+
+ 	return 1;
+}
+
+static int __init pSeries_probe(void)
+{
+ 	char *dtype = of_get_flat_dt_prop(of_get_flat_dt_root(),
+ 					  "device_type", NULL);
+ 	if (dtype == NULL)
+ 		return 0;
+ 	if (strcmp(dtype, "chrp"))
 		return 0;
 
-	/* if we have some ppc_md fixups for LPAR to do, do
-	 * it here ...
-	 */
+	DBG("pSeries detected, looking for LPAR capability...\n");
 
-	if (platform == PLATFORM_PSERIES_LPAR)
-		powerpc_firmware_features |= FW_FEATURE_LPAR;
+	/* Now try to figure out if we are running on LPAR */
+	of_scan_flat_dt(pSeries_probe_hypertas, NULL);
+
+	DBG("Machine is%s LPAR !\n",
+	    (powerpc_firmware_features & FW_FEATURE_LPAR) ? "" : " not");
 
 	return 1;
 }
 
+
 DECLARE_PER_CPU(unsigned long, smt_snooze_delay);
 
 static void pseries_dedicated_idle_sleep(void)
@@ -501,7 +519,8 @@ static void pseries_kexec_cpu_down(int crash_shutdown, int secondary)
 }
 #endif
 
-struct machdep_calls __initdata pSeries_md = {
+define_machine(pseries) {
+	.name			= "pSeries",
 	.probe			= pSeries_probe,
 	.setup_arch		= pSeries_setup_arch,
 	.init_early		= pSeries_init_early,

commit 4d177fbfdadb011f1bac96f9ccba0cc9f21da8de
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Tue Mar 28 17:14:44 2006 +1100

    [PATCH] powerpc: a couple of trivial compile warning fixes
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index f736234db9b2..1b0c4c034a26 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -455,8 +455,6 @@ static void pseries_dedicated_idle_sleep(void)
 
 static void pseries_shared_idle_sleep(void)
 {
-	unsigned int cpu = smp_processor_id();
-
 	/*
 	 * Indicate to the HV that we are idle. Now would be
 	 * a good time to find other work to dispatch.

commit d0160bf0b3e87032be8e85f80ddd2f18e107b86f
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Mon Mar 27 14:26:25 2006 +1100

    [PATCH] powerpc: Rename and export ppc64_firmware_features
    
    We need to export ppc64_firmware_features for modules. Before we do that
    I think we should probably rename it to powerpc_firmware_features.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 213bf983242f..f736234db9b2 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -385,7 +385,7 @@ static int __init pSeries_probe(int platform)
 	 */
 
 	if (platform == PLATFORM_PSERIES_LPAR)
-		ppc64_firmware_features |= FW_FEATURE_LPAR;
+		powerpc_firmware_features |= FW_FEATURE_LPAR;
 
 	return 1;
 }

commit fbd7740fdfdf9475f92287a84085a1913541cd5d
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Mar 27 15:06:20 2006 +1100

    powerpc: Simplify pSeries idle loop
    
    Since pSeries only wants to do something different in the idle loop when
    there is no work to do, we can simplify the code by implementing
    ppc_md.power_save functions instead of complete idle loops.  There are
    two versions: one for shared-processor partitions and one for dedicated-
    processor partitions.
    
    With this we also do a cede_processor() call on dedicated processor
    partitions if the poll_pending() call indicates that the hypervisor
    has work it wants to do.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 44d5c7fdcd97..213bf983242f 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -81,8 +81,8 @@ extern void find_udbg_vterm(void);
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 
-static void pseries_shared_idle(void);
-static void pseries_dedicated_idle(void);
+static void pseries_shared_idle_sleep(void);
+static void pseries_dedicated_idle_sleep(void);
 
 struct mpic *pSeries_mpic;
 
@@ -236,14 +236,13 @@ static void __init pSeries_setup_arch(void)
 		vpa_init(boot_cpuid);
 		if (get_lppaca()->shared_proc) {
 			printk(KERN_INFO "Using shared processor idle loop\n");
-			ppc_md.idle_loop = pseries_shared_idle;
+			ppc_md.power_save = pseries_shared_idle_sleep;
 		} else {
 			printk(KERN_INFO "Using dedicated idle loop\n");
-			ppc_md.idle_loop = pseries_dedicated_idle;
+			ppc_md.power_save = pseries_dedicated_idle_sleep;
 		}
 	} else {
 		printk(KERN_INFO "Using default idle loop\n");
-		ppc_md.idle_loop = default_idle;
 	}
 
 	if (firmware_has_feature(FW_FEATURE_LPAR))
@@ -393,136 +392,87 @@ static int __init pSeries_probe(int platform)
 
 DECLARE_PER_CPU(unsigned long, smt_snooze_delay);
 
-static inline void dedicated_idle_sleep(unsigned int cpu)
-{
-	struct lppaca *plppaca = &lppaca[cpu ^ 1];
-
-	/* Only sleep if the other thread is not idle */
-	if (!(plppaca->idle)) {
-		local_irq_disable();
-
-		/*
-		 * We are about to sleep the thread and so wont be polling any
-		 * more.
-		 */
-		clear_thread_flag(TIF_POLLING_NRFLAG);
-		smp_mb__after_clear_bit();
-
-		/*
-		 * SMT dynamic mode. Cede will result in this thread going
-		 * dormant, if the partner thread is still doing work.  Thread
-		 * wakes up if partner goes idle, an interrupt is presented, or
-		 * a prod occurs.  Returning from the cede enables external
-		 * interrupts.
-		 */
-		if (!need_resched())
-			cede_processor();
-		else
-			local_irq_enable();
-		set_thread_flag(TIF_POLLING_NRFLAG);
-	} else {
-		/*
-		 * Give the HV an opportunity at the processor, since we are
-		 * not doing any work.
-		 */
-		poll_pending();
-	}
-}
-
-static void pseries_dedicated_idle(void)
+static void pseries_dedicated_idle_sleep(void)
 { 
 	unsigned int cpu = smp_processor_id();
 	unsigned long start_snooze;
 	unsigned long *smt_snooze_delay = &__get_cpu_var(smt_snooze_delay);
-	set_thread_flag(TIF_POLLING_NRFLAG);
-
-	while (1) {
-		/*
-		 * Indicate to the HV that we are idle. Now would be
-		 * a good time to find other work to dispatch.
-		 */
-		get_lppaca()->idle = 1;
-
-		if (!need_resched()) {
-			start_snooze = get_tb() +
-				*smt_snooze_delay * tb_ticks_per_usec;
-
-			while (!need_resched() && !cpu_is_offline(cpu)) {
-				ppc64_runlatch_off();
-
-				/*
-				 * Go into low thread priority and possibly
-				 * low power mode.
-				 */
-				HMT_low();
-				HMT_very_low();
-
-				if (*smt_snooze_delay != 0 &&
-				    get_tb() > start_snooze) {
-					HMT_medium();
-					dedicated_idle_sleep(cpu);
-				}
-
-			}
-
-			HMT_medium();
-		}
 
-		get_lppaca()->idle = 0;
-		ppc64_runlatch_on();
+	/*
+	 * Indicate to the HV that we are idle. Now would be
+	 * a good time to find other work to dispatch.
+	 */
+	get_lppaca()->idle = 1;
 
-		preempt_enable_no_resched();
-		schedule();
-		preempt_disable();
+	/*
+	 * We come in with interrupts disabled, and need_resched()
+	 * has been checked recently.  If we should poll for a little
+	 * while, do so.
+	 */
+	if (*smt_snooze_delay) {
+		start_snooze = get_tb() +
+			*smt_snooze_delay * tb_ticks_per_usec;
+		local_irq_enable();
+		set_thread_flag(TIF_POLLING_NRFLAG);
 
-		if (cpu_is_offline(cpu) && system_state == SYSTEM_RUNNING)
-			cpu_die();
+		while (get_tb() < start_snooze) {
+			if (need_resched() || cpu_is_offline(cpu))
+				goto out;
+			ppc64_runlatch_off();
+			HMT_low();
+			HMT_very_low();
+		}
+
+		HMT_medium();
+		clear_thread_flag(TIF_POLLING_NRFLAG);
+		smp_mb();
+		local_irq_disable();
+		if (need_resched() || cpu_is_offline(cpu))
+			goto out;
 	}
+
+	/*
+	 * Cede if the other thread is not idle, so that it can
+	 * go single-threaded.  If the other thread is idle,
+	 * we ask the hypervisor if it has pending work it
+	 * wants to do and cede if it does.  Otherwise we keep
+	 * polling in order to reduce interrupt latency.
+	 *
+	 * Doing the cede when the other thread is active will
+	 * result in this thread going dormant, meaning the other
+	 * thread gets to run in single-threaded (ST) mode, which
+	 * is slightly faster than SMT mode with this thread at
+	 * very low priority.  The cede enables interrupts, which
+	 * doesn't matter here.
+	 */
+	if (!lppaca[cpu ^ 1].idle || poll_pending() == H_Pending)
+		cede_processor();
+
+out:
+	HMT_medium();
+	get_lppaca()->idle = 0;
 }
 
-static void pseries_shared_idle(void)
+static void pseries_shared_idle_sleep(void)
 {
 	unsigned int cpu = smp_processor_id();
 
-	while (1) {
-		/*
-		 * Indicate to the HV that we are idle. Now would be
-		 * a good time to find other work to dispatch.
-		 */
-		get_lppaca()->idle = 1;
-
-		while (!need_resched() && !cpu_is_offline(cpu)) {
-			local_irq_disable();
-			ppc64_runlatch_off();
-
-			/*
-			 * Yield the processor to the hypervisor.  We return if
-			 * an external interrupt occurs (which are driven prior
-			 * to returning here) or if a prod occurs from another
-			 * processor. When returning here, external interrupts
-			 * are enabled.
-			 *
-			 * Check need_resched() again with interrupts disabled
-			 * to avoid a race.
-			 */
-			if (!need_resched())
-				cede_processor();
-			else
-				local_irq_enable();
-
-			HMT_medium();
-		}
-
-		get_lppaca()->idle = 0;
-		ppc64_runlatch_on();
+	/*
+	 * Indicate to the HV that we are idle. Now would be
+	 * a good time to find other work to dispatch.
+	 */
+	get_lppaca()->idle = 1;
 
-		preempt_enable_no_resched();
-		schedule();
-		preempt_disable();
+	/*
+	 * Yield the processor to the hypervisor.  We return if
+	 * an external interrupt occurs (which are driven prior
+	 * to returning here) or if a prod occurs from another
+	 * processor. When returning here, external interrupts
+	 * are enabled.
+	 */
+	cede_processor();
 
-		if (cpu_is_offline(cpu) && system_state == SYSTEM_RUNNING)
-			cpu_die();
-	}
+	get_lppaca()->idle = 0;
 }
 
 static int pSeries_pci_probe_mode(struct pci_bus *bus)

commit 57cfb814f698d30894bc28e22125550193ebe549
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue Mar 21 20:45:59 2006 +1100

    [PATCH] powerpc: Replace platform_is_lpar() with a firmware feature
    
    It has been decreed that platform numbers are evil, so as a step in that
    direction, replace platform_is_lpar() with a FW_FEATURE_LPAR bit.
    
    Currently FW_FEATURE_LPAR really means i/pSeries LPAR, in the future we might
    have to clean that up if we need to be more specific about what LPAR actually
    means. But that's another patch ...
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 149751a3742a..44d5c7fdcd97 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -246,7 +246,7 @@ static void __init pSeries_setup_arch(void)
 		ppc_md.idle_loop = default_idle;
 	}
 
-	if (platform_is_lpar())
+	if (firmware_has_feature(FW_FEATURE_LPAR))
 		ppc_md.enable_pmcs = pseries_lpar_enable_pmcs;
 	else
 		ppc_md.enable_pmcs = power4_enable_pmcs;
@@ -324,12 +324,12 @@ static void __init pSeries_init_early(void)
 
 	fw_feature_init();
 	
-	if (platform_is_lpar())
+	if (firmware_has_feature(FW_FEATURE_LPAR))
 		hpte_init_lpar();
 	else
 		hpte_init_native();
 
-	if (platform_is_lpar())
+	if (firmware_has_feature(FW_FEATURE_LPAR))
 		find_udbg_vterm();
 
 	if (firmware_has_feature(FW_FEATURE_DABR))
@@ -385,6 +385,9 @@ static int __init pSeries_probe(int platform)
 	 * it here ...
 	 */
 
+	if (platform == PLATFORM_PSERIES_LPAR)
+		ppc64_firmware_features |= FW_FEATURE_LPAR;
+
 	return 1;
 }
 
@@ -524,7 +527,7 @@ static void pseries_shared_idle(void)
 
 static int pSeries_pci_probe_mode(struct pci_bus *bus)
 {
-	if (platform_is_lpar())
+	if (firmware_has_feature(FW_FEATURE_LPAR))
 		return PCI_PROBE_DEVTREE;
 	return PCI_PROBE_NORMAL;
 }

commit 415202447d31d0f458cca256ad7e0ed777d993d9
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue Mar 21 20:45:58 2006 +1100

    [PATCH] powerpc: Remove unused iommu_off logic from pSeries_init_early()
    
    When iommu_init_early_pSeries() was added, ages ago, we forgot to remove
    the code that checks /chosen/linux,iommu-off in pSeries_init_early(). We
    do it now in iommu_init_early_pSeries().
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b5996a7060f4..149751a3742a 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -320,19 +320,14 @@ static int pseries_set_xdabr(unsigned long dabr)
  */
 static void __init pSeries_init_early(void)
 {
-	int iommu_off = 0;
-
 	DBG(" -> pSeries_init_early()\n");
 
 	fw_feature_init();
 	
 	if (platform_is_lpar())
 		hpte_init_lpar();
-	else {
+	else
 		hpte_init_native();
-		iommu_off = (of_chosen &&
-			     get_property(of_chosen, "linux,iommu-off", NULL));
-	}
 
 	if (platform_is_lpar())
 		find_udbg_vterm();

commit 1965746bce49ddf001af52c7985e16343c768021
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Fri Feb 10 15:47:36 2006 +1100

    [PATCH] powerpc: Move pSeries firmware feature setup into platforms/pseries
    
    Currently we have some stuff in firmware.h and kernel/firmware.c that is
    #ifdef CONFIG_PPC_PSERIES. Move it all into platforms/pseries.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 984241bb776c..b5996a7060f4 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -60,7 +60,6 @@
 #include <asm/time.h>
 #include <asm/nvram.h>
 #include "xics.h"
-#include <asm/firmware.h>
 #include <asm/pmc.h>
 #include <asm/mpic.h>
 #include <asm/ppc-pci.h>
@@ -70,6 +69,7 @@
 
 #include "plpar_wrappers.h"
 #include "ras.h"
+#include "firmware.h"
 
 #ifdef DEBUG
 #define DBG(fmt...) udbg_printf(fmt)
@@ -262,49 +262,6 @@ static int __init pSeries_init_panel(void)
 }
 arch_initcall(pSeries_init_panel);
 
-
-/* Build up the firmware features bitmask using the contents of
- * device-tree/ibm,hypertas-functions.  Ultimately this functionality may
- * be moved into prom.c prom_init().
- */
-static void __init fw_feature_init(void)
-{
-	struct device_node *dn;
-	char *hypertas, *s;
-	int len, i;
-
-	DBG(" -> fw_feature_init()\n");
-
-	dn = of_find_node_by_path("/rtas");
-	if (dn == NULL) {
-		printk(KERN_ERR "WARNING! Cannot find RTAS in device-tree!\n");
-		goto out;
-	}
-
-	hypertas = get_property(dn, "ibm,hypertas-functions", &len);
-	if (hypertas == NULL)
-		goto out;
-
-	for (s = hypertas; s < hypertas + len; s += strlen(s) + 1) {
-		for (i = 0; i < FIRMWARE_MAX_FEATURES; i++) {
-			/* check value against table of strings */
-			if (!firmware_features_table[i].name ||
-			    strcmp(firmware_features_table[i].name, s))
-				continue;
-
-			/* we have a match */
-			ppc64_firmware_features |=
-				firmware_features_table[i].val;
-			break;
-		}
-	}
-
-out:
-	of_node_put(dn);
-	DBG(" <- fw_feature_init()\n");
-}
-
-
 static  void __init pSeries_discover_pic(void)
 {
 	struct device_node *np;

commit 0941d57aa7034ef7010bd523752c2e3bee569ef1
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Fri Feb 10 15:47:32 2006 +1100

    [PATCH] powerpc: Clean up pSeries firmware feature initialisation
    
    Clean up fw_feature_init in platforms/pseries/setup.c. Clean up white space
    and replace the while loop with a for loop - which seems clearer to me.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 9edeca83f434..984241bb776c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -263,48 +263,44 @@ static int __init pSeries_init_panel(void)
 arch_initcall(pSeries_init_panel);
 
 
-/* Build up the ppc64_firmware_features bitmask field
- * using contents of device-tree/ibm,hypertas-functions.
- * Ultimately this functionality may be moved into prom.c prom_init().
+/* Build up the firmware features bitmask using the contents of
+ * device-tree/ibm,hypertas-functions.  Ultimately this functionality may
+ * be moved into prom.c prom_init().
  */
 static void __init fw_feature_init(void)
 {
-	struct device_node * dn;
-	char * hypertas;
-	unsigned int len;
+	struct device_node *dn;
+	char *hypertas, *s;
+	int len, i;
 
 	DBG(" -> fw_feature_init()\n");
 
-	ppc64_firmware_features = 0;
 	dn = of_find_node_by_path("/rtas");
 	if (dn == NULL) {
-		printk(KERN_ERR "WARNING ! Cannot find RTAS in device-tree !\n");
-		goto no_rtas;
+		printk(KERN_ERR "WARNING! Cannot find RTAS in device-tree!\n");
+		goto out;
 	}
 
 	hypertas = get_property(dn, "ibm,hypertas-functions", &len);
-	if (hypertas) {
-		while (len > 0){
-			int i, hypertas_len;
+	if (hypertas == NULL)
+		goto out;
+
+	for (s = hypertas; s < hypertas + len; s += strlen(s) + 1) {
+		for (i = 0; i < FIRMWARE_MAX_FEATURES; i++) {
 			/* check value against table of strings */
-			for(i=0; i < FIRMWARE_MAX_FEATURES ;i++) {
-				if ((firmware_features_table[i].name) &&
-				    (strcmp(firmware_features_table[i].name,hypertas))==0) {
-					/* we have a match */
-					ppc64_firmware_features |= 
-						(firmware_features_table[i].val);
-					break;
-				} 
-			}
-			hypertas_len = strlen(hypertas);
-			len -= hypertas_len +1;
-			hypertas+= hypertas_len +1;
+			if (!firmware_features_table[i].name ||
+			    strcmp(firmware_features_table[i].name, s))
+				continue;
+
+			/* we have a match */
+			ppc64_firmware_features |=
+				firmware_features_table[i].val;
+			break;
 		}
 	}
 
+out:
 	of_node_put(dn);
-no_rtas:
-
 	DBG(" <- fw_feature_init()\n");
 }
 

commit 4dc43256931db60d02d76bacf3cf03b5d79aa33a
Author: Michael Neuling <mikey@neuling.org>
Date:   Tue Feb 7 10:58:21 2006 +1100

    [PATCH] powerpc: hypervisor check in pseries_kexec_cpu_down
    
    We call unregister_vpa but we don't check to see if the hypervisor
    supports this.
    
    Signed-off-by: Michael Neuling <mikey@neuling.org>
    Acked-by: Anton Blanchard <anton@samba.org>
    --
     arch/powerpc/platforms/pseries/setup.c |    2 +-
     1 files changed, 1 insertion(+), 1 deletion(-)
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index da6cebaf72cd..9edeca83f434 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -585,7 +585,7 @@ static int pSeries_pci_probe_mode(struct pci_bus *bus)
 static void pseries_kexec_cpu_down(int crash_shutdown, int secondary)
 {
 	/* Don't risk a hypervisor call if we're crashing */
-	if (!crash_shutdown) {
+	if (firmware_has_feature(FW_FEATURE_SPLPAR) && !crash_shutdown) {
 		unsigned long vpa = __pa(get_lppaca());
 
 		if (unregister_vpa(hard_smp_processor_id(), vpa)) {

commit 3356bb9f7ba378a6e2709f9df95f4ea52111f4df
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Fri Jan 13 10:26:42 2006 +1100

    [PATCH] powerpc: Remove lppaca structure from the PACA
    
    At present the lppaca - the structure shared with the iSeries
    hypervisor and phyp - is contained within the PACA, our own low-level
    per-cpu structure.  This doesn't have to be so, the patch below
    removes it, making a separate array of lppaca structures.
    
    This saves approximately 500*NR_CPUS bytes of image size and kernel
    memory, because we don't need aligning gap between the Linux and
    hypervisor portions of every PACA.  On the other hand it means an
    extra level of dereference in many accesses to the lppaca.
    
    The patch also gets rid of several places where we assign the paca
    address to a local variable for no particular reason.
    
    Signed-off-by: David Gibson <dwg@au1.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 68b7f086d63d..da6cebaf72cd 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -190,7 +190,7 @@ static void pseries_lpar_enable_pmcs(void)
 
 	/* instruct hypervisor to maintain PMCs */
 	if (firmware_has_feature(FW_FEATURE_SPLPAR))
-		get_paca()->lppaca.pmcregs_in_use = 1;
+		get_lppaca()->pmcregs_in_use = 1;
 }
 
 static void __init pSeries_setup_arch(void)
@@ -234,7 +234,7 @@ static void __init pSeries_setup_arch(void)
 	/* Choose an idle loop */
 	if (firmware_has_feature(FW_FEATURE_SPLPAR)) {
 		vpa_init(boot_cpuid);
-		if (get_paca()->lppaca.shared_proc) {
+		if (get_lppaca()->shared_proc) {
 			printk(KERN_INFO "Using shared processor idle loop\n");
 			ppc_md.idle_loop = pseries_shared_idle;
 		} else {
@@ -444,10 +444,10 @@ DECLARE_PER_CPU(unsigned long, smt_snooze_delay);
 
 static inline void dedicated_idle_sleep(unsigned int cpu)
 {
-	struct paca_struct *ppaca = &paca[cpu ^ 1];
+	struct lppaca *plppaca = &lppaca[cpu ^ 1];
 
 	/* Only sleep if the other thread is not idle */
-	if (!(ppaca->lppaca.idle)) {
+	if (!(plppaca->idle)) {
 		local_irq_disable();
 
 		/*
@@ -480,7 +480,6 @@ static inline void dedicated_idle_sleep(unsigned int cpu)
 
 static void pseries_dedicated_idle(void)
 { 
-	struct paca_struct *lpaca = get_paca();
 	unsigned int cpu = smp_processor_id();
 	unsigned long start_snooze;
 	unsigned long *smt_snooze_delay = &__get_cpu_var(smt_snooze_delay);
@@ -491,7 +490,7 @@ static void pseries_dedicated_idle(void)
 		 * Indicate to the HV that we are idle. Now would be
 		 * a good time to find other work to dispatch.
 		 */
-		lpaca->lppaca.idle = 1;
+		get_lppaca()->idle = 1;
 
 		if (!need_resched()) {
 			start_snooze = get_tb() +
@@ -518,7 +517,7 @@ static void pseries_dedicated_idle(void)
 			HMT_medium();
 		}
 
-		lpaca->lppaca.idle = 0;
+		get_lppaca()->idle = 0;
 		ppc64_runlatch_on();
 
 		preempt_enable_no_resched();
@@ -532,7 +531,6 @@ static void pseries_dedicated_idle(void)
 
 static void pseries_shared_idle(void)
 {
-	struct paca_struct *lpaca = get_paca();
 	unsigned int cpu = smp_processor_id();
 
 	while (1) {
@@ -540,7 +538,7 @@ static void pseries_shared_idle(void)
 		 * Indicate to the HV that we are idle. Now would be
 		 * a good time to find other work to dispatch.
 		 */
-		lpaca->lppaca.idle = 1;
+		get_lppaca()->idle = 1;
 
 		while (!need_resched() && !cpu_is_offline(cpu)) {
 			local_irq_disable();
@@ -564,7 +562,7 @@ static void pseries_shared_idle(void)
 			HMT_medium();
 		}
 
-		lpaca->lppaca.idle = 0;
+		get_lppaca()->idle = 0;
 		ppc64_runlatch_on();
 
 		preempt_enable_no_resched();
@@ -588,7 +586,7 @@ static void pseries_kexec_cpu_down(int crash_shutdown, int secondary)
 {
 	/* Don't risk a hypervisor call if we're crashing */
 	if (!crash_shutdown) {
-		unsigned long vpa = __pa(&get_paca()->lppaca);
+		unsigned long vpa = __pa(get_lppaca());
 
 		if (unregister_vpa(hard_smp_processor_id(), vpa)) {
 			printk("VPA deregistration of cpu %u (hw_cpu_id %d) "

commit 8446196ade39befe68f60cfae49c43b94a1144fc
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 11 00:00:02 2006 +0000

    [PATCH] powerpc: pseries namespace cleanup
    
    These symbols are only used in the file that they are defined in,
    so they should not be in the global namespace.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 8903cf63236a..68b7f086d63d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -86,7 +86,7 @@ static void pseries_dedicated_idle(void);
 
 struct mpic *pSeries_mpic;
 
-void pSeries_show_cpuinfo(struct seq_file *m)
+static void pSeries_show_cpuinfo(struct seq_file *m)
 {
 	struct device_node *root;
 	const char *model = "";

commit c902be71dc6d5e8473bd021feafc8c3608e2b82a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 4 19:55:53 2006 +0000

    [PATCH] cell: enable pause(0) in cpu_idle
    
    This patch enables support for pause(0) power management state
    for the Cell Broadband Processor, which is import for power efficient
    operation. The pervasive infrastructure will in the future enable
    us to introduce more functionality specific to the Cell's
    pervasive unit.
    
    From: Maximino Aguilar <maguilar@us.ibm.com>
    Signed-off-by: Arnd Bergmann <arndb@de.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 38b631ceaec9..8903cf63236a 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -69,6 +69,7 @@
 #include <asm/smp.h>
 
 #include "plpar_wrappers.h"
+#include "ras.h"
 
 #ifdef DEBUG
 #define DBG(fmt...) udbg_printf(fmt)
@@ -80,9 +81,6 @@ extern void find_udbg_vterm(void);
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 
-extern void pSeries_system_reset_exception(struct pt_regs *regs);
-extern int pSeries_machine_check_exception(struct pt_regs *regs);
-
 static void pseries_shared_idle(void);
 static void pseries_dedicated_idle(void);
 

commit 9da5cad61c13fbdc7fc7aa425f03a15da9d0cb43
Author: Haren Myneni <haren@us.ibm.com>
Date:   Tue Dec 27 15:51:07 2005 -0800

    [PATCH] powerpc: Fix search for the main interrupt controller
    
    At present, we are not looking at all interrupt controller nodes in the
    device tree even though the proper node was not found. This is causing
    the system panic. The attached patch will scan all nodes until it finds
    the proper interrupt controller type.
    
    Signed-off-by: Haren Myneni <haren@us.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 2cb082871210..38b631ceaec9 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -324,15 +324,18 @@ static  void __init pSeries_discover_pic(void)
 	ppc64_interrupt_controller = IC_INVALID;
 	for (np = NULL; (np = of_find_node_by_name(np, "interrupt-controller"));) {
 		typep = (char *)get_property(np, "compatible", NULL);
-		if (strstr(typep, "open-pic"))
+		if (strstr(typep, "open-pic")) {
 			ppc64_interrupt_controller = IC_OPEN_PIC;
-		else if (strstr(typep, "ppc-xicp"))
+			break;
+		} else if (strstr(typep, "ppc-xicp")) {
 			ppc64_interrupt_controller = IC_PPC_XIC;
-		else
-			printk("pSeries_discover_pic: failed to recognize"
-			       " interrupt-controller\n");
-		break;
+			break;
+		}
 	}
+	if (ppc64_interrupt_controller == IC_INVALID)
+		printk("pSeries_discover_pic: failed to recognize"
+			" interrupt-controller\n");
+
 }
 
 static void pSeries_mach_cpu_die(void)

commit cc53291521701f9c7c7265bbb3c140563174d8b2
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Sun Dec 4 18:39:43 2005 +1100

    [PATCH] powerpc: Add arch dependent basic infrastructure for Kdump.
    
    Implementing the machine_crash_shutdown which will be called by
    crash_kexec (called in case of a panic, sysrq etc.). Disable the
    interrupts, shootdown cpus using debugger IPI and collect regs
    for all CPUs.
    
    elfcorehdr= specifies the location of elf core header stored by
    the crashed kernel. This command line option will be passed by
    the kexec-tools to capture kernel.
    
    savemaxmem= specifies the actual memory size that the first kernel
    has and this value will be used for dumping in the capture kernel.
    This command line option will be passed by the kexec-tools to
    capture kernel.
    
    Signed-off-by: Haren Myneni <haren@us.ibm.com>
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index d678f228fc0f..2cb082871210 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -629,5 +629,6 @@ struct machdep_calls __initdata pSeries_md = {
 	.kexec_cpu_down		= pseries_kexec_cpu_down,
 	.machine_kexec		= default_machine_kexec,
 	.machine_kexec_prepare	= default_machine_kexec_prepare,
+	.machine_crash_shutdown	= default_machine_crash_shutdown,
 #endif
 };

commit 8c4f1f2958ff9d4a6760f3bdd0cfb7d2b9e12093
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Sun Dec 4 18:39:33 2005 +1100

    [PATCH] powerpc: Create a trampoline for the fwnmi vectors
    
    The fwnmi vectors can be anywhere < 32 MB, so we need to use a trampoline
    for them. The kdump kernel will register the trampoline addresses, which will
    then jump up to the real code above 32 MB.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 8828dc378c3e..d678f228fc0f 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -77,8 +77,6 @@
 #endif
 
 extern void find_udbg_vterm(void);
-extern void system_reset_fwnmi(void);	/* from head.S */
-extern void machine_check_fwnmi(void);	/* from head.S */
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 
@@ -104,18 +102,22 @@ void pSeries_show_cpuinfo(struct seq_file *m)
 
 /* Initialize firmware assisted non-maskable interrupts if
  * the firmware supports this feature.
- *
  */
 static void __init fwnmi_init(void)
 {
-	int ret;
+	unsigned long system_reset_addr, machine_check_addr;
+
 	int ibm_nmi_register = rtas_token("ibm,nmi-register");
 	if (ibm_nmi_register == RTAS_UNKNOWN_SERVICE)
 		return;
-	ret = rtas_call(ibm_nmi_register, 2, 1, NULL,
-			__pa((unsigned long)system_reset_fwnmi),
-			__pa((unsigned long)machine_check_fwnmi));
-	if (ret == 0)
+
+	/* If the kernel's not linked at zero we point the firmware at low
+	 * addresses anyway, and use a trampoline to get to the real code. */
+	system_reset_addr  = __pa(system_reset_fwnmi) - PHYSICAL_START;
+	machine_check_addr = __pa(machine_check_fwnmi) - PHYSICAL_START;
+
+	if (0 == rtas_call(ibm_nmi_register, 2, 1, NULL, system_reset_addr,
+				machine_check_addr))
 		fwnmi_active = 1;
 }
 

commit 463ce0e103f419f51b1769111e73fe8bb305d0ec
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Nov 23 17:56:06 2005 +1100

    [PATCH] powerpc: serial port discovery (#2)
    
    This moves the discovery of legacy serial ports to a separate file,
    makes it common to ppc32 and ppc64, and reworks it to use the new OF
    address translators to get to the ports early. This new version can also
    detect some PCI serial cards using legacy chips and will probably match
    those discovered port with the default console choice.
    
    Only ppc64 gets udbg still yet, unifying udbg isn't finished yet.
    
    It also adds some speed-probing code to udbg so that the default console
    can come up at the same speed it was set to by the firmware.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 8a4238a3757f..8828dc378c3e 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -79,8 +79,6 @@
 extern void find_udbg_vterm(void);
 extern void system_reset_fwnmi(void);	/* from head.S */
 extern void machine_check_fwnmi(void);	/* from head.S */
-extern void generic_find_legacy_serial_ports(u64 *physport,
-		unsigned int *default_speed);
 
 int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 
@@ -366,10 +364,7 @@ static int pseries_set_xdabr(unsigned long dabr)
  */
 static void __init pSeries_init_early(void)
 {
-	void *comport;
 	int iommu_off = 0;
-	unsigned int default_speed;
-	u64 physport;
 
 	DBG(" -> pSeries_init_early()\n");
 
@@ -383,17 +378,8 @@ static void __init pSeries_init_early(void)
 			     get_property(of_chosen, "linux,iommu-off", NULL));
 	}
 
-	generic_find_legacy_serial_ports(&physport, &default_speed);
-
 	if (platform_is_lpar())
 		find_udbg_vterm();
-	else if (physport) {
-		/* Map the uart for udbg. */
-		comport = (void *)ioremap(physport, 16);
-		udbg_init_uart(comport, default_speed);
-
-		DBG("Hello World !\n");
-	}
 
 	if (firmware_has_feature(FW_FEATURE_DABR))
 		ppc_md.set_dabr = pseries_set_dabr;

commit 3d1229d6ae92ed1994f4411b8493327ef8f4b76f
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Mon Nov 14 23:35:00 2005 +1100

    [PATCH] powerpc: Merge kexec
    
    This patch merges, to some extent, the PPC32 and PPC64 kexec implementations.
    
    We adopt the PPC32 approach of having ppc_md callbacks for the kexec functions.
    The current PPC64 implementation becomes the "default" implementation for PPC64
    which platforms can select if they need no special treatment.
    
    I've added these default callbacks to pseries/maple/cell/powermac, this means
    iSeries no longer supports kexec - but it never worked anyway.
    
    I've renamed PPC32's machine_kexec_simple to default_machine_kexec, inline with
    PPC64. Judging by the comments it might be better named machine_kexec_non_of,
    or something, but at the moment it's the only implementation for PPC32 so it's
    the "default".
    
    Kexec requires machine_shutdown(), which is in machine_kexec.c on PPC32, but we
    already have in setup-common.c on powerpc. All this does is call
    ppc_md.nvram_sync, which only powermac implements, so instead make
    machine_shutdown a ppc_md member and have it call core99_nvram_sync directly
    on powermac.
    
    I've also stuck relocate_kernel.S into misc_32.S for powerpc.
    
    Built for ARCH=ppc, and 32 & 64 bit ARCH=powerpc, with KEXEC=y/n. Booted on
    P5 LPAR and successfully kexec'ed.
    
    Should apply on top of 493f25ef4087395891c99fcfe2c72e62e293e89f.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 4a465f067ede..8a4238a3757f 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -56,6 +56,7 @@
 #include <asm/dma.h>
 #include <asm/machdep.h>
 #include <asm/irq.h>
+#include <asm/kexec.h>
 #include <asm/time.h>
 #include <asm/nvram.h>
 #include "xics.h"
@@ -638,5 +639,7 @@ struct machdep_calls __initdata pSeries_md = {
 	.machine_check_exception = pSeries_machine_check_exception,
 #ifdef CONFIG_KEXEC
 	.kexec_cpu_down		= pseries_kexec_cpu_down,
+	.machine_kexec		= default_machine_kexec,
+	.machine_kexec_prepare	= default_machine_kexec_prepare,
 #endif
 };

commit 6146eed1e972a7de93ce2e36adc5812de81e879c
Author: Paul Mackerras <paulus@samba.org>
Date:   Fri Nov 18 15:47:18 2005 +1100

    powerpc: Fix compile error on pSeries arising from delay.h changes
    
    pseries_dedicated_idle() was using __get_tb which used to be defined
    in asm/delay.h.  Change it to use get_tb from asm/time.h, which is
    in fact exactly the same thing.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index b9d9732b2e06..4a465f067ede 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -504,7 +504,7 @@ static void pseries_dedicated_idle(void)
 		lpaca->lppaca.idle = 1;
 
 		if (!need_resched()) {
-			start_snooze = __get_tb() +
+			start_snooze = get_tb() +
 				*smt_snooze_delay * tb_ticks_per_usec;
 
 			while (!need_resched() && !cpu_is_offline(cpu)) {
@@ -518,7 +518,7 @@ static void pseries_dedicated_idle(void)
 				HMT_very_low();
 
 				if (*smt_snooze_delay != 0 &&
-				    __get_tb() > start_snooze) {
+				    get_tb() > start_snooze) {
 					HMT_medium();
 					dedicated_idle_sleep(cpu);
 				}

commit c5e24354efae9f962e0e369d875d45f47e0bb9aa
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Sat Nov 12 00:06:05 2005 +1100

    [PATCH] powerpc: Turn cpu_irq_down into kexec_cpu_down
    
    We currently have a ppc_md member called cpu_irq_down, which disables IRQs
    for the cpu in question. The only caller of cpu_irq_down is the kexec code.
    
    On pSeries we need to do more than just teardown IRQs at kexec time, so rename
    the ppc_md member to kexec_cpu_down and expand it. The pSeries code needs to
    know, and other platforms might too, whether we're doing a crash shutdown (ie.
    panicking) or a regular kexec, so add a flag for that.
    
    The pSeries implementation of kexec_cpu_down does an unregister VPA call, which
    tells the Hypervisor to stop writing stuff into our pacas. Without this we can
    get weird memory corruption bugs when we kexec, caused by the Hypervisor
    writing into the first kernel's pacas which happens to be somewhere interesting
    in the second kernel's memory.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 31990829310c..b9d9732b2e06 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -200,14 +200,12 @@ static void __init pSeries_setup_arch(void)
 	if (ppc64_interrupt_controller == IC_OPEN_PIC) {
 		ppc_md.init_IRQ       = pSeries_init_mpic;
 		ppc_md.get_irq        = mpic_get_irq;
-	 	ppc_md.cpu_irq_down   = mpic_teardown_this_cpu;
 		/* Allocate the mpic now, so that find_and_init_phbs() can
 		 * fill the ISUs */
 		pSeries_setup_mpic();
 	} else {
 		ppc_md.init_IRQ       = xics_init_IRQ;
 		ppc_md.get_irq        = xics_get_irq;
-		ppc_md.cpu_irq_down   = xics_teardown_cpu;
 	}
 
 #ifdef CONFIG_SMP
@@ -595,6 +593,27 @@ static int pSeries_pci_probe_mode(struct pci_bus *bus)
 	return PCI_PROBE_NORMAL;
 }
 
+#ifdef CONFIG_KEXEC
+static void pseries_kexec_cpu_down(int crash_shutdown, int secondary)
+{
+	/* Don't risk a hypervisor call if we're crashing */
+	if (!crash_shutdown) {
+		unsigned long vpa = __pa(&get_paca()->lppaca);
+
+		if (unregister_vpa(hard_smp_processor_id(), vpa)) {
+			printk("VPA deregistration of cpu %u (hw_cpu_id %d) "
+					"failed\n", smp_processor_id(),
+					hard_smp_processor_id());
+		}
+	}
+
+	if (ppc64_interrupt_controller == IC_OPEN_PIC)
+		mpic_teardown_this_cpu(secondary);
+	else
+		xics_teardown_cpu(secondary);
+}
+#endif
+
 struct machdep_calls __initdata pSeries_md = {
 	.probe			= pSeries_probe,
 	.setup_arch		= pSeries_setup_arch,
@@ -617,4 +636,7 @@ struct machdep_calls __initdata pSeries_md = {
 	.check_legacy_ioport	= pSeries_check_legacy_ioport,
 	.system_reset_exception = pSeries_system_reset_exception,
 	.machine_check_exception = pSeries_machine_check_exception,
+#ifdef CONFIG_KEXEC
+	.kexec_cpu_down		= pseries_kexec_cpu_down,
+#endif
 };

commit 50bcfec19fcdf3aa936547bad5dee02062917d04
Author: Anton Blanchard <anton@samba.org>
Date:   Fri Nov 11 13:56:16 2005 +1100

    [PATCH] ppc64: Remove debug boot message
    
    We have been printing the raw ppc64_firmware_features during boot. Since
    we can work it out from the device tree, lets remove it.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e94247c28d42..31990829310c 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -306,9 +306,7 @@ static void __init fw_feature_init(void)
 	}
 
 	of_node_put(dn);
- no_rtas:
-	printk(KERN_INFO "firmware_features = 0x%lx\n", 
-	       ppc64_firmware_features);
+no_rtas:
 
 	DBG(" <- fw_feature_init()\n");
 }

commit 799d6046d3fb557006e6d7c9767fdb96479b0e0a
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Nov 10 13:37:51 2005 +1100

    [PATCH] powerpc: merge code values for identifying platforms
    
    This patch merges platform codes.  systemcfg->platform is no longer used,
    systemcfg use in general is deprecated as much as possible (and renamed
    _systemcfg before it gets completely moved elsewhere in a future patch),
    _machine is now used on ppc64 along as ppc32.  Platform codes aren't gone
    yet but we are getting a step closer. A bunch of asm code in head[_64].S
    is also turned into C code.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index a093a0d4dd69..e94247c28d42 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -249,7 +249,7 @@ static void __init pSeries_setup_arch(void)
 		ppc_md.idle_loop = default_idle;
 	}
 
-	if (systemcfg->platform & PLATFORM_LPAR)
+	if (platform_is_lpar())
 		ppc_md.enable_pmcs = pseries_lpar_enable_pmcs;
 	else
 		ppc_md.enable_pmcs = power4_enable_pmcs;
@@ -378,7 +378,7 @@ static void __init pSeries_init_early(void)
 
 	fw_feature_init();
 	
-	if (systemcfg->platform & PLATFORM_LPAR)
+	if (platform_is_lpar())
 		hpte_init_lpar();
 	else {
 		hpte_init_native();
@@ -388,7 +388,7 @@ static void __init pSeries_init_early(void)
 
 	generic_find_legacy_serial_ports(&physport, &default_speed);
 
-	if (systemcfg->platform & PLATFORM_LPAR)
+	if (platform_is_lpar())
 		find_udbg_vterm();
 	else if (physport) {
 		/* Map the uart for udbg. */
@@ -592,7 +592,7 @@ static void pseries_shared_idle(void)
 
 static int pSeries_pci_probe_mode(struct pci_bus *bus)
 {
-	if (systemcfg->platform & PLATFORM_LPAR)
+	if (platform_is_lpar())
 		return PCI_PROBE_DEVTREE;
 	return PCI_PROBE_NORMAL;
 }

commit 64c7c8f88559624abdbe12b5da6502e8879f8d28
Author: Nick Piggin <nickpiggin@yahoo.com.au>
Date:   Tue Nov 8 21:39:04 2005 -0800

    [PATCH] sched: resched and cpu_idle rework
    
    Make some changes to the NEED_RESCHED and POLLING_NRFLAG to reduce
    confusion, and make their semantics rigid.  Improves efficiency of
    resched_task and some cpu_idle routines.
    
    * In resched_task:
    - TIF_NEED_RESCHED is only cleared with the task's runqueue lock held,
      and as we hold it during resched_task, then there is no need for an
      atomic test and set there. The only other time this should be set is
      when the task's quantum expires, in the timer interrupt - this is
      protected against because the rq lock is irq-safe.
    
    - If TIF_NEED_RESCHED is set, then we don't need to do anything. It
      won't get unset until the task get's schedule()d off.
    
    - If we are running on the same CPU as the task we resched, then set
      TIF_NEED_RESCHED and no further action is required.
    
    - If we are running on another CPU, and TIF_POLLING_NRFLAG is *not* set
      after TIF_NEED_RESCHED has been set, then we need to send an IPI.
    
    Using these rules, we are able to remove the test and set operation in
    resched_task, and make clear the previously vague semantics of
    POLLING_NRFLAG.
    
    * In idle routines:
    - Enter cpu_idle with preempt disabled. When the need_resched() condition
      becomes true, explicitly call schedule(). This makes things a bit clearer
      (IMO), but haven't updated all architectures yet.
    
    - Many do a test and clear of TIF_NEED_RESCHED for some reason. According
      to the resched_task rules, this isn't needed (and actually breaks the
      assumption that TIF_NEED_RESCHED is only cleared with the runqueue lock
      held). So remove that. Generally one less locked memory op when switching
      to the idle thread.
    
    - Many idle routines clear TIF_POLLING_NRFLAG, and only set it in the inner
      most polling idle loops. The above resched_task semantics allow it to be
      set until before the last time need_resched() is checked before going into
      a halt requiring interrupt wakeup.
    
      Many idle routines simply never enter such a halt, and so POLLING_NRFLAG
      can be always left set, completely eliminating resched IPIs when rescheduling
      the idle task.
    
      POLLING_NRFLAG width can be increased, to reduce the chance of resched IPIs.
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Con Kolivas <kernel@kolivas.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 4854f5eb5c3d..a093a0d4dd69 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -469,6 +469,7 @@ static inline void dedicated_idle_sleep(unsigned int cpu)
 		 * more.
 		 */
 		clear_thread_flag(TIF_POLLING_NRFLAG);
+		smp_mb__after_clear_bit();
 
 		/*
 		 * SMT dynamic mode. Cede will result in this thread going
@@ -481,6 +482,7 @@ static inline void dedicated_idle_sleep(unsigned int cpu)
 			cede_processor();
 		else
 			local_irq_enable();
+		set_thread_flag(TIF_POLLING_NRFLAG);
 	} else {
 		/*
 		 * Give the HV an opportunity at the processor, since we are
@@ -492,11 +494,11 @@ static inline void dedicated_idle_sleep(unsigned int cpu)
 
 static void pseries_dedicated_idle(void)
 { 
-	long oldval;
 	struct paca_struct *lpaca = get_paca();
 	unsigned int cpu = smp_processor_id();
 	unsigned long start_snooze;
 	unsigned long *smt_snooze_delay = &__get_cpu_var(smt_snooze_delay);
+	set_thread_flag(TIF_POLLING_NRFLAG);
 
 	while (1) {
 		/*
@@ -505,10 +507,7 @@ static void pseries_dedicated_idle(void)
 		 */
 		lpaca->lppaca.idle = 1;
 
-		oldval = test_and_clear_thread_flag(TIF_NEED_RESCHED);
-		if (!oldval) {
-			set_thread_flag(TIF_POLLING_NRFLAG);
-
+		if (!need_resched()) {
 			start_snooze = __get_tb() +
 				*smt_snooze_delay * tb_ticks_per_usec;
 
@@ -531,9 +530,6 @@ static void pseries_dedicated_idle(void)
 			}
 
 			HMT_medium();
-			clear_thread_flag(TIF_POLLING_NRFLAG);
-		} else {
-			set_need_resched();
 		}
 
 		lpaca->lppaca.idle = 0;

commit 5bfb5d690f36d316a5f3b4f7775fda996faa6b12
Author: Nick Piggin <nickpiggin@yahoo.com.au>
Date:   Tue Nov 8 21:39:01 2005 -0800

    [PATCH] sched: disable preempt in idle tasks
    
    Run idle threads with preempt disabled.
    
    Also corrected a bugs in arm26's cpu_idle (make it actually call schedule()).
    How did it ever work before?
    
    Might fix the CPU hotplugging hang which Nigel Cunningham noted.
    
    We think the bug hits if the idle thread is preempted after checking
    need_resched() and before going to sleep, then the CPU offlined.
    
    After calling stop_machine_run, the CPU eventually returns from preemption and
    into the idle thread and goes to sleep.  The CPU will continue executing
    previous idle and have no chance to call play_dead.
    
    By disabling preemption until we are ready to explicitly schedule, this bug is
    fixed and the idle threads generally become more robust.
    
    From: alexs <ashepard@u.washington.edu>
    
      PPC build fix
    
    From: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
    
      MIPS build fix
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index e78c39368841..4854f5eb5c3d 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -539,7 +539,9 @@ static void pseries_dedicated_idle(void)
 		lpaca->lppaca.idle = 0;
 		ppc64_runlatch_on();
 
+		preempt_enable_no_resched();
 		schedule();
+		preempt_disable();
 
 		if (cpu_is_offline(cpu) && system_state == SYSTEM_RUNNING)
 			cpu_die();
@@ -583,7 +585,9 @@ static void pseries_shared_idle(void)
 		lpaca->lppaca.idle = 0;
 		ppc64_runlatch_on();
 
+		preempt_enable_no_resched();
 		schedule();
+		preempt_disable();
 
 		if (cpu_is_offline(cpu) && system_state == SYSTEM_RUNNING)
 			cpu_die();

commit 76032de898f34db55b5048349db56557828a1390
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Mon Nov 7 13:12:03 2005 +1100

    [PATCH] powerpc: Make ppc_md.set_dabr non 64-bit specific
    
    Define ppc_md.set_dabr for both 32 + 64 bit. Cleanup the implementation for
    pSeries also, it was needlessly complex. Now we just do two firmware tests at
    setup time, and use one of two functions, rather than using one function and
    testing on every call.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 934d7006353f..e78c39368841 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -354,14 +354,15 @@ static void pSeries_mach_cpu_die(void)
 
 static int pseries_set_dabr(unsigned long dabr)
 {
-	if (firmware_has_feature(FW_FEATURE_XDABR)) {
-		/* We want to catch accesses from kernel and userspace */
-		return plpar_set_xdabr(dabr, H_DABRX_KERNEL | H_DABRX_USER);
-	}
-
-	return plpar_set_dabr(dabr);
+	return plpar_hcall_norets(H_SET_DABR, dabr);
 }
 
+static int pseries_set_xdabr(unsigned long dabr)
+{
+	/* We want to catch accesses from kernel and userspace */
+	return plpar_hcall_norets(H_SET_XDABR, dabr,
+			H_DABRX_KERNEL | H_DABRX_USER);
+}
 
 /*
  * Early initialization.  Relocation is on but do not reference unbolted pages
@@ -397,8 +398,10 @@ static void __init pSeries_init_early(void)
 		DBG("Hello World !\n");
 	}
 
-	if (firmware_has_feature(FW_FEATURE_XDABR | FW_FEATURE_DABR))
+	if (firmware_has_feature(FW_FEATURE_DABR))
 		ppc_md.set_dabr = pseries_set_dabr;
+	else if (firmware_has_feature(FW_FEATURE_XDABR))
+		ppc_md.set_dabr = pseries_set_xdabr;
 
 	iommu_init_early_pSeries();
 

commit 2249ca9d60d3a8a1f6f223f0f0a0283fcb7ce33e
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Nov 7 13:18:13 2005 +1100

    powerpc: Various UP build fixes
    
    Mostly this involves adding #include <asm/smp.h>, since that defines
    things like boot_cpuid[_phys] and [gs]et_hard_smp_processor_id, which
    are SMP-related but still needed on UP.  This incorporates fixes
    posted by Olof Johansson and Heikki Lindholm.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 65bee939eecc..934d7006353f 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -65,6 +65,7 @@
 #include <asm/ppc-pci.h>
 #include <asm/i8259.h>
 #include <asm/udbg.h>
+#include <asm/smp.h>
 
 #include "plpar_wrappers.h"
 

commit dc3a9efb5ee89493a42c3365d219e339e4720c2b
Merge: 30415f6a63f3 d3ab57ebdc64
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Fri Nov 4 12:12:52 2005 +1100

    Merge with Paulus

commit a1218720321d778134914cf90ef54cf0d1d8477c
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Nov 3 15:33:31 2005 +1100

    powerpc: Move plpar_wrappers.h into arch/powerpc/platforms/pseries
    
    Move plpar_wrappers.h into arch/powerpc/platforms/pseries, fixup white space,
    and update callers.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index ee468f07f378..d54e1e4c7c63 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -58,7 +58,6 @@
 #include <asm/irq.h>
 #include <asm/time.h>
 #include <asm/nvram.h>
-#include <asm/plpar_wrappers.h>
 #include "xics.h"
 #include <asm/firmware.h>
 #include <asm/pmc.h>
@@ -67,6 +66,8 @@
 #include <asm/i8259.h>
 #include <asm/udbg.h>
 
+#include "plpar_wrappers.h"
+
 #ifdef DEBUG
 #define DBG(fmt...) udbg_printf(fmt)
 #else

commit cab0af98dfbbf8076d1af01f2927af491a76a33f
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Nov 3 15:30:49 2005 +1100

    powerpc: Make set_dabr() a ppc_md function
    
    Move pSeries specific code in set_dabr() into a ppc_md function, this will
    allow us to keep plpar_wrappers.h private to platforms/pseries.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index c0a3d918148a..ee468f07f378 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -350,6 +350,16 @@ static void pSeries_mach_cpu_die(void)
 	for(;;);
 }
 
+static int pseries_set_dabr(unsigned long dabr)
+{
+	if (firmware_has_feature(FW_FEATURE_XDABR)) {
+		/* We want to catch accesses from kernel and userspace */
+		return plpar_set_xdabr(dabr, H_DABRX_KERNEL | H_DABRX_USER);
+	}
+
+	return plpar_set_dabr(dabr);
+}
+
 
 /*
  * Early initialization.  Relocation is on but do not reference unbolted pages
@@ -385,6 +395,8 @@ static void __init pSeries_init_early(void)
 		DBG("Hello World !\n");
 	}
 
+	if (firmware_has_feature(FW_FEATURE_XDABR | FW_FEATURE_DABR))
+		ppc_md.set_dabr = pseries_set_dabr;
 
 	iommu_init_early_pSeries();
 

commit f4fcbbe9a7fdf11305fea657202b954bdc2228ec
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Nov 3 14:41:19 2005 +1100

    powerpc: Merge remaining RTAS code
    
    This moves rtas-proc.c and rtas_flash.c into arch/powerpc/kernel, since
    cell wants them as well as pseries (and chrp can use rtas-proc.c too,
    at least in principle).  rtas_fw.c is gone, with its bits moved into
    rtas_flash.c and rtas.c.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index c0a3d918148a..f73d69143d35 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -589,9 +589,9 @@ struct machdep_calls __initdata pSeries_md = {
 	.pcibios_fixup		= pSeries_final_fixup,
 	.pci_probe_mode		= pSeries_pci_probe_mode,
 	.irq_bus_setup		= pSeries_irq_bus_setup,
-	.restart		= rtas_fw_restart,
-	.power_off		= rtas_fw_power_off,
-	.halt			= rtas_fw_halt,
+	.restart		= rtas_restart,
+	.power_off		= rtas_power_off,
+	.halt			= rtas_halt,
 	.panic			= rtas_os_term,
 	.cpu_die		= pSeries_mach_cpu_die,
 	.get_boot_time		= rtas_get_boot_time,

commit a39dbcf71eba6e00ac6ae5482f499f9b57f1075e
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Nov 1 22:37:47 2005 +1100

    powerpc: Fix pseries (64-bit) build
    
    A recent commit that removed rtas-fw.h and moved its contents to
    include/asm-powerpc/rtas.h forgot to also remove the inclusion of
    it in arch/powerpc/platforms/pseries/setup.c.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 10cb0f2d9b5b..c0a3d918148a 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -67,8 +67,6 @@
 #include <asm/i8259.h>
 #include <asm/udbg.h>
 
-#include "rtas-fw.h"
-
 #ifdef DEBUG
 #define DBG(fmt...) udbg_printf(fmt)
 #else

commit 007e8f51b26ae7b6a17651af5a0f01ab6491cdca
Author: David Gibson <david@gibson.dropbear.id.au>
Date:   Fri Oct 28 15:35:50 2005 +1000

    [PATCH] powerpc: Move xics.[ch] into platforms/pseries
    
    This patch moves the XICS interrupt controller code into the
    platforms/pseries directory, since it only appears on pSeries
    machines.  If it ever appears on some other machine we can move it to
    sysdev, although xics.c itself will need a bunch of changes in that
    case to remove pSeries specific assumptions.
    
    Signed-off-by: David Gibson <dwg@au1.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 7e7e556e6b48..10cb0f2d9b5b 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -59,7 +59,7 @@
 #include <asm/time.h>
 #include <asm/nvram.h>
 #include <asm/plpar_wrappers.h>
-#include <asm/xics.h>
+#include "xics.h"
 #include <asm/firmware.h>
 #include <asm/pmc.h>
 #include <asm/mpic.h>

commit 033ef338b6e007dc081c6282a4f2a9dd761f8cd2
Author: Paul Mackerras <paulus@samba.org>
Date:   Wed Oct 26 17:05:24 2005 +1000

    powerpc: Merge rtas.c into arch/powerpc/kernel
    
    This splits arch/ppc64/kernel/rtas.c into arch/powerpc/kernel/rtas.c,
    which contains generic RTAS functions useful on any CHRP platform,
    and arch/powerpc/platforms/pseries/rtas-fw.[ch], which contain
    some pSeries-specific firmware flashing bits.  The parts of rtas.c
    that are to do with pSeries-specific error logging are protected
    by a new CONFIG_RTAS_ERROR_LOGGING symbol.  The inclusion of rtas.o
    is controlled by the CONFIG_PPC_RTAS symbol, and the relevant
    platforms select that.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 0fa5beae6d1b..7e7e556e6b48 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -1,5 +1,5 @@
 /*
- *  linux/arch/ppc/kernel/setup.c
+ *  64-bit pSeries and RS/6000 setup code.
  *
  *  Copyright (C) 1995  Linus Torvalds
  *  Adapted from 'alpha' version by Gary Thomas
@@ -67,6 +67,8 @@
 #include <asm/i8259.h>
 #include <asm/udbg.h>
 
+#include "rtas-fw.h"
+
 #ifdef DEBUG
 #define DBG(fmt...) udbg_printf(fmt)
 #else
@@ -589,9 +591,9 @@ struct machdep_calls __initdata pSeries_md = {
 	.pcibios_fixup		= pSeries_final_fixup,
 	.pci_probe_mode		= pSeries_pci_probe_mode,
 	.irq_bus_setup		= pSeries_irq_bus_setup,
-	.restart		= rtas_restart,
-	.power_off		= rtas_power_off,
-	.halt			= rtas_halt,
+	.restart		= rtas_fw_restart,
+	.power_off		= rtas_fw_power_off,
+	.halt			= rtas_fw_halt,
 	.panic			= rtas_os_term,
 	.cpu_die		= pSeries_mach_cpu_die,
 	.get_boot_time		= rtas_get_boot_time,

commit f9bd170a87948a9e077149b70fb192c563770fdf
Author: Paul Mackerras <paulus@samba.org>
Date:   Wed Oct 26 16:47:42 2005 +1000

    powerpc: Merge i8259.c into arch/powerpc/sysdev
    
    This changes the parameters for i8259_init so that it takes two
    parameters: a physical address for generating an interrupt
    acknowledge cycle, and an interrupt number offset.  i8259_init
    now sets the irq_desc[] for its interrupts; all the callers
    were doing this, and that code is gone now.  This also defines
    a CONFIG_PPC_I8259 symbol to select i8259.o for inclusion, and
    makes the platforms that need it select that symbol.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 92d18003f152..0fa5beae6d1b 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -87,7 +87,6 @@ extern int pSeries_machine_check_exception(struct pt_regs *regs);
 static void pseries_shared_idle(void);
 static void pseries_dedicated_idle(void);
 
-static volatile void __iomem * chrp_int_ack_special;
 struct mpic *pSeries_mpic;
 
 void pSeries_show_cpuinfo(struct seq_file *m)
@@ -119,19 +118,11 @@ static void __init fwnmi_init(void)
 		fwnmi_active = 1;
 }
 
-static int pSeries_irq_cascade(struct pt_regs *regs, void *data)
-{
-	if (chrp_int_ack_special)
-		return readb(chrp_int_ack_special);
-	else
-		return i8259_irq(regs);
-}
-
 static void __init pSeries_init_mpic(void)
 {
         unsigned int *addrp;
 	struct device_node *np;
-        int i;
+	unsigned long intack = 0;
 
 	/* All ISUs are setup, complete initialization */
 	mpic_init(pSeries_mpic);
@@ -142,16 +133,14 @@ static void __init pSeries_init_mpic(void)
                  get_property(np, "8259-interrupt-acknowledge", NULL)))
                 printk(KERN_ERR "Cannot find pci to get ack address\n");
         else
-		chrp_int_ack_special = ioremap(addrp[prom_n_addr_cells(np)-1], 1);
+		intack = addrp[prom_n_addr_cells(np)-1];
 	of_node_put(np);
 
 	/* Setup the legacy interrupts & controller */
-        for (i = 0; i < NUM_ISA_INTERRUPTS; i++)
-                irq_desc[i].handler = &i8259_pic;
-	i8259_init(0);
+	i8259_init(intack, 0);
 
 	/* Hook cascade to mpic */
-	mpic_setup_cascade(NUM_ISA_INTERRUPTS, pSeries_irq_cascade, NULL);
+	mpic_setup_cascade(NUM_ISA_INTERRUPTS, i8259_irq_cascade, NULL);
 }
 
 static void __init pSeries_setup_mpic(void)

commit 0458060c1c59c5378d8fb5daabe18cf4681c35cd
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Oct 20 21:00:20 2005 +1000

    ppc64: Move init_boot_text call and conswitchp init into setup_arch
    
    This way they get done in one place for all platforms, and it is
    more consistent with what ppc32 does.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index c53dbbb4490a..92d18003f152 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -241,10 +241,6 @@ static void __init pSeries_setup_arch(void)
 	find_and_init_phbs();
 	eeh_init();
 
-#ifdef CONFIG_DUMMY_CONSOLE
-	conswitchp = &dummy_con;
-#endif
-
 	pSeries_nvram_init();
 
 	/* Choose an idle loop */

commit 0dd194d02d2584c34e06ddd26c7a7896a5fa1974
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Oct 20 20:48:19 2005 +1000

    powerpc: Fix places where ppc_md.show_[per]cpuinfo was treated as int
    
    I missed a few places where ppc code was still assuming that the
    ppc_md.show_[per]cpuinfo functions returned int.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index 0c84a44b43b4..c53dbbb4490a 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -90,7 +90,7 @@ static void pseries_dedicated_idle(void);
 static volatile void __iomem * chrp_int_ack_special;
 struct mpic *pSeries_mpic;
 
-void pSeries_get_cpuinfo(struct seq_file *m)
+void pSeries_show_cpuinfo(struct seq_file *m)
 {
 	struct device_node *root;
 	const char *model = "";
@@ -599,7 +599,7 @@ struct machdep_calls __initdata pSeries_md = {
 	.probe			= pSeries_probe,
 	.setup_arch		= pSeries_setup_arch,
 	.init_early		= pSeries_init_early,
-	.get_cpuinfo		= pSeries_get_cpuinfo,
+	.show_cpuinfo		= pSeries_show_cpuinfo,
 	.log_error		= pSeries_log_error,
 	.pcibios_fixup		= pSeries_final_fixup,
 	.pci_probe_mode		= pSeries_pci_probe_mode,

commit 143a1dec7e04e0a9712ff93e779aabfb21dfd97c
Author: Paul Mackerras <paulus@samba.org>
Date:   Wed Oct 19 23:11:21 2005 +1000

    powerpc: Merge machdep.h
    
    A few things change for consistency between ppc32 and ppc64:
    idle functions return void; *_get_boot_time functions return
    unsigned long (i.e. time_t) rather than filling in a struct rtc_time
    (since that's useful to the callers and easier for pmac to
    generate); *_get_rtc_time and *_set_rtc_time functions take
    a struct rtc_time; irq_canonicalize is gone; nvram_sync returns
    void.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
index eb25ee2eead8..0c84a44b43b4 100644
--- a/arch/powerpc/platforms/pseries/setup.c
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -84,8 +84,8 @@ int fwnmi_active;  /* TRUE if an FWNMI handler is present */
 extern void pSeries_system_reset_exception(struct pt_regs *regs);
 extern int pSeries_machine_check_exception(struct pt_regs *regs);
 
-static int pseries_shared_idle(void);
-static int pseries_dedicated_idle(void);
+static void pseries_shared_idle(void);
+static void pseries_dedicated_idle(void);
 
 static volatile void __iomem * chrp_int_ack_special;
 struct mpic *pSeries_mpic;
@@ -488,8 +488,8 @@ static inline void dedicated_idle_sleep(unsigned int cpu)
 	}
 }
 
-static int pseries_dedicated_idle(void)
-{
+static void pseries_dedicated_idle(void)
+{ 
 	long oldval;
 	struct paca_struct *lpaca = get_paca();
 	unsigned int cpu = smp_processor_id();
@@ -544,7 +544,7 @@ static int pseries_dedicated_idle(void)
 	}
 }
 
-static int pseries_shared_idle(void)
+static void pseries_shared_idle(void)
 {
 	struct paca_struct *lpaca = get_paca();
 	unsigned int cpu = smp_processor_id();
@@ -586,8 +586,6 @@ static int pseries_shared_idle(void)
 		if (cpu_is_offline(cpu) && system_state == SYSTEM_RUNNING)
 			cpu_die();
 	}
-
-	return 0;
 }
 
 static int pSeries_pci_probe_mode(struct pci_bus *bus)

commit 69a80d3f69d0b2d7fae5a73c6e034d402d434d8a
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Oct 10 22:03:41 2005 +1000

    powerpc: move pSeries files to arch/powerpc/platforms/pseries
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pseries/setup.c b/arch/powerpc/platforms/pseries/setup.c
new file mode 100644
index 000000000000..eb25ee2eead8
--- /dev/null
+++ b/arch/powerpc/platforms/pseries/setup.c
@@ -0,0 +1,622 @@
+/*
+ *  linux/arch/ppc/kernel/setup.c
+ *
+ *  Copyright (C) 1995  Linus Torvalds
+ *  Adapted from 'alpha' version by Gary Thomas
+ *  Modified by Cort Dougan (cort@cs.nmt.edu)
+ *  Modified by PPC64 Team, IBM Corp
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+/*
+ * bootup setup stuff..
+ */
+
+#undef DEBUG
+
+#include <linux/config.h>
+#include <linux/cpu.h>
+#include <linux/errno.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/stddef.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/user.h>
+#include <linux/a.out.h>
+#include <linux/tty.h>
+#include <linux/major.h>
+#include <linux/interrupt.h>
+#include <linux/reboot.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/console.h>
+#include <linux/pci.h>
+#include <linux/utsname.h>
+#include <linux/adb.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/irq.h>
+#include <linux/seq_file.h>
+#include <linux/root_dev.h>
+
+#include <asm/mmu.h>
+#include <asm/processor.h>
+#include <asm/io.h>
+#include <asm/pgtable.h>
+#include <asm/prom.h>
+#include <asm/rtas.h>
+#include <asm/pci-bridge.h>
+#include <asm/iommu.h>
+#include <asm/dma.h>
+#include <asm/machdep.h>
+#include <asm/irq.h>
+#include <asm/time.h>
+#include <asm/nvram.h>
+#include <asm/plpar_wrappers.h>
+#include <asm/xics.h>
+#include <asm/firmware.h>
+#include <asm/pmc.h>
+#include <asm/mpic.h>
+#include <asm/ppc-pci.h>
+#include <asm/i8259.h>
+#include <asm/udbg.h>
+
+#ifdef DEBUG
+#define DBG(fmt...) udbg_printf(fmt)
+#else
+#define DBG(fmt...)
+#endif
+
+extern void find_udbg_vterm(void);
+extern void system_reset_fwnmi(void);	/* from head.S */
+extern void machine_check_fwnmi(void);	/* from head.S */
+extern void generic_find_legacy_serial_ports(u64 *physport,
+		unsigned int *default_speed);
+
+int fwnmi_active;  /* TRUE if an FWNMI handler is present */
+
+extern void pSeries_system_reset_exception(struct pt_regs *regs);
+extern int pSeries_machine_check_exception(struct pt_regs *regs);
+
+static int pseries_shared_idle(void);
+static int pseries_dedicated_idle(void);
+
+static volatile void __iomem * chrp_int_ack_special;
+struct mpic *pSeries_mpic;
+
+void pSeries_get_cpuinfo(struct seq_file *m)
+{
+	struct device_node *root;
+	const char *model = "";
+
+	root = of_find_node_by_path("/");
+	if (root)
+		model = get_property(root, "model", NULL);
+	seq_printf(m, "machine\t\t: CHRP %s\n", model);
+	of_node_put(root);
+}
+
+/* Initialize firmware assisted non-maskable interrupts if
+ * the firmware supports this feature.
+ *
+ */
+static void __init fwnmi_init(void)
+{
+	int ret;
+	int ibm_nmi_register = rtas_token("ibm,nmi-register");
+	if (ibm_nmi_register == RTAS_UNKNOWN_SERVICE)
+		return;
+	ret = rtas_call(ibm_nmi_register, 2, 1, NULL,
+			__pa((unsigned long)system_reset_fwnmi),
+			__pa((unsigned long)machine_check_fwnmi));
+	if (ret == 0)
+		fwnmi_active = 1;
+}
+
+static int pSeries_irq_cascade(struct pt_regs *regs, void *data)
+{
+	if (chrp_int_ack_special)
+		return readb(chrp_int_ack_special);
+	else
+		return i8259_irq(regs);
+}
+
+static void __init pSeries_init_mpic(void)
+{
+        unsigned int *addrp;
+	struct device_node *np;
+        int i;
+
+	/* All ISUs are setup, complete initialization */
+	mpic_init(pSeries_mpic);
+
+	/* Check what kind of cascade ACK we have */
+        if (!(np = of_find_node_by_name(NULL, "pci"))
+            || !(addrp = (unsigned int *)
+                 get_property(np, "8259-interrupt-acknowledge", NULL)))
+                printk(KERN_ERR "Cannot find pci to get ack address\n");
+        else
+		chrp_int_ack_special = ioremap(addrp[prom_n_addr_cells(np)-1], 1);
+	of_node_put(np);
+
+	/* Setup the legacy interrupts & controller */
+        for (i = 0; i < NUM_ISA_INTERRUPTS; i++)
+                irq_desc[i].handler = &i8259_pic;
+	i8259_init(0);
+
+	/* Hook cascade to mpic */
+	mpic_setup_cascade(NUM_ISA_INTERRUPTS, pSeries_irq_cascade, NULL);
+}
+
+static void __init pSeries_setup_mpic(void)
+{
+	unsigned int *opprop;
+	unsigned long openpic_addr = 0;
+        unsigned char senses[NR_IRQS - NUM_ISA_INTERRUPTS];
+        struct device_node *root;
+	int irq_count;
+
+	/* Find the Open PIC if present */
+	root = of_find_node_by_path("/");
+	opprop = (unsigned int *) get_property(root, "platform-open-pic", NULL);
+	if (opprop != 0) {
+		int n = prom_n_addr_cells(root);
+
+		for (openpic_addr = 0; n > 0; --n)
+			openpic_addr = (openpic_addr << 32) + *opprop++;
+		printk(KERN_DEBUG "OpenPIC addr: %lx\n", openpic_addr);
+	}
+	of_node_put(root);
+
+	BUG_ON(openpic_addr == 0);
+
+	/* Get the sense values from OF */
+	prom_get_irq_senses(senses, NUM_ISA_INTERRUPTS, NR_IRQS);
+	
+	/* Setup the openpic driver */
+	irq_count = NR_IRQS - NUM_ISA_INTERRUPTS - 4; /* leave room for IPIs */
+	pSeries_mpic = mpic_alloc(openpic_addr, MPIC_PRIMARY,
+				  16, 16, irq_count, /* isu size, irq offset, irq count */ 
+				  NR_IRQS - 4, /* ipi offset */
+				  senses, irq_count, /* sense & sense size */
+				  " MPIC     ");
+}
+
+static void pseries_lpar_enable_pmcs(void)
+{
+	unsigned long set, reset;
+
+	power4_enable_pmcs();
+
+	set = 1UL << 63;
+	reset = 0;
+	plpar_hcall_norets(H_PERFMON, set, reset);
+
+	/* instruct hypervisor to maintain PMCs */
+	if (firmware_has_feature(FW_FEATURE_SPLPAR))
+		get_paca()->lppaca.pmcregs_in_use = 1;
+}
+
+static void __init pSeries_setup_arch(void)
+{
+	/* Fixup ppc_md depending on the type of interrupt controller */
+	if (ppc64_interrupt_controller == IC_OPEN_PIC) {
+		ppc_md.init_IRQ       = pSeries_init_mpic;
+		ppc_md.get_irq        = mpic_get_irq;
+	 	ppc_md.cpu_irq_down   = mpic_teardown_this_cpu;
+		/* Allocate the mpic now, so that find_and_init_phbs() can
+		 * fill the ISUs */
+		pSeries_setup_mpic();
+	} else {
+		ppc_md.init_IRQ       = xics_init_IRQ;
+		ppc_md.get_irq        = xics_get_irq;
+		ppc_md.cpu_irq_down   = xics_teardown_cpu;
+	}
+
+#ifdef CONFIG_SMP
+	smp_init_pSeries();
+#endif
+	/* openpic global configuration register (64-bit format). */
+	/* openpic Interrupt Source Unit pointer (64-bit format). */
+	/* python0 facility area (mmio) (64-bit format) REAL address. */
+
+	/* init to some ~sane value until calibrate_delay() runs */
+	loops_per_jiffy = 50000000;
+
+	if (ROOT_DEV == 0) {
+		printk("No ramdisk, default root is /dev/sda2\n");
+		ROOT_DEV = Root_SDA2;
+	}
+
+	fwnmi_init();
+
+	/* Find and initialize PCI host bridges */
+	init_pci_config_tokens();
+	find_and_init_phbs();
+	eeh_init();
+
+#ifdef CONFIG_DUMMY_CONSOLE
+	conswitchp = &dummy_con;
+#endif
+
+	pSeries_nvram_init();
+
+	/* Choose an idle loop */
+	if (firmware_has_feature(FW_FEATURE_SPLPAR)) {
+		vpa_init(boot_cpuid);
+		if (get_paca()->lppaca.shared_proc) {
+			printk(KERN_INFO "Using shared processor idle loop\n");
+			ppc_md.idle_loop = pseries_shared_idle;
+		} else {
+			printk(KERN_INFO "Using dedicated idle loop\n");
+			ppc_md.idle_loop = pseries_dedicated_idle;
+		}
+	} else {
+		printk(KERN_INFO "Using default idle loop\n");
+		ppc_md.idle_loop = default_idle;
+	}
+
+	if (systemcfg->platform & PLATFORM_LPAR)
+		ppc_md.enable_pmcs = pseries_lpar_enable_pmcs;
+	else
+		ppc_md.enable_pmcs = power4_enable_pmcs;
+}
+
+static int __init pSeries_init_panel(void)
+{
+	/* Manually leave the kernel version on the panel. */
+	ppc_md.progress("Linux ppc64\n", 0);
+	ppc_md.progress(system_utsname.version, 0);
+
+	return 0;
+}
+arch_initcall(pSeries_init_panel);
+
+
+/* Build up the ppc64_firmware_features bitmask field
+ * using contents of device-tree/ibm,hypertas-functions.
+ * Ultimately this functionality may be moved into prom.c prom_init().
+ */
+static void __init fw_feature_init(void)
+{
+	struct device_node * dn;
+	char * hypertas;
+	unsigned int len;
+
+	DBG(" -> fw_feature_init()\n");
+
+	ppc64_firmware_features = 0;
+	dn = of_find_node_by_path("/rtas");
+	if (dn == NULL) {
+		printk(KERN_ERR "WARNING ! Cannot find RTAS in device-tree !\n");
+		goto no_rtas;
+	}
+
+	hypertas = get_property(dn, "ibm,hypertas-functions", &len);
+	if (hypertas) {
+		while (len > 0){
+			int i, hypertas_len;
+			/* check value against table of strings */
+			for(i=0; i < FIRMWARE_MAX_FEATURES ;i++) {
+				if ((firmware_features_table[i].name) &&
+				    (strcmp(firmware_features_table[i].name,hypertas))==0) {
+					/* we have a match */
+					ppc64_firmware_features |= 
+						(firmware_features_table[i].val);
+					break;
+				} 
+			}
+			hypertas_len = strlen(hypertas);
+			len -= hypertas_len +1;
+			hypertas+= hypertas_len +1;
+		}
+	}
+
+	of_node_put(dn);
+ no_rtas:
+	printk(KERN_INFO "firmware_features = 0x%lx\n", 
+	       ppc64_firmware_features);
+
+	DBG(" <- fw_feature_init()\n");
+}
+
+
+static  void __init pSeries_discover_pic(void)
+{
+	struct device_node *np;
+	char *typep;
+
+	/*
+	 * Setup interrupt mapping options that are needed for finish_device_tree
+	 * to properly parse the OF interrupt tree & do the virtual irq mapping
+	 */
+	__irq_offset_value = NUM_ISA_INTERRUPTS;
+	ppc64_interrupt_controller = IC_INVALID;
+	for (np = NULL; (np = of_find_node_by_name(np, "interrupt-controller"));) {
+		typep = (char *)get_property(np, "compatible", NULL);
+		if (strstr(typep, "open-pic"))
+			ppc64_interrupt_controller = IC_OPEN_PIC;
+		else if (strstr(typep, "ppc-xicp"))
+			ppc64_interrupt_controller = IC_PPC_XIC;
+		else
+			printk("pSeries_discover_pic: failed to recognize"
+			       " interrupt-controller\n");
+		break;
+	}
+}
+
+static void pSeries_mach_cpu_die(void)
+{
+	local_irq_disable();
+	idle_task_exit();
+	/* Some hardware requires clearing the CPPR, while other hardware does not
+	 * it is safe either way
+	 */
+	pSeriesLP_cppr_info(0, 0);
+	rtas_stop_self();
+	/* Should never get here... */
+	BUG();
+	for(;;);
+}
+
+
+/*
+ * Early initialization.  Relocation is on but do not reference unbolted pages
+ */
+static void __init pSeries_init_early(void)
+{
+	void *comport;
+	int iommu_off = 0;
+	unsigned int default_speed;
+	u64 physport;
+
+	DBG(" -> pSeries_init_early()\n");
+
+	fw_feature_init();
+	
+	if (systemcfg->platform & PLATFORM_LPAR)
+		hpte_init_lpar();
+	else {
+		hpte_init_native();
+		iommu_off = (of_chosen &&
+			     get_property(of_chosen, "linux,iommu-off", NULL));
+	}
+
+	generic_find_legacy_serial_ports(&physport, &default_speed);
+
+	if (systemcfg->platform & PLATFORM_LPAR)
+		find_udbg_vterm();
+	else if (physport) {
+		/* Map the uart for udbg. */
+		comport = (void *)ioremap(physport, 16);
+		udbg_init_uart(comport, default_speed);
+
+		DBG("Hello World !\n");
+	}
+
+
+	iommu_init_early_pSeries();
+
+	pSeries_discover_pic();
+
+	DBG(" <- pSeries_init_early()\n");
+}
+
+
+static int pSeries_check_legacy_ioport(unsigned int baseport)
+{
+	struct device_node *np;
+
+#define I8042_DATA_REG	0x60
+#define FDC_BASE	0x3f0
+
+
+	switch(baseport) {
+	case I8042_DATA_REG:
+		np = of_find_node_by_type(NULL, "8042");
+		if (np == NULL)
+			return -ENODEV;
+		of_node_put(np);
+		break;
+	case FDC_BASE:
+		np = of_find_node_by_type(NULL, "fdc");
+		if (np == NULL)
+			return -ENODEV;
+		of_node_put(np);
+		break;
+	}
+	return 0;
+}
+
+/*
+ * Called very early, MMU is off, device-tree isn't unflattened
+ */
+extern struct machdep_calls pSeries_md;
+
+static int __init pSeries_probe(int platform)
+{
+	if (platform != PLATFORM_PSERIES &&
+	    platform != PLATFORM_PSERIES_LPAR)
+		return 0;
+
+	/* if we have some ppc_md fixups for LPAR to do, do
+	 * it here ...
+	 */
+
+	return 1;
+}
+
+DECLARE_PER_CPU(unsigned long, smt_snooze_delay);
+
+static inline void dedicated_idle_sleep(unsigned int cpu)
+{
+	struct paca_struct *ppaca = &paca[cpu ^ 1];
+
+	/* Only sleep if the other thread is not idle */
+	if (!(ppaca->lppaca.idle)) {
+		local_irq_disable();
+
+		/*
+		 * We are about to sleep the thread and so wont be polling any
+		 * more.
+		 */
+		clear_thread_flag(TIF_POLLING_NRFLAG);
+
+		/*
+		 * SMT dynamic mode. Cede will result in this thread going
+		 * dormant, if the partner thread is still doing work.  Thread
+		 * wakes up if partner goes idle, an interrupt is presented, or
+		 * a prod occurs.  Returning from the cede enables external
+		 * interrupts.
+		 */
+		if (!need_resched())
+			cede_processor();
+		else
+			local_irq_enable();
+	} else {
+		/*
+		 * Give the HV an opportunity at the processor, since we are
+		 * not doing any work.
+		 */
+		poll_pending();
+	}
+}
+
+static int pseries_dedicated_idle(void)
+{
+	long oldval;
+	struct paca_struct *lpaca = get_paca();
+	unsigned int cpu = smp_processor_id();
+	unsigned long start_snooze;
+	unsigned long *smt_snooze_delay = &__get_cpu_var(smt_snooze_delay);
+
+	while (1) {
+		/*
+		 * Indicate to the HV that we are idle. Now would be
+		 * a good time to find other work to dispatch.
+		 */
+		lpaca->lppaca.idle = 1;
+
+		oldval = test_and_clear_thread_flag(TIF_NEED_RESCHED);
+		if (!oldval) {
+			set_thread_flag(TIF_POLLING_NRFLAG);
+
+			start_snooze = __get_tb() +
+				*smt_snooze_delay * tb_ticks_per_usec;
+
+			while (!need_resched() && !cpu_is_offline(cpu)) {
+				ppc64_runlatch_off();
+
+				/*
+				 * Go into low thread priority and possibly
+				 * low power mode.
+				 */
+				HMT_low();
+				HMT_very_low();
+
+				if (*smt_snooze_delay != 0 &&
+				    __get_tb() > start_snooze) {
+					HMT_medium();
+					dedicated_idle_sleep(cpu);
+				}
+
+			}
+
+			HMT_medium();
+			clear_thread_flag(TIF_POLLING_NRFLAG);
+		} else {
+			set_need_resched();
+		}
+
+		lpaca->lppaca.idle = 0;
+		ppc64_runlatch_on();
+
+		schedule();
+
+		if (cpu_is_offline(cpu) && system_state == SYSTEM_RUNNING)
+			cpu_die();
+	}
+}
+
+static int pseries_shared_idle(void)
+{
+	struct paca_struct *lpaca = get_paca();
+	unsigned int cpu = smp_processor_id();
+
+	while (1) {
+		/*
+		 * Indicate to the HV that we are idle. Now would be
+		 * a good time to find other work to dispatch.
+		 */
+		lpaca->lppaca.idle = 1;
+
+		while (!need_resched() && !cpu_is_offline(cpu)) {
+			local_irq_disable();
+			ppc64_runlatch_off();
+
+			/*
+			 * Yield the processor to the hypervisor.  We return if
+			 * an external interrupt occurs (which are driven prior
+			 * to returning here) or if a prod occurs from another
+			 * processor. When returning here, external interrupts
+			 * are enabled.
+			 *
+			 * Check need_resched() again with interrupts disabled
+			 * to avoid a race.
+			 */
+			if (!need_resched())
+				cede_processor();
+			else
+				local_irq_enable();
+
+			HMT_medium();
+		}
+
+		lpaca->lppaca.idle = 0;
+		ppc64_runlatch_on();
+
+		schedule();
+
+		if (cpu_is_offline(cpu) && system_state == SYSTEM_RUNNING)
+			cpu_die();
+	}
+
+	return 0;
+}
+
+static int pSeries_pci_probe_mode(struct pci_bus *bus)
+{
+	if (systemcfg->platform & PLATFORM_LPAR)
+		return PCI_PROBE_DEVTREE;
+	return PCI_PROBE_NORMAL;
+}
+
+struct machdep_calls __initdata pSeries_md = {
+	.probe			= pSeries_probe,
+	.setup_arch		= pSeries_setup_arch,
+	.init_early		= pSeries_init_early,
+	.get_cpuinfo		= pSeries_get_cpuinfo,
+	.log_error		= pSeries_log_error,
+	.pcibios_fixup		= pSeries_final_fixup,
+	.pci_probe_mode		= pSeries_pci_probe_mode,
+	.irq_bus_setup		= pSeries_irq_bus_setup,
+	.restart		= rtas_restart,
+	.power_off		= rtas_power_off,
+	.halt			= rtas_halt,
+	.panic			= rtas_os_term,
+	.cpu_die		= pSeries_mach_cpu_die,
+	.get_boot_time		= rtas_get_boot_time,
+	.get_rtc_time		= rtas_get_rtc_time,
+	.set_rtc_time		= rtas_set_rtc_time,
+	.calibrate_decr		= generic_calibrate_decr,
+	.progress		= rtas_progress,
+	.check_legacy_ioport	= pSeries_check_legacy_ioport,
+	.system_reset_exception = pSeries_system_reset_exception,
+	.machine_check_exception = pSeries_machine_check_exception,
+};
