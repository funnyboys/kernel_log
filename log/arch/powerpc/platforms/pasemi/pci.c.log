commit 4505153954fdb1465d2b178288a9bf646f2a2166
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 16:57:47 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 333
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 59 temple place suite 330 boston ma 02111
      1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 136 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190530000436.384967451@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index fdc839d93837..8779b107d872 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2006 PA Semi, Inc
  *
@@ -7,19 +8,6 @@
  * Maintained by: Olof Johansson <olof@lixom.net>
  *
  * Based on arch/powerpc/platforms/maple/pci.c
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 
 

commit 51f4cc2047a4b7e9bf1b49acf06c110991fd4167
Author: Darren Stevens <darren@stevens-zone.net>
Date:   Sun Aug 19 21:26:28 2018 +0100

    powerpc/pasemi: Add Nemo board IRQ initroutine
    
    Add a IRQ init routine for the Nemo board which inits and attatches
    the i8259 found in the SB600, and a cascade routine to dispatch the
    interrupts.
    
    Signed-off-by: Darren Stevens <darren@stevens-zone.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index 116c0fee6dd0..fdc839d93837 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -27,6 +27,7 @@
 #include <linux/pci.h>
 
 #include <asm/pci-bridge.h>
+#include <asm/isa-bridge.h>
 #include <asm/machdep.h>
 
 #include <asm/ppc-pci.h>
@@ -181,6 +182,8 @@ static int pa_pxp_read_config(struct pci_bus *bus, unsigned int devfn,
 
 	addr = pa_pxp_cfg_addr(hose, bus->number, devfn, offset);
 
+	sb600_set_flag(bus->number);
+
 	/*
 	 * Note: the caller has already checked that offset is
 	 * suitably aligned and that len is 1, 2 or 4.
@@ -215,6 +218,8 @@ static int pa_pxp_write_config(struct pci_bus *bus, unsigned int devfn,
 
 	addr = pa_pxp_cfg_addr(hose, bus->number, devfn, offset);
 
+	sb600_set_flag(bus->number);
+
 	/*
 	 * Note: the caller has already checked that offset is
 	 * suitably aligned and that len is 1, 2 or 4.
@@ -265,6 +270,12 @@ static int __init pas_add_bridge(struct device_node *dev)
 	/* Interpret the "ranges" property */
 	pci_process_bridge_OF_ranges(hose, dev, 1);
 
+	/*
+	 * Scan for an isa bridge. This is needed to find the SB600 on the nemo
+	 * and does nothing on machines without one.
+	 */
+	isa_bridge_find_early(hose);
+
 	return 0;
 }
 

commit 68f211a4d1e5882e881bbb84b6505908dde5f625
Author: Darren Stevens <darren@stevens-zone.net>
Date:   Sun Aug 19 21:21:55 2018 +0100

    powerpc/pasemi: Add PCI initialisation for Nemo board.
    
    The A-Eon Amigaone X1000's Nemo motherboard has an AMD SB600
    connected to one of the PCI-e root ports on its PaSemi
    Pwrficient 1628M SoC. Normally the SB600 southbridge would be
    connected to a hidden PCI-e port on the system's northbridge,
    and as a result doesn't fully comply with the PCI-e spec.
    
    Add code to relax the PCI-e detection in both the root port
    and the Linux kernel allowing on board devices to be detected.
    
    Signed-off-by: Darren Stevens <darren@stevens-zone.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index c3c64172482d..116c0fee6dd0 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -108,6 +108,61 @@ static int workaround_5945(struct pci_bus *bus, unsigned int devfn,
 	return 1;
 }
 
+#ifdef CONFIG_PPC_PASEMI_NEMO
+#define PXP_ERR_CFG_REG	0x4
+#define PXP_IGNORE_PCIE_ERRORS	0x800
+#define SB600_BUS 5
+
+static void sb600_set_flag(int bus)
+{
+	static void __iomem *iob_mapbase = NULL;
+	struct resource res;
+	struct device_node *dn;
+	int err;
+
+	if (iob_mapbase == NULL) {
+		dn = of_find_compatible_node(NULL, "isa", "pasemi,1682m-iob");
+		if (!dn) {
+			pr_crit("NEMO SB600 missing iob node\n");
+			return;
+		}
+
+		err = of_address_to_resource(dn, 0, &res);
+		of_node_put(dn);
+
+		if (err) {
+			pr_crit("NEMO SB600 missing resource\n");
+			return;
+		}
+
+		pr_info("NEMO SB600 IOB base %08llx\n",res.start);
+
+		iob_mapbase = ioremap(res.start + 0x100, 0x94);
+	}
+
+	if (iob_mapbase != NULL) {
+		if (bus == SB600_BUS) {
+			/*
+			 * This is the SB600's bus, tell the PCI-e root port
+			 * to allow non-zero devices to enumerate.
+			 */
+			out_le32(iob_mapbase + PXP_ERR_CFG_REG, in_le32(iob_mapbase + PXP_ERR_CFG_REG) | PXP_IGNORE_PCIE_ERRORS);
+		} else {
+			/*
+			 * Only scan device 0 on other busses
+			 */
+			out_le32(iob_mapbase + PXP_ERR_CFG_REG, in_le32(iob_mapbase + PXP_ERR_CFG_REG) & ~PXP_IGNORE_PCIE_ERRORS);
+		}
+	}
+}
+
+#else
+
+static void sb600_set_flag(int bus)
+{
+}
+#endif
+
 static int pa_pxp_read_config(struct pci_bus *bus, unsigned int devfn,
 			      int offset, int len, u32 *val)
 {

commit e13606d7321c0c08d4ac2d74a1102680a40cfdee
Author: Darren Stevens <darren@stevens-zone.net>
Date:   Fri Aug 3 21:15:10 2018 +1000

    powerpc/pasemi: Use pr_err/pr_warn... for kernel messages
    
    Pasemi code still uses printk(KERN_ERR/KERN_WARN ... change these to
    pr_err(, pr_warn(... to match other powerpc arch code.
    
    No functional changes.
    
    Signed-off-by: Darren Stevens <darren@stevens-zone.net>
    [mpe: Unsplit some strings while we're at it]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index 3e3e807d5b6b..c3c64172482d 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -205,7 +205,7 @@ static int __init pas_add_bridge(struct device_node *dev)
 
 	setup_pa_pxp(hose);
 
-	printk(KERN_INFO "Found PA-PXP PCI host bridge.\n");
+	pr_info("Found PA-PXP PCI host bridge.\n");
 
 	/* Interpret the "ranges" property */
 	pci_process_bridge_OF_ranges(hose, dev, 1);
@@ -220,8 +220,7 @@ void __init pas_pci_init(void)
 
 	root = of_find_node_by_path("/");
 	if (!root) {
-		printk(KERN_CRIT "pas_pci_init: can't find root "
-			"of device tree\n");
+		pr_crit("pas_pci_init: can't find root of device tree\n");
 		return;
 	}
 

commit 250a93501d6265bbb9ddf06af25ac9ae64782297
Author: Darren Stevens <darren@stevens-zone.net>
Date:   Wed Jul 25 21:55:18 2018 +0100

    powerpc/pasemi: Search for PCI root bus by compatible property
    
    Pasemi arch code finds the root of the PCI-e bus by searching the
    device-tree for a node called 'pxp'. But the root bus has a compatible
    property of 'pasemi,rootbus' so search for that instead.
    
    Signed-off-by: Darren Stevens <darren@stevens-zone.net>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index aea9ff2c8e6d..3e3e807d5b6b 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -216,6 +216,7 @@ static int __init pas_add_bridge(struct device_node *dev)
 void __init pas_pci_init(void)
 {
 	struct device_node *np, *root;
+	int res;
 
 	root = of_find_node_by_path("/");
 	if (!root) {
@@ -226,11 +227,11 @@ void __init pas_pci_init(void)
 
 	pci_set_flags(PCI_SCAN_ALL_PCIE_DEVS);
 
-	for (np = NULL; (np = of_get_next_child(root, np)) != NULL;)
-		if (np->name && !strcmp(np->name, "pxp") && !pas_add_bridge(np))
-			of_node_get(np);
-
-	of_node_put(root);
+	np = of_find_compatible_node(root, NULL, "pasemi,rootbus");
+	if (np) {
+		res = pas_add_bridge(np);
+		of_node_put(np);
+	}
 }
 
 void __iomem *pasemi_pci_getcfgaddr(struct pci_dev *dev, int offset)

commit eff06ef0891d200eb0ddd156c6e96ce3dd18edc0
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Dec 6 12:03:52 2017 +0100

    powerpc/pasemi: Set PCI_SCAN_ALL_PCI_DEVS
    
    Needed on Amiga X1000 with SB600.
    
    Reported-by: Christian Zigotzky <chzigotzky@xenosoft.de>
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index 5ff6108f19e9..aea9ff2c8e6d 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -224,6 +224,8 @@ void __init pas_pci_init(void)
 		return;
 	}
 
+	pci_set_flags(PCI_SCAN_ALL_PCIE_DEVS);
+
 	for (np = NULL; (np = of_get_next_child(root, np)) != NULL;)
 		if (np->name && !strcmp(np->name, "pxp") && !pas_add_bridge(np))
 			of_node_get(np);

commit b7c670d673d1186e9a6aafaad36aace34046bb6b
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 21 10:16:47 2017 -0500

    powerpc: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Anatolij Gustschin <agust@denx.de>
    Cc: Scott Wood <oss@buserror.net>
    Cc: Kumar Gala <galak@kernel.crashing.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linuxppc-dev@lists.ozlabs.org
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index 10c4e8fc6ea9..5ff6108f19e9 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -193,7 +193,7 @@ static int __init pas_add_bridge(struct device_node *dev)
 {
 	struct pci_controller *hose;
 
-	pr_debug("Adding PCI host bridge %s\n", dev->full_name);
+	pr_debug("Adding PCI host bridge %pOF\n", dev);
 
 	hose = pcibios_alloc_controller(dev);
 	if (!hose)

commit 8cc7581cdb84a232468c41bc417183a423dfbb07
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Fri May 20 16:41:37 2016 +1000

    powerpc/pci: Delay populating pdn
    
    The pdn (struct pci_dn) instances are allocated from memblock or
    bootmem when creating PCI controller (hoses) in setup_arch(). PCI
    hotplug, which will be supported by proceeding patches, releases
    PCI device nodes and their corresponding pdn on unplugging event.
    The memory chunks for pdn instances allocated from memblock or
    bootmem are hard to reused after being released.
    
    This delays creating pdn by pci_devs_phb_init() from setup_arch()
    to core_initcall() so that they are allocated from slab. The memory
    consumed by pdn can be released to system without problem during
    PCI unplugging time. It indicates that pci_dn is unavailable in
    setup_arch() and the the fixup on pdn (like AGP's) can't be carried
    out that time. We have to do that in pcibios_root_bridge_prepare()
    on maple/pasemi/powermac platforms where/when the pdn is available.
    pcibios_root_bridge_prepare is called from subsys_initcall() which
    is executed after core_initcall() so the code flow does not change.
    
    At the mean while, the EEH device is created when pdn is populated,
    meaning pdn and EEH device have same life cycle. In turn, we needn't
    call eeh_dev_init() to create EEH device explicitly.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index f3a68a0fef23..10c4e8fc6ea9 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -229,9 +229,6 @@ void __init pas_pci_init(void)
 			of_node_get(np);
 
 	of_node_put(root);
-
-	/* Setup the linkage between OF nodes and PHBs */
-	pci_devs_phb_init();
 }
 
 void __iomem *pasemi_pci_getcfgaddr(struct pci_dev *dev, int offset)

commit d28a0d94d752354d9830f8cc0426e9119f9f227d
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Mar 31 16:00:52 2015 +1100

    powerpc/pasemi: Move controller ops from ppc_md to controller_ops
    
    This moves the PaSemi platform to use the pci_controller_ops
    structure rather than ppc_md for PCI controller operations.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index aa862713258c..f3a68a0fef23 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -31,6 +31,8 @@
 
 #include <asm/ppc-pci.h>
 
+#include "pasemi.h"
+
 #define PA_PXP_CFA(bus, devfn, off) (((bus) << 20) | ((devfn) << 12) | (off))
 
 static inline int pa_pxp_offset_valid(u8 bus, u8 devfn, int offset)
@@ -199,6 +201,7 @@ static int __init pas_add_bridge(struct device_node *dev)
 
 	hose->first_busno = 0;
 	hose->last_busno = 0xff;
+	hose->controller_ops = pasemi_pci_controller_ops;
 
 	setup_pa_pxp(hose);
 
@@ -239,3 +242,5 @@ void __iomem *pasemi_pci_getcfgaddr(struct pci_dev *dev, int offset)
 
 	return (void __iomem *)pa_pxp_cfg_addr(hose, dev->bus->number, dev->devfn, offset);
 }
+
+struct pci_controller_ops pasemi_pci_controller_ops;

commit c0f209468e8b6c81b28f6417e7d88c99171d20b6
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 16 17:48:19 2012 -0600

    powerpc/PCI: allow reallocation on PA Semi
    
    We believe there's no reason to prevent reallocation on PA Semi, so
    revert to the default of "allow reallocation if necessary."
    
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: linuxppc-dev@lists.ozlabs.org
    Tested-by: Olof Johansson <olof@lixom.net>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index b27d8861116b..aa862713258c 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -229,9 +229,6 @@ void __init pas_pci_init(void)
 
 	/* Setup the linkage between OF nodes and PHBs */
 	pci_devs_phb_init();
-
-	/* Use the common resource allocation mechanism */
-	pci_add_flags(PCI_PROBE_ONLY);
 }
 
 void __iomem *pasemi_pci_getcfgaddr(struct pci_dev *dev, int offset)

commit 673c975624895c4db2edff32601d9c6475b2d39e
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:18:58 2012 -0700

    powerpc/PCI: replace pci_probe_only with pci_flags
    
    We already use pci_flags, so this just sets pci_flags directly and removes
    the intermediate step of figuring out pci_probe_only, then using it to set
    pci_flags.
    
    The PCI core provides a pci_flags definition (currently __weak), so drop
    the powerpc definitions in favor of that.
    
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index b6a0ec45c695..b27d8861116b 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -231,7 +231,7 @@ void __init pas_pci_init(void)
 	pci_devs_phb_init();
 
 	/* Use the common resource allocation mechanism */
-	pci_probe_only = 1;
+	pci_add_flags(PCI_PROBE_ONLY);
 }
 
 void __iomem *pasemi_pci_getcfgaddr(struct pci_dev *dev, int offset)

commit 4d442331e57b7bbc28b5a20f7d069bc12e9c503e
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Sep 5 12:08:50 2007 +1000

    [POWERPC] pasemi: Add workaround for erratum 5945
    
    Erratum 5945 causes some of the registers on the PCIe root ports to
    not read correctly.  Do a small dance to avoid this: Write an unused
    register, read the value and write it back.  Thankfully this is not in
    a hot code path.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index fcfb3df3f1a9..b6a0ec45c695 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -51,6 +51,61 @@ static void volatile __iomem *pa_pxp_cfg_addr(struct pci_controller *hose,
 	return hose->cfg_data + PA_PXP_CFA(bus, devfn, offset);
 }
 
+static inline int is_root_port(int busno, int devfn)
+{
+	return ((busno == 0) && (PCI_FUNC(devfn) < 4) &&
+		 ((PCI_SLOT(devfn) == 16) || (PCI_SLOT(devfn) == 17)));
+}
+
+static inline int is_5945_reg(int reg)
+{
+	return (((reg >= 0x18) && (reg < 0x34)) ||
+		((reg >= 0x158) && (reg < 0x178)));
+}
+
+static int workaround_5945(struct pci_bus *bus, unsigned int devfn,
+			   int offset, int len, u32 *val)
+{
+	struct pci_controller *hose;
+	void volatile __iomem *addr, *dummy;
+	int byte;
+	u32 tmp;
+
+	if (!is_root_port(bus->number, devfn) || !is_5945_reg(offset))
+		return 0;
+
+	hose = pci_bus_to_host(bus);
+
+	addr = pa_pxp_cfg_addr(hose, bus->number, devfn, offset & ~0x3);
+	byte = offset & 0x3;
+
+	/* Workaround bug 5945: write 0 to a dummy register before reading,
+	 * and write back what we read. We must read/write the full 32-bit
+	 * contents so we need to shift and mask by hand.
+	 */
+	dummy = pa_pxp_cfg_addr(hose, bus->number, devfn, 0x10);
+	out_le32(dummy, 0);
+	tmp = in_le32(addr);
+	out_le32(addr, tmp);
+
+	switch (len) {
+	case 1:
+		*val = (tmp >> (8*byte)) & 0xff;
+		break;
+	case 2:
+		if (byte == 0)
+			*val = tmp & 0xffff;
+		else
+			*val = (tmp >> 16) & 0xffff;
+		break;
+	default:
+		*val = tmp;
+		break;
+	}
+
+	return 1;
+}
+
 static int pa_pxp_read_config(struct pci_bus *bus, unsigned int devfn,
 			      int offset, int len, u32 *val)
 {
@@ -64,6 +119,9 @@ static int pa_pxp_read_config(struct pci_bus *bus, unsigned int devfn,
 	if (!pa_pxp_offset_valid(bus->number, devfn, offset))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
+	if (workaround_5945(bus, devfn, offset, len, val))
+		return PCIBIOS_SUCCESSFUL;
+
 	addr = pa_pxp_cfg_addr(hose, bus->number, devfn, offset);
 
 	/*
@@ -180,7 +238,7 @@ void __iomem *pasemi_pci_getcfgaddr(struct pci_dev *dev, int offset)
 {
 	struct pci_controller *hose;
 
-	hose = pci_bus_to_host(bus);
+	hose = pci_bus_to_host(dev->bus);
 
-	return pa_pxp_cfg_addr(hose, hose->number, dev->devfn, int offset)
+	return (void __iomem *)pa_pxp_cfg_addr(hose, dev->bus->number, dev->devfn, offset);
 }

commit 68c8404c742fdda2151b4bf6bd98419bf8118481
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Sep 5 12:08:30 2007 +1000

    [POWERPC] pasemi: Add pasemi_pci_getcfgaddr()
    
    Add pasemi_pci_getcfgaddr(), to get the remapped address of a specific
    config register for a PCI device.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index 03d1d07aa2ac..fcfb3df3f1a9 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -175,3 +175,12 @@ void __init pas_pci_init(void)
 	/* Use the common resource allocation mechanism */
 	pci_probe_only = 1;
 }
+
+void __iomem *pasemi_pci_getcfgaddr(struct pci_dev *dev, int offset)
+{
+	struct pci_controller *hose;
+
+	hose = pci_bus_to_host(bus);
+
+	return pa_pxp_cfg_addr(hose, hose->number, dev->devfn, int offset)
+}

commit b139f1fb0f1e4bfe06f2c88ba8c9a55d9513d871
Author: Nathan Lynch <ntl@pobox.com>
Date:   Fri Aug 10 07:37:27 2007 +1000

    [POWERPC] Remove gratuitous reads from pasemi pci config space methods
    
    The pasemi pci configuration space write method reads the written
    location immediately after the write is performed, presumably in order
    to flush the write.  However, configuration space writes are not
    allowed to be posted, making these reads gratuitous.  Furthermore,
    this behavior potentially causes us to violate the PCI PM spec when
    changing between e.g. D0 and D3 states, because a delay of up to 10ms
    may be required before the OS accesses configuration space after the
    write which initiates the transition.
    
    Remove the unnecessary reads from pa_pxp_write_config.
    
    Signed-off-by: Nathan Lynch <ntl@pobox.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index 882b571ba92c..03d1d07aa2ac 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -107,15 +107,12 @@ static int pa_pxp_write_config(struct pci_bus *bus, unsigned int devfn,
 	switch (len) {
 	case 1:
 		out_8(addr, val);
-		(void) in_8(addr);
 		break;
 	case 2:
 		out_le16(addr, val);
-		(void) in_le16(addr);
 		break;
 	default:
 		out_le32(addr, val);
-		(void) in_le32(addr);
 		break;
 	}
 	return PCIBIOS_SUCCESSFUL;

commit 1bb8c6216f08519c16ce20b82e6f6a59fe0ce717
Author: Nathan Lynch <ntl@pobox.com>
Date:   Fri Aug 10 05:18:40 2007 +1000

    [POWERPC] pa_pxp_ops: Use named structure member initializers
    
    Signed-off-by: Nathan Lynch <ntl@pobox.com>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index ab1f5f62bcd8..882b571ba92c 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -122,8 +122,8 @@ static int pa_pxp_write_config(struct pci_bus *bus, unsigned int devfn,
 }
 
 static struct pci_ops pa_pxp_ops = {
-	pa_pxp_read_config,
-	pa_pxp_write_config,
+	.read = pa_pxp_read_config,
+	.write = pa_pxp_write_config,
 };
 
 static void __init setup_pa_pxp(struct pci_controller *hose)

commit 09b55f76c9e41ed88f445f64f00ed39b48ed137d
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Jun 18 01:06:54 2007 +0200

    [POWERPC] rename add_bridge to avoid namespace clashes
    
    Many platforms currently define their own add_bridge function, some
    of them globally. This breaks some multiplatform configurations.
    Prefixing each of these functions with the platform name avoids
    this problem.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index 5606f25760bc..ab1f5f62bcd8 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -132,7 +132,7 @@ static void __init setup_pa_pxp(struct pci_controller *hose)
 	hose->cfg_data = ioremap(0xe0000000, 0x10000000);
 }
 
-static int __init add_bridge(struct device_node *dev)
+static int __init pas_add_bridge(struct device_node *dev)
 {
 	struct pci_controller *hose;
 
@@ -167,7 +167,7 @@ void __init pas_pci_init(void)
 	}
 
 	for (np = NULL; (np = of_get_next_child(root, np)) != NULL;)
-		if (np->name && !strcmp(np->name, "pxp") && !add_bridge(np))
+		if (np->name && !strcmp(np->name, "pxp") && !pas_add_bridge(np))
 			of_node_get(np);
 
 	of_node_put(root);

commit 3d5134ee8341bffc4f539049abb9e90d469b448d
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Jun 4 15:15:36 2007 +1000

    [POWERPC] Rewrite IO allocation & mapping on powerpc64
    
    This rewrites pretty much from scratch the handling of MMIO and PIO
    space allocations on powerpc64.  The main goals are:
    
     - Get rid of imalloc and use more common code where possible
     - Simplify the current mess so that PIO space is allocated and
       mapped in a single place for PCI bridges
     - Handle allocation constraints of PIO for all bridges including
       hot plugged ones within the 2GB space reserved for IO ports,
       so that devices on hotplugged busses will now work with drivers
       that assume IO ports fit in an int.
     - Cleanup and separate tracking of the ISA space in the reserved
       low 64K of IO space. No ISA -> Nothing mapped there.
    
    I booted a cell blade with IDE on PIO and MMIO and a dual G5 so
    far, that's it :-)
    
    With this patch, all allocations are done using the code in
    mm/vmalloc.c, though we use the low level __get_vm_area with
    explicit start/stop constraints in order to manage separate
    areas for vmalloc/vmap, ioremap, and PCI IOs.
    
    This greatly simplifies a lot of things, as you can see in the
    diffstat of that patch :-)
    
    A new pair of functions pcibios_map/unmap_io_space() now replace
    all of the previous code that used to manipulate PCI IOs space.
    The allocation is done at mapping time, which is now called from
    scan_phb's, just before the devices are probed (instead of after,
    which is by itself a bug fix). The only other caller is the PCI
    hotplug code for hot adding PCI-PCI bridges (slots).
    
    imalloc is gone, as is the "sub-allocation" thing, but I do beleive
    that hotplug should still work in the sense that the space allocation
    is always done by the PHB, but if you unmap a child bus of this PHB
    (which seems to be possible), then the code should properly tear
    down all the HPTE mappings for that area of the PHB allocated IO space.
    
    I now always reserve the first 64K of IO space for the bridge with
    the ISA bus on it. I have moved the code for tracking ISA in a separate
    file which should also make it smarter if we ever are capable of
    hot unplugging or re-plugging an ISA bridge.
    
    This should have a side effect on platforms like powermac where VGA IOs
    will no longer work. This is done on purpose though as they would have
    worked semi-randomly before. The idea at this point is to isolate drivers
    that might need to access those and fix them by providing a proper
    function to obtain an offset to the legacy IOs of a given bus.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index bbc6dfcfaa91..5606f25760bc 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -150,29 +150,11 @@ static int __init add_bridge(struct device_node *dev)
 	printk(KERN_INFO "Found PA-PXP PCI host bridge.\n");
 
 	/* Interpret the "ranges" property */
-	/* This also maps the I/O region and sets isa_io/mem_base */
 	pci_process_bridge_OF_ranges(hose, dev, 1);
-	pci_setup_phb_io(hose, 1);
 
 	return 0;
 }
 
-
-static void __init pas_fixup_phb_resources(void)
-{
-	struct pci_controller *hose, *tmp;
-
-	list_for_each_entry_safe(hose, tmp, &hose_list, list_node) {
-		unsigned long offset = (unsigned long)hose->io_base_virt - pci_io_base;
-		hose->io_resource.start += offset;
-		hose->io_resource.end += offset;
-		printk(KERN_INFO "PCI Host %d, io start: %lx; io end: %lx\n",
-		       hose->global_number,
-		       hose->io_resource.start, hose->io_resource.end);
-	}
-}
-
-
 void __init pas_pci_init(void)
 {
 	struct device_node *np, *root;
@@ -190,8 +172,6 @@ void __init pas_pci_init(void)
 
 	of_node_put(root);
 
-	pas_fixup_phb_resources();
-
 	/* Setup the linkage between OF nodes and PHBs */
 	pci_devs_phb_init();
 

commit 771f7404a9deca902594823d616cd7a84f827982
Author: Olof Johansson <olof@lixom.net>
Date:   Tue May 8 00:47:21 2007 -0500

    pasemi_mac: Move the IRQ mapping from the PCI layer to the driver
    
    Fixes for ethernet IRQ mapping, to be done in the driver instead of in
    the platform setup code.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index 056243da360b..bbc6dfcfaa91 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -173,19 +173,6 @@ static void __init pas_fixup_phb_resources(void)
 }
 
 
-void __devinit pas_pci_irq_fixup(struct pci_dev *dev)
-{
-	/* DMA is special, 84 interrupts (128 -> 211), all but 128
-	 * need to be mapped by hand here.
-	 */
-	if (dev->vendor == 0x1959 && dev->device == 0xa007) {
-		int i;
-		for (i = 129; i < 212; i++)
-			irq_create_mapping(NULL, i);
-	}
-}
-
-
 void __init pas_pci_init(void)
 {
 	struct device_node *np, *root;

commit df7e70a2b0899845bb9a53548beeed05b9947705
Author: Olof Johansson <olof@lixom.net>
Date:   Mon Apr 16 16:26:34 2007 +1000

    [POWERPC] pasemi: Allow 8KB config space for I/O bridge
    
    Device 0 function 0 on the root bus is really a two-function bus agent,
    but only the first function is visible. Because of this, we need to
    allow config accesses into the second range. Modify the check for valid
    offsets accordingly.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index 7ecb2ba24db9..056243da360b 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -33,7 +33,17 @@
 
 #define PA_PXP_CFA(bus, devfn, off) (((bus) << 20) | ((devfn) << 12) | (off))
 
-#define CONFIG_OFFSET_VALID(off) ((off) < 4096)
+static inline int pa_pxp_offset_valid(u8 bus, u8 devfn, int offset)
+{
+	/* Device 0 Function 0 is special: It's config space spans function 1 as
+	 * well, so allow larger offset. It's really a two-function device but the
+	 * second function does not probe.
+	 */
+	if (bus == 0 && devfn == 0)
+		return offset < 8192;
+	else
+		return offset < 4096;
+}
 
 static void volatile __iomem *pa_pxp_cfg_addr(struct pci_controller *hose,
 				       u8 bus, u8 devfn, int offset)
@@ -51,7 +61,7 @@ static int pa_pxp_read_config(struct pci_bus *bus, unsigned int devfn,
 	if (!hose)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
-	if (!CONFIG_OFFSET_VALID(offset))
+	if (!pa_pxp_offset_valid(bus->number, devfn, offset))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
 	addr = pa_pxp_cfg_addr(hose, bus->number, devfn, offset);
@@ -85,7 +95,7 @@ static int pa_pxp_write_config(struct pci_bus *bus, unsigned int devfn,
 	if (!hose)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
-	if (!CONFIG_OFFSET_VALID(offset))
+	if (!pa_pxp_offset_valid(bus->number, devfn, offset))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
 	addr = pa_pxp_cfg_addr(hose, bus->number, devfn, offset);

commit f9fba5b72dbedc691dcb10ae666ec03f279b07f4
Author: Olof Johansson <olof@lixom.net>
Date:   Sun Feb 4 16:36:54 2007 -0600

    [POWERPC] pasemi: Configure DMA controller interrupts
    
    The DMA controller on PWRficient is somewhat special -- has a PCI header
    so it looks like it's on the root PCI (-Express) root bus, but it uses
    more than the default number of interrupts (and they are hardwired).
    
    We need to wire up all interrupts for the DMA controller. The generic
    IRQ code will only map the primary interrupt from the PCI header (128),
    so add 129->211 by hand.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index faa618e04047..7ecb2ba24db9 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -163,6 +163,19 @@ static void __init pas_fixup_phb_resources(void)
 }
 
 
+void __devinit pas_pci_irq_fixup(struct pci_dev *dev)
+{
+	/* DMA is special, 84 interrupts (128 -> 211), all but 128
+	 * need to be mapped by hand here.
+	 */
+	if (dev->vendor == 0x1959 && dev->device == 0xa007) {
+		int i;
+		for (i = 129; i < 212; i++)
+			irq_create_mapping(NULL, i);
+	}
+}
+
+
 void __init pas_pci_init(void)
 {
 	struct device_node *np, *root;

commit f90bb153b1493719d18b4529a46ebfe43220ea6c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sat Nov 11 17:24:51 2006 +1100

    [POWERPC] Make pci_read_irq_line the default
    
    This patch reworks the way IRQs are fixed up on PCI for arch powerpc.
    
    It makes pci_read_irq_line() called by default in the PCI code for
    devices that are probed, and add an optional per-device fixup in
    ppc_md for platforms that really need to correct what they obtain
    from pci_read_irq_line().
    
    It also removes ppc_md.irq_bus_setup which was only used by pSeries
    and should not be needed anymore.
    
    I've also removed the pSeries s7a workaround as it can't work with
    the current interrupt code anyway. I'm trying to get one of these
    machines working so I can test a proper fix for that problem.
    
    I also haven't updated the old-style fixup code from 85xx_cds.c
    because it's actually buggy :) It assigns pci_dev->irq hard coded
    numbers which is no good with the new IRQ mapping code. It should
    at least use irq_create_mapping(NULL, hard_coded_number); and possibly
    also set_irq_type() to set them as level low.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index 39020c1fa13d..faa618e04047 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -148,14 +148,6 @@ static int __init add_bridge(struct device_node *dev)
 }
 
 
-void __init pas_pcibios_fixup(void)
-{
-	struct pci_dev *dev = NULL;
-
-	for_each_pci_dev(dev)
-		pci_read_irq_line(dev);
-}
-
 static void __init pas_fixup_phb_resources(void)
 {
 	struct pci_controller *hose, *tmp;

commit 7c84ace9bcd90e38ebf88b304a8ed4fed7ff3574
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Mon Oct 9 16:23:09 2006 +0100

    [PATCH] trivial iomem annotations (arch/powerpc/platfroms/parsemi/pci.c)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Acked-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
index 4679c5230413..39020c1fa13d 100644
--- a/arch/powerpc/platforms/pasemi/pci.c
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -35,17 +35,17 @@
 
 #define CONFIG_OFFSET_VALID(off) ((off) < 4096)
 
-static unsigned long pa_pxp_cfg_addr(struct pci_controller *hose,
+static void volatile __iomem *pa_pxp_cfg_addr(struct pci_controller *hose,
 				       u8 bus, u8 devfn, int offset)
 {
-	return ((unsigned long)hose->cfg_data) + PA_PXP_CFA(bus, devfn, offset);
+	return hose->cfg_data + PA_PXP_CFA(bus, devfn, offset);
 }
 
 static int pa_pxp_read_config(struct pci_bus *bus, unsigned int devfn,
 			      int offset, int len, u32 *val)
 {
 	struct pci_controller *hose;
-	unsigned long addr;
+	void volatile __iomem *addr;
 
 	hose = pci_bus_to_host(bus);
 	if (!hose)
@@ -62,13 +62,13 @@ static int pa_pxp_read_config(struct pci_bus *bus, unsigned int devfn,
 	 */
 	switch (len) {
 	case 1:
-		*val = in_8((u8 *)addr);
+		*val = in_8(addr);
 		break;
 	case 2:
-		*val = in_le16((u16 *)addr);
+		*val = in_le16(addr);
 		break;
 	default:
-		*val = in_le32((u32 *)addr);
+		*val = in_le32(addr);
 		break;
 	}
 
@@ -79,7 +79,7 @@ static int pa_pxp_write_config(struct pci_bus *bus, unsigned int devfn,
 			       int offset, int len, u32 val)
 {
 	struct pci_controller *hose;
-	unsigned long addr;
+	void volatile __iomem *addr;
 
 	hose = pci_bus_to_host(bus);
 	if (!hose)
@@ -96,16 +96,16 @@ static int pa_pxp_write_config(struct pci_bus *bus, unsigned int devfn,
 	 */
 	switch (len) {
 	case 1:
-		out_8((u8 *)addr, val);
-		(void) in_8((u8 *)addr);
+		out_8(addr, val);
+		(void) in_8(addr);
 		break;
 	case 2:
-		out_le16((u16 *)addr, val);
-		(void) in_le16((u16 *)addr);
+		out_le16(addr, val);
+		(void) in_le16(addr);
 		break;
 	default:
-		out_le32((u32 *)addr, val);
-		(void) in_le32((u32 *)addr);
+		out_le32(addr, val);
+		(void) in_le32(addr);
 		break;
 	}
 	return PCIBIOS_SUCCESSFUL;

commit 1e76875e51266a5c43f601ecf08a92be5769228c
Author: Olof Johansson <olof@lixom.net>
Date:   Wed Sep 6 14:42:08 2006 -0500

    [POWERPC] powerpc: PA Semi PWRficient platform support
    
    Base patch for PA6T and PA6T-1682M. This introduces the
    arch/powerpc/platform/pasemi directory, together with basic
    implementations for various setup.
    
    Much of this was based on other platform code, i.e. Maple, etc.
    
    Signed-off-by: Olof Johansson <olof@lixom.net>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/pasemi/pci.c b/arch/powerpc/platforms/pasemi/pci.c
new file mode 100644
index 000000000000..4679c5230413
--- /dev/null
+++ b/arch/powerpc/platforms/pasemi/pci.c
@@ -0,0 +1,198 @@
+/*
+ * Copyright (C) 2006 PA Semi, Inc
+ *
+ * Authors: Kip Walker, PA Semi
+ *	    Olof Johansson, PA Semi
+ *
+ * Maintained by: Olof Johansson <olof@lixom.net>
+ *
+ * Based on arch/powerpc/platforms/maple/pci.c
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+
+#include <asm/pci-bridge.h>
+#include <asm/machdep.h>
+
+#include <asm/ppc-pci.h>
+
+#define PA_PXP_CFA(bus, devfn, off) (((bus) << 20) | ((devfn) << 12) | (off))
+
+#define CONFIG_OFFSET_VALID(off) ((off) < 4096)
+
+static unsigned long pa_pxp_cfg_addr(struct pci_controller *hose,
+				       u8 bus, u8 devfn, int offset)
+{
+	return ((unsigned long)hose->cfg_data) + PA_PXP_CFA(bus, devfn, offset);
+}
+
+static int pa_pxp_read_config(struct pci_bus *bus, unsigned int devfn,
+			      int offset, int len, u32 *val)
+{
+	struct pci_controller *hose;
+	unsigned long addr;
+
+	hose = pci_bus_to_host(bus);
+	if (!hose)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if (!CONFIG_OFFSET_VALID(offset))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	addr = pa_pxp_cfg_addr(hose, bus->number, devfn, offset);
+
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	switch (len) {
+	case 1:
+		*val = in_8((u8 *)addr);
+		break;
+	case 2:
+		*val = in_le16((u16 *)addr);
+		break;
+	default:
+		*val = in_le32((u32 *)addr);
+		break;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pa_pxp_write_config(struct pci_bus *bus, unsigned int devfn,
+			       int offset, int len, u32 val)
+{
+	struct pci_controller *hose;
+	unsigned long addr;
+
+	hose = pci_bus_to_host(bus);
+	if (!hose)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if (!CONFIG_OFFSET_VALID(offset))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	addr = pa_pxp_cfg_addr(hose, bus->number, devfn, offset);
+
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	switch (len) {
+	case 1:
+		out_8((u8 *)addr, val);
+		(void) in_8((u8 *)addr);
+		break;
+	case 2:
+		out_le16((u16 *)addr, val);
+		(void) in_le16((u16 *)addr);
+		break;
+	default:
+		out_le32((u32 *)addr, val);
+		(void) in_le32((u32 *)addr);
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops pa_pxp_ops = {
+	pa_pxp_read_config,
+	pa_pxp_write_config,
+};
+
+static void __init setup_pa_pxp(struct pci_controller *hose)
+{
+	hose->ops = &pa_pxp_ops;
+	hose->cfg_data = ioremap(0xe0000000, 0x10000000);
+}
+
+static int __init add_bridge(struct device_node *dev)
+{
+	struct pci_controller *hose;
+
+	pr_debug("Adding PCI host bridge %s\n", dev->full_name);
+
+	hose = pcibios_alloc_controller(dev);
+	if (!hose)
+		return -ENOMEM;
+
+	hose->first_busno = 0;
+	hose->last_busno = 0xff;
+
+	setup_pa_pxp(hose);
+
+	printk(KERN_INFO "Found PA-PXP PCI host bridge.\n");
+
+	/* Interpret the "ranges" property */
+	/* This also maps the I/O region and sets isa_io/mem_base */
+	pci_process_bridge_OF_ranges(hose, dev, 1);
+	pci_setup_phb_io(hose, 1);
+
+	return 0;
+}
+
+
+void __init pas_pcibios_fixup(void)
+{
+	struct pci_dev *dev = NULL;
+
+	for_each_pci_dev(dev)
+		pci_read_irq_line(dev);
+}
+
+static void __init pas_fixup_phb_resources(void)
+{
+	struct pci_controller *hose, *tmp;
+
+	list_for_each_entry_safe(hose, tmp, &hose_list, list_node) {
+		unsigned long offset = (unsigned long)hose->io_base_virt - pci_io_base;
+		hose->io_resource.start += offset;
+		hose->io_resource.end += offset;
+		printk(KERN_INFO "PCI Host %d, io start: %lx; io end: %lx\n",
+		       hose->global_number,
+		       hose->io_resource.start, hose->io_resource.end);
+	}
+}
+
+
+void __init pas_pci_init(void)
+{
+	struct device_node *np, *root;
+
+	root = of_find_node_by_path("/");
+	if (!root) {
+		printk(KERN_CRIT "pas_pci_init: can't find root "
+			"of device tree\n");
+		return;
+	}
+
+	for (np = NULL; (np = of_get_next_child(root, np)) != NULL;)
+		if (np->name && !strcmp(np->name, "pxp") && !add_bridge(np))
+			of_node_get(np);
+
+	of_node_put(root);
+
+	pas_fixup_phb_resources();
+
+	/* Setup the linkage between OF nodes and PHBs */
+	pci_devs_phb_init();
+
+	/* Use the common resource allocation mechanism */
+	pci_probe_only = 1;
+}
