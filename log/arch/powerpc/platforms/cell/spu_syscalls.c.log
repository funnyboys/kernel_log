commit de6cc6515a445d5d81cad2dee899a0be1a6317f8
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:02 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 153
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details you should have received a
      copy of the gnu general public license along with this program if
      not write to the free software foundation inc 675 mass ave cambridge
      ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 77 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Armijn Hemel <armijn@tjaldur.nl>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.837555891@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index b95d6afc39b5..87ad7d563cfa 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * SPU file system -- system call stubs
  *
@@ -5,20 +6,6 @@
  * (C) Copyright 2006-2007, IBM Corporation
  *
  * Author: Arnd Bergmann <arndb@de.ibm.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2, or (at your option)
- * any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 #include <linux/file.h>
 #include <linux/fs.h>

commit 45a202a3fefc6ee7b19b1222bfb5b0679ce31996
Author: Sabyasachi Gupta <sabyasachi.linux@gmail.com>
Date:   Thu Jan 17 21:49:05 2019 +0530

    powerpc/cell: Remove duplicate header
    
    Remove linux/syscalls.h which is included more than once
    
    Signed-off-by: Sabyasachi Gupta <sabyasachi.linux@gmail.com>
    Acked-by: Souptick Joarder <jrdr.linux@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index 263413a34823..b95d6afc39b5 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -26,7 +26,6 @@
 #include <linux/syscalls.h>
 #include <linux/rcupdate.h>
 #include <linux/binfmts.h>
-#include <linux/syscalls.h>
 
 #include <asm/spu.h>
 

commit 3691d6145585f52a6292c158e72bcde59df8e0a9
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed May 2 23:20:46 2018 +1000

    powerpc/syscalls: Switch trivial cases to SYSCALL_DEFINE
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index 5e6e0bad6db6..263413a34823 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -26,6 +26,7 @@
 #include <linux/syscalls.h>
 #include <linux/rcupdate.h>
 #include <linux/binfmts.h>
+#include <linux/syscalls.h>
 
 #include <asm/spu.h>
 
@@ -90,7 +91,7 @@ SYSCALL_DEFINE4(spu_create, const char __user *, name, unsigned int, flags,
 	return ret;
 }
 
-asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus)
+SYSCALL_DEFINE3(spu_run,int, fd, __u32 __user *, unpc, __u32 __user *, ustatus)
 {
 	long ret;
 	struct fd arg;

commit e623fbf1c4c140764e084e9159a352750c035d44
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Jul 8 16:00:09 2014 +1000

    powerpc/cell: Fix compilation with CONFIG_COREDUMP=n
    
    Commit 046d662f4818 "coredump: make core dump functionality optional"
    made the coredump optional, but didn't update the spufs code that
    depends on it. That leads to build errors such as:
    
      arch/powerpc/platforms/built-in.o: In function `.spufs_arch_write_note':
      coredump.c:(.text+0x22cd4): undefined reference to `.dump_emit'
      coredump.c:(.text+0x22cf4): undefined reference to `.dump_emit'
      coredump.c:(.text+0x22d0c): undefined reference to `.dump_align'
      coredump.c:(.text+0x22d48): undefined reference to `.dump_emit'
      coredump.c:(.text+0x22e7c): undefined reference to `.dump_skip'
    
    Fix it by adding some ifdefs in the cell code.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index 38e0a1a5cec3..5e6e0bad6db6 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -111,6 +111,7 @@ asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus)
 	return ret;
 }
 
+#ifdef CONFIG_COREDUMP
 int elf_coredump_extra_notes_size(void)
 {
 	struct spufs_calls *calls;
@@ -142,6 +143,7 @@ int elf_coredump_extra_notes_write(struct coredump_params *cprm)
 
 	return ret;
 }
+#endif
 
 void notify_spus_active(void)
 {

commit 282efb7023d482632f2fa567163362841423a1ac
Author: Monam Agarwal <monamagarwal123@gmail.com>
Date:   Sat Mar 22 12:20:56 2014 +0530

    arch/powerpc: Use RCU_INIT_POINTER(x, NULL) in platforms/cell/spu_syscalls.c
    
    Here rcu_assign_pointer() is ensuring that the
    initialization of a structure is carried out before storing a pointer
    to that structure.
    So, rcu_assign_pointer(p, NULL) can always safely be converted to
    RCU_INIT_POINTER(p, NULL).
    
    Signed-off-by: Monam Agarwal <monamagarwal123@gmail.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index 3844f1397fc3..38e0a1a5cec3 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -170,7 +170,7 @@ EXPORT_SYMBOL_GPL(register_spu_syscalls);
 void unregister_spu_syscalls(struct spufs_calls *calls)
 {
 	BUG_ON(spufs_calls->owner != calls->owner);
-	rcu_assign_pointer(spufs_calls, NULL);
+	RCU_INIT_POINTER(spufs_calls, NULL);
 	synchronize_rcu();
 }
 EXPORT_SYMBOL_GPL(unregister_spu_syscalls);

commit cdc3d5627d5f7c4e6b6372b9fb39cba0fe6a9b2a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sat Oct 5 22:24:29 2013 -0400

    switch elf_coredump_extra_notes_write() to dump_emit()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index db4e638cf408..3844f1397fc3 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -25,6 +25,7 @@
 #include <linux/module.h>
 #include <linux/syscalls.h>
 #include <linux/rcupdate.h>
+#include <linux/binfmts.h>
 
 #include <asm/spu.h>
 
@@ -126,7 +127,7 @@ int elf_coredump_extra_notes_size(void)
 	return ret;
 }
 
-int elf_coredump_extra_notes_write(struct file *file, loff_t *foffset)
+int elf_coredump_extra_notes_write(struct coredump_params *cprm)
 {
 	struct spufs_calls *calls;
 	int ret;
@@ -135,7 +136,7 @@ int elf_coredump_extra_notes_write(struct file *file, loff_t *foffset)
 	if (!calls)
 		return 0;
 
-	ret = calls->coredump_extra_notes_write(file, foffset);
+	ret = calls->coredump_extra_notes_write(cprm);
 
 	spufs_calls_put(calls);
 

commit 2903ff019b346ab8d36ebbf54853c3aaf6590608
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Aug 28 12:52:22 2012 -0400

    switch simple cases of fget_light to fdget
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index 714bbfc3162c..db4e638cf408 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -69,8 +69,6 @@ SYSCALL_DEFINE4(spu_create, const char __user *, name, unsigned int, flags,
 	umode_t, mode, int, neighbor_fd)
 {
 	long ret;
-	struct file *neighbor;
-	int fput_needed;
 	struct spufs_calls *calls;
 
 	calls = spufs_calls_get();
@@ -78,11 +76,11 @@ SYSCALL_DEFINE4(spu_create, const char __user *, name, unsigned int, flags,
 		return -ENOSYS;
 
 	if (flags & SPU_CREATE_AFFINITY_SPU) {
+		struct fd neighbor = fdget(neighbor_fd);
 		ret = -EBADF;
-		neighbor = fget_light(neighbor_fd, &fput_needed);
-		if (neighbor) {
-			ret = calls->create_thread(name, flags, mode, neighbor);
-			fput_light(neighbor, fput_needed);
+		if (neighbor.file) {
+			ret = calls->create_thread(name, flags, mode, neighbor.file);
+			fdput(neighbor);
 		}
 	} else
 		ret = calls->create_thread(name, flags, mode, NULL);
@@ -94,8 +92,7 @@ SYSCALL_DEFINE4(spu_create, const char __user *, name, unsigned int, flags,
 asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus)
 {
 	long ret;
-	struct file *filp;
-	int fput_needed;
+	struct fd arg;
 	struct spufs_calls *calls;
 
 	calls = spufs_calls_get();
@@ -103,10 +100,10 @@ asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus)
 		return -ENOSYS;
 
 	ret = -EBADF;
-	filp = fget_light(fd, &fput_needed);
-	if (filp) {
-		ret = calls->spu_run(filp, unpc, ustatus);
-		fput_light(filp, fput_needed);
+	arg = fdget(fd);
+	if (arg.file) {
+		ret = calls->spu_run(arg.file, unpc, ustatus);
+		fdput(arg);
 	}
 
 	spufs_calls_put(calls);

commit 1bc94226d5c642b78cf6b2e3e843ef24eb740df0
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Jul 26 16:50:23 2011 -0400

    switch spu_create(2) to use of SYSCALL_DEFINE4, make it use umode_t
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index 75530d99eda6..714bbfc3162c 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -65,8 +65,8 @@ static inline void spufs_calls_put(struct spufs_calls *calls) { }
 
 #endif /* CONFIG_SPU_FS_MODULE */
 
-asmlinkage long sys_spu_create(const char __user *name,
-		unsigned int flags, mode_t mode, int neighbor_fd)
+SYSCALL_DEFINE4(spu_create, const char __user *, name, unsigned int, flags,
+	umode_t, mode, int, neighbor_fd)
 {
 	long ret;
 	struct file *neighbor;

commit aed3a8c9bb1a8623a618232087c5ff62718e3b9a
Author: Bob Nelson <rrnelson@linux.vnet.ibm.com>
Date:   Sat Dec 15 01:27:30 2007 +1100

    [POWERPC] Oprofile: Remove dependency on spufs module
    
    This removes an OProfile dependency on the spufs module.  This
    dependency was causing a problem for multiplatform systems that are
    built with support for Oprofile on Cell but try to load the oprofile
    module on a non-Cell system.
    
    Signed-off-by: Bob Nelson <rrnelson@us.ibm.com>
    Signed-off-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>
    Acked-by: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index a9438b719fe8..75530d99eda6 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -145,6 +145,20 @@ int elf_coredump_extra_notes_write(struct file *file, loff_t *foffset)
 	return ret;
 }
 
+void notify_spus_active(void)
+{
+	struct spufs_calls *calls;
+
+	calls = spufs_calls_get();
+	if (!calls)
+		return;
+
+	calls->notify_spus_active();
+	spufs_calls_put(calls);
+
+	return;
+}
+
 int register_spu_syscalls(struct spufs_calls *calls)
 {
 	if (spufs_calls)

commit 7af1443a9d319132087e1e9a3984b94c6998835c
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Wed Sep 19 14:38:12 2007 +1000

    [POWERPC] spufs: Handle errors in SPU coredump code, and support coredump to a pipe
    
    Rework spufs_coredump_extra_notes_write() to check for and return errors.
    
    If we're coredumping to a pipe we can't trust file->f_pos, we need to
    maintain the foffset value passed to us. The cleanest way to do this is
    to have the low level write routine increment foffset when we've
    successfully written.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index b0117a7c6100..a9438b719fe8 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -132,19 +132,17 @@ int elf_coredump_extra_notes_size(void)
 int elf_coredump_extra_notes_write(struct file *file, loff_t *foffset)
 {
 	struct spufs_calls *calls;
+	int ret;
 
 	calls = spufs_calls_get();
 	if (!calls)
 		return 0;
 
-	calls->coredump_extra_notes_write(file);
+	ret = calls->coredump_extra_notes_write(file, foffset);
 
 	spufs_calls_put(calls);
 
-	/* Fudge foffset for now */
-	*foffset = file->f_pos;
-
-	return 0;
+	return ret;
 }
 
 int register_spu_syscalls(struct spufs_calls *calls)

commit e55014923e65e4ee8e477a1212381cca0125f3aa
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Wed Sep 19 14:38:12 2007 +1000

    [POWERPC] spufs: Cleanup ELF coredump extra notes logic
    
    To start with, arch_notes_size() etc. is a little too ambiguous a name for
    my liking, so change the function names to be more explicit.
    
    Calling through macros is ugly, especially with hidden parameters, so don't
    do that, call the routines directly.
    
    Use ARCH_HAVE_EXTRA_ELF_NOTES as the only flag, and based on it decide
    whether we want the extern declarations or the empty versions.
    
    Since we have empty routines, actually use them in the coredump code to
    save a few #ifdefs.
    
    We want to change the handling of foffset so that the write routine updates
    foffset as it goes, instead of using file->f_pos (so that writing to a pipe
    works).  So pass foffset to the write routine, and for now just set it to
    file->f_pos at the end of writing.
    
    It should also be possible for the write routine to fail, so change it to
    return int and treat a non-zero return as failure.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index 05841cdef4e1..b0117a7c6100 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -21,6 +21,7 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 #include <linux/file.h>
+#include <linux/fs.h>
 #include <linux/module.h>
 #include <linux/syscalls.h>
 #include <linux/rcupdate.h>
@@ -112,7 +113,7 @@ asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus)
 	return ret;
 }
 
-int arch_notes_size(void)
+int elf_coredump_extra_notes_size(void)
 {
 	struct spufs_calls *calls;
 	int ret;
@@ -128,17 +129,22 @@ int arch_notes_size(void)
 	return ret;
 }
 
-void arch_write_notes(struct file *file)
+int elf_coredump_extra_notes_write(struct file *file, loff_t *foffset)
 {
 	struct spufs_calls *calls;
 
 	calls = spufs_calls_get();
 	if (!calls)
-		return;
+		return 0;
 
 	calls->coredump_extra_notes_write(file);
 
 	spufs_calls_put(calls);
+
+	/* Fudge foffset for now */
+	*foffset = file->f_pos;
+
+	return 0;
 }
 
 int register_spu_syscalls(struct spufs_calls *calls)

commit 48cad41f7ee7b8a9a8317a4abbdaf09bc68b4773
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Wed Sep 19 14:38:12 2007 +1000

    [POWERPC] spufs: Combine spufs_coredump_calls with spufs_calls
    
    Because spufs might be built as a module, we can't have other parts of the
    kernel calling directly into it, we need stub routines that check first if the
    module is loaded.
    
    Currently we have two structures which hold callbacks for these stubs, the
    syscalls are in spufs_calls and the coredump calls are in spufs_coredump_calls.
    In both cases the logic for registering/unregistering is essentially the same,
    so we can simplify things by combining the two.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Acked-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index c0238dd9ff27..05841cdef4e1 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -2,6 +2,7 @@
  * SPU file system -- system call stubs
  *
  * (C) Copyright IBM Deutschland Entwicklung GmbH 2005
+ * (C) Copyright 2006-2007, IBM Corporation
  *
  * Author: Arnd Bergmann <arndb@de.ibm.com>
  *
@@ -111,6 +112,35 @@ asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus)
 	return ret;
 }
 
+int arch_notes_size(void)
+{
+	struct spufs_calls *calls;
+	int ret;
+
+	calls = spufs_calls_get();
+	if (!calls)
+		return 0;
+
+	ret = calls->coredump_extra_notes_size();
+
+	spufs_calls_put(calls);
+
+	return ret;
+}
+
+void arch_write_notes(struct file *file)
+{
+	struct spufs_calls *calls;
+
+	calls = spufs_calls_get();
+	if (!calls)
+		return;
+
+	calls->coredump_extra_notes_write(file);
+
+	spufs_calls_put(calls);
+}
+
 int register_spu_syscalls(struct spufs_calls *calls)
 {
 	if (spufs_calls)

commit 98f06978ffebbec16abdea58489f217229580859
Author: Jeremy Kerr <jk@ozlabs.org>
Date:   Wed Sep 19 14:38:12 2007 +1000

    [POWERPC] cell: Unify spufs syscall path
    
    At present, a built-in spufs will not use the spufs_calls callbacks, but
    directly call sys_spu_create.  This saves us an indirect branch, but
    means we have duplicated functions - one for CONFIG_SPU_FS=y and one for
    =m.
    
    This change unifies the spufs syscall path, and provides access to the
    spufs_calls structure through a get/put pair.  At present, the only user
    of the spufs_calls structure is spu_syscalls.c, but this will facilitate
    adding the coredump calls later.
    
    Everyone likes numbers, right?  Here's a before/after comparison with
    CONFIG_SPU_FS=y, doing spu_create(); close(); 64k times.
    
    Before:
            [jk@cell ~]$ time ./spu_create
            performing 65536 spu_create calls
    
            real    0m24.075s
            user    0m0.146s
            sys     0m23.925s
    
    After:
            [jk@cell ~]$ time ./spu_create
            performing 65536 spu_create calls
    
            real    0m24.777s
            user    0m0.141s
            sys     0m24.631s
    
    So, we're adding around 11us per syscall, at the benefit of having
    only one syscall path.
    
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index 027ac32cc636..c0238dd9ff27 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -22,42 +22,70 @@
 #include <linux/file.h>
 #include <linux/module.h>
 #include <linux/syscalls.h>
+#include <linux/rcupdate.h>
 
 #include <asm/spu.h>
 
-struct spufs_calls spufs_calls = {
-	.owner = NULL,
-};
+/* protected by rcu */
+static struct spufs_calls *spufs_calls;
 
-/* These stub syscalls are needed to have the actual implementation
- * within a loadable module. When spufs is built into the kernel,
- * this file is not used and the syscalls directly enter the fs code */
+#ifdef CONFIG_SPU_FS_MODULE
+
+static inline struct spufs_calls *spufs_calls_get(void)
+{
+	struct spufs_calls *calls = NULL;
+
+	rcu_read_lock();
+	calls = rcu_dereference(spufs_calls);
+	if (calls && !try_module_get(calls->owner))
+		calls = NULL;
+	rcu_read_unlock();
+
+	return calls;
+}
+
+static inline void spufs_calls_put(struct spufs_calls *calls)
+{
+	BUG_ON(calls != spufs_calls);
+
+	/* we don't need to rcu this, as we hold a reference to the module */
+	module_put(spufs_calls->owner);
+}
+
+#else /* !defined CONFIG_SPU_FS_MODULE */
+
+static inline struct spufs_calls *spufs_calls_get(void)
+{
+	return spufs_calls;
+}
+
+static inline void spufs_calls_put(struct spufs_calls *calls) { }
+
+#endif /* CONFIG_SPU_FS_MODULE */
 
 asmlinkage long sys_spu_create(const char __user *name,
 		unsigned int flags, mode_t mode, int neighbor_fd)
 {
 	long ret;
-	struct module *owner = spufs_calls.owner;
 	struct file *neighbor;
 	int fput_needed;
+	struct spufs_calls *calls;
 
-	ret = -ENOSYS;
-	if (owner && try_module_get(owner)) {
-		if (flags & SPU_CREATE_AFFINITY_SPU) {
-			neighbor = fget_light(neighbor_fd, &fput_needed);
-			ret = -EBADF;
-			if (neighbor) {
-				ret = spufs_calls.create_thread(name, flags,
-								mode, neighbor);
-				fput_light(neighbor, fput_needed);
-			}
-		}
-		else {
-			ret = spufs_calls.create_thread(name, flags,
-							mode, NULL);
+	calls = spufs_calls_get();
+	if (!calls)
+		return -ENOSYS;
+
+	if (flags & SPU_CREATE_AFFINITY_SPU) {
+		ret = -EBADF;
+		neighbor = fget_light(neighbor_fd, &fput_needed);
+		if (neighbor) {
+			ret = calls->create_thread(name, flags, mode, neighbor);
+			fput_light(neighbor, fput_needed);
 		}
-		module_put(owner);
-	}
+	} else
+		ret = calls->create_thread(name, flags, mode, NULL);
+
+	spufs_calls_put(calls);
 	return ret;
 }
 
@@ -66,37 +94,37 @@ asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus)
 	long ret;
 	struct file *filp;
 	int fput_needed;
-	struct module *owner = spufs_calls.owner;
+	struct spufs_calls *calls;
 
-	ret = -ENOSYS;
-	if (owner && try_module_get(owner)) {
-		ret = -EBADF;
-		filp = fget_light(fd, &fput_needed);
-		if (filp) {
-			ret = spufs_calls.spu_run(filp, unpc, ustatus);
-			fput_light(filp, fput_needed);
-		}
-		module_put(owner);
+	calls = spufs_calls_get();
+	if (!calls)
+		return -ENOSYS;
+
+	ret = -EBADF;
+	filp = fget_light(fd, &fput_needed);
+	if (filp) {
+		ret = calls->spu_run(filp, unpc, ustatus);
+		fput_light(filp, fput_needed);
 	}
+
+	spufs_calls_put(calls);
 	return ret;
 }
 
 int register_spu_syscalls(struct spufs_calls *calls)
 {
-	if (spufs_calls.owner)
+	if (spufs_calls)
 		return -EBUSY;
 
-	spufs_calls.create_thread = calls->create_thread;
-	spufs_calls.spu_run = calls->spu_run;
-	smp_mb();
-	spufs_calls.owner = calls->owner;
+	rcu_assign_pointer(spufs_calls, calls);
 	return 0;
 }
 EXPORT_SYMBOL_GPL(register_spu_syscalls);
 
 void unregister_spu_syscalls(struct spufs_calls *calls)
 {
-	BUG_ON(spufs_calls.owner != calls->owner);
-	spufs_calls.owner = NULL;
+	BUG_ON(spufs_calls->owner != calls->owner);
+	rcu_assign_pointer(spufs_calls, NULL);
+	synchronize_rcu();
 }
 EXPORT_SYMBOL_GPL(unregister_spu_syscalls);

commit ad941fe4b6b83999863f49dfba7b3d2cebc4ced5
Author: Jeremy Kerr <jk@ozlabs.org>
Date:   Mon Aug 13 13:22:44 2007 +1000

    [POWERPC] cell: Fix errno for modular spufs_create with invalid neighbour
    
    At present, spu_create with an invalid neighbo(u)r will return -ENOSYS,
    not -EBADF, but only when spufs.o is built as a module.
    
    This change adds the appropriate errno, making the behaviour the same
    as the built-in case.
    
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Acked-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index dd2c6688c8aa..027ac32cc636 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -45,6 +45,7 @@ asmlinkage long sys_spu_create(const char __user *name,
 	if (owner && try_module_get(owner)) {
 		if (flags & SPU_CREATE_AFFINITY_SPU) {
 			neighbor = fget_light(neighbor_fd, &fput_needed);
+			ret = -EBADF;
 			if (neighbor) {
 				ret = spufs_calls.create_thread(name, flags,
 								mode, neighbor);

commit 8e68e2f248332a9c3fd4f08258f488c209bd3e0c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jul 20 21:39:47 2007 +0200

    [CELL] spufs: extension of spu_create to support affinity definition
    
    This patch adds support for additional flags at spu_create, which relate
    to the establishment of affinity between contexts and contexts to memory.
    A fourth, optional, parameter is supported. This parameter represent
    a affinity neighbor of the context being created, and is used when defining
    SPU-SPU affinity.
    Affinity is represented as a doubly linked list of spu_contexts.
    
    Signed-off-by: Andre Detsch <adetsch@br.ibm.com>
    Signed-off-by: Arnd Bergmann <arnd.bergmann@de.ibm.com>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index 261b507a901a..dd2c6688c8aa 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -34,14 +34,27 @@ struct spufs_calls spufs_calls = {
  * this file is not used and the syscalls directly enter the fs code */
 
 asmlinkage long sys_spu_create(const char __user *name,
-		unsigned int flags, mode_t mode)
+		unsigned int flags, mode_t mode, int neighbor_fd)
 {
 	long ret;
 	struct module *owner = spufs_calls.owner;
+	struct file *neighbor;
+	int fput_needed;
 
 	ret = -ENOSYS;
 	if (owner && try_module_get(owner)) {
-		ret = spufs_calls.create_thread(name, flags, mode);
+		if (flags & SPU_CREATE_AFFINITY_SPU) {
+			neighbor = fget_light(neighbor_fd, &fput_needed);
+			if (neighbor) {
+				ret = spufs_calls.create_thread(name, flags,
+								mode, neighbor);
+				fput_light(neighbor, fput_needed);
+			}
+		}
+		else {
+			ret = spufs_calls.create_thread(name, flags,
+							mode, NULL);
+		}
 		module_put(owner);
 	}
 	return ret;

commit 59d6d39f30f4460b7e6489831caf7fbfe371941a
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Dec 9 19:04:15 2005 +0100

    [PATCH] spufs: fix module refcount race
    
    One of the two users of spufs_calls.owner still has a race
    when calling try_module_get while the module is removed.
    This makes it use the correct instance of owner.
    
    Noticed by Milton Miller.
    
    Signed-off-by: Arnd Bergmann <arndb@de.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index 91d564df944e..261b507a901a 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -40,7 +40,7 @@ asmlinkage long sys_spu_create(const char __user *name,
 	struct module *owner = spufs_calls.owner;
 
 	ret = -ENOSYS;
-	if (owner && try_module_get(spufs_calls.owner)) {
+	if (owner && try_module_get(owner)) {
 		ret = spufs_calls.create_thread(name, flags, mode);
 		module_put(owner);
 	}

commit b41305a39a6966d8e8b1449d6b7c194923bfb451
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Dec 5 22:52:23 2005 -0500

    [PATCH] spufs: Fix oops when spufs module is not loaded
    
    try_module_get returns true when NULL arguments, so
    we first need to check if there is a module loaded before
    getting the reference count.
    
    Signed-off-by: Arnd Bergmann <arndb@de.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
index 43e0b187ffde..91d564df944e 100644
--- a/arch/powerpc/platforms/cell/spu_syscalls.c
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -37,11 +37,12 @@ asmlinkage long sys_spu_create(const char __user *name,
 		unsigned int flags, mode_t mode)
 {
 	long ret;
+	struct module *owner = spufs_calls.owner;
 
 	ret = -ENOSYS;
-	if (try_module_get(spufs_calls.owner)) {
+	if (owner && try_module_get(spufs_calls.owner)) {
 		ret = spufs_calls.create_thread(name, flags, mode);
-		module_put(spufs_calls.owner);
+		module_put(owner);
 	}
 	return ret;
 }
@@ -51,16 +52,17 @@ asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus)
 	long ret;
 	struct file *filp;
 	int fput_needed;
+	struct module *owner = spufs_calls.owner;
 
 	ret = -ENOSYS;
-	if (try_module_get(spufs_calls.owner)) {
+	if (owner && try_module_get(owner)) {
 		ret = -EBADF;
 		filp = fget_light(fd, &fput_needed);
 		if (filp) {
 			ret = spufs_calls.spu_run(filp, unpc, ustatus);
 			fput_light(filp, fput_needed);
 		}
-		module_put(spufs_calls.owner);
+		module_put(owner);
 	}
 	return ret;
 }

commit 67207b9664a8d603138ef1556141e6d0a102bea7
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Nov 15 15:53:48 2005 -0500

    [PATCH] spufs: The SPU file system, base
    
    This is the current version of the spu file system, used
    for driving SPEs on the Cell Broadband Engine.
    
    This release is almost identical to the version for the
    2.6.14 kernel posted earlier, which is available as part
    of the Cell BE Linux distribution from
    http://www.bsc.es/projects/deepcomputing/linuxoncell/.
    
    The first patch provides all the interfaces for running
    spu application, but does not have any support for
    debugging SPU tasks or for scheduling. Both these
    functionalities are added in the subsequent patches.
    
    See Documentation/filesystems/spufs.txt on how to use
    spufs.
    
    Signed-off-by: Arnd Bergmann <arndb@de.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/cell/spu_syscalls.c b/arch/powerpc/platforms/cell/spu_syscalls.c
new file mode 100644
index 000000000000..43e0b187ffde
--- /dev/null
+++ b/arch/powerpc/platforms/cell/spu_syscalls.c
@@ -0,0 +1,86 @@
+/*
+ * SPU file system -- system call stubs
+ *
+ * (C) Copyright IBM Deutschland Entwicklung GmbH 2005
+ *
+ * Author: Arnd Bergmann <arndb@de.ibm.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/file.h>
+#include <linux/module.h>
+#include <linux/syscalls.h>
+
+#include <asm/spu.h>
+
+struct spufs_calls spufs_calls = {
+	.owner = NULL,
+};
+
+/* These stub syscalls are needed to have the actual implementation
+ * within a loadable module. When spufs is built into the kernel,
+ * this file is not used and the syscalls directly enter the fs code */
+
+asmlinkage long sys_spu_create(const char __user *name,
+		unsigned int flags, mode_t mode)
+{
+	long ret;
+
+	ret = -ENOSYS;
+	if (try_module_get(spufs_calls.owner)) {
+		ret = spufs_calls.create_thread(name, flags, mode);
+		module_put(spufs_calls.owner);
+	}
+	return ret;
+}
+
+asmlinkage long sys_spu_run(int fd, __u32 __user *unpc, __u32 __user *ustatus)
+{
+	long ret;
+	struct file *filp;
+	int fput_needed;
+
+	ret = -ENOSYS;
+	if (try_module_get(spufs_calls.owner)) {
+		ret = -EBADF;
+		filp = fget_light(fd, &fput_needed);
+		if (filp) {
+			ret = spufs_calls.spu_run(filp, unpc, ustatus);
+			fput_light(filp, fput_needed);
+		}
+		module_put(spufs_calls.owner);
+	}
+	return ret;
+}
+
+int register_spu_syscalls(struct spufs_calls *calls)
+{
+	if (spufs_calls.owner)
+		return -EBUSY;
+
+	spufs_calls.create_thread = calls->create_thread;
+	spufs_calls.spu_run = calls->spu_run;
+	smp_mb();
+	spufs_calls.owner = calls->owner;
+	return 0;
+}
+EXPORT_SYMBOL_GPL(register_spu_syscalls);
+
+void unregister_spu_syscalls(struct spufs_calls *calls)
+{
+	BUG_ON(spufs_calls.owner != calls->owner);
+	spufs_calls.owner = NULL;
+}
+EXPORT_SYMBOL_GPL(unregister_spu_syscalls);
