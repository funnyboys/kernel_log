commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
index d23c10a96bde..3fe1a6593280 100644
--- a/arch/powerpc/platforms/82xx/mpc8272_ads.c
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * MPC8272 ADS board support
  *
@@ -6,11 +7,6 @@
  *
  * Based on code by Vitaly Bordug <vbordug@ru.mvista.com>
  * Copyright (c) 2006 MontaVista Software, Inc.
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 
 #include <linux/init.h>

commit 565713840445b7ccafb28dc1230d57d40bcb42a5
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jul 5 15:04:05 2016 +1000

    powerpc: Move 32-bit probe() machine to later in the boot process
    
    This converts all the 32-bit platforms to use the expanded device-tree
    which is a pretty mechanical change. Unlike 64-bit, the 32-bit kernel
    didn't rely on platform initializations to setup the MMU since it
    sets it up entirely before probe_machine() so the move has comparatively
    less consequences though it's a bigger patch.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
index d24deacf07d0..d23c10a96bde 100644
--- a/arch/powerpc/platforms/82xx/mpc8272_ads.c
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -201,8 +201,7 @@ machine_device_initcall(mpc8272_ads, declare_of_platform_devices);
  */
 static int __init mpc8272_ads_probe(void)
 {
-	unsigned long root = of_get_flat_dt_root();
-	return of_flat_dt_is_compatible(root, "fsl,mpc8272ads");
+	return of_machine_is_compatible("fsl,mpc8272ads");
 }
 
 define_machine(mpc8272_ads)

commit ce6d73c94d7cfbdc3dc31860fe14af2f37d1b4fe
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Wed Sep 10 21:56:38 2014 +0200

    powerpc: make of_device_ids const
    
    of_device_ids (i.e. compatible strings and the respective data) are not
    supposed to change at runtime. All functions working with of_device_ids
    provided by <linux/of.h> work with const of_device_ids. This allows to
    mark all struct of_device_id const, too.
    
    While touching these line also put the __init annotation at the right
    position where necessary.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
index 6a14cf50f4a2..d24deacf07d0 100644
--- a/arch/powerpc/platforms/82xx/mpc8272_ads.c
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -181,7 +181,7 @@ static void __init mpc8272_ads_setup_arch(void)
 		ppc_md.progress("mpc8272_ads_setup_arch(), finish", 0);
 }
 
-static struct of_device_id __initdata of_bus_ids[] = {
+static const struct of_device_id of_bus_ids[] __initconst = {
 	{ .name = "soc", },
 	{ .name = "cpm", },
 	{ .name = "localbus", },

commit 26a2056eb21fff26caf99d19ad5448e9403db55d
Author: Rob Herring <rob.herring@calxeda.com>
Date:   Thu Sep 26 07:40:04 2013 -0500

    powerpc: add explicit OF includes
    
    When removing prom.h include by of.h, several OF headers will no longer
    be implicitly included. Add explicit includes of of_*.h as needed.
    
    Signed-off-by: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Grant Likely <grant.likely@linaro.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Anatolij Gustschin <agust@denx.de>
    Cc: Kumar Gala <galak@kernel.crashing.org>
    Cc: Olof Johansson <olof@lixom.net>
    Cc: linuxppc-dev@lists.ozlabs.org

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
index 30394b409b3f..6a14cf50f4a2 100644
--- a/arch/powerpc/platforms/82xx/mpc8272_ads.c
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -16,6 +16,8 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/fsl_devices.h>
+#include <linux/of_address.h>
+#include <linux/of_fdt.h>
 #include <linux/of_platform.h>
 #include <linux/io.h>
 

commit 818fcac554397a04987d49e2bd2dfc2d394b265c
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Wed Aug 19 03:28:17 2009 +0400

    powerpc/82xx: Add CPM USB Gadget support for MPC8272ADS boards
    
    - Add usb node;
    - Configure pins and clocks;
    - Enable USB function in BCSR.
    
    The support was successfully tested using serial and ethernet gadget
    drivers.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
index 67e2184f4243..30394b409b3f 100644
--- a/arch/powerpc/platforms/82xx/mpc8272_ads.c
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -99,6 +99,15 @@ static struct cpm_pin mpc8272_ads_pins[] = {
 	/* I2C */
 	{3, 14, CPM_PIN_INPUT | CPM_PIN_SECONDARY | CPM_PIN_OPENDRAIN},
 	{3, 15, CPM_PIN_INPUT | CPM_PIN_SECONDARY | CPM_PIN_OPENDRAIN},
+
+	/* USB */
+	{2, 10, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{2, 11, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{2, 20, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{2, 24, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{3, 23, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{3, 24, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{3, 25, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
 };
 
 static void __init init_ioports(void)
@@ -112,6 +121,8 @@ static void __init init_ioports(void)
 
 	cpm2_clk_setup(CPM_CLK_SCC1, CPM_BRG1, CPM_CLK_RX);
 	cpm2_clk_setup(CPM_CLK_SCC1, CPM_BRG1, CPM_CLK_TX);
+	cpm2_clk_setup(CPM_CLK_SCC3, CPM_CLK8, CPM_CLK_RX);
+	cpm2_clk_setup(CPM_CLK_SCC3, CPM_CLK8, CPM_CLK_TX);
 	cpm2_clk_setup(CPM_CLK_SCC4, CPM_BRG4, CPM_CLK_RX);
 	cpm2_clk_setup(CPM_CLK_SCC4, CPM_BRG4, CPM_CLK_TX);
 	cpm2_clk_setup(CPM_CLK_FCC1, CPM_CLK11, CPM_CLK_RX);
@@ -147,6 +158,7 @@ static void __init mpc8272_ads_setup_arch(void)
 #define BCSR1_FETH_RST		0x04000000
 #define BCSR1_RS232_EN1		0x02000000
 #define BCSR1_RS232_EN2		0x01000000
+#define BCSR3_USB_nEN		0x80000000
 #define BCSR3_FETHIEN2		0x10000000
 #define BCSR3_FETH2_RST		0x08000000
 
@@ -156,6 +168,8 @@ static void __init mpc8272_ads_setup_arch(void)
 	clrbits32(&bcsr[3], BCSR3_FETHIEN2);
 	setbits32(&bcsr[3], BCSR3_FETH2_RST);
 
+	clrbits32(&bcsr[3], BCSR3_USB_nEN);
+
 	iounmap(bcsr);
 
 	init_ioports();

commit a70e88bc78d220a506394058d48cedd1c491a256
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Wed Aug 19 03:28:10 2009 +0400

    powerpc/82xx: Fix BCSR bits for MPC8272ADS boards
    
    mpc8272_ads.c is using BCSR bits definitions from pq2ads.h, but
    according to User's Guide the bits are wrong for MPC8272ADS boards
    (I guess definitions from pq2ads should only be used for PQ2FADS
    boards).
    
    So, let's introduce our own definitions for MPC8272ADS, and don't
    include pq2ads.h.
    
    Signed-off-by: Anton Vorontsov <avorontsov@ru.mvista.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
index 8054c685d323..67e2184f4243 100644
--- a/arch/powerpc/platforms/82xx/mpc8272_ads.c
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -29,7 +29,6 @@
 #include <sysdev/fsl_soc.h>
 #include <sysdev/cpm2_pic.h>
 
-#include "pq2ads.h"
 #include "pq2.h"
 
 static void __init mpc8272_ads_pic_init(void)
@@ -144,6 +143,13 @@ static void __init mpc8272_ads_setup_arch(void)
 		return;
 	}
 
+#define BCSR1_FETHIEN		0x08000000
+#define BCSR1_FETH_RST		0x04000000
+#define BCSR1_RS232_EN1		0x02000000
+#define BCSR1_RS232_EN2		0x01000000
+#define BCSR3_FETHIEN2		0x10000000
+#define BCSR3_FETH2_RST		0x08000000
+
 	clrbits32(&bcsr[1], BCSR1_RS232_EN1 | BCSR1_RS232_EN2 | BCSR1_FETHIEN);
 	setbits32(&bcsr[1], BCSR1_FETH_RST);
 

commit a5d28c8e64ff0bc77d38d9c19c6d8163e4c0ffaa
Author: Jochen Friedrich <jochen@scram.de>
Date:   Wed Jul 2 18:06:13 2008 +0200

    powerpc/CPM: Add i2c pins to dts and board setup
    
    Initialize I2C pins on boards with CPM1/CPM2 controllers and document the
    i2c bus in booting-without-of.
    
    The boards don't have any I2C chips connected to the I2C bus, so unless
    some external chips are connected to the boards, this code is just an
    example of setting everything else up.
    
    Signed-off-by: Jochen Friedrich <jochen@scram.de>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
index 7d3018751988..8054c685d323 100644
--- a/arch/powerpc/platforms/82xx/mpc8272_ads.c
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -96,6 +96,10 @@ static struct cpm_pin mpc8272_ads_pins[] = {
 	{1, 31, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
 	{2, 16, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
 	{2, 17, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+
+	/* I2C */
+	{3, 14, CPM_PIN_INPUT | CPM_PIN_SECONDARY | CPM_PIN_OPENDRAIN},
+	{3, 15, CPM_PIN_INPUT | CPM_PIN_SECONDARY | CPM_PIN_OPENDRAIN},
 };
 
 static void __init init_ioports(void)

commit 75e89b02e338d0db27f8e5d66642c7e2ae49c326
Author: Julia Lawall <julia@diku.dk>
Date:   Mon Feb 4 23:35:00 2008 -0800

    [POWERPC] arch/powerpc/platforms/82xx: Add missing of_node_put
    
    Of_get_parent and of_find_compatible_node do a of_node_get, and thus a
    corresponding of_code_put is needed in both the error case and the normal
    return case.
    
    The problem was found using the following semantic match.
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @@
    type T,T1,T2;
    identifier E;
    statement S;
    expression x1,x2,x3;
    int ret;
    @@
    
      T E;
      ...
    * E = \(of_get_parent\|of_find_compatible_node\)(...);
      if (E == NULL) S
      ... when != of_node_put(...,(T1)E,...)
          when != if (E != NULL) { ... of_node_put(...,(T1)E,...); ...}
          when != x1 = (T1)E
          when != E = x3;
          when any
      if (...) {
        ... when != of_node_put(...,(T2)E,...)
            when != if (E != NULL) { ... of_node_put(...,(T2)E,...); ...}
            when != x2 = (T2)E
    (
    *   return;
    |
    *   return ret;
    )
      }
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Kumar Gala <galak@gate.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
index 3fce6b375dbc..7d3018751988 100644
--- a/arch/powerpc/platforms/82xx/mpc8272_ads.c
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -134,13 +134,12 @@ static void __init mpc8272_ads_setup_arch(void)
 	}
 
 	bcsr = of_iomap(np, 0);
+	of_node_put(np);
 	if (!bcsr) {
 		printk(KERN_ERR "Cannot map BCSR registers\n");
 		return;
 	}
 
-	of_node_put(np);
-
 	clrbits32(&bcsr[1], BCSR1_RS232_EN1 | BCSR1_RS232_EN2 | BCSR1_FETHIEN);
 	setbits32(&bcsr[1], BCSR1_FETH_RST);
 

commit ca956f0ea8baa6365b5e39d16373f430e12a030d
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Jan 24 22:23:24 2008 -0700

    [POWERPC] 82xx and embedded6xx: Use machine_*_initcall() hooks in platform code
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
index fd83440eb287..3fce6b375dbc 100644
--- a/arch/powerpc/platforms/82xx/mpc8272_ads.c
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -165,14 +165,11 @@ static struct of_device_id __initdata of_bus_ids[] = {
 
 static int __init declare_of_platform_devices(void)
 {
-	if (!machine_is(mpc8272_ads))
-		return 0;
-
 	/* Publish the QE devices */
 	of_platform_bus_probe(NULL, of_bus_ids, NULL);
 	return 0;
 }
-device_initcall(declare_of_platform_devices);
+machine_device_initcall(mpc8272_ads, declare_of_platform_devices);
 
 /*
  * Called very early, device-tree isn't unflattened

commit e00c5498a2a614931cbb7d88a53979d5d47594e1
Author: Scott Wood <scottwood@freescale.com>
Date:   Fri Sep 14 15:41:56 2007 -0500

    [POWERPC] mpc82xx: Update mpc8272ads, and factor out PCI and reset.
    
    1. PCI and reset are factored out into pq2.c.  I renamed them from m82xx
    to pq2 because they won't work on the Integrated Host Processor line of
    82xx chips (i.e. 8240, 8245, and such).
    
    2. The PCI PIC, which is nominally board-specific, is used on multiple
    boards, and thus is used into pq2ads-pci-pic.c.
    
    3. The new CPM binding is used.
    
    4. General cleanup.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
index 4de76dad31b2..fd83440eb287 100644
--- a/arch/powerpc/platforms/82xx/mpc8272_ads.c
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -1,9 +1,10 @@
 /*
- * MPC8272_ads setup and early boot code plus other random bits.
+ * MPC8272 ADS board support
  *
- * Author: Vitaly Bordug <vbordug@ru.mvista.com>
- * m82xx_restart fix by Wade Farnsworth <wfarnsworth@mvista.com>
+ * Copyright 2007 Freescale Semiconductor, Inc.
+ * Author: Scott Wood <scottwood@freescale.com>
  *
+ * Based on code by Vitaly Bordug <vbordug@ru.mvista.com>
  * Copyright (c) 2006 MontaVista Software, Inc.
  *
  * This program is free software; you can redistribute  it and/or modify it
@@ -12,613 +13,184 @@
  * option) any later version.
  */
 
-#include <linux/stddef.h>
-#include <linux/kernel.h>
 #include <linux/init.h>
-#include <linux/errno.h>
-#include <linux/reboot.h>
-#include <linux/pci.h>
 #include <linux/interrupt.h>
-#include <linux/kdev_t.h>
-#include <linux/major.h>
-#include <linux/console.h>
-#include <linux/delay.h>
-#include <linux/seq_file.h>
-#include <linux/root_dev.h>
-#include <linux/initrd.h>
-#include <linux/module.h>
 #include <linux/fsl_devices.h>
-#include <linux/fs_uart_pd.h>
+#include <linux/of_platform.h>
+#include <linux/io.h>
 
-#include <asm/system.h>
-#include <asm/pgtable.h>
-#include <asm/page.h>
-#include <asm/atomic.h>
-#include <asm/time.h>
-#include <asm/io.h>
-#include <asm/machdep.h>
-#include <asm/pci-bridge.h>
-#include <asm/mpc8260.h>
-#include <asm/irq.h>
-#include <mm/mmu_decl.h>
-#include <asm/prom.h>
 #include <asm/cpm2.h>
 #include <asm/udbg.h>
-#include <asm/i8259.h>
-#include <linux/fs_enet_pd.h>
+#include <asm/machdep.h>
+#include <asm/time.h>
+
+#include <platforms/82xx/pq2.h>
 
 #include <sysdev/fsl_soc.h>
 #include <sysdev/cpm2_pic.h>
 
 #include "pq2ads.h"
-
-#ifdef CONFIG_PCI
-static uint pci_clk_frq;
-static struct {
-	unsigned long *pci_int_stat_reg;
-	unsigned long *pci_int_mask_reg;
-} pci_regs;
-
-static unsigned long pci_int_base;
-static struct irq_host *pci_pic_host;
-#endif
+#include "pq2.h"
 
 static void __init mpc8272_ads_pic_init(void)
 {
-	struct device_node *np = of_find_compatible_node(NULL, "cpm-pic", "CPM2");
-	struct resource r;
-	cpm2_map_t *cpm_reg;
-
-	if (np == NULL) {
-		printk(KERN_ERR "PIC init: can not find cpm-pic node\n");
-		return;
-	}
-	if (of_address_to_resource(np, 0, &r)) {
-		printk(KERN_ERR "PIC init: invalid resource\n");
-		of_node_put(np);
+	struct device_node *np = of_find_compatible_node(NULL, NULL,
+	                                                 "fsl,cpm2-pic");
+	if (!np) {
+		printk(KERN_ERR "PIC init: can not find fsl,cpm2-pic node\n");
 		return;
 	}
+
 	cpm2_pic_init(np);
 	of_node_put(np);
 
-	/* Initialize the default interrupt mapping priorities,
-	 * in case the boot rom changed something on us.
-	 */
-	cpm_reg = (cpm2_map_t *) ioremap(get_immrbase(), sizeof(cpm2_map_t));
-	cpm_reg->im_intctl.ic_siprr = 0x05309770;
-	iounmap(cpm_reg);
-#ifdef CONFIG_PCI
 	/* Initialize stuff for the 82xx CPLD IC and install demux  */
-	m82xx_pci_init_irq();
-#endif
+	pq2ads_pci_init_irq();
 }
 
-static void init_fcc1_ioports(struct fs_platform_info *fpi)
-{
-	struct io_port *io;
-	u32 tempval;
-	cpm2_map_t *immap = ioremap(get_immrbase(), sizeof(cpm2_map_t));
-	struct device_node *np;
-	struct resource r;
-	u32 *bcsr;
-
-	np = of_find_node_by_type(NULL, "memory");
-	if (!np) {
-		printk(KERN_INFO "No memory node in device tree\n");
-		return;
-	}
-	if (of_address_to_resource(np, 1, &r)) {
-		printk(KERN_INFO "No memory reg property [1] in devicetree\n");
-		return;
-	}
-	of_node_put(np);
-	bcsr = ioremap(r.start + 4, sizeof(u32));
-	io = &immap->im_ioport;
-
-	/* Enable the PHY */
-	clrbits32(bcsr, BCSR1_FETHIEN);
-	setbits32(bcsr, BCSR1_FETH_RST);
-
-	/* FCC1 pins are on port A/C. */
-	/* Configure port A and C pins for FCC1 Ethernet. */
-
-	tempval = in_be32(&io->iop_pdira);
-	tempval &= ~PA1_DIRA0;
-	tempval |= PA1_DIRA1;
-	out_be32(&io->iop_pdira, tempval);
-
-	tempval = in_be32(&io->iop_psora);
-	tempval &= ~PA1_PSORA0;
-	tempval |= PA1_PSORA1;
-	out_be32(&io->iop_psora, tempval);
-
-	setbits32(&io->iop_ppara, PA1_DIRA0 | PA1_DIRA1);
-
-	/* Alter clocks */
-	tempval = PC_CLK(fpi->clk_tx - 8) | PC_CLK(fpi->clk_rx - 8);
-
-	clrbits32(&io->iop_psorc, tempval);
-	clrbits32(&io->iop_pdirc, tempval);
-	setbits32(&io->iop_pparc, tempval);
-
-	cpm2_clk_setup(CPM_CLK_FCC1, fpi->clk_rx, CPM_CLK_RX);
-	cpm2_clk_setup(CPM_CLK_FCC1, fpi->clk_tx, CPM_CLK_TX);
+struct cpm_pin {
+	int port, pin, flags;
+};
 
-	iounmap(bcsr);
-	iounmap(immap);
-}
+static struct cpm_pin mpc8272_ads_pins[] = {
+	/* SCC1 */
+	{3, 30, CPM_PIN_OUTPUT | CPM_PIN_SECONDARY},
+	{3, 31, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+
+	/* SCC4 */
+	{3, 21, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{3, 22, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+
+	/* FCC1 */
+	{0, 14, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{0, 15, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{0, 16, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{0, 17, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{0, 18, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{0, 19, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{0, 20, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{0, 21, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{0, 26, CPM_PIN_INPUT | CPM_PIN_SECONDARY},
+	{0, 27, CPM_PIN_INPUT | CPM_PIN_SECONDARY},
+	{0, 28, CPM_PIN_OUTPUT | CPM_PIN_SECONDARY},
+	{0, 29, CPM_PIN_OUTPUT | CPM_PIN_SECONDARY},
+	{0, 30, CPM_PIN_INPUT | CPM_PIN_SECONDARY},
+	{0, 31, CPM_PIN_INPUT | CPM_PIN_SECONDARY},
+	{2, 21, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{2, 22, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+
+	/* FCC2 */
+	{1, 18, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 19, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 20, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 21, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 22, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 23, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 24, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 25, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{1, 26, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 27, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 28, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 29, CPM_PIN_OUTPUT | CPM_PIN_SECONDARY},
+	{1, 30, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{1, 31, CPM_PIN_OUTPUT | CPM_PIN_PRIMARY},
+	{2, 16, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+	{2, 17, CPM_PIN_INPUT | CPM_PIN_PRIMARY},
+};
 
-static void init_fcc2_ioports(struct fs_platform_info *fpi)
+static void __init init_ioports(void)
 {
-	cpm2_map_t *immap = ioremap(get_immrbase(), sizeof(cpm2_map_t));
-	struct device_node *np;
-	struct resource r;
-	u32 *bcsr;
-
-	struct io_port *io;
-	u32 tempval;
-
-	np = of_find_node_by_type(NULL, "memory");
-	if (!np) {
-		printk(KERN_INFO "No memory node in device tree\n");
-		return;
-	}
-	if (of_address_to_resource(np, 1, &r)) {
-		printk(KERN_INFO "No memory reg property [1] in devicetree\n");
-		return;
-	}
-	of_node_put(np);
-	io = &immap->im_ioport;
-	bcsr = ioremap(r.start + 12, sizeof(u32));
-
-	/* Enable the PHY */
-	clrbits32(bcsr, BCSR3_FETHIEN2);
-	setbits32(bcsr, BCSR3_FETH2_RST);
-
-	/* FCC2 are port B/C. */
-	/* Configure port A and C pins for FCC2 Ethernet. */
-
-	tempval = in_be32(&io->iop_pdirb);
-	tempval &= ~PB2_DIRB0;
-	tempval |= PB2_DIRB1;
-	out_be32(&io->iop_pdirb, tempval);
-
-	tempval = in_be32(&io->iop_psorb);
-	tempval &= ~PB2_PSORB0;
-	tempval |= PB2_PSORB1;
-	out_be32(&io->iop_psorb, tempval);
-
-	setbits32(&io->iop_pparb, PB2_DIRB0 | PB2_DIRB1);
-
-	tempval = PC_CLK(fpi->clk_tx - 8) | PC_CLK(fpi->clk_rx - 8);
-
-	/* Alter clocks */
-	clrbits32(&io->iop_psorc, tempval);
-	clrbits32(&io->iop_pdirc, tempval);
-	setbits32(&io->iop_pparc, tempval);
-
-	cpm2_clk_setup(CPM_CLK_FCC2, fpi->clk_rx, CPM_CLK_RX);
-	cpm2_clk_setup(CPM_CLK_FCC2, fpi->clk_tx, CPM_CLK_TX);
-
-	iounmap(bcsr);
-	iounmap(immap);
-}
+	int i;
 
-void init_fcc_ioports(struct fs_platform_info *fpi)
-{
-	int fcc_no = fs_get_fcc_index(fpi->fs_no);
-
-	switch (fcc_no) {
-	case 0:
-		init_fcc1_ioports(fpi);
-		break;
-	case 1:
-		init_fcc2_ioports(fpi);
-		break;
-	default:
-		printk(KERN_ERR "init_fcc_ioports: invalid FCC number\n");
-		return;
+	for (i = 0; i < ARRAY_SIZE(mpc8272_ads_pins); i++) {
+		struct cpm_pin *pin = &mpc8272_ads_pins[i];
+		cpm2_set_pin(pin->port, pin->pin, pin->flags);
 	}
-}
 
-static void init_scc1_uart_ioports(struct fs_uart_platform_info *data)
-{
-	cpm2_map_t *immap = ioremap(get_immrbase(), sizeof(cpm2_map_t));
-
-	/* SCC1 is only on port D */
-	setbits32(&immap->im_ioport.iop_ppard, 0x00000003);
-	clrbits32(&immap->im_ioport.iop_psord, 0x00000001);
-	setbits32(&immap->im_ioport.iop_psord, 0x00000002);
-	clrbits32(&immap->im_ioport.iop_pdird, 0x00000001);
-	setbits32(&immap->im_ioport.iop_pdird, 0x00000002);
-
-	clrbits32(&immap->im_cpmux.cmx_scr, (0x00000007 << (4 - data->clk_tx)));
-	clrbits32(&immap->im_cpmux.cmx_scr, (0x00000038 << (4 - data->clk_rx)));
-	setbits32(&immap->im_cpmux.cmx_scr,
-		  ((data->clk_tx - 1) << (4 - data->clk_tx)));
-	setbits32(&immap->im_cpmux.cmx_scr,
-		  ((data->clk_rx - 1) << (4 - data->clk_rx)));
-
-	iounmap(immap);
+	cpm2_clk_setup(CPM_CLK_SCC1, CPM_BRG1, CPM_CLK_RX);
+	cpm2_clk_setup(CPM_CLK_SCC1, CPM_BRG1, CPM_CLK_TX);
+	cpm2_clk_setup(CPM_CLK_SCC4, CPM_BRG4, CPM_CLK_RX);
+	cpm2_clk_setup(CPM_CLK_SCC4, CPM_BRG4, CPM_CLK_TX);
+	cpm2_clk_setup(CPM_CLK_FCC1, CPM_CLK11, CPM_CLK_RX);
+	cpm2_clk_setup(CPM_CLK_FCC1, CPM_CLK10, CPM_CLK_TX);
+	cpm2_clk_setup(CPM_CLK_FCC2, CPM_CLK15, CPM_CLK_RX);
+	cpm2_clk_setup(CPM_CLK_FCC2, CPM_CLK16, CPM_CLK_TX);
 }
 
-static void init_scc4_uart_ioports(struct fs_uart_platform_info *data)
+static void __init mpc8272_ads_setup_arch(void)
 {
-	cpm2_map_t *immap = ioremap(get_immrbase(), sizeof(cpm2_map_t));
-
-	setbits32(&immap->im_ioport.iop_ppard, 0x00000600);
-	clrbits32(&immap->im_ioport.iop_psord, 0x00000600);
-	clrbits32(&immap->im_ioport.iop_pdird, 0x00000200);
-	setbits32(&immap->im_ioport.iop_pdird, 0x00000400);
-
-	clrbits32(&immap->im_cpmux.cmx_scr, (0x00000007 << (4 - data->clk_tx)));
-	clrbits32(&immap->im_cpmux.cmx_scr, (0x00000038 << (4 - data->clk_rx)));
-	setbits32(&immap->im_cpmux.cmx_scr,
-		  ((data->clk_tx - 1) << (4 - data->clk_tx)));
-	setbits32(&immap->im_cpmux.cmx_scr,
-		  ((data->clk_rx - 1) << (4 - data->clk_rx)));
-
-	iounmap(immap);
-}
+	struct device_node *np;
+	__be32 __iomem *bcsr;
 
-void init_scc_ioports(struct fs_uart_platform_info *data)
-{
-	int scc_no = fs_get_scc_index(data->fs_no);
-
-	switch (scc_no) {
-	case 0:
-		init_scc1_uart_ioports(data);
-		data->brg = data->clk_rx;
-		break;
-	case 3:
-		init_scc4_uart_ioports(data);
-		data->brg = data->clk_rx;
-		break;
-	default:
-		printk(KERN_ERR "init_scc_ioports: invalid SCC number\n");
-		return;
-	}
-}
+	if (ppc_md.progress)
+		ppc_md.progress("mpc8272_ads_setup_arch()", 0);
 
-void __init m82xx_board_setup(void)
-{
-	cpm2_map_t *immap = ioremap(get_immrbase(), sizeof(cpm2_map_t));
-	struct device_node *np;
-	struct resource r;
-	u32 *bcsr;
+	cpm2_reset();
 
-	np = of_find_node_by_type(NULL, "memory");
+	np = of_find_compatible_node(NULL, NULL, "fsl,mpc8272ads-bcsr");
 	if (!np) {
-		printk(KERN_INFO "No memory node in device tree\n");
+		printk(KERN_ERR "No bcsr in device tree\n");
 		return;
 	}
-	if (of_address_to_resource(np, 1, &r)) {
-		printk(KERN_INFO "No memory reg property [1] in devicetree\n");
+
+	bcsr = of_iomap(np, 0);
+	if (!bcsr) {
+		printk(KERN_ERR "Cannot map BCSR registers\n");
 		return;
 	}
-	of_node_put(np);
-	bcsr = ioremap(r.start + 4, sizeof(u32));
-	/* Enable the 2nd UART port */
-	clrbits32(bcsr, BCSR1_RS232_EN2);
-
-#ifdef CONFIG_SERIAL_CPM_SCC1
-	clrbits32((u32 *) & immap->im_scc[0].scc_sccm,
-		  UART_SCCM_TX | UART_SCCM_RX);
-	clrbits32((u32 *) & immap->im_scc[0].scc_gsmrl,
-		  SCC_GSMRL_ENR | SCC_GSMRL_ENT);
-#endif
-
-#ifdef CONFIG_SERIAL_CPM_SCC2
-	clrbits32((u32 *) & immap->im_scc[1].scc_sccm,
-		  UART_SCCM_TX | UART_SCCM_RX);
-	clrbits32((u32 *) & immap->im_scc[1].scc_gsmrl,
-		  SCC_GSMRL_ENR | SCC_GSMRL_ENT);
-#endif
-
-#ifdef CONFIG_SERIAL_CPM_SCC3
-	clrbits32((u32 *) & immap->im_scc[2].scc_sccm,
-		  UART_SCCM_TX | UART_SCCM_RX);
-	clrbits32((u32 *) & immap->im_scc[2].scc_gsmrl,
-		  SCC_GSMRL_ENR | SCC_GSMRL_ENT);
-#endif
-
-#ifdef CONFIG_SERIAL_CPM_SCC4
-	clrbits32((u32 *) & immap->im_scc[3].scc_sccm,
-		  UART_SCCM_TX | UART_SCCM_RX);
-	clrbits32((u32 *) & immap->im_scc[3].scc_gsmrl,
-		  SCC_GSMRL_ENR | SCC_GSMRL_ENT);
-#endif
-
-	iounmap(bcsr);
-	iounmap(immap);
-}
-
-#ifdef CONFIG_PCI
-static void m82xx_pci_mask_irq(unsigned int irq)
-{
-	int bit = irq - pci_int_base;
 
-	*pci_regs.pci_int_mask_reg |= (1 << (31 - bit));
-	return;
-}
+	of_node_put(np);
 
-static void m82xx_pci_unmask_irq(unsigned int irq)
-{
-	int bit = irq - pci_int_base;
+	clrbits32(&bcsr[1], BCSR1_RS232_EN1 | BCSR1_RS232_EN2 | BCSR1_FETHIEN);
+	setbits32(&bcsr[1], BCSR1_FETH_RST);
 
-	*pci_regs.pci_int_mask_reg &= ~(1 << (31 - bit));
-	return;
-}
+	clrbits32(&bcsr[3], BCSR3_FETHIEN2);
+	setbits32(&bcsr[3], BCSR3_FETH2_RST);
 
-static void m82xx_pci_mask_and_ack(unsigned int irq)
-{
-	int bit = irq - pci_int_base;
-
-	*pci_regs.pci_int_mask_reg |= (1 << (31 - bit));
-	return;
-}
+	iounmap(bcsr);
 
-static void m82xx_pci_end_irq(unsigned int irq)
-{
-	int bit = irq - pci_int_base;
+	init_ioports();
+	pq2_init_pci();
 
-	*pci_regs.pci_int_mask_reg &= ~(1 << (31 - bit));
-	return;
+	if (ppc_md.progress)
+		ppc_md.progress("mpc8272_ads_setup_arch(), finish", 0);
 }
 
-struct hw_interrupt_type m82xx_pci_ic = {
-	.typename = "MPC82xx ADS PCI",
-	.name = "MPC82xx ADS PCI",
-	.enable = m82xx_pci_unmask_irq,
-	.disable = m82xx_pci_mask_irq,
-	.ack = m82xx_pci_mask_and_ack,
-	.end = m82xx_pci_end_irq,
-	.mask = m82xx_pci_mask_irq,
-	.mask_ack = m82xx_pci_mask_and_ack,
-	.unmask = m82xx_pci_unmask_irq,
-	.eoi = m82xx_pci_end_irq,
+static struct of_device_id __initdata of_bus_ids[] = {
+	{ .name = "soc", },
+	{ .name = "cpm", },
+	{ .name = "localbus", },
+	{},
 };
 
-static void
-m82xx_pci_irq_demux(unsigned int irq, struct irq_desc *desc)
+static int __init declare_of_platform_devices(void)
 {
-	unsigned long stat, mask, pend;
-	int bit;
-
-	for (;;) {
-		stat = *pci_regs.pci_int_stat_reg;
-		mask = *pci_regs.pci_int_mask_reg;
-		pend = stat & ~mask & 0xf0000000;
-		if (!pend)
-			break;
-		for (bit = 0; pend != 0; ++bit, pend <<= 1) {
-			if (pend & 0x80000000)
-				__do_IRQ(pci_int_base + bit);
-		}
-	}
-}
+	if (!machine_is(mpc8272_ads))
+		return 0;
 
-static int pci_pic_host_map(struct irq_host *h, unsigned int virq,
-			    irq_hw_number_t hw)
-{
-	get_irq_desc(virq)->status |= IRQ_LEVEL;
-	set_irq_chip(virq, &m82xx_pci_ic);
+	/* Publish the QE devices */
+	of_platform_bus_probe(NULL, of_bus_ids, NULL);
 	return 0;
 }
-
-static void pci_host_unmap(struct irq_host *h, unsigned int virq)
-{
-	/* remove chip and handler */
-	set_irq_chip(virq, NULL);
-}
-
-static struct irq_host_ops pci_pic_host_ops = {
-	.map = pci_pic_host_map,
-	.unmap = pci_host_unmap,
-};
-
-void m82xx_pci_init_irq(void)
-{
-	int irq;
-	cpm2_map_t *immap;
-	struct device_node *np;
-	struct resource r;
-	const u32 *regs;
-	unsigned int size;
-	const u32 *irq_map;
-	int i;
-	unsigned int irq_max, irq_min;
-
-	if ((np = of_find_node_by_type(NULL, "soc")) == NULL) {
-		printk(KERN_INFO "No SOC node in device tree\n");
-		return;
-	}
-	memset(&r, 0, sizeof(r));
-	if (of_address_to_resource(np, 0, &r)) {
-		printk(KERN_INFO "No SOC reg property in device tree\n");
-		return;
-	}
-	immap = ioremap(r.start, sizeof(*immap));
-	of_node_put(np);
-
-	/* install the demultiplexer for the PCI cascade interrupt */
-	np = of_find_node_by_type(NULL, "pci");
-	if (!np) {
-		printk(KERN_INFO "No pci node on device tree\n");
-		iounmap(immap);
-		return;
-	}
-	irq_map = of_get_property(np, "interrupt-map", &size);
-	if ((!irq_map) || (size <= 7)) {
-		printk(KERN_INFO "No interrupt-map property of pci node\n");
-		iounmap(immap);
-		return;
-	}
-	size /= sizeof(irq_map[0]);
-	for (i = 0, irq_max = 0, irq_min = 512; i < size; i += 7, irq_map += 7) {
-		if (irq_map[5] < irq_min)
-			irq_min = irq_map[5];
-		if (irq_map[5] > irq_max)
-			irq_max = irq_map[5];
-	}
-	pci_int_base = irq_min;
-	irq = irq_of_parse_and_map(np, 0);
-	set_irq_chained_handler(irq, m82xx_pci_irq_demux);
-	of_node_put(np);
-	np = of_find_node_by_type(NULL, "pci-pic");
-	if (!np) {
-		printk(KERN_INFO "No pci pic node on device tree\n");
-		iounmap(immap);
-		return;
-	}
-	/* PCI interrupt controller registers: status and mask */
-	regs = of_get_property(np, "reg", &size);
-	if ((!regs) || (size <= 2)) {
-		printk(KERN_INFO "No reg property in pci pic node\n");
-		iounmap(immap);
-		return;
-	}
-	pci_regs.pci_int_stat_reg =
-	    ioremap(regs[0], sizeof(*pci_regs.pci_int_stat_reg));
-	pci_regs.pci_int_mask_reg =
-	    ioremap(regs[1], sizeof(*pci_regs.pci_int_mask_reg));
-	/* configure chip select for PCI interrupt controller */
-	immap->im_memctl.memc_br3 = regs[0] | 0x00001801;
-	immap->im_memctl.memc_or3 = 0xffff8010;
-	/* make PCI IRQ level sensitive */
-	immap->im_intctl.ic_siexr &= ~(1 << (14 - (irq - SIU_INT_IRQ1)));
-
-	/* mask all PCI interrupts */
-	*pci_regs.pci_int_mask_reg |= 0xfff00000;
-	iounmap(immap);
-	pci_pic_host =
-	    irq_alloc_host(np, IRQ_HOST_MAP_LINEAR, irq_max - irq_min + 1,
-			   &pci_pic_host_ops, irq_max + 1);
-	return;
-}
-
-static int m82xx_pci_exclude_device(struct pci_controller *hose,
-				    u_char bus, u_char devfn)
-{
-	if (bus == 0 && PCI_SLOT(devfn) == 0)
-		return PCIBIOS_DEVICE_NOT_FOUND;
-	else
-		return PCIBIOS_SUCCESSFUL;
-}
-
-static void __init mpc82xx_add_bridge(struct device_node *np)
-{
-	int len;
-	struct pci_controller *hose;
-	struct resource r;
-	const int *bus_range;
-	const uint *ptr;
-
-	memset(&r, 0, sizeof(r));
-	if (of_address_to_resource(np, 0, &r)) {
-		printk(KERN_INFO "No PCI reg property in device tree\n");
-		return;
-	}
-	if (!(ptr = of_get_property(np, "clock-frequency", NULL))) {
-		printk(KERN_INFO "No clock-frequency property in PCI node");
-		return;
-	}
-	pci_clk_frq = *ptr;
-	of_node_put(np);
-	bus_range = of_get_property(np, "bus-range", &len);
-	if (bus_range == NULL || len < 2 * sizeof(int)) {
-		printk(KERN_WARNING "Can't get bus-range for %s, assume"
-		       " bus 0\n", np->full_name);
-	}
-
-	pci_assign_all_buses = 1;
-
-	hose = pcibios_alloc_controller(np);
-
-	if (!hose)
-		return;
-
-	hose->first_busno = bus_range ? bus_range[0] : 0;
-	hose->last_busno = bus_range ? bus_range[1] : 0xff;
-
-	setup_indirect_pci(hose,
-			   r.start + offsetof(pci_cpm2_t, pci_cfg_addr),
-			   r.start + offsetof(pci_cpm2_t, pci_cfg_data),
-			   0);
-
-	pci_process_bridge_OF_ranges(hose, np, 1);
-}
-#endif
-
-/*
- * Setup the architecture
- */
-static void __init mpc8272_ads_setup_arch(void)
-{
-#ifdef CONFIG_PCI
-	struct device_node *np;
-#endif
-
-	if (ppc_md.progress)
-		ppc_md.progress("mpc8272_ads_setup_arch()", 0);
-	cpm2_reset();
-
-	/* Map I/O region to a 256MB BAT */
-
-	m82xx_board_setup();
-
-#ifdef CONFIG_PCI
-	ppc_md.pci_exclude_device = m82xx_pci_exclude_device;
-	for (np = NULL; (np = of_find_node_by_type(np, "pci")) != NULL;)
-		mpc82xx_add_bridge(np);
-
-	of_node_put(np);
-#endif
-
-#ifdef  CONFIG_ROOT_NFS
-	ROOT_DEV = Root_NFS;
-#else
-	ROOT_DEV = Root_HDA1;
-#endif
-
-	if (ppc_md.progress)
-		ppc_md.progress("mpc8272_ads_setup_arch(), finish", 0);
-}
+device_initcall(declare_of_platform_devices);
 
 /*
  * Called very early, device-tree isn't unflattened
  */
 static int __init mpc8272_ads_probe(void)
 {
-	/* We always match for now, eventually we should look at
-	 * the flat dev tree to ensure this is the board we are
-	 * supposed to run on
-	 */
-	return 1;
-}
-
-#define RMR_CSRE 0x00000001
-static void m82xx_restart(char *cmd)
-{
-	__volatile__ unsigned char dummy;
-
-	local_irq_disable();
-	((cpm2_map_t *) cpm2_immr)->im_clkrst.car_rmr |= RMR_CSRE;
-
-	/* Clear the ME,EE,IR & DR bits in MSR to cause checkstop */
-	mtmsr(mfmsr() & ~(MSR_ME | MSR_EE | MSR_IR | MSR_DR));
-	dummy = ((cpm2_map_t *) cpm2_immr)->im_clkrst.res[0];
-	printk("Restart failed\n");
-	while (1) ;
+	unsigned long root = of_get_flat_dt_root();
+	return of_flat_dt_is_compatible(root, "fsl,mpc8272ads");
 }
 
 define_machine(mpc8272_ads)
 {
- 	.name = "MPC8272 ADS",
- 	.probe = mpc8272_ads_probe,
- 	.setup_arch = mpc8272_ads_setup_arch,
- 	.init_IRQ = mpc8272_ads_pic_init,
- 	.get_irq = cpm2_get_irq,
+	.name = "Freescale MPC8272 ADS",
+	.probe = mpc8272_ads_probe,
+	.setup_arch = mpc8272_ads_setup_arch,
+	.init_IRQ = mpc8272_ads_pic_init,
+	.get_irq = cpm2_get_irq,
 	.calibrate_decr = generic_calibrate_decr,
-	.restart = m82xx_restart,
+	.restart = pq2_restart,
+	.progress = udbg_progress,
 };

commit 2d2294ae12827a97c9daa253f1ce99e7ae3195d7
Author: Scott Wood <scottwood@freescale.com>
Date:   Thu Jul 26 13:52:28 2007 -0500

    [POWERPC] mpc8272ads: Change references from 82xx_ADS to 8272_ADS.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
index 5f538d5e7fdb..4de76dad31b2 100644
--- a/arch/powerpc/platforms/82xx/mpc8272_ads.c
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -1,5 +1,5 @@
 /*
- * MPC82xx_ads setup and early boot code plus other random bits.
+ * MPC8272_ads setup and early boot code plus other random bits.
  *
  * Author: Vitaly Bordug <vbordug@ru.mvista.com>
  * m82xx_restart fix by Wade Farnsworth <wfarnsworth@mvista.com>
@@ -63,7 +63,7 @@ static unsigned long pci_int_base;
 static struct irq_host *pci_pic_host;
 #endif
 
-static void __init mpc82xx_ads_pic_init(void)
+static void __init mpc8272_ads_pic_init(void)
 {
 	struct device_node *np = of_find_compatible_node(NULL, "cpm-pic", "CPM2");
 	struct resource r;
@@ -553,14 +553,14 @@ static void __init mpc82xx_add_bridge(struct device_node *np)
 /*
  * Setup the architecture
  */
-static void __init mpc82xx_ads_setup_arch(void)
+static void __init mpc8272_ads_setup_arch(void)
 {
 #ifdef CONFIG_PCI
 	struct device_node *np;
 #endif
 
 	if (ppc_md.progress)
-		ppc_md.progress("mpc82xx_ads_setup_arch()", 0);
+		ppc_md.progress("mpc8272_ads_setup_arch()", 0);
 	cpm2_reset();
 
 	/* Map I/O region to a 256MB BAT */
@@ -582,13 +582,13 @@ static void __init mpc82xx_ads_setup_arch(void)
 #endif
 
 	if (ppc_md.progress)
-		ppc_md.progress("mpc82xx_ads_setup_arch(), finish", 0);
+		ppc_md.progress("mpc8272_ads_setup_arch(), finish", 0);
 }
 
 /*
  * Called very early, device-tree isn't unflattened
  */
-static int __init mpc82xx_ads_probe(void)
+static int __init mpc8272_ads_probe(void)
 {
 	/* We always match for now, eventually we should look at
 	 * the flat dev tree to ensure this is the board we are
@@ -612,13 +612,13 @@ static void m82xx_restart(char *cmd)
 	while (1) ;
 }
 
-define_machine(mpc82xx_ads)
+define_machine(mpc8272_ads)
 {
-	.name = "MPC82xx ADS",
-	.probe = mpc82xx_ads_probe,
-	.setup_arch =    mpc82xx_ads_setup_arch,
-	.init_IRQ =    mpc82xx_ads_pic_init,
-	.get_irq =    cpm2_get_irq,
+ 	.name = "MPC8272 ADS",
+ 	.probe = mpc8272_ads_probe,
+ 	.setup_arch = mpc8272_ads_setup_arch,
+ 	.init_IRQ = mpc8272_ads_pic_init,
+ 	.get_irq = cpm2_get_irq,
 	.calibrate_decr = generic_calibrate_decr,
 	.restart = m82xx_restart,
 };

commit d1df447197b11e70d451786be8aebf2f8606754e
Author: Scott Wood <scottwood@freescale.com>
Date:   Thu Jul 26 13:51:42 2007 -0500

    [POWERPC] mpc82xx: Rename mpc82xx_ads to mpc8272_ads.
    
    This is just a rename patch; internal references to mpc82xx_ads will be
    changed in the next one.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/platforms/82xx/mpc8272_ads.c b/arch/powerpc/platforms/82xx/mpc8272_ads.c
new file mode 100644
index 000000000000..5f538d5e7fdb
--- /dev/null
+++ b/arch/powerpc/platforms/82xx/mpc8272_ads.c
@@ -0,0 +1,624 @@
+/*
+ * MPC82xx_ads setup and early boot code plus other random bits.
+ *
+ * Author: Vitaly Bordug <vbordug@ru.mvista.com>
+ * m82xx_restart fix by Wade Farnsworth <wfarnsworth@mvista.com>
+ *
+ * Copyright (c) 2006 MontaVista Software, Inc.
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ */
+
+#include <linux/stddef.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/reboot.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/console.h>
+#include <linux/delay.h>
+#include <linux/seq_file.h>
+#include <linux/root_dev.h>
+#include <linux/initrd.h>
+#include <linux/module.h>
+#include <linux/fsl_devices.h>
+#include <linux/fs_uart_pd.h>
+
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/page.h>
+#include <asm/atomic.h>
+#include <asm/time.h>
+#include <asm/io.h>
+#include <asm/machdep.h>
+#include <asm/pci-bridge.h>
+#include <asm/mpc8260.h>
+#include <asm/irq.h>
+#include <mm/mmu_decl.h>
+#include <asm/prom.h>
+#include <asm/cpm2.h>
+#include <asm/udbg.h>
+#include <asm/i8259.h>
+#include <linux/fs_enet_pd.h>
+
+#include <sysdev/fsl_soc.h>
+#include <sysdev/cpm2_pic.h>
+
+#include "pq2ads.h"
+
+#ifdef CONFIG_PCI
+static uint pci_clk_frq;
+static struct {
+	unsigned long *pci_int_stat_reg;
+	unsigned long *pci_int_mask_reg;
+} pci_regs;
+
+static unsigned long pci_int_base;
+static struct irq_host *pci_pic_host;
+#endif
+
+static void __init mpc82xx_ads_pic_init(void)
+{
+	struct device_node *np = of_find_compatible_node(NULL, "cpm-pic", "CPM2");
+	struct resource r;
+	cpm2_map_t *cpm_reg;
+
+	if (np == NULL) {
+		printk(KERN_ERR "PIC init: can not find cpm-pic node\n");
+		return;
+	}
+	if (of_address_to_resource(np, 0, &r)) {
+		printk(KERN_ERR "PIC init: invalid resource\n");
+		of_node_put(np);
+		return;
+	}
+	cpm2_pic_init(np);
+	of_node_put(np);
+
+	/* Initialize the default interrupt mapping priorities,
+	 * in case the boot rom changed something on us.
+	 */
+	cpm_reg = (cpm2_map_t *) ioremap(get_immrbase(), sizeof(cpm2_map_t));
+	cpm_reg->im_intctl.ic_siprr = 0x05309770;
+	iounmap(cpm_reg);
+#ifdef CONFIG_PCI
+	/* Initialize stuff for the 82xx CPLD IC and install demux  */
+	m82xx_pci_init_irq();
+#endif
+}
+
+static void init_fcc1_ioports(struct fs_platform_info *fpi)
+{
+	struct io_port *io;
+	u32 tempval;
+	cpm2_map_t *immap = ioremap(get_immrbase(), sizeof(cpm2_map_t));
+	struct device_node *np;
+	struct resource r;
+	u32 *bcsr;
+
+	np = of_find_node_by_type(NULL, "memory");
+	if (!np) {
+		printk(KERN_INFO "No memory node in device tree\n");
+		return;
+	}
+	if (of_address_to_resource(np, 1, &r)) {
+		printk(KERN_INFO "No memory reg property [1] in devicetree\n");
+		return;
+	}
+	of_node_put(np);
+	bcsr = ioremap(r.start + 4, sizeof(u32));
+	io = &immap->im_ioport;
+
+	/* Enable the PHY */
+	clrbits32(bcsr, BCSR1_FETHIEN);
+	setbits32(bcsr, BCSR1_FETH_RST);
+
+	/* FCC1 pins are on port A/C. */
+	/* Configure port A and C pins for FCC1 Ethernet. */
+
+	tempval = in_be32(&io->iop_pdira);
+	tempval &= ~PA1_DIRA0;
+	tempval |= PA1_DIRA1;
+	out_be32(&io->iop_pdira, tempval);
+
+	tempval = in_be32(&io->iop_psora);
+	tempval &= ~PA1_PSORA0;
+	tempval |= PA1_PSORA1;
+	out_be32(&io->iop_psora, tempval);
+
+	setbits32(&io->iop_ppara, PA1_DIRA0 | PA1_DIRA1);
+
+	/* Alter clocks */
+	tempval = PC_CLK(fpi->clk_tx - 8) | PC_CLK(fpi->clk_rx - 8);
+
+	clrbits32(&io->iop_psorc, tempval);
+	clrbits32(&io->iop_pdirc, tempval);
+	setbits32(&io->iop_pparc, tempval);
+
+	cpm2_clk_setup(CPM_CLK_FCC1, fpi->clk_rx, CPM_CLK_RX);
+	cpm2_clk_setup(CPM_CLK_FCC1, fpi->clk_tx, CPM_CLK_TX);
+
+	iounmap(bcsr);
+	iounmap(immap);
+}
+
+static void init_fcc2_ioports(struct fs_platform_info *fpi)
+{
+	cpm2_map_t *immap = ioremap(get_immrbase(), sizeof(cpm2_map_t));
+	struct device_node *np;
+	struct resource r;
+	u32 *bcsr;
+
+	struct io_port *io;
+	u32 tempval;
+
+	np = of_find_node_by_type(NULL, "memory");
+	if (!np) {
+		printk(KERN_INFO "No memory node in device tree\n");
+		return;
+	}
+	if (of_address_to_resource(np, 1, &r)) {
+		printk(KERN_INFO "No memory reg property [1] in devicetree\n");
+		return;
+	}
+	of_node_put(np);
+	io = &immap->im_ioport;
+	bcsr = ioremap(r.start + 12, sizeof(u32));
+
+	/* Enable the PHY */
+	clrbits32(bcsr, BCSR3_FETHIEN2);
+	setbits32(bcsr, BCSR3_FETH2_RST);
+
+	/* FCC2 are port B/C. */
+	/* Configure port A and C pins for FCC2 Ethernet. */
+
+	tempval = in_be32(&io->iop_pdirb);
+	tempval &= ~PB2_DIRB0;
+	tempval |= PB2_DIRB1;
+	out_be32(&io->iop_pdirb, tempval);
+
+	tempval = in_be32(&io->iop_psorb);
+	tempval &= ~PB2_PSORB0;
+	tempval |= PB2_PSORB1;
+	out_be32(&io->iop_psorb, tempval);
+
+	setbits32(&io->iop_pparb, PB2_DIRB0 | PB2_DIRB1);
+
+	tempval = PC_CLK(fpi->clk_tx - 8) | PC_CLK(fpi->clk_rx - 8);
+
+	/* Alter clocks */
+	clrbits32(&io->iop_psorc, tempval);
+	clrbits32(&io->iop_pdirc, tempval);
+	setbits32(&io->iop_pparc, tempval);
+
+	cpm2_clk_setup(CPM_CLK_FCC2, fpi->clk_rx, CPM_CLK_RX);
+	cpm2_clk_setup(CPM_CLK_FCC2, fpi->clk_tx, CPM_CLK_TX);
+
+	iounmap(bcsr);
+	iounmap(immap);
+}
+
+void init_fcc_ioports(struct fs_platform_info *fpi)
+{
+	int fcc_no = fs_get_fcc_index(fpi->fs_no);
+
+	switch (fcc_no) {
+	case 0:
+		init_fcc1_ioports(fpi);
+		break;
+	case 1:
+		init_fcc2_ioports(fpi);
+		break;
+	default:
+		printk(KERN_ERR "init_fcc_ioports: invalid FCC number\n");
+		return;
+	}
+}
+
+static void init_scc1_uart_ioports(struct fs_uart_platform_info *data)
+{
+	cpm2_map_t *immap = ioremap(get_immrbase(), sizeof(cpm2_map_t));
+
+	/* SCC1 is only on port D */
+	setbits32(&immap->im_ioport.iop_ppard, 0x00000003);
+	clrbits32(&immap->im_ioport.iop_psord, 0x00000001);
+	setbits32(&immap->im_ioport.iop_psord, 0x00000002);
+	clrbits32(&immap->im_ioport.iop_pdird, 0x00000001);
+	setbits32(&immap->im_ioport.iop_pdird, 0x00000002);
+
+	clrbits32(&immap->im_cpmux.cmx_scr, (0x00000007 << (4 - data->clk_tx)));
+	clrbits32(&immap->im_cpmux.cmx_scr, (0x00000038 << (4 - data->clk_rx)));
+	setbits32(&immap->im_cpmux.cmx_scr,
+		  ((data->clk_tx - 1) << (4 - data->clk_tx)));
+	setbits32(&immap->im_cpmux.cmx_scr,
+		  ((data->clk_rx - 1) << (4 - data->clk_rx)));
+
+	iounmap(immap);
+}
+
+static void init_scc4_uart_ioports(struct fs_uart_platform_info *data)
+{
+	cpm2_map_t *immap = ioremap(get_immrbase(), sizeof(cpm2_map_t));
+
+	setbits32(&immap->im_ioport.iop_ppard, 0x00000600);
+	clrbits32(&immap->im_ioport.iop_psord, 0x00000600);
+	clrbits32(&immap->im_ioport.iop_pdird, 0x00000200);
+	setbits32(&immap->im_ioport.iop_pdird, 0x00000400);
+
+	clrbits32(&immap->im_cpmux.cmx_scr, (0x00000007 << (4 - data->clk_tx)));
+	clrbits32(&immap->im_cpmux.cmx_scr, (0x00000038 << (4 - data->clk_rx)));
+	setbits32(&immap->im_cpmux.cmx_scr,
+		  ((data->clk_tx - 1) << (4 - data->clk_tx)));
+	setbits32(&immap->im_cpmux.cmx_scr,
+		  ((data->clk_rx - 1) << (4 - data->clk_rx)));
+
+	iounmap(immap);
+}
+
+void init_scc_ioports(struct fs_uart_platform_info *data)
+{
+	int scc_no = fs_get_scc_index(data->fs_no);
+
+	switch (scc_no) {
+	case 0:
+		init_scc1_uart_ioports(data);
+		data->brg = data->clk_rx;
+		break;
+	case 3:
+		init_scc4_uart_ioports(data);
+		data->brg = data->clk_rx;
+		break;
+	default:
+		printk(KERN_ERR "init_scc_ioports: invalid SCC number\n");
+		return;
+	}
+}
+
+void __init m82xx_board_setup(void)
+{
+	cpm2_map_t *immap = ioremap(get_immrbase(), sizeof(cpm2_map_t));
+	struct device_node *np;
+	struct resource r;
+	u32 *bcsr;
+
+	np = of_find_node_by_type(NULL, "memory");
+	if (!np) {
+		printk(KERN_INFO "No memory node in device tree\n");
+		return;
+	}
+	if (of_address_to_resource(np, 1, &r)) {
+		printk(KERN_INFO "No memory reg property [1] in devicetree\n");
+		return;
+	}
+	of_node_put(np);
+	bcsr = ioremap(r.start + 4, sizeof(u32));
+	/* Enable the 2nd UART port */
+	clrbits32(bcsr, BCSR1_RS232_EN2);
+
+#ifdef CONFIG_SERIAL_CPM_SCC1
+	clrbits32((u32 *) & immap->im_scc[0].scc_sccm,
+		  UART_SCCM_TX | UART_SCCM_RX);
+	clrbits32((u32 *) & immap->im_scc[0].scc_gsmrl,
+		  SCC_GSMRL_ENR | SCC_GSMRL_ENT);
+#endif
+
+#ifdef CONFIG_SERIAL_CPM_SCC2
+	clrbits32((u32 *) & immap->im_scc[1].scc_sccm,
+		  UART_SCCM_TX | UART_SCCM_RX);
+	clrbits32((u32 *) & immap->im_scc[1].scc_gsmrl,
+		  SCC_GSMRL_ENR | SCC_GSMRL_ENT);
+#endif
+
+#ifdef CONFIG_SERIAL_CPM_SCC3
+	clrbits32((u32 *) & immap->im_scc[2].scc_sccm,
+		  UART_SCCM_TX | UART_SCCM_RX);
+	clrbits32((u32 *) & immap->im_scc[2].scc_gsmrl,
+		  SCC_GSMRL_ENR | SCC_GSMRL_ENT);
+#endif
+
+#ifdef CONFIG_SERIAL_CPM_SCC4
+	clrbits32((u32 *) & immap->im_scc[3].scc_sccm,
+		  UART_SCCM_TX | UART_SCCM_RX);
+	clrbits32((u32 *) & immap->im_scc[3].scc_gsmrl,
+		  SCC_GSMRL_ENR | SCC_GSMRL_ENT);
+#endif
+
+	iounmap(bcsr);
+	iounmap(immap);
+}
+
+#ifdef CONFIG_PCI
+static void m82xx_pci_mask_irq(unsigned int irq)
+{
+	int bit = irq - pci_int_base;
+
+	*pci_regs.pci_int_mask_reg |= (1 << (31 - bit));
+	return;
+}
+
+static void m82xx_pci_unmask_irq(unsigned int irq)
+{
+	int bit = irq - pci_int_base;
+
+	*pci_regs.pci_int_mask_reg &= ~(1 << (31 - bit));
+	return;
+}
+
+static void m82xx_pci_mask_and_ack(unsigned int irq)
+{
+	int bit = irq - pci_int_base;
+
+	*pci_regs.pci_int_mask_reg |= (1 << (31 - bit));
+	return;
+}
+
+static void m82xx_pci_end_irq(unsigned int irq)
+{
+	int bit = irq - pci_int_base;
+
+	*pci_regs.pci_int_mask_reg &= ~(1 << (31 - bit));
+	return;
+}
+
+struct hw_interrupt_type m82xx_pci_ic = {
+	.typename = "MPC82xx ADS PCI",
+	.name = "MPC82xx ADS PCI",
+	.enable = m82xx_pci_unmask_irq,
+	.disable = m82xx_pci_mask_irq,
+	.ack = m82xx_pci_mask_and_ack,
+	.end = m82xx_pci_end_irq,
+	.mask = m82xx_pci_mask_irq,
+	.mask_ack = m82xx_pci_mask_and_ack,
+	.unmask = m82xx_pci_unmask_irq,
+	.eoi = m82xx_pci_end_irq,
+};
+
+static void
+m82xx_pci_irq_demux(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned long stat, mask, pend;
+	int bit;
+
+	for (;;) {
+		stat = *pci_regs.pci_int_stat_reg;
+		mask = *pci_regs.pci_int_mask_reg;
+		pend = stat & ~mask & 0xf0000000;
+		if (!pend)
+			break;
+		for (bit = 0; pend != 0; ++bit, pend <<= 1) {
+			if (pend & 0x80000000)
+				__do_IRQ(pci_int_base + bit);
+		}
+	}
+}
+
+static int pci_pic_host_map(struct irq_host *h, unsigned int virq,
+			    irq_hw_number_t hw)
+{
+	get_irq_desc(virq)->status |= IRQ_LEVEL;
+	set_irq_chip(virq, &m82xx_pci_ic);
+	return 0;
+}
+
+static void pci_host_unmap(struct irq_host *h, unsigned int virq)
+{
+	/* remove chip and handler */
+	set_irq_chip(virq, NULL);
+}
+
+static struct irq_host_ops pci_pic_host_ops = {
+	.map = pci_pic_host_map,
+	.unmap = pci_host_unmap,
+};
+
+void m82xx_pci_init_irq(void)
+{
+	int irq;
+	cpm2_map_t *immap;
+	struct device_node *np;
+	struct resource r;
+	const u32 *regs;
+	unsigned int size;
+	const u32 *irq_map;
+	int i;
+	unsigned int irq_max, irq_min;
+
+	if ((np = of_find_node_by_type(NULL, "soc")) == NULL) {
+		printk(KERN_INFO "No SOC node in device tree\n");
+		return;
+	}
+	memset(&r, 0, sizeof(r));
+	if (of_address_to_resource(np, 0, &r)) {
+		printk(KERN_INFO "No SOC reg property in device tree\n");
+		return;
+	}
+	immap = ioremap(r.start, sizeof(*immap));
+	of_node_put(np);
+
+	/* install the demultiplexer for the PCI cascade interrupt */
+	np = of_find_node_by_type(NULL, "pci");
+	if (!np) {
+		printk(KERN_INFO "No pci node on device tree\n");
+		iounmap(immap);
+		return;
+	}
+	irq_map = of_get_property(np, "interrupt-map", &size);
+	if ((!irq_map) || (size <= 7)) {
+		printk(KERN_INFO "No interrupt-map property of pci node\n");
+		iounmap(immap);
+		return;
+	}
+	size /= sizeof(irq_map[0]);
+	for (i = 0, irq_max = 0, irq_min = 512; i < size; i += 7, irq_map += 7) {
+		if (irq_map[5] < irq_min)
+			irq_min = irq_map[5];
+		if (irq_map[5] > irq_max)
+			irq_max = irq_map[5];
+	}
+	pci_int_base = irq_min;
+	irq = irq_of_parse_and_map(np, 0);
+	set_irq_chained_handler(irq, m82xx_pci_irq_demux);
+	of_node_put(np);
+	np = of_find_node_by_type(NULL, "pci-pic");
+	if (!np) {
+		printk(KERN_INFO "No pci pic node on device tree\n");
+		iounmap(immap);
+		return;
+	}
+	/* PCI interrupt controller registers: status and mask */
+	regs = of_get_property(np, "reg", &size);
+	if ((!regs) || (size <= 2)) {
+		printk(KERN_INFO "No reg property in pci pic node\n");
+		iounmap(immap);
+		return;
+	}
+	pci_regs.pci_int_stat_reg =
+	    ioremap(regs[0], sizeof(*pci_regs.pci_int_stat_reg));
+	pci_regs.pci_int_mask_reg =
+	    ioremap(regs[1], sizeof(*pci_regs.pci_int_mask_reg));
+	/* configure chip select for PCI interrupt controller */
+	immap->im_memctl.memc_br3 = regs[0] | 0x00001801;
+	immap->im_memctl.memc_or3 = 0xffff8010;
+	/* make PCI IRQ level sensitive */
+	immap->im_intctl.ic_siexr &= ~(1 << (14 - (irq - SIU_INT_IRQ1)));
+
+	/* mask all PCI interrupts */
+	*pci_regs.pci_int_mask_reg |= 0xfff00000;
+	iounmap(immap);
+	pci_pic_host =
+	    irq_alloc_host(np, IRQ_HOST_MAP_LINEAR, irq_max - irq_min + 1,
+			   &pci_pic_host_ops, irq_max + 1);
+	return;
+}
+
+static int m82xx_pci_exclude_device(struct pci_controller *hose,
+				    u_char bus, u_char devfn)
+{
+	if (bus == 0 && PCI_SLOT(devfn) == 0)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	else
+		return PCIBIOS_SUCCESSFUL;
+}
+
+static void __init mpc82xx_add_bridge(struct device_node *np)
+{
+	int len;
+	struct pci_controller *hose;
+	struct resource r;
+	const int *bus_range;
+	const uint *ptr;
+
+	memset(&r, 0, sizeof(r));
+	if (of_address_to_resource(np, 0, &r)) {
+		printk(KERN_INFO "No PCI reg property in device tree\n");
+		return;
+	}
+	if (!(ptr = of_get_property(np, "clock-frequency", NULL))) {
+		printk(KERN_INFO "No clock-frequency property in PCI node");
+		return;
+	}
+	pci_clk_frq = *ptr;
+	of_node_put(np);
+	bus_range = of_get_property(np, "bus-range", &len);
+	if (bus_range == NULL || len < 2 * sizeof(int)) {
+		printk(KERN_WARNING "Can't get bus-range for %s, assume"
+		       " bus 0\n", np->full_name);
+	}
+
+	pci_assign_all_buses = 1;
+
+	hose = pcibios_alloc_controller(np);
+
+	if (!hose)
+		return;
+
+	hose->first_busno = bus_range ? bus_range[0] : 0;
+	hose->last_busno = bus_range ? bus_range[1] : 0xff;
+
+	setup_indirect_pci(hose,
+			   r.start + offsetof(pci_cpm2_t, pci_cfg_addr),
+			   r.start + offsetof(pci_cpm2_t, pci_cfg_data),
+			   0);
+
+	pci_process_bridge_OF_ranges(hose, np, 1);
+}
+#endif
+
+/*
+ * Setup the architecture
+ */
+static void __init mpc82xx_ads_setup_arch(void)
+{
+#ifdef CONFIG_PCI
+	struct device_node *np;
+#endif
+
+	if (ppc_md.progress)
+		ppc_md.progress("mpc82xx_ads_setup_arch()", 0);
+	cpm2_reset();
+
+	/* Map I/O region to a 256MB BAT */
+
+	m82xx_board_setup();
+
+#ifdef CONFIG_PCI
+	ppc_md.pci_exclude_device = m82xx_pci_exclude_device;
+	for (np = NULL; (np = of_find_node_by_type(np, "pci")) != NULL;)
+		mpc82xx_add_bridge(np);
+
+	of_node_put(np);
+#endif
+
+#ifdef  CONFIG_ROOT_NFS
+	ROOT_DEV = Root_NFS;
+#else
+	ROOT_DEV = Root_HDA1;
+#endif
+
+	if (ppc_md.progress)
+		ppc_md.progress("mpc82xx_ads_setup_arch(), finish", 0);
+}
+
+/*
+ * Called very early, device-tree isn't unflattened
+ */
+static int __init mpc82xx_ads_probe(void)
+{
+	/* We always match for now, eventually we should look at
+	 * the flat dev tree to ensure this is the board we are
+	 * supposed to run on
+	 */
+	return 1;
+}
+
+#define RMR_CSRE 0x00000001
+static void m82xx_restart(char *cmd)
+{
+	__volatile__ unsigned char dummy;
+
+	local_irq_disable();
+	((cpm2_map_t *) cpm2_immr)->im_clkrst.car_rmr |= RMR_CSRE;
+
+	/* Clear the ME,EE,IR & DR bits in MSR to cause checkstop */
+	mtmsr(mfmsr() & ~(MSR_ME | MSR_EE | MSR_IR | MSR_DR));
+	dummy = ((cpm2_map_t *) cpm2_immr)->im_clkrst.res[0];
+	printk("Restart failed\n");
+	while (1) ;
+}
+
+define_machine(mpc82xx_ads)
+{
+	.name = "MPC82xx ADS",
+	.probe = mpc82xx_ads_probe,
+	.setup_arch =    mpc82xx_ads_setup_arch,
+	.init_IRQ =    mpc82xx_ads_pic_init,
+	.get_irq =    cpm2_get_irq,
+	.calibrate_decr = generic_calibrate_decr,
+	.restart = m82xx_restart,
+};
