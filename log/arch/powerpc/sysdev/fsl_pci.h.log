commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 151588530b06..1d7a41205695 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -1,13 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * MPC85xx/86xx PCI Express structure define
  *
  * Copyright 2007,2011 Freescale Semiconductor, Inc
- *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
- *
  */
 
 #ifdef __KERNEL__

commit 666db563d3d9fffcfc019e3d1a980dac47601a71
Author: Scott Wood <scottwood@freescale.com>
Date:   Thu Dec 10 13:07:12 2015 -0600

    EDAC, mpc85xx: Make mpc85xx-pci-edac a platform device
    
    Originally the mpc85xx-pci-edac driver bound directly to the PCI
    controller node.
    
    Commit
    
      905e75c46dba ("powerpc/fsl-pci: Unify pci/pcie initialization code")
    
    turned the PCI controller code into a platform device. Since we can't
    have two drivers binding to the same device, the EDAC code was changed
    to be called into as a library-style submodule. However, this doesn't
    work if the EDAC driver is built as a module.
    
    Commit
    
      8d8fcba6d1ea ("EDAC: Rip out the edac_subsys reference counting")
    
    exposed another problem with this approach -- mpc85xx_pci_err_probe()
    was being called in the same early boot phase that the PCI controller
    is initialized, rather than in the device_initcall phase that the EDAC
    layer expects. This caused a crash on boot.
    
    To fix this, the PCI controller code now creates a child platform device
    specifically for EDAC, which the mpc85xx-pci-edac driver binds to.
    
    Reported-by: Michael Ellerman <mpe@ellerman.id.au>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Daniel Axtens <dja@axtens.net>
    Cc: Doug Thompson <dougthompson@xmission.com>
    Cc: Jia Hongtao <B38951@freescale.com>
    Cc: Jiri Kosina <jkosina@suse.com>
    Cc: Kim Phillips <kim.phillips@freescale.com>
    Cc: linux-edac <linux-edac@vger.kernel.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: Masanari Iida <standby24x7@gmail.com>
    Cc: Mauro Carvalho Chehab <mchehab@osg.samsung.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Rob Herring <robh@kernel.org>
    Link: http://lkml.kernel.org/r/1449774432-18593-1-git-send-email-scottwood@freescale.com
    Signed-off-by: Borislav Petkov <bp@suse.de>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index c1cec771d5ea..151588530b06 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -130,15 +130,6 @@ void fsl_pci_assign_primary(void);
 static inline void fsl_pci_assign_primary(void) {}
 #endif
 
-#ifdef CONFIG_EDAC_MPC85XX
-int mpc85xx_pci_err_probe(struct platform_device *op);
-#else
-static inline int mpc85xx_pci_err_probe(struct platform_device *op)
-{
-	return -ENOTSUPP;
-}
-#endif
-
 #ifdef CONFIG_FSL_PCI
 extern int fsl_pci_mcheck_exception(struct pt_regs *);
 #else

commit 48b16180d0d91324e5d2423c6d53d97bbe3dcc14
Author: Wang Dongsheng <dongsheng.wang@freescale.com>
Date:   Thu Mar 20 11:19:37 2014 +0800

    fsl/pci: The new pci suspend/resume implementation
    
    If we do nothing in suspend/resume, some platform PCIe ip-block
    can't guarantee the link back to L0 state from sleep, then, when
    we read the EP device will hang. Only we send pme turnoff message
    in pci controller suspend, and send pme exit message in resume, the
    link state will be normal.
    
    When we send pme turnoff message in pci controller suspend, the
    links will into l2/l3 ready, then, host cannot communicate with
    ep device, but pci-driver will call back EP device to save them
    state. So we need to change platform_driver->suspend/resume to
    syscore->suspend/resume.
    
    So the new suspend/resume implementation, send pme turnoff message
    in suspend, and send pme exit message in resume. And add a PME handler,
    to response PME & message interrupt.
    
    Change platform_driver->suspend/resume to syscore->suspend/resume.
    pci-driver will call back EP device, to save EP state in
    pci_pm_suspend_noirq, so we need to keep the link, until
    pci_pm_suspend_noirq finish.
    
    Signed-off-by: Wang Dongsheng <dongsheng.wang@freescale.com>
    Signed-off-by: Scott Wood <scottwood@freescale.com>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 8d455df58471..c1cec771d5ea 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -32,6 +32,13 @@ struct platform_device;
 #define PIWAR_WRITE_SNOOP	0x00005000
 #define PIWAR_SZ_MASK          0x0000003f
 
+#define PEX_PMCR_PTOMR		0x1
+#define PEX_PMCR_EXL2S		0x2
+
+#define PME_DISR_EN_PTOD	0x00008000
+#define PME_DISR_EN_ENL23D	0x00002000
+#define PME_DISR_EN_EXL23D	0x00001000
+
 /* PCI/PCI Express outbound window reg */
 struct pci_outbound_window_regs {
 	__be32	potar;	/* 0x.0 - Outbound translation address register */
@@ -111,6 +118,7 @@ struct ccsr_pci {
 
 extern int fsl_add_bridge(struct platform_device *pdev, int is_primary);
 extern void fsl_pcibios_fixup_bus(struct pci_bus *bus);
+extern void fsl_pcibios_fixup_phb(struct pci_controller *phb);
 extern int mpc83xx_add_bridge(struct device_node *dev);
 u64 fsl_pci_immrbar_base(struct pci_controller *hose);
 

commit e5d0c874391a500be7643d3eef9fb07171eee129
Merge: d5adf7e2db89 d6a60fc1a818
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 12 11:29:26 2013 -0700

    Merge tag 'iommu-updates-v3.12' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu
    
    Pull IOMMU Updates from Joerg Roedel:
     "This round the updates contain:
    
       - A new driver for the Freescale PAMU IOMMU from Varun Sethi.
    
         This driver has cooked for a while and required changes to the
         IOMMU-API and infrastructure that were already merged before.
    
       - Updates for the ARM-SMMU driver from Will Deacon
    
       - Various fixes, the most important one is probably a fix from Alex
         Williamson for a memory leak in the VT-d page-table freeing code
    
      In summary not all that much.  The biggest part in the diffstat is the
      new PAMU driver"
    
    * tag 'iommu-updates-v3.12' of git://git.kernel.org/pub/scm/linux/kernel/git/joro/iommu:
      intel-iommu: Fix leaks in pagetable freeing
      iommu/amd: Fix resource leak in iommu_init_device()
      iommu/amd: Clean up unnecessary MSI/MSI-X capability find
      iommu/arm-smmu: Simplify VMID and ASID allocation
      iommu/arm-smmu: Don't use VMIDs for stage-1 translations
      iommu/arm-smmu: Tighten up global fault reporting
      iommu/arm-smmu: Remove broken big-endian check
      iommu/fsl: Remove unnecessary 'fsl-pamu' prefixes
      iommu/fsl: Fix whitespace problems noticed by git-am
      iommu/fsl: Freescale PAMU driver and iommu implementation.
      iommu/fsl: Add additional iommu attributes required by the PAMU driver.
      powerpc: Add iommu domain pointer to device archdata
      iommu/exynos: Remove dead code (set_prefbuf)

commit 695093e38c3ef63fcb43a2840ed865efa20671d5
Author: Varun Sethi <Varun.Sethi@freescale.com>
Date:   Mon Jul 15 10:20:57 2013 +0530

    iommu/fsl: Freescale PAMU driver and iommu implementation.
    
    Following is a brief description of the PAMU hardware:
    PAMU determines what action to take and whether to authorize the action on
    the basis of the memory address, a Logical IO Device Number (LIODN), and
    PAACT table (logically) indexed by LIODN and address. Hardware devices which
    need to access memory must provide an LIODN in addition to the memory address.
    
    Peripheral Access Authorization and Control Tables (PAACTs) are the primary
    data structures used by PAMU. A PAACT is a table of peripheral access
    authorization and control entries (PAACE).Each PAACE defines the range of
    I/O bus address space that is accessible by the LIOD and the associated access
    capabilities.
    
    There are two types of PAACTs: primary PAACT (PPAACT) and secondary PAACT
    (SPAACT).A given physical I/O device may be able to act as one or more
    independent logical I/O devices (LIODs). Each such logical I/O device is
    assigned an identifier called logical I/O device number (LIODN). A LIODN is
    allocated a contiguous portion of the I/O bus address space called the DSA window
    for performing DSA operations. The DSA window may optionally be divided into
    multiple sub-windows, each of which may be used to map to a region in system
    storage space. The first sub-window is referred to as the primary sub-window
    and the remaining are called secondary sub-windows.
    
    This patch provides the PAMU driver (fsl_pamu.c) and the corresponding IOMMU
    API implementation (fsl_pamu_domain.c). The PAMU hardware driver (fsl_pamu.c)
    has been derived from the work done by Ashish Kalra and Timur Tabi.
    
    [For iommu group support]
    Acked-by: Alex Williamson <alex.williamson@redhat.com>
    
    Signed-off-by: Timur Tabi <timur@tabi.org>
    Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
    Signed-off-by: Joerg Roedel <joro@8bytes.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 72b5625330e2..1e01291d060e 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -16,6 +16,11 @@
 
 struct platform_device;
 
+
+/* FSL PCI controller BRR1 register */
+#define PCI_FSL_BRR1      0xbf8
+#define PCI_FSL_BRR1_VER 0xffff
+
 #define PCIE_LTSSM	0x0404		/* PCIE Link Training and Status */
 #define PCIE_LTSSM_L0	0x16		/* L0 state */
 #define PCIE_IP_REV_2_2		0x02080202 /* PCIE IP block version Rev2.2 */

commit 4e0e3435b50285eafe5898124ce02f7577f6803a
Author: Hongtao Jia <hongtao.jia@freescale.com>
Date:   Sun Apr 28 13:20:08 2013 +0800

    powerpc/85xx: Add machine check handler to fix PCIe erratum on mpc85xx
    
    A PCIe erratum of mpc85xx may causes a core hang when a link of PCIe
    goes down. when the link goes down, Non-posted transactions issued
    via the ATMU requiring completion result in an instruction stall.
    At the same time a machine-check exception is generated to the core
    to allow further processing by the handler. We implements the handler
    which skips the instruction caused the stall.
    
    This patch depends on patch:
    powerpc/85xx: Add platform_device declaration to fsl_pci.h
    
    Signed-off-by: Zhao Chenhui <b35336@freescale.com>
    Signed-off-by: Li Yang <leoli@freescale.com>
    Signed-off-by: Liu Shuo <soniccat.liu@gmail.com>
    Signed-off-by: Jia Hongtao <hongtao.jia@freescale.com>
    Signed-off-by: Scott Wood <scottwood@freescale.com>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 72b5625330e2..defc422a375f 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -126,5 +126,11 @@ static inline int mpc85xx_pci_err_probe(struct platform_device *op)
 }
 #endif
 
+#ifdef CONFIG_FSL_PCI
+extern int fsl_pci_mcheck_exception(struct pt_regs *);
+#else
+static inline int fsl_pci_mcheck_exception(struct pt_regs *regs) {return 0; }
+#endif
+
 #endif /* __POWERPC_FSL_PCI_H */
 #endif /* __KERNEL__ */

commit c7417202569ff31c4ddc88811b30925263951da1
Author: Jia Hongtao <hongtao.jia@freescale.com>
Date:   Fri Mar 15 14:14:58 2013 +0800

    powerpc/85xx: Add platform_device declaration to fsl_pci.h
    
    mpc85xx_pci_err_probe(struct platform_device *op) need platform_device
    declaration for definition. Otherwise, it will cause compile error if any
    files including fsl_pci.h without declaration of platform_device.
    
    Signed-off-by: Jia Hongtao <hongtao.jia@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index c81bf4407b5e..72b5625330e2 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -14,6 +14,8 @@
 #ifndef __POWERPC_FSL_PCI_H
 #define __POWERPC_FSL_PCI_H
 
+struct platform_device;
+
 #define PCIE_LTSSM	0x0404		/* PCIE Link Training and Status */
 #define PCIE_LTSSM_L0	0x16		/* L0 state */
 #define PCIE_IP_REV_2_2		0x02080202 /* PCIE IP block version Rev2.2 */

commit cc6ea0dd28d450925dd43135647fcb73f171c748
Author: Roy ZANG <tie-fei.zang@freescale.com>
Date:   Fri Sep 21 04:12:52 2012 +0000

    powerpc/85xx: Add support for FSL PCIe controller v3.0
    
    The T4240 utilizes a new PCIe controller block that has some minor
    programming model differences from previous versions.
    
    The major one that impacts initialization is how we determine the link
    state.  On the 3.x controllers we have a memory mapped SoC register
    instead of a PCI config register that reports the link state.
    
    Signed-off-by: Roy Zang <tie-fei.zang@freescale.com>
    Signed-off-by: Andy Fleming <afleming@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index c495c00c8740..c81bf4407b5e 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -17,6 +17,7 @@
 #define PCIE_LTSSM	0x0404		/* PCIE Link Training and Status */
 #define PCIE_LTSSM_L0	0x16		/* L0 state */
 #define PCIE_IP_REV_2_2		0x02080202 /* PCIE IP block version Rev2.2 */
+#define PCIE_IP_REV_3_0		0x02080300 /* PCIE IP block version Rev3.0 */
 #define PIWAR_EN		0x80000000	/* Enable */
 #define PIWAR_PF		0x20000000	/* prefetch */
 #define PIWAR_TGI_LOCAL		0x00f00000	/* target - local memory */
@@ -89,6 +90,16 @@ struct ccsr_pci {
 	__be32	pex_err_cap_r1;		/* 0x.e2c - PCIE error capture register 0 */
 	__be32	pex_err_cap_r2;		/* 0x.e30 - PCIE error capture register 0 */
 	__be32	pex_err_cap_r3;		/* 0x.e34 - PCIE error capture register 0 */
+	u8	res_e38[200];
+	__be32	pdb_stat;		/* 0x.f00 - PCIE Debug Status */
+	u8	res_f04[16];
+	__be32	pex_csr0;		/* 0x.f14 - PEX Control/Status register 0*/
+#define PEX_CSR0_LTSSM_MASK	0xFC
+#define PEX_CSR0_LTSSM_SHIFT	2
+#define PEX_CSR0_LTSSM_L0	0x11
+	__be32	pex_csr1;		/* 0x.f18 - PEX Control/Status register 1*/
+	u8	res_f1c[228];
+
 };
 
 extern int fsl_add_bridge(struct platform_device *pdev, int is_primary);

commit 52c5affc545053d37c0b05224bbf70f5336caa20
Author: Varun Sethi <Varun.Sethi@freescale.com>
Date:   Mon Jan 14 16:58:00 2013 +0530

    powerpc/fsl_pci: Store the pci ctlr device ptr in the pci ctlr struct
    
    The pci controller structure has a provision to store the device structure
    pointer of the corresponding platform device. Currently this information is
    not stored during fsl pci controller initialization. This information is
    required while dealing with iommu groups for pci devices connected to the
    fsl pci controller. For the case where the pci devices can't be paritioned,
    they would fall under the same device group as the pci controller.
    
    This patch stores the platform device information in the pci controller
    structure during initialization.
    
    Signed-off-by: Varun Sethi <Varun.Sethi@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index d078537adece..c495c00c8740 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -91,7 +91,7 @@ struct ccsr_pci {
 	__be32	pex_err_cap_r3;		/* 0x.e34 - PCIE error capture register 0 */
 };
 
-extern int fsl_add_bridge(struct device_node *dev, int is_primary);
+extern int fsl_add_bridge(struct platform_device *pdev, int is_primary);
 extern void fsl_pcibios_fixup_bus(struct pci_bus *bus);
 extern int mpc83xx_add_bridge(struct device_node *dev);
 u64 fsl_pci_immrbar_base(struct pci_controller *hose);

commit 905e75c46dba5f3061049277e4eb7110beedba43
Author: Jia Hongtao <B38951@freescale.com>
Date:   Tue Aug 28 15:44:08 2012 +0800

    powerpc/fsl-pci: Unify pci/pcie initialization code
    
    We unified the Freescale pci/pcie initialization by changing the fsl_pci
    to a platform driver. In previous PCI code architecture the initialization
    routine is called at board_setup_arch stage. Now the initialization is done
    in probe function which is architectural better. Also It's convenient for
    adding PM support for PCI controller in later patch.
    
    Now we registered pci controllers as platform devices. So we combine two
    initialization code as one platform driver.
    
    Signed-off-by: Jia Hongtao <B38951@freescale.com>
    Signed-off-by: Li Yang <leoli@freescale.com>
    Signed-off-by: Chunhe Lan <Chunhe.Lan@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 54ed82c53235..d078537adece 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -98,10 +98,19 @@ u64 fsl_pci_immrbar_base(struct pci_controller *hose);
 
 extern struct device_node *fsl_pci_primary;
 
-#ifdef CONFIG_FSL_PCI
-void fsl_pci_init(void);
+#ifdef CONFIG_PCI
+void fsl_pci_assign_primary(void);
 #else
-static inline void fsl_pci_init(void) {}
+static inline void fsl_pci_assign_primary(void) {}
+#endif
+
+#ifdef CONFIG_EDAC_MPC85XX
+int mpc85xx_pci_err_probe(struct platform_device *op);
+#else
+static inline int mpc85xx_pci_err_probe(struct platform_device *op)
+{
+	return -ENOTSUPP;
+}
 #endif
 
 #endif /* __POWERPC_FSL_PCI_H */

commit 6cc1b4e931f8d8dccdcdb05b758a7d1178ad6b49
Author: Roy Zang <tie-fei.zang@freescale.com>
Date:   Mon Sep 3 17:22:09 2012 +0800

    powerpc/pci: Add IP revision register define for Freescale PCIe controller
    
    Signed-off-by: Roy Zang <tie-fei.zang@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index baa0fd18289f..54ed82c53235 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -16,6 +16,7 @@
 
 #define PCIE_LTSSM	0x0404		/* PCIE Link Training and Status */
 #define PCIE_LTSSM_L0	0x16		/* L0 state */
+#define PCIE_IP_REV_2_2		0x02080202 /* PCIE IP block version Rev2.2 */
 #define PIWAR_EN		0x80000000	/* Enable */
 #define PIWAR_PF		0x20000000	/* prefetch */
 #define PIWAR_TGI_LOCAL		0x00f00000	/* target - local memory */
@@ -57,7 +58,9 @@ struct ccsr_pci {
 	__be32	pex_pme_mes_disr;	/* 0x.024 - PCIE PME and message disable register */
 	__be32	pex_pme_mes_ier;	/* 0x.028 - PCIE PME and message interrupt enable register */
 	__be32	pex_pmcr;		/* 0x.02c - PCIE power management command register */
-	u8	res3[3024];
+	u8	res3[3016];
+	__be32	block_rev1;	/* 0x.bf8 - PCIE Block Revision register 1 */
+	__be32	block_rev2;	/* 0x.bfc - PCIE Block Revision register 2 */
 
 /* PCI/PCI Express outbound window 0-4
  * Window 0 is the default window and is the only window enabled upon reset.

commit 07e4f8014f4d3404de7cdeaba3fe307cc6eecb79
Author: Scott Wood <scottwood@freescale.com>
Date:   Tue Jul 10 19:26:47 2012 -0500

    powerpc/fsl-pci: get PCI init out of board files
    
    As an alternative incremental starting point to Jia Hongtao's patchset,
    get the FSL PCI init out of the board files, but do not yet convert to a
    platform driver.
    
    Rather than having each board supply a magic register offset for
    determining the "primary" bus, we look for which PCI host bridge
    contains an ISA node within its subtree.  If there is no ISA node,
    normally that would mean there is no primary bus, but until certain
    bugs are fixed we arbitrarily designate a primary in this case.
    
    Conversion to a platform driver and related improvements can happen
    after this, as the ordering issues are sorted out.
    
    Signed-off-by: Scott Wood <scottwood@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index a39ed5cc2c5a..baa0fd18289f 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -93,5 +93,13 @@ extern void fsl_pcibios_fixup_bus(struct pci_bus *bus);
 extern int mpc83xx_add_bridge(struct device_node *dev);
 u64 fsl_pci_immrbar_base(struct pci_controller *hose);
 
+extern struct device_node *fsl_pci_primary;
+
+#ifdef CONFIG_FSL_PCI
+void fsl_pci_init(void);
+#else
+static inline void fsl_pci_init(void) {}
+#endif
+
 #endif /* __POWERPC_FSL_PCI_H */
 #endif /* __KERNEL__ */

commit f4154e160aa2a40dccc963110768b63ce004fed9
Author: Prabhakar Kushwaha <prabhakar@freescale.com>
Date:   Thu Feb 24 15:05:04 2011 +0530

    powerpc/fsl_pci: Add support for FSL PCIe controllers v2.x
    
    FSL PCIe controller v2.1:
         - New MSI inbound window
         - Same Inbound windows address as PCIe controller v1.x
    
    Added new pit_t member(pmit) to struct ccsr_pci for MSI inbound window
    
    FSL PCIe controller v2.2 and v2.3:
         - Different addresses for PCIe inbound window 3,2,1
         - Exposed PCIe inbound window 0
         - New PCIe interrupt status register
    
    Added new config and interrupt Status register to struct ccsr_pci & updated
    pit_t array size to reflect the 4 inbound windows.
    
    Device tree is used to maintain backward compatibility i.e. update inbound
    window 1 index depending upon "compatible" field witin PCIE node.
    
    Signed-off-by: Prabhakar Kushwaha <prabhakar@freescale.com>
    Acked-by: Roy Zang <tie-fei.zang@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 8ad72a11f77b..a39ed5cc2c5a 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -1,7 +1,7 @@
 /*
  * MPC85xx/86xx PCI Express structure define
  *
- * Copyright 2007 Freescale Semiconductor, Inc
+ * Copyright 2007,2011 Freescale Semiconductor, Inc
  *
  * This program is free software; you can redistribute  it and/or modify it
  * under  the terms of  the GNU General  Public License as published by the
@@ -21,6 +21,7 @@
 #define PIWAR_TGI_LOCAL		0x00f00000	/* target - local memory */
 #define PIWAR_READ_SNOOP	0x00050000
 #define PIWAR_WRITE_SNOOP	0x00005000
+#define PIWAR_SZ_MASK          0x0000003f
 
 /* PCI/PCI Express outbound window reg */
 struct pci_outbound_window_regs {
@@ -49,7 +50,9 @@ struct ccsr_pci {
 	__be32	int_ack;		/* 0x.008 - PCI Interrupt Acknowledge Register */
 	__be32	pex_otb_cpl_tor;	/* 0x.00c - PCIE Outbound completion timeout register */
 	__be32	pex_conf_tor;		/* 0x.010 - PCIE configuration timeout register */
-	u8	res2[12];
+	__be32	pex_config;		/* 0x.014 - PCIE CONFIG Register */
+	__be32	pex_int_status;		/* 0x.018 - PCIE interrupt status */
+	u8	res2[4];
 	__be32	pex_pme_mes_dr;		/* 0x.020 - PCIE PME and message detect register */
 	__be32	pex_pme_mes_disr;	/* 0x.024 - PCIE PME and message disable register */
 	__be32	pex_pme_mes_ier;	/* 0x.028 - PCIE PME and message interrupt enable register */
@@ -62,14 +65,14 @@ struct ccsr_pci {
  * in all of the other outbound windows.
  */
 	struct pci_outbound_window_regs pow[5];
-
-	u8	res14[256];
-
-/* PCI/PCI Express inbound window 3-1
+	u8	res14[96];
+	struct pci_inbound_window_regs	pmit;	/* 0xd00 - 0xd9c Inbound MSI */
+	u8	res6[96];
+/* PCI/PCI Express inbound window 3-0
  * inbound window 1 supports only a 32-bit base address and does not
  * define an inbound window base extended address register.
  */
-	struct pci_inbound_window_regs piw[3];
+	struct pci_inbound_window_regs piw[4];
 
 	__be32	pex_err_dr;		/* 0x.e00 - PCI/PCIE error detect register */
 	u8	res21[4];

commit b8f44ec2c05f9cfe1647173ac60c0cccb1118c91
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Thu Aug 5 02:45:08 2010 -0500

    powerpc/fsl-pci: Fix MSI support on 83xx platforms
    
    The following commit broke 83xx because it assumed the 83xx platforms
    exposed the "IMMR" address in BAR0 like the 85xx/86xx/QoriQ devices do:
    
    commit 3da34aae03d498ee62f75aa7467de93cce3030fd
    Author: Kumar Gala <galak@kernel.crashing.org>
    Date:   Tue May 12 15:51:56 2009 -0500
    
        powerpc/fsl: Support unique MSI addresses per PCIe Root Complex
    
    However that is not true, so we have to search through the inbound
    window settings on 83xx to find which one matches the IMMR address to
    determine its PCI address.
    
    Reported-by: Ilya Yanok <yanok@emcraft.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index a9d8bbebed80..8ad72a11f77b 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -88,6 +88,7 @@ struct ccsr_pci {
 extern int fsl_add_bridge(struct device_node *dev, int is_primary);
 extern void fsl_pcibios_fixup_bus(struct pci_bus *bus);
 extern int mpc83xx_add_bridge(struct device_node *dev);
+u64 fsl_pci_immrbar_base(struct pci_controller *hose);
 
 #endif /* __POWERPC_FSL_PCI_H */
 #endif /* __KERNEL__ */

commit 54c181935d2a2d46a1b2f00cbb25acc35e4f5ee2
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Fri May 8 15:05:23 2009 -0500

    powerpc/fsl: Setup PCI inbound window based on actual amount of memory
    
    Previouslly we just always set the inbound window to 2G.  This was
    broken for systems with >2G.  If a system has >=4G we will need
    SWIOTLB support to handle that case.
    
    We now allocate PCICSRBAR/PEXCSRBAR right below the lowest PCI outbound
    address for MMIO or the 4G boundary (if the lowest PCI address is above
    4G).
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 13f30c2a61e7..a9d8bbebed80 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -16,7 +16,11 @@
 
 #define PCIE_LTSSM	0x0404		/* PCIE Link Training and Status */
 #define PCIE_LTSSM_L0	0x16		/* L0 state */
-#define PIWAR_2G	0xa0f5501e	/* Enable, Prefetch, Local Mem, Snoop R/W, 2G */
+#define PIWAR_EN		0x80000000	/* Enable */
+#define PIWAR_PF		0x20000000	/* prefetch */
+#define PIWAR_TGI_LOCAL		0x00f00000	/* target - local memory */
+#define PIWAR_READ_SNOOP	0x00050000
+#define PIWAR_WRITE_SNOOP	0x00005000
 
 /* PCI/PCI Express outbound window reg */
 struct pci_outbound_window_regs {

commit 76fe1ffce94067fc82d1d958f826eb9f1df53910
Author: John Rigby <jrigby@freescale.com>
Date:   Thu Jun 26 11:07:57 2008 -0600

    powerpc: Move mpc83xx_add_bridge to fsl_pci.c
    
    This allows other platforms with the same pci block like MPC5121 to use it.
    
    Signed-off-by: John Rigby <jrigby@freescale.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 37b04ad26571..13f30c2a61e7 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -83,6 +83,7 @@ struct ccsr_pci {
 
 extern int fsl_add_bridge(struct device_node *dev, int is_primary);
 extern void fsl_pcibios_fixup_bus(struct pci_bus *bus);
+extern int mpc83xx_add_bridge(struct device_node *dev);
 
 #endif /* __POWERPC_FSL_PCI_H */
 #endif /* __KERNEL__ */

commit 6c0a11c118471f79795202348fbd0e6580341794
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Thu Jul 19 15:29:53 2007 -0500

    [POWERPC] Fixup resources on pci_bus for PCIe PHB when no device is connected
    
    On the 85xx/86xx PCIe controllers if there is no device connected to the
    PHB we will still allocate a pci_bus for downstream bus of the virtual
    P2P bridge. However the resources allocated to the downstream bus are not
    correct and so we just mimic the resources from the upstream pci_bus.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 700d47827994..37b04ad26571 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -82,6 +82,7 @@ struct ccsr_pci {
 };
 
 extern int fsl_add_bridge(struct device_node *dev, int is_primary);
+extern void fsl_pcibios_fixup_bus(struct pci_bus *bus);
 
 #endif /* __POWERPC_FSL_PCI_H */
 #endif /* __KERNEL__ */

commit 9ac4dd301eebb3cd8de801e02bfc91f296e56f63
Author: Zang Roy-r61911 <tie-fei.zang@freescale.com>
Date:   Tue Jul 10 18:46:35 2007 +0800

    [POWERPC] Rewrite Freescale PCI/PCIe support for 8{3,5,6}xx
    
    Rewrite the Freescale PCI code to support PCI on 83xx/85xx/86xx and
    PCIe on 85xx/86xx.
    
    Signed-off-by: Roy Zang <tie-fei.zang@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
index 8d9779c84bea..700d47827994 100644
--- a/arch/powerpc/sysdev/fsl_pci.h
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -11,84 +11,77 @@
  */
 
 #ifdef __KERNEL__
-#ifndef __POWERPC_FSL_PCIE_H
-#define __POWERPC_FSL_PCIE_H
+#ifndef __POWERPC_FSL_PCI_H
+#define __POWERPC_FSL_PCI_H
 
-/* PCIE Express IO block registers in 85xx/86xx */
+#define PCIE_LTSSM	0x0404		/* PCIE Link Training and Status */
+#define PCIE_LTSSM_L0	0x16		/* L0 state */
+#define PIWAR_2G	0xa0f5501e	/* Enable, Prefetch, Local Mem, Snoop R/W, 2G */
 
-struct ccsr_pex {
-	__be32 __iomem    pex_config_addr;	/* 0x.000 - PCI Express Configuration Address Register */
-	__be32 __iomem    pex_config_data;	/* 0x.004 - PCI Express Configuration Data Register */
-	u8 __iomem    res1[4];
-	__be32 __iomem    pex_otb_cpl_tor;	/* 0x.00c - PCI Express Outbound completion timeout register */
-	__be32 __iomem    pex_conf_tor;		/* 0x.010 - PCI Express configuration timeout register */
-	u8 __iomem    res2[12];
-	__be32 __iomem    pex_pme_mes_dr;	/* 0x.020 - PCI Express PME and message detect register */
-	__be32 __iomem    pex_pme_mes_disr;	/* 0x.024 - PCI Express PME and message disable register */
-	__be32 __iomem    pex_pme_mes_ier;	/* 0x.028 - PCI Express PME and message interrupt enable register */
-	__be32 __iomem    pex_pmcr;		/* 0x.02c - PCI Express power management command register */
-	u8 __iomem    res3[3024];
-	__be32 __iomem    pexotar0;		/* 0x.c00 - PCI Express outbound translation address register 0 */
-	__be32 __iomem    pexotear0;		/* 0x.c04 - PCI Express outbound translation extended address register 0*/
-	u8 __iomem    res4[8];
-	__be32 __iomem    pexowar0;		/* 0x.c10 - PCI Express outbound window attributes register 0*/
-	u8 __iomem    res5[12];
-	__be32 __iomem    pexotar1;		/* 0x.c20 - PCI Express outbound translation address register 1 */
-	__be32 __iomem    pexotear1;		/* 0x.c24 - PCI Express outbound translation extended address register 1*/
-	__be32 __iomem    pexowbar1;		/* 0x.c28 - PCI Express outbound window base address register 1*/
-	u8 __iomem    res6[4];
-	__be32 __iomem    pexowar1;		/* 0x.c30 - PCI Express outbound window attributes register 1*/
-	u8 __iomem    res7[12];
-	__be32 __iomem    pexotar2;		/* 0x.c40 - PCI Express outbound translation address register 2 */
-	__be32 __iomem    pexotear2;		/* 0x.c44 - PCI Express outbound translation extended address register 2*/
-	__be32 __iomem    pexowbar2;		/* 0x.c48 - PCI Express outbound window base address register 2*/
-	u8 __iomem    res8[4];
-	__be32 __iomem    pexowar2;		/* 0x.c50 - PCI Express outbound window attributes register 2*/
-	u8 __iomem    res9[12];
-	__be32 __iomem    pexotar3;		/* 0x.c60 - PCI Express outbound translation address register 3 */
-	__be32 __iomem    pexotear3;		/* 0x.c64 - PCI Express outbound translation extended address register 3*/
-	__be32 __iomem    pexowbar3;		/* 0x.c68 - PCI Express outbound window base address register 3*/
-	u8 __iomem    res10[4];
-	__be32 __iomem    pexowar3;		/* 0x.c70 - PCI Express outbound window attributes register 3*/
-	u8 __iomem    res11[12];
-	__be32 __iomem    pexotar4;		/* 0x.c80 - PCI Express outbound translation address register 4 */
-	__be32 __iomem    pexotear4;		/* 0x.c84 - PCI Express outbound translation extended address register 4*/
-	__be32 __iomem    pexowbar4;		/* 0x.c88 - PCI Express outbound window base address register 4*/
-	u8 __iomem    res12[4];
-	__be32 __iomem    pexowar4;		/* 0x.c90 - PCI Express outbound window attributes register 4*/
-	u8 __iomem    res13[12];
-	u8 __iomem    res14[256];
-	__be32 __iomem    pexitar3;		/* 0x.da0 - PCI Express inbound translation address register 3 */
-	u8 __iomem    res15[4];
-	__be32 __iomem    pexiwbar3;		/* 0x.da8 - PCI Express inbound window base address register 3 */
-	__be32 __iomem    pexiwbear3;		/* 0x.dac - PCI Express inbound window base extended address register 3 */
-	__be32 __iomem    pexiwar3;		/* 0x.db0 - PCI Express inbound window attributes register 3 */
-	u8 __iomem    res16[12];
-	__be32 __iomem    pexitar2;		/* 0x.dc0 - PCI Express inbound translation address register 2 */
-	u8 __iomem    res17[4];
-	__be32 __iomem    pexiwbar2;		/* 0x.dc8 - PCI Express inbound window base address register 2 */
-	__be32 __iomem    pexiwbear2;		/* 0x.dcc - PCI Express inbound window base extended address register 2 */
-	__be32 __iomem    pexiwar2;		/* 0x.dd0 - PCI Express inbound window attributes register 2 */
-	u8 __iomem    res18[12];
-	__be32 __iomem    pexitar1;		/* 0x.de0 - PCI Express inbound translation address register 2 */
-	u8 __iomem    res19[4];
-	__be32 __iomem    pexiwbar1;		/* 0x.de8 - PCI Express inbound window base address register 2 */
-	__be32 __iomem    pexiwbear1;		/* 0x.dec - PCI Express inbound window base extended address register 2 */
-	__be32 __iomem    pexiwar1;		/* 0x.df0 - PCI Express inbound window attributes register 2 */
-	u8 __iomem    res20[12];
-	__be32 __iomem    pex_err_dr;		/* 0x.e00 - PCI Express error detect register */
-	u8 __iomem    res21[4];
-	__be32 __iomem    pex_err_en;		/* 0x.e08 - PCI Express error interrupt enable register */
-	u8 __iomem    res22[4];
-	__be32 __iomem    pex_err_disr;		/* 0x.e10 - PCI Express error disable register */
-	u8 __iomem    res23[12];
-	__be32 __iomem    pex_err_cap_stat;	/* 0x.e20 - PCI Express error capture status register */
-	u8 __iomem    res24[4];
-	__be32 __iomem    pex_err_cap_r0;	/* 0x.e28 - PCI Express error capture register 0 */
-	__be32 __iomem    pex_err_cap_r1;	/* 0x.e2c - PCI Express error capture register 0 */
-	__be32 __iomem    pex_err_cap_r2;	/* 0x.e30 - PCI Express error capture register 0 */
-	__be32 __iomem    pex_err_cap_r3;	/* 0x.e34 - PCI Express error capture register 0 */
+/* PCI/PCI Express outbound window reg */
+struct pci_outbound_window_regs {
+	__be32	potar;	/* 0x.0 - Outbound translation address register */
+	__be32	potear;	/* 0x.4 - Outbound translation extended address register */
+	__be32	powbar;	/* 0x.8 - Outbound window base address register */
+	u8	res1[4];
+	__be32	powar;	/* 0x.10 - Outbound window attributes register */
+	u8	res2[12];
 };
 
-#endif /* __POWERPC_FSL_PCIE_H */
+/* PCI/PCI Express inbound window reg */
+struct pci_inbound_window_regs {
+	__be32	pitar;	/* 0x.0 - Inbound translation address register */
+	u8	res1[4];
+	__be32	piwbar;	/* 0x.8 - Inbound window base address register */
+	__be32	piwbear;	/* 0x.c - Inbound window base extended address register */
+	__be32	piwar;	/* 0x.10 - Inbound window attributes register */
+	u8	res2[12];
+};
+
+/* PCI/PCI Express IO block registers for 85xx/86xx */
+struct ccsr_pci {
+	__be32	config_addr;		/* 0x.000 - PCI/PCIE Configuration Address Register */
+	__be32	config_data;		/* 0x.004 - PCI/PCIE Configuration Data Register */
+	__be32	int_ack;		/* 0x.008 - PCI Interrupt Acknowledge Register */
+	__be32	pex_otb_cpl_tor;	/* 0x.00c - PCIE Outbound completion timeout register */
+	__be32	pex_conf_tor;		/* 0x.010 - PCIE configuration timeout register */
+	u8	res2[12];
+	__be32	pex_pme_mes_dr;		/* 0x.020 - PCIE PME and message detect register */
+	__be32	pex_pme_mes_disr;	/* 0x.024 - PCIE PME and message disable register */
+	__be32	pex_pme_mes_ier;	/* 0x.028 - PCIE PME and message interrupt enable register */
+	__be32	pex_pmcr;		/* 0x.02c - PCIE power management command register */
+	u8	res3[3024];
+
+/* PCI/PCI Express outbound window 0-4
+ * Window 0 is the default window and is the only window enabled upon reset.
+ * The default outbound register set is used when a transaction misses
+ * in all of the other outbound windows.
+ */
+	struct pci_outbound_window_regs pow[5];
+
+	u8	res14[256];
+
+/* PCI/PCI Express inbound window 3-1
+ * inbound window 1 supports only a 32-bit base address and does not
+ * define an inbound window base extended address register.
+ */
+	struct pci_inbound_window_regs piw[3];
+
+	__be32	pex_err_dr;		/* 0x.e00 - PCI/PCIE error detect register */
+	u8	res21[4];
+	__be32	pex_err_en;		/* 0x.e08 - PCI/PCIE error interrupt enable register */
+	u8	res22[4];
+	__be32	pex_err_disr;		/* 0x.e10 - PCI/PCIE error disable register */
+	u8	res23[12];
+	__be32	pex_err_cap_stat;	/* 0x.e20 - PCI/PCIE error capture status register */
+	u8	res24[4];
+	__be32	pex_err_cap_r0;		/* 0x.e28 - PCIE error capture register 0 */
+	__be32	pex_err_cap_r1;		/* 0x.e2c - PCIE error capture register 0 */
+	__be32	pex_err_cap_r2;		/* 0x.e30 - PCIE error capture register 0 */
+	__be32	pex_err_cap_r3;		/* 0x.e34 - PCIE error capture register 0 */
+};
+
+extern int fsl_add_bridge(struct device_node *dev, int is_primary);
+
+#endif /* __POWERPC_FSL_PCI_H */
 #endif /* __KERNEL__ */

commit 55c44991e2910519bab274c857d95a08100ff5f7
Author: Roy Zang <tie-fei.zang@freescale.com>
Date:   Tue Jul 10 18:44:34 2007 +0800

    [POWERPC] Create common fsl pci/e files based on 86xx platforms
    
    Move
    arch/powerpc/platforms/86xx/pci.c -> arch/powerpc/sysdev/fsl_pci.c
    arch/powerpc/sysdev/fsl_pcie.h -> arch/powerpc/sysdev/fsl_pci.h
    as the base to unify 83xx/85xx/86xx pci and pcie.
    
    Add CONFIG_FSL_PCI to build fsl_pci.c for Freescale pci and pcie option.
    The code still works for 86xx platforms.
    
    Signed-off-by: Roy Zang <tie-fei.zang@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/fsl_pci.h b/arch/powerpc/sysdev/fsl_pci.h
new file mode 100644
index 000000000000..8d9779c84bea
--- /dev/null
+++ b/arch/powerpc/sysdev/fsl_pci.h
@@ -0,0 +1,94 @@
+/*
+ * MPC85xx/86xx PCI Express structure define
+ *
+ * Copyright 2007 Freescale Semiconductor, Inc
+ *
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ */
+
+#ifdef __KERNEL__
+#ifndef __POWERPC_FSL_PCIE_H
+#define __POWERPC_FSL_PCIE_H
+
+/* PCIE Express IO block registers in 85xx/86xx */
+
+struct ccsr_pex {
+	__be32 __iomem    pex_config_addr;	/* 0x.000 - PCI Express Configuration Address Register */
+	__be32 __iomem    pex_config_data;	/* 0x.004 - PCI Express Configuration Data Register */
+	u8 __iomem    res1[4];
+	__be32 __iomem    pex_otb_cpl_tor;	/* 0x.00c - PCI Express Outbound completion timeout register */
+	__be32 __iomem    pex_conf_tor;		/* 0x.010 - PCI Express configuration timeout register */
+	u8 __iomem    res2[12];
+	__be32 __iomem    pex_pme_mes_dr;	/* 0x.020 - PCI Express PME and message detect register */
+	__be32 __iomem    pex_pme_mes_disr;	/* 0x.024 - PCI Express PME and message disable register */
+	__be32 __iomem    pex_pme_mes_ier;	/* 0x.028 - PCI Express PME and message interrupt enable register */
+	__be32 __iomem    pex_pmcr;		/* 0x.02c - PCI Express power management command register */
+	u8 __iomem    res3[3024];
+	__be32 __iomem    pexotar0;		/* 0x.c00 - PCI Express outbound translation address register 0 */
+	__be32 __iomem    pexotear0;		/* 0x.c04 - PCI Express outbound translation extended address register 0*/
+	u8 __iomem    res4[8];
+	__be32 __iomem    pexowar0;		/* 0x.c10 - PCI Express outbound window attributes register 0*/
+	u8 __iomem    res5[12];
+	__be32 __iomem    pexotar1;		/* 0x.c20 - PCI Express outbound translation address register 1 */
+	__be32 __iomem    pexotear1;		/* 0x.c24 - PCI Express outbound translation extended address register 1*/
+	__be32 __iomem    pexowbar1;		/* 0x.c28 - PCI Express outbound window base address register 1*/
+	u8 __iomem    res6[4];
+	__be32 __iomem    pexowar1;		/* 0x.c30 - PCI Express outbound window attributes register 1*/
+	u8 __iomem    res7[12];
+	__be32 __iomem    pexotar2;		/* 0x.c40 - PCI Express outbound translation address register 2 */
+	__be32 __iomem    pexotear2;		/* 0x.c44 - PCI Express outbound translation extended address register 2*/
+	__be32 __iomem    pexowbar2;		/* 0x.c48 - PCI Express outbound window base address register 2*/
+	u8 __iomem    res8[4];
+	__be32 __iomem    pexowar2;		/* 0x.c50 - PCI Express outbound window attributes register 2*/
+	u8 __iomem    res9[12];
+	__be32 __iomem    pexotar3;		/* 0x.c60 - PCI Express outbound translation address register 3 */
+	__be32 __iomem    pexotear3;		/* 0x.c64 - PCI Express outbound translation extended address register 3*/
+	__be32 __iomem    pexowbar3;		/* 0x.c68 - PCI Express outbound window base address register 3*/
+	u8 __iomem    res10[4];
+	__be32 __iomem    pexowar3;		/* 0x.c70 - PCI Express outbound window attributes register 3*/
+	u8 __iomem    res11[12];
+	__be32 __iomem    pexotar4;		/* 0x.c80 - PCI Express outbound translation address register 4 */
+	__be32 __iomem    pexotear4;		/* 0x.c84 - PCI Express outbound translation extended address register 4*/
+	__be32 __iomem    pexowbar4;		/* 0x.c88 - PCI Express outbound window base address register 4*/
+	u8 __iomem    res12[4];
+	__be32 __iomem    pexowar4;		/* 0x.c90 - PCI Express outbound window attributes register 4*/
+	u8 __iomem    res13[12];
+	u8 __iomem    res14[256];
+	__be32 __iomem    pexitar3;		/* 0x.da0 - PCI Express inbound translation address register 3 */
+	u8 __iomem    res15[4];
+	__be32 __iomem    pexiwbar3;		/* 0x.da8 - PCI Express inbound window base address register 3 */
+	__be32 __iomem    pexiwbear3;		/* 0x.dac - PCI Express inbound window base extended address register 3 */
+	__be32 __iomem    pexiwar3;		/* 0x.db0 - PCI Express inbound window attributes register 3 */
+	u8 __iomem    res16[12];
+	__be32 __iomem    pexitar2;		/* 0x.dc0 - PCI Express inbound translation address register 2 */
+	u8 __iomem    res17[4];
+	__be32 __iomem    pexiwbar2;		/* 0x.dc8 - PCI Express inbound window base address register 2 */
+	__be32 __iomem    pexiwbear2;		/* 0x.dcc - PCI Express inbound window base extended address register 2 */
+	__be32 __iomem    pexiwar2;		/* 0x.dd0 - PCI Express inbound window attributes register 2 */
+	u8 __iomem    res18[12];
+	__be32 __iomem    pexitar1;		/* 0x.de0 - PCI Express inbound translation address register 2 */
+	u8 __iomem    res19[4];
+	__be32 __iomem    pexiwbar1;		/* 0x.de8 - PCI Express inbound window base address register 2 */
+	__be32 __iomem    pexiwbear1;		/* 0x.dec - PCI Express inbound window base extended address register 2 */
+	__be32 __iomem    pexiwar1;		/* 0x.df0 - PCI Express inbound window attributes register 2 */
+	u8 __iomem    res20[12];
+	__be32 __iomem    pex_err_dr;		/* 0x.e00 - PCI Express error detect register */
+	u8 __iomem    res21[4];
+	__be32 __iomem    pex_err_en;		/* 0x.e08 - PCI Express error interrupt enable register */
+	u8 __iomem    res22[4];
+	__be32 __iomem    pex_err_disr;		/* 0x.e10 - PCI Express error disable register */
+	u8 __iomem    res23[12];
+	__be32 __iomem    pex_err_cap_stat;	/* 0x.e20 - PCI Express error capture status register */
+	u8 __iomem    res24[4];
+	__be32 __iomem    pex_err_cap_r0;	/* 0x.e28 - PCI Express error capture register 0 */
+	__be32 __iomem    pex_err_cap_r1;	/* 0x.e2c - PCI Express error capture register 0 */
+	__be32 __iomem    pex_err_cap_r2;	/* 0x.e30 - PCI Express error capture register 0 */
+	__be32 __iomem    pex_err_cap_r3;	/* 0x.e34 - PCI Express error capture register 0 */
+};
+
+#endif /* __POWERPC_FSL_PCIE_H */
+#endif /* __KERNEL__ */
