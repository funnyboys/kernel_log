commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index 692de9dbc680..09b36617425e 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -1,12 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Support for indirect PCI bridges.
  *
  * Copyright (C) 1998 Gabriel Paubert.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 #include <linux/kernel.h>

commit 6d5f6a0eba15c1d2cfd367f1c3fb77ab2bfe8ca8
Author: Kim Phillips <kim.phillips@freescale.com>
Date:   Thu Jan 22 19:05:06 2015 -0600

    powerpc/fsl_pci: Fix pci stack build bug with FRAME_WARN
    
    Fix this:
    
      CC      arch/powerpc/sysdev/fsl_pci.o
    arch/powerpc/sysdev/fsl_pci.c: In function 'fsl_pcie_check_link':
    arch/powerpc/sysdev/fsl_pci.c:91:1: error: the frame size of 1360 bytes is larger than 1024 bytes [-Werror=frame-larger-than=]
    
    when configuring FRAME_WARN, by refactoring indirect_read_config()
    to take hose and bus number instead of the 1344-byte struct pci_bus.
    
    Signed-off-by: Kim Phillips <kim.phillips@freescale.com>
    Signed-off-by: Scott Wood <scottwood@freescale.com>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index 1f6c570d66d4..692de9dbc680 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -20,31 +20,31 @@
 #include <asm/pci-bridge.h>
 #include <asm/machdep.h>
 
-int indirect_read_config(struct pci_bus *bus, unsigned int devfn,
-			 int offset, int len, u32 *val)
+int __indirect_read_config(struct pci_controller *hose,
+			   unsigned char bus_number, unsigned int devfn,
+			   int offset, int len, u32 *val)
 {
-	struct pci_controller *hose = pci_bus_to_host(bus);
 	volatile void __iomem *cfg_data;
 	u8 cfg_type = 0;
 	u32 bus_no, reg;
 
 	if (hose->indirect_type & PPC_INDIRECT_TYPE_NO_PCIE_LINK) {
-		if (bus->number != hose->first_busno)
+		if (bus_number != hose->first_busno)
 			return PCIBIOS_DEVICE_NOT_FOUND;
 		if (devfn != 0)
 			return PCIBIOS_DEVICE_NOT_FOUND;
 	}
 
 	if (ppc_md.pci_exclude_device)
-		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
+		if (ppc_md.pci_exclude_device(hose, bus_number, devfn))
 			return PCIBIOS_DEVICE_NOT_FOUND;
 
 	if (hose->indirect_type & PPC_INDIRECT_TYPE_SET_CFG_TYPE)
-		if (bus->number != hose->first_busno)
+		if (bus_number != hose->first_busno)
 			cfg_type = 1;
 
-	bus_no = (bus->number == hose->first_busno) ?
-			hose->self_busno : bus->number;
+	bus_no = (bus_number == hose->first_busno) ?
+			hose->self_busno : bus_number;
 
 	if (hose->indirect_type & PPC_INDIRECT_TYPE_EXT_REG)
 		reg = ((offset & 0xf00) << 16) | (offset & 0xfc);
@@ -77,6 +77,15 @@ int indirect_read_config(struct pci_bus *bus, unsigned int devfn,
 	return PCIBIOS_SUCCESSFUL;
 }
 
+int indirect_read_config(struct pci_bus *bus, unsigned int devfn,
+			 int offset, int len, u32 *val)
+{
+	struct pci_controller *hose = pci_bus_to_host(bus);
+
+	return __indirect_read_config(hose, bus->number, devfn, offset, len,
+				      val);
+}
+
 int indirect_write_config(struct pci_bus *bus, unsigned int devfn,
 			  int offset, int len, u32 val)
 {

commit 1e83bf875e1eb14f99b3ce1cb5580a09f18ac8af
Author: Christian Engelmayer <cengelma@gmx.at>
Date:   Sun Dec 15 19:39:26 2013 +0100

    powerpc/sysdev: Fix a pci section mismatch for Book E
    
    Moved the following functions out of the __init section:
    
       arch/powerpc/sysdev/fsl_pci.c      : fsl_add_bridge()
       arch/powerpc/sysdev/indirect_pci.c : setup_indirect_pci()
    
    Those are referenced by arch/powerpc/sysdev/fsl_pci.c : fsl_pci_probe() when
    compiling for Book E support.
    
    Signed-off-by: Christian Engelmayer <cengelma@gmx.at>
    Signed-off-by: Scott Wood <scottwood@freescale.com>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index c6c8b526a4f6..1f6c570d66d4 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -152,10 +152,8 @@ static struct pci_ops indirect_pci_ops =
 	.write = indirect_write_config,
 };
 
-void __init
-setup_indirect_pci(struct pci_controller* hose,
-		   resource_size_t cfg_addr,
-		   resource_size_t cfg_data, u32 flags)
+void setup_indirect_pci(struct pci_controller *hose, resource_size_t cfg_addr,
+			resource_size_t cfg_data, u32 flags)
 {
 	resource_size_t base = cfg_addr & PAGE_MASK;
 	void __iomem *mbase;

commit 50d8f87d2b39313dae9d0a2d9b23d377328f2f7b
Author: Rojhalat Ibrahim <imr@rtschenk.de>
Date:   Mon Apr 8 10:15:28 2013 +0200

    powerpc/fsl-pci Make PCIe hotplug work with Freescale PCIe controllers
    
    Up to now the PCIe link status on Freescale PCIe controllers was only
    checked once at boot time. So hotplug did not work. With this patch the
    link status is checked on every config read. PCIe devices not present at
    boot time are found after doing 'echo 1 >/sys/bus/pci/rescan'.
    
    Signed-off-by: Rojhalat Ibrahim <imr@rtschenk.de>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index 82fdad885d20..c6c8b526a4f6 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -20,9 +20,8 @@
 #include <asm/pci-bridge.h>
 #include <asm/machdep.h>
 
-static int
-indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
-		     int len, u32 *val)
+int indirect_read_config(struct pci_bus *bus, unsigned int devfn,
+			 int offset, int len, u32 *val)
 {
 	struct pci_controller *hose = pci_bus_to_host(bus);
 	volatile void __iomem *cfg_data;
@@ -78,9 +77,8 @@ indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int
-indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
-		      int len, u32 val)
+int indirect_write_config(struct pci_bus *bus, unsigned int devfn,
+			  int offset, int len, u32 val)
 {
 	struct pci_controller *hose = pci_bus_to_host(bus);
 	volatile void __iomem *cfg_data;

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index 7ed809676642..82fdad885d20 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -117,7 +117,7 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 		out_le32(hose->cfg_addr, (0x80000000 | (bus_no << 16) |
 			 (devfn << 8) | reg | cfg_type));
 
-	/* surpress setting of PCI_PRIMARY_BUS */
+	/* suppress setting of PCI_PRIMARY_BUS */
 	if (hose->indirect_type & PPC_INDIRECT_TYPE_SURPRESS_PRIMARY_BUS)
 		if ((offset == PCI_PRIMARY_BUS) &&
 			(bus->number == hose->first_busno))

commit 19afa40797a3b392b64bf0b30b46e62001eeb66f
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Thu Apr 30 03:10:07 2009 +0000

    powerpc/pci: Clean up direct access to sysdata by indirect ops
    
    We shouldn't directly access sysdata to get the pci_controller.  Instead
    use pci_bus_to_host() for this purpose.  In the future we might have
    sysdata be a device_node to match ppc64 and unify the code between ppc32
    & ppc64.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index 7fd49c97501a..7ed809676642 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -24,7 +24,7 @@ static int
 indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
 		     int len, u32 *val)
 {
-	struct pci_controller *hose = bus->sysdata;
+	struct pci_controller *hose = pci_bus_to_host(bus);
 	volatile void __iomem *cfg_data;
 	u8 cfg_type = 0;
 	u32 bus_no, reg;
@@ -82,7 +82,7 @@ static int
 indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 		      int len, u32 val)
 {
-	struct pci_controller *hose = bus->sysdata;
+	struct pci_controller *hose = pci_bus_to_host(bus);
 	volatile void __iomem *cfg_data;
 	u8 cfg_type = 0;
 	u32 bus_no, reg;

commit 5ce4b59653b2c2053cd9a011918ac1e4747f24cc
Author: Josh Boyer <jwboyer@linux.vnet.ibm.com>
Date:   Tue Jun 17 19:01:38 2008 -0400

    powerpc/4xx: Workaround for PPC440EPx/GRx PCI_28 Errata
    
    The 440EPx/GRx chips don't support PCI MRM commands.  Drivers determine this
    by looking for a zero value in the PCI cache line size register.  However,
    some drivers write to this register upon initialization.  This can cause
    MRMs to be used on these chips, which may cause deadlocks on PLB4.
    
    The workaround implemented here introduces a new indirect_type flag, called
    PPC_INDIRECT_TYPE_BROKEN_MRM.  This is set in the pci_controller structure in
    the pci fixup function for 4xx PCI bridges by determining if the bridge is
    compatible with 440EPx/GRx.  The flag is checked in the indirect_write_config
    function, and forces any writes to the PCI_CACHE_LINE_SIZE register to be
    zero, which will disable MRMs for these chips.
    
    A similar workaround has been tested by AMCC on various PCI cards, such as
    the Silicon Image ATA card and Intel E1000 GIGE card.  Hangs were seen with
    the Silicon Image card, and MRMs were seen on the bus with a PCI analyzer.
    With the workaround in place, the card functioned properly and only Memory
    Reads were seen on the bus with the analyzer.
    
    Acked-by: Stefan Roese <sr@denx.de>
    Signed-off-by: Josh Boyer <jwboyer@linux.vnet.ibm.com>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index cfbd2aae93e8..7fd49c97501a 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -123,6 +123,12 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 			(bus->number == hose->first_busno))
 		val &= 0xffffff00;
 
+	/* Workaround for PCI_28 Errata in 440EPx/GRx */
+	if ((hose->indirect_type & PPC_INDIRECT_TYPE_BROKEN_MRM) &&
+			offset == PCI_CACHE_LINE_SIZE) {
+		val = 0;
+	}
+
 	/*
 	 * Note: the caller has already checked that offset is
 	 * suitably aligned and that len is 1, 2 or 4.

commit d94bad827d9a0df939a0e7ed081a2780b9f72c4b
Author: Valentine Barshak <vbarshak@ru.mvista.com>
Date:   Mon Oct 8 22:51:24 2007 +1000

    [POWERPC] PCI: Add 64-bit physical address support to setup_indirect_pci
    
    Add 64-bit physical address support to setup_indirect_pci().
    
    Signed-off-by: Valentine Barshak <vbarshak@ru.mvista.com>
    Acked-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index b5d068204aa3..cfbd2aae93e8 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -149,9 +149,11 @@ static struct pci_ops indirect_pci_ops =
 };
 
 void __init
-setup_indirect_pci(struct pci_controller* hose, u32 cfg_addr, u32 cfg_data, u32 flags)
+setup_indirect_pci(struct pci_controller* hose,
+		   resource_size_t cfg_addr,
+		   resource_size_t cfg_data, u32 flags)
 {
-	unsigned long base = cfg_addr & PAGE_MASK;
+	resource_size_t base = cfg_addr & PAGE_MASK;
 	void __iomem *mbase;
 
 	mbase = ioremap(base, PAGE_SIZE);

commit c78d453b6f95ff38a2226f6f77a4b08a6e27fc42
Author: Nathan Lynch <ntl@pobox.com>
Date:   Fri Aug 10 05:18:45 2007 +1000

    [POWERPC] indirect_pci_ops: Use named structure member initializers
    
    Signed-off-by: Nathan Lynch <ntl@pobox.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index 5294560c7b00..b5d068204aa3 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -144,8 +144,8 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 
 static struct pci_ops indirect_pci_ops =
 {
-	indirect_read_config,
-	indirect_write_config
+	.read = indirect_read_config,
+	.write = indirect_write_config,
 };
 
 void __init

commit 7659c038d3d0a635b5aeff04aed523d7b6c1dde8
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Wed Jul 25 00:29:53 2007 -0500

    [POWERPC] Fix PCI indirect for big-endian cfg_addr
    
    We didn't actually propogate the flag we pass into setup_indirect_pci()
    to set indirect_type and thus were getting the wrong endianness if
    PPC_INDIRECT_TYPE_BIG_ENDIAN was set.
    
    Also, we need to or in additional flags rather than just doing a
    direct assignment.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index a8ac2dfdd3d4..5294560c7b00 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -160,4 +160,5 @@ setup_indirect_pci(struct pci_controller* hose, u32 cfg_addr, u32 cfg_data, u32
 		mbase = ioremap(cfg_data & PAGE_MASK, PAGE_SIZE);
 	hose->cfg_data = mbase + (cfg_data & ~PAGE_MASK);
 	hose->ops = &indirect_pci_ops;
+	hose->indirect_type = flags;
 }

commit 2e56ff206b7c6c28b847ccdbe46ad69b3263ac32
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Thu Jul 19 16:07:35 2007 -0500

    [POWERPC] Make endianess of cfg_addr for indirect pci ops runtime
    
    Make it so we do a runtime check to know if we need to write cfg_addr
    as big or little endian.  This is needed if we want to allow 86xx support
    to co-exist in the same kernel as other 6xx PPCs.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index ad341f5ff94f..a8ac2dfdd3d4 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -20,12 +20,6 @@
 #include <asm/pci-bridge.h>
 #include <asm/machdep.h>
 
-#ifdef CONFIG_PPC_INDIRECT_PCI_BE
-#define PCI_CFG_OUT out_be32
-#else
-#define PCI_CFG_OUT out_le32
-#endif
-
 static int
 indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
 		     int len, u32 *val)
@@ -58,9 +52,12 @@ indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
 	else
 		reg = offset & 0xfc;
 
-	PCI_CFG_OUT(hose->cfg_addr,
-		 (0x80000000 | (bus_no << 16)
-		  | (devfn << 8) | reg | cfg_type));
+	if (hose->indirect_type & PPC_INDIRECT_TYPE_BIG_ENDIAN)
+		out_be32(hose->cfg_addr, (0x80000000 | (bus_no << 16) |
+			 (devfn << 8) | reg | cfg_type));
+	else
+		out_le32(hose->cfg_addr, (0x80000000 | (bus_no << 16) |
+			 (devfn << 8) | reg | cfg_type));
 
 	/*
 	 * Note: the caller has already checked that offset is
@@ -113,9 +110,12 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 	else
 		reg = offset & 0xfc;
 
-	PCI_CFG_OUT(hose->cfg_addr,
-		 (0x80000000 | (bus_no << 16)
-		  | (devfn << 8) | reg | cfg_type));
+	if (hose->indirect_type & PPC_INDIRECT_TYPE_BIG_ENDIAN)
+		out_be32(hose->cfg_addr, (0x80000000 | (bus_no << 16) |
+			 (devfn << 8) | reg | cfg_type));
+	else
+		out_le32(hose->cfg_addr, (0x80000000 | (bus_no << 16) |
+			 (devfn << 8) | reg | cfg_type));
 
 	/* surpress setting of PCI_PRIMARY_BUS */
 	if (hose->indirect_type & PPC_INDIRECT_TYPE_SURPRESS_PRIMARY_BUS)
@@ -149,7 +149,7 @@ static struct pci_ops indirect_pci_ops =
 };
 
 void __init
-setup_indirect_pci(struct pci_controller* hose, u32 cfg_addr, u32 cfg_data)
+setup_indirect_pci(struct pci_controller* hose, u32 cfg_addr, u32 cfg_data, u32 flags)
 {
 	unsigned long base = cfg_addr & PAGE_MASK;
 	void __iomem *mbase;

commit d5269966e57484548bc5d38e117f161bf2f56ce9
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Thu Jul 19 15:44:52 2007 -0500

    [POWERPC] Removed setup_indirect_pci_nomap
    
    We don't use setup_indirect_pci_nomap in arch/powerpc and it appears
    the users that needed it from arch/ppc are now using setup_indirect_pci.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index bc5b4e22fa5d..ad341f5ff94f 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -148,25 +148,16 @@ static struct pci_ops indirect_pci_ops =
 	indirect_write_config
 };
 
-void __init
-setup_indirect_pci_nomap(struct pci_controller* hose, void __iomem * cfg_addr,
-	void __iomem * cfg_data)
-{
-	hose->cfg_addr = cfg_addr;
-	hose->cfg_data = cfg_data;
-	hose->ops = &indirect_pci_ops;
-}
-
 void __init
 setup_indirect_pci(struct pci_controller* hose, u32 cfg_addr, u32 cfg_data)
 {
 	unsigned long base = cfg_addr & PAGE_MASK;
-	void __iomem *mbase, *addr, *data;
+	void __iomem *mbase;
 
 	mbase = ioremap(base, PAGE_SIZE);
-	addr = mbase + (cfg_addr & ~PAGE_MASK);
+	hose->cfg_addr = mbase + (cfg_addr & ~PAGE_MASK);
 	if ((cfg_data & PAGE_MASK) != base)
 		mbase = ioremap(cfg_data & PAGE_MASK, PAGE_SIZE);
-	data = mbase + (cfg_data & ~PAGE_MASK);
-	setup_indirect_pci_nomap(hose, addr, data);
+	hose->cfg_data = mbase + (cfg_data & ~PAGE_MASK);
+	hose->ops = &indirect_pci_ops;
 }

commit 62c66c8e55fae40d93d8f79d60e2ed50379e46f9
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Wed Jul 11 13:22:41 2007 -0500

    [POWERPC] Added indirect quirk to handle PCIe PHB that have issue w/no link
    
    Added PPC_INDIRECT_TYPE_NO_PCIE_LINK flag to the indirect pci handling
    code to ensure that we don't talk to any device other than the PHB
    if we don't have PCIe link.  Some controllers will lockup if they try
    to do a config cycle to any device on the bus except the PHB.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index c7e6e859b393..bc5b4e22fa5d 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -35,10 +35,17 @@ indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
 	u8 cfg_type = 0;
 	u32 bus_no, reg;
 
+	if (hose->indirect_type & PPC_INDIRECT_TYPE_NO_PCIE_LINK) {
+		if (bus->number != hose->first_busno)
+			return PCIBIOS_DEVICE_NOT_FOUND;
+		if (devfn != 0)
+			return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
 	if (ppc_md.pci_exclude_device)
 		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
 			return PCIBIOS_DEVICE_NOT_FOUND;
-	
+
 	if (hose->indirect_type & PPC_INDIRECT_TYPE_SET_CFG_TYPE)
 		if (bus->number != hose->first_busno)
 			cfg_type = 1;
@@ -83,6 +90,13 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 	u8 cfg_type = 0;
 	u32 bus_no, reg;
 
+	if (hose->indirect_type & PPC_INDIRECT_TYPE_NO_PCIE_LINK) {
+		if (bus->number != hose->first_busno)
+			return PCIBIOS_DEVICE_NOT_FOUND;
+		if (devfn != 0)
+			return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+
 	if (ppc_md.pci_exclude_device)
 		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
 			return PCIBIOS_DEVICE_NOT_FOUND;

commit 476f5779b77a919f0ced5953de2bf3e0f2d02c07
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Tue Jun 26 12:12:55 2007 -0500

    [POWERPC] 86xx: Workaround PCI_PRIMARY_BUS usage
    
    The Freescale PCI-e controllers have an issue in that they use the
    PCI_PRIMARY_BUS register in the virtual P2P bridge to determine which
    bus number to match on when generating a type 0 config cycle.  The
    issue is if we are renumbering bus numbers to match Linux we will try
    setting the PCI_PRIMARY_BUS and will not know which bus number to use
    for generating type 0 config cycles.  We surpress writing the register
    in the P2P bridge and always keep it at zero.
    
    In the future when proper PCI domain support is working we should be
    able to remove this.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index 3a1612253c60..c7e6e859b393 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -103,6 +103,12 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 		 (0x80000000 | (bus_no << 16)
 		  | (devfn << 8) | reg | cfg_type));
 
+	/* surpress setting of PCI_PRIMARY_BUS */
+	if (hose->indirect_type & PPC_INDIRECT_TYPE_SURPRESS_PRIMARY_BUS)
+		if ((offset == PCI_PRIMARY_BUS) &&
+			(bus->number == hose->first_busno))
+		val &= 0xffffff00;
+
 	/*
 	 * Note: the caller has already checked that offset is
 	 * suitably aligned and that len is 1, 2 or 4.

commit ab0f9ad34d1eb31bb13cc4218d7717f8a85b12ed
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Mon Jun 25 15:19:48 2007 -0500

    [POWERPC] Added indirect_type to handle variants of PCI ops
    
    The generic PCI config ops indirect support for ppc32 covers only two
    cases (implicit vs explicit) type 0/1 config cycles via set_cfg_type.
    Added a indirect_type bit mask to handle other variants.
    
    Added support for PCI-e extended registers and moved the cfg_type
    handling into the bit mask for ARCH=powerpc.  We can also use this to
    handle indirect quirks.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index efe3cff8dcd1..3a1612253c60 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -33,22 +33,27 @@ indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
 	struct pci_controller *hose = bus->sysdata;
 	volatile void __iomem *cfg_data;
 	u8 cfg_type = 0;
-	u32 bus_no;
+	u32 bus_no, reg;
 
 	if (ppc_md.pci_exclude_device)
 		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
 			return PCIBIOS_DEVICE_NOT_FOUND;
 	
-	if (hose->set_cfg_type)
+	if (hose->indirect_type & PPC_INDIRECT_TYPE_SET_CFG_TYPE)
 		if (bus->number != hose->first_busno)
 			cfg_type = 1;
 
 	bus_no = (bus->number == hose->first_busno) ?
 			hose->self_busno : bus->number;
 
+	if (hose->indirect_type & PPC_INDIRECT_TYPE_EXT_REG)
+		reg = ((offset & 0xf00) << 16) | (offset & 0xfc);
+	else
+		reg = offset & 0xfc;
+
 	PCI_CFG_OUT(hose->cfg_addr,
 		 (0x80000000 | (bus_no << 16)
-		  | (devfn << 8) | ((offset & 0xfc) | cfg_type)));
+		  | (devfn << 8) | reg | cfg_type));
 
 	/*
 	 * Note: the caller has already checked that offset is
@@ -76,22 +81,27 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 	struct pci_controller *hose = bus->sysdata;
 	volatile void __iomem *cfg_data;
 	u8 cfg_type = 0;
-	u32 bus_no;
+	u32 bus_no, reg;
 
 	if (ppc_md.pci_exclude_device)
 		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
 			return PCIBIOS_DEVICE_NOT_FOUND;
 
-	if (hose->set_cfg_type)
+	if (hose->indirect_type & PPC_INDIRECT_TYPE_SET_CFG_TYPE)
 		if (bus->number != hose->first_busno)
 			cfg_type = 1;
 
 	bus_no = (bus->number == hose->first_busno) ?
 			hose->self_busno : bus->number;
 
+	if (hose->indirect_type & PPC_INDIRECT_TYPE_EXT_REG)
+		reg = ((offset & 0xf00) << 16) | (offset & 0xfc);
+	else
+		reg = offset & 0xfc;
+
 	PCI_CFG_OUT(hose->cfg_addr,
 		 (0x80000000 | (bus_no << 16)
-		  | (devfn << 8) | ((offset & 0xfc) | cfg_type)));
+		  | (devfn << 8) | reg | cfg_type));
 
 	/*
 	 * Note: the caller has already checked that offset is

commit 0a3786c5f7575c0739ad94057213b931a9423502
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Mon Jun 25 13:32:48 2007 -0500

    [POWERPC] Removed remnants of bus_offset
    
    Removed the remants of bus_offset and use self_busno in the mv64x60 case
    and use pci_assign_all_buses on 83xx/85xx.
    
    83xx/85xx have multiple PHBs and the firmwares on these devices tend not
    to handle topologies with P2P bridges well so we let Linux just reassign
    the bus numbers to match.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index d490e71f0533..efe3cff8dcd1 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -44,7 +44,7 @@ indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
 			cfg_type = 1;
 
 	bus_no = (bus->number == hose->first_busno) ?
-			hose->self_busno : bus->number - hose->bus_offset;
+			hose->self_busno : bus->number;
 
 	PCI_CFG_OUT(hose->cfg_addr,
 		 (0x80000000 | (bus_no << 16)
@@ -87,7 +87,7 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 			cfg_type = 1;
 
 	bus_no = (bus->number == hose->first_busno) ?
-			hose->self_busno : bus->number - hose->bus_offset;
+			hose->self_busno : bus->number;
 
 	PCI_CFG_OUT(hose->cfg_addr,
 		 (0x80000000 | (bus_no << 16)

commit 5ab65ecdaffd85753e7ad957622afcd709a39deb
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Mon Jun 25 13:09:42 2007 -0500

    [POWERPC] Added self_busno to indicate which bus number the PHB is
    
    Added self_busno to pci_controller and indirect PCI ops to be set by
    board code to indicate which bus number to use when talking to the PHB.
    By default we use zero since the majority of controllers that have
    implicit mechanisms to talk to the PHBs use a bus number of zero.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index 3dedf8f5bfb4..d490e71f0533 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -33,6 +33,7 @@ indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
 	struct pci_controller *hose = bus->sysdata;
 	volatile void __iomem *cfg_data;
 	u8 cfg_type = 0;
+	u32 bus_no;
 
 	if (ppc_md.pci_exclude_device)
 		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
@@ -42,8 +43,11 @@ indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
 		if (bus->number != hose->first_busno)
 			cfg_type = 1;
 
+	bus_no = (bus->number == hose->first_busno) ?
+			hose->self_busno : bus->number - hose->bus_offset;
+
 	PCI_CFG_OUT(hose->cfg_addr,
-		 (0x80000000 | ((bus->number - hose->bus_offset) << 16)
+		 (0x80000000 | (bus_no << 16)
 		  | (devfn << 8) | ((offset & 0xfc) | cfg_type)));
 
 	/*
@@ -72,6 +76,7 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 	struct pci_controller *hose = bus->sysdata;
 	volatile void __iomem *cfg_data;
 	u8 cfg_type = 0;
+	u32 bus_no;
 
 	if (ppc_md.pci_exclude_device)
 		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
@@ -81,8 +86,11 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 		if (bus->number != hose->first_busno)
 			cfg_type = 1;
 
+	bus_no = (bus->number == hose->first_busno) ?
+			hose->self_busno : bus->number - hose->bus_offset;
+
 	PCI_CFG_OUT(hose->cfg_addr,
-		 (0x80000000 | ((bus->number - hose->bus_offset) << 16)
+		 (0x80000000 | (bus_no << 16)
 		  | (devfn << 8) | ((offset & 0xfc) | cfg_type)));
 
 	/*

commit 7d52c7b0cd46f42ae2c9df37f1a385d9aaf95842
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Fri Jun 22 00:23:57 2007 -0500

    [POWERPC] Pass the pci_controller into pci_exclude_device
    
    There are times that we need to know which controller we are on to decide
    how to exclude devices properly.  We now pass the pci_controller that we
    are going to use down to the pci_exclude_device function. This will
    greatly simplify being able to exclude the PHBs in multiple controller
    setups.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
index e71488469704..3dedf8f5bfb4 100644
--- a/arch/powerpc/sysdev/indirect_pci.c
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -35,14 +35,14 @@ indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
 	u8 cfg_type = 0;
 
 	if (ppc_md.pci_exclude_device)
-		if (ppc_md.pci_exclude_device(bus->number, devfn))
+		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
 			return PCIBIOS_DEVICE_NOT_FOUND;
 	
 	if (hose->set_cfg_type)
 		if (bus->number != hose->first_busno)
 			cfg_type = 1;
 
-	PCI_CFG_OUT(hose->cfg_addr, 					 
+	PCI_CFG_OUT(hose->cfg_addr,
 		 (0x80000000 | ((bus->number - hose->bus_offset) << 16)
 		  | (devfn << 8) | ((offset & 0xfc) | cfg_type)));
 
@@ -74,14 +74,14 @@ indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
 	u8 cfg_type = 0;
 
 	if (ppc_md.pci_exclude_device)
-		if (ppc_md.pci_exclude_device(bus->number, devfn))
+		if (ppc_md.pci_exclude_device(hose, bus->number, devfn))
 			return PCIBIOS_DEVICE_NOT_FOUND;
 
 	if (hose->set_cfg_type)
 		if (bus->number != hose->first_busno)
 			cfg_type = 1;
 
-	PCI_CFG_OUT(hose->cfg_addr, 					 
+	PCI_CFG_OUT(hose->cfg_addr,
 		 (0x80000000 | ((bus->number - hose->bus_offset) << 16)
 		  | (devfn << 8) | ((offset & 0xfc) | cfg_type)));
 

commit daec962e27490be4fae9ab5a51d0c17f6e638715
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Oct 10 22:25:26 2005 +1000

    powerpc: Use arch/powerpc/mm and arch/powerpc/lib for 64-bit
    
    This also puts a copy of indirect_pci.c in arch/powerpc/sysdev
    so that we don't need to build in arch/ppc/syslib.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/sysdev/indirect_pci.c b/arch/powerpc/sysdev/indirect_pci.c
new file mode 100644
index 000000000000..e71488469704
--- /dev/null
+++ b/arch/powerpc/sysdev/indirect_pci.c
@@ -0,0 +1,134 @@
+/*
+ * Support for indirect PCI bridges.
+ *
+ * Copyright (C) 1998 Gabriel Paubert.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/delay.h>
+#include <linux/string.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/prom.h>
+#include <asm/pci-bridge.h>
+#include <asm/machdep.h>
+
+#ifdef CONFIG_PPC_INDIRECT_PCI_BE
+#define PCI_CFG_OUT out_be32
+#else
+#define PCI_CFG_OUT out_le32
+#endif
+
+static int
+indirect_read_config(struct pci_bus *bus, unsigned int devfn, int offset,
+		     int len, u32 *val)
+{
+	struct pci_controller *hose = bus->sysdata;
+	volatile void __iomem *cfg_data;
+	u8 cfg_type = 0;
+
+	if (ppc_md.pci_exclude_device)
+		if (ppc_md.pci_exclude_device(bus->number, devfn))
+			return PCIBIOS_DEVICE_NOT_FOUND;
+	
+	if (hose->set_cfg_type)
+		if (bus->number != hose->first_busno)
+			cfg_type = 1;
+
+	PCI_CFG_OUT(hose->cfg_addr, 					 
+		 (0x80000000 | ((bus->number - hose->bus_offset) << 16)
+		  | (devfn << 8) | ((offset & 0xfc) | cfg_type)));
+
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	cfg_data = hose->cfg_data + (offset & 3);
+	switch (len) {
+	case 1:
+		*val = in_8(cfg_data);
+		break;
+	case 2:
+		*val = in_le16(cfg_data);
+		break;
+	default:
+		*val = in_le32(cfg_data);
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int
+indirect_write_config(struct pci_bus *bus, unsigned int devfn, int offset,
+		      int len, u32 val)
+{
+	struct pci_controller *hose = bus->sysdata;
+	volatile void __iomem *cfg_data;
+	u8 cfg_type = 0;
+
+	if (ppc_md.pci_exclude_device)
+		if (ppc_md.pci_exclude_device(bus->number, devfn))
+			return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if (hose->set_cfg_type)
+		if (bus->number != hose->first_busno)
+			cfg_type = 1;
+
+	PCI_CFG_OUT(hose->cfg_addr, 					 
+		 (0x80000000 | ((bus->number - hose->bus_offset) << 16)
+		  | (devfn << 8) | ((offset & 0xfc) | cfg_type)));
+
+	/*
+	 * Note: the caller has already checked that offset is
+	 * suitably aligned and that len is 1, 2 or 4.
+	 */
+	cfg_data = hose->cfg_data + (offset & 3);
+	switch (len) {
+	case 1:
+		out_8(cfg_data, val);
+		break;
+	case 2:
+		out_le16(cfg_data, val);
+		break;
+	default:
+		out_le32(cfg_data, val);
+		break;
+	}
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops indirect_pci_ops =
+{
+	indirect_read_config,
+	indirect_write_config
+};
+
+void __init
+setup_indirect_pci_nomap(struct pci_controller* hose, void __iomem * cfg_addr,
+	void __iomem * cfg_data)
+{
+	hose->cfg_addr = cfg_addr;
+	hose->cfg_data = cfg_data;
+	hose->ops = &indirect_pci_ops;
+}
+
+void __init
+setup_indirect_pci(struct pci_controller* hose, u32 cfg_addr, u32 cfg_data)
+{
+	unsigned long base = cfg_addr & PAGE_MASK;
+	void __iomem *mbase, *addr, *data;
+
+	mbase = ioremap(base, PAGE_SIZE);
+	addr = mbase + (cfg_addr & ~PAGE_MASK);
+	if ((cfg_data & PAGE_MASK) != base)
+		mbase = ioremap(cfg_data & PAGE_MASK, PAGE_SIZE);
+	data = mbase + (cfg_data & ~PAGE_MASK);
+	setup_indirect_pci_nomap(hose, addr, data);
+}
