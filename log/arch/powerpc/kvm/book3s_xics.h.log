commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index 453c9e518c19..6231f76bdd66 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -1,10 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright 2012 Michael Ellerman, IBM Corporation.
  * Copyright 2012 Benjamin Herrenschmidt, IBM Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, version 2, as
- * published by the Free Software Foundation.
  */
 
 #ifndef _KVM_PPC_BOOK3S_XICS_H

commit 5af50993850a48ba749b122173d789ea90976c72
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Apr 5 17:54:56 2017 +1000

    KVM: PPC: Book3S HV: Native usage of the XIVE interrupt controller
    
    This patch makes KVM capable of using the XIVE interrupt controller
    to provide the standard PAPR "XICS" style hypercalls. It is necessary
    for proper operations when the host uses XIVE natively.
    
    This has been lightly tested on an actual system, including PCI
    pass-through with a TG3 device.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    [mpe: Cleanup pr_xxx(), unsplit pr_xxx() strings, etc., fix build
     failures by adding KVM_XIVE which depends on KVM_XICS and XIVE, and
     adding empty stubs for the kvm_xive_xxx() routines, fixup subject,
     integrate fixes from Paul for building PR=y HV=n]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index ec5474cf70c6..453c9e518c19 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -10,6 +10,7 @@
 #ifndef _KVM_PPC_BOOK3S_XICS_H
 #define _KVM_PPC_BOOK3S_XICS_H
 
+#ifdef CONFIG_KVM_XICS
 /*
  * We use a two-level tree to store interrupt source information.
  * There are up to 1024 ICS nodes, each of which can represent
@@ -144,5 +145,11 @@ static inline struct kvmppc_ics *kvmppc_xics_find_ics(struct kvmppc_xics *xics,
 	return ics;
 }
 
+extern unsigned long xics_rm_h_xirr(struct kvm_vcpu *vcpu);
+extern int xics_rm_h_ipi(struct kvm_vcpu *vcpu, unsigned long server,
+			 unsigned long mfrr);
+extern int xics_rm_h_cppr(struct kvm_vcpu *vcpu, unsigned long cppr);
+extern int xics_rm_h_eoi(struct kvm_vcpu *vcpu, unsigned long xirr);
 
+#endif /* CONFIG_KVM_XICS */
 #endif /* _KVM_PPC_BOOK3S_XICS_H */

commit 17d48610ae0fa218aa386b16a538c792991a3652
Author: Li Zhong <zhong@linux.vnet.ibm.com>
Date:   Fri Nov 11 12:57:35 2016 +0800

    KVM: PPC: Book 3S: XICS: Implement ICS P/Q states
    
    This patch implements P(Presented)/Q(Queued) states for ICS irqs.
    
    When the interrupt is presented, set P. Present if P was not set.
    If P is already set, don't present again, set Q.
    When the interrupt is EOI'ed, move Q into P (and clear Q). If it is
    set, re-present.
    
    The asserted flag used by LSI is also incorporated into the P bit.
    
    When the irq state is saved, P/Q bits are also saved, they need some
    qemu modifications to be recognized and passed around to be restored.
    KVM_XICS_PENDING bit set and saved should also indicate
    KVM_XICS_PRESENTED bit set and saved. But it is possible some old
    code doesn't have/recognize the P bit, so when we restore, we set P
    for PENDING bit, too.
    
    The idea and much of the code come from Ben.
    
    Signed-off-by: Li Zhong <zhong@linux.vnet.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index 1d5fac80b706..ec5474cf70c6 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -31,16 +31,19 @@
 /* Priority value to use for disabling an interrupt */
 #define MASKED	0xff
 
+#define PQ_PRESENTED	1
+#define PQ_QUEUED	2
+
 /* State for one irq source */
 struct ics_irq_state {
 	u32 number;
 	u32 server;
+	u32 pq_state;
 	u8  priority;
 	u8  saved_priority;
 	u8  resend;
 	u8  masked_pending;
 	u8  lsi;		/* level-sensitive interrupt */
-	u8  asserted; /* Only for LSI */
 	u8  exists;
 	int intr_cpu;
 	u32 host_irq;

commit 5efa6605151b84029edeb2e07f2d2d74b52c106f
Author: Li Zhong <zhong@linux.vnet.ibm.com>
Date:   Fri Nov 11 12:57:32 2016 +0800

    KVM: PPC: Book 3S: XICS cleanup: remove XICS_RM_REJECT
    
    Commit b0221556dbd3 ("KVM: PPC: Book3S HV: Move virtual mode ICP functions
     to real-mode") removed the setting of the XICS_RM_REJECT flag. And
    since that commit, nothing else sets the flag any more, so we can remove
    the flag and the remaining code that handles it, including the counter
    that counts how many times it get set.
    
    Signed-off-by: Li Zhong <zhong@linux.vnet.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index 2a50320b55ca..1d5fac80b706 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -73,7 +73,6 @@ struct kvmppc_icp {
 	 */
 #define XICS_RM_KICK_VCPU	0x1
 #define XICS_RM_CHECK_RESEND	0x2
-#define XICS_RM_REJECT		0x4
 #define XICS_RM_NOTIFY_EOI	0x8
 	u32 rm_action;
 	struct kvm_vcpu *rm_kick_target;
@@ -84,7 +83,6 @@ struct kvmppc_icp {
 	/* Counters for each reason we exited real mode */
 	unsigned long n_rm_kick_vcpu;
 	unsigned long n_rm_check_resend;
-	unsigned long n_rm_reject;
 	unsigned long n_rm_notify_eoi;
 	/* Counters for handling ICP processing in real mode */
 	unsigned long n_check_resend;

commit 5d375199ea963fa2a972eae9c7d83db36ed37082
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Fri Aug 19 15:35:56 2016 +1000

    KVM: PPC: Book3S HV: Set server for passed-through interrupts
    
    When a guest has a PCI pass-through device with an interrupt, it
    will direct the interrupt to a particular guest VCPU.  In fact the
    physical interrupt might arrive on any CPU, and then get
    delivered to the target VCPU in the emulated XICS (guest interrupt
    controller), and eventually delivered to the target VCPU.
    
    Now that we have code to handle device interrupts in real mode
    without exiting to the host kernel, there is an advantage to having
    the device interrupt arrive on the same sub(core) as the target
    VCPU is running on.  In this situation, the interrupt can be
    delivered to the target VCPU without any exit to the host kernel
    (using a hypervisor doorbell interrupt between threads if
    necessary).
    
    This patch aims to get passed-through device interrupts arriving
    on the correct core by setting the interrupt server in the real
    hardware XICS for the interrupt to the first thread in the (sub)core
    where its target VCPU is running.  We do this in the real-mode H_EOI
    code because the H_EOI handler already needs to look at the
    emulated ICS state for the interrupt (whereas the H_XIRR handler
    doesn't), and we know we are running in the target VCPU context
    at that point.
    
    We set the server CPU in hardware using an OPAL call, regardless of
    what the IRQ affinity mask for the interrupt says, and without
    updating the affinity mask.  This amounts to saying that when an
    interrupt is passed through to a guest, as a matter of policy we
    allow the guest's affinity for the interrupt to override the host's.
    
    This is inspired by an earlier patch from Suresh Warrier, although
    none of this code came from that earlier patch.
    
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index a46b954055c4..2a50320b55ca 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -42,6 +42,8 @@ struct ics_irq_state {
 	u8  lsi;		/* level-sensitive interrupt */
 	u8  asserted; /* Only for LSI */
 	u8  exists;
+	int intr_cpu;
+	u32 host_irq;
 };
 
 /* Atomic ICP state, updated with a single compare & swap */

commit b1a4286b8f3393857a205ec89607683161b75f90
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Wed May 4 21:07:52 2016 +1000

    KVM: PPC: Book3S HV: Re-enable XICS fast path for irqfd-generated interrupts
    
    Commit c9a5eccac1ab ("kvm/eventfd: add arch-specific set_irq",
    2015-10-16) added the possibility for architecture-specific code
    to handle the generation of virtual interrupts in atomic context
    where possible, without having to schedule a work function.
    
    Since we can easily generate virtual interrupts on XICS without
    having to do anything worse than take a spinlock, we define a
    kvm_arch_set_irq_inatomic() for XICS.  We also remove kvm_set_msi()
    since it is not used any more.
    
    The one slightly tricky thing is that with the new interface, we
    don't get told whether the interrupt is an MSI (or other edge
    sensitive interrupt) vs. level-sensitive.  The difference as far
    as interrupt generation is concerned is that for LSIs we have to
    set the asserted flag so it will continue to fire until it is
    explicitly cleared.
    
    In fact the XICS code gets told which interrupts are LSIs by userspace
    when it configures the interrupt via the KVM_DEV_XICS_GRP_SOURCES
    attribute group on the XICS device.  To store this information, we add
    a new "lsi" field to struct ics_irq_state.  With that we can also do a
    better job of returning accurate values when reading the attribute
    group.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index 56ea44f9867f..a46b954055c4 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -39,6 +39,7 @@ struct ics_irq_state {
 	u8  saved_priority;
 	u8  resend;
 	u8  masked_pending;
+	u8  lsi;		/* level-sensitive interrupt */
 	u8  asserted; /* Only for LSI */
 	u8  exists;
 };

commit 6e0365b782739eb41b03bcfd23abeefacbf0817a
Author: Suresh Warrier <warrier@linux.vnet.ibm.com>
Date:   Fri Mar 20 20:39:48 2015 +1100

    KVM: PPC: Book3S HV: Add ICP real mode counters
    
    Add two counters to count how often we generate real-mode ICS resend
    and reject events. The counters provide some performance statistics
    that could be used in the future to consider if the real mode functions
    need further optimizing. The counters are displayed as part of IPC and
    ICP state provided by /sys/debug/kernel/powerpc/kvm* for each VM.
    
    Also added two counters that count (approximately) how many times we
    don't find an ICP or ICS we're looking for. These are not currently
    exposed through sysfs, but can be useful when debugging crashes.
    
    Signed-off-by: Suresh Warrier <warrier@linux.vnet.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index 055424c43249..56ea44f9867f 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -83,6 +83,9 @@ struct kvmppc_icp {
 	unsigned long n_rm_check_resend;
 	unsigned long n_rm_reject;
 	unsigned long n_rm_notify_eoi;
+	/* Counters for handling ICP processing in real mode */
+	unsigned long n_check_resend;
+	unsigned long n_reject;
 
 	/* Debug stuff for real mode */
 	union kvmppc_icp_state rm_dbgstate;
@@ -102,6 +105,8 @@ struct kvmppc_xics {
 	u32 max_icsid;
 	bool real_mode;
 	bool real_mode_dbg;
+	u32 err_noics;
+	u32 err_noicp;
 	struct kvmppc_ics *ics[KVMPPC_XICS_MAX_ICS_ID + 1];
 };
 

commit 34cb7954c0aa7c8ad1591cb6cceae36432f55bb5
Author: Suresh Warrier <warrier@linux.vnet.ibm.com>
Date:   Fri Mar 20 20:39:46 2015 +1100

    KVM: PPC: Book3S HV: Convert ICS mutex lock to spin lock
    
    Replaces the ICS mutex lock with a spin lock since we will be porting
    these routines to real mode. Note that we need to disable interrupts
    before we take the lock in anticipation of the fact that on the guest
    side, we are running in the context of a hard irq and interrupts are
    disabled (EE bit off) when the lock is acquired. Again, because we
    will be acquiring the lock in hypervisor real mode, we need to use
    an arch_spinlock_t instead of a normal spinlock here as we want to
    avoid running any lockdep code (which may not be safe to execute in
    real mode).
    
    Signed-off-by: Suresh Warrier <warrier@linux.vnet.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index de970eca2167..055424c43249 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -90,7 +90,7 @@ struct kvmppc_icp {
 };
 
 struct kvmppc_ics {
-	struct mutex lock;
+	arch_spinlock_t lock;
 	u16 icsid;
 	struct ics_irq_state irq_state[KVMPPC_XICS_IRQ_PER_ICS];
 };

commit 878610fe9884a34a282cd4431237343864324d23
Author: Suresh E. Warrier <warrier@linux.vnet.ibm.com>
Date:   Fri Mar 20 20:39:45 2015 +1100

    KVM: PPC: Book3S HV: Add guest->host real mode completion counters
    
    Add counters to track number of times we switch from guest real mode
    to host virtual mode during an interrupt-related hyper call because the
    hypercall requires actions that cannot be completed in real mode. This
    will help when making optimizations that reduce guest-host transitions.
    
    It is safe to use an ordinary increment rather than an atomic operation
    because there is one ICP per virtual CPU and kvmppc_xics_rm_complete()
    only works on the ICP for the current VCPU.
    
    The counters are displayed as part of IPC and ICP state provided by
    /sys/debug/kernel/powerpc/kvm* for each VM.
    
    Signed-off-by: Suresh Warrier <warrier@linux.vnet.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index 73f0f2723c07..de970eca2167 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -78,6 +78,12 @@ struct kvmppc_icp {
 	u32  rm_reject;
 	u32  rm_eoied_irq;
 
+	/* Counters for each reason we exited real mode */
+	unsigned long n_rm_kick_vcpu;
+	unsigned long n_rm_check_resend;
+	unsigned long n_rm_reject;
+	unsigned long n_rm_notify_eoi;
+
 	/* Debug stuff for real mode */
 	union kvmppc_icp_state rm_dbgstate;
 	struct kvm_vcpu *rm_dbgtgt;

commit 5b88cda665bc6ae92c9bd12060c9fd0840211eb7
Author: Suresh E. Warrier <warrier@linux.vnet.ibm.com>
Date:   Mon Nov 3 15:51:59 2014 +1100

    KVM: PPC: Book3S HV: Fix inaccuracies in ICP emulation for H_IPI
    
    This fixes some inaccuracies in the state machine for the virtualized
    ICP when implementing the H_IPI hcall (Set_MFFR and related states):
    
    1. The old code wipes out any pending interrupts when the new MFRR is
       more favored than the CPPR but less favored than a pending
       interrupt (by always modifying xisr and the pending_pri). This can
       cause us to lose a pending external interrupt.
    
       The correct code here is to only modify the pending_pri and xisr in
       the ICP if the MFRR is equal to or more favored than the current
       pending pri (since in this case, it is guaranteed that that there
       cannot be a pending external interrupt). The code changes are
       required in both kvmppc_rm_h_ipi and kvmppc_h_ipi.
    
    2. Again, in both kvmppc_rm_h_ipi and kvmppc_h_ipi, there is a check
       for whether MFRR is being made less favored AND further if new MFFR
       is also less favored than the current CPPR, we check for any
       resends pending in the ICP. These checks look like they are
       designed to cover the case where if the MFRR is being made less
       favored, we opportunistically trigger a resend of any interrupts
       that had been previously rejected. Although, this is not a state
       described by PAPR, this is an action we actually need to do
       especially if the CPPR is already at 0xFF.  Because in this case,
       the resend bit will stay on until another ICP state change which
       may be a long time coming and the interrupt stays pending until
       then. The current code which checks for MFRR < CPPR is broken when
       CPPR is 0xFF since it will not get triggered in that case.
    
       Ideally, we would want to do a resend only if
    
            prio(pending_interrupt) < mfrr && prio(pending_interrupt) < cppr
    
       where pending interrupt is the one that was rejected. But we don't
       have the priority of the pending interrupt state saved, so we
       simply trigger a resend whenever the MFRR is made less favored.
    
    3. In kvmppc_rm_h_ipi, where we save state to pass resends to the
       virtual mode, we also need to save the ICP whose need_resend we
       reset since this does not need to be my ICP (vcpu->arch.icp) as is
       incorrectly assumed by the current code. A new field rm_resend_icp
       is added to the kvmppc_icp structure for this purpose.
    
    Signed-off-by: Suresh Warrier <warrier@linux.vnet.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index e8aaa7a3f209..73f0f2723c07 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -74,6 +74,7 @@ struct kvmppc_icp {
 #define XICS_RM_NOTIFY_EOI	0x8
 	u32 rm_action;
 	struct kvm_vcpu *rm_kick_target;
+	struct kvmppc_icp *rm_resend_icp;
 	u32  rm_reject;
 	u32  rm_eoied_irq;
 

commit 25a2150bee00b4d996487552948b9b3ba21d0257
Author: Paul Mackerras <paulus@samba.org>
Date:   Mon Jun 30 20:51:14 2014 +1000

    KVM: PPC: Enable IRQFD support for the XICS interrupt controller
    
    This makes it possible to use IRQFDs on platforms that use the XICS
    interrupt controller.  To do this we implement kvm_irq_map_gsi() and
    kvm_irq_map_chip_pin() in book3s_xics.c, so as to provide a 1-1 mapping
    between global interrupt numbers and XICS interrupt source numbers.
    For now, all interrupts are mapped as "IRQCHIP" interrupts, and no
    MSI support is provided.
    
    This means that kvm_set_irq can now get called with level == 0 or 1
    as well as the powerpc-specific values KVM_INTERRUPT_SET,
    KVM_INTERRUPT_UNSET and KVM_INTERRUPT_SET_LEVEL.  We change
    ics_deliver_irq() to accept all those values, and remove its
    report_status argument, as it is always false, given that we don't
    support KVM_IRQ_LINE_STATUS.
    
    This also adds support for interrupt ack notifiers to the XICS code
    so that the IRQFD resampler functionality can be supported.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Tested-by: Eric Auger <eric.auger@linaro.org>
    Tested-by: Cornelia Huck <cornelia.huck@de.ibm.com>
    Signed-off-by: Paolo Bonzini <pbonzini@redhat.com>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index dd9326c5c19b..e8aaa7a3f209 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -71,9 +71,11 @@ struct kvmppc_icp {
 #define XICS_RM_KICK_VCPU	0x1
 #define XICS_RM_CHECK_RESEND	0x2
 #define XICS_RM_REJECT		0x4
+#define XICS_RM_NOTIFY_EOI	0x8
 	u32 rm_action;
 	struct kvm_vcpu *rm_kick_target;
 	u32  rm_reject;
+	u32  rm_eoied_irq;
 
 	/* Debug stuff for real mode */
 	union kvmppc_icp_state rm_dbgstate;

commit 5975a2e0950291a6bfe9fd5880e7952ff87764be
Author: Paul Mackerras <paulus@samba.org>
Date:   Sat Apr 27 00:28:37 2013 +0000

    KVM: PPC: Book3S: Add API for in-kernel XICS emulation
    
    This adds the API for userspace to instantiate an XICS device in a VM
    and connect VCPUs to it.  The API consists of a new device type for
    the KVM_CREATE_DEVICE ioctl, a new capability KVM_CAP_IRQ_XICS, which
    functions similarly to KVM_CAP_IRQ_MPIC, and the KVM_IRQ_LINE ioctl,
    which is used to assert and deassert interrupt inputs of the XICS.
    
    The XICS device has one attribute group, KVM_DEV_XICS_GRP_SOURCES.
    Each attribute within this group corresponds to the state of one
    interrupt source.  The attribute number is the same as the interrupt
    source number.
    
    This does not support irq routing or irqfd yet.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Acked-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index e4fdec3dde77..dd9326c5c19b 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -88,6 +88,7 @@ struct kvmppc_ics {
 
 struct kvmppc_xics {
 	struct kvm *kvm;
+	struct kvm_device *dev;
 	struct dentry *dentry;
 	u32 max_icsid;
 	bool real_mode;

commit d19bd86204f85d42873e07bb64a27587fc380b5b
Author: Paul Mackerras <paulus@samba.org>
Date:   Wed Apr 17 20:32:04 2013 +0000

    KVM: PPC: Book3S: Add support for ibm,int-on/off RTAS calls
    
    This adds support for the ibm,int-on and ibm,int-off RTAS calls to the
    in-kernel XICS emulation and corrects the handling of the saved
    priority by the ibm,set-xive RTAS call.  With this, ibm,int-off sets
    the specified interrupt's priority in its saved_priority field and
    sets the priority to 0xff (the least favoured value).  ibm,int-on
    restores the saved_priority to the priority field, and ibm,set-xive
    sets both the priority and the saved_priority to the specified
    priority value.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index c816c5a49c90..e4fdec3dde77 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -36,7 +36,7 @@ struct ics_irq_state {
 	u32 number;
 	u32 server;
 	u8  priority;
-	u8  saved_priority; /* currently unused */
+	u8  saved_priority;
 	u8  resend;
 	u8  masked_pending;
 	u8  asserted; /* Only for LSI */

commit e7d26f285b4be9466c9e393139e1c9cffe4cedfc
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Apr 17 20:31:15 2013 +0000

    KVM: PPC: Book3S HV: Add support for real mode ICP in XICS emulation
    
    This adds an implementation of the XICS hypercalls in real mode for HV
    KVM, which allows us to avoid exiting the guest MMU context on all
    threads for a variety of operations such as fetching a pending
    interrupt, EOI of messages, IPIs, etc.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
index 58ee190de5e5..c816c5a49c90 100644
--- a/arch/powerpc/kvm/book3s_xics.h
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -64,6 +64,20 @@ struct kvmppc_icp {
 	unsigned long server_num;
 	union kvmppc_icp_state state;
 	unsigned long resend_map[ICP_RESEND_MAP_SIZE];
+
+	/* Real mode might find something too hard, here's the action
+	 * it might request from virtual mode
+	 */
+#define XICS_RM_KICK_VCPU	0x1
+#define XICS_RM_CHECK_RESEND	0x2
+#define XICS_RM_REJECT		0x4
+	u32 rm_action;
+	struct kvm_vcpu *rm_kick_target;
+	u32  rm_reject;
+
+	/* Debug stuff for real mode */
+	union kvmppc_icp_state rm_dbgstate;
+	struct kvm_vcpu *rm_dbgtgt;
 };
 
 struct kvmppc_ics {
@@ -76,6 +90,8 @@ struct kvmppc_xics {
 	struct kvm *kvm;
 	struct dentry *dentry;
 	u32 max_icsid;
+	bool real_mode;
+	bool real_mode_dbg;
 	struct kvmppc_ics *ics[KVMPPC_XICS_MAX_ICS_ID + 1];
 };
 

commit bc5ad3f3701116e7db57268e6f89010ec714697e
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Apr 17 20:30:26 2013 +0000

    KVM: PPC: Book3S: Add kernel emulation for the XICS interrupt controller
    
    This adds in-kernel emulation of the XICS (eXternal Interrupt
    Controller Specification) interrupt controller specified by PAPR, for
    both HV and PR KVM guests.
    
    The XICS emulation supports up to 1048560 interrupt sources.
    Interrupt source numbers below 16 are reserved; 0 is used to mean no
    interrupt and 2 is used for IPIs.  Internally these are represented in
    blocks of 1024, called ICS (interrupt controller source) entities, but
    that is not visible to userspace.
    
    Each vcpu gets one ICP (interrupt controller presentation) entity,
    used to store the per-vcpu state such as vcpu priority, pending
    interrupt state, IPI request, etc.
    
    This does not include any API or any way to connect vcpus to their
    ICP state; that will be added in later patches.
    
    This is based on an initial implementation by Michael Ellerman
    <michael@ellerman.id.au> reworked by Benjamin Herrenschmidt and
    Paul Mackerras.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    [agraf: fix typo, add dependency on !KVM_MPIC]
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/arch/powerpc/kvm/book3s_xics.h b/arch/powerpc/kvm/book3s_xics.h
new file mode 100644
index 000000000000..58ee190de5e5
--- /dev/null
+++ b/arch/powerpc/kvm/book3s_xics.h
@@ -0,0 +1,113 @@
+/*
+ * Copyright 2012 Michael Ellerman, IBM Corporation.
+ * Copyright 2012 Benjamin Herrenschmidt, IBM Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _KVM_PPC_BOOK3S_XICS_H
+#define _KVM_PPC_BOOK3S_XICS_H
+
+/*
+ * We use a two-level tree to store interrupt source information.
+ * There are up to 1024 ICS nodes, each of which can represent
+ * 1024 sources.
+ */
+#define KVMPPC_XICS_MAX_ICS_ID	1023
+#define KVMPPC_XICS_ICS_SHIFT	10
+#define KVMPPC_XICS_IRQ_PER_ICS	(1 << KVMPPC_XICS_ICS_SHIFT)
+#define KVMPPC_XICS_SRC_MASK	(KVMPPC_XICS_IRQ_PER_ICS - 1)
+
+/*
+ * Interrupt source numbers below this are reserved, for example
+ * 0 is "no interrupt", and 2 is used for IPIs.
+ */
+#define KVMPPC_XICS_FIRST_IRQ	16
+#define KVMPPC_XICS_NR_IRQS	((KVMPPC_XICS_MAX_ICS_ID + 1) * \
+				 KVMPPC_XICS_IRQ_PER_ICS)
+
+/* Priority value to use for disabling an interrupt */
+#define MASKED	0xff
+
+/* State for one irq source */
+struct ics_irq_state {
+	u32 number;
+	u32 server;
+	u8  priority;
+	u8  saved_priority; /* currently unused */
+	u8  resend;
+	u8  masked_pending;
+	u8  asserted; /* Only for LSI */
+	u8  exists;
+};
+
+/* Atomic ICP state, updated with a single compare & swap */
+union kvmppc_icp_state {
+	unsigned long raw;
+	struct {
+		u8 out_ee:1;
+		u8 need_resend:1;
+		u8 cppr;
+		u8 mfrr;
+		u8 pending_pri;
+		u32 xisr;
+	};
+};
+
+/* One bit per ICS */
+#define ICP_RESEND_MAP_SIZE	(KVMPPC_XICS_MAX_ICS_ID / BITS_PER_LONG + 1)
+
+struct kvmppc_icp {
+	struct kvm_vcpu *vcpu;
+	unsigned long server_num;
+	union kvmppc_icp_state state;
+	unsigned long resend_map[ICP_RESEND_MAP_SIZE];
+};
+
+struct kvmppc_ics {
+	struct mutex lock;
+	u16 icsid;
+	struct ics_irq_state irq_state[KVMPPC_XICS_IRQ_PER_ICS];
+};
+
+struct kvmppc_xics {
+	struct kvm *kvm;
+	struct dentry *dentry;
+	u32 max_icsid;
+	struct kvmppc_ics *ics[KVMPPC_XICS_MAX_ICS_ID + 1];
+};
+
+static inline struct kvmppc_icp *kvmppc_xics_find_server(struct kvm *kvm,
+							 u32 nr)
+{
+	struct kvm_vcpu *vcpu = NULL;
+	int i;
+
+	kvm_for_each_vcpu(i, vcpu, kvm) {
+		if (vcpu->arch.icp && nr == vcpu->arch.icp->server_num)
+			return vcpu->arch.icp;
+	}
+	return NULL;
+}
+
+static inline struct kvmppc_ics *kvmppc_xics_find_ics(struct kvmppc_xics *xics,
+						      u32 irq, u16 *source)
+{
+	u32 icsid = irq >> KVMPPC_XICS_ICS_SHIFT;
+	u16 src = irq & KVMPPC_XICS_SRC_MASK;
+	struct kvmppc_ics *ics;
+
+	if (source)
+		*source = src;
+	if (icsid > KVMPPC_XICS_MAX_ICS_ID)
+		return NULL;
+	ics = xics->ics[icsid];
+	if (!ics)
+		return NULL;
+	return ics;
+}
+
+
+#endif /* _KVM_PPC_BOOK3S_XICS_H */
