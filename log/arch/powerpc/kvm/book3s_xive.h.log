commit 062cfab7069fcb55d77ad5552f29e24178728fa2
Author: Greg Kurz <groug@kaod.org>
Date:   Fri Sep 27 13:54:01 2019 +0200

    KVM: PPC: Book3S HV: XIVE: Make VP block size configurable
    
    The XIVE VP is an internal structure which allow the XIVE interrupt
    controller to maintain the interrupt context state of vCPUs non
    dispatched on HW threads.
    
    When a guest is started, the XIVE KVM device allocates a block of
    XIVE VPs in OPAL, enough to accommodate the highest possible vCPU
    id KVM_MAX_VCPU_ID (16384) packed down to KVM_MAX_VCPUS (2048).
    With a guest's core stride of 8 and a threading mode of 1 (QEMU's
    default), a VM must run at least 256 vCPUs to actually need such a
    range of VPs.
    
    A POWER9 system has a limited XIVE VP space : 512k and KVM is
    currently wasting this HW resource with large VP allocations,
    especially since a typical VM likely runs with a lot less vCPUs.
    
    Make the size of the VP block configurable. Add an nr_servers
    field to the XIVE structure and a function to set it for this
    purpose.
    
    Split VP allocation out of the device create function. Since the
    VP block isn't used before the first vCPU connects to the XIVE KVM
    device, allocation is now performed by kvmppc_xive_connect_vcpu().
    This gives the opportunity to set nr_servers in between:
    
              kvmppc_xive_create() / kvmppc_xive_native_create()
                                   .
                                   .
                         kvmppc_xive_set_nr_servers()
                                   .
                                   .
        kvmppc_xive_connect_vcpu() / kvmppc_xive_native_connect_vcpu()
    
    The connect_vcpu() functions check that the vCPU id is below nr_servers
    and if it is the first vCPU they allocate the VP block. This is protected
    against a concurrent update of nr_servers by kvmppc_xive_set_nr_servers()
    with the xive->lock mutex.
    
    Also, the block is allocated once for the device lifetime: nr_servers
    should stay constant otherwise connect_vcpu() could generate a boggus
    VP id and likely crash OPAL. It is thus forbidden to update nr_servers
    once the block is allocated.
    
    If the VP allocation fail, return ENOSPC which seems more appropriate to
    report the depletion of system wide HW resource than ENOMEM or ENXIO.
    
    A VM using a stride of 8 and 1 thread per core with 32 vCPUs would hence
    only need 256 VPs instead of 2048. If the stride is set to match the number
    of threads per core, this goes further down to 32.
    
    This will be exposed to userspace by a subsequent patch.
    
    Signed-off-by: Greg Kurz <groug@kaod.org>
    Reviewed-by: CÃ©dric Le Goater <clg@kaod.org>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index 90cf6ec35a68..382e3a56e789 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -135,6 +135,9 @@ struct kvmppc_xive {
 	/* Flags */
 	u8	single_escalation;
 
+	/* Number of entries in the VP block */
+	u32	nr_servers;
+
 	struct kvmppc_xive_ops *ops;
 	struct address_space   *mapping;
 	struct mutex mapping_lock;
@@ -297,6 +300,7 @@ struct kvmppc_xive *kvmppc_xive_get_device(struct kvm *kvm, u32 type);
 void xive_cleanup_single_escalation(struct kvm_vcpu *vcpu,
 				    struct kvmppc_xive_vcpu *xc, int irq);
 int kvmppc_xive_compute_vp_id(struct kvmppc_xive *xive, u32 cpu, u32 *vp);
+int kvmppc_xive_set_nr_servers(struct kvmppc_xive *xive, u64 addr);
 
 #endif /* CONFIG_KVM_XICS */
 #endif /* _KVM_PPC_BOOK3S_XICS_H */

commit 8db29ea2391cc6f5b73cc9c04b2dee4409b9fc05
Author: Greg Kurz <groug@kaod.org>
Date:   Fri Sep 27 13:53:55 2019 +0200

    KVM: PPC: Book3S HV: XIVE: Compute the VP id in a common helper
    
    Reduce code duplication by consolidating the checking of vCPU ids and VP
    ids to a common helper used by both legacy and native XIVE KVM devices.
    And explain the magic with a comment.
    
    Signed-off-by: Greg Kurz <groug@kaod.org>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index fe3ed50e0818..90cf6ec35a68 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -296,6 +296,7 @@ int kvmppc_xive_attach_escalation(struct kvm_vcpu *vcpu, u8 prio,
 struct kvmppc_xive *kvmppc_xive_get_device(struct kvm *kvm, u32 type);
 void xive_cleanup_single_escalation(struct kvm_vcpu *vcpu,
 				    struct kvmppc_xive_vcpu *xc, int irq);
+int kvmppc_xive_compute_vp_id(struct kvmppc_xive *xive, u32 cpu, u32 *vp);
 
 #endif /* CONFIG_KVM_XICS */
 #endif /* _KVM_PPC_BOOK3S_XICS_H */

commit 12ade69c1eb9958b13374edf5ef742ea20ccffde
Author: Greg Kurz <groug@kaod.org>
Date:   Fri Sep 27 13:53:43 2019 +0200

    KVM: PPC: Book3S HV: XIVE: Ensure VP isn't already in use
    
    Connecting a vCPU to a XIVE KVM device means establishing a 1:1
    association between a vCPU id and the offset (VP id) of a VP
    structure within a fixed size block of VPs. We currently try to
    enforce the 1:1 relationship by checking that a vCPU with the
    same id isn't already connected. This is good but unfortunately
    not enough because we don't map VP ids to raw vCPU ids but to
    packed vCPU ids, and the packing function kvmppc_pack_vcpu_id()
    isn't bijective by design. We got away with it because QEMU passes
    vCPU ids that fit well in the packing pattern. But nothing prevents
    userspace to come up with a forged vCPU id resulting in a packed id
    collision which causes the KVM device to associate two vCPUs to the
    same VP. This greatly confuses the irq layer and ultimately crashes
    the kernel, as shown below.
    
    Example: a guest with 1 guest thread per core, a core stride of
    8 and 300 vCPUs has vCPU ids 0,8,16...2392. If QEMU is patched to
    inject at some point an invalid vCPU id 348, which is the packed
    version of itself and 2392, we get:
    
    genirq: Flags mismatch irq 199. 00010000 (kvm-2-2392) vs. 00010000 (kvm-2-348)
    CPU: 24 PID: 88176 Comm: qemu-system-ppc Not tainted 5.3.0-xive-nr-servers-5.3-gku+ #38
    Call Trace:
    [c000003f7f9937e0] [c000000000c0110c] dump_stack+0xb0/0xf4 (unreliable)
    [c000003f7f993820] [c0000000001cb480] __setup_irq+0xa70/0xad0
    [c000003f7f9938d0] [c0000000001cb75c] request_threaded_irq+0x13c/0x260
    [c000003f7f993940] [c00800000d44e7ac] kvmppc_xive_attach_escalation+0x104/0x270 [kvm]
    [c000003f7f9939d0] [c00800000d45013c] kvmppc_xive_connect_vcpu+0x424/0x620 [kvm]
    [c000003f7f993ac0] [c00800000d444428] kvm_arch_vcpu_ioctl+0x260/0x448 [kvm]
    [c000003f7f993b90] [c00800000d43593c] kvm_vcpu_ioctl+0x154/0x7c8 [kvm]
    [c000003f7f993d00] [c0000000004840f0] do_vfs_ioctl+0xe0/0xc30
    [c000003f7f993db0] [c000000000484d44] ksys_ioctl+0x104/0x120
    [c000003f7f993e00] [c000000000484d88] sys_ioctl+0x28/0x80
    [c000003f7f993e20] [c00000000000b278] system_call+0x5c/0x68
    xive-kvm: Failed to request escalation interrupt for queue 0 of VCPU 2392
    ------------[ cut here ]------------
    remove_proc_entry: removing non-empty directory 'irq/199', leaking at least 'kvm-2-348'
    WARNING: CPU: 24 PID: 88176 at /home/greg/Work/linux/kernel-kvm-ppc/fs/proc/generic.c:684 remove_proc_entry+0x1ec/0x200
    Modules linked in: kvm_hv kvm dm_mod vhost_net vhost tap xt_CHECKSUM iptable_mangle xt_MASQUERADE iptable_nat nf_nat xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ipt_REJECT nf_reject_ipv4 tun bridge stp llc ebtable_filter ebtables ip6table_filter ip6_tables iptable_filter squashfs loop fuse i2c_dev sg ofpart ocxl powernv_flash at24 xts mtd uio_pdrv_genirq vmx_crypto opal_prd ipmi_powernv uio ipmi_devintf ipmi_msghandler ibmpowernv ib_iser rdma_cm iw_cm ib_cm ib_core iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi ip_tables ext4 mbcache jbd2 raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor xor async_tx raid6_pq libcrc32c raid1 raid0 linear sd_mod ast i2c_algo_bit drm_vram_helper ttm drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm ahci libahci libata tg3 drm_panel_orientation_quirks [last unloaded: kvm]
    CPU: 24 PID: 88176 Comm: qemu-system-ppc Not tainted 5.3.0-xive-nr-servers-5.3-gku+ #38
    NIP:  c00000000053b0cc LR: c00000000053b0c8 CTR: c0000000000ba3b0
    REGS: c000003f7f9934b0 TRAP: 0700   Not tainted  (5.3.0-xive-nr-servers-5.3-gku+)
    MSR:  9000000000029033 <SF,HV,EE,ME,IR,DR,RI,LE>  CR: 48228222  XER: 20040000
    CFAR: c000000000131a50 IRQMASK: 0
    GPR00: c00000000053b0c8 c000003f7f993740 c0000000015ec500 0000000000000057
    GPR04: 0000000000000001 0000000000000000 000049fb98484262 0000000000001bcf
    GPR08: 0000000000000007 0000000000000007 0000000000000001 9000000000001033
    GPR12: 0000000000008000 c000003ffffeb800 0000000000000000 000000012f4ce5a1
    GPR16: 000000012ef5a0c8 0000000000000000 000000012f113bb0 0000000000000000
    GPR20: 000000012f45d918 c000003f863758b0 c000003f86375870 0000000000000006
    GPR24: c000003f86375a30 0000000000000007 c0002039373d9020 c0000000014c4a48
    GPR28: 0000000000000001 c000003fe62a4f6b c00020394b2e9fab c000003fe62a4ec0
    NIP [c00000000053b0cc] remove_proc_entry+0x1ec/0x200
    LR [c00000000053b0c8] remove_proc_entry+0x1e8/0x200
    Call Trace:
    [c000003f7f993740] [c00000000053b0c8] remove_proc_entry+0x1e8/0x200 (unreliable)
    [c000003f7f9937e0] [c0000000001d3654] unregister_irq_proc+0x114/0x150
    [c000003f7f993880] [c0000000001c6284] free_desc+0x54/0xb0
    [c000003f7f9938c0] [c0000000001c65ec] irq_free_descs+0xac/0x100
    [c000003f7f993910] [c0000000001d1ff8] irq_dispose_mapping+0x68/0x80
    [c000003f7f993940] [c00800000d44e8a4] kvmppc_xive_attach_escalation+0x1fc/0x270 [kvm]
    [c000003f7f9939d0] [c00800000d45013c] kvmppc_xive_connect_vcpu+0x424/0x620 [kvm]
    [c000003f7f993ac0] [c00800000d444428] kvm_arch_vcpu_ioctl+0x260/0x448 [kvm]
    [c000003f7f993b90] [c00800000d43593c] kvm_vcpu_ioctl+0x154/0x7c8 [kvm]
    [c000003f7f993d00] [c0000000004840f0] do_vfs_ioctl+0xe0/0xc30
    [c000003f7f993db0] [c000000000484d44] ksys_ioctl+0x104/0x120
    [c000003f7f993e00] [c000000000484d88] sys_ioctl+0x28/0x80
    [c000003f7f993e20] [c00000000000b278] system_call+0x5c/0x68
    Instruction dump:
    2c230000 41820008 3923ff78 e8e900a0 3c82ff69 3c62ff8d 7fa6eb78 7fc5f378
    3884f080 3863b948 4bbf6925 60000000 <0fe00000> 4bffff7c fba10088 4bbf6e41
    ---[ end trace b925b67a74a1d8d1 ]---
    BUG: Kernel NULL pointer dereference at 0x00000010
    Faulting instruction address: 0xc00800000d44fc04
    Oops: Kernel access of bad area, sig: 11 [#1]
    LE PAGE_SIZE=64K MMU=Radix MMU=Hash SMP NR_CPUS=2048 NUMA PowerNV
    Modules linked in: kvm_hv kvm dm_mod vhost_net vhost tap xt_CHECKSUM iptable_mangle xt_MASQUERADE iptable_nat nf_nat xt_conntrack nf_conntrack nf_defrag_ipv6 nf_defrag_ipv4 ipt_REJECT nf_reject_ipv4 tun bridge stp llc ebtable_filter ebtables ip6table_filter ip6_tables iptable_filter squashfs loop fuse i2c_dev sg ofpart ocxl powernv_flash at24 xts mtd uio_pdrv_genirq vmx_crypto opal_prd ipmi_powernv uio ipmi_devintf ipmi_msghandler ibmpowernv ib_iser rdma_cm iw_cm ib_cm ib_core iscsi_tcp libiscsi_tcp libiscsi scsi_transport_iscsi ip_tables ext4 mbcache jbd2 raid10 raid456 async_raid6_recov async_memcpy async_pq async_xor xor async_tx raid6_pq libcrc32c raid1 raid0 linear sd_mod ast i2c_algo_bit drm_vram_helper ttm drm_kms_helper syscopyarea sysfillrect sysimgblt fb_sys_fops drm ahci libahci libata tg3 drm_panel_orientation_quirks [last unloaded: kvm]
    CPU: 24 PID: 88176 Comm: qemu-system-ppc Tainted: G        W         5.3.0-xive-nr-servers-5.3-gku+ #38
    NIP:  c00800000d44fc04 LR: c00800000d44fc00 CTR: c0000000001cd970
    REGS: c000003f7f9938e0 TRAP: 0300   Tainted: G        W          (5.3.0-xive-nr-servers-5.3-gku+)
    MSR:  9000000000009033 <SF,HV,EE,ME,IR,DR,RI,LE>  CR: 24228882  XER: 20040000
    CFAR: c0000000001cd9ac DAR: 0000000000000010 DSISR: 40000000 IRQMASK: 0
    GPR00: c00800000d44fc00 c000003f7f993b70 c00800000d468300 0000000000000000
    GPR04: 00000000000000c7 0000000000000000 0000000000000000 c000003ffacd06d8
    GPR08: 0000000000000000 c000003ffacd0738 0000000000000000 fffffffffffffffd
    GPR12: 0000000000000040 c000003ffffeb800 0000000000000000 000000012f4ce5a1
    GPR16: 000000012ef5a0c8 0000000000000000 000000012f113bb0 0000000000000000
    GPR20: 000000012f45d918 00007ffffe0d9a80 000000012f4f5df0 000000012ef8c9f8
    GPR24: 0000000000000001 0000000000000000 c000003fe4501ed0 c000003f8b1d0000
    GPR28: c0000033314689c0 c000003fe4501c00 c000003fe4501e70 c000003fe4501e90
    NIP [c00800000d44fc04] kvmppc_xive_cleanup_vcpu+0xfc/0x210 [kvm]
    LR [c00800000d44fc00] kvmppc_xive_cleanup_vcpu+0xf8/0x210 [kvm]
    Call Trace:
    [c000003f7f993b70] [c00800000d44fc00] kvmppc_xive_cleanup_vcpu+0xf8/0x210 [kvm] (unreliable)
    [c000003f7f993bd0] [c00800000d450bd4] kvmppc_xive_release+0xdc/0x1b0 [kvm]
    [c000003f7f993c30] [c00800000d436a98] kvm_device_release+0xb0/0x110 [kvm]
    [c000003f7f993c70] [c00000000046730c] __fput+0xec/0x320
    [c000003f7f993cd0] [c000000000164ae0] task_work_run+0x150/0x1c0
    [c000003f7f993d30] [c000000000025034] do_notify_resume+0x304/0x440
    [c000003f7f993e20] [c00000000000dcc4] ret_from_except_lite+0x70/0x74
    Instruction dump:
    3bff0008 7fbfd040 419e0054 847e0004 2fa30000 419effec e93d0000 8929203c
    2f890000 419effb8 4800821d e8410018 <e9230010> e9490008 9b2a0039 7c0004ac
    ---[ end trace b925b67a74a1d8d2 ]---
    
    Kernel panic - not syncing: Fatal exception
    
    This affects both XIVE and XICS-on-XIVE devices since the beginning.
    
    Check the VP id instead of the vCPU id when a new vCPU is connected.
    The allocation of the XIVE CPU structure in kvmppc_xive_connect_vcpu()
    is moved after the check to avoid the need for rollback.
    
    Cc: stable@vger.kernel.org # v4.12+
    Signed-off-by: Greg Kurz <groug@kaod.org>
    Reviewed-by: CÃ©dric Le Goater <clg@kaod.org>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index 955b820ffd6d..fe3ed50e0818 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -220,6 +220,18 @@ static inline u32 kvmppc_xive_vp(struct kvmppc_xive *xive, u32 server)
 	return xive->vp_base + kvmppc_pack_vcpu_id(xive->kvm, server);
 }
 
+static inline bool kvmppc_xive_vp_in_use(struct kvm *kvm, u32 vp_id)
+{
+	struct kvm_vcpu *vcpu = NULL;
+	int i;
+
+	kvm_for_each_vcpu(i, vcpu, kvm) {
+		if (vcpu->arch.xive_vcpu && vp_id == vcpu->arch.xive_vcpu->vp_id)
+			return true;
+	}
+	return false;
+}
+
 /*
  * Mapping between guest priorities and host priorities
  * is as follow.

commit da15c03b047dca891d37b9f4ef9ca14d84a6484f
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Tue Aug 13 20:06:48 2019 +1000

    powerpc/xive: Implement get_irqchip_state method for XIVE to fix shutdown race
    
    Testing has revealed the existence of a race condition where a XIVE
    interrupt being shut down can be in one of the XIVE interrupt queues
    (of which there are up to 8 per CPU, one for each priority) at the
    point where free_irq() is called.  If this happens, can return an
    interrupt number which has been shut down.  This can lead to various
    symptoms:
    
    - irq_to_desc(irq) can be NULL.  In this case, no end-of-interrupt
      function gets called, resulting in the CPU's elevated interrupt
      priority (numerically lowered CPPR) never gets reset.  That then
      means that the CPU stops processing interrupts, causing device
      timeouts and other errors in various device drivers.
    
    - The irq descriptor or related data structures can be in the process
      of being freed as the interrupt code is using them.  This typically
      leads to crashes due to bad pointer dereferences.
    
    This race is basically what commit 62e0468650c3 ("genirq: Add optional
    hardware synchronization for shutdown", 2019-06-28) is intended to
    fix, given a get_irqchip_state() method for the interrupt controller
    being used.  It works by polling the interrupt controller when an
    interrupt is being freed until the controller says it is not pending.
    
    With XIVE, the PQ bits of the interrupt source indicate the state of
    the interrupt source, and in particular the P bit goes from 0 to 1 at
    the point where the hardware writes an entry into the interrupt queue
    that this interrupt is directed towards.  Normally, the code will then
    process the interrupt and do an end-of-interrupt (EOI) operation which
    will reset PQ to 00 (assuming another interrupt hasn't been generated
    in the meantime).  However, there are situations where the code resets
    P even though a queue entry exists (for example, by setting PQ to 01,
    which disables the interrupt source), and also situations where the
    code leaves P at 1 after removing the queue entry (for example, this
    is done for escalation interrupts so they cannot fire again until
    they are explicitly re-enabled).
    
    The code already has a 'saved_p' flag for the interrupt source which
    indicates that a queue entry exists, although it isn't maintained
    consistently.  This patch adds a 'stale_p' flag to indicate that
    P has been left at 1 after processing a queue entry, and adds code
    to set and clear saved_p and stale_p as necessary to maintain a
    consistent indication of whether a queue entry may or may not exist.
    
    With this, we can implement xive_get_irqchip_state() by looking at
    stale_p, saved_p and the ESB PQ bits for the interrupt.
    
    There is some additional code to handle escalation interrupts
    properly; because they are enabled and disabled in KVM assembly code,
    which does not have access to the xive_irq_data struct for the
    escalation interrupt.  Hence, stale_p may be incorrect when the
    escalation interrupt is freed in kvmppc_xive_{,native_}cleanup_vcpu().
    Fortunately, we can fix it up by looking at vcpu->arch.xive_esc_on,
    with some careful attention to barriers in order to ensure the correct
    result if xive_esc_irq() races with kvmppc_xive_cleanup_vcpu().
    
    Finally, this adds code to make noise on the console (pr_crit and
    WARN_ON(1)) if we find an interrupt queue entry for an interrupt
    which does not have a descriptor.  While this won't catch the race
    reliably, if it does get triggered it will be an indication that
    the race is occurring and needs to be debugged.
    
    Fixes: 243e25112d06 ("powerpc/xive: Native exploitation of the XIVE interrupt controller")
    Cc: stable@vger.kernel.org # v4.12+
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20190813100648.GE9567@blackberry

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index 50494d0ee375..955b820ffd6d 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -282,6 +282,8 @@ int kvmppc_xive_select_target(struct kvm *kvm, u32 *server, u8 prio);
 int kvmppc_xive_attach_escalation(struct kvm_vcpu *vcpu, u8 prio,
 				  bool single_escalation);
 struct kvmppc_xive *kvmppc_xive_get_device(struct kvm *kvm, u32 type);
+void xive_cleanup_single_escalation(struct kvm_vcpu *vcpu,
+				    struct kvmppc_xive_vcpu *xc, int irq);
 
 #endif /* CONFIG_KVM_XICS */
 #endif /* _KVM_PPC_BOOK3S_XICS_H */

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index 862c2c9650ae..50494d0ee375 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -1,9 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright 2017 Benjamin Herrenschmidt, IBM Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License, version 2, as
- * published by the Free Software Foundation.
  */
 
 #ifndef _KVM_PPC_BOOK3S_XIVE_H

commit 7e10b9a6da619bcee243980d9c45112761a86e11
Author: CÃ©dric Le Goater <clg@kaod.org>
Date:   Fri May 24 15:20:30 2019 +0200

    KVM: PPC: Book3S HV: XIVE: Introduce a new mutex for the XIVE device
    
    The XICS-on-XIVE KVM device needs to allocate XIVE event queues when a
    priority is used by the OS. This is referred as EQ provisioning and it
    is done under the hood when :
    
      1. a CPU is hot-plugged in the VM
      2. the "set-xive" is called at VM startup
      3. sources are restored at VM restore
    
    The kvm->lock mutex is used to protect the different XIVE structures
    being modified but in some contexts, kvm->lock is taken under the
    vcpu->mutex which is not permitted by the KVM locking rules.
    
    Introduce a new mutex 'lock' for the KVM devices for them to
    synchronize accesses to the XIVE device structures.
    
    Reviewed-by: Greg Kurz <groug@kaod.org>
    Signed-off-by: CÃ©dric Le Goater <clg@kaod.org>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index 426146332984..862c2c9650ae 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -141,6 +141,7 @@ struct kvmppc_xive {
 	struct kvmppc_xive_ops *ops;
 	struct address_space   *mapping;
 	struct mutex mapping_lock;
+	struct mutex lock;
 };
 
 #define KVMPPC_XIVE_Q_COUNT	8

commit 5422e95103cf9663bc86cf1056a3ea44c2e2f09e
Author: CÃ©dric Le Goater <clg@kaod.org>
Date:   Thu Apr 18 12:39:42 2019 +0200

    KVM: PPC: Book3S HV: XIVE: Replace the 'destroy' method by a 'release' method
    
    When a P9 sPAPR VM boots, the CAS negotiation process determines which
    interrupt mode to use (XICS legacy or XIVE native) and invokes a
    machine reset to activate the chosen mode.
    
    We introduce 'release' methods for the XICS-on-XIVE and the XIVE
    native KVM devices which are called when the file descriptor of the
    device is closed after the TIMA and ESB pages have been unmapped.
    They perform the necessary cleanups : clear the vCPU interrupt
    presenters that could be attached and then destroy the device. The
    'release' methods replace the 'destroy' methods as 'destroy' is not
    called anymore once 'release' is. Compatibility with older QEMU is
    nevertheless maintained.
    
    This is not considered as a safe operation as the vCPUs are still
    running and could be referencing the KVM device through their
    presenters. To protect the system from any breakage, the kvmppc_xive
    objects representing both KVM devices are now stored in an array under
    the VM. Allocation is performed on first usage and memory is freed
    only when the VM exits.
    
    [paulus@ozlabs.org - Moved freeing of xive structures to book3s.c,
     put it under #ifdef CONFIG_KVM_XICS.]
    
    Signed-off-by: CÃ©dric Le Goater <clg@kaod.org>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index e011622dc038..426146332984 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -283,6 +283,7 @@ void kvmppc_xive_free_sources(struct kvmppc_xive_src_block *sb);
 int kvmppc_xive_select_target(struct kvm *kvm, u32 *server, u8 prio);
 int kvmppc_xive_attach_escalation(struct kvm_vcpu *vcpu, u8 prio,
 				  bool single_escalation);
+struct kvmppc_xive *kvmppc_xive_get_device(struct kvm *kvm, u32 type);
 
 #endif /* CONFIG_KVM_XICS */
 #endif /* _KVM_PPC_BOOK3S_XICS_H */

commit 232b984b7d55e68971962f07f1dd1d1eb1be52e0
Author: CÃ©dric Le Goater <clg@kaod.org>
Date:   Thu Apr 18 12:39:39 2019 +0200

    KVM: PPC: Book3S HV: XIVE: Add passthrough support
    
    The KVM XICS-over-XIVE device and the proposed KVM XIVE native device
    implement an IRQ space for the guest using the generic IPI interrupts
    of the XIVE IC controller. These interrupts are allocated at the OPAL
    level and "mapped" into the guest IRQ number space in the range 0-0x1FFF.
    Interrupt management is performed in the XIVE way: using loads and
    stores on the addresses of the XIVE IPI interrupt ESB pages.
    
    Both KVM devices share the same internal structure caching information
    on the interrupts, among which the xive_irq_data struct containing the
    addresses of the IPI ESB pages and an extra one in case of pass-through.
    The later contains the addresses of the ESB pages of the underlying HW
    controller interrupts, PHB4 in all cases for now.
    
    A guest, when running in the XICS legacy interrupt mode, lets the KVM
    XICS-over-XIVE device "handle" interrupt management, that is to
    perform the loads and stores on the addresses of the ESB pages of the
    guest interrupts. However, when running in XIVE native exploitation
    mode, the KVM XIVE native device exposes the interrupt ESB pages to
    the guest and lets the guest perform directly the loads and stores.
    
    The VMA exposing the ESB pages make use of a custom VM fault handler
    which role is to populate the VMA with appropriate pages. When a fault
    occurs, the guest IRQ number is deduced from the offset, and the ESB
    pages of associated XIVE IPI interrupt are inserted in the VMA (using
    the internal structure caching information on the interrupts).
    
    Supporting device passthrough in the guest running in XIVE native
    exploitation mode adds some extra refinements because the ESB pages
    of a different HW controller (PHB4) need to be exposed to the guest
    along with the initial IPI ESB pages of the XIVE IC controller. But
    the overall mechanic is the same.
    
    When the device HW irqs are mapped into or unmapped from the guest
    IRQ number space, the passthru_irq helpers, kvmppc_xive_set_mapped()
    and kvmppc_xive_clr_mapped(), are called to record or clear the
    passthrough interrupt information and to perform the switch.
    
    The approach taken by this patch is to clear the ESB pages of the
    guest IRQ number being mapped and let the VM fault handler repopulate.
    The handler will insert the ESB page corresponding to the HW interrupt
    of the device being passed-through or the initial IPI ESB page if the
    device is being removed.
    
    Signed-off-by: CÃ©dric Le Goater <clg@kaod.org>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index 622f594d93e1..e011622dc038 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -94,6 +94,11 @@ struct kvmppc_xive_src_block {
 	struct kvmppc_xive_irq_state irq_state[KVMPPC_XICS_IRQ_PER_ICS];
 };
 
+struct kvmppc_xive;
+
+struct kvmppc_xive_ops {
+	int (*reset_mapped)(struct kvm *kvm, unsigned long guest_irq);
+};
 
 struct kvmppc_xive {
 	struct kvm *kvm;
@@ -132,6 +137,10 @@ struct kvmppc_xive {
 
 	/* Flags */
 	u8	single_escalation;
+
+	struct kvmppc_xive_ops *ops;
+	struct address_space   *mapping;
+	struct mutex mapping_lock;
 };
 
 #define KVMPPC_XIVE_Q_COUNT	8

commit 13ce3297c5766b9541b6a7a255794c5168a7ae1a
Author: CÃ©dric Le Goater <clg@kaod.org>
Date:   Thu Apr 18 12:39:31 2019 +0200

    KVM: PPC: Book3S HV: XIVE: Add controls for the EQ configuration
    
    These controls will be used by the H_INT_SET_QUEUE_CONFIG and
    H_INT_GET_QUEUE_CONFIG hcalls from QEMU to configure the underlying
    Event Queue in the XIVE IC. They will also be used to restore the
    configuration of the XIVE EQs and to capture the internal run-time
    state of the EQs. Both 'get' and 'set' rely on an OPAL call to access
    the EQ toggle bit and EQ index which are updated by the XIVE IC when
    event notifications are enqueued in the EQ.
    
    The value of the guest physical address of the event queue is saved in
    the XIVE internal xive_q structure for later use. That is when
    migration needs to mark the EQ pages dirty to capture a consistent
    memory state of the VM.
    
    To be noted that H_INT_SET_QUEUE_CONFIG does not require the extra
    OPAL call setting the EQ toggle bit and EQ index to configure the EQ,
    but restoring the EQ state will.
    
    Signed-off-by: CÃ©dric Le Goater <clg@kaod.org>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index ae26fe653d98..622f594d93e1 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -272,6 +272,8 @@ struct kvmppc_xive_src_block *kvmppc_xive_create_src_block(
 	struct kvmppc_xive *xive, int irq);
 void kvmppc_xive_free_sources(struct kvmppc_xive_src_block *sb);
 int kvmppc_xive_select_target(struct kvm *kvm, u32 *server, u8 prio);
+int kvmppc_xive_attach_escalation(struct kvm_vcpu *vcpu, u8 prio,
+				  bool single_escalation);
 
 #endif /* CONFIG_KVM_XICS */
 #endif /* _KVM_PPC_BOOK3S_XICS_H */

commit e8676ce50e224d507946b1c535bc13584e6b49ff
Author: CÃ©dric Le Goater <clg@kaod.org>
Date:   Thu Apr 18 12:39:30 2019 +0200

    KVM: PPC: Book3S HV: XIVE: Add a control to configure a source
    
    This control will be used by the H_INT_SET_SOURCE_CONFIG hcall from
    QEMU to configure the target of a source and also to restore the
    configuration of a source when migrating the VM.
    
    The XIVE source interrupt structure is extended with the value of the
    Effective Interrupt Source Number. The EISN is the interrupt number
    pushed in the event queue that the guest OS will use to dispatch
    events internally. Caching the EISN value in KVM eases the test when
    checking if a reconfiguration is indeed needed.
    
    Signed-off-by: CÃ©dric Le Goater <clg@kaod.org>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index 1be921cb5dcb..ae26fe653d98 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -61,6 +61,9 @@ struct kvmppc_xive_irq_state {
 	bool saved_p;
 	bool saved_q;
 	u8 saved_scan_prio;
+
+	/* Xive native */
+	u32 eisn;			/* Guest Effective IRQ number */
 };
 
 /* Select the "right" interrupt (IPI vs. passthrough) */
@@ -268,6 +271,7 @@ int kvmppc_xive_debug_show_queues(struct seq_file *m, struct kvm_vcpu *vcpu);
 struct kvmppc_xive_src_block *kvmppc_xive_create_src_block(
 	struct kvmppc_xive *xive, int irq);
 void kvmppc_xive_free_sources(struct kvmppc_xive_src_block *sb);
+int kvmppc_xive_select_target(struct kvm *kvm, u32 *server, u8 prio);
 
 #endif /* CONFIG_KVM_XICS */
 #endif /* _KVM_PPC_BOOK3S_XICS_H */

commit 4131f83c3d64e591014dad14c7f8070c538b9422
Author: CÃ©dric Le Goater <clg@kaod.org>
Date:   Thu Apr 18 12:39:29 2019 +0200

    KVM: PPC: Book3S HV: XIVE: add a control to initialize a source
    
    The XIVE KVM device maintains a list of interrupt sources for the VM
    which are allocated in the pool of generic interrupts (IPIs) of the
    main XIVE IC controller. These are used for the CPU IPIs as well as
    for virtual device interrupts. The IRQ number space is defined by
    QEMU.
    
    The XIVE device reuses the source structures of the XICS-on-XIVE
    device for the source blocks (2-level tree) and for the source
    interrupts. Under XIVE native, the source interrupt caches mostly
    configuration information and is less used than under the XICS-on-XIVE
    device in which hcalls are still necessary at run-time.
    
    When a source is initialized in KVM, an IPI interrupt source is simply
    allocated at the OPAL level and then MASKED. KVM only needs to know
    about its type: LSI or MSI.
    
    Signed-off-by: CÃ©dric Le Goater <clg@kaod.org>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index d366df69b9cb..1be921cb5dcb 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -12,6 +12,13 @@
 #ifdef CONFIG_KVM_XICS
 #include "book3s_xics.h"
 
+/*
+ * The XIVE Interrupt source numbers are within the range 0 to
+ * KVMPPC_XICS_NR_IRQS.
+ */
+#define KVMPPC_XIVE_FIRST_IRQ	0
+#define KVMPPC_XIVE_NR_IRQS	KVMPPC_XICS_NR_IRQS
+
 /*
  * State for one guest irq source.
  *
@@ -258,6 +265,9 @@ extern int (*__xive_vm_h_eoi)(struct kvm_vcpu *vcpu, unsigned long xirr);
  */
 void kvmppc_xive_disable_vcpu_interrupts(struct kvm_vcpu *vcpu);
 int kvmppc_xive_debug_show_queues(struct seq_file *m, struct kvm_vcpu *vcpu);
+struct kvmppc_xive_src_block *kvmppc_xive_create_src_block(
+	struct kvmppc_xive *xive, int irq);
+void kvmppc_xive_free_sources(struct kvmppc_xive_src_block *sb);
 
 #endif /* CONFIG_KVM_XICS */
 #endif /* _KVM_PPC_BOOK3S_XICS_H */

commit eacc56bb9de3e6830ddc169553772cd6de59ee4c
Author: CÃ©dric Le Goater <clg@kaod.org>
Date:   Thu Apr 18 12:39:28 2019 +0200

    KVM: PPC: Book3S HV: XIVE: Introduce a new capability KVM_CAP_PPC_IRQ_XIVE
    
    The user interface exposes a new capability KVM_CAP_PPC_IRQ_XIVE to
    let QEMU connect the vCPU presenters to the XIVE KVM device if
    required. The capability is not advertised for now as the full support
    for the XIVE native exploitation mode is not yet available. When this
    is case, the capability will be advertised on PowerNV Hypervisors
    only. Nested guests (pseries KVM Hypervisor) are not supported.
    
    Internally, the interface to the new KVM device is protected with a
    new interrupt mode: KVMPPC_IRQ_XIVE.
    
    Signed-off-by: CÃ©dric Le Goater <clg@kaod.org>
    Reviewed-by: David Gibson <david@gibson.dropbear.id.au>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index a08ae6fd4c51..d366df69b9cb 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -198,6 +198,11 @@ static inline struct kvmppc_xive_src_block *kvmppc_xive_find_source(struct kvmpp
 	return xive->src_blocks[bid];
 }
 
+static inline u32 kvmppc_xive_vp(struct kvmppc_xive *xive, u32 server)
+{
+	return xive->vp_base + kvmppc_pack_vcpu_id(xive->kvm, server);
+}
+
 /*
  * Mapping between guest priorities and host priorities
  * is as follow.
@@ -248,5 +253,11 @@ extern int (*__xive_vm_h_ipi)(struct kvm_vcpu *vcpu, unsigned long server,
 extern int (*__xive_vm_h_cppr)(struct kvm_vcpu *vcpu, unsigned long cppr);
 extern int (*__xive_vm_h_eoi)(struct kvm_vcpu *vcpu, unsigned long xirr);
 
+/*
+ * Common Xive routines for XICS-over-XIVE and XIVE native
+ */
+void kvmppc_xive_disable_vcpu_interrupts(struct kvm_vcpu *vcpu);
+int kvmppc_xive_debug_show_queues(struct seq_file *m, struct kvm_vcpu *vcpu);
+
 #endif /* CONFIG_KVM_XICS */
 #endif /* _KVM_PPC_BOOK3S_XICS_H */

commit bf4159da4751ab8eea43ca6e7c49193dbce8398c
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Fri Jan 12 13:37:12 2018 +1100

    KVM: PPC: Book3S HV: Enable use of the new XIVE "single escalation" feature
    
    That feature, provided by Power9 DD2.0 and later, when supported
    by newer OPAL versions, allows us to sacrifice a queue (priority 7)
    in favor of merging all the escalation interrupts of the queues
    of a single VP into a single interrupt.
    
    This reduces the number of host interrupts used up by KVM guests
    especially when those guests use multiple priorities.
    
    It will also enable a future change to control the masking of the
    escalation interrupts more precisely to avoid spurious ones.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index 6ba63f8e8a61..a08ae6fd4c51 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -120,6 +120,8 @@ struct kvmppc_xive {
 	u32	q_order;
 	u32	q_page_order;
 
+	/* Flags */
+	u8	single_escalation;
 };
 
 #define KVMPPC_XIVE_Q_COUNT	8
@@ -201,25 +203,20 @@ static inline struct kvmppc_xive_src_block *kvmppc_xive_find_source(struct kvmpp
  * is as follow.
  *
  * Guest request for 0...6 are honored. Guest request for anything
- * higher results in a priority of 7 being applied.
- *
- * However, when XIRR is returned via H_XIRR, 7 is translated to 0xb
- * in order to match AIX expectations
+ * higher results in a priority of 6 being applied.
  *
  * Similar mapping is done for CPPR values
  */
 static inline u8 xive_prio_from_guest(u8 prio)
 {
-	if (prio == 0xff || prio < 8)
+	if (prio == 0xff || prio < 6)
 		return prio;
-	return 7;
+	return 6;
 }
 
 static inline u8 xive_prio_to_guest(u8 prio)
 {
-	if (prio == 0xff || prio < 7)
-		return prio;
-	return 0xb;
+	return prio;
 }
 
 static inline u32 __xive_read_eq(__be32 *qpage, u32 msk, u32 *idx, u32 *toggle)

commit 2fb1e946450a4fef74bb72f360555f7760d816f0
Author: Sam Bobroff <sam.bobroff@au1.ibm.com>
Date:   Tue Sep 26 16:47:04 2017 +1000

    KVM: PPC: Book3S: Fix server always zero from kvmppc_xive_get_xive()
    
    In KVM's XICS-on-XIVE emulation, kvmppc_xive_get_xive() returns the
    value of state->guest_server as "server". However, this value is not
    set by it's counterpart kvmppc_xive_set_xive(). When the guest uses
    this interface to migrate interrupts away from a CPU that is going
    offline, it sees all interrupts as belonging to CPU 0, so they are
    left assigned to (now) offline CPUs.
    
    This patch removes the guest_server field from the state, and returns
    act_server in it's place (that is, the CPU actually handling the
    interrupt, which may differ from the one requested).
    
    Fixes: 5af50993850a ("KVM: PPC: Book3S HV: Native usage of the XIVE interrupt controller")
    Cc: stable@vger.kernel.org
    Signed-off-by: Sam Bobroff <sam.bobroff@au1.ibm.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Radim KrÄmÃ¡Å <rkrcmar@redhat.com>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
index 5938f7644dc1..6ba63f8e8a61 100644
--- a/arch/powerpc/kvm/book3s_xive.h
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -35,7 +35,6 @@ struct kvmppc_xive_irq_state {
 	struct xive_irq_data *pt_data;	/* XIVE Pass-through associated data */
 
 	/* Targetting as set by guest */
-	u32 guest_server;		/* Current guest selected target */
 	u8 guest_priority;		/* Guest set priority */
 	u8 saved_priority;		/* Saved priority when masking */
 

commit 5af50993850a48ba749b122173d789ea90976c72
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Wed Apr 5 17:54:56 2017 +1000

    KVM: PPC: Book3S HV: Native usage of the XIVE interrupt controller
    
    This patch makes KVM capable of using the XIVE interrupt controller
    to provide the standard PAPR "XICS" style hypercalls. It is necessary
    for proper operations when the host uses XIVE natively.
    
    This has been lightly tested on an actual system, including PCI
    pass-through with a TG3 device.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    [mpe: Cleanup pr_xxx(), unsplit pr_xxx() strings, etc., fix build
     failures by adding KVM_XIVE which depends on KVM_XICS and XIVE, and
     adding empty stubs for the kvm_xive_xxx() routines, fixup subject,
     integrate fixes from Paul for building PR=y HV=n]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kvm/book3s_xive.h b/arch/powerpc/kvm/book3s_xive.h
new file mode 100644
index 000000000000..5938f7644dc1
--- /dev/null
+++ b/arch/powerpc/kvm/book3s_xive.h
@@ -0,0 +1,256 @@
+/*
+ * Copyright 2017 Benjamin Herrenschmidt, IBM Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License, version 2, as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _KVM_PPC_BOOK3S_XIVE_H
+#define _KVM_PPC_BOOK3S_XIVE_H
+
+#ifdef CONFIG_KVM_XICS
+#include "book3s_xics.h"
+
+/*
+ * State for one guest irq source.
+ *
+ * For each guest source we allocate a HW interrupt in the XIVE
+ * which we use for all SW triggers. It will be unused for
+ * pass-through but it's easier to keep around as the same
+ * guest interrupt can alternatively be emulated or pass-through
+ * if a physical device is hot unplugged and replaced with an
+ * emulated one.
+ *
+ * This state structure is very similar to the XICS one with
+ * additional XIVE specific tracking.
+ */
+struct kvmppc_xive_irq_state {
+	bool valid;			/* Interrupt entry is valid */
+
+	u32 number;			/* Guest IRQ number */
+	u32 ipi_number;			/* XIVE IPI HW number */
+	struct xive_irq_data ipi_data;	/* XIVE IPI associated data */
+	u32 pt_number;			/* XIVE Pass-through number if any */
+	struct xive_irq_data *pt_data;	/* XIVE Pass-through associated data */
+
+	/* Targetting as set by guest */
+	u32 guest_server;		/* Current guest selected target */
+	u8 guest_priority;		/* Guest set priority */
+	u8 saved_priority;		/* Saved priority when masking */
+
+	/* Actual targetting */
+	u32 act_server;			/* Actual server */
+	u8 act_priority;		/* Actual priority */
+
+	/* Various state bits */
+	bool in_eoi;			/* Synchronize with H_EOI */
+	bool old_p;			/* P bit state when masking */
+	bool old_q;			/* Q bit state when masking */
+	bool lsi;			/* level-sensitive interrupt */
+	bool asserted;			/* Only for emulated LSI: current state */
+
+	/* Saved for migration state */
+	bool in_queue;
+	bool saved_p;
+	bool saved_q;
+	u8 saved_scan_prio;
+};
+
+/* Select the "right" interrupt (IPI vs. passthrough) */
+static inline void kvmppc_xive_select_irq(struct kvmppc_xive_irq_state *state,
+					  u32 *out_hw_irq,
+					  struct xive_irq_data **out_xd)
+{
+	if (state->pt_number) {
+		if (out_hw_irq)
+			*out_hw_irq = state->pt_number;
+		if (out_xd)
+			*out_xd = state->pt_data;
+	} else {
+		if (out_hw_irq)
+			*out_hw_irq = state->ipi_number;
+		if (out_xd)
+			*out_xd = &state->ipi_data;
+	}
+}
+
+/*
+ * This corresponds to an "ICS" in XICS terminology, we use it
+ * as a mean to break up source information into multiple structures.
+ */
+struct kvmppc_xive_src_block {
+	arch_spinlock_t lock;
+	u16 id;
+	struct kvmppc_xive_irq_state irq_state[KVMPPC_XICS_IRQ_PER_ICS];
+};
+
+
+struct kvmppc_xive {
+	struct kvm *kvm;
+	struct kvm_device *dev;
+	struct dentry *dentry;
+
+	/* VP block associated with the VM */
+	u32	vp_base;
+
+	/* Blocks of sources */
+	struct kvmppc_xive_src_block *src_blocks[KVMPPC_XICS_MAX_ICS_ID + 1];
+	u32	max_sbid;
+
+	/*
+	 * For state save, we lazily scan the queues on the first interrupt
+	 * being migrated. We don't have a clean way to reset that flags
+	 * so we keep track of the number of valid sources and how many of
+	 * them were migrated so we can reset when all of them have been
+	 * processed.
+	 */
+	u32	src_count;
+	u32	saved_src_count;
+
+	/*
+	 * Some irqs are delayed on restore until the source is created,
+	 * keep track here of how many of them
+	 */
+	u32	delayed_irqs;
+
+	/* Which queues (priorities) are in use by the guest */
+	u8	qmap;
+
+	/* Queue orders */
+	u32	q_order;
+	u32	q_page_order;
+
+};
+
+#define KVMPPC_XIVE_Q_COUNT	8
+
+struct kvmppc_xive_vcpu {
+	struct kvmppc_xive	*xive;
+	struct kvm_vcpu		*vcpu;
+	bool			valid;
+
+	/* Server number. This is the HW CPU ID from a guest perspective */
+	u32			server_num;
+
+	/*
+	 * HW VP corresponding to this VCPU. This is the base of the VP
+	 * block plus the server number.
+	 */
+	u32			vp_id;
+	u32			vp_chip_id;
+	u32			vp_cam;
+
+	/* IPI used for sending ... IPIs */
+	u32			vp_ipi;
+	struct xive_irq_data	vp_ipi_data;
+
+	/* Local emulation state */
+	uint8_t			cppr;	/* guest CPPR */
+	uint8_t			hw_cppr;/* Hardware CPPR */
+	uint8_t			mfrr;
+	uint8_t			pending;
+
+	/* Each VP has 8 queues though we only provision some */
+	struct xive_q		queues[KVMPPC_XIVE_Q_COUNT];
+	u32			esc_virq[KVMPPC_XIVE_Q_COUNT];
+	char			*esc_virq_names[KVMPPC_XIVE_Q_COUNT];
+
+	/* Stash a delayed irq on restore from migration (see set_icp) */
+	u32			delayed_irq;
+
+	/* Stats */
+	u64			stat_rm_h_xirr;
+	u64			stat_rm_h_ipoll;
+	u64			stat_rm_h_cppr;
+	u64			stat_rm_h_eoi;
+	u64			stat_rm_h_ipi;
+	u64			stat_vm_h_xirr;
+	u64			stat_vm_h_ipoll;
+	u64			stat_vm_h_cppr;
+	u64			stat_vm_h_eoi;
+	u64			stat_vm_h_ipi;
+};
+
+static inline struct kvm_vcpu *kvmppc_xive_find_server(struct kvm *kvm, u32 nr)
+{
+	struct kvm_vcpu *vcpu = NULL;
+	int i;
+
+	kvm_for_each_vcpu(i, vcpu, kvm) {
+		if (vcpu->arch.xive_vcpu && nr == vcpu->arch.xive_vcpu->server_num)
+			return vcpu;
+	}
+	return NULL;
+}
+
+static inline struct kvmppc_xive_src_block *kvmppc_xive_find_source(struct kvmppc_xive *xive,
+		u32 irq, u16 *source)
+{
+	u32 bid = irq >> KVMPPC_XICS_ICS_SHIFT;
+	u16 src = irq & KVMPPC_XICS_SRC_MASK;
+
+	if (source)
+		*source = src;
+	if (bid > KVMPPC_XICS_MAX_ICS_ID)
+		return NULL;
+	return xive->src_blocks[bid];
+}
+
+/*
+ * Mapping between guest priorities and host priorities
+ * is as follow.
+ *
+ * Guest request for 0...6 are honored. Guest request for anything
+ * higher results in a priority of 7 being applied.
+ *
+ * However, when XIRR is returned via H_XIRR, 7 is translated to 0xb
+ * in order to match AIX expectations
+ *
+ * Similar mapping is done for CPPR values
+ */
+static inline u8 xive_prio_from_guest(u8 prio)
+{
+	if (prio == 0xff || prio < 8)
+		return prio;
+	return 7;
+}
+
+static inline u8 xive_prio_to_guest(u8 prio)
+{
+	if (prio == 0xff || prio < 7)
+		return prio;
+	return 0xb;
+}
+
+static inline u32 __xive_read_eq(__be32 *qpage, u32 msk, u32 *idx, u32 *toggle)
+{
+	u32 cur;
+
+	if (!qpage)
+		return 0;
+	cur = be32_to_cpup(qpage + *idx);
+	if ((cur >> 31) == *toggle)
+		return 0;
+	*idx = (*idx + 1) & msk;
+	if (*idx == 0)
+		(*toggle) ^= 1;
+	return cur & 0x7fffffff;
+}
+
+extern unsigned long xive_rm_h_xirr(struct kvm_vcpu *vcpu);
+extern unsigned long xive_rm_h_ipoll(struct kvm_vcpu *vcpu, unsigned long server);
+extern int xive_rm_h_ipi(struct kvm_vcpu *vcpu, unsigned long server,
+			 unsigned long mfrr);
+extern int xive_rm_h_cppr(struct kvm_vcpu *vcpu, unsigned long cppr);
+extern int xive_rm_h_eoi(struct kvm_vcpu *vcpu, unsigned long xirr);
+
+extern unsigned long (*__xive_vm_h_xirr)(struct kvm_vcpu *vcpu);
+extern unsigned long (*__xive_vm_h_ipoll)(struct kvm_vcpu *vcpu, unsigned long server);
+extern int (*__xive_vm_h_ipi)(struct kvm_vcpu *vcpu, unsigned long server,
+			      unsigned long mfrr);
+extern int (*__xive_vm_h_cppr)(struct kvm_vcpu *vcpu, unsigned long cppr);
+extern int (*__xive_vm_h_eoi)(struct kvm_vcpu *vcpu, unsigned long xirr);
+
+#endif /* CONFIG_KVM_XICS */
+#endif /* _KVM_PPC_BOOK3S_XICS_H */
