commit 1c7f4fe86f17f296bafab1d418c040533324bf4f
Author: Oliver O'Halloran <oohall@gmail.com>
Date:   Mon Oct 28 19:54:24 2019 +1100

    powerpc/pci: Remove pcibios_setup_bus_devices()
    
    With the previous patch applied pcibios_setup_device() will always be run
    when pcibios_bus_add_device() is called. There are several code paths where
    pcibios_setup_bus_device() is still called (the PowerPC specific PCI
    hotplug support is one) so with just the previous patch applied the setup
    can be run multiple times on a device, once before the device is added
    to the bus and once after.
    
    There's no need to run the setup in the early case any more so just
    remove it entirely.
    
    Signed-off-by: Oliver O'Halloran <oohall@gmail.com>
    Tested-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Reviewed-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20191028085424.12006-3-oohall@gmail.com

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index f91d7e94872e..c3024f104765 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -414,7 +414,6 @@ static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,
 	 */
 	if (!rescan_existing)
 		pcibios_setup_bus_self(bus);
-	pcibios_setup_bus_devices(bus);
 
 	/* Now scan child busses */
 	for_each_pci_bridge(dev, bus)

commit bc605cd79edb68131d3be5b00b949aa312277d39
Author: Alexey Kardashevskiy <aik@ozlabs.ru>
Date:   Thu Aug 29 18:44:17 2019 +1000

    powerpc/of/pci: Rewrite pci_parse_of_flags
    
    The existing code uses bunch of hardcoded values from the PCI Bus
    Binding to IEEE Std 1275 spec; and it does so in quite non-obvious
    way.
    
    This defines fields from the cell#0 of the "reg" property of a PCI
    device and uses them for parsing.
    
    This should cause no behavioral change.
    
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    [mpe: Unsplit some 80/81 char lines, space the code with some newlines]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20190829084417.71873-1-aik@ozlabs.ru

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 409c6c1beabf..f91d7e94872e 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -34,31 +34,75 @@ static u32 get_int_prop(struct device_node *np, const char *name, u32 def)
  * pci_parse_of_flags - Parse the flags cell of a device tree PCI address
  * @addr0: value of 1st cell of a device tree PCI address.
  * @bridge: Set this flag if the address is from a bridge 'ranges' property
+ *
+ * PCI Bus Binding to IEEE Std 1275-1994
+ *
+ * Bit#            33222222 22221111 11111100 00000000
+ *                 10987654 32109876 54321098 76543210
+ * phys.hi cell:   npt000ss bbbbbbbb dddddfff rrrrrrrr
+ * phys.mid cell:  hhhhhhhh hhhhhhhh hhhhhhhh hhhhhhhh
+ * phys.lo cell:   llllllll llllllll llllllll llllllll
+ *
+ * where:
+ * n        is 0 if the address is relocatable, 1 otherwise
+ * p        is 1 if the addressable region is "prefetchable", 0 otherwise
+ * t        is 1 if the address is aliased (for non-relocatable I/O),
+ *          below 1 MB (for Memory),or below 64 KB (for relocatable I/O).
+ * ss       is the space code, denoting the address space:
+ *              00 denotes Configuration Space
+ *              01 denotes I/O Space
+ *              10 denotes 32-bit-address Memory Space
+ *              11 denotes 64-bit-address Memory Space
+ * bbbbbbbb is the 8-bit Bus Number
+ * ddddd    is the 5-bit Device Number
+ * fff      is the 3-bit Function Number
+ * rrrrrrrr is the 8-bit Register Number
  */
+#define OF_PCI_ADDR0_SPACE(ss)		(((ss)&3)<<24)
+#define OF_PCI_ADDR0_SPACE_CFG		OF_PCI_ADDR0_SPACE(0)
+#define OF_PCI_ADDR0_SPACE_IO		OF_PCI_ADDR0_SPACE(1)
+#define OF_PCI_ADDR0_SPACE_MMIO32	OF_PCI_ADDR0_SPACE(2)
+#define OF_PCI_ADDR0_SPACE_MMIO64	OF_PCI_ADDR0_SPACE(3)
+#define OF_PCI_ADDR0_SPACE_MASK		OF_PCI_ADDR0_SPACE(3)
+#define OF_PCI_ADDR0_RELOC		(1UL<<31)
+#define OF_PCI_ADDR0_PREFETCH		(1UL<<30)
+#define OF_PCI_ADDR0_ALIAS		(1UL<<29)
+#define OF_PCI_ADDR0_BUS		0x00FF0000UL
+#define OF_PCI_ADDR0_DEV		0x0000F800UL
+#define OF_PCI_ADDR0_FN			0x00000700UL
+#define OF_PCI_ADDR0_BARREG		0x000000FFUL
+
 unsigned int pci_parse_of_flags(u32 addr0, int bridge)
 {
-	unsigned int flags = 0;
+	unsigned int flags = 0, as = addr0 & OF_PCI_ADDR0_SPACE_MASK;
 
-	if (addr0 & 0x02000000) {
+	if (as == OF_PCI_ADDR0_SPACE_MMIO32 || as == OF_PCI_ADDR0_SPACE_MMIO64) {
 		flags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;
-		flags |= (addr0 >> 22) & PCI_BASE_ADDRESS_MEM_TYPE_64;
-		if (flags & PCI_BASE_ADDRESS_MEM_TYPE_64)
-			flags |= IORESOURCE_MEM_64;
-		flags |= (addr0 >> 28) & PCI_BASE_ADDRESS_MEM_TYPE_1M;
-		if (addr0 & 0x40000000)
-			flags |= IORESOURCE_PREFETCH
-				 | PCI_BASE_ADDRESS_MEM_PREFETCH;
+
+		if (as == OF_PCI_ADDR0_SPACE_MMIO64)
+			flags |= PCI_BASE_ADDRESS_MEM_TYPE_64 | IORESOURCE_MEM_64;
+
+		if (addr0 & OF_PCI_ADDR0_ALIAS)
+			flags |= PCI_BASE_ADDRESS_MEM_TYPE_1M;
+
+		if (addr0 & OF_PCI_ADDR0_PREFETCH)
+			flags |= IORESOURCE_PREFETCH |
+				 PCI_BASE_ADDRESS_MEM_PREFETCH;
+
 		/* Note: We don't know whether the ROM has been left enabled
 		 * by the firmware or not. We mark it as disabled (ie, we do
 		 * not set the IORESOURCE_ROM_ENABLE flag) for now rather than
 		 * do a config space read, it will be force-enabled if needed
 		 */
-		if (!bridge && (addr0 & 0xff) == 0x30)
+		if (!bridge && (addr0 & OF_PCI_ADDR0_BARREG) == PCI_ROM_ADDRESS)
 			flags |= IORESOURCE_READONLY;
-	} else if (addr0 & 0x01000000)
+
+	} else if (as == OF_PCI_ADDR0_SPACE_IO)
 		flags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;
+
 	if (flags)
 		flags |= IORESOURCE_SIZEALIGN;
+
 	return flags;
 }
 

commit 192f0f8e9db7efe4ac98d47f5fa4334e43c1204d
Merge: ec9249752465 f5a9e488d623
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 13 16:08:36 2019 -0700

    Merge tag 'powerpc-5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc updates from Michael Ellerman:
     "Notable changes:
    
       - Removal of the NPU DMA code, used by the out-of-tree Nvidia driver,
         as well as some other functions only used by drivers that haven't
         (yet?) made it upstream.
    
       - A fix for a bug in our handling of hardware watchpoints (eg. perf
         record -e mem: ...) which could lead to register corruption and
         kernel crashes.
    
       - Enable HAVE_ARCH_HUGE_VMAP, which allows us to use large pages for
         vmalloc when using the Radix MMU.
    
       - A large but incremental rewrite of our exception handling code to
         use gas macros rather than multiple levels of nested CPP macros.
    
      And the usual small fixes, cleanups and improvements.
    
      Thanks to: Alastair D'Silva, Alexey Kardashevskiy, Andreas Schwab,
      Aneesh Kumar K.V, Anju T Sudhakar, Anton Blanchard, Arnd Bergmann,
      Athira Rajeev, CÃ©dric Le Goater, Christian Lamparter, Christophe
      Leroy, Christophe Lombard, Christoph Hellwig, Daniel Axtens, Denis
      Efremov, Enrico Weigelt, Frederic Barrat, Gautham R. Shenoy, Geert
      Uytterhoeven, Geliang Tang, Gen Zhang, Greg Kroah-Hartman, Greg Kurz,
      Gustavo Romero, Krzysztof Kozlowski, Madhavan Srinivasan, Masahiro
      Yamada, Mathieu Malaterre, Michael Neuling, Nathan Lynch, Naveen N.
      Rao, Nicholas Piggin, Nishad Kamdar, Oliver O'Halloran, Qian Cai, Ravi
      Bangoria, Sachin Sant, Sam Bobroff, Satheesh Rajendran, Segher
      Boessenkool, Shaokun Zhang, Shawn Anastasio, Stewart Smith, Suraj
      Jitindar Singh, Thiago Jung Bauermann, YueHaibing"
    
    * tag 'powerpc-5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (163 commits)
      powerpc/powernv/idle: Fix restore of SPRN_LDBAR for POWER9 stop state.
      powerpc/eeh: Handle hugepages in ioremap space
      ocxl: Update for AFU descriptor template version 1.1
      powerpc/boot: pass CONFIG options in a simpler and more robust way
      powerpc/boot: add {get, put}_unaligned_be32 to xz_config.h
      powerpc/irq: Don't WARN continuously in arch_local_irq_restore()
      powerpc/module64: Use symbolic instructions names.
      powerpc/module32: Use symbolic instructions names.
      powerpc: Move PPC_HA() PPC_HI() and PPC_LO() to ppc-opcode.h
      powerpc/module64: Fix comment in R_PPC64_ENTRY handling
      powerpc/boot: Add lzo support for uImage
      powerpc/boot: Add lzma support for uImage
      powerpc/boot: don't force gzipped uImage
      powerpc/8xx: Add microcode patch to move SMC parameter RAM.
      powerpc/8xx: Use IO accessors in microcode programming.
      powerpc/8xx: replace #ifdefs by IS_ENABLED() in microcode.c
      powerpc/8xx: refactor programming of microcode CPM params.
      powerpc/8xx: refactor printing of microcode patch name.
      powerpc/8xx: Refactor microcode write
      powerpc/8xx: refactor writing of CPM microcode arrays
      ...

commit dead1c845dbe97e0061dae2017eaf3bd8f8f06ee
Author: Alexey Kardashevskiy <aik@ozlabs.ru>
Date:   Wed Jun 26 12:37:46 2019 +1000

    powerpc/pci/of: Parse unassigned resources
    
    The pseries platform uses the PCI_PROBE_DEVTREE method of PCI probing
    which reads "assigned-addresses" of every PCI device and initializes
    the device resources. However if the property is missing or zero sized,
    then there is no fallback of any kind and the PCI resources remain
    undiscovered, i.e. pdev->resource[] array remains empty.
    
    This adds a fallback which parses the "reg" property in pretty much same
    way except it marks resources as "unset" which later make Linux assign
    those resources proper addresses.
    
    This has an effect when:
    1. a hypervisor failed to assign any resource for a device;
    2. /chosen/linux,pci-probe-only=0 is in the DT so the system may try
    assigning a resource.
    Neither is likely to happen under PowerVM.
    
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 64ad92016b63..bd78f325a636 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -82,10 +82,16 @@ static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)
 	const __be32 *addrs;
 	u32 i;
 	int proplen;
+	bool mark_unset = false;
 
 	addrs = of_get_property(node, "assigned-addresses", &proplen);
-	if (!addrs)
-		return;
+	if (!addrs || !proplen) {
+		addrs = of_get_property(node, "reg", &proplen);
+		if (!addrs || !proplen)
+			return;
+		mark_unset = true;
+	}
+
 	pr_debug("    parse addresses (%d bytes) @ %p\n", proplen, addrs);
 	for (; proplen >= 20; proplen -= 20, addrs += 5) {
 		flags = pci_parse_of_flags(of_read_number(addrs, 1), 0);
@@ -110,6 +116,8 @@ static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)
 			continue;
 		}
 		res->flags = flags;
+		if (mark_unset)
+			res->flags |= IORESOURCE_UNSET;
 		res->name = pci_name(dev);
 		region.start = base;
 		region.end = base + size - 1;

commit df5be5be8735ef2ae80d5ae1f2453cd81a035c4b
Author: Alexey Kardashevskiy <aik@ozlabs.ru>
Date:   Wed Jun 5 13:38:14 2019 +1000

    powerpc/pci/of: Fix OF flags parsing for 64bit BARs
    
    When the firmware does PCI BAR resource allocation, it passes the assigned
    addresses and flags (prefetch/64bit/...) via the "reg" property of
    a PCI device device tree node so the kernel does not need to do
    resource allocation.
    
    The flags are stored in resource::flags - the lower byte stores
    PCI_BASE_ADDRESS_SPACE/etc bits and the other bytes are IORESOURCE_IO/etc.
    Some flags from PCI_BASE_ADDRESS_xxx and IORESOURCE_xxx are duplicated,
    such as PCI_BASE_ADDRESS_MEM_PREFETCH/PCI_BASE_ADDRESS_MEM_TYPE_64/etc.
    When parsing the "reg" property, we copy the prefetch flag but we skip
    on PCI_BASE_ADDRESS_MEM_TYPE_64 which leaves the flags out of sync.
    
    The missing IORESOURCE_MEM_64 flag comes into play under 2 conditions:
    1. we remove PCI_PROBE_ONLY for pseries (by hacking pSeries_setup_arch()
    or by passing "/chosen/linux,pci-probe-only");
    2. we request resource alignment (by passing pci=resource_alignment=
    via the kernel cmd line to request PAGE_SIZE alignment or defining
    ppc_md.pcibios_default_alignment which returns anything but 0). Note that
    the alignment requests are ignored if PCI_PROBE_ONLY is enabled.
    
    With 1) and 2), the generic PCI code in the kernel unconditionally
    decides to:
    - reassign the BARs in pci_specified_resource_alignment() (works fine)
    - write new BARs to the device - this fails for 64bit BARs as the generic
    code looks at IORESOURCE_MEM_64 (not set) and writes only lower 32bits
    of the BAR and leaves the upper 32bit unmodified which breaks BAR mapping
    in the hypervisor.
    
    This fixes the issue by copying the flag. This is useful if we want to
    enforce certain BAR alignment per platform as handling subpage sized BARs
    is proven to cause problems with hotplug (SLOF already aligns BARs to 64k).
    
    Signed-off-by: Alexey Kardashevskiy <aik@ozlabs.ru>
    Reviewed-by: Sam Bobroff <sbobroff@linux.ibm.com>
    Reviewed-by: Oliver O'Halloran <oohall@gmail.com>
    Reviewed-by: Shawn Anastasio <shawn@anastas.io>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 24191ea2d9a7..64ad92016b63 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -45,6 +45,8 @@ unsigned int pci_parse_of_flags(u32 addr0, int bridge)
 	if (addr0 & 0x02000000) {
 		flags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;
 		flags |= (addr0 >> 22) & PCI_BASE_ADDRESS_MEM_TYPE_64;
+		if (flags & PCI_BASE_ADDRESS_MEM_TYPE_64)
+			flags |= IORESOURCE_MEM_64;
 		flags |= (addr0 >> 28) & PCI_BASE_ADDRESS_MEM_TYPE_1M;
 		if (addr0 & 0x40000000)
 			flags |= IORESOURCE_PREFETCH

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 24191ea2d9a7..24522aa37665 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Helper routines to scan the device tree for PCI devices and busses
  *
@@ -8,10 +9,6 @@
  * Copyright (C) 2003 Anton Blanchard <anton@au.ibm.com>, IBM
  *   Rework, based on alpha PCI code.
  * Copyright (c) 2009 Secret Lab Technologies Ltd.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * version 2 as published by the Free Software Foundation.
  */
 
 #include <linux/pci.h>

commit e5480bdcc4429e4c172d450ee1db1934d84482ef
Author: Rob Herring <robh@kernel.org>
Date:   Fri Nov 16 16:11:00 2018 -0600

    powerpc: Use device_type helpers to access the node type
    
    Remove directly accessing device_node.type pointer and use the
    accessors instead. This will eventually allow removing the type
    pointer.
    
    Replace the open coded iterating over child nodes with
    for_each_child_of_node() while we're here.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 98f04725def7..24191ea2d9a7 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -125,16 +125,13 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 				 struct pci_bus *bus, int devfn)
 {
 	struct pci_dev *dev;
-	const char *type;
 
 	dev = pci_alloc_dev(bus);
 	if (!dev)
 		return NULL;
-	type = of_get_property(node, "device_type", NULL);
-	if (type == NULL)
-		type = "";
 
-	pr_debug("    create device, devfn: %x, type: %s\n", devfn, type);
+	pr_debug("    create device, devfn: %x, type: %s\n", devfn,
+		 of_node_get_device_type(node));
 
 	dev->dev.of_node = of_node_get(node);
 	dev->dev.parent = bus->bridge;
@@ -167,12 +164,12 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 	/* Early fixups, before probing the BARs */
 	pci_fixup_device(pci_fixup_early, dev);
 
-	if (!strcmp(type, "pci") || !strcmp(type, "pciex")) {
+	if (of_node_is_type(node, "pci") || of_node_is_type(node, "pciex")) {
 		/* a PCI-PCI bridge */
 		dev->hdr_type = PCI_HEADER_TYPE_BRIDGE;
 		dev->rom_base_reg = PCI_ROM_ADDRESS1;
 		set_pcie_hotplug_bridge(dev);
-	} else if (!strcmp(type, "cardbus")) {
+	} else if (of_node_is_type(node, "cardbus")) {
 		dev->hdr_type = PCI_HEADER_TYPE_CARDBUS;
 	} else {
 		dev->hdr_type = PCI_HEADER_TYPE_NORMAL;

commit 105cf3c8c6264dce4bcdab877feb8037bc4109b1
Merge: e237f98a9c13 ab8c609356fb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 6 09:59:40 2018 -0800

    Merge tag 'pci-v4.16-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
    
     - skip AER driver error recovery callbacks for correctable errors
       reported via ACPI APEI, as we already do for errors reported via the
       native path (Tyler Baicar)
    
     - fix DPC shared interrupt handling (Alex Williamson)
    
     - print full DPC interrupt number (Keith Busch)
    
     - enable DPC only if AER is available (Keith Busch)
    
     - simplify DPC code (Bjorn Helgaas)
    
     - calculate ASPM L1 substate parameter instead of hardcoding it (Bjorn
       Helgaas)
    
     - enable Latency Tolerance Reporting for ASPM L1 substates (Bjorn
       Helgaas)
    
     - move ASPM internal interfaces out of public header (Bjorn Helgaas)
    
     - allow hot-removal of VGA devices (Mika Westerberg)
    
     - speed up unplug and shutdown by assuming Thunderbolt controllers
       don't support Command Completed events (Lukas Wunner)
    
     - add AtomicOps support for GPU and Infiniband drivers (Felix Kuehling,
       Jay Cornwall)
    
     - expose "ari_enabled" in sysfs to help NIC naming (Stuart Hayes)
    
     - clean up PCI DMA interface usage (Christoph Hellwig)
    
     - remove PCI pool API (replaced with DMA pool) (Romain Perier)
    
     - deprecate pci_get_bus_and_slot(), which assumed PCI domain 0 (Sinan
       Kaya)
    
     - move DT PCI code from drivers/of/ to drivers/pci/ (Rob Herring)
    
     - add PCI-specific wrappers for dev_info(), etc (Frederick Lawler)
    
     - remove warnings on sysfs mmap failure (Bjorn Helgaas)
    
     - quiet ROM validation messages (Alex Deucher)
    
     - remove redundant memory alloc failure messages (Markus Elfring)
    
     - fill in types for compile-time VGA and other I/O port resources
       (Bjorn Helgaas)
    
     - make "pci=pcie_scan_all" work for Root Ports as well as Downstream
       Ports to help AmigaOne X1000 (Bjorn Helgaas)
    
     - add SPDX tags to all PCI files (Bjorn Helgaas)
    
     - quirk Marvell 9128 DMA aliases (Alex Williamson)
    
     - quirk broken INTx disable on Ceton InfiniTV4 (Bjorn Helgaas)
    
     - fix CONFIG_PCI=n build by adding dummy pci_irqd_intx_xlate() (Niklas
       Cassel)
    
     - use DMA API to get MSI address for DesignWare IP (Niklas Cassel)
    
     - fix endpoint-mode DMA mask configuration (Kishon Vijay Abraham I)
    
     - fix ARTPEC-6 incorrect IS_ERR() usage (Wei Yongjun)
    
     - add support for ARTPEC-7 SoC (Niklas Cassel)
    
     - add endpoint-mode support for ARTPEC (Niklas Cassel)
    
     - add Cadence PCIe host and endpoint controller driver (Cyrille
       Pitchen)
    
     - handle multiple INTx status bits being set in dra7xx (Vignesh R)
    
     - translate dra7xx hwirq range to fix INTD handling (Vignesh R)
    
     - remove deprecated Exynos PHY initialization code (Jaehoon Chung)
    
     - fix MSI erratum workaround for HiSilicon Hip06/Hip07 (Dongdong Liu)
    
     - fix NULL pointer dereference in iProc BCMA driver (Ray Jui)
    
     - fix Keystone interrupt-controller-node lookup (Johan Hovold)
    
     - constify qcom driver structures (Julia Lawall)
    
     - rework Tegra config space mapping to increase space available for
       endpoints (Vidya Sagar)
    
     - simplify Tegra driver by using bus->sysdata (Manikanta Maddireddy)
    
     - remove PCI_REASSIGN_ALL_BUS usage on Tegra (Manikanta Maddireddy)
    
     - add support for Global Fabric Manager Server (GFMS) event to
       Microsemi Switchtec switch driver (Logan Gunthorpe)
    
     - add IDs for Switchtec PSX 24xG3 and PSX 48xG3 (Kelvin Cao)
    
    * tag 'pci-v4.16-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (140 commits)
      PCI: cadence: Add EndPoint Controller driver for Cadence PCIe controller
      dt-bindings: PCI: cadence: Add DT bindings for Cadence PCIe endpoint controller
      PCI: endpoint: Fix EPF device name to support multi-function devices
      PCI: endpoint: Add the function number as argument to EPC ops
      PCI: cadence: Add host driver for Cadence PCIe controller
      dt-bindings: PCI: cadence: Add DT bindings for Cadence PCIe host controller
      PCI: Add vendor ID for Cadence
      PCI: Add generic function to probe PCI host controllers
      PCI: generic: fix missing call of pci_free_resource_list()
      PCI: OF: Add generic function to parse and allocate PCI resources
      PCI: Regroup all PCI related entries into drivers/pci/Makefile
      PCI/DPC: Reformat DPC register definitions
      PCI/DPC: Add and use DPC Status register field definitions
      PCI/DPC: Squash dpc_rp_pio_get_info() into dpc_process_rp_pio_error()
      PCI/DPC: Remove unnecessary RP PIO register structs
      PCI/DPC: Push dpc->rp_pio_status assignment into dpc_rp_pio_get_info()
      PCI/DPC: Squash dpc_rp_pio_print_error() into dpc_rp_pio_get_info()
      PCI/DPC: Make RP PIO log size check more generic
      PCI/DPC: Rename local "status" to "dpc_status"
      PCI/DPC: Squash dpc_rp_pio_print_tlp_header() into dpc_rp_pio_print_error()
      ...

commit fc5f622163637308a3d520a315527481cff023f5
Author: Bryant G. Ly <bryantly@linux.vnet.ibm.com>
Date:   Fri Jan 5 10:45:52 2018 -0600

    powerpc/pseries: Add Initialization of VF Bars
    
    When enabling SR-IOV in pseries platform, the VF bar properties for a
    PF are reported on the device node in the device tree.
    
    This patch adds the IOV Bar resources to Linux structures from the
    device tree for later use when configuring SR-IOV by PF driver.
    
    Signed-off-by: Bryant G. Ly <bryantly@linux.vnet.ibm.com>
    Signed-off-by: Juan J. Alvarez <jjalvare@linux.vnet.ibm.com>
    Acked-by: Russell Currey <ruscur@russell.cc>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 0d790f8432d2..20ceec4a5f5e 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -38,7 +38,7 @@ static u32 get_int_prop(struct device_node *np, const char *name, u32 def)
  * @addr0: value of 1st cell of a device tree PCI address.
  * @bridge: Set this flag if the address is from a bridge 'ranges' property
  */
-static unsigned int pci_parse_of_flags(u32 addr0, int bridge)
+unsigned int pci_parse_of_flags(u32 addr0, int bridge)
 {
 	unsigned int flags = 0;
 

commit dd1ea5763e65c69983697dc97ea9d6e3cb9df922
Author: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
Date:   Fri Nov 10 19:52:29 2017 +0200

    powerpc/pci: Use for_each_pci_bridge() helper
    
    Use for_each_pci_bridge() helper to make the code slightly cleaner.  No
    functional change intended.
    
    Requires: 24a0c654d7d6 ("PCI: Add for_each_pci_bridge() helper")
    Signed-off-by: Andy Shevchenko <andriy.shevchenko@linux.intel.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 0d790f8432d2..8bdaa2a6fa62 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -369,11 +369,8 @@ static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,
 	pcibios_setup_bus_devices(bus);
 
 	/* Now scan child busses */
-	list_for_each_entry(dev, &bus->devices, bus_list) {
-		if (pci_is_bridge(dev)) {
-			of_scan_pci_bridge(dev);
-		}
-	}
+	for_each_pci_bridge(dev, bus)
+		of_scan_pci_bridge(dev);
 }
 
 /**

commit b7c670d673d1186e9a6aafaad36aace34046bb6b
Author: Rob Herring <robh@kernel.org>
Date:   Mon Aug 21 10:16:47 2017 -0500

    powerpc: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Anatolij Gustschin <agust@denx.de>
    Cc: Scott Wood <oss@buserror.net>
    Cc: Kumar Gala <galak@kernel.crashing.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linuxppc-dev@lists.ozlabs.org
    Reviewed-by: Tyrel Datwyler <tyreld@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index ea3d98115b88..0d790f8432d2 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -211,19 +211,19 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 	unsigned int flags;
 	u64 size;
 
-	pr_debug("of_scan_pci_bridge(%s)\n", node->full_name);
+	pr_debug("of_scan_pci_bridge(%pOF)\n", node);
 
 	/* parse bus-range property */
 	busrange = of_get_property(node, "bus-range", &len);
 	if (busrange == NULL || len != 8) {
-		printk(KERN_DEBUG "Can't get bus-range for PCI-PCI bridge %s\n",
-		       node->full_name);
+		printk(KERN_DEBUG "Can't get bus-range for PCI-PCI bridge %pOF\n",
+		       node);
 		return;
 	}
 	ranges = of_get_property(node, "ranges", &len);
 	if (ranges == NULL) {
-		printk(KERN_DEBUG "Can't get ranges for PCI-PCI bridge %s\n",
-		       node->full_name);
+		printk(KERN_DEBUG "Can't get ranges for PCI-PCI bridge %pOF\n",
+		       node);
 		return;
 	}
 
@@ -233,8 +233,8 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 		bus = pci_add_new_bus(dev->bus, dev,
 				      of_read_number(busrange, 1));
 		if (!bus) {
-			printk(KERN_ERR "Failed to create pci bus for %s\n",
-			       node->full_name);
+			printk(KERN_ERR "Failed to create pci bus for %pOF\n",
+			       node);
 			return;
 		}
 	}
@@ -262,13 +262,13 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 			res = bus->resource[0];
 			if (res->flags) {
 				printk(KERN_ERR "PCI: ignoring extra I/O range"
-				       " for bridge %s\n", node->full_name);
+				       " for bridge %pOF\n", node);
 				continue;
 			}
 		} else {
 			if (i >= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {
 				printk(KERN_ERR "PCI: too many memory ranges"
-				       " for bridge %s\n", node->full_name);
+				       " for bridge %pOF\n", node);
 				continue;
 			}
 			res = bus->resource[i];
@@ -307,7 +307,7 @@ static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,
 	struct eeh_dev *edev = pdn_to_eeh_dev(PCI_DN(dn));
 #endif
 
-	pr_debug("  * %s\n", dn->full_name);
+	pr_debug("  * %pOF\n", dn);
 	if (!of_device_is_available(dn))
 		return NULL;
 
@@ -350,8 +350,8 @@ static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,
 	struct device_node *child;
 	struct pci_dev *dev;
 
-	pr_debug("of_scan_bus(%s) bus no %d...\n",
-		 node->full_name, bus->number);
+	pr_debug("of_scan_bus(%pOF) bus no %d...\n",
+		 node, bus->number);
 
 	/* Scan direct children */
 	for_each_child_of_node(node, child) {

commit ef24ba7091517d2bbf9ba2cb4256c0dccd51d248
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Tue Sep 6 21:53:24 2016 +1000

    powerpc: Remove all usages of NO_IRQ
    
    NO_IRQ has been == 0 on powerpc for just over ten years (since commit
    0ebfff1491ef ("[POWERPC] Add new interrupt mapping core and change
    platforms to use it")). It's also 0 on most other arches.
    
    Although it's fairly harmless, every now and then it causes confusion
    when a driver is built on powerpc and another arch which doesn't define
    NO_IRQ. There's at least 6 definitions of NO_IRQ in drivers/, at least
    some of which are to work around that problem.
    
    So we'd like to remove it. This is fairly trivial in the arch code, we
    just convert:
    
        if (irq == NO_IRQ)  to      if (!irq)
        if (irq != NO_IRQ)  to      if (irq)
        irq = NO_IRQ;       to      irq = 0;
        return NO_IRQ;      to      return 0;
    
    And a few other odd cases as well.
    
    At least for now we keep the #define NO_IRQ, because there is driver
    code that uses NO_IRQ and the fixes to remove those will go via other
    trees.
    
    Note we also change some occurrences in PPC sound drivers, drivers/ps3,
    and drivers/macintosh.
    
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 526ac6750e4d..ea3d98115b88 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -178,7 +178,7 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 		dev->hdr_type = PCI_HEADER_TYPE_NORMAL;
 		dev->rom_base_reg = PCI_ROM_ADDRESS;
 		/* Maybe do a default OF mapping here */
-		dev->irq = NO_IRQ;
+		dev->irq = 0;
 	}
 
 	of_pci_parse_addrs(node, dev);

commit e80e7edc55ba711f3fe23975061b3f1c336ceb95
Author: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
Date:   Wed Oct 21 12:17:35 2015 -0200

    PCI/MSI: Initialize MSI capability for all architectures
    
    1851617cd2da ("PCI/MSI: Disable MSI at enumeration even if kernel doesn't
    support MSI") moved dev->msi_cap and dev->msix_cap initialization from the
    pci_init_capabilities() path (used on all architectures) to the
    pci_setup_device() path (not used on Open Firmware architectures).
    
    This broke MSI or MSI-X on Open Firmware machines.  4d9aac397a5d
    ("powerpc/PCI: Disable MSI/MSI-X interrupts at PCI probe time in OF case")
    fixed it for PowerPC but not for SPARC.
    
    Set up MSI and MSI-X (initialize msi_cap and msix_cap and disable MSI and
    MSI-X) in pci_init_capabilities() so all architectures do it the same way.
    
    This reverts 4d9aac397a5d since this patch fixes the problem generically
    for both PowerPC and SPARC.
    
    [bhelgaas: changelog, make pci_msi_setup_pci_dev() static]
    Fixes: 1851617cd2da ("PCI/MSI: Disable MSI at enumeration even if kernel doesn't support MSI")
    Signed-off-by: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 2e710c15893f..526ac6750e4d 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -187,9 +187,6 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 
 	pci_device_add(dev, bus);
 
-	/* Setup MSI caps & disable MSI/MSI-X interrupts */
-	pci_msi_setup_pci_dev(dev);
-
 	return dev;
 }
 EXPORT_SYMBOL(of_create_pci_dev);

commit 12f03ee606914317e7e6a0815e53a48205c31dae
Merge: d9241b22b58e 004f1afbe199
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Sep 8 14:35:59 2015 -0700

    Merge tag 'libnvdimm-for-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm
    
    Pull libnvdimm updates from Dan Williams:
     "This update has successfully completed a 0day-kbuild run and has
      appeared in a linux-next release.  The changes outside of the typical
      drivers/nvdimm/ and drivers/acpi/nfit.[ch] paths are related to the
      removal of IORESOURCE_CACHEABLE, the introduction of memremap(), and
      the introduction of ZONE_DEVICE + devm_memremap_pages().
    
      Summary:
    
       - Introduce ZONE_DEVICE and devm_memremap_pages() as a generic
         mechanism for adding device-driver-discovered memory regions to the
         kernel's direct map.
    
         This facility is used by the pmem driver to enable pfn_to_page()
         operations on the page frames returned by DAX ('direct_access' in
         'struct block_device_operations').
    
         For now, the 'memmap' allocation for these "device" pages comes
         from "System RAM".  Support for allocating the memmap from device
         memory will arrive in a later kernel.
    
       - Introduce memremap() to replace usages of ioremap_cache() and
         ioremap_wt().  memremap() drops the __iomem annotation for these
         mappings to memory that do not have i/o side effects.  The
         replacement of ioremap_cache() with memremap() is limited to the
         pmem driver to ease merging the api change in v4.3.
    
         Completion of the conversion is targeted for v4.4.
    
       - Similar to the usage of memcpy_to_pmem() + wmb_pmem() in the pmem
         driver, update the VFS DAX implementation and PMEM api to provide
         persistence guarantees for kernel operations on a DAX mapping.
    
       - Convert the ACPI NFIT 'BLK' driver to map the block apertures as
         cacheable to improve performance.
    
       - Miscellaneous updates and fixes to libnvdimm including support for
         issuing "address range scrub" commands, clarifying the optimal
         'sector size' of pmem devices, a clarification of the usage of the
         ACPI '_STA' (status) property for DIMM devices, and other minor
         fixes"
    
    * tag 'libnvdimm-for-4.3' of git://git.kernel.org/pub/scm/linux/kernel/git/nvdimm/nvdimm: (34 commits)
      libnvdimm, pmem: direct map legacy pmem by default
      libnvdimm, pmem: 'struct page' for pmem
      libnvdimm, pfn: 'struct page' provider infrastructure
      x86, pmem: clarify that ARCH_HAS_PMEM_API implies PMEM mapped WB
      add devm_memremap_pages
      mm: ZONE_DEVICE for "device memory"
      mm: move __phys_to_pfn and __pfn_to_phys to asm/generic/memory_model.h
      dax: drop size parameter to ->direct_access()
      nd_blk: change aperture mapping from WC to WB
      nvdimm: change to use generic kvfree()
      pmem, dax: have direct_access use __pmem annotation
      dax: update I/O path to do proper PMEM flushing
      pmem: add copy_from_iter_pmem() and clear_pmem()
      pmem, x86: clean up conditional pmem includes
      pmem: remove layer when calling arch_has_wmb_pmem()
      pmem, x86: move x86 PMEM API to new pmem.h header
      libnvdimm, e820: make CONFIG_X86_PMEM_LEGACY a tristate option
      pmem: switch to devm_ allocations
      devres: add devm_memremap
      libnvdimm, btt: write and validate parent_uuid
      ...

commit 26f8b7edc9eab56638274f5db90848a6df602081
Merge: edc837da4b54 9ca678d1dff6
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 31 17:14:39 2015 -0700

    Merge tag 'pci-v4.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI updates from Bjorn Helgaas:
     "PCI changes for the v4.3 merge window:
    
      Enumeration:
       - Allocate ATS struct during enumeration (Bjorn Helgaas)
       - Embed ATS info directly into struct pci_dev (Bjorn Helgaas)
       - Reduce size of ATS structure elements (Bjorn Helgaas)
       - Stop caching ATS Invalidate Queue Depth (Bjorn Helgaas)
       - iommu/vt-d: Cache PCI ATS state and Invalidate Queue Depth (Bjorn Helgaas)
       - Move MPS configuration check to pci_configure_device() (Bjorn Helgaas)
       - Set MPS to match upstream bridge (Keith Busch)
       - ARM/PCI: Set MPS before pci_bus_add_devices() (Murali Karicheri)
       - Add pci_scan_root_bus_msi() (Lorenzo Pieralisi)
       - ARM/PCI, designware, xilinx: Use pci_scan_root_bus_msi() (Lorenzo Pieralisi)
    
      Resource management:
       - Call pci_read_bridge_bases() from core instead of arch code (Lorenzo Pieralisi)
    
      PCI device hotplug:
       - pciehp: Remove unused interrupt events (Bjorn Helgaas)
       - pciehp: Remove ignored MRL sensor interrupt events (Bjorn Helgaas)
       - pciehp: Handle invalid data when reading from non-existent devices (Jarod Wilson)
       - pciehp: Simplify pcie_poll_cmd() (Yijing Wang)
       - Use "slot" and "pci_slot" for struct hotplug_slot and struct pci_slot (Yijing Wang)
       - Protect pci_bus->slots with pci_slot_mutex, not pci_bus_sem (Yijing Wang)
       - Hold pci_slot_mutex while searching bus->slots list (Yijing Wang)
    
      Power management:
       - Disable async suspend/resume for JMicron multi-function SATA/AHCI (Zhang Rui)
    
      Virtualization:
       - Add ACS quirks for Intel I219-LM/V (Alex Williamson)
       - Restore ACS configuration as part of pci_restore_state() (Alexander Duyck)
    
      MSI:
       - Add pcibios_alloc_irq() and pcibios_free_irq() (Jiang Liu)
       - x86: Implement pcibios_alloc_irq() and pcibios_free_irq() (Jiang Liu)
       - Add helpers to manage pci_dev->irq and pci_dev->irq_managed (Jiang Liu)
       - Free legacy IRQ when enabling MSI/MSI-X (Jiang Liu)
       - ARM/PCI: Remove msi_controller from struct pci_sys_data (Lorenzo Pieralisi)
       - Remove unused pcibios_msi_controller() hook (Lorenzo Pieralisi)
    
      Generic host bridge driver:
       - Remove dependency on ARM-specific struct hw_pci (Jayachandran C)
       - Build setup-irq.o for arm64 (Jayachandran C)
       - Add arm64 support (Jayachandran C)
    
      APM X-Gene host bridge driver:
       - Add APM X-Gene PCIe 64-bit prefetchable window (Duc Dang)
       - Add support for a 64-bit prefetchable memory window (Duc Dang)
       - Drop owner assignment from platform_driver (Krzysztof Kozlowski)
    
      Broadcom iProc host bridge driver:
       - Allow BCMA bus driver to be built as module (Hauke Mehrtens)
       - Delete unnecessary checks before phy calls (Markus Elfring)
       - Add arm64 support (Ray Jui)
    
      Synopsys DesignWare host bridge driver:
       - Don't complain missing *config* reg space if va_cfg0 is set (Murali Karicheri)
    
      TI DRA7xx host bridge driver:
       - Disable pm_runtime on get_sync failure (Kishon Vijay Abraham I)
       - Add PM support (Kishon Vijay Abraham I)
       - Clear MSE bit during suspend so clocks will idle (Kishon Vijay Abraham I)
       - Add support to make GPIO drive PERST# line (Kishon Vijay Abraham I)
    
      Xilinx AXI host bridge driver:
       - Check for MSI interrupt flag before handling as INTx (Russell Joyce)
    
      Miscellaneous:
       - Fix Intersil/Techwell TW686[4589] AV capture class code (Krzysztof HaÅasa)
       - Use PCI_CLASS_SERIAL_USB instead of bare number (Bjorn Helgaas)
       - Fix generic NCR 53c810 class code quirk (Bjorn Helgaas)
       - Fix TI816X class code quirk (Bjorn Helgaas)
       - Remove unused "pci_probe" flags (Bjorn Helgaas)
       - Host bridge driver code simplifications (Fabio Estevam)
       - Add dev_flags bit to access VPD through function 0 (Mark Rustad)
       - Add VPD function 0 quirk for Intel Ethernet devices (Mark Rustad)
       - Kill off set_irq_flags() usage (Rob Herring)
       - Remove Intel Cherrytrail D3 delays (Srinidhi Kasagar)
       - Clean up pci_find_capability() (Wei Yang)"
    
    * tag 'pci-v4.3-changes' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (72 commits)
      PCI: Disable async suspend/resume for JMicron multi-function SATA/AHCI
      PCI: Set MPS to match upstream bridge
      PCI: Move MPS configuration check to pci_configure_device()
      PCI: Drop references acquired by of_parse_phandle()
      PCI/MSI: Remove unused pcibios_msi_controller() hook
      ARM/PCI: Remove msi_controller from struct pci_sys_data
      ARM/PCI, designware, xilinx: Use pci_scan_root_bus_msi()
      PCI: Add pci_scan_root_bus_msi()
      ARM/PCI: Replace panic with WARN messages on failures
      PCI: generic: Add arm64 support
      PCI: Build setup-irq.o for arm64
      PCI: generic: Remove dependency on ARM-specific struct hw_pci
      PCI: imx6: Simplify a trivial if-return sequence
      PCI: spear: Use BUG_ON() instead of condition followed by BUG()
      PCI: dra7xx: Remove unneeded use of IS_ERR_VALUE()
      PCI: Remove pci_ats_enabled()
      PCI: Stop caching ATS Invalidate Queue Depth
      PCI: Move ATS declarations to linux/pci.h so they're all together
      PCI: Clean up ATS error handling
      PCI: Use pci_physfn() rather than looking up physfn by hand
      ...

commit 4d9aac397a5d8f4ee26a4178b5e4a5c474a3a76a
Author: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
Date:   Mon Aug 24 22:42:47 2015 +1000

    powerpc/PCI: Disable MSI/MSI-X interrupts at PCI probe time in OF case
    
    Since commit 1851617cd2da ("PCI/MSI: Disable MSI at enumeration even if
    kernel doesn't support MSI"), the setup of dev->msi_cap/msix_cap and the
    disable of MSI/MSI-X interrupts isn't being done at PCI probe time, as
    the logic responsible for this was moved in the aforementioned commit
    from pci_device_add() to pci_setup_device(). The latter function is not
    reachable on PowerPC pseries platform during Open Firmware PCI probing
    time.
    
    This exhibits as drivers not being able to enable MSI, eg:
    
      bnx2x 0000:01:00.0: no msix capability found
    
    This patch calls pci_msi_setup_pci_dev() explicitly to disable MSI/MSI-X
    during PCI probe time on pSeries platform.
    
    Fixes: 1851617cd2da ("PCI/MSI: Disable MSI at enumeration even if kernel doesn't support MSI")
    [mpe: Flesh out change log and clarify comment]
    Signed-off-by: Guilherme G. Piccoli <gpiccoli@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 42e02a2d570b..efc3fa54c90b 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -191,6 +191,9 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 
 	pci_device_add(dev, bus);
 
+	/* Setup MSI caps & disable MSI/MSI-X interrupts */
+	pci_msi_setup_pci_dev(dev);
+
 	return dev;
 }
 EXPORT_SYMBOL(of_create_pci_dev);

commit 92b19ff50e8f242392d78b2aacc5b5b672f1796b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Aug 10 23:07:06 2015 -0400

    cleanup IORESOURCE_CACHEABLE vs ioremap()
    
    Quoting Arnd:
        I was thinking the opposite approach and basically removing all uses
        of IORESOURCE_CACHEABLE from the kernel. There are only a handful of
        them.and we can probably replace them all with hardcoded
        ioremap_cached() calls in the cases they are actually useful.
    
    All existing usages of IORESOURCE_CACHEABLE call ioremap() instead of
    ioremap_nocache() if the resource is cacheable, however ioremap() is
    uncached by default. Clearly none of the existing usages care about the
    cacheability. Particularly devm_ioremap_resource() never worked as
    advertised since it always fell back to plain ioremap().
    
    Clean this up as the new direction we want is to convert
    ioremap_<type>() usages to memremap(..., flags).
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 42e02a2d570b..d4726addff0b 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -102,7 +102,7 @@ static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)
 			res = &dev->resource[(i - PCI_BASE_ADDRESS_0) >> 2];
 		} else if (i == dev->rom_base_reg) {
 			res = &dev->resource[PCI_ROM_RESOURCE];
-			flags |= IORESOURCE_READONLY | IORESOURCE_CACHEABLE;
+			flags |= IORESOURCE_READONLY;
 		} else {
 			printk(KERN_ERR "PCI: bad cfg reg num 0x%x\n", i);
 			continue;

commit 017ffe64e8b8c8db0f50433a71da41c6a4e12710
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Fri Jul 17 17:16:32 2015 +0800

    PCI: Hold pci_slot_mutex while searching bus->slots list
    
    Previously, pci_setup_device() and similar functions searched the
    pci_bus->slots list without any locking.  It was possible for another
    thread to update the list while we searched it.
    
    Add pci_dev_assign_slot() to search the list while holding pci_slot_mutex.
    
    [bhelgaas: changelog, fold in CONFIG_SYSFS fix]
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 42e02a2d570b..5e2debfc6ce5 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -126,7 +126,6 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 {
 	struct pci_dev *dev;
 	const char *type;
-	struct pci_slot *slot;
 
 	dev = pci_alloc_dev(bus);
 	if (!dev)
@@ -145,10 +144,7 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 	dev->needs_freset = 0;		/* pcie fundamental reset required */
 	set_pcie_port_type(dev);
 
-	list_for_each_entry(slot, &dev->bus->slots, list)
-		if (PCI_SLOT(dev->devfn) == slot->number)
-			dev->slot = slot;
-
+	pci_dev_assign_slot(dev);
 	dev->vendor = get_int_prop(node, "vendor-id", 0xffff);
 	dev->device = get_int_prop(node, "device-id", 0xffff);
 	dev->subsystem_vendor = get_int_prop(node, "subsystem-vendor-id", 0);

commit 467efc2e4fdc44e6cd4be7dd4adf01c14b3d148e
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Mar 31 16:00:56 2015 +1100

    powerpc: Remove shims for pci_controller_ops operations
    
    Remove shims, patch callsites to use pci_controller_ops
    versions instead.
    
    Also move back the probe mode defines, as explained in the patch
    for pci_probe_mode.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 4ee63c4f077e..42e02a2d570b 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -207,6 +207,7 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 {
 	struct device_node *node = dev->dev.of_node;
 	struct pci_bus *bus;
+	struct pci_controller *phb;
 	const __be32 *busrange, *ranges;
 	int len, i, mode;
 	struct pci_bus_region region;
@@ -286,8 +287,11 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 		bus->number);
 	pr_debug("    bus name: %s\n", bus->name);
 
+	phb = pci_bus_to_host(bus);
+
 	mode = PCI_PROBE_NORMAL;
-	mode = pci_probe_mode(bus);
+	if (phb->controller_ops.probe_mode)
+		mode = phb->controller_ops.probe_mode(bus);
 	pr_debug("    probe mode: %d\n", mode);
 
 	if (mode == PCI_PROBE_DEVTREE)

commit ff9df8c87d6807e90c5c3b0e1fd1649d09fd3bcd
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Mar 31 16:00:44 2015 +1100

    powerpc: Create pci_controller_ops.probe_mode and shim
    
    Add pci_controller_ops.probe_mode, shadowing ppc_md.pci_probe_mode.
    Add a shim, and changes the callsites to use the shim.
    
    We also need to move the probe mode defines to pci-bridge.h from pci.h.
    They are required by the shim in order to return a sensible default.
    Previously, the were defined in pci.h, but pci.h includes pci-bridge.h
    before the relevant #defines. This means the definitions are absent
    if pci.h is included before pci-bridge.h. This occurs in some drivers.
    So, move the definitons now, and move them back when we remove the shim.
    
    Anything that wants the defines would have had to include pci.h, and
    since pci.h includes pci-bridge.h, nothing will lose access to the
    defines.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 7122dfece393..4ee63c4f077e 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -287,8 +287,7 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 	pr_debug("    bus name: %s\n", bus->name);
 
 	mode = PCI_PROBE_NORMAL;
-	if (ppc_md.pci_probe_mode)
-		mode = ppc_md.pci_probe_mode(bus);
+	mode = pci_probe_mode(bus);
 	pr_debug("    probe mode: %d\n", mode);
 
 	if (mode == PCI_PROBE_DEVTREE)

commit c6406d8fbb014bebdfb5bf3c244548958aec7379
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Tue Mar 17 16:15:08 2015 +1100

    powerpc/eeh: Remove device_node dependency
    
    The patch removes struct eeh_dev::dn and the corresponding helper
    functions: eeh_dev_to_of_node() and of_node_to_eeh_dev(). Instead,
    eeh_dev_to_pdn() and pdn_to_eeh_dev() should be used to get the
    pdn, which might contain device_node on PowerNV platform.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index e6245e9c7d8d..7122dfece393 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -305,7 +305,7 @@ static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,
 	const __be32 *reg;
 	int reglen, devfn;
 #ifdef CONFIG_EEH
-	struct eeh_dev *edev = of_node_to_eeh_dev(dn);
+	struct eeh_dev *edev = pdn_to_eeh_dev(PCI_DN(dn));
 #endif
 
 	pr_debug("  * %s\n", dn->full_name);

commit e51df2c170efaeadce4d416e1825b0830de0a795
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Aug 20 08:55:18 2014 +1000

    powerpc: Make a bunch of things static
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 44562aa97f16..e6245e9c7d8d 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -38,7 +38,7 @@ static u32 get_int_prop(struct device_node *np, const char *name, u32 def)
  * @addr0: value of 1st cell of a device tree PCI address.
  * @bridge: Set this flag if the address is from a bridge 'ranges' property
  */
-unsigned int pci_parse_of_flags(u32 addr0, int bridge)
+static unsigned int pci_parse_of_flags(u32 addr0, int bridge)
 {
 	unsigned int flags = 0;
 

commit c5aec4c76af1a2d89ee2f2d4d5463b2ad2d85de5
Merge: 2937f5efa575 0c0a3e5a100b
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jun 10 18:54:22 2014 -0700

    Merge branch 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc
    
    Pull powerpc updates from Ben Herrenschmidt:
     "Here is the bulk of the powerpc changes for this merge window.  It got
      a bit delayed in part because I wasn't paying attention, and in part
      because I discovered I had a core PCI change without a PCI maintainer
      ack in it.  Bjorn eventually agreed it was ok to merge it though we'll
      probably improve it later and I didn't want to rebase to add his ack.
    
      There is going to be a bit more next week, essentially fixes that I
      still want to sort through and test.
    
      The biggest item this time is the support to build the ppc64 LE kernel
      with our new v2 ABI.  We previously supported v2 userspace but the
      kernel itself was a tougher nut to crack.  This is now sorted mostly
      thanks to Anton and Rusty.
    
      We also have a fairly big series from Cedric that add support for
      64-bit LE zImage boot wrapper.  This was made harder by the fact that
      traditionally our zImage wrapper was always 32-bit, but our new LE
      toolchains don't really support 32-bit anymore (it's somewhat there
      but not really "supported") so we didn't want to rely on it.  This
      meant more churn that just endian fixes.
    
      This brings some more LE bits as well, such as the ability to run in
      LE mode without a hypervisor (ie. under OPAL firmware) by doing the
      right OPAL call to reinitialize the CPU to take HV interrupts in the
      right mode and the usual pile of endian fixes.
    
      There's another series from Gavin adding EEH improvements (one day we
      *will* have a release with less than 20 EEH patches, I promise!).
    
      Another highlight is the support for the "Split core" functionality on
      P8 by Michael.  This allows a P8 core to be split into "sub cores" of
      4 threads which allows the subcores to run different guests under KVM
      (the HW still doesn't support a partition per thread).
    
      And then the usual misc bits and fixes ..."
    
    [ Further delayed by gmail deciding that BenH is a dirty spammer.
      Google knows.  ]
    
    * 'next' of git://git.kernel.org/pub/scm/linux/kernel/git/benh/powerpc: (155 commits)
      powerpc/powernv: Add missing include to LPC code
      selftests/powerpc: Test the THP bug we fixed in the previous commit
      powerpc/mm: Check paca psize is up to date for huge mappings
      powerpc/powernv: Pass buffer size to OPAL validate flash call
      powerpc/pseries: hcall functions are exported to modules, need _GLOBAL_TOC()
      powerpc: Exported functions __clear_user and copy_page use r2 so need _GLOBAL_TOC()
      powerpc/powernv: Set memory_block_size_bytes to 256MB
      powerpc: Allow ppc_md platform hook to override memory_block_size_bytes
      powerpc/powernv: Fix endian issues in memory error handling code
      powerpc/eeh: Skip eeh sysfs when eeh is disabled
      powerpc: 64bit sendfile is capped at 2GB
      powerpc/powernv: Provide debugfs access to the LPC bus via OPAL
      powerpc/serial: Use saner flags when creating legacy ports
      powerpc: Add cpu family documentation
      powerpc/xmon: Fix up xmon format strings
      powerpc/powernv: Add calls to support little endian host
      powerpc: Document sysfs DSCR interface
      powerpc: Fix regression of per-CPU DSCR setting
      powerpc: Split __SYSFS_SPRSETUP macro
      arch: powerpc/fadump: Cleaning up inconsistent NULL checks
      ...

commit c888770eb2c9fcc5e735965237759ffbe3a3eee9
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Sun May 4 12:23:41 2014 +0800

    powerpc/PCI: Use pci_is_bridge() to simplify code
    
    Use pci_is_bridge() to simplify code.  No functional change.
    
    Requires: 326c1cdae741 PCI: Rename pci_is_bridge() to pci_has_subordinate()
    Requires: 1c86438c9423 PCI: Add new pci_is_bridge() interface
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 83c26d829991..059e244484fe 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -362,8 +362,7 @@ static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,
 
 	/* Now scan child busses */
 	list_for_each_entry(dev, &bus->devices, bus_list) {
-		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
-		    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
+		if (pci_is_bridge(dev)) {
 			of_scan_pci_bridge(dev);
 		}
 	}

commit d2b0f6f77ee525811b6efe864efa6a4eb82eea73
Author: Gavin Shan <gwshan@linux.vnet.ibm.com>
Date:   Thu Apr 24 18:00:19 2014 +1000

    powerpc/eeh: No hotplug on permanently removed dev
    
    The issue was detected in a bit complicated test case where
    we have multiple hierarchical PEs shown as following figure:
    
                    +-----------------+
                    | PE#3     p2p#0  |
                    |          p2p#1  |
                    +-----------------+
                            |
                    +-----------------+
                    | PE#4     pdev#0 |
                    |          pdev#1 |
                    +-----------------+
    
    PE#4 (have 2 PCI devices) is the child of PE#3, which has 2 p2p
    bridges. We accidentally had less-known scenario: PE#4 was removed
    permanently from the system because of permanent failure (e.g.
    exceeding the max allowd failure times in last hour), then we detects
    EEH errors on PE#3 and tried to recover it. However, eeh_dev instances
    for pdev#0/1 were not detached from PE#4, which was still connected to
    PE#3. All of that was because of the fact that we rely on count-based
    pcibios_release_device(), which isn't reliable enough. When doing
    recovery for PE#3, we still apply hotplug on PE#4 and pdev#0/1, which
    are not valid any more. Eventually, we run into kernel crash.
    
    The patch fixes above issue from two aspects. For unplug, we simply
    skip those permanently removed PE, whose state is (EEH_PE_STATE_ISOLATED
    && !EEH_PE_STATE_RECOVERING) and its frozen count should be greater
    than EEH_MAX_ALLOWED_FREEZES. For plug, we marked all permanently
    removed EEH devices with EEH_DEV_REMOVED and return 0xFF's on read
    its PCI config so that PCI core will omit them.
    
    Signed-off-by: Gavin Shan <gwshan@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 83c26d829991..ea6470c21f4e 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -304,6 +304,9 @@ static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,
 	struct pci_dev *dev = NULL;
 	const __be32 *reg;
 	int reglen, devfn;
+#ifdef CONFIG_EEH
+	struct eeh_dev *edev = of_node_to_eeh_dev(dn);
+#endif
 
 	pr_debug("  * %s\n", dn->full_name);
 	if (!of_device_is_available(dn))
@@ -321,6 +324,12 @@ static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,
 		return dev;
 	}
 
+	/* Device removed permanently ? */
+#ifdef CONFIG_EEH
+	if (edev && (edev->mode & EEH_DEV_REMOVED))
+		return NULL;
+#endif
+
 	/* create a new pci_dev for this device */
 	dev = of_create_pci_dev(dn, bus, devfn);
 	if (!dev)

commit fc2798502f860b18f3c7121e4dc659d3d9d28d74
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Dec 9 22:54:40 2013 -0800

    PCI: Convert pcibios_resource_to_bus() to take a pci_bus, not a pci_dev
    
    These interfaces:
    
      pcibios_resource_to_bus(struct pci_dev *dev, *bus_region, *resource)
      pcibios_bus_to_resource(struct pci_dev *dev, *resource, *bus_region)
    
    took a pci_dev, but they really depend only on the pci_bus.  And we want to
    use them in resource allocation paths where we have the bus but not a
    device, so this patch converts them to take the pci_bus instead of the
    pci_dev:
    
      pcibios_resource_to_bus(struct pci_bus *bus, *bus_region, *resource)
      pcibios_bus_to_resource(struct pci_bus *bus, *resource, *bus_region)
    
    In fact, with standard PCI-PCI bridges, they only depend on the host
    bridge, because that's the only place address translation occurs, but
    we aren't going that far yet.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index ac0b034f9ae0..83c26d829991 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -111,7 +111,7 @@ static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)
 		res->name = pci_name(dev);
 		region.start = base;
 		region.end = base + size - 1;
-		pcibios_bus_to_resource(dev, res, &region);
+		pcibios_bus_to_resource(dev->bus, res, &region);
 	}
 }
 
@@ -280,7 +280,7 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 		res->flags = flags;
 		region.start = of_read_number(&ranges[1], 2);
 		region.end = region.start + size - 1;
-		pcibios_bus_to_resource(dev, res, &region);
+		pcibios_bus_to_resource(dev->bus, res, &region);
 	}
 	sprintf(bus->name, "PCI Bus %04x:%02x", pci_domain_nr(bus),
 		bus->number);

commit 3e7cec6b17d1c915cf4de1a3853f1b4ae0ed26b0
Author: Anton Blanchard <anton@samba.org>
Date:   Thu Oct 17 23:19:43 2013 +1100

    powerpc: Fix little endian issue in OF PCI scan
    
    This issue was causing the QEMU emulated USB device to fail dring
    PCI probe.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 4368ec6fdc8c..ac0b034f9ae0 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -302,7 +302,7 @@ static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,
 			    struct device_node *dn)
 {
 	struct pci_dev *dev = NULL;
-	const u32 *reg;
+	const __be32 *reg;
 	int reglen, devfn;
 
 	pr_debug("  * %s\n", dn->full_name);
@@ -312,7 +312,7 @@ static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,
 	reg = of_get_property(dn, "reg", &reglen);
 	if (reg == NULL || reglen < 20)
 		return NULL;
-	devfn = (reg[0] >> 8) & 0xff;
+	devfn = (of_read_number(reg, 1) >> 8) & 0xff;
 
 	/* Check if the PCI device is already there */
 	dev = pci_get_slot(bus, devfn);

commit a795dc548a973ff2a124a800718f0c99bcf78ea2
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Aug 7 02:01:41 2013 +1000

    powerpc: Make OF PCI device tree accesses endian safe
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 15d9105323bf..4368ec6fdc8c 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -24,12 +24,12 @@
  */
 static u32 get_int_prop(struct device_node *np, const char *name, u32 def)
 {
-	const u32 *prop;
+	const __be32 *prop;
 	int len;
 
 	prop = of_get_property(np, name, &len);
 	if (prop && len >= 4)
-		return *prop;
+		return of_read_number(prop, 1);
 	return def;
 }
 
@@ -77,7 +77,7 @@ static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)
 	unsigned int flags;
 	struct pci_bus_region region;
 	struct resource *res;
-	const u32 *addrs;
+	const __be32 *addrs;
 	u32 i;
 	int proplen;
 
@@ -86,14 +86,14 @@ static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)
 		return;
 	pr_debug("    parse addresses (%d bytes) @ %p\n", proplen, addrs);
 	for (; proplen >= 20; proplen -= 20, addrs += 5) {
-		flags = pci_parse_of_flags(addrs[0], 0);
+		flags = pci_parse_of_flags(of_read_number(addrs, 1), 0);
 		if (!flags)
 			continue;
 		base = of_read_number(&addrs[1], 2);
 		size = of_read_number(&addrs[3], 2);
 		if (!size)
 			continue;
-		i = addrs[0] & 0xff;
+		i = of_read_number(addrs, 1) & 0xff;
 		pr_debug("  base: %llx, size: %llx, i: %x\n",
 			 (unsigned long long)base,
 			 (unsigned long long)size, i);
@@ -207,7 +207,7 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 {
 	struct device_node *node = dev->dev.of_node;
 	struct pci_bus *bus;
-	const u32 *busrange, *ranges;
+	const __be32 *busrange, *ranges;
 	int len, i, mode;
 	struct pci_bus_region region;
 	struct resource *res;
@@ -230,9 +230,11 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 		return;
 	}
 
-	bus = pci_find_bus(pci_domain_nr(dev->bus), busrange[0]);
+	bus = pci_find_bus(pci_domain_nr(dev->bus),
+			   of_read_number(busrange, 1));
 	if (!bus) {
-		bus = pci_add_new_bus(dev->bus, dev, busrange[0]);
+		bus = pci_add_new_bus(dev->bus, dev,
+				      of_read_number(busrange, 1));
 		if (!bus) {
 			printk(KERN_ERR "Failed to create pci bus for %s\n",
 			       node->full_name);
@@ -241,7 +243,8 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 	}
 
 	bus->primary = dev->bus->number;
-	pci_bus_insert_busn_res(bus, busrange[0], busrange[1]);
+	pci_bus_insert_busn_res(bus, of_read_number(busrange, 1),
+				of_read_number(busrange+1, 1));
 	bus->bridge_ctl = 0;
 
 	/* parse ranges property */
@@ -254,7 +257,7 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 	}
 	i = 1;
 	for (; len >= 32; len -= 32, ranges += 8) {
-		flags = pci_parse_of_flags(ranges[0], 1);
+		flags = pci_parse_of_flags(of_read_number(ranges, 1), 1);
 		size = of_read_number(&ranges[6], 2);
 		if (flags == 0 || size == 0)
 			continue;

commit ab444ec97e8bd65fff9d489b9a409fc03979268b
Author: Gavin Shan <shangw@linux.vnet.ibm.com>
Date:   Wed Jul 24 10:24:57 2013 +0800

    powerpc/pci: Partial tree hotplug support
    
    When EEH error happens to one specific PE, the device drivers
    of its attached EEH devices (PCI devices) are checked to see
    the further action: reset with complete hotplug, or reset without
    hotplug. However, that's not enough for those PCI devices whose
    drivers can't support EEH, or those PCI devices without driver.
    So we need do so-called "partial hotplug" on basis of PCI devices.
    In the situation, part of PCI devices of the specific PE are
    unplugged and plugged again after PE reset.
    
    The patch changes pcibios_add_pci_devices() so that it can support
    full hotplug and so-called "partial" hotplug based on device-tree
    or real hardware. It's notable that pci_of_scan.c has been changed
    for a bit in order to support the "partial" hotplug based on dev-tree.
    
    Most of the generic code already supports that, we just need to
    plumb it properly on our side.
    
    Signed-off-by: Gavin Shan <shangw@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 6b0ba5854d99..15d9105323bf 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -230,11 +230,14 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 		return;
 	}
 
-	bus = pci_add_new_bus(dev->bus, dev, busrange[0]);
+	bus = pci_find_bus(pci_domain_nr(dev->bus), busrange[0]);
 	if (!bus) {
-		printk(KERN_ERR "Failed to create pci bus for %s\n",
-		       node->full_name);
-		return;
+		bus = pci_add_new_bus(dev->bus, dev, busrange[0]);
+		if (!bus) {
+			printk(KERN_ERR "Failed to create pci bus for %s\n",
+			       node->full_name);
+			return;
+		}
 	}
 
 	bus->primary = dev->bus->number;
@@ -292,6 +295,38 @@ void of_scan_pci_bridge(struct pci_dev *dev)
 }
 EXPORT_SYMBOL(of_scan_pci_bridge);
 
+static struct pci_dev *of_scan_pci_dev(struct pci_bus *bus,
+			    struct device_node *dn)
+{
+	struct pci_dev *dev = NULL;
+	const u32 *reg;
+	int reglen, devfn;
+
+	pr_debug("  * %s\n", dn->full_name);
+	if (!of_device_is_available(dn))
+		return NULL;
+
+	reg = of_get_property(dn, "reg", &reglen);
+	if (reg == NULL || reglen < 20)
+		return NULL;
+	devfn = (reg[0] >> 8) & 0xff;
+
+	/* Check if the PCI device is already there */
+	dev = pci_get_slot(bus, devfn);
+	if (dev) {
+		pci_dev_put(dev);
+		return dev;
+	}
+
+	/* create a new pci_dev for this device */
+	dev = of_create_pci_dev(dn, bus, devfn);
+	if (!dev)
+		return NULL;
+
+	pr_debug("  dev header type: %x\n", dev->hdr_type);
+	return dev;
+}
+
 /**
  * __of_scan_bus - given a PCI bus node, setup bus and scan for child devices
  * @node: device tree node for the PCI bus
@@ -302,8 +337,6 @@ static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,
 			  int rescan_existing)
 {
 	struct device_node *child;
-	const u32 *reg;
-	int reglen, devfn;
 	struct pci_dev *dev;
 
 	pr_debug("of_scan_bus(%s) bus no %d...\n",
@@ -311,16 +344,7 @@ static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,
 
 	/* Scan direct children */
 	for_each_child_of_node(node, child) {
-		pr_debug("  * %s\n", child->full_name);
-		if (!of_device_is_available(child))
-			continue;
-		reg = of_get_property(child, "reg", &reglen);
-		if (reg == NULL || reglen < 20)
-			continue;
-		devfn = (reg[0] >> 8) & 0xff;
-
-		/* create a new pci_dev for this device */
-		dev = of_create_pci_dev(child, bus, devfn);
+		dev = of_scan_pci_dev(bus, child);
 		if (!dev)
 			continue;
 		pr_debug("    dev header type: %x\n", dev->hdr_type);

commit df58f46c0f2a1d69268b734ac25c87ffb7aeb32a
Merge: 726246d2e6d0 050134864c1c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jun 14 17:47:46 2013 -0600

    Merge branch 'pci/jiang-bus-lock-v3' into next
    
    * pci/jiang-bus-lock-v3:
      PCI: Return early on allocation failures to unindent mainline code
      PCI: Simplify IOV implementation and fix reference count races
      PCI: Drop redundant setting of bus->is_added in virtfn_add_bus()
      unicore32/PCI: Remove redundant call of pci_bus_add_devices()
      m68k/PCI: Remove redundant call of pci_bus_add_devices()
      PCI: Rename pci_release_bus_bridge_dev() to pci_release_host_bridge_dev()
      PCI: Fix refcount issue in pci_create_root_bus() error recovery path
      ia64/PCI: Clean up pci_scan_root_bus() usage
      PCI: Convert alloc_pci_dev(void) to pci_alloc_dev(bus)
      PCI: Introduce pci_alloc_dev(struct pci_bus*) to replace alloc_pci_dev()
      PCI: Introduce pci_bus_{get|put}() to manage PCI bus reference count
    
    Conflicts:
            drivers/pci/probe.c

commit 8b1fce04dc2a2210f050484afa85acc3a81cfbba
Author: Gu Zheng <guz.fnst@cn.fujitsu.com>
Date:   Sat May 25 21:48:31 2013 +0800

    PCI: Convert alloc_pci_dev(void) to pci_alloc_dev(bus)
    
    Use the new pci_alloc_dev(bus) to replace the existing using of
    alloc_pci_dev(void).
    
    [bhelgaas: drop pci_bus ref later in pci_release_dev()]
    Signed-off-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Neela Syam Kolli <megaraidlinux@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 2a67e9baa59f..24d01c4eac5c 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -128,7 +128,7 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 	const char *type;
 	struct pci_slot *slot;
 
-	dev = alloc_pci_dev();
+	dev = pci_alloc_dev(bus);
 	if (!dev)
 		return NULL;
 	type = of_get_property(node, "device_type", NULL);
@@ -137,7 +137,6 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 
 	pr_debug("    create device, devfn: %x, type: %s\n", devfn, type);
 
-	dev->bus = bus;
 	dev->dev.of_node = of_node_get(node);
 	dev->dev.parent = bus->bridge;
 	dev->dev.bus = &pci_bus_type;

commit c2defb5f78e249a1402bc2af969a151af0391de8
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri May 17 15:08:50 2013 -0600

    powerpc/PCI: Use PCI_UNKNOWN for unknown power state
    
    Previously we initialized dev->current_state to 4 (PCI_D3cold), but I think
    we wanted PCI_UNKNOWN (5) here based on the comment and the fact that the
    generic version of this code, pci_setup_device(), uses PCI_UNKNOWN.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 2a67e9baa59f..d2d407d65344 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -165,7 +165,7 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 	pr_debug("    class: 0x%x\n", dev->class);
 	pr_debug("    revision: 0x%x\n", dev->revision);
 
-	dev->current_state = 4;		/* unknown power state */
+	dev->current_state = PCI_UNKNOWN;	/* unknown power state */
 	dev->error_state = pci_channel_io_normal;
 	dev->dma_mask = 0xffffffff;
 

commit cad5cef62a5a0c525d39118d2e94b6e2034d5e05
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 14:04:10 2012 -0800

    POWERPC: drivers: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 30378a19f65d..2a67e9baa59f 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -204,7 +204,7 @@ EXPORT_SYMBOL(of_create_pci_dev);
  * this routine in turn call of_scan_bus() recusively to scan for more child
  * devices.
  */
-void __devinit of_scan_pci_bridge(struct pci_dev *dev)
+void of_scan_pci_bridge(struct pci_dev *dev)
 {
 	struct device_node *node = dev->dev.of_node;
 	struct pci_bus *bus;
@@ -299,8 +299,8 @@ EXPORT_SYMBOL(of_scan_pci_bridge);
  * @bus: pci_bus structure for the PCI bus
  * @rescan_existing: Flag indicating bus has already been set up
  */
-static void __devinit __of_scan_bus(struct device_node *node,
-				    struct pci_bus *bus, int rescan_existing)
+static void __of_scan_bus(struct device_node *node, struct pci_bus *bus,
+			  int rescan_existing)
 {
 	struct device_node *child;
 	const u32 *reg;
@@ -348,8 +348,7 @@ static void __devinit __of_scan_bus(struct device_node *node,
  * @node: device tree node for the PCI bus
  * @bus: pci_bus structure for the PCI bus
  */
-void __devinit of_scan_bus(struct device_node *node,
-			   struct pci_bus *bus)
+void of_scan_bus(struct device_node *node, struct pci_bus *bus)
 {
 	__of_scan_bus(node, bus, 0);
 }
@@ -363,8 +362,7 @@ EXPORT_SYMBOL_GPL(of_scan_bus);
  * Same as of_scan_bus, but for a pci_bus structure that has already been
  * setup.
  */
-void __devinit of_rescan_bus(struct device_node *node,
-			     struct pci_bus *bus)
+void of_rescan_bus(struct device_node *node, struct pci_bus *bus)
 {
 	__of_scan_bus(node, bus, 1);
 }

commit 6dd53aa4563a2c69e80a24d2cc68d484b5ea2891
Merge: f14121ab3591 63b96f7baeba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 24 16:17:07 2012 -0700

    Merge tag 'for-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci
    
    Pull PCI changes from Bjorn Helgaas:
     "Host bridge hotplug:
        - Add MMCONFIG support for hot-added host bridges (Jiang Liu)
      Device hotplug:
        - Move fixups from __init to __devinit (Sebastian Andrzej Siewior)
        - Call FINAL fixups for hot-added devices, too (Myron Stowe)
        - Factor out generic code for P2P bridge hot-add (Yinghai Lu)
        - Remove all functions in a slot, not just those with _EJx (Amos
          Kong)
      Dynamic resource management:
        - Track bus number allocation (struct resource tree per domain)
          (Yinghai Lu)
        - Make P2P bridge 1K I/O windows work with resource reassignment
          (Bjorn Helgaas, Yinghai Lu)
        - Disable decoding while updating 64-bit BARs (Bjorn Helgaas)
      Power management:
        - Add PCIe runtime D3cold support (Huang Ying)
      Virtualization:
        - Add VFIO infrastructure (ACS, DMA source ID quirks) (Alex
          Williamson)
        - Add quirks for devices with broken INTx masking (Jan Kiszka)
      Miscellaneous:
        - Fix some PCI Express capability version issues (Myron Stowe)
        - Factor out some arch code with a weak, generic, pcibios_setup()
          (Myron Stowe)"
    
    * tag 'for-3.6' of git://git.kernel.org/pub/scm/linux/kernel/git/helgaas/pci: (122 commits)
      PCI: hotplug: ensure a consistent return value in error case
      PCI: fix undefined reference to 'pci_fixup_final_inited'
      PCI: build resource code for M68K architecture
      PCI: pciehp: remove unused pciehp_get_max_lnk_width(), pciehp_get_cur_lnk_width()
      PCI: reorder __pci_assign_resource() (no change)
      PCI: fix truncation of resource size to 32 bits
      PCI: acpiphp: merge acpiphp_debug and debug
      PCI: acpiphp: remove unused res_lock
      sparc/PCI: replace pci_cfg_fake_ranges() with pci_read_bridge_bases()
      PCI: call final fixups hot-added devices
      PCI: move final fixups from __init to __devinit
      x86/PCI: move final fixups from __init to __devinit
      MIPS/PCI: move final fixups from __init to __devinit
      PCI: support sizing P2P bridge I/O windows with 1K granularity
      PCI: reimplement P2P bridge 1K I/O windows (Intel P64H2)
      PCI: disable MEM decoding while updating 64-bit MEM BARs
      PCI: leave MEM and IO decoding disabled during 64-bit BAR sizing, too
      PCI: never discard enable/suspend/resume_early/resume fixups
      PCI: release temporary reference in __nv_msi_ht_cap_quirk()
      PCI: restructure 'pci_do_fixups()'
      ...

commit f0a875fd3f7028af904b3a60347693812abd2aad
Author: Wanpeng Li <liwp@linux.vnet.ibm.com>
Date:   Mon Jun 11 19:04:27 2012 +0000

    powerpc: Fix kernel-doc warning
    
    Warning(arch/powerpc/kernel/pci_of_scan.c:210): Excess function parameter 'node' description in 'of_scan_pci_bridge'
    Warning(arch/powerpc/kernel/vio.c:636): No description found for parameter 'desired'
    Warning(arch/powerpc/kernel/vio.c:636): Excess function parameter 'new_desired' description in 'vio_cmo_set_dev_desired'
    Warning(arch/powerpc/kernel/vio.c:1270): No description found for parameter 'viodrv'
    Warning(arch/powerpc/kernel/vio.c:1270): Excess function parameter 'drv' description in '__vio_register_driver'
    Warning(arch/powerpc/kernel/vio.c:1289): No description found for parameter 'viodrv'
    Warning(arch/powerpc/kernel/vio.c:1289): Excess function parameter 'driver' description in 'vio_unregister_driver'
    
    Signed-off-by: Wanpeng Li <liwp@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 89dde171a6fa..d7dd42bd1452 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -198,7 +198,6 @@ EXPORT_SYMBOL(of_create_pci_dev);
 
 /**
  * of_scan_pci_bridge - Set up a PCI bridge and scan for child nodes
- * @node: device tree node of bridge
  * @dev: pci_dev structure for the bridge
  *
  * of_scan_bus() calls this routine for each PCI bridge that it finds, and

commit be8e60d8bed118b19bd7038ac2f6ac6688d072d9
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:12 2012 -0700

    powerpc/PCI: register busn_res for root buses
    
    Add the host bridge bus number aperture to the resource list.
    Like the MMIO and I/O port apertures, this is used when assigning
    resources to hot-added devices or in the case of conflicts.
    
    [bhelgaas: changelog]
    CC: Paul Mackerras <paulus@samba.org>
    CC: linuxppc-dev@lists.ozlabs.org
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index a36281aa98f3..ae5ea5e04d65 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -240,7 +240,7 @@ void __devinit of_scan_pci_bridge(struct pci_dev *dev)
 	}
 
 	bus->primary = dev->bus->number;
-	bus->busn_res.end = busrange[1];
+	pci_bus_insert_busn_res(bus, busrange[0], busrange[1]);
 	bus->bridge_ctl = 0;
 
 	/* parse ranges property */

commit b918c62e086b2130a7bae44110ca516ef10bfe5a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:11 2012 -0700

    PCI: replace struct pci_bus secondary/subordinate with busn_res
    
    Replace the struct pci_bus secondary/subordinate members with the
    struct resource busn_res.  Later we'll build a resource tree of these
    bus numbers.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 89dde171a6fa..a36281aa98f3 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -240,7 +240,7 @@ void __devinit of_scan_pci_bridge(struct pci_dev *dev)
 	}
 
 	bus->primary = dev->bus->number;
-	bus->subordinate = busrange[1];
+	bus->busn_res.end = busrange[1];
 	bus->bridge_ctl = 0;
 
 	/* parse ranges property */

commit 39aa146aad3711317baa661e6c421e979c432f2d
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Mar 16 17:48:14 2012 -0600

    powerpc/PCI: convert devtree bus addresses to resource
    
    Normal PCI enumeration via PCI config space uses __pci_read_base(), where
    the PCI core applies any bus-to-resource offset.  But powerpc doesn't use
    that path when enumerating via the device tree.
    
    In 6c5705fec63d, I converted powerpc to use the PCI core bus-to-resource
    conversion, but I missed these powerpc-specific paths.  Some powerpc
    platforms fail to boot ("Cannot allocate resource region," "device not
    available," etc.) between that commit and this one.
    
    This adds the corresponding bus-to-resource conversion in the paths that
    read BAR values from the OF device tree.
    
    CC: Anton Blanchard <anton@samba.org>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index b37d0b5a796e..89dde171a6fa 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -75,6 +75,7 @@ static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)
 {
 	u64 base, size;
 	unsigned int flags;
+	struct pci_bus_region region;
 	struct resource *res;
 	const u32 *addrs;
 	u32 i;
@@ -106,10 +107,11 @@ static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)
 			printk(KERN_ERR "PCI: bad cfg reg num 0x%x\n", i);
 			continue;
 		}
-		res->start = base;
-		res->end = base + size - 1;
 		res->flags = flags;
 		res->name = pci_name(dev);
+		region.start = base;
+		region.end = base + size - 1;
+		pcibios_bus_to_resource(dev, res, &region);
 	}
 }
 
@@ -209,6 +211,7 @@ void __devinit of_scan_pci_bridge(struct pci_dev *dev)
 	struct pci_bus *bus;
 	const u32 *busrange, *ranges;
 	int len, i, mode;
+	struct pci_bus_region region;
 	struct resource *res;
 	unsigned int flags;
 	u64 size;
@@ -270,9 +273,10 @@ void __devinit of_scan_pci_bridge(struct pci_dev *dev)
 			res = bus->resource[i];
 			++i;
 		}
-		res->start = of_read_number(&ranges[1], 2);
-		res->end = res->start + size - 1;
 		res->flags = flags;
+		region.start = of_read_number(&ranges[1], 2);
+		region.end = region.start + size - 1;
+		pcibios_bus_to_resource(dev, res, &region);
 	}
 	sprintf(bus->name, "PCI Bus %04x:%02x", pci_domain_nr(bus),
 		bus->number);

commit 66b15db69c2553036cc25f6e2e74fe7e3aa2761e
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Fri May 27 10:46:24 2011 -0400

    powerpc: add export.h to files making use of EXPORT_SYMBOL
    
    With module.h being implicitly everywhere via device.h, the absence
    of explicitly including something for EXPORT_SYMBOL went unnoticed.
    Since we are heading to fix things up and clean module.h from the
    device.h file, we need to explicitly include these files now.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index fe0a5ad6f73e..b37d0b5a796e 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -15,6 +15,7 @@
  */
 
 #include <linux/pci.h>
+#include <linux/export.h>
 #include <asm/pci-bridge.h>
 #include <asm/prom.h>
 

commit 98d9f30c820d509145757e6ecbc36013aa02f7bc
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Apr 11 11:37:07 2011 +1000

    pci/of: Match PCI devices to OF nodes dynamically
    
    powerpc has two different ways of matching PCI devices to their
    corresponding OF node (if any) for historical reasons. The ppc64 one
    does a scan looking for matching bus/dev/fn, while the ppc32 one does a
    scan looking only for matching dev/fn on each level in order to be
    agnostic to busses being renumbered (which Linux does on some
    platforms).
    
    This removes both and instead moves the matching code to the PCI core
    itself. It's the most logical place to do it: when a pci_dev is created,
    we know the parent and thus can do a single level scan for the matching
    device_node (if any).
    
    The benefit is that all archs now get the matching for free. There's one
    hook the arch might want to provide to match a PHB bus to its device
    node. A default weak implementation is provided that looks for the
    parent device device node, but it's not entirely reliable on powerpc for
    various reasons so powerpc provides its own.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Michal Simek <monstr@monstr.eu>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 1e89a72fd030..fe0a5ad6f73e 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -202,9 +202,9 @@ EXPORT_SYMBOL(of_create_pci_dev);
  * this routine in turn call of_scan_bus() recusively to scan for more child
  * devices.
  */
-void __devinit of_scan_pci_bridge(struct device_node *node,
-				  struct pci_dev *dev)
+void __devinit of_scan_pci_bridge(struct pci_dev *dev)
 {
+	struct device_node *node = dev->dev.of_node;
 	struct pci_bus *bus;
 	const u32 *busrange, *ranges;
 	int len, i, mode;
@@ -238,7 +238,6 @@ void __devinit of_scan_pci_bridge(struct device_node *node,
 	bus->primary = dev->bus->number;
 	bus->subordinate = busrange[1];
 	bus->bridge_ctl = 0;
-	bus->dev.of_node = of_node_get(node);
 
 	/* parse ranges property */
 	/* PCI #address-cells == 3 and #size-cells == 2 always */
@@ -335,9 +334,7 @@ static void __devinit __of_scan_bus(struct device_node *node,
 	list_for_each_entry(dev, &bus->devices, bus_list) {
 		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
 		    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
-			struct device_node *child = pci_device_to_OF_node(dev);
-			if (child)
-				of_scan_pci_bridge(child, dev);
+			of_scan_pci_bridge(dev);
 		}
 	}
 }

commit b5d937de0367d26f65b9af1aef5f2c34c1939be0
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Feb 4 11:24:11 2011 -0700

    powerpc/pci: Make both ppc32 and ppc64 use sysdata for pci_controller
    
    Currently, ppc32 uses sysdata for the pci_controller pointer, and
    ppc64 uses it to hold the device_node pointer.  This patch moves the
    of_node pointer into (struct pci_bus*)->dev.of_node and
    (struct pci_dev*)->dev.of_node so that sysdata can be converted to always
    use the pci_controller pointer instead.  It also fixes up the
    allocating of pci devices so that the of_node pointer gets assigned
    consistently and increments the ref count.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index e751506323b4..1e89a72fd030 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -135,7 +135,7 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 	pr_debug("    create device, devfn: %x, type: %s\n", devfn, type);
 
 	dev->bus = bus;
-	dev->sysdata = node;
+	dev->dev.of_node = of_node_get(node);
 	dev->dev.parent = bus->bridge;
 	dev->dev.bus = &pci_bus_type;
 	dev->devfn = devfn;
@@ -238,7 +238,7 @@ void __devinit of_scan_pci_bridge(struct device_node *node,
 	bus->primary = dev->bus->number;
 	bus->subordinate = busrange[1];
 	bus->bridge_ctl = 0;
-	bus->sysdata = node;
+	bus->dev.of_node = of_node_get(node);
 
 	/* parse ranges property */
 	/* PCI #address-cells == 3 and #size-cells == 2 always */

commit 76ec01dbb70353928a9cee826502073ae928bbba
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed Aug 18 08:27:55 2010 +0000

    powerpc/pci: Fix checking for child bridges in PCI code.
    
    pci_device_to_OF_node() can return null, and list_for_each_entry will
    never enter the loop when dev is NULL, so it looks like this test is
    a typo.
    
    Reported-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 62dd363a9762..e751506323b4 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -336,7 +336,8 @@ static void __devinit __of_scan_bus(struct device_node *node,
 		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
 		    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
 			struct device_node *child = pci_device_to_OF_node(dev);
-			of_scan_pci_bridge(child, dev);
+			if (child)
+				of_scan_pci_bridge(child, dev);
 		}
 	}
 }

commit da9bef6735d3c5c1c0cd16717acee18d56dd59f5
Author: Julia Lawall <julia@diku.dk>
Date:   Tue Aug 3 11:35:17 2010 +0000

    powerpc/pci: Drop unnecessary null test
    
    list_for_each_entry binds its first argument to a non-null value, and thus
    any null test on the value of that argument is superfluous.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    iterator I;
    expression x,E,E1,E2;
    statement S,S1,S2;
    @@
    
    I(x,...) { <...
    - if (x != NULL || ...)
      S
      ...> }
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 6ddb795f83e8..62dd363a9762 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -336,8 +336,7 @@ static void __devinit __of_scan_bus(struct device_node *node,
 		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
 		    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
 			struct device_node *child = pci_device_to_OF_node(dev);
-			if (dev)
-				of_scan_pci_bridge(child, dev);
+			of_scan_pci_bridge(child, dev);
 		}
 	}
 }

commit 5b339bdf164d8aee394609768f7e2e4415b0252a
Author: Sonny Rao <sonnyrao@us.ibm.com>
Date:   Mon May 10 15:13:41 2010 +0000

    powerpc/pci: Check devices status property when scanning OF tree
    
    We ran into an issue where it looks like we're not properly ignoring a
    pci device with a non-good status property when we walk the device tree
    and instanciate the Linux side PCI devices.
    
    However, the EEH init code does look for the property and disables EEH
    on these devices. This leaves us in an inconsistent where we are poking
    at a supposedly bad piece of hardware and RTAS will block our config
    cycles because EEH isn't enabled anyway.
    
    Signed-of-by: Sonny Rao <sonnyrao@linux.vnet.ibm.com>
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index cd11d5ca80df..6ddb795f83e8 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -310,6 +310,8 @@ static void __devinit __of_scan_bus(struct device_node *node,
 	/* Scan direct children */
 	for_each_child_of_node(node, child) {
 		pr_debug("  * %s\n", child->full_name);
+		if (!of_device_is_available(child))
+			continue;
 		reg = of_get_property(child, "reg", &reglen);
 		if (reg == NULL || reglen < 20)
 			continue;

commit 8354be9c104db8e92bb079e29540fbafb7f09b5c
Author: Frans Pop <elendil@planet.nl>
Date:   Sat Feb 6 07:47:20 2010 +0000

    powerpc: Remove trailing space in messages
    
    Signed-off-by: Frans Pop <elendil@planet.nl>
    Cc: linuxppc-dev@ozlabs.org
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 4aa17401657b..cd11d5ca80df 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -304,7 +304,7 @@ static void __devinit __of_scan_bus(struct device_node *node,
 	int reglen, devfn;
 	struct pci_dev *dev;
 
-	pr_debug("of_scan_bus(%s) bus no %d... \n",
+	pr_debug("of_scan_bus(%s) bus no %d...\n",
 		 node->full_name, bus->number);
 
 	/* Scan direct children */

commit 94afc008e1e6fbadfac0b75fcf193b6d7074b2f1
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jan 26 17:10:05 2010 +0000

    powerpc/pci: Add missing call to header fixup
    
    Add missing call to  pci_fixup_device(pci_fixup_early, ...) when
    building the pci_dev from scratch off the Open Firmware device-tree
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index b6b2e86a50d2..4aa17401657b 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -166,6 +166,9 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 	dev->error_state = pci_channel_io_normal;
 	dev->dma_mask = 0xffffffff;
 
+	/* Early fixups, before probing the BARs */
+	pci_fixup_device(pci_fixup_early, dev);
+
 	if (!strcmp(type, "pci") || !strcmp(type, "pciex")) {
 		/* a PCI-PCI bridge */
 		dev->hdr_type = PCI_HEADER_TYPE_BRIDGE;

commit 26b4a0ca46985ae9586c194f7859f3838b1230f8
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jan 26 17:10:05 2010 +0000

    powerpc/pci: Add missing hookup to pci_slot
    
    Add missing hookup to existing pci_slot when building the pci_dev from
    scratch off the Open Firmware device-tree
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 693eb9a25bfa..b6b2e86a50d2 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -123,6 +123,7 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 {
 	struct pci_dev *dev;
 	const char *type;
+	struct pci_slot *slot;
 
 	dev = alloc_pci_dev();
 	if (!dev)
@@ -142,6 +143,10 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 	dev->needs_freset = 0;		/* pcie fundamental reset required */
 	set_pcie_port_type(dev);
 
+	list_for_each_entry(slot, &dev->bus->slots, list)
+		if (PCI_SLOT(dev->devfn) == slot->number)
+			dev->slot = slot;
+
 	dev->vendor = get_int_prop(node, "vendor-id", 0xffff);
 	dev->device = get_int_prop(node, "device-id", 0xffff);
 	dev->subsystem_vendor = get_int_prop(node, "subsystem-vendor-id", 0);

commit bb209c8287d2d55ec4a67e3933346e0a3ee0da76
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jan 26 17:10:03 2010 +0000

    powerpc/pci: Add calls to set_pcie_port_type() and set_pcie_hotplug_bridge()
    
    We are missing these when building the pci_dev from scratch off
    the Open Firmware device-tree
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
index 7311fdfb9bf8..693eb9a25bfa 100644
--- a/arch/powerpc/kernel/pci_of_scan.c
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -140,6 +140,7 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 	dev->devfn = devfn;
 	dev->multifunction = 0;		/* maybe a lie? */
 	dev->needs_freset = 0;		/* pcie fundamental reset required */
+	set_pcie_port_type(dev);
 
 	dev->vendor = get_int_prop(node, "vendor-id", 0xffff);
 	dev->device = get_int_prop(node, "device-id", 0xffff);
@@ -164,6 +165,7 @@ struct pci_dev *of_create_pci_dev(struct device_node *node,
 		/* a PCI-PCI bridge */
 		dev->hdr_type = PCI_HEADER_TYPE_BRIDGE;
 		dev->rom_base_reg = PCI_ROM_ADDRESS1;
+		set_pcie_hotplug_bridge(dev);
 	} else if (!strcmp(type, "cardbus")) {
 		dev->hdr_type = PCI_HEADER_TYPE_CARDBUS;
 	} else {

commit 4406c56d0a4da7a37b9180abeaece6cd00bcc874
Merge: 6b7b352f2102 5e3573db2bd5
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Sep 16 07:49:54 2009 -0700

    Merge branch 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6
    
    * 'linux-next' of git://git.kernel.org/pub/scm/linux/kernel/git/jbarnes/pci-2.6: (75 commits)
      PCI hotplug: clean up acpi_run_hpp()
      PCI hotplug: acpiphp: use generic pci_configure_slot()
      PCI hotplug: shpchp: use generic pci_configure_slot()
      PCI hotplug: pciehp: use generic pci_configure_slot()
      PCI hotplug: add pci_configure_slot()
      PCI hotplug: clean up acpi_get_hp_params_from_firmware() interface
      PCI hotplug: acpiphp: don't cache hotplug_params in acpiphp_bridge
      PCI hotplug: acpiphp: remove superfluous _HPP/_HPX evaluation
      PCI: Clear saved_state after the state has been restored
      PCI PM: Return error codes from pci_pm_resume()
      PCI: use dev_printk in quirk messages
      PCI / PCIe portdrv: Fix pcie_portdrv_slot_reset()
      PCI Hotplug: convert acpi_pci_detect_ejectable() to take an acpi_handle
      PCI Hotplug: acpiphp: find bridges the easy way
      PCI: pcie portdrv: remove unused variable
      PCI / ACPI PM: Propagate wake-up enable for devices w/o ACPI support
      ACPI PM: Replace wakeup.prepared with reference counter
      PCI PM: Introduce device flag wakeup_prepared
      PCI / ACPI PM: Rework some debug messages
      PCI PM: Simplify PCI wake-up code
      ...
    
    Fixed up conflict in arch/powerpc/kernel/pci_64.c due to OF device tree
    scanning having been moved and merged for the 32- and 64-bit cases.  The
    'needs_freset' initialization added in 6e19314cc ("PCI/powerpc: support
    PCIe fundamental reset") is now in arch/powerpc/kernel/pci_of_scan.c.

commit fbe65447197789a3ccccc27755956f6a4c445089
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Aug 25 20:07:11 2009 +0000

    powerpc/pci: move pci_64.c device tree scanning code into pci-common.c
    
    The PCI device tree scanning code in pci_64.c is some useful functionality.
    It allows PCI devices to be described in the device tree instead of being
    probed for, which in turn allows pci devices to use all of the device tree
    facilities to describe complex PCI bus architectures like GPIO and IRQ
    routing (perhaps not a common situation for desktop or server systems,
    but useful for embedded systems with on-board PCI devices).
    
    This patch moves the device tree scanning into pci-common.c so it is
    available for 32-bit powerpc machines too.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/kernel/pci_of_scan.c b/arch/powerpc/kernel/pci_of_scan.c
new file mode 100644
index 000000000000..72c31bcb7aa4
--- /dev/null
+++ b/arch/powerpc/kernel/pci_of_scan.c
@@ -0,0 +1,358 @@
+/*
+ * Helper routines to scan the device tree for PCI devices and busses
+ *
+ * Migrated out of PowerPC architecture pci_64.c file by Grant Likely
+ * <grant.likely@secretlab.ca> so that these routines are available for
+ * 32 bit also.
+ *
+ * Copyright (C) 2003 Anton Blanchard <anton@au.ibm.com>, IBM
+ *   Rework, based on alpha PCI code.
+ * Copyright (c) 2009 Secret Lab Technologies Ltd.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * version 2 as published by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <asm/pci-bridge.h>
+#include <asm/prom.h>
+
+/**
+ * get_int_prop - Decode a u32 from a device tree property
+ */
+static u32 get_int_prop(struct device_node *np, const char *name, u32 def)
+{
+	const u32 *prop;
+	int len;
+
+	prop = of_get_property(np, name, &len);
+	if (prop && len >= 4)
+		return *prop;
+	return def;
+}
+
+/**
+ * pci_parse_of_flags - Parse the flags cell of a device tree PCI address
+ * @addr0: value of 1st cell of a device tree PCI address.
+ * @bridge: Set this flag if the address is from a bridge 'ranges' property
+ */
+unsigned int pci_parse_of_flags(u32 addr0, int bridge)
+{
+	unsigned int flags = 0;
+
+	if (addr0 & 0x02000000) {
+		flags = IORESOURCE_MEM | PCI_BASE_ADDRESS_SPACE_MEMORY;
+		flags |= (addr0 >> 22) & PCI_BASE_ADDRESS_MEM_TYPE_64;
+		flags |= (addr0 >> 28) & PCI_BASE_ADDRESS_MEM_TYPE_1M;
+		if (addr0 & 0x40000000)
+			flags |= IORESOURCE_PREFETCH
+				 | PCI_BASE_ADDRESS_MEM_PREFETCH;
+		/* Note: We don't know whether the ROM has been left enabled
+		 * by the firmware or not. We mark it as disabled (ie, we do
+		 * not set the IORESOURCE_ROM_ENABLE flag) for now rather than
+		 * do a config space read, it will be force-enabled if needed
+		 */
+		if (!bridge && (addr0 & 0xff) == 0x30)
+			flags |= IORESOURCE_READONLY;
+	} else if (addr0 & 0x01000000)
+		flags = IORESOURCE_IO | PCI_BASE_ADDRESS_SPACE_IO;
+	if (flags)
+		flags |= IORESOURCE_SIZEALIGN;
+	return flags;
+}
+
+/**
+ * of_pci_parse_addrs - Parse PCI addresses assigned in the device tree node
+ * @node: device tree node for the PCI device
+ * @dev: pci_dev structure for the device
+ *
+ * This function parses the 'assigned-addresses' property of a PCI devices'
+ * device tree node and writes them into the associated pci_dev structure.
+ */
+static void of_pci_parse_addrs(struct device_node *node, struct pci_dev *dev)
+{
+	u64 base, size;
+	unsigned int flags;
+	struct resource *res;
+	const u32 *addrs;
+	u32 i;
+	int proplen;
+
+	addrs = of_get_property(node, "assigned-addresses", &proplen);
+	if (!addrs)
+		return;
+	pr_debug("    parse addresses (%d bytes) @ %p\n", proplen, addrs);
+	for (; proplen >= 20; proplen -= 20, addrs += 5) {
+		flags = pci_parse_of_flags(addrs[0], 0);
+		if (!flags)
+			continue;
+		base = of_read_number(&addrs[1], 2);
+		size = of_read_number(&addrs[3], 2);
+		if (!size)
+			continue;
+		i = addrs[0] & 0xff;
+		pr_debug("  base: %llx, size: %llx, i: %x\n",
+			 (unsigned long long)base,
+			 (unsigned long long)size, i);
+
+		if (PCI_BASE_ADDRESS_0 <= i && i <= PCI_BASE_ADDRESS_5) {
+			res = &dev->resource[(i - PCI_BASE_ADDRESS_0) >> 2];
+		} else if (i == dev->rom_base_reg) {
+			res = &dev->resource[PCI_ROM_RESOURCE];
+			flags |= IORESOURCE_READONLY | IORESOURCE_CACHEABLE;
+		} else {
+			printk(KERN_ERR "PCI: bad cfg reg num 0x%x\n", i);
+			continue;
+		}
+		res->start = base;
+		res->end = base + size - 1;
+		res->flags = flags;
+		res->name = pci_name(dev);
+	}
+}
+
+/**
+ * of_create_pci_dev - Given a device tree node on a pci bus, create a pci_dev
+ * @node: device tree node pointer
+ * @bus: bus the device is sitting on
+ * @devfn: PCI function number, extracted from device tree by caller.
+ */
+struct pci_dev *of_create_pci_dev(struct device_node *node,
+				 struct pci_bus *bus, int devfn)
+{
+	struct pci_dev *dev;
+	const char *type;
+
+	dev = alloc_pci_dev();
+	if (!dev)
+		return NULL;
+	type = of_get_property(node, "device_type", NULL);
+	if (type == NULL)
+		type = "";
+
+	pr_debug("    create device, devfn: %x, type: %s\n", devfn, type);
+
+	dev->bus = bus;
+	dev->sysdata = node;
+	dev->dev.parent = bus->bridge;
+	dev->dev.bus = &pci_bus_type;
+	dev->devfn = devfn;
+	dev->multifunction = 0;		/* maybe a lie? */
+
+	dev->vendor = get_int_prop(node, "vendor-id", 0xffff);
+	dev->device = get_int_prop(node, "device-id", 0xffff);
+	dev->subsystem_vendor = get_int_prop(node, "subsystem-vendor-id", 0);
+	dev->subsystem_device = get_int_prop(node, "subsystem-id", 0);
+
+	dev->cfg_size = pci_cfg_space_size(dev);
+
+	dev_set_name(&dev->dev, "%04x:%02x:%02x.%d", pci_domain_nr(bus),
+		dev->bus->number, PCI_SLOT(devfn), PCI_FUNC(devfn));
+	dev->class = get_int_prop(node, "class-code", 0);
+	dev->revision = get_int_prop(node, "revision-id", 0);
+
+	pr_debug("    class: 0x%x\n", dev->class);
+	pr_debug("    revision: 0x%x\n", dev->revision);
+
+	dev->current_state = 4;		/* unknown power state */
+	dev->error_state = pci_channel_io_normal;
+	dev->dma_mask = 0xffffffff;
+
+	if (!strcmp(type, "pci") || !strcmp(type, "pciex")) {
+		/* a PCI-PCI bridge */
+		dev->hdr_type = PCI_HEADER_TYPE_BRIDGE;
+		dev->rom_base_reg = PCI_ROM_ADDRESS1;
+	} else if (!strcmp(type, "cardbus")) {
+		dev->hdr_type = PCI_HEADER_TYPE_CARDBUS;
+	} else {
+		dev->hdr_type = PCI_HEADER_TYPE_NORMAL;
+		dev->rom_base_reg = PCI_ROM_ADDRESS;
+		/* Maybe do a default OF mapping here */
+		dev->irq = NO_IRQ;
+	}
+
+	of_pci_parse_addrs(node, dev);
+
+	pr_debug("    adding to system ...\n");
+
+	pci_device_add(dev, bus);
+
+	return dev;
+}
+EXPORT_SYMBOL(of_create_pci_dev);
+
+/**
+ * of_scan_pci_bridge - Set up a PCI bridge and scan for child nodes
+ * @node: device tree node of bridge
+ * @dev: pci_dev structure for the bridge
+ *
+ * of_scan_bus() calls this routine for each PCI bridge that it finds, and
+ * this routine in turn call of_scan_bus() recusively to scan for more child
+ * devices.
+ */
+void __devinit of_scan_pci_bridge(struct device_node *node,
+				  struct pci_dev *dev)
+{
+	struct pci_bus *bus;
+	const u32 *busrange, *ranges;
+	int len, i, mode;
+	struct resource *res;
+	unsigned int flags;
+	u64 size;
+
+	pr_debug("of_scan_pci_bridge(%s)\n", node->full_name);
+
+	/* parse bus-range property */
+	busrange = of_get_property(node, "bus-range", &len);
+	if (busrange == NULL || len != 8) {
+		printk(KERN_DEBUG "Can't get bus-range for PCI-PCI bridge %s\n",
+		       node->full_name);
+		return;
+	}
+	ranges = of_get_property(node, "ranges", &len);
+	if (ranges == NULL) {
+		printk(KERN_DEBUG "Can't get ranges for PCI-PCI bridge %s\n",
+		       node->full_name);
+		return;
+	}
+
+	bus = pci_add_new_bus(dev->bus, dev, busrange[0]);
+	if (!bus) {
+		printk(KERN_ERR "Failed to create pci bus for %s\n",
+		       node->full_name);
+		return;
+	}
+
+	bus->primary = dev->bus->number;
+	bus->subordinate = busrange[1];
+	bus->bridge_ctl = 0;
+	bus->sysdata = node;
+
+	/* parse ranges property */
+	/* PCI #address-cells == 3 and #size-cells == 2 always */
+	res = &dev->resource[PCI_BRIDGE_RESOURCES];
+	for (i = 0; i < PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES; ++i) {
+		res->flags = 0;
+		bus->resource[i] = res;
+		++res;
+	}
+	i = 1;
+	for (; len >= 32; len -= 32, ranges += 8) {
+		flags = pci_parse_of_flags(ranges[0], 1);
+		size = of_read_number(&ranges[6], 2);
+		if (flags == 0 || size == 0)
+			continue;
+		if (flags & IORESOURCE_IO) {
+			res = bus->resource[0];
+			if (res->flags) {
+				printk(KERN_ERR "PCI: ignoring extra I/O range"
+				       " for bridge %s\n", node->full_name);
+				continue;
+			}
+		} else {
+			if (i >= PCI_NUM_RESOURCES - PCI_BRIDGE_RESOURCES) {
+				printk(KERN_ERR "PCI: too many memory ranges"
+				       " for bridge %s\n", node->full_name);
+				continue;
+			}
+			res = bus->resource[i];
+			++i;
+		}
+		res->start = of_read_number(&ranges[1], 2);
+		res->end = res->start + size - 1;
+		res->flags = flags;
+	}
+	sprintf(bus->name, "PCI Bus %04x:%02x", pci_domain_nr(bus),
+		bus->number);
+	pr_debug("    bus name: %s\n", bus->name);
+
+	mode = PCI_PROBE_NORMAL;
+	if (ppc_md.pci_probe_mode)
+		mode = ppc_md.pci_probe_mode(bus);
+	pr_debug("    probe mode: %d\n", mode);
+
+	if (mode == PCI_PROBE_DEVTREE)
+		of_scan_bus(node, bus);
+	else if (mode == PCI_PROBE_NORMAL)
+		pci_scan_child_bus(bus);
+}
+EXPORT_SYMBOL(of_scan_pci_bridge);
+
+/**
+ * __of_scan_bus - given a PCI bus node, setup bus and scan for child devices
+ * @node: device tree node for the PCI bus
+ * @bus: pci_bus structure for the PCI bus
+ * @rescan_existing: Flag indicating bus has already been set up
+ */
+static void __devinit __of_scan_bus(struct device_node *node,
+				    struct pci_bus *bus, int rescan_existing)
+{
+	struct device_node *child;
+	const u32 *reg;
+	int reglen, devfn;
+	struct pci_dev *dev;
+
+	pr_debug("of_scan_bus(%s) bus no %d... \n",
+		 node->full_name, bus->number);
+
+	/* Scan direct children */
+	for_each_child_of_node(node, child) {
+		pr_debug("  * %s\n", child->full_name);
+		reg = of_get_property(child, "reg", &reglen);
+		if (reg == NULL || reglen < 20)
+			continue;
+		devfn = (reg[0] >> 8) & 0xff;
+
+		/* create a new pci_dev for this device */
+		dev = of_create_pci_dev(child, bus, devfn);
+		if (!dev)
+			continue;
+		pr_debug("    dev header type: %x\n", dev->hdr_type);
+	}
+
+	/* Apply all fixups necessary. We don't fixup the bus "self"
+	 * for an existing bridge that is being rescanned
+	 */
+	if (!rescan_existing)
+		pcibios_setup_bus_self(bus);
+	pcibios_setup_bus_devices(bus);
+
+	/* Now scan child busses */
+	list_for_each_entry(dev, &bus->devices, bus_list) {
+		if (dev->hdr_type == PCI_HEADER_TYPE_BRIDGE ||
+		    dev->hdr_type == PCI_HEADER_TYPE_CARDBUS) {
+			struct device_node *child = pci_device_to_OF_node(dev);
+			if (dev)
+				of_scan_pci_bridge(child, dev);
+		}
+	}
+}
+
+/**
+ * of_scan_bus - given a PCI bus node, setup bus and scan for child devices
+ * @node: device tree node for the PCI bus
+ * @bus: pci_bus structure for the PCI bus
+ */
+void __devinit of_scan_bus(struct device_node *node,
+			   struct pci_bus *bus)
+{
+	__of_scan_bus(node, bus, 0);
+}
+EXPORT_SYMBOL_GPL(of_scan_bus);
+
+/**
+ * of_rescan_bus - given a PCI bus node, scan for child devices
+ * @node: device tree node for the PCI bus
+ * @bus: pci_bus structure for the PCI bus
+ *
+ * Same as of_scan_bus, but for a pci_bus structure that has already been
+ * setup.
+ */
+void __devinit of_rescan_bus(struct device_node *node,
+			     struct pci_bus *bus)
+{
+	__of_scan_bus(node, bus, 1);
+}
+EXPORT_SYMBOL_GPL(of_rescan_bus);
+
