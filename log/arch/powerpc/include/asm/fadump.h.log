commit bec53196adf4791d466adf0e339b61186c7b5283
Author: Hari Bathini <hbathini@linux.ibm.com>
Date:   Wed Sep 11 20:26:03 2019 +0530

    powerpc/fadump: add support to preserve crash data on FADUMP disabled kernel
    
    Add a new kernel config option, CONFIG_PRESERVE_FA_DUMP that ensures
    that crash data, from previously crash'ed kernel, is preserved. This
    helps in cases where FADump is not enabled but the subsequent memory
    preserving kernel boot is likely to process this crash data. One
    typical usecase for this config option is petitboot kernel.
    
    As OPAL allows registering address with it in the first kernel and
    retrieving it after MPIPL, use it to store the top of boot memory.
    A kernel that intends to preserve crash data retrieves it and avoids
    using memory beyond this address.
    
    Move arch_reserved_kernel_pages() function as it is needed for both
    FA_DUMP and PRESERVE_FA_DUMP configurations.
    
    Signed-off-by: Hari Bathini <hbathini@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/156821375751.5656.11459483669542541602.stgit@hbathini.in.ibm.com

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index fd5002b4c18c..526a6a647312 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -14,9 +14,6 @@
 extern int crashing_cpu;
 
 extern int is_fadump_memory_area(u64 addr, ulong size);
-extern int early_init_dt_scan_fw_dump(unsigned long node,
-		const char *uname, int depth, void *data);
-extern int fadump_reserve_mem(void);
 extern int setup_fadump(void);
 extern int is_fadump_active(void);
 extern int should_fadump_crash(void);
@@ -29,4 +26,10 @@ static inline int should_fadump_crash(void) { return 0; }
 static inline void crash_fadump(struct pt_regs *regs, const char *str) { }
 static inline void fadump_cleanup(void) { }
 #endif /* !CONFIG_FA_DUMP */
+
+#if defined(CONFIG_FA_DUMP) || defined(CONFIG_PRESERVE_FA_DUMP)
+extern int early_init_dt_scan_fw_dump(unsigned long node, const char *uname,
+				      int depth, void *data);
+extern int fadump_reserve_mem(void);
+#endif
 #endif /* _ASM_POWERPC_FADUMP_H */

commit 0226e55275e569126882a7befe0b1a1c9bd270aa
Author: Hari Bathini <hbathini@linux.ibm.com>
Date:   Wed Sep 11 20:18:14 2019 +0530

    powerpc/fadump: move rtas specific definitions to platform code
    
    Currently, FADump is only supported on pSeries but that is going to
    change soon with FADump support being added on PowerNV platform. So,
    move rtas specific definitions to platform code to allow FADump
    to have multiple platforms support.
    
    Signed-off-by: Hari Bathini <hbathini@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/156821328494.5656.16219929140866195511.stgit@hbathini.in.ibm.com

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 751794978427..fd5002b4c18c 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -6,121 +6,13 @@
  * Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
  */
 
-#ifndef __PPC64_FA_DUMP_H__
-#define __PPC64_FA_DUMP_H__
+#ifndef _ASM_POWERPC_FADUMP_H
+#define _ASM_POWERPC_FADUMP_H
 
 #ifdef CONFIG_FA_DUMP
 
-/* Firmware provided dump sections */
-#define FADUMP_CPU_STATE_DATA	0x0001
-#define FADUMP_HPTE_REGION	0x0002
-#define FADUMP_REAL_MODE_REGION	0x0011
-
-/* Dump request flag */
-#define FADUMP_REQUEST_FLAG	0x00000001
-
-/* Dump status flag */
-#define FADUMP_ERROR_FLAG	0x2000
-
-#define FADUMP_CPU_ID_MASK	((1UL << 32) - 1)
-
-#define CPU_UNKNOWN		(~((u32)0))
-
-/* Utility macros */
-#define SKIP_TO_NEXT_CPU(reg_entry)					\
-({									\
-	while (be64_to_cpu(reg_entry->reg_id) != REG_ID("CPUEND"))	\
-		reg_entry++;						\
-	reg_entry++;							\
-})
-
 extern int crashing_cpu;
 
-/* Kernel Dump section info */
-struct fadump_section {
-	__be32	request_flag;
-	__be16	source_data_type;
-	__be16	error_flags;
-	__be64	source_address;
-	__be64	source_len;
-	__be64	bytes_dumped;
-	__be64	destination_address;
-};
-
-/* ibm,configure-kernel-dump header. */
-struct fadump_section_header {
-	__be32	dump_format_version;
-	__be16	dump_num_sections;
-	__be16	dump_status_flag;
-	__be32	offset_first_dump_section;
-
-	/* Fields for disk dump option. */
-	__be32	dd_block_size;
-	__be64	dd_block_offset;
-	__be64	dd_num_blocks;
-	__be32	dd_offset_disk_path;
-
-	/* Maximum time allowed to prevent an automatic dump-reboot. */
-	__be32	max_time_auto;
-};
-
-/*
- * Firmware Assisted dump memory structure. This structure is required for
- * registering future kernel dump with power firmware through rtas call.
- *
- * No disk dump option. Hence disk dump path string section is not included.
- */
-struct fadump_mem_struct {
-	struct fadump_section_header	header;
-
-	/* Kernel dump sections */
-	struct fadump_section		cpu_state_data;
-	struct fadump_section		hpte_region;
-	struct fadump_section		rmr_region;
-};
-
-/*
- * Copy the ascii values for first 8 characters from a string into u64
- * variable at their respective indexes.
- * e.g.
- *  The string "FADMPINF" will be converted into 0x4641444d50494e46
- */
-static inline u64 str_to_u64(const char *str)
-{
-	u64 val = 0;
-	int i;
-
-	for (i = 0; i < sizeof(val); i++)
-		val = (*str) ? (val << 8) | *str++ : val << 8;
-	return val;
-}
-#define STR_TO_HEX(x)	str_to_u64(x)
-#define REG_ID(x)	str_to_u64(x)
-
-#define REGSAVE_AREA_MAGIC		STR_TO_HEX("REGSAVE")
-
-/* The firmware-assisted dump format.
- *
- * The register save area is an area in the partition's memory used to preserve
- * the register contents (CPU state data) for the active CPUs during a firmware
- * assisted dump. The dump format contains register save area header followed
- * by register entries. Each list of registers for a CPU starts with
- * "CPUSTRT" and ends with "CPUEND".
- */
-
-/* Register save area header. */
-struct fadump_reg_save_area_header {
-	__be64		magic_number;
-	__be32		version;
-	__be32		num_cpu_offset;
-};
-
-/* Register entry. */
-struct fadump_reg_entry {
-	__be64		reg_id;
-	__be64		reg_value;
-};
-
 extern int is_fadump_memory_area(u64 addr, ulong size);
 extern int early_init_dt_scan_fw_dump(unsigned long node,
 		const char *uname, int depth, void *data);
@@ -136,5 +28,5 @@ static inline int is_fadump_active(void) { return 0; }
 static inline int should_fadump_crash(void) { return 0; }
 static inline void crash_fadump(struct pt_regs *regs, const char *str) { }
 static inline void fadump_cleanup(void) { }
-#endif
-#endif
+#endif /* !CONFIG_FA_DUMP */
+#endif /* _ASM_POWERPC_FADUMP_H */

commit ca986d7fa7e7f7b3f018f227b999f35e654fbb79
Author: Hari Bathini <hbathini@linux.ibm.com>
Date:   Wed Sep 11 20:16:21 2019 +0530

    powerpc/fadump: move internal macros/definitions to a new header
    
    Though asm/fadump.h is meant to be used by other components dealing
    with FADump, it also has macros/definitions internal to FADump code.
    Move them to a new header file used within FADump code. This also
    makes way for refactoring platform specific FADump code.
    
    Signed-off-by: Hari Bathini <hbathini@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/156821313134.5656.6597770626574392140.stgit@hbathini.in.ibm.com

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 17d9b6acaf63..751794978427 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -11,34 +11,6 @@
 
 #ifdef CONFIG_FA_DUMP
 
-/*
- * The RMA region will be saved for later dumping when kernel crashes.
- * RMA is Real Mode Area, the first block of logical memory address owned
- * by logical partition, containing the storage that may be accessed with
- * translate off.
- */
-#define RMA_START	0x0
-#define RMA_END		(ppc64_rma_size)
-
-/*
- * On some Power systems where RMO is 128MB, it still requires minimum of
- * 256MB for kernel to boot successfully. When kdump infrastructure is
- * configured to save vmcore over network, we run into OOM issue while
- * loading modules related to network setup. Hence we need aditional 64M
- * of memory to avoid OOM issue.
- */
-#define MIN_BOOT_MEM	(((RMA_END < (0x1UL << 28)) ? (0x1UL << 28) : RMA_END) \
-			+ (0x1UL << 26))
-
-/* The upper limit percentage for user specified boot memory size (25%) */
-#define MAX_BOOT_MEM_RATIO			4
-
-#define memblock_num_regions(memblock_type)	(memblock.memblock_type.cnt)
-
-/* Alignement per CMA requirement. */
-#define FADUMP_CMA_ALIGNMENT	(PAGE_SIZE <<				\
-			max_t(unsigned long, MAX_ORDER - 1, pageblock_order))
-
 /* Firmware provided dump sections */
 #define FADUMP_CPU_STATE_DATA	0x0001
 #define FADUMP_HPTE_REGION	0x0002
@@ -47,11 +19,6 @@
 /* Dump request flag */
 #define FADUMP_REQUEST_FLAG	0x00000001
 
-/* FAD commands */
-#define FADUMP_REGISTER		1
-#define FADUMP_UNREGISTER	2
-#define FADUMP_INVALIDATE	3
-
 /* Dump status flag */
 #define FADUMP_ERROR_FLAG	0x2000
 
@@ -112,29 +79,6 @@ struct fadump_mem_struct {
 	struct fadump_section		rmr_region;
 };
 
-/* Firmware-assisted dump configuration details. */
-struct fw_dump {
-	unsigned long	cpu_state_data_size;
-	unsigned long	hpte_region_size;
-	unsigned long	boot_memory_size;
-	unsigned long	reserve_dump_area_start;
-	unsigned long	reserve_dump_area_size;
-	/* cmd line option during boot */
-	unsigned long	reserve_bootvar;
-
-	unsigned long	fadumphdr_addr;
-	unsigned long	cpu_notes_buf;
-	unsigned long	cpu_notes_buf_size;
-
-	int		ibm_configure_kernel_dump;
-
-	unsigned long	fadump_enabled:1;
-	unsigned long	fadump_supported:1;
-	unsigned long	dump_active:1;
-	unsigned long	dump_registered:1;
-	unsigned long	nocma:1;
-};
-
 /*
  * Copy the ascii values for first 8 characters from a string into u64
  * variable at their respective indexes.
@@ -153,7 +97,6 @@ static inline u64 str_to_u64(const char *str)
 #define STR_TO_HEX(x)	str_to_u64(x)
 #define REG_ID(x)	str_to_u64(x)
 
-#define FADUMP_CRASH_INFO_MAGIC		STR_TO_HEX("FADMPINF")
 #define REGSAVE_AREA_MAGIC		STR_TO_HEX("REGSAVE")
 
 /* The firmware-assisted dump format.
@@ -178,20 +121,6 @@ struct fadump_reg_entry {
 	__be64		reg_value;
 };
 
-/* fadump crash info structure */
-struct fadump_crash_info_header {
-	u64		magic_number;
-	u64		elfcorehdr_addr;
-	u32		crashing_cpu;
-	struct pt_regs	regs;
-	struct cpumask	online_mask;
-};
-
-struct fad_crash_memory_ranges {
-	unsigned long long	base;
-	unsigned long long	size;
-};
-
 extern int is_fadump_memory_area(u64 addr, ulong size);
 extern int early_init_dt_scan_fw_dump(unsigned long node,
 		const char *uname, int depth, void *data);

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index e2099c0a15c3..17d9b6acaf63 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -1,20 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Firmware Assisted dump header file.
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
- *
  * Copyright 2011 IBM Corporation
  * Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
  */

commit 9c1d38b34e944cace44e0d2bea0beb5601a4d36d
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Fri Mar 22 08:08:39 2019 +0000

    powerpc/fadump: define an empty fadump_cleanup()
    
    To avoid #ifdefs, define an static inline fadump_cleanup() function
    when CONFIG_FADUMP is not selected
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 188776befaf9..e2099c0a15c3 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -219,5 +219,6 @@ extern void fadump_cleanup(void);
 static inline int is_fadump_active(void) { return 0; }
 static inline int should_fadump_crash(void) { return 0; }
 static inline void crash_fadump(struct pt_regs *regs, const char *str) { }
+static inline void fadump_cleanup(void) { }
 #endif
 #endif

commit 0db6896ff6332ba694f1e61b93ae3b2640317633
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Mon Aug 20 13:47:32 2018 +0530

    powerpc/fadump: Do not allow hot-remove memory from fadump reserved area.
    
    For fadump to work successfully there should not be any holes in reserved
    memory ranges where kernel has asked firmware to move the content of old
    kernel memory in event of crash. Now that fadump uses CMA for reserved
    area, this memory area is now not protected from hot-remove operations
    unless it is cma allocated. Hence, fadump service can fail to re-register
    after the hot-remove operation, if hot-removed memory belongs to fadump
    reserved region. To avoid this make sure that memory from fadump reserved
    area is not hot-removable if fadump is registered.
    
    However, if user still wants to remove that memory, he can do so by
    manually stopping fadump service before hot-remove operation.
    
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 0a4e37159276..188776befaf9 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -205,7 +205,7 @@ struct fad_crash_memory_ranges {
 	unsigned long long	size;
 };
 
-extern int is_fadump_boot_memory_area(u64 addr, ulong size);
+extern int is_fadump_memory_area(u64 addr, ulong size);
 extern int early_init_dt_scan_fw_dump(unsigned long node,
 		const char *uname, int depth, void *data);
 extern int fadump_reserve_mem(void);

commit a4e92ce8e4c8275bacfe3529d6ac85d54a233d87
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Mon Aug 20 13:47:17 2018 +0530

    powerpc/fadump: Reservationless firmware assisted dump
    
    One of the primary issues with Firmware Assisted Dump (fadump) on Power
    is that it needs a large amount of memory to be reserved. On large
    systems with TeraBytes of memory, this reservation can be quite
    significant.
    
    In some cases, fadump fails if the memory reserved is insufficient, or
    if the reserved memory was DLPAR hot-removed.
    
    In the normal case, post reboot, the preserved memory is filtered to
    extract only relevant areas of interest using the makedumpfile tool.
    While the tool provides flexibility to determine what needs to be part
    of the dump and what memory to filter out, all supported distributions
    default this to "Capture only kernel data and nothing else".
    
    We take advantage of this default and the Linux kernel's Contiguous
    Memory Allocator (CMA) to fundamentally change the memory reservation
    model for fadump.
    
    Instead of setting aside a significant chunk of memory nobody can use,
    this patch uses CMA instead, to reserve a significant chunk of memory
    that the kernel is prevented from using (due to MIGRATE_CMA), but
    applications are free to use it. With this fadump will still be able
    to capture all of the kernel memory and most of the user space memory
    except the user pages that were present in CMA region.
    
    Essentially, on a P9 LPAR with 2 cores, 8GB RAM and current upstream:
    [root@zzxx-yy10 ~]# free -m
                  total        used        free      shared  buff/cache   available
    Mem:           7557         193        6822          12         541        6725
    Swap:          4095           0        4095
    
    With this patch:
    [root@zzxx-yy10 ~]# free -m
                  total        used        free      shared  buff/cache   available
    Mem:           8133         194        7464          12         475        7338
    Swap:          4095           0        4095
    
    Changes made here are completely transparent to how fadump has
    traditionally worked.
    
    Thanks to Aneesh Kumar and Anshuman Khandual for helping us understand
    CMA and its usage.
    
    TODO:
    - Handle case where CMA reservation spans nodes.
    
    Signed-off-by: Ananth N Mavinakayanahalli <ananth@linux.vnet.ibm.com>
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Hari Bathini <hbathini@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 1e7a33592e29..0a4e37159276 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -48,6 +48,10 @@
 
 #define memblock_num_regions(memblock_type)	(memblock.memblock_type.cnt)
 
+/* Alignement per CMA requirement. */
+#define FADUMP_CMA_ALIGNMENT	(PAGE_SIZE <<				\
+			max_t(unsigned long, MAX_ORDER - 1, pageblock_order))
+
 /* Firmware provided dump sections */
 #define FADUMP_CPU_STATE_DATA	0x0001
 #define FADUMP_HPTE_REGION	0x0002
@@ -141,6 +145,7 @@ struct fw_dump {
 	unsigned long	fadump_supported:1;
 	unsigned long	dump_active:1;
 	unsigned long	dump_registered:1;
+	unsigned long	nocma:1;
 };
 
 /*

commit 1bd6a1c4b80a28d975287630644e6b47d0f977a5
Author: Hari Bathini <hbathini@linux.ibm.com>
Date:   Tue Aug 7 02:12:45 2018 +0530

    powerpc/fadump: handle crash memory ranges array index overflow
    
    Crash memory ranges is an array of memory ranges of the crashing kernel
    to be exported as a dump via /proc/vmcore file. The size of the array
    is set based on INIT_MEMBLOCK_REGIONS, which works alright in most cases
    where memblock memory regions count is less than INIT_MEMBLOCK_REGIONS
    value. But this count can grow beyond INIT_MEMBLOCK_REGIONS value since
    commit 142b45a72e22 ("memblock: Add array resizing support").
    
    On large memory systems with a few DLPAR operations, the memblock memory
    regions count could be larger than INIT_MEMBLOCK_REGIONS value. On such
    systems, registering fadump results in crash or other system failures
    like below:
    
      task: c00007f39a290010 ti: c00000000b738000 task.ti: c00000000b738000
      NIP: c000000000047df4 LR: c0000000000f9e58 CTR: c00000000010f180
      REGS: c00000000b73b570 TRAP: 0300   Tainted: G          L   X  (4.4.140+)
      MSR: 8000000000009033 <SF,EE,ME,IR,DR,RI,LE>  CR: 22004484  XER: 20000000
      CFAR: c000000000008500 DAR: 000007a450000000 DSISR: 40000000 SOFTE: 0
      ...
      NIP [c000000000047df4] smp_send_reschedule+0x24/0x80
      LR [c0000000000f9e58] resched_curr+0x138/0x160
      Call Trace:
        resched_curr+0x138/0x160 (unreliable)
        check_preempt_curr+0xc8/0xf0
        ttwu_do_wakeup+0x38/0x150
        try_to_wake_up+0x224/0x4d0
        __wake_up_common+0x94/0x100
        ep_poll_callback+0xac/0x1c0
        __wake_up_common+0x94/0x100
        __wake_up_sync_key+0x70/0xa0
        sock_def_readable+0x58/0xa0
        unix_stream_sendmsg+0x2dc/0x4c0
        sock_sendmsg+0x68/0xa0
        ___sys_sendmsg+0x2cc/0x2e0
        __sys_sendmsg+0x5c/0xc0
        SyS_socketcall+0x36c/0x3f0
        system_call+0x3c/0x100
    
    as array index overflow is not checked for while setting up crash memory
    ranges causing memory corruption. To resolve this issue, dynamically
    allocate memory for crash memory ranges and resize it incrementally,
    in units of pagesize, on hitting array size limit.
    
    Fixes: 2df173d9e85d ("fadump: Initialize elfcore header and add PT_LOAD program headers.")
    Cc: stable@vger.kernel.org # v3.4+
    Signed-off-by: Hari Bathini <hbathini@linux.ibm.com>
    Reviewed-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    [mpe: Just use PAGE_SIZE directly, fixup variable placement]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 5a23010af600..1e7a33592e29 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -195,9 +195,6 @@ struct fadump_crash_info_header {
 	struct cpumask	online_mask;
 };
 
-/* Crash memory ranges */
-#define INIT_CRASHMEM_RANGES	(INIT_MEMBLOCK_REGIONS + 2)
-
 struct fad_crash_memory_ranges {
 	unsigned long long	base;
 	unsigned long long	size;

commit 6fcd6baa90aeec9dcbe30786e15c125bf50503b2
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Jul 19 16:59:11 2017 +1000

    powerpc/powernv: Use kernel crash path for machine checks
    
    There are quite a few machine check exceptions that can be caused by
    kernel bugs. To make debugging easier, use the kernel crash path in
    cases of synchronous machine checks that occur in kernel mode, if that
    would not result in the machine going straight to panic or crash dump.
    
    There is a downside here that die()ing the process in kernel mode can
    still leave the system unstable. panic_on_oops will always force the
    system to fail-stop, so systems where that behaviour is important will
    still do the right thing.
    
    As a test, when triggering an i-side 0111b error (ifetch from foreign
    address) in kernel mode process context on POWER9, the kernel currently
    dies quickly like this:
    
      Severe Machine check interrupt [Not recovered]
        NIP [ffff000000000000]: 0xffff000000000000
        Initiator: CPU
        Error type: Real address [Instruction fetch (foreign)]
      [  127.426651616,0] OPAL: Reboot requested due to Platform error.
          Effective[  127.426693712,3] OPAL: Reboot requested due to Platform error. address: ffff000000000000
      opal: Reboot type 1 not supported
      Kernel panic - not syncing: PowerNV Unrecovered Machine Check
      CPU: 56 PID: 4425 Comm: syscall Tainted: G   M            4.12.0-rc1-13857-ga4700a261072-dirty #35
      Call Trace:
      [  128.017988928,4] IPMI: BUG: Dropping ESEL on the floor due to
        buggy/mising code in OPAL for this BMC
        Rebooting in 10 seconds..
      Trying to free IRQ 496 from IRQ context!
    
    After this patch, the process is killed and the kernel continues with
    this message, which gives enough information to identify the offending
    branch (i.e., with CFAR):
    
      Severe Machine check interrupt [Not recovered]
        NIP [ffff000000000000]: 0xffff000000000000
        Initiator: CPU
        Error type: Real address [Instruction fetch (foreign)]
          Effective address: ffff000000000000
      Oops: Machine check, sig: 7 [#1]
      SMP NR_CPUS=2048
      NUMA
      PowerNV
      Modules linked in: iptable_mangle ipt_MASQUERADE nf_nat_masquerade_ipv4 ...
      CPU: 22 PID: 4436 Comm: syscall Tainted: G   M            4.12.0-rc1-13857-ga4700a261072-dirty #36
      task: c000000932300000 task.stack: c000000932380000
      NIP: ffff000000000000 LR: 00000000217706a4 CTR: ffff000000000000
      REGS: c00000000fc8fd80 TRAP: 0200   Tainted: G   M             (4.12.0-rc1-13857-ga4700a261072-dirty)
      MSR: 90000000001c1003 <SF,HV,ME,RI,LE>
        CR: 24000484  XER: 20000000
      CFAR: c000000000004c80 DAR: 0000000021770a90 DSISR: 0a000000 SOFTE: 1
      GPR00: 0000000000001ebe 00007fffce4818b0 0000000021797f00 0000000000000000
      GPR04: 00007fff8007ac24 0000000044000484 0000000000004000 00007fff801405e8
      GPR08: 900000000280f033 0000000024000484 0000000000000000 0000000000000030
      GPR12: 9000000000001003 00007fff801bc370 0000000000000000 0000000000000000
      GPR16: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR20: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR24: 0000000000000000 0000000000000000 0000000000000000 0000000000000000
      GPR28: 00007fff801b0000 0000000000000000 00000000217707a0 00007fffce481918
      NIP [ffff000000000000] 0xffff000000000000
      LR [00000000217706a4] 0x217706a4
      Call Trace:
      Instruction dump:
      XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
      XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX XXXXXXXX
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Reviewed-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index ce88bbe1d809..5a23010af600 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -209,11 +209,13 @@ extern int early_init_dt_scan_fw_dump(unsigned long node,
 extern int fadump_reserve_mem(void);
 extern int setup_fadump(void);
 extern int is_fadump_active(void);
+extern int should_fadump_crash(void);
 extern void crash_fadump(struct pt_regs *, const char *);
 extern void fadump_cleanup(void);
 
 #else	/* CONFIG_FA_DUMP */
 static inline int is_fadump_active(void) { return 0; }
+static inline int should_fadump_crash(void) { return 0; }
 static inline void crash_fadump(struct pt_regs *regs, const char *str) { }
 #endif
 #endif

commit eae0dfcc44320c79a05637534d59af4643b2ee7b
Author: Hari Bathini <hbathini@linux.vnet.ibm.com>
Date:   Thu Jun 1 22:51:26 2017 +0530

    powerpc/fadump: avoid holes in boot memory area when fadump is registered
    
    To register fadump, boot memory area - the size of low memory chunk that
    is required for a kernel to boot successfully when booted with restricted
    memory, is assumed to have no holes. But this memory area is currently
    not protected from hot-remove operations. So, fadump could fail to
    re-register after a memory hot-remove operation, if memory is removed
    from boot memory area. To avoid this, ensure that memory from boot
    memory area is not hot-removed when fadump is registered.
    
    Signed-off-by: Hari Bathini <hbathini@linux.vnet.ibm.com>
    Reviewed-by: Mahesh J Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index a3de219073af..ce88bbe1d809 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -203,6 +203,7 @@ struct fad_crash_memory_ranges {
 	unsigned long long	size;
 };
 
+extern int is_fadump_boot_memory_area(u64 addr, ulong size);
 extern int early_init_dt_scan_fw_dump(unsigned long node,
 		const char *uname, int depth, void *data);
 extern int fadump_reserve_mem(void);

commit 48a316e350974739235c234430ec0e129f864a43
Author: Hari Bathini <hbathini@linux.vnet.ibm.com>
Date:   Fri Jun 2 13:00:27 2017 +0530

    powerpc/fadump: Set an upper limit for boot memory size
    
    By default, 5% of system RAM is reserved for preserving boot memory.
    Alternatively, a user can specify the amount of memory to reserve.
    See Documentation/powerpc/firmware-assisted-dump.txt for details. In
    addition to the memory reserved for preserving boot memory, some more
    memory is reserved, to save HPTE region, CPU state data and ELF core
    headers.
    
    Memory Reservation during first kernel looks like below:
    
      Low memory                                        Top of memory
      0      boot memory size                                       |
      |           |                       |<--Reserved dump area -->|
      V           V                       |   Permanent Reservation V
      +-----------+----------/ /----------+---+----+-----------+----+
      |           |                       |CPU|HPTE|  DUMP     |ELF |
      +-----------+----------/ /----------+---+----+-----------+----+
            |                                           ^
            |                                           |
            \                                           /
             -------------------------------------------
              Boot memory content gets transferred to
              reserved area by firmware at the time of
              crash
    
    This implicitly means that the sum of the sizes of boot memory, CPU
    state data, HPTE region, DUMP preserving area and ELF core headers
    can't be greater than the total memory size. But currently, a user is
    allowed to specify any value as boot memory size. So, the above rule
    is violated when a boot memory size around 50% of the total available
    memory is specified. As the kernel is not handling this currently, it
    may lead to undefined behavior. Fix it by setting an upper limit for
    boot memory size to 25% of the total available memory. Also, instead
    of using memblock_end_of_DRAM(), which doesn't take the holes, if any,
    in the memory layout into account, use memblock_phys_mem_size() to
    calculate the percentage of total available memory.
    
    Signed-off-by: Hari Bathini <hbathini@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 60b91084f33c..a3de219073af 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -43,6 +43,9 @@
 #define MIN_BOOT_MEM	(((RMA_END < (0x1UL << 28)) ? (0x1UL << 28) : RMA_END) \
 			+ (0x1UL << 26))
 
+/* The upper limit percentage for user specified boot memory size (25%) */
+#define MAX_BOOT_MEM_RATIO			4
+
 #define memblock_num_regions(memblock_type)	(memblock.memblock_type.cnt)
 
 /* Firmware provided dump sections */

commit 22bd0177bd08677a8888f4d1d8361b0326f9119b
Author: Hari Bathini <hbathini@linux.vnet.ibm.com>
Date:   Mon May 8 15:56:24 2017 -0700

    powerpc/fadump: remove dependency with CONFIG_KEXEC
    
    Now that crashkernel parameter parsing and vmcoreinfo related code is
    moved under CONFIG_CRASH_CORE instead of CONFIG_KEXEC_CORE, remove
    dependency with CONFIG_KEXEC for CONFIG_FA_DUMP.  While here, get rid of
    definitions of fadump_append_elf_note() & fadump_final_note() functions
    to reuse similar functions compiled under CONFIG_CRASH_CORE.
    
    Link: http://lkml.kernel.org/r/149035343956.6881.1536459326017709354.stgit@hbathini.in.ibm.com
    Signed-off-by: Hari Bathini <hbathini@linux.vnet.ibm.com>
    Reviewed-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Dave Young <dyoung@redhat.com>
    Cc: Eric Biederman <ebiederm@xmission.com>
    Cc: Vivek Goyal <vgoyal@redhat.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 0031806475f0..60b91084f33c 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -73,6 +73,8 @@
 	reg_entry++;							\
 })
 
+extern int crashing_cpu;
+
 /* Kernel Dump section info */
 struct fadump_section {
 	__be32	request_flag;

commit d8bced27be25537bde3714cbdb34ccece81f6a0d
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Sep 6 15:32:42 2016 +1000

    powerpc/fadump: Set core e_flags using kernel's ELF ABI version
    
    Firmware Assisted Dump is a facility to dump kernel core with assistance
    from firmware. As part of this process the kernel ELF ABI version is
    stored in the core file.
    
    Currently fadump.h defines this to 0 if it is not already defined. This
    clashes with a define in elf.h which sets it based on the current task -
    not based on the kernel's ELF ABI version.
    
    Use the compiler-provided #define _CALL_ELF which tells us the ELF ABI
    version of the kernel to set e_flags, this matches what binutils does.
    
    Remove the definition in fadump.h, which becomes unused.
    
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Reviewed-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index b4407d0add27..0031806475f0 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -45,10 +45,6 @@
 
 #define memblock_num_regions(memblock_type)	(memblock.memblock_type.cnt)
 
-#ifndef ELF_CORE_EFLAGS
-#define ELF_CORE_EFLAGS 0
-#endif
-
 /* Firmware provided dump sections */
 #define FADUMP_CPU_STATE_DATA	0x0001
 #define FADUMP_HPTE_REGION	0x0002

commit a0512164278b11deb3b07bf14e72f8b979b07aa6
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Jan 20 15:00:13 2016 -0800

    powerpc/fadump: rename cpu_online_mask member of struct fadump_crash_info_header
    
    The four cpumasks cpu_{possible,online,present,active}_bits are exposed
    readonly via the corresponding const variables cpu_xyz_mask.  But they are
    also accessible for arbitrary writing via the exposed functions
    set_cpu_xyz.  There's quite a bit of code throughout the kernel which
    iterates over or otherwise accesses these bitmaps, and having the access
    go via the cpu_xyz_mask variables is nowadays [1] simply a useless
    indirection.
    
    It may be that any problem in CS can be solved by an extra level of
    indirection, but that doesn't mean every extra indirection solves a
    problem.  In this case, it even necessitates some minor ugliness (see
    4/6).
    
    Patch 1/6 is new in v2, and fixes a build failure on ppc by renaming a
    struct member, to avoid problems when the identifier cpu_online_mask
    becomes a macro later in the series.  The next four patches eliminate the
    cpu_xyz_mask variables by simply exposing the actual bitmaps, after
    renaming them to discourage direct access - that still happens through
    cpu_xyz_mask, which are now simply macros with the same type and value as
    they used to have.
    
    After that, there's no longer any reason to have the setter functions be
    out-of-line: The boolean parameter is almost always a literal true or
    false, so by making them static inlines they will usually compile to one
    or two instructions.
    
    For a defconfig build on x86_64, bloat-o-meter says we save ~3000 bytes.
    We also save a little stack (stackdelta says 127 functions have a 16 byte
    smaller stack frame, while two grow by that amount).  Mostly because, when
    iterating over the mask, gcc typically loads the value of cpu_xyz_mask
    into a callee-saved register and from there into %rdi before each
    find_next_bit call - now it can just load the appropriate immediate
    address into %rdi before each call.
    
    [1] See Rusty's kind explanation
    http://thread.gmane.org/gmane.linux.kernel/2047078/focus=2047722 for
    some historic context.
    
    This patch (of 6):
    
    As preparation for eliminating the indirect access to the various global
    cpu_*_bits bitmaps via the pointer variables cpu_*_mask, rename the
    cpu_online_mask member of struct fadump_crash_info_header to simply
    online_mask, thus allowing cpu_online_mask to become a macro.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Acked-by: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 493e72f64b35..b4407d0add27 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -191,7 +191,7 @@ struct fadump_crash_info_header {
 	u64		elfcorehdr_addr;
 	u32		crashing_cpu;
 	struct pt_regs	regs;
-	struct cpumask	cpu_online_mask;
+	struct cpumask	online_mask;
 };
 
 /* Crash memory ranges */

commit 408cddd96e3b155337f9e3aba2198e92e94c6068
Author: Hari Bathini <hbathini@linux.vnet.ibm.com>
Date:   Wed Oct 1 12:32:30 2014 +0530

    powerpc/fadump: Fix endianess issues in firmware assisted dump handling
    
    Firmware-assisted dump (fadump) kernel code is not endian safe. The
    below patch fixes this issue. Tested this patch with upstream kernel.
    Below output shows crash tool successfully opening LE fadump vmcore.
    
        # crash vmlinux vmcore
        GNU gdb (GDB) 7.6
        This GDB was configured as "powerpc64le-unknown-linux-gnu"...
    
              KERNEL: vmlinux
            DUMPFILE: vmcore
            CPUS: 16
            DATE: Wed Dec 31 19:00:00 1969
              UPTIME: 00:03:28
        LOAD AVERAGE: 0.46, 0.86, 0.41
               TASKS: 268
            NODENAME: linux-dhr2
             RELEASE: 3.17.0-rc5-7-default
             VERSION: #6 SMP Tue Sep 30 01:06:34 EDT 2014
             MACHINE: ppc64le  (4116 Mhz)
              MEMORY: 40 GB
               PANIC: "Oops: Kernel access of bad area, sig: 11 [#1]" (check log for details)
             PID: 6223
             COMMAND: "bash"
            TASK: c0000009661b2500  [THREAD_INFO: c000000967ac0000]
             CPU: 2
               STATE: TASK_RUNNING (PANIC)
    
    Signed-off-by: Hari Bathini <hbathini@linux.vnet.ibm.com>
    [mpe: Make the comment in pSeries_lpar_hptab_clear() clearer]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index a6774560afe3..493e72f64b35 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -70,39 +70,39 @@
 #define CPU_UNKNOWN		(~((u32)0))
 
 /* Utility macros */
-#define SKIP_TO_NEXT_CPU(reg_entry)			\
-({							\
-	while (reg_entry->reg_id != REG_ID("CPUEND"))	\
-		reg_entry++;				\
-	reg_entry++;					\
+#define SKIP_TO_NEXT_CPU(reg_entry)					\
+({									\
+	while (be64_to_cpu(reg_entry->reg_id) != REG_ID("CPUEND"))	\
+		reg_entry++;						\
+	reg_entry++;							\
 })
 
 /* Kernel Dump section info */
 struct fadump_section {
-	u32	request_flag;
-	u16	source_data_type;
-	u16	error_flags;
-	u64	source_address;
-	u64	source_len;
-	u64	bytes_dumped;
-	u64	destination_address;
+	__be32	request_flag;
+	__be16	source_data_type;
+	__be16	error_flags;
+	__be64	source_address;
+	__be64	source_len;
+	__be64	bytes_dumped;
+	__be64	destination_address;
 };
 
 /* ibm,configure-kernel-dump header. */
 struct fadump_section_header {
-	u32	dump_format_version;
-	u16	dump_num_sections;
-	u16	dump_status_flag;
-	u32	offset_first_dump_section;
+	__be32	dump_format_version;
+	__be16	dump_num_sections;
+	__be16	dump_status_flag;
+	__be32	offset_first_dump_section;
 
 	/* Fields for disk dump option. */
-	u32	dd_block_size;
-	u64	dd_block_offset;
-	u64	dd_num_blocks;
-	u32	dd_offset_disk_path;
+	__be32	dd_block_size;
+	__be64	dd_block_offset;
+	__be64	dd_num_blocks;
+	__be32	dd_offset_disk_path;
 
 	/* Maximum time allowed to prevent an automatic dump-reboot. */
-	u32	max_time_auto;
+	__be32	max_time_auto;
 };
 
 /*
@@ -174,15 +174,15 @@ static inline u64 str_to_u64(const char *str)
 
 /* Register save area header. */
 struct fadump_reg_save_area_header {
-	u64		magic_number;
-	u32		version;
-	u32		num_cpu_offset;
+	__be64		magic_number;
+	__be32		version;
+	__be32		num_cpu_offset;
 };
 
 /* Register entry. */
 struct fadump_reg_entry {
-	u64		reg_id;
-	u64		reg_value;
+	__be64		reg_id;
+	__be64		reg_value;
 };
 
 /* fadump crash info structure */

commit 82e0703b6ca8b549952c1e4f04746f27eaec012d
Author: Rashika Kheria <rashika.kheria@gmail.com>
Date:   Mon Apr 7 15:38:50 2014 -0700

    include/linux/crash_dump.h: add vmcore_cleanup() prototype
    
    Eliminate the following warning in proc/vmcore.c:
    
      fs/proc/vmcore.c:1088:6: warning: no previous prototype for `vmcore_cleanup' [-Wmissing-prototypes]
    
    [akpm@linux-foundation.org: clean up powerpc, remove unneeded EXPORT_SYMBOL]
    Signed-off-by: Rashika Kheria <rashika.kheria@gmail.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 88dbf9659185..a6774560afe3 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -210,7 +210,6 @@ extern int is_fadump_active(void);
 extern void crash_fadump(struct pt_regs *, const char *);
 extern void fadump_cleanup(void);
 
-extern void vmcore_cleanup(void);
 #else	/* CONFIG_FA_DUMP */
 static inline int is_fadump_active(void) { return 0; }
 static inline void crash_fadump(struct pt_regs *regs, const char *str) { }

commit b500afff11f64227ca69fd2d05986d08d9573935
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Thu Feb 16 01:15:08 2012 +0000

    fadump: Invalidate registration and release reserved memory for general use.
    
    This patch introduces an sysfs interface '/sys/kernel/fadump_release_mem' to
    invalidate the last fadump registration, invalidate '/proc/vmcore', release
    the reserved memory for general use and re-register for future kernel dump.
    Once the dump is copied to the disk, unlike phyp dump, the userspace tool
    can release all the memory reserved for dump with one single operation of
    echo 1 to '/sys/kernel/fadump_release_mem'.
    
    Release the reserved memory region excluding the size of the memory required
    for future kernel dump registration. And therefore, unlike kdump, Fadump
    doesn't need a 2nd reboot to get back the system to the production
    configuration.
    
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 67681958e4b8..88dbf9659185 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -208,6 +208,9 @@ extern int fadump_reserve_mem(void);
 extern int setup_fadump(void);
 extern int is_fadump_active(void);
 extern void crash_fadump(struct pt_regs *, const char *);
+extern void fadump_cleanup(void);
+
+extern void vmcore_cleanup(void);
 #else	/* CONFIG_FA_DUMP */
 static inline int is_fadump_active(void) { return 0; }
 static inline void crash_fadump(struct pt_regs *regs, const char *str) { }

commit ebaeb5ae24379b5b635dc1d1fa6df904bc95b4d9
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Thu Feb 16 01:14:45 2012 +0000

    fadump: Convert firmware-assisted cpu state dump data into elf notes.
    
    When registered for firmware assisted dump on powerpc, firmware preserves
    the registers for the active CPUs during a system crash. This patch reads
    the cpu register data stored in Firmware-assisted dump format (except for
    crashing cpu) and converts it into elf notes and updates the PT_NOTE program
    header accordingly. The exact register state for crashing cpu is saved to
    fadump crash info structure in scratch area during crash_fadump() and read
    during second kernel boot.
    
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 9e172a5d53c7..67681958e4b8 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -65,6 +65,18 @@
 /* Dump status flag */
 #define FADUMP_ERROR_FLAG	0x2000
 
+#define FADUMP_CPU_ID_MASK	((1UL << 32) - 1)
+
+#define CPU_UNKNOWN		(~((u32)0))
+
+/* Utility macros */
+#define SKIP_TO_NEXT_CPU(reg_entry)			\
+({							\
+	while (reg_entry->reg_id != REG_ID("CPUEND"))	\
+		reg_entry++;				\
+	reg_entry++;					\
+})
+
 /* Kernel Dump section info */
 struct fadump_section {
 	u32	request_flag;
@@ -119,6 +131,9 @@ struct fw_dump {
 	unsigned long	reserve_bootvar;
 
 	unsigned long	fadumphdr_addr;
+	unsigned long	cpu_notes_buf;
+	unsigned long	cpu_notes_buf_size;
+
 	int		ibm_configure_kernel_dump;
 
 	unsigned long	fadump_enabled:1;
@@ -143,13 +158,40 @@ static inline u64 str_to_u64(const char *str)
 	return val;
 }
 #define STR_TO_HEX(x)	str_to_u64(x)
+#define REG_ID(x)	str_to_u64(x)
 
 #define FADUMP_CRASH_INFO_MAGIC		STR_TO_HEX("FADMPINF")
+#define REGSAVE_AREA_MAGIC		STR_TO_HEX("REGSAVE")
+
+/* The firmware-assisted dump format.
+ *
+ * The register save area is an area in the partition's memory used to preserve
+ * the register contents (CPU state data) for the active CPUs during a firmware
+ * assisted dump. The dump format contains register save area header followed
+ * by register entries. Each list of registers for a CPU starts with
+ * "CPUSTRT" and ends with "CPUEND".
+ */
+
+/* Register save area header. */
+struct fadump_reg_save_area_header {
+	u64		magic_number;
+	u32		version;
+	u32		num_cpu_offset;
+};
+
+/* Register entry. */
+struct fadump_reg_entry {
+	u64		reg_id;
+	u64		reg_value;
+};
 
 /* fadump crash info structure */
 struct fadump_crash_info_header {
 	u64		magic_number;
 	u64		elfcorehdr_addr;
+	u32		crashing_cpu;
+	struct pt_regs	regs;
+	struct cpumask	cpu_online_mask;
 };
 
 /* Crash memory ranges */
@@ -165,7 +207,9 @@ extern int early_init_dt_scan_fw_dump(unsigned long node,
 extern int fadump_reserve_mem(void);
 extern int setup_fadump(void);
 extern int is_fadump_active(void);
+extern void crash_fadump(struct pt_regs *, const char *);
 #else	/* CONFIG_FA_DUMP */
 static inline int is_fadump_active(void) { return 0; }
+static inline void crash_fadump(struct pt_regs *regs, const char *str) { }
 #endif
 #endif

commit 2df173d9e85d9e2c6a8933c63f0c034accff7e0f
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Thu Feb 16 01:14:37 2012 +0000

    fadump: Initialize elfcore header and add PT_LOAD program headers.
    
    Build the crash memory range list by traversing through system memory during
    the first kernel before we register for firmware-assisted dump. After the
    successful dump registration, initialize the elfcore header and populate
    PT_LOAD program headers with crash memory ranges. The elfcore header is
    saved in the scratch area within the reserved memory. The scratch area starts
    at the end of the memory reserved for saving RMR region contents. The
    scratch area contains fadump crash info structure that contains magic number
    for fadump validation and physical address where the eflcore header can be
    found. This structure will also be used to pass some important crash info
    data to the second kernel which will help second kernel to populate ELF core
    header with correct data before it gets exported through /proc/vmcore. Since
    the firmware preserves the entire partition memory at the time of crash the
    contents of the scratch area will be preserved till second kernel boot.
    
    Since the memory dump exported through /proc/vmcore is in ELF format similar
    to kdump, it will help us to reuse the kdump infrastructure for dump capture
    and filtering. Unlike phyp dump, userspace tool does not need to refer any
    sysfs interface while reading /proc/vmcore.
    
    NOTE: The current design implementation does not address a possibility of
    introducing additional fields (in future) to this structure without affecting
    compatibility. It's on TODO list to come up with better approach to
    address this.
    
    Reserved dump area start => +-------------------------------------+
                                |  CPU state dump data                |
                                +-------------------------------------+
                                |  HPTE region data                   |
                                +-------------------------------------+
                                |  RMR region data                    |
    Scratch area start       => +-------------------------------------+
                                |  fadump crash info structure {      |
                                |     magic nummber                   |
                         +------|---- elfcorehdr_addr                 |
                         |      |  }                                  |
                         +----> +-------------------------------------+
                                |  ELF core header                    |
    Reserved dump area end   => +-------------------------------------+
    
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index bbaf278bdccc..9e172a5d53c7 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -43,6 +43,12 @@
 #define MIN_BOOT_MEM	(((RMA_END < (0x1UL << 28)) ? (0x1UL << 28) : RMA_END) \
 			+ (0x1UL << 26))
 
+#define memblock_num_regions(memblock_type)	(memblock.memblock_type.cnt)
+
+#ifndef ELF_CORE_EFLAGS
+#define ELF_CORE_EFLAGS 0
+#endif
+
 /* Firmware provided dump sections */
 #define FADUMP_CPU_STATE_DATA	0x0001
 #define FADUMP_HPTE_REGION	0x0002
@@ -56,6 +62,9 @@
 #define FADUMP_UNREGISTER	2
 #define FADUMP_INVALIDATE	3
 
+/* Dump status flag */
+#define FADUMP_ERROR_FLAG	0x2000
+
 /* Kernel Dump section info */
 struct fadump_section {
 	u32	request_flag;
@@ -109,6 +118,7 @@ struct fw_dump {
 	/* cmd line option during boot */
 	unsigned long	reserve_bootvar;
 
+	unsigned long	fadumphdr_addr;
 	int		ibm_configure_kernel_dump;
 
 	unsigned long	fadump_enabled:1;
@@ -117,6 +127,39 @@ struct fw_dump {
 	unsigned long	dump_registered:1;
 };
 
+/*
+ * Copy the ascii values for first 8 characters from a string into u64
+ * variable at their respective indexes.
+ * e.g.
+ *  The string "FADMPINF" will be converted into 0x4641444d50494e46
+ */
+static inline u64 str_to_u64(const char *str)
+{
+	u64 val = 0;
+	int i;
+
+	for (i = 0; i < sizeof(val); i++)
+		val = (*str) ? (val << 8) | *str++ : val << 8;
+	return val;
+}
+#define STR_TO_HEX(x)	str_to_u64(x)
+
+#define FADUMP_CRASH_INFO_MAGIC		STR_TO_HEX("FADMPINF")
+
+/* fadump crash info structure */
+struct fadump_crash_info_header {
+	u64		magic_number;
+	u64		elfcorehdr_addr;
+};
+
+/* Crash memory ranges */
+#define INIT_CRASHMEM_RANGES	(INIT_MEMBLOCK_REGIONS + 2)
+
+struct fad_crash_memory_ranges {
+	unsigned long long	base;
+	unsigned long long	size;
+};
+
 extern int early_init_dt_scan_fw_dump(unsigned long node,
 		const char *uname, int depth, void *data);
 extern int fadump_reserve_mem(void);

commit 3ccc00a7e04ff7718c9aebb4b0c982571c798759
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Mon Feb 20 02:15:03 2012 +0000

    fadump: Register for firmware assisted dump.
    
    On 2012-02-20 11:02:51 Mon, Paul Mackerras wrote:
    > On Thu, Feb 16, 2012 at 04:44:30PM +0530, Mahesh J Salgaonkar wrote:
    >
    > If I have read the code correctly, we are going to get this printk on
    > non-pSeries machines or on older pSeries machines, even if the user
    > has not put the fadump=on option on the kernel command line.  The
    > printk will be annoying since there is no actual error condition.  It
    > seems to me that the condition for the printk should include
    > fw_dump.fadump_enabled.  In other words you should probably add
    >
    >       if (!fw_dump.fadump_enabled)
    >               return 0;
    >
    > at the beginning of the function.
    
    Hi Paul,
    
    Thanks for pointing it out. Please find the updated patch below.
    
    The existing patches above this (4/10 through 10/10) cleanly applies
    on this update.
    
    Thanks,
    -Mahesh.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
index 7be25d30d985..bbaf278bdccc 100644
--- a/arch/powerpc/include/asm/fadump.h
+++ b/arch/powerpc/include/asm/fadump.h
@@ -48,6 +48,58 @@
 #define FADUMP_HPTE_REGION	0x0002
 #define FADUMP_REAL_MODE_REGION	0x0011
 
+/* Dump request flag */
+#define FADUMP_REQUEST_FLAG	0x00000001
+
+/* FAD commands */
+#define FADUMP_REGISTER		1
+#define FADUMP_UNREGISTER	2
+#define FADUMP_INVALIDATE	3
+
+/* Kernel Dump section info */
+struct fadump_section {
+	u32	request_flag;
+	u16	source_data_type;
+	u16	error_flags;
+	u64	source_address;
+	u64	source_len;
+	u64	bytes_dumped;
+	u64	destination_address;
+};
+
+/* ibm,configure-kernel-dump header. */
+struct fadump_section_header {
+	u32	dump_format_version;
+	u16	dump_num_sections;
+	u16	dump_status_flag;
+	u32	offset_first_dump_section;
+
+	/* Fields for disk dump option. */
+	u32	dd_block_size;
+	u64	dd_block_offset;
+	u64	dd_num_blocks;
+	u32	dd_offset_disk_path;
+
+	/* Maximum time allowed to prevent an automatic dump-reboot. */
+	u32	max_time_auto;
+};
+
+/*
+ * Firmware Assisted dump memory structure. This structure is required for
+ * registering future kernel dump with power firmware through rtas call.
+ *
+ * No disk dump option. Hence disk dump path string section is not included.
+ */
+struct fadump_mem_struct {
+	struct fadump_section_header	header;
+
+	/* Kernel dump sections */
+	struct fadump_section		cpu_state_data;
+	struct fadump_section		hpte_region;
+	struct fadump_section		rmr_region;
+};
+
+/* Firmware-assisted dump configuration details. */
 struct fw_dump {
 	unsigned long	cpu_state_data_size;
 	unsigned long	hpte_region_size;
@@ -62,10 +114,15 @@ struct fw_dump {
 	unsigned long	fadump_enabled:1;
 	unsigned long	fadump_supported:1;
 	unsigned long	dump_active:1;
+	unsigned long	dump_registered:1;
 };
 
 extern int early_init_dt_scan_fw_dump(unsigned long node,
 		const char *uname, int depth, void *data);
 extern int fadump_reserve_mem(void);
+extern int setup_fadump(void);
+extern int is_fadump_active(void);
+#else	/* CONFIG_FA_DUMP */
+static inline int is_fadump_active(void) { return 0; }
 #endif
 #endif

commit eb39c8803d0e3d98fe74825f99287f63d55e6460
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Thu Feb 16 01:14:22 2012 +0000

    fadump: Reserve the memory for firmware assisted dump.
    
    Reserve the memory during early boot to preserve CPU state data, HPTE region
    and RMA (real mode area) region data in case of kernel crash. At the time of
    crash, powerpc firmware will store CPU state data, HPTE region data and move
    RMA region data to the reserved memory area.
    
    If the firmware-assisted dump fails to reserve the memory, then fallback
    to existing kexec-based kdump.
    
    Most of the code implementation to reserve memory has been
    adapted from phyp assisted dump implementation written by Linas Vepstas
    and Manish Ahuja
    
    This patch also introduces a config option CONFIG_FA_DUMP for firmware
    assisted dump feature on Powerpc (ppc64) architecture.
    
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/fadump.h b/arch/powerpc/include/asm/fadump.h
new file mode 100644
index 000000000000..7be25d30d985
--- /dev/null
+++ b/arch/powerpc/include/asm/fadump.h
@@ -0,0 +1,71 @@
+/*
+ * Firmware Assisted dump header file.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ *
+ * Copyright 2011 IBM Corporation
+ * Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
+ */
+
+#ifndef __PPC64_FA_DUMP_H__
+#define __PPC64_FA_DUMP_H__
+
+#ifdef CONFIG_FA_DUMP
+
+/*
+ * The RMA region will be saved for later dumping when kernel crashes.
+ * RMA is Real Mode Area, the first block of logical memory address owned
+ * by logical partition, containing the storage that may be accessed with
+ * translate off.
+ */
+#define RMA_START	0x0
+#define RMA_END		(ppc64_rma_size)
+
+/*
+ * On some Power systems where RMO is 128MB, it still requires minimum of
+ * 256MB for kernel to boot successfully. When kdump infrastructure is
+ * configured to save vmcore over network, we run into OOM issue while
+ * loading modules related to network setup. Hence we need aditional 64M
+ * of memory to avoid OOM issue.
+ */
+#define MIN_BOOT_MEM	(((RMA_END < (0x1UL << 28)) ? (0x1UL << 28) : RMA_END) \
+			+ (0x1UL << 26))
+
+/* Firmware provided dump sections */
+#define FADUMP_CPU_STATE_DATA	0x0001
+#define FADUMP_HPTE_REGION	0x0002
+#define FADUMP_REAL_MODE_REGION	0x0011
+
+struct fw_dump {
+	unsigned long	cpu_state_data_size;
+	unsigned long	hpte_region_size;
+	unsigned long	boot_memory_size;
+	unsigned long	reserve_dump_area_start;
+	unsigned long	reserve_dump_area_size;
+	/* cmd line option during boot */
+	unsigned long	reserve_bootvar;
+
+	int		ibm_configure_kernel_dump;
+
+	unsigned long	fadump_enabled:1;
+	unsigned long	fadump_supported:1;
+	unsigned long	dump_active:1;
+};
+
+extern int early_init_dt_scan_fw_dump(unsigned long node,
+		const char *uname, int depth, void *data);
+extern int fadump_reserve_mem(void);
+#endif
+#endif
