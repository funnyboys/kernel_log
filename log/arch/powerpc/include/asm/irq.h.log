commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index c91a60cda4fa..814dfab7e392 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -1,12 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 #ifdef __KERNEL__
 #ifndef _ASM_POWERPC_IRQ_H
 #define _ASM_POWERPC_IRQ_H
 
 /*
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 #include <linux/irqdomain.h>

commit a7916a1de526162d73e894b6d3ebd895d4302078
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Jan 31 10:09:00 2019 +0000

    powerpc: regain entire stack space
    
    thread_info is not anymore in the stack, so the entire stack
    can now be used.
    
    There is also no risk anymore of corrupting task_cpu(p) with a
    stack overflow so the patch removes the test.
    
    When doing this, an explicit test for NULL stack pointer is
    needed in validate_sp() as it is not anymore implicitely covered
    by the sizeof(thread_info) gap.
    
    In the meantime, with the previous patch all pointers to the stacks
    are not anymore pointers to thread_info so this patch changes them
    to void*
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 28a7ace0a1b9..c91a60cda4fa 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -48,16 +48,16 @@ struct pt_regs;
  * Per-cpu stacks for handling critical, debug and machine check
  * level interrupts.
  */
-extern struct thread_info *critirq_ctx[NR_CPUS];
-extern struct thread_info *dbgirq_ctx[NR_CPUS];
-extern struct thread_info *mcheckirq_ctx[NR_CPUS];
+extern void *critirq_ctx[NR_CPUS];
+extern void *dbgirq_ctx[NR_CPUS];
+extern void *mcheckirq_ctx[NR_CPUS];
 #endif
 
 /*
  * Per-cpu stacks for handling hard and soft interrupts.
  */
-extern struct thread_info *hardirq_ctx[NR_CPUS];
-extern struct thread_info *softirq_ctx[NR_CPUS];
+extern void *hardirq_ctx[NR_CPUS];
+extern void *softirq_ctx[NR_CPUS];
 
 void call_do_softirq(void *sp);
 void call_do_irq(struct pt_regs *regs, void *sp);

commit ed1cd6deb013a11959d17a94e35ce159197632da
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Jan 31 10:08:58 2019 +0000

    powerpc: Activate CONFIG_THREAD_INFO_IN_TASK
    
    This patch activates CONFIG_THREAD_INFO_IN_TASK which
    moves the thread_info into task_struct.
    
    Moving thread_info into task_struct has the following advantages:
      - It protects thread_info from corruption in the case of stack
        overflows.
      - Its address is harder to determine if stack addresses are leaked,
        making a number of attacks more difficult.
    
    This has the following consequences:
      - thread_info is now located at the beginning of task_struct.
      - The 'cpu' field is now in task_struct, and only exists when
        CONFIG_SMP is active.
      - thread_info doesn't have anymore the 'task' field.
    
    This patch:
      - Removes all recopy of thread_info struct when the stack changes.
      - Changes the CURRENT_THREAD_INFO() macro to point to current.
      - Selects CONFIG_THREAD_INFO_IN_TASK.
      - Modifies raw_smp_processor_id() to get ->cpu from current without
        including linux/sched.h to avoid circular inclusion and without
        including asm/asm-offsets.h to avoid symbol names duplication
        between ASM constants and C constants.
      - Modifies klp_init_thread_info() to take a task_struct pointer
        argument.
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Reviewed-by: Nicholas Piggin <npiggin@gmail.com>
    [mpe: Add task_stack.h to livepatch.h to fix build fails]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 2efbae8d93be..28a7ace0a1b9 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -51,9 +51,6 @@ struct pt_regs;
 extern struct thread_info *critirq_ctx[NR_CPUS];
 extern struct thread_info *dbgirq_ctx[NR_CPUS];
 extern struct thread_info *mcheckirq_ctx[NR_CPUS];
-extern void exc_lvl_ctx_init(void);
-#else
-#define exc_lvl_ctx_init()
 #endif
 
 /*
@@ -62,7 +59,6 @@ extern void exc_lvl_ctx_init(void);
 extern struct thread_info *hardirq_ctx[NR_CPUS];
 extern struct thread_info *softirq_ctx[NR_CPUS];
 
-extern void irq_ctx_init(void);
 void call_do_softirq(void *sp);
 void call_do_irq(struct pt_regs *regs, void *sp);
 extern void do_IRQ(struct pt_regs *regs);

commit 1e35f29c6b2eba72521d6f3c38f9c86f331cfd0a
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu Jan 17 23:17:56 2019 +1100

    powerpc: call_do_[soft]irq() takes a pointer to the stack
    
    The purpose of the pointer given to call_do_softirq() and
    call_do_irq() is to point the new stack. Currently that's the same
    thing as the thread_info, but won't be with THREAD_INFO_IN_TASK.
    
    So change the parameter to void* and rename it 'sp'.
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Reviewed-by: Nicholas Piggin <npiggin@gmail.com>
    [mpe: Split out of larger patch]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index ee39ce56b2a2..2efbae8d93be 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -63,8 +63,8 @@ extern struct thread_info *hardirq_ctx[NR_CPUS];
 extern struct thread_info *softirq_ctx[NR_CPUS];
 
 extern void irq_ctx_init(void);
-extern void call_do_softirq(struct thread_info *tp);
-extern void call_do_irq(struct pt_regs *regs, struct thread_info *tp);
+void call_do_softirq(void *sp);
+void call_do_irq(struct pt_regs *regs, void *sp);
 extern void do_IRQ(struct pt_regs *regs);
 extern void __init init_IRQ(void);
 extern void __do_irq(struct pt_regs *regs);

commit 23a6d8b9634897add6ebff32372f34348387b1ee
Author: Mathieu Malaterre <malat@debian.org>
Date:   Sun Feb 25 18:22:31 2018 +0100

    powerpc: Add missing prototype for init_IRQ()
    
    A function init_IRQ() was added without a prototype declared in header
    irq.h. Fix the following warning (treated as error in W=1):
    
      arch/powerpc/kernel/irq.c:662:13: error: no previous prototype for ‘init_IRQ’
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index e8e3a0a04eb0..ee39ce56b2a2 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -66,6 +66,7 @@ extern void irq_ctx_init(void);
 extern void call_do_softirq(struct thread_info *tp);
 extern void call_do_irq(struct pt_regs *regs, struct thread_info *tp);
 extern void do_IRQ(struct pt_regs *regs);
+extern void __init init_IRQ(void);
 extern void __do_irq(struct pt_regs *regs);
 
 int irq_choose_cpu(const struct cpumask *mask);

commit a38efcea56988761f89a3134145f0d5f9ea68076
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Aug 20 08:55:20 2014 +1000

    powerpc: Remove stale function prototypes
    
    There were a number of prototypes for functions that no longer
    exist. Remove them.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 41f13cec8a8f..e8e3a0a04eb0 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -31,11 +31,6 @@ extern atomic_t ppc_n_lost_interrupts;
 
 extern irq_hw_number_t virq_to_hw(unsigned int virq);
 
-/**
- * irq_early_init - Init irq remapping subsystem
- */
-extern void irq_early_init(void);
-
 static __inline__ int irq_canonicalize(int irq)
 {
 	return irq;

commit 0366a1c70b89efed4f9d590216bb004a16effbed
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Sep 23 14:29:11 2013 +1000

    powerpc/irq: Run softirqs off the top of the irq stack
    
    Nowadays, irq_exit() calls __do_softirq() pretty much directly
    instead of calling do_softirq() which switches to the decicated
    softirq stack.
    
    This has lead to observed stack overflows on powerpc since we call
    irq_enter() and irq_exit() outside of the scope that switches to
    the irq stack.
    
    This fixes it by moving the stack switching up a level, making
    irq_enter() and irq_exit() run off the irq stack.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 0e40843a1c6e..41f13cec8a8f 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -69,9 +69,9 @@ extern struct thread_info *softirq_ctx[NR_CPUS];
 
 extern void irq_ctx_init(void);
 extern void call_do_softirq(struct thread_info *tp);
-extern int call_handle_irq(int irq, void *p1,
-			   struct thread_info *tp, void *func);
+extern void call_do_irq(struct pt_regs *regs, struct thread_info *tp);
 extern void do_IRQ(struct pt_regs *regs);
+extern void __do_irq(struct pt_regs *regs);
 
 int irq_choose_cpu(const struct cpumask *mask);
 

commit 4013369f3782af9a488e37c2b603f1dcf008ea76
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Apr 23 12:30:02 2012 +0000

    powerpc/irqdomain: Fix broken NR_IRQ references
    
    The switch from using irq_map to irq_alloc_desc*() for managing irq
    number allocations introduced new bugs in some of the powerpc
    interrupt code.  Several functions rely on the value of NR_IRQS to
    determine the maximum irq number that could get allocated.  However,
    with sparse_irq and using irq_alloc_desc*() the maximum possible irq
    number is now specified with 'nr_irqs' which may be a number larger
    than NR_IRQS.  This has caused breakage on powermac when
    CONFIG_NR_IRQS is set to 32.
    
    This patch removes most of the direct references to NR_IRQS in the
    powerpc code and replaces them with either a nr_irqs reference or by
    using the common for_each_irq_desc() macro.  The powerpc-specific
    for_each_irq() macro is removed at the same time.
    
    Also, the Cell axon_msi driver is refactored to remove the global
    build assumption on the size of NR_IRQS and instead add a limit to the
    maximum irq number when calling irq_domain_add_nomap().
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index e648af92ced1..0e40843a1c6e 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -18,10 +18,6 @@
 #include <linux/atomic.h>
 
 
-/* Define a way to iterate across irqs. */
-#define for_each_irq(i) \
-	for ((i) = 0; (i) < NR_IRQS; ++(i))
-
 extern atomic_t ppc_n_lost_interrupts;
 
 /* This number is used when no interrupt has been assigned */

commit a699e4e49ec3fb62c4a44394357d14081df10bef
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Apr 3 07:11:04 2012 -0600

    irq: Kill pointless irqd_to_hw export
    
    It makes no sense to export this trivial function.  Make it a static inline
    instead.
    
    This patch also drops virq_to_hw from arch/c6x since it is unused by that
    architecture.
    
    v2: Move irq_hw_number_t into types.h to fix ARM build failure
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index cf417e510736..e648af92ced1 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -33,8 +33,6 @@ extern atomic_t ppc_n_lost_interrupts;
 /* Same thing, used by the generic IRQ code */
 #define NR_IRQS_LEGACY		NUM_ISA_INTERRUPTS
 
-struct irq_data;
-extern irq_hw_number_t irqd_to_hwirq(struct irq_data *d);
 extern irq_hw_number_t virq_to_hw(unsigned int virq);
 
 /**

commit 7ba3e4f5877466b0f81dcd3cb78db5d75b267645
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Wed Mar 21 18:09:51 2012 +0000

    powerpc: Remove NO_IRQ_IGNORE
    
    Now that legacy iSeries is gone, this is no longer used.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index fe0b09dceb7d..cf417e510736 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -27,12 +27,6 @@ extern atomic_t ppc_n_lost_interrupts;
 /* This number is used when no interrupt has been assigned */
 #define NO_IRQ			(0)
 
-/* This is a special irq number to return from get_irq() to tell that
- * no interrupt happened _and_ ignore it (don't count it as bad). Some
- * platforms like iSeries rely on that.
- */
-#define NO_IRQ_IGNORE		((unsigned int)-1)
-
 /* Total number of virq in the platform */
 #define NR_IRQS		CONFIG_NR_IRQS
 

commit 1bc04f2cf8c2a1feadbd994f50c40bb145bf2989
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 14 14:06:55 2012 -0700

    irq_domain: Add support for base irq and hwirq in legacy mappings
    
    Add support for a legacy mapping where irq = (hwirq - first_hwirq + first_irq)
    so that a controller driver can allocate a fixed range of irq_descs and use
    a simple calculation to translate back and forth between linux and hw irq
    numbers.  This is needed to use an irq_domain with many of the ARM interrupt
    controller drivers that manage their own irq_desc allocations.  Ultimately
    the goal is to migrate those drivers to use the linear revmap, but doing it
    this way allows each driver to be converted separately which makes the
    migration path easier.
    
    This patch generalizes the IRQ_DOMAIN_MAP_LEGACY method to use
    (first_irq-first_hwirq) as the offset between hwirq and linux irq number,
    and adds checks to make sure that the hwirq number does not exceed range
    assigned to the controller.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 728cc30d04ea..fe0b09dceb7d 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -36,9 +36,6 @@ extern atomic_t ppc_n_lost_interrupts;
 /* Total number of virq in the platform */
 #define NR_IRQS		CONFIG_NR_IRQS
 
-/* Number of irqs reserved for the legacy controller */
-#define NUM_ISA_INTERRUPTS	16
-
 /* Same thing, used by the generic IRQ code */
 #define NR_IRQS_LEGACY		NUM_ISA_INTERRUPTS
 

commit cc79ca691c292e9fd44f589c7940b9654e22f2f6
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Thu Feb 16 01:37:49 2012 -0700

    irq_domain: Move irq_domain code from powerpc to kernel/irq
    
    This patch only moves the code.  It doesn't make any changes, and the
    code is still only compiled for powerpc.  Follow-on patches will generalize
    the code for other architectures.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index f80f262e0597..728cc30d04ea 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -42,154 +42,10 @@ extern atomic_t ppc_n_lost_interrupts;
 /* Same thing, used by the generic IRQ code */
 #define NR_IRQS_LEGACY		NUM_ISA_INTERRUPTS
 
-/*
- * The host code and data structures are fairly agnostic to the fact that
- * we use an open firmware device-tree. We do have references to struct
- * device_node in two places: in irq_find_host() to find the host matching
- * a given interrupt controller node, and of course as an argument to its
- * counterpart host->ops->match() callback. However, those are treated as
- * generic pointers by the core and the fact that it's actually a device-node
- * pointer is purely a convention between callers and implementation. This
- * code could thus be used on other architectures by replacing those two
- * by some sort of arch-specific void * "token" used to identify interrupt
- * controllers.
- */
-
 struct irq_data;
 extern irq_hw_number_t irqd_to_hwirq(struct irq_data *d);
 extern irq_hw_number_t virq_to_hw(unsigned int virq);
 
-/**
- * irq_alloc_host - Allocate a new irq_domain data structure
- * @of_node: optional device-tree node of the interrupt controller
- * @revmap_type: type of reverse mapping to use
- * @revmap_arg: for IRQ_DOMAIN_MAP_LINEAR linear only: size of the map
- * @ops: map/unmap host callbacks
- * @inval_irq: provide a hw number in that host space that is always invalid
- *
- * Allocates and initialize and irq_domain structure. Note that in the case of
- * IRQ_DOMAIN_MAP_LEGACY, the map() callback will be called before this returns
- * for all legacy interrupts except 0 (which is always the invalid irq for
- * a legacy controller). For a IRQ_DOMAIN_MAP_LINEAR, the map is allocated by
- * this call as well. For a IRQ_DOMAIN_MAP_TREE, the radix tree will be allocated
- * later during boot automatically (the reverse mapping will use the slow path
- * until that happens).
- */
-extern struct irq_domain *irq_alloc_host(struct device_node *of_node,
-				       unsigned int revmap_type,
-				       unsigned int revmap_arg,
-				       struct irq_domain_ops *ops,
-				       irq_hw_number_t inval_irq);
-
-
-/**
- * irq_find_host - Locates a host for a given device node
- * @node: device-tree node of the interrupt controller
- */
-extern struct irq_domain *irq_find_host(struct device_node *node);
-
-
-/**
- * irq_set_default_host - Set a "default" host
- * @host: default host pointer
- *
- * For convenience, it's possible to set a "default" host that will be used
- * whenever NULL is passed to irq_create_mapping(). It makes life easier for
- * platforms that want to manipulate a few hard coded interrupt numbers that
- * aren't properly represented in the device-tree.
- */
-extern void irq_set_default_host(struct irq_domain *host);
-
-
-/**
- * irq_set_virq_count - Set the maximum number of virt irqs
- * @count: number of linux virtual irqs, capped with NR_IRQS
- *
- * This is mainly for use by platforms like iSeries who want to program
- * the virtual irq number in the controller to avoid the reverse mapping
- */
-extern void irq_set_virq_count(unsigned int count);
-
-
-/**
- * irq_create_mapping - Map a hardware interrupt into linux virq space
- * @host: host owning this hardware interrupt or NULL for default host
- * @hwirq: hardware irq number in that host space
- *
- * Only one mapping per hardware interrupt is permitted. Returns a linux
- * virq number.
- * If the sense/trigger is to be specified, set_irq_type() should be called
- * on the number returned from that call.
- */
-extern unsigned int irq_create_mapping(struct irq_domain *host,
-				       irq_hw_number_t hwirq);
-
-
-/**
- * irq_dispose_mapping - Unmap an interrupt
- * @virq: linux virq number of the interrupt to unmap
- */
-extern void irq_dispose_mapping(unsigned int virq);
-
-/**
- * irq_find_mapping - Find a linux virq from an hw irq number.
- * @host: host owning this hardware interrupt
- * @hwirq: hardware irq number in that host space
- *
- * This is a slow path, for use by generic code. It's expected that an
- * irq controller implementation directly calls the appropriate low level
- * mapping function.
- */
-extern unsigned int irq_find_mapping(struct irq_domain *host,
-				     irq_hw_number_t hwirq);
-
-/**
- * irq_create_direct_mapping - Allocate a virq for direct mapping
- * @host: host to allocate the virq for or NULL for default host
- *
- * This routine is used for irq controllers which can choose the hardware
- * interrupt numbers they generate. In such a case it's simplest to use
- * the linux virq as the hardware interrupt number.
- */
-extern unsigned int irq_create_direct_mapping(struct irq_domain *host);
-
-/**
- * irq_radix_revmap_insert - Insert a hw irq to linux virq number mapping.
- * @host: host owning this hardware interrupt
- * @virq: linux irq number
- * @hwirq: hardware irq number in that host space
- *
- * This is for use by irq controllers that use a radix tree reverse
- * mapping for fast lookup.
- */
-extern void irq_radix_revmap_insert(struct irq_domain *host, unsigned int virq,
-				    irq_hw_number_t hwirq);
-
-/**
- * irq_radix_revmap_lookup - Find a linux virq from a hw irq number.
- * @host: host owning this hardware interrupt
- * @hwirq: hardware irq number in that host space
- *
- * This is a fast path, for use by irq controller code that uses radix tree
- * revmaps
- */
-extern unsigned int irq_radix_revmap_lookup(struct irq_domain *host,
-					    irq_hw_number_t hwirq);
-
-/**
- * irq_linear_revmap - Find a linux virq from a hw irq number.
- * @host: host owning this hardware interrupt
- * @hwirq: hardware irq number in that host space
- *
- * This is a fast path, for use by irq controller code that uses linear
- * revmaps. It does fallback to the slow path if the revmap doesn't exist
- * yet and will create the revmap entry with appropriate locking
- */
-
-extern unsigned int irq_linear_revmap(struct irq_domain *host,
-				      irq_hw_number_t hwirq);
-
-
 /**
  * irq_early_init - Init irq remapping subsystem
  */

commit 6d9285b00f776eebe459a858ebf07b56c36c60d2
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 14 14:06:51 2012 -0700

    irq_domain/powerpc: Eliminate virq_is_host()
    
    There is only one user, and it is trivial to open-code.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index abdd7ef28cbf..f80f262e0597 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -58,7 +58,6 @@ extern atomic_t ppc_n_lost_interrupts;
 struct irq_data;
 extern irq_hw_number_t irqd_to_hwirq(struct irq_data *d);
 extern irq_hw_number_t virq_to_hw(unsigned int virq);
-extern bool virq_is_host(unsigned int virq, struct irq_domain *host);
 
 /**
  * irq_alloc_host - Allocate a new irq_domain data structure

commit 4bbdd45afdae208a7c4ade89cf602f89a6397cff
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 14 14:06:51 2012 -0700

    irq_domain/powerpc: eliminate irq_map; use irq_alloc_desc() instead
    
    This patch drops the powerpc-specific irq_map table and replaces it with
    directly using the irq_alloc_desc()/irq_free_desc() interfaces for allocating
    and freeing irq_desc structures.
    
    This patch is a preparation step for generalizing the powerpc-specific virq
    infrastructure to become irq_domains.
    
    As part of this change, the irq_big_lock is changed to a mutex from a raw
    spinlock.  There is no longer any need to use a spin lock since the irq_desc
    allocation code is now responsible for the critical section of finding
    an unused range of irq numbers.
    
    The radix lookup table is also changed to store the irq_data pointer instead
    of the irq_map entry since the irq_map is removed.  This should end up being
    functionally equivalent since only allocated irq_descs are ever added to the
    radix tree.
    
    v5: - Really don't ever allocate virq 0.  The previous version could still
          do it if hint == 0
        - Respect irq_virq_count setting for NOMAP.  Some NOMAP domains cannot
          use virq values above irq_virq_count.
        - Use numa_node_id() when allocating irq_descs.  Ideally the API should
          obtain that value from the caller, but that touches a lot of call sites
          so will be deferred to a follow-on patch.
        - Fix irq_find_mapping() to include irq numbers lower than
          NUM_ISA_INTERRUPTS.  With the switch to irq_alloc_desc*(), the lowest
          possible allocated irq is now returned by arch_probe_nr_irqs().
    v4: - Fix incorrect access to irq_data structure in debugfs code
        - Don't ever allocate virq 0
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index cb06b39f8e61..abdd7ef28cbf 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -191,33 +191,6 @@ extern unsigned int irq_linear_revmap(struct irq_domain *host,
 				      irq_hw_number_t hwirq);
 
 
-
-/**
- * irq_alloc_virt - Allocate virtual irq numbers
- * @host: host owning these new virtual irqs
- * @count: number of consecutive numbers to allocate
- * @hint: pass a hint number, the allocator will try to use a 1:1 mapping
- *
- * This is a low level function that is used internally by irq_create_mapping()
- * and that can be used by some irq controllers implementations for things
- * like allocating ranges of numbers for MSIs. The revmaps are left untouched.
- */
-extern unsigned int irq_alloc_virt(struct irq_domain *host,
-				   unsigned int count,
-				   unsigned int hint);
-
-/**
- * irq_free_virt - Free virtual irq numbers
- * @virq: virtual irq number of the first interrupt to free
- * @count: number of interrupts to free
- *
- * This function is the opposite of irq_alloc_virt. It will not clear reverse
- * maps, this should be done previously by unmap'ing the interrupt. In fact,
- * all interrupts covered by the range being freed should have been unmapped
- * prior to calling this.
- */
-extern void irq_free_virt(unsigned int virq, unsigned int count);
-
 /**
  * irq_early_init - Init irq remapping subsystem
  */

commit bae1d8f19983fbfa25559aa3cb6a81a84aa82a18
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Feb 14 14:06:50 2012 -0700

    irq_domain/powerpc: Use common irq_domain structure instead of irq_host
    
    This patch drops the powerpc-specific irq_host structures and uses the common
    irq_domain strucutres defined in linux/irqdomain.h.  It also fixes all
    the users to use the new structure names.
    
    Renaming irq_host to irq_domain has been discussed for a long time, and this
    patch is a step in the process of generalizing the powerpc virq code to be
    usable by all architecture.
    
    An astute reader will notice that this patch actually removes the irq_host
    structure instead of renaming it.  This is because the irq_domain structure
    already exists in include/linux/irqdomain.h and has the needed data members.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Milton Miller <miltonm@bga.com>
    Tested-by: Olof Johansson <olof@lixom.net>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index c0e1bc319e35..cb06b39f8e61 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -9,6 +9,7 @@
  * 2 of the License, or (at your option) any later version.
  */
 
+#include <linux/irqdomain.h>
 #include <linux/threads.h>
 #include <linux/list.h>
 #include <linux/radix-tree.h>
@@ -41,20 +42,7 @@ extern atomic_t ppc_n_lost_interrupts;
 /* Same thing, used by the generic IRQ code */
 #define NR_IRQS_LEGACY		NUM_ISA_INTERRUPTS
 
-/* This type is the placeholder for a hardware interrupt number. It has to
- * be big enough to enclose whatever representation is used by a given
- * platform.
- */
-typedef unsigned long irq_hw_number_t;
-
-/* Interrupt controller "host" data structure. This could be defined as a
- * irq domain controller. That is, it handles the mapping between hardware
- * and virtual interrupt numbers for a given interrupt domain. The host
- * structure is generally created by the PIC code for a given PIC instance
- * (though a host can cover more than one PIC if they have a flat number
- * model). It's the host callbacks that are responsible for setting the
- * irq_chip on a given irq_desc after it's been mapped.
- *
+/*
  * The host code and data structures are fairly agnostic to the fact that
  * we use an open firmware device-tree. We do have references to struct
  * device_node in two places: in irq_find_host() to find the host matching
@@ -66,90 +54,32 @@ typedef unsigned long irq_hw_number_t;
  * by some sort of arch-specific void * "token" used to identify interrupt
  * controllers.
  */
-struct irq_host;
-struct radix_tree_root;
-
-/* Functions below are provided by the host and called whenever a new mapping
- * is created or an old mapping is disposed. The host can then proceed to
- * whatever internal data structures management is required. It also needs
- * to setup the irq_desc when returning from map().
- */
-struct irq_host_ops {
-	/* Match an interrupt controller device node to a host, returns
-	 * 1 on a match
-	 */
-	int (*match)(struct irq_host *h, struct device_node *node);
-
-	/* Create or update a mapping between a virtual irq number and a hw
-	 * irq number. This is called only once for a given mapping.
-	 */
-	int (*map)(struct irq_host *h, unsigned int virq, irq_hw_number_t hw);
-
-	/* Dispose of such a mapping */
-	void (*unmap)(struct irq_host *h, unsigned int virq);
-
-	/* Translate device-tree interrupt specifier from raw format coming
-	 * from the firmware to a irq_hw_number_t (interrupt line number) and
-	 * type (sense) that can be passed to set_irq_type(). In the absence
-	 * of this callback, irq_create_of_mapping() and irq_of_parse_and_map()
-	 * will return the hw number in the first cell and IRQ_TYPE_NONE for
-	 * the type (which amount to keeping whatever default value the
-	 * interrupt controller has for that line)
-	 */
-	int (*xlate)(struct irq_host *h, struct device_node *ctrler,
-		     const u32 *intspec, unsigned int intsize,
-		     irq_hw_number_t *out_hwirq, unsigned int *out_type);
-};
-
-struct irq_host {
-	struct list_head	link;
-
-	/* type of reverse mapping technique */
-	unsigned int		revmap_type;
-#define IRQ_HOST_MAP_LEGACY     0 /* legacy 8259, gets irqs 1..15 */
-#define IRQ_HOST_MAP_NOMAP	1 /* no fast reverse mapping */
-#define IRQ_HOST_MAP_LINEAR	2 /* linear map of interrupts */
-#define IRQ_HOST_MAP_TREE	3 /* radix tree */
-	union {
-		struct {
-			unsigned int size;
-			unsigned int *revmap;
-		} linear;
-		struct radix_tree_root tree;
-	} revmap_data;
-	struct irq_host_ops	*ops;
-	void			*host_data;
-	irq_hw_number_t		inval_irq;
-
-	/* Optional device node pointer */
-	struct device_node	*of_node;
-};
 
 struct irq_data;
 extern irq_hw_number_t irqd_to_hwirq(struct irq_data *d);
 extern irq_hw_number_t virq_to_hw(unsigned int virq);
-extern bool virq_is_host(unsigned int virq, struct irq_host *host);
+extern bool virq_is_host(unsigned int virq, struct irq_domain *host);
 
 /**
- * irq_alloc_host - Allocate a new irq_host data structure
+ * irq_alloc_host - Allocate a new irq_domain data structure
  * @of_node: optional device-tree node of the interrupt controller
  * @revmap_type: type of reverse mapping to use
- * @revmap_arg: for IRQ_HOST_MAP_LINEAR linear only: size of the map
+ * @revmap_arg: for IRQ_DOMAIN_MAP_LINEAR linear only: size of the map
  * @ops: map/unmap host callbacks
  * @inval_irq: provide a hw number in that host space that is always invalid
  *
- * Allocates and initialize and irq_host structure. Note that in the case of
- * IRQ_HOST_MAP_LEGACY, the map() callback will be called before this returns
+ * Allocates and initialize and irq_domain structure. Note that in the case of
+ * IRQ_DOMAIN_MAP_LEGACY, the map() callback will be called before this returns
  * for all legacy interrupts except 0 (which is always the invalid irq for
- * a legacy controller). For a IRQ_HOST_MAP_LINEAR, the map is allocated by
- * this call as well. For a IRQ_HOST_MAP_TREE, the radix tree will be allocated
+ * a legacy controller). For a IRQ_DOMAIN_MAP_LINEAR, the map is allocated by
+ * this call as well. For a IRQ_DOMAIN_MAP_TREE, the radix tree will be allocated
  * later during boot automatically (the reverse mapping will use the slow path
  * until that happens).
  */
-extern struct irq_host *irq_alloc_host(struct device_node *of_node,
+extern struct irq_domain *irq_alloc_host(struct device_node *of_node,
 				       unsigned int revmap_type,
 				       unsigned int revmap_arg,
-				       struct irq_host_ops *ops,
+				       struct irq_domain_ops *ops,
 				       irq_hw_number_t inval_irq);
 
 
@@ -157,7 +87,7 @@ extern struct irq_host *irq_alloc_host(struct device_node *of_node,
  * irq_find_host - Locates a host for a given device node
  * @node: device-tree node of the interrupt controller
  */
-extern struct irq_host *irq_find_host(struct device_node *node);
+extern struct irq_domain *irq_find_host(struct device_node *node);
 
 
 /**
@@ -169,7 +99,7 @@ extern struct irq_host *irq_find_host(struct device_node *node);
  * platforms that want to manipulate a few hard coded interrupt numbers that
  * aren't properly represented in the device-tree.
  */
-extern void irq_set_default_host(struct irq_host *host);
+extern void irq_set_default_host(struct irq_domain *host);
 
 
 /**
@@ -192,7 +122,7 @@ extern void irq_set_virq_count(unsigned int count);
  * If the sense/trigger is to be specified, set_irq_type() should be called
  * on the number returned from that call.
  */
-extern unsigned int irq_create_mapping(struct irq_host *host,
+extern unsigned int irq_create_mapping(struct irq_domain *host,
 				       irq_hw_number_t hwirq);
 
 
@@ -211,7 +141,7 @@ extern void irq_dispose_mapping(unsigned int virq);
  * irq controller implementation directly calls the appropriate low level
  * mapping function.
  */
-extern unsigned int irq_find_mapping(struct irq_host *host,
+extern unsigned int irq_find_mapping(struct irq_domain *host,
 				     irq_hw_number_t hwirq);
 
 /**
@@ -222,7 +152,7 @@ extern unsigned int irq_find_mapping(struct irq_host *host,
  * interrupt numbers they generate. In such a case it's simplest to use
  * the linux virq as the hardware interrupt number.
  */
-extern unsigned int irq_create_direct_mapping(struct irq_host *host);
+extern unsigned int irq_create_direct_mapping(struct irq_domain *host);
 
 /**
  * irq_radix_revmap_insert - Insert a hw irq to linux virq number mapping.
@@ -233,7 +163,7 @@ extern unsigned int irq_create_direct_mapping(struct irq_host *host);
  * This is for use by irq controllers that use a radix tree reverse
  * mapping for fast lookup.
  */
-extern void irq_radix_revmap_insert(struct irq_host *host, unsigned int virq,
+extern void irq_radix_revmap_insert(struct irq_domain *host, unsigned int virq,
 				    irq_hw_number_t hwirq);
 
 /**
@@ -244,7 +174,7 @@ extern void irq_radix_revmap_insert(struct irq_host *host, unsigned int virq,
  * This is a fast path, for use by irq controller code that uses radix tree
  * revmaps
  */
-extern unsigned int irq_radix_revmap_lookup(struct irq_host *host,
+extern unsigned int irq_radix_revmap_lookup(struct irq_domain *host,
 					    irq_hw_number_t hwirq);
 
 /**
@@ -257,7 +187,7 @@ extern unsigned int irq_radix_revmap_lookup(struct irq_host *host,
  * yet and will create the revmap entry with appropriate locking
  */
 
-extern unsigned int irq_linear_revmap(struct irq_host *host,
+extern unsigned int irq_linear_revmap(struct irq_domain *host,
 				      irq_hw_number_t hwirq);
 
 
@@ -272,7 +202,7 @@ extern unsigned int irq_linear_revmap(struct irq_host *host,
  * and that can be used by some irq controllers implementations for things
  * like allocating ranges of numbers for MSIs. The revmaps are left untouched.
  */
-extern unsigned int irq_alloc_virt(struct irq_host *host,
+extern unsigned int irq_alloc_virt(struct irq_domain *host,
 				   unsigned int count,
 				   unsigned int hint);
 

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index c57a28e52b64..c0e1bc319e35 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -14,7 +14,7 @@
 #include <linux/radix-tree.h>
 
 #include <asm/types.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 
 
 /* Define a way to iterate across irqs. */

commit 6ec36b5848a8336d3a0010727b9365c3254d2d2e
Author: Stuart Yoder <stuart.yoder@freescale.com>
Date:   Thu May 19 08:54:26 2011 -0500

    powerpc: make irq_choose_cpu() available to all PIC drivers
    
    Move irq_choose_cpu() into arch/powerpc/kernel/irq.c so that it can be used
    by other PIC drivers.  The function is not MPIC-specific.
    
    Signed-off-by: Stuart Yoder <stuart.yoder@freescale.com>
    Signed-off-by: Timur Tabi <timur@freescale.com>
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 1bff591f7f72..c57a28e52b64 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -330,5 +330,7 @@ extern int call_handle_irq(int irq, void *p1,
 			   struct thread_info *tp, void *func);
 extern void do_IRQ(struct pt_regs *regs);
 
+int irq_choose_cpu(const struct cpumask *mask);
+
 #endif /* _ASM_IRQ_H */
 #endif /* __KERNEL__ */

commit 1e8c23013ed0d535e531b3b9cc30200e884f3ff0
Author: Milton Miller <miltonm@bga.com>
Date:   Tue May 10 19:30:40 2011 +0000

    powerpc: Remove virq_to_host
    
    The only references to the irq_map[].host field are internal to
    arch/powerpc/kernel/irq.c
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index a65d1702643b..1bff591f7f72 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -129,7 +129,6 @@ struct irq_data;
 extern irq_hw_number_t irqd_to_hwirq(struct irq_data *d);
 extern irq_hw_number_t virq_to_hw(unsigned int virq);
 extern bool virq_is_host(unsigned int virq, struct irq_host *host);
-extern struct irq_host *virq_to_host(unsigned int virq);
 
 /**
  * irq_alloc_host - Allocate a new irq_host data structure

commit 3ee62d365b519c0c18c774049efcde84fe51c60c
Author: Milton Miller <miltonm@bga.com>
Date:   Tue May 10 19:30:36 2011 +0000

    powerpc: Add virq_is_host to reduce virq_to_host usage
    
    Some irq_host implementations are using virq_to_host to check if
    they are the irq_host for a virtual irq.  To allow us to make space
    versus time tradeoffs, replace this usage with an assertive
    virq_is_host that confirms or denies the irq is associated with the
    given irq_host.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 6f4a3efb59a9..a65d1702643b 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -128,6 +128,7 @@ struct irq_host {
 struct irq_data;
 extern irq_hw_number_t irqd_to_hwirq(struct irq_data *d);
 extern irq_hw_number_t virq_to_hw(unsigned int virq);
+extern bool virq_is_host(unsigned int virq, struct irq_host *host);
 extern struct irq_host *virq_to_host(unsigned int virq);
 
 /**

commit da0519800260a3c791b4fe3317a0c7560027a372
Author: Milton Miller <miltonm@bga.com>
Date:   Tue May 10 19:30:26 2011 +0000

    powerpc: Remove irq_host_ops->remap hook
    
    It was called from irq_create_mapping if that was called for a host
    and hwirq that was previously mapped, "to update the flags".  But the
    only implementation was in beat_interrupt and all it did was repeat a
    hypervisor call without error checking that was performed with error
    checking at the beginning of the map hook.  In addition, the comment on
    the beat remap hook says it will only called once for a given mapping,
    which would apply to map not remap.
    
    All flags should be known by the time the match hook is called, before
    we call the map hook.  Removing this mostly unused hook will simpify
    the requirements of irq_domain concept.
    
    Signed-off-by: Milton Miller <miltonm@bga.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index e1983d577688..6f4a3efb59a9 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -88,9 +88,6 @@ struct irq_host_ops {
 	/* Dispose of such a mapping */
 	void (*unmap)(struct irq_host *h, unsigned int virq);
 
-	/* Update of such a mapping  */
-	void (*remap)(struct irq_host *h, unsigned int virq, irq_hw_number_t hw);
-
 	/* Translate device-tree interrupt specifier from raw format coming
 	 * from the firmware to a irq_hw_number_t (interrupt line number) and
 	 * type (sense) that can be passed to set_irq_type(). In the absence

commit 476eb4912601a8c01e6702b9a029f476b4b131d2
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Wed May 4 15:02:15 2011 +1000

    powerpc/irq: Stop exporting irq_map
    
    First step in eliminating irq_map[] table entirely
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 47b7905a6369..e1983d577688 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -128,25 +128,10 @@ struct irq_host {
 	struct device_node	*of_node;
 };
 
-/* The main irq map itself is an array of NR_IRQ entries containing the
- * associate host and irq number. An entry with a host of NULL is free.
- * An entry can be allocated if it's free, the allocator always then sets
- * hwirq first to the host's invalid irq number and then fills ops.
- */
-struct irq_map_entry {
-	irq_hw_number_t	hwirq;
-	struct irq_host	*host;
-};
-
-extern struct irq_map_entry irq_map[NR_IRQS];
-
+struct irq_data;
+extern irq_hw_number_t irqd_to_hwirq(struct irq_data *d);
 extern irq_hw_number_t virq_to_hw(unsigned int virq);
-
-/* This will eventually -replace- virq_to_hw if/when we stash the
- * HW number in the irq_data itself. We use a macro so we can inline
- * it as irq_data isn't defined yet
- */
-#define irq_data_to_hw(d) (irq_map[(d)->irq].hwirq)
+extern struct irq_host *virq_to_host(unsigned int virq);
 
 /**
  * irq_alloc_host - Allocate a new irq_host data structure

commit 0b05ac6e24807f0c26f763b3a546c0bcbf84125f
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Mon Apr 4 13:46:58 2011 +1000

    powerpc/xics: Rewrite XICS driver
    
    This is a significant rework of the XICS driver, too significant to
    conveniently break it up into a series of smaller patches to be honest.
    
    The driver is moved to a more generic location to allow new platforms
    to use it, and is broken up into separate ICP and ICS "backends". For
    now we have the native and "hypervisor" ICP backends and one common
    RTAS ICS backend.
    
    The driver supports one ICP backend instanciation, and many ICS ones,
    in order to accomodate future platforms with multiple possibly different
    interrupt "sources" mechanisms.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 67ab5fb7d153..47b7905a6369 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -142,6 +142,12 @@ extern struct irq_map_entry irq_map[NR_IRQS];
 
 extern irq_hw_number_t virq_to_hw(unsigned int virq);
 
+/* This will eventually -replace- virq_to_hw if/when we stash the
+ * HW number in the irq_data itself. We use a macro so we can inline
+ * it as irq_data isn't defined yet
+ */
+#define irq_data_to_hw(d) (irq_map[(d)->irq].hwirq)
+
 /**
  * irq_alloc_host - Allocate a new irq_host data structure
  * @of_node: optional device-tree node of the interrupt controller

commit 4e4f62bf7396fca48efe61513640ee399a6046e3
Merge: 9e3288dc9a94 b37fa16e78d6
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Sat Jul 24 09:49:13 2010 -0600

    Merge commit 'v2.6.35-rc6' into devicetree/next
    
    Conflicts:
            arch/sparc/kernel/prom_64.c

commit e3873444990dd6f8a095d1f72b5ad45192f8c506
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Fri Jun 18 11:09:59 2010 -0600

    of/irq: Move irq_of_parse_and_map() to common code
    
    Merge common code between PowerPC and Microblaze.  SPARC implements
    irq_of_parse_and_map(), but the implementation is different, so it
    does not use this code.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Jeremy Kerr <jeremy.kerr@canonical.com>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index e054baef1845..4e3051595b2b 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -300,34 +300,6 @@ extern unsigned int irq_alloc_virt(struct irq_host *host,
  */
 extern void irq_free_virt(unsigned int virq, unsigned int count);
 
-
-/* -- OF helpers -- */
-
-/**
- * irq_create_of_mapping - Map a hardware interrupt into linux virq space
- * @controller: Device node of the interrupt controller
- * @inspec: Interrupt specifier from the device-tree
- * @intsize: Size of the interrupt specifier from the device-tree
- *
- * This function is identical to irq_create_mapping except that it takes
- * as input informations straight from the device-tree (typically the results
- * of the of_irq_map_*() functions.
- */
-extern unsigned int irq_create_of_mapping(struct device_node *controller,
-					  const u32 *intspec, unsigned int intsize);
-
-/**
- * irq_of_parse_and_map - Parse and Map an interrupt into linux virq space
- * @device: Device node of the device whose interrupt is to be mapped
- * @index: Index of the interrupt to map
- *
- * This function is a wrapper that chains of_irq_map_one() and
- * irq_create_of_mapping() to make things easier to callers
- */
-extern unsigned int irq_of_parse_and_map(struct device_node *dev, int index);
-
-/* -- End OF helpers -- */
-
 /**
  * irq_early_init - Init irq remapping subsystem
  */

commit f1ba9a5b2ab7d3f5a910d93371c4f22b636b7683
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jun 2 22:24:26 2010 +0000

    powerpc: Unconditionally enabled irq stacks
    
    Irq stacks provide an essential protection from stack overflows through
    external interrupts, at the cost of two additionals stacks per CPU.
    
    Enable them unconditionally to simplify the kernel build and prevent
    people from accidentally disabling them.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index e054baef1845..ecba37a91749 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -358,7 +358,6 @@ extern void exc_lvl_ctx_init(void);
 #define exc_lvl_ctx_init()
 #endif
 
-#ifdef CONFIG_IRQSTACKS
 /*
  * Per-cpu stacks for handling hard and soft interrupts.
  */
@@ -369,11 +368,6 @@ extern void irq_ctx_init(void);
 extern void call_do_softirq(struct thread_info *tp);
 extern int call_handle_irq(int irq, void *p1,
 			   struct thread_info *tp, void *func);
-#else
-#define irq_ctx_init()
-
-#endif /* CONFIG_IRQSTACKS */
-
 extern void do_IRQ(struct pt_regs *regs);
 
 #endif /* _ASM_IRQ_H */

commit 40d50cf7ca956183f3a573bc21082e1c7d04fa7b
Author: Roman Fietze <roman.fietze@telemotive.de>
Date:   Tue Dec 8 02:39:50 2009 +0000

    powerpc: Make "intspec" pointers in irq_host->xlate() const
    
    Writing a driver using SCLPC on the MPC5200B I detected, that the
    intspec arrays to map irqs to Linux virq cannot be const, because the
    mapping and xlate functions only take non const pointers. All those
    functions do not modify the intspec, so a const pointer could be used.
    
    Signed-off-by: Roman Fietze <roman.fietze@telemotive.de>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index c85a32f1a17f..e054baef1845 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -100,7 +100,7 @@ struct irq_host_ops {
 	 * interrupt controller has for that line)
 	 */
 	int (*xlate)(struct irq_host *h, struct device_node *ctrler,
-		     u32 *intspec, unsigned int intsize,
+		     const u32 *intspec, unsigned int intsize,
 		     irq_hw_number_t *out_hwirq, unsigned int *out_type);
 };
 
@@ -314,7 +314,7 @@ extern void irq_free_virt(unsigned int virq, unsigned int count);
  * of the of_irq_map_*() functions.
  */
 extern unsigned int irq_create_of_mapping(struct device_node *controller,
-					  u32 *intspec, unsigned int intsize);
+					  const u32 *intspec, unsigned int intsize);
 
 /**
  * irq_of_parse_and_map - Parse and Map an interrupt into linux virq space

commit cd015707176820b86d07b5dffdecfefdd539a497
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue Oct 13 19:45:03 2009 +0000

    powerpc: Enable sparse irq_descs on powerpc
    
    Defining CONFIG_SPARSE_IRQ enables generic code that gets rid of the
    static irq_desc array, and replaces it with an array of pointers to
    irq_descs.
    
    It also allows node local allocation of irq_descs, however we
    currently don't have the information available to do that, so we just
    allocate them on all on node 0.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 03dc28cdb4da..c85a32f1a17f 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -38,6 +38,9 @@ extern atomic_t ppc_n_lost_interrupts;
 /* Number of irqs reserved for the legacy controller */
 #define NUM_ISA_INTERRUPTS	16
 
+/* Same thing, used by the generic IRQ code */
+#define NR_IRQS_LEGACY		NUM_ISA_INTERRUPTS
+
 /* This type is the placeholder for a hardware interrupt number. It has to
  * be big enough to enclose whatever representation is used by a given
  * platform.

commit 6cff46f4bc6cc4a8a4154b0b6a2e669db08e8fd2
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue Oct 13 19:44:51 2009 +0000

    powerpc: Remove get_irq_desc()
    
    get_irq_desc() is a powerpc-specific version of irq_to_desc(). That
    is reason enough to remove it, but it also doesn't know about sparse
    irq_desc support which irq_to_desc() does (when we enable it).
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index b83fcc81faed..03dc28cdb4da 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -17,8 +17,6 @@
 #include <asm/atomic.h>
 
 
-#define get_irq_desc(irq) (&irq_desc[(irq)])
-
 /* Define a way to iterate across irqs. */
 #define for_each_irq(i) \
 	for ((i) = 0; (i) < NR_IRQS; ++(i))

commit 551b81f26ffc2135b8490babad1a9ab12d617e8d
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Tue Oct 13 19:44:44 2009 +0000

    powerpc: Make NR_IRQS a CONFIG option
    
    The irq_desc array consumes quite a lot of space, and for systems
    that don't need or can't have 512 irqs it's just wasted space.
    
    The first 16 are reserved for ISA, so the minimum of 32 is really
    16 - and no one has asked for more than 512 so leave that as the
    maximum.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index bbcd1aaf3dfd..b83fcc81faed 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -34,8 +34,8 @@ extern atomic_t ppc_n_lost_interrupts;
  */
 #define NO_IRQ_IGNORE		((unsigned int)-1)
 
-/* Total number of virq in the platform (make it a CONFIG_* option ? */
-#define NR_IRQS		512
+/* Total number of virq in the platform */
+#define NR_IRQS		CONFIG_NR_IRQS
 
 /* Number of irqs reserved for the legacy controller */
 #define NUM_ISA_INTERRUPTS	16

commit 8708d002c416b8bf87351bc626d15d7407896edb
Author: Wolfram Sang <w.sang@pengutronix.de>
Date:   Thu Sep 10 12:47:20 2009 +0000

    powerpc/irq: Improve nanodoc
    
    The OF helpers look like nanodoc but are missing the header. Fix this and a
    typo (s/nad/and/) while we are here.
    
    Signed-off-by: Wolfram Sang <w.sang@pengutronix.de>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 0a5137676e1b..bbcd1aaf3dfd 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -302,7 +302,8 @@ extern void irq_free_virt(unsigned int virq, unsigned int count);
 
 /* -- OF helpers -- */
 
-/* irq_create_of_mapping - Map a hardware interrupt into linux virq space
+/**
+ * irq_create_of_mapping - Map a hardware interrupt into linux virq space
  * @controller: Device node of the interrupt controller
  * @inspec: Interrupt specifier from the device-tree
  * @intsize: Size of the interrupt specifier from the device-tree
@@ -314,8 +315,8 @@ extern void irq_free_virt(unsigned int virq, unsigned int count);
 extern unsigned int irq_create_of_mapping(struct device_node *controller,
 					  u32 *intspec, unsigned int intsize);
 
-
-/* irq_of_parse_and_map - Parse nad Map an interrupt into linux virq space
+/**
+ * irq_of_parse_and_map - Parse and Map an interrupt into linux virq space
  * @device: Device node of the device whose interrupt is to be mapped
  * @index: Index of the interrupt to map
  *

commit 967e012ef306e99cfddcd7423f37414e6b568361
Author: Sebastien Dugue <sebastien.dugue@bull.net>
Date:   Thu Sep 4 22:37:07 2008 +1000

    powerpc: Separate the irq radix tree insertion and lookup
    
    irq_radix_revmap() currently serves 2 purposes, irq mapping lookup
    and insertion which happen in interrupt and process context respectively.
    
    Separate the function into its 2 components, one for lookup only and one
    for insertion only.
    
    Fix the only user of the revmap tree (XICS) to use the new functions.
    
    Also, move the insertion into the radix tree of those irqs that were
    requested before it was initialized at said tree initialization.
    
    Mutual exclusion between the tree initialization and readers/writers is
    handled via a state variable (revmap_trees_allocated) set to 1 when the tree
    has been initialized and set to 2 after the already requested irqs have been
    inserted in the tree by the init path. This state is checked before any reader
    or writer access just like we used to check for tree.gfp_mask != 0 before.
    
    Finally, now that we're not any longer inserting nodes into the radix-tree
    in interrupt context, turn the GFP_ATOMIC allocations into GFP_KERNEL ones.
    
    Signed-off-by: Sebastien Dugue <sebastien.dugue@bull.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index a372f76836c2..0a5137676e1b 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -236,15 +236,27 @@ extern unsigned int irq_find_mapping(struct irq_host *host,
 extern unsigned int irq_create_direct_mapping(struct irq_host *host);
 
 /**
- * irq_radix_revmap - Find a linux virq from a hw irq number.
+ * irq_radix_revmap_insert - Insert a hw irq to linux virq number mapping.
+ * @host: host owning this hardware interrupt
+ * @virq: linux irq number
+ * @hwirq: hardware irq number in that host space
+ *
+ * This is for use by irq controllers that use a radix tree reverse
+ * mapping for fast lookup.
+ */
+extern void irq_radix_revmap_insert(struct irq_host *host, unsigned int virq,
+				    irq_hw_number_t hwirq);
+
+/**
+ * irq_radix_revmap_lookup - Find a linux virq from a hw irq number.
  * @host: host owning this hardware interrupt
  * @hwirq: hardware irq number in that host space
  *
  * This is a fast path, for use by irq controller code that uses radix tree
  * revmaps
  */
-extern unsigned int irq_radix_revmap(struct irq_host *host,
-				     irq_hw_number_t hwirq);
+extern unsigned int irq_radix_revmap_lookup(struct irq_host *host,
+					    irq_hw_number_t hwirq);
 
 /**
  * irq_linear_revmap - Find a linux virq from a hw irq number.

commit 9c4cb82515130c62224e23fdf7c13c8f6c59c614
Author: Kumar Gala <galak@kernel.crashing.org>
Date:   Sat Aug 2 02:44:11 2008 +1000

    powerpc: Remove use of CONFIG_PPC_MERGE
    
    Now that arch/ppc is gone and CONFIG_PPC_MERGE is always set, remove
    the dead code associated with !CONFIG_PPC_MERGE from arch/powerpc
    and include/asm-powerpc.
    
    Signed-off-by: Kumar Gala <galak@kernel.crashing.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
index 1ef8e304e0ea..a372f76836c2 100644
--- a/arch/powerpc/include/asm/irq.h
+++ b/arch/powerpc/include/asm/irq.h
@@ -25,8 +25,6 @@
 
 extern atomic_t ppc_n_lost_interrupts;
 
-#ifdef CONFIG_PPC_MERGE
-
 /* This number is used when no interrupt has been assigned */
 #define NO_IRQ			(0)
 
@@ -326,292 +324,6 @@ static __inline__ int irq_canonicalize(int irq)
 	return irq;
 }
 
-
-#else /* CONFIG_PPC_MERGE */
-
-/* This number is used when no interrupt has been assigned */
-#define NO_IRQ			(-1)
-#define NO_IRQ_IGNORE		(-2)
-
-
-/*
- * These constants are used for passing information about interrupt
- * signal polarity and level/edge sensing to the low-level PIC chip
- * drivers.
- */
-#define IRQ_SENSE_MASK		0x1
-#define IRQ_SENSE_LEVEL		0x1	/* interrupt on active level */
-#define IRQ_SENSE_EDGE		0x0	/* interrupt triggered by edge */
-
-#define IRQ_POLARITY_MASK	0x2
-#define IRQ_POLARITY_POSITIVE	0x2	/* high level or low->high edge */
-#define IRQ_POLARITY_NEGATIVE	0x0	/* low level or high->low edge */
-
-
-#if defined(CONFIG_40x)
-#include <asm/ibm4xx.h>
-
-#ifndef NR_BOARD_IRQS
-#define NR_BOARD_IRQS 0
-#endif
-
-#ifndef UIC_WIDTH /* Number of interrupts per device */
-#define UIC_WIDTH 32
-#endif
-
-#ifndef NR_UICS /* number  of UIC devices */
-#define NR_UICS 1
-#endif
-
-#if defined (CONFIG_403)
-/*
- * The PowerPC 403 cores' Asynchronous Interrupt Controller (AIC) has
- * 32 possible interrupts, a majority of which are not implemented on
- * all cores. There are six configurable, external interrupt pins and
- * there are eight internal interrupts for the on-chip serial port
- * (SPU), DMA controller, and JTAG controller.
- *
- */
-
-#define	NR_AIC_IRQS 32
-#define	NR_IRQS	 (NR_AIC_IRQS + NR_BOARD_IRQS)
-
-#elif !defined (CONFIG_403)
-
-/*
- *  The PowerPC 405 cores' Universal Interrupt Controller (UIC) has 32
- * possible interrupts as well. There are seven, configurable external
- * interrupt pins and there are 17 internal interrupts for the on-chip
- * serial port, DMA controller, on-chip Ethernet controller, PCI, etc.
- *
- */
-
-
-#define NR_UIC_IRQS UIC_WIDTH
-#define NR_IRQS		((NR_UIC_IRQS * NR_UICS) + NR_BOARD_IRQS)
-#endif
-
-#elif defined(CONFIG_44x)
-#include <asm/ibm44x.h>
-
-#define	NR_UIC_IRQS	32
-#define	NR_IRQS		((NR_UIC_IRQS * NR_UICS) + NR_BOARD_IRQS)
-
-#elif defined(CONFIG_8xx)
-
-/* Now include the board configuration specific associations.
-*/
-#include <asm/mpc8xx.h>
-
-/* The MPC8xx cores have 16 possible interrupts.  There are eight
- * possible level sensitive interrupts assigned and generated internally
- * from such devices as CPM, PCMCIA, RTC, PIT, TimeBase and Decrementer.
- * There are eight external interrupts (IRQs) that can be configured
- * as either level or edge sensitive.
- *
- * On some implementations, there is also the possibility of an 8259
- * through the PCI and PCI-ISA bridges.
- *
- * We are "flattening" the interrupt vectors of the cascaded CPM
- * and 8259 interrupt controllers so that we can uniquely identify
- * any interrupt source with a single integer.
- */
-#define NR_SIU_INTS	16
-#define NR_CPM_INTS	32
-#ifndef NR_8259_INTS
-#define NR_8259_INTS 0
-#endif
-
-#define SIU_IRQ_OFFSET		0
-#define CPM_IRQ_OFFSET		(SIU_IRQ_OFFSET + NR_SIU_INTS)
-#define I8259_IRQ_OFFSET	(CPM_IRQ_OFFSET + NR_CPM_INTS)
-
-#define NR_IRQS	(NR_SIU_INTS + NR_CPM_INTS + NR_8259_INTS)
-
-/* These values must be zero-based and map 1:1 with the SIU configuration.
- * They are used throughout the 8xx I/O subsystem to generate
- * interrupt masks, flags, and other control patterns.  This is why the
- * current kernel assumption of the 8259 as the base controller is such
- * a pain in the butt.
- */
-#define	SIU_IRQ0	(0)	/* Highest priority */
-#define	SIU_LEVEL0	(1)
-#define	SIU_IRQ1	(2)
-#define	SIU_LEVEL1	(3)
-#define	SIU_IRQ2	(4)
-#define	SIU_LEVEL2	(5)
-#define	SIU_IRQ3	(6)
-#define	SIU_LEVEL3	(7)
-#define	SIU_IRQ4	(8)
-#define	SIU_LEVEL4	(9)
-#define	SIU_IRQ5	(10)
-#define	SIU_LEVEL5	(11)
-#define	SIU_IRQ6	(12)
-#define	SIU_LEVEL6	(13)
-#define	SIU_IRQ7	(14)
-#define	SIU_LEVEL7	(15)
-
-#define MPC8xx_INT_FEC1		SIU_LEVEL1
-#define MPC8xx_INT_FEC2		SIU_LEVEL3
-
-#define MPC8xx_INT_SCC1		(CPM_IRQ_OFFSET + CPMVEC_SCC1)
-#define MPC8xx_INT_SCC2		(CPM_IRQ_OFFSET + CPMVEC_SCC2)
-#define MPC8xx_INT_SCC3		(CPM_IRQ_OFFSET + CPMVEC_SCC3)
-#define MPC8xx_INT_SCC4		(CPM_IRQ_OFFSET + CPMVEC_SCC4)
-#define MPC8xx_INT_SMC1		(CPM_IRQ_OFFSET + CPMVEC_SMC1)
-#define MPC8xx_INT_SMC2		(CPM_IRQ_OFFSET + CPMVEC_SMC2)
-
-/* The internal interrupts we can configure as we see fit.
- * My personal preference is CPM at level 2, which puts it above the
- * MBX PCI/ISA/IDE interrupts.
- */
-#ifndef PIT_INTERRUPT
-#define PIT_INTERRUPT		SIU_LEVEL0
-#endif
-#ifndef	CPM_INTERRUPT
-#define CPM_INTERRUPT		SIU_LEVEL2
-#endif
-#ifndef	PCMCIA_INTERRUPT
-#define PCMCIA_INTERRUPT	SIU_LEVEL6
-#endif
-#ifndef	DEC_INTERRUPT
-#define DEC_INTERRUPT		SIU_LEVEL7
-#endif
-
-/* Some internal interrupt registers use an 8-bit mask for the interrupt
- * level instead of a number.
- */
-#define	mk_int_int_mask(IL) (1 << (7 - (IL/2)))
-
-#else /* CONFIG_40x + CONFIG_8xx */
-/*
- * this is the # irq's for all ppc arch's (pmac/chrp/prep)
- * so it is the max of them all
- */
-#define NR_IRQS			256
-#define __DO_IRQ_CANON	1
-
-#ifndef CONFIG_8260
-
-#define NUM_8259_INTERRUPTS	16
-
-#else /* CONFIG_8260 */
-
-/* The 8260 has an internal interrupt controller with a maximum of
- * 64 IRQs.  We will use NR_IRQs from above since it is large enough.
- * Don't be confused by the 8260 documentation where they list an
- * "interrupt number" and "interrupt vector".  We are only interested
- * in the interrupt vector.  There are "reserved" holes where the
- * vector number increases, but the interrupt number in the table does not.
- * (Document errata updates have fixed this...make sure you have up to
- * date processor documentation -- Dan).
- */
-
-#ifndef CPM_IRQ_OFFSET
-#define CPM_IRQ_OFFSET	0
-#endif
-
-#define NR_CPM_INTS	64
-
-#define	SIU_INT_ERROR		((uint)0x00 + CPM_IRQ_OFFSET)
-#define	SIU_INT_I2C		((uint)0x01 + CPM_IRQ_OFFSET)
-#define	SIU_INT_SPI		((uint)0x02 + CPM_IRQ_OFFSET)
-#define	SIU_INT_RISC		((uint)0x03 + CPM_IRQ_OFFSET)
-#define	SIU_INT_SMC1		((uint)0x04 + CPM_IRQ_OFFSET)
-#define	SIU_INT_SMC2		((uint)0x05 + CPM_IRQ_OFFSET)
-#define	SIU_INT_IDMA1		((uint)0x06 + CPM_IRQ_OFFSET)
-#define	SIU_INT_IDMA2		((uint)0x07 + CPM_IRQ_OFFSET)
-#define	SIU_INT_IDMA3		((uint)0x08 + CPM_IRQ_OFFSET)
-#define	SIU_INT_IDMA4		((uint)0x09 + CPM_IRQ_OFFSET)
-#define	SIU_INT_SDMA		((uint)0x0a + CPM_IRQ_OFFSET)
-#define	SIU_INT_USB		((uint)0x0b + CPM_IRQ_OFFSET)
-#define	SIU_INT_TIMER1		((uint)0x0c + CPM_IRQ_OFFSET)
-#define	SIU_INT_TIMER2		((uint)0x0d + CPM_IRQ_OFFSET)
-#define	SIU_INT_TIMER3		((uint)0x0e + CPM_IRQ_OFFSET)
-#define	SIU_INT_TIMER4		((uint)0x0f + CPM_IRQ_OFFSET)
-#define	SIU_INT_TMCNT		((uint)0x10 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PIT		((uint)0x11 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PCI		((uint)0x12 + CPM_IRQ_OFFSET)
-#define	SIU_INT_IRQ1		((uint)0x13 + CPM_IRQ_OFFSET)
-#define	SIU_INT_IRQ2		((uint)0x14 + CPM_IRQ_OFFSET)
-#define	SIU_INT_IRQ3		((uint)0x15 + CPM_IRQ_OFFSET)
-#define	SIU_INT_IRQ4		((uint)0x16 + CPM_IRQ_OFFSET)
-#define	SIU_INT_IRQ5		((uint)0x17 + CPM_IRQ_OFFSET)
-#define	SIU_INT_IRQ6		((uint)0x18 + CPM_IRQ_OFFSET)
-#define	SIU_INT_IRQ7		((uint)0x19 + CPM_IRQ_OFFSET)
-#define	SIU_INT_FCC1		((uint)0x20 + CPM_IRQ_OFFSET)
-#define	SIU_INT_FCC2		((uint)0x21 + CPM_IRQ_OFFSET)
-#define	SIU_INT_FCC3		((uint)0x22 + CPM_IRQ_OFFSET)
-#define	SIU_INT_MCC1		((uint)0x24 + CPM_IRQ_OFFSET)
-#define	SIU_INT_MCC2		((uint)0x25 + CPM_IRQ_OFFSET)
-#define	SIU_INT_SCC1		((uint)0x28 + CPM_IRQ_OFFSET)
-#define	SIU_INT_SCC2		((uint)0x29 + CPM_IRQ_OFFSET)
-#define	SIU_INT_SCC3		((uint)0x2a + CPM_IRQ_OFFSET)
-#define	SIU_INT_SCC4		((uint)0x2b + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC15		((uint)0x30 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC14		((uint)0x31 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC13		((uint)0x32 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC12		((uint)0x33 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC11		((uint)0x34 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC10		((uint)0x35 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC9		((uint)0x36 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC8		((uint)0x37 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC7		((uint)0x38 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC6		((uint)0x39 + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC5		((uint)0x3a + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC4		((uint)0x3b + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC3		((uint)0x3c + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC2		((uint)0x3d + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC1		((uint)0x3e + CPM_IRQ_OFFSET)
-#define	SIU_INT_PC0		((uint)0x3f + CPM_IRQ_OFFSET)
-
-#endif /* CONFIG_8260 */
-
-#endif /* Whatever way too big #ifdef */
-
-#define NR_MASK_WORDS	((NR_IRQS + 31) / 32)
-/* pedantic: these are long because they are used with set_bit --RR */
-extern unsigned long ppc_cached_irq_mask[NR_MASK_WORDS];
-
-/*
- * Because many systems have two overlapping names spaces for
- * interrupts (ISA and XICS for example), and the ISA interrupts
- * have historically not been easy to renumber, we allow ISA
- * interrupts to take values 0 - 15, and shift up the remaining
- * interrupts by 0x10.
- */
-#define NUM_ISA_INTERRUPTS	0x10
-extern int __irq_offset_value;
-
-static inline int irq_offset_up(int irq)
-{
-	return(irq + __irq_offset_value);
-}
-
-static inline int irq_offset_down(int irq)
-{
-	return(irq - __irq_offset_value);
-}
-
-static inline int irq_offset_value(void)
-{
-	return __irq_offset_value;
-}
-
-#ifdef __DO_IRQ_CANON
-extern int ppc_do_canonicalize_irqs;
-#else
-#define ppc_do_canonicalize_irqs	0
-#endif
-
-static __inline__ int irq_canonicalize(int irq)
-{
-	if (ppc_do_canonicalize_irqs && irq == 2)
-		irq = 9;
-	return irq;
-}
-#endif /* CONFIG_PPC_MERGE */
-
 extern int distribute_irqs;
 
 struct irqaction;

commit b8b572e1015f81b4e748417be2629dfe51ab99f9
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Fri Aug 1 15:20:30 2008 +1000

    powerpc: Move include files to arch/powerpc/include/asm
    
    from include/asm-powerpc.  This is the result of a
    
    mkdir arch/powerpc/include/asm
    git mv include/asm-powerpc/* arch/powerpc/include/asm
    
    Followed by a few documentation/comment fixups and a couple of places
    where <asm-powepc/...> was being used explicitly.  Of the latter only
    one was outside the arch code and it is a driver only built for powerpc.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/include/asm/irq.h b/arch/powerpc/include/asm/irq.h
new file mode 100644
index 000000000000..1ef8e304e0ea
--- /dev/null
+++ b/arch/powerpc/include/asm/irq.h
@@ -0,0 +1,654 @@
+#ifdef __KERNEL__
+#ifndef _ASM_POWERPC_IRQ_H
+#define _ASM_POWERPC_IRQ_H
+
+/*
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/threads.h>
+#include <linux/list.h>
+#include <linux/radix-tree.h>
+
+#include <asm/types.h>
+#include <asm/atomic.h>
+
+
+#define get_irq_desc(irq) (&irq_desc[(irq)])
+
+/* Define a way to iterate across irqs. */
+#define for_each_irq(i) \
+	for ((i) = 0; (i) < NR_IRQS; ++(i))
+
+extern atomic_t ppc_n_lost_interrupts;
+
+#ifdef CONFIG_PPC_MERGE
+
+/* This number is used when no interrupt has been assigned */
+#define NO_IRQ			(0)
+
+/* This is a special irq number to return from get_irq() to tell that
+ * no interrupt happened _and_ ignore it (don't count it as bad). Some
+ * platforms like iSeries rely on that.
+ */
+#define NO_IRQ_IGNORE		((unsigned int)-1)
+
+/* Total number of virq in the platform (make it a CONFIG_* option ? */
+#define NR_IRQS		512
+
+/* Number of irqs reserved for the legacy controller */
+#define NUM_ISA_INTERRUPTS	16
+
+/* This type is the placeholder for a hardware interrupt number. It has to
+ * be big enough to enclose whatever representation is used by a given
+ * platform.
+ */
+typedef unsigned long irq_hw_number_t;
+
+/* Interrupt controller "host" data structure. This could be defined as a
+ * irq domain controller. That is, it handles the mapping between hardware
+ * and virtual interrupt numbers for a given interrupt domain. The host
+ * structure is generally created by the PIC code for a given PIC instance
+ * (though a host can cover more than one PIC if they have a flat number
+ * model). It's the host callbacks that are responsible for setting the
+ * irq_chip on a given irq_desc after it's been mapped.
+ *
+ * The host code and data structures are fairly agnostic to the fact that
+ * we use an open firmware device-tree. We do have references to struct
+ * device_node in two places: in irq_find_host() to find the host matching
+ * a given interrupt controller node, and of course as an argument to its
+ * counterpart host->ops->match() callback. However, those are treated as
+ * generic pointers by the core and the fact that it's actually a device-node
+ * pointer is purely a convention between callers and implementation. This
+ * code could thus be used on other architectures by replacing those two
+ * by some sort of arch-specific void * "token" used to identify interrupt
+ * controllers.
+ */
+struct irq_host;
+struct radix_tree_root;
+
+/* Functions below are provided by the host and called whenever a new mapping
+ * is created or an old mapping is disposed. The host can then proceed to
+ * whatever internal data structures management is required. It also needs
+ * to setup the irq_desc when returning from map().
+ */
+struct irq_host_ops {
+	/* Match an interrupt controller device node to a host, returns
+	 * 1 on a match
+	 */
+	int (*match)(struct irq_host *h, struct device_node *node);
+
+	/* Create or update a mapping between a virtual irq number and a hw
+	 * irq number. This is called only once for a given mapping.
+	 */
+	int (*map)(struct irq_host *h, unsigned int virq, irq_hw_number_t hw);
+
+	/* Dispose of such a mapping */
+	void (*unmap)(struct irq_host *h, unsigned int virq);
+
+	/* Update of such a mapping  */
+	void (*remap)(struct irq_host *h, unsigned int virq, irq_hw_number_t hw);
+
+	/* Translate device-tree interrupt specifier from raw format coming
+	 * from the firmware to a irq_hw_number_t (interrupt line number) and
+	 * type (sense) that can be passed to set_irq_type(). In the absence
+	 * of this callback, irq_create_of_mapping() and irq_of_parse_and_map()
+	 * will return the hw number in the first cell and IRQ_TYPE_NONE for
+	 * the type (which amount to keeping whatever default value the
+	 * interrupt controller has for that line)
+	 */
+	int (*xlate)(struct irq_host *h, struct device_node *ctrler,
+		     u32 *intspec, unsigned int intsize,
+		     irq_hw_number_t *out_hwirq, unsigned int *out_type);
+};
+
+struct irq_host {
+	struct list_head	link;
+
+	/* type of reverse mapping technique */
+	unsigned int		revmap_type;
+#define IRQ_HOST_MAP_LEGACY     0 /* legacy 8259, gets irqs 1..15 */
+#define IRQ_HOST_MAP_NOMAP	1 /* no fast reverse mapping */
+#define IRQ_HOST_MAP_LINEAR	2 /* linear map of interrupts */
+#define IRQ_HOST_MAP_TREE	3 /* radix tree */
+	union {
+		struct {
+			unsigned int size;
+			unsigned int *revmap;
+		} linear;
+		struct radix_tree_root tree;
+	} revmap_data;
+	struct irq_host_ops	*ops;
+	void			*host_data;
+	irq_hw_number_t		inval_irq;
+
+	/* Optional device node pointer */
+	struct device_node	*of_node;
+};
+
+/* The main irq map itself is an array of NR_IRQ entries containing the
+ * associate host and irq number. An entry with a host of NULL is free.
+ * An entry can be allocated if it's free, the allocator always then sets
+ * hwirq first to the host's invalid irq number and then fills ops.
+ */
+struct irq_map_entry {
+	irq_hw_number_t	hwirq;
+	struct irq_host	*host;
+};
+
+extern struct irq_map_entry irq_map[NR_IRQS];
+
+extern irq_hw_number_t virq_to_hw(unsigned int virq);
+
+/**
+ * irq_alloc_host - Allocate a new irq_host data structure
+ * @of_node: optional device-tree node of the interrupt controller
+ * @revmap_type: type of reverse mapping to use
+ * @revmap_arg: for IRQ_HOST_MAP_LINEAR linear only: size of the map
+ * @ops: map/unmap host callbacks
+ * @inval_irq: provide a hw number in that host space that is always invalid
+ *
+ * Allocates and initialize and irq_host structure. Note that in the case of
+ * IRQ_HOST_MAP_LEGACY, the map() callback will be called before this returns
+ * for all legacy interrupts except 0 (which is always the invalid irq for
+ * a legacy controller). For a IRQ_HOST_MAP_LINEAR, the map is allocated by
+ * this call as well. For a IRQ_HOST_MAP_TREE, the radix tree will be allocated
+ * later during boot automatically (the reverse mapping will use the slow path
+ * until that happens).
+ */
+extern struct irq_host *irq_alloc_host(struct device_node *of_node,
+				       unsigned int revmap_type,
+				       unsigned int revmap_arg,
+				       struct irq_host_ops *ops,
+				       irq_hw_number_t inval_irq);
+
+
+/**
+ * irq_find_host - Locates a host for a given device node
+ * @node: device-tree node of the interrupt controller
+ */
+extern struct irq_host *irq_find_host(struct device_node *node);
+
+
+/**
+ * irq_set_default_host - Set a "default" host
+ * @host: default host pointer
+ *
+ * For convenience, it's possible to set a "default" host that will be used
+ * whenever NULL is passed to irq_create_mapping(). It makes life easier for
+ * platforms that want to manipulate a few hard coded interrupt numbers that
+ * aren't properly represented in the device-tree.
+ */
+extern void irq_set_default_host(struct irq_host *host);
+
+
+/**
+ * irq_set_virq_count - Set the maximum number of virt irqs
+ * @count: number of linux virtual irqs, capped with NR_IRQS
+ *
+ * This is mainly for use by platforms like iSeries who want to program
+ * the virtual irq number in the controller to avoid the reverse mapping
+ */
+extern void irq_set_virq_count(unsigned int count);
+
+
+/**
+ * irq_create_mapping - Map a hardware interrupt into linux virq space
+ * @host: host owning this hardware interrupt or NULL for default host
+ * @hwirq: hardware irq number in that host space
+ *
+ * Only one mapping per hardware interrupt is permitted. Returns a linux
+ * virq number.
+ * If the sense/trigger is to be specified, set_irq_type() should be called
+ * on the number returned from that call.
+ */
+extern unsigned int irq_create_mapping(struct irq_host *host,
+				       irq_hw_number_t hwirq);
+
+
+/**
+ * irq_dispose_mapping - Unmap an interrupt
+ * @virq: linux virq number of the interrupt to unmap
+ */
+extern void irq_dispose_mapping(unsigned int virq);
+
+/**
+ * irq_find_mapping - Find a linux virq from an hw irq number.
+ * @host: host owning this hardware interrupt
+ * @hwirq: hardware irq number in that host space
+ *
+ * This is a slow path, for use by generic code. It's expected that an
+ * irq controller implementation directly calls the appropriate low level
+ * mapping function.
+ */
+extern unsigned int irq_find_mapping(struct irq_host *host,
+				     irq_hw_number_t hwirq);
+
+/**
+ * irq_create_direct_mapping - Allocate a virq for direct mapping
+ * @host: host to allocate the virq for or NULL for default host
+ *
+ * This routine is used for irq controllers which can choose the hardware
+ * interrupt numbers they generate. In such a case it's simplest to use
+ * the linux virq as the hardware interrupt number.
+ */
+extern unsigned int irq_create_direct_mapping(struct irq_host *host);
+
+/**
+ * irq_radix_revmap - Find a linux virq from a hw irq number.
+ * @host: host owning this hardware interrupt
+ * @hwirq: hardware irq number in that host space
+ *
+ * This is a fast path, for use by irq controller code that uses radix tree
+ * revmaps
+ */
+extern unsigned int irq_radix_revmap(struct irq_host *host,
+				     irq_hw_number_t hwirq);
+
+/**
+ * irq_linear_revmap - Find a linux virq from a hw irq number.
+ * @host: host owning this hardware interrupt
+ * @hwirq: hardware irq number in that host space
+ *
+ * This is a fast path, for use by irq controller code that uses linear
+ * revmaps. It does fallback to the slow path if the revmap doesn't exist
+ * yet and will create the revmap entry with appropriate locking
+ */
+
+extern unsigned int irq_linear_revmap(struct irq_host *host,
+				      irq_hw_number_t hwirq);
+
+
+
+/**
+ * irq_alloc_virt - Allocate virtual irq numbers
+ * @host: host owning these new virtual irqs
+ * @count: number of consecutive numbers to allocate
+ * @hint: pass a hint number, the allocator will try to use a 1:1 mapping
+ *
+ * This is a low level function that is used internally by irq_create_mapping()
+ * and that can be used by some irq controllers implementations for things
+ * like allocating ranges of numbers for MSIs. The revmaps are left untouched.
+ */
+extern unsigned int irq_alloc_virt(struct irq_host *host,
+				   unsigned int count,
+				   unsigned int hint);
+
+/**
+ * irq_free_virt - Free virtual irq numbers
+ * @virq: virtual irq number of the first interrupt to free
+ * @count: number of interrupts to free
+ *
+ * This function is the opposite of irq_alloc_virt. It will not clear reverse
+ * maps, this should be done previously by unmap'ing the interrupt. In fact,
+ * all interrupts covered by the range being freed should have been unmapped
+ * prior to calling this.
+ */
+extern void irq_free_virt(unsigned int virq, unsigned int count);
+
+
+/* -- OF helpers -- */
+
+/* irq_create_of_mapping - Map a hardware interrupt into linux virq space
+ * @controller: Device node of the interrupt controller
+ * @inspec: Interrupt specifier from the device-tree
+ * @intsize: Size of the interrupt specifier from the device-tree
+ *
+ * This function is identical to irq_create_mapping except that it takes
+ * as input informations straight from the device-tree (typically the results
+ * of the of_irq_map_*() functions.
+ */
+extern unsigned int irq_create_of_mapping(struct device_node *controller,
+					  u32 *intspec, unsigned int intsize);
+
+
+/* irq_of_parse_and_map - Parse nad Map an interrupt into linux virq space
+ * @device: Device node of the device whose interrupt is to be mapped
+ * @index: Index of the interrupt to map
+ *
+ * This function is a wrapper that chains of_irq_map_one() and
+ * irq_create_of_mapping() to make things easier to callers
+ */
+extern unsigned int irq_of_parse_and_map(struct device_node *dev, int index);
+
+/* -- End OF helpers -- */
+
+/**
+ * irq_early_init - Init irq remapping subsystem
+ */
+extern void irq_early_init(void);
+
+static __inline__ int irq_canonicalize(int irq)
+{
+	return irq;
+}
+
+
+#else /* CONFIG_PPC_MERGE */
+
+/* This number is used when no interrupt has been assigned */
+#define NO_IRQ			(-1)
+#define NO_IRQ_IGNORE		(-2)
+
+
+/*
+ * These constants are used for passing information about interrupt
+ * signal polarity and level/edge sensing to the low-level PIC chip
+ * drivers.
+ */
+#define IRQ_SENSE_MASK		0x1
+#define IRQ_SENSE_LEVEL		0x1	/* interrupt on active level */
+#define IRQ_SENSE_EDGE		0x0	/* interrupt triggered by edge */
+
+#define IRQ_POLARITY_MASK	0x2
+#define IRQ_POLARITY_POSITIVE	0x2	/* high level or low->high edge */
+#define IRQ_POLARITY_NEGATIVE	0x0	/* low level or high->low edge */
+
+
+#if defined(CONFIG_40x)
+#include <asm/ibm4xx.h>
+
+#ifndef NR_BOARD_IRQS
+#define NR_BOARD_IRQS 0
+#endif
+
+#ifndef UIC_WIDTH /* Number of interrupts per device */
+#define UIC_WIDTH 32
+#endif
+
+#ifndef NR_UICS /* number  of UIC devices */
+#define NR_UICS 1
+#endif
+
+#if defined (CONFIG_403)
+/*
+ * The PowerPC 403 cores' Asynchronous Interrupt Controller (AIC) has
+ * 32 possible interrupts, a majority of which are not implemented on
+ * all cores. There are six configurable, external interrupt pins and
+ * there are eight internal interrupts for the on-chip serial port
+ * (SPU), DMA controller, and JTAG controller.
+ *
+ */
+
+#define	NR_AIC_IRQS 32
+#define	NR_IRQS	 (NR_AIC_IRQS + NR_BOARD_IRQS)
+
+#elif !defined (CONFIG_403)
+
+/*
+ *  The PowerPC 405 cores' Universal Interrupt Controller (UIC) has 32
+ * possible interrupts as well. There are seven, configurable external
+ * interrupt pins and there are 17 internal interrupts for the on-chip
+ * serial port, DMA controller, on-chip Ethernet controller, PCI, etc.
+ *
+ */
+
+
+#define NR_UIC_IRQS UIC_WIDTH
+#define NR_IRQS		((NR_UIC_IRQS * NR_UICS) + NR_BOARD_IRQS)
+#endif
+
+#elif defined(CONFIG_44x)
+#include <asm/ibm44x.h>
+
+#define	NR_UIC_IRQS	32
+#define	NR_IRQS		((NR_UIC_IRQS * NR_UICS) + NR_BOARD_IRQS)
+
+#elif defined(CONFIG_8xx)
+
+/* Now include the board configuration specific associations.
+*/
+#include <asm/mpc8xx.h>
+
+/* The MPC8xx cores have 16 possible interrupts.  There are eight
+ * possible level sensitive interrupts assigned and generated internally
+ * from such devices as CPM, PCMCIA, RTC, PIT, TimeBase and Decrementer.
+ * There are eight external interrupts (IRQs) that can be configured
+ * as either level or edge sensitive.
+ *
+ * On some implementations, there is also the possibility of an 8259
+ * through the PCI and PCI-ISA bridges.
+ *
+ * We are "flattening" the interrupt vectors of the cascaded CPM
+ * and 8259 interrupt controllers so that we can uniquely identify
+ * any interrupt source with a single integer.
+ */
+#define NR_SIU_INTS	16
+#define NR_CPM_INTS	32
+#ifndef NR_8259_INTS
+#define NR_8259_INTS 0
+#endif
+
+#define SIU_IRQ_OFFSET		0
+#define CPM_IRQ_OFFSET		(SIU_IRQ_OFFSET + NR_SIU_INTS)
+#define I8259_IRQ_OFFSET	(CPM_IRQ_OFFSET + NR_CPM_INTS)
+
+#define NR_IRQS	(NR_SIU_INTS + NR_CPM_INTS + NR_8259_INTS)
+
+/* These values must be zero-based and map 1:1 with the SIU configuration.
+ * They are used throughout the 8xx I/O subsystem to generate
+ * interrupt masks, flags, and other control patterns.  This is why the
+ * current kernel assumption of the 8259 as the base controller is such
+ * a pain in the butt.
+ */
+#define	SIU_IRQ0	(0)	/* Highest priority */
+#define	SIU_LEVEL0	(1)
+#define	SIU_IRQ1	(2)
+#define	SIU_LEVEL1	(3)
+#define	SIU_IRQ2	(4)
+#define	SIU_LEVEL2	(5)
+#define	SIU_IRQ3	(6)
+#define	SIU_LEVEL3	(7)
+#define	SIU_IRQ4	(8)
+#define	SIU_LEVEL4	(9)
+#define	SIU_IRQ5	(10)
+#define	SIU_LEVEL5	(11)
+#define	SIU_IRQ6	(12)
+#define	SIU_LEVEL6	(13)
+#define	SIU_IRQ7	(14)
+#define	SIU_LEVEL7	(15)
+
+#define MPC8xx_INT_FEC1		SIU_LEVEL1
+#define MPC8xx_INT_FEC2		SIU_LEVEL3
+
+#define MPC8xx_INT_SCC1		(CPM_IRQ_OFFSET + CPMVEC_SCC1)
+#define MPC8xx_INT_SCC2		(CPM_IRQ_OFFSET + CPMVEC_SCC2)
+#define MPC8xx_INT_SCC3		(CPM_IRQ_OFFSET + CPMVEC_SCC3)
+#define MPC8xx_INT_SCC4		(CPM_IRQ_OFFSET + CPMVEC_SCC4)
+#define MPC8xx_INT_SMC1		(CPM_IRQ_OFFSET + CPMVEC_SMC1)
+#define MPC8xx_INT_SMC2		(CPM_IRQ_OFFSET + CPMVEC_SMC2)
+
+/* The internal interrupts we can configure as we see fit.
+ * My personal preference is CPM at level 2, which puts it above the
+ * MBX PCI/ISA/IDE interrupts.
+ */
+#ifndef PIT_INTERRUPT
+#define PIT_INTERRUPT		SIU_LEVEL0
+#endif
+#ifndef	CPM_INTERRUPT
+#define CPM_INTERRUPT		SIU_LEVEL2
+#endif
+#ifndef	PCMCIA_INTERRUPT
+#define PCMCIA_INTERRUPT	SIU_LEVEL6
+#endif
+#ifndef	DEC_INTERRUPT
+#define DEC_INTERRUPT		SIU_LEVEL7
+#endif
+
+/* Some internal interrupt registers use an 8-bit mask for the interrupt
+ * level instead of a number.
+ */
+#define	mk_int_int_mask(IL) (1 << (7 - (IL/2)))
+
+#else /* CONFIG_40x + CONFIG_8xx */
+/*
+ * this is the # irq's for all ppc arch's (pmac/chrp/prep)
+ * so it is the max of them all
+ */
+#define NR_IRQS			256
+#define __DO_IRQ_CANON	1
+
+#ifndef CONFIG_8260
+
+#define NUM_8259_INTERRUPTS	16
+
+#else /* CONFIG_8260 */
+
+/* The 8260 has an internal interrupt controller with a maximum of
+ * 64 IRQs.  We will use NR_IRQs from above since it is large enough.
+ * Don't be confused by the 8260 documentation where they list an
+ * "interrupt number" and "interrupt vector".  We are only interested
+ * in the interrupt vector.  There are "reserved" holes where the
+ * vector number increases, but the interrupt number in the table does not.
+ * (Document errata updates have fixed this...make sure you have up to
+ * date processor documentation -- Dan).
+ */
+
+#ifndef CPM_IRQ_OFFSET
+#define CPM_IRQ_OFFSET	0
+#endif
+
+#define NR_CPM_INTS	64
+
+#define	SIU_INT_ERROR		((uint)0x00 + CPM_IRQ_OFFSET)
+#define	SIU_INT_I2C		((uint)0x01 + CPM_IRQ_OFFSET)
+#define	SIU_INT_SPI		((uint)0x02 + CPM_IRQ_OFFSET)
+#define	SIU_INT_RISC		((uint)0x03 + CPM_IRQ_OFFSET)
+#define	SIU_INT_SMC1		((uint)0x04 + CPM_IRQ_OFFSET)
+#define	SIU_INT_SMC2		((uint)0x05 + CPM_IRQ_OFFSET)
+#define	SIU_INT_IDMA1		((uint)0x06 + CPM_IRQ_OFFSET)
+#define	SIU_INT_IDMA2		((uint)0x07 + CPM_IRQ_OFFSET)
+#define	SIU_INT_IDMA3		((uint)0x08 + CPM_IRQ_OFFSET)
+#define	SIU_INT_IDMA4		((uint)0x09 + CPM_IRQ_OFFSET)
+#define	SIU_INT_SDMA		((uint)0x0a + CPM_IRQ_OFFSET)
+#define	SIU_INT_USB		((uint)0x0b + CPM_IRQ_OFFSET)
+#define	SIU_INT_TIMER1		((uint)0x0c + CPM_IRQ_OFFSET)
+#define	SIU_INT_TIMER2		((uint)0x0d + CPM_IRQ_OFFSET)
+#define	SIU_INT_TIMER3		((uint)0x0e + CPM_IRQ_OFFSET)
+#define	SIU_INT_TIMER4		((uint)0x0f + CPM_IRQ_OFFSET)
+#define	SIU_INT_TMCNT		((uint)0x10 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PIT		((uint)0x11 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PCI		((uint)0x12 + CPM_IRQ_OFFSET)
+#define	SIU_INT_IRQ1		((uint)0x13 + CPM_IRQ_OFFSET)
+#define	SIU_INT_IRQ2		((uint)0x14 + CPM_IRQ_OFFSET)
+#define	SIU_INT_IRQ3		((uint)0x15 + CPM_IRQ_OFFSET)
+#define	SIU_INT_IRQ4		((uint)0x16 + CPM_IRQ_OFFSET)
+#define	SIU_INT_IRQ5		((uint)0x17 + CPM_IRQ_OFFSET)
+#define	SIU_INT_IRQ6		((uint)0x18 + CPM_IRQ_OFFSET)
+#define	SIU_INT_IRQ7		((uint)0x19 + CPM_IRQ_OFFSET)
+#define	SIU_INT_FCC1		((uint)0x20 + CPM_IRQ_OFFSET)
+#define	SIU_INT_FCC2		((uint)0x21 + CPM_IRQ_OFFSET)
+#define	SIU_INT_FCC3		((uint)0x22 + CPM_IRQ_OFFSET)
+#define	SIU_INT_MCC1		((uint)0x24 + CPM_IRQ_OFFSET)
+#define	SIU_INT_MCC2		((uint)0x25 + CPM_IRQ_OFFSET)
+#define	SIU_INT_SCC1		((uint)0x28 + CPM_IRQ_OFFSET)
+#define	SIU_INT_SCC2		((uint)0x29 + CPM_IRQ_OFFSET)
+#define	SIU_INT_SCC3		((uint)0x2a + CPM_IRQ_OFFSET)
+#define	SIU_INT_SCC4		((uint)0x2b + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC15		((uint)0x30 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC14		((uint)0x31 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC13		((uint)0x32 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC12		((uint)0x33 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC11		((uint)0x34 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC10		((uint)0x35 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC9		((uint)0x36 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC8		((uint)0x37 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC7		((uint)0x38 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC6		((uint)0x39 + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC5		((uint)0x3a + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC4		((uint)0x3b + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC3		((uint)0x3c + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC2		((uint)0x3d + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC1		((uint)0x3e + CPM_IRQ_OFFSET)
+#define	SIU_INT_PC0		((uint)0x3f + CPM_IRQ_OFFSET)
+
+#endif /* CONFIG_8260 */
+
+#endif /* Whatever way too big #ifdef */
+
+#define NR_MASK_WORDS	((NR_IRQS + 31) / 32)
+/* pedantic: these are long because they are used with set_bit --RR */
+extern unsigned long ppc_cached_irq_mask[NR_MASK_WORDS];
+
+/*
+ * Because many systems have two overlapping names spaces for
+ * interrupts (ISA and XICS for example), and the ISA interrupts
+ * have historically not been easy to renumber, we allow ISA
+ * interrupts to take values 0 - 15, and shift up the remaining
+ * interrupts by 0x10.
+ */
+#define NUM_ISA_INTERRUPTS	0x10
+extern int __irq_offset_value;
+
+static inline int irq_offset_up(int irq)
+{
+	return(irq + __irq_offset_value);
+}
+
+static inline int irq_offset_down(int irq)
+{
+	return(irq - __irq_offset_value);
+}
+
+static inline int irq_offset_value(void)
+{
+	return __irq_offset_value;
+}
+
+#ifdef __DO_IRQ_CANON
+extern int ppc_do_canonicalize_irqs;
+#else
+#define ppc_do_canonicalize_irqs	0
+#endif
+
+static __inline__ int irq_canonicalize(int irq)
+{
+	if (ppc_do_canonicalize_irqs && irq == 2)
+		irq = 9;
+	return irq;
+}
+#endif /* CONFIG_PPC_MERGE */
+
+extern int distribute_irqs;
+
+struct irqaction;
+struct pt_regs;
+
+#define __ARCH_HAS_DO_SOFTIRQ
+
+#if defined(CONFIG_BOOKE) || defined(CONFIG_40x)
+/*
+ * Per-cpu stacks for handling critical, debug and machine check
+ * level interrupts.
+ */
+extern struct thread_info *critirq_ctx[NR_CPUS];
+extern struct thread_info *dbgirq_ctx[NR_CPUS];
+extern struct thread_info *mcheckirq_ctx[NR_CPUS];
+extern void exc_lvl_ctx_init(void);
+#else
+#define exc_lvl_ctx_init()
+#endif
+
+#ifdef CONFIG_IRQSTACKS
+/*
+ * Per-cpu stacks for handling hard and soft interrupts.
+ */
+extern struct thread_info *hardirq_ctx[NR_CPUS];
+extern struct thread_info *softirq_ctx[NR_CPUS];
+
+extern void irq_ctx_init(void);
+extern void call_do_softirq(struct thread_info *tp);
+extern int call_handle_irq(int irq, void *p1,
+			   struct thread_info *tp, void *func);
+#else
+#define irq_ctx_init()
+
+#endif /* CONFIG_IRQSTACKS */
+
+extern void do_IRQ(struct pt_regs *regs);
+
+#endif /* _ASM_IRQ_H */
+#endif /* __KERNEL__ */
