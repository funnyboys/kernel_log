commit b6eca183e23e7a6625a0d2cdb806b7cd1abcd2d2
Author: Leonardo Bras <leonardo@linux.ibm.com>
Date:   Thu Apr 2 16:51:57 2020 -0300

    powerpc/kernel: Enables memory hot-remove after reboot on pseries guests
    
    While providing guests, it's desirable to resize it's memory on demand.
    
    By now, it's possible to do so by creating a guest with a small base
    memory, hot-plugging all the rest, and using 'movable_node' kernel
    command-line parameter, which puts all hot-plugged memory in
    ZONE_MOVABLE, allowing it to be removed whenever needed.
    
    But there is an issue regarding guest reboot:
    If memory is hot-plugged, and then the guest is rebooted, all hot-plugged
    memory goes to ZONE_NORMAL, which offers no guaranteed hot-removal.
    It usually prevents this memory to be hot-removed from the guest.
    
    It's possible to use device-tree information to fix that behavior, as
    it stores flags for LMB ranges on ibm,dynamic-memory-vN.
    It involves marking each memblock with the correct flags as hotpluggable
    memory, which mm/memblock.c puts in ZONE_MOVABLE during boot if
    'movable_node' is passed.
    
    For carrying such information, the new flag DRCONF_MEM_HOTREMOVABLE was
    proposed and accepted into Power Architecture documentation.
    This flag should be:
    - true (b=1) if the hypervisor may want to hot-remove it later, and
    - false (b=0) if it does not care.
    
    During boot, guest kernel reads the device-tree, early_init_drmem_lmb()
    is called for every added LMBs. Here, checking for this new flag and
    marking memblocks as hotplugable memory is enough to get the desirable
    behavior.
    
    This should cause no change if 'movable_node' parameter is not passed
    in kernel command-line.
    
    Signed-off-by: Leonardo Bras <leonardo@linux.ibm.com>
    Reviewed-by: Bharata B Rao <bharata@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20200402195156.626430-1-leonardo@linux.ibm.com

diff --git a/arch/powerpc/include/asm/drmem.h b/arch/powerpc/include/asm/drmem.h
index 28c3d936fdf3..414d209f45bb 100644
--- a/arch/powerpc/include/asm/drmem.h
+++ b/arch/powerpc/include/asm/drmem.h
@@ -65,6 +65,7 @@ struct of_drconf_cell_v2 {
 #define DRCONF_MEM_ASSIGNED	0x00000008
 #define DRCONF_MEM_AI_INVALID	0x00000040
 #define DRCONF_MEM_RESERVED	0x00000080
+#define DRCONF_MEM_HOTREMOVABLE	0x00000100
 
 static inline u32 drmem_lmb_size(void)
 {

commit a83836dbc53e96f13fec248ecc201d18e1e3111d
Author: Libor Pechacek <lpechacek@suse.cz>
Date:   Fri Jan 31 14:28:29 2020 +0100

    powerpc/pseries: Avoid NULL pointer dereference when drmem is unavailable
    
    In guests without hotplugagble memory drmem structure is only zero
    initialized. Trying to manipulate DLPAR parameters results in a crash.
    
      $ echo "memory add count 1" > /sys/kernel/dlpar
      Oops: Kernel access of bad area, sig: 11 [#1]
      LE PAGE_SIZE=64K MMU=Hash SMP NR_CPUS=2048 NUMA pSeries
      ...
      NIP:  c0000000000ff294 LR: c0000000000ff248 CTR: 0000000000000000
      REGS: c0000000fb9d3880 TRAP: 0300   Tainted: G            E      (5.5.0-rc6-2-default)
      MSR:  8000000000009033 <SF,EE,ME,IR,DR,RI,LE>  CR: 28242428  XER: 20000000
      CFAR: c0000000009a6c10 DAR: 0000000000000010 DSISR: 40000000 IRQMASK: 0
      ...
      NIP dlpar_memory+0x6e4/0xd00
      LR  dlpar_memory+0x698/0xd00
      Call Trace:
        dlpar_memory+0x698/0xd00 (unreliable)
        handle_dlpar_errorlog+0xc0/0x190
        dlpar_store+0x198/0x4a0
        kobj_attr_store+0x30/0x50
        sysfs_kf_write+0x64/0x90
        kernfs_fop_write+0x1b0/0x290
        __vfs_write+0x3c/0x70
        vfs_write+0xd0/0x260
        ksys_write+0xdc/0x130
        system_call+0x5c/0x68
    
    Taking closer look at the code, I can see that for_each_drmem_lmb is a
    macro expanding into `for (lmb = &drmem_info->lmbs[0]; lmb <=
    &drmem_info->lmbs[drmem_info->n_lmbs - 1]; lmb++)`. When drmem_info->lmbs
    is NULL, the loop would iterate through the whole address range if it
    weren't stopped by the NULL pointer dereference on the next line.
    
    This patch aligns for_each_drmem_lmb and for_each_drmem_lmb_in_range
    macro behavior with the common C semantics, where the end marker does
    not belong to the scanned range, and alters get_lmb_range() semantics.
    As a side effect, the wraparound observed in the crash is prevented.
    
    Fixes: 6c6ea53725b3 ("powerpc/mm: Separate ibm, dynamic-memory data from DT format")
    Cc: stable@vger.kernel.org # v4.16+
    Signed-off-by: Libor Pechacek <lpechacek@suse.cz>
    Signed-off-by: Michal Suchanek <msuchanek@suse.de>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20200131132829.10281-1-msuchanek@suse.de

diff --git a/arch/powerpc/include/asm/drmem.h b/arch/powerpc/include/asm/drmem.h
index 3d76e1c388c2..28c3d936fdf3 100644
--- a/arch/powerpc/include/asm/drmem.h
+++ b/arch/powerpc/include/asm/drmem.h
@@ -27,12 +27,12 @@ struct drmem_lmb_info {
 extern struct drmem_lmb_info *drmem_info;
 
 #define for_each_drmem_lmb_in_range(lmb, start, end)		\
-	for ((lmb) = (start); (lmb) <= (end); (lmb)++)
+	for ((lmb) = (start); (lmb) < (end); (lmb)++)
 
 #define for_each_drmem_lmb(lmb)					\
 	for_each_drmem_lmb_in_range((lmb),			\
 		&drmem_info->lmbs[0],				\
-		&drmem_info->lmbs[drmem_info->n_lmbs - 1])
+		&drmem_info->lmbs[drmem_info->n_lmbs])
 
 /*
  * The of_drconf_cell_v1 struct defines the layout of the LMB data

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/include/asm/drmem.h b/arch/powerpc/include/asm/drmem.h
index 7f3279b014db..3d76e1c388c2 100644
--- a/arch/powerpc/include/asm/drmem.h
+++ b/arch/powerpc/include/asm/drmem.h
@@ -1,12 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * drmem.h: Power specific logical memory block representation
  *
  * Copyright 2017 IBM Corporation
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 #ifndef _ASM_POWERPC_LMB_H

commit b2d3b5ee66f2a04a918cc043cec0c9ed3de58f40
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Tue Oct 2 10:35:59 2018 -0500

    powerpc/pseries: Track LMB nid instead of using device tree
    
    When removing memory we need to remove the memory from the node
    it was added to instead of looking up the node it should be in
    in the device tree.
    
    During testing we have seen scenarios where the affinity for a
    LMB changes due to a partition migration or PRRN event. In these
    cases the node the LMB exists in may not match the node the device
    tree indicates it belongs in. This can lead to a system crash
    when trying to DLPAR remove the LMB after a migration or PRRN
    event. The current code looks up the node in the device tree to
    remove the LMB from, the crash occurs when we try to offline this
    node and it does not have any data, i.e. node_data[nid] == NULL.
    
    36:mon> e
    cpu 0x36: Vector: 300 (Data Access) at [c0000001828b7810]
        pc: c00000000036d08c: try_offline_node+0x2c/0x1b0
        lr: c0000000003a14ec: remove_memory+0xbc/0x110
        sp: c0000001828b7a90
       msr: 800000000280b033
       dar: 9a28
     dsisr: 40000000
      current = 0xc0000006329c4c80
      paca    = 0xc000000007a55200   softe: 0        irq_happened: 0x01
        pid   = 76926, comm = kworker/u320:3
    
    36:mon> t
    [link register   ] c0000000003a14ec remove_memory+0xbc/0x110
    [c0000001828b7a90] c00000000006a1cc arch_remove_memory+0x9c/0xd0 (unreliable)
    [c0000001828b7ad0] c0000000003a14e0 remove_memory+0xb0/0x110
    [c0000001828b7b20] c0000000000c7db4 dlpar_remove_lmb+0x94/0x160
    [c0000001828b7b60] c0000000000c8ef8 dlpar_memory+0x7e8/0xd10
    [c0000001828b7bf0] c0000000000bf828 handle_dlpar_errorlog+0xf8/0x160
    [c0000001828b7c60] c0000000000bf8cc pseries_hp_work_fn+0x3c/0xa0
    [c0000001828b7c90] c000000000128cd8 process_one_work+0x298/0x5a0
    [c0000001828b7d20] c000000000129068 worker_thread+0x88/0x620
    [c0000001828b7dc0] c00000000013223c kthread+0x1ac/0x1c0
    [c0000001828b7e30] c00000000000b45c ret_from_kernel_thread+0x5c/0x80
    
    To resolve this we need to track the node a LMB belongs to when
    it is added to the system so we can remove it from that node instead
    of the node that the device tree indicates it should belong to.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/drmem.h b/arch/powerpc/include/asm/drmem.h
index 7c1d8e74b25d..7f3279b014db 100644
--- a/arch/powerpc/include/asm/drmem.h
+++ b/arch/powerpc/include/asm/drmem.h
@@ -17,6 +17,9 @@ struct drmem_lmb {
 	u32     drc_index;
 	u32     aa_index;
 	u32     flags;
+#ifdef CONFIG_MEMORY_HOTPLUG
+	int	nid;
+#endif
 };
 
 struct drmem_lmb_info {
@@ -104,4 +107,22 @@ static inline void invalidate_lmb_associativity_index(struct drmem_lmb *lmb)
 	lmb->aa_index = 0xffffffff;
 }
 
+#ifdef CONFIG_MEMORY_HOTPLUG
+static inline void lmb_set_nid(struct drmem_lmb *lmb)
+{
+	lmb->nid = memory_add_physaddr_to_nid(lmb->base_addr);
+}
+static inline void lmb_clear_nid(struct drmem_lmb *lmb)
+{
+	lmb->nid = -1;
+}
+#else
+static inline void lmb_set_nid(struct drmem_lmb *lmb)
+{
+}
+static inline void lmb_clear_nid(struct drmem_lmb *lmb)
+{
+}
+#endif
+
 #endif /* _ASM_POWERPC_LMB_H */

commit 063b8b1251fd069f3740339fca56119d218f11ba
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Fri Apr 20 15:29:48 2018 -0500

    powerpc/pseries/memory-hotplug: Only update DT once per memory DLPAR request
    
    The updates to powerpc numa and memory hotplug code now use the
    in-kernel LMB array instead of the device tree. This change allows the
    pseries memory DLPAR code to only update the device tree once after
    successfully handling a DLPAR request.
    
    Prior to the in-kernel LMB array, the numa code looked up the affinity
    for memory being added in the device tree, the code now looks this up
    in the LMB array. This change means the memory hotplug code can just
    update the affinity for an LMB in the LMB array instead of updating
    the device tree.
    
    This also provides a savings in kernel memory. When updating the
    device tree old properties are never free'ed since there is no
    usecount on properties. This behavior leads to a new copy of the
    property being allocated every time a LMB is added or removed (i.e. a
    request to add 100 LMBs creates 100 new copies of the property). With
    this update only a single new property is created when a DLPAR request
    completes successfully.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/drmem.h b/arch/powerpc/include/asm/drmem.h
index ce242b9ea8c6..7c1d8e74b25d 100644
--- a/arch/powerpc/include/asm/drmem.h
+++ b/arch/powerpc/include/asm/drmem.h
@@ -99,4 +99,9 @@ void __init walk_drmem_lmbs_early(unsigned long node,
 			void (*func)(struct drmem_lmb *, const __be32 **));
 #endif
 
+static inline void invalidate_lmb_associativity_index(struct drmem_lmb *lmb)
+{
+	lmb->aa_index = 0xffffffff;
+}
+
 #endif /* _ASM_POWERPC_LMB_H */

commit 2b31e3aec1dbaae5f0a6f0e485fcb1ff1aceb6cf
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Fri Dec 1 10:47:53 2017 -0600

    powerpc/drmem: Add support for ibm, dynamic-memory-v2 property
    
    The Power Hypervisor has introduced a new device tree format for
    the property describing the dynamic reconfiguration LMBs for a system,
    ibm,dynamic-memory-v2. This new format condenses the size of the
    property, especially on large memory systems, by reporting sets
    of LMBs that have the same properties (flags and associativity array
    index).
    
    This patch updates the powerpc/mm/drmem.c code to provide routines
    that can parse the new device tree format during the walk_drmem_lmb*
    routines used during boot, the creation of the LMB array, and updating
    the device tree to create a new property in the proper format for
    ibm,dynamic-memory-v2.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/drmem.h b/arch/powerpc/include/asm/drmem.h
index 54241456420e..ce242b9ea8c6 100644
--- a/arch/powerpc/include/asm/drmem.h
+++ b/arch/powerpc/include/asm/drmem.h
@@ -50,6 +50,19 @@ struct of_drconf_cell_v1 {
 	__be32	flags;
 };
 
+/*
+ * Version 2 of the ibm,dynamic-memory property is defined as a
+ * 32-bit value specifying the number of LMB sets followed by an
+ * array of of_drconf_cell_v2 entries, one per LMB set.
+ */
+struct of_drconf_cell_v2 {
+	u32	seq_lmbs;
+	u64	base_addr;
+	u32	drc_index;
+	u32	aa_index;
+	u32	flags;
+} __packed;
+
 #define DRCONF_MEM_ASSIGNED	0x00000008
 #define DRCONF_MEM_AI_INVALID	0x00000040
 #define DRCONF_MEM_RESERVED	0x00000080

commit 2c77721552e565e900705f4499067f8d37be3976
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Fri Dec 1 10:47:42 2017 -0600

    powerpc: Move of_drconf_cell struct to asm/drmem.h
    
    Now that the powerpc code parses dynamic reconfiguration memory
    LMB information from the LMB array and not the device tree
    directly we can move the of_drconf_cell struct to drmem.h where
    it fits better.
    
    In addition, the struct is renamed to of_drconf_cell_v1 in
    anticipation of upcoming support for version 2 of the dynamic
    reconfiguration property and the members are typed as __be*
    values to reflect how they exist in the device tree.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/drmem.h b/arch/powerpc/include/asm/drmem.h
index 464e061a6616..54241456420e 100644
--- a/arch/powerpc/include/asm/drmem.h
+++ b/arch/powerpc/include/asm/drmem.h
@@ -35,6 +35,25 @@ extern struct drmem_lmb_info *drmem_info;
 		&drmem_info->lmbs[0],				\
 		&drmem_info->lmbs[drmem_info->n_lmbs - 1])
 
+/*
+ * The of_drconf_cell_v1 struct defines the layout of the LMB data
+ * specified in the ibm,dynamic-memory device tree property.
+ * The property itself is a 32-bit value specifying the number of
+ * LMBs followed by an array of of_drconf_cell_v1 entries, one
+ * per LMB.
+ */
+struct of_drconf_cell_v1 {
+	__be64	base_addr;
+	__be32	drc_index;
+	__be32	reserved;
+	__be32	aa_index;
+	__be32	flags;
+};
+
+#define DRCONF_MEM_ASSIGNED	0x00000008
+#define DRCONF_MEM_AI_INVALID	0x00000040
+#define DRCONF_MEM_RESERVED	0x00000080
+
 static inline u32 drmem_lmb_size(void)
 {
 	return drmem_info->lmb_size;

commit 6195a5001f1d11e1ff6a7e47a865f4b42c1bb28c
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Fri Dec 1 10:47:31 2017 -0600

    powerpc/pseries: Update memory hotplug code to use drmem LMB array
    
    Update the pseries memory hotplug code to use the newly added
    dynamic reconfiguration LMB array. Doing this is required for the
    upcoming support of version 2 of the dynamic reconfiguration
    device tree property.
    
    In addition, making this change cleans up the code that parses the
    LMB information as we no longer need to worry about device tree
    format. This allows us to discard one of the first steps on memory
    hotplug where we make a working copy of the device tree property and
    convert the entire property to cpu format. Instead we just use the
    LMB array directly while holding the memory hotplug lock.
    
    This patch also moves the updating of the device tree property to
    powerpc/mm/drmem.c. This allows to the hotplug code to work without
    needing to know the device tree format and provides a single
    routine for updating the device tree property. This new routine
    will handle determination of the proper device tree format and
    generate a properly formatted device tree property.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/drmem.h b/arch/powerpc/include/asm/drmem.h
index 9dbfd38fa385..464e061a6616 100644
--- a/arch/powerpc/include/asm/drmem.h
+++ b/arch/powerpc/include/asm/drmem.h
@@ -40,9 +40,27 @@ static inline u32 drmem_lmb_size(void)
 	return drmem_info->lmb_size;
 }
 
+#define DRMEM_LMB_RESERVED	0x80000000
+
+static inline void drmem_mark_lmb_reserved(struct drmem_lmb *lmb)
+{
+	lmb->flags |= DRMEM_LMB_RESERVED;
+}
+
+static inline void drmem_remove_lmb_reservation(struct drmem_lmb *lmb)
+{
+	lmb->flags &= ~DRMEM_LMB_RESERVED;
+}
+
+static inline bool drmem_lmb_reserved(struct drmem_lmb *lmb)
+{
+	return lmb->flags & DRMEM_LMB_RESERVED;
+}
+
 u64 drmem_lmb_memory_max(void);
 void __init walk_drmem_lmbs(struct device_node *dn,
 			void (*func)(struct drmem_lmb *, const __be32 **));
+int drmem_update_dt(void);
 
 #ifdef CONFIG_PPC_PSERIES
 void __init walk_drmem_lmbs_early(unsigned long node,

commit 514a9cb3316a08d63063a40a70f11b4318d3c06c
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Fri Dec 1 10:47:21 2017 -0600

    powerpc/numa: Update numa code use walk_drmem_lmbs
    
    Update code in powerpc/numa.c to use the walk_drmem_lmbs()
    routine instead of parsing the device tree directly. This is
    in anticipation of introducing a new ibm,dynamic-memory-v2
    property with a different format. This will allow the numa code
    to use a single initialization routine per-LMB irregardless of
    the device tree format.
    
    Additionally, to support additional routines in numa.c that need
    to look up LMB information, an late_init routine is added to drmem.c
    to allocate the array of LMB information. This LMB array will provide
    per-LMB information to separate the LMB data from the device tree
    format.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/drmem.h b/arch/powerpc/include/asm/drmem.h
index 8b1fe465ec9d..9dbfd38fa385 100644
--- a/arch/powerpc/include/asm/drmem.h
+++ b/arch/powerpc/include/asm/drmem.h
@@ -40,6 +40,10 @@ static inline u32 drmem_lmb_size(void)
 	return drmem_info->lmb_size;
 }
 
+u64 drmem_lmb_memory_max(void);
+void __init walk_drmem_lmbs(struct device_node *dn,
+			void (*func)(struct drmem_lmb *, const __be32 **));
+
 #ifdef CONFIG_PPC_PSERIES
 void __init walk_drmem_lmbs_early(unsigned long node,
 			void (*func)(struct drmem_lmb *, const __be32 **));

commit 6c6ea53725b357fa3deac96d8d2d4ee785b67c6b
Author: Nathan Fontenot <nfont@linux.vnet.ibm.com>
Date:   Fri Dec 1 10:47:08 2017 -0600

    powerpc/mm: Separate ibm, dynamic-memory data from DT format
    
    We currently have code to parse the dynamic reconfiguration LMB
    information from the ibm,dynamic-meory device tree property in
    multiple locations; numa.c, prom.c, and pseries/hotplug-memory.c.
    In anticipation of adding support for a version 2 of the
    ibm,dynamic-memory property this patch aims to separate the device
    tree information from the device tree format.
    
    Doing this requires a two step process to avoid a possibly very large
    bootmem allocation early in boot. During initial boot, new routines
    are provided to walk the device tree property and make a call-back
    for each LMB.
    
    The second step (introduced in later patches) will allocate an
    array of LMB information that can be used directly without needing
    to know the DT format.
    
    This approach provides the benefit of consolidating the device tree
    property parsing to a single location and (eventually) providing
    a common data structure for retrieving LMB information.
    
    This patch introduces a routine to walk the ibm,dynamic-memory
    property in the flattened device tree and updates the prom.c code
    to use this to initialize memory.
    
    Signed-off-by: Nathan Fontenot <nfont@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/drmem.h b/arch/powerpc/include/asm/drmem.h
new file mode 100644
index 000000000000..8b1fe465ec9d
--- /dev/null
+++ b/arch/powerpc/include/asm/drmem.h
@@ -0,0 +1,48 @@
+/*
+ * drmem.h: Power specific logical memory block representation
+ *
+ * Copyright 2017 IBM Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef _ASM_POWERPC_LMB_H
+#define _ASM_POWERPC_LMB_H
+
+struct drmem_lmb {
+	u64     base_addr;
+	u32     drc_index;
+	u32     aa_index;
+	u32     flags;
+};
+
+struct drmem_lmb_info {
+	struct drmem_lmb        *lmbs;
+	int                     n_lmbs;
+	u32                     lmb_size;
+};
+
+extern struct drmem_lmb_info *drmem_info;
+
+#define for_each_drmem_lmb_in_range(lmb, start, end)		\
+	for ((lmb) = (start); (lmb) <= (end); (lmb)++)
+
+#define for_each_drmem_lmb(lmb)					\
+	for_each_drmem_lmb_in_range((lmb),			\
+		&drmem_info->lmbs[0],				\
+		&drmem_info->lmbs[drmem_info->n_lmbs - 1])
+
+static inline u32 drmem_lmb_size(void)
+{
+	return drmem_info->lmb_size;
+}
+
+#ifdef CONFIG_PPC_PSERIES
+void __init walk_drmem_lmbs_early(unsigned long node,
+			void (*func)(struct drmem_lmb *, const __be32 **));
+#endif
+
+#endif /* _ASM_POWERPC_LMB_H */
