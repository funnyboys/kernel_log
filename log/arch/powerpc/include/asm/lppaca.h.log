commit 192f0f8e9db7efe4ac98d47f5fa4334e43c1204d
Merge: ec9249752465 f5a9e488d623
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 13 16:08:36 2019 -0700

    Merge tag 'powerpc-5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux
    
    Pull powerpc updates from Michael Ellerman:
     "Notable changes:
    
       - Removal of the NPU DMA code, used by the out-of-tree Nvidia driver,
         as well as some other functions only used by drivers that haven't
         (yet?) made it upstream.
    
       - A fix for a bug in our handling of hardware watchpoints (eg. perf
         record -e mem: ...) which could lead to register corruption and
         kernel crashes.
    
       - Enable HAVE_ARCH_HUGE_VMAP, which allows us to use large pages for
         vmalloc when using the Radix MMU.
    
       - A large but incremental rewrite of our exception handling code to
         use gas macros rather than multiple levels of nested CPP macros.
    
      And the usual small fixes, cleanups and improvements.
    
      Thanks to: Alastair D'Silva, Alexey Kardashevskiy, Andreas Schwab,
      Aneesh Kumar K.V, Anju T Sudhakar, Anton Blanchard, Arnd Bergmann,
      Athira Rajeev, CÃ©dric Le Goater, Christian Lamparter, Christophe
      Leroy, Christophe Lombard, Christoph Hellwig, Daniel Axtens, Denis
      Efremov, Enrico Weigelt, Frederic Barrat, Gautham R. Shenoy, Geert
      Uytterhoeven, Geliang Tang, Gen Zhang, Greg Kroah-Hartman, Greg Kurz,
      Gustavo Romero, Krzysztof Kozlowski, Madhavan Srinivasan, Masahiro
      Yamada, Mathieu Malaterre, Michael Neuling, Nathan Lynch, Naveen N.
      Rao, Nicholas Piggin, Nishad Kamdar, Oliver O'Halloran, Qian Cai, Ravi
      Bangoria, Sachin Sant, Sam Bobroff, Satheesh Rajendran, Segher
      Boessenkool, Shaokun Zhang, Shawn Anastasio, Stewart Smith, Suraj
      Jitindar Singh, Thiago Jung Bauermann, YueHaibing"
    
    * tag 'powerpc-5.3-1' of git://git.kernel.org/pub/scm/linux/kernel/git/powerpc/linux: (163 commits)
      powerpc/powernv/idle: Fix restore of SPRN_LDBAR for POWER9 stop state.
      powerpc/eeh: Handle hugepages in ioremap space
      ocxl: Update for AFU descriptor template version 1.1
      powerpc/boot: pass CONFIG options in a simpler and more robust way
      powerpc/boot: add {get, put}_unaligned_be32 to xz_config.h
      powerpc/irq: Don't WARN continuously in arch_local_irq_restore()
      powerpc/module64: Use symbolic instructions names.
      powerpc/module32: Use symbolic instructions names.
      powerpc: Move PPC_HA() PPC_HI() and PPC_LO() to ppc-opcode.h
      powerpc/module64: Fix comment in R_PPC64_ENTRY handling
      powerpc/boot: Add lzo support for uImage
      powerpc/boot: Add lzma support for uImage
      powerpc/boot: don't force gzipped uImage
      powerpc/8xx: Add microcode patch to move SMC parameter RAM.
      powerpc/8xx: Use IO accessors in microcode programming.
      powerpc/8xx: replace #ifdefs by IS_ENABLED() in microcode.c
      powerpc/8xx: refactor programming of microcode CPM params.
      powerpc/8xx: refactor printing of microcode patch name.
      powerpc/8xx: Refactor microcode write
      powerpc/8xx: refactor writing of CPM microcode arrays
      ...

commit 18a593c8b5426f6a08bcb353636d761a83f78d9e
Author: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
Date:   Wed Jul 3 22:34:01 2019 +0530

    powerpc/pseries: Protect against hogging the cpu while setting up the stats
    
    When enabling or disabling the vcpu dispatch statistics, we do a lot of
    work including allocating/deallocating memory across all possible cpus
    for the DTL buffer. In order to guard against hogging the cpu for too
    long, track the time we're taking and yield the processor if necessary.
    
    Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index f5195b4d9ffb..d7952665945a 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -201,7 +201,7 @@ extern rwlock_t dtl_access_lock;
 extern void (*dtl_consumer)(struct dtl_entry *entry, u64 index);
 
 extern void register_dtl_buffer(int cpu);
-extern void alloc_dtl_buffers(void);
+extern void alloc_dtl_buffers(unsigned long *time_limit);
 extern long hcall_vphn(unsigned long cpu, u64 flags, __be32 *associativity);
 
 #endif /* CONFIG_PPC_BOOK3S */

commit 5a1ea4774ddc2c6bc3ba1415880091eccf1a901e
Author: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
Date:   Wed Jul 3 22:33:59 2019 +0530

    powerpc/pseries: Move mm/book3s64/vphn.c under platforms/pseries/
    
    hcall_vphn() is specific to pseries and will be used in a subsequent
    patch. So, move it to a more appropriate place under
    arch/powerpc/platforms/pseries. Also merge vphn.h into lppaca.h
    and update vphn selftest to use the new files.
    
    Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index e45b7293414d..f5195b4d9ffb 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -18,6 +18,29 @@
  */
 #ifndef _ASM_POWERPC_LPPACA_H
 #define _ASM_POWERPC_LPPACA_H
+
+/*
+ * The below VPHN macros are outside the __KERNEL__ check since these are
+ * used for compiling the vphn selftest in userspace
+ */
+
+/* The H_HOME_NODE_ASSOCIATIVITY h_call returns 6 64-bit registers. */
+#define VPHN_REGISTER_COUNT 6
+
+/*
+ * 6 64-bit registers unpacked into up to 24 be32 associativity values. To
+ * form the complete property we have to add the length in the first cell.
+ */
+#define VPHN_ASSOC_BUFSIZE (VPHN_REGISTER_COUNT*sizeof(u64)/sizeof(u16) + 1)
+
+/*
+ * The H_HOME_NODE_ASSOCIATIVITY hcall takes two values for flags:
+ * 1 for retrieving associativity information for a guest cpu
+ * 2 for retrieving associativity information for a host/hypervisor cpu
+ */
+#define VPHN_FLAG_VCPU	1
+#define VPHN_FLAG_PCPU	2
+
 #ifdef __KERNEL__
 
 /*
@@ -179,6 +202,7 @@ extern void (*dtl_consumer)(struct dtl_entry *entry, u64 index);
 
 extern void register_dtl_buffer(int cpu);
 extern void alloc_dtl_buffers(void);
+extern long hcall_vphn(unsigned long cpu, u64 flags, __be32 *associativity);
 
 #endif /* CONFIG_PPC_BOOK3S */
 #endif /* __KERNEL__ */

commit 06220d78f24a20549757be1014e57c382406cc92
Author: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
Date:   Wed Jul 3 22:33:57 2019 +0530

    powerpc/pseries: Introduce rwlock to gatekeep DTLB usage
    
    Since we would be introducing a new user of the DTL buffer in a
    subsequent patch, we need a way to gatekeep use of the DTL buffer.
    
    The current debugfs interface for DTL allows registering and opening
    cpu-specific DTL buffers. Cpu specific files are exposed under
    debugfs 'powerpc/dtl/' node, and changing 'dtl_event_mask' in the same
    directory enables controlling the event mask used when registering DTL
    buffer for a particular cpu.
    
    Subsequently, we will be introducing a user of the DTL buffers that
    registers access to the DTL buffers across all cpus with the same event
    mask. To ensure these two users do not step on each other, we introduce
    a rwlock to gatekeep DTL buffer access. This fits the requirement of the
    current debugfs interface wanting to allow multiple independent
    cpu-specific users (read lock), and the subsequent user wanting
    exclusive access (write lock).
    
    Suggested-by: Michael Ellerman <mpe@ellerman.id.au>
    Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index a8ac2b8988d4..e45b7293414d 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -32,6 +32,7 @@
  */
 #include <linux/cache.h>
 #include <linux/threads.h>
+#include <linux/spinlock_types.h>
 #include <asm/types.h>
 #include <asm/mmu.h>
 #include <asm/firmware.h>
@@ -166,6 +167,7 @@ struct dtl_entry {
 #define DTL_LOG_ALL		(DTL_LOG_CEDE | DTL_LOG_PREEMPT | DTL_LOG_FAULT)
 
 extern struct kmem_cache *dtl_cache;
+extern rwlock_t dtl_access_lock;
 
 /*
  * When CONFIG_VIRT_CPU_ACCOUNTING_NATIVE = y, the cpu accounting code controls

commit 1c85a2a1945cbafcd2e7cebc6e23d0e206aeda3d
Author: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
Date:   Wed Jul 3 22:33:56 2019 +0530

    powerpc/pseries: Factor out DTL buffer allocation and registration routines
    
    Introduce new helpers for DTL buffer allocation and registration and
    have the existing code use those.
    
    Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    [mpe: Don't split error messages across lines, for grepability]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 2c7e31187726..a8ac2b8988d4 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -175,6 +175,9 @@ extern struct kmem_cache *dtl_cache;
  */
 extern void (*dtl_consumer)(struct dtl_entry *entry, u64 index);
 
+extern void register_dtl_buffer(int cpu);
+extern void alloc_dtl_buffers(void);
+
 #endif /* CONFIG_PPC_BOOK3S */
 #endif /* __KERNEL__ */
 #endif /* _ASM_POWERPC_LPPACA_H */

commit 515bbc8ab488e4bc16fe26df097502c04d3649d4
Author: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
Date:   Wed Jul 3 22:33:54 2019 +0530

    powerpc/pseries: Use macros for referring to the DTL enable mask
    
    Introduce macros to encode the DTL enable mask fields and use those
    instead of hardcoding numbers.
    
    Acked-by: Nathan Lynch <nathanl@linux.ibm.com>
    Signed-off-by: Naveen N. Rao <naveen.n.rao@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 7c23ce8a5a4c..2c7e31187726 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -154,6 +154,17 @@ struct dtl_entry {
 #define DISPATCH_LOG_BYTES	4096	/* bytes per cpu */
 #define N_DISPATCH_LOG		(DISPATCH_LOG_BYTES / sizeof(struct dtl_entry))
 
+/*
+ * Dispatch trace log event enable mask:
+ *   0x1: voluntary virtual processor waits
+ *   0x2: time-slice preempts
+ *   0x4: virtual partition memory page faults
+ */
+#define DTL_LOG_CEDE		0x1
+#define DTL_LOG_PREEMPT		0x2
+#define DTL_LOG_FAULT		0x4
+#define DTL_LOG_ALL		(DTL_LOG_CEDE | DTL_LOG_PREEMPT | DTL_LOG_FAULT)
+
 extern struct kmem_cache *dtl_cache;
 
 /*

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 7c23ce8a5a4c..806494283e2a 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -1,20 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * lppaca.h
  * Copyright (C) 2001  Mike Corrigan IBM Corporation
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
  */
 #ifndef _ASM_POWERPC_LPPACA_H
 #define _ASM_POWERPC_LPPACA_H

commit a6201da34ff9366680e97392efd06abb9ff15014
Author: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
Date:   Mon Apr 2 13:03:37 2018 +0530

    powerpc: Fix oops due to bad access of lppaca on bare metal
    
    Commit 8e0b634b1327 ("powerpc/64s: Do not allocate lppaca if we are
    not virtualized") removed allocation of lppaca on bare metal
    platforms. But with CONFIG_PPC_SPLPAR enabled, we still access the
    lppaca on bare metal in some code paths.
    
    Fix this but adding runtime checks for SPLPAR (shared processor LPAR).
    
    Fixes: 8e0b634b1327 ("powerpc/64s: Do not allocate lppaca if we are not virtualized")
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 65d589689f01..7c23ce8a5a4c 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -34,6 +34,7 @@
 #include <linux/threads.h>
 #include <asm/types.h>
 #include <asm/mmu.h>
+#include <asm/firmware.h>
 
 /*
  * The lppaca is the "virtual processor area" registered with the hypervisor,
@@ -114,6 +115,8 @@ struct lppaca {
 
 static inline bool lppaca_shared_proc(struct lppaca *l)
 {
+	if (!firmware_has_feature(FW_FEATURE_SPLPAR))
+		return false;
 	return !!(l->__old_status & LPPACA_OLD_SHARED_PROC);
 }
 

commit 499dcd41378ebab2a37a0df65735748d66e75599
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Feb 14 01:08:13 2018 +1000

    powerpc/64s: Allocate LPPACAs individually
    
    We no longer allocate lppacas in an array, so this patch removes the
    1kB static alignment for the structure, and enforces the PAPR
    alignment requirements at allocation time. We can not reduce the 1kB
    allocation size however, due to existing KVM hypervisors.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 6e4589eee2da..65d589689f01 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -36,14 +36,16 @@
 #include <asm/mmu.h>
 
 /*
- * We only have to have statically allocated lppaca structs on
- * legacy iSeries, which supports at most 64 cpus.
- */
-#define NR_LPPACAS	1
-
-/*
- * The Hypervisor barfs if the lppaca crosses a page boundary.  A 1k
- * alignment is sufficient to prevent this
+ * The lppaca is the "virtual processor area" registered with the hypervisor,
+ * H_REGISTER_VPA etc.
+ *
+ * According to PAPR, the structure is 640 bytes long, must be L1 cache line
+ * aligned, and must not cross a 4kB boundary. Its size field must be at
+ * least 640 bytes (but may be more).
+ *
+ * Pre-v4.14 KVM hypervisors reject the VPA if its size field is smaller than
+ * 1kB, so we dynamically allocate 1kB and advertise size as 1kB, but keep
+ * this structure as the canonical 640 byte size.
  */
 struct lppaca {
 	/* cacheline 1 contains read-only data */
@@ -97,11 +99,9 @@ struct lppaca {
 
 	__be32	page_ins;		/* CMO Hint - # page ins by OS */
 	u8	reserved11[148];
-	volatile __be64 dtl_idx;		/* Dispatch Trace Log head index */
+	volatile __be64 dtl_idx;	/* Dispatch Trace Log head index */
 	u8	reserved12[96];
-} __attribute__((__aligned__(0x400)));
-
-extern struct lppaca lppaca[];
+} ____cacheline_aligned;
 
 #define lppaca_of(cpu)	(*paca_ptrs[cpu]->lppaca_ptr)
 

commit d2e60075a3d4422dc54b919f3b125d8066b839d4
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Feb 14 01:08:12 2018 +1000

    powerpc/64: Use array of paca pointers and allocate pacas individually
    
    Change the paca array into an array of pointers to pacas. Allocate
    pacas individually.
    
    This allows flexibility in where the PACAs are allocated. Future work
    will allocate them node-local. Platforms that don't have address limits
    on PACAs would be able to defer PACA allocations until later in boot
    rather than allocate all possible ones up-front then freeing unused.
    
    This is slightly more overhead (one additional indirection) for cross
    CPU paca references, but those aren't too common.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index d0a2a2f99564..6e4589eee2da 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -103,7 +103,7 @@ struct lppaca {
 
 extern struct lppaca lppaca[];
 
-#define lppaca_of(cpu)	(*paca[cpu].lppaca_ptr)
+#define lppaca_of(cpu)	(*paca_ptrs[cpu]->lppaca_ptr)
 
 /*
  * We are using a non architected field to determine if a partition is

commit 1a8f6f97ea4dbaaa21b05cae2dacea47e4aea37b
Author: Jeremy Kerr <jk@ozlabs.org>
Date:   Thu Dec 5 11:31:08 2013 +0800

    powerpc: Make slb_shadow a local
    
    The only external user of slb_shadow is the pseries lpar code, and it
    can access through the paca array instead.
    
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 844c28de7ec0..d0a2a2f99564 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -132,8 +132,6 @@ struct slb_shadow {
 	} save_area[SLB_NUM_BOLTED];
 } ____cacheline_aligned;
 
-extern struct slb_shadow slb_shadow[];
-
 /*
  * Layout of entries in the hypervisor's dispatch trace log buffer.
  */

commit 733187e29576041ceccf3b82092ca900fc929170
Author: Anton Blanchard <anton@samba.org>
Date:   Sun Oct 20 10:26:20 2013 +1100

    powerpc/pseries: Fix dedicated processor partition detection
    
    commit f13c13a00512 (powerpc: Stop using non-architected shared_proc
    field in lppaca) fixed a potential issue with shared/dedicated
    partition detection. The old method of detection relied on an
    unarchitected field (shared_proc), and this patch switched
    to using something architected (a non zero yield_count).
    
    Unfortunately the assertion in the Linux header that yield_count
    is only non zero on shared processor partitions is not true. It
    turns out dedicated processor partitions can increment yield_count
    and as such we falsely detect dedicated partitions as shared.
    
    Fix the comment, and switch back to using the old method.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 4470d1e34d23..844c28de7ec0 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -84,8 +84,8 @@ struct lppaca {
 	 * the processor is yielded (either because of an OS yield or a
 	 * hypervisor preempt).  An even value implies that the processor is
 	 * currently executing.
-	 * NOTE: This value will ALWAYS be zero for dedicated processors and
-	 * will NEVER be zero for shared processors (ie, initialized to a 1).
+	 * NOTE: Even dedicated processor partitions can yield so this
+	 * field cannot be used to determine if we are shared or dedicated.
 	 */
 	volatile __be32 yield_count;
 	volatile __be32 dispersion_count; /* dispatch changed physical cpu */
@@ -106,15 +106,15 @@ extern struct lppaca lppaca[];
 #define lppaca_of(cpu)	(*paca[cpu].lppaca_ptr)
 
 /*
- * Old kernels used a reserved bit in the VPA to determine if it was running
- * in shared processor mode. New kernels look for a non zero yield count
- * but KVM still needs to set the bit to keep the old stuff happy.
+ * We are using a non architected field to determine if a partition is
+ * shared or dedicated. This currently works on both KVM and PHYP, but
+ * we will have to transition to something better.
  */
 #define LPPACA_OLD_SHARED_PROC		2
 
 static inline bool lppaca_shared_proc(struct lppaca *l)
 {
-	return l->yield_count != 0;
+	return !!(l->__old_status & LPPACA_OLD_SHARED_PROC);
 }
 
 /*

commit c72cd555e828b710bce8c3635254dbb483397142
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Aug 7 02:01:45 2013 +1000

    powerpc: Add endian annotations to lppaca, slb_shadow and dtl_entry
    
    Add endian annotation to various hypervisor structures which
    are defined as big endian.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index bc8def08d5d8..4470d1e34d23 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -48,13 +48,13 @@
 struct lppaca {
 	/* cacheline 1 contains read-only data */
 
-	u32	desc;			/* Eye catcher 0xD397D781 */
-	u16	size;			/* Size of this struct */
+	__be32	desc;			/* Eye catcher 0xD397D781 */
+	__be16	size;			/* Size of this struct */
 	u8	reserved1[3];
 	u8	__old_status;		/* Old status, including shared proc */
 	u8	reserved3[14];
-	volatile u32 dyn_hw_node_id;	/* Dynamic hardware node id */
-	volatile u32 dyn_hw_proc_id;	/* Dynamic hardware proc id */
+	volatile __be32 dyn_hw_node_id;	/* Dynamic hardware node id */
+	volatile __be32 dyn_hw_proc_id;	/* Dynamic hardware proc id */
 	u8	reserved4[56];
 	volatile u8 vphn_assoc_counts[8]; /* Virtual processor home node */
 					  /* associativity change counters */
@@ -71,9 +71,9 @@ struct lppaca {
 	u8	fpregs_in_use;
 	u8	pmcregs_in_use;
 	u8	reserved8[28];
-	u64	wait_state_cycles;	/* Wait cycles for this proc */
+	__be64	wait_state_cycles;	/* Wait cycles for this proc */
 	u8	reserved9[28];
-	u16	slb_count;		/* # of SLBs to maintain */
+	__be16	slb_count;		/* # of SLBs to maintain */
 	u8	idle;			/* Indicate OS is idle */
 	u8	vmxregs_in_use;
 
@@ -87,17 +87,17 @@ struct lppaca {
 	 * NOTE: This value will ALWAYS be zero for dedicated processors and
 	 * will NEVER be zero for shared processors (ie, initialized to a 1).
 	 */
-	volatile u32 yield_count;
-	volatile u32 dispersion_count;	/* dispatch changed physical cpu */
-	volatile u64 cmo_faults;	/* CMO page fault count */
-	volatile u64 cmo_fault_time;	/* CMO page fault time */
+	volatile __be32 yield_count;
+	volatile __be32 dispersion_count; /* dispatch changed physical cpu */
+	volatile __be64 cmo_faults;	/* CMO page fault count */
+	volatile __be64 cmo_fault_time;	/* CMO page fault time */
 	u8	reserved10[104];
 
 	/* cacheline 4-5 */
 
-	u32	page_ins;		/* CMO Hint - # page ins by OS */
+	__be32	page_ins;		/* CMO Hint - # page ins by OS */
 	u8	reserved11[148];
-	volatile u64 dtl_idx;		/* Dispatch Trace Log head index */
+	volatile __be64 dtl_idx;		/* Dispatch Trace Log head index */
 	u8	reserved12[96];
 } __attribute__((__aligned__(0x400)));
 
@@ -123,12 +123,12 @@ static inline bool lppaca_shared_proc(struct lppaca *l)
  * ESID is stored in the lower 64bits, then the VSID.
  */
 struct slb_shadow {
-	u32	persistent;		/* Number of persistent SLBs */
-	u32	buffer_length;		/* Total shadow buffer length */
-	u64	reserved;
+	__be32	persistent;		/* Number of persistent SLBs */
+	__be32	buffer_length;		/* Total shadow buffer length */
+	__be64	reserved;
 	struct	{
-		u64     esid;
-		u64	vsid;
+		__be64     esid;
+		__be64	vsid;
 	} save_area[SLB_NUM_BOLTED];
 } ____cacheline_aligned;
 
@@ -140,14 +140,14 @@ extern struct slb_shadow slb_shadow[];
 struct dtl_entry {
 	u8	dispatch_reason;
 	u8	preempt_reason;
-	u16	processor_id;
-	u32	enqueue_to_dispatch_time;
-	u32	ready_to_enqueue_time;
-	u32	waiting_to_ready_time;
-	u64	timebase;
-	u64	fault_addr;
-	u64	srr0;
-	u64	srr1;
+	__be16	processor_id;
+	__be32	enqueue_to_dispatch_time;
+	__be32	ready_to_enqueue_time;
+	__be32	waiting_to_ready_time;
+	__be64	timebase;
+	__be64	fault_addr;
+	__be64	srr0;
+	__be64	srr1;
 };
 
 #define DISPATCH_LOG_BYTES	4096	/* bytes per cpu */

commit f13c13a005127b5dc5daaca190277a062d946e63
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Aug 7 02:01:26 2013 +1000

    powerpc: Stop using non-architected shared_proc field in lppaca
    
    Although the shared_proc field in the lppaca works today, it is
    not architected. A shared processor partition will always have a non
    zero yield_count so use that instead. Create a wrapper so users
    don't have to know about the details.
    
    In order for older kernels to continue to work on KVM we need
    to set the shared_proc bit. While here, remove the ugly bitfield.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 9b12f88d4adb..bc8def08d5d8 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -50,10 +50,8 @@ struct lppaca {
 
 	u32	desc;			/* Eye catcher 0xD397D781 */
 	u16	size;			/* Size of this struct */
-	u16	reserved1;
-	u16	reserved2:14;
-	u8	shared_proc:1;		/* Shared processor indicator */
-	u8	secondary_thread:1;	/* Secondary thread indicator */
+	u8	reserved1[3];
+	u8	__old_status;		/* Old status, including shared proc */
 	u8	reserved3[14];
 	volatile u32 dyn_hw_node_id;	/* Dynamic hardware node id */
 	volatile u32 dyn_hw_proc_id;	/* Dynamic hardware proc id */
@@ -107,6 +105,18 @@ extern struct lppaca lppaca[];
 
 #define lppaca_of(cpu)	(*paca[cpu].lppaca_ptr)
 
+/*
+ * Old kernels used a reserved bit in the VPA to determine if it was running
+ * in shared processor mode. New kernels look for a non zero yield count
+ * but KVM still needs to set the bit to keep the old stuff happy.
+ */
+#define LPPACA_OLD_SHARED_PROC		2
+
+static inline bool lppaca_shared_proc(struct lppaca *l)
+{
+	return l->yield_count != 0;
+}
+
 /*
  * SLB shadow buffer structure as defined in the PAPR.  The save_area
  * contains adjacent ESID and VSID pairs for each shadowed SLB.  The

commit 6e0b8bc965d25a8e0701eaca3fca5941b4f4b2b2
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Fri Jun 28 18:15:18 2013 +1000

    powerpc/pseries: Inform the hypervisor we are using EBB regs
    
    On LPAR systems we need to inform the hypervisor that we are using the
    EBB registers. We do this by setting a bit in the Virtual Processor Area
    (VPA) - formerly known as the lppaca.
    
    For now we do this always, ie. we do not dynamically enable/disable.
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index b1e7f2af1016..9b12f88d4adb 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -66,7 +66,8 @@ struct lppaca {
 
 	u8	reserved6[48];
 	u8	cede_latency_hint;
-	u8	reserved7[7];
+	u8	ebb_regs_in_use;
+	u8	reserved7[6];
 	u8	dtl_enable_mask;	/* Dispatch Trace Log mask */
 	u8	donate_dedicated_cpu;	/* Donate dedicated CPU cycles */
 	u8	fpregs_in_use;

commit abf917cd91cbb73952758f9741e2fa65002a48ee
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Wed Jul 25 07:56:04 2012 +0200

    cputime: Generic on-demand virtual cputime accounting
    
    If we want to stop the tick further idle, we need to be
    able to account the cputime without using the tick.
    
    Virtual based cputime accounting solves that problem by
    hooking into kernel/user boundaries.
    
    However implementing CONFIG_VIRT_CPU_ACCOUNTING require
    low level hooks and involves more overhead. But we already
    have a generic context tracking subsystem that is required
    for RCU needs by archs which plan to shut down the tick
    outside idle.
    
    This patch implements a generic virtual based cputime
    accounting that relies on these generic kernel/user hooks.
    
    There are some upsides of doing this:
    
    - This requires no arch code to implement CONFIG_VIRT_CPU_ACCOUNTING
    if context tracking is already built (already necessary for RCU in full
    tickless mode).
    
    - We can rely on the generic context tracking subsystem to dynamically
    (de)activate the hooks, so that we can switch anytime between virtual
    and tick based accounting. This way we don't have the overhead
    of the virtual accounting when the tick is running periodically.
    
    And one downside:
    
    - There is probably more overhead than a native virtual based cputime
    accounting. But this relies on hooks that are already set anyway.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Li Zhong <zhong@linux.vnet.ibm.com>
    Cc: Namhyung Kim <namhyung.kim@lge.com>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 531fe0c3108f..b1e7f2af1016 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -145,7 +145,7 @@ struct dtl_entry {
 extern struct kmem_cache *dtl_cache;
 
 /*
- * When CONFIG_VIRT_CPU_ACCOUNTING = y, the cpu accounting code controls
+ * When CONFIG_VIRT_CPU_ACCOUNTING_NATIVE = y, the cpu accounting code controls
  * reading from the dispatch trace log.  If other code wants to consume
  * DTL entries, it can set this pointer to a function that will get
  * called once for each DTL entry that gets processed.

commit 59c19cb2f6a7928a2fd3afd22bfe988e025b41d8
Author: Anton Blanchard <anton@samba.org>
Date:   Tue Apr 10 16:22:53 2012 +0000

    powerpc: Reformat lppaca.h
    
    Reformat lppaca.h to match Linux coding standards.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 06effe61a0de..531fe0c3108f 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -20,18 +20,16 @@
 #define _ASM_POWERPC_LPPACA_H
 #ifdef __KERNEL__
 
-/* These definitions relate to hypervisors that only exist when using
+/*
+ * These definitions relate to hypervisors that only exist when using
  * a server type processor
  */
 #ifdef CONFIG_PPC_BOOK3S
 
-//=============================================================================
-//
-//	This control block contains the data that is shared between the
-//	hypervisor and the OS.
-//
-//
-//----------------------------------------------------------------------------
+/*
+ * This control block contains the data that is shared between the
+ * hypervisor and the OS.
+ */
 #include <linux/cache.h>
 #include <linux/threads.h>
 #include <asm/types.h>
@@ -43,67 +41,65 @@
  */
 #define NR_LPPACAS	1
 
-
-/* The Hypervisor barfs if the lppaca crosses a page boundary.  A 1k
- * alignment is sufficient to prevent this */
+/*
+ * The Hypervisor barfs if the lppaca crosses a page boundary.  A 1k
+ * alignment is sufficient to prevent this
+ */
 struct lppaca {
-//=============================================================================
-// CACHE_LINE_1 0x0000 - 0x007F Contains read-only data
-//=============================================================================
-	u32	desc;			// Eye catcher 0xD397D781	x00-x03
-	u16	size;			// Size of this struct		x04-x05
-	u16	reserved1;		// Reserved			x06-x07
-	u16	reserved2:14;		// Reserved			x08-x09
-	u8	shared_proc:1;		// Shared processor indicator	...
-	u8	secondary_thread:1;	// Secondary thread indicator	...
-	u8	reserved3[14];		//				x0A-x17
-	volatile u32 dyn_hw_node_id;	// Dynamic Hardware Node id	x18-x1B
-	volatile u32 dyn_hw_proc_id;	// Dynamic Hardware Proc Id	x1C-x1F
-	u8	reserved4[56];		// Reserved			x20-x57
-	volatile u8 vphn_assoc_counts[8]; // Virtual processor home node
-					// associativity change counters x58-x5F
-	u8	reserved5[32];		// Reserved			x60-x7F
-
-//=============================================================================
-// CACHE_LINE_2 0x0080 - 0x00FF Contains local read-write data
-//=============================================================================
-
-	u8	reserved6[48];		//				x00-x2f
-	u8	cede_latency_hint;	/*				x30 */
-	u8	reserved7[7];		/*			    x31-x37 */
-	u8	dtl_enable_mask;	// Dispatch Trace Log mask	x38-x38
-	u8	donate_dedicated_cpu;	// Donate dedicated CPU cycles  x39-x39
-	u8	fpregs_in_use;		// FP regs in use               x3A-x3A
-	u8	pmcregs_in_use;		// PMC regs in use              x3B-x3B
-	u8	reserved8[28];		//				x3C-x57
-	u64	wait_state_cycles;	// Wait cycles for this proc    x58-x5F
-	u8	reserved9[28];		//				x60-x7B
-	u16	slb_count;		// # of SLBs to maintain        x7C-x7D
-	u8	idle;			// Indicate OS is idle          x7E
-	u8	vmxregs_in_use;		// VMX registers in use         x7F
-
-//=============================================================================
-// CACHE_LINE_3 0x0100 - 0x017F: This line is shared with other processors
-//=============================================================================
-	// This is the yield_count.  An "odd" value (low bit on) means that
-	// the processor is yielded (either because of an OS yield or a PLIC
-	// preempt).  An even value implies that the processor is currently
-	// executing.
-	// NOTE: This value will ALWAYS be zero for dedicated processors and
-	// will NEVER be zero for shared processors (ie, initialized to a 1).
-	volatile u32 yield_count;	// PLIC increments each dispatchx00-x03
-	volatile u32 dispersion_count;	// dispatch changed phys cpu    x04-x07
-	volatile u64 cmo_faults;	// CMO page fault count         x08-x0F
-	volatile u64 cmo_fault_time;	// CMO page fault time          x10-x17
-	u8	reserved10[104];		// Reserved                     x18-x7F
-
-//=============================================================================
-// CACHE_LINE_4-5 0x0180 - 0x027F Contains PMC interrupt data
-//=============================================================================
-	u32	page_ins;		// CMO Hint - # page ins by OS  x00-x03
-	u8	reserved11[148];		// Reserved                     x04-x97
-	volatile u64 dtl_idx;		// Dispatch Trace Log head idx	x98-x9F
-	u8	reserved12[96];		// Reserved                     xA0-xFF
+	/* cacheline 1 contains read-only data */
+
+	u32	desc;			/* Eye catcher 0xD397D781 */
+	u16	size;			/* Size of this struct */
+	u16	reserved1;
+	u16	reserved2:14;
+	u8	shared_proc:1;		/* Shared processor indicator */
+	u8	secondary_thread:1;	/* Secondary thread indicator */
+	u8	reserved3[14];
+	volatile u32 dyn_hw_node_id;	/* Dynamic hardware node id */
+	volatile u32 dyn_hw_proc_id;	/* Dynamic hardware proc id */
+	u8	reserved4[56];
+	volatile u8 vphn_assoc_counts[8]; /* Virtual processor home node */
+					  /* associativity change counters */
+	u8	reserved5[32];
+
+	/* cacheline 2 contains local read-write data */
+
+	u8	reserved6[48];
+	u8	cede_latency_hint;
+	u8	reserved7[7];
+	u8	dtl_enable_mask;	/* Dispatch Trace Log mask */
+	u8	donate_dedicated_cpu;	/* Donate dedicated CPU cycles */
+	u8	fpregs_in_use;
+	u8	pmcregs_in_use;
+	u8	reserved8[28];
+	u64	wait_state_cycles;	/* Wait cycles for this proc */
+	u8	reserved9[28];
+	u16	slb_count;		/* # of SLBs to maintain */
+	u8	idle;			/* Indicate OS is idle */
+	u8	vmxregs_in_use;
+
+	/* cacheline 3 is shared with other processors */
+
+	/*
+	 * This is the yield_count.  An "odd" value (low bit on) means that
+	 * the processor is yielded (either because of an OS yield or a
+	 * hypervisor preempt).  An even value implies that the processor is
+	 * currently executing.
+	 * NOTE: This value will ALWAYS be zero for dedicated processors and
+	 * will NEVER be zero for shared processors (ie, initialized to a 1).
+	 */
+	volatile u32 yield_count;
+	volatile u32 dispersion_count;	/* dispatch changed physical cpu */
+	volatile u64 cmo_faults;	/* CMO page fault count */
+	volatile u64 cmo_fault_time;	/* CMO page fault time */
+	u8	reserved10[104];
+
+	/* cacheline 4-5 */
+
+	u32	page_ins;		/* CMO Hint - # page ins by OS */
+	u8	reserved11[148];
+	volatile u64 dtl_idx;		/* Dispatch Trace Log head index */
+	u8	reserved12[96];
 } __attribute__((__aligned__(0x400)));
 
 extern struct lppaca lppaca[];
@@ -116,13 +112,13 @@ extern struct lppaca lppaca[];
  * ESID is stored in the lower 64bits, then the VSID.
  */
 struct slb_shadow {
-	u32	persistent;		// Number of persistent SLBs	x00-x03
-	u32	buffer_length;		// Total shadow buffer length	x04-x07
-	u64	reserved;		// Alignment			x08-x0f
+	u32	persistent;		/* Number of persistent SLBs */
+	u32	buffer_length;		/* Total shadow buffer length */
+	u64	reserved;
 	struct	{
 		u64     esid;
 		u64	vsid;
-	} save_area[SLB_NUM_BOLTED];	//				x10-x40
+	} save_area[SLB_NUM_BOLTED];
 } ____cacheline_aligned;
 
 extern struct slb_shadow slb_shadow[];

commit 448054a6508d74767ba4c76654b42182e4f750b6
Author: Anton Blanchard <anton@samba.org>
Date:   Tue Apr 10 16:22:12 2012 +0000

    powerpc: Remove iseries specific fields in lppaca
    
    Remove all the iseries specific fields in the lppaca.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index bc4e37552948..06effe61a0de 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -28,7 +28,7 @@
 //=============================================================================
 //
 //	This control block contains the data that is shared between the
-//	hypervisor (PLIC) and the OS.
+//	hypervisor and the OS.
 //
 //
 //----------------------------------------------------------------------------
@@ -49,9 +49,6 @@
 struct lppaca {
 //=============================================================================
 // CACHE_LINE_1 0x0000 - 0x007F Contains read-only data
-// NOTE: The xDynXyz fields are fields that will be dynamically changed by
-// PLIC when preparing to bring a processor online or when dispatching a
-// virtual processor!
 //=============================================================================
 	u32	desc;			// Eye catcher 0xD397D781	x00-x03
 	u16	size;			// Size of this struct		x04-x05
@@ -59,75 +56,32 @@ struct lppaca {
 	u16	reserved2:14;		// Reserved			x08-x09
 	u8	shared_proc:1;		// Shared processor indicator	...
 	u8	secondary_thread:1;	// Secondary thread indicator	...
-	volatile u8 dyn_proc_status:8;	// Dynamic Status of this proc	x0A-x0A
-	u8	secondary_thread_count;	// Secondary thread count	x0B-x0B
-	volatile u16 dyn_hv_phys_proc_index;// Dynamic HV Physical Proc Index0C-x0D
-	volatile u16 dyn_hv_log_proc_index;// Dynamic HV Logical Proc Indexx0E-x0F
-	u32	decr_val;   		// Value for Decr programming 	x10-x13
-	u32	pmc_val;       		// Value for PMC regs         	x14-x17
+	u8	reserved3[14];		//				x0A-x17
 	volatile u32 dyn_hw_node_id;	// Dynamic Hardware Node id	x18-x1B
 	volatile u32 dyn_hw_proc_id;	// Dynamic Hardware Proc Id	x1C-x1F
-	volatile u32 dyn_pir;		// Dynamic ProcIdReg value	x20-x23
-	u32	dsei_data;           	// DSEI data                  	x24-x27
-	u64	sprg3;               	// SPRG3 value                	x28-x2F
-	u8	reserved3[40];		// Reserved			x30-x57
+	u8	reserved4[56];		// Reserved			x20-x57
 	volatile u8 vphn_assoc_counts[8]; // Virtual processor home node
 					// associativity change counters x58-x5F
-	u8	reserved4[32];		// Reserved			x60-x7F
+	u8	reserved5[32];		// Reserved			x60-x7F
 
 //=============================================================================
 // CACHE_LINE_2 0x0080 - 0x00FF Contains local read-write data
 //=============================================================================
-	// This Dword contains a byte for each type of interrupt that can occur.
-	// The IPI is a count while the others are just a binary 1 or 0.
-	union {
-		u64	any_int;
-		struct {
-			u16	reserved;	// Reserved - cleared by #mpasmbl
-			u8	xirr_int;	// Indicates xXirrValue is valid or Immed IO
-			u8	ipi_cnt;	// IPI Count
-			u8	decr_int;	// DECR interrupt occurred
-			u8	pdc_int;	// PDC interrupt occurred
-			u8	quantum_int;	// Interrupt quantum reached
-			u8	old_plic_deferred_ext_int;	// Old PLIC has a deferred XIRR pending
-		} fields;
-	} int_dword;
-
-	// Whenever any fields in this Dword are set then PLIC will defer the
-	// processing of external interrupts.  Note that PLIC will store the
-	// XIRR directly into the xXirrValue field so that another XIRR will
-	// not be presented until this one clears.  The layout of the low
-	// 4-bytes of this Dword is up to SLIC - PLIC just checks whether the
-	// entire Dword is zero or not.  A non-zero value in the low order
-	// 2-bytes will result in SLIC being granted the highest thread
-	// priority upon return.  A 0 will return to SLIC as medium priority.
-	u64	plic_defer_ints_area;	// Entire Dword
-
-	// Used to pass the real SRR0/1 from PLIC to SLIC as well as to
-	// pass the target SRR0/1 from SLIC to PLIC on a SetAsrAndRfid.
-	u64	saved_srr0;		// Saved SRR0                   x10-x17
-	u64	saved_srr1;		// Saved SRR1                   x18-x1F
-	u64	reserved5[2];		/*			    x20-x2F */
+
+	u8	reserved6[48];		//				x00-x2f
 	u8	cede_latency_hint;	/*				x30 */
-	u8	reserved[7];		/*			    x31-x37 */
+	u8	reserved7[7];		/*			    x31-x37 */
 	u8	dtl_enable_mask;	// Dispatch Trace Log mask	x38-x38
 	u8	donate_dedicated_cpu;	// Donate dedicated CPU cycles  x39-x39
 	u8	fpregs_in_use;		// FP regs in use               x3A-x3A
 	u8	pmcregs_in_use;		// PMC regs in use              x3B-x3B
-	volatile u32 saved_decr;	// Saved Decr Value             x3C-x3F
-	volatile u64 emulated_time_base;// Emulated TB for this thread  x40-x47
-	volatile u64 cur_plic_latency;	// Unaccounted PLIC latency     x48-x4F
-	u64	tot_plic_latency;	// Accumulated PLIC latency     x50-x57
+	u8	reserved8[28];		//				x3C-x57
 	u64	wait_state_cycles;	// Wait cycles for this proc    x58-x5F
-	u64	end_of_quantum;		// TB at end of quantum         x60-x67
-	u64	pdc_saved_sprg1;	// Saved SPRG1 for PMC int      x68-x6F
-	u64	pdc_saved_srr0;		// Saved SRR0 for PMC int       x70-x77
-	volatile u32 virtual_decr;	// Virtual DECR for shared procsx78-x7B
+	u8	reserved9[28];		//				x60-x7B
 	u16	slb_count;		// # of SLBs to maintain        x7C-x7D
 	u8	idle;			// Indicate OS is idle          x7E
 	u8	vmxregs_in_use;		// VMX registers in use         x7F
 
-
 //=============================================================================
 // CACHE_LINE_3 0x0100 - 0x017F: This line is shared with other processors
 //=============================================================================
@@ -141,15 +95,15 @@ struct lppaca {
 	volatile u32 dispersion_count;	// dispatch changed phys cpu    x04-x07
 	volatile u64 cmo_faults;	// CMO page fault count         x08-x0F
 	volatile u64 cmo_fault_time;	// CMO page fault time          x10-x17
-	u8	reserved7[104];		// Reserved                     x18-x7F
+	u8	reserved10[104];		// Reserved                     x18-x7F
 
 //=============================================================================
 // CACHE_LINE_4-5 0x0180 - 0x027F Contains PMC interrupt data
 //=============================================================================
 	u32	page_ins;		// CMO Hint - # page ins by OS  x00-x03
-	u8	reserved8[148];		// Reserved                     x04-x97
+	u8	reserved11[148];		// Reserved                     x04-x97
 	volatile u64 dtl_idx;		// Dispatch Trace Log head idx	x98-x9F
-	u8	reserved9[96];		// Reserved                     xA0-xFF
+	u8	reserved12[96];		// Reserved                     xA0-xFF
 } __attribute__((__aligned__(0x400)));
 
 extern struct lppaca lppaca[];

commit cf8a056a2226754087320541fb4de743cc81cd2e
Author: Anton Blanchard <anton@samba.org>
Date:   Tue Apr 10 16:20:54 2012 +0000

    powerpc: Clean up lppaca->cede_latency_hint
    
    We have a union containing fields from the old iseries hypervisor
    that has been reused for the cede latency hint. Since we no
    longer support iseries, remove the union completely.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index a76254af0aaa..bc4e37552948 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -107,19 +107,9 @@ struct lppaca {
 	// pass the target SRR0/1 from SLIC to PLIC on a SetAsrAndRfid.
 	u64	saved_srr0;		// Saved SRR0                   x10-x17
 	u64	saved_srr1;		// Saved SRR1                   x18-x1F
-
-	// Used to pass parms from the OS to PLIC for SetAsrAndRfid
-	u64	saved_gpr3;		// Saved GPR3                   x20-x27
-	u64	saved_gpr4;		// Saved GPR4                   x28-x2F
-	union {
-		u64	saved_gpr5;	/* Saved GPR5               x30-x37 */
-		struct {
-			u8	cede_latency_hint;  /*			x30 */
-			u8	reserved[7];        /*		    x31-x36 */
-		} fields;
-	} gpr5_dword;
-
-
+	u64	reserved5[2];		/*			    x20-x2F */
+	u8	cede_latency_hint;	/*				x30 */
+	u8	reserved[7];		/*			    x31-x37 */
 	u8	dtl_enable_mask;	// Dispatch Trace Log mask	x38-x38
 	u8	donate_dedicated_cpu;	// Donate dedicated CPU cycles  x39-x39
 	u8	fpregs_in_use;		// FP regs in use               x3A-x3A

commit 1b041885ae1d9938440fc2cf6a444b70ec0a86c9
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Mar 15 18:20:13 2012 +0000

    powerpc: Remove the remaining CONFIG_PPC_ISERIES pieces
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index e0298d26ce5d..a76254af0aaa 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -41,15 +41,7 @@
  * We only have to have statically allocated lppaca structs on
  * legacy iSeries, which supports at most 64 cpus.
  */
-#ifdef CONFIG_PPC_ISERIES
-#if NR_CPUS < 64
-#define NR_LPPACAS	NR_CPUS
-#else
-#define NR_LPPACAS	64
-#endif
-#else /* not iSeries */
 #define NR_LPPACAS	1
-#endif
 
 
 /* The Hypervisor barfs if the lppaca crosses a page boundary.  A 1k

commit af442a1baa6d00117cc7e7377ce7e6a545268684
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Wed May 4 12:54:16 2011 +0000

    powerpc: Ensure dtl buffers do not cross 4k boundary
    
    Future releases of fimrware will enforce a requirement that DTL buffers
    do not cross a 4k boundary. Commit
    127493d5dc73589cbe00ea5ec8357cc2a4c0d82a satisfies this requirement for
    CONFIG_VIRT_CPU_ACCOUNTING=y kernels, but if !CONFIG_VIRT_CPU_ACCOUNTING
    && CONFIG_DTL=y, the current code will fail at dtl registration time.
    Fix this by making the kmem cache from
    127493d5dc73589cbe00ea5ec8357cc2a4c0d82a visible outside of setup.c and
    using the same cache in both dtl.c and setup.c. This requires a bit of
    reorganization to ensure ordering of the kmem cache and buffer
    allocations.
    
    Note: Since firmware now limits the size of the buffer, I made
    dtl_buf_entries read-only in debugfs.
    
    Tested with upcoming firmware with the 4 combinations of
    CONFIG_VIRT_CPU_ACCOUNTING and CONFIG_DTL.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Anton Blanchard <anton@samba.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index a077adc0b35e..e0298d26ce5d 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -210,6 +210,8 @@ struct dtl_entry {
 #define DISPATCH_LOG_BYTES	4096	/* bytes per cpu */
 #define N_DISPATCH_LOG		(DISPATCH_LOG_BYTES / sizeof(struct dtl_entry))
 
+extern struct kmem_cache *dtl_cache;
+
 /*
  * When CONFIG_VIRT_CPU_ACCOUNTING = y, the cpu accounting code controls
  * reading from the dispatch trace log.  If other code wants to consume

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 26b8c807f8f1..a077adc0b35e 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -105,7 +105,7 @@ struct lppaca {
 	// processing of external interrupts.  Note that PLIC will store the
 	// XIRR directly into the xXirrValue field so that another XIRR will
 	// not be presented until this one clears.  The layout of the low
-	// 4-bytes of this Dword is upto SLIC - PLIC just checks whether the
+	// 4-bytes of this Dword is up to SLIC - PLIC just checks whether the
 	// entire Dword is zero or not.  A non-zero value in the low order
 	// 2-bytes will result in SLIC being granted the highest thread
 	// priority upon return.  A 0 will return to SLIC as medium priority.

commit f2f6dad6ca3b06ae35a2e7b63f38158242c01531
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Sun Mar 6 18:02:31 2011 +0000

    powerpc/iseries: Fix early init access to lppaca
    
    The combination of commit
    
    8154c5d22d91cd16bd9985b0638c8957e4688d0e and
    93c22703efa72c7527dbd586d1951c1f4a85fd70
    
    Broke boot on iSeries.
    
    The problem is that iSeries very early boot code, which generates
    the device-tree and runs before our normal early initializations
    does need access the lppaca's very early, before the PACA array is
    initialized, and in fact even before the boot PACA has been
    initialized (it contains all 0's at this stage).
    
    However, the first patch above makes that code use the new
    llpaca_of(cpu) accessor, which itself is changed by the second patch to
    use the PACA array.
    
    We fix that by reverting iSeries to directly dereferencing the array. In
    addition, we fix all iterators in the iSeries code to always skip CPU
    whose number is above 63 which is the maximum size of that array and
    the maximum number of supported CPUs on these machines.
    
    Additionally, we make sure the boot_paca is properly initialized
    in our early startup code.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 380d48bacd16..26b8c807f8f1 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -33,9 +33,25 @@
 //
 //----------------------------------------------------------------------------
 #include <linux/cache.h>
+#include <linux/threads.h>
 #include <asm/types.h>
 #include <asm/mmu.h>
 
+/*
+ * We only have to have statically allocated lppaca structs on
+ * legacy iSeries, which supports at most 64 cpus.
+ */
+#ifdef CONFIG_PPC_ISERIES
+#if NR_CPUS < 64
+#define NR_LPPACAS	NR_CPUS
+#else
+#define NR_LPPACAS	64
+#endif
+#else /* not iSeries */
+#define NR_LPPACAS	1
+#endif
+
+
 /* The Hypervisor barfs if the lppaca crosses a page boundary.  A 1k
  * alignment is sufficient to prevent this */
 struct lppaca {

commit 9eff1a38407c051273fe1a20f03f8155bd32de35
Author: Jesse Larrew <jlarrew@linux.vnet.ibm.com>
Date:   Wed Dec 1 12:31:15 2010 +0000

    powerpc/pseries: Poll VPA for topology changes and update NUMA maps
    
    This patch sets a timer during boot that will periodically poll the
    associativity change counters in the VPA. When a change in
    associativity is detected, it retrieves the new associativity domain
    information via the H_HOME_NODE_ASSOCIATIVITY hcall and updates the
    NUMA node maps and sysfs entries accordingly. Note that since the
    ibm,associativity device tree property does not exist on configurations
    with both NUMA and SPLPAR enabled, no device tree updates are necessary.
    
    Signed-off-by: Jesse Larrew <jlarrew@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 7f5e0fefebb0..380d48bacd16 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -62,7 +62,10 @@ struct lppaca {
 	volatile u32 dyn_pir;		// Dynamic ProcIdReg value	x20-x23
 	u32	dsei_data;           	// DSEI data                  	x24-x27
 	u64	sprg3;               	// SPRG3 value                	x28-x2F
-	u8	reserved3[80];		// Reserved			x30-x7F
+	u8	reserved3[40];		// Reserved			x30-x57
+	volatile u8 vphn_assoc_counts[8]; // Virtual processor home node
+					// associativity change counters x58-x5F
+	u8	reserved4[32];		// Reserved			x60-x7F
 
 //=============================================================================
 // CACHE_LINE_2 0x0080 - 0x00FF Contains local read-write data

commit 872e439a45ed4a4bd499bc55cb0dffa74027f749
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Aug 31 01:59:53 2010 +0000

    powerpc/pseries: Re-enable dispatch trace log userspace interface
    
    Since the cpu accounting code uses the hypervisor dispatch trace log
    now when CONFIG_VIRT_CPU_ACCOUNTING = y, the previous commit disabled
    access to it via files in the /sys/kernel/debug/powerpc/dtl/ directory
    in that case.  This restores those files.
    
    To do this, we now have a hook that the cpu accounting code will call
    as it processes each entry from the hypervisor dispatch trace log.
    The code in dtl.c now uses that to fill up its ring buffer, rather
    than having the hypervisor fill the ring buffer directly.
    
    This also fixes dtl_file_read() to handle overflow conditions a bit
    better and adds a spinlock to ensure that race conditions (multiple
    processes opening or reading the file concurrently) are handled
    correctly.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index cfb85ec85750..7f5e0fefebb0 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -191,6 +191,14 @@ struct dtl_entry {
 #define DISPATCH_LOG_BYTES	4096	/* bytes per cpu */
 #define N_DISPATCH_LOG		(DISPATCH_LOG_BYTES / sizeof(struct dtl_entry))
 
+/*
+ * When CONFIG_VIRT_CPU_ACCOUNTING = y, the cpu accounting code controls
+ * reading from the dispatch trace log.  If other code wants to consume
+ * DTL entries, it can set this pointer to a function that will get
+ * called once for each DTL entry that gets processed.
+ */
+extern void (*dtl_consumer)(struct dtl_entry *entry, u64 index);
+
 #endif /* CONFIG_PPC_BOOK3S */
 #endif /* __KERNEL__ */
 #endif /* _ASM_POWERPC_LPPACA_H */

commit cf9efce0ce3136fa076f53e53154e98455229514
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Aug 26 19:56:43 2010 +0000

    powerpc: Account time using timebase rather than PURR
    
    Currently, when CONFIG_VIRT_CPU_ACCOUNTING is enabled, we use the
    PURR register for measuring the user and system time used by
    processes, as well as other related times such as hardirq and
    softirq times.  This turns out to be quite confusing for users
    because it means that a program will often be measured as taking
    less time when run on a multi-threaded processor (SMT2 or SMT4 mode)
    than it does when run on a single-threaded processor (ST mode), even
    though the program takes longer to finish.  The discrepancy is
    accounted for as stolen time, which is also confusing, particularly
    when there are no other partitions running.
    
    This changes the accounting to use the timebase instead, meaning that
    the reported user and system times are the actual number of real-time
    seconds that the program was executing on the processor thread,
    regardless of which SMT mode the processor is in.  Thus a program will
    generally show greater user and system times when run on a
    multi-threaded processor than on a single-threaded processor.
    
    On pSeries systems on POWER5 or later processors, we measure the
    stolen time (time when this partition wasn't running) using the
    hypervisor dispatch trace log.  We check for new entries in the
    log on every entry from user mode and on every transition from
    kernel process context to soft or hard IRQ context (i.e. when
    account_system_vtime() gets called).  So that we can correctly
    distinguish time stolen from user time and time stolen from system
    time, without having to check the log on every exit to user mode,
    we store separate timestamps for exit to user mode and entry from
    user mode.
    
    On systems that have a SPURR (POWER6 and POWER7), we read the SPURR
    in account_system_vtime() (as before), and then apportion the SPURR
    ticks since the last time we read it between scaled user time and
    scaled system time according to the relative proportions of user
    time and system time over the same interval.  This avoids having to
    read the SPURR on every kernel entry and exit.  On systems that have
    PURR but not SPURR (i.e., POWER5), we do the same using the PURR
    rather than the SPURR.
    
    This disables the DTL user interface in /sys/debug/kernel/powerpc/dtl
    for now since it conflicts with the use of the dispatch trace log
    by the time accounting code.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 6d02624b622c..cfb85ec85750 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -172,6 +172,25 @@ struct slb_shadow {
 
 extern struct slb_shadow slb_shadow[];
 
+/*
+ * Layout of entries in the hypervisor's dispatch trace log buffer.
+ */
+struct dtl_entry {
+	u8	dispatch_reason;
+	u8	preempt_reason;
+	u16	processor_id;
+	u32	enqueue_to_dispatch_time;
+	u32	ready_to_enqueue_time;
+	u32	waiting_to_ready_time;
+	u64	timebase;
+	u64	fault_addr;
+	u64	srr0;
+	u64	srr1;
+};
+
+#define DISPATCH_LOG_BYTES	4096	/* bytes per cpu */
+#define N_DISPATCH_LOG		(DISPATCH_LOG_BYTES / sizeof(struct dtl_entry))
+
 #endif /* CONFIG_PPC_BOOK3S */
 #endif /* __KERNEL__ */
 #endif /* _ASM_POWERPC_LPPACA_H */

commit 93c22703efa72c7527dbd586d1951c1f4a85fd70
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Aug 12 20:18:48 2010 +0000

    powerpc: Dynamically allocate most lppaca structs
    
    This arranges for the lppaca structs for most cpus to be dynamically
    allocated in the same manner as the paca structs.  If we don't include
    support for legacy iSeries, only the first lppaca is statically
    allocated; the rest are dynamically allocated.  If we include legacy
    iSeries support, then we statically allocate the first 64 lppaca
    structs, since the iSeries hypervisor requires that the lppaca
    structs be present in the data section of the kernel image, but
    legacy iSeries supports at most 64 cpus.
    
    With CONFIG_NR_CPUS, the kernel image size for a typical pSeries config
    went from:
    
       text    data     bss     dec     hex filename
    9524478 4734564 8469944 22728986        15ad11a ../test-1024/vmlinux
    
    to:
    
       text    data     bss     dec     hex filename
    9524482 3751508 8469944 21745934        14bd10e ../test-1024/vmlinux
    
    a reduction of 983052 bytes overall.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 6b73554433a0..6d02624b622c 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -153,7 +153,7 @@ struct lppaca {
 
 extern struct lppaca lppaca[];
 
-#define lppaca_of(cpu)	(lppaca[cpu])
+#define lppaca_of(cpu)	(*paca[cpu].lppaca_ptr)
 
 /*
  * SLB shadow buffer structure as defined in the PAPR.  The save_area

commit 8154c5d22d91cd16bd9985b0638c8957e4688d0e
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Aug 12 20:18:15 2010 +0000

    powerpc: Abstract indexing of lppaca structs
    
    Currently we have the lppaca structs as a simple array of NR_CPUS
    entries, taking up space in the data section of the kernel image.
    In future we would like to allocate them dynamically, so this
    abstracts out the accesses to the array, making it easier to
    change how we locate the lppaca for a given cpu in future.
    Specifically, lppaca[cpu] changes to lppaca_of(cpu).
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 14b592dfb4e8..6b73554433a0 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -153,6 +153,8 @@ struct lppaca {
 
 extern struct lppaca lppaca[];
 
+#define lppaca_of(cpu)	(lppaca[cpu])
+
 /*
  * SLB shadow buffer structure as defined in the PAPR.  The save_area
  * contains adjacent ESID and VSID pairs for each shadowed SLB.  The

commit 69ddb57cbea0b3dd851ea5f1edd1e609ad4da04e
Author: Gautham R Shenoy <ego@in.ibm.com>
Date:   Thu Oct 29 19:22:48 2009 +0000

    powerpc/pseries: Add extended_cede_processor() helper function.
    
    This patch provides an extended_cede_processor() helper function
    which takes the cede latency hint as an argument. This hint is to be passed
    on to the hypervisor to cede to the corresponding state on platforms
    which support it.
    
    Signed-off-by: Gautham R Shenoy <ego@in.ibm.com>
    Signed-off-by: Arun R Bharadwaj <arun@linux.vnet.ibm.com>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index f78f65c38f05..14b592dfb4e8 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -100,7 +100,14 @@ struct lppaca {
 	// Used to pass parms from the OS to PLIC for SetAsrAndRfid
 	u64	saved_gpr3;		// Saved GPR3                   x20-x27
 	u64	saved_gpr4;		// Saved GPR4                   x28-x2F
-	u64	saved_gpr5;		// Saved GPR5                   x30-x37
+	union {
+		u64	saved_gpr5;	/* Saved GPR5               x30-x37 */
+		struct {
+			u8	cede_latency_hint;  /*			x30 */
+			u8	reserved[7];        /*		    x31-x36 */
+		} fields;
+	} gpr5_dword;
+
 
 	u8	dtl_enable_mask;	// Dispatch Trace Log mask	x38-x38
 	u8	donate_dedicated_cpu;	// Donate dedicated CPU cycles  x39-x39

commit 944916858a430a0627e483657d4cfa2cd2dfb4f7
Author: Benjamin Herrenschmidt <benh@kernel.crashing.org>
Date:   Tue Jun 2 21:17:45 2009 +0000

    powerpc: Shield code specific to 64-bit server processors
    
    This is a random collection of added ifdef's around portions of
    code that only mak sense on server processors. Using either
    CONFIG_PPC_STD_MMU_64 or CONFIG_PPC_BOOK3S as seems appropriate.
    
    This is meant to make the future merging of Book3E 64-bit support
    easier.
    
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index d2a65e8ca6ae..f78f65c38f05 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -20,6 +20,11 @@
 #define _ASM_POWERPC_LPPACA_H
 #ifdef __KERNEL__
 
+/* These definitions relate to hypervisors that only exist when using
+ * a server type processor
+ */
+#ifdef CONFIG_PPC_BOOK3S
+
 //=============================================================================
 //
 //	This control block contains the data that is shared between the
@@ -158,5 +163,6 @@ struct slb_shadow {
 
 extern struct slb_shadow slb_shadow[];
 
+#endif /* CONFIG_PPC_BOOK3S */
 #endif /* __KERNEL__ */
 #endif /* _ASM_POWERPC_LPPACA_H */

commit 0559f0a7611bdd336b7297dce179f793b565f148
Author: Anton Blanchard <anton@samba.org>
Date:   Tue Mar 31 20:12:44 2009 +0000

    powerpc/pseries: Add dispatch dispersion statistics
    
    PHYP tells us how often a shared processor dispatch changed physical cpus.
    This can highlight performance problems caused by the hypervisor.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 68235f7e4a8f..d2a65e8ca6ae 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -125,7 +125,7 @@ struct lppaca {
 	// NOTE: This value will ALWAYS be zero for dedicated processors and
 	// will NEVER be zero for shared processors (ie, initialized to a 1).
 	volatile u32 yield_count;	// PLIC increments each dispatchx00-x03
-	u32 reserved6;
+	volatile u32 dispersion_count;	// dispatch changed phys cpu    x04-x07
 	volatile u64 cmo_faults;	// CMO page fault count         x08-x0F
 	volatile u64 cmo_fault_time;	// CMO page fault time          x10-x17
 	u8	reserved7[104];		// Reserved                     x18-x7F

commit 098e8957afd86323db04cbb8deea3bd158f9cc71
Author: Jeremy Kerr <jk@ozlabs.org>
Date:   Wed Mar 11 17:55:52 2009 +0000

    powerpc: Add dispatch trace log fields to lppaca
    
    PAPR v2.3 defines fields in the virtual processor area for a dispatch
    trace log (DLT). Since we'd like to use the DLT, add the necessary
    fields to struct lppaca.
    
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index b063121abb3b..68235f7e4a8f 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -97,7 +97,7 @@ struct lppaca {
 	u64	saved_gpr4;		// Saved GPR4                   x28-x2F
 	u64	saved_gpr5;		// Saved GPR5                   x30-x37
 
-	u8	reserved4;		// Reserved			x38-x38
+	u8	dtl_enable_mask;	// Dispatch Trace Log mask	x38-x38
 	u8	donate_dedicated_cpu;	// Donate dedicated CPU cycles  x39-x39
 	u8	fpregs_in_use;		// FP regs in use               x3A-x3A
 	u8	pmcregs_in_use;		// PMC regs in use              x3B-x3B
@@ -134,7 +134,9 @@ struct lppaca {
 // CACHE_LINE_4-5 0x0180 - 0x027F Contains PMC interrupt data
 //=============================================================================
 	u32	page_ins;		// CMO Hint - # page ins by OS  x00-x03
-	u8	pmc_save_area[252];	// PMC interrupt Area           x04-xFF
+	u8	reserved8[148];		// Reserved                     x04-x97
+	volatile u64 dtl_idx;		// Dispatch Trace Log head idx	x98-x9F
+	u8	reserved9[96];		// Reserved                     xA0-xFF
 } __attribute__((__aligned__(0x400)));
 
 extern struct lppaca lppaca[];

commit 4032278324bd3b7ad00b0ad687bb6125c4b9fc75
Author: Jeremy Kerr <jk@ozlabs.org>
Date:   Wed Mar 11 17:55:52 2009 +0000

    powerpc: Fix page_ins details in lppaca comments
    
    The page_ins member ends at byte 0x3, not 0x4. Also, fix up the
    alignment.
    
    Signed-off-by: Jeremy Kerr <jk@ozlabs.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 25aaa97facd8..b063121abb3b 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -133,7 +133,7 @@ struct lppaca {
 //=============================================================================
 // CACHE_LINE_4-5 0x0180 - 0x027F Contains PMC interrupt data
 //=============================================================================
-	u32	page_ins;			// CMO Hint - # page ins by OS  x00-x04
+	u32	page_ins;		// CMO Hint - # page ins by OS  x00-x03
 	u8	pmc_save_area[252];	// PMC interrupt Area           x04-xFF
 } __attribute__((__aligned__(0x400)));
 

commit 409001948d9f221c94a61c3ee96de112755fc04d
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Wed Oct 22 05:53:45 2008 +0000

    powerpc: Update page-in counter for CMM
    
    A new field has been added to the VPA as a method for the client OS to
    communicate to firmware the number of page-ins it is performing when
    running collaborative memory overcommit.  The hypervisor will use this
    information to better determine if a partition is experiencing memory
    pressure and needs more memory allocated to it.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
index 2fe268b10333..25aaa97facd8 100644
--- a/arch/powerpc/include/asm/lppaca.h
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -133,7 +133,8 @@ struct lppaca {
 //=============================================================================
 // CACHE_LINE_4-5 0x0180 - 0x027F Contains PMC interrupt data
 //=============================================================================
-	u8	pmc_save_area[256];	// PMC interrupt Area           x00-xFF
+	u32	page_ins;			// CMO Hint - # page ins by OS  x00-x04
+	u8	pmc_save_area[252];	// PMC interrupt Area           x04-xFF
 } __attribute__((__aligned__(0x400)));
 
 extern struct lppaca lppaca[];

commit b8b572e1015f81b4e748417be2629dfe51ab99f9
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Fri Aug 1 15:20:30 2008 +1000

    powerpc: Move include files to arch/powerpc/include/asm
    
    from include/asm-powerpc.  This is the result of a
    
    mkdir arch/powerpc/include/asm
    git mv include/asm-powerpc/* arch/powerpc/include/asm
    
    Followed by a few documentation/comment fixups and a couple of places
    where <asm-powepc/...> was being used explicitly.  Of the latter only
    one was outside the arch code and it is a driver only built for powerpc.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/include/asm/lppaca.h b/arch/powerpc/include/asm/lppaca.h
new file mode 100644
index 000000000000..2fe268b10333
--- /dev/null
+++ b/arch/powerpc/include/asm/lppaca.h
@@ -0,0 +1,159 @@
+/*
+ * lppaca.h
+ * Copyright (C) 2001  Mike Corrigan IBM Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307 USA
+ */
+#ifndef _ASM_POWERPC_LPPACA_H
+#define _ASM_POWERPC_LPPACA_H
+#ifdef __KERNEL__
+
+//=============================================================================
+//
+//	This control block contains the data that is shared between the
+//	hypervisor (PLIC) and the OS.
+//
+//
+//----------------------------------------------------------------------------
+#include <linux/cache.h>
+#include <asm/types.h>
+#include <asm/mmu.h>
+
+/* The Hypervisor barfs if the lppaca crosses a page boundary.  A 1k
+ * alignment is sufficient to prevent this */
+struct lppaca {
+//=============================================================================
+// CACHE_LINE_1 0x0000 - 0x007F Contains read-only data
+// NOTE: The xDynXyz fields are fields that will be dynamically changed by
+// PLIC when preparing to bring a processor online or when dispatching a
+// virtual processor!
+//=============================================================================
+	u32	desc;			// Eye catcher 0xD397D781	x00-x03
+	u16	size;			// Size of this struct		x04-x05
+	u16	reserved1;		// Reserved			x06-x07
+	u16	reserved2:14;		// Reserved			x08-x09
+	u8	shared_proc:1;		// Shared processor indicator	...
+	u8	secondary_thread:1;	// Secondary thread indicator	...
+	volatile u8 dyn_proc_status:8;	// Dynamic Status of this proc	x0A-x0A
+	u8	secondary_thread_count;	// Secondary thread count	x0B-x0B
+	volatile u16 dyn_hv_phys_proc_index;// Dynamic HV Physical Proc Index0C-x0D
+	volatile u16 dyn_hv_log_proc_index;// Dynamic HV Logical Proc Indexx0E-x0F
+	u32	decr_val;   		// Value for Decr programming 	x10-x13
+	u32	pmc_val;       		// Value for PMC regs         	x14-x17
+	volatile u32 dyn_hw_node_id;	// Dynamic Hardware Node id	x18-x1B
+	volatile u32 dyn_hw_proc_id;	// Dynamic Hardware Proc Id	x1C-x1F
+	volatile u32 dyn_pir;		// Dynamic ProcIdReg value	x20-x23
+	u32	dsei_data;           	// DSEI data                  	x24-x27
+	u64	sprg3;               	// SPRG3 value                	x28-x2F
+	u8	reserved3[80];		// Reserved			x30-x7F
+
+//=============================================================================
+// CACHE_LINE_2 0x0080 - 0x00FF Contains local read-write data
+//=============================================================================
+	// This Dword contains a byte for each type of interrupt that can occur.
+	// The IPI is a count while the others are just a binary 1 or 0.
+	union {
+		u64	any_int;
+		struct {
+			u16	reserved;	// Reserved - cleared by #mpasmbl
+			u8	xirr_int;	// Indicates xXirrValue is valid or Immed IO
+			u8	ipi_cnt;	// IPI Count
+			u8	decr_int;	// DECR interrupt occurred
+			u8	pdc_int;	// PDC interrupt occurred
+			u8	quantum_int;	// Interrupt quantum reached
+			u8	old_plic_deferred_ext_int;	// Old PLIC has a deferred XIRR pending
+		} fields;
+	} int_dword;
+
+	// Whenever any fields in this Dword are set then PLIC will defer the
+	// processing of external interrupts.  Note that PLIC will store the
+	// XIRR directly into the xXirrValue field so that another XIRR will
+	// not be presented until this one clears.  The layout of the low
+	// 4-bytes of this Dword is upto SLIC - PLIC just checks whether the
+	// entire Dword is zero or not.  A non-zero value in the low order
+	// 2-bytes will result in SLIC being granted the highest thread
+	// priority upon return.  A 0 will return to SLIC as medium priority.
+	u64	plic_defer_ints_area;	// Entire Dword
+
+	// Used to pass the real SRR0/1 from PLIC to SLIC as well as to
+	// pass the target SRR0/1 from SLIC to PLIC on a SetAsrAndRfid.
+	u64	saved_srr0;		// Saved SRR0                   x10-x17
+	u64	saved_srr1;		// Saved SRR1                   x18-x1F
+
+	// Used to pass parms from the OS to PLIC for SetAsrAndRfid
+	u64	saved_gpr3;		// Saved GPR3                   x20-x27
+	u64	saved_gpr4;		// Saved GPR4                   x28-x2F
+	u64	saved_gpr5;		// Saved GPR5                   x30-x37
+
+	u8	reserved4;		// Reserved			x38-x38
+	u8	donate_dedicated_cpu;	// Donate dedicated CPU cycles  x39-x39
+	u8	fpregs_in_use;		// FP regs in use               x3A-x3A
+	u8	pmcregs_in_use;		// PMC regs in use              x3B-x3B
+	volatile u32 saved_decr;	// Saved Decr Value             x3C-x3F
+	volatile u64 emulated_time_base;// Emulated TB for this thread  x40-x47
+	volatile u64 cur_plic_latency;	// Unaccounted PLIC latency     x48-x4F
+	u64	tot_plic_latency;	// Accumulated PLIC latency     x50-x57
+	u64	wait_state_cycles;	// Wait cycles for this proc    x58-x5F
+	u64	end_of_quantum;		// TB at end of quantum         x60-x67
+	u64	pdc_saved_sprg1;	// Saved SPRG1 for PMC int      x68-x6F
+	u64	pdc_saved_srr0;		// Saved SRR0 for PMC int       x70-x77
+	volatile u32 virtual_decr;	// Virtual DECR for shared procsx78-x7B
+	u16	slb_count;		// # of SLBs to maintain        x7C-x7D
+	u8	idle;			// Indicate OS is idle          x7E
+	u8	vmxregs_in_use;		// VMX registers in use         x7F
+
+
+//=============================================================================
+// CACHE_LINE_3 0x0100 - 0x017F: This line is shared with other processors
+//=============================================================================
+	// This is the yield_count.  An "odd" value (low bit on) means that
+	// the processor is yielded (either because of an OS yield or a PLIC
+	// preempt).  An even value implies that the processor is currently
+	// executing.
+	// NOTE: This value will ALWAYS be zero for dedicated processors and
+	// will NEVER be zero for shared processors (ie, initialized to a 1).
+	volatile u32 yield_count;	// PLIC increments each dispatchx00-x03
+	u32 reserved6;
+	volatile u64 cmo_faults;	// CMO page fault count         x08-x0F
+	volatile u64 cmo_fault_time;	// CMO page fault time          x10-x17
+	u8	reserved7[104];		// Reserved                     x18-x7F
+
+//=============================================================================
+// CACHE_LINE_4-5 0x0180 - 0x027F Contains PMC interrupt data
+//=============================================================================
+	u8	pmc_save_area[256];	// PMC interrupt Area           x00-xFF
+} __attribute__((__aligned__(0x400)));
+
+extern struct lppaca lppaca[];
+
+/*
+ * SLB shadow buffer structure as defined in the PAPR.  The save_area
+ * contains adjacent ESID and VSID pairs for each shadowed SLB.  The
+ * ESID is stored in the lower 64bits, then the VSID.
+ */
+struct slb_shadow {
+	u32	persistent;		// Number of persistent SLBs	x00-x03
+	u32	buffer_length;		// Total shadow buffer length	x04-x07
+	u64	reserved;		// Alignment			x08-x0f
+	struct	{
+		u64     esid;
+		u64	vsid;
+	} save_area[SLB_NUM_BOLTED];	//				x10-x40
+} ____cacheline_aligned;
+
+extern struct slb_shadow slb_shadow[];
+
+#endif /* __KERNEL__ */
+#endif /* _ASM_POWERPC_LPPACA_H */
