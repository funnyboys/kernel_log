commit 1b5c0967ab8aa9424cdd5108de4e055d8aeaa9d0
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Thu May 21 16:55:55 2020 +0000

    powerpc/40x: Remove support for IBM 403GCX
    
    CONFIG_403GCX is not user selectable and is not
    selected by any platform.
    
    Remove it.
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Christophe Leroy <christophe.leroy@csgroup.eu>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/635f8f5ce9d1f761b3bd8dc3e8ddad500cea26c4.1590079968.git.christophe.leroy@csgroup.eu

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 39ce95016a3a..b287cfc2dd85 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -51,24 +51,12 @@ struct div_result {
 
 static inline unsigned long get_tbl(void)
 {
-#if defined(CONFIG_403GCX)
-	unsigned long tbl;
-	asm volatile("mfspr %0, 0x3dd" : "=r" (tbl));
-	return tbl;
-#else
 	return mftbl();
-#endif
 }
 
 static inline unsigned int get_tbu(void)
 {
-#ifdef CONFIG_403GCX
-	unsigned int tbu;
-	asm volatile("mfspr %0, 0x3dc" : "=r" (tbu));
-	return tbu;
-#else
 	return mftbu();
-#endif
 }
 #endif /* !CONFIG_PPC64 */
 

commit 68b34588e2027f699a3c034235f21cd19356b2e6
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Feb 26 03:35:34 2020 +1000

    powerpc/64/sycall: Implement syscall entry/exit logic in C
    
    System call entry and particularly exit code is beyond the limit of
    what is reasonable to implement in asm.
    
    This conversion moves all conditional branches out of the asm code,
    except for the case that all GPRs should be restored at exit.
    
    Null syscall test is about 5% faster after this patch, because the
    exit work is handled under local_irq_disable, and the hard mask and
    pending interrupt replay is handled after that, which avoids games
    with MSR.
    
    mpe: Includes subsequent fixes from Nick:
    
    This fixes 4 issues caught by TM selftests. First was a tm-syscall bug
    that hit due to tabort_syscall being called after interrupts were
    reconciled (in a subsequent patch), which led to interrupts being
    enabled before tabort_syscall was called. Rather than going through an
    un-reconciling interrupts for the return, I just go back to putting
    the test early in asm, the C-ification of that wasn't a big win
    anyway.
    
    Second is the syscall return _TIF_USER_WORK_MASK check would go into
    an infinite loop if _TIF_RESTORE_TM became set. The asm code uses
    _TIF_USER_WORK_MASK to brach to slowpath which includes
    restore_tm_state.
    
    Third is system call return was not calling restore_tm_state, I missed
    this completely (alhtough it's in the return from interrupt C
    conversion because when the asm syscall code encountered problems it
    would branch to the interrupt return code.
    
    Fourth is MSR_VEC missing from restore_math, which was caught by
    tm-unavailable selftest taking an unexpected facility unavailable
    interrupt when testing VSX unavailble exception with MSR.FP=1
    MSR.VEC=1. Fourth case also has a fixup in a subsequent patch.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michal Suchanek <msuchanek@suse.de>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20200225173541.1549955-26-npiggin@gmail.com

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index e0107495c4de..39ce95016a3a 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -194,5 +194,8 @@ DECLARE_PER_CPU(u64, decrementers_next_tb);
 /* Convert timebase ticks to nanoseconds */
 unsigned long long tb_to_ns(unsigned long long tb_ticks);
 
+/* SPLPAR */
+void accumulate_stolen_time(void);
+
 #endif /* __KERNEL__ */
 #endif /* __POWERPC_TIME_H */

commit 2babd6ea43edacfc1577432baa187a7d212f3f4f
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Wed Feb 26 03:35:25 2020 +1000

    powerpc/64s/exception: Avoid touching the stack in hdecrementer
    
    The hdec interrupt handler is reported to sometimes fire in Linux if
    KVM leaves it pending after a guest exists. This is harmless, so there
    is a no-op handler for it.
    
    The interrupt handler currently uses the regular kernel stack. Change
    this to avoid touching the stack entirely.
    
    This should be the last place where the regular Linux stack can be
    accessed with asynchronous interrupts (including PMI) soft-masked.
    It might be possible to take advantage of this invariant, e.g., to
    context switch the kernel stack SLB entry without clearing MSR[EE].
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/20200225173541.1549955-17-npiggin@gmail.com

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 08dbe3e6831c..e0107495c4de 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -24,7 +24,6 @@ extern struct clock_event_device decrementer_clockevent;
 
 
 extern void generic_calibrate_decr(void);
-extern void hdec_interrupt(struct pt_regs *regs);
 
 /* Some sane defaults: 125 MHz timebase, 1GHz processor */
 extern unsigned long ppc_proc_freq;

commit 88fb309409ab454b497a6abb0f931ce3b6d9969c
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Mon Aug 26 15:52:16 2019 +0000

    powerpc/32s: drop CPU_FTR_USE_RTC feature
    
    CPU_FTR_USE_RTC feature only applies to powerpc601.
    
    Drop this feature and replace it with tests on CONFIG_PPC_BOOK3S_601.
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
    Link: https://lore.kernel.org/r/170411e2360861f4a95c21faad43519a08bc4040.1566834712.git.christophe.leroy@c-s.fr

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 54f4ec1f9fab..08dbe3e6831c 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -41,11 +41,7 @@ struct div_result {
 
 /* Accessor functions for the timebase (RTC on 601) registers. */
 /* If one day CONFIG_POWER is added just define __USE_RTC as 1 */
-#ifdef CONFIG_PPC_BOOK3S_32
-#define __USE_RTC()	(cpu_has_feature(CPU_FTR_USE_RTC))
-#else
-#define __USE_RTC()	0
-#endif
+#define __USE_RTC()	(IS_ENABLED(CONFIG_PPC_BOOK3S_601))
 
 #ifdef CONFIG_PPC64
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 57e968413d1e..54f4ec1f9fab 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -1,13 +1,9 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Common time prototypes and such for all ppc machines.
  *
  * Written by Cort Dougan (cort@cs.nmt.edu) to merge
  * Paul Mackerras' version and mine for PReP and Pmac.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 
 #ifndef __POWERPC_TIME_H

commit de269129a48a2d590ba1d20c719e19d86e3ddb3f
Author: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
Date:   Tue Mar 5 01:12:19 2019 +0530

    powerpc/hmi: Fix kernel hang when TB is in error state.
    
    On TOD/TB errors timebase register stops/freezes until HMI error recovery
    gets TOD/TB back into running state. On successful recovery, TB starts
    running again and udelay() that relies on TB value continues to function
    properly. But in case when HMI fails to recover from TOD/TB errors, the
    TB register stay freezed. With TB not running the __delay() function
    keeps looping and never return. If __delay() is called while in panic
    path then system hangs and never reboots after panic.
    
    Signed-off-by: Mahesh Salgaonkar <mahesh@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 54bf7e68a7e1..57e968413d1e 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -36,6 +36,8 @@ extern unsigned long ppc_proc_freq;
 extern unsigned long ppc_tb_freq;
 #define DEFAULT_TB_FREQ		125000000UL
 
+extern bool tb_invalid;
+
 struct div_result {
 	u64 result_high;
 	u64 result_low;

commit d7cceda96badc1bd444cff27ab9c375a1277c1e3
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Sat Nov 17 10:24:56 2018 +0000

    powerpc: change CONFIG_6xx to CONFIG_PPC_BOOK3S_32
    
    Today we have:
    
    config PPC_BOOK3S_32
            bool "512x/52xx/6xx/7xx/74xx/82xx/83xx/86xx"
            [depends on PPC32 within a choice]
    
    config PPC_BOOK3S
            def_bool y
            depends on PPC_BOOK3S_32 || PPC_BOOK3S_64
    
    config 6xx
            def_bool y
            depends on PPC32 && PPC_BOOK3S
    
    6xx is therefore redundant with PPC_BOOK3S_32.
    
    In order to make the code clearer, lets use preferably PPC_BOOK3S_32.
    This will allow to remove CONFIG_6xx in a later patch.
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index b80d492ceb29..54bf7e68a7e1 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -43,7 +43,7 @@ struct div_result {
 
 /* Accessor functions for the timebase (RTC on 601) registers. */
 /* If one day CONFIG_POWER is added just define __USE_RTC as 1 */
-#ifdef CONFIG_6xx
+#ifdef CONFIG_PPC_BOOK3S_32
 #define __USE_RTC()	(cpu_has_feature(CPU_FTR_USE_RTC))
 #else
 #define __USE_RTC()	0

commit 34efabe418953002d1c8e0ab28634929a9ddf433
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Apr 23 10:36:42 2018 +0200

    powerpc: remove unused to_tm() helper
    
    to_tm() is now completely unused, the only reference being in the
    _dump_time() helper that is also unused. This removes both, leaving
    the rest of the powerpc RTC code y2038 safe to as far as the hardware
    supports.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 69b89f941252..b80d492ceb29 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -26,8 +26,6 @@ extern unsigned long tb_ticks_per_usec;
 extern unsigned long tb_ticks_per_sec;
 extern struct clock_event_device decrementer_clockevent;
 
-struct rtc_time;
-extern void to_tm(int tim, struct rtc_time * tm);
 
 extern void generic_calibrate_decr(void);
 extern void hdec_interrupt(struct pt_regs *regs);

commit 3f984620f9a4fe089c0a3c951b75a460211394bb
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Sat May 5 03:19:31 2018 +1000

    powerpc: generic clockevents broadcast receiver call tick_receive_broadcast
    
    The broadcast tick recipient can call tick_receive_broadcast rather
    than re-running the full timer interrupt.
    
    It does not have to check for the next event time, because the sender
    already determined the timer has expired. It does not have to test
    irq_work_pending, because that's a direct decrementer interrupt and
    does not go through the clock events subsystem. And it does not have
    to read PURR because that was removed with the previous patch.
    
    This results in no code size change, but both the decrementer and
    broadcast path lengths are reduced.
    
    Cc: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: Preeti U Murthy <preeti@linux.vnet.ibm.com>
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index c965c79765c4..69b89f941252 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -28,7 +28,6 @@ extern struct clock_event_device decrementer_clockevent;
 
 struct rtc_time;
 extern void to_tm(int tim, struct rtc_time * tm);
-extern void tick_broadcast_ipi_handler(void);
 
 extern void generic_calibrate_decr(void);
 extern void hdec_interrupt(struct pt_regs *regs);

commit 3d3a6021ddcbe9c31520e4e7b65e5ce5dc58274d
Author: Nicholas Piggin <npiggin@gmail.com>
Date:   Sat May 5 03:19:30 2018 +1000

    powerpc/pseries: lparcfg calculate PURR on demand
    
    For SPLPAR, lparcfg provides a sum of PURR registers for all CPUs.
    Currently this is done by reading PURR in context switch and timer
    interrupt, and storing that into a per-CPU variable. These are summed
    to provide the value.
    
    This does not work with all timer schemes (e.g., NO_HZ_FULL), and it
    is sub-optimal for performance because it reads the PURR register on
    every context switch, although that's been difficult to distinguish
    from noise in the contxt_switch microbenchmark.
    
    This patch implements the sum by calling a function on each CPU, to
    read and add PURR values of each CPU.
    
    Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index db546c034905..c965c79765c4 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -196,14 +196,6 @@ extern u64 mulhdu(u64, u64);
 extern void div128_by_32(u64 dividend_high, u64 dividend_low,
 			 unsigned divisor, struct div_result *dr);
 
-/* Used to store Processor Utilization register (purr) values */
-
-struct cpu_usage {
-        u64 current_tb;  /* Holds the current purr register values */
-};
-
-DECLARE_PER_CPU(struct cpu_usage, cpu_usage_array);
-
 extern void secondary_cpu_time_init(void);
 extern void __init time_init(void);
 

commit a26cf1c9fe3c2e3b671b490aeb708ea72fb5ac0a
Merge: 78e5dfea84dc 681c617b7c42
Author: Michael Ellerman <mpe@ellerman.id.au>
Date:   Sat Mar 24 08:43:18 2018 +1100

    Merge branch 'topic/ppc-kvm' into next
    
    This brings in two series from Paul, one of which touches KVM code and
    may need to be merged into the kvm-ppc tree to resolve conflicts.

commit c0d64cf9fefd58831ce2cc81b2683bfff3760f7a
Author: Paul Mackerras <paulus@ozlabs.org>
Date:   Tue Mar 20 08:46:11 2018 +1100

    powerpc: Use feature bit for RTC presence rather than timebase presence
    
    All PowerPC CPUs other than the original PPC601 have a timebase
    register rather than the "real-time clock" (RTC) register that the
    PPC601 (and the original POWER and POWER2 CPUs) had.  Currently
    we have a CPU feature bit to indicate the presence of the timebase,
    but it makes more sense to use a bit to indicate the unusual
    situation rather than the common situation.  This therefore defines
    a CPU_FTR_USE_RTC bit in place of the CPU_FTR_USE_TB bit, and
    arranges for it to be set on PPC601 systems.
    
    Signed-off-by: Paul Mackerras <paulus@ozlabs.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index b240666b7bc1..c9ad438cc0a9 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -46,7 +46,7 @@ struct div_result {
 /* Accessor functions for the timebase (RTC on 601) registers. */
 /* If one day CONFIG_POWER is added just define __USE_RTC as 1 */
 #ifdef CONFIG_6xx
-#define __USE_RTC()	(!cpu_has_feature(CPU_FTR_USE_TB))
+#define __USE_RTC()	(cpu_has_feature(CPU_FTR_USE_RTC))
 #else
 #define __USE_RTC()	0
 #endif

commit 848092faa0c7687a99bf465808f7dae5bb5ca6be
Author: Mathieu Malaterre <malat@debian.org>
Date:   Sun Feb 25 18:22:27 2018 +0100

    powerpc: Add missing prototype for time_init()
    
    The function time_init did not have a prototype defined in the time.h
    header. Fix the following warning (treated as error in W=1):
    
      arch/powerpc/kernel/time.c:1068:13: error: no previous prototype for ‘time_init’
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index a7a8a9ac5991..828ebe7ba7dc 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -205,6 +205,7 @@ struct cpu_usage {
 DECLARE_PER_CPU(struct cpu_usage, cpu_usage_array);
 
 extern void secondary_cpu_time_init(void);
+extern void __init time_init(void);
 
 DECLARE_PER_CPU(u64, decrementers_next_tb);
 

commit 8b604faff7d421904ebd1fa65d642f566f4a6648
Author: Mathieu Malaterre <malat@debian.org>
Date:   Sun Feb 25 18:22:26 2018 +0100

    powerpc: Add missing prototype for hdec_interrupt
    
    In commit dabe859ec636 ("powerpc: Give hypervisor decrementer interrupts
    their own handler") an empty body function was added, but no prototype
    was declared. Fix warning (treated as error in W=1):
    
      arch/powerpc/kernel/time.c:629:6: error: no previous prototype for ‘hdec_interrupt’
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index b240666b7bc1..a7a8a9ac5991 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -31,6 +31,7 @@ extern void to_tm(int tim, struct rtc_time * tm);
 extern void tick_broadcast_ipi_handler(void);
 
 extern void generic_calibrate_decr(void);
+extern void hdec_interrupt(struct pt_regs *regs);
 
 /* Some sane defaults: 125 MHz timebase, 1GHz processor */
 extern unsigned long ppc_proc_freq;

commit b92a226e528423b8d249dd09bb450d53361fbfcb
Author: Kevin Hao <haokexin@gmail.com>
Date:   Sat Jul 23 14:42:40 2016 +0530

    powerpc: Move cpu_has_feature() to a separate file
    
    We plan to use jump label for cpu_has_feature(). In order to implement
    this we need to include the linux/jump_label.h in asm/cputable.h.
    
    Unfortunately if we do that it leads to an include loop. The root of the
    problem seems to be that reg.h needs cputable.h (for CPU_FTRs), and then
    cputable.h via jump_label.h eventually pulls in hw_irq.h which needs
    reg.h (for MSR_EE).
    
    So move cpu_has_feature() to a separate file on its own.
    
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    [mpe: Rename to cpu_has_feature.h and flesh out change log]
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index cbbeaf0a6597..b240666b7bc1 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -18,6 +18,7 @@
 #include <linux/percpu.h>
 
 #include <asm/processor.h>
+#include <asm/cpu_has_feature.h>
 
 /* time.c */
 extern unsigned long tb_ticks_per_jiffy;

commit 905259e33d0ca0ee8e0d55783c3eef3402df81b7
Author: Kevin Hao <haokexin@gmail.com>
Date:   Sat Jul 23 14:42:39 2016 +0530

    powerpc: Remove mfvtb()
    
    This function is only used by get_vtb(). They are almost the same except
    the reading from the real register. Move the mfspr() to get_vtb() and
    kill the function mfvtb(). With this, we can eliminate the use of
    cpu_has_feature() in very core header file like reg.h. This is a
    preparation for the use of jump label for cpu_has_feature().
    
    Signed-off-by: Kevin Hao <haokexin@gmail.com>
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 09211640a0e0..cbbeaf0a6597 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -103,7 +103,7 @@ static inline u64 get_vtb(void)
 {
 #ifdef CONFIG_PPC_BOOK3S_64
 	if (cpu_has_feature(CPU_FTR_ARCH_207S))
-		return mfvtb();
+		return mfspr(SPRN_VTB);
 #endif
 	return 0;
 }

commit 799010244685334b34e674d354a1a71a3a6b6148
Author: Oliver O'Halloran <oohall@gmail.com>
Date:   Fri Jul 1 16:20:39 2016 +1000

    powerpc/timer: Large Decrementer support
    
    Power ISAv3 adds a large decrementer (LD) mode which increases the size
    of the decrementer register. The size of the enlarged decrementer
    register is between 32 and 64 bits with the exact size being dependent
    on the implementation. When in LD mode, reads are sign extended to 64
    bits and a decrementer exception is raised when the high bit is set (i.e
    the value goes below zero). Writes however are truncated to the physical
    register width so some care needs to be taken to ensure that the high
    bit is not set when reloading the decrementer. This patch adds support
    for using the LD inside the host kernel on processors that support it.
    
    When LD mode is supported firmware will supply the ibm,dec-bits property
    for CPU nodes to allow the kernel to determine the maximum decrementer
    value. Enabling LD mode is a hypervisor privileged operation so the kernel
    can only enable it manually when running in hypervisor mode. Guests that
    support LD mode can request it using the "ibm,client-architecture-support"
    firmware call (not implemented in this patch) or some other platform
    specific method. If this property is not supplied then the traditional
    decrementer width of 32 bit is assumed and LD mode will not be enabled.
    
    This patch was based on initial work by Jack Miller.
    
    Signed-off-by: Oliver O'Halloran <oohall@gmail.com>
    Signed-off-by: Balbir Singh <bsingharora@gmail.com>
    Acked-by: Michael Neuling <mikey@neuling.org>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 1092fdd7e737..09211640a0e0 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -146,7 +146,7 @@ static inline void set_tb(unsigned int upper, unsigned int lower)
  * in auto-reload mode.  The problem is PIT stops counting when it
  * hits zero.  If it would wrap, we could use it just like a decrementer.
  */
-static inline unsigned int get_dec(void)
+static inline u64 get_dec(void)
 {
 #if defined(CONFIG_40x)
 	return (mfspr(SPRN_PIT));
@@ -160,10 +160,10 @@ static inline unsigned int get_dec(void)
  * in when the decrementer generates its interrupt: on the 1 to 0
  * transition for Book E/4xx, but on the 0 to -1 transition for others.
  */
-static inline void set_dec(int val)
+static inline void set_dec(u64 val)
 {
 #if defined(CONFIG_40x)
-	mtspr(SPRN_PIT, val);
+	mtspr(SPRN_PIT, (u32) val);
 #else
 #ifndef CONFIG_BOOKE
 	--val;

commit 63e9e1c28fa6fe714364c7817e60dbaed3cec95e
Author: Christophe Leroy <christophe.leroy@c-s.fr>
Date:   Tue Feb 9 17:08:16 2016 +0100

    powerpc/8xx: remove special handling of CPU6 errata in set_dec()
    
    CPU6 ERRATA is now handled directly in mtspr(), so we can use the
    standard set_dec() fonction in all cases.
    
    Signed-off-by: Christophe Leroy <christophe.leroy@c-s.fr>
    Signed-off-by: Scott Wood <oss@buserror.net>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 2d7109a8d296..1092fdd7e737 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -31,8 +31,6 @@ extern void tick_broadcast_ipi_handler(void);
 
 extern void generic_calibrate_decr(void);
 
-extern void set_dec_cpu6(unsigned int val);
-
 /* Some sane defaults: 125 MHz timebase, 1GHz processor */
 extern unsigned long ppc_proc_freq;
 #define DEFAULT_PROC_FREQ	(DEFAULT_TB_FREQ * 8)
@@ -166,14 +164,12 @@ static inline void set_dec(int val)
 {
 #if defined(CONFIG_40x)
 	mtspr(SPRN_PIT, val);
-#elif defined(CONFIG_8xx_CPU6)
-	set_dec_cpu6(val - 1);
 #else
 #ifndef CONFIG_BOOKE
 	--val;
 #endif
 	mtspr(SPRN_DEC, val);
-#endif /* not 40x or 8xx_CPU6 */
+#endif /* not 40x */
 }
 
 static inline unsigned long tb_ticks_since(unsigned long tstamp)

commit 00b912b0c88e690b1662067497182454357b18b0
Author: Daniel Axtens <dja@axtens.net>
Date:   Tue Dec 15 18:09:14 2015 +1100

    powerpc: Remove broken GregorianDay()
    
    GregorianDay() is supposed to calculate the day of the week
    (tm->tm_wday) for a given day/month/year. In that calcuation it
    indexed into an array called MonthOffset using tm->tm_mon-1. However
    tm_mon is zero-based, not one-based, so this is off-by-one. It also
    means that every January, GregoiranDay() will access element -1 of
    the MonthOffset array.
    
    It also doesn't appear to be a correct algorithm either: see in
    contrast kernel/time/timeconv.c's time_to_tm function.
    
    It's been broken forever, which suggests no-one in userland uses
    this. It looks like no-one in the kernel uses tm->tm_wday either
    (see e.g. drivers/rtc/rtc-ds1305.c:319).
    
    tm->tm_wday is conventionally set to -1 when not available in
    hardware so we can simply set it to -1 and drop the function.
    (There are over a dozen other drivers in drivers/rtc that do
    this.)
    
    Found using UBSAN.
    
    Cc: Andrey Ryabinin <aryabinin@virtuozzo.com>
    Cc: Andrew Morton <akpm@linux-foundation.org> # as an example of what UBSan finds.
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Cc: rtc-linux@googlegroups.com
    Signed-off-by: Daniel Axtens <dja@axtens.net>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 10fc784a2ad4..2d7109a8d296 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -27,7 +27,6 @@ extern struct clock_event_device decrementer_clockevent;
 
 struct rtc_time;
 extern void to_tm(int tim, struct rtc_time * tm);
-extern void GregorianDay(struct rtc_time *tm);
 extern void tick_broadcast_ipi_handler(void);
 
 extern void generic_calibrate_decr(void);

commit b6c295df3131c6fa25f8f29625ee0609506150ad
Author: Paul Mackerras <paulus@samba.org>
Date:   Sat Mar 28 14:21:02 2015 +1100

    KVM: PPC: Book3S HV: Accumulate timing information for real-mode code
    
    This reads the timebase at various points in the real-mode guest
    entry/exit code and uses that to accumulate total, minimum and
    maximum time spent in those parts of the code.  Currently these
    times are accumulated per vcpu in 5 parts of the code:
    
    * rm_entry - time taken from the start of kvmppc_hv_entry() until
      just before entering the guest.
    * rm_intr - time from when we take a hypervisor interrupt in the
      guest until we either re-enter the guest or decide to exit to the
      host.  This includes time spent handling hcalls in real mode.
    * rm_exit - time from when we decide to exit the guest until the
      return from kvmppc_hv_entry().
    * guest - time spend in the guest
    * cede - time spent napping in real mode due to an H_CEDE hcall
      while other threads in the same vcore are active.
    
    These times are exposed in debugfs in a directory per vcpu that
    contains a file called "timings".  This file contains one line for
    each of the 5 timings above, with the name followed by a colon and
    4 numbers, which are the count (number of times the code has been
    executed), the total time, the minimum time, and the maximum time,
    all in nanoseconds.
    
    The overhead of the extra code amounts to about 30ns for an hcall that
    is handled in real mode (e.g. H_SET_DABR), which is about 25%.  Since
    production environments may not wish to incur this overhead, the new
    code is conditional on a new config symbol,
    CONFIG_KVM_BOOK3S_HV_EXIT_TIMING.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 03cbada59d3a..10fc784a2ad4 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -211,5 +211,8 @@ extern void secondary_cpu_time_init(void);
 
 DECLARE_PER_CPU(u64, decrementers_next_tb);
 
+/* Convert timebase ticks to nanoseconds */
+unsigned long long tb_to_ns(unsigned long long tb_ticks);
+
 #endif /* __KERNEL__ */
 #endif /* __POWERPC_TIME_H */

commit 8f42ab2749d00ea15157ab896cfbed73a247b3e1
Author: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
Date:   Thu Jun 5 17:38:02 2014 +0530

    KVM: PPC: BOOK3S: PR: Emulate virtual timebase register
    
    virtual time base register is a per VM, per cpu register that needs
    to be saved and restored on vm exit and entry. Writing to VTB is not
    allowed in the privileged mode.
    
    Signed-off-by: Aneesh Kumar K.V <aneesh.kumar@linux.vnet.ibm.com>
    [agraf: fix compile error]
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 1d428e6007ca..03cbada59d3a 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -102,6 +102,15 @@ static inline u64 get_rtc(void)
 	return (u64)hi * 1000000000 + lo;
 }
 
+static inline u64 get_vtb(void)
+{
+#ifdef CONFIG_PPC_BOOK3S_64
+	if (cpu_has_feature(CPU_FTR_ARCH_207S))
+		return mfvtb();
+#endif
+	return 0;
+}
+
 #ifdef CONFIG_PPC64
 static inline u64 get_tb(void)
 {

commit 1b67bee129a36c22c17186cc2a9981678e9323ee
Author: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
Date:   Wed Feb 26 05:37:43 2014 +0530

    powerpc: Implement tick broadcast IPI as a fixed IPI message
    
    For scalability and performance reasons, we want the tick broadcast IPIs
    to be handled as efficiently as possible. Fixed IPI messages
    are one of the most efficient mechanisms available - they are faster than
    the smp_call_function mechanism because the IPI handlers are fixed and hence
    they don't involve costly operations such as adding IPI handlers to the target
    CPU's function queue, acquiring locks for synchronization etc.
    
    Luckily we have an unused IPI message slot, so use that to implement
    tick broadcast IPIs efficiently.
    
    Signed-off-by: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    [Functions renamed to tick_broadcast* and Changelog modified by
     Preeti U. Murthy<preeti@linux.vnet.ibm.com>]
    Signed-off-by: Preeti U. Murthy <preeti@linux.vnet.ibm.com>
    Acked-by: Geoff Levand <geoff@infradead.org> [For the PS3 part]
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index c1f267694acb..1d428e6007ca 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -28,6 +28,7 @@ extern struct clock_event_device decrementer_clockevent;
 struct rtc_time;
 extern void to_tm(int tim, struct rtc_time * tm);
 extern void GregorianDay(struct rtc_time *tm);
+extern void tick_broadcast_ipi_handler(void);
 
 extern void generic_calibrate_decr(void);
 

commit baa36046d09ea6dbc122c795566992318663d9eb
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Mon Jun 18 17:54:14 2012 +0200

    cputime: Consolidate vtime handling on context switch
    
    The archs that implement virtual cputime accounting all
    flush the cputime of a task when it gets descheduled
    and sometimes set up some ground initialization for the
    next task to account its cputime.
    
    These archs all put their own hooks in their context
    switch callbacks and handle the off-case themselves.
    
    Consolidate this by creating a new account_switch_vtime()
    callback called in generic code right after a context switch
    and that these archs must implement to flush the prev task
    cputime and initialize the next task cputime related state.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Acked-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 3b4b4a8da922..c1f267694acb 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -197,12 +197,6 @@ struct cpu_usage {
 
 DECLARE_PER_CPU(struct cpu_usage, cpu_usage_array);
 
-#if defined(CONFIG_VIRT_CPU_ACCOUNTING)
-#define account_process_vtime(tsk)		account_process_tick(tsk, 0)
-#else
-#define account_process_vtime(tsk)		do { } while (0)
-#endif
-
 extern void secondary_cpu_time_init(void);
 
 DECLARE_PER_CPU(u64, decrementers_next_tb);

commit 6e35994d1f6831af1e5577e28c363c9137d7d597
Author: Bharat Bhushan <r65777@freescale.com>
Date:   Wed Apr 18 06:01:19 2012 +0000

    KVM: PPC: Use clockevent multiplier and shifter for decrementer
    
    Time for which the hrtimer is started for decrementer emulation is calculated
    using tb_ticks_per_usec. While hrtimer uses the clockevent for DEC
    reprogramming (if needed) and which calculate timebase ticks using the
    multiplier and shifter mechanism implemented within clockevent layer.
    
    It was observed that this conversion (timebase->time->timebase) are not
    correct because the mechanism are not consistent.
    In our setup it adds 2% jitter.
    
    With this patch clockevent multiplier and shifter mechanism are used when
    starting hrtimer for decrementer emulation. Now the jitter is < 0.5%.
    
    Signed-off-by: Bharat Bhushan <bharat.bhushan@freescale.com>
    Signed-off-by: Alexander Graf <agraf@suse.de>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 2136f58a54e8..3b4b4a8da922 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -23,6 +23,7 @@
 extern unsigned long tb_ticks_per_jiffy;
 extern unsigned long tb_ticks_per_usec;
 extern unsigned long tb_ticks_per_sec;
+extern struct clock_event_device decrementer_clockevent;
 
 struct rtc_time;
 extern void to_tm(int tim, struct rtc_time * tm);

commit f5339277eb8d3aed37f12a27988366f68ab68930
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Thu Mar 15 18:18:00 2012 +0000

    powerpc: Remove FW_FEATURE ISERIES from arch code
    
    This is no longer selectable, so just remove all the dependent code.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 7eb10fb96cd0..2136f58a54e8 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -18,11 +18,6 @@
 #include <linux/percpu.h>
 
 #include <asm/processor.h>
-#ifdef CONFIG_PPC_ISERIES
-#include <asm/paca.h>
-#include <asm/firmware.h>
-#include <asm/iseries/hv_call.h>
-#endif
 
 /* time.c */
 extern unsigned long tb_ticks_per_jiffy;
@@ -166,15 +161,6 @@ static inline void set_dec(int val)
 #else
 #ifndef CONFIG_BOOKE
 	--val;
-#endif
-#ifdef CONFIG_PPC_ISERIES
-	if (firmware_has_feature(FW_FEATURE_ISERIES) &&
-			get_lppaca()->shared_proc) {
-		get_lppaca()->virtual_decr = val;
-		if (get_dec() > val)
-			HvCall_setVirtualDecr();
-		return;
-	}
 #endif
 	mtspr(SPRN_DEC, val);
 #endif /* not 40x or 8xx_CPU6 */
@@ -217,7 +203,6 @@ DECLARE_PER_CPU(struct cpu_usage, cpu_usage_array);
 #endif
 
 extern void secondary_cpu_time_init(void);
-extern void iSeries_time_init_early(void);
 
 DECLARE_PER_CPU(u64, decrementers_next_tb);
 

commit 7df1027542c9353bef4d027cb4ab8e99f69017b7
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Nov 23 20:07:22 2011 +0000

    powerpc/time: Optimise decrementer_check_overflow
    
    decrementer_check_overflow is called from arch_local_irq_restore so
    we want to make it as light weight as possible. As such, turn
    decrementer_check_overflow into an inline function.
    
    To avoid a circular mess of includes, separate out the two components
    of struct decrementer_clock and keep the struct clock_event_device
    part local to time.c.
    
    The fast path improves from:
    
    arch_local_irq_restore
         0:       mflr    r0
         4:       std     r0,16(r1)
         8:       stdu    r1,-112(r1)
         c:       stb     r3,578(r13)
        10:       cmpdi   cr7,r3,0
        14:       beq-    cr7,24 <.arch_local_irq_restore+0x24>
    ...
        24:       addi    r1,r1,112
        28:       ld      r0,16(r1)
        2c:       mtlr    r0
        30:       blr
    
    to:
    
    arch_local_irq_restore
        0:       std     r30,-16(r1)
        4:       ld      r30,0(r2)
        8:       stb     r3,578(r13)
        c:       cmpdi   cr7,r3,0
       10:       beq-    cr7,6c <.arch_local_irq_restore+0x6c>
    ...
       6c:       ld      r30,-16(r1)
       70:       blr
    
    Unfortunately we still setup a local TOC (due to -mminimal-toc). Yet
    another sign we should be moving to -mcmodel=medium.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index bc3c745cb906..7eb10fb96cd0 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -219,7 +219,7 @@ DECLARE_PER_CPU(struct cpu_usage, cpu_usage_array);
 extern void secondary_cpu_time_init(void);
 extern void iSeries_time_init_early(void);
 
-extern void decrementer_check_overflow(void);
+DECLARE_PER_CPU(u64, decrementers_next_tb);
 
 #endif /* __KERNEL__ */
 #endif /* __POWERPC_TIME_H */

commit 37fb9a0231ee43d42d069863bdfd567fca2b61af
Author: Anton Blanchard <anton@samba.org>
Date:   Wed Nov 23 20:07:17 2011 +0000

    powerpc/time: Handle wrapping of decrementer
    
    When re-enabling interrupts we have code to handle edge sensitive
    decrementers by resetting the decrementer to 1 whenever it is negative.
    If interrupts were disabled long enough that the decrementer wrapped to
    positive we do nothing. This means interrupts can be delayed for a long
    time until it finally goes negative again.
    
    While we hope interrupts are never be disabled long enough for the
    decrementer to go positive, we have a very good test team that can
    drive any kernel into the ground. The softlockup data we get back
    from these fails could be seconds in the future, completely missing
    the cause of the lockup.
    
    We already keep track of the timebase of the next event so use that
    to work out if we should trigger a decrementer exception.
    
    Signed-off-by: Anton Blanchard <anton@samba.org>
    Cc: stable@kernel.org
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index fe6f7c2c9c68..bc3c745cb906 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -219,5 +219,7 @@ DECLARE_PER_CPU(struct cpu_usage, cpu_usage_array);
 extern void secondary_cpu_time_init(void);
 extern void iSeries_time_init_early(void);
 
+extern void decrementer_check_overflow(void);
+
 #endif /* __KERNEL__ */
 #endif /* __POWERPC_TIME_H */

commit cf9efce0ce3136fa076f53e53154e98455229514
Author: Paul Mackerras <paulus@samba.org>
Date:   Thu Aug 26 19:56:43 2010 +0000

    powerpc: Account time using timebase rather than PURR
    
    Currently, when CONFIG_VIRT_CPU_ACCOUNTING is enabled, we use the
    PURR register for measuring the user and system time used by
    processes, as well as other related times such as hardirq and
    softirq times.  This turns out to be quite confusing for users
    because it means that a program will often be measured as taking
    less time when run on a multi-threaded processor (SMT2 or SMT4 mode)
    than it does when run on a single-threaded processor (ST mode), even
    though the program takes longer to finish.  The discrepancy is
    accounted for as stolen time, which is also confusing, particularly
    when there are no other partitions running.
    
    This changes the accounting to use the timebase instead, meaning that
    the reported user and system times are the actual number of real-time
    seconds that the program was executing on the processor thread,
    regardless of which SMT mode the processor is in.  Thus a program will
    generally show greater user and system times when run on a
    multi-threaded processor than on a single-threaded processor.
    
    On pSeries systems on POWER5 or later processors, we measure the
    stolen time (time when this partition wasn't running) using the
    hypervisor dispatch trace log.  We check for new entries in the
    log on every entry from user mode and on every transition from
    kernel process context to soft or hard IRQ context (i.e. when
    account_system_vtime() gets called).  So that we can correctly
    distinguish time stolen from user time and time stolen from system
    time, without having to check the log on every exit to user mode,
    we store separate timestamps for exit to user mode and entry from
    user mode.
    
    On systems that have a SPURR (POWER6 and POWER7), we read the SPURR
    in account_system_vtime() (as before), and then apportion the SPURR
    ticks since the last time we read it between scaled user time and
    scaled system time according to the relative proportions of user
    time and system time over the same interval.  This avoids having to
    read the SPURR on every kernel entry and exit.  On systems that have
    PURR but not SPURR (i.e., POWER5), we do the same using the PURR
    rather than the SPURR.
    
    This disables the DTL user interface in /sys/debug/kernel/powerpc/dtl
    for now since it conflicts with the use of the dispatch trace log
    by the time accounting code.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index dc779dfcf258..fe6f7c2c9c68 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -34,7 +34,6 @@ extern void to_tm(int tim, struct rtc_time * tm);
 extern void GregorianDay(struct rtc_time *tm);
 
 extern void generic_calibrate_decr(void);
-extern void snapshot_timebase(void);
 
 extern void set_dec_cpu6(unsigned int val);
 
@@ -212,12 +211,8 @@ struct cpu_usage {
 DECLARE_PER_CPU(struct cpu_usage, cpu_usage_array);
 
 #if defined(CONFIG_VIRT_CPU_ACCOUNTING)
-extern void calculate_steal_time(void);
-extern void snapshot_timebases(void);
 #define account_process_vtime(tsk)		account_process_tick(tsk, 0)
 #else
-#define calculate_steal_time()			do { } while (0)
-#define snapshot_timebases()			do { } while (0)
 #define account_process_vtime(tsk)		do { } while (0)
 #endif
 

commit c1aa687d499a8bce55cb8cf962f0b72c0f933f14
Author: Paul Mackerras <paulus@samba.org>
Date:   Sun Jun 20 19:04:14 2010 +0000

    powerpc: Clean up obsolete code relating to decrementer and timebase
    
    Since the decrementer and timekeeping code was moved over to using
    the generic clockevents and timekeeping infrastructure, several
    variables and functions have been obsolete and effectively unused.
    This deletes them.
    
    In particular, wakeup_decrementer() is no longer needed since the
    generic code reprograms the decrementer as part of the process of
    resuming the timekeeping code, which happens during sysdev resume.
    Thus the wakeup_decrementer calls in the suspend_enter methods for
    52xx platforms have been removed.  The call in the powermac cpu
    frequency change code has been replaced by set_dec(1), which will
    cause a timer interrupt as soon as interrupts are enabled, and the
    generic code will then reprogram the decrementer with the correct
    value.
    
    This also simplifies the generic_suspend_en/disable_irqs functions
    and makes them static since they are not referenced outside time.c.
    The preempt_enable/disable calls are removed because the generic
    code has disabled all but the boot cpu at the point where these
    functions are called, so we can't be moved to another cpu.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index 27ccb764fdab..dc779dfcf258 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -28,16 +28,12 @@
 extern unsigned long tb_ticks_per_jiffy;
 extern unsigned long tb_ticks_per_usec;
 extern unsigned long tb_ticks_per_sec;
-extern u64 tb_to_xs;
-extern unsigned      tb_to_us;
 
 struct rtc_time;
 extern void to_tm(int tim, struct rtc_time * tm);
 extern void GregorianDay(struct rtc_time *tm);
-extern time_t last_rtc_update;
 
 extern void generic_calibrate_decr(void);
-extern void wakeup_decrementer(void);
 extern void snapshot_timebase(void);
 
 extern void set_dec_cpu6(unsigned int val);
@@ -204,9 +200,6 @@ static inline unsigned long tb_ticks_since(unsigned long tstamp)
 extern u64 mulhdu(u64, u64);
 #endif
 
-extern void smp_space_timers(unsigned int);
-
-extern unsigned mulhwu_scale_factor(unsigned, unsigned);
 extern void div128_by_32(u64 dividend_high, u64 dividend_low,
 			 unsigned divisor, struct div_result *dr);
 

commit 3cc698789a3f44dabc5eed389b6c123caf787c0f
Author: Paul Mackerras <paulus@samba.org>
Date:   Tue Oct 28 00:18:11 2008 +0000

    powerpc: Eliminate unused do_gtod variable
    
    Since we started using the generic timekeeping code, we haven't had a
    powerpc-specific version of do_gettimeofday, and hence there is now
    nothing that reads the do_gtod variable in arch/powerpc/kernel/time.c.
    This therefore removes it and the code that sets it.
    
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
index febd581ec9b0..27ccb764fdab 100644
--- a/arch/powerpc/include/asm/time.h
+++ b/arch/powerpc/include/asm/time.h
@@ -48,26 +48,6 @@ extern unsigned long ppc_proc_freq;
 extern unsigned long ppc_tb_freq;
 #define DEFAULT_TB_FREQ		125000000UL
 
-/*
- * By putting all of this stuff into a single struct we 
- * reduce the number of cache lines touched by do_gettimeofday.
- * Both by collecting all of the data in one cache line and
- * by touching only one TOC entry on ppc64.
- */
-struct gettimeofday_vars {
-	u64 tb_to_xs;
-	u64 stamp_xsec;
-	u64 tb_orig_stamp;
-};
-
-struct gettimeofday_struct {
-	unsigned long tb_ticks_per_sec;
-	struct gettimeofday_vars vars[2];
-	struct gettimeofday_vars * volatile varp;
-	unsigned      var_idx;
-	unsigned      tb_to_us;
-};
-
 struct div_result {
 	u64 result_high;
 	u64 result_low;

commit b8b572e1015f81b4e748417be2629dfe51ab99f9
Author: Stephen Rothwell <sfr@canb.auug.org.au>
Date:   Fri Aug 1 15:20:30 2008 +1000

    powerpc: Move include files to arch/powerpc/include/asm
    
    from include/asm-powerpc.  This is the result of a
    
    mkdir arch/powerpc/include/asm
    git mv include/asm-powerpc/* arch/powerpc/include/asm
    
    Followed by a few documentation/comment fixups and a couple of places
    where <asm-powepc/...> was being used explicitly.  Of the latter only
    one was outside the arch code and it is a driver only built for powerpc.
    
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Paul Mackerras <paulus@samba.org>

diff --git a/arch/powerpc/include/asm/time.h b/arch/powerpc/include/asm/time.h
new file mode 100644
index 000000000000..febd581ec9b0
--- /dev/null
+++ b/arch/powerpc/include/asm/time.h
@@ -0,0 +1,255 @@
+/*
+ * Common time prototypes and such for all ppc machines.
+ *
+ * Written by Cort Dougan (cort@cs.nmt.edu) to merge
+ * Paul Mackerras' version and mine for PReP and Pmac.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+
+#ifndef __POWERPC_TIME_H
+#define __POWERPC_TIME_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#include <linux/percpu.h>
+
+#include <asm/processor.h>
+#ifdef CONFIG_PPC_ISERIES
+#include <asm/paca.h>
+#include <asm/firmware.h>
+#include <asm/iseries/hv_call.h>
+#endif
+
+/* time.c */
+extern unsigned long tb_ticks_per_jiffy;
+extern unsigned long tb_ticks_per_usec;
+extern unsigned long tb_ticks_per_sec;
+extern u64 tb_to_xs;
+extern unsigned      tb_to_us;
+
+struct rtc_time;
+extern void to_tm(int tim, struct rtc_time * tm);
+extern void GregorianDay(struct rtc_time *tm);
+extern time_t last_rtc_update;
+
+extern void generic_calibrate_decr(void);
+extern void wakeup_decrementer(void);
+extern void snapshot_timebase(void);
+
+extern void set_dec_cpu6(unsigned int val);
+
+/* Some sane defaults: 125 MHz timebase, 1GHz processor */
+extern unsigned long ppc_proc_freq;
+#define DEFAULT_PROC_FREQ	(DEFAULT_TB_FREQ * 8)
+extern unsigned long ppc_tb_freq;
+#define DEFAULT_TB_FREQ		125000000UL
+
+/*
+ * By putting all of this stuff into a single struct we 
+ * reduce the number of cache lines touched by do_gettimeofday.
+ * Both by collecting all of the data in one cache line and
+ * by touching only one TOC entry on ppc64.
+ */
+struct gettimeofday_vars {
+	u64 tb_to_xs;
+	u64 stamp_xsec;
+	u64 tb_orig_stamp;
+};
+
+struct gettimeofday_struct {
+	unsigned long tb_ticks_per_sec;
+	struct gettimeofday_vars vars[2];
+	struct gettimeofday_vars * volatile varp;
+	unsigned      var_idx;
+	unsigned      tb_to_us;
+};
+
+struct div_result {
+	u64 result_high;
+	u64 result_low;
+};
+
+/* Accessor functions for the timebase (RTC on 601) registers. */
+/* If one day CONFIG_POWER is added just define __USE_RTC as 1 */
+#ifdef CONFIG_6xx
+#define __USE_RTC()	(!cpu_has_feature(CPU_FTR_USE_TB))
+#else
+#define __USE_RTC()	0
+#endif
+
+#ifdef CONFIG_PPC64
+
+/* For compatibility, get_tbl() is defined as get_tb() on ppc64 */
+#define get_tbl		get_tb
+
+#else
+
+static inline unsigned long get_tbl(void)
+{
+#if defined(CONFIG_403GCX)
+	unsigned long tbl;
+	asm volatile("mfspr %0, 0x3dd" : "=r" (tbl));
+	return tbl;
+#else
+	return mftbl();
+#endif
+}
+
+static inline unsigned int get_tbu(void)
+{
+#ifdef CONFIG_403GCX
+	unsigned int tbu;
+	asm volatile("mfspr %0, 0x3dc" : "=r" (tbu));
+	return tbu;
+#else
+	return mftbu();
+#endif
+}
+#endif /* !CONFIG_PPC64 */
+
+static inline unsigned int get_rtcl(void)
+{
+	unsigned int rtcl;
+
+	asm volatile("mfrtcl %0" : "=r" (rtcl));
+	return rtcl;
+}
+
+static inline u64 get_rtc(void)
+{
+	unsigned int hi, lo, hi2;
+
+	do {
+		asm volatile("mfrtcu %0; mfrtcl %1; mfrtcu %2"
+			     : "=r" (hi), "=r" (lo), "=r" (hi2));
+	} while (hi2 != hi);
+	return (u64)hi * 1000000000 + lo;
+}
+
+#ifdef CONFIG_PPC64
+static inline u64 get_tb(void)
+{
+	return mftb();
+}
+#else /* CONFIG_PPC64 */
+static inline u64 get_tb(void)
+{
+	unsigned int tbhi, tblo, tbhi2;
+
+	do {
+		tbhi = get_tbu();
+		tblo = get_tbl();
+		tbhi2 = get_tbu();
+	} while (tbhi != tbhi2);
+
+	return ((u64)tbhi << 32) | tblo;
+}
+#endif /* !CONFIG_PPC64 */
+
+static inline u64 get_tb_or_rtc(void)
+{
+	return __USE_RTC() ? get_rtc() : get_tb();
+}
+
+static inline void set_tb(unsigned int upper, unsigned int lower)
+{
+	mtspr(SPRN_TBWL, 0);
+	mtspr(SPRN_TBWU, upper);
+	mtspr(SPRN_TBWL, lower);
+}
+
+/* Accessor functions for the decrementer register.
+ * The 4xx doesn't even have a decrementer.  I tried to use the
+ * generic timer interrupt code, which seems OK, with the 4xx PIT
+ * in auto-reload mode.  The problem is PIT stops counting when it
+ * hits zero.  If it would wrap, we could use it just like a decrementer.
+ */
+static inline unsigned int get_dec(void)
+{
+#if defined(CONFIG_40x)
+	return (mfspr(SPRN_PIT));
+#else
+	return (mfspr(SPRN_DEC));
+#endif
+}
+
+/*
+ * Note: Book E and 4xx processors differ from other PowerPC processors
+ * in when the decrementer generates its interrupt: on the 1 to 0
+ * transition for Book E/4xx, but on the 0 to -1 transition for others.
+ */
+static inline void set_dec(int val)
+{
+#if defined(CONFIG_40x)
+	mtspr(SPRN_PIT, val);
+#elif defined(CONFIG_8xx_CPU6)
+	set_dec_cpu6(val - 1);
+#else
+#ifndef CONFIG_BOOKE
+	--val;
+#endif
+#ifdef CONFIG_PPC_ISERIES
+	if (firmware_has_feature(FW_FEATURE_ISERIES) &&
+			get_lppaca()->shared_proc) {
+		get_lppaca()->virtual_decr = val;
+		if (get_dec() > val)
+			HvCall_setVirtualDecr();
+		return;
+	}
+#endif
+	mtspr(SPRN_DEC, val);
+#endif /* not 40x or 8xx_CPU6 */
+}
+
+static inline unsigned long tb_ticks_since(unsigned long tstamp)
+{
+	if (__USE_RTC()) {
+		int delta = get_rtcl() - (unsigned int) tstamp;
+		return delta < 0 ? delta + 1000000000 : delta;
+	}
+	return get_tbl() - tstamp;
+}
+
+#define mulhwu(x,y) \
+({unsigned z; asm ("mulhwu %0,%1,%2" : "=r" (z) : "r" (x), "r" (y)); z;})
+
+#ifdef CONFIG_PPC64
+#define mulhdu(x,y) \
+({unsigned long z; asm ("mulhdu %0,%1,%2" : "=r" (z) : "r" (x), "r" (y)); z;})
+#else
+extern u64 mulhdu(u64, u64);
+#endif
+
+extern void smp_space_timers(unsigned int);
+
+extern unsigned mulhwu_scale_factor(unsigned, unsigned);
+extern void div128_by_32(u64 dividend_high, u64 dividend_low,
+			 unsigned divisor, struct div_result *dr);
+
+/* Used to store Processor Utilization register (purr) values */
+
+struct cpu_usage {
+        u64 current_tb;  /* Holds the current purr register values */
+};
+
+DECLARE_PER_CPU(struct cpu_usage, cpu_usage_array);
+
+#if defined(CONFIG_VIRT_CPU_ACCOUNTING)
+extern void calculate_steal_time(void);
+extern void snapshot_timebases(void);
+#define account_process_vtime(tsk)		account_process_tick(tsk, 0)
+#else
+#define calculate_steal_time()			do { } while (0)
+#define snapshot_timebases()			do { } while (0)
+#define account_process_vtime(tsk)		do { } while (0)
+#endif
+
+extern void secondary_cpu_time_init(void);
+extern void iSeries_time_init_early(void);
+
+#endif /* __KERNEL__ */
+#endif /* __POWERPC_TIME_H */
