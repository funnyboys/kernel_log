commit bcc44f6b74106b31f0b0408b70305a40360d63b7
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed May 20 14:32:02 2020 +1000

    m68k: mac: Don't call via_flush_cache() on Mac IIfx
    
    There is no VIA2 chip on the Mac IIfx, so don't call via_flush_cache().
    This avoids a boot crash which appeared in v5.4.
    
    printk: console [ttyS0] enabled
    printk: bootconsole [debug0] disabled
    printk: bootconsole [debug0] disabled
    Calibrating delay loop... 9.61 BogoMIPS (lpj=48064)
    pid_max: default: 32768 minimum: 301
    Mount-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)
    Mountpoint-cache hash table entries: 1024 (order: 0, 4096 bytes, linear)
    devtmpfs: initialized
    random: get_random_u32 called from bucket_table_alloc.isra.27+0x68/0x194 with crng_init=0
    clocksource: jiffies: mask: 0xffffffff max_cycles: 0xffffffff, max_idle_ns: 19112604462750000 ns
    futex hash table entries: 256 (order: -1, 3072 bytes, linear)
    NET: Registered protocol family 16
    Data read fault at 0x00000000 in Super Data (pc=0x8a6a)
    BAD KERNEL BUSERR
    Oops: 00000000
    Modules linked in:
    PC: [<00008a6a>] via_flush_cache+0x12/0x2c
    SR: 2700  SP: 01c1fe3c  a2: 01c24000
    d0: 00001119    d1: 0000000c    d2: 00012000    d3: 0000000f
    d4: 01c06840    d5: 00033b92    a0: 00000000    a1: 00000000
    Process swapper (pid: 1, task=01c24000)
    Frame format=B ssw=0755 isc=0200 isb=fff7 daddr=00000000 dobuf=01c1fed0
    baddr=00008a6e dibuf=0000004e ver=f
    Stack from 01c1fec4:
            01c1fed0 00007d7e 00010080 01c1fedc 0000792e 00000001 01c1fef4 00006b40
            01c80000 00040000 00000006 00000003 01c1ff1c 004a545e 004ff200 00040000
            00000000 00000003 01c06840 00033b92 004a5410 004b6c88 01c1ff84 000021e2
            00000073 00000003 01c06840 00033b92 0038507a 004bb094 004b6ca8 004b6c88
            004b6ca4 004b6c88 000021ae 00020002 00000000 01c0685d 00000000 01c1ffb4
            0049f938 00409c85 01c06840 0045bd40 00000073 00000002 00000002 00000000
    Call Trace: [<00007d7e>] mac_cache_card_flush+0x12/0x1c
     [<00010080>] fix_dnrm+0x2/0x18
     [<0000792e>] cache_push+0x46/0x5a
     [<00006b40>] arch_dma_prep_coherent+0x60/0x6e
     [<00040000>] switched_to_dl+0x76/0xd0
     [<004a545e>] dma_atomic_pool_init+0x4e/0x188
     [<00040000>] switched_to_dl+0x76/0xd0
     [<00033b92>] parse_args+0x0/0x370
     [<004a5410>] dma_atomic_pool_init+0x0/0x188
     [<000021e2>] do_one_initcall+0x34/0x1be
     [<00033b92>] parse_args+0x0/0x370
     [<0038507a>] strcpy+0x0/0x1e
     [<000021ae>] do_one_initcall+0x0/0x1be
     [<00020002>] do_proc_dointvec_conv+0x54/0x74
     [<0049f938>] kernel_init_freeable+0x126/0x190
     [<0049f94c>] kernel_init_freeable+0x13a/0x190
     [<004a5410>] dma_atomic_pool_init+0x0/0x188
     [<00041798>] complete+0x0/0x3c
     [<000b9b0c>] kfree+0x0/0x20a
     [<0038df98>] schedule+0x0/0xd0
     [<0038d604>] kernel_init+0x0/0xda
     [<0038d610>] kernel_init+0xc/0xda
     [<0038d604>] kernel_init+0x0/0xda
     [<00002d38>] ret_from_kernel_thread+0xc/0x14
    Code: 0000 2079 0048 10da 2279 0048 10c8 d3c8 <1011> 0200 fff7 1280 d1f9 0048 10c8 1010 0000 0008 1080 4e5e 4e75 4e56 0000 2039
    Disabling lock debugging due to kernel taint
    Kernel panic - not syncing: Attempted to kill init! exitcode=0x0000000b
    
    Thanks to Stan Johnson for capturing the console log and running git
    bisect.
    
    Git bisect said commit 8e3a68fb55e0 ("dma-mapping: make
    dma_atomic_pool_init self-contained") is the first "bad" commit. I don't
    know why. Perhaps mach_l2_flush first became reachable with that commit.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Reported-and-tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Cc: Joshua Thompson <funaho@jurai.org>
    Link: https://lore.kernel.org/r/b8bbeef197d6b3898e82ed0d231ad08f575a4b34.1589949122.git.fthain@telegraphics.com.au
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 3c2cfcb74982..1f0fad2a98a0 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -294,10 +294,14 @@ void via_debug_dump(void)
  * the system into 24-bit mode for an instant.
  */
 
-void via_flush_cache(void)
+void via_l2_flush(int writeback)
 {
+	unsigned long flags;
+
+	local_irq_save(flags);
 	via2[gBufB] &= ~VIA2B_vMode32;
 	via2[gBufB] |= VIA2B_vMode32;
+	local_irq_restore(flags);
 }
 
 /*

commit 481fa139b893ff3fdbab6ea1b98271f6dde11135
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 1 11:53:10 2018 +1100

    m68k: mac: Convert to clocksource API
    
    Add a platform clocksource by adapting the existing arch_gettimeoffset
    implementation.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 8b8848998751..3c2cfcb74982 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -23,6 +23,7 @@
  *
  */
 
+#include <linux/clocksource.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
@@ -577,16 +578,39 @@ EXPORT_SYMBOL(via2_scsi_drq_pending);
 /* timer and clock source */
 
 #define VIA_CLOCK_FREQ     783360                /* VIA "phase 2" clock in Hz */
-#define VIA_TIMER_INTERVAL (1000000 / HZ)        /* microseconds per jiffy */
 #define VIA_TIMER_CYCLES   (VIA_CLOCK_FREQ / HZ) /* clock cycles per jiffy */
 
 #define VIA_TC             (VIA_TIMER_CYCLES - 2) /* including 0 and -1 */
 #define VIA_TC_LOW         (VIA_TC & 0xFF)
 #define VIA_TC_HIGH        (VIA_TC >> 8)
 
+static u64 mac_read_clk(struct clocksource *cs);
+
+static struct clocksource mac_clk = {
+	.name   = "via1",
+	.rating = 250,
+	.read   = mac_read_clk,
+	.mask   = CLOCKSOURCE_MASK(32),
+	.flags  = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
+static u32 clk_total, clk_offset;
+
+static irqreturn_t via_timer_handler(int irq, void *dev_id)
+{
+	irq_handler_t timer_routine = dev_id;
+
+	clk_total += VIA_TIMER_CYCLES;
+	clk_offset = 0;
+	timer_routine(0, NULL);
+
+	return IRQ_HANDLED;
+}
+
 void __init via_init_clock(irq_handler_t timer_routine)
 {
-	if (request_irq(IRQ_MAC_TIMER_1, timer_routine, 0, "timer", NULL)) {
+	if (request_irq(IRQ_MAC_TIMER_1, via_timer_handler, IRQF_TIMER, "timer",
+			timer_routine)) {
 		pr_err("Couldn't register %s interrupt\n", "timer");
 		return;
 	}
@@ -596,13 +620,16 @@ void __init via_init_clock(irq_handler_t timer_routine)
 	via1[vT1CL] = VIA_TC_LOW;
 	via1[vT1CH] = VIA_TC_HIGH;
 	via1[vACR] |= 0x40;
+
+	clocksource_register_hz(&mac_clk, VIA_CLOCK_FREQ);
 }
 
-u32 mac_gettimeoffset(void)
+static u64 mac_read_clk(struct clocksource *cs)
 {
 	unsigned long flags;
 	u8 count_high;
-	u16 count, offset = 0;
+	u16 count;
+	u32 ticks;
 
 	/*
 	 * Timer counter wrap-around is detected with the timer interrupt flag
@@ -618,11 +645,11 @@ u32 mac_gettimeoffset(void)
 	if (count_high == 0xFF)
 		count_high = 0;
 	if (count_high > 0 && (via1[vIFR] & VIA_TIMER_1_INT))
-		offset = VIA_TIMER_CYCLES;
-	local_irq_restore(flags);
-
+		clk_offset = VIA_TIMER_CYCLES;
 	count = count_high << 8;
-	count = VIA_TIMER_CYCLES - count + offset;
+	ticks = VIA_TIMER_CYCLES - count;
+	ticks += clk_offset + clk_total;
+	local_irq_restore(flags);
 
-	return ((count * VIA_TIMER_INTERVAL) / VIA_TIMER_CYCLES) * 1000;
+	return ticks;
 }

commit 0ca7ce7db771580433bf24454f7a1542bd326078
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 1 11:53:10 2018 +1100

    m68k: mac: Fix VIA timer counter accesses
    
    This resolves some bugs that affect VIA timer counter accesses.
    Avoid lost interrupts caused by reading the counter low byte register.
    Make allowance for the fact that the counter will be decremented to
    0xFFFF before being reloaded.
    
    Fixes: 1da177e4c3f4 ("Linux-2.6.12-rc2")
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 5c3d650d6a6f..8b8848998751 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -54,16 +54,6 @@ static __u8 rbv_clear;
 
 static int gIER,gIFR,gBufA,gBufB;
 
-/*
- * Timer defs.
- */
-
-#define TICK_SIZE		10000
-#define MAC_CLOCK_TICK		(783300/HZ)		/* ticks per HZ */
-#define MAC_CLOCK_LOW		(MAC_CLOCK_TICK&0xFF)
-#define MAC_CLOCK_HIGH		(MAC_CLOCK_TICK>>8)
-
-
 /*
  * On Macs with a genuine VIA chip there is no way to mask an individual slot
  * interrupt. This limitation also seems to apply to VIA clone logic cores in
@@ -271,22 +261,6 @@ void __init via_init(void)
 	}
 }
 
-/*
- * Start the 100 Hz clock
- */
-
-void __init via_init_clock(irq_handler_t func)
-{
-	via1[vACR] |= 0x40;
-	via1[vT1LL] = MAC_CLOCK_LOW;
-	via1[vT1LH] = MAC_CLOCK_HIGH;
-	via1[vT1CL] = MAC_CLOCK_LOW;
-	via1[vT1CH] = MAC_CLOCK_HIGH;
-
-	if (request_irq(IRQ_MAC_TIMER_1, func, 0, "timer", func))
-		pr_err("Couldn't register %s interrupt\n", "timer");
-}
-
 /*
  * Debugging dump, used in various places to see what's going on.
  */
@@ -314,29 +288,6 @@ void via_debug_dump(void)
 	}
 }
 
-/*
- * This is always executed with interrupts disabled.
- *
- * TBI: get time offset between scheduling timer ticks
- */
-
-u32 mac_gettimeoffset(void)
-{
-	unsigned long ticks, offset = 0;
-
-	/* read VIA1 timer 2 current value */
-	ticks = via1[vT1CL] | (via1[vT1CH] << 8);
-	/* The probability of underflow is less than 2% */
-	if (ticks > MAC_CLOCK_TICK - MAC_CLOCK_TICK / 50)
-		/* Check for pending timer interrupt in VIA1 IFR */
-		if (via1[vIFR] & 0x40) offset = TICK_SIZE;
-
-	ticks = MAC_CLOCK_TICK - ticks;
-	ticks = ticks * 10000L / MAC_CLOCK_TICK;
-
-	return (ticks + offset) * 1000;
-}
-
 /*
  * Flush the L2 cache on Macs that have it by flipping
  * the system into 24-bit mode for an instant.
@@ -622,3 +573,56 @@ int via2_scsi_drq_pending(void)
 	return via2[gIFR] & (1 << IRQ_IDX(IRQ_MAC_SCSIDRQ));
 }
 EXPORT_SYMBOL(via2_scsi_drq_pending);
+
+/* timer and clock source */
+
+#define VIA_CLOCK_FREQ     783360                /* VIA "phase 2" clock in Hz */
+#define VIA_TIMER_INTERVAL (1000000 / HZ)        /* microseconds per jiffy */
+#define VIA_TIMER_CYCLES   (VIA_CLOCK_FREQ / HZ) /* clock cycles per jiffy */
+
+#define VIA_TC             (VIA_TIMER_CYCLES - 2) /* including 0 and -1 */
+#define VIA_TC_LOW         (VIA_TC & 0xFF)
+#define VIA_TC_HIGH        (VIA_TC >> 8)
+
+void __init via_init_clock(irq_handler_t timer_routine)
+{
+	if (request_irq(IRQ_MAC_TIMER_1, timer_routine, 0, "timer", NULL)) {
+		pr_err("Couldn't register %s interrupt\n", "timer");
+		return;
+	}
+
+	via1[vT1LL] = VIA_TC_LOW;
+	via1[vT1LH] = VIA_TC_HIGH;
+	via1[vT1CL] = VIA_TC_LOW;
+	via1[vT1CH] = VIA_TC_HIGH;
+	via1[vACR] |= 0x40;
+}
+
+u32 mac_gettimeoffset(void)
+{
+	unsigned long flags;
+	u8 count_high;
+	u16 count, offset = 0;
+
+	/*
+	 * Timer counter wrap-around is detected with the timer interrupt flag
+	 * but reading the counter low byte (vT1CL) would reset the flag.
+	 * Also, accessing both counter registers is essentially a data race.
+	 * These problems are avoided by ignoring the low byte. Clock accuracy
+	 * is 256 times worse (error can reach 0.327 ms) but CPU overhead is
+	 * reduced by avoiding slow VIA register accesses.
+	 */
+
+	local_irq_save(flags);
+	count_high = via1[vT1CH];
+	if (count_high == 0xFF)
+		count_high = 0;
+	if (count_high > 0 && (via1[vIFR] & VIA_TIMER_1_INT))
+		offset = VIA_TIMER_CYCLES;
+	local_irq_restore(flags);
+
+	count = count_high << 8;
+	count = VIA_TIMER_CYCLES - count + offset;
+
+	return ((count * VIA_TIMER_INTERVAL) / VIA_TIMER_CYCLES) * 1000;
+}

commit 1efdd4bd254311498123a15fa0acd565f454da97
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 1 11:53:10 2018 +1100

    m68k: Call timer_interrupt() with interrupts disabled
    
    Some platforms execute their timer handler with the interrupt priority
    level set below 6. That means the handler could be interrupted by another
    driver and this could lead to re-entry of the timer core.
    
    Avoid this by use of local_irq_save/restore for timer interrupt dispatch.
    This provides mutual exclusion around the timer interrupt flag access
    which is needed later in this series for the clocksource conversion.
    
    Reported-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.21.1811131407120.2697@nanos.tec.linutronix.de
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 0b0289459173..5c3d650d6a6f 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -440,6 +440,8 @@ void via_nubus_irq_shutdown(int irq)
  * via6522.c :-), disable/pending masks added.
  */
 
+#define VIA_TIMER_1_INT BIT(6)
+
 void via1_irq(struct irq_desc *desc)
 {
 	int irq_num;
@@ -449,6 +451,21 @@ void via1_irq(struct irq_desc *desc)
 	if (!events)
 		return;
 
+	irq_num = IRQ_MAC_TIMER_1;
+	irq_bit = VIA_TIMER_1_INT;
+	if (events & irq_bit) {
+		unsigned long flags;
+
+		local_irq_save(flags);
+		via1[vIFR] = irq_bit;
+		generic_handle_irq(irq_num);
+		local_irq_restore(flags);
+
+		events &= ~irq_bit;
+		if (!events)
+			return;
+	}
+
 	irq_num = VIA1_SOURCE_BASE;
 	irq_bit = 1;
 	do {

commit bfc7bebe4b34139e03a150ab4a3567f392d74f3b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 22 13:18:01 2018 +1100

    m68k/mac: Remove obsolete comment
    
    According to The Guide To Mac Family Hardware, this is the correct way
    to disable the VBL interrupt. The confusing comment here doesn't add any
    value so remove it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index e6c8b71a3bcb..0b0289459173 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -189,7 +189,6 @@ void __init via_init(void)
 
 	/*
 	 * SE/30: disable video IRQ
-	 * XXX: testing for SE/30 VBL
 	 */
 
 	if (macintosh_config->ident == MAC_MODEL_SE30) {

commit 6a93207b7de55255209978fabeddc3cdf261e4db
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 22 13:18:01 2018 +1100

    m68k/mac: Skip VIA port setup unless RTC is connected
    
    Those Mac models which don't connect their RTC to VIA1 port B probably
    have something else connected to those pins. Just leave them the way we
    found them. Make the port B setup conditional on via_type, to match the
    RTC accessors in arch/m68k/mac/misc.c.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index acdabbeecfd2..e6c8b71a3bcb 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -197,13 +197,18 @@ void __init via_init(void)
 		via1[vBufB] |= 0x40;
 	}
 
-	/*
-	 * Set the RTC bits to a known state: all lines to outputs and
-	 * RTC disabled (yes that's 0 to enable and 1 to disable).
-	 */
-
-	via1[vDirB] |= (VIA1B_vRTCEnb | VIA1B_vRTCClk | VIA1B_vRTCData);
-	via1[vBufB] |= (VIA1B_vRTCEnb | VIA1B_vRTCClk);
+	switch (macintosh_config->adb_type) {
+	case MAC_ADB_IOP:
+	case MAC_ADB_II:
+	case MAC_ADB_PB1:
+		/*
+		 * Set the RTC bits to a known state: all lines to outputs and
+		 * RTC disabled (yes that's 0 to enable and 1 to disable).
+		 */
+		via1[vDirB] |= VIA1B_vRTCEnb | VIA1B_vRTCClk | VIA1B_vRTCData;
+		via1[vBufB] |= VIA1B_vRTCEnb | VIA1B_vRTCClk;
+		break;
+	}
 
 	/* Everything below this point is VIA2/RBV only... */
 

commit 9e09d05cfe7df9efa7bbca7d679af534a616026e
Merge: d60a540ac5f2 5e387199c17c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Nov 13 12:10:24 2017 -0800

    Merge tag 'm68k-for-v4.15-tag1' of git://git.kernel.org/pub/scm/linux/kernel/git/geert/linux-m68k
    
    Pull m68k updates from Geert Uytterhoeven:
    
      - more printk modernization
    
      - various cleanups and fixes (incl. a race condition) for Mac
    
      - defconfig updates
    
    * tag 'm68k-for-v4.15-tag1' of git://git.kernel.org/pub/scm/linux/kernel/git/geert/linux-m68k:
      m68k/defconfig: Update defconfigs for v4.14-rc7
      m68k/mac: Add mutual exclusion for IOP interrupt polling
      m68k/mac: Disentangle VIA/RBV and NuBus initialization
      m68k/mac: Disentangle VIA and OSS initialization
      m68k/mac: More printk modernization

commit 8ee90c5c3fd1af8e68133defb15cfc66c1de3f88
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Thu Oct 26 22:45:24 2017 -0400

    m68k/mac: Disentangle VIA/RBV and NuBus initialization
    
    The Nubus subsystem should not be concerned with differences between VIA,
    RBV and OSS platforms. It should be portable across Macs and PowerMacs.
    This goal has implications for the initialization code relating to bus
    locking and slot interrupts.
    
    During Nubus initialization, bus transactions are "unlocked": on VIA2 and
    RBV machines, via_nubus_init() sets a bit in the via2[gBufB] register to
    allow bus-mastering Nubus cards to arbitrate for the bus. This happens
    upon subsys_initcall(nubus_init). But because nubus_init() has no effect
    on card state, this sequence is arbitrary.
    
    Moreover, when Penguin is used to boot Linux, the bus is already unlocked
    when Linux starts. On OSS machines there's no attempt to unlock Nubus
    transactions at all. (Maybe there's no benefit on that platform or maybe
    no-one knows how.)
    
    All of this demonstrates that there's no benefit in locking out
    bus-mastering cards, as yet. (If the need arises, we could lock the bus
    for the duration of a timing-critical operation.) NetBSD unlocks the
    Nubus early (at VIA initialization) and we can do the same.
    
    via_nubus_init() is also responsible for some VIA interrupt setup that
    should happen earlier than subsys_initcall(nubus_init). And actually, the
    Nubus subsystem need not be involved with slot interrupts: SLOT2IRQ
    works fine because Nubus slot IRQs are geographically assigned
    (regardless of platform).
    
    For certain platforms with PDS slots, some Nubus IRQs may be platform
    IRQs and this is not something that the NuBus subsystem should worry
    about. So let's invoke via_nubus_init() earlier and make the platform
    responsible for bus unlocking and interrupt setup instead of the NuBus
    subsystem.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 19ad46ba4787..c38fab213e9f 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -106,6 +106,7 @@ static int gIER,gIFR,gBufA,gBufB;
 static u8 nubus_disabled;
 
 void via_debug_dump(void);
+static void via_nubus_init(void);
 
 /*
  * Initialize the VIAs
@@ -238,6 +239,8 @@ void __init via_init(void)
 		via2[vACR] &= ~0x03; /* disable port A & B latches */
 	}
 
+	via_nubus_init();
+
 	/* Everything below this point is VIA2 only... */
 
 	if (rbv_present)
@@ -359,7 +362,7 @@ int via_get_cache_disable(void)
  * Initialize VIA2 for Nubus access
  */
 
-void __init via_nubus_init(void)
+static void __init via_nubus_init(void)
 {
 	/* unlock nubus transactions */
 

commit 7a0bb4427024f426668f3ed63542328135282422
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Thu Oct 26 22:45:24 2017 -0400

    m68k/mac: Disentangle VIA and OSS initialization
    
    macintosh_config->via_type is meaningless on Mac IIfx (i.e. the only
    model with OSS chip), so skip the via_type switch statement.
    
    Call oss_init() before via_init() because it is more important and
    because that is the right place to initialize the oss_present flag.
    
    On this model, bringing forward oss_init() and delaying via_init()
    is no problem because those functions are independent.
    
    The only requirement here is that oss_register_interrupts() happens
    after via_init(). That is, mac_init_IRQ() happens after config_mac().
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 05021381af0b..19ad46ba4787 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -113,10 +113,6 @@ void via_debug_dump(void);
  * First we figure out where they actually _are_ as well as what type of
  * VIA we have for VIA2 (it could be a real VIA or an RBV or even an OSS.)
  * Then we pretty much clear them out and disable all IRQ sources.
- *
- * Note: the OSS is actually "detected" here and not in oss_init(). It just
- *	 seems more logical to do it here since via_init() needs to know
- *	 these things anyways.
  */
 
 void __init via_init(void)
@@ -124,21 +120,18 @@ void __init via_init(void)
 	via1 = (void *)VIA1_BASE;
 	pr_debug("VIA1 detected at %p\n", via1);
 
-	switch(macintosh_config->via_type) {
+	if (oss_present) {
+		via2 = NULL;
+		rbv_present = 0;
+	} else {
+		switch (macintosh_config->via_type) {
 
 		/* IIci, IIsi, IIvx, IIvi (P6xx), LC series */
 
 		case MAC_VIA_IICI:
-			if (macintosh_config->ident == MAC_MODEL_IIFX) {
-				via2 = NULL;
-				rbv_present = 0;
-				oss_present = 1;
-			} else {
-				via2 = (void *) RBV_BASE;
-				pr_debug("VIA2 (RBV) detected at %p\n", via2);
-				rbv_present = 1;
-				oss_present = 0;
-			}
+			via2 = (void *)RBV_BASE;
+			pr_debug("VIA2 (RBV) detected at %p\n", via2);
+			rbv_present = 1;
 			if (macintosh_config->ident == MAC_MODEL_LCIII) {
 				rbv_clear = 0x00;
 			} else {
@@ -160,15 +153,16 @@ void __init via_init(void)
 			via2 = (void *) VIA2_BASE;
 			pr_debug("VIA2 detected at %p\n", via2);
 			rbv_present = 0;
-			oss_present = 0;
 			rbv_clear = 0x00;
 			gIER = vIER;
 			gIFR = vIFR;
 			gBufA = vBufA;
 			gBufB = vBufB;
 			break;
+
 		default:
 			panic("UNKNOWN VIA TYPE");
+		}
 	}
 
 #ifdef DEBUG_VIA
@@ -295,9 +289,9 @@ void via_debug_dump(void)
 		(uint) via1[vDirA], (uint) via1[vDirB], (uint) via1[vACR]);
 	printk(KERN_DEBUG "         PCR = 0x%02X  IFR = 0x%02X IER = 0x%02X\n",
 		(uint) via1[vPCR], (uint) via1[vIFR], (uint) via1[vIER]);
-	if (oss_present) {
-		printk(KERN_DEBUG "VIA2: <OSS>\n");
-	} else if (rbv_present) {
+	if (!via2)
+		return;
+	if (rbv_present) {
 		printk(KERN_DEBUG "VIA2:  IFR = 0x%02X  IER = 0x%02X\n",
 			(uint) via2[rIFR], (uint) via2[rIER]);
 		printk(KERN_DEBUG "      SIFR = 0x%02X SIER = 0x%02X\n",

commit 0e37a23ebdadc0e34176b816770da6f4ac64043e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Thu Oct 26 22:45:24 2017 -0400

    m68k/mac: More printk modernization
    
    Log message fragments used to be printed on one line but now get split up.
    Fix this. Also, suppress log spam that merely prints known pointer values.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 16629e91feba..05021381af0b 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -121,18 +121,21 @@ void via_debug_dump(void);
 
 void __init via_init(void)
 {
+	via1 = (void *)VIA1_BASE;
+	pr_debug("VIA1 detected at %p\n", via1);
+
 	switch(macintosh_config->via_type) {
 
 		/* IIci, IIsi, IIvx, IIvi (P6xx), LC series */
 
 		case MAC_VIA_IICI:
-			via1 = (void *) VIA1_BASE;
 			if (macintosh_config->ident == MAC_MODEL_IIFX) {
 				via2 = NULL;
 				rbv_present = 0;
 				oss_present = 1;
 			} else {
 				via2 = (void *) RBV_BASE;
+				pr_debug("VIA2 (RBV) detected at %p\n", via2);
 				rbv_present = 1;
 				oss_present = 0;
 			}
@@ -154,8 +157,8 @@ void __init via_init(void)
 
 		case MAC_VIA_QUADRA:
 		case MAC_VIA_II:
-			via1 = (void *) VIA1_BASE;
 			via2 = (void *) VIA2_BASE;
+			pr_debug("VIA2 detected at %p\n", via2);
 			rbv_present = 0;
 			oss_present = 0;
 			rbv_clear = 0x00;
@@ -168,17 +171,6 @@ void __init via_init(void)
 			panic("UNKNOWN VIA TYPE");
 	}
 
-	printk(KERN_INFO "VIA1 at %p is a 6522 or clone\n", via1);
-
-	printk(KERN_INFO "VIA2 at %p is ", via2);
-	if (rbv_present) {
-		printk("an RBV\n");
-	} else if (oss_present) {
-		printk("an OSS\n");
-	} else {
-		printk("a 6522 or clone\n");
-	}
-
 #ifdef DEBUG_VIA
 	via_debug_dump();
 #endif

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 16629e91feba..9f59a662ace5 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *	6522 Versatile Interface Adapter (VIA)
  *

commit 16a1a66a5e8324dd6a2864ceaf3e246fc11f93a5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Jan 2 04:53:54 2017 -0500

    m68k/mac: Clean up interrupt debug macros and printk statements
    
    Mac interrupt code has been debugged. The Penguin deficiencies that
    still cause unhandled interrupts aren't fixable here. Besides,
    interrupts are fast and frequent and these printk statements
    were never really useful IMO. Remove them.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 920ff63d4a81..16629e91feba 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -550,10 +550,6 @@ void via_irq_enable(int irq) {
 	int irq_src	= IRQ_SRC(irq);
 	int irq_idx	= IRQ_IDX(irq);
 
-#ifdef DEBUG_IRQUSE
-	printk(KERN_DEBUG "via_irq_enable(%d)\n", irq);
-#endif
-
 	if (irq_src == 1) {
 		via1[vIER] = IER_SET_BIT(irq_idx);
 	} else if (irq_src == 2) {
@@ -582,10 +578,6 @@ void via_irq_disable(int irq) {
 	int irq_src	= IRQ_SRC(irq);
 	int irq_idx	= IRQ_IDX(irq);
 
-#ifdef DEBUG_IRQUSE
-	printk(KERN_DEBUG "via_irq_disable(%d)\n", irq);
-#endif
-
 	if (irq_src == 1) {
 		via1[vIER] = IER_CLR_BIT(irq_idx);
 	} else if (irq_src == 2) {

commit efbec135f11d6f14f40806935827c53d8889f59b
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Thu Feb 25 09:53:55 2016 -0800

    m68k: Fix misspellings in comments.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Acked-by: Greg Ungerer <gerg@uclinux.org> [nommu, coldfire]
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index ce56e04386e7..920ff63d4a81 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -68,7 +68,7 @@ static int gIER,gIFR,gBufA,gBufB;
  * interrupt. This limitation also seems to apply to VIA clone logic cores in
  * Quadra-like ASICs. (RBV and OSS machines don't have this limitation.)
  *
- * We used to fake it by configuring the relevent VIA pin as an output
+ * We used to fake it by configuring the relevant VIA pin as an output
  * (to mask the interrupt) or input (to unmask). That scheme did not work on
  * (at least) the Quadra 700. A NuBus card's /NMRQ signal is an open-collector
  * circuit (see Designing Cards and Drivers for Macintosh II and Macintosh SE,

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index e198dec868e4..ce56e04386e7 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -446,7 +446,7 @@ void via_nubus_irq_shutdown(int irq)
  * via6522.c :-), disable/pending masks added.
  */
 
-void via1_irq(unsigned int irq, struct irq_desc *desc)
+void via1_irq(struct irq_desc *desc)
 {
 	int irq_num;
 	unsigned char irq_bit, events;
@@ -467,7 +467,7 @@ void via1_irq(unsigned int irq, struct irq_desc *desc)
 	} while (events >= irq_bit);
 }
 
-static void via2_irq(unsigned int irq, struct irq_desc *desc)
+static void via2_irq(struct irq_desc *desc)
 {
 	int irq_num;
 	unsigned char irq_bit, events;
@@ -493,7 +493,7 @@ static void via2_irq(unsigned int irq, struct irq_desc *desc)
  * VIA2 dispatcher as a fast interrupt handler.
  */
 
-void via_nubus_irq(unsigned int irq, struct irq_desc *desc)
+static void via_nubus_irq(struct irq_desc *desc)
 {
 	int slot_irq;
 	unsigned char slot_bit, events;

commit 371001e502e8cd3543f7b9907d398a112939dff7
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sat Oct 5 21:14:22 2013 +0200

    m68k: Remove superfluous inclusions of <asm/bootinfo.h>
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 5d1458bb871b..e198dec868e4 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -30,7 +30,6 @@
 #include <linux/module.h>
 #include <linux/irq.h>
 
-#include <asm/bootinfo.h>
 #include <asm/macintosh.h>
 #include <asm/macints.h>
 #include <asm/mac_via.h>

commit c8d5ba1891eda2aa63800f052cb5af128283d130
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 8 11:34:55 2012 -0700

    m68k: set arch_gettimeoffset directly
    
    remove m68k's mach_gettimeoffset function pointer, and instead directly
    set the arch_gettimeoffset function pointer. This requires multiplying
    all function results by 1000, since the removed m68k_gettimeoffset() did
    this. Also, s/unsigned long/u32/ just to make the function prototypes
    exactly match that of arch_gettimeoffset.
    
    Cc: Joshua Thompson <funaho@jurai.org>
    Cc: Sam Creasey <sammy@sammy.net>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Phil Blundell <philb@gnu.org>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 2d85662715fb..5d1458bb871b 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -327,7 +327,7 @@ void via_debug_dump(void)
  * TBI: get time offset between scheduling timer ticks
  */
 
-unsigned long mac_gettimeoffset (void)
+u32 mac_gettimeoffset(void)
 {
 	unsigned long ticks, offset = 0;
 
@@ -341,7 +341,7 @@ unsigned long mac_gettimeoffset (void)
 	ticks = MAC_CLOCK_TICK - ticks;
 	ticks = ticks * 10000L / MAC_CLOCK_TICK;
 
-	return ticks + offset;
+	return (ticks + offset) * 1000;
 }
 
 /*

commit 608e287b0591789ecd851b05db6f0ba37807fadc
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 24 01:11:22 2011 +1100

    m68k/mac: cleanup macro case
    
    Code style convention has macro names in uppercase. Change MAC_VIA_IIci to MAC_VIA_IICI.
    
    Also remove an obsolete comment.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 7a2993bb092d..2d85662715fb 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -126,7 +126,7 @@ void __init via_init(void)
 
 		/* IIci, IIsi, IIvx, IIvi (P6xx), LC series */
 
-		case MAC_VIA_IIci:
+		case MAC_VIA_IICI:
 			via1 = (void *) VIA1_BASE;
 			if (macintosh_config->ident == MAC_MODEL_IIFX) {
 				via2 = NULL;
@@ -399,7 +399,7 @@ void __init via_nubus_init(void)
 	case MAC_VIA_QUADRA:
 		pr_debug("VIA2 vDirA is 0x%02X\n", via2[vDirA]);
 		break;
-	case MAC_VIA_IIci:
+	case MAC_VIA_IICI:
 		/* RBV. Disable all the slot interrupts. SIER works like IER. */
 		via2[rSIER] = 0x7F;
 		break;
@@ -422,7 +422,7 @@ void via_nubus_irq_startup(int irq)
 			via2[vDirA] &= 0x80 | ~(1 << irq_idx);
 		}
 		/* fall through */
-	case MAC_VIA_IIci:
+	case MAC_VIA_IICI:
 		via_irq_enable(irq);
 		break;
 	}
@@ -436,7 +436,7 @@ void via_nubus_irq_shutdown(int irq)
 		/* Ensure that the umbrella CA1 interrupt remains enabled. */
 		via_irq_enable(irq);
 		break;
-	case MAC_VIA_IIci:
+	case MAC_VIA_IICI:
 		via_irq_disable(irq);
 		break;
 	}
@@ -569,7 +569,7 @@ void via_irq_enable(int irq) {
 			if (!nubus_disabled)
 				via2[gIER] = IER_SET_BIT(1);
 			break;
-		case MAC_VIA_IIci:
+		case MAC_VIA_IICI:
 			/* On RBV, enable the slot interrupt.
 			 * SIER works like IER.
 			 */
@@ -599,7 +599,7 @@ void via_irq_disable(int irq) {
 			if (nubus_disabled)
 				via2[gIER] = IER_CLR_BIT(1);
 			break;
-		case MAC_VIA_IIci:
+		case MAC_VIA_IICI:
 			via2[rSIER] = IER_CLR_BIT(irq_idx);
 			break;
 		}

commit aa8a9fbe18bbbcf25bf5e3c7155e886057dcf171
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 24 01:11:21 2011 +1100

    mac_scsi: fix mac_scsi on some powerbooks
    
    Fix the mac_scsi interrupt edge trigger on non-RBV PowerBooks. This doesn't appear to help my PowerBook 520 but the NetBSD source reveals that the PowerBook 500 series is different than the others.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 97996a48b048..7a2993bb092d 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -253,22 +253,28 @@ void __init via_init(void)
 		via2[vACR] &= ~0x03; /* disable port A & B latches */
 	}
 
+	/* Everything below this point is VIA2 only... */
+
+	if (rbv_present)
+		return;
+
 	/*
-	 * Set vPCR for control line interrupts (but not on RBV)
+	 * Set vPCR for control line interrupts.
+	 *
+	 * CA1 (SLOTS IRQ), CB1 (ASC IRQ): negative edge trigger.
+	 *
+	 * Macs with ESP SCSI have a negative edge triggered SCSI interrupt.
+	 * Testing reveals that PowerBooks do too. However, the SE/30
+	 * schematic diagram shows an active high NCR5380 IRQ line.
 	 */
-	if (!rbv_present) {
-		/* For all VIA types, CA1 (SLOTS IRQ) and CB1 (ASC IRQ)
-		 * are made negative edge triggered here.
-		 */
-		if (macintosh_config->scsi_type == MAC_SCSI_OLD) {
-			/* CB2 (IRQ) indep. input, positive edge */
-			/* CA2 (DRQ) indep. input, positive edge */
-			via2[vPCR] = 0x66;
-		} else {
-			/* CB2 (IRQ) indep. input, negative edge */
-			/* CA2 (DRQ) indep. input, negative edge */
-			via2[vPCR] = 0x22;
-		}
+
+	pr_debug("VIA2 vPCR is 0x%02X\n", via2[vPCR]);
+	if (macintosh_config->via_type == MAC_VIA_II) {
+		/* CA2 (SCSI DRQ), CB2 (SCSI IRQ): indep. input, pos. edge */
+		via2[vPCR] = 0x66;
+	} else {
+		/* CA2 (SCSI DRQ), CB2 (SCSI IRQ): indep. input, neg. edge */
+		via2[vPCR] = 0x22;
 	}
 }
 

commit c4af5da7f24ff1bf60db2d6ff3e9d9bd912ca47a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 24 01:11:17 2011 +1100

    m68k/mac: fix nubus slot irq disable and shutdown
    
    Improve NuBus slot interrupt handling code and documentation. This patch fixes the NuBus NIC (mac8390) in my Quadra 700.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 642b44615f78..97996a48b048 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -63,18 +63,47 @@ static int gIER,gIFR,gBufA,gBufB;
 #define MAC_CLOCK_LOW		(MAC_CLOCK_TICK&0xFF)
 #define MAC_CLOCK_HIGH		(MAC_CLOCK_TICK>>8)
 
-/* To disable a NuBus slot on Quadras we make that slot IRQ line an output set
- * high. On RBV we just use the slot interrupt enable register. On Macs with
- * genuine VIA chips we must use nubus_disabled to keep track of disabled slot
- * interrupts. When any slot IRQ is disabled we mask the (edge triggered) CA1
- * or "SLOTS" interrupt. When no slot is disabled, we unmask the CA1 interrupt.
- * So, on genuine VIAs, having more than one NuBus IRQ can mean trouble,
- * because closing one of those drivers can mask all of the NuBus interrupts.
- * Also, since we can't mask the unregistered slot IRQs on genuine VIAs, it's
- * possible to get interrupts from cards that MacOS or the ROM has configured
- * but we have not. FWIW, "Designing Cards and Drivers for Macintosh II and
- * Macintosh SE", page 9-8, says, a slot IRQ with no driver would crash MacOS.
+
+/*
+ * On Macs with a genuine VIA chip there is no way to mask an individual slot
+ * interrupt. This limitation also seems to apply to VIA clone logic cores in
+ * Quadra-like ASICs. (RBV and OSS machines don't have this limitation.)
+ *
+ * We used to fake it by configuring the relevent VIA pin as an output
+ * (to mask the interrupt) or input (to unmask). That scheme did not work on
+ * (at least) the Quadra 700. A NuBus card's /NMRQ signal is an open-collector
+ * circuit (see Designing Cards and Drivers for Macintosh II and Macintosh SE,
+ * p. 10-11 etc) but VIA outputs are not (see datasheet).
+ *
+ * Driving these outputs high must cause the VIA to source current and the
+ * card to sink current when it asserts /NMRQ. Current will flow but the pin
+ * voltage is uncertain and so the /NMRQ condition may still cause a transition
+ * at the VIA2 CA1 input (which explains the lost interrupts). A side effect
+ * is that a disabled slot IRQ can never be tested as pending or not.
+ *
+ * Driving these outputs low doesn't work either. All the slot /NMRQ lines are
+ * (active low) OR'd together to generate the CA1 (aka "SLOTS") interrupt (see
+ * The Guide To Macintosh Family Hardware, 2nd edition p. 167). If we drive a
+ * disabled /NMRQ line low, the falling edge immediately triggers a CA1
+ * interrupt and all slot interrupts after that will generate no transition
+ * and therefore no interrupt, even after being re-enabled.
+ *
+ * So we make the VIA port A I/O lines inputs and use nubus_disabled to keep
+ * track of their states. When any slot IRQ becomes disabled we mask the CA1
+ * umbrella interrupt. Only when all slot IRQs become enabled do we unmask
+ * the CA1 interrupt. It must remain enabled even when cards have no interrupt
+ * handler registered. Drivers must therefore disable a slot interrupt at the
+ * device before they call free_irq (like shared and autovector interrupts).
+ *
+ * There is also a related problem when MacOS is used to boot Linux. A network
+ * card brought up by a MacOS driver may raise an interrupt while Linux boots.
+ * This can be fatal since it can't be handled until the right driver loads
+ * (if such a driver exists at all). Apparently related to this hardware
+ * limitation, "Designing Cards and Drivers", p. 9-8, says that a slot
+ * interrupt with no driver would crash MacOS (the book was written before
+ * the appearance of Macs with RBV or OSS).
  */
+
 static u8 nubus_disabled;
 
 void via_debug_dump(void);
@@ -354,34 +383,55 @@ void __init via_nubus_init(void)
 		via2[gBufB] |= 0x02;
 	}
 
-	/* Disable all the slot interrupts (where possible). */
+	/*
+	 * Disable the slot interrupts. On some hardware that's not possible.
+	 * On some hardware it's unclear what all of these I/O lines do.
+	 */
 
 	switch (macintosh_config->via_type) {
 	case MAC_VIA_II:
-		/* Just make the port A lines inputs. */
-		switch(macintosh_config->ident) {
-		case MAC_MODEL_II:
-		case MAC_MODEL_IIX:
-		case MAC_MODEL_IICX:
-		case MAC_MODEL_SE30:
-			/* The top two bits are RAM size outputs. */
-			via2[vDirA] &= 0xC0;
-			break;
-		default:
-			via2[vDirA] &= 0x80;
-		}
+	case MAC_VIA_QUADRA:
+		pr_debug("VIA2 vDirA is 0x%02X\n", via2[vDirA]);
 		break;
 	case MAC_VIA_IIci:
 		/* RBV. Disable all the slot interrupts. SIER works like IER. */
 		via2[rSIER] = 0x7F;
 		break;
+	}
+}
+
+void via_nubus_irq_startup(int irq)
+{
+	int irq_idx = IRQ_IDX(irq);
+
+	switch (macintosh_config->via_type) {
+	case MAC_VIA_II:
 	case MAC_VIA_QUADRA:
-		/* Disable the inactive slot interrupts by making those lines outputs. */
-		if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
-		    (macintosh_config->adb_type != MAC_ADB_PB2)) {
-			via2[vBufA] |= 0x7F;
-			via2[vDirA] |= 0x7F;
+		/* Make the port A line an input. Probably redundant. */
+		if (macintosh_config->via_type == MAC_VIA_II) {
+			/* The top two bits are RAM size outputs. */
+			via2[vDirA] &= 0xC0 | ~(1 << irq_idx);
+		} else {
+			/* Allow NuBus slots 9 through F. */
+			via2[vDirA] &= 0x80 | ~(1 << irq_idx);
 		}
+		/* fall through */
+	case MAC_VIA_IIci:
+		via_irq_enable(irq);
+		break;
+	}
+}
+
+void via_nubus_irq_shutdown(int irq)
+{
+	switch (macintosh_config->via_type) {
+	case MAC_VIA_II:
+	case MAC_VIA_QUADRA:
+		/* Ensure that the umbrella CA1 interrupt remains enabled. */
+		via_irq_enable(irq);
+		break;
+	case MAC_VIA_IIci:
+		via_irq_disable(irq);
 		break;
 	}
 }
@@ -507,6 +557,7 @@ void via_irq_enable(int irq) {
 	} else if (irq_src == 7) {
 		switch (macintosh_config->via_type) {
 		case MAC_VIA_II:
+		case MAC_VIA_QUADRA:
 			nubus_disabled &= ~(1 << irq_idx);
 			/* Enable the CA1 interrupt when no slot is disabled. */
 			if (!nubus_disabled)
@@ -518,14 +569,6 @@ void via_irq_enable(int irq) {
 			 */
 			via2[rSIER] = IER_SET_BIT(irq_idx);
 			break;
-		case MAC_VIA_QUADRA:
-			/* Make the port A line an input to enable the slot irq.
-			 * But not on PowerBooks, that's ADB.
-			 */
-			if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
-			    (macintosh_config->adb_type != MAC_ADB_PB2))
-				via2[vDirA] &= ~(1 << irq_idx);
-			break;
 		}
 	}
 }
@@ -545,6 +588,7 @@ void via_irq_disable(int irq) {
 	} else if (irq_src == 7) {
 		switch (macintosh_config->via_type) {
 		case MAC_VIA_II:
+		case MAC_VIA_QUADRA:
 			nubus_disabled |= 1 << irq_idx;
 			if (nubus_disabled)
 				via2[gIER] = IER_CLR_BIT(1);
@@ -552,11 +596,6 @@ void via_irq_disable(int irq) {
 		case MAC_VIA_IIci:
 			via2[rSIER] = IER_CLR_BIT(irq_idx);
 			break;
-		case MAC_VIA_QUADRA:
-			if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
-			    (macintosh_config->adb_type != MAC_ADB_PB2))
-				via2[vDirA] |= 1 << irq_idx;
-			break;
 		}
 	}
 }

commit 8d9f014ad16711d79c8a575f2d3d009d2a16c7b7
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 24 01:11:16 2011 +1100

    m68k/mac: enable via_alt_mapping on performa 580
    
    Enable via_alt_mapping on the Performa 588 and tidy up related documentation.
    
    I'm betting that remapped IRQs work just fine on the Performa 580 series since it works on the LC 630 and the logic board part numbers are reputedly the same.
    
    And the consensus seems to be that the Mac TV is essentially a Performa 550, not dissimilar to the Performa 520, so set the via_type accordingly.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 974c3e9ac7f3..642b44615f78 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -194,38 +194,17 @@ void __init via_init(void)
 	if (oss_present)
 		return;
 
-	/* Some machines support an alternate IRQ mapping that spreads  */
-	/* Ethernet and Sound out to their own autolevel IRQs and moves */
-	/* VIA1 to level 6. A/UX uses this mapping and we do too.  Note */
-	/* that the IIfx emulates this alternate mapping using the OSS. */
-
-	via_alt_mapping = 0;
-	if (macintosh_config->via_type == MAC_VIA_QUADRA)
-		switch (macintosh_config->ident) {
-		case MAC_MODEL_C660:
-		case MAC_MODEL_Q840:
-			/* not applicable */
-			break;
-		case MAC_MODEL_P588:
-		case MAC_MODEL_TV:
-		case MAC_MODEL_PB140:
-		case MAC_MODEL_PB145:
-		case MAC_MODEL_PB160:
-		case MAC_MODEL_PB165:
-		case MAC_MODEL_PB165C:
-		case MAC_MODEL_PB170:
-		case MAC_MODEL_PB180:
-		case MAC_MODEL_PB180C:
-		case MAC_MODEL_PB190:
-		case MAC_MODEL_PB520:
-			/* not yet tested */
-			break;
-		default:
-			via_alt_mapping = 1;
-			via1[vDirB] |= 0x40;
-			via1[vBufB] &= ~0x40;
-			break;
-		}
+	if ((macintosh_config->via_type == MAC_VIA_QUADRA) &&
+	    (macintosh_config->adb_type != MAC_ADB_PB1) &&
+	    (macintosh_config->adb_type != MAC_ADB_PB2) &&
+	    (macintosh_config->ident    != MAC_MODEL_C660) &&
+	    (macintosh_config->ident    != MAC_MODEL_Q840)) {
+		via_alt_mapping = 1;
+		via1[vDirB] |= 0x40;
+		via1[vBufB] &= ~0x40;
+	} else {
+		via_alt_mapping = 0;
+	}
 
 	/*
 	 * Now initialize VIA2. For RBV we just kill all interrupts;

commit ed04c97d5187c2d606a8fee0ec9ba172942ee508
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 24 01:11:15 2011 +1100

    m68k/mac: cleanup forward declarations
    
    Move some forward declarations into header files and adjust includes.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 105707aa03a2..974c3e9ac7f3 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -78,9 +78,6 @@ static int gIER,gIFR,gBufA,gBufB;
 static u8 nubus_disabled;
 
 void via_debug_dump(void);
-void via_irq_enable(int irq);
-void via_irq_disable(int irq);
-void via_irq_clear(int irq);
 
 /*
  * Initialize the VIAs

commit 30c0527d15ce4edcde64581e9d062ba9fb08fe16
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 24 01:11:14 2011 +1100

    m68k/mac: cleanup mac_irq_pending
    
    mac_irq_pending() has only one caller (mac_esp.c). Nothing tests for Baboon, PSC or OSS pending interrupts. Until that need arises, let's keep it simple and remove all the unused abstraction. Replace it with a routine to check for SCSI DRQ.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 1c2bce7506b2..105707aa03a2 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -585,28 +585,6 @@ void via_irq_disable(int irq) {
 	}
 }
 
-/*
- * Returns nonzero if an interrupt is pending on the given
- * VIA/IRQ combination.
- */
-
-int via_irq_pending(int irq)
-{
-	int irq_src	= IRQ_SRC(irq);
-	int irq_idx	= IRQ_IDX(irq);
-	int irq_bit	= 1 << irq_idx;
-
-	if (irq_src == 1) {
-		return via1[vIFR] & irq_bit;
-	} else if (irq_src == 2) {
-		return via2[gIFR] & irq_bit;
-	} else if (irq_src == 7) {
-		/* Always 0 for MAC_VIA_QUADRA if the slot irq is disabled. */
-		return ~via2[gBufA] & irq_bit;
-	}
-	return 0;
-}
-
 void via1_set_head(int head)
 {
 	if (head == 0)
@@ -615,3 +593,9 @@ void via1_set_head(int head)
 		via1[vBufA] |= VIA1A_vHeadSel;
 }
 EXPORT_SYMBOL(via1_set_head);
+
+int via2_scsi_drq_pending(void)
+{
+	return via2[gIFR] & (1 << IRQ_IDX(IRQ_MAC_SCSIDRQ));
+}
+EXPORT_SYMBOL(via2_scsi_drq_pending);

commit 56e63689fd866a865682fe14dc5a7e1ec3b2c3ad
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 24 01:11:13 2011 +1100

    m68k/mac: cleanup mac_clear_irq
    
    mac_clear_irq() is dead code and has been dead for as long as I can recall. On certain Mac models, certain irqs can't be cleared this way. Outside of irq dispatch, this code appears be unusable without busy loops or worse, and for irq dispatch we duplicate the same logic. Remove mac_clear_irq() and supporting code.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index f1600ad26621..1c2bce7506b2 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -585,22 +585,6 @@ void via_irq_disable(int irq) {
 	}
 }
 
-void via_irq_clear(int irq) {
-	int irq_src	= IRQ_SRC(irq);
-	int irq_idx	= IRQ_IDX(irq);
-	int irq_bit	= 1 << irq_idx;
-
-	if (irq_src == 1) {
-		via1[vIFR] = irq_bit;
-	} else if (irq_src == 2) {
-		via2[gIFR] = irq_bit | rbv_clear;
-	} else if (irq_src == 7) {
-		/* FIXME: There is no way to clear an individual nubus slot
-		 * IRQ flag, other than getting the device to do it.
-		 */
-	}
-}
-
 /*
  * Returns nonzero if an interrupt is pending on the given
  * VIA/IRQ combination.

commit d890d73995257b4e10cdd7d55bad80e34a71ba22
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 11 11:28:04 2011 +0200

    m68k/irq: Remove obsolete m68k irq framework
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index b8156ac496a0..f1600ad26621 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -28,9 +28,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/module.h>
-#ifdef CONFIG_GENERIC_HARDIRQS
 #include <linux/irq.h>
-#endif
 
 #include <asm/bootinfo.h>
 #include <asm/macintosh.h>
@@ -417,7 +415,6 @@ void __init via_nubus_init(void)
  * via6522.c :-), disable/pending masks added.
  */
 
-#ifdef CONFIG_GENERIC_HARDIRQS
 void via1_irq(unsigned int irq, struct irq_desc *desc)
 {
 	int irq_num;
@@ -459,58 +456,12 @@ static void via2_irq(unsigned int irq, struct irq_desc *desc)
 		irq_bit <<= 1;
 	} while (events >= irq_bit);
 }
-#else
-irqreturn_t via1_irq(int irq, void *dev_id)
-{
-	int irq_num;
-	unsigned char irq_bit, events;
-
-	events = via1[vIFR] & via1[vIER] & 0x7F;
-	if (!events)
-		return IRQ_NONE;
-
-	irq_num = VIA1_SOURCE_BASE;
-	irq_bit = 1;
-	do {
-		if (events & irq_bit) {
-			via1[vIFR] = irq_bit;
-			generic_handle_irq(irq_num);
-		}
-		++irq_num;
-		irq_bit <<= 1;
-	} while (events >= irq_bit);
-	return IRQ_HANDLED;
-}
-
-irqreturn_t via2_irq(int irq, void *dev_id)
-{
-	int irq_num;
-	unsigned char irq_bit, events;
-
-	events = via2[gIFR] & via2[gIER] & 0x7F;
-	if (!events)
-		return IRQ_NONE;
-
-	irq_num = VIA2_SOURCE_BASE;
-	irq_bit = 1;
-	do {
-		if (events & irq_bit) {
-			via2[gIFR] = irq_bit | rbv_clear;
-			generic_handle_irq(irq_num);
-		}
-		++irq_num;
-		irq_bit <<= 1;
-	} while (events >= irq_bit);
-	return IRQ_HANDLED;
-}
-#endif
 
 /*
  * Dispatch Nubus interrupts. We are called as a secondary dispatch by the
  * VIA2 dispatcher as a fast interrupt handler.
  */
 
-#ifdef CONFIG_GENERIC_HARDIRQS
 void via_nubus_irq(unsigned int irq, struct irq_desc *desc)
 {
 	int slot_irq;
@@ -545,43 +496,6 @@ void via_nubus_irq(unsigned int irq, struct irq_desc *desc)
 			events &= ~via2[vDirA];
 	} while (events);
 }
-#else
-irqreturn_t via_nubus_irq(int irq, void *dev_id)
-{
-	int slot_irq;
-	unsigned char slot_bit, events;
-
-	events = ~via2[gBufA] & 0x7F;
-	if (rbv_present)
-		events &= via2[rSIER];
-	else
-		events &= ~via2[vDirA];
-	if (!events)
-		return IRQ_NONE;
-
-	do {
-		slot_irq = IRQ_NUBUS_F;
-		slot_bit = 0x40;
-		do {
-			if (events & slot_bit) {
-				events &= ~slot_bit;
-				generic_handle_irq(slot_irq);
-			}
-			--slot_irq;
-			slot_bit >>= 1;
-		} while (events);
-
- 		/* clear the CA1 interrupt and make certain there's no more. */
-		via2[gIFR] = 0x02 | rbv_clear;
-		events = ~via2[gBufA] & 0x7F;
-		if (rbv_present)
-			events &= via2[rSIER];
-		else
-			events &= ~via2[vDirA];
-	} while (events);
-	return IRQ_HANDLED;
-}
-#endif
 
 /*
  * Register the interrupt dispatchers for VIA or RBV machines only.
@@ -589,7 +503,6 @@ irqreturn_t via_nubus_irq(int irq, void *dev_id)
 
 void __init via_register_interrupts(void)
 {
-#ifdef CONFIG_GENERIC_HARDIRQS
 	if (via_alt_mapping) {
 		/* software interrupt */
 		irq_set_chained_handler(IRQ_AUTO_1, via1_irq);
@@ -600,23 +513,6 @@ void __init via_register_interrupts(void)
 	}
 	irq_set_chained_handler(IRQ_AUTO_2, via2_irq);
 	irq_set_chained_handler(IRQ_MAC_NUBUS, via_nubus_irq);
-#else
-	if (via_alt_mapping) {
-		if (request_irq(IRQ_AUTO_1, via1_irq, 0, "software",
-				(void *)via1))
-			pr_err("Couldn't register %s interrupt\n", "software");
-		if (request_irq(IRQ_AUTO_6, via1_irq, 0, "via1", (void *)via1))
-			pr_err("Couldn't register %s interrupt\n", "via1");
-	} else {
-		if (request_irq(IRQ_AUTO_1, via1_irq, 0, "via1", (void *)via1))
-			pr_err("Couldn't register %s interrupt\n", "via1");
-	}
-	if (request_irq(IRQ_AUTO_2, via2_irq, 0, "via2", (void *)via2))
-		pr_err("Couldn't register %s interrupt\n", "via2");
-	if (request_irq(IRQ_MAC_NUBUS, via_nubus_irq, 0, "nubus",
-			(void *)via2))
-		pr_err("Couldn't register %s interrupt\n", "nubus");
-#endif
 }
 
 void via_irq_enable(int irq) {

commit 9145db564eae98134de8eb8d64b47d7177eccfdd
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Aug 10 12:48:29 2011 +0200

    m68k/mac: Optimize interrupts using chain handlers
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index bde156caa46d..b8156ac496a0 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -80,9 +80,6 @@ static int gIER,gIFR,gBufA,gBufB;
 static u8 nubus_disabled;
 
 void via_debug_dump(void);
-irqreturn_t via1_irq(int, void *);
-irqreturn_t via2_irq(int, void *);
-irqreturn_t via_nubus_irq(int, void *);
 void via_irq_enable(int irq);
 void via_irq_disable(int irq);
 void via_irq_clear(int irq);
@@ -288,29 +285,6 @@ void __init via_init_clock(irq_handler_t func)
 		pr_err("Couldn't register %s interrupt\n", "timer");
 }
 
-/*
- * Register the interrupt dispatchers for VIA or RBV machines only.
- */
-
-void __init via_register_interrupts(void)
-{
-	if (via_alt_mapping) {
-		if (request_irq(IRQ_AUTO_1, via1_irq, 0, "software",
-				(void *)via1))
-			pr_err("Couldn't register %s interrupt\n", "software");
-		if (request_irq(IRQ_AUTO_6, via1_irq, 0, "via1", (void *)via1))
-			pr_err("Couldn't register %s interrupt\n", "via1");
-	} else {
-		if (request_irq(IRQ_AUTO_1, via1_irq, 0, "via1", (void *)via1))
-			pr_err("Couldn't register %s interrupt\n", "via1");
-	}
-	if (request_irq(IRQ_AUTO_2, via2_irq, 0, "via2", (void *)via2))
-		pr_err("Couldn't register %s interrupt\n", "via2");
-	if (request_irq(IRQ_MAC_NUBUS, via_nubus_irq, 0, "nubus",
-			(void *)via2))
-		pr_err("Couldn't register %s interrupt\n", "nubus");
-}
-
 /*
  * Debugging dump, used in various places to see what's going on.
  */
@@ -443,6 +417,49 @@ void __init via_nubus_init(void)
  * via6522.c :-), disable/pending masks added.
  */
 
+#ifdef CONFIG_GENERIC_HARDIRQS
+void via1_irq(unsigned int irq, struct irq_desc *desc)
+{
+	int irq_num;
+	unsigned char irq_bit, events;
+
+	events = via1[vIFR] & via1[vIER] & 0x7F;
+	if (!events)
+		return;
+
+	irq_num = VIA1_SOURCE_BASE;
+	irq_bit = 1;
+	do {
+		if (events & irq_bit) {
+			via1[vIFR] = irq_bit;
+			generic_handle_irq(irq_num);
+		}
+		++irq_num;
+		irq_bit <<= 1;
+	} while (events >= irq_bit);
+}
+
+static void via2_irq(unsigned int irq, struct irq_desc *desc)
+{
+	int irq_num;
+	unsigned char irq_bit, events;
+
+	events = via2[gIFR] & via2[gIER] & 0x7F;
+	if (!events)
+		return;
+
+	irq_num = VIA2_SOURCE_BASE;
+	irq_bit = 1;
+	do {
+		if (events & irq_bit) {
+			via2[gIFR] = irq_bit | rbv_clear;
+			generic_handle_irq(irq_num);
+		}
+		++irq_num;
+		irq_bit <<= 1;
+	} while (events >= irq_bit);
+}
+#else
 irqreturn_t via1_irq(int irq, void *dev_id)
 {
 	int irq_num;
@@ -486,12 +503,49 @@ irqreturn_t via2_irq(int irq, void *dev_id)
 	} while (events >= irq_bit);
 	return IRQ_HANDLED;
 }
+#endif
 
 /*
  * Dispatch Nubus interrupts. We are called as a secondary dispatch by the
  * VIA2 dispatcher as a fast interrupt handler.
  */
 
+#ifdef CONFIG_GENERIC_HARDIRQS
+void via_nubus_irq(unsigned int irq, struct irq_desc *desc)
+{
+	int slot_irq;
+	unsigned char slot_bit, events;
+
+	events = ~via2[gBufA] & 0x7F;
+	if (rbv_present)
+		events &= via2[rSIER];
+	else
+		events &= ~via2[vDirA];
+	if (!events)
+		return;
+
+	do {
+		slot_irq = IRQ_NUBUS_F;
+		slot_bit = 0x40;
+		do {
+			if (events & slot_bit) {
+				events &= ~slot_bit;
+				generic_handle_irq(slot_irq);
+			}
+			--slot_irq;
+			slot_bit >>= 1;
+		} while (events);
+
+ 		/* clear the CA1 interrupt and make certain there's no more. */
+		via2[gIFR] = 0x02 | rbv_clear;
+		events = ~via2[gBufA] & 0x7F;
+		if (rbv_present)
+			events &= via2[rSIER];
+		else
+			events &= ~via2[vDirA];
+	} while (events);
+}
+#else
 irqreturn_t via_nubus_irq(int irq, void *dev_id)
 {
 	int slot_irq;
@@ -527,6 +581,43 @@ irqreturn_t via_nubus_irq(int irq, void *dev_id)
 	} while (events);
 	return IRQ_HANDLED;
 }
+#endif
+
+/*
+ * Register the interrupt dispatchers for VIA or RBV machines only.
+ */
+
+void __init via_register_interrupts(void)
+{
+#ifdef CONFIG_GENERIC_HARDIRQS
+	if (via_alt_mapping) {
+		/* software interrupt */
+		irq_set_chained_handler(IRQ_AUTO_1, via1_irq);
+		/* via1 interrupt */
+		irq_set_chained_handler(IRQ_AUTO_6, via1_irq);
+	} else {
+		irq_set_chained_handler(IRQ_AUTO_1, via1_irq);
+	}
+	irq_set_chained_handler(IRQ_AUTO_2, via2_irq);
+	irq_set_chained_handler(IRQ_MAC_NUBUS, via_nubus_irq);
+#else
+	if (via_alt_mapping) {
+		if (request_irq(IRQ_AUTO_1, via1_irq, 0, "software",
+				(void *)via1))
+			pr_err("Couldn't register %s interrupt\n", "software");
+		if (request_irq(IRQ_AUTO_6, via1_irq, 0, "via1", (void *)via1))
+			pr_err("Couldn't register %s interrupt\n", "via1");
+	} else {
+		if (request_irq(IRQ_AUTO_1, via1_irq, 0, "via1", (void *)via1))
+			pr_err("Couldn't register %s interrupt\n", "via1");
+	}
+	if (request_irq(IRQ_AUTO_2, via2_irq, 0, "via2", (void *)via2))
+		pr_err("Couldn't register %s interrupt\n", "via2");
+	if (request_irq(IRQ_MAC_NUBUS, via_nubus_irq, 0, "nubus",
+			(void *)via2))
+		pr_err("Couldn't register %s interrupt\n", "nubus");
+#endif
+}
 
 void via_irq_enable(int irq) {
 	int irq_src	= IRQ_SRC(irq);

commit ddc7fd25d09678f8252c0321ef4b66e8451abe7d
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jul 13 21:48:30 2011 +0200

    m68k/mac: Convert Mac to genirq
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index af9ed33bec14..bde156caa46d 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -28,6 +28,9 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/module.h>
+#ifdef CONFIG_GENERIC_HARDIRQS
+#include <linux/irq.h>
+#endif
 
 #include <asm/bootinfo.h>
 #include <asm/macintosh.h>

commit 5a2394534b160ce18f9a705cf9de40e77648f8a2
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jul 13 22:33:13 2011 +0200

    m68k/irq: Remove obsolete IRQ_FLG_* users
    
    The m68k core irq code stopped honoring these flags during the irq
    restructuring in 2006.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 067857046137..af9ed33bec14 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -281,7 +281,7 @@ void __init via_init_clock(irq_handler_t func)
 	via1[vT1CL] = MAC_CLOCK_LOW;
 	via1[vT1CH] = MAC_CLOCK_HIGH;
 
-	if (request_irq(IRQ_MAC_TIMER_1, func, IRQ_FLG_LOCK, "timer", func))
+	if (request_irq(IRQ_MAC_TIMER_1, func, 0, "timer", func))
 		pr_err("Couldn't register %s interrupt\n", "timer");
 }
 
@@ -292,25 +292,19 @@ void __init via_init_clock(irq_handler_t func)
 void __init via_register_interrupts(void)
 {
 	if (via_alt_mapping) {
-		if (request_irq(IRQ_AUTO_1, via1_irq,
-				IRQ_FLG_LOCK|IRQ_FLG_FAST, "software",
-				(void *) via1))
+		if (request_irq(IRQ_AUTO_1, via1_irq, 0, "software",
+				(void *)via1))
 			pr_err("Couldn't register %s interrupt\n", "software");
-		if (request_irq(IRQ_AUTO_6, via1_irq,
-				IRQ_FLG_LOCK|IRQ_FLG_FAST, "via1",
-				(void *) via1))
+		if (request_irq(IRQ_AUTO_6, via1_irq, 0, "via1", (void *)via1))
 			pr_err("Couldn't register %s interrupt\n", "via1");
 	} else {
-		if (request_irq(IRQ_AUTO_1, via1_irq,
-				IRQ_FLG_LOCK|IRQ_FLG_FAST, "via1",
-				(void *) via1))
+		if (request_irq(IRQ_AUTO_1, via1_irq, 0, "via1", (void *)via1))
 			pr_err("Couldn't register %s interrupt\n", "via1");
 	}
-	if (request_irq(IRQ_AUTO_2, via2_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
-			"via2", (void *) via2))
+	if (request_irq(IRQ_AUTO_2, via2_irq, 0, "via2", (void *)via2))
 		pr_err("Couldn't register %s interrupt\n", "via2");
-	if (request_irq(IRQ_MAC_NUBUS, via_nubus_irq,
-			IRQ_FLG_LOCK|IRQ_FLG_FAST, "nubus", (void *) via2))
+	if (request_irq(IRQ_MAC_NUBUS, via_nubus_irq, 0, "nubus",
+			(void *)via2))
 		pr_err("Couldn't register %s interrupt\n", "nubus");
 }
 

commit 1425df87c25b15400c9f26d57821bcfe01286b2a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Jul 1 20:39:19 2011 +0200

    m68k/irq: Rename {,__}m68k_handle_int()
    
      - Rename m68k_handle_int() to generic_handle_irq(), and drop the unneeded
        asmlinkage,
      - Rename __m68k_handle_int() to do_IRQ().
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index e71166daec6a..067857046137 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -460,7 +460,7 @@ irqreturn_t via1_irq(int irq, void *dev_id)
 	do {
 		if (events & irq_bit) {
 			via1[vIFR] = irq_bit;
-			m68k_handle_int(irq_num);
+			generic_handle_irq(irq_num);
 		}
 		++irq_num;
 		irq_bit <<= 1;
@@ -482,7 +482,7 @@ irqreturn_t via2_irq(int irq, void *dev_id)
 	do {
 		if (events & irq_bit) {
 			via2[gIFR] = irq_bit | rbv_clear;
-			m68k_handle_int(irq_num);
+			generic_handle_irq(irq_num);
 		}
 		++irq_num;
 		irq_bit <<= 1;
@@ -514,7 +514,7 @@ irqreturn_t via_nubus_irq(int irq, void *dev_id)
 		do {
 			if (events & slot_bit) {
 				events &= ~slot_bit;
-				m68k_handle_int(slot_irq);
+				generic_handle_irq(slot_irq);
 			}
 			--slot_irq;
 			slot_bit >>= 1;

commit 80614e5ab1458ff3ccced4d6ba2fa386575c8d5c
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Nov 17 20:06:48 2009 +1100

    mac68k: replace mac68k SCC code with platform device
    
    Remove the old 68k Mac serial port code and a lot of related cruft. Add
    new SCC platform devices to mac 68k platform.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 11bce3cb6482..e71166daec6a 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -84,8 +84,6 @@ void via_irq_enable(int irq);
 void via_irq_disable(int irq);
 void via_irq_clear(int irq);
 
-extern irqreturn_t mac_scc_dispatch(int, void *);
-
 /*
  * Initialize the VIAs
  *
@@ -311,11 +309,6 @@ void __init via_register_interrupts(void)
 	if (request_irq(IRQ_AUTO_2, via2_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
 			"via2", (void *) via2))
 		pr_err("Couldn't register %s interrupt\n", "via2");
-	if (!psc_present) {
-		if (request_irq(IRQ_AUTO_4, mac_scc_dispatch, IRQ_FLG_LOCK,
-				"scc", mac_scc_dispatch))
-			pr_err("Couldn't register %s interrupt\n", "scc");
-	}
 	if (request_irq(IRQ_MAC_NUBUS, via_nubus_irq,
 			IRQ_FLG_LOCK|IRQ_FLG_FAST, "nubus", (void *) via2))
 		pr_err("Couldn't register %s interrupt\n", "nubus");

commit 8852ecd97488249ca7fe2c0d3eb44cae95886881
Author: Laurent Vivier <laurent@lvivier.info>
Date:   Sat Nov 15 16:10:10 2008 +0100

    m68k: mac - Add SWIM floppy support
    
    It allows to read data from a floppy, but not to write to, and to eject the
    floppy (useful on our Mac without eject button).
    
    Signed-off-by: Laurent Vivier <Laurent@lvivier.info>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 7d97ba54536e..11bce3cb6482 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -645,3 +645,12 @@ int via_irq_pending(int irq)
 	}
 	return 0;
 }
+
+void via1_set_head(int head)
+{
+	if (head == 0)
+		via1[vBufA] &= ~VIA1A_vHeadSel;
+	else
+		via1[vBufA] |= VIA1A_vHeadSel;
+}
+EXPORT_SYMBOL(via1_set_head);

commit 92c3dd15cd0589adf66c13c7b6114790c207e5a2
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Dec 30 14:02:27 2008 +0100

    m68k: mac core - Kill warn_unused_result warnings
    
    warning: ignoring return value of 'request_irq', declared with attribute
    warn_unused_result
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index dfffb9c483a2..7d97ba54536e 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -283,7 +283,8 @@ void __init via_init_clock(irq_handler_t func)
 	via1[vT1CL] = MAC_CLOCK_LOW;
 	via1[vT1CH] = MAC_CLOCK_HIGH;
 
-	request_irq(IRQ_MAC_TIMER_1, func, IRQ_FLG_LOCK, "timer", func);
+	if (request_irq(IRQ_MAC_TIMER_1, func, IRQ_FLG_LOCK, "timer", func))
+		pr_err("Couldn't register %s interrupt\n", "timer");
 }
 
 /*
@@ -293,25 +294,31 @@ void __init via_init_clock(irq_handler_t func)
 void __init via_register_interrupts(void)
 {
 	if (via_alt_mapping) {
-		request_irq(IRQ_AUTO_1, via1_irq,
+		if (request_irq(IRQ_AUTO_1, via1_irq,
 				IRQ_FLG_LOCK|IRQ_FLG_FAST, "software",
-				(void *) via1);
-		request_irq(IRQ_AUTO_6, via1_irq,
+				(void *) via1))
+			pr_err("Couldn't register %s interrupt\n", "software");
+		if (request_irq(IRQ_AUTO_6, via1_irq,
 				IRQ_FLG_LOCK|IRQ_FLG_FAST, "via1",
-				(void *) via1);
+				(void *) via1))
+			pr_err("Couldn't register %s interrupt\n", "via1");
 	} else {
-		request_irq(IRQ_AUTO_1, via1_irq,
+		if (request_irq(IRQ_AUTO_1, via1_irq,
 				IRQ_FLG_LOCK|IRQ_FLG_FAST, "via1",
-				(void *) via1);
+				(void *) via1))
+			pr_err("Couldn't register %s interrupt\n", "via1");
 	}
-	request_irq(IRQ_AUTO_2, via2_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
-			"via2", (void *) via2);
+	if (request_irq(IRQ_AUTO_2, via2_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
+			"via2", (void *) via2))
+		pr_err("Couldn't register %s interrupt\n", "via2");
 	if (!psc_present) {
-		request_irq(IRQ_AUTO_4, mac_scc_dispatch, IRQ_FLG_LOCK,
-				"scc", mac_scc_dispatch);
+		if (request_irq(IRQ_AUTO_4, mac_scc_dispatch, IRQ_FLG_LOCK,
+				"scc", mac_scc_dispatch))
+			pr_err("Couldn't register %s interrupt\n", "scc");
 	}
-	request_irq(IRQ_MAC_NUBUS, via_nubus_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
-			"nubus", (void *) via2);
+	if (request_irq(IRQ_MAC_NUBUS, via_nubus_irq,
+			IRQ_FLG_LOCK|IRQ_FLG_FAST, "nubus", (void *) via2))
+		pr_err("Couldn't register %s interrupt\n", "nubus");
 }
 
 /*

commit c85627fbf5f47045b25bf66f1b4a7001b5b157af
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Dec 21 12:03:37 2008 +0100

    m68k: Kill several external declarations in source files
    
      - Replace external declarations by proper includes where availiable.
        The accesses to some symbols had to be modified, as before they were
        declared using e.g. "extern int _end", while asm-generic/sections.h uses
        e.g. "extern char _end[]"
      - Remove unused or superfluous external declarations
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index f01d418e64fe..dfffb9c483a2 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -34,6 +34,7 @@
 #include <asm/macints.h>
 #include <asm/mac_via.h>
 #include <asm/mac_psc.h>
+#include <asm/mac_oss.h>
 
 volatile __u8 *via1, *via2;
 int rbv_present;
@@ -84,7 +85,6 @@ void via_irq_disable(int irq);
 void via_irq_clear(int irq);
 
 extern irqreturn_t mac_scc_dispatch(int, void *);
-extern int oss_present;
 
 /*
  * Initialize the VIAs

commit 429dbf53bca49b110f1058f0d9417a59115c41b8
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Nov 18 20:45:20 2008 +0100

    m68k: machw.h cleanup
    
    Remove some more cruft from machw.h and drop the #include where it isn't
    needed.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 125404788e8d..f01d418e64fe 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -32,7 +32,6 @@
 #include <asm/bootinfo.h>
 #include <asm/macintosh.h>
 #include <asm/macints.h>
-#include <asm/machw.h>
 #include <asm/mac_via.h>
 #include <asm/mac_psc.h>
 

commit 4a973592d67ccc240bca694e48ce88facd764043
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Nov 18 20:45:20 2008 +0100

    m68k: Mac via cleanup and commentry
    
    No behavioural changes, just cleanups and better documentation.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 1bdb03c73c0f..125404788e8d 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -37,10 +37,6 @@
 #include <asm/mac_psc.h>
 
 volatile __u8 *via1, *via2;
-#if 0
-/* See note in mac_via.h about how this is possibly not useful */
-volatile long *via_memory_bogon=(long *)&via_memory_bogon;
-#endif
 int rbv_present;
 int via_alt_mapping;
 EXPORT_SYMBOL(via_alt_mapping);
@@ -66,7 +62,7 @@ static int gIER,gIFR,gBufA,gBufB;
 #define MAC_CLOCK_LOW		(MAC_CLOCK_TICK&0xFF)
 #define MAC_CLOCK_HIGH		(MAC_CLOCK_TICK>>8)
 
-/* To disable a NuBus slot on Quadras we make the slot IRQ lines outputs, set
+/* To disable a NuBus slot on Quadras we make that slot IRQ line an output set
  * high. On RBV we just use the slot interrupt enable register. On Macs with
  * genuine VIA chips we must use nubus_disabled to keep track of disabled slot
  * interrupts. When any slot IRQ is disabled we mask the (edge triggered) CA1
@@ -180,7 +176,7 @@ void __init via_init(void)
 	via1[vT1CH] = 0;
 	via1[vT2CL] = 0;
 	via1[vT2CH] = 0;
-	via1[vACR] &= 0x3F;
+	via1[vACR] &= ~0xC0; /* setup T1 timer with no PB7 output */
 	via1[vACR] &= ~0x03; /* disable port A & B latches */
 
 	/*
@@ -203,40 +199,41 @@ void __init via_init(void)
 
 	/* Everything below this point is VIA2/RBV only... */
 
-	if (oss_present) return;
+	if (oss_present)
+		return;
 
-#if 1
 	/* Some machines support an alternate IRQ mapping that spreads  */
 	/* Ethernet and Sound out to their own autolevel IRQs and moves */
 	/* VIA1 to level 6. A/UX uses this mapping and we do too.  Note */
 	/* that the IIfx emulates this alternate mapping using the OSS. */
 
-	switch(macintosh_config->ident) {
-		case MAC_MODEL_P475:
-		case MAC_MODEL_P475F:
-		case MAC_MODEL_P575:
-		case MAC_MODEL_Q605:
-		case MAC_MODEL_Q605_ACC:
-		case MAC_MODEL_C610:
-		case MAC_MODEL_Q610:
-		case MAC_MODEL_Q630:
-		case MAC_MODEL_C650:
-		case MAC_MODEL_Q650:
-		case MAC_MODEL_Q700:
-		case MAC_MODEL_Q800:
-		case MAC_MODEL_Q900:
-		case MAC_MODEL_Q950:
+	via_alt_mapping = 0;
+	if (macintosh_config->via_type == MAC_VIA_QUADRA)
+		switch (macintosh_config->ident) {
+		case MAC_MODEL_C660:
+		case MAC_MODEL_Q840:
+			/* not applicable */
+			break;
+		case MAC_MODEL_P588:
+		case MAC_MODEL_TV:
+		case MAC_MODEL_PB140:
+		case MAC_MODEL_PB145:
+		case MAC_MODEL_PB160:
+		case MAC_MODEL_PB165:
+		case MAC_MODEL_PB165C:
+		case MAC_MODEL_PB170:
+		case MAC_MODEL_PB180:
+		case MAC_MODEL_PB180C:
+		case MAC_MODEL_PB190:
+		case MAC_MODEL_PB520:
+			/* not yet tested */
+			break;
+		default:
 			via_alt_mapping = 1;
 			via1[vDirB] |= 0x40;
 			via1[vBufB] &= ~0x40;
 			break;
-		default:
-			via_alt_mapping = 0;
-			break;
-	}
-#else
-	via_alt_mapping = 0;
-#endif
+		}
 
 	/*
 	 * Now initialize VIA2. For RBV we just kill all interrupts;
@@ -252,14 +249,17 @@ void __init via_init(void)
 		via2[vT1CH] = 0;
 		via2[vT2CL] = 0;
 		via2[vT2CH] = 0;
-		via2[vACR] &= 0x3F;
+		via2[vACR] &= ~0xC0; /* setup T1 timer with no PB7 output */
 		via2[vACR] &= ~0x03; /* disable port A & B latches */
 	}
 
 	/*
-	 * Set vPCR for SCSI interrupts (but not on RBV)
+	 * Set vPCR for control line interrupts (but not on RBV)
 	 */
 	if (!rbv_present) {
+		/* For all VIA types, CA1 (SLOTS IRQ) and CB1 (ASC IRQ)
+		 * are made negative edge triggered here.
+		 */
 		if (macintosh_config->scsi_type == MAC_SCSI_OLD) {
 			/* CB2 (IRQ) indep. input, positive edge */
 			/* CA2 (DRQ) indep. input, positive edge */
@@ -466,21 +466,6 @@ irqreturn_t via1_irq(int irq, void *dev_id)
 		++irq_num;
 		irq_bit <<= 1;
 	} while (events >= irq_bit);
-
-#if 0 /* freakin' pmu is doing weird stuff */
-	if (!oss_present) {
-		/* This (still) seems to be necessary to get IDE
-		   working.  However, if you enable VBL interrupts,
-		   you're screwed... */
-		/* FIXME: should we check the SLOTIRQ bit before
-                   pulling this stunt? */
-		/* No, it won't be set. that's why we're doing this. */
-		via_irq_disable(IRQ_MAC_NUBUS);
-		via_irq_clear(IRQ_MAC_NUBUS);
-		m68k_handle_int(IRQ_MAC_NUBUS);
-		via_irq_enable(IRQ_MAC_NUBUS);
-	}
-#endif
 	return IRQ_HANDLED;
 }
 

commit 0e25f710618ce919ac5ae4850c90d3fca19565c3
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Aug 5 18:17:00 2008 +0200

    remove unneeded #include <linux/ide.h>'s
    
    This patch remove unneeded #include <linux/ide.h>'s.
    
    It also adds a required #include <linux/interrupt.h> that was previously
    implicitely pulled by ide.h
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    [bart: revert change to tests/lkdtm.c (spotted by Stephen Rothwell)]
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index f3b27d04a31f..1bdb03c73c0f 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -27,7 +27,6 @@
 #include <linux/mm.h>
 #include <linux/delay.h>
 #include <linux/init.h>
-#include <linux/ide.h>
 #include <linux/module.h>
 
 #include <asm/bootinfo.h>

commit 8dfbdf4abad6e5a7bbd097bf7e2c0ec41e0c54b4
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jul 17 21:16:25 2008 +0200

    m68k/mac/: possible cleanups
    
    This patch contains the following possible cleanups:
    - make the following needlessly global code (always) static:
      - baboon.c: struct baboon
      - baboon.c: baboon_irq()
      - config.c: mac_orig_videoaddr
      - config.c: mac_identify()
      - config.c: mac_report_hardware()
      - config.c: mac_debug_console_write()
      - config.c: mac_sccb_console_write()
      - config.c: mac_scca_console_write()
      - config.c: mac_init_scc_port()
      - oss.c: oss_irq()
      - oss.c: oss_nubus_irq()
      - psc.c: psc_debug_dump()
      - psc.c: psc_dma_die_die_die()
      - via.c: rbv_clear
    - remove the unused bootparse.c
    - #if 0 the following unused functions:
      - config.c: mac_debugging_short()
      - config.c: mac_debugging_long()
    - remove the following unused code:
      - config.c: mac_bisize
      - config.c: mac_env
      - config.c: mac_SCC_init_done
      - config.c: mac_SCC_reset_done
      - config.c: mac_init_scca_port()
      - config.c: mac_init_sccb_port()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index fa485df4160e..f3b27d04a31f 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -45,7 +45,7 @@ volatile long *via_memory_bogon=(long *)&via_memory_bogon;
 int rbv_present;
 int via_alt_mapping;
 EXPORT_SYMBOL(via_alt_mapping);
-__u8 rbv_clear;
+static __u8 rbv_clear;
 
 /*
  * Globals for accessing the VIA chip registers without having to

commit deea7775e2ae460aace0bf7b5bb2ff3b412017f1
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Feb 4 22:30:24 2008 -0800

    m68k: kill arch/m68k/mac/mac_ksyms.c
    
    EXPORT_SYMBOL's belong to the actual code.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 8df270e950fa..fa485df4160e 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -28,6 +28,7 @@
 #include <linux/delay.h>
 #include <linux/init.h>
 #include <linux/ide.h>
+#include <linux/module.h>
 
 #include <asm/bootinfo.h>
 #include <asm/macintosh.h>
@@ -41,7 +42,9 @@ volatile __u8 *via1, *via2;
 /* See note in mac_via.h about how this is possibly not useful */
 volatile long *via_memory_bogon=(long *)&via_memory_bogon;
 #endif
-int rbv_present, via_alt_mapping;
+int rbv_present;
+int via_alt_mapping;
+EXPORT_SYMBOL(via_alt_mapping);
 __u8 rbv_clear;
 
 /*

commit 0c79cf6af16c4a4c9ef539b52387de07f5ed62f5
Author: Simon Arlott <simon@fire.lp0.eu>
Date:   Sat Oct 20 01:20:32 2007 +0200

    spelling fixes: arch/m68k/
    
    Spelling fixes in arch/m68k/.
    
    Signed-off-by: Simon Arlott <simon@fire.lp0.eu>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index d5cac72eb3db..8df270e950fa 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -1,7 +1,7 @@
 /*
  *	6522 Versatile Interface Adapter (VIA)
  *
- *	There are two of these on the Mac II. Some IRQ's are vectored
+ *	There are two of these on the Mac II. Some IRQs are vectored
  *	via them as are assorted bits and bobs - eg RTC, ADB.
  *
  * CSA: Motorola seems to have removed documentation on the 6522 from

commit 217f6710c275118af1008bb1447d244be52d2dc3
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue May 1 22:32:58 2007 +0200

    m68k: Mac IRQ cleanup
    
    There are no slow IRQs on Macs since Roman Zippel's IRQ reorganisation that
    went into 2.6.16 and removed mac_irq_list[] and the do_mac_irq_list()
    dispatcher. (They were implemented in do_mac_irq_list() by lowering the IPL.)
    Hence there's no more use for mutual exclusion in the Mac interrupt
    dispatchers. Remove it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 83a3bb0c0325..d5cac72eb3db 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -443,11 +443,6 @@ void __init via_nubus_init(void)
 /*
  * The generic VIA interrupt routines (shamelessly stolen from Alan Cox's
  * via6522.c :-), disable/pending masks added.
- *
- * The new interrupt architecture in macints.c takes care of a lot of the
- * gruntwork for us, including tallying the interrupts and calling the
- * handlers on the linked list. All we need to do here is basically generate
- * the machspec interrupt number after clearing the interrupt.
  */
 
 irqreturn_t via1_irq(int irq, void *dev_id)
@@ -463,10 +458,8 @@ irqreturn_t via1_irq(int irq, void *dev_id)
 	irq_bit = 1;
 	do {
 		if (events & irq_bit) {
-			via1[vIER] = irq_bit;
 			via1[vIFR] = irq_bit;
 			m68k_handle_int(irq_num);
-			via1[vIER] = irq_bit | 0x80;
 		}
 		++irq_num;
 		irq_bit <<= 1;
@@ -502,11 +495,8 @@ irqreturn_t via2_irq(int irq, void *dev_id)
 	irq_bit = 1;
 	do {
 		if (events & irq_bit) {
-			via2[gIER] = irq_bit;
 			via2[gIFR] = irq_bit | rbv_clear;
 			m68k_handle_int(irq_num);
-			if (irq_num != IRQ_MAC_NUBUS || nubus_disabled == 0)
-				via2[gIER] = irq_bit | 0x80;
 		}
 		++irq_num;
 		irq_bit <<= 1;

commit cd713ddc93bf2f612783aea8eff6d0df6107765e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue May 1 22:32:57 2007 +0200

    m68k: Mac nubus IRQ fixes (plan E)
    
    Some Macs lack a slot interrupt enable register. So the existing code makes
    disabled and unregistered slot IRQ lines outputs set high. This seems to work
    on quadras, but does not work on genuine VIAs (perhaps the card still succeeds
    in pulling the line low, or perhaps because this increases the settle time on
    the port A input, meaning that the CA1 IRQ could fire before the slot line
    reads active).
    
    Because of this, the nubus_active flags were used to mask IRQs, which is
    actually worse than the problem it tries to solve. Any interrupt masked by
    nubus_active will remain asserted and prevent further transitions on CA1. And
    so the nubus gets wedged regardless of hardware (emulated VIA ASIC, real VIA
    chip or RBV).
    
    The best solution to this hardware limitation of genuine VIAs is to disable the
    umbrella SLOTS IRQ when disabling a slot on those machines. Unfortunately, this
    means all slot IRQs get disabled when any slot IRQ is disabled. But it is only
    a problem when there's more than 1 device using nubus interrupts.
    
    Another potential problem for genuine VIAs is an unregistered nubus IRQ.
    Eventually it will be possible to enable the CA1 interrupt by installing its
    handler only _after_ all nubus drivers have loaded but _before_ the kernel
    needs them, at which time this last problem can be fixed. For now it can be
    worked around:
    
      - disable MacOS extensions
      - don't boot MacOS (use the Emile bootloader instead)
      - get the bootloaders to disable ROM drivers (Penguin does this for video
        cards already, don't know about Emile)
      - physically remove unsupported cards
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 0c1cc45c570d..83a3bb0c0325 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -64,7 +64,19 @@ static int gIER,gIFR,gBufA,gBufB;
 #define MAC_CLOCK_LOW		(MAC_CLOCK_TICK&0xFF)
 #define MAC_CLOCK_HIGH		(MAC_CLOCK_TICK>>8)
 
-static int  nubus_active;
+/* To disable a NuBus slot on Quadras we make the slot IRQ lines outputs, set
+ * high. On RBV we just use the slot interrupt enable register. On Macs with
+ * genuine VIA chips we must use nubus_disabled to keep track of disabled slot
+ * interrupts. When any slot IRQ is disabled we mask the (edge triggered) CA1
+ * or "SLOTS" interrupt. When no slot is disabled, we unmask the CA1 interrupt.
+ * So, on genuine VIAs, having more than one NuBus IRQ can mean trouble,
+ * because closing one of those drivers can mask all of the NuBus interrupts.
+ * Also, since we can't mask the unregistered slot IRQs on genuine VIAs, it's
+ * possible to get interrupts from cards that MacOS or the ROM has configured
+ * but we have not. FWIW, "Designing Cards and Drivers for Macintosh II and
+ * Macintosh SE", page 9-8, says, a slot IRQ with no driver would crash MacOS.
+ */
+static u8 nubus_disabled;
 
 void via_debug_dump(void);
 irqreturn_t via1_irq(int, void *);
@@ -383,9 +395,6 @@ int via_get_cache_disable(void)
 
 void __init via_nubus_init(void)
 {
-	/* don't set nubus_active = 0 here, it kills the Baboon */
-	/* interrupt that we've already registered.		*/
-
 	/* unlock nubus transactions */
 
 	if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
@@ -399,28 +408,35 @@ void __init via_nubus_init(void)
 		via2[gBufB] |= 0x02;
 	}
 
-	/* disable nubus slot interrupts. */
-	if (rbv_present) {
+	/* Disable all the slot interrupts (where possible). */
+
+	switch (macintosh_config->via_type) {
+	case MAC_VIA_II:
+		/* Just make the port A lines inputs. */
+		switch(macintosh_config->ident) {
+		case MAC_MODEL_II:
+		case MAC_MODEL_IIX:
+		case MAC_MODEL_IICX:
+		case MAC_MODEL_SE30:
+			/* The top two bits are RAM size outputs. */
+			via2[vDirA] &= 0xC0;
+			break;
+		default:
+			via2[vDirA] &= 0x80;
+		}
+		break;
+	case MAC_VIA_IIci:
+		/* RBV. Disable all the slot interrupts. SIER works like IER. */
 		via2[rSIER] = 0x7F;
-		via2[rSIER] = nubus_active | 0x80;
-	} else {
-		/* These are ADB bits on PMU */
+		break;
+	case MAC_VIA_QUADRA:
+		/* Disable the inactive slot interrupts by making those lines outputs. */
 		if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
-		   (macintosh_config->adb_type != MAC_ADB_PB2)) {
-			switch(macintosh_config->ident)
-			{
-				case MAC_MODEL_II:
-				case MAC_MODEL_IIX:
-				case MAC_MODEL_IICX:
-				case MAC_MODEL_SE30:
-					via2[vBufA] |= 0x3F;
-					via2[vDirA] = ~nubus_active | 0xc0;
-					break;
-				default:
-					via2[vBufA] = 0xFF;
-					via2[vDirA] = ~nubus_active;
-			}
+		    (macintosh_config->adb_type != MAC_ADB_PB2)) {
+			via2[vBufA] |= 0x7F;
+			via2[vDirA] |= 0x7F;
 		}
+		break;
 	}
 }
 
@@ -489,7 +505,8 @@ irqreturn_t via2_irq(int irq, void *dev_id)
 			via2[gIER] = irq_bit;
 			via2[gIFR] = irq_bit | rbv_clear;
 			m68k_handle_int(irq_num);
-			via2[gIER] = irq_bit | 0x80;
+			if (irq_num != IRQ_MAC_NUBUS || nubus_disabled == 0)
+				via2[gIER] = irq_bit | 0x80;
 		}
 		++irq_num;
 		irq_bit <<= 1;
@@ -511,7 +528,7 @@ irqreturn_t via_nubus_irq(int irq, void *dev_id)
 	if (rbv_present)
 		events &= via2[rSIER];
 	else
-		events &= nubus_active;
+		events &= ~via2[vDirA];
 	if (!events)
 		return IRQ_NONE;
 
@@ -533,7 +550,7 @@ irqreturn_t via_nubus_irq(int irq, void *dev_id)
 		if (rbv_present)
 			events &= via2[rSIER];
 		else
-			events &= nubus_active;
+			events &= ~via2[vDirA];
 	} while (events);
 	return IRQ_HANDLED;
 }
@@ -541,38 +558,38 @@ irqreturn_t via_nubus_irq(int irq, void *dev_id)
 void via_irq_enable(int irq) {
 	int irq_src	= IRQ_SRC(irq);
 	int irq_idx	= IRQ_IDX(irq);
-	int irq_bit	= 1 << irq_idx;
 
 #ifdef DEBUG_IRQUSE
 	printk(KERN_DEBUG "via_irq_enable(%d)\n", irq);
 #endif
 
 	if (irq_src == 1) {
-		via1[vIER] = irq_bit | 0x80;
+		via1[vIER] = IER_SET_BIT(irq_idx);
 	} else if (irq_src == 2) {
-		via2[gIER] = irq_bit | 0x80;
+		if (irq != IRQ_MAC_NUBUS || nubus_disabled == 0)
+			via2[gIER] = IER_SET_BIT(irq_idx);
 	} else if (irq_src == 7) {
-		nubus_active |= irq_bit;
-		if (rbv_present) {
-			/* enable the slot interrupt. SIER works like IER. */
+		switch (macintosh_config->via_type) {
+		case MAC_VIA_II:
+			nubus_disabled &= ~(1 << irq_idx);
+			/* Enable the CA1 interrupt when no slot is disabled. */
+			if (!nubus_disabled)
+				via2[gIER] = IER_SET_BIT(1);
+			break;
+		case MAC_VIA_IIci:
+			/* On RBV, enable the slot interrupt.
+			 * SIER works like IER.
+			 */
 			via2[rSIER] = IER_SET_BIT(irq_idx);
-		} else {
-			/* Make sure the bit is an input, to enable the irq */
-			/* But not on PowerBooks, that's ADB... */
+			break;
+		case MAC_VIA_QUADRA:
+			/* Make the port A line an input to enable the slot irq.
+			 * But not on PowerBooks, that's ADB.
+			 */
 			if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
-			   (macintosh_config->adb_type != MAC_ADB_PB2)) {
-				switch(macintosh_config->ident)
-				{
-					case MAC_MODEL_II:
-					case MAC_MODEL_IIX:
-					case MAC_MODEL_IICX:
-					case MAC_MODEL_SE30:
-						via2[vDirA] &= (~irq_bit | 0xc0);
-						break;
-					default:
-						via2[vDirA] &= ~irq_bit;
-				}
-			}
+			    (macintosh_config->adb_type != MAC_ADB_PB2))
+				via2[vDirA] &= ~(1 << irq_idx);
+			break;
 		}
 	}
 }
@@ -580,29 +597,31 @@ void via_irq_enable(int irq) {
 void via_irq_disable(int irq) {
 	int irq_src	= IRQ_SRC(irq);
 	int irq_idx	= IRQ_IDX(irq);
-	int irq_bit	= 1 << irq_idx;
 
 #ifdef DEBUG_IRQUSE
 	printk(KERN_DEBUG "via_irq_disable(%d)\n", irq);
 #endif
 
 	if (irq_src == 1) {
-		via1[vIER] = irq_bit & 0x7F;
+		via1[vIER] = IER_CLR_BIT(irq_idx);
 	} else if (irq_src == 2) {
-		via2[gIER] = irq_bit & 0x7F;
+		via2[gIER] = IER_CLR_BIT(irq_idx);
 	} else if (irq_src == 7) {
-		if (rbv_present) {
-			/* disable the slot interrupt.  SIER works like IER. */
+		switch (macintosh_config->via_type) {
+		case MAC_VIA_II:
+			nubus_disabled |= 1 << irq_idx;
+			if (nubus_disabled)
+				via2[gIER] = IER_CLR_BIT(1);
+			break;
+		case MAC_VIA_IIci:
 			via2[rSIER] = IER_CLR_BIT(irq_idx);
-		} else {
-			/* disable the nubus irq by changing dir to output */
-			/* except on PMU */
+			break;
+		case MAC_VIA_QUADRA:
 			if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
-			   (macintosh_config->adb_type != MAC_ADB_PB2)) {
-				via2[vDirA] |= irq_bit;
-			}
+			    (macintosh_config->adb_type != MAC_ADB_PB2))
+				via2[vDirA] |= 1 << irq_idx;
+			break;
 		}
-		nubus_active &= ~irq_bit;
 	}
 }
 
@@ -638,7 +657,7 @@ int via_irq_pending(int irq)
 	} else if (irq_src == 2) {
 		return via2[gIFR] & irq_bit;
 	} else if (irq_src == 7) {
-		/* FIXME: this can't work while a slot irq is disabled! */
+		/* Always 0 for MAC_VIA_QUADRA if the slot irq is disabled. */
 		return ~via2[gBufA] & irq_bit;
 	}
 	return 0;

commit 67dfb153a352e57e71404d550be7eb60d15d7f2d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue May 1 22:32:56 2007 +0200

    m68k: Mac IRQ prep
    
    Make sure that there are no slot IRQs asserted before leaving the nubus
    handler. If there are and we don't then the nubus gets wedged because this
    prevents a CA1 transition, which means no more nubus IRQs.
    
    Make the interrupt dispatch loops terminate sooner.
    
    Explicitly initialise the VIA latches to make the code more easily understood.
    
    Also some cleanups.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 21b03180d9f4..0c1cc45c570d 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -13,6 +13,10 @@
  * for info.  A full-text web search on 6522 AND VIA will probably also
  * net some usefulness. <cananian@alumni.princeton.edu> 20apr1999
  *
+ * Additional data is here (the SY6522 was used in the Mac II etc):
+ *     http://www.6502.org/documents/datasheets/synertek/synertek_sy6522.pdf
+ *     http://www.6502.org/documents/datasheets/synertek/synertek_sy6522_programming_reference.pdf
+ *
  * PRAM/RTC access algorithms are from the NetBSD RTC toolkit version 1.08b
  * by Erik Vogan and adapted to Linux by Joshua M. Thompson (funaho@jurai.org)
  *
@@ -37,7 +41,7 @@ volatile __u8 *via1, *via2;
 /* See note in mac_via.h about how this is possibly not useful */
 volatile long *via_memory_bogon=(long *)&via_memory_bogon;
 #endif
-int  rbv_present,via_alt_mapping;
+int rbv_present, via_alt_mapping;
 __u8 rbv_clear;
 
 /*
@@ -138,11 +142,11 @@ void __init via_init(void)
 
 	printk(KERN_INFO "VIA2 at %p is ", via2);
 	if (rbv_present) {
-		printk(KERN_INFO "an RBV\n");
+		printk("an RBV\n");
 	} else if (oss_present) {
-		printk(KERN_INFO "an OSS\n");
+		printk("an OSS\n");
 	} else {
-		printk(KERN_INFO "a 6522 or clone\n");
+		printk("a 6522 or clone\n");
 	}
 
 #ifdef DEBUG_VIA
@@ -163,6 +167,7 @@ void __init via_init(void)
 	via1[vT2CL] = 0;
 	via1[vT2CH] = 0;
 	via1[vACR] &= 0x3F;
+	via1[vACR] &= ~0x03; /* disable port A & B latches */
 
 	/*
 	 * SE/30: disable video IRQ
@@ -234,6 +239,22 @@ void __init via_init(void)
 		via2[vT2CL] = 0;
 		via2[vT2CH] = 0;
 		via2[vACR] &= 0x3F;
+		via2[vACR] &= ~0x03; /* disable port A & B latches */
+	}
+
+	/*
+	 * Set vPCR for SCSI interrupts (but not on RBV)
+	 */
+	if (!rbv_present) {
+		if (macintosh_config->scsi_type == MAC_SCSI_OLD) {
+			/* CB2 (IRQ) indep. input, positive edge */
+			/* CA2 (DRQ) indep. input, positive edge */
+			via2[vPCR] = 0x66;
+		} else {
+			/* CB2 (IRQ) indep. input, negative edge */
+			/* CA2 (DRQ) indep. input, negative edge */
+			via2[vPCR] = 0x22;
+		}
 	}
 }
 
@@ -367,19 +388,14 @@ void __init via_nubus_init(void)
 
 	/* unlock nubus transactions */
 
-	if (!rbv_present) {
+	if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
+	    (macintosh_config->adb_type != MAC_ADB_PB2)) {
 		/* set the line to be an output on non-RBV machines */
-		if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
-		   (macintosh_config->adb_type != MAC_ADB_PB2)) {
+		if (!rbv_present)
 			via2[vDirB] |= 0x02;
-		}
-	}
-
-	/* this seems to be an ADB bit on PMU machines */
-	/* according to MkLinux.  -- jmt               */
 
-	if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
-	    (macintosh_config->adb_type != MAC_ADB_PB2)) {
+		/* this seems to be an ADB bit on PMU machines */
+		/* according to MkLinux.  -- jmt               */
 		via2[gBufB] |= 0x02;
 	}
 
@@ -420,20 +436,25 @@ void __init via_nubus_init(void)
 
 irqreturn_t via1_irq(int irq, void *dev_id)
 {
-	int irq_bit, i;
-	unsigned char events, mask;
+	int irq_num;
+	unsigned char irq_bit, events;
 
-	mask = via1[vIER] & 0x7F;
-	if (!(events = via1[vIFR] & mask))
+	events = via1[vIFR] & via1[vIER] & 0x7F;
+	if (!events)
 		return IRQ_NONE;
 
-	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1)
+	irq_num = VIA1_SOURCE_BASE;
+	irq_bit = 1;
+	do {
 		if (events & irq_bit) {
 			via1[vIER] = irq_bit;
 			via1[vIFR] = irq_bit;
-			m68k_handle_int(VIA1_SOURCE_BASE + i);
+			m68k_handle_int(irq_num);
 			via1[vIER] = irq_bit | 0x80;
 		}
+		++irq_num;
+		irq_bit <<= 1;
+	} while (events >= irq_bit);
 
 #if 0 /* freakin' pmu is doing weird stuff */
 	if (!oss_present) {
@@ -454,20 +475,25 @@ irqreturn_t via1_irq(int irq, void *dev_id)
 
 irqreturn_t via2_irq(int irq, void *dev_id)
 {
-	int irq_bit, i;
-	unsigned char events, mask;
+	int irq_num;
+	unsigned char irq_bit, events;
 
-	mask = via2[gIER] & 0x7F;
-	if (!(events = via2[gIFR] & mask))
+	events = via2[gIFR] & via2[gIER] & 0x7F;
+	if (!events)
 		return IRQ_NONE;
 
-	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1)
+	irq_num = VIA2_SOURCE_BASE;
+	irq_bit = 1;
+	do {
 		if (events & irq_bit) {
 			via2[gIER] = irq_bit;
 			via2[gIFR] = irq_bit | rbv_clear;
-			m68k_handle_int(VIA2_SOURCE_BASE + i);
+			m68k_handle_int(irq_num);
 			via2[gIER] = irq_bit | 0x80;
 		}
+		++irq_num;
+		irq_bit <<= 1;
+	} while (events >= irq_bit);
 	return IRQ_HANDLED;
 }
 
@@ -478,19 +504,37 @@ irqreturn_t via2_irq(int irq, void *dev_id)
 
 irqreturn_t via_nubus_irq(int irq, void *dev_id)
 {
-	int irq_bit, i;
-	unsigned char events;
-
-	if (!(events = ~via2[gBufA] & nubus_active))
+	int slot_irq;
+	unsigned char slot_bit, events;
+
+	events = ~via2[gBufA] & 0x7F;
+	if (rbv_present)
+		events &= via2[rSIER];
+	else
+		events &= nubus_active;
+	if (!events)
 		return IRQ_NONE;
 
-	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1) {
-		if (events & irq_bit) {
-			via_irq_disable(NUBUS_SOURCE_BASE + i);
-			m68k_handle_int(NUBUS_SOURCE_BASE + i);
-			via_irq_enable(NUBUS_SOURCE_BASE + i);
-		}
-	}
+	do {
+		slot_irq = IRQ_NUBUS_F;
+		slot_bit = 0x40;
+		do {
+			if (events & slot_bit) {
+				events &= ~slot_bit;
+				m68k_handle_int(slot_irq);
+			}
+			--slot_irq;
+			slot_bit >>= 1;
+		} while (events);
+
+ 		/* clear the CA1 interrupt and make certain there's no more. */
+		via2[gIFR] = 0x02 | rbv_clear;
+		events = ~via2[gBufA] & 0x7F;
+		if (rbv_present)
+			events &= via2[rSIER];
+		else
+			events &= nubus_active;
+	} while (events);
 	return IRQ_HANDLED;
 }
 
@@ -506,20 +550,6 @@ void via_irq_enable(int irq) {
 	if (irq_src == 1) {
 		via1[vIER] = irq_bit | 0x80;
 	} else if (irq_src == 2) {
-		/*
-		 * Set vPCR for SCSI interrupts (but not on RBV)
-		 */
-		if ((irq_idx == 0) && !rbv_present) {
-			if (macintosh_config->scsi_type == MAC_SCSI_OLD) {
-				/* CB2 (IRQ) indep. input, positive edge */
-				/* CA2 (DRQ) indep. input, positive edge */
-				via2[vPCR] = 0x66;
-			} else {
-				/* CB2 (IRQ) indep. input, negative edge */
-				/* CA2 (DRQ) indep. input, negative edge */
-				via2[vPCR] = 0x22;
-			}
-		}
 		via2[gIER] = irq_bit | 0x80;
 	} else if (irq_src == 7) {
 		nubus_active |= irq_bit;
@@ -557,9 +587,9 @@ void via_irq_disable(int irq) {
 #endif
 
 	if (irq_src == 1) {
-		via1[vIER] = irq_bit;
+		via1[vIER] = irq_bit & 0x7F;
 	} else if (irq_src == 2) {
-		via2[gIER] = irq_bit;
+		via2[gIER] = irq_bit & 0x7F;
 	} else if (irq_src == 7) {
 		if (rbv_present) {
 			/* disable the slot interrupt.  SIER works like IER. */
@@ -586,7 +616,9 @@ void via_irq_clear(int irq) {
 	} else if (irq_src == 2) {
 		via2[gIFR] = irq_bit | rbv_clear;
 	} else if (irq_src == 7) {
-		/* FIXME: hmm.. */
+		/* FIXME: There is no way to clear an individual nubus slot
+		 * IRQ flag, other than getting the device to do it.
+		 */
 	}
 }
 
@@ -606,6 +638,7 @@ int via_irq_pending(int irq)
 	} else if (irq_src == 2) {
 		return via2[gIFR] & irq_bit;
 	} else if (irq_src == 7) {
+		/* FIXME: this can't work while a slot irq is disabled! */
 		return ~via2[gBufA] & irq_bit;
 	}
 	return 0;

commit 647b804c8237aa35e19caf8e11ea8d5565107b0e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue May 1 22:32:55 2007 +0200

    m68k: reverse Mac IRQ damage
    
    Reverse the last of a monumental brown-paper-bag commit that went into the 2.3
    kernel.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 2be7b9cc5b32..21b03180d9f4 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -430,8 +430,8 @@ irqreturn_t via1_irq(int irq, void *dev_id)
 	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1)
 		if (events & irq_bit) {
 			via1[vIER] = irq_bit;
-			m68k_handle_int(VIA1_SOURCE_BASE + i);
 			via1[vIFR] = irq_bit;
+			m68k_handle_int(VIA1_SOURCE_BASE + i);
 			via1[vIER] = irq_bit | 0x80;
 		}
 

commit e10e5c4325b37e1a7dce9cd3d2cbcd8dd9536a7a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue May 1 22:32:52 2007 +0200

    m68k: Mac interrupt priorities
    
    Add some more machines that support A/UX interrupt priorities. There are
    probably others as well, but I've only tested these ones so far.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index e27735be2924..2be7b9cc5b32 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -193,8 +193,14 @@ void __init via_init(void)
 	/* that the IIfx emulates this alternate mapping using the OSS. */
 
 	switch(macintosh_config->ident) {
+		case MAC_MODEL_P475:
+		case MAC_MODEL_P475F:
+		case MAC_MODEL_P575:
+		case MAC_MODEL_Q605:
+		case MAC_MODEL_Q605_ACC:
 		case MAC_MODEL_C610:
 		case MAC_MODEL_Q610:
+		case MAC_MODEL_Q630:
 		case MAC_MODEL_C650:
 		case MAC_MODEL_Q650:
 		case MAC_MODEL_Q700:

commit 40220c1a192f51695f806d75b1f9970f0f17a6e8
Author: David Howells <dhowells@redhat.com>
Date:   Mon Oct 9 12:19:47 2006 +0100

    IRQ: Use the new typedef for interrupt handler function pointers
    
    Use the new typedef for interrupt handler function pointers rather than
    actually spelling out the full thing each time.  This was scripted with the
    following small shell script:
    
    #!/bin/sh
    egrep -nHrl -e 'irqreturn_t[    ]*[(][*]' $* |
    while read i
    do
        echo $i
        perl -pi -e 's/irqreturn_t\s*[(]\s*[*]\s*([_a-zA-Z0-9]*)\s*[)]\s*[(]\s*int\s*,\s*void\s*[*]\s*[)]/irq_handler_t \1/g' $i || exit $?
    done
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index 9b6c80c4bbe2..e27735be2924 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -235,7 +235,7 @@ void __init via_init(void)
  * Start the 100 Hz clock
  */
 
-void __init via_init_clock(irqreturn_t (*func)(int, void *))
+void __init via_init_clock(irq_handler_t func)
 {
 	via1[vACR] |= 0x40;
 	via1[vT1LL] = MAC_CLOCK_LOW;

commit 2850bc273776cbb1b510c5828e9e456dffb50a32
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Oct 7 14:16:45 2006 +0100

    [PATCH] m68k pt_regs fixes
    
    m68k_handle_int() split in two functions: __m68k_handle_int() takes
    pt_regs * and does set_irq_regs(); m68k_handle_int() doesn't get pt_regs
    *.
    
    Places where we used to call m68k_handle_int() recursively with the same
    pt_regs have simply lost the second argument, the rest is switched to
    __m68k_handle_int().
    
    The rest of patch is just dropping pt_regs * where needed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index c4aa345d544e..9b6c80c4bbe2 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -63,14 +63,14 @@ static int gIER,gIFR,gBufA,gBufB;
 static int  nubus_active;
 
 void via_debug_dump(void);
-irqreturn_t via1_irq(int, void *, struct pt_regs *);
-irqreturn_t via2_irq(int, void *, struct pt_regs *);
-irqreturn_t via_nubus_irq(int, void *, struct pt_regs *);
+irqreturn_t via1_irq(int, void *);
+irqreturn_t via2_irq(int, void *);
+irqreturn_t via_nubus_irq(int, void *);
 void via_irq_enable(int irq);
 void via_irq_disable(int irq);
 void via_irq_clear(int irq);
 
-extern irqreturn_t mac_scc_dispatch(int, void *, struct pt_regs *);
+extern irqreturn_t mac_scc_dispatch(int, void *);
 extern int oss_present;
 
 /*
@@ -235,7 +235,7 @@ void __init via_init(void)
  * Start the 100 Hz clock
  */
 
-void __init via_init_clock(irqreturn_t (*func)(int, void *, struct pt_regs *))
+void __init via_init_clock(irqreturn_t (*func)(int, void *))
 {
 	via1[vACR] |= 0x40;
 	via1[vT1LL] = MAC_CLOCK_LOW;
@@ -412,7 +412,7 @@ void __init via_nubus_init(void)
  * the machspec interrupt number after clearing the interrupt.
  */
 
-irqreturn_t via1_irq(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t via1_irq(int irq, void *dev_id)
 {
 	int irq_bit, i;
 	unsigned char events, mask;
@@ -424,7 +424,7 @@ irqreturn_t via1_irq(int irq, void *dev_id, struct pt_regs *regs)
 	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1)
 		if (events & irq_bit) {
 			via1[vIER] = irq_bit;
-			m68k_handle_int(VIA1_SOURCE_BASE + i, regs);
+			m68k_handle_int(VIA1_SOURCE_BASE + i);
 			via1[vIFR] = irq_bit;
 			via1[vIER] = irq_bit | 0x80;
 		}
@@ -439,14 +439,14 @@ irqreturn_t via1_irq(int irq, void *dev_id, struct pt_regs *regs)
 		/* No, it won't be set. that's why we're doing this. */
 		via_irq_disable(IRQ_MAC_NUBUS);
 		via_irq_clear(IRQ_MAC_NUBUS);
-		m68k_handle_int(IRQ_MAC_NUBUS, regs);
+		m68k_handle_int(IRQ_MAC_NUBUS);
 		via_irq_enable(IRQ_MAC_NUBUS);
 	}
 #endif
 	return IRQ_HANDLED;
 }
 
-irqreturn_t via2_irq(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t via2_irq(int irq, void *dev_id)
 {
 	int irq_bit, i;
 	unsigned char events, mask;
@@ -459,7 +459,7 @@ irqreturn_t via2_irq(int irq, void *dev_id, struct pt_regs *regs)
 		if (events & irq_bit) {
 			via2[gIER] = irq_bit;
 			via2[gIFR] = irq_bit | rbv_clear;
-			m68k_handle_int(VIA2_SOURCE_BASE + i, regs);
+			m68k_handle_int(VIA2_SOURCE_BASE + i);
 			via2[gIER] = irq_bit | 0x80;
 		}
 	return IRQ_HANDLED;
@@ -470,7 +470,7 @@ irqreturn_t via2_irq(int irq, void *dev_id, struct pt_regs *regs)
  * VIA2 dispatcher as a fast interrupt handler.
  */
 
-irqreturn_t via_nubus_irq(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t via_nubus_irq(int irq, void *dev_id)
 {
 	int irq_bit, i;
 	unsigned char events;
@@ -481,7 +481,7 @@ irqreturn_t via_nubus_irq(int irq, void *dev_id, struct pt_regs *regs)
 	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1) {
 		if (events & irq_bit) {
 			via_irq_disable(NUBUS_SOURCE_BASE + i);
-			m68k_handle_int(NUBUS_SOURCE_BASE + i, regs);
+			m68k_handle_int(NUBUS_SOURCE_BASE + i);
 			via_irq_enable(NUBUS_SOURCE_BASE + i);
 		}
 	}

commit 9c5f4afdfbe72d5d1c814ad7286a4524d00c7b96
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:04 2006 -0700

    [PATCH] m68k: convert mac irq code
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index a6e3814c8666..c4aa345d544e 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -253,21 +253,21 @@ void __init via_init_clock(irqreturn_t (*func)(int, void *, struct pt_regs *))
 void __init via_register_interrupts(void)
 {
 	if (via_alt_mapping) {
-		cpu_request_irq(IRQ_AUTO_1, via1_irq,
+		request_irq(IRQ_AUTO_1, via1_irq,
 				IRQ_FLG_LOCK|IRQ_FLG_FAST, "software",
 				(void *) via1);
-		cpu_request_irq(IRQ_AUTO_6, via1_irq,
+		request_irq(IRQ_AUTO_6, via1_irq,
 				IRQ_FLG_LOCK|IRQ_FLG_FAST, "via1",
 				(void *) via1);
 	} else {
-		cpu_request_irq(IRQ_AUTO_1, via1_irq,
+		request_irq(IRQ_AUTO_1, via1_irq,
 				IRQ_FLG_LOCK|IRQ_FLG_FAST, "via1",
 				(void *) via1);
 	}
-	cpu_request_irq(IRQ_AUTO_2, via2_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
+	request_irq(IRQ_AUTO_2, via2_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
 			"via2", (void *) via2);
 	if (!psc_present) {
-		cpu_request_irq(IRQ_AUTO_4, mac_scc_dispatch, IRQ_FLG_LOCK,
+		request_irq(IRQ_AUTO_4, mac_scc_dispatch, IRQ_FLG_LOCK,
 				"scc", mac_scc_dispatch);
 	}
 	request_irq(IRQ_MAC_NUBUS, via_nubus_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
@@ -424,7 +424,7 @@ irqreturn_t via1_irq(int irq, void *dev_id, struct pt_regs *regs)
 	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1)
 		if (events & irq_bit) {
 			via1[vIER] = irq_bit;
-			mac_do_irq_list(VIA1_SOURCE_BASE + i, regs);
+			m68k_handle_int(VIA1_SOURCE_BASE + i, regs);
 			via1[vIFR] = irq_bit;
 			via1[vIER] = irq_bit | 0x80;
 		}
@@ -439,7 +439,7 @@ irqreturn_t via1_irq(int irq, void *dev_id, struct pt_regs *regs)
 		/* No, it won't be set. that's why we're doing this. */
 		via_irq_disable(IRQ_MAC_NUBUS);
 		via_irq_clear(IRQ_MAC_NUBUS);
-		mac_do_irq_list(IRQ_MAC_NUBUS, regs);
+		m68k_handle_int(IRQ_MAC_NUBUS, regs);
 		via_irq_enable(IRQ_MAC_NUBUS);
 	}
 #endif
@@ -459,7 +459,7 @@ irqreturn_t via2_irq(int irq, void *dev_id, struct pt_regs *regs)
 		if (events & irq_bit) {
 			via2[gIER] = irq_bit;
 			via2[gIFR] = irq_bit | rbv_clear;
-			mac_do_irq_list(VIA2_SOURCE_BASE + i, regs);
+			m68k_handle_int(VIA2_SOURCE_BASE + i, regs);
 			via2[gIER] = irq_bit | 0x80;
 		}
 	return IRQ_HANDLED;
@@ -481,7 +481,7 @@ irqreturn_t via_nubus_irq(int irq, void *dev_id, struct pt_regs *regs)
 	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1) {
 		if (events & irq_bit) {
 			via_irq_disable(NUBUS_SOURCE_BASE + i);
-			mac_do_irq_list(NUBUS_SOURCE_BASE + i, regs);
+			m68k_handle_int(NUBUS_SOURCE_BASE + i, regs);
 			via_irq_enable(NUBUS_SOURCE_BASE + i);
 		}
 	}

commit 1a23989475846547e5b7ce14e77f072894aaff54
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Fri Jun 23 02:04:59 2006 -0700

    [PATCH] m68k: m68k mac VIA2 fixes and cleanups
    
    Some fixes and cleanups from the linux-mac68k repo.  Fix mac_esp by clearing
    the VIA2 SCSI IRQ flag before the SCSI IRQ handler is invoked.  Also fix a
    race condition caused by unmasking a nubus slot IRQ then setting the relevant
    nubus_active bit.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
index cd528bf7b43f..a6e3814c8666 100644
--- a/arch/m68k/mac/via.c
+++ b/arch/m68k/mac/via.c
@@ -25,7 +25,6 @@
 #include <linux/init.h>
 #include <linux/ide.h>
 
-#include <asm/traps.h>
 #include <asm/bootinfo.h>
 #include <asm/macintosh.h>
 #include <asm/macints.h>
@@ -71,7 +70,6 @@ void via_irq_enable(int irq);
 void via_irq_disable(int irq);
 void via_irq_clear(int irq);
 
-extern irqreturn_t mac_bang(int, void *, struct pt_regs *);
 extern irqreturn_t mac_scc_dispatch(int, void *, struct pt_regs *);
 extern int oss_present;
 
@@ -212,11 +210,6 @@ void __init via_init(void)
 			break;
 	}
 #else
-	/* The alernate IRQ mapping seems to just not work. Anyone with a   */
-	/* supported machine is welcome to take a stab at fixing it. It     */
-	/* _should_ work on the following Quadras: 610,650,700,800,900,950  */
-	/*                                               - 1999-06-12 (jmt) */
-
 	via_alt_mapping = 0;
 #endif
 
@@ -270,12 +263,6 @@ void __init via_register_interrupts(void)
 		cpu_request_irq(IRQ_AUTO_1, via1_irq,
 				IRQ_FLG_LOCK|IRQ_FLG_FAST, "via1",
 				(void *) via1);
-#if 0 /* interferes with serial on some machines */
-		if (!psc_present) {
-			cpu_request_irq(IRQ_AUTO_6, mac_bang, IRQ_FLG_LOCK,
-					"Off Switch", mac_bang);
-		}
-#endif
 	}
 	cpu_request_irq(IRQ_AUTO_2, via2_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
 			"via2", (void *) via2);
@@ -471,8 +458,8 @@ irqreturn_t via2_irq(int irq, void *dev_id, struct pt_regs *regs)
 	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1)
 		if (events & irq_bit) {
 			via2[gIER] = irq_bit;
-			mac_do_irq_list(VIA2_SOURCE_BASE + i, regs);
 			via2[gIFR] = irq_bit | rbv_clear;
+			mac_do_irq_list(VIA2_SOURCE_BASE + i, regs);
 			via2[gIER] = irq_bit | 0x80;
 		}
 	return IRQ_HANDLED;
@@ -529,6 +516,7 @@ void via_irq_enable(int irq) {
 		}
 		via2[gIER] = irq_bit | 0x80;
 	} else if (irq_src == 7) {
+		nubus_active |= irq_bit;
 		if (rbv_present) {
 			/* enable the slot interrupt. SIER works like IER. */
 			via2[rSIER] = IER_SET_BIT(irq_idx);
@@ -550,7 +538,6 @@ void via_irq_enable(int irq) {
 				}
 			}
 		}
-		nubus_active |= irq_bit;
 	}
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/mac/via.c b/arch/m68k/mac/via.c
new file mode 100644
index 000000000000..cd528bf7b43f
--- /dev/null
+++ b/arch/m68k/mac/via.c
@@ -0,0 +1,619 @@
+/*
+ *	6522 Versatile Interface Adapter (VIA)
+ *
+ *	There are two of these on the Mac II. Some IRQ's are vectored
+ *	via them as are assorted bits and bobs - eg RTC, ADB.
+ *
+ * CSA: Motorola seems to have removed documentation on the 6522 from
+ * their web site; try
+ *     http://nerini.drf.com/vectrex/other/text/chips/6522/
+ *     http://www.zymurgy.net/classic/vic20/vicdet1.htm
+ * and
+ *     http://193.23.168.87/mikro_laborversuche/via_iobaustein/via6522_1.html
+ * for info.  A full-text web search on 6522 AND VIA will probably also
+ * net some usefulness. <cananian@alumni.princeton.edu> 20apr1999
+ *
+ * PRAM/RTC access algorithms are from the NetBSD RTC toolkit version 1.08b
+ * by Erik Vogan and adapted to Linux by Joshua M. Thompson (funaho@jurai.org)
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/ide.h>
+
+#include <asm/traps.h>
+#include <asm/bootinfo.h>
+#include <asm/macintosh.h>
+#include <asm/macints.h>
+#include <asm/machw.h>
+#include <asm/mac_via.h>
+#include <asm/mac_psc.h>
+
+volatile __u8 *via1, *via2;
+#if 0
+/* See note in mac_via.h about how this is possibly not useful */
+volatile long *via_memory_bogon=(long *)&via_memory_bogon;
+#endif
+int  rbv_present,via_alt_mapping;
+__u8 rbv_clear;
+
+/*
+ * Globals for accessing the VIA chip registers without having to
+ * check if we're hitting a real VIA or an RBV. Normally you could
+ * just hit the combined register (ie, vIER|rIER) but that seems to
+ * break on AV Macs...probably because they actually decode more than
+ * eight address bits. Why can't Apple engineers at least be
+ * _consistently_ lazy?                          - 1999-05-21 (jmt)
+ */
+
+static int gIER,gIFR,gBufA,gBufB;
+
+/*
+ * Timer defs.
+ */
+
+#define TICK_SIZE		10000
+#define MAC_CLOCK_TICK		(783300/HZ)		/* ticks per HZ */
+#define MAC_CLOCK_LOW		(MAC_CLOCK_TICK&0xFF)
+#define MAC_CLOCK_HIGH		(MAC_CLOCK_TICK>>8)
+
+static int  nubus_active;
+
+void via_debug_dump(void);
+irqreturn_t via1_irq(int, void *, struct pt_regs *);
+irqreturn_t via2_irq(int, void *, struct pt_regs *);
+irqreturn_t via_nubus_irq(int, void *, struct pt_regs *);
+void via_irq_enable(int irq);
+void via_irq_disable(int irq);
+void via_irq_clear(int irq);
+
+extern irqreturn_t mac_bang(int, void *, struct pt_regs *);
+extern irqreturn_t mac_scc_dispatch(int, void *, struct pt_regs *);
+extern int oss_present;
+
+/*
+ * Initialize the VIAs
+ *
+ * First we figure out where they actually _are_ as well as what type of
+ * VIA we have for VIA2 (it could be a real VIA or an RBV or even an OSS.)
+ * Then we pretty much clear them out and disable all IRQ sources.
+ *
+ * Note: the OSS is actually "detected" here and not in oss_init(). It just
+ *	 seems more logical to do it here since via_init() needs to know
+ *	 these things anyways.
+ */
+
+void __init via_init(void)
+{
+	switch(macintosh_config->via_type) {
+
+		/* IIci, IIsi, IIvx, IIvi (P6xx), LC series */
+
+		case MAC_VIA_IIci:
+			via1 = (void *) VIA1_BASE;
+			if (macintosh_config->ident == MAC_MODEL_IIFX) {
+				via2 = NULL;
+				rbv_present = 0;
+				oss_present = 1;
+			} else {
+				via2 = (void *) RBV_BASE;
+				rbv_present = 1;
+				oss_present = 0;
+			}
+			if (macintosh_config->ident == MAC_MODEL_LCIII) {
+				rbv_clear = 0x00;
+			} else {
+				/* on most RBVs (& unlike the VIAs), you   */
+				/* need to set bit 7 when you write to IFR */
+				/* in order for your clear to occur.       */
+				rbv_clear = 0x80;
+			}
+			gIER = rIER;
+			gIFR = rIFR;
+			gBufA = rSIFR;
+			gBufB = rBufB;
+			break;
+
+		/* Quadra and early MacIIs agree on the VIA locations */
+
+		case MAC_VIA_QUADRA:
+		case MAC_VIA_II:
+			via1 = (void *) VIA1_BASE;
+			via2 = (void *) VIA2_BASE;
+			rbv_present = 0;
+			oss_present = 0;
+			rbv_clear = 0x00;
+			gIER = vIER;
+			gIFR = vIFR;
+			gBufA = vBufA;
+			gBufB = vBufB;
+			break;
+		default:
+			panic("UNKNOWN VIA TYPE");
+	}
+
+	printk(KERN_INFO "VIA1 at %p is a 6522 or clone\n", via1);
+
+	printk(KERN_INFO "VIA2 at %p is ", via2);
+	if (rbv_present) {
+		printk(KERN_INFO "an RBV\n");
+	} else if (oss_present) {
+		printk(KERN_INFO "an OSS\n");
+	} else {
+		printk(KERN_INFO "a 6522 or clone\n");
+	}
+
+#ifdef DEBUG_VIA
+	via_debug_dump();
+#endif
+
+	/*
+	 * Shut down all IRQ sources, reset the timers, and
+	 * kill the timer latch on VIA1.
+	 */
+
+	via1[vIER] = 0x7F;
+	via1[vIFR] = 0x7F;
+	via1[vT1LL] = 0;
+	via1[vT1LH] = 0;
+	via1[vT1CL] = 0;
+	via1[vT1CH] = 0;
+	via1[vT2CL] = 0;
+	via1[vT2CH] = 0;
+	via1[vACR] &= 0x3F;
+
+	/*
+	 * SE/30: disable video IRQ
+	 * XXX: testing for SE/30 VBL
+	 */
+
+	if (macintosh_config->ident == MAC_MODEL_SE30) {
+		via1[vDirB] |= 0x40;
+		via1[vBufB] |= 0x40;
+	}
+
+	/*
+	 * Set the RTC bits to a known state: all lines to outputs and
+	 * RTC disabled (yes that's 0 to enable and 1 to disable).
+	 */
+
+	via1[vDirB] |= (VIA1B_vRTCEnb | VIA1B_vRTCClk | VIA1B_vRTCData);
+	via1[vBufB] |= (VIA1B_vRTCEnb | VIA1B_vRTCClk);
+
+	/* Everything below this point is VIA2/RBV only... */
+
+	if (oss_present) return;
+
+#if 1
+	/* Some machines support an alternate IRQ mapping that spreads  */
+	/* Ethernet and Sound out to their own autolevel IRQs and moves */
+	/* VIA1 to level 6. A/UX uses this mapping and we do too.  Note */
+	/* that the IIfx emulates this alternate mapping using the OSS. */
+
+	switch(macintosh_config->ident) {
+		case MAC_MODEL_C610:
+		case MAC_MODEL_Q610:
+		case MAC_MODEL_C650:
+		case MAC_MODEL_Q650:
+		case MAC_MODEL_Q700:
+		case MAC_MODEL_Q800:
+		case MAC_MODEL_Q900:
+		case MAC_MODEL_Q950:
+			via_alt_mapping = 1;
+			via1[vDirB] |= 0x40;
+			via1[vBufB] &= ~0x40;
+			break;
+		default:
+			via_alt_mapping = 0;
+			break;
+	}
+#else
+	/* The alernate IRQ mapping seems to just not work. Anyone with a   */
+	/* supported machine is welcome to take a stab at fixing it. It     */
+	/* _should_ work on the following Quadras: 610,650,700,800,900,950  */
+	/*                                               - 1999-06-12 (jmt) */
+
+	via_alt_mapping = 0;
+#endif
+
+	/*
+	 * Now initialize VIA2. For RBV we just kill all interrupts;
+	 * for a regular VIA we also reset the timers and stuff.
+	 */
+
+	via2[gIER] = 0x7F;
+	via2[gIFR] = 0x7F | rbv_clear;
+	if (!rbv_present) {
+		via2[vT1LL] = 0;
+		via2[vT1LH] = 0;
+		via2[vT1CL] = 0;
+		via2[vT1CH] = 0;
+		via2[vT2CL] = 0;
+		via2[vT2CH] = 0;
+		via2[vACR] &= 0x3F;
+	}
+}
+
+/*
+ * Start the 100 Hz clock
+ */
+
+void __init via_init_clock(irqreturn_t (*func)(int, void *, struct pt_regs *))
+{
+	via1[vACR] |= 0x40;
+	via1[vT1LL] = MAC_CLOCK_LOW;
+	via1[vT1LH] = MAC_CLOCK_HIGH;
+	via1[vT1CL] = MAC_CLOCK_LOW;
+	via1[vT1CH] = MAC_CLOCK_HIGH;
+
+	request_irq(IRQ_MAC_TIMER_1, func, IRQ_FLG_LOCK, "timer", func);
+}
+
+/*
+ * Register the interrupt dispatchers for VIA or RBV machines only.
+ */
+
+void __init via_register_interrupts(void)
+{
+	if (via_alt_mapping) {
+		cpu_request_irq(IRQ_AUTO_1, via1_irq,
+				IRQ_FLG_LOCK|IRQ_FLG_FAST, "software",
+				(void *) via1);
+		cpu_request_irq(IRQ_AUTO_6, via1_irq,
+				IRQ_FLG_LOCK|IRQ_FLG_FAST, "via1",
+				(void *) via1);
+	} else {
+		cpu_request_irq(IRQ_AUTO_1, via1_irq,
+				IRQ_FLG_LOCK|IRQ_FLG_FAST, "via1",
+				(void *) via1);
+#if 0 /* interferes with serial on some machines */
+		if (!psc_present) {
+			cpu_request_irq(IRQ_AUTO_6, mac_bang, IRQ_FLG_LOCK,
+					"Off Switch", mac_bang);
+		}
+#endif
+	}
+	cpu_request_irq(IRQ_AUTO_2, via2_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
+			"via2", (void *) via2);
+	if (!psc_present) {
+		cpu_request_irq(IRQ_AUTO_4, mac_scc_dispatch, IRQ_FLG_LOCK,
+				"scc", mac_scc_dispatch);
+	}
+	request_irq(IRQ_MAC_NUBUS, via_nubus_irq, IRQ_FLG_LOCK|IRQ_FLG_FAST,
+			"nubus", (void *) via2);
+}
+
+/*
+ * Debugging dump, used in various places to see what's going on.
+ */
+
+void via_debug_dump(void)
+{
+	printk(KERN_DEBUG "VIA1: DDRA = 0x%02X DDRB = 0x%02X ACR = 0x%02X\n",
+		(uint) via1[vDirA], (uint) via1[vDirB], (uint) via1[vACR]);
+	printk(KERN_DEBUG "         PCR = 0x%02X  IFR = 0x%02X IER = 0x%02X\n",
+		(uint) via1[vPCR], (uint) via1[vIFR], (uint) via1[vIER]);
+	if (oss_present) {
+		printk(KERN_DEBUG "VIA2: <OSS>\n");
+	} else if (rbv_present) {
+		printk(KERN_DEBUG "VIA2:  IFR = 0x%02X  IER = 0x%02X\n",
+			(uint) via2[rIFR], (uint) via2[rIER]);
+		printk(KERN_DEBUG "      SIFR = 0x%02X SIER = 0x%02X\n",
+			(uint) via2[rSIFR], (uint) via2[rSIER]);
+	} else {
+		printk(KERN_DEBUG "VIA2: DDRA = 0x%02X DDRB = 0x%02X ACR = 0x%02X\n",
+			(uint) via2[vDirA], (uint) via2[vDirB],
+			(uint) via2[vACR]);
+		printk(KERN_DEBUG "         PCR = 0x%02X  IFR = 0x%02X IER = 0x%02X\n",
+			(uint) via2[vPCR],
+			(uint) via2[vIFR], (uint) via2[vIER]);
+	}
+}
+
+/*
+ * This is always executed with interrupts disabled.
+ *
+ * TBI: get time offset between scheduling timer ticks
+ */
+
+unsigned long mac_gettimeoffset (void)
+{
+	unsigned long ticks, offset = 0;
+
+	/* read VIA1 timer 2 current value */
+	ticks = via1[vT1CL] | (via1[vT1CH] << 8);
+	/* The probability of underflow is less than 2% */
+	if (ticks > MAC_CLOCK_TICK - MAC_CLOCK_TICK / 50)
+		/* Check for pending timer interrupt in VIA1 IFR */
+		if (via1[vIFR] & 0x40) offset = TICK_SIZE;
+
+	ticks = MAC_CLOCK_TICK - ticks;
+	ticks = ticks * 10000L / MAC_CLOCK_TICK;
+
+	return ticks + offset;
+}
+
+/*
+ * Flush the L2 cache on Macs that have it by flipping
+ * the system into 24-bit mode for an instant.
+ */
+
+void via_flush_cache(void)
+{
+	via2[gBufB] &= ~VIA2B_vMode32;
+	via2[gBufB] |= VIA2B_vMode32;
+}
+
+/*
+ * Return the status of the L2 cache on a IIci
+ */
+
+int via_get_cache_disable(void)
+{
+	/* Safeguard against being called accidentally */
+	if (!via2) {
+		printk(KERN_ERR "via_get_cache_disable called on a non-VIA machine!\n");
+		return 1;
+	}
+
+	return (int) via2[gBufB] & VIA2B_vCDis;
+}
+
+/*
+ * Initialize VIA2 for Nubus access
+ */
+
+void __init via_nubus_init(void)
+{
+	/* don't set nubus_active = 0 here, it kills the Baboon */
+	/* interrupt that we've already registered.		*/
+
+	/* unlock nubus transactions */
+
+	if (!rbv_present) {
+		/* set the line to be an output on non-RBV machines */
+		if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
+		   (macintosh_config->adb_type != MAC_ADB_PB2)) {
+			via2[vDirB] |= 0x02;
+		}
+	}
+
+	/* this seems to be an ADB bit on PMU machines */
+	/* according to MkLinux.  -- jmt               */
+
+	if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
+	    (macintosh_config->adb_type != MAC_ADB_PB2)) {
+		via2[gBufB] |= 0x02;
+	}
+
+	/* disable nubus slot interrupts. */
+	if (rbv_present) {
+		via2[rSIER] = 0x7F;
+		via2[rSIER] = nubus_active | 0x80;
+	} else {
+		/* These are ADB bits on PMU */
+		if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
+		   (macintosh_config->adb_type != MAC_ADB_PB2)) {
+			switch(macintosh_config->ident)
+			{
+				case MAC_MODEL_II:
+				case MAC_MODEL_IIX:
+				case MAC_MODEL_IICX:
+				case MAC_MODEL_SE30:
+					via2[vBufA] |= 0x3F;
+					via2[vDirA] = ~nubus_active | 0xc0;
+					break;
+				default:
+					via2[vBufA] = 0xFF;
+					via2[vDirA] = ~nubus_active;
+			}
+		}
+	}
+}
+
+/*
+ * The generic VIA interrupt routines (shamelessly stolen from Alan Cox's
+ * via6522.c :-), disable/pending masks added.
+ *
+ * The new interrupt architecture in macints.c takes care of a lot of the
+ * gruntwork for us, including tallying the interrupts and calling the
+ * handlers on the linked list. All we need to do here is basically generate
+ * the machspec interrupt number after clearing the interrupt.
+ */
+
+irqreturn_t via1_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int irq_bit, i;
+	unsigned char events, mask;
+
+	mask = via1[vIER] & 0x7F;
+	if (!(events = via1[vIFR] & mask))
+		return IRQ_NONE;
+
+	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1)
+		if (events & irq_bit) {
+			via1[vIER] = irq_bit;
+			mac_do_irq_list(VIA1_SOURCE_BASE + i, regs);
+			via1[vIFR] = irq_bit;
+			via1[vIER] = irq_bit | 0x80;
+		}
+
+#if 0 /* freakin' pmu is doing weird stuff */
+	if (!oss_present) {
+		/* This (still) seems to be necessary to get IDE
+		   working.  However, if you enable VBL interrupts,
+		   you're screwed... */
+		/* FIXME: should we check the SLOTIRQ bit before
+                   pulling this stunt? */
+		/* No, it won't be set. that's why we're doing this. */
+		via_irq_disable(IRQ_MAC_NUBUS);
+		via_irq_clear(IRQ_MAC_NUBUS);
+		mac_do_irq_list(IRQ_MAC_NUBUS, regs);
+		via_irq_enable(IRQ_MAC_NUBUS);
+	}
+#endif
+	return IRQ_HANDLED;
+}
+
+irqreturn_t via2_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int irq_bit, i;
+	unsigned char events, mask;
+
+	mask = via2[gIER] & 0x7F;
+	if (!(events = via2[gIFR] & mask))
+		return IRQ_NONE;
+
+	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1)
+		if (events & irq_bit) {
+			via2[gIER] = irq_bit;
+			mac_do_irq_list(VIA2_SOURCE_BASE + i, regs);
+			via2[gIFR] = irq_bit | rbv_clear;
+			via2[gIER] = irq_bit | 0x80;
+		}
+	return IRQ_HANDLED;
+}
+
+/*
+ * Dispatch Nubus interrupts. We are called as a secondary dispatch by the
+ * VIA2 dispatcher as a fast interrupt handler.
+ */
+
+irqreturn_t via_nubus_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int irq_bit, i;
+	unsigned char events;
+
+	if (!(events = ~via2[gBufA] & nubus_active))
+		return IRQ_NONE;
+
+	for (i = 0, irq_bit = 1 ; i < 7 ; i++, irq_bit <<= 1) {
+		if (events & irq_bit) {
+			via_irq_disable(NUBUS_SOURCE_BASE + i);
+			mac_do_irq_list(NUBUS_SOURCE_BASE + i, regs);
+			via_irq_enable(NUBUS_SOURCE_BASE + i);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+void via_irq_enable(int irq) {
+	int irq_src	= IRQ_SRC(irq);
+	int irq_idx	= IRQ_IDX(irq);
+	int irq_bit	= 1 << irq_idx;
+
+#ifdef DEBUG_IRQUSE
+	printk(KERN_DEBUG "via_irq_enable(%d)\n", irq);
+#endif
+
+	if (irq_src == 1) {
+		via1[vIER] = irq_bit | 0x80;
+	} else if (irq_src == 2) {
+		/*
+		 * Set vPCR for SCSI interrupts (but not on RBV)
+		 */
+		if ((irq_idx == 0) && !rbv_present) {
+			if (macintosh_config->scsi_type == MAC_SCSI_OLD) {
+				/* CB2 (IRQ) indep. input, positive edge */
+				/* CA2 (DRQ) indep. input, positive edge */
+				via2[vPCR] = 0x66;
+			} else {
+				/* CB2 (IRQ) indep. input, negative edge */
+				/* CA2 (DRQ) indep. input, negative edge */
+				via2[vPCR] = 0x22;
+			}
+		}
+		via2[gIER] = irq_bit | 0x80;
+	} else if (irq_src == 7) {
+		if (rbv_present) {
+			/* enable the slot interrupt. SIER works like IER. */
+			via2[rSIER] = IER_SET_BIT(irq_idx);
+		} else {
+			/* Make sure the bit is an input, to enable the irq */
+			/* But not on PowerBooks, that's ADB... */
+			if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
+			   (macintosh_config->adb_type != MAC_ADB_PB2)) {
+				switch(macintosh_config->ident)
+				{
+					case MAC_MODEL_II:
+					case MAC_MODEL_IIX:
+					case MAC_MODEL_IICX:
+					case MAC_MODEL_SE30:
+						via2[vDirA] &= (~irq_bit | 0xc0);
+						break;
+					default:
+						via2[vDirA] &= ~irq_bit;
+				}
+			}
+		}
+		nubus_active |= irq_bit;
+	}
+}
+
+void via_irq_disable(int irq) {
+	int irq_src	= IRQ_SRC(irq);
+	int irq_idx	= IRQ_IDX(irq);
+	int irq_bit	= 1 << irq_idx;
+
+#ifdef DEBUG_IRQUSE
+	printk(KERN_DEBUG "via_irq_disable(%d)\n", irq);
+#endif
+
+	if (irq_src == 1) {
+		via1[vIER] = irq_bit;
+	} else if (irq_src == 2) {
+		via2[gIER] = irq_bit;
+	} else if (irq_src == 7) {
+		if (rbv_present) {
+			/* disable the slot interrupt.  SIER works like IER. */
+			via2[rSIER] = IER_CLR_BIT(irq_idx);
+		} else {
+			/* disable the nubus irq by changing dir to output */
+			/* except on PMU */
+			if ((macintosh_config->adb_type != MAC_ADB_PB1) &&
+			   (macintosh_config->adb_type != MAC_ADB_PB2)) {
+				via2[vDirA] |= irq_bit;
+			}
+		}
+		nubus_active &= ~irq_bit;
+	}
+}
+
+void via_irq_clear(int irq) {
+	int irq_src	= IRQ_SRC(irq);
+	int irq_idx	= IRQ_IDX(irq);
+	int irq_bit	= 1 << irq_idx;
+
+	if (irq_src == 1) {
+		via1[vIFR] = irq_bit;
+	} else if (irq_src == 2) {
+		via2[gIFR] = irq_bit | rbv_clear;
+	} else if (irq_src == 7) {
+		/* FIXME: hmm.. */
+	}
+}
+
+/*
+ * Returns nonzero if an interrupt is pending on the given
+ * VIA/IRQ combination.
+ */
+
+int via_irq_pending(int irq)
+{
+	int irq_src	= IRQ_SRC(irq);
+	int irq_idx	= IRQ_IDX(irq);
+	int irq_bit	= 1 << irq_idx;
+
+	if (irq_src == 1) {
+		return via1[vIFR] & irq_bit;
+	} else if (irq_src == 2) {
+		return via2[gIFR] & irq_bit;
+	} else if (irq_src == 7) {
+		return ~via2[gBufA] & irq_bit;
+	}
+	return 0;
+}
