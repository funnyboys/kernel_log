commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 8d547df4e16c..0d0965b19c09 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *	Apple Peripheral System Controller (PSC)
  *

commit 0e37a23ebdadc0e34176b816770da6f4ac64043e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Thu Oct 26 22:45:24 2017 -0400

    m68k/mac: More printk modernization
    
    Log message fragments used to be printed on one line but now get split up.
    Fix this. Also, suppress log spam that merely prints known pointer values.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 439a2a2e5874..8d547df4e16c 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -42,7 +42,7 @@ static void psc_debug_dump(void)
 		return;
 
 	for (i = 0x30 ; i < 0x70 ; i += 0x10) {
-		printk("PSC #%d:  IFR = 0x%02X IER = 0x%02X\n",
+		printk(KERN_DEBUG "PSC #%d:  IFR = 0x%02X IER = 0x%02X\n",
 			i >> 4,
 			(int) psc_read_byte(pIFRbase + i),
 			(int) psc_read_byte(pIERbase + i));
@@ -59,14 +59,12 @@ static __init void psc_dma_die_die_die(void)
 {
 	int i;
 
-	printk("Killing all PSC DMA channels...");
 	for (i = 0 ; i < 9 ; i++) {
 		psc_write_word(PSC_CTL_BASE + (i << 4), 0x8800);
 		psc_write_word(PSC_CTL_BASE + (i << 4), 0x1000);
 		psc_write_word(PSC_CMD_BASE + (i << 5), 0x1100);
 		psc_write_word(PSC_CMD_BASE + (i << 5) + 0x10, 0x1100);
 	}
-	printk("done!\n");
 }
 
 /*
@@ -92,7 +90,7 @@ void __init psc_init(void)
 
 	psc = (void *) PSC_BASE;
 
-	printk("PSC detected at %p\n", psc);
+	pr_debug("PSC detected at %p\n", psc);
 
 	psc_dma_die_die_die();
 

commit 16a1a66a5e8324dd6a2864ceaf3e246fc11f93a5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Jan 2 04:53:54 2017 -0500

    m68k/mac: Clean up interrupt debug macros and printk statements
    
    Mac interrupt code has been debugged. The Penguin deficiencies that
    still cause unhandled interrupts aren't fixable here. Besides,
    interrupts are fast and frequent and these printk statements
    were never really useful IMO. Remove them.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index cb2b1a3a2b62..439a2a2e5874 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -122,11 +122,6 @@ static void psc_irq(struct irq_desc *desc)
 	int irq_num;
 	unsigned char irq_bit, events;
 
-#ifdef DEBUG_IRQS
-	printk("psc_irq: irq %u pIFR = 0x%02X pIER = 0x%02X\n",
-		irq, (int) psc_read_byte(pIFR), (int) psc_read_byte(pIER));
-#endif
-
 	events = psc_read_byte(pIFR) & psc_read_byte(pIER) & 0xF;
 	if (!events)
 		return;
@@ -160,9 +155,6 @@ void psc_irq_enable(int irq) {
 	int irq_idx	= IRQ_IDX(irq);
 	int pIER	= pIERbase + (irq_src << 4);
 
-#ifdef DEBUG_IRQUSE
-	printk("psc_irq_enable(%d)\n", irq);
-#endif
 	psc_write_byte(pIER, (1 << irq_idx) | 0x80);
 }
 
@@ -171,8 +163,5 @@ void psc_irq_disable(int irq) {
 	int irq_idx	= IRQ_IDX(irq);
 	int pIER	= pIERbase + (irq_src << 4);
 
-#ifdef DEBUG_IRQUSE
-	printk("psc_irq_disable(%d)\n", irq);
-#endif
 	psc_write_byte(pIER, 1 << irq_idx);
 }

commit 70bc53b473435f43dcf7d91304e28dd6e0ffda14
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Sep 29 09:27:22 2015 +0200

    m68k/mac: Kill psc_present
    
    The presence of the Apple Peripheral System Controller (PSC) can be
    tested for by just checking its base address pointer.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 2290c0cae48b..cb2b1a3a2b62 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -27,7 +27,6 @@
 
 #define DEBUG_PSC
 
-int psc_present;
 volatile __u8 *psc;
 EXPORT_SYMBOL_GPL(psc);
 
@@ -39,7 +38,9 @@ static void psc_debug_dump(void)
 {
 	int	i;
 
-	if (!psc_present) return;
+	if (!psc)
+		return;
+
 	for (i = 0x30 ; i < 0x70 ; i += 0x10) {
 		printk("PSC #%d:  IFR = 0x%02X IER = 0x%02X\n",
 			i >> 4,
@@ -81,7 +82,6 @@ void __init psc_init(void)
 	 && macintosh_config->ident != MAC_MODEL_Q840)
 	{
 		psc = NULL;
-		psc_present = 0;
 		return;
 	}
 
@@ -91,7 +91,6 @@ void __init psc_init(void)
 	 */
 
 	psc = (void *) PSC_BASE;
-	psc_present = 1;
 
 	printk("PSC detected at %p\n", psc);
 

commit a77cdaaf2dbc69743bc22354f81bc4ec5e452d40
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Sep 29 10:24:05 2015 +0200

    m68k/mac: Export Peripheral System Controller (PSC) base address to modules
    
    If CONFIG_MACMACE=m:
    
        ERROR: psc [drivers/net/ethernet/apple/macmace.ko] undefined!
    
    Add the missing export to fix this.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index cd38f29955c8..2290c0cae48b 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -29,6 +29,7 @@
 
 int psc_present;
 volatile __u8 *psc;
+EXPORT_SYMBOL_GPL(psc);
 
 /*
  * Debugging dump, used in various places to see what's going on.

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 3b9e302e7a37..cd38f29955c8 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -113,7 +113,7 @@ void __init psc_init(void)
  * PSC interrupt handler. It's a lot like the VIA interrupt handler.
  */
 
-static void psc_irq(unsigned int __irq, struct irq_desc *desc)
+static void psc_irq(struct irq_desc *desc)
 {
 	unsigned int offset = (unsigned int)irq_desc_get_handler_data(desc);
 	unsigned int irq = irq_desc_get_irq(desc);

commit 625b86ad26ad35200adc34094c04e04672384735
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 31 21:56:10 2015 +0200

    m68k/irq: Prepare irq handlers for irq argument removal
    
    The irq argument of most interrupt flow handlers is unused or merily
    used instead of a local variable. The handlers which need the irq
    argument can retrieve the irq number from the irq descriptor.
    
    Search and update was done with coccinelle and the invaluable help of
    Julia Lawall.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: linux-m68k@lists.linux-m68k.org

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 272dde481d17..3b9e302e7a37 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -113,9 +113,10 @@ void __init psc_init(void)
  * PSC interrupt handler. It's a lot like the VIA interrupt handler.
  */
 
-static void psc_irq(unsigned int irq, struct irq_desc *desc)
+static void psc_irq(unsigned int __irq, struct irq_desc *desc)
 {
 	unsigned int offset = (unsigned int)irq_desc_get_handler_data(desc);
+	unsigned int irq = irq_desc_get_irq(desc);
 	int pIFR	= pIFRbase + offset;
 	int pIER	= pIERbase + offset;
 	int irq_num;

commit 09c5cb942f7545e53819ee2ca72fe843d23880e5
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Jun 21 21:00:30 2015 +0200

    m68k/psc: Fix race in installing chained IRQ handler
    
    Fix a race where a pending interrupt could be received and the handler
    called before the handler's data has been setup, by converting to
    irq_set_chained_handler_and_data().
    
    Search and conversion was done with coccinelle:
    
    @@
    expression E1, E2, E3;
    @@
    (
    -if (irq_set_chained_handler(E1, E3) != 0)
    -   BUG();
    |
    -irq_set_chained_handler(E1, E3);
    )
    -irq_set_handler_data(E1, E2);
    +irq_set_chained_handler_and_data(E1, E3, E2);
    
    @@
    expression E1, E2, E3;
    @@
    (
    -if (irq_set_chained_handler(E1, E3) != 0)
    -   BUG();
    ...
    |
    -irq_set_chained_handler(E1, E3);
    ...
    )
    -irq_set_handler_data(E1, E2);
    +irq_set_chained_handler_and_data(E1, E3, E2);
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Joshua Thompson <funaho@jurai.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: linux-m68k@lists.linux-m68k.org

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 835fa04511c8..272dde481d17 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -148,14 +148,10 @@ static void psc_irq(unsigned int irq, struct irq_desc *desc)
 
 void __init psc_register_interrupts(void)
 {
-	irq_set_chained_handler(IRQ_AUTO_3, psc_irq);
-	irq_set_handler_data(IRQ_AUTO_3, (void *)0x30);
-	irq_set_chained_handler(IRQ_AUTO_4, psc_irq);
-	irq_set_handler_data(IRQ_AUTO_4, (void *)0x40);
-	irq_set_chained_handler(IRQ_AUTO_5, psc_irq);
-	irq_set_handler_data(IRQ_AUTO_5, (void *)0x50);
-	irq_set_chained_handler(IRQ_AUTO_6, psc_irq);
-	irq_set_handler_data(IRQ_AUTO_6, (void *)0x60);
+	irq_set_chained_handler_and_data(IRQ_AUTO_3, psc_irq, (void *)0x30);
+	irq_set_chained_handler_and_data(IRQ_AUTO_4, psc_irq, (void *)0x40);
+	irq_set_chained_handler_and_data(IRQ_AUTO_5, psc_irq, (void *)0x50);
+	irq_set_chained_handler_and_data(IRQ_AUTO_6, psc_irq, (void *)0x60);
 }
 
 void psc_irq_enable(int irq) {

commit 371001e502e8cd3543f7b9907d398a112939dff7
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sat Oct 5 21:14:22 2013 +0200

    m68k: Remove superfluous inclusions of <asm/bootinfo.h>
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index cc9f3f097be7..835fa04511c8 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -21,7 +21,6 @@
 #include <linux/irq.h>
 
 #include <asm/traps.h>
-#include <asm/bootinfo.h>
 #include <asm/macintosh.h>
 #include <asm/macints.h>
 #include <asm/mac_psc.h>

commit a4df02a217e9787a4b967197d9d9030c3e3c1088
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Jun 25 21:15:24 2013 +0200

    m68k: Mark functions only called from setup_arch() __init
    
    Some functions that are only called (indirectly) from setup_arch() lack
    __init annotations.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 6f026fc302fa..cc9f3f097be7 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -54,7 +54,7 @@ static void psc_debug_dump(void)
  * expanded to cover what I think are the other 7 channels.
  */
 
-static void psc_dma_die_die_die(void)
+static __init void psc_dma_die_die_die(void)
 {
 	int i;
 

commit 30c0527d15ce4edcde64581e9d062ba9fb08fe16
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 24 01:11:14 2011 +1100

    m68k/mac: cleanup mac_irq_pending
    
    mac_irq_pending() has only one caller (mac_esp.c). Nothing tests for Baboon, PSC or OSS pending interrupts. Until that need arises, let's keep it simple and remove all the unused abstraction. Replace it with a routine to check for SCSI DRQ.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 8dd71c555e93..6f026fc302fa 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -180,12 +180,3 @@ void psc_irq_disable(int irq) {
 #endif
 	psc_write_byte(pIER, 1 << irq_idx);
 }
-
-int psc_irq_pending(int irq)
-{
-	int irq_src	= IRQ_SRC(irq);
-	int irq_idx	= IRQ_IDX(irq);
-	int pIFR	= pIERbase + (irq_src << 4);
-
-	return psc_read_byte(pIFR) & (1 << irq_idx);
-}

commit 56e63689fd866a865682fe14dc5a7e1ec3b2c3ad
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 24 01:11:13 2011 +1100

    m68k/mac: cleanup mac_clear_irq
    
    mac_clear_irq() is dead code and has been dead for as long as I can recall. On certain Mac models, certain irqs can't be cleared this way. Outside of irq dispatch, this code appears be unusable without busy loops or worse, and for irq dispatch we duplicate the same logic. Remove mac_clear_irq() and supporting code.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index e6c2d20f328d..8dd71c555e93 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -181,14 +181,6 @@ void psc_irq_disable(int irq) {
 	psc_write_byte(pIER, 1 << irq_idx);
 }
 
-void psc_irq_clear(int irq) {
-	int irq_src	= IRQ_SRC(irq);
-	int irq_idx	= IRQ_IDX(irq);
-	int pIFR	= pIERbase + (irq_src << 4);
-
-	psc_write_byte(pIFR, 1 << irq_idx);
-}
-
 int psc_irq_pending(int irq)
 {
 	int irq_src	= IRQ_SRC(irq);

commit d890d73995257b4e10cdd7d55bad80e34a71ba22
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 11 11:28:04 2011 +0200

    m68k/irq: Remove obsolete m68k irq framework
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 52840b8c03b8..e6c2d20f328d 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -18,9 +18,7 @@
 #include <linux/mm.h>
 #include <linux/delay.h>
 #include <linux/init.h>
-#ifdef CONFIG_GENERIC_HARDIRQS
 #include <linux/irq.h>
-#endif
 
 #include <asm/traps.h>
 #include <asm/bootinfo.h>
@@ -116,7 +114,6 @@ void __init psc_init(void)
  * PSC interrupt handler. It's a lot like the VIA interrupt handler.
  */
 
-#ifdef CONFIG_GENERIC_HARDIRQS
 static void psc_irq(unsigned int irq, struct irq_desc *desc)
 {
 	unsigned int offset = (unsigned int)irq_desc_get_handler_data(desc);
@@ -145,36 +142,6 @@ static void psc_irq(unsigned int irq, struct irq_desc *desc)
 		irq_bit <<= 1;
 	} while (events >= irq_bit);
 }
-#else
-static irqreturn_t psc_irq(int irq, void *dev_id)
-{
-	int pIFR	= pIFRbase + ((int) dev_id);
-	int pIER	= pIERbase + ((int) dev_id);
-	int irq_num;
-	unsigned char irq_bit, events;
-
-#ifdef DEBUG_IRQS
-	printk("psc_irq: irq %d pIFR = 0x%02X pIER = 0x%02X\n",
-		irq, (int) psc_read_byte(pIFR), (int) psc_read_byte(pIER));
-#endif
-
-	events = psc_read_byte(pIFR) & psc_read_byte(pIER) & 0xF;
-	if (!events)
-		return IRQ_NONE;
-
-	irq_num = irq << 3;
-	irq_bit = 1;
-	do {
-		if (events & irq_bit) {
-			psc_write_byte(pIFR, irq_bit);
-			generic_handle_irq(irq_num);
-		}
-		irq_num++;
-		irq_bit <<= 1;
-	} while (events >= irq_bit);
-	return IRQ_HANDLED;
-}
-#endif
 
 /*
  * Register the PSC interrupt dispatchers for autovector interrupts 3-6.
@@ -182,7 +149,6 @@ static irqreturn_t psc_irq(int irq, void *dev_id)
 
 void __init psc_register_interrupts(void)
 {
-#ifdef CONFIG_GENERIC_HARDIRQS
 	irq_set_chained_handler(IRQ_AUTO_3, psc_irq);
 	irq_set_handler_data(IRQ_AUTO_3, (void *)0x30);
 	irq_set_chained_handler(IRQ_AUTO_4, psc_irq);
@@ -191,16 +157,6 @@ void __init psc_register_interrupts(void)
 	irq_set_handler_data(IRQ_AUTO_5, (void *)0x50);
 	irq_set_chained_handler(IRQ_AUTO_6, psc_irq);
 	irq_set_handler_data(IRQ_AUTO_6, (void *)0x60);
-#else /* !CONFIG_GENERIC_HARDIRQS */
-	if (request_irq(IRQ_AUTO_3, psc_irq, 0, "psc3", (void *) 0x30))
-		pr_err("Couldn't register psc%d interrupt\n", 3);
-	if (request_irq(IRQ_AUTO_4, psc_irq, 0, "psc4", (void *) 0x40))
-		pr_err("Couldn't register psc%d interrupt\n", 4);
-	if (request_irq(IRQ_AUTO_5, psc_irq, 0, "psc5", (void *) 0x50))
-		pr_err("Couldn't register psc%d interrupt\n", 5);
-	if (request_irq(IRQ_AUTO_6, psc_irq, 0, "psc6", (void *) 0x60))
-		pr_err("Couldn't register psc%d interrupt\n", 6);
-#endif /* !CONFIG_GENERIC_HARDIRQS */
 }
 
 void psc_irq_enable(int irq) {

commit 9145db564eae98134de8eb8d64b47d7177eccfdd
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Aug 10 12:48:29 2011 +0200

    m68k/mac: Optimize interrupts using chain handlers
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 0a34b7afc376..52840b8c03b8 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -33,8 +33,6 @@
 int psc_present;
 volatile __u8 *psc;
 
-irqreturn_t psc_irq(int, void *);
-
 /*
  * Debugging dump, used in various places to see what's going on.
  */
@@ -115,26 +113,40 @@ void __init psc_init(void)
 }
 
 /*
- * Register the PSC interrupt dispatchers for autovector interrupts 3-6.
+ * PSC interrupt handler. It's a lot like the VIA interrupt handler.
  */
 
-void __init psc_register_interrupts(void)
+#ifdef CONFIG_GENERIC_HARDIRQS
+static void psc_irq(unsigned int irq, struct irq_desc *desc)
 {
-	if (request_irq(IRQ_AUTO_3, psc_irq, 0, "psc3", (void *) 0x30))
-		pr_err("Couldn't register psc%d interrupt\n", 3);
-	if (request_irq(IRQ_AUTO_4, psc_irq, 0, "psc4", (void *) 0x40))
-		pr_err("Couldn't register psc%d interrupt\n", 4);
-	if (request_irq(IRQ_AUTO_5, psc_irq, 0, "psc5", (void *) 0x50))
-		pr_err("Couldn't register psc%d interrupt\n", 5);
-	if (request_irq(IRQ_AUTO_6, psc_irq, 0, "psc6", (void *) 0x60))
-		pr_err("Couldn't register psc%d interrupt\n", 6);
-}
+	unsigned int offset = (unsigned int)irq_desc_get_handler_data(desc);
+	int pIFR	= pIFRbase + offset;
+	int pIER	= pIERbase + offset;
+	int irq_num;
+	unsigned char irq_bit, events;
 
-/*
- * PSC interrupt handler. It's a lot like the VIA interrupt handler.
- */
+#ifdef DEBUG_IRQS
+	printk("psc_irq: irq %u pIFR = 0x%02X pIER = 0x%02X\n",
+		irq, (int) psc_read_byte(pIFR), (int) psc_read_byte(pIER));
+#endif
 
-irqreturn_t psc_irq(int irq, void *dev_id)
+	events = psc_read_byte(pIFR) & psc_read_byte(pIER) & 0xF;
+	if (!events)
+		return;
+
+	irq_num = irq << 3;
+	irq_bit = 1;
+	do {
+		if (events & irq_bit) {
+			psc_write_byte(pIFR, irq_bit);
+			generic_handle_irq(irq_num);
+		}
+		irq_num++;
+		irq_bit <<= 1;
+	} while (events >= irq_bit);
+}
+#else
+static irqreturn_t psc_irq(int irq, void *dev_id)
 {
 	int pIFR	= pIFRbase + ((int) dev_id);
 	int pIER	= pIERbase + ((int) dev_id);
@@ -162,6 +174,34 @@ irqreturn_t psc_irq(int irq, void *dev_id)
 	} while (events >= irq_bit);
 	return IRQ_HANDLED;
 }
+#endif
+
+/*
+ * Register the PSC interrupt dispatchers for autovector interrupts 3-6.
+ */
+
+void __init psc_register_interrupts(void)
+{
+#ifdef CONFIG_GENERIC_HARDIRQS
+	irq_set_chained_handler(IRQ_AUTO_3, psc_irq);
+	irq_set_handler_data(IRQ_AUTO_3, (void *)0x30);
+	irq_set_chained_handler(IRQ_AUTO_4, psc_irq);
+	irq_set_handler_data(IRQ_AUTO_4, (void *)0x40);
+	irq_set_chained_handler(IRQ_AUTO_5, psc_irq);
+	irq_set_handler_data(IRQ_AUTO_5, (void *)0x50);
+	irq_set_chained_handler(IRQ_AUTO_6, psc_irq);
+	irq_set_handler_data(IRQ_AUTO_6, (void *)0x60);
+#else /* !CONFIG_GENERIC_HARDIRQS */
+	if (request_irq(IRQ_AUTO_3, psc_irq, 0, "psc3", (void *) 0x30))
+		pr_err("Couldn't register psc%d interrupt\n", 3);
+	if (request_irq(IRQ_AUTO_4, psc_irq, 0, "psc4", (void *) 0x40))
+		pr_err("Couldn't register psc%d interrupt\n", 4);
+	if (request_irq(IRQ_AUTO_5, psc_irq, 0, "psc5", (void *) 0x50))
+		pr_err("Couldn't register psc%d interrupt\n", 5);
+	if (request_irq(IRQ_AUTO_6, psc_irq, 0, "psc6", (void *) 0x60))
+		pr_err("Couldn't register psc%d interrupt\n", 6);
+#endif /* !CONFIG_GENERIC_HARDIRQS */
+}
 
 void psc_irq_enable(int irq) {
 	int irq_src	= IRQ_SRC(irq);

commit ddc7fd25d09678f8252c0321ef4b66e8451abe7d
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jul 13 21:48:30 2011 +0200

    m68k/mac: Convert Mac to genirq
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 26c2b6595808..0a34b7afc376 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -18,6 +18,9 @@
 #include <linux/mm.h>
 #include <linux/delay.h>
 #include <linux/init.h>
+#ifdef CONFIG_GENERIC_HARDIRQS
+#include <linux/irq.h>
+#endif
 
 #include <asm/traps.h>
 #include <asm/bootinfo.h>

commit 1425df87c25b15400c9f26d57821bcfe01286b2a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Jul 1 20:39:19 2011 +0200

    m68k/irq: Rename {,__}m68k_handle_int()
    
      - Rename m68k_handle_int() to generic_handle_irq(), and drop the unneeded
        asmlinkage,
      - Rename __m68k_handle_int() to do_IRQ().
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index a4c3eb60706e..26c2b6595808 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -152,7 +152,7 @@ irqreturn_t psc_irq(int irq, void *dev_id)
 	do {
 		if (events & irq_bit) {
 			psc_write_byte(pIFR, irq_bit);
-			m68k_handle_int(irq_num);
+			generic_handle_irq(irq_num);
 		}
 		irq_num++;
 		irq_bit <<= 1;

commit a34f0b31398020e2d3be653eb695bd17a9cf3b55
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Fri Dec 10 14:55:42 2010 +0100

    fix comment typos concerning "consistent"
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index ba6ccab64018..a4c3eb60706e 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -88,7 +88,7 @@ void __init psc_init(void)
 
 	/*
 	 * The PSC is always at the same spot, but using psc
-	 * keeps things consisant with the psc_xxxx functions.
+	 * keeps things consistent with the psc_xxxx functions.
 	 */
 
 	psc = (void *) PSC_BASE;

commit 92c3dd15cd0589adf66c13c7b6114790c207e5a2
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Dec 30 14:02:27 2008 +0100

    m68k: mac core - Kill warn_unused_result warnings
    
    warning: ignoring return value of 'request_irq', declared with attribute
    warn_unused_result
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index f84a4dd64f94..ba6ccab64018 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -117,10 +117,14 @@ void __init psc_init(void)
 
 void __init psc_register_interrupts(void)
 {
-	request_irq(IRQ_AUTO_3, psc_irq, 0, "psc3", (void *) 0x30);
-	request_irq(IRQ_AUTO_4, psc_irq, 0, "psc4", (void *) 0x40);
-	request_irq(IRQ_AUTO_5, psc_irq, 0, "psc5", (void *) 0x50);
-	request_irq(IRQ_AUTO_6, psc_irq, 0, "psc6", (void *) 0x60);
+	if (request_irq(IRQ_AUTO_3, psc_irq, 0, "psc3", (void *) 0x30))
+		pr_err("Couldn't register psc%d interrupt\n", 3);
+	if (request_irq(IRQ_AUTO_4, psc_irq, 0, "psc4", (void *) 0x40))
+		pr_err("Couldn't register psc%d interrupt\n", 4);
+	if (request_irq(IRQ_AUTO_5, psc_irq, 0, "psc5", (void *) 0x50))
+		pr_err("Couldn't register psc%d interrupt\n", 5);
+	if (request_irq(IRQ_AUTO_6, psc_irq, 0, "psc6", (void *) 0x60))
+		pr_err("Couldn't register psc%d interrupt\n", 6);
 }
 
 /*

commit 8dfbdf4abad6e5a7bbd097bf7e2c0ec41e0c54b4
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jul 17 21:16:25 2008 +0200

    m68k/mac/: possible cleanups
    
    This patch contains the following possible cleanups:
    - make the following needlessly global code (always) static:
      - baboon.c: struct baboon
      - baboon.c: baboon_irq()
      - config.c: mac_orig_videoaddr
      - config.c: mac_identify()
      - config.c: mac_report_hardware()
      - config.c: mac_debug_console_write()
      - config.c: mac_sccb_console_write()
      - config.c: mac_scca_console_write()
      - config.c: mac_init_scc_port()
      - oss.c: oss_irq()
      - oss.c: oss_nubus_irq()
      - psc.c: psc_debug_dump()
      - psc.c: psc_dma_die_die_die()
      - via.c: rbv_clear
    - remove the unused bootparse.c
    - #if 0 the following unused functions:
      - config.c: mac_debugging_short()
      - config.c: mac_debugging_long()
    - remove the following unused code:
      - config.c: mac_bisize
      - config.c: mac_env
      - config.c: mac_SCC_init_done
      - config.c: mac_SCC_reset_done
      - config.c: mac_init_scca_port()
      - config.c: mac_init_sccb_port()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index d66f723b17c3..f84a4dd64f94 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -36,7 +36,7 @@ irqreturn_t psc_irq(int, void *);
  * Debugging dump, used in various places to see what's going on.
  */
 
-void psc_debug_dump(void)
+static void psc_debug_dump(void)
 {
 	int	i;
 
@@ -55,7 +55,7 @@ void psc_debug_dump(void)
  * expanded to cover what I think are the other 7 channels.
  */
 
-void psc_dma_die_die_die(void)
+static void psc_dma_die_die_die(void)
 {
 	int i;
 

commit 217f6710c275118af1008bb1447d244be52d2dc3
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue May 1 22:32:58 2007 +0200

    m68k: Mac IRQ cleanup
    
    There are no slow IRQs on Macs since Roman Zippel's IRQ reorganisation that
    went into 2.6.16 and removed mac_irq_list[] and the do_mac_irq_list()
    dispatcher. (They were implemented in do_mac_irq_list() by lowering the IPL.)
    Hence there's no more use for mutual exclusion in the Mac interrupt
    dispatchers. Remove it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 1dba88247c6f..d66f723b17c3 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -147,10 +147,8 @@ irqreturn_t psc_irq(int irq, void *dev_id)
 	irq_bit = 1;
 	do {
 		if (events & irq_bit) {
-			psc_write_byte(pIER, irq_bit);
 			psc_write_byte(pIFR, irq_bit);
 			m68k_handle_int(irq_num);
-			psc_write_byte(pIER, irq_bit | 0x80);
 		}
 		irq_num++;
 		irq_bit <<= 1;

commit 67dfb153a352e57e71404d550be7eb60d15d7f2d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue May 1 22:32:56 2007 +0200

    m68k: Mac IRQ prep
    
    Make sure that there are no slot IRQs asserted before leaving the nubus
    handler. If there are and we don't then the nubus gets wedged because this
    prevents a CA1 transition, which means no more nubus IRQs.
    
    Make the interrupt dispatch loops terminate sooner.
    
    Explicitly initialise the VIA latches to make the code more easily understood.
    
    Also some cleanups.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 401147985a96..1dba88247c6f 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -131,11 +131,8 @@ irqreturn_t psc_irq(int irq, void *dev_id)
 {
 	int pIFR	= pIFRbase + ((int) dev_id);
 	int pIER	= pIERbase + ((int) dev_id);
-	int base_irq;
-	int irq_bit,i;
-	unsigned char events;
-
-	base_irq = irq << 3;
+	int irq_num;
+	unsigned char irq_bit, events;
 
 #ifdef DEBUG_IRQS
 	printk("psc_irq: irq %d pIFR = 0x%02X pIER = 0x%02X\n",
@@ -146,14 +143,18 @@ irqreturn_t psc_irq(int irq, void *dev_id)
 	if (!events)
 		return IRQ_NONE;
 
-	for (i = 0, irq_bit = 1 ; i < 4 ; i++, irq_bit <<= 1) {
-	        if (events & irq_bit) {
+	irq_num = irq << 3;
+	irq_bit = 1;
+	do {
+		if (events & irq_bit) {
 			psc_write_byte(pIER, irq_bit);
 			psc_write_byte(pIFR, irq_bit);
-			m68k_handle_int(base_irq + i);
+			m68k_handle_int(irq_num);
 			psc_write_byte(pIER, irq_bit | 0x80);
 		}
-	}
+		irq_num++;
+		irq_bit <<= 1;
+	} while (events >= irq_bit);
 	return IRQ_HANDLED;
 }
 

commit 647b804c8237aa35e19caf8e11ea8d5565107b0e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue May 1 22:32:55 2007 +0200

    m68k: reverse Mac IRQ damage
    
    Reverse the last of a monumental brown-paper-bag commit that went into the 2.3
    kernel.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index 15378a5878c9..401147985a96 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -149,8 +149,8 @@ irqreturn_t psc_irq(int irq, void *dev_id)
 	for (i = 0, irq_bit = 1 ; i < 4 ; i++, irq_bit <<= 1) {
 	        if (events & irq_bit) {
 			psc_write_byte(pIER, irq_bit);
-			m68k_handle_int(base_irq + i);
 			psc_write_byte(pIFR, irq_bit);
+			m68k_handle_int(base_irq + i);
 			psc_write_byte(pIER, irq_bit | 0x80);
 		}
 	}

commit 2850bc273776cbb1b510c5828e9e456dffb50a32
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Oct 7 14:16:45 2006 +0100

    [PATCH] m68k pt_regs fixes
    
    m68k_handle_int() split in two functions: __m68k_handle_int() takes
    pt_regs * and does set_irq_regs(); m68k_handle_int() doesn't get pt_regs
    *.
    
    Places where we used to call m68k_handle_int() recursively with the same
    pt_regs have simply lost the second argument, the rest is switched to
    __m68k_handle_int().
    
    The rest of patch is just dropping pt_regs * where needed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index e26218091755..15378a5878c9 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -30,7 +30,7 @@
 int psc_present;
 volatile __u8 *psc;
 
-irqreturn_t psc_irq(int, void *, struct pt_regs *);
+irqreturn_t psc_irq(int, void *);
 
 /*
  * Debugging dump, used in various places to see what's going on.
@@ -127,7 +127,7 @@ void __init psc_register_interrupts(void)
  * PSC interrupt handler. It's a lot like the VIA interrupt handler.
  */
 
-irqreturn_t psc_irq(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t psc_irq(int irq, void *dev_id)
 {
 	int pIFR	= pIFRbase + ((int) dev_id);
 	int pIER	= pIERbase + ((int) dev_id);
@@ -149,7 +149,7 @@ irqreturn_t psc_irq(int irq, void *dev_id, struct pt_regs *regs)
 	for (i = 0, irq_bit = 1 ; i < 4 ; i++, irq_bit <<= 1) {
 	        if (events & irq_bit) {
 			psc_write_byte(pIER, irq_bit);
-			m68k_handle_int(base_irq + i, regs);
+			m68k_handle_int(base_irq + i);
 			psc_write_byte(pIFR, irq_bit);
 			psc_write_byte(pIER, irq_bit | 0x80);
 		}

commit 9c5f4afdfbe72d5d1c814ad7286a4524d00c7b96
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:04 2006 -0700

    [PATCH] m68k: convert mac irq code
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
index e72384e43a1e..e26218091755 100644
--- a/arch/m68k/mac/psc.c
+++ b/arch/m68k/mac/psc.c
@@ -117,10 +117,10 @@ void __init psc_init(void)
 
 void __init psc_register_interrupts(void)
 {
-	cpu_request_irq(3, psc_irq, IRQ_FLG_LOCK, "psc3", (void *) 0x30);
-	cpu_request_irq(4, psc_irq, IRQ_FLG_LOCK, "psc4", (void *) 0x40);
-	cpu_request_irq(5, psc_irq, IRQ_FLG_LOCK, "psc5", (void *) 0x50);
-	cpu_request_irq(6, psc_irq, IRQ_FLG_LOCK, "psc6", (void *) 0x60);
+	request_irq(IRQ_AUTO_3, psc_irq, 0, "psc3", (void *) 0x30);
+	request_irq(IRQ_AUTO_4, psc_irq, 0, "psc4", (void *) 0x40);
+	request_irq(IRQ_AUTO_5, psc_irq, 0, "psc5", (void *) 0x50);
+	request_irq(IRQ_AUTO_6, psc_irq, 0, "psc6", (void *) 0x60);
 }
 
 /*
@@ -149,7 +149,7 @@ irqreturn_t psc_irq(int irq, void *dev_id, struct pt_regs *regs)
 	for (i = 0, irq_bit = 1 ; i < 4 ; i++, irq_bit <<= 1) {
 	        if (events & irq_bit) {
 			psc_write_byte(pIER, irq_bit);
-			mac_do_irq_list(base_irq + i, regs);
+			m68k_handle_int(base_irq + i, regs);
 			psc_write_byte(pIFR, irq_bit);
 			psc_write_byte(pIER, irq_bit | 0x80);
 		}

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/mac/psc.c b/arch/m68k/mac/psc.c
new file mode 100644
index 000000000000..e72384e43a1e
--- /dev/null
+++ b/arch/m68k/mac/psc.c
@@ -0,0 +1,197 @@
+/*
+ *	Apple Peripheral System Controller (PSC)
+ *
+ *	The PSC is used on the AV Macs to control IO functions not handled
+ *	by the VIAs (Ethernet, DSP, SCC).
+ *
+ * TO DO:
+ *
+ * Try to figure out what's going on in pIFR5 and pIFR6. There seem to be
+ * persisant interrupt conditions in those registers and I have no idea what
+ * they are. Granted it doesn't affect since we're not enabling any interrupts
+ * on those levels at the moment, but it would be nice to know. I have a feeling
+ * they aren't actually interrupt lines but data lines (to the DSP?)
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/delay.h>
+#include <linux/init.h>
+
+#include <asm/traps.h>
+#include <asm/bootinfo.h>
+#include <asm/macintosh.h>
+#include <asm/macints.h>
+#include <asm/mac_psc.h>
+
+#define DEBUG_PSC
+
+int psc_present;
+volatile __u8 *psc;
+
+irqreturn_t psc_irq(int, void *, struct pt_regs *);
+
+/*
+ * Debugging dump, used in various places to see what's going on.
+ */
+
+void psc_debug_dump(void)
+{
+	int	i;
+
+	if (!psc_present) return;
+	for (i = 0x30 ; i < 0x70 ; i += 0x10) {
+		printk("PSC #%d:  IFR = 0x%02X IER = 0x%02X\n",
+			i >> 4,
+			(int) psc_read_byte(pIFRbase + i),
+			(int) psc_read_byte(pIERbase + i));
+	}
+}
+
+/*
+ * Try to kill all DMA channels on the PSC. Not sure how this his
+ * supposed to work; this is code lifted from macmace.c and then
+ * expanded to cover what I think are the other 7 channels.
+ */
+
+void psc_dma_die_die_die(void)
+{
+	int i;
+
+	printk("Killing all PSC DMA channels...");
+	for (i = 0 ; i < 9 ; i++) {
+		psc_write_word(PSC_CTL_BASE + (i << 4), 0x8800);
+		psc_write_word(PSC_CTL_BASE + (i << 4), 0x1000);
+		psc_write_word(PSC_CMD_BASE + (i << 5), 0x1100);
+		psc_write_word(PSC_CMD_BASE + (i << 5) + 0x10, 0x1100);
+	}
+	printk("done!\n");
+}
+
+/*
+ * Initialize the PSC. For now this just involves shutting down all
+ * interrupt sources using the IERs.
+ */
+
+void __init psc_init(void)
+{
+	int i;
+
+	if (macintosh_config->ident != MAC_MODEL_C660
+	 && macintosh_config->ident != MAC_MODEL_Q840)
+	{
+		psc = NULL;
+		psc_present = 0;
+		return;
+	}
+
+	/*
+	 * The PSC is always at the same spot, but using psc
+	 * keeps things consisant with the psc_xxxx functions.
+	 */
+
+	psc = (void *) PSC_BASE;
+	psc_present = 1;
+
+	printk("PSC detected at %p\n", psc);
+
+	psc_dma_die_die_die();
+
+#ifdef DEBUG_PSC
+	psc_debug_dump();
+#endif
+	/*
+	 * Mask and clear all possible interrupts
+	 */
+
+	for (i = 0x30 ; i < 0x70 ; i += 0x10) {
+		psc_write_byte(pIERbase + i, 0x0F);
+		psc_write_byte(pIFRbase + i, 0x0F);
+	}
+}
+
+/*
+ * Register the PSC interrupt dispatchers for autovector interrupts 3-6.
+ */
+
+void __init psc_register_interrupts(void)
+{
+	cpu_request_irq(3, psc_irq, IRQ_FLG_LOCK, "psc3", (void *) 0x30);
+	cpu_request_irq(4, psc_irq, IRQ_FLG_LOCK, "psc4", (void *) 0x40);
+	cpu_request_irq(5, psc_irq, IRQ_FLG_LOCK, "psc5", (void *) 0x50);
+	cpu_request_irq(6, psc_irq, IRQ_FLG_LOCK, "psc6", (void *) 0x60);
+}
+
+/*
+ * PSC interrupt handler. It's a lot like the VIA interrupt handler.
+ */
+
+irqreturn_t psc_irq(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int pIFR	= pIFRbase + ((int) dev_id);
+	int pIER	= pIERbase + ((int) dev_id);
+	int base_irq;
+	int irq_bit,i;
+	unsigned char events;
+
+	base_irq = irq << 3;
+
+#ifdef DEBUG_IRQS
+	printk("psc_irq: irq %d pIFR = 0x%02X pIER = 0x%02X\n",
+		irq, (int) psc_read_byte(pIFR), (int) psc_read_byte(pIER));
+#endif
+
+	events = psc_read_byte(pIFR) & psc_read_byte(pIER) & 0xF;
+	if (!events)
+		return IRQ_NONE;
+
+	for (i = 0, irq_bit = 1 ; i < 4 ; i++, irq_bit <<= 1) {
+	        if (events & irq_bit) {
+			psc_write_byte(pIER, irq_bit);
+			mac_do_irq_list(base_irq + i, regs);
+			psc_write_byte(pIFR, irq_bit);
+			psc_write_byte(pIER, irq_bit | 0x80);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+void psc_irq_enable(int irq) {
+	int irq_src	= IRQ_SRC(irq);
+	int irq_idx	= IRQ_IDX(irq);
+	int pIER	= pIERbase + (irq_src << 4);
+
+#ifdef DEBUG_IRQUSE
+	printk("psc_irq_enable(%d)\n", irq);
+#endif
+	psc_write_byte(pIER, (1 << irq_idx) | 0x80);
+}
+
+void psc_irq_disable(int irq) {
+	int irq_src	= IRQ_SRC(irq);
+	int irq_idx	= IRQ_IDX(irq);
+	int pIER	= pIERbase + (irq_src << 4);
+
+#ifdef DEBUG_IRQUSE
+	printk("psc_irq_disable(%d)\n", irq);
+#endif
+	psc_write_byte(pIER, 1 << irq_idx);
+}
+
+void psc_irq_clear(int irq) {
+	int irq_src	= IRQ_SRC(irq);
+	int irq_idx	= IRQ_IDX(irq);
+	int pIFR	= pIERbase + (irq_src << 4);
+
+	psc_write_byte(pIFR, 1 << irq_idx);
+}
+
+int psc_irq_pending(int irq)
+{
+	int irq_src	= IRQ_SRC(irq);
+	int irq_idx	= IRQ_IDX(irq);
+	int pIFR	= pIERbase + (irq_src << 4);
+
+	return psc_read_byte(pIFR) & (1 << irq_idx);
+}
