commit e31cf2f4ca422ac9b14ecc4a1295b8977a20f812
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:33 2020 -0700

    mm: don't include asm/pgtable.h if linux/mm.h is already included
    
    Patch series "mm: consolidate definitions of page table accessors", v2.
    
    The low level page table accessors (pXY_index(), pXY_offset()) are
    duplicated across all architectures and sometimes more than once.  For
    instance, we have 31 definition of pgd_offset() for 25 supported
    architectures.
    
    Most of these definitions are actually identical and typically it boils
    down to, e.g.
    
    static inline unsigned long pmd_index(unsigned long address)
    {
            return (address >> PMD_SHIFT) & (PTRS_PER_PMD - 1);
    }
    
    static inline pmd_t *pmd_offset(pud_t *pud, unsigned long address)
    {
            return (pmd_t *)pud_page_vaddr(*pud) + pmd_index(address);
    }
    
    These definitions can be shared among 90% of the arches provided
    XYZ_SHIFT, PTRS_PER_XYZ and xyz_page_vaddr() are defined.
    
    For architectures that really need a custom version there is always
    possibility to override the generic version with the usual ifdefs magic.
    
    These patches introduce include/linux/pgtable.h that replaces
    include/asm-generic/pgtable.h and add the definitions of the page table
    accessors to the new header.
    
    This patch (of 12):
    
    The linux/mm.h header includes <asm/pgtable.h> to allow inlining of the
    functions involving page table manipulations, e.g.  pte_alloc() and
    pmd_alloc().  So, there is no point to explicitly include <asm/pgtable.h>
    in the files that include <linux/mm.h>.
    
    The include statements in such cases are remove with a simple loop:
    
            for f in $(git grep -l "include <linux/mm.h>") ; do
                    sed -i -e '/include <asm\/pgtable.h>/ d' $f
            done
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Mike Rapoport <rppt@kernel.org>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-1-rppt@kernel.org
    Link: http://lkml.kernel.org/r/20200514170327.31389-2-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index 6152f9f631d2..ce79b322a99c 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -26,7 +26,6 @@
 #include <asm/setup.h>
 #include <asm/machdep.h>
 #include <asm/page.h>
-#include <asm/pgtable.h>
 #include <asm/atarihw.h>
 #include <asm/atari_stram.h>
 #include <asm/io.h>

commit 8a7f97b902f4fb0d94b355b6b3f1fbd7154cafb9
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Mar 11 23:30:31 2019 -0700

    treewide: add checks for the return value of memblock_alloc*()
    
    Add check for the return value of memblock_alloc*() functions and call
    panic() in case of error.  The panic message repeats the one used by
    panicing memblock allocators with adjustment of parameters to include
    only relevant ones.
    
    The replacement was mostly automated with semantic patches like the one
    below with manual massaging of format strings.
    
      @@
      expression ptr, size, align;
      @@
      ptr = memblock_alloc(size, align);
      + if (!ptr)
      +     panic("%s: Failed to allocate %lu bytes align=0x%lx\n", __func__, size, align);
    
    [anders.roxell@linaro.org: use '%pa' with 'phys_addr_t' type]
      Link: http://lkml.kernel.org/r/20190131161046.21886-1-anders.roxell@linaro.org
    [rppt@linux.ibm.com: fix format strings for panics after memblock_alloc]
      Link: http://lkml.kernel.org/r/1548950940-15145-1-git-send-email-rppt@linux.ibm.com
    [rppt@linux.ibm.com: don't panic if the allocation in sparse_buffer_init fails]
      Link: http://lkml.kernel.org/r/20190131074018.GD28876@rapoport-lnx
    [akpm@linux-foundation.org: fix xtensa printk warning]
    Link: http://lkml.kernel.org/r/1548057848-15136-20-git-send-email-rppt@linux.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Anders Roxell <anders.roxell@linaro.org>
    Reviewed-by: Guo Ren <ren_guo@c-sky.com>                [c-sky]
    Acked-by: Paul Burton <paul.burton@mips.com>            [MIPS]
    Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>    [s390]
    Reviewed-by: Juergen Gross <jgross@suse.com>            [Xen]
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>  [m68k]
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>             [xtensa]
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Dennis Zhou <dennis@kernel.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index 6ffc204eb07d..6152f9f631d2 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -97,6 +97,10 @@ void __init atari_stram_reserve_pages(void *start_mem)
 		pr_debug("atari_stram pool: kernel in ST-RAM, using alloc_bootmem!\n");
 		stram_pool.start = (resource_size_t)memblock_alloc_low(pool_size,
 								       PAGE_SIZE);
+		if (!stram_pool.start)
+			panic("%s: Failed to allocate %lu bytes align=%lx\n",
+			      __func__, pool_size, PAGE_SIZE);
+
 		stram_pool.end = stram_pool.start + pool_size - 1;
 		request_resource(&iomem_resource, &stram_pool);
 		stram_virt_offset = 0;

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index 1089d67df315..6ffc204eb07d 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -17,7 +17,7 @@
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/pagemap.h>
-#include <linux/bootmem.h>
+#include <linux/memblock.h>
 #include <linux/mount.h>
 #include <linux/blkdev.h>
 #include <linux/module.h>

commit e8625dce71b4c23eb81bc9b023c7628807df89e8
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:08:54 2018 -0700

    memblock: replace alloc_bootmem_low_pages with memblock_alloc_low
    
    The alloc_bootmem_low_pages() function allocates PAGE_SIZE aligned regions
    from low memory. memblock_alloc_low() with alignment set to PAGE_SIZE does
    exactly the same thing.
    
    The conversion is done using the following semantic patch:
    
    @@
    expression e;
    @@
    - alloc_bootmem_low_pages(e)
    + memblock_alloc_low(e, PAGE_SIZE)
    
    Link: http://lkml.kernel.org/r/1536927045-23536-19-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index c83d66442612..1089d67df315 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -95,7 +95,8 @@ void __init atari_stram_reserve_pages(void *start_mem)
 {
 	if (kernel_in_stram) {
 		pr_debug("atari_stram pool: kernel in ST-RAM, using alloc_bootmem!\n");
-		stram_pool.start = (resource_size_t)alloc_bootmem_low_pages(pool_size);
+		stram_pool.start = (resource_size_t)memblock_alloc_low(pool_size,
+								       PAGE_SIZE);
 		stram_pool.end = stram_pool.start + pool_size - 1;
 		request_resource(&iomem_resource, &stram_pool);
 		stram_virt_offset = 0;

commit 9aa59cacdf22de9127d147de9523c1a0f832da48
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Aug 14 09:25:38 2014 +0200

    m68k/atari - stram: Add missing #include <linux/ioport.h>
    
    If CONFIG_BLOCK=n:
    
    arch/m68k/atari/stram.c:44: error: variable ‘stram_pool’ has initializer but incomplete type
    arch/m68k/atari/stram.c:45: error: unknown field ‘name’ specified in initializer
    arch/m68k/atari/stram.c:46: warning: excess elements in struct initializer
    arch/m68k/atari/stram.c:46: warning: (near initialization for ‘stram_pool’)
    arch/m68k/atari/stram.c: In function ‘atari_stram_reserve_pages’:
    arch/m68k/atari/stram.c:97: error: invalid use of undefined type ‘struct resource’
    ...
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index 5f8cb5a234d9..c83d66442612 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -21,6 +21,7 @@
 #include <linux/mount.h>
 #include <linux/blkdev.h>
 #include <linux/module.h>
+#include <linux/ioport.h>
 
 #include <asm/setup.h>
 #include <asm/machdep.h>

commit fded332bf40349788c83399751fd3764fddc4b51
Author: Michael Schmitz <schmitzmic@gmail.com>
Date:   Mon Mar 31 21:06:05 2014 +1300

    m68k/atari - stram: alloc ST-RAM pool even if kernel not in ST-RAM
    
    With the kernel loaded to FastRAM (TT-RAM), none of the ST-RAM
    address range is mapped by init_mem, and ST-RAM is not accessible
    through the normal allocation pathways as a result.
    
    Implement ST-RAM pool allocation to be based on physical addresses
    always (it already was when the kernel was loaded in ST-RAM).
    Return kernel virtual addresses as per normal.
    
    The current test for the kernel residing in ST-RAM always returns
    true. Use the bootinfo memory chunk order instead - with the kernel
    in FastRAM, ST-RAM (phys. 0x0) is not the first chunk.
    
    In case the kernel is running from FastRAM, delay mapping of ST-RAM
    pool until after mem_init.
    
    Provide helper functions for those users of ST-RAM that need
    to be aware of the backing physical addresses.
    
    Kudos to Geert for his hints on getting this started.
    
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index 0810c8d56e59..5f8cb5a234d9 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -47,6 +47,7 @@ static struct resource stram_pool = {
 
 static unsigned long pool_size = 1024*1024;
 
+static unsigned long stram_virt_offset;
 
 static int __init atari_stram_setup(char *arg)
 {
@@ -67,14 +68,12 @@ early_param("stram_pool", atari_stram_setup);
 void __init atari_stram_init(void)
 {
 	int i;
-	void *stram_start;
 
 	/*
 	 * determine whether kernel code resides in ST-RAM
 	 * (then ST-RAM is the first memory block at virtual 0x0)
 	 */
-	stram_start = phys_to_virt(0);
-	kernel_in_stram = (stram_start == 0);
+	kernel_in_stram = (m68k_memory[0].addr == 0);
 
 	for (i = 0; i < m68k_num_memory; ++i) {
 		if (m68k_memory[i].addr == 0) {
@@ -89,24 +88,62 @@ void __init atari_stram_init(void)
 
 /*
  * This function is called from setup_arch() to reserve the pages needed for
- * ST-RAM management.
+ * ST-RAM management, if the kernel resides in ST-RAM.
  */
 void __init atari_stram_reserve_pages(void *start_mem)
 {
-	/*
-	 * always reserve first page of ST-RAM, the first 2 KiB are
-	 * supervisor-only!
-	 */
-	if (!kernel_in_stram)
-		reserve_bootmem(0, PAGE_SIZE, BOOTMEM_DEFAULT);
+	if (kernel_in_stram) {
+		pr_debug("atari_stram pool: kernel in ST-RAM, using alloc_bootmem!\n");
+		stram_pool.start = (resource_size_t)alloc_bootmem_low_pages(pool_size);
+		stram_pool.end = stram_pool.start + pool_size - 1;
+		request_resource(&iomem_resource, &stram_pool);
+		stram_virt_offset = 0;
+		pr_debug("atari_stram pool: size = %lu bytes, resource = %pR\n",
+			pool_size, &stram_pool);
+		pr_debug("atari_stram pool: stram_virt_offset = %lx\n",
+			stram_virt_offset);
+	}
+}
 
-	stram_pool.start = (resource_size_t)alloc_bootmem_low_pages(pool_size);
-	stram_pool.end = stram_pool.start + pool_size - 1;
-	request_resource(&iomem_resource, &stram_pool);
 
-	pr_debug("atari_stram pool: size = %lu bytes, resource = %pR\n",
-		 pool_size, &stram_pool);
+/*
+ * This function is called as arch initcall to reserve the pages needed for
+ * ST-RAM management, if the kernel does not reside in ST-RAM.
+ */
+int __init atari_stram_map_pages(void)
+{
+	if (!kernel_in_stram) {
+		/*
+		 * Skip page 0, as the fhe first 2 KiB are supervisor-only!
+		 */
+		pr_debug("atari_stram pool: kernel not in ST-RAM, using ioremap!\n");
+		stram_pool.start = PAGE_SIZE;
+		stram_pool.end = stram_pool.start + pool_size - 1;
+		request_resource(&iomem_resource, &stram_pool);
+		stram_virt_offset = (unsigned long) ioremap(stram_pool.start,
+				resource_size(&stram_pool)) - stram_pool.start;
+		pr_debug("atari_stram pool: size = %lu bytes, resource = %pR\n",
+			pool_size, &stram_pool);
+		pr_debug("atari_stram pool: stram_virt_offset = %lx\n",
+			stram_virt_offset);
+	}
+	return 0;
+}
+arch_initcall(atari_stram_map_pages);
+
+
+void *atari_stram_to_virt(unsigned long phys)
+{
+	return (void *)(phys + stram_virt_offset);
+}
+EXPORT_SYMBOL(atari_stram_to_virt);
+
+
+unsigned long atari_stram_to_phys(void *virt)
+{
+	return (unsigned long)(virt - stram_virt_offset);
 }
+EXPORT_SYMBOL(atari_stram_to_phys);
 
 
 void *atari_stram_alloc(unsigned long size, const char *owner)
@@ -134,14 +171,14 @@ void *atari_stram_alloc(unsigned long size, const char *owner)
 	}
 
 	pr_debug("atari_stram_alloc: returning %pR\n", res);
-	return (void *)res->start;
+	return atari_stram_to_virt(res->start);
 }
 EXPORT_SYMBOL(atari_stram_alloc);
 
 
 void atari_stram_free(void *addr)
 {
-	unsigned long start = (unsigned long)addr;
+	unsigned long start = atari_stram_to_phys(addr);
 	struct resource *res;
 	unsigned long size;
 

commit 217bbd81885587b462311fab1b04172926c59f1e
Author: Michael Schmitz <schmitzmic@googlemail.com>
Date:   Mon Nov 1 19:54:00 2010 +0100

    m68k/atari: Reserve some ST-RAM early on for device buffer use
    
    Based on an original patch from Michael Schmitz:
    
    Because mem_init() is now called before device init, devices that rely on
    ST-RAM may find all ST-RAM already allocated to other users by the time
    device init happens. In particular, a large initrd RAM disk may use up
    enough of ST-RAM to cause atari_stram_alloc() to resort to
    __get_dma_pages() allocation.
    
    In the current state of Atari memory management, all of RAM is marked
    DMA capable, so __get_dma_pages() may well return RAM that is not in actual
    fact DMA capable. Using this for frame buffer or SCSI DMA buffer causes
    subtle failure.
    
    The ST-RAM allocator has been changed to allocate memory from a pool of
    reserved ST-RAM of configurable size, set aside on ST-RAM init (i.e.
    before mem_init()). As long as this pool is not exhausted, allocation of
    real ST-RAM can be guaranteed.
    
    Other changes:
      - Replace the custom allocator in the ST-RAM pool by the existing allocator
        in the resource subsystem,
      - Remove mem_init_done and its hook, as memory init is now done before
        device init,
      - Remove /proc/stram, as ST-RAM usage now shows up under /proc/iomem, e.g.
    
            005f2000-006f1fff : ST-RAM Pool
              005f2000-0063dfff : atafb
              0063e000-00641fff : ataflop
              00642000-00642fff : SCSI
    
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    [Andreas Schwab <schwab@linux-m68k.org>: Use memparse()]
    [Geert: Use the resource subsystem instead of a custom allocator]
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index 6ec3b7f33779..0810c8d56e59 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -1,5 +1,5 @@
 /*
- * arch/m68k/atari/stram.c: Functions for ST-RAM allocations
+ * Functions for ST-RAM allocations
  *
  * Copyright 1994-97 Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
  *
@@ -30,91 +30,35 @@
 #include <asm/atari_stram.h>
 #include <asm/io.h>
 
-#undef DEBUG
-
-#ifdef DEBUG
-#define	DPRINTK(fmt,args...) printk( fmt, ##args )
-#else
-#define DPRINTK(fmt,args...)
-#endif
-
-#if defined(CONFIG_PROC_FS) && defined(CONFIG_STRAM_PROC)
-/* abbrev for the && above... */
-#define DO_PROC
-#include <linux/proc_fs.h>
-#include <linux/seq_file.h>
-#endif
 
 /*
- * ++roman:
- *
- * New version of ST-Ram buffer allocation. Instead of using the
- * 1 MB - 4 KB that remain when the ST-Ram chunk starts at $1000
- * (1 MB granularity!), such buffers are reserved like this:
- *
- *  - If the kernel resides in ST-Ram anyway, we can take the buffer
- *    from behind the current kernel data space the normal way
- *    (incrementing start_mem).
- *
- *  - If the kernel is in TT-Ram, stram_init() initializes start and
- *    end of the available region. Buffers are allocated from there
- *    and mem_init() later marks the such used pages as reserved.
- *    Since each TT-Ram chunk is at least 4 MB in size, I hope there
- *    won't be an overrun of the ST-Ram region by normal kernel data
- *    space.
- *
- * For that, ST-Ram may only be allocated while kernel initialization
- * is going on, or exactly: before mem_init() is called. There is also
- * no provision now for freeing ST-Ram buffers. It seems that isn't
- * really needed.
- *
+ * The ST-RAM allocator allocates memory from a pool of reserved ST-RAM of
+ * configurable size, set aside on ST-RAM init.
+ * As long as this pool is not exhausted, allocation of real ST-RAM can be
+ * guaranteed.
  */
 
-/* Start and end (virtual) of ST-RAM */
-static void *stram_start, *stram_end;
-
-/* set after memory_init() executed and allocations via start_mem aren't
- * possible anymore */
-static int mem_init_done;
-
 /* set if kernel is in ST-RAM */
 static int kernel_in_stram;
 
-typedef struct stram_block {
-	struct stram_block *next;
-	void *start;
-	unsigned long size;
-	unsigned flags;
-	const char *owner;
-} BLOCK;
-
-/* values for flags field */
-#define BLOCK_FREE	0x01	/* free structure in the BLOCKs pool */
-#define BLOCK_KMALLOCED	0x02	/* structure allocated by kmalloc() */
-#define BLOCK_GFP	0x08	/* block allocated with __get_dma_pages() */
+static struct resource stram_pool = {
+	.name = "ST-RAM Pool"
+};
 
-/* list of allocated blocks */
-static BLOCK *alloc_list;
+static unsigned long pool_size = 1024*1024;
 
-/* We can't always use kmalloc() to allocate BLOCK structures, since
- * stram_alloc() can be called rather early. So we need some pool of
- * statically allocated structures. 20 of them is more than enough, so in most
- * cases we never should need to call kmalloc(). */
-#define N_STATIC_BLOCKS	20
-static BLOCK static_blocks[N_STATIC_BLOCKS];
 
-/***************************** Prototypes *****************************/
+static int __init atari_stram_setup(char *arg)
+{
+	if (!MACH_IS_ATARI)
+		return 0;
 
-static BLOCK *add_region( void *addr, unsigned long size );
-static BLOCK *find_region( void *addr );
-static int remove_region( BLOCK *block );
+	pool_size = memparse(arg, NULL);
+	return 0;
+}
 
-/************************* End of Prototypes **************************/
+early_param("stram_pool", atari_stram_setup);
 
-
-/* ------------------------------------------------------------------------ */
-/*							   Public Interface								*/
-/* ------------------------------------------------------------------------ */
 
 /*
  * This init function is called very early by atari/config.c
@@ -123,25 +67,23 @@ static int remove_region( BLOCK *block );
 void __init atari_stram_init(void)
 {
 	int i;
+	void *stram_start;
 
-	/* initialize static blocks */
-	for( i = 0; i < N_STATIC_BLOCKS; ++i )
-		static_blocks[i].flags = BLOCK_FREE;
-
-	/* determine whether kernel code resides in ST-RAM (then ST-RAM is the
-	 * first memory block at virtual 0x0) */
+	/*
+	 * determine whether kernel code resides in ST-RAM
+	 * (then ST-RAM is the first memory block at virtual 0x0)
+	 */
 	stram_start = phys_to_virt(0);
 	kernel_in_stram = (stram_start == 0);
 
-	for( i = 0; i < m68k_num_memory; ++i ) {
+	for (i = 0; i < m68k_num_memory; ++i) {
 		if (m68k_memory[i].addr == 0) {
-			/* skip first 2kB or page (supervisor-only!) */
-			stram_end = stram_start + m68k_memory[i].size;
 			return;
 		}
 	}
+
 	/* Should never come here! (There is always ST-Ram!) */
-	panic( "atari_stram_init: no ST-RAM found!" );
+	panic("atari_stram_init: no ST-RAM found!");
 }
 
 
@@ -151,226 +93,68 @@ void __init atari_stram_init(void)
  */
 void __init atari_stram_reserve_pages(void *start_mem)
 {
-	/* always reserve first page of ST-RAM, the first 2 kB are
-	 * supervisor-only! */
+	/*
+	 * always reserve first page of ST-RAM, the first 2 KiB are
+	 * supervisor-only!
+	 */
 	if (!kernel_in_stram)
 		reserve_bootmem(0, PAGE_SIZE, BOOTMEM_DEFAULT);
 
-}
+	stram_pool.start = (resource_size_t)alloc_bootmem_low_pages(pool_size);
+	stram_pool.end = stram_pool.start + pool_size - 1;
+	request_resource(&iomem_resource, &stram_pool);
 
-void atari_stram_mem_init_hook (void)
-{
-	mem_init_done = 1;
+	pr_debug("atari_stram pool: size = %lu bytes, resource = %pR\n",
+		 pool_size, &stram_pool);
 }
 
 
-/*
- * This is main public interface: somehow allocate a ST-RAM block
- *
- *  - If we're before mem_init(), we have to make a static allocation. The
- *    region is taken in the kernel data area (if the kernel is in ST-RAM) or
- *    from the start of ST-RAM (if the kernel is in TT-RAM) and added to the
- *    rsvd_stram_* region. The ST-RAM is somewhere in the middle of kernel
- *    address space in the latter case.
- *
- *  - If mem_init() already has been called, try with __get_dma_pages().
- *    This has the disadvantage that it's very hard to get more than 1 page,
- *    and it is likely to fail :-(
- *
- */
-void *atari_stram_alloc(long size, const char *owner)
+void *atari_stram_alloc(unsigned long size, const char *owner)
 {
-	void *addr = NULL;
-	BLOCK *block;
-	int flags;
-
-	DPRINTK("atari_stram_alloc(size=%08lx,owner=%s)\n", size, owner);
-
-	if (!mem_init_done)
-		return alloc_bootmem_low(size);
-	else {
-		/* After mem_init(): can only resort to __get_dma_pages() */
-		addr = (void *)__get_dma_pages(GFP_KERNEL, get_order(size));
-		flags = BLOCK_GFP;
-		DPRINTK( "atari_stram_alloc: after mem_init, "
-				 "get_pages=%p\n", addr );
+	struct resource *res;
+	int error;
+
+	pr_debug("atari_stram_alloc: allocate %lu bytes\n", size);
+
+	/* round up */
+	size = PAGE_ALIGN(size);
+
+	res = kzalloc(sizeof(struct resource), GFP_KERNEL);
+	if (!res)
+		return NULL;
+
+	res->name = owner;
+	error = allocate_resource(&stram_pool, res, size, 0, UINT_MAX,
+				  PAGE_SIZE, NULL, NULL);
+	if (error < 0) {
+		pr_err("atari_stram_alloc: allocate_resource() failed %d!\n",
+		       error);
+		kfree(res);
+		return NULL;
 	}
 
-	if (addr) {
-		if (!(block = add_region( addr, size ))) {
-			/* out of memory for BLOCK structure :-( */
-			DPRINTK( "atari_stram_alloc: out of mem for BLOCK -- "
-					 "freeing again\n" );
-			free_pages((unsigned long)addr, get_order(size));
-			return( NULL );
-		}
-		block->owner = owner;
-		block->flags |= flags;
-	}
-	return( addr );
+	pr_debug("atari_stram_alloc: returning %pR\n", res);
+	return (void *)res->start;
 }
 EXPORT_SYMBOL(atari_stram_alloc);
 
-void atari_stram_free( void *addr )
 
+void atari_stram_free(void *addr)
 {
-	BLOCK *block;
-
-	DPRINTK( "atari_stram_free(addr=%p)\n", addr );
+	unsigned long start = (unsigned long)addr;
+	struct resource *res;
+	unsigned long size;
 
-	if (!(block = find_region( addr ))) {
-		printk( KERN_ERR "Attempt to free non-allocated ST-RAM block at %p "
-				"from %p\n", addr, __builtin_return_address(0) );
+	res = lookup_resource(&stram_pool, start);
+	if (!res) {
+		pr_err("atari_stram_free: trying to free nonexistent region "
+		       "at %p\n", addr);
 		return;
 	}
-	DPRINTK( "atari_stram_free: found block (%p): size=%08lx, owner=%s, "
-			 "flags=%02x\n", block, block->size, block->owner, block->flags );
-
-	if (!(block->flags & BLOCK_GFP))
-		goto fail;
 
-	DPRINTK("atari_stram_free: is kmalloced, order_size=%d\n",
-		get_order(block->size));
-	free_pages((unsigned long)addr, get_order(block->size));
-	remove_region( block );
-	return;
-
-  fail:
-	printk( KERN_ERR "atari_stram_free: cannot free block at %p "
-			"(called from %p)\n", addr, __builtin_return_address(0) );
+	size = resource_size(res);
+	pr_debug("atari_stram_free: free %lu bytes at %p\n", size, addr);
+	release_resource(res);
+	kfree(res);
 }
 EXPORT_SYMBOL(atari_stram_free);
-
-
-/* ------------------------------------------------------------------------ */
-/*							  Region Management								*/
-/* ------------------------------------------------------------------------ */
-
-
-/* insert a region into the alloced list (sorted) */
-static BLOCK *add_region( void *addr, unsigned long size )
-{
-	BLOCK **p, *n = NULL;
-	int i;
-
-	for( i = 0; i < N_STATIC_BLOCKS; ++i ) {
-		if (static_blocks[i].flags & BLOCK_FREE) {
-			n = &static_blocks[i];
-			n->flags = 0;
-			break;
-		}
-	}
-	if (!n && mem_init_done) {
-		/* if statics block pool exhausted and we can call kmalloc() already
-		 * (after mem_init()), try that */
-		n = kmalloc( sizeof(BLOCK), GFP_KERNEL );
-		if (n)
-			n->flags = BLOCK_KMALLOCED;
-	}
-	if (!n) {
-		printk( KERN_ERR "Out of memory for ST-RAM descriptor blocks\n" );
-		return( NULL );
-	}
-	n->start = addr;
-	n->size  = size;
-
-	for( p = &alloc_list; *p; p = &((*p)->next) )
-		if ((*p)->start > addr) break;
-	n->next = *p;
-	*p = n;
-
-	return( n );
-}
-
-
-/* find a region (by start addr) in the alloced list */
-static BLOCK *find_region( void *addr )
-{
-	BLOCK *p;
-
-	for( p = alloc_list; p; p = p->next ) {
-		if (p->start == addr)
-			return( p );
-		if (p->start > addr)
-			break;
-	}
-	return( NULL );
-}
-
-
-/* remove a block from the alloced list */
-static int remove_region( BLOCK *block )
-{
-	BLOCK **p;
-
-	for( p = &alloc_list; *p; p = &((*p)->next) )
-		if (*p == block) break;
-	if (!*p)
-		return( 0 );
-
-	*p = block->next;
-	if (block->flags & BLOCK_KMALLOCED)
-		kfree( block );
-	else
-		block->flags |= BLOCK_FREE;
-	return( 1 );
-}
-
-
-
-/* ------------------------------------------------------------------------ */
-/*						 /proc statistics file stuff						*/
-/* ------------------------------------------------------------------------ */
-
-#ifdef DO_PROC
-
-#define	PRINT_PROC(fmt,args...) seq_printf( m, fmt, ##args )
-
-static int stram_proc_show(struct seq_file *m, void *v)
-{
-	BLOCK *p;
-
-	PRINT_PROC("Total ST-RAM:      %8u kB\n",
-			   (stram_end - stram_start) >> 10);
-	PRINT_PROC( "Allocated regions:\n" );
-	for( p = alloc_list; p; p = p->next ) {
-		PRINT_PROC("0x%08lx-0x%08lx: %s (",
-			   virt_to_phys(p->start),
-			   virt_to_phys(p->start+p->size-1),
-			   p->owner);
-		if (p->flags & BLOCK_GFP)
-			PRINT_PROC( "page-alloced)\n" );
-		else
-			PRINT_PROC( "??)\n" );
-	}
-
-	return 0;
-}
-
-static int stram_proc_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, stram_proc_show, NULL);
-}
-
-static const struct file_operations stram_proc_fops = {
-	.open		= stram_proc_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static int __init proc_stram_init(void)
-{
-	proc_create("stram", 0, NULL, &stram_proc_fops);
-	return 0;
-}
-module_init(proc_stram_init);
-#endif
-
-
-/*
- * Local variables:
- *  c-indent-level: 4
- *  tab-width: 4
- * End:
- */

commit 4c150f6c30f5129bbce5c41568a285b1f7ca8d8b
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Sat Oct 4 13:49:34 2008 +0400

    proc: move /proc/stram to m68k-specific code
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index 04c69ffbea71..6ec3b7f33779 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -42,6 +42,7 @@
 /* abbrev for the && above... */
 #define DO_PROC
 #include <linux/proc_fs.h>
+#include <linux/seq_file.h>
 #endif
 
 /*
@@ -323,19 +324,16 @@ static int remove_region( BLOCK *block )
 
 #ifdef DO_PROC
 
-#define	PRINT_PROC(fmt,args...) len += sprintf( buf+len, fmt, ##args )
+#define	PRINT_PROC(fmt,args...) seq_printf( m, fmt, ##args )
 
-int get_stram_list( char *buf )
+static int stram_proc_show(struct seq_file *m, void *v)
 {
-	int len = 0;
 	BLOCK *p;
 
 	PRINT_PROC("Total ST-RAM:      %8u kB\n",
 			   (stram_end - stram_start) >> 10);
 	PRINT_PROC( "Allocated regions:\n" );
 	for( p = alloc_list; p; p = p->next ) {
-		if (len + 50 >= PAGE_SIZE)
-			break;
 		PRINT_PROC("0x%08lx-0x%08lx: %s (",
 			   virt_to_phys(p->start),
 			   virt_to_phys(p->start+p->size-1),
@@ -346,9 +344,27 @@ int get_stram_list( char *buf )
 			PRINT_PROC( "??)\n" );
 	}
 
-	return( len );
+	return 0;
+}
+
+static int stram_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, stram_proc_show, NULL);
 }
 
+static const struct file_operations stram_proc_fops = {
+	.open		= stram_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
+static int __init proc_stram_init(void)
+{
+	proc_create("stram", 0, NULL, &stram_proc_fops);
+	return 0;
+}
+module_init(proc_stram_init);
 #endif
 
 

commit 950e4da32426859ee4b37b2c95026d4f1efa5d05
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Feb 26 09:55:29 2008 -0500

    arch: Remove unnecessary inclusions of asm/semaphore.h
    
    None of these files use any of the functionality promised by
    asm/semaphore.h.  It's possible that they rely on it dragging in some
    unrelated header file, but I can't build all these files, so we'll have
    fix any build failures as they come up.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index 0055a6c06f75..04c69ffbea71 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -29,7 +29,6 @@
 #include <asm/atarihw.h>
 #include <asm/atari_stram.h>
 #include <asm/io.h>
-#include <asm/semaphore.h>
 
 #undef DEBUG
 

commit 72a7fe3967dbf86cb34e24fbf1d957fe24d2f246
Author: Bernhard Walle <bwalle@suse.de>
Date:   Thu Feb 7 00:15:17 2008 -0800

    Introduce flags for reserve_bootmem()
    
    This patchset adds a flags variable to reserve_bootmem() and uses the
    BOOTMEM_EXCLUSIVE flag in crashkernel reservation code to detect collisions
    between crashkernel area and already used memory.
    
    This patch:
    
    Change the reserve_bootmem() function to accept a new flag BOOTMEM_EXCLUSIVE.
    If that flag is set, the function returns with -EBUSY if the memory already
    has been reserved in the past.  This is to avoid conflicts.
    
    Because that code runs before SMP initialisation, there's no race condition
    inside reserve_bootmem_core().
    
    [akpm@linux-foundation.org: coding-style fixes]
    [akpm@linux-foundation.org: fix powerpc build]
    Signed-off-by: Bernhard Walle <bwalle@suse.de>
    Cc: <linux-arch@vger.kernel.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index 8dda6515887a..0055a6c06f75 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -154,7 +154,7 @@ void __init atari_stram_reserve_pages(void *start_mem)
 	/* always reserve first page of ST-RAM, the first 2 kB are
 	 * supervisor-only! */
 	if (!kernel_in_stram)
-		reserve_bootmem (0, PAGE_SIZE);
+		reserve_bootmem(0, PAGE_SIZE, BOOTMEM_DEFAULT);
 
 }
 

commit a3b2004a2671455ee7aef1d9aee5a24381999ddb
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Feb 4 22:30:26 2008 -0800

    m68k: kill arch/m68k/atari/atari_ksyms.c
    
    EXPORT_SYMBOL's belong to the actual code.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index bf4588cbe371..8dda6515887a 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -20,6 +20,7 @@
 #include <linux/bootmem.h>
 #include <linux/mount.h>
 #include <linux/blkdev.h>
+#include <linux/module.h>
 
 #include <asm/setup.h>
 #include <asm/machdep.h>
@@ -208,6 +209,7 @@ void *atari_stram_alloc(long size, const char *owner)
 	}
 	return( addr );
 }
+EXPORT_SYMBOL(atari_stram_alloc);
 
 void atari_stram_free( void *addr )
 
@@ -237,6 +239,7 @@ void atari_stram_free( void *addr )
 	printk( KERN_ERR "atari_stram_free: cannot free block at %p "
 			"(called from %p)\n", addr, __builtin_return_address(0) );
 }
+EXPORT_SYMBOL(atari_stram_free);
 
 
 /* ------------------------------------------------------------------------ */

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index 22e0481a5f7b..bf4588cbe371 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -8,7 +8,6 @@
  * for more details.
  */
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>

commit f9c98d0287de42221c624482fd4f8d485c98ab22
Author: Hugh Dickins <hugh@veritas.com>
Date:   Sat Oct 29 18:16:10 2005 -0700

    [PATCH] mm: m68k kill stram swap
    
    Please, please now delete the Atari CONFIG_STRAM_SWAP code.  It may be
    excellent and ingenious code, but its reference to swap_vfsmnt betrays that it
    hasn't been built since 2.5.1 (four years old come December), it's delving
    deep into matters which are the preserve of core mm code, its only purpose is
    to give the more conscientious mm guys an anxiety attack from time to time;
    yet we keep on breaking it more and more.
    
    If you want to use RAM for swap, then if the MTD driver does not already
    provide just what you need, I'm sure David could be persuaded to add the
    extra.  But you'd also like to be able to allocate extents of that swap for
    other use: we can give you a core interface for that if you need.  But unbuilt
    for four years suggests to me that there's no need at all.
    
    I cannot swear the patch below won't break your build, but believe so.
    
    Signed-off-by: Hugh Dickins <hugh@veritas.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
index 5a3c106b40c8..22e0481a5f7b 100644
--- a/arch/m68k/atari/stram.c
+++ b/arch/m68k/atari/stram.c
@@ -15,11 +15,9 @@
 #include <linux/kdev_t.h>
 #include <linux/major.h>
 #include <linux/init.h>
-#include <linux/swap.h>
 #include <linux/slab.h>
 #include <linux/vmalloc.h>
 #include <linux/pagemap.h>
-#include <linux/shm.h>
 #include <linux/bootmem.h>
 #include <linux/mount.h>
 #include <linux/blkdev.h>
@@ -33,8 +31,6 @@
 #include <asm/io.h>
 #include <asm/semaphore.h>
 
-#include <linux/swapops.h>
-
 #undef DEBUG
 
 #ifdef DEBUG
@@ -49,8 +45,7 @@
 #include <linux/proc_fs.h>
 #endif
 
-/* Pre-swapping comments:
- *
+/*
  * ++roman:
  *
  * New version of ST-Ram buffer allocation. Instead of using the
@@ -75,76 +70,6 @@
  *
  */
 
-/*
- * New Nov 1997: Use ST-RAM as swap space!
- *
- * In the past, there were often problems with modules that require ST-RAM
- * buffers. Such drivers have to use __get_dma_pages(), which unfortunately
- * often isn't very successful in allocating more than 1 page :-( [1] The net
- * result was that most of the time you couldn't insmod such modules (ataflop,
- * ACSI, SCSI on Falcon, Atari internal framebuffer, not to speak of acsi_slm,
- * which needs a 1 MB buffer... :-).
- *
- * To overcome this limitation, ST-RAM can now be turned into a very
- * high-speed swap space. If a request for an ST-RAM buffer comes, the kernel
- * now tries to unswap some pages on that swap device to make some free (and
- * contiguous) space. This works much better in comparison to
- * __get_dma_pages(), since used swap pages can be selectively freed by either
- * moving them to somewhere else in swap space, or by reading them back into
- * system memory. Ok, there operation of unswapping isn't really cheap (for
- * each page, one has to go through the page tables of all processes), but it
- * doesn't happen that often (only when allocation ST-RAM, i.e. when loading a
- * module that needs ST-RAM). But it at least makes it possible to load such
- * modules!
- *
- * It could also be that overall system performance increases a bit due to
- * ST-RAM swapping, since slow ST-RAM isn't used anymore for holding data or
- * executing code in. It's then just a (very fast, compared to disk) back
- * storage for not-so-often needed data. (But this effect must be compared
- * with the loss of total memory...) Don't know if the effect is already
- * visible on a TT, where the speed difference between ST- and TT-RAM isn't
- * that dramatic, but it should on machines where TT-RAM is really much faster
- * (e.g. Afterburner).
- *
- *   [1]: __get_free_pages() does a fine job if you only want one page, but if
- * you want more (contiguous) pages, it can give you such a block only if
- * there's already a free one. The algorithm can't try to free buffers or swap
- * out something in order to make more free space, since all that page-freeing
- * mechanisms work "target-less", i.e. they just free something, but not in a
- * specific place. I.e., __get_free_pages() can't do anything to free
- * *adjacent* pages :-( This situation becomes even worse for DMA memory,
- * since the freeing algorithms are also blind to DMA capability of pages.
- */
-
-/* 1998-10-20: ++andreas
-   unswap_by_move disabled because it does not handle swapped shm pages.
-*/
-
-/* 2000-05-01: ++andreas
-   Integrated with bootmem.  Remove all traces of unswap_by_move.
-*/
-
-#ifdef CONFIG_STRAM_SWAP
-#define ALIGN_IF_SWAP(x)	PAGE_ALIGN(x)
-#else
-#define ALIGN_IF_SWAP(x)	(x)
-#endif
-
-/* get index of swap page at address 'addr' */
-#define SWAP_NR(addr)		(((addr) - swap_start) >> PAGE_SHIFT)
-
-/* get address of swap page #'nr' */
-#define SWAP_ADDR(nr)		(swap_start + ((nr) << PAGE_SHIFT))
-
-/* get number of pages for 'n' bytes (already page-aligned) */
-#define N_PAGES(n)			((n) >> PAGE_SHIFT)
-
-/* The following two numbers define the maximum fraction of ST-RAM in total
- * memory, below that the kernel would automatically use ST-RAM as swap
- * space. This decision can be overridden with stram_swap= */
-#define MAX_STRAM_FRACTION_NOM		1
-#define MAX_STRAM_FRACTION_DENOM	3
-
 /* Start and end (virtual) of ST-RAM */
 static void *stram_start, *stram_end;
 
@@ -164,10 +89,9 @@ typedef struct stram_block {
 } BLOCK;
 
 /* values for flags field */
-#define BLOCK_FREE		0x01	/* free structure in the BLOCKs pool */
+#define BLOCK_FREE	0x01	/* free structure in the BLOCKs pool */
 #define BLOCK_KMALLOCED	0x02	/* structure allocated by kmalloc() */
-#define BLOCK_GFP		0x08	/* block allocated with __get_dma_pages() */
-#define BLOCK_INSWAP	0x10	/* block allocated in swap space */
+#define BLOCK_GFP	0x08	/* block allocated with __get_dma_pages() */
 
 /* list of allocated blocks */
 static BLOCK *alloc_list;
@@ -179,60 +103,8 @@ static BLOCK *alloc_list;
 #define N_STATIC_BLOCKS	20
 static BLOCK static_blocks[N_STATIC_BLOCKS];
 
-#ifdef CONFIG_STRAM_SWAP
-/* max. number of bytes to use for swapping
- *  0 = no ST-RAM swapping
- * -1 = do swapping (to whole ST-RAM) if it's less than MAX_STRAM_FRACTION of
- *      total memory
- */
-static int max_swap_size = -1;
-
-/* start and end of swapping area */
-static void *swap_start, *swap_end;
-
-/* The ST-RAM's swap info structure */
-static struct swap_info_struct *stram_swap_info;
-
-/* The ST-RAM's swap type */
-static int stram_swap_type;
-
-/* Semaphore for get_stram_region.  */
-static DECLARE_MUTEX(stram_swap_sem);
-
-/* major and minor device number of the ST-RAM device; for the major, we use
- * the same as Amiga z2ram, which is really similar and impossible on Atari,
- * and for the minor a relatively odd number to avoid the user creating and
- * using that device. */
-#define	STRAM_MAJOR		Z2RAM_MAJOR
-#define	STRAM_MINOR		13
-
-/* Some impossible pointer value */
-#define MAGIC_FILE_P	(struct file *)0xffffdead
-
-#ifdef DO_PROC
-static unsigned stat_swap_read;
-static unsigned stat_swap_write;
-static unsigned stat_swap_force;
-#endif /* DO_PROC */
-
-#endif /* CONFIG_STRAM_SWAP */
-
 /***************************** Prototypes *****************************/
 
-#ifdef CONFIG_STRAM_SWAP
-static int swap_init(void *start_mem, void *swap_data);
-static void *get_stram_region( unsigned long n_pages );
-static void free_stram_region( unsigned long offset, unsigned long n_pages
-			       );
-static int in_some_region(void *addr);
-static unsigned long find_free_region( unsigned long n_pages, unsigned long
-				       *total_free, unsigned long
-				       *region_free );
-static void do_stram_request(request_queue_t *);
-static int stram_open( struct inode *inode, struct file *filp );
-static int stram_release( struct inode *inode, struct file *filp );
-static void reserve_region(void *start, void *end);
-#endif
 static BLOCK *add_region( void *addr, unsigned long size );
 static BLOCK *find_region( void *addr );
 static int remove_region( BLOCK *block );
@@ -279,84 +151,11 @@ void __init atari_stram_init(void)
  */
 void __init atari_stram_reserve_pages(void *start_mem)
 {
-#ifdef CONFIG_STRAM_SWAP
-	/* if max_swap_size is negative (i.e. no stram_swap= option given),
-	 * determine at run time whether to use ST-RAM swapping */
-	if (max_swap_size < 0)
-		/* Use swapping if ST-RAM doesn't make up more than MAX_STRAM_FRACTION
-		 * of total memory. In that case, the max. size is set to 16 MB,
-		 * because ST-RAM can never be bigger than that.
-		 * Also, never use swapping on a Hades, there's no separate ST-RAM in
-		 * that machine. */
-		max_swap_size =
-			(!MACH_IS_HADES &&
-			 (N_PAGES(stram_end-stram_start)*MAX_STRAM_FRACTION_DENOM <=
-			  ((unsigned long)high_memory>>PAGE_SHIFT)*MAX_STRAM_FRACTION_NOM)) ? 16*1024*1024 : 0;
-	DPRINTK( "atari_stram_reserve_pages: max_swap_size = %d\n", max_swap_size );
-#endif
-
 	/* always reserve first page of ST-RAM, the first 2 kB are
 	 * supervisor-only! */
 	if (!kernel_in_stram)
 		reserve_bootmem (0, PAGE_SIZE);
 
-#ifdef CONFIG_STRAM_SWAP
-	{
-		void *swap_data;
-
-		start_mem = (void *) PAGE_ALIGN ((unsigned long) start_mem);
-		/* determine first page to use as swap: if the kernel is
-		   in TT-RAM, this is the first page of (usable) ST-RAM;
-		   otherwise just use the end of kernel data (= start_mem) */
-		swap_start = !kernel_in_stram ? stram_start + PAGE_SIZE : start_mem;
-		/* decrement by one page, rest of kernel assumes that first swap page
-		 * is always reserved and maybe doesn't handle swp_entry == 0
-		 * correctly */
-		swap_start -= PAGE_SIZE;
-		swap_end = stram_end;
-		if (swap_end-swap_start > max_swap_size)
-			swap_end =  swap_start + max_swap_size;
-		DPRINTK( "atari_stram_reserve_pages: swapping enabled; "
-				 "swap=%p-%p\n", swap_start, swap_end);
-
-		/* reserve some amount of memory for maintainance of
-		 * swapping itself: one page for each 2048 (PAGE_SIZE/2)
-		 * swap pages. (2 bytes for each page) */
-		swap_data = start_mem;
-		start_mem += ((SWAP_NR(swap_end) + PAGE_SIZE/2 - 1)
-			      >> (PAGE_SHIFT-1)) << PAGE_SHIFT;
-		/* correct swap_start if necessary */
-		if (swap_start + PAGE_SIZE == swap_data)
-			swap_start = start_mem - PAGE_SIZE;
-
-		if (!swap_init( start_mem, swap_data )) {
-			printk( KERN_ERR "ST-RAM swap space initialization failed\n" );
-			max_swap_size = 0;
-			return;
-		}
-		/* reserve region for swapping meta-data */
-		reserve_region(swap_data, start_mem);
-		/* reserve swapping area itself */
-		reserve_region(swap_start + PAGE_SIZE, swap_end);
-
-		/*
-		 * If the whole ST-RAM is used for swapping, there are no allocatable
-		 * dma pages left. But unfortunately, some shared parts of the kernel
-		 * (particularly the SCSI mid-level) call __get_dma_pages()
-		 * unconditionally :-( These calls then fail, and scsi.c even doesn't
-		 * check for NULL return values and just crashes. The quick fix for
-		 * this (instead of doing much clean up work in the SCSI code) is to
-		 * pretend all pages are DMA-able by setting mach_max_dma_address to
-		 * ULONG_MAX. This doesn't change any functionality so far, since
-		 * get_dma_pages() shouldn't be used on Atari anyway anymore (better
-		 * use atari_stram_alloc()), and the Atari SCSI drivers don't need DMA
-		 * memory. But unfortunately there's now no kind of warning (even not
-		 * a NULL return value) if you use get_dma_pages() nevertheless :-(
-		 * You just will get non-DMA-able memory...
-		 */
-		mach_max_dma_address = 0xffffffff;
-	}
-#endif
 }
 
 void atari_stram_mem_init_hook (void)
@@ -367,7 +166,6 @@ void atari_stram_mem_init_hook (void)
 
 /*
  * This is main public interface: somehow allocate a ST-RAM block
- * There are three strategies:
  *
  *  - If we're before mem_init(), we have to make a static allocation. The
  *    region is taken in the kernel data area (if the kernel is in ST-RAM) or
@@ -375,14 +173,9 @@ void atari_stram_mem_init_hook (void)
  *    rsvd_stram_* region. The ST-RAM is somewhere in the middle of kernel
  *    address space in the latter case.
  *
- *  - If mem_init() already has been called and ST-RAM swapping is enabled,
- *    try to get the memory from the (pseudo) swap-space, either free already
- *    or by moving some other pages out of the swap.
- *
- *  - If mem_init() already has been called, and ST-RAM swapping is not
- *    enabled, the only possibility is to try with __get_dma_pages(). This has
- *    the disadvantage that it's very hard to get more than 1 page, and it is
- *    likely to fail :-(
+ *  - If mem_init() already has been called, try with __get_dma_pages().
+ *    This has the disadvantage that it's very hard to get more than 1 page,
+ *    and it is likely to fail :-(
  *
  */
 void *atari_stram_alloc(long size, const char *owner)
@@ -393,27 +186,13 @@ void *atari_stram_alloc(long size, const char *owner)
 
 	DPRINTK("atari_stram_alloc(size=%08lx,owner=%s)\n", size, owner);
 
-	size = ALIGN_IF_SWAP(size);
-	DPRINTK( "atari_stram_alloc: rounded size = %08lx\n", size );
-#ifdef CONFIG_STRAM_SWAP
-	if (max_swap_size) {
-		/* If swapping is active: make some free space in the swap
-		   "device". */
-		DPRINTK( "atari_stram_alloc: after mem_init, swapping ok, "
-				 "calling get_region\n" );
-		addr = get_stram_region( N_PAGES(size) );
-		flags = BLOCK_INSWAP;
-	}
-	else
-#endif
 	if (!mem_init_done)
 		return alloc_bootmem_low(size);
 	else {
-		/* After mem_init() and no swapping: can only resort to
-		 * __get_dma_pages() */
+		/* After mem_init(): can only resort to __get_dma_pages() */
 		addr = (void *)__get_dma_pages(GFP_KERNEL, get_order(size));
 		flags = BLOCK_GFP;
-		DPRINTK( "atari_stram_alloc: after mem_init, swapping off, "
+		DPRINTK( "atari_stram_alloc: after mem_init, "
 				 "get_pages=%p\n", addr );
 	}
 
@@ -422,12 +201,7 @@ void *atari_stram_alloc(long size, const char *owner)
 			/* out of memory for BLOCK structure :-( */
 			DPRINTK( "atari_stram_alloc: out of mem for BLOCK -- "
 					 "freeing again\n" );
-#ifdef CONFIG_STRAM_SWAP
-			if (flags == BLOCK_INSWAP)
-				free_stram_region( SWAP_NR(addr), N_PAGES(size) );
-			else
-#endif
-				free_pages((unsigned long)addr, get_order(size));
+			free_pages((unsigned long)addr, get_order(size));
 			return( NULL );
 		}
 		block->owner = owner;
@@ -451,25 +225,12 @@ void atari_stram_free( void *addr )
 	DPRINTK( "atari_stram_free: found block (%p): size=%08lx, owner=%s, "
 			 "flags=%02x\n", block, block->size, block->owner, block->flags );
 
-#ifdef CONFIG_STRAM_SWAP
-	if (!max_swap_size) {
-#endif
-		if (block->flags & BLOCK_GFP) {
-			DPRINTK("atari_stram_free: is kmalloced, order_size=%d\n",
-				get_order(block->size));
-			free_pages((unsigned long)addr, get_order(block->size));
-		}
-		else
-			goto fail;
-#ifdef CONFIG_STRAM_SWAP
-	}
-	else if (block->flags & BLOCK_INSWAP) {
-		DPRINTK( "atari_stram_free: is swap-alloced\n" );
-		free_stram_region( SWAP_NR(block->start), N_PAGES(block->size) );
-	}
-	else
+	if (!(block->flags & BLOCK_GFP))
 		goto fail;
-#endif
+
+	DPRINTK("atari_stram_free: is kmalloced, order_size=%d\n",
+		get_order(block->size));
+	free_pages((unsigned long)addr, get_order(block->size));
 	remove_region( block );
 	return;
 
@@ -478,612 +239,6 @@ void atari_stram_free( void *addr )
 			"(called from %p)\n", addr, __builtin_return_address(0) );
 }
 
-
-#ifdef CONFIG_STRAM_SWAP
-
-
-/* ------------------------------------------------------------------------ */
-/*						   Main Swapping Functions							*/
-/* ------------------------------------------------------------------------ */
-
-
-/*
- * Initialize ST-RAM swap device
- * (lots copied and modified from sys_swapon() in mm/swapfile.c)
- */
-static int __init swap_init(void *start_mem, void *swap_data)
-{
-	static struct dentry fake_dentry;
-	static struct vfsmount fake_vfsmnt;
-	struct swap_info_struct *p;
-	struct inode swap_inode;
-	unsigned int type;
-	void *addr;
-	int i, j, k, prev;
-
-	DPRINTK("swap_init(start_mem=%p, swap_data=%p)\n",
-		start_mem, swap_data);
-
-	/* need at least one page for swapping to (and this also isn't very
-	 * much... :-) */
-	if (swap_end - swap_start < 2*PAGE_SIZE) {
-		printk( KERN_WARNING "stram_swap_init: swap space too small\n" );
-		return( 0 );
-	}
-
-	/* find free slot in swap_info */
-	for( p = swap_info, type = 0; type < nr_swapfiles; type++, p++ )
-		if (!(p->flags & SWP_USED))
-			break;
-	if (type >= MAX_SWAPFILES) {
-		printk( KERN_WARNING "stram_swap_init: max. number of "
-				"swap devices exhausted\n" );
-		return( 0 );
-	}
-	if (type >= nr_swapfiles)
-		nr_swapfiles = type+1;
-
-	stram_swap_info = p;
-	stram_swap_type = type;
-
-	/* fake some dir cache entries to give us some name in /dev/swaps */
-	fake_dentry.d_parent = &fake_dentry;
-	fake_dentry.d_name.name = "stram (internal)";
-	fake_dentry.d_name.len = 16;
-	fake_vfsmnt.mnt_parent = &fake_vfsmnt;
-
-	p->flags        = SWP_USED;
-	p->swap_file    = &fake_dentry;
-	p->swap_vfsmnt  = &fake_vfsmnt;
-	p->swap_map	= swap_data;
-	p->cluster_nr   = 0;
-	p->next         = -1;
-	p->prio         = 0x7ff0;	/* a rather high priority, but not the higest
-								 * to give the user a chance to override */
-
-	/* call stram_open() directly, avoids at least the overhead in
-	 * constructing a dummy file structure... */
-	swap_inode.i_rdev = MKDEV( STRAM_MAJOR, STRAM_MINOR );
-	stram_open( &swap_inode, MAGIC_FILE_P );
-	p->max = SWAP_NR(swap_end);
-
-	/* initialize swap_map: set regions that are already allocated or belong
-	 * to kernel data space to SWAP_MAP_BAD, otherwise to free */
-	j = 0; /* # of free pages */
-	k = 0; /* # of already allocated pages (from pre-mem_init stram_alloc()) */
-	p->lowest_bit = 0;
-	p->highest_bit = 0;
-	for( i = 1, addr = SWAP_ADDR(1); i < p->max;
-		 i++, addr += PAGE_SIZE ) {
-		if (in_some_region( addr )) {
-			p->swap_map[i] = SWAP_MAP_BAD;
-			++k;
-		}
-		else if (kernel_in_stram && addr < start_mem ) {
-			p->swap_map[i] = SWAP_MAP_BAD;
-		}
-		else {
-			p->swap_map[i] = 0;
-			++j;
-			if (!p->lowest_bit) p->lowest_bit = i;
-			p->highest_bit = i;
-		}
-	}
-	/* first page always reserved (and doesn't really belong to swap space) */
-	p->swap_map[0] = SWAP_MAP_BAD;
-
-	/* now swapping to this device ok */
-	p->pages = j + k;
-	swap_list_lock();
-	nr_swap_pages += j;
-	p->flags = SWP_WRITEOK;
-
-	/* insert swap space into swap_list */
-	prev = -1;
-	for (i = swap_list.head; i >= 0; i = swap_info[i].next) {
-		if (p->prio >= swap_info[i].prio) {
-			break;
-		}
-		prev = i;
-	}
-	p->next = i;
-	if (prev < 0) {
-		swap_list.head = swap_list.next = p - swap_info;
-	} else {
-		swap_info[prev].next = p - swap_info;
-	}
-	swap_list_unlock();
-
-	printk( KERN_INFO "Using %dk (%d pages) of ST-RAM as swap space.\n",
-			p->pages << 2, p->pages );
-	return( 1 );
-}
-
-
-/*
- * The swap entry has been read in advance, and we return 1 to indicate
- * that the page has been used or is no longer needed.
- *
- * Always set the resulting pte to be nowrite (the same as COW pages
- * after one process has exited).  We don't know just how many PTEs will
- * share this swap entry, so be cautious and let do_wp_page work out
- * what to do if a write is requested later.
- */
-static inline void unswap_pte(struct vm_area_struct * vma, unsigned long
-			      address, pte_t *dir, swp_entry_t entry,
-			      struct page *page)
-{
-	pte_t pte = *dir;
-
-	if (pte_none(pte))
-		return;
-	if (pte_present(pte)) {
-		/* If this entry is swap-cached, then page must already
-                   hold the right address for any copies in physical
-                   memory */
-		if (pte_page(pte) != page)
-			return;
-		/* We will be removing the swap cache in a moment, so... */
-		set_pte(dir, pte_mkdirty(pte));
-		return;
-	}
-	if (pte_val(pte) != entry.val)
-		return;
-
-	DPRINTK("unswap_pte: replacing entry %08lx by new page %p",
-		entry.val, page);
-	set_pte(dir, pte_mkdirty(mk_pte(page, vma->vm_page_prot)));
-	swap_free(entry);
-	get_page(page);
-	inc_mm_counter(vma->vm_mm, rss);
-}
-
-static inline void unswap_pmd(struct vm_area_struct * vma, pmd_t *dir,
-			      unsigned long address, unsigned long size,
-			      unsigned long offset, swp_entry_t entry,
-			      struct page *page)
-{
-	pte_t * pte;
-	unsigned long end;
-
-	if (pmd_none(*dir))
-		return;
-	if (pmd_bad(*dir)) {
-		pmd_ERROR(*dir);
-		pmd_clear(dir);
-		return;
-	}
-	pte = pte_offset_kernel(dir, address);
-	offset += address & PMD_MASK;
-	address &= ~PMD_MASK;
-	end = address + size;
-	if (end > PMD_SIZE)
-		end = PMD_SIZE;
-	do {
-		unswap_pte(vma, offset+address-vma->vm_start, pte, entry, page);
-		address += PAGE_SIZE;
-		pte++;
-	} while (address < end);
-}
-
-static inline void unswap_pgd(struct vm_area_struct * vma, pgd_t *dir,
-			      unsigned long address, unsigned long size,
-			      swp_entry_t entry, struct page *page)
-{
-	pmd_t * pmd;
-	unsigned long offset, end;
-
-	if (pgd_none(*dir))
-		return;
-	if (pgd_bad(*dir)) {
-		pgd_ERROR(*dir);
-		pgd_clear(dir);
-		return;
-	}
-	pmd = pmd_offset(dir, address);
-	offset = address & PGDIR_MASK;
-	address &= ~PGDIR_MASK;
-	end = address + size;
-	if (end > PGDIR_SIZE)
-		end = PGDIR_SIZE;
-	do {
-		unswap_pmd(vma, pmd, address, end - address, offset, entry,
-			   page);
-		address = (address + PMD_SIZE) & PMD_MASK;
-		pmd++;
-	} while (address < end);
-}
-
-static void unswap_vma(struct vm_area_struct * vma, pgd_t *pgdir,
-		       swp_entry_t entry, struct page *page)
-{
-	unsigned long start = vma->vm_start, end = vma->vm_end;
-
-	do {
-		unswap_pgd(vma, pgdir, start, end - start, entry, page);
-		start = (start + PGDIR_SIZE) & PGDIR_MASK;
-		pgdir++;
-	} while (start < end);
-}
-
-static void unswap_process(struct mm_struct * mm, swp_entry_t entry,
-			   struct page *page)
-{
-	struct vm_area_struct* vma;
-
-	/*
-	 * Go through process' page directory.
-	 */
-	if (!mm)
-		return;
-	for (vma = mm->mmap; vma; vma = vma->vm_next) {
-		pgd_t * pgd = pgd_offset(mm, vma->vm_start);
-		unswap_vma(vma, pgd, entry, page);
-	}
-}
-
-
-static int unswap_by_read(unsigned short *map, unsigned long max,
-			  unsigned long start, unsigned long n_pages)
-{
-	struct task_struct *p;
-	struct page *page;
-	swp_entry_t entry;
-	unsigned long i;
-
-	DPRINTK( "unswapping %lu..%lu by reading in\n",
-			 start, start+n_pages-1 );
-
-	for( i = start; i < start+n_pages; ++i ) {
-		if (map[i] == SWAP_MAP_BAD) {
-			printk( KERN_ERR "get_stram_region: page %lu already "
-					"reserved??\n", i );
-			continue;
-		}
-
-		if (map[i]) {
-			entry = swp_entry(stram_swap_type, i);
-			DPRINTK("unswap: map[i=%lu]=%u nr_swap=%ld\n",
-				i, map[i], nr_swap_pages);
-
-			swap_device_lock(stram_swap_info);
-			map[i]++;
-			swap_device_unlock(stram_swap_info);
-			/* Get a page for the entry, using the existing
-			   swap cache page if there is one.  Otherwise,
-			   get a clean page and read the swap into it. */
-			page = read_swap_cache_async(entry, NULL, 0);
-			if (!page) {
-				swap_free(entry);
-				return -ENOMEM;
-			}
-			read_lock(&tasklist_lock);
-			for_each_process(p)
-				unswap_process(p->mm, entry, page);
-			read_unlock(&tasklist_lock);
-			shmem_unuse(entry, page);
-			/* Now get rid of the extra reference to the
-			   temporary page we've been using. */
-			if (PageSwapCache(page))
-				delete_from_swap_cache(page);
-			__free_page(page);
-	#ifdef DO_PROC
-			stat_swap_force++;
-	#endif
-		}
-
-		DPRINTK( "unswap: map[i=%lu]=%u nr_swap=%ld\n",
-				 i, map[i], nr_swap_pages );
-		swap_list_lock();
-		swap_device_lock(stram_swap_info);
-		map[i] = SWAP_MAP_BAD;
-		if (stram_swap_info->lowest_bit == i)
-			stram_swap_info->lowest_bit++;
-		if (stram_swap_info->highest_bit == i)
-			stram_swap_info->highest_bit--;
-		--nr_swap_pages;
-		swap_device_unlock(stram_swap_info);
-		swap_list_unlock();
-	}
-
-	return 0;
-}
-
-/*
- * reserve a region in ST-RAM swap space for an allocation
- */
-static void *get_stram_region( unsigned long n_pages )
-{
-	unsigned short *map = stram_swap_info->swap_map;
-	unsigned long max = stram_swap_info->max;
-	unsigned long start, total_free, region_free;
-	int err;
-	void *ret = NULL;
-
-	DPRINTK( "get_stram_region(n_pages=%lu)\n", n_pages );
-
-	down(&stram_swap_sem);
-
-	/* disallow writing to the swap device now */
-	stram_swap_info->flags = SWP_USED;
-
-	/* find a region of n_pages pages in the swap space including as much free
-	 * pages as possible (and excluding any already-reserved pages). */
-	if (!(start = find_free_region( n_pages, &total_free, &region_free )))
-		goto end;
-	DPRINTK( "get_stram_region: region starts at %lu, has %lu free pages\n",
-			 start, region_free );
-
-	err = unswap_by_read(map, max, start, n_pages);
-	if (err)
-		goto end;
-
-	ret = SWAP_ADDR(start);
-  end:
-	/* allow using swap device again */
-	stram_swap_info->flags = SWP_WRITEOK;
-	up(&stram_swap_sem);
-	DPRINTK( "get_stram_region: returning %p\n", ret );
-	return( ret );
-}
-
-
-/*
- * free a reserved region in ST-RAM swap space
- */
-static void free_stram_region( unsigned long offset, unsigned long n_pages )
-{
-	unsigned short *map = stram_swap_info->swap_map;
-
-	DPRINTK( "free_stram_region(offset=%lu,n_pages=%lu)\n", offset, n_pages );
-
-	if (offset < 1 || offset + n_pages > stram_swap_info->max) {
-		printk( KERN_ERR "free_stram_region: Trying to free non-ST-RAM\n" );
-		return;
-	}
-
-	swap_list_lock();
-	swap_device_lock(stram_swap_info);
-	/* un-reserve the freed pages */
-	for( ; n_pages > 0; ++offset, --n_pages ) {
-		if (map[offset] != SWAP_MAP_BAD)
-			printk( KERN_ERR "free_stram_region: Swap page %lu was not "
-					"reserved\n", offset );
-		map[offset] = 0;
-	}
-
-	/* update swapping meta-data */
-	if (offset < stram_swap_info->lowest_bit)
-		stram_swap_info->lowest_bit = offset;
-	if (offset+n_pages-1 > stram_swap_info->highest_bit)
-		stram_swap_info->highest_bit = offset+n_pages-1;
-	if (stram_swap_info->prio > swap_info[swap_list.next].prio)
-		swap_list.next = swap_list.head;
-	nr_swap_pages += n_pages;
-	swap_device_unlock(stram_swap_info);
-	swap_list_unlock();
-}
-
-
-/* ------------------------------------------------------------------------ */
-/*						Utility Functions for Swapping						*/
-/* ------------------------------------------------------------------------ */
-
-
-/* is addr in some of the allocated regions? */
-static int in_some_region(void *addr)
-{
-	BLOCK *p;
-
-	for( p = alloc_list; p; p = p->next ) {
-		if (p->start <= addr && addr < p->start + p->size)
-			return( 1 );
-	}
-	return( 0 );
-}
-
-
-static unsigned long find_free_region(unsigned long n_pages,
-				      unsigned long *total_free,
-				      unsigned long *region_free)
-{
-	unsigned short *map = stram_swap_info->swap_map;
-	unsigned long max = stram_swap_info->max;
-	unsigned long head, tail, max_start;
-	long nfree, max_free;
-
-	/* first scan the swap space for a suitable place for the allocation */
-	head = 1;
-	max_start = 0;
-	max_free = -1;
-	*total_free = 0;
-
-  start_over:
-	/* increment tail until final window size reached, and count free pages */
-	nfree = 0;
-	for( tail = head; tail-head < n_pages && tail < max; ++tail ) {
-		if (map[tail] == SWAP_MAP_BAD) {
-			head = tail+1;
-			goto start_over;
-		}
-		if (!map[tail]) {
-			++nfree;
-			++*total_free;
-		}
-	}
-	if (tail-head < n_pages)
-		goto out;
-	if (nfree > max_free) {
-		max_start = head;
-		max_free  = nfree;
-		if (max_free >= n_pages)
-			/* don't need more free pages... :-) */
-			goto out;
-	}
-
-	/* now shift the window and look for the area where as much pages as
-	 * possible are free */
-	while( tail < max ) {
-		nfree -= (map[head++] == 0);
-		if (map[tail] == SWAP_MAP_BAD) {
-			head = tail+1;
-			goto start_over;
-		}
-		if (!map[tail]) {
-			++nfree;
-			++*total_free;
-		}
-		++tail;
-		if (nfree > max_free) {
-			max_start = head;
-			max_free  = nfree;
-			if (max_free >= n_pages)
-				/* don't need more free pages... :-) */
-				goto out;
-		}
-	}
-
-  out:
-	if (max_free < 0) {
-		printk( KERN_NOTICE "get_stram_region: ST-RAM too full or fragmented "
-				"-- can't allocate %lu pages\n", n_pages );
-		return( 0 );
-	}
-
-	*region_free = max_free;
-	return( max_start );
-}
-
-
-/* setup parameters from command line */
-void __init stram_swap_setup(char *str, int *ints)
-{
-	if (ints[0] >= 1)
-		max_swap_size = ((ints[1] < 0 ? 0 : ints[1]) * 1024) & PAGE_MASK;
-}
-
-
-/* ------------------------------------------------------------------------ */
-/*								ST-RAM device								*/
-/* ------------------------------------------------------------------------ */
-
-static int refcnt;
-
-static void do_stram_request(request_queue_t *q)
-{
-	struct request *req;
-
-	while ((req = elv_next_request(q)) != NULL) {
-		void *start = swap_start + (req->sector << 9);
-		unsigned long len = req->current_nr_sectors << 9;
-		if ((start + len) > swap_end) {
-			printk( KERN_ERR "stram: bad access beyond end of device: "
-					"block=%ld, count=%d\n",
-					req->sector,
-					req->current_nr_sectors );
-			end_request(req, 0);
-			continue;
-		}
-
-		if (req->cmd == READ) {
-			memcpy(req->buffer, start, len);
-#ifdef DO_PROC
-			stat_swap_read += N_PAGES(len);
-#endif
-		}
-		else {
-			memcpy(start, req->buffer, len);
-#ifdef DO_PROC
-			stat_swap_write += N_PAGES(len);
-#endif
-		}
-		end_request(req, 1);
-	}
-}
-
-
-static int stram_open( struct inode *inode, struct file *filp )
-{
-	if (filp != MAGIC_FILE_P) {
-		printk( KERN_NOTICE "Only kernel can open ST-RAM device\n" );
-		return( -EPERM );
-	}
-	if (refcnt)
-		return( -EBUSY );
-	++refcnt;
-	return( 0 );
-}
-
-static int stram_release( struct inode *inode, struct file *filp )
-{
-	if (filp != MAGIC_FILE_P) {
-		printk( KERN_NOTICE "Only kernel can close ST-RAM device\n" );
-		return( -EPERM );
-	}
-	if (refcnt > 0)
-		--refcnt;
-	return( 0 );
-}
-
-
-static struct block_device_operations stram_fops = {
-	.open =		stram_open,
-	.release =	stram_release,
-};
-
-static struct gendisk *stram_disk;
-static struct request_queue *stram_queue;
-static DEFINE_SPINLOCK(stram_lock);
-
-int __init stram_device_init(void)
-{
-	if (!MACH_IS_ATARI)
-		/* no point in initializing this, I hope */
-		return -ENXIO;
-
-	if (!max_swap_size)
-		/* swapping not enabled */
-		return -ENXIO;
-	stram_disk = alloc_disk(1);
-	if (!stram_disk)
-		return -ENOMEM;
-
-	if (register_blkdev(STRAM_MAJOR, "stram")) {
-		put_disk(stram_disk);
-		return -ENXIO;
-	}
-
-	stram_queue = blk_init_queue(do_stram_request, &stram_lock);
-	if (!stram_queue) {
-		unregister_blkdev(STRAM_MAJOR, "stram");
-		put_disk(stram_disk);
-		return -ENOMEM;
-	}
-
-	stram_disk->major = STRAM_MAJOR;
-	stram_disk->first_minor = STRAM_MINOR;
-	stram_disk->fops = &stram_fops;
-	stram_disk->queue = stram_queue;
-	sprintf(stram_disk->disk_name, "stram");
-	set_capacity(stram_disk, (swap_end - swap_start)/512);
-	add_disk(stram_disk);
-	return 0;
-}
-
-
-
-/* ------------------------------------------------------------------------ */
-/*							Misc Utility Functions							*/
-/* ------------------------------------------------------------------------ */
-
-/* reserve a range of pages */
-static void reserve_region(void *start, void *end)
-{
-	reserve_bootmem (virt_to_phys(start), end - start);
-}
-
-#endif /* CONFIG_STRAM_SWAP */
-
 
 /* ------------------------------------------------------------------------ */
 /*							  Region Management								*/
@@ -1173,50 +328,9 @@ int get_stram_list( char *buf )
 {
 	int len = 0;
 	BLOCK *p;
-#ifdef CONFIG_STRAM_SWAP
-	int i;
-	unsigned short *map = stram_swap_info->swap_map;
-	unsigned long max = stram_swap_info->max;
-	unsigned free = 0, used = 0, rsvd = 0;
-#endif
 
-#ifdef CONFIG_STRAM_SWAP
-	if (max_swap_size) {
-		for( i = 1; i < max; ++i ) {
-			if (!map[i])
-				++free;
-			else if (map[i] == SWAP_MAP_BAD)
-				++rsvd;
-			else
-				++used;
-		}
-		PRINT_PROC(
-			"Total ST-RAM:      %8u kB\n"
-			"Total ST-RAM swap: %8lu kB\n"
-			"Free swap:         %8u kB\n"
-			"Used swap:         %8u kB\n"
-			"Allocated swap:    %8u kB\n"
-			"Swap Reads:        %8u\n"
-			"Swap Writes:       %8u\n"
-			"Swap Forced Reads: %8u\n",
-			(stram_end - stram_start) >> 10,
-			(max-1) << (PAGE_SHIFT-10),
-			free << (PAGE_SHIFT-10),
-			used << (PAGE_SHIFT-10),
-			rsvd << (PAGE_SHIFT-10),
-			stat_swap_read,
-			stat_swap_write,
-			stat_swap_force );
-	}
-	else {
-#endif
-		PRINT_PROC( "ST-RAM swapping disabled\n" );
-		PRINT_PROC("Total ST-RAM:      %8u kB\n",
+	PRINT_PROC("Total ST-RAM:      %8u kB\n",
 			   (stram_end - stram_start) >> 10);
-#ifdef CONFIG_STRAM_SWAP
-	}
-#endif
-
 	PRINT_PROC( "Allocated regions:\n" );
 	for( p = alloc_list; p; p = p->next ) {
 		if (len + 50 >= PAGE_SIZE)
@@ -1227,8 +341,6 @@ int get_stram_list( char *buf )
 			   p->owner);
 		if (p->flags & BLOCK_GFP)
 			PRINT_PROC( "page-alloced)\n" );
-		else if (p->flags & BLOCK_INSWAP)
-			PRINT_PROC( "in swap)\n" );
 		else
 			PRINT_PROC( "??)\n" );
 	}

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/atari/stram.c b/arch/m68k/atari/stram.c
new file mode 100644
index 000000000000..5a3c106b40c8
--- /dev/null
+++ b/arch/m68k/atari/stram.c
@@ -0,0 +1,1247 @@
+/*
+ * arch/m68k/atari/stram.c: Functions for ST-RAM allocations
+ *
+ * Copyright 1994-97 Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/kdev_t.h>
+#include <linux/major.h>
+#include <linux/init.h>
+#include <linux/swap.h>
+#include <linux/slab.h>
+#include <linux/vmalloc.h>
+#include <linux/pagemap.h>
+#include <linux/shm.h>
+#include <linux/bootmem.h>
+#include <linux/mount.h>
+#include <linux/blkdev.h>
+
+#include <asm/setup.h>
+#include <asm/machdep.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/atarihw.h>
+#include <asm/atari_stram.h>
+#include <asm/io.h>
+#include <asm/semaphore.h>
+
+#include <linux/swapops.h>
+
+#undef DEBUG
+
+#ifdef DEBUG
+#define	DPRINTK(fmt,args...) printk( fmt, ##args )
+#else
+#define DPRINTK(fmt,args...)
+#endif
+
+#if defined(CONFIG_PROC_FS) && defined(CONFIG_STRAM_PROC)
+/* abbrev for the && above... */
+#define DO_PROC
+#include <linux/proc_fs.h>
+#endif
+
+/* Pre-swapping comments:
+ *
+ * ++roman:
+ *
+ * New version of ST-Ram buffer allocation. Instead of using the
+ * 1 MB - 4 KB that remain when the ST-Ram chunk starts at $1000
+ * (1 MB granularity!), such buffers are reserved like this:
+ *
+ *  - If the kernel resides in ST-Ram anyway, we can take the buffer
+ *    from behind the current kernel data space the normal way
+ *    (incrementing start_mem).
+ *
+ *  - If the kernel is in TT-Ram, stram_init() initializes start and
+ *    end of the available region. Buffers are allocated from there
+ *    and mem_init() later marks the such used pages as reserved.
+ *    Since each TT-Ram chunk is at least 4 MB in size, I hope there
+ *    won't be an overrun of the ST-Ram region by normal kernel data
+ *    space.
+ *
+ * For that, ST-Ram may only be allocated while kernel initialization
+ * is going on, or exactly: before mem_init() is called. There is also
+ * no provision now for freeing ST-Ram buffers. It seems that isn't
+ * really needed.
+ *
+ */
+
+/*
+ * New Nov 1997: Use ST-RAM as swap space!
+ *
+ * In the past, there were often problems with modules that require ST-RAM
+ * buffers. Such drivers have to use __get_dma_pages(), which unfortunately
+ * often isn't very successful in allocating more than 1 page :-( [1] The net
+ * result was that most of the time you couldn't insmod such modules (ataflop,
+ * ACSI, SCSI on Falcon, Atari internal framebuffer, not to speak of acsi_slm,
+ * which needs a 1 MB buffer... :-).
+ *
+ * To overcome this limitation, ST-RAM can now be turned into a very
+ * high-speed swap space. If a request for an ST-RAM buffer comes, the kernel
+ * now tries to unswap some pages on that swap device to make some free (and
+ * contiguous) space. This works much better in comparison to
+ * __get_dma_pages(), since used swap pages can be selectively freed by either
+ * moving them to somewhere else in swap space, or by reading them back into
+ * system memory. Ok, there operation of unswapping isn't really cheap (for
+ * each page, one has to go through the page tables of all processes), but it
+ * doesn't happen that often (only when allocation ST-RAM, i.e. when loading a
+ * module that needs ST-RAM). But it at least makes it possible to load such
+ * modules!
+ *
+ * It could also be that overall system performance increases a bit due to
+ * ST-RAM swapping, since slow ST-RAM isn't used anymore for holding data or
+ * executing code in. It's then just a (very fast, compared to disk) back
+ * storage for not-so-often needed data. (But this effect must be compared
+ * with the loss of total memory...) Don't know if the effect is already
+ * visible on a TT, where the speed difference between ST- and TT-RAM isn't
+ * that dramatic, but it should on machines where TT-RAM is really much faster
+ * (e.g. Afterburner).
+ *
+ *   [1]: __get_free_pages() does a fine job if you only want one page, but if
+ * you want more (contiguous) pages, it can give you such a block only if
+ * there's already a free one. The algorithm can't try to free buffers or swap
+ * out something in order to make more free space, since all that page-freeing
+ * mechanisms work "target-less", i.e. they just free something, but not in a
+ * specific place. I.e., __get_free_pages() can't do anything to free
+ * *adjacent* pages :-( This situation becomes even worse for DMA memory,
+ * since the freeing algorithms are also blind to DMA capability of pages.
+ */
+
+/* 1998-10-20: ++andreas
+   unswap_by_move disabled because it does not handle swapped shm pages.
+*/
+
+/* 2000-05-01: ++andreas
+   Integrated with bootmem.  Remove all traces of unswap_by_move.
+*/
+
+#ifdef CONFIG_STRAM_SWAP
+#define ALIGN_IF_SWAP(x)	PAGE_ALIGN(x)
+#else
+#define ALIGN_IF_SWAP(x)	(x)
+#endif
+
+/* get index of swap page at address 'addr' */
+#define SWAP_NR(addr)		(((addr) - swap_start) >> PAGE_SHIFT)
+
+/* get address of swap page #'nr' */
+#define SWAP_ADDR(nr)		(swap_start + ((nr) << PAGE_SHIFT))
+
+/* get number of pages for 'n' bytes (already page-aligned) */
+#define N_PAGES(n)			((n) >> PAGE_SHIFT)
+
+/* The following two numbers define the maximum fraction of ST-RAM in total
+ * memory, below that the kernel would automatically use ST-RAM as swap
+ * space. This decision can be overridden with stram_swap= */
+#define MAX_STRAM_FRACTION_NOM		1
+#define MAX_STRAM_FRACTION_DENOM	3
+
+/* Start and end (virtual) of ST-RAM */
+static void *stram_start, *stram_end;
+
+/* set after memory_init() executed and allocations via start_mem aren't
+ * possible anymore */
+static int mem_init_done;
+
+/* set if kernel is in ST-RAM */
+static int kernel_in_stram;
+
+typedef struct stram_block {
+	struct stram_block *next;
+	void *start;
+	unsigned long size;
+	unsigned flags;
+	const char *owner;
+} BLOCK;
+
+/* values for flags field */
+#define BLOCK_FREE		0x01	/* free structure in the BLOCKs pool */
+#define BLOCK_KMALLOCED	0x02	/* structure allocated by kmalloc() */
+#define BLOCK_GFP		0x08	/* block allocated with __get_dma_pages() */
+#define BLOCK_INSWAP	0x10	/* block allocated in swap space */
+
+/* list of allocated blocks */
+static BLOCK *alloc_list;
+
+/* We can't always use kmalloc() to allocate BLOCK structures, since
+ * stram_alloc() can be called rather early. So we need some pool of
+ * statically allocated structures. 20 of them is more than enough, so in most
+ * cases we never should need to call kmalloc(). */
+#define N_STATIC_BLOCKS	20
+static BLOCK static_blocks[N_STATIC_BLOCKS];
+
+#ifdef CONFIG_STRAM_SWAP
+/* max. number of bytes to use for swapping
+ *  0 = no ST-RAM swapping
+ * -1 = do swapping (to whole ST-RAM) if it's less than MAX_STRAM_FRACTION of
+ *      total memory
+ */
+static int max_swap_size = -1;
+
+/* start and end of swapping area */
+static void *swap_start, *swap_end;
+
+/* The ST-RAM's swap info structure */
+static struct swap_info_struct *stram_swap_info;
+
+/* The ST-RAM's swap type */
+static int stram_swap_type;
+
+/* Semaphore for get_stram_region.  */
+static DECLARE_MUTEX(stram_swap_sem);
+
+/* major and minor device number of the ST-RAM device; for the major, we use
+ * the same as Amiga z2ram, which is really similar and impossible on Atari,
+ * and for the minor a relatively odd number to avoid the user creating and
+ * using that device. */
+#define	STRAM_MAJOR		Z2RAM_MAJOR
+#define	STRAM_MINOR		13
+
+/* Some impossible pointer value */
+#define MAGIC_FILE_P	(struct file *)0xffffdead
+
+#ifdef DO_PROC
+static unsigned stat_swap_read;
+static unsigned stat_swap_write;
+static unsigned stat_swap_force;
+#endif /* DO_PROC */
+
+#endif /* CONFIG_STRAM_SWAP */
+
+/***************************** Prototypes *****************************/
+
+#ifdef CONFIG_STRAM_SWAP
+static int swap_init(void *start_mem, void *swap_data);
+static void *get_stram_region( unsigned long n_pages );
+static void free_stram_region( unsigned long offset, unsigned long n_pages
+			       );
+static int in_some_region(void *addr);
+static unsigned long find_free_region( unsigned long n_pages, unsigned long
+				       *total_free, unsigned long
+				       *region_free );
+static void do_stram_request(request_queue_t *);
+static int stram_open( struct inode *inode, struct file *filp );
+static int stram_release( struct inode *inode, struct file *filp );
+static void reserve_region(void *start, void *end);
+#endif
+static BLOCK *add_region( void *addr, unsigned long size );
+static BLOCK *find_region( void *addr );
+static int remove_region( BLOCK *block );
+
+/************************* End of Prototypes **************************/
+
+
+/* ------------------------------------------------------------------------ */
+/*							   Public Interface								*/
+/* ------------------------------------------------------------------------ */
+
+/*
+ * This init function is called very early by atari/config.c
+ * It initializes some internal variables needed for stram_alloc()
+ */
+void __init atari_stram_init(void)
+{
+	int i;
+
+	/* initialize static blocks */
+	for( i = 0; i < N_STATIC_BLOCKS; ++i )
+		static_blocks[i].flags = BLOCK_FREE;
+
+	/* determine whether kernel code resides in ST-RAM (then ST-RAM is the
+	 * first memory block at virtual 0x0) */
+	stram_start = phys_to_virt(0);
+	kernel_in_stram = (stram_start == 0);
+
+	for( i = 0; i < m68k_num_memory; ++i ) {
+		if (m68k_memory[i].addr == 0) {
+			/* skip first 2kB or page (supervisor-only!) */
+			stram_end = stram_start + m68k_memory[i].size;
+			return;
+		}
+	}
+	/* Should never come here! (There is always ST-Ram!) */
+	panic( "atari_stram_init: no ST-RAM found!" );
+}
+
+
+/*
+ * This function is called from setup_arch() to reserve the pages needed for
+ * ST-RAM management.
+ */
+void __init atari_stram_reserve_pages(void *start_mem)
+{
+#ifdef CONFIG_STRAM_SWAP
+	/* if max_swap_size is negative (i.e. no stram_swap= option given),
+	 * determine at run time whether to use ST-RAM swapping */
+	if (max_swap_size < 0)
+		/* Use swapping if ST-RAM doesn't make up more than MAX_STRAM_FRACTION
+		 * of total memory. In that case, the max. size is set to 16 MB,
+		 * because ST-RAM can never be bigger than that.
+		 * Also, never use swapping on a Hades, there's no separate ST-RAM in
+		 * that machine. */
+		max_swap_size =
+			(!MACH_IS_HADES &&
+			 (N_PAGES(stram_end-stram_start)*MAX_STRAM_FRACTION_DENOM <=
+			  ((unsigned long)high_memory>>PAGE_SHIFT)*MAX_STRAM_FRACTION_NOM)) ? 16*1024*1024 : 0;
+	DPRINTK( "atari_stram_reserve_pages: max_swap_size = %d\n", max_swap_size );
+#endif
+
+	/* always reserve first page of ST-RAM, the first 2 kB are
+	 * supervisor-only! */
+	if (!kernel_in_stram)
+		reserve_bootmem (0, PAGE_SIZE);
+
+#ifdef CONFIG_STRAM_SWAP
+	{
+		void *swap_data;
+
+		start_mem = (void *) PAGE_ALIGN ((unsigned long) start_mem);
+		/* determine first page to use as swap: if the kernel is
+		   in TT-RAM, this is the first page of (usable) ST-RAM;
+		   otherwise just use the end of kernel data (= start_mem) */
+		swap_start = !kernel_in_stram ? stram_start + PAGE_SIZE : start_mem;
+		/* decrement by one page, rest of kernel assumes that first swap page
+		 * is always reserved and maybe doesn't handle swp_entry == 0
+		 * correctly */
+		swap_start -= PAGE_SIZE;
+		swap_end = stram_end;
+		if (swap_end-swap_start > max_swap_size)
+			swap_end =  swap_start + max_swap_size;
+		DPRINTK( "atari_stram_reserve_pages: swapping enabled; "
+				 "swap=%p-%p\n", swap_start, swap_end);
+
+		/* reserve some amount of memory for maintainance of
+		 * swapping itself: one page for each 2048 (PAGE_SIZE/2)
+		 * swap pages. (2 bytes for each page) */
+		swap_data = start_mem;
+		start_mem += ((SWAP_NR(swap_end) + PAGE_SIZE/2 - 1)
+			      >> (PAGE_SHIFT-1)) << PAGE_SHIFT;
+		/* correct swap_start if necessary */
+		if (swap_start + PAGE_SIZE == swap_data)
+			swap_start = start_mem - PAGE_SIZE;
+
+		if (!swap_init( start_mem, swap_data )) {
+			printk( KERN_ERR "ST-RAM swap space initialization failed\n" );
+			max_swap_size = 0;
+			return;
+		}
+		/* reserve region for swapping meta-data */
+		reserve_region(swap_data, start_mem);
+		/* reserve swapping area itself */
+		reserve_region(swap_start + PAGE_SIZE, swap_end);
+
+		/*
+		 * If the whole ST-RAM is used for swapping, there are no allocatable
+		 * dma pages left. But unfortunately, some shared parts of the kernel
+		 * (particularly the SCSI mid-level) call __get_dma_pages()
+		 * unconditionally :-( These calls then fail, and scsi.c even doesn't
+		 * check for NULL return values and just crashes. The quick fix for
+		 * this (instead of doing much clean up work in the SCSI code) is to
+		 * pretend all pages are DMA-able by setting mach_max_dma_address to
+		 * ULONG_MAX. This doesn't change any functionality so far, since
+		 * get_dma_pages() shouldn't be used on Atari anyway anymore (better
+		 * use atari_stram_alloc()), and the Atari SCSI drivers don't need DMA
+		 * memory. But unfortunately there's now no kind of warning (even not
+		 * a NULL return value) if you use get_dma_pages() nevertheless :-(
+		 * You just will get non-DMA-able memory...
+		 */
+		mach_max_dma_address = 0xffffffff;
+	}
+#endif
+}
+
+void atari_stram_mem_init_hook (void)
+{
+	mem_init_done = 1;
+}
+
+
+/*
+ * This is main public interface: somehow allocate a ST-RAM block
+ * There are three strategies:
+ *
+ *  - If we're before mem_init(), we have to make a static allocation. The
+ *    region is taken in the kernel data area (if the kernel is in ST-RAM) or
+ *    from the start of ST-RAM (if the kernel is in TT-RAM) and added to the
+ *    rsvd_stram_* region. The ST-RAM is somewhere in the middle of kernel
+ *    address space in the latter case.
+ *
+ *  - If mem_init() already has been called and ST-RAM swapping is enabled,
+ *    try to get the memory from the (pseudo) swap-space, either free already
+ *    or by moving some other pages out of the swap.
+ *
+ *  - If mem_init() already has been called, and ST-RAM swapping is not
+ *    enabled, the only possibility is to try with __get_dma_pages(). This has
+ *    the disadvantage that it's very hard to get more than 1 page, and it is
+ *    likely to fail :-(
+ *
+ */
+void *atari_stram_alloc(long size, const char *owner)
+{
+	void *addr = NULL;
+	BLOCK *block;
+	int flags;
+
+	DPRINTK("atari_stram_alloc(size=%08lx,owner=%s)\n", size, owner);
+
+	size = ALIGN_IF_SWAP(size);
+	DPRINTK( "atari_stram_alloc: rounded size = %08lx\n", size );
+#ifdef CONFIG_STRAM_SWAP
+	if (max_swap_size) {
+		/* If swapping is active: make some free space in the swap
+		   "device". */
+		DPRINTK( "atari_stram_alloc: after mem_init, swapping ok, "
+				 "calling get_region\n" );
+		addr = get_stram_region( N_PAGES(size) );
+		flags = BLOCK_INSWAP;
+	}
+	else
+#endif
+	if (!mem_init_done)
+		return alloc_bootmem_low(size);
+	else {
+		/* After mem_init() and no swapping: can only resort to
+		 * __get_dma_pages() */
+		addr = (void *)__get_dma_pages(GFP_KERNEL, get_order(size));
+		flags = BLOCK_GFP;
+		DPRINTK( "atari_stram_alloc: after mem_init, swapping off, "
+				 "get_pages=%p\n", addr );
+	}
+
+	if (addr) {
+		if (!(block = add_region( addr, size ))) {
+			/* out of memory for BLOCK structure :-( */
+			DPRINTK( "atari_stram_alloc: out of mem for BLOCK -- "
+					 "freeing again\n" );
+#ifdef CONFIG_STRAM_SWAP
+			if (flags == BLOCK_INSWAP)
+				free_stram_region( SWAP_NR(addr), N_PAGES(size) );
+			else
+#endif
+				free_pages((unsigned long)addr, get_order(size));
+			return( NULL );
+		}
+		block->owner = owner;
+		block->flags |= flags;
+	}
+	return( addr );
+}
+
+void atari_stram_free( void *addr )
+
+{
+	BLOCK *block;
+
+	DPRINTK( "atari_stram_free(addr=%p)\n", addr );
+
+	if (!(block = find_region( addr ))) {
+		printk( KERN_ERR "Attempt to free non-allocated ST-RAM block at %p "
+				"from %p\n", addr, __builtin_return_address(0) );
+		return;
+	}
+	DPRINTK( "atari_stram_free: found block (%p): size=%08lx, owner=%s, "
+			 "flags=%02x\n", block, block->size, block->owner, block->flags );
+
+#ifdef CONFIG_STRAM_SWAP
+	if (!max_swap_size) {
+#endif
+		if (block->flags & BLOCK_GFP) {
+			DPRINTK("atari_stram_free: is kmalloced, order_size=%d\n",
+				get_order(block->size));
+			free_pages((unsigned long)addr, get_order(block->size));
+		}
+		else
+			goto fail;
+#ifdef CONFIG_STRAM_SWAP
+	}
+	else if (block->flags & BLOCK_INSWAP) {
+		DPRINTK( "atari_stram_free: is swap-alloced\n" );
+		free_stram_region( SWAP_NR(block->start), N_PAGES(block->size) );
+	}
+	else
+		goto fail;
+#endif
+	remove_region( block );
+	return;
+
+  fail:
+	printk( KERN_ERR "atari_stram_free: cannot free block at %p "
+			"(called from %p)\n", addr, __builtin_return_address(0) );
+}
+
+
+#ifdef CONFIG_STRAM_SWAP
+
+
+/* ------------------------------------------------------------------------ */
+/*						   Main Swapping Functions							*/
+/* ------------------------------------------------------------------------ */
+
+
+/*
+ * Initialize ST-RAM swap device
+ * (lots copied and modified from sys_swapon() in mm/swapfile.c)
+ */
+static int __init swap_init(void *start_mem, void *swap_data)
+{
+	static struct dentry fake_dentry;
+	static struct vfsmount fake_vfsmnt;
+	struct swap_info_struct *p;
+	struct inode swap_inode;
+	unsigned int type;
+	void *addr;
+	int i, j, k, prev;
+
+	DPRINTK("swap_init(start_mem=%p, swap_data=%p)\n",
+		start_mem, swap_data);
+
+	/* need at least one page for swapping to (and this also isn't very
+	 * much... :-) */
+	if (swap_end - swap_start < 2*PAGE_SIZE) {
+		printk( KERN_WARNING "stram_swap_init: swap space too small\n" );
+		return( 0 );
+	}
+
+	/* find free slot in swap_info */
+	for( p = swap_info, type = 0; type < nr_swapfiles; type++, p++ )
+		if (!(p->flags & SWP_USED))
+			break;
+	if (type >= MAX_SWAPFILES) {
+		printk( KERN_WARNING "stram_swap_init: max. number of "
+				"swap devices exhausted\n" );
+		return( 0 );
+	}
+	if (type >= nr_swapfiles)
+		nr_swapfiles = type+1;
+
+	stram_swap_info = p;
+	stram_swap_type = type;
+
+	/* fake some dir cache entries to give us some name in /dev/swaps */
+	fake_dentry.d_parent = &fake_dentry;
+	fake_dentry.d_name.name = "stram (internal)";
+	fake_dentry.d_name.len = 16;
+	fake_vfsmnt.mnt_parent = &fake_vfsmnt;
+
+	p->flags        = SWP_USED;
+	p->swap_file    = &fake_dentry;
+	p->swap_vfsmnt  = &fake_vfsmnt;
+	p->swap_map	= swap_data;
+	p->cluster_nr   = 0;
+	p->next         = -1;
+	p->prio         = 0x7ff0;	/* a rather high priority, but not the higest
+								 * to give the user a chance to override */
+
+	/* call stram_open() directly, avoids at least the overhead in
+	 * constructing a dummy file structure... */
+	swap_inode.i_rdev = MKDEV( STRAM_MAJOR, STRAM_MINOR );
+	stram_open( &swap_inode, MAGIC_FILE_P );
+	p->max = SWAP_NR(swap_end);
+
+	/* initialize swap_map: set regions that are already allocated or belong
+	 * to kernel data space to SWAP_MAP_BAD, otherwise to free */
+	j = 0; /* # of free pages */
+	k = 0; /* # of already allocated pages (from pre-mem_init stram_alloc()) */
+	p->lowest_bit = 0;
+	p->highest_bit = 0;
+	for( i = 1, addr = SWAP_ADDR(1); i < p->max;
+		 i++, addr += PAGE_SIZE ) {
+		if (in_some_region( addr )) {
+			p->swap_map[i] = SWAP_MAP_BAD;
+			++k;
+		}
+		else if (kernel_in_stram && addr < start_mem ) {
+			p->swap_map[i] = SWAP_MAP_BAD;
+		}
+		else {
+			p->swap_map[i] = 0;
+			++j;
+			if (!p->lowest_bit) p->lowest_bit = i;
+			p->highest_bit = i;
+		}
+	}
+	/* first page always reserved (and doesn't really belong to swap space) */
+	p->swap_map[0] = SWAP_MAP_BAD;
+
+	/* now swapping to this device ok */
+	p->pages = j + k;
+	swap_list_lock();
+	nr_swap_pages += j;
+	p->flags = SWP_WRITEOK;
+
+	/* insert swap space into swap_list */
+	prev = -1;
+	for (i = swap_list.head; i >= 0; i = swap_info[i].next) {
+		if (p->prio >= swap_info[i].prio) {
+			break;
+		}
+		prev = i;
+	}
+	p->next = i;
+	if (prev < 0) {
+		swap_list.head = swap_list.next = p - swap_info;
+	} else {
+		swap_info[prev].next = p - swap_info;
+	}
+	swap_list_unlock();
+
+	printk( KERN_INFO "Using %dk (%d pages) of ST-RAM as swap space.\n",
+			p->pages << 2, p->pages );
+	return( 1 );
+}
+
+
+/*
+ * The swap entry has been read in advance, and we return 1 to indicate
+ * that the page has been used or is no longer needed.
+ *
+ * Always set the resulting pte to be nowrite (the same as COW pages
+ * after one process has exited).  We don't know just how many PTEs will
+ * share this swap entry, so be cautious and let do_wp_page work out
+ * what to do if a write is requested later.
+ */
+static inline void unswap_pte(struct vm_area_struct * vma, unsigned long
+			      address, pte_t *dir, swp_entry_t entry,
+			      struct page *page)
+{
+	pte_t pte = *dir;
+
+	if (pte_none(pte))
+		return;
+	if (pte_present(pte)) {
+		/* If this entry is swap-cached, then page must already
+                   hold the right address for any copies in physical
+                   memory */
+		if (pte_page(pte) != page)
+			return;
+		/* We will be removing the swap cache in a moment, so... */
+		set_pte(dir, pte_mkdirty(pte));
+		return;
+	}
+	if (pte_val(pte) != entry.val)
+		return;
+
+	DPRINTK("unswap_pte: replacing entry %08lx by new page %p",
+		entry.val, page);
+	set_pte(dir, pte_mkdirty(mk_pte(page, vma->vm_page_prot)));
+	swap_free(entry);
+	get_page(page);
+	inc_mm_counter(vma->vm_mm, rss);
+}
+
+static inline void unswap_pmd(struct vm_area_struct * vma, pmd_t *dir,
+			      unsigned long address, unsigned long size,
+			      unsigned long offset, swp_entry_t entry,
+			      struct page *page)
+{
+	pte_t * pte;
+	unsigned long end;
+
+	if (pmd_none(*dir))
+		return;
+	if (pmd_bad(*dir)) {
+		pmd_ERROR(*dir);
+		pmd_clear(dir);
+		return;
+	}
+	pte = pte_offset_kernel(dir, address);
+	offset += address & PMD_MASK;
+	address &= ~PMD_MASK;
+	end = address + size;
+	if (end > PMD_SIZE)
+		end = PMD_SIZE;
+	do {
+		unswap_pte(vma, offset+address-vma->vm_start, pte, entry, page);
+		address += PAGE_SIZE;
+		pte++;
+	} while (address < end);
+}
+
+static inline void unswap_pgd(struct vm_area_struct * vma, pgd_t *dir,
+			      unsigned long address, unsigned long size,
+			      swp_entry_t entry, struct page *page)
+{
+	pmd_t * pmd;
+	unsigned long offset, end;
+
+	if (pgd_none(*dir))
+		return;
+	if (pgd_bad(*dir)) {
+		pgd_ERROR(*dir);
+		pgd_clear(dir);
+		return;
+	}
+	pmd = pmd_offset(dir, address);
+	offset = address & PGDIR_MASK;
+	address &= ~PGDIR_MASK;
+	end = address + size;
+	if (end > PGDIR_SIZE)
+		end = PGDIR_SIZE;
+	do {
+		unswap_pmd(vma, pmd, address, end - address, offset, entry,
+			   page);
+		address = (address + PMD_SIZE) & PMD_MASK;
+		pmd++;
+	} while (address < end);
+}
+
+static void unswap_vma(struct vm_area_struct * vma, pgd_t *pgdir,
+		       swp_entry_t entry, struct page *page)
+{
+	unsigned long start = vma->vm_start, end = vma->vm_end;
+
+	do {
+		unswap_pgd(vma, pgdir, start, end - start, entry, page);
+		start = (start + PGDIR_SIZE) & PGDIR_MASK;
+		pgdir++;
+	} while (start < end);
+}
+
+static void unswap_process(struct mm_struct * mm, swp_entry_t entry,
+			   struct page *page)
+{
+	struct vm_area_struct* vma;
+
+	/*
+	 * Go through process' page directory.
+	 */
+	if (!mm)
+		return;
+	for (vma = mm->mmap; vma; vma = vma->vm_next) {
+		pgd_t * pgd = pgd_offset(mm, vma->vm_start);
+		unswap_vma(vma, pgd, entry, page);
+	}
+}
+
+
+static int unswap_by_read(unsigned short *map, unsigned long max,
+			  unsigned long start, unsigned long n_pages)
+{
+	struct task_struct *p;
+	struct page *page;
+	swp_entry_t entry;
+	unsigned long i;
+
+	DPRINTK( "unswapping %lu..%lu by reading in\n",
+			 start, start+n_pages-1 );
+
+	for( i = start; i < start+n_pages; ++i ) {
+		if (map[i] == SWAP_MAP_BAD) {
+			printk( KERN_ERR "get_stram_region: page %lu already "
+					"reserved??\n", i );
+			continue;
+		}
+
+		if (map[i]) {
+			entry = swp_entry(stram_swap_type, i);
+			DPRINTK("unswap: map[i=%lu]=%u nr_swap=%ld\n",
+				i, map[i], nr_swap_pages);
+
+			swap_device_lock(stram_swap_info);
+			map[i]++;
+			swap_device_unlock(stram_swap_info);
+			/* Get a page for the entry, using the existing
+			   swap cache page if there is one.  Otherwise,
+			   get a clean page and read the swap into it. */
+			page = read_swap_cache_async(entry, NULL, 0);
+			if (!page) {
+				swap_free(entry);
+				return -ENOMEM;
+			}
+			read_lock(&tasklist_lock);
+			for_each_process(p)
+				unswap_process(p->mm, entry, page);
+			read_unlock(&tasklist_lock);
+			shmem_unuse(entry, page);
+			/* Now get rid of the extra reference to the
+			   temporary page we've been using. */
+			if (PageSwapCache(page))
+				delete_from_swap_cache(page);
+			__free_page(page);
+	#ifdef DO_PROC
+			stat_swap_force++;
+	#endif
+		}
+
+		DPRINTK( "unswap: map[i=%lu]=%u nr_swap=%ld\n",
+				 i, map[i], nr_swap_pages );
+		swap_list_lock();
+		swap_device_lock(stram_swap_info);
+		map[i] = SWAP_MAP_BAD;
+		if (stram_swap_info->lowest_bit == i)
+			stram_swap_info->lowest_bit++;
+		if (stram_swap_info->highest_bit == i)
+			stram_swap_info->highest_bit--;
+		--nr_swap_pages;
+		swap_device_unlock(stram_swap_info);
+		swap_list_unlock();
+	}
+
+	return 0;
+}
+
+/*
+ * reserve a region in ST-RAM swap space for an allocation
+ */
+static void *get_stram_region( unsigned long n_pages )
+{
+	unsigned short *map = stram_swap_info->swap_map;
+	unsigned long max = stram_swap_info->max;
+	unsigned long start, total_free, region_free;
+	int err;
+	void *ret = NULL;
+
+	DPRINTK( "get_stram_region(n_pages=%lu)\n", n_pages );
+
+	down(&stram_swap_sem);
+
+	/* disallow writing to the swap device now */
+	stram_swap_info->flags = SWP_USED;
+
+	/* find a region of n_pages pages in the swap space including as much free
+	 * pages as possible (and excluding any already-reserved pages). */
+	if (!(start = find_free_region( n_pages, &total_free, &region_free )))
+		goto end;
+	DPRINTK( "get_stram_region: region starts at %lu, has %lu free pages\n",
+			 start, region_free );
+
+	err = unswap_by_read(map, max, start, n_pages);
+	if (err)
+		goto end;
+
+	ret = SWAP_ADDR(start);
+  end:
+	/* allow using swap device again */
+	stram_swap_info->flags = SWP_WRITEOK;
+	up(&stram_swap_sem);
+	DPRINTK( "get_stram_region: returning %p\n", ret );
+	return( ret );
+}
+
+
+/*
+ * free a reserved region in ST-RAM swap space
+ */
+static void free_stram_region( unsigned long offset, unsigned long n_pages )
+{
+	unsigned short *map = stram_swap_info->swap_map;
+
+	DPRINTK( "free_stram_region(offset=%lu,n_pages=%lu)\n", offset, n_pages );
+
+	if (offset < 1 || offset + n_pages > stram_swap_info->max) {
+		printk( KERN_ERR "free_stram_region: Trying to free non-ST-RAM\n" );
+		return;
+	}
+
+	swap_list_lock();
+	swap_device_lock(stram_swap_info);
+	/* un-reserve the freed pages */
+	for( ; n_pages > 0; ++offset, --n_pages ) {
+		if (map[offset] != SWAP_MAP_BAD)
+			printk( KERN_ERR "free_stram_region: Swap page %lu was not "
+					"reserved\n", offset );
+		map[offset] = 0;
+	}
+
+	/* update swapping meta-data */
+	if (offset < stram_swap_info->lowest_bit)
+		stram_swap_info->lowest_bit = offset;
+	if (offset+n_pages-1 > stram_swap_info->highest_bit)
+		stram_swap_info->highest_bit = offset+n_pages-1;
+	if (stram_swap_info->prio > swap_info[swap_list.next].prio)
+		swap_list.next = swap_list.head;
+	nr_swap_pages += n_pages;
+	swap_device_unlock(stram_swap_info);
+	swap_list_unlock();
+}
+
+
+/* ------------------------------------------------------------------------ */
+/*						Utility Functions for Swapping						*/
+/* ------------------------------------------------------------------------ */
+
+
+/* is addr in some of the allocated regions? */
+static int in_some_region(void *addr)
+{
+	BLOCK *p;
+
+	for( p = alloc_list; p; p = p->next ) {
+		if (p->start <= addr && addr < p->start + p->size)
+			return( 1 );
+	}
+	return( 0 );
+}
+
+
+static unsigned long find_free_region(unsigned long n_pages,
+				      unsigned long *total_free,
+				      unsigned long *region_free)
+{
+	unsigned short *map = stram_swap_info->swap_map;
+	unsigned long max = stram_swap_info->max;
+	unsigned long head, tail, max_start;
+	long nfree, max_free;
+
+	/* first scan the swap space for a suitable place for the allocation */
+	head = 1;
+	max_start = 0;
+	max_free = -1;
+	*total_free = 0;
+
+  start_over:
+	/* increment tail until final window size reached, and count free pages */
+	nfree = 0;
+	for( tail = head; tail-head < n_pages && tail < max; ++tail ) {
+		if (map[tail] == SWAP_MAP_BAD) {
+			head = tail+1;
+			goto start_over;
+		}
+		if (!map[tail]) {
+			++nfree;
+			++*total_free;
+		}
+	}
+	if (tail-head < n_pages)
+		goto out;
+	if (nfree > max_free) {
+		max_start = head;
+		max_free  = nfree;
+		if (max_free >= n_pages)
+			/* don't need more free pages... :-) */
+			goto out;
+	}
+
+	/* now shift the window and look for the area where as much pages as
+	 * possible are free */
+	while( tail < max ) {
+		nfree -= (map[head++] == 0);
+		if (map[tail] == SWAP_MAP_BAD) {
+			head = tail+1;
+			goto start_over;
+		}
+		if (!map[tail]) {
+			++nfree;
+			++*total_free;
+		}
+		++tail;
+		if (nfree > max_free) {
+			max_start = head;
+			max_free  = nfree;
+			if (max_free >= n_pages)
+				/* don't need more free pages... :-) */
+				goto out;
+		}
+	}
+
+  out:
+	if (max_free < 0) {
+		printk( KERN_NOTICE "get_stram_region: ST-RAM too full or fragmented "
+				"-- can't allocate %lu pages\n", n_pages );
+		return( 0 );
+	}
+
+	*region_free = max_free;
+	return( max_start );
+}
+
+
+/* setup parameters from command line */
+void __init stram_swap_setup(char *str, int *ints)
+{
+	if (ints[0] >= 1)
+		max_swap_size = ((ints[1] < 0 ? 0 : ints[1]) * 1024) & PAGE_MASK;
+}
+
+
+/* ------------------------------------------------------------------------ */
+/*								ST-RAM device								*/
+/* ------------------------------------------------------------------------ */
+
+static int refcnt;
+
+static void do_stram_request(request_queue_t *q)
+{
+	struct request *req;
+
+	while ((req = elv_next_request(q)) != NULL) {
+		void *start = swap_start + (req->sector << 9);
+		unsigned long len = req->current_nr_sectors << 9;
+		if ((start + len) > swap_end) {
+			printk( KERN_ERR "stram: bad access beyond end of device: "
+					"block=%ld, count=%d\n",
+					req->sector,
+					req->current_nr_sectors );
+			end_request(req, 0);
+			continue;
+		}
+
+		if (req->cmd == READ) {
+			memcpy(req->buffer, start, len);
+#ifdef DO_PROC
+			stat_swap_read += N_PAGES(len);
+#endif
+		}
+		else {
+			memcpy(start, req->buffer, len);
+#ifdef DO_PROC
+			stat_swap_write += N_PAGES(len);
+#endif
+		}
+		end_request(req, 1);
+	}
+}
+
+
+static int stram_open( struct inode *inode, struct file *filp )
+{
+	if (filp != MAGIC_FILE_P) {
+		printk( KERN_NOTICE "Only kernel can open ST-RAM device\n" );
+		return( -EPERM );
+	}
+	if (refcnt)
+		return( -EBUSY );
+	++refcnt;
+	return( 0 );
+}
+
+static int stram_release( struct inode *inode, struct file *filp )
+{
+	if (filp != MAGIC_FILE_P) {
+		printk( KERN_NOTICE "Only kernel can close ST-RAM device\n" );
+		return( -EPERM );
+	}
+	if (refcnt > 0)
+		--refcnt;
+	return( 0 );
+}
+
+
+static struct block_device_operations stram_fops = {
+	.open =		stram_open,
+	.release =	stram_release,
+};
+
+static struct gendisk *stram_disk;
+static struct request_queue *stram_queue;
+static DEFINE_SPINLOCK(stram_lock);
+
+int __init stram_device_init(void)
+{
+	if (!MACH_IS_ATARI)
+		/* no point in initializing this, I hope */
+		return -ENXIO;
+
+	if (!max_swap_size)
+		/* swapping not enabled */
+		return -ENXIO;
+	stram_disk = alloc_disk(1);
+	if (!stram_disk)
+		return -ENOMEM;
+
+	if (register_blkdev(STRAM_MAJOR, "stram")) {
+		put_disk(stram_disk);
+		return -ENXIO;
+	}
+
+	stram_queue = blk_init_queue(do_stram_request, &stram_lock);
+	if (!stram_queue) {
+		unregister_blkdev(STRAM_MAJOR, "stram");
+		put_disk(stram_disk);
+		return -ENOMEM;
+	}
+
+	stram_disk->major = STRAM_MAJOR;
+	stram_disk->first_minor = STRAM_MINOR;
+	stram_disk->fops = &stram_fops;
+	stram_disk->queue = stram_queue;
+	sprintf(stram_disk->disk_name, "stram");
+	set_capacity(stram_disk, (swap_end - swap_start)/512);
+	add_disk(stram_disk);
+	return 0;
+}
+
+
+
+/* ------------------------------------------------------------------------ */
+/*							Misc Utility Functions							*/
+/* ------------------------------------------------------------------------ */
+
+/* reserve a range of pages */
+static void reserve_region(void *start, void *end)
+{
+	reserve_bootmem (virt_to_phys(start), end - start);
+}
+
+#endif /* CONFIG_STRAM_SWAP */
+
+
+/* ------------------------------------------------------------------------ */
+/*							  Region Management								*/
+/* ------------------------------------------------------------------------ */
+
+
+/* insert a region into the alloced list (sorted) */
+static BLOCK *add_region( void *addr, unsigned long size )
+{
+	BLOCK **p, *n = NULL;
+	int i;
+
+	for( i = 0; i < N_STATIC_BLOCKS; ++i ) {
+		if (static_blocks[i].flags & BLOCK_FREE) {
+			n = &static_blocks[i];
+			n->flags = 0;
+			break;
+		}
+	}
+	if (!n && mem_init_done) {
+		/* if statics block pool exhausted and we can call kmalloc() already
+		 * (after mem_init()), try that */
+		n = kmalloc( sizeof(BLOCK), GFP_KERNEL );
+		if (n)
+			n->flags = BLOCK_KMALLOCED;
+	}
+	if (!n) {
+		printk( KERN_ERR "Out of memory for ST-RAM descriptor blocks\n" );
+		return( NULL );
+	}
+	n->start = addr;
+	n->size  = size;
+
+	for( p = &alloc_list; *p; p = &((*p)->next) )
+		if ((*p)->start > addr) break;
+	n->next = *p;
+	*p = n;
+
+	return( n );
+}
+
+
+/* find a region (by start addr) in the alloced list */
+static BLOCK *find_region( void *addr )
+{
+	BLOCK *p;
+
+	for( p = alloc_list; p; p = p->next ) {
+		if (p->start == addr)
+			return( p );
+		if (p->start > addr)
+			break;
+	}
+	return( NULL );
+}
+
+
+/* remove a block from the alloced list */
+static int remove_region( BLOCK *block )
+{
+	BLOCK **p;
+
+	for( p = &alloc_list; *p; p = &((*p)->next) )
+		if (*p == block) break;
+	if (!*p)
+		return( 0 );
+
+	*p = block->next;
+	if (block->flags & BLOCK_KMALLOCED)
+		kfree( block );
+	else
+		block->flags |= BLOCK_FREE;
+	return( 1 );
+}
+
+
+
+/* ------------------------------------------------------------------------ */
+/*						 /proc statistics file stuff						*/
+/* ------------------------------------------------------------------------ */
+
+#ifdef DO_PROC
+
+#define	PRINT_PROC(fmt,args...) len += sprintf( buf+len, fmt, ##args )
+
+int get_stram_list( char *buf )
+{
+	int len = 0;
+	BLOCK *p;
+#ifdef CONFIG_STRAM_SWAP
+	int i;
+	unsigned short *map = stram_swap_info->swap_map;
+	unsigned long max = stram_swap_info->max;
+	unsigned free = 0, used = 0, rsvd = 0;
+#endif
+
+#ifdef CONFIG_STRAM_SWAP
+	if (max_swap_size) {
+		for( i = 1; i < max; ++i ) {
+			if (!map[i])
+				++free;
+			else if (map[i] == SWAP_MAP_BAD)
+				++rsvd;
+			else
+				++used;
+		}
+		PRINT_PROC(
+			"Total ST-RAM:      %8u kB\n"
+			"Total ST-RAM swap: %8lu kB\n"
+			"Free swap:         %8u kB\n"
+			"Used swap:         %8u kB\n"
+			"Allocated swap:    %8u kB\n"
+			"Swap Reads:        %8u\n"
+			"Swap Writes:       %8u\n"
+			"Swap Forced Reads: %8u\n",
+			(stram_end - stram_start) >> 10,
+			(max-1) << (PAGE_SHIFT-10),
+			free << (PAGE_SHIFT-10),
+			used << (PAGE_SHIFT-10),
+			rsvd << (PAGE_SHIFT-10),
+			stat_swap_read,
+			stat_swap_write,
+			stat_swap_force );
+	}
+	else {
+#endif
+		PRINT_PROC( "ST-RAM swapping disabled\n" );
+		PRINT_PROC("Total ST-RAM:      %8u kB\n",
+			   (stram_end - stram_start) >> 10);
+#ifdef CONFIG_STRAM_SWAP
+	}
+#endif
+
+	PRINT_PROC( "Allocated regions:\n" );
+	for( p = alloc_list; p; p = p->next ) {
+		if (len + 50 >= PAGE_SIZE)
+			break;
+		PRINT_PROC("0x%08lx-0x%08lx: %s (",
+			   virt_to_phys(p->start),
+			   virt_to_phys(p->start+p->size-1),
+			   p->owner);
+		if (p->flags & BLOCK_GFP)
+			PRINT_PROC( "page-alloced)\n" );
+		else if (p->flags & BLOCK_INSWAP)
+			PRINT_PROC( "in swap)\n" );
+		else
+			PRINT_PROC( "??)\n" );
+	}
+
+	return( len );
+}
+
+#endif
+
+
+/*
+ * Local variables:
+ *  c-indent-level: 4
+ *  tab-width: 4
+ * End:
+ */
