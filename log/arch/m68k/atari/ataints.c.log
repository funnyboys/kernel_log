commit 1efdd4bd254311498123a15fa0acd565f454da97
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 1 11:53:10 2018 +1100

    m68k: Call timer_interrupt() with interrupts disabled
    
    Some platforms execute their timer handler with the interrupt priority
    level set below 6. That means the handler could be interrupted by another
    driver and this could lead to re-entry of the timer core.
    
    Avoid this by use of local_irq_save/restore for timer interrupt dispatch.
    This provides mutual exclusion around the timer interrupt flag access
    which is needed later in this series for the clocksource conversion.
    
    Reported-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.21.1811131407120.2697@nanos.tec.linutronix.de
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 3d2b63bedf05..56f02ea2c248 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -142,7 +142,7 @@ struct mfptimerbase {
 	.name		= "MFP Timer D"
 };
 
-static irqreturn_t mfptimer_handler(int irq, void *dev_id)
+static irqreturn_t mfp_timer_d_handler(int irq, void *dev_id)
 {
 	struct mfptimerbase *base = dev_id;
 	int mach_irq;
@@ -344,7 +344,7 @@ void __init atari_init_IRQ(void)
 	st_mfp.tim_ct_cd = (st_mfp.tim_ct_cd & 0xf0) | 0x6;
 
 	/* request timer D dispatch handler */
-	if (request_irq(IRQ_MFP_TIMD, mfptimer_handler, IRQF_SHARED,
+	if (request_irq(IRQ_MFP_TIMD, mfp_timer_d_handler, IRQF_SHARED,
 			stmfp_base.name, &stmfp_base))
 		pr_err("Couldn't register %s interrupt\n", stmfp_base.name);
 

commit b718102e7d4ce2f9640805251fbbb3619fbb9a46
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 20 12:40:30 2014 +0100

    m68k: atari: Fix the last kernel_stat.h fallout
    
    Reported-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 3e73a63c066f..3d2b63bedf05 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -41,6 +41,7 @@
 #include <linux/init.h>
 #include <linux/seq_file.h>
 #include <linux/module.h>
+#include <linux/irq.h>
 
 #include <asm/traps.h>
 

commit a0b7b242261c8c1097925663bf44d51c1e357e58
Author: Michael Schmitz <schmitzmic@gmail.com>
Date:   Sat Jan 11 13:58:55 2014 +1300

    m68k/irq - Use polled IRQ flag for MFP timer cascaded interrupts
    
    Some Atari hardware has no capacity to raise interrupts (e.g.
    network or USB adapter hardware attached via ROM port). The driver
    interrupt routine is called from a timer interrupt (timer D) in
    these cases, using chained device specific pseudo interrupts
    (IRQ_MFP_TIMER1 ff.)
    
    These interrupts will more often than not, return IRQ_NONE as
    there is not always work for the device handler when called.
    Too many unhandled interrupts will result in the interrupt
    being disabled by the stuck interrupt watchdog.
    
    As preferred option to flag interrupts as needing exclusion
    from the watchdog mechanism, tglx added the IRQ_IS_POLLED flag
    for use in such a case. Currently, two interrupts need to use
    this flag. Add more users as needed.
    
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 20cde4e9fc77..3e73a63c066f 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -333,6 +333,9 @@ void __init atari_init_IRQ(void)
 	m68k_setup_irq_controller(&atari_mfptimer_chip, handle_simple_irq,
 				  IRQ_MFP_TIMER1, 8);
 
+	irq_set_status_flags(IRQ_MFP_TIMER1, IRQ_IS_POLLED);
+	irq_set_status_flags(IRQ_MFP_TIMER2, IRQ_IS_POLLED);
+
 	/* prepare timer D data for use as poll interrupt */
 	/* set Timer D data Register - needs to be > 0 */
 	st_mfp.tim_dt_d = 254;	/* < 100 Hz */

commit e6f80e87e05cc47188a141f68e9859ed438b4489
Author: Michael Schmitz <schmitzmic@gmail.com>
Date:   Sat Apr 6 13:26:43 2013 +1300

    m68k/atari: EtherNAT - add interrupt chip definition for CPLD interrupts
    
    Add a dedicated interrupt chip definition for the EtherNAT CPLD interrupts.
    SMC91C111 and ISP1160 chips have separate interrupts that can be enabled
    and disabled in a CPLD register at offset 0x23 from the card base.
    
    Note the CPLD interrupt control register is mapped on demand, whenever any
    interrupt enable/disable action is requested. The EtherNAT USB driver still
    needs interrupts disabled around reset and start actions.
    In particular, we cannot entirely rely on the irq_startup being called
    first.
    
    The smc91x and isp116x-hcd drivers will use this feature.
    
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index f699c829e594..20cde4e9fc77 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -49,6 +49,7 @@
 #include <asm/atari_stdma.h>
 #include <asm/irq.h>
 #include <asm/entry.h>
+#include <asm/io.h>
 
 
 /*
@@ -177,6 +178,80 @@ static struct irq_chip atari_mfptimer_chip = {
 	.irq_disable	= atari_mfptimer_disable,
 };
 
+
+/*
+ * EtherNAT CPLD interrupt handling
+ * CPLD interrupt register is at phys. 0x80000023
+ * Need this mapped in at interrupt startup time
+ * Possibly need this mapped on demand anyway -
+ * EtherNAT USB driver needs to disable IRQ before
+ * startup!
+ */
+
+static unsigned char *enat_cpld;
+
+static unsigned int atari_ethernat_startup(struct irq_data *data)
+{
+	int enat_num = 140 - data->irq + 1;
+
+	m68k_irq_startup(data);
+	/*
+	* map CPLD interrupt register
+	*/
+	if (!enat_cpld)
+		enat_cpld = (unsigned char *)ioremap((ATARI_ETHERNAT_PHYS_ADDR+0x23), 0x2);
+	/*
+	 * do _not_ enable the USB chip interrupt here - causes interrupt storm
+	 * and triggers dead interrupt watchdog
+	 * Need to reset the USB chip to a sane state in early startup before
+	 * removing this hack
+	 */
+	if (enat_num == 1)
+		*enat_cpld |= 1 << enat_num;
+
+	return 0;
+}
+
+static void atari_ethernat_enable(struct irq_data *data)
+{
+	int enat_num = 140 - data->irq + 1;
+	/*
+	* map CPLD interrupt register
+	*/
+	if (!enat_cpld)
+		enat_cpld = (unsigned char *)ioremap((ATARI_ETHERNAT_PHYS_ADDR+0x23), 0x2);
+	*enat_cpld |= 1 << enat_num;
+}
+
+static void atari_ethernat_disable(struct irq_data *data)
+{
+	int enat_num = 140 - data->irq + 1;
+	/*
+	* map CPLD interrupt register
+	*/
+	if (!enat_cpld)
+		enat_cpld = (unsigned char *)ioremap((ATARI_ETHERNAT_PHYS_ADDR+0x23), 0x2);
+	*enat_cpld &= ~(1 << enat_num);
+}
+
+static void atari_ethernat_shutdown(struct irq_data *data)
+{
+	int enat_num = 140 - data->irq + 1;
+	if (enat_cpld) {
+		*enat_cpld &= ~(1 << enat_num);
+		iounmap(enat_cpld);
+		enat_cpld = NULL;
+	}
+}
+
+static struct irq_chip atari_ethernat_chip = {
+	.name		= "ethernat",
+	.irq_startup	= atari_ethernat_startup,
+	.irq_shutdown	= atari_ethernat_shutdown,
+	.irq_enable	= atari_ethernat_enable,
+	.irq_disable	= atari_ethernat_disable,
+};
+
 /*
  * void atari_init_IRQ (void)
  *
@@ -268,6 +343,13 @@ void __init atari_init_IRQ(void)
 	if (request_irq(IRQ_MFP_TIMD, mfptimer_handler, IRQF_SHARED,
 			stmfp_base.name, &stmfp_base))
 		pr_err("Couldn't register %s interrupt\n", stmfp_base.name);
+
+	/*
+	 * EtherNAT ethernet / USB interrupt handlers
+	 */
+
+	m68k_setup_irq_controller(&atari_ethernat_chip, handle_simple_irq,
+				  139, 2);
 }
 
 

commit b1ae432c5e3d682d86a88fc798a9ed2469c14a7a
Author: Michael Schmitz <schmitzmic@gmail.com>
Date:   Sat Apr 6 13:26:37 2013 +1300

    m68k/atari: use dedicated irq_chip for timer D interrupts
    
    Add a special irq_chip for the Atari MFP timer D interrupt,
    which is used as a polling timer for EtherNEC and NetUSBee
    
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 3f41092d1b70..f699c829e594 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -121,6 +121,62 @@ static struct irq_chip atari_irq_chip = {
 	.irq_disable	= atari_irq_disable,
 };
 
+/*
+ * ST-MFP timer D chained interrupts - each driver gets its own timer
+ * interrupt instance.
+ */
+
+struct mfptimerbase {
+	volatile struct MFP *mfp;
+	unsigned char mfp_mask, mfp_data;
+	unsigned short int_mask;
+	int handler_irq, mfptimer_irq, server_irq;
+	char *name;
+} stmfp_base = {
+	.mfp		= &st_mfp,
+	.int_mask	= 0x0,
+	.handler_irq	= IRQ_MFP_TIMD,
+	.mfptimer_irq	= IRQ_MFP_TIMER1,
+	.name		= "MFP Timer D"
+};
+
+static irqreturn_t mfptimer_handler(int irq, void *dev_id)
+{
+	struct mfptimerbase *base = dev_id;
+	int mach_irq;
+	unsigned char ints;
+
+	mach_irq = base->mfptimer_irq;
+	ints = base->int_mask;
+	for (; ints; mach_irq++, ints >>= 1) {
+		if (ints & 1)
+			generic_handle_irq(mach_irq);
+	}
+	return IRQ_HANDLED;
+}
+
+
+static void atari_mfptimer_enable(struct irq_data *data)
+{
+	int mfp_num = data->irq - IRQ_MFP_TIMER1;
+	stmfp_base.int_mask |= 1 << mfp_num;
+	atari_enable_irq(IRQ_MFP_TIMD);
+}
+
+static void atari_mfptimer_disable(struct irq_data *data)
+{
+	int mfp_num = data->irq - IRQ_MFP_TIMER1;
+	stmfp_base.int_mask &= ~(1 << mfp_num);
+	if (!stmfp_base.int_mask)
+		atari_disable_irq(IRQ_MFP_TIMD);
+}
+
+static struct irq_chip atari_mfptimer_chip = {
+	.name		= "timer_d",
+	.irq_enable	= atari_mfptimer_enable,
+	.irq_disable	= atari_mfptimer_disable,
+};
+
 /*
  * void atari_init_IRQ (void)
  *
@@ -198,6 +254,20 @@ void __init atari_init_IRQ(void)
 	/* Initialize the PSG: all sounds off, both ports output */
 	sound_ym.rd_data_reg_sel = 7;
 	sound_ym.wd_data = 0xff;
+
+	m68k_setup_irq_controller(&atari_mfptimer_chip, handle_simple_irq,
+				  IRQ_MFP_TIMER1, 8);
+
+	/* prepare timer D data for use as poll interrupt */
+	/* set Timer D data Register - needs to be > 0 */
+	st_mfp.tim_dt_d = 254;	/* < 100 Hz */
+	/* start timer D, div = 1:100 */
+	st_mfp.tim_ct_cd = (st_mfp.tim_ct_cd & 0xf0) | 0x6;
+
+	/* request timer D dispatch handler */
+	if (request_irq(IRQ_MFP_TIMD, mfptimer_handler, IRQF_SHARED,
+			stmfp_base.name, &stmfp_base))
+		pr_err("Couldn't register %s interrupt\n", stmfp_base.name);
 }
 
 

commit 44883eb0231f4a5ce56926fdee185cba867ac121
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Aug 18 20:01:51 2011 +0200

    m68k/atari: Change VME irq numbers from unsigned long to unsigned int
    
    Device interrupts numbers were changed to unsigned int in 1997, the year
    IRQ_MACHSPEC was killed as well.
    
    Also kill a related cast while we're at it.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: netdev@vger.kernel.org

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 783d8f02360d..3f41092d1b70 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -206,7 +206,7 @@ void __init atari_init_IRQ(void)
  * hardware with a programmable int vector (probably a VME board).
  */
 
-unsigned long atari_register_vme_int(void)
+unsigned int atari_register_vme_int(void)
 {
 	int i;
 
@@ -223,7 +223,7 @@ unsigned long atari_register_vme_int(void)
 EXPORT_SYMBOL(atari_register_vme_int);
 
 
-void atari_unregister_vme_int(unsigned long irq)
+void atari_unregister_vme_int(unsigned int irq)
 {
 	if (irq >= VME_SOURCE_BASE && irq < VME_SOURCE_BASE + VME_MAX_SOURCES) {
 		irq -= VME_SOURCE_BASE;

commit 803f69144f0d48863c68f9d111b56849c7cef5bb
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for M68K
    
    Disintegrate asm/system.h for M68K.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    cc: linux-m68k@lists.linux-m68k.org

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 8048e1b7e552..783d8f02360d 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -42,7 +42,6 @@
 #include <linux/seq_file.h>
 #include <linux/module.h>
 
-#include <asm/system.h>
 #include <asm/traps.h>
 
 #include <asm/atarihw.h>

commit 125298d2daf7c9005d5bc26313a037b798c8de70
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Nov 13 10:44:24 2011 +0100

    m68k/atari: Move declaration of atari_SCC_reset_done to header file
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 6d196dadfdbc..8048e1b7e552 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -82,8 +82,6 @@ __ALIGN_STR "\n\t"
 
 extern void atari_microwire_cmd(int cmd);
 
-extern int atari_SCC_reset_done;
-
 static unsigned int atari_irq_startup(struct irq_data *data)
 {
 	unsigned int irq = data->irq;

commit f30a6484f1bcb410d0af0c24f34b8e3d92682a05
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 11 11:54:50 2011 +0200

    m68k/irq: Remove obsolete support for user vector interrupt fixups
    
    It was used on Apollo only, before its conversion to genirq.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index af544557dd1d..6d196dadfdbc 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -137,7 +137,7 @@ static struct irq_chip atari_irq_chip = {
 
 void __init atari_init_IRQ(void)
 {
-	m68k_setup_user_interrupt(VEC_USER, NUM_ATARI_SOURCES - IRQ_USER, NULL);
+	m68k_setup_user_interrupt(VEC_USER, NUM_ATARI_SOURCES - IRQ_USER);
 	m68k_setup_irq_controller(&atari_irq_chip, handle_simple_irq, 1,
 				  NUM_ATARI_SOURCES - 1);
 

commit 34971bad3a1511db7b76eeb2337819967a135075
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Aug 18 19:36:30 2011 +0200

    m68k/atari: Remove code and comments about different irq types
    
    This code was obsoleted during the irq restructuring in 2006.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 6149ff994641..af544557dd1d 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -60,244 +60,8 @@
  * <asm/atariints.h>): Autovector interrupts are 1..7, then follow ST-MFP,
  * TT-MFP, SCC, and finally VME interrupts. Vector numbers for the latter can
  * be allocated by atari_register_vme_int().
- *
- * Each interrupt can be of three types:
- *
- *  - SLOW: The handler runs with all interrupts enabled, except the one it
- *    was called by (to avoid reentering). This should be the usual method.
- *    But it is currently possible only for MFP ints, since only the MFP
- *    offers an easy way to mask interrupts.
- *
- *  - FAST: The handler runs with all interrupts disabled. This should be used
- *    only for really fast handlers, that just do actions immediately
- *    necessary, and let the rest do a bottom half or task queue.
- *
- *  - PRIORITIZED: The handler can be interrupted by higher-level ints
- *    (greater IPL, no MFP priorities!). This is the method of choice for ints
- *    which should be slow, but are not from a MFP.
- *
- * The feature of more than one handler for one int source is still there, but
- * only applicable if all handers are of the same type. To not slow down
- * processing of ints with only one handler by the chaining feature, the list
- * calling function atari_call_irq_list() is only plugged in at the time the
- * second handler is registered.
- *
- * Implementation notes: For fast-as-possible int handling, there are separate
- * entry points for each type (slow/fast/prio). The assembler handler calls
- * the irq directly in the usual case, no C wrapper is involved. In case of
- * multiple handlers, atari_call_irq_list() is registered as handler and calls
- * in turn the real irq's. To ease access from assembler level to the irq
- * function pointer and accompanying data, these two are stored in a separate
- * array, irq_handler[]. The rest of data (type, name) are put into a second
- * array, irq_param, that is accessed from C only. For each slow interrupt (32
- * in all) there are separate handler functions, which makes it possible to
- * hard-code the MFP register address and value, are necessary to mask the
- * int. If there'd be only one generic function, lots of calculations would be
- * needed to determine MFP register and int mask from the vector number :-(
- *
- * Furthermore, slow ints may not lower the IPL below its previous value
- * (before the int happened). This is needed so that an int of class PRIO, on
- * that this int may be stacked, cannot be reentered. This feature is
- * implemented as follows: If the stack frame format is 1 (throwaway), the int
- * is not stacked, and the IPL is anded with 0xfbff, resulting in a new level
- * 2, which still blocks the HSYNC, but no interrupts of interest. If the
- * frame format is 0, the int is nested, and the old IPL value can be found in
- * the sr copy in the frame.
  */
 
-#if 0
-
-#define	NUM_INT_SOURCES	(8 + NUM_ATARI_SOURCES)
-
-typedef void (*asm_irq_handler)(void);
-
-struct irqhandler {
-	irqreturn_t (*handler)(int, void *, struct pt_regs *);
-	void	*dev_id;
-};
-
-struct irqparam {
-	unsigned long	flags;
-	const char	*devname;
-};
-
-/*
- * Array with irq's and their parameter data. This array is accessed from low
- * level assembler code, so an element size of 8 allows usage of index scaling
- * addressing mode.
- */
-static struct irqhandler irq_handler[NUM_INT_SOURCES];
-
-/*
- * This array hold the rest of parameters of int handlers: type
- * (slow,fast,prio) and the name of the handler. These values are only
- * accessed from C
- */
-static struct irqparam irq_param[NUM_INT_SOURCES];
-
-/* check for valid int number (complex, sigh...) */
-#define	IS_VALID_INTNO(n)											\
-	((n) > 0 &&														\
-	 /* autovec and ST-MFP ok anyway */								\
-	 (((n) < TTMFP_SOURCE_BASE) ||									\
-	  /* TT-MFP ok if present */									\
-	  ((n) >= TTMFP_SOURCE_BASE && (n) < SCC_SOURCE_BASE &&			\
-	   ATARIHW_PRESENT(TT_MFP)) ||									\
-	  /* SCC ok if present and number even */						\
-	  ((n) >= SCC_SOURCE_BASE && (n) < VME_SOURCE_BASE &&			\
-	   !((n) & 1) && ATARIHW_PRESENT(SCC)) ||						\
-	  /* greater numbers ok if they are registered VME vectors */		\
-	  ((n) >= VME_SOURCE_BASE && (n) < VME_SOURCE_BASE + VME_MAX_SOURCES && \
-		  free_vme_vec_bitmap & (1 << ((n) - VME_SOURCE_BASE)))))
-
-
-/*
- * Here start the assembler entry points for interrupts
- */
-
-#define IRQ_NAME(nr) atari_slow_irq_##nr##_handler(void)
-
-#define	BUILD_SLOW_IRQ(n)						   \
-asmlinkage void IRQ_NAME(n);						   \
-/* Dummy function to allow asm with operands.  */			   \
-void atari_slow_irq_##n##_dummy (void) {				   \
-__asm__ (__ALIGN_STR "\n"						   \
-"atari_slow_irq_" #n "_handler:\t"					   \
-"	addl	%6,%5\n"	/* preempt_count() += HARDIRQ_OFFSET */	   \
-	SAVE_ALL_INT "\n"						   \
-	GET_CURRENT(%%d0) "\n"						   \
-"	andb	#~(1<<(%c3&7)),%a4:w\n"	/* mask this interrupt */	   \
-	/* get old IPL from stack frame */				   \
-"	bfextu	%%sp@(%c2){#5,#3},%%d0\n"				   \
-"	movew	%%sr,%%d1\n"						   \
-"	bfins	%%d0,%%d1{#21,#3}\n"					   \
-"	movew	%%d1,%%sr\n"		/* set IPL = previous value */	   \
-"	addql	#1,%a0\n"						   \
-"	lea	%a1,%%a0\n"						   \
-"	pea	%%sp@\n"		/* push addr of frame */	   \
-"	movel	%%a0@(4),%%sp@-\n"	/* push handler data */		   \
-"	pea	(%c3+8)\n"		/* push int number */		   \
-"	movel	%%a0@,%%a0\n"						   \
-"	jbsr	%%a0@\n"		/* call the handler */		   \
-"	addql	#8,%%sp\n"						   \
-"	addql	#4,%%sp\n"						   \
-"	orw	#0x0600,%%sr\n"						   \
-"	andw	#0xfeff,%%sr\n"		/* set IPL = 6 again */		   \
-"	orb	#(1<<(%c3&7)),%a4:w\n"	/* now unmask the int again */	   \
-"	jbra	ret_from_interrupt\n"					   \
-	 : : "i" (&kstat_cpu(0).irqs[n+8]), "i" (&irq_handler[n+8]),	   \
-	     "n" (PT_OFF_SR), "n" (n),					   \
-	     "i" (n & 8 ? (n & 16 ? &tt_mfp.int_mk_a : &st_mfp.int_mk_a)   \
-		        : (n & 16 ? &tt_mfp.int_mk_b : &st_mfp.int_mk_b)), \
-	     "m" (preempt_count()), "di" (HARDIRQ_OFFSET)		   \
-);									   \
-	for (;;);			/* fake noreturn */		   \
-}
-
-BUILD_SLOW_IRQ(0);
-BUILD_SLOW_IRQ(1);
-BUILD_SLOW_IRQ(2);
-BUILD_SLOW_IRQ(3);
-BUILD_SLOW_IRQ(4);
-BUILD_SLOW_IRQ(5);
-BUILD_SLOW_IRQ(6);
-BUILD_SLOW_IRQ(7);
-BUILD_SLOW_IRQ(8);
-BUILD_SLOW_IRQ(9);
-BUILD_SLOW_IRQ(10);
-BUILD_SLOW_IRQ(11);
-BUILD_SLOW_IRQ(12);
-BUILD_SLOW_IRQ(13);
-BUILD_SLOW_IRQ(14);
-BUILD_SLOW_IRQ(15);
-BUILD_SLOW_IRQ(16);
-BUILD_SLOW_IRQ(17);
-BUILD_SLOW_IRQ(18);
-BUILD_SLOW_IRQ(19);
-BUILD_SLOW_IRQ(20);
-BUILD_SLOW_IRQ(21);
-BUILD_SLOW_IRQ(22);
-BUILD_SLOW_IRQ(23);
-BUILD_SLOW_IRQ(24);
-BUILD_SLOW_IRQ(25);
-BUILD_SLOW_IRQ(26);
-BUILD_SLOW_IRQ(27);
-BUILD_SLOW_IRQ(28);
-BUILD_SLOW_IRQ(29);
-BUILD_SLOW_IRQ(30);
-BUILD_SLOW_IRQ(31);
-
-asm_irq_handler slow_handlers[32] = {
-	[0]	= atari_slow_irq_0_handler,
-	[1]	= atari_slow_irq_1_handler,
-	[2]	= atari_slow_irq_2_handler,
-	[3]	= atari_slow_irq_3_handler,
-	[4]	= atari_slow_irq_4_handler,
-	[5]	= atari_slow_irq_5_handler,
-	[6]	= atari_slow_irq_6_handler,
-	[7]	= atari_slow_irq_7_handler,
-	[8]	= atari_slow_irq_8_handler,
-	[9]	= atari_slow_irq_9_handler,
-	[10]	= atari_slow_irq_10_handler,
-	[11]	= atari_slow_irq_11_handler,
-	[12]	= atari_slow_irq_12_handler,
-	[13]	= atari_slow_irq_13_handler,
-	[14]	= atari_slow_irq_14_handler,
-	[15]	= atari_slow_irq_15_handler,
-	[16]	= atari_slow_irq_16_handler,
-	[17]	= atari_slow_irq_17_handler,
-	[18]	= atari_slow_irq_18_handler,
-	[19]	= atari_slow_irq_19_handler,
-	[20]	= atari_slow_irq_20_handler,
-	[21]	= atari_slow_irq_21_handler,
-	[22]	= atari_slow_irq_22_handler,
-	[23]	= atari_slow_irq_23_handler,
-	[24]	= atari_slow_irq_24_handler,
-	[25]	= atari_slow_irq_25_handler,
-	[26]	= atari_slow_irq_26_handler,
-	[27]	= atari_slow_irq_27_handler,
-	[28]	= atari_slow_irq_28_handler,
-	[29]	= atari_slow_irq_29_handler,
-	[30]	= atari_slow_irq_30_handler,
-	[31]	= atari_slow_irq_31_handler
-};
-
-asmlinkage void atari_fast_irq_handler( void );
-asmlinkage void atari_prio_irq_handler( void );
-
-/* Dummy function to allow asm with operands.  */
-void atari_fast_prio_irq_dummy (void) {
-__asm__ (__ALIGN_STR "\n"
-"atari_fast_irq_handler:\n\t"
-	"orw	#0x700,%%sr\n"		/* disable all interrupts */
-"atari_prio_irq_handler:\n\t"
-	"addl	%3,%2\n\t"		/* preempt_count() += HARDIRQ_OFFSET */
-	SAVE_ALL_INT "\n\t"
-	GET_CURRENT(%%d0) "\n\t"
-	/* get vector number from stack frame and convert to source */
-	"bfextu	%%sp@(%c1){#4,#10},%%d0\n\t"
-	"subw	#(0x40-8),%%d0\n\t"
-	"jpl	1f\n\t"
-	"addw	#(0x40-8-0x18),%%d0\n"
-    "1:\tlea	%a0,%%a0\n\t"
-	"addql	#1,%%a0@(%%d0:l:4)\n\t"
-	"lea	irq_handler,%%a0\n\t"
-	"lea	%%a0@(%%d0:l:8),%%a0\n\t"
-	"pea	%%sp@\n\t"		/* push frame address */
-	"movel	%%a0@(4),%%sp@-\n\t"	/* push handler data */
-	"movel	%%d0,%%sp@-\n\t"	/* push int number */
-	"movel	%%a0@,%%a0\n\t"
-	"jsr	%%a0@\n\t"		/* and call the handler */
-	"addql	#8,%%sp\n\t"
-	"addql	#4,%%sp\n\t"
-	"jbra	ret_from_interrupt"
-	 : : "i" (&kstat_cpu(0).irqs), "n" (PT_OFF_FORMATVEC),
-	     "m" (preempt_count()), "di" (HARDIRQ_OFFSET)
-);
-	for (;;);
-}
-#endif
-
 /*
  * Bitmap for free interrupt vector numbers
  * (new vectors starting from 0x70 can be allocated by

commit edb347256c44366888debb4f9e8477ac700a9026
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jun 1 11:15:21 2011 +0200

    m68k/irq: Add m68k_setup_irq_controller()
    
    This is a wrapper around m68k_setup_irq_chip() that discards its dummy
    second parameter, to ease the future transition to genirq.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 7f4e5a9b77c5..6149ff994641 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -374,7 +374,8 @@ static struct irq_chip atari_irq_chip = {
 void __init atari_init_IRQ(void)
 {
 	m68k_setup_user_interrupt(VEC_USER, NUM_ATARI_SOURCES - IRQ_USER, NULL);
-	m68k_setup_irq_chip(&atari_irq_chip, 1, NUM_ATARI_SOURCES - 1);
+	m68k_setup_irq_controller(&atari_irq_chip, handle_simple_irq, 1,
+				  NUM_ATARI_SOURCES - 1);
 
 	/* Initialize the MFP(s) */
 

commit e8abf5e73cdb6c034d35ccba1f63a4801cd3dec5
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 17 22:53:04 2011 +0200

    m68k/irq: Switch irq_chip methods to "struct irq_data *data"
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index ac0ebdf6ca72..7f4e5a9b77c5 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -320,30 +320,44 @@ extern void atari_microwire_cmd(int cmd);
 
 extern int atari_SCC_reset_done;
 
-static unsigned int atari_startup_irq(unsigned int irq)
+static unsigned int atari_irq_startup(struct irq_data *data)
 {
-	m68k_irq_startup(irq);
+	unsigned int irq = data->irq;
+
+	m68k_irq_startup(data);
 	atari_turnon_irq(irq);
 	atari_enable_irq(irq);
 	return 0;
 }
 
-static void atari_shutdown_irq(unsigned int irq)
+static void atari_irq_shutdown(struct irq_data *data)
 {
+	unsigned int irq = data->irq;
+
 	atari_disable_irq(irq);
 	atari_turnoff_irq(irq);
-	m68k_irq_shutdown(irq);
+	m68k_irq_shutdown(data);
 
 	if (irq == IRQ_AUTO_4)
 	    vectors[VEC_INT4] = falcon_hblhandler;
 }
 
+static void atari_irq_enable(struct irq_data *data)
+{
+	atari_enable_irq(data->irq);
+}
+
+static void atari_irq_disable(struct irq_data *data)
+{
+	atari_disable_irq(data->irq);
+}
+
 static struct irq_chip atari_irq_chip = {
 	.name		= "atari",
-	.irq_startup	= atari_startup_irq,
-	.irq_shutdown	= atari_shutdown_irq,
-	.irq_enable	= atari_enable_irq,
-	.irq_disable	= atari_disable_irq,
+	.irq_startup	= atari_irq_startup,
+	.irq_shutdown	= atari_irq_shutdown,
+	.irq_enable	= atari_irq_enable,
+	.irq_disable	= atari_irq_disable,
 };
 
 /*

commit c288bf2533e57174b90b07860c4391bcd1ea269c
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Apr 13 22:31:28 2011 +0200

    m68k/irq: Rename irq_controller to irq_chip
    
    Make it more similar to the genirq version:
      - Remove lock (unused as we don't do SMP anyway),
      - Prepend methods with irq_,
      - Make irq_startup() return unsigned int.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 26a804e67bce..ac0ebdf6ca72 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -320,7 +320,7 @@ extern void atari_microwire_cmd(int cmd);
 
 extern int atari_SCC_reset_done;
 
-static int atari_startup_irq(unsigned int irq)
+static unsigned int atari_startup_irq(unsigned int irq)
 {
 	m68k_irq_startup(irq);
 	atari_turnon_irq(irq);
@@ -338,13 +338,12 @@ static void atari_shutdown_irq(unsigned int irq)
 	    vectors[VEC_INT4] = falcon_hblhandler;
 }
 
-static struct irq_controller atari_irq_controller = {
+static struct irq_chip atari_irq_chip = {
 	.name		= "atari",
-	.lock		= __SPIN_LOCK_UNLOCKED(atari_irq_controller.lock),
-	.startup	= atari_startup_irq,
-	.shutdown	= atari_shutdown_irq,
-	.enable		= atari_enable_irq,
-	.disable	= atari_disable_irq,
+	.irq_startup	= atari_startup_irq,
+	.irq_shutdown	= atari_shutdown_irq,
+	.irq_enable	= atari_enable_irq,
+	.irq_disable	= atari_disable_irq,
 };
 
 /*
@@ -361,7 +360,7 @@ static struct irq_controller atari_irq_controller = {
 void __init atari_init_IRQ(void)
 {
 	m68k_setup_user_interrupt(VEC_USER, NUM_ATARI_SOURCES - IRQ_USER, NULL);
-	m68k_setup_irq_controller(&atari_irq_controller, 1, NUM_ATARI_SOURCES - 1);
+	m68k_setup_irq_chip(&atari_irq_chip, 1, NUM_ATARI_SOURCES - 1);
 
 	/* Initialize the MFP(s) */
 

commit de339e4b792aed799bec23251e83f594ac44ae04
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Jan 16 20:47:47 2011 +0100

    m68k/atari: Rename "scc" to "atari_scc"
    
    It's a way too generic name for a global #define and conflicts with a variable
    with the same name, causing build errors like:
    
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c: In function ‘_si_clkctl_cc’:
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1364: error: expected identifier or ‘(’ before ‘volatile’
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1364: error: expected ‘)’ before ‘(’ token
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1421: error: incompatible types in assignment
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1422: error: invalid operands to binary &
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1423: error: invalid operands to binary &
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1424: error: invalid operands to binary |
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: incompatible type for argument 4 of ‘bcmsdh_reg_write’
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1428: error: invalid operands to binary &
    | make[8]: *** [drivers/staging/brcm80211/brcmfmac/../util/siutils.o] Error 1
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 39478dd08e67..26a804e67bce 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -388,9 +388,9 @@ void __init atari_init_IRQ(void)
 	}
 
 	if (ATARIHW_PRESENT(SCC) && !atari_SCC_reset_done) {
-		scc.cha_a_ctrl = 9;
+		atari_scc.cha_a_ctrl = 9;
 		MFPDELAY();
-		scc.cha_a_ctrl = (char) 0xc0; /* hardware reset */
+		atari_scc.cha_a_ctrl = (char) 0xc0; /* hardware reset */
 	}
 
 	if (ATARIHW_PRESENT(SCU)) {

commit 3d92e8f3ae9ba21cac30370eb254ed9dc20df043
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Feb 22 09:38:47 2009 +0100

    m68k: atari - Rename "mfp" to "st_mfp"
    
    http://kisskb.ellerman.id.au/kisskb/buildresult/72115/:
    | net/mac80211/ieee80211_i.h:327: error: syntax error before 'volatile'
    | net/mac80211/ieee80211_i.h:350: error: syntax error before '}' token
    | net/mac80211/ieee80211_i.h:455: error: field 'sta' has incomplete type
    | distcc[19430] ERROR: compile net/mac80211/main.c on sprygo/32 failed
    
    This is caused by
    
    | # define mfp ((*(volatile struct MFP*)MFP_BAS))
    
    in arch/m68k/include/asm/atarihw.h, which conflicts with the new "mfp" enum in
    net/mac80211/ieee80211_i.h.
    
    Rename "mfp" to "st_mfp", as it's a way too generic name for a global #define.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index dba4afabb444..39478dd08e67 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -187,8 +187,8 @@ __asm__ (__ALIGN_STR "\n"						   \
 "	jbra	ret_from_interrupt\n"					   \
 	 : : "i" (&kstat_cpu(0).irqs[n+8]), "i" (&irq_handler[n+8]),	   \
 	     "n" (PT_OFF_SR), "n" (n),					   \
-	     "i" (n & 8 ? (n & 16 ? &tt_mfp.int_mk_a : &mfp.int_mk_a)	   \
-		        : (n & 16 ? &tt_mfp.int_mk_b : &mfp.int_mk_b)),	   \
+	     "i" (n & 8 ? (n & 16 ? &tt_mfp.int_mk_a : &st_mfp.int_mk_a)   \
+		        : (n & 16 ? &tt_mfp.int_mk_b : &st_mfp.int_mk_b)), \
 	     "m" (preempt_count()), "di" (HARDIRQ_OFFSET)		   \
 );									   \
 	for (;;);			/* fake noreturn */		   \
@@ -366,14 +366,14 @@ void __init atari_init_IRQ(void)
 	/* Initialize the MFP(s) */
 
 #ifdef ATARI_USE_SOFTWARE_EOI
-	mfp.vec_adr  = 0x48;	/* Software EOI-Mode */
+	st_mfp.vec_adr  = 0x48;	/* Software EOI-Mode */
 #else
-	mfp.vec_adr  = 0x40;	/* Automatic EOI-Mode */
+	st_mfp.vec_adr  = 0x40;	/* Automatic EOI-Mode */
 #endif
-	mfp.int_en_a = 0x00;	/* turn off MFP-Ints */
-	mfp.int_en_b = 0x00;
-	mfp.int_mk_a = 0xff;	/* no Masking */
-	mfp.int_mk_b = 0xff;
+	st_mfp.int_en_a = 0x00;	/* turn off MFP-Ints */
+	st_mfp.int_en_b = 0x00;
+	st_mfp.int_mk_a = 0xff;	/* no Masking */
+	st_mfp.int_mk_b = 0xff;
 
 	if (ATARIHW_PRESENT(TT_MFP)) {
 #ifdef ATARI_USE_SOFTWARE_EOI

commit 29c8a24672e1cdfee99c15b870c57eb30ae69daf
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Oct 13 21:58:59 2008 +0200

    m68k: Remove the broken Hades support
    
    This patch removes the Hades support that was marked as BROKEN 5 years ago.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index b45593a60bdd..dba4afabb444 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -407,10 +407,8 @@ void __init atari_init_IRQ(void)
 		 * gets overruns)
 		 */
 
-		if (!MACH_IS_HADES) {
-			vectors[VEC_INT2] = falcon_hblhandler;
-			vectors[VEC_INT4] = falcon_hblhandler;
-		}
+		vectors[VEC_INT2] = falcon_hblhandler;
+		vectors[VEC_INT4] = falcon_hblhandler;
 	}
 
 	if (ATARIHW_PRESENT(PCM_8BIT) && ATARIHW_PRESENT(MICROWIRE)) {

commit a3b2004a2671455ee7aef1d9aee5a24381999ddb
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Feb 4 22:30:26 2008 -0800

    m68k: kill arch/m68k/atari/atari_ksyms.c
    
    EXPORT_SYMBOL's belong to the actual code.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index b85ca22024c1..b45593a60bdd 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -40,6 +40,7 @@
 #include <linux/kernel_stat.h>
 #include <linux/init.h>
 #include <linux/seq_file.h>
+#include <linux/module.h>
 
 #include <asm/system.h>
 #include <asm/traps.h>
@@ -446,6 +447,7 @@ unsigned long atari_register_vme_int(void)
 	free_vme_vec_bitmap |= 1 << i;
 	return VME_SOURCE_BASE + i;
 }
+EXPORT_SYMBOL(atari_register_vme_int);
 
 
 void atari_unregister_vme_int(unsigned long irq)
@@ -455,5 +457,6 @@ void atari_unregister_vme_int(unsigned long irq)
 		free_vme_vec_bitmap &= ~(1 << irq);
 	}
 }
+EXPORT_SYMBOL(atari_unregister_vme_int);
 
 

commit 241258d1cc4d3551608364cd678d5a85239ad481
Author: Milind Arun Choudhary <milindchoudhary@gmail.com>
Date:   Sun May 6 14:50:54 2007 -0700

    SPIN_LOCK_UNLOCKED cleanup in arch/m68k
    
    SPIN_LOCK_UNLOCKED cleanup,use __SPIN_LOCK_UNLOCKED instead
    
    Signed-off-by: Milind Arun Choudhary <milindchoudhary@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 7f812641790c..b85ca22024c1 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -339,7 +339,7 @@ static void atari_shutdown_irq(unsigned int irq)
 
 static struct irq_controller atari_irq_controller = {
 	.name		= "atari",
-	.lock		= SPIN_LOCK_UNLOCKED,
+	.lock		= __SPIN_LOCK_UNLOCKED(atari_irq_controller.lock),
 	.startup	= atari_startup_irq,
 	.shutdown	= atari_shutdown_irq,
 	.enable		= atari_enable_irq,

commit 69961c375288bdab7604e0bb1c8d22999bb8a347
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Oct 9 22:23:31 2006 +0200

    [PATCH] m68k/Atari: Interrupt updates
    
    Misc Atari fixes:
      - initialize correct number of atari irqs
      - silence vbl interrupt until it's used by atafb
      - use mdelay() to read clock if necessary
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index ece13cbf9950..7f812641790c 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -332,6 +332,9 @@ static void atari_shutdown_irq(unsigned int irq)
 	atari_disable_irq(irq);
 	atari_turnoff_irq(irq);
 	m68k_irq_shutdown(irq);
+
+	if (irq == IRQ_AUTO_4)
+	    vectors[VEC_INT4] = falcon_hblhandler;
 }
 
 static struct irq_controller atari_irq_controller = {
@@ -356,7 +359,7 @@ static struct irq_controller atari_irq_controller = {
 
 void __init atari_init_IRQ(void)
 {
-	m68k_setup_user_interrupt(VEC_USER, 192, NULL);
+	m68k_setup_user_interrupt(VEC_USER, NUM_ATARI_SOURCES - IRQ_USER, NULL);
 	m68k_setup_irq_controller(&atari_irq_controller, 1, NUM_ATARI_SOURCES - 1);
 
 	/* Initialize the MFP(s) */
@@ -403,8 +406,10 @@ void __init atari_init_IRQ(void)
 		 * gets overruns)
 		 */
 
-		if (!MACH_IS_HADES)
+		if (!MACH_IS_HADES) {
 			vectors[VEC_INT2] = falcon_hblhandler;
+			vectors[VEC_INT4] = falcon_hblhandler;
+		}
 	}
 
 	if (ATARIHW_PRESENT(PCM_8BIT) && ATARIHW_PRESENT(MICROWIRE)) {

commit 734085651c9b80aa3f9e6027b156102de214a0b2
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:03 2006 -0700

    [PATCH] m68k: convert atari irq code
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index bb54741dd6cd..ece13cbf9950 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -104,6 +104,7 @@
  * the sr copy in the frame.
  */
 
+#if 0
 
 #define	NUM_INT_SOURCES	(8 + NUM_ATARI_SOURCES)
 
@@ -133,13 +134,6 @@ static struct irqhandler irq_handler[NUM_INT_SOURCES];
  */
 static struct irqparam irq_param[NUM_INT_SOURCES];
 
-/*
- * Bitmap for free interrupt vector numbers
- * (new vectors starting from 0x70 can be allocated by
- * atari_register_vme_int())
- */
-static int free_vme_vec_bitmap;
-
 /* check for valid int number (complex, sigh...) */
 #define	IS_VALID_INTNO(n)											\
 	((n) > 0 &&														\
@@ -301,6 +295,14 @@ __asm__ (__ALIGN_STR "\n"
 );
 	for (;;);
 }
+#endif
+
+/*
+ * Bitmap for free interrupt vector numbers
+ * (new vectors starting from 0x70 can be allocated by
+ * atari_register_vme_int())
+ */
+static int free_vme_vec_bitmap;
 
 /* GK:
  * HBL IRQ handler for Falcon. Nobody needs it :-)
@@ -313,13 +315,34 @@ __ALIGN_STR "\n\t"
 	"orw	#0x200,%sp@\n\t"	/* set saved ipl to 2 */
 	"rte");
 
-/* Defined in entry.S; only increments 'num_spurious' */
-asmlinkage void bad_inthandler(void);
-
-extern void atari_microwire_cmd( int cmd );
+extern void atari_microwire_cmd(int cmd);
 
 extern int atari_SCC_reset_done;
 
+static int atari_startup_irq(unsigned int irq)
+{
+	m68k_irq_startup(irq);
+	atari_turnon_irq(irq);
+	atari_enable_irq(irq);
+	return 0;
+}
+
+static void atari_shutdown_irq(unsigned int irq)
+{
+	atari_disable_irq(irq);
+	atari_turnoff_irq(irq);
+	m68k_irq_shutdown(irq);
+}
+
+static struct irq_controller atari_irq_controller = {
+	.name		= "atari",
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.startup	= atari_startup_irq,
+	.shutdown	= atari_shutdown_irq,
+	.enable		= atari_enable_irq,
+	.disable	= atari_disable_irq,
+};
+
 /*
  * void atari_init_IRQ (void)
  *
@@ -333,12 +356,8 @@ extern int atari_SCC_reset_done;
 
 void __init atari_init_IRQ(void)
 {
-	int i;
-
-	/* initialize the vector table */
-	for (i = 0; i < NUM_INT_SOURCES; ++i) {
-		vectors[IRQ_SOURCE_TO_VECTOR(i)] = bad_inthandler;
-	}
+	m68k_setup_user_interrupt(VEC_USER, 192, NULL);
+	m68k_setup_irq_controller(&atari_irq_controller, 1, NUM_ATARI_SOURCES - 1);
 
 	/* Initialize the MFP(s) */
 
@@ -378,8 +397,7 @@ void __init atari_init_IRQ(void)
 									 * enabled in VME mask
 									 */
 		tt_scu.vme_mask = 0x60;		/* enable MFP and SCC ints */
-	}
-	else {
+	} else {
 		/* If no SCU and no Hades, the HSYNC interrupt needs to be
 		 * disabled this way. (Else _inthandler in kernel/sys_call.S
 		 * gets overruns)
@@ -404,184 +422,6 @@ void __init atari_init_IRQ(void)
 }
 
 
-static irqreturn_t atari_call_irq_list( int irq, void *dev_id, struct pt_regs *fp )
-{
-	irq_node_t *node;
-
-	for (node = (irq_node_t *)dev_id; node; node = node->next)
-		node->handler(irq, node->dev_id, fp);
-	return IRQ_HANDLED;
-}
-
-
-/*
- * atari_request_irq : add an interrupt service routine for a particular
- *                     machine specific interrupt source.
- *                     If the addition was successful, it returns 0.
- */
-
-int atari_request_irq(unsigned int irq, irqreturn_t (*handler)(int, void *, struct pt_regs *),
-                      unsigned long flags, const char *devname, void *dev_id)
-{
-	int vector;
-	unsigned long oflags = flags;
-
-	/*
-	 * The following is a hack to make some PCI card drivers work,
-	 * which set the SA_SHIRQ flag.
-	 */
-
-	flags &= ~SA_SHIRQ;
-
-	if (flags == SA_INTERRUPT) {
-		printk ("%s: SA_INTERRUPT changed to IRQ_TYPE_SLOW for %s\n",
-			__FUNCTION__, devname);
-		flags = IRQ_TYPE_SLOW;
-	}
-	if (flags < IRQ_TYPE_SLOW || flags > IRQ_TYPE_PRIO) {
-		printk ("%s: Bad irq type 0x%lx <0x%lx> requested from %s\n",
-		        __FUNCTION__, flags, oflags, devname);
-		return -EINVAL;
-	}
-	if (!IS_VALID_INTNO(irq)) {
-		printk ("%s: Unknown irq %d requested from %s\n",
-		        __FUNCTION__, irq, devname);
-		return -ENXIO;
-	}
-	vector = IRQ_SOURCE_TO_VECTOR(irq);
-
-	/*
-	 * Check type/source combination: slow ints are (currently)
-	 * only possible for MFP-interrupts.
-	 */
-	if (flags == IRQ_TYPE_SLOW &&
-		(irq < STMFP_SOURCE_BASE || irq >= SCC_SOURCE_BASE)) {
-		printk ("%s: Slow irq requested for non-MFP source %d from %s\n",
-		        __FUNCTION__, irq, devname);
-		return -EINVAL;
-	}
-
-	if (vectors[vector] == bad_inthandler) {
-		/* int has no handler yet */
-		irq_handler[irq].handler = handler;
-		irq_handler[irq].dev_id  = dev_id;
-		irq_param[irq].flags   = flags;
-		irq_param[irq].devname = devname;
-		vectors[vector] =
-			(flags == IRQ_TYPE_SLOW) ? slow_handlers[irq-STMFP_SOURCE_BASE] :
-			(flags == IRQ_TYPE_FAST) ? atari_fast_irq_handler :
-			                          atari_prio_irq_handler;
-		/* If MFP int, also enable and umask it */
-		atari_turnon_irq(irq);
-		atari_enable_irq(irq);
-
-		return 0;
-	}
-	else if (irq_param[irq].flags == flags) {
-		/* old handler is of same type -> handlers can be chained */
-		irq_node_t *node;
-		unsigned long flags;
-
-		local_irq_save(flags);
-
-		if (irq_handler[irq].handler != atari_call_irq_list) {
-			/* Only one handler yet, make a node for this first one */
-			if (!(node = new_irq_node()))
-				return -ENOMEM;
-			node->handler = irq_handler[irq].handler;
-			node->dev_id  = irq_handler[irq].dev_id;
-			node->devname = irq_param[irq].devname;
-			node->next = NULL;
-
-			irq_handler[irq].handler = atari_call_irq_list;
-			irq_handler[irq].dev_id  = node;
-			irq_param[irq].devname   = "chained";
-		}
-
-		if (!(node = new_irq_node()))
-			return -ENOMEM;
-		node->handler = handler;
-		node->dev_id  = dev_id;
-		node->devname = devname;
-		/* new handlers are put in front of the queue */
-		node->next = irq_handler[irq].dev_id;
-		irq_handler[irq].dev_id = node;
-
-		local_irq_restore(flags);
-		return 0;
-	} else {
-		printk ("%s: Irq %d allocated by other type int (call from %s)\n",
-		        __FUNCTION__, irq, devname);
-		return -EBUSY;
-	}
-}
-
-void atari_free_irq(unsigned int irq, void *dev_id)
-{
-	unsigned long flags;
-	int vector;
-	irq_node_t **list, *node;
-
-	if (!IS_VALID_INTNO(irq)) {
-		printk("%s: Unknown irq %d\n", __FUNCTION__, irq);
-		return;
-	}
-
-	vector = IRQ_SOURCE_TO_VECTOR(irq);
-	if (vectors[vector] == bad_inthandler)
-		goto not_found;
-
-	local_irq_save(flags);
-
-	if (irq_handler[irq].handler != atari_call_irq_list) {
-		/* It's the only handler for the interrupt */
-		if (irq_handler[irq].dev_id != dev_id) {
-			local_irq_restore(flags);
-			goto not_found;
-		}
-		irq_handler[irq].handler = NULL;
-		irq_handler[irq].dev_id  = NULL;
-		irq_param[irq].devname   = NULL;
-		vectors[vector] = bad_inthandler;
-		/* If MFP int, also disable it */
-		atari_disable_irq(irq);
-		atari_turnoff_irq(irq);
-
-		local_irq_restore(flags);
-		return;
-	}
-
-	/* The interrupt is chained, find the irq on the list */
-	for(list = (irq_node_t **)&irq_handler[irq].dev_id; *list; list = &(*list)->next) {
-		if ((*list)->dev_id == dev_id) break;
-	}
-	if (!*list) {
-		local_irq_restore(flags);
-		goto not_found;
-	}
-
-	(*list)->handler = NULL; /* Mark it as free for reallocation */
-	*list = (*list)->next;
-
-	/* If there's now only one handler, unchain the interrupt, i.e. plug in
-	 * the handler directly again and omit atari_call_irq_list */
-	node = (irq_node_t *)irq_handler[irq].dev_id;
-	if (node && !node->next) {
-		irq_handler[irq].handler = node->handler;
-		irq_handler[irq].dev_id  = node->dev_id;
-		irq_param[irq].devname   = node->devname;
-		node->handler = NULL; /* Mark it as free for reallocation */
-	}
-
-	local_irq_restore(flags);
-	return;
-
-not_found:
-	printk("%s: tried to remove invalid irq\n", __FUNCTION__);
-	return;
-}
-
-
 /*
  * atari_register_vme_int() returns the number of a free interrupt vector for
  * hardware with a programmable int vector (probably a VME board).
@@ -591,58 +431,24 @@ unsigned long atari_register_vme_int(void)
 {
 	int i;
 
-	for(i = 0; i < 32; i++)
-		if((free_vme_vec_bitmap & (1 << i)) == 0)
+	for (i = 0; i < 32; i++)
+		if ((free_vme_vec_bitmap & (1 << i)) == 0)
 			break;
 
-	if(i == 16)
+	if (i == 16)
 		return 0;
 
 	free_vme_vec_bitmap |= 1 << i;
-	return (VME_SOURCE_BASE + i);
+	return VME_SOURCE_BASE + i;
 }
 
 
 void atari_unregister_vme_int(unsigned long irq)
 {
-	if(irq >= VME_SOURCE_BASE && irq < VME_SOURCE_BASE + VME_MAX_SOURCES) {
+	if (irq >= VME_SOURCE_BASE && irq < VME_SOURCE_BASE + VME_MAX_SOURCES) {
 		irq -= VME_SOURCE_BASE;
 		free_vme_vec_bitmap &= ~(1 << irq);
 	}
 }
 
 
-int show_atari_interrupts(struct seq_file *p, void *v)
-{
-	int i;
-
-	for (i = 0; i < NUM_INT_SOURCES; ++i) {
-		if (vectors[IRQ_SOURCE_TO_VECTOR(i)] == bad_inthandler)
-			continue;
-		if (i < STMFP_SOURCE_BASE)
-			seq_printf(p, "auto %2d: %10u ",
-				       i, kstat_cpu(0).irqs[i]);
-		else
-			seq_printf(p, "vec $%02x: %10u ",
-				       IRQ_SOURCE_TO_VECTOR(i),
-				       kstat_cpu(0).irqs[i]);
-
-		if (irq_handler[i].handler != atari_call_irq_list) {
-			seq_printf(p, "%s\n", irq_param[i].devname);
-		}
-		else {
-			irq_node_t *n;
-			for( n = (irq_node_t *)irq_handler[i].dev_id; n; n = n->next ) {
-				seq_printf(p, "%s\n", n->devname);
-				if (n->next)
-					seq_puts(p, "                    " );
-			}
-		}
-	}
-	if (num_spurious)
-		seq_printf(p, "spurio.: %10u\n", num_spurious);
-
-	return 0;
-}
-
-

commit 92445eaaadc1f03f5a177ecc957bda76bf2ba8d5
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:46:58 2006 -0700

    [PATCH] m68k: separate handler for auto and user vector interrupt
    
    Use separate entry points for auto and user vector interrupts and cleanup
    naming a little.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
index 076f47917842..bb54741dd6cd 100644
--- a/arch/m68k/atari/ataints.c
+++ b/arch/m68k/atari/ataints.c
@@ -314,7 +314,7 @@ __ALIGN_STR "\n\t"
 	"rte");
 
 /* Defined in entry.S; only increments 'num_spurious' */
-asmlinkage void bad_interrupt(void);
+asmlinkage void bad_inthandler(void);
 
 extern void atari_microwire_cmd( int cmd );
 
@@ -337,7 +337,7 @@ void __init atari_init_IRQ(void)
 
 	/* initialize the vector table */
 	for (i = 0; i < NUM_INT_SOURCES; ++i) {
-		vectors[IRQ_SOURCE_TO_VECTOR(i)] = bad_interrupt;
+		vectors[IRQ_SOURCE_TO_VECTOR(i)] = bad_inthandler;
 	}
 
 	/* Initialize the MFP(s) */
@@ -461,7 +461,7 @@ int atari_request_irq(unsigned int irq, irqreturn_t (*handler)(int, void *, stru
 		return -EINVAL;
 	}
 
-	if (vectors[vector] == bad_interrupt) {
+	if (vectors[vector] == bad_inthandler) {
 		/* int has no handler yet */
 		irq_handler[irq].handler = handler;
 		irq_handler[irq].dev_id  = dev_id;
@@ -528,7 +528,7 @@ void atari_free_irq(unsigned int irq, void *dev_id)
 	}
 
 	vector = IRQ_SOURCE_TO_VECTOR(irq);
-	if (vectors[vector] == bad_interrupt)
+	if (vectors[vector] == bad_inthandler)
 		goto not_found;
 
 	local_irq_save(flags);
@@ -542,7 +542,7 @@ void atari_free_irq(unsigned int irq, void *dev_id)
 		irq_handler[irq].handler = NULL;
 		irq_handler[irq].dev_id  = NULL;
 		irq_param[irq].devname   = NULL;
-		vectors[vector] = bad_interrupt;
+		vectors[vector] = bad_inthandler;
 		/* If MFP int, also disable it */
 		atari_disable_irq(irq);
 		atari_turnoff_irq(irq);
@@ -617,7 +617,7 @@ int show_atari_interrupts(struct seq_file *p, void *v)
 	int i;
 
 	for (i = 0; i < NUM_INT_SOURCES; ++i) {
-		if (vectors[IRQ_SOURCE_TO_VECTOR(i)] == bad_interrupt)
+		if (vectors[IRQ_SOURCE_TO_VECTOR(i)] == bad_inthandler)
 			continue;
 		if (i < STMFP_SOURCE_BASE)
 			seq_printf(p, "auto %2d: %10u ",

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/atari/ataints.c b/arch/m68k/atari/ataints.c
new file mode 100644
index 000000000000..076f47917842
--- /dev/null
+++ b/arch/m68k/atari/ataints.c
@@ -0,0 +1,648 @@
+/*
+ * arch/m68k/atari/ataints.c -- Atari Linux interrupt handling code
+ *
+ * 5/2/94 Roman Hodek:
+ *  Added support for TT interrupts; setup for TT SCU (may someone has
+ *  twiddled there and we won't get the right interrupts :-()
+ *
+ *  Major change: The device-independent code in m68k/ints.c didn't know
+ *  about non-autovec ints yet. It hardcoded the number of possible ints to
+ *  7 (IRQ1...IRQ7). But the Atari has lots of non-autovec ints! I made the
+ *  number of possible ints a constant defined in interrupt.h, which is
+ *  47 for the Atari. So we can call request_irq() for all Atari interrupts
+ *  just the normal way. Additionally, all vectors >= 48 are initialized to
+ *  call trap() instead of inthandler(). This must be changed here, too.
+ *
+ * 1995-07-16 Lars Brinkhoff <f93labr@dd.chalmers.se>:
+ *  Corrected a bug in atari_add_isr() which rejected all SCC
+ *  interrupt sources if there were no TT MFP!
+ *
+ * 12/13/95: New interface functions atari_level_triggered_int() and
+ *  atari_register_vme_int() as support for level triggered VME interrupts.
+ *
+ * 02/12/96: (Roman)
+ *  Total rewrite of Atari interrupt handling, for new scheme see comments
+ *  below.
+ *
+ * 1996-09-03 lars brinkhoff <f93labr@dd.chalmers.se>:
+ *  Added new function atari_unregister_vme_int(), and
+ *  modified atari_register_vme_int() as well as IS_VALID_INTNO()
+ *  to work with it.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/kernel_stat.h>
+#include <linux/init.h>
+#include <linux/seq_file.h>
+
+#include <asm/system.h>
+#include <asm/traps.h>
+
+#include <asm/atarihw.h>
+#include <asm/atariints.h>
+#include <asm/atari_stdma.h>
+#include <asm/irq.h>
+#include <asm/entry.h>
+
+
+/*
+ * Atari interrupt handling scheme:
+ * --------------------------------
+ *
+ * All interrupt source have an internal number (defined in
+ * <asm/atariints.h>): Autovector interrupts are 1..7, then follow ST-MFP,
+ * TT-MFP, SCC, and finally VME interrupts. Vector numbers for the latter can
+ * be allocated by atari_register_vme_int().
+ *
+ * Each interrupt can be of three types:
+ *
+ *  - SLOW: The handler runs with all interrupts enabled, except the one it
+ *    was called by (to avoid reentering). This should be the usual method.
+ *    But it is currently possible only for MFP ints, since only the MFP
+ *    offers an easy way to mask interrupts.
+ *
+ *  - FAST: The handler runs with all interrupts disabled. This should be used
+ *    only for really fast handlers, that just do actions immediately
+ *    necessary, and let the rest do a bottom half or task queue.
+ *
+ *  - PRIORITIZED: The handler can be interrupted by higher-level ints
+ *    (greater IPL, no MFP priorities!). This is the method of choice for ints
+ *    which should be slow, but are not from a MFP.
+ *
+ * The feature of more than one handler for one int source is still there, but
+ * only applicable if all handers are of the same type. To not slow down
+ * processing of ints with only one handler by the chaining feature, the list
+ * calling function atari_call_irq_list() is only plugged in at the time the
+ * second handler is registered.
+ *
+ * Implementation notes: For fast-as-possible int handling, there are separate
+ * entry points for each type (slow/fast/prio). The assembler handler calls
+ * the irq directly in the usual case, no C wrapper is involved. In case of
+ * multiple handlers, atari_call_irq_list() is registered as handler and calls
+ * in turn the real irq's. To ease access from assembler level to the irq
+ * function pointer and accompanying data, these two are stored in a separate
+ * array, irq_handler[]. The rest of data (type, name) are put into a second
+ * array, irq_param, that is accessed from C only. For each slow interrupt (32
+ * in all) there are separate handler functions, which makes it possible to
+ * hard-code the MFP register address and value, are necessary to mask the
+ * int. If there'd be only one generic function, lots of calculations would be
+ * needed to determine MFP register and int mask from the vector number :-(
+ *
+ * Furthermore, slow ints may not lower the IPL below its previous value
+ * (before the int happened). This is needed so that an int of class PRIO, on
+ * that this int may be stacked, cannot be reentered. This feature is
+ * implemented as follows: If the stack frame format is 1 (throwaway), the int
+ * is not stacked, and the IPL is anded with 0xfbff, resulting in a new level
+ * 2, which still blocks the HSYNC, but no interrupts of interest. If the
+ * frame format is 0, the int is nested, and the old IPL value can be found in
+ * the sr copy in the frame.
+ */
+
+
+#define	NUM_INT_SOURCES	(8 + NUM_ATARI_SOURCES)
+
+typedef void (*asm_irq_handler)(void);
+
+struct irqhandler {
+	irqreturn_t (*handler)(int, void *, struct pt_regs *);
+	void	*dev_id;
+};
+
+struct irqparam {
+	unsigned long	flags;
+	const char	*devname;
+};
+
+/*
+ * Array with irq's and their parameter data. This array is accessed from low
+ * level assembler code, so an element size of 8 allows usage of index scaling
+ * addressing mode.
+ */
+static struct irqhandler irq_handler[NUM_INT_SOURCES];
+
+/*
+ * This array hold the rest of parameters of int handlers: type
+ * (slow,fast,prio) and the name of the handler. These values are only
+ * accessed from C
+ */
+static struct irqparam irq_param[NUM_INT_SOURCES];
+
+/*
+ * Bitmap for free interrupt vector numbers
+ * (new vectors starting from 0x70 can be allocated by
+ * atari_register_vme_int())
+ */
+static int free_vme_vec_bitmap;
+
+/* check for valid int number (complex, sigh...) */
+#define	IS_VALID_INTNO(n)											\
+	((n) > 0 &&														\
+	 /* autovec and ST-MFP ok anyway */								\
+	 (((n) < TTMFP_SOURCE_BASE) ||									\
+	  /* TT-MFP ok if present */									\
+	  ((n) >= TTMFP_SOURCE_BASE && (n) < SCC_SOURCE_BASE &&			\
+	   ATARIHW_PRESENT(TT_MFP)) ||									\
+	  /* SCC ok if present and number even */						\
+	  ((n) >= SCC_SOURCE_BASE && (n) < VME_SOURCE_BASE &&			\
+	   !((n) & 1) && ATARIHW_PRESENT(SCC)) ||						\
+	  /* greater numbers ok if they are registered VME vectors */		\
+	  ((n) >= VME_SOURCE_BASE && (n) < VME_SOURCE_BASE + VME_MAX_SOURCES && \
+		  free_vme_vec_bitmap & (1 << ((n) - VME_SOURCE_BASE)))))
+
+
+/*
+ * Here start the assembler entry points for interrupts
+ */
+
+#define IRQ_NAME(nr) atari_slow_irq_##nr##_handler(void)
+
+#define	BUILD_SLOW_IRQ(n)						   \
+asmlinkage void IRQ_NAME(n);						   \
+/* Dummy function to allow asm with operands.  */			   \
+void atari_slow_irq_##n##_dummy (void) {				   \
+__asm__ (__ALIGN_STR "\n"						   \
+"atari_slow_irq_" #n "_handler:\t"					   \
+"	addl	%6,%5\n"	/* preempt_count() += HARDIRQ_OFFSET */	   \
+	SAVE_ALL_INT "\n"						   \
+	GET_CURRENT(%%d0) "\n"						   \
+"	andb	#~(1<<(%c3&7)),%a4:w\n"	/* mask this interrupt */	   \
+	/* get old IPL from stack frame */				   \
+"	bfextu	%%sp@(%c2){#5,#3},%%d0\n"				   \
+"	movew	%%sr,%%d1\n"						   \
+"	bfins	%%d0,%%d1{#21,#3}\n"					   \
+"	movew	%%d1,%%sr\n"		/* set IPL = previous value */	   \
+"	addql	#1,%a0\n"						   \
+"	lea	%a1,%%a0\n"						   \
+"	pea	%%sp@\n"		/* push addr of frame */	   \
+"	movel	%%a0@(4),%%sp@-\n"	/* push handler data */		   \
+"	pea	(%c3+8)\n"		/* push int number */		   \
+"	movel	%%a0@,%%a0\n"						   \
+"	jbsr	%%a0@\n"		/* call the handler */		   \
+"	addql	#8,%%sp\n"						   \
+"	addql	#4,%%sp\n"						   \
+"	orw	#0x0600,%%sr\n"						   \
+"	andw	#0xfeff,%%sr\n"		/* set IPL = 6 again */		   \
+"	orb	#(1<<(%c3&7)),%a4:w\n"	/* now unmask the int again */	   \
+"	jbra	ret_from_interrupt\n"					   \
+	 : : "i" (&kstat_cpu(0).irqs[n+8]), "i" (&irq_handler[n+8]),	   \
+	     "n" (PT_OFF_SR), "n" (n),					   \
+	     "i" (n & 8 ? (n & 16 ? &tt_mfp.int_mk_a : &mfp.int_mk_a)	   \
+		        : (n & 16 ? &tt_mfp.int_mk_b : &mfp.int_mk_b)),	   \
+	     "m" (preempt_count()), "di" (HARDIRQ_OFFSET)		   \
+);									   \
+	for (;;);			/* fake noreturn */		   \
+}
+
+BUILD_SLOW_IRQ(0);
+BUILD_SLOW_IRQ(1);
+BUILD_SLOW_IRQ(2);
+BUILD_SLOW_IRQ(3);
+BUILD_SLOW_IRQ(4);
+BUILD_SLOW_IRQ(5);
+BUILD_SLOW_IRQ(6);
+BUILD_SLOW_IRQ(7);
+BUILD_SLOW_IRQ(8);
+BUILD_SLOW_IRQ(9);
+BUILD_SLOW_IRQ(10);
+BUILD_SLOW_IRQ(11);
+BUILD_SLOW_IRQ(12);
+BUILD_SLOW_IRQ(13);
+BUILD_SLOW_IRQ(14);
+BUILD_SLOW_IRQ(15);
+BUILD_SLOW_IRQ(16);
+BUILD_SLOW_IRQ(17);
+BUILD_SLOW_IRQ(18);
+BUILD_SLOW_IRQ(19);
+BUILD_SLOW_IRQ(20);
+BUILD_SLOW_IRQ(21);
+BUILD_SLOW_IRQ(22);
+BUILD_SLOW_IRQ(23);
+BUILD_SLOW_IRQ(24);
+BUILD_SLOW_IRQ(25);
+BUILD_SLOW_IRQ(26);
+BUILD_SLOW_IRQ(27);
+BUILD_SLOW_IRQ(28);
+BUILD_SLOW_IRQ(29);
+BUILD_SLOW_IRQ(30);
+BUILD_SLOW_IRQ(31);
+
+asm_irq_handler slow_handlers[32] = {
+	[0]	= atari_slow_irq_0_handler,
+	[1]	= atari_slow_irq_1_handler,
+	[2]	= atari_slow_irq_2_handler,
+	[3]	= atari_slow_irq_3_handler,
+	[4]	= atari_slow_irq_4_handler,
+	[5]	= atari_slow_irq_5_handler,
+	[6]	= atari_slow_irq_6_handler,
+	[7]	= atari_slow_irq_7_handler,
+	[8]	= atari_slow_irq_8_handler,
+	[9]	= atari_slow_irq_9_handler,
+	[10]	= atari_slow_irq_10_handler,
+	[11]	= atari_slow_irq_11_handler,
+	[12]	= atari_slow_irq_12_handler,
+	[13]	= atari_slow_irq_13_handler,
+	[14]	= atari_slow_irq_14_handler,
+	[15]	= atari_slow_irq_15_handler,
+	[16]	= atari_slow_irq_16_handler,
+	[17]	= atari_slow_irq_17_handler,
+	[18]	= atari_slow_irq_18_handler,
+	[19]	= atari_slow_irq_19_handler,
+	[20]	= atari_slow_irq_20_handler,
+	[21]	= atari_slow_irq_21_handler,
+	[22]	= atari_slow_irq_22_handler,
+	[23]	= atari_slow_irq_23_handler,
+	[24]	= atari_slow_irq_24_handler,
+	[25]	= atari_slow_irq_25_handler,
+	[26]	= atari_slow_irq_26_handler,
+	[27]	= atari_slow_irq_27_handler,
+	[28]	= atari_slow_irq_28_handler,
+	[29]	= atari_slow_irq_29_handler,
+	[30]	= atari_slow_irq_30_handler,
+	[31]	= atari_slow_irq_31_handler
+};
+
+asmlinkage void atari_fast_irq_handler( void );
+asmlinkage void atari_prio_irq_handler( void );
+
+/* Dummy function to allow asm with operands.  */
+void atari_fast_prio_irq_dummy (void) {
+__asm__ (__ALIGN_STR "\n"
+"atari_fast_irq_handler:\n\t"
+	"orw	#0x700,%%sr\n"		/* disable all interrupts */
+"atari_prio_irq_handler:\n\t"
+	"addl	%3,%2\n\t"		/* preempt_count() += HARDIRQ_OFFSET */
+	SAVE_ALL_INT "\n\t"
+	GET_CURRENT(%%d0) "\n\t"
+	/* get vector number from stack frame and convert to source */
+	"bfextu	%%sp@(%c1){#4,#10},%%d0\n\t"
+	"subw	#(0x40-8),%%d0\n\t"
+	"jpl	1f\n\t"
+	"addw	#(0x40-8-0x18),%%d0\n"
+    "1:\tlea	%a0,%%a0\n\t"
+	"addql	#1,%%a0@(%%d0:l:4)\n\t"
+	"lea	irq_handler,%%a0\n\t"
+	"lea	%%a0@(%%d0:l:8),%%a0\n\t"
+	"pea	%%sp@\n\t"		/* push frame address */
+	"movel	%%a0@(4),%%sp@-\n\t"	/* push handler data */
+	"movel	%%d0,%%sp@-\n\t"	/* push int number */
+	"movel	%%a0@,%%a0\n\t"
+	"jsr	%%a0@\n\t"		/* and call the handler */
+	"addql	#8,%%sp\n\t"
+	"addql	#4,%%sp\n\t"
+	"jbra	ret_from_interrupt"
+	 : : "i" (&kstat_cpu(0).irqs), "n" (PT_OFF_FORMATVEC),
+	     "m" (preempt_count()), "di" (HARDIRQ_OFFSET)
+);
+	for (;;);
+}
+
+/* GK:
+ * HBL IRQ handler for Falcon. Nobody needs it :-)
+ * ++andreas: raise ipl to disable further HBLANK interrupts.
+ */
+asmlinkage void falcon_hblhandler(void);
+asm(".text\n"
+__ALIGN_STR "\n\t"
+"falcon_hblhandler:\n\t"
+	"orw	#0x200,%sp@\n\t"	/* set saved ipl to 2 */
+	"rte");
+
+/* Defined in entry.S; only increments 'num_spurious' */
+asmlinkage void bad_interrupt(void);
+
+extern void atari_microwire_cmd( int cmd );
+
+extern int atari_SCC_reset_done;
+
+/*
+ * void atari_init_IRQ (void)
+ *
+ * Parameters:	None
+ *
+ * Returns:	Nothing
+ *
+ * This function should be called during kernel startup to initialize
+ * the atari IRQ handling routines.
+ */
+
+void __init atari_init_IRQ(void)
+{
+	int i;
+
+	/* initialize the vector table */
+	for (i = 0; i < NUM_INT_SOURCES; ++i) {
+		vectors[IRQ_SOURCE_TO_VECTOR(i)] = bad_interrupt;
+	}
+
+	/* Initialize the MFP(s) */
+
+#ifdef ATARI_USE_SOFTWARE_EOI
+	mfp.vec_adr  = 0x48;	/* Software EOI-Mode */
+#else
+	mfp.vec_adr  = 0x40;	/* Automatic EOI-Mode */
+#endif
+	mfp.int_en_a = 0x00;	/* turn off MFP-Ints */
+	mfp.int_en_b = 0x00;
+	mfp.int_mk_a = 0xff;	/* no Masking */
+	mfp.int_mk_b = 0xff;
+
+	if (ATARIHW_PRESENT(TT_MFP)) {
+#ifdef ATARI_USE_SOFTWARE_EOI
+		tt_mfp.vec_adr  = 0x58;		/* Software EOI-Mode */
+#else
+		tt_mfp.vec_adr  = 0x50;		/* Automatic EOI-Mode */
+#endif
+		tt_mfp.int_en_a = 0x00;		/* turn off MFP-Ints */
+		tt_mfp.int_en_b = 0x00;
+		tt_mfp.int_mk_a = 0xff;		/* no Masking */
+		tt_mfp.int_mk_b = 0xff;
+	}
+
+	if (ATARIHW_PRESENT(SCC) && !atari_SCC_reset_done) {
+		scc.cha_a_ctrl = 9;
+		MFPDELAY();
+		scc.cha_a_ctrl = (char) 0xc0; /* hardware reset */
+	}
+
+	if (ATARIHW_PRESENT(SCU)) {
+		/* init the SCU if present */
+		tt_scu.sys_mask = 0x10;		/* enable VBL (for the cursor) and
+									 * disable HSYNC interrupts (who
+									 * needs them?)  MFP and SCC are
+									 * enabled in VME mask
+									 */
+		tt_scu.vme_mask = 0x60;		/* enable MFP and SCC ints */
+	}
+	else {
+		/* If no SCU and no Hades, the HSYNC interrupt needs to be
+		 * disabled this way. (Else _inthandler in kernel/sys_call.S
+		 * gets overruns)
+		 */
+
+		if (!MACH_IS_HADES)
+			vectors[VEC_INT2] = falcon_hblhandler;
+	}
+
+	if (ATARIHW_PRESENT(PCM_8BIT) && ATARIHW_PRESENT(MICROWIRE)) {
+		/* Initialize the LM1992 Sound Controller to enable
+		   the PSG sound.  This is misplaced here, it should
+		   be in an atasound_init(), that doesn't exist yet. */
+		atari_microwire_cmd(MW_LM1992_PSG_HIGH);
+	}
+
+	stdma_init();
+
+	/* Initialize the PSG: all sounds off, both ports output */
+	sound_ym.rd_data_reg_sel = 7;
+	sound_ym.wd_data = 0xff;
+}
+
+
+static irqreturn_t atari_call_irq_list( int irq, void *dev_id, struct pt_regs *fp )
+{
+	irq_node_t *node;
+
+	for (node = (irq_node_t *)dev_id; node; node = node->next)
+		node->handler(irq, node->dev_id, fp);
+	return IRQ_HANDLED;
+}
+
+
+/*
+ * atari_request_irq : add an interrupt service routine for a particular
+ *                     machine specific interrupt source.
+ *                     If the addition was successful, it returns 0.
+ */
+
+int atari_request_irq(unsigned int irq, irqreturn_t (*handler)(int, void *, struct pt_regs *),
+                      unsigned long flags, const char *devname, void *dev_id)
+{
+	int vector;
+	unsigned long oflags = flags;
+
+	/*
+	 * The following is a hack to make some PCI card drivers work,
+	 * which set the SA_SHIRQ flag.
+	 */
+
+	flags &= ~SA_SHIRQ;
+
+	if (flags == SA_INTERRUPT) {
+		printk ("%s: SA_INTERRUPT changed to IRQ_TYPE_SLOW for %s\n",
+			__FUNCTION__, devname);
+		flags = IRQ_TYPE_SLOW;
+	}
+	if (flags < IRQ_TYPE_SLOW || flags > IRQ_TYPE_PRIO) {
+		printk ("%s: Bad irq type 0x%lx <0x%lx> requested from %s\n",
+		        __FUNCTION__, flags, oflags, devname);
+		return -EINVAL;
+	}
+	if (!IS_VALID_INTNO(irq)) {
+		printk ("%s: Unknown irq %d requested from %s\n",
+		        __FUNCTION__, irq, devname);
+		return -ENXIO;
+	}
+	vector = IRQ_SOURCE_TO_VECTOR(irq);
+
+	/*
+	 * Check type/source combination: slow ints are (currently)
+	 * only possible for MFP-interrupts.
+	 */
+	if (flags == IRQ_TYPE_SLOW &&
+		(irq < STMFP_SOURCE_BASE || irq >= SCC_SOURCE_BASE)) {
+		printk ("%s: Slow irq requested for non-MFP source %d from %s\n",
+		        __FUNCTION__, irq, devname);
+		return -EINVAL;
+	}
+
+	if (vectors[vector] == bad_interrupt) {
+		/* int has no handler yet */
+		irq_handler[irq].handler = handler;
+		irq_handler[irq].dev_id  = dev_id;
+		irq_param[irq].flags   = flags;
+		irq_param[irq].devname = devname;
+		vectors[vector] =
+			(flags == IRQ_TYPE_SLOW) ? slow_handlers[irq-STMFP_SOURCE_BASE] :
+			(flags == IRQ_TYPE_FAST) ? atari_fast_irq_handler :
+			                          atari_prio_irq_handler;
+		/* If MFP int, also enable and umask it */
+		atari_turnon_irq(irq);
+		atari_enable_irq(irq);
+
+		return 0;
+	}
+	else if (irq_param[irq].flags == flags) {
+		/* old handler is of same type -> handlers can be chained */
+		irq_node_t *node;
+		unsigned long flags;
+
+		local_irq_save(flags);
+
+		if (irq_handler[irq].handler != atari_call_irq_list) {
+			/* Only one handler yet, make a node for this first one */
+			if (!(node = new_irq_node()))
+				return -ENOMEM;
+			node->handler = irq_handler[irq].handler;
+			node->dev_id  = irq_handler[irq].dev_id;
+			node->devname = irq_param[irq].devname;
+			node->next = NULL;
+
+			irq_handler[irq].handler = atari_call_irq_list;
+			irq_handler[irq].dev_id  = node;
+			irq_param[irq].devname   = "chained";
+		}
+
+		if (!(node = new_irq_node()))
+			return -ENOMEM;
+		node->handler = handler;
+		node->dev_id  = dev_id;
+		node->devname = devname;
+		/* new handlers are put in front of the queue */
+		node->next = irq_handler[irq].dev_id;
+		irq_handler[irq].dev_id = node;
+
+		local_irq_restore(flags);
+		return 0;
+	} else {
+		printk ("%s: Irq %d allocated by other type int (call from %s)\n",
+		        __FUNCTION__, irq, devname);
+		return -EBUSY;
+	}
+}
+
+void atari_free_irq(unsigned int irq, void *dev_id)
+{
+	unsigned long flags;
+	int vector;
+	irq_node_t **list, *node;
+
+	if (!IS_VALID_INTNO(irq)) {
+		printk("%s: Unknown irq %d\n", __FUNCTION__, irq);
+		return;
+	}
+
+	vector = IRQ_SOURCE_TO_VECTOR(irq);
+	if (vectors[vector] == bad_interrupt)
+		goto not_found;
+
+	local_irq_save(flags);
+
+	if (irq_handler[irq].handler != atari_call_irq_list) {
+		/* It's the only handler for the interrupt */
+		if (irq_handler[irq].dev_id != dev_id) {
+			local_irq_restore(flags);
+			goto not_found;
+		}
+		irq_handler[irq].handler = NULL;
+		irq_handler[irq].dev_id  = NULL;
+		irq_param[irq].devname   = NULL;
+		vectors[vector] = bad_interrupt;
+		/* If MFP int, also disable it */
+		atari_disable_irq(irq);
+		atari_turnoff_irq(irq);
+
+		local_irq_restore(flags);
+		return;
+	}
+
+	/* The interrupt is chained, find the irq on the list */
+	for(list = (irq_node_t **)&irq_handler[irq].dev_id; *list; list = &(*list)->next) {
+		if ((*list)->dev_id == dev_id) break;
+	}
+	if (!*list) {
+		local_irq_restore(flags);
+		goto not_found;
+	}
+
+	(*list)->handler = NULL; /* Mark it as free for reallocation */
+	*list = (*list)->next;
+
+	/* If there's now only one handler, unchain the interrupt, i.e. plug in
+	 * the handler directly again and omit atari_call_irq_list */
+	node = (irq_node_t *)irq_handler[irq].dev_id;
+	if (node && !node->next) {
+		irq_handler[irq].handler = node->handler;
+		irq_handler[irq].dev_id  = node->dev_id;
+		irq_param[irq].devname   = node->devname;
+		node->handler = NULL; /* Mark it as free for reallocation */
+	}
+
+	local_irq_restore(flags);
+	return;
+
+not_found:
+	printk("%s: tried to remove invalid irq\n", __FUNCTION__);
+	return;
+}
+
+
+/*
+ * atari_register_vme_int() returns the number of a free interrupt vector for
+ * hardware with a programmable int vector (probably a VME board).
+ */
+
+unsigned long atari_register_vme_int(void)
+{
+	int i;
+
+	for(i = 0; i < 32; i++)
+		if((free_vme_vec_bitmap & (1 << i)) == 0)
+			break;
+
+	if(i == 16)
+		return 0;
+
+	free_vme_vec_bitmap |= 1 << i;
+	return (VME_SOURCE_BASE + i);
+}
+
+
+void atari_unregister_vme_int(unsigned long irq)
+{
+	if(irq >= VME_SOURCE_BASE && irq < VME_SOURCE_BASE + VME_MAX_SOURCES) {
+		irq -= VME_SOURCE_BASE;
+		free_vme_vec_bitmap &= ~(1 << irq);
+	}
+}
+
+
+int show_atari_interrupts(struct seq_file *p, void *v)
+{
+	int i;
+
+	for (i = 0; i < NUM_INT_SOURCES; ++i) {
+		if (vectors[IRQ_SOURCE_TO_VECTOR(i)] == bad_interrupt)
+			continue;
+		if (i < STMFP_SOURCE_BASE)
+			seq_printf(p, "auto %2d: %10u ",
+				       i, kstat_cpu(0).irqs[i]);
+		else
+			seq_printf(p, "vec $%02x: %10u ",
+				       IRQ_SOURCE_TO_VECTOR(i),
+				       kstat_cpu(0).irqs[i]);
+
+		if (irq_handler[i].handler != atari_call_irq_list) {
+			seq_printf(p, "%s\n", irq_param[i].devname);
+		}
+		else {
+			irq_node_t *n;
+			for( n = (irq_node_t *)irq_handler[i].dev_id; n; n = n->next ) {
+				seq_printf(p, "%s\n", n->devname);
+				if (n->next)
+					seq_puts(p, "                    " );
+			}
+		}
+	}
+	if (num_spurious)
+		seq_printf(p, "spurio.: %10u\n", num_spurious);
+
+	return 0;
+}
+
+
