commit 8a09cec25fa19a3a7e9f21b4186fecc69085a60f
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Dec 1 11:14:51 2013 +0100

    m68k/amiga,atari: Fix specifying multiple debug= parameters
    
    Since commit d6713b4091a99fa2af2fabdcd2f3fb97f32ecf2e ("m68k: early
    parameter support"), the user can specify multiple debug consoles using the
    "debug=" kernel command line parameter.
    However, as there's only a single struct console object, which is reused,
    it would actually register the same console object multiple times, causing
    the following warning:
    
    WARNING: CPU: 0 PID: 0 at kernel/printk/printk.c:2233 register_console+0x36/
    console 'debug0' already registered
    
    Make sure to register the console object only once, to avoid the warning.
    
    Note that still only one console (the one corresponding to the last
    "debug=" parameter) will be active at the same time, as the .write() method
    of the already registered console object is overwritten by a subsequent
    "debug=" parameter.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/debug.c b/arch/m68k/atari/debug.c
index a547ba9683d1..03cb5e08d7cf 100644
--- a/arch/m68k/atari/debug.c
+++ b/arch/m68k/atari/debug.c
@@ -287,6 +287,8 @@ static void __init atari_init_midi_port(int cflag)
 
 static int __init atari_debug_setup(char *arg)
 {
+	bool registered;
+
 	if (!MACH_IS_ATARI)
 		return 0;
 
@@ -294,6 +296,7 @@ static int __init atari_debug_setup(char *arg)
 		/* defaults to ser2 for a Falcon and ser1 otherwise */
 		arg = MACH_IS_FALCON ? "ser2" : "ser1";
 
+	registered = !!atari_console_driver.write;
 	if (!strcmp(arg, "ser1")) {
 		/* ST-MFP Modem1 serial port */
 		atari_init_mfp_port(B9600|CS8);
@@ -317,7 +320,7 @@ static int __init atari_debug_setup(char *arg)
 		sound_ym.wd_data = sound_ym.rd_data_reg_sel | 0x20; /* strobe H */
 		atari_console_driver.write = atari_par_console_write;
 	}
-	if (atari_console_driver.write)
+	if (atari_console_driver.write && !registered)
 		register_console(&atari_console_driver);
 
 	return 0;

commit 125298d2daf7c9005d5bc26313a037b798c8de70
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Nov 13 10:44:24 2011 +0100

    m68k/atari: Move declaration of atari_SCC_reset_done to header file
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/debug.c b/arch/m68k/atari/debug.c
index 5a484247e493..a547ba9683d1 100644
--- a/arch/m68k/atari/debug.c
+++ b/arch/m68k/atari/debug.c
@@ -202,7 +202,6 @@ static void __init atari_init_mfp_port(int cflag)
 
 static void __init atari_init_scc_port(int cflag)
 {
-	extern int atari_SCC_reset_done;
 	static int clksrc_table[9] =
 		/* reg 11: 0x50 = BRG, 0x00 = RTxC, 0x28 = TRxC */
 		{ 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x00, 0x00 };

commit de339e4b792aed799bec23251e83f594ac44ae04
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Jan 16 20:47:47 2011 +0100

    m68k/atari: Rename "scc" to "atari_scc"
    
    It's a way too generic name for a global #define and conflicts with a variable
    with the same name, causing build errors like:
    
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c: In function ‘_si_clkctl_cc’:
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1364: error: expected identifier or ‘(’ before ‘volatile’
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1364: error: expected ‘)’ before ‘(’ token
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1421: error: incompatible types in assignment
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1422: error: invalid operands to binary &
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1423: error: invalid operands to binary &
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1424: error: invalid operands to binary |
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: aggregate value used where an integer was expected
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1425: error: incompatible type for argument 4 of ‘bcmsdh_reg_write’
    | drivers/staging/brcm80211/brcmfmac/../util/siutils.c:1428: error: invalid operands to binary &
    | make[8]: *** [drivers/staging/brcm80211/brcmfmac/../util/siutils.o] Error 1
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/atari/debug.c b/arch/m68k/atari/debug.c
index 28efdc33c1ae..5a484247e493 100644
--- a/arch/m68k/atari/debug.c
+++ b/arch/m68k/atari/debug.c
@@ -53,9 +53,9 @@ static inline void ata_scc_out(char c)
 {
 	do {
 		MFPDELAY();
-	} while (!(scc.cha_b_ctrl & 0x04)); /* wait for tx buf empty */
+	} while (!(atari_scc.cha_b_ctrl & 0x04)); /* wait for tx buf empty */
 	MFPDELAY();
-	scc.cha_b_data = c;
+	atari_scc.cha_b_data = c;
 }
 
 static void atari_scc_console_write(struct console *co, const char *str,
@@ -140,9 +140,9 @@ int atari_scc_console_wait_key(struct console *co)
 {
 	do {
 		MFPDELAY();
-	} while (!(scc.cha_b_ctrl & 0x01)); /* wait for rx buf filled */
+	} while (!(atari_scc.cha_b_ctrl & 0x01)); /* wait for rx buf filled */
 	MFPDELAY();
-	return scc.cha_b_data;
+	return atari_scc.cha_b_data;
 }
 
 int atari_midi_console_wait_key(struct console *co)
@@ -185,9 +185,9 @@ static void __init atari_init_mfp_port(int cflag)
 
 #define SCC_WRITE(reg, val)				\
 	do {						\
-		scc.cha_b_ctrl = (reg);			\
+		atari_scc.cha_b_ctrl = (reg);		\
 		MFPDELAY();				\
-		scc.cha_b_ctrl = (val);			\
+		atari_scc.cha_b_ctrl = (val);		\
 		MFPDELAY();				\
 	} while (0)
 
@@ -240,7 +240,7 @@ static void __init atari_init_scc_port(int cflag)
 	reg3 = (cflag & CSIZE) == CS8 ? 0xc0 : 0x40;
 	reg5 = (cflag & CSIZE) == CS8 ? 0x60 : 0x20 | 0x82 /* assert DTR/RTS */;
 
-	(void)scc.cha_b_ctrl;		/* reset reg pointer */
+	(void)atari_scc.cha_b_ctrl;	/* reset reg pointer */
 	SCC_WRITE(9, 0xc0);		/* reset */
 	LONG_DELAY();			/* extra delay after WR9 access */
 	SCC_WRITE(4, (cflag & PARENB) ? ((cflag & PARODD) ? 0x01 : 0x03)

commit 3d92e8f3ae9ba21cac30370eb254ed9dc20df043
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Feb 22 09:38:47 2009 +0100

    m68k: atari - Rename "mfp" to "st_mfp"
    
    http://kisskb.ellerman.id.au/kisskb/buildresult/72115/:
    | net/mac80211/ieee80211_i.h:327: error: syntax error before 'volatile'
    | net/mac80211/ieee80211_i.h:350: error: syntax error before '}' token
    | net/mac80211/ieee80211_i.h:455: error: field 'sta' has incomplete type
    | distcc[19430] ERROR: compile net/mac80211/main.c on sprygo/32 failed
    
    This is caused by
    
    | # define mfp ((*(volatile struct MFP*)MFP_BAS))
    
    in arch/m68k/include/asm/atarihw.h, which conflicts with the new "mfp" enum in
    net/mac80211/ieee80211_i.h.
    
    Rename "mfp" to "st_mfp", as it's a way too generic name for a global #define.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/debug.c b/arch/m68k/atari/debug.c
index 702b15ccfab7..28efdc33c1ae 100644
--- a/arch/m68k/atari/debug.c
+++ b/arch/m68k/atari/debug.c
@@ -34,9 +34,9 @@ static struct console atari_console_driver = {
 
 static inline void ata_mfp_out(char c)
 {
-	while (!(mfp.trn_stat & 0x80))	/* wait for tx buf empty */
+	while (!(st_mfp.trn_stat & 0x80))	/* wait for tx buf empty */
 		barrier();
-	mfp.usart_dta = c;
+	st_mfp.usart_dta = c;
 }
 
 static void atari_mfp_console_write(struct console *co, const char *str,
@@ -91,7 +91,7 @@ static int ata_par_out(char c)
 	/* This a some-seconds timeout in case no printer is connected */
 	unsigned long i = loops_per_jiffy > 1 ? loops_per_jiffy : 10000000/HZ;
 
-	while ((mfp.par_dt_reg & 1) && --i) /* wait for BUSY == L */
+	while ((st_mfp.par_dt_reg & 1) && --i) /* wait for BUSY == L */
 		;
 	if (!i)
 		return 0;
@@ -131,9 +131,9 @@ static void atari_par_console_write(struct console *co, const char *str,
 #if 0
 int atari_mfp_console_wait_key(struct console *co)
 {
-	while (!(mfp.rcv_stat & 0x80))	/* wait for rx buf filled */
+	while (!(st_mfp.rcv_stat & 0x80))	/* wait for rx buf filled */
 		barrier();
-	return mfp.usart_dta;
+	return st_mfp.usart_dta;
 }
 
 int atari_scc_console_wait_key(struct console *co)
@@ -175,12 +175,12 @@ static void __init atari_init_mfp_port(int cflag)
 		baud = B9600;		/* use default 9600bps for non-implemented rates */
 	baud -= B1200;			/* baud_table[] starts at 1200bps */
 
-	mfp.trn_stat &= ~0x01;		/* disable TX */
-	mfp.usart_ctr = parity | csize | 0x88; /* 1:16 clk mode, 1 stop bit */
-	mfp.tim_ct_cd &= 0x70;		/* stop timer D */
-	mfp.tim_dt_d = baud_table[baud];
-	mfp.tim_ct_cd |= 0x01;		/* start timer D, 1:4 */
-	mfp.trn_stat |= 0x01;		/* enable TX */
+	st_mfp.trn_stat &= ~0x01;	/* disable TX */
+	st_mfp.usart_ctr = parity | csize | 0x88; /* 1:16 clk mode, 1 stop bit */
+	st_mfp.tim_ct_cd &= 0x70;	/* stop timer D */
+	st_mfp.tim_dt_d = baud_table[baud];
+	st_mfp.tim_ct_cd |= 0x01;	/* start timer D, 1:4 */
+	st_mfp.trn_stat |= 0x01;	/* enable TX */
 }
 
 #define SCC_WRITE(reg, val)				\

commit 5575d0a3c9676b2886adad67dd4b2ac126a49f1f
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jul 17 21:16:24 2008 +0200

    m68k/atari/debug.c: possible cleanups
    
    This patch contains the following possible cleanups:
    - make the following needlessly global functions (always) static:
      - atari_mfp_console_write()
      - atari_scc_console_write()
      - atari_midi_console_write()
      - atari_init_mfp_port()
      - atari_init_scc_port()
      - atari_init_midi_port()
    - #if 0 the following unused functions:
      - atari_mfp_console_wait_key()
      - atari_scc_console_wait_key()
      - atari_midi_console_wait_key()
    - remove the following unused variables:
      - atari_MFP_init_done
      - atari_SCC_init_done
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/debug.c b/arch/m68k/atari/debug.c
index 043ddbc61c7b..702b15ccfab7 100644
--- a/arch/m68k/atari/debug.c
+++ b/arch/m68k/atari/debug.c
@@ -20,14 +20,6 @@
 #include <asm/atarihw.h>
 #include <asm/atariints.h>
 
-/* Flag that Modem1 port is already initialized and used */
-int atari_MFP_init_done;
-EXPORT_SYMBOL(atari_MFP_init_done);
-
-/* Flag that Modem1 port is already initialized and used */
-int atari_SCC_init_done;
-EXPORT_SYMBOL(atari_SCC_init_done);
-
 /* Can be set somewhere, if a SCC master reset has already be done and should
  * not be repeated; used by kgdb */
 int atari_SCC_reset_done;
@@ -47,8 +39,8 @@ static inline void ata_mfp_out(char c)
 	mfp.usart_dta = c;
 }
 
-void atari_mfp_console_write(struct console *co, const char *str,
-			     unsigned int count)
+static void atari_mfp_console_write(struct console *co, const char *str,
+				    unsigned int count)
 {
 	while (count--) {
 		if (*str == '\n')
@@ -66,8 +58,8 @@ static inline void ata_scc_out(char c)
 	scc.cha_b_data = c;
 }
 
-void atari_scc_console_write(struct console *co, const char *str,
-			     unsigned int count)
+static void atari_scc_console_write(struct console *co, const char *str,
+				    unsigned int count)
 {
 	while (count--) {
 		if (*str == '\n')
@@ -83,8 +75,8 @@ static inline void ata_midi_out(char c)
 	acia.mid_data = c;
 }
 
-void atari_midi_console_write(struct console *co, const char *str,
-			      unsigned int count)
+static void atari_midi_console_write(struct console *co, const char *str,
+				     unsigned int count)
 {
 	while (count--) {
 		if (*str == '\n')
@@ -136,7 +128,7 @@ static void atari_par_console_write(struct console *co, const char *str,
 	}
 }
 
-#ifdef CONFIG_SERIAL_CONSOLE
+#if 0
 int atari_mfp_console_wait_key(struct console *co)
 {
 	while (!(mfp.rcv_stat & 0x80))	/* wait for rx buf filled */
@@ -166,11 +158,7 @@ int atari_midi_console_wait_key(struct console *co)
  * SCC serial ports. They're used by the debugging interface, kgdb, and the
  * serial console code.
  */
-#ifndef CONFIG_SERIAL_CONSOLE
 static void __init atari_init_mfp_port(int cflag)
-#else
-void atari_init_mfp_port(int cflag)
-#endif
 {
 	/*
 	 * timer values for 1200...115200 bps; > 38400 select 110, 134, or 150
@@ -193,8 +181,6 @@ void atari_init_mfp_port(int cflag)
 	mfp.tim_dt_d = baud_table[baud];
 	mfp.tim_ct_cd |= 0x01;		/* start timer D, 1:4 */
 	mfp.trn_stat |= 0x01;		/* enable TX */
-
-	atari_MFP_init_done = 1;
 }
 
 #define SCC_WRITE(reg, val)				\
@@ -214,11 +200,7 @@ void atari_init_mfp_port(int cflag)
 			MFPDELAY();			\
 	} while (0)
 
-#ifndef CONFIG_SERIAL_CONSOLE
 static void __init atari_init_scc_port(int cflag)
-#else
-void atari_init_scc_port(int cflag)
-#endif
 {
 	extern int atari_SCC_reset_done;
 	static int clksrc_table[9] =
@@ -277,14 +259,9 @@ void atari_init_scc_port(int cflag)
 	SCC_WRITE(5, reg5 | 8);
 
 	atari_SCC_reset_done = 1;
-	atari_SCC_init_done = 1;
 }
 
-#ifndef CONFIG_SERIAL_CONSOLE
 static void __init atari_init_midi_port(int cflag)
-#else
-void atari_init_midi_port(int cflag)
-#endif
 {
 	int baud = cflag & CBAUD;
 	int csize = ((cflag & CSIZE) == CS8) ? 0x10 : 0x00;

commit a3b2004a2671455ee7aef1d9aee5a24381999ddb
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Feb 4 22:30:26 2008 -0800

    m68k: kill arch/m68k/atari/atari_ksyms.c
    
    EXPORT_SYMBOL's belong to the actual code.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/debug.c b/arch/m68k/atari/debug.c
index fbeed8c8ecbc..043ddbc61c7b 100644
--- a/arch/m68k/atari/debug.c
+++ b/arch/m68k/atari/debug.c
@@ -15,17 +15,23 @@
 #include <linux/console.h>
 #include <linux/init.h>
 #include <linux/delay.h>
+#include <linux/module.h>
 
 #include <asm/atarihw.h>
 #include <asm/atariints.h>
 
 /* Flag that Modem1 port is already initialized and used */
 int atari_MFP_init_done;
+EXPORT_SYMBOL(atari_MFP_init_done);
+
 /* Flag that Modem1 port is already initialized and used */
 int atari_SCC_init_done;
+EXPORT_SYMBOL(atari_SCC_init_done);
+
 /* Can be set somewhere, if a SCC master reset has already be done and should
  * not be repeated; used by kgdb */
 int atari_SCC_reset_done;
+EXPORT_SYMBOL(atari_SCC_reset_done);
 
 static struct console atari_console_driver = {
 	.name	= "debug",

commit d6713b4091a99fa2af2fabdcd2f3fb97f32ecf2e
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue May 1 22:32:45 2007 +0200

    m68k: early parameter support
    
    Add early parameter support and convert current users to it.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/debug.c b/arch/m68k/atari/debug.c
index 66983fe87509..fbeed8c8ecbc 100644
--- a/arch/m68k/atari/debug.c
+++ b/arch/m68k/atari/debug.c
@@ -19,8 +19,6 @@
 #include <asm/atarihw.h>
 #include <asm/atariints.h>
 
-extern char m68k_debug_device[];
-
 /* Flag that Modem1 port is already initialized and used */
 int atari_MFP_init_done;
 /* Flag that Modem1 port is already initialized and used */
@@ -305,26 +303,28 @@ void atari_init_midi_port(int cflag)
 		     ACIA_RHTID : ACIA_RLTID);
 }
 
-void __init atari_debug_init(void)
+static int __init atari_debug_setup(char *arg)
 {
-	if (!strcmp(m68k_debug_device, "ser")) {
+	if (!MACH_IS_ATARI)
+		return 0;
+
+	if (!strcmp(arg, "ser"))
 		/* defaults to ser2 for a Falcon and ser1 otherwise */
-		strcpy(m68k_debug_device, MACH_IS_FALCON ? "ser2" : "ser1");
-	}
+		arg = MACH_IS_FALCON ? "ser2" : "ser1";
 
-	if (!strcmp(m68k_debug_device, "ser1")) {
+	if (!strcmp(arg, "ser1")) {
 		/* ST-MFP Modem1 serial port */
 		atari_init_mfp_port(B9600|CS8);
 		atari_console_driver.write = atari_mfp_console_write;
-	} else if (!strcmp(m68k_debug_device, "ser2")) {
+	} else if (!strcmp(arg, "ser2")) {
 		/* SCC Modem2 serial port */
 		atari_init_scc_port(B9600|CS8);
 		atari_console_driver.write = atari_scc_console_write;
-	} else if (!strcmp(m68k_debug_device, "midi")) {
+	} else if (!strcmp(arg, "midi")) {
 		/* MIDI port */
 		atari_init_midi_port(B9600|CS8);
 		atari_console_driver.write = atari_midi_console_write;
-	} else if (!strcmp(m68k_debug_device, "par")) {
+	} else if (!strcmp(arg, "par")) {
 		/* parallel printer */
 		atari_turnoff_irq(IRQ_MFP_BUSY); /* avoid ints */
 		sound_ym.rd_data_reg_sel = 7;	/* select mixer control */
@@ -337,4 +337,8 @@ void __init atari_debug_init(void)
 	}
 	if (atari_console_driver.write)
 		register_console(&atari_console_driver);
+
+	return 0;
 }
+
+early_param("debug", atari_debug_setup);

commit 6ff5801acbb643e81d3420ac0f37c96089309063
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue May 1 22:32:43 2007 +0200

    m68k: reformat various m68k files
    
    Reformat various m68k files, so they actually look like Linux sources.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/atari/debug.c b/arch/m68k/atari/debug.c
index 4ae01004d8dd..66983fe87509 100644
--- a/arch/m68k/atari/debug.c
+++ b/arch/m68k/atari/debug.c
@@ -30,317 +30,311 @@ int atari_SCC_init_done;
 int atari_SCC_reset_done;
 
 static struct console atari_console_driver = {
-	.name =		"debug",
-	.flags =	CON_PRINTBUFFER,
-	.index =	-1,
+	.name	= "debug",
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
 };
 
 
-static inline void ata_mfp_out (char c)
+static inline void ata_mfp_out(char c)
 {
-    while (!(mfp.trn_stat & 0x80)) /* wait for tx buf empty */
-	barrier ();
-    mfp.usart_dta = c;
+	while (!(mfp.trn_stat & 0x80))	/* wait for tx buf empty */
+		barrier();
+	mfp.usart_dta = c;
 }
 
-void atari_mfp_console_write (struct console *co, const char *str,
-			      unsigned int count)
+void atari_mfp_console_write(struct console *co, const char *str,
+			     unsigned int count)
 {
-    while (count--) {
-	if (*str == '\n')
-	    ata_mfp_out( '\r' );
-	ata_mfp_out( *str++ );
-    }
+	while (count--) {
+		if (*str == '\n')
+			ata_mfp_out('\r');
+		ata_mfp_out(*str++);
+	}
 }
 
-static inline void ata_scc_out (char c)
+static inline void ata_scc_out(char c)
 {
-    do {
+	do {
+		MFPDELAY();
+	} while (!(scc.cha_b_ctrl & 0x04)); /* wait for tx buf empty */
 	MFPDELAY();
-    } while (!(scc.cha_b_ctrl & 0x04)); /* wait for tx buf empty */
-    MFPDELAY();
-    scc.cha_b_data = c;
+	scc.cha_b_data = c;
 }
 
-void atari_scc_console_write (struct console *co, const char *str,
-			      unsigned int count)
+void atari_scc_console_write(struct console *co, const char *str,
+			     unsigned int count)
 {
-    while (count--) {
-	if (*str == '\n')
-	    ata_scc_out( '\r' );
-	ata_scc_out( *str++ );
-    }
+	while (count--) {
+		if (*str == '\n')
+			ata_scc_out('\r');
+		ata_scc_out(*str++);
+	}
 }
 
-static inline void ata_midi_out (char c)
+static inline void ata_midi_out(char c)
 {
-    while (!(acia.mid_ctrl & ACIA_TDRE)) /* wait for tx buf empty */
-	barrier ();
-    acia.mid_data = c;
+	while (!(acia.mid_ctrl & ACIA_TDRE))	/* wait for tx buf empty */
+		barrier();
+	acia.mid_data = c;
 }
 
-void atari_midi_console_write (struct console *co, const char *str,
-			       unsigned int count)
+void atari_midi_console_write(struct console *co, const char *str,
+			      unsigned int count)
 {
-    while (count--) {
-	if (*str == '\n')
-	    ata_midi_out( '\r' );
-	ata_midi_out( *str++ );
-    }
+	while (count--) {
+		if (*str == '\n')
+			ata_midi_out('\r');
+		ata_midi_out(*str++);
+	}
 }
 
-static int ata_par_out (char c)
+static int ata_par_out(char c)
 {
-    unsigned char tmp;
-    /* This a some-seconds timeout in case no printer is connected */
-    unsigned long i = loops_per_jiffy > 1 ? loops_per_jiffy : 10000000/HZ;
-
-    while( (mfp.par_dt_reg & 1) && --i ) /* wait for BUSY == L */
-	;
-    if (!i) return( 0 );
-
-    sound_ym.rd_data_reg_sel = 15;  /* select port B */
-    sound_ym.wd_data = c;           /* put char onto port */
-    sound_ym.rd_data_reg_sel = 14;  /* select port A */
-    tmp = sound_ym.rd_data_reg_sel;
-    sound_ym.wd_data = tmp & ~0x20; /* set strobe L */
-    MFPDELAY();                     /* wait a bit */
-    sound_ym.wd_data = tmp | 0x20;  /* set strobe H */
-    return( 1 );
+	unsigned char tmp;
+	/* This a some-seconds timeout in case no printer is connected */
+	unsigned long i = loops_per_jiffy > 1 ? loops_per_jiffy : 10000000/HZ;
+
+	while ((mfp.par_dt_reg & 1) && --i) /* wait for BUSY == L */
+		;
+	if (!i)
+		return 0;
+
+	sound_ym.rd_data_reg_sel = 15;	/* select port B */
+	sound_ym.wd_data = c;		/* put char onto port */
+	sound_ym.rd_data_reg_sel = 14;	/* select port A */
+	tmp = sound_ym.rd_data_reg_sel;
+	sound_ym.wd_data = tmp & ~0x20;	/* set strobe L */
+	MFPDELAY();			/* wait a bit */
+	sound_ym.wd_data = tmp | 0x20;	/* set strobe H */
+	return 1;
 }
 
-static void atari_par_console_write (struct console *co, const char *str,
-				     unsigned int count)
+static void atari_par_console_write(struct console *co, const char *str,
+				    unsigned int count)
 {
-    static int printer_present = 1;
-
-    if (!printer_present)
-	return;
+	static int printer_present = 1;
 
-    while (count--) {
-	if (*str == '\n')
-	    if (!ata_par_out( '\r' )) {
-		printer_present = 0;
+	if (!printer_present)
 		return;
-	    }
-	if (!ata_par_out( *str++ )) {
-	    printer_present = 0;
-	    return;
+
+	while (count--) {
+		if (*str == '\n') {
+			if (!ata_par_out('\r')) {
+				printer_present = 0;
+				return;
+			}
+		}
+		if (!ata_par_out(*str++)) {
+			printer_present = 0;
+			return;
+		}
 	}
-    }
 }
 
 #ifdef CONFIG_SERIAL_CONSOLE
 int atari_mfp_console_wait_key(struct console *co)
 {
-    while( !(mfp.rcv_stat & 0x80) ) /* wait for rx buf filled */
-	barrier();
-    return( mfp.usart_dta );
+	while (!(mfp.rcv_stat & 0x80))	/* wait for rx buf filled */
+		barrier();
+	return mfp.usart_dta;
 }
 
 int atari_scc_console_wait_key(struct console *co)
 {
-    do {
+	do {
+		MFPDELAY();
+	} while (!(scc.cha_b_ctrl & 0x01)); /* wait for rx buf filled */
 	MFPDELAY();
-    } while( !(scc.cha_b_ctrl & 0x01) ); /* wait for rx buf filled */
-    MFPDELAY();
-    return( scc.cha_b_data );
+	return scc.cha_b_data;
 }
 
 int atari_midi_console_wait_key(struct console *co)
 {
-    while( !(acia.mid_ctrl & ACIA_RDRF) ) /* wait for rx buf filled */
-	barrier();
-    return( acia.mid_data );
+	while (!(acia.mid_ctrl & ACIA_RDRF)) /* wait for rx buf filled */
+		barrier();
+	return acia.mid_data;
 }
 #endif
 
-/* The following two functions do a quick'n'dirty initialization of the MFP or
+/*
+ * The following two functions do a quick'n'dirty initialization of the MFP or
  * SCC serial ports. They're used by the debugging interface, kgdb, and the
- * serial console code. */
+ * serial console code.
+ */
 #ifndef CONFIG_SERIAL_CONSOLE
-static void __init atari_init_mfp_port( int cflag )
+static void __init atari_init_mfp_port(int cflag)
 #else
-void atari_init_mfp_port( int cflag )
+void atari_init_mfp_port(int cflag)
 #endif
 {
-    /* timer values for 1200...115200 bps; > 38400 select 110, 134, or 150
-     * bps, resp., and work only correct if there's a RSVE or RSSPEED */
-    static int baud_table[9] = { 16, 11, 8, 4, 2, 1, 175, 143, 128 };
-    int baud = cflag & CBAUD;
-    int parity = (cflag & PARENB) ? ((cflag & PARODD) ? 0x04 : 0x06) : 0;
-    int csize = ((cflag & CSIZE) == CS7) ? 0x20 : 0x00;
-
-    if (cflag & CBAUDEX)
-	baud += B38400;
-    if (baud < B1200 || baud > B38400+2)
-	baud = B9600; /* use default 9600bps for non-implemented rates */
-    baud -= B1200; /* baud_table[] starts at 1200bps */
-
-    mfp.trn_stat &= ~0x01; /* disable TX */
-    mfp.usart_ctr = parity | csize | 0x88; /* 1:16 clk mode, 1 stop bit */
-    mfp.tim_ct_cd &= 0x70;  /* stop timer D */
-    mfp.tim_dt_d = baud_table[baud];
-    mfp.tim_ct_cd |= 0x01;  /* start timer D, 1:4 */
-    mfp.trn_stat |= 0x01;  /* enable TX */
-
-    atari_MFP_init_done = 1;
+	/*
+	 * timer values for 1200...115200 bps; > 38400 select 110, 134, or 150
+	 * bps, resp., and work only correct if there's a RSVE or RSSPEED
+	 */
+	static int baud_table[9] = { 16, 11, 8, 4, 2, 1, 175, 143, 128 };
+	int baud = cflag & CBAUD;
+	int parity = (cflag & PARENB) ? ((cflag & PARODD) ? 0x04 : 0x06) : 0;
+	int csize = ((cflag & CSIZE) == CS7) ? 0x20 : 0x00;
+
+	if (cflag & CBAUDEX)
+		baud += B38400;
+	if (baud < B1200 || baud > B38400+2)
+		baud = B9600;		/* use default 9600bps for non-implemented rates */
+	baud -= B1200;			/* baud_table[] starts at 1200bps */
+
+	mfp.trn_stat &= ~0x01;		/* disable TX */
+	mfp.usart_ctr = parity | csize | 0x88; /* 1:16 clk mode, 1 stop bit */
+	mfp.tim_ct_cd &= 0x70;		/* stop timer D */
+	mfp.tim_dt_d = baud_table[baud];
+	mfp.tim_ct_cd |= 0x01;		/* start timer D, 1:4 */
+	mfp.trn_stat |= 0x01;		/* enable TX */
+
+	atari_MFP_init_done = 1;
 }
 
-#define SCC_WRITE(reg,val)				\
-    do {						\
-	scc.cha_b_ctrl = (reg);				\
-	MFPDELAY();					\
-	scc.cha_b_ctrl = (val);				\
-	MFPDELAY();					\
-    } while(0)
+#define SCC_WRITE(reg, val)				\
+	do {						\
+		scc.cha_b_ctrl = (reg);			\
+		MFPDELAY();				\
+		scc.cha_b_ctrl = (val);			\
+		MFPDELAY();				\
+	} while (0)
 
 /* loops_per_jiffy isn't initialized yet, so we can't use udelay(). This does a
  * delay of ~ 60us. */
-#define LONG_DELAY()				\
-    do {					\
-	int i;					\
-	for( i = 100; i > 0; --i )		\
-	    MFPDELAY();				\
-    } while(0)
+#define LONG_DELAY()					\
+	do {						\
+		int i;					\
+		for (i = 100; i > 0; --i)		\
+			MFPDELAY();			\
+	} while (0)
 
 #ifndef CONFIG_SERIAL_CONSOLE
-static void __init atari_init_scc_port( int cflag )
+static void __init atari_init_scc_port(int cflag)
 #else
-void atari_init_scc_port( int cflag )
+void atari_init_scc_port(int cflag)
 #endif
 {
-    extern int atari_SCC_reset_done;
-    static int clksrc_table[9] =
-	/* reg 11: 0x50 = BRG, 0x00 = RTxC, 0x28 = TRxC */
-	{ 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x00, 0x00 };
-    static int brgsrc_table[9] =
-	/* reg 14: 0 = RTxC, 2 = PCLK */
-	{ 2, 2, 2, 2, 2, 2, 0, 2, 2 };
-    static int clkmode_table[9] =
-	/* reg 4: 0x40 = x16, 0x80 = x32, 0xc0 = x64 */
-	{ 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xc0, 0x80 };
-    static int div_table[9] =
-	/* reg12 (BRG low) */
-	{ 208, 138, 103, 50, 24, 11, 1, 0, 0 };
-
-    int baud = cflag & CBAUD;
-    int clksrc, clkmode, div, reg3, reg5;
-
-    if (cflag & CBAUDEX)
-	baud += B38400;
-    if (baud < B1200 || baud > B38400+2)
-	baud = B9600; /* use default 9600bps for non-implemented rates */
-    baud -= B1200; /* tables starts at 1200bps */
-
-    clksrc  = clksrc_table[baud];
-    clkmode = clkmode_table[baud];
-    div     = div_table[baud];
-    if (ATARIHW_PRESENT(TT_MFP) && baud >= 6) {
-	/* special treatment for TT, where rates >= 38400 are done via TRxC */
-	clksrc = 0x28; /* TRxC */
-	clkmode = baud == 6 ? 0xc0 :
-		  baud == 7 ? 0x80 : /* really 76800bps */
-			      0x40;  /* really 153600bps */
-	div = 0;
-    }
-
-    reg3 = (cflag & CSIZE) == CS8 ? 0xc0 : 0x40;
-    reg5 = (cflag & CSIZE) == CS8 ? 0x60 : 0x20 | 0x82 /* assert DTR/RTS */;
-
-    (void)scc.cha_b_ctrl;	/* reset reg pointer */
-    SCC_WRITE( 9, 0xc0 );	/* reset */
-    LONG_DELAY();		/* extra delay after WR9 access */
-    SCC_WRITE( 4, (cflag & PARENB) ? ((cflag & PARODD) ? 0x01 : 0x03) : 0 |
-		  0x04 /* 1 stopbit */ |
-		  clkmode );
-    SCC_WRITE( 3, reg3 );
-    SCC_WRITE( 5, reg5 );
-    SCC_WRITE( 9, 0 );		/* no interrupts */
-    LONG_DELAY();		/* extra delay after WR9 access */
-    SCC_WRITE( 10, 0 );		/* NRZ mode */
-    SCC_WRITE( 11, clksrc );	/* main clock source */
-    SCC_WRITE( 12, div );	/* BRG value */
-    SCC_WRITE( 13, 0 );		/* BRG high byte */
-    SCC_WRITE( 14, brgsrc_table[baud] );
-    SCC_WRITE( 14, brgsrc_table[baud] | (div ? 1 : 0) );
-    SCC_WRITE( 3, reg3 | 1 );
-    SCC_WRITE( 5, reg5 | 8 );
-
-    atari_SCC_reset_done = 1;
-    atari_SCC_init_done = 1;
+	extern int atari_SCC_reset_done;
+	static int clksrc_table[9] =
+		/* reg 11: 0x50 = BRG, 0x00 = RTxC, 0x28 = TRxC */
+		{ 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x00, 0x00 };
+	static int brgsrc_table[9] =
+		/* reg 14: 0 = RTxC, 2 = PCLK */
+		{ 2, 2, 2, 2, 2, 2, 0, 2, 2 };
+	static int clkmode_table[9] =
+		/* reg 4: 0x40 = x16, 0x80 = x32, 0xc0 = x64 */
+		{ 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xc0, 0x80 };
+	static int div_table[9] =
+		/* reg12 (BRG low) */
+		{ 208, 138, 103, 50, 24, 11, 1, 0, 0 };
+
+	int baud = cflag & CBAUD;
+	int clksrc, clkmode, div, reg3, reg5;
+
+	if (cflag & CBAUDEX)
+		baud += B38400;
+	if (baud < B1200 || baud > B38400+2)
+		baud = B9600;		/* use default 9600bps for non-implemented rates */
+	baud -= B1200;			/* tables starts at 1200bps */
+
+	clksrc  = clksrc_table[baud];
+	clkmode = clkmode_table[baud];
+	div     = div_table[baud];
+	if (ATARIHW_PRESENT(TT_MFP) && baud >= 6) {
+		/* special treatment for TT, where rates >= 38400 are done via TRxC */
+		clksrc = 0x28;		/* TRxC */
+		clkmode = baud == 6 ? 0xc0 :
+			  baud == 7 ? 0x80 : /* really 76800bps */
+				      0x40;  /* really 153600bps */
+		div = 0;
+	}
+
+	reg3 = (cflag & CSIZE) == CS8 ? 0xc0 : 0x40;
+	reg5 = (cflag & CSIZE) == CS8 ? 0x60 : 0x20 | 0x82 /* assert DTR/RTS */;
+
+	(void)scc.cha_b_ctrl;		/* reset reg pointer */
+	SCC_WRITE(9, 0xc0);		/* reset */
+	LONG_DELAY();			/* extra delay after WR9 access */
+	SCC_WRITE(4, (cflag & PARENB) ? ((cflag & PARODD) ? 0x01 : 0x03)
+				      : 0 | 0x04 /* 1 stopbit */ | clkmode);
+	SCC_WRITE(3, reg3);
+	SCC_WRITE(5, reg5);
+	SCC_WRITE(9, 0);		/* no interrupts */
+	LONG_DELAY();			/* extra delay after WR9 access */
+	SCC_WRITE(10, 0);		/* NRZ mode */
+	SCC_WRITE(11, clksrc);		/* main clock source */
+	SCC_WRITE(12, div);		/* BRG value */
+	SCC_WRITE(13, 0);		/* BRG high byte */
+	SCC_WRITE(14, brgsrc_table[baud]);
+	SCC_WRITE(14, brgsrc_table[baud] | (div ? 1 : 0));
+	SCC_WRITE(3, reg3 | 1);
+	SCC_WRITE(5, reg5 | 8);
+
+	atari_SCC_reset_done = 1;
+	atari_SCC_init_done = 1;
 }
 
 #ifndef CONFIG_SERIAL_CONSOLE
-static void __init atari_init_midi_port( int cflag )
+static void __init atari_init_midi_port(int cflag)
 #else
-void atari_init_midi_port( int cflag )
+void atari_init_midi_port(int cflag)
 #endif
 {
-    int baud = cflag & CBAUD;
-    int csize = ((cflag & CSIZE) == CS8) ? 0x10 : 0x00;
-    /* warning 7N1 isn't possible! (instead 7O2 is used...) */
-    int parity = (cflag & PARENB) ? ((cflag & PARODD) ? 0x0c : 0x08) : 0x04;
-    int div;
-
-    /* 4800 selects 7812.5, 115200 selects 500000, all other (incl. 9600 as
-     * default) the standard MIDI speed 31250. */
-    if (cflag & CBAUDEX)
-	baud += B38400;
-    if (baud == B4800)
-	div = ACIA_DIV64; /* really 7812.5 bps */
-    else if (baud == B38400+2 /* 115200 */)
-	div = ACIA_DIV1; /* really 500 kbps (does that work??) */
-    else
-	div = ACIA_DIV16; /* 31250 bps, standard for MIDI */
-
-    /* RTS low, ints disabled */
-    acia.mid_ctrl = div | csize | parity |
+	int baud = cflag & CBAUD;
+	int csize = ((cflag & CSIZE) == CS8) ? 0x10 : 0x00;
+	/* warning 7N1 isn't possible! (instead 7O2 is used...) */
+	int parity = (cflag & PARENB) ? ((cflag & PARODD) ? 0x0c : 0x08) : 0x04;
+	int div;
+
+	/* 4800 selects 7812.5, 115200 selects 500000, all other (incl. 9600 as
+	 * default) the standard MIDI speed 31250. */
+	if (cflag & CBAUDEX)
+		baud += B38400;
+	if (baud == B4800)
+		div = ACIA_DIV64;	/* really 7812.5 bps */
+	else if (baud == B38400+2 /* 115200 */)
+		div = ACIA_DIV1;	/* really 500 kbps (does that work??) */
+	else
+		div = ACIA_DIV16;	/* 31250 bps, standard for MIDI */
+
+	/* RTS low, ints disabled */
+	acia.mid_ctrl = div | csize | parity |
 		    ((atari_switches & ATARI_SWITCH_MIDI) ?
 		     ACIA_RHTID : ACIA_RLTID);
 }
 
 void __init atari_debug_init(void)
 {
-    if (!strcmp( m68k_debug_device, "ser" )) {
-	/* defaults to ser2 for a Falcon and ser1 otherwise */
-	strcpy( m68k_debug_device, MACH_IS_FALCON ? "ser2" : "ser1" );
-
-    }
-
-    if (!strcmp( m68k_debug_device, "ser1" )) {
-	/* ST-MFP Modem1 serial port */
-	atari_init_mfp_port( B9600|CS8 );
-	atari_console_driver.write = atari_mfp_console_write;
-    }
-    else if (!strcmp( m68k_debug_device, "ser2" )) {
-	/* SCC Modem2 serial port */
-	atari_init_scc_port( B9600|CS8 );
-	atari_console_driver.write = atari_scc_console_write;
-    }
-    else if (!strcmp( m68k_debug_device, "midi" )) {
-	/* MIDI port */
-	atari_init_midi_port( B9600|CS8 );
-	atari_console_driver.write = atari_midi_console_write;
-    }
-    else if (!strcmp( m68k_debug_device, "par" )) {
-	/* parallel printer */
-	atari_turnoff_irq( IRQ_MFP_BUSY ); /* avoid ints */
-	sound_ym.rd_data_reg_sel = 7;  /* select mixer control */
-	sound_ym.wd_data = 0xff;       /* sound off, ports are output */
-	sound_ym.rd_data_reg_sel = 15; /* select port B */
-	sound_ym.wd_data = 0;          /* no char */
-	sound_ym.rd_data_reg_sel = 14; /* select port A */
-	sound_ym.wd_data = sound_ym.rd_data_reg_sel | 0x20; /* strobe H */
-	atari_console_driver.write = atari_par_console_write;
-    }
-    if (atari_console_driver.write)
-	register_console(&atari_console_driver);
-}
+	if (!strcmp(m68k_debug_device, "ser")) {
+		/* defaults to ser2 for a Falcon and ser1 otherwise */
+		strcpy(m68k_debug_device, MACH_IS_FALCON ? "ser2" : "ser1");
+	}
 
-/*
- * Local variables:
- *  c-indent-level: 4
- *  tab-width: 8
- * End:
- */
+	if (!strcmp(m68k_debug_device, "ser1")) {
+		/* ST-MFP Modem1 serial port */
+		atari_init_mfp_port(B9600|CS8);
+		atari_console_driver.write = atari_mfp_console_write;
+	} else if (!strcmp(m68k_debug_device, "ser2")) {
+		/* SCC Modem2 serial port */
+		atari_init_scc_port(B9600|CS8);
+		atari_console_driver.write = atari_scc_console_write;
+	} else if (!strcmp(m68k_debug_device, "midi")) {
+		/* MIDI port */
+		atari_init_midi_port(B9600|CS8);
+		atari_console_driver.write = atari_midi_console_write;
+	} else if (!strcmp(m68k_debug_device, "par")) {
+		/* parallel printer */
+		atari_turnoff_irq(IRQ_MFP_BUSY); /* avoid ints */
+		sound_ym.rd_data_reg_sel = 7;	/* select mixer control */
+		sound_ym.wd_data = 0xff;	/* sound off, ports are output */
+		sound_ym.rd_data_reg_sel = 15;	/* select port B */
+		sound_ym.wd_data = 0;		/* no char */
+		sound_ym.rd_data_reg_sel = 14;	/* select port A */
+		sound_ym.wd_data = sound_ym.rd_data_reg_sel | 0x20; /* strobe H */
+		atari_console_driver.write = atari_par_console_write;
+	}
+	if (atari_console_driver.write)
+		register_console(&atari_console_driver);
+}

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/m68k/atari/debug.c b/arch/m68k/atari/debug.c
index ace05f79d968..4ae01004d8dd 100644
--- a/arch/m68k/atari/debug.c
+++ b/arch/m68k/atari/debug.c
@@ -10,7 +10,6 @@
  * for more details.
  */
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/tty.h>
 #include <linux/console.h>

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/atari/debug.c b/arch/m68k/atari/debug.c
new file mode 100644
index 000000000000..ace05f79d968
--- /dev/null
+++ b/arch/m68k/atari/debug.c
@@ -0,0 +1,347 @@
+/*
+ * linux/arch/m68k/atari/debug.c
+ *
+ * Atari debugging and serial console stuff
+ *
+ * Assembled of parts of former atari/config.c 97-12-18 by Roman Hodek
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/tty.h>
+#include <linux/console.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+
+#include <asm/atarihw.h>
+#include <asm/atariints.h>
+
+extern char m68k_debug_device[];
+
+/* Flag that Modem1 port is already initialized and used */
+int atari_MFP_init_done;
+/* Flag that Modem1 port is already initialized and used */
+int atari_SCC_init_done;
+/* Can be set somewhere, if a SCC master reset has already be done and should
+ * not be repeated; used by kgdb */
+int atari_SCC_reset_done;
+
+static struct console atari_console_driver = {
+	.name =		"debug",
+	.flags =	CON_PRINTBUFFER,
+	.index =	-1,
+};
+
+
+static inline void ata_mfp_out (char c)
+{
+    while (!(mfp.trn_stat & 0x80)) /* wait for tx buf empty */
+	barrier ();
+    mfp.usart_dta = c;
+}
+
+void atari_mfp_console_write (struct console *co, const char *str,
+			      unsigned int count)
+{
+    while (count--) {
+	if (*str == '\n')
+	    ata_mfp_out( '\r' );
+	ata_mfp_out( *str++ );
+    }
+}
+
+static inline void ata_scc_out (char c)
+{
+    do {
+	MFPDELAY();
+    } while (!(scc.cha_b_ctrl & 0x04)); /* wait for tx buf empty */
+    MFPDELAY();
+    scc.cha_b_data = c;
+}
+
+void atari_scc_console_write (struct console *co, const char *str,
+			      unsigned int count)
+{
+    while (count--) {
+	if (*str == '\n')
+	    ata_scc_out( '\r' );
+	ata_scc_out( *str++ );
+    }
+}
+
+static inline void ata_midi_out (char c)
+{
+    while (!(acia.mid_ctrl & ACIA_TDRE)) /* wait for tx buf empty */
+	barrier ();
+    acia.mid_data = c;
+}
+
+void atari_midi_console_write (struct console *co, const char *str,
+			       unsigned int count)
+{
+    while (count--) {
+	if (*str == '\n')
+	    ata_midi_out( '\r' );
+	ata_midi_out( *str++ );
+    }
+}
+
+static int ata_par_out (char c)
+{
+    unsigned char tmp;
+    /* This a some-seconds timeout in case no printer is connected */
+    unsigned long i = loops_per_jiffy > 1 ? loops_per_jiffy : 10000000/HZ;
+
+    while( (mfp.par_dt_reg & 1) && --i ) /* wait for BUSY == L */
+	;
+    if (!i) return( 0 );
+
+    sound_ym.rd_data_reg_sel = 15;  /* select port B */
+    sound_ym.wd_data = c;           /* put char onto port */
+    sound_ym.rd_data_reg_sel = 14;  /* select port A */
+    tmp = sound_ym.rd_data_reg_sel;
+    sound_ym.wd_data = tmp & ~0x20; /* set strobe L */
+    MFPDELAY();                     /* wait a bit */
+    sound_ym.wd_data = tmp | 0x20;  /* set strobe H */
+    return( 1 );
+}
+
+static void atari_par_console_write (struct console *co, const char *str,
+				     unsigned int count)
+{
+    static int printer_present = 1;
+
+    if (!printer_present)
+	return;
+
+    while (count--) {
+	if (*str == '\n')
+	    if (!ata_par_out( '\r' )) {
+		printer_present = 0;
+		return;
+	    }
+	if (!ata_par_out( *str++ )) {
+	    printer_present = 0;
+	    return;
+	}
+    }
+}
+
+#ifdef CONFIG_SERIAL_CONSOLE
+int atari_mfp_console_wait_key(struct console *co)
+{
+    while( !(mfp.rcv_stat & 0x80) ) /* wait for rx buf filled */
+	barrier();
+    return( mfp.usart_dta );
+}
+
+int atari_scc_console_wait_key(struct console *co)
+{
+    do {
+	MFPDELAY();
+    } while( !(scc.cha_b_ctrl & 0x01) ); /* wait for rx buf filled */
+    MFPDELAY();
+    return( scc.cha_b_data );
+}
+
+int atari_midi_console_wait_key(struct console *co)
+{
+    while( !(acia.mid_ctrl & ACIA_RDRF) ) /* wait for rx buf filled */
+	barrier();
+    return( acia.mid_data );
+}
+#endif
+
+/* The following two functions do a quick'n'dirty initialization of the MFP or
+ * SCC serial ports. They're used by the debugging interface, kgdb, and the
+ * serial console code. */
+#ifndef CONFIG_SERIAL_CONSOLE
+static void __init atari_init_mfp_port( int cflag )
+#else
+void atari_init_mfp_port( int cflag )
+#endif
+{
+    /* timer values for 1200...115200 bps; > 38400 select 110, 134, or 150
+     * bps, resp., and work only correct if there's a RSVE or RSSPEED */
+    static int baud_table[9] = { 16, 11, 8, 4, 2, 1, 175, 143, 128 };
+    int baud = cflag & CBAUD;
+    int parity = (cflag & PARENB) ? ((cflag & PARODD) ? 0x04 : 0x06) : 0;
+    int csize = ((cflag & CSIZE) == CS7) ? 0x20 : 0x00;
+
+    if (cflag & CBAUDEX)
+	baud += B38400;
+    if (baud < B1200 || baud > B38400+2)
+	baud = B9600; /* use default 9600bps for non-implemented rates */
+    baud -= B1200; /* baud_table[] starts at 1200bps */
+
+    mfp.trn_stat &= ~0x01; /* disable TX */
+    mfp.usart_ctr = parity | csize | 0x88; /* 1:16 clk mode, 1 stop bit */
+    mfp.tim_ct_cd &= 0x70;  /* stop timer D */
+    mfp.tim_dt_d = baud_table[baud];
+    mfp.tim_ct_cd |= 0x01;  /* start timer D, 1:4 */
+    mfp.trn_stat |= 0x01;  /* enable TX */
+
+    atari_MFP_init_done = 1;
+}
+
+#define SCC_WRITE(reg,val)				\
+    do {						\
+	scc.cha_b_ctrl = (reg);				\
+	MFPDELAY();					\
+	scc.cha_b_ctrl = (val);				\
+	MFPDELAY();					\
+    } while(0)
+
+/* loops_per_jiffy isn't initialized yet, so we can't use udelay(). This does a
+ * delay of ~ 60us. */
+#define LONG_DELAY()				\
+    do {					\
+	int i;					\
+	for( i = 100; i > 0; --i )		\
+	    MFPDELAY();				\
+    } while(0)
+
+#ifndef CONFIG_SERIAL_CONSOLE
+static void __init atari_init_scc_port( int cflag )
+#else
+void atari_init_scc_port( int cflag )
+#endif
+{
+    extern int atari_SCC_reset_done;
+    static int clksrc_table[9] =
+	/* reg 11: 0x50 = BRG, 0x00 = RTxC, 0x28 = TRxC */
+	{ 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x00, 0x00 };
+    static int brgsrc_table[9] =
+	/* reg 14: 0 = RTxC, 2 = PCLK */
+	{ 2, 2, 2, 2, 2, 2, 0, 2, 2 };
+    static int clkmode_table[9] =
+	/* reg 4: 0x40 = x16, 0x80 = x32, 0xc0 = x64 */
+	{ 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0xc0, 0x80 };
+    static int div_table[9] =
+	/* reg12 (BRG low) */
+	{ 208, 138, 103, 50, 24, 11, 1, 0, 0 };
+
+    int baud = cflag & CBAUD;
+    int clksrc, clkmode, div, reg3, reg5;
+
+    if (cflag & CBAUDEX)
+	baud += B38400;
+    if (baud < B1200 || baud > B38400+2)
+	baud = B9600; /* use default 9600bps for non-implemented rates */
+    baud -= B1200; /* tables starts at 1200bps */
+
+    clksrc  = clksrc_table[baud];
+    clkmode = clkmode_table[baud];
+    div     = div_table[baud];
+    if (ATARIHW_PRESENT(TT_MFP) && baud >= 6) {
+	/* special treatment for TT, where rates >= 38400 are done via TRxC */
+	clksrc = 0x28; /* TRxC */
+	clkmode = baud == 6 ? 0xc0 :
+		  baud == 7 ? 0x80 : /* really 76800bps */
+			      0x40;  /* really 153600bps */
+	div = 0;
+    }
+
+    reg3 = (cflag & CSIZE) == CS8 ? 0xc0 : 0x40;
+    reg5 = (cflag & CSIZE) == CS8 ? 0x60 : 0x20 | 0x82 /* assert DTR/RTS */;
+
+    (void)scc.cha_b_ctrl;	/* reset reg pointer */
+    SCC_WRITE( 9, 0xc0 );	/* reset */
+    LONG_DELAY();		/* extra delay after WR9 access */
+    SCC_WRITE( 4, (cflag & PARENB) ? ((cflag & PARODD) ? 0x01 : 0x03) : 0 |
+		  0x04 /* 1 stopbit */ |
+		  clkmode );
+    SCC_WRITE( 3, reg3 );
+    SCC_WRITE( 5, reg5 );
+    SCC_WRITE( 9, 0 );		/* no interrupts */
+    LONG_DELAY();		/* extra delay after WR9 access */
+    SCC_WRITE( 10, 0 );		/* NRZ mode */
+    SCC_WRITE( 11, clksrc );	/* main clock source */
+    SCC_WRITE( 12, div );	/* BRG value */
+    SCC_WRITE( 13, 0 );		/* BRG high byte */
+    SCC_WRITE( 14, brgsrc_table[baud] );
+    SCC_WRITE( 14, brgsrc_table[baud] | (div ? 1 : 0) );
+    SCC_WRITE( 3, reg3 | 1 );
+    SCC_WRITE( 5, reg5 | 8 );
+
+    atari_SCC_reset_done = 1;
+    atari_SCC_init_done = 1;
+}
+
+#ifndef CONFIG_SERIAL_CONSOLE
+static void __init atari_init_midi_port( int cflag )
+#else
+void atari_init_midi_port( int cflag )
+#endif
+{
+    int baud = cflag & CBAUD;
+    int csize = ((cflag & CSIZE) == CS8) ? 0x10 : 0x00;
+    /* warning 7N1 isn't possible! (instead 7O2 is used...) */
+    int parity = (cflag & PARENB) ? ((cflag & PARODD) ? 0x0c : 0x08) : 0x04;
+    int div;
+
+    /* 4800 selects 7812.5, 115200 selects 500000, all other (incl. 9600 as
+     * default) the standard MIDI speed 31250. */
+    if (cflag & CBAUDEX)
+	baud += B38400;
+    if (baud == B4800)
+	div = ACIA_DIV64; /* really 7812.5 bps */
+    else if (baud == B38400+2 /* 115200 */)
+	div = ACIA_DIV1; /* really 500 kbps (does that work??) */
+    else
+	div = ACIA_DIV16; /* 31250 bps, standard for MIDI */
+
+    /* RTS low, ints disabled */
+    acia.mid_ctrl = div | csize | parity |
+		    ((atari_switches & ATARI_SWITCH_MIDI) ?
+		     ACIA_RHTID : ACIA_RLTID);
+}
+
+void __init atari_debug_init(void)
+{
+    if (!strcmp( m68k_debug_device, "ser" )) {
+	/* defaults to ser2 for a Falcon and ser1 otherwise */
+	strcpy( m68k_debug_device, MACH_IS_FALCON ? "ser2" : "ser1" );
+
+    }
+
+    if (!strcmp( m68k_debug_device, "ser1" )) {
+	/* ST-MFP Modem1 serial port */
+	atari_init_mfp_port( B9600|CS8 );
+	atari_console_driver.write = atari_mfp_console_write;
+    }
+    else if (!strcmp( m68k_debug_device, "ser2" )) {
+	/* SCC Modem2 serial port */
+	atari_init_scc_port( B9600|CS8 );
+	atari_console_driver.write = atari_scc_console_write;
+    }
+    else if (!strcmp( m68k_debug_device, "midi" )) {
+	/* MIDI port */
+	atari_init_midi_port( B9600|CS8 );
+	atari_console_driver.write = atari_midi_console_write;
+    }
+    else if (!strcmp( m68k_debug_device, "par" )) {
+	/* parallel printer */
+	atari_turnoff_irq( IRQ_MFP_BUSY ); /* avoid ints */
+	sound_ym.rd_data_reg_sel = 7;  /* select mixer control */
+	sound_ym.wd_data = 0xff;       /* sound off, ports are output */
+	sound_ym.rd_data_reg_sel = 15; /* select port B */
+	sound_ym.wd_data = 0;          /* no char */
+	sound_ym.rd_data_reg_sel = 14; /* select port A */
+	sound_ym.wd_data = sound_ym.rd_data_reg_sel | 0x20; /* strobe H */
+	atari_console_driver.write = atari_par_console_write;
+    }
+    if (atari_console_driver.write)
+	register_console(&atari_console_driver);
+}
+
+/*
+ * Local variables:
+ *  c-indent-level: 4
+ *  tab-width: 8
+ * End:
+ */
