commit 1efdd4bd254311498123a15fa0acd565f454da97
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 1 11:53:10 2018 +1100

    m68k: Call timer_interrupt() with interrupts disabled
    
    Some platforms execute their timer handler with the interrupt priority
    level set below 6. That means the handler could be interrupted by another
    driver and this could lead to re-entry of the timer core.
    
    Avoid this by use of local_irq_save/restore for timer interrupt dispatch.
    This provides mutual exclusion around the timer interrupt flag access
    which is needed later in this series for the clocksource conversion.
    
    Reported-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.21.1811131407120.2697@nanos.tec.linutronix.de
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 6bbca30c9188..a5824abb4a39 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -61,8 +61,10 @@ static irqreturn_t sun3_int7(int irq, void *dev_id)
 
 static irqreturn_t sun3_int5(int irq, void *dev_id)
 {
+	unsigned long flags;
 	unsigned int cnt;
 
+	local_irq_save(flags);
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
@@ -76,6 +78,7 @@ static irqreturn_t sun3_int5(int irq, void *dev_id)
 	cnt = kstat_irqs_cpu(irq, 0);
 	if (!(cnt % 20))
 		sun3_leds(led_pattern[cnt % 160 / 20]);
+	local_irq_restore(flags);
 	return IRQ_HANDLED;
 }
 

commit 7f88d2c0ad7995ab862ee6da5c77c37cf447b1b3
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Sun Nov 11 13:28:33 2012 +0100

    m68k/sun3: Get interrupts working again
    
    SUN3 Intregister is not for enabling individual interrupts, but to enable
    special interrupts. So using it for interrupt enable/disable was wrong.
    The clock interrupt needs some special treatment to keep ticking.
    
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 78b60f53e90a..6bbca30c9188 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -66,6 +66,8 @@ static irqreturn_t sun3_int5(int irq, void *dev_id)
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
+	sun3_disable_irq(5);
+	sun3_enable_irq(5);
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
@@ -79,41 +81,18 @@ static irqreturn_t sun3_int5(int irq, void *dev_id)
 
 static irqreturn_t sun3_vec255(int irq, void *dev_id)
 {
-//	intersil_clear();
 	return IRQ_HANDLED;
 }
 
-static void sun3_irq_enable(struct irq_data *data)
-{
-    sun3_enable_irq(data->irq);
-};
-
-static void sun3_irq_disable(struct irq_data *data)
-{
-    sun3_disable_irq(data->irq);
-};
-
-static struct irq_chip sun3_irq_chip = {
-	.name		= "sun3",
-	.irq_startup	= m68k_irq_startup,
-	.irq_shutdown	= m68k_irq_shutdown,
-	.irq_enable	= sun3_irq_enable,
-	.irq_disable	= sun3_irq_disable,
-	.irq_mask	= sun3_irq_disable,
-	.irq_unmask	= sun3_irq_enable,
-};
-
 void __init sun3_init_IRQ(void)
 {
 	*sun3_intreg = 1;
 
-	m68k_setup_irq_controller(&sun3_irq_chip, handle_level_irq, IRQ_AUTO_1,
-				  7);
 	m68k_setup_user_interrupt(VEC_USER, 128);
 
-	if (request_irq(IRQ_AUTO_5, sun3_int5, 0, "int5", NULL))
+	if (request_irq(IRQ_AUTO_5, sun3_int5, 0, "clock", NULL))
 		pr_err("Couldn't register %s interrupt\n", "int5");
-	if (request_irq(IRQ_AUTO_7, sun3_int7, 0, "int7", NULL))
+	if (request_irq(IRQ_AUTO_7, sun3_int7, 0, "nmi", NULL))
 		pr_err("Couldn't register %s interrupt\n", "int7");
 	if (request_irq(IRQ_USER+127, sun3_vec255, 0, "vec255", NULL))
 		pr_err("Couldn't register %s interrupt\n", "vec255");

commit f30a6484f1bcb410d0af0c24f34b8e3d92682a05
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 11 11:54:50 2011 +0200

    m68k/irq: Remove obsolete support for user vector interrupt fixups
    
    It was used on Apollo only, before its conversion to genirq.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 7eb378195cf7..78b60f53e90a 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -109,7 +109,7 @@ void __init sun3_init_IRQ(void)
 
 	m68k_setup_irq_controller(&sun3_irq_chip, handle_level_irq, IRQ_AUTO_1,
 				  7);
-	m68k_setup_user_interrupt(VEC_USER, 128, NULL);
+	m68k_setup_user_interrupt(VEC_USER, 128);
 
 	if (request_irq(IRQ_AUTO_5, sun3_int5, 0, "int5", NULL))
 		pr_err("Couldn't register %s interrupt\n", "int5");

commit d890d73995257b4e10cdd7d55bad80e34a71ba22
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 11 11:28:04 2011 +0200

    m68k/irq: Remove obsolete m68k irq framework
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 626b601931e9..7eb378195cf7 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -53,9 +53,6 @@ static irqreturn_t sun3_int7(int irq, void *dev_id)
 {
 	unsigned int cnt;
 
-#ifndef CONFIG_GENERIC_HARDIRQS
-	*sun3_intreg |=  (1 << irq);
-#endif
 	cnt = kstat_irqs_cpu(irq, 0);
 	if (!(cnt % 2000))
 		sun3_leds(led_pattern[cnt % 16000 / 2000]);
@@ -69,9 +66,6 @@ static irqreturn_t sun3_int5(int irq, void *dev_id)
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
-#ifndef CONFIG_GENERIC_HARDIRQS
-        *sun3_intreg |=  (1 << irq);
-#endif
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
@@ -89,15 +83,6 @@ static irqreturn_t sun3_vec255(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-#ifndef CONFIG_GENERIC_HARDIRQS
-static void sun3_inthandle(unsigned int irq, struct pt_regs *fp)
-{
-        *sun3_intreg &= ~(1 << irq);
-
-	do_IRQ(irq, fp);
-}
-#endif
-
 static void sun3_irq_enable(struct irq_data *data)
 {
     sun3_enable_irq(data->irq);
@@ -114,19 +99,14 @@ static struct irq_chip sun3_irq_chip = {
 	.irq_shutdown	= m68k_irq_shutdown,
 	.irq_enable	= sun3_irq_enable,
 	.irq_disable	= sun3_irq_disable,
-#ifdef CONFIG_GENERIC_HARDIRQS
 	.irq_mask	= sun3_irq_disable,
 	.irq_unmask	= sun3_irq_enable,
-#endif
 };
 
 void __init sun3_init_IRQ(void)
 {
 	*sun3_intreg = 1;
 
-#ifndef CONFIG_GENERIC_HARDIRQS
-	m68k_setup_auto_interrupt(sun3_inthandle);
-#endif
 	m68k_setup_irq_controller(&sun3_irq_chip, handle_level_irq, IRQ_AUTO_1,
 				  7);
 	m68k_setup_user_interrupt(VEC_USER, 128, NULL);

commit dda7535912255015ecf7264c1d6691a09f8ba487
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Aug 18 14:46:46 2011 +0200

    m68k/sun3: Convert Sun3/3x to genirq
    
    Replace the custom irq handler that masks the irq and calls do_IRQ(), and
    the unmasking in the individual handlers, by handle_level_irq().
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Sam Creasey <sammy@sammy.net>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 1273eb879a15..626b601931e9 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -53,7 +53,9 @@ static irqreturn_t sun3_int7(int irq, void *dev_id)
 {
 	unsigned int cnt;
 
+#ifndef CONFIG_GENERIC_HARDIRQS
 	*sun3_intreg |=  (1 << irq);
+#endif
 	cnt = kstat_irqs_cpu(irq, 0);
 	if (!(cnt % 2000))
 		sun3_leds(led_pattern[cnt % 16000 / 2000]);
@@ -67,7 +69,9 @@ static irqreturn_t sun3_int5(int irq, void *dev_id)
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
+#ifndef CONFIG_GENERIC_HARDIRQS
         *sun3_intreg |=  (1 << irq);
+#endif
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
@@ -85,12 +89,14 @@ static irqreturn_t sun3_vec255(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+#ifndef CONFIG_GENERIC_HARDIRQS
 static void sun3_inthandle(unsigned int irq, struct pt_regs *fp)
 {
         *sun3_intreg &= ~(1 << irq);
 
 	do_IRQ(irq, fp);
 }
+#endif
 
 static void sun3_irq_enable(struct irq_data *data)
 {
@@ -108,15 +114,21 @@ static struct irq_chip sun3_irq_chip = {
 	.irq_shutdown	= m68k_irq_shutdown,
 	.irq_enable	= sun3_irq_enable,
 	.irq_disable	= sun3_irq_disable,
+#ifdef CONFIG_GENERIC_HARDIRQS
+	.irq_mask	= sun3_irq_disable,
+	.irq_unmask	= sun3_irq_enable,
+#endif
 };
 
 void __init sun3_init_IRQ(void)
 {
 	*sun3_intreg = 1;
 
+#ifndef CONFIG_GENERIC_HARDIRQS
 	m68k_setup_auto_interrupt(sun3_inthandle);
-	m68k_setup_irq_controller(&sun3_irq_chip, handle_simple_irq,
-				  IRQ_AUTO_1, 7);
+#endif
+	m68k_setup_irq_controller(&sun3_irq_chip, handle_level_irq, IRQ_AUTO_1,
+				  7);
 	m68k_setup_user_interrupt(VEC_USER, 128, NULL);
 
 	if (request_irq(IRQ_AUTO_5, sun3_int5, 0, "int5", NULL))

commit 4045513286462a3c12140fac0559f09bcb5e7f10
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Aug 18 22:46:01 2011 +0200

    m68k/sun3: Use the kstat_irqs_cpu() wrapper
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Sam Creasey <sammy@sammy.net>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 20ffee7dc319..1273eb879a15 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -51,14 +51,19 @@ void sun3_disable_irq(unsigned int irq)
 
 static irqreturn_t sun3_int7(int irq, void *dev_id)
 {
+	unsigned int cnt;
+
 	*sun3_intreg |=  (1 << irq);
-	if (!(kstat_cpu(0).irqs[irq] % 2000))
-		sun3_leds(led_pattern[(kstat_cpu(0).irqs[irq] % 16000) / 2000]);
+	cnt = kstat_irqs_cpu(irq, 0);
+	if (!(cnt % 2000))
+		sun3_leds(led_pattern[cnt % 16000 / 2000]);
 	return IRQ_HANDLED;
 }
 
 static irqreturn_t sun3_int5(int irq, void *dev_id)
 {
+	unsigned int cnt;
+
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
@@ -68,8 +73,9 @@ static irqreturn_t sun3_int5(int irq, void *dev_id)
 #endif
 	xtime_update(1);
 	update_process_times(user_mode(get_irq_regs()));
-        if (!(kstat_cpu(0).irqs[irq] % 20))
-                sun3_leds(led_pattern[(kstat_cpu(0).irqs[irq] % 160) / 20]);
+	cnt = kstat_irqs_cpu(irq, 0);
+	if (!(cnt % 20))
+		sun3_leds(led_pattern[cnt % 160 / 20]);
 	return IRQ_HANDLED;
 }
 

commit 1425df87c25b15400c9f26d57821bcfe01286b2a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Jul 1 20:39:19 2011 +0200

    m68k/irq: Rename {,__}m68k_handle_int()
    
      - Rename m68k_handle_int() to generic_handle_irq(), and drop the unneeded
        asmlinkage,
      - Rename __m68k_handle_int() to do_IRQ().
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 20461278e535..20ffee7dc319 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -83,7 +83,7 @@ static void sun3_inthandle(unsigned int irq, struct pt_regs *fp)
 {
         *sun3_intreg &= ~(1 << irq);
 
-	__m68k_handle_int(irq, fp);
+	do_IRQ(irq, fp);
 }
 
 static void sun3_irq_enable(struct irq_data *data)

commit edb347256c44366888debb4f9e8477ac700a9026
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jun 1 11:15:21 2011 +0200

    m68k/irq: Add m68k_setup_irq_controller()
    
    This is a wrapper around m68k_setup_irq_chip() that discards its dummy
    second parameter, to ease the future transition to genirq.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 5d45e0065d2e..20461278e535 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -109,7 +109,8 @@ void __init sun3_init_IRQ(void)
 	*sun3_intreg = 1;
 
 	m68k_setup_auto_interrupt(sun3_inthandle);
-	m68k_setup_irq_chip(&sun3_irq_chip, IRQ_AUTO_1, 7);
+	m68k_setup_irq_controller(&sun3_irq_chip, handle_simple_irq,
+				  IRQ_AUTO_1, 7);
 	m68k_setup_user_interrupt(VEC_USER, 128, NULL);
 
 	if (request_irq(IRQ_AUTO_5, sun3_int5, 0, "int5", NULL))

commit e8abf5e73cdb6c034d35ccba1f63a4801cd3dec5
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 17 22:53:04 2011 +0200

    m68k/irq: Switch irq_chip methods to "struct irq_data *data"
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 97fa9edc5a9d..5d45e0065d2e 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -86,12 +86,22 @@ static void sun3_inthandle(unsigned int irq, struct pt_regs *fp)
 	__m68k_handle_int(irq, fp);
 }
 
+static void sun3_irq_enable(struct irq_data *data)
+{
+    sun3_enable_irq(data->irq);
+};
+
+static void sun3_irq_disable(struct irq_data *data)
+{
+    sun3_disable_irq(data->irq);
+};
+
 static struct irq_chip sun3_irq_chip = {
 	.name		= "sun3",
 	.irq_startup	= m68k_irq_startup,
 	.irq_shutdown	= m68k_irq_shutdown,
-	.irq_enable	= sun3_enable_irq,
-	.irq_disable	= sun3_disable_irq,
+	.irq_enable	= sun3_irq_enable,
+	.irq_disable	= sun3_irq_disable,
 };
 
 void __init sun3_init_IRQ(void)

commit c288bf2533e57174b90b07860c4391bcd1ea269c
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Apr 13 22:31:28 2011 +0200

    m68k/irq: Rename irq_controller to irq_chip
    
    Make it more similar to the genirq version:
      - Remove lock (unused as we don't do SMP anyway),
      - Prepend methods with irq_,
      - Make irq_startup() return unsigned int.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 6464ad3ae3e6..97fa9edc5a9d 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -86,13 +86,12 @@ static void sun3_inthandle(unsigned int irq, struct pt_regs *fp)
 	__m68k_handle_int(irq, fp);
 }
 
-static struct irq_controller sun3_irq_controller = {
+static struct irq_chip sun3_irq_chip = {
 	.name		= "sun3",
-	.lock		= __SPIN_LOCK_UNLOCKED(sun3_irq_controller.lock),
-	.startup	= m68k_irq_startup,
-	.shutdown	= m68k_irq_shutdown,
-	.enable		= sun3_enable_irq,
-	.disable	= sun3_disable_irq,
+	.irq_startup	= m68k_irq_startup,
+	.irq_shutdown	= m68k_irq_shutdown,
+	.irq_enable	= sun3_enable_irq,
+	.irq_disable	= sun3_disable_irq,
 };
 
 void __init sun3_init_IRQ(void)
@@ -100,7 +99,7 @@ void __init sun3_init_IRQ(void)
 	*sun3_intreg = 1;
 
 	m68k_setup_auto_interrupt(sun3_inthandle);
-	m68k_setup_irq_controller(&sun3_irq_controller, IRQ_AUTO_1, 7);
+	m68k_setup_irq_chip(&sun3_irq_chip, IRQ_AUTO_1, 7);
 	m68k_setup_user_interrupt(VEC_USER, 128, NULL);
 
 	if (request_irq(IRQ_AUTO_5, sun3_int5, 0, "int5", NULL))

commit e53f276beb655c711a5d1f25f800b61aa976e34f
Author: Torben Hohn <torbenh@gmx.de>
Date:   Thu Jan 27 16:00:06 2011 +0100

    m68k: Switch do_timer() to xtime_update()
    
    xtime_update() properly takes the xtime_lock
    
    Signed-off-by: Torben Hohn <torbenh@gmx.de>
    Cc: Sam Creasey <sammy@sammy.net>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: johnstul@us.ibm.com
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: hch@infradead.org
    Cc: yong.zhang0@gmail.com
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greg Ungerer <gerg@uclinux.org>
    LKML-Reference: <20110127150006.23248.71790.stgit@localhost>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 2d9e21bd313a..6464ad3ae3e6 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -66,7 +66,7 @@ static irqreturn_t sun3_int5(int irq, void *dev_id)
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
-        do_timer(1);
+	xtime_update(1);
 	update_process_times(user_mode(get_irq_regs()));
         if (!(kstat_cpu(0).irqs[irq] % 20))
                 sun3_leds(led_pattern[(kstat_cpu(0).irqs[irq] % 160) / 20]);

commit 5bc5a70b62e5b672e40dd031da3e0444f62dbd3a
Author: Christian Dietrich <qy03fugy@stud.informatik.uni-erlangen.de>
Date:   Wed Aug 4 14:41:45 2010 +0200

    m68k/m68knommu: Remove dead SMP config option
    
    CONFIG_SMP doesn't exist in Kconfig (for this architecure), therefore
    remove all references to it from the source.
    
    Signed-off-by: Christian Dietrich <qy03fugy@stud.informatik.uni-erlangen.de>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index ad90393a3361..2d9e21bd313a 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -67,9 +67,7 @@ static irqreturn_t sun3_int5(int irq, void *dev_id)
 	intersil_clear();
 #endif
         do_timer(1);
-#ifndef CONFIG_SMP
 	update_process_times(user_mode(get_irq_regs()));
-#endif
         if (!(kstat_cpu(0).irqs[irq] % 20))
                 sun3_leds(led_pattern[(kstat_cpu(0).irqs[irq] % 160) / 20]);
 	return IRQ_HANDLED;

commit 07e449b5b43b4b82c54e3026fc26bd4d8c81b080
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Dec 30 14:05:24 2008 +0100

    m68k: sun3 core - Kill warn_unused_result warnings
    
    warning: ignoring return value of 'request_irq', declared with attribute
    warn_unused_result
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 7364cd67455e..ad90393a3361 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -105,7 +105,10 @@ void __init sun3_init_IRQ(void)
 	m68k_setup_irq_controller(&sun3_irq_controller, IRQ_AUTO_1, 7);
 	m68k_setup_user_interrupt(VEC_USER, 128, NULL);
 
-	request_irq(IRQ_AUTO_5, sun3_int5, 0, "int5", NULL);
-	request_irq(IRQ_AUTO_7, sun3_int7, 0, "int7", NULL);
-	request_irq(IRQ_USER+127, sun3_vec255, 0, "vec255", NULL);
+	if (request_irq(IRQ_AUTO_5, sun3_int5, 0, "int5", NULL))
+		pr_err("Couldn't register %s interrupt\n", "int5");
+	if (request_irq(IRQ_AUTO_7, sun3_int7, 0, "int7", NULL))
+		pr_err("Couldn't register %s interrupt\n", "int7");
+	if (request_irq(IRQ_USER+127, sun3_vec255, 0, "vec255", NULL))
+		pr_err("Couldn't register %s interrupt\n", "vec255");
 }

commit 07b8125949de66b6552966de8d4280c3a8620359
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jul 17 21:16:27 2008 +0200

    m68k/sun3/: possible cleanups
    
    This patch contains the following possible cleanups:
    - make the following needlessly global code static:
      - config.c: sun3_bootmem_alloc()
      - config.c: sun3_sched_init()
      - dvma.c: dvma_page()
      - idprom.c: struct Sun_Machines[]
      - mmu_emu.c: struct ctx_alloc[]
      - sun3dvma.c: iommu_use[]
      - sun3ints.c: led_pattern[]
    - remove the unused sbus.c
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index cf93481adb1d..7364cd67455e 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -30,7 +30,7 @@ void sun3_enable_interrupts(void)
 	sun3_enable_irq(0);
 }
 
-int led_pattern[8] = {
+static int led_pattern[8] = {
        ~(0x80), ~(0x01),
        ~(0x40), ~(0x02),
        ~(0x20), ~(0x04),

commit 66a3f820cb6a88ef0481e042d4b48b2299deab7e
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Jul 20 04:33:28 2007 +0100

    m68k: missing __init
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 50df34bf80e3..cf93481adb1d 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -97,7 +97,7 @@ static struct irq_controller sun3_irq_controller = {
 	.disable	= sun3_disable_irq,
 };
 
-void sun3_init_IRQ(void)
+void __init sun3_init_IRQ(void)
 {
 	*sun3_intreg = 1;
 

commit 241258d1cc4d3551608364cd678d5a85239ad481
Author: Milind Arun Choudhary <milindchoudhary@gmail.com>
Date:   Sun May 6 14:50:54 2007 -0700

    SPIN_LOCK_UNLOCKED cleanup in arch/m68k
    
    SPIN_LOCK_UNLOCKED cleanup,use __SPIN_LOCK_UNLOCKED instead
    
    Signed-off-by: Milind Arun Choudhary <milindchoudhary@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 4232a2c2fae9..50df34bf80e3 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -90,7 +90,7 @@ static void sun3_inthandle(unsigned int irq, struct pt_regs *fp)
 
 static struct irq_controller sun3_irq_controller = {
 	.name		= "sun3",
-	.lock		= SPIN_LOCK_UNLOCKED,
+	.lock		= __SPIN_LOCK_UNLOCKED(sun3_irq_controller.lock),
 	.startup	= m68k_irq_startup,
 	.shutdown	= m68k_irq_shutdown,
 	.enable		= sun3_enable_irq,

commit 35bdd52d7401b1208552523d6fa28d4a37dbc74d
Author: Sam Creasey <sammy@sammy.net>
Date:   Tue May 1 22:32:47 2007 +0200

    m68k: Correct number of interrupts for Sun3
    
    Only attempt to initialize the amount of interrupts a sun3 actually has...
    
    Signed-off-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index baf74e8de8b5..4232a2c2fae9 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -103,7 +103,7 @@ void sun3_init_IRQ(void)
 
 	m68k_setup_auto_interrupt(sun3_inthandle);
 	m68k_setup_irq_controller(&sun3_irq_controller, IRQ_AUTO_1, 7);
-	m68k_setup_user_interrupt(VEC_USER, 192, NULL);
+	m68k_setup_user_interrupt(VEC_USER, 128, NULL);
 
 	request_irq(IRQ_AUTO_5, sun3_int5, 0, "int5", NULL);
 	request_irq(IRQ_AUTO_7, sun3_int7, 0, "int7", NULL);

commit 2850bc273776cbb1b510c5828e9e456dffb50a32
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Oct 7 14:16:45 2006 +0100

    [PATCH] m68k pt_regs fixes
    
    m68k_handle_int() split in two functions: __m68k_handle_int() takes
    pt_regs * and does set_irq_regs(); m68k_handle_int() doesn't get pt_regs
    *.
    
    Places where we used to call m68k_handle_int() recursively with the same
    pt_regs have simply lost the second argument, the rest is switched to
    __m68k_handle_int().
    
    The rest of patch is just dropping pt_regs * where needed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index dc4ea7e074a6..baf74e8de8b5 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -15,6 +15,7 @@
 #include <asm/intersil.h>
 #include <asm/oplib.h>
 #include <asm/sun3ints.h>
+#include <asm/irq_regs.h>
 #include <linux/seq_file.h>
 
 extern void sun3_leds (unsigned char);
@@ -48,7 +49,7 @@ void sun3_disable_irq(unsigned int irq)
 	*sun3_intreg &= ~(1 << irq);
 }
 
-static irqreturn_t sun3_int7(int irq, void *dev_id, struct pt_regs *fp)
+static irqreturn_t sun3_int7(int irq, void *dev_id)
 {
 	*sun3_intreg |=  (1 << irq);
 	if (!(kstat_cpu(0).irqs[irq] % 2000))
@@ -56,7 +57,7 @@ static irqreturn_t sun3_int7(int irq, void *dev_id, struct pt_regs *fp)
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t sun3_int5(int irq, void *dev_id, struct pt_regs *fp)
+static irqreturn_t sun3_int5(int irq, void *dev_id)
 {
 #ifdef CONFIG_SUN3
 	intersil_clear();
@@ -67,14 +68,14 @@ static irqreturn_t sun3_int5(int irq, void *dev_id, struct pt_regs *fp)
 #endif
         do_timer(1);
 #ifndef CONFIG_SMP
-	update_process_times(user_mode(fp));
+	update_process_times(user_mode(get_irq_regs()));
 #endif
         if (!(kstat_cpu(0).irqs[irq] % 20))
                 sun3_leds(led_pattern[(kstat_cpu(0).irqs[irq] % 160) / 20]);
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t sun3_vec255(int irq, void *dev_id, struct pt_regs *fp)
+static irqreturn_t sun3_vec255(int irq, void *dev_id)
 {
 //	intersil_clear();
 	return IRQ_HANDLED;
@@ -84,7 +85,7 @@ static void sun3_inthandle(unsigned int irq, struct pt_regs *fp)
 {
         *sun3_intreg &= ~(1 << irq);
 
-	m68k_handle_int(irq, fp);
+	__m68k_handle_int(irq, fp);
 }
 
 static struct irq_controller sun3_irq_controller = {

commit 3171a0305d62e6627a24bff35af4f997e4988a80
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Sep 29 02:00:32 2006 -0700

    [PATCH] simplify update_times (avoid jiffies/jiffies_64 aliasing problem)
    
    Pass ticks to do_timer() and update_times(), and adjust x86_64 and s390
    timer interrupt handler with this change.
    
    Currently update_times() calculates ticks by "jiffies - wall_jiffies", but
    callers of do_timer() should know how many ticks to update.  Passing ticks
    get rid of this redundant calculation.  Also there are another redundancy
    pointed out by Martin Schwidefsky.
    
    This cleanup make a barrier added by
    5aee405c662ca644980c184774277fc6d0769a84 needless.  So this patch removes
    it.
    
    As a bonus, this cleanup make wall_jiffies can be removed easily, since now
    wall_jiffies is always synced with jiffies.  (This patch does not really
    remove wall_jiffies.  It would be another cleanup patch)
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: john stultz <johnstul@us.ibm.com>
    Cc: Andi Kleen <ak@muc.de>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Acked-by: Russell King <rmk@arm.linux.org.uk>
    Cc: Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Acked-by: David Howells <dhowells@redhat.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Hirokazu Takata <takata.hirokazu@renesas.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Kazumoto Kojima <kkojima@rr.iij4u.or.jp>
    Cc: Richard Curnow <rc@rc0.org.uk>
    Cc: William Lee Irwin III <wli@holomorphy.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Paolo 'Blaisorblade' Giarrusso <blaisorblade@yahoo.it>
    Cc: Miles Bader <uclinux-v850@lsi.nec.co.jp>
    Cc: Chris Zankel <chris@zankel.net>
    Acked-by: "Luck, Tony" <tony.luck@intel.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index f18b9d3ef16d..dc4ea7e074a6 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -65,7 +65,7 @@ static irqreturn_t sun3_int5(int irq, void *dev_id, struct pt_regs *fp)
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
-        do_timer(fp);
+        do_timer(1);
 #ifndef CONFIG_SMP
 	update_process_times(user_mode(fp));
 #endif

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index 0912435e9e90..f18b9d3ef16d 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -6,7 +6,6 @@
  * for more details.
  */
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>

commit ebba61d5b05ecfda388dd4c156bafdb78d398055
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:05 2006 -0700

    [PATCH] m68k: convert sun3 irq code
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
index e62a033cd493..0912435e9e90 100644
--- a/arch/m68k/sun3/sun3ints.c
+++ b/arch/m68k/sun3/sun3ints.c
@@ -19,7 +19,6 @@
 #include <linux/seq_file.h>
 
 extern void sun3_leds (unsigned char);
-static irqreturn_t sun3_inthandle(int irq, void *dev_id, struct pt_regs *fp);
 
 void sun3_disable_interrupts(void)
 {
@@ -40,48 +39,30 @@ int led_pattern[8] = {
 
 volatile unsigned char* sun3_intreg;
 
-void sun3_insert_irq(irq_node_t **list, irq_node_t *node)
-{
-}
-
-void sun3_delete_irq(irq_node_t **list, void *dev_id)
-{
-}
-
 void sun3_enable_irq(unsigned int irq)
 {
-	*sun3_intreg |=  (1<<irq);
+	*sun3_intreg |=  (1 << irq);
 }
 
 void sun3_disable_irq(unsigned int irq)
 {
-	*sun3_intreg &= ~(1<<irq);
-}
-
-inline void sun3_do_irq(int irq, struct pt_regs *fp)
-{
-	kstat_cpu(0).irqs[SYS_IRQS + irq]++;
-	*sun3_intreg &= ~(1<<irq);
-	*sun3_intreg |=  (1<<irq);
+	*sun3_intreg &= ~(1 << irq);
 }
 
 static irqreturn_t sun3_int7(int irq, void *dev_id, struct pt_regs *fp)
 {
-	sun3_do_irq(irq,fp);
-	if(!(kstat_cpu(0).irqs[SYS_IRQS + irq] % 2000))
-		sun3_leds(led_pattern[(kstat_cpu(0).irqs[SYS_IRQS+irq]%16000)
-			  /2000]);
+	*sun3_intreg |=  (1 << irq);
+	if (!(kstat_cpu(0).irqs[irq] % 2000))
+		sun3_leds(led_pattern[(kstat_cpu(0).irqs[irq] % 16000) / 2000]);
 	return IRQ_HANDLED;
 }
 
 static irqreturn_t sun3_int5(int irq, void *dev_id, struct pt_regs *fp)
 {
-        kstat_cpu(0).irqs[SYS_IRQS + irq]++;
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
-        *sun3_intreg &= ~(1<<irq);
-        *sun3_intreg |=  (1<<irq);
+        *sun3_intreg |=  (1 << irq);
 #ifdef CONFIG_SUN3
 	intersil_clear();
 #endif
@@ -89,65 +70,8 @@ static irqreturn_t sun3_int5(int irq, void *dev_id, struct pt_regs *fp)
 #ifndef CONFIG_SMP
 	update_process_times(user_mode(fp));
 #endif
-        if(!(kstat_cpu(0).irqs[SYS_IRQS + irq] % 20))
-                sun3_leds(led_pattern[(kstat_cpu(0).irqs[SYS_IRQS+irq]%160)
-                /20]);
-	return IRQ_HANDLED;
-}
-
-/* handle requested ints, excepting 5 and 7, which always do the same
-   thing */
-irqreturn_t (*sun3_default_handler[SYS_IRQS])(int, void *, struct pt_regs *) = {
-	[0] = sun3_inthandle,
-	[1] = sun3_inthandle,
-	[2] = sun3_inthandle,
-	[3] = sun3_inthandle,
-	[4] = sun3_inthandle,
-	[5] = sun3_int5,
-	[6] = sun3_inthandle,
-	[7] = sun3_int7
-};
-
-static const char *dev_names[SYS_IRQS] = {
-	[5] = "timer",
-	[7] = "int7 handler"
-};
-static void *dev_ids[SYS_IRQS];
-static irqreturn_t (*sun3_inthandler[SYS_IRQS])(int, void *, struct pt_regs *) = {
-	[5] = sun3_int5,
-	[7] = sun3_int7
-};
-static irqreturn_t (*sun3_vechandler[SUN3_INT_VECS])(int, void *, struct pt_regs *);
-static void *vec_ids[SUN3_INT_VECS];
-static const char *vec_names[SUN3_INT_VECS];
-static int vec_ints[SUN3_INT_VECS];
-
-
-int show_sun3_interrupts(struct seq_file *p, void *v)
-{
-	int i;
-
-	for(i = 0; i < (SUN3_INT_VECS-1); i++) {
-		if(sun3_vechandler[i] != NULL) {
-			seq_printf(p, "vec %3d: %10u %s\n", i+64,
-				   vec_ints[i],
-				   (vec_names[i]) ? vec_names[i] :
-				   "sun3_vechandler");
-		}
-	}
-
-	return 0;
-}
-
-static irqreturn_t sun3_inthandle(int irq, void *dev_id, struct pt_regs *fp)
-{
-	if(sun3_inthandler[irq] == NULL)
-		panic ("bad interrupt %d received (id %p)\n",irq, dev_id);
-
-        kstat_cpu(0).irqs[SYS_IRQS + irq]++;
-        *sun3_intreg &= ~(1<<irq);
-
-	sun3_inthandler[irq](irq, dev_ids[irq], fp);
+        if (!(kstat_cpu(0).irqs[irq] % 20))
+                sun3_leds(led_pattern[(kstat_cpu(0).irqs[irq] % 160) / 20]);
 	return IRQ_HANDLED;
 }
 
@@ -157,109 +81,31 @@ static irqreturn_t sun3_vec255(int irq, void *dev_id, struct pt_regs *fp)
 	return IRQ_HANDLED;
 }
 
-void sun3_init_IRQ(void)
+static void sun3_inthandle(unsigned int irq, struct pt_regs *fp)
 {
-	int i;
-
-	*sun3_intreg = 1;
-
-	for(i = 0; i < SYS_IRQS; i++)
-	{
-		if(dev_names[i])
-			cpu_request_irq(i, sun3_default_handler[i], 0,
-					dev_names[i], NULL);
-	}
-
-	for(i = 0; i < 192; i++)
-		sun3_vechandler[i] = NULL;
-
-	sun3_vechandler[191] = sun3_vec255;
-}
-
-int sun3_request_irq(unsigned int irq, irqreturn_t (*handler)(int, void *, struct pt_regs *),
-                      unsigned long flags, const char *devname, void *dev_id)
-{
-
-	if(irq < SYS_IRQS) {
-		if(sun3_inthandler[irq] != NULL) {
-			printk("sun3_request_irq: request for irq %d -- already taken!\n", irq);
-			return 1;
-		}
-
-		sun3_inthandler[irq] = handler;
-		dev_ids[irq] = dev_id;
-		dev_names[irq] = devname;
-
-		/* setting devname would be nice */
-		cpu_request_irq(irq, sun3_default_handler[irq], 0, devname,
-				NULL);
-
-		return 0;
-	} else {
-		if((irq >= 64) && (irq <= 255)) {
-		        int vec;
-
-			vec = irq - 64;
-			if(sun3_vechandler[vec] != NULL) {
-				printk("sun3_request_irq: request for vec %d -- already taken!\n", irq);
-				return 1;
-			}
-
-			sun3_vechandler[vec] = handler;
-			vec_ids[vec] = dev_id;
-			vec_names[vec] = devname;
-			vec_ints[vec] = 0;
-
-			return 0;
-		}
-	}
-
-	printk("sun3_request_irq: invalid irq %d\n", irq);
-	return 1;
+        *sun3_intreg &= ~(1 << irq);
 
+	m68k_handle_int(irq, fp);
 }
 
-void sun3_free_irq(unsigned int irq, void *dev_id)
-{
-
-	if(irq < SYS_IRQS) {
-		if(sun3_inthandler[irq] == NULL)
-			panic("sun3_free_int: attempt to free unused irq %d\n", irq);
-		if(dev_ids[irq] != dev_id)
-			panic("sun3_free_int: incorrect dev_id for irq %d\n", irq);
-
-		sun3_inthandler[irq] = NULL;
-		return;
-	} else if((irq >= 64) && (irq <= 255)) {
-		int vec;
-
-		vec = irq - 64;
-		if(sun3_vechandler[vec] == NULL)
-			panic("sun3_free_int: attempt to free unused vector %d\n", irq);
-		if(vec_ids[irq] != dev_id)
-			panic("sun3_free_int: incorrect dev_id for vec %d\n", irq);
-
-		sun3_vechandler[vec] = NULL;
-		return;
-	} else {
-		panic("sun3_free_irq: invalid irq %d\n", irq);
-	}
-}
+static struct irq_controller sun3_irq_controller = {
+	.name		= "sun3",
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.startup	= m68k_irq_startup,
+	.shutdown	= m68k_irq_shutdown,
+	.enable		= sun3_enable_irq,
+	.disable	= sun3_disable_irq,
+};
 
-irqreturn_t sun3_process_int(int irq, struct pt_regs *regs)
+void sun3_init_IRQ(void)
 {
+	*sun3_intreg = 1;
 
-	if((irq >= 64) && (irq <= 255)) {
-		int vec;
-
-		vec = irq - 64;
-		if(sun3_vechandler[vec] == NULL)
-			panic ("bad interrupt vector %d received\n",irq);
+	m68k_setup_auto_interrupt(sun3_inthandle);
+	m68k_setup_irq_controller(&sun3_irq_controller, IRQ_AUTO_1, 7);
+	m68k_setup_user_interrupt(VEC_USER, 192, NULL);
 
-		vec_ints[vec]++;
-		return sun3_vechandler[vec](irq, vec_ids[vec], regs);
-	} else {
-		panic("sun3_process_int: unable to handle interrupt vector %d\n",
-		      irq);
-	}
+	request_irq(IRQ_AUTO_5, sun3_int5, 0, "int5", NULL);
+	request_irq(IRQ_AUTO_7, sun3_int7, 0, "int7", NULL);
+	request_irq(IRQ_USER+127, sun3_vec255, 0, "vec255", NULL);
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/sun3/sun3ints.c b/arch/m68k/sun3/sun3ints.c
new file mode 100644
index 000000000000..e62a033cd493
--- /dev/null
+++ b/arch/m68k/sun3/sun3ints.c
@@ -0,0 +1,265 @@
+ /*
+ * linux/arch/m68k/sun3/sun3ints.c -- Sun-3(x) Linux interrupt handling code
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kernel_stat.h>
+#include <linux/interrupt.h>
+#include <asm/segment.h>
+#include <asm/intersil.h>
+#include <asm/oplib.h>
+#include <asm/sun3ints.h>
+#include <linux/seq_file.h>
+
+extern void sun3_leds (unsigned char);
+static irqreturn_t sun3_inthandle(int irq, void *dev_id, struct pt_regs *fp);
+
+void sun3_disable_interrupts(void)
+{
+	sun3_disable_irq(0);
+}
+
+void sun3_enable_interrupts(void)
+{
+	sun3_enable_irq(0);
+}
+
+int led_pattern[8] = {
+       ~(0x80), ~(0x01),
+       ~(0x40), ~(0x02),
+       ~(0x20), ~(0x04),
+       ~(0x10), ~(0x08)
+};
+
+volatile unsigned char* sun3_intreg;
+
+void sun3_insert_irq(irq_node_t **list, irq_node_t *node)
+{
+}
+
+void sun3_delete_irq(irq_node_t **list, void *dev_id)
+{
+}
+
+void sun3_enable_irq(unsigned int irq)
+{
+	*sun3_intreg |=  (1<<irq);
+}
+
+void sun3_disable_irq(unsigned int irq)
+{
+	*sun3_intreg &= ~(1<<irq);
+}
+
+inline void sun3_do_irq(int irq, struct pt_regs *fp)
+{
+	kstat_cpu(0).irqs[SYS_IRQS + irq]++;
+	*sun3_intreg &= ~(1<<irq);
+	*sun3_intreg |=  (1<<irq);
+}
+
+static irqreturn_t sun3_int7(int irq, void *dev_id, struct pt_regs *fp)
+{
+	sun3_do_irq(irq,fp);
+	if(!(kstat_cpu(0).irqs[SYS_IRQS + irq] % 2000))
+		sun3_leds(led_pattern[(kstat_cpu(0).irqs[SYS_IRQS+irq]%16000)
+			  /2000]);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sun3_int5(int irq, void *dev_id, struct pt_regs *fp)
+{
+        kstat_cpu(0).irqs[SYS_IRQS + irq]++;
+#ifdef CONFIG_SUN3
+	intersil_clear();
+#endif
+        *sun3_intreg &= ~(1<<irq);
+        *sun3_intreg |=  (1<<irq);
+#ifdef CONFIG_SUN3
+	intersil_clear();
+#endif
+        do_timer(fp);
+#ifndef CONFIG_SMP
+	update_process_times(user_mode(fp));
+#endif
+        if(!(kstat_cpu(0).irqs[SYS_IRQS + irq] % 20))
+                sun3_leds(led_pattern[(kstat_cpu(0).irqs[SYS_IRQS+irq]%160)
+                /20]);
+	return IRQ_HANDLED;
+}
+
+/* handle requested ints, excepting 5 and 7, which always do the same
+   thing */
+irqreturn_t (*sun3_default_handler[SYS_IRQS])(int, void *, struct pt_regs *) = {
+	[0] = sun3_inthandle,
+	[1] = sun3_inthandle,
+	[2] = sun3_inthandle,
+	[3] = sun3_inthandle,
+	[4] = sun3_inthandle,
+	[5] = sun3_int5,
+	[6] = sun3_inthandle,
+	[7] = sun3_int7
+};
+
+static const char *dev_names[SYS_IRQS] = {
+	[5] = "timer",
+	[7] = "int7 handler"
+};
+static void *dev_ids[SYS_IRQS];
+static irqreturn_t (*sun3_inthandler[SYS_IRQS])(int, void *, struct pt_regs *) = {
+	[5] = sun3_int5,
+	[7] = sun3_int7
+};
+static irqreturn_t (*sun3_vechandler[SUN3_INT_VECS])(int, void *, struct pt_regs *);
+static void *vec_ids[SUN3_INT_VECS];
+static const char *vec_names[SUN3_INT_VECS];
+static int vec_ints[SUN3_INT_VECS];
+
+
+int show_sun3_interrupts(struct seq_file *p, void *v)
+{
+	int i;
+
+	for(i = 0; i < (SUN3_INT_VECS-1); i++) {
+		if(sun3_vechandler[i] != NULL) {
+			seq_printf(p, "vec %3d: %10u %s\n", i+64,
+				   vec_ints[i],
+				   (vec_names[i]) ? vec_names[i] :
+				   "sun3_vechandler");
+		}
+	}
+
+	return 0;
+}
+
+static irqreturn_t sun3_inthandle(int irq, void *dev_id, struct pt_regs *fp)
+{
+	if(sun3_inthandler[irq] == NULL)
+		panic ("bad interrupt %d received (id %p)\n",irq, dev_id);
+
+        kstat_cpu(0).irqs[SYS_IRQS + irq]++;
+        *sun3_intreg &= ~(1<<irq);
+
+	sun3_inthandler[irq](irq, dev_ids[irq], fp);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t sun3_vec255(int irq, void *dev_id, struct pt_regs *fp)
+{
+//	intersil_clear();
+	return IRQ_HANDLED;
+}
+
+void sun3_init_IRQ(void)
+{
+	int i;
+
+	*sun3_intreg = 1;
+
+	for(i = 0; i < SYS_IRQS; i++)
+	{
+		if(dev_names[i])
+			cpu_request_irq(i, sun3_default_handler[i], 0,
+					dev_names[i], NULL);
+	}
+
+	for(i = 0; i < 192; i++)
+		sun3_vechandler[i] = NULL;
+
+	sun3_vechandler[191] = sun3_vec255;
+}
+
+int sun3_request_irq(unsigned int irq, irqreturn_t (*handler)(int, void *, struct pt_regs *),
+                      unsigned long flags, const char *devname, void *dev_id)
+{
+
+	if(irq < SYS_IRQS) {
+		if(sun3_inthandler[irq] != NULL) {
+			printk("sun3_request_irq: request for irq %d -- already taken!\n", irq);
+			return 1;
+		}
+
+		sun3_inthandler[irq] = handler;
+		dev_ids[irq] = dev_id;
+		dev_names[irq] = devname;
+
+		/* setting devname would be nice */
+		cpu_request_irq(irq, sun3_default_handler[irq], 0, devname,
+				NULL);
+
+		return 0;
+	} else {
+		if((irq >= 64) && (irq <= 255)) {
+		        int vec;
+
+			vec = irq - 64;
+			if(sun3_vechandler[vec] != NULL) {
+				printk("sun3_request_irq: request for vec %d -- already taken!\n", irq);
+				return 1;
+			}
+
+			sun3_vechandler[vec] = handler;
+			vec_ids[vec] = dev_id;
+			vec_names[vec] = devname;
+			vec_ints[vec] = 0;
+
+			return 0;
+		}
+	}
+
+	printk("sun3_request_irq: invalid irq %d\n", irq);
+	return 1;
+
+}
+
+void sun3_free_irq(unsigned int irq, void *dev_id)
+{
+
+	if(irq < SYS_IRQS) {
+		if(sun3_inthandler[irq] == NULL)
+			panic("sun3_free_int: attempt to free unused irq %d\n", irq);
+		if(dev_ids[irq] != dev_id)
+			panic("sun3_free_int: incorrect dev_id for irq %d\n", irq);
+
+		sun3_inthandler[irq] = NULL;
+		return;
+	} else if((irq >= 64) && (irq <= 255)) {
+		int vec;
+
+		vec = irq - 64;
+		if(sun3_vechandler[vec] == NULL)
+			panic("sun3_free_int: attempt to free unused vector %d\n", irq);
+		if(vec_ids[irq] != dev_id)
+			panic("sun3_free_int: incorrect dev_id for vec %d\n", irq);
+
+		sun3_vechandler[vec] = NULL;
+		return;
+	} else {
+		panic("sun3_free_irq: invalid irq %d\n", irq);
+	}
+}
+
+irqreturn_t sun3_process_int(int irq, struct pt_regs *regs)
+{
+
+	if((irq >= 64) && (irq <= 255)) {
+		int vec;
+
+		vec = irq - 64;
+		if(sun3_vechandler[vec] == NULL)
+			panic ("bad interrupt vector %d received\n",irq);
+
+		vec_ints[vec]++;
+		return sun3_vechandler[vec](irq, vec_ids[vec], regs);
+	} else {
+		panic("sun3_process_int: unable to handle interrupt vector %d\n",
+		      irq);
+	}
+}
