commit abcfc543bec803a53c5bd2925d3293df4ede84b0
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 5 13:28:32 2014 +0100

    m68k: Do not rely on magic indirect includes
    
    commit: 8f945a33 (genirq: Move kstat_incr_irqs_this_cpu() to core)
    unearthed the following:
    
    arch/m68k/kernel/ints.c:34:15: error: variable 'auto_irq_chip' has initializer but incomplete type
    arch/m68k/kernel/ints.c:35:2: error: unknown field 'name' specified in initializer
    arch/m68k/kernel/ints.c:35:2: warning: excess elements in struct initializer [enabled by default]
    
    The reason is that this file requires linux/irq.h and magically
    pulled that in via linux/kernel_stat.h
    
    The commit above got rid of the pointless include of linux/irq.h in
    linux/kernel_stat.h and therefor broke the build.
    
    Include linux/irq.h
    
    Reported-by: fengguang.wu@intel.com
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 077d3a70fed1..5b8d66fbf383 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -10,9 +10,9 @@
 #include <linux/types.h>
 #include <linux/sched.h>
 #include <linux/interrupt.h>
-#include <linux/kernel_stat.h>
 #include <linux/errno.h>
 #include <linux/init.h>
+#include <linux/irq.h>
 
 #include <asm/setup.h>
 #include <asm/irq.h>

commit 09f90f6685cd88b6b904c141035d096169958cc4
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Nov 11 21:01:03 2013 +0100

    m68k: Simplify low level interrupt handling code
    
    The low level interrupt entry code of m68k contains the following:
    
        add_preempt_count(HARDIRQ_OFFSET);
    
        do_IRQ();
            irq_enter();
                add_preempt_count(HARDIRQ_OFFSET);
            handle_interrupt();
            irq_exit();
                sub_preempt_count(HARDIRQ_OFFSET);
                if (in_interrupt())
                   return; <---- On m68k always taken!
                if (local_softirq_pending())
                   do_softirq();
    
        sub_preempt_count(HARDIRQ_OFFSET);
        if (in_hardirq())
           return;
        if (status_on_stack_has_interrupt_priority_mask > 0)
           return;
        if (local_softirq_pending())
           do_softirq();
    
        ret_from_exception:
            if (interrupted_context_is_kernel)
               return:
            ....
    
    I tried to find a proper explanation for this, but the changelog is
    sparse and there are no mails explaining it further. But obviously
    this relates to the interrupt priority levels of the m68k and tries to
    be extra clever with nested interrupts. Though this cleverness just
    adds code bloat to the interrupt hotpath.
    
    For the common case of non nested interrupts the code runs through two
    extra conditionals to the only important one, which checks whether the
    return is to kernel or user space.
    
    For the nested case the checks for in_hardirq() and the priority mask
    value on stack catch only the case where the nested interrupt happens
    inside the hard irq context of the first interrupt. If the nested
    interrupt happens while the first interrupt handles soft interrupts,
    then these extra checks buy nothing. The nested interrupt will fall
    through to the final kernel/user space return check at
    ret_from_exception.
    
    Changing the code flow in the following way:
    
        do_IRQ();
            irq_enter();
                add_preempt_count(HARDIRQ_OFFSET);
            handle_interrupt();
            irq_exit();
                sub_preempt_count(HARDIRQ_OFFSET);
                if (in_interrupt())
                   return;
                if (local_softirq_pending())
                   do_softirq();
    
        ret_from_exception:
            if (interrupted_context_is_kernel)
               return:
    
    makes the region protected by the hardirq count slightly smaller and
    the softirq handling is invoked with a minimal deeper stack. But
    otherwise it's completely functional equivalent and saves 104 bytes of
    text in arch/m68k/kernel/entry.o.
    
    This modification allows us further to get rid of the limitations
    which m68k puts on the preempt_count layout, so we can make the
    preempt count bits completely generic.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Tested-by: Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Linux/m68k <linux-m68k@vger.kernel.org>
    Cc: Andreas Schwab <schwab@linux-m68k.org>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.02.1311112052360.30673@ionos.tec.linutronix.de

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 4d7da384eea0..077d3a70fed1 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -58,12 +58,6 @@ void __init init_IRQ(void)
 {
 	int i;
 
-	/* assembly irq entry code relies on this... */
-	if (HARDIRQ_MASK != 0x00ff0000) {
-		extern void hardirq_mask_is_broken(void);
-		hardirq_mask_is_broken();
-	}
-
 	for (i = IRQ_AUTO_1; i <= IRQ_AUTO_7; i++)
 		irq_set_chip_and_handler(i, &auto_irq_chip, handle_simple_irq);
 

commit 378f7ca6aa2269519b825246e63f81f95f10a63b
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Mon Jun 3 12:53:01 2013 +0200

    m68k/irq: Vector ints need a valid interrupt handler
    
    To get vectored interrupts working we need to switch from the default
    handler handle_bad_irq() to something more sensible. Tested on a MVME177
    board.
    
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 6b32b64bac35..4d7da384eea0 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -101,7 +101,7 @@ void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt)
 	BUG_ON(IRQ_USER + cnt > NR_IRQS);
 	m68k_first_user_vec = vec;
 	for (i = 0; i < cnt; i++)
-		irq_set_chip(IRQ_USER + i, &user_irq_chip);
+		irq_set_chip_and_handler(i, &user_irq_chip, handle_simple_irq);
 	*user_irqvec_fixup = vec - IRQ_USER;
 	flush_icache();
 }

commit 803f69144f0d48863c68f9d111b56849c7cef5bb
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for M68K
    
    Disintegrate asm/system.h for M68K.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    cc: linux-m68k@lists.linux-m68k.org

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 74fefac00899..6b32b64bac35 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -15,7 +15,6 @@
 #include <linux/init.h>
 
 #include <asm/setup.h>
-#include <asm/system.h>
 #include <asm/irq.h>
 #include <asm/traps.h>
 #include <asm/page.h>

commit f30a6484f1bcb410d0af0c24f34b8e3d92682a05
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 11 11:54:50 2011 +0200

    m68k/irq: Remove obsolete support for user vector interrupt fixups
    
    It was used on Apollo only, before its conversion to genirq.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index e2b056b3a314..74fefac00899 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -28,7 +28,6 @@
 #endif
 
 extern u32 auto_irqhandler_fixup[];
-extern u32 user_irqhandler_fixup[];
 extern u16 user_irqvec_fixup[];
 
 static int m68k_first_user_vec;
@@ -91,16 +90,12 @@ void __init m68k_setup_auto_interrupt(void (*handler)(unsigned int, struct pt_re
  * m68k_setup_user_interrupt
  * @vec: first user vector interrupt to handle
  * @cnt: number of active user vector interrupts
- * @handler: called from user vector interrupts
  *
  * setup user vector interrupts, this includes activating the specified range
  * of interrupts, only then these interrupts can be requested (note: this is
- * different from auto vector interrupts). An optional handler can be installed
- * to be called instead of the default do_IRQ(), it will be called
- * with irq numbers starting from IRQ_USER.
+ * different from auto vector interrupts).
  */
-void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
-				      void (*handler)(unsigned int, struct pt_regs *))
+void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt)
 {
 	int i;
 
@@ -109,8 +104,6 @@ void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
 	for (i = 0; i < cnt; i++)
 		irq_set_chip(IRQ_USER + i, &user_irq_chip);
 	*user_irqvec_fixup = vec - IRQ_USER;
-	if (handler)
-		*user_irqhandler_fixup = (u32)handler;
 	flush_icache();
 }
 

commit d890d73995257b4e10cdd7d55bad80e34a71ba22
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 11 11:28:04 2011 +0200

    m68k/irq: Remove obsolete m68k irq framework
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index cea439f9819b..e2b056b3a314 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -31,20 +31,6 @@ extern u32 auto_irqhandler_fixup[];
 extern u32 user_irqhandler_fixup[];
 extern u16 user_irqvec_fixup[];
 
-#ifndef CONFIG_GENERIC_HARDIRQS
-/* table for system interrupt handlers */
-static struct irq_data *irq_list[NR_IRQS];
-static struct irq_chip *irq_chip[NR_IRQS];
-static int irq_depth[NR_IRQS];
-
-static inline int irq_set_chip(unsigned int irq, struct irq_chip *chip)
-{
-	irq_chip[irq] = chip;
-	return 0;
-}
-#define irq_set_chip_and_handler(irq, chip, dummy)	irq_set_chip(irq, chip)
-#endif /* !CONFIG_GENERIC_HARDIRQS */
-
 static int m68k_first_user_vec;
 
 static struct irq_chip auto_irq_chip = {
@@ -59,11 +45,6 @@ static struct irq_chip user_irq_chip = {
 	.irq_shutdown	= m68k_irq_shutdown,
 };
 
-#ifndef CONFIG_GENERIC_HARDIRQS
-#define NUM_IRQ_NODES 100
-static struct irq_data nodes[NUM_IRQ_NODES];
-#endif /* !CONFIG_GENERIC_HARDIRQS */
-
 /*
  * void init_IRQ(void)
  *
@@ -133,8 +114,6 @@ void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
 	flush_icache();
 }
 
-#ifdef CONFIG_GENERIC_HARDIRQS
-
 /**
  * m68k_setup_irq_controller
  * @chip: irq chip which controls specified irq
@@ -160,198 +139,6 @@ void m68k_setup_irq_controller(struct irq_chip *chip,
 	}
 }
 
-#else /* !CONFIG_GENERIC_HARDIRQS */
-
-/**
- * m68k_setup_irq_chip
- * @contr: irq controller which controls specified irq
- * @irq: first irq to be managed by the controller
- *
- * Change the controller for the specified range of irq, which will be used to
- * manage these irq. auto/user irq already have a default controller, which can
- * be changed as well, but the controller probably should use m68k_irq_startup/
- * m68k_irq_shutdown.
- */
-void m68k_setup_irq_chip(struct irq_chip *contr, unsigned int irq,
-			       unsigned int cnt)
-{
-	int i;
-
-	for (i = 0; i < cnt; i++)
-		irq_set_chip(irq + i, contr);
-}
-
-struct irq_data *new_irq_node(void)
-{
-	struct irq_data *node;
-	short i;
-
-	for (node = nodes, i = NUM_IRQ_NODES-1; i >= 0; node++, i--) {
-		if (!node->handler) {
-			memset(node, 0, sizeof(*node));
-			return node;
-		}
-	}
-
-	printk ("new_irq_node: out of nodes\n");
-	return NULL;
-}
-
-static int m68k_setup_irq(unsigned int irq, struct irq_data *node)
-{
-	struct irq_chip *contr;
-	struct irq_data **prev;
-	unsigned long flags;
-
-	if (irq >= NR_IRQS || !(contr = irq_chip[irq])) {
-		printk("%s: Incorrect IRQ %d from %s\n",
-		       __func__, irq, node->devname);
-		return -ENXIO;
-	}
-
-	local_irq_save(flags);
-
-	prev = irq_list + irq;
-	if (*prev) {
-		/* Can't share interrupts unless both agree to */
-		if (!((*prev)->flags & node->flags & IRQF_SHARED)) {
-			local_irq_restore(flags);
-			return -EBUSY;
-		}
-		while (*prev)
-			prev = &(*prev)->next;
-	}
-
-	if (!irq_list[irq]) {
-		if (contr->irq_startup)
-			contr->irq_startup(node);
-		else
-			contr->irq_enable(node);
-	}
-	node->next = NULL;
-	*prev = node;
-
-	local_irq_restore(flags);
-
-	return 0;
-}
-
-int request_irq(unsigned int irq,
-		irq_handler_t handler,
-		unsigned long flags, const char *devname, void *dev_id)
-{
-	struct irq_data *node;
-	int res;
-
-	node = new_irq_node();
-	if (!node)
-		return -ENOMEM;
-
-	node->irq     = irq;
-	node->handler = handler;
-	node->flags   = flags;
-	node->dev_id  = dev_id;
-	node->devname = devname;
-
-	res = m68k_setup_irq(irq, node);
-	if (res)
-		node->handler = NULL;
-
-	return res;
-}
-
-EXPORT_SYMBOL(request_irq);
-
-void free_irq(unsigned int irq, void *dev_id)
-{
-	struct irq_chip *contr;
-	struct irq_data **p, *node;
-	unsigned long flags;
-
-	if (irq >= NR_IRQS || !(contr = irq_chip[irq])) {
-		printk("%s: Incorrect IRQ %d\n", __func__, irq);
-		return;
-	}
-
-	local_irq_save(flags);
-
-	p = irq_list + irq;
-	while ((node = *p)) {
-		if (node->dev_id == dev_id)
-			break;
-		p = &node->next;
-	}
-
-	if (node) {
-		*p = node->next;
-		node->handler = NULL;
-	} else
-		printk("%s: Removing probably wrong IRQ %d\n",
-		       __func__, irq);
-
-	if (!irq_list[irq]) {
-		if (contr->irq_shutdown)
-			contr->irq_shutdown(node);
-		else
-			contr->irq_disable(node);
-	}
-
-	local_irq_restore(flags);
-}
-
-EXPORT_SYMBOL(free_irq);
-
-void enable_irq(unsigned int irq)
-{
-	struct irq_chip *contr;
-	unsigned long flags;
-
-	if (irq >= NR_IRQS || !(contr = irq_chip[irq])) {
-		printk("%s: Incorrect IRQ %d\n",
-		       __func__, irq);
-		return;
-	}
-
-	local_irq_save(flags);
-	if (irq_depth[irq]) {
-		if (!--irq_depth[irq]) {
-			if (contr->irq_enable)
-				contr->irq_enable(irq_list[irq]);
-		}
-	} else
-		WARN_ON(1);
-	local_irq_restore(flags);
-}
-
-EXPORT_SYMBOL(enable_irq);
-
-void disable_irq(unsigned int irq)
-{
-	struct irq_chip *contr;
-	unsigned long flags;
-
-	if (irq >= NR_IRQS || !(contr = irq_chip[irq])) {
-		printk("%s: Incorrect IRQ %d\n",
-		       __func__, irq);
-		return;
-	}
-
-	local_irq_save(flags);
-	if (!irq_depth[irq]++) {
-		if (contr->irq_disable)
-			contr->irq_disable(irq_list[irq]);
-	}
-	local_irq_restore(flags);
-}
-
-EXPORT_SYMBOL(disable_irq);
-
-void disable_irq_nosync(unsigned int irq) __attribute__((alias("disable_irq")));
-
-EXPORT_SYMBOL(disable_irq_nosync);
-
-#endif /* !CONFIG_GENERIC_HARDIRQS */
-
 unsigned int m68k_irq_startup_irq(unsigned int irq)
 {
 	if (irq <= IRQ_AUTO_7)
@@ -377,36 +164,6 @@ void m68k_irq_shutdown(struct irq_data *data)
 }
 
 
-#ifndef CONFIG_GENERIC_HARDIRQS
-
-/*
- * Do we need these probe functions on the m68k?
- *
- *  ... may be useful with ISA devices
- */
-unsigned long probe_irq_on (void)
-{
-#ifdef CONFIG_Q40
-	if (MACH_IS_Q40)
-		return q40_probe_irq_on();
-#endif
-	return 0;
-}
-
-EXPORT_SYMBOL(probe_irq_on);
-
-int probe_irq_off (unsigned long irqs)
-{
-#ifdef CONFIG_Q40
-	if (MACH_IS_Q40)
-		return q40_probe_irq_off(irqs);
-#endif
-	return 0;
-}
-
-EXPORT_SYMBOL(probe_irq_off);
-#endif /* CONFIG_GENERIC_HARDIRQS */
-
 unsigned int irq_canonicalize(unsigned int irq)
 {
 #ifdef CONFIG_Q40
@@ -418,63 +175,9 @@ unsigned int irq_canonicalize(unsigned int irq)
 
 EXPORT_SYMBOL(irq_canonicalize);
 
-#ifndef CONFIG_GENERIC_HARDIRQS
-void generic_handle_irq(unsigned int irq)
-{
-	struct irq_data *node;
-	kstat_cpu(0).irqs[irq]++;
-	node = irq_list[irq];
-	do {
-		node->handler(irq, node->dev_id);
-		node = node->next;
-	} while (node);
-}
-
-asmlinkage void do_IRQ(int irq, struct pt_regs *regs)
-{
-	struct pt_regs *old_regs;
-	old_regs = set_irq_regs(regs);
-	generic_handle_irq(irq);
-	set_irq_regs(old_regs);
-}
-
-asmlinkage void handle_badint(struct pt_regs *regs)
-{
-	kstat_cpu(0).irqs[0]++;
-	printk("unexpected interrupt from %u\n", regs->vector);
-}
-
-int show_interrupts(struct seq_file *p, void *v)
-{
-	struct irq_chip *contr;
-	struct irq_data *node;
-	int i = *(loff_t *) v;
-
-	/* autovector interrupts */
-	if (irq_list[i]) {
-		contr = irq_chip[i];
-		node = irq_list[i];
-		seq_printf(p, "%-8s %3u: %10u %s", contr->name, i, kstat_cpu(0).irqs[i], node->devname);
-		while ((node = node->next))
-			seq_printf(p, ", %s", node->devname);
-		seq_puts(p, "\n");
-	}
-	return 0;
-}
-
-#ifdef CONFIG_PROC_FS
-void init_irq_proc(void)
-{
-	/* Insert /proc/irq driver here */
-}
-#endif
-
-#else /* CONFIG_GENERIC_HARDIRQS */
 
 asmlinkage void handle_badint(struct pt_regs *regs)
 {
 	atomic_inc(&irq_err_count);
 	pr_warn("unexpected interrupt from %u\n", regs->vector);
 }
-
-#endif /* CONFIG_GENERIC_HARDIRQS */

commit 4936f63cb790e265eb30a1e1630bb90bd6af0e7a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Apr 21 22:50:52 2011 +0200

    m68k/irq: Add genirq support
    
    Disabled on all platforms for now
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    [v1] Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index f6a469865125..cea439f9819b 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -31,6 +31,7 @@ extern u32 auto_irqhandler_fixup[];
 extern u32 user_irqhandler_fixup[];
 extern u16 user_irqvec_fixup[];
 
+#ifndef CONFIG_GENERIC_HARDIRQS
 /* table for system interrupt handlers */
 static struct irq_data *irq_list[NR_IRQS];
 static struct irq_chip *irq_chip[NR_IRQS];
@@ -41,6 +42,8 @@ static inline int irq_set_chip(unsigned int irq, struct irq_chip *chip)
 	irq_chip[irq] = chip;
 	return 0;
 }
+#define irq_set_chip_and_handler(irq, chip, dummy)	irq_set_chip(irq, chip)
+#endif /* !CONFIG_GENERIC_HARDIRQS */
 
 static int m68k_first_user_vec;
 
@@ -56,8 +59,10 @@ static struct irq_chip user_irq_chip = {
 	.irq_shutdown	= m68k_irq_shutdown,
 };
 
+#ifndef CONFIG_GENERIC_HARDIRQS
 #define NUM_IRQ_NODES 100
 static struct irq_data nodes[NUM_IRQ_NODES];
+#endif /* !CONFIG_GENERIC_HARDIRQS */
 
 /*
  * void init_IRQ(void)
@@ -81,7 +86,7 @@ void __init init_IRQ(void)
 	}
 
 	for (i = IRQ_AUTO_1; i <= IRQ_AUTO_7; i++)
-		irq_set_chip(i, &auto_irq_chip);
+		irq_set_chip_and_handler(i, &auto_irq_chip, handle_simple_irq);
 
 	mach_init_IRQ();
 }
@@ -128,6 +133,35 @@ void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
 	flush_icache();
 }
 
+#ifdef CONFIG_GENERIC_HARDIRQS
+
+/**
+ * m68k_setup_irq_controller
+ * @chip: irq chip which controls specified irq
+ * @handle: flow handler which handles specified irq
+ * @irq: first irq to be managed by the controller
+ * @cnt: number of irqs to be managed by the controller
+ *
+ * Change the controller for the specified range of irq, which will be used to
+ * manage these irq. auto/user irq already have a default controller, which can
+ * be changed as well, but the controller probably should use m68k_irq_startup/
+ * m68k_irq_shutdown.
+ */
+void m68k_setup_irq_controller(struct irq_chip *chip,
+			       irq_flow_handler_t handle, unsigned int irq,
+			       unsigned int cnt)
+{
+	int i;
+
+	for (i = 0; i < cnt; i++) {
+		irq_set_chip(irq + i, chip);
+		if (handle)
+			irq_set_handler(irq + i, handle);
+	}
+}
+
+#else /* !CONFIG_GENERIC_HARDIRQS */
+
 /**
  * m68k_setup_irq_chip
  * @contr: irq controller which controls specified irq
@@ -316,6 +350,8 @@ void disable_irq_nosync(unsigned int irq) __attribute__((alias("disable_irq")));
 
 EXPORT_SYMBOL(disable_irq_nosync);
 
+#endif /* !CONFIG_GENERIC_HARDIRQS */
+
 unsigned int m68k_irq_startup_irq(unsigned int irq)
 {
 	if (irq <= IRQ_AUTO_7)
@@ -341,6 +377,8 @@ void m68k_irq_shutdown(struct irq_data *data)
 }
 
 
+#ifndef CONFIG_GENERIC_HARDIRQS
+
 /*
  * Do we need these probe functions on the m68k?
  *
@@ -367,6 +405,7 @@ int probe_irq_off (unsigned long irqs)
 }
 
 EXPORT_SYMBOL(probe_irq_off);
+#endif /* CONFIG_GENERIC_HARDIRQS */
 
 unsigned int irq_canonicalize(unsigned int irq)
 {
@@ -379,6 +418,7 @@ unsigned int irq_canonicalize(unsigned int irq)
 
 EXPORT_SYMBOL(irq_canonicalize);
 
+#ifndef CONFIG_GENERIC_HARDIRQS
 void generic_handle_irq(unsigned int irq)
 {
 	struct irq_data *node;
@@ -428,3 +468,13 @@ void init_irq_proc(void)
 	/* Insert /proc/irq driver here */
 }
 #endif
+
+#else /* CONFIG_GENERIC_HARDIRQS */
+
+asmlinkage void handle_badint(struct pt_regs *regs)
+{
+	atomic_inc(&irq_err_count);
+	pr_warn("unexpected interrupt from %u\n", regs->vector);
+}
+
+#endif /* CONFIG_GENERIC_HARDIRQS */

commit 5a2394534b160ce18f9a705cf9de40e77648f8a2
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jul 13 22:33:13 2011 +0200

    m68k/irq: Remove obsolete IRQ_FLG_* users
    
    The m68k core irq code stopped honoring these flags during the irq
    restructuring in 2006.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 15dbbe297334..f6a469865125 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -4,25 +4,6 @@
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file COPYING in the main directory of this archive
  * for more details.
- *
- * 07/03/96: Timer initialization, and thus mach_sched_init(),
- *           removed from request_irq() and moved to init_time().
- *           We should therefore consider renaming our add_isr() and
- *           remove_isr() to request_irq() and free_irq()
- *           respectively, so they are compliant with the other
- *           architectures.                                     /Jes
- * 11/07/96: Changed all add_/remove_isr() to request_/free_irq() calls.
- *           Removed irq list support, if any machine needs an irq server
- *           it must implement this itself (as it's already done), instead
- *           only default handler are used with mach_default_handler.
- *           request_irq got some flags different from other architectures:
- *           - IRQ_FLG_REPLACE : Replace an existing handler (the default one
- *                               can be replaced without this flag)
- *           - IRQ_FLG_LOCK : handler can't be replaced
- *           There are other machine depending flags, see there
- *           If you want to replace a default handler you should know what
- *           you're doing, since it might handle different other irq sources
- *           which must be served                               /Roman Zippel
  */
 
 #include <linux/module.h>

commit 1425df87c25b15400c9f26d57821bcfe01286b2a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Jul 1 20:39:19 2011 +0200

    m68k/irq: Rename {,__}m68k_handle_int()
    
      - Rename m68k_handle_int() to generic_handle_irq(), and drop the unneeded
        asmlinkage,
      - Rename __m68k_handle_int() to do_IRQ().
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 4f9868e160bd..15dbbe297334 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -110,7 +110,7 @@ void __init init_IRQ(void)
  * @handler: called from auto vector interrupts
  *
  * setup the handler to be called from auto vector interrupts instead of the
- * standard __m68k_handle_int(), it will be called with irq numbers in the range
+ * standard do_IRQ(), it will be called with irq numbers in the range
  * from IRQ_AUTO_1 - IRQ_AUTO_7.
  */
 void __init m68k_setup_auto_interrupt(void (*handler)(unsigned int, struct pt_regs *))
@@ -129,7 +129,7 @@ void __init m68k_setup_auto_interrupt(void (*handler)(unsigned int, struct pt_re
  * setup user vector interrupts, this includes activating the specified range
  * of interrupts, only then these interrupts can be requested (note: this is
  * different from auto vector interrupts). An optional handler can be installed
- * to be called instead of the default __m68k_handle_int(), it will be called
+ * to be called instead of the default do_IRQ(), it will be called
  * with irq numbers starting from IRQ_USER.
  */
 void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
@@ -398,7 +398,7 @@ unsigned int irq_canonicalize(unsigned int irq)
 
 EXPORT_SYMBOL(irq_canonicalize);
 
-asmlinkage void m68k_handle_int(unsigned int irq)
+void generic_handle_irq(unsigned int irq)
 {
 	struct irq_data *node;
 	kstat_cpu(0).irqs[irq]++;
@@ -409,11 +409,11 @@ asmlinkage void m68k_handle_int(unsigned int irq)
 	} while (node);
 }
 
-asmlinkage void __m68k_handle_int(unsigned int irq, struct pt_regs *regs)
+asmlinkage void do_IRQ(int irq, struct pt_regs *regs)
 {
 	struct pt_regs *old_regs;
 	old_regs = set_irq_regs(regs);
-	m68k_handle_int(irq);
+	generic_handle_irq(irq);
 	set_irq_regs(old_regs);
 }
 

commit 40a72c8f711bdf8ae3e4f945261ced5432dcac4d
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri May 27 22:33:41 2011 +0200

    m68k/irq: Extract irq_set_chip()
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index e68a3bd5de6e..4f9868e160bd 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -55,6 +55,12 @@ static struct irq_data *irq_list[NR_IRQS];
 static struct irq_chip *irq_chip[NR_IRQS];
 static int irq_depth[NR_IRQS];
 
+static inline int irq_set_chip(unsigned int irq, struct irq_chip *chip)
+{
+	irq_chip[irq] = chip;
+	return 0;
+}
+
 static int m68k_first_user_vec;
 
 static struct irq_chip auto_irq_chip = {
@@ -94,7 +100,7 @@ void __init init_IRQ(void)
 	}
 
 	for (i = IRQ_AUTO_1; i <= IRQ_AUTO_7; i++)
-		irq_chip[i] = &auto_irq_chip;
+		irq_set_chip(i, &auto_irq_chip);
 
 	mach_init_IRQ();
 }
@@ -134,7 +140,7 @@ void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
 	BUG_ON(IRQ_USER + cnt > NR_IRQS);
 	m68k_first_user_vec = vec;
 	for (i = 0; i < cnt; i++)
-		irq_chip[IRQ_USER + i] = &user_irq_chip;
+		irq_set_chip(IRQ_USER + i, &user_irq_chip);
 	*user_irqvec_fixup = vec - IRQ_USER;
 	if (handler)
 		*user_irqhandler_fixup = (u32)handler;
@@ -157,7 +163,7 @@ void m68k_setup_irq_chip(struct irq_chip *contr, unsigned int irq,
 	int i;
 
 	for (i = 0; i < cnt; i++)
-		irq_chip[irq + i] = contr;
+		irq_set_chip(irq + i, contr);
 }
 
 struct irq_data *new_irq_node(void)

commit 13d6da35813babaa1bc8c6799b2666191911100e
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Apr 19 20:10:53 2011 +0200

    m68k/irq: Rename setup_irq() to m68k_setup_irq() and make it static
    
    It has nothing to do with the standard one in <linux/irq.h>
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 404d832f5d35..e68a3bd5de6e 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -176,7 +176,7 @@ struct irq_data *new_irq_node(void)
 	return NULL;
 }
 
-int setup_irq(unsigned int irq, struct irq_data *node)
+static int m68k_setup_irq(unsigned int irq, struct irq_data *node)
 {
 	struct irq_chip *contr;
 	struct irq_data **prev;
@@ -232,7 +232,7 @@ int request_irq(unsigned int irq,
 	node->dev_id  = dev_id;
 	node->devname = devname;
 
-	res = setup_irq(irq, node);
+	res = m68k_setup_irq(irq, node);
 	if (res)
 		node->handler = NULL;
 

commit e8abf5e73cdb6c034d35ccba1f63a4801cd3dec5
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 17 22:53:04 2011 +0200

    m68k/irq: Switch irq_chip methods to "struct irq_data *data"
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 88779320d406..404d832f5d35 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -203,9 +203,9 @@ int setup_irq(unsigned int irq, struct irq_data *node)
 
 	if (!irq_list[irq]) {
 		if (contr->irq_startup)
-			contr->irq_startup(irq);
+			contr->irq_startup(node);
 		else
-			contr->irq_enable(irq);
+			contr->irq_enable(node);
 	}
 	node->next = NULL;
 	*prev = node;
@@ -270,9 +270,9 @@ void free_irq(unsigned int irq, void *dev_id)
 
 	if (!irq_list[irq]) {
 		if (contr->irq_shutdown)
-			contr->irq_shutdown(irq);
+			contr->irq_shutdown(node);
 		else
-			contr->irq_disable(irq);
+			contr->irq_disable(node);
 	}
 
 	local_irq_restore(flags);
@@ -295,7 +295,7 @@ void enable_irq(unsigned int irq)
 	if (irq_depth[irq]) {
 		if (!--irq_depth[irq]) {
 			if (contr->irq_enable)
-				contr->irq_enable(irq);
+				contr->irq_enable(irq_list[irq]);
 		}
 	} else
 		WARN_ON(1);
@@ -318,7 +318,7 @@ void disable_irq(unsigned int irq)
 	local_irq_save(flags);
 	if (!irq_depth[irq]++) {
 		if (contr->irq_disable)
-			contr->irq_disable(irq);
+			contr->irq_disable(irq_list[irq]);
 	}
 	local_irq_restore(flags);
 }
@@ -329,7 +329,7 @@ void disable_irq_nosync(unsigned int irq) __attribute__((alias("disable_irq")));
 
 EXPORT_SYMBOL(disable_irq_nosync);
 
-unsigned int m68k_irq_startup(unsigned int irq)
+unsigned int m68k_irq_startup_irq(unsigned int irq)
 {
 	if (irq <= IRQ_AUTO_7)
 		vectors[VEC_SPUR + irq] = auto_inthandler;
@@ -338,8 +338,15 @@ unsigned int m68k_irq_startup(unsigned int irq)
 	return 0;
 }
 
-void m68k_irq_shutdown(unsigned int irq)
+unsigned int m68k_irq_startup(struct irq_data *data)
 {
+	return m68k_irq_startup_irq(data->irq);
+}
+
+void m68k_irq_shutdown(struct irq_data *data)
+{
+	unsigned int irq = data->irq;
+
 	if (irq <= IRQ_AUTO_7)
 		vectors[VEC_SPUR + irq] = bad_inthandler;
 	else

commit 6549d537922da6a6893e9bc1be9c2b89db663719
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 17 21:59:23 2011 +0200

    m68k/irq: Rename irq_node to irq_data
    
    Make it more similar to the genirq version:
      - Add an irq field
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 9de8eb4eaefb..88779320d406 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -51,7 +51,7 @@ extern u32 user_irqhandler_fixup[];
 extern u16 user_irqvec_fixup[];
 
 /* table for system interrupt handlers */
-static struct irq_node *irq_list[NR_IRQS];
+static struct irq_data *irq_list[NR_IRQS];
 static struct irq_chip *irq_chip[NR_IRQS];
 static int irq_depth[NR_IRQS];
 
@@ -70,7 +70,7 @@ static struct irq_chip user_irq_chip = {
 };
 
 #define NUM_IRQ_NODES 100
-static struct irq_node nodes[NUM_IRQ_NODES];
+static struct irq_data nodes[NUM_IRQ_NODES];
 
 /*
  * void init_IRQ(void)
@@ -160,9 +160,9 @@ void m68k_setup_irq_chip(struct irq_chip *contr, unsigned int irq,
 		irq_chip[irq + i] = contr;
 }
 
-struct irq_node *new_irq_node(void)
+struct irq_data *new_irq_node(void)
 {
-	struct irq_node *node;
+	struct irq_data *node;
 	short i;
 
 	for (node = nodes, i = NUM_IRQ_NODES-1; i >= 0; node++, i--) {
@@ -176,10 +176,10 @@ struct irq_node *new_irq_node(void)
 	return NULL;
 }
 
-int setup_irq(unsigned int irq, struct irq_node *node)
+int setup_irq(unsigned int irq, struct irq_data *node)
 {
 	struct irq_chip *contr;
-	struct irq_node **prev;
+	struct irq_data **prev;
 	unsigned long flags;
 
 	if (irq >= NR_IRQS || !(contr = irq_chip[irq])) {
@@ -219,13 +219,14 @@ int request_irq(unsigned int irq,
 		irq_handler_t handler,
 		unsigned long flags, const char *devname, void *dev_id)
 {
-	struct irq_node *node;
+	struct irq_data *node;
 	int res;
 
 	node = new_irq_node();
 	if (!node)
 		return -ENOMEM;
 
+	node->irq     = irq;
 	node->handler = handler;
 	node->flags   = flags;
 	node->dev_id  = dev_id;
@@ -243,7 +244,7 @@ EXPORT_SYMBOL(request_irq);
 void free_irq(unsigned int irq, void *dev_id)
 {
 	struct irq_chip *contr;
-	struct irq_node **p, *node;
+	struct irq_data **p, *node;
 	unsigned long flags;
 
 	if (irq >= NR_IRQS || !(contr = irq_chip[irq])) {
@@ -386,7 +387,7 @@ EXPORT_SYMBOL(irq_canonicalize);
 
 asmlinkage void m68k_handle_int(unsigned int irq)
 {
-	struct irq_node *node;
+	struct irq_data *node;
 	kstat_cpu(0).irqs[irq]++;
 	node = irq_list[irq];
 	do {
@@ -412,7 +413,7 @@ asmlinkage void handle_badint(struct pt_regs *regs)
 int show_interrupts(struct seq_file *p, void *v)
 {
 	struct irq_chip *contr;
-	struct irq_node *node;
+	struct irq_data *node;
 	int i = *(loff_t *) v;
 
 	/* autovector interrupts */

commit 0dde595be678c06e7de27c98f45403088f1b126a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 17 21:39:08 2011 +0200

    m68k/irq: Kill irq_node_t typedef, always use struct irq_node
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index f43ad7b93ab6..9de8eb4eaefb 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -70,7 +70,7 @@ static struct irq_chip user_irq_chip = {
 };
 
 #define NUM_IRQ_NODES 100
-static irq_node_t nodes[NUM_IRQ_NODES];
+static struct irq_node nodes[NUM_IRQ_NODES];
 
 /*
  * void init_IRQ(void)
@@ -160,9 +160,9 @@ void m68k_setup_irq_chip(struct irq_chip *contr, unsigned int irq,
 		irq_chip[irq + i] = contr;
 }
 
-irq_node_t *new_irq_node(void)
+struct irq_node *new_irq_node(void)
 {
-	irq_node_t *node;
+	struct irq_node *node;
 	short i;
 
 	for (node = nodes, i = NUM_IRQ_NODES-1; i >= 0; node++, i--) {

commit c288bf2533e57174b90b07860c4391bcd1ea269c
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Apr 13 22:31:28 2011 +0200

    m68k/irq: Rename irq_controller to irq_chip
    
    Make it more similar to the genirq version:
      - Remove lock (unused as we don't do SMP anyway),
      - Prepend methods with irq_,
      - Make irq_startup() return unsigned int.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 761ee0440c99..f43ad7b93ab6 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -52,23 +52,21 @@ extern u16 user_irqvec_fixup[];
 
 /* table for system interrupt handlers */
 static struct irq_node *irq_list[NR_IRQS];
-static struct irq_controller *irq_controller[NR_IRQS];
+static struct irq_chip *irq_chip[NR_IRQS];
 static int irq_depth[NR_IRQS];
 
 static int m68k_first_user_vec;
 
-static struct irq_controller auto_irq_controller = {
+static struct irq_chip auto_irq_chip = {
 	.name		= "auto",
-	.lock		= __SPIN_LOCK_UNLOCKED(auto_irq_controller.lock),
-	.startup	= m68k_irq_startup,
-	.shutdown	= m68k_irq_shutdown,
+	.irq_startup	= m68k_irq_startup,
+	.irq_shutdown	= m68k_irq_shutdown,
 };
 
-static struct irq_controller user_irq_controller = {
+static struct irq_chip user_irq_chip = {
 	.name		= "user",
-	.lock		= __SPIN_LOCK_UNLOCKED(user_irq_controller.lock),
-	.startup	= m68k_irq_startup,
-	.shutdown	= m68k_irq_shutdown,
+	.irq_startup	= m68k_irq_startup,
+	.irq_shutdown	= m68k_irq_shutdown,
 };
 
 #define NUM_IRQ_NODES 100
@@ -96,7 +94,7 @@ void __init init_IRQ(void)
 	}
 
 	for (i = IRQ_AUTO_1; i <= IRQ_AUTO_7; i++)
-		irq_controller[i] = &auto_irq_controller;
+		irq_chip[i] = &auto_irq_chip;
 
 	mach_init_IRQ();
 }
@@ -136,7 +134,7 @@ void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
 	BUG_ON(IRQ_USER + cnt > NR_IRQS);
 	m68k_first_user_vec = vec;
 	for (i = 0; i < cnt; i++)
-		irq_controller[IRQ_USER + i] = &user_irq_controller;
+		irq_chip[IRQ_USER + i] = &user_irq_chip;
 	*user_irqvec_fixup = vec - IRQ_USER;
 	if (handler)
 		*user_irqhandler_fixup = (u32)handler;
@@ -144,7 +142,7 @@ void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
 }
 
 /**
- * m68k_setup_irq_controller
+ * m68k_setup_irq_chip
  * @contr: irq controller which controls specified irq
  * @irq: first irq to be managed by the controller
  *
@@ -153,13 +151,13 @@ void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
  * be changed as well, but the controller probably should use m68k_irq_startup/
  * m68k_irq_shutdown.
  */
-void m68k_setup_irq_controller(struct irq_controller *contr, unsigned int irq,
+void m68k_setup_irq_chip(struct irq_chip *contr, unsigned int irq,
 			       unsigned int cnt)
 {
 	int i;
 
 	for (i = 0; i < cnt; i++)
-		irq_controller[irq + i] = contr;
+		irq_chip[irq + i] = contr;
 }
 
 irq_node_t *new_irq_node(void)
@@ -180,23 +178,23 @@ irq_node_t *new_irq_node(void)
 
 int setup_irq(unsigned int irq, struct irq_node *node)
 {
-	struct irq_controller *contr;
+	struct irq_chip *contr;
 	struct irq_node **prev;
 	unsigned long flags;
 
-	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
+	if (irq >= NR_IRQS || !(contr = irq_chip[irq])) {
 		printk("%s: Incorrect IRQ %d from %s\n",
 		       __func__, irq, node->devname);
 		return -ENXIO;
 	}
 
-	spin_lock_irqsave(&contr->lock, flags);
+	local_irq_save(flags);
 
 	prev = irq_list + irq;
 	if (*prev) {
 		/* Can't share interrupts unless both agree to */
 		if (!((*prev)->flags & node->flags & IRQF_SHARED)) {
-			spin_unlock_irqrestore(&contr->lock, flags);
+			local_irq_restore(flags);
 			return -EBUSY;
 		}
 		while (*prev)
@@ -204,15 +202,15 @@ int setup_irq(unsigned int irq, struct irq_node *node)
 	}
 
 	if (!irq_list[irq]) {
-		if (contr->startup)
-			contr->startup(irq);
+		if (contr->irq_startup)
+			contr->irq_startup(irq);
 		else
-			contr->enable(irq);
+			contr->irq_enable(irq);
 	}
 	node->next = NULL;
 	*prev = node;
 
-	spin_unlock_irqrestore(&contr->lock, flags);
+	local_irq_restore(flags);
 
 	return 0;
 }
@@ -244,16 +242,16 @@ EXPORT_SYMBOL(request_irq);
 
 void free_irq(unsigned int irq, void *dev_id)
 {
-	struct irq_controller *contr;
+	struct irq_chip *contr;
 	struct irq_node **p, *node;
 	unsigned long flags;
 
-	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
+	if (irq >= NR_IRQS || !(contr = irq_chip[irq])) {
 		printk("%s: Incorrect IRQ %d\n", __func__, irq);
 		return;
 	}
 
-	spin_lock_irqsave(&contr->lock, flags);
+	local_irq_save(flags);
 
 	p = irq_list + irq;
 	while ((node = *p)) {
@@ -270,58 +268,58 @@ void free_irq(unsigned int irq, void *dev_id)
 		       __func__, irq);
 
 	if (!irq_list[irq]) {
-		if (contr->shutdown)
-			contr->shutdown(irq);
+		if (contr->irq_shutdown)
+			contr->irq_shutdown(irq);
 		else
-			contr->disable(irq);
+			contr->irq_disable(irq);
 	}
 
-	spin_unlock_irqrestore(&contr->lock, flags);
+	local_irq_restore(flags);
 }
 
 EXPORT_SYMBOL(free_irq);
 
 void enable_irq(unsigned int irq)
 {
-	struct irq_controller *contr;
+	struct irq_chip *contr;
 	unsigned long flags;
 
-	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
+	if (irq >= NR_IRQS || !(contr = irq_chip[irq])) {
 		printk("%s: Incorrect IRQ %d\n",
 		       __func__, irq);
 		return;
 	}
 
-	spin_lock_irqsave(&contr->lock, flags);
+	local_irq_save(flags);
 	if (irq_depth[irq]) {
 		if (!--irq_depth[irq]) {
-			if (contr->enable)
-				contr->enable(irq);
+			if (contr->irq_enable)
+				contr->irq_enable(irq);
 		}
 	} else
 		WARN_ON(1);
-	spin_unlock_irqrestore(&contr->lock, flags);
+	local_irq_restore(flags);
 }
 
 EXPORT_SYMBOL(enable_irq);
 
 void disable_irq(unsigned int irq)
 {
-	struct irq_controller *contr;
+	struct irq_chip *contr;
 	unsigned long flags;
 
-	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
+	if (irq >= NR_IRQS || !(contr = irq_chip[irq])) {
 		printk("%s: Incorrect IRQ %d\n",
 		       __func__, irq);
 		return;
 	}
 
-	spin_lock_irqsave(&contr->lock, flags);
+	local_irq_save(flags);
 	if (!irq_depth[irq]++) {
-		if (contr->disable)
-			contr->disable(irq);
+		if (contr->irq_disable)
+			contr->irq_disable(irq);
 	}
-	spin_unlock_irqrestore(&contr->lock, flags);
+	local_irq_restore(flags);
 }
 
 EXPORT_SYMBOL(disable_irq);
@@ -330,7 +328,7 @@ void disable_irq_nosync(unsigned int irq) __attribute__((alias("disable_irq")));
 
 EXPORT_SYMBOL(disable_irq_nosync);
 
-int m68k_irq_startup(unsigned int irq)
+unsigned int m68k_irq_startup(unsigned int irq)
 {
 	if (irq <= IRQ_AUTO_7)
 		vectors[VEC_SPUR + irq] = auto_inthandler;
@@ -413,13 +411,13 @@ asmlinkage void handle_badint(struct pt_regs *regs)
 
 int show_interrupts(struct seq_file *p, void *v)
 {
-	struct irq_controller *contr;
+	struct irq_chip *contr;
 	struct irq_node *node;
 	int i = *(loff_t *) v;
 
 	/* autovector interrupts */
 	if (irq_list[i]) {
-		contr = irq_controller[i];
+		contr = irq_chip[i];
 		node = irq_list[i];
 		seq_printf(p, "%-8s %3u: %10u %s", contr->name, i, kstat_cpu(0).irqs[i], node->devname);
 		while ((node = node->next))

commit 27123cbc264de89ce6951b1b4c84c223eb0f1702
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Nov 14 08:10:19 2008 +0100

    m68k: Fix off-by-one in m68k_setup_user_interrupt()
    
    commit 69961c375288bdab7604e0bb1c8d22999bb8a347 ("[PATCH] m68k/Atari:
    Interrupt updates") added a BUG_ON() with an incorrect upper bound
    comparison, which causes an early crash on VME boards, where IRQ_USER is
    8, cnt is 192 and NR_IRQS is 200.
    
    Reported-by: Stephen N Chivers <schivers@csc.com.au>
    Tested-by: Kars de Jong <jongk@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: stable@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 7e8a0d394e61..761ee0440c99 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -133,7 +133,7 @@ void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
 {
 	int i;
 
-	BUG_ON(IRQ_USER + cnt >= NR_IRQS);
+	BUG_ON(IRQ_USER + cnt > NR_IRQS);
 	m68k_first_user_vec = vec;
 	for (i = 0; i < cnt; i++)
 		irq_controller[IRQ_USER + i] = &user_irq_controller;

commit da9870e477492e0f837aa0cd26b2ac2e372b91d2
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Oct 13 21:59:01 2008 +0200

    m68k: init_irq_proc depends on CONFIG_PROC_FS
    
    If CONFIG_PROC_FS is not set, I get:
    
    | arch/m68k/kernel/ints.c:433: error: redefinition of 'init_irq_proc'
    | include/linux/interrupt.h:438: error: previous definition of 'init_irq_proc' was here
    
    This was introduced by commit 6168a702ab0be181e5e57a0b2d0e7376f7a47f0b
    ("Declare init_irq_proc before we use it."), which replaced the #ifdef
    protection of the init_irq_proc() call by a static inline dummy if
    CONFIG_PROC_FS is not set.
    
    Make init_irq_proc() depend on CONFIG_PROC_FS to fix this.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index ded7dd2f67b2..7e8a0d394e61 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -429,8 +429,9 @@ int show_interrupts(struct seq_file *p, void *v)
 	return 0;
 }
 
+#ifdef CONFIG_PROC_FS
 void init_irq_proc(void)
 {
 	/* Insert /proc/irq driver here */
 }
-
+#endif

commit f85e7cdc3fd0db65ef1442476b82ced0f01c5c19
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Apr 28 02:13:49 2008 -0700

    m68k: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 2b412454cb41..ded7dd2f67b2 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -186,7 +186,7 @@ int setup_irq(unsigned int irq, struct irq_node *node)
 
 	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
 		printk("%s: Incorrect IRQ %d from %s\n",
-		       __FUNCTION__, irq, node->devname);
+		       __func__, irq, node->devname);
 		return -ENXIO;
 	}
 
@@ -249,7 +249,7 @@ void free_irq(unsigned int irq, void *dev_id)
 	unsigned long flags;
 
 	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
-		printk("%s: Incorrect IRQ %d\n", __FUNCTION__, irq);
+		printk("%s: Incorrect IRQ %d\n", __func__, irq);
 		return;
 	}
 
@@ -267,7 +267,7 @@ void free_irq(unsigned int irq, void *dev_id)
 		node->handler = NULL;
 	} else
 		printk("%s: Removing probably wrong IRQ %d\n",
-		       __FUNCTION__, irq);
+		       __func__, irq);
 
 	if (!irq_list[irq]) {
 		if (contr->shutdown)
@@ -288,7 +288,7 @@ void enable_irq(unsigned int irq)
 
 	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
 		printk("%s: Incorrect IRQ %d\n",
-		       __FUNCTION__, irq);
+		       __func__, irq);
 		return;
 	}
 
@@ -312,7 +312,7 @@ void disable_irq(unsigned int irq)
 
 	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
 		printk("%s: Incorrect IRQ %d\n",
-		       __FUNCTION__, irq);
+		       __func__, irq);
 		return;
 	}
 

commit e9ed7e722e3f4cea07cf3c4bfe98c18180a17793
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Jul 21 23:29:12 2007 +0100

    take declarations of enable_irq() et.al. to linux/interrupt.h
    
    Now that the last inlined instances are gone, all that is left to do
    is turning disable_irq_nosync on arm26 and m68k from defines to aliases
    and we are all set - we can make these externs in linux/interrupt.h
    uncoditional and kill remaining instances in asm/irq.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 60d4d75f5798..2b412454cb41 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -326,6 +326,10 @@ void disable_irq(unsigned int irq)
 
 EXPORT_SYMBOL(disable_irq);
 
+void disable_irq_nosync(unsigned int irq) __attribute__((alias("disable_irq")));
+
+EXPORT_SYMBOL(disable_irq_nosync);
+
 int m68k_irq_startup(unsigned int irq)
 {
 	if (irq <= IRQ_AUTO_7)

commit 241258d1cc4d3551608364cd678d5a85239ad481
Author: Milind Arun Choudhary <milindchoudhary@gmail.com>
Date:   Sun May 6 14:50:54 2007 -0700

    SPIN_LOCK_UNLOCKED cleanup in arch/m68k
    
    SPIN_LOCK_UNLOCKED cleanup,use __SPIN_LOCK_UNLOCKED instead
    
    Signed-off-by: Milind Arun Choudhary <milindchoudhary@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index b66c97c904b3..60d4d75f5798 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -59,14 +59,14 @@ static int m68k_first_user_vec;
 
 static struct irq_controller auto_irq_controller = {
 	.name		= "auto",
-	.lock		= SPIN_LOCK_UNLOCKED,
+	.lock		= __SPIN_LOCK_UNLOCKED(auto_irq_controller.lock),
 	.startup	= m68k_irq_startup,
 	.shutdown	= m68k_irq_shutdown,
 };
 
 static struct irq_controller user_irq_controller = {
 	.name		= "user",
-	.lock		= SPIN_LOCK_UNLOCKED,
+	.lock		= __SPIN_LOCK_UNLOCKED(user_irq_controller.lock),
 	.startup	= m68k_irq_startup,
 	.shutdown	= m68k_irq_shutdown,
 };

commit 6168a702ab0be181e5e57a0b2d0e7376f7a47f0b
Author: Andrew Morton <akpm@osdl.org>
Date:   Sat Feb 17 21:22:39 2007 -0800

    [PATCH] Declare init_irq_proc before we use it.
    
    powerpc gets:
    
    init/main.c: In function `do_basic_setup':
    init/main.c:714: warning: implicit declaration of function `init_irq_proc'
    
    but we cannot include linux/irq.h in generic code.
    
    Fix it by moving the declaration into linux/interrupt.h instead.
    
    And make sure all code that defines init_irq_proc() is including
    linux/interrupt.h.
    
    And nuke an ifdef-in-C
    
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 84aceca6c05c..b66c97c904b3 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -28,6 +28,7 @@
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/sched.h>
+#include <linux/interrupt.h>
 #include <linux/kernel_stat.h>
 #include <linux/errno.h>
 #include <linux/init.h>

commit 69961c375288bdab7604e0bb1c8d22999bb8a347
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Oct 9 22:23:31 2006 +0200

    [PATCH] m68k/Atari: Interrupt updates
    
    Misc Atari fixes:
      - initialize correct number of atari irqs
      - silence vbl interrupt until it's used by atafb
      - use mdelay() to read clock if necessary
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 849c9488c7f8..84aceca6c05c 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -132,6 +132,7 @@ void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
 {
 	int i;
 
+	BUG_ON(IRQ_USER + cnt >= NR_IRQS);
 	m68k_first_user_vec = vec;
 	for (i = 0; i < cnt; i++)
 		irq_controller[IRQ_USER + i] = &user_irq_controller;

commit 40220c1a192f51695f806d75b1f9970f0f17a6e8
Author: David Howells <dhowells@redhat.com>
Date:   Mon Oct 9 12:19:47 2006 +0100

    IRQ: Use the new typedef for interrupt handler function pointers
    
    Use the new typedef for interrupt handler function pointers rather than
    actually spelling out the full thing each time.  This was scripted with the
    following small shell script:
    
    #!/bin/sh
    egrep -nHrl -e 'irqreturn_t[    ]*[(][*]' $* |
    while read i
    do
        echo $i
        perl -pi -e 's/irqreturn_t\s*[(]\s*[*]\s*([_a-zA-Z0-9]*)\s*[)]\s*[(]\s*int\s*,\s*void\s*[*]\s*[)]/irq_handler_t \1/g' $i || exit $?
    done
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 6fa893fc5fd6..849c9488c7f8 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -216,7 +216,7 @@ int setup_irq(unsigned int irq, struct irq_node *node)
 }
 
 int request_irq(unsigned int irq,
-		irqreturn_t (*handler) (int, void *),
+		irq_handler_t handler,
 		unsigned long flags, const char *devname, void *dev_id)
 {
 	struct irq_node *node;

commit 2850bc273776cbb1b510c5828e9e456dffb50a32
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Oct 7 14:16:45 2006 +0100

    [PATCH] m68k pt_regs fixes
    
    m68k_handle_int() split in two functions: __m68k_handle_int() takes
    pt_regs * and does set_irq_regs(); m68k_handle_int() doesn't get pt_regs
    *.
    
    Places where we used to call m68k_handle_int() recursively with the same
    pt_regs have simply lost the second argument, the rest is switched to
    __m68k_handle_int().
    
    The rest of patch is just dropping pt_regs * where needed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index b33e37fb7b0e..6fa893fc5fd6 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -39,6 +39,7 @@
 #include <asm/page.h>
 #include <asm/machdep.h>
 #include <asm/cacheflush.h>
+#include <asm/irq_regs.h>
 
 #ifdef CONFIG_Q40
 #include <asm/q40ints.h>
@@ -104,7 +105,7 @@ void __init init_IRQ(void)
  * @handler: called from auto vector interrupts
  *
  * setup the handler to be called from auto vector interrupts instead of the
- * standard m68k_handle_int(), it will be called with irq numbers in the range
+ * standard __m68k_handle_int(), it will be called with irq numbers in the range
  * from IRQ_AUTO_1 - IRQ_AUTO_7.
  */
 void __init m68k_setup_auto_interrupt(void (*handler)(unsigned int, struct pt_regs *))
@@ -123,7 +124,7 @@ void __init m68k_setup_auto_interrupt(void (*handler)(unsigned int, struct pt_re
  * setup user vector interrupts, this includes activating the specified range
  * of interrupts, only then these interrupts can be requested (note: this is
  * different from auto vector interrupts). An optional handler can be installed
- * to be called instead of the default m68k_handle_int(), it will be called
+ * to be called instead of the default __m68k_handle_int(), it will be called
  * with irq numbers starting from IRQ_USER.
  */
 void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
@@ -215,7 +216,7 @@ int setup_irq(unsigned int irq, struct irq_node *node)
 }
 
 int request_irq(unsigned int irq,
-		irqreturn_t (*handler) (int, void *, struct pt_regs *),
+		irqreturn_t (*handler) (int, void *),
 		unsigned long flags, const char *devname, void *dev_id)
 {
 	struct irq_node *node;
@@ -379,18 +380,25 @@ unsigned int irq_canonicalize(unsigned int irq)
 
 EXPORT_SYMBOL(irq_canonicalize);
 
-asmlinkage void m68k_handle_int(unsigned int irq, struct pt_regs *regs)
+asmlinkage void m68k_handle_int(unsigned int irq)
 {
 	struct irq_node *node;
-
 	kstat_cpu(0).irqs[irq]++;
 	node = irq_list[irq];
 	do {
-		node->handler(irq, node->dev_id, regs);
+		node->handler(irq, node->dev_id);
 		node = node->next;
 	} while (node);
 }
 
+asmlinkage void __m68k_handle_int(unsigned int irq, struct pt_regs *regs)
+{
+	struct pt_regs *old_regs;
+	old_regs = set_irq_regs(regs);
+	m68k_handle_int(irq);
+	set_irq_regs(old_regs);
+}
+
 asmlinkage void handle_badint(struct pt_regs *regs)
 {
 	kstat_cpu(0).irqs[0]++;

commit b0b9fdc123cf0f1b671ac3f593d77af325ad4cf3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:19 2006 -0700

    [PATCH] irq-flags: M68K: Use the new IRQF_ constants
    
    Use the new IRQF_ constants and remove the SA_INTERRUPT define
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index e969f0477640..b33e37fb7b0e 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -192,7 +192,7 @@ int setup_irq(unsigned int irq, struct irq_node *node)
 	prev = irq_list + irq;
 	if (*prev) {
 		/* Can't share interrupts unless both agree to */
-		if (!((*prev)->flags & node->flags & SA_SHIRQ)) {
+		if (!((*prev)->flags & node->flags & IRQF_SHARED)) {
 			spin_unlock_irqrestore(&contr->lock, flags);
 			return -EBUSY;
 		}

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 5a8344b93547..e969f0477640 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -25,7 +25,6 @@
  *           which must be served                               /Roman Zippel
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/types.h>
 #include <linux/sched.h>

commit 68387c448b7f2b3e2bfa0f606391cd3b602b1997
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:01 2006 -0700

    [PATCH] m68k: convert generic irq code to irq controller
    
    Convert the generic irq code to use irq controller, this gets rid of the
    machine specific callbacks and gives better control over irq handling without
    duplicating lots of code.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index c7f6ee67fd5a..5a8344b93547 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -39,14 +39,22 @@
 #include <asm/traps.h>
 #include <asm/page.h>
 #include <asm/machdep.h>
+#include <asm/cacheflush.h>
 
 #ifdef CONFIG_Q40
 #include <asm/q40ints.h>
 #endif
 
+extern u32 auto_irqhandler_fixup[];
+extern u32 user_irqhandler_fixup[];
+extern u16 user_irqvec_fixup[];
+
 /* table for system interrupt handlers */
-static struct irq_node *irq_list[SYS_IRQS];
-static struct irq_controller *irq_controller[SYS_IRQS];
+static struct irq_node *irq_list[NR_IRQS];
+static struct irq_controller *irq_controller[NR_IRQS];
+static int irq_depth[NR_IRQS];
+
+static int m68k_first_user_vec;
 
 static struct irq_controller auto_irq_controller = {
 	.name		= "auto",
@@ -55,39 +63,16 @@ static struct irq_controller auto_irq_controller = {
 	.shutdown	= m68k_irq_shutdown,
 };
 
-static const char *default_names[SYS_IRQS] = {
-	[0] = "spurious int",
-	[1] = "int1 handler",
-	[2] = "int2 handler",
-	[3] = "int3 handler",
-	[4] = "int4 handler",
-	[5] = "int5 handler",
-	[6] = "int6 handler",
-	[7] = "int7 handler"
+static struct irq_controller user_irq_controller = {
+	.name		= "user",
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.startup	= m68k_irq_startup,
+	.shutdown	= m68k_irq_shutdown,
 };
 
-/* The number of spurious interrupts */
-volatile unsigned int num_spurious;
-
 #define NUM_IRQ_NODES 100
 static irq_node_t nodes[NUM_IRQ_NODES];
 
-static void dummy_enable_irq(unsigned int irq);
-static void dummy_disable_irq(unsigned int irq);
-static int dummy_request_irq(unsigned int irq,
-		irqreturn_t (*handler) (int, void *, struct pt_regs *),
-		unsigned long flags, const char *devname, void *dev_id);
-static void dummy_free_irq(unsigned int irq, void *dev_id);
-
-void (*enable_irq) (unsigned int) = dummy_enable_irq;
-void (*disable_irq) (unsigned int) = dummy_disable_irq;
-
-int (*mach_request_irq) (unsigned int, irqreturn_t (*)(int, void *, struct pt_regs *),
-                      unsigned long, const char *, void *) = dummy_request_irq;
-void (*mach_free_irq) (unsigned int, void *) = dummy_free_irq;
-
-void init_irq_proc(void);
-
 /*
  * void init_IRQ(void)
  *
@@ -109,14 +94,70 @@ void __init init_IRQ(void)
 		hardirq_mask_is_broken();
 	}
 
-	for (i = IRQ_AUTO_1; i <= IRQ_AUTO_7; i++) {
+	for (i = IRQ_AUTO_1; i <= IRQ_AUTO_7; i++)
 		irq_controller[i] = &auto_irq_controller;
-		if (mach_default_handler && (*mach_default_handler)[i])
-			cpu_request_irq(i, (*mach_default_handler)[i],
-					0, default_names[i], NULL);
-	}
 
-	mach_init_IRQ ();
+	mach_init_IRQ();
+}
+
+/**
+ * m68k_setup_auto_interrupt
+ * @handler: called from auto vector interrupts
+ *
+ * setup the handler to be called from auto vector interrupts instead of the
+ * standard m68k_handle_int(), it will be called with irq numbers in the range
+ * from IRQ_AUTO_1 - IRQ_AUTO_7.
+ */
+void __init m68k_setup_auto_interrupt(void (*handler)(unsigned int, struct pt_regs *))
+{
+	if (handler)
+		*auto_irqhandler_fixup = (u32)handler;
+	flush_icache();
+}
+
+/**
+ * m68k_setup_user_interrupt
+ * @vec: first user vector interrupt to handle
+ * @cnt: number of active user vector interrupts
+ * @handler: called from user vector interrupts
+ *
+ * setup user vector interrupts, this includes activating the specified range
+ * of interrupts, only then these interrupts can be requested (note: this is
+ * different from auto vector interrupts). An optional handler can be installed
+ * to be called instead of the default m68k_handle_int(), it will be called
+ * with irq numbers starting from IRQ_USER.
+ */
+void __init m68k_setup_user_interrupt(unsigned int vec, unsigned int cnt,
+				      void (*handler)(unsigned int, struct pt_regs *))
+{
+	int i;
+
+	m68k_first_user_vec = vec;
+	for (i = 0; i < cnt; i++)
+		irq_controller[IRQ_USER + i] = &user_irq_controller;
+	*user_irqvec_fixup = vec - IRQ_USER;
+	if (handler)
+		*user_irqhandler_fixup = (u32)handler;
+	flush_icache();
+}
+
+/**
+ * m68k_setup_irq_controller
+ * @contr: irq controller which controls specified irq
+ * @irq: first irq to be managed by the controller
+ *
+ * Change the controller for the specified range of irq, which will be used to
+ * manage these irq. auto/user irq already have a default controller, which can
+ * be changed as well, but the controller probably should use m68k_irq_startup/
+ * m68k_irq_shutdown.
+ */
+void m68k_setup_irq_controller(struct irq_controller *contr, unsigned int irq,
+			       unsigned int cnt)
+{
+	int i;
+
+	for (i = 0; i < cnt; i++)
+		irq_controller[irq + i] = contr;
 }
 
 irq_node_t *new_irq_node(void)
@@ -135,34 +176,13 @@ irq_node_t *new_irq_node(void)
 	return NULL;
 }
 
-/*
- * We will keep these functions until I have convinced Linus to move
- * the declaration of them from include/linux/sched.h to
- * include/asm/irq.h.
- */
-int request_irq(unsigned int irq,
-		irqreturn_t (*handler) (int, void *, struct pt_regs *),
-		unsigned long flags, const char *devname, void *dev_id)
-{
-	return mach_request_irq(irq, handler, flags, devname, dev_id);
-}
-
-EXPORT_SYMBOL(request_irq);
-
-void free_irq(unsigned int irq, void *dev_id)
-{
-	mach_free_irq(irq, dev_id);
-}
-
-EXPORT_SYMBOL(free_irq);
-
 int setup_irq(unsigned int irq, struct irq_node *node)
 {
 	struct irq_controller *contr;
 	struct irq_node **prev;
 	unsigned long flags;
 
-	if (irq >= SYS_IRQS || !(contr = irq_controller[irq])) {
+	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
 		printk("%s: Incorrect IRQ %d from %s\n",
 		       __FUNCTION__, irq, node->devname);
 		return -ENXIO;
@@ -195,9 +215,9 @@ int setup_irq(unsigned int irq, struct irq_node *node)
 	return 0;
 }
 
-int cpu_request_irq(unsigned int irq,
-                    irqreturn_t (*handler)(int, void *, struct pt_regs *),
-                    unsigned long flags, const char *devname, void *dev_id)
+int request_irq(unsigned int irq,
+		irqreturn_t (*handler) (int, void *, struct pt_regs *),
+		unsigned long flags, const char *devname, void *dev_id)
 {
 	struct irq_node *node;
 	int res;
@@ -218,13 +238,15 @@ int cpu_request_irq(unsigned int irq,
 	return res;
 }
 
-void cpu_free_irq(unsigned int irq, void *dev_id)
+EXPORT_SYMBOL(request_irq);
+
+void free_irq(unsigned int irq, void *dev_id)
 {
 	struct irq_controller *contr;
 	struct irq_node **p, *node;
 	unsigned long flags;
 
-	if (irq >= SYS_IRQS || !(contr = irq_controller[irq])) {
+	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
 		printk("%s: Incorrect IRQ %d\n", __FUNCTION__, irq);
 		return;
 	}
@@ -245,16 +267,69 @@ void cpu_free_irq(unsigned int irq, void *dev_id)
 		printk("%s: Removing probably wrong IRQ %d\n",
 		       __FUNCTION__, irq);
 
-	if (!irq_list[irq])
-		contr->shutdown(irq);
+	if (!irq_list[irq]) {
+		if (contr->shutdown)
+			contr->shutdown(irq);
+		else
+			contr->disable(irq);
+	}
+
+	spin_unlock_irqrestore(&contr->lock, flags);
+}
+
+EXPORT_SYMBOL(free_irq);
+
+void enable_irq(unsigned int irq)
+{
+	struct irq_controller *contr;
+	unsigned long flags;
+
+	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
+		printk("%s: Incorrect IRQ %d\n",
+		       __FUNCTION__, irq);
+		return;
+	}
+
+	spin_lock_irqsave(&contr->lock, flags);
+	if (irq_depth[irq]) {
+		if (!--irq_depth[irq]) {
+			if (contr->enable)
+				contr->enable(irq);
+		}
+	} else
+		WARN_ON(1);
+	spin_unlock_irqrestore(&contr->lock, flags);
+}
+
+EXPORT_SYMBOL(enable_irq);
 
+void disable_irq(unsigned int irq)
+{
+	struct irq_controller *contr;
+	unsigned long flags;
+
+	if (irq >= NR_IRQS || !(contr = irq_controller[irq])) {
+		printk("%s: Incorrect IRQ %d\n",
+		       __FUNCTION__, irq);
+		return;
+	}
+
+	spin_lock_irqsave(&contr->lock, flags);
+	if (!irq_depth[irq]++) {
+		if (contr->disable)
+			contr->disable(irq);
+	}
 	spin_unlock_irqrestore(&contr->lock, flags);
 }
 
+EXPORT_SYMBOL(disable_irq);
+
 int m68k_irq_startup(unsigned int irq)
 {
 	if (irq <= IRQ_AUTO_7)
 		vectors[VEC_SPUR + irq] = auto_inthandler;
+	else
+		vectors[m68k_first_user_vec + irq - IRQ_USER] = user_inthandler;
 	return 0;
 }
 
@@ -262,6 +337,8 @@ void m68k_irq_shutdown(unsigned int irq)
 {
 	if (irq <= IRQ_AUTO_7)
 		vectors[VEC_SPUR + irq] = bad_inthandler;
+	else
+		vectors[m68k_first_user_vec + irq - IRQ_USER] = bad_inthandler;
 }
 
 
@@ -292,28 +369,16 @@ int probe_irq_off (unsigned long irqs)
 
 EXPORT_SYMBOL(probe_irq_off);
 
-static void dummy_enable_irq(unsigned int irq)
+unsigned int irq_canonicalize(unsigned int irq)
 {
-	printk("calling uninitialized enable_irq()\n");
-}
-
-static void dummy_disable_irq(unsigned int irq)
-{
-	printk("calling uninitialized disable_irq()\n");
-}
-
-static int dummy_request_irq(unsigned int irq,
-		irqreturn_t (*handler) (int, void *, struct pt_regs *),
-		unsigned long flags, const char *devname, void *dev_id)
-{
-	printk("calling uninitialized request_irq()\n");
-	return 0;
+#ifdef CONFIG_Q40
+	if (MACH_IS_Q40 && irq == 11)
+		irq = 10;
+#endif
+	return irq;
 }
 
-static void dummy_free_irq(unsigned int irq, void *dev_id)
-{
-	printk("calling uninitialized disable_irq()\n");
-}
+EXPORT_SYMBOL(irq_canonicalize);
 
 asmlinkage void m68k_handle_int(unsigned int irq, struct pt_regs *regs)
 {
@@ -340,15 +405,14 @@ int show_interrupts(struct seq_file *p, void *v)
 	int i = *(loff_t *) v;
 
 	/* autovector interrupts */
-	if (i < SYS_IRQS && irq_list[i]) {
+	if (irq_list[i]) {
 		contr = irq_controller[i];
 		node = irq_list[i];
-		seq_printf(p, "%s %u: %10u %s", contr->name, i, kstat_cpu(0).irqs[i], node->devname);
+		seq_printf(p, "%-8s %3u: %10u %s", contr->name, i, kstat_cpu(0).irqs[i], node->devname);
 		while ((node = node->next))
 			seq_printf(p, ", %s", node->devname);
 		seq_puts(p, "\n");
-	} else if (i == SYS_IRQS)
-		mach_get_irq_list(p, v);
+	}
 	return 0;
 }
 

commit b5dc7840b3ebe9c7967dd8ba73db957767009ff9
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:00 2006 -0700

    [PATCH] m68k: introduce irq controller
    
    Introduce irq controller and use it to manage auto vector interrupts.
    Introduce setup_irq() which can be used for irq setup.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 3ce7c6166bb9..c7f6ee67fd5a 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -45,7 +45,15 @@
 #endif
 
 /* table for system interrupt handlers */
-static irq_handler_t irq_list[SYS_IRQS];
+static struct irq_node *irq_list[SYS_IRQS];
+static struct irq_controller *irq_controller[SYS_IRQS];
+
+static struct irq_controller auto_irq_controller = {
+	.name		= "auto",
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.startup	= m68k_irq_startup,
+	.shutdown	= m68k_irq_shutdown,
+};
 
 static const char *default_names[SYS_IRQS] = {
 	[0] = "spurious int",
@@ -101,17 +109,13 @@ void __init init_IRQ(void)
 		hardirq_mask_is_broken();
 	}
 
-	for (i = 0; i < SYS_IRQS; i++) {
-		if (mach_default_handler)
-			irq_list[i].handler = (*mach_default_handler)[i];
-		irq_list[i].flags   = 0;
-		irq_list[i].dev_id  = NULL;
-		irq_list[i].devname = default_names[i];
+	for (i = IRQ_AUTO_1; i <= IRQ_AUTO_7; i++) {
+		irq_controller[i] = &auto_irq_controller;
+		if (mach_default_handler && (*mach_default_handler)[i])
+			cpu_request_irq(i, (*mach_default_handler)[i],
+					0, default_names[i], NULL);
 	}
 
-	for (i = 0; i < NUM_IRQ_NODES; i++)
-		nodes[i].handler = NULL;
-
 	mach_init_IRQ ();
 }
 
@@ -120,9 +124,12 @@ irq_node_t *new_irq_node(void)
 	irq_node_t *node;
 	short i;
 
-	for (node = nodes, i = NUM_IRQ_NODES-1; i >= 0; node++, i--)
-		if (!node->handler)
+	for (node = nodes, i = NUM_IRQ_NODES-1; i >= 0; node++, i--) {
+		if (!node->handler) {
+			memset(node, 0, sizeof(*node));
 			return node;
+		}
+	}
 
 	printk ("new_irq_node: out of nodes\n");
 	return NULL;
@@ -149,55 +156,115 @@ void free_irq(unsigned int irq, void *dev_id)
 
 EXPORT_SYMBOL(free_irq);
 
-int cpu_request_irq(unsigned int irq,
-                    irqreturn_t (*handler)(int, void *, struct pt_regs *),
-                    unsigned long flags, const char *devname, void *dev_id)
+int setup_irq(unsigned int irq, struct irq_node *node)
 {
-	if (irq < IRQ_AUTO_1 || irq > IRQ_AUTO_7) {
+	struct irq_controller *contr;
+	struct irq_node **prev;
+	unsigned long flags;
+
+	if (irq >= SYS_IRQS || !(contr = irq_controller[irq])) {
 		printk("%s: Incorrect IRQ %d from %s\n",
-		       __FUNCTION__, irq, devname);
+		       __FUNCTION__, irq, node->devname);
 		return -ENXIO;
 	}
 
-#if 0
-	if (!(irq_list[irq].flags & IRQ_FLG_STD)) {
-		if (irq_list[irq].flags & IRQ_FLG_LOCK) {
-			printk("%s: IRQ %d from %s is not replaceable\n",
-			       __FUNCTION__, irq, irq_list[irq].devname);
-			return -EBUSY;
-		}
-		if (!(flags & IRQ_FLG_REPLACE)) {
-			printk("%s: %s can't replace IRQ %d from %s\n",
-			       __FUNCTION__, devname, irq, irq_list[irq].devname);
+	spin_lock_irqsave(&contr->lock, flags);
+
+	prev = irq_list + irq;
+	if (*prev) {
+		/* Can't share interrupts unless both agree to */
+		if (!((*prev)->flags & node->flags & SA_SHIRQ)) {
+			spin_unlock_irqrestore(&contr->lock, flags);
 			return -EBUSY;
 		}
+		while (*prev)
+			prev = &(*prev)->next;
 	}
-#endif
 
-	irq_list[irq].handler = handler;
-	irq_list[irq].flags   = flags;
-	irq_list[irq].dev_id  = dev_id;
-	irq_list[irq].devname = devname;
+	if (!irq_list[irq]) {
+		if (contr->startup)
+			contr->startup(irq);
+		else
+			contr->enable(irq);
+	}
+	node->next = NULL;
+	*prev = node;
+
+	spin_unlock_irqrestore(&contr->lock, flags);
+
 	return 0;
 }
 
+int cpu_request_irq(unsigned int irq,
+                    irqreturn_t (*handler)(int, void *, struct pt_regs *),
+                    unsigned long flags, const char *devname, void *dev_id)
+{
+	struct irq_node *node;
+	int res;
+
+	node = new_irq_node();
+	if (!node)
+		return -ENOMEM;
+
+	node->handler = handler;
+	node->flags   = flags;
+	node->dev_id  = dev_id;
+	node->devname = devname;
+
+	res = setup_irq(irq, node);
+	if (res)
+		node->handler = NULL;
+
+	return res;
+}
+
 void cpu_free_irq(unsigned int irq, void *dev_id)
 {
-	if (irq < IRQ_AUTO_1 || irq > IRQ_AUTO_7) {
+	struct irq_controller *contr;
+	struct irq_node **p, *node;
+	unsigned long flags;
+
+	if (irq >= SYS_IRQS || !(contr = irq_controller[irq])) {
 		printk("%s: Incorrect IRQ %d\n", __FUNCTION__, irq);
 		return;
 	}
 
-	if (irq_list[irq].dev_id != dev_id)
-		printk("%s: Removing probably wrong IRQ %d from %s\n",
-		       __FUNCTION__, irq, irq_list[irq].devname);
+	spin_lock_irqsave(&contr->lock, flags);
+
+	p = irq_list + irq;
+	while ((node = *p)) {
+		if (node->dev_id == dev_id)
+			break;
+		p = &node->next;
+	}
+
+	if (node) {
+		*p = node->next;
+		node->handler = NULL;
+	} else
+		printk("%s: Removing probably wrong IRQ %d\n",
+		       __FUNCTION__, irq);
+
+	if (!irq_list[irq])
+		contr->shutdown(irq);
 
-	irq_list[irq].handler = (*mach_default_handler)[irq];
-	irq_list[irq].flags   = 0;
-	irq_list[irq].dev_id  = NULL;
-	irq_list[irq].devname = default_names[irq];
+	spin_unlock_irqrestore(&contr->lock, flags);
 }
 
+int m68k_irq_startup(unsigned int irq)
+{
+	if (irq <= IRQ_AUTO_7)
+		vectors[VEC_SPUR + irq] = auto_inthandler;
+	return 0;
+}
+
+void m68k_irq_shutdown(unsigned int irq)
+{
+	if (irq <= IRQ_AUTO_7)
+		vectors[VEC_SPUR + irq] = bad_inthandler;
+}
+
+
 /*
  * Do we need these probe functions on the m68k?
  *
@@ -250,8 +317,14 @@ static void dummy_free_irq(unsigned int irq, void *dev_id)
 
 asmlinkage void m68k_handle_int(unsigned int irq, struct pt_regs *regs)
 {
+	struct irq_node *node;
+
 	kstat_cpu(0).irqs[irq]++;
-	irq_list[irq].handler(irq, irq_list[irq].dev_id, regs);
+	node = irq_list[irq];
+	do {
+		node->handler(irq, node->dev_id, regs);
+		node = node->next;
+	} while (node);
 }
 
 asmlinkage void handle_badint(struct pt_regs *regs)
@@ -262,16 +335,18 @@ asmlinkage void handle_badint(struct pt_regs *regs)
 
 int show_interrupts(struct seq_file *p, void *v)
 {
+	struct irq_controller *contr;
+	struct irq_node *node;
 	int i = *(loff_t *) v;
 
 	/* autovector interrupts */
-	if (i < SYS_IRQS) {
-		if (mach_default_handler) {
-			seq_printf(p, "auto %2d: %10u ", i,
-			               i ? kstat_cpu(0).irqs[i] : num_spurious);
-			seq_puts(p, "  ");
-			seq_printf(p, "%s\n", irq_list[i].devname);
-		}
+	if (i < SYS_IRQS && irq_list[i]) {
+		contr = irq_controller[i];
+		node = irq_list[i];
+		seq_printf(p, "%s %u: %10u %s", contr->name, i, kstat_cpu(0).irqs[i], node->devname);
+		while ((node = node->next))
+			seq_printf(p, ", %s", node->devname);
+		seq_puts(p, "\n");
 	} else if (i == SYS_IRQS)
 		mach_get_irq_list(p, v);
 	return 0;

commit 4facfde9f1d7b8a61fb0017460da45e23e60115c
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:46:59 2006 -0700

    [PATCH] m68k: cleanup generic irq names
    
    Rename IRQ1..IRQ7 to IRQ_AUTO_1..IRQ_AUTO_7 and remove the duplicate
    defintions.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 895a56d69eba..3ce7c6166bb9 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -153,7 +153,7 @@ int cpu_request_irq(unsigned int irq,
                     irqreturn_t (*handler)(int, void *, struct pt_regs *),
                     unsigned long flags, const char *devname, void *dev_id)
 {
-	if (irq < IRQ1 || irq > IRQ7) {
+	if (irq < IRQ_AUTO_1 || irq > IRQ_AUTO_7) {
 		printk("%s: Incorrect IRQ %d from %s\n",
 		       __FUNCTION__, irq, devname);
 		return -ENXIO;
@@ -183,7 +183,7 @@ int cpu_request_irq(unsigned int irq,
 
 void cpu_free_irq(unsigned int irq, void *dev_id)
 {
-	if (irq < IRQ1 || irq > IRQ7) {
+	if (irq < IRQ_AUTO_1 || irq > IRQ_AUTO_7) {
 		printk("%s: Incorrect IRQ %d\n", __FUNCTION__, irq);
 		return;
 	}

commit 92445eaaadc1f03f5a177ecc957bda76bf2ba8d5
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:46:58 2006 -0700

    [PATCH] m68k: separate handler for auto and user vector interrupt
    
    Use separate entry points for auto and user vector interrupts and cleanup
    naming a little.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 4b85514792e7..895a56d69eba 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -248,19 +248,16 @@ static void dummy_free_irq(unsigned int irq, void *dev_id)
 	printk("calling uninitialized disable_irq()\n");
 }
 
-asmlinkage void process_int(unsigned long vec, struct pt_regs *fp)
+asmlinkage void m68k_handle_int(unsigned int irq, struct pt_regs *regs)
 {
-	if (vec >= VEC_INT1 && vec <= VEC_INT7 && !MACH_IS_BVME6000) {
-		vec -= VEC_SPUR;
-		kstat_cpu(0).irqs[vec]++;
-		irq_list[vec].handler(vec, irq_list[vec].dev_id, fp);
-	} else {
-		if (mach_process_int)
-			mach_process_int(vec, fp);
-		else
-			panic("Can't process interrupt vector %ld\n", vec);
-		return;
-	}
+	kstat_cpu(0).irqs[irq]++;
+	irq_list[irq].handler(irq, irq_list[irq].dev_id, regs);
+}
+
+asmlinkage void handle_badint(struct pt_regs *regs)
+{
+	kstat_cpu(0).irqs[0]++;
+	printk("unexpected interrupt from %u\n", regs->vector);
 }
 
 int show_interrupts(struct seq_file *p, void *v)

commit 6d2f16a8917eb77a8b79849686159f3a5eae2501
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Fri Jun 23 02:04:59 2006 -0700

    [PATCH] m68k: adjust to changed HARDIRQ_MASK
    
    Adjust entry.S to the changed HARDIRQ_MASK, add a check to prevent it from
    silently breaking again.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
index 514d323ad536..4b85514792e7 100644
--- a/arch/m68k/kernel/ints.c
+++ b/arch/m68k/kernel/ints.c
@@ -95,6 +95,12 @@ void __init init_IRQ(void)
 {
 	int i;
 
+	/* assembly irq entry code relies on this... */
+	if (HARDIRQ_MASK != 0x00ff0000) {
+		extern void hardirq_mask_is_broken(void);
+		hardirq_mask_is_broken();
+	}
+
 	for (i = 0; i < SYS_IRQS; i++) {
 		if (mach_default_handler)
 			irq_list[i].handler = (*mach_default_handler)[i];

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/kernel/ints.c b/arch/m68k/kernel/ints.c
new file mode 100644
index 000000000000..514d323ad536
--- /dev/null
+++ b/arch/m68k/kernel/ints.c
@@ -0,0 +1,281 @@
+/*
+ * linux/arch/m68k/kernel/ints.c -- Linux/m68k general interrupt handling code
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * 07/03/96: Timer initialization, and thus mach_sched_init(),
+ *           removed from request_irq() and moved to init_time().
+ *           We should therefore consider renaming our add_isr() and
+ *           remove_isr() to request_irq() and free_irq()
+ *           respectively, so they are compliant with the other
+ *           architectures.                                     /Jes
+ * 11/07/96: Changed all add_/remove_isr() to request_/free_irq() calls.
+ *           Removed irq list support, if any machine needs an irq server
+ *           it must implement this itself (as it's already done), instead
+ *           only default handler are used with mach_default_handler.
+ *           request_irq got some flags different from other architectures:
+ *           - IRQ_FLG_REPLACE : Replace an existing handler (the default one
+ *                               can be replaced without this flag)
+ *           - IRQ_FLG_LOCK : handler can't be replaced
+ *           There are other machine depending flags, see there
+ *           If you want to replace a default handler you should know what
+ *           you're doing, since it might handle different other irq sources
+ *           which must be served                               /Roman Zippel
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/sched.h>
+#include <linux/kernel_stat.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+
+#include <asm/setup.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/traps.h>
+#include <asm/page.h>
+#include <asm/machdep.h>
+
+#ifdef CONFIG_Q40
+#include <asm/q40ints.h>
+#endif
+
+/* table for system interrupt handlers */
+static irq_handler_t irq_list[SYS_IRQS];
+
+static const char *default_names[SYS_IRQS] = {
+	[0] = "spurious int",
+	[1] = "int1 handler",
+	[2] = "int2 handler",
+	[3] = "int3 handler",
+	[4] = "int4 handler",
+	[5] = "int5 handler",
+	[6] = "int6 handler",
+	[7] = "int7 handler"
+};
+
+/* The number of spurious interrupts */
+volatile unsigned int num_spurious;
+
+#define NUM_IRQ_NODES 100
+static irq_node_t nodes[NUM_IRQ_NODES];
+
+static void dummy_enable_irq(unsigned int irq);
+static void dummy_disable_irq(unsigned int irq);
+static int dummy_request_irq(unsigned int irq,
+		irqreturn_t (*handler) (int, void *, struct pt_regs *),
+		unsigned long flags, const char *devname, void *dev_id);
+static void dummy_free_irq(unsigned int irq, void *dev_id);
+
+void (*enable_irq) (unsigned int) = dummy_enable_irq;
+void (*disable_irq) (unsigned int) = dummy_disable_irq;
+
+int (*mach_request_irq) (unsigned int, irqreturn_t (*)(int, void *, struct pt_regs *),
+                      unsigned long, const char *, void *) = dummy_request_irq;
+void (*mach_free_irq) (unsigned int, void *) = dummy_free_irq;
+
+void init_irq_proc(void);
+
+/*
+ * void init_IRQ(void)
+ *
+ * Parameters:	None
+ *
+ * Returns:	Nothing
+ *
+ * This function should be called during kernel startup to initialize
+ * the IRQ handling routines.
+ */
+
+void __init init_IRQ(void)
+{
+	int i;
+
+	for (i = 0; i < SYS_IRQS; i++) {
+		if (mach_default_handler)
+			irq_list[i].handler = (*mach_default_handler)[i];
+		irq_list[i].flags   = 0;
+		irq_list[i].dev_id  = NULL;
+		irq_list[i].devname = default_names[i];
+	}
+
+	for (i = 0; i < NUM_IRQ_NODES; i++)
+		nodes[i].handler = NULL;
+
+	mach_init_IRQ ();
+}
+
+irq_node_t *new_irq_node(void)
+{
+	irq_node_t *node;
+	short i;
+
+	for (node = nodes, i = NUM_IRQ_NODES-1; i >= 0; node++, i--)
+		if (!node->handler)
+			return node;
+
+	printk ("new_irq_node: out of nodes\n");
+	return NULL;
+}
+
+/*
+ * We will keep these functions until I have convinced Linus to move
+ * the declaration of them from include/linux/sched.h to
+ * include/asm/irq.h.
+ */
+int request_irq(unsigned int irq,
+		irqreturn_t (*handler) (int, void *, struct pt_regs *),
+		unsigned long flags, const char *devname, void *dev_id)
+{
+	return mach_request_irq(irq, handler, flags, devname, dev_id);
+}
+
+EXPORT_SYMBOL(request_irq);
+
+void free_irq(unsigned int irq, void *dev_id)
+{
+	mach_free_irq(irq, dev_id);
+}
+
+EXPORT_SYMBOL(free_irq);
+
+int cpu_request_irq(unsigned int irq,
+                    irqreturn_t (*handler)(int, void *, struct pt_regs *),
+                    unsigned long flags, const char *devname, void *dev_id)
+{
+	if (irq < IRQ1 || irq > IRQ7) {
+		printk("%s: Incorrect IRQ %d from %s\n",
+		       __FUNCTION__, irq, devname);
+		return -ENXIO;
+	}
+
+#if 0
+	if (!(irq_list[irq].flags & IRQ_FLG_STD)) {
+		if (irq_list[irq].flags & IRQ_FLG_LOCK) {
+			printk("%s: IRQ %d from %s is not replaceable\n",
+			       __FUNCTION__, irq, irq_list[irq].devname);
+			return -EBUSY;
+		}
+		if (!(flags & IRQ_FLG_REPLACE)) {
+			printk("%s: %s can't replace IRQ %d from %s\n",
+			       __FUNCTION__, devname, irq, irq_list[irq].devname);
+			return -EBUSY;
+		}
+	}
+#endif
+
+	irq_list[irq].handler = handler;
+	irq_list[irq].flags   = flags;
+	irq_list[irq].dev_id  = dev_id;
+	irq_list[irq].devname = devname;
+	return 0;
+}
+
+void cpu_free_irq(unsigned int irq, void *dev_id)
+{
+	if (irq < IRQ1 || irq > IRQ7) {
+		printk("%s: Incorrect IRQ %d\n", __FUNCTION__, irq);
+		return;
+	}
+
+	if (irq_list[irq].dev_id != dev_id)
+		printk("%s: Removing probably wrong IRQ %d from %s\n",
+		       __FUNCTION__, irq, irq_list[irq].devname);
+
+	irq_list[irq].handler = (*mach_default_handler)[irq];
+	irq_list[irq].flags   = 0;
+	irq_list[irq].dev_id  = NULL;
+	irq_list[irq].devname = default_names[irq];
+}
+
+/*
+ * Do we need these probe functions on the m68k?
+ *
+ *  ... may be useful with ISA devices
+ */
+unsigned long probe_irq_on (void)
+{
+#ifdef CONFIG_Q40
+	if (MACH_IS_Q40)
+		return q40_probe_irq_on();
+#endif
+	return 0;
+}
+
+EXPORT_SYMBOL(probe_irq_on);
+
+int probe_irq_off (unsigned long irqs)
+{
+#ifdef CONFIG_Q40
+	if (MACH_IS_Q40)
+		return q40_probe_irq_off(irqs);
+#endif
+	return 0;
+}
+
+EXPORT_SYMBOL(probe_irq_off);
+
+static void dummy_enable_irq(unsigned int irq)
+{
+	printk("calling uninitialized enable_irq()\n");
+}
+
+static void dummy_disable_irq(unsigned int irq)
+{
+	printk("calling uninitialized disable_irq()\n");
+}
+
+static int dummy_request_irq(unsigned int irq,
+		irqreturn_t (*handler) (int, void *, struct pt_regs *),
+		unsigned long flags, const char *devname, void *dev_id)
+{
+	printk("calling uninitialized request_irq()\n");
+	return 0;
+}
+
+static void dummy_free_irq(unsigned int irq, void *dev_id)
+{
+	printk("calling uninitialized disable_irq()\n");
+}
+
+asmlinkage void process_int(unsigned long vec, struct pt_regs *fp)
+{
+	if (vec >= VEC_INT1 && vec <= VEC_INT7 && !MACH_IS_BVME6000) {
+		vec -= VEC_SPUR;
+		kstat_cpu(0).irqs[vec]++;
+		irq_list[vec].handler(vec, irq_list[vec].dev_id, fp);
+	} else {
+		if (mach_process_int)
+			mach_process_int(vec, fp);
+		else
+			panic("Can't process interrupt vector %ld\n", vec);
+		return;
+	}
+}
+
+int show_interrupts(struct seq_file *p, void *v)
+{
+	int i = *(loff_t *) v;
+
+	/* autovector interrupts */
+	if (i < SYS_IRQS) {
+		if (mach_default_handler) {
+			seq_printf(p, "auto %2d: %10u ", i,
+			               i ? kstat_cpu(0).irqs[i] : num_spurious);
+			seq_puts(p, "  ");
+			seq_printf(p, "%s\n", irq_list[i].devname);
+		}
+	} else if (i == SYS_IRQS)
+		mach_get_irq_list(p, v);
+	return 0;
+}
+
+void init_irq_proc(void)
+{
+	/* Insert /proc/irq driver here */
+}
+
