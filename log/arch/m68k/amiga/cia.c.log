commit 1efdd4bd254311498123a15fa0acd565f454da97
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 1 11:53:10 2018 +1100

    m68k: Call timer_interrupt() with interrupts disabled
    
    Some platforms execute their timer handler with the interrupt priority
    level set below 6. That means the handler could be interrupted by another
    driver and this could lead to re-entry of the timer core.
    
    Avoid this by use of local_irq_save/restore for timer interrupt dispatch.
    This provides mutual exclusion around the timer interrupt flag access
    which is needed later in this series for the clocksource conversion.
    
    Reported-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.21.1811131407120.2697@nanos.tec.linutronix.de
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index 2081b8cd5591..b9aee983e6f4 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -88,10 +88,19 @@ static irqreturn_t cia_handler(int irq, void *dev_id)
 	struct ciabase *base = dev_id;
 	int mach_irq;
 	unsigned char ints;
+	unsigned long flags;
 
+	/* Interrupts get disabled while the timer irq flag is cleared and
+	 * the timer interrupt serviced.
+	 */
 	mach_irq = base->cia_irq;
+	local_irq_save(flags);
 	ints = cia_set_irq(base, CIA_ICR_ALL);
 	amiga_custom.intreq = base->int_mask;
+	if (ints & 1)
+		generic_handle_irq(mach_irq);
+	local_irq_restore(flags);
+	mach_irq++, ints >>= 1;
 	for (; ints; mach_irq++, ints >>= 1) {
 		if (ints & 1)
 			generic_handle_irq(mach_irq);

commit 14b4319a44f2e0385e1794bf41a07d872908b539
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 19 11:17:40 2014 +0100

    m68k: amiga: Add linux/irq.h to make it compile again
    
    The removal of linux/irq.h from kernel_stat.h causes
    
     arch/m68k/amiga/cia.c:171: error: 'handle_simple_irq' undeclared
    
    Reported-by: Ingo Molnar <mingo@kernel.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index 18c0e29976e3..2081b8cd5591 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -18,6 +18,7 @@
 #include <linux/init.h>
 #include <linux/seq_file.h>
 #include <linux/interrupt.h>
+#include <linux/irq.h>
 
 #include <asm/irq.h>
 #include <asm/amigahw.h>

commit 1425df87c25b15400c9f26d57821bcfe01286b2a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Jul 1 20:39:19 2011 +0200

    m68k/irq: Rename {,__}m68k_handle_int()
    
      - Rename m68k_handle_int() to generic_handle_irq(), and drop the unneeded
        asmlinkage,
      - Rename __m68k_handle_int() to do_IRQ().
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index 84663ae824ef..18c0e29976e3 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -93,7 +93,7 @@ static irqreturn_t cia_handler(int irq, void *dev_id)
 	amiga_custom.intreq = base->int_mask;
 	for (; ints; mach_irq++, ints >>= 1) {
 		if (ints & 1)
-			m68k_handle_int(mach_irq);
+			generic_handle_irq(mach_irq);
 	}
 	return IRQ_HANDLED;
 }

commit edb347256c44366888debb4f9e8477ac700a9026
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jun 1 11:15:21 2011 +0200

    m68k/irq: Add m68k_setup_irq_controller()
    
    This is a wrapper around m68k_setup_irq_chip() that discards its dummy
    second parameter, to ease the future transition to genirq.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index b04b453718d9..84663ae824ef 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -168,14 +168,16 @@ static struct irq_chip auto_irq_chip = {
 
 void __init cia_init_IRQ(struct ciabase *base)
 {
-	m68k_setup_irq_chip(&cia_irq_chip, base->cia_irq, CIA_IRQS);
+	m68k_setup_irq_controller(&cia_irq_chip, handle_simple_irq,
+				  base->cia_irq, CIA_IRQS);
 
 	/* clear any pending interrupt and turn off all interrupts */
 	cia_set_irq(base, CIA_ICR_ALL);
 	cia_able_irq(base, CIA_ICR_ALL);
 
 	/* override auto int and install CIA handler */
-	m68k_setup_irq_chip(&auto_irq_chip, base->handler_irq, 1);
+	m68k_setup_irq_controller(&auto_irq_chip, handle_simple_irq,
+				  base->handler_irq, 1);
 	m68k_irq_startup_irq(base->handler_irq);
 	if (request_irq(base->handler_irq, cia_handler, IRQF_SHARED,
 			base->name, base))

commit e8abf5e73cdb6c034d35ccba1f63a4801cd3dec5
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 17 22:53:04 2011 +0200

    m68k/irq: Switch irq_chip methods to "struct irq_data *data"
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index 637ef53112b6..b04b453718d9 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -98,8 +98,9 @@ static irqreturn_t cia_handler(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static void cia_enable_irq(unsigned int irq)
+static void cia_irq_enable(struct irq_data *data)
 {
+	unsigned int irq = data->irq;
 	unsigned char mask;
 
 	if (irq >= IRQ_AMIGA_CIAB) {
@@ -113,8 +114,10 @@ static void cia_enable_irq(unsigned int irq)
 	}
 }
 
-static void cia_disable_irq(unsigned int irq)
+static void cia_irq_disable(struct irq_data *data)
 {
+	unsigned int irq = data->irq;
+
 	if (irq >= IRQ_AMIGA_CIAB)
 		cia_able_irq(&ciab_base, 1 << (irq - IRQ_AMIGA_CIAB));
 	else
@@ -123,8 +126,8 @@ static void cia_disable_irq(unsigned int irq)
 
 static struct irq_chip cia_irq_chip = {
 	.name		= "cia",
-	.irq_enable	= cia_enable_irq,
-	.irq_disable	= cia_disable_irq,
+	.irq_enable	= cia_irq_enable,
+	.irq_disable	= cia_irq_disable,
 };
 
 /*
@@ -133,9 +136,9 @@ static struct irq_chip cia_irq_chip = {
  * into this chain.
  */
 
-static void auto_enable_irq(unsigned int irq)
+static void auto_irq_enable(struct irq_data *data)
 {
-	switch (irq) {
+	switch (data->irq) {
 	case IRQ_AUTO_2:
 		amiga_custom.intena = IF_SETCLR | IF_PORTS;
 		break;
@@ -145,9 +148,9 @@ static void auto_enable_irq(unsigned int irq)
 	}
 }
 
-static void auto_disable_irq(unsigned int irq)
+static void auto_irq_disable(struct irq_data *data)
 {
-	switch (irq) {
+	switch (data->irq) {
 	case IRQ_AUTO_2:
 		amiga_custom.intena = IF_PORTS;
 		break;
@@ -159,8 +162,8 @@ static void auto_disable_irq(unsigned int irq)
 
 static struct irq_chip auto_irq_chip = {
 	.name		= "auto",
-	.irq_enable	= auto_enable_irq,
-	.irq_disable	= auto_disable_irq,
+	.irq_enable	= auto_irq_enable,
+	.irq_disable	= auto_irq_disable,
 };
 
 void __init cia_init_IRQ(struct ciabase *base)
@@ -173,7 +176,7 @@ void __init cia_init_IRQ(struct ciabase *base)
 
 	/* override auto int and install CIA handler */
 	m68k_setup_irq_chip(&auto_irq_chip, base->handler_irq, 1);
-	m68k_irq_startup(base->handler_irq);
+	m68k_irq_startup_irq(base->handler_irq);
 	if (request_irq(base->handler_irq, cia_handler, IRQF_SHARED,
 			base->name, base))
 		pr_err("Couldn't register %s interrupt\n", base->name);

commit c288bf2533e57174b90b07860c4391bcd1ea269c
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Apr 13 22:31:28 2011 +0200

    m68k/irq: Rename irq_controller to irq_chip
    
    Make it more similar to the genirq version:
      - Remove lock (unused as we don't do SMP anyway),
      - Prepend methods with irq_,
      - Make irq_startup() return unsigned int.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index ecd0f7ca6f0e..637ef53112b6 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -121,11 +121,10 @@ static void cia_disable_irq(unsigned int irq)
 		cia_able_irq(&ciaa_base, 1 << (irq - IRQ_AMIGA_CIAA));
 }
 
-static struct irq_controller cia_irq_controller = {
+static struct irq_chip cia_irq_chip = {
 	.name		= "cia",
-	.lock		= __SPIN_LOCK_UNLOCKED(cia_irq_controller.lock),
-	.enable		= cia_enable_irq,
-	.disable	= cia_disable_irq,
+	.irq_enable	= cia_enable_irq,
+	.irq_disable	= cia_disable_irq,
 };
 
 /*
@@ -158,23 +157,22 @@ static void auto_disable_irq(unsigned int irq)
 	}
 }
 
-static struct irq_controller auto_irq_controller = {
+static struct irq_chip auto_irq_chip = {
 	.name		= "auto",
-	.lock		= __SPIN_LOCK_UNLOCKED(auto_irq_controller.lock),
-	.enable		= auto_enable_irq,
-	.disable	= auto_disable_irq,
+	.irq_enable	= auto_enable_irq,
+	.irq_disable	= auto_disable_irq,
 };
 
 void __init cia_init_IRQ(struct ciabase *base)
 {
-	m68k_setup_irq_controller(&cia_irq_controller, base->cia_irq, CIA_IRQS);
+	m68k_setup_irq_chip(&cia_irq_chip, base->cia_irq, CIA_IRQS);
 
 	/* clear any pending interrupt and turn off all interrupts */
 	cia_set_irq(base, CIA_ICR_ALL);
 	cia_able_irq(base, CIA_ICR_ALL);
 
 	/* override auto int and install CIA handler */
-	m68k_setup_irq_controller(&auto_irq_controller, base->handler_irq, 1);
+	m68k_setup_irq_chip(&auto_irq_chip, base->handler_irq, 1);
 	m68k_irq_startup(base->handler_irq);
 	if (request_irq(base->handler_irq, cia_handler, IRQF_SHARED,
 			base->name, base))

commit 66acd2581259d80935fc5216b4b1268d639d9143
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Dec 30 14:00:34 2008 +0100

    m68k: amiga core - Kill warn_unused_result warnings
    
    warning: ignoring return value of 'request_irq', declared with attribute
    warn_unused_result
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index 343fab49bd9a..ecd0f7ca6f0e 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -176,5 +176,7 @@ void __init cia_init_IRQ(struct ciabase *base)
 	/* override auto int and install CIA handler */
 	m68k_setup_irq_controller(&auto_irq_controller, base->handler_irq, 1);
 	m68k_irq_startup(base->handler_irq);
-	request_irq(base->handler_irq, cia_handler, IRQF_SHARED, base->name, base);
+	if (request_irq(base->handler_irq, cia_handler, IRQF_SHARED,
+			base->name, base))
+		pr_err("Couldn't register %s interrupt\n", base->name);
 }

commit 15aafa2f9d8399b22e418c53a87dfc0c43f4030f
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Feb 6 01:36:20 2008 -0800

    Remove pointless casts from void pointers
    
    Mostly in and around irq handlers.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Cc: Russell King <rmk@arm.linux.org.uk>
    Cc: "Luck Tony" <tony.luck@intel.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Acked-by: Dmitry Torokhov <dtor@mail.ru>
    Cc: Karsten Keil <kkeil@suse.de>
    Acked-by: "John W. Linville" <linville@tuxdriver.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: David Brownell <david-b@pacbell.net>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Acked-by: Josh Boyer <jwboyer@linux.vnet.ibm.com>
    Acked-by: Holger Schurig <hs4233@mail.mn-solutions.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index c4a4ffd45bc0..343fab49bd9a 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -84,7 +84,7 @@ unsigned char cia_able_irq(struct ciabase *base, unsigned char mask)
 
 static irqreturn_t cia_handler(int irq, void *dev_id)
 {
-	struct ciabase *base = (struct ciabase *)dev_id;
+	struct ciabase *base = dev_id;
 	int mach_irq;
 	unsigned char ints;
 

commit 241258d1cc4d3551608364cd678d5a85239ad481
Author: Milind Arun Choudhary <milindchoudhary@gmail.com>
Date:   Sun May 6 14:50:54 2007 -0700

    SPIN_LOCK_UNLOCKED cleanup in arch/m68k
    
    SPIN_LOCK_UNLOCKED cleanup,use __SPIN_LOCK_UNLOCKED instead
    
    Signed-off-by: Milind Arun Choudhary <milindchoudhary@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index 7a20058eb380..c4a4ffd45bc0 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -123,7 +123,7 @@ static void cia_disable_irq(unsigned int irq)
 
 static struct irq_controller cia_irq_controller = {
 	.name		= "cia",
-	.lock		= SPIN_LOCK_UNLOCKED,
+	.lock		= __SPIN_LOCK_UNLOCKED(cia_irq_controller.lock),
 	.enable		= cia_enable_irq,
 	.disable	= cia_disable_irq,
 };
@@ -160,7 +160,7 @@ static void auto_disable_irq(unsigned int irq)
 
 static struct irq_controller auto_irq_controller = {
 	.name		= "auto",
-	.lock		= SPIN_LOCK_UNLOCKED,
+	.lock		= __SPIN_LOCK_UNLOCKED(auto_irq_controller.lock),
 	.enable		= auto_enable_irq,
 	.disable	= auto_disable_irq,
 };

commit 2850bc273776cbb1b510c5828e9e456dffb50a32
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Oct 7 14:16:45 2006 +0100

    [PATCH] m68k pt_regs fixes
    
    m68k_handle_int() split in two functions: __m68k_handle_int() takes
    pt_regs * and does set_irq_regs(); m68k_handle_int() doesn't get pt_regs
    *.
    
    Places where we used to call m68k_handle_int() recursively with the same
    pt_regs have simply lost the second argument, the rest is switched to
    __m68k_handle_int().
    
    The rest of patch is just dropping pt_regs * where needed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index dbad30054721..7a20058eb380 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -82,7 +82,7 @@ unsigned char cia_able_irq(struct ciabase *base, unsigned char mask)
 	return old;
 }
 
-static irqreturn_t cia_handler(int irq, void *dev_id, struct pt_regs *fp)
+static irqreturn_t cia_handler(int irq, void *dev_id)
 {
 	struct ciabase *base = (struct ciabase *)dev_id;
 	int mach_irq;
@@ -93,7 +93,7 @@ static irqreturn_t cia_handler(int irq, void *dev_id, struct pt_regs *fp)
 	amiga_custom.intreq = base->int_mask;
 	for (; ints; mach_irq++, ints >>= 1) {
 		if (ints & 1)
-			m68k_handle_int(mach_irq, fp);
+			m68k_handle_int(mach_irq);
 	}
 	return IRQ_HANDLED;
 }

commit b0b9fdc123cf0f1b671ac3f593d77af325ad4cf3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:19 2006 -0700

    [PATCH] irq-flags: M68K: Use the new IRQF_ constants
    
    Use the new IRQF_ constants and remove the SA_INTERRUPT define
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index 0956e45399e5..dbad30054721 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -176,5 +176,5 @@ void __init cia_init_IRQ(struct ciabase *base)
 	/* override auto int and install CIA handler */
 	m68k_setup_irq_controller(&auto_irq_controller, base->handler_irq, 1);
 	m68k_irq_startup(base->handler_irq);
-	request_irq(base->handler_irq, cia_handler, SA_SHIRQ, base->name, base);
+	request_irq(base->handler_irq, cia_handler, IRQF_SHARED, base->name, base);
 }

commit 74be8d0835f91f0f77a2f1554dfa7242f1f7b652
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:01 2006 -0700

    [PATCH] m68k: convert amiga irq code
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index 4a003d87f98d..0956e45399e5 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -29,21 +29,18 @@ struct ciabase {
 	unsigned short int_mask;
 	int handler_irq, cia_irq, server_irq;
 	char *name;
-	irq_handler_t irq_list[CIA_IRQS];
 } ciaa_base = {
 	.cia		= &ciaa,
 	.int_mask	= IF_PORTS,
-	.handler_irq	= IRQ_AUTO_2,
+	.handler_irq	= IRQ_AMIGA_PORTS,
 	.cia_irq	= IRQ_AMIGA_CIAA,
-	.server_irq	= IRQ_AMIGA_PORTS,
-	.name		= "CIAA handler"
+	.name		= "CIAA"
 }, ciab_base = {
 	.cia		= &ciab,
 	.int_mask	= IF_EXTER,
-	.handler_irq	= IRQ_AUTO_6,
+	.handler_irq	= IRQ_AMIGA_EXTER,
 	.cia_irq	= IRQ_AMIGA_CIAB,
-	.server_irq	= IRQ_AMIGA_EXTER,
-	.name		= "CIAB handler"
+	.name		= "CIAB"
 };
 
 /*
@@ -66,13 +63,11 @@ unsigned char cia_set_irq(struct ciabase *base, unsigned char mask)
 
 /*
  *  Enable or disable CIA interrupts, return old interrupt mask,
- *  interrupts will only be enabled if a handler exists
  */
 
 unsigned char cia_able_irq(struct ciabase *base, unsigned char mask)
 {
-	unsigned char old, tmp;
-	int i;
+	unsigned char old;
 
 	old = base->icr_mask;
 	base->icr_data |= base->cia->icr;
@@ -82,98 +77,104 @@ unsigned char cia_able_irq(struct ciabase *base, unsigned char mask)
 	else
 		base->icr_mask &= ~mask;
 	base->icr_mask &= CIA_ICR_ALL;
-	for (i = 0, tmp = 1; i < CIA_IRQS; i++, tmp <<= 1) {
-		if ((tmp & base->icr_mask) && !base->irq_list[i].handler) {
-			base->icr_mask &= ~tmp;
-			base->cia->icr = tmp;
-		}
-	}
 	if (base->icr_data & base->icr_mask)
 		amiga_custom.intreq = IF_SETCLR | base->int_mask;
 	return old;
 }
 
-int cia_request_irq(struct ciabase *base, unsigned int irq,
-                    irqreturn_t (*handler)(int, void *, struct pt_regs *),
-                    unsigned long flags, const char *devname, void *dev_id)
-{
-	unsigned char mask;
-
-	base->irq_list[irq].handler = handler;
-	base->irq_list[irq].flags   = flags;
-	base->irq_list[irq].dev_id  = dev_id;
-	base->irq_list[irq].devname = devname;
-
-	/* enable the interrupt */
-	mask = 1 << irq;
-	cia_set_irq(base, mask);
-	cia_able_irq(base, CIA_ICR_SETCLR | mask);
-	return 0;
-}
-
-void cia_free_irq(struct ciabase *base, unsigned int irq, void *dev_id)
-{
-	if (base->irq_list[irq].dev_id != dev_id)
-		printk("%s: removing probably wrong IRQ %i from %s\n",
-		       __FUNCTION__, base->cia_irq + irq,
-		       base->irq_list[irq].devname);
-
-	base->irq_list[irq].handler = NULL;
-	base->irq_list[irq].flags   = 0;
-
-	cia_able_irq(base, 1 << irq);
-}
-
 static irqreturn_t cia_handler(int irq, void *dev_id, struct pt_regs *fp)
 {
 	struct ciabase *base = (struct ciabase *)dev_id;
-	int mach_irq, i;
+	int mach_irq;
 	unsigned char ints;
 
 	mach_irq = base->cia_irq;
 	ints = cia_set_irq(base, CIA_ICR_ALL);
 	amiga_custom.intreq = base->int_mask;
-	for (i = 0; i < CIA_IRQS; i++, mach_irq++) {
-		if (ints & 1) {
-			kstat_cpu(0).irqs[mach_irq]++;
-			base->irq_list[i].handler(mach_irq, base->irq_list[i].dev_id, fp);
-		}
-		ints >>= 1;
+	for (; ints; mach_irq++, ints >>= 1) {
+		if (ints & 1)
+			m68k_handle_int(mach_irq, fp);
 	}
-	amiga_do_irq_list(base->server_irq, fp);
 	return IRQ_HANDLED;
 }
 
-void __init cia_init_IRQ(struct ciabase *base)
+static void cia_enable_irq(unsigned int irq)
 {
-	int i;
+	unsigned char mask;
 
-	/* init isr handlers */
-	for (i = 0; i < CIA_IRQS; i++) {
-		base->irq_list[i].handler = NULL;
-		base->irq_list[i].flags   = 0;
+	if (irq >= IRQ_AMIGA_CIAB) {
+		mask = 1 << (irq - IRQ_AMIGA_CIAB);
+		cia_set_irq(&ciab_base, mask);
+		cia_able_irq(&ciab_base, CIA_ICR_SETCLR | mask);
+	} else {
+		mask = 1 << (irq - IRQ_AMIGA_CIAA);
+		cia_set_irq(&ciaa_base, mask);
+		cia_able_irq(&ciaa_base, CIA_ICR_SETCLR | mask);
 	}
+}
 
-	/* clear any pending interrupt and turn off all interrupts */
-	cia_set_irq(base, CIA_ICR_ALL);
-	cia_able_irq(base, CIA_ICR_ALL);
+static void cia_disable_irq(unsigned int irq)
+{
+	if (irq >= IRQ_AMIGA_CIAB)
+		cia_able_irq(&ciab_base, 1 << (irq - IRQ_AMIGA_CIAB));
+	else
+		cia_able_irq(&ciaa_base, 1 << (irq - IRQ_AMIGA_CIAA));
+}
 
-	/* install CIA handler */
-	request_irq(base->handler_irq, cia_handler, 0, base->name, base);
+static struct irq_controller cia_irq_controller = {
+	.name		= "cia",
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.enable		= cia_enable_irq,
+	.disable	= cia_disable_irq,
+};
+
+/*
+ * Override auto irq 2 & 6 and use them as general chain
+ * for external interrupts, we link the CIA interrupt sources
+ * into this chain.
+ */
 
-	amiga_custom.intena = IF_SETCLR | base->int_mask;
+static void auto_enable_irq(unsigned int irq)
+{
+	switch (irq) {
+	case IRQ_AUTO_2:
+		amiga_custom.intena = IF_SETCLR | IF_PORTS;
+		break;
+	case IRQ_AUTO_6:
+		amiga_custom.intena = IF_SETCLR | IF_EXTER;
+		break;
+	}
 }
 
-int cia_get_irq_list(struct ciabase *base, struct seq_file *p)
+static void auto_disable_irq(unsigned int irq)
 {
-	int i, j;
-
-	j = base->cia_irq;
-	for (i = 0; i < CIA_IRQS; i++) {
-		seq_printf(p, "cia  %2d: %10d ", j + i,
-			       kstat_cpu(0).irqs[j + i]);
-		seq_puts(p, "  ");
-		seq_printf(p, "%s\n", base->irq_list[i].devname);
+	switch (irq) {
+	case IRQ_AUTO_2:
+		amiga_custom.intena = IF_PORTS;
+		break;
+	case IRQ_AUTO_6:
+		amiga_custom.intena = IF_EXTER;
+		break;
 	}
-	return 0;
+}
+
+static struct irq_controller auto_irq_controller = {
+	.name		= "auto",
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.enable		= auto_enable_irq,
+	.disable	= auto_disable_irq,
+};
+
+void __init cia_init_IRQ(struct ciabase *base)
+{
+	m68k_setup_irq_controller(&cia_irq_controller, base->cia_irq, CIA_IRQS);
+
+	/* clear any pending interrupt and turn off all interrupts */
+	cia_set_irq(base, CIA_ICR_ALL);
+	cia_able_irq(base, CIA_ICR_ALL);
+
+	/* override auto int and install CIA handler */
+	m68k_setup_irq_controller(&auto_irq_controller, base->handler_irq, 1);
+	m68k_irq_startup(base->handler_irq);
+	request_irq(base->handler_irq, cia_handler, SA_SHIRQ, base->name, base);
 }

commit 1d174cfb0f2a8967433e157bae9c2d4dcdee5324
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:00 2006 -0700

    [PATCH] m68k: cleanup amiga irq numbering
    
    Fix amiga irq numbering, so they are after the generic IRQ_AUTO defines and
    remove the IRQ_AMIGA_AUTO defines.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index 9476eb9440f5..4a003d87f98d 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -33,14 +33,14 @@ struct ciabase {
 } ciaa_base = {
 	.cia		= &ciaa,
 	.int_mask	= IF_PORTS,
-	.handler_irq	= IRQ_AMIGA_AUTO_2,
+	.handler_irq	= IRQ_AUTO_2,
 	.cia_irq	= IRQ_AMIGA_CIAA,
 	.server_irq	= IRQ_AMIGA_PORTS,
 	.name		= "CIAA handler"
 }, ciab_base = {
 	.cia		= &ciab,
 	.int_mask	= IF_EXTER,
-	.handler_irq	= IRQ_AMIGA_AUTO_6,
+	.handler_irq	= IRQ_AUTO_6,
 	.cia_irq	= IRQ_AMIGA_CIAB,
 	.server_irq	= IRQ_AMIGA_EXTER,
 	.name		= "CIAB handler"
@@ -131,12 +131,11 @@ static irqreturn_t cia_handler(int irq, void *dev_id, struct pt_regs *fp)
 	unsigned char ints;
 
 	mach_irq = base->cia_irq;
-	irq = SYS_IRQS + mach_irq;
 	ints = cia_set_irq(base, CIA_ICR_ALL);
 	amiga_custom.intreq = base->int_mask;
-	for (i = 0; i < CIA_IRQS; i++, irq++, mach_irq++) {
+	for (i = 0; i < CIA_IRQS; i++, mach_irq++) {
 		if (ints & 1) {
-			kstat_cpu(0).irqs[irq]++;
+			kstat_cpu(0).irqs[mach_irq]++;
 			base->irq_list[i].handler(mach_irq, base->irq_list[i].dev_id, fp);
 		}
 		ints >>= 1;
@@ -172,7 +171,7 @@ int cia_get_irq_list(struct ciabase *base, struct seq_file *p)
 	j = base->cia_irq;
 	for (i = 0; i < CIA_IRQS; i++) {
 		seq_printf(p, "cia  %2d: %10d ", j + i,
-			       kstat_cpu(0).irqs[SYS_IRQS + j + i]);
+			       kstat_cpu(0).irqs[j + i]);
 		seq_puts(p, "  ");
 		seq_printf(p, "%s\n", base->irq_list[i].devname);
 	}

commit b4290a23cfa9040e2f0de5ab57d6ea65abaf053b
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jan 12 01:06:12 2006 -0800

    [PATCH] m68k: namespace pollution fix (custom->amiga_custom)
    
    in amigahw.h custom renamed to amiga_custom, in drivers with few instances the
    same replacement, in the rest - #define custom amiga_custom in driver itself
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
index 7d55682615e3..9476eb9440f5 100644
--- a/arch/m68k/amiga/cia.c
+++ b/arch/m68k/amiga/cia.c
@@ -60,7 +60,7 @@ unsigned char cia_set_irq(struct ciabase *base, unsigned char mask)
 	else
 		base->icr_data &= ~mask;
 	if (base->icr_data & base->icr_mask)
-		custom.intreq = IF_SETCLR | base->int_mask;
+		amiga_custom.intreq = IF_SETCLR | base->int_mask;
 	return old & base->icr_mask;
 }
 
@@ -89,7 +89,7 @@ unsigned char cia_able_irq(struct ciabase *base, unsigned char mask)
 		}
 	}
 	if (base->icr_data & base->icr_mask)
-		custom.intreq = IF_SETCLR | base->int_mask;
+		amiga_custom.intreq = IF_SETCLR | base->int_mask;
 	return old;
 }
 
@@ -133,7 +133,7 @@ static irqreturn_t cia_handler(int irq, void *dev_id, struct pt_regs *fp)
 	mach_irq = base->cia_irq;
 	irq = SYS_IRQS + mach_irq;
 	ints = cia_set_irq(base, CIA_ICR_ALL);
-	custom.intreq = base->int_mask;
+	amiga_custom.intreq = base->int_mask;
 	for (i = 0; i < CIA_IRQS; i++, irq++, mach_irq++) {
 		if (ints & 1) {
 			kstat_cpu(0).irqs[irq]++;
@@ -162,7 +162,7 @@ void __init cia_init_IRQ(struct ciabase *base)
 	/* install CIA handler */
 	request_irq(base->handler_irq, cia_handler, 0, base->name, base);
 
-	custom.intena = IF_SETCLR | base->int_mask;
+	amiga_custom.intena = IF_SETCLR | base->int_mask;
 }
 
 int cia_get_irq_list(struct ciabase *base, struct seq_file *p)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/amiga/cia.c b/arch/m68k/amiga/cia.c
new file mode 100644
index 000000000000..7d55682615e3
--- /dev/null
+++ b/arch/m68k/amiga/cia.c
@@ -0,0 +1,180 @@
+/*
+ *  linux/arch/m68k/amiga/cia.c - CIA support
+ *
+ *  Copyright (C) 1996 Roman Zippel
+ *
+ *  The concept of some functions bases on the original Amiga OS function
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/errno.h>
+#include <linux/kernel_stat.h>
+#include <linux/init.h>
+#include <linux/seq_file.h>
+#include <linux/interrupt.h>
+
+#include <asm/irq.h>
+#include <asm/amigahw.h>
+#include <asm/amigaints.h>
+
+struct ciabase {
+	volatile struct CIA *cia;
+	unsigned char icr_mask, icr_data;
+	unsigned short int_mask;
+	int handler_irq, cia_irq, server_irq;
+	char *name;
+	irq_handler_t irq_list[CIA_IRQS];
+} ciaa_base = {
+	.cia		= &ciaa,
+	.int_mask	= IF_PORTS,
+	.handler_irq	= IRQ_AMIGA_AUTO_2,
+	.cia_irq	= IRQ_AMIGA_CIAA,
+	.server_irq	= IRQ_AMIGA_PORTS,
+	.name		= "CIAA handler"
+}, ciab_base = {
+	.cia		= &ciab,
+	.int_mask	= IF_EXTER,
+	.handler_irq	= IRQ_AMIGA_AUTO_6,
+	.cia_irq	= IRQ_AMIGA_CIAB,
+	.server_irq	= IRQ_AMIGA_EXTER,
+	.name		= "CIAB handler"
+};
+
+/*
+ *  Cause or clear CIA interrupts, return old interrupt status.
+ */
+
+unsigned char cia_set_irq(struct ciabase *base, unsigned char mask)
+{
+	unsigned char old;
+
+	old = (base->icr_data |= base->cia->icr);
+	if (mask & CIA_ICR_SETCLR)
+		base->icr_data |= mask;
+	else
+		base->icr_data &= ~mask;
+	if (base->icr_data & base->icr_mask)
+		custom.intreq = IF_SETCLR | base->int_mask;
+	return old & base->icr_mask;
+}
+
+/*
+ *  Enable or disable CIA interrupts, return old interrupt mask,
+ *  interrupts will only be enabled if a handler exists
+ */
+
+unsigned char cia_able_irq(struct ciabase *base, unsigned char mask)
+{
+	unsigned char old, tmp;
+	int i;
+
+	old = base->icr_mask;
+	base->icr_data |= base->cia->icr;
+	base->cia->icr = mask;
+	if (mask & CIA_ICR_SETCLR)
+		base->icr_mask |= mask;
+	else
+		base->icr_mask &= ~mask;
+	base->icr_mask &= CIA_ICR_ALL;
+	for (i = 0, tmp = 1; i < CIA_IRQS; i++, tmp <<= 1) {
+		if ((tmp & base->icr_mask) && !base->irq_list[i].handler) {
+			base->icr_mask &= ~tmp;
+			base->cia->icr = tmp;
+		}
+	}
+	if (base->icr_data & base->icr_mask)
+		custom.intreq = IF_SETCLR | base->int_mask;
+	return old;
+}
+
+int cia_request_irq(struct ciabase *base, unsigned int irq,
+                    irqreturn_t (*handler)(int, void *, struct pt_regs *),
+                    unsigned long flags, const char *devname, void *dev_id)
+{
+	unsigned char mask;
+
+	base->irq_list[irq].handler = handler;
+	base->irq_list[irq].flags   = flags;
+	base->irq_list[irq].dev_id  = dev_id;
+	base->irq_list[irq].devname = devname;
+
+	/* enable the interrupt */
+	mask = 1 << irq;
+	cia_set_irq(base, mask);
+	cia_able_irq(base, CIA_ICR_SETCLR | mask);
+	return 0;
+}
+
+void cia_free_irq(struct ciabase *base, unsigned int irq, void *dev_id)
+{
+	if (base->irq_list[irq].dev_id != dev_id)
+		printk("%s: removing probably wrong IRQ %i from %s\n",
+		       __FUNCTION__, base->cia_irq + irq,
+		       base->irq_list[irq].devname);
+
+	base->irq_list[irq].handler = NULL;
+	base->irq_list[irq].flags   = 0;
+
+	cia_able_irq(base, 1 << irq);
+}
+
+static irqreturn_t cia_handler(int irq, void *dev_id, struct pt_regs *fp)
+{
+	struct ciabase *base = (struct ciabase *)dev_id;
+	int mach_irq, i;
+	unsigned char ints;
+
+	mach_irq = base->cia_irq;
+	irq = SYS_IRQS + mach_irq;
+	ints = cia_set_irq(base, CIA_ICR_ALL);
+	custom.intreq = base->int_mask;
+	for (i = 0; i < CIA_IRQS; i++, irq++, mach_irq++) {
+		if (ints & 1) {
+			kstat_cpu(0).irqs[irq]++;
+			base->irq_list[i].handler(mach_irq, base->irq_list[i].dev_id, fp);
+		}
+		ints >>= 1;
+	}
+	amiga_do_irq_list(base->server_irq, fp);
+	return IRQ_HANDLED;
+}
+
+void __init cia_init_IRQ(struct ciabase *base)
+{
+	int i;
+
+	/* init isr handlers */
+	for (i = 0; i < CIA_IRQS; i++) {
+		base->irq_list[i].handler = NULL;
+		base->irq_list[i].flags   = 0;
+	}
+
+	/* clear any pending interrupt and turn off all interrupts */
+	cia_set_irq(base, CIA_ICR_ALL);
+	cia_able_irq(base, CIA_ICR_ALL);
+
+	/* install CIA handler */
+	request_irq(base->handler_irq, cia_handler, 0, base->name, base);
+
+	custom.intena = IF_SETCLR | base->int_mask;
+}
+
+int cia_get_irq_list(struct ciabase *base, struct seq_file *p)
+{
+	int i, j;
+
+	j = base->cia_irq;
+	for (i = 0; i < CIA_IRQS; i++) {
+		seq_printf(p, "cia  %2d: %10d ", j + i,
+			       kstat_cpu(0).irqs[SYS_IRQS + j + i]);
+		seq_puts(p, "  ");
+		seq_printf(p, "%s\n", base->irq_list[i].devname);
+	}
+	return 0;
+}
