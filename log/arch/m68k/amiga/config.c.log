commit e31cf2f4ca422ac9b14ecc4a1295b8977a20f812
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:33 2020 -0700

    mm: don't include asm/pgtable.h if linux/mm.h is already included
    
    Patch series "mm: consolidate definitions of page table accessors", v2.
    
    The low level page table accessors (pXY_index(), pXY_offset()) are
    duplicated across all architectures and sometimes more than once.  For
    instance, we have 31 definition of pgd_offset() for 25 supported
    architectures.
    
    Most of these definitions are actually identical and typically it boils
    down to, e.g.
    
    static inline unsigned long pmd_index(unsigned long address)
    {
            return (address >> PMD_SHIFT) & (PTRS_PER_PMD - 1);
    }
    
    static inline pmd_t *pmd_offset(pud_t *pud, unsigned long address)
    {
            return (pmd_t *)pud_page_vaddr(*pud) + pmd_index(address);
    }
    
    These definitions can be shared among 90% of the arches provided
    XYZ_SHIFT, PTRS_PER_XYZ and xyz_page_vaddr() are defined.
    
    For architectures that really need a custom version there is always
    possibility to override the generic version with the usual ifdefs magic.
    
    These patches introduce include/linux/pgtable.h that replaces
    include/asm-generic/pgtable.h and add the definitions of the page table
    accessors to the new header.
    
    This patch (of 12):
    
    The linux/mm.h header includes <asm/pgtable.h> to allow inlining of the
    functions involving page table manipulations, e.g.  pte_alloc() and
    pmd_alloc().  So, there is no point to explicitly include <asm/pgtable.h>
    in the files that include <linux/mm.h>.
    
    The include statements in such cases are remove with a simple loop:
    
            for f in $(git grep -l "include <linux/mm.h>") ; do
                    sed -i -e '/include <asm\/pgtable.h>/ d' $f
            done
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Mike Rapoport <rppt@kernel.org>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-1-rppt@kernel.org
    Link: http://lkml.kernel.org/r/20200514170327.31389-2-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 4eb911d64e8d..8f23b2fab64c 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -32,7 +32,6 @@
 #include <asm/bootinfo-amiga.h>
 #include <asm/byteorder.h>
 #include <asm/setup.h>
-#include <asm/pgtable.h>
 #include <asm/amigahw.h>
 #include <asm/amigaints.h>
 #include <asm/irq.h>

commit 366b8149fbff1965f9e25bb27dd4698d654be270
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Apr 20 13:14:01 2020 -0500

    m68k: amiga: config: Replace zero-length array with flexible-array member
    
    The current codebase makes use of the zero-length array language
    extension to the C90 standard, but the preferred mechanism to declare
    variable-length types such as these ones is a flexible array member[1][2],
    introduced in C99:
    
    struct foo {
            int stuff;
            struct boo array[];
    };
    
    By making use of the mechanism above, we will get a compiler warning
    in case the flexible array does not occur last in the structure, which
    will help us prevent some kind of undefined behavior bugs from being
    inadvertently introduced[3] to the codebase from now on.
    
    Also, notice that, dynamic memory allocations won't be affected by
    this change:
    
    "Flexible array members have incomplete type, and so the sizeof operator
    may not be applied. As a quirk of the original implementation of
    zero-length arrays, sizeof evaluates to zero."[1]
    
    This issue was found with the help of Coccinelle.
    
    [1] https://gcc.gnu.org/onlinedocs/gcc/Zero-Length.html
    [2] https://github.com/KSPP/linux/issues/21
    [3] commit 76497732932f ("cxgb3/l2t: Fix undefined behaviour")
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/20200420181401.GA32172@embeddedor
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 777196e9c9bc..4eb911d64e8d 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -629,7 +629,7 @@ struct savekmsg {
 	unsigned long magic2;		/* SAVEKMSG_MAGIC2 */
 	unsigned long magicptr;		/* address of magic1 */
 	unsigned long size;
-	char data[0];
+	char data[];
 };
 
 static struct savekmsg *savekmsg;

commit e09a7440407900757d03aa0cd897e4fc8e7d5fac
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Thu Mar 26 18:29:09 2020 -0500

    m68k: amiga: config: Mark expected switch fall-through
    
    Mark switch cases where we are expecting to fall through.
    
    This patch fixes the following warning (Building: allmodconfig m68k):
    
    arch/m68k/amiga/config.c: In function ‘amiga_identify’:
    ./arch/m68k/include/asm/amigahw.h:42:50: warning: this statement may fall through [-Wimplicit-fallthrough=]
     #define AMIGAHW_SET(name) (amiga_hw_present.name = 1)
                               ~~~~~~~~~~~~~~~~~~~~~~~^~~~
    arch/m68k/amiga/config.c:223:3: note: in expansion of macro ‘AMIGAHW_SET’
       AMIGAHW_SET(PCMCIA);
       ^~~~~~~~~~~
    arch/m68k/amiga/config.c:224:2: note: here
      case AMI_500:
      ^~~~
    
    Replace the existing /* fall through */ comments and fix the issue above
    by using the new pseudo-keyword fallthrough;
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Link: https://lore.kernel.org/r/14ff577604d25243c8a897f851b436ba87ae87cb.1585264062.git.gustavo@embeddedor.com
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index c32ab8041cf6..777196e9c9bc 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -221,6 +221,7 @@ static void __init amiga_identify(void)
 	case AMI_1200:
 		AMIGAHW_SET(A1200_IDE);
 		AMIGAHW_SET(PCMCIA);
+		fallthrough;
 	case AMI_500:
 	case AMI_500PLUS:
 	case AMI_1000:
@@ -233,7 +234,7 @@ static void __init amiga_identify(void)
 	case AMI_3000T:
 		AMIGAHW_SET(AMBER_FF);
 		AMIGAHW_SET(MAGIC_REKICK);
-		/* fall through */
+		fallthrough;
 	case AMI_3000PLUS:
 		AMIGAHW_SET(A3000_SCSI);
 		AMIGAHW_SET(A3000_CLK);
@@ -242,7 +243,7 @@ static void __init amiga_identify(void)
 
 	case AMI_4000T:
 		AMIGAHW_SET(A4000_SCSI);
-		/* fall through */
+		fallthrough;
 	case AMI_4000:
 		AMIGAHW_SET(A4000_IDE);
 		AMIGAHW_SET(A3000_CLK);

commit 5afd3d06e5cb30a312aaa34348f9457b9fb38a52
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 1 11:53:10 2018 +1100

    m68k: amiga: Convert to clocksource API
    
    Add a platform clocksource by adapting the existing arch_gettimeoffset
    implementation.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index d4976c1aa0cc..c32ab8041cf6 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -17,6 +17,7 @@
 #include <linux/mm.h>
 #include <linux/seq_file.h>
 #include <linux/tty.h>
+#include <linux/clocksource.h>
 #include <linux/console.h>
 #include <linux/rtc.h>
 #include <linux/init.h>
@@ -461,7 +462,29 @@ void __init config_amiga(void)
 		*(unsigned char *)ZTWO_VADDR(0xde0002) |= 0x80;
 }
 
+static u64 amiga_read_clk(struct clocksource *cs);
+
+static struct clocksource amiga_clk = {
+	.name   = "ciab",
+	.rating = 250,
+	.read   = amiga_read_clk,
+	.mask   = CLOCKSOURCE_MASK(32),
+	.flags  = CLOCK_SOURCE_IS_CONTINUOUS,
+};
+
 static unsigned short jiffy_ticks;
+static u32 clk_total, clk_offset;
+
+static irqreturn_t ciab_timer_handler(int irq, void *dev_id)
+{
+	irq_handler_t timer_routine = dev_id;
+
+	clk_total += jiffy_ticks;
+	clk_offset = 0;
+	timer_routine(0, NULL);
+
+	return IRQ_HANDLED;
+}
 
 static void __init amiga_sched_init(irq_handler_t timer_routine)
 {
@@ -481,19 +504,22 @@ static void __init amiga_sched_init(irq_handler_t timer_routine)
 	 * Please don't change this to use ciaa, as it interferes with the
 	 * SCSI code. We'll have to take a look at this later
 	 */
-	if (request_irq(IRQ_AMIGA_CIAB_TA, timer_routine, 0, "timer", NULL))
+	if (request_irq(IRQ_AMIGA_CIAB_TA, ciab_timer_handler, IRQF_TIMER,
+			"timer", timer_routine))
 		pr_err("Couldn't register timer interrupt\n");
 	/* start timer */
 	ciab.cra |= 0x11;
-}
 
-#define TICK_SIZE 10000
+	clocksource_register_hz(&amiga_clk, amiga_eclock);
+}
 
-/* This is always executed with interrupts disabled.  */
-static u32 amiga_gettimeoffset(void)
+static u64 amiga_read_clk(struct clocksource *cs)
 {
 	unsigned short hi, lo, hi2;
-	u32 ticks, offset = 0;
+	unsigned long flags;
+	u32 ticks;
+
+	local_irq_save(flags);
 
 	/* read CIA B timer A current value */
 	hi  = ciab.tahi;
@@ -510,12 +536,14 @@ static u32 amiga_gettimeoffset(void)
 	if (ticks > jiffy_ticks / 2)
 		/* check for pending interrupt */
 		if (cia_set_irq(&ciab_base, 0) & CIA_ICR_TA)
-			offset = 10000;
+			clk_offset = jiffy_ticks;
 
 	ticks = jiffy_ticks - ticks;
-	ticks = (10000 * ticks) / jiffy_ticks;
+	ticks += clk_offset + clk_total;
+
+	local_irq_restore(flags);
 
-	return (ticks + offset) * 1000;
+	return ticks;
 }
 
 static void amiga_reset(void)  __noreturn;

commit 7d6ca23554e34f25a70cb25666194f25b38c319b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 1 11:53:10 2018 +1100

    m68k: Drop ARCH_USES_GETTIMEOFFSET
    
    The functions that implement arch_gettimeoffset are re-used by
    new clocksource drivers in subsequent patches.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 65f63a457130..d4976c1aa0cc 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -95,8 +95,6 @@ static char amiga_model_name[13] = "Amiga ";
 static void amiga_sched_init(irq_handler_t handler);
 static void amiga_get_model(char *model);
 static void amiga_get_hardware_list(struct seq_file *m);
-/* amiga specific timer functions */
-static u32 amiga_gettimeoffset(void);
 extern void amiga_mksound(unsigned int count, unsigned int ticks);
 static void amiga_reset(void);
 extern void amiga_init_sound(void);
@@ -386,7 +384,6 @@ void __init config_amiga(void)
 	mach_init_IRQ        = amiga_init_IRQ;
 	mach_get_model       = amiga_get_model;
 	mach_get_hardware_list = amiga_get_hardware_list;
-	arch_gettimeoffset   = amiga_gettimeoffset;
 
 	/*
 	 * default MAX_DMA=0xffffffff on all machines. If we don't do so, the SCSI

commit f2a0c53402990ee106a8ec329b00fc527d6e0773
Author: Markus Elfring <elfring@users.sourceforge.net>
Date:   Sun Oct 23 22:55:03 2016 +0200

    m68k/amiga: Use seq_puts() in amiga_get_hardware_list()
    
    A string which did not contain a data format specification should be put
    into a sequence. Thus use the corresponding function "seq_puts".
    
    This issue was detected by using the Coccinelle software.
    
    Signed-off-by: Markus Elfring <elfring@users.sourceforge.net>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index ddb8192a3661..65f63a457130 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -786,8 +786,7 @@ static void amiga_get_hardware_list(struct seq_file *m)
 	if (AMIGAHW_PRESENT(name))			\
 		seq_printf (m, "\t%s\n", str)
 
-	seq_printf (m, "Detected hardware:\n");
-
+	seq_puts(m, "Detected hardware:\n");
 	AMIGAHW_ANNOUNCE(AMI_VIDEO, "Amiga Video");
 	AMIGAHW_ANNOUNCE(AMI_BLITTER, "Blitter");
 	AMIGAHW_ANNOUNCE(AMBER_FF, "Amber Flicker Fixer");

commit a1a9e88f708fc1c5602cbe9761f246c6acbc27cd
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Sep 5 13:18:15 2016 +0200

    m68k: Use IS_ENABLED() instead of checking for built-in or module
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index ec9cc1fdd237..ddb8192a3661 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -396,7 +396,7 @@ void __init config_amiga(void)
 	mach_max_dma_address = 0xffffffff;
 
 	mach_reset           = amiga_reset;
-#if defined(CONFIG_INPUT_M68K_BEEP) || defined(CONFIG_INPUT_M68K_BEEP_MODULE)
+#if IS_ENABLED(CONFIG_INPUT_M68K_BEEP)
 	mach_beep            = amiga_mksound;
 #endif
 

commit 084b3600e2d98ebbab968f91b8b8f48ffbbf2ecb
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon May 30 20:57:59 2016 +0200

    char/genrtc: remove m68k support
    
    The asm/rtc.h header is only used for the old gen_rtc driver
    that has been replaced by rtc-generic. According to Geert
    Uytterhoeven, nobody has used the old driver on m68k for
    a long time, so we can now just remove the header file
    and disallow the driver in Kconfig.
    
    All files that used to include asm/rtc.h are now changed so
    they include the headers that were used implicitly through
    asm/rtc.h.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 01693df7f2f6..ec9cc1fdd237 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -35,7 +35,6 @@
 #include <asm/amigahw.h>
 #include <asm/amigaints.h>
 #include <asm/irq.h>
-#include <asm/rtc.h>
 #include <asm/machdep.h>
 #include <asm/io.h>
 

commit f296401b04a6eb2af8da5a5d40e937e91617061b
Author: Fabian Frederick <fabf@skynet.be>
Date:   Sat May 10 12:38:00 2014 +0200

    m68k/amiga: Convert printk(foo to pr_foo()
    
    -no level printk converted to pr_warn/pr_info
    -fixed a small identation problem
    
    This is untested
    
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 9625b7132227..01693df7f2f6 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -183,7 +183,7 @@ int __init amiga_parse_bootinfo(const struct bi_record *record)
 			dev->boardaddr = be32_to_cpu(cd->cd_BoardAddr);
 			dev->boardsize = be32_to_cpu(cd->cd_BoardSize);
 		} else
-			printk("amiga_parse_bootinfo: too many AutoConfig devices\n");
+			pr_warn("amiga_parse_bootinfo: too many AutoConfig devices\n");
 #endif /* CONFIG_ZORRO */
 		break;
 
@@ -209,9 +209,9 @@ static void __init amiga_identify(void)
 
 	memset(&amiga_hw_present, 0, sizeof(amiga_hw_present));
 
-	printk("Amiga hardware found: ");
+	pr_info("Amiga hardware found: ");
 	if (amiga_model >= AMI_500 && amiga_model <= AMI_DRACO) {
-		printk("[%s] ", amiga_models[amiga_model-AMI_500]);
+		pr_cont("[%s] ", amiga_models[amiga_model-AMI_500]);
 		strcat(amiga_model_name, amiga_models[amiga_model-AMI_500]);
 	}
 
@@ -322,7 +322,7 @@ static void __init amiga_identify(void)
 
 #define AMIGAHW_ANNOUNCE(name, str)		\
 	if (AMIGAHW_PRESENT(name))		\
-		printk(str)
+		pr_cont(str)
 
 	AMIGAHW_ANNOUNCE(AMI_VIDEO, "VIDEO ");
 	AMIGAHW_ANNOUNCE(AMI_BLITTER, "BLITTER ");
@@ -354,8 +354,8 @@ static void __init amiga_identify(void)
 	AMIGAHW_ANNOUNCE(MAGIC_REKICK, "MAGIC_REKICK ");
 	AMIGAHW_ANNOUNCE(PCMCIA, "PCMCIA ");
 	if (AMIGAHW_PRESENT(ZORRO))
-		printk("ZORRO%s ", AMIGAHW_PRESENT(ZORRO3) ? "3" : "");
-	printk("\n");
+		pr_cont("ZORRO%s ", AMIGAHW_PRESENT(ZORRO3) ? "3" : "");
+	pr_cont("\n");
 
 #undef AMIGAHW_ANNOUNCE
 }
@@ -424,7 +424,7 @@ void __init config_amiga(void)
 			if (m68k_memory[i].addr < 16*1024*1024) {
 				if (i == 0) {
 					/* don't cut off the branch we're sitting on */
-					printk("Warning: kernel runs in Zorro II memory\n");
+					pr_warn("Warning: kernel runs in Zorro II memory\n");
 					continue;
 				}
 				disabled_z2mem += m68k_memory[i].size;
@@ -435,8 +435,8 @@ void __init config_amiga(void)
 			}
 		}
 		if (disabled_z2mem)
-		printk("%dK of Zorro II memory will not be used as system memory\n",
-		disabled_z2mem>>10);
+			pr_info("%dK of Zorro II memory will not be used as system memory\n",
+				disabled_z2mem>>10);
 	}
 
 	/* request all RAM */
@@ -475,7 +475,7 @@ static void __init amiga_sched_init(irq_handler_t timer_routine)
 	jiffy_ticks = DIV_ROUND_CLOSEST(amiga_eclock, HZ);
 
 	if (request_resource(&mb_resources._ciab, &sched_res))
-		printk("Cannot allocate ciab.ta{lo,hi}\n");
+		pr_warn("Cannot allocate ciab.ta{lo,hi}\n");
 	ciab.cra &= 0xC0;   /* turn off timer A, continuous mode, from Eclk */
 	ciab.talo = jiffy_ticks % 256;
 	ciab.tahi = jiffy_ticks / 256;

commit 8a09cec25fa19a3a7e9f21b4186fecc69085a60f
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Dec 1 11:14:51 2013 +0100

    m68k/amiga,atari: Fix specifying multiple debug= parameters
    
    Since commit d6713b4091a99fa2af2fabdcd2f3fb97f32ecf2e ("m68k: early
    parameter support"), the user can specify multiple debug consoles using the
    "debug=" kernel command line parameter.
    However, as there's only a single struct console object, which is reused,
    it would actually register the same console object multiple times, causing
    the following warning:
    
    WARNING: CPU: 0 PID: 0 at kernel/printk/printk.c:2233 register_console+0x36/
    console 'debug0' already registered
    
    Make sure to register the console object only once, to avoid the warning.
    
    Note that still only one console (the one corresponding to the last
    "debug=" parameter) will be active at the same time, as the .write() method
    of the already registered console object is overwritten by a subsequent
    "debug=" parameter.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index c425fa6c2795..9625b7132227 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -620,6 +620,8 @@ static void amiga_mem_console_write(struct console *co, const char *s,
 
 static int __init amiga_savekmsg_setup(char *arg)
 {
+	bool registered;
+
 	if (!MACH_IS_AMIGA || strcmp(arg, "mem"))
 		return 0;
 
@@ -636,8 +638,10 @@ static int __init amiga_savekmsg_setup(char *arg)
 	savekmsg->magicptr = ZTWO_PADDR(savekmsg);
 	savekmsg->size = 0;
 
+	registered = !!amiga_console_driver.write;
 	amiga_console_driver.write = amiga_mem_console_write;
-	register_console(&amiga_console_driver);
+	if (!registered)
+		register_console(&amiga_console_driver);
 	return 0;
 }
 
@@ -719,11 +723,16 @@ void amiga_serial_gets(struct console *co, char *s, int len)
 
 static int __init amiga_debug_setup(char *arg)
 {
-	if (MACH_IS_AMIGA && !strcmp(arg, "ser")) {
-		/* no initialization required (?) */
-		amiga_console_driver.write = amiga_serial_console_write;
+	bool registered;
+
+	if (!MACH_IS_AMIGA || strcmp(arg, "ser"))
+		return 0;
+
+	/* no initialization required (?) */
+	registered = !!amiga_console_driver.write;
+	amiga_console_driver.write = amiga_serial_console_write;
+	if (!registered)
 		register_console(&amiga_console_driver);
-	}
 	return 0;
 }
 

commit 50190edb2a56bb9efa3e2f8ca32482dbd3e42412
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Oct 18 13:16:06 2013 +0200

    m68k/amiga: Provide mach_random_get_entropy()
    
    Use the beam position registers, which provide at least 17 bits of data
    changing at 1.79 MHz.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 06920e85fac9..c425fa6c2795 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -360,6 +360,14 @@ static void __init amiga_identify(void)
 #undef AMIGAHW_ANNOUNCE
 }
 
+
+static unsigned long amiga_random_get_entropy(void)
+{
+	/* VPOSR/VHPOSR provide at least 17 bits of data changing at 1.79 MHz */
+	return *(unsigned long *)&amiga_custom.vposr;
+}
+
+
     /*
      *  Setup the Amiga configuration info
      */
@@ -397,6 +405,8 @@ void __init config_amiga(void)
 	mach_heartbeat = amiga_heartbeat;
 #endif
 
+	mach_random_get_entropy = amiga_random_get_entropy;
+
 	/* Fill in the clock value (based on the 700 kHz E-Clock) */
 	amiga_colorclock = 5*amiga_eclock;	/* 3.5 MHz */
 

commit abe48101c17eaf1b5d85270272392e6111562626
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Oct 4 11:41:24 2013 +0200

    m68k/UAPI: Use proper types (endianness/size) in <asm/bootinfo*.h>
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 0c92c1baf9bf..06920e85fac9 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -145,37 +145,37 @@ static struct resource ram_resource[NUM_MEMINFO];
 int __init amiga_parse_bootinfo(const struct bi_record *record)
 {
 	int unknown = 0;
-	const unsigned long *data = record->data;
+	const void *data = record->data;
 
-	switch (record->tag) {
+	switch (be16_to_cpu(record->tag)) {
 	case BI_AMIGA_MODEL:
-		amiga_model = *data;
+		amiga_model = be32_to_cpup(data);
 		break;
 
 	case BI_AMIGA_ECLOCK:
-		amiga_eclock = *data;
+		amiga_eclock = be32_to_cpup(data);
 		break;
 
 	case BI_AMIGA_CHIPSET:
-		amiga_chipset = *data;
+		amiga_chipset = be32_to_cpup(data);
 		break;
 
 	case BI_AMIGA_CHIP_SIZE:
-		amiga_chip_size = *(const int *)data;
+		amiga_chip_size = be32_to_cpup(data);
 		break;
 
 	case BI_AMIGA_VBLANK:
-		amiga_vblank = *(const unsigned char *)data;
+		amiga_vblank = *(const __u8 *)data;
 		break;
 
 	case BI_AMIGA_PSFREQ:
-		amiga_psfreq = *(const unsigned char *)data;
+		amiga_psfreq = *(const __u8 *)data;
 		break;
 
 	case BI_AMIGA_AUTOCON:
 #ifdef CONFIG_ZORRO
 		if (zorro_num_autocon < ZORRO_NUM_AUTO) {
-			const struct ConfigDev *cd = (struct ConfigDev *)data;
+			const struct ConfigDev *cd = data;
 			struct zorro_dev_init *dev = &zorro_autocon_init[zorro_num_autocon++];
 			dev->rom = cd->cd_Rom;
 			dev->slotaddr = be16_to_cpu(cd->cd_SlotAddr);

commit 4c3c522bcebe16a717d7a809fd14b11823794027
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Oct 2 11:37:33 2013 +0200

    m68k/UAPI: Disintegrate arch/m68k/include/asm/bootinfo.h
    
    Export the bootinfo definitions that are used by bootstrap loaders, and
    split them up in generic and platform-specific parts.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 65b5e937ebba..0c92c1baf9bf 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -28,6 +28,7 @@
 #include <linux/keyboard.h>
 
 #include <asm/bootinfo.h>
+#include <asm/bootinfo-amiga.h>
 #include <asm/byteorder.h>
 #include <asm/setup.h>
 #include <asm/pgtable.h>

commit bd9ba8f40ee30edf31cc0845d8838bc43d172ef3
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Oct 4 09:38:53 2013 +0200

    zorro/UAPI: Use proper types (endianness/size) in <linux/zorro.h>
    
    Fix member definitions for non-native userspace handling:
      - All multi-byte values are big-endian, hence use __be*,
      - All pointers are 32-bit pointers under AmigaOS, but unused (except for
        cd_BoardAddr) under Linux, hence use __be32.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index acd9c1640cfc..65b5e937ebba 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -28,6 +28,7 @@
 #include <linux/keyboard.h>
 
 #include <asm/bootinfo.h>
+#include <asm/byteorder.h>
 #include <asm/setup.h>
 #include <asm/pgtable.h>
 #include <asm/amigahw.h>
@@ -176,10 +177,10 @@ int __init amiga_parse_bootinfo(const struct bi_record *record)
 			const struct ConfigDev *cd = (struct ConfigDev *)data;
 			struct zorro_dev_init *dev = &zorro_autocon_init[zorro_num_autocon++];
 			dev->rom = cd->cd_Rom;
-			dev->slotaddr = cd->cd_SlotAddr;
-			dev->slotsize = cd->cd_SlotSize;
-			dev->boardaddr = (u32)cd->cd_BoardAddr;
-			dev->boardsize = cd->cd_BoardSize;
+			dev->slotaddr = be16_to_cpu(cd->cd_SlotAddr);
+			dev->slotsize = be16_to_cpu(cd->cd_SlotSize);
+			dev->boardaddr = be32_to_cpu(cd->cd_BoardAddr);
+			dev->boardsize = be32_to_cpu(cd->cd_BoardSize);
 		} else
 			printk("amiga_parse_bootinfo: too many AutoConfig devices\n");
 #endif /* CONFIG_ZORRO */

commit 6112ea0862facaeaeab504ee01c0d04bcd22daaf
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Jan 9 11:03:43 2011 +0100

    zorro: ZTWO_VADDR() should return "void __iomem *"
    
    ZTWO_VADDR() converts from physical to virtual I/O addresses, so it should
    return "void __iomem *" instead of "unsigned long".
    
    This allows to drop several casts, but requires adding a few casts to
    accomodate legacy driver frameworks that store "unsigned long" I/O
    addresses.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index d956ddbfebe1..acd9c1640cfc 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -618,7 +618,7 @@ static int __init amiga_savekmsg_setup(char *arg)
 
 	/* Just steal the block, the chipram allocator isn't functional yet */
 	amiga_chip_size -= SAVEKMSG_MAXMEM;
-	savekmsg = (void *)ZTWO_VADDR(CHIP_PHYSADDR + amiga_chip_size);
+	savekmsg = ZTWO_VADDR(CHIP_PHYSADDR + amiga_chip_size);
 	savekmsg->magic1 = SAVEKMSG_MAGIC1;
 	savekmsg->magic2 = SAVEKMSG_MAGIC2;
 	savekmsg->magicptr = ZTWO_PADDR(savekmsg);

commit c293738e6d8dfb9c941759855b5161fde449644d
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sat Jun 29 10:40:20 2013 +0200

    zorro: Do not allocate zorro_autocon[] statically
    
    Currently the array of Zorro devices is allocated statically, wasting
    up to 4.5 KiB when running an Amiga or multi-platform kernel on a machine
    with no or a handful of Zorro expansion cards. Convert it to conditional
    dynamic memory allocation to fix this.
    
    amiga_parse_bootinfo() still needs to store some information about the
    detected Zorro devices, at a time even the bootmem allocator is not yet
    available.  This is now handled using a much smaller array (typically less
    than 0.5 KiB), which is __initdata and thus freed later.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 93ab423758da..d956ddbfebe1 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -174,12 +174,12 @@ int __init amiga_parse_bootinfo(const struct bi_record *record)
 #ifdef CONFIG_ZORRO
 		if (zorro_num_autocon < ZORRO_NUM_AUTO) {
 			const struct ConfigDev *cd = (struct ConfigDev *)data;
-			struct zorro_dev *dev = &zorro_autocon[zorro_num_autocon++];
+			struct zorro_dev_init *dev = &zorro_autocon_init[zorro_num_autocon++];
 			dev->rom = cd->cd_Rom;
 			dev->slotaddr = cd->cd_SlotAddr;
 			dev->slotsize = cd->cd_SlotSize;
-			dev->resource.start = (unsigned long)cd->cd_BoardAddr;
-			dev->resource.end = dev->resource.start + cd->cd_BoardSize - 1;
+			dev->boardaddr = (u32)cd->cd_BoardAddr;
+			dev->boardsize = cd->cd_BoardSize;
 		} else
 			printk("amiga_parse_bootinfo: too many AutoConfig devices\n");
 #endif /* CONFIG_ZORRO */

commit a4df02a217e9787a4b967197d9d9030c3e3c1088
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Jun 25 21:15:24 2013 +0200

    m68k: Mark functions only called from setup_arch() __init
    
    Some functions that are only called (indirectly) from setup_arch() lack
    __init annotations.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index b819390e29cd..93ab423758da 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -140,7 +140,7 @@ static struct resource ram_resource[NUM_MEMINFO];
      *  Parse an Amiga-specific record in the bootinfo
      */
 
-int amiga_parse_bootinfo(const struct bi_record *record)
+int __init amiga_parse_bootinfo(const struct bi_record *record)
 {
 	int unknown = 0;
 	const unsigned long *data = record->data;

commit c8d5ba1891eda2aa63800f052cb5af128283d130
Author: Stephen Warren <swarren@nvidia.com>
Date:   Thu Nov 8 11:34:55 2012 -0700

    m68k: set arch_gettimeoffset directly
    
    remove m68k's mach_gettimeoffset function pointer, and instead directly
    set the arch_gettimeoffset function pointer. This requires multiplying
    all function results by 1000, since the removed m68k_gettimeoffset() did
    this. Also, s/unsigned long/u32/ just to make the function prototypes
    exactly match that of arch_gettimeoffset.
    
    Cc: Joshua Thompson <funaho@jurai.org>
    Cc: Sam Creasey <sammy@sammy.net>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Phil Blundell <philb@gnu.org>
    Signed-off-by: Stephen Warren <swarren@nvidia.com>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index ee01b7a38e58..b819390e29cd 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -95,7 +95,7 @@ static void amiga_sched_init(irq_handler_t handler);
 static void amiga_get_model(char *model);
 static void amiga_get_hardware_list(struct seq_file *m);
 /* amiga specific timer functions */
-static unsigned long amiga_gettimeoffset(void);
+static u32 amiga_gettimeoffset(void);
 extern void amiga_mksound(unsigned int count, unsigned int ticks);
 static void amiga_reset(void);
 extern void amiga_init_sound(void);
@@ -377,7 +377,7 @@ void __init config_amiga(void)
 	mach_init_IRQ        = amiga_init_IRQ;
 	mach_get_model       = amiga_get_model;
 	mach_get_hardware_list = amiga_get_hardware_list;
-	mach_gettimeoffset   = amiga_gettimeoffset;
+	arch_gettimeoffset   = amiga_gettimeoffset;
 
 	/*
 	 * default MAX_DMA=0xffffffff on all machines. If we don't do so, the SCSI
@@ -482,10 +482,10 @@ static void __init amiga_sched_init(irq_handler_t timer_routine)
 #define TICK_SIZE 10000
 
 /* This is always executed with interrupts disabled.  */
-static unsigned long amiga_gettimeoffset(void)
+static u32 amiga_gettimeoffset(void)
 {
 	unsigned short hi, lo, hi2;
-	unsigned long ticks, offset = 0;
+	u32 ticks, offset = 0;
 
 	/* read CIA B timer A current value */
 	hi  = ciab.tahi;
@@ -507,7 +507,7 @@ static unsigned long amiga_gettimeoffset(void)
 	ticks = jiffy_ticks - ticks;
 	ticks = (10000 * ticks) / jiffy_ticks;
 
-	return ticks + offset;
+	return (ticks + offset) * 1000;
 }
 
 static void amiga_reset(void)  __noreturn;

commit 803f69144f0d48863c68f9d111b56849c7cef5bb
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for M68K
    
    Disintegrate asm/system.h for M68K.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    cc: linux-m68k@lists.linux-m68k.org

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index b95a451b1c3a..ee01b7a38e58 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -29,7 +29,6 @@
 
 #include <asm/bootinfo.h>
 #include <asm/setup.h>
-#include <asm/system.h>
 #include <asm/pgtable.h>
 #include <asm/amigahw.h>
 #include <asm/amigaints.h>

commit ff2d8b19a3a62559afba1c53360c8577a7697714
Author: Joe Perches <joe@perches.com>
Date:   Thu Jan 12 17:17:21 2012 -0800

    treewide: convert uses of ATTRIB_NORETURN to __noreturn
    
    Use the more commonly used __noreturn instead of ATTRIB_NORETURN.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index a3b0558328b6..b95a451b1c3a 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -511,8 +511,7 @@ static unsigned long amiga_gettimeoffset(void)
 	return ticks + offset;
 }
 
-static void amiga_reset(void)
-    ATTRIB_NORET;
+static void amiga_reset(void)  __noreturn;
 
 static void amiga_reset(void)
 {

commit 9402c95f34a66e81eba473a2f7267bbae5a1dee2
Author: Joe Perches <joe@perches.com>
Date:   Thu Jan 12 17:17:17 2012 -0800

    treewide: remove useless NORET_TYPE macro and uses
    
    It's a very old and now unused prototype marking so just delete it.
    
    Neaten panic pointer argument style to keep checkpatch quiet.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 82a4bb51d5d8..a3b0558328b6 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -511,7 +511,7 @@ static unsigned long amiga_gettimeoffset(void)
 	return ticks + offset;
 }
 
-static NORET_TYPE void amiga_reset(void)
+static void amiga_reset(void)
     ATTRIB_NORET;
 
 static void amiga_reset(void)

commit 5df1abdbd37af2ae317a1c5b5944173284dc55d6
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Jan 7 13:25:29 2011 +0100

    m68k/amiga: Fix "debug=mem"
    
    `debug=mem' on Amiga has been broken for a while.
    early_param() processing is done very/too early, i.e. before
    amiga_identify() / amiga_chip_init(), causing amiga_savekmsg_setup() not
    to find any Chip RAM.
    
    As we don't plan to free this memory anyway, just steal it from the initial
    Chip RAM memory block instead.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index b1577f741fa8..82a4bb51d5d8 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -610,17 +610,17 @@ static void amiga_mem_console_write(struct console *co, const char *s,
 
 static int __init amiga_savekmsg_setup(char *arg)
 {
-	static struct resource debug_res = { .name = "Debug" };
-
 	if (!MACH_IS_AMIGA || strcmp(arg, "mem"))
-		goto done;
+		return 0;
 
-	if (!AMIGAHW_PRESENT(CHIP_RAM)) {
-		printk("Warning: no chipram present for debugging\n");
-		goto done;
+	if (amiga_chip_size < SAVEKMSG_MAXMEM) {
+		pr_err("Not enough chipram for debugging\n");
+		return -ENOMEM;
 	}
 
-	savekmsg = amiga_chip_alloc_res(SAVEKMSG_MAXMEM, &debug_res);
+	/* Just steal the block, the chipram allocator isn't functional yet */
+	amiga_chip_size -= SAVEKMSG_MAXMEM;
+	savekmsg = (void *)ZTWO_VADDR(CHIP_PHYSADDR + amiga_chip_size);
 	savekmsg->magic1 = SAVEKMSG_MAGIC1;
 	savekmsg->magic2 = SAVEKMSG_MAGIC2;
 	savekmsg->magicptr = ZTWO_PADDR(savekmsg);
@@ -628,8 +628,6 @@ static int __init amiga_savekmsg_setup(char *arg)
 
 	amiga_console_driver.write = amiga_mem_console_write;
 	register_console(&amiga_console_driver);
-
-done:
 	return 0;
 }
 

commit 0779c862e43e052c58a350a8bd2bf97e6908de04
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 5 13:15:10 2009 +0200

    m68k: amiga - RTC platform device conversion
    
    The A2000 TOD is an Oki MSM6242B, while the A3000 TOD is a Ricoh RP5C01.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index d2cc35d98532..b1577f741fa8 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -97,10 +97,6 @@ static void amiga_get_model(char *model);
 static void amiga_get_hardware_list(struct seq_file *m);
 /* amiga specific timer functions */
 static unsigned long amiga_gettimeoffset(void);
-static int a3000_hwclk(int, struct rtc_time *);
-static int a2000_hwclk(int, struct rtc_time *);
-static int amiga_set_clock_mmss(unsigned long);
-static unsigned int amiga_get_ss(void);
 extern void amiga_mksound(unsigned int count, unsigned int ticks);
 static void amiga_reset(void);
 extern void amiga_init_sound(void);
@@ -138,10 +134,6 @@ static struct {
 	}
 };
 
-static struct resource rtc_resource = {
-	.start = 0x00dc0000, .end = 0x00dcffff
-};
-
 static struct resource ram_resource[NUM_MEMINFO];
 
 
@@ -387,15 +379,6 @@ void __init config_amiga(void)
 	mach_get_model       = amiga_get_model;
 	mach_get_hardware_list = amiga_get_hardware_list;
 	mach_gettimeoffset   = amiga_gettimeoffset;
-	if (AMIGAHW_PRESENT(A3000_CLK)) {
-		mach_hwclk         = a3000_hwclk;
-		rtc_resource.name = "A3000 RTC";
-		request_resource(&iomem_resource, &rtc_resource);
-	} else /* if (AMIGAHW_PRESENT(A2000_CLK)) */ {
-		mach_hwclk         = a2000_hwclk;
-		rtc_resource.name = "A2000 RTC";
-		request_resource(&iomem_resource, &rtc_resource);
-	}
 
 	/*
 	 * default MAX_DMA=0xffffffff on all machines. If we don't do so, the SCSI
@@ -404,8 +387,6 @@ void __init config_amiga(void)
 	 */
 	mach_max_dma_address = 0xffffffff;
 
-	mach_set_clock_mmss  = amiga_set_clock_mmss;
-	mach_get_ss          = amiga_get_ss;
 	mach_reset           = amiga_reset;
 #if defined(CONFIG_INPUT_M68K_BEEP) || defined(CONFIG_INPUT_M68K_BEEP_MODULE)
 	mach_beep            = amiga_mksound;
@@ -530,161 +511,6 @@ static unsigned long amiga_gettimeoffset(void)
 	return ticks + offset;
 }
 
-static int a3000_hwclk(int op, struct rtc_time *t)
-{
-	tod_3000.cntrl1 = TOD3000_CNTRL1_HOLD;
-
-	if (!op) { /* read */
-		t->tm_sec  = tod_3000.second1 * 10 + tod_3000.second2;
-		t->tm_min  = tod_3000.minute1 * 10 + tod_3000.minute2;
-		t->tm_hour = tod_3000.hour1   * 10 + tod_3000.hour2;
-		t->tm_mday = tod_3000.day1    * 10 + tod_3000.day2;
-		t->tm_wday = tod_3000.weekday;
-		t->tm_mon  = tod_3000.month1  * 10 + tod_3000.month2 - 1;
-		t->tm_year = tod_3000.year1   * 10 + tod_3000.year2;
-		if (t->tm_year <= 69)
-			t->tm_year += 100;
-	} else {
-		tod_3000.second1 = t->tm_sec / 10;
-		tod_3000.second2 = t->tm_sec % 10;
-		tod_3000.minute1 = t->tm_min / 10;
-		tod_3000.minute2 = t->tm_min % 10;
-		tod_3000.hour1   = t->tm_hour / 10;
-		tod_3000.hour2   = t->tm_hour % 10;
-		tod_3000.day1    = t->tm_mday / 10;
-		tod_3000.day2    = t->tm_mday % 10;
-		if (t->tm_wday != -1)
-			tod_3000.weekday = t->tm_wday;
-		tod_3000.month1  = (t->tm_mon + 1) / 10;
-		tod_3000.month2  = (t->tm_mon + 1) % 10;
-		if (t->tm_year >= 100)
-			t->tm_year -= 100;
-		tod_3000.year1   = t->tm_year / 10;
-		tod_3000.year2   = t->tm_year % 10;
-	}
-
-	tod_3000.cntrl1 = TOD3000_CNTRL1_FREE;
-
-	return 0;
-}
-
-static int a2000_hwclk(int op, struct rtc_time *t)
-{
-	int cnt = 5;
-
-	tod_2000.cntrl1 = TOD2000_CNTRL1_HOLD;
-
-	while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt) {
-		tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
-		udelay(70);
-		tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
-		--cnt;
-	}
-
-	if (!cnt)
-		printk(KERN_INFO "hwclk: timed out waiting for RTC (0x%x)\n",
-			tod_2000.cntrl1);
-
-	if (!op) { /* read */
-		t->tm_sec  = tod_2000.second1     * 10 + tod_2000.second2;
-		t->tm_min  = tod_2000.minute1     * 10 + tod_2000.minute2;
-		t->tm_hour = (tod_2000.hour1 & 3) * 10 + tod_2000.hour2;
-		t->tm_mday = tod_2000.day1        * 10 + tod_2000.day2;
-		t->tm_wday = tod_2000.weekday;
-		t->tm_mon  = tod_2000.month1      * 10 + tod_2000.month2 - 1;
-		t->tm_year = tod_2000.year1       * 10 + tod_2000.year2;
-		if (t->tm_year <= 69)
-			t->tm_year += 100;
-
-		if (!(tod_2000.cntrl3 & TOD2000_CNTRL3_24HMODE)) {
-			if (!(tod_2000.hour1 & TOD2000_HOUR1_PM) && t->tm_hour == 12)
-				t->tm_hour = 0;
-			else if ((tod_2000.hour1 & TOD2000_HOUR1_PM) && t->tm_hour != 12)
-				t->tm_hour += 12;
-		}
-	} else {
-		tod_2000.second1 = t->tm_sec / 10;
-		tod_2000.second2 = t->tm_sec % 10;
-		tod_2000.minute1 = t->tm_min / 10;
-		tod_2000.minute2 = t->tm_min % 10;
-		if (tod_2000.cntrl3 & TOD2000_CNTRL3_24HMODE)
-			tod_2000.hour1 = t->tm_hour / 10;
-		else if (t->tm_hour >= 12)
-			tod_2000.hour1 = TOD2000_HOUR1_PM +
-				(t->tm_hour - 12) / 10;
-		else
-			tod_2000.hour1 = t->tm_hour / 10;
-		tod_2000.hour2   = t->tm_hour % 10;
-		tod_2000.day1    = t->tm_mday / 10;
-		tod_2000.day2    = t->tm_mday % 10;
-		if (t->tm_wday != -1)
-			tod_2000.weekday = t->tm_wday;
-		tod_2000.month1  = (t->tm_mon + 1) / 10;
-		tod_2000.month2  = (t->tm_mon + 1) % 10;
-		if (t->tm_year >= 100)
-			t->tm_year -= 100;
-		tod_2000.year1   = t->tm_year / 10;
-		tod_2000.year2   = t->tm_year % 10;
-	}
-
-	tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
-
-	return 0;
-}
-
-static int amiga_set_clock_mmss(unsigned long nowtime)
-{
-	short real_seconds = nowtime % 60, real_minutes = (nowtime / 60) % 60;
-
-	if (AMIGAHW_PRESENT(A3000_CLK)) {
-		tod_3000.cntrl1 = TOD3000_CNTRL1_HOLD;
-
-		tod_3000.second1 = real_seconds / 10;
-		tod_3000.second2 = real_seconds % 10;
-		tod_3000.minute1 = real_minutes / 10;
-		tod_3000.minute2 = real_minutes % 10;
-
-		tod_3000.cntrl1 = TOD3000_CNTRL1_FREE;
-	} else /* if (AMIGAHW_PRESENT(A2000_CLK)) */ {
-		int cnt = 5;
-
-		tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
-
-		while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt) {
-			tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
-			udelay(70);
-			tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
-			--cnt;
-		}
-
-		if (!cnt)
-			printk(KERN_INFO "set_clock_mmss: timed out waiting for RTC (0x%x)\n", tod_2000.cntrl1);
-
-		tod_2000.second1 = real_seconds / 10;
-		tod_2000.second2 = real_seconds % 10;
-		tod_2000.minute1 = real_minutes / 10;
-		tod_2000.minute2 = real_minutes % 10;
-
-		tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
-	}
-
-	return 0;
-}
-
-static unsigned int amiga_get_ss(void)
-{
-	unsigned int s;
-
-	if (AMIGAHW_PRESENT(A3000_CLK)) {
-		tod_3000.cntrl1 = TOD3000_CNTRL1_HOLD;
-		s = tod_3000.second1 * 10 + tod_3000.second2;
-		tod_3000.cntrl1 = TOD3000_CNTRL1_FREE;
-	} else /* if (AMIGAHW_PRESENT(A2000_CLK)) */ {
-		s = tod_2000.second1 * 10 + tod_2000.second2;
-	}
-	return s;
-}
-
 static NORET_TYPE void amiga_reset(void)
     ATTRIB_NORET;
 

commit 1a0caf41c061868eff05a054ff2b0ffe26baf4e0
Author: Julia Lawall <julia@diku.dk>
Date:   Sun Aug 2 10:47:47 2009 +0200

    m68k: Use DIV_ROUND_CLOSEST
    
    The kernel.h macro DIV_ROUND_CLOSEST performs the computation (x + d/2)/d
    but is perhaps more readable.
    
    The semantic patch that makes this change is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @haskernel@
    @@
    
    @depends on haskernel@
    expression x,__divisor;
    @@
    
    - (((x) + ((__divisor) / 2)) / (__divisor))
    + DIV_ROUND_CLOSEST(x,__divisor)
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 6c74751c7b82..d2cc35d98532 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -480,7 +480,7 @@ static void __init amiga_sched_init(irq_handler_t timer_routine)
 	static struct resource sched_res = {
 		.name = "timer", .start = 0x00bfd400, .end = 0x00bfd5ff,
 	};
-	jiffy_ticks = (amiga_eclock+HZ/2)/HZ;
+	jiffy_ticks = DIV_ROUND_CLOSEST(amiga_eclock, HZ);
 
 	if (request_resource(&mb_resources._ciab, &sched_res))
 		printk("Cannot allocate ciab.ta{lo,hi}\n");

commit dd9b3e84f2095ed19582f4df5d20e1e40c01ca3c
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Wed Jun 17 13:13:57 2009 -0700

    m68k: cnt reaches -1, not 0
    
    With the postfix decrement cnt reaches -1 rather than 0.
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 6e562751ad51..6c74751c7b82 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -574,10 +574,11 @@ static int a2000_hwclk(int op, struct rtc_time *t)
 
 	tod_2000.cntrl1 = TOD2000_CNTRL1_HOLD;
 
-	while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt--) {
+	while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt) {
 		tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
 		udelay(70);
 		tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
+		--cnt;
 	}
 
 	if (!cnt)
@@ -649,10 +650,11 @@ static int amiga_set_clock_mmss(unsigned long nowtime)
 
 		tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
 
-		while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt--) {
+		while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt) {
 			tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
 			udelay(70);
 			tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
+			--cnt;
 		}
 
 		if (!cnt)

commit 66acd2581259d80935fc5216b4b1268d639d9143
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Dec 30 14:00:34 2008 +0100

    m68k: amiga core - Kill warn_unused_result warnings
    
    warning: ignoring return value of 'request_irq', declared with attribute
    warn_unused_result
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index ab9862c3a136..6e562751ad51 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -493,7 +493,8 @@ static void __init amiga_sched_init(irq_handler_t timer_routine)
 	 * Please don't change this to use ciaa, as it interferes with the
 	 * SCSI code. We'll have to take a look at this later
 	 */
-	request_irq(IRQ_AMIGA_CIAB_TA, timer_routine, 0, "timer", NULL);
+	if (request_irq(IRQ_AMIGA_CIAB_TA, timer_routine, 0, "timer", NULL))
+		pr_err("Couldn't register timer interrupt\n");
 	/* start timer */
 	ciab.cra |= 0x11;
 }

commit 813dcf7a6e642feb1ea566b96ce2912249d2b57d
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Fri Oct 3 22:42:36 2008 +0400

    proc: move /proc/hardware to m68k-specific code
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 0a3f9e8ebde0..ab9862c3a136 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -15,6 +15,7 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
+#include <linux/seq_file.h>
 #include <linux/tty.h>
 #include <linux/console.h>
 #include <linux/rtc.h>
@@ -93,7 +94,7 @@ static char amiga_model_name[13] = "Amiga ";
 
 static void amiga_sched_init(irq_handler_t handler);
 static void amiga_get_model(char *model);
-static int amiga_get_hardware_list(char *buffer);
+static void amiga_get_hardware_list(struct seq_file *m);
 /* amiga specific timer functions */
 static unsigned long amiga_gettimeoffset(void);
 static int a3000_hwclk(int, struct rtc_time *);
@@ -911,13 +912,11 @@ static void amiga_get_model(char *model)
 }
 
 
-static int amiga_get_hardware_list(char *buffer)
+static void amiga_get_hardware_list(struct seq_file *m)
 {
-	int len = 0;
-
 	if (AMIGAHW_PRESENT(CHIP_RAM))
-		len += sprintf(buffer+len, "Chip RAM:\t%ldK\n", amiga_chip_size>>10);
-	len += sprintf(buffer+len, "PS Freq:\t%dHz\nEClock Freq:\t%ldHz\n",
+		seq_printf(m, "Chip RAM:\t%ldK\n", amiga_chip_size>>10);
+	seq_printf(m, "PS Freq:\t%dHz\nEClock Freq:\t%ldHz\n",
 			amiga_psfreq, amiga_eclock);
 	if (AMIGAHW_PRESENT(AMI_VIDEO)) {
 		char *type;
@@ -935,14 +934,14 @@ static int amiga_get_hardware_list(char *buffer)
 			type = "Old or Unknown";
 			break;
 		}
-		len += sprintf(buffer+len, "Graphics:\t%s\n", type);
+		seq_printf(m, "Graphics:\t%s\n", type);
 	}
 
 #define AMIGAHW_ANNOUNCE(name, str)			\
 	if (AMIGAHW_PRESENT(name))			\
-		len += sprintf (buffer+len, "\t%s\n", str)
+		seq_printf (m, "\t%s\n", str)
 
-	len += sprintf (buffer + len, "Detected hardware:\n");
+	seq_printf (m, "Detected hardware:\n");
 
 	AMIGAHW_ANNOUNCE(AMI_VIDEO, "Amiga Video");
 	AMIGAHW_ANNOUNCE(AMI_BLITTER, "Blitter");
@@ -975,15 +974,13 @@ static int amiga_get_hardware_list(char *buffer)
 	AMIGAHW_ANNOUNCE(PCMCIA, "PCMCIA Slot");
 #ifdef CONFIG_ZORRO
 	if (AMIGAHW_PRESENT(ZORRO))
-		len += sprintf(buffer+len, "\tZorro II%s AutoConfig: %d Expansion "
+		seq_printf(m, "\tZorro II%s AutoConfig: %d Expansion "
 				"Device%s\n",
 				AMIGAHW_PRESENT(ZORRO3) ? "I" : "",
 				zorro_num_autocon, zorro_num_autocon == 1 ? "" : "s");
 #endif /* CONFIG_ZORRO */
 
 #undef AMIGAHW_ANNOUNCE
-
-	return len;
 }
 
 /*

commit 39d2d99d988142b7db38afab568c72da03b96237
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Oct 13 21:58:53 2008 +0200

    m68k: Modular Amiga keyboard needs key_maps
    
    | ERROR: "key_maps" [drivers/input/keyboard/amikbd.ko] undefined!
    
    Export key_maps in the Amiga core code, as its defined in an autogenerated
    file (drivers/char/defkeymap.c)
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index df679d96b1cb..0a3f9e8ebde0 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -24,6 +24,7 @@
 #include <linux/interrupt.h>
 #include <linux/zorro.h>
 #include <linux/module.h>
+#include <linux/keyboard.h>
 
 #include <asm/bootinfo.h>
 #include <asm/setup.h>
@@ -984,3 +985,11 @@ static int amiga_get_hardware_list(char *buffer)
 
 	return len;
 }
+
+/*
+ * The Amiga keyboard driver needs key_maps, but we cannot export it in
+ * drivers/char/defkeymap.c, as it is autogenerated
+ */
+#ifdef CONFIG_HW_CONSOLE
+EXPORT_SYMBOL_GPL(key_maps);
+#endif

commit 0795dbcc4c4c93a929463957993c04cf5fec346c
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jul 17 21:16:23 2008 +0200

    m68k/amiga/: possible cleanups
    
    This patch contains the following possible cleanups:
    - amiints.c: add a proper prototype for amiga_init_IRQ() in
                 include/asm-m68k/amigaints.h
    - make the following needlessly global code static:
      - config.c: amiga_model
      - config.c: amiga_psfreq
      - config.c: amiga_serial_console_write()
    - #if 0 the following unused functions:
      - config.c: amiga_serial_puts()
      - config.c: amiga_serial_console_wait_key()
      - config.c: amiga_serial_gets()
    - remove the following unused variable:
      - config.c: amiga_masterclock
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index dd0734e54bb8..df679d96b1cb 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -36,14 +36,11 @@
 #include <asm/machdep.h>
 #include <asm/io.h>
 
-unsigned long amiga_model;
-EXPORT_SYMBOL(amiga_model);
+static unsigned long amiga_model;
 
 unsigned long amiga_eclock;
 EXPORT_SYMBOL(amiga_eclock);
 
-unsigned long amiga_masterclock;
-
 unsigned long amiga_colorclock;
 EXPORT_SYMBOL(amiga_colorclock);
 
@@ -53,7 +50,7 @@ EXPORT_SYMBOL(amiga_chipset);
 unsigned char amiga_vblank;
 EXPORT_SYMBOL(amiga_vblank);
 
-unsigned char amiga_psfreq;
+static unsigned char amiga_psfreq;
 
 struct amiga_hw_present amiga_hw_present;
 EXPORT_SYMBOL(amiga_hw_present);
@@ -94,8 +91,6 @@ static char *amiga_models[] __initdata = {
 static char amiga_model_name[13] = "Amiga ";
 
 static void amiga_sched_init(irq_handler_t handler);
-/* amiga specific irq functions */
-extern void amiga_init_IRQ(void);
 static void amiga_get_model(char *model);
 static int amiga_get_hardware_list(char *buffer);
 /* amiga specific timer functions */
@@ -109,8 +104,6 @@ static void amiga_reset(void);
 extern void amiga_init_sound(void);
 static void amiga_mem_console_write(struct console *co, const char *b,
 				    unsigned int count);
-void amiga_serial_console_write(struct console *co, const char *s,
-				unsigned int count);
 #ifdef CONFIG_HEARTBEAT
 static void amiga_heartbeat(int on);
 #endif
@@ -420,8 +413,7 @@ void __init config_amiga(void)
 	mach_heartbeat = amiga_heartbeat;
 #endif
 
-	/* Fill in the clock values (based on the 700 kHz E-Clock) */
-	amiga_masterclock = 40*amiga_eclock;	/* 28 MHz */
+	/* Fill in the clock value (based on the 700 kHz E-Clock) */
 	amiga_colorclock = 5*amiga_eclock;	/* 3.5 MHz */
 
 	/* clear all DMA bits */
@@ -819,8 +811,8 @@ static void amiga_serial_putc(char c)
 		;
 }
 
-void amiga_serial_console_write(struct console *co, const char *s,
-				unsigned int count)
+static void amiga_serial_console_write(struct console *co, const char *s,
+				       unsigned int count)
 {
 	while (count--) {
 		if (*s == '\n')
@@ -829,7 +821,7 @@ void amiga_serial_console_write(struct console *co, const char *s,
 	}
 }
 
-#ifdef CONFIG_SERIAL_CONSOLE
+#if 0
 void amiga_serial_puts(const char *s)
 {
 	amiga_serial_console_write(NULL, s, strlen(s));

commit 8468afc039f03837066132be14cdd9e5fa726f0b
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jul 17 21:16:21 2008 +0200

    export amiga_vblank
    
    This patch fixes the following build error:
    
    <--  snip  -->
    
    ..
      Building modules, stage 2.
      MODPOST 1203 modules
    ERROR: "amiga_vblank" [drivers/video/amifb.ko] undefined!
    ..
    make[2]: *** [__modpost] Error 1
    
    <--  snip  -->
    
    Reported-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 50f5daab46b7..dd0734e54bb8 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -51,6 +51,8 @@ unsigned long amiga_chipset;
 EXPORT_SYMBOL(amiga_chipset);
 
 unsigned char amiga_vblank;
+EXPORT_SYMBOL(amiga_vblank);
+
 unsigned char amiga_psfreq;
 
 struct amiga_hw_present amiga_hw_present;

commit 8b169fa2c942bc2a579da3f33986bd3fc48d9684
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Feb 4 22:30:25 2008 -0800

    m68k: kill arch/m68k/amiga/amiga_ksyms.c
    
    EXPORT_SYMBOL's belong to the actual code.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 35748531327d..50f5daab46b7 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -23,6 +23,7 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/zorro.h>
+#include <linux/module.h>
 
 #include <asm/bootinfo.h>
 #include <asm/setup.h>
@@ -36,13 +37,24 @@
 #include <asm/io.h>
 
 unsigned long amiga_model;
+EXPORT_SYMBOL(amiga_model);
+
 unsigned long amiga_eclock;
+EXPORT_SYMBOL(amiga_eclock);
+
 unsigned long amiga_masterclock;
+
 unsigned long amiga_colorclock;
+EXPORT_SYMBOL(amiga_colorclock);
+
 unsigned long amiga_chipset;
+EXPORT_SYMBOL(amiga_chipset);
+
 unsigned char amiga_vblank;
 unsigned char amiga_psfreq;
+
 struct amiga_hw_present amiga_hw_present;
+EXPORT_SYMBOL(amiga_hw_present);
 
 static char s_a500[] __initdata = "A500";
 static char s_a500p[] __initdata = "A500+";

commit d6713b4091a99fa2af2fabdcd2f3fb97f32ecf2e
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue May 1 22:32:45 2007 +0200

    m68k: early parameter support
    
    Add early parameter support and convert current users to it.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index c3b69b1b0cef..35748531327d 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -79,8 +79,6 @@ static char *amiga_models[] __initdata = {
 
 static char amiga_model_name[13] = "Amiga ";
 
-extern char m68k_debug_device[];
-
 static void amiga_sched_init(irq_handler_t handler);
 /* amiga specific irq functions */
 extern void amiga_init_IRQ(void);
@@ -95,12 +93,10 @@ static unsigned int amiga_get_ss(void);
 extern void amiga_mksound(unsigned int count, unsigned int ticks);
 static void amiga_reset(void);
 extern void amiga_init_sound(void);
-static void amiga_savekmsg_init(void);
 static void amiga_mem_console_write(struct console *co, const char *b,
 				    unsigned int count);
 void amiga_serial_console_write(struct console *co, const char *s,
 				unsigned int count);
-static void amiga_debug_init(void);
 #ifdef CONFIG_HEARTBEAT
 static void amiga_heartbeat(int on);
 #endif
@@ -370,7 +366,6 @@ void __init config_amiga(void)
 {
 	int i;
 
-	amiga_debug_init();
 	amiga_identify();
 
 	/* Yuk, we don't have PCI memory */
@@ -458,17 +453,6 @@ void __init config_amiga(void)
 	/* initialize chipram allocator */
 	amiga_chip_init();
 
-	/* debugging using chipram */
-	if (!strcmp(m68k_debug_device, "mem")) {
-		if (!AMIGAHW_PRESENT(CHIP_RAM))
-			printk("Warning: no chipram present for debugging\n");
-		else {
-			amiga_savekmsg_init();
-			amiga_console_driver.write = amiga_mem_console_write;
-			register_console(&amiga_console_driver);
-		}
-	}
-
 	/* our beloved beeper */
 	if (AMIGAHW_PRESENT(AMI_AUDIO))
 		amiga_init_sound();
@@ -787,17 +771,33 @@ static void amiga_mem_console_write(struct console *co, const char *s,
 	}
 }
 
-static void amiga_savekmsg_init(void)
+static int __init amiga_savekmsg_setup(char *arg)
 {
 	static struct resource debug_res = { .name = "Debug" };
 
+	if (!MACH_IS_AMIGA || strcmp(arg, "mem"))
+		goto done;
+
+	if (!AMIGAHW_PRESENT(CHIP_RAM)) {
+		printk("Warning: no chipram present for debugging\n");
+		goto done;
+	}
+
 	savekmsg = amiga_chip_alloc_res(SAVEKMSG_MAXMEM, &debug_res);
 	savekmsg->magic1 = SAVEKMSG_MAGIC1;
 	savekmsg->magic2 = SAVEKMSG_MAGIC2;
 	savekmsg->magicptr = ZTWO_PADDR(savekmsg);
 	savekmsg->size = 0;
+
+	amiga_console_driver.write = amiga_mem_console_write;
+	register_console(&amiga_console_driver);
+
+done:
+	return 0;
 }
 
+early_param("debug", amiga_savekmsg_setup);
+
 static void amiga_serial_putc(char c)
 {
 	amiga_custom.serdat = (unsigned char)c | 0x100;
@@ -872,15 +872,18 @@ void amiga_serial_gets(struct console *co, char *s, int len)
 }
 #endif
 
-static void __init amiga_debug_init(void)
+static int __init amiga_debug_setup(char *arg)
 {
-	if (!strcmp(m68k_debug_device, "ser" )) {
+	if (MACH_IS_AMIGA && !strcmp(arg, "ser")) {
 		/* no initialization required (?) */
 		amiga_console_driver.write = amiga_serial_console_write;
 		register_console(&amiga_console_driver);
 	}
+	return 0;
 }
 
+early_param("debug", amiga_debug_setup);
+
 #ifdef CONFIG_HEARTBEAT
 static void amiga_heartbeat(int on)
 {

commit 6ff5801acbb643e81d3420ac0f37c96089309063
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue May 1 22:32:43 2007 +0200

    m68k: reformat various m68k files
    
    Reformat various m68k files, so they actually look like Linux sources.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 3204f412cad8..c3b69b1b0cef 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -22,9 +22,7 @@
 #include <linux/vt_kern.h>
 #include <linux/delay.h>
 #include <linux/interrupt.h>
-#ifdef CONFIG_ZORRO
 #include <linux/zorro.h>
-#endif
 
 #include <asm/bootinfo.h>
 #include <asm/setup.h>
@@ -62,21 +60,21 @@ static char s_cdtv[] __initdata = "CDTV";
 static char s_cd32[] __initdata = "CD32";
 static char s_draco[] __initdata = "Draco";
 static char *amiga_models[] __initdata = {
-    [AMI_500-AMI_500]		= s_a500,
-    [AMI_500PLUS-AMI_500]	= s_a500p,
-    [AMI_600-AMI_500]		= s_a600,
-    [AMI_1000-AMI_500]		= s_a1000,
-    [AMI_1200-AMI_500]		= s_a1200,
-    [AMI_2000-AMI_500]		= s_a2000,
-    [AMI_2500-AMI_500]		= s_a2500,
-    [AMI_3000-AMI_500]		= s_a3000,
-    [AMI_3000T-AMI_500]		= s_a3000t,
-    [AMI_3000PLUS-AMI_500]	= s_a3000p,
-    [AMI_4000-AMI_500]		= s_a4000,
-    [AMI_4000T-AMI_500]		= s_a4000t,
-    [AMI_CDTV-AMI_500]		= s_cdtv,
-    [AMI_CD32-AMI_500]		= s_cd32,
-    [AMI_DRACO-AMI_500]		= s_draco,
+	[AMI_500-AMI_500]	= s_a500,
+	[AMI_500PLUS-AMI_500]	= s_a500p,
+	[AMI_600-AMI_500]	= s_a600,
+	[AMI_1000-AMI_500]	= s_a1000,
+	[AMI_1200-AMI_500]	= s_a1200,
+	[AMI_2000-AMI_500]	= s_a2000,
+	[AMI_2500-AMI_500]	= s_a2500,
+	[AMI_3000-AMI_500]	= s_a3000,
+	[AMI_3000T-AMI_500]	= s_a3000t,
+	[AMI_3000PLUS-AMI_500]	= s_a3000p,
+	[AMI_4000-AMI_500]	= s_a4000,
+	[AMI_4000T-AMI_500]	= s_a4000t,
+	[AMI_CDTV-AMI_500]	= s_cdtv,
+	[AMI_CD32-AMI_500]	= s_cd32,
+	[AMI_DRACO-AMI_500]	= s_draco,
 };
 
 static char amiga_model_name[13] = "Amiga ";
@@ -85,17 +83,17 @@ extern char m68k_debug_device[];
 
 static void amiga_sched_init(irq_handler_t handler);
 /* amiga specific irq functions */
-extern void amiga_init_IRQ (void);
+extern void amiga_init_IRQ(void);
 static void amiga_get_model(char *model);
 static int amiga_get_hardware_list(char *buffer);
 /* amiga specific timer functions */
-static unsigned long amiga_gettimeoffset (void);
-static int a3000_hwclk (int, struct rtc_time *);
-static int a2000_hwclk (int, struct rtc_time *);
-static int amiga_set_clock_mmss (unsigned long);
-static unsigned int amiga_get_ss (void);
-extern void amiga_mksound( unsigned int count, unsigned int ticks );
-static void amiga_reset (void);
+static unsigned long amiga_gettimeoffset(void);
+static int a3000_hwclk(int, struct rtc_time *);
+static int a2000_hwclk(int, struct rtc_time *);
+static int amiga_set_clock_mmss(unsigned long);
+static unsigned int amiga_get_ss(void);
+extern void amiga_mksound(unsigned int count, unsigned int ticks);
+static void amiga_reset(void);
 extern void amiga_init_sound(void);
 static void amiga_savekmsg_init(void);
 static void amiga_mem_console_write(struct console *co, const char *b,
@@ -108,9 +106,9 @@ static void amiga_heartbeat(int on);
 #endif
 
 static struct console amiga_console_driver = {
-	.name =		"debug",
-	.flags =	CON_PRINTBUFFER,
-	.index =	-1,
+	.name	= "debug",
+	.flags	= CON_PRINTBUFFER,
+	.index	= -1,
 };
 
 
@@ -119,24 +117,24 @@ static struct console amiga_console_driver = {
      */
 
 static struct {
-    struct resource _ciab, _ciaa, _custom, _kickstart;
+	struct resource _ciab, _ciaa, _custom, _kickstart;
 } mb_resources = {
-    ._ciab = {
-	.name = "CIA B", .start = 0x00bfd000, .end = 0x00bfdfff
-    },
-    ._ciaa = {
-	.name = "CIA A", .start = 0x00bfe000, .end = 0x00bfefff
-    },
-    ._custom = {
-	.name = "Custom I/O", .start = 0x00dff000, .end = 0x00dfffff
-    },
-    ._kickstart = {
-	.name = "Kickstart ROM", .start = 0x00f80000, .end = 0x00ffffff
-    }
+	._ciab = {
+		.name = "CIA B", .start = 0x00bfd000, .end = 0x00bfdfff
+	},
+	._ciaa = {
+		.name = "CIA A", .start = 0x00bfe000, .end = 0x00bfefff
+	},
+	._custom = {
+		.name = "Custom I/O", .start = 0x00dff000, .end = 0x00dfffff
+	},
+	._kickstart = {
+		.name = "Kickstart ROM", .start = 0x00f80000, .end = 0x00ffffff
+	}
 };
 
 static struct resource rtc_resource = {
-    .start = 0x00dc0000, .end = 0x00dcffff
+	.start = 0x00dc0000, .end = 0x00dcffff
 };
 
 static struct resource ram_resource[NUM_MEMINFO];
@@ -148,57 +146,57 @@ static struct resource ram_resource[NUM_MEMINFO];
 
 int amiga_parse_bootinfo(const struct bi_record *record)
 {
-    int unknown = 0;
-    const unsigned long *data = record->data;
+	int unknown = 0;
+	const unsigned long *data = record->data;
 
-    switch (record->tag) {
+	switch (record->tag) {
 	case BI_AMIGA_MODEL:
-	    amiga_model = *data;
-	    break;
+		amiga_model = *data;
+		break;
 
 	case BI_AMIGA_ECLOCK:
-	    amiga_eclock = *data;
-	    break;
+		amiga_eclock = *data;
+		break;
 
 	case BI_AMIGA_CHIPSET:
-	    amiga_chipset = *data;
-	    break;
+		amiga_chipset = *data;
+		break;
 
 	case BI_AMIGA_CHIP_SIZE:
-	    amiga_chip_size = *(const int *)data;
-	    break;
+		amiga_chip_size = *(const int *)data;
+		break;
 
 	case BI_AMIGA_VBLANK:
-	    amiga_vblank = *(const unsigned char *)data;
-	    break;
+		amiga_vblank = *(const unsigned char *)data;
+		break;
 
 	case BI_AMIGA_PSFREQ:
-	    amiga_psfreq = *(const unsigned char *)data;
-	    break;
+		amiga_psfreq = *(const unsigned char *)data;
+		break;
 
 	case BI_AMIGA_AUTOCON:
 #ifdef CONFIG_ZORRO
-	    if (zorro_num_autocon < ZORRO_NUM_AUTO) {
-		const struct ConfigDev *cd = (struct ConfigDev *)data;
-		struct zorro_dev *dev = &zorro_autocon[zorro_num_autocon++];
-		dev->rom = cd->cd_Rom;
-		dev->slotaddr = cd->cd_SlotAddr;
-		dev->slotsize = cd->cd_SlotSize;
-		dev->resource.start = (unsigned long)cd->cd_BoardAddr;
-		dev->resource.end = dev->resource.start+cd->cd_BoardSize-1;
-	    } else
-		printk("amiga_parse_bootinfo: too many AutoConfig devices\n");
+		if (zorro_num_autocon < ZORRO_NUM_AUTO) {
+			const struct ConfigDev *cd = (struct ConfigDev *)data;
+			struct zorro_dev *dev = &zorro_autocon[zorro_num_autocon++];
+			dev->rom = cd->cd_Rom;
+			dev->slotaddr = cd->cd_SlotAddr;
+			dev->slotsize = cd->cd_SlotSize;
+			dev->resource.start = (unsigned long)cd->cd_BoardAddr;
+			dev->resource.end = dev->resource.start + cd->cd_BoardSize - 1;
+		} else
+			printk("amiga_parse_bootinfo: too many AutoConfig devices\n");
 #endif /* CONFIG_ZORRO */
-	    break;
+		break;
 
 	case BI_AMIGA_SERPER:
-	    /* serial port period: ignored here */
-	    break;
+		/* serial port period: ignored here */
+		break;
 
 	default:
-	    unknown = 1;
-    }
-    return(unknown);
+		unknown = 1;
+	}
+	return unknown;
 }
 
     /*
@@ -207,159 +205,159 @@ int amiga_parse_bootinfo(const struct bi_record *record)
 
 static void __init amiga_identify(void)
 {
-  /* Fill in some default values, if necessary */
-  if (amiga_eclock == 0)
-    amiga_eclock = 709379;
-
-  memset(&amiga_hw_present, 0, sizeof(amiga_hw_present));
-
-  printk("Amiga hardware found: ");
-  if (amiga_model >= AMI_500 && amiga_model <= AMI_DRACO) {
-    printk("[%s] ", amiga_models[amiga_model-AMI_500]);
-    strcat(amiga_model_name, amiga_models[amiga_model-AMI_500]);
-  }
-
-  switch(amiga_model) {
-  case AMI_UNKNOWN:
-    goto Generic;
-
-  case AMI_600:
-  case AMI_1200:
-    AMIGAHW_SET(A1200_IDE);
-    AMIGAHW_SET(PCMCIA);
-  case AMI_500:
-  case AMI_500PLUS:
-  case AMI_1000:
-  case AMI_2000:
-  case AMI_2500:
-    AMIGAHW_SET(A2000_CLK);	/* Is this correct for all models? */
-    goto Generic;
-
-  case AMI_3000:
-  case AMI_3000T:
-    AMIGAHW_SET(AMBER_FF);
-    AMIGAHW_SET(MAGIC_REKICK);
-    /* fall through */
-  case AMI_3000PLUS:
-    AMIGAHW_SET(A3000_SCSI);
-    AMIGAHW_SET(A3000_CLK);
-    AMIGAHW_SET(ZORRO3);
-    goto Generic;
-
-  case AMI_4000T:
-    AMIGAHW_SET(A4000_SCSI);
-    /* fall through */
-  case AMI_4000:
-    AMIGAHW_SET(A4000_IDE);
-    AMIGAHW_SET(A3000_CLK);
-    AMIGAHW_SET(ZORRO3);
-    goto Generic;
-
-  case AMI_CDTV:
-  case AMI_CD32:
-    AMIGAHW_SET(CD_ROM);
-    AMIGAHW_SET(A2000_CLK);             /* Is this correct? */
-    goto Generic;
-
-  Generic:
-    AMIGAHW_SET(AMI_VIDEO);
-    AMIGAHW_SET(AMI_BLITTER);
-    AMIGAHW_SET(AMI_AUDIO);
-    AMIGAHW_SET(AMI_FLOPPY);
-    AMIGAHW_SET(AMI_KEYBOARD);
-    AMIGAHW_SET(AMI_MOUSE);
-    AMIGAHW_SET(AMI_SERIAL);
-    AMIGAHW_SET(AMI_PARALLEL);
-    AMIGAHW_SET(CHIP_RAM);
-    AMIGAHW_SET(PAULA);
-
-    switch(amiga_chipset) {
-    case CS_OCS:
-    case CS_ECS:
-    case CS_AGA:
-      switch (amiga_custom.deniseid & 0xf) {
-      case 0x0c:
-	AMIGAHW_SET(DENISE_HR);
-	break;
-      case 0x08:
-	AMIGAHW_SET(LISA);
-	break;
-      }
-      break;
-    default:
-      AMIGAHW_SET(DENISE);
-      break;
-    }
-    switch ((amiga_custom.vposr>>8) & 0x7f) {
-    case 0x00:
-      AMIGAHW_SET(AGNUS_PAL);
-      break;
-    case 0x10:
-      AMIGAHW_SET(AGNUS_NTSC);
-      break;
-    case 0x20:
-    case 0x21:
-      AMIGAHW_SET(AGNUS_HR_PAL);
-      break;
-    case 0x30:
-    case 0x31:
-      AMIGAHW_SET(AGNUS_HR_NTSC);
-      break;
-    case 0x22:
-    case 0x23:
-      AMIGAHW_SET(ALICE_PAL);
-      break;
-    case 0x32:
-    case 0x33:
-      AMIGAHW_SET(ALICE_NTSC);
-      break;
-    }
-    AMIGAHW_SET(ZORRO);
-    break;
-
-  case AMI_DRACO:
-    panic("No support for Draco yet");
-
-  default:
-    panic("Unknown Amiga Model");
-  }
+	/* Fill in some default values, if necessary */
+	if (amiga_eclock == 0)
+		amiga_eclock = 709379;
 
-#define AMIGAHW_ANNOUNCE(name, str)			\
-  if (AMIGAHW_PRESENT(name))				\
-    printk(str)
-
-  AMIGAHW_ANNOUNCE(AMI_VIDEO, "VIDEO ");
-  AMIGAHW_ANNOUNCE(AMI_BLITTER, "BLITTER ");
-  AMIGAHW_ANNOUNCE(AMBER_FF, "AMBER_FF ");
-  AMIGAHW_ANNOUNCE(AMI_AUDIO, "AUDIO ");
-  AMIGAHW_ANNOUNCE(AMI_FLOPPY, "FLOPPY ");
-  AMIGAHW_ANNOUNCE(A3000_SCSI, "A3000_SCSI ");
-  AMIGAHW_ANNOUNCE(A4000_SCSI, "A4000_SCSI ");
-  AMIGAHW_ANNOUNCE(A1200_IDE, "A1200_IDE ");
-  AMIGAHW_ANNOUNCE(A4000_IDE, "A4000_IDE ");
-  AMIGAHW_ANNOUNCE(CD_ROM, "CD_ROM ");
-  AMIGAHW_ANNOUNCE(AMI_KEYBOARD, "KEYBOARD ");
-  AMIGAHW_ANNOUNCE(AMI_MOUSE, "MOUSE ");
-  AMIGAHW_ANNOUNCE(AMI_SERIAL, "SERIAL ");
-  AMIGAHW_ANNOUNCE(AMI_PARALLEL, "PARALLEL ");
-  AMIGAHW_ANNOUNCE(A2000_CLK, "A2000_CLK ");
-  AMIGAHW_ANNOUNCE(A3000_CLK, "A3000_CLK ");
-  AMIGAHW_ANNOUNCE(CHIP_RAM, "CHIP_RAM ");
-  AMIGAHW_ANNOUNCE(PAULA, "PAULA ");
-  AMIGAHW_ANNOUNCE(DENISE, "DENISE ");
-  AMIGAHW_ANNOUNCE(DENISE_HR, "DENISE_HR ");
-  AMIGAHW_ANNOUNCE(LISA, "LISA ");
-  AMIGAHW_ANNOUNCE(AGNUS_PAL, "AGNUS_PAL ");
-  AMIGAHW_ANNOUNCE(AGNUS_NTSC, "AGNUS_NTSC ");
-  AMIGAHW_ANNOUNCE(AGNUS_HR_PAL, "AGNUS_HR_PAL ");
-  AMIGAHW_ANNOUNCE(AGNUS_HR_NTSC, "AGNUS_HR_NTSC ");
-  AMIGAHW_ANNOUNCE(ALICE_PAL, "ALICE_PAL ");
-  AMIGAHW_ANNOUNCE(ALICE_NTSC, "ALICE_NTSC ");
-  AMIGAHW_ANNOUNCE(MAGIC_REKICK, "MAGIC_REKICK ");
-  AMIGAHW_ANNOUNCE(PCMCIA, "PCMCIA ");
-  if (AMIGAHW_PRESENT(ZORRO))
-    printk("ZORRO%s ", AMIGAHW_PRESENT(ZORRO3) ? "3" : "");
-  printk("\n");
+	memset(&amiga_hw_present, 0, sizeof(amiga_hw_present));
+
+	printk("Amiga hardware found: ");
+	if (amiga_model >= AMI_500 && amiga_model <= AMI_DRACO) {
+		printk("[%s] ", amiga_models[amiga_model-AMI_500]);
+		strcat(amiga_model_name, amiga_models[amiga_model-AMI_500]);
+	}
+
+	switch (amiga_model) {
+	case AMI_UNKNOWN:
+		goto Generic;
+
+	case AMI_600:
+	case AMI_1200:
+		AMIGAHW_SET(A1200_IDE);
+		AMIGAHW_SET(PCMCIA);
+	case AMI_500:
+	case AMI_500PLUS:
+	case AMI_1000:
+	case AMI_2000:
+	case AMI_2500:
+		AMIGAHW_SET(A2000_CLK);	/* Is this correct for all models? */
+		goto Generic;
+
+	case AMI_3000:
+	case AMI_3000T:
+		AMIGAHW_SET(AMBER_FF);
+		AMIGAHW_SET(MAGIC_REKICK);
+		/* fall through */
+	case AMI_3000PLUS:
+		AMIGAHW_SET(A3000_SCSI);
+		AMIGAHW_SET(A3000_CLK);
+		AMIGAHW_SET(ZORRO3);
+		goto Generic;
+
+	case AMI_4000T:
+		AMIGAHW_SET(A4000_SCSI);
+		/* fall through */
+	case AMI_4000:
+		AMIGAHW_SET(A4000_IDE);
+		AMIGAHW_SET(A3000_CLK);
+		AMIGAHW_SET(ZORRO3);
+		goto Generic;
+
+	case AMI_CDTV:
+	case AMI_CD32:
+		AMIGAHW_SET(CD_ROM);
+		AMIGAHW_SET(A2000_CLK);             /* Is this correct? */
+		goto Generic;
+
+	Generic:
+		AMIGAHW_SET(AMI_VIDEO);
+		AMIGAHW_SET(AMI_BLITTER);
+		AMIGAHW_SET(AMI_AUDIO);
+		AMIGAHW_SET(AMI_FLOPPY);
+		AMIGAHW_SET(AMI_KEYBOARD);
+		AMIGAHW_SET(AMI_MOUSE);
+		AMIGAHW_SET(AMI_SERIAL);
+		AMIGAHW_SET(AMI_PARALLEL);
+		AMIGAHW_SET(CHIP_RAM);
+		AMIGAHW_SET(PAULA);
+
+		switch (amiga_chipset) {
+		case CS_OCS:
+		case CS_ECS:
+		case CS_AGA:
+			switch (amiga_custom.deniseid & 0xf) {
+			case 0x0c:
+				AMIGAHW_SET(DENISE_HR);
+				break;
+			case 0x08:
+				AMIGAHW_SET(LISA);
+				break;
+			}
+			break;
+		default:
+			AMIGAHW_SET(DENISE);
+			break;
+		}
+		switch ((amiga_custom.vposr>>8) & 0x7f) {
+		case 0x00:
+			AMIGAHW_SET(AGNUS_PAL);
+			break;
+		case 0x10:
+			AMIGAHW_SET(AGNUS_NTSC);
+			break;
+		case 0x20:
+		case 0x21:
+			AMIGAHW_SET(AGNUS_HR_PAL);
+			break;
+		case 0x30:
+		case 0x31:
+			AMIGAHW_SET(AGNUS_HR_NTSC);
+			break;
+		case 0x22:
+		case 0x23:
+			AMIGAHW_SET(ALICE_PAL);
+			break;
+		case 0x32:
+		case 0x33:
+			AMIGAHW_SET(ALICE_NTSC);
+			break;
+		}
+		AMIGAHW_SET(ZORRO);
+		break;
+
+	case AMI_DRACO:
+		panic("No support for Draco yet");
+
+	default:
+		panic("Unknown Amiga Model");
+	}
+
+#define AMIGAHW_ANNOUNCE(name, str)		\
+	if (AMIGAHW_PRESENT(name))		\
+		printk(str)
+
+	AMIGAHW_ANNOUNCE(AMI_VIDEO, "VIDEO ");
+	AMIGAHW_ANNOUNCE(AMI_BLITTER, "BLITTER ");
+	AMIGAHW_ANNOUNCE(AMBER_FF, "AMBER_FF ");
+	AMIGAHW_ANNOUNCE(AMI_AUDIO, "AUDIO ");
+	AMIGAHW_ANNOUNCE(AMI_FLOPPY, "FLOPPY ");
+	AMIGAHW_ANNOUNCE(A3000_SCSI, "A3000_SCSI ");
+	AMIGAHW_ANNOUNCE(A4000_SCSI, "A4000_SCSI ");
+	AMIGAHW_ANNOUNCE(A1200_IDE, "A1200_IDE ");
+	AMIGAHW_ANNOUNCE(A4000_IDE, "A4000_IDE ");
+	AMIGAHW_ANNOUNCE(CD_ROM, "CD_ROM ");
+	AMIGAHW_ANNOUNCE(AMI_KEYBOARD, "KEYBOARD ");
+	AMIGAHW_ANNOUNCE(AMI_MOUSE, "MOUSE ");
+	AMIGAHW_ANNOUNCE(AMI_SERIAL, "SERIAL ");
+	AMIGAHW_ANNOUNCE(AMI_PARALLEL, "PARALLEL ");
+	AMIGAHW_ANNOUNCE(A2000_CLK, "A2000_CLK ");
+	AMIGAHW_ANNOUNCE(A3000_CLK, "A3000_CLK ");
+	AMIGAHW_ANNOUNCE(CHIP_RAM, "CHIP_RAM ");
+	AMIGAHW_ANNOUNCE(PAULA, "PAULA ");
+	AMIGAHW_ANNOUNCE(DENISE, "DENISE ");
+	AMIGAHW_ANNOUNCE(DENISE_HR, "DENISE_HR ");
+	AMIGAHW_ANNOUNCE(LISA, "LISA ");
+	AMIGAHW_ANNOUNCE(AGNUS_PAL, "AGNUS_PAL ");
+	AMIGAHW_ANNOUNCE(AGNUS_NTSC, "AGNUS_NTSC ");
+	AMIGAHW_ANNOUNCE(AGNUS_HR_PAL, "AGNUS_HR_PAL ");
+	AMIGAHW_ANNOUNCE(AGNUS_HR_NTSC, "AGNUS_HR_NTSC ");
+	AMIGAHW_ANNOUNCE(ALICE_PAL, "ALICE_PAL ");
+	AMIGAHW_ANNOUNCE(ALICE_NTSC, "ALICE_NTSC ");
+	AMIGAHW_ANNOUNCE(MAGIC_REKICK, "MAGIC_REKICK ");
+	AMIGAHW_ANNOUNCE(PCMCIA, "PCMCIA ");
+	if (AMIGAHW_PRESENT(ZORRO))
+		printk("ZORRO%s ", AMIGAHW_PRESENT(ZORRO3) ? "3" : "");
+	printk("\n");
 
 #undef AMIGAHW_ANNOUNCE
 }
@@ -370,119 +368,117 @@ static void __init amiga_identify(void)
 
 void __init config_amiga(void)
 {
-  int i;
-
-  amiga_debug_init();
-  amiga_identify();
-
-  /* Yuk, we don't have PCI memory */
-  iomem_resource.name = "Memory";
-  for (i = 0; i < 4; i++)
-    request_resource(&iomem_resource, &((struct resource *)&mb_resources)[i]);
-
-  mach_sched_init      = amiga_sched_init;
-  mach_init_IRQ        = amiga_init_IRQ;
-  mach_get_model       = amiga_get_model;
-  mach_get_hardware_list = amiga_get_hardware_list;
-  mach_gettimeoffset   = amiga_gettimeoffset;
-  if (AMIGAHW_PRESENT(A3000_CLK)){
-    mach_hwclk         = a3000_hwclk;
-    rtc_resource.name = "A3000 RTC";
-    request_resource(&iomem_resource, &rtc_resource);
-  }
-  else{ /* if (AMIGAHW_PRESENT(A2000_CLK)) */
-    mach_hwclk         = a2000_hwclk;
-    rtc_resource.name = "A2000 RTC";
-    request_resource(&iomem_resource, &rtc_resource);
-  }
-
-  mach_max_dma_address = 0xffffffff; /*
-				      * default MAX_DMA=0xffffffff
-				      * on all machines. If we don't
-				      * do so, the SCSI code will not
-				      * be able to allocate any mem
-				      * for transfers, unless we are
-				      * dealing with a Z2 mem only
-				      * system.                  /Jes
-				      */
-
-  mach_set_clock_mmss  = amiga_set_clock_mmss;
-  mach_get_ss          = amiga_get_ss;
-  mach_reset           = amiga_reset;
+	int i;
+
+	amiga_debug_init();
+	amiga_identify();
+
+	/* Yuk, we don't have PCI memory */
+	iomem_resource.name = "Memory";
+	for (i = 0; i < 4; i++)
+		request_resource(&iomem_resource, &((struct resource *)&mb_resources)[i]);
+
+	mach_sched_init      = amiga_sched_init;
+	mach_init_IRQ        = amiga_init_IRQ;
+	mach_get_model       = amiga_get_model;
+	mach_get_hardware_list = amiga_get_hardware_list;
+	mach_gettimeoffset   = amiga_gettimeoffset;
+	if (AMIGAHW_PRESENT(A3000_CLK)) {
+		mach_hwclk         = a3000_hwclk;
+		rtc_resource.name = "A3000 RTC";
+		request_resource(&iomem_resource, &rtc_resource);
+	} else /* if (AMIGAHW_PRESENT(A2000_CLK)) */ {
+		mach_hwclk         = a2000_hwclk;
+		rtc_resource.name = "A2000 RTC";
+		request_resource(&iomem_resource, &rtc_resource);
+	}
+
+	/*
+	 * default MAX_DMA=0xffffffff on all machines. If we don't do so, the SCSI
+	 * code will not be able to allocate any mem for transfers, unless we are
+	 * dealing with a Z2 mem only system.                  /Jes
+	 */
+	mach_max_dma_address = 0xffffffff;
+
+	mach_set_clock_mmss  = amiga_set_clock_mmss;
+	mach_get_ss          = amiga_get_ss;
+	mach_reset           = amiga_reset;
 #if defined(CONFIG_INPUT_M68K_BEEP) || defined(CONFIG_INPUT_M68K_BEEP_MODULE)
-  mach_beep            = amiga_mksound;
+	mach_beep            = amiga_mksound;
 #endif
 
 #ifdef CONFIG_HEARTBEAT
-  mach_heartbeat = amiga_heartbeat;
+	mach_heartbeat = amiga_heartbeat;
 #endif
 
-  /* Fill in the clock values (based on the 700 kHz E-Clock) */
-  amiga_masterclock = 40*amiga_eclock;	/* 28 MHz */
-  amiga_colorclock = 5*amiga_eclock;	/* 3.5 MHz */
-
-  /* clear all DMA bits */
-  amiga_custom.dmacon = DMAF_ALL;
-  /* ensure that the DMA master bit is set */
-  amiga_custom.dmacon = DMAF_SETCLR | DMAF_MASTER;
-
-  /* don't use Z2 RAM as system memory on Z3 capable machines */
-  if (AMIGAHW_PRESENT(ZORRO3)) {
-    int i, j;
-    u32 disabled_z2mem = 0;
-    for (i = 0; i < m68k_num_memory; i++)
-      if (m68k_memory[i].addr < 16*1024*1024) {
-	if (i == 0) {
-	  /* don't cut off the branch we're sitting on */
-	  printk("Warning: kernel runs in Zorro II memory\n");
-	  continue;
+	/* Fill in the clock values (based on the 700 kHz E-Clock) */
+	amiga_masterclock = 40*amiga_eclock;	/* 28 MHz */
+	amiga_colorclock = 5*amiga_eclock;	/* 3.5 MHz */
+
+	/* clear all DMA bits */
+	amiga_custom.dmacon = DMAF_ALL;
+	/* ensure that the DMA master bit is set */
+	amiga_custom.dmacon = DMAF_SETCLR | DMAF_MASTER;
+
+	/* don't use Z2 RAM as system memory on Z3 capable machines */
+	if (AMIGAHW_PRESENT(ZORRO3)) {
+		int i, j;
+		u32 disabled_z2mem = 0;
+
+		for (i = 0; i < m68k_num_memory; i++) {
+			if (m68k_memory[i].addr < 16*1024*1024) {
+				if (i == 0) {
+					/* don't cut off the branch we're sitting on */
+					printk("Warning: kernel runs in Zorro II memory\n");
+					continue;
+				}
+				disabled_z2mem += m68k_memory[i].size;
+				m68k_num_memory--;
+				for (j = i; j < m68k_num_memory; j++)
+					m68k_memory[j] = m68k_memory[j+1];
+				i--;
+			}
+		}
+		if (disabled_z2mem)
+		printk("%dK of Zorro II memory will not be used as system memory\n",
+		disabled_z2mem>>10);
+	}
+
+	/* request all RAM */
+	for (i = 0; i < m68k_num_memory; i++) {
+		ram_resource[i].name =
+			(m68k_memory[i].addr >= 0x01000000) ? "32-bit Fast RAM" :
+			(m68k_memory[i].addr < 0x00c00000) ? "16-bit Fast RAM" :
+			"16-bit Slow RAM";
+		ram_resource[i].start = m68k_memory[i].addr;
+		ram_resource[i].end = m68k_memory[i].addr+m68k_memory[i].size-1;
+		request_resource(&iomem_resource, &ram_resource[i]);
+	}
+
+	/* initialize chipram allocator */
+	amiga_chip_init();
+
+	/* debugging using chipram */
+	if (!strcmp(m68k_debug_device, "mem")) {
+		if (!AMIGAHW_PRESENT(CHIP_RAM))
+			printk("Warning: no chipram present for debugging\n");
+		else {
+			amiga_savekmsg_init();
+			amiga_console_driver.write = amiga_mem_console_write;
+			register_console(&amiga_console_driver);
+		}
 	}
-	disabled_z2mem += m68k_memory[i].size;
-	m68k_num_memory--;
-	for (j = i; j < m68k_num_memory; j++)
-	  m68k_memory[j] = m68k_memory[j+1];
-	i--;
-      }
-    if (disabled_z2mem)
-      printk("%dK of Zorro II memory will not be used as system memory\n",
-	     disabled_z2mem>>10);
-  }
-
-  /* request all RAM */
-  for (i = 0; i < m68k_num_memory; i++) {
-    ram_resource[i].name =
-      (m68k_memory[i].addr >= 0x01000000) ? "32-bit Fast RAM" :
-      (m68k_memory[i].addr < 0x00c00000) ? "16-bit Fast RAM" :
-      "16-bit Slow RAM";
-    ram_resource[i].start = m68k_memory[i].addr;
-    ram_resource[i].end = m68k_memory[i].addr+m68k_memory[i].size-1;
-    request_resource(&iomem_resource, &ram_resource[i]);
-  }
-
-  /* initialize chipram allocator */
-  amiga_chip_init ();
-
-  /* debugging using chipram */
-  if (!strcmp( m68k_debug_device, "mem" )){
-	  if (!AMIGAHW_PRESENT(CHIP_RAM))
-		  printk("Warning: no chipram present for debugging\n");
-	  else {
-		  amiga_savekmsg_init();
-		  amiga_console_driver.write = amiga_mem_console_write;
-		  register_console(&amiga_console_driver);
-	  }
-  }
-
-  /* our beloved beeper */
-  if (AMIGAHW_PRESENT(AMI_AUDIO))
-	  amiga_init_sound();
-
-  /*
-   * if it is an A3000, set the magic bit that forces
-   * a hard rekick
-   */
-  if (AMIGAHW_PRESENT(MAGIC_REKICK))
-	  *(unsigned char *)ZTWO_VADDR(0xde0002) |= 0x80;
+
+	/* our beloved beeper */
+	if (AMIGAHW_PRESENT(AMI_AUDIO))
+		amiga_init_sound();
+
+	/*
+	 * if it is an A3000, set the magic bit that forces
+	 * a hard rekick
+	 */
+	if (AMIGAHW_PRESENT(MAGIC_REKICK))
+		*(unsigned char *)ZTWO_VADDR(0xde0002) |= 0x80;
 }
 
 static unsigned short jiffy_ticks;
@@ -490,12 +486,12 @@ static unsigned short jiffy_ticks;
 static void __init amiga_sched_init(irq_handler_t timer_routine)
 {
 	static struct resource sched_res = {
-	    .name = "timer", .start = 0x00bfd400, .end = 0x00bfd5ff,
+		.name = "timer", .start = 0x00bfd400, .end = 0x00bfd5ff,
 	};
 	jiffy_ticks = (amiga_eclock+HZ/2)/HZ;
 
 	if (request_resource(&mb_resources._ciab, &sched_res))
-	    printk("Cannot allocate ciab.ta{lo,hi}\n");
+		printk("Cannot allocate ciab.ta{lo,hi}\n");
 	ciab.cra &= 0xC0;   /* turn off timer A, continuous mode, from Eclk */
 	ciab.talo = jiffy_ticks % 256;
 	ciab.tahi = jiffy_ticks / 256;
@@ -513,7 +509,7 @@ static void __init amiga_sched_init(irq_handler_t timer_routine)
 #define TICK_SIZE 10000
 
 /* This is always executed with interrupts disabled.  */
-static unsigned long amiga_gettimeoffset (void)
+static unsigned long amiga_gettimeoffset(void)
 {
 	unsigned short hi, lo, hi2;
 	unsigned long ticks, offset = 0;
@@ -585,15 +581,15 @@ static int a2000_hwclk(int op, struct rtc_time *t)
 
 	tod_2000.cntrl1 = TOD2000_CNTRL1_HOLD;
 
-	while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt--)
-	{
-	        tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
-	        udelay(70);
-	        tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
+	while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt--) {
+		tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
+		udelay(70);
+		tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
 	}
 
 	if (!cnt)
-		printk(KERN_INFO "hwclk: timed out waiting for RTC (0x%x)\n", tod_2000.cntrl1);
+		printk(KERN_INFO "hwclk: timed out waiting for RTC (0x%x)\n",
+			tod_2000.cntrl1);
 
 	if (!op) { /* read */
 		t->tm_sec  = tod_2000.second1     * 10 + tod_2000.second2;
@@ -606,7 +602,7 @@ static int a2000_hwclk(int op, struct rtc_time *t)
 		if (t->tm_year <= 69)
 			t->tm_year += 100;
 
-		if (!(tod_2000.cntrl3 & TOD2000_CNTRL3_24HMODE)){
+		if (!(tod_2000.cntrl3 & TOD2000_CNTRL3_24HMODE)) {
 			if (!(tod_2000.hour1 & TOD2000_HOUR1_PM) && t->tm_hour == 12)
 				t->tm_hour = 0;
 			else if ((tod_2000.hour1 & TOD2000_HOUR1_PM) && t->tm_hour != 12)
@@ -642,7 +638,7 @@ static int a2000_hwclk(int op, struct rtc_time *t)
 	return 0;
 }
 
-static int amiga_set_clock_mmss (unsigned long nowtime)
+static int amiga_set_clock_mmss(unsigned long nowtime)
 {
 	short real_seconds = nowtime % 60, real_minutes = (nowtime / 60) % 60;
 
@@ -660,8 +656,7 @@ static int amiga_set_clock_mmss (unsigned long nowtime)
 
 		tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
 
-		while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt--)
-		{
+		while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt--) {
 			tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
 			udelay(70);
 			tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
@@ -681,7 +676,7 @@ static int amiga_set_clock_mmss (unsigned long nowtime)
 	return 0;
 }
 
-static unsigned int amiga_get_ss( void )
+static unsigned int amiga_get_ss(void)
 {
 	unsigned int s;
 
@@ -695,71 +690,72 @@ static unsigned int amiga_get_ss( void )
 	return s;
 }
 
-static NORET_TYPE void amiga_reset( void )
+static NORET_TYPE void amiga_reset(void)
     ATTRIB_NORET;
 
-static void amiga_reset (void)
+static void amiga_reset(void)
 {
-  unsigned long jmp_addr040 = virt_to_phys(&&jmp_addr_label040);
-  unsigned long jmp_addr = virt_to_phys(&&jmp_addr_label);
-
-  local_irq_disable();
-  if (CPU_IS_040_OR_060)
-    /* Setup transparent translation registers for mapping
-     * of 16 MB kernel segment before disabling translation
-     */
-    __asm__ __volatile__
-      ("movel    %0,%/d0\n\t"
-       "andl     #0xff000000,%/d0\n\t"
-       "orw      #0xe020,%/d0\n\t"   /* map 16 MB, enable, cacheable */
-       ".chip    68040\n\t"
-       "movec    %%d0,%%itt0\n\t"
-       "movec    %%d0,%%dtt0\n\t"
-       ".chip    68k\n\t"
-       "jmp      %0@\n\t"
-       : /* no outputs */
-       : "a" (jmp_addr040));
-  else
-    /* for 680[23]0, just disable translation and jump to the physical
-     * address of the label
-     */
-    __asm__ __volatile__
-      ("pmove  %/tc,%@\n\t"
-       "bclr   #7,%@\n\t"
-       "pmove  %@,%/tc\n\t"
-       "jmp    %0@\n\t"
-       : /* no outputs */
-       : "a" (jmp_addr));
- jmp_addr_label040:
-  /* disable translation on '040 now */
-  __asm__ __volatile__
-    ("moveq #0,%/d0\n\t"
-     ".chip 68040\n\t"
-     "movec %%d0,%%tc\n\t"	/* disable MMU */
-     ".chip 68k\n\t"
-     : /* no outputs */
-     : /* no inputs */
-     : "d0");
-
- jmp_addr_label:
-  /* pickup reset address from AmigaOS ROM, reset devices and jump
-   * to reset address
-   */
-  __asm__ __volatile__
-    ("movew #0x2700,%/sr\n\t"
-     "leal  0x01000000,%/a0\n\t"
-     "subl  %/a0@(-0x14),%/a0\n\t"
-     "movel %/a0@(4),%/a0\n\t"
-     "subql #2,%/a0\n\t"
-     "bra   1f\n\t"
-     /* align on a longword boundary */
-     __ALIGN_STR "\n"
-     "1:\n\t"
-     "reset\n\t"
-     "jmp   %/a0@" : /* Just that gcc scans it for % escapes */ );
-
-  for (;;);
-
+	unsigned long jmp_addr040 = virt_to_phys(&&jmp_addr_label040);
+	unsigned long jmp_addr = virt_to_phys(&&jmp_addr_label);
+
+	local_irq_disable();
+	if (CPU_IS_040_OR_060)
+		/* Setup transparent translation registers for mapping
+		 * of 16 MB kernel segment before disabling translation
+		 */
+		asm volatile ("\n"
+			"	move.l	%0,%%d0\n"
+			"	and.l	#0xff000000,%%d0\n"
+			"	or.w	#0xe020,%%d0\n"   /* map 16 MB, enable, cacheable */
+			"	.chip	68040\n"
+			"	movec	%%d0,%%itt0\n"
+			"	movec	%%d0,%%dtt0\n"
+			"	.chip	68k\n"
+			"	jmp	%0@\n"
+			: /* no outputs */
+			: "a" (jmp_addr040)
+			: "d0");
+	else
+		/* for 680[23]0, just disable translation and jump to the physical
+		 * address of the label
+		 */
+		asm volatile ("\n"
+			"	pmove	%%tc,%@\n"
+			"	bclr	#7,%@\n"
+			"	pmove	%@,%%tc\n"
+			"	jmp	%0@\n"
+			: /* no outputs */
+			: "a" (jmp_addr));
+jmp_addr_label040:
+	/* disable translation on '040 now */
+	asm volatile ("\n"
+		"	moveq	#0,%%d0\n"
+		"	.chip	68040\n"
+		"	movec	%%d0,%%tc\n"	/* disable MMU */
+		"	.chip	68k\n"
+		: /* no outputs */
+		: /* no inputs */
+		: "d0");
+
+	jmp_addr_label:
+	/* pickup reset address from AmigaOS ROM, reset devices and jump
+	 * to reset address
+	 */
+	asm volatile ("\n"
+		"	move.w	#0x2700,%sr\n"
+		"	lea	0x01000000,%a0\n"
+		"	sub.l	%a0@(-0x14),%a0\n"
+		"	move.l	%a0@(4),%a0\n"
+		"	subq.l	#2,%a0\n"
+		"	jra	1f\n"
+		/* align on a longword boundary */
+		"	" __ALIGN_STR "\n"
+		"1:\n"
+		"	reset\n"
+		"	jmp   %a0@");
+
+	for (;;)
+		;
 }
 
 
@@ -773,11 +769,11 @@ static void amiga_reset (void)
 #define SAVEKMSG_MAGIC2		0x4B4D5347	/* 'KMSG' */
 
 struct savekmsg {
-    unsigned long magic1;		/* SAVEKMSG_MAGIC1 */
-    unsigned long magic2;		/* SAVEKMSG_MAGIC2 */
-    unsigned long magicptr;		/* address of magic1 */
-    unsigned long size;
-    char data[0];
+	unsigned long magic1;		/* SAVEKMSG_MAGIC1 */
+	unsigned long magic2;		/* SAVEKMSG_MAGIC2 */
+	unsigned long magicptr;		/* address of magic1 */
+	unsigned long size;
+	char data[0];
 };
 
 static struct savekmsg *savekmsg;
@@ -785,100 +781,100 @@ static struct savekmsg *savekmsg;
 static void amiga_mem_console_write(struct console *co, const char *s,
 				    unsigned int count)
 {
-    if (savekmsg->size+count <= SAVEKMSG_MAXMEM-sizeof(struct savekmsg)) {
-        memcpy(savekmsg->data+savekmsg->size, s, count);
-        savekmsg->size += count;
-    }
+	if (savekmsg->size + count <= SAVEKMSG_MAXMEM-sizeof(struct savekmsg)) {
+		memcpy(savekmsg->data + savekmsg->size, s, count);
+		savekmsg->size += count;
+	}
 }
 
 static void amiga_savekmsg_init(void)
 {
-    static struct resource debug_res = { .name = "Debug" };
+	static struct resource debug_res = { .name = "Debug" };
 
-    savekmsg = amiga_chip_alloc_res(SAVEKMSG_MAXMEM, &debug_res);
-    savekmsg->magic1 = SAVEKMSG_MAGIC1;
-    savekmsg->magic2 = SAVEKMSG_MAGIC2;
-    savekmsg->magicptr = ZTWO_PADDR(savekmsg);
-    savekmsg->size = 0;
+	savekmsg = amiga_chip_alloc_res(SAVEKMSG_MAXMEM, &debug_res);
+	savekmsg->magic1 = SAVEKMSG_MAGIC1;
+	savekmsg->magic2 = SAVEKMSG_MAGIC2;
+	savekmsg->magicptr = ZTWO_PADDR(savekmsg);
+	savekmsg->size = 0;
 }
 
 static void amiga_serial_putc(char c)
 {
-    amiga_custom.serdat = (unsigned char)c | 0x100;
-    while (!(amiga_custom.serdatr & 0x2000))
-	;
+	amiga_custom.serdat = (unsigned char)c | 0x100;
+	while (!(amiga_custom.serdatr & 0x2000))
+		;
 }
 
 void amiga_serial_console_write(struct console *co, const char *s,
-				       unsigned int count)
+				unsigned int count)
 {
-    while (count--) {
-	if (*s == '\n')
-	    amiga_serial_putc('\r');
-	amiga_serial_putc(*s++);
-    }
+	while (count--) {
+		if (*s == '\n')
+			amiga_serial_putc('\r');
+		amiga_serial_putc(*s++);
+	}
 }
 
 #ifdef CONFIG_SERIAL_CONSOLE
 void amiga_serial_puts(const char *s)
 {
-    amiga_serial_console_write(NULL, s, strlen(s));
+	amiga_serial_console_write(NULL, s, strlen(s));
 }
 
 int amiga_serial_console_wait_key(struct console *co)
 {
-    int ch;
-
-    while (!(amiga_custom.intreqr & IF_RBF))
-	barrier();
-    ch = amiga_custom.serdatr & 0xff;
-    /* clear the interrupt, so that another character can be read */
-    amiga_custom.intreq = IF_RBF;
-    return ch;
+	int ch;
+
+	while (!(amiga_custom.intreqr & IF_RBF))
+		barrier();
+	ch = amiga_custom.serdatr & 0xff;
+	/* clear the interrupt, so that another character can be read */
+	amiga_custom.intreq = IF_RBF;
+	return ch;
 }
 
 void amiga_serial_gets(struct console *co, char *s, int len)
 {
-    int ch, cnt = 0;
-
-    while (1) {
-	ch = amiga_serial_console_wait_key(co);
-
-	/* Check for backspace. */
-	if (ch == 8 || ch == 127) {
-	    if (cnt == 0) {
-		amiga_serial_putc('\007');
-		continue;
-	    }
-	    cnt--;
-	    amiga_serial_puts("\010 \010");
-	    continue;
-	}
+	int ch, cnt = 0;
+
+	while (1) {
+		ch = amiga_serial_console_wait_key(co);
+
+		/* Check for backspace. */
+		if (ch == 8 || ch == 127) {
+			if (cnt == 0) {
+				amiga_serial_putc('\007');
+				continue;
+			}
+			cnt--;
+			amiga_serial_puts("\010 \010");
+			continue;
+		}
 
-	/* Check for enter. */
-	if (ch == 10 || ch == 13)
-	    break;
+		/* Check for enter. */
+		if (ch == 10 || ch == 13)
+			break;
 
-	/* See if line is too long. */
-	if (cnt >= len + 1) {
-	    amiga_serial_putc(7);
-	    cnt--;
-	    continue;
-	}
+		/* See if line is too long. */
+		if (cnt >= len + 1) {
+			amiga_serial_putc(7);
+			cnt--;
+			continue;
+		}
 
-	/* Store and echo character. */
-	s[cnt++] = ch;
-	amiga_serial_putc(ch);
-    }
-    /* Print enter. */
-    amiga_serial_puts("\r\n");
-    s[cnt] = 0;
+		/* Store and echo character. */
+		s[cnt++] = ch;
+		amiga_serial_putc(ch);
+	}
+	/* Print enter. */
+	amiga_serial_puts("\r\n");
+	s[cnt] = 0;
 }
 #endif
 
 static void __init amiga_debug_init(void)
 {
-	if (!strcmp( m68k_debug_device, "ser" )) {
+	if (!strcmp(m68k_debug_device, "ser" )) {
 		/* no initialization required (?) */
 		amiga_console_driver.write = amiga_serial_console_write;
 		register_console(&amiga_console_driver);
@@ -888,10 +884,10 @@ static void __init amiga_debug_init(void)
 #ifdef CONFIG_HEARTBEAT
 static void amiga_heartbeat(int on)
 {
-    if (on)
-	ciaa.pra &= ~2;
-    else
-	ciaa.pra |= 2;
+	if (on)
+		ciaa.pra &= ~2;
+	else
+		ciaa.pra |= 2;
 }
 #endif
 
@@ -901,81 +897,81 @@ static void amiga_heartbeat(int on)
 
 static void amiga_get_model(char *model)
 {
-    strcpy(model, amiga_model_name);
+	strcpy(model, amiga_model_name);
 }
 
 
 static int amiga_get_hardware_list(char *buffer)
 {
-    int len = 0;
-
-    if (AMIGAHW_PRESENT(CHIP_RAM))
-	len += sprintf(buffer+len, "Chip RAM:\t%ldK\n", amiga_chip_size>>10);
-    len += sprintf(buffer+len, "PS Freq:\t%dHz\nEClock Freq:\t%ldHz\n",
-		   amiga_psfreq, amiga_eclock);
-    if (AMIGAHW_PRESENT(AMI_VIDEO)) {
-	char *type;
-	switch(amiga_chipset) {
-	    case CS_OCS:
-		type = "OCS";
-		break;
-	    case CS_ECS:
-		type = "ECS";
-		break;
-	    case CS_AGA:
-		type = "AGA";
-		break;
-	    default:
-		type = "Old or Unknown";
-		break;
+	int len = 0;
+
+	if (AMIGAHW_PRESENT(CHIP_RAM))
+		len += sprintf(buffer+len, "Chip RAM:\t%ldK\n", amiga_chip_size>>10);
+	len += sprintf(buffer+len, "PS Freq:\t%dHz\nEClock Freq:\t%ldHz\n",
+			amiga_psfreq, amiga_eclock);
+	if (AMIGAHW_PRESENT(AMI_VIDEO)) {
+		char *type;
+		switch (amiga_chipset) {
+		case CS_OCS:
+			type = "OCS";
+			break;
+		case CS_ECS:
+			type = "ECS";
+			break;
+		case CS_AGA:
+			type = "AGA";
+			break;
+		default:
+			type = "Old or Unknown";
+			break;
+		}
+		len += sprintf(buffer+len, "Graphics:\t%s\n", type);
 	}
-	len += sprintf(buffer+len, "Graphics:\t%s\n", type);
-    }
 
 #define AMIGAHW_ANNOUNCE(name, str)			\
-    if (AMIGAHW_PRESENT(name))				\
-	len += sprintf (buffer+len, "\t%s\n", str)
-
-    len += sprintf (buffer + len, "Detected hardware:\n");
-
-    AMIGAHW_ANNOUNCE(AMI_VIDEO, "Amiga Video");
-    AMIGAHW_ANNOUNCE(AMI_BLITTER, "Blitter");
-    AMIGAHW_ANNOUNCE(AMBER_FF, "Amber Flicker Fixer");
-    AMIGAHW_ANNOUNCE(AMI_AUDIO, "Amiga Audio");
-    AMIGAHW_ANNOUNCE(AMI_FLOPPY, "Floppy Controller");
-    AMIGAHW_ANNOUNCE(A3000_SCSI, "SCSI Controller WD33C93 (A3000 style)");
-    AMIGAHW_ANNOUNCE(A4000_SCSI, "SCSI Controller NCR53C710 (A4000T style)");
-    AMIGAHW_ANNOUNCE(A1200_IDE, "IDE Interface (A1200 style)");
-    AMIGAHW_ANNOUNCE(A4000_IDE, "IDE Interface (A4000 style)");
-    AMIGAHW_ANNOUNCE(CD_ROM, "Internal CD ROM drive");
-    AMIGAHW_ANNOUNCE(AMI_KEYBOARD, "Keyboard");
-    AMIGAHW_ANNOUNCE(AMI_MOUSE, "Mouse Port");
-    AMIGAHW_ANNOUNCE(AMI_SERIAL, "Serial Port");
-    AMIGAHW_ANNOUNCE(AMI_PARALLEL, "Parallel Port");
-    AMIGAHW_ANNOUNCE(A2000_CLK, "Hardware Clock (A2000 style)");
-    AMIGAHW_ANNOUNCE(A3000_CLK, "Hardware Clock (A3000 style)");
-    AMIGAHW_ANNOUNCE(CHIP_RAM, "Chip RAM");
-    AMIGAHW_ANNOUNCE(PAULA, "Paula 8364");
-    AMIGAHW_ANNOUNCE(DENISE, "Denise 8362");
-    AMIGAHW_ANNOUNCE(DENISE_HR, "Denise 8373");
-    AMIGAHW_ANNOUNCE(LISA, "Lisa 8375");
-    AMIGAHW_ANNOUNCE(AGNUS_PAL, "Normal/Fat PAL Agnus 8367/8371");
-    AMIGAHW_ANNOUNCE(AGNUS_NTSC, "Normal/Fat NTSC Agnus 8361/8370");
-    AMIGAHW_ANNOUNCE(AGNUS_HR_PAL, "Fat Hires PAL Agnus 8372");
-    AMIGAHW_ANNOUNCE(AGNUS_HR_NTSC, "Fat Hires NTSC Agnus 8372");
-    AMIGAHW_ANNOUNCE(ALICE_PAL, "PAL Alice 8374");
-    AMIGAHW_ANNOUNCE(ALICE_NTSC, "NTSC Alice 8374");
-    AMIGAHW_ANNOUNCE(MAGIC_REKICK, "Magic Hard Rekick");
-    AMIGAHW_ANNOUNCE(PCMCIA, "PCMCIA Slot");
+	if (AMIGAHW_PRESENT(name))			\
+		len += sprintf (buffer+len, "\t%s\n", str)
+
+	len += sprintf (buffer + len, "Detected hardware:\n");
+
+	AMIGAHW_ANNOUNCE(AMI_VIDEO, "Amiga Video");
+	AMIGAHW_ANNOUNCE(AMI_BLITTER, "Blitter");
+	AMIGAHW_ANNOUNCE(AMBER_FF, "Amber Flicker Fixer");
+	AMIGAHW_ANNOUNCE(AMI_AUDIO, "Amiga Audio");
+	AMIGAHW_ANNOUNCE(AMI_FLOPPY, "Floppy Controller");
+	AMIGAHW_ANNOUNCE(A3000_SCSI, "SCSI Controller WD33C93 (A3000 style)");
+	AMIGAHW_ANNOUNCE(A4000_SCSI, "SCSI Controller NCR53C710 (A4000T style)");
+	AMIGAHW_ANNOUNCE(A1200_IDE, "IDE Interface (A1200 style)");
+	AMIGAHW_ANNOUNCE(A4000_IDE, "IDE Interface (A4000 style)");
+	AMIGAHW_ANNOUNCE(CD_ROM, "Internal CD ROM drive");
+	AMIGAHW_ANNOUNCE(AMI_KEYBOARD, "Keyboard");
+	AMIGAHW_ANNOUNCE(AMI_MOUSE, "Mouse Port");
+	AMIGAHW_ANNOUNCE(AMI_SERIAL, "Serial Port");
+	AMIGAHW_ANNOUNCE(AMI_PARALLEL, "Parallel Port");
+	AMIGAHW_ANNOUNCE(A2000_CLK, "Hardware Clock (A2000 style)");
+	AMIGAHW_ANNOUNCE(A3000_CLK, "Hardware Clock (A3000 style)");
+	AMIGAHW_ANNOUNCE(CHIP_RAM, "Chip RAM");
+	AMIGAHW_ANNOUNCE(PAULA, "Paula 8364");
+	AMIGAHW_ANNOUNCE(DENISE, "Denise 8362");
+	AMIGAHW_ANNOUNCE(DENISE_HR, "Denise 8373");
+	AMIGAHW_ANNOUNCE(LISA, "Lisa 8375");
+	AMIGAHW_ANNOUNCE(AGNUS_PAL, "Normal/Fat PAL Agnus 8367/8371");
+	AMIGAHW_ANNOUNCE(AGNUS_NTSC, "Normal/Fat NTSC Agnus 8361/8370");
+	AMIGAHW_ANNOUNCE(AGNUS_HR_PAL, "Fat Hires PAL Agnus 8372");
+	AMIGAHW_ANNOUNCE(AGNUS_HR_NTSC, "Fat Hires NTSC Agnus 8372");
+	AMIGAHW_ANNOUNCE(ALICE_PAL, "PAL Alice 8374");
+	AMIGAHW_ANNOUNCE(ALICE_NTSC, "NTSC Alice 8374");
+	AMIGAHW_ANNOUNCE(MAGIC_REKICK, "Magic Hard Rekick");
+	AMIGAHW_ANNOUNCE(PCMCIA, "PCMCIA Slot");
 #ifdef CONFIG_ZORRO
-    if (AMIGAHW_PRESENT(ZORRO))
-	len += sprintf(buffer+len, "\tZorro II%s AutoConfig: %d Expansion "
-				   "Device%s\n",
-		       AMIGAHW_PRESENT(ZORRO3) ? "I" : "",
-		       zorro_num_autocon, zorro_num_autocon == 1 ? "" : "s");
+	if (AMIGAHW_PRESENT(ZORRO))
+		len += sprintf(buffer+len, "\tZorro II%s AutoConfig: %d Expansion "
+				"Device%s\n",
+				AMIGAHW_PRESENT(ZORRO3) ? "I" : "",
+				zorro_num_autocon, zorro_num_autocon == 1 ? "" : "s");
 #endif /* CONFIG_ZORRO */
 
 #undef AMIGAHW_ANNOUNCE
 
-    return(len);
+	return len;
 }

commit 40220c1a192f51695f806d75b1f9970f0f17a6e8
Author: David Howells <dhowells@redhat.com>
Date:   Mon Oct 9 12:19:47 2006 +0100

    IRQ: Use the new typedef for interrupt handler function pointers
    
    Use the new typedef for interrupt handler function pointers rather than
    actually spelling out the full thing each time.  This was scripted with the
    following small shell script:
    
    #!/bin/sh
    egrep -nHrl -e 'irqreturn_t[    ]*[(][*]' $* |
    while read i
    do
        echo $i
        perl -pi -e 's/irqreturn_t\s*[(]\s*[*]\s*([_a-zA-Z0-9]*)\s*[)]\s*[(]\s*int\s*,\s*void\s*[*]\s*[)]/irq_handler_t \1/g' $i || exit $?
    done
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 6f63d62bd7d6..3204f412cad8 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -83,7 +83,7 @@ static char amiga_model_name[13] = "Amiga ";
 
 extern char m68k_debug_device[];
 
-static void amiga_sched_init(irqreturn_t (*handler)(int, void *));
+static void amiga_sched_init(irq_handler_t handler);
 /* amiga specific irq functions */
 extern void amiga_init_IRQ (void);
 static void amiga_get_model(char *model);
@@ -487,7 +487,7 @@ void __init config_amiga(void)
 
 static unsigned short jiffy_ticks;
 
-static void __init amiga_sched_init(irqreturn_t (*timer_routine)(int, void *))
+static void __init amiga_sched_init(irq_handler_t timer_routine)
 {
 	static struct resource sched_res = {
 	    .name = "timer", .start = 0x00bfd400, .end = 0x00bfd5ff,

commit 2850bc273776cbb1b510c5828e9e456dffb50a32
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Oct 7 14:16:45 2006 +0100

    [PATCH] m68k pt_regs fixes
    
    m68k_handle_int() split in two functions: __m68k_handle_int() takes
    pt_regs * and does set_irq_regs(); m68k_handle_int() doesn't get pt_regs
    *.
    
    Places where we used to call m68k_handle_int() recursively with the same
    pt_regs have simply lost the second argument, the rest is switched to
    __m68k_handle_int().
    
    The rest of patch is just dropping pt_regs * where needed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 092e50d2cb13..6f63d62bd7d6 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -83,7 +83,7 @@ static char amiga_model_name[13] = "Amiga ";
 
 extern char m68k_debug_device[];
 
-static void amiga_sched_init(irqreturn_t (*handler)(int, void *, struct pt_regs *));
+static void amiga_sched_init(irqreturn_t (*handler)(int, void *));
 /* amiga specific irq functions */
 extern void amiga_init_IRQ (void);
 static void amiga_get_model(char *model);
@@ -487,8 +487,7 @@ void __init config_amiga(void)
 
 static unsigned short jiffy_ticks;
 
-static void __init amiga_sched_init(irqreturn_t (*timer_routine)(int, void *,
-							  struct pt_regs *))
+static void __init amiga_sched_init(irqreturn_t (*timer_routine)(int, void *))
 {
 	static struct resource sched_res = {
 	    .name = "timer", .start = 0x00bfd400, .end = 0x00bfd5ff,

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index b5b8a416a07a..092e50d2cb13 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -12,7 +12,6 @@
  * Miscellaneous Amiga stuff
  */
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>

commit 74be8d0835f91f0f77a2f1554dfa7242f1f7b652
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:01 2006 -0700

    [PATCH] m68k: convert amiga irq code
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 12e3706fe02c..b5b8a416a07a 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -87,17 +87,8 @@ extern char m68k_debug_device[];
 static void amiga_sched_init(irqreturn_t (*handler)(int, void *, struct pt_regs *));
 /* amiga specific irq functions */
 extern void amiga_init_IRQ (void);
-extern irqreturn_t (*amiga_default_handler[]) (int, void *, struct pt_regs *);
-extern int amiga_request_irq (unsigned int irq,
-			      irqreturn_t (*handler)(int, void *, struct pt_regs *),
-                              unsigned long flags, const char *devname,
-			      void *dev_id);
-extern void amiga_free_irq (unsigned int irq, void *dev_id);
-extern void amiga_enable_irq (unsigned int);
-extern void amiga_disable_irq (unsigned int);
 static void amiga_get_model(char *model);
 static int amiga_get_hardware_list(char *buffer);
-extern int show_amiga_interrupts (struct seq_file *, void *);
 /* amiga specific timer functions */
 static unsigned long amiga_gettimeoffset (void);
 static int a3000_hwclk (int, struct rtc_time *);
@@ -392,14 +383,8 @@ void __init config_amiga(void)
 
   mach_sched_init      = amiga_sched_init;
   mach_init_IRQ        = amiga_init_IRQ;
-  mach_default_handler = &amiga_default_handler;
-  mach_request_irq     = amiga_request_irq;
-  mach_free_irq        = amiga_free_irq;
-  enable_irq           = amiga_enable_irq;
-  disable_irq          = amiga_disable_irq;
   mach_get_model       = amiga_get_model;
   mach_get_hardware_list = amiga_get_hardware_list;
-  mach_get_irq_list    = show_amiga_interrupts;
   mach_gettimeoffset   = amiga_gettimeoffset;
   if (AMIGAHW_PRESENT(A3000_CLK)){
     mach_hwclk         = a3000_hwclk;

commit 639074354bb371feb2dde409b2ce05d56afef02b
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jan 12 01:06:36 2006 -0800

    [PATCH] m68k: kill mach_floppy_setup, convert to proper __setup() in drivers
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 8eadde9d2a8f..12e3706fe02c 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -105,9 +105,6 @@ static int a2000_hwclk (int, struct rtc_time *);
 static int amiga_set_clock_mmss (unsigned long);
 static unsigned int amiga_get_ss (void);
 extern void amiga_mksound( unsigned int count, unsigned int ticks );
-#ifdef CONFIG_AMIGA_FLOPPY
-extern void amiga_floppy_setup(char *, int *);
-#endif
 static void amiga_reset (void);
 extern void amiga_init_sound(void);
 static void amiga_savekmsg_init(void);
@@ -427,9 +424,6 @@ void __init config_amiga(void)
 
   mach_set_clock_mmss  = amiga_set_clock_mmss;
   mach_get_ss          = amiga_get_ss;
-#ifdef CONFIG_AMIGA_FLOPPY
-  mach_floppy_setup    = amiga_floppy_setup;
-#endif
   mach_reset           = amiga_reset;
 #if defined(CONFIG_INPUT_M68K_BEEP) || defined(CONFIG_INPUT_M68K_BEEP_MODULE)
   mach_beep            = amiga_mksound;

commit 0c79358b874af31430cf8d26540ae7b8713505f6
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jan 12 01:06:35 2006 -0800

    [PATCH] m68k: Moved initialisation of conswitchp from subarches to global arch setup
    
    Signed-off-by: Kars de Jong <jongk@linux-m68k.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index da24476db8e9..8eadde9d2a8f 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -431,9 +431,6 @@ void __init config_amiga(void)
   mach_floppy_setup    = amiga_floppy_setup;
 #endif
   mach_reset           = amiga_reset;
-#ifdef CONFIG_DUMMY_CONSOLE
-  conswitchp           = &dummy_con;
-#endif
 #if defined(CONFIG_INPUT_M68K_BEEP) || defined(CONFIG_INPUT_M68K_BEEP_MODULE)
   mach_beep            = amiga_mksound;
 #endif

commit b4290a23cfa9040e2f0de5ab57d6ea65abaf053b
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jan 12 01:06:12 2006 -0800

    [PATCH] m68k: namespace pollution fix (custom->amiga_custom)
    
    in amigahw.h custom renamed to amiga_custom, in drivers with few instances the
    same replacement, in the rest - #define custom amiga_custom in driver itself
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
index 4775e18a78f0..da24476db8e9 100644
--- a/arch/m68k/amiga/config.c
+++ b/arch/m68k/amiga/config.c
@@ -290,7 +290,7 @@ static void __init amiga_identify(void)
     case CS_OCS:
     case CS_ECS:
     case CS_AGA:
-      switch (custom.deniseid & 0xf) {
+      switch (amiga_custom.deniseid & 0xf) {
       case 0x0c:
 	AMIGAHW_SET(DENISE_HR);
 	break;
@@ -303,7 +303,7 @@ static void __init amiga_identify(void)
       AMIGAHW_SET(DENISE);
       break;
     }
-    switch ((custom.vposr>>8) & 0x7f) {
+    switch ((amiga_custom.vposr>>8) & 0x7f) {
     case 0x00:
       AMIGAHW_SET(AGNUS_PAL);
       break;
@@ -447,9 +447,9 @@ void __init config_amiga(void)
   amiga_colorclock = 5*amiga_eclock;	/* 3.5 MHz */
 
   /* clear all DMA bits */
-  custom.dmacon = DMAF_ALL;
+  amiga_custom.dmacon = DMAF_ALL;
   /* ensure that the DMA master bit is set */
-  custom.dmacon = DMAF_SETCLR | DMAF_MASTER;
+  amiga_custom.dmacon = DMAF_SETCLR | DMAF_MASTER;
 
   /* don't use Z2 RAM as system memory on Z3 capable machines */
   if (AMIGAHW_PRESENT(ZORRO3)) {
@@ -830,8 +830,8 @@ static void amiga_savekmsg_init(void)
 
 static void amiga_serial_putc(char c)
 {
-    custom.serdat = (unsigned char)c | 0x100;
-    while (!(custom.serdatr & 0x2000))
+    amiga_custom.serdat = (unsigned char)c | 0x100;
+    while (!(amiga_custom.serdatr & 0x2000))
 	;
 }
 
@@ -855,11 +855,11 @@ int amiga_serial_console_wait_key(struct console *co)
 {
     int ch;
 
-    while (!(custom.intreqr & IF_RBF))
+    while (!(amiga_custom.intreqr & IF_RBF))
 	barrier();
-    ch = custom.serdatr & 0xff;
+    ch = amiga_custom.serdatr & 0xff;
     /* clear the interrupt, so that another character can be read */
-    custom.intreq = IF_RBF;
+    amiga_custom.intreq = IF_RBF;
     return ch;
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/amiga/config.c b/arch/m68k/amiga/config.c
new file mode 100644
index 000000000000..4775e18a78f0
--- /dev/null
+++ b/arch/m68k/amiga/config.c
@@ -0,0 +1,1007 @@
+/*
+ *  linux/arch/m68k/amiga/config.c
+ *
+ *  Copyright (C) 1993 Hamish Macdonald
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
+
+/*
+ * Miscellaneous Amiga stuff
+ */
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/tty.h>
+#include <linux/console.h>
+#include <linux/rtc.h>
+#include <linux/init.h>
+#include <linux/vt_kern.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#ifdef CONFIG_ZORRO
+#include <linux/zorro.h>
+#endif
+
+#include <asm/bootinfo.h>
+#include <asm/setup.h>
+#include <asm/system.h>
+#include <asm/pgtable.h>
+#include <asm/amigahw.h>
+#include <asm/amigaints.h>
+#include <asm/irq.h>
+#include <asm/rtc.h>
+#include <asm/machdep.h>
+#include <asm/io.h>
+
+unsigned long amiga_model;
+unsigned long amiga_eclock;
+unsigned long amiga_masterclock;
+unsigned long amiga_colorclock;
+unsigned long amiga_chipset;
+unsigned char amiga_vblank;
+unsigned char amiga_psfreq;
+struct amiga_hw_present amiga_hw_present;
+
+static char s_a500[] __initdata = "A500";
+static char s_a500p[] __initdata = "A500+";
+static char s_a600[] __initdata = "A600";
+static char s_a1000[] __initdata = "A1000";
+static char s_a1200[] __initdata = "A1200";
+static char s_a2000[] __initdata = "A2000";
+static char s_a2500[] __initdata = "A2500";
+static char s_a3000[] __initdata = "A3000";
+static char s_a3000t[] __initdata = "A3000T";
+static char s_a3000p[] __initdata = "A3000+";
+static char s_a4000[] __initdata = "A4000";
+static char s_a4000t[] __initdata = "A4000T";
+static char s_cdtv[] __initdata = "CDTV";
+static char s_cd32[] __initdata = "CD32";
+static char s_draco[] __initdata = "Draco";
+static char *amiga_models[] __initdata = {
+    [AMI_500-AMI_500]		= s_a500,
+    [AMI_500PLUS-AMI_500]	= s_a500p,
+    [AMI_600-AMI_500]		= s_a600,
+    [AMI_1000-AMI_500]		= s_a1000,
+    [AMI_1200-AMI_500]		= s_a1200,
+    [AMI_2000-AMI_500]		= s_a2000,
+    [AMI_2500-AMI_500]		= s_a2500,
+    [AMI_3000-AMI_500]		= s_a3000,
+    [AMI_3000T-AMI_500]		= s_a3000t,
+    [AMI_3000PLUS-AMI_500]	= s_a3000p,
+    [AMI_4000-AMI_500]		= s_a4000,
+    [AMI_4000T-AMI_500]		= s_a4000t,
+    [AMI_CDTV-AMI_500]		= s_cdtv,
+    [AMI_CD32-AMI_500]		= s_cd32,
+    [AMI_DRACO-AMI_500]		= s_draco,
+};
+
+static char amiga_model_name[13] = "Amiga ";
+
+extern char m68k_debug_device[];
+
+static void amiga_sched_init(irqreturn_t (*handler)(int, void *, struct pt_regs *));
+/* amiga specific irq functions */
+extern void amiga_init_IRQ (void);
+extern irqreturn_t (*amiga_default_handler[]) (int, void *, struct pt_regs *);
+extern int amiga_request_irq (unsigned int irq,
+			      irqreturn_t (*handler)(int, void *, struct pt_regs *),
+                              unsigned long flags, const char *devname,
+			      void *dev_id);
+extern void amiga_free_irq (unsigned int irq, void *dev_id);
+extern void amiga_enable_irq (unsigned int);
+extern void amiga_disable_irq (unsigned int);
+static void amiga_get_model(char *model);
+static int amiga_get_hardware_list(char *buffer);
+extern int show_amiga_interrupts (struct seq_file *, void *);
+/* amiga specific timer functions */
+static unsigned long amiga_gettimeoffset (void);
+static int a3000_hwclk (int, struct rtc_time *);
+static int a2000_hwclk (int, struct rtc_time *);
+static int amiga_set_clock_mmss (unsigned long);
+static unsigned int amiga_get_ss (void);
+extern void amiga_mksound( unsigned int count, unsigned int ticks );
+#ifdef CONFIG_AMIGA_FLOPPY
+extern void amiga_floppy_setup(char *, int *);
+#endif
+static void amiga_reset (void);
+extern void amiga_init_sound(void);
+static void amiga_savekmsg_init(void);
+static void amiga_mem_console_write(struct console *co, const char *b,
+				    unsigned int count);
+void amiga_serial_console_write(struct console *co, const char *s,
+				unsigned int count);
+static void amiga_debug_init(void);
+#ifdef CONFIG_HEARTBEAT
+static void amiga_heartbeat(int on);
+#endif
+
+static struct console amiga_console_driver = {
+	.name =		"debug",
+	.flags =	CON_PRINTBUFFER,
+	.index =	-1,
+};
+
+
+    /*
+     *  Motherboard Resources present in all Amiga models
+     */
+
+static struct {
+    struct resource _ciab, _ciaa, _custom, _kickstart;
+} mb_resources = {
+    ._ciab = {
+	.name = "CIA B", .start = 0x00bfd000, .end = 0x00bfdfff
+    },
+    ._ciaa = {
+	.name = "CIA A", .start = 0x00bfe000, .end = 0x00bfefff
+    },
+    ._custom = {
+	.name = "Custom I/O", .start = 0x00dff000, .end = 0x00dfffff
+    },
+    ._kickstart = {
+	.name = "Kickstart ROM", .start = 0x00f80000, .end = 0x00ffffff
+    }
+};
+
+static struct resource rtc_resource = {
+    .start = 0x00dc0000, .end = 0x00dcffff
+};
+
+static struct resource ram_resource[NUM_MEMINFO];
+
+
+    /*
+     *  Parse an Amiga-specific record in the bootinfo
+     */
+
+int amiga_parse_bootinfo(const struct bi_record *record)
+{
+    int unknown = 0;
+    const unsigned long *data = record->data;
+
+    switch (record->tag) {
+	case BI_AMIGA_MODEL:
+	    amiga_model = *data;
+	    break;
+
+	case BI_AMIGA_ECLOCK:
+	    amiga_eclock = *data;
+	    break;
+
+	case BI_AMIGA_CHIPSET:
+	    amiga_chipset = *data;
+	    break;
+
+	case BI_AMIGA_CHIP_SIZE:
+	    amiga_chip_size = *(const int *)data;
+	    break;
+
+	case BI_AMIGA_VBLANK:
+	    amiga_vblank = *(const unsigned char *)data;
+	    break;
+
+	case BI_AMIGA_PSFREQ:
+	    amiga_psfreq = *(const unsigned char *)data;
+	    break;
+
+	case BI_AMIGA_AUTOCON:
+#ifdef CONFIG_ZORRO
+	    if (zorro_num_autocon < ZORRO_NUM_AUTO) {
+		const struct ConfigDev *cd = (struct ConfigDev *)data;
+		struct zorro_dev *dev = &zorro_autocon[zorro_num_autocon++];
+		dev->rom = cd->cd_Rom;
+		dev->slotaddr = cd->cd_SlotAddr;
+		dev->slotsize = cd->cd_SlotSize;
+		dev->resource.start = (unsigned long)cd->cd_BoardAddr;
+		dev->resource.end = dev->resource.start+cd->cd_BoardSize-1;
+	    } else
+		printk("amiga_parse_bootinfo: too many AutoConfig devices\n");
+#endif /* CONFIG_ZORRO */
+	    break;
+
+	case BI_AMIGA_SERPER:
+	    /* serial port period: ignored here */
+	    break;
+
+	default:
+	    unknown = 1;
+    }
+    return(unknown);
+}
+
+    /*
+     *  Identify builtin hardware
+     */
+
+static void __init amiga_identify(void)
+{
+  /* Fill in some default values, if necessary */
+  if (amiga_eclock == 0)
+    amiga_eclock = 709379;
+
+  memset(&amiga_hw_present, 0, sizeof(amiga_hw_present));
+
+  printk("Amiga hardware found: ");
+  if (amiga_model >= AMI_500 && amiga_model <= AMI_DRACO) {
+    printk("[%s] ", amiga_models[amiga_model-AMI_500]);
+    strcat(amiga_model_name, amiga_models[amiga_model-AMI_500]);
+  }
+
+  switch(amiga_model) {
+  case AMI_UNKNOWN:
+    goto Generic;
+
+  case AMI_600:
+  case AMI_1200:
+    AMIGAHW_SET(A1200_IDE);
+    AMIGAHW_SET(PCMCIA);
+  case AMI_500:
+  case AMI_500PLUS:
+  case AMI_1000:
+  case AMI_2000:
+  case AMI_2500:
+    AMIGAHW_SET(A2000_CLK);	/* Is this correct for all models? */
+    goto Generic;
+
+  case AMI_3000:
+  case AMI_3000T:
+    AMIGAHW_SET(AMBER_FF);
+    AMIGAHW_SET(MAGIC_REKICK);
+    /* fall through */
+  case AMI_3000PLUS:
+    AMIGAHW_SET(A3000_SCSI);
+    AMIGAHW_SET(A3000_CLK);
+    AMIGAHW_SET(ZORRO3);
+    goto Generic;
+
+  case AMI_4000T:
+    AMIGAHW_SET(A4000_SCSI);
+    /* fall through */
+  case AMI_4000:
+    AMIGAHW_SET(A4000_IDE);
+    AMIGAHW_SET(A3000_CLK);
+    AMIGAHW_SET(ZORRO3);
+    goto Generic;
+
+  case AMI_CDTV:
+  case AMI_CD32:
+    AMIGAHW_SET(CD_ROM);
+    AMIGAHW_SET(A2000_CLK);             /* Is this correct? */
+    goto Generic;
+
+  Generic:
+    AMIGAHW_SET(AMI_VIDEO);
+    AMIGAHW_SET(AMI_BLITTER);
+    AMIGAHW_SET(AMI_AUDIO);
+    AMIGAHW_SET(AMI_FLOPPY);
+    AMIGAHW_SET(AMI_KEYBOARD);
+    AMIGAHW_SET(AMI_MOUSE);
+    AMIGAHW_SET(AMI_SERIAL);
+    AMIGAHW_SET(AMI_PARALLEL);
+    AMIGAHW_SET(CHIP_RAM);
+    AMIGAHW_SET(PAULA);
+
+    switch(amiga_chipset) {
+    case CS_OCS:
+    case CS_ECS:
+    case CS_AGA:
+      switch (custom.deniseid & 0xf) {
+      case 0x0c:
+	AMIGAHW_SET(DENISE_HR);
+	break;
+      case 0x08:
+	AMIGAHW_SET(LISA);
+	break;
+      }
+      break;
+    default:
+      AMIGAHW_SET(DENISE);
+      break;
+    }
+    switch ((custom.vposr>>8) & 0x7f) {
+    case 0x00:
+      AMIGAHW_SET(AGNUS_PAL);
+      break;
+    case 0x10:
+      AMIGAHW_SET(AGNUS_NTSC);
+      break;
+    case 0x20:
+    case 0x21:
+      AMIGAHW_SET(AGNUS_HR_PAL);
+      break;
+    case 0x30:
+    case 0x31:
+      AMIGAHW_SET(AGNUS_HR_NTSC);
+      break;
+    case 0x22:
+    case 0x23:
+      AMIGAHW_SET(ALICE_PAL);
+      break;
+    case 0x32:
+    case 0x33:
+      AMIGAHW_SET(ALICE_NTSC);
+      break;
+    }
+    AMIGAHW_SET(ZORRO);
+    break;
+
+  case AMI_DRACO:
+    panic("No support for Draco yet");
+
+  default:
+    panic("Unknown Amiga Model");
+  }
+
+#define AMIGAHW_ANNOUNCE(name, str)			\
+  if (AMIGAHW_PRESENT(name))				\
+    printk(str)
+
+  AMIGAHW_ANNOUNCE(AMI_VIDEO, "VIDEO ");
+  AMIGAHW_ANNOUNCE(AMI_BLITTER, "BLITTER ");
+  AMIGAHW_ANNOUNCE(AMBER_FF, "AMBER_FF ");
+  AMIGAHW_ANNOUNCE(AMI_AUDIO, "AUDIO ");
+  AMIGAHW_ANNOUNCE(AMI_FLOPPY, "FLOPPY ");
+  AMIGAHW_ANNOUNCE(A3000_SCSI, "A3000_SCSI ");
+  AMIGAHW_ANNOUNCE(A4000_SCSI, "A4000_SCSI ");
+  AMIGAHW_ANNOUNCE(A1200_IDE, "A1200_IDE ");
+  AMIGAHW_ANNOUNCE(A4000_IDE, "A4000_IDE ");
+  AMIGAHW_ANNOUNCE(CD_ROM, "CD_ROM ");
+  AMIGAHW_ANNOUNCE(AMI_KEYBOARD, "KEYBOARD ");
+  AMIGAHW_ANNOUNCE(AMI_MOUSE, "MOUSE ");
+  AMIGAHW_ANNOUNCE(AMI_SERIAL, "SERIAL ");
+  AMIGAHW_ANNOUNCE(AMI_PARALLEL, "PARALLEL ");
+  AMIGAHW_ANNOUNCE(A2000_CLK, "A2000_CLK ");
+  AMIGAHW_ANNOUNCE(A3000_CLK, "A3000_CLK ");
+  AMIGAHW_ANNOUNCE(CHIP_RAM, "CHIP_RAM ");
+  AMIGAHW_ANNOUNCE(PAULA, "PAULA ");
+  AMIGAHW_ANNOUNCE(DENISE, "DENISE ");
+  AMIGAHW_ANNOUNCE(DENISE_HR, "DENISE_HR ");
+  AMIGAHW_ANNOUNCE(LISA, "LISA ");
+  AMIGAHW_ANNOUNCE(AGNUS_PAL, "AGNUS_PAL ");
+  AMIGAHW_ANNOUNCE(AGNUS_NTSC, "AGNUS_NTSC ");
+  AMIGAHW_ANNOUNCE(AGNUS_HR_PAL, "AGNUS_HR_PAL ");
+  AMIGAHW_ANNOUNCE(AGNUS_HR_NTSC, "AGNUS_HR_NTSC ");
+  AMIGAHW_ANNOUNCE(ALICE_PAL, "ALICE_PAL ");
+  AMIGAHW_ANNOUNCE(ALICE_NTSC, "ALICE_NTSC ");
+  AMIGAHW_ANNOUNCE(MAGIC_REKICK, "MAGIC_REKICK ");
+  AMIGAHW_ANNOUNCE(PCMCIA, "PCMCIA ");
+  if (AMIGAHW_PRESENT(ZORRO))
+    printk("ZORRO%s ", AMIGAHW_PRESENT(ZORRO3) ? "3" : "");
+  printk("\n");
+
+#undef AMIGAHW_ANNOUNCE
+}
+
+    /*
+     *  Setup the Amiga configuration info
+     */
+
+void __init config_amiga(void)
+{
+  int i;
+
+  amiga_debug_init();
+  amiga_identify();
+
+  /* Yuk, we don't have PCI memory */
+  iomem_resource.name = "Memory";
+  for (i = 0; i < 4; i++)
+    request_resource(&iomem_resource, &((struct resource *)&mb_resources)[i]);
+
+  mach_sched_init      = amiga_sched_init;
+  mach_init_IRQ        = amiga_init_IRQ;
+  mach_default_handler = &amiga_default_handler;
+  mach_request_irq     = amiga_request_irq;
+  mach_free_irq        = amiga_free_irq;
+  enable_irq           = amiga_enable_irq;
+  disable_irq          = amiga_disable_irq;
+  mach_get_model       = amiga_get_model;
+  mach_get_hardware_list = amiga_get_hardware_list;
+  mach_get_irq_list    = show_amiga_interrupts;
+  mach_gettimeoffset   = amiga_gettimeoffset;
+  if (AMIGAHW_PRESENT(A3000_CLK)){
+    mach_hwclk         = a3000_hwclk;
+    rtc_resource.name = "A3000 RTC";
+    request_resource(&iomem_resource, &rtc_resource);
+  }
+  else{ /* if (AMIGAHW_PRESENT(A2000_CLK)) */
+    mach_hwclk         = a2000_hwclk;
+    rtc_resource.name = "A2000 RTC";
+    request_resource(&iomem_resource, &rtc_resource);
+  }
+
+  mach_max_dma_address = 0xffffffff; /*
+				      * default MAX_DMA=0xffffffff
+				      * on all machines. If we don't
+				      * do so, the SCSI code will not
+				      * be able to allocate any mem
+				      * for transfers, unless we are
+				      * dealing with a Z2 mem only
+				      * system.                  /Jes
+				      */
+
+  mach_set_clock_mmss  = amiga_set_clock_mmss;
+  mach_get_ss          = amiga_get_ss;
+#ifdef CONFIG_AMIGA_FLOPPY
+  mach_floppy_setup    = amiga_floppy_setup;
+#endif
+  mach_reset           = amiga_reset;
+#ifdef CONFIG_DUMMY_CONSOLE
+  conswitchp           = &dummy_con;
+#endif
+#if defined(CONFIG_INPUT_M68K_BEEP) || defined(CONFIG_INPUT_M68K_BEEP_MODULE)
+  mach_beep            = amiga_mksound;
+#endif
+
+#ifdef CONFIG_HEARTBEAT
+  mach_heartbeat = amiga_heartbeat;
+#endif
+
+  /* Fill in the clock values (based on the 700 kHz E-Clock) */
+  amiga_masterclock = 40*amiga_eclock;	/* 28 MHz */
+  amiga_colorclock = 5*amiga_eclock;	/* 3.5 MHz */
+
+  /* clear all DMA bits */
+  custom.dmacon = DMAF_ALL;
+  /* ensure that the DMA master bit is set */
+  custom.dmacon = DMAF_SETCLR | DMAF_MASTER;
+
+  /* don't use Z2 RAM as system memory on Z3 capable machines */
+  if (AMIGAHW_PRESENT(ZORRO3)) {
+    int i, j;
+    u32 disabled_z2mem = 0;
+    for (i = 0; i < m68k_num_memory; i++)
+      if (m68k_memory[i].addr < 16*1024*1024) {
+	if (i == 0) {
+	  /* don't cut off the branch we're sitting on */
+	  printk("Warning: kernel runs in Zorro II memory\n");
+	  continue;
+	}
+	disabled_z2mem += m68k_memory[i].size;
+	m68k_num_memory--;
+	for (j = i; j < m68k_num_memory; j++)
+	  m68k_memory[j] = m68k_memory[j+1];
+	i--;
+      }
+    if (disabled_z2mem)
+      printk("%dK of Zorro II memory will not be used as system memory\n",
+	     disabled_z2mem>>10);
+  }
+
+  /* request all RAM */
+  for (i = 0; i < m68k_num_memory; i++) {
+    ram_resource[i].name =
+      (m68k_memory[i].addr >= 0x01000000) ? "32-bit Fast RAM" :
+      (m68k_memory[i].addr < 0x00c00000) ? "16-bit Fast RAM" :
+      "16-bit Slow RAM";
+    ram_resource[i].start = m68k_memory[i].addr;
+    ram_resource[i].end = m68k_memory[i].addr+m68k_memory[i].size-1;
+    request_resource(&iomem_resource, &ram_resource[i]);
+  }
+
+  /* initialize chipram allocator */
+  amiga_chip_init ();
+
+  /* debugging using chipram */
+  if (!strcmp( m68k_debug_device, "mem" )){
+	  if (!AMIGAHW_PRESENT(CHIP_RAM))
+		  printk("Warning: no chipram present for debugging\n");
+	  else {
+		  amiga_savekmsg_init();
+		  amiga_console_driver.write = amiga_mem_console_write;
+		  register_console(&amiga_console_driver);
+	  }
+  }
+
+  /* our beloved beeper */
+  if (AMIGAHW_PRESENT(AMI_AUDIO))
+	  amiga_init_sound();
+
+  /*
+   * if it is an A3000, set the magic bit that forces
+   * a hard rekick
+   */
+  if (AMIGAHW_PRESENT(MAGIC_REKICK))
+	  *(unsigned char *)ZTWO_VADDR(0xde0002) |= 0x80;
+}
+
+static unsigned short jiffy_ticks;
+
+static void __init amiga_sched_init(irqreturn_t (*timer_routine)(int, void *,
+							  struct pt_regs *))
+{
+	static struct resource sched_res = {
+	    .name = "timer", .start = 0x00bfd400, .end = 0x00bfd5ff,
+	};
+	jiffy_ticks = (amiga_eclock+HZ/2)/HZ;
+
+	if (request_resource(&mb_resources._ciab, &sched_res))
+	    printk("Cannot allocate ciab.ta{lo,hi}\n");
+	ciab.cra &= 0xC0;   /* turn off timer A, continuous mode, from Eclk */
+	ciab.talo = jiffy_ticks % 256;
+	ciab.tahi = jiffy_ticks / 256;
+
+	/* install interrupt service routine for CIAB Timer A
+	 *
+	 * Please don't change this to use ciaa, as it interferes with the
+	 * SCSI code. We'll have to take a look at this later
+	 */
+	request_irq(IRQ_AMIGA_CIAB_TA, timer_routine, 0, "timer", NULL);
+	/* start timer */
+	ciab.cra |= 0x11;
+}
+
+#define TICK_SIZE 10000
+
+/* This is always executed with interrupts disabled.  */
+static unsigned long amiga_gettimeoffset (void)
+{
+	unsigned short hi, lo, hi2;
+	unsigned long ticks, offset = 0;
+
+	/* read CIA B timer A current value */
+	hi  = ciab.tahi;
+	lo  = ciab.talo;
+	hi2 = ciab.tahi;
+
+	if (hi != hi2) {
+		lo = ciab.talo;
+		hi = hi2;
+	}
+
+	ticks = hi << 8 | lo;
+
+	if (ticks > jiffy_ticks / 2)
+		/* check for pending interrupt */
+		if (cia_set_irq(&ciab_base, 0) & CIA_ICR_TA)
+			offset = 10000;
+
+	ticks = jiffy_ticks - ticks;
+	ticks = (10000 * ticks) / jiffy_ticks;
+
+	return ticks + offset;
+}
+
+static int a3000_hwclk(int op, struct rtc_time *t)
+{
+	tod_3000.cntrl1 = TOD3000_CNTRL1_HOLD;
+
+	if (!op) { /* read */
+		t->tm_sec  = tod_3000.second1 * 10 + tod_3000.second2;
+		t->tm_min  = tod_3000.minute1 * 10 + tod_3000.minute2;
+		t->tm_hour = tod_3000.hour1   * 10 + tod_3000.hour2;
+		t->tm_mday = tod_3000.day1    * 10 + tod_3000.day2;
+		t->tm_wday = tod_3000.weekday;
+		t->tm_mon  = tod_3000.month1  * 10 + tod_3000.month2 - 1;
+		t->tm_year = tod_3000.year1   * 10 + tod_3000.year2;
+		if (t->tm_year <= 69)
+			t->tm_year += 100;
+	} else {
+		tod_3000.second1 = t->tm_sec / 10;
+		tod_3000.second2 = t->tm_sec % 10;
+		tod_3000.minute1 = t->tm_min / 10;
+		tod_3000.minute2 = t->tm_min % 10;
+		tod_3000.hour1   = t->tm_hour / 10;
+		tod_3000.hour2   = t->tm_hour % 10;
+		tod_3000.day1    = t->tm_mday / 10;
+		tod_3000.day2    = t->tm_mday % 10;
+		if (t->tm_wday != -1)
+			tod_3000.weekday = t->tm_wday;
+		tod_3000.month1  = (t->tm_mon + 1) / 10;
+		tod_3000.month2  = (t->tm_mon + 1) % 10;
+		if (t->tm_year >= 100)
+			t->tm_year -= 100;
+		tod_3000.year1   = t->tm_year / 10;
+		tod_3000.year2   = t->tm_year % 10;
+	}
+
+	tod_3000.cntrl1 = TOD3000_CNTRL1_FREE;
+
+	return 0;
+}
+
+static int a2000_hwclk(int op, struct rtc_time *t)
+{
+	int cnt = 5;
+
+	tod_2000.cntrl1 = TOD2000_CNTRL1_HOLD;
+
+	while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt--)
+	{
+	        tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
+	        udelay(70);
+	        tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
+	}
+
+	if (!cnt)
+		printk(KERN_INFO "hwclk: timed out waiting for RTC (0x%x)\n", tod_2000.cntrl1);
+
+	if (!op) { /* read */
+		t->tm_sec  = tod_2000.second1     * 10 + tod_2000.second2;
+		t->tm_min  = tod_2000.minute1     * 10 + tod_2000.minute2;
+		t->tm_hour = (tod_2000.hour1 & 3) * 10 + tod_2000.hour2;
+		t->tm_mday = tod_2000.day1        * 10 + tod_2000.day2;
+		t->tm_wday = tod_2000.weekday;
+		t->tm_mon  = tod_2000.month1      * 10 + tod_2000.month2 - 1;
+		t->tm_year = tod_2000.year1       * 10 + tod_2000.year2;
+		if (t->tm_year <= 69)
+			t->tm_year += 100;
+
+		if (!(tod_2000.cntrl3 & TOD2000_CNTRL3_24HMODE)){
+			if (!(tod_2000.hour1 & TOD2000_HOUR1_PM) && t->tm_hour == 12)
+				t->tm_hour = 0;
+			else if ((tod_2000.hour1 & TOD2000_HOUR1_PM) && t->tm_hour != 12)
+				t->tm_hour += 12;
+		}
+	} else {
+		tod_2000.second1 = t->tm_sec / 10;
+		tod_2000.second2 = t->tm_sec % 10;
+		tod_2000.minute1 = t->tm_min / 10;
+		tod_2000.minute2 = t->tm_min % 10;
+		if (tod_2000.cntrl3 & TOD2000_CNTRL3_24HMODE)
+			tod_2000.hour1 = t->tm_hour / 10;
+		else if (t->tm_hour >= 12)
+			tod_2000.hour1 = TOD2000_HOUR1_PM +
+				(t->tm_hour - 12) / 10;
+		else
+			tod_2000.hour1 = t->tm_hour / 10;
+		tod_2000.hour2   = t->tm_hour % 10;
+		tod_2000.day1    = t->tm_mday / 10;
+		tod_2000.day2    = t->tm_mday % 10;
+		if (t->tm_wday != -1)
+			tod_2000.weekday = t->tm_wday;
+		tod_2000.month1  = (t->tm_mon + 1) / 10;
+		tod_2000.month2  = (t->tm_mon + 1) % 10;
+		if (t->tm_year >= 100)
+			t->tm_year -= 100;
+		tod_2000.year1   = t->tm_year / 10;
+		tod_2000.year2   = t->tm_year % 10;
+	}
+
+	tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
+
+	return 0;
+}
+
+static int amiga_set_clock_mmss (unsigned long nowtime)
+{
+	short real_seconds = nowtime % 60, real_minutes = (nowtime / 60) % 60;
+
+	if (AMIGAHW_PRESENT(A3000_CLK)) {
+		tod_3000.cntrl1 = TOD3000_CNTRL1_HOLD;
+
+		tod_3000.second1 = real_seconds / 10;
+		tod_3000.second2 = real_seconds % 10;
+		tod_3000.minute1 = real_minutes / 10;
+		tod_3000.minute2 = real_minutes % 10;
+
+		tod_3000.cntrl1 = TOD3000_CNTRL1_FREE;
+	} else /* if (AMIGAHW_PRESENT(A2000_CLK)) */ {
+		int cnt = 5;
+
+		tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
+
+		while ((tod_2000.cntrl1 & TOD2000_CNTRL1_BUSY) && cnt--)
+		{
+			tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
+			udelay(70);
+			tod_2000.cntrl1 |= TOD2000_CNTRL1_HOLD;
+		}
+
+		if (!cnt)
+			printk(KERN_INFO "set_clock_mmss: timed out waiting for RTC (0x%x)\n", tod_2000.cntrl1);
+
+		tod_2000.second1 = real_seconds / 10;
+		tod_2000.second2 = real_seconds % 10;
+		tod_2000.minute1 = real_minutes / 10;
+		tod_2000.minute2 = real_minutes % 10;
+
+		tod_2000.cntrl1 &= ~TOD2000_CNTRL1_HOLD;
+	}
+
+	return 0;
+}
+
+static unsigned int amiga_get_ss( void )
+{
+	unsigned int s;
+
+	if (AMIGAHW_PRESENT(A3000_CLK)) {
+		tod_3000.cntrl1 = TOD3000_CNTRL1_HOLD;
+		s = tod_3000.second1 * 10 + tod_3000.second2;
+		tod_3000.cntrl1 = TOD3000_CNTRL1_FREE;
+	} else /* if (AMIGAHW_PRESENT(A2000_CLK)) */ {
+		s = tod_2000.second1 * 10 + tod_2000.second2;
+	}
+	return s;
+}
+
+static NORET_TYPE void amiga_reset( void )
+    ATTRIB_NORET;
+
+static void amiga_reset (void)
+{
+  unsigned long jmp_addr040 = virt_to_phys(&&jmp_addr_label040);
+  unsigned long jmp_addr = virt_to_phys(&&jmp_addr_label);
+
+  local_irq_disable();
+  if (CPU_IS_040_OR_060)
+    /* Setup transparent translation registers for mapping
+     * of 16 MB kernel segment before disabling translation
+     */
+    __asm__ __volatile__
+      ("movel    %0,%/d0\n\t"
+       "andl     #0xff000000,%/d0\n\t"
+       "orw      #0xe020,%/d0\n\t"   /* map 16 MB, enable, cacheable */
+       ".chip    68040\n\t"
+       "movec    %%d0,%%itt0\n\t"
+       "movec    %%d0,%%dtt0\n\t"
+       ".chip    68k\n\t"
+       "jmp      %0@\n\t"
+       : /* no outputs */
+       : "a" (jmp_addr040));
+  else
+    /* for 680[23]0, just disable translation and jump to the physical
+     * address of the label
+     */
+    __asm__ __volatile__
+      ("pmove  %/tc,%@\n\t"
+       "bclr   #7,%@\n\t"
+       "pmove  %@,%/tc\n\t"
+       "jmp    %0@\n\t"
+       : /* no outputs */
+       : "a" (jmp_addr));
+ jmp_addr_label040:
+  /* disable translation on '040 now */
+  __asm__ __volatile__
+    ("moveq #0,%/d0\n\t"
+     ".chip 68040\n\t"
+     "movec %%d0,%%tc\n\t"	/* disable MMU */
+     ".chip 68k\n\t"
+     : /* no outputs */
+     : /* no inputs */
+     : "d0");
+
+ jmp_addr_label:
+  /* pickup reset address from AmigaOS ROM, reset devices and jump
+   * to reset address
+   */
+  __asm__ __volatile__
+    ("movew #0x2700,%/sr\n\t"
+     "leal  0x01000000,%/a0\n\t"
+     "subl  %/a0@(-0x14),%/a0\n\t"
+     "movel %/a0@(4),%/a0\n\t"
+     "subql #2,%/a0\n\t"
+     "bra   1f\n\t"
+     /* align on a longword boundary */
+     __ALIGN_STR "\n"
+     "1:\n\t"
+     "reset\n\t"
+     "jmp   %/a0@" : /* Just that gcc scans it for % escapes */ );
+
+  for (;;);
+
+}
+
+
+    /*
+     *  Debugging
+     */
+
+#define SAVEKMSG_MAXMEM		128*1024
+
+#define SAVEKMSG_MAGIC1		0x53415645	/* 'SAVE' */
+#define SAVEKMSG_MAGIC2		0x4B4D5347	/* 'KMSG' */
+
+struct savekmsg {
+    unsigned long magic1;		/* SAVEKMSG_MAGIC1 */
+    unsigned long magic2;		/* SAVEKMSG_MAGIC2 */
+    unsigned long magicptr;		/* address of magic1 */
+    unsigned long size;
+    char data[0];
+};
+
+static struct savekmsg *savekmsg;
+
+static void amiga_mem_console_write(struct console *co, const char *s,
+				    unsigned int count)
+{
+    if (savekmsg->size+count <= SAVEKMSG_MAXMEM-sizeof(struct savekmsg)) {
+        memcpy(savekmsg->data+savekmsg->size, s, count);
+        savekmsg->size += count;
+    }
+}
+
+static void amiga_savekmsg_init(void)
+{
+    static struct resource debug_res = { .name = "Debug" };
+
+    savekmsg = amiga_chip_alloc_res(SAVEKMSG_MAXMEM, &debug_res);
+    savekmsg->magic1 = SAVEKMSG_MAGIC1;
+    savekmsg->magic2 = SAVEKMSG_MAGIC2;
+    savekmsg->magicptr = ZTWO_PADDR(savekmsg);
+    savekmsg->size = 0;
+}
+
+static void amiga_serial_putc(char c)
+{
+    custom.serdat = (unsigned char)c | 0x100;
+    while (!(custom.serdatr & 0x2000))
+	;
+}
+
+void amiga_serial_console_write(struct console *co, const char *s,
+				       unsigned int count)
+{
+    while (count--) {
+	if (*s == '\n')
+	    amiga_serial_putc('\r');
+	amiga_serial_putc(*s++);
+    }
+}
+
+#ifdef CONFIG_SERIAL_CONSOLE
+void amiga_serial_puts(const char *s)
+{
+    amiga_serial_console_write(NULL, s, strlen(s));
+}
+
+int amiga_serial_console_wait_key(struct console *co)
+{
+    int ch;
+
+    while (!(custom.intreqr & IF_RBF))
+	barrier();
+    ch = custom.serdatr & 0xff;
+    /* clear the interrupt, so that another character can be read */
+    custom.intreq = IF_RBF;
+    return ch;
+}
+
+void amiga_serial_gets(struct console *co, char *s, int len)
+{
+    int ch, cnt = 0;
+
+    while (1) {
+	ch = amiga_serial_console_wait_key(co);
+
+	/* Check for backspace. */
+	if (ch == 8 || ch == 127) {
+	    if (cnt == 0) {
+		amiga_serial_putc('\007');
+		continue;
+	    }
+	    cnt--;
+	    amiga_serial_puts("\010 \010");
+	    continue;
+	}
+
+	/* Check for enter. */
+	if (ch == 10 || ch == 13)
+	    break;
+
+	/* See if line is too long. */
+	if (cnt >= len + 1) {
+	    amiga_serial_putc(7);
+	    cnt--;
+	    continue;
+	}
+
+	/* Store and echo character. */
+	s[cnt++] = ch;
+	amiga_serial_putc(ch);
+    }
+    /* Print enter. */
+    amiga_serial_puts("\r\n");
+    s[cnt] = 0;
+}
+#endif
+
+static void __init amiga_debug_init(void)
+{
+	if (!strcmp( m68k_debug_device, "ser" )) {
+		/* no initialization required (?) */
+		amiga_console_driver.write = amiga_serial_console_write;
+		register_console(&amiga_console_driver);
+	}
+}
+
+#ifdef CONFIG_HEARTBEAT
+static void amiga_heartbeat(int on)
+{
+    if (on)
+	ciaa.pra &= ~2;
+    else
+	ciaa.pra |= 2;
+}
+#endif
+
+    /*
+     *  Amiga specific parts of /proc
+     */
+
+static void amiga_get_model(char *model)
+{
+    strcpy(model, amiga_model_name);
+}
+
+
+static int amiga_get_hardware_list(char *buffer)
+{
+    int len = 0;
+
+    if (AMIGAHW_PRESENT(CHIP_RAM))
+	len += sprintf(buffer+len, "Chip RAM:\t%ldK\n", amiga_chip_size>>10);
+    len += sprintf(buffer+len, "PS Freq:\t%dHz\nEClock Freq:\t%ldHz\n",
+		   amiga_psfreq, amiga_eclock);
+    if (AMIGAHW_PRESENT(AMI_VIDEO)) {
+	char *type;
+	switch(amiga_chipset) {
+	    case CS_OCS:
+		type = "OCS";
+		break;
+	    case CS_ECS:
+		type = "ECS";
+		break;
+	    case CS_AGA:
+		type = "AGA";
+		break;
+	    default:
+		type = "Old or Unknown";
+		break;
+	}
+	len += sprintf(buffer+len, "Graphics:\t%s\n", type);
+    }
+
+#define AMIGAHW_ANNOUNCE(name, str)			\
+    if (AMIGAHW_PRESENT(name))				\
+	len += sprintf (buffer+len, "\t%s\n", str)
+
+    len += sprintf (buffer + len, "Detected hardware:\n");
+
+    AMIGAHW_ANNOUNCE(AMI_VIDEO, "Amiga Video");
+    AMIGAHW_ANNOUNCE(AMI_BLITTER, "Blitter");
+    AMIGAHW_ANNOUNCE(AMBER_FF, "Amber Flicker Fixer");
+    AMIGAHW_ANNOUNCE(AMI_AUDIO, "Amiga Audio");
+    AMIGAHW_ANNOUNCE(AMI_FLOPPY, "Floppy Controller");
+    AMIGAHW_ANNOUNCE(A3000_SCSI, "SCSI Controller WD33C93 (A3000 style)");
+    AMIGAHW_ANNOUNCE(A4000_SCSI, "SCSI Controller NCR53C710 (A4000T style)");
+    AMIGAHW_ANNOUNCE(A1200_IDE, "IDE Interface (A1200 style)");
+    AMIGAHW_ANNOUNCE(A4000_IDE, "IDE Interface (A4000 style)");
+    AMIGAHW_ANNOUNCE(CD_ROM, "Internal CD ROM drive");
+    AMIGAHW_ANNOUNCE(AMI_KEYBOARD, "Keyboard");
+    AMIGAHW_ANNOUNCE(AMI_MOUSE, "Mouse Port");
+    AMIGAHW_ANNOUNCE(AMI_SERIAL, "Serial Port");
+    AMIGAHW_ANNOUNCE(AMI_PARALLEL, "Parallel Port");
+    AMIGAHW_ANNOUNCE(A2000_CLK, "Hardware Clock (A2000 style)");
+    AMIGAHW_ANNOUNCE(A3000_CLK, "Hardware Clock (A3000 style)");
+    AMIGAHW_ANNOUNCE(CHIP_RAM, "Chip RAM");
+    AMIGAHW_ANNOUNCE(PAULA, "Paula 8364");
+    AMIGAHW_ANNOUNCE(DENISE, "Denise 8362");
+    AMIGAHW_ANNOUNCE(DENISE_HR, "Denise 8373");
+    AMIGAHW_ANNOUNCE(LISA, "Lisa 8375");
+    AMIGAHW_ANNOUNCE(AGNUS_PAL, "Normal/Fat PAL Agnus 8367/8371");
+    AMIGAHW_ANNOUNCE(AGNUS_NTSC, "Normal/Fat NTSC Agnus 8361/8370");
+    AMIGAHW_ANNOUNCE(AGNUS_HR_PAL, "Fat Hires PAL Agnus 8372");
+    AMIGAHW_ANNOUNCE(AGNUS_HR_NTSC, "Fat Hires NTSC Agnus 8372");
+    AMIGAHW_ANNOUNCE(ALICE_PAL, "PAL Alice 8374");
+    AMIGAHW_ANNOUNCE(ALICE_NTSC, "NTSC Alice 8374");
+    AMIGAHW_ANNOUNCE(MAGIC_REKICK, "Magic Hard Rekick");
+    AMIGAHW_ANNOUNCE(PCMCIA, "PCMCIA Slot");
+#ifdef CONFIG_ZORRO
+    if (AMIGAHW_PRESENT(ZORRO))
+	len += sprintf(buffer+len, "\tZorro II%s AutoConfig: %d Expansion "
+				   "Device%s\n",
+		       AMIGAHW_PRESENT(ZORRO3) ? "I" : "",
+		       zorro_num_autocon, zorro_num_autocon == 1 ? "" : "s");
+#endif /* CONFIG_ZORRO */
+
+#undef AMIGAHW_ANNOUNCE
+
+    return(len);
+}
