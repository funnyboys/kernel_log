commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index 47b5f90002ab..7ff739e94896 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -46,7 +46,7 @@ static struct irq_chip amiga_irq_chip = {
  * The builtin Amiga hardware interrupt handlers.
  */
 
-static void ami_int1(unsigned int irq, struct irq_desc *desc)
+static void ami_int1(struct irq_desc *desc)
 {
 	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 
@@ -69,7 +69,7 @@ static void ami_int1(unsigned int irq, struct irq_desc *desc)
 	}
 }
 
-static void ami_int3(unsigned int irq, struct irq_desc *desc)
+static void ami_int3(struct irq_desc *desc)
 {
 	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 
@@ -92,7 +92,7 @@ static void ami_int3(unsigned int irq, struct irq_desc *desc)
 	}
 }
 
-static void ami_int4(unsigned int irq, struct irq_desc *desc)
+static void ami_int4(struct irq_desc *desc)
 {
 	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 
@@ -121,7 +121,7 @@ static void ami_int4(unsigned int irq, struct irq_desc *desc)
 	}
 }
 
-static void ami_int5(unsigned int irq, struct irq_desc *desc)
+static void ami_int5(struct irq_desc *desc)
 {
 	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 

commit d890d73995257b4e10cdd7d55bad80e34a71ba22
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 11 11:28:04 2011 +0200

    m68k/irq: Remove obsolete m68k irq framework
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index a8da47126584..47b5f90002ab 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -9,9 +9,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/errno.h>
-#ifdef CONFIG_GENERIC_HARDIRQS
 #include <linux/irq.h>
-#endif
 
 #include <asm/irq.h>
 #include <asm/traps.h>
@@ -48,7 +46,6 @@ static struct irq_chip amiga_irq_chip = {
  * The builtin Amiga hardware interrupt handlers.
  */
 
-#ifdef CONFIG_GENERIC_HARDIRQS
 static void ami_int1(unsigned int irq, struct irq_desc *desc)
 {
 	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
@@ -140,103 +137,6 @@ static void ami_int5(unsigned int irq, struct irq_desc *desc)
 		generic_handle_irq(IRQ_AMIGA_DSKSYN);
 	}
 }
-#else /* !CONFIG_GENERIC_HARDIRQS */
-static irqreturn_t ami_int1(int irq, void *dev_id)
-{
-	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
-
-	/* if serial transmit buffer empty, interrupt */
-	if (ints & IF_TBE) {
-		amiga_custom.intreq = IF_TBE;
-		generic_handle_irq(IRQ_AMIGA_TBE);
-	}
-
-	/* if floppy disk transfer complete, interrupt */
-	if (ints & IF_DSKBLK) {
-		amiga_custom.intreq = IF_DSKBLK;
-		generic_handle_irq(IRQ_AMIGA_DSKBLK);
-	}
-
-	/* if software interrupt set, interrupt */
-	if (ints & IF_SOFT) {
-		amiga_custom.intreq = IF_SOFT;
-		generic_handle_irq(IRQ_AMIGA_SOFT);
-	}
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t ami_int3(int irq, void *dev_id)
-{
-	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
-
-	/* if a blitter interrupt */
-	if (ints & IF_BLIT) {
-		amiga_custom.intreq = IF_BLIT;
-		generic_handle_irq(IRQ_AMIGA_BLIT);
-	}
-
-	/* if a copper interrupt */
-	if (ints & IF_COPER) {
-		amiga_custom.intreq = IF_COPER;
-		generic_handle_irq(IRQ_AMIGA_COPPER);
-	}
-
-	/* if a vertical blank interrupt */
-	if (ints & IF_VERTB) {
-		amiga_custom.intreq = IF_VERTB;
-		generic_handle_irq(IRQ_AMIGA_VERTB);
-	}
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t ami_int4(int irq, void *dev_id)
-{
-	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
-
-	/* if audio 0 interrupt */
-	if (ints & IF_AUD0) {
-		amiga_custom.intreq = IF_AUD0;
-		generic_handle_irq(IRQ_AMIGA_AUD0);
-	}
-
-	/* if audio 1 interrupt */
-	if (ints & IF_AUD1) {
-		amiga_custom.intreq = IF_AUD1;
-		generic_handle_irq(IRQ_AMIGA_AUD1);
-	}
-
-	/* if audio 2 interrupt */
-	if (ints & IF_AUD2) {
-		amiga_custom.intreq = IF_AUD2;
-		generic_handle_irq(IRQ_AMIGA_AUD2);
-	}
-
-	/* if audio 3 interrupt */
-	if (ints & IF_AUD3) {
-		amiga_custom.intreq = IF_AUD3;
-		generic_handle_irq(IRQ_AMIGA_AUD3);
-	}
-	return IRQ_HANDLED;
-}
-
-static irqreturn_t ami_int5(int irq, void *dev_id)
-{
-	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
-
-	/* if serial receive buffer full interrupt */
-	if (ints & IF_RBF) {
-		/* acknowledge of IF_RBF must be done by the serial interrupt */
-		generic_handle_irq(IRQ_AMIGA_RBF);
-	}
-
-	/* if a disk sync interrupt */
-	if (ints & IF_DSKSYN) {
-		amiga_custom.intreq = IF_DSKSYN;
-		generic_handle_irq(IRQ_AMIGA_DSKSYN);
-	}
-	return IRQ_HANDLED;
-}
-#endif /* !CONFIG_GENERIC_HARDIRQS */
 
 
 /*
@@ -252,7 +152,6 @@ static irqreturn_t ami_int5(int irq, void *dev_id)
 
 void __init amiga_init_IRQ(void)
 {
-#ifdef CONFIG_GENERIC_HARDIRQS
 	m68k_setup_irq_controller(&amiga_irq_chip, handle_simple_irq, IRQ_USER,
 				  AMI_STD_IRQS);
 
@@ -260,19 +159,6 @@ void __init amiga_init_IRQ(void)
 	irq_set_chained_handler(IRQ_AUTO_3, ami_int3);
 	irq_set_chained_handler(IRQ_AUTO_4, ami_int4);
 	irq_set_chained_handler(IRQ_AUTO_5, ami_int5);
-#else /* !CONFIG_GENERIC_HARDIRQS */
-	if (request_irq(IRQ_AUTO_1, ami_int1, 0, "int1", NULL))
-		pr_err("Couldn't register int%d\n", 1);
-	if (request_irq(IRQ_AUTO_3, ami_int3, 0, "int3", NULL))
-		pr_err("Couldn't register int%d\n", 3);
-	if (request_irq(IRQ_AUTO_4, ami_int4, 0, "int4", NULL))
-		pr_err("Couldn't register int%d\n", 4);
-	if (request_irq(IRQ_AUTO_5, ami_int5, 0, "int5", NULL))
-		pr_err("Couldn't register int%d\n", 5);
-
-	m68k_setup_irq_controller(&amiga_irq_chip, handle_simple_irq, IRQ_USER,
-				  AMI_STD_IRQS);
-#endif /* !CONFIG_GENERIC_HARDIRQS */
 
 	/* turn off PCMCIA interrupts */
 	if (AMIGAHW_PRESENT(PCMCIA))

commit fb1b646aa3bcae2f8211136a6b40228c7c9d236c
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jun 1 11:49:18 2011 +0200

    m68k/amiga: Optimize interrupts using chain handlers
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index c3da5342f495..a8da47126584 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -48,6 +48,99 @@ static struct irq_chip amiga_irq_chip = {
  * The builtin Amiga hardware interrupt handlers.
  */
 
+#ifdef CONFIG_GENERIC_HARDIRQS
+static void ami_int1(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
+
+	/* if serial transmit buffer empty, interrupt */
+	if (ints & IF_TBE) {
+		amiga_custom.intreq = IF_TBE;
+		generic_handle_irq(IRQ_AMIGA_TBE);
+	}
+
+	/* if floppy disk transfer complete, interrupt */
+	if (ints & IF_DSKBLK) {
+		amiga_custom.intreq = IF_DSKBLK;
+		generic_handle_irq(IRQ_AMIGA_DSKBLK);
+	}
+
+	/* if software interrupt set, interrupt */
+	if (ints & IF_SOFT) {
+		amiga_custom.intreq = IF_SOFT;
+		generic_handle_irq(IRQ_AMIGA_SOFT);
+	}
+}
+
+static void ami_int3(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
+
+	/* if a blitter interrupt */
+	if (ints & IF_BLIT) {
+		amiga_custom.intreq = IF_BLIT;
+		generic_handle_irq(IRQ_AMIGA_BLIT);
+	}
+
+	/* if a copper interrupt */
+	if (ints & IF_COPER) {
+		amiga_custom.intreq = IF_COPER;
+		generic_handle_irq(IRQ_AMIGA_COPPER);
+	}
+
+	/* if a vertical blank interrupt */
+	if (ints & IF_VERTB) {
+		amiga_custom.intreq = IF_VERTB;
+		generic_handle_irq(IRQ_AMIGA_VERTB);
+	}
+}
+
+static void ami_int4(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
+
+	/* if audio 0 interrupt */
+	if (ints & IF_AUD0) {
+		amiga_custom.intreq = IF_AUD0;
+		generic_handle_irq(IRQ_AMIGA_AUD0);
+	}
+
+	/* if audio 1 interrupt */
+	if (ints & IF_AUD1) {
+		amiga_custom.intreq = IF_AUD1;
+		generic_handle_irq(IRQ_AMIGA_AUD1);
+	}
+
+	/* if audio 2 interrupt */
+	if (ints & IF_AUD2) {
+		amiga_custom.intreq = IF_AUD2;
+		generic_handle_irq(IRQ_AMIGA_AUD2);
+	}
+
+	/* if audio 3 interrupt */
+	if (ints & IF_AUD3) {
+		amiga_custom.intreq = IF_AUD3;
+		generic_handle_irq(IRQ_AMIGA_AUD3);
+	}
+}
+
+static void ami_int5(unsigned int irq, struct irq_desc *desc)
+{
+	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
+
+	/* if serial receive buffer full interrupt */
+	if (ints & IF_RBF) {
+		/* acknowledge of IF_RBF must be done by the serial interrupt */
+		generic_handle_irq(IRQ_AMIGA_RBF);
+	}
+
+	/* if a disk sync interrupt */
+	if (ints & IF_DSKSYN) {
+		amiga_custom.intreq = IF_DSKSYN;
+		generic_handle_irq(IRQ_AMIGA_DSKSYN);
+	}
+}
+#else /* !CONFIG_GENERIC_HARDIRQS */
 static irqreturn_t ami_int1(int irq, void *dev_id)
 {
 	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
@@ -143,6 +236,7 @@ static irqreturn_t ami_int5(int irq, void *dev_id)
 	}
 	return IRQ_HANDLED;
 }
+#endif /* !CONFIG_GENERIC_HARDIRQS */
 
 
 /*
@@ -158,6 +252,15 @@ static irqreturn_t ami_int5(int irq, void *dev_id)
 
 void __init amiga_init_IRQ(void)
 {
+#ifdef CONFIG_GENERIC_HARDIRQS
+	m68k_setup_irq_controller(&amiga_irq_chip, handle_simple_irq, IRQ_USER,
+				  AMI_STD_IRQS);
+
+	irq_set_chained_handler(IRQ_AUTO_1, ami_int1);
+	irq_set_chained_handler(IRQ_AUTO_3, ami_int3);
+	irq_set_chained_handler(IRQ_AUTO_4, ami_int4);
+	irq_set_chained_handler(IRQ_AUTO_5, ami_int5);
+#else /* !CONFIG_GENERIC_HARDIRQS */
 	if (request_irq(IRQ_AUTO_1, ami_int1, 0, "int1", NULL))
 		pr_err("Couldn't register int%d\n", 1);
 	if (request_irq(IRQ_AUTO_3, ami_int3, 0, "int3", NULL))
@@ -169,6 +272,7 @@ void __init amiga_init_IRQ(void)
 
 	m68k_setup_irq_controller(&amiga_irq_chip, handle_simple_irq, IRQ_USER,
 				  AMI_STD_IRQS);
+#endif /* !CONFIG_GENERIC_HARDIRQS */
 
 	/* turn off PCMCIA interrupts */
 	if (AMIGAHW_PRESENT(PCMCIA))

commit 978ef7e6d0e02083e4a62ab4411922bdeffa36a4
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue May 31 22:08:28 2011 +0200

    m68k/amiga: Convert Amiga to genirq
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index c8f9eac121a1..c3da5342f495 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -9,6 +9,9 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/errno.h>
+#ifdef CONFIG_GENERIC_HARDIRQS
+#include <linux/irq.h>
+#endif
 
 #include <asm/irq.h>
 #include <asm/traps.h>

commit 92b1bd5f1aa88ce4760c02814bfcbb58ad521984
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue May 31 11:11:01 2011 +0200

    m68k/amiga: Refactor amiints.c
    
      - Remove filename in comments,
      - Reorder functions so we no longer need forward declarations.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index e5f3033499e7..c8f9eac121a1 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -1,5 +1,5 @@
 /*
- * linux/arch/m68k/amiga/amiints.c -- Amiga Linux interrupt handling code
+ * Amiga Linux interrupt handling code
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file COPYING in the main directory of this archive
@@ -16,56 +16,6 @@
 #include <asm/amigaints.h>
 #include <asm/amipcmcia.h>
 
-static void amiga_irq_enable(struct irq_data *data);
-static void amiga_irq_disable(struct irq_data *data);
-static irqreturn_t ami_int1(int irq, void *dev_id);
-static irqreturn_t ami_int3(int irq, void *dev_id);
-static irqreturn_t ami_int4(int irq, void *dev_id);
-static irqreturn_t ami_int5(int irq, void *dev_id);
-
-static struct irq_chip amiga_irq_chip = {
-	.name		= "amiga",
-	.irq_enable	= amiga_irq_enable,
-	.irq_disable	= amiga_irq_disable,
-};
-
-/*
- * void amiga_init_IRQ(void)
- *
- * Parameters:	None
- *
- * Returns:	Nothing
- *
- * This function should be called during kernel startup to initialize
- * the amiga IRQ handling routines.
- */
-
-void __init amiga_init_IRQ(void)
-{
-	if (request_irq(IRQ_AUTO_1, ami_int1, 0, "int1", NULL))
-		pr_err("Couldn't register int%d\n", 1);
-	if (request_irq(IRQ_AUTO_3, ami_int3, 0, "int3", NULL))
-		pr_err("Couldn't register int%d\n", 3);
-	if (request_irq(IRQ_AUTO_4, ami_int4, 0, "int4", NULL))
-		pr_err("Couldn't register int%d\n", 4);
-	if (request_irq(IRQ_AUTO_5, ami_int5, 0, "int5", NULL))
-		pr_err("Couldn't register int%d\n", 5);
-
-	m68k_setup_irq_controller(&amiga_irq_chip, handle_simple_irq, IRQ_USER,
-				  AMI_STD_IRQS);
-
-	/* turn off PCMCIA interrupts */
-	if (AMIGAHW_PRESENT(PCMCIA))
-		gayle.inten = GAYLE_IRQ_IDE;
-
-	/* turn off all interrupts and enable the master interrupt bit */
-	amiga_custom.intena = 0x7fff;
-	amiga_custom.intreq = 0x7fff;
-	amiga_custom.intena = IF_SETCLR | IF_INTEN;
-
-	cia_init_IRQ(&ciaa_base);
-	cia_init_IRQ(&ciab_base);
-}
 
 /*
  * Enable/disable a particular machine specific interrupt source.
@@ -84,6 +34,13 @@ static void amiga_irq_disable(struct irq_data *data)
 	amiga_custom.intena = 1 << (data->irq - IRQ_USER);
 }
 
+static struct irq_chip amiga_irq_chip = {
+	.name		= "amiga",
+	.irq_enable	= amiga_irq_enable,
+	.irq_disable	= amiga_irq_disable,
+};
+
+
 /*
  * The builtin Amiga hardware interrupt handlers.
  */
@@ -183,3 +140,42 @@ static irqreturn_t ami_int5(int irq, void *dev_id)
 	}
 	return IRQ_HANDLED;
 }
+
+
+/*
+ * void amiga_init_IRQ(void)
+ *
+ * Parameters:	None
+ *
+ * Returns:	Nothing
+ *
+ * This function should be called during kernel startup to initialize
+ * the amiga IRQ handling routines.
+ */
+
+void __init amiga_init_IRQ(void)
+{
+	if (request_irq(IRQ_AUTO_1, ami_int1, 0, "int1", NULL))
+		pr_err("Couldn't register int%d\n", 1);
+	if (request_irq(IRQ_AUTO_3, ami_int3, 0, "int3", NULL))
+		pr_err("Couldn't register int%d\n", 3);
+	if (request_irq(IRQ_AUTO_4, ami_int4, 0, "int4", NULL))
+		pr_err("Couldn't register int%d\n", 4);
+	if (request_irq(IRQ_AUTO_5, ami_int5, 0, "int5", NULL))
+		pr_err("Couldn't register int%d\n", 5);
+
+	m68k_setup_irq_controller(&amiga_irq_chip, handle_simple_irq, IRQ_USER,
+				  AMI_STD_IRQS);
+
+	/* turn off PCMCIA interrupts */
+	if (AMIGAHW_PRESENT(PCMCIA))
+		gayle.inten = GAYLE_IRQ_IDE;
+
+	/* turn off all interrupts and enable the master interrupt bit */
+	amiga_custom.intena = 0x7fff;
+	amiga_custom.intreq = 0x7fff;
+	amiga_custom.intena = IF_SETCLR | IF_INTEN;
+
+	cia_init_IRQ(&ciaa_base);
+	cia_init_IRQ(&ciab_base);
+}

commit 5a2394534b160ce18f9a705cf9de40e77648f8a2
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jul 13 22:33:13 2011 +0200

    m68k/irq: Remove obsolete IRQ_FLG_* users
    
    The m68k core irq code stopped honoring these flags during the irq
    restructuring in 2006.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index 0daa7fce9df1..e5f3033499e7 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -4,35 +4,6 @@
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file COPYING in the main directory of this archive
  * for more details.
- *
- * 11/07/96: rewritten interrupt handling, irq lists are exists now only for
- *           this sources where it makes sense (VERTB/PORTS/EXTER) and you must
- *           be careful that dev_id for this sources is unique since this the
- *           only possibility to distinguish between different handlers for
- *           free_irq. irq lists also have different irq flags:
- *           - IRQ_FLG_FAST: handler is inserted at top of list (after other
- *                           fast handlers)
- *           - IRQ_FLG_SLOW: handler is inserted at bottom of list and before
- *                           they're executed irq level is set to the previous
- *                           one, but handlers don't need to be reentrant, if
- *                           reentrance occurred, slow handlers will be just
- *                           called again.
- *           The whole interrupt handling for CIAs is moved to cia.c
- *           /Roman Zippel
- *
- * 07/08/99: rewamp of the interrupt handling - we now have two types of
- *           interrupts, normal and fast handlers, fast handlers being
- *           marked with IRQF_DISABLED and runs with all other interrupts
- *           disabled. Normal interrupts disable their own source but
- *           run with all other interrupt sources enabled.
- *           PORTS and EXTER interrupts are always shared even if the
- *           drivers do not explicitly mark this when calling
- *           request_irq which they really should do.
- *           This is similar to the way interrupts are handled on all
- *           other architectures and makes a ton of sense besides
- *           having the advantage of making it easier to share
- *           drivers.
- *           /Jes
  */
 
 #include <linux/init.h>

commit 1425df87c25b15400c9f26d57821bcfe01286b2a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Jul 1 20:39:19 2011 +0200

    m68k/irq: Rename {,__}m68k_handle_int()
    
      - Rename m68k_handle_int() to generic_handle_irq(), and drop the unneeded
        asmlinkage,
      - Rename __m68k_handle_int() to do_IRQ().
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index 8af5ea3eea67..0daa7fce9df1 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -124,19 +124,19 @@ static irqreturn_t ami_int1(int irq, void *dev_id)
 	/* if serial transmit buffer empty, interrupt */
 	if (ints & IF_TBE) {
 		amiga_custom.intreq = IF_TBE;
-		m68k_handle_int(IRQ_AMIGA_TBE);
+		generic_handle_irq(IRQ_AMIGA_TBE);
 	}
 
 	/* if floppy disk transfer complete, interrupt */
 	if (ints & IF_DSKBLK) {
 		amiga_custom.intreq = IF_DSKBLK;
-		m68k_handle_int(IRQ_AMIGA_DSKBLK);
+		generic_handle_irq(IRQ_AMIGA_DSKBLK);
 	}
 
 	/* if software interrupt set, interrupt */
 	if (ints & IF_SOFT) {
 		amiga_custom.intreq = IF_SOFT;
-		m68k_handle_int(IRQ_AMIGA_SOFT);
+		generic_handle_irq(IRQ_AMIGA_SOFT);
 	}
 	return IRQ_HANDLED;
 }
@@ -148,19 +148,19 @@ static irqreturn_t ami_int3(int irq, void *dev_id)
 	/* if a blitter interrupt */
 	if (ints & IF_BLIT) {
 		amiga_custom.intreq = IF_BLIT;
-		m68k_handle_int(IRQ_AMIGA_BLIT);
+		generic_handle_irq(IRQ_AMIGA_BLIT);
 	}
 
 	/* if a copper interrupt */
 	if (ints & IF_COPER) {
 		amiga_custom.intreq = IF_COPER;
-		m68k_handle_int(IRQ_AMIGA_COPPER);
+		generic_handle_irq(IRQ_AMIGA_COPPER);
 	}
 
 	/* if a vertical blank interrupt */
 	if (ints & IF_VERTB) {
 		amiga_custom.intreq = IF_VERTB;
-		m68k_handle_int(IRQ_AMIGA_VERTB);
+		generic_handle_irq(IRQ_AMIGA_VERTB);
 	}
 	return IRQ_HANDLED;
 }
@@ -172,25 +172,25 @@ static irqreturn_t ami_int4(int irq, void *dev_id)
 	/* if audio 0 interrupt */
 	if (ints & IF_AUD0) {
 		amiga_custom.intreq = IF_AUD0;
-		m68k_handle_int(IRQ_AMIGA_AUD0);
+		generic_handle_irq(IRQ_AMIGA_AUD0);
 	}
 
 	/* if audio 1 interrupt */
 	if (ints & IF_AUD1) {
 		amiga_custom.intreq = IF_AUD1;
-		m68k_handle_int(IRQ_AMIGA_AUD1);
+		generic_handle_irq(IRQ_AMIGA_AUD1);
 	}
 
 	/* if audio 2 interrupt */
 	if (ints & IF_AUD2) {
 		amiga_custom.intreq = IF_AUD2;
-		m68k_handle_int(IRQ_AMIGA_AUD2);
+		generic_handle_irq(IRQ_AMIGA_AUD2);
 	}
 
 	/* if audio 3 interrupt */
 	if (ints & IF_AUD3) {
 		amiga_custom.intreq = IF_AUD3;
-		m68k_handle_int(IRQ_AMIGA_AUD3);
+		generic_handle_irq(IRQ_AMIGA_AUD3);
 	}
 	return IRQ_HANDLED;
 }
@@ -202,13 +202,13 @@ static irqreturn_t ami_int5(int irq, void *dev_id)
 	/* if serial receive buffer full interrupt */
 	if (ints & IF_RBF) {
 		/* acknowledge of IF_RBF must be done by the serial interrupt */
-		m68k_handle_int(IRQ_AMIGA_RBF);
+		generic_handle_irq(IRQ_AMIGA_RBF);
 	}
 
 	/* if a disk sync interrupt */
 	if (ints & IF_DSKSYN) {
 		amiga_custom.intreq = IF_DSKSYN;
-		m68k_handle_int(IRQ_AMIGA_DSKSYN);
+		generic_handle_irq(IRQ_AMIGA_DSKSYN);
 	}
 	return IRQ_HANDLED;
 }

commit edb347256c44366888debb4f9e8477ac700a9026
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jun 1 11:15:21 2011 +0200

    m68k/irq: Add m68k_setup_irq_controller()
    
    This is a wrapper around m68k_setup_irq_chip() that discards its dummy
    second parameter, to ease the future transition to genirq.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index 09a695babfe9..8af5ea3eea67 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -80,7 +80,8 @@ void __init amiga_init_IRQ(void)
 	if (request_irq(IRQ_AUTO_5, ami_int5, 0, "int5", NULL))
 		pr_err("Couldn't register int%d\n", 5);
 
-	m68k_setup_irq_chip(&amiga_irq_chip, IRQ_USER, AMI_STD_IRQS);
+	m68k_setup_irq_controller(&amiga_irq_chip, handle_simple_irq, IRQ_USER,
+				  AMI_STD_IRQS);
 
 	/* turn off PCMCIA interrupts */
 	if (AMIGAHW_PRESENT(PCMCIA))

commit e8abf5e73cdb6c034d35ccba1f63a4801cd3dec5
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 17 22:53:04 2011 +0200

    m68k/irq: Switch irq_chip methods to "struct irq_data *data"
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index 320c5d048dc7..09a695babfe9 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -45,8 +45,8 @@
 #include <asm/amigaints.h>
 #include <asm/amipcmcia.h>
 
-static void amiga_enable_irq(unsigned int irq);
-static void amiga_disable_irq(unsigned int irq);
+static void amiga_irq_enable(struct irq_data *data);
+static void amiga_irq_disable(struct irq_data *data);
 static irqreturn_t ami_int1(int irq, void *dev_id);
 static irqreturn_t ami_int3(int irq, void *dev_id);
 static irqreturn_t ami_int4(int irq, void *dev_id);
@@ -54,8 +54,8 @@ static irqreturn_t ami_int5(int irq, void *dev_id);
 
 static struct irq_chip amiga_irq_chip = {
 	.name		= "amiga",
-	.irq_enable	= amiga_enable_irq,
-	.irq_disable	= amiga_disable_irq,
+	.irq_enable	= amiga_irq_enable,
+	.irq_disable	= amiga_irq_disable,
 };
 
 /*
@@ -102,14 +102,14 @@ void __init amiga_init_IRQ(void)
  * internal data, that may not be changed by the interrupt at the same time.
  */
 
-static void amiga_enable_irq(unsigned int irq)
+static void amiga_irq_enable(struct irq_data *data)
 {
-	amiga_custom.intena = IF_SETCLR | (1 << (irq - IRQ_USER));
+	amiga_custom.intena = IF_SETCLR | (1 << (data->irq - IRQ_USER));
 }
 
-static void amiga_disable_irq(unsigned int irq)
+static void amiga_irq_disable(struct irq_data *data)
 {
-	amiga_custom.intena = 1 << (irq - IRQ_USER);
+	amiga_custom.intena = 1 << (data->irq - IRQ_USER);
 }
 
 /*

commit c288bf2533e57174b90b07860c4391bcd1ea269c
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Apr 13 22:31:28 2011 +0200

    m68k/irq: Rename irq_controller to irq_chip
    
    Make it more similar to the genirq version:
      - Remove lock (unused as we don't do SMP anyway),
      - Prepend methods with irq_,
      - Make irq_startup() return unsigned int.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index c5b5212cc3f9..320c5d048dc7 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -52,11 +52,10 @@ static irqreturn_t ami_int3(int irq, void *dev_id);
 static irqreturn_t ami_int4(int irq, void *dev_id);
 static irqreturn_t ami_int5(int irq, void *dev_id);
 
-static struct irq_controller amiga_irq_controller = {
+static struct irq_chip amiga_irq_chip = {
 	.name		= "amiga",
-	.lock		= __SPIN_LOCK_UNLOCKED(amiga_irq_controller.lock),
-	.enable		= amiga_enable_irq,
-	.disable	= amiga_disable_irq,
+	.irq_enable	= amiga_enable_irq,
+	.irq_disable	= amiga_disable_irq,
 };
 
 /*
@@ -81,7 +80,7 @@ void __init amiga_init_IRQ(void)
 	if (request_irq(IRQ_AUTO_5, ami_int5, 0, "int5", NULL))
 		pr_err("Couldn't register int%d\n", 5);
 
-	m68k_setup_irq_controller(&amiga_irq_controller, IRQ_USER, AMI_STD_IRQS);
+	m68k_setup_irq_chip(&amiga_irq_chip, IRQ_USER, AMI_STD_IRQS);
 
 	/* turn off PCMCIA interrupts */
 	if (AMIGAHW_PRESENT(PCMCIA))

commit 66acd2581259d80935fc5216b4b1268d639d9143
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Dec 30 14:00:34 2008 +0100

    m68k: amiga core - Kill warn_unused_result warnings
    
    warning: ignoring return value of 'request_irq', declared with attribute
    warn_unused_result
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index 907a5533c845..c5b5212cc3f9 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -72,10 +72,14 @@ static struct irq_controller amiga_irq_controller = {
 
 void __init amiga_init_IRQ(void)
 {
-	request_irq(IRQ_AUTO_1, ami_int1, 0, "int1", NULL);
-	request_irq(IRQ_AUTO_3, ami_int3, 0, "int3", NULL);
-	request_irq(IRQ_AUTO_4, ami_int4, 0, "int4", NULL);
-	request_irq(IRQ_AUTO_5, ami_int5, 0, "int5", NULL);
+	if (request_irq(IRQ_AUTO_1, ami_int1, 0, "int1", NULL))
+		pr_err("Couldn't register int%d\n", 1);
+	if (request_irq(IRQ_AUTO_3, ami_int3, 0, "int3", NULL))
+		pr_err("Couldn't register int%d\n", 3);
+	if (request_irq(IRQ_AUTO_4, ami_int4, 0, "int4", NULL))
+		pr_err("Couldn't register int%d\n", 4);
+	if (request_irq(IRQ_AUTO_5, ami_int5, 0, "int5", NULL))
+		pr_err("Couldn't register int%d\n", 5);
 
 	m68k_setup_irq_controller(&amiga_irq_controller, IRQ_USER, AMI_STD_IRQS);
 

commit 241258d1cc4d3551608364cd678d5a85239ad481
Author: Milind Arun Choudhary <milindchoudhary@gmail.com>
Date:   Sun May 6 14:50:54 2007 -0700

    SPIN_LOCK_UNLOCKED cleanup in arch/m68k
    
    SPIN_LOCK_UNLOCKED cleanup,use __SPIN_LOCK_UNLOCKED instead
    
    Signed-off-by: Milind Arun Choudhary <milindchoudhary@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index 28d95cfe8ac0..907a5533c845 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -54,7 +54,7 @@ static irqreturn_t ami_int5(int irq, void *dev_id);
 
 static struct irq_controller amiga_irq_controller = {
 	.name		= "amiga",
-	.lock		= SPIN_LOCK_UNLOCKED,
+	.lock		= __SPIN_LOCK_UNLOCKED(amiga_irq_controller.lock),
 	.enable		= amiga_enable_irq,
 	.disable	= amiga_disable_irq,
 };

commit 2850bc273776cbb1b510c5828e9e456dffb50a32
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Oct 7 14:16:45 2006 +0100

    [PATCH] m68k pt_regs fixes
    
    m68k_handle_int() split in two functions: __m68k_handle_int() takes
    pt_regs * and does set_irq_regs(); m68k_handle_int() doesn't get pt_regs
    *.
    
    Places where we used to call m68k_handle_int() recursively with the same
    pt_regs have simply lost the second argument, the rest is switched to
    __m68k_handle_int().
    
    The rest of patch is just dropping pt_regs * where needed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index 96c79d840cff..28d95cfe8ac0 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -47,10 +47,10 @@
 
 static void amiga_enable_irq(unsigned int irq);
 static void amiga_disable_irq(unsigned int irq);
-static irqreturn_t ami_int1(int irq, void *dev_id, struct pt_regs *fp);
-static irqreturn_t ami_int3(int irq, void *dev_id, struct pt_regs *fp);
-static irqreturn_t ami_int4(int irq, void *dev_id, struct pt_regs *fp);
-static irqreturn_t ami_int5(int irq, void *dev_id, struct pt_regs *fp);
+static irqreturn_t ami_int1(int irq, void *dev_id);
+static irqreturn_t ami_int3(int irq, void *dev_id);
+static irqreturn_t ami_int4(int irq, void *dev_id);
+static irqreturn_t ami_int5(int irq, void *dev_id);
 
 static struct irq_controller amiga_irq_controller = {
 	.name		= "amiga",
@@ -113,98 +113,98 @@ static void amiga_disable_irq(unsigned int irq)
  * The builtin Amiga hardware interrupt handlers.
  */
 
-static irqreturn_t ami_int1(int irq, void *dev_id, struct pt_regs *fp)
+static irqreturn_t ami_int1(int irq, void *dev_id)
 {
 	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 
 	/* if serial transmit buffer empty, interrupt */
 	if (ints & IF_TBE) {
 		amiga_custom.intreq = IF_TBE;
-		m68k_handle_int(IRQ_AMIGA_TBE, fp);
+		m68k_handle_int(IRQ_AMIGA_TBE);
 	}
 
 	/* if floppy disk transfer complete, interrupt */
 	if (ints & IF_DSKBLK) {
 		amiga_custom.intreq = IF_DSKBLK;
-		m68k_handle_int(IRQ_AMIGA_DSKBLK, fp);
+		m68k_handle_int(IRQ_AMIGA_DSKBLK);
 	}
 
 	/* if software interrupt set, interrupt */
 	if (ints & IF_SOFT) {
 		amiga_custom.intreq = IF_SOFT;
-		m68k_handle_int(IRQ_AMIGA_SOFT, fp);
+		m68k_handle_int(IRQ_AMIGA_SOFT);
 	}
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t ami_int3(int irq, void *dev_id, struct pt_regs *fp)
+static irqreturn_t ami_int3(int irq, void *dev_id)
 {
 	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 
 	/* if a blitter interrupt */
 	if (ints & IF_BLIT) {
 		amiga_custom.intreq = IF_BLIT;
-		m68k_handle_int(IRQ_AMIGA_BLIT, fp);
+		m68k_handle_int(IRQ_AMIGA_BLIT);
 	}
 
 	/* if a copper interrupt */
 	if (ints & IF_COPER) {
 		amiga_custom.intreq = IF_COPER;
-		m68k_handle_int(IRQ_AMIGA_COPPER, fp);
+		m68k_handle_int(IRQ_AMIGA_COPPER);
 	}
 
 	/* if a vertical blank interrupt */
 	if (ints & IF_VERTB) {
 		amiga_custom.intreq = IF_VERTB;
-		m68k_handle_int(IRQ_AMIGA_VERTB, fp);
+		m68k_handle_int(IRQ_AMIGA_VERTB);
 	}
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t ami_int4(int irq, void *dev_id, struct pt_regs *fp)
+static irqreturn_t ami_int4(int irq, void *dev_id)
 {
 	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 
 	/* if audio 0 interrupt */
 	if (ints & IF_AUD0) {
 		amiga_custom.intreq = IF_AUD0;
-		m68k_handle_int(IRQ_AMIGA_AUD0, fp);
+		m68k_handle_int(IRQ_AMIGA_AUD0);
 	}
 
 	/* if audio 1 interrupt */
 	if (ints & IF_AUD1) {
 		amiga_custom.intreq = IF_AUD1;
-		m68k_handle_int(IRQ_AMIGA_AUD1, fp);
+		m68k_handle_int(IRQ_AMIGA_AUD1);
 	}
 
 	/* if audio 2 interrupt */
 	if (ints & IF_AUD2) {
 		amiga_custom.intreq = IF_AUD2;
-		m68k_handle_int(IRQ_AMIGA_AUD2, fp);
+		m68k_handle_int(IRQ_AMIGA_AUD2);
 	}
 
 	/* if audio 3 interrupt */
 	if (ints & IF_AUD3) {
 		amiga_custom.intreq = IF_AUD3;
-		m68k_handle_int(IRQ_AMIGA_AUD3, fp);
+		m68k_handle_int(IRQ_AMIGA_AUD3);
 	}
 	return IRQ_HANDLED;
 }
 
-static irqreturn_t ami_int5(int irq, void *dev_id, struct pt_regs *fp)
+static irqreturn_t ami_int5(int irq, void *dev_id)
 {
 	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 
 	/* if serial receive buffer full interrupt */
 	if (ints & IF_RBF) {
 		/* acknowledge of IF_RBF must be done by the serial interrupt */
-		m68k_handle_int(IRQ_AMIGA_RBF, fp);
+		m68k_handle_int(IRQ_AMIGA_RBF);
 	}
 
 	/* if a disk sync interrupt */
 	if (ints & IF_DSKSYN) {
 		amiga_custom.intreq = IF_DSKSYN;
-		m68k_handle_int(IRQ_AMIGA_DSKSYN, fp);
+		m68k_handle_int(IRQ_AMIGA_DSKSYN);
 	}
 	return IRQ_HANDLED;
 }

commit b0b9fdc123cf0f1b671ac3f593d77af325ad4cf3
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:19 2006 -0700

    [PATCH] irq-flags: M68K: Use the new IRQF_ constants
    
    Use the new IRQF_ constants and remove the SA_INTERRUPT define
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index f9403f4640a1..96c79d840cff 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -22,7 +22,7 @@
  *
  * 07/08/99: rewamp of the interrupt handling - we now have two types of
  *           interrupts, normal and fast handlers, fast handlers being
- *           marked with SA_INTERRUPT and runs with all other interrupts
+ *           marked with IRQF_DISABLED and runs with all other interrupts
  *           disabled. Normal interrupts disable their own source but
  *           run with all other interrupt sources enabled.
  *           PORTS and EXTER interrupts are always shared even if the

commit 74be8d0835f91f0f77a2f1554dfa7242f1f7b652
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:01 2006 -0700

    [PATCH] m68k: convert amiga irq code
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index e2d47b7bdfc1..f9403f4640a1 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -35,62 +35,30 @@
  *           /Jes
  */
 
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/sched.h>
-#include <linux/kernel_stat.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/errno.h>
-#include <linux/seq_file.h>
 
-#include <asm/system.h>
 #include <asm/irq.h>
 #include <asm/traps.h>
 #include <asm/amigahw.h>
 #include <asm/amigaints.h>
 #include <asm/amipcmcia.h>
 
-extern int cia_request_irq(struct ciabase *base,int irq,
-                           irqreturn_t (*handler)(int, void *, struct pt_regs *),
-                           unsigned long flags, const char *devname, void *dev_id);
-extern void cia_free_irq(struct ciabase *base, unsigned int irq, void *dev_id);
-extern void cia_init_IRQ(struct ciabase *base);
-extern int cia_get_irq_list(struct ciabase *base, struct seq_file *p);
-
-/* irq node variables for amiga interrupt sources */
-static irq_node_t *ami_irq_list[AMI_STD_IRQS];
-
-static unsigned short amiga_intena_vals[AMI_STD_IRQS] = {
-	[IRQ_AMIGA_VERTB-IRQ_USER]	= IF_VERTB,
-	[IRQ_AMIGA_COPPER-IRQ_USER]	= IF_COPER,
-	[IRQ_AMIGA_AUD0-IRQ_USER]	= IF_AUD0,
-	[IRQ_AMIGA_AUD1-IRQ_USER]	= IF_AUD1,
-	[IRQ_AMIGA_AUD2-IRQ_USER]	= IF_AUD2,
-	[IRQ_AMIGA_AUD3-IRQ_USER]	= IF_AUD3,
-	[IRQ_AMIGA_BLIT-IRQ_USER]	= IF_BLIT,
-	[IRQ_AMIGA_DSKSYN-IRQ_USER]	= IF_DSKSYN,
-	[IRQ_AMIGA_DSKBLK-IRQ_USER]	= IF_DSKBLK,
-	[IRQ_AMIGA_RBF-IRQ_USER]	= IF_RBF,
-	[IRQ_AMIGA_TBE-IRQ_USER]	= IF_TBE,
-	[IRQ_AMIGA_SOFT-IRQ_USER]	= IF_SOFT,
-	[IRQ_AMIGA_PORTS-IRQ_USER]	= IF_PORTS,
-	[IRQ_AMIGA_EXTER-IRQ_USER]	= IF_EXTER
-};
-static const unsigned char ami_servers[AMI_STD_IRQS] = {
-	[IRQ_AMIGA_VERTB-IRQ_USER]	= 1,
-	[IRQ_AMIGA_PORTS-IRQ_USER]	= 1,
-	[IRQ_AMIGA_EXTER-IRQ_USER]	= 1
+static void amiga_enable_irq(unsigned int irq);
+static void amiga_disable_irq(unsigned int irq);
+static irqreturn_t ami_int1(int irq, void *dev_id, struct pt_regs *fp);
+static irqreturn_t ami_int3(int irq, void *dev_id, struct pt_regs *fp);
+static irqreturn_t ami_int4(int irq, void *dev_id, struct pt_regs *fp);
+static irqreturn_t ami_int5(int irq, void *dev_id, struct pt_regs *fp);
+
+static struct irq_controller amiga_irq_controller = {
+	.name		= "amiga",
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.enable		= amiga_enable_irq,
+	.disable	= amiga_disable_irq,
 };
 
-static short ami_ablecount[AMI_IRQS];
-
-static irqreturn_t ami_badint(int irq, void *dev_id, struct pt_regs *fp)
-{
-	num_spurious += 1;
-	return IRQ_NONE;
-}
-
 /*
  * void amiga_init_IRQ(void)
  *
@@ -104,23 +72,12 @@ static irqreturn_t ami_badint(int irq, void *dev_id, struct pt_regs *fp)
 
 void __init amiga_init_IRQ(void)
 {
-	int i;
+	request_irq(IRQ_AUTO_1, ami_int1, 0, "int1", NULL);
+	request_irq(IRQ_AUTO_3, ami_int3, 0, "int3", NULL);
+	request_irq(IRQ_AUTO_4, ami_int4, 0, "int4", NULL);
+	request_irq(IRQ_AUTO_5, ami_int5, 0, "int5", NULL);
 
-	/* initialize handlers */
-	for (i = 0; i < AMI_STD_IRQS; i++) {
-		if (ami_servers[i]) {
-			ami_irq_list[i] = NULL;
-		} else {
-			ami_irq_list[i] = new_irq_node();
-			ami_irq_list[i]->handler = ami_badint;
-			ami_irq_list[i]->flags   = 0;
-			ami_irq_list[i]->dev_id  = NULL;
-			ami_irq_list[i]->devname = NULL;
-			ami_irq_list[i]->next    = NULL;
-		}
-	}
-	for (i = 0; i < AMI_IRQS; i++)
-		ami_ablecount[i] = 0;
+	m68k_setup_irq_controller(&amiga_irq_controller, IRQ_USER, AMI_STD_IRQS);
 
 	/* turn off PCMCIA interrupts */
 	if (AMIGAHW_PRESENT(PCMCIA))
@@ -135,250 +92,21 @@ void __init amiga_init_IRQ(void)
 	cia_init_IRQ(&ciab_base);
 }
 
-static inline int amiga_insert_irq(irq_node_t **list, irq_node_t *node)
-{
-	unsigned long flags;
-	irq_node_t *cur;
-
-	if (!node->dev_id)
-		printk("%s: Warning: dev_id of %s is zero\n",
-		       __FUNCTION__, node->devname);
-
-	local_irq_save(flags);
-
-	cur = *list;
-
-	if (node->flags & SA_INTERRUPT) {
-		if (node->flags & SA_SHIRQ)
-			return -EBUSY;
-		/*
-		 * There should never be more than one
-		 */
-		while (cur && cur->flags & SA_INTERRUPT) {
-			list = &cur->next;
-			cur = cur->next;
-		}
-	} else {
-		while (cur) {
-			list = &cur->next;
-			cur = cur->next;
-		}
-	}
-
-	node->next = cur;
-	*list = node;
-
-	local_irq_restore(flags);
-	return 0;
-}
-
-static inline void amiga_delete_irq(irq_node_t **list, void *dev_id)
-{
-	unsigned long flags;
-	irq_node_t *node;
-
-	local_irq_save(flags);
-
-	for (node = *list; node; list = &node->next, node = *list) {
-		if (node->dev_id == dev_id) {
-			*list = node->next;
-			/* Mark it as free. */
-			node->handler = NULL;
-			local_irq_restore(flags);
-			return;
-		}
-	}
-	local_irq_restore(flags);
-	printk ("%s: tried to remove invalid irq\n", __FUNCTION__);
-}
-
-/*
- * amiga_request_irq : add an interrupt service routine for a particular
- *                     machine specific interrupt source.
- *                     If the addition was successful, it returns 0.
- */
-
-int amiga_request_irq(unsigned int irq,
-		      irqreturn_t (*handler)(int, void *, struct pt_regs *),
-                      unsigned long flags, const char *devname, void *dev_id)
-{
-	irq_node_t *node;
-	int error = 0;
-
-	if (irq >= AMI_IRQS) {
-		printk ("%s: Unknown IRQ %d from %s\n", __FUNCTION__,
-			irq, devname);
-		return -ENXIO;
-	}
-
-	if (irq < IRQ_USER)
-		return cpu_request_irq(irq, handler, flags, devname, dev_id);
-
-	if (irq >= IRQ_AMIGA_CIAB)
-		return cia_request_irq(&ciab_base, irq - IRQ_AMIGA_CIAB,
-		                       handler, flags, devname, dev_id);
-
-	if (irq >= IRQ_AMIGA_CIAA)
-		return cia_request_irq(&ciaa_base, irq - IRQ_AMIGA_CIAA,
-		                       handler, flags, devname, dev_id);
-
-	irq -= IRQ_USER;
-	/*
-	 * IRQ_AMIGA_PORTS & IRQ_AMIGA_EXTER defaults to shared,
-	 * we could add a check here for the SA_SHIRQ flag but all drivers
-	 * should be aware of sharing anyway.
-	 */
-	if (ami_servers[irq]) {
-		if (!(node = new_irq_node()))
-			return -ENOMEM;
-		node->handler = handler;
-		node->flags   = flags;
-		node->dev_id  = dev_id;
-		node->devname = devname;
-		node->next    = NULL;
-		error = amiga_insert_irq(&ami_irq_list[irq], node);
-	} else {
-		ami_irq_list[irq]->handler = handler;
-		ami_irq_list[irq]->flags   = flags;
-		ami_irq_list[irq]->dev_id  = dev_id;
-		ami_irq_list[irq]->devname = devname;
-	}
-
-	/* enable the interrupt */
-	if (irq < IRQ_AMIGA_PORTS && !ami_ablecount[irq])
-		amiga_custom.intena = IF_SETCLR | amiga_intena_vals[irq];
-
-	return error;
-}
-
-void amiga_free_irq(unsigned int irq, void *dev_id)
-{
-	if (irq >= AMI_IRQS) {
-		printk ("%s: Unknown IRQ %d\n", __FUNCTION__, irq);
-		return;
-	}
-
-	if (irq < IRQ_USER)
-		cpu_free_irq(irq, dev_id);
-
-	if (irq >= IRQ_AMIGA_CIAB) {
-		cia_free_irq(&ciab_base, irq - IRQ_AMIGA_CIAB, dev_id);
-		return;
-	}
-
-	if (irq >= IRQ_AMIGA_CIAA) {
-		cia_free_irq(&ciaa_base, irq - IRQ_AMIGA_CIAA, dev_id);
-		return;
-	}
-
-	irq -= IRQ_USER;
-	if (ami_servers[irq]) {
-		amiga_delete_irq(&ami_irq_list[irq], dev_id);
-		/* if server list empty, disable the interrupt */
-		if (!ami_irq_list[irq] && irq < IRQ_AMIGA_PORTS)
-			amiga_custom.intena = amiga_intena_vals[irq];
-	} else {
-		if (ami_irq_list[irq]->dev_id != dev_id)
-			printk("%s: removing probably wrong IRQ %d from %s\n",
-			       __FUNCTION__, irq, ami_irq_list[irq]->devname);
-		ami_irq_list[irq]->handler = ami_badint;
-		ami_irq_list[irq]->flags   = 0;
-		ami_irq_list[irq]->dev_id  = NULL;
-		ami_irq_list[irq]->devname = NULL;
-		amiga_custom.intena = amiga_intena_vals[irq];
-	}
-}
-
 /*
  * Enable/disable a particular machine specific interrupt source.
  * Note that this may affect other interrupts in case of a shared interrupt.
  * This function should only be called for a _very_ short time to change some
  * internal data, that may not be changed by the interrupt at the same time.
- * ami_(enable|disable)_irq calls may also be nested.
  */
 
-void amiga_enable_irq(unsigned int irq)
-{
-	if (irq >= AMI_IRQS) {
-		printk("%s: Unknown IRQ %d\n", __FUNCTION__, irq);
-		return;
-	}
-
-	if (--ami_ablecount[irq])
-		return;
-
-	/* No action for auto-vector interrupts */
-	if (irq < IRQ_USER) {
-		printk("%s: Trying to enable auto-vector IRQ %i\n",
-		       __FUNCTION__, irq);
-		return;
-	}
-
-	if (irq >= IRQ_AMIGA_CIAB) {
-		cia_set_irq(&ciab_base, (1 << (irq - IRQ_AMIGA_CIAB)));
-		cia_able_irq(&ciab_base, CIA_ICR_SETCLR |
-		             (1 << (irq - IRQ_AMIGA_CIAB)));
-		return;
-	}
-
-	if (irq >= IRQ_AMIGA_CIAA) {
-		cia_set_irq(&ciaa_base, (1 << (irq - IRQ_AMIGA_CIAA)));
-		cia_able_irq(&ciaa_base, CIA_ICR_SETCLR |
-		             (1 << (irq - IRQ_AMIGA_CIAA)));
-		return;
-	}
-
-	/* enable the interrupt */
-	amiga_custom.intena = IF_SETCLR | amiga_intena_vals[irq-IRQ_USER];
-}
-
-void amiga_disable_irq(unsigned int irq)
-{
-	if (irq >= AMI_IRQS) {
-		printk("%s: Unknown IRQ %d\n", __FUNCTION__, irq);
-		return;
-	}
-
-	if (ami_ablecount[irq]++)
-		return;
-
-	/* No action for auto-vector interrupts */
-	if (irq < IRQ_USER) {
-		printk("%s: Trying to disable auto-vector IRQ %i\n",
-		       __FUNCTION__, irq);
-		return;
-	}
-
-	if (irq >= IRQ_AMIGA_CIAB) {
-		cia_able_irq(&ciab_base, 1 << (irq - IRQ_AMIGA_CIAB));
-		return;
-	}
-
-	if (irq >= IRQ_AMIGA_CIAA) {
-		cia_able_irq(&ciaa_base, 1 << (irq - IRQ_AMIGA_CIAA));
-		return;
-	}
-
-	/* disable the interrupt */
-	amiga_custom.intena = amiga_intena_vals[irq-IRQ_USER];
-}
-
-inline void amiga_do_irq(int irq, struct pt_regs *fp)
+static void amiga_enable_irq(unsigned int irq)
 {
-	kstat_cpu(0).irqs[irq]++;
-	ami_irq_list[irq-IRQ_USER]->handler(irq, ami_irq_list[irq-IRQ_USER]->dev_id, fp);
+	amiga_custom.intena = IF_SETCLR | (1 << (irq - IRQ_USER));
 }
 
-void amiga_do_irq_list(int irq, struct pt_regs *fp)
+static void amiga_disable_irq(unsigned int irq)
 {
-	irq_node_t *node;
-
-	kstat_cpu(0).irqs[irq]++;
-
-	amiga_custom.intreq = amiga_intena_vals[irq-IRQ_USER];
-
-	for (node = ami_irq_list[irq-IRQ_USER]; node; node = node->next)
-		node->handler(irq, node->dev_id, fp);
+	amiga_custom.intena = 1 << (irq - IRQ_USER);
 }
 
 /*
@@ -392,19 +120,19 @@ static irqreturn_t ami_int1(int irq, void *dev_id, struct pt_regs *fp)
 	/* if serial transmit buffer empty, interrupt */
 	if (ints & IF_TBE) {
 		amiga_custom.intreq = IF_TBE;
-		amiga_do_irq(IRQ_AMIGA_TBE, fp);
+		m68k_handle_int(IRQ_AMIGA_TBE, fp);
 	}
 
 	/* if floppy disk transfer complete, interrupt */
 	if (ints & IF_DSKBLK) {
 		amiga_custom.intreq = IF_DSKBLK;
-		amiga_do_irq(IRQ_AMIGA_DSKBLK, fp);
+		m68k_handle_int(IRQ_AMIGA_DSKBLK, fp);
 	}
 
 	/* if software interrupt set, interrupt */
 	if (ints & IF_SOFT) {
 		amiga_custom.intreq = IF_SOFT;
-		amiga_do_irq(IRQ_AMIGA_SOFT, fp);
+		m68k_handle_int(IRQ_AMIGA_SOFT, fp);
 	}
 	return IRQ_HANDLED;
 }
@@ -416,18 +144,20 @@ static irqreturn_t ami_int3(int irq, void *dev_id, struct pt_regs *fp)
 	/* if a blitter interrupt */
 	if (ints & IF_BLIT) {
 		amiga_custom.intreq = IF_BLIT;
-		amiga_do_irq(IRQ_AMIGA_BLIT, fp);
+		m68k_handle_int(IRQ_AMIGA_BLIT, fp);
 	}
 
 	/* if a copper interrupt */
 	if (ints & IF_COPER) {
 		amiga_custom.intreq = IF_COPER;
-		amiga_do_irq(IRQ_AMIGA_COPPER, fp);
+		m68k_handle_int(IRQ_AMIGA_COPPER, fp);
 	}
 
 	/* if a vertical blank interrupt */
-	if (ints & IF_VERTB)
-		amiga_do_irq_list(IRQ_AMIGA_VERTB, fp);
+	if (ints & IF_VERTB) {
+		amiga_custom.intreq = IF_VERTB;
+		m68k_handle_int(IRQ_AMIGA_VERTB, fp);
+	}
 	return IRQ_HANDLED;
 }
 
@@ -438,25 +168,25 @@ static irqreturn_t ami_int4(int irq, void *dev_id, struct pt_regs *fp)
 	/* if audio 0 interrupt */
 	if (ints & IF_AUD0) {
 		amiga_custom.intreq = IF_AUD0;
-		amiga_do_irq(IRQ_AMIGA_AUD0, fp);
+		m68k_handle_int(IRQ_AMIGA_AUD0, fp);
 	}
 
 	/* if audio 1 interrupt */
 	if (ints & IF_AUD1) {
 		amiga_custom.intreq = IF_AUD1;
-		amiga_do_irq(IRQ_AMIGA_AUD1, fp);
+		m68k_handle_int(IRQ_AMIGA_AUD1, fp);
 	}
 
 	/* if audio 2 interrupt */
 	if (ints & IF_AUD2) {
 		amiga_custom.intreq = IF_AUD2;
-		amiga_do_irq(IRQ_AMIGA_AUD2, fp);
+		m68k_handle_int(IRQ_AMIGA_AUD2, fp);
 	}
 
 	/* if audio 3 interrupt */
 	if (ints & IF_AUD3) {
 		amiga_custom.intreq = IF_AUD3;
-		amiga_do_irq(IRQ_AMIGA_AUD3, fp);
+		m68k_handle_int(IRQ_AMIGA_AUD3, fp);
 	}
 	return IRQ_HANDLED;
 }
@@ -468,53 +198,13 @@ static irqreturn_t ami_int5(int irq, void *dev_id, struct pt_regs *fp)
 	/* if serial receive buffer full interrupt */
 	if (ints & IF_RBF) {
 		/* acknowledge of IF_RBF must be done by the serial interrupt */
-		amiga_do_irq(IRQ_AMIGA_RBF, fp);
+		m68k_handle_int(IRQ_AMIGA_RBF, fp);
 	}
 
 	/* if a disk sync interrupt */
 	if (ints & IF_DSKSYN) {
 		amiga_custom.intreq = IF_DSKSYN;
-		amiga_do_irq(IRQ_AMIGA_DSKSYN, fp);
+		m68k_handle_int(IRQ_AMIGA_DSKSYN, fp);
 	}
 	return IRQ_HANDLED;
 }
-
-static irqreturn_t ami_int7(int irq, void *dev_id, struct pt_regs *fp)
-{
-	panic ("level 7 interrupt received\n");
-}
-
-irqreturn_t (*amiga_default_handler[SYS_IRQS])(int, void *, struct pt_regs *) = {
-	[1] = ami_int1,
-	[3] = ami_int3,
-	[4] = ami_int4,
-	[5] = ami_int5,
-	[7] = ami_int7
-};
-
-int show_amiga_interrupts(struct seq_file *p, void *v)
-{
-	int i;
-	irq_node_t *node;
-
-	for (i = IRQ_USER; i < IRQ_AMIGA_CIAA; i++) {
-		node = ami_irq_list[i - IRQ_USER];
-		if (!node)
-			continue;
-		seq_printf(p, "ami  %2d: %10u ", i,
-		               kstat_cpu(0).irqs[i]);
-		do {
-			if (node->flags & SA_INTERRUPT)
-				seq_puts(p, "F ");
-			else
-				seq_puts(p, "  ");
-			seq_printf(p, "%s\n", node->devname);
-			if ((node = node->next))
-				seq_puts(p, "                    ");
-		} while (node);
-	}
-
-	cia_get_irq_list(&ciaa_base, p);
-	cia_get_irq_list(&ciab_base, p);
-	return 0;
-}

commit b5dc7840b3ebe9c7967dd8ba73db957767009ff9
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:00 2006 -0700

    [PATCH] m68k: introduce irq controller
    
    Introduce irq controller and use it to manage auto vector interrupts.
    Introduce setup_irq() which can be used for irq setup.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index d02458ebd345..e2d47b7bdfc1 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -40,6 +40,7 @@
 #include <linux/sched.h>
 #include <linux/kernel_stat.h>
 #include <linux/init.h>
+#include <linux/interrupt.h>
 #include <linux/errno.h>
 #include <linux/seq_file.h>
 
@@ -484,13 +485,10 @@ static irqreturn_t ami_int7(int irq, void *dev_id, struct pt_regs *fp)
 }
 
 irqreturn_t (*amiga_default_handler[SYS_IRQS])(int, void *, struct pt_regs *) = {
-	[0] = ami_badint,
 	[1] = ami_int1,
-	[2] = ami_badint,
 	[3] = ami_int3,
 	[4] = ami_int4,
 	[5] = ami_int5,
-	[6] = ami_badint,
 	[7] = ami_int7
 };
 

commit 1d174cfb0f2a8967433e157bae9c2d4dcdee5324
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:00 2006 -0700

    [PATCH] m68k: cleanup amiga irq numbering
    
    Fix amiga irq numbering, so they are after the generic IRQ_AUTO defines and
    remove the IRQ_AMIGA_AUTO defines.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index b0aa61bf8700..d02458ebd345 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -61,25 +61,25 @@ extern int cia_get_irq_list(struct ciabase *base, struct seq_file *p);
 static irq_node_t *ami_irq_list[AMI_STD_IRQS];
 
 static unsigned short amiga_intena_vals[AMI_STD_IRQS] = {
-	[IRQ_AMIGA_VERTB]	= IF_VERTB,
-	[IRQ_AMIGA_COPPER]	= IF_COPER,
-	[IRQ_AMIGA_AUD0]	= IF_AUD0,
-	[IRQ_AMIGA_AUD1]	= IF_AUD1,
-	[IRQ_AMIGA_AUD2]	= IF_AUD2,
-	[IRQ_AMIGA_AUD3]	= IF_AUD3,
-	[IRQ_AMIGA_BLIT]	= IF_BLIT,
-	[IRQ_AMIGA_DSKSYN]	= IF_DSKSYN,
-	[IRQ_AMIGA_DSKBLK]	= IF_DSKBLK,
-	[IRQ_AMIGA_RBF]		= IF_RBF,
-	[IRQ_AMIGA_TBE]		= IF_TBE,
-	[IRQ_AMIGA_SOFT]	= IF_SOFT,
-	[IRQ_AMIGA_PORTS]	= IF_PORTS,
-	[IRQ_AMIGA_EXTER]	= IF_EXTER
+	[IRQ_AMIGA_VERTB-IRQ_USER]	= IF_VERTB,
+	[IRQ_AMIGA_COPPER-IRQ_USER]	= IF_COPER,
+	[IRQ_AMIGA_AUD0-IRQ_USER]	= IF_AUD0,
+	[IRQ_AMIGA_AUD1-IRQ_USER]	= IF_AUD1,
+	[IRQ_AMIGA_AUD2-IRQ_USER]	= IF_AUD2,
+	[IRQ_AMIGA_AUD3-IRQ_USER]	= IF_AUD3,
+	[IRQ_AMIGA_BLIT-IRQ_USER]	= IF_BLIT,
+	[IRQ_AMIGA_DSKSYN-IRQ_USER]	= IF_DSKSYN,
+	[IRQ_AMIGA_DSKBLK-IRQ_USER]	= IF_DSKBLK,
+	[IRQ_AMIGA_RBF-IRQ_USER]	= IF_RBF,
+	[IRQ_AMIGA_TBE-IRQ_USER]	= IF_TBE,
+	[IRQ_AMIGA_SOFT-IRQ_USER]	= IF_SOFT,
+	[IRQ_AMIGA_PORTS-IRQ_USER]	= IF_PORTS,
+	[IRQ_AMIGA_EXTER-IRQ_USER]	= IF_EXTER
 };
 static const unsigned char ami_servers[AMI_STD_IRQS] = {
-	[IRQ_AMIGA_VERTB]	= 1,
-	[IRQ_AMIGA_PORTS]	= 1,
-	[IRQ_AMIGA_EXTER]	= 1
+	[IRQ_AMIGA_VERTB-IRQ_USER]	= 1,
+	[IRQ_AMIGA_PORTS-IRQ_USER]	= 1,
+	[IRQ_AMIGA_EXTER-IRQ_USER]	= 1
 };
 
 static short ami_ablecount[AMI_IRQS];
@@ -210,9 +210,8 @@ int amiga_request_irq(unsigned int irq,
 		return -ENXIO;
 	}
 
-	if (irq >= IRQ_AMIGA_AUTO)
-		return cpu_request_irq(irq - IRQ_AMIGA_AUTO, handler,
-		                       flags, devname, dev_id);
+	if (irq < IRQ_USER)
+		return cpu_request_irq(irq, handler, flags, devname, dev_id);
 
 	if (irq >= IRQ_AMIGA_CIAB)
 		return cia_request_irq(&ciab_base, irq - IRQ_AMIGA_CIAB,
@@ -222,6 +221,7 @@ int amiga_request_irq(unsigned int irq,
 		return cia_request_irq(&ciaa_base, irq - IRQ_AMIGA_CIAA,
 		                       handler, flags, devname, dev_id);
 
+	irq -= IRQ_USER;
 	/*
 	 * IRQ_AMIGA_PORTS & IRQ_AMIGA_EXTER defaults to shared,
 	 * we could add a check here for the SA_SHIRQ flag but all drivers
@@ -257,8 +257,8 @@ void amiga_free_irq(unsigned int irq, void *dev_id)
 		return;
 	}
 
-	if (irq >= IRQ_AMIGA_AUTO)
-		cpu_free_irq(irq - IRQ_AMIGA_AUTO, dev_id);
+	if (irq < IRQ_USER)
+		cpu_free_irq(irq, dev_id);
 
 	if (irq >= IRQ_AMIGA_CIAB) {
 		cia_free_irq(&ciab_base, irq - IRQ_AMIGA_CIAB, dev_id);
@@ -270,6 +270,7 @@ void amiga_free_irq(unsigned int irq, void *dev_id)
 		return;
 	}
 
+	irq -= IRQ_USER;
 	if (ami_servers[irq]) {
 		amiga_delete_irq(&ami_irq_list[irq], dev_id);
 		/* if server list empty, disable the interrupt */
@@ -306,9 +307,9 @@ void amiga_enable_irq(unsigned int irq)
 		return;
 
 	/* No action for auto-vector interrupts */
-	if (irq >= IRQ_AMIGA_AUTO){
+	if (irq < IRQ_USER) {
 		printk("%s: Trying to enable auto-vector IRQ %i\n",
-		       __FUNCTION__, irq - IRQ_AMIGA_AUTO);
+		       __FUNCTION__, irq);
 		return;
 	}
 
@@ -327,7 +328,7 @@ void amiga_enable_irq(unsigned int irq)
 	}
 
 	/* enable the interrupt */
-	amiga_custom.intena = IF_SETCLR | amiga_intena_vals[irq];
+	amiga_custom.intena = IF_SETCLR | amiga_intena_vals[irq-IRQ_USER];
 }
 
 void amiga_disable_irq(unsigned int irq)
@@ -341,9 +342,9 @@ void amiga_disable_irq(unsigned int irq)
 		return;
 
 	/* No action for auto-vector interrupts */
-	if (irq >= IRQ_AMIGA_AUTO) {
+	if (irq < IRQ_USER) {
 		printk("%s: Trying to disable auto-vector IRQ %i\n",
-		       __FUNCTION__, irq - IRQ_AMIGA_AUTO);
+		       __FUNCTION__, irq);
 		return;
 	}
 
@@ -358,24 +359,24 @@ void amiga_disable_irq(unsigned int irq)
 	}
 
 	/* disable the interrupt */
-	amiga_custom.intena = amiga_intena_vals[irq];
+	amiga_custom.intena = amiga_intena_vals[irq-IRQ_USER];
 }
 
 inline void amiga_do_irq(int irq, struct pt_regs *fp)
 {
-	kstat_cpu(0).irqs[SYS_IRQS + irq]++;
-	ami_irq_list[irq]->handler(irq, ami_irq_list[irq]->dev_id, fp);
+	kstat_cpu(0).irqs[irq]++;
+	ami_irq_list[irq-IRQ_USER]->handler(irq, ami_irq_list[irq-IRQ_USER]->dev_id, fp);
 }
 
 void amiga_do_irq_list(int irq, struct pt_regs *fp)
 {
 	irq_node_t *node;
 
-	kstat_cpu(0).irqs[SYS_IRQS + irq]++;
+	kstat_cpu(0).irqs[irq]++;
 
-	amiga_custom.intreq = amiga_intena_vals[irq];
+	amiga_custom.intreq = amiga_intena_vals[irq-IRQ_USER];
 
-	for (node = ami_irq_list[irq]; node; node = node->next)
+	for (node = ami_irq_list[irq-IRQ_USER]; node; node = node->next)
 		node->handler(irq, node->dev_id, fp);
 }
 
@@ -498,11 +499,12 @@ int show_amiga_interrupts(struct seq_file *p, void *v)
 	int i;
 	irq_node_t *node;
 
-	for (i = 0; i < AMI_STD_IRQS; i++) {
-		if (!(node = ami_irq_list[i]))
+	for (i = IRQ_USER; i < IRQ_AMIGA_CIAA; i++) {
+		node = ami_irq_list[i - IRQ_USER];
+		if (!node)
 			continue;
 		seq_printf(p, "ami  %2d: %10u ", i,
-		               kstat_cpu(0).irqs[SYS_IRQS + i]);
+		               kstat_cpu(0).irqs[i]);
 		do {
 			if (node->flags & SA_INTERRUPT)
 				seq_puts(p, "F ");

commit b4290a23cfa9040e2f0de5ab57d6ea65abaf053b
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jan 12 01:06:12 2006 -0800

    [PATCH] m68k: namespace pollution fix (custom->amiga_custom)
    
    in amigahw.h custom renamed to amiga_custom, in drivers with few instances the
    same replacement, in the rest - #define custom amiga_custom in driver itself
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
index d9edf2d1a492..b0aa61bf8700 100644
--- a/arch/m68k/amiga/amiints.c
+++ b/arch/m68k/amiga/amiints.c
@@ -126,9 +126,9 @@ void __init amiga_init_IRQ(void)
 		gayle.inten = GAYLE_IRQ_IDE;
 
 	/* turn off all interrupts and enable the master interrupt bit */
-	custom.intena = 0x7fff;
-	custom.intreq = 0x7fff;
-	custom.intena = IF_SETCLR | IF_INTEN;
+	amiga_custom.intena = 0x7fff;
+	amiga_custom.intreq = 0x7fff;
+	amiga_custom.intena = IF_SETCLR | IF_INTEN;
 
 	cia_init_IRQ(&ciaa_base);
 	cia_init_IRQ(&ciab_base);
@@ -245,7 +245,7 @@ int amiga_request_irq(unsigned int irq,
 
 	/* enable the interrupt */
 	if (irq < IRQ_AMIGA_PORTS && !ami_ablecount[irq])
-		custom.intena = IF_SETCLR | amiga_intena_vals[irq];
+		amiga_custom.intena = IF_SETCLR | amiga_intena_vals[irq];
 
 	return error;
 }
@@ -274,7 +274,7 @@ void amiga_free_irq(unsigned int irq, void *dev_id)
 		amiga_delete_irq(&ami_irq_list[irq], dev_id);
 		/* if server list empty, disable the interrupt */
 		if (!ami_irq_list[irq] && irq < IRQ_AMIGA_PORTS)
-			custom.intena = amiga_intena_vals[irq];
+			amiga_custom.intena = amiga_intena_vals[irq];
 	} else {
 		if (ami_irq_list[irq]->dev_id != dev_id)
 			printk("%s: removing probably wrong IRQ %d from %s\n",
@@ -283,7 +283,7 @@ void amiga_free_irq(unsigned int irq, void *dev_id)
 		ami_irq_list[irq]->flags   = 0;
 		ami_irq_list[irq]->dev_id  = NULL;
 		ami_irq_list[irq]->devname = NULL;
-		custom.intena = amiga_intena_vals[irq];
+		amiga_custom.intena = amiga_intena_vals[irq];
 	}
 }
 
@@ -327,7 +327,7 @@ void amiga_enable_irq(unsigned int irq)
 	}
 
 	/* enable the interrupt */
-	custom.intena = IF_SETCLR | amiga_intena_vals[irq];
+	amiga_custom.intena = IF_SETCLR | amiga_intena_vals[irq];
 }
 
 void amiga_disable_irq(unsigned int irq)
@@ -358,7 +358,7 @@ void amiga_disable_irq(unsigned int irq)
 	}
 
 	/* disable the interrupt */
-	custom.intena = amiga_intena_vals[irq];
+	amiga_custom.intena = amiga_intena_vals[irq];
 }
 
 inline void amiga_do_irq(int irq, struct pt_regs *fp)
@@ -373,7 +373,7 @@ void amiga_do_irq_list(int irq, struct pt_regs *fp)
 
 	kstat_cpu(0).irqs[SYS_IRQS + irq]++;
 
-	custom.intreq = amiga_intena_vals[irq];
+	amiga_custom.intreq = amiga_intena_vals[irq];
 
 	for (node = ami_irq_list[irq]; node; node = node->next)
 		node->handler(irq, node->dev_id, fp);
@@ -385,23 +385,23 @@ void amiga_do_irq_list(int irq, struct pt_regs *fp)
 
 static irqreturn_t ami_int1(int irq, void *dev_id, struct pt_regs *fp)
 {
-	unsigned short ints = custom.intreqr & custom.intenar;
+	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 
 	/* if serial transmit buffer empty, interrupt */
 	if (ints & IF_TBE) {
-		custom.intreq = IF_TBE;
+		amiga_custom.intreq = IF_TBE;
 		amiga_do_irq(IRQ_AMIGA_TBE, fp);
 	}
 
 	/* if floppy disk transfer complete, interrupt */
 	if (ints & IF_DSKBLK) {
-		custom.intreq = IF_DSKBLK;
+		amiga_custom.intreq = IF_DSKBLK;
 		amiga_do_irq(IRQ_AMIGA_DSKBLK, fp);
 	}
 
 	/* if software interrupt set, interrupt */
 	if (ints & IF_SOFT) {
-		custom.intreq = IF_SOFT;
+		amiga_custom.intreq = IF_SOFT;
 		amiga_do_irq(IRQ_AMIGA_SOFT, fp);
 	}
 	return IRQ_HANDLED;
@@ -409,17 +409,17 @@ static irqreturn_t ami_int1(int irq, void *dev_id, struct pt_regs *fp)
 
 static irqreturn_t ami_int3(int irq, void *dev_id, struct pt_regs *fp)
 {
-	unsigned short ints = custom.intreqr & custom.intenar;
+	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 
 	/* if a blitter interrupt */
 	if (ints & IF_BLIT) {
-		custom.intreq = IF_BLIT;
+		amiga_custom.intreq = IF_BLIT;
 		amiga_do_irq(IRQ_AMIGA_BLIT, fp);
 	}
 
 	/* if a copper interrupt */
 	if (ints & IF_COPER) {
-		custom.intreq = IF_COPER;
+		amiga_custom.intreq = IF_COPER;
 		amiga_do_irq(IRQ_AMIGA_COPPER, fp);
 	}
 
@@ -431,29 +431,29 @@ static irqreturn_t ami_int3(int irq, void *dev_id, struct pt_regs *fp)
 
 static irqreturn_t ami_int4(int irq, void *dev_id, struct pt_regs *fp)
 {
-	unsigned short ints = custom.intreqr & custom.intenar;
+	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 
 	/* if audio 0 interrupt */
 	if (ints & IF_AUD0) {
-		custom.intreq = IF_AUD0;
+		amiga_custom.intreq = IF_AUD0;
 		amiga_do_irq(IRQ_AMIGA_AUD0, fp);
 	}
 
 	/* if audio 1 interrupt */
 	if (ints & IF_AUD1) {
-		custom.intreq = IF_AUD1;
+		amiga_custom.intreq = IF_AUD1;
 		amiga_do_irq(IRQ_AMIGA_AUD1, fp);
 	}
 
 	/* if audio 2 interrupt */
 	if (ints & IF_AUD2) {
-		custom.intreq = IF_AUD2;
+		amiga_custom.intreq = IF_AUD2;
 		amiga_do_irq(IRQ_AMIGA_AUD2, fp);
 	}
 
 	/* if audio 3 interrupt */
 	if (ints & IF_AUD3) {
-		custom.intreq = IF_AUD3;
+		amiga_custom.intreq = IF_AUD3;
 		amiga_do_irq(IRQ_AMIGA_AUD3, fp);
 	}
 	return IRQ_HANDLED;
@@ -461,7 +461,7 @@ static irqreturn_t ami_int4(int irq, void *dev_id, struct pt_regs *fp)
 
 static irqreturn_t ami_int5(int irq, void *dev_id, struct pt_regs *fp)
 {
-	unsigned short ints = custom.intreqr & custom.intenar;
+	unsigned short ints = amiga_custom.intreqr & amiga_custom.intenar;
 
 	/* if serial receive buffer full interrupt */
 	if (ints & IF_RBF) {
@@ -471,7 +471,7 @@ static irqreturn_t ami_int5(int irq, void *dev_id, struct pt_regs *fp)
 
 	/* if a disk sync interrupt */
 	if (ints & IF_DSKSYN) {
-		custom.intreq = IF_DSKSYN;
+		amiga_custom.intreq = IF_DSKSYN;
 		amiga_do_irq(IRQ_AMIGA_DSKSYN, fp);
 	}
 	return IRQ_HANDLED;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/amiga/amiints.c b/arch/m68k/amiga/amiints.c
new file mode 100644
index 000000000000..d9edf2d1a492
--- /dev/null
+++ b/arch/m68k/amiga/amiints.c
@@ -0,0 +1,520 @@
+/*
+ * linux/arch/m68k/amiga/amiints.c -- Amiga Linux interrupt handling code
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * 11/07/96: rewritten interrupt handling, irq lists are exists now only for
+ *           this sources where it makes sense (VERTB/PORTS/EXTER) and you must
+ *           be careful that dev_id for this sources is unique since this the
+ *           only possibility to distinguish between different handlers for
+ *           free_irq. irq lists also have different irq flags:
+ *           - IRQ_FLG_FAST: handler is inserted at top of list (after other
+ *                           fast handlers)
+ *           - IRQ_FLG_SLOW: handler is inserted at bottom of list and before
+ *                           they're executed irq level is set to the previous
+ *                           one, but handlers don't need to be reentrant, if
+ *                           reentrance occurred, slow handlers will be just
+ *                           called again.
+ *           The whole interrupt handling for CIAs is moved to cia.c
+ *           /Roman Zippel
+ *
+ * 07/08/99: rewamp of the interrupt handling - we now have two types of
+ *           interrupts, normal and fast handlers, fast handlers being
+ *           marked with SA_INTERRUPT and runs with all other interrupts
+ *           disabled. Normal interrupts disable their own source but
+ *           run with all other interrupt sources enabled.
+ *           PORTS and EXTER interrupts are always shared even if the
+ *           drivers do not explicitly mark this when calling
+ *           request_irq which they really should do.
+ *           This is similar to the way interrupts are handled on all
+ *           other architectures and makes a ton of sense besides
+ *           having the advantage of making it easier to share
+ *           drivers.
+ *           /Jes
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/kernel_stat.h>
+#include <linux/init.h>
+#include <linux/errno.h>
+#include <linux/seq_file.h>
+
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/traps.h>
+#include <asm/amigahw.h>
+#include <asm/amigaints.h>
+#include <asm/amipcmcia.h>
+
+extern int cia_request_irq(struct ciabase *base,int irq,
+                           irqreturn_t (*handler)(int, void *, struct pt_regs *),
+                           unsigned long flags, const char *devname, void *dev_id);
+extern void cia_free_irq(struct ciabase *base, unsigned int irq, void *dev_id);
+extern void cia_init_IRQ(struct ciabase *base);
+extern int cia_get_irq_list(struct ciabase *base, struct seq_file *p);
+
+/* irq node variables for amiga interrupt sources */
+static irq_node_t *ami_irq_list[AMI_STD_IRQS];
+
+static unsigned short amiga_intena_vals[AMI_STD_IRQS] = {
+	[IRQ_AMIGA_VERTB]	= IF_VERTB,
+	[IRQ_AMIGA_COPPER]	= IF_COPER,
+	[IRQ_AMIGA_AUD0]	= IF_AUD0,
+	[IRQ_AMIGA_AUD1]	= IF_AUD1,
+	[IRQ_AMIGA_AUD2]	= IF_AUD2,
+	[IRQ_AMIGA_AUD3]	= IF_AUD3,
+	[IRQ_AMIGA_BLIT]	= IF_BLIT,
+	[IRQ_AMIGA_DSKSYN]	= IF_DSKSYN,
+	[IRQ_AMIGA_DSKBLK]	= IF_DSKBLK,
+	[IRQ_AMIGA_RBF]		= IF_RBF,
+	[IRQ_AMIGA_TBE]		= IF_TBE,
+	[IRQ_AMIGA_SOFT]	= IF_SOFT,
+	[IRQ_AMIGA_PORTS]	= IF_PORTS,
+	[IRQ_AMIGA_EXTER]	= IF_EXTER
+};
+static const unsigned char ami_servers[AMI_STD_IRQS] = {
+	[IRQ_AMIGA_VERTB]	= 1,
+	[IRQ_AMIGA_PORTS]	= 1,
+	[IRQ_AMIGA_EXTER]	= 1
+};
+
+static short ami_ablecount[AMI_IRQS];
+
+static irqreturn_t ami_badint(int irq, void *dev_id, struct pt_regs *fp)
+{
+	num_spurious += 1;
+	return IRQ_NONE;
+}
+
+/*
+ * void amiga_init_IRQ(void)
+ *
+ * Parameters:	None
+ *
+ * Returns:	Nothing
+ *
+ * This function should be called during kernel startup to initialize
+ * the amiga IRQ handling routines.
+ */
+
+void __init amiga_init_IRQ(void)
+{
+	int i;
+
+	/* initialize handlers */
+	for (i = 0; i < AMI_STD_IRQS; i++) {
+		if (ami_servers[i]) {
+			ami_irq_list[i] = NULL;
+		} else {
+			ami_irq_list[i] = new_irq_node();
+			ami_irq_list[i]->handler = ami_badint;
+			ami_irq_list[i]->flags   = 0;
+			ami_irq_list[i]->dev_id  = NULL;
+			ami_irq_list[i]->devname = NULL;
+			ami_irq_list[i]->next    = NULL;
+		}
+	}
+	for (i = 0; i < AMI_IRQS; i++)
+		ami_ablecount[i] = 0;
+
+	/* turn off PCMCIA interrupts */
+	if (AMIGAHW_PRESENT(PCMCIA))
+		gayle.inten = GAYLE_IRQ_IDE;
+
+	/* turn off all interrupts and enable the master interrupt bit */
+	custom.intena = 0x7fff;
+	custom.intreq = 0x7fff;
+	custom.intena = IF_SETCLR | IF_INTEN;
+
+	cia_init_IRQ(&ciaa_base);
+	cia_init_IRQ(&ciab_base);
+}
+
+static inline int amiga_insert_irq(irq_node_t **list, irq_node_t *node)
+{
+	unsigned long flags;
+	irq_node_t *cur;
+
+	if (!node->dev_id)
+		printk("%s: Warning: dev_id of %s is zero\n",
+		       __FUNCTION__, node->devname);
+
+	local_irq_save(flags);
+
+	cur = *list;
+
+	if (node->flags & SA_INTERRUPT) {
+		if (node->flags & SA_SHIRQ)
+			return -EBUSY;
+		/*
+		 * There should never be more than one
+		 */
+		while (cur && cur->flags & SA_INTERRUPT) {
+			list = &cur->next;
+			cur = cur->next;
+		}
+	} else {
+		while (cur) {
+			list = &cur->next;
+			cur = cur->next;
+		}
+	}
+
+	node->next = cur;
+	*list = node;
+
+	local_irq_restore(flags);
+	return 0;
+}
+
+static inline void amiga_delete_irq(irq_node_t **list, void *dev_id)
+{
+	unsigned long flags;
+	irq_node_t *node;
+
+	local_irq_save(flags);
+
+	for (node = *list; node; list = &node->next, node = *list) {
+		if (node->dev_id == dev_id) {
+			*list = node->next;
+			/* Mark it as free. */
+			node->handler = NULL;
+			local_irq_restore(flags);
+			return;
+		}
+	}
+	local_irq_restore(flags);
+	printk ("%s: tried to remove invalid irq\n", __FUNCTION__);
+}
+
+/*
+ * amiga_request_irq : add an interrupt service routine for a particular
+ *                     machine specific interrupt source.
+ *                     If the addition was successful, it returns 0.
+ */
+
+int amiga_request_irq(unsigned int irq,
+		      irqreturn_t (*handler)(int, void *, struct pt_regs *),
+                      unsigned long flags, const char *devname, void *dev_id)
+{
+	irq_node_t *node;
+	int error = 0;
+
+	if (irq >= AMI_IRQS) {
+		printk ("%s: Unknown IRQ %d from %s\n", __FUNCTION__,
+			irq, devname);
+		return -ENXIO;
+	}
+
+	if (irq >= IRQ_AMIGA_AUTO)
+		return cpu_request_irq(irq - IRQ_AMIGA_AUTO, handler,
+		                       flags, devname, dev_id);
+
+	if (irq >= IRQ_AMIGA_CIAB)
+		return cia_request_irq(&ciab_base, irq - IRQ_AMIGA_CIAB,
+		                       handler, flags, devname, dev_id);
+
+	if (irq >= IRQ_AMIGA_CIAA)
+		return cia_request_irq(&ciaa_base, irq - IRQ_AMIGA_CIAA,
+		                       handler, flags, devname, dev_id);
+
+	/*
+	 * IRQ_AMIGA_PORTS & IRQ_AMIGA_EXTER defaults to shared,
+	 * we could add a check here for the SA_SHIRQ flag but all drivers
+	 * should be aware of sharing anyway.
+	 */
+	if (ami_servers[irq]) {
+		if (!(node = new_irq_node()))
+			return -ENOMEM;
+		node->handler = handler;
+		node->flags   = flags;
+		node->dev_id  = dev_id;
+		node->devname = devname;
+		node->next    = NULL;
+		error = amiga_insert_irq(&ami_irq_list[irq], node);
+	} else {
+		ami_irq_list[irq]->handler = handler;
+		ami_irq_list[irq]->flags   = flags;
+		ami_irq_list[irq]->dev_id  = dev_id;
+		ami_irq_list[irq]->devname = devname;
+	}
+
+	/* enable the interrupt */
+	if (irq < IRQ_AMIGA_PORTS && !ami_ablecount[irq])
+		custom.intena = IF_SETCLR | amiga_intena_vals[irq];
+
+	return error;
+}
+
+void amiga_free_irq(unsigned int irq, void *dev_id)
+{
+	if (irq >= AMI_IRQS) {
+		printk ("%s: Unknown IRQ %d\n", __FUNCTION__, irq);
+		return;
+	}
+
+	if (irq >= IRQ_AMIGA_AUTO)
+		cpu_free_irq(irq - IRQ_AMIGA_AUTO, dev_id);
+
+	if (irq >= IRQ_AMIGA_CIAB) {
+		cia_free_irq(&ciab_base, irq - IRQ_AMIGA_CIAB, dev_id);
+		return;
+	}
+
+	if (irq >= IRQ_AMIGA_CIAA) {
+		cia_free_irq(&ciaa_base, irq - IRQ_AMIGA_CIAA, dev_id);
+		return;
+	}
+
+	if (ami_servers[irq]) {
+		amiga_delete_irq(&ami_irq_list[irq], dev_id);
+		/* if server list empty, disable the interrupt */
+		if (!ami_irq_list[irq] && irq < IRQ_AMIGA_PORTS)
+			custom.intena = amiga_intena_vals[irq];
+	} else {
+		if (ami_irq_list[irq]->dev_id != dev_id)
+			printk("%s: removing probably wrong IRQ %d from %s\n",
+			       __FUNCTION__, irq, ami_irq_list[irq]->devname);
+		ami_irq_list[irq]->handler = ami_badint;
+		ami_irq_list[irq]->flags   = 0;
+		ami_irq_list[irq]->dev_id  = NULL;
+		ami_irq_list[irq]->devname = NULL;
+		custom.intena = amiga_intena_vals[irq];
+	}
+}
+
+/*
+ * Enable/disable a particular machine specific interrupt source.
+ * Note that this may affect other interrupts in case of a shared interrupt.
+ * This function should only be called for a _very_ short time to change some
+ * internal data, that may not be changed by the interrupt at the same time.
+ * ami_(enable|disable)_irq calls may also be nested.
+ */
+
+void amiga_enable_irq(unsigned int irq)
+{
+	if (irq >= AMI_IRQS) {
+		printk("%s: Unknown IRQ %d\n", __FUNCTION__, irq);
+		return;
+	}
+
+	if (--ami_ablecount[irq])
+		return;
+
+	/* No action for auto-vector interrupts */
+	if (irq >= IRQ_AMIGA_AUTO){
+		printk("%s: Trying to enable auto-vector IRQ %i\n",
+		       __FUNCTION__, irq - IRQ_AMIGA_AUTO);
+		return;
+	}
+
+	if (irq >= IRQ_AMIGA_CIAB) {
+		cia_set_irq(&ciab_base, (1 << (irq - IRQ_AMIGA_CIAB)));
+		cia_able_irq(&ciab_base, CIA_ICR_SETCLR |
+		             (1 << (irq - IRQ_AMIGA_CIAB)));
+		return;
+	}
+
+	if (irq >= IRQ_AMIGA_CIAA) {
+		cia_set_irq(&ciaa_base, (1 << (irq - IRQ_AMIGA_CIAA)));
+		cia_able_irq(&ciaa_base, CIA_ICR_SETCLR |
+		             (1 << (irq - IRQ_AMIGA_CIAA)));
+		return;
+	}
+
+	/* enable the interrupt */
+	custom.intena = IF_SETCLR | amiga_intena_vals[irq];
+}
+
+void amiga_disable_irq(unsigned int irq)
+{
+	if (irq >= AMI_IRQS) {
+		printk("%s: Unknown IRQ %d\n", __FUNCTION__, irq);
+		return;
+	}
+
+	if (ami_ablecount[irq]++)
+		return;
+
+	/* No action for auto-vector interrupts */
+	if (irq >= IRQ_AMIGA_AUTO) {
+		printk("%s: Trying to disable auto-vector IRQ %i\n",
+		       __FUNCTION__, irq - IRQ_AMIGA_AUTO);
+		return;
+	}
+
+	if (irq >= IRQ_AMIGA_CIAB) {
+		cia_able_irq(&ciab_base, 1 << (irq - IRQ_AMIGA_CIAB));
+		return;
+	}
+
+	if (irq >= IRQ_AMIGA_CIAA) {
+		cia_able_irq(&ciaa_base, 1 << (irq - IRQ_AMIGA_CIAA));
+		return;
+	}
+
+	/* disable the interrupt */
+	custom.intena = amiga_intena_vals[irq];
+}
+
+inline void amiga_do_irq(int irq, struct pt_regs *fp)
+{
+	kstat_cpu(0).irqs[SYS_IRQS + irq]++;
+	ami_irq_list[irq]->handler(irq, ami_irq_list[irq]->dev_id, fp);
+}
+
+void amiga_do_irq_list(int irq, struct pt_regs *fp)
+{
+	irq_node_t *node;
+
+	kstat_cpu(0).irqs[SYS_IRQS + irq]++;
+
+	custom.intreq = amiga_intena_vals[irq];
+
+	for (node = ami_irq_list[irq]; node; node = node->next)
+		node->handler(irq, node->dev_id, fp);
+}
+
+/*
+ * The builtin Amiga hardware interrupt handlers.
+ */
+
+static irqreturn_t ami_int1(int irq, void *dev_id, struct pt_regs *fp)
+{
+	unsigned short ints = custom.intreqr & custom.intenar;
+
+	/* if serial transmit buffer empty, interrupt */
+	if (ints & IF_TBE) {
+		custom.intreq = IF_TBE;
+		amiga_do_irq(IRQ_AMIGA_TBE, fp);
+	}
+
+	/* if floppy disk transfer complete, interrupt */
+	if (ints & IF_DSKBLK) {
+		custom.intreq = IF_DSKBLK;
+		amiga_do_irq(IRQ_AMIGA_DSKBLK, fp);
+	}
+
+	/* if software interrupt set, interrupt */
+	if (ints & IF_SOFT) {
+		custom.intreq = IF_SOFT;
+		amiga_do_irq(IRQ_AMIGA_SOFT, fp);
+	}
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ami_int3(int irq, void *dev_id, struct pt_regs *fp)
+{
+	unsigned short ints = custom.intreqr & custom.intenar;
+
+	/* if a blitter interrupt */
+	if (ints & IF_BLIT) {
+		custom.intreq = IF_BLIT;
+		amiga_do_irq(IRQ_AMIGA_BLIT, fp);
+	}
+
+	/* if a copper interrupt */
+	if (ints & IF_COPER) {
+		custom.intreq = IF_COPER;
+		amiga_do_irq(IRQ_AMIGA_COPPER, fp);
+	}
+
+	/* if a vertical blank interrupt */
+	if (ints & IF_VERTB)
+		amiga_do_irq_list(IRQ_AMIGA_VERTB, fp);
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ami_int4(int irq, void *dev_id, struct pt_regs *fp)
+{
+	unsigned short ints = custom.intreqr & custom.intenar;
+
+	/* if audio 0 interrupt */
+	if (ints & IF_AUD0) {
+		custom.intreq = IF_AUD0;
+		amiga_do_irq(IRQ_AMIGA_AUD0, fp);
+	}
+
+	/* if audio 1 interrupt */
+	if (ints & IF_AUD1) {
+		custom.intreq = IF_AUD1;
+		amiga_do_irq(IRQ_AMIGA_AUD1, fp);
+	}
+
+	/* if audio 2 interrupt */
+	if (ints & IF_AUD2) {
+		custom.intreq = IF_AUD2;
+		amiga_do_irq(IRQ_AMIGA_AUD2, fp);
+	}
+
+	/* if audio 3 interrupt */
+	if (ints & IF_AUD3) {
+		custom.intreq = IF_AUD3;
+		amiga_do_irq(IRQ_AMIGA_AUD3, fp);
+	}
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ami_int5(int irq, void *dev_id, struct pt_regs *fp)
+{
+	unsigned short ints = custom.intreqr & custom.intenar;
+
+	/* if serial receive buffer full interrupt */
+	if (ints & IF_RBF) {
+		/* acknowledge of IF_RBF must be done by the serial interrupt */
+		amiga_do_irq(IRQ_AMIGA_RBF, fp);
+	}
+
+	/* if a disk sync interrupt */
+	if (ints & IF_DSKSYN) {
+		custom.intreq = IF_DSKSYN;
+		amiga_do_irq(IRQ_AMIGA_DSKSYN, fp);
+	}
+	return IRQ_HANDLED;
+}
+
+static irqreturn_t ami_int7(int irq, void *dev_id, struct pt_regs *fp)
+{
+	panic ("level 7 interrupt received\n");
+}
+
+irqreturn_t (*amiga_default_handler[SYS_IRQS])(int, void *, struct pt_regs *) = {
+	[0] = ami_badint,
+	[1] = ami_int1,
+	[2] = ami_badint,
+	[3] = ami_int3,
+	[4] = ami_int4,
+	[5] = ami_int5,
+	[6] = ami_badint,
+	[7] = ami_int7
+};
+
+int show_amiga_interrupts(struct seq_file *p, void *v)
+{
+	int i;
+	irq_node_t *node;
+
+	for (i = 0; i < AMI_STD_IRQS; i++) {
+		if (!(node = ami_irq_list[i]))
+			continue;
+		seq_printf(p, "ami  %2d: %10u ", i,
+		               kstat_cpu(0).irqs[SYS_IRQS + i]);
+		do {
+			if (node->flags & SA_INTERRUPT)
+				seq_puts(p, "F ");
+			else
+				seq_puts(p, "  ");
+			seq_printf(p, "%s\n", node->devname);
+			if ((node = node->next))
+				seq_puts(p, "                    ");
+		} while (node);
+	}
+
+	cia_get_irq_list(&ciaa_base, p);
+	cia_get_irq_list(&ciab_base, p);
+	return 0;
+}
