commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index ba03cec3f711..a537953bc10c 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
 **  linux/amiga/chipram.c
 **

commit 6112ea0862facaeaeab504ee01c0d04bcd22daaf
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Jan 9 11:03:43 2011 +0100

    zorro: ZTWO_VADDR() should return "void __iomem *"
    
    ZTWO_VADDR() converts from physical to virtual I/O addresses, so it should
    return "void __iomem *" instead of "unsigned long".
    
    This allows to drop several casts, but requires adding a few casts to
    accomodate legacy driver frameworks that store "unsigned long" I/O
    addresses.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index 99449fbf9a72..ba03cec3f711 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -87,7 +87,7 @@ void *amiga_chip_alloc_res(unsigned long size, struct resource *res)
 
 	atomic_sub(size, &chipavail);
 	pr_debug("amiga_chip_alloc_res: returning %pR\n", res);
-	return (void *)ZTWO_VADDR(res->start);
+	return ZTWO_VADDR(res->start);
 }
 
 void amiga_chip_free(void *ptr)

commit b7785e954348465e1926d9c10ff3e49c207d4ec6
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sat May 7 20:56:00 2011 +0200

    m68k/amiga: Chip RAM - Use lookup_resource()
    
    Replace a custom implementation (which doesn't lock the resource tree) by a
    call to lookup_resource()
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index 4790f77cbd48..99449fbf9a72 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -93,21 +93,21 @@ void *amiga_chip_alloc_res(unsigned long size, struct resource *res)
 void amiga_chip_free(void *ptr)
 {
 	unsigned long start = ZTWO_PADDR(ptr);
-	struct resource **p, *res;
+	struct resource *res;
 	unsigned long size;
 
-	for (p = &chipram_res.child; (res = *p); p = &res->sibling) {
-		if (res->start != start)
-			continue;
-		*p = res->sibling;
-		size = resource_size(res);
-		pr_debug("amiga_chip_free: free %lu bytes at %p\n", size, ptr);
-		atomic_add(size, &chipavail);
-		kfree(res);
+	res = lookup_resource(&chipram_res, start);
+	if (!res) {
+		pr_err("amiga_chip_free: trying to free nonexistent region at "
+		       "%p\n", ptr);
 		return;
 	}
-	pr_err("amiga_chip_free: trying to free nonexistent region at %p\n",
-	       ptr);
+
+	size = resource_size(res);
+	pr_debug("amiga_chip_free: free %lu bytes at %p\n", size, ptr);
+	atomic_add(size, &chipavail);
+	release_resource(res);
+	kfree(res);
 }
 EXPORT_SYMBOL(amiga_chip_free);
 

commit 1dad6c7bd7dd158ef874f7382615cedc21a1f48d
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun May 22 11:09:02 2011 +0200

    m68k/amiga: Chip RAM - Offset resource end by CHIP_PHYSADDR
    
    Technically, the end of Chip RAM should be offset by CHIP_PHYSADDR (which is
    zero).
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index cfd3b7af26c6..4790f77cbd48 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -34,7 +34,7 @@ void __init amiga_chip_init(void)
 	if (!AMIGAHW_PRESENT(CHIP_RAM))
 		return;
 
-	chipram_res.end = amiga_chip_size-1;
+	chipram_res.end = CHIP_PHYSADDR + amiga_chip_size - 1;
 	request_resource(&iomem_resource, &chipram_res);
 
 	atomic_set(&chipavail, amiga_chip_size);

commit cb4f9988f86746fff3183d31381deb2b2a421a3a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Apr 27 10:28:19 2011 +0200

    m68k/amiga: Chip RAM - Use resource_size() to fix off-by-one error
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index c3fe45125f52..cfd3b7af26c6 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -100,7 +100,7 @@ void amiga_chip_free(void *ptr)
 		if (res->start != start)
 			continue;
 		*p = res->sibling;
-		size = res->end-start;
+		size = resource_size(res);
 		pr_debug("amiga_chip_free: free %lu bytes at %p\n", size, ptr);
 		atomic_add(size, &chipavail);
 		kfree(res);

commit cab49bc95d848a85d7108f896f6d21283f25f54c
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 24 23:40:51 2011 +0200

    m68k/amiga: Chip RAM - Change chipavail to an atomic_t
    
    While the core resource handling code is safe, our global counter must
    still be protected against concurrent modifications.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index e5a8dbc9abaf..c3fe45125f52 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -16,6 +16,7 @@
 #include <linux/string.h>
 #include <linux/module.h>
 
+#include <asm/atomic.h>
 #include <asm/page.h>
 #include <asm/amigahw.h>
 
@@ -25,7 +26,7 @@ EXPORT_SYMBOL(amiga_chip_size);
 static struct resource chipram_res = {
 	.name = "Chip RAM", .start = CHIP_PHYSADDR
 };
-static unsigned long chipavail;
+static atomic_t chipavail;
 
 
 void __init amiga_chip_init(void)
@@ -36,7 +37,7 @@ void __init amiga_chip_init(void)
 	chipram_res.end = amiga_chip_size-1;
 	request_resource(&iomem_resource, &chipram_res);
 
-	chipavail = amiga_chip_size;
+	atomic_set(&chipavail, amiga_chip_size);
 }
 
 
@@ -84,7 +85,7 @@ void *amiga_chip_alloc_res(unsigned long size, struct resource *res)
 		return NULL;
 	}
 
-	chipavail -= size;
+	atomic_sub(size, &chipavail);
 	pr_debug("amiga_chip_alloc_res: returning %pR\n", res);
 	return (void *)ZTWO_VADDR(res->start);
 }
@@ -101,7 +102,7 @@ void amiga_chip_free(void *ptr)
 		*p = res->sibling;
 		size = res->end-start;
 		pr_debug("amiga_chip_free: free %lu bytes at %p\n", size, ptr);
-		chipavail += size;
+		atomic_add(size, &chipavail);
 		kfree(res);
 		return;
 	}
@@ -113,8 +114,10 @@ EXPORT_SYMBOL(amiga_chip_free);
 
 unsigned long amiga_chip_avail(void)
 {
-	pr_debug("amiga_chip_avail : %lu bytes\n", chipavail);
-	return chipavail;
+	unsigned long n = atomic_read(&chipavail);
+
+	pr_debug("amiga_chip_avail : %lu bytes\n", n);
+	return n;
 }
 EXPORT_SYMBOL(amiga_chip_avail);
 

commit 3a17bfa4fb37e7f8e06ef31feafec559bd4c6699
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 24 23:19:05 2011 +0200

    m68k/amiga: Chip RAM - Always allocate from the start of memory
    
    As of commit 5df1abdbd37af2ae317a1c5b5944173284dc55d6 ('m68k/amiga: Fix
    "debug=mem"'), "debug=mem" no longer uses amiga_chip_alloc_res(), so we
    can remove the hack to prefer memory at the safe end.
    
    This allows to simplify the code and make amiga_chip_alloc() just call
    amiga_chip_alloc_res() internally.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index 9005fa07f2e2..e5a8dbc9abaf 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -43,24 +43,20 @@ void __init amiga_chip_init(void)
 void *amiga_chip_alloc(unsigned long size, const char *name)
 {
 	struct resource *res;
+	void *p;
 
-	/* round up */
-	size = PAGE_ALIGN(size);
-
-	pr_debug("amiga_chip_alloc: allocate %lu bytes\n", size);
 	res = kzalloc(sizeof(struct resource), GFP_KERNEL);
 	if (!res)
 		return NULL;
-	res->name = name;
 
-	if (allocate_resource(&chipram_res, res, size, 0, UINT_MAX, PAGE_SIZE,
-			      NULL, NULL) < 0) {
+	res->name = name;
+	p = amiga_chip_alloc_res(size, res);
+	if (!p) {
 		kfree(res);
 		return NULL;
 	}
-	chipavail -= size;
-	pr_debug("amiga_chip_alloc: returning %pR\n", res);
-	return (void *)ZTWO_VADDR(res->start);
+
+	return p;
 }
 EXPORT_SYMBOL(amiga_chip_alloc);
 
@@ -72,23 +68,22 @@ EXPORT_SYMBOL(amiga_chip_alloc);
 	 *  those drivers must not free that Chip RAM afterwards.
 	 */
 
-void * __init amiga_chip_alloc_res(unsigned long size, struct resource *res)
+void *amiga_chip_alloc_res(unsigned long size, struct resource *res)
 {
-	unsigned long start;
+	int error;
 
 	/* round up */
 	size = PAGE_ALIGN(size);
-	/* dmesg into chipmem prefers memory at the safe end */
-	start = CHIP_PHYSADDR + chipavail - size;
 
 	pr_debug("amiga_chip_alloc_res: allocate %lu bytes\n", size);
-	if (allocate_resource(&chipram_res, res, size, start, UINT_MAX,
-			      PAGE_SIZE, NULL, NULL) < 0) {
-		pr_err("amiga_chip_alloc_res: first alloc failed!\n");
-		if (allocate_resource(&chipram_res, res, size, 0, UINT_MAX,
-				      PAGE_SIZE, NULL, NULL) < 0)
-			return NULL;
+	error = allocate_resource(&chipram_res, res, size, 0, UINT_MAX,
+				  PAGE_SIZE, NULL, NULL);
+	if (error < 0) {
+		pr_err("amiga_chip_alloc_res: allocate_resource() failed %d!\n",
+		       error);
+		return NULL;
 	}
+
 	chipavail -= size;
 	pr_debug("amiga_chip_alloc_res: returning %pR\n", res);
 	return (void *)ZTWO_VADDR(res->start);

commit b4f6f45302a9440e26f71dab0b95906bcc3bd13a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 24 22:55:20 2011 +0200

    m68k/amiga: Chip RAM - Convert from printk() to pr_*()
    
    and fix a few formattings:
      - resource sizes are now resource_size_t, use %pR to make it future proof,
      - use %lu for unsigned long.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index e757ffffbc8a..9005fa07f2e2 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -47,9 +47,7 @@ void *amiga_chip_alloc(unsigned long size, const char *name)
 	/* round up */
 	size = PAGE_ALIGN(size);
 
-#ifdef DEBUG
-	printk("amiga_chip_alloc: allocate %ld bytes\n", size);
-#endif
+	pr_debug("amiga_chip_alloc: allocate %lu bytes\n", size);
 	res = kzalloc(sizeof(struct resource), GFP_KERNEL);
 	if (!res)
 		return NULL;
@@ -61,9 +59,7 @@ void *amiga_chip_alloc(unsigned long size, const char *name)
 		return NULL;
 	}
 	chipavail -= size;
-#ifdef DEBUG
-	printk("amiga_chip_alloc: returning %lx\n", res->start);
-#endif
+	pr_debug("amiga_chip_alloc: returning %pR\n", res);
 	return (void *)ZTWO_VADDR(res->start);
 }
 EXPORT_SYMBOL(amiga_chip_alloc);
@@ -85,20 +81,16 @@ void * __init amiga_chip_alloc_res(unsigned long size, struct resource *res)
 	/* dmesg into chipmem prefers memory at the safe end */
 	start = CHIP_PHYSADDR + chipavail - size;
 
-#ifdef DEBUG
-	printk("amiga_chip_alloc_res: allocate %ld bytes\n", size);
-#endif
+	pr_debug("amiga_chip_alloc_res: allocate %lu bytes\n", size);
 	if (allocate_resource(&chipram_res, res, size, start, UINT_MAX,
 			      PAGE_SIZE, NULL, NULL) < 0) {
-		printk("amiga_chip_alloc_res: first alloc failed!\n");
+		pr_err("amiga_chip_alloc_res: first alloc failed!\n");
 		if (allocate_resource(&chipram_res, res, size, 0, UINT_MAX,
 				      PAGE_SIZE, NULL, NULL) < 0)
 			return NULL;
 	}
 	chipavail -= size;
-#ifdef DEBUG
-	printk("amiga_chip_alloc_res: returning %lx\n", res->start);
-#endif
+	pr_debug("amiga_chip_alloc_res: returning %pR\n", res);
 	return (void *)ZTWO_VADDR(res->start);
 }
 
@@ -113,14 +105,12 @@ void amiga_chip_free(void *ptr)
 			continue;
 		*p = res->sibling;
 		size = res->end-start;
-#ifdef DEBUG
-		printk("amiga_chip_free: free %ld bytes at %p\n", size, ptr);
-#endif
+		pr_debug("amiga_chip_free: free %lu bytes at %p\n", size, ptr);
 		chipavail += size;
 		kfree(res);
 		return;
 	}
-	printk("amiga_chip_free: trying to free nonexistent region at %p\n",
+	pr_err("amiga_chip_free: trying to free nonexistent region at %p\n",
 	       ptr);
 }
 EXPORT_SYMBOL(amiga_chip_free);
@@ -128,9 +118,7 @@ EXPORT_SYMBOL(amiga_chip_free);
 
 unsigned long amiga_chip_avail(void)
 {
-#ifdef DEBUG
-	printk("amiga_chip_avail : %ld bytes\n", chipavail);
-#endif
+	pr_debug("amiga_chip_avail : %lu bytes\n", chipavail);
 	return chipavail;
 }
 EXPORT_SYMBOL(amiga_chip_avail);

commit 5be3246306e613055505f4950411f5497d97edb0
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sat May 21 20:46:39 2011 +0200

    m68k/amiga: Chip RAM - Use tabs for indentation
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index dd0447db1c90..e757ffffbc8a 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -23,101 +23,105 @@ unsigned long amiga_chip_size;
 EXPORT_SYMBOL(amiga_chip_size);
 
 static struct resource chipram_res = {
-    .name = "Chip RAM", .start = CHIP_PHYSADDR
+	.name = "Chip RAM", .start = CHIP_PHYSADDR
 };
 static unsigned long chipavail;
 
 
 void __init amiga_chip_init(void)
 {
-    if (!AMIGAHW_PRESENT(CHIP_RAM))
-	return;
+	if (!AMIGAHW_PRESENT(CHIP_RAM))
+		return;
 
-    chipram_res.end = amiga_chip_size-1;
-    request_resource(&iomem_resource, &chipram_res);
+	chipram_res.end = amiga_chip_size-1;
+	request_resource(&iomem_resource, &chipram_res);
 
-    chipavail = amiga_chip_size;
+	chipavail = amiga_chip_size;
 }
 
 
 void *amiga_chip_alloc(unsigned long size, const char *name)
 {
-    struct resource *res;
+	struct resource *res;
 
-    /* round up */
-    size = PAGE_ALIGN(size);
+	/* round up */
+	size = PAGE_ALIGN(size);
 
 #ifdef DEBUG
-    printk("amiga_chip_alloc: allocate %ld bytes\n", size);
+	printk("amiga_chip_alloc: allocate %ld bytes\n", size);
 #endif
-    res = kzalloc(sizeof(struct resource), GFP_KERNEL);
-    if (!res)
-	return NULL;
-    res->name = name;
-
-    if (allocate_resource(&chipram_res, res, size, 0, UINT_MAX, PAGE_SIZE, NULL, NULL) < 0) {
-	kfree(res);
-	return NULL;
-    }
-    chipavail -= size;
+	res = kzalloc(sizeof(struct resource), GFP_KERNEL);
+	if (!res)
+		return NULL;
+	res->name = name;
+
+	if (allocate_resource(&chipram_res, res, size, 0, UINT_MAX, PAGE_SIZE,
+			      NULL, NULL) < 0) {
+		kfree(res);
+		return NULL;
+	}
+	chipavail -= size;
 #ifdef DEBUG
-    printk("amiga_chip_alloc: returning %lx\n", res->start);
+	printk("amiga_chip_alloc: returning %lx\n", res->start);
 #endif
-    return (void *)ZTWO_VADDR(res->start);
+	return (void *)ZTWO_VADDR(res->start);
 }
 EXPORT_SYMBOL(amiga_chip_alloc);
 
 
-    /*
-     *  Warning:
-     *  amiga_chip_alloc_res is meant only for drivers that need to allocate
-     *  Chip RAM before kmalloc() is functional. As a consequence, those
-     *  drivers must not free that Chip RAM afterwards.
-     */
+	/*
+	 *  Warning:
+	 *  amiga_chip_alloc_res is meant only for drivers that need to
+	 *  allocate Chip RAM before kmalloc() is functional. As a consequence,
+	 *  those drivers must not free that Chip RAM afterwards.
+	 */
 
 void * __init amiga_chip_alloc_res(unsigned long size, struct resource *res)
 {
-    unsigned long start;
+	unsigned long start;
 
-    /* round up */
-    size = PAGE_ALIGN(size);
-    /* dmesg into chipmem prefers memory at the safe end */
-    start = CHIP_PHYSADDR + chipavail - size;
+	/* round up */
+	size = PAGE_ALIGN(size);
+	/* dmesg into chipmem prefers memory at the safe end */
+	start = CHIP_PHYSADDR + chipavail - size;
 
 #ifdef DEBUG
-    printk("amiga_chip_alloc_res: allocate %ld bytes\n", size);
+	printk("amiga_chip_alloc_res: allocate %ld bytes\n", size);
 #endif
-    if (allocate_resource(&chipram_res, res, size, start, UINT_MAX, PAGE_SIZE, NULL, NULL) < 0) {
-	printk("amiga_chip_alloc_res: first alloc failed!\n");
-	if (allocate_resource(&chipram_res, res, size, 0, UINT_MAX, PAGE_SIZE, NULL, NULL) < 0)
-	    return NULL;
-    }
-    chipavail -= size;
+	if (allocate_resource(&chipram_res, res, size, start, UINT_MAX,
+			      PAGE_SIZE, NULL, NULL) < 0) {
+		printk("amiga_chip_alloc_res: first alloc failed!\n");
+		if (allocate_resource(&chipram_res, res, size, 0, UINT_MAX,
+				      PAGE_SIZE, NULL, NULL) < 0)
+			return NULL;
+	}
+	chipavail -= size;
 #ifdef DEBUG
-    printk("amiga_chip_alloc_res: returning %lx\n", res->start);
+	printk("amiga_chip_alloc_res: returning %lx\n", res->start);
 #endif
-    return (void *)ZTWO_VADDR(res->start);
+	return (void *)ZTWO_VADDR(res->start);
 }
 
 void amiga_chip_free(void *ptr)
 {
-    unsigned long start = ZTWO_PADDR(ptr);
-    struct resource **p, *res;
-    unsigned long size;
-
-    for (p = &chipram_res.child; (res = *p); p = &res->sibling) {
-	if (res->start != start)
-	    continue;
-	*p = res->sibling;
-	size = res->end-start;
+	unsigned long start = ZTWO_PADDR(ptr);
+	struct resource **p, *res;
+	unsigned long size;
+
+	for (p = &chipram_res.child; (res = *p); p = &res->sibling) {
+		if (res->start != start)
+			continue;
+		*p = res->sibling;
+		size = res->end-start;
 #ifdef DEBUG
-	printk("amiga_chip_free: free %ld bytes at %p\n", size, ptr);
+		printk("amiga_chip_free: free %ld bytes at %p\n", size, ptr);
 #endif
-	chipavail += size;
-	kfree(res);
-	return;
-    }
-    printk("amiga_chip_free: trying to free nonexistent region at %p\n", ptr);
+		chipavail += size;
+		kfree(res);
+		return;
+	}
+	printk("amiga_chip_free: trying to free nonexistent region at %p\n",
+	       ptr);
 }
 EXPORT_SYMBOL(amiga_chip_free);
 

commit f369e3781611e78127c34195659538e37568c79c
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Jan 9 14:19:42 2011 +0100

    m68k/amiga: Reclaim Chip RAM for PPC exception handlers
    
    On m68k, it doesn't make sense to reserve memory for the PPC exception
    handlers, and APUS support is dead.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index 61df1d33c050..dd0447db1c90 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -33,10 +33,6 @@ void __init amiga_chip_init(void)
     if (!AMIGAHW_PRESENT(CHIP_RAM))
 	return;
 
-    /*
-     *  Remove the first 4 pages where PPC exception handlers will be located
-     */
-    amiga_chip_size -= 0x4000;
     chipram_res.end = amiga_chip_size-1;
     request_resource(&iomem_resource, &chipram_res);
 

commit 27ac792ca0b0a1e7e65f20342260650516c95864
Author: Andrea Righi <righi.andrea@gmail.com>
Date:   Wed Jul 23 21:28:13 2008 -0700

    PAGE_ALIGN(): correctly handle 64-bit values on 32-bit architectures
    
    On 32-bit architectures PAGE_ALIGN() truncates 64-bit values to the 32-bit
    boundary. For example:
    
            u64 val = PAGE_ALIGN(size);
    
    always returns a value < 4GB even if size is greater than 4GB.
    
    The problem resides in PAGE_MASK definition (from include/asm-x86/page.h for
    example):
    
    #define PAGE_SHIFT      12
    #define PAGE_SIZE       (_AC(1,UL) << PAGE_SHIFT)
    #define PAGE_MASK       (~(PAGE_SIZE-1))
    ...
    #define PAGE_ALIGN(addr)       (((addr)+PAGE_SIZE-1)&PAGE_MASK)
    
    The "~" is performed on a 32-bit value, so everything in "and" with
    PAGE_MASK greater than 4GB will be truncated to the 32-bit boundary.
    Using the ALIGN() macro seems to be the right way, because it uses
    typeof(addr) for the mask.
    
    Also move the PAGE_ALIGN() definitions out of include/asm-*/page.h in
    include/linux/mm.h.
    
    See also lkml discussion: http://lkml.org/lkml/2008/6/11/237
    
    [akpm@linux-foundation.org: fix drivers/media/video/uvc/uvc_queue.c]
    [akpm@linux-foundation.org: fix v850]
    [akpm@linux-foundation.org: fix powerpc]
    [akpm@linux-foundation.org: fix arm]
    [akpm@linux-foundation.org: fix mips]
    [akpm@linux-foundation.org: fix drivers/media/video/pvrusb2/pvrusb2-dvb.c]
    [akpm@linux-foundation.org: fix drivers/mtd/maps/uclinux.c]
    [akpm@linux-foundation.org: fix powerpc]
    Signed-off-by: Andrea Righi <righi.andrea@gmail.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index cbe36538af47..61df1d33c050 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -9,6 +9,7 @@
 
 #include <linux/types.h>
 #include <linux/kernel.h>
+#include <linux/mm.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/slab.h>

commit 7b892806b09dca77db8ef6acbb6c51271578d34d
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Feb 6 01:36:29 2008 -0800

    cleanup after APUS removal
    
    After the APUS removal, some code can be removed.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: "Antonino A. Daplas" <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index d10726f9038b..cbe36538af47 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -32,12 +32,10 @@ void __init amiga_chip_init(void)
     if (!AMIGAHW_PRESENT(CHIP_RAM))
 	return;
 
-#ifndef CONFIG_APUS_FAST_EXCEPT
     /*
      *  Remove the first 4 pages where PPC exception handlers will be located
      */
     amiga_chip_size -= 0x4000;
-#endif
     chipram_res.end = amiga_chip_size-1;
     request_resource(&iomem_resource, &chipram_res);
 

commit 8b169fa2c942bc2a579da3f33986bd3fc48d9684
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Feb 4 22:30:25 2008 -0800

    m68k: kill arch/m68k/amiga/amiga_ksyms.c
    
    EXPORT_SYMBOL's belong to the actual code.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index fa015d801617..d10726f9038b 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -13,10 +13,13 @@
 #include <linux/ioport.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <linux/module.h>
+
 #include <asm/page.h>
 #include <asm/amigahw.h>
 
 unsigned long amiga_chip_size;
+EXPORT_SYMBOL(amiga_chip_size);
 
 static struct resource chipram_res = {
     .name = "Chip RAM", .start = CHIP_PHYSADDR
@@ -67,6 +70,7 @@ void *amiga_chip_alloc(unsigned long size, const char *name)
 #endif
     return (void *)ZTWO_VADDR(res->start);
 }
+EXPORT_SYMBOL(amiga_chip_alloc);
 
 
     /*
@@ -120,6 +124,7 @@ void amiga_chip_free(void *ptr)
     }
     printk("amiga_chip_free: trying to free nonexistent region at %p\n", ptr);
 }
+EXPORT_SYMBOL(amiga_chip_free);
 
 
 unsigned long amiga_chip_avail(void)
@@ -129,3 +134,5 @@ unsigned long amiga_chip_avail(void)
 #endif
 	return chipavail;
 }
+EXPORT_SYMBOL(amiga_chip_avail);
+

commit 8bcbdf603bc4bf24c2bcfa071871afb03dd3ae80
Author: Yan Burman <burman.yan@gmail.com>
Date:   Wed Dec 6 20:34:51 2006 -0800

    [PATCH] m68k: replace kmalloc+memset with kzalloc
    
    Replace kmalloc+memset with kzalloc
    
    Signed-off-by: Yan Burman <burman.yan@gmail.com>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index de1304c91112..fa015d801617 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -52,10 +52,9 @@ void *amiga_chip_alloc(unsigned long size, const char *name)
 #ifdef DEBUG
     printk("amiga_chip_alloc: allocate %ld bytes\n", size);
 #endif
-    res = kmalloc(sizeof(struct resource), GFP_KERNEL);
+    res = kzalloc(sizeof(struct resource), GFP_KERNEL);
     if (!res)
 	return NULL;
-    memset(res, 0, sizeof(struct resource));
     res->name = name;
 
     if (allocate_resource(&chipram_res, res, size, 0, UINT_MAX, PAGE_SIZE, NULL, NULL) < 0) {

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
index 558d5fd2d2ba..de1304c91112 100644
--- a/arch/m68k/amiga/chipram.c
+++ b/arch/m68k/amiga/chipram.c
@@ -7,7 +7,6 @@
 **	Rewritten 15/9/2000 by Geert to use resource management
 */
 
-#include <linux/config.h>
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/init.h>

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/amiga/chipram.c b/arch/m68k/amiga/chipram.c
new file mode 100644
index 000000000000..558d5fd2d2ba
--- /dev/null
+++ b/arch/m68k/amiga/chipram.c
@@ -0,0 +1,133 @@
+/*
+**  linux/amiga/chipram.c
+**
+**      Modified 03-May-94 by Geert Uytterhoeven <geert@linux-m68k.org>
+**          - 64-bit aligned allocations for full AGA compatibility
+**
+**	Rewritten 15/9/2000 by Geert to use resource management
+*/
+
+#include <linux/config.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <linux/string.h>
+#include <asm/page.h>
+#include <asm/amigahw.h>
+
+unsigned long amiga_chip_size;
+
+static struct resource chipram_res = {
+    .name = "Chip RAM", .start = CHIP_PHYSADDR
+};
+static unsigned long chipavail;
+
+
+void __init amiga_chip_init(void)
+{
+    if (!AMIGAHW_PRESENT(CHIP_RAM))
+	return;
+
+#ifndef CONFIG_APUS_FAST_EXCEPT
+    /*
+     *  Remove the first 4 pages where PPC exception handlers will be located
+     */
+    amiga_chip_size -= 0x4000;
+#endif
+    chipram_res.end = amiga_chip_size-1;
+    request_resource(&iomem_resource, &chipram_res);
+
+    chipavail = amiga_chip_size;
+}
+
+
+void *amiga_chip_alloc(unsigned long size, const char *name)
+{
+    struct resource *res;
+
+    /* round up */
+    size = PAGE_ALIGN(size);
+
+#ifdef DEBUG
+    printk("amiga_chip_alloc: allocate %ld bytes\n", size);
+#endif
+    res = kmalloc(sizeof(struct resource), GFP_KERNEL);
+    if (!res)
+	return NULL;
+    memset(res, 0, sizeof(struct resource));
+    res->name = name;
+
+    if (allocate_resource(&chipram_res, res, size, 0, UINT_MAX, PAGE_SIZE, NULL, NULL) < 0) {
+	kfree(res);
+	return NULL;
+    }
+    chipavail -= size;
+#ifdef DEBUG
+    printk("amiga_chip_alloc: returning %lx\n", res->start);
+#endif
+    return (void *)ZTWO_VADDR(res->start);
+}
+
+
+    /*
+     *  Warning:
+     *  amiga_chip_alloc_res is meant only for drivers that need to allocate
+     *  Chip RAM before kmalloc() is functional. As a consequence, those
+     *  drivers must not free that Chip RAM afterwards.
+     */
+
+void * __init amiga_chip_alloc_res(unsigned long size, struct resource *res)
+{
+    unsigned long start;
+
+    /* round up */
+    size = PAGE_ALIGN(size);
+    /* dmesg into chipmem prefers memory at the safe end */
+    start = CHIP_PHYSADDR + chipavail - size;
+
+#ifdef DEBUG
+    printk("amiga_chip_alloc_res: allocate %ld bytes\n", size);
+#endif
+    if (allocate_resource(&chipram_res, res, size, start, UINT_MAX, PAGE_SIZE, NULL, NULL) < 0) {
+	printk("amiga_chip_alloc_res: first alloc failed!\n");
+	if (allocate_resource(&chipram_res, res, size, 0, UINT_MAX, PAGE_SIZE, NULL, NULL) < 0)
+	    return NULL;
+    }
+    chipavail -= size;
+#ifdef DEBUG
+    printk("amiga_chip_alloc_res: returning %lx\n", res->start);
+#endif
+    return (void *)ZTWO_VADDR(res->start);
+}
+
+void amiga_chip_free(void *ptr)
+{
+    unsigned long start = ZTWO_PADDR(ptr);
+    struct resource **p, *res;
+    unsigned long size;
+
+    for (p = &chipram_res.child; (res = *p); p = &res->sibling) {
+	if (res->start != start)
+	    continue;
+	*p = res->sibling;
+	size = res->end-start;
+#ifdef DEBUG
+	printk("amiga_chip_free: free %ld bytes at %p\n", size, ptr);
+#endif
+	chipavail += size;
+	kfree(res);
+	return;
+    }
+    printk("amiga_chip_free: trying to free nonexistent region at %p\n", ptr);
+}
+
+
+unsigned long amiga_chip_avail(void)
+{
+#ifdef DEBUG
+	printk("amiga_chip_avail : %ld bytes\n", chipavail);
+#endif
+	return chipavail;
+}
