commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 0ddf3efbcae9..ceb42670aee5 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /****************************************************************************/
 
 /*

commit 2d24b532f95b8b1b61bf670ef5bdee52bcf59640
Author: Steven King <sfking@fdwdc.com>
Date:   Mon Jun 30 09:53:19 2014 -0700

    m68knommu: platform support for i2c devices on ColdFire SoC
    
    These changes based on work by Steven King <sfking@fdwdc.com> to support
    the i2c hardware modules on ColdFire SoC family devices.
    
    This is the per SoC hardware support. Contains a common platform device
    setup. Each of the SoC family members tends to have some minor local
    setup required to initialize the module. But all ColdFire family members
    use the same i2c hardware module.
    
    This i2c hardware module is the same as used in the Freescale iMX ARM
    based family of SoC devices. Steven's original patches were based on using
    a new and different i2c-coldfire.c driver. But this is not neccessary as
    we can use the existing Linux i2c-imx.c driver with no change required to
    it. And this patch is now based on using the existing i2c-imx driver.
    
    This patch only contains the ColdFire platform changes.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>
    Tested-by: Angelo Dureghello <angelo@sysam.it>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 4cf864f5ea7a..0ddf3efbcae9 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -110,6 +110,7 @@
 /*
  *	Define system peripheral IRQ usage.
  */
+#define	MCF_IRQ_I2C0		29		/* I2C, Level 5 */
 #define	MCF_IRQ_TIMER		30		/* Timer0, Level 6 */
 #define	MCF_IRQ_PROFILER	31		/* Timer1, Level 7 */
 #define	MCF_IRQ_UART0		73		/* UART0 */
@@ -138,6 +139,7 @@
 #define	MCFSIM_SWDICR		MCFSIM_ICR8	/* Watchdog timer ICR */
 #define	MCFSIM_TIMER1ICR	MCFSIM_ICR9	/* Timer 1 ICR */
 #define	MCFSIM_TIMER2ICR	MCFSIM_ICR10	/* Timer 2 ICR */
+#define	MCFSIM_I2CICR		MCFSIM_ICR11	/* I2C ICR */
 #define	MCFSIM_UART1ICR		MCFSIM_ICR12	/* UART 1 ICR */
 #define	MCFSIM_UART2ICR		MCFSIM_ICR13	/* UART 2 ICR */
 #ifdef CONFIG_M5206e
@@ -145,5 +147,11 @@
 #define	MCFSIM_DMA2ICR		MCFSIM_ICR15	/* DMA 2 ICR */
 #endif
 
+/*
+ * I2C Controller
+*/
+#define MCFI2C_BASE0		(MCF_MBAR + 0x1e0)
+#define MCFI2C_SIZE0		0x40
+
 /****************************************************************************/
 #endif	/* m5206sim_h */

commit 1419ea3b34db3e3cf5d6bedb3f913ed814022030
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Fri Sep 14 15:36:02 2012 +1000

    m68knommu: make ColdFire Chip Select register definitions absolute addresses
    
    Make all definitions of the ColdFire Chip Select registers absolute addresses.
    Currently some are relative to the MBAR peripheral region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the absolute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 3e86b035b290..4cf864f5ea7a 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -58,31 +58,31 @@
 #define	MCFSIM_DMR1		(MCF_MBAR + 0x5c) /* DRAM 1 Mask reg (r/w) */
 #define	MCFSIM_DCR1		(MCF_MBAR + 0x63) /* DRAM 1 Control reg (r/w) */
 
-#define	MCFSIM_CSAR0		0x64		/* CS 0 Address 0 reg (r/w) */
-#define	MCFSIM_CSMR0		0x68		/* CS 0 Mask 0 reg (r/w) */
-#define	MCFSIM_CSCR0		0x6e		/* CS 0 Control reg (r/w) */
-#define	MCFSIM_CSAR1		0x70		/* CS 1 Address reg (r/w) */
-#define	MCFSIM_CSMR1		0x74		/* CS 1 Mask reg (r/w) */
-#define	MCFSIM_CSCR1		0x7a		/* CS 1 Control reg (r/w) */
-#define	MCFSIM_CSAR2		0x7c		/* CS 2 Address reg (r/w) */
-#define	MCFSIM_CSMR2		0x80		/* CS 2 Mask reg (r/w) */
-#define	MCFSIM_CSCR2		0x86		/* CS 2 Control reg (r/w) */
-#define	MCFSIM_CSAR3		0x88		/* CS 3 Address reg (r/w) */
-#define	MCFSIM_CSMR3		0x8c		/* CS 3 Mask reg (r/w) */
-#define	MCFSIM_CSCR3		0x92		/* CS 3 Control reg (r/w) */
-#define	MCFSIM_CSAR4		0x94		/* CS 4 Address reg (r/w) */
-#define	MCFSIM_CSMR4		0x98		/* CS 4 Mask reg (r/w) */
-#define	MCFSIM_CSCR4		0x9e		/* CS 4 Control reg (r/w) */
-#define	MCFSIM_CSAR5		0xa0		/* CS 5 Address reg (r/w) */
-#define	MCFSIM_CSMR5		0xa4		/* CS 5 Mask reg (r/w) */
-#define	MCFSIM_CSCR5		0xaa		/* CS 5 Control reg (r/w) */
-#define	MCFSIM_CSAR6		0xac		/* CS 6 Address reg (r/w) */
-#define	MCFSIM_CSMR6		0xb0		/* CS 6 Mask reg (r/w) */
-#define	MCFSIM_CSCR6		0xb6		/* CS 6 Control reg (r/w) */
-#define	MCFSIM_CSAR7		0xb8		/* CS 7 Address reg (r/w) */
-#define	MCFSIM_CSMR7		0xbc		/* CS 7 Mask reg (r/w) */
-#define	MCFSIM_CSCR7		0xc2		/* CS 7 Control reg (r/w) */
-#define	MCFSIM_DMCR		0xc6		/* Default control */
+#define	MCFSIM_CSAR0		(MCF_MBAR + 0x64)	/* CS 0 Address reg */
+#define	MCFSIM_CSMR0		(MCF_MBAR + 0x68)	/* CS 0 Mask reg */
+#define	MCFSIM_CSCR0		(MCF_MBAR + 0x6e)	/* CS 0 Control reg */
+#define	MCFSIM_CSAR1		(MCF_MBAR + 0x70)	/* CS 1 Address reg */
+#define	MCFSIM_CSMR1		(MCF_MBAR + 0x74)	/* CS 1 Mask reg */
+#define	MCFSIM_CSCR1		(MCF_MBAR + 0x7a)	/* CS 1 Control reg */
+#define	MCFSIM_CSAR2		(MCF_MBAR + 0x7c)	/* CS 2 Address reg */
+#define	MCFSIM_CSMR2		(MCF_MBAR + 0x80)	/* CS 2 Mask reg */
+#define	MCFSIM_CSCR2		(MCF_MBAR + 0x86)	/* CS 2 Control reg */
+#define	MCFSIM_CSAR3		(MCF_MBAR + 0x88)	/* CS 3 Address reg */
+#define	MCFSIM_CSMR3		(MCF_MBAR + 0x8c)	/* CS 3 Mask reg */
+#define	MCFSIM_CSCR3		(MCF_MBAR + 0x92)	/* CS 3 Control reg */
+#define	MCFSIM_CSAR4		(MCF_MBAR + 0x94)	/* CS 4 Address reg */
+#define	MCFSIM_CSMR4		(MCF_MBAR + 0x98)	/* CS 4 Mask reg */
+#define	MCFSIM_CSCR4		(MCF_MBAR + 0x9e)	/* CS 4 Control reg */
+#define	MCFSIM_CSAR5		(MCF_MBAR + 0xa0)	/* CS 5 Address reg */
+#define	MCFSIM_CSMR5		(MCF_MBAR + 0xa4)	/* CS 5 Mask reg */
+#define	MCFSIM_CSCR5		(MCF_MBAR + 0xaa)	/* CS 5 Control reg */
+#define	MCFSIM_CSAR6		(MCF_MBAR + 0xac)	/* CS 6 Address reg */
+#define	MCFSIM_CSMR6		(MCF_MBAR + 0xb0)	/* CS 6 Mask reg */
+#define	MCFSIM_CSCR6		(MCF_MBAR + 0xb6)	/* CS 6 Control reg */
+#define	MCFSIM_CSAR7		(MCF_MBAR + 0xb8)	/* CS 7 Address reg */
+#define	MCFSIM_CSMR7		(MCF_MBAR + 0xbc)	/* CS 7 Mask reg */
+#define	MCFSIM_CSCR7		(MCF_MBAR + 0xc2)	/* CS 7 Control reg */
+#define	MCFSIM_DMCR		(MCF_MBAR + 0xc6)	/* Default control */
 
 #ifdef CONFIG_M5206e
 #define	MCFSIM_PAR		(MCF_MBAR + 0xca)	/* Pin Assignment */

commit c986a3d520395604ca29a7fb9fca60a455abcc44
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Fri Aug 17 16:48:16 2012 +1000

    m68knommu: make ColdFire Interrupt Source register definitions absolute addresses
    
    Make all definitions of the ColdFire Interrupt Source registers absolute
    addresses. Currently some are relative to the MBAR peripheral region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the absolute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index c78ff10c0153..3e86b035b290 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -21,23 +21,23 @@
 /*
  *	Define the 5206 SIM register set addresses.
  */
-#define	MCFSIM_SIMR		0x03		/* SIM Config reg (r/w) */
-#define	MCFSIM_ICR1		0x14		/* Intr Ctrl reg 1 (r/w) */
-#define	MCFSIM_ICR2		0x15		/* Intr Ctrl reg 2 (r/w) */
-#define	MCFSIM_ICR3		0x16		/* Intr Ctrl reg 3 (r/w) */
-#define	MCFSIM_ICR4		0x17		/* Intr Ctrl reg 4 (r/w) */
-#define	MCFSIM_ICR5		0x18		/* Intr Ctrl reg 5 (r/w) */
-#define	MCFSIM_ICR6		0x19		/* Intr Ctrl reg 6 (r/w) */
-#define	MCFSIM_ICR7		0x1a		/* Intr Ctrl reg 7 (r/w) */
-#define	MCFSIM_ICR8		0x1b		/* Intr Ctrl reg 8 (r/w) */
-#define	MCFSIM_ICR9		0x1c		/* Intr Ctrl reg 9 (r/w) */
-#define	MCFSIM_ICR10		0x1d		/* Intr Ctrl reg 10 (r/w) */
-#define	MCFSIM_ICR11		0x1e		/* Intr Ctrl reg 11 (r/w) */
-#define	MCFSIM_ICR12		0x1f		/* Intr Ctrl reg 12 (r/w) */
-#define	MCFSIM_ICR13		0x20		/* Intr Ctrl reg 13 (r/w) */
+#define	MCFSIM_SIMR		(MCF_MBAR + 0x03)	/* SIM Config reg */
+#define	MCFSIM_ICR1		(MCF_MBAR + 0x14)	/* Intr Ctrl reg 1 */
+#define	MCFSIM_ICR2		(MCF_MBAR + 0x15)	/* Intr Ctrl reg 2 */
+#define	MCFSIM_ICR3		(MCF_MBAR + 0x16)	/* Intr Ctrl reg 3 */
+#define	MCFSIM_ICR4		(MCF_MBAR + 0x17)	/* Intr Ctrl reg 4 */
+#define	MCFSIM_ICR5		(MCF_MBAR + 0x18)	/* Intr Ctrl reg 5 */
+#define	MCFSIM_ICR6		(MCF_MBAR + 0x19)	/* Intr Ctrl reg 6 */
+#define	MCFSIM_ICR7		(MCF_MBAR + 0x1a)	/* Intr Ctrl reg 7 */
+#define	MCFSIM_ICR8		(MCF_MBAR + 0x1b)	/* Intr Ctrl reg 8 */
+#define	MCFSIM_ICR9		(MCF_MBAR + 0x1c)	/* Intr Ctrl reg 9 */
+#define	MCFSIM_ICR10		(MCF_MBAR + 0x1d)	/* Intr Ctrl reg 10 */
+#define	MCFSIM_ICR11		(MCF_MBAR + 0x1e)	/* Intr Ctrl reg 11 */
+#define	MCFSIM_ICR12		(MCF_MBAR + 0x1f)	/* Intr Ctrl reg 12 */
+#define	MCFSIM_ICR13		(MCF_MBAR + 0x20)	/* Intr Ctrl reg 13 */
 #ifdef CONFIG_M5206e
-#define	MCFSIM_ICR14		0x21		/* Intr Ctrl reg 14 (r/w) */
-#define	MCFSIM_ICR15		0x22		/* Intr Ctrl reg 15 (r/w) */
+#define	MCFSIM_ICR14		(MCF_MBAR + 0x21)	/* Intr Ctrl reg 14 */
+#define	MCFSIM_ICR15		(MCF_MBAR + 0x22)	/* Intr Ctrl reg 15 */
 #endif
 
 #define	MCFSIM_IMR		(MCF_MBAR + 0x36)	/* Interrupt Mask */

commit a45f56b272e59527e41d7fbfc9b49dac9b90644c
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Fri Aug 17 16:20:23 2012 +1000

    m68knommu: make ColdFire Pin Assignment register definitions absolute addresses
    
    Make all definitions of the ColdFire Pin Assignment registers absolute
    addresses. Currently some are relative to the MBAR peripheral region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the absolute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 02a91f489cbf..c78ff10c0153 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -85,9 +85,9 @@
 #define	MCFSIM_DMCR		0xc6		/* Default control */
 
 #ifdef CONFIG_M5206e
-#define	MCFSIM_PAR		0xca		/* Pin Assignment reg (r/w) */
+#define	MCFSIM_PAR		(MCF_MBAR + 0xca)	/* Pin Assignment */
 #else
-#define	MCFSIM_PAR		0xcb		/* Pin Assignment reg (r/w) */
+#define	MCFSIM_PAR		(MCF_MBAR + 0xcb)	/* Pin Assignment */
 #endif
 
 #define	MCFTIMER_BASE1		(MCF_MBAR + 0x100)	/* Base of TIMER1 */

commit 660b73e356a63d67231aab49d23e83b1a5a9ec87
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Sun Jul 15 22:01:08 2012 +1000

    m68knommu: make ColdFire watchdog register definitions absolute addresses
    
    Make all definitions of the ColdFire Software watchdog registers absolute
    addresses. Currently some are relative to the MBAR peripheral region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the absolute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index d67ce08e508d..02a91f489cbf 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -46,8 +46,8 @@
 #define	MCFSIM_RSR		(MCF_MBAR + 0x40)	/* Reset Status */
 #define	MCFSIM_SYPCR		(MCF_MBAR + 0x41)	/* System Protection */
 
-#define	MCFSIM_SWIVR		0x42		/* SW Watchdog intr reg (r/w) */
-#define	MCFSIM_SWSR		0x43		/* SW Watchdog service (r/w) */
+#define	MCFSIM_SWIVR		(MCF_MBAR + 0x42)	/* SW Watchdog intr */
+#define	MCFSIM_SWSR		(MCF_MBAR + 0x43)	/* SW Watchdog srv */
 
 #define	MCFSIM_DCRR		(MCF_MBAR + 0x46) /* DRAM Refresh reg (r/w) */
 #define	MCFSIM_DCTR		(MCF_MBAR + 0x4a) /* DRAM Timing reg (r/w) */

commit e1e362dc074c2981e7f78d26bf38a4f14be52ecd
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Sun Jul 15 21:55:01 2012 +1000

    m68knommu: make ColdFire SYPCR and RSR register definitions absolute addresses
    
    Make all definitions of the ColdFire Reset and System registers absolute
    addresses. Currently some are relative to the MBAR peripheral region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the abolsute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index e8bae33aed60..d67ce08e508d 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -43,8 +43,8 @@
 #define	MCFSIM_IMR		(MCF_MBAR + 0x36)	/* Interrupt Mask */
 #define	MCFSIM_IPR		(MCF_MBAR + 0x3a)	/* Interrupt Pending */
 
-#define	MCFSIM_RSR		0x40		/* Reset Status reg (r/w) */
-#define	MCFSIM_SYPCR		0x41		/* System Protection reg (r/w)*/
+#define	MCFSIM_RSR		(MCF_MBAR + 0x40)	/* Reset Status */
+#define	MCFSIM_SYPCR		(MCF_MBAR + 0x41)	/* System Protection */
 
 #define	MCFSIM_SWIVR		0x42		/* SW Watchdog intr reg (r/w) */
 #define	MCFSIM_SWSR		0x43		/* SW Watchdog service (r/w) */

commit 6a3a786d02172b34d0ffba6f80bd1150da51125d
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Sun Jul 15 21:42:47 2012 +1000

    m68knommu: make ColdFire IMR and IPR register definitions absolute addresses
    
    Make all definitions of the ColdFire Interrupt Mask and Pending registers
    absolute addresses. Currently some are relative to the MBAR peripheral region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the absolute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 69722366b084..e8bae33aed60 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -40,8 +40,8 @@
 #define	MCFSIM_ICR15		0x22		/* Intr Ctrl reg 15 (r/w) */
 #endif
 
-#define MCFSIM_IMR		0x36		/* Interrupt Mask reg (r/w) */
-#define MCFSIM_IPR		0x3a		/* Interrupt Pend reg (r/w) */
+#define	MCFSIM_IMR		(MCF_MBAR + 0x36)	/* Interrupt Mask */
+#define	MCFSIM_IPR		(MCF_MBAR + 0x3a)	/* Interrupt Pending */
 
 #define	MCFSIM_RSR		0x40		/* Reset Status reg (r/w) */
 #define	MCFSIM_SYPCR		0x41		/* System Protection reg (r/w)*/

commit 8400ca322e2fb6771d2adfc05a745b8872af038d
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Sat Dec 24 00:10:48 2011 +1000

    m68knommu: make 5206 UART platform addressing consistent
    
    If we make all UART addressing consistent across all ColdFire family members
    then we will be able to remove the duplicated plaform data and use a single
    setup for all.
    
    So modify the ColdFire 5206 UART addressing so that:
    
    . UARTs are numbered from 0 up
    . base addresses are absolute (not relative to MBAR peripheral register)
    . use a common name for IRQs used
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 9015eadd5c00..69722366b084 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -100,11 +100,11 @@
 #define	MCFDMA_BASE1		(MCF_MBAR + 0x240)	/* Base address DMA 1 */
 
 #if defined(CONFIG_NETtel)
-#define	MCFUART_BASE1		0x180		/* Base address of UART1 */
-#define	MCFUART_BASE2		0x140		/* Base address of UART2 */
+#define	MCFUART_BASE0		(MCF_MBAR + 0x180)	/* Base address UART0 */
+#define	MCFUART_BASE1		(MCF_MBAR + 0x140)	/* Base address UART1 */
 #else
-#define	MCFUART_BASE1		0x140		/* Base address of UART1 */
-#define	MCFUART_BASE2		0x180		/* Base address of UART2 */
+#define	MCFUART_BASE0		(MCF_MBAR + 0x140)	/* Base address UART0 */
+#define	MCFUART_BASE1		(MCF_MBAR + 0x180)	/* Base address UART1 */
 #endif
 
 /*
@@ -112,6 +112,8 @@
  */
 #define	MCF_IRQ_TIMER		30		/* Timer0, Level 6 */
 #define	MCF_IRQ_PROFILER	31		/* Timer1, Level 7 */
+#define	MCF_IRQ_UART0		73		/* UART0 */
+#define	MCF_IRQ_UART1		74		/* UART1 */
 
 /*
  *	Generic GPIO

commit ce3de78a1c9504dba1781e47613b397e4028ae2b
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Wed Mar 9 14:19:08 2011 +1000

    m68knommu: remove ColdFire CLOCK_DIV config option
    
    The reality is that you do not need the abiltity to configure the
    clock divider for ColdFire CPUs. It is a fixed ratio on any given
    ColdFire family member. It is not the same for all ColdFire parts,
    but it is always the same in a model range. So hard define the divider
    for each supported ColdFire CPU type and remove the Kconfig option.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index dfd6d3f73584..9015eadd5c00 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -14,6 +14,7 @@
 
 #define	CPU_NAME		"COLDFIRE(m5206)"
 #define	CPU_INSTR_PER_JIFFY	3
+#define	MCF_BUSCLK		MCF_CLK
 
 #include <asm/m52xxacr.h>
 

commit 6a92e1982d5c538d1cfafbe4b0cb16d49306854f
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Sun Mar 6 23:01:46 2011 +1000

    m68knommu: clean up use of MBAR for DRAM registers on ColdFire start
    
    In some of the RAM size autodetection code on ColdFire CPU startup
    we reference DRAM registers relative to the MBAR register. Not all of
    the supported ColdFire CPUs have an MBAR, and currently this works
    because we fake an MBAR address on those registers. In an effort to
    clean this up, and eventually remove the fake MBAR setting make the
    DRAM register address definitions actually contain the MBAR (or IPSBAR
    as appropriate) value as required.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 7b58da5050a0..dfd6d3f73584 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -48,14 +48,14 @@
 #define	MCFSIM_SWIVR		0x42		/* SW Watchdog intr reg (r/w) */
 #define	MCFSIM_SWSR		0x43		/* SW Watchdog service (r/w) */
 
-#define	MCFSIM_DCRR		0x46		/* DRAM Refresh reg (r/w) */
-#define	MCFSIM_DCTR		0x4a		/* DRAM Timing reg (r/w) */
-#define	MCFSIM_DAR0		0x4c		/* DRAM 0 Address reg(r/w) */
-#define	MCFSIM_DMR0		0x50		/* DRAM 0 Mask reg (r/w) */
-#define	MCFSIM_DCR0		0x57		/* DRAM 0 Control reg (r/w) */
-#define	MCFSIM_DAR1		0x58		/* DRAM 1 Address reg (r/w) */
-#define	MCFSIM_DMR1		0x5c		/* DRAM 1 Mask reg (r/w) */
-#define	MCFSIM_DCR1		0x63		/* DRAM 1 Control reg (r/w) */
+#define	MCFSIM_DCRR		(MCF_MBAR + 0x46) /* DRAM Refresh reg (r/w) */
+#define	MCFSIM_DCTR		(MCF_MBAR + 0x4a) /* DRAM Timing reg (r/w) */
+#define	MCFSIM_DAR0		(MCF_MBAR + 0x4c) /* DRAM 0 Address reg(r/w) */
+#define	MCFSIM_DMR0		(MCF_MBAR + 0x50) /* DRAM 0 Mask reg (r/w) */
+#define	MCFSIM_DCR0		(MCF_MBAR + 0x57) /* DRAM 0 Control reg (r/w) */
+#define	MCFSIM_DAR1		(MCF_MBAR + 0x58) /* DRAM 1 Address reg (r/w) */
+#define	MCFSIM_DMR1		(MCF_MBAR + 0x5c) /* DRAM 1 Mask reg (r/w) */
+#define	MCFSIM_DCR1		(MCF_MBAR + 0x63) /* DRAM 1 Control reg (r/w) */
 
 #define	MCFSIM_CSAR0		0x64		/* CS 0 Address 0 reg (r/w) */
 #define	MCFSIM_CSMR0		0x68		/* CS 0 Mask 0 reg (r/w) */

commit 58f0ac98f386d2b335e5852e8feec828c43a0e13
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Wed Mar 9 09:57:14 2011 +1000

    m68knommu: remove use of MBAR in old-style ColdFire timer
    
    Not all ColdFire CPUs that use the old style timer hardware module use
    an MBAR set peripheral region. Move the TIMER base address defines to the
    per-CPU header files where we can set it correctly based on how the
    peripherals are mapped - instead of using a fake MBAR for some platforms.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 6fb656f18455..7b58da5050a0 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -89,6 +89,9 @@
 #define	MCFSIM_PAR		0xcb		/* Pin Assignment reg (r/w) */
 #endif
 
+#define	MCFTIMER_BASE1		(MCF_MBAR + 0x100)	/* Base of TIMER1 */
+#define	MCFTIMER_BASE2		(MCF_MBAR + 0x120)	/* Base of TIMER2 */
+
 #define	MCFSIM_PADDR		(MCF_MBAR + 0x1c5)	/* Parallel Direction (r/w) */
 #define	MCFSIM_PADAT		(MCF_MBAR + 0x1c9)	/* Parallel Port Value (r/w) */
 

commit babc08b7e953cd23e10d175d546309dedadaabea
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Sun Mar 6 00:54:36 2011 +1000

    m68knommu: move ColdFire DMA register addresses to per-cpu headers
    
    The base addresses of the ColdFire DMA unit registers belong with
    all the other address definitions in the per-cpu headers. The current
    definitions assume they are relative to an MBAR register. Not all
    ColdFire CPUs have an MBAR register. A clean address define can only
    be acheived in the per-cpu headers along with all the other chips
    peripheral base addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 561b03b5ddf8..6fb656f18455 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -92,6 +92,9 @@
 #define	MCFSIM_PADDR		(MCF_MBAR + 0x1c5)	/* Parallel Direction (r/w) */
 #define	MCFSIM_PADAT		(MCF_MBAR + 0x1c9)	/* Parallel Port Value (r/w) */
 
+#define	MCFDMA_BASE0		(MCF_MBAR + 0x200)	/* Base address DMA 0 */
+#define	MCFDMA_BASE1		(MCF_MBAR + 0x240)	/* Base address DMA 1 */
+
 #if defined(CONFIG_NETtel)
 #define	MCFUART_BASE1		0x180		/* Base address of UART1 */
 #define	MCFUART_BASE2		0x140		/* Base address of UART2 */

commit a12cf0a8c6e2763ac865aa31f296557e07432b8a
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Tue Nov 9 10:12:29 2010 +1000

    m68knommu: create bit definitions for the version 2 ColdFire cache controller
    
    The version 2 ColdFire CPU based cores all contain a similar cache
    controller unit. Create a set of bit flag definitions for the supporting
    registers.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index aa7ee48d5059..561b03b5ddf8 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -15,6 +15,8 @@
 #define	CPU_NAME		"COLDFIRE(m5206)"
 #define	CPU_INSTR_PER_JIFFY	3
 
+#include <asm/m52xxacr.h>
+
 /*
  *	Define the 5206 SIM register set addresses.
  */

commit 57015421d3f3deafb1f6ccf03a6fe0539763dbee
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Wed Nov 3 12:50:30 2010 +1000

    m68knommu: move UART addressing to part specific includes
    
    The ColdFire UART base addresses varies between the different ColdFire
    family members. Instead of keeping the base addresses with the UART
    definitions keep them with the other addresses definitions for each
    ColdFire part.
    
    The motivation for this move is so that when we add new ColdFire
    part definitions, they are all in a single file (and we shouldn't
    normally need to modify the UART definitions in mcfuart.h at all).
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index b882a210ee6e..aa7ee48d5059 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -90,6 +90,14 @@
 #define	MCFSIM_PADDR		(MCF_MBAR + 0x1c5)	/* Parallel Direction (r/w) */
 #define	MCFSIM_PADAT		(MCF_MBAR + 0x1c9)	/* Parallel Port Value (r/w) */
 
+#if defined(CONFIG_NETtel)
+#define	MCFUART_BASE1		0x180		/* Base address of UART1 */
+#define	MCFUART_BASE2		0x140		/* Base address of UART2 */
+#else
+#define	MCFUART_BASE1		0x140		/* Base address of UART1 */
+#define	MCFUART_BASE2		0x180		/* Base address of UART2 */
+#endif
+
 /*
  *	Define system peripheral IRQ usage.
  */
@@ -97,7 +105,7 @@
 #define	MCF_IRQ_PROFILER	31		/* Timer1, Level 7 */
 
 /*
- * Generic GPIO
+ *	Generic GPIO
  */
 #define MCFGPIO_PIN_MAX		8
 #define MCFGPIO_IRQ_VECBASE	-1

commit 733f31b764061d976a60c5ee454632d9562900ea
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Tue Nov 2 17:40:37 2010 +1000

    m68knommu: fix clock rate value reported for ColdFire 54xx parts
    
    The instruction timings of the ColdFire 54xx family parts are
    different to other version 4 parts (or version 2 or 3 parts for
    that matter too).
    
    Move the instruction timing setting into the ColdFire part
    specific headers, and set the 54xx value appropriately.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 6cc7a42cc425..b882a210ee6e 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -12,7 +12,8 @@
 #define	m5206sim_h
 /****************************************************************************/
 
-#define	CPU_NAME	"COLDFIRE(m5206)"
+#define	CPU_NAME		"COLDFIRE(m5206)"
+#define	CPU_INSTR_PER_JIFFY	3
 
 /*
  *	Define the 5206 SIM register set addresses.

commit 7fc82b655a169039d8a58fde609b5e778573d5ab
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Tue Nov 2 17:13:27 2010 +1000

    m68knommu: move ColdFire CPU names into their headers
    
    Move the ColdFire CPU names out of setup.c and into their repsective
    headers. That way when we add new ones we won't need to modify
    setup.c any more.
    
    Add the missing 548x CPU name.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 9c384e294af9..6cc7a42cc425 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -12,6 +12,7 @@
 #define	m5206sim_h
 /****************************************************************************/
 
+#define	CPU_NAME	"COLDFIRE(m5206)"
 
 /*
  *	Define the 5206 SIM register set addresses.

commit 04b75b10dceadf937e3707ecc3dfccf6a076fd29
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Tue May 19 14:52:40 2009 +1000

    m68knommu: simplify ColdFire "timers" clock initialization
    
    The ColdFire "timers" clock setup can be simplified. There is really no
    need for the flexible per-platform setup code. The clock interrupt can be
    hard defined per CPU platform (in CPU include files). This makes the
    actual timer code simpler.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index b50061aaf8f0..9c384e294af9 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -88,12 +88,19 @@
 #define	MCFSIM_PADDR		(MCF_MBAR + 0x1c5)	/* Parallel Direction (r/w) */
 #define	MCFSIM_PADAT		(MCF_MBAR + 0x1c9)	/* Parallel Port Value (r/w) */
 
+/*
+ *	Define system peripheral IRQ usage.
+ */
+#define	MCF_IRQ_TIMER		30		/* Timer0, Level 6 */
+#define	MCF_IRQ_PROFILER	31		/* Timer1, Level 7 */
+
 /*
  * Generic GPIO
  */
 #define MCFGPIO_PIN_MAX		8
 #define MCFGPIO_IRQ_VECBASE	-1
 #define MCFGPIO_IRQ_MAX		-1
+
 /*
  *	Some symbol defines for the Parallel Port Pin Assignment Register
  */
@@ -117,11 +124,5 @@
 #define	MCFSIM_DMA2ICR		MCFSIM_ICR15	/* DMA 2 ICR */
 #endif
 
-/*
- * Let the common interrupt handler code know that the ColdFire 5206*
- * family of CPU's only has a 16bit sized IMR register.
- */
-#define	MCFSIM_IMR_IS_16BITS
-
 /****************************************************************************/
 #endif	/* m5206sim_h */

commit f2154bef817ac3d0ea67b52526fd8e88898b66f9
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Tue May 19 14:38:08 2009 +1000

    m68knommu: merge old ColdFire interrupt controller masking macros
    
    Currently the code that supports setting the old style ColdFire interrupt
    controller mask registers is macros in the include files of each of the
    CPU types. Merge all these into a set of real masking functions in the
    old Coldfire interrupt controller code proper. All the macros are basically
    the same (excepting a register size difference on really early parts).
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 7be8a2d3e659..b50061aaf8f0 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -117,21 +117,11 @@
 #define	MCFSIM_DMA2ICR		MCFSIM_ICR15	/* DMA 2 ICR */
 #endif
 
-#if defined(CONFIG_M5206e)
-#define	MCFSIM_IMR_MASKALL	0xfffe		/* All SIM intr sources */
-#endif
-
 /*
- *	Macro to get and set IMR register. It is 16 bits on the 5206.
+ * Let the common interrupt handler code know that the ColdFire 5206*
+ * family of CPU's only has a 16bit sized IMR register.
  */
-#define	mcf_getimr()		\
-	*((volatile unsigned short *) (MCF_MBAR + MCFSIM_IMR))
-
-#define	mcf_setimr(imr)		\
-	*((volatile unsigned short *) (MCF_MBAR + MCFSIM_IMR)) = (imr)
-
-#define	mcf_getipr()		\
-	*((volatile unsigned short *) (MCF_MBAR + MCFSIM_IPR))
+#define	MCFSIM_IMR_IS_16BITS
 
 /****************************************************************************/
 #endif	/* m5206sim_h */

commit bc25b057fa0a0e4754b7e2524c509874649d11ae
Author: sfking@fdwdc.com <sfking@fdwdc.com>
Date:   Fri Jun 19 18:11:01 2009 -0700

    generic GPIO support for the Freescale Coldfire 5206.
    
    Add support for the 5206.
    
    Signed-off-by: Steven King <sfking@fdwdc.com>
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
index 7e3594dea88b..7be8a2d3e659 100644
--- a/arch/m68k/include/asm/m5206sim.h
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -85,9 +85,15 @@
 #define	MCFSIM_PAR		0xcb		/* Pin Assignment reg (r/w) */
 #endif
 
-#define	MCFSIM_PADDR		0x1c5		/* Parallel Direction (r/w) */
-#define	MCFSIM_PADAT		0x1c9		/* Parallel Port Value (r/w) */
+#define	MCFSIM_PADDR		(MCF_MBAR + 0x1c5)	/* Parallel Direction (r/w) */
+#define	MCFSIM_PADAT		(MCF_MBAR + 0x1c9)	/* Parallel Port Value (r/w) */
 
+/*
+ * Generic GPIO
+ */
+#define MCFGPIO_PIN_MAX		8
+#define MCFGPIO_IRQ_VECBASE	-1
+#define MCFGPIO_IRQ_MAX		-1
 /*
  *	Some symbol defines for the Parallel Port Pin Assignment Register
  */

commit 49148020bcb6910ce71417bd990a5ce7017f9bd3
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Jan 16 21:58:10 2009 +1000

    m68k,m68knommu: merge header files
    
    Merge header files for m68k and m68knommu to the single location:
    
        arch/m68k/include/asm
    
    The majority of this patch was the result of the
    script that is included in the changelog below.
    
    The script was originally written by Arnd Bergman and
    exten by me to cover a few more files.
    
    When the header files differed the script uses the following:
    
    The original m68k file is named <file>_mm.h  [mm for memory manager]
    The m68knommu file is named <file>_no.h [no for no memory manager]
    
    The files uses the following include guard:
    
    This include gaurd works as the m68knommu toolchain set
    the __uClinux__ symbol - so this should work in userspace too.
    
    Merging the header files for m68k and m68knommu exposes the
    (unexpected?) ABI differences thus it is easier to actually
    identify these and thus to fix them.
    
    The commit has been build tested with both a m68k and
    a m68knommu toolchain - with success.
    
    The commit has also been tested with "make headers_check"
    and this patch fixes make headers_check for m68knommu.
    
    The script used:
    TARGET=arch/m68k/include/asm
    SOURCE=arch/m68knommu/include/asm
    
    INCLUDE="cachectl.h errno.h fcntl.h hwtest.h ioctls.h ipcbuf.h \
    linkage.h math-emu.h md.h mman.h movs.h msgbuf.h openprom.h \
    oplib.h poll.h posix_types.h resource.h rtc.h sembuf.h shmbuf.h \
    shm.h shmparam.h socket.h sockios.h spinlock.h statfs.h stat.h \
    termbits.h termios.h tlb.h types.h user.h"
    
    EQUAL="auxvec.h cputime.h device.h emergency-restart.h futex.h \
    ioctl.h irq_regs.h kdebug.h local.h mutex.h percpu.h \
    sections.h topology.h"
    
    NOMUUFILES="anchor.h bootstd.h coldfire.h commproc.h dbg.h \
    elia.h flat.h m5206sim.h m520xsim.h m523xsim.h m5249sim.h \
    m5272sim.h m527xsim.h m528xsim.h m5307sim.h m532xsim.h \
    m5407sim.h m68360_enet.h m68360.h m68360_pram.h m68360_quicc.h \
    m68360_regs.h MC68328.h MC68332.h MC68EZ328.h MC68VZ328.h \
    mcfcache.h mcfdma.h mcfmbus.h mcfne.h mcfpci.h mcfpit.h \
    mcfsim.h mcfsmc.h mcftimer.h mcfuart.h mcfwdebug.h \
    nettel.h quicc_simple.h smp.h"
    
    FILES="atomic.h bitops.h bootinfo.h bug.h bugs.h byteorder.h cache.h \
    cacheflush.h checksum.h current.h delay.h div64.h \
    dma-mapping.h dma.h elf.h entry.h fb.h fpu.h hardirq.h hw_irq.h io.h \
    irq.h kmap_types.h machdep.h mc146818rtc.h mmu.h mmu_context.h \
    module.h page.h page_offset.h param.h pci.h pgalloc.h \
    pgtable.h processor.h ptrace.h scatterlist.h segment.h \
    setup.h sigcontext.h siginfo.h signal.h string.h system.h swab.h \
    thread_info.h timex.h tlbflush.h traps.h uaccess.h ucontext.h \
    unaligned.h unistd.h"
    
    mergefile() {
            BASE=${1%.h}
            git mv ${SOURCE}/$1 ${TARGET}/${BASE}_no.h
            git mv ${TARGET}/$1 ${TARGET}/${BASE}_mm.h
    
    cat << EOF > ${TARGET}/$1
    EOF
    
            git add ${TARGET}/$1
    }
    
    set -e
    
    mkdir -p ${TARGET}
    
    git mv include/asm-m68k/* ${TARGET}
    rmdir include/asm-m68k
    
    git rm ${SOURCE}/Kbuild
    for F in $INCLUDE $EQUAL; do
            git rm ${SOURCE}/$F
    done
    
    for F in $NOMUUFILES; do
            git mv ${SOURCE}/$F ${TARGET}/$F
    done
    
    for F in $FILES ; do
            mergefile $F
    done
    
    rmdir arch/m68knommu/include/asm
    rmdir arch/m68knommu/include
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m5206sim.h b/arch/m68k/include/asm/m5206sim.h
new file mode 100644
index 000000000000..7e3594dea88b
--- /dev/null
+++ b/arch/m68k/include/asm/m5206sim.h
@@ -0,0 +1,131 @@
+/****************************************************************************/
+
+/*
+ *	m5206sim.h -- ColdFire 5206 System Integration Module support.
+ *
+ *	(C) Copyright 1999, Greg Ungerer (gerg@snapgear.com)
+ * 	(C) Copyright 2000, Lineo Inc. (www.lineo.com) 
+ */
+
+/****************************************************************************/
+#ifndef	m5206sim_h
+#define	m5206sim_h
+/****************************************************************************/
+
+
+/*
+ *	Define the 5206 SIM register set addresses.
+ */
+#define	MCFSIM_SIMR		0x03		/* SIM Config reg (r/w) */
+#define	MCFSIM_ICR1		0x14		/* Intr Ctrl reg 1 (r/w) */
+#define	MCFSIM_ICR2		0x15		/* Intr Ctrl reg 2 (r/w) */
+#define	MCFSIM_ICR3		0x16		/* Intr Ctrl reg 3 (r/w) */
+#define	MCFSIM_ICR4		0x17		/* Intr Ctrl reg 4 (r/w) */
+#define	MCFSIM_ICR5		0x18		/* Intr Ctrl reg 5 (r/w) */
+#define	MCFSIM_ICR6		0x19		/* Intr Ctrl reg 6 (r/w) */
+#define	MCFSIM_ICR7		0x1a		/* Intr Ctrl reg 7 (r/w) */
+#define	MCFSIM_ICR8		0x1b		/* Intr Ctrl reg 8 (r/w) */
+#define	MCFSIM_ICR9		0x1c		/* Intr Ctrl reg 9 (r/w) */
+#define	MCFSIM_ICR10		0x1d		/* Intr Ctrl reg 10 (r/w) */
+#define	MCFSIM_ICR11		0x1e		/* Intr Ctrl reg 11 (r/w) */
+#define	MCFSIM_ICR12		0x1f		/* Intr Ctrl reg 12 (r/w) */
+#define	MCFSIM_ICR13		0x20		/* Intr Ctrl reg 13 (r/w) */
+#ifdef CONFIG_M5206e
+#define	MCFSIM_ICR14		0x21		/* Intr Ctrl reg 14 (r/w) */
+#define	MCFSIM_ICR15		0x22		/* Intr Ctrl reg 15 (r/w) */
+#endif
+
+#define MCFSIM_IMR		0x36		/* Interrupt Mask reg (r/w) */
+#define MCFSIM_IPR		0x3a		/* Interrupt Pend reg (r/w) */
+
+#define	MCFSIM_RSR		0x40		/* Reset Status reg (r/w) */
+#define	MCFSIM_SYPCR		0x41		/* System Protection reg (r/w)*/
+
+#define	MCFSIM_SWIVR		0x42		/* SW Watchdog intr reg (r/w) */
+#define	MCFSIM_SWSR		0x43		/* SW Watchdog service (r/w) */
+
+#define	MCFSIM_DCRR		0x46		/* DRAM Refresh reg (r/w) */
+#define	MCFSIM_DCTR		0x4a		/* DRAM Timing reg (r/w) */
+#define	MCFSIM_DAR0		0x4c		/* DRAM 0 Address reg(r/w) */
+#define	MCFSIM_DMR0		0x50		/* DRAM 0 Mask reg (r/w) */
+#define	MCFSIM_DCR0		0x57		/* DRAM 0 Control reg (r/w) */
+#define	MCFSIM_DAR1		0x58		/* DRAM 1 Address reg (r/w) */
+#define	MCFSIM_DMR1		0x5c		/* DRAM 1 Mask reg (r/w) */
+#define	MCFSIM_DCR1		0x63		/* DRAM 1 Control reg (r/w) */
+
+#define	MCFSIM_CSAR0		0x64		/* CS 0 Address 0 reg (r/w) */
+#define	MCFSIM_CSMR0		0x68		/* CS 0 Mask 0 reg (r/w) */
+#define	MCFSIM_CSCR0		0x6e		/* CS 0 Control reg (r/w) */
+#define	MCFSIM_CSAR1		0x70		/* CS 1 Address reg (r/w) */
+#define	MCFSIM_CSMR1		0x74		/* CS 1 Mask reg (r/w) */
+#define	MCFSIM_CSCR1		0x7a		/* CS 1 Control reg (r/w) */
+#define	MCFSIM_CSAR2		0x7c		/* CS 2 Address reg (r/w) */
+#define	MCFSIM_CSMR2		0x80		/* CS 2 Mask reg (r/w) */
+#define	MCFSIM_CSCR2		0x86		/* CS 2 Control reg (r/w) */
+#define	MCFSIM_CSAR3		0x88		/* CS 3 Address reg (r/w) */
+#define	MCFSIM_CSMR3		0x8c		/* CS 3 Mask reg (r/w) */
+#define	MCFSIM_CSCR3		0x92		/* CS 3 Control reg (r/w) */
+#define	MCFSIM_CSAR4		0x94		/* CS 4 Address reg (r/w) */
+#define	MCFSIM_CSMR4		0x98		/* CS 4 Mask reg (r/w) */
+#define	MCFSIM_CSCR4		0x9e		/* CS 4 Control reg (r/w) */
+#define	MCFSIM_CSAR5		0xa0		/* CS 5 Address reg (r/w) */
+#define	MCFSIM_CSMR5		0xa4		/* CS 5 Mask reg (r/w) */
+#define	MCFSIM_CSCR5		0xaa		/* CS 5 Control reg (r/w) */
+#define	MCFSIM_CSAR6		0xac		/* CS 6 Address reg (r/w) */
+#define	MCFSIM_CSMR6		0xb0		/* CS 6 Mask reg (r/w) */
+#define	MCFSIM_CSCR6		0xb6		/* CS 6 Control reg (r/w) */
+#define	MCFSIM_CSAR7		0xb8		/* CS 7 Address reg (r/w) */
+#define	MCFSIM_CSMR7		0xbc		/* CS 7 Mask reg (r/w) */
+#define	MCFSIM_CSCR7		0xc2		/* CS 7 Control reg (r/w) */
+#define	MCFSIM_DMCR		0xc6		/* Default control */
+
+#ifdef CONFIG_M5206e
+#define	MCFSIM_PAR		0xca		/* Pin Assignment reg (r/w) */
+#else
+#define	MCFSIM_PAR		0xcb		/* Pin Assignment reg (r/w) */
+#endif
+
+#define	MCFSIM_PADDR		0x1c5		/* Parallel Direction (r/w) */
+#define	MCFSIM_PADAT		0x1c9		/* Parallel Port Value (r/w) */
+
+/*
+ *	Some symbol defines for the Parallel Port Pin Assignment Register
+ */
+#ifdef CONFIG_M5206e
+#define MCFSIM_PAR_DREQ0        0x100           /* Set to select DREQ0 input */
+                                                /* Clear to select T0 input */
+#define MCFSIM_PAR_DREQ1        0x200           /* Select DREQ1 input */
+                                                /* Clear to select T0 output */
+#endif
+
+/*
+ *	Some symbol defines for the Interrupt Control Register
+ */
+#define	MCFSIM_SWDICR		MCFSIM_ICR8	/* Watchdog timer ICR */
+#define	MCFSIM_TIMER1ICR	MCFSIM_ICR9	/* Timer 1 ICR */
+#define	MCFSIM_TIMER2ICR	MCFSIM_ICR10	/* Timer 2 ICR */
+#define	MCFSIM_UART1ICR		MCFSIM_ICR12	/* UART 1 ICR */
+#define	MCFSIM_UART2ICR		MCFSIM_ICR13	/* UART 2 ICR */
+#ifdef CONFIG_M5206e
+#define	MCFSIM_DMA1ICR		MCFSIM_ICR14	/* DMA 1 ICR */
+#define	MCFSIM_DMA2ICR		MCFSIM_ICR15	/* DMA 2 ICR */
+#endif
+
+#if defined(CONFIG_M5206e)
+#define	MCFSIM_IMR_MASKALL	0xfffe		/* All SIM intr sources */
+#endif
+
+/*
+ *	Macro to get and set IMR register. It is 16 bits on the 5206.
+ */
+#define	mcf_getimr()		\
+	*((volatile unsigned short *) (MCF_MBAR + MCFSIM_IMR))
+
+#define	mcf_setimr(imr)		\
+	*((volatile unsigned short *) (MCF_MBAR + MCFSIM_IMR)) = (imr)
+
+#define	mcf_getipr()		\
+	*((volatile unsigned short *) (MCF_MBAR + MCFSIM_IPR))
+
+/****************************************************************************/
+#endif	/* m5206sim_h */
