commit 8e8e69d67e5fad1a1edf97acebd649a6c8f1febd
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:17:59 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 285
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation version 2 of the license this program
      is distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 100 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141900.918357685@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/m68k/include/asm/mcfgpio.h b/arch/m68k/include/asm/mcfgpio.h
index 66203c334c6f..27f32cc81da6 100644
--- a/arch/m68k/include/asm/mcfgpio.h
+++ b/arch/m68k/include/asm/mcfgpio.h
@@ -1,16 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Coldfire generic GPIO support.
  *
  * (C) Copyright 2009, Steven King <sfking@fdwdc.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; version 2 of the License.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
  */
 
 #ifndef mcfgpio_h

commit 83c6bdb827c9422fe6e02130d9546800143304c1
Author: Steven King <sfking@fdwdc.com>
Date:   Wed May 21 16:00:33 2014 -0700

    m68knommu: Implement gpio support for m54xx.
    
    Singed-off-by: Steven King <sfking@fdwdc.com>
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/mcfgpio.h b/arch/m68k/include/asm/mcfgpio.h
index c41ebf45f1d0..66203c334c6f 100644
--- a/arch/m68k/include/asm/mcfgpio.h
+++ b/arch/m68k/include/asm/mcfgpio.h
@@ -139,7 +139,8 @@ static inline void gpio_free(unsigned gpio)
 
 #if defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
     defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
-    defined(CONFIG_M53xx) || defined(CONFIG_M5441x)
+    defined(CONFIG_M53xx) || defined(CONFIG_M54xx) || \
+    defined(CONFIG_M5441x)
 /*
  * These parts have an 'Edge' Port module (external interrupt/GPIO) which uses
  * read-modify-write to change an output and a GPIO module which has separate
@@ -195,7 +196,8 @@ static inline u32 __mcfgpio_ppdr(unsigned gpio)
 		return MCFSIM2_GPIO1READ;
 #elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
       defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
-      defined(CONFIG_M53xx) || defined(CONFIG_M5441x)
+      defined(CONFIG_M53xx) || defined(CONFIG_M54xx) || \
+      defined(CONFIG_M5441x)
 #if !defined(CONFIG_M5441x)
 	if (gpio < 8)
 		return MCFEPORT_EPPDR;
@@ -237,7 +239,8 @@ static inline u32 __mcfgpio_podr(unsigned gpio)
 		return MCFSIM2_GPIO1WRITE;
 #elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
       defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
-      defined(CONFIG_M53xx) || defined(CONFIG_M5441x)
+      defined(CONFIG_M53xx) || defined(CONFIG_M54xx) || \
+      defined(CONFIG_M5441x)
 #if !defined(CONFIG_M5441x)
 	if (gpio < 8)
 		return MCFEPORT_EPDR;
@@ -279,7 +282,8 @@ static inline u32 __mcfgpio_pddr(unsigned gpio)
 		return MCFSIM2_GPIO1ENABLE;
 #elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
       defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
-      defined(CONFIG_M53xx) || defined(CONFIG_M5441x)
+      defined(CONFIG_M53xx) || defined(CONFIG_M54xx) || \
+      defined(CONFIG_M5441x)
 #if !defined(CONFIG_M5441x)
 	if (gpio < 8)
 		return MCFEPORT_EPDDR;

commit 6eac402783441543ffc582f5e6c942d488d848b0
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Mon Nov 5 12:01:38 2012 +1000

    m68knommu: create and use a common M53xx ColdFire class of CPUs
    
    The current CONFIG_M532x support definitions are actually common to a larger
    set of version 3 ColdFire CPU types. In the future we want to add support for
    the 537x family. It is very similar to the 532x internally, and will be able
    to use most of the same definitions.
    
    Create a CONFIG_M53xx option that is enabled to support any of the common
    532x and 537x CPU types. Convert the current users of CONFIG_M532x to use
    CONFIG_M53xx instead.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/mcfgpio.h b/arch/m68k/include/asm/mcfgpio.h
index fa1059f50dfc..c41ebf45f1d0 100644
--- a/arch/m68k/include/asm/mcfgpio.h
+++ b/arch/m68k/include/asm/mcfgpio.h
@@ -104,7 +104,7 @@ static inline void gpio_free(unsigned gpio)
 #if defined(CONFIG_M5206) || defined(CONFIG_M5206e) || \
     defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
     defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
-    defined(CONFIG_M532x) || defined(CONFIG_M54xx) || \
+    defined(CONFIG_M53xx) || defined(CONFIG_M54xx) || \
     defined(CONFIG_M5441x)
 
 /* These parts have GPIO organized by 8 bit ports */
@@ -139,7 +139,7 @@ static inline void gpio_free(unsigned gpio)
 
 #if defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
     defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
-    defined(CONFIG_M532x) || defined(CONFIG_M5441x)
+    defined(CONFIG_M53xx) || defined(CONFIG_M5441x)
 /*
  * These parts have an 'Edge' Port module (external interrupt/GPIO) which uses
  * read-modify-write to change an output and a GPIO module which has separate
@@ -195,7 +195,7 @@ static inline u32 __mcfgpio_ppdr(unsigned gpio)
 		return MCFSIM2_GPIO1READ;
 #elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
       defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
-      defined(CONFIG_M532x) || defined(CONFIG_M5441x)
+      defined(CONFIG_M53xx) || defined(CONFIG_M5441x)
 #if !defined(CONFIG_M5441x)
 	if (gpio < 8)
 		return MCFEPORT_EPPDR;
@@ -237,7 +237,7 @@ static inline u32 __mcfgpio_podr(unsigned gpio)
 		return MCFSIM2_GPIO1WRITE;
 #elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
       defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
-      defined(CONFIG_M532x) || defined(CONFIG_M5441x)
+      defined(CONFIG_M53xx) || defined(CONFIG_M5441x)
 #if !defined(CONFIG_M5441x)
 	if (gpio < 8)
 		return MCFEPORT_EPDR;
@@ -279,7 +279,7 @@ static inline u32 __mcfgpio_pddr(unsigned gpio)
 		return MCFSIM2_GPIO1ENABLE;
 #elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
       defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
-      defined(CONFIG_M532x) || defined(CONFIG_M5441x)
+      defined(CONFIG_M53xx) || defined(CONFIG_M5441x)
 #if !defined(CONFIG_M5441x)
 	if (gpio < 8)
 		return MCFEPORT_EPDDR;

commit bea8bcb12da09bd35cdada395d0d0db1aee2ba4c
Author: Steven King <sfking@fdwdc.com>
Date:   Wed Jun 6 14:28:31 2012 -0700

    m68knommu: Add support for the Coldfire m5441x.
    
    Add support for the Coldfire 5441x (54410/54415/54416/54417/54418).  Currently
    we only support noMMU mode.  It requires the PIT patch posted previously as it
    uses the PIT instead of the dma timer as a clock source so we can get all that
    GENERIC_CLOCKEVENTS goodness.  It also adds some simple clk definitions and
    very simple minded power management.  The gpio code is tweeked and some
    additional devices are added to devices.c.  The Makefile uses -mv4e as
    apparently, the only difference a v4m (m5441x) and a v4e is the later has a
    FPU, which I don't think should matter to us in the kernel.
    
    Signed-off-by: Steven King <sfking@fdwdc.com>
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/mcfgpio.h b/arch/m68k/include/asm/mcfgpio.h
index b2471a5f02eb..fa1059f50dfc 100644
--- a/arch/m68k/include/asm/mcfgpio.h
+++ b/arch/m68k/include/asm/mcfgpio.h
@@ -104,7 +104,8 @@ static inline void gpio_free(unsigned gpio)
 #if defined(CONFIG_M5206) || defined(CONFIG_M5206e) || \
     defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
     defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
-    defined(CONFIG_M532x) || defined(CONFIG_M54xx)
+    defined(CONFIG_M532x) || defined(CONFIG_M54xx) || \
+    defined(CONFIG_M5441x)
 
 /* These parts have GPIO organized by 8 bit ports */
 
@@ -137,7 +138,8 @@ static inline void gpio_free(unsigned gpio)
 #define mcfgpio_port(gpio)		((gpio) / MCFGPIO_PORTSIZE)
 
 #if defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
-    defined(CONFIG_M527x) || defined(CONFIG_M528x) || defined(CONFIG_M532x)
+    defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
+    defined(CONFIG_M532x) || defined(CONFIG_M5441x)
 /*
  * These parts have an 'Edge' Port module (external interrupt/GPIO) which uses
  * read-modify-write to change an output and a GPIO module which has separate
@@ -149,6 +151,9 @@ static inline void gpio_free(unsigned gpio)
  * read-modify-write as well as those controlled by the EPORT and GPIO modules.
  */
 #define MCFGPIO_SCR_START		40
+#elif defined(CONFIGM5441x)
+/* The m5441x EPORT doesn't have its own GPIO port, uses PORT C */
+#define MCFGPIO_SCR_START		0
 #else
 #define MCFGPIO_SCR_START		8
 #endif
@@ -189,7 +194,9 @@ static inline u32 __mcfgpio_ppdr(unsigned gpio)
 	else
 		return MCFSIM2_GPIO1READ;
 #elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
-      defined(CONFIG_M527x) || defined(CONFIG_M528x) || defined(CONFIG_M532x)
+      defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
+      defined(CONFIG_M532x) || defined(CONFIG_M5441x)
+#if !defined(CONFIG_M5441x)
 	if (gpio < 8)
 		return MCFEPORT_EPPDR;
 #if defined(CONFIG_M528x)
@@ -201,8 +208,9 @@ static inline u32 __mcfgpio_ppdr(unsigned gpio)
 		return MCFQADC_PORTQA;
 	else if (gpio < 40)
 		return MCFQADC_PORTQB;
-#endif
+#endif /* defined(CONFIG_M528x) */
 	else
+#endif /* !defined(CONFIG_M5441x) */
 		return MCFGPIO_PPDR + mcfgpio_port(gpio - MCFGPIO_SCR_START);
 #else
 	return 0;
@@ -228,7 +236,9 @@ static inline u32 __mcfgpio_podr(unsigned gpio)
 	else
 		return MCFSIM2_GPIO1WRITE;
 #elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
-      defined(CONFIG_M527x) || defined(CONFIG_M528x) || defined(CONFIG_M532x)
+      defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
+      defined(CONFIG_M532x) || defined(CONFIG_M5441x)
+#if !defined(CONFIG_M5441x)
 	if (gpio < 8)
 		return MCFEPORT_EPDR;
 #if defined(CONFIG_M528x)
@@ -240,8 +250,9 @@ static inline u32 __mcfgpio_podr(unsigned gpio)
 		return MCFQADC_PORTQA;
 	else if (gpio < 40)
 		return MCFQADC_PORTQB;
-#endif
+#endif /* defined(CONFIG_M528x) */
 	else
+#endif /* !defined(CONFIG_M5441x) */
 		return MCFGPIO_PODR + mcfgpio_port(gpio - MCFGPIO_SCR_START);
 #else
 	return 0;
@@ -267,7 +278,9 @@ static inline u32 __mcfgpio_pddr(unsigned gpio)
 	else
 		return MCFSIM2_GPIO1ENABLE;
 #elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
-      defined(CONFIG_M527x) || defined(CONFIG_M528x) || defined(CONFIG_M532x)
+      defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
+      defined(CONFIG_M532x) || defined(CONFIG_M5441x)
+#if !defined(CONFIG_M5441x)
 	if (gpio < 8)
 		return MCFEPORT_EPDDR;
 #if defined(CONFIG_M528x)
@@ -279,8 +292,9 @@ static inline u32 __mcfgpio_pddr(unsigned gpio)
 		return MCFQADC_DDRQA;
 	else if (gpio < 40)
 		return MCFQADC_DDRQB;
-#endif
+#endif /* defined(CONFIG_M528x) */
 	else
+#endif /* !defined(CONFIG_M5441x) */
 		return MCFGPIO_PDDR + mcfgpio_port(gpio - MCFGPIO_SCR_START);
 #else
 	return 0;

commit 04e037aa4e5f71d11c004e844339d385a89733f6
Author: Steven King <sfking@fdwdc.com>
Date:   Tue Jun 5 08:23:08 2012 -0700

    m68knommu: Add support for the Coldfire 5251/5253
    
    Basic support for the Coldfire 5251/5253.
    
    Signed-off-by: Steven king <sfking@fdwdc.com>
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/mcfgpio.h b/arch/m68k/include/asm/mcfgpio.h
index 67ba20ffedbe..b2471a5f02eb 100644
--- a/arch/m68k/include/asm/mcfgpio.h
+++ b/arch/m68k/include/asm/mcfgpio.h
@@ -122,7 +122,7 @@ static inline void gpio_free(unsigned gpio)
 #define mcfgpio_read(port)		__raw_readw(port)
 #define mcfgpio_write(data, port)	__raw_writew(data, port)
 
-#elif defined(CONFIG_M5249)
+#elif defined(CONFIG_M5249) || defined(CONFIG_M525x)
 
 /* These parts have GPIO organized by 32 bit ports */
 
@@ -183,7 +183,7 @@ static inline u32 __mcfgpio_ppdr(unsigned gpio)
 		return MCFSIM_PBDAT;
 	else
 		return MCFSIM_PCDAT;
-#elif defined(CONFIG_M5249)
+#elif defined(CONFIG_M5249) || defined(CONFIG_M525x)
 	if (gpio < 32)
 		return MCFSIM2_GPIOREAD;
 	else
@@ -222,7 +222,7 @@ static inline u32 __mcfgpio_podr(unsigned gpio)
 		return MCFSIM_PBDAT;
 	else
 		return MCFSIM_PCDAT;
-#elif defined(CONFIG_M5249)
+#elif defined(CONFIG_M5249) || defined(CONFIG_M525x)
 	if (gpio < 32)
 		return MCFSIM2_GPIOWRITE;
 	else
@@ -261,7 +261,7 @@ static inline u32 __mcfgpio_pddr(unsigned gpio)
 		return MCFSIM_PBDDR;
 	else
 		return MCFSIM_PCDDR;
-#elif defined(CONFIG_M5249)
+#elif defined(CONFIG_M5249) || defined(CONFIG_M525x)
 	if (gpio < 32)
 		return MCFSIM2_GPIOENABLE;
 	else

commit eac57949947fa24f47a2e993a1dbbfdb573b4301
Author: Steven King <sfking@fdwdc.com>
Date:   Mon May 21 13:10:19 2012 -0700

    m68knommu: refactor Coldfire GPIO not to require GPIOLIB, eliminate mcf_gpio_chips.
    
    If we're not connecting external GPIO extenders via i2c or spi or whatever, we
    probably don't need GPIOLIB.  If we provide an alternate implementation of
    the GPIOLIB functions to use when only on-chip GPIO is needed, we can change
    ARCH_REQUIRE_GPIOLIB to ARCH_WANTS_OPTIONAL_GPIOLIB so that GPIOLIB becomes
    optional.
    
    The downside is that in the GPIOLIB=n case, we lose all error checking done by
    gpiolib, ie multiply allocating the gpio, free'ing gpio etc., so that the
    only checking that can be done is if we reference a gpio on an external part.
    Targets that need the extra error checking can still select GPIOLIB=y.
    
    For the case where GPIOLIB=y, we can simplify the table of gpio chips to use a
    single chip, eliminating the tables of chips in the 5xxx.c files.  The
    original motivation for the definition of multiple chips was to match the way
    many of the Coldfire variants defined their gpio as a spare array in memory.
    However, all this really gains us is some error checking when we request a
    gpio, gpiolib can check that it doesn't fall in one of the holes.  If thats
    important, I think we can still come up with a better way of accomplishing
    that.
    
    Also in this patch is some general cleanup and reorganizing of the gpio header
    files (I'm sure I must have had a reason why I sometimes used a prefix of
    mcf_gpio and other times mcfgpio but for the life of me I can't think of it
    now).
    
    Signed-off-by: Steven King <sfking@fdwdc.com>
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/mcfgpio.h b/arch/m68k/include/asm/mcfgpio.h
index fe468eaa51e0..67ba20ffedbe 100644
--- a/arch/m68k/include/asm/mcfgpio.h
+++ b/arch/m68k/include/asm/mcfgpio.h
@@ -16,82 +16,275 @@
 #ifndef mcfgpio_h
 #define mcfgpio_h
 
-#include <linux/io.h>
+#ifdef CONFIG_GPIOLIB
 #include <asm-generic/gpio.h>
+#else
+
+int __mcfgpio_get_value(unsigned gpio);
+void __mcfgpio_set_value(unsigned gpio, int value);
+int __mcfgpio_direction_input(unsigned gpio);
+int __mcfgpio_direction_output(unsigned gpio, int value);
+int __mcfgpio_request(unsigned gpio);
+void __mcfgpio_free(unsigned gpio);
+
+/* our alternate 'gpiolib' functions */
+static inline int __gpio_get_value(unsigned gpio)
+{
+	if (gpio < MCFGPIO_PIN_MAX)
+		return __mcfgpio_get_value(gpio);
+	else
+		return -EINVAL;
+}
+
+static inline void __gpio_set_value(unsigned gpio, int value)
+{
+	if (gpio < MCFGPIO_PIN_MAX)
+		__mcfgpio_set_value(gpio, value);
+}
+
+static inline int __gpio_cansleep(unsigned gpio)
+{
+	if (gpio < MCFGPIO_PIN_MAX)
+		return 0;
+	else
+		return -EINVAL;
+}
+
+static inline int __gpio_to_irq(unsigned gpio)
+{
+	return -EINVAL;
+}
+
+static inline int gpio_direction_input(unsigned gpio)
+{
+	if (gpio < MCFGPIO_PIN_MAX)
+		return __mcfgpio_direction_input(gpio);
+	else
+		return -EINVAL;
+}
+
+static inline int gpio_direction_output(unsigned gpio, int value)
+{
+	if (gpio < MCFGPIO_PIN_MAX)
+		return __mcfgpio_direction_output(gpio, value);
+	else
+		return -EINVAL;
+}
+
+static inline int gpio_request(unsigned gpio, const char *label)
+{
+	if (gpio < MCFGPIO_PIN_MAX)
+		return __mcfgpio_request(gpio);
+	else
+		return -EINVAL;
+}
+
+static inline void gpio_free(unsigned gpio)
+{
+	if (gpio < MCFGPIO_PIN_MAX)
+		__mcfgpio_free(gpio);
+}
+
+#endif /* CONFIG_GPIOLIB */
 
-struct mcf_gpio_chip {
-	struct gpio_chip gpio_chip;
-	void __iomem *pddr;
-	void __iomem *podr;
-	void __iomem *ppdr;
-	void __iomem *setr;
-	void __iomem *clrr;
-	const u8 *gpio_to_pinmux;
-};
-
-extern struct mcf_gpio_chip mcf_gpio_chips[];
-extern unsigned int mcf_gpio_chips_size;
-
-int mcf_gpio_direction_input(struct gpio_chip *, unsigned);
-int mcf_gpio_get_value(struct gpio_chip *, unsigned);
-int mcf_gpio_direction_output(struct gpio_chip *, unsigned, int);
-void mcf_gpio_set_value(struct gpio_chip *, unsigned, int);
-void mcf_gpio_set_value_fast(struct gpio_chip *, unsigned, int);
-int mcf_gpio_request(struct gpio_chip *, unsigned);
-void mcf_gpio_free(struct gpio_chip *, unsigned);
 
 /*
- *	Define macros to ease the pain of setting up the GPIO tables. There
- *	are two cases we need to deal with here, they cover all currently
- *	available ColdFire GPIO hardware. There are of course minor differences
- *	in the layout and number of bits in each ColdFire part, but the macros
- *	take all that in.
+ * The Freescale Coldfire family is quite varied in how they implement GPIO.
+ * Some parts have 8 bit ports, some have 16bit and some have 32bit; some have
+ * only one port, others have multiple ports; some have a single data latch
+ * for both input and output, others have a separate pin data register to read
+ * input; some require a read-modify-write access to change an output, others
+ * have set and clear registers for some of the outputs; Some have all the
+ * GPIOs in a single control area, others have some GPIOs implemented in
+ * different modules.
  *
- *	Firstly is the conventional GPIO registers where we toggle individual
- *	bits in a register, preserving the other bits in the register. For
- *	lack of a better term I have called this the slow method.
+ * This implementation attempts accommodate the differences while presenting
+ * a generic interface that will optimize to as few instructions as possible.
  */
-#define	MCFGPS(mlabel, mbase, mngpio, mpddr, mpodr, mppdr)		    \
-	{								    \
-		.gpio_chip			= {			    \
-			.label			= #mlabel,		    \
-			.request		= mcf_gpio_request,	    \
-			.free			= mcf_gpio_free,	    \
-			.direction_input	= mcf_gpio_direction_input, \
-			.direction_output	= mcf_gpio_direction_output,\
-			.get			= mcf_gpio_get_value,	    \
-			.set			= mcf_gpio_set_value,       \
-			.base			= mbase,		    \
-			.ngpio			= mngpio,		    \
-		},							    \
-		.pddr		= (void __iomem *) mpddr,		    \
-		.podr		= (void __iomem *) mpodr,		    \
-		.ppdr		= (void __iomem *) mppdr,		    \
-	}
+#if defined(CONFIG_M5206) || defined(CONFIG_M5206e) || \
+    defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
+    defined(CONFIG_M527x) || defined(CONFIG_M528x) || \
+    defined(CONFIG_M532x) || defined(CONFIG_M54xx)
+
+/* These parts have GPIO organized by 8 bit ports */
+
+#define MCFGPIO_PORTTYPE		u8
+#define MCFGPIO_PORTSIZE		8
+#define mcfgpio_read(port)		__raw_readb(port)
+#define mcfgpio_write(data, port)	__raw_writeb(data, port)
+
+#elif defined(CONFIG_M5307) || defined(CONFIG_M5407) || defined(CONFIG_M5272)
+
+/* These parts have GPIO organized by 16 bit ports */
+
+#define MCFGPIO_PORTTYPE		u16
+#define MCFGPIO_PORTSIZE		16
+#define mcfgpio_read(port)		__raw_readw(port)
+#define mcfgpio_write(data, port)	__raw_writew(data, port)
+
+#elif defined(CONFIG_M5249)
+
+/* These parts have GPIO organized by 32 bit ports */
+
+#define MCFGPIO_PORTTYPE		u32
+#define MCFGPIO_PORTSIZE		32
+#define mcfgpio_read(port)		__raw_readl(port)
+#define mcfgpio_write(data, port)	__raw_writel(data, port)
+
+#endif
 
+#define mcfgpio_bit(gpio)		(1 << ((gpio) %  MCFGPIO_PORTSIZE))
+#define mcfgpio_port(gpio)		((gpio) / MCFGPIO_PORTSIZE)
+
+#if defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
+    defined(CONFIG_M527x) || defined(CONFIG_M528x) || defined(CONFIG_M532x)
+/*
+ * These parts have an 'Edge' Port module (external interrupt/GPIO) which uses
+ * read-modify-write to change an output and a GPIO module which has separate
+ * set/clr registers to directly change outputs with a single write access.
+ */
+#if defined(CONFIG_M528x)
 /*
- *	Secondly is the faster case, where we have set and clear registers
- *	that allow us to set or clear a bit with a single write, not having
- *	to worry about preserving other bits.
+ * The 528x also has GPIOs in other modules (GPT, QADC) which use
+ * read-modify-write as well as those controlled by the EPORT and GPIO modules.
  */
-#define	MCFGPF(mlabel, mbase, mngpio)					    \
-	{								    \
-		.gpio_chip			= {			    \
-			.label			= #mlabel,		    \
-			.request		= mcf_gpio_request,	    \
-			.free			= mcf_gpio_free,	    \
-			.direction_input	= mcf_gpio_direction_input, \
-			.direction_output	= mcf_gpio_direction_output,\
-			.get			= mcf_gpio_get_value,	    \
-			.set			= mcf_gpio_set_value_fast,  \
-			.base			= mbase,		    \
-			.ngpio			= mngpio,		    \
-		},							    \
-		.pddr		= (void __iomem *) MCFGPIO_PDDR_##mlabel,   \
-		.podr		= (void __iomem *) MCFGPIO_PODR_##mlabel,   \
-		.ppdr		= (void __iomem *) MCFGPIO_PPDSDR_##mlabel, \
-		.setr		= (void __iomem *) MCFGPIO_PPDSDR_##mlabel, \
-		.clrr		= (void __iomem *) MCFGPIO_PCLRR_##mlabel,  \
-	}
+#define MCFGPIO_SCR_START		40
+#else
+#define MCFGPIO_SCR_START		8
+#endif
+
+#define MCFGPIO_SETR_PORT(gpio)		(MCFGPIO_SETR + \
+					mcfgpio_port(gpio - MCFGPIO_SCR_START))
+
+#define MCFGPIO_CLRR_PORT(gpio)		(MCFGPIO_CLRR + \
+					mcfgpio_port(gpio - MCFGPIO_SCR_START))
+#else
+
+#define MCFGPIO_SCR_START		MCFGPIO_PIN_MAX
+/* with MCFGPIO_SCR == MCFGPIO_PIN_MAX, these will be optimized away */
+#define MCFGPIO_SETR_PORT(gpio)		0
+#define MCFGPIO_CLRR_PORT(gpio)		0
 
 #endif
+/*
+ * Coldfire specific helper functions
+ */
+
+/* return the port pin data register for a gpio */
+static inline u32 __mcfgpio_ppdr(unsigned gpio)
+{
+#if defined(CONFIG_M5206) || defined(CONFIG_M5206e) || \
+    defined(CONFIG_M5307) || defined(CONFIG_M5407)
+	return MCFSIM_PADAT;
+#elif defined(CONFIG_M5272)
+	if (gpio < 16)
+		return MCFSIM_PADAT;
+	else if (gpio < 32)
+		return MCFSIM_PBDAT;
+	else
+		return MCFSIM_PCDAT;
+#elif defined(CONFIG_M5249)
+	if (gpio < 32)
+		return MCFSIM2_GPIOREAD;
+	else
+		return MCFSIM2_GPIO1READ;
+#elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
+      defined(CONFIG_M527x) || defined(CONFIG_M528x) || defined(CONFIG_M532x)
+	if (gpio < 8)
+		return MCFEPORT_EPPDR;
+#if defined(CONFIG_M528x)
+	else if (gpio < 16)
+		return MCFGPTA_GPTPORT;
+	else if (gpio < 24)
+		return MCFGPTB_GPTPORT;
+	else if (gpio < 32)
+		return MCFQADC_PORTQA;
+	else if (gpio < 40)
+		return MCFQADC_PORTQB;
+#endif
+	else
+		return MCFGPIO_PPDR + mcfgpio_port(gpio - MCFGPIO_SCR_START);
+#else
+	return 0;
+#endif
+}
+
+/* return the port output data register for a gpio */
+static inline u32 __mcfgpio_podr(unsigned gpio)
+{
+#if defined(CONFIG_M5206) || defined(CONFIG_M5206e) || \
+    defined(CONFIG_M5307) || defined(CONFIG_M5407)
+	return MCFSIM_PADAT;
+#elif defined(CONFIG_M5272)
+	if (gpio < 16)
+		return MCFSIM_PADAT;
+	else if (gpio < 32)
+		return MCFSIM_PBDAT;
+	else
+		return MCFSIM_PCDAT;
+#elif defined(CONFIG_M5249)
+	if (gpio < 32)
+		return MCFSIM2_GPIOWRITE;
+	else
+		return MCFSIM2_GPIO1WRITE;
+#elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
+      defined(CONFIG_M527x) || defined(CONFIG_M528x) || defined(CONFIG_M532x)
+	if (gpio < 8)
+		return MCFEPORT_EPDR;
+#if defined(CONFIG_M528x)
+	else if (gpio < 16)
+		return MCFGPTA_GPTPORT;
+	else if (gpio < 24)
+		return MCFGPTB_GPTPORT;
+	else if (gpio < 32)
+		return MCFQADC_PORTQA;
+	else if (gpio < 40)
+		return MCFQADC_PORTQB;
+#endif
+	else
+		return MCFGPIO_PODR + mcfgpio_port(gpio - MCFGPIO_SCR_START);
+#else
+	return 0;
+#endif
+}
+
+/* return the port direction data register for a gpio */
+static inline u32 __mcfgpio_pddr(unsigned gpio)
+{
+#if defined(CONFIG_M5206) || defined(CONFIG_M5206e) || \
+    defined(CONFIG_M5307) || defined(CONFIG_M5407)
+	return MCFSIM_PADDR;
+#elif defined(CONFIG_M5272)
+	if (gpio < 16)
+		return MCFSIM_PADDR;
+	else if (gpio < 32)
+		return MCFSIM_PBDDR;
+	else
+		return MCFSIM_PCDDR;
+#elif defined(CONFIG_M5249)
+	if (gpio < 32)
+		return MCFSIM2_GPIOENABLE;
+	else
+		return MCFSIM2_GPIO1ENABLE;
+#elif defined(CONFIG_M520x) || defined(CONFIG_M523x) || \
+      defined(CONFIG_M527x) || defined(CONFIG_M528x) || defined(CONFIG_M532x)
+	if (gpio < 8)
+		return MCFEPORT_EPDDR;
+#if defined(CONFIG_M528x)
+	else if (gpio < 16)
+		return MCFGPTA_GPTDDR;
+	else if (gpio < 24)
+		return MCFGPTB_GPTDDR;
+	else if (gpio < 32)
+		return MCFQADC_DDRQA;
+	else if (gpio < 40)
+		return MCFQADC_DDRQB;
+#endif
+	else
+		return MCFGPIO_PDDR + mcfgpio_port(gpio - MCFGPIO_SCR_START);
+#else
+	return 0;
+#endif
+}
+
+#endif /* mcfgpio_h */

commit f23c144d4265b9251a4146e057af668bcd7667cb
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Tue Apr 17 13:25:38 2012 +1000

    m68knommu: make duplicated ColdFire GPIO init code common for all
    
    The code that adds each ColdFire platforms GPIO signals is duplicated in
    each platforms specific code. Remove it from each platforms code and put
    a single version in the existing ColdFire gpio subsystem init code.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>
    Acked-by: Steven King <sfking@fdwdc.com>

diff --git a/arch/m68k/include/asm/mcfgpio.h b/arch/m68k/include/asm/mcfgpio.h
index 1bc877b45554..fe468eaa51e0 100644
--- a/arch/m68k/include/asm/mcfgpio.h
+++ b/arch/m68k/include/asm/mcfgpio.h
@@ -29,6 +29,9 @@ struct mcf_gpio_chip {
 	const u8 *gpio_to_pinmux;
 };
 
+extern struct mcf_gpio_chip mcf_gpio_chips[];
+extern unsigned int mcf_gpio_chips_size;
+
 int mcf_gpio_direction_input(struct gpio_chip *, unsigned);
 int mcf_gpio_get_value(struct gpio_chip *, unsigned);
 int mcf_gpio_direction_output(struct gpio_chip *, unsigned, int);

commit c269d4efaab0847947e87df7a5a8b6c5817d9f1d
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Mon Apr 16 15:59:29 2012 +1000

    m68knommu: introduce macros to simplify ColdFire GPIO table initialization
    
    We have very large tables in the ColdFire CPU GPIO setup code that essentially
    boil down to 2 distinct types of GPIO pin initiaization. Using 2 macros we can
    reduce these large tables to at most a dozen lines of setup code, and in quite
    a few cases a single table entry.
    
    Introduce these 2 macros into the existing mcfgpio.h header.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>
    Acked-by: Steven King <sfking@fdwdc.com>

diff --git a/arch/m68k/include/asm/mcfgpio.h b/arch/m68k/include/asm/mcfgpio.h
index ee5e4ccce89e..1bc877b45554 100644
--- a/arch/m68k/include/asm/mcfgpio.h
+++ b/arch/m68k/include/asm/mcfgpio.h
@@ -37,4 +37,58 @@ void mcf_gpio_set_value_fast(struct gpio_chip *, unsigned, int);
 int mcf_gpio_request(struct gpio_chip *, unsigned);
 void mcf_gpio_free(struct gpio_chip *, unsigned);
 
+/*
+ *	Define macros to ease the pain of setting up the GPIO tables. There
+ *	are two cases we need to deal with here, they cover all currently
+ *	available ColdFire GPIO hardware. There are of course minor differences
+ *	in the layout and number of bits in each ColdFire part, but the macros
+ *	take all that in.
+ *
+ *	Firstly is the conventional GPIO registers where we toggle individual
+ *	bits in a register, preserving the other bits in the register. For
+ *	lack of a better term I have called this the slow method.
+ */
+#define	MCFGPS(mlabel, mbase, mngpio, mpddr, mpodr, mppdr)		    \
+	{								    \
+		.gpio_chip			= {			    \
+			.label			= #mlabel,		    \
+			.request		= mcf_gpio_request,	    \
+			.free			= mcf_gpio_free,	    \
+			.direction_input	= mcf_gpio_direction_input, \
+			.direction_output	= mcf_gpio_direction_output,\
+			.get			= mcf_gpio_get_value,	    \
+			.set			= mcf_gpio_set_value,       \
+			.base			= mbase,		    \
+			.ngpio			= mngpio,		    \
+		},							    \
+		.pddr		= (void __iomem *) mpddr,		    \
+		.podr		= (void __iomem *) mpodr,		    \
+		.ppdr		= (void __iomem *) mppdr,		    \
+	}
+
+/*
+ *	Secondly is the faster case, where we have set and clear registers
+ *	that allow us to set or clear a bit with a single write, not having
+ *	to worry about preserving other bits.
+ */
+#define	MCFGPF(mlabel, mbase, mngpio)					    \
+	{								    \
+		.gpio_chip			= {			    \
+			.label			= #mlabel,		    \
+			.request		= mcf_gpio_request,	    \
+			.free			= mcf_gpio_free,	    \
+			.direction_input	= mcf_gpio_direction_input, \
+			.direction_output	= mcf_gpio_direction_output,\
+			.get			= mcf_gpio_get_value,	    \
+			.set			= mcf_gpio_set_value_fast,  \
+			.base			= mbase,		    \
+			.ngpio			= mngpio,		    \
+		},							    \
+		.pddr		= (void __iomem *) MCFGPIO_PDDR_##mlabel,   \
+		.podr		= (void __iomem *) MCFGPIO_PODR_##mlabel,   \
+		.ppdr		= (void __iomem *) MCFGPIO_PPDSDR_##mlabel, \
+		.setr		= (void __iomem *) MCFGPIO_PPDSDR_##mlabel, \
+		.clrr		= (void __iomem *) MCFGPIO_PCLRR_##mlabel,  \
+	}
+
 #endif

commit af39bb8b07af83b579c90c09ba3943123cdb4132
Author: sfking@fdwdc.com <sfking@fdwdc.com>
Date:   Fri Jun 19 18:11:00 2009 -0700

    core generic GPIO support for Freescale Coldfire processors.
    
    This adds the basic infrastructure used by all of the different Coldfire CPUs.
    
    Signed-off-by: Steven King <sfking@fdwdc.com>
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/mcfgpio.h b/arch/m68k/include/asm/mcfgpio.h
new file mode 100644
index 000000000000..ee5e4ccce89e
--- /dev/null
+++ b/arch/m68k/include/asm/mcfgpio.h
@@ -0,0 +1,40 @@
+/*
+ * Coldfire generic GPIO support.
+ *
+ * (C) Copyright 2009, Steven King <sfking@fdwdc.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef mcfgpio_h
+#define mcfgpio_h
+
+#include <linux/io.h>
+#include <asm-generic/gpio.h>
+
+struct mcf_gpio_chip {
+	struct gpio_chip gpio_chip;
+	void __iomem *pddr;
+	void __iomem *podr;
+	void __iomem *ppdr;
+	void __iomem *setr;
+	void __iomem *clrr;
+	const u8 *gpio_to_pinmux;
+};
+
+int mcf_gpio_direction_input(struct gpio_chip *, unsigned);
+int mcf_gpio_get_value(struct gpio_chip *, unsigned);
+int mcf_gpio_direction_output(struct gpio_chip *, unsigned, int);
+void mcf_gpio_set_value(struct gpio_chip *, unsigned, int);
+void mcf_gpio_set_value_fast(struct gpio_chip *, unsigned, int);
+int mcf_gpio_request(struct gpio_chip *, unsigned);
+void mcf_gpio_free(struct gpio_chip *, unsigned);
+
+#endif
