commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/m68k/include/asm/m525xsim.h b/arch/m68k/include/asm/m525xsim.h
index 699f20c8a0fe..de01b701d95f 100644
--- a/arch/m68k/include/asm/m525xsim.h
+++ b/arch/m68k/include/asm/m525xsim.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /****************************************************************************/
 
 /*

commit 86a8280a7fe007d61b05fa8a352edc0595283dad
Author: Andrea Gelmini <andrea.gelmini@gelma.net>
Date:   Sat May 21 13:57:20 2016 +0200

    m68k: Assorted spelling fixes
    
      - s/acccess/access/
      - s/accoding/according/
      - s/addad/added/
      - s/addreess/address/
      - s/allocatiom/allocation/
      - s/Assember/Assembler/
      - s/compactnes/compactness/
      - s/conneced/connected/
      - s/decending/descending/
      - s/diectly/directly/
      - s/diplacement/displacement/
    
    Signed-off-by: Andrea Gelmini <andrea.gelmini@gelma.net>
    [geert: Squashed, fix arch/m68k/ifpsp060/src/pfpsp.S]
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/include/asm/m525xsim.h b/arch/m68k/include/asm/m525xsim.h
index f186459072e9..699f20c8a0fe 100644
--- a/arch/m68k/include/asm/m525xsim.h
+++ b/arch/m68k/include/asm/m525xsim.h
@@ -123,10 +123,10 @@
 /*
  *	I2C module.
  */
-#define MCFI2C_BASE0		(MCF_MBAR + 0x280)	/* Base addreess I2C0 */
+#define MCFI2C_BASE0		(MCF_MBAR + 0x280)	/* Base address I2C0 */
 #define MCFI2C_SIZE0		0x20			/* Register set size */
 
-#define MCFI2C_BASE1		(MCF_MBAR2 + 0x440)	/* Base addreess I2C1 */
+#define MCFI2C_BASE1		(MCF_MBAR2 + 0x440)	/* Base address I2C1 */
 #define MCFI2C_SIZE1		0x20			/* Register set size */
 
 /*

commit e93e91f2255fce33727d5f618cb16885fd157291
Author: Steven King <sfking@fdwdc.com>
Date:   Wed May 14 10:06:46 2014 -0700

    m68knommu: Fix the 5249/525x qspi base address.
    
    Use the correct base address for the QSPI module on the 5249/525x.
    
    Signed-off-by: Steven King <sfking@fdwdc.com>
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m525xsim.h b/arch/m68k/include/asm/m525xsim.h
index e33f5bb6aca8..f186459072e9 100644
--- a/arch/m68k/include/asm/m525xsim.h
+++ b/arch/m68k/include/asm/m525xsim.h
@@ -105,7 +105,7 @@
 /*
  *	QSPI module.
  */
-#define MCFQSPI_BASE		(MCF_MBAR + 0x300)	/* Base address QSPI */
+#define MCFQSPI_BASE		(MCF_MBAR + 0x400)	/* Base address QSPI */
 #define MCFQSPI_SIZE		0x40			/* Register set size */
 
 #ifdef CONFIG_M5249

commit 5a4acf3eac0631c288b8abb070fdb38c21eaf787
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Wed Sep 19 13:52:12 2012 +1000

    m68knommu: merge ColdFire 5249 and 525x definitions
    
    The ColdFire 5249 and 525x family of SoCs are very similar. Most of the
    internals are the same, and are mapped the same. We can use a single set of
    peripheral definitions for all of them.
    
    So merge the current m5249sim.h and m525xsim.h definitions into a single
    file. The 5249 is now obsolete, and the 525x parts are current, so I have
    chosen to move everything into the existing m525xsim.h file.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m525xsim.h b/arch/m68k/include/asm/m525xsim.h
index acab61cb91ed..e33f5bb6aca8 100644
--- a/arch/m68k/include/asm/m525xsim.h
+++ b/arch/m68k/include/asm/m525xsim.h
@@ -12,6 +12,11 @@
 #define m525xsim_h
 /****************************************************************************/
 
+/*
+ *	This header supports ColdFire 5249, 5251 and 5253. There are a few
+ *	little differences between them, but most of the peripheral support
+ *	can be used by all of them.
+ */
 #define CPU_NAME		"COLDFIRE(m525x)"
 #define CPU_INSTR_PER_JIFFY	3
 #define MCF_BUSCLK		(MCF_CLK / 2)
@@ -65,6 +70,8 @@
 #define MCFSIM_DCR		(MCF_MBAR + 0x100)	/* DRAM Control */
 #define MCFSIM_DACR0		(MCF_MBAR + 0x108)	/* DRAM 0 Addr/Ctrl */
 #define MCFSIM_DMR0		(MCF_MBAR + 0x10c)	/* DRAM 0 Mask */
+#define MCFSIM_DACR1		(MCF_MBAR + 0x110)	/* DRAM 1 Addr/Ctrl */
+#define MCFSIM_DMR1		(MCF_MBAR + 0x114)	/* DRAM 1 Mask */
 
 /*
  * Secondary Interrupt Controller (in MBAR2)
@@ -101,11 +108,17 @@
 #define MCFQSPI_BASE		(MCF_MBAR + 0x300)	/* Base address QSPI */
 #define MCFQSPI_SIZE		0x40			/* Register set size */
 
-
+#ifdef CONFIG_M5249
+#define MCFQSPI_CS0		29
+#define MCFQSPI_CS1		24
+#define MCFQSPI_CS2		21
+#define MCFQSPI_CS3		22
+#else
 #define MCFQSPI_CS0		15
 #define MCFQSPI_CS1		16
 #define MCFQSPI_CS2		24
 #define MCFQSPI_CS3		28
+#endif
 
 /*
  *	I2C module.
@@ -115,6 +128,7 @@
 
 #define MCFI2C_BASE1		(MCF_MBAR2 + 0x440)	/* Base addreess I2C1 */
 #define MCFI2C_SIZE1		0x20			/* Register set size */
+
 /*
  *	DMA unit base addresses.
  */
@@ -163,6 +177,7 @@
 #define MCF_IRQ_GPIO4		(MCFINTC2_VECBASE + 36)
 #define MCF_IRQ_GPIO5		(MCFINTC2_VECBASE + 37)
 #define MCF_IRQ_GPIO6		(MCFINTC2_VECBASE + 38)
+#define MCF_IRQ_GPIO7		(MCFINTC2_VECBASE + 39)
 
 #define MCF_IRQ_USBWUP		(MCFINTC2_VECBASE + 40)
 #define MCF_IRQ_I2C1		(MCFINTC2_VECBASE + 62)
@@ -183,12 +198,111 @@
 #define MCFSIM2_GPIOINTCLEAR	(MCF_MBAR2 + 0xc0)	/* GPIO intr clear */
 #define MCFSIM2_GPIOINTENABLE	(MCF_MBAR2 + 0xc4)	/* GPIO intr enable */
 
+#define MCFSIM2_DMAROUTE	(MCF_MBAR2 + 0x188)     /* DMA routing */
+#define MCFSIM2_IDECONFIG1	(MCF_MBAR2 + 0x18c)	/* IDEconfig1 */
+#define MCFSIM2_IDECONFIG2	(MCF_MBAR2 + 0x190)	/* IDEconfig2 */
+
 /*
  * Generic GPIO support
  */
 #define MCFGPIO_PIN_MAX		64
+#ifdef CONFIG_M5249
+#define MCFGPIO_IRQ_MAX		-1
+#define MCFGPIO_IRQ_VECBASE	-1
+#else
 #define MCFGPIO_IRQ_MAX		7
 #define MCFGPIO_IRQ_VECBASE	MCF_IRQ_GPIO0
+#endif
+
+/****************************************************************************/
+
+#ifdef __ASSEMBLER__
+#ifdef CONFIG_M5249C3
+/*
+ *	The M5249C3 board needs a little help getting all its SIM devices
+ *	initialized at kernel start time. dBUG doesn't set much up, so
+ *	we need to do it manually.
+ */
+.macro m5249c3_setup
+	/*
+	 *	Set MBAR1 and MBAR2, just incase they are not set.
+	 */
+	movel	#0x10000001,%a0
+	movec	%a0,%MBAR			/* map MBAR region */
+	subql	#1,%a0				/* get MBAR address in a0 */
+
+	movel	#0x80000001,%a1
+	movec	%a1,#3086			/* map MBAR2 region */
+	subql	#1,%a1				/* get MBAR2 address in a1 */
+
+	/*
+	 *      Move secondary interrupts to their base (128).
+	 */
+	moveb	#MCFINTC2_VECBASE,%d0
+	moveb	%d0,0x16b(%a1)			/* interrupt base register */
+
+	/*
+	 *      Work around broken CSMR0/DRAM vector problem.
+	 */
+	movel	#0x001F0021,%d0			/* disable C/I bit */
+	movel	%d0,0x84(%a0)			/* set CSMR0 */
+
+	/*
+	 *	Disable the PLL firstly. (Who knows what state it is
+	 *	in here!).
+	 */
+	movel	0x180(%a1),%d0			/* get current PLL value */
+	andl	#0xfffffffe,%d0			/* PLL bypass first */
+	movel	%d0,0x180(%a1)			/* set PLL register */
+	nop
+
+#if CONFIG_CLOCK_FREQ == 140000000
+	/*
+	 *	Set initial clock frequency. This assumes M5249C3 board
+	 *	is fitted with 11.2896MHz crystal. It will program the
+	 *	PLL for 140MHz. Lets go fast :-)
+	 */
+	movel	#0x125a40f0,%d0			/* set for 140MHz */
+	movel	%d0,0x180(%a1)			/* set PLL register */
+	orl	#0x1,%d0
+	movel	%d0,0x180(%a1)			/* set PLL register */
+#endif
+
+	/*
+	 *	Setup CS1 for ethernet controller.
+	 *	(Setup as per M5249C3 doco).
+	 */
+	movel  #0xe0000000,%d0			/* CS1 mapped at 0xe0000000 */
+	movel  %d0,0x8c(%a0)
+	movel  #0x001f0021,%d0			/* CS1 size of 1Mb */
+	movel  %d0,0x90(%a0)
+	movew  #0x0080,%d0			/* CS1 = 16bit port, AA */
+	movew  %d0,0x96(%a0)
+
+	/*
+	 *	Setup CS2 for IDE interface.
+	 */
+	movel	#0x50000000,%d0			/* CS2 mapped at 0x50000000 */
+	movel	%d0,0x98(%a0)
+	movel	#0x001f0001,%d0			/* CS2 size of 1MB */
+	movel	%d0,0x9c(%a0)
+	movew	#0x0080,%d0			/* CS2 = 16bit, TA */
+	movew	%d0,0xa2(%a0)
+
+	movel	#0x00107000,%d0			/* IDEconfig1 */
+	movel	%d0,0x18c(%a1)
+	movel	#0x000c0400,%d0			/* IDEconfig2 */
+	movel	%d0,0x190(%a1)
+
+	movel	#0x00080000,%d0			/* GPIO19, IDE reset bit */
+	orl	%d0,0xc(%a1)			/* function GPIO19 */
+	orl	%d0,0x8(%a1)			/* enable GPIO19 as output */
+        orl	%d0,0x4(%a1)			/* de-assert IDE reset */
+.endm
+
+#define	PLATFORM_SETUP	m5249c3_setup
 
+#endif /* CONFIG_M5249C3 */
+#endif /* __ASSEMBLER__ */
 /****************************************************************************/
 #endif	/* m525xsim_h */

commit 35142b915bd1307fef4316848a4c5dc5b38836f4
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Fri Sep 14 16:09:59 2012 +1000

    m68knommu: make ColdFire Park and Assignment register definitions absolute addresses
    
    Make all definitions of the ColdFire MPARK and IRQ Assignment registers
    absolute addresses. Currently some are relative to the MBAR peripheral
    region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the absolute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m525xsim.h b/arch/m68k/include/asm/m525xsim.h
index 158fdd4df51f..acab61cb91ed 100644
--- a/arch/m68k/include/asm/m525xsim.h
+++ b/arch/m68k/include/asm/m525xsim.h
@@ -30,7 +30,7 @@
 #define MCFSIM_SYPCR		(MCF_MBAR + 0x01)	/* System Protection */
 #define MCFSIM_SWIVR		(MCF_MBAR + 0x02)	/* SW Watchdog intr */
 #define MCFSIM_SWSR		(MCF_MBAR + 0x03)	/* SW Watchdog srv */
-#define MCFSIM_MPARK		0x0C		/* BUS Master Control Reg*/
+#define MCFSIM_MPARK		(MCF_MBAR + 0x0C)	/* BUS Master Ctrl */
 #define MCFSIM_IPR		(MCF_MBAR + 0x40)	/* Interrupt Pending */
 #define MCFSIM_IMR		(MCF_MBAR + 0x44)	/* Interrupt Mask */
 #define MCFSIM_ICR0		(MCF_MBAR + 0x4c)	/* Intr Ctrl reg 0 */

commit 1419ea3b34db3e3cf5d6bedb3f913ed814022030
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Fri Sep 14 15:36:02 2012 +1000

    m68knommu: make ColdFire Chip Select register definitions absolute addresses
    
    Make all definitions of the ColdFire Chip Select registers absolute addresses.
    Currently some are relative to the MBAR peripheral region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the absolute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m525xsim.h b/arch/m68k/include/asm/m525xsim.h
index 6a1ab49c4ac3..158fdd4df51f 100644
--- a/arch/m68k/include/asm/m525xsim.h
+++ b/arch/m68k/include/asm/m525xsim.h
@@ -46,21 +46,21 @@
 #define MCFSIM_ICR10		(MCF_MBAR + 0x56)	/* Intr Ctrl reg 10 */
 #define MCFSIM_ICR11		(MCF_MBAR + 0x57)	/* Intr Ctrl reg 11 */
 
-#define MCFSIM_CSAR0		0x80		/* CS 0 Address 0 reg (r/w) */
-#define MCFSIM_CSMR0		0x84		/* CS 0 Mask 0 reg (r/w) */
-#define MCFSIM_CSCR0		0x8a		/* CS 0 Control reg (r/w) */
-#define MCFSIM_CSAR1		0x8c		/* CS 1 Address reg (r/w) */
-#define MCFSIM_CSMR1		0x90		/* CS 1 Mask reg (r/w) */
-#define MCFSIM_CSCR1		0x96		/* CS 1 Control reg (r/w) */
-#define MCFSIM_CSAR2		0x98		/* CS 2 Address reg (r/w) */
-#define MCFSIM_CSMR2		0x9c		/* CS 2 Mask reg (r/w) */
-#define MCFSIM_CSCR2		0xa2		/* CS 2 Control reg (r/w) */
-#define MCFSIM_CSAR3		0xa4		/* CS 3 Address reg (r/w) */
-#define MCFSIM_CSMR3		0xa8		/* CS 3 Mask reg (r/w) */
-#define MCFSIM_CSCR3		0xae		/* CS 3 Control reg (r/w) */
-#define MCFSIM_CSAR4		0xb0		/* CS 4 Address reg (r/w) */
-#define MCFSIM_CSMR4		0xb4		/* CS 4 Mask reg (r/w) */
-#define MCFSIM_CSCR4		0xba		/* CS 4 Control reg (r/w) */
+#define MCFSIM_CSAR0		(MCF_MBAR + 0x80)	/* CS 0 Address reg */
+#define MCFSIM_CSMR0		(MCF_MBAR + 0x84)	/* CS 0 Mask reg */
+#define MCFSIM_CSCR0		(MCF_MBAR + 0x8a)	/* CS 0 Control reg */
+#define MCFSIM_CSAR1		(MCF_MBAR + 0x8c)	/* CS 1 Address reg */
+#define MCFSIM_CSMR1		(MCF_MBAR + 0x90)	/* CS 1 Mask reg */
+#define MCFSIM_CSCR1		(MCF_MBAR + 0x96)	/* CS 1 Control reg */
+#define MCFSIM_CSAR2		(MCF_MBAR + 0x98)	/* CS 2 Address reg */
+#define MCFSIM_CSMR2		(MCF_MBAR + 0x9c)	/* CS 2 Mask reg */
+#define MCFSIM_CSCR2		(MCF_MBAR + 0xa2)	/* CS 2 Control reg */
+#define MCFSIM_CSAR3		(MCF_MBAR + 0xa4)	/* CS 3 Address reg */
+#define MCFSIM_CSMR3		(MCF_MBAR + 0xa8)	/* CS 3 Mask reg */
+#define MCFSIM_CSCR3		(MCF_MBAR + 0xae)	/* CS 3 Control reg */
+#define MCFSIM_CSAR4		(MCF_MBAR + 0xb0)	/* CS 4 Address reg */
+#define MCFSIM_CSMR4		(MCF_MBAR + 0xb4)	/* CS 4 Mask reg */
+#define MCFSIM_CSCR4		(MCF_MBAR + 0xba)	/* CS 4 Control reg */
 
 #define MCFSIM_DCR		(MCF_MBAR + 0x100)	/* DRAM Control */
 #define MCFSIM_DACR0		(MCF_MBAR + 0x108)	/* DRAM 0 Addr/Ctrl */

commit c986a3d520395604ca29a7fb9fca60a455abcc44
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Fri Aug 17 16:48:16 2012 +1000

    m68knommu: make ColdFire Interrupt Source register definitions absolute addresses
    
    Make all definitions of the ColdFire Interrupt Source registers absolute
    addresses. Currently some are relative to the MBAR peripheral region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the absolute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m525xsim.h b/arch/m68k/include/asm/m525xsim.h
index b0fccd9d7102..6a1ab49c4ac3 100644
--- a/arch/m68k/include/asm/m525xsim.h
+++ b/arch/m68k/include/asm/m525xsim.h
@@ -33,18 +33,18 @@
 #define MCFSIM_MPARK		0x0C		/* BUS Master Control Reg*/
 #define MCFSIM_IPR		(MCF_MBAR + 0x40)	/* Interrupt Pending */
 #define MCFSIM_IMR		(MCF_MBAR + 0x44)	/* Interrupt Mask */
-#define MCFSIM_ICR0		0x4c		/* Intr Ctrl reg 0 (r/w) */
-#define MCFSIM_ICR1		0x4d		/* Intr Ctrl reg 1 (r/w) */
-#define MCFSIM_ICR2		0x4e		/* Intr Ctrl reg 2 (r/w) */
-#define MCFSIM_ICR3		0x4f		/* Intr Ctrl reg 3 (r/w) */
-#define MCFSIM_ICR4		0x50		/* Intr Ctrl reg 4 (r/w) */
-#define MCFSIM_ICR5		0x51		/* Intr Ctrl reg 5 (r/w) */
-#define MCFSIM_ICR6		0x52		/* Intr Ctrl reg 6 (r/w) */
-#define MCFSIM_ICR7		0x53		/* Intr Ctrl reg 7 (r/w) */
-#define MCFSIM_ICR8		0x54		/* Intr Ctrl reg 8 (r/w) */
-#define MCFSIM_ICR9		0x55		/* Intr Ctrl reg 9 (r/w) */
-#define MCFSIM_ICR10		0x56		/* Intr Ctrl reg 10 (r/w) */
-#define MCFSIM_ICR11		0x57		/* Intr Ctrl reg 11 (r/w) */
+#define MCFSIM_ICR0		(MCF_MBAR + 0x4c)	/* Intr Ctrl reg 0 */
+#define MCFSIM_ICR1		(MCF_MBAR + 0x4d)	/* Intr Ctrl reg 1 */
+#define MCFSIM_ICR2		(MCF_MBAR + 0x4e)	/* Intr Ctrl reg 2 */
+#define MCFSIM_ICR3		(MCF_MBAR + 0x4f)	/* Intr Ctrl reg 3 */
+#define MCFSIM_ICR4		(MCF_MBAR + 0x50)	/* Intr Ctrl reg 4 */
+#define MCFSIM_ICR5		(MCF_MBAR + 0x51)	/* Intr Ctrl reg 5 */
+#define MCFSIM_ICR6		(MCF_MBAR + 0x52)	/* Intr Ctrl reg 6 */
+#define MCFSIM_ICR7		(MCF_MBAR + 0x53)	/* Intr Ctrl reg 7 */
+#define MCFSIM_ICR8		(MCF_MBAR + 0x54)	/* Intr Ctrl reg 8 */
+#define MCFSIM_ICR9		(MCF_MBAR + 0x55)	/* Intr Ctrl reg 9 */
+#define MCFSIM_ICR10		(MCF_MBAR + 0x56)	/* Intr Ctrl reg 10 */
+#define MCFSIM_ICR11		(MCF_MBAR + 0x57)	/* Intr Ctrl reg 11 */
 
 #define MCFSIM_CSAR0		0x80		/* CS 0 Address 0 reg (r/w) */
 #define MCFSIM_CSMR0		0x84		/* CS 0 Mask 0 reg (r/w) */

commit 660b73e356a63d67231aab49d23e83b1a5a9ec87
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Sun Jul 15 22:01:08 2012 +1000

    m68knommu: make ColdFire watchdog register definitions absolute addresses
    
    Make all definitions of the ColdFire Software watchdog registers absolute
    addresses. Currently some are relative to the MBAR peripheral region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the absolute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m525xsim.h b/arch/m68k/include/asm/m525xsim.h
index 05876cc95dde..b0fccd9d7102 100644
--- a/arch/m68k/include/asm/m525xsim.h
+++ b/arch/m68k/include/asm/m525xsim.h
@@ -28,8 +28,8 @@
  */
 #define MCFSIM_RSR		(MCF_MBAR + 0x00)	/* Reset Status */
 #define MCFSIM_SYPCR		(MCF_MBAR + 0x01)	/* System Protection */
-#define MCFSIM_SWIVR		0x02		/* SW Watchdog intr reg (r/w) */
-#define MCFSIM_SWSR		0x03		/* SW Watchdog service (r/w) */
+#define MCFSIM_SWIVR		(MCF_MBAR + 0x02)	/* SW Watchdog intr */
+#define MCFSIM_SWSR		(MCF_MBAR + 0x03)	/* SW Watchdog srv */
 #define MCFSIM_MPARK		0x0C		/* BUS Master Control Reg*/
 #define MCFSIM_IPR		(MCF_MBAR + 0x40)	/* Interrupt Pending */
 #define MCFSIM_IMR		(MCF_MBAR + 0x44)	/* Interrupt Mask */

commit e1e362dc074c2981e7f78d26bf38a4f14be52ecd
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Sun Jul 15 21:55:01 2012 +1000

    m68knommu: make ColdFire SYPCR and RSR register definitions absolute addresses
    
    Make all definitions of the ColdFire Reset and System registers absolute
    addresses. Currently some are relative to the MBAR peripheral region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the abolsute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m525xsim.h b/arch/m68k/include/asm/m525xsim.h
index 0d6d192355ca..05876cc95dde 100644
--- a/arch/m68k/include/asm/m525xsim.h
+++ b/arch/m68k/include/asm/m525xsim.h
@@ -26,8 +26,8 @@
 /*
  *	Define the 525x SIM register set addresses.
  */
-#define MCFSIM_RSR		0x00		/* Reset Status reg (r/w) */
-#define MCFSIM_SYPCR		0x01		/* System Protection reg (r/w)*/
+#define MCFSIM_RSR		(MCF_MBAR + 0x00)	/* Reset Status */
+#define MCFSIM_SYPCR		(MCF_MBAR + 0x01)	/* System Protection */
 #define MCFSIM_SWIVR		0x02		/* SW Watchdog intr reg (r/w) */
 #define MCFSIM_SWSR		0x03		/* SW Watchdog service (r/w) */
 #define MCFSIM_MPARK		0x0C		/* BUS Master Control Reg*/

commit 6a3a786d02172b34d0ffba6f80bd1150da51125d
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Sun Jul 15 21:42:47 2012 +1000

    m68knommu: make ColdFire IMR and IPR register definitions absolute addresses
    
    Make all definitions of the ColdFire Interrupt Mask and Pending registers
    absolute addresses. Currently some are relative to the MBAR peripheral region.
    
    The various ColdFire parts use different methods to address the internal
    registers, some are absolute, some are relative to peripheral regions
    which can be mapped at different address ranges (such as the MBAR and IPSBAR
    registers). We don't want to deal with this in the code when we are
    accessing these registers, so make all register definitions the absolute
    address - factoring out whether it is an offset into a peripheral region.
    
    This makes them all consistently defined, and reduces the occasional bugs
    caused by inconsistent definition of the register addresses.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m525xsim.h b/arch/m68k/include/asm/m525xsim.h
index 6da24f653902..0d6d192355ca 100644
--- a/arch/m68k/include/asm/m525xsim.h
+++ b/arch/m68k/include/asm/m525xsim.h
@@ -31,8 +31,8 @@
 #define MCFSIM_SWIVR		0x02		/* SW Watchdog intr reg (r/w) */
 #define MCFSIM_SWSR		0x03		/* SW Watchdog service (r/w) */
 #define MCFSIM_MPARK		0x0C		/* BUS Master Control Reg*/
-#define MCFSIM_IPR		0x40		/* Interrupt Pend reg (r/w) */
-#define MCFSIM_IMR		0x44		/* Interrupt Mask reg (r/w) */
+#define MCFSIM_IPR		(MCF_MBAR + 0x40)	/* Interrupt Pending */
+#define MCFSIM_IMR		(MCF_MBAR + 0x44)	/* Interrupt Mask */
 #define MCFSIM_ICR0		0x4c		/* Intr Ctrl reg 0 (r/w) */
 #define MCFSIM_ICR1		0x4d		/* Intr Ctrl reg 1 (r/w) */
 #define MCFSIM_ICR2		0x4e		/* Intr Ctrl reg 2 (r/w) */

commit 04e037aa4e5f71d11c004e844339d385a89733f6
Author: Steven King <sfking@fdwdc.com>
Date:   Tue Jun 5 08:23:08 2012 -0700

    m68knommu: Add support for the Coldfire 5251/5253
    
    Basic support for the Coldfire 5251/5253.
    
    Signed-off-by: Steven king <sfking@fdwdc.com>
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/m525xsim.h b/arch/m68k/include/asm/m525xsim.h
new file mode 100644
index 000000000000..6da24f653902
--- /dev/null
+++ b/arch/m68k/include/asm/m525xsim.h
@@ -0,0 +1,194 @@
+/****************************************************************************/
+
+/*
+ *	m525xsim.h -- ColdFire 525x System Integration Module support.
+ *
+ *	(C) Copyright 2012, Steven king <sfking@fdwdc.com>
+ *	(C) Copyright 2002, Greg Ungerer (gerg@snapgear.com)
+ */
+
+/****************************************************************************/
+#ifndef	m525xsim_h
+#define m525xsim_h
+/****************************************************************************/
+
+#define CPU_NAME		"COLDFIRE(m525x)"
+#define CPU_INSTR_PER_JIFFY	3
+#define MCF_BUSCLK		(MCF_CLK / 2)
+
+#include <asm/m52xxacr.h>
+
+/*
+ *	The 525x has a second MBAR region, define its address.
+ */
+#define MCF_MBAR2		0x80000000
+
+/*
+ *	Define the 525x SIM register set addresses.
+ */
+#define MCFSIM_RSR		0x00		/* Reset Status reg (r/w) */
+#define MCFSIM_SYPCR		0x01		/* System Protection reg (r/w)*/
+#define MCFSIM_SWIVR		0x02		/* SW Watchdog intr reg (r/w) */
+#define MCFSIM_SWSR		0x03		/* SW Watchdog service (r/w) */
+#define MCFSIM_MPARK		0x0C		/* BUS Master Control Reg*/
+#define MCFSIM_IPR		0x40		/* Interrupt Pend reg (r/w) */
+#define MCFSIM_IMR		0x44		/* Interrupt Mask reg (r/w) */
+#define MCFSIM_ICR0		0x4c		/* Intr Ctrl reg 0 (r/w) */
+#define MCFSIM_ICR1		0x4d		/* Intr Ctrl reg 1 (r/w) */
+#define MCFSIM_ICR2		0x4e		/* Intr Ctrl reg 2 (r/w) */
+#define MCFSIM_ICR3		0x4f		/* Intr Ctrl reg 3 (r/w) */
+#define MCFSIM_ICR4		0x50		/* Intr Ctrl reg 4 (r/w) */
+#define MCFSIM_ICR5		0x51		/* Intr Ctrl reg 5 (r/w) */
+#define MCFSIM_ICR6		0x52		/* Intr Ctrl reg 6 (r/w) */
+#define MCFSIM_ICR7		0x53		/* Intr Ctrl reg 7 (r/w) */
+#define MCFSIM_ICR8		0x54		/* Intr Ctrl reg 8 (r/w) */
+#define MCFSIM_ICR9		0x55		/* Intr Ctrl reg 9 (r/w) */
+#define MCFSIM_ICR10		0x56		/* Intr Ctrl reg 10 (r/w) */
+#define MCFSIM_ICR11		0x57		/* Intr Ctrl reg 11 (r/w) */
+
+#define MCFSIM_CSAR0		0x80		/* CS 0 Address 0 reg (r/w) */
+#define MCFSIM_CSMR0		0x84		/* CS 0 Mask 0 reg (r/w) */
+#define MCFSIM_CSCR0		0x8a		/* CS 0 Control reg (r/w) */
+#define MCFSIM_CSAR1		0x8c		/* CS 1 Address reg (r/w) */
+#define MCFSIM_CSMR1		0x90		/* CS 1 Mask reg (r/w) */
+#define MCFSIM_CSCR1		0x96		/* CS 1 Control reg (r/w) */
+#define MCFSIM_CSAR2		0x98		/* CS 2 Address reg (r/w) */
+#define MCFSIM_CSMR2		0x9c		/* CS 2 Mask reg (r/w) */
+#define MCFSIM_CSCR2		0xa2		/* CS 2 Control reg (r/w) */
+#define MCFSIM_CSAR3		0xa4		/* CS 3 Address reg (r/w) */
+#define MCFSIM_CSMR3		0xa8		/* CS 3 Mask reg (r/w) */
+#define MCFSIM_CSCR3		0xae		/* CS 3 Control reg (r/w) */
+#define MCFSIM_CSAR4		0xb0		/* CS 4 Address reg (r/w) */
+#define MCFSIM_CSMR4		0xb4		/* CS 4 Mask reg (r/w) */
+#define MCFSIM_CSCR4		0xba		/* CS 4 Control reg (r/w) */
+
+#define MCFSIM_DCR		(MCF_MBAR + 0x100)	/* DRAM Control */
+#define MCFSIM_DACR0		(MCF_MBAR + 0x108)	/* DRAM 0 Addr/Ctrl */
+#define MCFSIM_DMR0		(MCF_MBAR + 0x10c)	/* DRAM 0 Mask */
+
+/*
+ * Secondary Interrupt Controller (in MBAR2)
+*/
+#define MCFINTC2_INTBASE	(MCF_MBAR2 + 0x168)	/* Base Vector Reg */
+#define MCFINTC2_INTPRI1	(MCF_MBAR2 + 0x140)	/* 0-7 priority */
+#define MCFINTC2_INTPRI2	(MCF_MBAR2 + 0x144)	/* 8-15 priority */
+#define MCFINTC2_INTPRI3	(MCF_MBAR2 + 0x148)	/* 16-23 priority */
+#define MCFINTC2_INTPRI4	(MCF_MBAR2 + 0x14c)	/* 24-31 priority */
+#define MCFINTC2_INTPRI5	(MCF_MBAR2 + 0x150)	/* 32-39 priority */
+#define MCFINTC2_INTPRI6	(MCF_MBAR2 + 0x154)	/* 40-47 priority */
+#define MCFINTC2_INTPRI7	(MCF_MBAR2 + 0x158)	/* 48-55 priority */
+#define MCFINTC2_INTPRI8	(MCF_MBAR2 + 0x15c)	/* 56-63 priority */
+
+#define MCFINTC2_INTPRI_REG(i)	(MCFINTC2_INTPRI1 + \
+				((((i) - MCFINTC2_VECBASE) / 8) * 4))
+#define MCFINTC2_INTPRI_BITS(b, i)	((b) << (((i) % 8) * 4))
+
+/*
+ *	Timer module.
+ */
+#define MCFTIMER_BASE1		(MCF_MBAR + 0x140)	/* Base of TIMER1 */
+#define MCFTIMER_BASE2		(MCF_MBAR + 0x180)	/* Base of TIMER2 */
+
+/*
+ *	UART module.
+ */
+#define MCFUART_BASE0		(MCF_MBAR + 0x1c0)	/* Base address UART0 */
+#define MCFUART_BASE1		(MCF_MBAR + 0x200)	/* Base address UART1 */
+
+/*
+ *	QSPI module.
+ */
+#define MCFQSPI_BASE		(MCF_MBAR + 0x300)	/* Base address QSPI */
+#define MCFQSPI_SIZE		0x40			/* Register set size */
+
+
+#define MCFQSPI_CS0		15
+#define MCFQSPI_CS1		16
+#define MCFQSPI_CS2		24
+#define MCFQSPI_CS3		28
+
+/*
+ *	I2C module.
+ */
+#define MCFI2C_BASE0		(MCF_MBAR + 0x280)	/* Base addreess I2C0 */
+#define MCFI2C_SIZE0		0x20			/* Register set size */
+
+#define MCFI2C_BASE1		(MCF_MBAR2 + 0x440)	/* Base addreess I2C1 */
+#define MCFI2C_SIZE1		0x20			/* Register set size */
+/*
+ *	DMA unit base addresses.
+ */
+#define MCFDMA_BASE0		(MCF_MBAR + 0x300)	/* Base address DMA 0 */
+#define MCFDMA_BASE1		(MCF_MBAR + 0x340)	/* Base address DMA 1 */
+#define MCFDMA_BASE2		(MCF_MBAR + 0x380)	/* Base address DMA 2 */
+#define MCFDMA_BASE3		(MCF_MBAR + 0x3C0)	/* Base address DMA 3 */
+
+/*
+ *	Some symbol defines for the above...
+ */
+#define MCFSIM_SWDICR		MCFSIM_ICR0	/* Watchdog timer ICR */
+#define MCFSIM_TIMER1ICR	MCFSIM_ICR1	/* Timer 1 ICR */
+#define MCFSIM_TIMER2ICR	MCFSIM_ICR2	/* Timer 2 ICR */
+#define MCFSIM_I2CICR		MCFSIM_ICR3	/* I2C ICR */
+#define MCFSIM_UART1ICR		MCFSIM_ICR4	/* UART 1 ICR */
+#define MCFSIM_UART2ICR		MCFSIM_ICR5	/* UART 2 ICR */
+#define MCFSIM_DMA0ICR		MCFSIM_ICR6	/* DMA 0 ICR */
+#define MCFSIM_DMA1ICR		MCFSIM_ICR7	/* DMA 1 ICR */
+#define MCFSIM_DMA2ICR		MCFSIM_ICR8	/* DMA 2 ICR */
+#define MCFSIM_DMA3ICR		MCFSIM_ICR9	/* DMA 3 ICR */
+#define MCFSIM_QSPIICR		MCFSIM_ICR10	/* QSPI ICR */
+
+/*
+ *	Define system peripheral IRQ usage.
+ */
+#define MCF_IRQ_QSPI		28		/* QSPI, Level 4 */
+#define MCF_IRQ_I2C0		29
+#define MCF_IRQ_TIMER		30		/* Timer0, Level 6 */
+#define MCF_IRQ_PROFILER	31		/* Timer1, Level 7 */
+
+#define MCF_IRQ_UART0		73		/* UART0 */
+#define MCF_IRQ_UART1		74		/* UART1 */
+
+/*
+ * Define the base interrupt for the second interrupt controller.
+ * We set it to 128, out of the way of the base interrupts, and plenty
+ * of room for its 64 interrupts.
+ */
+#define MCFINTC2_VECBASE	128
+
+#define MCF_IRQ_GPIO0		(MCFINTC2_VECBASE + 32)
+#define MCF_IRQ_GPIO1		(MCFINTC2_VECBASE + 33)
+#define MCF_IRQ_GPIO2		(MCFINTC2_VECBASE + 34)
+#define MCF_IRQ_GPIO3		(MCFINTC2_VECBASE + 35)
+#define MCF_IRQ_GPIO4		(MCFINTC2_VECBASE + 36)
+#define MCF_IRQ_GPIO5		(MCFINTC2_VECBASE + 37)
+#define MCF_IRQ_GPIO6		(MCFINTC2_VECBASE + 38)
+
+#define MCF_IRQ_USBWUP		(MCFINTC2_VECBASE + 40)
+#define MCF_IRQ_I2C1		(MCFINTC2_VECBASE + 62)
+
+/*
+ *	General purpose IO registers (in MBAR2).
+ */
+#define MCFSIM2_GPIOREAD	(MCF_MBAR2 + 0x000)	/* GPIO read values */
+#define MCFSIM2_GPIOWRITE	(MCF_MBAR2 + 0x004)	/* GPIO write values */
+#define MCFSIM2_GPIOENABLE	(MCF_MBAR2 + 0x008)	/* GPIO enabled */
+#define MCFSIM2_GPIOFUNC	(MCF_MBAR2 + 0x00C)	/* GPIO function */
+#define MCFSIM2_GPIO1READ	(MCF_MBAR2 + 0x0B0)	/* GPIO1 read values */
+#define MCFSIM2_GPIO1WRITE	(MCF_MBAR2 + 0x0B4)	/* GPIO1 write values */
+#define MCFSIM2_GPIO1ENABLE	(MCF_MBAR2 + 0x0B8)	/* GPIO1 enabled */
+#define MCFSIM2_GPIO1FUNC	(MCF_MBAR2 + 0x0BC)	/* GPIO1 function */
+
+#define MCFSIM2_GPIOINTSTAT	(MCF_MBAR2 + 0xc0)	/* GPIO intr status */
+#define MCFSIM2_GPIOINTCLEAR	(MCF_MBAR2 + 0xc0)	/* GPIO intr clear */
+#define MCFSIM2_GPIOINTENABLE	(MCF_MBAR2 + 0xc4)	/* GPIO intr enable */
+
+/*
+ * Generic GPIO support
+ */
+#define MCFGPIO_PIN_MAX		64
+#define MCFGPIO_IRQ_MAX		7
+#define MCFGPIO_IRQ_VECBASE	MCF_IRQ_GPIO0
+
+/****************************************************************************/
+#endif	/* m525xsim_h */
