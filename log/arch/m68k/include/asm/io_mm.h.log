commit 94c04390225bcd8283103fd0c04be20cc30cc979
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Fri Aug 2 10:10:25 2019 +1000

    m68k: Prevent some compiler warnings in Coldfire builds
    
    Since commit d3b41b6bb49e ("m68k: Dispatch nvram_ops calls to Atari or
    Mac functions"), Coldfire builds generate compiler warnings due to the
    unconditional inclusion of asm/atarihw.h and asm/macintosh.h.
    
    The inclusion of asm/atarihw.h causes warnings like this:
    
    In file included from ./arch/m68k/include/asm/atarihw.h:25:0,
                     from arch/m68k/kernel/setup_mm.c:41,
                     from arch/m68k/kernel/setup.c:3:
    ./arch/m68k/include/asm/raw_io.h:39:0: warning: "__raw_readb" redefined
     #define __raw_readb in_8
    
    In file included from ./arch/m68k/include/asm/io.h:6:0,
                     from arch/m68k/kernel/setup_mm.c:36,
                     from arch/m68k/kernel/setup.c:3:
    ./arch/m68k/include/asm/io_no.h:16:0: note: this is the location of the previous definition
     #define __raw_readb(addr) \
    ...
    
    This issue is resolved by dropping the asm/raw_io.h include. It turns out
    that asm/io_mm.h already includes that header file.
    
    Moving the relevant macro definitions helps to clarify this dependency
    and make it safe to include asm/atarihw.h.
    
    The other warnings look like this:
    
    In file included from arch/m68k/kernel/setup_mm.c:48:0,
                     from arch/m68k/kernel/setup.c:3:
    ./arch/m68k/include/asm/macintosh.h:19:35: warning: 'struct irq_data' declared inside parameter list will not be visible outside of this definition or declaration
     extern void mac_irq_enable(struct irq_data *data);
                                       ^~~~~~~~
    ...
    
    This issue is resolved by adding the missing linux/irq.h include.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Greg Ungerer <gerg@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 6c03ca5bc436..819f611dccf2 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -29,7 +29,11 @@
 #include <asm-generic/iomap.h>
 
 #ifdef CONFIG_ATARI
-#include <asm/atarihw.h>
+#define atari_readb   raw_inb
+#define atari_writeb  raw_outb
+
+#define atari_inb_p   raw_inb
+#define atari_outb_p  raw_outb
 #endif
 
 

commit 0f43ca692dcb55108ea9a59c11a1a0e359dba367
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Feb 22 13:03:18 2019 +0000

    m68k/io: Remove useless definition of mmiowb()
    
    m68k includes asm-generic/io.h, which provides a dummy definition of
    mmiowb() if one isn't already provided by the architecture.
    
    Remove the useless definition.
    
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 782b78f8a048..6c03ca5bc436 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -377,8 +377,6 @@ static inline void isa_delay(void)
 #define writesw(port, buf, nr)    raw_outsw((port), (u16 *)(buf), (nr))
 #define writesl(port, buf, nr)    raw_outsl((port), (u32 *)(buf), (nr))
 
-#define mmiowb()
-
 #ifndef CONFIG_SUN3
 #define IO_SPACE_LIMIT 0xffff
 #else

commit 781c4d6f5f278fc23687d6d224ddb452bb5ac368
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Jun 28 11:18:53 2018 +0200

    m68k/io: Switch mmu variant to <asm-generic/io.h>
    
    The dummy functions defined in <asm/io_mm.h> can be provided by
    <asm-generic/io.h>.
    
    As nommu already uses <asm-generic/io.h>, move its inclusion to
    <asm/io.h>, and add/adjust include guards where appropriate.
    
    This gets rid of lots of "statement with no effect" and "unused
    variable" warnings when compile-testing.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Greg Ungerer <gerg@linux-m68k.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 7e518303786c..782b78f8a048 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -16,8 +16,8 @@
  *    isa_readX(),isa_writeX()  are for ISA memory
  */
 
-#ifndef _IO_H
-#define _IO_H
+#ifndef _M68K_IO_MM_H
+#define _M68K_IO_MM_H
 
 #ifdef __KERNEL__
 
@@ -367,40 +367,6 @@ static inline void isa_delay(void)
 #define writew(val, addr)	out_le16((addr), (val))
 #endif /* CONFIG_ATARI_ROM_ISA */
 
-#if !defined(CONFIG_ISA) && !defined(CONFIG_ATARI_ROM_ISA)
-/*
- * We need to define dummy functions for GENERIC_IOMAP support.
- */
-#define inb(port)          0xff
-#define inb_p(port)        0xff
-#define outb(val,port)     ((void)0)
-#define outb_p(val,port)   ((void)0)
-#define inw(port)          0xffff
-#define inw_p(port)        0xffff
-#define outw(val,port)     ((void)0)
-#define outw_p(val,port)   ((void)0)
-#define inl(port)          0xffffffffUL
-#define inl_p(port)        0xffffffffUL
-#define outl(val,port)     ((void)0)
-#define outl_p(val,port)   ((void)0)
-
-#define insb(port,buf,nr)  ((void)0)
-#define outsb(port,buf,nr) ((void)0)
-#define insw(port,buf,nr)  ((void)0)
-#define outsw(port,buf,nr) ((void)0)
-#define insl(port,buf,nr)  ((void)0)
-#define outsl(port,buf,nr) ((void)0)
-
-/*
- * These should be valid on any ioremap()ed region
- */
-#define readb(addr)      in_8(addr)
-#define writeb(val,addr) out_8((addr),(val))
-#define readw(addr)      in_le16(addr)
-#define writew(val,addr) out_le16((addr),(val))
-
-#endif /* !CONFIG_ISA && !CONFIG_ATARI_ROM_ISA */
-
 #define readl(addr)      in_le32(addr)
 #define writel(val,addr) out_le32((addr),(val))
 
@@ -442,4 +408,4 @@ static inline void isa_delay(void)
 #define writew_relaxed(b, addr)	writew(b, addr)
 #define writel_relaxed(b, addr)	writel(b, addr)
 
-#endif /* _IO_H */
+#endif /* _M68K_IO_MM_H */

commit e295066f66a4fa78c39c29de7d7635e6957dd4f7
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Jun 26 18:41:11 2018 +0200

    m68k/io: Add missing ioremap define guards, fix typo
    
      - Add missing define guard for ioremap_wt(),
      - Move ARCH_HAS_IOREMAP_WT from <asm/io_mm.h> to <asm/kmap.h>, as it
        is applicable to Coldfire with MMU, too,
      - Fix typo s/ioremap_fillcache/ioremap_fullcache/,
      - Add define guard for iounmap() for consistency with other
        architectures.
    
    Fixes: 9746882f547d2f00 ("m68k: group io mapping definitions and functions")
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Greg Ungerer <gerg@linux-m68k.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index fe485f4f5fac..7e518303786c 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -21,8 +21,6 @@
 
 #ifdef __KERNEL__
 
-#define ARCH_HAS_IOREMAP_WT
-
 #include <linux/compiler.h>
 #include <asm/raw_io.h>
 #include <asm/virtconvert.h>

commit de25cfcb6404a0370067bbadaf13122f15464459
Author: Greg Ungerer <gerg@linux-m68k.org>
Date:   Sun Mar 25 22:50:00 2018 +1000

    m68k: remove old ColdFire IO access support code
    
    All the ColdFire IO access support code has been moved to io_no.h.
    This means that all ColdFire support is at least now consistent no
    matter whether the MMU is enabled or not for them.
    
    Now that io_mm.h has reverted to only support the traditional m68k MMU
    enabled processors we can remove the ColdFire specific definitions.
    
    We can also remove the old ColdFire PCI bus IO access functions.
    The new io_no.h uses asm-generic/io.h to provide all the basic support.
    
    Signed-off-by: Greg Ungerer <gerg@linux-m68k.org>
    Reviewed-by: Angelo Dureghello <angelo@sysam.it>
    Tested-by: Angelo Dureghello <angelo@sysam.it>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 21fba26f57f4..fe485f4f5fac 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -86,53 +86,7 @@
 #endif /* ATARI_ROM_ISA */
 
 
-#if defined(CONFIG_PCI) && defined(CONFIG_COLDFIRE)
-
-#define HAVE_ARCH_PIO_SIZE
-#define PIO_OFFSET	0
-#define PIO_MASK	0xffff
-#define PIO_RESERVED	0x10000
-
-u8 mcf_pci_inb(u32 addr);
-u16 mcf_pci_inw(u32 addr);
-u32 mcf_pci_inl(u32 addr);
-void mcf_pci_insb(u32 addr, u8 *buf, u32 len);
-void mcf_pci_insw(u32 addr, u16 *buf, u32 len);
-void mcf_pci_insl(u32 addr, u32 *buf, u32 len);
-
-void mcf_pci_outb(u8 v, u32 addr);
-void mcf_pci_outw(u16 v, u32 addr);
-void mcf_pci_outl(u32 v, u32 addr);
-void mcf_pci_outsb(u32 addr, const u8 *buf, u32 len);
-void mcf_pci_outsw(u32 addr, const u16 *buf, u32 len);
-void mcf_pci_outsl(u32 addr, const u32 *buf, u32 len);
-
-#define	inb	mcf_pci_inb
-#define	inb_p	mcf_pci_inb
-#define	inw	mcf_pci_inw
-#define	inw_p	mcf_pci_inw
-#define	inl	mcf_pci_inl
-#define	inl_p	mcf_pci_inl
-#define	insb	mcf_pci_insb
-#define	insw	mcf_pci_insw
-#define	insl	mcf_pci_insl
-
-#define	outb	mcf_pci_outb
-#define	outb_p	mcf_pci_outb
-#define	outw	mcf_pci_outw
-#define	outw_p	mcf_pci_outw
-#define	outl	mcf_pci_outl
-#define	outl_p	mcf_pci_outl
-#define	outsb	mcf_pci_outsb
-#define	outsw	mcf_pci_outsw
-#define	outsl	mcf_pci_outsl
-
-#define readb(addr)	in_8(addr)
-#define writeb(v, addr)	out_8((addr), (v))
-#define readw(addr)	in_le16(addr)
-#define writew(v, addr)	out_le16((addr), (v))
-
-#elif defined(CONFIG_ISA) || defined(CONFIG_ATARI_ROM_ISA)
+#if defined(CONFIG_ISA) || defined(CONFIG_ATARI_ROM_ISA)
 
 #if MULTI_ISA == 0
 #undef MULTI_ISA
@@ -415,8 +369,7 @@ static inline void isa_delay(void)
 #define writew(val, addr)	out_le16((addr), (val))
 #endif /* CONFIG_ATARI_ROM_ISA */
 
-#if !defined(CONFIG_ISA) && !defined(CONFIG_ATARI_ROM_ISA) && \
-    !(defined(CONFIG_PCI) && defined(CONFIG_COLDFIRE))
+#if !defined(CONFIG_ISA) && !defined(CONFIG_ATARI_ROM_ISA)
 /*
  * We need to define dummy functions for GENERIC_IOMAP support.
  */

commit 9746882f547d2f00d2e761b418ae690cd406c8e2
Author: Greg Ungerer <gerg@linux-m68k.org>
Date:   Sun Mar 25 22:17:38 2018 +1000

    m68k: group io mapping definitions and functions
    
    Create a new header file, kmap.h, that groups all the definitions and
    functions associated with the io mapping and remapping.
    
    Currently the functions are spread across raw_io.h and io_mm.h. And in
    the future we will want to use these in io_no.h as well. So it makes
    sense to move them all together into a single header file.
    
    It is named after the arch/m68k/mm/kmap.c file that actually implements
    many of the exported functions.
    
    Signed-off-by: Greg Ungerer <gerg@linux-m68k.org>
    Tested-by: Angelo Dureghello <angelo@sysam.it>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 22e778e293c6..21fba26f57f4 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -26,6 +26,7 @@
 #include <linux/compiler.h>
 #include <asm/raw_io.h>
 #include <asm/virtconvert.h>
+#include <asm/kmap.h>
 
 #include <asm-generic/iomap.h>
 
@@ -461,39 +462,6 @@ static inline void isa_delay(void)
 
 #define mmiowb()
 
-static inline void __iomem *ioremap(unsigned long physaddr, unsigned long size)
-{
-	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
-}
-static inline void __iomem *ioremap_nocache(unsigned long physaddr, unsigned long size)
-{
-	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
-}
-#define ioremap_uc ioremap_nocache
-static inline void __iomem *ioremap_wt(unsigned long physaddr,
-					 unsigned long size)
-{
-	return __ioremap(physaddr, size, IOMAP_WRITETHROUGH);
-}
-static inline void __iomem *ioremap_fullcache(unsigned long physaddr,
-				      unsigned long size)
-{
-	return __ioremap(physaddr, size, IOMAP_FULL_CACHING);
-}
-
-static inline void memset_io(volatile void __iomem *addr, unsigned char val, int count)
-{
-	__builtin_memset((void __force *) addr, val, count);
-}
-static inline void memcpy_fromio(void *dst, const volatile void __iomem *src, int count)
-{
-	__builtin_memcpy(dst, (void __force *) src, count);
-}
-static inline void memcpy_toio(volatile void __iomem *dst, const void *src, int count)
-{
-	__builtin_memcpy((void __force *) dst, src, count);
-}
-
 #ifndef CONFIG_SUN3
 #define IO_SPACE_LIMIT 0xffff
 #else
@@ -515,15 +483,6 @@ static inline void memcpy_toio(volatile void __iomem *dst, const void *src, int
  */
 #define xlate_dev_kmem_ptr(p)	p
 
-static inline void __iomem *ioport_map(unsigned long port, unsigned int nr)
-{
-	return (void __iomem *) port;
-}
-
-static inline void ioport_unmap(void __iomem *p)
-{
-}
-
 #define readb_relaxed(addr)	readb(addr)
 #define readw_relaxed(addr)	readw(addr)
 #define readl_relaxed(addr)	readl(addr)

commit fedc33e36406c4e50592a286169583d0d3d25a2e
Author: Greg Ungerer <gerg@linux-m68k.org>
Date:   Wed Mar 21 23:36:11 2018 +1000

    m68k: move *_relaxed macros into io_no.h and io_mm.h
    
    Move a copy of the definitions of the *_relaxed() macros into io_no.h
    and io_mm.h. This precedes a change to the io_no.h file to use
    asm-generic/io.h. They will be removed from io_no.h at that point.
    
    Signed-off-by: Greg Ungerer <gerg@linux-m68k.org>
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Angelo Dureghello <angelo@sysam.it>
    Tested-by: Angelo Dureghello <angelo@sysam.it>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index ed5333e87879..22e778e293c6 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -524,4 +524,12 @@ static inline void ioport_unmap(void __iomem *p)
 {
 }
 
+#define readb_relaxed(addr)	readb(addr)
+#define readw_relaxed(addr)	readw(addr)
+#define readl_relaxed(addr)	readl(addr)
+
+#define writeb_relaxed(b, addr)	writeb(b, addr)
+#define writew_relaxed(b, addr)	writew(b, addr)
+#define writel_relaxed(b, addr)	writel(b, addr)
+
 #endif /* _IO_H */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index c98ac81582ac..ed5333e87879 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * linux/include/asm-m68k/io.h
  *

commit 8d58b66ed2b000f27658c88a4ed70e8042e86a58
Merge: 13fe86f465b7 c13dcf9f2d6f
Author: Ingo Molnar <mingo@kernel.org>
Date:   Tue Aug 25 09:59:19 2015 +0200

    Merge tag 'v4.2-rc8' into x86/mm, before applying new changes
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 4c73e8926623ca0f64c2c6111289ab8096fa647a
Author: Luis R. Rodriguez <mcgrof@suse.com>
Date:   Tue Jul 28 20:17:13 2015 +0200

    arch/*/io.h: Add ioremap_uc() to all architectures
    
    This adds ioremap_uc() only for architectures that do not
    include asm-generic.h/io.h as that already provides a default
    definition for them for both cases where you have CONFIG_MMU
    and you do not, and because of this, the number of architectures
    this patch address is less than the architectures that the
    ioremap_wt() patch addressed, "arch/*/io.h: Add ioremap_wt() to
    all architectures").
    
    In order to reduce the number of architectures we have to
    modify by adding new architecture IO APIs we'll have to review
    the architectures in this patch, see why they can't add
    asm-generic.h/io.h or issues that would be created by doing
    so and then spread a consistent inclusion of this header
    towards the end of their own header. For instance arch/metag
    includes the asm-generic/io.h *before* the ioremap*()
    definitions, this should be the other way around but only
    once we have guard wrappers for the non-MMU case also for
    asm-generic/io.h.
    
    Reported-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Signed-off-by: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Abhilash Kesavan <a.kesavan@samsung.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Borislav Petkov <bp@suse.de>
    Cc: Chris Metcalf <cmetcalf@ezchip.com>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Fengguang Wu <fengguang.wu@intel.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Greg Ungerer <gerg@uclinux.org>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Cc: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    Cc: Kyle McMartin <kyle@redhat.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: linux-am33-list@redhat.com
    Cc: linux-arch@vger.kernel.org
    Cc: linux-m68k@lists.linux-m68k.org
    Cc: linux-sh@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Link: http://lkml.kernel.org/r/20150728181713.GB30479@wotan.suse.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 618c85d3c786..a0fce34029b3 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -467,6 +467,7 @@ static inline void __iomem *ioremap_nocache(unsigned long physaddr, unsigned lon
 {
 	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
 }
+#define ioremap_uc ioremap_nocache
 static inline void __iomem *ioremap_wt(unsigned long physaddr,
 					 unsigned long size)
 {

commit 03aa29f80e371c75370e83eded7b551951385122
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Wed Jul 8 16:54:13 2015 +1000

    m68k: fix io functions for ColdFire/MMU/PCI case
    
    The inb/outb/... family of IO methods end up being multiply defined when
    building PCI support for the ColdFire. Compiling gives this:
    
      CC      init/main.o
    In file included from ./arch/m68k/include/asm/io.h:4:0,
                     from include/linux/bio.h:30,
                     from include/linux/blkdev.h:18,
                     from init/main.c:75:
    ./arch/m68k/include/asm/io_mm.h:420:0: warning: "inb" redefined
    ./arch/m68k/include/asm/io_mm.h:108:0: note: this is the location of the previous definition
    ...
    
    The ColdFire/PCI case defines its own IO access methods, so no others
    should be defined or used in this case. Conditionally disable other
    definitions that clash with it.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 618c85d3c786..f55cad529400 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -413,7 +413,8 @@ static inline void isa_delay(void)
 #define writew(val, addr)	out_le16((addr), (val))
 #endif /* CONFIG_ATARI_ROM_ISA */
 
-#if !defined(CONFIG_ISA) && !defined(CONFIG_ATARI_ROM_ISA)
+#if !defined(CONFIG_ISA) && !defined(CONFIG_ATARI_ROM_ISA) && \
+    !(defined(CONFIG_PCI) && defined(CONFIG_COLDFIRE))
 /*
  * We need to define dummy functions for GENERIC_IOMAP support.
  */

commit c7c95f19f37976731efca9576f6e4a22067798a2
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Thu Jun 4 18:55:17 2015 +0200

    video/fbdev, asm/io.h: Remove ioremap_writethrough()
    
    Replace all calls to ioremap_writethrough() with ioremap_wt().
    Remove ioremap_writethrough() too.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Elliott@hp.com
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: arnd@arndb.de
    Cc: hch@lst.de
    Cc: hmh@hmh.eng.br
    Cc: jgross@suse.com
    Cc: konrad.wilk@oracle.com
    Cc: linux-mm <linux-mm@kvack.org>
    Cc: linux-nvdimm@lists.01.org
    Cc: stefan.bader@canonical.com
    Cc: yigal@plexistor.com
    Link: http://lkml.kernel.org/r/1433436928-31903-10-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 7c12138bb3cb..618c85d3c786 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -467,11 +467,6 @@ static inline void __iomem *ioremap_nocache(unsigned long physaddr, unsigned lon
 {
 	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
 }
-static inline void __iomem *ioremap_writethrough(unsigned long physaddr,
-					 unsigned long size)
-{
-	return __ioremap(physaddr, size, IOMAP_WRITETHROUGH);
-}
 static inline void __iomem *ioremap_wt(unsigned long physaddr,
 					 unsigned long size)
 {

commit 556269c138a8b2d3f5714b8105fa6119ecc505f2
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Thu Jun 4 18:55:16 2015 +0200

    arch/*/io.h: Add ioremap_wt() to all architectures
    
    Add ioremap_wt() to all arch-specific asm/io.h headers which
    define ioremap_wc() locally. These headers do not include
    <asm-generic/iomap.h>. Some of them include <asm-generic/io.h>,
    but ioremap_wt() is defined for consistency since they define
    all ioremap_xxx locally.
    
    In all architectures without Write-Through support, ioremap_wt()
    is defined indentical to ioremap_nocache().
    
    frv and m68k already have ioremap_writethrough(). On those we
    add ioremap_wt() indetical to ioremap_writethrough() and defines
    ARCH_HAS_IOREMAP_WT in both architectures.
    
    The ioremap_wt() interface is exported to drivers.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Elliott@hp.com
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: arnd@arndb.de
    Cc: hch@lst.de
    Cc: hmh@hmh.eng.br
    Cc: jgross@suse.com
    Cc: konrad.wilk@oracle.com
    Cc: linux-mm <linux-mm@kvack.org>
    Cc: linux-nvdimm@lists.01.org
    Cc: stefan.bader@canonical.com
    Cc: yigal@plexistor.com
    Link: http://lkml.kernel.org/r/1433436928-31903-9-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 8955b40a5dc4..7c12138bb3cb 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -20,6 +20,8 @@
 
 #ifdef __KERNEL__
 
+#define ARCH_HAS_IOREMAP_WT
+
 #include <linux/compiler.h>
 #include <asm/raw_io.h>
 #include <asm/virtconvert.h>
@@ -470,6 +472,11 @@ static inline void __iomem *ioremap_writethrough(unsigned long physaddr,
 {
 	return __ioremap(physaddr, size, IOMAP_WRITETHROUGH);
 }
+static inline void __iomem *ioremap_wt(unsigned long physaddr,
+					 unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_WRITETHROUGH);
+}
 static inline void __iomem *ioremap_fullcache(unsigned long physaddr,
 				      unsigned long size)
 {

commit a000dfc2ab201ffc43fbe925a522adeebe51f6f3
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Sep 9 11:32:44 2014 +0200

    m68k: Add missing ioport_unmap()
    
    drivers/net/ethernet/cirrus/cs89x0.c: In function ‘cs89x0_ioport_probe’:
    drivers/net/ethernet/cirrus/cs89x0.c:1629: error: implicit declaration of function ‘ioport_unmap’
    
    Add the missing ioport_unmap() implementation, and convert ioport_map()
    from a macro to a static inline function while we're at it (both copied
    from asm-generic).
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index ffdf54f44bc6..8955b40a5dc4 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -510,6 +510,13 @@ static inline void memcpy_toio(volatile void __iomem *dst, const void *src, int
  */
 #define xlate_dev_kmem_ptr(p)	p
 
-#define ioport_map(port, nr)	((void __iomem *)(port))
+static inline void __iomem *ioport_map(unsigned long port, unsigned int nr)
+{
+	return (void __iomem *) port;
+}
+
+static inline void ioport_unmap(void __iomem *p)
+{
+}
 
 #endif /* _IO_H */

commit 84b16b7b0d5c818fadc731a69965dc76dce0c91e
Author: Michael Schmitz <schmitz@opal.biophys.uni-duesseldorf.de>
Date:   Sat Apr 6 13:26:35 2013 +1300

    m68k/atari: ROM port ISA adapter support
    
    Atari ROM port ISA adapter support for EtherNEC and NetUSBee adapters
    
    16 bit access for ROM port adapters follows debugging and
    clarification by David Galvez <dgalvez75@gmail.com>. The NetUSBee
    ISP1160 USB chip uses these macros.
    
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index a6686d26fe17..ffdf54f44bc6 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -63,6 +63,23 @@
 #endif
 #endif /* AMIGA_PCMCIA */
 
+#ifdef CONFIG_ATARI_ROM_ISA
+
+#define enec_isa_read_base  0xfffa0000
+#define enec_isa_write_base 0xfffb0000
+
+#define ENEC_ISA_IO_B(ioaddr)	(enec_isa_read_base+((((unsigned long)(ioaddr))&0x7F)<<9))
+#define ENEC_ISA_IO_W(ioaddr)	(enec_isa_read_base+((((unsigned long)(ioaddr))&0x7F)<<9))
+#define ENEC_ISA_MEM_B(madr)	(enec_isa_read_base+((((unsigned long)(madr))&0x7F)<<9))
+#define ENEC_ISA_MEM_W(madr)	(enec_isa_read_base+((((unsigned long)(madr))&0x7F)<<9))
+
+#ifndef MULTI_ISA
+#define MULTI_ISA 0
+#else
+#undef MULTI_ISA
+#define MULTI_ISA 1
+#endif
+#endif /* ATARI_ROM_ISA */
 
 
 #if defined(CONFIG_PCI) && defined(CONFIG_COLDFIRE)
@@ -111,14 +128,15 @@ void mcf_pci_outsl(u32 addr, const u32 *buf, u32 len);
 #define readw(addr)	in_le16(addr)
 #define writew(v, addr)	out_le16((addr), (v))
 
-#elif defined(CONFIG_ISA)
+#elif defined(CONFIG_ISA) || defined(CONFIG_ATARI_ROM_ISA)
 
 #if MULTI_ISA == 0
 #undef MULTI_ISA
 #endif
 
-#define ISA_TYPE_Q40 (1)
-#define ISA_TYPE_AG  (2)
+#define ISA_TYPE_Q40  (1)
+#define ISA_TYPE_AG   (2)
+#define ISA_TYPE_ENEC (3)
 
 #if defined(CONFIG_Q40) && !defined(MULTI_ISA)
 #define ISA_TYPE ISA_TYPE_Q40
@@ -128,6 +146,10 @@ void mcf_pci_outsl(u32 addr, const u32 *buf, u32 len);
 #define ISA_TYPE ISA_TYPE_AG
 #define ISA_SEX  1
 #endif
+#if defined(CONFIG_ATARI_ROM_ISA) && !defined(MULTI_ISA)
+#define ISA_TYPE ISA_TYPE_ENEC
+#define ISA_SEX  0
+#endif
 
 #ifdef MULTI_ISA
 extern int isa_type;
@@ -151,6 +173,9 @@ static inline u8 __iomem *isa_itb(unsigned long addr)
 #endif
 #ifdef CONFIG_AMIGA_PCMCIA
     case ISA_TYPE_AG: return (u8 __iomem *)AG_ISA_IO_B(addr);
+#endif
+#ifdef CONFIG_ATARI_ROM_ISA
+    case ISA_TYPE_ENEC: return (u8 __iomem *)ENEC_ISA_IO_B(addr);
 #endif
     default: return NULL; /* avoid warnings, just in case */
     }
@@ -164,6 +189,9 @@ static inline u16 __iomem *isa_itw(unsigned long addr)
 #endif
 #ifdef CONFIG_AMIGA_PCMCIA
     case ISA_TYPE_AG: return (u16 __iomem *)AG_ISA_IO_W(addr);
+#endif
+#ifdef CONFIG_ATARI_ROM_ISA
+    case ISA_TYPE_ENEC: return (u16 __iomem *)ENEC_ISA_IO_W(addr);
 #endif
     default: return NULL; /* avoid warnings, just in case */
     }
@@ -187,6 +215,9 @@ static inline u8 __iomem *isa_mtb(unsigned long addr)
 #endif
 #ifdef CONFIG_AMIGA_PCMCIA
     case ISA_TYPE_AG: return (u8 __iomem *)addr;
+#endif
+#ifdef CONFIG_ATARI_ROM_ISA
+    case ISA_TYPE_ENEC: return (u8 __iomem *)ENEC_ISA_MEM_B(addr);
 #endif
     default: return NULL; /* avoid warnings, just in case */
     }
@@ -200,6 +231,9 @@ static inline u16 __iomem *isa_mtw(unsigned long addr)
 #endif
 #ifdef CONFIG_AMIGA_PCMCIA
     case ISA_TYPE_AG: return (u16 __iomem *)addr;
+#endif
+#ifdef CONFIG_ATARI_ROM_ISA
+    case ISA_TYPE_ENEC: return (u16 __iomem *)ENEC_ISA_MEM_W(addr);
 #endif
     default: return NULL; /* avoid warnings, just in case */
     }
@@ -222,6 +256,36 @@ static inline u16 __iomem *isa_mtw(unsigned long addr)
 	(ISA_SEX ? out_be16(isa_mtw((unsigned long)(p)),(val))	\
 		 : out_le16(isa_mtw((unsigned long)(p)),(val)))
 
+#ifdef CONFIG_ATARI_ROM_ISA
+#define isa_rom_inb(port)      rom_in_8(isa_itb(port))
+#define isa_rom_inw(port)	\
+	(ISA_SEX ? rom_in_be16(isa_itw(port))	\
+		 : rom_in_le16(isa_itw(port)))
+
+#define isa_rom_outb(val, port) rom_out_8(isa_itb(port), (val))
+#define isa_rom_outw(val, port)	\
+	(ISA_SEX ? rom_out_be16(isa_itw(port), (val))	\
+		 : rom_out_le16(isa_itw(port), (val)))
+
+#define isa_rom_readb(p)       rom_in_8(isa_mtb((unsigned long)(p)))
+#define isa_rom_readw(p)       \
+	(ISA_SEX ? rom_in_be16(isa_mtw((unsigned long)(p)))	\
+		 : rom_in_le16(isa_mtw((unsigned long)(p))))
+#define isa_rom_readw_swap(p)       \
+	(ISA_SEX ? rom_in_le16(isa_mtw((unsigned long)(p)))	\
+		 : rom_in_be16(isa_mtw((unsigned long)(p))))
+#define isa_rom_readw_raw(p)   rom_in_be16(isa_mtw((unsigned long)(p)))
+
+#define isa_rom_writeb(val, p)  rom_out_8(isa_mtb((unsigned long)(p)), (val))
+#define isa_rom_writew(val, p)  \
+	(ISA_SEX ? rom_out_be16(isa_mtw((unsigned long)(p)), (val))	\
+		 : rom_out_le16(isa_mtw((unsigned long)(p)), (val)))
+#define isa_rom_writew_swap(val, p)  \
+	(ISA_SEX ? rom_out_le16(isa_mtw((unsigned long)(p)), (val))	\
+		 : rom_out_be16(isa_mtw((unsigned long)(p)), (val)))
+#define isa_rom_writew_raw(val, p)  rom_out_be16(isa_mtw((unsigned long)(p)), (val))
+#endif /* CONFIG_ATARI_ROM_ISA */
+
 static inline void isa_delay(void)
 {
   switch(ISA_TYPE)
@@ -231,6 +295,9 @@ static inline void isa_delay(void)
 #endif
 #ifdef CONFIG_AMIGA_PCMCIA
     case ISA_TYPE_AG: break;
+#endif
+#ifdef CONFIG_ATARI_ROM_ISA
+    case ISA_TYPE_ENEC: break;
 #endif
     default: break; /* avoid warnings */
     }
@@ -263,6 +330,29 @@ static inline void isa_delay(void)
                   raw_outsw_swapw(isa_itw(port), (u16 *)(buf), (nr)<<1))
 
 
+#ifdef CONFIG_ATARI_ROM_ISA
+#define isa_rom_inb_p(p)	({ u8 _v = isa_rom_inb(p); isa_delay(); _v; })
+#define isa_rom_inw_p(p)	({ u16 _v = isa_rom_inw(p); isa_delay(); _v; })
+#define isa_rom_outb_p(v, p)	({ isa_rom_outb((v), (p)); isa_delay(); })
+#define isa_rom_outw_p(v, p)	({ isa_rom_outw((v), (p)); isa_delay(); })
+
+#define isa_rom_insb(port, buf, nr) raw_rom_insb(isa_itb(port), (u8 *)(buf), (nr))
+
+#define isa_rom_insw(port, buf, nr)     \
+       (ISA_SEX ? raw_rom_insw(isa_itw(port), (u16 *)(buf), (nr)) :    \
+		  raw_rom_insw_swapw(isa_itw(port), (u16 *)(buf), (nr)))
+
+#define isa_rom_outsb(port, buf, nr) raw_rom_outsb(isa_itb(port), (u8 *)(buf), (nr))
+
+#define isa_rom_outsw(port, buf, nr)    \
+       (ISA_SEX ? raw_rom_outsw(isa_itw(port), (u16 *)(buf), (nr)) :  \
+		  raw_rom_outsw_swapw(isa_itw(port), (u16 *)(buf), (nr)))
+#endif /* CONFIG_ATARI_ROM_ISA */
+
+#endif  /* CONFIG_ISA || CONFIG_ATARI_ROM_ISA */
+
+
+#if defined(CONFIG_ISA) && !defined(CONFIG_ATARI_ROM_ISA)
 #define inb     isa_inb
 #define inb_p   isa_inb_p
 #define outb    isa_outb
@@ -285,9 +375,43 @@ static inline void isa_delay(void)
 #define readw   isa_readw
 #define writeb  isa_writeb
 #define writew  isa_writew
+#endif  /* CONFIG_ISA && !CONFIG_ATARI_ROM_ISA */
 
-#else  /* CONFIG_ISA */
-
+#ifdef CONFIG_ATARI_ROM_ISA
+/*
+ * kernel with both ROM port ISA and IDE compiled in, those have
+ * conflicting defs for in/out. Simply consider port < 1024
+ * ROM port ISA and everything else regular ISA for IDE. read,write defined
+ * below.
+ */
+#define inb(port)	((port) < 1024 ? isa_rom_inb(port) : in_8(port))
+#define inb_p(port)	((port) < 1024 ? isa_rom_inb_p(port) : in_8(port))
+#define inw(port)	((port) < 1024 ? isa_rom_inw(port) : in_le16(port))
+#define inw_p(port)	((port) < 1024 ? isa_rom_inw_p(port) : in_le16(port))
+#define inl		isa_inl
+#define inl_p		isa_inl_p
+
+#define outb(val, port)	((port) < 1024 ? isa_rom_outb((val), (port)) : out_8((port), (val)))
+#define outb_p(val, port) ((port) < 1024 ? isa_rom_outb_p((val), (port)) : out_8((port), (val)))
+#define outw(val, port)	((port) < 1024 ? isa_rom_outw((val), (port)) : out_le16((port), (val)))
+#define outw_p(val, port) ((port) < 1024 ? isa_rom_outw_p((val), (port)) : out_le16((port), (val)))
+#define outl		isa_outl
+#define outl_p		isa_outl_p
+
+#define insb(port, buf, nr)	((port) < 1024 ? isa_rom_insb((port), (buf), (nr)) : isa_insb((port), (buf), (nr)))
+#define insw(port, buf, nr)	((port) < 1024 ? isa_rom_insw((port), (buf), (nr)) : isa_insw((port), (buf), (nr)))
+#define insl			isa_insl
+#define outsb(port, buf, nr)	((port) < 1024 ? isa_rom_outsb((port), (buf), (nr)) : isa_outsb((port), (buf), (nr)))
+#define outsw(port, buf, nr)	((port) < 1024 ? isa_rom_outsw((port), (buf), (nr)) : isa_outsw((port), (buf), (nr)))
+#define outsl			isa_outsl
+
+#define readb(addr)		in_8(addr)
+#define writeb(val, addr)	out_8((addr), (val))
+#define readw(addr)		in_le16(addr)
+#define writew(val, addr)	out_le16((addr), (val))
+#endif /* CONFIG_ATARI_ROM_ISA */
+
+#if !defined(CONFIG_ISA) && !defined(CONFIG_ATARI_ROM_ISA)
 /*
  * We need to define dummy functions for GENERIC_IOMAP support.
  */
@@ -319,7 +443,7 @@ static inline void isa_delay(void)
 #define readw(addr)      in_le16(addr)
 #define writew(val,addr) out_le16((addr),(val))
 
-#endif /* CONFIG_ISA */
+#endif /* !CONFIG_ISA && !CONFIG_ATARI_ROM_ISA */
 
 #define readl(addr)      in_le32(addr)
 #define writel(val,addr) out_le32((addr),(val))

commit 9ff601a41ff5d0d1e4fc06d2c313a86a5f84cba4
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Fri Jun 29 00:03:27 2012 +1000

    m68k: add IO access definitions to support PCI on ColdFire platforms
    
    Define the usual memory access functions (readb/writeb/...) and I/O space
    functions (inb/outb/...) for PCI bus support on ColdFire CPU based platforms.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index b85dbef85e1c..a6686d26fe17 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -65,7 +65,53 @@
 
 
 
-#ifdef CONFIG_ISA
+#if defined(CONFIG_PCI) && defined(CONFIG_COLDFIRE)
+
+#define HAVE_ARCH_PIO_SIZE
+#define PIO_OFFSET	0
+#define PIO_MASK	0xffff
+#define PIO_RESERVED	0x10000
+
+u8 mcf_pci_inb(u32 addr);
+u16 mcf_pci_inw(u32 addr);
+u32 mcf_pci_inl(u32 addr);
+void mcf_pci_insb(u32 addr, u8 *buf, u32 len);
+void mcf_pci_insw(u32 addr, u16 *buf, u32 len);
+void mcf_pci_insl(u32 addr, u32 *buf, u32 len);
+
+void mcf_pci_outb(u8 v, u32 addr);
+void mcf_pci_outw(u16 v, u32 addr);
+void mcf_pci_outl(u32 v, u32 addr);
+void mcf_pci_outsb(u32 addr, const u8 *buf, u32 len);
+void mcf_pci_outsw(u32 addr, const u16 *buf, u32 len);
+void mcf_pci_outsl(u32 addr, const u32 *buf, u32 len);
+
+#define	inb	mcf_pci_inb
+#define	inb_p	mcf_pci_inb
+#define	inw	mcf_pci_inw
+#define	inw_p	mcf_pci_inw
+#define	inl	mcf_pci_inl
+#define	inl_p	mcf_pci_inl
+#define	insb	mcf_pci_insb
+#define	insw	mcf_pci_insw
+#define	insl	mcf_pci_insl
+
+#define	outb	mcf_pci_outb
+#define	outb_p	mcf_pci_outb
+#define	outw	mcf_pci_outw
+#define	outw_p	mcf_pci_outw
+#define	outl	mcf_pci_outl
+#define	outl_p	mcf_pci_outl
+#define	outsb	mcf_pci_outsb
+#define	outsw	mcf_pci_outsw
+#define	outsl	mcf_pci_outsl
+
+#define readb(addr)	in_8(addr)
+#define writeb(v, addr)	out_8((addr), (v))
+#define readw(addr)	in_le16(addr)
+#define writew(v, addr)	out_le16((addr), (v))
+
+#elif defined(CONFIG_ISA)
 
 #if MULTI_ISA == 0
 #undef MULTI_ISA

commit e93a6bbeb5a5f473293dd62f92903f89ec8004aa
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Mon Nov 28 16:32:49 2011 +1000

    m68k: common PCI support definitions and code
    
    Basic set of definitions and support code required to turn on CONFIG_PCI
    for the m68k architecture. Nothing specific to any PCI implementation in
    any m68k class CPU hardware yet.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index fa4324bcf566..b85dbef85e1c 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -340,4 +340,6 @@ static inline void memcpy_toio(volatile void __iomem *dst, const void *src, int
  */
 #define xlate_dev_kmem_ptr(p)	p
 
+#define ioport_map(port, nr)	((void __iomem *)(port))
+
 #endif /* _IO_H */

commit f5db9c6a3dd94033a113a6bd9ccce9f8c28c70b1
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 15 20:37:39 2012 +0200

    m68k: Make sure {read,write}s[bwl]() are always defined
    
    drivers/usb/musb/musb_io.h provides default implementations for
    {read,write}s[bwl]() on most platforms, some of which will conflict soon
    with platform-specific counterparts on m68k.
    
    To avoid having to add more platform-specific checks to musb_io.h later,
    make sure {read,write}s[bwl]() are always defined on m68k, and disable the
    default implementations in musb_io.h on m68k, like is already done for
    several other architectures.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Felipe Balbi <balbi@ti.com>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 0fb3468000e7..fa4324bcf566 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -278,6 +278,13 @@ static inline void isa_delay(void)
 #define readl(addr)      in_le32(addr)
 #define writel(val,addr) out_le32((addr),(val))
 
+#define readsb(port, buf, nr)     raw_insb((port), (u8 *)(buf), (nr))
+#define readsw(port, buf, nr)     raw_insw((port), (u16 *)(buf), (nr))
+#define readsl(port, buf, nr)     raw_insl((port), (u32 *)(buf), (nr))
+#define writesb(port, buf, nr)    raw_outsb((port), (u8 *)(buf), (nr))
+#define writesw(port, buf, nr)    raw_outsw((port), (u16 *)(buf), (nr))
+#define writesl(port, buf, nr)    raw_outsl((port), (u32 *)(buf), (nr))
+
 #define mmiowb()
 
 static inline void __iomem *ioremap(unsigned long physaddr, unsigned long size)

commit 779b7e64b536ff65bcd40c0292871d2bb9b6d6e5
Author: Thorsten Glaser <tg@debian.org>
Date:   Sun Oct 3 18:48:51 2010 +0000

    m68k: Add missing I/O macros {in,out}{w,l}_p() for !CONFIG_ISA
    
    On m68k, I/O macros like inb() outw() etc. are only defined to
    something useful if CONFIG_ISA is set; dummies are in place if
    not, but four macros were missing from the !CONFIG_ISA case.
    Adding these makes some drivers, such as speakup, compile again.
    
    Signed-off-by: Thorsten Glaser <tg@debian.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 125cb60a2df9..0fb3468000e7 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -250,9 +250,13 @@ static inline void isa_delay(void)
 #define outb(val,port)     ((void)0)
 #define outb_p(val,port)   ((void)0)
 #define inw(port)          0xffff
+#define inw_p(port)        0xffff
 #define outw(val,port)     ((void)0)
+#define outw_p(val,port)   ((void)0)
 #define inl(port)          0xffffffffUL
+#define inl_p(port)        0xffffffffUL
 #define outl(val,port)     ((void)0)
+#define outl_p(val,port)   ((void)0)
 
 #define insb(port,buf,nr)  ((void)0)
 #define outsb(port,buf,nr) ((void)0)

commit 808fa62f1b0f75eef76aa3a7682a8fd89eae581f
Author: Christian Dietrich <qy03fugy@stud.informatik.uni-erlangen.de>
Date:   Wed Aug 4 14:41:34 2010 +0200

    m68k: Remove dead GG2 config option
    
    CONFIG_GG2 doesn't exist in Kconfig, therefore remove
    all references to it from the source.
    
    Signed-off-by: Christian Dietrich <qy03fugy@stud.informatik.uni-erlangen.de>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
index 9e673e3bd434..125cb60a2df9 100644
--- a/arch/m68k/include/asm/io_mm.h
+++ b/arch/m68k/include/asm/io_mm.h
@@ -49,23 +49,6 @@
 #define MULTI_ISA 0
 #endif /* Q40 */
 
-/* GG-II Zorro to ISA bridge */
-#ifdef CONFIG_GG2
-
-extern unsigned long gg2_isa_base;
-#define GG2_ISA_IO_B(ioaddr) (gg2_isa_base+1+((unsigned long)(ioaddr)*4))
-#define GG2_ISA_IO_W(ioaddr) (gg2_isa_base+  ((unsigned long)(ioaddr)*4))
-#define GG2_ISA_MEM_B(madr)  (gg2_isa_base+1+(((unsigned long)(madr)*4) & 0xfffff))
-#define GG2_ISA_MEM_W(madr)  (gg2_isa_base+  (((unsigned long)(madr)*4) & 0xfffff))
-
-#ifndef MULTI_ISA
-#define MULTI_ISA 0
-#else
-#undef MULTI_ISA
-#define MULTI_ISA 1
-#endif
-#endif /* GG2 */
-
 #ifdef CONFIG_AMIGA_PCMCIA
 #include <asm/amigayle.h>
 
@@ -89,8 +72,7 @@ extern unsigned long gg2_isa_base;
 #endif
 
 #define ISA_TYPE_Q40 (1)
-#define ISA_TYPE_GG2 (2)
-#define ISA_TYPE_AG  (3)
+#define ISA_TYPE_AG  (2)
 
 #if defined(CONFIG_Q40) && !defined(MULTI_ISA)
 #define ISA_TYPE ISA_TYPE_Q40
@@ -100,10 +82,6 @@ extern unsigned long gg2_isa_base;
 #define ISA_TYPE ISA_TYPE_AG
 #define ISA_SEX  1
 #endif
-#if defined(CONFIG_GG2) && !defined(MULTI_ISA)
-#define ISA_TYPE ISA_TYPE_GG2
-#define ISA_SEX  0
-#endif
 
 #ifdef MULTI_ISA
 extern int isa_type;
@@ -125,9 +103,6 @@ static inline u8 __iomem *isa_itb(unsigned long addr)
 #ifdef CONFIG_Q40
     case ISA_TYPE_Q40: return (u8 __iomem *)Q40_ISA_IO_B(addr);
 #endif
-#ifdef CONFIG_GG2
-    case ISA_TYPE_GG2: return (u8 __iomem *)GG2_ISA_IO_B(addr);
-#endif
 #ifdef CONFIG_AMIGA_PCMCIA
     case ISA_TYPE_AG: return (u8 __iomem *)AG_ISA_IO_B(addr);
 #endif
@@ -141,9 +116,6 @@ static inline u16 __iomem *isa_itw(unsigned long addr)
 #ifdef CONFIG_Q40
     case ISA_TYPE_Q40: return (u16 __iomem *)Q40_ISA_IO_W(addr);
 #endif
-#ifdef CONFIG_GG2
-    case ISA_TYPE_GG2: return (u16 __iomem *)GG2_ISA_IO_W(addr);
-#endif
 #ifdef CONFIG_AMIGA_PCMCIA
     case ISA_TYPE_AG: return (u16 __iomem *)AG_ISA_IO_W(addr);
 #endif
@@ -167,9 +139,6 @@ static inline u8 __iomem *isa_mtb(unsigned long addr)
 #ifdef CONFIG_Q40
     case ISA_TYPE_Q40: return (u8 __iomem *)Q40_ISA_MEM_B(addr);
 #endif
-#ifdef CONFIG_GG2
-    case ISA_TYPE_GG2: return (u8 __iomem *)GG2_ISA_MEM_B(addr);
-#endif
 #ifdef CONFIG_AMIGA_PCMCIA
     case ISA_TYPE_AG: return (u8 __iomem *)addr;
 #endif
@@ -183,9 +152,6 @@ static inline u16 __iomem *isa_mtw(unsigned long addr)
 #ifdef CONFIG_Q40
     case ISA_TYPE_Q40: return (u16 __iomem *)Q40_ISA_MEM_W(addr);
 #endif
-#ifdef CONFIG_GG2
-    case ISA_TYPE_GG2: return (u16 __iomem *)GG2_ISA_MEM_W(addr);
-#endif
 #ifdef CONFIG_AMIGA_PCMCIA
     case ISA_TYPE_AG: return (u16 __iomem *)addr;
 #endif
@@ -217,9 +183,6 @@ static inline void isa_delay(void)
 #ifdef CONFIG_Q40
     case ISA_TYPE_Q40: isa_outb(0,0x80); break;
 #endif
-#ifdef CONFIG_GG2
-    case ISA_TYPE_GG2: break;
-#endif
 #ifdef CONFIG_AMIGA_PCMCIA
     case ISA_TYPE_AG: break;
 #endif

commit 49148020bcb6910ce71417bd990a5ce7017f9bd3
Author: Sam Ravnborg <sam@ravnborg.org>
Date:   Fri Jan 16 21:58:10 2009 +1000

    m68k,m68knommu: merge header files
    
    Merge header files for m68k and m68knommu to the single location:
    
        arch/m68k/include/asm
    
    The majority of this patch was the result of the
    script that is included in the changelog below.
    
    The script was originally written by Arnd Bergman and
    exten by me to cover a few more files.
    
    When the header files differed the script uses the following:
    
    The original m68k file is named <file>_mm.h  [mm for memory manager]
    The m68knommu file is named <file>_no.h [no for no memory manager]
    
    The files uses the following include guard:
    
    This include gaurd works as the m68knommu toolchain set
    the __uClinux__ symbol - so this should work in userspace too.
    
    Merging the header files for m68k and m68knommu exposes the
    (unexpected?) ABI differences thus it is easier to actually
    identify these and thus to fix them.
    
    The commit has been build tested with both a m68k and
    a m68knommu toolchain - with success.
    
    The commit has also been tested with "make headers_check"
    and this patch fixes make headers_check for m68knommu.
    
    The script used:
    TARGET=arch/m68k/include/asm
    SOURCE=arch/m68knommu/include/asm
    
    INCLUDE="cachectl.h errno.h fcntl.h hwtest.h ioctls.h ipcbuf.h \
    linkage.h math-emu.h md.h mman.h movs.h msgbuf.h openprom.h \
    oplib.h poll.h posix_types.h resource.h rtc.h sembuf.h shmbuf.h \
    shm.h shmparam.h socket.h sockios.h spinlock.h statfs.h stat.h \
    termbits.h termios.h tlb.h types.h user.h"
    
    EQUAL="auxvec.h cputime.h device.h emergency-restart.h futex.h \
    ioctl.h irq_regs.h kdebug.h local.h mutex.h percpu.h \
    sections.h topology.h"
    
    NOMUUFILES="anchor.h bootstd.h coldfire.h commproc.h dbg.h \
    elia.h flat.h m5206sim.h m520xsim.h m523xsim.h m5249sim.h \
    m5272sim.h m527xsim.h m528xsim.h m5307sim.h m532xsim.h \
    m5407sim.h m68360_enet.h m68360.h m68360_pram.h m68360_quicc.h \
    m68360_regs.h MC68328.h MC68332.h MC68EZ328.h MC68VZ328.h \
    mcfcache.h mcfdma.h mcfmbus.h mcfne.h mcfpci.h mcfpit.h \
    mcfsim.h mcfsmc.h mcftimer.h mcfuart.h mcfwdebug.h \
    nettel.h quicc_simple.h smp.h"
    
    FILES="atomic.h bitops.h bootinfo.h bug.h bugs.h byteorder.h cache.h \
    cacheflush.h checksum.h current.h delay.h div64.h \
    dma-mapping.h dma.h elf.h entry.h fb.h fpu.h hardirq.h hw_irq.h io.h \
    irq.h kmap_types.h machdep.h mc146818rtc.h mmu.h mmu_context.h \
    module.h page.h page_offset.h param.h pci.h pgalloc.h \
    pgtable.h processor.h ptrace.h scatterlist.h segment.h \
    setup.h sigcontext.h siginfo.h signal.h string.h system.h swab.h \
    thread_info.h timex.h tlbflush.h traps.h uaccess.h ucontext.h \
    unaligned.h unistd.h"
    
    mergefile() {
            BASE=${1%.h}
            git mv ${SOURCE}/$1 ${TARGET}/${BASE}_no.h
            git mv ${TARGET}/$1 ${TARGET}/${BASE}_mm.h
    
    cat << EOF > ${TARGET}/$1
    EOF
    
            git add ${TARGET}/$1
    }
    
    set -e
    
    mkdir -p ${TARGET}
    
    git mv include/asm-m68k/* ${TARGET}
    rmdir include/asm-m68k
    
    git rm ${SOURCE}/Kbuild
    for F in $INCLUDE $EQUAL; do
            git rm ${SOURCE}/$F
    done
    
    for F in $NOMUUFILES; do
            git mv ${SOURCE}/$F ${TARGET}/$F
    done
    
    for F in $FILES ; do
            mergefile $F
    done
    
    rmdir arch/m68knommu/include/asm
    rmdir arch/m68knommu/include
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/include/asm/io_mm.h b/arch/m68k/include/asm/io_mm.h
new file mode 100644
index 000000000000..9e673e3bd434
--- /dev/null
+++ b/arch/m68k/include/asm/io_mm.h
@@ -0,0 +1,369 @@
+/*
+ * linux/include/asm-m68k/io.h
+ *
+ * 4/1/00 RZ: - rewritten to avoid clashes between ISA/PCI and other
+ *              IO access
+ *            - added Q40 support
+ *            - added skeleton for GG-II and Amiga PCMCIA
+ * 2/3/01 RZ: - moved a few more defs into raw_io.h
+ *
+ * inX/outX should not be used by any driver unless it does
+ * ISA access. Other drivers should use function defined in raw_io.h
+ * or define its own macros on top of these.
+ *
+ *    inX(),outX()              are for ISA I/O
+ *    isa_readX(),isa_writeX()  are for ISA memory
+ */
+
+#ifndef _IO_H
+#define _IO_H
+
+#ifdef __KERNEL__
+
+#include <linux/compiler.h>
+#include <asm/raw_io.h>
+#include <asm/virtconvert.h>
+
+#include <asm-generic/iomap.h>
+
+#ifdef CONFIG_ATARI
+#include <asm/atarihw.h>
+#endif
+
+
+/*
+ * IO/MEM definitions for various ISA bridges
+ */
+
+
+#ifdef CONFIG_Q40
+
+#define q40_isa_io_base  0xff400000
+#define q40_isa_mem_base 0xff800000
+
+#define Q40_ISA_IO_B(ioaddr) (q40_isa_io_base+1+4*((unsigned long)(ioaddr)))
+#define Q40_ISA_IO_W(ioaddr) (q40_isa_io_base+  4*((unsigned long)(ioaddr)))
+#define Q40_ISA_MEM_B(madr)  (q40_isa_mem_base+1+4*((unsigned long)(madr)))
+#define Q40_ISA_MEM_W(madr)  (q40_isa_mem_base+  4*((unsigned long)(madr)))
+
+#define MULTI_ISA 0
+#endif /* Q40 */
+
+/* GG-II Zorro to ISA bridge */
+#ifdef CONFIG_GG2
+
+extern unsigned long gg2_isa_base;
+#define GG2_ISA_IO_B(ioaddr) (gg2_isa_base+1+((unsigned long)(ioaddr)*4))
+#define GG2_ISA_IO_W(ioaddr) (gg2_isa_base+  ((unsigned long)(ioaddr)*4))
+#define GG2_ISA_MEM_B(madr)  (gg2_isa_base+1+(((unsigned long)(madr)*4) & 0xfffff))
+#define GG2_ISA_MEM_W(madr)  (gg2_isa_base+  (((unsigned long)(madr)*4) & 0xfffff))
+
+#ifndef MULTI_ISA
+#define MULTI_ISA 0
+#else
+#undef MULTI_ISA
+#define MULTI_ISA 1
+#endif
+#endif /* GG2 */
+
+#ifdef CONFIG_AMIGA_PCMCIA
+#include <asm/amigayle.h>
+
+#define AG_ISA_IO_B(ioaddr) ( GAYLE_IO+(ioaddr)+(((ioaddr)&1)*GAYLE_ODD) )
+#define AG_ISA_IO_W(ioaddr) ( GAYLE_IO+(ioaddr) )
+
+#ifndef MULTI_ISA
+#define MULTI_ISA 0
+#else
+#undef MULTI_ISA
+#define MULTI_ISA 1
+#endif
+#endif /* AMIGA_PCMCIA */
+
+
+
+#ifdef CONFIG_ISA
+
+#if MULTI_ISA == 0
+#undef MULTI_ISA
+#endif
+
+#define ISA_TYPE_Q40 (1)
+#define ISA_TYPE_GG2 (2)
+#define ISA_TYPE_AG  (3)
+
+#if defined(CONFIG_Q40) && !defined(MULTI_ISA)
+#define ISA_TYPE ISA_TYPE_Q40
+#define ISA_SEX  0
+#endif
+#if defined(CONFIG_AMIGA_PCMCIA) && !defined(MULTI_ISA)
+#define ISA_TYPE ISA_TYPE_AG
+#define ISA_SEX  1
+#endif
+#if defined(CONFIG_GG2) && !defined(MULTI_ISA)
+#define ISA_TYPE ISA_TYPE_GG2
+#define ISA_SEX  0
+#endif
+
+#ifdef MULTI_ISA
+extern int isa_type;
+extern int isa_sex;
+
+#define ISA_TYPE isa_type
+#define ISA_SEX  isa_sex
+#endif
+
+/*
+ * define inline addr translation functions. Normally only one variant will
+ * be compiled in so the case statement will be optimised away
+ */
+
+static inline u8 __iomem *isa_itb(unsigned long addr)
+{
+  switch(ISA_TYPE)
+    {
+#ifdef CONFIG_Q40
+    case ISA_TYPE_Q40: return (u8 __iomem *)Q40_ISA_IO_B(addr);
+#endif
+#ifdef CONFIG_GG2
+    case ISA_TYPE_GG2: return (u8 __iomem *)GG2_ISA_IO_B(addr);
+#endif
+#ifdef CONFIG_AMIGA_PCMCIA
+    case ISA_TYPE_AG: return (u8 __iomem *)AG_ISA_IO_B(addr);
+#endif
+    default: return NULL; /* avoid warnings, just in case */
+    }
+}
+static inline u16 __iomem *isa_itw(unsigned long addr)
+{
+  switch(ISA_TYPE)
+    {
+#ifdef CONFIG_Q40
+    case ISA_TYPE_Q40: return (u16 __iomem *)Q40_ISA_IO_W(addr);
+#endif
+#ifdef CONFIG_GG2
+    case ISA_TYPE_GG2: return (u16 __iomem *)GG2_ISA_IO_W(addr);
+#endif
+#ifdef CONFIG_AMIGA_PCMCIA
+    case ISA_TYPE_AG: return (u16 __iomem *)AG_ISA_IO_W(addr);
+#endif
+    default: return NULL; /* avoid warnings, just in case */
+    }
+}
+static inline u32 __iomem *isa_itl(unsigned long addr)
+{
+  switch(ISA_TYPE)
+    {
+#ifdef CONFIG_AMIGA_PCMCIA
+    case ISA_TYPE_AG: return (u32 __iomem *)AG_ISA_IO_W(addr);
+#endif
+    default: return 0; /* avoid warnings, just in case */
+    }
+}
+static inline u8 __iomem *isa_mtb(unsigned long addr)
+{
+  switch(ISA_TYPE)
+    {
+#ifdef CONFIG_Q40
+    case ISA_TYPE_Q40: return (u8 __iomem *)Q40_ISA_MEM_B(addr);
+#endif
+#ifdef CONFIG_GG2
+    case ISA_TYPE_GG2: return (u8 __iomem *)GG2_ISA_MEM_B(addr);
+#endif
+#ifdef CONFIG_AMIGA_PCMCIA
+    case ISA_TYPE_AG: return (u8 __iomem *)addr;
+#endif
+    default: return NULL; /* avoid warnings, just in case */
+    }
+}
+static inline u16 __iomem *isa_mtw(unsigned long addr)
+{
+  switch(ISA_TYPE)
+    {
+#ifdef CONFIG_Q40
+    case ISA_TYPE_Q40: return (u16 __iomem *)Q40_ISA_MEM_W(addr);
+#endif
+#ifdef CONFIG_GG2
+    case ISA_TYPE_GG2: return (u16 __iomem *)GG2_ISA_MEM_W(addr);
+#endif
+#ifdef CONFIG_AMIGA_PCMCIA
+    case ISA_TYPE_AG: return (u16 __iomem *)addr;
+#endif
+    default: return NULL; /* avoid warnings, just in case */
+    }
+}
+
+
+#define isa_inb(port)      in_8(isa_itb(port))
+#define isa_inw(port)      (ISA_SEX ? in_be16(isa_itw(port)) : in_le16(isa_itw(port)))
+#define isa_inl(port)      (ISA_SEX ? in_be32(isa_itl(port)) : in_le32(isa_itl(port)))
+#define isa_outb(val,port) out_8(isa_itb(port),(val))
+#define isa_outw(val,port) (ISA_SEX ? out_be16(isa_itw(port),(val)) : out_le16(isa_itw(port),(val)))
+#define isa_outl(val,port) (ISA_SEX ? out_be32(isa_itl(port),(val)) : out_le32(isa_itl(port),(val)))
+
+#define isa_readb(p)       in_8(isa_mtb((unsigned long)(p)))
+#define isa_readw(p)       \
+	(ISA_SEX ? in_be16(isa_mtw((unsigned long)(p)))	\
+		 : in_le16(isa_mtw((unsigned long)(p))))
+#define isa_writeb(val,p)  out_8(isa_mtb((unsigned long)(p)),(val))
+#define isa_writew(val,p)  \
+	(ISA_SEX ? out_be16(isa_mtw((unsigned long)(p)),(val))	\
+		 : out_le16(isa_mtw((unsigned long)(p)),(val)))
+
+static inline void isa_delay(void)
+{
+  switch(ISA_TYPE)
+    {
+#ifdef CONFIG_Q40
+    case ISA_TYPE_Q40: isa_outb(0,0x80); break;
+#endif
+#ifdef CONFIG_GG2
+    case ISA_TYPE_GG2: break;
+#endif
+#ifdef CONFIG_AMIGA_PCMCIA
+    case ISA_TYPE_AG: break;
+#endif
+    default: break; /* avoid warnings */
+    }
+}
+
+#define isa_inb_p(p)      ({u8 v=isa_inb(p);isa_delay();v;})
+#define isa_outb_p(v,p)   ({isa_outb((v),(p));isa_delay();})
+#define isa_inw_p(p)      ({u16 v=isa_inw(p);isa_delay();v;})
+#define isa_outw_p(v,p)   ({isa_outw((v),(p));isa_delay();})
+#define isa_inl_p(p)      ({u32 v=isa_inl(p);isa_delay();v;})
+#define isa_outl_p(v,p)   ({isa_outl((v),(p));isa_delay();})
+
+#define isa_insb(port, buf, nr) raw_insb(isa_itb(port), (u8 *)(buf), (nr))
+#define isa_outsb(port, buf, nr) raw_outsb(isa_itb(port), (u8 *)(buf), (nr))
+
+#define isa_insw(port, buf, nr)     \
+       (ISA_SEX ? raw_insw(isa_itw(port), (u16 *)(buf), (nr)) :    \
+                  raw_insw_swapw(isa_itw(port), (u16 *)(buf), (nr)))
+
+#define isa_outsw(port, buf, nr)    \
+       (ISA_SEX ? raw_outsw(isa_itw(port), (u16 *)(buf), (nr)) :  \
+                  raw_outsw_swapw(isa_itw(port), (u16 *)(buf), (nr)))
+
+#define isa_insl(port, buf, nr)     \
+       (ISA_SEX ? raw_insl(isa_itl(port), (u32 *)(buf), (nr)) :    \
+                  raw_insw_swapw(isa_itw(port), (u16 *)(buf), (nr)<<1))
+
+#define isa_outsl(port, buf, nr)    \
+       (ISA_SEX ? raw_outsl(isa_itl(port), (u32 *)(buf), (nr)) :  \
+                  raw_outsw_swapw(isa_itw(port), (u16 *)(buf), (nr)<<1))
+
+
+#define inb     isa_inb
+#define inb_p   isa_inb_p
+#define outb    isa_outb
+#define outb_p  isa_outb_p
+#define inw     isa_inw
+#define inw_p   isa_inw_p
+#define outw    isa_outw
+#define outw_p  isa_outw_p
+#define inl     isa_inl
+#define inl_p   isa_inl_p
+#define outl    isa_outl
+#define outl_p  isa_outl_p
+#define insb    isa_insb
+#define insw    isa_insw
+#define insl    isa_insl
+#define outsb   isa_outsb
+#define outsw   isa_outsw
+#define outsl   isa_outsl
+#define readb   isa_readb
+#define readw   isa_readw
+#define writeb  isa_writeb
+#define writew  isa_writew
+
+#else  /* CONFIG_ISA */
+
+/*
+ * We need to define dummy functions for GENERIC_IOMAP support.
+ */
+#define inb(port)          0xff
+#define inb_p(port)        0xff
+#define outb(val,port)     ((void)0)
+#define outb_p(val,port)   ((void)0)
+#define inw(port)          0xffff
+#define outw(val,port)     ((void)0)
+#define inl(port)          0xffffffffUL
+#define outl(val,port)     ((void)0)
+
+#define insb(port,buf,nr)  ((void)0)
+#define outsb(port,buf,nr) ((void)0)
+#define insw(port,buf,nr)  ((void)0)
+#define outsw(port,buf,nr) ((void)0)
+#define insl(port,buf,nr)  ((void)0)
+#define outsl(port,buf,nr) ((void)0)
+
+/*
+ * These should be valid on any ioremap()ed region
+ */
+#define readb(addr)      in_8(addr)
+#define writeb(val,addr) out_8((addr),(val))
+#define readw(addr)      in_le16(addr)
+#define writew(val,addr) out_le16((addr),(val))
+
+#endif /* CONFIG_ISA */
+
+#define readl(addr)      in_le32(addr)
+#define writel(val,addr) out_le32((addr),(val))
+
+#define mmiowb()
+
+static inline void __iomem *ioremap(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
+}
+static inline void __iomem *ioremap_nocache(unsigned long physaddr, unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_NOCACHE_SER);
+}
+static inline void __iomem *ioremap_writethrough(unsigned long physaddr,
+					 unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_WRITETHROUGH);
+}
+static inline void __iomem *ioremap_fullcache(unsigned long physaddr,
+				      unsigned long size)
+{
+	return __ioremap(physaddr, size, IOMAP_FULL_CACHING);
+}
+
+static inline void memset_io(volatile void __iomem *addr, unsigned char val, int count)
+{
+	__builtin_memset((void __force *) addr, val, count);
+}
+static inline void memcpy_fromio(void *dst, const volatile void __iomem *src, int count)
+{
+	__builtin_memcpy(dst, (void __force *) src, count);
+}
+static inline void memcpy_toio(volatile void __iomem *dst, const void *src, int count)
+{
+	__builtin_memcpy((void __force *) dst, src, count);
+}
+
+#ifndef CONFIG_SUN3
+#define IO_SPACE_LIMIT 0xffff
+#else
+#define IO_SPACE_LIMIT 0x0fffffff
+#endif
+
+#endif /* __KERNEL__ */
+
+#define __ARCH_HAS_NO_PAGE_ZERO_MAPPED		1
+
+/*
+ * Convert a physical pointer to a virtual kernel pointer for /dev/mem
+ * access
+ */
+#define xlate_dev_mem_ptr(p)	__va(p)
+
+/*
+ * Convert a virtual cached pointer to an uncached pointer
+ */
+#define xlate_dev_kmem_ptr(p)	p
+
+#endif /* _IO_H */
