commit 423c01eac31fe9e6c9eee7bf45ace9abcd57251b
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Mon Oct 29 16:15:43 2012 +1000

    m68k: fix unused variable warning in mempcy.c
    
    When compiling for original 68000 or ColdFire targets you will get the
    following warning when compiling arch/m68k/lib/memcpy.c:
    
      CC      arch/m68k/lib/memcpy.o
    arch/m68k/lib/memcpy.c: In function ‘__builtin_memcpy’:
    arch/m68k/lib/memcpy.c:13:15: warning: unused variable ‘temp1’
    
    This is easily fixed by moving the definition of temp1 into the code block
    where it is used.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/lib/memcpy.c b/arch/m68k/lib/memcpy.c
index 10ca051d56b8..c1e2dfb206f3 100644
--- a/arch/m68k/lib/memcpy.c
+++ b/arch/m68k/lib/memcpy.c
@@ -10,7 +10,7 @@
 void *memcpy(void *to, const void *from, size_t n)
 {
 	void *xto = to;
-	size_t temp, temp1;
+	size_t temp;
 
 	if (!n)
 		return xto;
@@ -47,6 +47,7 @@ void *memcpy(void *to, const void *from, size_t n)
 		for (; temp; temp--)
 			*lto++ = *lfrom++;
 #else
+		size_t temp1;
 		asm volatile (
 			"	movel %2,%3\n"
 			"	andw  #7,%3\n"

commit f230e80b423f6cb002015ab4771c06a53d5a2287
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Fri Aug 5 14:41:29 2011 +1000

    m68k: fix memcpy to unmatched/unaligned source and dest on 68000
    
    The original 68000 processors cannot copy 16bit or larger quantities from
    odd addresses. All newer members of the 68k family (including ColdFire)
    can do this.
    
    In the current memcpy implementation after trying to align the destination
    address to a 16bit boundary if we end up with an odd source address we go
    off and try to copy multi-byte quantities from it. This will trap on the
    68000.
    
    The only solution if we end with an odd source address is to byte wise
    copy the whole memcpy region. We only need to do this if we are supporting
    original 68000 processors.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/lib/memcpy.c b/arch/m68k/lib/memcpy.c
index 064889316974..10ca051d56b8 100644
--- a/arch/m68k/lib/memcpy.c
+++ b/arch/m68k/lib/memcpy.c
@@ -22,6 +22,15 @@ void *memcpy(void *to, const void *from, size_t n)
 		from = cfrom;
 		n--;
 	}
+#if defined(CONFIG_M68000)
+	if ((long)from & 1) {
+		char *cto = to;
+		const char *cfrom = from;
+		for (; n; n--)
+			*cto++ = *cfrom++;
+		return xto;
+	}
+#endif
 	if (n > 2 && (long)to & 2) {
 		short *sto = to;
 		const short *sfrom = from;

commit 734c3ce3bd4d51c932893b9f6d32b9ded31acdff
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Thu Jun 2 16:07:33 2011 +1000

    m68k: use kernel processor defines for conditional optimizations
    
    Older m68k-linux compilers will include pre-defined symbols that
    confuse what processor it is being targeted for. For example gcc-4.1.2
    will pre-define __mc68020__ even if you specify the target processor
    as -m68000 on the gcc command line. Newer versions of gcc have this
    corrected.
    
    In a few places the m68k code uses defined(__mc68020__) for optimizations
    that include instructions that are specific to the CPU 68020 and above.
    When compiling with older compilers this will be true even when we have
    selected to compile for the older 68000 processors.
    
    Switch to using the kernel processor defines, CONFIG_M68020 and friends.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/lib/memcpy.c b/arch/m68k/lib/memcpy.c
index 62182c81e91c..064889316974 100644
--- a/arch/m68k/lib/memcpy.c
+++ b/arch/m68k/lib/memcpy.c
@@ -34,8 +34,10 @@ void *memcpy(void *to, const void *from, size_t n)
 	if (temp) {
 		long *lto = to;
 		const long *lfrom = from;
-#if defined(__mc68020__) || defined(__mc68030__) || \
-    defined(__mc68040__) || defined(__mc68060__) || defined(__mcpu32__)
+#if defined(CONFIG_M68000) || defined(CONFIG_COLDFIRE)
+		for (; temp; temp--)
+			*lto++ = *lfrom++;
+#else
 		asm volatile (
 			"	movel %2,%3\n"
 			"	andw  #7,%3\n"
@@ -56,9 +58,6 @@ void *memcpy(void *to, const void *from, size_t n)
 			"	jpl   4b"
 			: "=a" (lfrom), "=a" (lto), "=d" (temp), "=&d" (temp1)
 			: "0" (lfrom), "1" (lto), "2" (temp));
-#else
-		for (; temp; temp--)
-			*lto++ = *lfrom++;
 #endif
 		to = lto;
 		from = lfrom;

commit 66d83ab32aec5d84d707d4d72717b9468ec33a96
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Mon Mar 28 16:53:37 2011 +1000

    m68k: remove duplicate memcpy() implementation
    
    Merging the mmu and non-mmu directories we ended up with duplicate
    implementations of memcpy(). One is a little more optimized for the
    >= 68020 case, but that can easily be inserted into a single
    implementation of memcpy(). Clean up the exporting of this symbol
    too, otherwise we end up exporting it twice on a no-mmu build.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/lib/memcpy.c b/arch/m68k/lib/memcpy.c
index b50dbcad4746..62182c81e91c 100644
--- a/arch/m68k/lib/memcpy.c
+++ b/arch/m68k/lib/memcpy.c
@@ -1,62 +1,80 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ */
 
-#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/string.h>
 
-void * memcpy(void * to, const void * from, size_t n)
+void *memcpy(void *to, const void *from, size_t n)
 {
-#ifdef CONFIG_COLDFIRE
-  void *xto = to;
-  size_t temp;
+	void *xto = to;
+	size_t temp, temp1;
 
-  if (!n)
-    return xto;
-  if ((long) to & 1)
-    {
-      char *cto = to;
-      const char *cfrom = from;
-      *cto++ = *cfrom++;
-      to = cto;
-      from = cfrom;
-      n--;
-    }
-  if (n > 2 && (long) to & 2)
-    {
-      short *sto = to;
-      const short *sfrom = from;
-      *sto++ = *sfrom++;
-      to = sto;
-      from = sfrom;
-      n -= 2;
-    }
-  temp = n >> 2;
-  if (temp)
-    {
-      long *lto = to;
-      const long *lfrom = from;
-      for (; temp; temp--)
-	*lto++ = *lfrom++;
-      to = lto;
-      from = lfrom;
-    }
-  if (n & 2)
-    {
-      short *sto = to;
-      const short *sfrom = from;
-      *sto++ = *sfrom++;
-      to = sto;
-      from = sfrom;
-    }
-  if (n & 1)
-    {
-      char *cto = to;
-      const char *cfrom = from;
-      *cto = *cfrom;
-    }
-  return xto;
+	if (!n)
+		return xto;
+	if ((long)to & 1) {
+		char *cto = to;
+		const char *cfrom = from;
+		*cto++ = *cfrom++;
+		to = cto;
+		from = cfrom;
+		n--;
+	}
+	if (n > 2 && (long)to & 2) {
+		short *sto = to;
+		const short *sfrom = from;
+		*sto++ = *sfrom++;
+		to = sto;
+		from = sfrom;
+		n -= 2;
+	}
+	temp = n >> 2;
+	if (temp) {
+		long *lto = to;
+		const long *lfrom = from;
+#if defined(__mc68020__) || defined(__mc68030__) || \
+    defined(__mc68040__) || defined(__mc68060__) || defined(__mcpu32__)
+		asm volatile (
+			"	movel %2,%3\n"
+			"	andw  #7,%3\n"
+			"	lsrl  #3,%2\n"
+			"	negw  %3\n"
+			"	jmp   %%pc@(1f,%3:w:2)\n"
+			"4:	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"	movel %0@+,%1@+\n"
+			"1:	dbra  %2,4b\n"
+			"	clrw  %2\n"
+			"	subql #1,%2\n"
+			"	jpl   4b"
+			: "=a" (lfrom), "=a" (lto), "=d" (temp), "=&d" (temp1)
+			: "0" (lfrom), "1" (lto), "2" (temp));
 #else
-  const char *c_from = from;
-  char *c_to = to;
-  while (n-- > 0)
-    *c_to++ = *c_from++;
-  return((void *) to);
+		for (; temp; temp--)
+			*lto++ = *lfrom++;
 #endif
+		to = lto;
+		from = lfrom;
+	}
+	if (n & 2) {
+		short *sto = to;
+		const short *sfrom = from;
+		*sto++ = *sfrom++;
+		to = sto;
+		from = sfrom;
+	}
+	if (n & 1) {
+		char *cto = to;
+		const char *cfrom = from;
+		*cto = *cfrom;
+	}
+	return xto;
 }
+EXPORT_SYMBOL(memcpy);

commit 66d857b08b8c3ed5c72c361f863cce77d2a978d7
Author: Greg Ungerer <gerg@uclinux.org>
Date:   Tue Mar 22 13:39:27 2011 +1000

    m68k: merge m68k and m68knommu arch directories
    
    There is a lot of common code that could be shared between the m68k
    and m68knommu arch branches. It makes sense to merge the two branches
    into a single directory structure so that we can more easily share
    that common code.
    
    This is a brute force merge, based on a script from Stephen King
    <sfking@fdwdc.com>, which was originally written by Arnd Bergmann
    <arnd@arndb.de>.
    
    > The script was inspired by the script Sam Ravnborg used to merge the
    > includes from m68knommu. For those files common to both arches but
    > differing in content, the m68k version of the file is renamed to
    > <file>_mm.<ext> and the m68knommu version of the file is moved into the
    > corresponding m68k directory and renamed <file>_no.<ext> and a small
    > wrapper file <file>.<ext> is used to select between the two version. Files
    > that are common to both but don't differ are removed from the m68knommu
    > tree and files and directories that are unique to the m68knommu tree are
    > moved to the m68k tree. Finally, the arch/m68knommu tree is removed.
    >
    > To select between the the versions of the files, the wrapper uses
    >
    > #ifdef CONFIG_MMU
    > #include <file>_mm.<ext>
    > #else
    > #include <file>_no.<ext>
    > #endif
    
    On top of this file merge I have done a simplistic merge of m68k and
    m68knommu Kconfig, which primarily attempts to keep existing options and
    menus in place. Other than a handful of options being moved it produces
    identical .config outputs on m68k and m68knommu targets I tested it on.
    
    With this in place there is now quite a bit of scope for merge cleanups
    in future patches.
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>

diff --git a/arch/m68k/lib/memcpy.c b/arch/m68k/lib/memcpy.c
new file mode 100644
index 000000000000..b50dbcad4746
--- /dev/null
+++ b/arch/m68k/lib/memcpy.c
@@ -0,0 +1,62 @@
+
+#include <linux/types.h>
+
+void * memcpy(void * to, const void * from, size_t n)
+{
+#ifdef CONFIG_COLDFIRE
+  void *xto = to;
+  size_t temp;
+
+  if (!n)
+    return xto;
+  if ((long) to & 1)
+    {
+      char *cto = to;
+      const char *cfrom = from;
+      *cto++ = *cfrom++;
+      to = cto;
+      from = cfrom;
+      n--;
+    }
+  if (n > 2 && (long) to & 2)
+    {
+      short *sto = to;
+      const short *sfrom = from;
+      *sto++ = *sfrom++;
+      to = sto;
+      from = sfrom;
+      n -= 2;
+    }
+  temp = n >> 2;
+  if (temp)
+    {
+      long *lto = to;
+      const long *lfrom = from;
+      for (; temp; temp--)
+	*lto++ = *lfrom++;
+      to = lto;
+      from = lfrom;
+    }
+  if (n & 2)
+    {
+      short *sto = to;
+      const short *sfrom = from;
+      *sto++ = *sfrom++;
+      to = sto;
+      from = sfrom;
+    }
+  if (n & 1)
+    {
+      char *cto = to;
+      const char *cfrom = from;
+      *cto = *cfrom;
+    }
+  return xto;
+#else
+  const char *c_from = from;
+  char *c_to = to;
+  while (n-- > 0)
+    *c_to++ = *c_from++;
+  return((void *) to);
+#endif
+}

commit 072dffda1d35c391fe893ec9b1d098145e668fef
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sat Sep 3 15:57:10 2005 -0700

    [PATCH] m68k: cleanup inline mem functions
    
    Use the builtin functions for memset/memclr/memcpy, special optimizations for
    page operations have dedicated functions now.  Uninline memmove/memchr and
    move all functions into a single file and clean it up a little.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/lib/memcpy.c b/arch/m68k/lib/memcpy.c
deleted file mode 100644
index 73e181823d9b..000000000000
--- a/arch/m68k/lib/memcpy.c
+++ /dev/null
@@ -1,75 +0,0 @@
-#include <linux/types.h>
-
-void * memcpy(void * to, const void * from, size_t n)
-{
-  void *xto = to;
-  size_t temp, temp1;
-
-  if (!n)
-    return xto;
-  if ((long) to & 1)
-    {
-      char *cto = to;
-      const char *cfrom = from;
-      *cto++ = *cfrom++;
-      to = cto;
-      from = cfrom;
-      n--;
-    }
-  if (n > 2 && (long) to & 2)
-    {
-      short *sto = to;
-      const short *sfrom = from;
-      *sto++ = *sfrom++;
-      to = sto;
-      from = sfrom;
-      n -= 2;
-    }
-  temp = n >> 2;
-  if (temp)
-    {
-      long *lto = to;
-      const long *lfrom = from;
-
-      __asm__ __volatile__("movel %2,%3\n\t"
-			   "andw  #7,%3\n\t"
-			   "lsrl  #3,%2\n\t"
-			   "negw  %3\n\t"
-			   "jmp   %%pc@(1f,%3:w:2)\n\t"
-			   "4:\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "movel %0@+,%1@+\n\t"
-			   "1:\t"
-			   "dbra  %2,4b\n\t"
-			   "clrw  %2\n\t"
-			   "subql #1,%2\n\t"
-			   "jpl   4b\n\t"
-			   : "=a" (lfrom), "=a" (lto), "=d" (temp),
-			   "=&d" (temp1)
-			   : "0" (lfrom), "1" (lto), "2" (temp)
-			   );
-      to = lto;
-      from = lfrom;
-    }
-  if (n & 2)
-    {
-      short *sto = to;
-      const short *sfrom = from;
-      *sto++ = *sfrom++;
-      to = sto;
-      from = sfrom;
-    }
-  if (n & 1)
-    {
-      char *cto = to;
-      const char *cfrom = from;
-      *cto = *cfrom;
-    }
-  return xto;
-}

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/lib/memcpy.c b/arch/m68k/lib/memcpy.c
new file mode 100644
index 000000000000..73e181823d9b
--- /dev/null
+++ b/arch/m68k/lib/memcpy.c
@@ -0,0 +1,75 @@
+#include <linux/types.h>
+
+void * memcpy(void * to, const void * from, size_t n)
+{
+  void *xto = to;
+  size_t temp, temp1;
+
+  if (!n)
+    return xto;
+  if ((long) to & 1)
+    {
+      char *cto = to;
+      const char *cfrom = from;
+      *cto++ = *cfrom++;
+      to = cto;
+      from = cfrom;
+      n--;
+    }
+  if (n > 2 && (long) to & 2)
+    {
+      short *sto = to;
+      const short *sfrom = from;
+      *sto++ = *sfrom++;
+      to = sto;
+      from = sfrom;
+      n -= 2;
+    }
+  temp = n >> 2;
+  if (temp)
+    {
+      long *lto = to;
+      const long *lfrom = from;
+
+      __asm__ __volatile__("movel %2,%3\n\t"
+			   "andw  #7,%3\n\t"
+			   "lsrl  #3,%2\n\t"
+			   "negw  %3\n\t"
+			   "jmp   %%pc@(1f,%3:w:2)\n\t"
+			   "4:\t"
+			   "movel %0@+,%1@+\n\t"
+			   "movel %0@+,%1@+\n\t"
+			   "movel %0@+,%1@+\n\t"
+			   "movel %0@+,%1@+\n\t"
+			   "movel %0@+,%1@+\n\t"
+			   "movel %0@+,%1@+\n\t"
+			   "movel %0@+,%1@+\n\t"
+			   "movel %0@+,%1@+\n\t"
+			   "1:\t"
+			   "dbra  %2,4b\n\t"
+			   "clrw  %2\n\t"
+			   "subql #1,%2\n\t"
+			   "jpl   4b\n\t"
+			   : "=a" (lfrom), "=a" (lto), "=d" (temp),
+			   "=&d" (temp1)
+			   : "0" (lfrom), "1" (lto), "2" (temp)
+			   );
+      to = lto;
+      from = lfrom;
+    }
+  if (n & 2)
+    {
+      short *sto = to;
+      const short *sfrom = from;
+      *sto++ = *sfrom++;
+      to = sto;
+      from = sfrom;
+    }
+  if (n & 1)
+    {
+      char *cto = to;
+      const char *cfrom = from;
+      *cto = *cfrom;
+    }
+  return xto;
+}
