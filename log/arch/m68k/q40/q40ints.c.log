commit 1efdd4bd254311498123a15fa0acd565f454da97
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 1 11:53:10 2018 +1100

    m68k: Call timer_interrupt() with interrupts disabled
    
    Some platforms execute their timer handler with the interrupt priority
    level set below 6. That means the handler could be interrupted by another
    driver and this could lead to re-entry of the timer core.
    
    Avoid this by use of local_irq_save/restore for timer interrupt dispatch.
    This provides mutual exclusion around the timer interrupt flag access
    which is needed later in this series for the clocksource conversion.
    
    Reported-by: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/alpine.DEB.2.21.1811131407120.2697@nanos.tec.linutronix.de
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index 3e7603202977..1c696906c159 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -127,10 +127,10 @@ void q40_mksound(unsigned int hz, unsigned int ticks)
 	sound_ticks = ticks << 1;
 }
 
-static irq_handler_t q40_timer_routine;
-
-static irqreturn_t q40_timer_int (int irq, void * dev)
+static irqreturn_t q40_timer_int(int irq, void *dev_id)
 {
+	irq_handler_t timer_routine = dev_id;
+
 	ql_ticks = ql_ticks ? 0 : 1;
 	if (sound_ticks) {
 		unsigned char sval=(sound_ticks & 1) ? 128-SVOL : 128+SVOL;
@@ -139,8 +139,13 @@ static irqreturn_t q40_timer_int (int irq, void * dev)
 		*DAC_RIGHT=sval;
 	}
 
-	if (!ql_ticks)
-		q40_timer_routine(irq, dev);
+	if (!ql_ticks) {
+		unsigned long flags;
+
+		local_irq_save(flags);
+		timer_routine(0, NULL);
+		local_irq_restore(flags);
+	}
 	return IRQ_HANDLED;
 }
 
@@ -148,11 +153,9 @@ void q40_sched_init (irq_handler_t timer_routine)
 {
 	int timer_irq;
 
-	q40_timer_routine = timer_routine;
 	timer_irq = Q40_IRQ_FRAME;
 
-	if (request_irq(timer_irq, q40_timer_int, 0,
-				"timer", q40_timer_int))
+	if (request_irq(timer_irq, q40_timer_int, 0, "timer", timer_routine))
 		panic("Couldn't register timer int");
 
 	master_outb(-1, FRAME_CLEAR_REG);

commit 446926f9490342532ff44983cb187c01051174a9
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Tue Dec 6 17:11:01 2016 +0100

    m68k/q40: Modernize printing of kernel messages
    
      - Convert from printk() to pr_*(),
      - Use TABs for indentation while at it.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index 513f9bb17b9c..3e7603202977 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -48,7 +48,8 @@ static unsigned int q40_irq_startup(struct irq_data *data)
 	switch (irq) {
 	case 1: case 2: case 8: case 9:
 	case 11: case 12: case 13:
-		printk("%s: ISA IRQ %d not implemented by HW\n", __func__, irq);
+		pr_warn("%s: ISA IRQ %d not implemented by HW\n", __func__,
+			irq);
 		/* FIXME return -ENXIO; */
 	}
 	return 0;
@@ -250,7 +251,7 @@ static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
 					disable_irq(irq);
 					disabled = 1;
 #else
-					/*printk("IRQ_INPROGRESS detected for irq %d, disabling - %s disabled\n",
+					/*pr_warn("IRQ_INPROGRESS detected for irq %d, disabling - %s disabled\n",
 						irq, disabled ? "already" : "not yet"); */
 					fp->sr = (((fp->sr) & (~0x700))+0x200);
 					disabled = 1;
@@ -273,7 +274,7 @@ static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
 					}
 #else
 					disabled = 0;
-					/*printk("reenabling irq %d\n", irq); */
+					/*pr_info("reenabling irq %d\n", irq); */
 #endif
 				}
 // used to do 'goto repeat;' here, this delayed bh processing too long
@@ -281,7 +282,8 @@ static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
 			}
 		}
 		if (mer && ccleirq > 0 && !aliased_irq) {
-			printk("ISA interrupt from unknown source? EIRQ_REG = %x\n",mer);
+			pr_warn("ISA interrupt from unknown source? EIRQ_REG = %x\n",
+				mer);
 			ccleirq--;
 		}
 	}
@@ -301,7 +303,7 @@ void q40_irq_enable(struct irq_data *data)
 	if (irq >= 5 && irq <= 15) {
 		mext_disabled--;
 		if (mext_disabled > 0)
-			printk("q40_irq_enable : nested disable/enable\n");
+			pr_warn("q40_irq_enable : nested disable/enable\n");
 		if (mext_disabled == 0)
 			master_outb(1, EXT_ENABLE_REG);
 	}
@@ -321,6 +323,7 @@ void q40_irq_disable(struct irq_data *data)
 		master_outb(0, EXT_ENABLE_REG);
 		mext_disabled++;
 		if (mext_disabled > 1)
-			printk("disable_irq nesting count %d\n",mext_disabled);
+			pr_info("disable_irq nesting count %d\n",
+				mext_disabled);
 	}
 }

commit 803f69144f0d48863c68f9d111b56849c7cef5bb
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for M68K
    
    Disintegrate asm/system.h for M68K.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    cc: linux-m68k@lists.linux-m68k.org

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index 2b888491f29a..513f9bb17b9c 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -18,7 +18,6 @@
 #include <linux/irq.h>
 
 #include <asm/ptrace.h>
-#include <asm/system.h>
 #include <asm/traps.h>
 
 #include <asm/q40_master.h>

commit d890d73995257b4e10cdd7d55bad80e34a71ba22
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 11 11:28:04 2011 +0200

    m68k/irq: Remove obsolete m68k irq framework
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index f1e5288f043f..2b888491f29a 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -15,11 +15,7 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/interrupt.h>
-#ifdef CONFIG_GENERIC_HARDIRQS
 #include <linux/irq.h>
-#else
-#include <asm/irq.h>
-#endif
 
 #include <asm/ptrace.h>
 #include <asm/system.h>
@@ -329,15 +325,3 @@ void q40_irq_disable(struct irq_data *data)
 			printk("disable_irq nesting count %d\n",mext_disabled);
 	}
 }
-
-#ifndef CONFIG_GENERIC_HARDIRQS
-unsigned long q40_probe_irq_on(void)
-{
-	printk("irq probing not working - reconfigure the driver to avoid this\n");
-	return -1;
-}
-int q40_probe_irq_off(unsigned long irqs)
-{
-	return -1;
-}
-#endif

commit a03010ed9b399fdbc28ac8836e0a6d4b15403f9f
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Thu Aug 18 14:47:16 2011 +0200

    m68k/q40: Convert Q40/Q60 to genirq
    
    q40_irq_handler() must be kept to translate ISA IRQs to the range 1-15.
    q40_probe_irq_o{ff,n}() become unused.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Richard Zidlicky <rz@linux-m68k.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index afe600c03659..f1e5288f043f 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -15,10 +15,14 @@
 #include <linux/kernel.h>
 #include <linux/errno.h>
 #include <linux/interrupt.h>
+#ifdef CONFIG_GENERIC_HARDIRQS
+#include <linux/irq.h>
+#else
+#include <asm/irq.h>
+#endif
 
 #include <asm/ptrace.h>
 #include <asm/system.h>
-#include <asm/irq.h>
 #include <asm/traps.h>
 
 #include <asm/q40_master.h>
@@ -326,6 +330,7 @@ void q40_irq_disable(struct irq_data *data)
 	}
 }
 
+#ifndef CONFIG_GENERIC_HARDIRQS
 unsigned long q40_probe_irq_on(void)
 {
 	printk("irq probing not working - reconfigure the driver to avoid this\n");
@@ -335,3 +340,4 @@ int q40_probe_irq_off(unsigned long irqs)
 {
 	return -1;
 }
+#endif

commit 1425df87c25b15400c9f26d57821bcfe01286b2a
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Fri Jul 1 20:39:19 2011 +0200

    m68k/irq: Rename {,__}m68k_handle_int()
    
      - Rename m68k_handle_int() to generic_handle_irq(), and drop the unneeded
        asmlinkage,
      - Rename __m68k_handle_int() to do_IRQ().
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index a8a5ce8b18fc..afe600c03659 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -220,11 +220,11 @@ static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
 	switch (irq) {
 	case 4:
 	case 6:
-		__m68k_handle_int(Q40_IRQ_SAMPLE, fp);
+		do_IRQ(Q40_IRQ_SAMPLE, fp);
 		return;
 	}
 	if (mir & Q40_IRQ_FRAME_MASK) {
-		__m68k_handle_int(Q40_IRQ_FRAME, fp);
+		do_IRQ(Q40_IRQ_FRAME, fp);
 		master_outb(-1, FRAME_CLEAR_REG);
 	}
 	if ((mir & Q40_IRQ_SER_MASK) || (mir & Q40_IRQ_EXT_MASK)) {
@@ -259,7 +259,7 @@ static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
 					goto iirq;
 				}
 				q40_state[irq] |= IRQ_INPROGRESS;
-				__m68k_handle_int(irq, fp);
+				do_IRQ(irq, fp);
 				q40_state[irq] &= ~IRQ_INPROGRESS;
 
 				/* naively enable everything, if that fails than    */
@@ -290,7 +290,7 @@ static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
 	mir = master_inb(IIRQ_REG);
 	/* should test whether keyboard irq is really enabled, doing it in defhand */
 	if (mir & Q40_IRQ_KEYB_MASK)
-		__m68k_handle_int(Q40_IRQ_KEYBOARD, fp);
+		do_IRQ(Q40_IRQ_KEYBOARD, fp);
 
 	return;
 }

commit edb347256c44366888debb4f9e8477ac700a9026
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Jun 1 11:15:21 2011 +0200

    m68k/irq: Add m68k_setup_irq_controller()
    
    This is a wrapper around m68k_setup_irq_chip() that discards its dummy
    second parameter, to ease the future transition to genirq.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index cb245f972e1a..a8a5ce8b18fc 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -82,7 +82,8 @@ static int disabled;
 
 void __init q40_init_IRQ(void)
 {
-	m68k_setup_irq_chip(&q40_irq_chip, 1, Q40_IRQ_MAX);
+	m68k_setup_irq_controller(&q40_irq_chip, handle_simple_irq, 1,
+				  Q40_IRQ_MAX);
 
 	/* setup handler for ISA ints */
 	m68k_setup_auto_interrupt(q40_irq_handler);

commit e8abf5e73cdb6c034d35ccba1f63a4801cd3dec5
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Apr 17 22:53:04 2011 +0200

    m68k/irq: Switch irq_chip methods to "struct irq_data *data"
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index fa05a03f8dfe..cb245f972e1a 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -35,14 +35,16 @@
 */
 
 static void q40_irq_handler(unsigned int, struct pt_regs *fp);
-static void q40_enable_irq(unsigned int);
-static void q40_disable_irq(unsigned int);
+static void q40_irq_enable(struct irq_data *data);
+static void q40_irq_disable(struct irq_data *data);
 
 unsigned short q40_ablecount[35];
 unsigned short q40_state[35];
 
-static unsigned int q40_irq_startup(unsigned int irq)
+static unsigned int q40_irq_startup(struct irq_data *data)
 {
+	unsigned int irq = data->irq;
+
 	/* test for ISA ints not implemented by HW */
 	switch (irq) {
 	case 1: case 2: case 8: case 9:
@@ -53,7 +55,7 @@ static unsigned int q40_irq_startup(unsigned int irq)
 	return 0;
 }
 
-static void q40_irq_shutdown(unsigned int irq)
+static void q40_irq_shutdown(struct irq_data *data)
 {
 }
 
@@ -61,8 +63,8 @@ static struct irq_chip q40_irq_chip = {
 	.name		= "q40",
 	.irq_startup	= q40_irq_startup,
 	.irq_shutdown	= q40_irq_shutdown,
-	.irq_enable	= q40_enable_irq,
-	.irq_disable	= q40_disable_irq,
+	.irq_enable	= q40_irq_enable,
+	.irq_disable	= q40_irq_disable,
 };
 
 /*
@@ -85,8 +87,8 @@ void __init q40_init_IRQ(void)
 	/* setup handler for ISA ints */
 	m68k_setup_auto_interrupt(q40_irq_handler);
 
-	m68k_irq_startup(IRQ_AUTO_2);
-	m68k_irq_startup(IRQ_AUTO_4);
+	m68k_irq_startup_irq(IRQ_AUTO_2);
+	m68k_irq_startup_irq(IRQ_AUTO_4);
 
 	/* now enable some ints.. */
 	master_outb(1, EXT_ENABLE_REG);  /* ISA IRQ 5-15 */
@@ -292,20 +294,24 @@ static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
 	return;
 }
 
-void q40_enable_irq(unsigned int irq)
+void q40_irq_enable(struct irq_data *data)
 {
+	unsigned int irq = data->irq;
+
 	if (irq >= 5 && irq <= 15) {
 		mext_disabled--;
 		if (mext_disabled > 0)
-			printk("q40_enable_irq : nested disable/enable\n");
+			printk("q40_irq_enable : nested disable/enable\n");
 		if (mext_disabled == 0)
 			master_outb(1, EXT_ENABLE_REG);
 	}
 }
 
 
-void q40_disable_irq(unsigned int irq)
+void q40_irq_disable(struct irq_data *data)
 {
+	unsigned int irq = data->irq;
+
 	/* disable ISA iqs : only do something if the driver has been
 	 * verified to be Q40 "compatible" - right now IDE, NE2K
 	 * Any driver should not attempt to sleep across disable_irq !!

commit c288bf2533e57174b90b07860c4391bcd1ea269c
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Apr 13 22:31:28 2011 +0200

    m68k/irq: Rename irq_controller to irq_chip
    
    Make it more similar to the genirq version:
      - Remove lock (unused as we don't do SMP anyway),
      - Prepend methods with irq_,
      - Make irq_startup() return unsigned int.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index 9f0e3d59bf92..fa05a03f8dfe 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -41,14 +41,14 @@ static void q40_disable_irq(unsigned int);
 unsigned short q40_ablecount[35];
 unsigned short q40_state[35];
 
-static int q40_irq_startup(unsigned int irq)
+static unsigned int q40_irq_startup(unsigned int irq)
 {
 	/* test for ISA ints not implemented by HW */
 	switch (irq) {
 	case 1: case 2: case 8: case 9:
 	case 11: case 12: case 13:
 		printk("%s: ISA IRQ %d not implemented by HW\n", __func__, irq);
-		return -ENXIO;
+		/* FIXME return -ENXIO; */
 	}
 	return 0;
 }
@@ -57,13 +57,12 @@ static void q40_irq_shutdown(unsigned int irq)
 {
 }
 
-static struct irq_controller q40_irq_controller = {
+static struct irq_chip q40_irq_chip = {
 	.name		= "q40",
-	.lock		= __SPIN_LOCK_UNLOCKED(q40_irq_controller.lock),
-	.startup	= q40_irq_startup,
-	.shutdown	= q40_irq_shutdown,
-	.enable		= q40_enable_irq,
-	.disable	= q40_disable_irq,
+	.irq_startup	= q40_irq_startup,
+	.irq_shutdown	= q40_irq_shutdown,
+	.irq_enable	= q40_enable_irq,
+	.irq_disable	= q40_disable_irq,
 };
 
 /*
@@ -81,7 +80,7 @@ static int disabled;
 
 void __init q40_init_IRQ(void)
 {
-	m68k_setup_irq_controller(&q40_irq_controller, 1, Q40_IRQ_MAX);
+	m68k_setup_irq_chip(&q40_irq_chip, 1, Q40_IRQ_MAX);
 
 	/* setup handler for ISA ints */
 	m68k_setup_auto_interrupt(q40_irq_handler);

commit f85e7cdc3fd0db65ef1442476b82ced0f01c5c19
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Apr 28 02:13:49 2008 -0700

    m68k: replace remaining __FUNCTION__ occurrences
    
    __FUNCTION__ is gcc-specific, use __func__
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index 46161cef08b9..9f0e3d59bf92 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -47,7 +47,7 @@ static int q40_irq_startup(unsigned int irq)
 	switch (irq) {
 	case 1: case 2: case 8: case 9:
 	case 11: case 12: case 13:
-		printk("%s: ISA IRQ %d not implemented by HW\n", __FUNCTION__, irq);
+		printk("%s: ISA IRQ %d not implemented by HW\n", __func__, irq);
 		return -ENXIO;
 	}
 	return 0;

commit 0c79cf6af16c4a4c9ef539b52387de07f5ed62f5
Author: Simon Arlott <simon@fire.lp0.eu>
Date:   Sat Oct 20 01:20:32 2007 +0200

    spelling fixes: arch/m68k/
    
    Spelling fixes in arch/m68k/.
    
    Signed-off-by: Simon Arlott <simon@fire.lp0.eu>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index ad3ed1fb8879..46161cef08b9 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -184,7 +184,7 @@ static struct IRQ_TABLE eirqs[] = {
 };
 
 /* complain only this many times about spurious ints : */
-static int ccleirq=60;    /* ISA dev IRQ's*/
+static int ccleirq=60;    /* ISA dev IRQs*/
 /*static int cclirq=60;*/     /* internal */
 
 /* FIXME: add shared ints,mask,unmask,probing.... */
@@ -234,7 +234,7 @@ static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
  * There is a little mess wrt which IRQ really caused this irq request. The
  * main problem is that IIRQ_REG and EIRQ_REG reflect the state when they
  * are read - which is long after the request came in. In theory IRQs should
- * not just go away but they occassionally do
+ * not just go away but they occasionally do
  */
 				if (irq > 4 && irq <= 15 && mext_disabled) {
 					/*aliased_irq++;*/

commit 66a3f820cb6a88ef0481e042d4b48b2299deab7e
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Jul 20 04:33:28 2007 +0100

    m68k: missing __init
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index 2fb25ae46a8a..ad3ed1fb8879 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -79,7 +79,7 @@ static struct irq_controller q40_irq_controller = {
 
 static int disabled;
 
-void q40_init_IRQ(void)
+void __init q40_init_IRQ(void)
 {
 	m68k_setup_irq_controller(&q40_irq_controller, 1, Q40_IRQ_MAX);
 

commit 241258d1cc4d3551608364cd678d5a85239ad481
Author: Milind Arun Choudhary <milindchoudhary@gmail.com>
Date:   Sun May 6 14:50:54 2007 -0700

    SPIN_LOCK_UNLOCKED cleanup in arch/m68k
    
    SPIN_LOCK_UNLOCKED cleanup,use __SPIN_LOCK_UNLOCKED instead
    
    Signed-off-by: Milind Arun Choudhary <milindchoudhary@gmail.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index 31cc07d8cec4..2fb25ae46a8a 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -59,7 +59,7 @@ static void q40_irq_shutdown(unsigned int irq)
 
 static struct irq_controller q40_irq_controller = {
 	.name		= "q40",
-	.lock		= SPIN_LOCK_UNLOCKED,
+	.lock		= __SPIN_LOCK_UNLOCKED(q40_irq_controller.lock),
 	.startup	= q40_irq_startup,
 	.shutdown	= q40_irq_shutdown,
 	.enable		= q40_enable_irq,

commit 40220c1a192f51695f806d75b1f9970f0f17a6e8
Author: David Howells <dhowells@redhat.com>
Date:   Mon Oct 9 12:19:47 2006 +0100

    IRQ: Use the new typedef for interrupt handler function pointers
    
    Use the new typedef for interrupt handler function pointers rather than
    actually spelling out the full thing each time.  This was scripted with the
    following small shell script:
    
    #!/bin/sh
    egrep -nHrl -e 'irqreturn_t[    ]*[(][*]' $* |
    while read i
    do
        echo $i
        perl -pi -e 's/irqreturn_t\s*[(]\s*[*]\s*([_a-zA-Z0-9]*)\s*[)]\s*[(]\s*int\s*,\s*void\s*[*]\s*[)]/irq_handler_t \1/g' $i || exit $?
    done
    
    Signed-Off-By: David Howells <dhowells@redhat.com>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index 4a4ee4dfa6f1..31cc07d8cec4 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -125,7 +125,7 @@ void q40_mksound(unsigned int hz, unsigned int ticks)
 	sound_ticks = ticks << 1;
 }
 
-static irqreturn_t (*q40_timer_routine)(int, void *);
+static irq_handler_t q40_timer_routine;
 
 static irqreturn_t q40_timer_int (int irq, void * dev)
 {
@@ -142,7 +142,7 @@ static irqreturn_t q40_timer_int (int irq, void * dev)
 	return IRQ_HANDLED;
 }
 
-void q40_sched_init (irqreturn_t (*timer_routine)(int, void *))
+void q40_sched_init (irq_handler_t timer_routine)
 {
 	int timer_irq;
 

commit 2850bc273776cbb1b510c5828e9e456dffb50a32
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Sat Oct 7 14:16:45 2006 +0100

    [PATCH] m68k pt_regs fixes
    
    m68k_handle_int() split in two functions: __m68k_handle_int() takes
    pt_regs * and does set_irq_regs(); m68k_handle_int() doesn't get pt_regs
    *.
    
    Places where we used to call m68k_handle_int() recursively with the same
    pt_regs have simply lost the second argument, the rest is switched to
    __m68k_handle_int().
    
    The rest of patch is just dropping pt_regs * where needed.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index 472f41c4158b..4a4ee4dfa6f1 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -125,9 +125,9 @@ void q40_mksound(unsigned int hz, unsigned int ticks)
 	sound_ticks = ticks << 1;
 }
 
-static irqreturn_t (*q40_timer_routine)(int, void *, struct pt_regs *);
+static irqreturn_t (*q40_timer_routine)(int, void *);
 
-static irqreturn_t q40_timer_int (int irq, void * dev, struct pt_regs * regs)
+static irqreturn_t q40_timer_int (int irq, void * dev)
 {
 	ql_ticks = ql_ticks ? 0 : 1;
 	if (sound_ticks) {
@@ -138,11 +138,11 @@ static irqreturn_t q40_timer_int (int irq, void * dev, struct pt_regs * regs)
 	}
 
 	if (!ql_ticks)
-		q40_timer_routine(irq, dev, regs);
+		q40_timer_routine(irq, dev);
 	return IRQ_HANDLED;
 }
 
-void q40_sched_init (irqreturn_t (*timer_routine)(int, void *, struct pt_regs *))
+void q40_sched_init (irqreturn_t (*timer_routine)(int, void *))
 {
 	int timer_irq;
 
@@ -218,11 +218,11 @@ static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
 	switch (irq) {
 	case 4:
 	case 6:
-		m68k_handle_int(Q40_IRQ_SAMPLE, fp);
+		__m68k_handle_int(Q40_IRQ_SAMPLE, fp);
 		return;
 	}
 	if (mir & Q40_IRQ_FRAME_MASK) {
-		m68k_handle_int(Q40_IRQ_FRAME, fp);
+		__m68k_handle_int(Q40_IRQ_FRAME, fp);
 		master_outb(-1, FRAME_CLEAR_REG);
 	}
 	if ((mir & Q40_IRQ_SER_MASK) || (mir & Q40_IRQ_EXT_MASK)) {
@@ -257,7 +257,7 @@ static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
 					goto iirq;
 				}
 				q40_state[irq] |= IRQ_INPROGRESS;
-				m68k_handle_int(irq, fp);
+				__m68k_handle_int(irq, fp);
 				q40_state[irq] &= ~IRQ_INPROGRESS;
 
 				/* naively enable everything, if that fails than    */
@@ -288,7 +288,7 @@ static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
 	mir = master_inb(IIRQ_REG);
 	/* should test whether keyboard irq is really enabled, doing it in defhand */
 	if (mir & Q40_IRQ_KEYB_MASK)
-		m68k_handle_int(Q40_IRQ_KEYBOARD, fp);
+		__m68k_handle_int(Q40_IRQ_KEYBOARD, fp);
 
 	return;
 }

commit 77dda339e512c729bb27abd452e6632465490986
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:05 2006 -0700

    [PATCH] m68k: convert q40 irq code
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index ff80cba110d4..472f41c4158b 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -14,13 +14,8 @@
 #include <linux/types.h>
 #include <linux/kernel.h>
 #include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/sched.h>
-#include <linux/seq_file.h>
 #include <linux/interrupt.h>
-#include <linux/hardirq.h>
 
-#include <asm/rtc.h>
 #include <asm/ptrace.h>
 #include <asm/system.h>
 #include <asm/irq.h>
@@ -39,28 +34,37 @@
  *
 */
 
-extern int ints_inited;
+static void q40_irq_handler(unsigned int, struct pt_regs *fp);
+static void q40_enable_irq(unsigned int);
+static void q40_disable_irq(unsigned int);
 
+unsigned short q40_ablecount[35];
+unsigned short q40_state[35];
 
-irqreturn_t q40_irq2_handler (int, void *, struct pt_regs *fp);
-
-
-static irqreturn_t q40_defhand (int irq, void *dev_id, struct pt_regs *fp);
-
-
-#define DEVNAME_SIZE 24
+static int q40_irq_startup(unsigned int irq)
+{
+	/* test for ISA ints not implemented by HW */
+	switch (irq) {
+	case 1: case 2: case 8: case 9:
+	case 11: case 12: case 13:
+		printk("%s: ISA IRQ %d not implemented by HW\n", __FUNCTION__, irq);
+		return -ENXIO;
+	}
+	return 0;
+}
 
-static struct q40_irq_node {
-	irqreturn_t	(*handler)(int, void *, struct pt_regs *);
-	unsigned long	flags;
-	void		*dev_id;
-  /*        struct q40_irq_node *next;*/
-        char	        devname[DEVNAME_SIZE];
-	unsigned	count;
-        unsigned short  state;
-} irq_tab[Q40_IRQ_MAX+1];
+static void q40_irq_shutdown(unsigned int irq)
+{
+}
 
-short unsigned q40_ablecount[Q40_IRQ_MAX+1];
+static struct irq_controller q40_irq_controller = {
+	.name		= "q40",
+	.lock		= SPIN_LOCK_UNLOCKED,
+	.startup	= q40_irq_startup,
+	.shutdown	= q40_irq_shutdown,
+	.enable		= q40_enable_irq,
+	.disable	= q40_disable_irq,
+};
 
 /*
  * void q40_init_IRQ (void)
@@ -73,139 +77,29 @@ short unsigned q40_ablecount[Q40_IRQ_MAX+1];
  * the q40 IRQ handling routines.
  */
 
-static int disabled=0;
+static int disabled;
 
-void q40_init_IRQ (void)
+void q40_init_IRQ(void)
 {
-	int i;
-
-	disabled=0;
-	for (i = 0; i <= Q40_IRQ_MAX; i++) {
-		irq_tab[i].handler = q40_defhand;
-		irq_tab[i].flags = 0;
-		irq_tab[i].dev_id = NULL;
-		/*		irq_tab[i].next = NULL;*/
-		irq_tab[i].devname[0] = 0;
-		irq_tab[i].count = 0;
-		irq_tab[i].state =0;
-		q40_ablecount[i]=0;   /* all enabled */
-	}
+	m68k_setup_irq_controller(&q40_irq_controller, 1, Q40_IRQ_MAX);
 
 	/* setup handler for ISA ints */
-	cpu_request_irq(IRQ_AUTO_2, q40_irq2_handler, 0,
-			"q40 ISA and master chip", NULL);
+	m68k_setup_auto_interrupt(q40_irq_handler);
+
+	m68k_irq_startup(IRQ_AUTO_2);
+	m68k_irq_startup(IRQ_AUTO_4);
 
 	/* now enable some ints.. */
-	master_outb(1,EXT_ENABLE_REG);  /* ISA IRQ 5-15 */
+	master_outb(1, EXT_ENABLE_REG);  /* ISA IRQ 5-15 */
 
 	/* make sure keyboard IRQ is disabled */
-	master_outb(0,KEY_IRQ_ENABLE_REG);
+	master_outb(0, KEY_IRQ_ENABLE_REG);
 }
 
-int q40_request_irq(unsigned int irq,
-		irqreturn_t (*handler)(int, void *, struct pt_regs *),
-                unsigned long flags, const char *devname, void *dev_id)
-{
-  /*printk("q40_request_irq %d, %s\n",irq,devname);*/
-
-	if (irq > Q40_IRQ_MAX || (irq>15 && irq<32)) {
-		printk("%s: Incorrect IRQ %d from %s\n", __FUNCTION__, irq, devname);
-		return -ENXIO;
-	}
-
-	/* test for ISA ints not implemented by HW */
-	switch (irq)
-	  {
-	  case 1: case 2: case 8: case 9:
-	  case 12: case 13:
-	    printk("%s: ISA IRQ %d from %s not implemented by HW\n", __FUNCTION__, irq, devname);
-	    return -ENXIO;
-	  case 11:
-	    printk("warning IRQ 10 and 11 not distinguishable\n");
-	    irq=10;
-	  default:
-	    ;
-	  }
-
-	if (irq<Q40_IRQ_SAMPLE)
-	  {
-	    if (irq_tab[irq].dev_id != NULL)
-		  {
-		    printk("%s: IRQ %d from %s is not replaceable\n",
-			   __FUNCTION__, irq, irq_tab[irq].devname);
-		    return -EBUSY;
-		  }
-	    /*printk("IRQ %d set to handler %p\n",irq,handler);*/
-	    if (dev_id==NULL)
-		  {
-		printk("WARNING: dev_id == NULL in request_irq\n");
-		dev_id=(void*)1;
-	      }
-	    irq_tab[irq].handler = handler;
-	    irq_tab[irq].flags   = flags;
-	    irq_tab[irq].dev_id  = dev_id;
-	    strlcpy(irq_tab[irq].devname,devname,sizeof(irq_tab[irq].devname));
-	    irq_tab[irq].state = 0;
-	    return 0;
-	  }
-	else {
-	  /* Q40_IRQ_SAMPLE :somewhat special actions required here ..*/
-	  cpu_request_irq(4, handler, flags, devname, dev_id);
-	  cpu_request_irq(6, handler, flags, devname, dev_id);
-	  return 0;
-	}
-}
-
-void q40_free_irq(unsigned int irq, void *dev_id)
-{
-	if (irq > Q40_IRQ_MAX || (irq>15 && irq<32)) {
-		printk("%s: Incorrect IRQ %d, dev_id %x \n", __FUNCTION__, irq, (unsigned)dev_id);
-		return;
-	}
-
-	/* test for ISA ints not implemented by HW */
-	switch (irq)
-	  {
-	  case 1: case 2: case 8: case 9:
-	  case 12: case 13:
-	    printk("%s: ISA IRQ %d from %x invalid\n", __FUNCTION__, irq, (unsigned)dev_id);
-	    return;
-	  case 11: irq=10;
-	  default:
-	    ;
-	  }
-
-	if (irq<Q40_IRQ_SAMPLE)
-	  {
-	    if (irq_tab[irq].dev_id != dev_id)
-	      printk("%s: Removing probably wrong IRQ %d from %s\n",
-		     __FUNCTION__, irq, irq_tab[irq].devname);
-
-	    irq_tab[irq].handler = q40_defhand;
-	    irq_tab[irq].flags   = 0;
-	    irq_tab[irq].dev_id  = NULL;
-	    /* irq_tab[irq].devname = NULL; */
-	    /* do not reset state !! */
-	  }
-	else
-	  { /* == Q40_IRQ_SAMPLE */
-	    cpu_free_irq(4, dev_id);
-	    cpu_free_irq(6, dev_id);
-	  }
-}
-
-
-irqreturn_t q40_process_int (int level, struct pt_regs *fp)
-{
-  printk("unexpected interrupt vec=%x, pc=%lx, d0=%lx, d0_orig=%lx, d1=%lx, d2=%lx\n",
-          level, fp->pc, fp->d0, fp->orig_d0, fp->d1, fp->d2);
-  printk("\tIIRQ_REG = %x, EIRQ_REG = %x\n",master_inb(IIRQ_REG),master_inb(EIRQ_REG));
-  return IRQ_HANDLED;
-}
 
 /*
  * this stuff doesn't really belong here..
-*/
+ */
 
 int ql_ticks;              /* 200Hz ticks since last jiffie */
 static int sound_ticks;
@@ -214,54 +108,53 @@ static int sound_ticks;
 
 void q40_mksound(unsigned int hz, unsigned int ticks)
 {
-  /* for now ignore hz, except that hz==0 switches off sound */
-  /* simply alternate the ampl (128-SVOL)-(128+SVOL)-..-.. at 200Hz */
-  if (hz==0)
-    {
-      if (sound_ticks)
-	sound_ticks=1;
-
-      *DAC_LEFT=128;
-      *DAC_RIGHT=128;
-
-      return;
-    }
-  /* sound itself is done in q40_timer_int */
-  if (sound_ticks == 0) sound_ticks=1000; /* pretty long beep */
-  sound_ticks=ticks<<1;
+	/* for now ignore hz, except that hz==0 switches off sound */
+	/* simply alternate the ampl (128-SVOL)-(128+SVOL)-..-.. at 200Hz */
+	if (hz == 0) {
+		if (sound_ticks)
+			sound_ticks = 1;
+
+		*DAC_LEFT = 128;
+		*DAC_RIGHT = 128;
+
+		return;
+	}
+	/* sound itself is done in q40_timer_int */
+	if (sound_ticks == 0)
+		sound_ticks = 1000; /* pretty long beep */
+	sound_ticks = ticks << 1;
 }
 
 static irqreturn_t (*q40_timer_routine)(int, void *, struct pt_regs *);
 
 static irqreturn_t q40_timer_int (int irq, void * dev, struct pt_regs * regs)
 {
-    ql_ticks = ql_ticks ? 0 : 1;
-    if (sound_ticks)
-      {
-	unsigned char sval=(sound_ticks & 1) ? 128-SVOL : 128+SVOL;
-	sound_ticks--;
-	*DAC_LEFT=sval;
-	*DAC_RIGHT=sval;
-      }
-
-    if (!ql_ticks)
-	q40_timer_routine(irq, dev, regs);
-    return IRQ_HANDLED;
+	ql_ticks = ql_ticks ? 0 : 1;
+	if (sound_ticks) {
+		unsigned char sval=(sound_ticks & 1) ? 128-SVOL : 128+SVOL;
+		sound_ticks--;
+		*DAC_LEFT=sval;
+		*DAC_RIGHT=sval;
+	}
+
+	if (!ql_ticks)
+		q40_timer_routine(irq, dev, regs);
+	return IRQ_HANDLED;
 }
 
 void q40_sched_init (irqreturn_t (*timer_routine)(int, void *, struct pt_regs *))
 {
-    int timer_irq;
+	int timer_irq;
 
-    q40_timer_routine = timer_routine;
-    timer_irq=Q40_IRQ_FRAME;
+	q40_timer_routine = timer_routine;
+	timer_irq = Q40_IRQ_FRAME;
 
-    if (request_irq(timer_irq, q40_timer_int, 0,
+	if (request_irq(timer_irq, q40_timer_int, 0,
 				"timer", q40_timer_int))
-	panic ("Couldn't register timer int");
+		panic("Couldn't register timer int");
 
-    master_outb(-1,FRAME_CLEAR_REG);
-    master_outb( 1,FRAME_RATE_REG);
+	master_outb(-1, FRAME_CLEAR_REG);
+	master_outb( 1, FRAME_RATE_REG);
 }
 
 
@@ -307,153 +200,132 @@ static int mext_disabled=0;  /* ext irq disabled by master chip? */
 static int aliased_irq=0;  /* how many times inside handler ?*/
 
 
-/* got level 2 interrupt, dispatch to ISA or keyboard/timer IRQs */
-irqreturn_t q40_irq2_handler (int vec, void *devname, struct pt_regs *fp)
+/* got interrupt, dispatch to ISA or keyboard/timer IRQs */
+static void q40_irq_handler(unsigned int irq, struct pt_regs *fp)
 {
-  unsigned mir, mer;
-  int irq,i;
+	unsigned mir, mer;
+	int i;
 
 //repeat:
-  mir=master_inb(IIRQ_REG);
-  if (mir&Q40_IRQ_FRAME_MASK) {
-	  irq_tab[Q40_IRQ_FRAME].count++;
-	  irq_tab[Q40_IRQ_FRAME].handler(Q40_IRQ_FRAME,irq_tab[Q40_IRQ_FRAME].dev_id,fp);
-	  master_outb(-1,FRAME_CLEAR_REG);
-  }
-  if ((mir&Q40_IRQ_SER_MASK) || (mir&Q40_IRQ_EXT_MASK)) {
-	  mer=master_inb(EIRQ_REG);
-	  for (i=0; eirqs[i].mask; i++) {
-		  if (mer&(eirqs[i].mask)) {
-			  irq=eirqs[i].irq;
+	mir = master_inb(IIRQ_REG);
+#ifdef CONFIG_BLK_DEV_FD
+	if ((mir & Q40_IRQ_EXT_MASK) &&
+	    (master_inb(EIRQ_REG) & Q40_IRQ6_MASK)) {
+		floppy_hardint();
+		return;
+	}
+#endif
+	switch (irq) {
+	case 4:
+	case 6:
+		m68k_handle_int(Q40_IRQ_SAMPLE, fp);
+		return;
+	}
+	if (mir & Q40_IRQ_FRAME_MASK) {
+		m68k_handle_int(Q40_IRQ_FRAME, fp);
+		master_outb(-1, FRAME_CLEAR_REG);
+	}
+	if ((mir & Q40_IRQ_SER_MASK) || (mir & Q40_IRQ_EXT_MASK)) {
+		mer = master_inb(EIRQ_REG);
+		for (i = 0; eirqs[i].mask; i++) {
+			if (mer & eirqs[i].mask) {
+				irq = eirqs[i].irq;
 /*
  * There is a little mess wrt which IRQ really caused this irq request. The
  * main problem is that IIRQ_REG and EIRQ_REG reflect the state when they
  * are read - which is long after the request came in. In theory IRQs should
  * not just go away but they occassionally do
  */
-			  if (irq>4 && irq<=15 && mext_disabled) {
-				  /*aliased_irq++;*/
-				  goto iirq;
-			  }
-			  if (irq_tab[irq].handler == q40_defhand ) {
-				  printk("handler for IRQ %d not defined\n",irq);
-				  continue; /* ignore uninited INTs :-( */
-			  }
-			  if ( irq_tab[irq].state & IRQ_INPROGRESS ) {
-				  /* some handlers do local_irq_enable() for irq latency reasons, */
-				  /* however reentering an active irq handler is not permitted */
+				if (irq > 4 && irq <= 15 && mext_disabled) {
+					/*aliased_irq++;*/
+					goto iirq;
+				}
+				if (q40_state[irq] & IRQ_INPROGRESS) {
+					/* some handlers do local_irq_enable() for irq latency reasons, */
+					/* however reentering an active irq handler is not permitted */
 #ifdef IP_USE_DISABLE
-				  /* in theory this is the better way to do it because it still */
-				  /* lets through eg the serial irqs, unfortunately it crashes */
-				  disable_irq(irq);
-				  disabled=1;
+					/* in theory this is the better way to do it because it still */
+					/* lets through eg the serial irqs, unfortunately it crashes */
+					disable_irq(irq);
+					disabled = 1;
 #else
-				  /*printk("IRQ_INPROGRESS detected for irq %d, disabling - %s disabled\n",irq,disabled ? "already" : "not yet"); */
-				  fp->sr = (((fp->sr) & (~0x700))+0x200);
-				  disabled=1;
+					/*printk("IRQ_INPROGRESS detected for irq %d, disabling - %s disabled\n",
+						irq, disabled ? "already" : "not yet"); */
+					fp->sr = (((fp->sr) & (~0x700))+0x200);
+					disabled = 1;
 #endif
-				  goto iirq;
-			  }
-			  irq_tab[irq].count++;
-			  irq_tab[irq].state |= IRQ_INPROGRESS;
-			  irq_tab[irq].handler(irq,irq_tab[irq].dev_id,fp);
-			  irq_tab[irq].state &= ~IRQ_INPROGRESS;
-
-			  /* naively enable everything, if that fails than    */
-			  /* this function will be reentered immediately thus */
-			  /* getting another chance to disable the IRQ        */
-
-			  if ( disabled ) {
+					goto iirq;
+				}
+				q40_state[irq] |= IRQ_INPROGRESS;
+				m68k_handle_int(irq, fp);
+				q40_state[irq] &= ~IRQ_INPROGRESS;
+
+				/* naively enable everything, if that fails than    */
+				/* this function will be reentered immediately thus */
+				/* getting another chance to disable the IRQ        */
+
+				if (disabled) {
 #ifdef IP_USE_DISABLE
-				  if (irq>4){
-					  disabled=0;
-					  enable_irq(irq);}
+					if (irq > 4) {
+						disabled = 0;
+						enable_irq(irq);
+					}
 #else
-				  disabled=0;
-				  /*printk("reenabling irq %d\n",irq); */
+					disabled = 0;
+					/*printk("reenabling irq %d\n", irq); */
 #endif
-			  }
+				}
 // used to do 'goto repeat;' here, this delayed bh processing too long
-			  return IRQ_HANDLED;
-		  }
-	  }
-	  if (mer && ccleirq>0 && !aliased_irq)
-		  printk("ISA interrupt from unknown source? EIRQ_REG = %x\n",mer),ccleirq--;
-  }
- iirq:
-  mir=master_inb(IIRQ_REG);
-  /* should test whether keyboard irq is really enabled, doing it in defhand */
-  if (mir&Q40_IRQ_KEYB_MASK) {
-	  irq_tab[Q40_IRQ_KEYBOARD].count++;
-	  irq_tab[Q40_IRQ_KEYBOARD].handler(Q40_IRQ_KEYBOARD,irq_tab[Q40_IRQ_KEYBOARD].dev_id,fp);
-  }
-  return IRQ_HANDLED;
-}
-
-int show_q40_interrupts (struct seq_file *p, void *v)
-{
-	int i;
-
-	for (i = 0; i <= Q40_IRQ_MAX; i++) {
-		if (irq_tab[i].count)
-		      seq_printf(p, "%sIRQ %02d: %8d  %s%s\n",
-			      (i<=15) ? "ISA-" : "    " ,
-			    i, irq_tab[i].count,
-			    irq_tab[i].devname[0] ? irq_tab[i].devname : "?",
-			    irq_tab[i].handler == q40_defhand ?
-					" (now unassigned)" : "");
+				return;
+			}
+		}
+		if (mer && ccleirq > 0 && !aliased_irq) {
+			printk("ISA interrupt from unknown source? EIRQ_REG = %x\n",mer);
+			ccleirq--;
+		}
 	}
-	return 0;
-}
-
+ iirq:
+	mir = master_inb(IIRQ_REG);
+	/* should test whether keyboard irq is really enabled, doing it in defhand */
+	if (mir & Q40_IRQ_KEYB_MASK)
+		m68k_handle_int(Q40_IRQ_KEYBOARD, fp);
 
-static irqreturn_t q40_defhand (int irq, void *dev_id, struct pt_regs *fp)
-{
-        if (irq!=Q40_IRQ_KEYBOARD)
-	     printk ("Unknown q40 interrupt %d\n", irq);
-	else master_outb(-1,KEYBOARD_UNLOCK_REG);
-	return IRQ_NONE;
+	return;
 }
 
-
-void q40_enable_irq (unsigned int irq)
+void q40_enable_irq(unsigned int irq)
 {
-  if ( irq>=5 && irq<=15 )
-  {
-    mext_disabled--;
-    if (mext_disabled>0)
-	  printk("q40_enable_irq : nested disable/enable\n");
-    if (mext_disabled==0)
-    master_outb(1,EXT_ENABLE_REG);
-    }
+	if (irq >= 5 && irq <= 15) {
+		mext_disabled--;
+		if (mext_disabled > 0)
+			printk("q40_enable_irq : nested disable/enable\n");
+		if (mext_disabled == 0)
+			master_outb(1, EXT_ENABLE_REG);
+	}
 }
 
 
-void q40_disable_irq (unsigned int irq)
+void q40_disable_irq(unsigned int irq)
 {
-  /* disable ISA iqs : only do something if the driver has been
-   * verified to be Q40 "compatible" - right now IDE, NE2K
-   * Any driver should not attempt to sleep across disable_irq !!
-   */
-
-  if ( irq>=5 && irq<=15 ) {
-    master_outb(0,EXT_ENABLE_REG);
-    mext_disabled++;
-    if (mext_disabled>1) printk("disable_irq nesting count %d\n",mext_disabled);
-  }
+	/* disable ISA iqs : only do something if the driver has been
+	 * verified to be Q40 "compatible" - right now IDE, NE2K
+	 * Any driver should not attempt to sleep across disable_irq !!
+	 */
+
+	if (irq >= 5 && irq <= 15) {
+		master_outb(0, EXT_ENABLE_REG);
+		mext_disabled++;
+		if (mext_disabled > 1)
+			printk("disable_irq nesting count %d\n",mext_disabled);
+	}
 }
 
-unsigned long q40_probe_irq_on (void)
+unsigned long q40_probe_irq_on(void)
 {
-  printk("irq probing not working - reconfigure the driver to avoid this\n");
-  return -1;
+	printk("irq probing not working - reconfigure the driver to avoid this\n");
+	return -1;
 }
-int q40_probe_irq_off (unsigned long irqs)
+int q40_probe_irq_off(unsigned long irqs)
 {
-  return -1;
+	return -1;
 }
-/*
- * Local variables:
- * compile-command: "m68k-linux-gcc -D__KERNEL__ -I/home/rz/lx/linux-2.2.6/include -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -pipe -fno-strength-reduce -ffixed-a2 -m68040   -c -o q40ints.o q40ints.c"
- * End:
- */

commit b5dc7840b3ebe9c7967dd8ba73db957767009ff9
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:00 2006 -0700

    [PATCH] m68k: introduce irq controller
    
    Introduce irq controller and use it to manage auto vector interrupts.
    Introduce setup_irq() which can be used for irq setup.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index b106839ad813..ff80cba110d4 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -46,7 +46,6 @@ irqreturn_t q40_irq2_handler (int, void *, struct pt_regs *fp);
 
 
 static irqreturn_t q40_defhand (int irq, void *dev_id, struct pt_regs *fp);
-static irqreturn_t default_handler(int lev, void *dev_id, struct pt_regs *regs);
 
 
 #define DEVNAME_SIZE 24
@@ -415,22 +414,6 @@ static irqreturn_t q40_defhand (int irq, void *dev_id, struct pt_regs *fp)
 	else master_outb(-1,KEYBOARD_UNLOCK_REG);
 	return IRQ_NONE;
 }
-static irqreturn_t default_handler(int lev, void *dev_id, struct pt_regs *regs)
-{
-	printk ("Uninitialised interrupt level %d\n", lev);
-	return IRQ_NONE;
-}
-
-irqreturn_t (*q40_default_handler[SYS_IRQS])(int, void *, struct pt_regs *) = {
-	 [0] = default_handler,
-	 [1] = default_handler,
-	 [2] = default_handler,
-	 [3] = default_handler,
-	 [4] = default_handler,
-	 [5] = default_handler,
-	 [6] = default_handler,
-	 [7] = default_handler
-};
 
 
 void q40_enable_irq (unsigned int irq)

commit 4facfde9f1d7b8a61fb0017460da45e23e60115c
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:46:59 2006 -0700

    [PATCH] m68k: cleanup generic irq names
    
    Rename IRQ1..IRQ7 to IRQ_AUTO_1..IRQ_AUTO_7 and remove the duplicate
    defintions.
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
index f8ecc2664fe6..b106839ad813 100644
--- a/arch/m68k/q40/q40ints.c
+++ b/arch/m68k/q40/q40ints.c
@@ -93,8 +93,8 @@ void q40_init_IRQ (void)
 	}
 
 	/* setup handler for ISA ints */
-	cpu_request_irq(IRQ2, q40_irq2_handler, 0, "q40 ISA and master chip",
-			NULL);
+	cpu_request_irq(IRQ_AUTO_2, q40_irq2_handler, 0,
+			"q40 ISA and master chip", NULL);
 
 	/* now enable some ints.. */
 	master_outb(1,EXT_ENABLE_REG);  /* ISA IRQ 5-15 */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/m68k/q40/q40ints.c b/arch/m68k/q40/q40ints.c
new file mode 100644
index 000000000000..f8ecc2664fe6
--- /dev/null
+++ b/arch/m68k/q40/q40ints.c
@@ -0,0 +1,476 @@
+/*
+ * arch/m68k/q40/q40ints.c
+ *
+ * Copyright (C) 1999,2001 Richard Zidlicky
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ * .. used to be loosely based on bvme6000ints.c
+ *
+ */
+
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/sched.h>
+#include <linux/seq_file.h>
+#include <linux/interrupt.h>
+#include <linux/hardirq.h>
+
+#include <asm/rtc.h>
+#include <asm/ptrace.h>
+#include <asm/system.h>
+#include <asm/irq.h>
+#include <asm/traps.h>
+
+#include <asm/q40_master.h>
+#include <asm/q40ints.h>
+
+/*
+ * Q40 IRQs are defined as follows:
+ *            3,4,5,6,7,10,11,14,15 : ISA dev IRQs
+ *            16-31: reserved
+ *            32   : keyboard int
+ *            33   : frame int (50/200 Hz periodic timer)
+ *            34   : sample int (10/20 KHz periodic timer)
+ *
+*/
+
+extern int ints_inited;
+
+
+irqreturn_t q40_irq2_handler (int, void *, struct pt_regs *fp);
+
+
+static irqreturn_t q40_defhand (int irq, void *dev_id, struct pt_regs *fp);
+static irqreturn_t default_handler(int lev, void *dev_id, struct pt_regs *regs);
+
+
+#define DEVNAME_SIZE 24
+
+static struct q40_irq_node {
+	irqreturn_t	(*handler)(int, void *, struct pt_regs *);
+	unsigned long	flags;
+	void		*dev_id;
+  /*        struct q40_irq_node *next;*/
+        char	        devname[DEVNAME_SIZE];
+	unsigned	count;
+        unsigned short  state;
+} irq_tab[Q40_IRQ_MAX+1];
+
+short unsigned q40_ablecount[Q40_IRQ_MAX+1];
+
+/*
+ * void q40_init_IRQ (void)
+ *
+ * Parameters:	None
+ *
+ * Returns:	Nothing
+ *
+ * This function is called during kernel startup to initialize
+ * the q40 IRQ handling routines.
+ */
+
+static int disabled=0;
+
+void q40_init_IRQ (void)
+{
+	int i;
+
+	disabled=0;
+	for (i = 0; i <= Q40_IRQ_MAX; i++) {
+		irq_tab[i].handler = q40_defhand;
+		irq_tab[i].flags = 0;
+		irq_tab[i].dev_id = NULL;
+		/*		irq_tab[i].next = NULL;*/
+		irq_tab[i].devname[0] = 0;
+		irq_tab[i].count = 0;
+		irq_tab[i].state =0;
+		q40_ablecount[i]=0;   /* all enabled */
+	}
+
+	/* setup handler for ISA ints */
+	cpu_request_irq(IRQ2, q40_irq2_handler, 0, "q40 ISA and master chip",
+			NULL);
+
+	/* now enable some ints.. */
+	master_outb(1,EXT_ENABLE_REG);  /* ISA IRQ 5-15 */
+
+	/* make sure keyboard IRQ is disabled */
+	master_outb(0,KEY_IRQ_ENABLE_REG);
+}
+
+int q40_request_irq(unsigned int irq,
+		irqreturn_t (*handler)(int, void *, struct pt_regs *),
+                unsigned long flags, const char *devname, void *dev_id)
+{
+  /*printk("q40_request_irq %d, %s\n",irq,devname);*/
+
+	if (irq > Q40_IRQ_MAX || (irq>15 && irq<32)) {
+		printk("%s: Incorrect IRQ %d from %s\n", __FUNCTION__, irq, devname);
+		return -ENXIO;
+	}
+
+	/* test for ISA ints not implemented by HW */
+	switch (irq)
+	  {
+	  case 1: case 2: case 8: case 9:
+	  case 12: case 13:
+	    printk("%s: ISA IRQ %d from %s not implemented by HW\n", __FUNCTION__, irq, devname);
+	    return -ENXIO;
+	  case 11:
+	    printk("warning IRQ 10 and 11 not distinguishable\n");
+	    irq=10;
+	  default:
+	    ;
+	  }
+
+	if (irq<Q40_IRQ_SAMPLE)
+	  {
+	    if (irq_tab[irq].dev_id != NULL)
+		  {
+		    printk("%s: IRQ %d from %s is not replaceable\n",
+			   __FUNCTION__, irq, irq_tab[irq].devname);
+		    return -EBUSY;
+		  }
+	    /*printk("IRQ %d set to handler %p\n",irq,handler);*/
+	    if (dev_id==NULL)
+		  {
+		printk("WARNING: dev_id == NULL in request_irq\n");
+		dev_id=(void*)1;
+	      }
+	    irq_tab[irq].handler = handler;
+	    irq_tab[irq].flags   = flags;
+	    irq_tab[irq].dev_id  = dev_id;
+	    strlcpy(irq_tab[irq].devname,devname,sizeof(irq_tab[irq].devname));
+	    irq_tab[irq].state = 0;
+	    return 0;
+	  }
+	else {
+	  /* Q40_IRQ_SAMPLE :somewhat special actions required here ..*/
+	  cpu_request_irq(4, handler, flags, devname, dev_id);
+	  cpu_request_irq(6, handler, flags, devname, dev_id);
+	  return 0;
+	}
+}
+
+void q40_free_irq(unsigned int irq, void *dev_id)
+{
+	if (irq > Q40_IRQ_MAX || (irq>15 && irq<32)) {
+		printk("%s: Incorrect IRQ %d, dev_id %x \n", __FUNCTION__, irq, (unsigned)dev_id);
+		return;
+	}
+
+	/* test for ISA ints not implemented by HW */
+	switch (irq)
+	  {
+	  case 1: case 2: case 8: case 9:
+	  case 12: case 13:
+	    printk("%s: ISA IRQ %d from %x invalid\n", __FUNCTION__, irq, (unsigned)dev_id);
+	    return;
+	  case 11: irq=10;
+	  default:
+	    ;
+	  }
+
+	if (irq<Q40_IRQ_SAMPLE)
+	  {
+	    if (irq_tab[irq].dev_id != dev_id)
+	      printk("%s: Removing probably wrong IRQ %d from %s\n",
+		     __FUNCTION__, irq, irq_tab[irq].devname);
+
+	    irq_tab[irq].handler = q40_defhand;
+	    irq_tab[irq].flags   = 0;
+	    irq_tab[irq].dev_id  = NULL;
+	    /* irq_tab[irq].devname = NULL; */
+	    /* do not reset state !! */
+	  }
+	else
+	  { /* == Q40_IRQ_SAMPLE */
+	    cpu_free_irq(4, dev_id);
+	    cpu_free_irq(6, dev_id);
+	  }
+}
+
+
+irqreturn_t q40_process_int (int level, struct pt_regs *fp)
+{
+  printk("unexpected interrupt vec=%x, pc=%lx, d0=%lx, d0_orig=%lx, d1=%lx, d2=%lx\n",
+          level, fp->pc, fp->d0, fp->orig_d0, fp->d1, fp->d2);
+  printk("\tIIRQ_REG = %x, EIRQ_REG = %x\n",master_inb(IIRQ_REG),master_inb(EIRQ_REG));
+  return IRQ_HANDLED;
+}
+
+/*
+ * this stuff doesn't really belong here..
+*/
+
+int ql_ticks;              /* 200Hz ticks since last jiffie */
+static int sound_ticks;
+
+#define SVOL 45
+
+void q40_mksound(unsigned int hz, unsigned int ticks)
+{
+  /* for now ignore hz, except that hz==0 switches off sound */
+  /* simply alternate the ampl (128-SVOL)-(128+SVOL)-..-.. at 200Hz */
+  if (hz==0)
+    {
+      if (sound_ticks)
+	sound_ticks=1;
+
+      *DAC_LEFT=128;
+      *DAC_RIGHT=128;
+
+      return;
+    }
+  /* sound itself is done in q40_timer_int */
+  if (sound_ticks == 0) sound_ticks=1000; /* pretty long beep */
+  sound_ticks=ticks<<1;
+}
+
+static irqreturn_t (*q40_timer_routine)(int, void *, struct pt_regs *);
+
+static irqreturn_t q40_timer_int (int irq, void * dev, struct pt_regs * regs)
+{
+    ql_ticks = ql_ticks ? 0 : 1;
+    if (sound_ticks)
+      {
+	unsigned char sval=(sound_ticks & 1) ? 128-SVOL : 128+SVOL;
+	sound_ticks--;
+	*DAC_LEFT=sval;
+	*DAC_RIGHT=sval;
+      }
+
+    if (!ql_ticks)
+	q40_timer_routine(irq, dev, regs);
+    return IRQ_HANDLED;
+}
+
+void q40_sched_init (irqreturn_t (*timer_routine)(int, void *, struct pt_regs *))
+{
+    int timer_irq;
+
+    q40_timer_routine = timer_routine;
+    timer_irq=Q40_IRQ_FRAME;
+
+    if (request_irq(timer_irq, q40_timer_int, 0,
+				"timer", q40_timer_int))
+	panic ("Couldn't register timer int");
+
+    master_outb(-1,FRAME_CLEAR_REG);
+    master_outb( 1,FRAME_RATE_REG);
+}
+
+
+/*
+ * tables to translate bits into IRQ numbers
+ * it is a good idea to order the entries by priority
+ *
+*/
+
+struct IRQ_TABLE{ unsigned mask; int irq ;};
+#if 0
+static struct IRQ_TABLE iirqs[]={
+  {Q40_IRQ_FRAME_MASK,Q40_IRQ_FRAME},
+  {Q40_IRQ_KEYB_MASK,Q40_IRQ_KEYBOARD},
+  {0,0}};
+#endif
+static struct IRQ_TABLE eirqs[] = {
+  { .mask = Q40_IRQ3_MASK,	.irq = 3 },	/* ser 1 */
+  { .mask = Q40_IRQ4_MASK,	.irq = 4 },	/* ser 2 */
+  { .mask = Q40_IRQ14_MASK,	.irq = 14 },	/* IDE 1 */
+  { .mask = Q40_IRQ15_MASK,	.irq = 15 },	/* IDE 2 */
+  { .mask = Q40_IRQ6_MASK,	.irq = 6 },	/* floppy, handled elsewhere */
+  { .mask = Q40_IRQ7_MASK,	.irq = 7 },	/* par */
+  { .mask = Q40_IRQ5_MASK,	.irq = 5 },
+  { .mask = Q40_IRQ10_MASK,	.irq = 10 },
+  {0,0}
+};
+
+/* complain only this many times about spurious ints : */
+static int ccleirq=60;    /* ISA dev IRQ's*/
+/*static int cclirq=60;*/     /* internal */
+
+/* FIXME: add shared ints,mask,unmask,probing.... */
+
+#define IRQ_INPROGRESS 1
+/*static unsigned short saved_mask;*/
+//static int do_tint=0;
+
+#define DEBUG_Q40INT
+/*#define IP_USE_DISABLE *//* would be nice, but crashes ???? */
+
+static int mext_disabled=0;  /* ext irq disabled by master chip? */
+static int aliased_irq=0;  /* how many times inside handler ?*/
+
+
+/* got level 2 interrupt, dispatch to ISA or keyboard/timer IRQs */
+irqreturn_t q40_irq2_handler (int vec, void *devname, struct pt_regs *fp)
+{
+  unsigned mir, mer;
+  int irq,i;
+
+//repeat:
+  mir=master_inb(IIRQ_REG);
+  if (mir&Q40_IRQ_FRAME_MASK) {
+	  irq_tab[Q40_IRQ_FRAME].count++;
+	  irq_tab[Q40_IRQ_FRAME].handler(Q40_IRQ_FRAME,irq_tab[Q40_IRQ_FRAME].dev_id,fp);
+	  master_outb(-1,FRAME_CLEAR_REG);
+  }
+  if ((mir&Q40_IRQ_SER_MASK) || (mir&Q40_IRQ_EXT_MASK)) {
+	  mer=master_inb(EIRQ_REG);
+	  for (i=0; eirqs[i].mask; i++) {
+		  if (mer&(eirqs[i].mask)) {
+			  irq=eirqs[i].irq;
+/*
+ * There is a little mess wrt which IRQ really caused this irq request. The
+ * main problem is that IIRQ_REG and EIRQ_REG reflect the state when they
+ * are read - which is long after the request came in. In theory IRQs should
+ * not just go away but they occassionally do
+ */
+			  if (irq>4 && irq<=15 && mext_disabled) {
+				  /*aliased_irq++;*/
+				  goto iirq;
+			  }
+			  if (irq_tab[irq].handler == q40_defhand ) {
+				  printk("handler for IRQ %d not defined\n",irq);
+				  continue; /* ignore uninited INTs :-( */
+			  }
+			  if ( irq_tab[irq].state & IRQ_INPROGRESS ) {
+				  /* some handlers do local_irq_enable() for irq latency reasons, */
+				  /* however reentering an active irq handler is not permitted */
+#ifdef IP_USE_DISABLE
+				  /* in theory this is the better way to do it because it still */
+				  /* lets through eg the serial irqs, unfortunately it crashes */
+				  disable_irq(irq);
+				  disabled=1;
+#else
+				  /*printk("IRQ_INPROGRESS detected for irq %d, disabling - %s disabled\n",irq,disabled ? "already" : "not yet"); */
+				  fp->sr = (((fp->sr) & (~0x700))+0x200);
+				  disabled=1;
+#endif
+				  goto iirq;
+			  }
+			  irq_tab[irq].count++;
+			  irq_tab[irq].state |= IRQ_INPROGRESS;
+			  irq_tab[irq].handler(irq,irq_tab[irq].dev_id,fp);
+			  irq_tab[irq].state &= ~IRQ_INPROGRESS;
+
+			  /* naively enable everything, if that fails than    */
+			  /* this function will be reentered immediately thus */
+			  /* getting another chance to disable the IRQ        */
+
+			  if ( disabled ) {
+#ifdef IP_USE_DISABLE
+				  if (irq>4){
+					  disabled=0;
+					  enable_irq(irq);}
+#else
+				  disabled=0;
+				  /*printk("reenabling irq %d\n",irq); */
+#endif
+			  }
+// used to do 'goto repeat;' here, this delayed bh processing too long
+			  return IRQ_HANDLED;
+		  }
+	  }
+	  if (mer && ccleirq>0 && !aliased_irq)
+		  printk("ISA interrupt from unknown source? EIRQ_REG = %x\n",mer),ccleirq--;
+  }
+ iirq:
+  mir=master_inb(IIRQ_REG);
+  /* should test whether keyboard irq is really enabled, doing it in defhand */
+  if (mir&Q40_IRQ_KEYB_MASK) {
+	  irq_tab[Q40_IRQ_KEYBOARD].count++;
+	  irq_tab[Q40_IRQ_KEYBOARD].handler(Q40_IRQ_KEYBOARD,irq_tab[Q40_IRQ_KEYBOARD].dev_id,fp);
+  }
+  return IRQ_HANDLED;
+}
+
+int show_q40_interrupts (struct seq_file *p, void *v)
+{
+	int i;
+
+	for (i = 0; i <= Q40_IRQ_MAX; i++) {
+		if (irq_tab[i].count)
+		      seq_printf(p, "%sIRQ %02d: %8d  %s%s\n",
+			      (i<=15) ? "ISA-" : "    " ,
+			    i, irq_tab[i].count,
+			    irq_tab[i].devname[0] ? irq_tab[i].devname : "?",
+			    irq_tab[i].handler == q40_defhand ?
+					" (now unassigned)" : "");
+	}
+	return 0;
+}
+
+
+static irqreturn_t q40_defhand (int irq, void *dev_id, struct pt_regs *fp)
+{
+        if (irq!=Q40_IRQ_KEYBOARD)
+	     printk ("Unknown q40 interrupt %d\n", irq);
+	else master_outb(-1,KEYBOARD_UNLOCK_REG);
+	return IRQ_NONE;
+}
+static irqreturn_t default_handler(int lev, void *dev_id, struct pt_regs *regs)
+{
+	printk ("Uninitialised interrupt level %d\n", lev);
+	return IRQ_NONE;
+}
+
+irqreturn_t (*q40_default_handler[SYS_IRQS])(int, void *, struct pt_regs *) = {
+	 [0] = default_handler,
+	 [1] = default_handler,
+	 [2] = default_handler,
+	 [3] = default_handler,
+	 [4] = default_handler,
+	 [5] = default_handler,
+	 [6] = default_handler,
+	 [7] = default_handler
+};
+
+
+void q40_enable_irq (unsigned int irq)
+{
+  if ( irq>=5 && irq<=15 )
+  {
+    mext_disabled--;
+    if (mext_disabled>0)
+	  printk("q40_enable_irq : nested disable/enable\n");
+    if (mext_disabled==0)
+    master_outb(1,EXT_ENABLE_REG);
+    }
+}
+
+
+void q40_disable_irq (unsigned int irq)
+{
+  /* disable ISA iqs : only do something if the driver has been
+   * verified to be Q40 "compatible" - right now IDE, NE2K
+   * Any driver should not attempt to sleep across disable_irq !!
+   */
+
+  if ( irq>=5 && irq<=15 ) {
+    master_outb(0,EXT_ENABLE_REG);
+    mext_disabled++;
+    if (mext_disabled>1) printk("disable_irq nesting count %d\n",mext_disabled);
+  }
+}
+
+unsigned long q40_probe_irq_on (void)
+{
+  printk("irq probing not working - reconfigure the driver to avoid this\n");
+  return -1;
+}
+int q40_probe_irq_off (unsigned long irqs)
+{
+  return -1;
+}
+/*
+ * Local variables:
+ * compile-command: "m68k-linux-gcc -D__KERNEL__ -I/home/rz/lx/linux-2.2.6/include -Wall -Wstrict-prototypes -O2 -fomit-frame-pointer -pipe -fno-strength-reduce -ffixed-a2 -m68040   -c -o q40ints.o q40ints.c"
+ * End:
+ */
