commit 7cca9b8b7c5bcc56d627851550840586a25aaa1b
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Fri Aug 23 11:47:28 2019 +0200

    microblaze: Switch to standard restart handler
    
    The microblaze uses the legacy APIs to dig out a GPIO pin
    defined in the root of the device tree to issue a hard
    reset of the platform.
    
    Asserting a hard reset should be done using the standard
    DT-enabled and fully GPIO descriptor aware driver in
    drivers/power/reset/gpio-restart.c using the bindings
    from Documentation/devicetree/bindings/power/reset/gpio-restart.txt
    
    To achieve this, first make sure microblaze makes use of
    the standard kernel restart path utilizing do_kernel_restart()
    from <linux/reboot.h>. Put in some grace time and an
    emergency print if the restart does not properly assert.
    
    As this is basic platform functionality we patch the DTS
    file and defconfig in one go for a lockstep change.
    
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Michal Simek <monstr@monstr.eu>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    [ Michal: Move machine_restart back to reset.c ]
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index fcbe1daf6316..5f4722908164 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -8,83 +8,9 @@
  */
 
 #include <linux/init.h>
+#include <linux/delay.h>
 #include <linux/of_platform.h>
-
-/* Trigger specific functions */
-#ifdef CONFIG_GPIOLIB
-
-#include <linux/of_gpio.h>
-
-static int handle; /* reset pin handle */
-static unsigned int reset_val;
-
-static int of_platform_reset_gpio_probe(void)
-{
-	int ret;
-	handle = of_get_named_gpio(of_find_node_by_path("/"),
-				   "hard-reset-gpios", 0);
-
-	if (!gpio_is_valid(handle)) {
-		pr_info("Skipping unavailable RESET gpio %d (%s)\n",
-				handle, "reset");
-		return -ENODEV;
-	}
-
-	ret = gpio_request(handle, "reset");
-	if (ret < 0) {
-		pr_info("GPIO pin is already allocated\n");
-		return ret;
-	}
-
-	/* get current setup value */
-	reset_val = gpio_get_value(handle);
-	/* FIXME maybe worth to perform any action */
-	pr_debug("Reset: Gpio output state: 0x%x\n", reset_val);
-
-	/* Setup GPIO as output */
-	ret = gpio_direction_output(handle, 0);
-	if (ret < 0)
-		goto err;
-
-	/* Setup output direction */
-	gpio_set_value(handle, 0);
-
-	pr_info("RESET: Registered gpio device: %d, current val: %d\n",
-							handle, reset_val);
-	return 0;
-err:
-	gpio_free(handle);
-	return ret;
-}
-device_initcall(of_platform_reset_gpio_probe);
-
-
-static void gpio_system_reset(void)
-{
-	if (gpio_is_valid(handle))
-		gpio_set_value(handle, 1 - reset_val);
-	else
-		pr_notice("Reset GPIO unavailable - halting!\n");
-}
-#else
-static void gpio_system_reset(void)
-{
-	pr_notice("No reset GPIO present - halting!\n");
-}
-
-void of_platform_reset_gpio_probe(void)
-{
-	return;
-}
-#endif
-
-void machine_restart(char *cmd)
-{
-	pr_notice("Machine restart...\n");
-	gpio_system_reset();
-	while (1)
-		;
-}
+#include <linux/reboot.h>
 
 void machine_shutdown(void)
 {
@@ -106,3 +32,12 @@ void machine_power_off(void)
 	while (1)
 		;
 }
+
+void machine_restart(char *cmd)
+{
+	do_kernel_restart(cmd);
+	/* Give the restart hook 1 s to take us down */
+	mdelay(1000);
+	pr_emerg("Reboot failed -- System halted\n");
+	while (1);
+}

commit 45df561a7ae2ca5080708cc2cf84a236f4d930ef
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jun 19 15:36:20 2018 -0600

    microblaze: consolidate GPIO reset handling
    
    Now that platform.c only has the GPIO reset handling left, move the
    initcall to reset.c and remove platform.c.
    
    Cc: Michal Simek <monstr@monstr.eu>
    Signed-off-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index bab4c8330ef4..fcbe1daf6316 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -18,7 +18,7 @@
 static int handle; /* reset pin handle */
 static unsigned int reset_val;
 
-void of_platform_reset_gpio_probe(void)
+static int of_platform_reset_gpio_probe(void)
 {
 	int ret;
 	handle = of_get_named_gpio(of_find_node_by_path("/"),
@@ -27,13 +27,13 @@ void of_platform_reset_gpio_probe(void)
 	if (!gpio_is_valid(handle)) {
 		pr_info("Skipping unavailable RESET gpio %d (%s)\n",
 				handle, "reset");
-		return;
+		return -ENODEV;
 	}
 
 	ret = gpio_request(handle, "reset");
 	if (ret < 0) {
 		pr_info("GPIO pin is already allocated\n");
-		return;
+		return ret;
 	}
 
 	/* get current setup value */
@@ -51,11 +51,12 @@ void of_platform_reset_gpio_probe(void)
 
 	pr_info("RESET: Registered gpio device: %d, current val: %d\n",
 							handle, reset_val);
-	return;
+	return 0;
 err:
 	gpio_free(handle);
-	return;
+	return ret;
 }
+device_initcall(of_platform_reset_gpio_probe);
 
 
 static void gpio_system_reset(void)

commit b366f11b9a81ad0cc7ed3cbdaca15bb98f96db25
Author: Michal Simek <michal.simek@xilinx.com>
Date:   Thu Dec 18 15:31:59 2014 +0100

    microblaze: Remove unused prom header from reset.c
    
    Completely unused header by this file.
    
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index fbe58c6554a8..bab4c8330ef4 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -9,7 +9,6 @@
 
 #include <linux/init.h>
 #include <linux/of_platform.h>
-#include <asm/prom.h>
 
 /* Trigger specific functions */
 #ifdef CONFIG_GPIOLIB

commit 54ea21f0785fd01fb3279d42fe6670cef64cf648
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon May 28 09:56:40 2012 +0200

    microblaze: Show message when reset gpio is not present
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index 2e5079ab53d2..fbe58c6554a8 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -67,7 +67,11 @@ static void gpio_system_reset(void)
 		pr_notice("Reset GPIO unavailable - halting!\n");
 }
 #else
-#define gpio_system_reset() do {} while (0)
+static void gpio_system_reset(void)
+{
+	pr_notice("No reset GPIO present - halting!\n");
+}
+
 void of_platform_reset_gpio_probe(void)
 {
 	return;

commit aaa5241ebb53733663775c8a044004d63a126eb6
Author: Michal Simek <monstr@monstr.eu>
Date:   Thu Oct 4 14:24:58 2012 +0200

    microblaze: Prefer to use pr_XXX instead of printk(KERN_XX)
    
    Fix reset.c, timer.c, setup.c file.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index 6ce60fb24ac5..2e5079ab53d2 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -26,14 +26,14 @@ void of_platform_reset_gpio_probe(void)
 				   "hard-reset-gpios", 0);
 
 	if (!gpio_is_valid(handle)) {
-		printk(KERN_INFO "Skipping unavailable RESET gpio %d (%s)\n",
+		pr_info("Skipping unavailable RESET gpio %d (%s)\n",
 				handle, "reset");
 		return;
 	}
 
 	ret = gpio_request(handle, "reset");
 	if (ret < 0) {
-		printk(KERN_INFO "GPIO pin is already allocated\n");
+		pr_info("GPIO pin is already allocated\n");
 		return;
 	}
 
@@ -50,7 +50,7 @@ void of_platform_reset_gpio_probe(void)
 	/* Setup output direction */
 	gpio_set_value(handle, 0);
 
-	printk(KERN_INFO "RESET: Registered gpio device: %d, current val: %d\n",
+	pr_info("RESET: Registered gpio device: %d, current val: %d\n",
 							handle, reset_val);
 	return;
 err:
@@ -76,7 +76,7 @@ void of_platform_reset_gpio_probe(void)
 
 void machine_restart(char *cmd)
 {
-	printk(KERN_NOTICE "Machine restart...\n");
+	pr_notice("Machine restart...\n");
 	gpio_system_reset();
 	while (1)
 		;
@@ -84,21 +84,21 @@ void machine_restart(char *cmd)
 
 void machine_shutdown(void)
 {
-	printk(KERN_NOTICE "Machine shutdown...\n");
+	pr_notice("Machine shutdown...\n");
 	while (1)
 		;
 }
 
 void machine_halt(void)
 {
-	printk(KERN_NOTICE "Machine halt...\n");
+	pr_notice("Machine halt...\n");
 	while (1)
 		;
 }
 
 void machine_power_off(void)
 {
-	printk(KERN_NOTICE "Machine power off...\n");
+	pr_notice("Machine power off...\n");
 	while (1)
 		;
 }

commit 191d5eca2405b58cece0e572f694abd1230b0efe
Author: Stephan Linz <linz@li-pro.net>
Date:   Wed Jun 20 22:36:37 2012 +0200

    microblaze: Improve failure handling for GPIO reset
    
    Early exit from of_platform_reset_gpio_probe() if there
    was no GPIO reset line configured.
    
    Avoid kernel oops in gpio_system_reset():
    
    [   27.413294] Restarting system.
    [   27.415674] Machine restart...
    [   27.418787] Oops: kernel access of bad area, sig: 11
    [   27.423252]  Registers dump: mode=83871D1C
    [   27.427428]  r1=00000000, r2=00000000, r3=FFFFFEF8, r4=00000000
    [   27.433310]  r5=C026AED0, r6=00000001, r7=00000068, r8=00000000
    [   27.439189]  r9=C3871DAC, r10=000011A5, r11=00000000, r12=0000000A
    [   27.445318]  r13=00000000, r14=0000000F, r15=C00029BC, r16=00000000
    [   27.451558]  r17=C011DE8C, r18=80000115, r19=0000000F, r20=48184ED8
    [   27.457770]  r21=00000000, r22=FFFFFFEA, r23=00000001, r24=FEE1DEAD
    [   27.463982]  r25=00000054, r26=1000B1C8, r27=00000000, r28=00000000
    [   27.470208]  r29=00000000, r30=00000000, r31=C32D30C0, rPC=C011DE8C
    [   27.476433]  msr=000042A2, ear=0000004B, esr=00000872, fsr=342E3732
    
    And remove useless dump_stack from machine_restart.
    
    Signed-off-by: Stephan Linz <linz@li-pro.net>
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index 88a01636f785..6ce60fb24ac5 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -28,6 +28,7 @@ void of_platform_reset_gpio_probe(void)
 	if (!gpio_is_valid(handle)) {
 		printk(KERN_INFO "Skipping unavailable RESET gpio %d (%s)\n",
 				handle, "reset");
+		return;
 	}
 
 	ret = gpio_request(handle, "reset");
@@ -60,7 +61,10 @@ void of_platform_reset_gpio_probe(void)
 
 static void gpio_system_reset(void)
 {
-	gpio_set_value(handle, 1 - reset_val);
+	if (gpio_is_valid(handle))
+		gpio_set_value(handle, 1 - reset_val);
+	else
+		pr_notice("Reset GPIO unavailable - halting!\n");
 }
 #else
 #define gpio_system_reset() do {} while (0)
@@ -74,7 +78,6 @@ void machine_restart(char *cmd)
 {
 	printk(KERN_NOTICE "Machine restart...\n");
 	gpio_system_reset();
-	dump_stack();
 	while (1)
 		;
 }

commit fe9f68449a507e03d41bee4500456bbfa22095d3
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Mon Dec 12 09:25:56 2011 -0700

    gpio/microblaze: Eliminate duplication of of_get_named_gpio_flags()
    
    of_reset_gpio_handle() is largely a cut-and-paste copy of
    of_get_named_gpio_flags(). There really isn't any reason for the
    split, so this patch deletes the duplicate function
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index bd8ccab5ceff..88a01636f785 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -19,50 +19,11 @@
 static int handle; /* reset pin handle */
 static unsigned int reset_val;
 
-static int of_reset_gpio_handle(void)
-{
-	int ret; /* variable which stored handle reset gpio pin */
-	struct device_node *root; /* root node */
-	struct device_node *gpio; /* gpio node */
-	struct gpio_chip *gc;
-	u32 flags;
-	const void *gpio_spec;
-
-	/* find out root node */
-	root = of_find_node_by_path("/");
-
-	/* give me handle for gpio node to be possible allocate pin */
-	ret = of_parse_phandles_with_args(root, "hard-reset-gpios",
-				"#gpio-cells", 0, &gpio, &gpio_spec);
-	if (ret) {
-		pr_debug("%s: can't parse gpios property\n", __func__);
-		goto err0;
-	}
-
-	gc = of_node_to_gpiochip(gpio);
-	if (!gc) {
-		pr_debug("%s: gpio controller %s isn't registered\n",
-			 root->full_name, gpio->full_name);
-		ret = -ENODEV;
-		goto err1;
-	}
-
-	ret = gc->of_xlate(gc, root, gpio_spec, &flags);
-	if (ret < 0)
-		goto err1;
-
-	ret += gc->base;
-err1:
-	of_node_put(gpio);
-err0:
-	pr_debug("%s exited with status %d\n", __func__, ret);
-	return ret;
-}
-
 void of_platform_reset_gpio_probe(void)
 {
 	int ret;
-	handle = of_reset_gpio_handle();
+	handle = of_get_named_gpio(of_find_node_by_path("/"),
+				   "hard-reset-gpios", 0);
 
 	if (!gpio_is_valid(handle)) {
 		printk(KERN_INFO "Skipping unavailable RESET gpio %d (%s)\n",

commit 594fa265e084073443390c5b93d5410fd28e9bcd
Author: Grant Likely <grant.likely@secretlab.ca>
Date:   Tue Jun 8 07:48:16 2010 -0600

    of/gpio: stop using device_node data pointer to find gpio_chip
    
    Currently the kernel uses the struct device_node.data pointer to resolve
    a struct gpio_chip pointer from a device tree node.  However, the .data
    member doesn't provide any type checking and there aren't any rules
    enforced on what it should be used for.  There's no guarantee that the
    data stored in it actually points to an gpio_chip pointer.
    
    Instead of relying on the .data pointer, this patch modifies the code
    to add a lookup function which scans through the registered gpio_chips
    and returns the gpio_chip that has a pointer to the specified
    device_node.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    CC: Andrew Morton <akpm@linux-foundation.org>
    CC: Anton Vorontsov <avorontsov@ru.mvista.com>
    CC: Grant Likely <grant.likely@secretlab.ca>
    CC: David Brownell <dbrownell@users.sourceforge.net>
    CC: Bill Gatliff <bgat@billgatliff.com>
    CC: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: Jean Delvare <khali@linux-fr.org>
    CC: linux-kernel@vger.kernel.org
    CC: devicetree-discuss@lists.ozlabs.org

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index 5476d3caf045..bd8ccab5ceff 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -39,7 +39,7 @@ static int of_reset_gpio_handle(void)
 		goto err0;
 	}
 
-	gc = gpio->data;
+	gc = of_node_to_gpiochip(gpio);
 	if (!gc) {
 		pr_debug("%s: gpio controller %s isn't registered\n",
 			 root->full_name, gpio->full_name);

commit a19e3da5bc5fc6c10ab73f310bea80f3845b4531
Author: Anton Vorontsov <avorontsov@ru.mvista.com>
Date:   Tue Jun 8 07:48:16 2010 -0600

    of/gpio: Kill of_gpio_chip and add members directly to gpio_chip
    
    The OF gpio infrastructure is great for describing GPIO connections within
    the device tree.  However, using a GPIO binding still requires changes to
    the gpio controller just to add an of_gpio structure.  In most cases, the
    gpio controller doesn't actually need any special support and the simple
    OF gpio mapping function is more than sufficient.  Additional, the current
    scheme of using of_gpio_chip requires a convoluted scheme to maintain
    1:1 mappings between of_gpio_chip and gpio_chip instances.
    
    If the struct of_gpio_chip data members were moved into struct gpio_chip,
    then it would simplify the processing of OF gpio bindings, and it would
    make it trivial to use device tree OF connections on existing gpiolib
    controller drivers.
    
    This patch eliminates the of_gpio_chip structure and moves the relevant
    fields into struct gpio_chip (conditional on CONFIG_OF_GPIO).  This move
    simplifies the existing code and prepares for adding automatic device tree
    support to existing drivers.
    
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Anton Vorontsov <avorontsov@ru.mvista.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Bill Gatliff <bgat@billgatliff.com>
    Cc: Dmitry Eremin-Solenikov <dbaryshkov@gmail.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Jean Delvare <khali@linux-fr.org>

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index a1721a33042e..5476d3caf045 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -24,8 +24,8 @@ static int of_reset_gpio_handle(void)
 	int ret; /* variable which stored handle reset gpio pin */
 	struct device_node *root; /* root node */
 	struct device_node *gpio; /* gpio node */
-	struct of_gpio_chip *of_gc = NULL;
-	enum of_gpio_flags flags ;
+	struct gpio_chip *gc;
+	u32 flags;
 	const void *gpio_spec;
 
 	/* find out root node */
@@ -39,19 +39,19 @@ static int of_reset_gpio_handle(void)
 		goto err0;
 	}
 
-	of_gc = gpio->data;
-	if (!of_gc) {
+	gc = gpio->data;
+	if (!gc) {
 		pr_debug("%s: gpio controller %s isn't registered\n",
 			 root->full_name, gpio->full_name);
 		ret = -ENODEV;
 		goto err1;
 	}
 
-	ret = of_gc->xlate(of_gc, root, gpio_spec, &flags);
+	ret = gc->of_xlate(gc, root, gpio_spec, &flags);
 	if (ret < 0)
 		goto err1;
 
-	ret += of_gc->gc.base;
+	ret += gc->base;
 err1:
 	of_node_put(gpio);
 err0:

commit 67bf87665466c4ea93e2c54d66dfd4cdac011a4b
Author: Michal Simek <monstr@monstr.eu>
Date:   Thu Oct 29 10:12:59 2009 +0100

    microblaze: Support both levels for reset
    
    Till this patch reset always perform writen to 1.
    Now we can use negative logic and perform reset write to 0.
    
    It is opposite level than is currently read from that pin
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index 789af930d72c..a1721a33042e 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -17,6 +17,7 @@
 #include <linux/of_gpio.h>
 
 static int handle; /* reset pin handle */
+static unsigned int reset_val;
 
 static int of_reset_gpio_handle(void)
 {
@@ -75,9 +76,9 @@ void of_platform_reset_gpio_probe(void)
 	}
 
 	/* get current setup value */
-	ret = gpio_get_value(handle);
+	reset_val = gpio_get_value(handle);
 	/* FIXME maybe worth to perform any action */
-	pr_debug("Reset: Gpio output state: 0x%x\n", ret);
+	pr_debug("Reset: Gpio output state: 0x%x\n", reset_val);
 
 	/* Setup GPIO as output */
 	ret = gpio_direction_output(handle, 0);
@@ -87,7 +88,8 @@ void of_platform_reset_gpio_probe(void)
 	/* Setup output direction */
 	gpio_set_value(handle, 0);
 
-	printk(KERN_INFO "RESET: Registered gpio device: %d\n", handle);
+	printk(KERN_INFO "RESET: Registered gpio device: %d, current val: %d\n",
+							handle, reset_val);
 	return;
 err:
 	gpio_free(handle);
@@ -97,7 +99,7 @@ void of_platform_reset_gpio_probe(void)
 
 static void gpio_system_reset(void)
 {
-	gpio_set_value(handle, 1);
+	gpio_set_value(handle, 1 - reset_val);
 }
 #else
 #define gpio_system_reset() do {} while (0)

commit 753758304019fc7c2ef3af674f52a193b1606d15
Author: Michal Simek <monstr@monstr.eu>
Date:   Thu Oct 29 08:58:15 2009 +0100

    microblaze: Fix announce message for reset gpio
    
    I had to change message for gpio-reset because I always
    not to see it. Prefix RESET is big and visible.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
index ce74a6f436e3..789af930d72c 100644
--- a/arch/microblaze/kernel/reset.c
+++ b/arch/microblaze/kernel/reset.c
@@ -87,7 +87,7 @@ void of_platform_reset_gpio_probe(void)
 	/* Setup output direction */
 	gpio_set_value(handle, 0);
 
-	printk(KERN_INFO "Registered reset device: %d\n", handle);
+	printk(KERN_INFO "RESET: Registered gpio device: %d\n", handle);
 	return;
 err:
 	gpio_free(handle);

commit 42a2478b789cb1b4335909e0fecc721c07be7d90
Author: Michal Simek <monstr@monstr.eu>
Date:   Fri Oct 2 12:48:47 2009 +0200

    microblaze: GPIO reset support
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/kernel/reset.c b/arch/microblaze/kernel/reset.c
new file mode 100644
index 000000000000..ce74a6f436e3
--- /dev/null
+++ b/arch/microblaze/kernel/reset.c
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2009 Michal Simek <monstr@monstr.eu>
+ * Copyright (C) 2009 PetaLogix
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#include <linux/init.h>
+#include <linux/of_platform.h>
+#include <asm/prom.h>
+
+/* Trigger specific functions */
+#ifdef CONFIG_GPIOLIB
+
+#include <linux/of_gpio.h>
+
+static int handle; /* reset pin handle */
+
+static int of_reset_gpio_handle(void)
+{
+	int ret; /* variable which stored handle reset gpio pin */
+	struct device_node *root; /* root node */
+	struct device_node *gpio; /* gpio node */
+	struct of_gpio_chip *of_gc = NULL;
+	enum of_gpio_flags flags ;
+	const void *gpio_spec;
+
+	/* find out root node */
+	root = of_find_node_by_path("/");
+
+	/* give me handle for gpio node to be possible allocate pin */
+	ret = of_parse_phandles_with_args(root, "hard-reset-gpios",
+				"#gpio-cells", 0, &gpio, &gpio_spec);
+	if (ret) {
+		pr_debug("%s: can't parse gpios property\n", __func__);
+		goto err0;
+	}
+
+	of_gc = gpio->data;
+	if (!of_gc) {
+		pr_debug("%s: gpio controller %s isn't registered\n",
+			 root->full_name, gpio->full_name);
+		ret = -ENODEV;
+		goto err1;
+	}
+
+	ret = of_gc->xlate(of_gc, root, gpio_spec, &flags);
+	if (ret < 0)
+		goto err1;
+
+	ret += of_gc->gc.base;
+err1:
+	of_node_put(gpio);
+err0:
+	pr_debug("%s exited with status %d\n", __func__, ret);
+	return ret;
+}
+
+void of_platform_reset_gpio_probe(void)
+{
+	int ret;
+	handle = of_reset_gpio_handle();
+
+	if (!gpio_is_valid(handle)) {
+		printk(KERN_INFO "Skipping unavailable RESET gpio %d (%s)\n",
+				handle, "reset");
+	}
+
+	ret = gpio_request(handle, "reset");
+	if (ret < 0) {
+		printk(KERN_INFO "GPIO pin is already allocated\n");
+		return;
+	}
+
+	/* get current setup value */
+	ret = gpio_get_value(handle);
+	/* FIXME maybe worth to perform any action */
+	pr_debug("Reset: Gpio output state: 0x%x\n", ret);
+
+	/* Setup GPIO as output */
+	ret = gpio_direction_output(handle, 0);
+	if (ret < 0)
+		goto err;
+
+	/* Setup output direction */
+	gpio_set_value(handle, 0);
+
+	printk(KERN_INFO "Registered reset device: %d\n", handle);
+	return;
+err:
+	gpio_free(handle);
+	return;
+}
+
+
+static void gpio_system_reset(void)
+{
+	gpio_set_value(handle, 1);
+}
+#else
+#define gpio_system_reset() do {} while (0)
+void of_platform_reset_gpio_probe(void)
+{
+	return;
+}
+#endif
+
+void machine_restart(char *cmd)
+{
+	printk(KERN_NOTICE "Machine restart...\n");
+	gpio_system_reset();
+	dump_stack();
+	while (1)
+		;
+}
+
+void machine_shutdown(void)
+{
+	printk(KERN_NOTICE "Machine shutdown...\n");
+	while (1)
+		;
+}
+
+void machine_halt(void)
+{
+	printk(KERN_NOTICE "Machine halt...\n");
+	while (1)
+		;
+}
+
+void machine_power_off(void)
+{
+	printk(KERN_NOTICE "Machine power off...\n");
+	while (1)
+		;
+}
