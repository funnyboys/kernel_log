commit ca5999fde0a1761665a38e4c9a72dbcd7d190a81
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:38 2020 -0700

    mm: introduce include/linux/pgtable.h
    
    The include/linux/pgtable.h is going to be the home of generic page table
    manipulation functions.
    
    Start with moving asm-generic/pgtable.h to include/linux/pgtable.h and
    make the latter include asm/pgtable.h.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-3-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 070ba6139a62..6723c56ec378 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -12,7 +12,7 @@
 
 #include <asm/mmu.h>
 #include <asm/page.h>
-#include <asm/pgtable.h>
+#include <linux/pgtable.h>
 #include <asm/extable.h>
 #include <linux/string.h>
 

commit a8222fd5b80c7ec83f257060670becbeea9b50b9
Merge: cad18da0afb1 9fd1a1c9b3f2
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 31 09:58:07 2020 -0700

    Merge tag 'microblaze-v5.7-rc1' of git://git.monstr.eu/linux-2.6-microblaze
    
    Pull microblaze updates from Michal Simek:
    
     - convert license headers to SPDX
    
     - cleanup header handling and use asm-generic one
    
     - get rid of earlyprintk residues
    
     - define barriers and use it in the code
    
     - get rid of setup_irq() for timer
    
     - various small addons and fixes
    
    * tag 'microblaze-v5.7-rc1' of git://git.monstr.eu/linux-2.6-microblaze:
      microblaze: Replace setup_irq() by request_irq()
      microblaze: Stop printing the virtual memory layout
      microblaze: Use asm generic cmpxchg.h for !SMP case
      microblaze: Define percpu sestion in linker file
      microblaze: Remove unused boot_cpuid variable
      microblaze: Add missing irqflags.h header
      microblaze: Add sync to tlb operations
      microblaze: Define microblaze barrier
      microblaze: Remove empty headers
      microblaze: Remove early printk setup
      microblaze: Remove architecture tlb.h and use generic one
      microblaze: Convert headers to SPDX license
      microblaze: Fix _reset() function
      microblaze: Kernel parameters should be parsed earlier

commit d964ea7014a9d0d6312ccd5f47088a792371ad0b
Author: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
Date:   Sat Mar 21 12:25:54 2020 +0100

    microblaze: Remove mm.h from asm/uaccess.h
    
    The defconfig compiles without linux/mm.h. With mm.h included the
    include chain leands to:
    |   CC      kernel/locking/percpu-rwsem.o
    | In file included from include/linux/huge_mm.h:8,
    |                  from include/linux/mm.h:567,
    |                  from arch/microblaze/include/asm/uaccess.h:,
    |                  from include/linux/uaccess.h:11,
    |                  from include/linux/sched/task.h:11,
    |                  from include/linux/sched/signal.h:9,
    |                  from include/linux/rcuwait.h:6,
    |                  from include/linux/percpu-rwsem.h:8,
    |                  from kernel/locking/percpu-rwsem.c:6:
    | include/linux/fs.h:1422:29: error: array type has incomplete element type 'struct percpu_rw_semaphore'
    |  1422 |  struct percpu_rw_semaphore rw_sem[SB_FREEZE_LEVELS];
    
    once rcuwait.h includes linux/sched/signal.h.
    
    Remove the linux/mm.h include.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Sebastian Andrzej Siewior <bigeasy@linutronix.de>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Link: https://lkml.kernel.org/r/20200321113241.719022171@linutronix.de

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index a1f206b90753..4916d5fbea5e 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -12,7 +12,6 @@
 #define _ASM_MICROBLAZE_UACCESS_H
 
 #include <linux/kernel.h>
-#include <linux/mm.h>
 
 #include <asm/mmu.h>
 #include <asm/page.h>

commit 4726dd6082bc960a20b761428eafb34b8af075b5
Author: Michal Simek <michal.simek@xilinx.com>
Date:   Mon Feb 3 10:25:40 2020 +0100

    microblaze: Convert headers to SPDX license
    
    Covert all headers to SPDX.
    
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>
    Reviewed-by: Stefan Asserhall <stefan.asserhall@xilinx.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index a1f206b90753..09498fe1ab98 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -1,11 +1,8 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 /*
  * Copyright (C) 2008-2009 Michal Simek <monstr@monstr.eu>
  * Copyright (C) 2008-2009 PetaLogix
  * Copyright (C) 2006 Atmark Techno, Inc.
- *
- * This file is subject to the terms and conditions of the GNU General Public
- * License. See the file "COPYING" in the main directory of this archive
- * for more details.
  */
 
 #ifndef _ASM_MICROBLAZE_UACCESS_H

commit 6a090e97972dc7bb6f2661eda3eabd8ae21e9b6d
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Mon Sep 16 18:39:44 2019 -0700

    arch/microblaze: support get_user() of size 8 bytes
    
    arch/microblaze/ is missing support for get_user() of size 8 bytes,
    so add it by using __copy_from_user().
    
    While there, also drop a lot of the code duplication.
    
    Fixes these build errors:
       drivers/infiniband/core/uverbs_main.o: In function `ib_uverbs_write':
       drivers/infiniband/core/.tmp_gl_uverbs_main.o:(.text+0x13a4): undefined reference to `__user_bad'
       drivers/android/binder.o: In function `binder_thread_write':
       drivers/android/.tmp_gl_binder.o:(.text+0xda6c): undefined reference to `__user_bad'
       drivers/android/.tmp_gl_binder.o:(.text+0xda98): undefined reference to `__user_bad'
       drivers/android/.tmp_gl_binder.o:(.text+0xdf10): undefined reference to `__user_bad'
       drivers/android/.tmp_gl_binder.o:(.text+0xe498): undefined reference to `__user_bad'
       drivers/android/binder.o:drivers/android/.tmp_gl_binder.o:(.text+0xea78): more undefined references to `__user_bad' follow
    
    'make allmodconfig' now builds successfully for arch/microblaze/.
    
    Fixes: 538722ca3b76 ("microblaze: fix get_user/put_user side-effects")
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Al Viro <viro@zeniv.linux.org.uk>
    Cc: Steven J. Magnani <steve@digidescorp.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Jason Gunthorpe <jgg@mellanox.com>
    Cc: Leon Romanovsky <leonro@mellanox.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Doug Ledford <dledford@redhat.com>
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index bff2a71c828a..a1f206b90753 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -163,44 +163,15 @@ extern long __user_bad(void);
  * Returns zero on success, or -EFAULT on error.
  * On error, the variable @x is set to zero.
  */
-#define get_user(x, ptr)						\
-	__get_user_check((x), (ptr), sizeof(*(ptr)))
-
-#define __get_user_check(x, ptr, size)					\
-({									\
-	unsigned long __gu_val = 0;					\
-	const typeof(*(ptr)) __user *__gu_addr = (ptr);			\
-	int __gu_err = 0;						\
-									\
-	if (access_ok(__gu_addr, size)) {			\
-		switch (size) {						\
-		case 1:							\
-			__get_user_asm("lbu", __gu_addr, __gu_val,	\
-				       __gu_err);			\
-			break;						\
-		case 2:							\
-			__get_user_asm("lhu", __gu_addr, __gu_val,	\
-				       __gu_err);			\
-			break;						\
-		case 4:							\
-			__get_user_asm("lw", __gu_addr, __gu_val,	\
-				       __gu_err);			\
-			break;						\
-		default:						\
-			__gu_err = __user_bad();			\
-			break;						\
-		}							\
-	} else {							\
-		__gu_err = -EFAULT;					\
-	}								\
-	x = (__force typeof(*(ptr)))__gu_val;				\
-	__gu_err;							\
+#define get_user(x, ptr) ({				\
+	const typeof(*(ptr)) __user *__gu_ptr = (ptr);	\
+	access_ok(__gu_ptr, sizeof(*__gu_ptr)) ?	\
+		__get_user(x, __gu_ptr) : -EFAULT;	\
 })
 
 #define __get_user(x, ptr)						\
 ({									\
 	unsigned long __gu_val = 0;					\
-	/*unsigned long __gu_ptr = (unsigned long)(ptr);*/		\
 	long __gu_err;							\
 	switch (sizeof(*(ptr))) {					\
 	case 1:								\
@@ -212,6 +183,11 @@ extern long __user_bad(void);
 	case 4:								\
 		__get_user_asm("lw", (ptr), __gu_val, __gu_err);	\
 		break;							\
+	case 8:								\
+		__gu_err = __copy_from_user(&__gu_val, ptr, 8);		\
+		if (__gu_err)						\
+			__gu_err = -EFAULT;				\
+		break;							\
 	default:							\
 		/* __gu_val = 0; __gu_err = -EINVAL;*/ __gu_err = __user_bad();\
 	}								\

commit 736706bee3298208343a76096370e4f6a5c55915
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 4 10:39:05 2019 -0800

    get rid of legacy 'get_ds()' function
    
    Every in-kernel use of this function defined it to KERNEL_DS (either as
    an actual define, or as an inline function).  It's an entirely
    historical artifact, and long long long ago used to actually read the
    segment selector valueof '%ds' on x86.
    
    Which in the kernel is always KERNEL_DS.
    
    Inspired by a patch from Jann Horn that just did this for a very small
    subset of users (the ones in fs/), along with Al who suggested a script.
    I then just took it to the logical extreme and removed all the remaining
    gunk.
    
    Roughly scripted with
    
       git grep -l '(get_ds())' -- :^tools/ | xargs sed -i 's/(get_ds())/(KERNEL_DS)/'
       git grep -lw 'get_ds' -- :^tools/ | xargs sed -i '/^#define get_ds()/d'
    
    plus manual fixups to remove a few unusual usage patterns, the couple of
    inline function cases and to fix up a comment that had become stale.
    
    The 'get_ds()' function remains in an x86 kvm selftest, since in user
    space it actually does something relevant.
    
    Inspired-by: Jann Horn <jannh@google.com>
    Inspired-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index dbfea093a7c7..bff2a71c828a 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -42,7 +42,6 @@
 #  define USER_DS	MAKE_MM_SEG(TASK_SIZE - 1)
 #  endif
 
-# define get_ds()	(KERNEL_DS)
 # define get_fs()	(current_thread_info()->addr_limit)
 # define set_fs(val)	(current_thread_info()->addr_limit = (val))
 

commit 96d4f267e40f9509e8a66e2b39e8b95655617693
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jan 3 18:57:57 2019 -0800

    Remove 'type' argument from access_ok() function
    
    Nobody has actually used the type (VERIFY_READ vs VERIFY_WRITE) argument
    of the user address range verification function since we got rid of the
    old racy i386-only code to walk page tables by hand.
    
    It existed because the original 80386 would not honor the write protect
    bit when in kernel mode, so you had to do COW by hand before doing any
    user access.  But we haven't supported that in a long time, and these
    days the 'type' argument is a purely historical artifact.
    
    A discussion about extending 'user_access_begin()' to do the range
    checking resulted this patch, because there is no way we're going to
    move the old VERIFY_xyz interface to that model.  And it's best done at
    the end of the merge window when I've done most of my merges, so let's
    just get this done once and for all.
    
    This patch was mostly done with a sed-script, with manual fix-ups for
    the cases that weren't of the trivial 'access_ok(VERIFY_xyz' form.
    
    There were a couple of notable cases:
    
     - csky still had the old "verify_area()" name as an alias.
    
     - the iter_iov code had magical hardcoded knowledge of the actual
       values of VERIFY_{READ,WRITE} (not that they mattered, since nothing
       really used it)
    
     - microblaze used the type argument for a debug printout
    
    but other than those oddities this should be a total no-op patch.
    
    I tried to fix up all architectures, did fairly extensive grepping for
    access_ok() uses, and the changes are trivial, but I may have missed
    something.  Any missed conversion should be trivially fixable, though.
    
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 81f16aadbf9e..dbfea093a7c7 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -60,26 +60,25 @@ static inline int ___range_ok(unsigned long addr, unsigned long size)
 #define __range_ok(addr, size) \
 		___range_ok((unsigned long)(addr), (unsigned long)(size))
 
-#define access_ok(type, addr, size) (__range_ok((addr), (size)) == 0)
+#define access_ok(addr, size) (__range_ok((addr), (size)) == 0)
 
 #else
 
-static inline int access_ok(int type, const void __user *addr,
-							unsigned long size)
+static inline int access_ok(const void __user *addr, unsigned long size)
 {
 	if (!size)
 		goto ok;
 
 	if ((get_fs().seg < ((unsigned long)addr)) ||
 			(get_fs().seg < ((unsigned long)addr + size - 1))) {
-		pr_devel("ACCESS fail: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
-			type ? "WRITE" : "READ ", (__force u32)addr, (u32)size,
+		pr_devel("ACCESS fail at 0x%08x (size 0x%x), seg 0x%08x\n",
+			(__force u32)addr, (u32)size,
 			(u32)get_fs().seg);
 		return 0;
 	}
 ok:
-	pr_devel("ACCESS OK: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
-			type ? "WRITE" : "READ ", (__force u32)addr, (u32)size,
+	pr_devel("ACCESS OK at 0x%08x (size 0x%x), seg 0x%08x\n",
+			(__force u32)addr, (u32)size,
 			(u32)get_fs().seg);
 	return 1;
 }
@@ -120,7 +119,7 @@ static inline unsigned long __must_check clear_user(void __user *to,
 							unsigned long n)
 {
 	might_fault();
-	if (unlikely(!access_ok(VERIFY_WRITE, to, n)))
+	if (unlikely(!access_ok(to, n)))
 		return n;
 
 	return __clear_user(to, n);
@@ -174,7 +173,7 @@ extern long __user_bad(void);
 	const typeof(*(ptr)) __user *__gu_addr = (ptr);			\
 	int __gu_err = 0;						\
 									\
-	if (access_ok(VERIFY_READ, __gu_addr, size)) {			\
+	if (access_ok(__gu_addr, size)) {			\
 		switch (size) {						\
 		case 1:							\
 			__get_user_asm("lbu", __gu_addr, __gu_val,	\
@@ -286,7 +285,7 @@ extern long __user_bad(void);
 	typeof(*(ptr)) __user *__pu_addr = (ptr);			\
 	int __pu_err = 0;						\
 									\
-	if (access_ok(VERIFY_WRITE, __pu_addr, size)) {			\
+	if (access_ok(__pu_addr, size)) {			\
 		switch (size) {						\
 		case 1:							\
 			__put_user_asm("sb", __pu_addr, __pu_val,	\
@@ -358,7 +357,7 @@ extern int __strncpy_user(char *to, const char __user *from, int len);
 static inline long
 strncpy_from_user(char *dst, const char __user *src, long count)
 {
-	if (!access_ok(VERIFY_READ, src, 1))
+	if (!access_ok(src, 1))
 		return -EFAULT;
 	return __strncpy_user(dst, src, count);
 }
@@ -372,7 +371,7 @@ extern int __strnlen_user(const char __user *sstr, int len);
 
 static inline long strnlen_user(const char __user *src, long n)
 {
-	if (!access_ok(VERIFY_READ, src, 1))
+	if (!access_ok(src, 1))
 		return 0;
 	return __strnlen_user(src, n);
 }

commit 10503bf9435f304b7a74ebfdb8571dec001d751c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Apr 7 17:54:24 2017 -0400

    get rid of unused __strncpy_from_user() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 38f2c9ccef10..81f16aadbf9e 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -355,14 +355,12 @@ raw_copy_to_user(void __user *to, const void *from, unsigned long n)
  */
 extern int __strncpy_user(char *to, const char __user *from, int len);
 
-#define __strncpy_from_user	__strncpy_user
-
 static inline long
 strncpy_from_user(char *dst, const char __user *src, long count)
 {
 	if (!access_ok(VERIFY_READ, src, 1))
 		return -EFAULT;
-	return __strncpy_from_user(dst, src, count);
+	return __strncpy_user(dst, src, count);
 }
 
 /*

commit d491afb8654e84f972ed00cb0e087ad2fae5a1ac
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Mar 21 12:10:12 2017 -0400

    microblaze: switch to RAW_COPY_USER
    
    [kudos to Piotr Sroka for spotting a braino in the previous variant]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 2c39375ac871..38f2c9ccef10 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -336,39 +336,19 @@ extern long __user_bad(void);
 	__gu_err;							\
 })
 
-
-/* copy_to_from_user */
-#define __copy_from_user(to, from, n)	\
-	__copy_tofrom_user((__force void __user *)(to), \
-				(void __user *)(from), (n))
-#define __copy_from_user_inatomic(to, from, n) \
-		__copy_from_user((to), (from), (n))
-
-static inline long copy_from_user(void *to,
-		const void __user *from, unsigned long n)
+static inline unsigned long
+raw_copy_from_user(void *to, const void __user *from, unsigned long n)
 {
-	unsigned long res = n;
-	might_fault();
-	if (likely(access_ok(VERIFY_READ, from, n)))
-		res = __copy_from_user(to, from, n);
-	if (unlikely(res))
-		memset(to + (n - res), 0, res);
-	return res;
+	return __copy_tofrom_user((__force void __user *)to, from, n);
 }
 
-#define __copy_to_user(to, from, n)	\
-		__copy_tofrom_user((void __user *)(to), \
-			(__force const void __user *)(from), (n))
-#define __copy_to_user_inatomic(to, from, n) __copy_to_user((to), (from), (n))
-
-static inline long copy_to_user(void __user *to,
-		const void *from, unsigned long n)
+static inline unsigned long
+raw_copy_to_user(void __user *to, const void *from, unsigned long n)
 {
-	might_fault();
-	if (access_ok(VERIFY_WRITE, to, n))
-		return __copy_to_user(to, from, n);
-	return n;
+	return __copy_tofrom_user(to, (__force const void __user *)from, n);
 }
+#define INLINE_COPY_FROM_USER
+#define INLINE_COPY_TO_USER
 
 /*
  * Copy a null terminated string from userspace.

commit 730132e7e52210cbbfa95af67f5e23a63199c13d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Dec 25 14:34:44 2016 -0500

    microblaze: switch to generic extable.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index b132cd301e66..2c39375ac871 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -17,6 +17,7 @@
 #include <asm/mmu.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
+#include <asm/extable.h>
 #include <linux/string.h>
 
 /*
@@ -47,22 +48,6 @@
 
 # define segment_eq(a, b)	((a).seg == (b).seg)
 
-/*
- * The exception table consists of pairs of addresses: the first is the
- * address of an instruction that is allowed to fault, and the second is
- * the address at which the program should continue. No registers are
- * modified, so it is entirely up to the continuation code to figure out
- * what to do.
- *
- * All the routines below use bits of fixup code that are out of line
- * with the main instruction path. This means when everything is well,
- * we don't even have to jump over them. Further, they do not intrude
- * on our cache or tlb entries.
- */
-struct exception_table_entry {
-	unsigned long insn, fixup;
-};
-
 #ifndef CONFIG_MMU
 
 /* Check against bounds of physical memory */

commit 444f02c458db00bd6049cc1bfe4254e80f57459e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 27 18:19:09 2016 -0500

    uaccess: drop pointless ifdefs
    
    None of those file is ever included from uapi stuff, so __KERNEL__
    is always defined.  None of them is ever included from assembler
    (they are only pulled from linux/uaccess.h, which _can't_ be
    included from assembler), so __ASSEMBLY__ is never defined.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index a3c0a06d7848..b132cd301e66 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -11,9 +11,6 @@
 #ifndef _ASM_MICROBLAZE_UACCESS_H
 #define _ASM_MICROBLAZE_UACCESS_H
 
-#ifdef __KERNEL__
-#ifndef __ASSEMBLY__
-
 #include <linux/kernel.h>
 #include <linux/mm.h>
 
@@ -417,7 +414,4 @@ static inline long strnlen_user(const char __user *src, long n)
 	return __strnlen_user(src, n);
 }
 
-#endif  /* __ASSEMBLY__ */
-#endif /* __KERNEL__ */
-
 #endif /* _ASM_MICROBLAZE_UACCESS_H */

commit af1d5b37d6211c814fac0d5d0b71ec695618054a
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 27 18:14:09 2016 -0500

    uaccess: drop duplicate includes from asm/uaccess.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 70cf5f3dfae3..a3c0a06d7848 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -15,8 +15,6 @@
 #ifndef __ASSEMBLY__
 
 #include <linux/kernel.h>
-#include <linux/errno.h>
-#include <linux/sched.h> /* RLIMIT_FSIZE */
 #include <linux/mm.h>
 
 #include <asm/mmu.h>

commit 5e6039d8a307d8411422c154f3d446b44fa32b6d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Dec 27 18:00:15 2016 -0500

    uaccess: move VERIFY_{READ,WRITE} definitions to linux/uaccess.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 253a67e275ad..70cf5f3dfae3 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -24,9 +24,6 @@
 #include <asm/pgtable.h>
 #include <linux/string.h>
 
-#define VERIFY_READ	0
-#define VERIFY_WRITE	1
-
 /*
  * On Microblaze the fs value is actually the top of the corresponding
  * address space.

commit df720ac12fc76d235a1b0d7ebccd14b23085c24e
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Aug 12 18:47:45 2016 -0400

    exceptions: detritus removal
    
    externs and defines for stuff that is never used
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 826676778094..253a67e275ad 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -71,9 +71,6 @@ struct exception_table_entry {
 	unsigned long insn, fixup;
 };
 
-/* Returns 0 if exception not found and fixup otherwise.  */
-extern unsigned long search_exception_table(unsigned long);
-
 #ifndef CONFIG_MMU
 
 /* Check against bounds of physical memory */

commit e98b9e37ae04562d52c96f46b3cf4c2e80222dc1
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Sep 9 19:23:33 2016 -0400

    microblaze: fix __get_user()
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 3a486d3b6f52..826676778094 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -227,7 +227,7 @@ extern long __user_bad(void);
 
 #define __get_user(x, ptr)						\
 ({									\
-	unsigned long __gu_val;						\
+	unsigned long __gu_val = 0;					\
 	/*unsigned long __gu_ptr = (unsigned long)(ptr);*/		\
 	long __gu_err;							\
 	switch (sizeof(*(ptr))) {					\

commit d0cf385160c12abd109746cad1f13e3b3e8b50b8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Sep 9 19:22:34 2016 -0400

    microblaze: fix copy_from_user()
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 331b0d35f89c..3a486d3b6f52 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -373,10 +373,13 @@ extern long __user_bad(void);
 static inline long copy_from_user(void *to,
 		const void __user *from, unsigned long n)
 {
+	unsigned long res = n;
 	might_fault();
-	if (access_ok(VERIFY_READ, from, n))
-		return __copy_from_user(to, from, n);
-	return n;
+	if (likely(access_ok(VERIFY_READ, from, n)))
+		res = __copy_from_user(to, from, n);
+	if (unlikely(res))
+		memset(to + (n - res), 0, res);
+	return res;
 }
 
 #define __copy_to_user(to, from, n)	\

commit b3c395ef5556a6c60f4426cc060f5b7bdcf82d5b
Author: David Hildenbrand <dahi@linux.vnet.ibm.com>
Date:   Mon May 11 17:52:08 2015 +0200

    mm/uaccess, mm/fault: Clarify that uaccess may only sleep if pagefaults are enabled
    
    In general, non-atomic variants of user access functions must not sleep
    if pagefaults are disabled.
    
    Let's update all relevant comments in uaccess code. This also reflects
    the might_sleep() checks in might_fault().
    
    Reviewed-and-tested-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: David Hildenbrand <dahi@linux.vnet.ibm.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: David.Laight@ACULAB.COM
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: airlied@linux.ie
    Cc: akpm@linux-foundation.org
    Cc: benh@kernel.crashing.org
    Cc: bigeasy@linutronix.de
    Cc: borntraeger@de.ibm.com
    Cc: daniel.vetter@intel.com
    Cc: heiko.carstens@de.ibm.com
    Cc: herbert@gondor.apana.org.au
    Cc: hocko@suse.cz
    Cc: hughd@google.com
    Cc: mst@redhat.com
    Cc: paulus@samba.org
    Cc: ralf@linux-mips.org
    Cc: schwidefsky@de.ibm.com
    Cc: yang.shi@windriver.com
    Link: http://lkml.kernel.org/r/1431359540-32227-4-git-send-email-dahi@linux.vnet.ibm.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 62942fd12672..331b0d35f89c 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -178,7 +178,8 @@ extern long __user_bad(void);
  * @x:   Variable to store result.
  * @ptr: Source address, in user space.
  *
- * Context: User context only.  This function may sleep.
+ * Context: User context only. This function may sleep if pagefaults are
+ *          enabled.
  *
  * This macro copies a single simple variable from user space to kernel
  * space.  It supports simple types like char and int, but not larger
@@ -290,7 +291,8 @@ extern long __user_bad(void);
  * @x:   Value to copy to user space.
  * @ptr: Destination address, in user space.
  *
- * Context: User context only.  This function may sleep.
+ * Context: User context only. This function may sleep if pagefaults are
+ *          enabled.
  *
  * This macro copies a single simple value from kernel space to user
  * space.  It supports simple types like char and int, but not larger

commit 132d5dfc04698e4226ca9787214bd4e277ed39f2
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Tue Jan 6 17:45:03 2015 +0200

    microblaze: whitespace fix
    
    Align using tabs to make code prettier.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index e41bebf8d473..62942fd12672 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -306,7 +306,7 @@ extern long __user_bad(void);
 
 #define __put_user_check(x, ptr, size)					\
 ({									\
-	typeof(*(ptr)) volatile __pu_val = x;					\
+	typeof(*(ptr)) volatile __pu_val = x;				\
 	typeof(*(ptr)) __user *__pu_addr = (ptr);			\
 	int __pu_err = 0;						\
 									\

commit 0774bf6a8b49ccd35fad58a1eed0d2382f34912e
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Tue Jan 6 17:44:02 2015 +0200

    microblaze/uaccess: fix sparse errors
    
    virtio wants to read bitwise types from userspace using get_user.  At the
    moment this triggers sparse errors, since the value is passed through an
    integer.
    
    Fix that up using __force.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 59a89a64a865..e41bebf8d473 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -220,7 +220,7 @@ extern long __user_bad(void);
 	} else {							\
 		__gu_err = -EFAULT;					\
 	}								\
-	x = (typeof(*(ptr)))__gu_val;					\
+	x = (__force typeof(*(ptr)))__gu_val;				\
 	__gu_err;							\
 })
 
@@ -242,7 +242,7 @@ extern long __user_bad(void);
 	default:							\
 		/* __gu_val = 0; __gu_err = -EINVAL;*/ __gu_err = __user_bad();\
 	}								\
-	x = (__typeof__(*(ptr))) __gu_val;				\
+	x = (__force __typeof__(*(ptr))) __gu_val;			\
 	__gu_err;							\
 })
 

commit de295cf0dbed54d732a23dd0f048c89538d80222
Author: Chen Gang <gang.chen.5i5j@gmail.com>
Date:   Wed Aug 6 00:25:52 2014 +0800

    arch/microblaze/include/asm/uaccess.h: Use pr_devel() instead of pr_debug()
    
    When DYNAMIC_DEBUG enabled, pr_debug() depends on KBUILD_MODNAME which
    also depends on the modules number in Makefile. The related information
    in "scripts/Makefile.lib" line 94:
    
      # $(modname_flags) #defines KBUILD_MODNAME as the name of the module it will
      # end up in (or would, if it gets compiled in)
      # Note: Files that end up in two or more modules are compiled without the
      #       KBUILD_MODNAME definition. The reason is that any made-up name would
      #       differ in different configs.
    
    For this case, 'radio-si470x-i2c.o' and 'radio-si470x-common.o' are in
    one line, so cause compiling issue. And 'uaccess.h' is a common shared
    header (not specially for drivers), so use pr_devel() instead of is OK.
    
    The related error with allmodconfig:
    
        CC [M]  drivers/media/radio/si470x/radio-si470x-i2c.o
        CC [M]  drivers/media/radio/si470x/radio-si470x-common.o
      In file included from include/linux/printk.h:257:0,
                       from include/linux/kernel.h:13,
                       from drivers/media/radio/si470x/radio-si470x.h:29,
                       from drivers/media/radio/si470x/radio-si470x-common.c:115:
      ./arch/microblaze/include/asm/uaccess.h: In function 'access_ok':
      include/linux/dynamic_debug.h:66:14: error: 'KBUILD_MODNAME' undeclared (first use in this function)
         .modname = KBUILD_MODNAME,   \
                    ^
      include/linux/dynamic_debug.h:76:2: note: in expansion of macro 'DEFINE_DYNAMIC_DEBUG_METADATA'
        DEFINE_DYNAMIC_DEBUG_METADATA(descriptor, fmt);  \
        ^
      include/linux/printk.h:263:2: note: in expansion of macro 'dynamic_pr_debug'
        dynamic_pr_debug(fmt, ##__VA_ARGS__)
        ^
      ./arch/microblaze/include/asm/uaccess.h:101:3: note: in expansion of macro 'pr_debug'
         pr_debug("ACCESS fail: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
         ^
    
    Signed-off-by: Chen Gang <gang.chen.5i5j@gmail.com>
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 0aa005703a0b..59a89a64a865 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -98,13 +98,13 @@ static inline int access_ok(int type, const void __user *addr,
 
 	if ((get_fs().seg < ((unsigned long)addr)) ||
 			(get_fs().seg < ((unsigned long)addr + size - 1))) {
-		pr_debug("ACCESS fail: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
+		pr_devel("ACCESS fail: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
 			type ? "WRITE" : "READ ", (__force u32)addr, (u32)size,
 			(u32)get_fs().seg);
 		return 0;
 	}
 ok:
-	pr_debug("ACCESS OK: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
+	pr_devel("ACCESS OK: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
 			type ? "WRITE" : "READ ", (__force u32)addr, (u32)size,
 			(u32)get_fs().seg);
 	return 1;

commit e13053f50664d3d614bbc9b8c83abdad979ac7c9
Merge: 2d722f6d5671 662bbcb2747c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 2 16:19:24 2013 -0700

    Merge branch 'sched-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip
    
    Pull voluntary preemption fixes from Ingo Molnar:
     "This tree contains a speedup which is achieved through better
      might_sleep()/might_fault() preemption point annotations for uaccess
      functions, by Michael S Tsirkin:
    
      1. The only reason uaccess routines might sleep is if they fault.
         Make this explicit for all architectures.
    
      2. A voluntary preemption point in uaccess functions means compiler
         can't inline them efficiently, this breaks assumptions that they
         are very fast and small that e.g.  net code seems to make.  Remove
         this preemption point so behaviour matches with what callers
         assume.
    
      3. Accesses (e.g through socket ops) to kernel memory with KERNEL_DS
         like net/sunrpc does will never sleep.  Remove an unconditinal
         might_sleep() in the might_fault() inline in kernel.h (used when
         PROVE_LOCKING is not set).
    
      4. Accesses with pagefault_disable() return EFAULT but won't cause
         caller to sleep.  Check for that and thus avoid might_sleep() when
         PROVE_LOCKING is set.
    
      These changes offer a nice speedup for CONFIG_PREEMPT_VOLUNTARY=y
      kernels, here's a network bandwidth measurement between a virtual
      machine and the host:
    
       before:
            incoming: 7122.77   Mb/s
            outgoing: 8480.37   Mb/s
    
       after:
            incoming: 8619.24   Mb/s   [ +21.0% ]
            outgoing: 9455.42   Mb/s   [ +11.5% ]
    
      I kept these changes in a separate tree, separate from scheduler
      changes, because it's a mixed MM and scheduler topic"
    
    * 'sched-mm-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      mm, sched: Allow uaccess in atomic with pagefault_disable()
      mm, sched: Drop voluntary schedule from might_fault()
      x86: uaccess s/might_sleep/might_fault/
      tile: uaccess s/might_sleep/might_fault/
      powerpc: uaccess s/might_sleep/might_fault/
      mn10300: uaccess s/might_sleep/might_fault/
      microblaze: uaccess s/might_sleep/might_fault/
      m32r: uaccess s/might_sleep/might_fault/
      frv: uaccess s/might_sleep/might_fault/
      arm64: uaccess s/might_sleep/might_fault/
      asm-generic: uaccess s/might_sleep/might_fault/

commit 8706a6b6303dd75c7ee2baf2161de0f5a2fbdd8b
Author: Michal Simek <michal.simek@xilinx.com>
Date:   Thu May 30 15:10:52 2013 +0200

    microblaze: Fix sparse warnings
    
    arch/microblaze/include/asm/uaccess.h:101:3:
     warning: cast removes address space of expression
    arch/microblaze/include/asm/uaccess.h:107:2:
     warning: cast removes address space of expression
    
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index efe59d881789..04e49553bdf9 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -99,13 +99,13 @@ static inline int access_ok(int type, const void __user *addr,
 	if ((get_fs().seg < ((unsigned long)addr)) ||
 			(get_fs().seg < ((unsigned long)addr + size - 1))) {
 		pr_debug("ACCESS fail: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
-			type ? "WRITE" : "READ ", (u32)addr, (u32)size,
+			type ? "WRITE" : "READ ", (__force u32)addr, (u32)size,
 			(u32)get_fs().seg);
 		return 0;
 	}
 ok:
 	pr_debug("ACCESS OK: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
-			type ? "WRITE" : "READ ", (u32)addr, (u32)size,
+			type ? "WRITE" : "READ ", (__force u32)addr, (u32)size,
 			(u32)get_fs().seg);
 	return 1;
 }

commit ac093f8d5e76be1f2654acfd7a59d339ba037654
Author: Michael S. Tsirkin <mst@redhat.com>
Date:   Sun May 26 17:30:56 2013 +0300

    microblaze: uaccess s/might_sleep/might_fault/
    
    The only reason uaccess routines might sleep
    is if they fault. Make this explicit.
    
    Signed-off-by: Michael S. Tsirkin <mst@redhat.com>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/r/1369577426-26721-5-git-send-email-mst@redhat.com
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index efe59d881789..2fc8bf7bcdd0 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -145,7 +145,7 @@ static inline unsigned long __must_check __clear_user(void __user *to,
 static inline unsigned long __must_check clear_user(void __user *to,
 							unsigned long n)
 {
-	might_sleep();
+	might_fault();
 	if (unlikely(!access_ok(VERIFY_WRITE, to, n)))
 		return n;
 
@@ -371,7 +371,7 @@ extern long __user_bad(void);
 static inline long copy_from_user(void *to,
 		const void __user *from, unsigned long n)
 {
-	might_sleep();
+	might_fault();
 	if (access_ok(VERIFY_READ, from, n))
 		return __copy_from_user(to, from, n);
 	return n;
@@ -385,7 +385,7 @@ static inline long copy_from_user(void *to,
 static inline long copy_to_user(void __user *to,
 		const void *from, unsigned long n)
 {
-	might_sleep();
+	might_fault();
 	if (access_ok(VERIFY_WRITE, to, n))
 		return __copy_to_user(to, from, n);
 	return n;

commit f663b60f5215b44d147ee0c07d17ffd7e9f3f881
Author: Michal Simek <michal.simek@xilinx.com>
Date:   Thu Mar 28 16:42:44 2013 +0100

    microblaze: Fix uaccess_ok macro
    
    Fix access_ok macro no to permit
    case where user will try to access
    the last address space which is equal
    to segment address.
    
    Example:
    segment addr = 0xbfff ffff
    address = 0xbfff fff0
    size = 0x10
    
    Current wrong implementation
    0xbfff ffff >= (0xbfff fff0 | 0x10 | (0xbfff fff0 + 0x10))
    0xbfff ffff >= (0xbfff fff0        | 0xc000 0000)
    0xbfff ffff >= 0xf000 0000
    return 0 which is access failed even the combination is valid.
    because get_fs().seq returns the last valid address.
    
    This patch fix this problem.
    
    Size equals to zero is valid access.
    
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index a1ab5f0009ef..efe59d881789 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -90,17 +90,25 @@ static inline int ___range_ok(unsigned long addr, unsigned long size)
 
 #else
 
-/*
- * Address is valid if:
- *  - "addr", "addr + size" and "size" are all below the limit
- */
-#define access_ok(type, addr, size) \
-	(get_fs().seg >= (((unsigned long)(addr)) | \
-		(size) | ((unsigned long)(addr) + (size))))
-
-/* || printk("access_ok failed for %s at 0x%08lx (size %d), seg 0x%08x\n",
- type?"WRITE":"READ",addr,size,get_fs().seg)) */
-
+static inline int access_ok(int type, const void __user *addr,
+							unsigned long size)
+{
+	if (!size)
+		goto ok;
+
+	if ((get_fs().seg < ((unsigned long)addr)) ||
+			(get_fs().seg < ((unsigned long)addr + size - 1))) {
+		pr_debug("ACCESS fail: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
+			type ? "WRITE" : "READ ", (u32)addr, (u32)size,
+			(u32)get_fs().seg);
+		return 0;
+	}
+ok:
+	pr_debug("ACCESS OK: %s at 0x%08x (size 0x%x), seg 0x%08x\n",
+			type ? "WRITE" : "READ ", (u32)addr, (u32)size,
+			(u32)get_fs().seg);
+	return 1;
+}
 #endif
 
 #ifdef CONFIG_MMU

commit 7e278157921f95d7313ede005cb07b72b7011962
Author: Michal Simek <michal.simek@xilinx.com>
Date:   Fri Dec 21 10:53:40 2012 +0100

    microblaze: Change section flags for noMMU
    
    All files which uses user unified macros from uaccess.h
    (get_user/put_user/clear_user/copy_tofrom_user/
    strnlen_user and strncpy_user) generate this
    warning messages:
    Assembler messages:
    Warning: ignoring changed section attributes for .discard
    
    Setting up discard executable section flang for __EX_TABLE_SECTION
    macro removed all these warnings.
    
    Signed-off-by: Michal Simek <michal.simek@xilinx.com>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 927540d3cb7d..a1ab5f0009ef 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -108,7 +108,7 @@ static inline int ___range_ok(unsigned long addr, unsigned long size)
 # define __EX_TABLE_SECTION	".section __ex_table,\"a\"\n"
 #else
 # define __FIXUP_SECTION	".section .discard,\"ax\"\n"
-# define __EX_TABLE_SECTION	".section .discard,\"a\"\n"
+# define __EX_TABLE_SECTION	".section .discard,\"ax\"\n"
 #endif
 
 extern unsigned long __copy_tofrom_user(void __user *to,

commit bf0e12c753ee71fa9fcb1210e5b961ba1df7981f
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Oct 15 11:49:22 2012 +0200

    microblaze: uaccess.h: Fix timerfd syscall
    
    __pu_val must be volatile to ensure that the value is not lost.
    
    It was causing the problem with timerfd syscall
    where using inline asm at the end of function call doesn't
    save u64 bit value to the stack.
    In comparison both cases you can find out this fragment
    where you can see the first part which is saved u64
    value to stack and then using it in __put_user_asm_8 macro.
    Origin broken implementation misses the first two swi instructions.
    
            swi     r22, r1, 28 /* missing without volatile */
            swi     r23, r1, 32
    ...
            addik   r4, r1, 28
            lwi     r3, r4, 0
            swi     r3, r25, 0
            lwi     r3, r4, 4
            swi     r3, r25, 4
            addk    r3, r0, r0
    
    NOTE: Moving __put_val initialization after declaration
    has not impact on this bug. It is just coding style issue.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index ef25f7538d4a..927540d3cb7d 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -298,11 +298,10 @@ extern long __user_bad(void);
 
 #define __put_user_check(x, ptr, size)					\
 ({									\
-	typeof(*(ptr)) __pu_val;					\
+	typeof(*(ptr)) volatile __pu_val = x;					\
 	typeof(*(ptr)) __user *__pu_addr = (ptr);			\
 	int __pu_err = 0;						\
 									\
-	__pu_val = (x);							\
 	if (access_ok(VERIFY_WRITE, __pu_addr, size)) {			\
 		switch (size) {						\
 		case 1:							\

commit 83a92529c1789f86481190743a6bb09f31ec39a8
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Dec 19 13:46:35 2011 +0100

    microblaze: mm: Fix lowmem max memory size limits
    
    Use CONFIG_LOWMEM_SIZE if system has larger ram size.
    For system with larger ram size, enable HIGMEM support.
    
    Also setup limitation for memblock and use memblock
    allocation in lowmem region.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 072b0077abf9..ef25f7538d4a 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -80,7 +80,7 @@ extern unsigned long search_exception_table(unsigned long);
 static inline int ___range_ok(unsigned long addr, unsigned long size)
 {
 	return ((addr < memory_start) ||
-		((addr + size) > memory_end));
+		((addr + size - 1) > (memory_start + memory_size - 1)));
 }
 
 #define __range_ok(addr, size) \

commit 41b7602ed17a6bbb3b3d33087c39ef5c3a5589c7
Author: Michal Simek <monstr@monstr.eu>
Date:   Thu Jul 28 15:23:37 2011 +0200

    microblaze: Fix access_ok macro
    
    There is the problem with bit OR (|) because for
    some combination is addr | size | addr+size equal
    to seq.
    
    For standard kernel setting (kernel starts at 0xC0000000)
    is seq for user space 0xBFFFFFFF and everything below
    this limit is fine.
    
    But even address 0xBFFFFFFF is fine because it
    is below kernel space.
    
    Signed-off-by: Andrew Fedonczuk <andrew.fedonczuk@ericsson.com>
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 5bb95a11880d..072b0077abf9 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -95,7 +95,7 @@ static inline int ___range_ok(unsigned long addr, unsigned long size)
  *  - "addr", "addr + size" and "size" are all below the limit
  */
 #define access_ok(type, addr, size) \
-	(get_fs().seg > (((unsigned long)(addr)) | \
+	(get_fs().seg >= (((unsigned long)(addr)) | \
 		(size) | ((unsigned long)(addr) + (size))))
 
 /* || printk("access_ok failed for %s at 0x%08lx (size %d), seg 0x%08x\n",

commit 6f3946b421395ff853bc0bcdab9c26b50ebbba8f
Author: Steven J. Magnani <steve@digidescorp.com>
Date:   Thu Feb 10 12:12:13 2011 -0600

    microblaze: Fix /dev/zero corruption from __clear_user()
    
    A userland read of more than PAGE_SIZE bytes from /dev/zero results in
    (a) not all of the bytes returned being zero, and
    (b) memory corruption due to zeroing of bytes beyond the user buffer.
    
    This is caused by improper constraints on the assembly __clear_user function.
    The constrints don't indicate to the compiler that the pointer argument is
    modified. Since the function is inline, this results in double-incrementing
    of the pointer when __clear_user() is invoked through a multi-page read() of
    /dev/zero.
    
    Signed-off-by: Steven J. Magnani <steve@digidescorp.com>
    Acked-by: Michal Simek <monstr@monstr.eu>
    CC: stable@kernel.org

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index d840f4a2d3c9..5bb95a11880d 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -120,16 +120,16 @@ static inline unsigned long __must_check __clear_user(void __user *to,
 {
 	/* normal memset with two words to __ex_table */
 	__asm__ __volatile__ (				\
-			"1:	sb	r0, %2, r0;"	\
+			"1:	sb	r0, %1, r0;"	\
 			"	addik	%0, %0, -1;"	\
 			"	bneid	%0, 1b;"	\
-			"	addik	%2, %2, 1;"	\
+			"	addik	%1, %1, 1;"	\
 			"2:			"	\
 			__EX_TABLE_SECTION		\
 			".word	1b,2b;"			\
 			".previous;"			\
-		: "=r"(n)				\
-		: "0"(n), "r"(to)
+		: "=r"(n), "=r"(to)			\
+		: "0"(n), "1"(to)
 	);
 	return n;
 }

commit 8d7ec6ee59e78140bf01c7d0d009ea39ab6b3b59
Author: Michal Simek <monstr@monstr.eu>
Date:   Thu May 20 10:56:29 2010 +0200

    microblaze: Fix __copy_to/from_user_inatomic macros
    
    __copy_to/from_user_inatomic should call __copy_to/from_user
    because there is not necessary to check access because of kernel function.
    
    might_sleep in copy_to/from_user macros is causing problems
    in debug sessions too (CONFIG_DEBUG_SPINLOCK_SLEEP).
    
    BUG: sleeping function called from invalid context at
    .../arch/microblaze/include/asm/uaccess.h:388
    in_atomic(): 1, irqs_disabled(): 0, pid: 1, name: swapper
    1 lock held by swapper/1:
     #0:  (&p->cred_guard_mutex){......}, at: [<c00d4b90>] prepare_bprm_creds+0x2c/0x88
    Kernel Stack:
    ...
    
    Call Trace:
    [<c0006bd4>] microblaze_unwind+0x7c/0x94
    [<c0006684>] show_stack+0xf4/0x190
    [<c0006730>] dump_stack+0x10/0x30
    [<c00103a0>] __might_sleep+0x12c/0x160
    [<c0090de4>] file_read_actor+0x1d8/0x2a8
    [<c0091568>] generic_file_aio_read+0x6b4/0xa64
    [<c00cd778>] do_sync_read+0xac/0x110
    [<c00ce254>] vfs_read+0xc8/0x160
    [<c00d585c>] kernel_read+0x38/0x64
    [<c00d5984>] prepare_binprm+0xfc/0x130
    [<c00d6430>] do_execve+0x228/0x370
    [<c000614c>] microblaze_execve+0x58/0xa4
    
    caused by file_read_actor (mm/filemap.c) which calls
    __copy_to_user_inatomic.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 26460d15b338..d840f4a2d3c9 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -359,7 +359,7 @@ extern long __user_bad(void);
 	__copy_tofrom_user((__force void __user *)(to), \
 				(void __user *)(from), (n))
 #define __copy_from_user_inatomic(to, from, n) \
-		copy_from_user((to), (from), (n))
+		__copy_from_user((to), (from), (n))
 
 static inline long copy_from_user(void *to,
 		const void __user *from, unsigned long n)
@@ -373,7 +373,7 @@ static inline long copy_from_user(void *to,
 #define __copy_to_user(to, from, n)	\
 		__copy_tofrom_user((void __user *)(to), \
 			(__force const void __user *)(from), (n))
-#define __copy_to_user_inatomic(to, from, n)	copy_to_user((to), (from), (n))
+#define __copy_to_user_inatomic(to, from, n) __copy_to_user((to), (from), (n))
 
 static inline long copy_to_user(void __user *to,
 		const void *from, unsigned long n)

commit 538722ca3b762023ac65cec214901a1ebff8b575
Author: Steven J. Magnani <steve@digidescorp.com>
Date:   Thu May 6 16:38:33 2010 -0500

    microblaze: fix get_user/put_user side-effects
    
    The Microblaze implementations of get_user() and (MMU) put_user() evaluate
    the address argument more than once. This causes unexpected side-effects for
    invocations that include increment operators, i.e. get_user(foo, bar++).
    
    This patch also removes the distinction between MMU and noMMU put_user().
    
    Without the patch:
      $ echo 1234567890 > /proc/sys/kernel/core_pattern
      $ cat /proc/sys/kernel/core_pattern
      12345
    
    Signed-off-by: Steven J. Magnani <steve@digidescorp.com>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 446bec29b142..26460d15b338 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -182,6 +182,39 @@ extern long __user_bad(void);
  * Returns zero on success, or -EFAULT on error.
  * On error, the variable @x is set to zero.
  */
+#define get_user(x, ptr)						\
+	__get_user_check((x), (ptr), sizeof(*(ptr)))
+
+#define __get_user_check(x, ptr, size)					\
+({									\
+	unsigned long __gu_val = 0;					\
+	const typeof(*(ptr)) __user *__gu_addr = (ptr);			\
+	int __gu_err = 0;						\
+									\
+	if (access_ok(VERIFY_READ, __gu_addr, size)) {			\
+		switch (size) {						\
+		case 1:							\
+			__get_user_asm("lbu", __gu_addr, __gu_val,	\
+				       __gu_err);			\
+			break;						\
+		case 2:							\
+			__get_user_asm("lhu", __gu_addr, __gu_val,	\
+				       __gu_err);			\
+			break;						\
+		case 4:							\
+			__get_user_asm("lw", __gu_addr, __gu_val,	\
+				       __gu_err);			\
+			break;						\
+		default:						\
+			__gu_err = __user_bad();			\
+			break;						\
+		}							\
+	} else {							\
+		__gu_err = -EFAULT;					\
+	}								\
+	x = (typeof(*(ptr)))__gu_val;					\
+	__gu_err;							\
+})
 
 #define __get_user(x, ptr)						\
 ({									\
@@ -206,12 +239,6 @@ extern long __user_bad(void);
 })
 
 
-#define get_user(x, ptr)						\
-({									\
-	access_ok(VERIFY_READ, (ptr), sizeof(*(ptr)))			\
-		? __get_user((x), (ptr)) : -EFAULT;			\
-})
-
 #define __put_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
 ({								\
 	__asm__ __volatile__ (					\
@@ -266,6 +293,42 @@ extern long __user_bad(void);
  *
  * Returns zero on success, or -EFAULT on error.
  */
+#define put_user(x, ptr)						\
+	__put_user_check((x), (ptr), sizeof(*(ptr)))
+
+#define __put_user_check(x, ptr, size)					\
+({									\
+	typeof(*(ptr)) __pu_val;					\
+	typeof(*(ptr)) __user *__pu_addr = (ptr);			\
+	int __pu_err = 0;						\
+									\
+	__pu_val = (x);							\
+	if (access_ok(VERIFY_WRITE, __pu_addr, size)) {			\
+		switch (size) {						\
+		case 1:							\
+			__put_user_asm("sb", __pu_addr, __pu_val,	\
+				       __pu_err);			\
+			break;						\
+		case 2:							\
+			__put_user_asm("sh", __pu_addr, __pu_val,	\
+				       __pu_err);			\
+			break;						\
+		case 4:							\
+			__put_user_asm("sw", __pu_addr, __pu_val,	\
+				       __pu_err);			\
+			break;						\
+		case 8:							\
+			__put_user_asm_8(__pu_addr, __pu_val, __pu_err);\
+			break;						\
+		default:						\
+			__pu_err = __user_bad();			\
+			break;						\
+		}							\
+	} else {							\
+		__pu_err = -EFAULT;					\
+	}								\
+	__pu_err;							\
+})
 
 #define __put_user(x, ptr)						\
 ({									\
@@ -290,18 +353,6 @@ extern long __user_bad(void);
 	__gu_err;							\
 })
 
-#ifndef CONFIG_MMU
-
-#define put_user(x, ptr)	__put_user((x), (ptr))
-
-#else /* CONFIG_MMU */
-
-#define put_user(x, ptr)						\
-({									\
-	access_ok(VERIFY_WRITE, (ptr), sizeof(*(ptr)))			\
-		? __put_user((x), (ptr)) : -EFAULT;			\
-})
-#endif /* CONFIG_MMU */
 
 /* copy_to_from_user */
 #define __copy_from_user(to, from, n)	\

commit 89ae9753aef160c2f7bcecec21a7c4a6bc4c9b9b
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Mar 22 18:49:45 2010 +0100

    microblaze: uaccess: Sync strlen, strnlen, copy_to/from_user
    
    Last sync.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index b33ab659781e..446bec29b142 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -294,40 +294,6 @@ extern long __user_bad(void);
 
 #define put_user(x, ptr)	__put_user((x), (ptr))
 
-static inline long strnlen_user(const char __user *src, long count)
-{
-	return strlen(src) + 1;
-}
-
-#define __do_strncpy_from_user(dst, src, count, res)			\
-	do {								\
-		char *tmp;						\
-		strncpy(dst, src, count);				\
-		for (tmp = dst; *tmp && count > 0; tmp++, count--)	\
-			;						\
-		res = (tmp - dst);					\
-	} while (0)
-
-static inline long __strncpy_from_user(char *dst,
-				const char __user *src, long count)
-{
-	long res;
-	__do_strncpy_from_user(dst, src, count, res);
-	return res;
-}
-
-static inline long strncpy_from_user(char *dst,
-				const char __user *src, long count)
-{
-	long res = -EFAULT;
-	if (access_ok(VERIFY_READ, src, 1))
-		__do_strncpy_from_user(dst, src, count, res);
-	return res;
-}
-
-extern long strncpy_from_user(char *dst, const char *src, long count);
-extern long strnlen_user(const char *src, long count);
-
 #else /* CONFIG_MMU */
 
 #define put_user(x, ptr)						\
@@ -335,26 +301,9 @@ extern long strnlen_user(const char *src, long count);
 	access_ok(VERIFY_WRITE, (ptr), sizeof(*(ptr)))			\
 		? __put_user((x), (ptr)) : -EFAULT;			\
 })
-
-extern int __strncpy_user(char *to, const char __user *from, int len);
-
-#define __strncpy_from_user	__strncpy_user
-
-static inline long
-strncpy_from_user(char *dst, const char __user *src, long count)
-{
-	if (!access_ok(VERIFY_READ, src, 1))
-		return -EFAULT;
-	return __strncpy_from_user(dst, src, count);
-}
-
-extern int __strnlen_user(const char __user *sstr, int len);
-
-#define strnlen_user(str, len)	\
-		(access_ok(VERIFY_READ, str, 1) ? __strnlen_user(str, len) : 0)
-
 #endif /* CONFIG_MMU */
 
+/* copy_to_from_user */
 #define __copy_from_user(to, from, n)	\
 	__copy_tofrom_user((__force void __user *)(to), \
 				(void __user *)(from), (n))
@@ -367,8 +316,7 @@ static inline long copy_from_user(void *to,
 	might_sleep();
 	if (access_ok(VERIFY_READ, from, n))
 		return __copy_from_user(to, from, n);
-	else
-		return n;
+	return n;
 }
 
 #define __copy_to_user(to, from, n)	\
@@ -382,8 +330,36 @@ static inline long copy_to_user(void __user *to,
 	might_sleep();
 	if (access_ok(VERIFY_WRITE, to, n))
 		return __copy_to_user(to, from, n);
-	else
-		return n;
+	return n;
+}
+
+/*
+ * Copy a null terminated string from userspace.
+ */
+extern int __strncpy_user(char *to, const char __user *from, int len);
+
+#define __strncpy_from_user	__strncpy_user
+
+static inline long
+strncpy_from_user(char *dst, const char __user *src, long count)
+{
+	if (!access_ok(VERIFY_READ, src, 1))
+		return -EFAULT;
+	return __strncpy_from_user(dst, src, count);
+}
+
+/*
+ * Return the size of a string (including the ending 0)
+ *
+ * Return 0 on exception, a value greater than N if too long
+ */
+extern int __strnlen_user(const char __user *sstr, int len);
+
+static inline long strnlen_user(const char __user *src, long n)
+{
+	if (!access_ok(VERIFY_READ, src, 1))
+		return 0;
+	return __strnlen_user(src, n);
 }
 
 #endif  /* __ASSEMBLY__ */

commit 94804a9b3d0e62096a52fb62afcea32b899380c5
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Mar 22 18:39:20 2010 +0100

    microblaze: uaccess: Unify __copy_tofrom_user
    
    Move to generic location.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 34b79feb1ff1..b33ab659781e 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -111,6 +111,9 @@ static inline int ___range_ok(unsigned long addr, unsigned long size)
 # define __EX_TABLE_SECTION	".section .discard,\"a\"\n"
 #endif
 
+extern unsigned long __copy_tofrom_user(void __user *to,
+		const void __user *from, unsigned long size);
+
 /* Return: number of not copied bytes, i.e. 0 if OK or non-zero if fail. */
 static inline unsigned long __must_check __clear_user(void __user *to,
 							unsigned long n)
@@ -322,23 +325,6 @@ static inline long strncpy_from_user(char *dst,
 	return res;
 }
 
-static inline unsigned long __copy_tofrom_user(void __user *to,
-		const void __user *from, unsigned long size)
-{
-	memcpy(to, from, size);
-	return 0;
-}
-
-#define copy_to_user(to, from, n)	(memcpy((to), (from), (n)), 0)
-#define copy_from_user(to, from, n)	(memcpy((to), (from), (n)), 0)
-
-#define __copy_to_user(to, from, n)	(copy_to_user((to), (from), (n)))
-#define __copy_from_user(to, from, n)	(copy_from_user((to), (from), (n)))
-#define __copy_to_user_inatomic(to, from, n) \
-			(__copy_to_user((to), (from), (n)))
-#define __copy_from_user_inatomic(to, from, n) \
-			(__copy_from_user((to), (from), (n)))
-
 extern long strncpy_from_user(char *dst, const char *src, long count);
 extern long strnlen_user(const char *src, long count);
 
@@ -350,8 +336,24 @@ extern long strnlen_user(const char *src, long count);
 		? __put_user((x), (ptr)) : -EFAULT;			\
 })
 
-extern unsigned long __copy_tofrom_user(void __user *to,
-		const void __user *from, unsigned long size);
+extern int __strncpy_user(char *to, const char __user *from, int len);
+
+#define __strncpy_from_user	__strncpy_user
+
+static inline long
+strncpy_from_user(char *dst, const char __user *src, long count)
+{
+	if (!access_ok(VERIFY_READ, src, 1))
+		return -EFAULT;
+	return __strncpy_from_user(dst, src, count);
+}
+
+extern int __strnlen_user(const char __user *sstr, int len);
+
+#define strnlen_user(str, len)	\
+		(access_ok(VERIFY_READ, str, 1) ? __strnlen_user(str, len) : 0)
+
+#endif /* CONFIG_MMU */
 
 #define __copy_from_user(to, from, n)	\
 	__copy_tofrom_user((__force void __user *)(to), \
@@ -384,25 +386,6 @@ static inline long copy_to_user(void __user *to,
 		return n;
 }
 
-extern int __strncpy_user(char *to, const char __user *from, int len);
-
-#define __strncpy_from_user	__strncpy_user
-
-static inline long
-strncpy_from_user(char *dst, const char __user *src, long count)
-{
-	if (!access_ok(VERIFY_READ, src, 1))
-		return -EFAULT;
-	return __strncpy_from_user(dst, src, count);
-}
-
-extern int __strnlen_user(const char __user *sstr, int len);
-
-#define strnlen_user(str, len)	\
-		(access_ok(VERIFY_READ, str, 1) ? __strnlen_user(str, len) : 0)
-
-#endif /* CONFIG_MMU */
-
 #endif  /* __ASSEMBLY__ */
 #endif /* __KERNEL__ */
 

commit cca79120c253451220e589a104bdeb57e4901871
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Mar 22 18:23:45 2010 +0100

    microblaze: uaccess: Move functions to generic location
    
    noMMU and MMU use them.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 4f17950d0a0e..34b79feb1ff1 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -111,9 +111,6 @@ static inline int ___range_ok(unsigned long addr, unsigned long size)
 # define __EX_TABLE_SECTION	".section .discard,\"a\"\n"
 #endif
 
-extern unsigned long __copy_tofrom_user(void __user *to,
-		const void __user *from, unsigned long size);
-
 /* Return: number of not copied bytes, i.e. 0 if OK or non-zero if fail. */
 static inline unsigned long __must_check __clear_user(void __user *to,
 							unsigned long n)
@@ -144,8 +141,7 @@ static inline unsigned long __must_check clear_user(void __user *to,
 	return __clear_user(to, n);
 }
 
-#ifndef CONFIG_MMU
-
+/* put_user and get_user macros */
 extern long __user_bad(void);
 
 #define __get_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
@@ -251,6 +247,23 @@ extern long __user_bad(void);
 		);						\
 })
 
+/**
+ * put_user: - Write a simple value into user space.
+ * @x:   Value to copy to user space.
+ * @ptr: Destination address, in user space.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * This macro copies a single simple value from kernel space to user
+ * space.  It supports simple types like char and int, but not larger
+ * data types like structures or arrays.
+ *
+ * @ptr must have pointer-to-simple-variable type, and @x must be assignable
+ * to the result of dereferencing @ptr.
+ *
+ * Returns zero on success, or -EFAULT on error.
+ */
+
 #define __put_user(x, ptr)						\
 ({									\
 	__typeof__(*(ptr)) volatile __gu_val = (x);			\
@@ -274,8 +287,48 @@ extern long __user_bad(void);
 	__gu_err;							\
 })
 
+#ifndef CONFIG_MMU
+
 #define put_user(x, ptr)	__put_user((x), (ptr))
 
+static inline long strnlen_user(const char __user *src, long count)
+{
+	return strlen(src) + 1;
+}
+
+#define __do_strncpy_from_user(dst, src, count, res)			\
+	do {								\
+		char *tmp;						\
+		strncpy(dst, src, count);				\
+		for (tmp = dst; *tmp && count > 0; tmp++, count--)	\
+			;						\
+		res = (tmp - dst);					\
+	} while (0)
+
+static inline long __strncpy_from_user(char *dst,
+				const char __user *src, long count)
+{
+	long res;
+	__do_strncpy_from_user(dst, src, count, res);
+	return res;
+}
+
+static inline long strncpy_from_user(char *dst,
+				const char __user *src, long count)
+{
+	long res = -EFAULT;
+	if (access_ok(VERIFY_READ, src, 1))
+		__do_strncpy_from_user(dst, src, count, res);
+	return res;
+}
+
+static inline unsigned long __copy_tofrom_user(void __user *to,
+		const void __user *from, unsigned long size)
+{
+	memcpy(to, from, size);
+	return 0;
+}
+
 #define copy_to_user(to, from, n)	(memcpy((to), (from), (n)), 0)
 #define copy_from_user(to, from, n)	(memcpy((to), (from), (n)), 0)
 
@@ -291,158 +344,15 @@ extern long strnlen_user(const char *src, long count);
 
 #else /* CONFIG_MMU */
 
-/* put_user and get_user macros */
-
-extern long __user_bad(void);
-
-#define __get_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
-({								\
-	__asm__ __volatile__ (					\
-			"1:"	insn	" %1, %2, r0;"		\
-			"	addk	%0, r0, r0;"		\
-			"2:			"		\
-			__FIXUP_SECTION				\
-			"3:	brid	2b;	"		\
-			"	addik	%0, r0, %3;"		\
-			".previous;"				\
-			__EX_TABLE_SECTION			\
-			".word	1b,3b;"				\
-			".previous;"				\
-		: "=&r"(__gu_err), "=r"(__gu_val)		\
-		: "r"(__gu_ptr), "i"(-EFAULT)			\
-	);							\
-})
-
-#define __get_user(x, ptr)						\
-({									\
-	unsigned long __gu_val;						\
-	/*unsigned long __gu_ptr = (unsigned long)(ptr);*/		\
-	long __gu_err;							\
-	switch (sizeof(*(ptr))) {					\
-	case 1:								\
-		__get_user_asm("lbu", (ptr), __gu_val, __gu_err);	\
-		break;							\
-	case 2:								\
-		__get_user_asm("lhu", (ptr), __gu_val, __gu_err);	\
-		break;							\
-	case 4:								\
-		__get_user_asm("lw", (ptr), __gu_val, __gu_err);	\
-		break;							\
-	default:							\
-		/* __gu_val = 0; __gu_err = -EINVAL;*/ __gu_err = __user_bad();\
-	}								\
-	x = (__typeof__(*(ptr))) __gu_val;				\
-	__gu_err;							\
-})
-
-/**
- * get_user: - Get a simple variable from user space.
- * @x:   Variable to store result.
- * @ptr: Source address, in user space.
- *
- * Context: User context only.  This function may sleep.
- *
- * This macro copies a single simple variable from user space to kernel
- * space.  It supports simple types like char and int, but not larger
- * data types like structures or arrays.
- *
- * @ptr must have pointer-to-simple-variable type, and the result of
- * dereferencing @ptr must be assignable to @x without a cast.
- *
- * Returns zero on success, or -EFAULT on error.
- * On error, the variable @x is set to zero.
- */
-
-#define get_user(x, ptr)						\
-({									\
-	access_ok(VERIFY_READ, (ptr), sizeof(*(ptr)))			\
-		? __get_user((x), (ptr)) : -EFAULT;			\
-})
-
-/**
- * put_user: - Write a simple value into user space.
- * @x:   Value to copy to user space.
- * @ptr: Destination address, in user space.
- *
- * Context: User context only.  This function may sleep.
- *
- * This macro copies a single simple value from kernel space to user
- * space.  It supports simple types like char and int, but not larger
- * data types like structures or arrays.
- *
- * @ptr must have pointer-to-simple-variable type, and @x must be assignable
- * to the result of dereferencing @ptr.
- *
- * Returns zero on success, or -EFAULT on error.
- */
-
-#define __put_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
-({								\
-	__asm__ __volatile__ (					\
-			"1:"	insn	" %1, %2, r0;"		\
-			"	addk	%0, r0, r0;"		\
-			"2:			"		\
-			__FIXUP_SECTION				\
-			"3:	brid	2b;"			\
-			"	addik	%0, r0, %3;"		\
-			".previous;"				\
-			__EX_TABLE_SECTION			\
-			".word	1b,3b;"				\
-			".previous;"				\
-		: "=&r"(__gu_err)				\
-		: "r"(__gu_val), "r"(__gu_ptr), "i"(-EFAULT)	\
-	);							\
-})
-
-#define __put_user_asm_8(__gu_ptr, __gu_val, __gu_err)		\
-({								\
-	__asm__ __volatile__ ("	lwi	%0, %1, 0;"		\
-			"1:	swi	%0, %2, 0;"		\
-			"	lwi	%0, %1, 4;"		\
-			"2:	swi	%0, %2, 4;"		\
-			"	addk	%0, r0, r0;"		\
-			"3:				"	\
-			__FIXUP_SECTION				\
-			"4:	brid	3b;"			\
-			"	addik	%0, r0, %3;"		\
-			".previous;"				\
-			__EX_TABLE_SECTION			\
-			".word	1b,4b,2b,4b;"			\
-			".previous;"				\
-		: "=&r"(__gu_err)				\
-		: "r"(&__gu_val), "r"(__gu_ptr), "i"(-EFAULT)	\
-		);						\
-})
-
-#define __put_user(x, ptr)						\
-({									\
-	__typeof__(*(ptr)) volatile __gu_val = (x);			\
-	long __gu_err = 0;						\
-	switch (sizeof(__gu_val)) {					\
-	case 1:								\
-		__put_user_asm("sb", (ptr), __gu_val, __gu_err);	\
-		break;							\
-	case 2: 							\
-		__put_user_asm("sh", (ptr), __gu_val, __gu_err);	\
-		break;							\
-	case 4:								\
-		__put_user_asm("sw", (ptr), __gu_val, __gu_err);	\
-		break;							\
-	case 8:								\
-		__put_user_asm_8((ptr), __gu_val, __gu_err);		\
-		break;							\
-	default:							\
-		/*__gu_err = -EINVAL;*/	__gu_err = __user_bad();	\
-	}								\
-	__gu_err;							\
-})
-
 #define put_user(x, ptr)						\
 ({									\
 	access_ok(VERIFY_WRITE, (ptr), sizeof(*(ptr)))			\
 		? __put_user((x), (ptr)) : -EFAULT;			\
 })
 
+extern unsigned long __copy_tofrom_user(void __user *to,
+		const void __user *from, unsigned long size);
+
 #define __copy_from_user(to, from, n)	\
 	__copy_tofrom_user((__force void __user *)(to), \
 				(void __user *)(from), (n))

commit ef4e277b5d86e56db650137de0b1cd16ded32498
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Mar 22 16:22:41 2010 +0100

    microblaze: uaccess: Fix put_user for noMMU
    
    Here is small regression on dhrystone tests and I think
    that on all benchmarking tests. It is due to better checking
    mechanism in put_user macro
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index b079ac31a671..4f17950d0a0e 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -213,32 +213,66 @@ extern long __user_bad(void);
 		? __get_user((x), (ptr)) : -EFAULT;			\
 })
 
-/* Undefined function to trigger linker error */
-extern int bad_user_access_length(void);
+#define __put_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
+({								\
+	__asm__ __volatile__ (					\
+			"1:"	insn	" %1, %2, r0;"		\
+			"	addk	%0, r0, r0;"		\
+			"2:			"		\
+			__FIXUP_SECTION				\
+			"3:	brid	2b;"			\
+			"	addik	%0, r0, %3;"		\
+			".previous;"				\
+			__EX_TABLE_SECTION			\
+			".word	1b,3b;"				\
+			".previous;"				\
+		: "=&r"(__gu_err)				\
+		: "r"(__gu_val), "r"(__gu_ptr), "i"(-EFAULT)	\
+	);							\
+})
 
-/* FIXME is not there defined __pu_val */
-#define __put_user(var, ptr)					\
+#define __put_user_asm_8(__gu_ptr, __gu_val, __gu_err)		\
 ({								\
-	int __pu_err = 0;					\
-	switch (sizeof(*(ptr))) {				\
-	case 1:							\
-	case 2:							\
-	case 4:							\
-		*(ptr) = (var);					\
-		break;						\
-	case 8: {						\
-		typeof(*(ptr)) __pu_val = (var);		\
-		memcpy(ptr, &__pu_val, sizeof(__pu_val));	\
-		}						\
-		break;						\
-	default:						\
-		__pu_err = __put_user_bad();			\
-		break;						\
-	}							\
-	__pu_err;						\
+	__asm__ __volatile__ ("	lwi	%0, %1, 0;"		\
+			"1:	swi	%0, %2, 0;"		\
+			"	lwi	%0, %1, 4;"		\
+			"2:	swi	%0, %2, 4;"		\
+			"	addk	%0, r0, r0;"		\
+			"3:			"		\
+			__FIXUP_SECTION				\
+			"4:	brid	3b;"			\
+			"	addik	%0, r0, %3;"		\
+			".previous;"				\
+			__EX_TABLE_SECTION			\
+			".word	1b,4b,2b,4b;"			\
+			".previous;"				\
+		: "=&r"(__gu_err)				\
+		: "r"(&__gu_val), "r"(__gu_ptr), "i"(-EFAULT)	\
+		);						\
 })
 
-#define __put_user_bad()	(bad_user_access_length(), (-EFAULT))
+#define __put_user(x, ptr)						\
+({									\
+	__typeof__(*(ptr)) volatile __gu_val = (x);			\
+	long __gu_err = 0;						\
+	switch (sizeof(__gu_val)) {					\
+	case 1:								\
+		__put_user_asm("sb", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	case 2:								\
+		__put_user_asm("sh", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	case 4:								\
+		__put_user_asm("sw", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	case 8:								\
+		__put_user_asm_8((ptr), __gu_val, __gu_err);		\
+		break;							\
+	default:							\
+		/*__gu_err = -EINVAL;*/	__gu_err = __user_bad();	\
+	}								\
+	__gu_err;							\
+})
 
 #define put_user(x, ptr)	__put_user((x), (ptr))
 

commit 3a6d77245efe062993284fd1c2f7510d9a90efe1
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Mar 8 10:52:24 2010 +0100

    microblaze: uaccess: Fix get_user macro for noMMU
    
    Use unified version.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 1af92025fff9..b079ac31a671 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -146,31 +146,75 @@ static inline unsigned long __must_check clear_user(void __user *to,
 
 #ifndef CONFIG_MMU
 
-/* Undefined function to trigger linker error */
-extern int bad_user_access_length(void);
+extern long __user_bad(void);
+
+#define __get_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
+({								\
+	__asm__ __volatile__ (					\
+			"1:"	insn	" %1, %2, r0;"		\
+			"	addk	%0, r0, r0;"		\
+			"2:			"		\
+			__FIXUP_SECTION				\
+			"3:	brid	2b;"			\
+			"	addik	%0, r0, %3;"		\
+			".previous;"				\
+			__EX_TABLE_SECTION			\
+			".word	1b,3b;"				\
+			".previous;"				\
+		: "=&r"(__gu_err), "=r"(__gu_val)		\
+		: "r"(__gu_ptr), "i"(-EFAULT)			\
+	);							\
+})
+
+/**
+ * get_user: - Get a simple variable from user space.
+ * @x:   Variable to store result.
+ * @ptr: Source address, in user space.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * This macro copies a single simple variable from user space to kernel
+ * space.  It supports simple types like char and int, but not larger
+ * data types like structures or arrays.
+ *
+ * @ptr must have pointer-to-simple-variable type, and the result of
+ * dereferencing @ptr must be assignable to @x without a cast.
+ *
+ * Returns zero on success, or -EFAULT on error.
+ * On error, the variable @x is set to zero.
+ */
+
+#define __get_user(x, ptr)						\
+({									\
+	unsigned long __gu_val;						\
+	/*unsigned long __gu_ptr = (unsigned long)(ptr);*/		\
+	long __gu_err;							\
+	switch (sizeof(*(ptr))) {					\
+	case 1:								\
+		__get_user_asm("lbu", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	case 2:								\
+		__get_user_asm("lhu", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	case 4:								\
+		__get_user_asm("lw", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	default:							\
+		/* __gu_val = 0; __gu_err = -EINVAL;*/ __gu_err = __user_bad();\
+	}								\
+	x = (__typeof__(*(ptr))) __gu_val;				\
+	__gu_err;							\
+})
+
 
-/* FIXME this is function for optimalization -> memcpy */
-#define __get_user(var, ptr)				\
-({							\
-	int __gu_err = 0;				\
-	switch (sizeof(*(ptr))) {			\
-	case 1:						\
-	case 2:						\
-	case 4:						\
-		(var) = *(ptr);				\
-		break;					\
-	case 8:						\
-		memcpy((void *) &(var), (ptr), 8);	\
-		break;					\
-	default:					\
-		(var) = 0;				\
-		__gu_err = __get_user_bad();		\
-		break;					\
-	}						\
-	__gu_err;					\
+#define get_user(x, ptr)						\
+({									\
+	access_ok(VERIFY_READ, (ptr), sizeof(*(ptr)))			\
+		? __get_user((x), (ptr)) : -EFAULT;			\
 })
 
-#define __get_user_bad()	(bad_user_access_length(), (-EFAULT))
+/* Undefined function to trigger linker error */
+extern int bad_user_access_length(void);
 
 /* FIXME is not there defined __pu_val */
 #define __put_user(var, ptr)					\
@@ -197,7 +241,6 @@ extern int bad_user_access_length(void);
 #define __put_user_bad()	(bad_user_access_length(), (-EFAULT))
 
 #define put_user(x, ptr)	__put_user((x), (ptr))
-#define get_user(x, ptr)	__get_user((x), (ptr))
 
 #define copy_to_user(to, from, n)	(memcpy((to), (from), (n)), 0)
 #define copy_from_user(to, from, n)	(memcpy((to), (from), (n)), 0)

commit 527bdb52d50ddbc8dd64369e464d7a08bc7eb83c
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Mar 22 16:02:59 2010 +0100

    microblaze: uaccess: fix clear_user for noMMU kernel
    
    Previous patches fixed only MMU version and this is the first
    patch for noMMU kernel
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index fe954b394fdc..1af92025fff9 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -71,6 +71,9 @@ struct exception_table_entry {
 	unsigned long insn, fixup;
 };
 
+/* Returns 0 if exception not found and fixup otherwise.  */
+extern unsigned long search_exception_table(unsigned long);
+
 #ifndef CONFIG_MMU
 
 /* Check against bounds of physical memory */
@@ -108,6 +111,39 @@ static inline int ___range_ok(unsigned long addr, unsigned long size)
 # define __EX_TABLE_SECTION	".section .discard,\"a\"\n"
 #endif
 
+extern unsigned long __copy_tofrom_user(void __user *to,
+		const void __user *from, unsigned long size);
+
+/* Return: number of not copied bytes, i.e. 0 if OK or non-zero if fail. */
+static inline unsigned long __must_check __clear_user(void __user *to,
+							unsigned long n)
+{
+	/* normal memset with two words to __ex_table */
+	__asm__ __volatile__ (				\
+			"1:	sb	r0, %2, r0;"	\
+			"	addik	%0, %0, -1;"	\
+			"	bneid	%0, 1b;"	\
+			"	addik	%2, %2, 1;"	\
+			"2:			"	\
+			__EX_TABLE_SECTION		\
+			".word	1b,2b;"			\
+			".previous;"			\
+		: "=r"(n)				\
+		: "0"(n), "r"(to)
+	);
+	return n;
+}
+
+static inline unsigned long __must_check clear_user(void __user *to,
+							unsigned long n)
+{
+	might_sleep();
+	if (unlikely(!access_ok(VERIFY_WRITE, to, n)))
+		return n;
+
+	return __clear_user(to, n);
+}
+
 #ifndef CONFIG_MMU
 
 /* Undefined function to trigger linker error */
@@ -173,53 +209,11 @@ extern int bad_user_access_length(void);
 #define __copy_from_user_inatomic(to, from, n) \
 			(__copy_from_user((to), (from), (n)))
 
-#define __clear_user(addr, n)	(memset((void *)(addr), 0, (n)), 0)
-
-/* stejne s MMU */
-static inline unsigned long clear_user(void *addr, unsigned long size)
-{
-	if (access_ok(VERIFY_WRITE, addr, size))
-		size = __clear_user(addr, size);
-	return size;
-}
-
-/* Returns 0 if exception not found and fixup otherwise.  */
-extern unsigned long search_exception_table(unsigned long);
-
 extern long strncpy_from_user(char *dst, const char *src, long count);
 extern long strnlen_user(const char *src, long count);
 
 #else /* CONFIG_MMU */
 
-/* Return: number of not copied bytes, i.e. 0 if OK or non-zero if fail. */
-static inline unsigned long __must_check __clear_user(void __user *to,
-							unsigned long n)
-{
-	/* normal memset with two words to __ex_table */
-	__asm__ __volatile__ (				\
-			"1:	sb	r0, %2, r0;"	\
-			"	addik	%0, %0, -1;"	\
-			"	bneid	%0, 1b;"	\
-			"	addik	%2, %2, 1;"	\
-			"2:			"	\
-			__EX_TABLE_SECTION		\
-			".word	1b,2b;"			\
-			".previous;"			\
-		: "=r"(n)				\
-		: "0"(n), "r"(to)
-	);
-	return n;
-}
-
-static inline unsigned long __must_check clear_user(void __user *to,
-							unsigned long n)
-{
-	might_sleep();
-	if (unlikely(!access_ok(VERIFY_WRITE, to, n)))
-		return n;
-	return __clear_user(to, n);
-}
-
 /* put_user and get_user macros */
 
 extern long __user_bad(void);
@@ -372,9 +366,6 @@ extern long __user_bad(void);
 		? __put_user((x), (ptr)) : -EFAULT;			\
 })
 
-extern unsigned long __copy_tofrom_user(void __user *to,
-		const void __user *from, unsigned long size);
-
 #define __copy_from_user(to, from, n)	\
 	__copy_tofrom_user((__force void __user *)(to), \
 				(void __user *)(from), (n))

commit 40e11e3380d4bd14bb3d85c7e7b863075a6a8d86
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Mar 8 09:38:02 2010 +0100

    microblaze: uaccess: Fix strncpy_from_user function
    
    Generic implementation for noMMU and MMU version
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index b56d8ae9b17e..fe954b394fdc 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -407,11 +407,19 @@ static inline long copy_to_user(void __user *to,
 }
 
 extern int __strncpy_user(char *to, const char __user *from, int len);
+
+#define __strncpy_from_user	__strncpy_user
+
+static inline long
+strncpy_from_user(char *dst, const char __user *src, long count)
+{
+	if (!access_ok(VERIFY_READ, src, 1))
+		return -EFAULT;
+	return __strncpy_from_user(dst, src, count);
+}
+
 extern int __strnlen_user(const char __user *sstr, int len);
 
-#define strncpy_from_user(to, from, len)	\
-		(access_ok(VERIFY_READ, from, 1) ?	\
-			__strncpy_user(to, from, len) : -EFAULT)
 #define strnlen_user(str, len)	\
 		(access_ok(VERIFY_READ, str, 1) ? __strnlen_user(str, len) : 0)
 

commit 4270690bd4b1420a8d634ea31953a1c4def2a44a
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Mar 22 15:56:32 2010 +0100

    microblaze: uaccess: fix copy_from_user macro
    
    copy_from_user macro also use copy_tofrom_user function
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 125e4cf4105c..b56d8ae9b17e 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -375,12 +375,24 @@ extern long __user_bad(void);
 extern unsigned long __copy_tofrom_user(void __user *to,
 		const void __user *from, unsigned long size);
 
-#define __copy_from_user(to, from, n)	copy_from_user((to), (from), (n))
+#define __copy_from_user(to, from, n)	\
+	__copy_tofrom_user((__force void __user *)(to), \
+				(void __user *)(from), (n))
 #define __copy_from_user_inatomic(to, from, n) \
 		copy_from_user((to), (from), (n))
 
+static inline long copy_from_user(void *to,
+		const void __user *from, unsigned long n)
+{
+	might_sleep();
+	if (access_ok(VERIFY_READ, from, n))
+		return __copy_from_user(to, from, n);
+	else
+		return n;
+}
+
 #define __copy_to_user(to, from, n)	\
-	__copy_tofrom_user((void __user *)(to),	\
+		__copy_tofrom_user((void __user *)(to), \
 			(__force const void __user *)(from), (n))
 #define __copy_to_user_inatomic(to, from, n)	copy_to_user((to), (from), (n))
 
@@ -394,12 +406,6 @@ static inline long copy_to_user(void __user *to,
 		return n;
 }
 
-#define copy_from_user(to, from, n)					\
-	(access_ok(VERIFY_READ, (from), (n)) ?				\
-		__copy_tofrom_user((__force void __user *)(to),		\
-			(void __user *)(from), (n))			\
-		: -EFAULT)
-
 extern int __strncpy_user(char *to, const char __user *from, int len);
 extern int __strnlen_user(const char __user *sstr, int len);
 
@@ -411,7 +417,6 @@ extern int __strnlen_user(const char __user *sstr, int len);
 
 #endif /* CONFIG_MMU */
 
-
 #endif  /* __ASSEMBLY__ */
 #endif /* __KERNEL__ */
 

commit cc5a428b7ae9c2d6233b5bf6b3e6fbb24ddd1ed5
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Mar 22 15:52:53 2010 +0100

    microblaze: uaccess: copy_to_user unification
    
    noMMU and MMU kernel will use copy copy_tofrom_user
    asm implementation.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 6bb9b8fb6655..125e4cf4105c 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -372,19 +372,28 @@ extern long __user_bad(void);
 		? __put_user((x), (ptr)) : -EFAULT;			\
 })
 
+extern unsigned long __copy_tofrom_user(void __user *to,
+		const void __user *from, unsigned long size);
+
 #define __copy_from_user(to, from, n)	copy_from_user((to), (from), (n))
 #define __copy_from_user_inatomic(to, from, n) \
 		copy_from_user((to), (from), (n))
 
-#define copy_to_user(to, from, n)					\
-	(access_ok(VERIFY_WRITE, (to), (n)) ?				\
-		__copy_tofrom_user((void __user *)(to),			\
-			(__force const void __user *)(from), (n))	\
-		: -EFAULT)
-
-#define __copy_to_user(to, from, n)	copy_to_user((to), (from), (n))
+#define __copy_to_user(to, from, n)	\
+	__copy_tofrom_user((void __user *)(to),	\
+			(__force const void __user *)(from), (n))
 #define __copy_to_user_inatomic(to, from, n)	copy_to_user((to), (from), (n))
 
+static inline long copy_to_user(void __user *to,
+		const void *from, unsigned long n)
+{
+	might_sleep();
+	if (access_ok(VERIFY_WRITE, to, n))
+		return __copy_to_user(to, from, n);
+	else
+		return n;
+}
+
 #define copy_from_user(to, from, n)					\
 	(access_ok(VERIFY_READ, (from), (n)) ?				\
 		__copy_tofrom_user((__force void __user *)(to),		\
@@ -402,8 +411,6 @@ extern int __strnlen_user(const char __user *sstr, int len);
 
 #endif /* CONFIG_MMU */
 
-extern unsigned long __copy_tofrom_user(void __user *to,
-		const void __user *from, unsigned long size);
 
 #endif  /* __ASSEMBLY__ */
 #endif /* __KERNEL__ */

commit 0dcb409de73edeb221aed38d9ff8640cf41ff0de
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Mar 22 15:46:56 2010 +0100

    microblaze: uaccess: sync put/get/clear_user macros
    
    Add macro description and resort.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 1e8fa4b76115..6bb9b8fb6655 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -191,11 +191,38 @@ extern long strnlen_user(const char *src, long count);
 
 #else /* CONFIG_MMU */
 
-/*
- * All the __XXX versions macros/functions below do not perform
- * access checking. It is assumed that the necessary checks have been
- * already performed before the finction (macro) is called.
- */
+/* Return: number of not copied bytes, i.e. 0 if OK or non-zero if fail. */
+static inline unsigned long __must_check __clear_user(void __user *to,
+							unsigned long n)
+{
+	/* normal memset with two words to __ex_table */
+	__asm__ __volatile__ (				\
+			"1:	sb	r0, %2, r0;"	\
+			"	addik	%0, %0, -1;"	\
+			"	bneid	%0, 1b;"	\
+			"	addik	%2, %2, 1;"	\
+			"2:			"	\
+			__EX_TABLE_SECTION		\
+			".word	1b,2b;"			\
+			".previous;"			\
+		: "=r"(n)				\
+		: "0"(n), "r"(to)
+	);
+	return n;
+}
+
+static inline unsigned long __must_check clear_user(void __user *to,
+							unsigned long n)
+{
+	might_sleep();
+	if (unlikely(!access_ok(VERIFY_WRITE, to, n)))
+		return n;
+	return __clear_user(to, n);
+}
+
+/* put_user and get_user macros */
+
+extern long __user_bad(void);
 
 #define __get_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
 ({								\
@@ -231,18 +258,53 @@ extern long strnlen_user(const char *src, long count);
 		__get_user_asm("lw", (ptr), __gu_val, __gu_err);	\
 		break;							\
 	default:							\
-		__gu_val = 0; __gu_err = -EINVAL;			\
+		/* __gu_val = 0; __gu_err = -EINVAL;*/ __gu_err = __user_bad();\
 	}								\
 	x = (__typeof__(*(ptr))) __gu_val;				\
 	__gu_err;							\
 })
 
+/**
+ * get_user: - Get a simple variable from user space.
+ * @x:   Variable to store result.
+ * @ptr: Source address, in user space.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * This macro copies a single simple variable from user space to kernel
+ * space.  It supports simple types like char and int, but not larger
+ * data types like structures or arrays.
+ *
+ * @ptr must have pointer-to-simple-variable type, and the result of
+ * dereferencing @ptr must be assignable to @x without a cast.
+ *
+ * Returns zero on success, or -EFAULT on error.
+ * On error, the variable @x is set to zero.
+ */
+
 #define get_user(x, ptr)						\
 ({									\
 	access_ok(VERIFY_READ, (ptr), sizeof(*(ptr)))			\
 		? __get_user((x), (ptr)) : -EFAULT;			\
 })
 
+/**
+ * put_user: - Write a simple value into user space.
+ * @x:   Value to copy to user space.
+ * @ptr: Destination address, in user space.
+ *
+ * Context: User context only.  This function may sleep.
+ *
+ * This macro copies a single simple value from kernel space to user
+ * space.  It supports simple types like char and int, but not larger
+ * data types like structures or arrays.
+ *
+ * @ptr must have pointer-to-simple-variable type, and @x must be assignable
+ * to the result of dereferencing @ptr.
+ *
+ * Returns zero on success, or -EFAULT on error.
+ */
+
 #define __put_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
 ({								\
 	__asm__ __volatile__ (					\
@@ -299,7 +361,7 @@ extern long strnlen_user(const char *src, long count);
 		__put_user_asm_8((ptr), __gu_val, __gu_err);		\
 		break;							\
 	default:							\
-		__gu_err = -EINVAL;					\
+		/*__gu_err = -EINVAL;*/	__gu_err = __user_bad();	\
 	}								\
 	__gu_err;							\
 })
@@ -310,36 +372,6 @@ extern long strnlen_user(const char *src, long count);
 		? __put_user((x), (ptr)) : -EFAULT;			\
 })
 
-/* Return: number of not copied bytes, i.e. 0 if OK or non-zero if fail. */
-static inline unsigned long __must_check __clear_user(void __user *to,
-							unsigned long n)
-{
-	/* normal memset with two words to __ex_table */
-	__asm__ __volatile__ (				\
-			"1:	sb	r0, %2, r0;"	\
-			"	addik	%0, %0, -1;"	\
-			"	bneid	%0, 1b;"	\
-			"	addik	%2, %2, 1;"	\
-			"2:			"	\
-			__EX_TABLE_SECTION		\
-			".word	1b,2b;"			\
-			".previous;"			\
-		: "=r"(n)				\
-		: "0"(n), "r"(to)
-	);
-	return n;
-}
-
-static inline unsigned long __must_check clear_user(void __user *to,
-							unsigned long n)
-{
-	might_sleep();
-	if (unlikely(!access_ok(VERIFY_WRITE, to, n)))
-		return n;
-
-	return __clear_user(to, n);
-}
-
 #define __copy_from_user(to, from, n)	copy_from_user((to), (from), (n))
 #define __copy_from_user_inatomic(to, from, n) \
 		copy_from_user((to), (from), (n))

commit 8b651aa4a7c047b848f3a7bdf0aba9449e6dc3d3
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Mar 22 15:25:12 2010 +0100

    microblaze: uaccess: fix put_user and get_user macros
    
    Use FIXUP macros and resort them.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 531172e1d1f3..1e8fa4b76115 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -197,16 +197,22 @@ extern long strnlen_user(const char *src, long count);
  * already performed before the finction (macro) is called.
  */
 
-#define get_user(x, ptr)						\
-({									\
-	access_ok(VERIFY_READ, (ptr), sizeof(*(ptr)))			\
-		? __get_user((x), (ptr)) : -EFAULT;			\
-})
-
-#define put_user(x, ptr)						\
-({									\
-	access_ok(VERIFY_WRITE, (ptr), sizeof(*(ptr)))			\
-		? __put_user((x), (ptr)) : -EFAULT;			\
+#define __get_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
+({								\
+	__asm__ __volatile__ (					\
+			"1:"	insn	" %1, %2, r0;"		\
+			"	addk	%0, r0, r0;"		\
+			"2:			"		\
+			__FIXUP_SECTION				\
+			"3:	brid	2b;	"		\
+			"	addik	%0, r0, %3;"		\
+			".previous;"				\
+			__EX_TABLE_SECTION			\
+			".word	1b,3b;"				\
+			".previous;"				\
+		: "=&r"(__gu_err), "=r"(__gu_val)		\
+		: "r"(__gu_ptr), "i"(-EFAULT)			\
+	);							\
 })
 
 #define __get_user(x, ptr)						\
@@ -231,24 +237,49 @@ extern long strnlen_user(const char *src, long count);
 	__gu_err;							\
 })
 
-#define __get_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
+#define get_user(x, ptr)						\
+({									\
+	access_ok(VERIFY_READ, (ptr), sizeof(*(ptr)))			\
+		? __get_user((x), (ptr)) : -EFAULT;			\
+})
+
+#define __put_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
 ({								\
 	__asm__ __volatile__ (					\
 			"1:"	insn	" %1, %2, r0;"		\
 			"	addk	%0, r0, r0;"		\
 			"2:			"		\
 			__FIXUP_SECTION				\
-			"3:	brid	2b;	"		\
+			"3:	brid	2b;"			\
 			"	addik	%0, r0, %3;"		\
 			".previous;"				\
 			__EX_TABLE_SECTION			\
 			".word	1b,3b;"				\
 			".previous;"				\
-		: "=&r"(__gu_err), "=r"(__gu_val)		\
-		: "r"(__gu_ptr), "i"(-EFAULT)			\
+		: "=&r"(__gu_err)				\
+		: "r"(__gu_val), "r"(__gu_ptr), "i"(-EFAULT)	\
 	);							\
 })
 
+#define __put_user_asm_8(__gu_ptr, __gu_val, __gu_err)		\
+({								\
+	__asm__ __volatile__ ("	lwi	%0, %1, 0;"		\
+			"1:	swi	%0, %2, 0;"		\
+			"	lwi	%0, %1, 4;"		\
+			"2:	swi	%0, %2, 4;"		\
+			"	addk	%0, r0, r0;"		\
+			"3:				"	\
+			__FIXUP_SECTION				\
+			"4:	brid	3b;"			\
+			"	addik	%0, r0, %3;"		\
+			".previous;"				\
+			__EX_TABLE_SECTION			\
+			".word	1b,4b,2b,4b;"			\
+			".previous;"				\
+		: "=&r"(__gu_err)				\
+		: "r"(&__gu_val), "r"(__gu_ptr), "i"(-EFAULT)	\
+		);						\
+})
 
 #define __put_user(x, ptr)						\
 ({									\
@@ -273,43 +304,10 @@ extern long strnlen_user(const char *src, long count);
 	__gu_err;							\
 })
 
-#define __put_user_asm_8(__gu_ptr, __gu_val, __gu_err)	\
-({							\
-__asm__ __volatile__ ("	lwi	%0, %1, 0;		\
-		1:	swi	%0, %2, 0;		\
-			lwi	%0, %1, 4;		\
-		2:	swi	%0, %2, 4;		\
-			addk	%0,r0,r0;		\
-		3:					\
-		.section .fixup,\"ax\";			\
-		4:	brid	3b;			\
-			addik	%0, r0, %3;		\
-		.previous;				\
-		.section __ex_table,\"a\";		\
-		.word	1b,4b,2b,4b;			\
-		.previous;"				\
-	: "=&r"(__gu_err)				\
-	: "r"(&__gu_val),				\
-	"r"(__gu_ptr), "i"(-EFAULT)			\
-	);						\
-})
-
-#define __put_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
-({								\
-	__asm__ __volatile__ (					\
-			"1:"	insn	" %1, %2, r0;		\
-				addk	%0, r0, r0;		\
-			2:					\
-			.section .fixup,\"ax\";			\
-			3:	brid	2b;			\
-				addik	%0, r0, %3;		\
-			.previous;				\
-			.section __ex_table,\"a\";		\
-			.word	1b,3b;				\
-			.previous;"				\
-		: "=r"(__gu_err)				\
-		: "r"(__gu_val), "r"(__gu_ptr), "i"(-EFAULT)	\
-	);							\
+#define put_user(x, ptr)						\
+({									\
+	access_ok(VERIFY_WRITE, (ptr), sizeof(*(ptr)))			\
+		? __put_user((x), (ptr)) : -EFAULT;			\
 })
 
 /* Return: number of not copied bytes, i.e. 0 if OK or non-zero if fail. */

commit c77a9c4bb7b6e26400853c92d74ccc697c5e2f7e
Author: Michal Simek <monstr@monstr.eu>
Date:   Fri Mar 5 18:03:53 2010 +0100

    microblaze: uaccess: fix __get_user_asm macro
    
    It is used __FIXUP_SECTION and __EX_TABLE_SECTION macros.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index fdb1c1cf51ad..531172e1d1f3 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -231,24 +231,25 @@ extern long strnlen_user(const char *src, long count);
 	__gu_err;							\
 })
 
-#define __get_user_asm(insn, __gu_ptr, __gu_val, __gu_err)		\
-({									\
-	__asm__ __volatile__ (						\
-			"1:"	insn	" %1, %2, r0;			\
-				addk	%0, r0, r0;			\
-			2:						\
-			.section .fixup,\"ax\";				\
-			3:	brid	2b;				\
-				addik	%0, r0, %3;			\
-			.previous;					\
-			.section __ex_table,\"a\";			\
-			.word	1b,3b;					\
-			.previous;"					\
-		: "=r"(__gu_err), "=r"(__gu_val)			\
-		: "r"(__gu_ptr), "i"(-EFAULT)				\
-	);								\
+#define __get_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
+({								\
+	__asm__ __volatile__ (					\
+			"1:"	insn	" %1, %2, r0;"		\
+			"	addk	%0, r0, r0;"		\
+			"2:			"		\
+			__FIXUP_SECTION				\
+			"3:	brid	2b;	"		\
+			"	addik	%0, r0, %3;"		\
+			".previous;"				\
+			__EX_TABLE_SECTION			\
+			".word	1b,3b;"				\
+			".previous;"				\
+		: "=&r"(__gu_err), "=r"(__gu_val)		\
+		: "r"(__gu_ptr), "i"(-EFAULT)			\
+	);							\
 })
 
+
 #define __put_user(x, ptr)						\
 ({									\
 	__typeof__(*(ptr)) volatile __gu_val = (x);			\

commit 40b1156db09ab2df48aa4970ddf4a27a17246f1f
Author: Michal Simek <monstr@monstr.eu>
Date:   Fri Mar 5 16:50:01 2010 +0100

    microblaze: uaccess: fix clean user macro
    
    This is the first patch which does uaccess unification.
    I choosed to do several patches to be able to use bisect
    in future if any fault happens.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index ce5defb259a4..fdb1c1cf51ad 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -71,8 +71,6 @@ struct exception_table_entry {
 	unsigned long insn, fixup;
 };
 
-#define __clear_user(addr, n)	(memset((void *)(addr), 0, (n)), 0)
-
 #ifndef CONFIG_MMU
 
 /* Check against bounds of physical memory */
@@ -86,7 +84,31 @@ static inline int ___range_ok(unsigned long addr, unsigned long size)
 		___range_ok((unsigned long)(addr), (unsigned long)(size))
 
 #define access_ok(type, addr, size) (__range_ok((addr), (size)) == 0)
-#define __access_ok(add, size) (__range_ok((addr), (size)) == 0)
+
+#else
+
+/*
+ * Address is valid if:
+ *  - "addr", "addr + size" and "size" are all below the limit
+ */
+#define access_ok(type, addr, size) \
+	(get_fs().seg > (((unsigned long)(addr)) | \
+		(size) | ((unsigned long)(addr) + (size))))
+
+/* || printk("access_ok failed for %s at 0x%08lx (size %d), seg 0x%08x\n",
+ type?"WRITE":"READ",addr,size,get_fs().seg)) */
+
+#endif
+
+#ifdef CONFIG_MMU
+# define __FIXUP_SECTION	".section .fixup,\"ax\"\n"
+# define __EX_TABLE_SECTION	".section __ex_table,\"a\"\n"
+#else
+# define __FIXUP_SECTION	".section .discard,\"ax\"\n"
+# define __EX_TABLE_SECTION	".section .discard,\"a\"\n"
+#endif
+
+#ifndef CONFIG_MMU
 
 /* Undefined function to trigger linker error */
 extern int bad_user_access_length(void);
@@ -151,6 +173,9 @@ extern int bad_user_access_length(void);
 #define __copy_from_user_inatomic(to, from, n) \
 			(__copy_from_user((to), (from), (n)))
 
+#define __clear_user(addr, n)	(memset((void *)(addr), 0, (n)), 0)
+
+/* stejne s MMU */
 static inline unsigned long clear_user(void *addr, unsigned long size)
 {
 	if (access_ok(VERIFY_WRITE, addr, size))
@@ -166,17 +191,6 @@ extern long strnlen_user(const char *src, long count);
 
 #else /* CONFIG_MMU */
 
-/*
- * Address is valid if:
- *  - "addr", "addr + size" and "size" are all below the limit
- */
-#define access_ok(type, addr, size) \
-	(get_fs().seg > (((unsigned long)(addr)) | \
-		(size) | ((unsigned long)(addr) + (size))))
-
-/* || printk("access_ok failed for %s at 0x%08lx (size %d), seg 0x%08x\n",
- type?"WRITE":"READ",addr,size,get_fs().seg)) */
-
 /*
  * All the __XXX versions macros/functions below do not perform
  * access checking. It is assumed that the necessary checks have been
@@ -297,27 +311,34 @@ __asm__ __volatile__ ("	lwi	%0, %1, 0;		\
 	);							\
 })
 
-/*
- * Return: number of not copied bytes, i.e. 0 if OK or non-zero if fail.
- */
-static inline int clear_user(char *to, int size)
+/* Return: number of not copied bytes, i.e. 0 if OK or non-zero if fail. */
+static inline unsigned long __must_check __clear_user(void __user *to,
+							unsigned long n)
 {
-	if (size && access_ok(VERIFY_WRITE, to, size)) {
-		__asm__ __volatile__ ("				\
-				1:				\
-					sb	r0, %2, r0;	\
-					addik	%0, %0, -1;	\
-					bneid	%0, 1b;		\
-					addik	%2, %2, 1;	\
-				2:				\
-				.section __ex_table,\"a\";	\
-				.word	1b,2b;			\
-				.section .text;"		\
-			: "=r"(size)				\
-			: "0"(size), "r"(to)
-		);
-	}
-	return size;
+	/* normal memset with two words to __ex_table */
+	__asm__ __volatile__ (				\
+			"1:	sb	r0, %2, r0;"	\
+			"	addik	%0, %0, -1;"	\
+			"	bneid	%0, 1b;"	\
+			"	addik	%2, %2, 1;"	\
+			"2:			"	\
+			__EX_TABLE_SECTION		\
+			".word	1b,2b;"			\
+			".previous;"			\
+		: "=r"(n)				\
+		: "0"(n), "r"(to)
+	);
+	return n;
+}
+
+static inline unsigned long __must_check clear_user(void __user *to,
+							unsigned long n)
+{
+	might_sleep();
+	if (unlikely(!access_ok(VERIFY_WRITE, to, n)))
+		return n;
+
+	return __clear_user(to, n);
 }
 
 #define __copy_from_user(to, from, n)	copy_from_user((to), (from), (n))

commit 60a729f7bb936a9ab82b430de70a1952f560adf3
Author: Michal Simek <monstr@monstr.eu>
Date:   Fri Mar 5 15:49:53 2010 +0100

    microblaze: move noMMU __range_ok function to uaccess.h
    
    The same noMMU and MMU functions should be placed in
    one file.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index e2adad33950e..ce5defb259a4 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -75,7 +75,12 @@ struct exception_table_entry {
 
 #ifndef CONFIG_MMU
 
-extern int ___range_ok(unsigned long addr, unsigned long size);
+/* Check against bounds of physical memory */
+static inline int ___range_ok(unsigned long addr, unsigned long size)
+{
+	return ((addr < memory_start) ||
+		((addr + size) > memory_end));
+}
 
 #define __range_ok(addr, size) \
 		___range_ok((unsigned long)(addr), (unsigned long)(size))

commit 357bc3c9284b2fb201786176e8187d2273323bc1
Author: Michal Simek <monstr@monstr.eu>
Date:   Fri Mar 5 15:37:57 2010 +0100

    microblaze: Move exception_table_entry upward
    
    Just sort to be able remove whole block.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index a8f794d03c5f..e2adad33950e 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -55,6 +55,21 @@
 
 # define segment_eq(a, b)	((a).seg == (b).seg)
 
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue. No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path. This means when everything is well,
+ * we don't even have to jump over them. Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+struct exception_table_entry {
+	unsigned long insn, fixup;
+};
 
 #define __clear_user(addr, n)	(memset((void *)(addr), 0, (n)), 0)
 
@@ -333,22 +348,6 @@ extern int __strnlen_user(const char __user *sstr, int len);
 extern unsigned long __copy_tofrom_user(void __user *to,
 		const void __user *from, unsigned long size);
 
-/*
- * The exception table consists of pairs of addresses: the first is the
- * address of an instruction that is allowed to fault, and the second is
- * the address at which the program should continue. No registers are
- * modified, so it is entirely up to the continuation code to figure out
- * what to do.
- *
- * All the routines below use bits of fixup code that are out of line
- * with the main instruction path. This means when everything is well,
- * we don't even have to jump over them. Further, they do not intrude
- * on our cache or tlb entries.
- */
-struct exception_table_entry {
-	unsigned long insn, fixup;
-};
-
 #endif  /* __ASSEMBLY__ */
 #endif /* __KERNEL__ */
 

commit 40db0834337ef0cde586feeb5588e45f0349098b
Author: Michal Simek <monstr@monstr.eu>
Date:   Fri Mar 5 15:34:12 2010 +0100

    microblaze: Remove segment.h
    
    I would like to use asm-generic uaccess.h where are segment
    macros defined. This is just first step.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 371bd6e56d9a..a8f794d03c5f 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -22,12 +22,40 @@
 #include <asm/mmu.h>
 #include <asm/page.h>
 #include <asm/pgtable.h>
-#include <asm/segment.h>
 #include <linux/string.h>
 
 #define VERIFY_READ	0
 #define VERIFY_WRITE	1
 
+/*
+ * On Microblaze the fs value is actually the top of the corresponding
+ * address space.
+ *
+ * The fs value determines whether argument validity checking should be
+ * performed or not. If get_fs() == USER_DS, checking is performed, with
+ * get_fs() == KERNEL_DS, checking is bypassed.
+ *
+ * For historical reasons, these macros are grossly misnamed.
+ *
+ * For non-MMU arch like Microblaze, KERNEL_DS and USER_DS is equal.
+ */
+# define MAKE_MM_SEG(s)       ((mm_segment_t) { (s) })
+
+#  ifndef CONFIG_MMU
+#  define KERNEL_DS	MAKE_MM_SEG(0)
+#  define USER_DS	KERNEL_DS
+#  else
+#  define KERNEL_DS	MAKE_MM_SEG(0xFFFFFFFF)
+#  define USER_DS	MAKE_MM_SEG(TASK_SIZE - 1)
+#  endif
+
+# define get_ds()	(KERNEL_DS)
+# define get_fs()	(current_thread_info()->addr_limit)
+# define set_fs(val)	(current_thread_info()->addr_limit = (val))
+
+# define segment_eq(a, b)	((a).seg == (b).seg)
+
+
 #define __clear_user(addr, n)	(memset((void *)(addr), 0, (n)), 0)
 
 #ifndef CONFIG_MMU

commit 95dfbbe4700016bddd7e8915e95a97652e70f495
Author: John Williams <john.williams@petalogix.com>
Date:   Fri Aug 14 12:06:46 2009 +1000

    microblaze: Simple __copy_tofrom_user for noMMU
    
    This is first patch which clear part of uaccess.h.
    uaccess.h will be clear later.
    
    Signed-off-by: John Williams <john.williams@petalogix.com>
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 5431b4631a7a..371bd6e56d9a 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -272,8 +272,9 @@ static inline int clear_user(char *to, int size)
 	return size;
 }
 
-extern unsigned long __copy_tofrom_user(void __user *to,
-		const void __user *from, unsigned long size);
+#define __copy_from_user(to, from, n)	copy_from_user((to), (from), (n))
+#define __copy_from_user_inatomic(to, from, n) \
+		copy_from_user((to), (from), (n))
 
 #define copy_to_user(to, from, n)					\
 	(access_ok(VERIFY_WRITE, (to), (n)) ?				\
@@ -290,10 +291,6 @@ extern unsigned long __copy_tofrom_user(void __user *to,
 			(void __user *)(from), (n))			\
 		: -EFAULT)
 
-#define __copy_from_user(to, from, n)	copy_from_user((to), (from), (n))
-#define __copy_from_user_inatomic(to, from, n) \
-		copy_from_user((to), (from), (n))
-
 extern int __strncpy_user(char *to, const char __user *from, int len);
 extern int __strnlen_user(const char __user *sstr, int len);
 
@@ -305,6 +302,9 @@ extern int __strnlen_user(const char __user *sstr, int len);
 
 #endif /* CONFIG_MMU */
 
+extern unsigned long __copy_tofrom_user(void __user *to,
+		const void __user *from, unsigned long size);
+
 /*
  * The exception table consists of pairs of addresses: the first is the
  * address of an instruction that is allowed to fault, and the second is

commit 7bcb63b21327427b130edeb6e6ad44ee260b3043
Author: Michal Simek <monstr@monstr.eu>
Date:   Mon Jul 13 16:46:54 2009 +0200

    microblaze: Fix put_user macro for 64bits arguments
    
    For 64bits arguments gcc caused that put_user macro
    works with wrong value because of optimalization.
    Adding volatile caused that gcc not optimized it.
    
    It is possible to use (as Blackfin do) two put_user
    macros with 32bits arguments but there is one more
    instruction which is due to duplication zero return
    value which is called put_user_asm macro.
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 65adad61e7e9..5431b4631a7a 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -189,7 +189,7 @@ extern long strnlen_user(const char *src, long count);
 
 #define __put_user(x, ptr)						\
 ({									\
-	__typeof__(*(ptr)) __gu_val = x;				\
+	__typeof__(*(ptr)) volatile __gu_val = (x);			\
 	long __gu_err = 0;						\
 	switch (sizeof(__gu_val)) {					\
 	case 1:								\

commit 0d6de9532663a4120ce35f507f16b72df382e360
Author: Michal Simek <monstr@monstr.eu>
Date:   Tue May 26 16:30:23 2009 +0200

    microblaze_mmu_v2: uaccess MMU update
    
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index a4e171d49d15..65adad61e7e9 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -1,4 +1,6 @@
 /*
+ * Copyright (C) 2008-2009 Michal Simek <monstr@monstr.eu>
+ * Copyright (C) 2008-2009 PetaLogix
  * Copyright (C) 2006 Atmark Techno, Inc.
  *
  * This file is subject to the terms and conditions of the GNU General Public
@@ -26,6 +28,10 @@
 #define VERIFY_READ	0
 #define VERIFY_WRITE	1
 
+#define __clear_user(addr, n)	(memset((void *)(addr), 0, (n)), 0)
+
+#ifndef CONFIG_MMU
+
 extern int ___range_ok(unsigned long addr, unsigned long size);
 
 #define __range_ok(addr, size) \
@@ -38,63 +44,64 @@ extern int ___range_ok(unsigned long addr, unsigned long size);
 extern int bad_user_access_length(void);
 
 /* FIXME this is function for optimalization -> memcpy */
-#define __get_user(var, ptr)					\
-	({							\
-		int __gu_err = 0;				\
-		switch (sizeof(*(ptr))) {			\
-		case 1:						\
-		case 2:						\
-		case 4:						\
-			(var) = *(ptr);				\
-			break;					\
-		case 8:						\
-			memcpy((void *) &(var), (ptr), 8);	\
-			break;					\
-		default:					\
-			(var) = 0;				\
-			__gu_err = __get_user_bad();		\
-			break;					\
-		}						\
-		__gu_err;					\
-	})
+#define __get_user(var, ptr)				\
+({							\
+	int __gu_err = 0;				\
+	switch (sizeof(*(ptr))) {			\
+	case 1:						\
+	case 2:						\
+	case 4:						\
+		(var) = *(ptr);				\
+		break;					\
+	case 8:						\
+		memcpy((void *) &(var), (ptr), 8);	\
+		break;					\
+	default:					\
+		(var) = 0;				\
+		__gu_err = __get_user_bad();		\
+		break;					\
+	}						\
+	__gu_err;					\
+})
 
 #define __get_user_bad()	(bad_user_access_length(), (-EFAULT))
 
+/* FIXME is not there defined __pu_val */
 #define __put_user(var, ptr)					\
-	({							\
-		int __pu_err = 0;				\
-		switch (sizeof(*(ptr))) {			\
-		case 1:						\
-		case 2:						\
-		case 4:						\
-			*(ptr) = (var);				\
-			break;					\
-		case 8: {					\
-			typeof(*(ptr)) __pu_val = var;		\
-			memcpy(ptr, &__pu_val, sizeof(__pu_val));\
-			}					\
-			break;					\
-		default:					\
-			__pu_err = __put_user_bad();		\
-			break;					\
-		}							\
-		__pu_err;						\
-	})
+({								\
+	int __pu_err = 0;					\
+	switch (sizeof(*(ptr))) {				\
+	case 1:							\
+	case 2:							\
+	case 4:							\
+		*(ptr) = (var);					\
+		break;						\
+	case 8: {						\
+		typeof(*(ptr)) __pu_val = (var);		\
+		memcpy(ptr, &__pu_val, sizeof(__pu_val));	\
+		}						\
+		break;						\
+	default:						\
+		__pu_err = __put_user_bad();			\
+		break;						\
+	}							\
+	__pu_err;						\
+})
 
 #define __put_user_bad()	(bad_user_access_length(), (-EFAULT))
 
-#define put_user(x, ptr)	__put_user(x, ptr)
-#define get_user(x, ptr)	__get_user(x, ptr)
-
-#define copy_to_user(to, from, n)		(memcpy(to, from, n), 0)
-#define copy_from_user(to, from, n)		(memcpy(to, from, n), 0)
+#define put_user(x, ptr)	__put_user((x), (ptr))
+#define get_user(x, ptr)	__get_user((x), (ptr))
 
-#define __copy_to_user(to, from, n)		(copy_to_user(to, from, n))
-#define __copy_from_user(to, from, n)		(copy_from_user(to, from, n))
-#define __copy_to_user_inatomic(to, from, n)	(__copy_to_user(to, from, n))
-#define __copy_from_user_inatomic(to, from, n)	(__copy_from_user(to, from, n))
+#define copy_to_user(to, from, n)	(memcpy((to), (from), (n)), 0)
+#define copy_from_user(to, from, n)	(memcpy((to), (from), (n)), 0)
 
-#define __clear_user(addr, n)	(memset((void *)addr, 0, n), 0)
+#define __copy_to_user(to, from, n)	(copy_to_user((to), (from), (n)))
+#define __copy_from_user(to, from, n)	(copy_from_user((to), (from), (n)))
+#define __copy_to_user_inatomic(to, from, n) \
+			(__copy_to_user((to), (from), (n)))
+#define __copy_from_user_inatomic(to, from, n) \
+			(__copy_from_user((to), (from), (n)))
 
 static inline unsigned long clear_user(void *addr, unsigned long size)
 {
@@ -103,13 +110,200 @@ static inline unsigned long clear_user(void *addr, unsigned long size)
 	return size;
 }
 
-/* Returns 0 if exception not found and fixup otherwise. */
+/* Returns 0 if exception not found and fixup otherwise.  */
 extern unsigned long search_exception_table(unsigned long);
 
+extern long strncpy_from_user(char *dst, const char *src, long count);
+extern long strnlen_user(const char *src, long count);
+
+#else /* CONFIG_MMU */
+
+/*
+ * Address is valid if:
+ *  - "addr", "addr + size" and "size" are all below the limit
+ */
+#define access_ok(type, addr, size) \
+	(get_fs().seg > (((unsigned long)(addr)) | \
+		(size) | ((unsigned long)(addr) + (size))))
+
+/* || printk("access_ok failed for %s at 0x%08lx (size %d), seg 0x%08x\n",
+ type?"WRITE":"READ",addr,size,get_fs().seg)) */
+
+/*
+ * All the __XXX versions macros/functions below do not perform
+ * access checking. It is assumed that the necessary checks have been
+ * already performed before the finction (macro) is called.
+ */
+
+#define get_user(x, ptr)						\
+({									\
+	access_ok(VERIFY_READ, (ptr), sizeof(*(ptr)))			\
+		? __get_user((x), (ptr)) : -EFAULT;			\
+})
+
+#define put_user(x, ptr)						\
+({									\
+	access_ok(VERIFY_WRITE, (ptr), sizeof(*(ptr)))			\
+		? __put_user((x), (ptr)) : -EFAULT;			\
+})
+
+#define __get_user(x, ptr)						\
+({									\
+	unsigned long __gu_val;						\
+	/*unsigned long __gu_ptr = (unsigned long)(ptr);*/		\
+	long __gu_err;							\
+	switch (sizeof(*(ptr))) {					\
+	case 1:								\
+		__get_user_asm("lbu", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	case 2:								\
+		__get_user_asm("lhu", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	case 4:								\
+		__get_user_asm("lw", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	default:							\
+		__gu_val = 0; __gu_err = -EINVAL;			\
+	}								\
+	x = (__typeof__(*(ptr))) __gu_val;				\
+	__gu_err;							\
+})
+
+#define __get_user_asm(insn, __gu_ptr, __gu_val, __gu_err)		\
+({									\
+	__asm__ __volatile__ (						\
+			"1:"	insn	" %1, %2, r0;			\
+				addk	%0, r0, r0;			\
+			2:						\
+			.section .fixup,\"ax\";				\
+			3:	brid	2b;				\
+				addik	%0, r0, %3;			\
+			.previous;					\
+			.section __ex_table,\"a\";			\
+			.word	1b,3b;					\
+			.previous;"					\
+		: "=r"(__gu_err), "=r"(__gu_val)			\
+		: "r"(__gu_ptr), "i"(-EFAULT)				\
+	);								\
+})
+
+#define __put_user(x, ptr)						\
+({									\
+	__typeof__(*(ptr)) __gu_val = x;				\
+	long __gu_err = 0;						\
+	switch (sizeof(__gu_val)) {					\
+	case 1:								\
+		__put_user_asm("sb", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	case 2: 							\
+		__put_user_asm("sh", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	case 4:								\
+		__put_user_asm("sw", (ptr), __gu_val, __gu_err);	\
+		break;							\
+	case 8:								\
+		__put_user_asm_8((ptr), __gu_val, __gu_err);		\
+		break;							\
+	default:							\
+		__gu_err = -EINVAL;					\
+	}								\
+	__gu_err;							\
+})
+
+#define __put_user_asm_8(__gu_ptr, __gu_val, __gu_err)	\
+({							\
+__asm__ __volatile__ ("	lwi	%0, %1, 0;		\
+		1:	swi	%0, %2, 0;		\
+			lwi	%0, %1, 4;		\
+		2:	swi	%0, %2, 4;		\
+			addk	%0,r0,r0;		\
+		3:					\
+		.section .fixup,\"ax\";			\
+		4:	brid	3b;			\
+			addik	%0, r0, %3;		\
+		.previous;				\
+		.section __ex_table,\"a\";		\
+		.word	1b,4b,2b,4b;			\
+		.previous;"				\
+	: "=&r"(__gu_err)				\
+	: "r"(&__gu_val),				\
+	"r"(__gu_ptr), "i"(-EFAULT)			\
+	);						\
+})
+
+#define __put_user_asm(insn, __gu_ptr, __gu_val, __gu_err)	\
+({								\
+	__asm__ __volatile__ (					\
+			"1:"	insn	" %1, %2, r0;		\
+				addk	%0, r0, r0;		\
+			2:					\
+			.section .fixup,\"ax\";			\
+			3:	brid	2b;			\
+				addik	%0, r0, %3;		\
+			.previous;				\
+			.section __ex_table,\"a\";		\
+			.word	1b,3b;				\
+			.previous;"				\
+		: "=r"(__gu_err)				\
+		: "r"(__gu_val), "r"(__gu_ptr), "i"(-EFAULT)	\
+	);							\
+})
+
+/*
+ * Return: number of not copied bytes, i.e. 0 if OK or non-zero if fail.
+ */
+static inline int clear_user(char *to, int size)
+{
+	if (size && access_ok(VERIFY_WRITE, to, size)) {
+		__asm__ __volatile__ ("				\
+				1:				\
+					sb	r0, %2, r0;	\
+					addik	%0, %0, -1;	\
+					bneid	%0, 1b;		\
+					addik	%2, %2, 1;	\
+				2:				\
+				.section __ex_table,\"a\";	\
+				.word	1b,2b;			\
+				.section .text;"		\
+			: "=r"(size)				\
+			: "0"(size), "r"(to)
+		);
+	}
+	return size;
+}
+
+extern unsigned long __copy_tofrom_user(void __user *to,
+		const void __user *from, unsigned long size);
+
+#define copy_to_user(to, from, n)					\
+	(access_ok(VERIFY_WRITE, (to), (n)) ?				\
+		__copy_tofrom_user((void __user *)(to),			\
+			(__force const void __user *)(from), (n))	\
+		: -EFAULT)
+
+#define __copy_to_user(to, from, n)	copy_to_user((to), (from), (n))
+#define __copy_to_user_inatomic(to, from, n)	copy_to_user((to), (from), (n))
+
+#define copy_from_user(to, from, n)					\
+	(access_ok(VERIFY_READ, (from), (n)) ?				\
+		__copy_tofrom_user((__force void __user *)(to),		\
+			(void __user *)(from), (n))			\
+		: -EFAULT)
+
+#define __copy_from_user(to, from, n)	copy_from_user((to), (from), (n))
+#define __copy_from_user_inatomic(to, from, n) \
+		copy_from_user((to), (from), (n))
+
+extern int __strncpy_user(char *to, const char __user *from, int len);
+extern int __strnlen_user(const char __user *sstr, int len);
+
+#define strncpy_from_user(to, from, len)	\
+		(access_ok(VERIFY_READ, from, 1) ?	\
+			__strncpy_user(to, from, len) : -EFAULT)
+#define strnlen_user(str, len)	\
+		(access_ok(VERIFY_READ, str, 1) ? __strnlen_user(str, len) : 0)
 
-extern long strncpy_from_user(char *dst, const char __user *src, long count);
-extern long strnlen_user(const char __user *src, long count);
-extern long __strncpy_from_user(char *dst, const char __user *src, long count);
+#endif /* CONFIG_MMU */
 
 /*
  * The exception table consists of pairs of addresses: the first is the

commit 838d2406ee62595c1b40d1d03b48bc9a2102258b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri May 1 13:36:13 2009 +0000

    microblaze: remove bad_user_access_length
    
    This function was actually causing harm, by hiding
    errors about invalid sized get_user/put_user accesses.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
index 5a3ffc308e12..a4e171d49d15 100644
--- a/arch/microblaze/include/asm/uaccess.h
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -34,10 +34,9 @@ extern int ___range_ok(unsigned long addr, unsigned long size);
 #define access_ok(type, addr, size) (__range_ok((addr), (size)) == 0)
 #define __access_ok(add, size) (__range_ok((addr), (size)) == 0)
 
-extern inline int bad_user_access_length(void)
-{
-	return 0;
-}
+/* Undefined function to trigger linker error */
+extern int bad_user_access_length(void);
+
 /* FIXME this is function for optimalization -> memcpy */
 #define __get_user(var, ptr)					\
 	({							\

commit 2660663ff2d34a3665381a2591bbc3ce0cdbd69c
Author: Michal Simek <monstr@monstr.eu>
Date:   Fri Mar 27 14:25:23 2009 +0100

    microblaze_v8: uaccess files
    
    Reviewed-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Stephen Neuendorffer <stephen.neuendorffer@xilinx.com>
    Acked-by: John Linn <john.linn@xilinx.com>
    Acked-by: John Williams <john.williams@petalogix.com>
    Signed-off-by: Michal Simek <monstr@monstr.eu>

diff --git a/arch/microblaze/include/asm/uaccess.h b/arch/microblaze/include/asm/uaccess.h
new file mode 100644
index 000000000000..5a3ffc308e12
--- /dev/null
+++ b/arch/microblaze/include/asm/uaccess.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2006 Atmark Techno, Inc.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License. See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+
+#ifndef _ASM_MICROBLAZE_UACCESS_H
+#define _ASM_MICROBLAZE_UACCESS_H
+
+#ifdef __KERNEL__
+#ifndef __ASSEMBLY__
+
+#include <linux/kernel.h>
+#include <linux/errno.h>
+#include <linux/sched.h> /* RLIMIT_FSIZE */
+#include <linux/mm.h>
+
+#include <asm/mmu.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/segment.h>
+#include <linux/string.h>
+
+#define VERIFY_READ	0
+#define VERIFY_WRITE	1
+
+extern int ___range_ok(unsigned long addr, unsigned long size);
+
+#define __range_ok(addr, size) \
+		___range_ok((unsigned long)(addr), (unsigned long)(size))
+
+#define access_ok(type, addr, size) (__range_ok((addr), (size)) == 0)
+#define __access_ok(add, size) (__range_ok((addr), (size)) == 0)
+
+extern inline int bad_user_access_length(void)
+{
+	return 0;
+}
+/* FIXME this is function for optimalization -> memcpy */
+#define __get_user(var, ptr)					\
+	({							\
+		int __gu_err = 0;				\
+		switch (sizeof(*(ptr))) {			\
+		case 1:						\
+		case 2:						\
+		case 4:						\
+			(var) = *(ptr);				\
+			break;					\
+		case 8:						\
+			memcpy((void *) &(var), (ptr), 8);	\
+			break;					\
+		default:					\
+			(var) = 0;				\
+			__gu_err = __get_user_bad();		\
+			break;					\
+		}						\
+		__gu_err;					\
+	})
+
+#define __get_user_bad()	(bad_user_access_length(), (-EFAULT))
+
+#define __put_user(var, ptr)					\
+	({							\
+		int __pu_err = 0;				\
+		switch (sizeof(*(ptr))) {			\
+		case 1:						\
+		case 2:						\
+		case 4:						\
+			*(ptr) = (var);				\
+			break;					\
+		case 8: {					\
+			typeof(*(ptr)) __pu_val = var;		\
+			memcpy(ptr, &__pu_val, sizeof(__pu_val));\
+			}					\
+			break;					\
+		default:					\
+			__pu_err = __put_user_bad();		\
+			break;					\
+		}							\
+		__pu_err;						\
+	})
+
+#define __put_user_bad()	(bad_user_access_length(), (-EFAULT))
+
+#define put_user(x, ptr)	__put_user(x, ptr)
+#define get_user(x, ptr)	__get_user(x, ptr)
+
+#define copy_to_user(to, from, n)		(memcpy(to, from, n), 0)
+#define copy_from_user(to, from, n)		(memcpy(to, from, n), 0)
+
+#define __copy_to_user(to, from, n)		(copy_to_user(to, from, n))
+#define __copy_from_user(to, from, n)		(copy_from_user(to, from, n))
+#define __copy_to_user_inatomic(to, from, n)	(__copy_to_user(to, from, n))
+#define __copy_from_user_inatomic(to, from, n)	(__copy_from_user(to, from, n))
+
+#define __clear_user(addr, n)	(memset((void *)addr, 0, n), 0)
+
+static inline unsigned long clear_user(void *addr, unsigned long size)
+{
+	if (access_ok(VERIFY_WRITE, addr, size))
+		size = __clear_user(addr, size);
+	return size;
+}
+
+/* Returns 0 if exception not found and fixup otherwise. */
+extern unsigned long search_exception_table(unsigned long);
+
+
+extern long strncpy_from_user(char *dst, const char __user *src, long count);
+extern long strnlen_user(const char __user *src, long count);
+extern long __strncpy_from_user(char *dst, const char __user *src, long count);
+
+/*
+ * The exception table consists of pairs of addresses: the first is the
+ * address of an instruction that is allowed to fault, and the second is
+ * the address at which the program should continue. No registers are
+ * modified, so it is entirely up to the continuation code to figure out
+ * what to do.
+ *
+ * All the routines below use bits of fixup code that are out of line
+ * with the main instruction path. This means when everything is well,
+ * we don't even have to jump over them. Further, they do not intrude
+ * on our cache or tlb entries.
+ */
+struct exception_table_entry {
+	unsigned long insn, fixup;
+};
+
+#endif  /* __ASSEMBLY__ */
+#endif /* __KERNEL__ */
+
+#endif /* _ASM_MICROBLAZE_UACCESS_H */
