commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arc/include/asm/mmzone.h b/arch/arc/include/asm/mmzone.h
index 8e97136413d9..b86b9d1e54dc 100644
--- a/arch/arc/include/asm/mmzone.h
+++ b/arch/arc/include/asm/mmzone.h
@@ -1,9 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2016 Synopsys, Inc. (www.synopsys.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef _ASM_ARC_MMZONE_H

commit 26f9d5fd82ca20fe536cb493ec7cf5628f8997e5
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon Apr 18 10:49:56 2016 +0530

    ARC: support HIGHMEM even without PAE40
    
    Initial HIGHMEM support on ARC was introduced for PAE40 where the low
    memory (0x8000_0000 based) and high memory (0x1_0000_0000) were
    physically contiguous. So CONFIG_FLATMEM sufficed (despite a peipheral
    hole in the middle, which wasted a bit of struct page memory, but things
    worked).
    
    However w/o PAE, highmem was not possible and we could only reach
    ~1.75GB of DDR. Now there is a use case to access ~4GB of DDR w/o PAE40
    The idea is to have low memory at canonical 0x8000_0000 and highmem
    at 0 so enire 4GB address space is available for physical addressing
    This needs additional platform/interconnect mapping to convert
    the non contiguous physical addresses into linear bus adresses.
    
    From Linux point of view, non contiguous divide means FLATMEM no
    longer works and DISCONTIGMEM is needed to track the pfns in the 2
    regions.
    
    This scheme would also work for PAE40, only better in that we don't
    waste struct page memory for the peripheral hole.
    
    The DT description will be something like
    
        memory {
            ...
            reg = <0x80000000 0x200000000   /* 512MB: lowmem */
                   0x00000000 0x10000000>;  /* 256MB: highmem */
       }
    
    Signed-off-by: Noam Camus <noamc@ezchip.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/mmzone.h b/arch/arc/include/asm/mmzone.h
new file mode 100644
index 000000000000..8e97136413d9
--- /dev/null
+++ b/arch/arc/include/asm/mmzone.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2016 Synopsys, Inc. (www.synopsys.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _ASM_ARC_MMZONE_H
+#define _ASM_ARC_MMZONE_H
+
+#ifdef CONFIG_DISCONTIGMEM
+
+extern struct pglist_data node_data[];
+#define NODE_DATA(nid) (&node_data[nid])
+
+static inline int pfn_to_nid(unsigned long pfn)
+{
+	int is_end_low = 1;
+
+	if (IS_ENABLED(CONFIG_ARC_HAS_PAE40))
+		is_end_low = pfn <= virt_to_pfn(0xFFFFFFFFUL);
+
+	/*
+	 * node 0: lowmem:             0x8000_0000   to 0xFFFF_FFFF
+	 * node 1: HIGHMEM w/o  PAE40: 0x0           to 0x7FFF_FFFF
+	 *         HIGHMEM with PAE40: 0x1_0000_0000 to ...
+	 */
+	if (pfn >= ARCH_PFN_OFFSET && is_end_low)
+		return 0;
+
+	return 1;
+}
+
+static inline int pfn_valid(unsigned long pfn)
+{
+	int nid = pfn_to_nid(pfn);
+
+	return (pfn <= node_end_pfn(nid));
+}
+#endif /* CONFIG_DISCONTIGMEM  */
+
+#endif
