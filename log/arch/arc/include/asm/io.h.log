commit d092a87073269677b7ff09e71a8d91912b7f969a
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 16 08:09:38 2019 +0200

    arch: rely on asm-generic/io.h for default ioremap_* definitions
    
    Various architectures that use asm-generic/io.h still defined their
    own default versions of ioremap_nocache, ioremap_wt and ioremap_wc
    that point back to plain ioremap directly or indirectly.  Remove these
    definitions and rely on asm-generic/io.h instead.  For this to work
    the backup ioremap_* defintions needs to be changed to purely cpp
    macros instea of inlines to cover for architectures like openrisc
    that only define ioremap after including <asm-generic/io.h>.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Palmer Dabbelt <palmer@dabbelt.com>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index 72f7929736f8..8f777d6441a5 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -34,10 +34,6 @@ static inline void ioport_unmap(void __iomem *addr)
 
 extern void iounmap(const void __iomem *addr);
 
-#define ioremap_nocache(phy, sz)	ioremap(phy, sz)
-#define ioremap_wc(phy, sz)		ioremap(phy, sz)
-#define ioremap_wt(phy, sz)		ioremap(phy, sz)
-
 /*
  * io{read,write}{16,32}be() macros
  */

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index 2f39d9b3886e..72f7929736f8 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -1,9 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #ifndef _ASM_ARC_IO_H

commit 10d443431dc2bb733cf7add99b453e3fb9047a2e
Author: Jose Abreu <joabreu@synopsys.com>
Date:   Fri Nov 30 09:47:31 2018 +0000

    ARC: io.h: Implement reads{x}()/writes{x}()
    
    Some ARC CPU's do not support unaligned loads/stores. Currently, generic
    implementation of reads{b/w/l}()/writes{b/w/l}() is being used with ARC.
    This can lead to misfunction of some drivers as generic functions do a
    plain dereference of a pointer that can be unaligned.
    
    Let's use {get/put}_unaligned() helpers instead of plain dereference of
    pointer in order to fix. The helpers allow to get and store data from an
    unaligned address whilst preserving the CPU internal alignment.
    According to [1], the use of these helpers are costly in terms of
    performance so we added an initial check for a buffer already aligned so
    that the usage of the helpers can be avoided, when possible.
    
    [1] Documentation/unaligned-memory-access.txt
    
    Cc: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: Joao Pinto <jpinto@synopsys.com>
    Cc: David Laight <David.Laight@ACULAB.COM>
    Tested-by: Vitor Soares <soares@synopsys.com>
    Signed-off-by: Jose Abreu <joabreu@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index c22b181e8206..2f39d9b3886e 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -12,6 +12,7 @@
 #include <linux/types.h>
 #include <asm/byteorder.h>
 #include <asm/page.h>
+#include <asm/unaligned.h>
 
 #ifdef CONFIG_ISA_ARCV2
 #include <asm/barrier.h>
@@ -94,6 +95,42 @@ static inline u32 __raw_readl(const volatile void __iomem *addr)
 	return w;
 }
 
+/*
+ * {read,write}s{b,w,l}() repeatedly access the same IO address in
+ * native endianness in 8-, 16-, 32-bit chunks {into,from} memory,
+ * @count times
+ */
+#define __raw_readsx(t,f) \
+static inline void __raw_reads##f(const volatile void __iomem *addr,	\
+				  void *ptr, unsigned int count)	\
+{									\
+	bool is_aligned = ((unsigned long)ptr % ((t) / 8)) == 0;	\
+	u##t *buf = ptr;						\
+									\
+	if (!count)							\
+		return;							\
+									\
+	/* Some ARC CPU's don't support unaligned accesses */		\
+	if (is_aligned) {						\
+		do {							\
+			u##t x = __raw_read##f(addr);			\
+			*buf++ = x;					\
+		} while (--count);					\
+	} else {							\
+		do {							\
+			u##t x = __raw_read##f(addr);			\
+			put_unaligned(x, buf++);			\
+		} while (--count);					\
+	}								\
+}
+
+#define __raw_readsb __raw_readsb
+__raw_readsx(8, b)
+#define __raw_readsw __raw_readsw
+__raw_readsx(16, w)
+#define __raw_readsl __raw_readsl
+__raw_readsx(32, l)
+
 #define __raw_writeb __raw_writeb
 static inline void __raw_writeb(u8 b, volatile void __iomem *addr)
 {
@@ -126,6 +163,35 @@ static inline void __raw_writel(u32 w, volatile void __iomem *addr)
 
 }
 
+#define __raw_writesx(t,f)						\
+static inline void __raw_writes##f(volatile void __iomem *addr, 	\
+				   const void *ptr, unsigned int count)	\
+{									\
+	bool is_aligned = ((unsigned long)ptr % ((t) / 8)) == 0;	\
+	const u##t *buf = ptr;						\
+									\
+	if (!count)							\
+		return;							\
+									\
+	/* Some ARC CPU's don't support unaligned accesses */		\
+	if (is_aligned) {						\
+		do {							\
+			__raw_write##f(*buf++, addr);			\
+		} while (--count);					\
+	} else {							\
+		do {							\
+			__raw_write##f(get_unaligned(buf++), addr);	\
+		} while (--count);					\
+	}								\
+}
+
+#define __raw_writesb __raw_writesb
+__raw_writesx(8, b)
+#define __raw_writesw __raw_writesw
+__raw_writesx(16, w)
+#define __raw_writesl __raw_writesl
+__raw_writesx(32, l)
+
 /*
  * MMIO can also get buffered/optimized in micro-arch, so barriers needed
  * Based on ARM model for the typical use case
@@ -141,10 +207,16 @@ static inline void __raw_writel(u32 w, volatile void __iomem *addr)
 #define readb(c)		({ u8  __v = readb_relaxed(c); __iormb(); __v; })
 #define readw(c)		({ u16 __v = readw_relaxed(c); __iormb(); __v; })
 #define readl(c)		({ u32 __v = readl_relaxed(c); __iormb(); __v; })
+#define readsb(p,d,l)		({ __raw_readsb(p,d,l); __iormb(); })
+#define readsw(p,d,l)		({ __raw_readsw(p,d,l); __iormb(); })
+#define readsl(p,d,l)		({ __raw_readsl(p,d,l); __iormb(); })
 
 #define writeb(v,c)		({ __iowmb(); writeb_relaxed(v,c); })
 #define writew(v,c)		({ __iowmb(); writew_relaxed(v,c); })
 #define writel(v,c)		({ __iowmb(); writel_relaxed(v,c); })
+#define writesb(p,d,l)		({ __iowmb(); __raw_writesb(p,d,l); })
+#define writesw(p,d,l)		({ __iowmb(); __raw_writesw(p,d,l); })
+#define writesl(p,d,l)		({ __iowmb(); __raw_writesl(p,d,l); })
 
 /*
  * Relaxed API for drivers which can handle barrier ordering themselves

commit e5bc0478ab6cf565619224536d75ecb2aedca43b
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu May 5 13:32:34 2016 +0530

    ARC: Add missing io barriers to io{read,write}{16,32}be()
    
    While reviewing a different change to asm-generic/io.h Arnd spotted that
    ARC ioread32 and ioread32be both of which come from asm-generic versions
    are not symmetrical in terms of calling the io barriers.
    
    generic ioread32   -> ARC readl()                  [ has barriers]
    generic ioread32be -> __be32_to_cpu(__raw_readl()) [ lacks barriers]
    
    While generic ioread32be is being remediated to call readl(), that involves
    a swab32(), causing double swaps on ioread32be() on Big Endian systems.
    
    So provide our versions of big endian IO accessors to ensure io barrier
    calls while also keeping them optimal
    
    Suggested-by: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: stable@vger.kernel.org  [4.2+]
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index 17f85c9c73cf..c22b181e8206 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -13,6 +13,15 @@
 #include <asm/byteorder.h>
 #include <asm/page.h>
 
+#ifdef CONFIG_ISA_ARCV2
+#include <asm/barrier.h>
+#define __iormb()		rmb()
+#define __iowmb()		wmb()
+#else
+#define __iormb()		do { } while (0)
+#define __iowmb()		do { } while (0)
+#endif
+
 extern void __iomem *ioremap(phys_addr_t paddr, unsigned long size);
 extern void __iomem *ioremap_prot(phys_addr_t paddr, unsigned long size,
 				  unsigned long flags);
@@ -31,6 +40,15 @@ extern void iounmap(const void __iomem *addr);
 #define ioremap_wc(phy, sz)		ioremap(phy, sz)
 #define ioremap_wt(phy, sz)		ioremap(phy, sz)
 
+/*
+ * io{read,write}{16,32}be() macros
+ */
+#define ioread16be(p)		({ u16 __v = be16_to_cpu((__force __be16)__raw_readw(p)); __iormb(); __v; })
+#define ioread32be(p)		({ u32 __v = be32_to_cpu((__force __be32)__raw_readl(p)); __iormb(); __v; })
+
+#define iowrite16be(v,p)	({ __iowmb(); __raw_writew((__force u16)cpu_to_be16(v), p); })
+#define iowrite32be(v,p)	({ __iowmb(); __raw_writel((__force u32)cpu_to_be32(v), p); })
+
 /* Change struct page to physical address */
 #define page_to_phys(page)		(page_to_pfn(page) << PAGE_SHIFT)
 
@@ -108,15 +126,6 @@ static inline void __raw_writel(u32 w, volatile void __iomem *addr)
 
 }
 
-#ifdef CONFIG_ISA_ARCV2
-#include <asm/barrier.h>
-#define __iormb()		rmb()
-#define __iowmb()		wmb()
-#else
-#define __iormb()		do { } while (0)
-#define __iowmb()		do { } while (0)
-#endif
-
 /*
  * MMIO can also get buffered/optimized in micro-arch, so barriers needed
  * Based on ARM model for the typical use case

commit d34687ab97731b3a707106f78756342b61f46dbc
Merge: 77d913178c24 deaf7565eb61
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Mar 21 13:00:46 2016 -0700

    Merge tag 'arc-4.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/vgupta/arc
    
    Pull ARC architecture updates from Vineet Gupta:
     - Big Endian io accessors fix [Lada]
     - Spellos fixes [Adam]
     - Fix for DW GMAC breakage [Alexey]
     - Making DMA API 64-bit ready
     - Shutting up -Wmaybe-uninitialized noise for ARC
     - Other minor fixes here and there, comments update
    
    * tag 'arc-4.6-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/vgupta/arc: (21 commits)
      ARCv2: ioremap: Support dynamic peripheral address space
      ARC: dma: reintroduce platform specific dma<->phys
      ARC: dma: ioremap: use phys_addr_t consistenctly in code paths
      ARC: dma: pass_phys() not sg_virt() to cache ops
      ARC: dma: non-coherent pages need V-P mapping if in HIGHMEM
      ARC: dma: Use struct page based page allocator helpers
      ARC: build: Turn off -Wmaybe-uninitialized for ARC gcc 4.8
      ARC: [plat-axs10x] add Ethernet PHY description in .dts
      arc: use of_platform_default_populate() to populate default bus
      ARC: thp: unbork !CONFIG_TRANSPARENT_HUGEPAGE build
      arc: [plat-nsimosci*] use ezchip network driver
      ARCv2: LLSC: software backoff is NOT needed starting HS2.1c
      ARC: mm: Use virt_to_pfn() for addr >> PAGE_SHIFT pattern
      ARC: [plat-nsim] document ranges
      ARC: build: Better way to detect ISA compatible toolchain
      ARCv2: Allow enabling PAE40 w/o HIGHMEM
      ARC: [BE] readl()/writel() to work in Big Endian CPU configuration
      ARC: [*defconfig] No need to specify CONFIG_CROSS_COMPILE
      ARC: [BE] Select correct CROSS_COMPILE prefix
      ARC: bitops: Remove non relevant comments
      ...

commit f5db19e93f680160a0fb3e2b05ceb4832b24d486
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Mar 16 15:04:39 2016 +0530

    ARC: dma: ioremap: use phys_addr_t consistenctly in code paths
    
    To support dma in physical memory beyond 4GB with PAE40
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index 27b17adea50d..1a20a62d192a 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -13,8 +13,8 @@
 #include <asm/byteorder.h>
 #include <asm/page.h>
 
-extern void __iomem *ioremap(unsigned long physaddr, unsigned long size);
-extern void __iomem *ioremap_prot(phys_addr_t offset, unsigned long size,
+extern void __iomem *ioremap(phys_addr_t paddr, unsigned long size);
+extern void __iomem *ioremap_prot(phys_addr_t paddr, unsigned long size,
 				  unsigned long flags);
 extern void iounmap(const void __iomem *addr);
 

commit f778cc65717687a3d3f26dd21bef62cd059f1b8b
Author: Lada Trimasova <ltrimas@synopsys.com>
Date:   Wed Mar 9 20:21:04 2016 +0300

    ARC: [BE] readl()/writel() to work in Big Endian CPU configuration
    
    read{l,w}() write{l,w}() primitives should use le{16,32}_to_cpu() and
    cpu_to_le{16,32}() respectively to ensure device registers are read
    correctly in Big Endian CPU configuration.
    
    Per Arnd Bergmann
    | Most drivers using readl() or readl_relaxed() expect those to perform byte
    | swaps on big-endian architectures, as the registers tend to be fixed endian
    
    This was needed for getting UART to work correctly on a Big Endian ARC.
    
    The ARC accessors originally were fine, and the bug got introduced
    inadventently by commit b8a033023994 ("ARCv2: barriers")
    
    Fixes: b8a033023994 ("ARCv2: barriers")
    Link: http://lkml.kernel.org/r/201603100845.30602.arnd@arndb.de
    Cc: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: stable@vger.kernel.org  [4.2+]
    Cc: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Lada Trimasova <ltrimas@synopsys.com>
    [vgupta: beefed up changelog, added Fixes/stable tags]
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index 694ece8a0243..27b17adea50d 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -129,15 +129,23 @@ static inline void __raw_writel(u32 w, volatile void __iomem *addr)
 #define writel(v,c)		({ __iowmb(); writel_relaxed(v,c); })
 
 /*
- * Relaxed API for drivers which can handle any ordering themselves
+ * Relaxed API for drivers which can handle barrier ordering themselves
+ *
+ * Also these are defined to perform little endian accesses.
+ * To provide the typical device register semantics of fixed endian,
+ * swap the byte order for Big Endian
+ *
+ * http://lkml.kernel.org/r/201603100845.30602.arnd@arndb.de
  */
 #define readb_relaxed(c)	__raw_readb(c)
-#define readw_relaxed(c)	__raw_readw(c)
-#define readl_relaxed(c)	__raw_readl(c)
+#define readw_relaxed(c) ({ u16 __r = le16_to_cpu((__force __le16) \
+					__raw_readw(c)); __r; })
+#define readl_relaxed(c) ({ u32 __r = le32_to_cpu((__force __le32) \
+					__raw_readl(c)); __r; })
 
 #define writeb_relaxed(v,c)	__raw_writeb(v,c)
-#define writew_relaxed(v,c)	__raw_writew(v,c)
-#define writel_relaxed(v,c)	__raw_writel(v,c)
+#define writew_relaxed(v,c)	__raw_writew((__force u16) cpu_to_le16(v),c)
+#define writel_relaxed(v,c)	__raw_writel((__force u32) cpu_to_le32(v),c)
 
 #include <asm-generic/io.h>
 

commit c1678ffcdea25afe4fbbebfab13d65a7db5458fb
Author: Joao Pinto <Joao.Pinto@synopsys.com>
Date:   Thu Mar 10 14:44:13 2016 -0600

    ARC: Add PCI support
    
    Add PCI support to ARC and update drivers/pci Makefile enabling the ARC
    arch to use the generic PCI setup functions.
    
    [bhelgaas: fold in Joao's pci-dma-compat.h & pci-bridge.h build fix (I
    should have caught this myself, sorry]
    Signed-off-by: Joao Pinto <jpinto@synopsys.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index 694ece8a0243..947bf0cfdec0 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -16,6 +16,15 @@
 extern void __iomem *ioremap(unsigned long physaddr, unsigned long size);
 extern void __iomem *ioremap_prot(phys_addr_t offset, unsigned long size,
 				  unsigned long flags);
+static inline void __iomem *ioport_map(unsigned long port, unsigned int nr)
+{
+	return (void __iomem *)port;
+}
+
+static inline void ioport_unmap(void __iomem *addr)
+{
+}
+
 extern void iounmap(const void __iomem *addr);
 
 #define ioremap_nocache(phy, sz)	ioremap(phy, sz)

commit 0890a264794f33df540fbaf274699146903b4e6b
Merge: 05a8256c586a 40b8ad8f762c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Jul 1 09:24:26 2015 -0700

    Merge tag 'arc-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/vgupta/arc
    
    Pull ARC architecture updates from Vineet Gupta:
    
     - support for HS38 cores based on ARCv2 ISA
    
         ARCv2 is the next generation ISA from Synopsys and basis for the
         HS3{4,6,8} families of processors which retain the traditional ARC mantra of
         low power and configurability and are now more performant and feature rich.
    
         HS38x is a 10 stage pipeline core which supports MMU (with huge pages) and
         SMP (upto 4 cores) among other features.
    
         + www.synopsys.com/dw/ipdir.php?ds=arc-hs38-processor
         + http://news.synopsys.com/2014-10-14-New-DesignWare-ARC-HS38-Processor-Doubles-Performance-for-Embedded-Linux-Applications
         + http://www.embedded.com/electronics-news/4435975/Synopsys-ARC-HS38-core-gives-2X-boost-to-Linux-based-apps
    
     - support for ARC SDP (Software Development platform): Main Board + CPU Cards
        = AXS101: CPU Card with ARC700 in silicon @ 700 MHz
        = AXS103: CPU Card with HS38x in FPGA
    
     - refactoring of ARCompact port to accomodate new ARCv2 ISA
    
     - misc updates/cleanups
    
    * tag 'arc-4.2-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/vgupta/arc: (72 commits)
      ARC: Fix build failures for ARCompact in linux-next after ARCv2 support
      ARCv2: Allow older gcc to cope with new regime of ARCv2/ARCompact support
      ARCv2: [vdk] dts files and defconfig for HS38 VDK
      ARCv2: [axs103] Support ARC SDP FPGA platform for HS38x cores
      ARC: [axs101] Prepare for AXS103
      ARCv2: [nsim*hs*] Support simulation platforms for HS38x cores
      ARCv2: All bits in place, allow ARCv2 builds
      ARCv2: SLC: Handle explcit flush for DMA ops (w/o IO-coherency)
      ARCv2: STAR 9000837815 workaround hardware exclusive transactions livelock
      ARC: Reduce bitops lines of code using macros
      ARCv2: barriers
      arch: conditionally define smp_{mb,rmb,wmb}
      ARC: add smp barriers around atomics per Documentation/atomic_ops.txt
      ARC: add compiler barrier to LLSC based cmpxchg
      ARCv2: SMP: intc: IDU 2nd level intc for dynamic IRQ distribution
      ARCv2: SMP: clocksource: Enable Global Real Time counter
      ARCv2: SMP: ARConnect debug/robustness
      ARCv2: SMP: Support ARConnect (MCIP) for Inter-Core-Interrupts et al
      ARC: make plat_smp_ops weak to allow over-rides
      ARCv2: clocksource: Introduce 64bit local RTC counter
      ...

commit b8a033023994c4e59697bb3b16b441b38f258390
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Mar 11 21:42:37 2015 +0530

    ARCv2: barriers
    
    ARCv2 based HS38 cores are weakly ordered and thus explicit barriers for
    kernel proper.
    
    SMP barrier is provided by DMB instruction which also guarantees local
    barrier hence used as backend of smp_*mb() as well as *mb() APIs
    
    Also hookup barriers into MMIO accessors to avoid ordering issues in IO
    
    Cc: Peter Zijlstra (Intel) <peterz@infradead.org>
    Reviewed-by: Will Deacon <will.deacon@arm.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index cabd518cb253..00f97a2f5fa6 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -98,9 +98,45 @@ static inline void __raw_writel(u32 w, volatile void __iomem *addr)
 
 }
 
-#define readb_relaxed readb
-#define readw_relaxed readw
-#define readl_relaxed readl
+#ifdef CONFIG_ISA_ARCV2
+#include <asm/barrier.h>
+#define __iormb()		rmb()
+#define __iowmb()		wmb()
+#else
+#define __iormb()		do { } while (0)
+#define __iowmb()		do { } while (0)
+#endif
+
+/*
+ * MMIO can also get buffered/optimized in micro-arch, so barriers needed
+ * Based on ARM model for the typical use case
+ *
+ *	<ST [DMA buffer]>
+ *	<writel MMIO "go" reg>
+ *  or:
+ *	<readl MMIO "status" reg>
+ *	<LD [DMA buffer]>
+ *
+ * http://lkml.kernel.org/r/20150622133656.GG1583@arm.com
+ */
+#define readb(c)		({ u8  __v = readb_relaxed(c); __iormb(); __v; })
+#define readw(c)		({ u16 __v = readw_relaxed(c); __iormb(); __v; })
+#define readl(c)		({ u32 __v = readl_relaxed(c); __iormb(); __v; })
+
+#define writeb(v,c)		({ __iowmb(); writeb_relaxed(v,c); })
+#define writew(v,c)		({ __iowmb(); writew_relaxed(v,c); })
+#define writel(v,c)		({ __iowmb(); writel_relaxed(v,c); })
+
+/*
+ * Relaxed API for drivers which can handle any ordering themselves
+ */
+#define readb_relaxed(c)	__raw_readb(c)
+#define readw_relaxed(c)	__raw_readw(c)
+#define readl_relaxed(c)	__raw_readl(c)
+
+#define writeb_relaxed(v,c)	__raw_writeb(v,c)
+#define writew_relaxed(v,c)	__raw_writew(v,c)
+#define writel_relaxed(v,c)	__raw_writel(v,c)
 
 #include <asm-generic/io.h>
 

commit 556269c138a8b2d3f5714b8105fa6119ecc505f2
Author: Toshi Kani <toshi.kani@hp.com>
Date:   Thu Jun 4 18:55:16 2015 +0200

    arch/*/io.h: Add ioremap_wt() to all architectures
    
    Add ioremap_wt() to all arch-specific asm/io.h headers which
    define ioremap_wc() locally. These headers do not include
    <asm-generic/iomap.h>. Some of them include <asm-generic/io.h>,
    but ioremap_wt() is defined for consistency since they define
    all ioremap_xxx locally.
    
    In all architectures without Write-Through support, ioremap_wt()
    is defined indentical to ioremap_nocache().
    
    frv and m68k already have ioremap_writethrough(). On those we
    add ioremap_wt() indetical to ioremap_writethrough() and defines
    ARCH_HAS_IOREMAP_WT in both architectures.
    
    The ioremap_wt() interface is exported to drivers.
    
    Signed-off-by: Toshi Kani <toshi.kani@hp.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Elliott@hp.com
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: arnd@arndb.de
    Cc: hch@lst.de
    Cc: hmh@hmh.eng.br
    Cc: jgross@suse.com
    Cc: konrad.wilk@oracle.com
    Cc: linux-mm <linux-mm@kvack.org>
    Cc: linux-nvdimm@lists.01.org
    Cc: stefan.bader@canonical.com
    Cc: yigal@plexistor.com
    Link: http://lkml.kernel.org/r/1433436928-31903-9-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index cabd518cb253..7cc4ced5dbf4 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -20,6 +20,7 @@ extern void iounmap(const void __iomem *addr);
 
 #define ioremap_nocache(phy, sz)	ioremap(phy, sz)
 #define ioremap_wc(phy, sz)		ioremap(phy, sz)
+#define ioremap_wt(phy, sz)		ioremap(phy, sz)
 
 /* Change struct page to physical address */
 #define page_to_phys(page)		(page_to_pfn(page) << PAGE_SHIFT)

commit bfb111ec255c82f2501d2898c5d26f39959c0111
Author: Thierry Reding <treding@nvidia.com>
Date:   Mon Jul 7 12:30:50 2014 +0200

    ARC: Remove redundant PCI_IOBASE declaration
    
    ARC's asm/io.h includes the asm-generic/io.h which already defines the
    PCI_IOBASE variable in exactly the same way, so it can be dropped from
    the architecture specific header.
    
    Signed-off-by: Thierry Reding <treding@nvidia.com>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index 334ce7017a18..cabd518cb253 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -13,8 +13,6 @@
 #include <asm/byteorder.h>
 #include <asm/page.h>
 
-#define PCI_IOBASE ((void __iomem *)0)
-
 extern void __iomem *ioremap(unsigned long physaddr, unsigned long size);
 extern void __iomem *ioremap_prot(phys_addr_t offset, unsigned long size,
 				  unsigned long flags);

commit 6532b02fe5affb962b267e3c12e87ec16311aebf
Author: Mischa Jonker <mjonker@synopsys.com>
Date:   Wed Aug 28 20:32:50 2013 +0200

    ARC: Add read*_relaxed to asm/io.h
    
    Some drivers require these, and ARC didn't had them yet.
    
    Signed-off-by: Mischa Jonker <mjonker@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index 473424d7528b..334ce7017a18 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -100,6 +100,10 @@ static inline void __raw_writel(u32 w, volatile void __iomem *addr)
 
 }
 
+#define readb_relaxed readb
+#define readw_relaxed readw
+#define readl_relaxed readl
+
 #include <asm-generic/io.h>
 
 #endif /* _ASM_ARC_IO_H */

commit 4368902bb90f0e208387f336c3fce0e6b2a110fc
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Tue Jan 22 16:48:45 2013 +0530

    ARC: Add support for ioremap_prot API
    
    Implement ioremap_prot() to allow mapping IO memory with variable
    protection
    via TLB.
    
    Implementing this allows the /dev/mem driver to use its generic access()
    VMA callback, which in turn allows ptrace to examine data in memory
    mapped regions mapped via /dev/mem, such as Arc DCCM.
    
    The end result is that it is possible to examine values of variables
    placed into DCCM in user space programs via GDB.
    
    CC: Alexey Brodkin <Alexey.Brodkin@synopsys.com>
    CC: Noam Camus <noamc@ezchip.com>
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
index d20051bbbf02..473424d7528b 100644
--- a/arch/arc/include/asm/io.h
+++ b/arch/arc/include/asm/io.h
@@ -16,6 +16,8 @@
 #define PCI_IOBASE ((void __iomem *)0)
 
 extern void __iomem *ioremap(unsigned long physaddr, unsigned long size);
+extern void __iomem *ioremap_prot(phys_addr_t offset, unsigned long size,
+				  unsigned long flags);
 extern void iounmap(const void __iomem *addr);
 
 #define ioremap_nocache(phy, sz)	ioremap(phy, sz)

commit 1162b0701b14ba112d4e3fe5c27c694caf983539
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:20 2013 +0530

    ARC: I/O and DMA Mappings
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/io.h b/arch/arc/include/asm/io.h
new file mode 100644
index 000000000000..d20051bbbf02
--- /dev/null
+++ b/arch/arc/include/asm/io.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef _ASM_ARC_IO_H
+#define _ASM_ARC_IO_H
+
+#include <linux/types.h>
+#include <asm/byteorder.h>
+#include <asm/page.h>
+
+#define PCI_IOBASE ((void __iomem *)0)
+
+extern void __iomem *ioremap(unsigned long physaddr, unsigned long size);
+extern void iounmap(const void __iomem *addr);
+
+#define ioremap_nocache(phy, sz)	ioremap(phy, sz)
+#define ioremap_wc(phy, sz)		ioremap(phy, sz)
+
+/* Change struct page to physical address */
+#define page_to_phys(page)		(page_to_pfn(page) << PAGE_SHIFT)
+
+#define __raw_readb __raw_readb
+static inline u8 __raw_readb(const volatile void __iomem *addr)
+{
+	u8 b;
+
+	__asm__ __volatile__(
+	"	ldb%U1 %0, %1	\n"
+	: "=r" (b)
+	: "m" (*(volatile u8 __force *)addr)
+	: "memory");
+
+	return b;
+}
+
+#define __raw_readw __raw_readw
+static inline u16 __raw_readw(const volatile void __iomem *addr)
+{
+	u16 s;
+
+	__asm__ __volatile__(
+	"	ldw%U1 %0, %1	\n"
+	: "=r" (s)
+	: "m" (*(volatile u16 __force *)addr)
+	: "memory");
+
+	return s;
+}
+
+#define __raw_readl __raw_readl
+static inline u32 __raw_readl(const volatile void __iomem *addr)
+{
+	u32 w;
+
+	__asm__ __volatile__(
+	"	ld%U1 %0, %1	\n"
+	: "=r" (w)
+	: "m" (*(volatile u32 __force *)addr)
+	: "memory");
+
+	return w;
+}
+
+#define __raw_writeb __raw_writeb
+static inline void __raw_writeb(u8 b, volatile void __iomem *addr)
+{
+	__asm__ __volatile__(
+	"	stb%U1 %0, %1	\n"
+	:
+	: "r" (b), "m" (*(volatile u8 __force *)addr)
+	: "memory");
+}
+
+#define __raw_writew __raw_writew
+static inline void __raw_writew(u16 s, volatile void __iomem *addr)
+{
+	__asm__ __volatile__(
+	"	stw%U1 %0, %1	\n"
+	:
+	: "r" (s), "m" (*(volatile u16 __force *)addr)
+	: "memory");
+
+}
+
+#define __raw_writel __raw_writel
+static inline void __raw_writel(u32 w, volatile void __iomem *addr)
+{
+	__asm__ __volatile__(
+	"	st%U1 %0, %1	\n"
+	:
+	: "r" (w), "m" (*(volatile u32 __force *)addr)
+	: "memory");
+
+}
+
+#include <asm-generic/io.h>
+
+#endif /* _ASM_ARC_IO_H */
