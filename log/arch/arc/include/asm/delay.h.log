commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arc/include/asm/delay.h b/arch/arc/include/asm/delay.h
index 03d6bb0f4e13..54db798f0aa0 100644
--- a/arch/arc/include/asm/delay.h
+++ b/arch/arc/include/asm/delay.h
@@ -1,10 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Delay routines using pre computed loops_per_jiffy value.
  *
  * vineetg: Feb 2012

commit 2423665ec53f2a29191b35382075e9834288a975
Author: Randy Dunlap <rdunlap@infradead.org>
Date:   Thu Jul 26 20:16:35 2018 -0700

    arc: fix build errors in arc/include/asm/delay.h
    
    Fix build errors in arch/arc/'s delay.h:
    - add "extern unsigned long loops_per_jiffy;"
    - add <asm-generic/types.h> for "u64"
    
    In file included from ../drivers/infiniband/hw/cxgb3/cxio_hal.c:32:
    ../arch/arc/include/asm/delay.h: In function '__udelay':
    ../arch/arc/include/asm/delay.h:61:12: error: 'u64' undeclared (first use in this function)
      loops = ((u64) usecs * 4295 * HZ * loops_per_jiffy) >> 32;
                ^~~
    
    In file included from ../drivers/infiniband/hw/cxgb3/cxio_hal.c:32:
    ../arch/arc/include/asm/delay.h: In function '__udelay':
    ../arch/arc/include/asm/delay.h:63:37: error: 'loops_per_jiffy' undeclared (first use in this function)
      loops = ((u64) usecs * 4295 * HZ * loops_per_jiffy) >> 32;
                                         ^~~~~~~~~~~~~~~
    
    Signed-off-by: Randy Dunlap <rdunlap@infradead.org>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: linux-snps-arc@lists.infradead.org
    Cc: Elad Kanfi <eladkan@mellanox.com>
    Cc: Leon Romanovsky <leonro@mellanox.com>
    Cc: Ofer Levi <oferle@mellanox.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/delay.h b/arch/arc/include/asm/delay.h
index d5da2115d78a..03d6bb0f4e13 100644
--- a/arch/arc/include/asm/delay.h
+++ b/arch/arc/include/asm/delay.h
@@ -17,8 +17,11 @@
 #ifndef __ASM_ARC_UDELAY_H
 #define __ASM_ARC_UDELAY_H
 
+#include <asm-generic/types.h>
 #include <asm/param.h>		/* HZ */
 
+extern unsigned long loops_per_jiffy;
+
 static inline void __delay(unsigned long loops)
 {
 	__asm__ __volatile__(

commit 36425cd67052e3becf325fd4d3ba5691791ef7e4
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue Jan 24 10:23:42 2017 -0800

    ARC: udelay: fix inline assembler by adding LP_COUNT to clobber list
    
    commit 3c7c7a2fc8811bc ("ARC: Don't use "+l" inline asm constraint")
    modified the inline assembly to setup LP_COUNT register manually and NOT
    rely on gcc to do it (with the +l inline assembler contraint hint, now
    being retired in the compiler)
    
    However the fix was flawed as we didn't add LP_COUNT to asm clobber list,
    meaning gcc doesn't know that LP_COUNT or zero-delay-loops are in action
    in the inline asm.
    
    This resulted in some fun - as nested ZOL loops were being generared
    
    | mov lp_count,250000 ;16 # tmp235,
    | lp .L__GCC__LP14 #            <======= OUTER LOOP (gcc generated)
    |   .L14:
    |   ld r2, [r5] # MEM[(volatile u32 *)prephitmp_43], w
    |   dmb 1
    |   breq r2, -1, @.L21 #, w,,
    |   bbit0 r2,1,@.L13 # w,,
    |   ld r4,[r7] ;25 # loops_per_jiffy, loops_per_jiffy
    |   mpymu r3,r4,r6 #, loops_per_jiffy, tmp234
    |
    |   mov lp_count, r3 #           <====== INNER LOOP (from inline asm)
    |   lp 1f
    |        nop
    |   1:
    |   nop_s
    | .L__GCC__LP14: ; loop end, start is @.L14 #,
    
    This caused issues with drivers relying on sane behaviour of udelay
    friends.
    
    With LP_COUNT added to clobber list, gcc doesn't generate the outer
    loop in say above case.
    
    Addresses STAR 9001146134
    
    Reported-by: Joao Pinto <jpinto@synopsys.com>
    Fixes: 3c7c7a2fc8811bc ("ARC: Don't use "+l" inline asm constraint")
    Cc: stable@vger.kernel.org
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/delay.h b/arch/arc/include/asm/delay.h
index a36e8601114d..d5da2115d78a 100644
--- a/arch/arc/include/asm/delay.h
+++ b/arch/arc/include/asm/delay.h
@@ -26,7 +26,9 @@ static inline void __delay(unsigned long loops)
 	"	lp  1f			\n"
 	"	nop			\n"
 	"1:				\n"
-	: : "r"(loops));
+	:
+        : "r"(loops)
+        : "lp_count");
 }
 
 extern void __bad_udelay(void);

commit 3c7c7a2fc8811bc7097479f69acf2527693d7562
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Nov 23 17:43:17 2016 -0800

    ARC: Don't use "+l" inline asm constraint
    
    Apparenty this is coming in the way of gcc fix which inhibits the usage
    of LP_COUNT as a gpr.
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/delay.h b/arch/arc/include/asm/delay.h
index 08e7e2a16ac1..a36e8601114d 100644
--- a/arch/arc/include/asm/delay.h
+++ b/arch/arc/include/asm/delay.h
@@ -22,10 +22,11 @@
 static inline void __delay(unsigned long loops)
 {
 	__asm__ __volatile__(
-	"	lp  1f	\n"
-	"	nop	\n"
-	"1:		\n"
-	: "+l"(loops));
+	"	mov lp_count, %0	\n"
+	"	lp  1f			\n"
+	"	nop			\n"
+	"1:				\n"
+	: : "r"(loops));
 }
 
 extern void __bad_udelay(void);

commit 8922bc3058abbe5deaf887147e26531750ce7513
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon Oct 7 18:10:08 2013 +0530

    ARCv2: Adhere to Zero Delay loop restriction
    
    Branch insn can't be scheduled as last insn of Zero Overhead loop
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/delay.h b/arch/arc/include/asm/delay.h
index 43de30256981..08e7e2a16ac1 100644
--- a/arch/arc/include/asm/delay.h
+++ b/arch/arc/include/asm/delay.h
@@ -22,11 +22,10 @@
 static inline void __delay(unsigned long loops)
 {
 	__asm__ __volatile__(
-	"1:	sub.f %0, %0, 1	\n"
-	"	jpnz 1b		\n"
-	: "+r"(loops)
-	:
-	: "cc");
+	"	lp  1f	\n"
+	"	nop	\n"
+	"1:		\n"
+	: "+l"(loops));
 }
 
 extern void __bad_udelay(void);

commit 7efd0da2d17360e1cef91507dbe619db0ee2c691
Author: Mischa Jonker <mjonker@synopsys.com>
Date:   Fri Aug 30 11:56:25 2013 +0200

    ARC: Fix __udelay calculation
    
    Cast usecs to u64, to ensure that the (usecs * 4295 * HZ)
    multiplication is 64 bit.
    
    Initially, the (usecs * 4295 * HZ) part was done as a 32 bit
    multiplication, with the result casted to 64 bit. This led to some bits
    falling off, causing a "DMA initialization error" in the stmmac Ethernet
    driver, due to a premature timeout.
    
    Signed-off-by: Mischa Jonker <mjonker@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/delay.h b/arch/arc/include/asm/delay.h
index 442ce5d0f709..43de30256981 100644
--- a/arch/arc/include/asm/delay.h
+++ b/arch/arc/include/asm/delay.h
@@ -53,11 +53,10 @@ static inline void __udelay(unsigned long usecs)
 {
 	unsigned long loops;
 
-	/* (long long) cast ensures 64 bit MPY - real or emulated
+	/* (u64) cast ensures 64 bit MPY - real or emulated
 	 * HZ * 4295 is pre-evaluated by gcc - hence only 2 mpy ops
 	 */
-	loops = ((long long)(usecs * 4295 * HZ) *
-		 (long long)(loops_per_jiffy)) >> 32;
+	loops = ((u64) usecs * 4295 * HZ * loops_per_jiffy) >> 32;
 
 	__delay(loops);
 }

commit d8005e6b95268cbb50db3773d5f180c32a9434fe
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:18 2013 +0530

    ARC: Timers/counters/delay management
    
    ARC700 includes 2 in-core 32bit timers TIMER0 and TIMER1.
    Both have exactly same capabilies.
    
    * programmable to count from TIMER<n>_CNT to TIMER<n>_LIMIT
    * for count 0 and LIMIT ~1, provides a free-running counter by
        auto-wrapping when limit is reached.
    * optionally interrupt when LIMIT is reached (oneshot event semantics)
    * rearming the interrupt provides periodic semantics
    * run at CPU clk
    
    ARC Linux uses TIMER0 for clockevent (periodic/oneshot) and TIMER1 for
    clocksource (free-running clock).
    
    Newer cores provide RTSC insn which gives a 64bit cpu clk snapshot hence
    is more apt for clocksource when available.
    
    SMP poses a bit of challenge for global timekeeping clocksource /
    sched_clock() backend:
     -TIMER1 based local clocks are out-of-sync hence can't be used
      (thus we default to jiffies based cs as well as sched_clock() one/both
      of which platform can override with it's specific hardware assist)
     -RTSC is only allowed in SMP if it's cross-core-sync (Kconfig glue
      ensures that) and thus usable for both requirements.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arc/include/asm/delay.h b/arch/arc/include/asm/delay.h
new file mode 100644
index 000000000000..442ce5d0f709
--- /dev/null
+++ b/arch/arc/include/asm/delay.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Delay routines using pre computed loops_per_jiffy value.
+ *
+ * vineetg: Feb 2012
+ *  -Rewrote in "C" to avoid dealing with availability of H/w MPY
+ *  -Also reduced the num of MPY operations from 3 to 2
+ *
+ * Amit Bhor: Codito Technologies 2004
+ */
+
+#ifndef __ASM_ARC_UDELAY_H
+#define __ASM_ARC_UDELAY_H
+
+#include <asm/param.h>		/* HZ */
+
+static inline void __delay(unsigned long loops)
+{
+	__asm__ __volatile__(
+	"1:	sub.f %0, %0, 1	\n"
+	"	jpnz 1b		\n"
+	: "+r"(loops)
+	:
+	: "cc");
+}
+
+extern void __bad_udelay(void);
+
+/*
+ * Normal Math for computing loops in "N" usecs
+ *  -we have precomputed @loops_per_jiffy
+ *  -1 sec has HZ jiffies
+ * loops per "N" usecs = ((loops_per_jiffy * HZ / 1000000) * N)
+ *
+ * Approximate Division by multiplication:
+ *  -Mathematically if we multiply and divide a number by same value the
+ *   result remains unchanged:  In this case, we use 2^32
+ *  -> (loops_per_N_usec * 2^32 ) / 2^32
+ *  -> (((loops_per_jiffy * HZ / 1000000) * N) * 2^32) / 2^32
+ *  -> (loops_per_jiffy * HZ * N * 4295) / 2^32
+ *
+ *  -Divide by 2^32 is very simply right shift by 32
+ *  -We simply need to ensure that the multiply per above eqn happens in
+ *   64-bit precision (if CPU doesn't support it - gcc can emaulate it)
+ */
+
+static inline void __udelay(unsigned long usecs)
+{
+	unsigned long loops;
+
+	/* (long long) cast ensures 64 bit MPY - real or emulated
+	 * HZ * 4295 is pre-evaluated by gcc - hence only 2 mpy ops
+	 */
+	loops = ((long long)(usecs * 4295 * HZ) *
+		 (long long)(loops_per_jiffy)) >> 32;
+
+	__delay(loops);
+}
+
+#define udelay(n) (__builtin_constant_p(n) ? ((n) > 20000 ? __bad_udelay() \
+				: __udelay(n)) : __udelay(n))
+
+#endif /* __ASM_ARC_UDELAY_H */
