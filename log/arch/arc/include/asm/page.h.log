commit c62da0c35d58518ddb26ff641d2485596567fd96
Author: Anshuman Khandual <anshuman.khandual@arm.com>
Date:   Fri Apr 10 14:33:05 2020 -0700

    mm/vma: define a default value for VM_DATA_DEFAULT_FLAGS
    
    There are many platforms with exact same value for VM_DATA_DEFAULT_FLAGS
    This creates a default value for VM_DATA_DEFAULT_FLAGS in line with the
    existing VM_STACK_DEFAULT_FLAGS.  While here, also define some more
    macros with standard VMA access flag combinations that are used
    frequently across many platforms.  Apart from simplification, this
    reduces code duplication as well.
    
    Signed-off-by: Anshuman Khandual <anshuman.khandual@arm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Reviewed-by: Vlastimil Babka <vbabka@suse.cz>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paulburton@kernel.org>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: "James E.J. Bottomley" <James.Bottomley@HansenPartnership.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Rich Felker <dalias@libc.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Chris Zankel <chris@zankel.net>
    Link: http://lkml.kernel.org/r/1583391014-8170-2-git-send-email-anshuman.khandual@arm.com
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 0a32e8cfd074..b0dfed0f12be 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -102,7 +102,7 @@ typedef pte_t * pgtable_t;
 #define virt_addr_valid(kaddr)  pfn_valid(virt_to_pfn(kaddr))
 
 /* Default Permissions for stack/heaps pages (Non Executable) */
-#define VM_DATA_DEFAULT_FLAGS   (VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+#define VM_DATA_DEFAULT_FLAGS	VM_DATA_FLAGS_NON_EXEC
 
 #define WANT_PAGE_VIRTUAL   1
 

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 09ddddf71cc5..0a32e8cfd074 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -1,9 +1,6 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 #ifndef __ASM_ARC_PAGE_H
 #define __ASM_ARC_PAGE_H

commit 93312b6da4df31e4102ce5420e6217135a16c7ea
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Jul 11 10:42:20 2018 -0700

    ARC: mm: allow mprotect to make stack mappings executable
    
    mprotect(EXEC) was failing for stack mappings as default vm flags was
    missing MAYEXEC.
    
    This was triggered by glibc test suite nptl/tst-execstack testcase
    
    What is surprising is that despite running LTP for years on, we didn't
    catch this issue as it lacks a directed test case.
    
    gcc dejagnu tests with nested functions also requiring exec stack work
    fine though because they rely on the GNU_STACK segment spit out by
    compiler and handled in kernel elf loader.
    
    This glibc case is different as the stack is non exec to begin with and
    a dlopen of shared lib with GNU_STACK segment triggers the exec stack
    proceedings using a mprotect(PROT_EXEC) which was broken.
    
    CC: stable@vger.kernel.org
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 109baa06831c..09ddddf71cc5 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -105,7 +105,7 @@ typedef pte_t * pgtable_t;
 #define virt_addr_valid(kaddr)  pfn_valid(virt_to_pfn(kaddr))
 
 /* Default Permissions for stack/heaps pages (Non Executable) */
-#define VM_DATA_DEFAULT_FLAGS   (VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE)
+#define VM_DATA_DEFAULT_FLAGS   (VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
 
 #define WANT_PAGE_VIRTUAL   1
 

commit 9ed68785f7f2b001a6911d64fbd10cfc6fa49b27
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Tue Aug 15 21:13:54 2017 +0300

    ARC: mm: Decouple RAM base address from kernel link address
    
            [Needed for HSDK]
    
    Currently the first page of system (hence RAM base) is assumed to be
    @ CONFIG_LINUX_LINK_BASE, where kernel itself is linked.
    
    However is case of HSDK platform, for reasons explained in that patch,
    this is not true. kernel needs to be linked @ 0x9000_0000 while DDR
    is still wired at 0x8000_0000. To properly account for this 256M of RAM,
    we need to introduce a new option and base page frame accountiing off of
    it.
    
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    [vgupta: renamed  CONFIG_KERNEL_RAM_BASE_ADDRESS => CONFIG_LINUX_RAM_BASE
           : simplified changelog]

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 296c3426a6ad..109baa06831c 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -85,7 +85,7 @@ typedef pte_t * pgtable_t;
  */
 #define virt_to_pfn(kaddr)	(__pa(kaddr) >> PAGE_SHIFT)
 
-#define ARCH_PFN_OFFSET		virt_to_pfn(CONFIG_LINUX_LINK_BASE)
+#define ARCH_PFN_OFFSET		virt_to_pfn(CONFIG_LINUX_RAM_BASE)
 
 #ifdef CONFIG_FLATMEM
 #define pfn_valid(pfn)		(((pfn) - ARCH_PFN_OFFSET) < max_mapnr)

commit 5035cd5b666b7378e32e1985225aae5746a59ac9
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue May 3 14:53:40 2016 +0530

    ARC: pae: STRICT_MM_TYPECHECKS was broken
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 0d53854884d0..296c3426a6ad 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -31,7 +31,11 @@ void clear_user_page(void *to, unsigned long u_vaddr, struct page *page);
  * These are used to make use of C type-checking..
  */
 typedef struct {
+#ifdef CONFIG_ARC_HAS_PAE40
+	unsigned long long pte;
+#else
 	unsigned long pte;
+#endif
 } pte_t;
 typedef struct {
 	unsigned long pgd;

commit 26f9d5fd82ca20fe536cb493ec7cf5628f8997e5
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon Apr 18 10:49:56 2016 +0530

    ARC: support HIGHMEM even without PAE40
    
    Initial HIGHMEM support on ARC was introduced for PAE40 where the low
    memory (0x8000_0000 based) and high memory (0x1_0000_0000) were
    physically contiguous. So CONFIG_FLATMEM sufficed (despite a peipheral
    hole in the middle, which wasted a bit of struct page memory, but things
    worked).
    
    However w/o PAE, highmem was not possible and we could only reach
    ~1.75GB of DDR. Now there is a use case to access ~4GB of DDR w/o PAE40
    The idea is to have low memory at canonical 0x8000_0000 and highmem
    at 0 so enire 4GB address space is available for physical addressing
    This needs additional platform/interconnect mapping to convert
    the non contiguous physical addresses into linear bus adresses.
    
    From Linux point of view, non contiguous divide means FLATMEM no
    longer works and DISCONTIGMEM is needed to track the pfns in the 2
    regions.
    
    This scheme would also work for PAE40, only better in that we don't
    waste struct page memory for the peripheral hole.
    
    The DT description will be something like
    
        memory {
            ...
            reg = <0x80000000 0x200000000   /* 512MB: lowmem */
                   0x00000000 0x10000000>;  /* 256MB: highmem */
       }
    
    Signed-off-by: Noam Camus <noamc@ezchip.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 533e5a0c6ba5..0d53854884d0 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -83,7 +83,9 @@ typedef pte_t * pgtable_t;
 
 #define ARCH_PFN_OFFSET		virt_to_pfn(CONFIG_LINUX_LINK_BASE)
 
+#ifdef CONFIG_FLATMEM
 #define pfn_valid(pfn)		(((pfn) - ARCH_PFN_OFFSET) < max_mapnr)
+#endif
 
 /*
  * __pa, __va, virt_to_page (ALERT: deprecated, don't use them)
@@ -95,9 +97,7 @@ typedef pte_t * pgtable_t;
 #define __pa(vaddr)  ((unsigned long)(vaddr))
 #define __va(paddr)  ((void *)((unsigned long)(paddr)))
 
-#define virt_to_page(kaddr)	\
-	(mem_map + virt_to_pfn((kaddr) - CONFIG_LINUX_LINK_BASE))
-
+#define virt_to_page(kaddr)	pfn_to_page(virt_to_pfn(kaddr))
 #define virt_addr_valid(kaddr)  pfn_valid(virt_to_pfn(kaddr))
 
 /* Default Permissions for stack/heaps pages (Non Executable) */

commit 2519d753676bdf2460fbbcde276d5b6ba8d6b695
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu May 5 14:53:48 2016 +0530

    ARC: Fix PAE40 boot failures due to PTE truncation
    
    So a benign looking cleanup which macro'ized PAGE_SHIFT shifts turned
    out to be bad (since it was done non-sensically across the board).
    
    It caused boot failures with PAE40 as forced cast to (unsigned long)
    from newly introduced virt_to_pfn() was causing truncatiion of the
    (long long) pte/paddr values.
    
    It is OK to use this in accessors dealing with kernel virtual address,
    pointers etc, but not for PTE values themelves.
    
    Fixes: cJ2ff5cf2735c ("ARC: mm: Use virt_to_pfn() for addr >> PAGE_SHIFT pattern)
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 36da89e2c853..533e5a0c6ba5 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -72,6 +72,13 @@ typedef unsigned long pgprot_t;
 
 typedef pte_t * pgtable_t;
 
+/*
+ * Use virt_to_pfn with caution:
+ * If used in pte or paddr related macros, it could cause truncation
+ * in PAE40 builds
+ * As a rule of thumb, only use it in helpers starting with virt_
+ * You have been warned !
+ */
 #define virt_to_pfn(kaddr)	(__pa(kaddr) >> PAGE_SHIFT)
 
 #define ARCH_PFN_OFFSET		virt_to_pfn(CONFIG_LINUX_LINK_BASE)
@@ -85,7 +92,7 @@ typedef pte_t * pgtable_t;
  * virt here means link-address/program-address as embedded in object code.
  * And for ARC, link-addr = physical address
  */
-#define __pa(vaddr)  ((unsigned long)vaddr)
+#define __pa(vaddr)  ((unsigned long)(vaddr))
 #define __va(paddr)  ((void *)((unsigned long)(paddr)))
 
 #define virt_to_page(kaddr)	\

commit 11caf57f6a4b8e380001548b8af0a3ae3f7b4354
Merge: 3d66c6ba3f97 a1cbaad75a8f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 24 23:13:48 2016 -0700

    Merge tag 'asm-generic-4.6' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic
    
    Pull asm-generic updates from Arnd Bergmann:
     "There are only three patches this time, most other changes to files in
      include/asm-generic tend to go through the tree of whoever depends on
      the change.
    
      Two patches are cleanups for stuff that is no longer needed, the main
      change is to adapt the generic version of BUG_ON() for CONFIG_BUG=n to
      make it behave consistently with BUG().
    
      This avoids undefined behavior along with a number of warnings about
      that undefined behavior in randconfig builds when we keep going on
      after hitting a BUG_ON()"
    
    * tag 'asm-generic-4.6' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/asm-generic:
      asm-generic: remove old nonatomic-io wrapper files
      asm-generic: default BUG_ON(x) to if(x)BUG()
      asm-generic: page.h: Remove useless get_user_page and free_user_page

commit c2ff5cf2735c57542b8e630e63d6983013a2e1c3
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Dec 18 13:57:41 2015 +0530

    ARC: mm: Use virt_to_pfn() for addr >> PAGE_SHIFT pattern
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 429957f1c236..9a7cf521b95c 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -10,7 +10,6 @@
 
 #include <uapi/asm/page.h>
 
-
 #ifndef __ASSEMBLY__
 
 #define get_user_page(vaddr)		__get_free_page(GFP_KERNEL)
@@ -76,30 +75,26 @@ typedef unsigned long pgprot_t;
 
 typedef pte_t * pgtable_t;
 
-#define ARCH_PFN_OFFSET     (CONFIG_LINUX_LINK_BASE >> PAGE_SHIFT)
+#define virt_to_pfn(kaddr)	(__pa(kaddr) >> PAGE_SHIFT)
+
+#define ARCH_PFN_OFFSET		virt_to_pfn(CONFIG_LINUX_LINK_BASE)
 
-#define pfn_valid(pfn)      (((pfn) - ARCH_PFN_OFFSET) < max_mapnr)
+#define pfn_valid(pfn)		(((pfn) - ARCH_PFN_OFFSET) < max_mapnr)
 
 /*
  * __pa, __va, virt_to_page (ALERT: deprecated, don't use them)
  *
  * These macros have historically been misnamed
  * virt here means link-address/program-address as embedded in object code.
- * So if kernel img is linked at 0x8000_0000 onwards, 0x8010_0000 will be
- * 128th page, and virt_to_page( ) will return the struct page corresp to it.
- * mem_map[ ] is an array of struct page for each page frame in the system
- *
- * Independent of where linux is linked at, link-addr = physical address
- * So the old macro  __pa = vaddr + PAGE_OFFSET - CONFIG_LINUX_LINK_BASE
- * would have been wrong in case kernel is not at 0x8zs
+ * And for ARC, link-addr = physical address
  */
 #define __pa(vaddr)  ((unsigned long)vaddr)
 #define __va(paddr)  ((void *)((unsigned long)(paddr)))
 
 #define virt_to_page(kaddr)	\
-	(mem_map + ((__pa(kaddr) - CONFIG_LINUX_LINK_BASE) >> PAGE_SHIFT))
+	(mem_map + virt_to_pfn((kaddr) - CONFIG_LINUX_LINK_BASE))
 
-#define virt_addr_valid(kaddr)  pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
+#define virt_addr_valid(kaddr)  pfn_valid(virt_to_pfn(kaddr))
 
 /* Default Permissions for stack/heaps pages (Non Executable) */
 #define VM_DATA_DEFAULT_FLAGS   (VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE)

commit 4e0b6ca9dace8dc0731571efd2bf1897fcb11938
Author: Chen Gang <gang.chen.5i5j@gmail.com>
Date:   Thu Nov 19 03:24:42 2015 +0800

    asm-generic: page.h: Remove useless get_user_page and free_user_page
    
    They are not symmetric with each other, neither are used in real world
    (can not be found by grep command in source code root directory), so
    remove them.
    
    Signed-off-by: Chen Gang <gang.chen.5i5j@gmail.com>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Ungerer <gerg@uclinux.org>
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 429957f1c236..adf5cbb141a5 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -13,9 +13,6 @@
 
 #ifndef __ASSEMBLY__
 
-#define get_user_page(vaddr)		__get_free_page(GFP_KERNEL)
-#define free_user_page(page, addr)	free_page(addr)
-
 #define clear_page(paddr)		memset((paddr), 0, PAGE_SIZE)
 #define copy_page(to, from)		memcpy((to), (from), PAGE_SIZE)
 

commit 5a364c2a1762e8a78721fafc93144509c0b6cb84
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Feb 6 18:44:57 2015 +0300

    ARC: mm: PAE40 support
    
    This is the first working implementation of 40-bit physical address
    extension on ARCv2.
    
    Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 37706837ef75..429957f1c236 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -56,7 +56,11 @@ typedef struct {
 
 #else /* !STRICT_MM_TYPECHECKS */
 
+#ifdef CONFIG_ARC_HAS_PAE40
+typedef unsigned long long pte_t;
+#else
 typedef unsigned long pte_t;
+#endif
 typedef unsigned long pgd_t;
 typedef unsigned long pgprot_t;
 

commit fe6c1b8611aa3a79a937a5e3b85a16576b6ad159
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue Jul 8 18:43:47 2014 +0530

    ARCv2: mm: THP support
    
    MMUv4 in HS38x cores supports Super Pages which are basis for Linux THP
    support.
    
    Normal and Super pages can co-exist (ofcourse not overlap) in TLB with a
    new bit "SZ" in TLB page desciptor to distinguish between them.
    Super Page size is configurable in hardware (4K to 16M), but fixed once
    RTL builds.
    
    The exact THP size a Linx configuration will support is a function of:
     - MMU page size (typical 8K, RTL fixed)
     - software page walker address split between PGD:PTE:PFN (typical
       11:8:13, but can be changed with 1 line)
    
    So for above default, THP size supported is 8K * 256 = 2M
    
    Default Page Walker is 2 levels, PGD:PTE:PFN, which in THP regime
    reduces to 1 level (as PTE is folded into PGD and canonically referred
    to as PMD).
    
    Thus thp PMD accessors are implemented in terms of PTE (just like sparc)
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 2994cac1069e..37706837ef75 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -64,6 +64,7 @@ typedef unsigned long pgprot_t;
 #define pgd_val(x)	(x)
 #define pgprot_val(x)	(x)
 #define __pte(x)	(x)
+#define __pgd(x)	(x)
 #define __pgprot(x)	(x)
 #define pte_pgprot(x)	(x)
 

commit e8a75963a4b9433dca55286e222f4dd1cc1ca76c
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Aug 28 08:39:57 2015 +0530

    ARC: mm: switch pgtable_to to pte_t *
    
    ARC is the only arch with unsigned long type (vs. struct page *).
    Historically this was done to avoid the page_address() calls in various
    arch hooks which need to get the virtual/logical address of the table.
    
    Some arches alternately define it as pte_t *, and is as efficient as
    unsigned long (generated code doesn't change)
    
    Suggested-by: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 9c8aa41e45c2..2994cac1069e 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -43,7 +43,6 @@ typedef struct {
 typedef struct {
 	unsigned long pgprot;
 } pgprot_t;
-typedef unsigned long pgtable_t;
 
 #define pte_val(x)      ((x).pte)
 #define pgd_val(x)      ((x).pgd)
@@ -60,7 +59,6 @@ typedef unsigned long pgtable_t;
 typedef unsigned long pte_t;
 typedef unsigned long pgd_t;
 typedef unsigned long pgprot_t;
-typedef unsigned long pgtable_t;
 
 #define pte_val(x)	(x)
 #define pgd_val(x)	(x)
@@ -71,6 +69,8 @@ typedef unsigned long pgtable_t;
 
 #endif
 
+typedef pte_t * pgtable_t;
+
 #define ARCH_PFN_OFFSET     (CONFIG_LINUX_LINK_BASE >> PAGE_SHIFT)
 
 #define pfn_valid(pfn)      (((pfn) - ARCH_PFN_OFFSET) < max_mapnr)

commit 3abc94480225677ea08af817d56edfb0df9e9b80
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Jun 5 17:49:14 2013 +0530

    ARC: [mm] Make stack/heap Non-executable by default
    
    1. For VM_EXEC based delayed dcache/icache flush, reduces the number of
       flushes.
    
    2. Makes this security feature ON by default rather than OFF before.
    
    3. Applications can use mprotect() to selectively override this.
    
    4. ELF binaries have a GNU_STACK segment which can easily override the
       kernel default permissions.
       For nested-functions/trampolines, gcc already auto-enables executable
       stack in elf. Others needing this can use -Wl,-z,execstack option.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index ab84bf131fe1..9c8aa41e45c2 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -96,13 +96,8 @@ typedef unsigned long pgtable_t;
 
 #define virt_addr_valid(kaddr)  pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
 
-/* Default Permissions for page, used in mmap.c */
-#ifdef CONFIG_ARC_STACK_NONEXEC
+/* Default Permissions for stack/heaps pages (Non Executable) */
 #define VM_DATA_DEFAULT_FLAGS   (VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE)
-#else
-#define VM_DATA_DEFAULT_FLAGS   (VM_READ | VM_WRITE | VM_EXEC | \
-				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
-#endif
 
 #define WANT_PAGE_VIRTUAL   1
 

commit 7bb66f6e6eecdd8e10ed3a63bd28c1e9105adc79
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Sat May 25 14:04:25 2013 +0530

    ARC: lazy dcache flush broke gdb in non-aliasing configs
    
    gdbserver inserting a breakpoint ends up calling copy_user_page() for a
    code page. The generic version of which (non-aliasing config) didn't set
    the PG_arch_1 bit hence update_mmu_cache() didn't sync dcache/icache for
    corresponding dynamic loader code page - causing garbade to be executed.
    
    So now aliasing versions of copy_user_highpage()/clear_page() are made
    default. There is no significant overhead since all of special alias
    handling code is compiled out for non-aliasing build
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 374a35514116..ab84bf131fe1 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -19,13 +19,6 @@
 #define clear_page(paddr)		memset((paddr), 0, PAGE_SIZE)
 #define copy_page(to, from)		memcpy((to), (from), PAGE_SIZE)
 
-#ifndef CONFIG_ARC_CACHE_VIPT_ALIASING
-
-#define clear_user_page(addr, vaddr, pg)	clear_page(addr)
-#define copy_user_page(vto, vfrom, vaddr, pg)	copy_page(vto, vfrom)
-
-#else	/* VIPT aliasing dcache */
-
 struct vm_area_struct;
 struct page;
 
@@ -35,8 +28,6 @@ void copy_user_highpage(struct page *to, struct page *from,
 			unsigned long u_vaddr, struct vm_area_struct *vma);
 void clear_user_page(void *to, unsigned long u_vaddr, struct page *page);
 
-#endif	/* CONFIG_ARC_CACHE_VIPT_ALIASING */
-
 #undef STRICT_MM_TYPECHECKS
 
 #ifdef STRICT_MM_TYPECHECKS

commit 4102b53392d6397d80b6e09b516517efacf7ea77
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu May 9 21:54:51 2013 +0530

    ARC: [mm] Aliasing VIPT dcache support 2/4
    
    This is the meat of the series which prevents any dcache alias creation
    by always keeping the U and K mapping of a page congruent.
    If a mapping already exists, and other tries to access the page, prev
    one is flushed to physical page (wback+inv)
    
    Essentially flush_dcache_page()/copy_user_highpage() create K-mapping
    of a page, but try to defer flushing, unless U-mapping exist.
    When page is actually mapped to userspace, update_mmu_cache() flushes
    the K-mapping (in certain cases this can be optimised out)
    
    Additonally flush_cache_mm(), flush_cache_range(), flush_cache_page()
    handle the puring of stale userspace mappings on exit/munmap...
    
    flush_anon_page() handles the existing U-mapping for anon page before
    kernel reads it via the GUP path.
    
    Note that while not complete, this is enough to boot a simple
    dynamically linked Busybox based rootfs
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index bdf546104551..374a35514116 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -16,13 +16,27 @@
 #define get_user_page(vaddr)		__get_free_page(GFP_KERNEL)
 #define free_user_page(page, addr)	free_page(addr)
 
-/* TBD: for now don't worry about VIPT D$ aliasing */
 #define clear_page(paddr)		memset((paddr), 0, PAGE_SIZE)
 #define copy_page(to, from)		memcpy((to), (from), PAGE_SIZE)
 
+#ifndef CONFIG_ARC_CACHE_VIPT_ALIASING
+
 #define clear_user_page(addr, vaddr, pg)	clear_page(addr)
 #define copy_user_page(vto, vfrom, vaddr, pg)	copy_page(vto, vfrom)
 
+#else	/* VIPT aliasing dcache */
+
+struct vm_area_struct;
+struct page;
+
+#define __HAVE_ARCH_COPY_USER_HIGHPAGE
+
+void copy_user_highpage(struct page *to, struct page *from,
+			unsigned long u_vaddr, struct vm_area_struct *vma);
+void clear_user_page(void *to, unsigned long u_vaddr, struct page *page);
+
+#endif	/* CONFIG_ARC_CACHE_VIPT_ALIASING */
+
 #undef STRICT_MM_TYPECHECKS
 
 #ifdef STRICT_MM_TYPECHECKS

commit 4368902bb90f0e208387f336c3fce0e6b2a110fc
Author: Gilad Ben-Yossef <gilad@benyossef.com>
Date:   Tue Jan 22 16:48:45 2013 +0530

    ARC: Add support for ioremap_prot API
    
    Implement ioremap_prot() to allow mapping IO memory with variable
    protection
    via TLB.
    
    Implementing this allows the /dev/mem driver to use its generic access()
    VMA callback, which in turn allows ptrace to examine data in memory
    mapped regions mapped via /dev/mem, such as Arc DCCM.
    
    The end result is that it is possible to examine values of variables
    placed into DCCM in user space programs via GDB.
    
    CC: Alexey Brodkin <Alexey.Brodkin@synopsys.com>
    CC: Noam Camus <noamc@ezchip.com>
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Gilad Ben-Yossef <gilad@benyossef.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index dfe1f8a95f1d..bdf546104551 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -48,6 +48,8 @@ typedef unsigned long pgtable_t;
 #define __pgd(x)        ((pgd_t) { (x) })
 #define __pgprot(x)     ((pgprot_t) { (x) })
 
+#define pte_pgprot(x) __pgprot(pte_val(x))
+
 #else /* !STRICT_MM_TYPECHECKS */
 
 typedef unsigned long pte_t;
@@ -60,6 +62,7 @@ typedef unsigned long pgtable_t;
 #define pgprot_val(x)	(x)
 #define __pte(x)	(x)
 #define __pgprot(x)	(x)
+#define pte_pgprot(x)	(x)
 
 #endif
 

commit 8c2f4a8dd0e0fc9dcaf14c768544039eddfa7375
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon Feb 11 19:55:33 2013 +0530

    ARC: UAPI Disintegrate arch/arc/include/asm
    
    1. ./genfilelist.pl arch/arc/include/asm/
    
    2. Create arch/arc/include/uapi/asm/Kbuild as follows
    
            +# UAPI Header export list
            +include include/uapi/asm-generic/Kbuild.asm
    
    3. ./disintegrate-one.pl arch/arc/include/{,uapi/}asm/<above-list>
    
    4. Edit arch/arc/include/asm/Kbuild to remove ref to
            asm-generic/Kbuild.asm
    
    - To work around empty uapi/asm/setup.h added a placholder comment.
    - Also a manual #ifdef __ASSEMBLY__ for a late ptrace change
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: David Howells <dhowells@redhat.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index d111d0cea9cc..dfe1f8a95f1d 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -5,37 +5,11 @@
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
  */
-
 #ifndef __ASM_ARC_PAGE_H
 #define __ASM_ARC_PAGE_H
 
-/* PAGE_SHIFT determines the page size */
-#if defined(CONFIG_ARC_PAGE_SIZE_16K)
-#define PAGE_SHIFT 14
-#elif defined(CONFIG_ARC_PAGE_SIZE_4K)
-#define PAGE_SHIFT 12
-#else
-/*
- * Default 8k
- * done this way (instead of under CONFIG_ARC_PAGE_SIZE_8K) because adhoc
- * user code (busybox appletlib.h) expects PAGE_SHIFT to be defined w/o
- * using the correct uClibc header and in their build our autoconf.h is
- * not available
- */
-#define PAGE_SHIFT 13
-#endif
-
-#ifdef __ASSEMBLY__
-#define PAGE_SIZE	(1 << PAGE_SHIFT)
-#define PAGE_OFFSET	(0x80000000)
-#else
-#define PAGE_SIZE	(1UL << PAGE_SHIFT)	/* Default 8K */
-#define PAGE_OFFSET	(0x80000000UL)	/* Kernel starts at 2G onwards */
-#endif
+#include <uapi/asm/page.h>
 
-#define PAGE_MASK	(~(PAGE_SIZE-1))
-
-#ifdef __KERNEL__
 
 #ifndef __ASSEMBLY__
 
@@ -129,6 +103,4 @@ typedef unsigned long pgtable_t;
 
 #endif /* !__ASSEMBLY__ */
 
-#endif /* __KERNEL__ */
-
 #endif

commit 5dda4dc570ac41e3bd73ef871c500aeb7005c6b0
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:19 2013 +0530

    ARC: Page Table Management
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
index 7cd1224d8e7d..d111d0cea9cc 100644
--- a/arch/arc/include/asm/page.h
+++ b/arch/arc/include/asm/page.h
@@ -35,6 +35,98 @@
 
 #define PAGE_MASK	(~(PAGE_SIZE-1))
 
+#ifdef __KERNEL__
+
+#ifndef __ASSEMBLY__
+
+#define get_user_page(vaddr)		__get_free_page(GFP_KERNEL)
+#define free_user_page(page, addr)	free_page(addr)
+
+/* TBD: for now don't worry about VIPT D$ aliasing */
+#define clear_page(paddr)		memset((paddr), 0, PAGE_SIZE)
+#define copy_page(to, from)		memcpy((to), (from), PAGE_SIZE)
+
+#define clear_user_page(addr, vaddr, pg)	clear_page(addr)
+#define copy_user_page(vto, vfrom, vaddr, pg)	copy_page(vto, vfrom)
+
+#undef STRICT_MM_TYPECHECKS
+
+#ifdef STRICT_MM_TYPECHECKS
+/*
+ * These are used to make use of C type-checking..
+ */
+typedef struct {
+	unsigned long pte;
+} pte_t;
+typedef struct {
+	unsigned long pgd;
+} pgd_t;
+typedef struct {
+	unsigned long pgprot;
+} pgprot_t;
+typedef unsigned long pgtable_t;
+
+#define pte_val(x)      ((x).pte)
+#define pgd_val(x)      ((x).pgd)
+#define pgprot_val(x)   ((x).pgprot)
+
+#define __pte(x)        ((pte_t) { (x) })
+#define __pgd(x)        ((pgd_t) { (x) })
+#define __pgprot(x)     ((pgprot_t) { (x) })
+
+#else /* !STRICT_MM_TYPECHECKS */
+
+typedef unsigned long pte_t;
+typedef unsigned long pgd_t;
+typedef unsigned long pgprot_t;
+typedef unsigned long pgtable_t;
+
+#define pte_val(x)	(x)
+#define pgd_val(x)	(x)
+#define pgprot_val(x)	(x)
+#define __pte(x)	(x)
+#define __pgprot(x)	(x)
+
+#endif
+
+#define ARCH_PFN_OFFSET     (CONFIG_LINUX_LINK_BASE >> PAGE_SHIFT)
+
+#define pfn_valid(pfn)      (((pfn) - ARCH_PFN_OFFSET) < max_mapnr)
+
+/*
+ * __pa, __va, virt_to_page (ALERT: deprecated, don't use them)
+ *
+ * These macros have historically been misnamed
+ * virt here means link-address/program-address as embedded in object code.
+ * So if kernel img is linked at 0x8000_0000 onwards, 0x8010_0000 will be
+ * 128th page, and virt_to_page( ) will return the struct page corresp to it.
+ * mem_map[ ] is an array of struct page for each page frame in the system
+ *
+ * Independent of where linux is linked at, link-addr = physical address
+ * So the old macro  __pa = vaddr + PAGE_OFFSET - CONFIG_LINUX_LINK_BASE
+ * would have been wrong in case kernel is not at 0x8zs
+ */
+#define __pa(vaddr)  ((unsigned long)vaddr)
+#define __va(paddr)  ((void *)((unsigned long)(paddr)))
+
+#define virt_to_page(kaddr)	\
+	(mem_map + ((__pa(kaddr) - CONFIG_LINUX_LINK_BASE) >> PAGE_SHIFT))
+
+#define virt_addr_valid(kaddr)  pfn_valid(__pa(kaddr) >> PAGE_SHIFT)
+
+/* Default Permissions for page, used in mmap.c */
+#ifdef CONFIG_ARC_STACK_NONEXEC
+#define VM_DATA_DEFAULT_FLAGS   (VM_READ | VM_WRITE | VM_MAYREAD | VM_MAYWRITE)
+#else
+#define VM_DATA_DEFAULT_FLAGS   (VM_READ | VM_WRITE | VM_EXEC | \
+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)
+#endif
+
+#define WANT_PAGE_VIRTUAL   1
+
+#include <asm-generic/memory_model.h>   /* page_to_pfn, pfn_to_page */
+#include <asm-generic/getorder.h>
+
 #endif /* !__ASSEMBLY__ */
 
 #endif /* __KERNEL__ */

commit 3be80aaef861a60b85a9323462ebb5f623774f7a
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:17 2013 +0530

    ARC: Fundamental ARCH data-types/defines
    
    * L1_CACHE_SHIFT
    * PAGE_SIZE, PAGE_OFFSET
    * struct pt_regs, struct user_regs_struct
    * struct thread_struct, cpu_relax(), task_pt_regs(), start_thread(), ...
    * struct thread_info, THREAD_SIZE, INIT_THREAD_INFO(), TIF_*, ...
    * BUG()
    * ELF_*
    * Elf_*
    
    To disallow user-space visibility into some of the core kernel data-types
    such as struct pt_regs, #ifdef __KERNEL__ which also makes the UAPI header
    spit (further patch in the series) to NOT export it to asm/uapi/ptrace.h
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Jonas Bonn <jonas.bonn@gmail.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arc/include/asm/page.h b/arch/arc/include/asm/page.h
new file mode 100644
index 000000000000..7cd1224d8e7d
--- /dev/null
+++ b/arch/arc/include/asm/page.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __ASM_ARC_PAGE_H
+#define __ASM_ARC_PAGE_H
+
+/* PAGE_SHIFT determines the page size */
+#if defined(CONFIG_ARC_PAGE_SIZE_16K)
+#define PAGE_SHIFT 14
+#elif defined(CONFIG_ARC_PAGE_SIZE_4K)
+#define PAGE_SHIFT 12
+#else
+/*
+ * Default 8k
+ * done this way (instead of under CONFIG_ARC_PAGE_SIZE_8K) because adhoc
+ * user code (busybox appletlib.h) expects PAGE_SHIFT to be defined w/o
+ * using the correct uClibc header and in their build our autoconf.h is
+ * not available
+ */
+#define PAGE_SHIFT 13
+#endif
+
+#ifdef __ASSEMBLY__
+#define PAGE_SIZE	(1 << PAGE_SHIFT)
+#define PAGE_OFFSET	(0x80000000)
+#else
+#define PAGE_SIZE	(1UL << PAGE_SHIFT)	/* Default 8K */
+#define PAGE_OFFSET	(0x80000000UL)	/* Kernel starts at 2G onwards */
+#endif
+
+#define PAGE_MASK	(~(PAGE_SIZE-1))
+
+#endif /* !__ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#endif
