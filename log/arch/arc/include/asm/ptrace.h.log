commit 7321e2ea0d6aece516a9c0827028ecda2ccaeae9
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Thu Mar 5 23:02:51 2020 +0300

    ARC: add support for DSP-enabled userspace applications
    
    To be able to run DSP-enabled userspace applications we need to
    save and restore following DSP-related registers:
    At IRQ/exception entry/exit:
     * DSP_CTRL (save it and reset to value suitable for kernel)
     * ACC0_LO, ACC0_HI (we already save them as r58, r59 pair)
    At context switch:
     * ACC0_GLO, ACC0_GHI
     * DSP_BFLY0, DSP_FFT_CTRL
    
    Reviewed-by: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index ba9854ef39e8..2fdb87addadc 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -91,6 +91,9 @@ struct pt_regs {
 #ifdef CONFIG_ARC_HAS_ACCL_REGS
 	unsigned long r58, r59;	/* ACCL/ACCH used by FPU / DSP MPY */
 #endif
+#ifdef CONFIG_ARC_DSP_SAVE_RESTORE_REGS
+	unsigned long DSP_CTRL;
+#endif
 
 	/*------- Below list auto saved by h/w -----------*/
 	unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 5a8cb22724a1..ba9854ef39e8 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -1,10 +1,7 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
  * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  * Amit Bhor, Sameer Dhavale: Codito Technologies 2004
  */
 #ifndef __ASM_ARC_PTRACE_H

commit 28923f6b74060b183207a373ddae4ce4948cabea
Author: Liav Rehana <liavr@mellanox.com>
Date:   Thu Jun 15 11:44:00 2017 +0300

    ARC: [plat-eznps] handle extra aux regs #2: kernel/entry exit
    
    Preserve eflags and gpa1 aux during entry/exit into kernel as these
    could be modified by kernel mode
    
    These registers used by compare exchange instructions.
      - GPA1 is used for compare value,
      - EFLAGS got bit reflects atomic operation response.
    
    EFLAGS is zeroed for each new user task so it won't get its
    parent value.
    
    Signed-off-by: Liav Rehana <liavr@mellanox.com>
    Signed-off-by: Noam Camus <noamc@ezchip.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 5297faa8a378..5a8cb22724a1 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -19,6 +19,11 @@
 #ifdef CONFIG_ISA_ARCOMPACT
 struct pt_regs {
 
+#ifdef CONFIG_ARC_PLAT_EZNPS
+	unsigned long eflags;	/* Extended FLAGS */
+	unsigned long gpa1;	/* General Purpose Aux */
+#endif
+
 	/* Real registers */
 	unsigned long bta;	/* bta_l1, bta_l2, erbta */
 

commit 3d5e80125a6e5649c6bdad8d5780e39ea422c67d
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu Apr 20 15:36:51 2017 -0700

    ARCv2: entry: save Accumulator register pair (r58:59) if present
    
    Accumulator is present in configs with FPU and/or DSP MPY (mpy > 6)
    
    Instead of doing this in pt_regs (and thus every kernel entry/exit),
    this could have been done in context switch (and for user task only) as
    currently kernel doesn't clobber these registers for its own accord.
    However we will soon start using 64-bit multiply instructions for kernel
    which can clobber these. Also gcc folks also plan to start using these
    as GPRs, hence better to always save/restore them
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 47111d565a95..5297faa8a378 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -86,6 +86,10 @@ struct pt_regs {
 
 	unsigned long r12, r30;
 
+#ifdef CONFIG_ARC_HAS_ACCL_REGS
+	unsigned long r58, r59;	/* ACCL/ACCH used by FPU / DSP MPY */
+#endif
+
 	/*------- Below list auto saved by h/w -----------*/
 	unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
 

commit ecd43afdbe72017aefe48080631eb625e177ef4d
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Sun Jan 8 19:45:48 2017 -0800

    ARCv2: save r30 on kernel entry as gcc uses it for code-gen
    
    This is not exposed to userspace debugers yet, which can be done
    independently as a seperate patch !
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 69095da1fcfd..47111d565a95 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -84,7 +84,7 @@ struct pt_regs {
 	unsigned long fp;
 	unsigned long sp;	/* user/kernel sp depending on where we came from  */
 
-	unsigned long r12;
+	unsigned long r12, r30;
 
 	/*------- Below list auto saved by h/w -----------*/
 	unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;

commit 87ce62802f7a3553234ebf1ae7cd52c8bf272fb9
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Aug 5 11:12:00 2015 +0530

    ARC: Make pt_regs regs unsigned
    
    KGDB fails to build after f51e2f191112 ("ARC: make sure instruction_pointer()
    returns unsigned value")
    
    The hack to force one specific reg to unsigned backfired. There's no
    reason to keep the regs signed after all.
    
    |  CC      arch/arc/kernel/kgdb.o
    |../arch/arc/kernel/kgdb.c: In function 'kgdb_trap':
    | ../arch/arc/kernel/kgdb.c:180:29: error: lvalue required as left operand of assignment
    |   instruction_pointer(regs) -= BREAK_INSTR_SIZE;
    
    Reported-by: Yuriy Kolerov <yuriy.kolerov@synopsys.com>
    Fixes: f51e2f191112 ("ARC: make sure instruction_pointer() returns unsigned value")
    Cc: Alexey Brodkin <abrodkin@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 91694ec1ce95..69095da1fcfd 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -20,20 +20,20 @@
 struct pt_regs {
 
 	/* Real registers */
-	long bta;	/* bta_l1, bta_l2, erbta */
+	unsigned long bta;	/* bta_l1, bta_l2, erbta */
 
-	long lp_start, lp_end, lp_count;
+	unsigned long lp_start, lp_end, lp_count;
 
-	long status32;	/* status32_l1, status32_l2, erstatus */
-	long ret;	/* ilink1, ilink2 or eret */
-	long blink;
-	long fp;
-	long r26;	/* gp */
+	unsigned long status32;	/* status32_l1, status32_l2, erstatus */
+	unsigned long ret;	/* ilink1, ilink2 or eret */
+	unsigned long blink;
+	unsigned long fp;
+	unsigned long r26;	/* gp */
 
-	long r12, r11, r10, r9, r8, r7, r6, r5, r4, r3, r2, r1, r0;
+	unsigned long r12, r11, r10, r9, r8, r7, r6, r5, r4, r3, r2, r1, r0;
 
-	long sp;	/* user/kernel sp depending on where we came from  */
-	long orig_r0;
+	unsigned long sp;	/* User/Kernel depending on where we came from */
+	unsigned long orig_r0;
 
 	/*
 	 * To distinguish bet excp, syscall, irq
@@ -55,13 +55,13 @@ struct pt_regs {
 		unsigned long event;
 	};
 
-	long user_r25;
+	unsigned long user_r25;
 };
 #else
 
 struct pt_regs {
 
-	long orig_r0;
+	unsigned long orig_r0;
 
 	union {
 		struct {
@@ -76,26 +76,26 @@ struct pt_regs {
 		unsigned long event;
 	};
 
-	long bta;	/* bta_l1, bta_l2, erbta */
+	unsigned long bta;	/* bta_l1, bta_l2, erbta */
 
-	long user_r25;
+	unsigned long user_r25;
 
-	long r26;	/* gp */
-	long fp;
-	long sp;	/* user/kernel sp depending on where we came from  */
+	unsigned long r26;	/* gp */
+	unsigned long fp;
+	unsigned long sp;	/* user/kernel sp depending on where we came from  */
 
-	long r12;
+	unsigned long r12;
 
 	/*------- Below list auto saved by h/w -----------*/
-	long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
+	unsigned long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
 
-	long blink;
-	long lp_end, lp_start, lp_count;
+	unsigned long blink;
+	unsigned long lp_end, lp_start, lp_count;
 
-	long ei, ldi, jli;
+	unsigned long ei, ldi, jli;
 
-	long ret;
-	long status32;
+	unsigned long ret;
+	unsigned long status32;
 };
 
 #endif
@@ -103,10 +103,10 @@ struct pt_regs {
 /* Callee saved registers - need to be saved only when you are scheduled out */
 
 struct callee_regs {
-	long r25, r24, r23, r22, r21, r20, r19, r18, r17, r16, r15, r14, r13;
+	unsigned long r25, r24, r23, r22, r21, r20, r19, r18, r17, r16, r15, r14, r13;
 };
 
-#define instruction_pointer(regs)	(unsigned long)((regs)->ret)
+#define instruction_pointer(regs)	((regs)->ret)
 #define profile_pc(regs)		instruction_pointer(regs)
 
 /* return 1 if user mode or 0 if kernel mode */
@@ -142,7 +142,7 @@ struct callee_regs {
 
 static inline long regs_return_value(struct pt_regs *regs)
 {
-	return regs->r0;
+	return (long)regs->r0;
 }
 
 #endif /* !__ASSEMBLY__ */

commit f51e2f1911122879eefefa4c592dea8bf794b39c
Author: Alexey Brodkin <abrodkin@synopsys.com>
Date:   Mon Jul 13 10:25:17 2015 +0300

    ARC: make sure instruction_pointer() returns unsigned value
    
    Currently instruction_pointer() returns pt_regs->ret and so return value
    is of type "long", which implicitly stands for "signed long".
    
    While that's perfectly fine when dealing with 32-bit values if return
    value of instruction_pointer() gets assigned to 64-bit variable sign
    extension may happen.
    
    And at least in one real use-case it happens already.
    In perf_prepare_sample() return value of perf_instruction_pointer()
    (which is an alias to instruction_pointer() in case of ARC) is assigned
    to (struct perf_sample_data)->ip (which type is "u64").
    
    And what we see if instuction pointer points to user-space application
    that in case of ARC lays below 0x8000_0000 "ip" gets set properly with
    leading 32 zeros. But if instruction pointer points to kernel address
    space that starts from 0x8000_0000 then "ip" is set with 32 leadig
    "f"-s. I.e. id instruction_pointer() returns 0x8100_0000, "ip" will be
    assigned with 0xffff_ffff__8100_0000. Which is obviously wrong.
    
    In particular that issuse broke output of perf, because perf was unable
    to associate addresses like 0xffff_ffff__8100_0000 with anything from
    /proc/kallsyms.
    
    That's what we used to see:
     ----------->8----------
      6.27%  ls       [unknown]                [k] 0xffffffff8046c5cc
      2.96%  ls       libuClibc-0.9.34-git.so  [.] memcpy
      2.25%  ls       libuClibc-0.9.34-git.so  [.] memset
      1.66%  ls       [unknown]                [k] 0xffffffff80666536
      1.54%  ls       libuClibc-0.9.34-git.so  [.] 0x000224d6
      1.18%  ls       libuClibc-0.9.34-git.so  [.] 0x00022472
     ----------->8----------
    
    With that change perf output looks much better now:
     ----------->8----------
      8.21%  ls       [kernel.kallsyms]        [k] memset
      3.52%  ls       libuClibc-0.9.34-git.so  [.] memcpy
      2.11%  ls       libuClibc-0.9.34-git.so  [.] malloc
      1.88%  ls       libuClibc-0.9.34-git.so  [.] memset
      1.64%  ls       [kernel.kallsyms]        [k] _raw_spin_unlock_irqrestore
      1.41%  ls       [kernel.kallsyms]        [k] __d_lookup_rcu
     ----------->8----------
    
    Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: arc-linux-dev@synopsys.com
    Cc: stable@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 91755972b9a2..91694ec1ce95 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -106,7 +106,7 @@ struct callee_regs {
 	long r25, r24, r23, r22, r21, r20, r19, r18, r17, r16, r15, r14, r13;
 };
 
-#define instruction_pointer(regs)	((regs)->ret)
+#define instruction_pointer(regs)	(unsigned long)((regs)->ret)
 #define profile_pc(regs)		instruction_pointer(regs)
 
 /* return 1 if user mode or 0 if kernel mode */

commit 1f6ccfff6314672743ad7252160654709e997a2a
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon May 13 18:30:41 2013 +0530

    ARCv2: Support for ARCv2 ISA and HS38x cores
    
    The notable features are:
        - SMP configurations of upto 4 cores with coherency
        - Optional L2 Cache and IO-Coherency
        - Revised Interrupt Architecture (multiple priorites, reg banks,
            auto stack switch, auto regfile save/restore)
        - MMUv4 (PIPT dcache, Huge Pages)
        - Instructions for
            * 64bit load/store: LDD, STD
            * Hardware assisted divide/remainder: DIV, REM
            * Function prologue/epilogue: ENTER_S, LEAVE_S
            * IRQ enable/disable: CLRI, SETI
            * pop count: FFS, FLS
            * SETcc, BMSKN, XBFU...
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 1bfeec2c0558..91755972b9a2 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -16,6 +16,7 @@
 
 /* THE pt_regs: Defines how regs are saved during entry into kernel */
 
+#ifdef CONFIG_ISA_ARCOMPACT
 struct pt_regs {
 
 	/* Real registers */
@@ -56,6 +57,48 @@ struct pt_regs {
 
 	long user_r25;
 };
+#else
+
+struct pt_regs {
+
+	long orig_r0;
+
+	union {
+		struct {
+#ifdef CONFIG_CPU_BIG_ENDIAN
+			unsigned long state:8, ecr_vec:8,
+				      ecr_cause:8, ecr_param:8;
+#else
+			unsigned long ecr_param:8, ecr_cause:8,
+				      ecr_vec:8, state:8;
+#endif
+		};
+		unsigned long event;
+	};
+
+	long bta;	/* bta_l1, bta_l2, erbta */
+
+	long user_r25;
+
+	long r26;	/* gp */
+	long fp;
+	long sp;	/* user/kernel sp depending on where we came from  */
+
+	long r12;
+
+	/*------- Below list auto saved by h/w -----------*/
+	long r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11;
+
+	long blink;
+	long lp_end, lp_start, lp_count;
+
+	long ei, ldi, jli;
+
+	long ret;
+	long status32;
+};
+
+#endif
 
 /* Callee saved registers - need to be saved only when you are scheduled out */
 

commit 4b06ff35fb1dcafbcbdcbe9ce794ab0770f2a843
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Jul 10 11:40:27 2013 +0530

    ARC: Code cosmetics (Nothing semantical)
    
    * reduce editor lines taken by pt_regs
    * ARCompact ISA specific part of TLB Miss handlers clubbed together
    * cleanup some comments
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index c9938e7a7dbd..1bfeec2c0558 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -20,27 +20,17 @@ struct pt_regs {
 
 	/* Real registers */
 	long bta;	/* bta_l1, bta_l2, erbta */
-	long lp_start;
-	long lp_end;
-	long lp_count;
+
+	long lp_start, lp_end, lp_count;
+
 	long status32;	/* status32_l1, status32_l2, erstatus */
 	long ret;	/* ilink1, ilink2 or eret */
 	long blink;
 	long fp;
 	long r26;	/* gp */
-	long r12;
-	long r11;
-	long r10;
-	long r9;
-	long r8;
-	long r7;
-	long r6;
-	long r5;
-	long r4;
-	long r3;
-	long r2;
-	long r1;
-	long r0;
+
+	long r12, r11, r10, r9, r8, r7, r6, r5, r4, r3, r2, r1, r0;
+
 	long sp;	/* user/kernel sp depending on where we came from  */
 	long orig_r0;
 
@@ -70,19 +60,7 @@ struct pt_regs {
 /* Callee saved registers - need to be saved only when you are scheduled out */
 
 struct callee_regs {
-	long r25;
-	long r24;
-	long r23;
-	long r22;
-	long r21;
-	long r20;
-	long r19;
-	long r18;
-	long r17;
-	long r16;
-	long r15;
-	long r14;
-	long r13;
+	long r25, r24, r23, r22, r21, r20, r19, r18, r17, r16, r15, r14, r13;
 };
 
 #define instruction_pointer(regs)	((regs)->ret)

commit 502a0c775c7f0a01065e0d078e06c0440b86a11a
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue Jun 11 18:56:54 2013 +0530

    ARC: pt_regs update #5: Use real ECR for pt_regs->event vs. synth values
    
    pt_regs->event was set with artificial values to identify the low level
    system event (syscall trap / breakpoint trap / exceptions / interrupts)
    
    With r8 saving out of the way, the full word can be used to save real
    ECR (Exception Cause Register) which helps idenify the event naturally,
    including additional info such as cause code, param.
    Only for Interrupts, where ECR is not applicable, do we resort to
    synthetic non ECR values.
    
    SAVE_ALL_TRAP/EXCEPTIONS can now be merged as they both use ECR with
    different runtime values.
    
    The ptrace helpers now use the sub-fields of ECR to distinguish the
    events (e.g. vector 0x25 is trap, param 0 is syscall...)
    
    The following benefits will follow:
    
    (1) This centralizes the location of where ECR is saved and will allow
        the cleanup of task->thread.cause_code ECR placeholder which is set
        in non-uniform way. Then ARC VM code can safely rely on it being
        there for purpose of finer grained VM_EXEC dcache flush (based on
        exec fault: I-TLB Miss)
    
    (2) Further, ECR being passed around from low level handlers as arg can
        be eliminated as it is part of standard reg-file in pt_regs
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 7b2de6f7025a..c9938e7a7dbd 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -44,15 +44,24 @@ struct pt_regs {
 	long sp;	/* user/kernel sp depending on where we came from  */
 	long orig_r0;
 
-	/*to distinguish bet excp, syscall, irq */
+	/*
+	 * To distinguish bet excp, syscall, irq
+	 * For traps and exceptions, Exception Cause Register.
+	 * 	ECR: <00> <VV> <CC> <PP>
+	 * 	Last word used by Linux for extra state mgmt (syscall-restart)
+	 * For interrupts, use artificial ECR values to note current prio-level
+	 */
 	union {
+		struct {
 #ifdef CONFIG_CPU_BIG_ENDIAN
-		/* so that assembly code is same for LE/BE */
-		unsigned long orig_r8:16, event:16;
+			unsigned long state:8, ecr_vec:8,
+				      ecr_cause:8, ecr_param:8;
 #else
-		unsigned long event:16, orig_r8:16;
+			unsigned long ecr_param:8, ecr_cause:8,
+				      ecr_vec:8, state:8;
 #endif
-		long orig_r8_word;
+		};
+		unsigned long event;
 	};
 
 	long user_r25;
@@ -94,11 +103,13 @@ struct callee_regs {
 /* return 1 if PC in delay slot */
 #define delay_mode(regs) ((regs->status32 & STATUS_DE_MASK) == STATUS_DE_MASK)
 
-#define in_syscall(regs)    (regs->event & orig_r8_IS_SCALL)
-#define in_brkpt_trap(regs) (regs->event & orig_r8_IS_BRKPT)
+#define in_syscall(regs)    ((regs->ecr_vec == ECR_V_TRAP) && !regs->ecr_param)
+#define in_brkpt_trap(regs) ((regs->ecr_vec == ECR_V_TRAP) && regs->ecr_param)
 
-#define syscall_wont_restart(regs) (regs->event |= orig_r8_IS_SCALL_RESTARTED)
-#define syscall_restartable(regs) !(regs->event &  orig_r8_IS_SCALL_RESTARTED)
+#define STATE_SCALL_RESTARTED	0x01
+
+#define syscall_wont_restart(reg) (reg->state |= STATE_SCALL_RESTARTED)
+#define syscall_restartable(reg) !(reg->state &  STATE_SCALL_RESTARTED)
 
 #define current_pt_regs()					\
 ({								\
@@ -115,11 +126,4 @@ static inline long regs_return_value(struct pt_regs *regs)
 
 #endif /* !__ASSEMBLY__ */
 
-#define orig_r8_IS_SCALL		0x0001
-#define orig_r8_IS_SCALL_RESTARTED	0x0002
-#define orig_r8_IS_BRKPT		0x0004
-#define orig_r8_IS_EXCPN		0x0008
-#define orig_r8_IS_IRQ1			0x0010
-#define orig_r8_IS_IRQ2			0x0020
-
 #endif /* __ASM_PTRACE_H */

commit 359105bdb06f8421fd8e69ae47fd052e398b6778
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue May 28 13:50:41 2013 +0530

    ARC: pt_regs update #4: r25 saved/restored unconditionally
    
    (This is a VERY IMP change for low level interrupt/exception handling)
    
    -----------------------------------------------------------------------
    WHAT
    -----------------------------------------------------------------------
    * User 25 now saved in pt_regs->user_r25 (vs. tsk->thread_info.user_r25)
    
    * This allows Low level interrupt code to unconditionally save r25
      (vs. the prev version which would only do it for U->K transition).
      Ofcourse for nested interrupts, only the pt_regs->user_r25 of
      bottom-most frame is useful.
    
    * simplifies the interrupt prologue/epilogue
    
    * Needed for ARCv2 ISA code and done here to keep design similar with
      ARCompact event handling
    
    -----------------------------------------------------------------------
    WHY
    -------------------------------------------------------------------------
    With CONFIG_ARC_CURR_IN_REG, r25 is used to cache "current" task pointer
    in kernel mode. So when entering kernel mode from User Mode
    - user r25 is specially safe-kept (it being a callee reg is NOT part of
      pt_regs which are saved by default on each interrupt/trap/exception)
    - r25 loaded with current task pointer.
    
    Further, if interrupt was taken in kernel mode, this is skipped since we
    know that r25 already has valid "current" pointer.
    
    With 2 level of interrupts in ARCompact ISA, detecting this is difficult
    but still possible, since we could be in kernel mode but r25 not already saved
    (in fact the stack itself might not have been switched).
    
    A. User mode
    B. L1 IRQ taken
    C. L2 IRQ taken (while on 1st line of L1 ISR)
    
    So in #C, although in kernel mode, r25 not saved (infact SP not
    switched at all)
    
    Given that ARcompact has manual stack switching, we could use a bit of
    trickey - The low level code would make sure that SP is only set to kernel
    mode value at the very end (after saving r25). So a non kernel mode SP,
    even if in kernel mode, meant r25 was NOT saved.
    
    The same paradigm won't work in ARCv2 ISA since SP is auto-switched so
    it's setting can't be delayed/constrained.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 47801ba135b3..7b2de6f7025a 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -54,6 +54,8 @@ struct pt_regs {
 #endif
 		long orig_r8_word;
 	};
+
+	long user_r25;
 };
 
 /* Callee saved registers - need to be saved only when you are scheduled out */

commit 16f9afe651e8197fb7ce6df0990d8e2ad779e1af
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon May 27 21:43:41 2013 +0530

    ARC: pt_regs update #3: Remove unused gutter at start of callee_regs
    
    This is trickier than prev two:
    
    * context switching code saves kernel mode callee regs in the format of
      struct callee_regs thus needs adjustment. This also reduces the height
      of topmost kernel stack frame by 1 word.
    
    * Since kernel stack unwinder is sensitive to height of topmost kernel
      stack frame, that needs a word of adjustment too.
    
    ptrace needs a bit of updating since pt_regs now diverges from
    user_regs_struct.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 7491bb7428bd..47801ba135b3 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -59,7 +59,6 @@ struct pt_regs {
 /* Callee saved registers - need to be saved only when you are scheduled out */
 
 struct callee_regs {
-	long res;	/* Again this is not needed */
 	long r25;
 	long r24;
 	long r23;

commit 2fa919045b72ec892e17d56f888e6af4260b7629
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue May 28 09:43:17 2013 +0530

    ARC: pt_regs update #2: Remove unused gutter at start of pt_regs
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index f82a3a2201b5..7491bb7428bd 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -17,12 +17,6 @@
 /* THE pt_regs: Defines how regs are saved during entry into kernel */
 
 struct pt_regs {
-	/*
-	 * 1 word gutter after reg-file has been saved
-	 * Technically not needed, Since SP always points to a "full" location
-	 * (vs. "empty"). But pt_regs is shared with tools....
-	 */
-	long res;
 
 	/* Real registers */
 	long bta;	/* bta_l1, bta_l2, erbta */

commit 283237a04fd332bddc2ac298e6ad7d23a1fc4b99
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue May 28 09:34:45 2013 +0530

    ARC: pt_regs update #1: Align pt_regs end with end of kernel stack page
    
    Historically, pt_regs would end at offset of 1 word from end of stack
    page.
    
            -----------------  -> START of page (task->stack)
            |               |
            | thread_info   |
            -----------------
            |               |
       ^    ~               ~
       |    ~               ~
       |    |               |
       |    |               | <---- pt_regs used to END here
            -----------------
            | 1 word GUTTER |
            ----------------- -> End of page (START of kernel stack)
    
    This required special "one-off" considerations in low level code.
    
    The root cause is very likely assumption of "empty" SP by the original
    ARC kernel hackers, despite ARC700 always been "full" SP.
    
    So finally RIP one word gutter !
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 6179de7e07c2..f82a3a2201b5 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -110,7 +110,7 @@ struct callee_regs {
 	/* open-coded current_thread_info() */			\
 	register unsigned long sp asm ("sp");			\
 	unsigned long pg_start = (sp & ~(THREAD_SIZE - 1));	\
-	(struct pt_regs *)(pg_start + THREAD_SIZE - 4) - 1;	\
+	(struct pt_regs *)(pg_start + THREAD_SIZE) - 1;	\
 })
 
 static inline long regs_return_value(struct pt_regs *regs)

commit 367f3fcd9296977bc4689546f55c5f4a9c680e8d
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Mar 20 16:53:14 2013 +0530

    ARC: Fix the typo in event identifier flags used by ptrace
    
    orig_r8_IS_EXCPN and orig_r8_IS_BRKPT were same values due to a
    copy/paste error. Although it looks bad and is wrong, it really doesn't
    affect gdb working.
    
    orig_r8_IS_BRKPT is the one relevant to debugging (breakpoints), since
    it is used to provide EFA vs. ERET to a ptrace "stop_pc" request.
    
    So when gdb has inserted a breakpoint, orig_r8_IS_BRKPT is already set,
    and anything else (i.e. orig_r8_IS_EXCPN) becoming same as it, really
    doesn't hurt gdb. The corollary case, could be nasty but nobody uses the
    ptrace "stop_pc" request in that case
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 8ae783d20a81..6179de7e07c2 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -123,7 +123,7 @@ static inline long regs_return_value(struct pt_regs *regs)
 #define orig_r8_IS_SCALL		0x0001
 #define orig_r8_IS_SCALL_RESTARTED	0x0002
 #define orig_r8_IS_BRKPT		0x0004
-#define orig_r8_IS_EXCPN		0x0004
+#define orig_r8_IS_EXCPN		0x0008
 #define orig_r8_IS_IRQ1			0x0010
 #define orig_r8_IS_IRQ2			0x0020
 

commit 8c2f4a8dd0e0fc9dcaf14c768544039eddfa7375
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon Feb 11 19:55:33 2013 +0530

    ARC: UAPI Disintegrate arch/arc/include/asm
    
    1. ./genfilelist.pl arch/arc/include/asm/
    
    2. Create arch/arc/include/uapi/asm/Kbuild as follows
    
            +# UAPI Header export list
            +include include/uapi/asm-generic/Kbuild.asm
    
    3. ./disintegrate-one.pl arch/arc/include/{,uapi/}asm/<above-list>
    
    4. Edit arch/arc/include/asm/Kbuild to remove ref to
            asm-generic/Kbuild.asm
    
    - To work around empty uapi/asm/setup.h added a placholder comment.
    - Also a manual #ifdef __ASSEMBLY__ for a late ptrace change
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: David Howells <dhowells@redhat.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index df5b95213776..8ae783d20a81 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -7,11 +7,10 @@
  *
  * Amit Bhor, Sameer Dhavale: Codito Technologies 2004
  */
-
 #ifndef __ASM_ARC_PTRACE_H
 #define __ASM_ARC_PTRACE_H
 
-#ifdef __KERNEL__
+#include <uapi/asm/ptrace.h>
 
 #ifndef __ASSEMBLY__
 
@@ -128,39 +127,4 @@ static inline long regs_return_value(struct pt_regs *regs)
 #define orig_r8_IS_IRQ1			0x0010
 #define orig_r8_IS_IRQ2			0x0020
 
-#endif /* __KERNEL__ */
-
-#ifndef __ASSEMBLY__
-/*
- * Userspace ABI: Register state needed by
- *  -ptrace (gdbserver)
- *  -sigcontext (SA_SIGNINFO signal frame)
- *
- * This is to decouple pt_regs from user-space ABI, to be able to change it
- * w/o affecting the ABI.
- * Although the layout (initial padding) is similar to pt_regs to have some
- * optimizations when copying pt_regs to/from user_regs_struct.
- *
- * Also, sigcontext only care about the scratch regs as that is what we really
- * save/restore for signal handling.
-*/
-struct user_regs_struct {
-
-	struct scratch {
-		long pad;
-		long bta, lp_start, lp_end, lp_count;
-		long status32, ret, blink, fp, gp;
-		long r12, r11, r10, r9, r8, r7, r6, r5, r4, r3, r2, r1, r0;
-		long sp;
-	} scratch;
-	struct callee {
-		long pad;
-		long r25, r24, r23, r22, r21, r20;
-		long r19, r18, r17, r16, r15, r14, r13;
-	} callee;
-	long efa;	/* break pt addr, for break points in delay slots */
-	long stop_pc;	/* give dbg stop_pc directly after checking orig_r8 */
-};
-#endif /* !__ASSEMBLY__ */
-
 #endif /* __ASM_PTRACE_H */

commit 2e651ea1596b0ee25af4fcdc4cd13cbb33ffc254
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Jan 23 16:30:36 2013 +0530

    ARC: Unaligned access emulation
    
    ARC700 doesn't natively support unaligned access, but can be emulated
    -Unaligned Access Exception
    -Disassembly at the Fault address to find the exact insn (long/short)
    
    Also per Arnd's comment, we runtime control it using 2 sysctl knobs:
    * SYSCTL_ARCH_UNALIGN_ALLOW: Runtime enable/disble
    * SYSCTL_ARCH_UNALIGN_NO_WARN: Warn on each emulation attempt
    
    Originally contributed by Tim Yao <tim.yao@amlogic.com>
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Tim Yao <tim.yao@amlogic.com>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 063ed0040ef7..df5b95213776 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -97,6 +97,9 @@ struct callee_regs {
 	sp;			\
 })
 
+/* return 1 if PC in delay slot */
+#define delay_mode(regs) ((regs->status32 & STATUS_DE_MASK) == STATUS_DE_MASK)
+
 #define in_syscall(regs)    (regs->event & orig_r8_IS_SCALL)
 #define in_brkpt_trap(regs) (regs->event & orig_r8_IS_BRKPT)
 

commit 4d86dfbbda09b3c67bcaeb370f22a2cc7f39205b
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue Jan 22 17:03:59 2013 +0530

    ARC: kprobes support
    
    Origin port done by Rajeshwar Ranga
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Rajeshwar Ranga <rajeshwar.ranga@gmail.com>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index a98957a95fb3..063ed0040ef7 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -111,6 +111,11 @@ struct callee_regs {
 	(struct pt_regs *)(pg_start + THREAD_SIZE - 4) - 1;	\
 })
 
+static inline long regs_return_value(struct pt_regs *regs)
+{
+	return regs->r0;
+}
+
 #endif /* !__ASSEMBLY__ */
 
 #define orig_r8_IS_SCALL		0x0001

commit 55bb9480f9159b229ac3c3454c97b62d1e0a7e80
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:19 2013 +0530

    ARC: [Review] Prevent incorrect syscall restarts
    
    Per Al Viro's "signals for dummies" https://lkml.org/lkml/2012/12/6/366
    there are 3 golden rules for (not) restarting syscalls:
    
    "       What we need to guarantee is
    * restarts do not happen on signals caught in interrupts or exceptions
    * restarts do not happen on signals caught in sigreturn()
    * restart should happen only once, even if we get through do_signal()
      many times."
    
    ARC Port already handled #1, this patch fixes #2 and #3.
    
    We use the additional state in pt_regs->orig_r8 to ckh if restarting
    has already been done once.
    
    Thanks to Al Viro for spotting this.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 3ec89f467ac3..a98957a95fb3 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -100,6 +100,9 @@ struct callee_regs {
 #define in_syscall(regs)    (regs->event & orig_r8_IS_SCALL)
 #define in_brkpt_trap(regs) (regs->event & orig_r8_IS_BRKPT)
 
+#define syscall_wont_restart(regs) (regs->event |= orig_r8_IS_SCALL_RESTARTED)
+#define syscall_restartable(regs) !(regs->event &  orig_r8_IS_SCALL_RESTARTED)
+
 #define current_pt_regs()					\
 ({								\
 	/* open-coded current_thread_info() */			\

commit 5c39c0ab5e862cf71cda1fc39a5cedd4e2f18c6e
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon Feb 11 20:01:24 2013 +0530

    ARC: [Review] Preparing to fix incorrect syscall restarts due to signals
    
    To avoid multiple syscall restarts (multiple signals) or no restart at
    all (sigreturn), we need just an extra bit of state "literally 1 bit" in
    struct pt_regs. orig_r8 is the best place to do this, however given the
    way it is encoded currently, we can't add anything simplistically.
    
    Current orig_r8:
    * syscalls   -> 1 to NR_SYSCALLS
    * Exceptions -> NR_SYSCALLS + 1
    * Break-point-> NR_SYSCALLS + 2
    
    In new scheme it is a bit-field
    * lower short word contains the  exact event type (and a new bit to represent
       restart semantics : if syscall was already / can't be restarted)
    * upper short word optionally containing the syscall num - needed by
      likes of tracehooks etc
    
    This patch only changes how orig_r8 is organised and nothing should
    change behaviourily.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 3afadefe335f..3ec89f467ac3 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -50,7 +50,17 @@ struct pt_regs {
 	long r0;
 	long sp;	/* user/kernel sp depending on where we came from  */
 	long orig_r0;
-	long orig_r8;	/*to distinguish bet excp, sys call, int1 or int2 */
+
+	/*to distinguish bet excp, syscall, irq */
+	union {
+#ifdef CONFIG_CPU_BIG_ENDIAN
+		/* so that assembly code is same for LE/BE */
+		unsigned long orig_r8:16, event:16;
+#else
+		unsigned long event:16, orig_r8:16;
+#endif
+		long orig_r8_word;
+	};
 };
 
 /* Callee saved registers - need to be saved only when you are scheduled out */
@@ -87,9 +97,8 @@ struct callee_regs {
 	sp;			\
 })
 
-/* return 1 if in syscall, 0 if Intr or Exception */
-#define in_syscall(regs) (((regs->orig_r8) >= 0 && \
-			   (regs->orig_r8 <= NR_syscalls)) ? 1 : 0)
+#define in_syscall(regs)    (regs->event & orig_r8_IS_SCALL)
+#define in_brkpt_trap(regs) (regs->event & orig_r8_IS_BRKPT)
 
 #define current_pt_regs()					\
 ({								\
@@ -101,6 +110,13 @@ struct callee_regs {
 
 #endif /* !__ASSEMBLY__ */
 
+#define orig_r8_IS_SCALL		0x0001
+#define orig_r8_IS_SCALL_RESTARTED	0x0002
+#define orig_r8_IS_BRKPT		0x0004
+#define orig_r8_IS_EXCPN		0x0004
+#define orig_r8_IS_IRQ1			0x0010
+#define orig_r8_IS_IRQ2			0x0020
+
 #endif /* __KERNEL__ */
 
 #ifndef __ASSEMBLY__

commit bf90e1eab682dcb79b7765989fb65835ce9d6165
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:18 2013 +0530

    ARC: Process-creation/scheduling/idle-loop
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 4c9359477ded..3afadefe335f 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -91,6 +91,14 @@ struct callee_regs {
 #define in_syscall(regs) (((regs->orig_r8) >= 0 && \
 			   (regs->orig_r8 <= NR_syscalls)) ? 1 : 0)
 
+#define current_pt_regs()					\
+({								\
+	/* open-coded current_thread_info() */			\
+	register unsigned long sp asm ("sp");			\
+	unsigned long pg_start = (sp & ~(THREAD_SIZE - 1));	\
+	(struct pt_regs *)(pg_start + THREAD_SIZE - 4) - 1;	\
+})
+
 #endif /* !__ASSEMBLY__ */
 
 #endif /* __KERNEL__ */

commit 4adeefe161a74369e44cc8e663f240ece0470dc3
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:18 2013 +0530

    ARC: Syscall support (no-legacy-syscall ABI)
    
    This includes support for generic clone/for/vfork/execve
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
index 446e55eee7be..4c9359477ded 100644
--- a/arch/arc/include/asm/ptrace.h
+++ b/arch/arc/include/asm/ptrace.h
@@ -86,6 +86,11 @@ struct callee_regs {
 		sp = -1;	\
 	sp;			\
 })
+
+/* return 1 if in syscall, 0 if Intr or Exception */
+#define in_syscall(regs) (((regs->orig_r8) >= 0 && \
+			   (regs->orig_r8 <= NR_syscalls)) ? 1 : 0)
+
 #endif /* !__ASSEMBLY__ */
 
 #endif /* __KERNEL__ */

commit 3be80aaef861a60b85a9323462ebb5f623774f7a
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:17 2013 +0530

    ARC: Fundamental ARCH data-types/defines
    
    * L1_CACHE_SHIFT
    * PAGE_SIZE, PAGE_OFFSET
    * struct pt_regs, struct user_regs_struct
    * struct thread_struct, cpu_relax(), task_pt_regs(), start_thread(), ...
    * struct thread_info, THREAD_SIZE, INIT_THREAD_INFO(), TIF_*, ...
    * BUG()
    * ELF_*
    * Elf_*
    
    To disallow user-space visibility into some of the core kernel data-types
    such as struct pt_regs, #ifdef __KERNEL__ which also makes the UAPI header
    spit (further patch in the series) to NOT export it to asm/uapi/ptrace.h
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Jonas Bonn <jonas.bonn@gmail.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arc/include/asm/ptrace.h b/arch/arc/include/asm/ptrace.h
new file mode 100644
index 000000000000..446e55eee7be
--- /dev/null
+++ b/arch/arc/include/asm/ptrace.h
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Amit Bhor, Sameer Dhavale: Codito Technologies 2004
+ */
+
+#ifndef __ASM_ARC_PTRACE_H
+#define __ASM_ARC_PTRACE_H
+
+#ifdef __KERNEL__
+
+#ifndef __ASSEMBLY__
+
+/* THE pt_regs: Defines how regs are saved during entry into kernel */
+
+struct pt_regs {
+	/*
+	 * 1 word gutter after reg-file has been saved
+	 * Technically not needed, Since SP always points to a "full" location
+	 * (vs. "empty"). But pt_regs is shared with tools....
+	 */
+	long res;
+
+	/* Real registers */
+	long bta;	/* bta_l1, bta_l2, erbta */
+	long lp_start;
+	long lp_end;
+	long lp_count;
+	long status32;	/* status32_l1, status32_l2, erstatus */
+	long ret;	/* ilink1, ilink2 or eret */
+	long blink;
+	long fp;
+	long r26;	/* gp */
+	long r12;
+	long r11;
+	long r10;
+	long r9;
+	long r8;
+	long r7;
+	long r6;
+	long r5;
+	long r4;
+	long r3;
+	long r2;
+	long r1;
+	long r0;
+	long sp;	/* user/kernel sp depending on where we came from  */
+	long orig_r0;
+	long orig_r8;	/*to distinguish bet excp, sys call, int1 or int2 */
+};
+
+/* Callee saved registers - need to be saved only when you are scheduled out */
+
+struct callee_regs {
+	long res;	/* Again this is not needed */
+	long r25;
+	long r24;
+	long r23;
+	long r22;
+	long r21;
+	long r20;
+	long r19;
+	long r18;
+	long r17;
+	long r16;
+	long r15;
+	long r14;
+	long r13;
+};
+
+#define instruction_pointer(regs)	((regs)->ret)
+#define profile_pc(regs)		instruction_pointer(regs)
+
+/* return 1 if user mode or 0 if kernel mode */
+#define user_mode(regs) (regs->status32 & STATUS_U_MASK)
+
+#define user_stack_pointer(regs)\
+({  unsigned int sp;		\
+	if (user_mode(regs))	\
+		sp = (regs)->sp;\
+	else			\
+		sp = -1;	\
+	sp;			\
+})
+#endif /* !__ASSEMBLY__ */
+
+#endif /* __KERNEL__ */
+
+#ifndef __ASSEMBLY__
+/*
+ * Userspace ABI: Register state needed by
+ *  -ptrace (gdbserver)
+ *  -sigcontext (SA_SIGNINFO signal frame)
+ *
+ * This is to decouple pt_regs from user-space ABI, to be able to change it
+ * w/o affecting the ABI.
+ * Although the layout (initial padding) is similar to pt_regs to have some
+ * optimizations when copying pt_regs to/from user_regs_struct.
+ *
+ * Also, sigcontext only care about the scratch regs as that is what we really
+ * save/restore for signal handling.
+*/
+struct user_regs_struct {
+
+	struct scratch {
+		long pad;
+		long bta, lp_start, lp_end, lp_count;
+		long status32, ret, blink, fp, gp;
+		long r12, r11, r10, r9, r8, r7, r6, r5, r4, r3, r2, r1, r0;
+		long sp;
+	} scratch;
+	struct callee {
+		long pad;
+		long r25, r24, r23, r22, r21, r20;
+		long r19, r18, r17, r16, r15, r14, r13;
+	} callee;
+	long efa;	/* break pt addr, for break points in delay slots */
+	long stop_pc;	/* give dbg stop_pc directly after checking orig_r8 */
+};
+#endif /* !__ASSEMBLY__ */
+
+#endif /* __ASM_PTRACE_H */
