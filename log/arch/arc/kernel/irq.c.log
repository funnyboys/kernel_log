commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 62b185057c04..ef909dd4b40c 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -1,10 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2011-12 Synopsys, Inc. (www.synopsys.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
  */
 
 #include <linux/interrupt.h>

commit 2f24ef7413a4d91657ef04e77c27ce0b313e6c95
Author: Alexey Brodkin <Alexey.Brodkin@synopsys.com>
Date:   Wed Nov 29 11:21:45 2017 +0300

    ARC: Enable machine_desc->init_per_cpu for !CONFIG_SMP
    
    machine_desc->init_per_cpu() hook is supposed to be per cpu
    initialization and would seem to apply  equally to UP and/or SMP.
    Infact the comment in header file seems to suggest it works for
    UP too, which was not the case and this patch.
    
    This enables !CONFIG_SMP build for platforms such as hsdk.
    
    Signed-off-by: Alexey Brodkin <abrodkin@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    [vgupta: trimmeed changelog]

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 538b36afe89e..62b185057c04 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -31,10 +31,10 @@ void __init init_IRQ(void)
 	/* a SMP H/w block could do IPI IRQ request here */
 	if (plat_smp_ops.init_per_cpu)
 		plat_smp_ops.init_per_cpu(smp_processor_id());
+#endif
 
 	if (machine_desc->init_per_cpu)
 		machine_desc->init_per_cpu(smp_processor_id());
-#endif
 }
 
 /*

commit 1b0ccb8a4eee2d8c14adc996e07335cb7aa9e2ac
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 1 15:12:54 2016 +0530

    ARC: [intc-*] Do a domain lookup in primary handler for hwirq -> linux virq
    
    The primary interrupt handler arch_do_IRQ() was passing hwirq as linux
    virq to core code. This was fragile and worked so far as we only had legacy/linear
    domains.
    
    This came out of a rant by Marc Zyngier.
    http://lists.infradead.org/pipermail/linux-snps-arc/2015-December/000298.html
    
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Noam Camus <noamc@ezchip.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index fb6dede9d05f..538b36afe89e 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -41,12 +41,7 @@ void __init init_IRQ(void)
  * "C" Entry point for any ARC ISR, called from low level vector handler
  * @irq is the vector number read from ICAUSE reg of on-chip intc
  */
-void arch_do_IRQ(unsigned int irq, struct pt_regs *regs)
+void arch_do_IRQ(unsigned int hwirq, struct pt_regs *regs)
 {
-	struct pt_regs *old_regs = set_irq_regs(regs);
-
-	irq_enter();
-	generic_handle_irq(irq);
-	irq_exit();
-	set_irq_regs(old_regs);
+	handle_domain_irq(NULL, hwirq, regs);
 }

commit 569579401ae1c9b9f317f38261e32135b153e9b3
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu Jan 28 12:56:03 2016 +0530

    ARC: opencode arc_request_percpu_irq
    
    - The idea is to remove the API usage since it has a subltle
      design flaw - relies on being called on cpu0 first. This is true for
      some early per cpu irqs such as TIMER/IPI, but not for late probed
      per cpu peripherals such a perf. And it's usage in perf has already
      bitten us once: see c6317bc7c5ab
      ("ARCv2: perf: Ensure perf intr gets enabled on all cores") where we
      ended up open coding it anyways
    
    - The seeming duplication will go away once we start using cpu notifier
      for timer setup
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 88074b50456b..fb6dede9d05f 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -50,32 +50,3 @@ void arch_do_IRQ(unsigned int irq, struct pt_regs *regs)
 	irq_exit();
 	set_irq_regs(old_regs);
 }
-
-/*
- * API called for requesting percpu interrupts - called by each CPU
- *  - For boot CPU, actually request the IRQ with genirq core + enables
- *  - For subsequent callers only enable called locally
- *
- * Relies on being called by boot cpu first (i.e. request called ahead) of
- * any enable as expected by genirq. Hence Suitable only for TIMER, IPI
- * which are guaranteed to be setup on boot core first.
- * Late probed peripherals such as perf can't use this as there no guarantee
- * of being called on boot CPU first.
- */
-
-void arc_request_percpu_irq(int irq, int cpu,
-                            irqreturn_t (*isr)(int irq, void *dev),
-                            const char *irq_nm,
-                            void *percpu_dev)
-{
-	/* Boot cpu calls request, all call enable */
-	if (!cpu) {
-		int rc;
-
-		rc = request_percpu_irq(irq, isr, irq_nm, percpu_dev);
-		if (rc)
-			panic("Percpu IRQ request failed for %d\n", irq);
-	}
-
-	enable_percpu_irq(irq, 0);
-}

commit db4c4426daedffefcfd890d04a6ec9ed93268878
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu Jan 28 12:52:33 2016 +0530

    ARC: [intc-compact] setup TIMER as percpu_dev
    
    This removes the quirk from arc_request_percpu_irq() and paves way for
    future simplifications
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index ba17f85285cf..88074b50456b 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -72,18 +72,6 @@ void arc_request_percpu_irq(int irq, int cpu,
 	if (!cpu) {
 		int rc;
 
-#ifdef CONFIG_ISA_ARCOMPACT
-		/*
-		 * A subsequent request_percpu_irq() fails if percpu_devid is
-		 * not set. That in turns sets NOAUTOEN, meaning each core needs
-		 * to call enable_percpu_irq()
-		 *
-		 * For ARCv2, this is done in irq map function since we know
-		 * which irqs are strictly per cpu
-		 */
-		irq_set_percpu_devid(irq);
-#endif
-
 		rc = request_percpu_irq(irq, isr, irq_nm, percpu_dev);
 		if (rc)
 			panic("Percpu IRQ request failed for %d\n", irq);

commit 575a9d4e2c09675c05db2bc781c5c33153ce932f
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu Dec 17 12:22:21 2015 +0530

    ARC: smp: Rename platform hook @init_cpu_smp -> @init_per_cpu
    
    Makes it similar to smp_ops which also has callback with same name
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 3917fe7e62fc..ba17f85285cf 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -32,8 +32,8 @@ void __init init_IRQ(void)
 	if (plat_smp_ops.init_per_cpu)
 		plat_smp_ops.init_per_cpu(smp_processor_id());
 
-	if (machine_desc->init_cpu_smp)
-		machine_desc->init_cpu_smp(smp_processor_id());
+	if (machine_desc->init_per_cpu)
+		machine_desc->init_per_cpu(smp_processor_id());
 #endif
 }
 

commit b474a02382b75f4a75c4e94eb9847aad28dd4a37
Author: Noam Camus <noamc@ezchip.com>
Date:   Wed Dec 16 03:10:27 2015 +0200

    ARC: rename smp operation init_irq_cpu() to init_per_cpu()
    
    This will better reflect its description i.e. "any needed setup..."
    and not just do an "IPI request".
    
    Signed-off-by: Noam Camus <noamc@ezchip.com>
    Acked-by: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index b1f75937f0e1..3917fe7e62fc 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -29,8 +29,8 @@ void __init init_IRQ(void)
 
 #ifdef CONFIG_SMP
 	/* a SMP H/w block could do IPI IRQ request here */
-	if (plat_smp_ops.init_irq_cpu)
-		plat_smp_ops.init_irq_cpu(smp_processor_id());
+	if (plat_smp_ops.init_per_cpu)
+		plat_smp_ops.init_per_cpu(smp_processor_id());
 
 	if (machine_desc->init_cpu_smp)
 		machine_desc->init_cpu_smp(smp_processor_id());

commit c512c6ba7ac41b8bc196f17a85ee52099a109146
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Dec 11 19:31:23 2015 +0530

    ARC: intc: Document arc_request_percpu_irq() better
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index d736678d2724..b1f75937f0e1 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -51,6 +51,18 @@ void arch_do_IRQ(unsigned int irq, struct pt_regs *regs)
 	set_irq_regs(old_regs);
 }
 
+/*
+ * API called for requesting percpu interrupts - called by each CPU
+ *  - For boot CPU, actually request the IRQ with genirq core + enables
+ *  - For subsequent callers only enable called locally
+ *
+ * Relies on being called by boot cpu first (i.e. request called ahead) of
+ * any enable as expected by genirq. Hence Suitable only for TIMER, IPI
+ * which are guaranteed to be setup on boot core first.
+ * Late probed peripherals such as perf can't use this as there no guarantee
+ * of being called on boot CPU first.
+ */
+
 void arc_request_percpu_irq(int irq, int cpu,
                             irqreturn_t (*isr)(int irq, void *dev),
                             const char *irq_nm,

commit 5bf704c204440b1e90251382ee07a2dc5e4960ec
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Dec 11 16:16:11 2015 +0530

    ARC: intc: No need to clear IRQ_NOAUTOEN
    
    arc_request_percpu_irq() is called by all cores to request/enable percpu
    irq. It has some "prep" calls needed by genirq:
     - setup percpu devid
     - disable IRQ_NOAUTOEN
    
    However given that enable_percpu_irq() is called enayways, latter can be
    avoided.
    
    We are now left with irq_set_percpu_devid() quirk and that too for
    ARCompact builds only, since previous patch updated ARCv2 intc to do this
    in the "right" place, i.e. irq map function.
    
    By next release, this will ultimately be fixed for ARCompact as well.
    
    Cc: Marc Zyngier <marc.zyngier@arm.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Alexey Brodkin <abrodkin@synopsys.com>
    Cc: linux-snps-arc@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 2ee226546c6a..d736678d2724 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -60,14 +60,17 @@ void arc_request_percpu_irq(int irq, int cpu,
 	if (!cpu) {
 		int rc;
 
+#ifdef CONFIG_ISA_ARCOMPACT
 		/*
-		 * These 2 calls are essential to making percpu IRQ APIs work
-		 * Ideally these details could be hidden in irq chip map function
-		 * but the issue is IPIs IRQs being static (non-DT) and platform
-		 * specific, so we can't identify them there.
+		 * A subsequent request_percpu_irq() fails if percpu_devid is
+		 * not set. That in turns sets NOAUTOEN, meaning each core needs
+		 * to call enable_percpu_irq()
+		 *
+		 * For ARCv2, this is done in irq map function since we know
+		 * which irqs are strictly per cpu
 		 */
 		irq_set_percpu_devid(irq);
-		irq_modify_status(irq, IRQ_NOAUTOEN, 0);  /* @irq, @clr, @set */
+#endif
 
 		rc = request_percpu_irq(irq, isr, irq_nm, percpu_dev);
 		if (rc)

commit 286130ebf196d9643800977d57bdb7cda266b49e
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Oct 14 14:38:02 2015 +0530

    ARC: smp: Introduce smp hook @init_irq_cpu called for all cores
    
    Note this is not part of platform owned static machine_desc,
    but more of device owned plat_smp_ops (rather misnamed) which a IPI
    provider or some such typically defines.
    
    This will help us seperate out the IPI registration from platform
    specific init_cpu_smp() into device specific init_irq_cpu()
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 1dd8f2685afc..2ee226546c6a 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -10,6 +10,7 @@
 #include <linux/interrupt.h>
 #include <linux/irqchip.h>
 #include <asm/mach_desc.h>
+#include <asm/smp.h>
 
 /*
  * Late Interrupt system init called from start_kernel for Boot CPU only
@@ -27,7 +28,10 @@ void __init init_IRQ(void)
 	irqchip_init();
 
 #ifdef CONFIG_SMP
-	/* Master CPU can initialize it's side of IPI */
+	/* a SMP H/w block could do IPI IRQ request here */
+	if (plat_smp_ops.init_irq_cpu)
+		plat_smp_ops.init_irq_cpu(smp_processor_id());
+
 	if (machine_desc->init_cpu_smp)
 		machine_desc->init_cpu_smp(smp_processor_id());
 #endif

commit 8721a7f5a6f95c38cacbe1be22c820a7698926ef
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue Oct 13 15:26:00 2015 +0530

    ARC: smp: Rename platform hook @init_smp -> @init_cpu_smp
    
    This conveys better that it is called for each cpu
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 156489af75e8..1dd8f2685afc 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -28,8 +28,8 @@ void __init init_IRQ(void)
 
 #ifdef CONFIG_SMP
 	/* Master CPU can initialize it's side of IPI */
-	if (machine_desc->init_smp)
-		machine_desc->init_smp(smp_processor_id());
+	if (machine_desc->init_cpu_smp)
+		machine_desc->init_cpu_smp(smp_processor_id());
 #endif
 }
 

commit 4c82f28617ab9ce938118f0b99156a96c64d3da0
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue Oct 13 08:48:54 2015 +0530

    ARC: remove @init_time, @init_irq platform callbacks
    
    These are not in use for ARC platforms. Moreover DT mechanims exist to
    probe them w/o explicit platform calls.
    
     - clocksource drivers can use CLOCKSOURCE_OF_DECLARE()
     - intc IRQCHIP_DECLARE() calls + cascading inside DT allows external
       intc to be probed automatically
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 2989a7bcf8a8..156489af75e8 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -19,11 +19,11 @@
  */
 void __init init_IRQ(void)
 {
-	/* Any external intc can be setup here */
-	if (machine_desc->init_irq)
-		machine_desc->init_irq();
-
-	/* process the entire interrupt tree in one go */
+	/*
+	 * process the entire interrupt tree in one go
+	 * Any external intc will be setup provided DT chains them
+	 * properly
+	 */
 	irqchip_init();
 
 #ifdef CONFIG_SMP

commit 5793e273a134331d05ed904e5be3b31ccfca54c1
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu Mar 5 19:13:56 2015 +0530

    ARC: intc: split into ARCompact ISA specific, common bits
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 620ec2fe32a9..2989a7bcf8a8 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -8,115 +8,9 @@
  */
 
 #include <linux/interrupt.h>
-#include <linux/module.h>
-#include <linux/of.h>
-#include <linux/irqdomain.h>
 #include <linux/irqchip.h>
-#include "../../drivers/irqchip/irqchip.h"
-#include <asm/sections.h>
-#include <asm/irq.h>
 #include <asm/mach_desc.h>
 
-/*
- * Early Hardware specific Interrupt setup
- * -Platform independent, needed for each CPU (not foldable into init_IRQ)
- * -Called very early (start_kernel -> setup_arch -> setup_processor)
- *
- * what it does ?
- * -Optionally, setup the High priority Interrupts as Level 2 IRQs
- */
-void arc_init_IRQ(void)
-{
-	int level_mask = 0;
-
-       /* setup any high priority Interrupts (Level2 in ARCompact jargon) */
-	level_mask |= IS_ENABLED(CONFIG_ARC_IRQ3_LV2) << 3;
-	level_mask |= IS_ENABLED(CONFIG_ARC_IRQ5_LV2) << 5;
-	level_mask |= IS_ENABLED(CONFIG_ARC_IRQ6_LV2) << 6;
-
-	/*
-	 * Write to register, even if no LV2 IRQs configured to reset it
-	 * in case bootloader had mucked with it
-	 */
-	write_aux_reg(AUX_IRQ_LEV, level_mask);
-
-	if (level_mask)
-		pr_info("Level-2 interrupts bitset %x\n", level_mask);
-}
-
-/*
- * ARC700 core includes a simple on-chip intc supporting
- * -per IRQ enable/disable
- * -2 levels of interrupts (high/low)
- * -all interrupts being level triggered
- *
- * To reduce platform code, we assume all IRQs directly hooked-up into intc.
- * Platforms with external intc, hence cascaded IRQs, are free to over-ride
- * below, per IRQ.
- */
-
-static void arc_irq_mask(struct irq_data *data)
-{
-	unsigned int ienb;
-
-	ienb = read_aux_reg(AUX_IENABLE);
-	ienb &= ~(1 << data->irq);
-	write_aux_reg(AUX_IENABLE, ienb);
-}
-
-static void arc_irq_unmask(struct irq_data *data)
-{
-	unsigned int ienb;
-
-	ienb = read_aux_reg(AUX_IENABLE);
-	ienb |= (1 << data->irq);
-	write_aux_reg(AUX_IENABLE, ienb);
-}
-
-static struct irq_chip onchip_intc = {
-	.name           = "ARC In-core Intc",
-	.irq_mask	= arc_irq_mask,
-	.irq_unmask	= arc_irq_unmask,
-};
-
-static int arc_intc_domain_map(struct irq_domain *d, unsigned int irq,
-				irq_hw_number_t hw)
-{
-	if (irq == TIMER0_IRQ)
-		irq_set_chip_and_handler(irq, &onchip_intc, handle_percpu_irq);
-	else
-		irq_set_chip_and_handler(irq, &onchip_intc, handle_level_irq);
-
-	return 0;
-}
-
-static const struct irq_domain_ops arc_intc_domain_ops = {
-	.xlate = irq_domain_xlate_onecell,
-	.map = arc_intc_domain_map,
-};
-
-static struct irq_domain *root_domain;
-
-static int __init
-init_onchip_IRQ(struct device_node *intc, struct device_node *parent)
-{
-	if (parent)
-		panic("DeviceTree incore intc not a root irq controller\n");
-
-	root_domain = irq_domain_add_legacy(intc, NR_CPU_IRQS, 0, 0,
-					    &arc_intc_domain_ops, NULL);
-
-	if (!root_domain)
-		panic("root irq domain not avail\n");
-
-	/* with this we don't need to export root_domain */
-	irq_set_default_host(root_domain);
-
-	return 0;
-}
-
-IRQCHIP_DECLARE(arc_intc, "snps,arc700-intc", init_onchip_IRQ);
-
 /*
  * Late Interrupt system init called from start_kernel for Boot CPU only
  *
@@ -178,107 +72,3 @@ void arc_request_percpu_irq(int irq, int cpu,
 
 	enable_percpu_irq(irq, 0);
 }
-
-/*
- * arch_local_irq_enable - Enable interrupts.
- *
- * 1. Explicitly called to re-enable interrupts
- * 2. Implicitly called from spin_unlock_irq, write_unlock_irq etc
- *    which maybe in hard ISR itself
- *
- * Semantics of this function change depending on where it is called from:
- *
- * -If called from hard-ISR, it must not invert interrupt priorities
- *  e.g. suppose TIMER is high priority (Level 2) IRQ
- *    Time hard-ISR, timer_interrupt( ) calls spin_unlock_irq several times.
- *    Here local_irq_enable( ) shd not re-enable lower priority interrupts
- * -If called from soft-ISR, it must re-enable all interrupts
- *    soft ISR are low prioity jobs which can be very slow, thus all IRQs
- *    must be enabled while they run.
- *    Now hardware context wise we may still be in L2 ISR (not done rtie)
- *    still we must re-enable both L1 and L2 IRQs
- *  Another twist is prev scenario with flow being
- *     L1 ISR ==> interrupted by L2 ISR  ==> L2 soft ISR
- *     here we must not re-enable Ll as prev Ll Interrupt's h/w context will get
- *     over-written (this is deficiency in ARC700 Interrupt mechanism)
- */
-
-#ifdef CONFIG_ARC_COMPACT_IRQ_LEVELS	/* Complex version for 2 IRQ levels */
-
-void arch_local_irq_enable(void)
-{
-
-	unsigned long flags;
-	flags = arch_local_save_flags();
-
-	/* Allow both L1 and L2 at the onset */
-	flags |= (STATUS_E1_MASK | STATUS_E2_MASK);
-
-	/* Called from hard ISR (between irq_enter and irq_exit) */
-	if (in_irq()) {
-
-		/* If in L2 ISR, don't re-enable any further IRQs as this can
-		 * cause IRQ priorities to get upside down. e.g. it could allow
-		 * L1 be taken while in L2 hard ISR which is wrong not only in
-		 * theory, it can also cause the dreaded L1-L2-L1 scenario
-		 */
-		if (flags & STATUS_A2_MASK)
-			flags &= ~(STATUS_E1_MASK | STATUS_E2_MASK);
-
-		/* Even if in L1 ISR, allowe Higher prio L2 IRQs */
-		else if (flags & STATUS_A1_MASK)
-			flags &= ~(STATUS_E1_MASK);
-	}
-
-	/* called from soft IRQ, ideally we want to re-enable all levels */
-
-	else if (in_softirq()) {
-
-		/* However if this is case of L1 interrupted by L2,
-		 * re-enabling both may cause whaco L1-L2-L1 scenario
-		 * because ARC700 allows level 1 to interrupt an active L2 ISR
-		 * Thus we disable both
-		 * However some code, executing in soft ISR wants some IRQs
-		 * to be enabled so we re-enable L2 only
-		 *
-		 * How do we determine L1 intr by L2
-		 *  -A2 is set (means in L2 ISR)
-		 *  -E1 is set in this ISR's pt_regs->status32 which is
-		 *      saved copy of status32_l2 when l2 ISR happened
-		 */
-		struct pt_regs *pt = get_irq_regs();
-		if ((flags & STATUS_A2_MASK) && pt &&
-		    (pt->status32 & STATUS_A1_MASK)) {
-			/*flags &= ~(STATUS_E1_MASK | STATUS_E2_MASK); */
-			flags &= ~(STATUS_E1_MASK);
-		}
-	}
-
-	arch_local_irq_restore(flags);
-}
-
-#else /* ! CONFIG_ARC_COMPACT_IRQ_LEVELS */
-
-/*
- * Simpler version for only 1 level of interrupt
- * Here we only Worry about Level 1 Bits
- */
-void arch_local_irq_enable(void)
-{
-	unsigned long flags;
-
-	/*
-	 * ARC IDE Drivers tries to re-enable interrupts from hard-isr
-	 * context which is simply wrong
-	 */
-	if (in_irq()) {
-		WARN_ONCE(1, "IRQ enabled from hard-isr");
-		return;
-	}
-
-	flags = arch_local_save_flags();
-	flags |= (STATUS_E1_MASK | STATUS_E2_MASK);
-	arch_local_irq_restore(flags);
-}
-#endif
-EXPORT_SYMBOL(arch_local_irq_enable);

commit 590892deb650fa152698f0a2f4eba44789e51c38
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Jun 25 17:25:46 2014 +0530

    ARC: [intc] mask/unmask can be hidden again
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 02ffc764c97a..620ec2fe32a9 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -55,20 +55,28 @@ void arc_init_IRQ(void)
  * below, per IRQ.
  */
 
-static void arc_mask_irq(struct irq_data *data)
+static void arc_irq_mask(struct irq_data *data)
 {
-	arch_mask_irq(data->irq);
+	unsigned int ienb;
+
+	ienb = read_aux_reg(AUX_IENABLE);
+	ienb &= ~(1 << data->irq);
+	write_aux_reg(AUX_IENABLE, ienb);
 }
 
-static void arc_unmask_irq(struct irq_data *data)
+static void arc_irq_unmask(struct irq_data *data)
 {
-	arch_unmask_irq(data->irq);
+	unsigned int ienb;
+
+	ienb = read_aux_reg(AUX_IENABLE);
+	ienb |= (1 << data->irq);
+	write_aux_reg(AUX_IENABLE, ienb);
 }
 
 static struct irq_chip onchip_intc = {
 	.name           = "ARC In-core Intc",
-	.irq_mask	= arc_mask_irq,
-	.irq_unmask	= arc_unmask_irq,
+	.irq_mask	= arc_irq_mask,
+	.irq_unmask	= arc_irq_unmask,
 };
 
 static int arc_intc_domain_map(struct irq_domain *d, unsigned int irq,

commit 878f46c71e99cfb6d8e4e15a561db63a3c9601e5
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Jun 25 17:16:04 2014 +0530

    ARC: [intc] don't mask all IRQ by default
    
    Hardware keeps them enabled on reset, and Linux needs to keep status quo.
    Any spurious interrupts will be reported/blocked by genirq.
    
    This helps remove a SMP IRQ quirk (next commit), where a peripheral IRQ
    is hard wired to core0, and request_irq()->unmask() happens on core1,
    keeping the IRQ masked on core0, needing an explicit unmask.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 835fa5e71b62..02ffc764c97a 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -19,21 +19,16 @@
 
 /*
  * Early Hardware specific Interrupt setup
+ * -Platform independent, needed for each CPU (not foldable into init_IRQ)
  * -Called very early (start_kernel -> setup_arch -> setup_processor)
- * -Platform Independent (must for any ARC700)
- * -Needed for each CPU (hence not foldable into init_IRQ)
  *
  * what it does ?
- * -Disable all IRQs (on CPU side)
  * -Optionally, setup the High priority Interrupts as Level 2 IRQs
  */
 void arc_init_IRQ(void)
 {
 	int level_mask = 0;
 
-	/* Disable all IRQs: enable them as devices request */
-	write_aux_reg(AUX_IENABLE, 0);
-
        /* setup any high priority Interrupts (Level2 in ARCompact jargon) */
 	level_mask |= IS_ENABLED(CONFIG_ARC_IRQ3_LV2) << 3;
 	level_mask |= IS_ENABLED(CONFIG_ARC_IRQ5_LV2) << 5;

commit 2b75c0f93e395aa6130c20a08016b143e6ec8c53
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed May 7 15:25:10 2014 +0530

    ARC: [SMP] unify cpu private IRQ requests (TIMER/IPI)
    
    The current cpu-private IRQ registration is ugly as it requires need to
    expose arch_unmask_irq() outside of intc code.
    So switch to percpu IRQ APIs:
      -request_percpu_irq [boot core]
      -enable_percpu_irq  [all cores]
    
    Encapsulated in helper arc_request_percpu_irq()
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 7d653c0d0773..835fa5e71b62 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -150,6 +150,32 @@ void arch_do_IRQ(unsigned int irq, struct pt_regs *regs)
 	set_irq_regs(old_regs);
 }
 
+void arc_request_percpu_irq(int irq, int cpu,
+                            irqreturn_t (*isr)(int irq, void *dev),
+                            const char *irq_nm,
+                            void *percpu_dev)
+{
+	/* Boot cpu calls request, all call enable */
+	if (!cpu) {
+		int rc;
+
+		/*
+		 * These 2 calls are essential to making percpu IRQ APIs work
+		 * Ideally these details could be hidden in irq chip map function
+		 * but the issue is IPIs IRQs being static (non-DT) and platform
+		 * specific, so we can't identify them there.
+		 */
+		irq_set_percpu_devid(irq);
+		irq_modify_status(irq, IRQ_NOAUTOEN, 0);  /* @irq, @clr, @set */
+
+		rc = request_percpu_irq(irq, isr, irq_nm, percpu_dev);
+		if (rc)
+			panic("Percpu IRQ request failed for %d\n", irq);
+	}
+
+	enable_percpu_irq(irq, 0);
+}
+
 /*
  * arch_local_irq_enable - Enable interrupts.
  *

commit 9a091d9e8450a4cec76bd208bbbb017a12795416
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Feb 28 16:13:44 2014 +0800

    ARC: [SMP] ISS SMP extension bitrot
    
    * Move extension specific code out of common SMP code
    * Don't enable it by default for SMP
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index a4b141ee9a6a..7d653c0d0773 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -150,24 +150,6 @@ void arch_do_IRQ(unsigned int irq, struct pt_regs *regs)
 	set_irq_regs(old_regs);
 }
 
-int get_hw_config_num_irq(void)
-{
-	uint32_t val = read_aux_reg(ARC_REG_VECBASE_BCR);
-
-	switch (val & 0x03) {
-	case 0:
-		return 16;
-	case 1:
-		return 32;
-	case 2:
-		return 8;
-	default:
-		return 0;
-	}
-
-	return 0;
-}
-
 /*
  * arch_local_irq_enable - Enable interrupts.
  *

commit 4782f7f9aeba4dfd383c532e96bebf83ce0b9748
Author: Chen Gang <gang.chen@asianux.com>
Date:   Wed Oct 23 11:02:51 2013 +0800

    arc: remove '__init' for get_hw_config_num_irq()
    
    get_hw_config_num_irq() may be called by normal iss_model_init_smp()
    which is a function pointer for 'init_smp' which may be called by
    first_lines_of_secondary() which also need be normal too.
    
    The related warning (with allmodconfig):
    
        MODPOST vmlinux.o
      WARNING: vmlinux.o(.text+0x5814): Section mismatch in reference from the function iss_model_init_smp() to the function .init.text:get_hw_config_num_irq()
      The function iss_model_init_smp() references
      the function __init get_hw_config_num_irq().
      This is often because iss_model_init_smp lacks a __init
      annotation or the annotation of get_hw_config_num_irq is wrong.
    
    Signed-off-by: Chen Gang <gang.chen@asianux.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 02684e1a0cf0..a4b141ee9a6a 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -150,7 +150,7 @@ void arch_do_IRQ(unsigned int irq, struct pt_regs *regs)
 	set_irq_regs(old_regs);
 }
 
-int __init get_hw_config_num_irq(void)
+int get_hw_config_num_irq(void)
 {
 	uint32_t val = read_aux_reg(ARC_REG_VECBASE_BCR);
 

commit 54c8bff14d604de23d0718eee59c5436a4703fe5
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu Sep 12 13:53:06 2013 +0530

    ARC: Reset the value of Interrupt Priority Register
    
    In case bootloader has changed the priority of one/more IRQ lines
    
    Reported-by: Noam Camus <noamc@ezchip.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 5fc92455da36..02684e1a0cf0 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -39,10 +39,14 @@ void arc_init_IRQ(void)
 	level_mask |= IS_ENABLED(CONFIG_ARC_IRQ5_LV2) << 5;
 	level_mask |= IS_ENABLED(CONFIG_ARC_IRQ6_LV2) << 6;
 
-	if (level_mask) {
+	/*
+	 * Write to register, even if no LV2 IRQs configured to reset it
+	 * in case bootloader had mucked with it
+	 */
+	write_aux_reg(AUX_IRQ_LEV, level_mask);
+
+	if (level_mask)
 		pr_info("Level-2 interrupts bitset %x\n", level_mask);
-		write_aux_reg(AUX_IRQ_LEV, level_mask);
-	}
 }
 
 /*

commit c3567f8a359b7917dcffa442301f88ed0a75211f
Author: Noam Camus <noamc@ezchip.com>
Date:   Thu Sep 12 13:07:39 2013 +0530

    ARC: SMP failed to boot due to missing IVT setup
    
    Commit 05b016ecf5e7a "ARC: Setup Vector Table Base in early boot" moved
    the Interrupt vector Table setup out of arc_init_IRQ() which is called
    for all CPUs, to entry point of boot cpu only, breaking booting of others.
    
    Fix by adding the same to entry point of non-boot CPUs too.
    
    read_arc_build_cfg_regs() printing IVT Base Register didn't help the
    casue since it prints a synthetic value if zero which is totally bogus,
    so fix that to print the exact Register.
    
    [vgupta: Remove the now stale comment from header of arc_init_IRQ and
    also added the commentary for halt-on-reset]
    
    Cc: Gilad Ben-Yossef <gilad@benyossef.com>
    Cc: Cc: <stable@vger.kernel.org> #3.11
    Signed-off-by: Noam Camus <noamc@ezchip.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 305b3f866aa7..5fc92455da36 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -24,7 +24,6 @@
  * -Needed for each CPU (hence not foldable into init_IRQ)
  *
  * what it does ?
- * -setup Vector Table Base Reg - in case Linux not linked at 0x8000_0000
  * -Disable all IRQs (on CPU side)
  * -Optionally, setup the High priority Interrupts as Level 2 IRQs
  */

commit ce7599567e27eabc1003e35b6f05579268dafecd
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jun 24 15:30:15 2013 -0400

    arc: delete __cpuinit usage from all arc files
    
    The __cpuinit type of throwaway sections might have made sense
    some time ago when RAM was more constrained, but now the savings
    do not offset the cost and complications.  For example, the fix in
    commit 5e427ec2d0 ("x86: Fix bit corruption at CPU resume time")
    is a good example of the nasty type of bugs that can be created
    with improper use of the various __init prefixes.
    
    After a discussion on LKML[1] it was decided that cpuinit should go
    the way of devinit and be phased out.  Once all the users are gone,
    we can then finally remove the macros themselves from linux/init.h.
    
    Note that some harmless section mismatch warnings may result, since
    notify_cpu_starting() and cpu_up() are arch independent (kernel/cpu.c)
    are flagged as __cpuinit  -- so if we remove the __cpuinit from
    arch specific callers, we will also get section mismatch warnings.
    As an intermediate step, we intend to turn the linux/init.h cpuinit
    content into no-ops as early as possible, since that will get rid
    of these warnings.  In any case, they are temporary and harmless.
    
    This removes all the arch/arc uses of the __cpuinit macros from
    all C files.  Currently arc does not have any __CPUINIT used in
    assembly files.
    
    [1] https://lkml.org/lkml/2013/5/20/589
    
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 4918a66a1d8e..305b3f866aa7 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -28,7 +28,7 @@
  * -Disable all IRQs (on CPU side)
  * -Optionally, setup the High priority Interrupts as Level 2 IRQs
  */
-void __cpuinit arc_init_IRQ(void)
+void arc_init_IRQ(void)
 {
 	int level_mask = 0;
 

commit 05b016ecf5e7a8c24409d8e9effb5d2ec9107708
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon Jun 17 18:27:23 2013 +0530

    ARC: Setup Vector Table Base in early boot
    
    Otherwise early boot exceptions such as instructions errors due to
    configuration mismatch between kernel and hardware go off to la-la land,
    as opposed to hitting the handler and panic()'ing properly.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index d1ef4129de7d..4918a66a1d8e 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -32,8 +32,6 @@ void __cpuinit arc_init_IRQ(void)
 {
 	int level_mask = 0;
 
-	write_aux_reg(AUX_INTR_VEC_BASE, _int_vec_base_lds);
-
 	/* Disable all IRQs: enable them as devices request */
 	write_aux_reg(AUX_IENABLE, 0);
 

commit 18437347b976b81e616a57fb36922a240e71a6de
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu Jun 20 16:20:14 2013 +0530

    ARC: More code beautification with IS_ENABLED()
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 8115fa531575..d1ef4129de7d 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -38,15 +38,9 @@ void __cpuinit arc_init_IRQ(void)
 	write_aux_reg(AUX_IENABLE, 0);
 
        /* setup any high priority Interrupts (Level2 in ARCompact jargon) */
-#ifdef CONFIG_ARC_IRQ3_LV2
-	level_mask |= (1 << 3);
-#endif
-#ifdef CONFIG_ARC_IRQ5_LV2
-	level_mask |= (1 << 5);
-#endif
-#ifdef CONFIG_ARC_IRQ6_LV2
-	level_mask |= (1 << 6);
-#endif
+	level_mask |= IS_ENABLED(CONFIG_ARC_IRQ3_LV2) << 3;
+	level_mask |= IS_ENABLED(CONFIG_ARC_IRQ5_LV2) << 5;
+	level_mask |= IS_ENABLED(CONFIG_ARC_IRQ6_LV2) << 6;
 
 	if (level_mask) {
 		pr_info("Level-2 interrupts bitset %x\n", level_mask);

commit a37cdacc9bc339097a2c206aad449ca307d7fd63
Author: Christian Ruppert <christian.ruppert@abilis.com>
Date:   Thu Apr 11 15:19:39 2013 +0200

    ARC: Prepare interrupt code for external controllers
    
    This patch adds some room for CPU-external interrupt controllers in the
    Linux interrupt space. Until now, only the 32 CPU internal interrupt lines
    were supported which does not allow for external interrupt controllers such
    as GPIO modules etc.
    
    Signed-off-by: Christian Ruppert <christian.ruppert@abilis.com>
    Signed-off-by: Pierrick Hascoet <pierrick.hascoet@abilis.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index dd4b7e32ad4f..8115fa531575 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -105,7 +105,7 @@ init_onchip_IRQ(struct device_node *intc, struct device_node *parent)
 	if (parent)
 		panic("DeviceTree incore intc not a root irq controller\n");
 
-	root_domain = irq_domain_add_legacy(intc, NR_IRQS, 0, 0,
+	root_domain = irq_domain_add_legacy(intc, NR_CPU_IRQS, 0, 0,
 					    &arc_intc_domain_ops, NULL);
 
 	if (!root_domain)

commit c93d8b8c781f99d578ee499d178929323ca5cbc7
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Thu Apr 11 14:47:36 2013 +0530

    ARC: Allow embedded arc-intc to be properly placed in DT intc hierarchy
    
    arc-intc is initialized in arc common code as it is applicable to all
    platforms. However platforms with their own external intc still need to
    refer to it for correct DT interrupt tree hierarchy setup,
    
    e.g.
    static struct of_device_id __initdata tb10x_irq_ids[] = {
            { .compatible = "snps,arc700-intc", .data = dummy_init_irq },
            { .compatible = "abilis,tb10x_ictl", .data = tb10x_init_irq },
            {},
    };
    
    The fix is to use the generic irqchip framework to tie all irqchips in
    a special linker section and then call irqchip_init() which calls the
    DT of_irq_init() for all the intc in one go.
    
    That way the platform code need not be aware of arc-intc at all.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 84ce5317d9fc..dd4b7e32ad4f 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -11,6 +11,8 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/irqdomain.h>
+#include <linux/irqchip.h>
+#include "../../drivers/irqchip/irqchip.h"
 #include <asm/sections.h>
 #include <asm/irq.h>
 #include <asm/mach_desc.h>
@@ -97,13 +99,11 @@ static const struct irq_domain_ops arc_intc_domain_ops = {
 
 static struct irq_domain *root_domain;
 
-void __init init_onchip_IRQ(void)
+static int __init
+init_onchip_IRQ(struct device_node *intc, struct device_node *parent)
 {
-	struct device_node *intc = NULL;
-
-	intc = of_find_compatible_node(NULL, NULL, "snps,arc700-intc");
-	if (!intc)
-		panic("DeviceTree Missing incore intc\n");
+	if (parent)
+		panic("DeviceTree incore intc not a root irq controller\n");
 
 	root_domain = irq_domain_add_legacy(intc, NR_IRQS, 0, 0,
 					    &arc_intc_domain_ops, NULL);
@@ -113,8 +113,12 @@ void __init init_onchip_IRQ(void)
 
 	/* with this we don't need to export root_domain */
 	irq_set_default_host(root_domain);
+
+	return 0;
 }
 
+IRQCHIP_DECLARE(arc_intc, "snps,arc700-intc", init_onchip_IRQ);
+
 /*
  * Late Interrupt system init called from start_kernel for Boot CPU only
  *
@@ -123,12 +127,13 @@ void __init init_onchip_IRQ(void)
  */
 void __init init_IRQ(void)
 {
-	init_onchip_IRQ();
-
 	/* Any external intc can be setup here */
 	if (machine_desc->init_irq)
 		machine_desc->init_irq();
 
+	/* process the entire interrupt tree in one go */
+	irqchip_init();
+
 #ifdef CONFIG_SMP
 	/* Master CPU can initialize it's side of IPI */
 	if (machine_desc->init_smp)

commit 30ecee8cdd05415e5602bd755d9210e1c5a5b64d
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue Apr 9 17:18:12 2013 +0530

    ARC: [build] Fix warnings with CONFIG_DEBUG_SECTION_MISMATCH
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index d32c050dd7b9..84ce5317d9fc 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -26,7 +26,7 @@
  * -Disable all IRQs (on CPU side)
  * -Optionally, setup the High priority Interrupts as Level 2 IRQs
  */
-void __init arc_init_IRQ(void)
+void __cpuinit arc_init_IRQ(void)
 {
 	int level_mask = 0;
 

commit 955ad5959f913bd340ecb8d5e78d03ef7d1b0392
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed Mar 6 16:53:45 2013 +0530

    ARC: Fix coding style issues
    
    Fixes the following coding style issues as detected by checkpatch:
    ERROR: space required before the open parenthesis '('
    ERROR: "foo * bar" should be "foo *bar"
    WARNING: space prohibited between function name and open parenthesis '('
    WARNING: please, no spaces at the start of a line
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 551c10dff481..d32c050dd7b9 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -102,7 +102,7 @@ void __init init_onchip_IRQ(void)
 	struct device_node *intc = NULL;
 
 	intc = of_find_compatible_node(NULL, NULL, "snps,arc700-intc");
-	if(!intc)
+	if (!intc)
 		panic("DeviceTree Missing incore intc\n");
 
 	root_domain = irq_domain_add_legacy(intc, NR_IRQS, 0, 0,

commit 877768c84d6ca8f7dedafff0e44615a12e82f8f4
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed Jan 23 16:32:48 2013 +0530

    ARC: [Review] Multi-platform image #3: switch to board callback
    
    -platform API is retired and instead callbacks are used
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 1198168850e8..551c10dff481 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -124,7 +124,6 @@ void __init init_onchip_IRQ(void)
 void __init init_IRQ(void)
 {
 	init_onchip_IRQ();
-	plat_init_IRQ();
 
 	/* Any external intc can be setup here */
 	if (machine_desc->init_irq)
@@ -132,7 +131,6 @@ void __init init_IRQ(void)
 
 #ifdef CONFIG_SMP
 	/* Master CPU can initialize it's side of IPI */
-	arc_platform_smp_init_cpu();
 	if (machine_desc->init_smp)
 		machine_desc->init_smp(smp_processor_id());
 #endif

commit 03a6d28cdddfbd11b338c23e7fe51d0816b9bdef
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:26 2013 +0530

    ARC: [Review] Multi-platform image #2: Board callback Infrastructure
    
    The orig platform code orgnaization was singleton design pattern - only
    one platform (and board thereof) would build at a time.
    
    Thus any platform/board specific code (e.g. irq init, early init ...)
    expected by ARC common code was exported as well defined set of APIs,
    with only ONE instance building ever.
    
    Now with multiple-platform build requirement, that design of code no
    longer holds - multiple board specific calls need to build at the same
    time - so ARC common code can't use the API approach, it needs a
    callback based design where each board registers it's specific set of
    functions, and at runtime, depending on board detection, the callbacks
    are used from the registry.
    
    This commit adds all the infrastructure, where board specific callbacks
    are specified as a "maThine description".
    
    All the hooks are placed in right spots, no board callbacks registered
    yet (with MACHINE_STARt/END constructs) so the hooks will not run.
    
    Next commit will actually convert the platform to this infrastructure.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index df7da2b5a5bd..1198168850e8 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -13,6 +13,7 @@
 #include <linux/irqdomain.h>
 #include <asm/sections.h>
 #include <asm/irq.h>
+#include <asm/mach_desc.h>
 
 /*
  * Early Hardware specific Interrupt setup
@@ -125,9 +126,15 @@ void __init init_IRQ(void)
 	init_onchip_IRQ();
 	plat_init_IRQ();
 
+	/* Any external intc can be setup here */
+	if (machine_desc->init_irq)
+		machine_desc->init_irq();
+
 #ifdef CONFIG_SMP
 	/* Master CPU can initialize it's side of IPI */
 	arc_platform_smp_init_cpu();
+	if (machine_desc->init_smp)
+		machine_desc->init_smp(smp_processor_id());
 #endif
 }
 

commit 41195d236e84458bebd4fdc218610a92231ac791
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:23 2013 +0530

    ARC: SMP support
    
    ARC common code to enable a SMP system + ISS provided SMP extensions.
    
    ARC700 natively lacks SMP support, hence some of the core features are
    are only enabled if SoCs have the necessary h/w pixie-dust. This
    includes:
    -Inter Processor Interrupts (IPI)
    -Cache coherency
    -load-locked/store-conditional
    ...
    
    The low level exception handling would be completely broken in SMP
    because we don't have hardware assisted stack switching. Thus a fair bit
    of this code is repurposing the MMU_SCRATCH reg for event handler
    prologues to keep them re-entrant.
    
    Many thanks to Rajeshwar Ranga for his initial "major" contributions to
    SMP Port (back in 2008), and to Noam Camus and Gilad Ben-Yossef for help
    with resurrecting that in 3.2 kernel (2012).
    
    Note that this platform code is again singleton design pattern - so
    multiple SMP platforms won't build at the moment - this deficiency is
    addressed in subsequent patches within this series.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Rajeshwar Ranga <rajeshwar.ranga@gmail.com>
    Cc: Noam Camus <noamc@ezchip.com>
    Cc: Gilad Ben-Yossef <gilad@benyossef.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index ca70894e2309..df7da2b5a5bd 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -124,6 +124,11 @@ void __init init_IRQ(void)
 {
 	init_onchip_IRQ();
 	plat_init_IRQ();
+
+#ifdef CONFIG_SMP
+	/* Master CPU can initialize it's side of IPI */
+	arc_platform_smp_init_cpu();
+#endif
 }
 
 /*

commit 4788a5942bc896803c87005be8c6dd14c373a2d3
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:22 2013 +0530

    ARC: Support for high priority interrupts in the in-core intc
    
    There is a bit of hack/kludge right now where we disable preemption if a
    L2 (High prio) IRQ is taken while L1 (Low prio) is active.
    
    Need to revisit this
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 3c18e66386c7..ca70894e2309 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -23,15 +23,32 @@
  * what it does ?
  * -setup Vector Table Base Reg - in case Linux not linked at 0x8000_0000
  * -Disable all IRQs (on CPU side)
+ * -Optionally, setup the High priority Interrupts as Level 2 IRQs
  */
 void __init arc_init_IRQ(void)
 {
-	int level_mask = level_mask;
+	int level_mask = 0;
 
 	write_aux_reg(AUX_INTR_VEC_BASE, _int_vec_base_lds);
 
 	/* Disable all IRQs: enable them as devices request */
 	write_aux_reg(AUX_IENABLE, 0);
+
+       /* setup any high priority Interrupts (Level2 in ARCompact jargon) */
+#ifdef CONFIG_ARC_IRQ3_LV2
+	level_mask |= (1 << 3);
+#endif
+#ifdef CONFIG_ARC_IRQ5_LV2
+	level_mask |= (1 << 5);
+#endif
+#ifdef CONFIG_ARC_IRQ6_LV2
+	level_mask |= (1 << 6);
+#endif
+
+	if (level_mask) {
+		pr_info("Level-2 interrupts bitset %x\n", level_mask);
+		write_aux_reg(AUX_IRQ_LEV, level_mask);
+	}
 }
 
 /*
@@ -141,6 +158,90 @@ int __init get_hw_config_num_irq(void)
 	return 0;
 }
 
+/*
+ * arch_local_irq_enable - Enable interrupts.
+ *
+ * 1. Explicitly called to re-enable interrupts
+ * 2. Implicitly called from spin_unlock_irq, write_unlock_irq etc
+ *    which maybe in hard ISR itself
+ *
+ * Semantics of this function change depending on where it is called from:
+ *
+ * -If called from hard-ISR, it must not invert interrupt priorities
+ *  e.g. suppose TIMER is high priority (Level 2) IRQ
+ *    Time hard-ISR, timer_interrupt( ) calls spin_unlock_irq several times.
+ *    Here local_irq_enable( ) shd not re-enable lower priority interrupts
+ * -If called from soft-ISR, it must re-enable all interrupts
+ *    soft ISR are low prioity jobs which can be very slow, thus all IRQs
+ *    must be enabled while they run.
+ *    Now hardware context wise we may still be in L2 ISR (not done rtie)
+ *    still we must re-enable both L1 and L2 IRQs
+ *  Another twist is prev scenario with flow being
+ *     L1 ISR ==> interrupted by L2 ISR  ==> L2 soft ISR
+ *     here we must not re-enable Ll as prev Ll Interrupt's h/w context will get
+ *     over-written (this is deficiency in ARC700 Interrupt mechanism)
+ */
+
+#ifdef CONFIG_ARC_COMPACT_IRQ_LEVELS	/* Complex version for 2 IRQ levels */
+
+void arch_local_irq_enable(void)
+{
+
+	unsigned long flags;
+	flags = arch_local_save_flags();
+
+	/* Allow both L1 and L2 at the onset */
+	flags |= (STATUS_E1_MASK | STATUS_E2_MASK);
+
+	/* Called from hard ISR (between irq_enter and irq_exit) */
+	if (in_irq()) {
+
+		/* If in L2 ISR, don't re-enable any further IRQs as this can
+		 * cause IRQ priorities to get upside down. e.g. it could allow
+		 * L1 be taken while in L2 hard ISR which is wrong not only in
+		 * theory, it can also cause the dreaded L1-L2-L1 scenario
+		 */
+		if (flags & STATUS_A2_MASK)
+			flags &= ~(STATUS_E1_MASK | STATUS_E2_MASK);
+
+		/* Even if in L1 ISR, allowe Higher prio L2 IRQs */
+		else if (flags & STATUS_A1_MASK)
+			flags &= ~(STATUS_E1_MASK);
+	}
+
+	/* called from soft IRQ, ideally we want to re-enable all levels */
+
+	else if (in_softirq()) {
+
+		/* However if this is case of L1 interrupted by L2,
+		 * re-enabling both may cause whaco L1-L2-L1 scenario
+		 * because ARC700 allows level 1 to interrupt an active L2 ISR
+		 * Thus we disable both
+		 * However some code, executing in soft ISR wants some IRQs
+		 * to be enabled so we re-enable L2 only
+		 *
+		 * How do we determine L1 intr by L2
+		 *  -A2 is set (means in L2 ISR)
+		 *  -E1 is set in this ISR's pt_regs->status32 which is
+		 *      saved copy of status32_l2 when l2 ISR happened
+		 */
+		struct pt_regs *pt = get_irq_regs();
+		if ((flags & STATUS_A2_MASK) && pt &&
+		    (pt->status32 & STATUS_A1_MASK)) {
+			/*flags &= ~(STATUS_E1_MASK | STATUS_E2_MASK); */
+			flags &= ~(STATUS_E1_MASK);
+		}
+	}
+
+	arch_local_irq_restore(flags);
+}
+
+#else /* ! CONFIG_ARC_COMPACT_IRQ_LEVELS */
+
+/*
+ * Simpler version for only 1 level of interrupt
+ * Here we only Worry about Level 1 Bits
+ */
 void arch_local_irq_enable(void)
 {
 	unsigned long flags;
@@ -158,4 +259,5 @@ void arch_local_irq_enable(void)
 	flags |= (STATUS_E1_MASK | STATUS_E2_MASK);
 	arch_local_irq_restore(flags);
 }
+#endif
 EXPORT_SYMBOL(arch_local_irq_enable);

commit abe11ddea1d759f9995a9a4636c28c9b40856ca8
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:21 2013 +0530

    ARC: [plat-arcfpga]: Enabling DeviceTree for Angel4 board
    
    * arc-uart platform device now populated dynamically, using
      of_platform_populate() - applies to any other device whatsoever.
    
    * uart in turn requires incore arc-intc to be also present in DT
    
    * A irq-domain needs to be instantiated for IRQ requests by DT probed
      device (e.g. arc-uart)
    
    TODO: switch over to linear irq domain once all devs have been
          transitioned to DT
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index 2f399eb88f9d..3c18e66386c7 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -9,6 +9,8 @@
 
 #include <linux/interrupt.h>
 #include <linux/module.h>
+#include <linux/of.h>
+#include <linux/irqdomain.h>
 #include <asm/sections.h>
 #include <asm/irq.h>
 
@@ -59,16 +61,40 @@ static struct irq_chip onchip_intc = {
 	.irq_unmask	= arc_unmask_irq,
 };
 
+static int arc_intc_domain_map(struct irq_domain *d, unsigned int irq,
+				irq_hw_number_t hw)
+{
+	if (irq == TIMER0_IRQ)
+		irq_set_chip_and_handler(irq, &onchip_intc, handle_percpu_irq);
+	else
+		irq_set_chip_and_handler(irq, &onchip_intc, handle_level_irq);
+
+	return 0;
+}
+
+static const struct irq_domain_ops arc_intc_domain_ops = {
+	.xlate = irq_domain_xlate_onecell,
+	.map = arc_intc_domain_map,
+};
+
+static struct irq_domain *root_domain;
+
 void __init init_onchip_IRQ(void)
 {
-	int i;
+	struct device_node *intc = NULL;
+
+	intc = of_find_compatible_node(NULL, NULL, "snps,arc700-intc");
+	if(!intc)
+		panic("DeviceTree Missing incore intc\n");
+
+	root_domain = irq_domain_add_legacy(intc, NR_IRQS, 0, 0,
+					    &arc_intc_domain_ops, NULL);
 
-	for (i = 0; i < NR_IRQS; i++)
-		irq_set_chip_and_handler(i, &onchip_intc, handle_level_irq);
+	if (!root_domain)
+		panic("root irq domain not avail\n");
 
-#ifdef CONFIG_SMP
-	irq_set_chip_and_handler(TIMER0_IRQ, &onchip_intc, handle_percpu_irq);
-#endif
+	/* with this we don't need to export root_domain */
+	irq_set_default_host(root_domain);
 }
 
 /*

commit bacdf4809afade180a8f2171adb4cf7ec715d139
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:18 2013 +0530

    ARC: Interrupt Handling
    
    This contains:
    -bootup arch IRQ init: init_IRQ(), arc_init_IRQ()
    -generic IRQ subsystem glue: arch_do_IRQ()
    -basic IRQ chip setup for in-core intc
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
index c4e9b25d305f..2f399eb88f9d 100644
--- a/arch/arc/kernel/irq.c
+++ b/arch/arc/kernel/irq.c
@@ -9,8 +9,111 @@
 
 #include <linux/interrupt.h>
 #include <linux/module.h>
-#include <asm/irqflags.h>
-#include <asm/arcregs.h>
+#include <asm/sections.h>
+#include <asm/irq.h>
+
+/*
+ * Early Hardware specific Interrupt setup
+ * -Called very early (start_kernel -> setup_arch -> setup_processor)
+ * -Platform Independent (must for any ARC700)
+ * -Needed for each CPU (hence not foldable into init_IRQ)
+ *
+ * what it does ?
+ * -setup Vector Table Base Reg - in case Linux not linked at 0x8000_0000
+ * -Disable all IRQs (on CPU side)
+ */
+void __init arc_init_IRQ(void)
+{
+	int level_mask = level_mask;
+
+	write_aux_reg(AUX_INTR_VEC_BASE, _int_vec_base_lds);
+
+	/* Disable all IRQs: enable them as devices request */
+	write_aux_reg(AUX_IENABLE, 0);
+}
+
+/*
+ * ARC700 core includes a simple on-chip intc supporting
+ * -per IRQ enable/disable
+ * -2 levels of interrupts (high/low)
+ * -all interrupts being level triggered
+ *
+ * To reduce platform code, we assume all IRQs directly hooked-up into intc.
+ * Platforms with external intc, hence cascaded IRQs, are free to over-ride
+ * below, per IRQ.
+ */
+
+static void arc_mask_irq(struct irq_data *data)
+{
+	arch_mask_irq(data->irq);
+}
+
+static void arc_unmask_irq(struct irq_data *data)
+{
+	arch_unmask_irq(data->irq);
+}
+
+static struct irq_chip onchip_intc = {
+	.name           = "ARC In-core Intc",
+	.irq_mask	= arc_mask_irq,
+	.irq_unmask	= arc_unmask_irq,
+};
+
+void __init init_onchip_IRQ(void)
+{
+	int i;
+
+	for (i = 0; i < NR_IRQS; i++)
+		irq_set_chip_and_handler(i, &onchip_intc, handle_level_irq);
+
+#ifdef CONFIG_SMP
+	irq_set_chip_and_handler(TIMER0_IRQ, &onchip_intc, handle_percpu_irq);
+#endif
+}
+
+/*
+ * Late Interrupt system init called from start_kernel for Boot CPU only
+ *
+ * Since slab must already be initialized, platforms can start doing any
+ * needed request_irq( )s
+ */
+void __init init_IRQ(void)
+{
+	init_onchip_IRQ();
+	plat_init_IRQ();
+}
+
+/*
+ * "C" Entry point for any ARC ISR, called from low level vector handler
+ * @irq is the vector number read from ICAUSE reg of on-chip intc
+ */
+void arch_do_IRQ(unsigned int irq, struct pt_regs *regs)
+{
+	struct pt_regs *old_regs = set_irq_regs(regs);
+
+	irq_enter();
+	generic_handle_irq(irq);
+	irq_exit();
+	set_irq_regs(old_regs);
+}
+
+int __init get_hw_config_num_irq(void)
+{
+	uint32_t val = read_aux_reg(ARC_REG_VECBASE_BCR);
+
+	switch (val & 0x03) {
+	case 0:
+		return 16;
+	case 1:
+		return 32;
+	case 2:
+		return 8;
+	default:
+		return 0;
+	}
+
+	return 0;
+}
 
 void arch_local_irq_enable(void)
 {

commit ac4c244d4e5d914f9a5642cdcc03b18780e55dbc
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:16 2013 +0530

    ARC: irqflags - Interrupt enabling/disabling at in-core intc
    
    ARC700 has an in-core intc which provides 2 priorities (a.k.a.) "levels"
    of interrupts (per IRQ) hencforth referred to as L1/L2 interrupts.
    
    CPU flags register STATUS32 has Interrupt Enable bits per level (E1/E2)
    to globally enable (or disable) all IRQs at a level. Hence the
    implementation of arch_local_irq_{save,restore,enable,disable}( )
    
    The STATUS32 reg can be r/w only using the AUX Interface of ARC, hence
    the use of LR/SR instructions. Further, E1/E2 bits in there can only be
    updated using the FLAG insn.
    
    The intc supports 32 interrupts - and per IRQ enabling is controlled by
    a bit in the AUX_IENABLE register, hence the implmentation of
    arch_{,un}mask_irq( ) routines.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/arc/kernel/irq.c b/arch/arc/kernel/irq.c
new file mode 100644
index 000000000000..c4e9b25d305f
--- /dev/null
+++ b/arch/arc/kernel/irq.c
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2011-12 Synopsys, Inc. (www.synopsys.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ */
+
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <asm/irqflags.h>
+#include <asm/arcregs.h>
+
+void arch_local_irq_enable(void)
+{
+	unsigned long flags;
+
+	/*
+	 * ARC IDE Drivers tries to re-enable interrupts from hard-isr
+	 * context which is simply wrong
+	 */
+	if (in_irq()) {
+		WARN_ONCE(1, "IRQ enabled from hard-isr");
+		return;
+	}
+
+	flags = arch_local_save_flags();
+	flags |= (STATUS_E1_MASK | STATUS_E2_MASK);
+	arch_local_irq_restore(flags);
+}
+EXPORT_SYMBOL(arch_local_irq_enable);
