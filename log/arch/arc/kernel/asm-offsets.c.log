commit 7321e2ea0d6aece516a9c0827028ecda2ccaeae9
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Thu Mar 5 23:02:51 2020 +0300

    ARC: add support for DSP-enabled userspace applications
    
    To be able to run DSP-enabled userspace applications we need to
    save and restore following DSP-related registers:
    At IRQ/exception entry/exit:
     * DSP_CTRL (save it and reset to value suitable for kernel)
     * ACC0_LO, ACC0_HI (we already save them as r58, r59 pair)
    At context switch:
     * ACC0_GLO, ACC0_GHI
     * DSP_BFLY0, DSP_FFT_CTRL
    
    Reviewed-by: Vineet Gupta <vgupta@synopsys.com>
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index c783bcd35eb8..0e884036ab74 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -12,6 +12,7 @@
 #include <asm/hardirq.h>
 #include <asm/page.h>
 
+
 int main(void)
 {
 	DEFINE(TASK_THREAD, offsetof(struct task_struct, thread));
@@ -75,6 +76,9 @@ int main(void)
 	OFFSET(PT_r58, pt_regs, r58);
 	OFFSET(PT_r59, pt_regs, r59);
 #endif
+#ifdef CONFIG_ARC_DSP_SAVE_RESTORE_REGS
+	OFFSET(PT_DSP_CTRL, pt_regs, DSP_CTRL);
+#endif
 
 	return 0;
 }

commit 7ecc6c1d5c8dbc713c647512a5267ca0eafe3e1c
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Fri Dec 27 21:03:43 2019 +0300

    ARC: pt_regs: remove hardcoded registers offset
    
    Replace hardcoded registers offset numbers by calculated via
    offsetof.
    
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index 631ebb5d3458..c783bcd35eb8 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -67,5 +67,14 @@ int main(void)
 	DEFINE(SZ_CALLEE_REGS, sizeof(struct callee_regs));
 	DEFINE(SZ_PT_REGS, sizeof(struct pt_regs));
 
+#ifdef CONFIG_ISA_ARCV2
+	OFFSET(PT_r12, pt_regs, r12);
+	OFFSET(PT_r30, pt_regs, r30);
+#endif
+#ifdef CONFIG_ARC_HAS_ACCL_REGS
+	OFFSET(PT_r58, pt_regs, r58);
+	OFFSET(PT_r59, pt_regs, r59);
+#endif
+
 	return 0;
 }

commit 833a20b8d4924b63ef7700e43fe4941963002822
Author: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
Date:   Thu Dec 19 16:30:40 2019 +0300

    ARC: asm-offsets: remove duplicate entry
    
    We define 'PT_user_r25' twice in asm-offsets.c
    It's not a big issue as we define it to the same value, however
    let's fix it.
    
    Signed-off-by: Eugeniy Paltsev <Eugeniy.Paltsev@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index 1f621e416521..631ebb5d3458 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -66,7 +66,6 @@ int main(void)
 
 	DEFINE(SZ_CALLEE_REGS, sizeof(struct callee_regs));
 	DEFINE(SZ_PT_REGS, sizeof(struct pt_regs));
-	DEFINE(PT_user_r25, offsetof(struct pt_regs, user_r25));
 
 	return 0;
 }

commit a4880801a72ecc2dcdfa432f81a754f3e7438567
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Wed May 15 15:36:46 2019 -0700

    ARCv2: entry: rewrite to enable use of double load/stores LDD/STD
    
     - the motivation was to be remove blatent copy-paste due to hasty support
       of CONFIG_ARC_IRQ_NO_AUTOSAVE support
    
     - but with refactoring we could use LDD/STD to greatly optimize the code
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index dba116535005..1f621e416521 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -55,7 +55,14 @@ int main(void)
 	DEFINE(PT_r5, offsetof(struct pt_regs, r5));
 	DEFINE(PT_r6, offsetof(struct pt_regs, r6));
 	DEFINE(PT_r7, offsetof(struct pt_regs, r7));
+	DEFINE(PT_r8, offsetof(struct pt_regs, r8));
+	DEFINE(PT_r10, offsetof(struct pt_regs, r10));
+	DEFINE(PT_r26, offsetof(struct pt_regs, r26));
 	DEFINE(PT_ret, offsetof(struct pt_regs, ret));
+	DEFINE(PT_blink, offsetof(struct pt_regs, blink));
+	DEFINE(PT_lpe, offsetof(struct pt_regs, lp_end));
+	DEFINE(PT_lpc, offsetof(struct pt_regs, lp_count));
+	DEFINE(PT_user_r25, offsetof(struct pt_regs, user_r25));
 
 	DEFINE(SZ_CALLEE_REGS, sizeof(struct callee_regs));
 	DEFINE(SZ_PT_REGS, sizeof(struct pt_regs));

commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index ecaf34e9235c..dba116535005 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -1,9 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
  */
 
 #include <linux/sched.h>

commit 2924cd18c434c79ee777dc63616a8505045d7509
Author: Ruud Derwig <rderwig@synopsys.com>
Date:   Wed Dec 3 15:52:41 2014 +0100

    ARCv2: [vdk] dts files and defconfig for HS38 VDK
    
     - CONFIG_ARC_UBOOT_SUPPORT to handle arguments passed in r0, r1, r2
     - CONFIG_DEVTMPFS_MOUNT for mouting rootfs since it uses external cpio
       for rootfs
    
    Cc: Grant Likely <grant.likely@linaro.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: devicetree@vger.kernel.org
    Signed-off-by: Ruud Derwig <rderwig@synopsys.com>
    [vgupta: folded the Main baord DT files for smp/up into one]
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index 605281f5b301..ecaf34e9235c 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -37,6 +37,8 @@ int main(void)
 
 	DEFINE(TASK_ACT_MM, offsetof(struct task_struct, active_mm));
 	DEFINE(TASK_TGID, offsetof(struct task_struct, tgid));
+	DEFINE(TASK_PID, offsetof(struct task_struct, pid));
+	DEFINE(TASK_COMM, offsetof(struct task_struct, comm));
 
 	DEFINE(MM_CTXT, offsetof(struct mm_struct, context));
 	DEFINE(MM_PGD, offsetof(struct mm_struct, pgd));

commit 0d7b8855a05c099a5c65a8d49a1e604198021f56
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue Oct 7 14:12:13 2014 +0530

    ARCv2: STAR 9000808988: signals involving Delay Slot
    
    Reported by Anton as LTP:munmap01 failing with Illegal Instruction
    Exception.
    
       --------------------->8--------------------------------------
       mmap2(NULL, 24576, PROT_READ|PROT_WRITE, MAP_SHARED, 3, 0) = 0x200d2000
       munmap(0x200d2000, 24576)               = 0
       --- SIGSEGV {si_signo=SIGSEGV, si_code=SEGV_MAPERR, si_addr=0x200d2000}
       ---
       potentially unexpected fatal signal 4.
       Path: /munmap01
       CPU: 0 PID: 61 Comm: munmap01 Not tainted 3.13.0-g5d5c46d9a556 #8
       task: 9f1a8000 ti: 9f154000 task.ti: 9f154000
    
       [ECR   ]: 0x00020100 => Illegal Insn
       [EFA   ]: 0x0001354c
       [BLINK ]: 0x200515d4
       [ERET  ]: 0x1354c
           @off 0x1354c in [/munmap01]
           VMA: 0x00010000 to 0x00018000
       [STAT32]: 0x800802c0
       ...
       --------------------->8--------------------------------------
    
    The issue was
    1. munmap01 accessed unmapped memory (on purpose) with signal handler
       installed for SIGSEGV
    
    2. The faulting instruction happened to be in Delay Slot
       00011864 <main>:
          11908:    bl.d       13284 <tst_resm>
          1190c:    stb        r16,[r2]
    
    3. kernel sets up the reg file for signal handler and correctly clears
       the DE bit in pt_regs->status32 placeholder
    
    4. However RESTORE_CALLEE_SAVED_USER macro is not adjusted for ARCv2,
       and it over-writes the above with orig/stale value of status32
    
    5. After RTIE, userspace signal handler executes a non branch
       instruction with DE bit set, triggering Illegal Instruction Exception.
    
    Reported-by: Anton Kolesov <akolesov@synopsys.com>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index b9cf23313273..605281f5b301 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -60,5 +60,7 @@ int main(void)
 
 	DEFINE(SZ_CALLEE_REGS, sizeof(struct callee_regs));
 	DEFINE(SZ_PT_REGS, sizeof(struct pt_regs));
+	DEFINE(PT_user_r25, offsetof(struct pt_regs, user_r25));
+
 	return 0;
 }

commit 4255b07f2c9c43540149ed823faf5ac8476cccee
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon Sep 22 16:51:47 2014 +0530

    ARCv2: STAR 9000793984: Handle return from intr to Delay Slot
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index 6c3aa0edb9b5..b9cf23313273 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -56,6 +56,7 @@ int main(void)
 	DEFINE(PT_r5, offsetof(struct pt_regs, r5));
 	DEFINE(PT_r6, offsetof(struct pt_regs, r6));
 	DEFINE(PT_r7, offsetof(struct pt_regs, r7));
+	DEFINE(PT_ret, offsetof(struct pt_regs, ret));
 
 	DEFINE(SZ_CALLEE_REGS, sizeof(struct callee_regs));
 	DEFINE(SZ_PT_REGS, sizeof(struct pt_regs));

commit 502a0c775c7f0a01065e0d078e06c0440b86a11a
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue Jun 11 18:56:54 2013 +0530

    ARC: pt_regs update #5: Use real ECR for pt_regs->event vs. synth values
    
    pt_regs->event was set with artificial values to identify the low level
    system event (syscall trap / breakpoint trap / exceptions / interrupts)
    
    With r8 saving out of the way, the full word can be used to save real
    ECR (Exception Cause Register) which helps idenify the event naturally,
    including additional info such as cause code, param.
    Only for Interrupts, where ECR is not applicable, do we resort to
    synthetic non ECR values.
    
    SAVE_ALL_TRAP/EXCEPTIONS can now be merged as they both use ECR with
    different runtime values.
    
    The ptrace helpers now use the sub-fields of ECR to distinguish the
    events (e.g. vector 0x25 is trap, param 0 is syscall...)
    
    The following benefits will follow:
    
    (1) This centralizes the location of where ECR is saved and will allow
        the cleanup of task->thread.cause_code ECR placeholder which is set
        in non-uniform way. Then ARC VM code can safely rely on it being
        there for purpose of finer grained VM_EXEC dcache flush (based on
        exec fault: I-TLB Miss)
    
    (2) Further, ECR being passed around from low level handlers as arg can
        be eliminated as it is part of standard reg-file in pt_regs
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index 75f05b83d77d..6c3aa0edb9b5 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -46,7 +46,7 @@ int main(void)
 	BLANK();
 
 	DEFINE(PT_status32, offsetof(struct pt_regs, status32));
-	DEFINE(PT_orig_r8, offsetof(struct pt_regs, orig_r8_word));
+	DEFINE(PT_event, offsetof(struct pt_regs, event));
 	DEFINE(PT_sp, offsetof(struct pt_regs, sp));
 	DEFINE(PT_r0, offsetof(struct pt_regs, r0));
 	DEFINE(PT_r1, offsetof(struct pt_regs, r1));

commit 359105bdb06f8421fd8e69ae47fd052e398b6778
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Tue May 28 13:50:41 2013 +0530

    ARC: pt_regs update #4: r25 saved/restored unconditionally
    
    (This is a VERY IMP change for low level interrupt/exception handling)
    
    -----------------------------------------------------------------------
    WHAT
    -----------------------------------------------------------------------
    * User 25 now saved in pt_regs->user_r25 (vs. tsk->thread_info.user_r25)
    
    * This allows Low level interrupt code to unconditionally save r25
      (vs. the prev version which would only do it for U->K transition).
      Ofcourse for nested interrupts, only the pt_regs->user_r25 of
      bottom-most frame is useful.
    
    * simplifies the interrupt prologue/epilogue
    
    * Needed for ARCv2 ISA code and done here to keep design similar with
      ARCompact event handling
    
    -----------------------------------------------------------------------
    WHY
    -------------------------------------------------------------------------
    With CONFIG_ARC_CURR_IN_REG, r25 is used to cache "current" task pointer
    in kernel mode. So when entering kernel mode from User Mode
    - user r25 is specially safe-kept (it being a callee reg is NOT part of
      pt_regs which are saved by default on each interrupt/trap/exception)
    - r25 loaded with current task pointer.
    
    Further, if interrupt was taken in kernel mode, this is skipped since we
    know that r25 already has valid "current" pointer.
    
    With 2 level of interrupts in ARCompact ISA, detecting this is difficult
    but still possible, since we could be in kernel mode but r25 not already saved
    (in fact the stack itself might not have been switched).
    
    A. User mode
    B. L1 IRQ taken
    C. L2 IRQ taken (while on 1st line of L1 ISR)
    
    So in #C, although in kernel mode, r25 not saved (infact SP not
    switched at all)
    
    Given that ARcompact has manual stack switching, we could use a bit of
    trickey - The low level code would make sure that SP is only set to kernel
    mode value at the very end (after saving r25). So a non kernel mode SP,
    even if in kernel mode, meant r25 was NOT saved.
    
    The same paradigm won't work in ARCv2 ISA since SP is auto-switched so
    it's setting can't be delayed/constrained.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index fdcd76532b70..75f05b83d77d 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -24,9 +24,6 @@ int main(void)
 
 	DEFINE(THREAD_KSP, offsetof(struct thread_struct, ksp));
 	DEFINE(THREAD_CALLEE_REG, offsetof(struct thread_struct, callee_reg));
-#ifdef CONFIG_ARC_CURR_IN_REG
-	DEFINE(THREAD_USER_R25, offsetof(struct thread_struct, user_r25));
-#endif
 	DEFINE(THREAD_FAULT_ADDR,
 	       offsetof(struct thread_struct, fault_address));
 
@@ -61,5 +58,6 @@ int main(void)
 	DEFINE(PT_r7, offsetof(struct pt_regs, r7));
 
 	DEFINE(SZ_CALLEE_REGS, sizeof(struct callee_regs));
+	DEFINE(SZ_PT_REGS, sizeof(struct pt_regs));
 	return 0;
 }

commit 16f9afe651e8197fb7ce6df0990d8e2ad779e1af
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon May 27 21:43:41 2013 +0530

    ARC: pt_regs update #3: Remove unused gutter at start of callee_regs
    
    This is trickier than prev two:
    
    * context switching code saves kernel mode callee regs in the format of
      struct callee_regs thus needs adjustment. This also reduces the height
      of topmost kernel stack frame by 1 word.
    
    * Since kernel stack unwinder is sensitive to height of topmost kernel
      stack frame, that needs a word of adjustment too.
    
    ptrace needs a bit of updating since pt_regs now diverges from
    user_regs_struct.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index 7dcda7025241..fdcd76532b70 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -60,5 +60,6 @@ int main(void)
 	DEFINE(PT_r6, offsetof(struct pt_regs, r6));
 	DEFINE(PT_r7, offsetof(struct pt_regs, r7));
 
+	DEFINE(SZ_CALLEE_REGS, sizeof(struct callee_regs));
 	return 0;
 }

commit 1ec9db1056b0c4b8b9dfca4736634c7c8e0833d5
Author: Sachin Kamat <sachin.kamat@linaro.org>
Date:   Wed Mar 6 16:53:44 2013 +0530

    ARC: Use <linux/*> headers instead of <asm/*>
    
    Silences the following checkpatch warnings:
    WARNING: Use #include <linux/ptrace.h> instead of <asm/ptrace.h>
    WARNING: Use #include <linux/kprobes.h> instead of <asm/kprobes.h>
    WARNING: Use #include <linux/kgdb.h> instead of <asm/kgdb.h>
    WARNING: Use #include <linux/uaccess.h> instead of <asm/uaccess.h>
    WARNING: Use #include <linux/cache.h> instead of <asm/cache.h>
    
    Signed-off-by: Sachin Kamat <sachin.kamat@linaro.org>
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index 0dc148ebce74..7dcda7025241 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -11,9 +11,9 @@
 #include <linux/interrupt.h>
 #include <linux/thread_info.h>
 #include <linux/kbuild.h>
+#include <linux/ptrace.h>
 #include <asm/hardirq.h>
 #include <asm/page.h>
-#include <asm/ptrace.h>
 
 int main(void)
 {

commit 080c37473eb671a037b3e9a315303851f0675be5
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon Feb 11 19:52:57 2013 +0530

    ARC: [optim] Cache "current" in Register r25
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index d7770cc9aee3..0dc148ebce74 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -24,6 +24,9 @@ int main(void)
 
 	DEFINE(THREAD_KSP, offsetof(struct thread_struct, ksp));
 	DEFINE(THREAD_CALLEE_REG, offsetof(struct thread_struct, callee_reg));
+#ifdef CONFIG_ARC_CURR_IN_REG
+	DEFINE(THREAD_USER_R25, offsetof(struct thread_struct, user_r25));
+#endif
 	DEFINE(THREAD_FAULT_ADDR,
 	       offsetof(struct thread_struct, fault_address));
 

commit 5c39c0ab5e862cf71cda1fc39a5cedd4e2f18c6e
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Mon Feb 11 20:01:24 2013 +0530

    ARC: [Review] Preparing to fix incorrect syscall restarts due to signals
    
    To avoid multiple syscall restarts (multiple signals) or no restart at
    all (sigreturn), we need just an extra bit of state "literally 1 bit" in
    struct pt_regs. orig_r8 is the best place to do this, however given the
    way it is encoded currently, we can't add anything simplistically.
    
    Current orig_r8:
    * syscalls   -> 1 to NR_SYSCALLS
    * Exceptions -> NR_SYSCALLS + 1
    * Break-point-> NR_SYSCALLS + 2
    
    In new scheme it is a bit-field
    * lower short word contains the  exact event type (and a new bit to represent
       restart semantics : if syscall was already / can't be restarted)
    * upper short word optionally containing the syscall num - needed by
      likes of tracehooks etc
    
    This patch only changes how orig_r8 is organised and nothing should
    change behaviourily.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Al Viro <viro@ZenIV.linux.org.uk>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
index 64b2c2fa7b54..d7770cc9aee3 100644
--- a/arch/arc/kernel/asm-offsets.c
+++ b/arch/arc/kernel/asm-offsets.c
@@ -46,7 +46,7 @@ int main(void)
 	BLANK();
 
 	DEFINE(PT_status32, offsetof(struct pt_regs, status32));
-	DEFINE(PT_orig_r8, offsetof(struct pt_regs, orig_r8));
+	DEFINE(PT_orig_r8, offsetof(struct pt_regs, orig_r8_word));
 	DEFINE(PT_sp, offsetof(struct pt_regs, sp));
 	DEFINE(PT_r0, offsetof(struct pt_regs, r0));
 	DEFINE(PT_r1, offsetof(struct pt_regs, r1));

commit cfdbc2e16e65c1ec1c23057640607cee98d1a1bd
Author: Vineet Gupta <vgupta@synopsys.com>
Date:   Fri Jan 18 15:12:20 2013 +0530

    ARC: Build system: Makefiles, Kconfig, Linker script
    
    Arnd in his review pointed out that arch Kconfig organisation has several
    deficiencies:
    
    * Build time entries for things which can be runtime extracted from DT
      (e.g. SDRAM size, core clk frequency..)
    * Not multi-platform-image-build friendly (choice .. endchoice constructs)
    * cpu variants support (750/770) is exclusive.
    
    The first 2 have been fixed in subsequent patches.
    Due to the nature of the 750 and 770, it is not possible to build for
    both together, w/o special runtime glue code which would hurt
    performance.
    
    Signed-off-by: Vineet Gupta <vgupta@synopsys.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Acked-by: Sam Ravnborg <sam@ravnborg.org>

diff --git a/arch/arc/kernel/asm-offsets.c b/arch/arc/kernel/asm-offsets.c
new file mode 100644
index 000000000000..64b2c2fa7b54
--- /dev/null
+++ b/arch/arc/kernel/asm-offsets.c
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2004, 2007-2010, 2011-2012 Synopsys, Inc. (www.synopsys.com)
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/sched.h>
+#include <linux/mm.h>
+#include <linux/interrupt.h>
+#include <linux/thread_info.h>
+#include <linux/kbuild.h>
+#include <asm/hardirq.h>
+#include <asm/page.h>
+#include <asm/ptrace.h>
+
+int main(void)
+{
+	DEFINE(TASK_THREAD, offsetof(struct task_struct, thread));
+	DEFINE(TASK_THREAD_INFO, offsetof(struct task_struct, stack));
+
+	BLANK();
+
+	DEFINE(THREAD_KSP, offsetof(struct thread_struct, ksp));
+	DEFINE(THREAD_CALLEE_REG, offsetof(struct thread_struct, callee_reg));
+	DEFINE(THREAD_FAULT_ADDR,
+	       offsetof(struct thread_struct, fault_address));
+
+	BLANK();
+
+	DEFINE(THREAD_INFO_FLAGS, offsetof(struct thread_info, flags));
+	DEFINE(THREAD_INFO_PREEMPT_COUNT,
+	       offsetof(struct thread_info, preempt_count));
+
+	BLANK();
+
+	DEFINE(TASK_ACT_MM, offsetof(struct task_struct, active_mm));
+	DEFINE(TASK_TGID, offsetof(struct task_struct, tgid));
+
+	DEFINE(MM_CTXT, offsetof(struct mm_struct, context));
+	DEFINE(MM_PGD, offsetof(struct mm_struct, pgd));
+
+	DEFINE(MM_CTXT_ASID, offsetof(mm_context_t, asid));
+
+	BLANK();
+
+	DEFINE(PT_status32, offsetof(struct pt_regs, status32));
+	DEFINE(PT_orig_r8, offsetof(struct pt_regs, orig_r8));
+	DEFINE(PT_sp, offsetof(struct pt_regs, sp));
+	DEFINE(PT_r0, offsetof(struct pt_regs, r0));
+	DEFINE(PT_r1, offsetof(struct pt_regs, r1));
+	DEFINE(PT_r2, offsetof(struct pt_regs, r2));
+	DEFINE(PT_r3, offsetof(struct pt_regs, r3));
+	DEFINE(PT_r4, offsetof(struct pt_regs, r4));
+	DEFINE(PT_r5, offsetof(struct pt_regs, r5));
+	DEFINE(PT_r6, offsetof(struct pt_regs, r6));
+	DEFINE(PT_r7, offsetof(struct pt_regs, r7));
+
+	return 0;
+}
