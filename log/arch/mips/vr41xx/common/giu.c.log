commit 16216333235adf51093d0330a934a7e4a03134fe
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 15:51:31 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 1
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      51 franklin street fifth floor boston ma 02110 1301 usa
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option [no]_[pad]_[ctrl] any later version this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 51 franklin street fifth floor boston ma
      02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 176 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Jilayne Lovejoy <opensource@jilayne.com>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190519154040.652910950@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/vr41xx/common/giu.c b/arch/mips/vr41xx/common/giu.c
index 32cc8d66b34e..398c626411f8 100644
--- a/arch/mips/vr41xx/common/giu.c
+++ b/arch/mips/vr41xx/common/giu.c
@@ -1,21 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  NEC VR4100 series GIU platform device.
  *
  *  Copyright (C) 2007	Yoichi Yuasa <yuasa@linux-mips.org>
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
  */
 #include <linux/errno.h>
 #include <linux/init.h>

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/vr41xx/common/giu.c b/arch/mips/vr41xx/common/giu.c
index b32b3bc60441..32cc8d66b34e 100644
--- a/arch/mips/vr41xx/common/giu.c
+++ b/arch/mips/vr41xx/common/giu.c
@@ -1,7 +1,7 @@
 /*
  *  NEC VR4100 series GIU platform device.
  *
- *  Copyright (C) 2007  Yoichi Yuasa <yuasa@linux-mips.org>
+ *  Copyright (C) 2007	Yoichi Yuasa <yuasa@linux-mips.org>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by

commit c72f4d6141b3fd2c01f58989cdb0d6b656512647
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Jul 28 19:39:02 2011 -0400

    mips: fix implicit smp.h usage in various files.
    
    We need to call out inclusion of smp.h, or with the module.h cleanup
    we'll get things like:
    
    arch/mips/loongson/common/platform.c:21: error: implicit declaration of function 'smp_processor_id'
    
    arch/mips/vr41xx/common/giu.c:84: error: implicit declaration of function 'smp_processor_id'
    
    arch/mips/vr41xx/common/rtc.c:85: error: implicit declaration of function 'smp_processor_id'
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/mips/vr41xx/common/giu.c b/arch/mips/vr41xx/common/giu.c
index 22cc6f2100a1..b32b3bc60441 100644
--- a/arch/mips/vr41xx/common/giu.c
+++ b/arch/mips/vr41xx/common/giu.c
@@ -19,6 +19,7 @@
  */
 #include <linux/errno.h>
 #include <linux/init.h>
+#include <linux/smp.h>
 #include <linux/ioport.h>
 #include <linux/platform_device.h>
 

commit ada8e9514b5880f81cdbbd212d121380ceef7acc
Author: Yoichi Yuasa <yuasa@linux-mips.org>
Date:   Fri Jul 3 00:39:38 2009 +0900

    Update Yoichi Yuasa's e-mail address
    
    Signed-off-by: Yoichi Yuasa <yuasa@linux-mips.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/vr41xx/common/giu.c b/arch/mips/vr41xx/common/giu.c
index 2b272f1496fe..22cc6f2100a1 100644
--- a/arch/mips/vr41xx/common/giu.c
+++ b/arch/mips/vr41xx/common/giu.c
@@ -1,7 +1,7 @@
 /*
  *  NEC VR4100 series GIU platform device.
  *
- *  Copyright (C) 2007  Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
+ *  Copyright (C) 2007  Yoichi Yuasa <yuasa@linux-mips.org>
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by

commit 10cc3529072d5415fb040018a8a99aa7a60190b6
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:15 2007 +0100

    [MIPS] Allow hardwiring of the CPU type to a single type for optimization.
    
    This saves a few k on systems which only ever ship with a single CPU type.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/vr41xx/common/giu.c b/arch/mips/vr41xx/common/giu.c
index d21f6f2d22a3..2b272f1496fe 100644
--- a/arch/mips/vr41xx/common/giu.c
+++ b/arch/mips/vr41xx/common/giu.c
@@ -81,7 +81,7 @@ static int __init vr41xx_giu_add(void)
 	if (!pdev)
 		return -ENOMEM;
 
-	switch (current_cpu_data.cputype) {
+	switch (current_cpu_type()) {
 	case CPU_VR4111:
 	case CPU_VR4121:
 		pdev->id = GPIO_50PINS_PULLUPDOWN;

commit 44173fb2e83183b585e137e6fee8ba32460f5645
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Thu May 10 22:21:35 2007 +0900

    [MIPS] Separate platform_device registration for VR41xx GPIO
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/vr41xx/common/giu.c b/arch/mips/vr41xx/common/giu.c
new file mode 100644
index 000000000000..d21f6f2d22a3
--- /dev/null
+++ b/arch/mips/vr41xx/common/giu.c
@@ -0,0 +1,122 @@
+/*
+ *  NEC VR4100 series GIU platform device.
+ *
+ *  Copyright (C) 2007  Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+
+#include <asm/cpu.h>
+#include <asm/vr41xx/giu.h>
+#include <asm/vr41xx/irq.h>
+
+static struct resource giu_50pins_pullupdown_resource[] __initdata = {
+	{
+		.start	= 0x0b000100,
+		.end	= 0x0b00011f,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= 0x0b0002e0,
+		.end	= 0x0b0002e3,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= GIUINT_IRQ,
+		.end	= GIUINT_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource giu_36pins_resource[] __initdata = {
+	{
+		.start	= 0x0f000140,
+		.end	= 0x0f00015f,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= GIUINT_IRQ,
+		.end	= GIUINT_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static struct resource giu_48pins_resource[] __initdata = {
+	{
+		.start	= 0x0f000140,
+		.end	= 0x0f000167,
+		.flags	= IORESOURCE_MEM,
+	},
+	{
+		.start	= GIUINT_IRQ,
+		.end	= GIUINT_IRQ,
+		.flags	= IORESOURCE_IRQ,
+	},
+};
+
+static int __init vr41xx_giu_add(void)
+{
+	struct platform_device *pdev;
+	struct resource *res;
+	unsigned int num;
+	int retval;
+
+	pdev = platform_device_alloc("GIU", -1);
+	if (!pdev)
+		return -ENOMEM;
+
+	switch (current_cpu_data.cputype) {
+	case CPU_VR4111:
+	case CPU_VR4121:
+		pdev->id = GPIO_50PINS_PULLUPDOWN;
+		res = giu_50pins_pullupdown_resource;
+		num = ARRAY_SIZE(giu_50pins_pullupdown_resource);
+		break;
+	case CPU_VR4122:
+	case CPU_VR4131:
+		pdev->id = GPIO_36PINS;
+		res = giu_36pins_resource;
+		num = ARRAY_SIZE(giu_36pins_resource);
+		break;
+	case CPU_VR4133:
+		pdev->id = GPIO_48PINS_EDGE_SELECT;
+		res = giu_48pins_resource;
+		num = ARRAY_SIZE(giu_48pins_resource);
+		break;
+	default:
+		retval = -ENODEV;
+		goto err_free_device;
+	}
+
+	retval = platform_device_add_resources(pdev, res, num);
+	if (retval)
+		goto err_free_device;
+
+	retval = platform_device_add(pdev);
+	if (retval)
+		goto err_free_device;
+
+	return 0;
+
+err_free_device:
+	platform_device_put(pdev);
+
+	return retval;
+}
+device_initcall(vr41xx_giu_add);

commit f2d5c74d778fc59a46f8e173cf986e7320e15e50
Author: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
Date:   Wed Jul 27 11:44:22 2005 -0700

    [PATCH] mips: remove obsolete GIU driver for vr41xx
    
    This patch has removed obsolete GIU driver for vr41xx.  This patch already
    has been applied to mips tree.
    
    Signed-off-by: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/vr41xx/common/giu.c b/arch/mips/vr41xx/common/giu.c
deleted file mode 100644
index 9c6b21a79e8f..000000000000
--- a/arch/mips/vr41xx/common/giu.c
+++ /dev/null
@@ -1,455 +0,0 @@
-/*
- *  giu.c, General-purpose I/O Unit Interrupt routines for NEC VR4100 series.
- *
- *  Copyright (C) 2002 MontaVista Software Inc.
- *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
- *  Copyright (C) 2003-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- *  Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- */
-/*
- * Changes:
- *  MontaVista Software Inc. <yyuasa@mvista.com> or <source@mvista.com>
- *  - New creation, NEC VR4111, VR4121, VR4122 and VR4131 are supported.
- *
- *  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- *  - Added support for NEC VR4133.
- *  - Removed board_irq_init.
- */
-#include <linux/errno.h>
-#include <linux/init.h>
-#include <linux/irq.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/smp.h>
-#include <linux/types.h>
-
-#include <asm/cpu.h>
-#include <asm/io.h>
-#include <asm/vr41xx/vr41xx.h>
-
-#define GIUIOSELL_TYPE1	KSEG1ADDR(0x0b000100)
-#define GIUIOSELL_TYPE2	KSEG1ADDR(0x0f000140)
-
-#define GIUIOSELL	0x00
-#define GIUIOSELH	0x02
-#define GIUINTSTATL	0x08
-#define GIUINTSTATH	0x0a
-#define GIUINTENL	0x0c
-#define GIUINTENH	0x0e
-#define GIUINTTYPL	0x10
-#define GIUINTTYPH	0x12
-#define GIUINTALSELL	0x14
-#define GIUINTALSELH	0x16
-#define GIUINTHTSELL	0x18
-#define GIUINTHTSELH	0x1a
-#define GIUFEDGEINHL	0x20
-#define GIUFEDGEINHH	0x22
-#define GIUREDGEINHL	0x24
-#define GIUREDGEINHH	0x26
-
-static uint32_t giu_base;
-
-static struct irqaction giu_cascade = {
-	.handler	= no_action,
-	.mask		= CPU_MASK_NONE,
-	.name		= "cascade",
-};
-
-#define read_giuint(offset)		readw(giu_base + (offset))
-#define write_giuint(val, offset)	writew((val), giu_base + (offset))
-
-#define GIUINT_HIGH_OFFSET	16
-
-static inline uint16_t set_giuint(uint8_t offset, uint16_t set)
-{
-	uint16_t res;
-
-	res = read_giuint(offset);
-	res |= set;
-	write_giuint(res, offset);
-
-	return res;
-}
-
-static inline uint16_t clear_giuint(uint8_t offset, uint16_t clear)
-{
-	uint16_t res;
-
-	res = read_giuint(offset);
-	res &= ~clear;
-	write_giuint(res, offset);
-
-	return res;
-}
-
-static unsigned int startup_giuint_low_irq(unsigned int irq)
-{
-	unsigned int pin;
-
-	pin = GIU_IRQ_TO_PIN(irq);
-	write_giuint((uint16_t)1 << pin, GIUINTSTATL);
-	set_giuint(GIUINTENL, (uint16_t)1 << pin);
-
-	return 0;
-}
-
-static void shutdown_giuint_low_irq(unsigned int irq)
-{
-	clear_giuint(GIUINTENL, (uint16_t)1 << GIU_IRQ_TO_PIN(irq));
-}
-
-static void enable_giuint_low_irq(unsigned int irq)
-{
-	set_giuint(GIUINTENL, (uint16_t)1 << GIU_IRQ_TO_PIN(irq));
-}
-
-#define disable_giuint_low_irq	shutdown_giuint_low_irq
-
-static void ack_giuint_low_irq(unsigned int irq)
-{
-	unsigned int pin;
-
-	pin = GIU_IRQ_TO_PIN(irq);
-	clear_giuint(GIUINTENL, (uint16_t)1 << pin);
-	write_giuint((uint16_t)1 << pin, GIUINTSTATL);
-}
-
-static void end_giuint_low_irq(unsigned int irq)
-{
-	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
-		set_giuint(GIUINTENL, (uint16_t)1 << GIU_IRQ_TO_PIN(irq));
-}
-
-static struct hw_interrupt_type giuint_low_irq_type = {
-	.typename	= "GIUINTL",
-	.startup	= startup_giuint_low_irq,
-	.shutdown	= shutdown_giuint_low_irq,
-	.enable		= enable_giuint_low_irq,
-	.disable	= disable_giuint_low_irq,
-	.ack		= ack_giuint_low_irq,
-	.end		= end_giuint_low_irq,
-};
-
-static unsigned int startup_giuint_high_irq(unsigned int irq)
-{
-	unsigned int pin;
-
-	pin = GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET);
-	write_giuint((uint16_t)1 << pin, GIUINTSTATH);
-	set_giuint(GIUINTENH, (uint16_t)1 << pin);
-
-	return 0;
-}
-
-static void shutdown_giuint_high_irq(unsigned int irq)
-{
-	clear_giuint(GIUINTENH, (uint16_t)1 << GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET));
-}
-
-static void enable_giuint_high_irq(unsigned int irq)
-{
-	set_giuint(GIUINTENH, (uint16_t)1 << GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET));
-}
-
-#define disable_giuint_high_irq	shutdown_giuint_high_irq
-
-static void ack_giuint_high_irq(unsigned int irq)
-{
-	unsigned int pin;
-
-	pin = GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET);
-	clear_giuint(GIUINTENH, (uint16_t)1 << pin);
-	write_giuint((uint16_t)1 << pin, GIUINTSTATH);
-}
-
-static void end_giuint_high_irq(unsigned int irq)
-{
-	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
-		set_giuint(GIUINTENH, (uint16_t)1 << GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET));
-}
-
-static struct hw_interrupt_type giuint_high_irq_type = {
-	.typename	= "GIUINTH",
-	.startup	= startup_giuint_high_irq,
-	.shutdown	= shutdown_giuint_high_irq,
-	.enable		= enable_giuint_high_irq,
-	.disable	= disable_giuint_high_irq,
-	.ack		= ack_giuint_high_irq,
-	.end		= end_giuint_high_irq,
-};
-
-void __init init_vr41xx_giuint_irq(void)
-{
-	int i;
-
-	for (i = GIU_IRQ_BASE; i <= GIU_IRQ_LAST; i++) {
-		if (i < (GIU_IRQ_BASE + GIUINT_HIGH_OFFSET))
-			irq_desc[i].handler = &giuint_low_irq_type;
-		else
-			irq_desc[i].handler = &giuint_high_irq_type;
-	}
-
-	setup_irq(GIUINT_CASCADE_IRQ, &giu_cascade);
-}
-
-void vr41xx_set_irq_trigger(int pin, int trigger, int hold)
-{
-	uint16_t mask;
-
-	if (pin < GIUINT_HIGH_OFFSET) {
-		mask = (uint16_t)1 << pin;
-		if (trigger != TRIGGER_LEVEL) {
-        		set_giuint(GIUINTTYPL, mask);
-			if (hold == SIGNAL_HOLD)
-				set_giuint(GIUINTHTSELL, mask);
-			else
-				clear_giuint(GIUINTHTSELL, mask);
-			if (current_cpu_data.cputype == CPU_VR4133) {
-				switch (trigger) {
-				case TRIGGER_EDGE_FALLING:
-					set_giuint(GIUFEDGEINHL, mask);
-					clear_giuint(GIUREDGEINHL, mask);
-					break;
-				case TRIGGER_EDGE_RISING:
-					clear_giuint(GIUFEDGEINHL, mask);
-					set_giuint(GIUREDGEINHL, mask);
-					break;
-				default:
-					set_giuint(GIUFEDGEINHL, mask);
-					set_giuint(GIUREDGEINHL, mask);
-					break;
-				}
-			}
-		} else {
-			clear_giuint(GIUINTTYPL, mask);
-			clear_giuint(GIUINTHTSELL, mask);
-		}
-		write_giuint(mask, GIUINTSTATL);
-	} else {
-		mask = (uint16_t)1 << (pin - GIUINT_HIGH_OFFSET);
-		if (trigger != TRIGGER_LEVEL) {
-			set_giuint(GIUINTTYPH, mask);
-			if (hold == SIGNAL_HOLD)
-				set_giuint(GIUINTHTSELH, mask);
-			else
-				clear_giuint(GIUINTHTSELH, mask);
-			if (current_cpu_data.cputype == CPU_VR4133) {
-				switch (trigger) {
-				case TRIGGER_EDGE_FALLING:
-					set_giuint(GIUFEDGEINHH, mask);
-					clear_giuint(GIUREDGEINHH, mask);
-					break;
-				case TRIGGER_EDGE_RISING:
-					clear_giuint(GIUFEDGEINHH, mask);
-					set_giuint(GIUREDGEINHH, mask);
-					break;
-				default:
-					set_giuint(GIUFEDGEINHH, mask);
-					set_giuint(GIUREDGEINHH, mask);
-					break;
-				}
-			}
-		} else {
-			clear_giuint(GIUINTTYPH, mask);
-			clear_giuint(GIUINTHTSELH, mask);
-		}
-		write_giuint(mask, GIUINTSTATH);
-	}
-}
-
-EXPORT_SYMBOL(vr41xx_set_irq_trigger);
-
-void vr41xx_set_irq_level(int pin, int level)
-{
-	uint16_t mask;
-
-	if (pin < GIUINT_HIGH_OFFSET) {
-		mask = (uint16_t)1 << pin;
-		if (level == LEVEL_HIGH)
-			set_giuint(GIUINTALSELL, mask);
-		else
-			clear_giuint(GIUINTALSELL, mask);
-		write_giuint(mask, GIUINTSTATL);
-	} else {
-		mask = (uint16_t)1 << (pin - GIUINT_HIGH_OFFSET);
-		if (level == LEVEL_HIGH)
-			set_giuint(GIUINTALSELH, mask);
-		else
-			clear_giuint(GIUINTALSELH, mask);
-		write_giuint(mask, GIUINTSTATH);
-	}
-}
-
-EXPORT_SYMBOL(vr41xx_set_irq_level);
-
-#define GIUINT_NR_IRQS		32
-
-enum {
-	GIUINT_NO_CASCADE,
-	GIUINT_CASCADE
-};
-
-struct vr41xx_giuint_cascade {
-	unsigned int flag;
-	int (*get_irq_number)(int irq);
-};
-
-static struct vr41xx_giuint_cascade giuint_cascade[GIUINT_NR_IRQS];
-
-static int no_irq_number(int irq)
-{
-	return -EINVAL;
-}
-
-int vr41xx_cascade_irq(unsigned int irq, int (*get_irq_number)(int irq))
-{
-	unsigned int pin;
-	int retval;
-
-	if (irq < GIU_IRQ(0) || irq > GIU_IRQ(31))
-		return -EINVAL;
-
-	if(!get_irq_number)
-		return -EINVAL;
-
-	pin = GIU_IRQ_TO_PIN(irq);
-	giuint_cascade[pin].flag = GIUINT_CASCADE;
-	giuint_cascade[pin].get_irq_number = get_irq_number;
-
-	retval = setup_irq(irq, &giu_cascade);
-	if (retval != 0) {
-		giuint_cascade[pin].flag = GIUINT_NO_CASCADE;
-		giuint_cascade[pin].get_irq_number = no_irq_number;
-	}
-
-	return retval;
-}
-
-EXPORT_SYMBOL(vr41xx_cascade_irq);
-
-static inline int get_irq_pin_number(void)
-{
-	uint16_t pendl, pendh, maskl, maskh;
-	int i;
-
-	pendl = read_giuint(GIUINTSTATL);
-	pendh = read_giuint(GIUINTSTATH);
-	maskl = read_giuint(GIUINTENL);
-	maskh = read_giuint(GIUINTENH);
-
-	maskl &= pendl;
-	maskh &= pendh;
-
-	if (maskl) {
-		for (i = 0; i < 16; i++) {
-			if (maskl & ((uint16_t)1 << i))
-				return i;
-		}
-	} else if (maskh) {
-		for (i = 0; i < 16; i++) {
-			if (maskh & ((uint16_t)1 << i))
-				return i + GIUINT_HIGH_OFFSET;
-		}
-	}
-
-	printk(KERN_ERR "spurious GIU interrupt: %04x(%04x),%04x(%04x)\n",
-	       maskl, pendl, maskh, pendh);
-
-	atomic_inc(&irq_err_count);
-
-	return -1;
-}
-
-static inline void ack_giuint_irq(int pin)
-{
-	if (pin < GIUINT_HIGH_OFFSET) {
-		clear_giuint(GIUINTENL, (uint16_t)1 << pin);
-		write_giuint((uint16_t)1 << pin, GIUINTSTATL);
-	} else {
-		pin -= GIUINT_HIGH_OFFSET;
-		clear_giuint(GIUINTENH, (uint16_t)1 << pin);
-		write_giuint((uint16_t)1 << pin, GIUINTSTATH);
-	}
-}
-
-static inline void end_giuint_irq(int pin)
-{
-	if (pin < GIUINT_HIGH_OFFSET)
-		set_giuint(GIUINTENL, (uint16_t)1 << pin);
-	else
-		set_giuint(GIUINTENH, (uint16_t)1 << (pin - GIUINT_HIGH_OFFSET));
-}
-
-void giuint_irq_dispatch(struct pt_regs *regs)
-{
-	struct vr41xx_giuint_cascade *cascade;
-	unsigned int giuint_irq;
-	int pin;
-
-	pin = get_irq_pin_number();
-	if (pin < 0)
-		return;
-
-	disable_irq(GIUINT_CASCADE_IRQ);
-
-	cascade = &giuint_cascade[pin];
-	giuint_irq = GIU_IRQ(pin);
-	if (cascade->flag == GIUINT_CASCADE) {
-		int irq = cascade->get_irq_number(giuint_irq);
-		ack_giuint_irq(pin);
-		if (irq >= 0)
-			do_IRQ(irq, regs);
-		end_giuint_irq(pin);
-	} else {
-		do_IRQ(giuint_irq, regs);
-	}
-
-	enable_irq(GIUINT_CASCADE_IRQ);
-}
-
-static int __init vr41xx_giu_init(void)
-{
-	int i;
-
-	switch (current_cpu_data.cputype) {
-	case CPU_VR4111:
-	case CPU_VR4121:
-		giu_base = GIUIOSELL_TYPE1;
-		break;
-	case CPU_VR4122:
-	case CPU_VR4131:
-	case CPU_VR4133:
-		giu_base = GIUIOSELL_TYPE2;
-		break;
-	default:
-		printk(KERN_ERR "GIU: Unexpected CPU of NEC VR4100 series\n");
-		return -EINVAL;
-	}
-
-	for (i = 0; i < GIUINT_NR_IRQS; i++) {
-		if (i < GIUINT_HIGH_OFFSET)
-			clear_giuint(GIUINTENL, (uint16_t)1 << i);
-		else
-			clear_giuint(GIUINTENH, (uint16_t)1 << (i - GIUINT_HIGH_OFFSET));
-		giuint_cascade[i].flag = GIUINT_NO_CASCADE;
-		giuint_cascade[i].get_irq_number = no_irq_number;
-	}
-
-	return 0;
-}
-
-early_initcall(vr41xx_giu_init);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/vr41xx/common/giu.c b/arch/mips/vr41xx/common/giu.c
new file mode 100644
index 000000000000..9c6b21a79e8f
--- /dev/null
+++ b/arch/mips/vr41xx/common/giu.c
@@ -0,0 +1,455 @@
+/*
+ *  giu.c, General-purpose I/O Unit Interrupt routines for NEC VR4100 series.
+ *
+ *  Copyright (C) 2002 MontaVista Software Inc.
+ *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
+ *  Copyright (C) 2003-2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2005 Ralf Baechle (ralf@linux-mips.org)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*
+ * Changes:
+ *  MontaVista Software Inc. <yyuasa@mvista.com> or <source@mvista.com>
+ *  - New creation, NEC VR4111, VR4121, VR4122 and VR4131 are supported.
+ *
+ *  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  - Added support for NEC VR4133.
+ *  - Removed board_irq_init.
+ */
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/smp.h>
+#include <linux/types.h>
+
+#include <asm/cpu.h>
+#include <asm/io.h>
+#include <asm/vr41xx/vr41xx.h>
+
+#define GIUIOSELL_TYPE1	KSEG1ADDR(0x0b000100)
+#define GIUIOSELL_TYPE2	KSEG1ADDR(0x0f000140)
+
+#define GIUIOSELL	0x00
+#define GIUIOSELH	0x02
+#define GIUINTSTATL	0x08
+#define GIUINTSTATH	0x0a
+#define GIUINTENL	0x0c
+#define GIUINTENH	0x0e
+#define GIUINTTYPL	0x10
+#define GIUINTTYPH	0x12
+#define GIUINTALSELL	0x14
+#define GIUINTALSELH	0x16
+#define GIUINTHTSELL	0x18
+#define GIUINTHTSELH	0x1a
+#define GIUFEDGEINHL	0x20
+#define GIUFEDGEINHH	0x22
+#define GIUREDGEINHL	0x24
+#define GIUREDGEINHH	0x26
+
+static uint32_t giu_base;
+
+static struct irqaction giu_cascade = {
+	.handler	= no_action,
+	.mask		= CPU_MASK_NONE,
+	.name		= "cascade",
+};
+
+#define read_giuint(offset)		readw(giu_base + (offset))
+#define write_giuint(val, offset)	writew((val), giu_base + (offset))
+
+#define GIUINT_HIGH_OFFSET	16
+
+static inline uint16_t set_giuint(uint8_t offset, uint16_t set)
+{
+	uint16_t res;
+
+	res = read_giuint(offset);
+	res |= set;
+	write_giuint(res, offset);
+
+	return res;
+}
+
+static inline uint16_t clear_giuint(uint8_t offset, uint16_t clear)
+{
+	uint16_t res;
+
+	res = read_giuint(offset);
+	res &= ~clear;
+	write_giuint(res, offset);
+
+	return res;
+}
+
+static unsigned int startup_giuint_low_irq(unsigned int irq)
+{
+	unsigned int pin;
+
+	pin = GIU_IRQ_TO_PIN(irq);
+	write_giuint((uint16_t)1 << pin, GIUINTSTATL);
+	set_giuint(GIUINTENL, (uint16_t)1 << pin);
+
+	return 0;
+}
+
+static void shutdown_giuint_low_irq(unsigned int irq)
+{
+	clear_giuint(GIUINTENL, (uint16_t)1 << GIU_IRQ_TO_PIN(irq));
+}
+
+static void enable_giuint_low_irq(unsigned int irq)
+{
+	set_giuint(GIUINTENL, (uint16_t)1 << GIU_IRQ_TO_PIN(irq));
+}
+
+#define disable_giuint_low_irq	shutdown_giuint_low_irq
+
+static void ack_giuint_low_irq(unsigned int irq)
+{
+	unsigned int pin;
+
+	pin = GIU_IRQ_TO_PIN(irq);
+	clear_giuint(GIUINTENL, (uint16_t)1 << pin);
+	write_giuint((uint16_t)1 << pin, GIUINTSTATL);
+}
+
+static void end_giuint_low_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		set_giuint(GIUINTENL, (uint16_t)1 << GIU_IRQ_TO_PIN(irq));
+}
+
+static struct hw_interrupt_type giuint_low_irq_type = {
+	.typename	= "GIUINTL",
+	.startup	= startup_giuint_low_irq,
+	.shutdown	= shutdown_giuint_low_irq,
+	.enable		= enable_giuint_low_irq,
+	.disable	= disable_giuint_low_irq,
+	.ack		= ack_giuint_low_irq,
+	.end		= end_giuint_low_irq,
+};
+
+static unsigned int startup_giuint_high_irq(unsigned int irq)
+{
+	unsigned int pin;
+
+	pin = GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET);
+	write_giuint((uint16_t)1 << pin, GIUINTSTATH);
+	set_giuint(GIUINTENH, (uint16_t)1 << pin);
+
+	return 0;
+}
+
+static void shutdown_giuint_high_irq(unsigned int irq)
+{
+	clear_giuint(GIUINTENH, (uint16_t)1 << GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET));
+}
+
+static void enable_giuint_high_irq(unsigned int irq)
+{
+	set_giuint(GIUINTENH, (uint16_t)1 << GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET));
+}
+
+#define disable_giuint_high_irq	shutdown_giuint_high_irq
+
+static void ack_giuint_high_irq(unsigned int irq)
+{
+	unsigned int pin;
+
+	pin = GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET);
+	clear_giuint(GIUINTENH, (uint16_t)1 << pin);
+	write_giuint((uint16_t)1 << pin, GIUINTSTATH);
+}
+
+static void end_giuint_high_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED | IRQ_INPROGRESS)))
+		set_giuint(GIUINTENH, (uint16_t)1 << GIU_IRQ_TO_PIN(irq - GIUINT_HIGH_OFFSET));
+}
+
+static struct hw_interrupt_type giuint_high_irq_type = {
+	.typename	= "GIUINTH",
+	.startup	= startup_giuint_high_irq,
+	.shutdown	= shutdown_giuint_high_irq,
+	.enable		= enable_giuint_high_irq,
+	.disable	= disable_giuint_high_irq,
+	.ack		= ack_giuint_high_irq,
+	.end		= end_giuint_high_irq,
+};
+
+void __init init_vr41xx_giuint_irq(void)
+{
+	int i;
+
+	for (i = GIU_IRQ_BASE; i <= GIU_IRQ_LAST; i++) {
+		if (i < (GIU_IRQ_BASE + GIUINT_HIGH_OFFSET))
+			irq_desc[i].handler = &giuint_low_irq_type;
+		else
+			irq_desc[i].handler = &giuint_high_irq_type;
+	}
+
+	setup_irq(GIUINT_CASCADE_IRQ, &giu_cascade);
+}
+
+void vr41xx_set_irq_trigger(int pin, int trigger, int hold)
+{
+	uint16_t mask;
+
+	if (pin < GIUINT_HIGH_OFFSET) {
+		mask = (uint16_t)1 << pin;
+		if (trigger != TRIGGER_LEVEL) {
+        		set_giuint(GIUINTTYPL, mask);
+			if (hold == SIGNAL_HOLD)
+				set_giuint(GIUINTHTSELL, mask);
+			else
+				clear_giuint(GIUINTHTSELL, mask);
+			if (current_cpu_data.cputype == CPU_VR4133) {
+				switch (trigger) {
+				case TRIGGER_EDGE_FALLING:
+					set_giuint(GIUFEDGEINHL, mask);
+					clear_giuint(GIUREDGEINHL, mask);
+					break;
+				case TRIGGER_EDGE_RISING:
+					clear_giuint(GIUFEDGEINHL, mask);
+					set_giuint(GIUREDGEINHL, mask);
+					break;
+				default:
+					set_giuint(GIUFEDGEINHL, mask);
+					set_giuint(GIUREDGEINHL, mask);
+					break;
+				}
+			}
+		} else {
+			clear_giuint(GIUINTTYPL, mask);
+			clear_giuint(GIUINTHTSELL, mask);
+		}
+		write_giuint(mask, GIUINTSTATL);
+	} else {
+		mask = (uint16_t)1 << (pin - GIUINT_HIGH_OFFSET);
+		if (trigger != TRIGGER_LEVEL) {
+			set_giuint(GIUINTTYPH, mask);
+			if (hold == SIGNAL_HOLD)
+				set_giuint(GIUINTHTSELH, mask);
+			else
+				clear_giuint(GIUINTHTSELH, mask);
+			if (current_cpu_data.cputype == CPU_VR4133) {
+				switch (trigger) {
+				case TRIGGER_EDGE_FALLING:
+					set_giuint(GIUFEDGEINHH, mask);
+					clear_giuint(GIUREDGEINHH, mask);
+					break;
+				case TRIGGER_EDGE_RISING:
+					clear_giuint(GIUFEDGEINHH, mask);
+					set_giuint(GIUREDGEINHH, mask);
+					break;
+				default:
+					set_giuint(GIUFEDGEINHH, mask);
+					set_giuint(GIUREDGEINHH, mask);
+					break;
+				}
+			}
+		} else {
+			clear_giuint(GIUINTTYPH, mask);
+			clear_giuint(GIUINTHTSELH, mask);
+		}
+		write_giuint(mask, GIUINTSTATH);
+	}
+}
+
+EXPORT_SYMBOL(vr41xx_set_irq_trigger);
+
+void vr41xx_set_irq_level(int pin, int level)
+{
+	uint16_t mask;
+
+	if (pin < GIUINT_HIGH_OFFSET) {
+		mask = (uint16_t)1 << pin;
+		if (level == LEVEL_HIGH)
+			set_giuint(GIUINTALSELL, mask);
+		else
+			clear_giuint(GIUINTALSELL, mask);
+		write_giuint(mask, GIUINTSTATL);
+	} else {
+		mask = (uint16_t)1 << (pin - GIUINT_HIGH_OFFSET);
+		if (level == LEVEL_HIGH)
+			set_giuint(GIUINTALSELH, mask);
+		else
+			clear_giuint(GIUINTALSELH, mask);
+		write_giuint(mask, GIUINTSTATH);
+	}
+}
+
+EXPORT_SYMBOL(vr41xx_set_irq_level);
+
+#define GIUINT_NR_IRQS		32
+
+enum {
+	GIUINT_NO_CASCADE,
+	GIUINT_CASCADE
+};
+
+struct vr41xx_giuint_cascade {
+	unsigned int flag;
+	int (*get_irq_number)(int irq);
+};
+
+static struct vr41xx_giuint_cascade giuint_cascade[GIUINT_NR_IRQS];
+
+static int no_irq_number(int irq)
+{
+	return -EINVAL;
+}
+
+int vr41xx_cascade_irq(unsigned int irq, int (*get_irq_number)(int irq))
+{
+	unsigned int pin;
+	int retval;
+
+	if (irq < GIU_IRQ(0) || irq > GIU_IRQ(31))
+		return -EINVAL;
+
+	if(!get_irq_number)
+		return -EINVAL;
+
+	pin = GIU_IRQ_TO_PIN(irq);
+	giuint_cascade[pin].flag = GIUINT_CASCADE;
+	giuint_cascade[pin].get_irq_number = get_irq_number;
+
+	retval = setup_irq(irq, &giu_cascade);
+	if (retval != 0) {
+		giuint_cascade[pin].flag = GIUINT_NO_CASCADE;
+		giuint_cascade[pin].get_irq_number = no_irq_number;
+	}
+
+	return retval;
+}
+
+EXPORT_SYMBOL(vr41xx_cascade_irq);
+
+static inline int get_irq_pin_number(void)
+{
+	uint16_t pendl, pendh, maskl, maskh;
+	int i;
+
+	pendl = read_giuint(GIUINTSTATL);
+	pendh = read_giuint(GIUINTSTATH);
+	maskl = read_giuint(GIUINTENL);
+	maskh = read_giuint(GIUINTENH);
+
+	maskl &= pendl;
+	maskh &= pendh;
+
+	if (maskl) {
+		for (i = 0; i < 16; i++) {
+			if (maskl & ((uint16_t)1 << i))
+				return i;
+		}
+	} else if (maskh) {
+		for (i = 0; i < 16; i++) {
+			if (maskh & ((uint16_t)1 << i))
+				return i + GIUINT_HIGH_OFFSET;
+		}
+	}
+
+	printk(KERN_ERR "spurious GIU interrupt: %04x(%04x),%04x(%04x)\n",
+	       maskl, pendl, maskh, pendh);
+
+	atomic_inc(&irq_err_count);
+
+	return -1;
+}
+
+static inline void ack_giuint_irq(int pin)
+{
+	if (pin < GIUINT_HIGH_OFFSET) {
+		clear_giuint(GIUINTENL, (uint16_t)1 << pin);
+		write_giuint((uint16_t)1 << pin, GIUINTSTATL);
+	} else {
+		pin -= GIUINT_HIGH_OFFSET;
+		clear_giuint(GIUINTENH, (uint16_t)1 << pin);
+		write_giuint((uint16_t)1 << pin, GIUINTSTATH);
+	}
+}
+
+static inline void end_giuint_irq(int pin)
+{
+	if (pin < GIUINT_HIGH_OFFSET)
+		set_giuint(GIUINTENL, (uint16_t)1 << pin);
+	else
+		set_giuint(GIUINTENH, (uint16_t)1 << (pin - GIUINT_HIGH_OFFSET));
+}
+
+void giuint_irq_dispatch(struct pt_regs *regs)
+{
+	struct vr41xx_giuint_cascade *cascade;
+	unsigned int giuint_irq;
+	int pin;
+
+	pin = get_irq_pin_number();
+	if (pin < 0)
+		return;
+
+	disable_irq(GIUINT_CASCADE_IRQ);
+
+	cascade = &giuint_cascade[pin];
+	giuint_irq = GIU_IRQ(pin);
+	if (cascade->flag == GIUINT_CASCADE) {
+		int irq = cascade->get_irq_number(giuint_irq);
+		ack_giuint_irq(pin);
+		if (irq >= 0)
+			do_IRQ(irq, regs);
+		end_giuint_irq(pin);
+	} else {
+		do_IRQ(giuint_irq, regs);
+	}
+
+	enable_irq(GIUINT_CASCADE_IRQ);
+}
+
+static int __init vr41xx_giu_init(void)
+{
+	int i;
+
+	switch (current_cpu_data.cputype) {
+	case CPU_VR4111:
+	case CPU_VR4121:
+		giu_base = GIUIOSELL_TYPE1;
+		break;
+	case CPU_VR4122:
+	case CPU_VR4131:
+	case CPU_VR4133:
+		giu_base = GIUIOSELL_TYPE2;
+		break;
+	default:
+		printk(KERN_ERR "GIU: Unexpected CPU of NEC VR4100 series\n");
+		return -EINVAL;
+	}
+
+	for (i = 0; i < GIUINT_NR_IRQS; i++) {
+		if (i < GIUINT_HIGH_OFFSET)
+			clear_giuint(GIUINTENL, (uint16_t)1 << i);
+		else
+			clear_giuint(GIUINTENH, (uint16_t)1 << (i - GIUINT_HIGH_OFFSET));
+		giuint_cascade[i].flag = GIUINT_NO_CASCADE;
+		giuint_cascade[i].get_irq_number = no_irq_number;
+	}
+
+	return 0;
+}
+
+early_initcall(vr41xx_giu_init);
