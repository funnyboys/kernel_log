commit 19a8d6b7604df85402deecae01d7861cb1d40c89
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Tue Sep 19 15:50:42 2017 +0100

    MIPS: PCI: Move map_irq() hooks out of initdata
    
    04c81c7293df ("MIPS: PCI: Replace pci_fixup_irqs() call with host bridge
    IRQ mapping hooks") moved the PCI IRQ fixup to the new host bridge
    map/swizzle_irq() hooks mechanism. Those hooks can also be called after
    boot, when all the __init/__initdata/__initconst sections have been freed.
    Therefore, functions called by them (and the data they refer to) must not
    be marked as __init/__initdata/__initconst lest compilation trigger section
    mismatch warnings.
    
    Fix all the board files map_irq() hooks by simply removing the respective
    __init/__initdata/__initconst section markers and by adding another
    persistent hook IRQ map for the txx9 board files.
    
    Fixes: 04c81c7293df ("MIPS: PCI: Replace pci_fixup_irqs() call with host bridge IRQ mapping hooks")
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Steve French <smfrench@gmail.com>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 0bd2a1e1ff9a..fb998726bd5d 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -386,9 +386,10 @@ int pcibios_plat_dev_init(struct pci_dev *dev)
 	return 0;
 }
 
-int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+static int (*txx9_pci_map_irq)(const struct pci_dev *dev, u8 slot, u8 pin);
+int pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
-	return txx9_board_vec->pci_map_irq(dev, slot, pin);
+	return txx9_pci_map_irq(dev, slot, pin);
 }
 
 char * (*txx9_board_pcibios_setup)(char *str) __initdata;
@@ -424,5 +425,8 @@ char *__init txx9_pcibios_setup(char *str)
 			txx9_pci_err_action = TXX9_PCI_ERR_IGNORE;
 		return NULL;
 	}
+
+	txx9_pci_map_irq = txx9_board_vec->pci_map_irq;
+
 	return str;
 }

commit 2cec11d871814cd65702ccd3591232ee9f185360
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Dec 7 10:05:15 2016 +0100

    MIPS: TXx9: Modernize printing of kernel messages
    
    - Convert from printk() to pr_*(),
      - Add missing continuations, to fix user-visible breakage,
      - Drop superfluous casts (u64 has been unsigned long long on all
        architectures for many years).
    
    On rbtx4927, this restores the kernel output like:
    
        -TX4927 SDRAMC --
        - CR0:0000007e00000544
        - TR:32800030e
        +TX4927 SDRAMC -- CR0:0000007e00000544 TR:32800030e
    
    and:
    
        -PCIC -- PCICLK:
        -Internal(33.3MHz)
        -
        +PCIC -- PCICLK:Internal(33.3MHz)
    
    Fixes: 4bcc595ccd80decb ("printk: reinstate KERN_CONT for printing continuation lines")
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/14646/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 285d84e5c7b9..0bd2a1e1ff9a 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -55,7 +55,7 @@ int __init txx9_pci66_check(struct pci_controller *hose, int top_bus,
 	/* It seems SLC90E66 needs some time after PCI reset... */
 	mdelay(80);
 
-	printk(KERN_INFO "PCI: Checking 66MHz capabilities...\n");
+	pr_info("PCI: Checking 66MHz capabilities...\n");
 
 	for (pci_devfn = 0; pci_devfn < 0xff; pci_devfn++) {
 		if (PCI_FUNC(pci_devfn))
@@ -74,9 +74,8 @@ int __init txx9_pci66_check(struct pci_controller *hose, int top_bus,
 			early_read_config_word(hose, top_bus, current_bus,
 					       pci_devfn, PCI_STATUS, &stat);
 			if (!(stat & PCI_STATUS_66MHZ)) {
-				printk(KERN_DEBUG
-				       "PCI: %02x:%02x not 66MHz capable.\n",
-				       current_bus, pci_devfn);
+				pr_debug("PCI: %02x:%02x not 66MHz capable.\n",
+					 current_bus, pci_devfn);
 				cap66 = 0;
 				break;
 			}
@@ -209,8 +208,8 @@ txx9_alloc_pci_controller(struct pci_controller *pcic,
 
 	pcic->mem_offset = 0;	/* busaddr == physaddr */
 
-	printk(KERN_INFO "PCI: IO %pR MEM %pR\n",
-	       &pcic->mem_resource[1], &pcic->mem_resource[0]);
+	pr_info("PCI: IO %pR MEM %pR\n", &pcic->mem_resource[1],
+		&pcic->mem_resource[0]);
 
 	/* register_pci_controller() will request MEM resource */
 	release_resource(&pcic->mem_resource[0]);
@@ -219,7 +218,7 @@ txx9_alloc_pci_controller(struct pci_controller *pcic,
 	release_resource(&pcic->mem_resource[0]);
  free_and_exit:
 	kfree(new);
-	printk(KERN_ERR "PCI: Failed to allocate resources.\n");
+	pr_err("PCI: Failed to allocate resources.\n");
 	return NULL;
 }
 
@@ -260,7 +259,7 @@ static int txx9_i8259_irq_setup(int irq)
 	err = request_irq(irq, &i8259_interrupt, IRQF_SHARED,
 			  "cascade(i8259)", (void *)(long)irq);
 	if (!err)
-		printk(KERN_INFO "PCI-ISA bridge PIC (irq %d)\n", irq);
+		pr_info("PCI-ISA bridge PIC (irq %d)\n", irq);
 	return err;
 }
 
@@ -308,13 +307,13 @@ static void quirk_slc90e66_ide(struct pci_dev *dev)
 	/* SMSC SLC90E66 IDE uses irq 14, 15 (default) */
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, 14);
 	pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &dat);
-	printk(KERN_INFO "PCI: %s: IRQ %02x", pci_name(dev), dat);
+	pr_info("PCI: %s: IRQ %02x", pci_name(dev), dat);
 	/* enable SMSC SLC90E66 IDE */
 	for (i = 0; i < ARRAY_SIZE(regs); i++) {
 		pci_read_config_byte(dev, regs[i], &dat);
 		pci_write_config_byte(dev, regs[i], dat | 0x80);
 		pci_read_config_byte(dev, regs[i], &dat);
-		printk(KERN_CONT " IDETIM%d %02x", i, dat);
+		pr_cont(" IDETIM%d %02x", i, dat);
 	}
 	pci_read_config_byte(dev, 0x5c, &dat);
 	/*
@@ -329,8 +328,7 @@ static void quirk_slc90e66_ide(struct pci_dev *dev)
 	dat |= 0x01;
 	pci_write_config_byte(dev, 0x5c, dat);
 	pci_read_config_byte(dev, 0x5c, &dat);
-	printk(KERN_CONT " REG5C %02x", dat);
-	printk(KERN_CONT "\n");
+	pr_cont(" REG5C %02x\n", dat);
 }
 #endif /* CONFIG_TOSHIBA_FPCIB0 */
 
@@ -352,7 +350,7 @@ static void final_fixup(struct pci_dev *dev)
 	    (bist & PCI_BIST_CAPABLE)) {
 		unsigned long timeout;
 		pci_set_power_state(dev, PCI_D0);
-		printk(KERN_INFO "PCI: %s BIST...", pci_name(dev));
+		pr_info("PCI: %s BIST...", pci_name(dev));
 		pci_write_config_byte(dev, PCI_BIST, PCI_BIST_START);
 		timeout = jiffies + HZ * 2;	/* timeout after 2 sec */
 		do {
@@ -361,9 +359,9 @@ static void final_fixup(struct pci_dev *dev)
 				break;
 		} while (bist & PCI_BIST_START);
 		if (bist & (PCI_BIST_CODE_MASK | PCI_BIST_START))
-			printk(KERN_CONT "failed. (0x%x)\n", bist);
+			pr_cont("failed. (0x%x)\n", bist);
 		else
-			printk(KERN_CONT "OK.\n");
+			pr_cont("OK.\n");
 	}
 }
 

commit 5f92635462d64f09f4643e7c15c48ea7a1f7d2b7
Author: Keith Busch <keith.busch@intel.com>
Date:   Tue Sep 13 09:21:47 2016 -0600

    MIPS: PCI: Reduce stack frame usage
    
    This patch removes creating a fake pci device in MIPS early config
    access and instead just uses the pci bus to get the same functionality.
    The struct pci_dev is too large to allocate on the stack, and was relying
    on compiler optimizations to remove its usage.
    
    Signed-off-by: Keith Busch <keith.busch@intel.com>
    Reviewed-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14253/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 1f6bc9a3036c..285d84e5c7b9 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -29,12 +29,8 @@ static int __init
 early_read_config_word(struct pci_controller *hose,
 		       int top_bus, int bus, int devfn, int offset, u16 *value)
 {
-	struct pci_dev fake_dev;
 	struct pci_bus fake_bus;
 
-	fake_dev.bus = &fake_bus;
-	fake_dev.sysdata = hose;
-	fake_dev.devfn = devfn;
 	fake_bus.number = bus;
 	fake_bus.sysdata = hose;
 	fake_bus.ops = hose->pci_ops;
@@ -45,7 +41,7 @@ early_read_config_word(struct pci_controller *hose,
 	else
 		fake_bus.parent = NULL;
 
-	return pci_read_config_word(&fake_dev, offset, value);
+	return pci_bus_read_config_word(&fake_bus, devfn, offset, value);
 }
 
 int __init txx9_pci66_check(struct pci_controller *hose, int top_bus,

commit bd721ea73e1f965569b40620538c942001f76294
Author: Fabian Frederick <fabf@skynet.be>
Date:   Tue Aug 2 14:03:33 2016 -0700

    treewide: replace obsolete _refok by __ref
    
    There was only one use of __initdata_refok and __exit_refok
    
    __init_refok was used 46 times against 82 for __ref.
    
    Those definitions are obsolete since commit 312b1485fb50 ("Introduce new
    section reference annotations tags: __ref, __refdata, __refconst")
    
    This patch removes the following compatibility definitions and replaces
    them treewide.
    
    /* compatibility defines */
    #define __init_refok     __ref
    #define __initdata_refok __refdata
    #define __exit_refok     __ref
    
    I can also provide separate patches if necessary.
    (One patch per tree and check in 1 month or 2 to remove old definitions)
    
    [akpm@linux-foundation.org: coding-style fixes]
    Link: http://lkml.kernel.org/r/1466796271-3043-1-git-send-email-fabf@skynet.be
    Signed-off-by: Fabian Frederick <fabf@skynet.be>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Sam Ravnborg <sam@ravnborg.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index a77698ff2b6f..1f6bc9a3036c 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -268,7 +268,7 @@ static int txx9_i8259_irq_setup(int irq)
 	return err;
 }
 
-static void __init_refok quirk_slc90e66_bridge(struct pci_dev *dev)
+static void __ref quirk_slc90e66_bridge(struct pci_dev *dev)
 {
 	int irq;	/* PCI/ISA Bridge interrupt */
 	u8 reg_64;

commit 5236d5c776524f01e52d2442dcbd5c9aaa4e65e7
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat Jun 28 23:56:57 2014 +0900

    MIPS: TXx9: Add __init_refok annotation to quirk_slc90e66_bridge
    
    This pci fixup routine calls __init functions.
    In general pci fixup routine must not call __init functions,
    but this pci/isa bridge device is not hotpluggable anyway.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7215/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 3c5f1808a4ca..a77698ff2b6f 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -268,7 +268,7 @@ static int txx9_i8259_irq_setup(int irq)
 	return err;
 }
 
-static void quirk_slc90e66_bridge(struct pci_dev *dev)
+static void __init_refok quirk_slc90e66_bridge(struct pci_dev *dev)
 {
 	int irq;	/* PCI/ISA Bridge interrupt */
 	u8 reg_64;

commit ad6f9022da088e5ec219ca0bbe267feb046a57a2
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat Jun 28 23:56:00 2014 +0900

    MIPS: TXx9: Fix quirk_slc90e66_ide
    
    Fix wrong code spotted by -Werror=array-bounds:
            arch/mips/txx9/generic/pci.c:334:23: error: array subscript is above array bounds [-Werror=array-bounds]
              pci_write_config_byte(dev, regs[i], dat);
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7214/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 28713274e0cc..3c5f1808a4ca 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -331,7 +331,7 @@ static void quirk_slc90e66_ide(struct pci_dev *dev)
 	 * !!! DO NOT REMOVE THIS COMMENT IT IS REQUIRED BY SMSC !!!
 	 */
 	dat |= 0x01;
-	pci_write_config_byte(dev, regs[i], dat);
+	pci_write_config_byte(dev, 0x5c, dat);
 	pci_read_config_byte(dev, 0x5c, &dat);
 	printk(KERN_CONT " REG5C %02x", dat);
 	printk(KERN_CONT "\n");

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index ce8f8b9b930c..28713274e0cc 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -2,7 +2,7 @@
  * linux/arch/mips/txx9/pci.c
  *
  * Based on linux/arch/mips/txx9/rbtx4927/setup.c,
- *          linux/arch/mips/txx9/rbtx4938/setup.c,
+ *	    linux/arch/mips/txx9/rbtx4938/setup.c,
  *	    and RBTX49xx patch from CELF patch archive.
  *
  * Copyright 2001-2005 MontaVista Software Inc.
@@ -107,7 +107,7 @@ int txx9_pci_mem_high __initdata;
 
 /*
  * allocate pci_controller and resources.
- * mem_base, io_base: physical address.  0 for auto assignment.
+ * mem_base, io_base: physical address.	 0 for auto assignment.
  * mem_size and io_size means max size on auto assignment.
  * pcic must be &txx9_primary_pcic or NULL.
  */

commit 28eb0e46612a08a235c8b103eb2bd6a1aea83210
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 14:04:39 2012 -0800

    MIPS: drivers: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index b14ee53581a9..ce8f8b9b930c 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -256,8 +256,7 @@ static irqreturn_t i8259_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int __devinit
-txx9_i8259_irq_setup(int irq)
+static int txx9_i8259_irq_setup(int irq)
 {
 	int err;
 
@@ -269,7 +268,7 @@ txx9_i8259_irq_setup(int irq)
 	return err;
 }
 
-static void __devinit quirk_slc90e66_bridge(struct pci_dev *dev)
+static void quirk_slc90e66_bridge(struct pci_dev *dev)
 {
 	int irq;	/* PCI/ISA Bridge interrupt */
 	u8 reg_64;
@@ -304,7 +303,7 @@ static void __devinit quirk_slc90e66_bridge(struct pci_dev *dev)
 	smsc_fdc37m81x_config_end();
 }
 
-static void __devinit quirk_slc90e66_ide(struct pci_dev *dev)
+static void quirk_slc90e66_ide(struct pci_dev *dev)
 {
 	unsigned char dat;
 	int regs[2] = {0x41, 0x43};
@@ -339,7 +338,7 @@ static void __devinit quirk_slc90e66_ide(struct pci_dev *dev)
 }
 #endif /* CONFIG_TOSHIBA_FPCIB0 */
 
-static void __devinit tc35815_fixup(struct pci_dev *dev)
+static void tc35815_fixup(struct pci_dev *dev)
 {
 	/* This device may have PM registers but not they are not supported. */
 	if (dev->pm_cap) {
@@ -348,7 +347,7 @@ static void __devinit tc35815_fixup(struct pci_dev *dev)
 	}
 }
 
-static void __devinit final_fixup(struct pci_dev *dev)
+static void final_fixup(struct pci_dev *dev)
 {
 	unsigned char bist;
 

commit 02582e9bcc36ed503ffede46e104a885dea222fb
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Aug 22 19:11:26 2012 +0900

    treewide: fix typo of "suport" in various comments and Kconfig
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 4efd9185f294..b14ee53581a9 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -341,7 +341,7 @@ static void __devinit quirk_slc90e66_ide(struct pci_dev *dev)
 
 static void __devinit tc35815_fixup(struct pci_dev *dev)
 {
-	/* This device may have PM registers but not they are not suported. */
+	/* This device may have PM registers but not they are not supported. */
 	if (dev->pm_cap) {
 		dev_info(&dev->dev, "PM disabled\n");
 		dev->pm_cap = 0;

commit 287dc4b7642df15fa6b9f286c812e79138acd698
Merge: 720d85075b7e 68d8848567ef
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jul 30 11:45:52 2012 -0700

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
     "More hardware support across the field including a bunch of device
      drivers.  The highlight however really are further steps towards
      device tree.
    
      This has been sitting in -next for ages.  All MIPS _defconfigs have
      been tested to boot or where I don't have hardware available, to at
      least build fine."
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (77 commits)
      MIPS: Loongson 1B: Add defconfig
      MIPS: Loongson 1B: Add board support
      MIPS: Netlogic: early console fix
      MIPS: Netlogic: Fix indentation of smpboot.S
      MIPS: Netlogic: remove cpu_has_dc_aliases define for XLP
      MIPS: Netlogic: Remove unused pcibios_fixups
      MIPS: Netlogic: Add XLP SoC devices in FDT
      MIPS: Netlogic: Add IRQ mappings for more devices
      MIPS: Netlogic: USB support for XLP
      MIPS: Netlogic: XLP PCIe controller support.
      MIPS: Netlogic: Platform changes for XLR/XLS I2C
      MIPS: Netlogic: Platform NAND/NOR flash support
      MIPS: Netlogic: Platform changes for XLS USB
      MIPS: Netlogic: Remove NETLOGIC_ prefix
      MIPS: Netlogic: SMP wakeup code update
      MIPS: Netlogic: Update comments in smpboot.S
      MIPS: BCM63XX: Add 96328avng reference board
      MIPS: Expose PCIe drivers for MIPS
      MIPS: BCM63XX: Add PCIe Support for BCM6328
      MIPS: BCM63XX: Move the PCI initialization into its own function
      ...

commit f7257d38ebb1bd3b8f80662c67ec7d502ac67421
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Jun 4 04:42:04 2012 +0100

    MIPS: PCI: Add missing __devinit attributions to fixup functions.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 64eb71b15280..bab4953c292c 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -304,7 +304,7 @@ static void __devinit quirk_slc90e66_bridge(struct pci_dev *dev)
 	smsc_fdc37m81x_config_end();
 }
 
-static void quirk_slc90e66_ide(struct pci_dev *dev)
+static void __devinit quirk_slc90e66_ide(struct pci_dev *dev)
 {
 	unsigned char dat;
 	int regs[2] = {0x41, 0x43};
@@ -339,7 +339,7 @@ static void quirk_slc90e66_ide(struct pci_dev *dev)
 }
 #endif /* CONFIG_TOSHIBA_FPCIB0 */
 
-static void tc35815_fixup(struct pci_dev *dev)
+static void __devinit tc35815_fixup(struct pci_dev *dev)
 {
 	/* This device may have PM registers but not they are not suported. */
 	if (dev->pm_cap) {
@@ -348,7 +348,7 @@ static void tc35815_fixup(struct pci_dev *dev)
 	}
 }
 
-static void final_fixup(struct pci_dev *dev)
+static void __devinit final_fixup(struct pci_dev *dev)
 {
 	unsigned char bist;
 

commit 85a053fa5f2d67ae5b2968305b16e8d2fe4cdf4d
Author: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
Date:   Thu Jul 19 07:13:54 2012 +0200

    MIPS: PCI: Move fixups from __init to __devinit.
    
    Fixups are executed once the pci-device is found which is during boot
    process so __init seems fine as long as the platform does not support
    hotplug.
    However it is possible to remove the PCI bus at run time and have it
    rediscovered again via "echo 1 > /sys/bus/pci/rescan" and this will call
    the fixups again.
    
    [ralf@linux-mips.org: Made piixirqmap[] in malta_piix_func0_fixup()
    __initdata.]
    
    Signed-off-by: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: linux-mips@linux-mips.org
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 682efb0c108d..64eb71b15280 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -269,7 +269,7 @@ txx9_i8259_irq_setup(int irq)
 	return err;
 }
 
-static void __init quirk_slc90e66_bridge(struct pci_dev *dev)
+static void __devinit quirk_slc90e66_bridge(struct pci_dev *dev)
 {
 	int irq;	/* PCI/ISA Bridge interrupt */
 	u8 reg_64;

commit 9349b44a459677e270ae19a373c58e5c3edbff04
Merge: a7711ba1090a 735bff10c157
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Mon Jul 9 20:56:54 2012 -0600

    Merge branch 'pci/myron-final-fixups-v2' into next
    
    * pci/myron-final-fixups-v2:
      PCI: call final fixups hot-added devices
      PCI: move final fixups from __init to __devinit
      x86/PCI: move final fixups from __init to __devinit
      MIPS/PCI: move final fixups from __init to __devinit
      PCI: never discard enable/suspend/resume_early/resume fixups
      PCI: release temporary reference in __nv_msi_ht_cap_quirk()
      PCI: restructure 'pci_do_fixups()'

commit 02d4b36bf0022a17f20c3a79b3d94a14dbd6da3a
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Mon Jul 9 15:36:27 2012 -0600

    MIPS/PCI: move final fixups from __init to __devinit
    
    Final fixups are executed during device enumeration.  If we support
    hotplug, this may be after boot, so final fixups cannot be __init.
    
    [bhelgaas: changelog]
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 682efb0c108d..ce1ee5088a03 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -256,7 +256,7 @@ static irqreturn_t i8259_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int __init
+static int __devinit
 txx9_i8259_irq_setup(int irq)
 {
 	int err;
@@ -269,7 +269,7 @@ txx9_i8259_irq_setup(int irq)
 	return err;
 }
 
-static void __init quirk_slc90e66_bridge(struct pci_dev *dev)
+static void __devinit quirk_slc90e66_bridge(struct pci_dev *dev)
 {
 	int irq;	/* PCI/ISA Bridge interrupt */
 	u8 reg_64;

commit 938ca5162ec9a835078924447a6f55667e47e857
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Mon Jun 25 21:31:37 2012 -0600

    MIPS/PCI: adjust section annotations for pcibios_setup()
    
    Make pcibios_setup() consistently use the "__init" section annotation.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 682efb0c108d..f028e3dc25fb 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -398,9 +398,9 @@ int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 	return txx9_board_vec->pci_map_irq(dev, slot, pin);
 }
 
-char * (*txx9_board_pcibios_setup)(char *str) __devinitdata;
+char * (*txx9_board_pcibios_setup)(char *str) __initdata;
 
-char *__devinit txx9_pcibios_setup(char *str)
+char *__init txx9_pcibios_setup(char *str)
 {
 	if (txx9_board_pcibios_setup && !txx9_board_pcibios_setup(str))
 		return NULL;

commit 8b5690f8847490c1e3ea47266819833a13621253
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Tue Nov 22 14:38:03 2011 +0000

    MIPS: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled and we even check
    and yell when an interrupt handler returns with interrupts enabled (see
    commit [b738a50a: genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    [ralf@linux-mips.org: Fixed up conflicts in
    arch/mips/alchemy/common/dbdma.c, arch/mips/cavium-octeon/smp.c and
    arch/mips/kernel/perf_event.c.]
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    To: linux-kernel@vger.kernel.org
    Cc: tglx@linutronix.de
    linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2835/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 85a87de17eb4..682efb0c108d 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -262,7 +262,7 @@ txx9_i8259_irq_setup(int irq)
 	int err;
 
 	init_i8259_irqs();
-	err = request_irq(irq, &i8259_interrupt, IRQF_DISABLED|IRQF_SHARED,
+	err = request_irq(irq, &i8259_interrupt, IRQF_SHARED,
 			  "cascade(i8259)", (void *)(long)irq);
 	if (!err)
 		printk(KERN_INFO "PCI-ISA bridge PIC (irq %d)\n", irq);

commit 0bec405e8ee390067e63265b3002aaac49d4eea8
Author: Joe Perches <joe@perches.com>
Date:   Fri Nov 12 13:37:52 2010 -0800

    MIPS: Use printf extension %pR for struct resource
    
    Using %pR standardizes the struct resource output.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    To: Jiri Kosina <trivial@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/1772/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 96e69a00ffc8..85a87de17eb4 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -213,11 +213,8 @@ txx9_alloc_pci_controller(struct pci_controller *pcic,
 
 	pcic->mem_offset = 0;	/* busaddr == physaddr */
 
-	printk(KERN_INFO "PCI: IO 0x%08llx-0x%08llx MEM 0x%08llx-0x%08llx\n",
-	       (unsigned long long)pcic->mem_resource[1].start,
-	       (unsigned long long)pcic->mem_resource[1].end,
-	       (unsigned long long)pcic->mem_resource[0].start,
-	       (unsigned long long)pcic->mem_resource[0].end);
+	printk(KERN_INFO "PCI: IO %pR MEM %pR\n",
+	       &pcic->mem_resource[1], &pcic->mem_resource[0]);
 
 	/* register_pci_controller() will request MEM resource */
 	release_resource(&pcic->mem_resource[0]);

commit b595076a180a56d1bb170e6eceda6eb9d76f4cd3
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Nov 1 15:38:34 2010 -0400

    tree-wide: fix comment/printk typos
    
    "gadget", "through", "command", "maintain", "maintain", "controller", "address",
    "between", "initiali[zs]e", "instead", "function", "select", "already",
    "equal", "access", "management", "hierarchy", "registration", "interest",
    "relative", "memory", "offset", "already",
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 9a0be810cafa..96e69a00ffc8 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -107,7 +107,7 @@ int txx9_pci_mem_high __initdata;
 
 /*
  * allocate pci_controller and resources.
- * mem_base, io_base: physical addresss.  0 for auto assignment.
+ * mem_base, io_base: physical address.  0 for auto assignment.
  * mem_size and io_size means max size on auto assignment.
  * pcic must be &txx9_primary_pcic or NULL.
  */

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 707cfa9c547d..9a0be810cafa 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -20,6 +20,7 @@
 #include <asm/txx9/pci.h>
 #ifdef CONFIG_TOSHIBA_FPCIB0
 #include <linux/interrupt.h>
+#include <linux/slab.h>
 #include <asm/i8259.h>
 #include <asm/txx9/smsc_fdc37m81x.h>
 #endif

commit 13680ade4e57090a8ccad332e84e1f3d48b67125
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Sep 4 22:09:04 2009 +0900

    MIPS: TXx9: Disable PM capability of TX493[89] internal ether
    
    Some TC35815 variants (i.e. TX493[89] internal ether) report existance of
    PM registers though they are not supported.  Disable PM features by
    clearing pdev->pm_cap.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 7b637a7c0e66..707cfa9c547d 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -341,6 +341,15 @@ static void quirk_slc90e66_ide(struct pci_dev *dev)
 }
 #endif /* CONFIG_TOSHIBA_FPCIB0 */
 
+static void tc35815_fixup(struct pci_dev *dev)
+{
+	/* This device may have PM registers but not they are not suported. */
+	if (dev->pm_cap) {
+		dev_info(&dev->dev, "PM disabled\n");
+		dev->pm_cap = 0;
+	}
+}
+
 static void final_fixup(struct pci_dev *dev)
 {
 	unsigned char bist;
@@ -374,6 +383,10 @@ DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_EFAR, PCI_DEVICE_ID_EFAR_SLC90E66_1,
 DECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_EFAR, PCI_DEVICE_ID_EFAR_SLC90E66_1,
 	quirk_slc90e66_ide);
 #endif
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_TOSHIBA_2,
+			PCI_DEVICE_ID_TOSHIBA_TC35815_NWU, tc35815_fixup);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_TOSHIBA_2,
+			PCI_DEVICE_ID_TOSHIBA_TC35815_TX4939, tc35815_fixup);
 DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, final_fixup);
 DECLARE_PCI_FIXUP_RESUME(PCI_ANY_ID, PCI_ANY_ID, final_fixup);
 

commit 07517529225ae4ce770271f83d8cd1004733a01d
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:15 2008 +0900

    [MIPS] TXx9: Add some pci options
    
    Add pci options for backplane type, clock selection, error handling,
    timeout values.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 0b92d8c13208..7b637a7c0e66 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -386,3 +386,39 @@ int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
 {
 	return txx9_board_vec->pci_map_irq(dev, slot, pin);
 }
+
+char * (*txx9_board_pcibios_setup)(char *str) __devinitdata;
+
+char *__devinit txx9_pcibios_setup(char *str)
+{
+	if (txx9_board_pcibios_setup && !txx9_board_pcibios_setup(str))
+		return NULL;
+	if (!strcmp(str, "picmg")) {
+		/* PICMG compliant backplane (TOSHIBA JMB-PICMG-ATX
+		   (5V or 3.3V), JMB-PICMG-L2 (5V only), etc.) */
+		txx9_pci_option |= TXX9_PCI_OPT_PICMG;
+		return NULL;
+	} else if (!strcmp(str, "nopicmg")) {
+		/* non-PICMG compliant backplane (TOSHIBA
+		   RBHBK4100,RBHBK4200, Interface PCM-PCM05, etc.) */
+		txx9_pci_option &= ~TXX9_PCI_OPT_PICMG;
+		return NULL;
+	} else if (!strncmp(str, "clk=", 4)) {
+		char *val = str + 4;
+		txx9_pci_option &= ~TXX9_PCI_OPT_CLK_MASK;
+		if (strcmp(val, "33") == 0)
+			txx9_pci_option |= TXX9_PCI_OPT_CLK_33;
+		else if (strcmp(val, "66") == 0)
+			txx9_pci_option |= TXX9_PCI_OPT_CLK_66;
+		else /* "auto" */
+			txx9_pci_option |= TXX9_PCI_OPT_CLK_AUTO;
+		return NULL;
+	} else if (!strncmp(str, "err=", 4)) {
+		if (!strcmp(str + 4, "panic"))
+			txx9_pci_err_action = TXX9_PCI_ERR_PANIC;
+		else if (!strcmp(str + 4, "ignore"))
+			txx9_pci_err_action = TXX9_PCI_ERR_IGNORE;
+		return NULL;
+	}
+	return str;
+}

commit edcaf1a6a77315562e9781245cc8e028c9a921dc
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 23:27:54 2008 +0900

    [MIPS] TXx9: Make single kernel can support multiple boards
    
    Make single kernel can be used on RBTX4927/37/38.  Also make
    some SoC-specific code independent from board-specific code.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
index 8173faab99bb..0b92d8c13208 100644
--- a/arch/mips/txx9/generic/pci.c
+++ b/arch/mips/txx9/generic/pci.c
@@ -16,6 +16,7 @@
 #include <linux/delay.h>
 #include <linux/jiffies.h>
 #include <linux/io.h>
+#include <asm/txx9/generic.h>
 #include <asm/txx9/pci.h>
 #ifdef CONFIG_TOSHIBA_FPCIB0
 #include <linux/interrupt.h>
@@ -375,3 +376,13 @@ DECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_EFAR, PCI_DEVICE_ID_EFAR_SLC90E66_1,
 #endif
 DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, final_fixup);
 DECLARE_PCI_FIXUP_RESUME(PCI_ANY_ID, PCI_ANY_ID, final_fixup);
+
+int pcibios_plat_dev_init(struct pci_dev *dev)
+{
+	return 0;
+}
+
+int __init pcibios_map_irq(const struct pci_dev *dev, u8 slot, u8 pin)
+{
+	return txx9_board_vec->pci_map_irq(dev, slot, pin);
+}

commit 89d63fe179520b11f54de1f26755b7444c79e73a
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 00:33:08 2008 +0900

    [MIPS] TXx9: Reorganize PCI code
    
    Split out PCIC dependent code and SoC dependent code from board dependent
    code.  Now TX4927 PCIC code is independent from TX4927/TX4938 SoC code.
    Also fix some build problems on CONFIG_PCI=n.
    
    As a bonus, "FPCIB0 Backplane Support" is available for all TX39/TX49 boards
    and PCI66 support is available for all TX49 boards.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/pci.c b/arch/mips/txx9/generic/pci.c
new file mode 100644
index 000000000000..8173faab99bb
--- /dev/null
+++ b/arch/mips/txx9/generic/pci.c
@@ -0,0 +1,377 @@
+/*
+ * linux/arch/mips/txx9/pci.c
+ *
+ * Based on linux/arch/mips/txx9/rbtx4927/setup.c,
+ *          linux/arch/mips/txx9/rbtx4938/setup.c,
+ *	    and RBTX49xx patch from CELF patch archive.
+ *
+ * Copyright 2001-2005 MontaVista Software Inc.
+ * Copyright (C) 1996, 97, 2001, 04  Ralf Baechle (ralf@linux-mips.org)
+ * (C) Copyright TOSHIBA CORPORATION 2000-2001, 2004-2007
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/delay.h>
+#include <linux/jiffies.h>
+#include <linux/io.h>
+#include <asm/txx9/pci.h>
+#ifdef CONFIG_TOSHIBA_FPCIB0
+#include <linux/interrupt.h>
+#include <asm/i8259.h>
+#include <asm/txx9/smsc_fdc37m81x.h>
+#endif
+
+static int __init
+early_read_config_word(struct pci_controller *hose,
+		       int top_bus, int bus, int devfn, int offset, u16 *value)
+{
+	struct pci_dev fake_dev;
+	struct pci_bus fake_bus;
+
+	fake_dev.bus = &fake_bus;
+	fake_dev.sysdata = hose;
+	fake_dev.devfn = devfn;
+	fake_bus.number = bus;
+	fake_bus.sysdata = hose;
+	fake_bus.ops = hose->pci_ops;
+
+	if (bus != top_bus)
+		/* Fake a parent bus structure. */
+		fake_bus.parent = &fake_bus;
+	else
+		fake_bus.parent = NULL;
+
+	return pci_read_config_word(&fake_dev, offset, value);
+}
+
+int __init txx9_pci66_check(struct pci_controller *hose, int top_bus,
+			    int current_bus)
+{
+	u32 pci_devfn;
+	unsigned short vid;
+	int cap66 = -1;
+	u16 stat;
+
+	/* It seems SLC90E66 needs some time after PCI reset... */
+	mdelay(80);
+
+	printk(KERN_INFO "PCI: Checking 66MHz capabilities...\n");
+
+	for (pci_devfn = 0; pci_devfn < 0xff; pci_devfn++) {
+		if (PCI_FUNC(pci_devfn))
+			continue;
+		if (early_read_config_word(hose, top_bus, current_bus,
+					   pci_devfn, PCI_VENDOR_ID, &vid) !=
+		    PCIBIOS_SUCCESSFUL)
+			continue;
+		if (vid == 0xffff)
+			continue;
+
+		/* check 66MHz capability */
+		if (cap66 < 0)
+			cap66 = 1;
+		if (cap66) {
+			early_read_config_word(hose, top_bus, current_bus,
+					       pci_devfn, PCI_STATUS, &stat);
+			if (!(stat & PCI_STATUS_66MHZ)) {
+				printk(KERN_DEBUG
+				       "PCI: %02x:%02x not 66MHz capable.\n",
+				       current_bus, pci_devfn);
+				cap66 = 0;
+				break;
+			}
+		}
+	}
+	return cap66 > 0;
+}
+
+static struct resource primary_pci_mem_res[2] = {
+	{ .name = "PCI MEM" },
+	{ .name = "PCI MMIO" },
+};
+static struct resource primary_pci_io_res = { .name = "PCI IO" };
+struct pci_controller txx9_primary_pcic = {
+	.mem_resource = &primary_pci_mem_res[0],
+	.io_resource = &primary_pci_io_res,
+};
+
+#ifdef CONFIG_64BIT
+int txx9_pci_mem_high __initdata = 1;
+#else
+int txx9_pci_mem_high __initdata;
+#endif
+
+/*
+ * allocate pci_controller and resources.
+ * mem_base, io_base: physical addresss.  0 for auto assignment.
+ * mem_size and io_size means max size on auto assignment.
+ * pcic must be &txx9_primary_pcic or NULL.
+ */
+struct pci_controller *__init
+txx9_alloc_pci_controller(struct pci_controller *pcic,
+			  unsigned long mem_base, unsigned long mem_size,
+			  unsigned long io_base, unsigned long io_size)
+{
+	struct pcic {
+		struct pci_controller c;
+		struct resource r_mem[2];
+		struct resource r_io;
+	} *new = NULL;
+	int min_size = 0x10000;
+
+	if (!pcic) {
+		new = kzalloc(sizeof(*new), GFP_KERNEL);
+		if (!new)
+			return NULL;
+		new->r_mem[0].name = "PCI mem";
+		new->r_mem[1].name = "PCI mmio";
+		new->r_io.name = "PCI io";
+		new->c.mem_resource = new->r_mem;
+		new->c.io_resource = &new->r_io;
+		pcic = &new->c;
+	} else
+		BUG_ON(pcic != &txx9_primary_pcic);
+	pcic->io_resource->flags = IORESOURCE_IO;
+
+	/*
+	 * for auto assignment, first search a (big) region for PCI
+	 * MEM, then search a region for PCI IO.
+	 */
+	if (mem_base) {
+		pcic->mem_resource[0].start = mem_base;
+		pcic->mem_resource[0].end = mem_base + mem_size - 1;
+		if (request_resource(&iomem_resource, &pcic->mem_resource[0]))
+			goto free_and_exit;
+	} else {
+		unsigned long min = 0, max = 0x20000000; /* low 512MB */
+		if (!mem_size) {
+			/* default size for auto assignment */
+			if (txx9_pci_mem_high)
+				mem_size = 0x20000000;	/* mem:512M(max) */
+			else
+				mem_size = 0x08000000;	/* mem:128M(max) */
+		}
+		if (txx9_pci_mem_high) {
+			min = 0x20000000;
+			max = 0xe0000000;
+		}
+		/* search free region for PCI MEM */
+		for (; mem_size >= min_size; mem_size /= 2) {
+			if (allocate_resource(&iomem_resource,
+					      &pcic->mem_resource[0],
+					      mem_size, min, max,
+					      mem_size, NULL, NULL) == 0)
+				break;
+		}
+		if (mem_size < min_size)
+			goto free_and_exit;
+	}
+
+	pcic->mem_resource[1].flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	if (io_base) {
+		pcic->mem_resource[1].start = io_base;
+		pcic->mem_resource[1].end = io_base + io_size - 1;
+		if (request_resource(&iomem_resource, &pcic->mem_resource[1]))
+			goto release_and_exit;
+	} else {
+		if (!io_size)
+			/* default size for auto assignment */
+			io_size = 0x01000000;	/* io:16M(max) */
+		/* search free region for PCI IO in low 512MB */
+		for (; io_size >= min_size; io_size /= 2) {
+			if (allocate_resource(&iomem_resource,
+					      &pcic->mem_resource[1],
+					      io_size, 0, 0x20000000,
+					      io_size, NULL, NULL) == 0)
+				break;
+		}
+		if (io_size < min_size)
+			goto release_and_exit;
+		io_base = pcic->mem_resource[1].start;
+	}
+
+	pcic->mem_resource[0].flags = IORESOURCE_MEM;
+	if (pcic == &txx9_primary_pcic &&
+	    mips_io_port_base == (unsigned long)-1) {
+		/* map ioport 0 to PCI I/O space address 0 */
+		set_io_port_base(IO_BASE + pcic->mem_resource[1].start);
+		pcic->io_resource->start = 0;
+		pcic->io_offset = 0;	/* busaddr == ioaddr */
+		pcic->io_map_base = IO_BASE + pcic->mem_resource[1].start;
+	} else {
+		/* physaddr to ioaddr */
+		pcic->io_resource->start =
+			io_base - (mips_io_port_base - IO_BASE);
+		pcic->io_offset = io_base - (mips_io_port_base - IO_BASE);
+		pcic->io_map_base = mips_io_port_base;
+	}
+	pcic->io_resource->end = pcic->io_resource->start + io_size - 1;
+
+	pcic->mem_offset = 0;	/* busaddr == physaddr */
+
+	printk(KERN_INFO "PCI: IO 0x%08llx-0x%08llx MEM 0x%08llx-0x%08llx\n",
+	       (unsigned long long)pcic->mem_resource[1].start,
+	       (unsigned long long)pcic->mem_resource[1].end,
+	       (unsigned long long)pcic->mem_resource[0].start,
+	       (unsigned long long)pcic->mem_resource[0].end);
+
+	/* register_pci_controller() will request MEM resource */
+	release_resource(&pcic->mem_resource[0]);
+	return pcic;
+ release_and_exit:
+	release_resource(&pcic->mem_resource[0]);
+ free_and_exit:
+	kfree(new);
+	printk(KERN_ERR "PCI: Failed to allocate resources.\n");
+	return NULL;
+}
+
+static int __init
+txx9_arch_pci_init(void)
+{
+	PCIBIOS_MIN_IO = 0x8000;	/* reseve legacy I/O space */
+	return 0;
+}
+arch_initcall(txx9_arch_pci_init);
+
+/* IRQ/IDSEL mapping */
+int txx9_pci_option =
+#ifdef CONFIG_PICMG_PCI_BACKPLANE_DEFAULT
+	TXX9_PCI_OPT_PICMG |
+#endif
+	TXX9_PCI_OPT_CLK_AUTO;
+
+enum txx9_pci_err_action txx9_pci_err_action = TXX9_PCI_ERR_REPORT;
+
+#ifdef CONFIG_TOSHIBA_FPCIB0
+static irqreturn_t i8259_interrupt(int irq, void *dev_id)
+{
+	int isairq;
+
+	isairq = i8259_irq();
+	if (unlikely(isairq <= I8259A_IRQ_BASE))
+		return IRQ_NONE;
+	generic_handle_irq(isairq);
+	return IRQ_HANDLED;
+}
+
+static int __init
+txx9_i8259_irq_setup(int irq)
+{
+	int err;
+
+	init_i8259_irqs();
+	err = request_irq(irq, &i8259_interrupt, IRQF_DISABLED|IRQF_SHARED,
+			  "cascade(i8259)", (void *)(long)irq);
+	if (!err)
+		printk(KERN_INFO "PCI-ISA bridge PIC (irq %d)\n", irq);
+	return err;
+}
+
+static void __init quirk_slc90e66_bridge(struct pci_dev *dev)
+{
+	int irq;	/* PCI/ISA Bridge interrupt */
+	u8 reg_64;
+	u32 reg_b0;
+	u8 reg_e1;
+	irq = pcibios_map_irq(dev, PCI_SLOT(dev->devfn), 1); /* INTA */
+	if (!irq)
+		return;
+	txx9_i8259_irq_setup(irq);
+	pci_read_config_byte(dev, 0x64, &reg_64);
+	pci_read_config_dword(dev, 0xb0, &reg_b0);
+	pci_read_config_byte(dev, 0xe1, &reg_e1);
+	/* serial irq control */
+	reg_64 = 0xd0;
+	/* serial irq pin */
+	reg_b0 |= 0x00010000;
+	/* ide irq on isa14 */
+	reg_e1 &= 0xf0;
+	reg_e1 |= 0x0d;
+	pci_write_config_byte(dev, 0x64, reg_64);
+	pci_write_config_dword(dev, 0xb0, reg_b0);
+	pci_write_config_byte(dev, 0xe1, reg_e1);
+
+	smsc_fdc37m81x_init(0x3f0);
+	smsc_fdc37m81x_config_beg();
+	smsc_fdc37m81x_config_set(SMSC_FDC37M81X_DNUM,
+				  SMSC_FDC37M81X_KBD);
+	smsc_fdc37m81x_config_set(SMSC_FDC37M81X_INT, 1);
+	smsc_fdc37m81x_config_set(SMSC_FDC37M81X_INT2, 12);
+	smsc_fdc37m81x_config_set(SMSC_FDC37M81X_ACTIVE,
+				  1);
+	smsc_fdc37m81x_config_end();
+}
+
+static void quirk_slc90e66_ide(struct pci_dev *dev)
+{
+	unsigned char dat;
+	int regs[2] = {0x41, 0x43};
+	int i;
+
+	/* SMSC SLC90E66 IDE uses irq 14, 15 (default) */
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, 14);
+	pci_read_config_byte(dev, PCI_INTERRUPT_LINE, &dat);
+	printk(KERN_INFO "PCI: %s: IRQ %02x", pci_name(dev), dat);
+	/* enable SMSC SLC90E66 IDE */
+	for (i = 0; i < ARRAY_SIZE(regs); i++) {
+		pci_read_config_byte(dev, regs[i], &dat);
+		pci_write_config_byte(dev, regs[i], dat | 0x80);
+		pci_read_config_byte(dev, regs[i], &dat);
+		printk(KERN_CONT " IDETIM%d %02x", i, dat);
+	}
+	pci_read_config_byte(dev, 0x5c, &dat);
+	/*
+	 * !!! DO NOT REMOVE THIS COMMENT IT IS REQUIRED BY SMSC !!!
+	 *
+	 * This line of code is intended to provide the user with a work
+	 * around solution to the anomalies cited in SMSC's anomaly sheet
+	 * entitled, "SLC90E66 Functional Rev.J_0.1 Anomalies"".
+	 *
+	 * !!! DO NOT REMOVE THIS COMMENT IT IS REQUIRED BY SMSC !!!
+	 */
+	dat |= 0x01;
+	pci_write_config_byte(dev, regs[i], dat);
+	pci_read_config_byte(dev, 0x5c, &dat);
+	printk(KERN_CONT " REG5C %02x", dat);
+	printk(KERN_CONT "\n");
+}
+#endif /* CONFIG_TOSHIBA_FPCIB0 */
+
+static void final_fixup(struct pci_dev *dev)
+{
+	unsigned char bist;
+
+	/* Do build-in self test */
+	if (pci_read_config_byte(dev, PCI_BIST, &bist) == PCIBIOS_SUCCESSFUL &&
+	    (bist & PCI_BIST_CAPABLE)) {
+		unsigned long timeout;
+		pci_set_power_state(dev, PCI_D0);
+		printk(KERN_INFO "PCI: %s BIST...", pci_name(dev));
+		pci_write_config_byte(dev, PCI_BIST, PCI_BIST_START);
+		timeout = jiffies + HZ * 2;	/* timeout after 2 sec */
+		do {
+			pci_read_config_byte(dev, PCI_BIST, &bist);
+			if (time_after(jiffies, timeout))
+				break;
+		} while (bist & PCI_BIST_START);
+		if (bist & (PCI_BIST_CODE_MASK | PCI_BIST_START))
+			printk(KERN_CONT "failed. (0x%x)\n", bist);
+		else
+			printk(KERN_CONT "OK.\n");
+	}
+}
+
+#ifdef CONFIG_TOSHIBA_FPCIB0
+#define PCI_DEVICE_ID_EFAR_SLC90E66_0 0x9460
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_EFAR, PCI_DEVICE_ID_EFAR_SLC90E66_0,
+	quirk_slc90e66_bridge);
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_EFAR, PCI_DEVICE_ID_EFAR_SLC90E66_1,
+	quirk_slc90e66_ide);
+DECLARE_PCI_FIXUP_RESUME(PCI_VENDOR_ID_EFAR, PCI_DEVICE_ID_EFAR_SLC90E66_1,
+	quirk_slc90e66_ide);
+#endif
+DECLARE_PCI_FIXUP_FINAL(PCI_ANY_ID, PCI_ANY_ID, final_fixup);
+DECLARE_PCI_FIXUP_RESUME(PCI_ANY_ID, PCI_ANY_ID, final_fixup);
