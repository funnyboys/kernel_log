commit 3c2b02397893c40ce46e2297ba980fbc40d908b0
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Sat Oct 29 21:36:59 2016 +0200

    MIPS: TXx9: 7segled: use permission-specific DEVICE_ATTR variants
    
    Use DEVICE_ATTR_WO for write only attributes.  This simplifies the
    source code, improves readbility, and reduces the chance of
    inconsistencies.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @wo@
    declarer name DEVICE_ATTR;
    identifier x,x_store;
    @@
    
    DEVICE_ATTR(x, \(0200\|S_IWUSR\), NULL, x_store);
    
    @script:ocaml@
    x << wo.x;
    x_store << wo.x_store;
    @@
    
    if not (x^"_store" = x_store) then Coccilib.include_match false
    
    @@
    declarer name DEVICE_ATTR_WO;
    identifier wo.x,wo.x_store;
    @@
    
    - DEVICE_ATTR(x, \(0200\|S_IWUSR\), NULL, x_store);
    + DEVICE_ATTR_WO(x);
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: kernel-janitors@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/14463/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/7segled.c b/arch/mips/txx9/generic/7segled.c
index 566c58bd44d0..2203c2548cb4 100644
--- a/arch/mips/txx9/generic/7segled.c
+++ b/arch/mips/txx9/generic/7segled.c
@@ -55,8 +55,8 @@ static ssize_t raw_store(struct device *dev,
 	return size;
 }
 
-static DEVICE_ATTR(ascii, 0200, NULL, ascii_store);
-static DEVICE_ATTR(raw, 0200, NULL, raw_store);
+static DEVICE_ATTR_WO(ascii);
+static DEVICE_ATTR_WO(raw);
 
 static ssize_t map_seg7_show(struct device *dev,
 			     struct device_attribute *attr,

commit f0a7a2d042807d08e5bcfd3194e74b16810c4def
Author: Levente Kurusa <levex@linux.com>
Date:   Thu Dec 19 16:03:26 2013 +0100

    MIPS: TXx9: 7segled: add missing put_device call
    
    This is required so that we give up the last reference to the device.
    
    Also, add a new tx_7segled_release function which will be called after the
    put_device to ensure that device is kfree'd.
    
    [ralf@linux-mips.org: Reformat to Linux coding style and make
    tx_7segled_release static.]
    
    Signed-off-by: Levente Kurusa <levex@linux.com>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6260/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/7segled.c b/arch/mips/txx9/generic/7segled.c
index 4642f56e70e5..566c58bd44d0 100644
--- a/arch/mips/txx9/generic/7segled.c
+++ b/arch/mips/txx9/generic/7segled.c
@@ -83,6 +83,11 @@ static struct bus_type tx_7segled_subsys = {
 	.dev_name	= "7segled",
 };
 
+static void tx_7segled_release(struct device *dev)
+{
+	kfree(dev);
+}
+
 static int __init tx_7segled_init_sysfs(void)
 {
 	int error, i;
@@ -103,11 +108,14 @@ static int __init tx_7segled_init_sysfs(void)
 		}
 		dev->id = i;
 		dev->bus = &tx_7segled_subsys;
+		dev->release = &tx_7segled_release;
 		error = device_register(dev);
-		if (!error) {
-			device_create_file(dev, &dev_attr_ascii);
-			device_create_file(dev, &dev_attr_raw);
+		if (error) {
+			put_device(dev);
+			return error;
 		}
+		device_create_file(dev, &dev_attr_ascii);
+		device_create_file(dev, &dev_attr_raw);
 	}
 	return error;
 }

commit 193fb42613ec8d96bcb645cf717e949821ff07a7
Author: Yoichi Yuasa <yuasa@linux-mips.org>
Date:   Tue Jan 10 21:11:56 2012 +0900

    MIPS: txx9 7segled fix struct device has no member
    
    arch/mips/txx9/generic/7segled.c: In function 'tx_7segled_init_sysfs':
    arch/mips/txx9/generic/7segled.c:105:6: error: 'struct device' has no member named 'dev'
    make[3]: *** [arch/mips/txx9/generic/7segled.o] Error 1
    
    Signed-off-by: Yoichi Yuasa <yuasa@linux-mips.org>
    Cc: Greg Kroah-Hartman <gregkh@suse.de>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/3250/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/7segled.c b/arch/mips/txx9/generic/7segled.c
index 8e93b2122524..4642f56e70e5 100644
--- a/arch/mips/txx9/generic/7segled.c
+++ b/arch/mips/txx9/generic/7segled.c
@@ -102,7 +102,7 @@ static int __init tx_7segled_init_sysfs(void)
 			break;
 		}
 		dev->id = i;
-		dev->dev = &tx_7segled_subsys;
+		dev->bus = &tx_7segled_subsys;
 		error = device_register(dev);
 		if (!error) {
 			device_create_file(dev, &dev_attr_ascii);

commit 0e38eaf34e0d9955aeaaed9648b2cfaba3076fee
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 21 15:09:53 2011 -0800

    mips: 7segled - convert sysdev_class to a regular subsystem
    
    After all sysdev classes are ported to regular driver core entities, the
    sysdev implementation will be entirely removed from the kernel.
    
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/mips/txx9/generic/7segled.c b/arch/mips/txx9/generic/7segled.c
index 7f8416f86222..8e93b2122524 100644
--- a/arch/mips/txx9/generic/7segled.c
+++ b/arch/mips/txx9/generic/7segled.c
@@ -9,7 +9,7 @@
  * (C) Copyright TOSHIBA CORPORATION 2005-2007
  * All Rights Reserved.
  */
-#include <linux/sysdev.h>
+#include <linux/device.h>
 #include <linux/slab.h>
 #include <linux/map_to_7segment.h>
 #include <asm/txx9/generic.h>
@@ -37,8 +37,8 @@ int txx9_7segled_putc(unsigned int pos, char c)
 	return 0;
 }
 
-static ssize_t ascii_store(struct sys_device *dev,
-			   struct sysdev_attribute *attr,
+static ssize_t ascii_store(struct device *dev,
+			   struct device_attribute *attr,
 			   const char *buf, size_t size)
 {
 	unsigned int ch = dev->id;
@@ -46,8 +46,8 @@ static ssize_t ascii_store(struct sys_device *dev,
 	return size;
 }
 
-static ssize_t raw_store(struct sys_device *dev,
-			 struct sysdev_attribute *attr,
+static ssize_t raw_store(struct device *dev,
+			 struct device_attribute *attr,
 			 const char *buf, size_t size)
 {
 	unsigned int ch = dev->id;
@@ -55,19 +55,19 @@ static ssize_t raw_store(struct sys_device *dev,
 	return size;
 }
 
-static SYSDEV_ATTR(ascii, 0200, NULL, ascii_store);
-static SYSDEV_ATTR(raw, 0200, NULL, raw_store);
+static DEVICE_ATTR(ascii, 0200, NULL, ascii_store);
+static DEVICE_ATTR(raw, 0200, NULL, raw_store);
 
-static ssize_t map_seg7_show(struct sysdev_class *class,
-			     struct sysdev_class_attribute *attr,
+static ssize_t map_seg7_show(struct device *dev,
+			     struct device_attribute *attr,
 			     char *buf)
 {
 	memcpy(buf, &txx9_seg7map, sizeof(txx9_seg7map));
 	return sizeof(txx9_seg7map);
 }
 
-static ssize_t map_seg7_store(struct sysdev_class *class,
-			      struct sysdev_class_attribute *attr,
+static ssize_t map_seg7_store(struct device *dev,
+			      struct device_attribute *attr,
 			      const char *buf, size_t size)
 {
 	if (size != sizeof(txx9_seg7map))
@@ -76,10 +76,11 @@ static ssize_t map_seg7_store(struct sysdev_class *class,
 	return size;
 }
 
-static SYSDEV_CLASS_ATTR(map_seg7, 0600, map_seg7_show, map_seg7_store);
+static DEVICE_ATTR(map_seg7, 0600, map_seg7_show, map_seg7_store);
 
-static struct sysdev_class tx_7segled_sysdev_class = {
-	.name	= "7segled",
+static struct bus_type tx_7segled_subsys = {
+	.name		= "7segled",
+	.dev_name	= "7segled",
 };
 
 static int __init tx_7segled_init_sysfs(void)
@@ -87,26 +88,25 @@ static int __init tx_7segled_init_sysfs(void)
 	int error, i;
 	if (!tx_7segled_num)
 		return -ENODEV;
-	error = sysdev_class_register(&tx_7segled_sysdev_class);
+	error = subsys_system_register(&tx_7segled_subsys, NULL);
 	if (error)
 		return error;
-	error = sysdev_class_create_file(&tx_7segled_sysdev_class,
-					 &attr_map_seg7);
+	error = device_create_file(tx_7segled_subsys.dev_root, &dev_attr_map_seg7);
 	if (error)
 		return error;
 	for (i = 0; i < tx_7segled_num; i++) {
-		struct sys_device *dev;
+		struct device *dev;
 		dev = kzalloc(sizeof(*dev), GFP_KERNEL);
 		if (!dev) {
 			error = -ENODEV;
 			break;
 		}
 		dev->id = i;
-		dev->cls = &tx_7segled_sysdev_class;
-		error = sysdev_register(dev);
+		dev->dev = &tx_7segled_subsys;
+		error = device_register(dev);
 		if (!error) {
-			sysdev_create_file(dev, &attr_ascii);
-			sysdev_create_file(dev, &attr_raw);
+			device_create_file(dev, &dev_attr_ascii);
+			device_create_file(dev, &dev_attr_raw);
 		}
 	}
 	return error;

commit c9be0a36f9bf392a7984473124a67a12964df11f
Author: Andi Kleen <andi@firstfloor.org>
Date:   Tue Jan 5 12:47:58 2010 +0100

    sysdev: Pass attribute in sysdev_class attributes show/store
    
    Passing the attribute to the low level IO functions allows all kinds
    of cleanups, by sharing low level IO code without requiring
    an own function for every piece of data.
    
    Also drivers can extend the attributes with own data fields
    and use that in the low level function.
    
    Similar to sysdev_attributes and normal attributes.
    
    This is a tree-wide sweep, converting everything in one go.
    
    No functional changes in this patch other than passing the new
    argument everywhere.
    
    Tested on x86, the non x86 parts are uncompiled.
    
    Signed-off-by: Andi Kleen <ak@linux.intel.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/mips/txx9/generic/7segled.c b/arch/mips/txx9/generic/7segled.c
index 727ab21b6618..7f8416f86222 100644
--- a/arch/mips/txx9/generic/7segled.c
+++ b/arch/mips/txx9/generic/7segled.c
@@ -58,13 +58,16 @@ static ssize_t raw_store(struct sys_device *dev,
 static SYSDEV_ATTR(ascii, 0200, NULL, ascii_store);
 static SYSDEV_ATTR(raw, 0200, NULL, raw_store);
 
-static ssize_t map_seg7_show(struct sysdev_class *class, char *buf)
+static ssize_t map_seg7_show(struct sysdev_class *class,
+			     struct sysdev_class_attribute *attr,
+			     char *buf)
 {
 	memcpy(buf, &txx9_seg7map, sizeof(txx9_seg7map));
 	return sizeof(txx9_seg7map);
 }
 
 static ssize_t map_seg7_store(struct sysdev_class *class,
+			      struct sysdev_class_attribute *attr,
 			      const char *buf, size_t size)
 {
 	if (size != sizeof(txx9_seg7map))

commit bc89b2bdefa5f56133d0b19a220880d4ada62560
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Oct 20 23:28:50 2008 +0900

    MIPS: TXx9: 7 segment LED support
    
    Add sysfs interface for 7 segment LED and implement access routine for
    RBTX4939.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/generic/7segled.c b/arch/mips/txx9/generic/7segled.c
new file mode 100644
index 000000000000..727ab21b6618
--- /dev/null
+++ b/arch/mips/txx9/generic/7segled.c
@@ -0,0 +1,112 @@
+/*
+ * 7 Segment LED routines
+ * Based on RBTX49xx patch from CELF patch archive.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * (C) Copyright TOSHIBA CORPORATION 2005-2007
+ * All Rights Reserved.
+ */
+#include <linux/sysdev.h>
+#include <linux/slab.h>
+#include <linux/map_to_7segment.h>
+#include <asm/txx9/generic.h>
+
+static unsigned int tx_7segled_num;
+static void (*tx_7segled_putc)(unsigned int pos, unsigned char val);
+
+void __init txx9_7segled_init(unsigned int num,
+			      void (*putc)(unsigned int pos, unsigned char val))
+{
+	tx_7segled_num = num;
+	tx_7segled_putc = putc;
+}
+
+static SEG7_CONVERSION_MAP(txx9_seg7map, MAP_ASCII7SEG_ALPHANUM_LC);
+
+int txx9_7segled_putc(unsigned int pos, char c)
+{
+	if (pos >= tx_7segled_num)
+		return -EINVAL;
+	c = map_to_seg7(&txx9_seg7map, c);
+	if (c < 0)
+		return c;
+	tx_7segled_putc(pos, c);
+	return 0;
+}
+
+static ssize_t ascii_store(struct sys_device *dev,
+			   struct sysdev_attribute *attr,
+			   const char *buf, size_t size)
+{
+	unsigned int ch = dev->id;
+	txx9_7segled_putc(ch, buf[0]);
+	return size;
+}
+
+static ssize_t raw_store(struct sys_device *dev,
+			 struct sysdev_attribute *attr,
+			 const char *buf, size_t size)
+{
+	unsigned int ch = dev->id;
+	tx_7segled_putc(ch, buf[0]);
+	return size;
+}
+
+static SYSDEV_ATTR(ascii, 0200, NULL, ascii_store);
+static SYSDEV_ATTR(raw, 0200, NULL, raw_store);
+
+static ssize_t map_seg7_show(struct sysdev_class *class, char *buf)
+{
+	memcpy(buf, &txx9_seg7map, sizeof(txx9_seg7map));
+	return sizeof(txx9_seg7map);
+}
+
+static ssize_t map_seg7_store(struct sysdev_class *class,
+			      const char *buf, size_t size)
+{
+	if (size != sizeof(txx9_seg7map))
+		return -EINVAL;
+	memcpy(&txx9_seg7map, buf, size);
+	return size;
+}
+
+static SYSDEV_CLASS_ATTR(map_seg7, 0600, map_seg7_show, map_seg7_store);
+
+static struct sysdev_class tx_7segled_sysdev_class = {
+	.name	= "7segled",
+};
+
+static int __init tx_7segled_init_sysfs(void)
+{
+	int error, i;
+	if (!tx_7segled_num)
+		return -ENODEV;
+	error = sysdev_class_register(&tx_7segled_sysdev_class);
+	if (error)
+		return error;
+	error = sysdev_class_create_file(&tx_7segled_sysdev_class,
+					 &attr_map_seg7);
+	if (error)
+		return error;
+	for (i = 0; i < tx_7segled_num; i++) {
+		struct sys_device *dev;
+		dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+		if (!dev) {
+			error = -ENODEV;
+			break;
+		}
+		dev->id = i;
+		dev->cls = &tx_7segled_sysdev_class;
+		error = sysdev_register(dev);
+		if (!error) {
+			sysdev_create_file(dev, &attr_ascii);
+			sysdev_create_file(dev, &attr_raw);
+		}
+	}
+	return error;
+}
+
+device_initcall(tx_7segled_init_sysfs);
