commit 21cff2d946cd4710abac23d6a7b81ff1965f3fed
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Dec 26 12:03:10 2017 +0530

    MIPS: TXX9: Constify gpio_led
    
    gpio_leds are not supposed to change at runtime. struct
    gpio_led_platform_data contains a const struct gpio_led pointer since
    v2.6.39, so mark the gpio_led structures const too.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/18008/
    [jhogan@kernel.org: improve commit message]
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index f5b367e20dff..31955c1d5555 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -319,7 +319,7 @@ static void __init rbtx4927_mtd_init(void)
 
 static void __init rbtx4927_gpioled_init(void)
 {
-	static struct gpio_led leds[] = {
+	static const struct gpio_led leds[] = {
 		{ .name = "gpioled:green:0", .gpio = 0, .active_low = 1, },
 		{ .name = "gpioled:green:1", .gpio = 1, .active_low = 1, },
 	};

commit 5ac676ade1eac27fb311f0f2fb11eeac5089a66c
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 11 10:48:33 2016 +0200

    MIPS: TXx9: tx49xx: Move GPIO setup from .mem_setup() to .arch_init()
    
    txx9_gpio_init() calls gpiochip_add_data(), which fails with -ENOMEM as
    it is called too early in the boot process. This causes all subsequent
    GPIO operations to fail silently (before commit 54d77198fdfbc4f0 ("gpio:
    bail out silently on NULL descriptors") it printed the error message
    "gpiod_direction_output_raw: invalid GPIO" on RBTX49[23]7).
    
    Postpone all GPIO setup to .arch_init() time to fix this.
    
    Suggested-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-gpio@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/14237/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 3c516ef625e5..f5b367e20dff 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -52,6 +52,7 @@
 #include <linux/leds.h>
 #include <asm/io.h>
 #include <asm/reboot.h>
+#include <asm/txx9pio.h>
 #include <asm/txx9/generic.h>
 #include <asm/txx9/pci.h>
 #include <asm/txx9/rbtx4927.h>
@@ -151,20 +152,37 @@ static void __init tx4937_pci_setup(void)
 	}
 	tx4938_setup_pcierr_irq();
 }
+#else
+static inline void tx4927_pci_setup(void) {}
+static inline void tx4937_pci_setup(void) {}
+#endif /* CONFIG_PCI */
+
+static void __init rbtx4927_gpio_init(void)
+{
+	/* TX4927-SIO DTR on (PIO[15]) */
+	gpio_request(15, "sio-dtr");
+	gpio_direction_output(15, 1);
+
+	tx4927_sio_init(0, 0);
+}
 
 static void __init rbtx4927_arch_init(void)
 {
+	txx9_gpio_init(TX4927_PIO_REG & 0xfffffffffULL, 0, TX4927_NUM_PIO);
+
+	rbtx4927_gpio_init();
+
 	tx4927_pci_setup();
 }
 
 static void __init rbtx4937_arch_init(void)
 {
+	txx9_gpio_init(TX4938_PIO_REG & 0xfffffffffULL, 0, TX4938_NUM_PIO);
+
+	rbtx4927_gpio_init();
+
 	tx4937_pci_setup();
 }
-#else
-#define rbtx4927_arch_init NULL
-#define rbtx4937_arch_init NULL
-#endif /* CONFIG_PCI */
 
 static void toshiba_rbtx4927_restart(char *command)
 {
@@ -205,12 +223,6 @@ static void __init rbtx4927_mem_setup(void)
 #else
 	set_io_port_base(KSEG1 + RBTX4927_ISA_IO_OFFSET);
 #endif
-
-	/* TX4927-SIO DTR on (PIO[15]) */
-	gpio_request(15, "sio-dtr");
-	gpio_direction_output(15, 1);
-
-	tx4927_sio_init(0, 0);
 }
 
 static void __init rbtx4927_clock_init(void)

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index b15adfc2d726..3c516ef625e5 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -2,7 +2,7 @@
  * Toshiba rbtx4927 specific setup
  *
  * Author: MontaVista Software, Inc.
- *         source@mvista.com
+ *	   source@mvista.com
  *
  * Copyright 2001-2002 MontaVista Software Inc.
  *

commit ab4ba291683d07038c7ddf1eec191d3d09e1f468
Author: Yoichi Yuasa <yuasa@linux-mips.org>
Date:   Tue Feb 2 18:40:04 2010 +0900

    MIPS: TXx9: Remove forced serial console setting
    
    It is not always used, even if it is available.
    
    Signed-off-by: Yoichi Yuasa <yuasa@linux-mips.org>
    Cc: linux-mips <linux-mips@linux-mips.org>
    Patchwork: http://patchwork.linux-mips.org/patch/933/
    Acked-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index ee468eaee4f7..b15adfc2d726 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -187,8 +187,6 @@ static void __init rbtx4937_clock_init(void);
 
 static void __init rbtx4927_mem_setup(void)
 {
-	char *argptr;
-
 	if (TX4927_REV_PCODE() == 0x4927) {
 		rbtx4927_clock_init();
 		tx4927_setup();
@@ -213,11 +211,6 @@ static void __init rbtx4927_mem_setup(void)
 	gpio_direction_output(15, 1);
 
 	tx4927_sio_init(0, 0);
-#ifdef CONFIG_SERIAL_TXX9_CONSOLE
-	argptr = prom_getcmdline();
-	if (!strstr(argptr, "console="))
-		strcat(argptr, " console=ttyS0,38400");
-#endif
 }
 
 static void __init rbtx4927_clock_init(void)

commit 742cd5867b2ef7ce865d7ab67574c4e3aa1fb155
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue May 19 22:12:22 2009 +0900

    MIPS: TXx9: Add ACLC support
    
    Add platform support for ACLC of TXx9 SoCs.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 332cdbc7fcef..ee468eaee4f7 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -337,10 +337,14 @@ static void __init rbtx4927_device_init(void)
 	rbtx4927_ne_init();
 	tx4927_wdt_init();
 	rbtx4927_mtd_init();
-	if (TX4927_REV_PCODE() == 0x4927)
+	if (TX4927_REV_PCODE() == 0x4927) {
 		tx4927_dmac_init(2);
-	else
+		tx4927_aclc_init(0, 1);
+	} else {
 		tx4938_dmac_init(0, 2);
+		tx4938_aclc_init();
+	}
+	platform_device_register_simple("txx9aclc-generic", -1, NULL, 0);
 	txx9_iocled_init(RBTX4927_LED_ADDR - IO_BASE, -1, 3, 1, "green", NULL);
 	rbtx4927_gpioled_init();
 }

commit f48c8c958a2d39f13dace880d15a6e711aafe577
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Apr 23 00:40:31 2009 +0900

    MIPS: TXx9: Add DMAC support
    
    Add platform support for DMAC of TXx9 SoCs.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 01129a9d50fa..332cdbc7fcef 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -337,6 +337,10 @@ static void __init rbtx4927_device_init(void)
 	rbtx4927_ne_init();
 	tx4927_wdt_init();
 	rbtx4927_mtd_init();
+	if (TX4927_REV_PCODE() == 0x4927)
+		tx4927_dmac_init(2);
+	else
+		tx4938_dmac_init(0, 2);
 	txx9_iocled_init(RBTX4927_LED_ADDR - IO_BASE, -1, 3, 1, "green", NULL);
 	rbtx4927_gpioled_init();
 }

commit 864cbf804ddfb3d63d3ba3cca7afdeb98be23434
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Sep 2 22:44:38 2008 +0900

    MIPS: RBTX4927: Add GPIO-LED support
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 4a74423b2ba8..01129a9d50fa 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -49,6 +49,7 @@
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <linux/gpio.h>
+#include <linux/leds.h>
 #include <asm/io.h>
 #include <asm/reboot.h>
 #include <asm/txx9/generic.h>
@@ -210,10 +211,6 @@ static void __init rbtx4927_mem_setup(void)
 	/* TX4927-SIO DTR on (PIO[15]) */
 	gpio_request(15, "sio-dtr");
 	gpio_direction_output(15, 1);
-	gpio_request(0, "led");
-	gpio_direction_output(0, 1);
-	gpio_request(1, "led");
-	gpio_direction_output(1, 1);
 
 	tx4927_sio_init(0, 0);
 #ifdef CONFIG_SERIAL_TXX9_CONSOLE
@@ -315,6 +312,25 @@ static void __init rbtx4927_mtd_init(void)
 		tx4927_mtd_init(i);
 }
 
+static void __init rbtx4927_gpioled_init(void)
+{
+	static struct gpio_led leds[] = {
+		{ .name = "gpioled:green:0", .gpio = 0, .active_low = 1, },
+		{ .name = "gpioled:green:1", .gpio = 1, .active_low = 1, },
+	};
+	static struct gpio_led_platform_data pdata = {
+		.num_leds = ARRAY_SIZE(leds),
+		.leds = leds,
+	};
+	struct platform_device *pdev = platform_device_alloc("leds-gpio", 0);
+
+	if (!pdev)
+		return;
+	pdev->dev.platform_data = &pdata;
+	if (platform_device_add(pdev))
+		platform_device_put(pdev);
+}
+
 static void __init rbtx4927_device_init(void)
 {
 	toshiba_rbtx4927_rtc_init();
@@ -322,6 +338,7 @@ static void __init rbtx4927_device_init(void)
 	tx4927_wdt_init();
 	rbtx4927_mtd_init();
 	txx9_iocled_init(RBTX4927_LED_ADDR - IO_BASE, -1, 3, 1, "green", NULL);
+	rbtx4927_gpioled_init();
 }
 
 struct txx9_board_vec rbtx4927_vec __initdata = {

commit ae027ead87b13cff99b4f48da7696aa4fe75393b
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Sep 1 22:22:38 2008 +0900

    MIPS: TXx9: IOC LED support
    
    Add leds-gpio platform device for controlling LEDs connected to IOC on
    RBTX49XX and JMR3927 board.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index abe32c1a79dc..4a74423b2ba8 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -321,6 +321,7 @@ static void __init rbtx4927_device_init(void)
 	rbtx4927_ne_init();
 	tx4927_wdt_init();
 	rbtx4927_mtd_init();
+	txx9_iocled_init(RBTX4927_LED_ADDR - IO_BASE, -1, 3, 1, "green", NULL);
 }
 
 struct txx9_board_vec rbtx4927_vec __initdata = {

commit 51f607c76e1e7bd089dcad97b6b0a58649be06a3
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Aug 19 22:55:11 2008 +0900

    MIPS: TXx9: Add mtd support
    
    Add helper routines to register physmap-flash platform devices for NOR
    flashes.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 0464a39b39ac..abe32c1a79dc 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -307,11 +307,20 @@ static void __init rbtx4927_ne_init(void)
 	platform_device_register_simple("ne", -1, res, ARRAY_SIZE(res));
 }
 
+static void __init rbtx4927_mtd_init(void)
+{
+	int i;
+
+	for (i = 0; i < 2; i++)
+		tx4927_mtd_init(i);
+}
+
 static void __init rbtx4927_device_init(void)
 {
 	toshiba_rbtx4927_rtc_init();
 	rbtx4927_ne_init();
 	tx4927_wdt_init();
+	rbtx4927_mtd_init();
 }
 
 struct txx9_board_vec rbtx4927_vec __initdata = {

commit d10e025f0e4ba4b96d7b5786d232ac5b0b232b11
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Aug 19 22:55:09 2008 +0900

    MIPS: TXx9: Cache fixup
    
    TX39/TX49 can enable/disable I/D cache at runtime.  Add kernel options
    to control them.  This is useful to debug some cache-related issues,
    such as aliasing or I/D coherency.  Also enable CWF bit for TX49 SoCs.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 5985f330838a..0464a39b39ac 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -186,14 +186,8 @@ static void __init rbtx4937_clock_init(void);
 
 static void __init rbtx4927_mem_setup(void)
 {
-	u32 cp0_config;
 	char *argptr;
 
-	/* enable caches -- HCP5 does this, pmon does not */
-	cp0_config = read_c0_config();
-	cp0_config = cp0_config & ~(TX49_CONF_IC | TX49_CONF_DC);
-	write_c0_config(cp0_config);
-
 	if (TX4927_REV_PCODE() == 0x4927) {
 		rbtx4927_clock_init();
 		tx4927_setup();

commit f96a3383cfede841cdf80a5927f14478981ed78c
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Aug 19 22:55:05 2008 +0900

    MIPS: RBTX4927: More explicit initialization
    
    * Make sure all interrupts cleared on startup
    * Initialize some GPIOs
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 0d39bafea794..5985f330838a 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -48,6 +48,7 @@
 #include <linux/ioport.h>
 #include <linux/platform_device.h>
 #include <linux/delay.h>
+#include <linux/gpio.h>
 #include <asm/io.h>
 #include <asm/reboot.h>
 #include <asm/txx9/generic.h>
@@ -212,6 +213,14 @@ static void __init rbtx4927_mem_setup(void)
 	set_io_port_base(KSEG1 + RBTX4927_ISA_IO_OFFSET);
 #endif
 
+	/* TX4927-SIO DTR on (PIO[15]) */
+	gpio_request(15, "sio-dtr");
+	gpio_direction_output(15, 1);
+	gpio_request(0, "led");
+	gpio_direction_output(0, 1);
+	gpio_request(1, "led");
+	gpio_direction_output(1, 1);
+
 	tx4927_sio_init(0, 0);
 #ifdef CONFIG_SERIAL_TXX9_CONSOLE
 	argptr = prom_getcmdline();

commit 7779a5e07d33fe316fe468e7afe7975fb686a831
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 25 23:08:06 2008 +0900

    [MIPS] TXx9: Unify serial_txx9 setup
    
    * Unify calling of early_serial_txx9_setup.
    * Use dedicated serial clock on RBTX4938.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 962ada57d12d..0d39bafea794 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -212,7 +212,7 @@ static void __init rbtx4927_mem_setup(void)
 	set_io_port_base(KSEG1 + RBTX4927_ISA_IO_OFFSET);
 #endif
 
-	tx4927_setup_serial();
+	tx4927_sio_init(0, 0);
 #ifdef CONFIG_SERIAL_TXX9_CONSOLE
 	argptr = prom_getcmdline();
 	if (!strstr(argptr, "console="))

commit bb72f1f729dcbd6a6a93c74479eeaa19deebfb47
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:21 2008 +0900

    [MIPS] TXx9: Random cleanup
    
    * Random cleanups spotted by checkpatch script.
    * Do not initialize panic_timeout.  "panic=" kernel parameter can be used.
    * Do not add "ip=any" or "ip=bootp".  This options is not board specific.
    * Do not add "root=/dev/nfs".  This is default on CONFIG_ROOT_NFS.
    * Kill unused error checking.
    * Fix IRQ comment to match current code.
    * Kill some unneeded includes
    * ST0_ERL is already cleared in generic code.
    * conswitchp is initialized generic code.
    * __init is not needed in prototype.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index f01af382e9a8..962ada57d12d 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -46,7 +46,6 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/ioport.h>
-#include <linux/interrupt.h>
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <asm/io.h>
@@ -189,9 +188,6 @@ static void __init rbtx4927_mem_setup(void)
 	u32 cp0_config;
 	char *argptr;
 
-	/* f/w leaves this on at startup */
-	clear_c0_status(ST0_ERL);
-
 	/* enable caches -- HCP5 does this, pmon does not */
 	cp0_config = read_c0_config();
 	cp0_config = cp0_config & ~(TX49_CONF_IC | TX49_CONF_DC);
@@ -218,24 +214,9 @@ static void __init rbtx4927_mem_setup(void)
 
 	tx4927_setup_serial();
 #ifdef CONFIG_SERIAL_TXX9_CONSOLE
-        argptr = prom_getcmdline();
-        if (strstr(argptr, "console=") == NULL) {
-                strcat(argptr, " console=ttyS0,38400");
-        }
-#endif
-
-#ifdef CONFIG_ROOT_NFS
-        argptr = prom_getcmdline();
-        if (strstr(argptr, "root=") == NULL) {
-                strcat(argptr, " root=/dev/nfs rw");
-        }
-#endif
-
-#ifdef CONFIG_IP_PNP
-        argptr = prom_getcmdline();
-        if (strstr(argptr, "ip=") == NULL) {
-                strcat(argptr, " ip=any");
-        }
+	argptr = prom_getcmdline();
+	if (!strstr(argptr, "console="))
+		strcat(argptr, " console=ttyS0,38400");
 #endif
 }
 
@@ -298,19 +279,17 @@ static void __init rbtx4927_time_init(void)
 	tx4927_time_init(0);
 }
 
-static int __init toshiba_rbtx4927_rtc_init(void)
+static void __init toshiba_rbtx4927_rtc_init(void)
 {
 	struct resource res = {
 		.start	= RBTX4927_BRAMRTC_BASE - IO_BASE,
 		.end	= RBTX4927_BRAMRTC_BASE - IO_BASE + 0x800 - 1,
 		.flags	= IORESOURCE_MEM,
 	};
-	struct platform_device *dev =
-		platform_device_register_simple("rtc-ds1742", -1, &res, 1);
-	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
+	platform_device_register_simple("rtc-ds1742", -1, &res, 1);
 }
 
-static int __init rbtx4927_ne_init(void)
+static void __init rbtx4927_ne_init(void)
 {
 	struct resource res[] = {
 		{
@@ -322,10 +301,7 @@ static int __init rbtx4927_ne_init(void)
 			.flags	= IORESOURCE_IRQ,
 		}
 	};
-	struct platform_device *dev =
-		platform_device_register_simple("ne", -1,
-						res, ARRAY_SIZE(res));
-	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
+	platform_device_register_simple("ne", -1, res, ARRAY_SIZE(res));
 }
 
 static void __init rbtx4927_device_init(void)

commit 683147254ef7e69ebbbe55280ba6a3c5ae2325d8
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:18 2008 +0900

    [MIPS] TXx9: Cleanup watchdog
    
    Unify registration of txx9wdt platform device.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 54c33c3e9f7d..f01af382e9a8 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -328,30 +328,11 @@ static int __init rbtx4927_ne_init(void)
 	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
 }
 
-/* Watchdog support */
-
-static int __init txx9_wdt_init(unsigned long base)
-{
-	struct resource res = {
-		.start	= base,
-		.end	= base + 0x100 - 1,
-		.flags	= IORESOURCE_MEM,
-	};
-	struct platform_device *dev =
-		platform_device_register_simple("txx9wdt", -1, &res, 1);
-	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
-}
-
-static int __init rbtx4927_wdt_init(void)
-{
-	return txx9_wdt_init(TX4927_TMR_REG(2) & 0xfffffffffULL);
-}
-
 static void __init rbtx4927_device_init(void)
 {
 	toshiba_rbtx4927_rtc_init();
 	rbtx4927_ne_init();
-	rbtx4927_wdt_init();
+	tx4927_wdt_init();
 }
 
 struct txx9_board_vec rbtx4927_vec __initdata = {

commit a49297e8fc8a9a835ac4ec124aa83028abdcc7d5
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:17 2008 +0900

    [MIPS] TXx9: Cleanup restart/halt/power_off
    
    Unify machine_restart/machine_halt/pm_power_off and add fallback
    machine_halt routine.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 65b72247d320..54c33c3e9f7d 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -47,11 +47,9 @@
 #include <linux/types.h>
 #include <linux/ioport.h>
 #include <linux/interrupt.h>
-#include <linux/pm.h>
 #include <linux/platform_device.h>
 #include <linux/delay.h>
 #include <asm/io.h>
-#include <asm/processor.h>
 #include <asm/reboot.h>
 #include <asm/txx9/generic.h>
 #include <asm/txx9/pci.h>
@@ -167,17 +165,8 @@ static void __init rbtx4937_arch_init(void)
 #define rbtx4937_arch_init NULL
 #endif /* CONFIG_PCI */
 
-static void __noreturn wait_forever(void)
-{
-	while (1)
-		if (cpu_wait)
-			(*cpu_wait)();
-}
-
 static void toshiba_rbtx4927_restart(char *command)
 {
-	printk(KERN_NOTICE "System Rebooting...\n");
-
 	/* enable the s/w reset register */
 	writeb(1, rbtx4927_softresetlock_addr);
 
@@ -188,24 +177,8 @@ static void toshiba_rbtx4927_restart(char *command)
 	/* do a s/w reset */
 	writeb(1, rbtx4927_softreset_addr);
 
-	/* do something passive while waiting for reset */
-	local_irq_disable();
-	wait_forever();
-	/* no return */
-}
-
-static void toshiba_rbtx4927_halt(void)
-{
-	printk(KERN_NOTICE "System Halted\n");
-	local_irq_disable();
-	wait_forever();
-	/* no return */
-}
-
-static void toshiba_rbtx4927_power_off(void)
-{
-	toshiba_rbtx4927_halt();
-	/* no return */
+	/* fallback */
+	(*_machine_halt)();
 }
 
 static void __init rbtx4927_clock_init(void);
@@ -233,8 +206,6 @@ static void __init rbtx4927_mem_setup(void)
 	}
 
 	_machine_restart = toshiba_rbtx4927_restart;
-	_machine_halt = toshiba_rbtx4927_halt;
-	pm_power_off = toshiba_rbtx4927_power_off;
 
 #ifdef CONFIG_PCI
 	txx9_alloc_pci_controller(&txx9_primary_pcic,

commit 455cc256eb23915100e203fb33ee143afd127954
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 25 23:01:35 2008 +0900

    [MIPS] TXx9: PCI error handling
    
    From: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Date: Thu, 24 Jul 2008 00:25:16 +0900
    Subject: [PATCH] txx9: PCI error handling
    
    Add more control and detailed report on PCI error interrupt.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 88c05ccee3b2..65b72247d320 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -103,6 +103,7 @@ static void __init tx4927_pci_setup(void)
 		tx4927_report_pciclk();
 		tx4927_pcic_setup(tx4927_pcicptr, c, extarb);
 	}
+	tx4927_setup_pcierr_irq();
 }
 
 static void __init tx4937_pci_setup(void)
@@ -149,6 +150,7 @@ static void __init tx4937_pci_setup(void)
 		tx4938_report_pciclk();
 		tx4927_pcic_setup(tx4938_pcicptr, c, extarb);
 	}
+	tx4938_setup_pcierr_irq();
 }
 
 static void __init rbtx4927_arch_init(void)

commit 07517529225ae4ce770271f83d8cd1004733a01d
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:15 2008 +0900

    [MIPS] TXx9: Add some pci options
    
    Add pci options for backplane type, clock selection, error handling,
    timeout values.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 3da20ea3e55c..88c05ccee3b2 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -238,6 +238,7 @@ static void __init rbtx4927_mem_setup(void)
 	txx9_alloc_pci_controller(&txx9_primary_pcic,
 				  RBTX4927_PCIMEM, RBTX4927_PCIMEM_SIZE,
 				  RBTX4927_PCIIO, RBTX4927_PCIIO_SIZE);
+	txx9_board_pcibios_setup = tx4927_pcibios_setup;
 #else
 	set_io_port_base(KSEG1 + RBTX4927_ISA_IO_OFFSET);
 #endif

commit 94a4c32939dede9328c6e4face335eb8441fc18d
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat Jul 19 01:51:47 2008 +0900

    [MIPS] TXx9: Add 64-bit support
    
    SYS_SUPPORTS_64BIT_KERNEL is enabled for RBTX4927/RBTX4938, but
    actually it was broken for long time (or from the beginning).  Now it
    should work.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 1657fd935da8..3da20ea3e55c 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -53,17 +53,10 @@
 #include <asm/io.h>
 #include <asm/processor.h>
 #include <asm/reboot.h>
-#include <asm/time.h>
-#include <asm/txx9tmr.h>
 #include <asm/txx9/generic.h>
 #include <asm/txx9/pci.h>
 #include <asm/txx9/rbtx4927.h>
 #include <asm/txx9/tx4938.h>	/* for TX4937 */
-#ifdef CONFIG_SERIAL_TXX9
-#include <linux/serial_core.h>
-#endif
-
-static int tx4927_ccfg_toeon = 1;
 
 #ifdef CONFIG_PCI
 static void __init tx4927_pci_setup(void)
@@ -184,14 +177,14 @@ static void toshiba_rbtx4927_restart(char *command)
 	printk(KERN_NOTICE "System Rebooting...\n");
 
 	/* enable the s/w reset register */
-	writeb(RBTX4927_SW_RESET_ENABLE_SET, RBTX4927_SW_RESET_ENABLE);
+	writeb(1, rbtx4927_softresetlock_addr);
 
 	/* wait for enable to be seen */
-	while ((readb(RBTX4927_SW_RESET_ENABLE) &
-		RBTX4927_SW_RESET_ENABLE_SET) == 0x00);
+	while (!(readb(rbtx4927_softresetlock_addr) & 1))
+		;
 
 	/* do a s/w reset */
-	writeb(RBTX4927_SW_RESET_DO_SET, RBTX4927_SW_RESET_DO);
+	writeb(1, rbtx4927_softreset_addr);
 
 	/* do something passive while waiting for reset */
 	local_irq_disable();
@@ -213,9 +206,11 @@ static void toshiba_rbtx4927_power_off(void)
 	/* no return */
 }
 
+static void __init rbtx4927_clock_init(void);
+static void __init rbtx4937_clock_init(void);
+
 static void __init rbtx4927_mem_setup(void)
 {
-	int i;
 	u32 cp0_config;
 	char *argptr;
 
@@ -227,16 +222,18 @@ static void __init rbtx4927_mem_setup(void)
 	cp0_config = cp0_config & ~(TX49_CONF_IC | TX49_CONF_DC);
 	write_c0_config(cp0_config);
 
-	ioport_resource.end = 0xffffffff;
-	iomem_resource.end = 0xffffffff;
+	if (TX4927_REV_PCODE() == 0x4927) {
+		rbtx4927_clock_init();
+		tx4927_setup();
+	} else {
+		rbtx4937_clock_init();
+		tx4938_setup();
+	}
 
 	_machine_restart = toshiba_rbtx4927_restart;
 	_machine_halt = toshiba_rbtx4927_halt;
 	pm_power_off = toshiba_rbtx4927_power_off;
 
-	for (i = 0; i < TX4927_NR_TMR; i++)
-		txx9_tmr_init(TX4927_TMR_REG(0) & 0xfffffffffULL);
-
 #ifdef CONFIG_PCI
 	txx9_alloc_pci_controller(&txx9_primary_pcic,
 				  RBTX4927_PCIMEM, RBTX4927_PCIMEM_SIZE,
@@ -245,36 +242,13 @@ static void __init rbtx4927_mem_setup(void)
 	set_io_port_base(KSEG1 + RBTX4927_ISA_IO_OFFSET);
 #endif
 
-	/* CCFG */
-	/* do reset on watchdog */
-	tx4927_ccfg_set(TX4927_CCFG_WR);
-	/* enable Timeout BusError */
-	if (tx4927_ccfg_toeon)
-		tx4927_ccfg_set(TX4927_CCFG_TOE);
-
-#ifdef CONFIG_SERIAL_TXX9
-	{
-		extern int early_serial_txx9_setup(struct uart_port *port);
-		struct uart_port req;
-		for(i = 0; i < 2; i++) {
-			memset(&req, 0, sizeof(req));
-			req.line = i;
-			req.iotype = UPIO_MEM;
-			req.membase = (char *)(0xff1ff300 + i * 0x100);
-			req.mapbase = 0xff1ff300 + i * 0x100;
-			req.irq = TXX9_IRQ_BASE + TX4927_IR_SIO(i);
-			req.flags |= UPF_BUGGY_UART /*HAVE_CTS_LINE*/;
-			req.uartclk = 50000000;
-			early_serial_txx9_setup(&req);
-		}
-	}
+	tx4927_setup_serial();
 #ifdef CONFIG_SERIAL_TXX9_CONSOLE
         argptr = prom_getcmdline();
         if (strstr(argptr, "console=") == NULL) {
                 strcat(argptr, " console=ttyS0,38400");
         }
 #endif
-#endif
 
 #ifdef CONFIG_ROOT_NFS
         argptr = prom_getcmdline();
@@ -291,19 +265,7 @@ static void __init rbtx4927_mem_setup(void)
 #endif
 }
 
-static void __init rbtx49x7_common_time_init(void)
-{
-	/* change default value to udelay/mdelay take reasonable time */
-	loops_per_jiffy = txx9_cpu_clock / HZ / 2;
-
-	mips_hpt_frequency = txx9_cpu_clock / 2;
-	if (____raw_readq(&tx4927_ccfgptr->ccfg) & TX4927_CCFG_TINTDIS)
-		txx9_clockevent_init(TX4927_TMR_REG(0) & 0xfffffffffULL,
-				     TXX9_IRQ_BASE + 17,
-				     50000000);
-}
-
-static void __init rbtx4927_time_init(void)
+static void __init rbtx4927_clock_init(void)
 {
 	/*
 	 * ASSUMPTION: PCIDIVMODE is configured for PCI 33MHz or 66MHz.
@@ -325,11 +287,9 @@ static void __init rbtx4927_time_init(void)
 	default:
 		txx9_cpu_clock = 200000000;	/* 200MHz */
 	}
-
-	rbtx49x7_common_time_init();
 }
 
-static void __init rbtx4937_time_init(void)
+static void __init rbtx4937_clock_init(void)
 {
 	/*
 	 * ASSUMPTION: PCIDIVMODE is configured for PCI 33MHz or 66MHz.
@@ -357,15 +317,18 @@ static void __init rbtx4937_time_init(void)
 	default:
 		txx9_cpu_clock = 333333333;	/* 333MHz */
 	}
+}
 
-	rbtx49x7_common_time_init();
+static void __init rbtx4927_time_init(void)
+{
+	tx4927_time_init(0);
 }
 
 static int __init toshiba_rbtx4927_rtc_init(void)
 {
-	static struct resource __initdata res = {
-		.start	= 0x1c010000,
-		.end	= 0x1c010000 + 0x800 - 1,
+	struct resource res = {
+		.start	= RBTX4927_BRAMRTC_BASE - IO_BASE,
+		.end	= RBTX4927_BRAMRTC_BASE - IO_BASE + 0x800 - 1,
 		.flags	= IORESOURCE_MEM,
 	};
 	struct platform_device *dev =
@@ -375,7 +338,7 @@ static int __init toshiba_rbtx4927_rtc_init(void)
 
 static int __init rbtx4927_ne_init(void)
 {
-	static struct resource __initdata res[] = {
+	struct resource res[] = {
 		{
 			.start	= RBTX4927_RTL_8019_BASE,
 			.end	= RBTX4927_RTL_8019_BASE + 0x20 - 1,
@@ -434,7 +397,7 @@ struct txx9_board_vec rbtx4937_vec __initdata = {
 	.prom_init = rbtx4927_prom_init,
 	.mem_setup = rbtx4927_mem_setup,
 	.irq_setup = rbtx4927_irq_setup,
-	.time_init = rbtx4937_time_init,
+	.time_init = rbtx4927_time_init,
 	.device_init = rbtx4927_device_init,
 	.arch_init = rbtx4937_arch_init,
 #ifdef CONFIG_PCI

commit 7b22609442a32050e37cec5f6735376af61e68a1
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Jul 14 00:15:04 2008 +0900

    [MIPS] TXx9: cleanup and fix some sparse warnings
    
    * Do not return void value
    * Make some functions static
    * Do not include unnecessary bootinfo.h
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index aba11f376a51..1657fd935da8 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -50,8 +50,6 @@
 #include <linux/pm.h>
 #include <linux/platform_device.h>
 #include <linux/delay.h>
-
-#include <asm/bootinfo.h>
 #include <asm/io.h>
 #include <asm/processor.h>
 #include <asm/reboot.h>
@@ -65,14 +63,6 @@
 #include <linux/serial_core.h>
 #endif
 
-/* These functions are used for rebooting or halting the machine*/
-extern void toshiba_rbtx4927_restart(char *command);
-extern void toshiba_rbtx4927_halt(void);
-extern void toshiba_rbtx4927_power_off(void);
-extern void toshiba_rbtx4927_irq_setup(void);
-
-char *prom_getcmdline(void);
-
 static int tx4927_ccfg_toeon = 1;
 
 #ifdef CONFIG_PCI
@@ -189,7 +179,7 @@ static void __noreturn wait_forever(void)
 			(*cpu_wait)();
 }
 
-void toshiba_rbtx4927_restart(char *command)
+static void toshiba_rbtx4927_restart(char *command)
 {
 	printk(KERN_NOTICE "System Rebooting...\n");
 
@@ -209,7 +199,7 @@ void toshiba_rbtx4927_restart(char *command)
 	/* no return */
 }
 
-void toshiba_rbtx4927_halt(void)
+static void toshiba_rbtx4927_halt(void)
 {
 	printk(KERN_NOTICE "System Halted\n");
 	local_irq_disable();
@@ -217,7 +207,7 @@ void toshiba_rbtx4927_halt(void)
 	/* no return */
 }
 
-void toshiba_rbtx4927_power_off(void)
+static void toshiba_rbtx4927_power_off(void)
 {
 	toshiba_rbtx4927_halt();
 	/* no return */

commit 6e68665e51b9937b132a990b9ae7f04118e64688
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Sun Jul 13 20:04:18 2008 +0900

    [MIPS] remove machtype for group Toshiba
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Acked-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index adc91c0bbb95..aba11f376a51 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -428,7 +428,6 @@ static void __init rbtx4927_device_init(void)
 }
 
 struct txx9_board_vec rbtx4927_vec __initdata = {
-	.type = MACH_TOSHIBA_RBTX4927,
 	.system = "Toshiba RBTX4927",
 	.prom_init = rbtx4927_prom_init,
 	.mem_setup = rbtx4927_mem_setup,
@@ -441,7 +440,6 @@ struct txx9_board_vec rbtx4927_vec __initdata = {
 #endif
 };
 struct txx9_board_vec rbtx4937_vec __initdata = {
-	.type = MACH_TOSHIBA_RBTX4937,
 	.system = "Toshiba RBTX4937",
 	.prom_init = rbtx4927_prom_init,
 	.mem_setup = rbtx4927_mem_setup,

commit b6c4053610f04011bc0ecbc5a0417afe169b2693
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Sun Jul 13 20:02:13 2008 +0900

    [MIPS] separate rbtx4927_time_init() and rbtx4937_time_init()
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Acked-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index b4c4178607c4..adc91c0bbb95 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -301,6 +301,18 @@ static void __init rbtx4927_mem_setup(void)
 #endif
 }
 
+static void __init rbtx49x7_common_time_init(void)
+{
+	/* change default value to udelay/mdelay take reasonable time */
+	loops_per_jiffy = txx9_cpu_clock / HZ / 2;
+
+	mips_hpt_frequency = txx9_cpu_clock / 2;
+	if (____raw_readq(&tx4927_ccfgptr->ccfg) & TX4927_CCFG_TINTDIS)
+		txx9_clockevent_init(TX4927_TMR_REG(0) & 0xfffffffffULL,
+				     TXX9_IRQ_BASE + 17,
+				     50000000);
+}
+
 static void __init rbtx4927_time_init(void)
 {
 	/*
@@ -313,6 +325,24 @@ static void __init rbtx4927_time_init(void)
 	 * CPU 166MHz: PCI 33MHz : PCIDIVMODE: 10 (1/5)
 	 * CPU 200MHz: PCI 33MHz : PCIDIVMODE: 11 (1/6)
 	 * i.e. S9[3]: ON (83MHz), OFF (100MHz)
+	 */
+	switch ((unsigned long)__raw_readq(&tx4927_ccfgptr->ccfg) &
+		TX4927_CCFG_PCIDIVMODE_MASK) {
+	case TX4927_CCFG_PCIDIVMODE_2_5:
+	case TX4927_CCFG_PCIDIVMODE_5:
+		txx9_cpu_clock = 166666666;	/* 166MHz */
+		break;
+	default:
+		txx9_cpu_clock = 200000000;	/* 200MHz */
+	}
+
+	rbtx49x7_common_time_init();
+}
+
+static void __init rbtx4937_time_init(void)
+{
+	/*
+	 * ASSUMPTION: PCIDIVMODE is configured for PCI 33MHz or 66MHz.
 	 *
 	 * For TX4937:
 	 * PCIDIVMODE[12:11]'s initial value is given by S1[5:4] (ON:0, OFF:1)
@@ -324,39 +354,21 @@ static void __init rbtx4927_time_init(void)
 	 * CPU 333MHz: PCI 33MHz : PCIDIVMODE: 100 (1/10)
 	 * CPU 333MHz: PCI 66MHz : PCIDIVMODE: 101 (1/5)
 	 */
-	if (mips_machtype == MACH_TOSHIBA_RBTX4937)
-		switch ((unsigned long)__raw_readq(&tx4938_ccfgptr->ccfg) &
-			TX4938_CCFG_PCIDIVMODE_MASK) {
-		case TX4938_CCFG_PCIDIVMODE_8:
-		case TX4938_CCFG_PCIDIVMODE_4:
-			txx9_cpu_clock = 266666666;	/* 266MHz */
-			break;
-		case TX4938_CCFG_PCIDIVMODE_9:
-		case TX4938_CCFG_PCIDIVMODE_4_5:
-			txx9_cpu_clock = 300000000;	/* 300MHz */
-			break;
-		default:
-			txx9_cpu_clock = 333333333;	/* 333MHz */
-		}
-	else
-		switch ((unsigned long)__raw_readq(&tx4927_ccfgptr->ccfg) &
-			TX4927_CCFG_PCIDIVMODE_MASK) {
-		case TX4927_CCFG_PCIDIVMODE_2_5:
-		case TX4927_CCFG_PCIDIVMODE_5:
-			txx9_cpu_clock = 166666666;	/* 166MHz */
-			break;
-		default:
-			txx9_cpu_clock = 200000000;	/* 200MHz */
-		}
-
-	/* change default value to udelay/mdelay take reasonable time */
-	loops_per_jiffy = txx9_cpu_clock / HZ / 2;
+	switch ((unsigned long)__raw_readq(&tx4938_ccfgptr->ccfg) &
+		TX4938_CCFG_PCIDIVMODE_MASK) {
+	case TX4938_CCFG_PCIDIVMODE_8:
+	case TX4938_CCFG_PCIDIVMODE_4:
+		txx9_cpu_clock = 266666666;	/* 266MHz */
+		break;
+	case TX4938_CCFG_PCIDIVMODE_9:
+	case TX4938_CCFG_PCIDIVMODE_4_5:
+		txx9_cpu_clock = 300000000;	/* 300MHz */
+		break;
+	default:
+		txx9_cpu_clock = 333333333;	/* 333MHz */
+	}
 
-	mips_hpt_frequency = txx9_cpu_clock / 2;
-	if (____raw_readq(&tx4927_ccfgptr->ccfg) & TX4927_CCFG_TINTDIS)
-		txx9_clockevent_init(TX4927_TMR_REG(0) & 0xfffffffffULL,
-				     TXX9_IRQ_BASE + 17,
-				     50000000);
+	rbtx49x7_common_time_init();
 }
 
 static int __init toshiba_rbtx4927_rtc_init(void)
@@ -434,7 +446,7 @@ struct txx9_board_vec rbtx4937_vec __initdata = {
 	.prom_init = rbtx4927_prom_init,
 	.mem_setup = rbtx4927_mem_setup,
 	.irq_setup = rbtx4927_irq_setup,
-	.time_init = rbtx4927_time_init,
+	.time_init = rbtx4937_time_init,
 	.device_init = rbtx4927_device_init,
 	.arch_init = rbtx4937_arch_init,
 #ifdef CONFIG_PCI

commit a38c47519832f22659244fd8437722b7aaa67f9a
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Sun Jul 13 20:01:04 2008 +0900

    [MIPS] separate rbtx4927_arch_init() and rbtx4937_arch_init()
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Acked-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index bba6ef9db068..b4c4178607c4 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -170,13 +170,16 @@ static void __init tx4937_pci_setup(void)
 
 static void __init rbtx4927_arch_init(void)
 {
-	if (mips_machtype == MACH_TOSHIBA_RBTX4937)
-		tx4937_pci_setup();
-	else
-		tx4927_pci_setup();
+	tx4927_pci_setup();
+}
+
+static void __init rbtx4937_arch_init(void)
+{
+	tx4937_pci_setup();
 }
 #else
 #define rbtx4927_arch_init NULL
+#define rbtx4937_arch_init NULL
 #endif /* CONFIG_PCI */
 
 static void __noreturn wait_forever(void)
@@ -433,7 +436,7 @@ struct txx9_board_vec rbtx4937_vec __initdata = {
 	.irq_setup = rbtx4927_irq_setup,
 	.time_init = rbtx4927_time_init,
 	.device_init = rbtx4927_device_init,
-	.arch_init = rbtx4927_arch_init,
+	.arch_init = rbtx4937_arch_init,
 #ifdef CONFIG_PCI
 	.pci_map_irq = rbtx4927_pci_map_irq,
 #endif

commit a00fb6694f15b3bccf105f34f10bbcb6b47af67c
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Sun Jul 13 19:54:08 2008 +0900

    [MIPS] txx9_cpu_clock setup move to rbtx4927_time_init()
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Acked-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index c3566c39c26c..bba6ef9db068 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -252,55 +252,6 @@ static void __init rbtx4927_mem_setup(void)
 	set_io_port_base(KSEG1 + RBTX4927_ISA_IO_OFFSET);
 #endif
 
-	/*
-	   * ASSUMPTION: PCIDIVMODE is configured for PCI 33MHz or 66MHz.
-	   *
-	   * For TX4927:
-	   * PCIDIVMODE[12:11]'s initial value is given by S9[4:3] (ON:0, OFF:1).
-	   * CPU 166MHz: PCI 66MHz : PCIDIVMODE: 00 (1/2.5)
-	   * CPU 200MHz: PCI 66MHz : PCIDIVMODE: 01 (1/3)
-	   * CPU 166MHz: PCI 33MHz : PCIDIVMODE: 10 (1/5)
-	   * CPU 200MHz: PCI 33MHz : PCIDIVMODE: 11 (1/6)
-	   * i.e. S9[3]: ON (83MHz), OFF (100MHz)
-	   *
-	   * For TX4937:
-	   * PCIDIVMODE[12:11]'s initial value is given by S1[5:4] (ON:0, OFF:1)
-	   * PCIDIVMODE[10] is 0.
-	   * CPU 266MHz: PCI 33MHz : PCIDIVMODE: 000 (1/8)
-	   * CPU 266MHz: PCI 66MHz : PCIDIVMODE: 001 (1/4)
-	   * CPU 300MHz: PCI 33MHz : PCIDIVMODE: 010 (1/9)
-	   * CPU 300MHz: PCI 66MHz : PCIDIVMODE: 011 (1/4.5)
-	   * CPU 333MHz: PCI 33MHz : PCIDIVMODE: 100 (1/10)
-	   * CPU 333MHz: PCI 66MHz : PCIDIVMODE: 101 (1/5)
-	   *
-	 */
-	if (mips_machtype == MACH_TOSHIBA_RBTX4937)
-		switch ((unsigned long)__raw_readq(&tx4938_ccfgptr->ccfg) &
-			TX4938_CCFG_PCIDIVMODE_MASK) {
-		case TX4938_CCFG_PCIDIVMODE_8:
-		case TX4938_CCFG_PCIDIVMODE_4:
-			txx9_cpu_clock = 266666666;	/* 266MHz */
-			break;
-		case TX4938_CCFG_PCIDIVMODE_9:
-		case TX4938_CCFG_PCIDIVMODE_4_5:
-			txx9_cpu_clock = 300000000;	/* 300MHz */
-			break;
-		default:
-			txx9_cpu_clock = 333333333;	/* 333MHz */
-		}
-	else
-		switch ((unsigned long)__raw_readq(&tx4927_ccfgptr->ccfg) &
-			TX4927_CCFG_PCIDIVMODE_MASK) {
-		case TX4927_CCFG_PCIDIVMODE_2_5:
-		case TX4927_CCFG_PCIDIVMODE_5:
-			txx9_cpu_clock = 166666666;	/* 166MHz */
-			break;
-		default:
-			txx9_cpu_clock = 200000000;	/* 200MHz */
-		}
-	/* change default value to udelay/mdelay take reasonable time */
-	loops_per_jiffy = txx9_cpu_clock / HZ / 2;
-
 	/* CCFG */
 	/* do reset on watchdog */
 	tx4927_ccfg_set(TX4927_CCFG_WR);
@@ -349,6 +300,55 @@ static void __init rbtx4927_mem_setup(void)
 
 static void __init rbtx4927_time_init(void)
 {
+	/*
+	 * ASSUMPTION: PCIDIVMODE is configured for PCI 33MHz or 66MHz.
+	 *
+	 * For TX4927:
+	 * PCIDIVMODE[12:11]'s initial value is given by S9[4:3] (ON:0, OFF:1).
+	 * CPU 166MHz: PCI 66MHz : PCIDIVMODE: 00 (1/2.5)
+	 * CPU 200MHz: PCI 66MHz : PCIDIVMODE: 01 (1/3)
+	 * CPU 166MHz: PCI 33MHz : PCIDIVMODE: 10 (1/5)
+	 * CPU 200MHz: PCI 33MHz : PCIDIVMODE: 11 (1/6)
+	 * i.e. S9[3]: ON (83MHz), OFF (100MHz)
+	 *
+	 * For TX4937:
+	 * PCIDIVMODE[12:11]'s initial value is given by S1[5:4] (ON:0, OFF:1)
+	 * PCIDIVMODE[10] is 0.
+	 * CPU 266MHz: PCI 33MHz : PCIDIVMODE: 000 (1/8)
+	 * CPU 266MHz: PCI 66MHz : PCIDIVMODE: 001 (1/4)
+	 * CPU 300MHz: PCI 33MHz : PCIDIVMODE: 010 (1/9)
+	 * CPU 300MHz: PCI 66MHz : PCIDIVMODE: 011 (1/4.5)
+	 * CPU 333MHz: PCI 33MHz : PCIDIVMODE: 100 (1/10)
+	 * CPU 333MHz: PCI 66MHz : PCIDIVMODE: 101 (1/5)
+	 */
+	if (mips_machtype == MACH_TOSHIBA_RBTX4937)
+		switch ((unsigned long)__raw_readq(&tx4938_ccfgptr->ccfg) &
+			TX4938_CCFG_PCIDIVMODE_MASK) {
+		case TX4938_CCFG_PCIDIVMODE_8:
+		case TX4938_CCFG_PCIDIVMODE_4:
+			txx9_cpu_clock = 266666666;	/* 266MHz */
+			break;
+		case TX4938_CCFG_PCIDIVMODE_9:
+		case TX4938_CCFG_PCIDIVMODE_4_5:
+			txx9_cpu_clock = 300000000;	/* 300MHz */
+			break;
+		default:
+			txx9_cpu_clock = 333333333;	/* 333MHz */
+		}
+	else
+		switch ((unsigned long)__raw_readq(&tx4927_ccfgptr->ccfg) &
+			TX4927_CCFG_PCIDIVMODE_MASK) {
+		case TX4927_CCFG_PCIDIVMODE_2_5:
+		case TX4927_CCFG_PCIDIVMODE_5:
+			txx9_cpu_clock = 166666666;	/* 166MHz */
+			break;
+		default:
+			txx9_cpu_clock = 200000000;	/* 200MHz */
+		}
+
+	/* change default value to udelay/mdelay take reasonable time */
+	loops_per_jiffy = txx9_cpu_clock / HZ / 2;
+
 	mips_hpt_frequency = txx9_cpu_clock / 2;
 	if (____raw_readq(&tx4927_ccfgptr->ccfg) & TX4927_CCFG_TINTDIS)
 		txx9_clockevent_init(TX4927_TMR_REG(0) & 0xfffffffffULL,

commit edcaf1a6a77315562e9781245cc8e028c9a921dc
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 23:27:54 2008 +0900

    [MIPS] TXx9: Make single kernel can support multiple boards
    
    Make single kernel can be used on RBTX4927/37/38.  Also make
    some SoC-specific code independent from board-specific code.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index 86b870abc319..c3566c39c26c 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -49,7 +49,6 @@
 #include <linux/interrupt.h>
 #include <linux/pm.h>
 #include <linux/platform_device.h>
-#include <linux/clk.h>
 #include <linux/delay.h>
 
 #include <asm/bootinfo.h>
@@ -76,8 +75,6 @@ char *prom_getcmdline(void);
 
 static int tx4927_ccfg_toeon = 1;
 
-char *toshiba_name = "";
-
 #ifdef CONFIG_PCI
 static void __init tx4927_pci_setup(void)
 {
@@ -171,15 +168,15 @@ static void __init tx4937_pci_setup(void)
 	}
 }
 
-static int __init rbtx4927_arch_init(void)
+static void __init rbtx4927_arch_init(void)
 {
 	if (mips_machtype == MACH_TOSHIBA_RBTX4937)
 		tx4937_pci_setup();
 	else
 		tx4927_pci_setup();
-	return 0;
 }
-arch_initcall(rbtx4927_arch_init);
+#else
+#define rbtx4927_arch_init NULL
 #endif /* CONFIG_PCI */
 
 static void __noreturn wait_forever(void)
@@ -223,14 +220,12 @@ void toshiba_rbtx4927_power_off(void)
 	/* no return */
 }
 
-void __init plat_mem_setup(void)
+static void __init rbtx4927_mem_setup(void)
 {
 	int i;
 	u32 cp0_config;
 	char *argptr;
 
-	printk("CPU is %s\n", toshiba_name);
-
 	/* f/w leaves this on at startup */
 	clear_c0_status(ST0_ERL);
 
@@ -323,7 +318,7 @@ void __init plat_mem_setup(void)
 			req.iotype = UPIO_MEM;
 			req.membase = (char *)(0xff1ff300 + i * 0x100);
 			req.mapbase = 0xff1ff300 + i * 0x100;
-			req.irq = TX4927_IRQ_PIC_BEG + 8 + i;
+			req.irq = TXX9_IRQ_BASE + TX4927_IR_SIO(i);
 			req.flags |= UPF_BUGGY_UART /*HAVE_CTS_LINE*/;
 			req.uartclk = 50000000;
 			early_serial_txx9_setup(&req);
@@ -352,7 +347,7 @@ void __init plat_mem_setup(void)
 #endif
 }
 
-void __init plat_time_init(void)
+static void __init rbtx4927_time_init(void)
 {
 	mips_hpt_frequency = txx9_cpu_clock / 2;
 	if (____raw_readq(&tx4927_ccfgptr->ccfg) & TX4927_CCFG_TINTDIS)
@@ -372,7 +367,6 @@ static int __init toshiba_rbtx4927_rtc_init(void)
 		platform_device_register_simple("rtc-ds1742", -1, &res, 1);
 	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
 }
-device_initcall(toshiba_rbtx4927_rtc_init);
 
 static int __init rbtx4927_ne_init(void)
 {
@@ -391,7 +385,6 @@ static int __init rbtx4927_ne_init(void)
 						res, ARRAY_SIZE(res));
 	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
 }
-device_initcall(rbtx4927_ne_init);
 
 /* Watchdog support */
 
@@ -411,36 +404,37 @@ static int __init rbtx4927_wdt_init(void)
 {
 	return txx9_wdt_init(TX4927_TMR_REG(2) & 0xfffffffffULL);
 }
-device_initcall(rbtx4927_wdt_init);
-
-/* Minimum CLK support */
-
-struct clk *clk_get(struct device *dev, const char *id)
-{
-	if (!strcmp(id, "imbus_clk"))
-		return (struct clk *)50000000;
-	return ERR_PTR(-ENOENT);
-}
-EXPORT_SYMBOL(clk_get);
-
-int clk_enable(struct clk *clk)
-{
-	return 0;
-}
-EXPORT_SYMBOL(clk_enable);
 
-void clk_disable(struct clk *clk)
+static void __init rbtx4927_device_init(void)
 {
+	toshiba_rbtx4927_rtc_init();
+	rbtx4927_ne_init();
+	rbtx4927_wdt_init();
 }
-EXPORT_SYMBOL(clk_disable);
 
-unsigned long clk_get_rate(struct clk *clk)
-{
-	return (unsigned long)clk;
-}
-EXPORT_SYMBOL(clk_get_rate);
-
-void clk_put(struct clk *clk)
-{
-}
-EXPORT_SYMBOL(clk_put);
+struct txx9_board_vec rbtx4927_vec __initdata = {
+	.type = MACH_TOSHIBA_RBTX4927,
+	.system = "Toshiba RBTX4927",
+	.prom_init = rbtx4927_prom_init,
+	.mem_setup = rbtx4927_mem_setup,
+	.irq_setup = rbtx4927_irq_setup,
+	.time_init = rbtx4927_time_init,
+	.device_init = rbtx4927_device_init,
+	.arch_init = rbtx4927_arch_init,
+#ifdef CONFIG_PCI
+	.pci_map_irq = rbtx4927_pci_map_irq,
+#endif
+};
+struct txx9_board_vec rbtx4937_vec __initdata = {
+	.type = MACH_TOSHIBA_RBTX4937,
+	.system = "Toshiba RBTX4937",
+	.prom_init = rbtx4927_prom_init,
+	.mem_setup = rbtx4927_mem_setup,
+	.irq_setup = rbtx4927_irq_setup,
+	.time_init = rbtx4927_time_init,
+	.device_init = rbtx4927_device_init,
+	.arch_init = rbtx4927_arch_init,
+#ifdef CONFIG_PCI
+	.pci_map_irq = rbtx4927_pci_map_irq,
+#endif
+};

commit 89d63fe179520b11f54de1f26755b7444c79e73a
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 00:33:08 2008 +0900

    [MIPS] TXx9: Reorganize PCI code
    
    Split out PCIC dependent code and SoC dependent code from board dependent
    code.  Now TX4927 PCIC code is independent from TX4927/TX4938 SoC code.
    Also fix some build problems on CONFIG_PCI=n.
    
    As a bonus, "FPCIB0 Backplane Support" is available for all TX39/TX49 boards
    and PCI66 support is available for all TX49 boards.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
index df1b6e99b666..86b870abc319 100644
--- a/arch/mips/txx9/rbtx4927/setup.c
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -47,10 +47,10 @@
 #include <linux/types.h>
 #include <linux/ioport.h>
 #include <linux/interrupt.h>
-#include <linux/pci.h>
 #include <linux/pm.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
+#include <linux/delay.h>
 
 #include <asm/bootinfo.h>
 #include <asm/io.h>
@@ -58,10 +58,10 @@
 #include <asm/reboot.h>
 #include <asm/time.h>
 #include <asm/txx9tmr.h>
-#ifdef CONFIG_TOSHIBA_FPCIB0
-#include <asm/txx9/smsc_fdc37m81x.h>
-#endif
+#include <asm/txx9/generic.h>
+#include <asm/txx9/pci.h>
 #include <asm/txx9/rbtx4927.h>
+#include <asm/txx9/tx4938.h>	/* for TX4937 */
 #ifdef CONFIG_SERIAL_TXX9
 #include <linux/serial_core.h>
 #endif
@@ -70,356 +70,116 @@
 extern void toshiba_rbtx4927_restart(char *command);
 extern void toshiba_rbtx4927_halt(void);
 extern void toshiba_rbtx4927_power_off(void);
-
-int tx4927_using_backplane = 0;
-
 extern void toshiba_rbtx4927_irq_setup(void);
 
 char *prom_getcmdline(void);
 
-#ifdef CONFIG_PCI
-#undef TX4927_SUPPORT_COMMAND_IO
-#undef  TX4927_SUPPORT_PCI_66
-int tx4927_cpu_clock = 100000000;	/* 100MHz */
-unsigned long mips_pci_io_base;
-unsigned long mips_pci_io_size;
-unsigned long mips_pci_mem_base;
-unsigned long mips_pci_mem_size;
-/* for legacy I/O, PCI I/O PCI Bus address must be 0 */
-unsigned long mips_pci_io_pciaddr = 0;
-unsigned long mips_memory_upper;
 static int tx4927_ccfg_toeon = 1;
-static int tx4927_pcic_trdyto = 0;	/* default: disabled */
-unsigned long tx4927_ce_base[8];
-int tx4927_pci66 = 0;		/* 0:auto */
-#endif
 
 char *toshiba_name = "";
 
 #ifdef CONFIG_PCI
-extern struct pci_controller tx4927_controller;
-
-static struct pci_dev *fake_pci_dev(struct pci_controller *hose,
-				    int top_bus, int busnr, int devfn)
+static void __init tx4927_pci_setup(void)
 {
-	static struct pci_dev dev;
-	static struct pci_bus bus;
-
-	dev.sysdata = (void *)hose;
-	dev.devfn = devfn;
-	bus.number = busnr;
-	bus.ops = hose->pci_ops;
-	bus.parent = NULL;
-	dev.bus = &bus;
-
-	return &dev;
-}
-
-#define EARLY_PCI_OP(rw, size, type)                                    \
-static int early_##rw##_config_##size(struct pci_controller *hose,      \
-        int top_bus, int bus, int devfn, int offset, type value)        \
-{                                                                       \
-        return pci_##rw##_config_##size(                                \
-                fake_pci_dev(hose, top_bus, bus, devfn),                \
-                offset, value);                                         \
+	int extarb = !(__raw_readq(&tx4927_ccfgptr->ccfg) & TX4927_CCFG_PCIARB);
+	struct pci_controller *c = &txx9_primary_pcic;
+
+	register_pci_controller(c);
+
+	if (__raw_readq(&tx4927_ccfgptr->ccfg) & TX4927_CCFG_PCI66)
+		txx9_pci_option =
+			(txx9_pci_option & ~TXX9_PCI_OPT_CLK_MASK) |
+			TXX9_PCI_OPT_CLK_66; /* already configured */
+
+	/* Reset PCI Bus */
+	writeb(1, rbtx4927_pcireset_addr);
+	/* Reset PCIC */
+	txx9_set64(&tx4927_ccfgptr->clkctr, TX4927_CLKCTR_PCIRST);
+	if ((txx9_pci_option & TXX9_PCI_OPT_CLK_MASK) ==
+	    TXX9_PCI_OPT_CLK_66)
+		tx4927_pciclk66_setup();
+	mdelay(10);
+	/* clear PCIC reset */
+	txx9_clear64(&tx4927_ccfgptr->clkctr, TX4927_CLKCTR_PCIRST);
+	writeb(0, rbtx4927_pcireset_addr);
+	iob();
+
+	tx4927_report_pciclk();
+	tx4927_pcic_setup(tx4927_pcicptr, c, extarb);
+	if ((txx9_pci_option & TXX9_PCI_OPT_CLK_MASK) ==
+	    TXX9_PCI_OPT_CLK_AUTO &&
+	    txx9_pci66_check(c, 0, 0)) {
+		/* Reset PCI Bus */
+		writeb(1, rbtx4927_pcireset_addr);
+		/* Reset PCIC */
+		txx9_set64(&tx4927_ccfgptr->clkctr, TX4927_CLKCTR_PCIRST);
+		tx4927_pciclk66_setup();
+		mdelay(10);
+		/* clear PCIC reset */
+		txx9_clear64(&tx4927_ccfgptr->clkctr, TX4927_CLKCTR_PCIRST);
+		writeb(0, rbtx4927_pcireset_addr);
+		iob();
+		/* Reinitialize PCIC */
+		tx4927_report_pciclk();
+		tx4927_pcic_setup(tx4927_pcicptr, c, extarb);
+	}
 }
 
-EARLY_PCI_OP(read, byte, u8 *)
-EARLY_PCI_OP(read, dword, u32 *)
-EARLY_PCI_OP(write, byte, u8)
-EARLY_PCI_OP(write, dword, u32)
-
-static int __init tx4927_pcibios_init(void)
+static void __init tx4937_pci_setup(void)
 {
-	unsigned int id;
-	u32 pci_devfn;
-	int devfn_start = 0;
-	int devfn_stop = 0xff;
-	int busno = 0; /* One bus on the Toshiba */
-	struct pci_controller *hose = &tx4927_controller;
-
-	for (pci_devfn = devfn_start; pci_devfn < devfn_stop; pci_devfn++) {
-		early_read_config_dword(hose, busno, busno, pci_devfn,
-					PCI_VENDOR_ID, &id);
-
-		if (id == 0xffffffff) {
-			continue;
-		}
-
-		if (id == 0x94601055) {
-			u8 v08_64;
-			u32 v32_b0;
-			u8 v08_e1;
-
-			early_read_config_byte(hose, busno, busno,
-					       pci_devfn, 0x64, &v08_64);
-			early_read_config_dword(hose, busno, busno,
-						pci_devfn, 0xb0, &v32_b0);
-			early_read_config_byte(hose, busno, busno,
-					       pci_devfn, 0xe1, &v08_e1);
-
-			/* serial irq control */
-			v08_64 = 0xd0;
-
-			/* serial irq pin */
-			v32_b0 |= 0x00010000;
-
-			/* ide irq on isa14 */
-			v08_e1 &= 0xf0;
-			v08_e1 |= 0x0d;
-
-			early_write_config_byte(hose, busno, busno,
-						pci_devfn, 0x64, v08_64);
-			early_write_config_dword(hose, busno, busno,
-						 pci_devfn, 0xb0, v32_b0);
-			early_write_config_byte(hose, busno, busno,
-						pci_devfn, 0xe1, v08_e1);
-		}
-
-		if (id == 0x91301055) {
-			u8 v08_04;
-			u8 v08_09;
-			u8 v08_41;
-			u8 v08_43;
-			u8 v08_5c;
-
-			early_read_config_byte(hose, busno, busno,
-					       pci_devfn, 0x04, &v08_04);
-			early_read_config_byte(hose, busno, busno,
-					       pci_devfn, 0x09, &v08_09);
-			early_read_config_byte(hose, busno, busno,
-					       pci_devfn, 0x41, &v08_41);
-			early_read_config_byte(hose, busno, busno,
-					       pci_devfn, 0x43, &v08_43);
-			early_read_config_byte(hose, busno, busno,
-					       pci_devfn, 0x5c, &v08_5c);
-
-			/* enable ide master/io */
-			v08_04 |= (PCI_COMMAND_MASTER | PCI_COMMAND_IO);
-
-			/* enable ide native mode */
-			v08_09 |= 0x05;
-
-			/* enable primary ide */
-			v08_41 |= 0x80;
-
-			/* enable secondary ide */
-			v08_43 |= 0x80;
-
-			/*
-			 * !!! DO NOT REMOVE THIS COMMENT IT IS REQUIRED BY SMSC !!!
-			 *
-			 * This line of code is intended to provide the user with a work
-			 * around solution to the anomalies cited in SMSC's anomaly sheet
-			 * entitled, "SLC90E66 Functional Rev.J_0.1 Anomalies"".
-			 *
-			 * !!! DO NOT REMOVE THIS COMMENT IT IS REQUIRED BY SMSC !!!
-			 */
-			v08_5c |= 0x01;
-
-			early_write_config_byte(hose, busno, busno,
-						pci_devfn, 0x5c, v08_5c);
-			early_write_config_byte(hose, busno, busno,
-						pci_devfn, 0x04, v08_04);
-			early_write_config_byte(hose, busno, busno,
-						pci_devfn, 0x09, v08_09);
-			early_write_config_byte(hose, busno, busno,
-						pci_devfn, 0x41, v08_41);
-			early_write_config_byte(hose, busno, busno,
-						pci_devfn, 0x43, v08_43);
-		}
-
+	int extarb = !(__raw_readq(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCIARB);
+	struct pci_controller *c = &txx9_primary_pcic;
+
+	register_pci_controller(c);
+
+	if (__raw_readq(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCI66)
+		txx9_pci_option =
+			(txx9_pci_option & ~TXX9_PCI_OPT_CLK_MASK) |
+			TXX9_PCI_OPT_CLK_66; /* already configured */
+
+	/* Reset PCI Bus */
+	writeb(1, rbtx4927_pcireset_addr);
+	/* Reset PCIC */
+	txx9_set64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIRST);
+	if ((txx9_pci_option & TXX9_PCI_OPT_CLK_MASK) ==
+	    TXX9_PCI_OPT_CLK_66)
+		tx4938_pciclk66_setup();
+	mdelay(10);
+	/* clear PCIC reset */
+	txx9_clear64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIRST);
+	writeb(0, rbtx4927_pcireset_addr);
+	iob();
+
+	tx4938_report_pciclk();
+	tx4927_pcic_setup(tx4938_pcicptr, c, extarb);
+	if ((txx9_pci_option & TXX9_PCI_OPT_CLK_MASK) ==
+	    TXX9_PCI_OPT_CLK_AUTO &&
+	    txx9_pci66_check(c, 0, 0)) {
+		/* Reset PCI Bus */
+		writeb(1, rbtx4927_pcireset_addr);
+		/* Reset PCIC */
+		txx9_set64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIRST);
+		tx4938_pciclk66_setup();
+		mdelay(10);
+		/* clear PCIC reset */
+		txx9_clear64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIRST);
+		writeb(0, rbtx4927_pcireset_addr);
+		iob();
+		/* Reinitialize PCIC */
+		tx4938_report_pciclk();
+		tx4927_pcic_setup(tx4938_pcicptr, c, extarb);
 	}
-
-	register_pci_controller(&tx4927_controller);
-	return 0;
 }
 
-arch_initcall(tx4927_pcibios_init);
-
-extern struct resource pci_io_resource;
-extern struct resource pci_mem_resource;
-
-void __init tx4927_pci_setup(void)
+static int __init rbtx4927_arch_init(void)
 {
-	static int called = 0;
-	extern unsigned int tx4927_get_mem_size(void);
-
-	mips_memory_upper = tx4927_get_mem_size() << 20;
-	mips_memory_upper += KSEG0;
-	mips_pci_io_base = TX4927_PCIIO;
-	mips_pci_io_size = TX4927_PCIIO_SIZE;
-	mips_pci_mem_base = TX4927_PCIMEM;
-	mips_pci_mem_size = TX4927_PCIMEM_SIZE;
-
-	if (!called) {
-		printk
-		    ("%s PCIC -- DID:%04x VID:%04x RID:%02x Arbiter:%s\n",
-		     toshiba_name,
-		     (unsigned short) (tx4927_pcicptr->pciid >> 16),
-		     (unsigned short) (tx4927_pcicptr->pciid & 0xffff),
-		     (unsigned short) (tx4927_pcicptr->pciccrev & 0xff),
-		     (!(tx4927_ccfgptr->
-			ccfg & TX4927_CCFG_PCIXARB)) ? "External" :
-		     "Internal");
-		called = 1;
-	}
-	printk("%s PCIC --%s PCICLK:", toshiba_name,
-	       (tx4927_ccfgptr->ccfg & TX4927_CCFG_PCI66) ? " PCI66" : "");
-	if (tx4927_ccfgptr->pcfg & TX4927_PCFG_PCICLKEN_ALL) {
-		int pciclk = 0;
-		if (mips_machtype == MACH_TOSHIBA_RBTX4937)
-			switch ((unsigned long) tx4927_ccfgptr->
-				ccfg & TX4937_CCFG_PCIDIVMODE_MASK) {
-			case TX4937_CCFG_PCIDIVMODE_4:
-				pciclk = tx4927_cpu_clock / 4;
-				break;
-			case TX4937_CCFG_PCIDIVMODE_4_5:
-				pciclk = tx4927_cpu_clock * 2 / 9;
-				break;
-			case TX4937_CCFG_PCIDIVMODE_5:
-				pciclk = tx4927_cpu_clock / 5;
-				break;
-			case TX4937_CCFG_PCIDIVMODE_5_5:
-				pciclk = tx4927_cpu_clock * 2 / 11;
-				break;
-			case TX4937_CCFG_PCIDIVMODE_8:
-				pciclk = tx4927_cpu_clock / 8;
-				break;
-			case TX4937_CCFG_PCIDIVMODE_9:
-				pciclk = tx4927_cpu_clock / 9;
-				break;
-			case TX4937_CCFG_PCIDIVMODE_10:
-				pciclk = tx4927_cpu_clock / 10;
-				break;
-			case TX4937_CCFG_PCIDIVMODE_11:
-				pciclk = tx4927_cpu_clock / 11;
-				break;
-			}
-
-		else
-			switch ((unsigned long) tx4927_ccfgptr->
-				ccfg & TX4927_CCFG_PCIDIVMODE_MASK) {
-			case TX4927_CCFG_PCIDIVMODE_2_5:
-				pciclk = tx4927_cpu_clock * 2 / 5;
-				break;
-			case TX4927_CCFG_PCIDIVMODE_3:
-				pciclk = tx4927_cpu_clock / 3;
-				break;
-			case TX4927_CCFG_PCIDIVMODE_5:
-				pciclk = tx4927_cpu_clock / 5;
-				break;
-			case TX4927_CCFG_PCIDIVMODE_6:
-				pciclk = tx4927_cpu_clock / 6;
-				break;
-			}
-
-		printk("Internal(%dMHz)", pciclk / 1000000);
-	} else
-		printk("External");
-	printk("\n");
-
-	/* GB->PCI mappings */
-	tx4927_pcicptr->g2piomask = (mips_pci_io_size - 1) >> 4;
-	tx4927_pcicptr->g2piogbase = mips_pci_io_base |
-#ifdef __BIG_ENDIAN
-	    TX4927_PCIC_G2PIOGBASE_ECHG
-#else
-	    TX4927_PCIC_G2PIOGBASE_BSDIS
-#endif
-	    ;
-
-	tx4927_pcicptr->g2piopbase = 0;
-
-	tx4927_pcicptr->g2pmmask[0] = (mips_pci_mem_size - 1) >> 4;
-	tx4927_pcicptr->g2pmgbase[0] = mips_pci_mem_base |
-#ifdef __BIG_ENDIAN
-	    TX4927_PCIC_G2PMnGBASE_ECHG
-#else
-	    TX4927_PCIC_G2PMnGBASE_BSDIS
-#endif
-	    ;
-	tx4927_pcicptr->g2pmpbase[0] = mips_pci_mem_base;
-
-	tx4927_pcicptr->g2pmmask[1] = 0;
-	tx4927_pcicptr->g2pmgbase[1] = 0;
-	tx4927_pcicptr->g2pmpbase[1] = 0;
-	tx4927_pcicptr->g2pmmask[2] = 0;
-	tx4927_pcicptr->g2pmgbase[2] = 0;
-	tx4927_pcicptr->g2pmpbase[2] = 0;
-
-
-	/* PCI->GB mappings (I/O 256B) */
-	tx4927_pcicptr->p2giopbase = 0;	/* 256B */
-
-	/* PCI->GB mappings (MEM 512MB) M0 gets all of memory */
-	tx4927_pcicptr->p2gm0plbase = 0;
-	tx4927_pcicptr->p2gm0pubase = 0;
-	tx4927_pcicptr->p2gmgbase[0] = 0 | TX4927_PCIC_P2GMnGBASE_TMEMEN |
-#ifdef __BIG_ENDIAN
-	    TX4927_PCIC_P2GMnGBASE_TECHG
-#else
-	    TX4927_PCIC_P2GMnGBASE_TBSDIS
-#endif
-	    ;
-
-	/* PCI->GB mappings (MEM 16MB) -not used */
-	tx4927_pcicptr->p2gm1plbase = 0xffffffff;
-	tx4927_pcicptr->p2gm1pubase = 0xffffffff;
-	tx4927_pcicptr->p2gmgbase[1] = 0;
-
-	/* PCI->GB mappings (MEM 1MB) -not used */
-	tx4927_pcicptr->p2gm2pbase = 0xffffffff;
-	tx4927_pcicptr->p2gmgbase[2] = 0;
-
-
-	/* Enable Initiator Memory 0 Space, I/O Space, Config */
-	tx4927_pcicptr->pciccfg &= TX4927_PCIC_PCICCFG_LBWC_MASK;
-	tx4927_pcicptr->pciccfg |=
-	    TX4927_PCIC_PCICCFG_IMSE0 | TX4927_PCIC_PCICCFG_IISE |
-	    TX4927_PCIC_PCICCFG_ICAE | TX4927_PCIC_PCICCFG_ATR;
-
-
-	/* Do not use MEMMUL, MEMINF: YMFPCI card causes M_ABORT. */
-	tx4927_pcicptr->pcicfg1 = 0;
-
-	if (tx4927_pcic_trdyto >= 0) {
-		tx4927_pcicptr->g2ptocnt &= ~0xff;
-		tx4927_pcicptr->g2ptocnt |= (tx4927_pcic_trdyto & 0xff);
-	}
-
-	/* Clear All Local Bus Status */
-	tx4927_pcicptr->pcicstatus = TX4927_PCIC_PCICSTATUS_ALL;
-	/* Enable All Local Bus Interrupts */
-	tx4927_pcicptr->pcicmask = TX4927_PCIC_PCICSTATUS_ALL;
-	/* Clear All Initiator Status */
-	tx4927_pcicptr->g2pstatus = TX4927_PCIC_G2PSTATUS_ALL;
-	/* Enable All Initiator Interrupts */
-	tx4927_pcicptr->g2pmask = TX4927_PCIC_G2PSTATUS_ALL;
-	/* Clear All PCI Status Error */
-	tx4927_pcicptr->pcistatus =
-	    (tx4927_pcicptr->pcistatus & 0x0000ffff) |
-	    (TX4927_PCIC_PCISTATUS_ALL << 16);
-	/* Enable All PCI Status Error Interrupts */
-	tx4927_pcicptr->pcimask = TX4927_PCIC_PCISTATUS_ALL;
-
-	/* PCIC Int => IRC IRQ16 */
-	tx4927_pcicptr->pcicfg2 =
-	    (tx4927_pcicptr->pcicfg2 & 0xffffff00) | TX4927_IR_PCIC;
-
-	if (!(tx4927_ccfgptr->ccfg & TX4927_CCFG_PCIXARB)) {
-		/* XXX */
-	} else {
-		/* Reset Bus Arbiter */
-		tx4927_pcicptr->pbacfg = TX4927_PCIC_PBACFG_RPBA;
-		/* Enable Bus Arbiter */
-		tx4927_pcicptr->pbacfg = TX4927_PCIC_PBACFG_PBAEN;
-	}
-
-	tx4927_pcicptr->pcistatus = PCI_COMMAND_MASTER |
-	    PCI_COMMAND_MEMORY |
-	    PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+	if (mips_machtype == MACH_TOSHIBA_RBTX4937)
+		tx4937_pci_setup();
+	else
+		tx4927_pci_setup();
+	return 0;
 }
+arch_initcall(rbtx4927_arch_init);
 #endif /* CONFIG_PCI */
 
 static void __noreturn wait_forever(void)
@@ -479,8 +239,6 @@ void __init plat_mem_setup(void)
 	cp0_config = cp0_config & ~(TX49_CONF_IC | TX49_CONF_DC);
 	write_c0_config(cp0_config);
 
-	set_io_port_base(KSEG1 + TBTX4927_ISA_IO_OFFSET);
-
 	ioport_resource.end = 0xffffffff;
 	iomem_resource.end = 0xffffffff;
 
@@ -492,8 +250,13 @@ void __init plat_mem_setup(void)
 		txx9_tmr_init(TX4927_TMR_REG(0) & 0xfffffffffULL);
 
 #ifdef CONFIG_PCI
+	txx9_alloc_pci_controller(&txx9_primary_pcic,
+				  RBTX4927_PCIMEM, RBTX4927_PCIMEM_SIZE,
+				  RBTX4927_PCIIO, RBTX4927_PCIIO_SIZE);
+#else
+	set_io_port_base(KSEG1 + RBTX4927_ISA_IO_OFFSET);
+#endif
 
-	/* PCIC */
 	/*
 	   * ASSUMPTION: PCIDIVMODE is configured for PCI 33MHz or 66MHz.
 	   *
@@ -517,58 +280,38 @@ void __init plat_mem_setup(void)
 	   *
 	 */
 	if (mips_machtype == MACH_TOSHIBA_RBTX4937)
-		switch ((unsigned long)tx4927_ccfgptr->
-			ccfg & TX4937_CCFG_PCIDIVMODE_MASK) {
-		case TX4937_CCFG_PCIDIVMODE_8:
-		case TX4937_CCFG_PCIDIVMODE_4:
-			tx4927_cpu_clock = 266666666;	/* 266MHz */
+		switch ((unsigned long)__raw_readq(&tx4938_ccfgptr->ccfg) &
+			TX4938_CCFG_PCIDIVMODE_MASK) {
+		case TX4938_CCFG_PCIDIVMODE_8:
+		case TX4938_CCFG_PCIDIVMODE_4:
+			txx9_cpu_clock = 266666666;	/* 266MHz */
 			break;
-		case TX4937_CCFG_PCIDIVMODE_9:
-		case TX4937_CCFG_PCIDIVMODE_4_5:
-			tx4927_cpu_clock = 300000000;	/* 300MHz */
+		case TX4938_CCFG_PCIDIVMODE_9:
+		case TX4938_CCFG_PCIDIVMODE_4_5:
+			txx9_cpu_clock = 300000000;	/* 300MHz */
 			break;
 		default:
-			tx4927_cpu_clock = 333333333;	/* 333MHz */
+			txx9_cpu_clock = 333333333;	/* 333MHz */
 		}
 	else
-		switch ((unsigned long)tx4927_ccfgptr->
-			ccfg & TX4927_CCFG_PCIDIVMODE_MASK) {
+		switch ((unsigned long)__raw_readq(&tx4927_ccfgptr->ccfg) &
+			TX4927_CCFG_PCIDIVMODE_MASK) {
 		case TX4927_CCFG_PCIDIVMODE_2_5:
 		case TX4927_CCFG_PCIDIVMODE_5:
-			tx4927_cpu_clock = 166666666;	/* 166MHz */
+			txx9_cpu_clock = 166666666;	/* 166MHz */
 			break;
 		default:
-			tx4927_cpu_clock = 200000000;	/* 200MHz */
+			txx9_cpu_clock = 200000000;	/* 200MHz */
 		}
+	/* change default value to udelay/mdelay take reasonable time */
+	loops_per_jiffy = txx9_cpu_clock / HZ / 2;
 
 	/* CCFG */
 	/* do reset on watchdog */
-	tx4927_ccfgptr->ccfg |= TX4927_CCFG_WR;
+	tx4927_ccfg_set(TX4927_CCFG_WR);
 	/* enable Timeout BusError */
 	if (tx4927_ccfg_toeon)
-		tx4927_ccfgptr->ccfg |= TX4927_CCFG_TOE;
-
-	tx4927_pci_setup();
-	if (tx4927_using_backplane == 1)
-		printk("backplane board IS installed\n");
-	else
-		printk("No Backplane \n");
-
-	/* this is on ISA bus behind PCI bus, so need PCI up first */
-#ifdef CONFIG_TOSHIBA_FPCIB0
-	if (tx4927_using_backplane) {
-		smsc_fdc37m81x_init(0x3f0);
-		smsc_fdc37m81x_config_beg();
-		smsc_fdc37m81x_config_set(SMSC_FDC37M81X_DNUM,
-					  SMSC_FDC37M81X_KBD);
-		smsc_fdc37m81x_config_set(SMSC_FDC37M81X_INT, 1);
-		smsc_fdc37m81x_config_set(SMSC_FDC37M81X_INT2, 12);
-		smsc_fdc37m81x_config_set(SMSC_FDC37M81X_ACTIVE,
-					  1);
-		smsc_fdc37m81x_config_end();
-	}
-#endif
-#endif /* CONFIG_PCI */
+		tx4927_ccfg_set(TX4927_CCFG_TOE);
 
 #ifdef CONFIG_SERIAL_TXX9
 	{
@@ -611,8 +354,8 @@ void __init plat_mem_setup(void)
 
 void __init plat_time_init(void)
 {
-	mips_hpt_frequency = tx4927_cpu_clock / 2;
-	if (tx4927_ccfgptr->ccfg & TX4927_CCFG_TINTDIS)
+	mips_hpt_frequency = txx9_cpu_clock / 2;
+	if (____raw_readq(&tx4927_ccfgptr->ccfg) & TX4927_CCFG_TINTDIS)
 		txx9_clockevent_init(TX4927_TMR_REG(0) & 0xfffffffffULL,
 				     TXX9_IRQ_BASE + 17,
 				     50000000);

commit 22b1d707ffc99faebd86257ad19d5bb9fc624734
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 00:31:36 2008 +0900

    [MIPS] TXx9: Reorganize code
    
    Move arch/mips/{jmr3927,tx4927,tx4938} into arch/mips/txx9/ tree.
    This will help more code sharing and maintainance.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4927/setup.c b/arch/mips/txx9/rbtx4927/setup.c
new file mode 100644
index 000000000000..df1b6e99b666
--- /dev/null
+++ b/arch/mips/txx9/rbtx4927/setup.c
@@ -0,0 +1,703 @@
+/*
+ * Toshiba rbtx4927 specific setup
+ *
+ * Author: MontaVista Software, Inc.
+ *         source@mvista.com
+ *
+ * Copyright 2001-2002 MontaVista Software Inc.
+ *
+ * Copyright (C) 1996, 97, 2001, 04  Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2000 RidgeRun, Inc.
+ * Author: RidgeRun, Inc.
+ *   glonnon@ridgerun.com, skranz@ridgerun.com, stevej@ridgerun.com
+ *
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: jsun@mvista.com or jsun@junsun.net
+ *
+ * Copyright 2002 MontaVista Software Inc.
+ * Author: Michael Pruznick, michael_pruznick@mvista.com
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * Copyright (C) 2004 MontaVista Software Inc.
+ * Author: Manish Lachwani, mlachwani@mvista.com
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License as published by the
+ *  Free Software Foundation; either version 2 of the License, or (at your
+ *  option) any later version.
+ *
+ *  THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
+ *  WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ *  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
+ *  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
+ *  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR
+ *  TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+ *  USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+
+#include <asm/bootinfo.h>
+#include <asm/io.h>
+#include <asm/processor.h>
+#include <asm/reboot.h>
+#include <asm/time.h>
+#include <asm/txx9tmr.h>
+#ifdef CONFIG_TOSHIBA_FPCIB0
+#include <asm/txx9/smsc_fdc37m81x.h>
+#endif
+#include <asm/txx9/rbtx4927.h>
+#ifdef CONFIG_SERIAL_TXX9
+#include <linux/serial_core.h>
+#endif
+
+/* These functions are used for rebooting or halting the machine*/
+extern void toshiba_rbtx4927_restart(char *command);
+extern void toshiba_rbtx4927_halt(void);
+extern void toshiba_rbtx4927_power_off(void);
+
+int tx4927_using_backplane = 0;
+
+extern void toshiba_rbtx4927_irq_setup(void);
+
+char *prom_getcmdline(void);
+
+#ifdef CONFIG_PCI
+#undef TX4927_SUPPORT_COMMAND_IO
+#undef  TX4927_SUPPORT_PCI_66
+int tx4927_cpu_clock = 100000000;	/* 100MHz */
+unsigned long mips_pci_io_base;
+unsigned long mips_pci_io_size;
+unsigned long mips_pci_mem_base;
+unsigned long mips_pci_mem_size;
+/* for legacy I/O, PCI I/O PCI Bus address must be 0 */
+unsigned long mips_pci_io_pciaddr = 0;
+unsigned long mips_memory_upper;
+static int tx4927_ccfg_toeon = 1;
+static int tx4927_pcic_trdyto = 0;	/* default: disabled */
+unsigned long tx4927_ce_base[8];
+int tx4927_pci66 = 0;		/* 0:auto */
+#endif
+
+char *toshiba_name = "";
+
+#ifdef CONFIG_PCI
+extern struct pci_controller tx4927_controller;
+
+static struct pci_dev *fake_pci_dev(struct pci_controller *hose,
+				    int top_bus, int busnr, int devfn)
+{
+	static struct pci_dev dev;
+	static struct pci_bus bus;
+
+	dev.sysdata = (void *)hose;
+	dev.devfn = devfn;
+	bus.number = busnr;
+	bus.ops = hose->pci_ops;
+	bus.parent = NULL;
+	dev.bus = &bus;
+
+	return &dev;
+}
+
+#define EARLY_PCI_OP(rw, size, type)                                    \
+static int early_##rw##_config_##size(struct pci_controller *hose,      \
+        int top_bus, int bus, int devfn, int offset, type value)        \
+{                                                                       \
+        return pci_##rw##_config_##size(                                \
+                fake_pci_dev(hose, top_bus, bus, devfn),                \
+                offset, value);                                         \
+}
+
+EARLY_PCI_OP(read, byte, u8 *)
+EARLY_PCI_OP(read, dword, u32 *)
+EARLY_PCI_OP(write, byte, u8)
+EARLY_PCI_OP(write, dword, u32)
+
+static int __init tx4927_pcibios_init(void)
+{
+	unsigned int id;
+	u32 pci_devfn;
+	int devfn_start = 0;
+	int devfn_stop = 0xff;
+	int busno = 0; /* One bus on the Toshiba */
+	struct pci_controller *hose = &tx4927_controller;
+
+	for (pci_devfn = devfn_start; pci_devfn < devfn_stop; pci_devfn++) {
+		early_read_config_dword(hose, busno, busno, pci_devfn,
+					PCI_VENDOR_ID, &id);
+
+		if (id == 0xffffffff) {
+			continue;
+		}
+
+		if (id == 0x94601055) {
+			u8 v08_64;
+			u32 v32_b0;
+			u8 v08_e1;
+
+			early_read_config_byte(hose, busno, busno,
+					       pci_devfn, 0x64, &v08_64);
+			early_read_config_dword(hose, busno, busno,
+						pci_devfn, 0xb0, &v32_b0);
+			early_read_config_byte(hose, busno, busno,
+					       pci_devfn, 0xe1, &v08_e1);
+
+			/* serial irq control */
+			v08_64 = 0xd0;
+
+			/* serial irq pin */
+			v32_b0 |= 0x00010000;
+
+			/* ide irq on isa14 */
+			v08_e1 &= 0xf0;
+			v08_e1 |= 0x0d;
+
+			early_write_config_byte(hose, busno, busno,
+						pci_devfn, 0x64, v08_64);
+			early_write_config_dword(hose, busno, busno,
+						 pci_devfn, 0xb0, v32_b0);
+			early_write_config_byte(hose, busno, busno,
+						pci_devfn, 0xe1, v08_e1);
+		}
+
+		if (id == 0x91301055) {
+			u8 v08_04;
+			u8 v08_09;
+			u8 v08_41;
+			u8 v08_43;
+			u8 v08_5c;
+
+			early_read_config_byte(hose, busno, busno,
+					       pci_devfn, 0x04, &v08_04);
+			early_read_config_byte(hose, busno, busno,
+					       pci_devfn, 0x09, &v08_09);
+			early_read_config_byte(hose, busno, busno,
+					       pci_devfn, 0x41, &v08_41);
+			early_read_config_byte(hose, busno, busno,
+					       pci_devfn, 0x43, &v08_43);
+			early_read_config_byte(hose, busno, busno,
+					       pci_devfn, 0x5c, &v08_5c);
+
+			/* enable ide master/io */
+			v08_04 |= (PCI_COMMAND_MASTER | PCI_COMMAND_IO);
+
+			/* enable ide native mode */
+			v08_09 |= 0x05;
+
+			/* enable primary ide */
+			v08_41 |= 0x80;
+
+			/* enable secondary ide */
+			v08_43 |= 0x80;
+
+			/*
+			 * !!! DO NOT REMOVE THIS COMMENT IT IS REQUIRED BY SMSC !!!
+			 *
+			 * This line of code is intended to provide the user with a work
+			 * around solution to the anomalies cited in SMSC's anomaly sheet
+			 * entitled, "SLC90E66 Functional Rev.J_0.1 Anomalies"".
+			 *
+			 * !!! DO NOT REMOVE THIS COMMENT IT IS REQUIRED BY SMSC !!!
+			 */
+			v08_5c |= 0x01;
+
+			early_write_config_byte(hose, busno, busno,
+						pci_devfn, 0x5c, v08_5c);
+			early_write_config_byte(hose, busno, busno,
+						pci_devfn, 0x04, v08_04);
+			early_write_config_byte(hose, busno, busno,
+						pci_devfn, 0x09, v08_09);
+			early_write_config_byte(hose, busno, busno,
+						pci_devfn, 0x41, v08_41);
+			early_write_config_byte(hose, busno, busno,
+						pci_devfn, 0x43, v08_43);
+		}
+
+	}
+
+	register_pci_controller(&tx4927_controller);
+	return 0;
+}
+
+arch_initcall(tx4927_pcibios_init);
+
+extern struct resource pci_io_resource;
+extern struct resource pci_mem_resource;
+
+void __init tx4927_pci_setup(void)
+{
+	static int called = 0;
+	extern unsigned int tx4927_get_mem_size(void);
+
+	mips_memory_upper = tx4927_get_mem_size() << 20;
+	mips_memory_upper += KSEG0;
+	mips_pci_io_base = TX4927_PCIIO;
+	mips_pci_io_size = TX4927_PCIIO_SIZE;
+	mips_pci_mem_base = TX4927_PCIMEM;
+	mips_pci_mem_size = TX4927_PCIMEM_SIZE;
+
+	if (!called) {
+		printk
+		    ("%s PCIC -- DID:%04x VID:%04x RID:%02x Arbiter:%s\n",
+		     toshiba_name,
+		     (unsigned short) (tx4927_pcicptr->pciid >> 16),
+		     (unsigned short) (tx4927_pcicptr->pciid & 0xffff),
+		     (unsigned short) (tx4927_pcicptr->pciccrev & 0xff),
+		     (!(tx4927_ccfgptr->
+			ccfg & TX4927_CCFG_PCIXARB)) ? "External" :
+		     "Internal");
+		called = 1;
+	}
+	printk("%s PCIC --%s PCICLK:", toshiba_name,
+	       (tx4927_ccfgptr->ccfg & TX4927_CCFG_PCI66) ? " PCI66" : "");
+	if (tx4927_ccfgptr->pcfg & TX4927_PCFG_PCICLKEN_ALL) {
+		int pciclk = 0;
+		if (mips_machtype == MACH_TOSHIBA_RBTX4937)
+			switch ((unsigned long) tx4927_ccfgptr->
+				ccfg & TX4937_CCFG_PCIDIVMODE_MASK) {
+			case TX4937_CCFG_PCIDIVMODE_4:
+				pciclk = tx4927_cpu_clock / 4;
+				break;
+			case TX4937_CCFG_PCIDIVMODE_4_5:
+				pciclk = tx4927_cpu_clock * 2 / 9;
+				break;
+			case TX4937_CCFG_PCIDIVMODE_5:
+				pciclk = tx4927_cpu_clock / 5;
+				break;
+			case TX4937_CCFG_PCIDIVMODE_5_5:
+				pciclk = tx4927_cpu_clock * 2 / 11;
+				break;
+			case TX4937_CCFG_PCIDIVMODE_8:
+				pciclk = tx4927_cpu_clock / 8;
+				break;
+			case TX4937_CCFG_PCIDIVMODE_9:
+				pciclk = tx4927_cpu_clock / 9;
+				break;
+			case TX4937_CCFG_PCIDIVMODE_10:
+				pciclk = tx4927_cpu_clock / 10;
+				break;
+			case TX4937_CCFG_PCIDIVMODE_11:
+				pciclk = tx4927_cpu_clock / 11;
+				break;
+			}
+
+		else
+			switch ((unsigned long) tx4927_ccfgptr->
+				ccfg & TX4927_CCFG_PCIDIVMODE_MASK) {
+			case TX4927_CCFG_PCIDIVMODE_2_5:
+				pciclk = tx4927_cpu_clock * 2 / 5;
+				break;
+			case TX4927_CCFG_PCIDIVMODE_3:
+				pciclk = tx4927_cpu_clock / 3;
+				break;
+			case TX4927_CCFG_PCIDIVMODE_5:
+				pciclk = tx4927_cpu_clock / 5;
+				break;
+			case TX4927_CCFG_PCIDIVMODE_6:
+				pciclk = tx4927_cpu_clock / 6;
+				break;
+			}
+
+		printk("Internal(%dMHz)", pciclk / 1000000);
+	} else
+		printk("External");
+	printk("\n");
+
+	/* GB->PCI mappings */
+	tx4927_pcicptr->g2piomask = (mips_pci_io_size - 1) >> 4;
+	tx4927_pcicptr->g2piogbase = mips_pci_io_base |
+#ifdef __BIG_ENDIAN
+	    TX4927_PCIC_G2PIOGBASE_ECHG
+#else
+	    TX4927_PCIC_G2PIOGBASE_BSDIS
+#endif
+	    ;
+
+	tx4927_pcicptr->g2piopbase = 0;
+
+	tx4927_pcicptr->g2pmmask[0] = (mips_pci_mem_size - 1) >> 4;
+	tx4927_pcicptr->g2pmgbase[0] = mips_pci_mem_base |
+#ifdef __BIG_ENDIAN
+	    TX4927_PCIC_G2PMnGBASE_ECHG
+#else
+	    TX4927_PCIC_G2PMnGBASE_BSDIS
+#endif
+	    ;
+	tx4927_pcicptr->g2pmpbase[0] = mips_pci_mem_base;
+
+	tx4927_pcicptr->g2pmmask[1] = 0;
+	tx4927_pcicptr->g2pmgbase[1] = 0;
+	tx4927_pcicptr->g2pmpbase[1] = 0;
+	tx4927_pcicptr->g2pmmask[2] = 0;
+	tx4927_pcicptr->g2pmgbase[2] = 0;
+	tx4927_pcicptr->g2pmpbase[2] = 0;
+
+
+	/* PCI->GB mappings (I/O 256B) */
+	tx4927_pcicptr->p2giopbase = 0;	/* 256B */
+
+	/* PCI->GB mappings (MEM 512MB) M0 gets all of memory */
+	tx4927_pcicptr->p2gm0plbase = 0;
+	tx4927_pcicptr->p2gm0pubase = 0;
+	tx4927_pcicptr->p2gmgbase[0] = 0 | TX4927_PCIC_P2GMnGBASE_TMEMEN |
+#ifdef __BIG_ENDIAN
+	    TX4927_PCIC_P2GMnGBASE_TECHG
+#else
+	    TX4927_PCIC_P2GMnGBASE_TBSDIS
+#endif
+	    ;
+
+	/* PCI->GB mappings (MEM 16MB) -not used */
+	tx4927_pcicptr->p2gm1plbase = 0xffffffff;
+	tx4927_pcicptr->p2gm1pubase = 0xffffffff;
+	tx4927_pcicptr->p2gmgbase[1] = 0;
+
+	/* PCI->GB mappings (MEM 1MB) -not used */
+	tx4927_pcicptr->p2gm2pbase = 0xffffffff;
+	tx4927_pcicptr->p2gmgbase[2] = 0;
+
+
+	/* Enable Initiator Memory 0 Space, I/O Space, Config */
+	tx4927_pcicptr->pciccfg &= TX4927_PCIC_PCICCFG_LBWC_MASK;
+	tx4927_pcicptr->pciccfg |=
+	    TX4927_PCIC_PCICCFG_IMSE0 | TX4927_PCIC_PCICCFG_IISE |
+	    TX4927_PCIC_PCICCFG_ICAE | TX4927_PCIC_PCICCFG_ATR;
+
+
+	/* Do not use MEMMUL, MEMINF: YMFPCI card causes M_ABORT. */
+	tx4927_pcicptr->pcicfg1 = 0;
+
+	if (tx4927_pcic_trdyto >= 0) {
+		tx4927_pcicptr->g2ptocnt &= ~0xff;
+		tx4927_pcicptr->g2ptocnt |= (tx4927_pcic_trdyto & 0xff);
+	}
+
+	/* Clear All Local Bus Status */
+	tx4927_pcicptr->pcicstatus = TX4927_PCIC_PCICSTATUS_ALL;
+	/* Enable All Local Bus Interrupts */
+	tx4927_pcicptr->pcicmask = TX4927_PCIC_PCICSTATUS_ALL;
+	/* Clear All Initiator Status */
+	tx4927_pcicptr->g2pstatus = TX4927_PCIC_G2PSTATUS_ALL;
+	/* Enable All Initiator Interrupts */
+	tx4927_pcicptr->g2pmask = TX4927_PCIC_G2PSTATUS_ALL;
+	/* Clear All PCI Status Error */
+	tx4927_pcicptr->pcistatus =
+	    (tx4927_pcicptr->pcistatus & 0x0000ffff) |
+	    (TX4927_PCIC_PCISTATUS_ALL << 16);
+	/* Enable All PCI Status Error Interrupts */
+	tx4927_pcicptr->pcimask = TX4927_PCIC_PCISTATUS_ALL;
+
+	/* PCIC Int => IRC IRQ16 */
+	tx4927_pcicptr->pcicfg2 =
+	    (tx4927_pcicptr->pcicfg2 & 0xffffff00) | TX4927_IR_PCIC;
+
+	if (!(tx4927_ccfgptr->ccfg & TX4927_CCFG_PCIXARB)) {
+		/* XXX */
+	} else {
+		/* Reset Bus Arbiter */
+		tx4927_pcicptr->pbacfg = TX4927_PCIC_PBACFG_RPBA;
+		/* Enable Bus Arbiter */
+		tx4927_pcicptr->pbacfg = TX4927_PCIC_PBACFG_PBAEN;
+	}
+
+	tx4927_pcicptr->pcistatus = PCI_COMMAND_MASTER |
+	    PCI_COMMAND_MEMORY |
+	    PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+}
+#endif /* CONFIG_PCI */
+
+static void __noreturn wait_forever(void)
+{
+	while (1)
+		if (cpu_wait)
+			(*cpu_wait)();
+}
+
+void toshiba_rbtx4927_restart(char *command)
+{
+	printk(KERN_NOTICE "System Rebooting...\n");
+
+	/* enable the s/w reset register */
+	writeb(RBTX4927_SW_RESET_ENABLE_SET, RBTX4927_SW_RESET_ENABLE);
+
+	/* wait for enable to be seen */
+	while ((readb(RBTX4927_SW_RESET_ENABLE) &
+		RBTX4927_SW_RESET_ENABLE_SET) == 0x00);
+
+	/* do a s/w reset */
+	writeb(RBTX4927_SW_RESET_DO_SET, RBTX4927_SW_RESET_DO);
+
+	/* do something passive while waiting for reset */
+	local_irq_disable();
+	wait_forever();
+	/* no return */
+}
+
+void toshiba_rbtx4927_halt(void)
+{
+	printk(KERN_NOTICE "System Halted\n");
+	local_irq_disable();
+	wait_forever();
+	/* no return */
+}
+
+void toshiba_rbtx4927_power_off(void)
+{
+	toshiba_rbtx4927_halt();
+	/* no return */
+}
+
+void __init plat_mem_setup(void)
+{
+	int i;
+	u32 cp0_config;
+	char *argptr;
+
+	printk("CPU is %s\n", toshiba_name);
+
+	/* f/w leaves this on at startup */
+	clear_c0_status(ST0_ERL);
+
+	/* enable caches -- HCP5 does this, pmon does not */
+	cp0_config = read_c0_config();
+	cp0_config = cp0_config & ~(TX49_CONF_IC | TX49_CONF_DC);
+	write_c0_config(cp0_config);
+
+	set_io_port_base(KSEG1 + TBTX4927_ISA_IO_OFFSET);
+
+	ioport_resource.end = 0xffffffff;
+	iomem_resource.end = 0xffffffff;
+
+	_machine_restart = toshiba_rbtx4927_restart;
+	_machine_halt = toshiba_rbtx4927_halt;
+	pm_power_off = toshiba_rbtx4927_power_off;
+
+	for (i = 0; i < TX4927_NR_TMR; i++)
+		txx9_tmr_init(TX4927_TMR_REG(0) & 0xfffffffffULL);
+
+#ifdef CONFIG_PCI
+
+	/* PCIC */
+	/*
+	   * ASSUMPTION: PCIDIVMODE is configured for PCI 33MHz or 66MHz.
+	   *
+	   * For TX4927:
+	   * PCIDIVMODE[12:11]'s initial value is given by S9[4:3] (ON:0, OFF:1).
+	   * CPU 166MHz: PCI 66MHz : PCIDIVMODE: 00 (1/2.5)
+	   * CPU 200MHz: PCI 66MHz : PCIDIVMODE: 01 (1/3)
+	   * CPU 166MHz: PCI 33MHz : PCIDIVMODE: 10 (1/5)
+	   * CPU 200MHz: PCI 33MHz : PCIDIVMODE: 11 (1/6)
+	   * i.e. S9[3]: ON (83MHz), OFF (100MHz)
+	   *
+	   * For TX4937:
+	   * PCIDIVMODE[12:11]'s initial value is given by S1[5:4] (ON:0, OFF:1)
+	   * PCIDIVMODE[10] is 0.
+	   * CPU 266MHz: PCI 33MHz : PCIDIVMODE: 000 (1/8)
+	   * CPU 266MHz: PCI 66MHz : PCIDIVMODE: 001 (1/4)
+	   * CPU 300MHz: PCI 33MHz : PCIDIVMODE: 010 (1/9)
+	   * CPU 300MHz: PCI 66MHz : PCIDIVMODE: 011 (1/4.5)
+	   * CPU 333MHz: PCI 33MHz : PCIDIVMODE: 100 (1/10)
+	   * CPU 333MHz: PCI 66MHz : PCIDIVMODE: 101 (1/5)
+	   *
+	 */
+	if (mips_machtype == MACH_TOSHIBA_RBTX4937)
+		switch ((unsigned long)tx4927_ccfgptr->
+			ccfg & TX4937_CCFG_PCIDIVMODE_MASK) {
+		case TX4937_CCFG_PCIDIVMODE_8:
+		case TX4937_CCFG_PCIDIVMODE_4:
+			tx4927_cpu_clock = 266666666;	/* 266MHz */
+			break;
+		case TX4937_CCFG_PCIDIVMODE_9:
+		case TX4937_CCFG_PCIDIVMODE_4_5:
+			tx4927_cpu_clock = 300000000;	/* 300MHz */
+			break;
+		default:
+			tx4927_cpu_clock = 333333333;	/* 333MHz */
+		}
+	else
+		switch ((unsigned long)tx4927_ccfgptr->
+			ccfg & TX4927_CCFG_PCIDIVMODE_MASK) {
+		case TX4927_CCFG_PCIDIVMODE_2_5:
+		case TX4927_CCFG_PCIDIVMODE_5:
+			tx4927_cpu_clock = 166666666;	/* 166MHz */
+			break;
+		default:
+			tx4927_cpu_clock = 200000000;	/* 200MHz */
+		}
+
+	/* CCFG */
+	/* do reset on watchdog */
+	tx4927_ccfgptr->ccfg |= TX4927_CCFG_WR;
+	/* enable Timeout BusError */
+	if (tx4927_ccfg_toeon)
+		tx4927_ccfgptr->ccfg |= TX4927_CCFG_TOE;
+
+	tx4927_pci_setup();
+	if (tx4927_using_backplane == 1)
+		printk("backplane board IS installed\n");
+	else
+		printk("No Backplane \n");
+
+	/* this is on ISA bus behind PCI bus, so need PCI up first */
+#ifdef CONFIG_TOSHIBA_FPCIB0
+	if (tx4927_using_backplane) {
+		smsc_fdc37m81x_init(0x3f0);
+		smsc_fdc37m81x_config_beg();
+		smsc_fdc37m81x_config_set(SMSC_FDC37M81X_DNUM,
+					  SMSC_FDC37M81X_KBD);
+		smsc_fdc37m81x_config_set(SMSC_FDC37M81X_INT, 1);
+		smsc_fdc37m81x_config_set(SMSC_FDC37M81X_INT2, 12);
+		smsc_fdc37m81x_config_set(SMSC_FDC37M81X_ACTIVE,
+					  1);
+		smsc_fdc37m81x_config_end();
+	}
+#endif
+#endif /* CONFIG_PCI */
+
+#ifdef CONFIG_SERIAL_TXX9
+	{
+		extern int early_serial_txx9_setup(struct uart_port *port);
+		struct uart_port req;
+		for(i = 0; i < 2; i++) {
+			memset(&req, 0, sizeof(req));
+			req.line = i;
+			req.iotype = UPIO_MEM;
+			req.membase = (char *)(0xff1ff300 + i * 0x100);
+			req.mapbase = 0xff1ff300 + i * 0x100;
+			req.irq = TX4927_IRQ_PIC_BEG + 8 + i;
+			req.flags |= UPF_BUGGY_UART /*HAVE_CTS_LINE*/;
+			req.uartclk = 50000000;
+			early_serial_txx9_setup(&req);
+		}
+	}
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
+        argptr = prom_getcmdline();
+        if (strstr(argptr, "console=") == NULL) {
+                strcat(argptr, " console=ttyS0,38400");
+        }
+#endif
+#endif
+
+#ifdef CONFIG_ROOT_NFS
+        argptr = prom_getcmdline();
+        if (strstr(argptr, "root=") == NULL) {
+                strcat(argptr, " root=/dev/nfs rw");
+        }
+#endif
+
+#ifdef CONFIG_IP_PNP
+        argptr = prom_getcmdline();
+        if (strstr(argptr, "ip=") == NULL) {
+                strcat(argptr, " ip=any");
+        }
+#endif
+}
+
+void __init plat_time_init(void)
+{
+	mips_hpt_frequency = tx4927_cpu_clock / 2;
+	if (tx4927_ccfgptr->ccfg & TX4927_CCFG_TINTDIS)
+		txx9_clockevent_init(TX4927_TMR_REG(0) & 0xfffffffffULL,
+				     TXX9_IRQ_BASE + 17,
+				     50000000);
+}
+
+static int __init toshiba_rbtx4927_rtc_init(void)
+{
+	static struct resource __initdata res = {
+		.start	= 0x1c010000,
+		.end	= 0x1c010000 + 0x800 - 1,
+		.flags	= IORESOURCE_MEM,
+	};
+	struct platform_device *dev =
+		platform_device_register_simple("rtc-ds1742", -1, &res, 1);
+	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
+}
+device_initcall(toshiba_rbtx4927_rtc_init);
+
+static int __init rbtx4927_ne_init(void)
+{
+	static struct resource __initdata res[] = {
+		{
+			.start	= RBTX4927_RTL_8019_BASE,
+			.end	= RBTX4927_RTL_8019_BASE + 0x20 - 1,
+			.flags	= IORESOURCE_IO,
+		}, {
+			.start	= RBTX4927_RTL_8019_IRQ,
+			.flags	= IORESOURCE_IRQ,
+		}
+	};
+	struct platform_device *dev =
+		platform_device_register_simple("ne", -1,
+						res, ARRAY_SIZE(res));
+	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
+}
+device_initcall(rbtx4927_ne_init);
+
+/* Watchdog support */
+
+static int __init txx9_wdt_init(unsigned long base)
+{
+	struct resource res = {
+		.start	= base,
+		.end	= base + 0x100 - 1,
+		.flags	= IORESOURCE_MEM,
+	};
+	struct platform_device *dev =
+		platform_device_register_simple("txx9wdt", -1, &res, 1);
+	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
+}
+
+static int __init rbtx4927_wdt_init(void)
+{
+	return txx9_wdt_init(TX4927_TMR_REG(2) & 0xfffffffffULL);
+}
+device_initcall(rbtx4927_wdt_init);
+
+/* Minimum CLK support */
+
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	if (!strcmp(id, "imbus_clk"))
+		return (struct clk *)50000000;
+	return ERR_PTR(-ENOENT);
+}
+EXPORT_SYMBOL(clk_get);
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return (unsigned long)clk;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+void clk_put(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_put);
