commit e4ec7989b4e55d9275ebac66230b7dac6dcb1fae
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Mar 27 15:19:28 2011 +0200

    MIPS: Convert the irq functions to the new names
    
    Scripted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/mips/txx9/jmr3927/irq.c b/arch/mips/txx9/jmr3927/irq.c
index 92a5c1b400f0..c22c859a2c49 100644
--- a/arch/mips/txx9/jmr3927/irq.c
+++ b/arch/mips/txx9/jmr3927/irq.c
@@ -120,8 +120,9 @@ void __init jmr3927_irq_setup(void)
 
 	tx3927_irq_init();
 	for (i = JMR3927_IRQ_IOC; i < JMR3927_IRQ_IOC + JMR3927_NR_IRQ_IOC; i++)
-		set_irq_chip_and_handler(i, &jmr3927_irq_ioc, handle_level_irq);
+		irq_set_chip_and_handler(i, &jmr3927_irq_ioc,
+					 handle_level_irq);
 
 	/* setup IOC interrupt 1 (PCI, MODEM) */
-	set_irq_chained_handler(JMR3927_IRQ_IOCINT, handle_simple_irq);
+	irq_set_chained_handler(JMR3927_IRQ_IOCINT, handle_simple_irq);
 }

commit d7ae7c7137868fca5a18954f4d70d525f38867c9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 23 21:09:16 2011 +0000

    MIPS: TXx9: Convert to new irq_chip functions
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    To: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2207/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/jmr3927/irq.c b/arch/mips/txx9/jmr3927/irq.c
index 0a7f8e3b9fd7..92a5c1b400f0 100644
--- a/arch/mips/txx9/jmr3927/irq.c
+++ b/arch/mips/txx9/jmr3927/irq.c
@@ -47,20 +47,20 @@
  * CP0_STATUS is a thread's resource (saved/restored on context switch).
  * So disable_irq/enable_irq MUST handle IOC/IRC registers.
  */
-static void mask_irq_ioc(unsigned int irq)
+static void mask_irq_ioc(struct irq_data *d)
 {
 	/* 0: mask */
-	unsigned int irq_nr = irq - JMR3927_IRQ_IOC;
+	unsigned int irq_nr = d->irq - JMR3927_IRQ_IOC;
 	unsigned char imask = jmr3927_ioc_reg_in(JMR3927_IOC_INTM_ADDR);
 	unsigned int bit = 1 << irq_nr;
 	jmr3927_ioc_reg_out(imask & ~bit, JMR3927_IOC_INTM_ADDR);
 	/* flush write buffer */
 	(void)jmr3927_ioc_reg_in(JMR3927_IOC_REV_ADDR);
 }
-static void unmask_irq_ioc(unsigned int irq)
+static void unmask_irq_ioc(struct irq_data *d)
 {
 	/* 0: mask */
-	unsigned int irq_nr = irq - JMR3927_IRQ_IOC;
+	unsigned int irq_nr = d->irq - JMR3927_IRQ_IOC;
 	unsigned char imask = jmr3927_ioc_reg_in(JMR3927_IOC_INTM_ADDR);
 	unsigned int bit = 1 << irq_nr;
 	jmr3927_ioc_reg_out(imask | bit, JMR3927_IOC_INTM_ADDR);
@@ -95,10 +95,8 @@ static int jmr3927_irq_dispatch(int pending)
 
 static struct irq_chip jmr3927_irq_ioc = {
 	.name = "jmr3927_ioc",
-	.ack = mask_irq_ioc,
-	.mask = mask_irq_ioc,
-	.mask_ack = mask_irq_ioc,
-	.unmask = unmask_irq_ioc,
+	.irq_mask = mask_irq_ioc,
+	.irq_unmask = unmask_irq_ioc,
 };
 
 void __init jmr3927_irq_setup(void)

commit ca4d3e6746bdcfccb517349bce2d2c5b5614fb6f
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 7 14:08:54 2010 +0100

    MIPS: Add missing #inclusions of <linux/irq.h>
    
    Add missing #inclusions of <linux/irq.h> to a whole bunch of files that should
    really include it.  Note that this can replace #inclusions of <asm/irq.h>.
    
    This is required for the patch to sort out irqflags handling function naming to
    compile on MIPS.
    
    The problem is that these files require access to things like setup_irq() -
    which isn't available by #including <linux/interrupt.h>
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/jmr3927/irq.c b/arch/mips/txx9/jmr3927/irq.c
index 6ec626c9473f..0a7f8e3b9fd7 100644
--- a/arch/mips/txx9/jmr3927/irq.c
+++ b/arch/mips/txx9/jmr3927/irq.c
@@ -32,6 +32,7 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/interrupt.h>
+#include <linux/irq.h>
 
 #include <asm/io.h>
 #include <asm/mipsregs.h>

commit bb72f1f729dcbd6a6a93c74479eeaa19deebfb47
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:21 2008 +0900

    [MIPS] TXx9: Random cleanup
    
    * Random cleanups spotted by checkpatch script.
    * Do not initialize panic_timeout.  "panic=" kernel parameter can be used.
    * Do not add "ip=any" or "ip=bootp".  This options is not board specific.
    * Do not add "root=/dev/nfs".  This is default on CONFIG_ROOT_NFS.
    * Kill unused error checking.
    * Fix IRQ comment to match current code.
    * Kill some unneeded includes
    * ST0_ERL is already cleared in generic code.
    * conswitchp is initialized generic code.
    * __init is not needed in prototype.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/jmr3927/irq.c b/arch/mips/txx9/jmr3927/irq.c
index 68f74368ddec..6ec626c9473f 100644
--- a/arch/mips/txx9/jmr3927/irq.c
+++ b/arch/mips/txx9/jmr3927/irq.c
@@ -30,15 +30,11 @@
  *  675 Mass Ave, Cambridge, MA 02139, USA.
  */
 #include <linux/init.h>
-#include <linux/sched.h>
 #include <linux/types.h>
 #include <linux/interrupt.h>
 
 #include <asm/io.h>
 #include <asm/mipsregs.h>
-#include <asm/system.h>
-
-#include <asm/processor.h>
 #include <asm/txx9/generic.h>
 #include <asm/txx9/jmr3927.h>
 

commit f6727fb889c664be094fa041a0fdf0f1a1caefb6
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:19 2008 +0900

    [MIPS] TXx9: Make tx3927-specific code more independent
    
    Make some TX3927 SoC specific code independent from board specific code.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/jmr3927/irq.c b/arch/mips/txx9/jmr3927/irq.c
index f3b60233e99d..68f74368ddec 100644
--- a/arch/mips/txx9/jmr3927/irq.c
+++ b/arch/mips/txx9/jmr3927/irq.c
@@ -46,13 +46,6 @@
 #error JMR3927_IRQ_END > NR_IRQS
 #endif
 
-static unsigned char irc_level[TX3927_NUM_IR] = {
-	5, 5, 5, 5, 5, 5,	/* INT[5:0] */
-	7, 7,			/* SIO */
-	5, 5, 5, 0, 0,		/* DMA, PIO, PCI */
-	6, 6, 6			/* TMR */
-};
-
 /*
  * CP0_STATUS is a thread's resource (saved/restored on context switch).
  * So disable_irq/enable_irq MUST handle IOC/IRC registers.
@@ -103,10 +96,18 @@ static int jmr3927_irq_dispatch(int pending)
 	return irq;
 }
 
-static void __init jmr3927_irq_init(void);
+static struct irq_chip jmr3927_irq_ioc = {
+	.name = "jmr3927_ioc",
+	.ack = mask_irq_ioc,
+	.mask = mask_irq_ioc,
+	.mask_ack = mask_irq_ioc,
+	.unmask = unmask_irq_ioc,
+};
 
 void __init jmr3927_irq_setup(void)
 {
+	int i;
+
 	txx9_irq_dispatch = jmr3927_irq_dispatch;
 	/* Now, interrupt control disabled, */
 	/* all IRC interrupts are masked, */
@@ -122,30 +123,10 @@ void __init jmr3927_irq_setup(void)
 	/* clear PCI Reset interrupts */
 	jmr3927_ioc_reg_out(0, JMR3927_IOC_RESET_ADDR);
 
-	jmr3927_irq_init();
+	tx3927_irq_init();
+	for (i = JMR3927_IRQ_IOC; i < JMR3927_IRQ_IOC + JMR3927_NR_IRQ_IOC; i++)
+		set_irq_chip_and_handler(i, &jmr3927_irq_ioc, handle_level_irq);
 
 	/* setup IOC interrupt 1 (PCI, MODEM) */
 	set_irq_chained_handler(JMR3927_IRQ_IOCINT, handle_simple_irq);
-
-	/* enable all CPU interrupt bits. */
-	set_c0_status(ST0_IM);	/* IE bit is still 0. */
-}
-
-static struct irq_chip jmr3927_irq_ioc = {
-	.name = "jmr3927_ioc",
-	.ack = mask_irq_ioc,
-	.mask = mask_irq_ioc,
-	.mask_ack = mask_irq_ioc,
-	.unmask = unmask_irq_ioc,
-};
-
-static void __init jmr3927_irq_init(void)
-{
-	u32 i;
-
-	txx9_irq_init(TX3927_IRC_REG);
-	for (i = 0; i < TXx9_MAX_IR; i++)
-		txx9_irq_set_pri(i, irc_level[i]);
-	for (i = JMR3927_IRQ_IOC; i < JMR3927_IRQ_IOC + JMR3927_NR_IRQ_IOC; i++)
-		set_irq_chip_and_handler(i, &jmr3927_irq_ioc, handle_level_irq);
 }

commit 455cc256eb23915100e203fb33ee143afd127954
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 25 23:01:35 2008 +0900

    [MIPS] TXx9: PCI error handling
    
    From: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Date: Thu, 24 Jul 2008 00:25:16 +0900
    Subject: [PATCH] txx9: PCI error handling
    
    Add more control and detailed report on PCI error interrupt.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/jmr3927/irq.c b/arch/mips/txx9/jmr3927/irq.c
index 070c9a115e57..f3b60233e99d 100644
--- a/arch/mips/txx9/jmr3927/irq.c
+++ b/arch/mips/txx9/jmr3927/irq.c
@@ -103,22 +103,6 @@ static int jmr3927_irq_dispatch(int pending)
 	return irq;
 }
 
-#ifdef CONFIG_PCI
-static irqreturn_t jmr3927_pcierr_interrupt(int irq, void *dev_id)
-{
-	printk(KERN_WARNING "PCI error interrupt (irq 0x%x).\n", irq);
-	printk(KERN_WARNING "pcistat:%02x, lbstat:%04lx\n",
-	       tx3927_pcicptr->pcistat, tx3927_pcicptr->lbstat);
-
-	return IRQ_HANDLED;
-}
-static struct irqaction pcierr_action = {
-	.handler = jmr3927_pcierr_interrupt,
-	.mask = CPU_MASK_NONE,
-	.name = "PCI error",
-};
-#endif
-
 static void __init jmr3927_irq_init(void);
 
 void __init jmr3927_irq_setup(void)
@@ -143,10 +127,6 @@ void __init jmr3927_irq_setup(void)
 	/* setup IOC interrupt 1 (PCI, MODEM) */
 	set_irq_chained_handler(JMR3927_IRQ_IOCINT, handle_simple_irq);
 
-#ifdef CONFIG_PCI
-	setup_irq(JMR3927_IRQ_IRC_PCI, &pcierr_action);
-#endif
-
 	/* enable all CPU interrupt bits. */
 	set_c0_status(ST0_IM);	/* IE bit is still 0. */
 }

commit edcaf1a6a77315562e9781245cc8e028c9a921dc
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 23:27:54 2008 +0900

    [MIPS] TXx9: Make single kernel can support multiple boards
    
    Make single kernel can be used on RBTX4927/37/38.  Also make
    some SoC-specific code independent from board-specific code.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/jmr3927/irq.c b/arch/mips/txx9/jmr3927/irq.c
index b97d22e15da6..070c9a115e57 100644
--- a/arch/mips/txx9/jmr3927/irq.c
+++ b/arch/mips/txx9/jmr3927/irq.c
@@ -39,6 +39,7 @@
 #include <asm/system.h>
 
 #include <asm/processor.h>
+#include <asm/txx9/generic.h>
 #include <asm/txx9/jmr3927.h>
 
 #if JMR3927_IRQ_END > NR_IRQS
@@ -77,37 +78,30 @@ static void unmask_irq_ioc(unsigned int irq)
 	(void)jmr3927_ioc_reg_in(JMR3927_IOC_REV_ADDR);
 }
 
-asmlinkage void plat_irq_dispatch(void)
-{
-	unsigned long cp0_cause = read_c0_cause();
-	int irq;
-
-	if ((cp0_cause & CAUSEF_IP7) == 0)
-		return;
-	irq = (cp0_cause >> CAUSEB_IP2) & 0x0f;
-
-	do_IRQ(irq + JMR3927_IRQ_IRC);
-}
-
-static irqreturn_t jmr3927_ioc_interrupt(int irq, void *dev_id)
+static int jmr3927_ioc_irqroute(void)
 {
 	unsigned char istat = jmr3927_ioc_reg_in(JMR3927_IOC_INTS2_ADDR);
 	int i;
 
 	for (i = 0; i < JMR3927_NR_IRQ_IOC; i++) {
-		if (istat & (1 << i)) {
-			irq = JMR3927_IRQ_IOC + i;
-			do_IRQ(irq);
-		}
+		if (istat & (1 << i))
+			return JMR3927_IRQ_IOC + i;
 	}
-	return IRQ_HANDLED;
+	return -1;
 }
 
-static struct irqaction ioc_action = {
-	.handler = jmr3927_ioc_interrupt,
-	.mask = CPU_MASK_NONE,
-	.name = "IOC",
-};
+static int jmr3927_irq_dispatch(int pending)
+{
+	int irq;
+
+	if ((pending & CAUSEF_IP7) == 0)
+		return -1;
+	irq = (pending >> CAUSEB_IP2) & 0x0f;
+	irq += JMR3927_IRQ_IRC;
+	if (irq == JMR3927_IRQ_IOCINT)
+		irq = jmr3927_ioc_irqroute();
+	return irq;
+}
 
 #ifdef CONFIG_PCI
 static irqreturn_t jmr3927_pcierr_interrupt(int irq, void *dev_id)
@@ -127,8 +121,9 @@ static struct irqaction pcierr_action = {
 
 static void __init jmr3927_irq_init(void);
 
-void __init arch_init_irq(void)
+void __init jmr3927_irq_setup(void)
 {
+	txx9_irq_dispatch = jmr3927_irq_dispatch;
 	/* Now, interrupt control disabled, */
 	/* all IRC interrupts are masked, */
 	/* all IRC interrupt mode are Low Active. */
@@ -146,7 +141,7 @@ void __init arch_init_irq(void)
 	jmr3927_irq_init();
 
 	/* setup IOC interrupt 1 (PCI, MODEM) */
-	setup_irq(JMR3927_IRQ_IOCINT, &ioc_action);
+	set_irq_chained_handler(JMR3927_IRQ_IOCINT, handle_simple_irq);
 
 #ifdef CONFIG_PCI
 	setup_irq(JMR3927_IRQ_IRC_PCI, &pcierr_action);

commit 89d63fe179520b11f54de1f26755b7444c79e73a
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 00:33:08 2008 +0900

    [MIPS] TXx9: Reorganize PCI code
    
    Split out PCIC dependent code and SoC dependent code from board dependent
    code.  Now TX4927 PCIC code is independent from TX4927/TX4938 SoC code.
    Also fix some build problems on CONFIG_PCI=n.
    
    As a bonus, "FPCIB0 Backplane Support" is available for all TX39/TX49 boards
    and PCI66 support is available for all TX49 boards.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/jmr3927/irq.c b/arch/mips/txx9/jmr3927/irq.c
index 85e1daf15c7b..b97d22e15da6 100644
--- a/arch/mips/txx9/jmr3927/irq.c
+++ b/arch/mips/txx9/jmr3927/irq.c
@@ -109,6 +109,7 @@ static struct irqaction ioc_action = {
 	.name = "IOC",
 };
 
+#ifdef CONFIG_PCI
 static irqreturn_t jmr3927_pcierr_interrupt(int irq, void *dev_id)
 {
 	printk(KERN_WARNING "PCI error interrupt (irq 0x%x).\n", irq);
@@ -122,6 +123,7 @@ static struct irqaction pcierr_action = {
 	.mask = CPU_MASK_NONE,
 	.name = "PCI error",
 };
+#endif
 
 static void __init jmr3927_irq_init(void);
 

commit 22b1d707ffc99faebd86257ad19d5bb9fc624734
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 00:31:36 2008 +0900

    [MIPS] TXx9: Reorganize code
    
    Move arch/mips/{jmr3927,tx4927,tx4938} into arch/mips/txx9/ tree.
    This will help more code sharing and maintainance.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/jmr3927/irq.c b/arch/mips/txx9/jmr3927/irq.c
new file mode 100644
index 000000000000..85e1daf15c7b
--- /dev/null
+++ b/arch/mips/txx9/jmr3927/irq.c
@@ -0,0 +1,174 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *              ahennessy@mvista.com
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/init.h>
+#include <linux/sched.h>
+#include <linux/types.h>
+#include <linux/interrupt.h>
+
+#include <asm/io.h>
+#include <asm/mipsregs.h>
+#include <asm/system.h>
+
+#include <asm/processor.h>
+#include <asm/txx9/jmr3927.h>
+
+#if JMR3927_IRQ_END > NR_IRQS
+#error JMR3927_IRQ_END > NR_IRQS
+#endif
+
+static unsigned char irc_level[TX3927_NUM_IR] = {
+	5, 5, 5, 5, 5, 5,	/* INT[5:0] */
+	7, 7,			/* SIO */
+	5, 5, 5, 0, 0,		/* DMA, PIO, PCI */
+	6, 6, 6			/* TMR */
+};
+
+/*
+ * CP0_STATUS is a thread's resource (saved/restored on context switch).
+ * So disable_irq/enable_irq MUST handle IOC/IRC registers.
+ */
+static void mask_irq_ioc(unsigned int irq)
+{
+	/* 0: mask */
+	unsigned int irq_nr = irq - JMR3927_IRQ_IOC;
+	unsigned char imask = jmr3927_ioc_reg_in(JMR3927_IOC_INTM_ADDR);
+	unsigned int bit = 1 << irq_nr;
+	jmr3927_ioc_reg_out(imask & ~bit, JMR3927_IOC_INTM_ADDR);
+	/* flush write buffer */
+	(void)jmr3927_ioc_reg_in(JMR3927_IOC_REV_ADDR);
+}
+static void unmask_irq_ioc(unsigned int irq)
+{
+	/* 0: mask */
+	unsigned int irq_nr = irq - JMR3927_IRQ_IOC;
+	unsigned char imask = jmr3927_ioc_reg_in(JMR3927_IOC_INTM_ADDR);
+	unsigned int bit = 1 << irq_nr;
+	jmr3927_ioc_reg_out(imask | bit, JMR3927_IOC_INTM_ADDR);
+	/* flush write buffer */
+	(void)jmr3927_ioc_reg_in(JMR3927_IOC_REV_ADDR);
+}
+
+asmlinkage void plat_irq_dispatch(void)
+{
+	unsigned long cp0_cause = read_c0_cause();
+	int irq;
+
+	if ((cp0_cause & CAUSEF_IP7) == 0)
+		return;
+	irq = (cp0_cause >> CAUSEB_IP2) & 0x0f;
+
+	do_IRQ(irq + JMR3927_IRQ_IRC);
+}
+
+static irqreturn_t jmr3927_ioc_interrupt(int irq, void *dev_id)
+{
+	unsigned char istat = jmr3927_ioc_reg_in(JMR3927_IOC_INTS2_ADDR);
+	int i;
+
+	for (i = 0; i < JMR3927_NR_IRQ_IOC; i++) {
+		if (istat & (1 << i)) {
+			irq = JMR3927_IRQ_IOC + i;
+			do_IRQ(irq);
+		}
+	}
+	return IRQ_HANDLED;
+}
+
+static struct irqaction ioc_action = {
+	.handler = jmr3927_ioc_interrupt,
+	.mask = CPU_MASK_NONE,
+	.name = "IOC",
+};
+
+static irqreturn_t jmr3927_pcierr_interrupt(int irq, void *dev_id)
+{
+	printk(KERN_WARNING "PCI error interrupt (irq 0x%x).\n", irq);
+	printk(KERN_WARNING "pcistat:%02x, lbstat:%04lx\n",
+	       tx3927_pcicptr->pcistat, tx3927_pcicptr->lbstat);
+
+	return IRQ_HANDLED;
+}
+static struct irqaction pcierr_action = {
+	.handler = jmr3927_pcierr_interrupt,
+	.mask = CPU_MASK_NONE,
+	.name = "PCI error",
+};
+
+static void __init jmr3927_irq_init(void);
+
+void __init arch_init_irq(void)
+{
+	/* Now, interrupt control disabled, */
+	/* all IRC interrupts are masked, */
+	/* all IRC interrupt mode are Low Active. */
+
+	/* mask all IOC interrupts */
+	jmr3927_ioc_reg_out(0, JMR3927_IOC_INTM_ADDR);
+	/* setup IOC interrupt mode (SOFT:High Active, Others:Low Active) */
+	jmr3927_ioc_reg_out(JMR3927_IOC_INTF_SOFT, JMR3927_IOC_INTP_ADDR);
+
+	/* clear PCI Soft interrupts */
+	jmr3927_ioc_reg_out(0, JMR3927_IOC_INTS1_ADDR);
+	/* clear PCI Reset interrupts */
+	jmr3927_ioc_reg_out(0, JMR3927_IOC_RESET_ADDR);
+
+	jmr3927_irq_init();
+
+	/* setup IOC interrupt 1 (PCI, MODEM) */
+	setup_irq(JMR3927_IRQ_IOCINT, &ioc_action);
+
+#ifdef CONFIG_PCI
+	setup_irq(JMR3927_IRQ_IRC_PCI, &pcierr_action);
+#endif
+
+	/* enable all CPU interrupt bits. */
+	set_c0_status(ST0_IM);	/* IE bit is still 0. */
+}
+
+static struct irq_chip jmr3927_irq_ioc = {
+	.name = "jmr3927_ioc",
+	.ack = mask_irq_ioc,
+	.mask = mask_irq_ioc,
+	.mask_ack = mask_irq_ioc,
+	.unmask = unmask_irq_ioc,
+};
+
+static void __init jmr3927_irq_init(void)
+{
+	u32 i;
+
+	txx9_irq_init(TX3927_IRC_REG);
+	for (i = 0; i < TXx9_MAX_IR; i++)
+		txx9_irq_set_pri(i, irc_level[i]);
+	for (i = JMR3927_IRQ_IOC; i < JMR3927_IRQ_IOC + JMR3927_NR_IRQ_IOC; i++)
+		set_irq_chip_and_handler(i, &jmr3927_irq_ioc, handle_level_irq);
+}
