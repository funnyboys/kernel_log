commit e4ec7989b4e55d9275ebac66230b7dac6dcb1fae
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Mar 27 15:19:28 2011 +0200

    MIPS: Convert the irq functions to the new names
    
    Scripted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/mips/txx9/rbtx4938/irq.c b/arch/mips/txx9/rbtx4938/irq.c
index 2ec4fe1b1670..58cd7a9272cc 100644
--- a/arch/mips/txx9/rbtx4938/irq.c
+++ b/arch/mips/txx9/rbtx4938/irq.c
@@ -132,10 +132,10 @@ static void __init toshiba_rbtx4938_irq_ioc_init(void)
 
 	for (i = RBTX4938_IRQ_IOC;
 	     i < RBTX4938_IRQ_IOC + RBTX4938_NR_IRQ_IOC; i++)
-		set_irq_chip_and_handler(i, &toshiba_rbtx4938_irq_ioc_type,
+		irq_set_chip_and_handler(i, &toshiba_rbtx4938_irq_ioc_type,
 					 handle_level_irq);
 
-	set_irq_chained_handler(RBTX4938_IRQ_IOCINT, handle_simple_irq);
+	irq_set_chained_handler(RBTX4938_IRQ_IOCINT, handle_simple_irq);
 }
 
 void __init rbtx4938_irq_setup(void)
@@ -153,5 +153,5 @@ void __init rbtx4938_irq_setup(void)
 	tx4938_irq_init();
 	toshiba_rbtx4938_irq_ioc_init();
 	/* Onboard 10M Ether: High Active */
-	set_irq_type(RBTX4938_IRQ_ETHER, IRQF_TRIGGER_HIGH);
+	irq_set_irq_type(RBTX4938_IRQ_ETHER, IRQF_TRIGGER_HIGH);
 }

commit d7ae7c7137868fca5a18954f4d70d525f38867c9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 23 21:09:16 2011 +0000

    MIPS: TXx9: Convert to new irq_chip functions
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    To: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2207/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/irq.c b/arch/mips/txx9/rbtx4938/irq.c
index 67a73a8065ec..2ec4fe1b1670 100644
--- a/arch/mips/txx9/rbtx4938/irq.c
+++ b/arch/mips/txx9/rbtx4938/irq.c
@@ -69,18 +69,6 @@
 #include <asm/txx9/generic.h>
 #include <asm/txx9/rbtx4938.h>
 
-static void toshiba_rbtx4938_irq_ioc_enable(unsigned int irq);
-static void toshiba_rbtx4938_irq_ioc_disable(unsigned int irq);
-
-#define TOSHIBA_RBTX4938_IOC_NAME "RBTX4938-IOC"
-static struct irq_chip toshiba_rbtx4938_irq_ioc_type = {
-	.name = TOSHIBA_RBTX4938_IOC_NAME,
-	.ack = toshiba_rbtx4938_irq_ioc_disable,
-	.mask = toshiba_rbtx4938_irq_ioc_disable,
-	.mask_ack = toshiba_rbtx4938_irq_ioc_disable,
-	.unmask = toshiba_rbtx4938_irq_ioc_enable,
-};
-
 static int toshiba_rbtx4938_irq_nested(int sw_irq)
 {
 	u8 level3;
@@ -92,41 +80,33 @@ static int toshiba_rbtx4938_irq_nested(int sw_irq)
 	return RBTX4938_IRQ_IOC + __fls8(level3);
 }
 
-static void __init
-toshiba_rbtx4938_irq_ioc_init(void)
-{
-	int i;
-
-	for (i = RBTX4938_IRQ_IOC;
-	     i < RBTX4938_IRQ_IOC + RBTX4938_NR_IRQ_IOC; i++)
-		set_irq_chip_and_handler(i, &toshiba_rbtx4938_irq_ioc_type,
-					 handle_level_irq);
-
-	set_irq_chained_handler(RBTX4938_IRQ_IOCINT, handle_simple_irq);
-}
-
-static void
-toshiba_rbtx4938_irq_ioc_enable(unsigned int irq)
+static void toshiba_rbtx4938_irq_ioc_enable(struct irq_data *d)
 {
 	unsigned char v;
 
 	v = readb(rbtx4938_imask_addr);
-	v |= (1 << (irq - RBTX4938_IRQ_IOC));
+	v |= (1 << (d->irq - RBTX4938_IRQ_IOC));
 	writeb(v, rbtx4938_imask_addr);
 	mmiowb();
 }
 
-static void
-toshiba_rbtx4938_irq_ioc_disable(unsigned int irq)
+static void toshiba_rbtx4938_irq_ioc_disable(struct irq_data *d)
 {
 	unsigned char v;
 
 	v = readb(rbtx4938_imask_addr);
-	v &= ~(1 << (irq - RBTX4938_IRQ_IOC));
+	v &= ~(1 << (d->irq - RBTX4938_IRQ_IOC));
 	writeb(v, rbtx4938_imask_addr);
 	mmiowb();
 }
 
+#define TOSHIBA_RBTX4938_IOC_NAME "RBTX4938-IOC"
+static struct irq_chip toshiba_rbtx4938_irq_ioc_type = {
+	.name = TOSHIBA_RBTX4938_IOC_NAME,
+	.irq_mask = toshiba_rbtx4938_irq_ioc_disable,
+	.irq_unmask = toshiba_rbtx4938_irq_ioc_enable,
+};
+
 static int rbtx4938_irq_dispatch(int pending)
 {
 	int irq;
@@ -146,6 +126,18 @@ static int rbtx4938_irq_dispatch(int pending)
 	return irq;
 }
 
+static void __init toshiba_rbtx4938_irq_ioc_init(void)
+{
+	int i;
+
+	for (i = RBTX4938_IRQ_IOC;
+	     i < RBTX4938_IRQ_IOC + RBTX4938_NR_IRQ_IOC; i++)
+		set_irq_chip_and_handler(i, &toshiba_rbtx4938_irq_ioc_type,
+					 handle_level_irq);
+
+	set_irq_chained_handler(RBTX4938_IRQ_IOCINT, handle_simple_irq);
+}
+
 void __init rbtx4938_irq_setup(void)
 {
 	txx9_irq_dispatch = rbtx4938_irq_dispatch;

commit ca4d3e6746bdcfccb517349bce2d2c5b5614fb6f
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 7 14:08:54 2010 +0100

    MIPS: Add missing #inclusions of <linux/irq.h>
    
    Add missing #inclusions of <linux/irq.h> to a whole bunch of files that should
    really include it.  Note that this can replace #inclusions of <asm/irq.h>.
    
    This is required for the patch to sort out irqflags handling function naming to
    compile on MIPS.
    
    The problem is that these files require access to things like setup_irq() -
    which isn't available by #including <linux/interrupt.h>
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/irq.c b/arch/mips/txx9/rbtx4938/irq.c
index 7d21befb8932..67a73a8065ec 100644
--- a/arch/mips/txx9/rbtx4938/irq.c
+++ b/arch/mips/txx9/rbtx4938/irq.c
@@ -64,6 +64,7 @@
  */
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <linux/irq.h>
 #include <asm/mipsregs.h>
 #include <asm/txx9/generic.h>
 #include <asm/txx9/rbtx4938.h>

commit 21e77df215e58523a755b5dd006cb17610616f20
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Sep 1 22:22:37 2008 +0900

    MIPS: TXx9: Microoptimize interrupt handlers
    
    The IOC interrupt status register on RBTX49XX only have 8 bits.  Use
    8-bit version of __fls() to optimize interrupt handlers.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/irq.c b/arch/mips/txx9/rbtx4938/irq.c
index ca2f8306ce93..7d21befb8932 100644
--- a/arch/mips/txx9/rbtx4938/irq.c
+++ b/arch/mips/txx9/rbtx4938/irq.c
@@ -85,10 +85,10 @@ static int toshiba_rbtx4938_irq_nested(int sw_irq)
 	u8 level3;
 
 	level3 = readb(rbtx4938_imstat_addr);
-	if (level3)
-		/* must use fls so onboard ATA has priority */
-		sw_irq = RBTX4938_IRQ_IOC + fls(level3) - 1;
-	return sw_irq;
+	if (unlikely(!level3))
+		return -1;
+	/* must use fls so onboard ATA has priority */
+	return RBTX4938_IRQ_IOC + __fls8(level3);
 }
 
 static void __init

commit bb72f1f729dcbd6a6a93c74479eeaa19deebfb47
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:21 2008 +0900

    [MIPS] TXx9: Random cleanup
    
    * Random cleanups spotted by checkpatch script.
    * Do not initialize panic_timeout.  "panic=" kernel parameter can be used.
    * Do not add "ip=any" or "ip=bootp".  This options is not board specific.
    * Do not add "root=/dev/nfs".  This is default on CONFIG_ROOT_NFS.
    * Kill unused error checking.
    * Fix IRQ comment to match current code.
    * Kill some unneeded includes
    * ST0_ERL is already cleared in generic code.
    * conswitchp is initialized generic code.
    * __init is not needed in prototype.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/irq.c b/arch/mips/txx9/rbtx4938/irq.c
index 3971a061657a..ca2f8306ce93 100644
--- a/arch/mips/txx9/rbtx4938/irq.c
+++ b/arch/mips/txx9/rbtx4938/irq.c
@@ -11,59 +11,57 @@
  */
 
 /*
-IRQ  Device
-
-16   TX4938-CP0/00 Software 0
-17   TX4938-CP0/01 Software 1
-18   TX4938-CP0/02 Cascade TX4938-CP0
-19   TX4938-CP0/03 Multiplexed -- do not use
-20   TX4938-CP0/04 Multiplexed -- do not use
-21   TX4938-CP0/05 Multiplexed -- do not use
-22   TX4938-CP0/06 Multiplexed -- do not use
-23   TX4938-CP0/07 CPU TIMER
-
-24   TX4938-PIC/00
-25   TX4938-PIC/01
-26   TX4938-PIC/02 Cascade RBTX4938-IOC
-27   TX4938-PIC/03 RBTX4938 RTL-8019AS Ethernet
-28   TX4938-PIC/04
-29   TX4938-PIC/05 TX4938 ETH1
-30   TX4938-PIC/06 TX4938 ETH0
-31   TX4938-PIC/07
-32   TX4938-PIC/08 TX4938 SIO 0
-33   TX4938-PIC/09 TX4938 SIO 1
-34   TX4938-PIC/10 TX4938 DMA0
-35   TX4938-PIC/11 TX4938 DMA1
-36   TX4938-PIC/12 TX4938 DMA2
-37   TX4938-PIC/13 TX4938 DMA3
-38   TX4938-PIC/14
-39   TX4938-PIC/15
-40   TX4938-PIC/16 TX4938 PCIC
-41   TX4938-PIC/17 TX4938 TMR0
-42   TX4938-PIC/18 TX4938 TMR1
-43   TX4938-PIC/19 TX4938 TMR2
-44   TX4938-PIC/20
-45   TX4938-PIC/21
-46   TX4938-PIC/22 TX4938 PCIERR
-47   TX4938-PIC/23
-48   TX4938-PIC/24
-49   TX4938-PIC/25
-50   TX4938-PIC/26
-51   TX4938-PIC/27
-52   TX4938-PIC/28
-53   TX4938-PIC/29
-54   TX4938-PIC/30
-55   TX4938-PIC/31 TX4938 SPI
-
-56 RBTX4938-IOC/00 PCI-D
-57 RBTX4938-IOC/01 PCI-C
-58 RBTX4938-IOC/02 PCI-B
-59 RBTX4938-IOC/03 PCI-A
-60 RBTX4938-IOC/04 RTC
-61 RBTX4938-IOC/05 ATA
-62 RBTX4938-IOC/06 MODEM
-63 RBTX4938-IOC/07 SWINT
-*/
+ * MIPS_CPU_IRQ_BASE+00 Software 0
+ * MIPS_CPU_IRQ_BASE+01 Software 1
+ * MIPS_CPU_IRQ_BASE+02 Cascade TX4938-CP0
+ * MIPS_CPU_IRQ_BASE+03 Multiplexed -- do not use
+ * MIPS_CPU_IRQ_BASE+04 Multiplexed -- do not use
+ * MIPS_CPU_IRQ_BASE+05 Multiplexed -- do not use
+ * MIPS_CPU_IRQ_BASE+06 Multiplexed -- do not use
+ * MIPS_CPU_IRQ_BASE+07 CPU TIMER
+ *
+ * TXX9_IRQ_BASE+00
+ * TXX9_IRQ_BASE+01
+ * TXX9_IRQ_BASE+02 Cascade RBTX4938-IOC
+ * TXX9_IRQ_BASE+03 RBTX4938 RTL-8019AS Ethernet
+ * TXX9_IRQ_BASE+04
+ * TXX9_IRQ_BASE+05 TX4938 ETH1
+ * TXX9_IRQ_BASE+06 TX4938 ETH0
+ * TXX9_IRQ_BASE+07
+ * TXX9_IRQ_BASE+08 TX4938 SIO 0
+ * TXX9_IRQ_BASE+09 TX4938 SIO 1
+ * TXX9_IRQ_BASE+10 TX4938 DMA0
+ * TXX9_IRQ_BASE+11 TX4938 DMA1
+ * TXX9_IRQ_BASE+12 TX4938 DMA2
+ * TXX9_IRQ_BASE+13 TX4938 DMA3
+ * TXX9_IRQ_BASE+14
+ * TXX9_IRQ_BASE+15
+ * TXX9_IRQ_BASE+16 TX4938 PCIC
+ * TXX9_IRQ_BASE+17 TX4938 TMR0
+ * TXX9_IRQ_BASE+18 TX4938 TMR1
+ * TXX9_IRQ_BASE+19 TX4938 TMR2
+ * TXX9_IRQ_BASE+20
+ * TXX9_IRQ_BASE+21
+ * TXX9_IRQ_BASE+22 TX4938 PCIERR
+ * TXX9_IRQ_BASE+23
+ * TXX9_IRQ_BASE+24
+ * TXX9_IRQ_BASE+25
+ * TXX9_IRQ_BASE+26
+ * TXX9_IRQ_BASE+27
+ * TXX9_IRQ_BASE+28
+ * TXX9_IRQ_BASE+29
+ * TXX9_IRQ_BASE+30
+ * TXX9_IRQ_BASE+31 TX4938 SPI
+ *
+ * RBTX4938_IRQ_IOC+00 PCI-D
+ * RBTX4938_IRQ_IOC+01 PCI-C
+ * RBTX4938_IRQ_IOC+02 PCI-B
+ * RBTX4938_IRQ_IOC+03 PCI-A
+ * RBTX4938_IRQ_IOC+04 RTC
+ * RBTX4938_IRQ_IOC+05 ATA
+ * RBTX4938_IRQ_IOC+06 MODEM
+ * RBTX4938_IRQ_IOC+07 SWINT
+ */
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <asm/mipsregs.h>
@@ -93,9 +91,6 @@ static int toshiba_rbtx4938_irq_nested(int sw_irq)
 	return sw_irq;
 }
 
-/**********************************************************************************/
-/* Functions for ioc                                                              */
-/**********************************************************************************/
 static void __init
 toshiba_rbtx4938_irq_ioc_init(void)
 {

commit edcaf1a6a77315562e9781245cc8e028c9a921dc
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 23:27:54 2008 +0900

    [MIPS] TXx9: Make single kernel can support multiple boards
    
    Make single kernel can be used on RBTX4927/37/38.  Also make
    some SoC-specific code independent from board-specific code.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/irq.c b/arch/mips/txx9/rbtx4938/irq.c
index f4984820251a..3971a061657a 100644
--- a/arch/mips/txx9/rbtx4938/irq.c
+++ b/arch/mips/txx9/rbtx4938/irq.c
@@ -66,6 +66,8 @@ IRQ  Device
 */
 #include <linux/init.h>
 #include <linux/interrupt.h>
+#include <asm/mipsregs.h>
+#include <asm/txx9/generic.h>
 #include <asm/txx9/rbtx4938.h>
 
 static void toshiba_rbtx4938_irq_ioc_enable(unsigned int irq);
@@ -80,26 +82,17 @@ static struct irq_chip toshiba_rbtx4938_irq_ioc_type = {
 	.unmask = toshiba_rbtx4938_irq_ioc_enable,
 };
 
-int
-toshiba_rbtx4938_irq_nested(int sw_irq)
+static int toshiba_rbtx4938_irq_nested(int sw_irq)
 {
 	u8 level3;
 
 	level3 = readb(rbtx4938_imstat_addr);
 	if (level3)
 		/* must use fls so onboard ATA has priority */
-		sw_irq = TOSHIBA_RBTX4938_IRQ_IOC_BEG + fls(level3) - 1;
-
+		sw_irq = RBTX4938_IRQ_IOC + fls(level3) - 1;
 	return sw_irq;
 }
 
-static struct irqaction toshiba_rbtx4938_irq_ioc_action = {
-	.handler = no_action,
-	.flags = 0,
-	.mask = CPU_MASK_NONE,
-	.name = TOSHIBA_RBTX4938_IOC_NAME,
-};
-
 /**********************************************************************************/
 /* Functions for ioc                                                              */
 /**********************************************************************************/
@@ -108,13 +101,12 @@ toshiba_rbtx4938_irq_ioc_init(void)
 {
 	int i;
 
-	for (i = TOSHIBA_RBTX4938_IRQ_IOC_BEG;
-	     i <= TOSHIBA_RBTX4938_IRQ_IOC_END; i++)
+	for (i = RBTX4938_IRQ_IOC;
+	     i < RBTX4938_IRQ_IOC + RBTX4938_NR_IRQ_IOC; i++)
 		set_irq_chip_and_handler(i, &toshiba_rbtx4938_irq_ioc_type,
 					 handle_level_irq);
 
-	setup_irq(RBTX4938_IRQ_IOCINT,
-		  &toshiba_rbtx4938_irq_ioc_action);
+	set_irq_chained_handler(RBTX4938_IRQ_IOCINT, handle_simple_irq);
 }
 
 static void
@@ -123,7 +115,7 @@ toshiba_rbtx4938_irq_ioc_enable(unsigned int irq)
 	unsigned char v;
 
 	v = readb(rbtx4938_imask_addr);
-	v |= (1 << (irq - TOSHIBA_RBTX4938_IRQ_IOC_BEG));
+	v |= (1 << (irq - RBTX4938_IRQ_IOC));
 	writeb(v, rbtx4938_imask_addr);
 	mmiowb();
 }
@@ -134,15 +126,33 @@ toshiba_rbtx4938_irq_ioc_disable(unsigned int irq)
 	unsigned char v;
 
 	v = readb(rbtx4938_imask_addr);
-	v &= ~(1 << (irq - TOSHIBA_RBTX4938_IRQ_IOC_BEG));
+	v &= ~(1 << (irq - RBTX4938_IRQ_IOC));
 	writeb(v, rbtx4938_imask_addr);
 	mmiowb();
 }
 
-void __init arch_init_irq(void)
+static int rbtx4938_irq_dispatch(int pending)
 {
-	extern void tx4938_irq_init(void);
+	int irq;
+
+	if (pending & STATUSF_IP7)
+		irq = MIPS_CPU_IRQ_BASE + 7;
+	else if (pending & STATUSF_IP2) {
+		irq = txx9_irq();
+		if (irq == RBTX4938_IRQ_IOCINT)
+			irq = toshiba_rbtx4938_irq_nested(irq);
+	} else if (pending & STATUSF_IP1)
+		irq = MIPS_CPU_IRQ_BASE + 0;
+	else if (pending & STATUSF_IP0)
+		irq = MIPS_CPU_IRQ_BASE + 1;
+	else
+		irq = -1;
+	return irq;
+}
 
+void __init rbtx4938_irq_setup(void)
+{
+	txx9_irq_dispatch = rbtx4938_irq_dispatch;
 	/* Now, interrupt control disabled, */
 	/* all IRC interrupts are masked, */
 	/* all IRC interrupt mode are Low Active. */

commit 22b1d707ffc99faebd86257ad19d5bb9fc624734
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 00:31:36 2008 +0900

    [MIPS] TXx9: Reorganize code
    
    Move arch/mips/{jmr3927,tx4927,tx4938} into arch/mips/txx9/ tree.
    This will help more code sharing and maintainance.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/irq.c b/arch/mips/txx9/rbtx4938/irq.c
new file mode 100644
index 000000000000..f4984820251a
--- /dev/null
+++ b/arch/mips/txx9/rbtx4938/irq.c
@@ -0,0 +1,159 @@
+/*
+ * Toshiba RBTX4938 specific interrupt handlers
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+
+/*
+IRQ  Device
+
+16   TX4938-CP0/00 Software 0
+17   TX4938-CP0/01 Software 1
+18   TX4938-CP0/02 Cascade TX4938-CP0
+19   TX4938-CP0/03 Multiplexed -- do not use
+20   TX4938-CP0/04 Multiplexed -- do not use
+21   TX4938-CP0/05 Multiplexed -- do not use
+22   TX4938-CP0/06 Multiplexed -- do not use
+23   TX4938-CP0/07 CPU TIMER
+
+24   TX4938-PIC/00
+25   TX4938-PIC/01
+26   TX4938-PIC/02 Cascade RBTX4938-IOC
+27   TX4938-PIC/03 RBTX4938 RTL-8019AS Ethernet
+28   TX4938-PIC/04
+29   TX4938-PIC/05 TX4938 ETH1
+30   TX4938-PIC/06 TX4938 ETH0
+31   TX4938-PIC/07
+32   TX4938-PIC/08 TX4938 SIO 0
+33   TX4938-PIC/09 TX4938 SIO 1
+34   TX4938-PIC/10 TX4938 DMA0
+35   TX4938-PIC/11 TX4938 DMA1
+36   TX4938-PIC/12 TX4938 DMA2
+37   TX4938-PIC/13 TX4938 DMA3
+38   TX4938-PIC/14
+39   TX4938-PIC/15
+40   TX4938-PIC/16 TX4938 PCIC
+41   TX4938-PIC/17 TX4938 TMR0
+42   TX4938-PIC/18 TX4938 TMR1
+43   TX4938-PIC/19 TX4938 TMR2
+44   TX4938-PIC/20
+45   TX4938-PIC/21
+46   TX4938-PIC/22 TX4938 PCIERR
+47   TX4938-PIC/23
+48   TX4938-PIC/24
+49   TX4938-PIC/25
+50   TX4938-PIC/26
+51   TX4938-PIC/27
+52   TX4938-PIC/28
+53   TX4938-PIC/29
+54   TX4938-PIC/30
+55   TX4938-PIC/31 TX4938 SPI
+
+56 RBTX4938-IOC/00 PCI-D
+57 RBTX4938-IOC/01 PCI-C
+58 RBTX4938-IOC/02 PCI-B
+59 RBTX4938-IOC/03 PCI-A
+60 RBTX4938-IOC/04 RTC
+61 RBTX4938-IOC/05 ATA
+62 RBTX4938-IOC/06 MODEM
+63 RBTX4938-IOC/07 SWINT
+*/
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <asm/txx9/rbtx4938.h>
+
+static void toshiba_rbtx4938_irq_ioc_enable(unsigned int irq);
+static void toshiba_rbtx4938_irq_ioc_disable(unsigned int irq);
+
+#define TOSHIBA_RBTX4938_IOC_NAME "RBTX4938-IOC"
+static struct irq_chip toshiba_rbtx4938_irq_ioc_type = {
+	.name = TOSHIBA_RBTX4938_IOC_NAME,
+	.ack = toshiba_rbtx4938_irq_ioc_disable,
+	.mask = toshiba_rbtx4938_irq_ioc_disable,
+	.mask_ack = toshiba_rbtx4938_irq_ioc_disable,
+	.unmask = toshiba_rbtx4938_irq_ioc_enable,
+};
+
+int
+toshiba_rbtx4938_irq_nested(int sw_irq)
+{
+	u8 level3;
+
+	level3 = readb(rbtx4938_imstat_addr);
+	if (level3)
+		/* must use fls so onboard ATA has priority */
+		sw_irq = TOSHIBA_RBTX4938_IRQ_IOC_BEG + fls(level3) - 1;
+
+	return sw_irq;
+}
+
+static struct irqaction toshiba_rbtx4938_irq_ioc_action = {
+	.handler = no_action,
+	.flags = 0,
+	.mask = CPU_MASK_NONE,
+	.name = TOSHIBA_RBTX4938_IOC_NAME,
+};
+
+/**********************************************************************************/
+/* Functions for ioc                                                              */
+/**********************************************************************************/
+static void __init
+toshiba_rbtx4938_irq_ioc_init(void)
+{
+	int i;
+
+	for (i = TOSHIBA_RBTX4938_IRQ_IOC_BEG;
+	     i <= TOSHIBA_RBTX4938_IRQ_IOC_END; i++)
+		set_irq_chip_and_handler(i, &toshiba_rbtx4938_irq_ioc_type,
+					 handle_level_irq);
+
+	setup_irq(RBTX4938_IRQ_IOCINT,
+		  &toshiba_rbtx4938_irq_ioc_action);
+}
+
+static void
+toshiba_rbtx4938_irq_ioc_enable(unsigned int irq)
+{
+	unsigned char v;
+
+	v = readb(rbtx4938_imask_addr);
+	v |= (1 << (irq - TOSHIBA_RBTX4938_IRQ_IOC_BEG));
+	writeb(v, rbtx4938_imask_addr);
+	mmiowb();
+}
+
+static void
+toshiba_rbtx4938_irq_ioc_disable(unsigned int irq)
+{
+	unsigned char v;
+
+	v = readb(rbtx4938_imask_addr);
+	v &= ~(1 << (irq - TOSHIBA_RBTX4938_IRQ_IOC_BEG));
+	writeb(v, rbtx4938_imask_addr);
+	mmiowb();
+}
+
+void __init arch_init_irq(void)
+{
+	extern void tx4938_irq_init(void);
+
+	/* Now, interrupt control disabled, */
+	/* all IRC interrupts are masked, */
+	/* all IRC interrupt mode are Low Active. */
+
+	/* mask all IOC interrupts */
+	writeb(0, rbtx4938_imask_addr);
+
+	/* clear SoftInt interrupts */
+	writeb(0, rbtx4938_softint_addr);
+	tx4938_irq_init();
+	toshiba_rbtx4938_irq_ioc_init();
+	/* Onboard 10M Ether: High Active */
+	set_irq_type(RBTX4938_IRQ_ETHER, IRQF_TRIGGER_HIGH);
+}
