commit 2cec11d871814cd65702ccd3591232ee9f185360
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Dec 7 10:05:15 2016 +0100

    MIPS: TXx9: Modernize printing of kernel messages
    
    - Convert from printk() to pr_*(),
      - Add missing continuations, to fix user-visible breakage,
      - Drop superfluous casts (u64 has been unsigned long long on all
        architectures for many years).
    
    On rbtx4927, this restores the kernel output like:
    
        -TX4927 SDRAMC --
        - CR0:0000007e00000544
        - TR:32800030e
        +TX4927 SDRAMC -- CR0:0000007e00000544 TR:32800030e
    
    and:
    
        -PCIC -- PCICLK:
        -Internal(33.3MHz)
        -
        +PCIC -- PCICLK:Internal(33.3MHz)
    
    Fixes: 4bcc595ccd80decb ("printk: reinstate KERN_CONT for printing continuation lines")
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Reviewed-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/14646/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 07939ed6b22f..e68eb2e7ce0c 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -123,15 +123,15 @@ static int __init rbtx4938_ethaddr_init(void)
 
 	/* 0-3: "MAC\0", 4-9:eth0, 10-15:eth1, 16:sum */
 	if (spi_eeprom_read(SPI_BUSNO, SEEPROM1_CS, 0, dat, sizeof(dat))) {
-		printk(KERN_ERR "seeprom: read error.\n");
+		pr_err("seeprom: read error.\n");
 		return -ENODEV;
 	} else {
 		if (strcmp(dat, "MAC") != 0)
-			printk(KERN_WARNING "seeprom: bad signature.\n");
+			pr_warn("seeprom: bad signature.\n");
 		for (i = 0, sum = 0; i < sizeof(dat); i++)
 			sum += dat[i];
 		if (sum)
-			printk(KERN_WARNING "seeprom: bad checksum.\n");
+			pr_warn("seeprom: bad checksum.\n");
 	}
 	tx4938_ethaddr_init(&dat[4], &dat[4 + 6]);
 #endif /* CONFIG_PCI */
@@ -214,14 +214,14 @@ static void __init rbtx4938_mem_setup(void)
 	rbtx4938_fpga_resource.end = CPHYSADDR(RBTX4938_FPGA_REG_ADDR) + 0xffff;
 	rbtx4938_fpga_resource.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
 	if (request_resource(&txx9_ce_res[2], &rbtx4938_fpga_resource))
-		printk(KERN_ERR "request resource for fpga failed\n");
+		pr_err("request resource for fpga failed\n");
 
 	_machine_restart = rbtx4938_machine_restart;
 
 	writeb(0xff, rbtx4938_led_addr);
-	printk(KERN_INFO "RBTX4938 --- FPGA(Rev %02x) DIPSW:%02x,%02x\n",
-	       readb(rbtx4938_fpga_rev_addr),
-	       readb(rbtx4938_dipsw_addr), readb(rbtx4938_bdipsw_addr));
+	pr_info("RBTX4938 --- FPGA(Rev %02x) DIPSW:%02x,%02x\n",
+		readb(rbtx4938_fpga_rev_addr),
+		readb(rbtx4938_dipsw_addr), readb(rbtx4938_bdipsw_addr));
 }
 
 static void __init rbtx4938_ne_init(void)

commit 5ac676ade1eac27fb311f0f2fb11eeac5089a66c
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Sep 11 10:48:33 2016 +0200

    MIPS: TXx9: tx49xx: Move GPIO setup from .mem_setup() to .arch_init()
    
    txx9_gpio_init() calls gpiochip_add_data(), which fails with -ENOMEM as
    it is called too early in the boot process. This causes all subsequent
    GPIO operations to fail silently (before commit 54d77198fdfbc4f0 ("gpio:
    bail out silently on NULL descriptors") it printed the error message
    "gpiod_direction_output_raw: invalid GPIO" on RBTX49[23]7).
    
    Postpone all GPIO setup to .arch_init() time to fix this.
    
    Suggested-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Acked-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-gpio@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/14237/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 54de66837103..07939ed6b22f 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -336,6 +336,7 @@ static void __init rbtx4938_mtd_init(void)
 
 static void __init rbtx4938_arch_init(void)
 {
+	txx9_gpio_init(TX4938_PIO_REG & 0xfffffffffULL, 0, TX4938_NUM_PIO);
 	gpiochip_add_data(&rbtx4938_spi_gpio_chip, NULL);
 	rbtx4938_pci_setup();
 	rbtx4938_spi_init();

commit ff53d12c50c8b5cbc652787ab4512d269ea09a64
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 8 14:43:48 2015 +0100

    MIPS: txx9: rbtx4938: switch to gpiochip_add_data()
    
    We're planning to remove the gpiochip_add() function to swith
    to gpiochip_add_data() with NULL for data argument.
    
    Cc: linux-mips@linux-mips.org
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index c9afd05020e0..54de66837103 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -14,6 +14,7 @@
 #include <linux/ioport.h>
 #include <linux/delay.h>
 #include <linux/platform_device.h>
+#include <linux/gpio/driver.h>
 #include <linux/gpio.h>
 #include <linux/mtd/physmap.h>
 
@@ -335,7 +336,7 @@ static void __init rbtx4938_mtd_init(void)
 
 static void __init rbtx4938_arch_init(void)
 {
-	gpiochip_add(&rbtx4938_spi_gpio_chip);
+	gpiochip_add_data(&rbtx4938_spi_gpio_chip, NULL);
 	rbtx4938_pci_setup();
 	rbtx4938_spi_init();
 }

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index d6e70dab3bd3..c9afd05020e0 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -107,10 +107,10 @@ static void __init rbtx4938_pci_setup(void)
 /* SPI support */
 
 /* chip select for SPI devices */
-#define	SEEPROM1_CS	7	/* PIO7 */
-#define	SEEPROM2_CS	0	/* IOC */
-#define	SEEPROM3_CS	1	/* IOC */
-#define	SRTC_CS	2	/* IOC */
+#define SEEPROM1_CS	7	/* PIO7 */
+#define SEEPROM2_CS	0	/* IOC */
+#define SEEPROM3_CS	1	/* IOC */
+#define SRTC_CS 2	/* IOC */
 #define SPI_BUSNO	0
 
 static int __init rbtx4938_ethaddr_init(void)

commit ab4ba291683d07038c7ddf1eec191d3d09e1f468
Author: Yoichi Yuasa <yuasa@linux-mips.org>
Date:   Tue Feb 2 18:40:04 2010 +0900

    MIPS: TXx9: Remove forced serial console setting
    
    It is not always used, even if it is available.
    
    Signed-off-by: Yoichi Yuasa <yuasa@linux-mips.org>
    Cc: linux-mips <linux-mips@linux-mips.org>
    Patchwork: http://patchwork.linux-mips.org/patch/933/
    Acked-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index d66509b14284..d6e70dab3bd3 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -153,7 +153,6 @@ static void __init rbtx4938_time_init(void)
 static void __init rbtx4938_mem_setup(void)
 {
 	unsigned long long pcfg;
-	char *argptr;
 
 	if (txx9_master_clock == 0)
 		txx9_master_clock = 25000000; /* 25MHz */
@@ -168,11 +167,6 @@ static void __init rbtx4938_mem_setup(void)
 #endif
 
 	tx4938_sio_init(7372800, 0);
-#ifdef CONFIG_SERIAL_TXX9_CONSOLE
-	argptr = prom_getcmdline();
-	if (!strstr(argptr, "console="))
-		strcat(argptr, " console=ttyS0,38400");
-#endif
 
 #ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_PIO58_61
 	pr_info("PIOSEL: disabling both ATA and NAND selection\n");

commit c3b28ae260d99a5364a31210a36a3246bd9647f7
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon May 25 22:04:02 2009 +0900

    MIPS: TXx9: Add SRAMC support
    
    Add a sysdev to access SRAM in TXx9 SoCs via sysfs.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 8da66e956ee6..d66509b14284 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -358,6 +358,7 @@ static void __init rbtx4938_device_init(void)
 	tx4938_dmac_init(0, 2);
 	tx4938_aclc_init();
 	platform_device_register_simple("txx9aclc-generic", -1, NULL, 0);
+	tx4938_sramc_init();
 	txx9_iocled_init(RBTX4938_LED_ADDR - IO_BASE, -1, 8, 1, "green", NULL);
 }
 

commit 742cd5867b2ef7ce865d7ab67574c4e3aa1fb155
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue May 19 22:12:22 2009 +0900

    MIPS: TXx9: Add ACLC support
    
    Add platform support for ACLC of TXx9 SoCs.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Acked-by: Mark Brown <broonie@opensource.wolfsonmicro.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 37c5e3d20287..8da66e956ee6 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -356,6 +356,8 @@ static void __init rbtx4938_device_init(void)
 	tx4938_ndfmc_init(10, 35);
 	tx4938_ata_init(RBTX4938_IRQ_IOC_ATA, 0, 1);
 	tx4938_dmac_init(0, 2);
+	tx4938_aclc_init();
+	platform_device_register_simple("txx9aclc-generic", -1, NULL, 0);
 	txx9_iocled_init(RBTX4938_LED_ADDR - IO_BASE, -1, 8, 1, "green", NULL);
 }
 

commit f48c8c958a2d39f13dace880d15a6e711aafe577
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Apr 23 00:40:31 2009 +0900

    MIPS: TXx9: Add DMAC support
    
    Add platform support for DMAC of TXx9 SoCs.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 65d13df8878a..37c5e3d20287 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -355,6 +355,7 @@ static void __init rbtx4938_device_init(void)
 	/* TC58DVM82A1FT: tDH=10ns, tWP=tRP=tREADID=35ns */
 	tx4938_ndfmc_init(10, 35);
 	tx4938_ata_init(RBTX4938_IRQ_IOC_ATA, 0, 1);
+	tx4938_dmac_init(0, 2);
 	txx9_iocled_init(RBTX4938_LED_ADDR - IO_BASE, -1, 8, 1, "green", NULL);
 }
 

commit a591f5d35e89be90c04830d7de01c276af68aeb7
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Wed Mar 4 12:01:31 2009 -0800

    [MTD] [NAND] TXx9: add NDFMC support
    
    Add platform support for NAND Flash Memory Controller of TXx9 SoCs.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Acked-By: Ralf BÃ¤chle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 547ff2920bf0..65d13df8878a 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -352,6 +352,8 @@ static void __init rbtx4938_device_init(void)
 	rbtx4938_ne_init();
 	tx4938_wdt_init();
 	rbtx4938_mtd_init();
+	/* TC58DVM82A1FT: tDH=10ns, tWP=tRP=tREADID=35ns */
+	tx4938_ndfmc_init(10, 35);
 	tx4938_ata_init(RBTX4938_IRQ_IOC_ATA, 0, 1);
 	txx9_iocled_init(RBTX4938_LED_ADDR - IO_BASE, -1, 8, 1, "green", NULL);
 }

commit 5d1d2f8c26f2d197df1f4b6a7f4c0088b190343e
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Oct 23 23:22:08 2008 +0200

    TXx9: Add TX4938 ATA support (v3)
    
    Add a helper routine to register tx4938ide driver and use it on
    RBTX4938 board.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index e077cc4d3a59..547ff2920bf0 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -352,6 +352,7 @@ static void __init rbtx4938_device_init(void)
 	rbtx4938_ne_init();
 	tx4938_wdt_init();
 	rbtx4938_mtd_init();
+	tx4938_ata_init(RBTX4938_IRQ_IOC_ATA, 0, 1);
 	txx9_iocled_init(RBTX4938_LED_ADDR - IO_BASE, -1, 8, 1, "green", NULL);
 }
 

commit ae027ead87b13cff99b4f48da7696aa4fe75393b
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Sep 1 22:22:38 2008 +0900

    MIPS: TXx9: IOC LED support
    
    Add leds-gpio platform device for controlling LEDs connected to IOC on
    RBTX49XX and JMR3927 board.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index ec6e81258f73..e077cc4d3a59 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -352,6 +352,7 @@ static void __init rbtx4938_device_init(void)
 	rbtx4938_ne_init();
 	tx4938_wdt_init();
 	rbtx4938_mtd_init();
+	txx9_iocled_init(RBTX4938_LED_ADDR - IO_BASE, -1, 8, 1, "green", NULL);
 }
 
 struct txx9_board_vec rbtx4938_vec __initdata = {

commit d75a40e90e9eb08c2159e719a90a7922dab231d3
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Aug 19 22:55:14 2008 +0900

    MIPS: TXx9: Make spi_eeprom.c more generic
    
    Helper routines in txx9/rbtx4938/spi_eeprom.c is not TX4938 specific.
    Move it to txx9/generic/ directory and make it works with SPI bus
    number other than 0.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
     create mode 100644 arch/mips/txx9/generic/spi_eeprom.c
     delete mode 100644 arch/mips/txx9/rbtx4938/spi_eeprom.c

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 7aba92a12399..ec6e81258f73 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -111,6 +111,7 @@ static void __init rbtx4938_pci_setup(void)
 #define	SEEPROM2_CS	0	/* IOC */
 #define	SEEPROM3_CS	1	/* IOC */
 #define	SRTC_CS	2	/* IOC */
+#define SPI_BUSNO	0
 
 static int __init rbtx4938_ethaddr_init(void)
 {
@@ -120,7 +121,7 @@ static int __init rbtx4938_ethaddr_init(void)
 	int i;
 
 	/* 0-3: "MAC\0", 4-9:eth0, 10-15:eth1, 16:sum */
-	if (spi_eeprom_read(SEEPROM1_CS, 0, dat, sizeof(dat))) {
+	if (spi_eeprom_read(SPI_BUSNO, SEEPROM1_CS, 0, dat, sizeof(dat))) {
 		printk(KERN_ERR "seeprom: read error.\n");
 		return -ENODEV;
 	} else {
@@ -287,9 +288,9 @@ static int __init rbtx4938_spi_init(void)
 		.mode = SPI_MODE_1 | SPI_CS_HIGH,
 	};
 	spi_register_board_info(&srtc_info, 1);
-	spi_eeprom_register(SEEPROM1_CS);
-	spi_eeprom_register(16 + SEEPROM2_CS);
-	spi_eeprom_register(16 + SEEPROM3_CS);
+	spi_eeprom_register(SPI_BUSNO, SEEPROM1_CS, 128);
+	spi_eeprom_register(SPI_BUSNO, 16 + SEEPROM2_CS, 128);
+	spi_eeprom_register(SPI_BUSNO, 16 + SEEPROM3_CS, 128);
 	gpio_request(16 + SRTC_CS, "rtc-rs5c348");
 	gpio_direction_output(16 + SRTC_CS, 0);
 	gpio_request(SEEPROM1_CS, "seeprom1");
@@ -298,7 +299,7 @@ static int __init rbtx4938_spi_init(void)
 	gpio_direction_output(16 + SEEPROM2_CS, 1);
 	gpio_request(16 + SEEPROM3_CS, "seeprom3");
 	gpio_direction_output(16 + SEEPROM3_CS, 1);
-	tx4938_spi_init(0);
+	tx4938_spi_init(SPI_BUSNO);
 	return 0;
 }
 

commit e6332374770ae5aa370af5792115261edbad05c1
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Aug 19 22:55:13 2008 +0900

    MIPS: RBTX4938: Add TOSHIBA_RBTX4938_MPLEX_KEEP
    
    Add TOSHIBA_RBTX4938_MPLEX_KEEP to keep MPLEX settings by firmware.
    Also replace some printk with pr_info.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index e7bc5b8c7db8..7aba92a12399 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -174,23 +174,30 @@ static void __init rbtx4938_mem_setup(void)
 #endif
 
 #ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_PIO58_61
-	printk(KERN_INFO "PIOSEL: disabling both ata and nand selection\n");
+	pr_info("PIOSEL: disabling both ATA and NAND selection\n");
 	txx9_clear64(&tx4938_ccfgptr->pcfg,
 		     TX4938_PCFG_NDF_SEL | TX4938_PCFG_ATA_SEL);
 #endif
 
 #ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_NAND
-	printk(KERN_INFO "PIOSEL: enabling nand selection\n");
+	pr_info("PIOSEL: enabling NAND selection\n");
 	txx9_set64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_NDF_SEL);
 	txx9_clear64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_ATA_SEL);
 #endif
 
 #ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_ATA
-	printk(KERN_INFO "PIOSEL: enabling ata selection\n");
+	pr_info("PIOSEL: enabling ATA selection\n");
 	txx9_set64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_ATA_SEL);
 	txx9_clear64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_NDF_SEL);
 #endif
 
+#ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_KEEP
+	pcfg = ____raw_readq(&tx4938_ccfgptr->pcfg);
+	pr_info("PIOSEL: NAND %s, ATA %s\n",
+		(pcfg & TX4938_PCFG_NDF_SEL) ? "enabled" : "disabled",
+		(pcfg & TX4938_PCFG_ATA_SEL) ? "enabled" : "disabled");
+#endif
+
 	rbtx4938_spi_setup();
 	pcfg = ____raw_readq(&tx4938_ccfgptr->pcfg);	/* updated */
 	/* fixup piosel */

commit 51f607c76e1e7bd089dcad97b6b0a58649be06a3
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Aug 19 22:55:11 2008 +0900

    MIPS: TXx9: Add mtd support
    
    Add helper routines to register physmap-flash platform devices for NOR
    flashes.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 9ab48dec0fe8..e7bc5b8c7db8 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -15,6 +15,7 @@
 #include <linux/delay.h>
 #include <linux/platform_device.h>
 #include <linux/gpio.h>
+#include <linux/mtd/physmap.h>
 
 #include <asm/reboot.h>
 #include <asm/io.h>
@@ -294,6 +295,42 @@ static int __init rbtx4938_spi_init(void)
 	return 0;
 }
 
+static void __init rbtx4938_mtd_init(void)
+{
+	struct physmap_flash_data pdata = {
+		.width = 4,
+	};
+
+	switch (readb(rbtx4938_bdipsw_addr) & 7) {
+	case 0:
+		/* Boot */
+		txx9_physmap_flash_init(0, 0x1fc00000, 0x400000, &pdata);
+		/* System */
+		txx9_physmap_flash_init(1, 0x1e000000, 0x1000000, &pdata);
+		break;
+	case 1:
+		/* System */
+		txx9_physmap_flash_init(0, 0x1f000000, 0x1000000, &pdata);
+		/* Boot */
+		txx9_physmap_flash_init(1, 0x1ec00000, 0x400000, &pdata);
+		break;
+	case 2:
+		/* Ext */
+		txx9_physmap_flash_init(0, 0x1f000000, 0x1000000, &pdata);
+		/* System */
+		txx9_physmap_flash_init(1, 0x1e000000, 0x1000000, &pdata);
+		/* Boot */
+		txx9_physmap_flash_init(2, 0x1dc00000, 0x400000, &pdata);
+		break;
+	case 3:
+		/* Boot */
+		txx9_physmap_flash_init(1, 0x1bc00000, 0x400000, &pdata);
+		/* System */
+		txx9_physmap_flash_init(2, 0x1a000000, 0x1000000, &pdata);
+		break;
+	}
+}
+
 static void __init rbtx4938_arch_init(void)
 {
 	gpiochip_add(&rbtx4938_spi_gpio_chip);
@@ -306,6 +343,7 @@ static void __init rbtx4938_device_init(void)
 	rbtx4938_ethaddr_init();
 	rbtx4938_ne_init();
 	tx4938_wdt_init();
+	rbtx4938_mtd_init();
 }
 
 struct txx9_board_vec rbtx4938_vec __initdata = {

commit 7779a5e07d33fe316fe468e7afe7975fb686a831
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 25 23:08:06 2008 +0900

    [MIPS] TXx9: Unify serial_txx9 setup
    
    * Unify calling of early_serial_txx9_setup.
    * Use dedicated serial clock on RBTX4938.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 5c05a21b33f5..9ab48dec0fe8 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -165,7 +165,7 @@ static void __init rbtx4938_mem_setup(void)
 	set_io_port_base(RBTX4938_ETHER_BASE);
 #endif
 
-	tx4938_setup_serial();
+	tx4938_sio_init(7372800, 0);
 #ifdef CONFIG_SERIAL_TXX9_CONSOLE
 	argptr = prom_getcmdline();
 	if (!strstr(argptr, "console="))

commit bb72f1f729dcbd6a6a93c74479eeaa19deebfb47
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:21 2008 +0900

    [MIPS] TXx9: Random cleanup
    
    * Random cleanups spotted by checkpatch script.
    * Do not initialize panic_timeout.  "panic=" kernel parameter can be used.
    * Do not add "ip=any" or "ip=bootp".  This options is not board specific.
    * Do not add "root=/dev/nfs".  This is default on CONFIG_ROOT_NFS.
    * Kill unused error checking.
    * Fix IRQ comment to match current code.
    * Kill some unneeded includes
    * ST0_ERL is already cleared in generic code.
    * conswitchp is initialized generic code.
    * __init is not needed in prototype.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 3324a70a6b7a..5c05a21b33f5 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -13,8 +13,6 @@
 #include <linux/types.h>
 #include <linux/ioport.h>
 #include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/console.h>
 #include <linux/platform_device.h>
 #include <linux/gpio.h>
 
@@ -169,45 +167,29 @@ static void __init rbtx4938_mem_setup(void)
 
 	tx4938_setup_serial();
 #ifdef CONFIG_SERIAL_TXX9_CONSOLE
-        argptr = prom_getcmdline();
-        if (strstr(argptr, "console=") == NULL) {
-                strcat(argptr, " console=ttyS0,38400");
-        }
+	argptr = prom_getcmdline();
+	if (!strstr(argptr, "console="))
+		strcat(argptr, " console=ttyS0,38400");
 #endif
 
 #ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_PIO58_61
-	printk("PIOSEL: disabling both ata and nand selection\n");
-	local_irq_disable();
+	printk(KERN_INFO "PIOSEL: disabling both ata and nand selection\n");
 	txx9_clear64(&tx4938_ccfgptr->pcfg,
 		     TX4938_PCFG_NDF_SEL | TX4938_PCFG_ATA_SEL);
 #endif
 
 #ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_NAND
-	printk("PIOSEL: enabling nand selection\n");
+	printk(KERN_INFO "PIOSEL: enabling nand selection\n");
 	txx9_set64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_NDF_SEL);
 	txx9_clear64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_ATA_SEL);
 #endif
 
 #ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_ATA
-	printk("PIOSEL: enabling ata selection\n");
+	printk(KERN_INFO "PIOSEL: enabling ata selection\n");
 	txx9_set64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_ATA_SEL);
 	txx9_clear64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_NDF_SEL);
 #endif
 
-#ifdef CONFIG_IP_PNP
-	argptr = prom_getcmdline();
-	if (strstr(argptr, "ip=") == NULL) {
-		strcat(argptr, " ip=any");
-	}
-#endif
-
-
-#ifdef CONFIG_FB
-	{
-		conswitchp = &dummy_con;
-	}
-#endif
-
 	rbtx4938_spi_setup();
 	pcfg = ____raw_readq(&tx4938_ccfgptr->pcfg);	/* updated */
 	/* fixup piosel */
@@ -228,7 +210,7 @@ static void __init rbtx4938_mem_setup(void)
 	rbtx4938_fpga_resource.end = CPHYSADDR(RBTX4938_FPGA_REG_ADDR) + 0xffff;
 	rbtx4938_fpga_resource.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
 	if (request_resource(&txx9_ce_res[2], &rbtx4938_fpga_resource))
-		printk("request resource for fpga failed\n");
+		printk(KERN_ERR "request resource for fpga failed\n");
 
 	_machine_restart = rbtx4938_machine_restart;
 
@@ -238,7 +220,7 @@ static void __init rbtx4938_mem_setup(void)
 	       readb(rbtx4938_dipsw_addr), readb(rbtx4938_bdipsw_addr));
 }
 
-static int __init rbtx4938_ne_init(void)
+static void __init rbtx4938_ne_init(void)
 {
 	struct resource res[] = {
 		{
@@ -250,10 +232,7 @@ static int __init rbtx4938_ne_init(void)
 			.flags	= IORESOURCE_IRQ,
 		}
 	};
-	struct platform_device *dev =
-		platform_device_register_simple("ne", -1,
-						res, ARRAY_SIZE(res));
-	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
+	platform_device_register_simple("ne", -1, res, ARRAY_SIZE(res));
 }
 
 static DEFINE_SPINLOCK(rbtx4938_spi_gpio_lock);

commit c49f91f51e3cca796494f69fd967a7f72df5d457
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:20 2008 +0900

    [MIPS] TXx9: Make tx4938-specific code more independent
    
    Make some TX4938 SoC specific code independent from board specific code.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index ff5fda2151f2..3324a70a6b7a 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -132,19 +132,7 @@ static int __init rbtx4938_ethaddr_init(void)
 		if (sum)
 			printk(KERN_WARNING "seeprom: bad checksum.\n");
 	}
-	for (i = 0; i < 2; i++) {
-		unsigned int id =
-			TXX9_IRQ_BASE + (i ? TX4938_IR_ETH1 : TX4938_IR_ETH0);
-		struct platform_device *pdev;
-		if (!(__raw_readq(&tx4938_ccfgptr->pcfg) &
-		      (i ? TX4938_PCFG_ETH1_SEL : TX4938_PCFG_ETH0_SEL)))
-			continue;
-		pdev = platform_device_alloc("tc35815-mac", id);
-		if (!pdev ||
-		    platform_device_add_data(pdev, &dat[4 + 6 * i], 6) ||
-		    platform_device_add(pdev))
-			platform_device_put(pdev);
-	}
+	tx4938_ethaddr_init(&dat[4], &dat[4 + 6]);
 #endif /* CONFIG_PCI */
 	return 0;
 }
@@ -301,24 +289,6 @@ static struct gpio_chip rbtx4938_spi_gpio_chip = {
 	.ngpio = 3,
 };
 
-/* SPI support */
-
-static void __init txx9_spi_init(unsigned long base, int irq)
-{
-	struct resource res[] = {
-		{
-			.start	= base,
-			.end	= base + 0x20 - 1,
-			.flags	= IORESOURCE_MEM,
-		}, {
-			.start	= irq,
-			.flags	= IORESOURCE_IRQ,
-		},
-	};
-	platform_device_register_simple("spi_txx9", 0,
-					res, ARRAY_SIZE(res));
-}
-
 static int __init rbtx4938_spi_init(void)
 {
 	struct spi_board_info srtc_info = {
@@ -341,7 +311,7 @@ static int __init rbtx4938_spi_init(void)
 	gpio_direction_output(16 + SEEPROM2_CS, 1);
 	gpio_request(16 + SEEPROM3_CS, "seeprom3");
 	gpio_direction_output(16 + SEEPROM3_CS, 1);
-	txx9_spi_init(TX4938_SPI_REG & 0xfffffffffULL, RBTX4938_IRQ_IRC_SPI);
+	tx4938_spi_init(0);
 	return 0;
 }
 

commit 683147254ef7e69ebbbe55280ba6a3c5ae2325d8
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:18 2008 +0900

    [MIPS] TXx9: Cleanup watchdog
    
    Unify registration of txx9wdt platform device.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index e1177b3b9103..ff5fda2151f2 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -352,30 +352,11 @@ static void __init rbtx4938_arch_init(void)
 	rbtx4938_spi_init();
 }
 
-/* Watchdog support */
-
-static int __init txx9_wdt_init(unsigned long base)
-{
-	struct resource res = {
-		.start	= base,
-		.end	= base + 0x100 - 1,
-		.flags	= IORESOURCE_MEM,
-	};
-	struct platform_device *dev =
-		platform_device_register_simple("txx9wdt", -1, &res, 1);
-	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
-}
-
-static int __init rbtx4938_wdt_init(void)
-{
-	return txx9_wdt_init(TX4938_TMR_REG(2) & 0xfffffffffULL);
-}
-
 static void __init rbtx4938_device_init(void)
 {
 	rbtx4938_ethaddr_init();
 	rbtx4938_ne_init();
-	rbtx4938_wdt_init();
+	tx4938_wdt_init();
 }
 
 struct txx9_board_vec rbtx4938_vec __initdata = {

commit a49297e8fc8a9a835ac4ec124aa83028abdcc7d5
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:17 2008 +0900

    [MIPS] TXx9: Cleanup restart/halt/power_off
    
    Unify machine_restart/machine_halt/pm_power_off and add fallback
    machine_halt routine.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 4454b7901cd3..e1177b3b9103 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -15,7 +15,6 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/console.h>
-#include <linux/pm.h>
 #include <linux/platform_device.h>
 #include <linux/gpio.h>
 
@@ -28,33 +27,14 @@
 #include <asm/txx9/spi.h>
 #include <asm/txx9pio.h>
 
-static void rbtx4938_machine_halt(void)
-{
-        printk(KERN_NOTICE "System Halted\n");
-	local_irq_disable();
-
-	while (1)
-		__asm__(".set\tmips3\n\t"
-			"wait\n\t"
-			".set\tmips0");
-}
-
-static void rbtx4938_machine_power_off(void)
-{
-        rbtx4938_machine_halt();
-        /* no return */
-}
-
 static void rbtx4938_machine_restart(char *command)
 {
 	local_irq_disable();
-
-	printk("Rebooting...");
 	writeb(1, rbtx4938_softresetlock_addr);
 	writeb(1, rbtx4938_sfvol_addr);
 	writeb(1, rbtx4938_softreset_addr);
-	while(1)
-		;
+	/* fallback */
+	(*_machine_halt)();
 }
 
 static void __init rbtx4938_pci_setup(void)
@@ -263,8 +243,6 @@ static void __init rbtx4938_mem_setup(void)
 		printk("request resource for fpga failed\n");
 
 	_machine_restart = rbtx4938_machine_restart;
-	_machine_halt = rbtx4938_machine_halt;
-	pm_power_off = rbtx4938_machine_power_off;
 
 	writeb(0xff, rbtx4938_led_addr);
 	printk(KERN_INFO "RBTX4938 --- FPGA(Rev %02x) DIPSW:%02x,%02x\n",

commit 455cc256eb23915100e203fb33ee143afd127954
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 25 23:01:35 2008 +0900

    [MIPS] TXx9: PCI error handling
    
    From: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Date: Thu, 24 Jul 2008 00:25:16 +0900
    Subject: [PATCH] txx9: PCI error handling
    
    Add more control and detailed report on PCI error interrupt.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index fc9034db526e..4454b7901cd3 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -121,6 +121,7 @@ static void __init rbtx4938_pci_setup(void)
 		register_pci_controller(c);
 		tx4927_pcic_setup(tx4938_pcic1ptr, c, 0);
 	}
+	tx4938_setup_pcierr_irq();
 #endif /* CONFIG_PCI */
 }
 

commit 07517529225ae4ce770271f83d8cd1004733a01d
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:15 2008 +0900

    [MIPS] TXx9: Add some pci options
    
    Add pci options for backplane type, clock selection, error handling,
    timeout values.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 6c2b99bb8af6..fc9034db526e 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -193,6 +193,7 @@ static void __init rbtx4938_mem_setup(void)
 
 #ifdef CONFIG_PCI
 	txx9_alloc_pci_controller(&txx9_primary_pcic, 0, 0, 0, 0);
+	txx9_board_pcibios_setup = tx4927_pcibios_setup;
 #else
 	set_io_port_base(RBTX4938_ETHER_BASE);
 #endif

commit 94a4c32939dede9328c6e4face335eb8441fc18d
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat Jul 19 01:51:47 2008 +0900

    [MIPS] TXx9: Add 64-bit support
    
    SYS_SUPPORTS_64BIT_KERNEL is enabled for RBTX4927/RBTX4938, but
    actually it was broken for long time (or from the beginning).  Now it
    should work.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index c1e076c7b2d2..6c2b99bb8af6 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -20,21 +20,14 @@
 #include <linux/gpio.h>
 
 #include <asm/reboot.h>
-#include <asm/time.h>
-#include <asm/txx9tmr.h>
 #include <asm/io.h>
 #include <asm/txx9/generic.h>
 #include <asm/txx9/pci.h>
 #include <asm/txx9/rbtx4938.h>
-#ifdef CONFIG_SERIAL_TXX9
-#include <linux/serial_core.h>
-#endif
 #include <linux/spi/spi.h>
 #include <asm/txx9/spi.h>
 #include <asm/txx9pio.h>
 
-static int tx4938_ccfg_toeon = 1;
-
 static void rbtx4938_machine_halt(void)
 {
         printk(KERN_NOTICE "System Halted\n");
@@ -182,189 +175,10 @@ static void __init rbtx4938_spi_setup(void)
 }
 
 static struct resource rbtx4938_fpga_resource;
-static struct resource tx4938_sdram_resource[4];
-static struct resource tx4938_sram_resource;
-
-void __init tx4938_board_setup(void)
-{
-	int i;
-	unsigned long divmode;
-	int cpuclk = 0;
-	unsigned long pcode = TX4938_REV_PCODE();
-
-	ioport_resource.start = 0;
-	ioport_resource.end = 0xffffffff;
-	iomem_resource.start = 0;
-	iomem_resource.end = 0xffffffff;	/* expand to 4GB */
-
-	txx9_reg_res_init(pcode, TX4938_REG_BASE,
-			  TX4938_REG_SIZE);
-	/* SDRAMC,EBUSC are configured by PROM */
-	for (i = 0; i < 8; i++) {
-		if (!(TX4938_EBUSC_CR(i) & 0x8))
-			continue;	/* disabled */
-		txx9_ce_res[i].start = (unsigned long)TX4938_EBUSC_BA(i);
-		txx9_ce_res[i].end =
-			txx9_ce_res[i].start + TX4938_EBUSC_SIZE(i) - 1;
-		request_resource(&iomem_resource, &txx9_ce_res[i]);
-	}
-
-	/* clocks */
-	if (txx9_master_clock) {
-		u64 ccfg = ____raw_readq(&tx4938_ccfgptr->ccfg);
-		/* calculate gbus_clock and cpu_clock_freq from master_clock */
-		divmode = (__u32)ccfg & TX4938_CCFG_DIVMODE_MASK;
-		switch (divmode) {
-		case TX4938_CCFG_DIVMODE_8:
-		case TX4938_CCFG_DIVMODE_10:
-		case TX4938_CCFG_DIVMODE_12:
-		case TX4938_CCFG_DIVMODE_16:
-		case TX4938_CCFG_DIVMODE_18:
-			txx9_gbus_clock = txx9_master_clock * 4; break;
-		default:
-			txx9_gbus_clock = txx9_master_clock;
-		}
-		switch (divmode) {
-		case TX4938_CCFG_DIVMODE_2:
-		case TX4938_CCFG_DIVMODE_8:
-			cpuclk = txx9_gbus_clock * 2; break;
-		case TX4938_CCFG_DIVMODE_2_5:
-		case TX4938_CCFG_DIVMODE_10:
-			cpuclk = txx9_gbus_clock * 5 / 2; break;
-		case TX4938_CCFG_DIVMODE_3:
-		case TX4938_CCFG_DIVMODE_12:
-			cpuclk = txx9_gbus_clock * 3; break;
-		case TX4938_CCFG_DIVMODE_4:
-		case TX4938_CCFG_DIVMODE_16:
-			cpuclk = txx9_gbus_clock * 4; break;
-		case TX4938_CCFG_DIVMODE_4_5:
-		case TX4938_CCFG_DIVMODE_18:
-			cpuclk = txx9_gbus_clock * 9 / 2; break;
-		}
-		txx9_cpu_clock = cpuclk;
-	} else {
-		u64 ccfg = ____raw_readq(&tx4938_ccfgptr->ccfg);
-		if (txx9_cpu_clock == 0) {
-			txx9_cpu_clock = 300000000;	/* 300MHz */
-		}
-		/* calculate gbus_clock and master_clock from cpu_clock_freq */
-		cpuclk = txx9_cpu_clock;
-		divmode = (__u32)ccfg & TX4938_CCFG_DIVMODE_MASK;
-		switch (divmode) {
-		case TX4938_CCFG_DIVMODE_2:
-		case TX4938_CCFG_DIVMODE_8:
-			txx9_gbus_clock = cpuclk / 2; break;
-		case TX4938_CCFG_DIVMODE_2_5:
-		case TX4938_CCFG_DIVMODE_10:
-			txx9_gbus_clock = cpuclk * 2 / 5; break;
-		case TX4938_CCFG_DIVMODE_3:
-		case TX4938_CCFG_DIVMODE_12:
-			txx9_gbus_clock = cpuclk / 3; break;
-		case TX4938_CCFG_DIVMODE_4:
-		case TX4938_CCFG_DIVMODE_16:
-			txx9_gbus_clock = cpuclk / 4; break;
-		case TX4938_CCFG_DIVMODE_4_5:
-		case TX4938_CCFG_DIVMODE_18:
-			txx9_gbus_clock = cpuclk * 2 / 9; break;
-		}
-		switch (divmode) {
-		case TX4938_CCFG_DIVMODE_8:
-		case TX4938_CCFG_DIVMODE_10:
-		case TX4938_CCFG_DIVMODE_12:
-		case TX4938_CCFG_DIVMODE_16:
-		case TX4938_CCFG_DIVMODE_18:
-			txx9_master_clock = txx9_gbus_clock / 4; break;
-		default:
-			txx9_master_clock = txx9_gbus_clock;
-		}
-	}
-	/* change default value to udelay/mdelay take reasonable time */
-	loops_per_jiffy = txx9_cpu_clock / HZ / 2;
-
-	/* CCFG */
-	/* clear WatchDogReset,BusErrorOnWrite flag (W1C) */
-	tx4938_ccfg_set(TX4938_CCFG_WDRST | TX4938_CCFG_BEOW);
-	/* do reset on watchdog */
-	tx4938_ccfg_set(TX4938_CCFG_WR);
-	/* clear PCIC1 reset */
-	txx9_clear64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIC1RST);
-
-	/* enable Timeout BusError */
-	if (tx4938_ccfg_toeon)
-		tx4938_ccfg_set(TX4938_CCFG_TOE);
-
-	/* DMA selection */
-	txx9_clear64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_DMASEL_ALL);
-
-	/* Use external clock for external arbiter */
-	if (!(____raw_readq(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCIARB))
-		txx9_clear64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_PCICLKEN_ALL);
-
-	printk(KERN_INFO "%s -- %dMHz(M%dMHz) CRIR:%08x CCFG:%llx PCFG:%llx\n",
-	       txx9_pcode_str,
-	       (cpuclk + 500000) / 1000000,
-	       (txx9_master_clock + 500000) / 1000000,
-	       (__u32)____raw_readq(&tx4938_ccfgptr->crir),
-	       (unsigned long long)____raw_readq(&tx4938_ccfgptr->ccfg),
-	       (unsigned long long)____raw_readq(&tx4938_ccfgptr->pcfg));
-
-	printk(KERN_INFO "%s SDRAMC --", txx9_pcode_str);
-	for (i = 0; i < 4; i++) {
-		u64 cr = TX4938_SDRAMC_CR(i);
-		unsigned long ram_base, ram_size;
-		if (!((unsigned long)cr & 0x00000400))
-			continue;	/* disabled */
-		ram_base = (unsigned long)(cr >> 49) << 21;
-		ram_size = ((unsigned long)(cr >> 33) + 1) << 21;
-		if (ram_base >= 0x20000000)
-			continue;	/* high memory (ignore) */
-		printk(KERN_CONT " CR%d:%016llx", i, cr);
-		tx4938_sdram_resource[i].name = "SDRAM";
-		tx4938_sdram_resource[i].start = ram_base;
-		tx4938_sdram_resource[i].end = ram_base + ram_size - 1;
-		tx4938_sdram_resource[i].flags = IORESOURCE_MEM;
-		request_resource(&iomem_resource, &tx4938_sdram_resource[i]);
-	}
-	printk(KERN_CONT " TR:%09llx\n", ____raw_readq(&tx4938_sdramcptr->tr));
-
-	/* SRAM */
-	if (____raw_readq(&tx4938_sramcptr->cr) & 1) {
-		unsigned int size = 0x800;
-		unsigned long base =
-			(____raw_readq(&tx4938_sramcptr->cr) >> (39-11))
-			& ~(size - 1);
-		tx4938_sram_resource.name = "SRAM";
-		tx4938_sram_resource.start = base;
-		tx4938_sram_resource.end = base + size - 1;
-		tx4938_sram_resource.flags = IORESOURCE_MEM;
-		request_resource(&iomem_resource, &tx4938_sram_resource);
-	}
-
-	/* TMR */
-	for (i = 0; i < TX4938_NR_TMR; i++)
-		txx9_tmr_init(TX4938_TMR_REG(i) & 0xfffffffffULL);
-
-	/* enable DMA */
-	for (i = 0; i < 2; i++)
-		____raw_writeq(TX4938_DMA_MCR_MSTEN,
-			       (void __iomem *)(TX4938_DMA_REG(i) + 0x50));
-
-	/* PIO */
-	__raw_writel(0, &tx4938_pioptr->maskcpu);
-	__raw_writel(0, &tx4938_pioptr->maskext);
-
-#ifdef CONFIG_PCI
-	txx9_alloc_pci_controller(&txx9_primary_pcic, 0, 0, 0, 0);
-#endif
-}
 
 static void __init rbtx4938_time_init(void)
 {
-	mips_hpt_frequency = txx9_cpu_clock / 2;
-	if (____raw_readq(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_TINTDIS)
-		txx9_clockevent_init(TX4938_TMR_REG(0) & 0xfffffffffULL,
-				     TXX9_IRQ_BASE + TX4938_IR_TMR(0),
-				     txx9_gbus_clock / 2);
+	tx4938_time_init(0);
 }
 
 static void __init rbtx4938_mem_setup(void)
@@ -372,39 +186,24 @@ static void __init rbtx4938_mem_setup(void)
 	unsigned long long pcfg;
 	char *argptr;
 
-	iomem_resource.end = 0xffffffff;	/* 4GB */
-
 	if (txx9_master_clock == 0)
 		txx9_master_clock = 25000000; /* 25MHz */
-	tx4938_board_setup();
-#ifndef CONFIG_PCI
+
+	tx4938_setup();
+
+#ifdef CONFIG_PCI
+	txx9_alloc_pci_controller(&txx9_primary_pcic, 0, 0, 0, 0);
+#else
 	set_io_port_base(RBTX4938_ETHER_BASE);
 #endif
 
-#ifdef CONFIG_SERIAL_TXX9
-	{
-		extern int early_serial_txx9_setup(struct uart_port *port);
-		int i;
-		struct uart_port req;
-		for(i = 0; i < 2; i++) {
-			memset(&req, 0, sizeof(req));
-			req.line = i;
-			req.iotype = UPIO_MEM;
-			req.membase = (char *)(0xff1ff300 + i * 0x100);
-			req.mapbase = 0xff1ff300 + i * 0x100;
-			req.irq = RBTX4938_IRQ_IRC_SIO(i);
-			req.flags |= UPF_BUGGY_UART /*HAVE_CTS_LINE*/;
-			req.uartclk = 50000000;
-			early_serial_txx9_setup(&req);
-		}
-	}
+	tx4938_setup_serial();
 #ifdef CONFIG_SERIAL_TXX9_CONSOLE
         argptr = prom_getcmdline();
         if (strstr(argptr, "console=") == NULL) {
                 strcat(argptr, " console=ttyS0,38400");
         }
 #endif
-#endif
 
 #ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_PIO58_61
 	printk("PIOSEL: disabling both ata and nand selection\n");
@@ -568,7 +367,6 @@ static int __init rbtx4938_spi_init(void)
 
 static void __init rbtx4938_arch_init(void)
 {
-	txx9_gpio_init(TX4938_PIO_REG & 0xfffffffffULL, 0, 16);
 	gpiochip_add(&rbtx4938_spi_gpio_chip);
 	rbtx4938_pci_setup();
 	rbtx4938_spi_init();

commit 255033a9bb900a06c9a7798908ce12557d24fb66
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat Jul 19 01:51:41 2008 +0900

    [MIPS] TXx9: Cleanups for 64-bit support
    
    * Unify (and fix) mem_tx4938.c and mem_tx4927.c
    * Simplify prom_init
    * Kill volatiles and unused definitions for tx4927.h and tx4938.h
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index c2da92396b7a..c1e076c7b2d2 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -310,7 +310,7 @@ void __init tx4938_board_setup(void)
 
 	printk(KERN_INFO "%s SDRAMC --", txx9_pcode_str);
 	for (i = 0; i < 4; i++) {
-		unsigned long long cr = tx4938_sdramcptr->cr[i];
+		u64 cr = TX4938_SDRAMC_CR(i);
 		unsigned long ram_base, ram_size;
 		if (!((unsigned long)cr & 0x00000400))
 			continue;	/* disabled */
@@ -318,20 +318,21 @@ void __init tx4938_board_setup(void)
 		ram_size = ((unsigned long)(cr >> 33) + 1) << 21;
 		if (ram_base >= 0x20000000)
 			continue;	/* high memory (ignore) */
-		printk(" CR%d:%016Lx", i, cr);
+		printk(KERN_CONT " CR%d:%016llx", i, cr);
 		tx4938_sdram_resource[i].name = "SDRAM";
 		tx4938_sdram_resource[i].start = ram_base;
 		tx4938_sdram_resource[i].end = ram_base + ram_size - 1;
 		tx4938_sdram_resource[i].flags = IORESOURCE_MEM;
 		request_resource(&iomem_resource, &tx4938_sdram_resource[i]);
 	}
-	printk(" TR:%09Lx\n", tx4938_sdramcptr->tr);
+	printk(KERN_CONT " TR:%09llx\n", ____raw_readq(&tx4938_sdramcptr->tr));
 
 	/* SRAM */
-	if (tx4938_sramcptr->cr & 1) {
+	if (____raw_readq(&tx4938_sramcptr->cr) & 1) {
 		unsigned int size = 0x800;
 		unsigned long base =
-			(tx4938_sramcptr->cr >> (39-11)) & ~(size - 1);
+			(____raw_readq(&tx4938_sramcptr->cr) >> (39-11))
+			& ~(size - 1);
 		tx4938_sram_resource.name = "SRAM";
 		tx4938_sram_resource.start = base;
 		tx4938_sram_resource.end = base + size - 1;

commit 8d795f2a5cf73338a467ac82bdeb73225e987c45
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 18 00:43:48 2008 +0900

    [MIPS] TXx9: Miscellaneous build fixes
    
    * Fix build if only RBTX4927 or RBTX4938 was selected.
    * Move gpio helpers to generic part.
    * Select SOC_TX4938 for RBTX4927/37 board.
    * Fix parent of rbtx4938_fpga_resource.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index aaa987ae0f83..c2da92396b7a 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -457,7 +457,7 @@ static void __init rbtx4938_mem_setup(void)
 	rbtx4938_fpga_resource.start = CPHYSADDR(RBTX4938_FPGA_REG_ADDR);
 	rbtx4938_fpga_resource.end = CPHYSADDR(RBTX4938_FPGA_REG_ADDR) + 0xffff;
 	rbtx4938_fpga_resource.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
-	if (request_resource(&iomem_resource, &rbtx4938_fpga_resource))
+	if (request_resource(&txx9_ce_res[2], &rbtx4938_fpga_resource))
 		printk("request resource for fpga failed\n");
 
 	_machine_restart = rbtx4938_machine_restart;
@@ -488,18 +488,6 @@ static int __init rbtx4938_ne_init(void)
 	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
 }
 
-/* GPIO support */
-
-int gpio_to_irq(unsigned gpio)
-{
-	return -EINVAL;
-}
-
-int irq_to_gpio(unsigned irq)
-{
-	return -EINVAL;
-}
-
 static DEFINE_SPINLOCK(rbtx4938_spi_gpio_lock);
 
 static void rbtx4938_spi_gpio_set(struct gpio_chip *chip, unsigned int offset,

commit 7b22609442a32050e37cec5f6735376af61e68a1
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Jul 14 00:15:04 2008 +0900

    [MIPS] TXx9: cleanup and fix some sparse warnings
    
    * Do not return void value
    * Make some functions static
    * Do not include unnecessary bootinfo.h
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 2ef71adea827..aaa987ae0f83 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -23,7 +23,6 @@
 #include <asm/time.h>
 #include <asm/txx9tmr.h>
 #include <asm/io.h>
-#include <asm/bootinfo.h>
 #include <asm/txx9/generic.h>
 #include <asm/txx9/pci.h>
 #include <asm/txx9/rbtx4938.h>
@@ -34,15 +33,9 @@
 #include <asm/txx9/spi.h>
 #include <asm/txx9pio.h>
 
-extern char * __init prom_getcmdline(void);
-/* These functions are used for rebooting or halting the machine*/
-extern void rbtx4938_machine_restart(char *command);
-extern void rbtx4938_machine_halt(void);
-extern void rbtx4938_machine_power_off(void);
-
 static int tx4938_ccfg_toeon = 1;
 
-void rbtx4938_machine_halt(void)
+static void rbtx4938_machine_halt(void)
 {
         printk(KERN_NOTICE "System Halted\n");
 	local_irq_disable();
@@ -53,13 +46,13 @@ void rbtx4938_machine_halt(void)
 			".set\tmips0");
 }
 
-void rbtx4938_machine_power_off(void)
+static void rbtx4938_machine_power_off(void)
 {
         rbtx4938_machine_halt();
         /* no return */
 }
 
-void rbtx4938_machine_restart(char *command)
+static void rbtx4938_machine_restart(char *command)
 {
 	local_irq_disable();
 

commit 6e68665e51b9937b132a990b9ae7f04118e64688
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Sun Jul 13 20:04:18 2008 +0900

    [MIPS] remove machtype for group Toshiba
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Acked-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 8306ba333dda..2ef71adea827 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -619,7 +619,6 @@ static void __init rbtx4938_device_init(void)
 }
 
 struct txx9_board_vec rbtx4938_vec __initdata = {
-	.type = MACH_TOSHIBA_RBTX4938,
 	.system = "Toshiba RBTX4938",
 	.prom_init = rbtx4938_prom_init,
 	.mem_setup = rbtx4938_mem_setup,

commit edcaf1a6a77315562e9781245cc8e028c9a921dc
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 23:27:54 2008 +0900

    [MIPS] TXx9: Make single kernel can support multiple boards
    
    Make single kernel can be used on RBTX4927/37/38.  Also make
    some SoC-specific code independent from board-specific code.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index 144d2cada820..8306ba333dda 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -17,7 +17,6 @@
 #include <linux/console.h>
 #include <linux/pm.h>
 #include <linux/platform_device.h>
-#include <linux/clk.h>
 #include <linux/gpio.h>
 
 #include <asm/reboot.h>
@@ -147,9 +146,9 @@ static void __init rbtx4938_pci_setup(void)
 #define	SEEPROM3_CS	1	/* IOC */
 #define	SRTC_CS	2	/* IOC */
 
-#ifdef CONFIG_PCI
 static int __init rbtx4938_ethaddr_init(void)
 {
+#ifdef CONFIG_PCI
 	unsigned char dat[17];
 	unsigned char sum;
 	int i;
@@ -179,10 +178,9 @@ static int __init rbtx4938_ethaddr_init(void)
 		    platform_device_add(pdev))
 			platform_device_put(pdev);
 	}
+#endif /* CONFIG_PCI */
 	return 0;
 }
-device_initcall(rbtx4938_ethaddr_init);
-#endif /* CONFIG_PCI */
 
 static void __init rbtx4938_spi_setup(void)
 {
@@ -366,7 +364,7 @@ void __init tx4938_board_setup(void)
 #endif
 }
 
-void __init plat_time_init(void)
+static void __init rbtx4938_time_init(void)
 {
 	mips_hpt_frequency = txx9_cpu_clock / 2;
 	if (____raw_readq(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_TINTDIS)
@@ -375,7 +373,7 @@ void __init plat_time_init(void)
 				     txx9_gbus_clock / 2);
 }
 
-void __init plat_mem_setup(void)
+static void __init rbtx4938_mem_setup(void)
 {
 	unsigned long long pcfg;
 	char *argptr;
@@ -496,7 +494,6 @@ static int __init rbtx4938_ne_init(void)
 						res, ARRAY_SIZE(res));
 	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
 }
-device_initcall(rbtx4938_ne_init);
 
 /* GPIO support */
 
@@ -587,14 +584,13 @@ static int __init rbtx4938_spi_init(void)
 	return 0;
 }
 
-static int __init rbtx4938_arch_init(void)
+static void __init rbtx4938_arch_init(void)
 {
 	txx9_gpio_init(TX4938_PIO_REG & 0xfffffffffULL, 0, 16);
 	gpiochip_add(&rbtx4938_spi_gpio_chip);
 	rbtx4938_pci_setup();
-	return rbtx4938_spi_init();
+	rbtx4938_spi_init();
 }
-arch_initcall(rbtx4938_arch_init);
 
 /* Watchdog support */
 
@@ -614,38 +610,24 @@ static int __init rbtx4938_wdt_init(void)
 {
 	return txx9_wdt_init(TX4938_TMR_REG(2) & 0xfffffffffULL);
 }
-device_initcall(rbtx4938_wdt_init);
-
-/* Minimum CLK support */
-
-struct clk *clk_get(struct device *dev, const char *id)
-{
-	if (!strcmp(id, "spi-baseclk"))
-		return (struct clk *)(txx9_gbus_clock / 2 / 4);
-	if (!strcmp(id, "imbus_clk"))
-		return (struct clk *)(txx9_gbus_clock / 2);
-	return ERR_PTR(-ENOENT);
-}
-EXPORT_SYMBOL(clk_get);
-
-int clk_enable(struct clk *clk)
-{
-	return 0;
-}
-EXPORT_SYMBOL(clk_enable);
-
-void clk_disable(struct clk *clk)
-{
-}
-EXPORT_SYMBOL(clk_disable);
 
-unsigned long clk_get_rate(struct clk *clk)
+static void __init rbtx4938_device_init(void)
 {
-	return (unsigned long)clk;
+	rbtx4938_ethaddr_init();
+	rbtx4938_ne_init();
+	rbtx4938_wdt_init();
 }
-EXPORT_SYMBOL(clk_get_rate);
 
-void clk_put(struct clk *clk)
-{
-}
-EXPORT_SYMBOL(clk_put);
+struct txx9_board_vec rbtx4938_vec __initdata = {
+	.type = MACH_TOSHIBA_RBTX4938,
+	.system = "Toshiba RBTX4938",
+	.prom_init = rbtx4938_prom_init,
+	.mem_setup = rbtx4938_mem_setup,
+	.irq_setup = rbtx4938_irq_setup,
+	.time_init = rbtx4938_time_init,
+	.device_init = rbtx4938_device_init,
+	.arch_init = rbtx4938_arch_init,
+#ifdef CONFIG_PCI
+	.pci_map_irq = rbtx4938_pci_map_irq,
+#endif
+};

commit 89d63fe179520b11f54de1f26755b7444c79e73a
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 00:33:08 2008 +0900

    [MIPS] TXx9: Reorganize PCI code
    
    Split out PCIC dependent code and SoC dependent code from board dependent
    code.  Now TX4927 PCIC code is independent from TX4927/TX4938 SoC code.
    Also fix some build problems on CONFIG_PCI=n.
    
    As a bonus, "FPCIB0 Backplane Support" is available for all TX39/TX49 boards
    and PCI66 support is available for all TX49 boards.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
index bbd572c9675b..144d2cada820 100644
--- a/arch/mips/txx9/rbtx4938/setup.c
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -15,7 +15,6 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 #include <linux/console.h>
-#include <linux/pci.h>
 #include <linux/pm.h>
 #include <linux/platform_device.h>
 #include <linux/clk.h>
@@ -26,6 +25,8 @@
 #include <asm/txx9tmr.h>
 #include <asm/io.h>
 #include <asm/bootinfo.h>
+#include <asm/txx9/generic.h>
+#include <asm/txx9/pci.h>
 #include <asm/txx9/rbtx4938.h>
 #ifdef CONFIG_SERIAL_TXX9
 #include <linux/serial_core.h>
@@ -35,37 +36,13 @@
 #include <asm/txx9pio.h>
 
 extern char * __init prom_getcmdline(void);
-static inline void tx4938_report_pcic_status1(struct tx4938_pcic_reg *pcicptr);
-
 /* These functions are used for rebooting or halting the machine*/
 extern void rbtx4938_machine_restart(char *command);
 extern void rbtx4938_machine_halt(void);
 extern void rbtx4938_machine_power_off(void);
 
-/* clocks */
-unsigned int txx9_master_clock;
-unsigned int txx9_cpu_clock;
-unsigned int txx9_gbus_clock;
-
-unsigned long rbtx4938_ce_base[8];
-unsigned long rbtx4938_ce_size[8];
-int txboard_pci66_mode;
-static int tx4938_pcic_trdyto;	/* default: disabled */
-static int tx4938_pcic_retryto;	/* default: disabled */
 static int tx4938_ccfg_toeon = 1;
 
-struct tx4938_pcic_reg *pcicptrs[4] = {
-       tx4938_pcicptr  /* default setting for TX4938 */
-};
-
-static struct {
-	unsigned long base;
-	unsigned long size;
-} phys_regions[16] __initdata;
-static int num_phys_regions  __initdata;
-
-#define PHYS_REGION_MINSIZE	0x10000
-
 void rbtx4938_machine_halt(void)
 {
         printk(KERN_NOTICE "System Halted\n");
@@ -95,473 +72,72 @@ void rbtx4938_machine_restart(char *command)
 		;
 }
 
-void __init
-txboard_add_phys_region(unsigned long base, unsigned long size)
-{
-	if (num_phys_regions >= ARRAY_SIZE(phys_regions)) {
-		printk("phys_region overflow\n");
-		return;
-	}
-	phys_regions[num_phys_regions].base = base;
-	phys_regions[num_phys_regions].size = size;
-	num_phys_regions++;
-}
-unsigned long __init
-txboard_find_free_phys_region(unsigned long begin, unsigned long end,
-			      unsigned long size)
-{
-	unsigned long base;
-	int i;
-
-	for (base = begin / size * size; base < end; base += size) {
-		for (i = 0; i < num_phys_regions; i++) {
-			if (phys_regions[i].size &&
-			    base <= phys_regions[i].base + (phys_regions[i].size - 1) &&
-			    base + (size - 1) >= phys_regions[i].base)
-				break;
-		}
-		if (i == num_phys_regions)
-			return base;
-	}
-	return 0;
-}
-unsigned long __init
-txboard_find_free_phys_region_shrink(unsigned long begin, unsigned long end,
-				     unsigned long *size)
-{
-	unsigned long sz, base;
-	for (sz = *size; sz >= PHYS_REGION_MINSIZE; sz /= 2) {
-		base = txboard_find_free_phys_region(begin, end, sz);
-		if (base) {
-			*size = sz;
-			return base;
-		}
-	}
-	return 0;
-}
-unsigned long __init
-txboard_request_phys_region_range(unsigned long begin, unsigned long end,
-				  unsigned long size)
-{
-	unsigned long base;
-	base = txboard_find_free_phys_region(begin, end, size);
-	if (base)
-		txboard_add_phys_region(base, size);
-	return base;
-}
-unsigned long __init
-txboard_request_phys_region(unsigned long size)
+static void __init rbtx4938_pci_setup(void)
 {
-	unsigned long base;
-	unsigned long begin = 0, end = 0x20000000;	/* search low 512MB */
-	base = txboard_find_free_phys_region(begin, end, size);
-	if (base)
-		txboard_add_phys_region(base, size);
-	return base;
-}
-unsigned long __init
-txboard_request_phys_region_shrink(unsigned long *size)
-{
-	unsigned long base;
-	unsigned long begin = 0, end = 0x20000000;	/* search low 512MB */
-	base = txboard_find_free_phys_region_shrink(begin, end, size);
-	if (base)
-		txboard_add_phys_region(base, *size);
-	return base;
-}
-
 #ifdef CONFIG_PCI
-void __init
-tx4938_pcic_setup(struct tx4938_pcic_reg *pcicptr,
-		  struct pci_controller *channel,
-		  unsigned long pci_io_base,
-		  int extarb)
-{
-	int i;
+	int extarb = !(__raw_readq(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCIARB);
+	struct pci_controller *c = &txx9_primary_pcic;
 
-	/* Disable All Initiator Space */
-	pcicptr->pciccfg &= ~(TX4938_PCIC_PCICCFG_G2PMEN(0)|
-			      TX4938_PCIC_PCICCFG_G2PMEN(1)|
-			      TX4938_PCIC_PCICCFG_G2PMEN(2)|
-			      TX4938_PCIC_PCICCFG_G2PIOEN);
-
-	/* GB->PCI mappings */
-	pcicptr->g2piomask = (channel->io_resource->end - channel->io_resource->start) >> 4;
-	pcicptr->g2piogbase = pci_io_base |
-#ifdef __BIG_ENDIAN
-		TX4938_PCIC_G2PIOGBASE_ECHG
-#else
-		TX4938_PCIC_G2PIOGBASE_BSDIS
-#endif
-		;
-	pcicptr->g2piopbase = 0;
-	for (i = 0; i < 3; i++) {
-		pcicptr->g2pmmask[i] = 0;
-		pcicptr->g2pmgbase[i] = 0;
-		pcicptr->g2pmpbase[i] = 0;
-	}
-	if (channel->mem_resource->end) {
-		pcicptr->g2pmmask[0] = (channel->mem_resource->end - channel->mem_resource->start) >> 4;
-		pcicptr->g2pmgbase[0] = channel->mem_resource->start |
-#ifdef __BIG_ENDIAN
-			TX4938_PCIC_G2PMnGBASE_ECHG
-#else
-			TX4938_PCIC_G2PMnGBASE_BSDIS
-#endif
-			;
-		pcicptr->g2pmpbase[0] = channel->mem_resource->start;
-	}
-	/* PCI->GB mappings (I/O 256B) */
-	pcicptr->p2giopbase = 0; /* 256B */
-	pcicptr->p2giogbase = 0;
-	/* PCI->GB mappings (MEM 512MB (64MB on R1.x)) */
-	pcicptr->p2gm0plbase = 0;
-	pcicptr->p2gm0pubase = 0;
-	pcicptr->p2gmgbase[0] = 0 |
-		TX4938_PCIC_P2GMnGBASE_TMEMEN |
-#ifdef __BIG_ENDIAN
-		TX4938_PCIC_P2GMnGBASE_TECHG
-#else
-		TX4938_PCIC_P2GMnGBASE_TBSDIS
-#endif
-		;
-	/* PCI->GB mappings (MEM 16MB) */
-	pcicptr->p2gm1plbase = 0xffffffff;
-	pcicptr->p2gm1pubase = 0xffffffff;
-	pcicptr->p2gmgbase[1] = 0;
-	/* PCI->GB mappings (MEM 1MB) */
-	pcicptr->p2gm2pbase = 0xffffffff; /* 1MB */
-	pcicptr->p2gmgbase[2] = 0;
-
-	pcicptr->pciccfg &= TX4938_PCIC_PCICCFG_GBWC_MASK;
-	/* Enable Initiator Memory Space */
-	if (channel->mem_resource->end)
-		pcicptr->pciccfg |= TX4938_PCIC_PCICCFG_G2PMEN(0);
-	/* Enable Initiator I/O Space */
-	if (channel->io_resource->end)
-		pcicptr->pciccfg |= TX4938_PCIC_PCICCFG_G2PIOEN;
-	/* Enable Initiator Config */
-	pcicptr->pciccfg |=
-		TX4938_PCIC_PCICCFG_ICAEN |
-		TX4938_PCIC_PCICCFG_TCAR;
-
-	/* Do not use MEMMUL, MEMINF: YMFPCI card causes M_ABORT. */
-	pcicptr->pcicfg1 = 0;
-
-	pcicptr->g2ptocnt &= ~0xffff;
-
-	if (tx4938_pcic_trdyto >= 0) {
-		pcicptr->g2ptocnt &= ~0xff;
-		pcicptr->g2ptocnt |= (tx4938_pcic_trdyto & 0xff);
-	}
-
-	if (tx4938_pcic_retryto >= 0) {
-		pcicptr->g2ptocnt &= ~0xff00;
-		pcicptr->g2ptocnt |= ((tx4938_pcic_retryto<<8) & 0xff00);
-	}
-
-	/* Clear All Local Bus Status */
-	pcicptr->pcicstatus = TX4938_PCIC_PCICSTATUS_ALL;
-	/* Enable All Local Bus Interrupts */
-	pcicptr->pcicmask = TX4938_PCIC_PCICSTATUS_ALL;
-	/* Clear All Initiator Status */
-	pcicptr->g2pstatus = TX4938_PCIC_G2PSTATUS_ALL;
-	/* Enable All Initiator Interrupts */
-	pcicptr->g2pmask = TX4938_PCIC_G2PSTATUS_ALL;
-	/* Clear All PCI Status Error */
-	pcicptr->pcistatus =
-		(pcicptr->pcistatus & 0x0000ffff) |
-		(TX4938_PCIC_PCISTATUS_ALL << 16);
-	/* Enable All PCI Status Error Interrupts */
-	pcicptr->pcimask = TX4938_PCIC_PCISTATUS_ALL;
-
-	if (!extarb) {
-		/* Reset Bus Arbiter */
-		pcicptr->pbacfg = TX4938_PCIC_PBACFG_RPBA;
-		pcicptr->pbabm = 0;
-		/* Enable Bus Arbiter */
-		pcicptr->pbacfg = TX4938_PCIC_PBACFG_PBAEN;
-	}
-
-      /* PCIC Int => IRC IRQ16 */
-	pcicptr->pcicfg2 =
-		    (pcicptr->pcicfg2 & 0xffffff00) | TX4938_IR_PCIC;
-
-	pcicptr->pcistatus = PCI_COMMAND_MASTER |
-		PCI_COMMAND_MEMORY |
-		PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
-}
-
-int __init
-tx4938_report_pciclk(void)
-{
-	unsigned long pcode = TX4938_REV_PCODE();
-	int pciclk = 0;
-	printk("TX%lx PCIC --%s PCICLK:",
-	       pcode,
-	       (tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI66) ? " PCI66" : "");
-	if (tx4938_ccfgptr->pcfg & TX4938_PCFG_PCICLKEN_ALL) {
-
-		switch ((unsigned long)tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIDIVMODE_MASK) {
-		case TX4938_CCFG_PCIDIVMODE_4:
-			pciclk = txx9_cpu_clock / 4; break;
-		case TX4938_CCFG_PCIDIVMODE_4_5:
-			pciclk = txx9_cpu_clock * 2 / 9; break;
-		case TX4938_CCFG_PCIDIVMODE_5:
-			pciclk = txx9_cpu_clock / 5; break;
-		case TX4938_CCFG_PCIDIVMODE_5_5:
-			pciclk = txx9_cpu_clock * 2 / 11; break;
-		case TX4938_CCFG_PCIDIVMODE_8:
-			pciclk = txx9_cpu_clock / 8; break;
-		case TX4938_CCFG_PCIDIVMODE_9:
-			pciclk = txx9_cpu_clock / 9; break;
-		case TX4938_CCFG_PCIDIVMODE_10:
-			pciclk = txx9_cpu_clock / 10; break;
-		case TX4938_CCFG_PCIDIVMODE_11:
-			pciclk = txx9_cpu_clock / 11; break;
-		}
-		printk("Internal(%dMHz)", pciclk / 1000000);
-	} else {
-		printk("External");
-		pciclk = -1;
-	}
-	printk("\n");
-	return pciclk;
-}
-
-void __init set_tx4938_pcicptr(int ch, struct tx4938_pcic_reg *pcicptr)
-{
-	pcicptrs[ch] = pcicptr;
-}
-
-struct tx4938_pcic_reg *get_tx4938_pcicptr(int ch)
-{
-       return pcicptrs[ch];
-}
-
-static struct pci_dev *fake_pci_dev(struct pci_controller *hose,
-                                    int top_bus, int busnr, int devfn)
-{
-	static struct pci_dev dev;
-	static struct pci_bus bus;
+	register_pci_controller(c);
 
-	dev.sysdata = bus.sysdata = hose;
-	dev.devfn = devfn;
-	bus.number = busnr;
-	bus.ops = hose->pci_ops;
-	bus.parent = NULL;
-	dev.bus = &bus;
-
-	return &dev;
-}
-
-#define EARLY_PCI_OP(rw, size, type)                                    \
-static int early_##rw##_config_##size(struct pci_controller *hose,      \
-        int top_bus, int bus, int devfn, int offset, type value)        \
-{                                                                       \
-        return pci_##rw##_config_##size(                                \
-                fake_pci_dev(hose, top_bus, bus, devfn),                \
-                offset, value);                                         \
-}
-
-EARLY_PCI_OP(read, word, u16 *)
-
-int txboard_pci66_check(struct pci_controller *hose, int top_bus, int current_bus)
-{
-	u32 pci_devfn;
-	unsigned short vid;
-	int devfn_start = 0;
-	int devfn_stop = 0xff;
-	int cap66 = -1;
-	u16 stat;
-
-	printk("PCI: Checking 66MHz capabilities...\n");
-
-	for (pci_devfn=devfn_start; pci_devfn<devfn_stop; pci_devfn++) {
-		if (early_read_config_word(hose, top_bus, current_bus,
-					   pci_devfn, PCI_VENDOR_ID,
-					   &vid) != PCIBIOS_SUCCESSFUL)
-			continue;
-
-		if (vid == 0xffff) continue;
-
-		/* check 66MHz capability */
-		if (cap66 < 0)
-			cap66 = 1;
-		if (cap66) {
-			early_read_config_word(hose, top_bus, current_bus, pci_devfn,
-					       PCI_STATUS, &stat);
-			if (!(stat & PCI_STATUS_66MHZ)) {
-				printk(KERN_DEBUG "PCI: %02x:%02x not 66MHz capable.\n",
-				       current_bus, pci_devfn);
-				cap66 = 0;
-				break;
-			}
-		}
-	}
-	return cap66 > 0;
-}
-
-int __init
-tx4938_pciclk66_setup(void)
-{
-	int pciclk;
-
-	/* Assert M66EN */
-	tx4938_ccfgptr->ccfg |= TX4938_CCFG_PCI66;
-	/* Double PCICLK (if possible) */
-	if (tx4938_ccfgptr->pcfg & TX4938_PCFG_PCICLKEN_ALL) {
-		unsigned int pcidivmode =
-			tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIDIVMODE_MASK;
-		switch (pcidivmode) {
-		case TX4938_CCFG_PCIDIVMODE_8:
-		case TX4938_CCFG_PCIDIVMODE_4:
-			pcidivmode = TX4938_CCFG_PCIDIVMODE_4;
-			pciclk = txx9_cpu_clock / 4;
-			break;
-		case TX4938_CCFG_PCIDIVMODE_9:
-		case TX4938_CCFG_PCIDIVMODE_4_5:
-			pcidivmode = TX4938_CCFG_PCIDIVMODE_4_5;
-			pciclk = txx9_cpu_clock * 2 / 9;
-			break;
-		case TX4938_CCFG_PCIDIVMODE_10:
-		case TX4938_CCFG_PCIDIVMODE_5:
-			pcidivmode = TX4938_CCFG_PCIDIVMODE_5;
-			pciclk = txx9_cpu_clock / 5;
-			break;
-		case TX4938_CCFG_PCIDIVMODE_11:
-		case TX4938_CCFG_PCIDIVMODE_5_5:
-		default:
-			pcidivmode = TX4938_CCFG_PCIDIVMODE_5_5;
-			pciclk = txx9_cpu_clock * 2 / 11;
-			break;
-		}
-		tx4938_ccfgptr->ccfg =
-			(tx4938_ccfgptr->ccfg & ~TX4938_CCFG_PCIDIVMODE_MASK)
-			| pcidivmode;
-		printk(KERN_DEBUG "PCICLK: ccfg:%08lx\n",
-		       (unsigned long)tx4938_ccfgptr->ccfg);
-	} else {
-		pciclk = -1;
-	}
-	return pciclk;
-}
-
-extern struct pci_controller tx4938_pci_controller[];
-static int __init tx4938_pcibios_init(void)
-{
-	unsigned long mem_base[2];
-	unsigned long mem_size[2] = {TX4938_PCIMEM_SIZE_0, TX4938_PCIMEM_SIZE_1}; /* MAX 128M,64K */
-	unsigned long io_base[2];
-	unsigned long io_size[2] = {TX4938_PCIIO_SIZE_0, TX4938_PCIIO_SIZE_1}; /* MAX 16M,64K */
-	/* TX4938 PCIC1: 64K MEM/IO is enough for ETH0,ETH1 */
-	int extarb = !(tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIXARB);
-
-	PCIBIOS_MIN_IO = 0x00001000UL;
-
-	mem_base[0] = txboard_request_phys_region_shrink(&mem_size[0]);
-	io_base[0] = txboard_request_phys_region_shrink(&io_size[0]);
-
-	printk("TX4938 PCIC -- DID:%04x VID:%04x RID:%02x Arbiter:%s\n",
-	       (unsigned short)(tx4938_pcicptr->pciid >> 16),
-	       (unsigned short)(tx4938_pcicptr->pciid & 0xffff),
-	       (unsigned short)(tx4938_pcicptr->pciccrev & 0xff),
-	       extarb ? "External" : "Internal");
-
-	/* setup PCI area */
-	tx4938_pci_controller[0].io_resource->start = io_base[0];
-	tx4938_pci_controller[0].io_resource->end = (io_base[0] + io_size[0]) - 1;
-	tx4938_pci_controller[0].mem_resource->start = mem_base[0];
-	tx4938_pci_controller[0].mem_resource->end = mem_base[0] + mem_size[0] - 1;
-
-	set_tx4938_pcicptr(0, tx4938_pcicptr);
-
-	register_pci_controller(&tx4938_pci_controller[0]);
-
-	if (tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI66) {
-		printk("TX4938_CCFG_PCI66 already configured\n");
-		txboard_pci66_mode = -1; /* already configured */
-	}
+	if (__raw_readq(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCI66)
+		txx9_pci_option =
+			(txx9_pci_option & ~TXX9_PCI_OPT_CLK_MASK) |
+			TXX9_PCI_OPT_CLK_66; /* already configured */
 
 	/* Reset PCI Bus */
 	writeb(0, rbtx4938_pcireset_addr);
 	/* Reset PCIC */
-	tx4938_ccfgptr->clkctr |= TX4938_CLKCTR_PCIRST;
-	if (txboard_pci66_mode > 0)
+	txx9_set64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIRST);
+	if ((txx9_pci_option & TXX9_PCI_OPT_CLK_MASK) ==
+	    TXX9_PCI_OPT_CLK_66)
 		tx4938_pciclk66_setup();
 	mdelay(10);
 	/* clear PCIC reset */
-	tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIRST;
+	txx9_clear64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIRST);
 	writeb(1, rbtx4938_pcireset_addr);
-	mmiowb();
-	tx4938_report_pcic_status1(tx4938_pcicptr);
+	iob();
 
 	tx4938_report_pciclk();
-	tx4938_pcic_setup(tx4938_pcicptr, &tx4938_pci_controller[0], io_base[0], extarb);
-	if (txboard_pci66_mode == 0 &&
-	    txboard_pci66_check(&tx4938_pci_controller[0], 0, 0)) {
+	tx4927_pcic_setup(tx4938_pcicptr, c, extarb);
+	if ((txx9_pci_option & TXX9_PCI_OPT_CLK_MASK) ==
+	    TXX9_PCI_OPT_CLK_AUTO &&
+	    txx9_pci66_check(c, 0, 0)) {
 		/* Reset PCI Bus */
 		writeb(0, rbtx4938_pcireset_addr);
 		/* Reset PCIC */
-		tx4938_ccfgptr->clkctr |= TX4938_CLKCTR_PCIRST;
+		txx9_set64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIRST);
 		tx4938_pciclk66_setup();
 		mdelay(10);
 		/* clear PCIC reset */
-		tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIRST;
+		txx9_clear64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIRST);
 		writeb(1, rbtx4938_pcireset_addr);
-		mmiowb();
+		iob();
 		/* Reinitialize PCIC */
 		tx4938_report_pciclk();
-		tx4938_pcic_setup(tx4938_pcicptr, &tx4938_pci_controller[0], io_base[0], extarb);
+		tx4927_pcic_setup(tx4938_pcicptr, c, extarb);
 	}
 
-	mem_base[1] = txboard_request_phys_region_shrink(&mem_size[1]);
-	io_base[1] = txboard_request_phys_region_shrink(&io_size[1]);
-	/* Reset PCIC1 */
-	tx4938_ccfgptr->clkctr |= TX4938_CLKCTR_PCIC1RST;
-	/* PCI1DMD==0 => PCI1CLK==GBUSCLK/2 => PCI66 */
-	if (!(tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI1DMD))
-		tx4938_ccfgptr->ccfg |= TX4938_CCFG_PCI1_66;
-	else
-		tx4938_ccfgptr->ccfg &= ~TX4938_CCFG_PCI1_66;
-	mdelay(10);
-	/* clear PCIC1 reset */
-	tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIC1RST;
-	tx4938_report_pcic_status1(tx4938_pcic1ptr);
-
-	printk("TX4938 PCIC1 -- DID:%04x VID:%04x RID:%02x",
-	       (unsigned short)(tx4938_pcic1ptr->pciid >> 16),
-	       (unsigned short)(tx4938_pcic1ptr->pciid & 0xffff),
-	       (unsigned short)(tx4938_pcic1ptr->pciccrev & 0xff));
-	printk("%s PCICLK:%dMHz\n",
-	       (tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI1_66) ? " PCI66" : "",
-	       txx9_gbus_clock /
-	       ((tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI1DMD) ? 4 : 2) /
-	       1000000);
-
-	/* assumption: CPHYSADDR(mips_io_port_base) == io_base[0] */
-	tx4938_pci_controller[1].io_resource->start =
-		io_base[1] - io_base[0];
-	tx4938_pci_controller[1].io_resource->end =
-		io_base[1] - io_base[0] + io_size[1] - 1;
-	tx4938_pci_controller[1].mem_resource->start = mem_base[1];
-	tx4938_pci_controller[1].mem_resource->end =
-		mem_base[1] + mem_size[1] - 1;
-	set_tx4938_pcicptr(1, tx4938_pcic1ptr);
-
-	register_pci_controller(&tx4938_pci_controller[1]);
-
-	tx4938_pcic_setup(tx4938_pcic1ptr, &tx4938_pci_controller[1], io_base[1], extarb);
-
-	/* map ioport 0 to PCI I/O space address 0 */
-	set_io_port_base(KSEG1 + io_base[0]);
-
-	return 0;
-}
-
-arch_initcall(tx4938_pcibios_init);
-
+	if (__raw_readq(&tx4938_ccfgptr->pcfg) &
+	    (TX4938_PCFG_ETH0_SEL|TX4938_PCFG_ETH1_SEL)) {
+		/* Reset PCIC1 */
+		txx9_set64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIC1RST);
+		/* PCI1DMD==0 => PCI1CLK==GBUSCLK/2 => PCI66 */
+		if (!(__raw_readq(&tx4938_ccfgptr->ccfg)
+		      & TX4938_CCFG_PCI1DMD))
+			tx4938_ccfg_set(TX4938_CCFG_PCI1_66);
+		mdelay(10);
+		/* clear PCIC1 reset */
+		txx9_clear64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIC1RST);
+		tx4938_report_pci1clk();
+
+		/* mem:64K(max), io:64K(max) (enough for ETH0,ETH1) */
+		c = txx9_alloc_pci_controller(NULL, 0, 0x10000, 0, 0x10000);
+		register_pci_controller(c);
+		tx4927_pcic_setup(tx4938_pcic1ptr, c, 0);
+	}
 #endif /* CONFIG_PCI */
+}
 
 /* SPI support */
 
@@ -594,7 +170,7 @@ static int __init rbtx4938_ethaddr_init(void)
 		unsigned int id =
 			TXX9_IRQ_BASE + (i ? TX4938_IR_ETH1 : TX4938_IR_ETH0);
 		struct platform_device *pdev;
-		if (!(tx4938_ccfgptr->pcfg &
+		if (!(__raw_readq(&tx4938_ccfgptr->pcfg) &
 		      (i ? TX4938_PCFG_ETH1_SEL : TX4938_PCFG_ETH0_SEL)))
 			continue;
 		pdev = platform_device_alloc("tc35815-mac", id);
@@ -611,18 +187,12 @@ device_initcall(rbtx4938_ethaddr_init);
 static void __init rbtx4938_spi_setup(void)
 {
 	/* set SPI_SEL */
-	tx4938_ccfgptr->pcfg |= TX4938_PCFG_SPI_SEL;
+	txx9_set64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_SPI_SEL);
 }
 
 static struct resource rbtx4938_fpga_resource;
-
-static char pcode_str[8];
-static struct resource tx4938_reg_resource = {
-	.start	= TX4938_REG_BASE,
-	.end	= TX4938_REG_BASE + TX4938_REG_SIZE,
-	.name	= pcode_str,
-	.flags	= IORESOURCE_MEM
-};
+static struct resource tx4938_sdram_resource[4];
+static struct resource tx4938_sram_resource;
 
 void __init tx4938_board_setup(void)
 {
@@ -631,24 +201,28 @@ void __init tx4938_board_setup(void)
 	int cpuclk = 0;
 	unsigned long pcode = TX4938_REV_PCODE();
 
-	ioport_resource.start = 0x1000;
+	ioport_resource.start = 0;
 	ioport_resource.end = 0xffffffff;
-	iomem_resource.start = 0x1000;
+	iomem_resource.start = 0;
 	iomem_resource.end = 0xffffffff;	/* expand to 4GB */
 
-	sprintf(pcode_str, "TX%lx", pcode);
+	txx9_reg_res_init(pcode, TX4938_REG_BASE,
+			  TX4938_REG_SIZE);
 	/* SDRAMC,EBUSC are configured by PROM */
 	for (i = 0; i < 8; i++) {
-		if (!(tx4938_ebuscptr->cr[i] & 0x8))
+		if (!(TX4938_EBUSC_CR(i) & 0x8))
 			continue;	/* disabled */
-		rbtx4938_ce_base[i] = (unsigned long)TX4938_EBUSC_BA(i);
-		txboard_add_phys_region(rbtx4938_ce_base[i], TX4938_EBUSC_SIZE(i));
+		txx9_ce_res[i].start = (unsigned long)TX4938_EBUSC_BA(i);
+		txx9_ce_res[i].end =
+			txx9_ce_res[i].start + TX4938_EBUSC_SIZE(i) - 1;
+		request_resource(&iomem_resource, &txx9_ce_res[i]);
 	}
 
 	/* clocks */
 	if (txx9_master_clock) {
+		u64 ccfg = ____raw_readq(&tx4938_ccfgptr->ccfg);
 		/* calculate gbus_clock and cpu_clock_freq from master_clock */
-		divmode = (unsigned long)tx4938_ccfgptr->ccfg & TX4938_CCFG_DIVMODE_MASK;
+		divmode = (__u32)ccfg & TX4938_CCFG_DIVMODE_MASK;
 		switch (divmode) {
 		case TX4938_CCFG_DIVMODE_8:
 		case TX4938_CCFG_DIVMODE_10:
@@ -678,12 +252,13 @@ void __init tx4938_board_setup(void)
 		}
 		txx9_cpu_clock = cpuclk;
 	} else {
+		u64 ccfg = ____raw_readq(&tx4938_ccfgptr->ccfg);
 		if (txx9_cpu_clock == 0) {
 			txx9_cpu_clock = 300000000;	/* 300MHz */
 		}
 		/* calculate gbus_clock and master_clock from cpu_clock_freq */
 		cpuclk = txx9_cpu_clock;
-		divmode = (unsigned long)tx4938_ccfgptr->ccfg & TX4938_CCFG_DIVMODE_MASK;
+		divmode = (__u32)ccfg & TX4938_CCFG_DIVMODE_MASK;
 		switch (divmode) {
 		case TX4938_CCFG_DIVMODE_2:
 		case TX4938_CCFG_DIVMODE_8:
@@ -717,32 +292,32 @@ void __init tx4938_board_setup(void)
 
 	/* CCFG */
 	/* clear WatchDogReset,BusErrorOnWrite flag (W1C) */
-	tx4938_ccfgptr->ccfg |= TX4938_CCFG_WDRST | TX4938_CCFG_BEOW;
+	tx4938_ccfg_set(TX4938_CCFG_WDRST | TX4938_CCFG_BEOW);
 	/* do reset on watchdog */
-	tx4938_ccfgptr->ccfg |= TX4938_CCFG_WR;
+	tx4938_ccfg_set(TX4938_CCFG_WR);
 	/* clear PCIC1 reset */
-	if (tx4938_ccfgptr->clkctr & TX4938_CLKCTR_PCIC1RST)
-		tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIC1RST;
+	txx9_clear64(&tx4938_ccfgptr->clkctr, TX4938_CLKCTR_PCIC1RST);
 
 	/* enable Timeout BusError */
 	if (tx4938_ccfg_toeon)
-		tx4938_ccfgptr->ccfg |= TX4938_CCFG_TOE;
+		tx4938_ccfg_set(TX4938_CCFG_TOE);
 
 	/* DMA selection */
-	tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_DMASEL_ALL;
+	txx9_clear64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_DMASEL_ALL);
 
 	/* Use external clock for external arbiter */
-	if (!(tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIXARB))
-		tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_PCICLKEN_ALL;
-
-	printk("%s -- %dMHz(M%dMHz) CRIR:%08lx CCFG:%Lx PCFG:%Lx\n",
-	       pcode_str,
-	       cpuclk / 1000000, txx9_master_clock / 1000000,
-	       (unsigned long)tx4938_ccfgptr->crir,
-	       tx4938_ccfgptr->ccfg,
-	       tx4938_ccfgptr->pcfg);
-
-	printk("%s SDRAMC --", pcode_str);
+	if (!(____raw_readq(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_PCIARB))
+		txx9_clear64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_PCICLKEN_ALL);
+
+	printk(KERN_INFO "%s -- %dMHz(M%dMHz) CRIR:%08x CCFG:%llx PCFG:%llx\n",
+	       txx9_pcode_str,
+	       (cpuclk + 500000) / 1000000,
+	       (txx9_master_clock + 500000) / 1000000,
+	       (__u32)____raw_readq(&tx4938_ccfgptr->crir),
+	       (unsigned long long)____raw_readq(&tx4938_ccfgptr->ccfg),
+	       (unsigned long long)____raw_readq(&tx4938_ccfgptr->pcfg));
+
+	printk(KERN_INFO "%s SDRAMC --", txx9_pcode_str);
 	for (i = 0; i < 4; i++) {
 		unsigned long long cr = tx4938_sdramcptr->cr[i];
 		unsigned long ram_base, ram_size;
@@ -753,16 +328,24 @@ void __init tx4938_board_setup(void)
 		if (ram_base >= 0x20000000)
 			continue;	/* high memory (ignore) */
 		printk(" CR%d:%016Lx", i, cr);
-		txboard_add_phys_region(ram_base, ram_size);
+		tx4938_sdram_resource[i].name = "SDRAM";
+		tx4938_sdram_resource[i].start = ram_base;
+		tx4938_sdram_resource[i].end = ram_base + ram_size - 1;
+		tx4938_sdram_resource[i].flags = IORESOURCE_MEM;
+		request_resource(&iomem_resource, &tx4938_sdram_resource[i]);
 	}
 	printk(" TR:%09Lx\n", tx4938_sdramcptr->tr);
 
 	/* SRAM */
-	if (pcode == 0x4938 && tx4938_sramcptr->cr & 1) {
+	if (tx4938_sramcptr->cr & 1) {
 		unsigned int size = 0x800;
 		unsigned long base =
 			(tx4938_sramcptr->cr >> (39-11)) & ~(size - 1);
-		 txboard_add_phys_region(base, size);
+		tx4938_sram_resource.name = "SRAM";
+		tx4938_sram_resource.start = base;
+		tx4938_sram_resource.end = base + size - 1;
+		tx4938_sram_resource.flags = IORESOURCE_MEM;
+		request_resource(&iomem_resource, &tx4938_sram_resource);
 	}
 
 	/* TMR */
@@ -778,71 +361,15 @@ void __init tx4938_board_setup(void)
 	__raw_writel(0, &tx4938_pioptr->maskcpu);
 	__raw_writel(0, &tx4938_pioptr->maskext);
 
-	/* TX4938 internal registers */
-	if (request_resource(&iomem_resource, &tx4938_reg_resource))
-		printk("request resource for internal registers failed\n");
-}
-
 #ifdef CONFIG_PCI
-static inline void tx4938_report_pcic_status1(struct tx4938_pcic_reg *pcicptr)
-{
-	unsigned short pcistatus = (unsigned short)(pcicptr->pcistatus >> 16);
-	unsigned long g2pstatus = pcicptr->g2pstatus;
-	unsigned long pcicstatus = pcicptr->pcicstatus;
-	static struct {
-		unsigned long flag;
-		const char *str;
-	} pcistat_tbl[] = {
-		{ PCI_STATUS_DETECTED_PARITY,	"DetectedParityError" },
-		{ PCI_STATUS_SIG_SYSTEM_ERROR,	"SignaledSystemError" },
-		{ PCI_STATUS_REC_MASTER_ABORT,	"ReceivedMasterAbort" },
-		{ PCI_STATUS_REC_TARGET_ABORT,	"ReceivedTargetAbort" },
-		{ PCI_STATUS_SIG_TARGET_ABORT,	"SignaledTargetAbort" },
-		{ PCI_STATUS_PARITY,	"MasterParityError" },
-	}, g2pstat_tbl[] = {
-		{ TX4938_PCIC_G2PSTATUS_TTOE,	"TIOE" },
-		{ TX4938_PCIC_G2PSTATUS_RTOE,	"RTOE" },
-	}, pcicstat_tbl[] = {
-		{ TX4938_PCIC_PCICSTATUS_PME,	"PME" },
-		{ TX4938_PCIC_PCICSTATUS_TLB,	"TLB" },
-		{ TX4938_PCIC_PCICSTATUS_NIB,	"NIB" },
-		{ TX4938_PCIC_PCICSTATUS_ZIB,	"ZIB" },
-		{ TX4938_PCIC_PCICSTATUS_PERR,	"PERR" },
-		{ TX4938_PCIC_PCICSTATUS_SERR,	"SERR" },
-		{ TX4938_PCIC_PCICSTATUS_GBE,	"GBE" },
-		{ TX4938_PCIC_PCICSTATUS_IWB,	"IWB" },
-	};
-	int i;
-
-	printk("pcistat:%04x(", pcistatus);
-	for (i = 0; i < ARRAY_SIZE(pcistat_tbl); i++)
-		if (pcistatus & pcistat_tbl[i].flag)
-			printk("%s ", pcistat_tbl[i].str);
-	printk("), g2pstatus:%08lx(", g2pstatus);
-	for (i = 0; i < ARRAY_SIZE(g2pstat_tbl); i++)
-		if (g2pstatus & g2pstat_tbl[i].flag)
-			printk("%s ", g2pstat_tbl[i].str);
-	printk("), pcicstatus:%08lx(", pcicstatus);
-	for (i = 0; i < ARRAY_SIZE(pcicstat_tbl); i++)
-		if (pcicstatus & pcicstat_tbl[i].flag)
-			printk("%s ", pcicstat_tbl[i].str);
-	printk(")\n");
-}
-
-void tx4938_report_pcic_status(void)
-{
-	int i;
-	struct tx4938_pcic_reg *pcicptr;
-	for (i = 0; (pcicptr = get_tx4938_pcicptr(i)) != NULL; i++)
-		tx4938_report_pcic_status1(pcicptr);
+	txx9_alloc_pci_controller(&txx9_primary_pcic, 0, 0, 0, 0);
+#endif
 }
 
-#endif /* CONFIG_PCI */
-
 void __init plat_time_init(void)
 {
 	mips_hpt_frequency = txx9_cpu_clock / 2;
-	if (tx4938_ccfgptr->ccfg & TX4938_CCFG_TINTDIS)
+	if (____raw_readq(&tx4938_ccfgptr->ccfg) & TX4938_CCFG_TINTDIS)
 		txx9_clockevent_init(TX4938_TMR_REG(0) & 0xfffffffffULL,
 				     TXX9_IRQ_BASE + TX4938_IR_TMR(0),
 				     txx9_gbus_clock / 2);
@@ -890,19 +417,20 @@ void __init plat_mem_setup(void)
 #ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_PIO58_61
 	printk("PIOSEL: disabling both ata and nand selection\n");
 	local_irq_disable();
-	tx4938_ccfgptr->pcfg &= ~(TX4938_PCFG_NDF_SEL | TX4938_PCFG_ATA_SEL);
+	txx9_clear64(&tx4938_ccfgptr->pcfg,
+		     TX4938_PCFG_NDF_SEL | TX4938_PCFG_ATA_SEL);
 #endif
 
 #ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_NAND
 	printk("PIOSEL: enabling nand selection\n");
-	tx4938_ccfgptr->pcfg |= TX4938_PCFG_NDF_SEL;
-	tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_ATA_SEL;
+	txx9_set64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_NDF_SEL);
+	txx9_clear64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_ATA_SEL);
 #endif
 
 #ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_ATA
 	printk("PIOSEL: enabling ata selection\n");
-	tx4938_ccfgptr->pcfg |= TX4938_PCFG_ATA_SEL;
-	tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_NDF_SEL;
+	txx9_set64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_ATA_SEL);
+	txx9_clear64(&tx4938_ccfgptr->pcfg, TX4938_PCFG_NDF_SEL);
 #endif
 
 #ifdef CONFIG_IP_PNP
@@ -920,7 +448,7 @@ void __init plat_mem_setup(void)
 #endif
 
 	rbtx4938_spi_setup();
-	pcfg = tx4938_ccfgptr->pcfg;	/* updated */
+	pcfg = ____raw_readq(&tx4938_ccfgptr->pcfg);	/* updated */
 	/* fixup piosel */
 	if ((pcfg & (TX4938_PCFG_ATA_SEL | TX4938_PCFG_NDF_SEL)) ==
 	    TX4938_PCFG_ATA_SEL)
@@ -1063,6 +591,7 @@ static int __init rbtx4938_arch_init(void)
 {
 	txx9_gpio_init(TX4938_PIO_REG & 0xfffffffffULL, 0, 16);
 	gpiochip_add(&rbtx4938_spi_gpio_chip);
+	rbtx4938_pci_setup();
 	return rbtx4938_spi_init();
 }
 arch_initcall(rbtx4938_arch_init);

commit 22b1d707ffc99faebd86257ad19d5bb9fc624734
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 00:31:36 2008 +0900

    [MIPS] TXx9: Reorganize code
    
    Move arch/mips/{jmr3927,tx4927,tx4938} into arch/mips/txx9/ tree.
    This will help more code sharing and maintainance.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/txx9/rbtx4938/setup.c b/arch/mips/txx9/rbtx4938/setup.c
new file mode 100644
index 000000000000..bbd572c9675b
--- /dev/null
+++ b/arch/mips/txx9/rbtx4938/setup.c
@@ -0,0 +1,1122 @@
+/*
+ * Setup pointers to hardware-dependent routines.
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * 2003-2005 (c) MontaVista Software, Inc. This file is licensed under the
+ * terms of the GNU General Public License version 2. This program is
+ * licensed "as is" without any warranty of any kind, whether express
+ * or implied.
+ *
+ * Support for TX4938 in 2.6 - Manish Lachwani (mlachwani@mvista.com)
+ */
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/console.h>
+#include <linux/pci.h>
+#include <linux/pm.h>
+#include <linux/platform_device.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+
+#include <asm/reboot.h>
+#include <asm/time.h>
+#include <asm/txx9tmr.h>
+#include <asm/io.h>
+#include <asm/bootinfo.h>
+#include <asm/txx9/rbtx4938.h>
+#ifdef CONFIG_SERIAL_TXX9
+#include <linux/serial_core.h>
+#endif
+#include <linux/spi/spi.h>
+#include <asm/txx9/spi.h>
+#include <asm/txx9pio.h>
+
+extern char * __init prom_getcmdline(void);
+static inline void tx4938_report_pcic_status1(struct tx4938_pcic_reg *pcicptr);
+
+/* These functions are used for rebooting or halting the machine*/
+extern void rbtx4938_machine_restart(char *command);
+extern void rbtx4938_machine_halt(void);
+extern void rbtx4938_machine_power_off(void);
+
+/* clocks */
+unsigned int txx9_master_clock;
+unsigned int txx9_cpu_clock;
+unsigned int txx9_gbus_clock;
+
+unsigned long rbtx4938_ce_base[8];
+unsigned long rbtx4938_ce_size[8];
+int txboard_pci66_mode;
+static int tx4938_pcic_trdyto;	/* default: disabled */
+static int tx4938_pcic_retryto;	/* default: disabled */
+static int tx4938_ccfg_toeon = 1;
+
+struct tx4938_pcic_reg *pcicptrs[4] = {
+       tx4938_pcicptr  /* default setting for TX4938 */
+};
+
+static struct {
+	unsigned long base;
+	unsigned long size;
+} phys_regions[16] __initdata;
+static int num_phys_regions  __initdata;
+
+#define PHYS_REGION_MINSIZE	0x10000
+
+void rbtx4938_machine_halt(void)
+{
+        printk(KERN_NOTICE "System Halted\n");
+	local_irq_disable();
+
+	while (1)
+		__asm__(".set\tmips3\n\t"
+			"wait\n\t"
+			".set\tmips0");
+}
+
+void rbtx4938_machine_power_off(void)
+{
+        rbtx4938_machine_halt();
+        /* no return */
+}
+
+void rbtx4938_machine_restart(char *command)
+{
+	local_irq_disable();
+
+	printk("Rebooting...");
+	writeb(1, rbtx4938_softresetlock_addr);
+	writeb(1, rbtx4938_sfvol_addr);
+	writeb(1, rbtx4938_softreset_addr);
+	while(1)
+		;
+}
+
+void __init
+txboard_add_phys_region(unsigned long base, unsigned long size)
+{
+	if (num_phys_regions >= ARRAY_SIZE(phys_regions)) {
+		printk("phys_region overflow\n");
+		return;
+	}
+	phys_regions[num_phys_regions].base = base;
+	phys_regions[num_phys_regions].size = size;
+	num_phys_regions++;
+}
+unsigned long __init
+txboard_find_free_phys_region(unsigned long begin, unsigned long end,
+			      unsigned long size)
+{
+	unsigned long base;
+	int i;
+
+	for (base = begin / size * size; base < end; base += size) {
+		for (i = 0; i < num_phys_regions; i++) {
+			if (phys_regions[i].size &&
+			    base <= phys_regions[i].base + (phys_regions[i].size - 1) &&
+			    base + (size - 1) >= phys_regions[i].base)
+				break;
+		}
+		if (i == num_phys_regions)
+			return base;
+	}
+	return 0;
+}
+unsigned long __init
+txboard_find_free_phys_region_shrink(unsigned long begin, unsigned long end,
+				     unsigned long *size)
+{
+	unsigned long sz, base;
+	for (sz = *size; sz >= PHYS_REGION_MINSIZE; sz /= 2) {
+		base = txboard_find_free_phys_region(begin, end, sz);
+		if (base) {
+			*size = sz;
+			return base;
+		}
+	}
+	return 0;
+}
+unsigned long __init
+txboard_request_phys_region_range(unsigned long begin, unsigned long end,
+				  unsigned long size)
+{
+	unsigned long base;
+	base = txboard_find_free_phys_region(begin, end, size);
+	if (base)
+		txboard_add_phys_region(base, size);
+	return base;
+}
+unsigned long __init
+txboard_request_phys_region(unsigned long size)
+{
+	unsigned long base;
+	unsigned long begin = 0, end = 0x20000000;	/* search low 512MB */
+	base = txboard_find_free_phys_region(begin, end, size);
+	if (base)
+		txboard_add_phys_region(base, size);
+	return base;
+}
+unsigned long __init
+txboard_request_phys_region_shrink(unsigned long *size)
+{
+	unsigned long base;
+	unsigned long begin = 0, end = 0x20000000;	/* search low 512MB */
+	base = txboard_find_free_phys_region_shrink(begin, end, size);
+	if (base)
+		txboard_add_phys_region(base, *size);
+	return base;
+}
+
+#ifdef CONFIG_PCI
+void __init
+tx4938_pcic_setup(struct tx4938_pcic_reg *pcicptr,
+		  struct pci_controller *channel,
+		  unsigned long pci_io_base,
+		  int extarb)
+{
+	int i;
+
+	/* Disable All Initiator Space */
+	pcicptr->pciccfg &= ~(TX4938_PCIC_PCICCFG_G2PMEN(0)|
+			      TX4938_PCIC_PCICCFG_G2PMEN(1)|
+			      TX4938_PCIC_PCICCFG_G2PMEN(2)|
+			      TX4938_PCIC_PCICCFG_G2PIOEN);
+
+	/* GB->PCI mappings */
+	pcicptr->g2piomask = (channel->io_resource->end - channel->io_resource->start) >> 4;
+	pcicptr->g2piogbase = pci_io_base |
+#ifdef __BIG_ENDIAN
+		TX4938_PCIC_G2PIOGBASE_ECHG
+#else
+		TX4938_PCIC_G2PIOGBASE_BSDIS
+#endif
+		;
+	pcicptr->g2piopbase = 0;
+	for (i = 0; i < 3; i++) {
+		pcicptr->g2pmmask[i] = 0;
+		pcicptr->g2pmgbase[i] = 0;
+		pcicptr->g2pmpbase[i] = 0;
+	}
+	if (channel->mem_resource->end) {
+		pcicptr->g2pmmask[0] = (channel->mem_resource->end - channel->mem_resource->start) >> 4;
+		pcicptr->g2pmgbase[0] = channel->mem_resource->start |
+#ifdef __BIG_ENDIAN
+			TX4938_PCIC_G2PMnGBASE_ECHG
+#else
+			TX4938_PCIC_G2PMnGBASE_BSDIS
+#endif
+			;
+		pcicptr->g2pmpbase[0] = channel->mem_resource->start;
+	}
+	/* PCI->GB mappings (I/O 256B) */
+	pcicptr->p2giopbase = 0; /* 256B */
+	pcicptr->p2giogbase = 0;
+	/* PCI->GB mappings (MEM 512MB (64MB on R1.x)) */
+	pcicptr->p2gm0plbase = 0;
+	pcicptr->p2gm0pubase = 0;
+	pcicptr->p2gmgbase[0] = 0 |
+		TX4938_PCIC_P2GMnGBASE_TMEMEN |
+#ifdef __BIG_ENDIAN
+		TX4938_PCIC_P2GMnGBASE_TECHG
+#else
+		TX4938_PCIC_P2GMnGBASE_TBSDIS
+#endif
+		;
+	/* PCI->GB mappings (MEM 16MB) */
+	pcicptr->p2gm1plbase = 0xffffffff;
+	pcicptr->p2gm1pubase = 0xffffffff;
+	pcicptr->p2gmgbase[1] = 0;
+	/* PCI->GB mappings (MEM 1MB) */
+	pcicptr->p2gm2pbase = 0xffffffff; /* 1MB */
+	pcicptr->p2gmgbase[2] = 0;
+
+	pcicptr->pciccfg &= TX4938_PCIC_PCICCFG_GBWC_MASK;
+	/* Enable Initiator Memory Space */
+	if (channel->mem_resource->end)
+		pcicptr->pciccfg |= TX4938_PCIC_PCICCFG_G2PMEN(0);
+	/* Enable Initiator I/O Space */
+	if (channel->io_resource->end)
+		pcicptr->pciccfg |= TX4938_PCIC_PCICCFG_G2PIOEN;
+	/* Enable Initiator Config */
+	pcicptr->pciccfg |=
+		TX4938_PCIC_PCICCFG_ICAEN |
+		TX4938_PCIC_PCICCFG_TCAR;
+
+	/* Do not use MEMMUL, MEMINF: YMFPCI card causes M_ABORT. */
+	pcicptr->pcicfg1 = 0;
+
+	pcicptr->g2ptocnt &= ~0xffff;
+
+	if (tx4938_pcic_trdyto >= 0) {
+		pcicptr->g2ptocnt &= ~0xff;
+		pcicptr->g2ptocnt |= (tx4938_pcic_trdyto & 0xff);
+	}
+
+	if (tx4938_pcic_retryto >= 0) {
+		pcicptr->g2ptocnt &= ~0xff00;
+		pcicptr->g2ptocnt |= ((tx4938_pcic_retryto<<8) & 0xff00);
+	}
+
+	/* Clear All Local Bus Status */
+	pcicptr->pcicstatus = TX4938_PCIC_PCICSTATUS_ALL;
+	/* Enable All Local Bus Interrupts */
+	pcicptr->pcicmask = TX4938_PCIC_PCICSTATUS_ALL;
+	/* Clear All Initiator Status */
+	pcicptr->g2pstatus = TX4938_PCIC_G2PSTATUS_ALL;
+	/* Enable All Initiator Interrupts */
+	pcicptr->g2pmask = TX4938_PCIC_G2PSTATUS_ALL;
+	/* Clear All PCI Status Error */
+	pcicptr->pcistatus =
+		(pcicptr->pcistatus & 0x0000ffff) |
+		(TX4938_PCIC_PCISTATUS_ALL << 16);
+	/* Enable All PCI Status Error Interrupts */
+	pcicptr->pcimask = TX4938_PCIC_PCISTATUS_ALL;
+
+	if (!extarb) {
+		/* Reset Bus Arbiter */
+		pcicptr->pbacfg = TX4938_PCIC_PBACFG_RPBA;
+		pcicptr->pbabm = 0;
+		/* Enable Bus Arbiter */
+		pcicptr->pbacfg = TX4938_PCIC_PBACFG_PBAEN;
+	}
+
+      /* PCIC Int => IRC IRQ16 */
+	pcicptr->pcicfg2 =
+		    (pcicptr->pcicfg2 & 0xffffff00) | TX4938_IR_PCIC;
+
+	pcicptr->pcistatus = PCI_COMMAND_MASTER |
+		PCI_COMMAND_MEMORY |
+		PCI_COMMAND_PARITY | PCI_COMMAND_SERR;
+}
+
+int __init
+tx4938_report_pciclk(void)
+{
+	unsigned long pcode = TX4938_REV_PCODE();
+	int pciclk = 0;
+	printk("TX%lx PCIC --%s PCICLK:",
+	       pcode,
+	       (tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI66) ? " PCI66" : "");
+	if (tx4938_ccfgptr->pcfg & TX4938_PCFG_PCICLKEN_ALL) {
+
+		switch ((unsigned long)tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIDIVMODE_MASK) {
+		case TX4938_CCFG_PCIDIVMODE_4:
+			pciclk = txx9_cpu_clock / 4; break;
+		case TX4938_CCFG_PCIDIVMODE_4_5:
+			pciclk = txx9_cpu_clock * 2 / 9; break;
+		case TX4938_CCFG_PCIDIVMODE_5:
+			pciclk = txx9_cpu_clock / 5; break;
+		case TX4938_CCFG_PCIDIVMODE_5_5:
+			pciclk = txx9_cpu_clock * 2 / 11; break;
+		case TX4938_CCFG_PCIDIVMODE_8:
+			pciclk = txx9_cpu_clock / 8; break;
+		case TX4938_CCFG_PCIDIVMODE_9:
+			pciclk = txx9_cpu_clock / 9; break;
+		case TX4938_CCFG_PCIDIVMODE_10:
+			pciclk = txx9_cpu_clock / 10; break;
+		case TX4938_CCFG_PCIDIVMODE_11:
+			pciclk = txx9_cpu_clock / 11; break;
+		}
+		printk("Internal(%dMHz)", pciclk / 1000000);
+	} else {
+		printk("External");
+		pciclk = -1;
+	}
+	printk("\n");
+	return pciclk;
+}
+
+void __init set_tx4938_pcicptr(int ch, struct tx4938_pcic_reg *pcicptr)
+{
+	pcicptrs[ch] = pcicptr;
+}
+
+struct tx4938_pcic_reg *get_tx4938_pcicptr(int ch)
+{
+       return pcicptrs[ch];
+}
+
+static struct pci_dev *fake_pci_dev(struct pci_controller *hose,
+                                    int top_bus, int busnr, int devfn)
+{
+	static struct pci_dev dev;
+	static struct pci_bus bus;
+
+	dev.sysdata = bus.sysdata = hose;
+	dev.devfn = devfn;
+	bus.number = busnr;
+	bus.ops = hose->pci_ops;
+	bus.parent = NULL;
+	dev.bus = &bus;
+
+	return &dev;
+}
+
+#define EARLY_PCI_OP(rw, size, type)                                    \
+static int early_##rw##_config_##size(struct pci_controller *hose,      \
+        int top_bus, int bus, int devfn, int offset, type value)        \
+{                                                                       \
+        return pci_##rw##_config_##size(                                \
+                fake_pci_dev(hose, top_bus, bus, devfn),                \
+                offset, value);                                         \
+}
+
+EARLY_PCI_OP(read, word, u16 *)
+
+int txboard_pci66_check(struct pci_controller *hose, int top_bus, int current_bus)
+{
+	u32 pci_devfn;
+	unsigned short vid;
+	int devfn_start = 0;
+	int devfn_stop = 0xff;
+	int cap66 = -1;
+	u16 stat;
+
+	printk("PCI: Checking 66MHz capabilities...\n");
+
+	for (pci_devfn=devfn_start; pci_devfn<devfn_stop; pci_devfn++) {
+		if (early_read_config_word(hose, top_bus, current_bus,
+					   pci_devfn, PCI_VENDOR_ID,
+					   &vid) != PCIBIOS_SUCCESSFUL)
+			continue;
+
+		if (vid == 0xffff) continue;
+
+		/* check 66MHz capability */
+		if (cap66 < 0)
+			cap66 = 1;
+		if (cap66) {
+			early_read_config_word(hose, top_bus, current_bus, pci_devfn,
+					       PCI_STATUS, &stat);
+			if (!(stat & PCI_STATUS_66MHZ)) {
+				printk(KERN_DEBUG "PCI: %02x:%02x not 66MHz capable.\n",
+				       current_bus, pci_devfn);
+				cap66 = 0;
+				break;
+			}
+		}
+	}
+	return cap66 > 0;
+}
+
+int __init
+tx4938_pciclk66_setup(void)
+{
+	int pciclk;
+
+	/* Assert M66EN */
+	tx4938_ccfgptr->ccfg |= TX4938_CCFG_PCI66;
+	/* Double PCICLK (if possible) */
+	if (tx4938_ccfgptr->pcfg & TX4938_PCFG_PCICLKEN_ALL) {
+		unsigned int pcidivmode =
+			tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIDIVMODE_MASK;
+		switch (pcidivmode) {
+		case TX4938_CCFG_PCIDIVMODE_8:
+		case TX4938_CCFG_PCIDIVMODE_4:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_4;
+			pciclk = txx9_cpu_clock / 4;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_9:
+		case TX4938_CCFG_PCIDIVMODE_4_5:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_4_5;
+			pciclk = txx9_cpu_clock * 2 / 9;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_10:
+		case TX4938_CCFG_PCIDIVMODE_5:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_5;
+			pciclk = txx9_cpu_clock / 5;
+			break;
+		case TX4938_CCFG_PCIDIVMODE_11:
+		case TX4938_CCFG_PCIDIVMODE_5_5:
+		default:
+			pcidivmode = TX4938_CCFG_PCIDIVMODE_5_5;
+			pciclk = txx9_cpu_clock * 2 / 11;
+			break;
+		}
+		tx4938_ccfgptr->ccfg =
+			(tx4938_ccfgptr->ccfg & ~TX4938_CCFG_PCIDIVMODE_MASK)
+			| pcidivmode;
+		printk(KERN_DEBUG "PCICLK: ccfg:%08lx\n",
+		       (unsigned long)tx4938_ccfgptr->ccfg);
+	} else {
+		pciclk = -1;
+	}
+	return pciclk;
+}
+
+extern struct pci_controller tx4938_pci_controller[];
+static int __init tx4938_pcibios_init(void)
+{
+	unsigned long mem_base[2];
+	unsigned long mem_size[2] = {TX4938_PCIMEM_SIZE_0, TX4938_PCIMEM_SIZE_1}; /* MAX 128M,64K */
+	unsigned long io_base[2];
+	unsigned long io_size[2] = {TX4938_PCIIO_SIZE_0, TX4938_PCIIO_SIZE_1}; /* MAX 16M,64K */
+	/* TX4938 PCIC1: 64K MEM/IO is enough for ETH0,ETH1 */
+	int extarb = !(tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIXARB);
+
+	PCIBIOS_MIN_IO = 0x00001000UL;
+
+	mem_base[0] = txboard_request_phys_region_shrink(&mem_size[0]);
+	io_base[0] = txboard_request_phys_region_shrink(&io_size[0]);
+
+	printk("TX4938 PCIC -- DID:%04x VID:%04x RID:%02x Arbiter:%s\n",
+	       (unsigned short)(tx4938_pcicptr->pciid >> 16),
+	       (unsigned short)(tx4938_pcicptr->pciid & 0xffff),
+	       (unsigned short)(tx4938_pcicptr->pciccrev & 0xff),
+	       extarb ? "External" : "Internal");
+
+	/* setup PCI area */
+	tx4938_pci_controller[0].io_resource->start = io_base[0];
+	tx4938_pci_controller[0].io_resource->end = (io_base[0] + io_size[0]) - 1;
+	tx4938_pci_controller[0].mem_resource->start = mem_base[0];
+	tx4938_pci_controller[0].mem_resource->end = mem_base[0] + mem_size[0] - 1;
+
+	set_tx4938_pcicptr(0, tx4938_pcicptr);
+
+	register_pci_controller(&tx4938_pci_controller[0]);
+
+	if (tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI66) {
+		printk("TX4938_CCFG_PCI66 already configured\n");
+		txboard_pci66_mode = -1; /* already configured */
+	}
+
+	/* Reset PCI Bus */
+	writeb(0, rbtx4938_pcireset_addr);
+	/* Reset PCIC */
+	tx4938_ccfgptr->clkctr |= TX4938_CLKCTR_PCIRST;
+	if (txboard_pci66_mode > 0)
+		tx4938_pciclk66_setup();
+	mdelay(10);
+	/* clear PCIC reset */
+	tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIRST;
+	writeb(1, rbtx4938_pcireset_addr);
+	mmiowb();
+	tx4938_report_pcic_status1(tx4938_pcicptr);
+
+	tx4938_report_pciclk();
+	tx4938_pcic_setup(tx4938_pcicptr, &tx4938_pci_controller[0], io_base[0], extarb);
+	if (txboard_pci66_mode == 0 &&
+	    txboard_pci66_check(&tx4938_pci_controller[0], 0, 0)) {
+		/* Reset PCI Bus */
+		writeb(0, rbtx4938_pcireset_addr);
+		/* Reset PCIC */
+		tx4938_ccfgptr->clkctr |= TX4938_CLKCTR_PCIRST;
+		tx4938_pciclk66_setup();
+		mdelay(10);
+		/* clear PCIC reset */
+		tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIRST;
+		writeb(1, rbtx4938_pcireset_addr);
+		mmiowb();
+		/* Reinitialize PCIC */
+		tx4938_report_pciclk();
+		tx4938_pcic_setup(tx4938_pcicptr, &tx4938_pci_controller[0], io_base[0], extarb);
+	}
+
+	mem_base[1] = txboard_request_phys_region_shrink(&mem_size[1]);
+	io_base[1] = txboard_request_phys_region_shrink(&io_size[1]);
+	/* Reset PCIC1 */
+	tx4938_ccfgptr->clkctr |= TX4938_CLKCTR_PCIC1RST;
+	/* PCI1DMD==0 => PCI1CLK==GBUSCLK/2 => PCI66 */
+	if (!(tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI1DMD))
+		tx4938_ccfgptr->ccfg |= TX4938_CCFG_PCI1_66;
+	else
+		tx4938_ccfgptr->ccfg &= ~TX4938_CCFG_PCI1_66;
+	mdelay(10);
+	/* clear PCIC1 reset */
+	tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIC1RST;
+	tx4938_report_pcic_status1(tx4938_pcic1ptr);
+
+	printk("TX4938 PCIC1 -- DID:%04x VID:%04x RID:%02x",
+	       (unsigned short)(tx4938_pcic1ptr->pciid >> 16),
+	       (unsigned short)(tx4938_pcic1ptr->pciid & 0xffff),
+	       (unsigned short)(tx4938_pcic1ptr->pciccrev & 0xff));
+	printk("%s PCICLK:%dMHz\n",
+	       (tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI1_66) ? " PCI66" : "",
+	       txx9_gbus_clock /
+	       ((tx4938_ccfgptr->ccfg & TX4938_CCFG_PCI1DMD) ? 4 : 2) /
+	       1000000);
+
+	/* assumption: CPHYSADDR(mips_io_port_base) == io_base[0] */
+	tx4938_pci_controller[1].io_resource->start =
+		io_base[1] - io_base[0];
+	tx4938_pci_controller[1].io_resource->end =
+		io_base[1] - io_base[0] + io_size[1] - 1;
+	tx4938_pci_controller[1].mem_resource->start = mem_base[1];
+	tx4938_pci_controller[1].mem_resource->end =
+		mem_base[1] + mem_size[1] - 1;
+	set_tx4938_pcicptr(1, tx4938_pcic1ptr);
+
+	register_pci_controller(&tx4938_pci_controller[1]);
+
+	tx4938_pcic_setup(tx4938_pcic1ptr, &tx4938_pci_controller[1], io_base[1], extarb);
+
+	/* map ioport 0 to PCI I/O space address 0 */
+	set_io_port_base(KSEG1 + io_base[0]);
+
+	return 0;
+}
+
+arch_initcall(tx4938_pcibios_init);
+
+#endif /* CONFIG_PCI */
+
+/* SPI support */
+
+/* chip select for SPI devices */
+#define	SEEPROM1_CS	7	/* PIO7 */
+#define	SEEPROM2_CS	0	/* IOC */
+#define	SEEPROM3_CS	1	/* IOC */
+#define	SRTC_CS	2	/* IOC */
+
+#ifdef CONFIG_PCI
+static int __init rbtx4938_ethaddr_init(void)
+{
+	unsigned char dat[17];
+	unsigned char sum;
+	int i;
+
+	/* 0-3: "MAC\0", 4-9:eth0, 10-15:eth1, 16:sum */
+	if (spi_eeprom_read(SEEPROM1_CS, 0, dat, sizeof(dat))) {
+		printk(KERN_ERR "seeprom: read error.\n");
+		return -ENODEV;
+	} else {
+		if (strcmp(dat, "MAC") != 0)
+			printk(KERN_WARNING "seeprom: bad signature.\n");
+		for (i = 0, sum = 0; i < sizeof(dat); i++)
+			sum += dat[i];
+		if (sum)
+			printk(KERN_WARNING "seeprom: bad checksum.\n");
+	}
+	for (i = 0; i < 2; i++) {
+		unsigned int id =
+			TXX9_IRQ_BASE + (i ? TX4938_IR_ETH1 : TX4938_IR_ETH0);
+		struct platform_device *pdev;
+		if (!(tx4938_ccfgptr->pcfg &
+		      (i ? TX4938_PCFG_ETH1_SEL : TX4938_PCFG_ETH0_SEL)))
+			continue;
+		pdev = platform_device_alloc("tc35815-mac", id);
+		if (!pdev ||
+		    platform_device_add_data(pdev, &dat[4 + 6 * i], 6) ||
+		    platform_device_add(pdev))
+			platform_device_put(pdev);
+	}
+	return 0;
+}
+device_initcall(rbtx4938_ethaddr_init);
+#endif /* CONFIG_PCI */
+
+static void __init rbtx4938_spi_setup(void)
+{
+	/* set SPI_SEL */
+	tx4938_ccfgptr->pcfg |= TX4938_PCFG_SPI_SEL;
+}
+
+static struct resource rbtx4938_fpga_resource;
+
+static char pcode_str[8];
+static struct resource tx4938_reg_resource = {
+	.start	= TX4938_REG_BASE,
+	.end	= TX4938_REG_BASE + TX4938_REG_SIZE,
+	.name	= pcode_str,
+	.flags	= IORESOURCE_MEM
+};
+
+void __init tx4938_board_setup(void)
+{
+	int i;
+	unsigned long divmode;
+	int cpuclk = 0;
+	unsigned long pcode = TX4938_REV_PCODE();
+
+	ioport_resource.start = 0x1000;
+	ioport_resource.end = 0xffffffff;
+	iomem_resource.start = 0x1000;
+	iomem_resource.end = 0xffffffff;	/* expand to 4GB */
+
+	sprintf(pcode_str, "TX%lx", pcode);
+	/* SDRAMC,EBUSC are configured by PROM */
+	for (i = 0; i < 8; i++) {
+		if (!(tx4938_ebuscptr->cr[i] & 0x8))
+			continue;	/* disabled */
+		rbtx4938_ce_base[i] = (unsigned long)TX4938_EBUSC_BA(i);
+		txboard_add_phys_region(rbtx4938_ce_base[i], TX4938_EBUSC_SIZE(i));
+	}
+
+	/* clocks */
+	if (txx9_master_clock) {
+		/* calculate gbus_clock and cpu_clock_freq from master_clock */
+		divmode = (unsigned long)tx4938_ccfgptr->ccfg & TX4938_CCFG_DIVMODE_MASK;
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_8:
+		case TX4938_CCFG_DIVMODE_10:
+		case TX4938_CCFG_DIVMODE_12:
+		case TX4938_CCFG_DIVMODE_16:
+		case TX4938_CCFG_DIVMODE_18:
+			txx9_gbus_clock = txx9_master_clock * 4; break;
+		default:
+			txx9_gbus_clock = txx9_master_clock;
+		}
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_2:
+		case TX4938_CCFG_DIVMODE_8:
+			cpuclk = txx9_gbus_clock * 2; break;
+		case TX4938_CCFG_DIVMODE_2_5:
+		case TX4938_CCFG_DIVMODE_10:
+			cpuclk = txx9_gbus_clock * 5 / 2; break;
+		case TX4938_CCFG_DIVMODE_3:
+		case TX4938_CCFG_DIVMODE_12:
+			cpuclk = txx9_gbus_clock * 3; break;
+		case TX4938_CCFG_DIVMODE_4:
+		case TX4938_CCFG_DIVMODE_16:
+			cpuclk = txx9_gbus_clock * 4; break;
+		case TX4938_CCFG_DIVMODE_4_5:
+		case TX4938_CCFG_DIVMODE_18:
+			cpuclk = txx9_gbus_clock * 9 / 2; break;
+		}
+		txx9_cpu_clock = cpuclk;
+	} else {
+		if (txx9_cpu_clock == 0) {
+			txx9_cpu_clock = 300000000;	/* 300MHz */
+		}
+		/* calculate gbus_clock and master_clock from cpu_clock_freq */
+		cpuclk = txx9_cpu_clock;
+		divmode = (unsigned long)tx4938_ccfgptr->ccfg & TX4938_CCFG_DIVMODE_MASK;
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_2:
+		case TX4938_CCFG_DIVMODE_8:
+			txx9_gbus_clock = cpuclk / 2; break;
+		case TX4938_CCFG_DIVMODE_2_5:
+		case TX4938_CCFG_DIVMODE_10:
+			txx9_gbus_clock = cpuclk * 2 / 5; break;
+		case TX4938_CCFG_DIVMODE_3:
+		case TX4938_CCFG_DIVMODE_12:
+			txx9_gbus_clock = cpuclk / 3; break;
+		case TX4938_CCFG_DIVMODE_4:
+		case TX4938_CCFG_DIVMODE_16:
+			txx9_gbus_clock = cpuclk / 4; break;
+		case TX4938_CCFG_DIVMODE_4_5:
+		case TX4938_CCFG_DIVMODE_18:
+			txx9_gbus_clock = cpuclk * 2 / 9; break;
+		}
+		switch (divmode) {
+		case TX4938_CCFG_DIVMODE_8:
+		case TX4938_CCFG_DIVMODE_10:
+		case TX4938_CCFG_DIVMODE_12:
+		case TX4938_CCFG_DIVMODE_16:
+		case TX4938_CCFG_DIVMODE_18:
+			txx9_master_clock = txx9_gbus_clock / 4; break;
+		default:
+			txx9_master_clock = txx9_gbus_clock;
+		}
+	}
+	/* change default value to udelay/mdelay take reasonable time */
+	loops_per_jiffy = txx9_cpu_clock / HZ / 2;
+
+	/* CCFG */
+	/* clear WatchDogReset,BusErrorOnWrite flag (W1C) */
+	tx4938_ccfgptr->ccfg |= TX4938_CCFG_WDRST | TX4938_CCFG_BEOW;
+	/* do reset on watchdog */
+	tx4938_ccfgptr->ccfg |= TX4938_CCFG_WR;
+	/* clear PCIC1 reset */
+	if (tx4938_ccfgptr->clkctr & TX4938_CLKCTR_PCIC1RST)
+		tx4938_ccfgptr->clkctr &= ~TX4938_CLKCTR_PCIC1RST;
+
+	/* enable Timeout BusError */
+	if (tx4938_ccfg_toeon)
+		tx4938_ccfgptr->ccfg |= TX4938_CCFG_TOE;
+
+	/* DMA selection */
+	tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_DMASEL_ALL;
+
+	/* Use external clock for external arbiter */
+	if (!(tx4938_ccfgptr->ccfg & TX4938_CCFG_PCIXARB))
+		tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_PCICLKEN_ALL;
+
+	printk("%s -- %dMHz(M%dMHz) CRIR:%08lx CCFG:%Lx PCFG:%Lx\n",
+	       pcode_str,
+	       cpuclk / 1000000, txx9_master_clock / 1000000,
+	       (unsigned long)tx4938_ccfgptr->crir,
+	       tx4938_ccfgptr->ccfg,
+	       tx4938_ccfgptr->pcfg);
+
+	printk("%s SDRAMC --", pcode_str);
+	for (i = 0; i < 4; i++) {
+		unsigned long long cr = tx4938_sdramcptr->cr[i];
+		unsigned long ram_base, ram_size;
+		if (!((unsigned long)cr & 0x00000400))
+			continue;	/* disabled */
+		ram_base = (unsigned long)(cr >> 49) << 21;
+		ram_size = ((unsigned long)(cr >> 33) + 1) << 21;
+		if (ram_base >= 0x20000000)
+			continue;	/* high memory (ignore) */
+		printk(" CR%d:%016Lx", i, cr);
+		txboard_add_phys_region(ram_base, ram_size);
+	}
+	printk(" TR:%09Lx\n", tx4938_sdramcptr->tr);
+
+	/* SRAM */
+	if (pcode == 0x4938 && tx4938_sramcptr->cr & 1) {
+		unsigned int size = 0x800;
+		unsigned long base =
+			(tx4938_sramcptr->cr >> (39-11)) & ~(size - 1);
+		 txboard_add_phys_region(base, size);
+	}
+
+	/* TMR */
+	for (i = 0; i < TX4938_NR_TMR; i++)
+		txx9_tmr_init(TX4938_TMR_REG(i) & 0xfffffffffULL);
+
+	/* enable DMA */
+	for (i = 0; i < 2; i++)
+		____raw_writeq(TX4938_DMA_MCR_MSTEN,
+			       (void __iomem *)(TX4938_DMA_REG(i) + 0x50));
+
+	/* PIO */
+	__raw_writel(0, &tx4938_pioptr->maskcpu);
+	__raw_writel(0, &tx4938_pioptr->maskext);
+
+	/* TX4938 internal registers */
+	if (request_resource(&iomem_resource, &tx4938_reg_resource))
+		printk("request resource for internal registers failed\n");
+}
+
+#ifdef CONFIG_PCI
+static inline void tx4938_report_pcic_status1(struct tx4938_pcic_reg *pcicptr)
+{
+	unsigned short pcistatus = (unsigned short)(pcicptr->pcistatus >> 16);
+	unsigned long g2pstatus = pcicptr->g2pstatus;
+	unsigned long pcicstatus = pcicptr->pcicstatus;
+	static struct {
+		unsigned long flag;
+		const char *str;
+	} pcistat_tbl[] = {
+		{ PCI_STATUS_DETECTED_PARITY,	"DetectedParityError" },
+		{ PCI_STATUS_SIG_SYSTEM_ERROR,	"SignaledSystemError" },
+		{ PCI_STATUS_REC_MASTER_ABORT,	"ReceivedMasterAbort" },
+		{ PCI_STATUS_REC_TARGET_ABORT,	"ReceivedTargetAbort" },
+		{ PCI_STATUS_SIG_TARGET_ABORT,	"SignaledTargetAbort" },
+		{ PCI_STATUS_PARITY,	"MasterParityError" },
+	}, g2pstat_tbl[] = {
+		{ TX4938_PCIC_G2PSTATUS_TTOE,	"TIOE" },
+		{ TX4938_PCIC_G2PSTATUS_RTOE,	"RTOE" },
+	}, pcicstat_tbl[] = {
+		{ TX4938_PCIC_PCICSTATUS_PME,	"PME" },
+		{ TX4938_PCIC_PCICSTATUS_TLB,	"TLB" },
+		{ TX4938_PCIC_PCICSTATUS_NIB,	"NIB" },
+		{ TX4938_PCIC_PCICSTATUS_ZIB,	"ZIB" },
+		{ TX4938_PCIC_PCICSTATUS_PERR,	"PERR" },
+		{ TX4938_PCIC_PCICSTATUS_SERR,	"SERR" },
+		{ TX4938_PCIC_PCICSTATUS_GBE,	"GBE" },
+		{ TX4938_PCIC_PCICSTATUS_IWB,	"IWB" },
+	};
+	int i;
+
+	printk("pcistat:%04x(", pcistatus);
+	for (i = 0; i < ARRAY_SIZE(pcistat_tbl); i++)
+		if (pcistatus & pcistat_tbl[i].flag)
+			printk("%s ", pcistat_tbl[i].str);
+	printk("), g2pstatus:%08lx(", g2pstatus);
+	for (i = 0; i < ARRAY_SIZE(g2pstat_tbl); i++)
+		if (g2pstatus & g2pstat_tbl[i].flag)
+			printk("%s ", g2pstat_tbl[i].str);
+	printk("), pcicstatus:%08lx(", pcicstatus);
+	for (i = 0; i < ARRAY_SIZE(pcicstat_tbl); i++)
+		if (pcicstatus & pcicstat_tbl[i].flag)
+			printk("%s ", pcicstat_tbl[i].str);
+	printk(")\n");
+}
+
+void tx4938_report_pcic_status(void)
+{
+	int i;
+	struct tx4938_pcic_reg *pcicptr;
+	for (i = 0; (pcicptr = get_tx4938_pcicptr(i)) != NULL; i++)
+		tx4938_report_pcic_status1(pcicptr);
+}
+
+#endif /* CONFIG_PCI */
+
+void __init plat_time_init(void)
+{
+	mips_hpt_frequency = txx9_cpu_clock / 2;
+	if (tx4938_ccfgptr->ccfg & TX4938_CCFG_TINTDIS)
+		txx9_clockevent_init(TX4938_TMR_REG(0) & 0xfffffffffULL,
+				     TXX9_IRQ_BASE + TX4938_IR_TMR(0),
+				     txx9_gbus_clock / 2);
+}
+
+void __init plat_mem_setup(void)
+{
+	unsigned long long pcfg;
+	char *argptr;
+
+	iomem_resource.end = 0xffffffff;	/* 4GB */
+
+	if (txx9_master_clock == 0)
+		txx9_master_clock = 25000000; /* 25MHz */
+	tx4938_board_setup();
+#ifndef CONFIG_PCI
+	set_io_port_base(RBTX4938_ETHER_BASE);
+#endif
+
+#ifdef CONFIG_SERIAL_TXX9
+	{
+		extern int early_serial_txx9_setup(struct uart_port *port);
+		int i;
+		struct uart_port req;
+		for(i = 0; i < 2; i++) {
+			memset(&req, 0, sizeof(req));
+			req.line = i;
+			req.iotype = UPIO_MEM;
+			req.membase = (char *)(0xff1ff300 + i * 0x100);
+			req.mapbase = 0xff1ff300 + i * 0x100;
+			req.irq = RBTX4938_IRQ_IRC_SIO(i);
+			req.flags |= UPF_BUGGY_UART /*HAVE_CTS_LINE*/;
+			req.uartclk = 50000000;
+			early_serial_txx9_setup(&req);
+		}
+	}
+#ifdef CONFIG_SERIAL_TXX9_CONSOLE
+        argptr = prom_getcmdline();
+        if (strstr(argptr, "console=") == NULL) {
+                strcat(argptr, " console=ttyS0,38400");
+        }
+#endif
+#endif
+
+#ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_PIO58_61
+	printk("PIOSEL: disabling both ata and nand selection\n");
+	local_irq_disable();
+	tx4938_ccfgptr->pcfg &= ~(TX4938_PCFG_NDF_SEL | TX4938_PCFG_ATA_SEL);
+#endif
+
+#ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_NAND
+	printk("PIOSEL: enabling nand selection\n");
+	tx4938_ccfgptr->pcfg |= TX4938_PCFG_NDF_SEL;
+	tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_ATA_SEL;
+#endif
+
+#ifdef CONFIG_TOSHIBA_RBTX4938_MPLEX_ATA
+	printk("PIOSEL: enabling ata selection\n");
+	tx4938_ccfgptr->pcfg |= TX4938_PCFG_ATA_SEL;
+	tx4938_ccfgptr->pcfg &= ~TX4938_PCFG_NDF_SEL;
+#endif
+
+#ifdef CONFIG_IP_PNP
+	argptr = prom_getcmdline();
+	if (strstr(argptr, "ip=") == NULL) {
+		strcat(argptr, " ip=any");
+	}
+#endif
+
+
+#ifdef CONFIG_FB
+	{
+		conswitchp = &dummy_con;
+	}
+#endif
+
+	rbtx4938_spi_setup();
+	pcfg = tx4938_ccfgptr->pcfg;	/* updated */
+	/* fixup piosel */
+	if ((pcfg & (TX4938_PCFG_ATA_SEL | TX4938_PCFG_NDF_SEL)) ==
+	    TX4938_PCFG_ATA_SEL)
+		writeb((readb(rbtx4938_piosel_addr) & 0x03) | 0x04,
+		       rbtx4938_piosel_addr);
+	else if ((pcfg & (TX4938_PCFG_ATA_SEL | TX4938_PCFG_NDF_SEL)) ==
+		 TX4938_PCFG_NDF_SEL)
+		writeb((readb(rbtx4938_piosel_addr) & 0x03) | 0x08,
+		       rbtx4938_piosel_addr);
+	else
+		writeb(readb(rbtx4938_piosel_addr) & ~(0x08 | 0x04),
+		       rbtx4938_piosel_addr);
+
+	rbtx4938_fpga_resource.name = "FPGA Registers";
+	rbtx4938_fpga_resource.start = CPHYSADDR(RBTX4938_FPGA_REG_ADDR);
+	rbtx4938_fpga_resource.end = CPHYSADDR(RBTX4938_FPGA_REG_ADDR) + 0xffff;
+	rbtx4938_fpga_resource.flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+	if (request_resource(&iomem_resource, &rbtx4938_fpga_resource))
+		printk("request resource for fpga failed\n");
+
+	_machine_restart = rbtx4938_machine_restart;
+	_machine_halt = rbtx4938_machine_halt;
+	pm_power_off = rbtx4938_machine_power_off;
+
+	writeb(0xff, rbtx4938_led_addr);
+	printk(KERN_INFO "RBTX4938 --- FPGA(Rev %02x) DIPSW:%02x,%02x\n",
+	       readb(rbtx4938_fpga_rev_addr),
+	       readb(rbtx4938_dipsw_addr), readb(rbtx4938_bdipsw_addr));
+}
+
+static int __init rbtx4938_ne_init(void)
+{
+	struct resource res[] = {
+		{
+			.start	= RBTX4938_RTL_8019_BASE,
+			.end	= RBTX4938_RTL_8019_BASE + 0x20 - 1,
+			.flags	= IORESOURCE_IO,
+		}, {
+			.start	= RBTX4938_RTL_8019_IRQ,
+			.flags	= IORESOURCE_IRQ,
+		}
+	};
+	struct platform_device *dev =
+		platform_device_register_simple("ne", -1,
+						res, ARRAY_SIZE(res));
+	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
+}
+device_initcall(rbtx4938_ne_init);
+
+/* GPIO support */
+
+int gpio_to_irq(unsigned gpio)
+{
+	return -EINVAL;
+}
+
+int irq_to_gpio(unsigned irq)
+{
+	return -EINVAL;
+}
+
+static DEFINE_SPINLOCK(rbtx4938_spi_gpio_lock);
+
+static void rbtx4938_spi_gpio_set(struct gpio_chip *chip, unsigned int offset,
+				  int value)
+{
+	u8 val;
+	unsigned long flags;
+	spin_lock_irqsave(&rbtx4938_spi_gpio_lock, flags);
+	val = readb(rbtx4938_spics_addr);
+	if (value)
+		val |= 1 << offset;
+	else
+		val &= ~(1 << offset);
+	writeb(val, rbtx4938_spics_addr);
+	mmiowb();
+	spin_unlock_irqrestore(&rbtx4938_spi_gpio_lock, flags);
+}
+
+static int rbtx4938_spi_gpio_dir_out(struct gpio_chip *chip,
+				     unsigned int offset, int value)
+{
+	rbtx4938_spi_gpio_set(chip, offset, value);
+	return 0;
+}
+
+static struct gpio_chip rbtx4938_spi_gpio_chip = {
+	.set = rbtx4938_spi_gpio_set,
+	.direction_output = rbtx4938_spi_gpio_dir_out,
+	.label = "RBTX4938-SPICS",
+	.base = 16,
+	.ngpio = 3,
+};
+
+/* SPI support */
+
+static void __init txx9_spi_init(unsigned long base, int irq)
+{
+	struct resource res[] = {
+		{
+			.start	= base,
+			.end	= base + 0x20 - 1,
+			.flags	= IORESOURCE_MEM,
+		}, {
+			.start	= irq,
+			.flags	= IORESOURCE_IRQ,
+		},
+	};
+	platform_device_register_simple("spi_txx9", 0,
+					res, ARRAY_SIZE(res));
+}
+
+static int __init rbtx4938_spi_init(void)
+{
+	struct spi_board_info srtc_info = {
+		.modalias = "rtc-rs5c348",
+		.max_speed_hz = 1000000, /* 1.0Mbps @ Vdd 2.0V */
+		.bus_num = 0,
+		.chip_select = 16 + SRTC_CS,
+		/* Mode 1 (High-Active, Shift-Then-Sample), High Avtive CS  */
+		.mode = SPI_MODE_1 | SPI_CS_HIGH,
+	};
+	spi_register_board_info(&srtc_info, 1);
+	spi_eeprom_register(SEEPROM1_CS);
+	spi_eeprom_register(16 + SEEPROM2_CS);
+	spi_eeprom_register(16 + SEEPROM3_CS);
+	gpio_request(16 + SRTC_CS, "rtc-rs5c348");
+	gpio_direction_output(16 + SRTC_CS, 0);
+	gpio_request(SEEPROM1_CS, "seeprom1");
+	gpio_direction_output(SEEPROM1_CS, 1);
+	gpio_request(16 + SEEPROM2_CS, "seeprom2");
+	gpio_direction_output(16 + SEEPROM2_CS, 1);
+	gpio_request(16 + SEEPROM3_CS, "seeprom3");
+	gpio_direction_output(16 + SEEPROM3_CS, 1);
+	txx9_spi_init(TX4938_SPI_REG & 0xfffffffffULL, RBTX4938_IRQ_IRC_SPI);
+	return 0;
+}
+
+static int __init rbtx4938_arch_init(void)
+{
+	txx9_gpio_init(TX4938_PIO_REG & 0xfffffffffULL, 0, 16);
+	gpiochip_add(&rbtx4938_spi_gpio_chip);
+	return rbtx4938_spi_init();
+}
+arch_initcall(rbtx4938_arch_init);
+
+/* Watchdog support */
+
+static int __init txx9_wdt_init(unsigned long base)
+{
+	struct resource res = {
+		.start	= base,
+		.end	= base + 0x100 - 1,
+		.flags	= IORESOURCE_MEM,
+	};
+	struct platform_device *dev =
+		platform_device_register_simple("txx9wdt", -1, &res, 1);
+	return IS_ERR(dev) ? PTR_ERR(dev) : 0;
+}
+
+static int __init rbtx4938_wdt_init(void)
+{
+	return txx9_wdt_init(TX4938_TMR_REG(2) & 0xfffffffffULL);
+}
+device_initcall(rbtx4938_wdt_init);
+
+/* Minimum CLK support */
+
+struct clk *clk_get(struct device *dev, const char *id)
+{
+	if (!strcmp(id, "spi-baseclk"))
+		return (struct clk *)(txx9_gbus_clock / 2 / 4);
+	if (!strcmp(id, "imbus_clk"))
+		return (struct clk *)(txx9_gbus_clock / 2);
+	return ERR_PTR(-ENOENT);
+}
+EXPORT_SYMBOL(clk_get);
+
+int clk_enable(struct clk *clk)
+{
+	return 0;
+}
+EXPORT_SYMBOL(clk_enable);
+
+void clk_disable(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_disable);
+
+unsigned long clk_get_rate(struct clk *clk)
+{
+	return (unsigned long)clk;
+}
+EXPORT_SYMBOL(clk_get_rate);
+
+void clk_put(struct clk *clk)
+{
+}
+EXPORT_SYMBOL(clk_put);
