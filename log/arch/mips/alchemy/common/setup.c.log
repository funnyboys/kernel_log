commit 7a6659a59198acb5e9be050f42dbb1060efe7434
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Mon Apr 20 13:28:54 2020 +0200

    MIPS: alchemy: Fix build error after ioremap cleanup
    
    IOremap changes caused following build error:
    
    arch/mips/alchemy/common/setup.c:99:9: error: implicit declaration of function
    +‘remap_pfn_range’; did you mean ‘io_remap_pfn_range’?
    +[-Werror=implicit-function-declaration]
    
    Fixed my including linux/mm.h
    
    Fixes: d399157283fb ("MIPS: cleanup fixup_bigphys_addr handling")
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index a8cbc552bd64..0f60efe0481e 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -27,6 +27,7 @@
 
 #include <linux/init.h>
 #include <linux/ioport.h>
+#include <linux/mm.h>
 
 #include <asm/dma-coherence.h>
 #include <asm/mipsregs.h>

commit d399157283fb457cdc3ae03f2897070f0bd5d7c6
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Apr 16 17:00:07 2020 +0200

    MIPS: cleanup fixup_bigphys_addr handling
    
    fixup_bigphys_addr is only provided by the alchemy platform.  Remove
    all the stubs, and ensure we only call it if it is actually implemented.
    
    Also don't bother implementing io_remap_pfn_range if we don't have to,
    and move the remaining implementation to alchemy platform code.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 7faaa6d593a7..a8cbc552bd64 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -72,9 +72,9 @@ void __init plat_mem_setup(void)
 	iomem_resource.end = IOMEM_RESOURCE_END;
 }
 
-#if defined(CONFIG_PHYS_ADDR_T_64BIT) && defined(CONFIG_PCI)
+#ifdef CONFIG_MIPS_FIXUP_BIGPHYS_ADDR
 /* This routine should be valid for all Au1x based boards */
-phys_addr_t __fixup_bigphys_addr(phys_addr_t phys_addr, phys_addr_t size)
+phys_addr_t fixup_bigphys_addr(phys_addr_t phys_addr, phys_addr_t size)
 {
 	unsigned long start = ALCHEMY_PCI_MEMWIN_START;
 	unsigned long end = ALCHEMY_PCI_MEMWIN_END;
@@ -90,5 +90,13 @@ phys_addr_t __fixup_bigphys_addr(phys_addr_t phys_addr, phys_addr_t size)
 	/* default nop */
 	return phys_addr;
 }
-EXPORT_SYMBOL(__fixup_bigphys_addr);
-#endif
+
+int io_remap_pfn_range(struct vm_area_struct *vma, unsigned long vaddr,
+		unsigned long pfn, unsigned long size, pgprot_t prot)
+{
+	phys_addr_t phys_addr = fixup_bigphys_addr(pfn << PAGE_SHIFT, size);
+
+	return remap_pfn_range(vma, vaddr, phys_addr >> PAGE_SHIFT, size, prot);
+}
+EXPORT_SYMBOL(io_remap_pfn_range);
+#endif /* CONFIG_MIPS_FIXUP_BIGPHYS_ADDR */

commit f23020230e682a43cc4706cabb041bba469df2d6
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Wed Oct 5 18:18:14 2016 +0100

    MIPS: Sanitise coherentio semantics
    
    The coherentio variable has previously been used as a boolean value,
    indicating whether the user specified that coherent I/O should be
    enabled or disabled. It failed to take into account the case where the
    user does not specify any preference, in which case it makes sense that
    we should default to coherent I/O if the hardware supports it
    (hw_coherentio is non-zero).
    
    Introduce an enum to clarify the 3 different values of coherentio & use
    it throughout the code, modifying plat_device_is_coherent() &
    r4k_cache_init() to take into account the default case.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Paul Burton <paul.burton@imgtec.com>
    Patchwork: https://patchwork.linux-mips.org/patch/14347/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 2902138b3e0f..7faaa6d593a7 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -48,17 +48,17 @@ void __init plat_mem_setup(void)
 		clear_c0_config(1 << 19); /* Clear Config[OD] */
 
 	hw_coherentio = 0;
-	coherentio = 1;
+	coherentio = IO_COHERENCE_ENABLED;
 	switch (alchemy_get_cputype()) {
 	case ALCHEMY_CPU_AU1000:
 	case ALCHEMY_CPU_AU1500:
 	case ALCHEMY_CPU_AU1100:
-		coherentio = 0;
+		coherentio = IO_COHERENCE_DISABLED;
 		break;
 	case ALCHEMY_CPU_AU1200:
 		/* Au1200 AB USB does not support coherent memory */
 		if (0 == (read_c0_prid() & PRID_REV_MASK))
-			coherentio = 0;
+			coherentio = IO_COHERENCE_DISABLED;
 		break;
 	}
 

commit 200276e6730c2817a77cfa6fc7e39ab3a63c4646
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Thu Jan 29 16:06:44 2015 +0100

    MIPS: Alchemy: remove declaration for set_cpuspec
    
    set_cpuspec() has been dropped with commit 074cf656700ddd1d2bd7f815f78e785418beb898
    ("MIPS: Alchemy: remove cpu_table.") in late 2008.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/9150/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 9a0c4c8da106..2902138b3e0f 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -34,7 +34,6 @@
 #include <au1000.h>
 
 extern void __init board_setup(void);
-extern void set_cpuspec(void);
 extern void __init alchemy_set_lpj(void);
 
 void __init plat_mem_setup(void)

commit 45a848f7fa067a81ae606bb06b2edcdf53772eac
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Thu Jan 29 16:06:43 2015 +0100

    MIPS: Alchemy: preset loops_per_jiffy based on CPU clock
    
    This was lost during the rewrite of clock framework support.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/9149/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 4e72daf12c32..9a0c4c8da106 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -35,9 +35,12 @@
 
 extern void __init board_setup(void);
 extern void set_cpuspec(void);
+extern void __init alchemy_set_lpj(void);
 
 void __init plat_mem_setup(void)
 {
+	alchemy_set_lpj();
+
 	if (au1xxx_cpu_needs_config_od())
 		/* Various early Au1xx0 errata corrected by this */
 		set_c0_config(1 << 19); /* Set Config[OD] */

commit 15d45cce3a0e0716fa49c768f887c6406dfb91f7
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Nov 22 00:22:09 2014 +0100

    MIPS: Replace use of phys_t with phys_addr_t.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index a97707e1b4ab..4e72daf12c32 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -72,7 +72,7 @@ void __init plat_mem_setup(void)
 
 #if defined(CONFIG_PHYS_ADDR_T_64BIT) && defined(CONFIG_PCI)
 /* This routine should be valid for all Au1x based boards */
-phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
+phys_addr_t __fixup_bigphys_addr(phys_addr_t phys_addr, phys_addr_t size)
 {
 	unsigned long start = ALCHEMY_PCI_MEMWIN_START;
 	unsigned long end = ALCHEMY_PCI_MEMWIN_END;
@@ -83,7 +83,7 @@ phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
 
 	/* Check for PCI memory window */
 	if (phys_addr >= start && (phys_addr + size - 1) <= end)
-		return (phys_t)(AU1500_PCI_MEM_PHYS_ADDR + phys_addr);
+		return (phys_addr_t)(AU1500_PCI_MEM_PHYS_ADDR + phys_addr);
 
 	/* default nop */
 	return phys_addr;

commit 34adb28d500e644cc260da4ceb66ba6dc0beaf93
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Nov 22 00:16:48 2014 +0100

    MIPS: Replace MIPS-specific 64BIT_PHYS_ADDR with generic PHYS_ADDR_T_64BIT
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index ea8f41869e56..a97707e1b4ab 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -70,7 +70,7 @@ void __init plat_mem_setup(void)
 	iomem_resource.end = IOMEM_RESOURCE_END;
 }
 
-#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_PCI)
+#if defined(CONFIG_PHYS_ADDR_T_64BIT) && defined(CONFIG_PCI)
 /* This routine should be valid for all Au1x based boards */
 phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
 {

commit 72e1e2a30f67fc19a958be6c1818e7e6cb1573fe
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Wed Jul 23 16:36:57 2014 +0200

    MIPS: Alchemy: remove old clock support
    
    With the clock framework in place, remove unused functions and bits,
    and drop the CLK_IGNORE_UNUSED flag, which is now unneeded.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7473/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 8267e3c97721..ea8f41869e56 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -27,12 +27,9 @@
 
 #include <linux/init.h>
 #include <linux/ioport.h>
-#include <linux/jiffies.h>
-#include <linux/module.h>
 
 #include <asm/dma-coherence.h>
 #include <asm/mipsregs.h>
-#include <asm/time.h>
 
 #include <au1000.h>
 
@@ -41,18 +38,6 @@ extern void set_cpuspec(void);
 
 void __init plat_mem_setup(void)
 {
-	unsigned long est_freq;
-
-	/* determine core clock */
-	est_freq = au1xxx_calc_clock();
-	est_freq += 5000;    /* round */
-	est_freq -= est_freq % 10000;
-	printk(KERN_INFO "(PRId %08x) @ %lu.%02lu MHz\n", read_c0_prid(),
-	       est_freq / 1000000, ((est_freq % 1000000) * 100) / 1000000);
-
-	/* this is faster than wasting cycles trying to approximate it */
-	preset_lpj = (est_freq >> 1) / HZ;
-
 	if (au1xxx_cpu_needs_config_od())
 		/* Various early Au1xx0 errata corrected by this */
 		set_c0_config(1 << 19); /* Set Config[OD] */

commit 739cec8f187f1ea920b8821ef4ae733bc097085c
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Thu Apr 10 22:57:59 2014 +0200

    MIPS: Alchemy: Default to noncoherent IO on Au1200 AB
    
    CONFIG_DMA_COHERENT is no longer set; default to noncoherent io on
    Au1200 revision AB to make USB work.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/6745/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 566a1743f685..8267e3c97721 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -67,6 +67,12 @@ void __init plat_mem_setup(void)
 	case ALCHEMY_CPU_AU1500:
 	case ALCHEMY_CPU_AU1100:
 		coherentio = 0;
+		break;
+	case ALCHEMY_CPU_AU1200:
+		/* Au1200 AB USB does not support coherent memory */
+		if (0 == (read_c0_prid() & PRID_REV_MASK))
+			coherentio = 0;
+		break;
 	}
 
 	board_setup();	/* board specific setup */

commit 88e9a93c9d53ddcf633aa07f14245da7f30408c2
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Thu Feb 20 14:59:23 2014 +0100

    MIPS: Alchemy: Determine cohereny at runtime based on cpu type
    
    All Alchemy chips have coherent DMA, but for example the USB or AC97
    peripherals on the Au1000/1500/1100 are not.
    This patch uses DMA_MAYBE_COHERENT on Alchemy and sets coherentio based
    on CPU type.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/6576/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 62b4e7bbeab9..566a1743f685 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -30,6 +30,7 @@
 #include <linux/jiffies.h>
 #include <linux/module.h>
 
+#include <asm/dma-coherence.h>
 #include <asm/mipsregs.h>
 #include <asm/time.h>
 
@@ -59,6 +60,15 @@ void __init plat_mem_setup(void)
 		/* Clear to obtain best system bus performance */
 		clear_c0_config(1 << 19); /* Clear Config[OD] */
 
+	hw_coherentio = 0;
+	coherentio = 1;
+	switch (alchemy_get_cputype()) {
+	case ALCHEMY_CPU_AU1000:
+	case ALCHEMY_CPU_AU1500:
+	case ALCHEMY_CPU_AU1100:
+		coherentio = 0;
+	}
+
 	board_setup();	/* board specific setup */
 
 	/* IO/MEM resources. */

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 37ffd997c616..62b4e7bbeab9 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -59,7 +59,7 @@ void __init plat_mem_setup(void)
 		/* Clear to obtain best system bus performance */
 		clear_c0_config(1 << 19); /* Clear Config[OD] */
 
-	board_setup();  /* board specific setup */
+	board_setup();	/* board specific setup */
 
 	/* IO/MEM resources. */
 	set_io_port_base(0);

commit 7517de348663b08a808aff44b5300e817157a568
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Fri Aug 12 11:39:44 2011 +0200

    MIPS: Alchemy: Redo PCI as platform driver
    
    - Rewrite Alchemy PCI support as a platform driver.
    - Fixup boards which have PCI.
    
    Run-tested on DB1500 and DB1550.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/2706/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
     delete mode 100644 arch/mips/alchemy/common/pci.c
     delete mode 100644 arch/mips/pci/fixup-au1000.c
     delete mode 100644 arch/mips/pci/ops-au1000.c
     create mode 100644 arch/mips/pci/pci-alchemy.c

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 1b887c868417..37ffd997c616 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -73,8 +73,8 @@ void __init plat_mem_setup(void)
 /* This routine should be valid for all Au1x based boards */
 phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
 {
-	u32 start = (u32)Au1500_PCI_MEM_START;
-	u32 end   = (u32)Au1500_PCI_MEM_END;
+	unsigned long start = ALCHEMY_PCI_MEMWIN_START;
+	unsigned long end = ALCHEMY_PCI_MEMWIN_END;
 
 	/* Don't fixup 36-bit addresses */
 	if ((phys_addr >> 32) != 0)
@@ -82,7 +82,7 @@ phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
 
 	/* Check for PCI memory window */
 	if (phys_addr >= start && (phys_addr + size - 1) <= end)
-		return (phys_t)((phys_addr - start) + Au1500_PCI_MEM_START);
+		return (phys_t)(AU1500_PCI_MEM_PHYS_ADDR + phys_addr);
 
 	/* default nop */
 	return phys_addr;

commit 0591128066bdfe07e0ef0ab7f877f794d8ba071d
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sun May 8 10:42:12 2011 +0200

    MIPS: DB1200: Set Config[OD] for improved stability.
    
    Setting Config[OD] gets rid of a _LOT_ of spurious CPLD interrupts,
    but also decreases overall performance a bit.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@googlemail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Patchwork: https://patchwork.linux-mips.org/patch/2347/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 561e5da2658b..1b887c868417 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -52,8 +52,6 @@ void __init plat_mem_setup(void)
 	/* this is faster than wasting cycles trying to approximate it */
 	preset_lpj = (est_freq >> 1) / HZ;
 
-	board_setup();  /* board specific setup */
-
 	if (au1xxx_cpu_needs_config_od())
 		/* Various early Au1xx0 errata corrected by this */
 		set_c0_config(1 << 19); /* Set Config[OD] */
@@ -61,6 +59,8 @@ void __init plat_mem_setup(void)
 		/* Clear to obtain best system bus performance */
 		clear_c0_config(1 << 19); /* Clear Config[OD] */
 
+	board_setup();  /* board specific setup */
+
 	/* IO/MEM resources. */
 	set_io_port_base(0);
 	ioport_resource.start = IOPORT_RESOURCE_START;

commit 11b897cf84c37e6522db914793677e933ef311fb
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Wed Feb 24 17:40:21 2010 +0100

    MIPS: Alchemy: use 36bit addresses for PCMCIA resources.
    
    On Alchemy the PCMCIA area lies at the end of the chips 36bit system bus
    area.  Currently, addresses at the far end of the 32bit area are assumed
    to belong to the PCMCIA area and fixed up to the real 36bit address before
    being passed to ioremap().
    
    A previous commit enabled 64 bit physical size for the resource datatype on
    Alchemy and this allows to use the correct 36bit addresses when registering
    the PCMCIA sockets.
    
    This patch removes the 32-to-36bit address fixup and registers the Alchemy
    demo board pcmcia socket with the correct 36bit physical addresses.
    
    Tested on DB1200, with a CF card (ide-cs driver) and a 3c589 PCMCIA ethernet
    card.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    To: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Manuel Lauss <manuel.lauss@gmail.com>
    Patchwork: http://patchwork.linux-mips.org/patch/994/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 193ba166affd..561e5da2658b 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -69,38 +69,20 @@ void __init plat_mem_setup(void)
 	iomem_resource.end = IOMEM_RESOURCE_END;
 }
 
-#if defined(CONFIG_64BIT_PHYS_ADDR)
+#if defined(CONFIG_64BIT_PHYS_ADDR) && defined(CONFIG_PCI)
 /* This routine should be valid for all Au1x based boards */
 phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
 {
+	u32 start = (u32)Au1500_PCI_MEM_START;
+	u32 end   = (u32)Au1500_PCI_MEM_END;
+
 	/* Don't fixup 36-bit addresses */
 	if ((phys_addr >> 32) != 0)
 		return phys_addr;
 
-#ifdef CONFIG_PCI
-	{
-		u32 start = (u32)Au1500_PCI_MEM_START;
-		u32 end   = (u32)Au1500_PCI_MEM_END;
-
-		/* Check for PCI memory window */
-		if (phys_addr >= start && (phys_addr + size - 1) <= end)
-			return (phys_t)
-			       ((phys_addr - start) + Au1500_PCI_MEM_START);
-	}
-#endif
-
-	/*
-	 * All Au1xx0 SOCs have a PCMCIA controller.
-	 * We setup our 32-bit pseudo addresses to be equal to the
-	 * 36-bit addr >> 4, to make it easier to check the address
-	 * and fix it.
-	 * The PCMCIA socket 0 physical attribute address is 0xF 4000 0000.
-	 * The pseudo address we use is 0xF400 0000. Any address over
-	 * 0xF400 0000 is a PCMCIA pseudo address.
-	 */
-	if ((phys_addr >= PCMCIA_ATTR_PSEUDO_PHYS) &&
-	    (phys_addr < PCMCIA_PSEUDO_END))
-		return (phys_t)(phys_addr << 4);
+	/* Check for PCI memory window */
+	if (phys_addr >= start && (phys_addr + size - 1) <= end)
+		return (phys_t)((phys_addr - start) + Au1500_PCI_MEM_START);
 
 	/* default nop */
 	return phys_addr;

commit 32fd6901a6d8d19f94e4de6be4e4b552ab078620
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Tue Dec 8 19:18:13 2009 +0100

    MIPS: Alchemy: get rid of common/reset.c
    
    Implement reset / poweroff in the board code instead.  The peripheral reset
    code is gone too since YAMON which all in-tree boards use does the same
    work when it boots.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Yoichi Yuasa <yuasa@linux-mips.org>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Patchwork: http://patchwork.linux-mips.org/patch/783/
    Patchwork: http://patchwork.linux-mips.org/patch/882/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 375984e5c2e6..193ba166affd 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -29,18 +29,13 @@
 #include <linux/ioport.h>
 #include <linux/jiffies.h>
 #include <linux/module.h>
-#include <linux/pm.h>
 
 #include <asm/mipsregs.h>
-#include <asm/reboot.h>
 #include <asm/time.h>
 
 #include <au1000.h>
 
 extern void __init board_setup(void);
-extern void au1000_restart(char *);
-extern void au1000_halt(void);
-extern void au1000_power_off(void);
 extern void set_cpuspec(void);
 
 void __init plat_mem_setup(void)
@@ -57,10 +52,6 @@ void __init plat_mem_setup(void)
 	/* this is faster than wasting cycles trying to approximate it */
 	preset_lpj = (est_freq >> 1) / HZ;
 
-	_machine_restart = au1000_restart;
-	_machine_halt = au1000_halt;
-	pm_power_off = au1000_power_off;
-
 	board_setup();  /* board specific setup */
 
 	if (au1xxx_cpu_needs_config_od())

commit 66213b3ccfc770704025ce9465fa3aaedde21b55
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Sun Oct 4 14:55:27 2009 +0200

    MIPS: PCMCIA: new socket driver for Au1000 demoboards.
    
    New PCMCIA socket driver for all Db/Pb1xxx boards (except Pb1000),
    which replaces au1000_db1x00.c and (most of) au1000_pb1x00.c.
    Notable improvements:
            - supports Db1000, DB/PB1100/1500/1550/1200.
            - support for carddetect and statuschange IRQs.
            - pcmcia socket mem/io/attr areas and irqs passed through
              platform resource information.
            - doesn't freeze system during card insertion/ejection like
              the one it replaces.
            - boardtype is automatically detected using BCSR ID register.
    
    Run-tested on the DB1200.
    
    Cc: Linux-PCMCIA <linux-pcmcia@lists.infradead.org>
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 6184baa56786..375984e5c2e6 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -107,7 +107,8 @@ phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
 	 * The pseudo address we use is 0xF400 0000. Any address over
 	 * 0xF400 0000 is a PCMCIA pseudo address.
 	 */
-	if ((phys_addr >= 0xF4000000) && (phys_addr < 0xFFFFFFFF))
+	if ((phys_addr >= PCMCIA_ATTR_PSEUDO_PHYS) &&
+	    (phys_addr < PCMCIA_PSEUDO_END))
 		return (phys_t)(phys_addr << 4);
 
 	/* default nop */

commit a7bcb1ae6094db78b077ae17e92c69de7643014f
Author: Manuel Lauss <manuel.lauss@googlemail.com>
Date:   Thu Aug 27 19:21:18 2009 +0200

    MIPS: Alchemy: override loops_per_jiffy detection
    
    loops_per_jiffy depends on coreclk speed;  preset it instead of
    letting the kernel waste precious microseconds trying to approximate it.
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 3f036b3d400e..6184baa56786 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -27,6 +27,7 @@
 
 #include <linux/init.h>
 #include <linux/ioport.h>
+#include <linux/jiffies.h>
 #include <linux/module.h>
 #include <linux/pm.h>
 
@@ -53,6 +54,9 @@ void __init plat_mem_setup(void)
 	printk(KERN_INFO "(PRId %08x) @ %lu.%02lu MHz\n", read_c0_prid(),
 	       est_freq / 1000000, ((est_freq % 1000000) * 100) / 1000000);
 
+	/* this is faster than wasting cycles trying to approximate it */
+	preset_lpj = (est_freq >> 1) / HZ;
+
 	_machine_restart = au1000_restart;
 	_machine_halt = au1000_halt;
 	pm_power_off = au1000_power_off;

commit 2699cdfb765c3b7d77d28ea3bc7d84e486697177
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Sun Dec 21 09:26:24 2008 +0100

    MIPS: Alchemy: move calc_clock function.
    
    Now that nothing in time.c depends on calc_clock, it can
    be moved to clocks.c where it belongs.
    While at it, give it a better non-generic name and call it
    as soon as possible in plat_mem_init.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 8ad453af2c64..3f036b3d400e 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -44,6 +44,15 @@ extern void set_cpuspec(void);
 
 void __init plat_mem_setup(void)
 {
+	unsigned long est_freq;
+
+	/* determine core clock */
+	est_freq = au1xxx_calc_clock();
+	est_freq += 5000;    /* round */
+	est_freq -= est_freq % 10000;
+	printk(KERN_INFO "(PRId %08x) @ %lu.%02lu MHz\n", read_c0_prid(),
+	       est_freq / 1000000, ((est_freq % 1000000) * 100) / 1000000);
+
 	_machine_restart = au1000_restart;
 	_machine_halt = au1000_halt;
 	pm_power_off = au1000_power_off;

commit 0c694de12b54fa96b9555e07603f567906ce21c8
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Sun Dec 21 09:26:23 2008 +0100

    MIPS: Alchemy: RTC counter clocksource / clockevent support.
    
    Add support for the 32 kHz counter1 (RTC) as clocksource / clockevent
    device.  As a nice side effect, this also enables use of the 'wait'
    instruction for runtime idle power savings.
    
    If the counters aren't enabled/working properly, fall back on the
    cp0 counter clock code.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 4d42be811e7f..8ad453af2c64 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -63,12 +63,6 @@ void __init plat_mem_setup(void)
 	ioport_resource.end = IOPORT_RESOURCE_END;
 	iomem_resource.start = IOMEM_RESOURCE_START;
 	iomem_resource.end = IOMEM_RESOURCE_END;
-
-	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_E0S);
-	au_writel(SYS_CNTRL_E0 | SYS_CNTRL_EN0, SYS_COUNTER_CNTRL);
-	au_sync();
-	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_T0S);
-	au_writel(0, SYS_TOYTRIM);
 }
 
 #if defined(CONFIG_64BIT_PHYS_ADDR)

commit 074cf656700ddd1d2bd7f815f78e785418beb898
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Sun Dec 21 09:26:21 2008 +0100

    MIPS: Alchemy: remove cpu_table.
    
    Remove the cpu_table:
    - move detection of whether c0_config[OD] is read-only and should be set
      to fix various chip errata to au1000 headers.
    - move detection of write-only sys_cpupll to au1000 headers.
    - remove the BCLK switching code:  Activation of this features should be
      left to the boards using the chips since it also affects external devices
      tied to BCLK, and only the board designers know whether it is safe to
      enable.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
     delete mode 100644 arch/mips/alchemy/common/cputable.c

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 9889ec3ba4c4..4d42be811e7f 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -44,37 +44,13 @@ extern void set_cpuspec(void);
 
 void __init plat_mem_setup(void)
 {
-	struct	cpu_spec *sp;
-	unsigned long prid, cpufreq, bclk;
-
-	set_cpuspec();
-	sp = cur_cpu_spec[0];
-
 	_machine_restart = au1000_restart;
 	_machine_halt = au1000_halt;
 	pm_power_off = au1000_power_off;
 
 	board_setup();  /* board specific setup */
 
-	prid = read_c0_prid();
-	if (sp->cpu_pll_wo)
-#ifdef CONFIG_SOC_AU1000_FREQUENCY
-		cpufreq = CONFIG_SOC_AU1000_FREQUENCY / 1000000;
-#else
-		cpufreq = 396;
-#endif
-	else
-		cpufreq = (au_readl(SYS_CPUPLL) & 0x3F) * 12;
-	printk(KERN_INFO "(PRID %08lx) @ %ld MHz\n", prid, cpufreq);
-
-	if (sp->cpu_bclk) {
-		/* Enable BCLK switching */
-		bclk = au_readl(SYS_POWERCTRL);
-		au_writel(bclk | 0x60, SYS_POWERCTRL);
-		printk(KERN_INFO "BCLK switching enabled!\n");
-	}
-
-	if (sp->cpu_od)
+	if (au1xxx_cpu_needs_config_od())
 		/* Various early Au1xx0 errata corrected by this */
 		set_c0_config(1 << 19); /* Set Config[OD] */
 	else

commit 7179380ee9bdeb5fa2ff07581f512fe0f5382e5b
Author: Manuel Lauss <mano@roarinelk.homelinux.net>
Date:   Sun Dec 21 09:26:16 2008 +0100

    MIPS: Alchemy: move commandline mangling out of common code
    
    Not every alchemy-based board might want these options forced on it,
    and most of this stuff seems to be intended for devboard code anyway.
    Remove commandline mangling code out of common chip code and instead
    add relevant sections to all in-tree boards to not change existing
    behaviour.
    
    Signed-off-by: Manuel Lauss <mano@roarinelk.homelinux.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
index 1ac6b06f42a3..9889ec3ba4c4 100644
--- a/arch/mips/alchemy/common/setup.c
+++ b/arch/mips/alchemy/common/setup.c
@@ -35,7 +35,6 @@
 #include <asm/time.h>
 
 #include <au1000.h>
-#include <prom.h>
 
 extern void __init board_setup(void);
 extern void au1000_restart(char *);
@@ -46,12 +45,15 @@ extern void set_cpuspec(void);
 void __init plat_mem_setup(void)
 {
 	struct	cpu_spec *sp;
-	char *argptr;
 	unsigned long prid, cpufreq, bclk;
 
 	set_cpuspec();
 	sp = cur_cpu_spec[0];
 
+	_machine_restart = au1000_restart;
+	_machine_halt = au1000_halt;
+	pm_power_off = au1000_power_off;
+
 	board_setup();  /* board specific setup */
 
 	prid = read_c0_prid();
@@ -79,34 +81,6 @@ void __init plat_mem_setup(void)
 		/* Clear to obtain best system bus performance */
 		clear_c0_config(1 << 19); /* Clear Config[OD] */
 
-	argptr = prom_getcmdline();
-
-#ifdef CONFIG_SERIAL_8250_CONSOLE
-	argptr = strstr(argptr, "console=");
-	if (argptr == NULL) {
-		argptr = prom_getcmdline();
-		strcat(argptr, " console=ttyS0,115200");
-	}
-#endif
-
-#ifdef CONFIG_FB_AU1100
-	argptr = strstr(argptr, "video=");
-	if (argptr == NULL) {
-		argptr = prom_getcmdline();
-		/* default panel */
-		/*strcat(argptr, " video=au1100fb:panel:Sharp_320x240_16");*/
-	}
-#endif
-
-#if defined(CONFIG_SOUND_AU1X00) && !defined(CONFIG_SOC_AU1000)
-	/* au1000 does not support vra, au1500 and au1100 do */
-	strcat(argptr, " au1000_audio=vra");
-	argptr = prom_getcmdline();
-#endif
-	_machine_restart = au1000_restart;
-	_machine_halt = au1000_halt;
-	pm_power_off = au1000_power_off;
-
 	/* IO/MEM resources. */
 	set_io_port_base(0);
 	ioport_resource.start = IOPORT_RESOURCE_START;

commit e8c7c482347574ecdd45c43e32c332d5fc2ece61
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 16 19:12:16 2008 +0200

    MIPS: Alchemy: rename directory
    
    It's more than the au1000 these days.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/alchemy/common/setup.c b/arch/mips/alchemy/common/setup.c
new file mode 100644
index 000000000000..1ac6b06f42a3
--- /dev/null
+++ b/arch/mips/alchemy/common/setup.c
@@ -0,0 +1,160 @@
+/*
+ * Copyright 2000, 2007-2008 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc. <source@mvista.com
+ *
+ * Updates to 2.6, Pete Popov, Embedded Alley Solutions, Inc.
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/module.h>
+#include <linux/pm.h>
+
+#include <asm/mipsregs.h>
+#include <asm/reboot.h>
+#include <asm/time.h>
+
+#include <au1000.h>
+#include <prom.h>
+
+extern void __init board_setup(void);
+extern void au1000_restart(char *);
+extern void au1000_halt(void);
+extern void au1000_power_off(void);
+extern void set_cpuspec(void);
+
+void __init plat_mem_setup(void)
+{
+	struct	cpu_spec *sp;
+	char *argptr;
+	unsigned long prid, cpufreq, bclk;
+
+	set_cpuspec();
+	sp = cur_cpu_spec[0];
+
+	board_setup();  /* board specific setup */
+
+	prid = read_c0_prid();
+	if (sp->cpu_pll_wo)
+#ifdef CONFIG_SOC_AU1000_FREQUENCY
+		cpufreq = CONFIG_SOC_AU1000_FREQUENCY / 1000000;
+#else
+		cpufreq = 396;
+#endif
+	else
+		cpufreq = (au_readl(SYS_CPUPLL) & 0x3F) * 12;
+	printk(KERN_INFO "(PRID %08lx) @ %ld MHz\n", prid, cpufreq);
+
+	if (sp->cpu_bclk) {
+		/* Enable BCLK switching */
+		bclk = au_readl(SYS_POWERCTRL);
+		au_writel(bclk | 0x60, SYS_POWERCTRL);
+		printk(KERN_INFO "BCLK switching enabled!\n");
+	}
+
+	if (sp->cpu_od)
+		/* Various early Au1xx0 errata corrected by this */
+		set_c0_config(1 << 19); /* Set Config[OD] */
+	else
+		/* Clear to obtain best system bus performance */
+		clear_c0_config(1 << 19); /* Clear Config[OD] */
+
+	argptr = prom_getcmdline();
+
+#ifdef CONFIG_SERIAL_8250_CONSOLE
+	argptr = strstr(argptr, "console=");
+	if (argptr == NULL) {
+		argptr = prom_getcmdline();
+		strcat(argptr, " console=ttyS0,115200");
+	}
+#endif
+
+#ifdef CONFIG_FB_AU1100
+	argptr = strstr(argptr, "video=");
+	if (argptr == NULL) {
+		argptr = prom_getcmdline();
+		/* default panel */
+		/*strcat(argptr, " video=au1100fb:panel:Sharp_320x240_16");*/
+	}
+#endif
+
+#if defined(CONFIG_SOUND_AU1X00) && !defined(CONFIG_SOC_AU1000)
+	/* au1000 does not support vra, au1500 and au1100 do */
+	strcat(argptr, " au1000_audio=vra");
+	argptr = prom_getcmdline();
+#endif
+	_machine_restart = au1000_restart;
+	_machine_halt = au1000_halt;
+	pm_power_off = au1000_power_off;
+
+	/* IO/MEM resources. */
+	set_io_port_base(0);
+	ioport_resource.start = IOPORT_RESOURCE_START;
+	ioport_resource.end = IOPORT_RESOURCE_END;
+	iomem_resource.start = IOMEM_RESOURCE_START;
+	iomem_resource.end = IOMEM_RESOURCE_END;
+
+	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_E0S);
+	au_writel(SYS_CNTRL_E0 | SYS_CNTRL_EN0, SYS_COUNTER_CNTRL);
+	au_sync();
+	while (au_readl(SYS_COUNTER_CNTRL) & SYS_CNTRL_T0S);
+	au_writel(0, SYS_TOYTRIM);
+}
+
+#if defined(CONFIG_64BIT_PHYS_ADDR)
+/* This routine should be valid for all Au1x based boards */
+phys_t __fixup_bigphys_addr(phys_t phys_addr, phys_t size)
+{
+	/* Don't fixup 36-bit addresses */
+	if ((phys_addr >> 32) != 0)
+		return phys_addr;
+
+#ifdef CONFIG_PCI
+	{
+		u32 start = (u32)Au1500_PCI_MEM_START;
+		u32 end   = (u32)Au1500_PCI_MEM_END;
+
+		/* Check for PCI memory window */
+		if (phys_addr >= start && (phys_addr + size - 1) <= end)
+			return (phys_t)
+			       ((phys_addr - start) + Au1500_PCI_MEM_START);
+	}
+#endif
+
+	/*
+	 * All Au1xx0 SOCs have a PCMCIA controller.
+	 * We setup our 32-bit pseudo addresses to be equal to the
+	 * 36-bit addr >> 4, to make it easier to check the address
+	 * and fix it.
+	 * The PCMCIA socket 0 physical attribute address is 0xF 4000 0000.
+	 * The pseudo address we use is 0xF400 0000. Any address over
+	 * 0xF400 0000 is a PCMCIA pseudo address.
+	 */
+	if ((phys_addr >= 0xF4000000) && (phys_addr < 0xFFFFFFFF))
+		return (phys_t)(phys_addr << 4);
+
+	/* default nop */
+	return phys_addr;
+}
+EXPORT_SYMBOL(__fixup_bigphys_addr);
+#endif
