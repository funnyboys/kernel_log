commit fc9ab75e894b376b8f2960e59d32e8740d2c64e2
Author: Jason Yan <yanaijie@huawei.com>
Date:   Wed May 6 21:43:07 2020 +0800

    MIPS: CFE: Remove dead code in cfe_getfwinfo()
    
    This code has been marked dead since the beginning of the git history.
    Seems no need to keep it now.
    
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/fw/cfe/cfe_api.c b/arch/mips/fw/cfe/cfe_api.c
index c020b29f561c..0c9c97ab291e 100644
--- a/arch/mips/fw/cfe/cfe_api.c
+++ b/arch/mips/fw/cfe/cfe_api.c
@@ -243,11 +243,6 @@ int cfe_getfwinfo(cfe_fwinfo_t * info)
 	info->fwi_bootarea_pa = xiocb.plist.xiocb_fwinfo.fwi_bootarea_pa;
 	info->fwi_bootarea_size =
 	    xiocb.plist.xiocb_fwinfo.fwi_bootarea_size;
-#if 0
-	info->fwi_reserved1 = xiocb.plist.xiocb_fwinfo.fwi_reserved1;
-	info->fwi_reserved2 = xiocb.plist.xiocb_fwinfo.fwi_reserved2;
-	info->fwi_reserved3 = xiocb.plist.xiocb_fwinfo.fwi_reserved3;
-#endif
 
 	return 0;
 }

commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/fw/cfe/cfe_api.c b/arch/mips/fw/cfe/cfe_api.c
index cf84f01931c5..c020b29f561c 100644
--- a/arch/mips/fw/cfe/cfe_api.c
+++ b/arch/mips/fw/cfe/cfe_api.c
@@ -1,19 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2000, 2001, 2002 Broadcom Corporation
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
 
 /*

commit 39b6f3aa1979ad7df42474d3c63bbc7e25bd31e4
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Mon Jun 17 13:00:36 2013 +0000

    MIPS: sibyte: Declare the cfe_write() buffer as constant
    
    The write() prototype expects a const char * as argument so declare
    it as such.
    
    Fixes the following build problem:
    
    arch/mips/sibyte/common/cfe_console.c:23:5: error: passing argument 2 of
    'cfe_write' discards 'const' qualifier from pointer target type [-Werror]
    arch/mips/sibyte/common/cfe_console.c:34:4: error: passing argument 2 of
    'cfe_write' makes pointer from integer without a cast [-Werror]
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Acked-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: sibyte-users@bitmover.com
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5485/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/fw/cfe/cfe_api.c b/arch/mips/fw/cfe/cfe_api.c
index d06dc5a6b8d3..cf84f01931c5 100644
--- a/arch/mips/fw/cfe/cfe_api.c
+++ b/arch/mips/fw/cfe/cfe_api.c
@@ -406,12 +406,12 @@ int cfe_setenv(char *name, char *val)
 	return xiocb.xiocb_status;
 }
 
-int cfe_write(int handle, unsigned char *buffer, int length)
+int cfe_write(int handle, const char *buffer, int length)
 {
 	return cfe_writeblk(handle, 0, buffer, length);
 }
 
-int cfe_writeblk(int handle, s64 offset, unsigned char *buffer, int length)
+int cfe_writeblk(int handle, s64 offset, const char *buffer, int length)
 {
 	struct cfe_xiocb xiocb;
 

commit 982f6ffeeed5ef6104cfd72e517ff9e7a9270fda
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Sep 17 02:25:07 2009 +0200

    MIPS: Remove useless zero initializations.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/fw/cfe/cfe_api.c b/arch/mips/fw/cfe/cfe_api.c
index 717db74f7c6e..d06dc5a6b8d3 100644
--- a/arch/mips/fw/cfe/cfe_api.c
+++ b/arch/mips/fw/cfe/cfe_api.c
@@ -45,8 +45,8 @@ int cfe_iocb_dispatch(struct cfe_xiocb *xiocb);
  * passed in two registers each, and CFE expects one.
  */
 
-static int (*cfe_dispfunc) (intptr_t handle, intptr_t xiocb) = 0;
-static u64 cfe_handle = 0;
+static int (*cfe_dispfunc) (intptr_t handle, intptr_t xiocb);
+static u64 cfe_handle;
 
 int cfe_init(u64 handle, u64 ept)
 {

commit 417345d8f5bacc291138c99a292a8ca69947530e
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 29 14:23:43 2007 +0000

    [MIPS] CFE: Make code remotely resemble Linux code.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/fw/cfe/cfe_api.c b/arch/mips/fw/cfe/cfe_api.c
index a9f69e4e40ac..717db74f7c6e 100644
--- a/arch/mips/fw/cfe/cfe_api.c
+++ b/arch/mips/fw/cfe/cfe_api.c
@@ -16,19 +16,16 @@
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
  */
 
-/*  *********************************************************************
-    *
-    *  Broadcom Common Firmware Environment (CFE)
-    *
-    *  Device Function stubs			File: cfe_api.c
-    *
-    *  This module contains device function stubs (small routines to
-    *  call the standard "iocb" interface entry point to CFE).
-    *  There should be one routine here per iocb function call.
-    *
-    *  Authors:  Mitch Lichtenberg, Chris Demetriou
-    *
-    ********************************************************************* */
+/*
+ *
+ * Broadcom Common Firmware Environment (CFE)
+ *
+ * This module contains device function stubs (small routines to
+ * call the standard "iocb" interface entry point to CFE).
+ * There should be one routine here per iocb function call.
+ *
+ * Authors:  Mitch Lichtenberg, Chris Demetriou
+ */
 
 #include <asm/fw/cfe/cfe_api.h>
 #include "cfe_api_int.h"
@@ -37,12 +34,8 @@
 #define XPTR_FROM_NATIVE(n)	((cfe_xptr_t) (intptr_t) (n))
 #define NATIVE_FROM_XPTR(x)	((void *) (intptr_t) (x))
 
-#ifdef CFE_API_IMPL_NAMESPACE
-#define cfe_iocb_dispatch(a)		__cfe_iocb_dispatch(a)
-#endif
-int cfe_iocb_dispatch(cfe_xiocb_t * xiocb);
+int cfe_iocb_dispatch(struct cfe_xiocb *xiocb);
 
-#if defined(CFE_API_common) || defined(CFE_API_ALL)
 /*
  * Declare the dispatch function with args of "intptr_t".
  * This makes sure whatever model we're compiling in
@@ -53,27 +46,25 @@ int cfe_iocb_dispatch(cfe_xiocb_t * xiocb);
  */
 
 static int (*cfe_dispfunc) (intptr_t handle, intptr_t xiocb) = 0;
-static cfe_xuint_t cfe_handle = 0;
+static u64 cfe_handle = 0;
 
-int cfe_init(cfe_xuint_t handle, cfe_xuint_t ept)
+int cfe_init(u64 handle, u64 ept)
 {
 	cfe_dispfunc = NATIVE_FROM_XPTR(ept);
 	cfe_handle = handle;
 	return 0;
 }
 
-int cfe_iocb_dispatch(cfe_xiocb_t * xiocb)
+int cfe_iocb_dispatch(struct cfe_xiocb * xiocb)
 {
 	if (!cfe_dispfunc)
 		return -1;
 	return (*cfe_dispfunc) ((intptr_t) cfe_handle, (intptr_t) xiocb);
 }
-#endif				/* CFE_API_common || CFE_API_ALL */
 
-#if defined(CFE_API_close) || defined(CFE_API_ALL)
 int cfe_close(int handle)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_DEV_CLOSE;
 	xiocb.xiocb_status = 0;
@@ -86,18 +77,16 @@ int cfe_close(int handle)
 	return xiocb.xiocb_status;
 
 }
-#endif				/* CFE_API_close || CFE_API_ALL */
 
-#if defined(CFE_API_cpu_start) || defined(CFE_API_ALL)
 int cfe_cpu_start(int cpu, void (*fn) (void), long sp, long gp, long a1)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_FW_CPUCTL;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = 0;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_cpuctl_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_cpuctl);
 	xiocb.plist.xiocb_cpuctl.cpu_number = cpu;
 	xiocb.plist.xiocb_cpuctl.cpu_command = CFE_CPU_CMD_START;
 	xiocb.plist.xiocb_cpuctl.gp_val = gp;
@@ -109,18 +98,16 @@ int cfe_cpu_start(int cpu, void (*fn) (void), long sp, long gp, long a1)
 
 	return xiocb.xiocb_status;
 }
-#endif				/* CFE_API_cpu_start || CFE_API_ALL */
 
-#if defined(CFE_API_cpu_stop) || defined(CFE_API_ALL)
 int cfe_cpu_stop(int cpu)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_FW_CPUCTL;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = 0;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_cpuctl_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_cpuctl);
 	xiocb.plist.xiocb_cpuctl.cpu_number = cpu;
 	xiocb.plist.xiocb_cpuctl.cpu_command = CFE_CPU_CMD_STOP;
 
@@ -128,18 +115,16 @@ int cfe_cpu_stop(int cpu)
 
 	return xiocb.xiocb_status;
 }
-#endif				/* CFE_API_cpu_stop || CFE_API_ALL */
 
-#if defined(CFE_API_enumenv) || defined(CFE_API_ALL)
 int cfe_enumenv(int idx, char *name, int namelen, char *val, int vallen)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_ENV_SET;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = 0;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_envbuf_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_envbuf);
 	xiocb.plist.xiocb_envbuf.enum_idx = idx;
 	xiocb.plist.xiocb_envbuf.name_ptr = XPTR_FROM_NATIVE(name);
 	xiocb.plist.xiocb_envbuf.name_length = namelen;
@@ -150,20 +135,17 @@ int cfe_enumenv(int idx, char *name, int namelen, char *val, int vallen)
 
 	return xiocb.xiocb_status;
 }
-#endif				/* CFE_API_enumenv || CFE_API_ALL */
 
-#if defined(CFE_API_enummem) || defined(CFE_API_ALL)
 int
-cfe_enummem(int idx, int flags, cfe_xuint_t * start, cfe_xuint_t * length,
-	    cfe_xuint_t * type)
+cfe_enummem(int idx, int flags, u64 *start, u64 *length, u64 *type)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_FW_MEMENUM;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = 0;
 	xiocb.xiocb_flags = flags;
-	xiocb.xiocb_psize = sizeof(xiocb_meminfo_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_meminfo);
 	xiocb.plist.xiocb_meminfo.mi_idx = idx;
 
 	cfe_iocb_dispatch(&xiocb);
@@ -177,30 +159,26 @@ cfe_enummem(int idx, int flags, cfe_xuint_t * start, cfe_xuint_t * length,
 
 	return 0;
 }
-#endif				/* CFE_API_enummem || CFE_API_ALL */
 
-#if defined(CFE_API_exit) || defined(CFE_API_ALL)
 int cfe_exit(int warm, int status)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_FW_RESTART;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = 0;
 	xiocb.xiocb_flags = warm ? CFE_FLG_WARMSTART : 0;
-	xiocb.xiocb_psize = sizeof(xiocb_exitstat_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_exitstat);
 	xiocb.plist.xiocb_exitstat.status = status;
 
 	cfe_iocb_dispatch(&xiocb);
 
 	return xiocb.xiocb_status;
 }
-#endif				/* CFE_API_exit || CFE_API_ALL */
 
-#if defined(CFE_API_flushcache) || defined(CFE_API_ALL)
 int cfe_flushcache(int flg)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_FW_FLUSHCACHE;
 	xiocb.xiocb_status = 0;
@@ -212,34 +190,30 @@ int cfe_flushcache(int flg)
 
 	return xiocb.xiocb_status;
 }
-#endif				/* CFE_API_flushcache || CFE_API_ALL */
 
-#if defined(CFE_API_getdevinfo) || defined(CFE_API_ALL)
 int cfe_getdevinfo(char *name)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_DEV_GETINFO;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = 0;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_buffer_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_buffer);
 	xiocb.plist.xiocb_buffer.buf_offset = 0;
 	xiocb.plist.xiocb_buffer.buf_ptr = XPTR_FROM_NATIVE(name);
-	xiocb.plist.xiocb_buffer.buf_length = cfe_strlen(name);
+	xiocb.plist.xiocb_buffer.buf_length = strlen(name);
 
 	cfe_iocb_dispatch(&xiocb);
 
 	if (xiocb.xiocb_status < 0)
 		return xiocb.xiocb_status;
-	return xiocb.plist.xiocb_buffer.buf_devflags;
+	return xiocb.plist.xiocb_buffer.buf_ioctlcmd;
 }
-#endif				/* CFE_API_getdevinfo || CFE_API_ALL */
 
-#if defined(CFE_API_getenv) || defined(CFE_API_ALL)
 int cfe_getenv(char *name, char *dest, int destlen)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	*dest = 0;
 
@@ -247,10 +221,10 @@ int cfe_getenv(char *name, char *dest, int destlen)
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = 0;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_envbuf_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_envbuf);
 	xiocb.plist.xiocb_envbuf.enum_idx = 0;
 	xiocb.plist.xiocb_envbuf.name_ptr = XPTR_FROM_NATIVE(name);
-	xiocb.plist.xiocb_envbuf.name_length = cfe_strlen(name);
+	xiocb.plist.xiocb_envbuf.name_length = strlen(name);
 	xiocb.plist.xiocb_envbuf.val_ptr = XPTR_FROM_NATIVE(dest);
 	xiocb.plist.xiocb_envbuf.val_length = destlen;
 
@@ -258,18 +232,16 @@ int cfe_getenv(char *name, char *dest, int destlen)
 
 	return xiocb.xiocb_status;
 }
-#endif				/* CFE_API_getenv || CFE_API_ALL */
 
-#if defined(CFE_API_getfwinfo) || defined(CFE_API_ALL)
 int cfe_getfwinfo(cfe_fwinfo_t * info)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_FW_GETINFO;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = 0;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_fwinfo_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_fwinfo);
 
 	cfe_iocb_dispatch(&xiocb);
 
@@ -292,12 +264,10 @@ int cfe_getfwinfo(cfe_fwinfo_t * info)
 
 	return 0;
 }
-#endif				/* CFE_API_getfwinfo || CFE_API_ALL */
 
-#if defined(CFE_API_getstdhandle) || defined(CFE_API_ALL)
 int cfe_getstdhandle(int flg)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_DEV_GETHANDLE;
 	xiocb.xiocb_status = 0;
@@ -311,23 +281,17 @@ int cfe_getstdhandle(int flg)
 		return xiocb.xiocb_status;
 	return xiocb.xiocb_handle;
 }
-#endif				/* CFE_API_getstdhandle || CFE_API_ALL */
 
-#if defined(CFE_API_getticks) || defined(CFE_API_ALL)
 int64_t
-#ifdef CFE_API_IMPL_NAMESPACE
-__cfe_getticks(void)
-#else
 cfe_getticks(void)
-#endif
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_FW_GETTIME;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = 0;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_time_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_time);
 	xiocb.plist.xiocb_time.ticks = 0;
 
 	cfe_iocb_dispatch(&xiocb);
@@ -335,18 +299,16 @@ cfe_getticks(void)
 	return xiocb.plist.xiocb_time.ticks;
 
 }
-#endif				/* CFE_API_getticks || CFE_API_ALL */
 
-#if defined(CFE_API_inpstat) || defined(CFE_API_ALL)
 int cfe_inpstat(int handle)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_DEV_INPSTAT;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = handle;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_inpstat_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_inpstat);
 	xiocb.plist.xiocb_inpstat.inp_status = 0;
 
 	cfe_iocb_dispatch(&xiocb);
@@ -355,20 +317,18 @@ int cfe_inpstat(int handle)
 		return xiocb.xiocb_status;
 	return xiocb.plist.xiocb_inpstat.inp_status;
 }
-#endif				/* CFE_API_inpstat || CFE_API_ALL */
 
-#if defined(CFE_API_ioctl) || defined(CFE_API_ALL)
 int
 cfe_ioctl(int handle, unsigned int ioctlnum, unsigned char *buffer,
-	  int length, int *retlen, cfe_xuint_t offset)
+	  int length, int *retlen, u64 offset)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_DEV_IOCTL;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = handle;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_buffer_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_buffer);
 	xiocb.plist.xiocb_buffer.buf_offset = offset;
 	xiocb.plist.xiocb_buffer.buf_ioctlcmd = ioctlnum;
 	xiocb.plist.xiocb_buffer.buf_ptr = XPTR_FROM_NATIVE(buffer);
@@ -380,21 +340,19 @@ cfe_ioctl(int handle, unsigned int ioctlnum, unsigned char *buffer,
 		*retlen = xiocb.plist.xiocb_buffer.buf_retlen;
 	return xiocb.xiocb_status;
 }
-#endif				/* CFE_API_ioctl || CFE_API_ALL */
 
-#if defined(CFE_API_open) || defined(CFE_API_ALL)
 int cfe_open(char *name)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_DEV_OPEN;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = 0;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_buffer_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_buffer);
 	xiocb.plist.xiocb_buffer.buf_offset = 0;
 	xiocb.plist.xiocb_buffer.buf_ptr = XPTR_FROM_NATIVE(name);
-	xiocb.plist.xiocb_buffer.buf_length = cfe_strlen(name);
+	xiocb.plist.xiocb_buffer.buf_length = strlen(name);
 
 	cfe_iocb_dispatch(&xiocb);
 
@@ -402,27 +360,21 @@ int cfe_open(char *name)
 		return xiocb.xiocb_status;
 	return xiocb.xiocb_handle;
 }
-#endif				/* CFE_API_open || CFE_API_ALL */
 
-#if defined(CFE_API_read) || defined(CFE_API_ALL)
 int cfe_read(int handle, unsigned char *buffer, int length)
 {
 	return cfe_readblk(handle, 0, buffer, length);
 }
-#endif				/* CFE_API_read || CFE_API_ALL */
 
-#if defined(CFE_API_readblk) || defined(CFE_API_ALL)
-int
-cfe_readblk(int handle, cfe_xint_t offset, unsigned char *buffer,
-	    int length)
+int cfe_readblk(int handle, s64 offset, unsigned char *buffer, int length)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_DEV_READ;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = handle;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_buffer_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_buffer);
 	xiocb.plist.xiocb_buffer.buf_offset = offset;
 	xiocb.plist.xiocb_buffer.buf_ptr = XPTR_FROM_NATIVE(buffer);
 	xiocb.plist.xiocb_buffer.buf_length = length;
@@ -433,62 +385,41 @@ cfe_readblk(int handle, cfe_xint_t offset, unsigned char *buffer,
 		return xiocb.xiocb_status;
 	return xiocb.plist.xiocb_buffer.buf_retlen;
 }
-#endif				/* CFE_API_readblk || CFE_API_ALL */
 
-#if defined(CFE_API_setenv) || defined(CFE_API_ALL)
 int cfe_setenv(char *name, char *val)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_ENV_SET;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = 0;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_envbuf_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_envbuf);
 	xiocb.plist.xiocb_envbuf.enum_idx = 0;
 	xiocb.plist.xiocb_envbuf.name_ptr = XPTR_FROM_NATIVE(name);
-	xiocb.plist.xiocb_envbuf.name_length = cfe_strlen(name);
+	xiocb.plist.xiocb_envbuf.name_length = strlen(name);
 	xiocb.plist.xiocb_envbuf.val_ptr = XPTR_FROM_NATIVE(val);
-	xiocb.plist.xiocb_envbuf.val_length = cfe_strlen(val);
+	xiocb.plist.xiocb_envbuf.val_length = strlen(val);
 
 	cfe_iocb_dispatch(&xiocb);
 
 	return xiocb.xiocb_status;
 }
-#endif				/* CFE_API_setenv || CFE_API_ALL */
-
-#if (defined(CFE_API_strlen) || defined(CFE_API_ALL)) \
-    && !defined(CFE_API_STRLEN_CUSTOM)
-int cfe_strlen(char *name)
-{
-	int count = 0;
-
-	while (*name++)
-		count++;
 
-	return count;
-}
-#endif				/* CFE_API_strlen || CFE_API_ALL */
-
-#if defined(CFE_API_write) || defined(CFE_API_ALL)
 int cfe_write(int handle, unsigned char *buffer, int length)
 {
 	return cfe_writeblk(handle, 0, buffer, length);
 }
-#endif				/* CFE_API_write || CFE_API_ALL */
 
-#if defined(CFE_API_writeblk) || defined(CFE_API_ALL)
-int
-cfe_writeblk(int handle, cfe_xint_t offset, unsigned char *buffer,
-	     int length)
+int cfe_writeblk(int handle, s64 offset, unsigned char *buffer, int length)
 {
-	cfe_xiocb_t xiocb;
+	struct cfe_xiocb xiocb;
 
 	xiocb.xiocb_fcode = CFE_CMD_DEV_WRITE;
 	xiocb.xiocb_status = 0;
 	xiocb.xiocb_handle = handle;
 	xiocb.xiocb_flags = 0;
-	xiocb.xiocb_psize = sizeof(xiocb_buffer_t);
+	xiocb.xiocb_psize = sizeof(struct xiocb_buffer);
 	xiocb.plist.xiocb_buffer.buf_offset = offset;
 	xiocb.plist.xiocb_buffer.buf_ptr = XPTR_FROM_NATIVE(buffer);
 	xiocb.plist.xiocb_buffer.buf_length = length;
@@ -499,4 +430,3 @@ cfe_writeblk(int handle, cfe_xint_t offset, unsigned char *buffer,
 		return xiocb.xiocb_status;
 	return xiocb.plist.xiocb_buffer.buf_retlen;
 }
-#endif				/* CFE_API_writeblk || CFE_API_ALL */

commit df78b5c8faa72b3c04f82faab126de93af178348
Author: Aurelien Jarno <aurelien@aurel32.net>
Date:   Wed Sep 5 08:58:26 2007 +0200

    [MIPS] Move CFE code into arch/mips/fw/cfe
    
    Move the platform independent part of the CFE code to arch/mips/fw/cfe from
    arch/mips/sibyte/cfe.
    
    Signed-off-by: Aurelien Jarno <aurelien@aurel32.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/fw/cfe/cfe_api.c b/arch/mips/fw/cfe/cfe_api.c
new file mode 100644
index 000000000000..a9f69e4e40ac
--- /dev/null
+++ b/arch/mips/fw/cfe/cfe_api.c
@@ -0,0 +1,502 @@
+/*
+ * Copyright (C) 2000, 2001, 2002 Broadcom Corporation
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ */
+
+/*  *********************************************************************
+    *
+    *  Broadcom Common Firmware Environment (CFE)
+    *
+    *  Device Function stubs			File: cfe_api.c
+    *
+    *  This module contains device function stubs (small routines to
+    *  call the standard "iocb" interface entry point to CFE).
+    *  There should be one routine here per iocb function call.
+    *
+    *  Authors:  Mitch Lichtenberg, Chris Demetriou
+    *
+    ********************************************************************* */
+
+#include <asm/fw/cfe/cfe_api.h>
+#include "cfe_api_int.h"
+
+/* Cast from a native pointer to a cfe_xptr_t and back.	 */
+#define XPTR_FROM_NATIVE(n)	((cfe_xptr_t) (intptr_t) (n))
+#define NATIVE_FROM_XPTR(x)	((void *) (intptr_t) (x))
+
+#ifdef CFE_API_IMPL_NAMESPACE
+#define cfe_iocb_dispatch(a)		__cfe_iocb_dispatch(a)
+#endif
+int cfe_iocb_dispatch(cfe_xiocb_t * xiocb);
+
+#if defined(CFE_API_common) || defined(CFE_API_ALL)
+/*
+ * Declare the dispatch function with args of "intptr_t".
+ * This makes sure whatever model we're compiling in
+ * puts the pointers in a single register.  For example,
+ * combining -mlong64 and -mips1 or -mips2 would lead to
+ * trouble, since the handle and IOCB pointer will be
+ * passed in two registers each, and CFE expects one.
+ */
+
+static int (*cfe_dispfunc) (intptr_t handle, intptr_t xiocb) = 0;
+static cfe_xuint_t cfe_handle = 0;
+
+int cfe_init(cfe_xuint_t handle, cfe_xuint_t ept)
+{
+	cfe_dispfunc = NATIVE_FROM_XPTR(ept);
+	cfe_handle = handle;
+	return 0;
+}
+
+int cfe_iocb_dispatch(cfe_xiocb_t * xiocb)
+{
+	if (!cfe_dispfunc)
+		return -1;
+	return (*cfe_dispfunc) ((intptr_t) cfe_handle, (intptr_t) xiocb);
+}
+#endif				/* CFE_API_common || CFE_API_ALL */
+
+#if defined(CFE_API_close) || defined(CFE_API_ALL)
+int cfe_close(int handle)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_DEV_CLOSE;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = handle;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = 0;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	return xiocb.xiocb_status;
+
+}
+#endif				/* CFE_API_close || CFE_API_ALL */
+
+#if defined(CFE_API_cpu_start) || defined(CFE_API_ALL)
+int cfe_cpu_start(int cpu, void (*fn) (void), long sp, long gp, long a1)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_FW_CPUCTL;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_cpuctl_t);
+	xiocb.plist.xiocb_cpuctl.cpu_number = cpu;
+	xiocb.plist.xiocb_cpuctl.cpu_command = CFE_CPU_CMD_START;
+	xiocb.plist.xiocb_cpuctl.gp_val = gp;
+	xiocb.plist.xiocb_cpuctl.sp_val = sp;
+	xiocb.plist.xiocb_cpuctl.a1_val = a1;
+	xiocb.plist.xiocb_cpuctl.start_addr = (long) fn;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	return xiocb.xiocb_status;
+}
+#endif				/* CFE_API_cpu_start || CFE_API_ALL */
+
+#if defined(CFE_API_cpu_stop) || defined(CFE_API_ALL)
+int cfe_cpu_stop(int cpu)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_FW_CPUCTL;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_cpuctl_t);
+	xiocb.plist.xiocb_cpuctl.cpu_number = cpu;
+	xiocb.plist.xiocb_cpuctl.cpu_command = CFE_CPU_CMD_STOP;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	return xiocb.xiocb_status;
+}
+#endif				/* CFE_API_cpu_stop || CFE_API_ALL */
+
+#if defined(CFE_API_enumenv) || defined(CFE_API_ALL)
+int cfe_enumenv(int idx, char *name, int namelen, char *val, int vallen)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_ENV_SET;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_envbuf_t);
+	xiocb.plist.xiocb_envbuf.enum_idx = idx;
+	xiocb.plist.xiocb_envbuf.name_ptr = XPTR_FROM_NATIVE(name);
+	xiocb.plist.xiocb_envbuf.name_length = namelen;
+	xiocb.plist.xiocb_envbuf.val_ptr = XPTR_FROM_NATIVE(val);
+	xiocb.plist.xiocb_envbuf.val_length = vallen;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	return xiocb.xiocb_status;
+}
+#endif				/* CFE_API_enumenv || CFE_API_ALL */
+
+#if defined(CFE_API_enummem) || defined(CFE_API_ALL)
+int
+cfe_enummem(int idx, int flags, cfe_xuint_t * start, cfe_xuint_t * length,
+	    cfe_xuint_t * type)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_FW_MEMENUM;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = flags;
+	xiocb.xiocb_psize = sizeof(xiocb_meminfo_t);
+	xiocb.plist.xiocb_meminfo.mi_idx = idx;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	if (xiocb.xiocb_status < 0)
+		return xiocb.xiocb_status;
+
+	*start = xiocb.plist.xiocb_meminfo.mi_addr;
+	*length = xiocb.plist.xiocb_meminfo.mi_size;
+	*type = xiocb.plist.xiocb_meminfo.mi_type;
+
+	return 0;
+}
+#endif				/* CFE_API_enummem || CFE_API_ALL */
+
+#if defined(CFE_API_exit) || defined(CFE_API_ALL)
+int cfe_exit(int warm, int status)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_FW_RESTART;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = warm ? CFE_FLG_WARMSTART : 0;
+	xiocb.xiocb_psize = sizeof(xiocb_exitstat_t);
+	xiocb.plist.xiocb_exitstat.status = status;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	return xiocb.xiocb_status;
+}
+#endif				/* CFE_API_exit || CFE_API_ALL */
+
+#if defined(CFE_API_flushcache) || defined(CFE_API_ALL)
+int cfe_flushcache(int flg)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_FW_FLUSHCACHE;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = flg;
+	xiocb.xiocb_psize = 0;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	return xiocb.xiocb_status;
+}
+#endif				/* CFE_API_flushcache || CFE_API_ALL */
+
+#if defined(CFE_API_getdevinfo) || defined(CFE_API_ALL)
+int cfe_getdevinfo(char *name)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_DEV_GETINFO;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_buffer_t);
+	xiocb.plist.xiocb_buffer.buf_offset = 0;
+	xiocb.plist.xiocb_buffer.buf_ptr = XPTR_FROM_NATIVE(name);
+	xiocb.plist.xiocb_buffer.buf_length = cfe_strlen(name);
+
+	cfe_iocb_dispatch(&xiocb);
+
+	if (xiocb.xiocb_status < 0)
+		return xiocb.xiocb_status;
+	return xiocb.plist.xiocb_buffer.buf_devflags;
+}
+#endif				/* CFE_API_getdevinfo || CFE_API_ALL */
+
+#if defined(CFE_API_getenv) || defined(CFE_API_ALL)
+int cfe_getenv(char *name, char *dest, int destlen)
+{
+	cfe_xiocb_t xiocb;
+
+	*dest = 0;
+
+	xiocb.xiocb_fcode = CFE_CMD_ENV_GET;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_envbuf_t);
+	xiocb.plist.xiocb_envbuf.enum_idx = 0;
+	xiocb.plist.xiocb_envbuf.name_ptr = XPTR_FROM_NATIVE(name);
+	xiocb.plist.xiocb_envbuf.name_length = cfe_strlen(name);
+	xiocb.plist.xiocb_envbuf.val_ptr = XPTR_FROM_NATIVE(dest);
+	xiocb.plist.xiocb_envbuf.val_length = destlen;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	return xiocb.xiocb_status;
+}
+#endif				/* CFE_API_getenv || CFE_API_ALL */
+
+#if defined(CFE_API_getfwinfo) || defined(CFE_API_ALL)
+int cfe_getfwinfo(cfe_fwinfo_t * info)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_FW_GETINFO;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_fwinfo_t);
+
+	cfe_iocb_dispatch(&xiocb);
+
+	if (xiocb.xiocb_status < 0)
+		return xiocb.xiocb_status;
+
+	info->fwi_version = xiocb.plist.xiocb_fwinfo.fwi_version;
+	info->fwi_totalmem = xiocb.plist.xiocb_fwinfo.fwi_totalmem;
+	info->fwi_flags = xiocb.plist.xiocb_fwinfo.fwi_flags;
+	info->fwi_boardid = xiocb.plist.xiocb_fwinfo.fwi_boardid;
+	info->fwi_bootarea_va = xiocb.plist.xiocb_fwinfo.fwi_bootarea_va;
+	info->fwi_bootarea_pa = xiocb.plist.xiocb_fwinfo.fwi_bootarea_pa;
+	info->fwi_bootarea_size =
+	    xiocb.plist.xiocb_fwinfo.fwi_bootarea_size;
+#if 0
+	info->fwi_reserved1 = xiocb.plist.xiocb_fwinfo.fwi_reserved1;
+	info->fwi_reserved2 = xiocb.plist.xiocb_fwinfo.fwi_reserved2;
+	info->fwi_reserved3 = xiocb.plist.xiocb_fwinfo.fwi_reserved3;
+#endif
+
+	return 0;
+}
+#endif				/* CFE_API_getfwinfo || CFE_API_ALL */
+
+#if defined(CFE_API_getstdhandle) || defined(CFE_API_ALL)
+int cfe_getstdhandle(int flg)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_DEV_GETHANDLE;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = flg;
+	xiocb.xiocb_psize = 0;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	if (xiocb.xiocb_status < 0)
+		return xiocb.xiocb_status;
+	return xiocb.xiocb_handle;
+}
+#endif				/* CFE_API_getstdhandle || CFE_API_ALL */
+
+#if defined(CFE_API_getticks) || defined(CFE_API_ALL)
+int64_t
+#ifdef CFE_API_IMPL_NAMESPACE
+__cfe_getticks(void)
+#else
+cfe_getticks(void)
+#endif
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_FW_GETTIME;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_time_t);
+	xiocb.plist.xiocb_time.ticks = 0;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	return xiocb.plist.xiocb_time.ticks;
+
+}
+#endif				/* CFE_API_getticks || CFE_API_ALL */
+
+#if defined(CFE_API_inpstat) || defined(CFE_API_ALL)
+int cfe_inpstat(int handle)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_DEV_INPSTAT;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = handle;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_inpstat_t);
+	xiocb.plist.xiocb_inpstat.inp_status = 0;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	if (xiocb.xiocb_status < 0)
+		return xiocb.xiocb_status;
+	return xiocb.plist.xiocb_inpstat.inp_status;
+}
+#endif				/* CFE_API_inpstat || CFE_API_ALL */
+
+#if defined(CFE_API_ioctl) || defined(CFE_API_ALL)
+int
+cfe_ioctl(int handle, unsigned int ioctlnum, unsigned char *buffer,
+	  int length, int *retlen, cfe_xuint_t offset)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_DEV_IOCTL;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = handle;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_buffer_t);
+	xiocb.plist.xiocb_buffer.buf_offset = offset;
+	xiocb.plist.xiocb_buffer.buf_ioctlcmd = ioctlnum;
+	xiocb.plist.xiocb_buffer.buf_ptr = XPTR_FROM_NATIVE(buffer);
+	xiocb.plist.xiocb_buffer.buf_length = length;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	if (retlen)
+		*retlen = xiocb.plist.xiocb_buffer.buf_retlen;
+	return xiocb.xiocb_status;
+}
+#endif				/* CFE_API_ioctl || CFE_API_ALL */
+
+#if defined(CFE_API_open) || defined(CFE_API_ALL)
+int cfe_open(char *name)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_DEV_OPEN;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_buffer_t);
+	xiocb.plist.xiocb_buffer.buf_offset = 0;
+	xiocb.plist.xiocb_buffer.buf_ptr = XPTR_FROM_NATIVE(name);
+	xiocb.plist.xiocb_buffer.buf_length = cfe_strlen(name);
+
+	cfe_iocb_dispatch(&xiocb);
+
+	if (xiocb.xiocb_status < 0)
+		return xiocb.xiocb_status;
+	return xiocb.xiocb_handle;
+}
+#endif				/* CFE_API_open || CFE_API_ALL */
+
+#if defined(CFE_API_read) || defined(CFE_API_ALL)
+int cfe_read(int handle, unsigned char *buffer, int length)
+{
+	return cfe_readblk(handle, 0, buffer, length);
+}
+#endif				/* CFE_API_read || CFE_API_ALL */
+
+#if defined(CFE_API_readblk) || defined(CFE_API_ALL)
+int
+cfe_readblk(int handle, cfe_xint_t offset, unsigned char *buffer,
+	    int length)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_DEV_READ;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = handle;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_buffer_t);
+	xiocb.plist.xiocb_buffer.buf_offset = offset;
+	xiocb.plist.xiocb_buffer.buf_ptr = XPTR_FROM_NATIVE(buffer);
+	xiocb.plist.xiocb_buffer.buf_length = length;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	if (xiocb.xiocb_status < 0)
+		return xiocb.xiocb_status;
+	return xiocb.plist.xiocb_buffer.buf_retlen;
+}
+#endif				/* CFE_API_readblk || CFE_API_ALL */
+
+#if defined(CFE_API_setenv) || defined(CFE_API_ALL)
+int cfe_setenv(char *name, char *val)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_ENV_SET;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = 0;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_envbuf_t);
+	xiocb.plist.xiocb_envbuf.enum_idx = 0;
+	xiocb.plist.xiocb_envbuf.name_ptr = XPTR_FROM_NATIVE(name);
+	xiocb.plist.xiocb_envbuf.name_length = cfe_strlen(name);
+	xiocb.plist.xiocb_envbuf.val_ptr = XPTR_FROM_NATIVE(val);
+	xiocb.plist.xiocb_envbuf.val_length = cfe_strlen(val);
+
+	cfe_iocb_dispatch(&xiocb);
+
+	return xiocb.xiocb_status;
+}
+#endif				/* CFE_API_setenv || CFE_API_ALL */
+
+#if (defined(CFE_API_strlen) || defined(CFE_API_ALL)) \
+    && !defined(CFE_API_STRLEN_CUSTOM)
+int cfe_strlen(char *name)
+{
+	int count = 0;
+
+	while (*name++)
+		count++;
+
+	return count;
+}
+#endif				/* CFE_API_strlen || CFE_API_ALL */
+
+#if defined(CFE_API_write) || defined(CFE_API_ALL)
+int cfe_write(int handle, unsigned char *buffer, int length)
+{
+	return cfe_writeblk(handle, 0, buffer, length);
+}
+#endif				/* CFE_API_write || CFE_API_ALL */
+
+#if defined(CFE_API_writeblk) || defined(CFE_API_ALL)
+int
+cfe_writeblk(int handle, cfe_xint_t offset, unsigned char *buffer,
+	     int length)
+{
+	cfe_xiocb_t xiocb;
+
+	xiocb.xiocb_fcode = CFE_CMD_DEV_WRITE;
+	xiocb.xiocb_status = 0;
+	xiocb.xiocb_handle = handle;
+	xiocb.xiocb_flags = 0;
+	xiocb.xiocb_psize = sizeof(xiocb_buffer_t);
+	xiocb.plist.xiocb_buffer.buf_offset = offset;
+	xiocb.plist.xiocb_buffer.buf_ptr = XPTR_FROM_NATIVE(buffer);
+	xiocb.plist.xiocb_buffer.buf_length = length;
+
+	cfe_iocb_dispatch(&xiocb);
+
+	if (xiocb.xiocb_status < 0)
+		return xiocb.xiocb_status;
+	return xiocb.plist.xiocb_buffer.buf_retlen;
+}
+#endif				/* CFE_API_writeblk || CFE_API_ALL */
