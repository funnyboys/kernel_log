commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/pci/pci-vr41xx.c b/arch/mips/pci/pci-vr41xx.c
index 157c7715b7c8..1fa4e101470c 100644
--- a/arch/mips/pci/pci-vr41xx.c
+++ b/arch/mips/pci/pci-vr41xx.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *  pci-vr41xx.c, PCI Control Unit routines for the NEC VR4100 series.
  *
@@ -5,20 +6,6 @@
  *    Author: Yoichi Yuasa <source@mvista.com>
  *  Copyright (C) 2004-2008  Yoichi Yuasa <yuasa@linux-mips.org>
  *  Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
- *
- *  This program is free software; you can redistribute it and/or modify
- *  it under the terms of the GNU General Public License as published by
- *  the Free Software Foundation; either version 2 of the License, or
- *  (at your option) any later version.
- *
- *  This program is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *  GNU General Public License for more details.
- *
- *  You should have received a copy of the GNU General Public License
- *  along with this program; if not, write to the Free Software
- *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 /*
  * Changes:

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-vr41xx.c b/arch/mips/pci/pci-vr41xx.c
index 444b8d8004ad..157c7715b7c8 100644
--- a/arch/mips/pci/pci-vr41xx.c
+++ b/arch/mips/pci/pci-vr41xx.c
@@ -69,17 +69,17 @@ static struct pci_target_address_window pci_target_window1 = {
 };
 
 static struct resource pci_mem_resource = {
-	.name   = "PCI Memory resources",
-	.start  = PCI_MEM_RESOURCE_START,
-	.end    = PCI_MEM_RESOURCE_END,
-	.flags  = IORESOURCE_MEM,
+	.name	= "PCI Memory resources",
+	.start	= PCI_MEM_RESOURCE_START,
+	.end	= PCI_MEM_RESOURCE_END,
+	.flags	= IORESOURCE_MEM,
 };
 
 static struct resource pci_io_resource = {
-	.name   = "PCI I/O resources",
-	.start  = PCI_IO_RESOURCE_START,
-	.end    = PCI_IO_RESOURCE_END,
-	.flags  = IORESOURCE_IO,
+	.name	= "PCI I/O resources",
+	.start	= PCI_IO_RESOURCE_START,
+	.end	= PCI_IO_RESOURCE_END,
+	.flags	= IORESOURCE_IO,
 };
 
 static struct pci_controller_unit_setup vr41xx_pci_controller_unit_setup = {
@@ -97,7 +97,7 @@ static struct pci_controller_unit_setup vr41xx_pci_controller_unit_setup = {
 };
 
 static struct pci_controller vr41xx_pci_controller = {
-	.pci_ops        = &vr41xx_pci_ops,
+	.pci_ops	= &vr41xx_pci_ops,
 	.mem_resource	= &pci_mem_resource,
 	.io_resource	= &pci_io_resource,
 };
@@ -148,7 +148,7 @@ static int __init vr41xx_pciu_init(void)
 	else if ((vtclock / 2) < pci_clock_max)
 		pciu_write(PCICLKSELREG, HALF_VTCLOCK);
 	else if (current_cpu_data.processor_id >= PRID_VR4131_REV2_1 &&
-	         (vtclock / 3) < pci_clock_max)
+		 (vtclock / 3) < pci_clock_max)
 		pciu_write(PCICLKSELREG, ONE_THIRD_VTCLOCK);
 	else if ((vtclock / 4) < pci_clock_max)
 		pciu_write(PCICLKSELREG, QUARTER_VTCLOCK);
@@ -281,7 +281,7 @@ static int __init vr41xx_pciu_init(void)
 	pciu_write(PCIAPCNTREG, val);
 
 	pciu_write(COMMANDREG, PCI_COMMAND_IO | PCI_COMMAND_MEMORY |
-	                       PCI_COMMAND_MASTER | PCI_COMMAND_PARITY |
+			       PCI_COMMAND_MASTER | PCI_COMMAND_PARITY |
 			       PCI_COMMAND_SERR);
 
 	/* Clear bus error */

commit 28f65c11f2ffb3957259dece647a24f8ad2e241b
Author: Joe Perches <joe@perches.com>
Date:   Thu Jun 9 09:13:32 2011 -0700

    treewide: Convert uses of struct resource to resource_size(ptr)
    
    Several fixes as well where the +1 was missing.
    
    Done via coccinelle scripts like:
    
    @@
    struct resource *ptr;
    @@
    
    - ptr->end - ptr->start + 1
    + resource_size(ptr)
    
    and some grep and typing.
    
    Mostly uncompiled, no cross-compilers.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/arch/mips/pci/pci-vr41xx.c b/arch/mips/pci/pci-vr41xx.c
index 56525711f8b7..444b8d8004ad 100644
--- a/arch/mips/pci/pci-vr41xx.c
+++ b/arch/mips/pci/pci-vr41xx.c
@@ -305,7 +305,7 @@ static int __init vr41xx_pciu_init(void)
 		struct resource *res = vr41xx_pci_controller.io_resource;
 		master = setup->master_io;
 		io_map_base = ioremap(master->bus_base_address,
-				      res->end - res->start + 1);
+				      resource_size(res));
 		if (!io_map_base)
 			return -EBUSY;
 

commit ada8e9514b5880f81cdbbd212d121380ceef7acc
Author: Yoichi Yuasa <yuasa@linux-mips.org>
Date:   Fri Jul 3 00:39:38 2009 +0900

    Update Yoichi Yuasa's e-mail address
    
    Signed-off-by: Yoichi Yuasa <yuasa@linux-mips.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-vr41xx.c b/arch/mips/pci/pci-vr41xx.c
index d1e049b55f34..56525711f8b7 100644
--- a/arch/mips/pci/pci-vr41xx.c
+++ b/arch/mips/pci/pci-vr41xx.c
@@ -2,8 +2,8 @@
  *  pci-vr41xx.c, PCI Control Unit routines for the NEC VR4100 series.
  *
  *  Copyright (C) 2001-2003 MontaVista Software Inc.
- *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
- *  Copyright (C) 2004-2008  Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
+ *    Author: Yoichi Yuasa <source@mvista.com>
+ *  Copyright (C) 2004-2008  Yoichi Yuasa <yuasa@linux-mips.org>
  *  Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -22,7 +22,7 @@
  */
 /*
  * Changes:
- *  MontaVista Software Inc. <yyuasa@mvista.com> or <source@mvista.com>
+ *  MontaVista Software Inc. <source@mvista.com>
  *  - New creation, NEC VR4122 and VR4131 are supported.
  */
 #include <linux/init.h>

commit f1304b358a6c952e4cd1f92c8a6f183b1026c103
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Mon Jun 16 22:51:08 2008 +0900

    [MIPS] Vr41xx: Initialize PCI io_map_base
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-vr41xx.c b/arch/mips/pci/pci-vr41xx.c
index 33c4f683d067..d1e049b55f34 100644
--- a/arch/mips/pci/pci-vr41xx.c
+++ b/arch/mips/pci/pci-vr41xx.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2001-2003 MontaVista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
- *  Copyright (C) 2004-2005  Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
+ *  Copyright (C) 2004-2008  Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
  *  Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute it and/or modify
@@ -300,6 +300,18 @@ static int __init vr41xx_pciu_init(void)
 		ioport_resource.end = IO_PORT_RESOURCE_END;
 	}
 
+	if (setup->master_io) {
+		void __iomem *io_map_base;
+		struct resource *res = vr41xx_pci_controller.io_resource;
+		master = setup->master_io;
+		io_map_base = ioremap(master->bus_base_address,
+				      res->end - res->start + 1);
+		if (!io_map_base)
+			return -EBUSY;
+
+		vr41xx_pci_controller.io_map_base = (unsigned long)io_map_base;
+	}
+
 	register_pci_controller(&vr41xx_pci_controller);
 
 	return 0;

commit bb856c5b494049584eca61c6069eb8e1b0f9ce35
Author: Roel Kluin <12o3l@tiscali.nl>
Date:   Sun Nov 4 13:00:06 2007 +0100

    [MIPS] iounmap if in vr41xx_pciu_init() pci clock is over 33MHz
    
    iounmap if pci clock is over 33MHz.  Cosmetic because the iomap() in this
    case is just a bit of address magic.
    
    Signed-off-by: Roel Kluin <12o3l@tiscali.nl>
    Acked-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-vr41xx.c b/arch/mips/pci/pci-vr41xx.c
index 240df9e33813..33c4f683d067 100644
--- a/arch/mips/pci/pci-vr41xx.c
+++ b/arch/mips/pci/pci-vr41xx.c
@@ -154,6 +154,7 @@ static int __init vr41xx_pciu_init(void)
 		pciu_write(PCICLKSELREG, QUARTER_VTCLOCK);
 	else {
 		printk(KERN_ERR "PCI Clock is over 33MHz.\n");
+		iounmap(pciu_base);
 		return -EINVAL;
 	}
 

commit 10cc3529072d5415fb040018a8a99aa7a60190b6
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:15 2007 +0100

    [MIPS] Allow hardwiring of the CPU type to a single type for optimization.
    
    This saves a few k on systems which only ever ship with a single CPU type.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-vr41xx.c b/arch/mips/pci/pci-vr41xx.c
index 9885fa403603..240df9e33813 100644
--- a/arch/mips/pci/pci-vr41xx.c
+++ b/arch/mips/pci/pci-vr41xx.c
@@ -228,7 +228,7 @@ static int __init vr41xx_pciu_init(void)
 	else
 		pciu_write(PCIEXACCREG, 0);
 
-	if (current_cpu_data.cputype == CPU_VR4122)
+	if (current_cpu_type() == CPU_VR4122)
 		pciu_write(PCITRDYVREG, TRDYV(setup->wait_time_limit_from_irdy_to_trdy));
 
 	pciu_write(LATTIMEREG, MLTIM(setup->master_latency_timer));

commit 29ce2c765ca9a41be6f31aa1770e8ee3ee48cd21
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Dec 12 20:11:50 2005 +0000

    Update Yoichi Yuasa's email address.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-vr41xx.c b/arch/mips/pci/pci-vr41xx.c
index 91df4da7ddb9..9885fa403603 100644
--- a/arch/mips/pci/pci-vr41xx.c
+++ b/arch/mips/pci/pci-vr41xx.c
@@ -3,7 +3,7 @@
  *
  *  Copyright (C) 2001-2003 MontaVista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
- *  Copyright (C) 2004-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2004-2005  Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
  *  Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute it and/or modify

commit 5dfa9c1b4f5d399a2800d8486ca188988900db87
Author: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
Date:   Sat Apr 16 15:24:40 2005 -0700

    [PATCH] mips: update VR41xx CPU-PCI bridge support
    
    This patch updates NEC VR4100 series CPU-PCI bridge support.
    
    Signed-off-by: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/pci/pci-vr41xx.c b/arch/mips/pci/pci-vr41xx.c
index f3ccbf7fada4..91df4da7ddb9 100644
--- a/arch/mips/pci/pci-vr41xx.c
+++ b/arch/mips/pci/pci-vr41xx.c
@@ -3,8 +3,8 @@
  *
  *  Copyright (C) 2001-2003 MontaVista Software Inc.
  *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
- *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
- * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
+ *  Copyright (C) 2004-2005  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ *  Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can redistribute it and/or modify
  *  it under the terms of the GNU General Public License as published by
@@ -31,12 +31,18 @@
 
 #include <asm/cpu.h>
 #include <asm/io.h>
+#include <asm/vr41xx/pci.h>
 #include <asm/vr41xx/vr41xx.h>
 
 #include "pci-vr41xx.h"
 
 extern struct pci_ops vr41xx_pci_ops;
 
+static void __iomem *pciu_base;
+
+#define pciu_read(offset)		readl(pciu_base + (offset))
+#define pciu_write(offset, value)	writel((value), pciu_base + (offset))
+
 static struct pci_master_address_conversion pci_master_memory1 = {
 	.bus_base_address	= PCI_MASTER_MEM1_BUS_BASE_ADDRESS,
 	.address_mask		= PCI_MASTER_MEM1_ADDRESS_MASK,
@@ -113,6 +119,15 @@ static int __init vr41xx_pciu_init(void)
 
 	setup = &vr41xx_pci_controller_unit_setup;
 
+	if (request_mem_region(PCIU_BASE, PCIU_SIZE, "PCIU") == NULL)
+		return -EBUSY;
+
+	pciu_base = ioremap(PCIU_BASE, PCIU_SIZE);
+	if (pciu_base == NULL) {
+		release_mem_region(PCIU_BASE, PCIU_SIZE);
+		return -EBUSY;
+	}
+
 	/* Disable PCI interrupt */
 	vr41xx_disable_pciint();
 
@@ -129,14 +144,14 @@ static int __init vr41xx_pciu_init(void)
 		pci_clock_max = PCI_CLOCK_MAX;
 	vtclock = vr41xx_get_vtclock_frequency();
 	if (vtclock < pci_clock_max)
-		writel(EQUAL_VTCLOCK, PCICLKSELREG);
+		pciu_write(PCICLKSELREG, EQUAL_VTCLOCK);
 	else if ((vtclock / 2) < pci_clock_max)
-		writel(HALF_VTCLOCK, PCICLKSELREG);
+		pciu_write(PCICLKSELREG, HALF_VTCLOCK);
 	else if (current_cpu_data.processor_id >= PRID_VR4131_REV2_1 &&
 	         (vtclock / 3) < pci_clock_max)
-		writel(ONE_THIRD_VTCLOCK, PCICLKSELREG);
+		pciu_write(PCICLKSELREG, ONE_THIRD_VTCLOCK);
 	else if ((vtclock / 4) < pci_clock_max)
-		writel(QUARTER_VTCLOCK, PCICLKSELREG);
+		pciu_write(PCICLKSELREG, QUARTER_VTCLOCK);
 	else {
 		printk(KERN_ERR "PCI Clock is over 33MHz.\n");
 		return -EINVAL;
@@ -151,11 +166,11 @@ static int __init vr41xx_pciu_init(void)
 		      MASTER_MSK(master->address_mask) |
 		      WINEN |
 		      PCIA(master->pci_base_address);
-		writel(val, PCIMMAW1REG);
+		pciu_write(PCIMMAW1REG, val);
 	} else {
-		val = readl(PCIMMAW1REG);
+		val = pciu_read(PCIMMAW1REG);
 		val &= ~WINEN;
-		writel(val, PCIMMAW1REG);
+		pciu_write(PCIMMAW1REG, val);
 	}
 
 	if (setup->master_memory2 != NULL) {
@@ -164,11 +179,11 @@ static int __init vr41xx_pciu_init(void)
 		      MASTER_MSK(master->address_mask) |
 		      WINEN |
 		      PCIA(master->pci_base_address);
-		writel(val, PCIMMAW2REG);
+		pciu_write(PCIMMAW2REG, val);
 	} else {
-		val = readl(PCIMMAW2REG);
+		val = pciu_read(PCIMMAW2REG);
 		val &= ~WINEN;
-		writel(val, PCIMMAW2REG);
+		pciu_write(PCIMMAW2REG, val);
 	}
 
 	if (setup->target_memory1 != NULL) {
@@ -176,11 +191,11 @@ static int __init vr41xx_pciu_init(void)
 		val = TARGET_MSK(target->address_mask) |
 		      WINEN |
 		      ITA(target->bus_base_address);
-		writel(val, PCITAW1REG);
+		pciu_write(PCITAW1REG, val);
 	} else {
-		val = readl(PCITAW1REG);
+		val = pciu_read(PCITAW1REG);
 		val &= ~WINEN;
-		writel(val, PCITAW1REG);
+		pciu_write(PCITAW1REG, val);
 	}
 
 	if (setup->target_memory2 != NULL) {
@@ -188,11 +203,11 @@ static int __init vr41xx_pciu_init(void)
 		val = TARGET_MSK(target->address_mask) |
 		      WINEN |
 		      ITA(target->bus_base_address);
-		writel(val, PCITAW2REG);
+		pciu_write(PCITAW2REG, val);
 	} else {
-		val = readl(PCITAW2REG);
+		val = pciu_read(PCITAW2REG);
 		val &= ~WINEN;
-		writel(val, PCITAW2REG);
+		pciu_write(PCITAW2REG, val);
 	}
 
 	if (setup->master_io != NULL) {
@@ -201,50 +216,50 @@ static int __init vr41xx_pciu_init(void)
 		      MASTER_MSK(master->address_mask) |
 		      WINEN |
 		      PCIIA(master->pci_base_address);
-		writel(val, PCIMIOAWREG);
+		pciu_write(PCIMIOAWREG, val);
 	} else {
-		val = readl(PCIMIOAWREG);
+		val = pciu_read(PCIMIOAWREG);
 		val &= ~WINEN;
-		writel(val, PCIMIOAWREG);
+		pciu_write(PCIMIOAWREG, val);
 	}
 
 	if (setup->exclusive_access == CANNOT_LOCK_FROM_DEVICE)
-		writel(UNLOCK, PCIEXACCREG);
+		pciu_write(PCIEXACCREG, UNLOCK);
 	else
-		writel(0, PCIEXACCREG);
+		pciu_write(PCIEXACCREG, 0);
 
 	if (current_cpu_data.cputype == CPU_VR4122)
-		writel(TRDYV(setup->wait_time_limit_from_irdy_to_trdy), PCITRDYVREG);
+		pciu_write(PCITRDYVREG, TRDYV(setup->wait_time_limit_from_irdy_to_trdy));
 
-	writel(MLTIM(setup->master_latency_timer), LATTIMEREG);
+	pciu_write(LATTIMEREG, MLTIM(setup->master_latency_timer));
 
 	if (setup->mailbox != NULL) {
 		mailbox = setup->mailbox;
 		val = MBADD(mailbox->base_address) | TYPE_32BITSPACE |
 		      MSI_MEMORY | PREF_APPROVAL;
-		writel(val, MAILBAREG);
+		pciu_write(MAILBAREG, val);
 	}
 
 	if (setup->target_window1) {
 		window = setup->target_window1;
 		val = PMBA(window->base_address) | TYPE_32BITSPACE |
 		      MSI_MEMORY | PREF_APPROVAL;
-		writel(val, PCIMBA1REG);
+		pciu_write(PCIMBA1REG, val);
 	}
 
 	if (setup->target_window2) {
 		window = setup->target_window2;
 		val = PMBA(window->base_address) | TYPE_32BITSPACE |
 		      MSI_MEMORY | PREF_APPROVAL;
-		writel(val, PCIMBA2REG);
+		pciu_write(PCIMBA2REG, val);
 	}
 
-	val = readl(RETVALREG);
+	val = pciu_read(RETVALREG);
 	val &= ~RTYVAL_MASK;
 	val |= RTYVAL(setup->retry_limit);
-	writel(val, RETVALREG);
+	pciu_write(RETVALREG, val);
 
-	val = readl(PCIAPCNTREG);
+	val = pciu_read(PCIAPCNTREG);
 	val &= ~(TKYGNT | PAPC);
 
 	switch (setup->arbiter_priority_control) {
@@ -262,15 +277,16 @@ static int __init vr41xx_pciu_init(void)
 	if (setup->take_away_gnt_mode == PCI_TAKE_AWAY_GNT_ENABLE)
 		val |= TKYGNT_ENABLE;
 
-	writel(val, PCIAPCNTREG);
+	pciu_write(PCIAPCNTREG, val);
 
-	writel(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |
-	       PCI_COMMAND_PARITY | PCI_COMMAND_SERR, COMMANDREG);
+	pciu_write(COMMANDREG, PCI_COMMAND_IO | PCI_COMMAND_MEMORY |
+	                       PCI_COMMAND_MASTER | PCI_COMMAND_PARITY |
+			       PCI_COMMAND_SERR);
 
 	/* Clear bus error */
-	readl(BUSERRADREG);
+	pciu_read(BUSERRADREG);
 
-	writel(BLOODY_CONFIG_DONE, PCIENREG);
+	pciu_write(PCIENREG, PCIU_CONFIG_DONE);
 
 	if (setup->mem_resource != NULL)
 		vr41xx_pci_controller.mem_resource = setup->mem_resource;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/pci/pci-vr41xx.c b/arch/mips/pci/pci-vr41xx.c
new file mode 100644
index 000000000000..f3ccbf7fada4
--- /dev/null
+++ b/arch/mips/pci/pci-vr41xx.c
@@ -0,0 +1,291 @@
+/*
+ *  pci-vr41xx.c, PCI Control Unit routines for the NEC VR4100 series.
+ *
+ *  Copyright (C) 2001-2003 MontaVista Software Inc.
+ *    Author: Yoichi Yuasa <yyuasa@mvista.com or source@mvista.com>
+ *  Copyright (C) 2004  Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
+ * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation; either version 2 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program; if not, write to the Free Software
+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+/*
+ * Changes:
+ *  MontaVista Software Inc. <yyuasa@mvista.com> or <source@mvista.com>
+ *  - New creation, NEC VR4122 and VR4131 are supported.
+ */
+#include <linux/init.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+
+#include <asm/cpu.h>
+#include <asm/io.h>
+#include <asm/vr41xx/vr41xx.h>
+
+#include "pci-vr41xx.h"
+
+extern struct pci_ops vr41xx_pci_ops;
+
+static struct pci_master_address_conversion pci_master_memory1 = {
+	.bus_base_address	= PCI_MASTER_MEM1_BUS_BASE_ADDRESS,
+	.address_mask		= PCI_MASTER_MEM1_ADDRESS_MASK,
+	.pci_base_address	= PCI_MASTER_MEM1_PCI_BASE_ADDRESS,
+};
+
+static struct pci_target_address_conversion pci_target_memory1 = {
+	.address_mask		= PCI_TARGET_MEM1_ADDRESS_MASK,
+	.bus_base_address	= PCI_TARGET_MEM1_BUS_BASE_ADDRESS,
+};
+
+static struct pci_master_address_conversion pci_master_io = {
+	.bus_base_address	= PCI_MASTER_IO_BUS_BASE_ADDRESS,
+	.address_mask		= PCI_MASTER_IO_ADDRESS_MASK,
+	.pci_base_address	= PCI_MASTER_IO_PCI_BASE_ADDRESS,
+};
+
+static struct pci_mailbox_address pci_mailbox = {
+	.base_address		= PCI_MAILBOX_BASE_ADDRESS,
+};
+
+static struct pci_target_address_window pci_target_window1 = {
+	.base_address		= PCI_TARGET_WINDOW1_BASE_ADDRESS,
+};
+
+static struct resource pci_mem_resource = {
+	.name   = "PCI Memory resources",
+	.start  = PCI_MEM_RESOURCE_START,
+	.end    = PCI_MEM_RESOURCE_END,
+	.flags  = IORESOURCE_MEM,
+};
+
+static struct resource pci_io_resource = {
+	.name   = "PCI I/O resources",
+	.start  = PCI_IO_RESOURCE_START,
+	.end    = PCI_IO_RESOURCE_END,
+	.flags  = IORESOURCE_IO,
+};
+
+static struct pci_controller_unit_setup vr41xx_pci_controller_unit_setup = {
+	.master_memory1				= &pci_master_memory1,
+	.target_memory1				= &pci_target_memory1,
+	.master_io				= &pci_master_io,
+	.exclusive_access			= CANNOT_LOCK_FROM_DEVICE,
+	.wait_time_limit_from_irdy_to_trdy	= 0,
+	.mailbox				= &pci_mailbox,
+	.target_window1				= &pci_target_window1,
+	.master_latency_timer			= 0x80,
+	.retry_limit				= 0,
+	.arbiter_priority_control		= PCI_ARBITRATION_MODE_FAIR,
+	.take_away_gnt_mode			= PCI_TAKE_AWAY_GNT_DISABLE,
+};
+
+static struct pci_controller vr41xx_pci_controller = {
+	.pci_ops        = &vr41xx_pci_ops,
+	.mem_resource	= &pci_mem_resource,
+	.io_resource	= &pci_io_resource,
+};
+
+void __init vr41xx_pciu_setup(struct pci_controller_unit_setup *setup)
+{
+	vr41xx_pci_controller_unit_setup = *setup;
+}
+
+static int __init vr41xx_pciu_init(void)
+{
+	struct pci_controller_unit_setup *setup;
+	struct pci_master_address_conversion *master;
+	struct pci_target_address_conversion *target;
+	struct pci_mailbox_address *mailbox;
+	struct pci_target_address_window *window;
+	unsigned long vtclock, pci_clock_max;
+	uint32_t val;
+
+	setup = &vr41xx_pci_controller_unit_setup;
+
+	/* Disable PCI interrupt */
+	vr41xx_disable_pciint();
+
+	/* Supply VTClock to PCIU */
+	vr41xx_supply_clock(PCIU_CLOCK);
+
+	/* Dummy write, waiting for supply of VTClock. */
+	vr41xx_disable_pciint();
+
+	/* Select PCI clock */
+	if (setup->pci_clock_max != 0)
+		pci_clock_max = setup->pci_clock_max;
+	else
+		pci_clock_max = PCI_CLOCK_MAX;
+	vtclock = vr41xx_get_vtclock_frequency();
+	if (vtclock < pci_clock_max)
+		writel(EQUAL_VTCLOCK, PCICLKSELREG);
+	else if ((vtclock / 2) < pci_clock_max)
+		writel(HALF_VTCLOCK, PCICLKSELREG);
+	else if (current_cpu_data.processor_id >= PRID_VR4131_REV2_1 &&
+	         (vtclock / 3) < pci_clock_max)
+		writel(ONE_THIRD_VTCLOCK, PCICLKSELREG);
+	else if ((vtclock / 4) < pci_clock_max)
+		writel(QUARTER_VTCLOCK, PCICLKSELREG);
+	else {
+		printk(KERN_ERR "PCI Clock is over 33MHz.\n");
+		return -EINVAL;
+	}
+
+	/* Supply PCI clock by PCI bus */
+	vr41xx_supply_clock(PCI_CLOCK);
+
+	if (setup->master_memory1 != NULL) {
+		master = setup->master_memory1;
+		val = IBA(master->bus_base_address) |
+		      MASTER_MSK(master->address_mask) |
+		      WINEN |
+		      PCIA(master->pci_base_address);
+		writel(val, PCIMMAW1REG);
+	} else {
+		val = readl(PCIMMAW1REG);
+		val &= ~WINEN;
+		writel(val, PCIMMAW1REG);
+	}
+
+	if (setup->master_memory2 != NULL) {
+		master = setup->master_memory2;
+		val = IBA(master->bus_base_address) |
+		      MASTER_MSK(master->address_mask) |
+		      WINEN |
+		      PCIA(master->pci_base_address);
+		writel(val, PCIMMAW2REG);
+	} else {
+		val = readl(PCIMMAW2REG);
+		val &= ~WINEN;
+		writel(val, PCIMMAW2REG);
+	}
+
+	if (setup->target_memory1 != NULL) {
+		target = setup->target_memory1;
+		val = TARGET_MSK(target->address_mask) |
+		      WINEN |
+		      ITA(target->bus_base_address);
+		writel(val, PCITAW1REG);
+	} else {
+		val = readl(PCITAW1REG);
+		val &= ~WINEN;
+		writel(val, PCITAW1REG);
+	}
+
+	if (setup->target_memory2 != NULL) {
+		target = setup->target_memory2;
+		val = TARGET_MSK(target->address_mask) |
+		      WINEN |
+		      ITA(target->bus_base_address);
+		writel(val, PCITAW2REG);
+	} else {
+		val = readl(PCITAW2REG);
+		val &= ~WINEN;
+		writel(val, PCITAW2REG);
+	}
+
+	if (setup->master_io != NULL) {
+		master = setup->master_io;
+		val = IBA(master->bus_base_address) |
+		      MASTER_MSK(master->address_mask) |
+		      WINEN |
+		      PCIIA(master->pci_base_address);
+		writel(val, PCIMIOAWREG);
+	} else {
+		val = readl(PCIMIOAWREG);
+		val &= ~WINEN;
+		writel(val, PCIMIOAWREG);
+	}
+
+	if (setup->exclusive_access == CANNOT_LOCK_FROM_DEVICE)
+		writel(UNLOCK, PCIEXACCREG);
+	else
+		writel(0, PCIEXACCREG);
+
+	if (current_cpu_data.cputype == CPU_VR4122)
+		writel(TRDYV(setup->wait_time_limit_from_irdy_to_trdy), PCITRDYVREG);
+
+	writel(MLTIM(setup->master_latency_timer), LATTIMEREG);
+
+	if (setup->mailbox != NULL) {
+		mailbox = setup->mailbox;
+		val = MBADD(mailbox->base_address) | TYPE_32BITSPACE |
+		      MSI_MEMORY | PREF_APPROVAL;
+		writel(val, MAILBAREG);
+	}
+
+	if (setup->target_window1) {
+		window = setup->target_window1;
+		val = PMBA(window->base_address) | TYPE_32BITSPACE |
+		      MSI_MEMORY | PREF_APPROVAL;
+		writel(val, PCIMBA1REG);
+	}
+
+	if (setup->target_window2) {
+		window = setup->target_window2;
+		val = PMBA(window->base_address) | TYPE_32BITSPACE |
+		      MSI_MEMORY | PREF_APPROVAL;
+		writel(val, PCIMBA2REG);
+	}
+
+	val = readl(RETVALREG);
+	val &= ~RTYVAL_MASK;
+	val |= RTYVAL(setup->retry_limit);
+	writel(val, RETVALREG);
+
+	val = readl(PCIAPCNTREG);
+	val &= ~(TKYGNT | PAPC);
+
+	switch (setup->arbiter_priority_control) {
+	case PCI_ARBITRATION_MODE_ALTERNATE_0:
+		val |= PAPC_ALTERNATE_0;
+		break;
+	case PCI_ARBITRATION_MODE_ALTERNATE_B:
+		val |= PAPC_ALTERNATE_B;
+		break;
+	default:
+		val |= PAPC_FAIR;
+		break;
+	}
+
+	if (setup->take_away_gnt_mode == PCI_TAKE_AWAY_GNT_ENABLE)
+		val |= TKYGNT_ENABLE;
+
+	writel(val, PCIAPCNTREG);
+
+	writel(PCI_COMMAND_IO | PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER |
+	       PCI_COMMAND_PARITY | PCI_COMMAND_SERR, COMMANDREG);
+
+	/* Clear bus error */
+	readl(BUSERRADREG);
+
+	writel(BLOODY_CONFIG_DONE, PCIENREG);
+
+	if (setup->mem_resource != NULL)
+		vr41xx_pci_controller.mem_resource = setup->mem_resource;
+
+	if (setup->io_resource != NULL) {
+		vr41xx_pci_controller.io_resource = setup->io_resource;
+	} else {
+		set_io_port_base(IO_PORT_BASE);
+		ioport_resource.start = IO_PORT_RESOURCE_START;
+		ioport_resource.end = IO_PORT_RESOURCE_END;
+	}
+
+	register_pci_controller(&vr41xx_pci_controller);
+
+	return 0;
+}
+
+arch_initcall(vr41xx_pciu_init);
