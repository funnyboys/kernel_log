commit d2912cb15bdda8ba4a5dd73396ad62641af2f520
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue Jun 4 10:11:33 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 500
    
    Based on 2 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation #
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 4122 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Enrico Weigelt <info@metux.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190604081206.933168790@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 64b58cc48a91..869d5c9a2f8d 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -1,12 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Atheros AR724X PCI host controller driver
  *
  *  Copyright (C) 2011 Ren√© Bolldorf <xsecute@googlemail.com>
  *  Copyright (C) 2009-2011 Gabor Juhos <juhosg@openwrt.org>
- *
- *  This program is free software; you can redistribute it and/or modify it
- *  under the terms of the GNU General Public License version 2 as published
- *  by the Free Software Foundation.
  */
 
 #include <linux/irq.h>

commit 0316b05311e777f8044c72a88b966ebae7c7a39f
Author: Mathias Kresin <dev@kresin.me>
Date:   Fri Jul 20 13:58:25 2018 +0200

    MIPS: ath79: get PCIe controller out of reset
    
    The ar724x pci driver expects the PCIe controller to be brought out of
    reset by the bootloader.
    
    At least the AVM Fritz 300E bootloader doesn't take care of releasing
    the different PCIe controller related resets which causes an endless
    hang as soon as either the PCIE Reset register (0x180f0018) or the PCI
    Application Control register (0x180f0000) is read from.
    
    Do the full "PCIE Root Complex Initialization Sequence" if the PCIe
    host controller is still in reset during probing.
    
    The QCA u-boot sleeps 10ms after the PCIE Application Control bit is
    set to ready. It has been shown that 10ms might not be enough time if
    PCIe should be used right after setting the bit. During my tests it
    took up to 20ms till the link was up. Giving the link up to 100ms
    should work for all cases.
    
    Signed-off-by: Mathias Kresin <dev@kresin.me>
    Signed-off-by: John Crispin <john@phrozen.org>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/19916/
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 1e23c8d587bd..64b58cc48a91 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -12,14 +12,18 @@
 #include <linux/irq.h>
 #include <linux/pci.h>
 #include <linux/init.h>
+#include <linux/delay.h>
 #include <linux/platform_device.h>
 #include <asm/mach-ath79/ath79.h>
 #include <asm/mach-ath79/ar71xx_regs.h>
 
+#define AR724X_PCI_REG_APP		0x00
 #define AR724X_PCI_REG_RESET		0x18
 #define AR724X_PCI_REG_INT_STATUS	0x4c
 #define AR724X_PCI_REG_INT_MASK		0x50
 
+#define AR724X_PCI_APP_LTSSM_ENABLE	BIT(0)
+
 #define AR724X_PCI_RESET_LINK_UP	BIT(0)
 
 #define AR724X_PCI_INT_DEV0		BIT(14)
@@ -325,6 +329,37 @@ static void ar724x_pci_irq_init(struct ar724x_pci_controller *apc,
 					 apc);
 }
 
+static void ar724x_pci_hw_init(struct ar724x_pci_controller *apc)
+{
+	u32 ppl, app;
+	int wait = 0;
+
+	/* deassert PCIe host controller and PCIe PHY reset */
+	ath79_device_reset_clear(AR724X_RESET_PCIE);
+	ath79_device_reset_clear(AR724X_RESET_PCIE_PHY);
+
+	/* remove the reset of the PCIE PLL */
+	ppl = ath79_pll_rr(AR724X_PLL_REG_PCIE_CONFIG);
+	ppl &= ~AR724X_PLL_REG_PCIE_CONFIG_PPL_RESET;
+	ath79_pll_wr(AR724X_PLL_REG_PCIE_CONFIG, ppl);
+
+	/* deassert bypass for the PCIE PLL */
+	ppl = ath79_pll_rr(AR724X_PLL_REG_PCIE_CONFIG);
+	ppl &= ~AR724X_PLL_REG_PCIE_CONFIG_PPL_BYPASS;
+	ath79_pll_wr(AR724X_PLL_REG_PCIE_CONFIG, ppl);
+
+	/* set PCIE Application Control to ready */
+	app = __raw_readl(apc->ctrl_base + AR724X_PCI_REG_APP);
+	app |= AR724X_PCI_APP_LTSSM_ENABLE;
+	__raw_writel(app, apc->ctrl_base + AR724X_PCI_REG_APP);
+
+	/* wait up to 100ms for PHY link up */
+	do {
+		mdelay(10);
+		wait++;
+	} while (wait < 10 && !ar724x_pci_check_link(apc));
+}
+
 static int ar724x_pci_probe(struct platform_device *pdev)
 {
 	struct ar724x_pci_controller *apc;
@@ -383,6 +418,13 @@ static int ar724x_pci_probe(struct platform_device *pdev)
 	apc->pci_controller.io_resource = &apc->io_res;
 	apc->pci_controller.mem_resource = &apc->mem_res;
 
+	/*
+	 * Do the full PCIE Root Complex Initialization Sequence if the PCIe
+	 * host controller is in reset.
+	 */
+	if (ath79_reset_rr(AR724X_RESET_REG_RESET_MODULE) & AR724X_RESET_PCIE)
+		ar724x_pci_hw_init(apc);
+
 	apc->link_up = ar724x_pci_check_link(apc);
 	if (!apc->link_up)
 		dev_warn(&pdev->dev, "PCIe link is down\n");

commit 2722090af4f8988ecce1b22c667fa03ee0f473ca
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sun Aug 21 15:58:16 2016 -0400

    MIPS: pci: Audit and remove any unnecessary uses of module.h
    
    Historically a lot of these existed because we did not have
    a distinction between what was modular code and what was providing
    support to modules via EXPORT_SYMBOL and friends.  That changed
    when we forked out support for the latter into the export.h file.
    
    This means we should be able to reduce the usage of module.h
    in code that is obj-y Makefile or bool Kconfig.  The advantage
    in doing so is that module.h itself sources about 15 other headers;
    adding significantly to what we feed cpp, and it can obscure what
    headers we are effectively using.
    
    Since module.h was the source for init.h (for __init) and for
    export.h (for EXPORT_SYMBOL) we consider each obj-y/bool instance
    for the presence of either and replace as needed.
    
    We also needed to remove the no-op MODULE_DEVICE_TABLE usage in
    several instances to permit removal of the module.h include.  The
    files in these instances were all controlled by bool Kconfig.
    
    In one instance, module_param was being used so we transition the
    module.h include onto a moduleparam.h include.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14035/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 2013dad700df..1e23c8d587bd 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -11,7 +11,7 @@
 
 #include <linux/irq.h>
 #include <linux/pci.h>
-#include <linux/module.h>
+#include <linux/init.h>
 #include <linux/platform_device.h>
 #include <asm/mach-ath79/ath79.h>
 #include <asm/mach-ath79/ar71xx_regs.h>

commit bd0b9ac405e1794d72533c3d487aa65b6b955a0c
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Sep 14 10:42:37 2015 +0200

    genirq: Remove irq argument from irq flow handlers
    
    Most interrupt flow handlers do not use the irq argument. Those few
    which use it can retrieve the irq number from the irq descriptor.
    
    Remove the argument.
    
    Search and replace was done with coccinelle and some extra helper
    scripts around it. Thanks to Julia for her help!
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 907d11dd921b..2013dad700df 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -225,7 +225,7 @@ static struct pci_ops ar724x_pci_ops = {
 	.write	= ar724x_pci_write,
 };
 
-static void ar724x_pci_irq_handler(unsigned int irq, struct irq_desc *desc)
+static void ar724x_pci_irq_handler(struct irq_desc *desc)
 {
 	struct ar724x_pci_controller *apc;
 	void __iomem *base;

commit 4d3f77d855090e11c9823fcb00864745adaf6fae
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Jul 13 20:45:56 2015 +0000

    MIPS: pci-ar724x: Consolidate chained IRQ handler install/remove
    
    Chained irq handlers usually set up handler data as well. We now have
    a function to set both under irq_desc->lock. Replace the two calls
    with one.
    
    Search and conversion was done with coccinelle.
    
    Reported-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Julia Lawall <Julia.Lawall@lip6.fr>
    Cc: linux-mips@linux-mips.org
    Cc: LKML <linux-kernel@vger.kernel.org>
    Cc: Jiang Liu <jiang.liu@linux.intel.com>
    Patchwork: https://patchwork.linux-mips.org/patch/10697/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 0af362b5af92..907d11dd921b 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -321,8 +321,8 @@ static void ar724x_pci_irq_init(struct ar724x_pci_controller *apc,
 		irq_set_chip_data(i, apc);
 	}
 
-	irq_set_handler_data(apc->irq, apc);
-	irq_set_chained_handler(apc->irq, ar724x_pci_irq_handler);
+	irq_set_chained_handler_and_data(apc->irq, ar724x_pci_irq_handler,
+					 apc);
 }
 
 static int ar724x_pci_probe(struct platform_device *pdev)

commit 25aae561373280ab0c18d81d0ef9301aee4f5988
Author: Jiang Liu <jiang.liu@linux.intel.com>
Date:   Wed May 20 17:59:51 2015 +0800

    MIPS, IRQ: Use irq_desc_get_xxx() to avoid redundant lookup of irq_desc
    
    Use irq_desc_get_xxx() to avoid redundant lookup of irq_desc while we
    already have a pointer to corresponding irq_desc.
    
    Signed-off-by: Jiang Liu <jiang.liu@linux.intel.com>
    Acked-by: Sergey Ryazanov <ryazanov.s.a@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Rafael J. Wysocki <rjw@rjwysocki.net>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Aleksey Makarov <aleksey.makarov@auriga.com>
    Cc: David Daney <david.daney@cavium.com>
    Cc: Christoph Lameter <cl@linux.com>
    Cc: John Crispin <blogic@openwrt.org>
    Cc: Andrew Bresticker <abrestic@chromium.org>
    Cc: Konrad Rzeszutek Wilk <konrad.wilk@oracle.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: x86@kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-pci@vger.kernel.org
    Cc: linux-acpi@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/10086/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index a1b7d2a1b0d5..0af362b5af92 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -231,7 +231,7 @@ static void ar724x_pci_irq_handler(unsigned int irq, struct irq_desc *desc)
 	void __iomem *base;
 	u32 pending;
 
-	apc = irq_get_handler_data(irq);
+	apc = irq_desc_get_handler_data(desc);
 	base = apc->ctrl_base;
 
 	pending = __raw_readl(base + AR724X_PCI_REG_INT_STATUS) &

commit e6b5be2be4e30037eb551e0ed09dd97bd00d85d3
Merge: 37da7bbbe84f f1c488a78d9f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Dec 14 16:10:09 2014 -0800

    Merge tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core
    
    Pull driver core update from Greg KH:
     "Here's the set of driver core patches for 3.19-rc1.
    
      They are dominated by the removal of the .owner field in platform
      drivers.  They touch a lot of files, but they are "simple" changes,
      just removing a line in a structure.
    
      Other than that, a few minor driver core and debugfs changes.  There
      are some ath9k patches coming in through this tree that have been
      acked by the wireless maintainers as they relied on the debugfs
      changes.
    
      Everything has been in linux-next for a while"
    
    * tag 'driver-core-3.19-rc1' of git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core: (324 commits)
      Revert "ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries"
      fs: debugfs: add forward declaration for struct device type
      firmware class: Deletion of an unnecessary check before the function call "vunmap"
      firmware loader: fix hung task warning dump
      devcoredump: provide a one-way disable function
      device: Add dev_<level>_once variants
      ath: ath9k: use debugfs_create_devm_seqfile() helper for seq_file entries
      ath: use seq_file api for ath9k debugfs files
      debugfs: add helper function to create device related seq_file
      drivers/base: cacheinfo: remove noisy error boot message
      Revert "core: platform: add warning if driver has no owner"
      drivers: base: support cpu cache information interface to userspace via sysfs
      drivers: base: add cpu_device_create to support per-cpu devices
      topology: replace custom attribute macros with standard DEVICE_ATTR*
      cpumask: factor out show_cpumap into separate helper function
      driver core: Fix unbalanced device reference in drivers_probe
      driver core: fix race with userland in device_add()
      sysfs/kernfs: make read requests on pre-alloc files use the buffer.
      sysfs/kernfs: allow attributes to request write buffer be pre-allocated.
      fs: sysfs: return EGBIG on write if offset is larger than file size
      ...

commit 490a0ece6c9d7c39c1e6b523ee488f1c913aace7
Author: Sergey Ryazanov <ryazanov.s.a@gmail.com>
Date:   Sat Aug 30 06:06:26 2014 +0400

    MIPS: pci-ar7{1x, 24}x: remove odd locking in PCI config space access code
    
    Caller (generic PCI code) already do proper locking so no need to add
    another one here.
    
    Signed-off-by: Sergey Ryazanov <ryazanov.s.a@gmail.com>
    Cc: Linux MIPS <linux-mips@linux-mips.org>
    Cc: Gabor Juhos <juhosg@openwrt.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7602/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 785b2659b519..b7a6fcbb8852 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -9,7 +9,6 @@
  *  by the Free Software Foundation.
  */
 
-#include <linux/spinlock.h>
 #include <linux/irq.h>
 #include <linux/pci.h>
 #include <linux/module.h>
@@ -48,8 +47,6 @@ struct ar724x_pci_controller {
 	bool bar0_is_cached;
 	u32  bar0_value;
 
-	spinlock_t lock;
-
 	struct pci_controller pci_controller;
 	struct resource io_res;
 	struct resource mem_res;
@@ -75,7 +72,6 @@ pci_bus_to_ar724x_controller(struct pci_bus *bus)
 static int ar724x_pci_local_write(struct ar724x_pci_controller *apc,
 				  int where, int size, u32 value)
 {
-	unsigned long flags;
 	void __iomem *base;
 	u32 data;
 	int s;
@@ -86,8 +82,6 @@ static int ar724x_pci_local_write(struct ar724x_pci_controller *apc,
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	base = apc->crp_base;
-
-	spin_lock_irqsave(&apc->lock, flags);
 	data = __raw_readl(base + (where & ~3));
 
 	switch (size) {
@@ -105,14 +99,12 @@ static int ar724x_pci_local_write(struct ar724x_pci_controller *apc,
 		data = value;
 		break;
 	default:
-		spin_unlock_irqrestore(&apc->lock, flags);
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 	}
 
 	__raw_writel(data, base + (where & ~3));
 	/* flush write */
 	__raw_readl(base + (where & ~3));
-	spin_unlock_irqrestore(&apc->lock, flags);
 
 	return PCIBIOS_SUCCESSFUL;
 }
@@ -121,7 +113,6 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 			    int size, uint32_t *value)
 {
 	struct ar724x_pci_controller *apc;
-	unsigned long flags;
 	void __iomem *base;
 	u32 data;
 
@@ -133,8 +124,6 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	base = apc->devcfg_base;
-
-	spin_lock_irqsave(&apc->lock, flags);
 	data = __raw_readl(base + (where & ~3));
 
 	switch (size) {
@@ -153,13 +142,9 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 	case 4:
 		break;
 	default:
-		spin_unlock_irqrestore(&apc->lock, flags);
-
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 	}
 
-	spin_unlock_irqrestore(&apc->lock, flags);
-
 	if (where == PCI_BASE_ADDRESS_0 && size == 4 &&
 	    apc->bar0_is_cached) {
 		/* use the cached value */
@@ -175,7 +160,6 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 			     int size, uint32_t value)
 {
 	struct ar724x_pci_controller *apc;
-	unsigned long flags;
 	void __iomem *base;
 	u32 data;
 	int s;
@@ -209,8 +193,6 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 	}
 
 	base = apc->devcfg_base;
-
-	spin_lock_irqsave(&apc->lock, flags);
 	data = __raw_readl(base + (where & ~3));
 
 	switch (size) {
@@ -228,15 +210,12 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 		data = value;
 		break;
 	default:
-		spin_unlock_irqrestore(&apc->lock, flags);
-
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 	}
 
 	__raw_writel(data, base + (where & ~3));
 	/* flush write */
 	__raw_readl(base + (where & ~3));
-	spin_unlock_irqrestore(&apc->lock, flags);
 
 	return PCIBIOS_SUCCESSFUL;
 }
@@ -380,8 +359,6 @@ static int ar724x_pci_probe(struct platform_device *pdev)
 	if (apc->irq < 0)
 		return -EINVAL;
 
-	spin_lock_init(&apc->lock);
-
 	res = platform_get_resource_byname(pdev, IORESOURCE_IO, "io_base");
 	if (!res)
 		return -EINVAL;

commit ec4848815c83d4b8b83440bf6bf571d9b6b5e0d6
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:20:08 2014 +0200

    mips: pci: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 785b2659b519..204c8525c4bb 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -423,7 +423,6 @@ static struct platform_driver ar724x_pci_driver = {
 	.probe = ar724x_pci_probe,
 	.driver = {
 		.name = "ar724x-pci",
-		.owner = THIS_MODULE,
 	},
 };
 

commit c6e7274e7a04af90b6dd7b507e1ea15dbe37b2e0
Author: Julia Lawall <Julia.Lawall@lip6.fr>
Date:   Mon Aug 19 10:51:56 2013 +0200

    MIPS: ath79: simplify platform_get_resource_byname/devm_ioremap_resource
    
    Remove unneeded error handling on the result of a call to
    platform_get_resource_byname when the value is passed to devm_ioremap_resource.
    
    A simplified version of the semantic patch that makes this change is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @@
    expression pdev,res,e,e1;
    expression ret != 0;
    identifier l;
    @@
    
      res = platform_get_resource_byname(...);
    - if (res == NULL) { ... \(goto l;\|return ret;\) }
      e = devm_ioremap_resource(e1, res);
    // </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@lip6.fr>
    Acked-by: Gabor Juhos <juhosg@openwrt.org>
    Cc: kernel-janitors@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/5725/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 65ec032fa0b4..785b2659b519 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -362,25 +362,16 @@ static int ar724x_pci_probe(struct platform_device *pdev)
 		return -ENOMEM;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ctrl_base");
-	if (!res)
-		return -EINVAL;
-
 	apc->ctrl_base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(apc->ctrl_base))
 		return PTR_ERR(apc->ctrl_base);
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cfg_base");
-	if (!res)
-		return -EINVAL;
-
 	apc->devcfg_base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(apc->devcfg_base))
 		return PTR_ERR(apc->devcfg_base);
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "crp_base");
-	if (!res)
-		return -EINVAL;
-
 	apc->crp_base = devm_ioremap_resource(&pdev->dev, res);
 	if (IS_ERR(apc->crp_base))
 		return PTR_ERR(apc->crp_base);

commit f560fabdf3f3fe12bd48146a6ccdf03ddf9ab12c
Author: Silviu-Mihai Popescu <silviupopescu1990@gmail.com>
Date:   Tue Mar 12 10:30:05 2013 +0000

    MIPS: pci: convert to devm_ioremap_resource()
    
    Convert all uses of devm_request_and_ioremap() to the newly introduced
    devm_ioremap_resource() which provides more consistent error handling.
    
    Signed-off-by: Silviu-Mihai Popescu <silviupopescu1990@gmail.com>
    Patchwork: http://patchwork.linux-mips.org/patch/4986/
    Acked-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 8a0700d448fe..65ec032fa0b4 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -365,25 +365,25 @@ static int ar724x_pci_probe(struct platform_device *pdev)
 	if (!res)
 		return -EINVAL;
 
-	apc->ctrl_base = devm_request_and_ioremap(&pdev->dev, res);
-	if (apc->ctrl_base == NULL)
-		return -EBUSY;
+	apc->ctrl_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(apc->ctrl_base))
+		return PTR_ERR(apc->ctrl_base);
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cfg_base");
 	if (!res)
 		return -EINVAL;
 
-	apc->devcfg_base = devm_request_and_ioremap(&pdev->dev, res);
-	if (!apc->devcfg_base)
-		return -EBUSY;
+	apc->devcfg_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(apc->devcfg_base))
+		return PTR_ERR(apc->devcfg_base);
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "crp_base");
 	if (!res)
 		return -EINVAL;
 
-	apc->crp_base = devm_request_and_ioremap(&pdev->dev, res);
-	if (apc->crp_base == NULL)
-		return -EBUSY;
+	apc->crp_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(apc->crp_base))
+		return PTR_ERR(apc->crp_base);
 
 	apc->irq = platform_get_irq(pdev, 0);
 	if (apc->irq < 0)

commit 12401fc28d40aa5bf8bda6991a96b6d7a3dae3ac
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Sun Feb 3 14:52:47 2013 +0000

    MIPS: pci-ar724x: setup command register of the PCI controller
    
    The command register of the PCI controller is
    not initialized correctly by the bootloader on
    some boards and this leads to non working PCI
    bus.
    
    Add code to initialize the command register
    from the Linux code to avoid this.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4916/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 0440d8800f8a..8a0700d448fe 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -29,9 +29,17 @@
 
 #define AR7240_BAR0_WAR_VALUE	0xffff
 
+#define AR724X_PCI_CMD_INIT	(PCI_COMMAND_MEMORY |		\
+				 PCI_COMMAND_MASTER |		\
+				 PCI_COMMAND_INVALIDATE |	\
+				 PCI_COMMAND_PARITY |		\
+				 PCI_COMMAND_SERR |		\
+				 PCI_COMMAND_FAST_BACK)
+
 struct ar724x_pci_controller {
 	void __iomem *devcfg_base;
 	void __iomem *ctrl_base;
+	void __iomem *crp_base;
 
 	int irq;
 	int irq_base;
@@ -64,6 +72,51 @@ pci_bus_to_ar724x_controller(struct pci_bus *bus)
 	return container_of(hose, struct ar724x_pci_controller, pci_controller);
 }
 
+static int ar724x_pci_local_write(struct ar724x_pci_controller *apc,
+				  int where, int size, u32 value)
+{
+	unsigned long flags;
+	void __iomem *base;
+	u32 data;
+	int s;
+
+	WARN_ON(where & (size - 1));
+
+	if (!apc->link_up)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	base = apc->crp_base;
+
+	spin_lock_irqsave(&apc->lock, flags);
+	data = __raw_readl(base + (where & ~3));
+
+	switch (size) {
+	case 1:
+		s = ((where & 3) * 8);
+		data &= ~(0xff << s);
+		data |= ((value & 0xff) << s);
+		break;
+	case 2:
+		s = ((where & 2) * 8);
+		data &= ~(0xffff << s);
+		data |= ((value & 0xffff) << s);
+		break;
+	case 4:
+		data = value;
+		break;
+	default:
+		spin_unlock_irqrestore(&apc->lock, flags);
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	}
+
+	__raw_writel(data, base + (where & ~3));
+	/* flush write */
+	__raw_readl(base + (where & ~3));
+	spin_unlock_irqrestore(&apc->lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
 static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 			    int size, uint32_t *value)
 {
@@ -324,6 +377,14 @@ static int ar724x_pci_probe(struct platform_device *pdev)
 	if (!apc->devcfg_base)
 		return -EBUSY;
 
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "crp_base");
+	if (!res)
+		return -EINVAL;
+
+	apc->crp_base = devm_request_and_ioremap(&pdev->dev, res);
+	if (apc->crp_base == NULL)
+		return -EBUSY;
+
 	apc->irq = platform_get_irq(pdev, 0);
 	if (apc->irq < 0)
 		return -EINVAL;
@@ -360,6 +421,8 @@ static int ar724x_pci_probe(struct platform_device *pdev)
 
 	ar724x_pci_irq_init(apc, id);
 
+	ar724x_pci_local_write(apc, PCI_COMMAND, 4, AR724X_PCI_CMD_INIT);
+
 	register_pci_controller(&apc->pci_controller);
 
 	return 0;

commit 8b66d461187ff61c5755001af7296e6edde48423
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Sun Feb 3 10:00:16 2013 +0000

    MIPS: pci-ar724x: use per-controller IRQ base
    
    Change to the code to use per-controller IRQ base.
    This is needed for multiple PCI controller support.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4915/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index d0d707de6c6c..0440d8800f8a 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -34,6 +34,7 @@ struct ar724x_pci_controller {
 	void __iomem *ctrl_base;
 
 	int irq;
+	int irq_base;
 
 	bool link_up;
 	bool bar0_is_cached;
@@ -205,7 +206,7 @@ static void ar724x_pci_irq_handler(unsigned int irq, struct irq_desc *desc)
 		  __raw_readl(base + AR724X_PCI_REG_INT_MASK);
 
 	if (pending & AR724X_PCI_INT_DEV0)
-		generic_handle_irq(ATH79_PCI_IRQ(0));
+		generic_handle_irq(apc->irq_base + 0);
 
 	else
 		spurious_interrupt();
@@ -215,13 +216,15 @@ static void ar724x_pci_irq_unmask(struct irq_data *d)
 {
 	struct ar724x_pci_controller *apc;
 	void __iomem *base;
+	int offset;
 	u32 t;
 
 	apc = irq_data_get_irq_chip_data(d);
 	base = apc->ctrl_base;
+	offset = apc->irq_base - d->irq;
 
-	switch (d->irq) {
-	case ATH79_PCI_IRQ(0):
+	switch (offset) {
+	case 0:
 		t = __raw_readl(base + AR724X_PCI_REG_INT_MASK);
 		__raw_writel(t | AR724X_PCI_INT_DEV0,
 			     base + AR724X_PCI_REG_INT_MASK);
@@ -234,13 +237,15 @@ static void ar724x_pci_irq_mask(struct irq_data *d)
 {
 	struct ar724x_pci_controller *apc;
 	void __iomem *base;
+	int offset;
 	u32 t;
 
 	apc = irq_data_get_irq_chip_data(d);
 	base = apc->ctrl_base;
+	offset = apc->irq_base - d->irq;
 
-	switch (d->irq) {
-	case ATH79_PCI_IRQ(0):
+	switch (offset) {
+	case 0:
 		t = __raw_readl(base + AR724X_PCI_REG_INT_MASK);
 		__raw_writel(t & ~AR724X_PCI_INT_DEV0,
 			     base + AR724X_PCI_REG_INT_MASK);
@@ -264,7 +269,8 @@ static struct irq_chip ar724x_pci_irq_chip = {
 	.irq_mask_ack	= ar724x_pci_irq_mask,
 };
 
-static void ar724x_pci_irq_init(struct ar724x_pci_controller *apc)
+static void ar724x_pci_irq_init(struct ar724x_pci_controller *apc,
+				int id)
 {
 	void __iomem *base;
 	int i;
@@ -274,10 +280,10 @@ static void ar724x_pci_irq_init(struct ar724x_pci_controller *apc)
 	__raw_writel(0, base + AR724X_PCI_REG_INT_MASK);
 	__raw_writel(0, base + AR724X_PCI_REG_INT_STATUS);
 
-	BUILD_BUG_ON(ATH79_PCI_IRQ_COUNT < AR724X_PCI_IRQ_COUNT);
+	apc->irq_base = ATH79_PCI_IRQ_BASE + (id * AR724X_PCI_IRQ_COUNT);
 
-	for (i = ATH79_PCI_IRQ_BASE;
-	     i < ATH79_PCI_IRQ_BASE + AR724X_PCI_IRQ_COUNT; i++) {
+	for (i = apc->irq_base;
+	     i < apc->irq_base + AR724X_PCI_IRQ_COUNT; i++) {
 		irq_set_chip_and_handler(i, &ar724x_pci_irq_chip,
 					 handle_level_irq);
 		irq_set_chip_data(i, apc);
@@ -291,6 +297,11 @@ static int ar724x_pci_probe(struct platform_device *pdev)
 {
 	struct ar724x_pci_controller *apc;
 	struct resource *res;
+	int id;
+
+	id = pdev->id;
+	if (id == -1)
+		id = 0;
 
 	apc = devm_kzalloc(&pdev->dev, sizeof(struct ar724x_pci_controller),
 			    GFP_KERNEL);
@@ -347,7 +358,7 @@ static int ar724x_pci_probe(struct platform_device *pdev)
 	if (!apc->link_up)
 		dev_warn(&pdev->dev, "PCIe link is down\n");
 
-	ar724x_pci_irq_init(apc);
+	ar724x_pci_irq_init(apc, id);
 
 	register_pci_controller(&apc->pci_controller);
 

commit 34b134aebda89888b6985b7a3139e9cbdf209236
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Sun Feb 3 09:59:45 2013 +0000

    MIPS: pci-ar724x: remove static PCI IO/MEM resources
    
    Static resources become impractical when multiple
    PCI controllers are present. Move the resources
    into the platform device registration code and
    change the probe routine to get those from there
    platform device's resources.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4914/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 93ab8778ce10..d0d707de6c6c 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -42,6 +42,8 @@ struct ar724x_pci_controller {
 	spinlock_t lock;
 
 	struct pci_controller pci_controller;
+	struct resource io_res;
+	struct resource mem_res;
 };
 
 static inline bool ar724x_pci_check_link(struct ar724x_pci_controller *apc)
@@ -190,20 +192,6 @@ static struct pci_ops ar724x_pci_ops = {
 	.write	= ar724x_pci_write,
 };
 
-static struct resource ar724x_io_resource = {
-	.name   = "PCI IO space",
-	.start  = 0,
-	.end    = 0,
-	.flags  = IORESOURCE_IO,
-};
-
-static struct resource ar724x_mem_resource = {
-	.name   = "PCI memory space",
-	.start  = AR724X_PCI_MEM_BASE,
-	.end    = AR724X_PCI_MEM_BASE + AR724X_PCI_MEM_SIZE - 1,
-	.flags  = IORESOURCE_MEM,
-};
-
 static void ar724x_pci_irq_handler(unsigned int irq, struct irq_desc *desc)
 {
 	struct ar724x_pci_controller *apc;
@@ -331,9 +319,29 @@ static int ar724x_pci_probe(struct platform_device *pdev)
 
 	spin_lock_init(&apc->lock);
 
+	res = platform_get_resource_byname(pdev, IORESOURCE_IO, "io_base");
+	if (!res)
+		return -EINVAL;
+
+	apc->io_res.parent = res;
+	apc->io_res.name = "PCI IO space";
+	apc->io_res.start = res->start;
+	apc->io_res.end = res->end;
+	apc->io_res.flags = IORESOURCE_IO;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "mem_base");
+	if (!res)
+		return -EINVAL;
+
+	apc->mem_res.parent = res;
+	apc->mem_res.name = "PCI memory space";
+	apc->mem_res.start = res->start;
+	apc->mem_res.end = res->end;
+	apc->mem_res.flags = IORESOURCE_MEM;
+
 	apc->pci_controller.pci_ops = &ar724x_pci_ops;
-	apc->pci_controller.io_resource = &ar724x_io_resource;
-	apc->pci_controller.mem_resource = &ar724x_mem_resource;
+	apc->pci_controller.io_resource = &apc->io_res;
+	apc->pci_controller.mem_resource = &apc->mem_res;
 
 	apc->link_up = ar724x_pci_check_link(apc);
 	if (!apc->link_up)

commit 908339ef25b1d5e80f1c6fab22b9958174708b4a
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Sun Feb 3 09:58:38 2013 +0000

    MIPS: pci-ar724x: use dynamically allocated PCI controller structure
    
    The current code uses static variables to store the
    PCI controller specific data. This works if the system
    contains one PCI controller only, however it becomes
    impractical when multiple PCI controllers are present.
    
    Move the variables into a dynamically allocated controller
    specific structure, and use that instead of the static
    variables.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4912/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 8f008d9a112c..93ab8778ce10 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -9,6 +9,7 @@
  *  by the Free Software Foundation.
  */
 
+#include <linux/spinlock.h>
 #include <linux/irq.h>
 #include <linux/pci.h>
 #include <linux/module.h>
@@ -28,38 +29,56 @@
 
 #define AR7240_BAR0_WAR_VALUE	0xffff
 
-static DEFINE_SPINLOCK(ar724x_pci_lock);
-static void __iomem *ar724x_pci_devcfg_base;
-static void __iomem *ar724x_pci_ctrl_base;
+struct ar724x_pci_controller {
+	void __iomem *devcfg_base;
+	void __iomem *ctrl_base;
 
-static u32 ar724x_pci_bar0_value;
-static bool ar724x_pci_bar0_is_cached;
-static bool ar724x_pci_link_up;
+	int irq;
+
+	bool link_up;
+	bool bar0_is_cached;
+	u32  bar0_value;
+
+	spinlock_t lock;
+
+	struct pci_controller pci_controller;
+};
 
-static inline bool ar724x_pci_check_link(void)
+static inline bool ar724x_pci_check_link(struct ar724x_pci_controller *apc)
 {
 	u32 reset;
 
-	reset = __raw_readl(ar724x_pci_ctrl_base + AR724X_PCI_REG_RESET);
+	reset = __raw_readl(apc->ctrl_base + AR724X_PCI_REG_RESET);
 	return reset & AR724X_PCI_RESET_LINK_UP;
 }
 
+static inline struct ar724x_pci_controller *
+pci_bus_to_ar724x_controller(struct pci_bus *bus)
+{
+	struct pci_controller *hose;
+
+	hose = (struct pci_controller *) bus->sysdata;
+	return container_of(hose, struct ar724x_pci_controller, pci_controller);
+}
+
 static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 			    int size, uint32_t *value)
 {
+	struct ar724x_pci_controller *apc;
 	unsigned long flags;
 	void __iomem *base;
 	u32 data;
 
-	if (!ar724x_pci_link_up)
+	apc = pci_bus_to_ar724x_controller(bus);
+	if (!apc->link_up)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	if (devfn)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
-	base = ar724x_pci_devcfg_base;
+	base = apc->devcfg_base;
 
-	spin_lock_irqsave(&ar724x_pci_lock, flags);
+	spin_lock_irqsave(&apc->lock, flags);
 	data = __raw_readl(base + (where & ~3));
 
 	switch (size) {
@@ -78,17 +97,17 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 	case 4:
 		break;
 	default:
-		spin_unlock_irqrestore(&ar724x_pci_lock, flags);
+		spin_unlock_irqrestore(&apc->lock, flags);
 
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 	}
 
-	spin_unlock_irqrestore(&ar724x_pci_lock, flags);
+	spin_unlock_irqrestore(&apc->lock, flags);
 
 	if (where == PCI_BASE_ADDRESS_0 && size == 4 &&
-	    ar724x_pci_bar0_is_cached) {
+	    apc->bar0_is_cached) {
 		/* use the cached value */
-		*value = ar724x_pci_bar0_value;
+		*value = apc->bar0_value;
 	} else {
 		*value = data;
 	}
@@ -99,12 +118,14 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 			     int size, uint32_t value)
 {
+	struct ar724x_pci_controller *apc;
 	unsigned long flags;
 	void __iomem *base;
 	u32 data;
 	int s;
 
-	if (!ar724x_pci_link_up)
+	apc = pci_bus_to_ar724x_controller(bus);
+	if (!apc->link_up)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
 	if (devfn)
@@ -122,18 +143,18 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 			 * BAR0 register in order to make the device memory
 			 * accessible.
 			 */
-			ar724x_pci_bar0_is_cached = true;
-			ar724x_pci_bar0_value = value;
+			apc->bar0_is_cached = true;
+			apc->bar0_value = value;
 
 			value = AR7240_BAR0_WAR_VALUE;
 		} else {
-			ar724x_pci_bar0_is_cached = false;
+			apc->bar0_is_cached = false;
 		}
 	}
 
-	base = ar724x_pci_devcfg_base;
+	base = apc->devcfg_base;
 
-	spin_lock_irqsave(&ar724x_pci_lock, flags);
+	spin_lock_irqsave(&apc->lock, flags);
 	data = __raw_readl(base + (where & ~3));
 
 	switch (size) {
@@ -151,7 +172,7 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 		data = value;
 		break;
 	default:
-		spin_unlock_irqrestore(&ar724x_pci_lock, flags);
+		spin_unlock_irqrestore(&apc->lock, flags);
 
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 	}
@@ -159,7 +180,7 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 	__raw_writel(data, base + (where & ~3));
 	/* flush write */
 	__raw_readl(base + (where & ~3));
-	spin_unlock_irqrestore(&ar724x_pci_lock, flags);
+	spin_unlock_irqrestore(&apc->lock, flags);
 
 	return PCIBIOS_SUCCESSFUL;
 }
@@ -183,18 +204,14 @@ static struct resource ar724x_mem_resource = {
 	.flags  = IORESOURCE_MEM,
 };
 
-static struct pci_controller ar724x_pci_controller = {
-	.pci_ops        = &ar724x_pci_ops,
-	.io_resource    = &ar724x_io_resource,
-	.mem_resource	= &ar724x_mem_resource,
-};
-
 static void ar724x_pci_irq_handler(unsigned int irq, struct irq_desc *desc)
 {
+	struct ar724x_pci_controller *apc;
 	void __iomem *base;
 	u32 pending;
 
-	base = ar724x_pci_ctrl_base;
+	apc = irq_get_handler_data(irq);
+	base = apc->ctrl_base;
 
 	pending = __raw_readl(base + AR724X_PCI_REG_INT_STATUS) &
 		  __raw_readl(base + AR724X_PCI_REG_INT_MASK);
@@ -208,10 +225,12 @@ static void ar724x_pci_irq_handler(unsigned int irq, struct irq_desc *desc)
 
 static void ar724x_pci_irq_unmask(struct irq_data *d)
 {
+	struct ar724x_pci_controller *apc;
 	void __iomem *base;
 	u32 t;
 
-	base = ar724x_pci_ctrl_base;
+	apc = irq_data_get_irq_chip_data(d);
+	base = apc->ctrl_base;
 
 	switch (d->irq) {
 	case ATH79_PCI_IRQ(0):
@@ -225,10 +244,12 @@ static void ar724x_pci_irq_unmask(struct irq_data *d)
 
 static void ar724x_pci_irq_mask(struct irq_data *d)
 {
+	struct ar724x_pci_controller *apc;
 	void __iomem *base;
 	u32 t;
 
-	base = ar724x_pci_ctrl_base;
+	apc = irq_data_get_irq_chip_data(d);
+	base = apc->ctrl_base;
 
 	switch (d->irq) {
 	case ATH79_PCI_IRQ(0):
@@ -255,12 +276,12 @@ static struct irq_chip ar724x_pci_irq_chip = {
 	.irq_mask_ack	= ar724x_pci_irq_mask,
 };
 
-static void ar724x_pci_irq_init(int irq)
+static void ar724x_pci_irq_init(struct ar724x_pci_controller *apc)
 {
 	void __iomem *base;
 	int i;
 
-	base = ar724x_pci_ctrl_base;
+	base = apc->ctrl_base;
 
 	__raw_writel(0, base + AR724X_PCI_REG_INT_MASK);
 	__raw_writel(0, base + AR724X_PCI_REG_INT_STATUS);
@@ -268,45 +289,59 @@ static void ar724x_pci_irq_init(int irq)
 	BUILD_BUG_ON(ATH79_PCI_IRQ_COUNT < AR724X_PCI_IRQ_COUNT);
 
 	for (i = ATH79_PCI_IRQ_BASE;
-	     i < ATH79_PCI_IRQ_BASE + AR724X_PCI_IRQ_COUNT; i++)
+	     i < ATH79_PCI_IRQ_BASE + AR724X_PCI_IRQ_COUNT; i++) {
 		irq_set_chip_and_handler(i, &ar724x_pci_irq_chip,
 					 handle_level_irq);
+		irq_set_chip_data(i, apc);
+	}
 
-	irq_set_chained_handler(irq, ar724x_pci_irq_handler);
+	irq_set_handler_data(apc->irq, apc);
+	irq_set_chained_handler(apc->irq, ar724x_pci_irq_handler);
 }
 
 static int ar724x_pci_probe(struct platform_device *pdev)
 {
+	struct ar724x_pci_controller *apc;
 	struct resource *res;
-	int irq;
+
+	apc = devm_kzalloc(&pdev->dev, sizeof(struct ar724x_pci_controller),
+			    GFP_KERNEL);
+	if (!apc)
+		return -ENOMEM;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ctrl_base");
 	if (!res)
 		return -EINVAL;
 
-	ar724x_pci_ctrl_base = devm_request_and_ioremap(&pdev->dev, res);
-	if (ar724x_pci_ctrl_base == NULL)
+	apc->ctrl_base = devm_request_and_ioremap(&pdev->dev, res);
+	if (apc->ctrl_base == NULL)
 		return -EBUSY;
 
 	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cfg_base");
 	if (!res)
 		return -EINVAL;
 
-	ar724x_pci_devcfg_base = devm_request_and_ioremap(&pdev->dev, res);
-	if (!ar724x_pci_devcfg_base)
+	apc->devcfg_base = devm_request_and_ioremap(&pdev->dev, res);
+	if (!apc->devcfg_base)
 		return -EBUSY;
 
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0)
+	apc->irq = platform_get_irq(pdev, 0);
+	if (apc->irq < 0)
 		return -EINVAL;
 
-	ar724x_pci_link_up = ar724x_pci_check_link();
-	if (!ar724x_pci_link_up)
+	spin_lock_init(&apc->lock);
+
+	apc->pci_controller.pci_ops = &ar724x_pci_ops;
+	apc->pci_controller.io_resource = &ar724x_io_resource;
+	apc->pci_controller.mem_resource = &ar724x_mem_resource;
+
+	apc->link_up = ar724x_pci_check_link(apc);
+	if (!apc->link_up)
 		dev_warn(&pdev->dev, "PCIe link is down\n");
 
-	ar724x_pci_irq_init(irq);
+	ar724x_pci_irq_init(apc);
 
-	register_pci_controller(&ar724x_pci_controller);
+	register_pci_controller(&apc->pci_controller);
 
 	return 0;
 }

commit 6e783865b4e60f2ecf7708f8ea24db5c5ea07ced
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Mon Feb 4 11:58:49 2013 +0100

    MIPS: ath79: remove unused ar7{1x,24}x_pcibios_init functions
    
    The functions are unused now, so remove them.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4909/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index b3f9d093c066..8f008d9a112c 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -15,7 +15,6 @@
 #include <linux/platform_device.h>
 #include <asm/mach-ath79/ath79.h>
 #include <asm/mach-ath79/ar71xx_regs.h>
-#include <asm/mach-ath79/pci.h>
 
 #define AR724X_PCI_REG_RESET		0x18
 #define AR724X_PCI_REG_INT_STATUS	0x4c
@@ -276,37 +275,6 @@ static void ar724x_pci_irq_init(int irq)
 	irq_set_chained_handler(irq, ar724x_pci_irq_handler);
 }
 
-int ar724x_pcibios_init(int irq)
-{
-	int ret;
-
-	ret = -ENOMEM;
-
-	ar724x_pci_devcfg_base = ioremap(AR724X_PCI_CFG_BASE,
-					 AR724X_PCI_CFG_SIZE);
-	if (ar724x_pci_devcfg_base == NULL)
-		goto err;
-
-	ar724x_pci_ctrl_base = ioremap(AR724X_PCI_CTRL_BASE,
-				       AR724X_PCI_CTRL_SIZE);
-	if (ar724x_pci_ctrl_base == NULL)
-		goto err_unmap_devcfg;
-
-	ar724x_pci_link_up = ar724x_pci_check_link();
-	if (!ar724x_pci_link_up)
-		pr_warn("ar724x: PCIe link is down\n");
-
-	ar724x_pci_irq_init(irq);
-	register_pci_controller(&ar724x_pci_controller);
-
-	return PCIBIOS_SUCCESSFUL;
-
-err_unmap_devcfg:
-	iounmap(ar724x_pci_devcfg_base);
-err:
-	return ret;
-}
-
 static int ar724x_pci_probe(struct platform_device *pdev)
 {
 	struct resource *res;

commit ad4ce92e919f7ad5561a2060deb58899de58b40c
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Mon Feb 4 11:56:53 2013 +0100

    MIPS: ath79: move global PCI defines into a common header
    
    The constants will be used by a subsequent patch.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4907/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index e7aca88ba0c0..b3f9d093c066 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -17,14 +17,6 @@
 #include <asm/mach-ath79/ar71xx_regs.h>
 #include <asm/mach-ath79/pci.h>
 
-#define AR724X_PCI_CFG_BASE	0x14000000
-#define AR724X_PCI_CFG_SIZE	0x1000
-#define AR724X_PCI_CTRL_BASE	(AR71XX_APB_BASE + 0x000f0000)
-#define AR724X_PCI_CTRL_SIZE	0x100
-
-#define AR724X_PCI_MEM_BASE	0x10000000
-#define AR724X_PCI_MEM_SIZE	0x04000000
-
 #define AR724X_PCI_REG_RESET		0x18
 #define AR724X_PCI_REG_INT_STATUS	0x4c
 #define AR724X_PCI_REG_INT_MASK		0x50

commit 58d2e9bcd682d76bcb9575dc56c85f1d82a81bfa
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Sat Feb 2 11:40:42 2013 +0000

    MIPS: pci-ar724x: convert into a platform driver
    
    The patch converts the pci-ar724x driver into a
    platform driver. This makes it possible to register
    the PCI controller as a plain platform device.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4905/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index c11c75be2d7e..e7aca88ba0c0 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -11,6 +11,8 @@
 
 #include <linux/irq.h>
 #include <linux/pci.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
 #include <asm/mach-ath79/ath79.h>
 #include <asm/mach-ath79/ar71xx_regs.h>
 #include <asm/mach-ath79/pci.h>
@@ -262,7 +264,7 @@ static struct irq_chip ar724x_pci_irq_chip = {
 	.irq_mask_ack	= ar724x_pci_irq_mask,
 };
 
-static void __init ar724x_pci_irq_init(int irq)
+static void ar724x_pci_irq_init(int irq)
 {
 	void __iomem *base;
 	int i;
@@ -282,7 +284,7 @@ static void __init ar724x_pci_irq_init(int irq)
 	irq_set_chained_handler(irq, ar724x_pci_irq_handler);
 }
 
-int __init ar724x_pcibios_init(int irq)
+int ar724x_pcibios_init(int irq)
 {
 	int ret;
 
@@ -312,3 +314,54 @@ int __init ar724x_pcibios_init(int irq)
 err:
 	return ret;
 }
+
+static int ar724x_pci_probe(struct platform_device *pdev)
+{
+	struct resource *res;
+	int irq;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "ctrl_base");
+	if (!res)
+		return -EINVAL;
+
+	ar724x_pci_ctrl_base = devm_request_and_ioremap(&pdev->dev, res);
+	if (ar724x_pci_ctrl_base == NULL)
+		return -EBUSY;
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "cfg_base");
+	if (!res)
+		return -EINVAL;
+
+	ar724x_pci_devcfg_base = devm_request_and_ioremap(&pdev->dev, res);
+	if (!ar724x_pci_devcfg_base)
+		return -EBUSY;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq < 0)
+		return -EINVAL;
+
+	ar724x_pci_link_up = ar724x_pci_check_link();
+	if (!ar724x_pci_link_up)
+		dev_warn(&pdev->dev, "PCIe link is down\n");
+
+	ar724x_pci_irq_init(irq);
+
+	register_pci_controller(&ar724x_pci_controller);
+
+	return 0;
+}
+
+static struct platform_driver ar724x_pci_driver = {
+	.probe = ar724x_pci_probe,
+	.driver = {
+		.name = "ar724x-pci",
+		.owner = THIS_MODULE,
+	},
+};
+
+static int __init ar724x_pci_init(void)
+{
+	return platform_driver_register(&ar724x_pci_driver);
+}
+
+postcore_initcall(ar724x_pci_init);

commit 4c960910e2fb3a301ee4a504fa6b2c5204efeab0
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Tue Jan 29 08:27:03 2013 +0000

    MIPS: AR724x: Fix AR724X_PCI_MEM_SIZE
    
    The base address of the PCI memory is
    0x10000000 and the base address of the
    PCI configuration space is 0x14000000
    on the AR724x SoCs.
    
    The AR724X_PCI_MEM_SIZE is defined as
    0x08000000 which is wrong because that
    overlaps  with the configuration space.
    
    The patch fixes the value of the
    AR724X_PCI_MEM_SIZE constant, in order
    to avoid this resource conflicts.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4872/
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 86d77a666458..c11c75be2d7e 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -21,7 +21,7 @@
 #define AR724X_PCI_CTRL_SIZE	0x100
 
 #define AR724X_PCI_MEM_BASE	0x10000000
-#define AR724X_PCI_MEM_SIZE	0x08000000
+#define AR724X_PCI_MEM_SIZE	0x04000000
 
 #define AR724X_PCI_REG_RESET		0x18
 #define AR724X_PCI_REG_INT_STATUS	0x4c

commit a1dca315ce3f78347bca8ce8befe3cc71ae63b7e
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Thu Aug 23 15:35:26 2012 +0200

    MIPS: pci-ar724x: avoid data bus error due to a missing PCIe module
    
    If the controller has no PCIe module attached, accessing of the device
    configuration space causes a data bus error. Avoid this by checking the
    status of the PCIe link in advance, and indicate an error if the link
    is down.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Cc: stable@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/4293/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 414a7459858d..86d77a666458 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -23,9 +23,12 @@
 #define AR724X_PCI_MEM_BASE	0x10000000
 #define AR724X_PCI_MEM_SIZE	0x08000000
 
+#define AR724X_PCI_REG_RESET		0x18
 #define AR724X_PCI_REG_INT_STATUS	0x4c
 #define AR724X_PCI_REG_INT_MASK		0x50
 
+#define AR724X_PCI_RESET_LINK_UP	BIT(0)
+
 #define AR724X_PCI_INT_DEV0		BIT(14)
 
 #define AR724X_PCI_IRQ_COUNT		1
@@ -38,6 +41,15 @@ static void __iomem *ar724x_pci_ctrl_base;
 
 static u32 ar724x_pci_bar0_value;
 static bool ar724x_pci_bar0_is_cached;
+static bool ar724x_pci_link_up;
+
+static inline bool ar724x_pci_check_link(void)
+{
+	u32 reset;
+
+	reset = __raw_readl(ar724x_pci_ctrl_base + AR724X_PCI_REG_RESET);
+	return reset & AR724X_PCI_RESET_LINK_UP;
+}
 
 static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 			    int size, uint32_t *value)
@@ -46,6 +58,9 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 	void __iomem *base;
 	u32 data;
 
+	if (!ar724x_pci_link_up)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
 	if (devfn)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
@@ -96,6 +111,9 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 	u32 data;
 	int s;
 
+	if (!ar724x_pci_link_up)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
 	if (devfn)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
@@ -280,6 +298,10 @@ int __init ar724x_pcibios_init(int irq)
 	if (ar724x_pci_ctrl_base == NULL)
 		goto err_unmap_devcfg;
 
+	ar724x_pci_link_up = ar724x_pci_check_link();
+	if (!ar724x_pci_link_up)
+		pr_warn("ar724x: PCIe link is down\n");
+
 	ar724x_pci_irq_init(irq);
 	register_pci_controller(&ar724x_pci_controller);
 

commit e9b62e8ef9d71ed977797529fc0dfc352448d50b
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Mar 14 10:36:14 2012 +0100

    MIPS: ath79: update copyright headers of PCI related files
    
    Add copyright records according to the recent changes in
    the PCI code. Also fix up the descriptions.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Signed-off-by: Imre Kaloz <kaloz@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3503/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 04f433a823da..414a7459858d 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -1,7 +1,8 @@
 /*
- *  Atheros 724x PCI support
+ *  Atheros AR724X PCI host controller driver
  *
  *  Copyright (C) 2011 Ren√© Bolldorf <xsecute@googlemail.com>
+ *  Copyright (C) 2009-2011 Gabor Juhos <juhosg@openwrt.org>
  *
  *  This program is free software; you can redistribute it and/or modify it
  *  under the terms of the GNU General Public License version 2 as published

commit 4c07c7dfa0f3575dc3276c544349fbf181381167
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Mar 14 10:36:07 2012 +0100

    MIPS: ath79: add PCI IRQ handling code for AR724X SoCs
    
    The PCI Host Controller of the AR724x SoC has a
    built-in IRQ controller. The current code does
    not supports that, so the IRQ lines wired to this
    controller are not usable. This leads to failed
    'request_irq' calls:
    
      ath9k 0000:00:00.0: request_irq failed
      ath9k: probe of 0000:00:00.0 failed with error -89
    
    This patch adds support for the IRQ controller
    in order to make PCI IRQs work.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Cc:  linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3496/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 07b7e3071735..04f433a823da 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -8,19 +8,32 @@
  *  by the Free Software Foundation.
  */
 
+#include <linux/irq.h>
 #include <linux/pci.h>
 #include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ar71xx_regs.h>
 #include <asm/mach-ath79/pci.h>
 
 #define AR724X_PCI_CFG_BASE	0x14000000
 #define AR724X_PCI_CFG_SIZE	0x1000
+#define AR724X_PCI_CTRL_BASE	(AR71XX_APB_BASE + 0x000f0000)
+#define AR724X_PCI_CTRL_SIZE	0x100
+
 #define AR724X_PCI_MEM_BASE	0x10000000
 #define AR724X_PCI_MEM_SIZE	0x08000000
 
+#define AR724X_PCI_REG_INT_STATUS	0x4c
+#define AR724X_PCI_REG_INT_MASK		0x50
+
+#define AR724X_PCI_INT_DEV0		BIT(14)
+
+#define AR724X_PCI_IRQ_COUNT		1
+
 #define AR7240_BAR0_WAR_VALUE	0xffff
 
 static DEFINE_SPINLOCK(ar724x_pci_lock);
 static void __iomem *ar724x_pci_devcfg_base;
+static void __iomem *ar724x_pci_ctrl_base;
 
 static u32 ar724x_pci_bar0_value;
 static bool ar724x_pci_bar0_is_cached;
@@ -164,14 +177,115 @@ static struct pci_controller ar724x_pci_controller = {
 	.mem_resource	= &ar724x_mem_resource,
 };
 
-int __init ar724x_pcibios_init(void)
+static void ar724x_pci_irq_handler(unsigned int irq, struct irq_desc *desc)
+{
+	void __iomem *base;
+	u32 pending;
+
+	base = ar724x_pci_ctrl_base;
+
+	pending = __raw_readl(base + AR724X_PCI_REG_INT_STATUS) &
+		  __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+
+	if (pending & AR724X_PCI_INT_DEV0)
+		generic_handle_irq(ATH79_PCI_IRQ(0));
+
+	else
+		spurious_interrupt();
+}
+
+static void ar724x_pci_irq_unmask(struct irq_data *d)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ar724x_pci_ctrl_base;
+
+	switch (d->irq) {
+	case ATH79_PCI_IRQ(0):
+		t = __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+		__raw_writel(t | AR724X_PCI_INT_DEV0,
+			     base + AR724X_PCI_REG_INT_MASK);
+		/* flush write */
+		__raw_readl(base + AR724X_PCI_REG_INT_MASK);
+	}
+}
+
+static void ar724x_pci_irq_mask(struct irq_data *d)
+{
+	void __iomem *base;
+	u32 t;
+
+	base = ar724x_pci_ctrl_base;
+
+	switch (d->irq) {
+	case ATH79_PCI_IRQ(0):
+		t = __raw_readl(base + AR724X_PCI_REG_INT_MASK);
+		__raw_writel(t & ~AR724X_PCI_INT_DEV0,
+			     base + AR724X_PCI_REG_INT_MASK);
+
+		/* flush write */
+		__raw_readl(base + AR724X_PCI_REG_INT_MASK);
+
+		t = __raw_readl(base + AR724X_PCI_REG_INT_STATUS);
+		__raw_writel(t | AR724X_PCI_INT_DEV0,
+			     base + AR724X_PCI_REG_INT_STATUS);
+
+		/* flush write */
+		__raw_readl(base + AR724X_PCI_REG_INT_STATUS);
+	}
+}
+
+static struct irq_chip ar724x_pci_irq_chip = {
+	.name		= "AR724X PCI ",
+	.irq_mask	= ar724x_pci_irq_mask,
+	.irq_unmask	= ar724x_pci_irq_unmask,
+	.irq_mask_ack	= ar724x_pci_irq_mask,
+};
+
+static void __init ar724x_pci_irq_init(int irq)
+{
+	void __iomem *base;
+	int i;
+
+	base = ar724x_pci_ctrl_base;
+
+	__raw_writel(0, base + AR724X_PCI_REG_INT_MASK);
+	__raw_writel(0, base + AR724X_PCI_REG_INT_STATUS);
+
+	BUILD_BUG_ON(ATH79_PCI_IRQ_COUNT < AR724X_PCI_IRQ_COUNT);
+
+	for (i = ATH79_PCI_IRQ_BASE;
+	     i < ATH79_PCI_IRQ_BASE + AR724X_PCI_IRQ_COUNT; i++)
+		irq_set_chip_and_handler(i, &ar724x_pci_irq_chip,
+					 handle_level_irq);
+
+	irq_set_chained_handler(irq, ar724x_pci_irq_handler);
+}
+
+int __init ar724x_pcibios_init(int irq)
 {
+	int ret;
+
+	ret = -ENOMEM;
+
 	ar724x_pci_devcfg_base = ioremap(AR724X_PCI_CFG_BASE,
 					 AR724X_PCI_CFG_SIZE);
 	if (ar724x_pci_devcfg_base == NULL)
-		return -ENOMEM;
+		goto err;
 
+	ar724x_pci_ctrl_base = ioremap(AR724X_PCI_CTRL_BASE,
+				       AR724X_PCI_CTRL_SIZE);
+	if (ar724x_pci_ctrl_base == NULL)
+		goto err_unmap_devcfg;
+
+	ar724x_pci_irq_init(irq);
 	register_pci_controller(&ar724x_pci_controller);
 
 	return PCIBIOS_SUCCESSFUL;
+
+err_unmap_devcfg:
+	iounmap(ar724x_pci_devcfg_base);
+err:
+	return ret;
 }

commit 6015a856f16ccf33e9f83643d04c2e15be2384eb
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Mar 14 10:36:05 2012 +0100

    MIPS: ath79: add a workaround for a PCI controller bug in AR7240 SoCs
    
    The PCI controller of the AR724X SoCs has a hardware
    bag. If the BAR0 register of the PCI device is set to
    the proper base address, the memory address space of
    the device is not accessible.
    
    When the device driver tries to access the memory
    address space of the PCI device, it leads to data
    bus error, similiar to this:
    
    Data bus error, epc == 801f69a0, ra == 801f698c
    Oops[#1]:
    Cpu 0
    $ 0   : 00000000 00000061 deadbeef 000000ff
    $ 4   : 00000000 000000ff 00000014 00000000
    $ 8   : ff000000 fffffffc 00000000 00000000
    $12   : 000001f5 00000006 00000000 6e637920
    $16   : 81ca4000 81ca0260 81ca4000 804d70f0
    $20   : fffffff4 0000002b 803ad4c4 00000000
    $24   : 00000003 00000000
    $28   : 81c20000 81c21c60 00000000 801f698c
    Hi    : 00000000
    Lo    : 00000000
    epc   : 801f69a0 ath9k_hw_init+0xd0/0xa70
        Not tainted
    ra    : 801f698c ath9k_hw_init+0xbc/0xa70
    Status: 1000c103    KERNEL EXL IE
    Cause : 1080001c
    PrId  : 00019374 (MIPS 24Kc)
    Modules linked in:
    Process swapper (pid: 1, threadinfo=81c20000, task=81c18000, tls=00000000)
    Stack : 00000000 00000000 00000000 00000000 81c21c78 81ca0260 00000000 804d70f0
            81ca0260 81c21cc0 81ca0e80 81ca0260 81ca4000 804d70f0 fffffff4 0000002b
            803ad4c4 00000000 00000000 801e3ae8 81c9d080 81ca0e80 b0000000 800b9b9c
            00000008 81c9d000 8031aeb0 802d38a0 00000000 81c14c00 81c14c60 00000000
            81ca0e80 81ca0260 b0000000 801f08a4 81c9c820 81c21d48 81c9c820 80144320
            ...
    Call Trace:
    [<801f69a0>] ath9k_hw_init+0xd0/0xa70
    [<801e3ae8>] ath9k_init_device+0x174/0x680
    [<801f08a4>] ath_pci_probe+0x27c/0x380
    [<8019e490>] pci_device_probe+0x74/0x9c
    [<801bfadc>] driver_probe_device+0x9c/0x1b4
    [<801bfcb0>] __driver_attach+0xbc/0xc4
    [<801bea0c>] bus_for_each_dev+0x5c/0x98
    [<801bf394>] bus_add_driver+0x1d0/0x2a4
    [<801c0364>] driver_register+0x8c/0x16c
    [<8019e72c>] __pci_register_driver+0x4c/0xe4
    [<803d3d40>] ath9k_init+0x3c/0x88
    [<80060930>] do_one_initcall+0x3c/0x1cc
    [<803c297c>] kernel_init+0xa4/0x138
    [<80063c04>] kernel_thread_helper+0x10/0x18
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3494/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index bb4f2162d4e4..07b7e3071735 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -9,6 +9,7 @@
  */
 
 #include <linux/pci.h>
+#include <asm/mach-ath79/ath79.h>
 #include <asm/mach-ath79/pci.h>
 
 #define AR724X_PCI_CFG_BASE	0x14000000
@@ -16,9 +17,14 @@
 #define AR724X_PCI_MEM_BASE	0x10000000
 #define AR724X_PCI_MEM_SIZE	0x08000000
 
+#define AR7240_BAR0_WAR_VALUE	0xffff
+
 static DEFINE_SPINLOCK(ar724x_pci_lock);
 static void __iomem *ar724x_pci_devcfg_base;
 
+static u32 ar724x_pci_bar0_value;
+static bool ar724x_pci_bar0_is_cached;
+
 static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 			    int size, uint32_t *value)
 {
@@ -56,7 +62,14 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 	}
 
 	spin_unlock_irqrestore(&ar724x_pci_lock, flags);
-	*value = data;
+
+	if (where == PCI_BASE_ADDRESS_0 && size == 4 &&
+	    ar724x_pci_bar0_is_cached) {
+		/* use the cached value */
+		*value = ar724x_pci_bar0_value;
+	} else {
+		*value = data;
+	}
 
 	return PCIBIOS_SUCCESSFUL;
 }
@@ -72,6 +85,27 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 	if (devfn)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
+	if (soc_is_ar7240() && where == PCI_BASE_ADDRESS_0 && size == 4) {
+		if (value != 0xffffffff) {
+			/*
+			 * WAR for a hw issue. If the BAR0 register of the
+			 * device is set to the proper base address, the
+			 * memory space of the device is not accessible.
+			 *
+			 * Cache the intended value so it can be read back,
+			 * and write a SoC specific constant value to the
+			 * BAR0 register in order to make the device memory
+			 * accessible.
+			 */
+			ar724x_pci_bar0_is_cached = true;
+			ar724x_pci_bar0_value = value;
+
+			value = AR7240_BAR0_WAR_VALUE;
+		} else {
+			ar724x_pci_bar0_is_cached = false;
+		}
+	}
+
 	base = ar724x_pci_devcfg_base;
 
 	spin_lock_irqsave(&ar724x_pci_lock, flags);

commit 64adb6bb62bee11ad04c2f9c3c797799e329c351
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Mar 14 10:36:04 2012 +0100

    MIPS: ath79: fix broken ar724x_pci_{read,write} functions
    
    The current ar724x_pci_{read,write} functions are
    broken. Due to that, pci_read_config_byte returns
    with bogus values, and pci_write_config_{byte,word}
    unconditionally clears the accessed PCI configuration
    registers instead of changing the value of them.
    
    The patch fixes the broken functions, thus the PCI
    configuration space can be accessed correctly.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3493/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 342bf4ab8960..bb4f2162d4e4 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -22,8 +22,9 @@ static void __iomem *ar724x_pci_devcfg_base;
 static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 			    int size, uint32_t *value)
 {
-	unsigned long flags, addr, tval, mask;
+	unsigned long flags;
 	void __iomem *base;
+	u32 data;
 
 	if (devfn)
 		return PCIBIOS_DEVICE_NOT_FOUND;
@@ -31,24 +32,22 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 	base = ar724x_pci_devcfg_base;
 
 	spin_lock_irqsave(&ar724x_pci_lock, flags);
+	data = __raw_readl(base + (where & ~3));
 
 	switch (size) {
 	case 1:
-		addr = where & ~3;
-		mask = 0xff000000 >> ((where % 4) * 8);
-		tval = __raw_readl(base + addr);
-		tval = tval & ~mask;
-		*value = (tval >> ((4 - (where % 4))*8));
+		if (where & 1)
+			data >>= 8;
+		if (where & 2)
+			data >>= 16;
+		data &= 0xff;
 		break;
 	case 2:
-		addr = where & ~3;
-		mask = 0xffff0000 >> ((where % 4)*8);
-		tval = __raw_readl(base + addr);
-		tval = tval & ~mask;
-		*value = (tval >> ((4 - (where % 4))*8));
+		if (where & 2)
+			data >>= 16;
+		data &= 0xffff;
 		break;
 	case 4:
-		*value = __raw_readl(base + where);
 		break;
 	default:
 		spin_unlock_irqrestore(&ar724x_pci_lock, flags);
@@ -57,6 +56,7 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 	}
 
 	spin_unlock_irqrestore(&ar724x_pci_lock, flags);
+	*value = data;
 
 	return PCIBIOS_SUCCESSFUL;
 }
@@ -64,8 +64,10 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 			     int size, uint32_t value)
 {
-	unsigned long flags, tval, addr, mask;
+	unsigned long flags;
 	void __iomem *base;
+	u32 data;
+	int s;
 
 	if (devfn)
 		return PCIBIOS_DEVICE_NOT_FOUND;
@@ -73,26 +75,21 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 	base = ar724x_pci_devcfg_base;
 
 	spin_lock_irqsave(&ar724x_pci_lock, flags);
+	data = __raw_readl(base + (where & ~3));
 
 	switch (size) {
 	case 1:
-		addr = where & ~3;
-		mask = 0xff000000 >> ((where % 4)*8);
-		tval = __raw_readl(base + addr);
-		tval = tval & ~mask;
-		tval |= (value << ((4 - (where % 4))*8)) & mask;
-		__raw_writel(tval, base + addr);
+		s = ((where & 3) * 8);
+		data &= ~(0xff << s);
+		data |= ((value & 0xff) << s);
 		break;
 	case 2:
-		addr = where & ~3;
-		mask = 0xffff0000 >> ((where % 4)*8);
-		tval = __raw_readl(base + addr);
-		tval = tval & ~mask;
-		tval |= (value << ((4 - (where % 4))*8)) & mask;
-		__raw_writel(tval, base + addr);
+		s = ((where & 2) * 8);
+		data &= ~(0xffff << s);
+		data |= ((value & 0xffff) << s);
 		break;
 	case 4:
-		__raw_writel(value, (base + where));
+		data = value;
 		break;
 	default:
 		spin_unlock_irqrestore(&ar724x_pci_lock, flags);
@@ -100,6 +97,9 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 	}
 
+	__raw_writel(data, base + (where & ~3));
+	/* flush write */
+	__raw_readl(base + (where & ~3));
 	spin_unlock_irqrestore(&ar724x_pci_lock, flags);
 
 	return PCIBIOS_SUCCESSFUL;

commit ffdce4668234a113e767edd27aa1331903959106
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Mar 14 10:36:03 2012 +0100

    MIPS: ath79: remove superfluous alignment checks from pci-ar724x.c
    
    The alignment of the 'where' parameters are checked
    in the core PCI code already.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3492/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 22f5e5bc4dfe..342bf4ab8960 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -28,9 +28,6 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 	if (devfn)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
-	if (where & (size - 1))
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-
 	base = ar724x_pci_devcfg_base;
 
 	spin_lock_irqsave(&ar724x_pci_lock, flags);
@@ -73,9 +70,6 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 	if (devfn)
 		return PCIBIOS_DEVICE_NOT_FOUND;
 
-	if (where & (size - 1))
-		return PCIBIOS_BAD_REGISTER_NUMBER;
-
 	base = ar724x_pci_devcfg_base;
 
 	spin_lock_irqsave(&ar724x_pci_lock, flags);

commit c198441a3f3007752c551a32d5c426f48ae8712d
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Mar 14 10:29:27 2012 +0100

    MIPS: ath79: use io-accessor macros in pci-ar724x.c
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Acked-by: Ren√© Bolldorf <xsecute@googlemail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3491/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index 772d12c5fc9e..22f5e5bc4dfe 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -11,19 +11,19 @@
 #include <linux/pci.h>
 #include <asm/mach-ath79/pci.h>
 
-#define reg_read(_phys)		(*(unsigned int *) KSEG1ADDR(_phys))
-#define reg_write(_phys, _val)	((*(unsigned int *) KSEG1ADDR(_phys)) = (_val))
-
-#define AR724X_PCI_DEV_BASE	0x14000000
+#define AR724X_PCI_CFG_BASE	0x14000000
+#define AR724X_PCI_CFG_SIZE	0x1000
 #define AR724X_PCI_MEM_BASE	0x10000000
 #define AR724X_PCI_MEM_SIZE	0x08000000
 
 static DEFINE_SPINLOCK(ar724x_pci_lock);
+static void __iomem *ar724x_pci_devcfg_base;
 
 static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 			    int size, uint32_t *value)
 {
 	unsigned long flags, addr, tval, mask;
+	void __iomem *base;
 
 	if (devfn)
 		return PCIBIOS_DEVICE_NOT_FOUND;
@@ -31,25 +31,27 @@ static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 	if (where & (size - 1))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
+	base = ar724x_pci_devcfg_base;
+
 	spin_lock_irqsave(&ar724x_pci_lock, flags);
 
 	switch (size) {
 	case 1:
 		addr = where & ~3;
 		mask = 0xff000000 >> ((where % 4) * 8);
-		tval = reg_read(AR724X_PCI_DEV_BASE + addr);
+		tval = __raw_readl(base + addr);
 		tval = tval & ~mask;
 		*value = (tval >> ((4 - (where % 4))*8));
 		break;
 	case 2:
 		addr = where & ~3;
 		mask = 0xffff0000 >> ((where % 4)*8);
-		tval = reg_read(AR724X_PCI_DEV_BASE + addr);
+		tval = __raw_readl(base + addr);
 		tval = tval & ~mask;
 		*value = (tval >> ((4 - (where % 4))*8));
 		break;
 	case 4:
-		*value = reg_read(AR724X_PCI_DEV_BASE + where);
+		*value = __raw_readl(base + where);
 		break;
 	default:
 		spin_unlock_irqrestore(&ar724x_pci_lock, flags);
@@ -66,6 +68,7 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 			     int size, uint32_t value)
 {
 	unsigned long flags, tval, addr, mask;
+	void __iomem *base;
 
 	if (devfn)
 		return PCIBIOS_DEVICE_NOT_FOUND;
@@ -73,27 +76,29 @@ static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 	if (where & (size - 1))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
+	base = ar724x_pci_devcfg_base;
+
 	spin_lock_irqsave(&ar724x_pci_lock, flags);
 
 	switch (size) {
 	case 1:
-		addr = (AR724X_PCI_DEV_BASE + where) & ~3;
+		addr = where & ~3;
 		mask = 0xff000000 >> ((where % 4)*8);
-		tval = reg_read(addr);
+		tval = __raw_readl(base + addr);
 		tval = tval & ~mask;
 		tval |= (value << ((4 - (where % 4))*8)) & mask;
-		reg_write(addr, tval);
+		__raw_writel(tval, base + addr);
 		break;
 	case 2:
-		addr = (AR724X_PCI_DEV_BASE + where) & ~3;
+		addr = where & ~3;
 		mask = 0xffff0000 >> ((where % 4)*8);
-		tval = reg_read(addr);
+		tval = __raw_readl(base + addr);
 		tval = tval & ~mask;
 		tval |= (value << ((4 - (where % 4))*8)) & mask;
-		reg_write(addr, tval);
+		__raw_writel(tval, base + addr);
 		break;
 	case 4:
-		reg_write((AR724X_PCI_DEV_BASE + where), value);
+		__raw_writel(value, (base + where));
 		break;
 	default:
 		spin_unlock_irqrestore(&ar724x_pci_lock, flags);
@@ -133,6 +138,11 @@ static struct pci_controller ar724x_pci_controller = {
 
 int __init ar724x_pcibios_init(void)
 {
+	ar724x_pci_devcfg_base = ioremap(AR724X_PCI_CFG_BASE,
+					 AR724X_PCI_CFG_SIZE);
+	if (ar724x_pci_devcfg_base == NULL)
+		return -ENOMEM;
+
 	register_pci_controller(&ar724x_pci_controller);
 
 	return PCIBIOS_SUCCESSFUL;

commit d624bd3cf7835612b25b9ec8db4002624c2dbb32
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Mar 14 10:29:26 2012 +0100

    MIPS: ath79: replace ath724x to ar724x
    
    Replace the 'ath724x' to 'ar724x' in function, variable and
    structure names to reflect the name of the real SoC.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Acked-by: Ren√© Bolldorf <xsecute@googlemail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3490/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
index ebefc165fae6..772d12c5fc9e 100644
--- a/arch/mips/pci/pci-ar724x.c
+++ b/arch/mips/pci/pci-ar724x.c
@@ -14,13 +14,13 @@
 #define reg_read(_phys)		(*(unsigned int *) KSEG1ADDR(_phys))
 #define reg_write(_phys, _val)	((*(unsigned int *) KSEG1ADDR(_phys)) = (_val))
 
-#define ATH724X_PCI_DEV_BASE	0x14000000
-#define ATH724X_PCI_MEM_BASE	0x10000000
-#define ATH724X_PCI_MEM_SIZE	0x08000000
+#define AR724X_PCI_DEV_BASE	0x14000000
+#define AR724X_PCI_MEM_BASE	0x10000000
+#define AR724X_PCI_MEM_SIZE	0x08000000
 
-static DEFINE_SPINLOCK(ath724x_pci_lock);
+static DEFINE_SPINLOCK(ar724x_pci_lock);
 
-static int ath724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
+static int ar724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 			    int size, uint32_t *value)
 {
 	unsigned long flags, addr, tval, mask;
@@ -31,38 +31,38 @@ static int ath724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
 	if (where & (size - 1))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
-	spin_lock_irqsave(&ath724x_pci_lock, flags);
+	spin_lock_irqsave(&ar724x_pci_lock, flags);
 
 	switch (size) {
 	case 1:
 		addr = where & ~3;
 		mask = 0xff000000 >> ((where % 4) * 8);
-		tval = reg_read(ATH724X_PCI_DEV_BASE + addr);
+		tval = reg_read(AR724X_PCI_DEV_BASE + addr);
 		tval = tval & ~mask;
 		*value = (tval >> ((4 - (where % 4))*8));
 		break;
 	case 2:
 		addr = where & ~3;
 		mask = 0xffff0000 >> ((where % 4)*8);
-		tval = reg_read(ATH724X_PCI_DEV_BASE + addr);
+		tval = reg_read(AR724X_PCI_DEV_BASE + addr);
 		tval = tval & ~mask;
 		*value = (tval >> ((4 - (where % 4))*8));
 		break;
 	case 4:
-		*value = reg_read(ATH724X_PCI_DEV_BASE + where);
+		*value = reg_read(AR724X_PCI_DEV_BASE + where);
 		break;
 	default:
-		spin_unlock_irqrestore(&ath724x_pci_lock, flags);
+		spin_unlock_irqrestore(&ar724x_pci_lock, flags);
 
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 	}
 
-	spin_unlock_irqrestore(&ath724x_pci_lock, flags);
+	spin_unlock_irqrestore(&ar724x_pci_lock, flags);
 
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static int ath724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
+static int ar724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 			     int size, uint32_t value)
 {
 	unsigned long flags, tval, addr, mask;
@@ -73,11 +73,11 @@ static int ath724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 	if (where & (size - 1))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
-	spin_lock_irqsave(&ath724x_pci_lock, flags);
+	spin_lock_irqsave(&ar724x_pci_lock, flags);
 
 	switch (size) {
 	case 1:
-		addr = (ATH724X_PCI_DEV_BASE + where) & ~3;
+		addr = (AR724X_PCI_DEV_BASE + where) & ~3;
 		mask = 0xff000000 >> ((where % 4)*8);
 		tval = reg_read(addr);
 		tval = tval & ~mask;
@@ -85,7 +85,7 @@ static int ath724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 		reg_write(addr, tval);
 		break;
 	case 2:
-		addr = (ATH724X_PCI_DEV_BASE + where) & ~3;
+		addr = (AR724X_PCI_DEV_BASE + where) & ~3;
 		mask = 0xffff0000 >> ((where % 4)*8);
 		tval = reg_read(addr);
 		tval = tval & ~mask;
@@ -93,47 +93,47 @@ static int ath724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
 		reg_write(addr, tval);
 		break;
 	case 4:
-		reg_write((ATH724X_PCI_DEV_BASE + where), value);
+		reg_write((AR724X_PCI_DEV_BASE + where), value);
 		break;
 	default:
-		spin_unlock_irqrestore(&ath724x_pci_lock, flags);
+		spin_unlock_irqrestore(&ar724x_pci_lock, flags);
 
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 	}
 
-	spin_unlock_irqrestore(&ath724x_pci_lock, flags);
+	spin_unlock_irqrestore(&ar724x_pci_lock, flags);
 
 	return PCIBIOS_SUCCESSFUL;
 }
 
-static struct pci_ops ath724x_pci_ops = {
-	.read	= ath724x_pci_read,
-	.write	= ath724x_pci_write,
+static struct pci_ops ar724x_pci_ops = {
+	.read	= ar724x_pci_read,
+	.write	= ar724x_pci_write,
 };
 
-static struct resource ath724x_io_resource = {
+static struct resource ar724x_io_resource = {
 	.name   = "PCI IO space",
 	.start  = 0,
 	.end    = 0,
 	.flags  = IORESOURCE_IO,
 };
 
-static struct resource ath724x_mem_resource = {
+static struct resource ar724x_mem_resource = {
 	.name   = "PCI memory space",
-	.start  = ATH724X_PCI_MEM_BASE,
-	.end    = ATH724X_PCI_MEM_BASE + ATH724X_PCI_MEM_SIZE - 1,
+	.start  = AR724X_PCI_MEM_BASE,
+	.end    = AR724X_PCI_MEM_BASE + AR724X_PCI_MEM_SIZE - 1,
 	.flags  = IORESOURCE_MEM,
 };
 
-static struct pci_controller ath724x_pci_controller = {
-	.pci_ops        = &ath724x_pci_ops,
-	.io_resource    = &ath724x_io_resource,
-	.mem_resource	= &ath724x_mem_resource,
+static struct pci_controller ar724x_pci_controller = {
+	.pci_ops        = &ar724x_pci_ops,
+	.io_resource    = &ar724x_io_resource,
+	.mem_resource	= &ar724x_mem_resource,
 };
 
-int __init ath724x_pcibios_init(void)
+int __init ar724x_pcibios_init(void)
 {
-	register_pci_controller(&ath724x_pci_controller);
+	register_pci_controller(&ar724x_pci_controller);
 
 	return PCIBIOS_SUCCESSFUL;
 }

commit 692183ef12c4ba9dcdc9a54065ca92072cd79493
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Wed Mar 14 10:29:25 2012 +0100

    MIPS: ath79: rename pci-ath724x.c to make it reflect the real SoC name
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Acked-by: Ren√© Bolldorf <xsecute@googlemail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3489/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-ar724x.c b/arch/mips/pci/pci-ar724x.c
new file mode 100644
index 000000000000..ebefc165fae6
--- /dev/null
+++ b/arch/mips/pci/pci-ar724x.c
@@ -0,0 +1,139 @@
+/*
+ *  Atheros 724x PCI support
+ *
+ *  Copyright (C) 2011 Ren√© Bolldorf <xsecute@googlemail.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify it
+ *  under the terms of the GNU General Public License version 2 as published
+ *  by the Free Software Foundation.
+ */
+
+#include <linux/pci.h>
+#include <asm/mach-ath79/pci.h>
+
+#define reg_read(_phys)		(*(unsigned int *) KSEG1ADDR(_phys))
+#define reg_write(_phys, _val)	((*(unsigned int *) KSEG1ADDR(_phys)) = (_val))
+
+#define ATH724X_PCI_DEV_BASE	0x14000000
+#define ATH724X_PCI_MEM_BASE	0x10000000
+#define ATH724X_PCI_MEM_SIZE	0x08000000
+
+static DEFINE_SPINLOCK(ath724x_pci_lock);
+
+static int ath724x_pci_read(struct pci_bus *bus, unsigned int devfn, int where,
+			    int size, uint32_t *value)
+{
+	unsigned long flags, addr, tval, mask;
+
+	if (devfn)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if (where & (size - 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	spin_lock_irqsave(&ath724x_pci_lock, flags);
+
+	switch (size) {
+	case 1:
+		addr = where & ~3;
+		mask = 0xff000000 >> ((where % 4) * 8);
+		tval = reg_read(ATH724X_PCI_DEV_BASE + addr);
+		tval = tval & ~mask;
+		*value = (tval >> ((4 - (where % 4))*8));
+		break;
+	case 2:
+		addr = where & ~3;
+		mask = 0xffff0000 >> ((where % 4)*8);
+		tval = reg_read(ATH724X_PCI_DEV_BASE + addr);
+		tval = tval & ~mask;
+		*value = (tval >> ((4 - (where % 4))*8));
+		break;
+	case 4:
+		*value = reg_read(ATH724X_PCI_DEV_BASE + where);
+		break;
+	default:
+		spin_unlock_irqrestore(&ath724x_pci_lock, flags);
+
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	}
+
+	spin_unlock_irqrestore(&ath724x_pci_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int ath724x_pci_write(struct pci_bus *bus, unsigned int devfn, int where,
+			     int size, uint32_t value)
+{
+	unsigned long flags, tval, addr, mask;
+
+	if (devfn)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if (where & (size - 1))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	spin_lock_irqsave(&ath724x_pci_lock, flags);
+
+	switch (size) {
+	case 1:
+		addr = (ATH724X_PCI_DEV_BASE + where) & ~3;
+		mask = 0xff000000 >> ((where % 4)*8);
+		tval = reg_read(addr);
+		tval = tval & ~mask;
+		tval |= (value << ((4 - (where % 4))*8)) & mask;
+		reg_write(addr, tval);
+		break;
+	case 2:
+		addr = (ATH724X_PCI_DEV_BASE + where) & ~3;
+		mask = 0xffff0000 >> ((where % 4)*8);
+		tval = reg_read(addr);
+		tval = tval & ~mask;
+		tval |= (value << ((4 - (where % 4))*8)) & mask;
+		reg_write(addr, tval);
+		break;
+	case 4:
+		reg_write((ATH724X_PCI_DEV_BASE + where), value);
+		break;
+	default:
+		spin_unlock_irqrestore(&ath724x_pci_lock, flags);
+
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+	}
+
+	spin_unlock_irqrestore(&ath724x_pci_lock, flags);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static struct pci_ops ath724x_pci_ops = {
+	.read	= ath724x_pci_read,
+	.write	= ath724x_pci_write,
+};
+
+static struct resource ath724x_io_resource = {
+	.name   = "PCI IO space",
+	.start  = 0,
+	.end    = 0,
+	.flags  = IORESOURCE_IO,
+};
+
+static struct resource ath724x_mem_resource = {
+	.name   = "PCI memory space",
+	.start  = ATH724X_PCI_MEM_BASE,
+	.end    = ATH724X_PCI_MEM_BASE + ATH724X_PCI_MEM_SIZE - 1,
+	.flags  = IORESOURCE_MEM,
+};
+
+static struct pci_controller ath724x_pci_controller = {
+	.pci_ops        = &ath724x_pci_ops,
+	.io_resource    = &ath724x_io_resource,
+	.mem_resource	= &ath724x_mem_resource,
+};
+
+int __init ath724x_pcibios_init(void)
+{
+	register_pci_controller(&ath724x_pci_controller);
+
+	return PCIBIOS_SUCCESSFUL;
+}
