commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/mips/pci/pci-bcm63xx.c b/arch/mips/pci/pci-bcm63xx.c
index 151d9b5870bb..5548365605c0 100644
--- a/arch/mips/pci/pci-bcm63xx.c
+++ b/arch/mips/pci/pci-bcm63xx.c
@@ -221,7 +221,7 @@ static int __init bcm63xx_register_pci(void)
 	 * a spinlock for each io access, so this is currently kind of
 	 * broken on SMP.
 	 */
-	pci_iospace_start = ioremap_nocache(BCM_PCI_IO_BASE_PA, 4);
+	pci_iospace_start = ioremap(BCM_PCI_IO_BASE_PA, 4);
 	if (!pci_iospace_start)
 		return -ENOMEM;
 

commit 7b9334215f53135fb9cbdf0b44833cbc8e7d57b2
Author: Florian Fainelli <florian@openwrt.org>
Date:   Tue Jun 18 16:55:40 2013 +0000

    MIPS: BCM63XX: add support for BCM3368 Cable Modem
    
    The Broadcom BCM3368 Cable Modem SoC is extremely similar to the
    existing BCM63xx DSL SoCs, in particular BCM6358, therefore little effort
    in the existing code base is required to get it supported. This patch adds
    support for the following on-chip peripherals:
    
    - two UARTS
    - GPIO
    - Ethernet
    - SPI
    - PCI
    - NOR Flash
    
    The most noticeable difference with 3368 is that it has its peripheral
    register at 0xfff8_0000 we check that separately in ioremap.h. Since
    3368 is identical to 6358 for its clock and reset bits, we use them
    verbatim.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Cc: cernekee@gmail.com
    Cc: jogo@openwrt.org
    Patchwork: https://patchwork.linux-mips.org/patch/5499/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-bcm63xx.c b/arch/mips/pci/pci-bcm63xx.c
index 2eb954239bc5..151d9b5870bb 100644
--- a/arch/mips/pci/pci-bcm63xx.c
+++ b/arch/mips/pci/pci-bcm63xx.c
@@ -266,7 +266,7 @@ static int __init bcm63xx_register_pci(void)
 	/* setup PCI to local bus access, used by PCI device to target
 	 * local RAM while bus mastering */
 	bcm63xx_int_cfg_writel(0, PCI_BASE_ADDRESS_3);
-	if (BCMCPU_IS_6358() || BCMCPU_IS_6368())
+	if (BCMCPU_IS_3368() || BCMCPU_IS_6358() || BCMCPU_IS_6368())
 		val = MPI_SP0_REMAP_ENABLE_MASK;
 	else
 		val = 0;
@@ -338,6 +338,7 @@ static int __init bcm63xx_pci_init(void)
 	case BCM6328_CPU_ID:
 	case BCM6362_CPU_ID:
 		return bcm63xx_register_pcie();
+	case BCM3368_CPU_ID:
 	case BCM6348_CPU_ID:
 	case BCM6358_CPU_ID:
 	case BCM6368_CPU_ID:

commit a156ba61f0b959a803d7a6941a52c5453524c99b
Author: Jonas Gorski <jogo@openwrt.org>
Date:   Thu Mar 21 14:03:19 2013 +0000

    MIPS: BCM63XX: enable pcie for BCM6362
    
    The PCIe controller is almost the same as the BCM6328 one, with only
    the SERDES register being at a different location.
    
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/5011/
    Acked-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci-bcm63xx.c b/arch/mips/pci/pci-bcm63xx.c
index 88e781c6b5ba..2eb954239bc5 100644
--- a/arch/mips/pci/pci-bcm63xx.c
+++ b/arch/mips/pci/pci-bcm63xx.c
@@ -121,11 +121,17 @@ void __iomem *pci_iospace_start;
 static void __init bcm63xx_reset_pcie(void)
 {
 	u32 val;
+	u32 reg;
 
 	/* enable SERDES */
-	val = bcm_misc_readl(MISC_SERDES_CTRL_REG);
+	if (BCMCPU_IS_6328())
+		reg = MISC_SERDES_CTRL_6328_REG;
+	else
+		reg = MISC_SERDES_CTRL_6362_REG;
+
+	val = bcm_misc_readl(reg);
 	val |= SERDES_PCIE_EN | SERDES_PCIE_EXD_EN;
-	bcm_misc_writel(val, MISC_SERDES_CTRL_REG);
+	bcm_misc_writel(val, reg);
 
 	/* reset the PCIe core */
 	bcm63xx_core_set_reset(BCM63XX_RESET_PCIE, 1);
@@ -330,6 +336,7 @@ static int __init bcm63xx_pci_init(void)
 
 	switch (bcm63xx_get_cpu_id()) {
 	case BCM6328_CPU_ID:
+	case BCM6362_CPU_ID:
 		return bcm63xx_register_pcie();
 	case BCM6348_CPU_ID:
 	case BCM6358_CPU_ID:

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-bcm63xx.c b/arch/mips/pci/pci-bcm63xx.c
index ca179b6ff39b..88e781c6b5ba 100644
--- a/arch/mips/pci/pci-bcm63xx.c
+++ b/arch/mips/pci/pci-bcm63xx.c
@@ -25,21 +25,21 @@
 int bcm63xx_pci_enabled;
 
 static struct resource bcm_pci_mem_resource = {
-	.name   = "bcm63xx PCI memory space",
-	.start  = BCM_PCI_MEM_BASE_PA,
-	.end    = BCM_PCI_MEM_END_PA,
-	.flags  = IORESOURCE_MEM
+	.name	= "bcm63xx PCI memory space",
+	.start	= BCM_PCI_MEM_BASE_PA,
+	.end	= BCM_PCI_MEM_END_PA,
+	.flags	= IORESOURCE_MEM
 };
 
 static struct resource bcm_pci_io_resource = {
-	.name   = "bcm63xx PCI IO space",
-	.start  = BCM_PCI_IO_BASE_PA,
+	.name	= "bcm63xx PCI IO space",
+	.start	= BCM_PCI_IO_BASE_PA,
 #ifdef CONFIG_CARDBUS
-	.end    = BCM_PCI_IO_HALF_PA,
+	.end	= BCM_PCI_IO_HALF_PA,
 #else
-	.end    = BCM_PCI_IO_END_PA,
+	.end	= BCM_PCI_IO_END_PA,
 #endif
-	.flags  = IORESOURCE_IO
+	.flags	= IORESOURCE_IO
 };
 
 struct pci_controller bcm63xx_controller = {
@@ -55,17 +55,17 @@ struct pci_controller bcm63xx_controller = {
  */
 #ifdef CONFIG_CARDBUS
 static struct resource bcm_cb_mem_resource = {
-	.name   = "bcm63xx Cardbus memory space",
-	.start  = BCM_CB_MEM_BASE_PA,
-	.end    = BCM_CB_MEM_END_PA,
-	.flags  = IORESOURCE_MEM
+	.name	= "bcm63xx Cardbus memory space",
+	.start	= BCM_CB_MEM_BASE_PA,
+	.end	= BCM_CB_MEM_END_PA,
+	.flags	= IORESOURCE_MEM
 };
 
 static struct resource bcm_cb_io_resource = {
-	.name   = "bcm63xx Cardbus IO space",
-	.start  = BCM_PCI_IO_HALF_PA + 1,
-	.end    = BCM_PCI_IO_END_PA,
-	.flags  = IORESOURCE_IO
+	.name	= "bcm63xx Cardbus IO space",
+	.start	= BCM_PCI_IO_HALF_PA + 1,
+	.end	= BCM_PCI_IO_END_PA,
+	.flags	= IORESOURCE_IO
 };
 
 struct pci_controller bcm63xx_cb_controller = {
@@ -76,17 +76,17 @@ struct pci_controller bcm63xx_cb_controller = {
 #endif
 
 static struct resource bcm_pcie_mem_resource = {
-	.name   = "bcm63xx PCIe memory space",
-	.start  = BCM_PCIE_MEM_BASE_PA,
-	.end    = BCM_PCIE_MEM_END_PA,
-	.flags  = IORESOURCE_MEM,
+	.name	= "bcm63xx PCIe memory space",
+	.start	= BCM_PCIE_MEM_BASE_PA,
+	.end	= BCM_PCIE_MEM_END_PA,
+	.flags	= IORESOURCE_MEM,
 };
 
 static struct resource bcm_pcie_io_resource = {
-	.name   = "bcm63xx PCIe IO space",
-	.start  = 0,
-	.end    = 0,
-	.flags  = 0,
+	.name	= "bcm63xx PCIe IO space",
+	.start	= 0,
+	.end	= 0,
+	.flags	= 0,
 };
 
 struct pci_controller bcm63xx_pcie_controller = {
@@ -111,7 +111,7 @@ static void bcm63xx_int_cfg_writel(u32 val, u32 reg)
 	u32 tmp;
 
 	tmp = reg & MPI_PCICFGCTL_CFGADDR_MASK;
-	tmp |=  MPI_PCICFGCTL_WRITEEN_MASK;
+	tmp |=	MPI_PCICFGCTL_WRITEEN_MASK;
 	bcm_mpi_writel(tmp, MPI_PCICFGCTL_REG);
 	bcm_mpi_writel(val, MPI_PCICFGDATA_REG);
 }
@@ -211,7 +211,7 @@ static int __init bcm63xx_register_pci(void)
 	 * first bytes to access it from CPU.
 	 *
 	 * this means that  no io access from CPU  should happen while
-	 * we do a configuration cycle,  but there's no way we can add
+	 * we do a configuration cycle,	 but there's no way we can add
 	 * a spinlock for each io access, so this is currently kind of
 	 * broken on SMP.
 	 */
@@ -244,9 +244,9 @@ static int __init bcm63xx_register_pci(void)
 	bcm_mpi_writel(0, MPI_L2PMEMREMAP2_REG);
 #endif
 
-	/* setup local bus  to PCI access (IO memory),  we have only 1
-	 * IO window  for both PCI  and cardbus, but it  cannot handle
-	 * both  at the  same time,  assume standard  PCI for  now, if
+	/* setup local bus  to PCI access (IO memory),	we have only 1
+	 * IO window  for both PCI  and cardbus, but it	 cannot handle
+	 * both	 at the	 same time,  assume standard  PCI for  now, if
 	 * cardbus card has  IO zone, PCI fixup will  change window to
 	 * cardbus */
 	val = BCM_PCI_IO_BASE_PA & MPI_L2P_BASE_MASK;
@@ -284,7 +284,7 @@ static int __init bcm63xx_register_pci(void)
 		bcm_mpi_writel(0, MPI_SP1_RANGE_REG);
 	}
 
-	/* change  host bridge  retry  counter to  infinite number  of
+	/* change  host bridge	retry  counter to  infinite number  of
 	 * retry,  needed for  some broadcom  wifi cards  with Silicon
 	 * Backplane bus where access to srom seems very slow  */
 	val = bcm63xx_int_cfg_readl(BCMPCI_REG_TIMERS);

commit ba00e2e5c24f447fb09437a99df697787103f0cd
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Sun Oct 28 12:17:55 2012 +0000

    MIPS: BCM63XX: use the new reset helper
    
    Use the new reset helper where appropriate.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Patchwork: http://patchwork.linux-mips.org/patch/4453
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci-bcm63xx.c b/arch/mips/pci/pci-bcm63xx.c
index fa8c320936fe..ca179b6ff39b 100644
--- a/arch/mips/pci/pci-bcm63xx.c
+++ b/arch/mips/pci/pci-bcm63xx.c
@@ -14,6 +14,8 @@
 #include <linux/clk.h>
 #include <asm/bootinfo.h>
 
+#include <bcm63xx_reset.h>
+
 #include "pci-bcm63xx.h"
 
 /*
@@ -126,23 +128,14 @@ static void __init bcm63xx_reset_pcie(void)
 	bcm_misc_writel(val, MISC_SERDES_CTRL_REG);
 
 	/* reset the PCIe core */
-	val = bcm_perf_readl(PERF_SOFTRESET_6328_REG);
-
-	val &= ~SOFTRESET_6328_PCIE_MASK;
-	val &= ~SOFTRESET_6328_PCIE_CORE_MASK;
-	val &= ~SOFTRESET_6328_PCIE_HARD_MASK;
-	val &= ~SOFTRESET_6328_PCIE_EXT_MASK;
-	bcm_perf_writel(val, PERF_SOFTRESET_6328_REG);
+	bcm63xx_core_set_reset(BCM63XX_RESET_PCIE, 1);
+	bcm63xx_core_set_reset(BCM63XX_RESET_PCIE_EXT, 1);
 	mdelay(10);
 
-	val |= SOFTRESET_6328_PCIE_MASK;
-	val |= SOFTRESET_6328_PCIE_CORE_MASK;
-	val |= SOFTRESET_6328_PCIE_HARD_MASK;
-	bcm_perf_writel(val, PERF_SOFTRESET_6328_REG);
+	bcm63xx_core_set_reset(BCM63XX_RESET_PCIE, 0);
 	mdelay(10);
 
-	val |= SOFTRESET_6328_PCIE_EXT_MASK;
-	bcm_perf_writel(val, PERF_SOFTRESET_6328_REG);
+	bcm63xx_core_set_reset(BCM63XX_RESET_PCIE_EXT, 0);
 	mdelay(200);
 }
 

commit f2d1035e956052d29c83fe8f8da0d056af6d221a
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Sun Oct 28 11:49:53 2012 +0000

    MIPS: BCM63XX: add and use a clock for PCIe
    
    Add a PCIe clock and use that instead of directly touching the clock
    control register. While at it, fail if there is no such clock.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Acked-by: Florian Fainelli <florian@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4452
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci-bcm63xx.c b/arch/mips/pci/pci-bcm63xx.c
index 8a48139d219c..fa8c320936fe 100644
--- a/arch/mips/pci/pci-bcm63xx.c
+++ b/arch/mips/pci/pci-bcm63xx.c
@@ -11,6 +11,7 @@
 #include <linux/kernel.h>
 #include <linux/init.h>
 #include <linux/delay.h>
+#include <linux/clk.h>
 #include <asm/bootinfo.h>
 
 #include "pci-bcm63xx.h"
@@ -119,11 +120,6 @@ static void __init bcm63xx_reset_pcie(void)
 {
 	u32 val;
 
-	/* enable clock */
-	val = bcm_perf_readl(PERF_CKCTL_REG);
-	val |= CKCTL_6328_PCIE_EN;
-	bcm_perf_writel(val, PERF_CKCTL_REG);
-
 	/* enable SERDES */
 	val = bcm_misc_readl(MISC_SERDES_CTRL_REG);
 	val |= SERDES_PCIE_EN | SERDES_PCIE_EXD_EN;
@@ -150,10 +146,19 @@ static void __init bcm63xx_reset_pcie(void)
 	mdelay(200);
 }
 
+static struct clk *pcie_clk;
+
 static int __init bcm63xx_register_pcie(void)
 {
 	u32 val;
 
+	/* enable clock */
+	pcie_clk = clk_get(NULL, "pcie");
+	if (IS_ERR_OR_NULL(pcie_clk))
+		return -ENODEV;
+
+	clk_prepare_enable(pcie_clk);
+
 	bcm63xx_reset_pcie();
 
 	/* configure the PCIe bridge */

commit 19c860d932de520017c9b2d88cd9dff90b71ba36
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Tue Jul 24 16:33:13 2012 +0200

    MIPS: BCM63XX: Add PCIe Support for BCM6328
    
    Add support for the PCIe port found on BCM6328.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: Maxime Bizon <mbizon@freebox.fr>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/3956/
    Reviewed-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-bcm63xx.c b/arch/mips/pci/pci-bcm63xx.c
index a2b6d55a2492..8a48139d219c 100644
--- a/arch/mips/pci/pci-bcm63xx.c
+++ b/arch/mips/pci/pci-bcm63xx.c
@@ -10,6 +10,7 @@
 #include <linux/pci.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
+#include <linux/delay.h>
 #include <asm/bootinfo.h>
 
 #include "pci-bcm63xx.h"
@@ -71,6 +72,26 @@ struct pci_controller bcm63xx_cb_controller = {
 };
 #endif
 
+static struct resource bcm_pcie_mem_resource = {
+	.name   = "bcm63xx PCIe memory space",
+	.start  = BCM_PCIE_MEM_BASE_PA,
+	.end    = BCM_PCIE_MEM_END_PA,
+	.flags  = IORESOURCE_MEM,
+};
+
+static struct resource bcm_pcie_io_resource = {
+	.name   = "bcm63xx PCIe IO space",
+	.start  = 0,
+	.end    = 0,
+	.flags  = 0,
+};
+
+struct pci_controller bcm63xx_pcie_controller = {
+	.pci_ops	= &bcm63xx_pcie_ops,
+	.io_resource	= &bcm_pcie_io_resource,
+	.mem_resource	= &bcm_pcie_mem_resource,
+};
+
 static u32 bcm63xx_int_cfg_readl(u32 reg)
 {
 	u32 tmp;
@@ -94,6 +115,95 @@ static void bcm63xx_int_cfg_writel(u32 val, u32 reg)
 
 void __iomem *pci_iospace_start;
 
+static void __init bcm63xx_reset_pcie(void)
+{
+	u32 val;
+
+	/* enable clock */
+	val = bcm_perf_readl(PERF_CKCTL_REG);
+	val |= CKCTL_6328_PCIE_EN;
+	bcm_perf_writel(val, PERF_CKCTL_REG);
+
+	/* enable SERDES */
+	val = bcm_misc_readl(MISC_SERDES_CTRL_REG);
+	val |= SERDES_PCIE_EN | SERDES_PCIE_EXD_EN;
+	bcm_misc_writel(val, MISC_SERDES_CTRL_REG);
+
+	/* reset the PCIe core */
+	val = bcm_perf_readl(PERF_SOFTRESET_6328_REG);
+
+	val &= ~SOFTRESET_6328_PCIE_MASK;
+	val &= ~SOFTRESET_6328_PCIE_CORE_MASK;
+	val &= ~SOFTRESET_6328_PCIE_HARD_MASK;
+	val &= ~SOFTRESET_6328_PCIE_EXT_MASK;
+	bcm_perf_writel(val, PERF_SOFTRESET_6328_REG);
+	mdelay(10);
+
+	val |= SOFTRESET_6328_PCIE_MASK;
+	val |= SOFTRESET_6328_PCIE_CORE_MASK;
+	val |= SOFTRESET_6328_PCIE_HARD_MASK;
+	bcm_perf_writel(val, PERF_SOFTRESET_6328_REG);
+	mdelay(10);
+
+	val |= SOFTRESET_6328_PCIE_EXT_MASK;
+	bcm_perf_writel(val, PERF_SOFTRESET_6328_REG);
+	mdelay(200);
+}
+
+static int __init bcm63xx_register_pcie(void)
+{
+	u32 val;
+
+	bcm63xx_reset_pcie();
+
+	/* configure the PCIe bridge */
+	val = bcm_pcie_readl(PCIE_BRIDGE_OPT1_REG);
+	val |= OPT1_RD_BE_OPT_EN;
+	val |= OPT1_RD_REPLY_BE_FIX_EN;
+	val |= OPT1_PCIE_BRIDGE_HOLE_DET_EN;
+	val |= OPT1_L1_INT_STATUS_MASK_POL;
+	bcm_pcie_writel(val, PCIE_BRIDGE_OPT1_REG);
+
+	/* setup the interrupts */
+	val = bcm_pcie_readl(PCIE_BRIDGE_RC_INT_MASK_REG);
+	val |= PCIE_RC_INT_A | PCIE_RC_INT_B | PCIE_RC_INT_C | PCIE_RC_INT_D;
+	bcm_pcie_writel(val, PCIE_BRIDGE_RC_INT_MASK_REG);
+
+	val = bcm_pcie_readl(PCIE_BRIDGE_OPT2_REG);
+	/* enable credit checking and error checking */
+	val |= OPT2_TX_CREDIT_CHK_EN;
+	val |= OPT2_UBUS_UR_DECODE_DIS;
+
+	/* set device bus/func for the pcie device */
+	val |= (PCIE_BUS_DEVICE << OPT2_CFG_TYPE1_BUS_NO_SHIFT);
+	val |= OPT2_CFG_TYPE1_BD_SEL;
+	bcm_pcie_writel(val, PCIE_BRIDGE_OPT2_REG);
+
+	/* setup class code as bridge */
+	val = bcm_pcie_readl(PCIE_IDVAL3_REG);
+	val &= ~IDVAL3_CLASS_CODE_MASK;
+	val |= (PCI_CLASS_BRIDGE_PCI << IDVAL3_SUBCLASS_SHIFT);
+	bcm_pcie_writel(val, PCIE_IDVAL3_REG);
+
+	/* disable bar1 size */
+	val = bcm_pcie_readl(PCIE_CONFIG2_REG);
+	val &= ~CONFIG2_BAR1_SIZE_MASK;
+	bcm_pcie_writel(val, PCIE_CONFIG2_REG);
+
+	/* set bar0 to little endian */
+	val = (BCM_PCIE_MEM_BASE_PA >> 20) << BASEMASK_BASE_SHIFT;
+	val |= (BCM_PCIE_MEM_BASE_PA >> 20) << BASEMASK_MASK_SHIFT;
+	val |= BASEMASK_REMAP_EN;
+	bcm_pcie_writel(val, PCIE_BRIDGE_BAR0_BASEMASK_REG);
+
+	val = (BCM_PCIE_MEM_BASE_PA >> 20) << REBASE_ADDR_BASE_SHIFT;
+	bcm_pcie_writel(val, PCIE_BRIDGE_BAR0_REBASE_ADDR_REG);
+
+	register_pci_controller(&bcm63xx_pcie_controller);
+
+	return 0;
+}
+
 static int __init bcm63xx_register_pci(void)
 {
 	unsigned int mem_size;
@@ -221,6 +331,8 @@ static int __init bcm63xx_pci_init(void)
 		return -ENODEV;
 
 	switch (bcm63xx_get_cpu_id()) {
+	case BCM6328_CPU_ID:
+		return bcm63xx_register_pcie();
 	case BCM6348_CPU_ID:
 	case BCM6358_CPU_ID:
 	case BCM6368_CPU_ID:

commit 76f42fe8117c85fced0135b23835890cfa41a47b
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Tue Jul 24 16:33:13 2012 +0200

    MIPS: BCM63XX: Move the PCI initialization into its own function
    
    Also make the cpu check a bit more explicit.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: Maxime Bizon <mbizon@freebox.fr>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/3953/
    Reviewed-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-bcm63xx.c b/arch/mips/pci/pci-bcm63xx.c
index 39eb7c417e2f..a2b6d55a2492 100644
--- a/arch/mips/pci/pci-bcm63xx.c
+++ b/arch/mips/pci/pci-bcm63xx.c
@@ -94,17 +94,10 @@ static void bcm63xx_int_cfg_writel(u32 val, u32 reg)
 
 void __iomem *pci_iospace_start;
 
-static int __init bcm63xx_pci_init(void)
+static int __init bcm63xx_register_pci(void)
 {
 	unsigned int mem_size;
 	u32 val;
-
-	if (!BCMCPU_IS_6348() && !BCMCPU_IS_6358() && !BCMCPU_IS_6368())
-		return -ENODEV;
-
-	if (!bcm63xx_pci_enabled)
-		return -ENODEV;
-
 	/*
 	 * configuration  access are  done through  IO space,  remap 4
 	 * first bytes to access it from CPU.
@@ -221,4 +214,20 @@ static int __init bcm63xx_pci_init(void)
 	return 0;
 }
 
+
+static int __init bcm63xx_pci_init(void)
+{
+	if (!bcm63xx_pci_enabled)
+		return -ENODEV;
+
+	switch (bcm63xx_get_cpu_id()) {
+	case BCM6348_CPU_ID:
+	case BCM6358_CPU_ID:
+	case BCM6368_CPU_ID:
+		return bcm63xx_register_pci();
+	default:
+		return -ENODEV;
+	}
+}
+
 arch_initcall(bcm63xx_pci_init);

commit 04712f3ff6e3a42ef658b55b0f99478f4f0682e3
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Fri Nov 4 19:09:35 2011 +0100

    MIPS: BCM63XX: Add support for bcm6368 CPU.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2892/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-bcm63xx.c b/arch/mips/pci/pci-bcm63xx.c
index 82e0fde1dba0..39eb7c417e2f 100644
--- a/arch/mips/pci/pci-bcm63xx.c
+++ b/arch/mips/pci/pci-bcm63xx.c
@@ -99,7 +99,7 @@ static int __init bcm63xx_pci_init(void)
 	unsigned int mem_size;
 	u32 val;
 
-	if (!BCMCPU_IS_6348() && !BCMCPU_IS_6358())
+	if (!BCMCPU_IS_6348() && !BCMCPU_IS_6358() && !BCMCPU_IS_6368())
 		return -ENODEV;
 
 	if (!bcm63xx_pci_enabled)
@@ -159,7 +159,7 @@ static int __init bcm63xx_pci_init(void)
 	/* setup PCI to local bus access, used by PCI device to target
 	 * local RAM while bus mastering */
 	bcm63xx_int_cfg_writel(0, PCI_BASE_ADDRESS_3);
-	if (BCMCPU_IS_6358())
+	if (BCMCPU_IS_6358() || BCMCPU_IS_6368())
 		val = MPI_SP0_REMAP_ENABLE_MASK;
 	else
 		val = 0;

commit e7300d04bd0809eb7ea10a2ed8c729459f816e36
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Tue Aug 18 13:23:37 2009 +0100

    MIPS: BCM63xx: Add support for the Broadcom BCM63xx family of SOCs.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-bcm63xx.c b/arch/mips/pci/pci-bcm63xx.c
new file mode 100644
index 000000000000..82e0fde1dba0
--- /dev/null
+++ b/arch/mips/pci/pci-bcm63xx.c
@@ -0,0 +1,224 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2008 Maxime Bizon <mbizon@freebox.fr>
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <asm/bootinfo.h>
+
+#include "pci-bcm63xx.h"
+
+/*
+ * Allow PCI to be disabled at runtime depending on board nvram
+ * configuration
+ */
+int bcm63xx_pci_enabled;
+
+static struct resource bcm_pci_mem_resource = {
+	.name   = "bcm63xx PCI memory space",
+	.start  = BCM_PCI_MEM_BASE_PA,
+	.end    = BCM_PCI_MEM_END_PA,
+	.flags  = IORESOURCE_MEM
+};
+
+static struct resource bcm_pci_io_resource = {
+	.name   = "bcm63xx PCI IO space",
+	.start  = BCM_PCI_IO_BASE_PA,
+#ifdef CONFIG_CARDBUS
+	.end    = BCM_PCI_IO_HALF_PA,
+#else
+	.end    = BCM_PCI_IO_END_PA,
+#endif
+	.flags  = IORESOURCE_IO
+};
+
+struct pci_controller bcm63xx_controller = {
+	.pci_ops	= &bcm63xx_pci_ops,
+	.io_resource	= &bcm_pci_io_resource,
+	.mem_resource	= &bcm_pci_mem_resource,
+};
+
+/*
+ * We handle cardbus  via a fake Cardbus bridge,  memory and io spaces
+ * have to be  clearly separated from PCI one  since we have different
+ * memory decoder.
+ */
+#ifdef CONFIG_CARDBUS
+static struct resource bcm_cb_mem_resource = {
+	.name   = "bcm63xx Cardbus memory space",
+	.start  = BCM_CB_MEM_BASE_PA,
+	.end    = BCM_CB_MEM_END_PA,
+	.flags  = IORESOURCE_MEM
+};
+
+static struct resource bcm_cb_io_resource = {
+	.name   = "bcm63xx Cardbus IO space",
+	.start  = BCM_PCI_IO_HALF_PA + 1,
+	.end    = BCM_PCI_IO_END_PA,
+	.flags  = IORESOURCE_IO
+};
+
+struct pci_controller bcm63xx_cb_controller = {
+	.pci_ops	= &bcm63xx_cb_ops,
+	.io_resource	= &bcm_cb_io_resource,
+	.mem_resource	= &bcm_cb_mem_resource,
+};
+#endif
+
+static u32 bcm63xx_int_cfg_readl(u32 reg)
+{
+	u32 tmp;
+
+	tmp = reg & MPI_PCICFGCTL_CFGADDR_MASK;
+	tmp |= MPI_PCICFGCTL_WRITEEN_MASK;
+	bcm_mpi_writel(tmp, MPI_PCICFGCTL_REG);
+	iob();
+	return bcm_mpi_readl(MPI_PCICFGDATA_REG);
+}
+
+static void bcm63xx_int_cfg_writel(u32 val, u32 reg)
+{
+	u32 tmp;
+
+	tmp = reg & MPI_PCICFGCTL_CFGADDR_MASK;
+	tmp |=  MPI_PCICFGCTL_WRITEEN_MASK;
+	bcm_mpi_writel(tmp, MPI_PCICFGCTL_REG);
+	bcm_mpi_writel(val, MPI_PCICFGDATA_REG);
+}
+
+void __iomem *pci_iospace_start;
+
+static int __init bcm63xx_pci_init(void)
+{
+	unsigned int mem_size;
+	u32 val;
+
+	if (!BCMCPU_IS_6348() && !BCMCPU_IS_6358())
+		return -ENODEV;
+
+	if (!bcm63xx_pci_enabled)
+		return -ENODEV;
+
+	/*
+	 * configuration  access are  done through  IO space,  remap 4
+	 * first bytes to access it from CPU.
+	 *
+	 * this means that  no io access from CPU  should happen while
+	 * we do a configuration cycle,  but there's no way we can add
+	 * a spinlock for each io access, so this is currently kind of
+	 * broken on SMP.
+	 */
+	pci_iospace_start = ioremap_nocache(BCM_PCI_IO_BASE_PA, 4);
+	if (!pci_iospace_start)
+		return -ENOMEM;
+
+	/* setup local bus to PCI access (PCI memory) */
+	val = BCM_PCI_MEM_BASE_PA & MPI_L2P_BASE_MASK;
+	bcm_mpi_writel(val, MPI_L2PMEMBASE1_REG);
+	bcm_mpi_writel(~(BCM_PCI_MEM_SIZE - 1), MPI_L2PMEMRANGE1_REG);
+	bcm_mpi_writel(val | MPI_L2PREMAP_ENABLED_MASK, MPI_L2PMEMREMAP1_REG);
+
+	/* set Cardbus IDSEL (type 0 cfg access on primary bus for
+	 * this IDSEL will be done on Cardbus instead) */
+	val = bcm_pcmcia_readl(PCMCIA_C1_REG);
+	val &= ~PCMCIA_C1_CBIDSEL_MASK;
+	val |= (CARDBUS_PCI_IDSEL << PCMCIA_C1_CBIDSEL_SHIFT);
+	bcm_pcmcia_writel(val, PCMCIA_C1_REG);
+
+#ifdef CONFIG_CARDBUS
+	/* setup local bus to PCI access (Cardbus memory) */
+	val = BCM_CB_MEM_BASE_PA & MPI_L2P_BASE_MASK;
+	bcm_mpi_writel(val, MPI_L2PMEMBASE2_REG);
+	bcm_mpi_writel(~(BCM_CB_MEM_SIZE - 1), MPI_L2PMEMRANGE2_REG);
+	val |= MPI_L2PREMAP_ENABLED_MASK | MPI_L2PREMAP_IS_CARDBUS_MASK;
+	bcm_mpi_writel(val, MPI_L2PMEMREMAP2_REG);
+#else
+	/* disable second access windows */
+	bcm_mpi_writel(0, MPI_L2PMEMREMAP2_REG);
+#endif
+
+	/* setup local bus  to PCI access (IO memory),  we have only 1
+	 * IO window  for both PCI  and cardbus, but it  cannot handle
+	 * both  at the  same time,  assume standard  PCI for  now, if
+	 * cardbus card has  IO zone, PCI fixup will  change window to
+	 * cardbus */
+	val = BCM_PCI_IO_BASE_PA & MPI_L2P_BASE_MASK;
+	bcm_mpi_writel(val, MPI_L2PIOBASE_REG);
+	bcm_mpi_writel(~(BCM_PCI_IO_SIZE - 1), MPI_L2PIORANGE_REG);
+	bcm_mpi_writel(val | MPI_L2PREMAP_ENABLED_MASK, MPI_L2PIOREMAP_REG);
+
+	/* enable PCI related GPIO pins */
+	bcm_mpi_writel(MPI_LOCBUSCTL_EN_PCI_GPIO_MASK, MPI_LOCBUSCTL_REG);
+
+	/* setup PCI to local bus access, used by PCI device to target
+	 * local RAM while bus mastering */
+	bcm63xx_int_cfg_writel(0, PCI_BASE_ADDRESS_3);
+	if (BCMCPU_IS_6358())
+		val = MPI_SP0_REMAP_ENABLE_MASK;
+	else
+		val = 0;
+	bcm_mpi_writel(val, MPI_SP0_REMAP_REG);
+
+	bcm63xx_int_cfg_writel(0x0, PCI_BASE_ADDRESS_4);
+	bcm_mpi_writel(0, MPI_SP1_REMAP_REG);
+
+	mem_size = bcm63xx_get_memory_size();
+
+	/* 6348 before rev b0 exposes only 16 MB of RAM memory through
+	 * PCI, throw a warning if we have more memory */
+	if (BCMCPU_IS_6348() && (bcm63xx_get_cpu_rev() & 0xf0) == 0xa0) {
+		if (mem_size > (16 * 1024 * 1024))
+			printk(KERN_WARNING "bcm63xx: this CPU "
+			       "revision cannot handle more than 16MB "
+			       "of RAM for PCI bus mastering\n");
+	} else {
+		/* setup sp0 range to local RAM size */
+		bcm_mpi_writel(~(mem_size - 1), MPI_SP0_RANGE_REG);
+		bcm_mpi_writel(0, MPI_SP1_RANGE_REG);
+	}
+
+	/* change  host bridge  retry  counter to  infinite number  of
+	 * retry,  needed for  some broadcom  wifi cards  with Silicon
+	 * Backplane bus where access to srom seems very slow  */
+	val = bcm63xx_int_cfg_readl(BCMPCI_REG_TIMERS);
+	val &= ~REG_TIMER_RETRY_MASK;
+	bcm63xx_int_cfg_writel(val, BCMPCI_REG_TIMERS);
+
+	/* enable memory decoder and bus mastering */
+	val = bcm63xx_int_cfg_readl(PCI_COMMAND);
+	val |= (PCI_COMMAND_MEMORY | PCI_COMMAND_MASTER);
+	bcm63xx_int_cfg_writel(val, PCI_COMMAND);
+
+	/* enable read prefetching & disable byte swapping for bus
+	 * mastering transfers */
+	val = bcm_mpi_readl(MPI_PCIMODESEL_REG);
+	val &= ~MPI_PCIMODESEL_BAR1_NOSWAP_MASK;
+	val &= ~MPI_PCIMODESEL_BAR2_NOSWAP_MASK;
+	val &= ~MPI_PCIMODESEL_PREFETCH_MASK;
+	val |= (8 << MPI_PCIMODESEL_PREFETCH_SHIFT);
+	bcm_mpi_writel(val, MPI_PCIMODESEL_REG);
+
+	/* enable pci interrupt */
+	val = bcm_mpi_readl(MPI_LOCINT_REG);
+	val |= MPI_LOCINT_MASK(MPI_LOCINT_EXT_PCI_INT);
+	bcm_mpi_writel(val, MPI_LOCINT_REG);
+
+	register_pci_controller(&bcm63xx_controller);
+
+#ifdef CONFIG_CARDBUS
+	register_pci_controller(&bcm63xx_cb_controller);
+#endif
+
+	/* mark memory space used for IO mapping as reserved */
+	request_mem_region(BCM_PCI_IO_BASE_PA, BCM_PCI_IO_SIZE,
+			   "bcm63xx PCI IO space");
+	return 0;
+}
+
+arch_initcall(bcm63xx_pci_init);
