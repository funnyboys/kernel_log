commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index d54ea93651ac..f7802f100401 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Define the pci_ops for the PCIC on Toshiba TX4927, TX4938, etc.
  *
@@ -9,11 +10,6 @@
  * 2003-2005 (c) MontaVista Software, Inc.
  * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  * (C) Copyright TOSHIBA CORPORATION 2000-2001, 2004-2007
- *
- * This program is free software; you can redistribute	it and/or modify it
- * under  the terms of	the GNU General	 Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  */
 #include <linux/kernel.h>
 #include <linux/interrupt.h>

commit 1bc2d3e38e5bf90af4e9d64e1696f2d39757355a
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat Jun 28 23:57:13 2014 +0900

    MIPS: TXx9: Delete an unused variable in tx4927_pcibios_setup
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7216/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index 0e046d82e4e3..d54ea93651ac 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -199,8 +199,6 @@ static struct {
 
 char *tx4927_pcibios_setup(char *str)
 {
-	unsigned long val;
-
 	if (!strncmp(str, "trdyto=", 7)) {
 		u8 val = 0;
 		if (kstrtou8(str + 7, 0, &val) == 0)

commit 8e9ecbc5e21bf82693e52ec75b1f45c1245a9bea
Author: Daniel Walter <dwalter@google.com>
Date:   Tue Jun 3 16:22:08 2014 +0100

    MIPS: Replace calls to obsolete strict_strto call with kstrto* equivalents.
    
    Signed-off-by: Daniel Walter <dwalter@google.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: richard@nod.at
    Cc: akpm@linux-foundation.org
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index 3d5df514d024..0e046d82e4e3 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -202,17 +202,20 @@ char *tx4927_pcibios_setup(char *str)
 	unsigned long val;
 
 	if (!strncmp(str, "trdyto=", 7)) {
-		if (strict_strtoul(str + 7, 0, &val) == 0)
+		u8 val = 0;
+		if (kstrtou8(str + 7, 0, &val) == 0)
 			tx4927_pci_opts.trdyto = val;
 		return NULL;
 	}
 	if (!strncmp(str, "retryto=", 8)) {
-		if (strict_strtoul(str + 8, 0, &val) == 0)
+		u8 val = 0;
+		if (kstrtou8(str + 8, 0, &val) == 0)
 			tx4927_pci_opts.retryto = val;
 		return NULL;
 	}
 	if (!strncmp(str, "gbwc=", 5)) {
-		if (strict_strtoul(str + 5, 0, &val) == 0)
+		u16 val;
+		if (kstrtou16(str + 5, 0, &val) == 0)
 			tx4927_pci_opts.gbwc = val;
 		return NULL;
 	}

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index 0d69d6f4ea44..3d5df514d024 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -2,16 +2,16 @@
  * Define the pci_ops for the PCIC on Toshiba TX4927, TX4938, etc.
  *
  * Based on linux/arch/mips/pci/ops-tx4938.c,
- *          linux/arch/mips/pci/fixup-rbtx4938.c,
- *          linux/arch/mips/txx9/rbtx4938/setup.c,
+ *	    linux/arch/mips/pci/fixup-rbtx4938.c,
+ *	    linux/arch/mips/txx9/rbtx4938/setup.c,
  *	    and RBTX49xx patch from CELF patch archive.
  *
  * 2003-2005 (c) MontaVista Software, Inc.
  * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  * (C) Copyright TOSHIBA CORPORATION 2000-2001, 2004-2007
  *
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
+ * This program is free software; you can redistribute	it and/or modify it
+ * under  the terms of	the GNU General	 Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  */

commit 28eb0e46612a08a235c8b103eb2bd6a1aea83210
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 14:04:39 2012 -0800

    MIPS: drivers: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index bc13e29d2bb3..0d69d6f4ea44 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -191,13 +191,13 @@ static struct {
 	u8 trdyto;
 	u8 retryto;
 	u16 gbwc;
-} tx4927_pci_opts __devinitdata = {
+} tx4927_pci_opts = {
 	.trdyto = 0,
 	.retryto = 0,
 	.gbwc = 0xfe0,	/* 4064 GBUSCLK for CCFG.GTOT=0b11 */
 };
 
-char *__devinit tx4927_pcibios_setup(char *str)
+char *tx4927_pcibios_setup(char *str)
 {
 	unsigned long val;
 
@@ -495,7 +495,7 @@ irqreturn_t tx4927_pcierr_interrupt(int irq, void *dev_id)
 }
 
 #ifdef CONFIG_TOSHIBA_FPCIB0
-static void __devinit tx4927_quirk_slc90e66_bridge(struct pci_dev *dev)
+static void tx4927_quirk_slc90e66_bridge(struct pci_dev *dev)
 {
 	struct tx4927_pcic_reg __iomem *pcicptr = pci_bus_to_pcicptr(dev->bus);
 

commit 85a053fa5f2d67ae5b2968305b16e8d2fe4cdf4d
Author: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
Date:   Thu Jul 19 07:13:54 2012 +0200

    MIPS: PCI: Move fixups from __init to __devinit.
    
    Fixups are executed once the pci-device is found which is during boot
    process so __init seems fine as long as the platform does not support
    hotplug.
    However it is possible to remove the PCI bus at run time and have it
    rediscovered again via "echo 1 > /sys/bus/pci/rescan" and this will call
    the fixups again.
    
    [ralf@linux-mips.org: Made piixirqmap[] in malta_piix_func0_fixup()
    __initdata.]
    
    Signed-off-by: Sebastian Andrzej Siewior <sebastian@breakpoint.cc>
    Cc: linux-mips@linux-mips.org
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index a1e7e6d80c8c..bc13e29d2bb3 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -495,7 +495,7 @@ irqreturn_t tx4927_pcierr_interrupt(int irq, void *dev_id)
 }
 
 #ifdef CONFIG_TOSHIBA_FPCIB0
-static void __init tx4927_quirk_slc90e66_bridge(struct pci_dev *dev)
+static void __devinit tx4927_quirk_slc90e66_bridge(struct pci_dev *dev)
 {
 	struct tx4927_pcic_reg __iomem *pcicptr = pci_bus_to_pcicptr(dev->bus);
 

commit ca4d3e6746bdcfccb517349bce2d2c5b5614fb6f
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 7 14:08:54 2010 +0100

    MIPS: Add missing #inclusions of <linux/irq.h>
    
    Add missing #inclusions of <linux/irq.h> to a whole bunch of files that should
    really include it.  Note that this can replace #inclusions of <asm/irq.h>.
    
    This is required for the patch to sort out irqflags handling function naming to
    compile on MIPS.
    
    The problem is that these files require access to things like setup_irq() -
    which isn't available by #including <linux/interrupt.h>
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index 5989e747527f..a1e7e6d80c8c 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -17,6 +17,7 @@
  */
 #include <linux/kernel.h>
 #include <linux/interrupt.h>
+#include <linux/irq.h>
 #include <asm/txx9/pci.h>
 #include <asm/txx9/tx4927pcic.h>
 

commit 455cc256eb23915100e203fb33ee143afd127954
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 25 23:01:35 2008 +0900

    [MIPS] TXx9: PCI error handling
    
    From: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Date: Thu, 24 Jul 2008 00:25:16 +0900
    Subject: [PATCH] txx9: PCI error handling
    
    Add more control and detailed report on PCI error interrupt.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index 038e311b069d..5989e747527f 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -16,6 +16,8 @@
  * option) any later version.
  */
 #include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <asm/txx9/pci.h>
 #include <asm/txx9/tx4927pcic.h>
 
 static struct {
@@ -431,6 +433,66 @@ void tx4927_report_pcic_status(void)
 	}
 }
 
+static void tx4927_dump_pcic_settings1(struct tx4927_pcic_reg __iomem *pcicptr)
+{
+	int i;
+	__u32 __iomem *preg = (__u32 __iomem *)pcicptr;
+
+	printk(KERN_INFO "tx4927 pcic (0x%p) settings:", pcicptr);
+	for (i = 0; i < sizeof(struct tx4927_pcic_reg); i += 4, preg++) {
+		if (i % 32 == 0) {
+			printk(KERN_CONT "\n");
+			printk(KERN_INFO "%04x:", i);
+		}
+		/* skip registers with side-effects */
+		if (i == offsetof(struct tx4927_pcic_reg, g2pintack)
+		    || i == offsetof(struct tx4927_pcic_reg, g2pspc)
+		    || i == offsetof(struct tx4927_pcic_reg, g2pcfgadrs)
+		    || i == offsetof(struct tx4927_pcic_reg, g2pcfgdata)) {
+			printk(KERN_CONT " XXXXXXXX");
+			continue;
+		}
+		printk(KERN_CONT " %08x", __raw_readl(preg));
+	}
+	printk(KERN_CONT "\n");
+}
+
+void tx4927_dump_pcic_settings(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pcicptrs); i++) {
+		if (pcicptrs[i].pcicptr)
+			tx4927_dump_pcic_settings1(pcicptrs[i].pcicptr);
+	}
+}
+
+irqreturn_t tx4927_pcierr_interrupt(int irq, void *dev_id)
+{
+	struct pt_regs *regs = get_irq_regs();
+	struct tx4927_pcic_reg __iomem *pcicptr =
+		(struct tx4927_pcic_reg __iomem *)(unsigned long)dev_id;
+
+	if (txx9_pci_err_action != TXX9_PCI_ERR_IGNORE) {
+		printk(KERN_WARNING "PCIERR interrupt at 0x%0*lx\n",
+		       (int)(2 * sizeof(unsigned long)), regs->cp0_epc);
+		tx4927_report_pcic_status1(pcicptr);
+	}
+	if (txx9_pci_err_action != TXX9_PCI_ERR_PANIC) {
+		/* clear all pci errors */
+		__raw_writel((__raw_readl(&pcicptr->pcistatus) & 0x0000ffff)
+			     | (TX4927_PCIC_PCISTATUS_ALL << 16),
+			     &pcicptr->pcistatus);
+		__raw_writel(TX4927_PCIC_G2PSTATUS_ALL, &pcicptr->g2pstatus);
+		__raw_writel(TX4927_PCIC_PBASTATUS_ALL, &pcicptr->pbastatus);
+		__raw_writel(TX4927_PCIC_PCICSTATUS_ALL, &pcicptr->pcicstatus);
+		return IRQ_HANDLED;
+	}
+	console_verbose();
+	tx4927_dump_pcic_settings1(pcicptr);
+	panic("PCI error.");
+}
+
 #ifdef CONFIG_TOSHIBA_FPCIB0
 static void __init tx4927_quirk_slc90e66_bridge(struct pci_dev *dev)
 {

commit 07517529225ae4ce770271f83d8cd1004733a01d
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:15 2008 +0900

    [MIPS] TXx9: Add some pci options
    
    Add pci options for backplane type, clock selection, error handling,
    timeout values.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index 6d844094ef5d..038e311b069d 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -194,6 +194,28 @@ static struct {
 	.gbwc = 0xfe0,	/* 4064 GBUSCLK for CCFG.GTOT=0b11 */
 };
 
+char *__devinit tx4927_pcibios_setup(char *str)
+{
+	unsigned long val;
+
+	if (!strncmp(str, "trdyto=", 7)) {
+		if (strict_strtoul(str + 7, 0, &val) == 0)
+			tx4927_pci_opts.trdyto = val;
+		return NULL;
+	}
+	if (!strncmp(str, "retryto=", 8)) {
+		if (strict_strtoul(str + 8, 0, &val) == 0)
+			tx4927_pci_opts.retryto = val;
+		return NULL;
+	}
+	if (!strncmp(str, "gbwc=", 5)) {
+		if (strict_strtoul(str + 5, 0, &val) == 0)
+			tx4927_pci_opts.gbwc = val;
+		return NULL;
+	}
+	return str;
+}
+
 void __init tx4927_pcic_setup(struct tx4927_pcic_reg __iomem *pcicptr,
 			      struct pci_controller *channel, int extarb)
 {

commit 32d00d0f933ea5d21c3cd0809461ebbf7ab89cef
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:13 2008 +0900

    [MIPS] TXx9: PCI fixes for tx3927/tx4927
    
    * Fix tx3927 pci ops for Type-1 configuration
    * Fix abort checking of tx3927 pci ops
    * Flush write buffer to avoid spurious PCI error interrupt
    * Add a quirk for FPCIB backplane
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index c6b49bccd274..6d844094ef5d 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -85,6 +85,8 @@ static int check_abort(struct tx4927_pcic_reg __iomem *pcicptr)
 		__raw_writel((__raw_readl(&pcicptr->pcistatus) & 0x0000ffff)
 			     | (PCI_STATUS_REC_MASTER_ABORT << 16),
 			     &pcicptr->pcistatus);
+		/* flush write buffer */
+		iob();
 		code = PCIBIOS_DEVICE_NOT_FOUND;
 	}
 	return code;
@@ -406,3 +408,35 @@ void tx4927_report_pcic_status(void)
 			tx4927_report_pcic_status1(pcicptrs[i].pcicptr);
 	}
 }
+
+#ifdef CONFIG_TOSHIBA_FPCIB0
+static void __init tx4927_quirk_slc90e66_bridge(struct pci_dev *dev)
+{
+	struct tx4927_pcic_reg __iomem *pcicptr = pci_bus_to_pcicptr(dev->bus);
+
+	if (!pcicptr)
+		return;
+	if (__raw_readl(&pcicptr->pbacfg) & TX4927_PCIC_PBACFG_PBAEN) {
+		/* Reset Bus Arbiter */
+		__raw_writel(TX4927_PCIC_PBACFG_RPBA, &pcicptr->pbacfg);
+		/*
+		 * swap reqBP and reqXP (raise priority of SLC90E66).
+		 * SLC90E66(PCI-ISA bridge) is connected to REQ2 on
+		 * PCI Backplane board.
+		 */
+		__raw_writel(0x72543610, &pcicptr->pbareqport);
+		__raw_writel(0, &pcicptr->pbabm);
+		/* Use Fixed ParkMaster (required by SLC90E66) */
+		__raw_writel(TX4927_PCIC_PBACFG_FIXPA, &pcicptr->pbacfg);
+		/* Enable Bus Arbiter */
+		__raw_writel(TX4927_PCIC_PBACFG_FIXPA |
+			     TX4927_PCIC_PBACFG_PBAEN,
+			     &pcicptr->pbacfg);
+		printk(KERN_INFO "PCI: Use Fixed Park Master (REQPORT %08x)\n",
+		       __raw_readl(&pcicptr->pbareqport));
+	}
+}
+#define PCI_DEVICE_ID_EFAR_SLC90E66_0 0x9460
+DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_EFAR, PCI_DEVICE_ID_EFAR_SLC90E66_0,
+	tx4927_quirk_slc90e66_bridge);
+#endif

commit 89d63fe179520b11f54de1f26755b7444c79e73a
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 00:33:08 2008 +0900

    [MIPS] TXx9: Reorganize PCI code
    
    Split out PCIC dependent code and SoC dependent code from board dependent
    code.  Now TX4927 PCIC code is independent from TX4927/TX4938 SoC code.
    Also fix some build problems on CONFIG_PCI=n.
    
    As a bonus, "FPCIB0 Backplane Support" is available for all TX39/TX49 boards
    and PCI66 support is available for all TX49 boards.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index 54730eee451b..c6b49bccd274 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -1,206 +1,408 @@
 /*
- * Copyright 2001 MontaVista Software Inc.
- * Author: MontaVista Software, Inc.
- *              ahennessy@mvista.com
+ * Define the pci_ops for the PCIC on Toshiba TX4927, TX4938, etc.
  *
- * Copyright (C) 2000-2001 Toshiba Corporation
- * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
- *
- * Based on arch/mips/ddb5xxx/ddb5477/pci_ops.c
- *
- *     Define the pci_ops for the Toshiba rbtx4927
- *
- * Much of the code is derived from the original DDB5074 port by
- * Geert Uytterhoeven <geert@sonycom.com>
- *
- * Copyright 2004 MontaVista Software Inc.
- * Author: Manish Lachwani (mlachwani@mvista.com)
- *
- *  This program is free software; you can redistribute  it and/or modify it
- *  under  the terms of  the GNU General  Public License as published by the
- *  Free Software Foundation;  either version 2 of the  License, or (at your
- *  option) any later version.
+ * Based on linux/arch/mips/pci/ops-tx4938.c,
+ *          linux/arch/mips/pci/fixup-rbtx4938.c,
+ *          linux/arch/mips/txx9/rbtx4938/setup.c,
+ *	    and RBTX49xx patch from CELF patch archive.
  *
- *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
- *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
- *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
- *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
- *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
- *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
- *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
- *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
- *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 2003-2005 (c) MontaVista Software, Inc.
+ * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
+ * (C) Copyright TOSHIBA CORPORATION 2000-2001, 2004-2007
  *
- *  You should have received a copy of the  GNU General Public License along
- *  with this program; if not, write  to the Free Software Foundation, Inc.,
- *  675 Mass Ave, Cambridge, MA 02139, USA.
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
  */
-#include <linux/types.h>
-#include <linux/pci.h>
 #include <linux/kernel.h>
-#include <linux/init.h>
-#include <asm/txx9/tx4927.h>
-
-/* initialize in setup */
-struct resource pci_io_resource = {
-	.name	= "TX4927 PCI IO SPACE",
-	.start	= 0x1000,
-	.end	= (0x1000 + (TX4927_PCIIO_SIZE)) - 1,
-	.flags	= IORESOURCE_IO
-};
+#include <asm/txx9/tx4927pcic.h>
 
-/* initialize in setup */
-struct resource pci_mem_resource = {
-	.name	= "TX4927 PCI MEM SPACE",
-	.start	= TX4927_PCIMEM,
-	.end	= TX4927_PCIMEM + TX4927_PCIMEM_SIZE - 1,
-	.flags	= IORESOURCE_MEM
-};
+static struct {
+	struct pci_controller *channel;
+	struct tx4927_pcic_reg __iomem *pcicptr;
+} pcicptrs[2];	/* TX4938 has 2 pcic */
+
+static void __init set_tx4927_pcicptr(struct pci_controller *channel,
+				      struct tx4927_pcic_reg __iomem *pcicptr)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pcicptrs); i++) {
+		if (pcicptrs[i].channel == channel) {
+			pcicptrs[i].pcicptr = pcicptr;
+			return;
+		}
+	}
+	for (i = 0; i < ARRAY_SIZE(pcicptrs); i++) {
+		if (!pcicptrs[i].channel) {
+			pcicptrs[i].channel = channel;
+			pcicptrs[i].pcicptr = pcicptr;
+			return;
+		}
+	}
+	BUG();
+}
 
-static int mkaddr(int bus, int dev_fn, int where, int *flagsp)
+struct tx4927_pcic_reg __iomem *get_tx4927_pcicptr(
+	struct pci_controller *channel)
 {
-	if (bus > 0) {
-		/* Type 1 configuration */
-		tx4927_pcicptr->g2pcfgadrs = ((bus & 0xff) << 0x10) |
-		    ((dev_fn & 0xff) << 0x08) | (where & 0xfc) | 1;
-	} else {
-		if (dev_fn >= PCI_DEVFN(TX4927_PCIC_MAX_DEVNU, 0))
-			return -1;
+	int i;
 
-		/* Type 0 configuration */
-		tx4927_pcicptr->g2pcfgadrs = ((bus & 0xff) << 0x10) |
-		    ((dev_fn & 0xff) << 0x08) | (where & 0xfc);
+	for (i = 0; i < ARRAY_SIZE(pcicptrs); i++) {
+		if (pcicptrs[i].channel == channel)
+			return pcicptrs[i].pcicptr;
 	}
+	return NULL;
+}
+
+static int mkaddr(struct pci_bus *bus, unsigned int devfn, int where,
+		  struct tx4927_pcic_reg __iomem *pcicptr)
+{
+	if (bus->parent == NULL &&
+	    devfn >= PCI_DEVFN(TX4927_PCIC_MAX_DEVNU, 0))
+		return -1;
+	__raw_writel(((bus->number & 0xff) << 0x10)
+		     | ((devfn & 0xff) << 0x08) | (where & 0xfc)
+		     | (bus->parent ? 1 : 0),
+		     &pcicptr->g2pcfgadrs);
 	/* clear M_ABORT and Disable M_ABORT Int. */
-	tx4927_pcicptr->pcistatus =
-	    (tx4927_pcicptr->pcistatus & 0x0000ffff) |
-	    (PCI_STATUS_REC_MASTER_ABORT << 16);
-	tx4927_pcicptr->pcimask &= ~PCI_STATUS_REC_MASTER_ABORT;
+	__raw_writel((__raw_readl(&pcicptr->pcistatus) & 0x0000ffff)
+		     | (PCI_STATUS_REC_MASTER_ABORT << 16),
+		     &pcicptr->pcistatus);
 	return 0;
 }
 
-static int check_abort(int flags)
+static int check_abort(struct tx4927_pcic_reg __iomem *pcicptr)
 {
 	int code = PCIBIOS_SUCCESSFUL;
-	if (tx4927_pcicptr->
-	    pcistatus & (PCI_STATUS_REC_MASTER_ABORT << 16)) {
-		tx4927_pcicptr->pcistatus =
-		    (tx4927_pcicptr->
-		     pcistatus & 0x0000ffff) | (PCI_STATUS_REC_MASTER_ABORT
-						<< 16);
-		tx4927_pcicptr->pcimask |= PCI_STATUS_REC_MASTER_ABORT;
+
+	/* wait write cycle completion before checking error status */
+	while (__raw_readl(&pcicptr->pcicstatus) & TX4927_PCIC_PCICSTATUS_IWB)
+		;
+	if (__raw_readl(&pcicptr->pcistatus)
+	    & (PCI_STATUS_REC_MASTER_ABORT << 16)) {
+		__raw_writel((__raw_readl(&pcicptr->pcistatus) & 0x0000ffff)
+			     | (PCI_STATUS_REC_MASTER_ABORT << 16),
+			     &pcicptr->pcistatus);
 		code = PCIBIOS_DEVICE_NOT_FOUND;
 	}
 	return code;
 }
 
-static int tx4927_pcibios_read_config(struct pci_bus *bus, unsigned int devfn, int where,
-		int size, u32 * val)
+static u8 icd_readb(int offset, struct tx4927_pcic_reg __iomem *pcicptr)
+{
+#ifdef __BIG_ENDIAN
+	offset ^= 3;
+#endif
+	return __raw_readb((void __iomem *)&pcicptr->g2pcfgdata + offset);
+}
+static u16 icd_readw(int offset, struct tx4927_pcic_reg __iomem *pcicptr)
+{
+#ifdef __BIG_ENDIAN
+	offset ^= 2;
+#endif
+	return __raw_readw((void __iomem *)&pcicptr->g2pcfgdata + offset);
+}
+static u32 icd_readl(struct tx4927_pcic_reg __iomem *pcicptr)
+{
+	return __raw_readl(&pcicptr->g2pcfgdata);
+}
+static void icd_writeb(u8 val, int offset,
+		       struct tx4927_pcic_reg __iomem *pcicptr)
+{
+#ifdef __BIG_ENDIAN
+	offset ^= 3;
+#endif
+	__raw_writeb(val, (void __iomem *)&pcicptr->g2pcfgdata + offset);
+}
+static void icd_writew(u16 val, int offset,
+		       struct tx4927_pcic_reg __iomem *pcicptr)
+{
+#ifdef __BIG_ENDIAN
+	offset ^= 2;
+#endif
+	__raw_writew(val, (void __iomem *)&pcicptr->g2pcfgdata + offset);
+}
+static void icd_writel(u32 val, struct tx4927_pcic_reg __iomem *pcicptr)
 {
-	int flags, retval, dev, busno, func;
+	__raw_writel(val, &pcicptr->g2pcfgdata);
+}
 
-	busno = bus->number;
-        dev = PCI_SLOT(devfn);
-        func = PCI_FUNC(devfn);
+static struct tx4927_pcic_reg __iomem *pci_bus_to_pcicptr(struct pci_bus *bus)
+{
+	struct pci_controller *channel = bus->sysdata;
+	return get_tx4927_pcicptr(channel);
+}
 
-	/* check if the bus is top-level */
-	if (bus->parent != NULL) {
-		busno = bus->number;
-	} else {
-		busno = 0;
-	}
+static int tx4927_pci_config_read(struct pci_bus *bus, unsigned int devfn,
+				  int where, int size, u32 *val)
+{
+	struct tx4927_pcic_reg __iomem *pcicptr = pci_bus_to_pcicptr(bus);
 
-	if (mkaddr(busno, devfn, where, &flags))
+	if (mkaddr(bus, devfn, where, pcicptr)) {
+		*val = 0xffffffff;
 		return -1;
-
+	}
 	switch (size) {
 	case 1:
-		*val = *(volatile u8 *) ((unsigned long) & tx4927_pcicptr->
-                              g2pcfgdata |
-#ifdef __LITTLE_ENDIAN
-						(where & 3));
-#else
-						((where & 0x3) ^ 0x3));
-#endif
+		*val = icd_readb(where & 3, pcicptr);
 		break;
 	case 2:
-		*val = *(volatile u16 *) ((unsigned long) & tx4927_pcicptr->
-                               g2pcfgdata |
-#ifdef __LITTLE_ENDIAN
-						(where & 3));
-#else
-						((where & 0x3) ^ 0x2));
-#endif
-		break;
-	case 4:
-		*val = tx4927_pcicptr->g2pcfgdata;
+		*val = icd_readw(where & 3, pcicptr);
 		break;
+	default:
+		*val = icd_readl(pcicptr);
 	}
+	return check_abort(pcicptr);
+}
 
-	retval = check_abort(flags);
-	if (retval == PCIBIOS_DEVICE_NOT_FOUND)
-		*val = 0xffffffff;
+static int tx4927_pci_config_write(struct pci_bus *bus, unsigned int devfn,
+				   int where, int size, u32 val)
+{
+	struct tx4927_pcic_reg __iomem *pcicptr = pci_bus_to_pcicptr(bus);
 
-	return retval;
+	if (mkaddr(bus, devfn, where, pcicptr))
+		return -1;
+	switch (size) {
+	case 1:
+		icd_writeb(val, where & 3, pcicptr);
+		break;
+	case 2:
+		icd_writew(val, where & 3, pcicptr);
+		break;
+	default:
+		icd_writel(val, pcicptr);
+	}
+	return check_abort(pcicptr);
 }
 
-static int tx4927_pcibios_write_config(struct pci_bus *bus, unsigned int devfn, int where,
-				int size, u32 val)
+static struct pci_ops tx4927_pci_ops = {
+	.read = tx4927_pci_config_read,
+	.write = tx4927_pci_config_write,
+};
+
+static struct {
+	u8 trdyto;
+	u8 retryto;
+	u16 gbwc;
+} tx4927_pci_opts __devinitdata = {
+	.trdyto = 0,
+	.retryto = 0,
+	.gbwc = 0xfe0,	/* 4064 GBUSCLK for CCFG.GTOT=0b11 */
+};
+
+void __init tx4927_pcic_setup(struct tx4927_pcic_reg __iomem *pcicptr,
+			      struct pci_controller *channel, int extarb)
 {
-	int flags, dev, busno, func;
-	busno = bus->number;
-        dev = PCI_SLOT(devfn);
-        func = PCI_FUNC(devfn);
+	int i;
+	unsigned long flags;
 
-	/* check if the bus is top-level */
-	if (bus->parent != NULL) {
-		busno = bus->number;
-	} else {
-		busno = 0;
-	}
+	set_tx4927_pcicptr(channel, pcicptr);
 
-	if (mkaddr(busno, devfn, where, &flags))
-		return -1;
+	if (!channel->pci_ops)
+		printk(KERN_INFO
+		       "PCIC -- DID:%04x VID:%04x RID:%02x Arbiter:%s\n",
+		       __raw_readl(&pcicptr->pciid) >> 16,
+		       __raw_readl(&pcicptr->pciid) & 0xffff,
+		       __raw_readl(&pcicptr->pciccrev) & 0xff,
+			extarb ? "External" : "Internal");
+	channel->pci_ops = &tx4927_pci_ops;
 
-	switch (size) {
-	case 1:
-		 *(volatile u8 *) ((unsigned long) & tx4927_pcicptr->
-                          g2pcfgdata |
-#ifdef __LITTLE_ENDIAN
-					(where & 3)) = val;
+	local_irq_save(flags);
+
+	/* Disable All Initiator Space */
+	__raw_writel(__raw_readl(&pcicptr->pciccfg)
+		     & ~(TX4927_PCIC_PCICCFG_G2PMEN(0)
+			 | TX4927_PCIC_PCICCFG_G2PMEN(1)
+			 | TX4927_PCIC_PCICCFG_G2PMEN(2)
+			 | TX4927_PCIC_PCICCFG_G2PIOEN),
+		     &pcicptr->pciccfg);
+
+	/* GB->PCI mappings */
+	__raw_writel((channel->io_resource->end - channel->io_resource->start)
+		     >> 4,
+		     &pcicptr->g2piomask);
+	____raw_writeq((channel->io_resource->start +
+			channel->io_map_base - IO_BASE) |
+#ifdef __BIG_ENDIAN
+		       TX4927_PCIC_G2PIOGBASE_ECHG
 #else
-					((where & 0x3) ^ 0x3)) = val;
+		       TX4927_PCIC_G2PIOGBASE_BSDIS
 #endif
-		break;
-
-	case 2:
-		*(volatile u16 *) ((unsigned long) & tx4927_pcicptr->
-                           g2pcfgdata |
-#ifdef __LITTLE_ENDIAN
-					(where & 3)) = val;
+		       , &pcicptr->g2piogbase);
+	____raw_writeq(channel->io_resource->start - channel->io_offset,
+		       &pcicptr->g2piopbase);
+	for (i = 0; i < 3; i++) {
+		__raw_writel(0, &pcicptr->g2pmmask[i]);
+		____raw_writeq(0, &pcicptr->g2pmgbase[i]);
+		____raw_writeq(0, &pcicptr->g2pmpbase[i]);
+	}
+	if (channel->mem_resource->end) {
+		__raw_writel((channel->mem_resource->end
+			      - channel->mem_resource->start) >> 4,
+			     &pcicptr->g2pmmask[0]);
+		____raw_writeq(channel->mem_resource->start |
+#ifdef __BIG_ENDIAN
+			       TX4927_PCIC_G2PMnGBASE_ECHG
 #else
-					((where & 0x3) ^ 0x2)) = val;
+			       TX4927_PCIC_G2PMnGBASE_BSDIS
 #endif
-		break;
-	case 4:
-		tx4927_pcicptr->g2pcfgdata = val;
-		break;
+			       , &pcicptr->g2pmgbase[0]);
+		____raw_writeq(channel->mem_resource->start -
+			       channel->mem_offset,
+			       &pcicptr->g2pmpbase[0]);
+	}
+	/* PCI->GB mappings (I/O 256B) */
+	__raw_writel(0, &pcicptr->p2giopbase); /* 256B */
+	____raw_writeq(0, &pcicptr->p2giogbase);
+	/* PCI->GB mappings (MEM 512MB (64MB on R1.x)) */
+	__raw_writel(0, &pcicptr->p2gm0plbase);
+	__raw_writel(0, &pcicptr->p2gm0pubase);
+	____raw_writeq(TX4927_PCIC_P2GMnGBASE_TMEMEN |
+#ifdef __BIG_ENDIAN
+		       TX4927_PCIC_P2GMnGBASE_TECHG
+#else
+		       TX4927_PCIC_P2GMnGBASE_TBSDIS
+#endif
+		       , &pcicptr->p2gmgbase[0]);
+	/* PCI->GB mappings (MEM 16MB) */
+	__raw_writel(0xffffffff, &pcicptr->p2gm1plbase);
+	__raw_writel(0xffffffff, &pcicptr->p2gm1pubase);
+	____raw_writeq(0, &pcicptr->p2gmgbase[1]);
+	/* PCI->GB mappings (MEM 1MB) */
+	__raw_writel(0xffffffff, &pcicptr->p2gm2pbase); /* 1MB */
+	____raw_writeq(0, &pcicptr->p2gmgbase[2]);
+
+	/* Clear all (including IRBER) except for GBWC */
+	__raw_writel((tx4927_pci_opts.gbwc << 16)
+		     & TX4927_PCIC_PCICCFG_GBWC_MASK,
+		     &pcicptr->pciccfg);
+	/* Enable Initiator Memory Space */
+	if (channel->mem_resource->end)
+		__raw_writel(__raw_readl(&pcicptr->pciccfg)
+			     | TX4927_PCIC_PCICCFG_G2PMEN(0),
+			     &pcicptr->pciccfg);
+	/* Enable Initiator I/O Space */
+	if (channel->io_resource->end)
+		__raw_writel(__raw_readl(&pcicptr->pciccfg)
+			     | TX4927_PCIC_PCICCFG_G2PIOEN,
+			     &pcicptr->pciccfg);
+	/* Enable Initiator Config */
+	__raw_writel(__raw_readl(&pcicptr->pciccfg)
+		     | TX4927_PCIC_PCICCFG_ICAEN | TX4927_PCIC_PCICCFG_TCAR,
+		     &pcicptr->pciccfg);
+
+	/* Do not use MEMMUL, MEMINF: YMFPCI card causes M_ABORT. */
+	__raw_writel(0, &pcicptr->pcicfg1);
+
+	__raw_writel((__raw_readl(&pcicptr->g2ptocnt) & ~0xffff)
+		     | (tx4927_pci_opts.trdyto & 0xff)
+		     | ((tx4927_pci_opts.retryto & 0xff) << 8),
+		     &pcicptr->g2ptocnt);
+
+	/* Clear All Local Bus Status */
+	__raw_writel(TX4927_PCIC_PCICSTATUS_ALL, &pcicptr->pcicstatus);
+	/* Enable All Local Bus Interrupts */
+	__raw_writel(TX4927_PCIC_PCICSTATUS_ALL, &pcicptr->pcicmask);
+	/* Clear All Initiator Status */
+	__raw_writel(TX4927_PCIC_G2PSTATUS_ALL, &pcicptr->g2pstatus);
+	/* Enable All Initiator Interrupts */
+	__raw_writel(TX4927_PCIC_G2PSTATUS_ALL, &pcicptr->g2pmask);
+	/* Clear All PCI Status Error */
+	__raw_writel((__raw_readl(&pcicptr->pcistatus) & 0x0000ffff)
+		     | (TX4927_PCIC_PCISTATUS_ALL << 16),
+		     &pcicptr->pcistatus);
+	/* Enable All PCI Status Error Interrupts */
+	__raw_writel(TX4927_PCIC_PCISTATUS_ALL, &pcicptr->pcimask);
+
+	if (!extarb) {
+		/* Reset Bus Arbiter */
+		__raw_writel(TX4927_PCIC_PBACFG_RPBA, &pcicptr->pbacfg);
+		__raw_writel(0, &pcicptr->pbabm);
+		/* Enable Bus Arbiter */
+		__raw_writel(TX4927_PCIC_PBACFG_PBAEN, &pcicptr->pbacfg);
 	}
 
-	return check_abort(flags);
+	__raw_writel(PCI_COMMAND_MASTER | PCI_COMMAND_MEMORY
+		     | PCI_COMMAND_PARITY | PCI_COMMAND_SERR,
+		     &pcicptr->pcistatus);
+	local_irq_restore(flags);
+
+	printk(KERN_DEBUG
+	       "PCI: COMMAND=%04x,PCIMASK=%04x,"
+	       "TRDYTO=%02x,RETRYTO=%02x,GBWC=%03x\n",
+	       __raw_readl(&pcicptr->pcistatus) & 0xffff,
+	       __raw_readl(&pcicptr->pcimask) & 0xffff,
+	       __raw_readl(&pcicptr->g2ptocnt) & 0xff,
+	       (__raw_readl(&pcicptr->g2ptocnt) & 0xff00) >> 8,
+	       (__raw_readl(&pcicptr->pciccfg) >> 16) & 0xfff);
 }
 
-struct pci_ops tx4927_pci_ops = {
-	tx4927_pcibios_read_config,
-	tx4927_pcibios_write_config
-};
+static void tx4927_report_pcic_status1(struct tx4927_pcic_reg __iomem *pcicptr)
+{
+	__u16 pcistatus = (__u16)(__raw_readl(&pcicptr->pcistatus) >> 16);
+	__u32 g2pstatus = __raw_readl(&pcicptr->g2pstatus);
+	__u32 pcicstatus = __raw_readl(&pcicptr->pcicstatus);
+	static struct {
+		__u32 flag;
+		const char *str;
+	} pcistat_tbl[] = {
+		{ PCI_STATUS_DETECTED_PARITY,	"DetectedParityError" },
+		{ PCI_STATUS_SIG_SYSTEM_ERROR,	"SignaledSystemError" },
+		{ PCI_STATUS_REC_MASTER_ABORT,	"ReceivedMasterAbort" },
+		{ PCI_STATUS_REC_TARGET_ABORT,	"ReceivedTargetAbort" },
+		{ PCI_STATUS_SIG_TARGET_ABORT,	"SignaledTargetAbort" },
+		{ PCI_STATUS_PARITY,	"MasterParityError" },
+	}, g2pstat_tbl[] = {
+		{ TX4927_PCIC_G2PSTATUS_TTOE,	"TIOE" },
+		{ TX4927_PCIC_G2PSTATUS_RTOE,	"RTOE" },
+	}, pcicstat_tbl[] = {
+		{ TX4927_PCIC_PCICSTATUS_PME,	"PME" },
+		{ TX4927_PCIC_PCICSTATUS_TLB,	"TLB" },
+		{ TX4927_PCIC_PCICSTATUS_NIB,	"NIB" },
+		{ TX4927_PCIC_PCICSTATUS_ZIB,	"ZIB" },
+		{ TX4927_PCIC_PCICSTATUS_PERR,	"PERR" },
+		{ TX4927_PCIC_PCICSTATUS_SERR,	"SERR" },
+		{ TX4927_PCIC_PCICSTATUS_GBE,	"GBE" },
+		{ TX4927_PCIC_PCICSTATUS_IWB,	"IWB" },
+	};
+	int i, cont;
 
-/*
- * h/w only supports devices 0x00 to 0x14
- */
-struct pci_controller tx4927_controller = {
-	.pci_ops        = &tx4927_pci_ops,
-	.io_resource    = &pci_io_resource,
-	.mem_resource   = &pci_mem_resource,
-};
+	printk(KERN_ERR "");
+	if (pcistatus & TX4927_PCIC_PCISTATUS_ALL) {
+		printk(KERN_CONT "pcistat:%04x(", pcistatus);
+		for (i = 0, cont = 0; i < ARRAY_SIZE(pcistat_tbl); i++)
+			if (pcistatus & pcistat_tbl[i].flag)
+				printk(KERN_CONT "%s%s",
+				       cont++ ? " " : "", pcistat_tbl[i].str);
+		printk(KERN_CONT ") ");
+	}
+	if (g2pstatus & TX4927_PCIC_G2PSTATUS_ALL) {
+		printk(KERN_CONT "g2pstatus:%08x(", g2pstatus);
+		for (i = 0, cont = 0; i < ARRAY_SIZE(g2pstat_tbl); i++)
+			if (g2pstatus & g2pstat_tbl[i].flag)
+				printk(KERN_CONT "%s%s",
+				       cont++ ? " " : "", g2pstat_tbl[i].str);
+		printk(KERN_CONT ") ");
+	}
+	if (pcicstatus & TX4927_PCIC_PCICSTATUS_ALL) {
+		printk(KERN_CONT "pcicstatus:%08x(", pcicstatus);
+		for (i = 0, cont = 0; i < ARRAY_SIZE(pcicstat_tbl); i++)
+			if (pcicstatus & pcicstat_tbl[i].flag)
+				printk(KERN_CONT "%s%s",
+				       cont++ ? " " : "", pcicstat_tbl[i].str);
+		printk(KERN_CONT ")");
+	}
+	printk(KERN_CONT "\n");
+}
+
+void tx4927_report_pcic_status(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(pcicptrs); i++) {
+		if (pcicptrs[i].pcicptr)
+			tx4927_report_pcic_status1(pcicptrs[i].pcicptr);
+	}
+}

commit 22b1d707ffc99faebd86257ad19d5bb9fc624734
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 11 00:31:36 2008 +0900

    [MIPS] TXx9: Reorganize code
    
    Move arch/mips/{jmr3927,tx4927,tx4938} into arch/mips/txx9/ tree.
    This will help more code sharing and maintainance.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index 1bbafeb4a774..54730eee451b 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -40,7 +40,7 @@
 #include <linux/pci.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
-#include <asm/tx4927/tx4927.h>
+#include <asm/txx9/tx4927.h>
 
 /* initialize in setup */
 struct resource pci_io_resource = {

commit b29eee4935d9e5952a7ea8543ea499f06fb86808
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Wed Apr 16 02:00:45 2008 +0900

    [MIPS] rbtx4927: misc cleanups
    
    * Merge tx4927_pci.h into tx4927.h
    * Kill (broken) external PCI clock frequency reporting
    * Kill unnecessary wbflush()
    * Kill unnecessary includes
    * Kill debug garbages
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index 150419c8b414..1bbafeb4a774 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -40,10 +40,7 @@
 #include <linux/pci.h>
 #include <linux/kernel.h>
 #include <linux/init.h>
-
-#include <asm/addrspace.h>
-#include <asm/byteorder.h>
-#include <asm/tx4927/tx4927_pci.h>
+#include <asm/tx4927/tx4927.h>
 
 /* initialize in setup */
 struct resource pci_io_resource = {

commit fc103349bb7d3f011ffe9678da86a35634f4b6fc
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Jun 28 11:24:12 2006 +0100

    [MIPS] Remove BSD and Sys V compat data types.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index 7688b7711329..150419c8b414 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -119,7 +119,7 @@ static int tx4927_pcibios_read_config(struct pci_bus *bus, unsigned int devfn, i
 
 	switch (size) {
 	case 1:
-		*val = *(volatile u8 *) ((ulong) & tx4927_pcicptr->
+		*val = *(volatile u8 *) ((unsigned long) & tx4927_pcicptr->
                               g2pcfgdata |
 #ifdef __LITTLE_ENDIAN
 						(where & 3));
@@ -128,7 +128,7 @@ static int tx4927_pcibios_read_config(struct pci_bus *bus, unsigned int devfn, i
 #endif
 		break;
 	case 2:
-		*val = *(volatile u16 *) ((ulong) & tx4927_pcicptr->
+		*val = *(volatile u16 *) ((unsigned long) & tx4927_pcicptr->
                                g2pcfgdata |
 #ifdef __LITTLE_ENDIAN
 						(where & 3));
@@ -168,7 +168,7 @@ static int tx4927_pcibios_write_config(struct pci_bus *bus, unsigned int devfn,
 
 	switch (size) {
 	case 1:
-		 *(volatile u8 *) ((ulong) & tx4927_pcicptr->
+		 *(volatile u8 *) ((unsigned long) & tx4927_pcicptr->
                           g2pcfgdata |
 #ifdef __LITTLE_ENDIAN
 					(where & 3)) = val;
@@ -178,7 +178,7 @@ static int tx4927_pcibios_write_config(struct pci_bus *bus, unsigned int devfn,
 		break;
 
 	case 2:
-		*(volatile u16 *) ((ulong) & tx4927_pcicptr->
+		*(volatile u16 *) ((unsigned long) & tx4927_pcicptr->
                            g2pcfgdata |
 #ifdef __LITTLE_ENDIAN
 					(where & 3)) = val;

commit 42a3b4f25af8f8d77feddf27f839fa0628dbff1a
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Sep 3 15:56:17 2005 -0700

    [PATCH] mips: nuke trailing whitespace
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
index 2a9d7227fe87..7688b7711329 100644
--- a/arch/mips/pci/ops-tx4927.c
+++ b/arch/mips/pci/ops-tx4927.c
@@ -1,16 +1,16 @@
 /*
  * Copyright 2001 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
- *              ahennessy@mvista.com       
+ *              ahennessy@mvista.com
  *
- * Copyright (C) 2000-2001 Toshiba Corporation 
+ * Copyright (C) 2000-2001 Toshiba Corporation
  * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
  *
  * Based on arch/mips/ddb5xxx/ddb5477/pci_ops.c
  *
  *     Define the pci_ops for the Toshiba rbtx4927
  *
- * Much of the code is derived from the original DDB5074 port by 
+ * Much of the code is derived from the original DDB5074 port by
  * Geert Uytterhoeven <geert@sonycom.com>
  *
  * Copyright 2004 MontaVista Software Inc.

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/pci/ops-tx4927.c b/arch/mips/pci/ops-tx4927.c
new file mode 100644
index 000000000000..2a9d7227fe87
--- /dev/null
+++ b/arch/mips/pci/ops-tx4927.c
@@ -0,0 +1,209 @@
+/*
+ * Copyright 2001 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *              ahennessy@mvista.com       
+ *
+ * Copyright (C) 2000-2001 Toshiba Corporation 
+ * Copyright (C) 2004 by Ralf Baechle (ralf@linux-mips.org)
+ *
+ * Based on arch/mips/ddb5xxx/ddb5477/pci_ops.c
+ *
+ *     Define the pci_ops for the Toshiba rbtx4927
+ *
+ * Much of the code is derived from the original DDB5074 port by 
+ * Geert Uytterhoeven <geert@sonycom.com>
+ *
+ * Copyright 2004 MontaVista Software Inc.
+ * Author: Manish Lachwani (mlachwani@mvista.com)
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ *  THIS  SOFTWARE  IS PROVIDED   ``AS  IS'' AND   ANY  EXPRESS OR IMPLIED
+ *  WARRANTIES,   INCLUDING, BUT NOT  LIMITED  TO, THE IMPLIED WARRANTIES OF
+ *  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
+ *  NO  EVENT  SHALL   THE AUTHOR  BE    LIABLE FOR ANY   DIRECT, INDIRECT,
+ *  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *  NOT LIMITED   TO, PROCUREMENT OF  SUBSTITUTE GOODS  OR SERVICES; LOSS OF
+ *  USE, DATA,  OR PROFITS; OR  BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ *  ANY THEORY OF LIABILITY, WHETHER IN  CONTRACT, STRICT LIABILITY, OR TORT
+ *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ *  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ *  You should have received a copy of the  GNU General Public License along
+ *  with this program; if not, write  to the Free Software Foundation, Inc.,
+ *  675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+
+#include <asm/addrspace.h>
+#include <asm/byteorder.h>
+#include <asm/tx4927/tx4927_pci.h>
+
+/* initialize in setup */
+struct resource pci_io_resource = {
+	.name	= "TX4927 PCI IO SPACE",
+	.start	= 0x1000,
+	.end	= (0x1000 + (TX4927_PCIIO_SIZE)) - 1,
+	.flags	= IORESOURCE_IO
+};
+
+/* initialize in setup */
+struct resource pci_mem_resource = {
+	.name	= "TX4927 PCI MEM SPACE",
+	.start	= TX4927_PCIMEM,
+	.end	= TX4927_PCIMEM + TX4927_PCIMEM_SIZE - 1,
+	.flags	= IORESOURCE_MEM
+};
+
+static int mkaddr(int bus, int dev_fn, int where, int *flagsp)
+{
+	if (bus > 0) {
+		/* Type 1 configuration */
+		tx4927_pcicptr->g2pcfgadrs = ((bus & 0xff) << 0x10) |
+		    ((dev_fn & 0xff) << 0x08) | (where & 0xfc) | 1;
+	} else {
+		if (dev_fn >= PCI_DEVFN(TX4927_PCIC_MAX_DEVNU, 0))
+			return -1;
+
+		/* Type 0 configuration */
+		tx4927_pcicptr->g2pcfgadrs = ((bus & 0xff) << 0x10) |
+		    ((dev_fn & 0xff) << 0x08) | (where & 0xfc);
+	}
+	/* clear M_ABORT and Disable M_ABORT Int. */
+	tx4927_pcicptr->pcistatus =
+	    (tx4927_pcicptr->pcistatus & 0x0000ffff) |
+	    (PCI_STATUS_REC_MASTER_ABORT << 16);
+	tx4927_pcicptr->pcimask &= ~PCI_STATUS_REC_MASTER_ABORT;
+	return 0;
+}
+
+static int check_abort(int flags)
+{
+	int code = PCIBIOS_SUCCESSFUL;
+	if (tx4927_pcicptr->
+	    pcistatus & (PCI_STATUS_REC_MASTER_ABORT << 16)) {
+		tx4927_pcicptr->pcistatus =
+		    (tx4927_pcicptr->
+		     pcistatus & 0x0000ffff) | (PCI_STATUS_REC_MASTER_ABORT
+						<< 16);
+		tx4927_pcicptr->pcimask |= PCI_STATUS_REC_MASTER_ABORT;
+		code = PCIBIOS_DEVICE_NOT_FOUND;
+	}
+	return code;
+}
+
+static int tx4927_pcibios_read_config(struct pci_bus *bus, unsigned int devfn, int where,
+		int size, u32 * val)
+{
+	int flags, retval, dev, busno, func;
+
+	busno = bus->number;
+        dev = PCI_SLOT(devfn);
+        func = PCI_FUNC(devfn);
+
+	/* check if the bus is top-level */
+	if (bus->parent != NULL) {
+		busno = bus->number;
+	} else {
+		busno = 0;
+	}
+
+	if (mkaddr(busno, devfn, where, &flags))
+		return -1;
+
+	switch (size) {
+	case 1:
+		*val = *(volatile u8 *) ((ulong) & tx4927_pcicptr->
+                              g2pcfgdata |
+#ifdef __LITTLE_ENDIAN
+						(where & 3));
+#else
+						((where & 0x3) ^ 0x3));
+#endif
+		break;
+	case 2:
+		*val = *(volatile u16 *) ((ulong) & tx4927_pcicptr->
+                               g2pcfgdata |
+#ifdef __LITTLE_ENDIAN
+						(where & 3));
+#else
+						((where & 0x3) ^ 0x2));
+#endif
+		break;
+	case 4:
+		*val = tx4927_pcicptr->g2pcfgdata;
+		break;
+	}
+
+	retval = check_abort(flags);
+	if (retval == PCIBIOS_DEVICE_NOT_FOUND)
+		*val = 0xffffffff;
+
+	return retval;
+}
+
+static int tx4927_pcibios_write_config(struct pci_bus *bus, unsigned int devfn, int where,
+				int size, u32 val)
+{
+	int flags, dev, busno, func;
+	busno = bus->number;
+        dev = PCI_SLOT(devfn);
+        func = PCI_FUNC(devfn);
+
+	/* check if the bus is top-level */
+	if (bus->parent != NULL) {
+		busno = bus->number;
+	} else {
+		busno = 0;
+	}
+
+	if (mkaddr(busno, devfn, where, &flags))
+		return -1;
+
+	switch (size) {
+	case 1:
+		 *(volatile u8 *) ((ulong) & tx4927_pcicptr->
+                          g2pcfgdata |
+#ifdef __LITTLE_ENDIAN
+					(where & 3)) = val;
+#else
+					((where & 0x3) ^ 0x3)) = val;
+#endif
+		break;
+
+	case 2:
+		*(volatile u16 *) ((ulong) & tx4927_pcicptr->
+                           g2pcfgdata |
+#ifdef __LITTLE_ENDIAN
+					(where & 3)) = val;
+#else
+					((where & 0x3) ^ 0x2)) = val;
+#endif
+		break;
+	case 4:
+		tx4927_pcicptr->g2pcfgdata = val;
+		break;
+	}
+
+	return check_abort(flags);
+}
+
+struct pci_ops tx4927_pci_ops = {
+	tx4927_pcibios_read_config,
+	tx4927_pcibios_write_config
+};
+
+/*
+ * h/w only supports devices 0x00 to 0x14
+ */
+struct pci_controller tx4927_controller = {
+	.pci_ops        = &tx4927_pci_ops,
+	.io_resource    = &pci_io_resource,
+	.mem_resource   = &pci_mem_resource,
+};
