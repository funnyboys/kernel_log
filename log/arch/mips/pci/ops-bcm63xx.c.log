commit c9b0299034665d594e56ee343f28033d1b24de6d
Author: Liangliang Huang <huanglllzu@gmail.com>
Date:   Mon May 4 16:51:29 2020 +0800

    MIPS: Use fallthrough for arch/mips
    
    Convert the various /* fallthrough */ comments to the pseudo-keyword
    fallthrough;
    
    Done via script:
    https://lore.kernel.org/lkml/b56602fcf79f849e733e7b521bb0e17895d390fa.1582230379.git.joe@perches.com/
    
    Signed-off-by: Liangliang Huang <huangll@lemote.com>
    Reviewed-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/pci/ops-bcm63xx.c b/arch/mips/pci/ops-bcm63xx.c
index 925c72348fb6..dc6dc2741272 100644
--- a/arch/mips/pci/ops-bcm63xx.c
+++ b/arch/mips/pci/ops-bcm63xx.c
@@ -474,7 +474,7 @@ static int bcm63xx_pcie_can_access(struct pci_bus *bus, int devfn)
 		if (PCI_SLOT(devfn) == 0)
 			return bcm_pcie_readl(PCIE_DLSTATUS_REG)
 					& DLSTATUS_PHYLINKUP;
-		/* else, fall through */
+		fallthrough;
 	default:
 		return false;
 	}

commit 74034a09267c1f48d5ce7ae4c4a317fac7d43418
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Aug 5 13:55:33 2019 -0500

    MIPS: BCM63XX: Mark expected switch fall-through
    
    Mark switch cases where we are expecting to fall through.
    
    This patch fixes the following warning (Building: bcm63xx_defconfig mips):
    
    arch/mips/pci/ops-bcm63xx.c: In function ‘bcm63xx_pcie_can_access’:
    arch/mips/pci/ops-bcm63xx.c:474:6: warning: this statement may fall through [-Wimplicit-fallthrough=]
       if (PCI_SLOT(devfn) == 0)
          ^
    arch/mips/pci/ops-bcm63xx.c:477:2: note: here
      default:
      ^~~~~~~
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: bcm-kernel-feedback-list@broadcom.com
    Cc: linux-mips@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/pci/ops-bcm63xx.c b/arch/mips/pci/ops-bcm63xx.c
index d02eb9d16b55..925c72348fb6 100644
--- a/arch/mips/pci/ops-bcm63xx.c
+++ b/arch/mips/pci/ops-bcm63xx.c
@@ -474,6 +474,7 @@ static int bcm63xx_pcie_can_access(struct pci_bus *bus, int devfn)
 		if (PCI_SLOT(devfn) == 0)
 			return bcm_pcie_readl(PCIE_DLSTATUS_REG)
 					& DLSTATUS_PHYLINKUP;
+		/* else, fall through */
 	default:
 		return false;
 	}

commit 635c99070600ff04b4c1d5afe67f051631a8397c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Oct 21 14:12:49 2014 +0200

    MIPS: Remove useless parentheses
    
    Based on the spatch
    
    @@
    expression e;
    @@
    - return (e);
    + return e;
    
    with heavy hand editing because some of the changes are either whitespace
    or identation only or result in excessivly long lines.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-bcm63xx.c b/arch/mips/pci/ops-bcm63xx.c
index 13eea696bbe7..d02eb9d16b55 100644
--- a/arch/mips/pci/ops-bcm63xx.c
+++ b/arch/mips/pci/ops-bcm63xx.c
@@ -469,7 +469,7 @@ static int bcm63xx_pcie_can_access(struct pci_bus *bus, int devfn)
 {
 	switch (bus->number) {
 	case PCIE_BUS_BRIDGE:
-		return (PCI_SLOT(devfn) == 0);
+		return PCI_SLOT(devfn) == 0;
 	case PCIE_BUS_DEVICE:
 		if (PCI_SLOT(devfn) == 0)
 			return bcm_pcie_readl(PCIE_DLSTATUS_REG)

commit 3b2663ca844648c1b511f4dc8b1d5918174da58b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 6 14:59:30 2014 -0500

    mips: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6320/

diff --git a/arch/mips/pci/ops-bcm63xx.c b/arch/mips/pci/ops-bcm63xx.c
index 6144bb337e44..13eea696bbe7 100644
--- a/arch/mips/pci/ops-bcm63xx.c
+++ b/arch/mips/pci/ops-bcm63xx.c
@@ -9,7 +9,6 @@
 #include <linux/types.h>
 #include <linux/pci.h>
 #include <linux/kernel.h>
-#include <linux/init.h>
 #include <linux/delay.h>
 #include <linux/io.h>
 

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-bcm63xx.c b/arch/mips/pci/ops-bcm63xx.c
index 4a156629e958..6144bb337e44 100644
--- a/arch/mips/pci/ops-bcm63xx.c
+++ b/arch/mips/pci/ops-bcm63xx.c
@@ -174,8 +174,8 @@ static int bcm63xx_pci_write(struct pci_bus *bus, unsigned int devfn,
 }
 
 struct pci_ops bcm63xx_pci_ops = {
-	.read   = bcm63xx_pci_read,
-	.write  = bcm63xx_pci_write
+	.read	= bcm63xx_pci_read,
+	.write	= bcm63xx_pci_write
 };
 
 #ifdef CONFIG_CARDBUS
@@ -370,8 +370,8 @@ static int bcm63xx_cb_read(struct pci_bus *bus, unsigned int devfn,
 		return fake_cb_bridge_read(where, size, val);
 	}
 
-	/* a  configuration  cycle for  the  device  behind the  cardbus
-	 * bridge is  actually done as a  type 0 cycle  on the primary
+	/* a  configuration  cycle for	the  device  behind the	 cardbus
+	 * bridge is  actually done as a  type 0 cycle	on the primary
 	 * bus. This means that only  one device can be on the cardbus
 	 * bus */
 	if (fake_cb_bridge_regs.bus_assigned &&
@@ -403,8 +403,8 @@ static int bcm63xx_cb_write(struct pci_bus *bus, unsigned int devfn,
 }
 
 struct pci_ops bcm63xx_cb_ops = {
-	.read   = bcm63xx_cb_read,
-	.write   = bcm63xx_cb_write,
+	.read	= bcm63xx_cb_read,
+	.write	 = bcm63xx_cb_write,
 };
 
 /*
@@ -523,6 +523,6 @@ static int bcm63xx_pcie_write(struct pci_bus *bus, unsigned int devfn,
 
 
 struct pci_ops bcm63xx_pcie_ops = {
-	.read   = bcm63xx_pcie_read,
-	.write  = bcm63xx_pcie_write
+	.read	= bcm63xx_pcie_read,
+	.write	= bcm63xx_pcie_write
 };

commit 28eb0e46612a08a235c8b103eb2bd6a1aea83210
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 14:04:39 2012 -0800

    MIPS: drivers: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/pci/ops-bcm63xx.c b/arch/mips/pci/ops-bcm63xx.c
index 65c7bd100486..4a156629e958 100644
--- a/arch/mips/pci/ops-bcm63xx.c
+++ b/arch/mips/pci/ops-bcm63xx.c
@@ -411,7 +411,7 @@ struct pci_ops bcm63xx_cb_ops = {
  * only one IO window, so it  cannot be shared by PCI and cardbus, use
  * fixup to choose and detect unhandled configuration
  */
-static void __devinit bcm63xx_fixup(struct pci_dev *dev)
+static void bcm63xx_fixup(struct pci_dev *dev)
 {
 	static int io_window = -1;
 	int i, found, new_io_window;

commit 68d8848567ef03eb2c2303173934428d0bf0a531
Merge: 28a33cbc24e4 71a1c776d51a 6c2be5cf1d4e 2f74b770aa6d b59b28410145 f9c9affc5799 6cd3c7e2b1dc 9afd40811538 7e6507ad76a2
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Jul 25 16:37:46 2012 +0200

    Merge branches 'next/generic', 'next/alchemy', 'next/bcm63xx', 'next/cavium', 'next/jz4740', 'next/lantiq', 'next/loongson1b' and 'next/netlogic' into mips-for-linux-next

commit 19c860d932de520017c9b2d88cd9dff90b71ba36
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Tue Jul 24 16:33:13 2012 +0200

    MIPS: BCM63XX: Add PCIe Support for BCM6328
    
    Add support for the PCIe port found on BCM6328.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: Maxime Bizon <mbizon@freebox.fr>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/3956/
    Reviewed-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-bcm63xx.c b/arch/mips/pci/ops-bcm63xx.c
index 822ae179bc56..4a156629e958 100644
--- a/arch/mips/pci/ops-bcm63xx.c
+++ b/arch/mips/pci/ops-bcm63xx.c
@@ -465,3 +465,64 @@ static void bcm63xx_fixup(struct pci_dev *dev)
 
 DECLARE_PCI_FIXUP_ENABLE(PCI_ANY_ID, PCI_ANY_ID, bcm63xx_fixup);
 #endif
+
+static int bcm63xx_pcie_can_access(struct pci_bus *bus, int devfn)
+{
+	switch (bus->number) {
+	case PCIE_BUS_BRIDGE:
+		return (PCI_SLOT(devfn) == 0);
+	case PCIE_BUS_DEVICE:
+		if (PCI_SLOT(devfn) == 0)
+			return bcm_pcie_readl(PCIE_DLSTATUS_REG)
+					& DLSTATUS_PHYLINKUP;
+	default:
+		return false;
+	}
+}
+
+static int bcm63xx_pcie_read(struct pci_bus *bus, unsigned int devfn,
+			     int where, int size, u32 *val)
+{
+	u32 data;
+	u32 reg = where & ~3;
+
+	if (!bcm63xx_pcie_can_access(bus, devfn))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if (bus->number == PCIE_BUS_DEVICE)
+		reg += PCIE_DEVICE_OFFSET;
+
+	data = bcm_pcie_readl(reg);
+
+	*val = postprocess_read(data, where, size);
+
+	return PCIBIOS_SUCCESSFUL;
+
+}
+
+static int bcm63xx_pcie_write(struct pci_bus *bus, unsigned int devfn,
+			      int where, int size, u32 val)
+{
+	u32 data;
+	u32 reg = where & ~3;
+
+	if (!bcm63xx_pcie_can_access(bus, devfn))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	if (bus->number == PCIE_BUS_DEVICE)
+		reg += PCIE_DEVICE_OFFSET;
+
+
+	data = bcm_pcie_readl(reg);
+
+	data = preprocess_write(data, val, where, size);
+	bcm_pcie_writel(data, reg);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+
+struct pci_ops bcm63xx_pcie_ops = {
+	.read   = bcm63xx_pcie_read,
+	.write  = bcm63xx_pcie_write
+};

commit f7257d38ebb1bd3b8f80662c67ec7d502ac67421
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Jun 4 04:42:04 2012 +0100

    MIPS: PCI: Add missing __devinit attributions to fixup functions.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-bcm63xx.c b/arch/mips/pci/ops-bcm63xx.c
index 822ae179bc56..097239ba4bc9 100644
--- a/arch/mips/pci/ops-bcm63xx.c
+++ b/arch/mips/pci/ops-bcm63xx.c
@@ -411,7 +411,7 @@ struct pci_ops bcm63xx_cb_ops = {
  * only one IO window, so it  cannot be shared by PCI and cardbus, use
  * fixup to choose and detect unhandled configuration
  */
-static void bcm63xx_fixup(struct pci_dev *dev)
+static void __devinit bcm63xx_fixup(struct pci_dev *dev)
 {
 	static int io_window = -1;
 	int i, found, new_io_window;

commit e7300d04bd0809eb7ea10a2ed8c729459f816e36
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Tue Aug 18 13:23:37 2009 +0100

    MIPS: BCM63xx: Add support for the Broadcom BCM63xx family of SOCs.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-bcm63xx.c b/arch/mips/pci/ops-bcm63xx.c
new file mode 100644
index 000000000000..822ae179bc56
--- /dev/null
+++ b/arch/mips/pci/ops-bcm63xx.c
@@ -0,0 +1,467 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2008 Maxime Bizon <mbizon@freebox.fr>
+ */
+
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+
+#include "pci-bcm63xx.h"
+
+/*
+ * swizzle 32bits data to return only the needed part
+ */
+static int postprocess_read(u32 data, int where, unsigned int size)
+{
+	u32 ret;
+
+	ret = 0;
+	switch (size) {
+	case 1:
+		ret = (data >> ((where & 3) << 3)) & 0xff;
+		break;
+	case 2:
+		ret = (data >> ((where & 3) << 3)) & 0xffff;
+		break;
+	case 4:
+		ret = data;
+		break;
+	}
+	return ret;
+}
+
+static int preprocess_write(u32 orig_data, u32 val, int where,
+			    unsigned int size)
+{
+	u32 ret;
+
+	ret = 0;
+	switch (size) {
+	case 1:
+		ret = (orig_data & ~(0xff << ((where & 3) << 3))) |
+			(val << ((where & 3) << 3));
+		break;
+	case 2:
+		ret = (orig_data & ~(0xffff << ((where & 3) << 3))) |
+			(val << ((where & 3) << 3));
+		break;
+	case 4:
+		ret = val;
+		break;
+	}
+	return ret;
+}
+
+/*
+ * setup hardware for a configuration cycle with given parameters
+ */
+static int bcm63xx_setup_cfg_access(int type, unsigned int busn,
+				    unsigned int devfn, int where)
+{
+	unsigned int slot, func, reg;
+	u32 val;
+
+	slot = PCI_SLOT(devfn);
+	func = PCI_FUNC(devfn);
+	reg = where >> 2;
+
+	/* sanity check */
+	if (slot > (MPI_L2PCFG_DEVNUM_MASK >> MPI_L2PCFG_DEVNUM_SHIFT))
+		return 1;
+
+	if (func > (MPI_L2PCFG_FUNC_MASK >> MPI_L2PCFG_FUNC_SHIFT))
+		return 1;
+
+	if (reg > (MPI_L2PCFG_REG_MASK >> MPI_L2PCFG_REG_SHIFT))
+		return 1;
+
+	/* ok, setup config access */
+	val = (reg << MPI_L2PCFG_REG_SHIFT);
+	val |= (func << MPI_L2PCFG_FUNC_SHIFT);
+	val |= (slot << MPI_L2PCFG_DEVNUM_SHIFT);
+	val |= MPI_L2PCFG_CFG_USEREG_MASK;
+	val |= MPI_L2PCFG_CFG_SEL_MASK;
+	/* type 0 cycle for local bus, type 1 cycle for anything else */
+	if (type != 0) {
+		/* FIXME: how to specify bus ??? */
+		val |= (1 << MPI_L2PCFG_CFG_TYPE_SHIFT);
+	}
+	bcm_mpi_writel(val, MPI_L2PCFG_REG);
+
+	return 0;
+}
+
+static int bcm63xx_do_cfg_read(int type, unsigned int busn,
+				unsigned int devfn, int where, int size,
+				u32 *val)
+{
+	u32 data;
+
+	/* two phase cycle, first we write address, then read data at
+	 * another location, caller already has a spinlock so no need
+	 * to add one here  */
+	if (bcm63xx_setup_cfg_access(type, busn, devfn, where))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	iob();
+	data = le32_to_cpu(__raw_readl(pci_iospace_start));
+	/* restore IO space normal behaviour */
+	bcm_mpi_writel(0, MPI_L2PCFG_REG);
+
+	*val = postprocess_read(data, where, size);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int bcm63xx_do_cfg_write(int type, unsigned int busn,
+				 unsigned int devfn, int where, int size,
+				 u32 val)
+{
+	u32 data;
+
+	/* two phase cycle, first we write address, then write data to
+	 * another location, caller already has a spinlock so no need
+	 * to add one here  */
+	if (bcm63xx_setup_cfg_access(type, busn, devfn, where))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+	iob();
+
+	data = le32_to_cpu(__raw_readl(pci_iospace_start));
+	data = preprocess_write(data, val, where, size);
+
+	__raw_writel(cpu_to_le32(data), pci_iospace_start);
+	wmb();
+	/* no way to know the access is done, we have to wait */
+	udelay(500);
+	/* restore IO space normal behaviour */
+	bcm_mpi_writel(0, MPI_L2PCFG_REG);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int bcm63xx_pci_read(struct pci_bus *bus, unsigned int devfn,
+			     int where, int size, u32 *val)
+{
+	int type;
+
+	type = bus->parent ? 1 : 0;
+
+	if (type == 0 && PCI_SLOT(devfn) == CARDBUS_PCI_IDSEL)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return bcm63xx_do_cfg_read(type, bus->number, devfn,
+				    where, size, val);
+}
+
+static int bcm63xx_pci_write(struct pci_bus *bus, unsigned int devfn,
+			      int where, int size, u32 val)
+{
+	int type;
+
+	type = bus->parent ? 1 : 0;
+
+	if (type == 0 && PCI_SLOT(devfn) == CARDBUS_PCI_IDSEL)
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	return bcm63xx_do_cfg_write(type, bus->number, devfn,
+				     where, size, val);
+}
+
+struct pci_ops bcm63xx_pci_ops = {
+	.read   = bcm63xx_pci_read,
+	.write  = bcm63xx_pci_write
+};
+
+#ifdef CONFIG_CARDBUS
+/*
+ * emulate configuration read access on a cardbus bridge
+ */
+#define FAKE_CB_BRIDGE_SLOT	0x1e
+
+static int fake_cb_bridge_bus_number = -1;
+
+static struct {
+	u16 pci_command;
+	u8 cb_latency;
+	u8 subordinate_busn;
+	u8 cardbus_busn;
+	u8 pci_busn;
+	int bus_assigned;
+	u16 bridge_control;
+
+	u32 mem_base0;
+	u32 mem_limit0;
+	u32 mem_base1;
+	u32 mem_limit1;
+
+	u32 io_base0;
+	u32 io_limit0;
+	u32 io_base1;
+	u32 io_limit1;
+} fake_cb_bridge_regs;
+
+static int fake_cb_bridge_read(int where, int size, u32 *val)
+{
+	unsigned int reg;
+	u32 data;
+
+	data = 0;
+	reg = where >> 2;
+	switch (reg) {
+	case (PCI_VENDOR_ID >> 2):
+	case (PCI_CB_SUBSYSTEM_VENDOR_ID >> 2):
+		/* create dummy vendor/device id from our cpu id */
+		data = (bcm63xx_get_cpu_id() << 16) | PCI_VENDOR_ID_BROADCOM;
+		break;
+
+	case (PCI_COMMAND >> 2):
+		data = (PCI_STATUS_DEVSEL_SLOW << 16);
+		data |= fake_cb_bridge_regs.pci_command;
+		break;
+
+	case (PCI_CLASS_REVISION >> 2):
+		data = (PCI_CLASS_BRIDGE_CARDBUS << 16);
+		break;
+
+	case (PCI_CACHE_LINE_SIZE >> 2):
+		data = (PCI_HEADER_TYPE_CARDBUS << 16);
+		break;
+
+	case (PCI_INTERRUPT_LINE >> 2):
+		/* bridge control */
+		data = (fake_cb_bridge_regs.bridge_control << 16);
+		/* pin:intA line:0xff */
+		data |= (0x1 << 8) | 0xff;
+		break;
+
+	case (PCI_CB_PRIMARY_BUS >> 2):
+		data = (fake_cb_bridge_regs.cb_latency << 24);
+		data |= (fake_cb_bridge_regs.subordinate_busn << 16);
+		data |= (fake_cb_bridge_regs.cardbus_busn << 8);
+		data |= fake_cb_bridge_regs.pci_busn;
+		break;
+
+	case (PCI_CB_MEMORY_BASE_0 >> 2):
+		data = fake_cb_bridge_regs.mem_base0;
+		break;
+
+	case (PCI_CB_MEMORY_LIMIT_0 >> 2):
+		data = fake_cb_bridge_regs.mem_limit0;
+		break;
+
+	case (PCI_CB_MEMORY_BASE_1 >> 2):
+		data = fake_cb_bridge_regs.mem_base1;
+		break;
+
+	case (PCI_CB_MEMORY_LIMIT_1 >> 2):
+		data = fake_cb_bridge_regs.mem_limit1;
+		break;
+
+	case (PCI_CB_IO_BASE_0 >> 2):
+		/* | 1 for 32bits io support */
+		data = fake_cb_bridge_regs.io_base0 | 0x1;
+		break;
+
+	case (PCI_CB_IO_LIMIT_0 >> 2):
+		data = fake_cb_bridge_regs.io_limit0;
+		break;
+
+	case (PCI_CB_IO_BASE_1 >> 2):
+		/* | 1 for 32bits io support */
+		data = fake_cb_bridge_regs.io_base1 | 0x1;
+		break;
+
+	case (PCI_CB_IO_LIMIT_1 >> 2):
+		data = fake_cb_bridge_regs.io_limit1;
+		break;
+	}
+
+	*val = postprocess_read(data, where, size);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+/*
+ * emulate configuration write access on a cardbus bridge
+ */
+static int fake_cb_bridge_write(int where, int size, u32 val)
+{
+	unsigned int reg;
+	u32 data, tmp;
+	int ret;
+
+	ret = fake_cb_bridge_read((where & ~0x3), 4, &data);
+	if (ret != PCIBIOS_SUCCESSFUL)
+		return ret;
+
+	data = preprocess_write(data, val, where, size);
+
+	reg = where >> 2;
+	switch (reg) {
+	case (PCI_COMMAND >> 2):
+		fake_cb_bridge_regs.pci_command = (data & 0xffff);
+		break;
+
+	case (PCI_CB_PRIMARY_BUS >> 2):
+		fake_cb_bridge_regs.cb_latency = (data >> 24) & 0xff;
+		fake_cb_bridge_regs.subordinate_busn = (data >> 16) & 0xff;
+		fake_cb_bridge_regs.cardbus_busn = (data >> 8) & 0xff;
+		fake_cb_bridge_regs.pci_busn = data & 0xff;
+		if (fake_cb_bridge_regs.cardbus_busn)
+			fake_cb_bridge_regs.bus_assigned = 1;
+		break;
+
+	case (PCI_INTERRUPT_LINE >> 2):
+		tmp = (data >> 16) & 0xffff;
+		/* disable memory prefetch support */
+		tmp &= ~PCI_CB_BRIDGE_CTL_PREFETCH_MEM0;
+		tmp &= ~PCI_CB_BRIDGE_CTL_PREFETCH_MEM1;
+		fake_cb_bridge_regs.bridge_control = tmp;
+		break;
+
+	case (PCI_CB_MEMORY_BASE_0 >> 2):
+		fake_cb_bridge_regs.mem_base0 = data;
+		break;
+
+	case (PCI_CB_MEMORY_LIMIT_0 >> 2):
+		fake_cb_bridge_regs.mem_limit0 = data;
+		break;
+
+	case (PCI_CB_MEMORY_BASE_1 >> 2):
+		fake_cb_bridge_regs.mem_base1 = data;
+		break;
+
+	case (PCI_CB_MEMORY_LIMIT_1 >> 2):
+		fake_cb_bridge_regs.mem_limit1 = data;
+		break;
+
+	case (PCI_CB_IO_BASE_0 >> 2):
+		fake_cb_bridge_regs.io_base0 = data;
+		break;
+
+	case (PCI_CB_IO_LIMIT_0 >> 2):
+		fake_cb_bridge_regs.io_limit0 = data;
+		break;
+
+	case (PCI_CB_IO_BASE_1 >> 2):
+		fake_cb_bridge_regs.io_base1 = data;
+		break;
+
+	case (PCI_CB_IO_LIMIT_1 >> 2):
+		fake_cb_bridge_regs.io_limit1 = data;
+		break;
+	}
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int bcm63xx_cb_read(struct pci_bus *bus, unsigned int devfn,
+			   int where, int size, u32 *val)
+{
+	/* snoop access to slot 0x1e on root bus, we fake a cardbus
+	 * bridge at this location */
+	if (!bus->parent && PCI_SLOT(devfn) == FAKE_CB_BRIDGE_SLOT) {
+		fake_cb_bridge_bus_number = bus->number;
+		return fake_cb_bridge_read(where, size, val);
+	}
+
+	/* a  configuration  cycle for  the  device  behind the  cardbus
+	 * bridge is  actually done as a  type 0 cycle  on the primary
+	 * bus. This means that only  one device can be on the cardbus
+	 * bus */
+	if (fake_cb_bridge_regs.bus_assigned &&
+	    bus->number == fake_cb_bridge_regs.cardbus_busn &&
+	    PCI_SLOT(devfn) == 0)
+		return bcm63xx_do_cfg_read(0, 0,
+					   PCI_DEVFN(CARDBUS_PCI_IDSEL, 0),
+					   where, size, val);
+
+	return PCIBIOS_DEVICE_NOT_FOUND;
+}
+
+static int bcm63xx_cb_write(struct pci_bus *bus, unsigned int devfn,
+			    int where, int size, u32 val)
+{
+	if (!bus->parent && PCI_SLOT(devfn) == FAKE_CB_BRIDGE_SLOT) {
+		fake_cb_bridge_bus_number = bus->number;
+		return fake_cb_bridge_write(where, size, val);
+	}
+
+	if (fake_cb_bridge_regs.bus_assigned &&
+	    bus->number == fake_cb_bridge_regs.cardbus_busn &&
+	    PCI_SLOT(devfn) == 0)
+		return bcm63xx_do_cfg_write(0, 0,
+					    PCI_DEVFN(CARDBUS_PCI_IDSEL, 0),
+					    where, size, val);
+
+	return PCIBIOS_DEVICE_NOT_FOUND;
+}
+
+struct pci_ops bcm63xx_cb_ops = {
+	.read   = bcm63xx_cb_read,
+	.write   = bcm63xx_cb_write,
+};
+
+/*
+ * only one IO window, so it  cannot be shared by PCI and cardbus, use
+ * fixup to choose and detect unhandled configuration
+ */
+static void bcm63xx_fixup(struct pci_dev *dev)
+{
+	static int io_window = -1;
+	int i, found, new_io_window;
+	u32 val;
+
+	/* look for any io resource */
+	found = 0;
+	for (i = 0; i < DEVICE_COUNT_RESOURCE; i++) {
+		if (pci_resource_flags(dev, i) & IORESOURCE_IO) {
+			found = 1;
+			break;
+		}
+	}
+
+	if (!found)
+		return;
+
+	/* skip our fake bus with only cardbus bridge on it */
+	if (dev->bus->number == fake_cb_bridge_bus_number)
+		return;
+
+	/* find on which bus the device is */
+	if (fake_cb_bridge_regs.bus_assigned &&
+	    dev->bus->number == fake_cb_bridge_regs.cardbus_busn &&
+	    PCI_SLOT(dev->devfn) == 0)
+		new_io_window = 1;
+	else
+		new_io_window = 0;
+
+	if (new_io_window == io_window)
+		return;
+
+	if (io_window != -1) {
+		printk(KERN_ERR "bcm63xx: both PCI and cardbus devices "
+		       "need IO, which hardware cannot do\n");
+		return;
+	}
+
+	printk(KERN_INFO "bcm63xx: PCI IO window assigned to %s\n",
+	       (new_io_window == 0) ? "PCI" : "cardbus");
+
+	val = bcm_mpi_readl(MPI_L2PIOREMAP_REG);
+	if (io_window)
+		val |= MPI_L2PREMAP_IS_CARDBUS_MASK;
+	else
+		val &= ~MPI_L2PREMAP_IS_CARDBUS_MASK;
+	bcm_mpi_writel(val, MPI_L2PIOREMAP_REG);
+
+	io_window = new_io_window;
+}
+
+DECLARE_PCI_FIXUP_ENABLE(PCI_ANY_ID, PCI_ANY_ID, bcm63xx_fixup);
+#endif
