commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/pci/pci-legacy.c b/arch/mips/pci/pci-legacy.c
index 687513880fbf..39052de915f3 100644
--- a/arch/mips/pci/pci-legacy.c
+++ b/arch/mips/pci/pci-legacy.c
@@ -1,8 +1,5 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * This program is free software; you can redistribute	it and/or modify it
- * under  the terms of	the GNU General	 Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  *
  * Copyright (C) 2003, 04, 11 Ralf Baechle (ralf@linux-mips.org)
  * Copyright (C) 2011 Wind River Systems,

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/pci/pci-legacy.c b/arch/mips/pci/pci-legacy.c
index 3c3b1e6abb53..687513880fbf 100644
--- a/arch/mips/pci/pci-legacy.c
+++ b/arch/mips/pci/pci-legacy.c
@@ -11,7 +11,7 @@
 #include <linux/bug.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
-#include <linux/bootmem.h>
+#include <linux/memblock.h>
 #include <linux/export.h>
 #include <linux/init.h>
 #include <linux/types.h>

commit 2794f688b2c336e0da85e9f91fed33febbd9f54a
Author: Huacai Chen <chenhc@lemote.com>
Date:   Sat Sep 15 14:01:12 2018 +0800

    MIPS/PCI: Call pcie_bus_configure_settings() to set MPS/MRRS
    
    Call pcie_bus_configure_settings() on MIPS, like for other platforms.
    The function pcie_bus_configure_settings() makes sure the MPS (Max
    Payload Size) across the bus is uniform and provides the ability to
    tune the MRSS (Max Read Request Size) and MPS (Max Payload Size) to
    higher performance values. Some devices will not operate properly if
    these aren't set correctly because the firmware doesn't always do it.
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/20649/
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Cc: Huacai Chen <chenhuacai@gmail.com>

diff --git a/arch/mips/pci/pci-legacy.c b/arch/mips/pci/pci-legacy.c
index f1e92bf743c2..3c3b1e6abb53 100644
--- a/arch/mips/pci/pci-legacy.c
+++ b/arch/mips/pci/pci-legacy.c
@@ -127,8 +127,12 @@ static void pcibios_scanbus(struct pci_controller *hose)
 	if (pci_has_flag(PCI_PROBE_ONLY)) {
 		pci_bus_claim_resources(bus);
 	} else {
+		struct pci_bus *child;
+
 		pci_bus_size_bridges(bus);
 		pci_bus_assign_resources(bus);
+		list_for_each_entry(child, &bus->children, node)
+			pcie_bus_configure_settings(child);
 	}
 	pci_bus_add_devices(bus);
 }

commit 77edfac4e7551d32070abb11a754f9572b2fdaae
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue May 22 07:56:22 2018 -0500

    MIPS: PCI: Use dev_printk() when possible
    
    Use the pci_info() and pci_err() wrappers for dev_printk() when possible.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/pci/pci-legacy.c b/arch/mips/pci/pci-legacy.c
index 0c65c38e05d6..f1e92bf743c2 100644
--- a/arch/mips/pci/pci-legacy.c
+++ b/arch/mips/pci/pci-legacy.c
@@ -263,9 +263,8 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 				(!(r->flags & IORESOURCE_ROM_ENABLE)))
 			continue;
 		if (!r->start && r->end) {
-			printk(KERN_ERR "PCI: Device %s not available "
-			       "because of resource collisions\n",
-			       pci_name(dev));
+			pci_err(dev,
+				"can't enable device: resource collisions\n");
 			return -EINVAL;
 		}
 		if (r->flags & IORESOURCE_IO)
@@ -274,8 +273,7 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 			cmd |= PCI_COMMAND_MEMORY;
 	}
 	if (cmd != old_cmd) {
-		printk("PCI: Enabling device %s (%04x -> %04x)\n",
-		       pci_name(dev), old_cmd, cmd);
+		pci_info(dev, "enabling device (%04x -> %04x)\n", old_cmd, cmd);
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
 	return 0;

commit 7318413077a5141a50a753b1fab687b7907eef16
Merge: 8d93c7a43157 35eed7cb2cf1
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Sep 15 20:43:33 2017 -0700

    Merge branch '4.14-features' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
     "This is the main pull request for 4.14 for MIPS; below a summary of
      the non-merge commits:
    
      CM:
       - Rename mips_cm_base to mips_gcr_base
       - Specify register size when generating accessors
       - Use BIT/GENMASK for register fields, order & drop shifts
       - Add cluster & block args to mips_cm_lock_other()
    
      CPC:
       - Use common CPS accessor generation macros
       - Use BIT/GENMASK for register fields, order & drop shifts
       - Introduce register modify (set/clear/change) accessors
       - Use change_*, set_* & clear_* where appropriate
       - Add CM/CPC 3.5 register definitions
       - Use GlobalNumber macros rather than magic numbers
       - Have asm/mips-cps.h include CM & CPC headers
       - Cluster support for topology functions
       - Detect CPUs in secondary clusters
    
      CPS:
       - Read GIC_VL_IDENT directly, not via irqchip driver
    
      DMA:
       - Consolidate coherent and non-coherent dma_alloc code
       - Don't use dma_cache_sync to implement fd_cacheflush
    
      FPU emulation / FP assist code:
       - Another series of 14 commits fixing corner cases such as NaN
         propgagation and other special input values.
       - Zero bits 32-63 of the result for a CLASS.D instruction.
       - Enhanced statics via debugfs
       - Do not use bools for arithmetic. GCC 7.1 moans about this.
       - Correct user fault_addr type
    
      Generic MIPS:
       - Enhancement of stack backtraces
       - Cleanup from non-existing options
       - Handle non word sized instructions when examining frame
       - Fix detection and decoding of ADDIUSP instruction
       - Fix decoding of SWSP16 instruction
       - Refactor handling of stack pointer in get_frame_info
       - Remove unreachable code from force_fcr31_sig()
       - Convert to using %pOF instead of full_name
       - Remove the R6000 support.
       - Move FP code from *_switch.S to *_fpu.S
       - Remove unused ST_OFF from r2300_switch.S
       - Allow platform to specify multiple its.S files
       - Add #includes to various files to ensure code builds reliable and
         without warning..
       - Remove __invalidate_kernel_vmap_range
       - Remove plat_timer_setup
       - Declare various variables & functions static
       - Abstract CPU core & VP(E) ID access through accessor functions
       - Store core & VP IDs in GlobalNumber-style variable
       - Unify checks for sibling CPUs
       - Add CPU cluster number accessors
       - Prevent direct use of generic_defconfig
       - Make CONFIG_MIPS_MT_SMP default y
       - Add __ioread64_copy
       - Remove unnecessary inclusions of linux/irqchip/mips-gic.h
    
      GIC:
       - Introduce asm/mips-gic.h with accessor functions
       - Use new GIC accessor functions in mips-gic-timer
       - Remove counter access functions from irq-mips-gic.c
       - Remove gic_read_local_vp_id() from irq-mips-gic.c
       - Simplify shared interrupt pending/mask reads in irq-mips-gic.c
       - Simplify gic_local_irq_domain_map() in irq-mips-gic.c
       - Drop gic_(re)set_mask() functions in irq-mips-gic.c
       - Remove gic_set_polarity(), gic_set_trigger(), gic_set_dual_edge(),
         gic_map_to_pin() and gic_map_to_vpe() from irq-mips-gic.c.
       - Convert remaining shared reg access, local int mask access and
         remaining local reg access to new accessors
       - Move GIC_LOCAL_INT_* to asm/mips-gic.h
       - Remove GIC_CPU_INT* macros from irq-mips-gic.c
       - Move various definitions to the driver
       - Remove gic_get_usm_range()
       - Remove __gic_irq_dispatch() forward declaration
       - Remove gic_init()
       - Use mips_gic_present() in place of gic_present and remove
         gic_present
       - Move gic_get_c0_*_int() to asm/mips-gic.h
       - Remove linux/irqchip/mips-gic.h
       - Inline __gic_init()
       - Inline gic_basic_init()
       - Make pcpu_masks a per-cpu variable
       - Use pcpu_masks to avoid reading GIC_SH_MASK*
       - Clean up mti, reserved-cpu-vectors handling
       - Use cpumask_first_and() in gic_set_affinity()
       - Let the core set struct irq_common_data affinity
    
      microMIPS:
       - Fix microMIPS stack unwinding on big endian systems
    
      MIPS-GIC:
       - SYNC after enabling GIC region
    
      NUMA:
       - Remove the unused parent_node() macro
    
      R6:
       - Constify r2_decoder_tables
       - Add accessor & bit definitions for GlobalNumber
    
      SMP:
       - Constify smp ops
       - Allow boot_secondary SMP op to return errors
    
      VDSO:
       - Drop gic_get_usm_range() usage
       - Avoid use of linux/irqchip/mips-gic.h
    
      Platform changes:
    
      Alchemy:
       - Add devboard machine type to cpuinfo
       - update cpu feature overrides
       - Threaded carddetect irqs for devboards
    
      AR7:
       - allow NULL clock for clk_get_rate
    
      BCM63xx:
       - Fix ENETDMA_6345_MAXBURST_REG offset
       - Allow NULL clock for clk_get_rate
    
      CI20:
       - Enable GPIO and RTC drivers in defconfig
       - Add ethernet and fixed-regulator nodes to DTS
    
      Generic platform:
       - Move Boston and NI 169445 FIT image source to their own files
       - Include asm/bootinfo.h for plat_fdt_relocated()
       - Include asm/time.h for get_c0_*_int()
       - Include asm/bootinfo.h for plat_fdt_relocated()
       - Include asm/time.h for get_c0_*_int()
       - Allow filtering enabled boards by requirements
       - Don't explicitly disable CONFIG_USB_SUPPORT
       - Bump default NR_CPUS to 16
    
      JZ4700:
       - Probe the jz4740-rtc driver from devicetree
    
      Lantiq:
       - Drop check of boot select from the spi-falcon driver.
       - Drop check of boot select from the lantiq-flash MTD driver.
       - Access boot cause register in the watchdog driver through regmap
       - Add device tree binding documentation for the watchdog driver
       - Add docs for the RCU DT bindings.
       - Convert the fpi bus driver to a platform_driver
       - Remove ltq_reset_cause() and ltq_boot_select(
       - Switch to a proper reset driver
       - Switch to a new drivers/soc GPHY driver
       - Add an USB PHY driver for the Lantiq SoCs using the RCU module
       - Use of_platform_default_populate instead of __dt_register_buses
       - Enable MFD_SYSCON to be able to use it for the RCU MFD
       - Replace ltq_boot_select() with dummy implementation.
    
      Loongson 2F:
       - Allow NULL clock for clk_get_rate
    
      Malta:
       - Use new GIC accessor functions
    
      NI 169445:
       - Add support for NI 169445 board.
       - Only include in 32r2el kernels
    
      Octeon:
       - Add support for watchdog of 78XX SOCs.
       - Add support for watchdog of CN68XX SOCs.
       - Expose support for mips32r1, mips32r2 and mips64r1
       - Enable more drivers in config file
       - Add support for accessing the boot vector.
       - Remove old boot vector code from watchdog driver
       - Define watchdog registers for 70xx, 73xx, 78xx, F75xx.
       - Make CSR functions node aware.
       - Allow access to CIU3 IRQ domains.
       - Misc cleanups in the watchdog driver
    
      Omega2+:
       - New board, add support and defconfig
    
      Pistachio:
       - Enable Root FS on NFS in defconfig
    
      Ralink:
       - Add Mediatek MT7628A SoC
       - Allow NULL clock for clk_get_rate
       - Explicitly request exclusive reset control in the pci-mt7620 PCI driver.
    
      SEAD3:
       - Only include in 32 bit kernels by default
    
      VoCore:
       - Add VoCore as a vendor t0 dt-bindings
       - Add defconfig file"
    
    * '4.14-features' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (167 commits)
      MIPS: Refactor handling of stack pointer in get_frame_info
      MIPS: Stacktrace: Fix microMIPS stack unwinding on big endian systems
      MIPS: microMIPS: Fix decoding of swsp16 instruction
      MIPS: microMIPS: Fix decoding of addiusp instruction
      MIPS: microMIPS: Fix detection of addiusp instruction
      MIPS: Handle non word sized instructions when examining frame
      MIPS: ralink: allow NULL clock for clk_get_rate
      MIPS: Loongson 2F: allow NULL clock for clk_get_rate
      MIPS: BCM63XX: allow NULL clock for clk_get_rate
      MIPS: AR7: allow NULL clock for clk_get_rate
      MIPS: BCM63XX: fix ENETDMA_6345_MAXBURST_REG offset
      mips: Save all registers when saving the frame
      MIPS: Add DWARF unwinding to assembly
      MIPS: Make SAVE_SOME more standard
      MIPS: Fix issues in backtraces
      MIPS: jz4780: DTS: Probe the jz4740-rtc driver from devicetree
      MIPS: Ci20: Enable RTC driver
      watchdog: octeon-wdt: Add support for 78XX SOCs.
      watchdog: octeon-wdt: Add support for cn68XX SOCs.
      watchdog: octeon-wdt: File cleaning.
      ...

commit 7f27b5b8ed1f77427811d13788fbdb2f53ce94a4
Author: Rob Herring <robh@kernel.org>
Date:   Tue Jul 18 16:42:45 2017 -0500

    MIPS: Convert to using %pOF instead of full_name
    
    Now that we have a custom printf format specifier, convert users of
    full_name to use %pOF instead. This is preparation to remove storing
    of the full path string for each node.
    
    Signed-off-by: Rob Herring <robh@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Cc: devicetree@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/16783/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-legacy.c b/arch/mips/pci/pci-legacy.c
index 174575a9a112..958f47c1f558 100644
--- a/arch/mips/pci/pci-legacy.c
+++ b/arch/mips/pci/pci-legacy.c
@@ -127,7 +127,7 @@ void pci_load_of_ranges(struct pci_controller *hose, struct device_node *node)
 	struct of_pci_range range;
 	struct of_pci_range_parser parser;
 
-	pr_info("PCI host bridge %s ranges:\n", node->full_name);
+	pr_info("PCI host bridge %pOF ranges:\n", node);
 	hose->of_node = node;
 
 	if (of_pci_range_parser_init(&parser, node))

commit 04c81c7293df875ca6a46e2c9a272c7ec72e5145
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Jul 31 17:37:53 2017 +0100

    MIPS: PCI: Replace pci_fixup_irqs() call with host bridge IRQ mapping hooks
    
    The pci_fixup_irqs() function allocates IRQs for all PCI devices present in
    a system; those PCI devices possibly belong to different PCI bus trees (and
    possibly rooted at different host bridges) and may well be enabled (ie
    probed and bound to a driver) by the time pci_fixup_irqs() is called when
    probing a given host bridge driver.
    
    Furthermore, current kernel code relying on pci_fixup_irqs() to assign
    legacy PCI IRQs to devices does not work at all for hotplugged devices in
    that the code carrying out the IRQ fixup is called at host bridge driver
    probe time, which just cannot take into account devices hotplugged after
    the system has booted.
    
    The introduction of map/swizzle function hooks in struct pci_host_bridge
    allows us to define per-bridge map/swizzle functions, that can be used at
    device probe time in PCI core code to allocate IRQs for a given device
    (through pci_assign_irq()).
    
    Convert PCI host bridge initialization code to the
    pci_scan_root_bus_bridge() API (that allows to pass a struct
    pci_host_bridge with initialized map/swizzle pointers) and remove the
    pci_fixup_irqs() call from arch code.
    
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@imgtec.com>

diff --git a/arch/mips/pci/pci-legacy.c b/arch/mips/pci/pci-legacy.c
index 71d62f818d77..fc7726088103 100644
--- a/arch/mips/pci/pci-legacy.c
+++ b/arch/mips/pci/pci-legacy.c
@@ -78,6 +78,12 @@ static void pcibios_scanbus(struct pci_controller *hose)
 	static int need_domain_info;
 	LIST_HEAD(resources);
 	struct pci_bus *bus;
+	struct pci_host_bridge *bridge;
+	int ret;
+
+	bridge = pci_alloc_host_bridge(0);
+	if (!bridge)
+		return;
 
 	if (hose->get_busno && pci_has_flag(PCI_PROBE_ONLY))
 		next_busno = (*hose->get_busno)();
@@ -87,14 +93,20 @@ static void pcibios_scanbus(struct pci_controller *hose)
 	pci_add_resource_offset(&resources,
 				hose->io_resource, hose->io_offset);
 	pci_add_resource(&resources, hose->busn_resource);
-	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
-				&resources);
-	if (!bus) {
-		pci_free_resource_list(&resources);
+	list_splice_init(&resources, &bridge->windows);
+	bridge->dev.parent = NULL;
+	bridge->sysdata = hose;
+	bridge->busnr = next_busno;
+	bridge->ops = hose->pci_ops;
+	bridge->swizzle_irq = pci_common_swizzle;
+	bridge->map_irq = pcibios_map_irq;
+	ret = pci_scan_root_bus_bridge(bridge);
+	if (ret) {
+		pci_free_host_bridge(bridge);
 		return;
 	}
 
-	hose->bus = bus;
+	hose->bus = bus = bridge->bus;
 
 	need_domain_info = need_domain_info || pci_domain_nr(bus);
 	set_pci_need_domain_info(hose, need_domain_info);
@@ -224,8 +236,6 @@ static int __init pcibios_init(void)
 	list_for_each_entry(hose, &controllers, list)
 		pcibios_scanbus(hose);
 
-	pci_fixup_irqs(pci_common_swizzle, pcibios_map_irq);
-
 	pci_initialized = 1;
 
 	return 0;

commit 902d886d4474a4d2661ae337f3c30dc7a8e59f28
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Mon Jul 10 09:58:46 2017 -0500

    MIPS: PCI: Fix pcibios_scan_bus() NULL check code path
    
    If pci_scan_root_bus() fails (ie returns NULL) pcibios_scan_bus() must
    return immediately since the struct pci_bus pointer it returns is not valid
    and cannot be used.
    
    Move code checking the pci_scan_root_bus() return value to reinstate proper
    pcibios_scanbus() error path behaviour.
    
    Fixes: 88555b481958 ("MIPS: PCI: Support for CONFIG_PCI_DOMAINS_GENERIC")
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@imgtec.com>

diff --git a/arch/mips/pci/pci-legacy.c b/arch/mips/pci/pci-legacy.c
index 174575a9a112..71d62f818d77 100644
--- a/arch/mips/pci/pci-legacy.c
+++ b/arch/mips/pci/pci-legacy.c
@@ -89,16 +89,16 @@ static void pcibios_scanbus(struct pci_controller *hose)
 	pci_add_resource(&resources, hose->busn_resource);
 	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
 				&resources);
-	hose->bus = bus;
-
-	need_domain_info = need_domain_info || pci_domain_nr(bus);
-	set_pci_need_domain_info(hose, need_domain_info);
-
 	if (!bus) {
 		pci_free_resource_list(&resources);
 		return;
 	}
 
+	hose->bus = bus;
+
+	need_domain_info = need_domain_info || pci_domain_nr(bus);
+	set_pci_need_domain_info(hose, need_domain_info);
+
 	next_busno = bus->busn_res.end + 1;
 	/* Don't allow 8-bit bus number overflow inside the hose -
 	   reserve some space for bridges. */

commit 7ee214b540d9453af297cd19c43002018ed73fea
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu May 18 15:39:19 2017 -0500

    MIPS: PCI: Remove unused busn_offset
    
    pci_add_resource_offset() is for host bridge windows where the bridge
    translates CPU addresses to PCI bus addresses by adding an offset.  To my
    knowledge, no host bridge translates bus numbers, so this is only useful
    for MEM and IO windows.  In any event, host->busn_offset is never set to
    anything other than zero, so pci_add_resource() is sufficient.
    
    a2e50f53d535 ("MIPS: PCI: Add a hook for IORESOURCE_BUS in
    pci_controller/bridge_controller") also added busn_resource itself.  This
    is currently unused but may be used by future SGI IP27 fixes, so I left it
    there.
    
    Tested-by: Joshua Kinard <kumba@gentoo.org>     # SGI IP30 and IP27
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Joshua Kinard <kumba@gentoo.org>

diff --git a/arch/mips/pci/pci-legacy.c b/arch/mips/pci/pci-legacy.c
index 3a84f6c0c840..174575a9a112 100644
--- a/arch/mips/pci/pci-legacy.c
+++ b/arch/mips/pci/pci-legacy.c
@@ -86,8 +86,7 @@ static void pcibios_scanbus(struct pci_controller *hose)
 				hose->mem_resource, hose->mem_offset);
 	pci_add_resource_offset(&resources,
 				hose->io_resource, hose->io_offset);
-	pci_add_resource_offset(&resources,
-				hose->busn_resource, hose->busn_offset);
+	pci_add_resource(&resources, hose->busn_resource);
 	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
 				&resources);
 	hose->bus = bus;

commit edb0b6a0b4490014924d56c4c7117c7c8fc608ca
Author: Mathias Kresin <dev@kresin.me>
Date:   Sun Mar 26 19:05:36 2017 +0200

    MIPS: PCI: add controllers before the specified head
    
    With commit 23dac14d058f ("MIPS: PCI: Use struct list_head lists") new
    controllers are added after the specified head where they where added
    before the specified head previously.
    
    Use list_add_tail to restore the former order.
    
    This patches fixes the following PCI error on lantiq:
    
      pci 0000:01:00.0: BAR 0: error updating (0x1c000004 != 0x000000)
    
    Fixes: 23dac14d058f ("MIPS: PCI: Use struct list_head lists")
    Signed-off-by: Mathias Kresin <dev@kresin.me>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/15808/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-legacy.c b/arch/mips/pci/pci-legacy.c
index 014649be158d..3a84f6c0c840 100644
--- a/arch/mips/pci/pci-legacy.c
+++ b/arch/mips/pci/pci-legacy.c
@@ -190,7 +190,7 @@ void register_pci_controller(struct pci_controller *hose)
 	}
 
 	INIT_LIST_HEAD(&hose->list);
-	list_add(&hose->list, &controllers);
+	list_add_tail(&hose->list, &controllers);
 
 	/*
 	 * Do not panic here but later - this might happen before console init.

commit f8091a88978b68df8ee6095eed0de2177eac3c69
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Wed Oct 5 18:18:11 2016 +0100

    MIPS: PCI: Split pci.c into pci.c & pci-legacy.c
    
    Split out the parts of pci.c that are used by existing systems with
    MIPS-style PCI drivers but that will not be used by systems with more
    generic PCI drivers such as pcie-xilinx. This is done in preparation for
    allowing configurations where the code moved to pci-legacy.c is not
    built.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Paul Burton <paul.burton@imgtec.com>
    Patchwork: https://patchwork.linux-mips.org/patch/14344/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci-legacy.c b/arch/mips/pci/pci-legacy.c
new file mode 100644
index 000000000000..014649be158d
--- /dev/null
+++ b/arch/mips/pci/pci-legacy.c
@@ -0,0 +1,302 @@
+/*
+ * This program is free software; you can redistribute	it and/or modify it
+ * under  the terms of	the GNU General	 Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Copyright (C) 2003, 04, 11 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2011 Wind River Systems,
+ *   written by Ralf Baechle (ralf@linux-mips.org)
+ */
+#include <linux/bug.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+#include <linux/of_address.h>
+
+#include <asm/cpu-info.h>
+
+/*
+ * If PCI_PROBE_ONLY in pci_flags is set, we don't change any PCI resource
+ * assignments.
+ */
+
+/*
+ * The PCI controller list.
+ */
+static LIST_HEAD(controllers);
+
+static int pci_initialized;
+
+/*
+ * We need to avoid collisions with `mirrored' VGA ports
+ * and other strange ISA hardware, so we always want the
+ * addresses to be allocated in the 0x000-0x0ff region
+ * modulo 0x400.
+ *
+ * Why? Because some silly external IO cards only decode
+ * the low 10 bits of the IO address. The 0x00-0xff region
+ * is reserved for motherboard devices that decode all 16
+ * bits, so it's ok to allocate at, say, 0x2800-0x28ff,
+ * but we want to try to avoid allocating at 0x2900-0x2bff
+ * which might have be mirrored at 0x0100-0x03ff..
+ */
+resource_size_t
+pcibios_align_resource(void *data, const struct resource *res,
+		       resource_size_t size, resource_size_t align)
+{
+	struct pci_dev *dev = data;
+	struct pci_controller *hose = dev->sysdata;
+	resource_size_t start = res->start;
+
+	if (res->flags & IORESOURCE_IO) {
+		/* Make sure we start at our min on all hoses */
+		if (start < PCIBIOS_MIN_IO + hose->io_resource->start)
+			start = PCIBIOS_MIN_IO + hose->io_resource->start;
+
+		/*
+		 * Put everything into 0x00-0xff region modulo 0x400
+		 */
+		if (start & 0x300)
+			start = (start + 0x3ff) & ~0x3ff;
+	} else if (res->flags & IORESOURCE_MEM) {
+		/* Make sure we start at our min on all hoses */
+		if (start < PCIBIOS_MIN_MEM + hose->mem_resource->start)
+			start = PCIBIOS_MIN_MEM + hose->mem_resource->start;
+	}
+
+	return start;
+}
+
+static void pcibios_scanbus(struct pci_controller *hose)
+{
+	static int next_busno;
+	static int need_domain_info;
+	LIST_HEAD(resources);
+	struct pci_bus *bus;
+
+	if (hose->get_busno && pci_has_flag(PCI_PROBE_ONLY))
+		next_busno = (*hose->get_busno)();
+
+	pci_add_resource_offset(&resources,
+				hose->mem_resource, hose->mem_offset);
+	pci_add_resource_offset(&resources,
+				hose->io_resource, hose->io_offset);
+	pci_add_resource_offset(&resources,
+				hose->busn_resource, hose->busn_offset);
+	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
+				&resources);
+	hose->bus = bus;
+
+	need_domain_info = need_domain_info || pci_domain_nr(bus);
+	set_pci_need_domain_info(hose, need_domain_info);
+
+	if (!bus) {
+		pci_free_resource_list(&resources);
+		return;
+	}
+
+	next_busno = bus->busn_res.end + 1;
+	/* Don't allow 8-bit bus number overflow inside the hose -
+	   reserve some space for bridges. */
+	if (next_busno > 224) {
+		next_busno = 0;
+		need_domain_info = 1;
+	}
+
+	/*
+	 * We insert PCI resources into the iomem_resource and
+	 * ioport_resource trees in either pci_bus_claim_resources()
+	 * or pci_bus_assign_resources().
+	 */
+	if (pci_has_flag(PCI_PROBE_ONLY)) {
+		pci_bus_claim_resources(bus);
+	} else {
+		pci_bus_size_bridges(bus);
+		pci_bus_assign_resources(bus);
+	}
+	pci_bus_add_devices(bus);
+}
+
+#ifdef CONFIG_OF
+void pci_load_of_ranges(struct pci_controller *hose, struct device_node *node)
+{
+	struct of_pci_range range;
+	struct of_pci_range_parser parser;
+
+	pr_info("PCI host bridge %s ranges:\n", node->full_name);
+	hose->of_node = node;
+
+	if (of_pci_range_parser_init(&parser, node))
+		return;
+
+	for_each_of_pci_range(&parser, &range) {
+		struct resource *res = NULL;
+
+		switch (range.flags & IORESOURCE_TYPE_BITS) {
+		case IORESOURCE_IO:
+			pr_info("  IO 0x%016llx..0x%016llx\n",
+				range.cpu_addr,
+				range.cpu_addr + range.size - 1);
+			hose->io_map_base =
+				(unsigned long)ioremap(range.cpu_addr,
+						       range.size);
+			res = hose->io_resource;
+			break;
+		case IORESOURCE_MEM:
+			pr_info(" MEM 0x%016llx..0x%016llx\n",
+				range.cpu_addr,
+				range.cpu_addr + range.size - 1);
+			res = hose->mem_resource;
+			break;
+		}
+		if (res != NULL)
+			of_pci_range_to_resource(&range, node, res);
+	}
+}
+
+struct device_node *pcibios_get_phb_of_node(struct pci_bus *bus)
+{
+	struct pci_controller *hose = bus->sysdata;
+
+	return of_node_get(hose->of_node);
+}
+#endif
+
+static DEFINE_MUTEX(pci_scan_mutex);
+
+void register_pci_controller(struct pci_controller *hose)
+{
+	struct resource *parent;
+
+	parent = hose->mem_resource->parent;
+	if (!parent)
+		parent = &iomem_resource;
+
+	if (request_resource(parent, hose->mem_resource) < 0)
+		goto out;
+
+	parent = hose->io_resource->parent;
+	if (!parent)
+		parent = &ioport_resource;
+
+	if (request_resource(parent, hose->io_resource) < 0) {
+		release_resource(hose->mem_resource);
+		goto out;
+	}
+
+	INIT_LIST_HEAD(&hose->list);
+	list_add(&hose->list, &controllers);
+
+	/*
+	 * Do not panic here but later - this might happen before console init.
+	 */
+	if (!hose->io_map_base) {
+		printk(KERN_WARNING
+		       "registering PCI controller with io_map_base unset\n");
+	}
+
+	/*
+	 * Scan the bus if it is register after the PCI subsystem
+	 * initialization.
+	 */
+	if (pci_initialized) {
+		mutex_lock(&pci_scan_mutex);
+		pcibios_scanbus(hose);
+		mutex_unlock(&pci_scan_mutex);
+	}
+
+	return;
+
+out:
+	printk(KERN_WARNING
+	       "Skipping PCI bus scan due to resource conflict\n");
+}
+
+static int __init pcibios_init(void)
+{
+	struct pci_controller *hose;
+
+	/* Scan all of the recorded PCI controllers.  */
+	list_for_each_entry(hose, &controllers, list)
+		pcibios_scanbus(hose);
+
+	pci_fixup_irqs(pci_common_swizzle, pcibios_map_irq);
+
+	pci_initialized = 1;
+
+	return 0;
+}
+
+subsys_initcall(pcibios_init);
+
+static int pcibios_enable_resources(struct pci_dev *dev, int mask)
+{
+	u16 cmd, old_cmd;
+	int idx;
+	struct resource *r;
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	old_cmd = cmd;
+	for (idx=0; idx < PCI_NUM_RESOURCES; idx++) {
+		/* Only set up the requested stuff */
+		if (!(mask & (1<<idx)))
+			continue;
+
+		r = &dev->resource[idx];
+		if (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))
+			continue;
+		if ((idx == PCI_ROM_RESOURCE) &&
+				(!(r->flags & IORESOURCE_ROM_ENABLE)))
+			continue;
+		if (!r->start && r->end) {
+			printk(KERN_ERR "PCI: Device %s not available "
+			       "because of resource collisions\n",
+			       pci_name(dev));
+			return -EINVAL;
+		}
+		if (r->flags & IORESOURCE_IO)
+			cmd |= PCI_COMMAND_IO;
+		if (r->flags & IORESOURCE_MEM)
+			cmd |= PCI_COMMAND_MEMORY;
+	}
+	if (cmd != old_cmd) {
+		printk("PCI: Enabling device %s (%04x -> %04x)\n",
+		       pci_name(dev), old_cmd, cmd);
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+	return 0;
+}
+
+int pcibios_enable_device(struct pci_dev *dev, int mask)
+{
+	int err;
+
+	if ((err = pcibios_enable_resources(dev, mask)) < 0)
+		return err;
+
+	return pcibios_plat_dev_init(dev);
+}
+
+void pcibios_fixup_bus(struct pci_bus *bus)
+{
+	struct pci_dev *dev = bus->self;
+
+	if (pci_has_flag(PCI_PROBE_ONLY) && dev &&
+	    (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
+		pci_read_bridge_bases(bus);
+	}
+}
+
+char * (*pcibios_plat_setup)(char *str) __initdata;
+
+char *__init pcibios_setup(char *str)
+{
+	if (pcibios_plat_setup)
+		return pcibios_plat_setup(str);
+	return str;
+}
