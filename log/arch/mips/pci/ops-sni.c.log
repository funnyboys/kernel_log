commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-sni.c b/arch/mips/pci/ops-sni.c
index 97ed25b92edf..35daa7fe6571 100644
--- a/arch/mips/pci/ops-sni.c
+++ b/arch/mips/pci/ops-sni.c
@@ -14,8 +14,8 @@
 
 /*
  * It seems that on the RM200 only lower 3 bits of the 5 bit PCI device
- * address are decoded.  We therefore manually have to reject attempts at
- * reading outside this range.  Being on the paranoid side we only do this
+ * address are decoded.	 We therefore manually have to reject attempts at
+ * reading outside this range.	Being on the paranoid side we only do this
  * test for bus 0 and hope forwarding and decoding work properly for any
  * subordinated busses.
  *
@@ -31,8 +31,8 @@ static int set_config_address(unsigned int busno, unsigned int devfn, int reg)
 
 	*(volatile u32 *)PCIMT_CONFIG_ADDRESS =
 		 ((busno    & 0xff) << 16) |
-	         ((devfn    & 0xff) <<  8) |
-	          (reg      & 0xfc);
+		 ((devfn    & 0xff) <<	8) |
+		  (reg	    & 0xfc);
 
 	return PCIBIOS_SUCCESSFUL;
 }

commit 49a89efbbbcc178a39555c43bd59a7593c429664
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:15 2007 +0100

    [MIPS] Fix "no space between function name and open parenthesis" warnings.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-sni.c b/arch/mips/pci/ops-sni.c
index fa2d2c60f797..97ed25b92edf 100644
--- a/arch/mips/pci/ops-sni.c
+++ b/arch/mips/pci/ops-sni.c
@@ -70,13 +70,13 @@ static int pcimt_write(struct pci_bus *bus, unsigned int devfn, int reg,
 
 	switch (size) {
 	case 1:
-		outb (val, PCIMT_CONFIG_DATA + (reg & 3));
+		outb(val, PCIMT_CONFIG_DATA + (reg & 3));
 		break;
 	case 2:
-		outw (val, PCIMT_CONFIG_DATA + (reg & 2));
+		outw(val, PCIMT_CONFIG_DATA + (reg & 2));
 		break;
 	case 4:
-		outl (val, PCIMT_CONFIG_DATA);
+		outl(val, PCIMT_CONFIG_DATA);
 		break;
 	}
 
@@ -93,7 +93,7 @@ static int pcit_set_config_address(unsigned int busno, unsigned int devfn, int r
 	if ((devfn > 255) || (reg > 255) || (busno > 255))
 		return PCIBIOS_BAD_REGISTER_NUMBER;
 
-	outl ((1 << 31) | ((busno & 0xff) << 16) | ((devfn & 0xff) << 8) | (reg & 0xfc), 0xcf8);
+	outl((1 << 31) | ((busno & 0xff) << 16) | ((devfn & 0xff) << 8) | (reg & 0xfc), 0xcf8);
 	return PCIBIOS_SUCCESSFUL;
 }
 
@@ -108,12 +108,12 @@ static int pcit_read(struct pci_bus *bus, unsigned int devfn, int reg,
 	 * we don't do it, we will get a data bus error
 	 */
 	if (bus->number == 0) {
-		pcit_set_config_address (0, 0, 0x68);
-		outl (inl (0xcfc) | 0xc0000000, 0xcfc);
+		pcit_set_config_address(0, 0, 0x68);
+		outl(inl(0xcfc) | 0xc0000000, 0xcfc);
 		if ((res = pcit_set_config_address(0, devfn, 0)))
 			return res;
-		outl (0xffffffff, 0xcfc);
-		pcit_set_config_address (0, 0, 0x68);
+		outl(0xffffffff, 0xcfc);
+		pcit_set_config_address(0, 0, 0x68);
 		if (inl(0xcfc) & 0x100000)
 			return PCIBIOS_DEVICE_NOT_FOUND;
 	}
@@ -144,13 +144,13 @@ static int pcit_write(struct pci_bus *bus, unsigned int devfn, int reg,
 
 	switch (size) {
 	case 1:
-		outb (val, PCIMT_CONFIG_DATA + (reg & 3));
+		outb(val, PCIMT_CONFIG_DATA + (reg & 3));
 		break;
 	case 2:
-		outw (val, PCIMT_CONFIG_DATA + (reg & 2));
+		outw(val, PCIMT_CONFIG_DATA + (reg & 2));
 		break;
 	case 4:
-		outl (val, PCIMT_CONFIG_DATA);
+		outl(val, PCIMT_CONFIG_DATA);
 		break;
 	}
 

commit c066a32a890c50ce59e91f8cea8eb5fd8d5821b9
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Thu Dec 28 18:22:32 2006 +0100

    [MIPS] Support for several more SNI RM models.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-sni.c b/arch/mips/pci/ops-sni.c
index 2b0ccd6d9dcd..fa2d2c60f797 100644
--- a/arch/mips/pci/ops-sni.c
+++ b/arch/mips/pci/ops-sni.c
@@ -83,7 +83,82 @@ static int pcimt_write(struct pci_bus *bus, unsigned int devfn, int reg,
 	return 0;
 }
 
-struct pci_ops sni_pci_ops = {
+struct pci_ops sni_pcimt_ops = {
 	.read = pcimt_read,
 	.write = pcimt_write,
 };
+
+static int pcit_set_config_address(unsigned int busno, unsigned int devfn, int reg)
+{
+	if ((devfn > 255) || (reg > 255) || (busno > 255))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	outl ((1 << 31) | ((busno & 0xff) << 16) | ((devfn & 0xff) << 8) | (reg & 0xfc), 0xcf8);
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pcit_read(struct pci_bus *bus, unsigned int devfn, int reg,
+		      int size, u32 * val)
+{
+	int res;
+
+	/*
+	 * on bus 0 we need to check, whether there is a device answering
+	 * for the devfn by doing a config write and checking the result. If
+	 * we don't do it, we will get a data bus error
+	 */
+	if (bus->number == 0) {
+		pcit_set_config_address (0, 0, 0x68);
+		outl (inl (0xcfc) | 0xc0000000, 0xcfc);
+		if ((res = pcit_set_config_address(0, devfn, 0)))
+			return res;
+		outl (0xffffffff, 0xcfc);
+		pcit_set_config_address (0, 0, 0x68);
+		if (inl(0xcfc) & 0x100000)
+			return PCIBIOS_DEVICE_NOT_FOUND;
+	}
+	if ((res = pcit_set_config_address(bus->number, devfn, reg)))
+		return res;
+
+	switch (size) {
+	case 1:
+		*val = inb(PCIMT_CONFIG_DATA + (reg & 3));
+		break;
+	case 2:
+		*val = inw(PCIMT_CONFIG_DATA + (reg & 2));
+		break;
+	case 4:
+		*val = inl(PCIMT_CONFIG_DATA);
+		break;
+	}
+	return 0;
+}
+
+static int pcit_write(struct pci_bus *bus, unsigned int devfn, int reg,
+		       int size, u32 val)
+{
+	int res;
+
+	if ((res = pcit_set_config_address(bus->number, devfn, reg)))
+		return res;
+
+	switch (size) {
+	case 1:
+		outb (val, PCIMT_CONFIG_DATA + (reg & 3));
+		break;
+	case 2:
+		outw (val, PCIMT_CONFIG_DATA + (reg & 2));
+		break;
+	case 4:
+		outl (val, PCIMT_CONFIG_DATA);
+		break;
+	}
+
+	return 0;
+}
+
+
+struct pci_ops sni_pcit_ops = {
+	.read = pcit_read,
+	.write = pcit_write,
+};

commit 4a0312fca6599299bbed944ce09278d90388a3e5
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Tue Jun 13 13:59:01 2006 +0200

    [MIPS] Support SNI RM200C SNI in big endian mode and R5000 processors.
    
    Added support for RM200C machines with big endian firmware
    Added support for RM200-C40 (R5000 support)
    
    Signed-off-by: Florian Lohoff <flo@rfc822.org>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/ops-sni.c b/arch/mips/pci/ops-sni.c
index 62bdd19c7f8e..2b0ccd6d9dcd 100644
--- a/arch/mips/pci/ops-sni.c
+++ b/arch/mips/pci/ops-sni.c
@@ -47,13 +47,13 @@ static int pcimt_read(struct pci_bus *bus, unsigned int devfn, int reg,
 
 	switch (size) {
 	case 1:
-		*val = *(volatile  u8 *) (PCIMT_CONFIG_DATA + (reg & 3));
+		*val = inb(PCIMT_CONFIG_DATA + (reg & 3));
 		break;
 	case 2:
-		*val = *(volatile u16 *) (PCIMT_CONFIG_DATA + (reg & 2));
+		*val = inw(PCIMT_CONFIG_DATA + (reg & 2));
 		break;
 	case 4:
-		*val = *(volatile u32 *) PCIMT_CONFIG_DATA;
+		*val = inl(PCIMT_CONFIG_DATA);
 		break;
 	}
 
@@ -70,13 +70,13 @@ static int pcimt_write(struct pci_bus *bus, unsigned int devfn, int reg,
 
 	switch (size) {
 	case 1:
-		*(volatile  u8 *) (PCIMT_CONFIG_DATA + (reg & 3)) = val;
+		outb (val, PCIMT_CONFIG_DATA + (reg & 3));
 		break;
 	case 2:
-		*(volatile u16 *) (PCIMT_CONFIG_DATA + (reg & 2)) = val;
+		outw (val, PCIMT_CONFIG_DATA + (reg & 2));
 		break;
 	case 4:
-		*(volatile u32 *) PCIMT_CONFIG_DATA = val;
+		outl (val, PCIMT_CONFIG_DATA);
 		break;
 	}
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/pci/ops-sni.c b/arch/mips/pci/ops-sni.c
new file mode 100644
index 000000000000..62bdd19c7f8e
--- /dev/null
+++ b/arch/mips/pci/ops-sni.c
@@ -0,0 +1,89 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * SNI specific PCI support for RM200/RM300.
+ *
+ * Copyright (C) 1997 - 2000, 2003 Ralf Baechle <ralf@linux-mips.org>
+ */
+#include <linux/kernel.h>
+#include <linux/pci.h>
+#include <linux/types.h>
+#include <asm/sni.h>
+
+/*
+ * It seems that on the RM200 only lower 3 bits of the 5 bit PCI device
+ * address are decoded.  We therefore manually have to reject attempts at
+ * reading outside this range.  Being on the paranoid side we only do this
+ * test for bus 0 and hope forwarding and decoding work properly for any
+ * subordinated busses.
+ *
+ * ASIC PCI only supports type 1 config cycles.
+ */
+static int set_config_address(unsigned int busno, unsigned int devfn, int reg)
+{
+	if ((devfn > 255) || (reg > 255))
+		return PCIBIOS_BAD_REGISTER_NUMBER;
+
+	if (busno == 0 && devfn >= PCI_DEVFN(8, 0))
+		return PCIBIOS_DEVICE_NOT_FOUND;
+
+	*(volatile u32 *)PCIMT_CONFIG_ADDRESS =
+		 ((busno    & 0xff) << 16) |
+	         ((devfn    & 0xff) <<  8) |
+	          (reg      & 0xfc);
+
+	return PCIBIOS_SUCCESSFUL;
+}
+
+static int pcimt_read(struct pci_bus *bus, unsigned int devfn, int reg,
+		      int size, u32 * val)
+{
+	int res;
+
+	if ((res = set_config_address(bus->number, devfn, reg)))
+		return res;
+
+	switch (size) {
+	case 1:
+		*val = *(volatile  u8 *) (PCIMT_CONFIG_DATA + (reg & 3));
+		break;
+	case 2:
+		*val = *(volatile u16 *) (PCIMT_CONFIG_DATA + (reg & 2));
+		break;
+	case 4:
+		*val = *(volatile u32 *) PCIMT_CONFIG_DATA;
+		break;
+	}
+
+	return 0;
+}
+
+static int pcimt_write(struct pci_bus *bus, unsigned int devfn, int reg,
+		       int size, u32 val)
+{
+	int res;
+
+	if ((res = set_config_address(bus->number, devfn, reg)))
+		return res;
+
+	switch (size) {
+	case 1:
+		*(volatile  u8 *) (PCIMT_CONFIG_DATA + (reg & 3)) = val;
+		break;
+	case 2:
+		*(volatile u16 *) (PCIMT_CONFIG_DATA + (reg & 2)) = val;
+		break;
+	case 4:
+		*(volatile u32 *) PCIMT_CONFIG_DATA = val;
+		break;
+	}
+
+	return 0;
+}
+
+struct pci_ops sni_pci_ops = {
+	.read = pcimt_read,
+	.write = pcimt_write,
+};
