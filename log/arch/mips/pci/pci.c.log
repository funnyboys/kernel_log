commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index e68b44b27c0d..feebc6eeee5b 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -1,8 +1,5 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
- * This program is free software; you can redistribute	it and/or modify it
- * under  the terms of	the GNU General	 Public License as published by the
- * Free Software Foundation;  either version 2 of the  License, or (at your
- * option) any later version.
  *
  * Copyright (C) 2003, 04, 11 Ralf Baechle (ralf@linux-mips.org)
  * Copyright (C) 2011 Wind River Systems,

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index c2e94cf5ecda..e68b44b27c0d 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -11,7 +11,7 @@
 #include <linux/bug.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
-#include <linux/bootmem.h>
+#include <linux/memblock.h>
 #include <linux/export.h>
 #include <linux/init.h>
 #include <linux/types.h>

commit 38c0a74fe06da3be133cae3fb7bde6a9438e698b
Author: Paul Burton <paul.burton@mips.com>
Date:   Thu Jul 12 09:33:04 2018 -0700

    MIPS: Fix off-by-one in pci_resource_to_user()
    
    The MIPS implementation of pci_resource_to_user() introduced in v3.12 by
    commit 4c2924b725fb ("MIPS: PCI: Use pci_resource_to_user to map pci
    memory space properly") incorrectly sets *end to the address of the
    byte after the resource, rather than the last byte of the resource.
    
    This results in userland seeing resources as a byte larger than they
    actually are, for example a 32 byte BAR will be reported by a tool such
    as lspci as being 33 bytes in size:
    
        Region 2: I/O ports at 1000 [disabled] [size=33]
    
    Correct this by subtracting one from the calculated end address,
    reporting the correct address to userland.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Reported-by: Rui Wang <rui.wang@windriver.com>
    Fixes: 4c2924b725fb ("MIPS: PCI: Use pci_resource_to_user to map pci memory space properly")
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Wolfgang Grandegger <wg@grandegger.com>
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org # v3.12+
    Patchwork: https://patchwork.linux-mips.org/patch/19829/

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 9632436d74d7..c2e94cf5ecda 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -54,5 +54,5 @@ void pci_resource_to_user(const struct pci_dev *dev, int bar,
 	phys_addr_t size = resource_size(rsrc);
 
 	*start = fixup_bigphys_addr(rsrc->start, size);
-	*end = rsrc->start + size;
+	*end = rsrc->start + size - 1;
 }

commit 735302665c353d6756e7fa2a2cf41b039299f732
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Wed Jul 26 08:41:09 2017 +0100

    MIPS: PCI: Fix smp_processor_id() in preemptible
    
    Commit 1c3c5eab1715 ("sched/core: Enable might_sleep() and
    smp_processor_id() checks early") enables checks for might_sleep() and
    smp_processor_id() being used in preemptible code earlier in the boot
    than before. This results in a new BUG from
    pcibios_set_cache_line_size().
    
    BUG: using smp_processor_id() in preemptible [00000000] code:
    swapper/0/1 caller is pcibios_set_cache_line_size+0x10/0x70
    CPU: 1 PID: 1 Comm: swapper/0 Not tainted 4.13.0-rc1-00007-g3ce3e4ba4275 #615
    Stack: 0000000000000000 ffffffff81189694 0000000000000000 ffffffff81822318
           000000000000004e 0000000000000001 800000000e20bd08 20c49ba5e3540000
           0000000000000000 0000000000000000 ffffffff818d0000 0000000000000000
           0000000000000000 ffffffff81189328 ffffffff818ce692 0000000000000000
           0000000000000000 ffffffff81189bc8 ffffffff818d0000 0000000000000000
           ffffffff81828907 ffffffff81769970 800000020ec78d80 ffffffff818c7b48
           0000000000000001 0000000000000001 ffffffff818652b0 ffffffff81896268
           ffffffff818c0000 800000020ec7fb40 800000020ec7fc58 ffffffff81684cac
           0000000000000000 ffffffff8118ab50 0000000000000030 ffffffff81769970
           0000000000000001 ffffffff81122a58 0000000000000000 0000000000000000 ...
    Call Trace:
    [<ffffffff81122a58>] show_stack+0x90/0xb0
    [<ffffffff81684cac>] dump_stack+0xac/0xf0
    [<ffffffff813f7050>] check_preemption_disabled+0x120/0x128
    [<ffffffff818855e8>] pcibios_set_cache_line_size+0x10/0x70
    [<ffffffff81100578>] do_one_initcall+0x48/0x140
    [<ffffffff81865dc4>] kernel_init_freeable+0x194/0x24c
    [<ffffffff8169c534>] kernel_init+0x14/0x118
    [<ffffffff8111ca84>] ret_from_kernel_thread+0x14/0x1c
    
    Fix this by using the cpu_*cache_line_size() macros instead. These
    macros are the "proper" way to determine the CPU cache sizes.
    This makes use of the newly added cpu_tcache_line_size.
    
    Fixes: 1c3c5eab1715 ("sched/core: Enable might_sleep() and smp_processor_id() checks early")
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Suggested-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index bd67ac74fe2d..9632436d74d7 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -28,16 +28,15 @@ EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
 
 static int __init pcibios_set_cache_line_size(void)
 {
-	struct cpuinfo_mips *c = &current_cpu_data;
 	unsigned int lsize;
 
 	/*
 	 * Set PCI cacheline size to that of the highest level in the
 	 * cache hierarchy.
 	 */
-	lsize = c->dcache.linesz;
-	lsize = c->scache.linesz ? : lsize;
-	lsize = c->tcache.linesz ? : lsize;
+	lsize = cpu_dcache_line_size();
+	lsize = cpu_scache_line_size() ? : lsize;
+	lsize = cpu_tcache_line_size() ? : lsize;
 
 	BUG_ON(!lsize);
 

commit 35368f80403d32a993587c7f26cd3bcede3ed202
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Wed Apr 12 13:26:02 2017 +0100

    MIPS: PCI: Use generic pci_mmap_resource_range()
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index f189502041a6..bd67ac74fe2d 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -57,28 +57,3 @@ void pci_resource_to_user(const struct pci_dev *dev, int bar,
 	*start = fixup_bigphys_addr(rsrc->start, size);
 	*end = rsrc->start + size;
 }
-
-int pci_mmap_page_range(struct pci_dev *dev, int bar,
-			struct vm_area_struct *vma,
-			enum pci_mmap_state mmap_state, int write_combine)
-{
-	unsigned long prot;
-
-	/*
-	 * I/O space can be accessed via normal processor loads and stores on
-	 * this platform but for now we elect not to do this and portable
-	 * drivers should not do this anyway.
-	 */
-	if (mmap_state == pci_mmap_io)
-		return -EINVAL;
-
-	/*
-	 * Ignore write-combine; for now only return uncached mappings.
-	 */
-	prot = pgprot_val(vma->vm_page_prot);
-	prot = (prot & ~_CACHE_MASK) | _CACHE_UNCACHED;
-	vma->vm_page_prot = __pgprot(prot);
-
-	return remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
-		vma->vm_end - vma->vm_start, vma->vm_page_prot);
-}

commit f66e225828c1b046c7db1db65b0dd2d135f6a2da
Author: David Woodhouse <dwmw@amazon.co.uk>
Date:   Wed Apr 12 13:25:58 2017 +0100

    PCI: Add BAR index argument to pci_mmap_page_range()
    
    In all cases we know which BAR it is.  Passing it in means that arch code
    (or generic code; watch this space) won't have to go looking for it again.
    
    Signed-off-by: David Woodhouse <dwmw@amazon.co.uk>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index f6325fa657fb..f189502041a6 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -58,7 +58,8 @@ void pci_resource_to_user(const struct pci_dev *dev, int bar,
 	*end = rsrc->start + size;
 }
 
-int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
+int pci_mmap_page_range(struct pci_dev *dev, int bar,
+			struct vm_area_struct *vma,
 			enum pci_mmap_state mmap_state, int write_combine)
 {
 	unsigned long prot;

commit f8091a88978b68df8ee6095eed0de2177eac3c69
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Wed Oct 5 18:18:11 2016 +0100

    MIPS: PCI: Split pci.c into pci.c & pci-legacy.c
    
    Split out the parts of pci.c that are used by existing systems with
    MIPS-style PCI drivers but that will not be used by systems with more
    generic PCI drivers such as pcie-xilinx. This is done in preparation for
    allowing configurations where the code moved to pci-legacy.c is not
    built.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Paul Burton <paul.burton@imgtec.com>
    Patchwork: https://patchwork.linux-mips.org/patch/14344/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 8cc6ea4e9481..f6325fa657fb 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -20,205 +20,11 @@
 
 #include <asm/cpu-info.h>
 
-/*
- * If PCI_PROBE_ONLY in pci_flags is set, we don't change any PCI resource
- * assignments.
- */
-
-/*
- * The PCI controller list.
- */
-static LIST_HEAD(controllers);
-
 unsigned long PCIBIOS_MIN_IO;
-unsigned long PCIBIOS_MIN_MEM;
-
-static int pci_initialized;
-
-/*
- * We need to avoid collisions with `mirrored' VGA ports
- * and other strange ISA hardware, so we always want the
- * addresses to be allocated in the 0x000-0x0ff region
- * modulo 0x400.
- *
- * Why? Because some silly external IO cards only decode
- * the low 10 bits of the IO address. The 0x00-0xff region
- * is reserved for motherboard devices that decode all 16
- * bits, so it's ok to allocate at, say, 0x2800-0x28ff,
- * but we want to try to avoid allocating at 0x2900-0x2bff
- * which might have be mirrored at 0x0100-0x03ff..
- */
-resource_size_t
-pcibios_align_resource(void *data, const struct resource *res,
-		       resource_size_t size, resource_size_t align)
-{
-	struct pci_dev *dev = data;
-	struct pci_controller *hose = dev->sysdata;
-	resource_size_t start = res->start;
-
-	if (res->flags & IORESOURCE_IO) {
-		/* Make sure we start at our min on all hoses */
-		if (start < PCIBIOS_MIN_IO + hose->io_resource->start)
-			start = PCIBIOS_MIN_IO + hose->io_resource->start;
-
-		/*
-		 * Put everything into 0x00-0xff region modulo 0x400
-		 */
-		if (start & 0x300)
-			start = (start + 0x3ff) & ~0x3ff;
-	} else if (res->flags & IORESOURCE_MEM) {
-		/* Make sure we start at our min on all hoses */
-		if (start < PCIBIOS_MIN_MEM + hose->mem_resource->start)
-			start = PCIBIOS_MIN_MEM + hose->mem_resource->start;
-	}
-
-	return start;
-}
-
-static void pcibios_scanbus(struct pci_controller *hose)
-{
-	static int next_busno;
-	static int need_domain_info;
-	LIST_HEAD(resources);
-	struct pci_bus *bus;
-
-	if (hose->get_busno && pci_has_flag(PCI_PROBE_ONLY))
-		next_busno = (*hose->get_busno)();
-
-	pci_add_resource_offset(&resources,
-				hose->mem_resource, hose->mem_offset);
-	pci_add_resource_offset(&resources,
-				hose->io_resource, hose->io_offset);
-	pci_add_resource_offset(&resources,
-				hose->busn_resource, hose->busn_offset);
-	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
-				&resources);
-	hose->bus = bus;
-
-	need_domain_info = need_domain_info || pci_domain_nr(bus);
-	set_pci_need_domain_info(hose, need_domain_info);
-
-	if (!bus) {
-		pci_free_resource_list(&resources);
-		return;
-	}
-
-	next_busno = bus->busn_res.end + 1;
-	/* Don't allow 8-bit bus number overflow inside the hose -
-	   reserve some space for bridges. */
-	if (next_busno > 224) {
-		next_busno = 0;
-		need_domain_info = 1;
-	}
-
-	/*
-	 * We insert PCI resources into the iomem_resource and
-	 * ioport_resource trees in either pci_bus_claim_resources()
-	 * or pci_bus_assign_resources().
-	 */
-	if (pci_has_flag(PCI_PROBE_ONLY)) {
-		pci_bus_claim_resources(bus);
-	} else {
-		pci_bus_size_bridges(bus);
-		pci_bus_assign_resources(bus);
-	}
-	pci_bus_add_devices(bus);
-}
-
-#ifdef CONFIG_OF
-void pci_load_of_ranges(struct pci_controller *hose, struct device_node *node)
-{
-	struct of_pci_range range;
-	struct of_pci_range_parser parser;
-
-	pr_info("PCI host bridge %s ranges:\n", node->full_name);
-	hose->of_node = node;
-
-	if (of_pci_range_parser_init(&parser, node))
-		return;
-
-	for_each_of_pci_range(&parser, &range) {
-		struct resource *res = NULL;
-
-		switch (range.flags & IORESOURCE_TYPE_BITS) {
-		case IORESOURCE_IO:
-			pr_info("  IO 0x%016llx..0x%016llx\n",
-				range.cpu_addr,
-				range.cpu_addr + range.size - 1);
-			hose->io_map_base =
-				(unsigned long)ioremap(range.cpu_addr,
-						       range.size);
-			res = hose->io_resource;
-			break;
-		case IORESOURCE_MEM:
-			pr_info(" MEM 0x%016llx..0x%016llx\n",
-				range.cpu_addr,
-				range.cpu_addr + range.size - 1);
-			res = hose->mem_resource;
-			break;
-		}
-		if (res != NULL)
-			of_pci_range_to_resource(&range, node, res);
-	}
-}
-
-struct device_node *pcibios_get_phb_of_node(struct pci_bus *bus)
-{
-	struct pci_controller *hose = bus->sysdata;
-
-	return of_node_get(hose->of_node);
-}
-#endif
-
-static DEFINE_MUTEX(pci_scan_mutex);
-
-void register_pci_controller(struct pci_controller *hose)
-{
-	struct resource *parent;
-
-	parent = hose->mem_resource->parent;
-	if (!parent)
-		parent = &iomem_resource;
-
-	if (request_resource(parent, hose->mem_resource) < 0)
-		goto out;
-
-	parent = hose->io_resource->parent;
-	if (!parent)
-		parent = &ioport_resource;
-
-	if (request_resource(parent, hose->io_resource) < 0) {
-		release_resource(hose->mem_resource);
-		goto out;
-	}
-
-	INIT_LIST_HEAD(&hose->list);
-	list_add(&hose->list, &controllers);
-
-	/*
-	 * Do not panic here but later - this might happen before console init.
-	 */
-	if (!hose->io_map_base) {
-		printk(KERN_WARNING
-		       "registering PCI controller with io_map_base unset\n");
-	}
-
-	/*
-	 * Scan the bus if it is register after the PCI subsystem
-	 * initialization.
-	 */
-	if (pci_initialized) {
-		mutex_lock(&pci_scan_mutex);
-		pcibios_scanbus(hose);
-		mutex_unlock(&pci_scan_mutex);
-	}
-
-	return;
+EXPORT_SYMBOL(PCIBIOS_MIN_IO);
 
-out:
-	printk(KERN_WARNING
-	       "Skipping PCI bus scan due to resource conflict\n");
-}
+unsigned long PCIBIOS_MIN_MEM;
+EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
 
 static int __init pcibios_set_cache_line_size(void)
 {
@@ -242,84 +48,6 @@ static int __init pcibios_set_cache_line_size(void)
 }
 arch_initcall(pcibios_set_cache_line_size);
 
-static int __init pcibios_init(void)
-{
-	struct pci_controller *hose;
-
-	/* Scan all of the recorded PCI controllers.  */
-	list_for_each_entry(hose, &controllers, list)
-		pcibios_scanbus(hose);
-
-	pci_fixup_irqs(pci_common_swizzle, pcibios_map_irq);
-
-	pci_initialized = 1;
-
-	return 0;
-}
-
-subsys_initcall(pcibios_init);
-
-static int pcibios_enable_resources(struct pci_dev *dev, int mask)
-{
-	u16 cmd, old_cmd;
-	int idx;
-	struct resource *r;
-
-	pci_read_config_word(dev, PCI_COMMAND, &cmd);
-	old_cmd = cmd;
-	for (idx=0; idx < PCI_NUM_RESOURCES; idx++) {
-		/* Only set up the requested stuff */
-		if (!(mask & (1<<idx)))
-			continue;
-
-		r = &dev->resource[idx];
-		if (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))
-			continue;
-		if ((idx == PCI_ROM_RESOURCE) &&
-				(!(r->flags & IORESOURCE_ROM_ENABLE)))
-			continue;
-		if (!r->start && r->end) {
-			printk(KERN_ERR "PCI: Device %s not available "
-			       "because of resource collisions\n",
-			       pci_name(dev));
-			return -EINVAL;
-		}
-		if (r->flags & IORESOURCE_IO)
-			cmd |= PCI_COMMAND_IO;
-		if (r->flags & IORESOURCE_MEM)
-			cmd |= PCI_COMMAND_MEMORY;
-	}
-	if (cmd != old_cmd) {
-		printk("PCI: Enabling device %s (%04x -> %04x)\n",
-		       pci_name(dev), old_cmd, cmd);
-		pci_write_config_word(dev, PCI_COMMAND, cmd);
-	}
-	return 0;
-}
-
-int pcibios_enable_device(struct pci_dev *dev, int mask)
-{
-	int err;
-
-	if ((err = pcibios_enable_resources(dev, mask)) < 0)
-		return err;
-
-	return pcibios_plat_dev_init(dev);
-}
-
-void pcibios_fixup_bus(struct pci_bus *bus)
-{
-	struct pci_dev *dev = bus->self;
-
-	if (pci_has_flag(PCI_PROBE_ONLY) && dev &&
-	    (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
-		pci_read_bridge_bases(bus);
-	}
-}
-
-EXPORT_SYMBOL(PCIBIOS_MIN_IO);
-EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
-
 void pci_resource_to_user(const struct pci_dev *dev, int bar,
 			  const struct resource *rsrc, resource_size_t *start,
 			  resource_size_t *end)
@@ -353,12 +81,3 @@ int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
 	return remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
 		vma->vm_end - vma->vm_start, vma->vm_page_prot);
 }
-
-char * (*pcibios_plat_setup)(char *str) __initdata;
-
-char *__init pcibios_setup(char *str)
-{
-	if (pcibios_plat_setup)
-		return pcibios_plat_setup(str);
-	return str;
-}

commit ab96b03144c5392b8c0c427cc37df34daa84c5d0
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Wed Oct 5 18:18:10 2016 +0100

    MIPS: PCI: Inline pcibios_assign_all_busses
    
    The MIPS implementation of pcibios_assign_all_busses trivially returns
    1. Implement it as a static function in asm/pci.h such that the compiler
    can inline it & optimise out never-taken paths.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14343/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 30320a4c8909..8cc6ea4e9481 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -297,11 +297,6 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 	return 0;
 }
 
-unsigned int pcibios_assign_all_busses(void)
-{
-	return 1;
-}
-
 int pcibios_enable_device(struct pci_dev *dev, int mask)
 {
 	int err;

commit f474ba9d9f275fc3bfe459b48bfc17ddd8e1f4cb
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Wed Oct 5 18:18:09 2016 +0100

    MIPS: PCI: Make pcibios_set_cache_line_size an initcall
    
    In preparation for allowing configurations in which pcibios_init is not
    included, make pcibios_set_cache_line_size an initcall. arch_initcall is
    used such that it runs before the pcibios_init subsys_initcall for
    platforms that continue to use it.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14342/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 5207c043c69c..30320a4c8909 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -220,7 +220,7 @@ void register_pci_controller(struct pci_controller *hose)
 	       "Skipping PCI bus scan due to resource conflict\n");
 }
 
-static void __init pcibios_set_cache_line_size(void)
+static int __init pcibios_set_cache_line_size(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
 	unsigned int lsize;
@@ -238,14 +238,14 @@ static void __init pcibios_set_cache_line_size(void)
 	pci_dfl_cache_line_size = lsize >> 2;
 
 	pr_debug("PCI: pci_cache_line_size set to %d bytes\n", lsize);
+	return 0;
 }
+arch_initcall(pcibios_set_cache_line_size);
 
 static int __init pcibios_init(void)
 {
 	struct pci_controller *hose;
 
-	pcibios_set_cache_line_size();
-
 	/* Scan all of the recorded PCI controllers.  */
 	list_for_each_entry(hose, &controllers, list)
 		pcibios_scanbus(hose);

commit 88555b481958083b1b928a4ba5c6e3bc606ce34b
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Wed Oct 5 18:18:08 2016 +0100

    MIPS: PCI: Support for CONFIG_PCI_DOMAINS_GENERIC
    
    Introduce support for CONFIG_PCI_DOMAINS_GENERIC, allowing for platforms
    to make use of generic PCI domains instead of the MIPS-specific
    implementation. The set_pci_need_domain_info function is introduced to
    abstract away the removed need_domain_info field in struct
    pci_controller, and pcibios_scanbus is adjusted to use the pci_domain_nr
    accessor instead of directly accessing the index field.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14341/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 644ae9696edd..5207c043c69c 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -95,8 +95,8 @@ static void pcibios_scanbus(struct pci_controller *hose)
 				&resources);
 	hose->bus = bus;
 
-	need_domain_info = need_domain_info || hose->index;
-	hose->need_domain_info = need_domain_info;
+	need_domain_info = need_domain_info || pci_domain_nr(bus);
+	set_pci_need_domain_info(hose, need_domain_info);
 
 	if (!bus) {
 		pci_free_resource_list(&resources);

commit 23dac14d058fcd7cb2b4e6389139ca065855afe7
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Wed Oct 5 18:18:07 2016 +0100

    MIPS: PCI: Use struct list_head lists
    
    Rather than open-coding a linked list implementation, make use of the
    one in linux/list.h.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14340/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index b4c02f29663e..644ae9696edd 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -28,8 +28,7 @@
 /*
  * The PCI controller list.
  */
-
-static struct pci_controller *hose_head, **hose_tail = &hose_head;
+static LIST_HEAD(controllers);
 
 unsigned long PCIBIOS_MIN_IO;
 unsigned long PCIBIOS_MIN_MEM;
@@ -193,8 +192,8 @@ void register_pci_controller(struct pci_controller *hose)
 		goto out;
 	}
 
-	*hose_tail = hose;
-	hose_tail = &hose->next;
+	INIT_LIST_HEAD(&hose->list);
+	list_add(&hose->list, &controllers);
 
 	/*
 	 * Do not panic here but later - this might happen before console init.
@@ -248,7 +247,7 @@ static int __init pcibios_init(void)
 	pcibios_set_cache_line_size();
 
 	/* Scan all of the recorded PCI controllers.  */
-	for (hose = hose_head; hose; hose = hose->next)
+	list_for_each_entry(hose, &controllers, list)
 		pcibios_scanbus(hose);
 
 	pci_fixup_irqs(pci_common_swizzle, pcibios_map_irq);

commit 046136170a56ba47338fbd10fdf4db4214b30567
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Jun 23 16:32:20 2016 -0500

    MIPS/PCI: Claim bus resources on PCI_PROBE_ONLY set-ups
    
    We claim PCI BAR and bridge window resources in pci_bus_assign_resources(),
    but when PCI_PROBE_ONLY is set, we treat those resources as immutable and
    don't call pci_bus_assign_resources(), so the resources aren't put in the
    resource tree.
    
    When the resources aren't in the tree, they don't show up in /proc/iomem,
    we can't detect conflicts, and we need special cases elsewhere for
    PCI_PROBE_ONLY or resources without a parent pointer.
    
    Claim all PCI BAR and window resources in the PCI_PROBE_ONLY case.
    
    If a PCI_PROBE_ONLY platform assigns conflicting resources, Linux can't fix
    the conflicts.  Previously we didn't notice the conflicts, but now we will,
    which may expose new failures.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 5717384a986d..b4c02f29663e 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -112,7 +112,14 @@ static void pcibios_scanbus(struct pci_controller *hose)
 		need_domain_info = 1;
 	}
 
-	if (!pci_has_flag(PCI_PROBE_ONLY)) {
+	/*
+	 * We insert PCI resources into the iomem_resource and
+	 * ioport_resource trees in either pci_bus_claim_resources()
+	 * or pci_bus_assign_resources().
+	 */
+	if (pci_has_flag(PCI_PROBE_ONLY)) {
+		pci_bus_claim_resources(bus);
+	} else {
 		pci_bus_size_bridges(bus);
 		pci_bus_assign_resources(bus);
 	}

commit 8221a013528597edc18d371b22667e8eefca599b
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Jun 17 14:43:34 2016 -0500

    PCI: Unify pci_resource_to_user() declarations
    
    Replace the pci_resource_to_user() declarations in each arch that defines
    HAVE_ARCH_PCI_RESOURCE_TO_USER with a single one in linux/pci.h.
    
    Change the MIPS static inline implementation to a non-inline version so the
    static inline doesn't conflict with the new non-static linux/pci.h
    declaration.
    
    No functional change intended.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index f1b11f0dea2d..5717384a986d 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -319,6 +319,16 @@ void pcibios_fixup_bus(struct pci_bus *bus)
 EXPORT_SYMBOL(PCIBIOS_MIN_IO);
 EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
 
+void pci_resource_to_user(const struct pci_dev *dev, int bar,
+			  const struct resource *rsrc, resource_size_t *start,
+			  resource_size_t *end)
+{
+	phys_addr_t size = resource_size(rsrc);
+
+	*start = fixup_bigphys_addr(rsrc->start, size);
+	*end = rsrc->start + size;
+}
+
 int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
 			enum pci_mmap_state mmap_state, int write_combine)
 {

commit e8b5325ca3d01c512be6f04d587869a01e0ea59f
Author: Sergey Ryazanov <ryazanov.s.a@gmail.com>
Date:   Sat Aug 30 06:06:28 2014 +0400

    MIPS: make PCI_DMA_BUS_IS_PHYS=1 constant
    
    No one of supported MIPS machines has an IOMMU unit, so we can safely define
    PCI_DMA_BUS_IS_PHYS = 1. Also remove iommu flag from the pci controller
    structure, since it is useless.
    
    Signed-off-by: Sergey Ryazanov <ryazanov.s.a@gmail.com>
    Cc: Linux MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7604/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index b8a0bf5766f2..f1b11f0dea2d 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -83,9 +83,6 @@ static void pcibios_scanbus(struct pci_controller *hose)
 	LIST_HEAD(resources);
 	struct pci_bus *bus;
 
-	if (!hose->iommu)
-		PCI_DMA_BUS_IS_PHYS = 1;
-
 	if (hose->get_busno && pci_has_flag(PCI_PROBE_ONLY))
 		next_busno = (*hose->get_busno)();
 

commit 237865f195f6b10e4724ce49eeb3972641da882a
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Sep 15 13:18:04 2015 -0500

    PCI: Revert "PCI: Call pci_read_bridge_bases() from core instead of arch code"
    
    Revert dff22d2054b5 ("PCI: Call pci_read_bridge_bases() from core instead
    of arch code").
    
    Reading PCI bridge windows is not arch-specific in itself, but there is PCI
    core code that doesn't work correctly if we read them too early.  For
    example, Hannes found this case on an ARM Freescale i.mx6 board:
    
      pci_bus 0000:00: root bus resource [mem 0x01000000-0x01efffff]
      pci 0000:00:00.0: PCI bridge to [bus 01-ff]
      pci 0000:00:00.0: BAR 8: no space for [mem size 0x01000000] (mem window)
      pci 0000:01:00.0: BAR 2: failed to assign [mem size 0x00200000]
      pci 0000:01:00.0: BAR 1: failed to assign [mem size 0x00004000]
      pci 0000:01:00.0: BAR 0: failed to assign [mem size 0x00000100]
    
    The 00:00.0 mem window needs to be at least 3MB: the 01:00.0 device needs
    0x204100 of space, and mem windows are megabyte-aligned.
    
    Bus sizing can increase a bridge window size, but never *decrease* it (see
    d65245c3297a ("PCI: don't shrink bridge resources")).  Prior to
    dff22d2054b5, ARM didn't read bridge windows at all, so the "original size"
    was zero, and we assigned a 3MB window.
    
    After dff22d2054b5, we read the bridge windows before sizing the bus.  The
    firmware programmed a 16MB window (size 0x01000000) in 00:00.0, and since
    we never decrease the size, we kept 16MB even though we only needed 3MB.
    But 16MB doesn't fit in the host bridge aperture, so we failed to assign
    space for the window and the downstream devices.
    
    I think this is a defect in the PCI core: we shouldn't rely on the firmware
    to assign sensible windows.
    
    Ray reported a similar problem, also on ARM, with Broadcom iProc.
    
    Issues like this are too hard to fix right now, so revert dff22d2054b5.
    
    Reported-by: Hannes <oe5hpm@gmail.com>
    Reported-by: Ray Jui <rjui@broadcom.com>
    Link: http://lkml.kernel.org/r/CAAa04yFQEUJm7Jj1qMT57-LG7ZGtnhNDBe=PpSRa70Mj+XhW-A@mail.gmail.com
    Link: http://lkml.kernel.org/r/55F75BB8.4070405@broadcom.com
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Yinghai Lu <yinghai@kernel.org>
    Acked-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index c6996cf67a5c..b8a0bf5766f2 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -311,6 +311,12 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
 
 void pcibios_fixup_bus(struct pci_bus *bus)
 {
+	struct pci_dev *dev = bus->self;
+
+	if (pci_has_flag(PCI_PROBE_ONLY) && dev &&
+	    (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
+		pci_read_bridge_bases(bus);
+	}
 }
 
 EXPORT_SYMBOL(PCIBIOS_MIN_IO);

commit dff22d2054b5dbb1889f20c03959dd0c494fab8c
Author: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
Date:   Thu Jul 9 11:59:16 2015 +0100

    PCI: Call pci_read_bridge_bases() from core instead of arch code
    
    When we scan a PCI bus, we read PCI-PCI bridge window registers with
    pci_read_bridge_bases() so we can validate the resource hierarchy.  Most
    architectures call pci_read_bridge_bases() from pcibios_fixup_bus(), but
    PCI-PCI bridges are not arch-specific, so this doesn't need to be in
    arch-specific code.
    
    Call pci_read_bridge_bases() directly from the PCI core instead of from
    arch code.
    
    For alpha and mips, we now call pci_read_bridge_bases() always; previously
    we only called it if PCI_PROBE_ONLY was set.
    
    [bhelgaas: changelog]
    Signed-off-by: Lorenzo Pieralisi <lorenzo.pieralisi@arm.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: James E.J. Bottomley <jejb@parisc-linux.org>
    CC: Michael Ellerman <mpe@ellerman.id.au>
    CC: Bjorn Helgaas <bhelgaas@google.com>
    CC: Richard Henderson <rth@twiddle.net>
    CC: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    CC: David Howells <dhowells@redhat.com>
    CC: Russell King <linux@arm.linux.org.uk>
    CC: Tony Luck <tony.luck@intel.com>
    CC: David S. Miller <davem@davemloft.net>
    CC: Ingo Molnar <mingo@redhat.com>
    CC: Guenter Roeck <linux@roeck-us.net>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Chris Zankel <chris@zankel.net>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index b8a0bf5766f2..c6996cf67a5c 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -311,12 +311,6 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
 
 void pcibios_fixup_bus(struct pci_bus *bus)
 {
-	struct pci_dev *dev = bus->self;
-
-	if (pci_has_flag(PCI_PROBE_ONLY) && dev &&
-	    (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
-		pci_read_bridge_bases(bus);
-	}
 }
 
 EXPORT_SYMBOL(PCIBIOS_MIN_IO);

commit bfaf245022b4b8661af2e35f467cf0e91943c24c
Merge: 96d928ed75c4 3e20a26b02bd
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 17 15:50:54 2015 -0400

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
     "This is the main pull request for MIPS for Linux 4.1.  Most
      noteworthy:
    
       - Add more Octeon-optimized crypto functions
       - Octeon crypto preemption and locking fixes
       - Little endian support for Octeon
       - Use correct CSR to soft reset Octeons
       - Support LEDs on the Octeon-based DSR-1000N
       - Fix PCI interrupt mapping for the Octeon-based DSR-1000N
       - Mark prom_free_prom_memory() as __init for a number of systems
       - Support for Imagination's Pistachio SOC.  This includes arch and
         CLK bits.  I'd like to merge pinctrl bits later
       - Improve parallelism of csum_partial for certain pipelines
       - Organize DTB files in subdirs like other architectures
       - Implement read_sched_clock for all MIPS platforms other than
         Octeon
       - Massive series of 38 fixes and cleanups for the FPU emulator /
         kernel
       - Further FPU remulator work to support new features.  This sits on a
         separate branch which also has been pulled into the 4.1 KVM branch
       - Clean up and fixes for the SEAD3 eval board; remove unused file
       - Various updates for Netlogic platforms
       - A number of small updates for Loongson 3 platforms
       - Increase the memory limit for ATH79 platforms to 256MB
       - A fair number of fixes and updates for BCM47xx platforms
       - Finish the implementation of XPA support
       - MIPS FDC support.  No, not floppy controller but Fast Debug Channel :)
       - Detect the R16000 used in SGI legacy platforms
       - Fix Kconfig dependencies for the SSB bus support"
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (265 commits)
      MIPS: Makefile: Fix MIPS ASE detection code
      MIPS: asm: elf: Set O32 default FPU flags
      MIPS: BCM47XX: Fix detecting Microsoft MN-700 & Asus WL500G
      MIPS: Kconfig: Disable SMP/CPS for 64-bit
      MIPS: Hibernate: flush TLB entries earlier
      MIPS: smp-cps: cpu_set FPU mask if FPU present
      MIPS: lose_fpu(): Disable FPU when MSA enabled
      MIPS: ralink: add missing symbol for RALINK_ILL_ACC
      MIPS: ralink: Fix bad config symbol in PCI makefile.
      SSB: fix Kconfig dependencies
      MIPS: Malta: Detect and fix bad memsize values
      Revert "MIPS: Avoid pipeline stalls on some MIPS32R2 cores."
      MIPS: Octeon: Delete override of cpu_has_mips_r2_exec_hazard.
      MIPS: Fix cpu_has_mips_r2_exec_hazard.
      MIPS: kernel: entry.S: Set correct ISA level for mips_ihb
      MIPS: asm: spinlock: Fix addiu instruction for R10000_LLSC_WAR case
      MIPS: r4kcache: Use correct base register for MIPS R6 cache flushes
      MIPS: Kconfig: Fix typo for the r2-to-r6 emulator kernel parameter
      MIPS: unaligned: Fix regular load/store instruction emulation for EVA
      MIPS: unaligned: Surround load/store macros in do {} while statements
      ...

commit a2e50f53d535fa885a432fb9fc3e3ca5ed97364c
Author: Joshua Kinard <kumba@gentoo.org>
Date:   Mon Jan 19 04:19:20 2015 -0500

    MIPS: PCI: Add a hook for IORESOURCE_BUS in pci_controller/bridge_controller
    
    On SGI Origin 2k/Onyx2 and SGI Octane systems, there can exist multiple PCI
    buses attached to the Xtalk bus.  The current code will stop counting PCI buses
    after it finds the first one.  If one installs the optional PCI cardcage
    ("shoebox") into these systems, because of the order of the Xtalk widgets, the
    current PCI code will find the cardcage first, and fail to detect the BaseIO
    PCI devices, which are on a higher Xtalk widget ID.
    
    This patch adds the hooks needed for resolving this issue in the IP27 PCI code
    (in a later patch).
    
    Verified on both an SGI Onyx2 and an SGI Octane.
    
    Signed-off-by: Joshua Kinard <kumba@gentoo.org>
    Cc: Linux MIPS List <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/9074/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 1bf60b127377..0e3f437e8cad 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -91,7 +91,10 @@ static void pcibios_scanbus(struct pci_controller *hose)
 
 	pci_add_resource_offset(&resources,
 				hose->mem_resource, hose->mem_offset);
-	pci_add_resource_offset(&resources, hose->io_resource, hose->io_offset);
+	pci_add_resource_offset(&resources,
+				hose->io_resource, hose->io_offset);
+	pci_add_resource_offset(&resources,
+				hose->busn_resource, hose->busn_offset);
 	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
 				&resources);
 	if (!bus)

commit 9e808eb6a7689b61399f772a2576d779161769ec
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Mar 12 15:07:04 2015 -0500

    PCI: Cleanup control flow
    
    Return errors immediately so the straightline path is the normal,
    no-error path.  No functional change.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 9eb54b557c9f..8bb13a4af68a 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -94,28 +94,29 @@ static void pcibios_scanbus(struct pci_controller *hose)
 	pci_add_resource_offset(&resources, hose->io_resource, hose->io_offset);
 	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
 				&resources);
-	if (!bus)
-		pci_free_resource_list(&resources);
-
 	hose->bus = bus;
 
 	need_domain_info = need_domain_info || hose->index;
 	hose->need_domain_info = need_domain_info;
-	if (bus) {
-		next_busno = bus->busn_res.end + 1;
-		/* Don't allow 8-bit bus number overflow inside the hose -
-		   reserve some space for bridges. */
-		if (next_busno > 224) {
-			next_busno = 0;
-			need_domain_info = 1;
-		}
 
-		if (!pci_has_flag(PCI_PROBE_ONLY)) {
-			pci_bus_size_bridges(bus);
-			pci_bus_assign_resources(bus);
-		}
-		pci_bus_add_devices(bus);
+	if (!bus) {
+		pci_free_resource_list(&resources);
+		return;
+	}
+
+	next_busno = bus->busn_res.end + 1;
+	/* Don't allow 8-bit bus number overflow inside the hose -
+	   reserve some space for bridges. */
+	if (next_busno > 224) {
+		next_busno = 0;
+		need_domain_info = 1;
+	}
+
+	if (!pci_has_flag(PCI_PROBE_ONLY)) {
+		pci_bus_size_bridges(bus);
+		pci_bus_assign_resources(bus);
 	}
+	pci_bus_add_devices(bus);
 }
 
 #ifdef CONFIG_OF

commit b97ea289cf6aff8d4cbcefe2b707bb9b00a73c73
Author: Yijing Wang <wangyijing@huawei.com>
Date:   Mon Mar 16 11:18:56 2015 +0800

    PCI: Assign resources before drivers claim devices (pci_scan_root_bus())
    
    Previously, pci_scan_root_bus() created a root PCI bus, enumerated the
    devices on it, and called pci_bus_add_devices(), which made the devices
    available for drivers to claim them.
    
    Most callers assigned resources to devices after pci_scan_root_bus()
    returns, which may be after drivers have claimed the devices.  This is
    incorrect; the PCI core should not change device resources while a driver
    is managing the device.
    
    Remove pci_bus_add_devices() from pci_scan_root_bus() and do it after any
    resource assignment in the callers.
    
    Note that ARM's pci_common_init_dev() already called pci_bus_add_devices()
    after pci_scan_root_bus(), so we only need to remove the first call:
    
      pci_common_init_dev
        pcibios_init_hw
          pci_scan_root_bus
            pci_bus_add_devices        # first call
        pci_bus_assign_resources
        pci_bus_add_devices            # second call
    
    [bhelgaas: changelog, drop "root_bus" var in alpha common_init_pci(),
    return failure earlier in mn10300, add "return" in x86 pcibios_scan_root(),
    return early if xtensa platform_pcibios_fixup() fails]
    Signed-off-by: Yijing Wang <wangyijing@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    CC: Richard Henderson <rth@twiddle.net>
    CC: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    CC: Matt Turner <mattst88@gmail.com>
    CC: David Howells <dhowells@redhat.com>
    CC: Tony Luck <tony.luck@intel.com>
    CC: Michal Simek <monstr@monstr.eu>
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    CC: Sebastian Ott <sebott@linux.vnet.ibm.com>
    CC: "David S. Miller" <davem@davemloft.net>
    CC: Chris Metcalf <cmetcalf@ezchip.com>
    CC: Chris Zankel <chris@zankel.net>
    CC: Max Filippov <jcmvbkbc@gmail.com>
    CC: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 1bf60b127377..9eb54b557c9f 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -114,6 +114,7 @@ static void pcibios_scanbus(struct pci_controller *hose)
 			pci_bus_size_bridges(bus);
 			pci_bus_assign_resources(bus);
 		}
+		pci_bus_add_devices(bus);
 	}
 }
 

commit cffe00c037cdaa14d420bb1dbc69b4dfb5f1bc23
Author: Andrew Murray <amurray@embedded-bits.co.uk>
Date:   Thu Jul 25 17:14:25 2013 +0100

    MIPS: of/pci: Use of_pci_range_parser
    
    This patch converts the pci_load_of_ranges function to use the new common
    of_pci_range_parser.
    
    Signed-off-by: Andrew Murray <amurray@embedded-bits.co.uk>
    Signed-off-by: Andrew Murray <Andrew.Murray@arm.com>
    Signed-off-by: Liviu Dudau <Liviu.Dudau@arm.com>
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Reviewed-by: Rob Herring <rob.herring@calxeda.com>
    Reviewed-by: Grant Likely <grant.likely@secretlab.ca>
    Tested-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: jason@lakedaemon.net
    Patchwork: https://patchwork.linux-mips.org/patch/5625/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 33e7aa52d9c4..1bf60b127377 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -120,51 +120,37 @@ static void pcibios_scanbus(struct pci_controller *hose)
 #ifdef CONFIG_OF
 void pci_load_of_ranges(struct pci_controller *hose, struct device_node *node)
 {
-	const __be32 *ranges;
-	int rlen;
-	int pna = of_n_addr_cells(node);
-	int np = pna + 5;
+	struct of_pci_range range;
+	struct of_pci_range_parser parser;
 
 	pr_info("PCI host bridge %s ranges:\n", node->full_name);
-	ranges = of_get_property(node, "ranges", &rlen);
-	if (ranges == NULL)
-		return;
 	hose->of_node = node;
 
-	while ((rlen -= np * 4) >= 0) {
-		u32 pci_space;
+	if (of_pci_range_parser_init(&parser, node))
+		return;
+
+	for_each_of_pci_range(&parser, &range) {
 		struct resource *res = NULL;
-		u64 addr, size;
-
-		pci_space = be32_to_cpup(&ranges[0]);
-		addr = of_translate_address(node, ranges + 3);
-		size = of_read_number(ranges + pna + 3, 2);
-		ranges += np;
-		switch ((pci_space >> 24) & 0x3) {
-		case 1:		/* PCI IO space */
+
+		switch (range.flags & IORESOURCE_TYPE_BITS) {
+		case IORESOURCE_IO:
 			pr_info("  IO 0x%016llx..0x%016llx\n",
-					addr, addr + size - 1);
+				range.cpu_addr,
+				range.cpu_addr + range.size - 1);
 			hose->io_map_base =
-				(unsigned long)ioremap(addr, size);
+				(unsigned long)ioremap(range.cpu_addr,
+						       range.size);
 			res = hose->io_resource;
-			res->flags = IORESOURCE_IO;
 			break;
-		case 2:		/* PCI Memory space */
-		case 3:		/* PCI 64 bits Memory space */
+		case IORESOURCE_MEM:
 			pr_info(" MEM 0x%016llx..0x%016llx\n",
-					addr, addr + size - 1);
+				range.cpu_addr,
+				range.cpu_addr + range.size - 1);
 			res = hose->mem_resource;
-			res->flags = IORESOURCE_MEM;
 			break;
 		}
-		if (res != NULL) {
-			res->start = addr;
-			res->name = node->full_name;
-			res->end = res->start + size - 1;
-			res->parent = NULL;
-			res->sibling = NULL;
-			res->child = NULL;
-		}
+		if (res != NULL)
+			of_pci_range_to_resource(&range, node, res);
 	}
 }
 

commit 928bea964827d7824b548c1f8e06eccbbc4d0d7d
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Mon Jul 22 14:37:17 2013 -0700

    PCI: Delay enabling bridges until they're needed
    
    We currently enable PCI bridges after scanning a bus and assigning
    resources.  This is often done in arch code.
    
    This patch changes this so we don't enable a bridge until necessary, i.e.,
    until we enable a PCI device behind the bridge.  We do this in the generic
    pci_enable_device() path, so this also removes the arch-specific code to
    enable bridges.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 594e60d6a43b..33e7aa52d9c4 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -113,7 +113,6 @@ static void pcibios_scanbus(struct pci_controller *hose)
 		if (!pci_has_flag(PCI_PROBE_ONLY)) {
 			pci_bus_size_bridges(bus);
 			pci_bus_assign_resources(bus);
-			pci_enable_bridges(bus);
 		}
 	}
 }

commit 9a97cd43f4ef62520a852b5a2348233b0f37455b
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Thu Apr 4 20:01:23 2013 +0200

    MIPS/PCI: Implement pcibios_get_phb_of_node
    
    The of_node field of the device assigned to a
    PCI bus is used during scanning of the PCI bus.
    However on MIPS, the of_node field is assigned
    only after the bus has been scanned.
    
    Implement the architecture specific version of
    'pcibios_get_phb_of_node'. Which ensures that the
    PCI driver core will initialize the of_node field
    before starting the scan.
    
    Also remove the local assignment of bus->dev.of_node,
    it is not needed after the patch.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 0872f12f268d..594e60d6a43b 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -115,7 +115,6 @@ static void pcibios_scanbus(struct pci_controller *hose)
 			pci_bus_assign_resources(bus);
 			pci_enable_bridges(bus);
 		}
-		bus->dev.of_node = hose->of_node;
 	}
 }
 
@@ -169,6 +168,13 @@ void pci_load_of_ranges(struct pci_controller *hose, struct device_node *node)
 		}
 	}
 }
+
+struct device_node *pcibios_get_phb_of_node(struct pci_bus *bus)
+{
+	struct pci_controller *hose = bus->sysdata;
+
+	return of_node_get(hose->of_node);
+}
 #endif
 
 static DEFINE_MUTEX(pci_scan_mutex);

commit 8bfc245f9ad7bd4e461179e4e7852ef99b8b6144
Merge: 612663a97406 535237cecab2
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Feb 21 12:51:33 2013 +0100

    Merge branch 'mips-next-3.9' of git://git.linux-mips.org/pub/scm/john/linux-john into mips-for-linux-next

commit 222831787704c9ad9215f6b56f975b233968607c
Author: Gabor Juhos <juhosg@openwrt.org>
Date:   Sat Feb 2 13:18:54 2013 +0000

    MIPS: avoid possible resource conflict in register_pci_controller
    
    The IO and memory resources of a PCI controller
    might already have a parent resource set when
    they are passed to 'register_pci_controller'.
    
    If the parent resource is set, the request_resource
    call will fail due to resource conflict and the
    current code will not be able to register the
    PCI controller.
    
    Use the parent resource if it is available in the
    request_resource call to avoid the isssue.
    
    Signed-off-by: Gabor Juhos <juhosg@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4910/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index a1843448fad3..eb653994a2f1 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -175,9 +175,20 @@ static DEFINE_MUTEX(pci_scan_mutex);
 
 void register_pci_controller(struct pci_controller *hose)
 {
-	if (request_resource(&iomem_resource, hose->mem_resource) < 0)
+	struct resource *parent;
+
+	parent = hose->mem_resource->parent;
+	if (!parent)
+		parent = &iomem_resource;
+
+	if (request_resource(parent, hose->mem_resource) < 0)
 		goto out;
-	if (request_resource(&ioport_resource, hose->io_resource) < 0) {
+
+	parent = hose->io_resource->parent;
+	if (!parent)
+		parent = &ioport_resource;
+
+	if (request_resource(parent, hose->io_resource) < 0) {
 		release_resource(hose->mem_resource);
 		goto out;
 	}

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index a1843448fad3..e8a14a6514cf 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -1,6 +1,6 @@
 /*
- * This program is free software; you can redistribute  it and/or modify it
- * under  the terms of  the GNU General  Public License as published by the
+ * This program is free software; you can redistribute	it and/or modify it
+ * under  the terms of	the GNU General	 Public License as published by the
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  *

commit 28eb0e46612a08a235c8b103eb2bd6a1aea83210
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 14:04:39 2012 -0800

    MIPS: drivers: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 4040416e0603..a1843448fad3 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -76,7 +76,7 @@ pcibios_align_resource(void *data, const struct resource *res,
 	return start;
 }
 
-static void __devinit pcibios_scanbus(struct pci_controller *hose)
+static void pcibios_scanbus(struct pci_controller *hose)
 {
 	static int next_busno;
 	static int need_domain_info;
@@ -120,8 +120,7 @@ static void __devinit pcibios_scanbus(struct pci_controller *hose)
 }
 
 #ifdef CONFIG_OF
-void __devinit pci_load_of_ranges(struct pci_controller *hose,
-				struct device_node *node)
+void pci_load_of_ranges(struct pci_controller *hose, struct device_node *node)
 {
 	const __be32 *ranges;
 	int rlen;
@@ -174,7 +173,7 @@ void __devinit pci_load_of_ranges(struct pci_controller *hose,
 
 static DEFINE_MUTEX(pci_scan_mutex);
 
-void __devinit register_pci_controller(struct pci_controller *hose)
+void register_pci_controller(struct pci_controller *hose)
 {
 	if (request_resource(&iomem_resource, hose->mem_resource) < 0)
 		goto out;
@@ -303,7 +302,7 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
 	return pcibios_plat_dev_init(dev);
 }
 
-void __devinit pcibios_fixup_bus(struct pci_bus *bus)
+void pcibios_fixup_bus(struct pci_bus *bus)
 {
 	struct pci_dev *dev = bus->self;
 

commit 0a6f19db99c4833ad01eccbee51812b8000d63ea
Author: Bill Pemberton <wfp5p@virginia.edu>
Date:   Wed Nov 21 15:34:53 2012 -0500

    mips/PCI: Remove CONFIG_HOTPLUG ifdefs
    
    Remove conditional code based on CONFIG_HOTPLUG being false.  It's
    always on now in preparation of it going away as an option.
    
    Signed-off-by: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Rob Herring <rob.herring@calxeda.com>
    Acked-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 04e35bcde07c..4040416e0603 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -313,10 +313,8 @@ void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 	}
 }
 
-#ifdef CONFIG_HOTPLUG
 EXPORT_SYMBOL(PCIBIOS_MIN_IO);
 EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
-#endif
 
 int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
 			enum pci_mmap_state mmap_state, int write_combine)

commit 8885b7b637fa9aca7e1b00581a0173c6956966d3
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Sep 17 13:22:54 2012 +0200

    PCI: Provide a default pcibios_update_irq()
    
    Most architectures implement this in exactly the same way. Instead of
    having each architecture duplicate this function, provide a single
    implementation in the core and make it a weak symbol so that it can be
    overridden on architectures where it is required.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 64f0419e5856..04e35bcde07c 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -313,12 +313,6 @@ void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 	}
 }
 
-void
-pcibios_update_irq(struct pci_dev *dev, int irq)
-{
-	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
-}
-
 #ifdef CONFIG_HOTPLUG
 EXPORT_SYMBOL(PCIBIOS_MIN_IO);
 EXPORT_SYMBOL(PCIBIOS_MIN_MEM);

commit 3ddbebf878ac8d958bb34e87a742a6b3adc283a3
Author: Thierry Reding <thierry.reding@avionic-design.de>
Date:   Mon Sep 17 13:22:53 2012 +0200

    PCI: Discard __init annotations for pci_fixup_irqs() and related functions
    
    Remove the __init annotations in order to keep pci_fixup_irqs() around
    after init (e.g. for hotplug). This requires the same change for the
    implementation of pcibios_update_irq() on all architectures. While at
    it, all __devinit annotations are removed as well, since they will be
    useless now that HOTPLUG is always on.
    
    Signed-off-by: Thierry Reding <thierry.reding@avionic-design.de>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 690356808f8a..64f0419e5856 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -313,7 +313,7 @@ void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 	}
 }
 
-void __init
+void
 pcibios_update_irq(struct pci_dev *dev, int irq)
 {
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);

commit 85a00dd391d2de1e177c5ad8db5672428934ac20
Merge: 35e7f73c32ad 29e8d7bff2f5
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Jul 5 15:31:05 2012 -0600

    Merge branch 'pci/myron-pcibios_setup' into next
    
    * pci/myron-pcibios_setup:
      xtensa/PCI: factor out pcibios_setup()
      x86/PCI: adjust section annotations for pcibios_setup()
      unicore32/PCI: adjust section annotations for pcibios_setup()
      tile/PCI: factor out pcibios_setup()
      sparc/PCI: factor out pcibios_setup()
      sh/PCI: adjust section annotations for pcibios_setup()
      sh/PCI: factor out pcibios_setup()
      powerpc/PCI: factor out pcibios_setup()
      parisc/PCI: factor out pcibios_setup()
      MIPS/PCI: adjust section annotations for pcibios_setup()
      MIPS/PCI: factor out pcibios_setup()
      microblaze/PCI: factor out pcibios_setup()
      ia64/PCI: factor out pcibios_setup()
      cris/PCI: factor out pcibios_setup()
      alpha/PCI: factor out pcibios_setup()
      PCI: pull pcibios_setup() up into core

commit 938ca5162ec9a835078924447a6f55667e47e857
Author: Myron Stowe <myron.stowe@redhat.com>
Date:   Mon Jun 25 21:31:37 2012 -0600

    MIPS/PCI: adjust section annotations for pcibios_setup()
    
    Make pcibios_setup() consistently use the "__init" section annotation.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 271e8c4a54c7..0e111d2741ac 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -348,9 +348,9 @@ int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
 		vma->vm_end - vma->vm_start, vma->vm_page_prot);
 }
 
-char * (*pcibios_plat_setup)(char *str) __devinitdata;
+char * (*pcibios_plat_setup)(char *str) __initdata;
 
-char *__devinit pcibios_setup(char *str)
+char *__init pcibios_setup(char *str)
 {
 	if (pcibios_plat_setup)
 		return pcibios_plat_setup(str);

commit b918c62e086b2130a7bae44110ca516ef10bfe5a
Author: Yinghai Lu <yinghai@kernel.org>
Date:   Thu May 17 18:51:11 2012 -0700

    PCI: replace struct pci_bus secondary/subordinate with busn_res
    
    Replace the struct pci_bus secondary/subordinate members with the
    struct resource busn_res.  Later we'll build a resource tree of these
    bus numbers.
    
    [bhelgaas: changelog]
    Signed-off-by: Yinghai Lu <yinghai@kernel.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 271e8c4a54c7..0a9bf778edb5 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -102,7 +102,7 @@ static void __devinit pcibios_scanbus(struct pci_controller *hose)
 	need_domain_info = need_domain_info || hose->index;
 	hose->need_domain_info = need_domain_info;
 	if (bus) {
-		next_busno = bus->subordinate + 1;
+		next_busno = bus->busn_res.end + 1;
 		/* Don't allow 8-bit bus number overflow inside the hose -
 		   reserve some space for bridges. */
 		if (next_busno > 224) {

commit a48cf37ac8a77ddd2370be3c9af411c622ebc425
Author: John Crispin <blogic@openwrt.org>
Date:   Fri May 4 10:50:13 2012 +0200

    MIPS: pci: parse memory ranges from devicetree
    
    Implement pci_load_of_ranges on MIPS. Due to lack of test hardware only 32bit
    bus width is supported. This function is based on pci_process_bridge_OF_ranges
    from powerpc.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3729/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 0514866fa925..271e8c4a54c7 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/pci.h>
+#include <linux/of_address.h>
 
 #include <asm/cpu-info.h>
 
@@ -114,9 +115,63 @@ static void __devinit pcibios_scanbus(struct pci_controller *hose)
 			pci_bus_assign_resources(bus);
 			pci_enable_bridges(bus);
 		}
+		bus->dev.of_node = hose->of_node;
 	}
 }
 
+#ifdef CONFIG_OF
+void __devinit pci_load_of_ranges(struct pci_controller *hose,
+				struct device_node *node)
+{
+	const __be32 *ranges;
+	int rlen;
+	int pna = of_n_addr_cells(node);
+	int np = pna + 5;
+
+	pr_info("PCI host bridge %s ranges:\n", node->full_name);
+	ranges = of_get_property(node, "ranges", &rlen);
+	if (ranges == NULL)
+		return;
+	hose->of_node = node;
+
+	while ((rlen -= np * 4) >= 0) {
+		u32 pci_space;
+		struct resource *res = NULL;
+		u64 addr, size;
+
+		pci_space = be32_to_cpup(&ranges[0]);
+		addr = of_translate_address(node, ranges + 3);
+		size = of_read_number(ranges + pna + 3, 2);
+		ranges += np;
+		switch ((pci_space >> 24) & 0x3) {
+		case 1:		/* PCI IO space */
+			pr_info("  IO 0x%016llx..0x%016llx\n",
+					addr, addr + size - 1);
+			hose->io_map_base =
+				(unsigned long)ioremap(addr, size);
+			res = hose->io_resource;
+			res->flags = IORESOURCE_IO;
+			break;
+		case 2:		/* PCI Memory space */
+		case 3:		/* PCI 64 bits Memory space */
+			pr_info(" MEM 0x%016llx..0x%016llx\n",
+					addr, addr + size - 1);
+			res = hose->mem_resource;
+			res->flags = IORESOURCE_MEM;
+			break;
+		}
+		if (res != NULL) {
+			res->start = addr;
+			res->name = node->full_name;
+			res->end = res->start + size - 1;
+			res->parent = NULL;
+			res->sibling = NULL;
+			res->child = NULL;
+		}
+	}
+}
+#endif
+
 static DEFINE_MUTEX(pci_scan_mutex);
 
 void __devinit register_pci_controller(struct pci_controller *hose)

commit 96a6b9ad05a2d5654f168d3ad9d9696d3b03a7c2
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:19:02 2012 -0700

    mips/PCI: get rid of device resource fixups
    
    Tell the PCI core about host bridge address translation so it can take
    care of bus-to-resource conversion for us.
    
    Here's the wrinkle on Cobalt: we can't generate normal I/O port addresses
    on PCI because the GT-64111 doesn't do any address translation, so we have
    this:
    
      CPU I/O port addresses                [io 0x0000-0xffffff]
      PCI bus I/O port addresses    [io 0x10000000-0x10ffffff]
    
    Legacy-mode IDE controllers start out with the legacy bus addresses, e.g.,
    0x1f0, assigned by pci_setup_device().  These are outside the range of
    addresses GT-64111 can generate on PCI, but pcibios_fixup_device_resources()
    converted them to CPU addresses anyway by adding io_offset.  Therefore, we
    had to pre-adjust them in cobalt_legacy_ide_fixup().
    
    With io_offset = 0xf0000000, we had this:
    
      res->start = 0x1f0    initialized in pci_setup_device()
      res->start = 0x100001f0       -= io_offset in cobalt_legacy_ide_fixup()
      res->start = 0x1f0    += io_offset in pcibios_fixup_device_resources()
    
    The difference after this patch is that the generic pci_bus_to_resource()
    only adds the offset if the bus address is inside a host bridge window.
    Since 0x1f0 is not a valid bus address and is not inside any windows, it is
    unaffected, so we now have this:
    
      region->start = 0x1f0 initialized in pci_setup_device()
      res->start = 0x1f0    no offset by pci_bus_to_resource()
    
    That means we can remove both pcibios_fixup_device_resources() and
    cobalt_legacy_ide_fixup().
    
    I would *rather* set the host bridge offset to zero (which corresponds
    to what the GT-64111 actually does), and have both CPU and PCI addresses
    of [io 0x10000000-0x10ffffff].  However, that would require changes to
    generic code that assumes legacy I/O addresses, such as pic1_io_resource
    ([io 0x0020-0x00021]), and we'd have to keep a Cobalt IDE fixup.
    
    Of course, none of this changes the fact that references to I/O port
    0x1f0 actually go to port 0x100001f0, not 0x1f0, on the Cobalt PCI bus.
    Fortunately the VT82C586 IDE controller only decodes the low 24 address
    bits, so it does work.
    
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: Yoichi Yuasa <yuasa@linux-mips.org>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 19f6d194a568..0514866fa925 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -88,8 +88,9 @@ static void __devinit pcibios_scanbus(struct pci_controller *hose)
 	if (hose->get_busno && pci_has_flag(PCI_PROBE_ONLY))
 		next_busno = (*hose->get_busno)();
 
-	pci_add_resource(&resources, hose->mem_resource);
-	pci_add_resource(&resources, hose->io_resource);
+	pci_add_resource_offset(&resources,
+				hose->mem_resource, hose->mem_offset);
+	pci_add_resource_offset(&resources, hose->io_resource, hose->io_offset);
 	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
 				&resources);
 	if (!bus)
@@ -247,45 +248,13 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
 	return pcibios_plat_dev_init(dev);
 }
 
-static void pcibios_fixup_device_resources(struct pci_dev *dev,
-	struct pci_bus *bus)
-{
-	/* Update device resources.  */
-	struct pci_controller *hose = (struct pci_controller *)bus->sysdata;
-	unsigned long offset = 0;
-	int i;
-
-	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
-		if (!dev->resource[i].start)
-			continue;
-		if (dev->resource[i].flags & IORESOURCE_IO)
-			offset = hose->io_offset;
-		else if (dev->resource[i].flags & IORESOURCE_MEM)
-			offset = hose->mem_offset;
-
-		dev->resource[i].start += offset;
-		dev->resource[i].end += offset;
-	}
-}
-
 void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 {
-	/* Propagate hose info into the subordinate devices.  */
-
-	struct list_head *ln;
 	struct pci_dev *dev = bus->self;
 
 	if (pci_has_flag(PCI_PROBE_ONLY) && dev &&
 	    (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
 		pci_read_bridge_bases(bus);
-		pcibios_fixup_device_resources(dev, bus);
-	}
-
-	for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
-		dev = pci_dev_b(ln);
-
-		if ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)
-			pcibios_fixup_device_resources(dev, bus);
 	}
 }
 
@@ -295,40 +264,7 @@ pcibios_update_irq(struct pci_dev *dev, int irq)
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
 }
 
-void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
-			 struct resource *res)
-{
-	struct pci_controller *hose = (struct pci_controller *)dev->sysdata;
-	unsigned long offset = 0;
-
-	if (res->flags & IORESOURCE_IO)
-		offset = hose->io_offset;
-	else if (res->flags & IORESOURCE_MEM)
-		offset = hose->mem_offset;
-
-	region->start = res->start - offset;
-	region->end = res->end - offset;
-}
-
-void __devinit
-pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
-			struct pci_bus_region *region)
-{
-	struct pci_controller *hose = (struct pci_controller *)dev->sysdata;
-	unsigned long offset = 0;
-
-	if (res->flags & IORESOURCE_IO)
-		offset = hose->io_offset;
-	else if (res->flags & IORESOURCE_MEM)
-		offset = hose->mem_offset;
-
-	res->start = region->start + offset;
-	res->end = region->end + offset;
-}
-
 #ifdef CONFIG_HOTPLUG
-EXPORT_SYMBOL(pcibios_resource_to_bus);
-EXPORT_SYMBOL(pcibios_bus_to_resource);
 EXPORT_SYMBOL(PCIBIOS_MIN_IO);
 EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
 #endif

commit 14be538c566f6fd6f8c8abd1687aa5d36a600703
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:18:57 2012 -0700

    mips/PCI: removed unused pci_probe configurability
    
    We never assign anything other than PCI_ASSIGN_ALL_BUSSES to pci_probe,
    so just remove the indirection.  If configurability is required in the
    future, please use the pci_flags/PCI_REASSIGN_ALL_BUS functionality
    as is done for powerpc.
    
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: linux-mips@linux-mips.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 2a1104512036..19f6d194a568 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -24,10 +24,6 @@
  * assignments.
  */
 
-#define PCI_ASSIGN_ALL_BUSSES	1
-
-unsigned int pci_probe = PCI_ASSIGN_ALL_BUSSES;
-
 /*
  * The PCI controller list.
  */
@@ -238,7 +234,7 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 
 unsigned int pcibios_assign_all_busses(void)
 {
-	return (pci_probe & PCI_ASSIGN_ALL_BUSSES) ? 1 : 0;
+	return 1;
 }
 
 int pcibios_enable_device(struct pci_dev *dev, int mask)

commit 2909060699226f70d731d9c242489418f7da4972
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Thu Feb 23 20:18:57 2012 -0700

    mips/PCI: replace pci_probe_only with pci_flags
    
    Some architectures (alpha, mips, powerpc) have an arch-specific
    "pci_probe_only" flag.  Others use PCI_PROBE_ONLY in pci_flags for
    the same purpose.  This moves mips to the pci_flags approach so
    generic code can use the same test across all architectures.
    
    CC: Ralf Baechle <ralf@linux-mips.org>
    CC: linux-mips@linux-mips.org
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index aec2b111d35b..2a1104512036 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -20,12 +20,9 @@
 #include <asm/cpu-info.h>
 
 /*
- * Indicate whether we respect the PCI setup left by the firmware.
- *
- * Make this long-lived  so that we know when shutting down
- * whether we probed only or not.
+ * If PCI_PROBE_ONLY in pci_flags is set, we don't change any PCI resource
+ * assignments.
  */
-int pci_probe_only;
 
 #define PCI_ASSIGN_ALL_BUSSES	1
 
@@ -92,7 +89,7 @@ static void __devinit pcibios_scanbus(struct pci_controller *hose)
 	if (!hose->iommu)
 		PCI_DMA_BUS_IS_PHYS = 1;
 
-	if (hose->get_busno && pci_probe_only)
+	if (hose->get_busno && pci_has_flag(PCI_PROBE_ONLY))
 		next_busno = (*hose->get_busno)();
 
 	pci_add_resource(&resources, hose->mem_resource);
@@ -115,7 +112,7 @@ static void __devinit pcibios_scanbus(struct pci_controller *hose)
 			need_domain_info = 1;
 		}
 
-		if (!pci_probe_only) {
+		if (!pci_has_flag(PCI_PROBE_ONLY)) {
 			pci_bus_size_bridges(bus);
 			pci_bus_assign_resources(bus);
 			pci_enable_bridges(bus);
@@ -282,7 +279,7 @@ void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 	struct list_head *ln;
 	struct pci_dev *dev = bus->self;
 
-	if (pci_probe_only && dev &&
+	if (pci_has_flag(PCI_PROBE_ONLY) && dev &&
 	    (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
 		pci_read_bridge_bases(bus);
 		pcibios_fixup_device_resources(dev, bus);

commit 4964e0664c80680fa6b28ef91381c076a5b25c2c
Merge: 0a80939b3e6a 7bf6612e8a9d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 14 13:05:21 2012 -0800

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (119 commits)
      MIPS: Delete unused function add_temporary_entry.
      MIPS: Set default pci cache line size.
      MIPS: Flush huge TLB
      MIPS: Octeon: Remove SYS_SUPPORTS_HIGHMEM.
      MIPS: Octeon: Add support for OCTEON II PCIe
      MIPS: Octeon: Update PCI Latency timer and enable more error reporting.
      MIPS: Alchemy: Update cpu-feature-overrides
      MIPS: Alchemy: db1200: Improve PB1200 detection.
      MIPS: Alchemy: merge Au1000 and Au1300-style IRQ controller code.
      MIPS: Alchemy: chain IRQ controllers to MIPS IRQ controller
      MIPS: Alchemy: irq: register pm at irq init time
      MIPS: Alchemy: Touchscreen support on DB1100
      MIPS: Alchemy: Hook up IrDA on DB1000/DB1100
      net/irda: convert au1k_ir to platform driver.
      MIPS: Alchemy: remove unused board headers
      MTD: nand: make au1550nd.c a platform_driver
      MIPS: Netlogic: Mark Netlogic chips as SMT capable
      MIPS: Netlogic: Add support for XLP 3XX cores
      MIPS: Netlogic: Merge some of XLR/XLP wakup code
      MIPS: Netlogic: Add default XLP config.
      ...
    
    Fix up trivial conflicts in arch/mips/kernel/{perf_event_mipsxx.c,
    traps.c} and drivers/tty/serial/Makefile

commit c539ef7d355219c7b0e16cc302bf179fcad936b3
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Jan 11 15:37:16 2012 +0100

    MIPS: Set default pci cache line size.
    
    On MIPS the generic PCI code has always defaulted to L1_CACHE_BYTES
    because the architecutre PCI code did not provide a better default.
    In particular on systems with S-caches or T-caches this was suboptimal.
    
    Provide a better default by setting pci_dfl_cache_line_size based on
    the size of the line size of the lowest level of the cache hierarchy.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/2982/

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 41af7fa2887b..8ac0d4841852 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -4,8 +4,11 @@
  * Free Software Foundation;  either version 2 of the  License, or (at your
  * option) any later version.
  *
- * Copyright (C) 2003, 04 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2003, 04, 11 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2011 Wind River Systems,
+ *   written by Ralf Baechle (ralf@linux-mips.org)
  */
+#include <linux/bug.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/bootmem.h>
@@ -14,6 +17,8 @@
 #include <linux/types.h>
 #include <linux/pci.h>
 
+#include <asm/cpu-info.h>
+
 /*
  * Indicate whether we respect the PCI setup left by the firmware.
  *
@@ -150,10 +155,32 @@ void __devinit register_pci_controller(struct pci_controller *hose)
 	       "Skipping PCI bus scan due to resource conflict\n");
 }
 
+static void __init pcibios_set_cache_line_size(void)
+{
+	struct cpuinfo_mips *c = &current_cpu_data;
+	unsigned int lsize;
+
+	/*
+	 * Set PCI cacheline size to that of the highest level in the
+	 * cache hierarchy.
+	 */
+	lsize = c->dcache.linesz;
+	lsize = c->scache.linesz ? : lsize;
+	lsize = c->tcache.linesz ? : lsize;
+
+	BUG_ON(!lsize);
+
+	pci_dfl_cache_line_size = lsize >> 2;
+
+	pr_debug("PCI: pci_cache_line_size set to %d bytes\n", lsize);
+}
+
 static int __init pcibios_init(void)
 {
 	struct pci_controller *hose;
 
+	pcibios_set_cache_line_size();
+
 	/* Scan all of the recorded PCI controllers.  */
 	for (hose = hose_head; hose; hose = hose->next)
 		pcibios_scanbus(hose);

commit 7c090e5bfaa65b031083605a0a4a780443fa6a08
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Fri Oct 28 16:26:57 2011 -0600

    mips/PCI: convert to pci_scan_root_bus() for correct root bus resources
    
    Convert from pci_scan_bus() to pci_scan_root_bus() and remove root bus
    resource fixups.  This fixes the problem of "early" and "header" quirks
    seeing incorrect root bus resources.
    
    Based on original patch by Deng-Cheng Zhu.
    
    Reference: https://lkml.org/lkml/2011/8/26/89
    CC: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Deng-Cheng Zhu <dczhu@mips.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 0586535872cf..fa8e378413b1 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -81,6 +81,7 @@ static void __devinit pcibios_scanbus(struct pci_controller *hose)
 {
 	static int next_busno;
 	static int need_domain_info;
+	LIST_HEAD(resources);
 	struct pci_bus *bus;
 
 	if (!hose->iommu)
@@ -89,7 +90,13 @@ static void __devinit pcibios_scanbus(struct pci_controller *hose)
 	if (hose->get_busno && pci_probe_only)
 		next_busno = (*hose->get_busno)();
 
-	bus = pci_scan_bus(next_busno, hose->pci_ops, hose);
+	pci_add_resource(&resources, hose->mem_resource);
+	pci_add_resource(&resources, hose->io_resource);
+	bus = pci_scan_root_bus(NULL, next_busno, hose->pci_ops, hose,
+				&resources);
+	if (!bus)
+		pci_free_resource_list(&resources);
+
 	hose->bus = bus;
 
 	need_domain_info = need_domain_info || hose->index;
@@ -245,15 +252,11 @@ void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 {
 	/* Propagate hose info into the subordinate devices.  */
 
-	struct pci_controller *hose = bus->sysdata;
 	struct list_head *ln;
 	struct pci_dev *dev = bus->self;
 
-	if (!dev) {
-		bus->resource[0] = hose->io_resource;
-		bus->resource[1] = hose->mem_resource;
-	} else if (pci_probe_only &&
-		   (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
+	if (pci_probe_only && dev &&
+	    (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
 		pci_read_bridge_bases(bus);
 		pcibios_fixup_device_resources(dev, bus);
 	}

commit 96633fa2f8f6b20758bc4e03f3a89e0d58f68fd3
Author: Myron Stowe <mstowe@redhat.com>
Date:   Fri Oct 28 15:48:52 2011 -0600

    PCI: MIPS: use generic pcibios_set_master()
    
    This patch removes MIPS' architecture-specific 'pcibios_set_master()'
    routine and lets the default PCI core based implementation handle PCI
    device 'latency timer' setup.
    
    No functional change.
    
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index f93f749b92e3..0586535872cf 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -205,21 +205,6 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 	return 0;
 }
 
-void pcibios_set_master(struct pci_dev *dev)
-{
-	u8 lat;
-	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);
-	if (lat < 16)
-		lat = (64 <= pcibios_max_latency) ? 64 : pcibios_max_latency;
-	else if (lat > pcibios_max_latency)
-		lat = pcibios_max_latency;
-	else
-		return;
-	printk(KERN_DEBUG "PCI: Setting latency timer of device %s to %d\n",
-	       pci_name(dev), lat);
-	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
-}
-
 unsigned int pcibios_assign_all_busses(void)
 {
 	return (pci_probe & PCI_ASSIGN_ALL_BUSSES) ? 1 : 0;

commit 96c5590058d7fded14f43af2ab521436cecf3125
Author: Myron Stowe <mstowe@redhat.com>
Date:   Fri Oct 28 15:48:38 2011 -0600

    PCI: Pull PCI 'latency timer' setup up into the core
    
    The 'latency timer' of PCI devices, both Type 0 and Type 1,
    is setup in architecture-specific code [see: 'pcibios_set_master()'].
    There are two approaches being taken by all the architectures - check
    if the 'latency timer' is currently set between 16 and 255 and if not
    bring it within bounds, or, do nothing (and then there is the
    gratuitously different PA-RISC implementation).
    
    There is nothing architecture-specific about PCI's 'latency timer' so
    this patch pulls its setup functionality up into the PCI core by
    creating a generic 'pcibios_set_master()' function using the '__weak'
    attribute which can be used by all architectures as a default which,
    if necessary, can then be over-ridden by architecture-specific code.
    
    No functional change.
    
    Signed-off-by: Myron Stowe <myron.stowe@redhat.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 41af7fa2887b..f93f749b92e3 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -205,12 +205,6 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 	return 0;
 }
 
-/*
- *  If we set up a device for bus mastering, we need to check the latency
- *  timer as certain crappy BIOSes forget to set it properly.
- */
-static unsigned int pcibios_max_latency = 255;
-
 void pcibios_set_master(struct pci_dev *dev)
 {
 	u8 lat;

commit cae39d1386dba405de0fbda32e224a1535d38a07
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Jul 28 18:46:31 2011 -0400

    mips: add export.h to files using EXPORT_SYMBOL/THIS_MODULE
    
    Or else we get lots of variations on this:
    
    arch/mips/pci/pci.c:330: warning: type defaults to 'int' in declaration of 'EXPORT_SYMBOL'
    
    scattered throughout the build.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 33bba7bff258..41af7fa2887b 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -9,6 +9,7 @@
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/bootmem.h>
+#include <linux/export.h>
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/pci.h>

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 38bc28005b4a..33bba7bff258 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -125,7 +125,7 @@ void __devinit register_pci_controller(struct pci_controller *hose)
 	hose_tail = &hose->next;
 
 	/*
-	 * Do not panic here but later - this might hapen before console init.
+	 * Do not panic here but later - this might happen before console init.
 	 */
 	if (!hose->io_map_base) {
 		printk(KERN_WARNING

commit 8190471087b59ff63a8db125953ae612b7a8b8b5
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Wed Feb 24 13:53:27 2010 -0700

    MIPS: Cobalt: convert legacy port addresses to GT-64111 bus addresses
    
    The GT-64111 PCI host bridge has no address translation mechanism, so
    it can't generate legacy port accesses.  This quirk fixes legacy device
    port resources to contain the bus addresses actually generated by the
    GT-64111.
    
    I think this is the approach Ben Herrenschmidt suggested long ago:
        http://marc.info/?l=linux-kernel&m=119733290624544&w=2
    
    This allows us to remove the IORESOURCE_PCI_FIXED hack from
    pcibios_fixup_device_resources(), which converts bus addresses to CPU
    addresses.  IORESOURCE_PCI_FIXED denotes resources that can't be moved;
    it has nothing to do with converting bus to CPU addresses.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Yoichi Yuasa <yuasa@linux-mips.org>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: linux-mips@linux-mips.org
    Tested-by: Yoichi Yuasa <yuasa@linux-mips.org>
    Patchwork: http://patchwork.linux-mips.org/patch/998/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index f87f5e188fa6..38bc28005b4a 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -251,8 +251,6 @@ static void pcibios_fixup_device_resources(struct pci_dev *dev,
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 		if (!dev->resource[i].start)
 			continue;
-		if (dev->resource[i].flags & IORESOURCE_PCI_FIXED)
-			continue;
 		if (dev->resource[i].flags & IORESOURCE_IO)
 			offset = hose->io_offset;
 		else if (dev->resource[i].flags & IORESOURCE_MEM)

commit 3b7a17fcdae532d29dffab9d564a28be08960988
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Jan 1 17:40:50 2010 +0100

    resource/PCI: mark struct resource as const
    
    Now that we return the new resource start position, there is no
    need to update "struct resource" inside the align function.
    Therefore, mark the struct resource as const.
    
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 9085988f7cf3..f87f5e188fa6 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -50,7 +50,7 @@ static int pci_initialized;
  * which might have be mirrored at 0x0100-0x03ff..
  */
 resource_size_t
-pcibios_align_resource(void *data, struct resource *res,
+pcibios_align_resource(void *data, const struct resource *res,
 		       resource_size_t size, resource_size_t align)
 {
 	struct pci_dev *dev = data;

commit b26b2d494b659f988b4d75eb394dfa0ddac415c9
Author: Dominik Brodowski <linux@dominikbrodowski.net>
Date:   Fri Jan 1 17:40:49 2010 +0100

    resource/PCI: align functions now return start of resource
    
    As suggested by Linus, align functions should return the start
    of a resource, not void. An update of "res->start" is no longer
    necessary.
    
    Cc: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Cc: Yinghai Lu <yhlu.kernel@gmail.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 9a11c2226891..9085988f7cf3 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -49,7 +49,7 @@ static int pci_initialized;
  * but we want to try to avoid allocating at 0x2900-0x2bff
  * which might have be mirrored at 0x0100-0x03ff..
  */
-void
+resource_size_t
 pcibios_align_resource(void *data, struct resource *res,
 		       resource_size_t size, resource_size_t align)
 {
@@ -73,7 +73,7 @@ pcibios_align_resource(void *data, struct resource *res,
 			start = PCIBIOS_MIN_MEM + hose->mem_resource->start;
 	}
 
-	res->start = start;
+	return start;
 }
 
 static void __devinit pcibios_scanbus(struct pci_controller *hose)

commit 982f6ffeeed5ef6104cfd72e517ff9e7a9270fda
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Sep 17 02:25:07 2009 +0200

    MIPS: Remove useless zero initializations.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index b0eb9e75c682..9a11c2226891 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -31,8 +31,8 @@ unsigned int pci_probe = PCI_ASSIGN_ALL_BUSSES;
 
 static struct pci_controller *hose_head, **hose_tail = &hose_head;
 
-unsigned long PCIBIOS_MIN_IO	= 0x0000;
-unsigned long PCIBIOS_MIN_MEM	= 0;
+unsigned long PCIBIOS_MIN_IO;
+unsigned long PCIBIOS_MIN_MEM;
 
 static int pci_initialized;
 

commit 67eed58060ca2049fd59d35f426b6c7dbd51b20b
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Dec 16 21:37:10 2008 -0700

    PCI: mips: use generic INTx swizzle from PCI core
    
    Use the generic pci_common_swizzle() instead of arch-specific code.
    
    Note that pci_common_swizzle() loops based on dev->bus->self, not
    dev->bus->parent as the mips common_swizzle() did.  I think they
    are equivalent for this purpose.
    
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index fa63dc25125d..b0eb9e75c682 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -149,21 +149,6 @@ void __devinit register_pci_controller(struct pci_controller *hose)
 	       "Skipping PCI bus scan due to resource conflict\n");
 }
 
-static u8 __init common_swizzle(struct pci_dev *dev, u8 *pinp)
-{
-	u8 pin = *pinp;
-
-	while (dev->bus->parent) {
-		pin = pci_swizzle_interrupt_pin(dev, pin);
-		/* Move up the chain of bridges. */
-		dev = dev->bus->self;
-        }
-	*pinp = pin;
-
-	/* The slot is the slot of the last bridge. */
-	return PCI_SLOT(dev->devfn);
-}
-
 static int __init pcibios_init(void)
 {
 	struct pci_controller *hose;
@@ -172,7 +157,7 @@ static int __init pcibios_init(void)
 	for (hose = hose_head; hose; hose = hose->next)
 		pcibios_scanbus(hose);
 
-	pci_fixup_irqs(common_swizzle, pcibios_map_irq);
+	pci_fixup_irqs(pci_common_swizzle, pcibios_map_irq);
 
 	pci_initialized = 1;
 

commit 30d546dac9420fc238109aec2c6596e044cc6d4c
Author: Bjorn Helgaas <bjorn.helgaas@hp.com>
Date:   Tue Dec 9 16:12:17 2008 -0700

    PCI: mips: use generic pci_swizzle_interrupt_pin()
    
    Use the generic pci_swizzle_interrupt_pin() instead of arch-specific code.
    
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Bjorn Helgaas <bjorn.helgaas@hp.com>
    Signed-off-by: Jesse Barnes <jbarnes@virtuousgeek.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 62cae740e250..fa63dc25125d 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -149,19 +149,12 @@ void __devinit register_pci_controller(struct pci_controller *hose)
 	       "Skipping PCI bus scan due to resource conflict\n");
 }
 
-/* Most MIPS systems have straight-forward swizzling needs.  */
-
-static inline u8 bridge_swizzle(u8 pin, u8 slot)
-{
-	return (((pin - 1) + slot) % 4) + 1;
-}
-
 static u8 __init common_swizzle(struct pci_dev *dev, u8 *pinp)
 {
 	u8 pin = *pinp;
 
 	while (dev->bus->parent) {
-		pin = bridge_swizzle(pin, PCI_SLOT(dev->devfn));
+		pin = pci_swizzle_interrupt_pin(dev, pin);
 		/* Move up the chain of bridges. */
 		dev = dev->bus->self;
         }

commit 98873f53becea9a8a46972ff252e96fe575b120d
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Dec 9 17:58:46 2008 +0000

    MIPS: Better than nothing implementation of PCI mmap to fix X.
    
    Certain X11 servers such as the SIS server will only work if PCI mmap is
    implemented.  This patch implements PCI mmap but to be on the same side
    so close to a release it only supports uncached mappings so performance
    will not be optimal for some uses such as framebuffers.
    
    Thanks to Zhang Le <r0bertz@gentoo.org> for the original report and
    testing.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index a377e9d2d029..62cae740e250 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -354,6 +354,30 @@ EXPORT_SYMBOL(PCIBIOS_MIN_IO);
 EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
 #endif
 
+int pci_mmap_page_range(struct pci_dev *dev, struct vm_area_struct *vma,
+			enum pci_mmap_state mmap_state, int write_combine)
+{
+	unsigned long prot;
+
+	/*
+	 * I/O space can be accessed via normal processor loads and stores on
+	 * this platform but for now we elect not to do this and portable
+	 * drivers should not do this anyway.
+	 */
+	if (mmap_state == pci_mmap_io)
+		return -EINVAL;
+
+	/*
+	 * Ignore write-combine; for now only return uncached mappings.
+	 */
+	prot = pgprot_val(vma->vm_page_prot);
+	prot = (prot & ~_CACHE_MASK) | _CACHE_UNCACHED;
+	vma->vm_page_prot = __pgprot(prot);
+
+	return remap_pfn_range(vma, vma->vm_start, vma->vm_pgoff,
+		vma->vm_end - vma->vm_start, vma->vm_page_prot);
+}
+
 char * (*pcibios_plat_setup)(char *str) __devinitdata;
 
 char *__devinit pcibios_setup(char *str)

commit 540799e32eb146c9363445d1118b2bfdebd3da0b
Author: Aurelien Jarno <aurelien@aurel32.net>
Date:   Tue Oct 14 11:45:09 2008 +0200

    MIPS: PCI: Scan busses when they are registered
    
    The patch below changes register_pci_controller() such that controllers
    being added after pcibios_init() has run are be scanned immediately.
    
    This is needed for example by the BCM47xx PCI controller, which is located
    on the SSB bus, which is now initialized after the PCI subsystem.
    
    Signed-off-by: Aurelien Jarno <aurelien@aurel32.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index c7fe6ec621e6..a377e9d2d029 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -34,6 +34,8 @@ static struct pci_controller *hose_head, **hose_tail = &hose_head;
 unsigned long PCIBIOS_MIN_IO	= 0x0000;
 unsigned long PCIBIOS_MIN_MEM	= 0;
 
+static int pci_initialized;
+
 /*
  * We need to avoid collisions with `mirrored' VGA ports
  * and other strange ISA hardware, so we always want the
@@ -74,6 +76,42 @@ pcibios_align_resource(void *data, struct resource *res,
 	res->start = start;
 }
 
+static void __devinit pcibios_scanbus(struct pci_controller *hose)
+{
+	static int next_busno;
+	static int need_domain_info;
+	struct pci_bus *bus;
+
+	if (!hose->iommu)
+		PCI_DMA_BUS_IS_PHYS = 1;
+
+	if (hose->get_busno && pci_probe_only)
+		next_busno = (*hose->get_busno)();
+
+	bus = pci_scan_bus(next_busno, hose->pci_ops, hose);
+	hose->bus = bus;
+
+	need_domain_info = need_domain_info || hose->index;
+	hose->need_domain_info = need_domain_info;
+	if (bus) {
+		next_busno = bus->subordinate + 1;
+		/* Don't allow 8-bit bus number overflow inside the hose -
+		   reserve some space for bridges. */
+		if (next_busno > 224) {
+			next_busno = 0;
+			need_domain_info = 1;
+		}
+
+		if (!pci_probe_only) {
+			pci_bus_size_bridges(bus);
+			pci_bus_assign_resources(bus);
+			pci_enable_bridges(bus);
+		}
+	}
+}
+
+static DEFINE_MUTEX(pci_scan_mutex);
+
 void __devinit register_pci_controller(struct pci_controller *hose)
 {
 	if (request_resource(&iomem_resource, hose->mem_resource) < 0)
@@ -93,6 +131,17 @@ void __devinit register_pci_controller(struct pci_controller *hose)
 		printk(KERN_WARNING
 		       "registering PCI controller with io_map_base unset\n");
 	}
+
+	/*
+	 * Scan the bus if it is register after the PCI subsystem
+	 * initialization.
+	 */
+	if (pci_initialized) {
+		mutex_lock(&pci_scan_mutex);
+		pcibios_scanbus(hose);
+		mutex_unlock(&pci_scan_mutex);
+	}
+
 	return;
 
 out:
@@ -125,38 +174,15 @@ static u8 __init common_swizzle(struct pci_dev *dev, u8 *pinp)
 static int __init pcibios_init(void)
 {
 	struct pci_controller *hose;
-	struct pci_bus *bus;
-	int next_busno;
-	int need_domain_info = 0;
 
 	/* Scan all of the recorded PCI controllers.  */
-	for (next_busno = 0, hose = hose_head; hose; hose = hose->next) {
-
-		if (!hose->iommu)
-			PCI_DMA_BUS_IS_PHYS = 1;
-
-		if (hose->get_busno && pci_probe_only)
-			next_busno = (*hose->get_busno)();
-
-		bus = pci_scan_bus(next_busno, hose->pci_ops, hose);
-		hose->bus = bus;
-		need_domain_info = need_domain_info || hose->index;
-		hose->need_domain_info = need_domain_info;
-		if (bus) {
-			next_busno = bus->subordinate + 1;
-			/* Don't allow 8-bit bus number overflow inside the hose -
-			   reserve some space for bridges. */
-			if (next_busno > 224) {
-				next_busno = 0;
-				need_domain_info = 1;
-			}
-		}
-	}
+	for (hose = hose_head; hose; hose = hose->next)
+		pcibios_scanbus(hose);
 
-	if (!pci_probe_only)
-		pci_assign_unassigned_resources();
 	pci_fixup_irqs(common_swizzle, pcibios_map_irq);
 
+	pci_initialized = 1;
+
 	return 0;
 }
 

commit 47a5c976486e407fc0d0bc8fa165132b6f9bec26
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jul 24 00:25:14 2008 +0900

    [MIPS] Introduce pcibios_plat_setup
    
    Introduce pcibios_plat_setup for platform-specific pcibios_setup.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 77bd5b68dc43..c7fe6ec621e6 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -328,7 +328,11 @@ EXPORT_SYMBOL(PCIBIOS_MIN_IO);
 EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
 #endif
 
-char *pcibios_setup(char *str)
+char * (*pcibios_plat_setup)(char *str) __devinitdata;
+
+char *__devinit pcibios_setup(char *str)
 {
+	if (pcibios_plat_setup)
+		return pcibios_plat_setup(str);
 	return str;
 }

commit 3450004a8cec8bab246372a1cabb9c2483b1e6c3
Author: Dmitri Vorobiev <dmitri.vorobiev@movial.fi>
Date:   Tue Jul 15 19:57:30 2008 +0300

    [MIPS] PCI: Make the pcibios_max_latency variable static
    
    The pcibios_max_latency variable is needlessly defined global, and this
    patch makes it static.
    
    Build-tested using malta_defconfig.
    
    Signed-off-by: Dmitri Vorobiev <dmitri.vorobiev@movial.fi>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index d7d6cb063d26..77bd5b68dc43 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -204,7 +204,7 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
  *  If we set up a device for bus mastering, we need to check the latency
  *  timer as certain crappy BIOSes forget to set it properly.
  */
-unsigned int pcibios_max_latency = 255;
+static unsigned int pcibios_max_latency = 255;
 
 void pcibios_set_master(struct pci_dev *dev)
 {

commit d58eaab5a01b9cf1819ec57271ac214a39bf6278
Author: Dmitri Vorobiev <dmitri.vorobiev@movial.fi>
Date:   Wed Jun 18 10:18:20 2008 +0300

    [MIPS] Namespace clean-up in arch/mips/pci/pci.c
    
    The following symbols
    
            hose_head
            hose_tail
    
    are needlessly defined global in arch/mips/pci/pci.c, and
    this patch makes them static.
    
    The variable pci_isa_hose is not used, and is removed by
    this patch.
    
    Spotted by namespacecheck. Tested by booting a Malta 4Kc
    board up to the shell prompt.
    
    Signed-off-by: Dmitri Vorobiev <dmitri.vorobiev@movial.fi>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 358ad6210949..d7d6cb063d26 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -29,8 +29,7 @@ unsigned int pci_probe = PCI_ASSIGN_ALL_BUSSES;
  * The PCI controller list.
  */
 
-struct pci_controller *hose_head, **hose_tail = &hose_head;
-struct pci_controller *pci_isa_hose;
+static struct pci_controller *hose_head, **hose_tail = &hose_head;
 
 unsigned long PCIBIOS_MIN_IO	= 0x0000;
 unsigned long PCIBIOS_MIN_MEM	= 0;

commit 234fcd1484a66158b561b36b421547f0ab85fee9
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Mar 8 09:56:28 2008 +0000

    [MIPS] Fix loads of section missmatches
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index f9471d77c096..358ad6210949 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -260,7 +260,7 @@ static void pcibios_fixup_device_resources(struct pci_dev *dev,
 	}
 }
 
-void pcibios_fixup_bus(struct pci_bus *bus)
+void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 {
 	/* Propagate hose info into the subordinate devices.  */
 

commit 40d7c1aa6153605b3eae23990d4c2d4e8f807cb0
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Feb 19 16:01:20 2008 +0000

    [MIPS] PCI: Coding style fixes for pcibios_enable_resources.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 1d10d6544152..f9471d77c096 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -183,7 +183,9 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 				(!(r->flags & IORESOURCE_ROM_ENABLE)))
 			continue;
 		if (!r->start && r->end) {
-			printk(KERN_ERR "PCI: Device %s not available because of resource collisions\n", pci_name(dev));
+			printk(KERN_ERR "PCI: Device %s not available "
+			       "because of resource collisions\n",
+			       pci_name(dev));
 			return -EINVAL;
 		}
 		if (r->flags & IORESOURCE_IO)
@@ -192,7 +194,8 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 			cmd |= PCI_COMMAND_MEMORY;
 	}
 	if (cmd != old_cmd) {
-		printk("PCI: Enabling device %s (%04x -> %04x)\n", pci_name(dev), old_cmd, cmd);
+		printk("PCI: Enabling device %s (%04x -> %04x)\n",
+		       pci_name(dev), old_cmd, cmd);
 		pci_write_config_word(dev, PCI_COMMAND, cmd);
 	}
 	return 0;

commit 986c94854e5615000f39edfc788dffff7035ec7d
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Feb 19 15:59:33 2008 +0000

    [MIPS] PCI: Port i386 PCI fixes.
    
    The MIPS version of pcibios_enalbe_resources did not have the fixes
    from ed6d14f9760857c745206c978b80352fc09cfd19 yet which under circumstances
    similar to x86 might result in failures.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 6e6981fd7934..1d10d6544152 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -177,6 +177,11 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 			continue;
 
 		r = &dev->resource[idx];
+		if (!(r->flags & (IORESOURCE_IO | IORESOURCE_MEM)))
+			continue;
+		if ((idx == PCI_ROM_RESOURCE) &&
+				(!(r->flags & IORESOURCE_ROM_ENABLE)))
+			continue;
 		if (!r->start && r->end) {
 			printk(KERN_ERR "PCI: Device %s not available because of resource collisions\n", pci_name(dev));
 			return -EINVAL;
@@ -186,8 +191,6 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 		if (r->flags & IORESOURCE_MEM)
 			cmd |= PCI_COMMAND_MEMORY;
 	}
-	if (dev->resource[PCI_ROM_RESOURCE].start)
-		cmd |= PCI_COMMAND_MEMORY;
 	if (cmd != old_cmd) {
 		printk("PCI: Enabling device %s (%04x -> %04x)\n", pci_name(dev), old_cmd, cmd);
 		pci_write_config_word(dev, PCI_COMMAND, cmd);

commit d20e47e153dcfddca5a066ff0f8da2d1104d08ea
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Dec 11 19:49:24 2007 +0000

    [MIPS] PCI: Make pcibios_fixup_device_resources ignore legacy resources.
    
    There might be other reasons why a resource might be marked as fixed
    such as a PCI UART holding the system console but until we use
    IORESOURCE_PCI_FIXED that way also this will work.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 589b745d822a..6e6981fd7934 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -242,6 +242,8 @@ static void pcibios_fixup_device_resources(struct pci_dev *dev,
 	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
 		if (!dev->resource[i].start)
 			continue;
+		if (dev->resource[i].flags & IORESOURCE_PCI_FIXED)
+			continue;
 		if (dev->resource[i].flags & IORESOURCE_IO)
 			offset = hose->io_offset;
 		else if (dev->resource[i].flags & IORESOURCE_MEM)

commit d4ef9dd33d0f513777409710fd99e016d46c3a85
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Aug 29 08:34:39 2007 +0100

    [MIPS] PCI: Set need_domain_info if controller domain index is non-zero.
    
    This fixes this little funny:
    
    bigsur:/proc/bus/pci# ls -l
    total 0
    dr-xr-xr-x    2 root     root            0 Aug 28 19:31 00
    dr-xr-xr-x    2 root     root            0 Aug 28 19:31 00
    dr-xr-xr-x    2 root     root            0 Aug 28 19:31 01
    dr-xr-xr-x    2 root     root            0 Aug 28 19:31 03
    -r--r--r--    1 root     root            0 Aug 28 19:31 devices
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 6c5c684d1422..589b745d822a 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -141,6 +141,7 @@ static int __init pcibios_init(void)
 
 		bus = pci_scan_bus(next_busno, hose->pci_ops, hose);
 		hose->bus = bus;
+		need_domain_info = need_domain_info || hose->index;
 		hose->need_domain_info = need_domain_info;
 		if (bus) {
 			next_busno = bus->subordinate + 1;

commit 606bf782846163b87868d8cdd46f44241c0c2a6b
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Aug 24 02:13:33 2007 +0100

    [MIPS] HOTPLUG: Make register_pci_controller __devinit.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 403487ed6f15..6c5c684d1422 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -75,7 +75,7 @@ pcibios_align_resource(void *data, struct resource *res,
 	res->start = start;
 }
 
-void __init register_pci_controller(struct pci_controller *hose)
+void __devinit register_pci_controller(struct pci_controller *hose)
 {
 	if (request_resource(&iomem_resource, hose->mem_resource) < 0)
 		goto out;

commit c4aa2563f953d13a9bcf4731b00b0900a45626d7
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Aug 23 14:17:14 2007 +0100

    [MIPS] PCI: Remove __devinit attribute from pcibios_fixup_bus.
    
    Since 96bde06a2df1b363206d3cdef53134b84ff37813 several callers of
    pcibios_resource_to_bus are no longer marked __devinit resulting in a
    pile of modpost warnings if PCI && !HOTPLUG:
    
      MODPOST vmlinux.o
    WARNING: vmlinux.o(.text+0x15dde8): Section mismatch: reference to .init.text:pcibios_resource_to_bus (between 'pci_map_rom' and 'pci_map_rom_copy')
    WARNING: vmlinux.o(.text+0x15e140): Section mismatch: reference to .init.text:pcibios_resource_to_bus (between 'pci_update_resource' and 'pci_claim_resource')
    WARNING: vmlinux.o(.text+0x15f0cc): Section mismatch: reference to .init.text:pcibios_resource_to_bus (between 'pci_setup_cardbus' and 'pci_bus_assign_resources')
    WARNING: vmlinux.o(.text+0x15f0f0): Section mismatch: reference to .init.text:pcibios_resource_to_bus (between 'pci_setup_cardbus' and 'pci_bus_assign_resources')
    WARNING: vmlinux.o(.text+0x15f114): Section mismatch: reference to .init.text:pcibios_resource_to_bus (between 'pci_setup_cardbus' and 'pci_bus_assign_resources')
    WARNING: vmlinux.o(.text+0x15f138): Section mismatch: reference to .init.text:pcibios_resource_to_bus (between 'pci_setup_cardbus' and 'pci_bus_assign_resources')
    WARNING: vmlinux.o(.text+0x15f438): Section mismatch: reference to .init.text:pcibios_resource_to_bus (between 'pci_bus_assign_resources' and 'pbus_size_mem')
    WARNING: vmlinux.o(.text+0x15f4f4): Section mismatch: reference to .init.text:pcibios_resource_to_bus (between 'pci_bus_assign_resources' and 'pbus_size_mem')
    
    Removing __devinit from pcibios_resource_to_bus make the same necessary
    for pcibios_fixup_device_resources as well.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 6c2da625a102..403487ed6f15 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -230,7 +230,7 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
 	return pcibios_plat_dev_init(dev);
 }
 
-static void __devinit pcibios_fixup_device_resources(struct pci_dev *dev,
+static void pcibios_fixup_device_resources(struct pci_dev *dev,
 	struct pci_bus *bus)
 {
 	/* Update device resources.  */
@@ -282,8 +282,7 @@ pcibios_update_irq(struct pci_dev *dev, int irq)
 	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
 }
 
-void __devinit
-pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
+void pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
 			 struct resource *res)
 {
 	struct pci_controller *hose = (struct pci_controller *)dev->sysdata;

commit 4547d224d29a6a9a81df91858c2e26b7f88e02e1
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Aug 23 14:12:56 2007 +0100

    [MIPS] PCI: Remove __devinit attribute from pcibios_fixup_bus.
    
    Since 96bde06a2df1b363206d3cdef53134b84ff37813 pcibios_fixup_bus's caller
    pci_scan_child_bus is no longer marked __devinit resulting in this modpost
    warning if PCI && !HOTPLUG:
    
      MODPOST vmlinux.o
    WARNING: vmlinux.o(.text+0x158b9c): Section mismatch: reference to .init.text:pcibios_fixup_bus (between 'pci_scan_child_bus' and 'pci_scan_bus_parented')
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 99d8f4fd3ff4..6c2da625a102 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -251,7 +251,7 @@ static void __devinit pcibios_fixup_device_resources(struct pci_dev *dev,
 	}
 }
 
-void __devinit pcibios_fixup_bus(struct pci_bus *bus)
+void pcibios_fixup_bus(struct pci_bus *bus)
 {
 	/* Propagate hose info into the subordinate devices.  */
 

commit 8ed07a1cce1530d2fd42e23c867a7c0c1170515a
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Jul 13 01:26:52 2007 +0900

    [MIPS] Fix a sparse warning in arch/mips/pci/pci.c
    
    Fixes this warning:
    
    arch/mips/pci/pci.c:284:18: warning: symbol 'dev' shadows an earlier one
    arch/mips/pci/pci.c:272:17: originally declared here
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 8108231f2e20..99d8f4fd3ff4 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -269,7 +269,7 @@ void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 	}
 
 	for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
-		struct pci_dev *dev = pci_dev_b(ln);
+		dev = pci_dev_b(ln);
 
 		if ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)
 			pcibios_fixup_device_resources(dev, bus);

commit 639702bd725b3cc1a9bd442a7822c83849d66e91
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Sun Apr 8 13:28:44 2007 +0200

    [MIPS] Register PCI host bridge resource earlier
    
    PCI based SNI RM machines have their EISA bus behind an Intel PCI/EISA
    bridge. So the PCI IO range must start at 0x0000. Changing that will
    break the PCI bus, because i8259.c already has registered it's IO
    addresses before the PCI bus gets initialized. Below is a patch,
    which will register the PCI host bridge resources inside
    register_pci_controller(). It also changes i8259.c to use insert_region(),
    because request_resource() will fail, if the IO space of the PIT hanging
    of the PCI host bridge (maybe passing the resource parent to
    init_i8259_irqs() is a cleaner fix for that).
    
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index de7cfc559ddb..8108231f2e20 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -77,6 +77,13 @@ pcibios_align_resource(void *data, struct resource *res,
 
 void __init register_pci_controller(struct pci_controller *hose)
 {
+	if (request_resource(&iomem_resource, hose->mem_resource) < 0)
+		goto out;
+	if (request_resource(&ioport_resource, hose->io_resource) < 0) {
+		release_resource(hose->mem_resource);
+		goto out;
+	}
+
 	*hose_tail = hose;
 	hose_tail = &hose->next;
 
@@ -87,6 +94,11 @@ void __init register_pci_controller(struct pci_controller *hose)
 		printk(KERN_WARNING
 		       "registering PCI controller with io_map_base unset\n");
 	}
+	return;
+
+out:
+	printk(KERN_WARNING
+	       "Skipping PCI bus scan due to resource conflict\n");
 }
 
 /* Most MIPS systems have straight-forward swizzling needs.  */
@@ -121,11 +133,6 @@ static int __init pcibios_init(void)
 	/* Scan all of the recorded PCI controllers.  */
 	for (next_busno = 0, hose = hose_head; hose; hose = hose->next) {
 
-		if (request_resource(&iomem_resource, hose->mem_resource) < 0)
-			goto out;
-		if (request_resource(&ioport_resource, hose->io_resource) < 0)
-			goto out_free_mem_resource;
-
 		if (!hose->iommu)
 			PCI_DMA_BUS_IS_PHYS = 1;
 
@@ -144,14 +151,6 @@ static int __init pcibios_init(void)
 				need_domain_info = 1;
 			}
 		}
-		continue;
-
-out_free_mem_resource:
-		release_resource(hose->mem_resource);
-
-out:
-		printk(KERN_WARNING
-		       "Skipping PCI bus scan due to resource conflict\n");
 	}
 
 	if (!pci_probe_only)

commit 4419708807308fc93ec9a135db7ffe50b182fdda
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Feb 23 01:13:17 2007 +0900

    [MIPS] Mark pcibios_fixup_device_resources() as __devinit
    
    pcibios_fixup_device_resources() is called by pcibios_fixup_bus() which is
    marked as __devinit.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 697a7e48cb8d..de7cfc559ddb 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -231,7 +231,7 @@ int pcibios_enable_device(struct pci_dev *dev, int mask)
 	return pcibios_plat_dev_init(dev);
 }
 
-static void __init pcibios_fixup_device_resources(struct pci_dev *dev,
+static void __devinit pcibios_fixup_device_resources(struct pci_dev *dev,
 	struct pci_bus *bus)
 {
 	/* Update device resources.  */

commit 140c1729a221dc6eacfcbf2a073dbf00fad13e43
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Dec 7 15:35:43 2006 +0100

    [MIPS] Iomap implementation.
    
    This implementation has support for the concept of one separate ioport
    address space by PCI domain.  A pointer to the virtual address where
    the port space of a domain has been mapped has been added to struct
    pci_controller and systems should be fixed to fill in this value. For
    single domain systems this will be the same value as passed to
    set_io_port_base().
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 5ace368657ad..697a7e48cb8d 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -79,6 +79,14 @@ void __init register_pci_controller(struct pci_controller *hose)
 {
 	*hose_tail = hose;
 	hose_tail = &hose->next;
+
+	/*
+	 * Do not panic here but later - this might hapen before console init.
+	 */
+	if (!hose->io_map_base) {
+		printk(KERN_WARNING
+		       "registering PCI controller with io_map_base unset\n");
+	}
 }
 
 /* Most MIPS systems have straight-forward swizzling needs.  */

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index ba66f8c9bd4e..5ace368657ad 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -6,7 +6,6 @@
  *
  * Copyright (C) 2003, 04 Ralf Baechle (ralf@linux-mips.org)
  */
-#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/bootmem.h>

commit e31dd6e4520439ceae4753f32dd2da2c345e929a
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jun 12 17:06:02 2006 -0700

    [PATCH] 64bit resource: change pci core and arch code to use resource_size_t
    
    Based on a patch series originally from Vivek Goyal <vgoyal@in.ibm.com>
    
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 4dfce154d4af..ba66f8c9bd4e 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -51,11 +51,11 @@ unsigned long PCIBIOS_MIN_MEM	= 0;
  */
 void
 pcibios_align_resource(void *data, struct resource *res,
-		       unsigned long size, unsigned long align)
+		       resource_size_t size, resource_size_t align)
 {
 	struct pci_dev *dev = data;
 	struct pci_controller *hose = dev->sysdata;
-	unsigned long start = res->start;
+	resource_size_t start = res->start;
 
 	if (res->flags & IORESOURCE_IO) {
 		/* Make sure we start at our min on all hoses */

commit 610019baddcb4c4c323c12cd44ca7f73d7145d6f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Jun 17 14:54:32 2006 +0100

    [MIPS] Remove unused function alloc_pci_controller.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 21402ffd7c98..4dfce154d4af 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -76,11 +76,6 @@ pcibios_align_resource(void *data, struct resource *res,
 	res->start = start;
 }
 
-struct pci_controller * __init alloc_pci_controller(void)
-{
-	return alloc_bootmem(sizeof(struct pci_controller));
-}
-
 void __init register_pci_controller(struct pci_controller *hose)
 {
 	*hose_tail = hose;

commit 8a1417de9e11f9f577499cd4fe89fa35f4bf54fa
Author: Andrew Isaacson <adi@broadcom.com>
Date:   Wed Oct 19 23:59:11 2005 -0700

    BCM1480 HT support
    
    PCI support code for PLX 7250 PCI-X tunnel on BCM91480B BigSur board.
    
    Signed-Off-By: Andy Isaacson <adi@broadcom.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 170c6650f961..21402ffd7c98 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -127,15 +127,20 @@ static int __init pcibios_init(void)
 		if (!hose->iommu)
 			PCI_DMA_BUS_IS_PHYS = 1;
 
+		if (hose->get_busno && pci_probe_only)
+			next_busno = (*hose->get_busno)();
+
 		bus = pci_scan_bus(next_busno, hose->pci_ops, hose);
 		hose->bus = bus;
 		hose->need_domain_info = need_domain_info;
-		next_busno = bus->subordinate + 1;
-		/* Don't allow 8-bit bus number overflow inside the hose -
-		   reserve some space for bridges. */
-		if (next_busno > 224) {
-			next_busno = 0;
-			need_domain_info = 1;
+		if (bus) {
+			next_busno = bus->subordinate + 1;
+			/* Don't allow 8-bit bus number overflow inside the hose -
+			   reserve some space for bridges. */
+			if (next_busno > 224) {
+				next_busno = 0;
+				need_domain_info = 1;
+			}
 		}
 		continue;
 

commit e5de3b468795e4c58a9f0702630d28707b3ae011
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jul 12 09:18:53 2005 +0000

    In pcibios_enable_resources go back to handling all PCI_NUM_RESOURCES
    resources.  We tried previous but ran into problems ...
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index a8d499b0a36f..170c6650f961 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -164,7 +164,7 @@ static int pcibios_enable_resources(struct pci_dev *dev, int mask)
 
 	pci_read_config_word(dev, PCI_COMMAND, &cmd);
 	old_cmd = cmd;
-	for(idx=0; idx<6; idx++) {
+	for (idx=0; idx < PCI_NUM_RESOURCES; idx++) {
 		/* Only set up the requested stuff */
 		if (!(mask & (1<<idx)))
 			continue;

commit e63ea56fe2669c20f4668d89522500f4ab439b04
Author: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
Date:   Sat Sep 3 15:56:20 2005 -0700

    [PATCH] mips: add pcibios_bus_to_resource
    
    This patch has added pcibios_bus_to_resource to MIPS.
    
    Signed-off-by: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 8a5b52250bda..a8d499b0a36f 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -292,8 +292,25 @@ pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
 	region->end = res->end - offset;
 }
 
+void __devinit
+pcibios_bus_to_resource(struct pci_dev *dev, struct resource *res,
+			struct pci_bus_region *region)
+{
+	struct pci_controller *hose = (struct pci_controller *)dev->sysdata;
+	unsigned long offset = 0;
+
+	if (res->flags & IORESOURCE_IO)
+		offset = hose->io_offset;
+	else if (res->flags & IORESOURCE_MEM)
+		offset = hose->mem_offset;
+
+	res->start = region->start + offset;
+	res->end = region->end + offset;
+}
+
 #ifdef CONFIG_HOTPLUG
 EXPORT_SYMBOL(pcibios_resource_to_bus);
+EXPORT_SYMBOL(pcibios_bus_to_resource);
 EXPORT_SYMBOL(PCIBIOS_MIN_IO);
 EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
 #endif

commit 42a3b4f25af8f8d77feddf27f839fa0628dbff1a
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Sep 3 15:56:17 2005 -0700

    [PATCH] mips: nuke trailing whitespace
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
index 8141dffac241..8a5b52250bda 100644
--- a/arch/mips/pci/pci.c
+++ b/arch/mips/pci/pci.c
@@ -132,7 +132,7 @@ static int __init pcibios_init(void)
 		hose->need_domain_info = need_domain_info;
 		next_busno = bus->subordinate + 1;
 		/* Don't allow 8-bit bus number overflow inside the hose -
-		   reserve some space for bridges. */ 
+		   reserve some space for bridges. */
 		if (next_busno > 224) {
 			next_busno = 0;
 			need_domain_info = 1;
@@ -260,7 +260,7 @@ void __devinit pcibios_fixup_bus(struct pci_bus *bus)
 		   (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
 		pci_read_bridge_bases(bus);
 		pcibios_fixup_device_resources(dev, bus);
-	} 
+	}
 
 	for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
 		struct pci_dev *dev = pci_dev_b(ln);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/pci/pci.c b/arch/mips/pci/pci.c
new file mode 100644
index 000000000000..8141dffac241
--- /dev/null
+++ b/arch/mips/pci/pci.c
@@ -0,0 +1,304 @@
+/*
+ * This program is free software; you can redistribute  it and/or modify it
+ * under  the terms of  the GNU General  Public License as published by the
+ * Free Software Foundation;  either version 2 of the  License, or (at your
+ * option) any later version.
+ *
+ * Copyright (C) 2003, 04 Ralf Baechle (ralf@linux-mips.org)
+ */
+#include <linux/config.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/bootmem.h>
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/pci.h>
+
+/*
+ * Indicate whether we respect the PCI setup left by the firmware.
+ *
+ * Make this long-lived  so that we know when shutting down
+ * whether we probed only or not.
+ */
+int pci_probe_only;
+
+#define PCI_ASSIGN_ALL_BUSSES	1
+
+unsigned int pci_probe = PCI_ASSIGN_ALL_BUSSES;
+
+/*
+ * The PCI controller list.
+ */
+
+struct pci_controller *hose_head, **hose_tail = &hose_head;
+struct pci_controller *pci_isa_hose;
+
+unsigned long PCIBIOS_MIN_IO	= 0x0000;
+unsigned long PCIBIOS_MIN_MEM	= 0;
+
+/*
+ * We need to avoid collisions with `mirrored' VGA ports
+ * and other strange ISA hardware, so we always want the
+ * addresses to be allocated in the 0x000-0x0ff region
+ * modulo 0x400.
+ *
+ * Why? Because some silly external IO cards only decode
+ * the low 10 bits of the IO address. The 0x00-0xff region
+ * is reserved for motherboard devices that decode all 16
+ * bits, so it's ok to allocate at, say, 0x2800-0x28ff,
+ * but we want to try to avoid allocating at 0x2900-0x2bff
+ * which might have be mirrored at 0x0100-0x03ff..
+ */
+void
+pcibios_align_resource(void *data, struct resource *res,
+		       unsigned long size, unsigned long align)
+{
+	struct pci_dev *dev = data;
+	struct pci_controller *hose = dev->sysdata;
+	unsigned long start = res->start;
+
+	if (res->flags & IORESOURCE_IO) {
+		/* Make sure we start at our min on all hoses */
+		if (start < PCIBIOS_MIN_IO + hose->io_resource->start)
+			start = PCIBIOS_MIN_IO + hose->io_resource->start;
+
+		/*
+		 * Put everything into 0x00-0xff region modulo 0x400
+		 */
+		if (start & 0x300)
+			start = (start + 0x3ff) & ~0x3ff;
+	} else if (res->flags & IORESOURCE_MEM) {
+		/* Make sure we start at our min on all hoses */
+		if (start < PCIBIOS_MIN_MEM + hose->mem_resource->start)
+			start = PCIBIOS_MIN_MEM + hose->mem_resource->start;
+	}
+
+	res->start = start;
+}
+
+struct pci_controller * __init alloc_pci_controller(void)
+{
+	return alloc_bootmem(sizeof(struct pci_controller));
+}
+
+void __init register_pci_controller(struct pci_controller *hose)
+{
+	*hose_tail = hose;
+	hose_tail = &hose->next;
+}
+
+/* Most MIPS systems have straight-forward swizzling needs.  */
+
+static inline u8 bridge_swizzle(u8 pin, u8 slot)
+{
+	return (((pin - 1) + slot) % 4) + 1;
+}
+
+static u8 __init common_swizzle(struct pci_dev *dev, u8 *pinp)
+{
+	u8 pin = *pinp;
+
+	while (dev->bus->parent) {
+		pin = bridge_swizzle(pin, PCI_SLOT(dev->devfn));
+		/* Move up the chain of bridges. */
+		dev = dev->bus->self;
+        }
+	*pinp = pin;
+
+	/* The slot is the slot of the last bridge. */
+	return PCI_SLOT(dev->devfn);
+}
+
+static int __init pcibios_init(void)
+{
+	struct pci_controller *hose;
+	struct pci_bus *bus;
+	int next_busno;
+	int need_domain_info = 0;
+
+	/* Scan all of the recorded PCI controllers.  */
+	for (next_busno = 0, hose = hose_head; hose; hose = hose->next) {
+
+		if (request_resource(&iomem_resource, hose->mem_resource) < 0)
+			goto out;
+		if (request_resource(&ioport_resource, hose->io_resource) < 0)
+			goto out_free_mem_resource;
+
+		if (!hose->iommu)
+			PCI_DMA_BUS_IS_PHYS = 1;
+
+		bus = pci_scan_bus(next_busno, hose->pci_ops, hose);
+		hose->bus = bus;
+		hose->need_domain_info = need_domain_info;
+		next_busno = bus->subordinate + 1;
+		/* Don't allow 8-bit bus number overflow inside the hose -
+		   reserve some space for bridges. */ 
+		if (next_busno > 224) {
+			next_busno = 0;
+			need_domain_info = 1;
+		}
+		continue;
+
+out_free_mem_resource:
+		release_resource(hose->mem_resource);
+
+out:
+		printk(KERN_WARNING
+		       "Skipping PCI bus scan due to resource conflict\n");
+	}
+
+	if (!pci_probe_only)
+		pci_assign_unassigned_resources();
+	pci_fixup_irqs(common_swizzle, pcibios_map_irq);
+
+	return 0;
+}
+
+subsys_initcall(pcibios_init);
+
+static int pcibios_enable_resources(struct pci_dev *dev, int mask)
+{
+	u16 cmd, old_cmd;
+	int idx;
+	struct resource *r;
+
+	pci_read_config_word(dev, PCI_COMMAND, &cmd);
+	old_cmd = cmd;
+	for(idx=0; idx<6; idx++) {
+		/* Only set up the requested stuff */
+		if (!(mask & (1<<idx)))
+			continue;
+
+		r = &dev->resource[idx];
+		if (!r->start && r->end) {
+			printk(KERN_ERR "PCI: Device %s not available because of resource collisions\n", pci_name(dev));
+			return -EINVAL;
+		}
+		if (r->flags & IORESOURCE_IO)
+			cmd |= PCI_COMMAND_IO;
+		if (r->flags & IORESOURCE_MEM)
+			cmd |= PCI_COMMAND_MEMORY;
+	}
+	if (dev->resource[PCI_ROM_RESOURCE].start)
+		cmd |= PCI_COMMAND_MEMORY;
+	if (cmd != old_cmd) {
+		printk("PCI: Enabling device %s (%04x -> %04x)\n", pci_name(dev), old_cmd, cmd);
+		pci_write_config_word(dev, PCI_COMMAND, cmd);
+	}
+	return 0;
+}
+
+/*
+ *  If we set up a device for bus mastering, we need to check the latency
+ *  timer as certain crappy BIOSes forget to set it properly.
+ */
+unsigned int pcibios_max_latency = 255;
+
+void pcibios_set_master(struct pci_dev *dev)
+{
+	u8 lat;
+	pci_read_config_byte(dev, PCI_LATENCY_TIMER, &lat);
+	if (lat < 16)
+		lat = (64 <= pcibios_max_latency) ? 64 : pcibios_max_latency;
+	else if (lat > pcibios_max_latency)
+		lat = pcibios_max_latency;
+	else
+		return;
+	printk(KERN_DEBUG "PCI: Setting latency timer of device %s to %d\n",
+	       pci_name(dev), lat);
+	pci_write_config_byte(dev, PCI_LATENCY_TIMER, lat);
+}
+
+unsigned int pcibios_assign_all_busses(void)
+{
+	return (pci_probe & PCI_ASSIGN_ALL_BUSSES) ? 1 : 0;
+}
+
+int pcibios_enable_device(struct pci_dev *dev, int mask)
+{
+	int err;
+
+	if ((err = pcibios_enable_resources(dev, mask)) < 0)
+		return err;
+
+	return pcibios_plat_dev_init(dev);
+}
+
+static void __init pcibios_fixup_device_resources(struct pci_dev *dev,
+	struct pci_bus *bus)
+{
+	/* Update device resources.  */
+	struct pci_controller *hose = (struct pci_controller *)bus->sysdata;
+	unsigned long offset = 0;
+	int i;
+
+	for (i = 0; i < PCI_NUM_RESOURCES; i++) {
+		if (!dev->resource[i].start)
+			continue;
+		if (dev->resource[i].flags & IORESOURCE_IO)
+			offset = hose->io_offset;
+		else if (dev->resource[i].flags & IORESOURCE_MEM)
+			offset = hose->mem_offset;
+
+		dev->resource[i].start += offset;
+		dev->resource[i].end += offset;
+	}
+}
+
+void __devinit pcibios_fixup_bus(struct pci_bus *bus)
+{
+	/* Propagate hose info into the subordinate devices.  */
+
+	struct pci_controller *hose = bus->sysdata;
+	struct list_head *ln;
+	struct pci_dev *dev = bus->self;
+
+	if (!dev) {
+		bus->resource[0] = hose->io_resource;
+		bus->resource[1] = hose->mem_resource;
+	} else if (pci_probe_only &&
+		   (dev->class >> 8) == PCI_CLASS_BRIDGE_PCI) {
+		pci_read_bridge_bases(bus);
+		pcibios_fixup_device_resources(dev, bus);
+	} 
+
+	for (ln = bus->devices.next; ln != &bus->devices; ln = ln->next) {
+		struct pci_dev *dev = pci_dev_b(ln);
+
+		if ((dev->class >> 8) != PCI_CLASS_BRIDGE_PCI)
+			pcibios_fixup_device_resources(dev, bus);
+	}
+}
+
+void __init
+pcibios_update_irq(struct pci_dev *dev, int irq)
+{
+	pci_write_config_byte(dev, PCI_INTERRUPT_LINE, irq);
+}
+
+void __devinit
+pcibios_resource_to_bus(struct pci_dev *dev, struct pci_bus_region *region,
+			 struct resource *res)
+{
+	struct pci_controller *hose = (struct pci_controller *)dev->sysdata;
+	unsigned long offset = 0;
+
+	if (res->flags & IORESOURCE_IO)
+		offset = hose->io_offset;
+	else if (res->flags & IORESOURCE_MEM)
+		offset = hose->mem_offset;
+
+	region->start = res->start - offset;
+	region->end = res->end - offset;
+}
+
+#ifdef CONFIG_HOTPLUG
+EXPORT_SYMBOL(pcibios_resource_to_bus);
+EXPORT_SYMBOL(PCIBIOS_MIN_IO);
+EXPORT_SYMBOL(PCIBIOS_MIN_MEM);
+#endif
+
+char *pcibios_setup(char *str)
+{
+	return str;
+}
