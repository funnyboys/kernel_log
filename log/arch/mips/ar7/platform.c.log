commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 1f2028266493..215149a85d83 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -702,7 +702,7 @@ static int __init ar7_register_devices(void)
 		pr_warn("unable to register usb slave: %d\n", res);
 
 	/* Register watchdog only if enabled in hardware */
-	bootcr = ioremap_nocache(AR7_REGS_DCL, 4);
+	bootcr = ioremap(AR7_REGS_DCL, 4);
 	val = readl(bootcr);
 	iounmap(bootcr);
 	if (val & AR7_WDT_HW_ENA) {

commit fd534e9b5fdcf9bab33c03cb3ade1a1ae5b23c20
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:39 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 102
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      51 franklin st fifth floor boston ma 02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 50 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091649.499889647@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 10ff07b7721e..1f2028266493 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -1,20 +1,7 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2006,2007 Felix Fietkau <nbd@openwrt.org>
  * Copyright (C) 2006,2007 Eugene Konev <ejka@openwrt.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 #include <linux/init.h>

commit 5468e82f7034f0ae175a3ce075441356099bdaa3
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Mon Feb 4 11:26:18 2019 +0100

    net: phy: fixed-phy: Drop GPIO from fixed_phy_add()
    
    All users of the fixed_phy_add() pass -1 as GPIO number
    to the fixed phy driver, and all users of fixed_phy_register()
    pass -1 as GPIO number as well, except for the device
    tree MDIO bus.
    
    Any new users should create a proper device and pass the
    GPIO as a descriptor associated with the device so delete
    the GPIO argument from the calls and drop the code looking
    requesting a GPIO in fixed_phy_add().
    
    In fixed phy_register(), investigate the "fixed-link"
    node and pick the GPIO descriptor from "link-gpios" if
    this property exists. Move the corresponding code out
    of of_mdio.c as the fixed phy code anyways requires
    OF to be in use.
    
    Tested-by: Andrew Lunn <andrew@lunn.ch>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index f09262e0a72f..10ff07b7721e 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -683,7 +683,7 @@ static int __init ar7_register_devices(void)
 
 	if (ar7_has_high_cpmac()) {
 		res = fixed_phy_add(PHY_POLL, cpmac_high.id,
-				    &fixed_phy_status, -1);
+				    &fixed_phy_status);
 		if (!res) {
 			cpmac_get_mac(1, cpmac_high_data.dev_addr);
 
@@ -696,7 +696,7 @@ static int __init ar7_register_devices(void)
 	} else
 		cpmac_low_data.phy_mask = 0xffffffff;
 
-	res = fixed_phy_add(PHY_POLL, cpmac_low.id, &fixed_phy_status, -1);
+	res = fixed_phy_add(PHY_POLL, cpmac_low.id, &fixed_phy_status);
 	if (!res) {
 		cpmac_get_mac(0, cpmac_low_data.dev_addr);
 		res = platform_device_register(&cpmac_low);

commit 041f40f44cd0509a52c66ada27e115429c010d4d
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Tue Dec 26 12:03:09 2017 +0530

    MIPS: AR7: Constify gpio_led
    
    gpio_leds are not supposed to change at runtime. struct
    gpio_led_platform_data contains a const struct gpio_led pointer since
    v2.6.39, so mark the gpio_led structures const too.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/18007/
    [jhogan@kernel.org: improve commit message]
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index e1675c25d5d4..f09262e0a72f 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -346,7 +346,7 @@ static struct platform_device ar7_udc = {
 /*****************************************************************************
  * LEDs
  ****************************************************************************/
-static struct gpio_led default_leds[] = {
+static const struct gpio_led default_leds[] = {
 	{
 		.name			= "status",
 		.gpio			= 8,
@@ -354,12 +354,12 @@ static struct gpio_led default_leds[] = {
 	},
 };
 
-static struct gpio_led titan_leds[] = {
+static const struct gpio_led titan_leds[] = {
 	{ .name = "status", .gpio = 8, .active_low = 1, },
 	{ .name = "wifi", .gpio = 13, .active_low = 1, },
 };
 
-static struct gpio_led dsl502t_leds[] = {
+static const struct gpio_led dsl502t_leds[] = {
 	{
 		.name			= "status",
 		.gpio			= 9,
@@ -377,7 +377,7 @@ static struct gpio_led dsl502t_leds[] = {
 	},
 };
 
-static struct gpio_led dg834g_leds[] = {
+static const struct gpio_led dg834g_leds[] = {
 	{
 		.name			= "ppp",
 		.gpio			= 6,
@@ -406,7 +406,7 @@ static struct gpio_led dg834g_leds[] = {
 	},
 };
 
-static struct gpio_led fb_sl_leds[] = {
+static const struct gpio_led fb_sl_leds[] = {
 	{
 		.name			= "1",
 		.gpio			= 7,
@@ -433,7 +433,7 @@ static struct gpio_led fb_sl_leds[] = {
 	},
 };
 
-static struct gpio_led fb_fon_leds[] = {
+static const struct gpio_led fb_fon_leds[] = {
 	{
 		.name			= "1",
 		.gpio			= 8,
@@ -459,7 +459,7 @@ static struct gpio_led fb_fon_leds[] = {
 	},
 };
 
-static struct gpio_led gt701_leds[] = {
+static const struct gpio_led gt701_leds[] = {
 	{
 		.name			= "inet:green",
 		.gpio			= 13,

commit 0a5191efe06b5103909206e4fbcff81d30283f8e
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Sun Oct 29 16:27:21 2017 +0100

    MIPS: AR7: ensure the port type's FCR value is used
    
    Since commit aef9a7bd9b67 ("serial/uart/8250: Add tunable RX interrupt
    trigger I/F of FIFO buffers"), the port's default FCR value isn't used
    in serial8250_do_set_termios anymore, but copied over once in
    serial8250_config_port and then modified as needed.
    
    Unfortunately, serial8250_config_port will never be called if the port
    is shared between kernel and userspace, and the port's flag doesn't have
    UPF_BOOT_AUTOCONF, which would trigger a serial8250_config_port as well.
    
    This causes garbled output from userspace:
    
    [    5.220000] random: procd urandom read with 49 bits of entropy available
    ers
       [kee
    
    Fix this by forcing it to be configured on boot, resulting in the
    expected output:
    
    [    5.250000] random: procd urandom read with 50 bits of entropy available
    Press the [f] key and hit [enter] to enter failsafe mode
    Press the [1], [2], [3] or [4] key and hit [enter] to select the debug level
    
    Fixes: aef9a7bd9b67 ("serial/uart/8250: Add tunable RX interrupt trigger I/F of FIFO buffers")
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Yoshihiro YUNOMAE <yoshihiro.yunomae.ez@hitachi.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Nicolas Schichan <nschichan@freebox.fr>
    Cc: linux-mips@linux-mips.org
    Cc: linux-serial@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/17544/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 4674f1efbe7a..e1675c25d5d4 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -575,7 +575,7 @@ static int __init ar7_register_uarts(void)
 	uart_port.type		= PORT_AR7;
 	uart_port.uartclk	= clk_get_rate(bus_clk) / 2;
 	uart_port.iotype	= UPIO_MEM32;
-	uart_port.flags		= UPF_FIXED_TYPE;
+	uart_port.flags		= UPF_FIXED_TYPE | UPF_BOOT_AUTOCONF;
 	uart_port.regshift	= 2;
 
 	uart_port.line		= 0;

commit b084116f8587b222a2c5ef6dcd846f40f24b9420
Author: Oswald Buddenhagen <oswald.buddenhagen@gmx.de>
Date:   Sun Oct 29 16:27:20 2017 +0100

    MIPS: AR7: Ensure that serial ports are properly set up
    
    Without UPF_FIXED_TYPE, the data from the PORT_AR7 uart_config entry is
    never copied, resulting in a dead port.
    
    Fixes: 154615d55459 ("MIPS: AR7: Use correct UART port type")
    Signed-off-by: Oswald Buddenhagen <oswald.buddenhagen@gmx.de>
    [jonas.gorski: add Fixes tag]
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Yoshihiro YUNOMAE <yoshihiro.yunomae.ez@hitachi.com>
    Cc: Nicolas Schichan <nschichan@freebox.fr>
    Cc: Oswald Buddenhagen <oswald.buddenhagen@gmx.de>
    Cc: linux-mips@linux-mips.org
    Cc: linux-serial@vger.kernel.org
    Cc: <stable@vger.kernel.org>
    Patchwork: https://patchwork.linux-mips.org/patch/17543/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index f2c9f90c5f13..4674f1efbe7a 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -575,6 +575,7 @@ static int __init ar7_register_uarts(void)
 	uart_port.type		= PORT_AR7;
 	uart_port.uartclk	= clk_get_rate(bus_clk) / 2;
 	uart_port.iotype	= UPIO_MEM32;
+	uart_port.flags		= UPF_FIXED_TYPE;
 	uart_port.regshift	= 2;
 
 	uart_port.line		= 0;

commit e6b03ab63b4d270e0249f96536fde632409dc1dc
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Sun Oct 29 16:27:19 2017 +0100

    MIPS: AR7: Defer registration of GPIO
    
    When called from prom init code, ar7_gpio_init() will fail as it will
    call gpiochip_add() which relies on a working kmalloc() to alloc
    the gpio_desc array and kmalloc is not useable yet at prom init time.
    
    Move ar7_gpio_init() to ar7_register_devices() (a device_initcall)
    where kmalloc works.
    
    Fixes: 14e85c0e69d5 ("gpio: remove gpio_descs global array")
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Yoshihiro YUNOMAE <yoshihiro.yunomae.ez@hitachi.com>
    Cc: Nicolas Schichan <nschichan@freebox.fr>
    Cc: linux-mips@linux-mips.org
    Cc: linux-serial@vger.kernel.org
    Cc: <stable@vger.kernel.org> # 3.19+
    Patchwork: https://patchwork.linux-mips.org/patch/17542/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index df7acea3747a..f2c9f90c5f13 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -653,6 +653,10 @@ static int __init ar7_register_devices(void)
 	u32 val;
 	int res;
 
+	res = ar7_gpio_init();
+	if (res)
+		pr_warn("unable to register gpios: %d\n", res);
+
 	res = ar7_register_uarts();
 	if (res)
 		pr_err("unable to setup uart(s): %d\n", res);

commit 26dd3e4ff9ac1aa576c97d23d7425d2544dbc5bf
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Jan 28 21:05:57 2017 -0500

    MIPS: Audit and remove any unnecessary uses of module.h
    
    Historically a lot of these existed because we did not have
    a distinction between what was modular code and what was providing
    support to modules via EXPORT_SYMBOL and friends.  That changed
    when we forked out support for the latter into the export.h file.
    
    This means we should be able to reduce the usage of module.h
    in code that is obj-y Makefile or bool Kconfig.  In the case of
    some code where it is modular, we can extend that to also include
    files that are building basic support functionality but not related
    to loading or registering the final module; such files also have
    no need whatsoever for module.h
    
    The advantage in removing such instances is that module.h itself
    sources about 15 other headers; adding significantly to what we feed
    cpp, and it can obscure what headers we are effectively using.
    
    Since module.h might have been the implicit source for init.h
    (for __init) and for export.h (for EXPORT_SYMBOL) we consider each
    instance for the presence of either and replace/add as needed.
    
    Also note that MODULE_DEVICE_TABLE is a no-op for non-modular code.
    
    Build coverage of all the mips defconfigs revealed the module.h
    header was masking a couple of implicit include instances, so
    we add the appropriate headers there.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: David Daney <david.daney@cavium.com>
    Cc: John Crispin <john@phrozen.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: "Steven J. Hill" <steven.hill@cavium.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/15131/
    [james.hogan@imgtec.com: Preserve sort order where it already exists]
    Signed-off-by: James Hogan <james.hogan@imgtec.com>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 58fca9ad5fcc..df7acea3747a 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -19,7 +19,6 @@
 
 #include <linux/init.h>
 #include <linux/types.h>
-#include <linux/module.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
 #include <linux/platform_device.h>

commit 807249d3ada1ff28a47c4054ca4edd479421b671
Merge: ff474e8ca854 2db97045aa40
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Sep 3 16:55:55 2015 -0700

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
     "This is the main pull request for 4.3 for MIPS.  Here's the summary:
    
      Three fixes that didn't make 4.2-stable:
    
       - a -Os build might compile the kernel using the MIPS16 instruction
         set but the R2 optimized inline functions in <uapi/asm/swab.h> are
         implemented using 32-bit wide instructions which is invalid.
    
       - a build error in pgtable-bits.h for a particular kernel
         configuration.
    
       - accessing registers of the CM GCR might have been compiled to use
         64 bit accesses but these registers are onl 32 bit wide.
    
      And also a few new bits:
    
       - move the ATH79 GPIO driver to drivers/gpio
    
       - the definition of IRQCHIP_DECLARE has moved to linux/irqchip.h,
         change ATH79 accordingly.
    
       - fix definition of pgprot_writecombine
    
       - add an implementation of dma_map_ops.mmap
    
       - fix alignment of quiet build output for vmlinuz link
    
       - BCM47xx: Use kmemdup rather than duplicating its implementation
    
       - Netlogic: Fix 0x0x prefixes of constants.
    
       - merge Bjorn Helgaas' series to remove most of the weak keywords
         from function declarations.
    
       - CP0 and CP1 registers are best considered treated as unsigned
         values to avoid large values from becoming negative values.
    
       - improve support for the MIPS GIC timer.
    
       - enable common clock framework for Malta and SEAD3.
    
       - a number of improvments and fixes to dump_tlb().
    
       - document the MIPS TLB dump functionality in Magic SysRq.
    
       - Cavium Octeon CN68XX improvments.
    
       - NetLogic improvments.
    
       - irq: Use access helper irq_data_get_affinity_mask.
    
       - handle MSA unaligned accesses.
    
       - a number of R6-related math-emu fixes.
    
       - support for I6400.
    
       - improvments to MSA support.
    
       - add uprobes support.
    
       - move from deprecated __initcall to arch_initcall.
    
       - remove finish_arch_switch().
    
       - IRQ cleanups by Thomas Gleixner.
    
       - migrate to new 'set-state' interface.
    
       - random small cleanups"
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (148 commits)
      MIPS: UAPI: Fix unrecognized opcode WSBH/DSBH/DSHD when using MIPS16.
      MIPS: Fix alignment of quiet build output for vmlinuz link
      MIPS: math-emu: Remove unused handle_dsemul function declaration
      MIPS: math-emu: Add support for the MIPS R6 MAX{, A} FPU instruction
      MIPS: math-emu: Add support for the MIPS R6 MIN{, A} FPU instruction
      MIPS: math-emu: Add support for the MIPS R6 CLASS FPU instruction
      MIPS: math-emu: Add support for the MIPS R6 RINT FPU instruction
      MIPS: math-emu: Add support for the MIPS R6 MSUBF FPU instruction
      MIPS: math-emu: Add support for the MIPS R6 MADDF FPU instruction
      MIPS: math-emu: Add support for the MIPS R6 SELNEZ FPU instruction
      MIPS: math-emu: Add support for the MIPS R6 SELEQZ FPU instruction
      MIPS: math-emu: Add support for the CMP.condn.fmt R6 instruction
      MIPS: inst.h: Add new MIPS R6 FPU opcodes
      MIPS: Octeon: Fix management port MII address on Kontron S1901
      MIPS: BCM47xx: Use kmemdup rather than duplicating its implementation
      STAGING: Octeon: Use common helpers for determining interface and port
      MIPS: Octeon: Support interfaces 4 and 5
      MIPS: Octeon: Set up 1:1 mapping between CN68XX PKO queues and ports
      MIPS: Octeon: Initialize CN68XX PKO
      STAGING: Octeon: Support CN68XX style WQE
      ...

commit 832f5dacfa0bb081a3b3b979a36a132b28ffacf3
Author: Alban Bedel <albeu@free.fr>
Date:   Sun Aug 2 18:30:11 2015 +0200

    MIPS: Remove all the uses of custom gpio.h
    
    Currently CONFIG_ARCH_HAVE_CUSTOM_GPIO_H is defined for all MIPS
    machines, and each machine type provides its own gpio.h. However
    only a handful really implement the GPIO API, most just forward
    everythings to gpiolib.
    
    The Alchemy machine is notable as it provides a system to allow
    implementing the GPIO API at the board level. But it is not used by
    any board currently supported, so it can also be removed.
    
    For most machine types we can just remove the custom gpio.h, as well
    as the custom wrappers if some exists. Some of the code found in
    the wrappers must be moved to the respective GPIO driver.
    
    A few more fixes are need in some drivers as they rely on linux/gpio.h
    to provides some machine specific definitions, or used asm/gpio.h
    instead of linux/gpio.h for the gpio API.
    
    Signed-off-by: Alban Bedel <albeu@free.fr>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: Hauke Mehrtens <hauke@hauke-m.de>
    Cc: Rafał Miłecki <zajec5@gmail.com>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Daniel Walter <dwalter@google.com>
    Cc: Sergey Ryazanov <ryazanov.s.a@gmail.com>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: James Hartley <james.hartley@imgtec.com>
    Cc: Andrew Bresticker <abrestic@chromium.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Wolfram Sang <wsa@the-dreams.de>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Varka Bhadram <varkabhadram@gmail.com>
    Cc: Masanari Iida <standby24x7@gmail.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Michael Buesch <m@bues.ch>
    Cc: abdoulaye berthe <berthe.ab@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-ide@vger.kernel.org
    Cc: linux-gpio@vger.kernel.org
    Cc: linux-input@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/10828/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index be9ff1673ded..462a252ea6e6 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -39,7 +39,6 @@
 
 #include <asm/addrspace.h>
 #include <asm/mach-ar7/ar7.h>
-#include <asm/mach-ar7/gpio.h>
 #include <asm/mach-ar7/prom.h>
 
 /*****************************************************************************

commit a5597008dbc230876db2d344561d634f4d52ea4a
Author: Andrew Lunn <andrew@lunn.ch>
Date:   Mon Aug 31 15:56:53 2015 +0200

    phy: fixed_phy: Add gpio to determine link up/down.
    
    An SFP module may have a link up/down status pin which can be
    connection to a GPIO line of the host. Add support for reading such an
    GPIO in the fixed_phy driver.
    
    Signed-off-by: Andrew Lunn <andrew@lunn.ch>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index be9ff1673ded..298b97715d5f 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -679,7 +679,8 @@ static int __init ar7_register_devices(void)
 	}
 
 	if (ar7_has_high_cpmac()) {
-		res = fixed_phy_add(PHY_POLL, cpmac_high.id, &fixed_phy_status);
+		res = fixed_phy_add(PHY_POLL, cpmac_high.id,
+				    &fixed_phy_status, -1);
 		if (!res) {
 			cpmac_get_mac(1, cpmac_high_data.dev_addr);
 
@@ -692,7 +693,7 @@ static int __init ar7_register_devices(void)
 	} else
 		cpmac_low_data.phy_mask = 0xffffffff;
 
-	res = fixed_phy_add(PHY_POLL, cpmac_low.id, &fixed_phy_status);
+	res = fixed_phy_add(PHY_POLL, cpmac_low.id, &fixed_phy_status, -1);
 	if (!res) {
 		cpmac_get_mac(0, cpmac_low_data.dev_addr);
 		res = platform_device_register(&cpmac_low);

commit 5db7ccdc9f685fd742cc32efe58aa0c036f380b9
Author: Daniel Walter <dwalter@google.com>
Date:   Tue Jun 24 16:39:59 2014 +0100

    MIPS: AR7: Replace mac address parsing
    
    Replace sscanf() with mac_pton().
    
    [ralf@linux-mips.org: Resolved conflict.]
    
    Signed-off-by: Daniel Walter <dwalter@google.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/7151/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index af2441dbfc12..be9ff1673ded 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -307,10 +307,7 @@ static void __init cpmac_get_mac(int instance, unsigned char *dev_addr)
 	}
 
 	if (mac) {
-		if (sscanf(mac, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
-					&dev_addr[0], &dev_addr[1],
-					&dev_addr[2], &dev_addr[3],
-					&dev_addr[4], &dev_addr[5]) != 6) {
+		if (!mac_pton(mac, dev_addr)) {
 			pr_warn("cannot parse mac address, using random address\n");
 			eth_random_addr(dev_addr);
 		}

commit 7178d2cdd9f5f70902dd0201ebcf01c9489c4afb
Author: Joe Perches <joe@perches.com>
Date:   Sat Oct 4 09:50:42 2014 -0700

    mips: Convert pr_warning to pr_warn
    
    Use the much more common pr_warn instead of pr_warning
    with the goal of removing pr_warning eventually.
    
    Other miscellanea:
    
    o Coalesce formats
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: linux-mips <linux-mips@linux-mips.org>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7935/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 7e2356fd5fd6..af2441dbfc12 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -311,8 +311,7 @@ static void __init cpmac_get_mac(int instance, unsigned char *dev_addr)
 					&dev_addr[0], &dev_addr[1],
 					&dev_addr[2], &dev_addr[3],
 					&dev_addr[4], &dev_addr[5]) != 6) {
-			pr_warning("cannot parse mac address, "
-					"using random address\n");
+			pr_warn("cannot parse mac address, using random address\n");
 			eth_random_addr(dev_addr);
 		}
 	} else
@@ -665,7 +664,7 @@ static int __init ar7_register_devices(void)
 
 	res = platform_device_register(&physmap_flash);
 	if (res)
-		pr_warning("unable to register physmap-flash: %d\n", res);
+		pr_warn("unable to register physmap-flash: %d\n", res);
 
 	if (ar7_is_titan())
 		titan_fixup_devices();
@@ -673,13 +672,13 @@ static int __init ar7_register_devices(void)
 	ar7_device_disable(vlynq_low_data.reset_bit);
 	res = platform_device_register(&vlynq_low);
 	if (res)
-		pr_warning("unable to register vlynq-low: %d\n", res);
+		pr_warn("unable to register vlynq-low: %d\n", res);
 
 	if (ar7_has_high_vlynq()) {
 		ar7_device_disable(vlynq_high_data.reset_bit);
 		res = platform_device_register(&vlynq_high);
 		if (res)
-			pr_warning("unable to register vlynq-high: %d\n", res);
+			pr_warn("unable to register vlynq-high: %d\n", res);
 	}
 
 	if (ar7_has_high_cpmac()) {
@@ -689,9 +688,10 @@ static int __init ar7_register_devices(void)
 
 			res = platform_device_register(&cpmac_high);
 			if (res)
-				pr_warning("unable to register cpmac-high: %d\n", res);
+				pr_warn("unable to register cpmac-high: %d\n",
+					res);
 		} else
-			pr_warning("unable to add cpmac-high phy: %d\n", res);
+			pr_warn("unable to add cpmac-high phy: %d\n", res);
 	} else
 		cpmac_low_data.phy_mask = 0xffffffff;
 
@@ -700,18 +700,18 @@ static int __init ar7_register_devices(void)
 		cpmac_get_mac(0, cpmac_low_data.dev_addr);
 		res = platform_device_register(&cpmac_low);
 		if (res)
-			pr_warning("unable to register cpmac-low: %d\n", res);
+			pr_warn("unable to register cpmac-low: %d\n", res);
 	} else
-		pr_warning("unable to add cpmac-low phy: %d\n", res);
+		pr_warn("unable to add cpmac-low phy: %d\n", res);
 
 	detect_leds();
 	res = platform_device_register(&ar7_gpio_leds);
 	if (res)
-		pr_warning("unable to register leds: %d\n", res);
+		pr_warn("unable to register leds: %d\n", res);
 
 	res = platform_device_register(&ar7_udc);
 	if (res)
-		pr_warning("unable to register usb slave: %d\n", res);
+		pr_warn("unable to register usb slave: %d\n", res);
 
 	/* Register watchdog only if enabled in hardware */
 	bootcr = ioremap_nocache(AR7_REGS_DCL, 4);
@@ -726,7 +726,7 @@ static int __init ar7_register_devices(void)
 		ar7_wdt_res.end = ar7_wdt_res.start + 0x20;
 		res = platform_device_register(&ar7_wdt);
 		if (res)
-			pr_warning("unable to register watchdog: %d\n", res);
+			pr_warn("unable to register watchdog: %d\n", res);
 	}
 
 	return 0;

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 7477fd2127ad..7e2356fd5fd6 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -492,11 +492,11 @@ static struct gpio_led gt701_leds[] = {
 		.active_low		= 1,
 		.default_trigger	= "default-on",
 	},
-        {
-                .name                   = "ethernet",
-                .gpio                   = 10,
-                .active_low             = 1,
-        },
+	{
+		.name			= "ethernet",
+		.gpio			= 10,
+		.active_low		= 1,
+	},
 };
 
 static struct gpio_led_platform_data ar7_led_data;
@@ -512,7 +512,7 @@ static void __init detect_leds(void)
 {
 	char *prid, *usb_prod;
 
-	/* Default LEDs	*/
+	/* Default LEDs */
 	ar7_led_data.num_leds = ARRAY_SIZE(default_leds);
 	ar7_led_data.leds = default_leds;
 

commit dcb96a4e36425d563cefd44a20d3386e02a547f3
Author: Florian Fainelli <florian@openwrt.org>
Date:   Tue Nov 27 22:19:58 2012 +0100

    MIPS: AR7: use part_probe_types to specificy the partition parser to use
    
    This patch changes the physmap-flash platform data on AR7 to pass the
    correct partition parser: ar7part to used by the "physmap-flash" mapping
    driver so we get the partitions probed correctly.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Cc: blogic@openwrt.org
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/4654/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 1bbc24b08685..7477fd2127ad 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -202,8 +202,11 @@ static struct resource physmap_flash_resource = {
 	.end	= 0x107fffff,
 };
 
+static const char *ar7_probe_types[] = { "ar7part", NULL };
+
 static struct physmap_flash_data physmap_flash_data = {
 	.width	= 2,
+	.part_probe_types = ar7_probe_types,
 };
 
 static struct platform_device physmap_flash = {

commit 6e5928f6dfd92a47c489bb735c4cb8bbb62038e0
Author: Joe Perches <joe@perches.com>
Date:   Thu Jul 12 22:33:12 2012 -0700

    arch: Use eth_random_addr
    
    Convert the existing uses of random_ether_addr to
    the new eth_random_addr.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 1a24d317e7a3..1bbc24b08685 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -310,10 +310,10 @@ static void __init cpmac_get_mac(int instance, unsigned char *dev_addr)
 					&dev_addr[4], &dev_addr[5]) != 6) {
 			pr_warning("cannot parse mac address, "
 					"using random address\n");
-			random_ether_addr(dev_addr);
+			eth_random_addr(dev_addr);
 		}
 	} else
-		random_ether_addr(dev_addr);
+		eth_random_addr(dev_addr);
 }
 
 /*****************************************************************************

commit 7bf6612e8a9d6a0b3b82e8e2611942be1258b307
Merge: 7a5c3b8c5c27 f77138e8d53a b606d5ae905f b15a6d62b548 df0ac8a40671 876f1166189b d7a887a73dec 6457a396bbc2 5611cc4572e8 ff5d7265cfb8 b3ea581834c1
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Jan 11 15:42:31 2012 +0100

    Merge branches 'next/ar7', 'next/ath79', 'next/bcm63xx', 'next/bmips', 'next/cavium', 'next/generic', 'next/kprobes', 'next/lantiq', 'next/perf' and 'next/raza' into mips-for-linux-next

commit f77138e8d53a7a4a539f8d931107991d91727afd
Author: Florian Fainelli <florian@openwrt.org>
Date:   Tue Nov 15 20:23:44 2011 +0100

    MIPS: AR7: add LEDs layout for the Actiontec GT701 router
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2981/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 33ffecf6a6d6..e5f6fca690e1 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -462,6 +462,40 @@ static struct gpio_led fb_fon_leds[] = {
 	},
 };
 
+static struct gpio_led gt701_leds[] = {
+	{
+		.name			= "inet:green",
+		.gpio			= 13,
+		.active_low		= 1,
+	},
+	{
+		.name			= "usb",
+		.gpio			= 12,
+		.active_low		= 1,
+	},
+	{
+		.name			= "inet:red",
+		.gpio			= 9,
+		.active_low		= 1,
+	},
+	{
+		.name			= "power:red",
+		.gpio			= 7,
+		.active_low		= 1,
+	},
+	{
+		.name			= "power:green",
+		.gpio			= 8,
+		.active_low		= 1,
+		.default_trigger	= "default-on",
+	},
+        {
+                .name                   = "ethernet",
+                .gpio                   = 10,
+                .active_low             = 1,
+        },
+};
+
 static struct gpio_led_platform_data ar7_led_data;
 
 static struct platform_device ar7_gpio_leds = {
@@ -503,6 +537,9 @@ static void __init detect_leds(void)
 	} else if (strstr(prid, "CYWM") || strstr(prid, "CYWL")) {
 		ar7_led_data.num_leds = ARRAY_SIZE(titan_leds);
 		ar7_led_data.leds = titan_leds;
+	} else if (strstr(prid, "GT701")) {
+		ar7_led_data.num_leds = ARRAY_SIZE(gt701_leds);
+		ar7_led_data.leds = gt701_leds;
 	}
 }
 

commit ab75dc02c151c9d2a2fd446334d740b097a3b9db
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Nov 17 15:07:31 2011 +0000

    MIPS: Fix up inconsistency in panic() string argument.
    
    Panic() invokes printk() to add a \n internally, so panic arguments should
    not themselves end in \n.  Panic invocations in arch/mips and elsewhere
    are inconsistently sometimes terminating in \n, sometimes not.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 33ffecf6a6d6..60102392af01 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -536,7 +536,7 @@ static int __init ar7_register_uarts(void)
 
 	bus_clk = clk_get(NULL, "bus");
 	if (IS_ERR(bus_clk))
-		panic("unable to get bus clk\n");
+		panic("unable to get bus clk");
 
 	uart_port.type		= PORT_AR7;
 	uart_port.uartclk	= clk_get_rate(bus_clk) / 2;

commit 11454100f41f43f128da02c0235ac85636a2cf70
Author: Florian Fainelli <florian@openwrt.org>
Date:   Sun Jun 12 20:57:18 2011 +0200

    MIPS: AR7: Remove 'space before tabs' in platform.c
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    To: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2490/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 7d2fab392327..33ffecf6a6d6 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -229,7 +229,7 @@ static struct resource cpmac_low_res[] = {
 		.name	= "irq",
 		.flags	= IORESOURCE_IRQ,
 		.start	= 27,
-		.end 	= 27,
+		.end	= 27,
 	},
 };
 

commit 238dd317f74250983aefbde6dc0a1f345a717993
Author: Florian Fainelli <florian@openwrt.org>
Date:   Sun Aug 29 17:08:44 2010 +0200

    MIPS: AR7: Add support for Titan (TNETV10xx) SoC variant
    
    Add support for Titan TNETV1050,1055,1056,1060 variants. This SoC is almost
    completely identical to AR7 except on a few points:
    - a second bank of gpios is available
    - vlynq0 on titan is vlynq1 on ar7
    - different PHY addresses for cpmac0
    
    This SoC can be found on commercial products like the Linksys WRTP54G
    
    Original patch by Xin with improvments by Florian.
    
    Signed-off-by: Xin Zhen <xlonestar2000@aim.com>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/1563/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
    ---

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 0da5b2b8dd88..7d2fab392327 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -357,6 +357,11 @@ static struct gpio_led default_leds[] = {
 	},
 };
 
+static struct gpio_led titan_leds[] = {
+	{ .name = "status", .gpio = 8, .active_low = 1, },
+	{ .name = "wifi", .gpio = 13, .active_low = 1, },
+};
+
 static struct gpio_led dsl502t_leds[] = {
 	{
 		.name			= "status",
@@ -495,6 +500,9 @@ static void __init detect_leds(void)
 	} else if (strstr(prid, "DG834")) {
 		ar7_led_data.num_leds = ARRAY_SIZE(dg834g_leds);
 		ar7_led_data.leds = dg834g_leds;
+	} else if (strstr(prid, "CYWM") || strstr(prid, "CYWL")) {
+		ar7_led_data.num_leds = ARRAY_SIZE(titan_leds);
+		ar7_led_data.leds = titan_leds;
 	}
 }
 
@@ -560,6 +568,51 @@ static int __init ar7_register_uarts(void)
 	return 0;
 }
 
+static void __init titan_fixup_devices(void)
+{
+	/* Set vlynq0 data */
+	vlynq_low_data.reset_bit = 15;
+	vlynq_low_data.gpio_bit = 14;
+
+	/* Set vlynq1 data */
+	vlynq_high_data.reset_bit = 16;
+	vlynq_high_data.gpio_bit = 7;
+
+	/* Set vlynq0 resources */
+	vlynq_low_res[0].start = TITAN_REGS_VLYNQ0;
+	vlynq_low_res[0].end = TITAN_REGS_VLYNQ0 + 0xff;
+	vlynq_low_res[1].start = 33;
+	vlynq_low_res[1].end = 33;
+	vlynq_low_res[2].start = 0x0c000000;
+	vlynq_low_res[2].end = 0x0fffffff;
+	vlynq_low_res[3].start = 80;
+	vlynq_low_res[3].end = 111;
+
+	/* Set vlynq1 resources */
+	vlynq_high_res[0].start = TITAN_REGS_VLYNQ1;
+	vlynq_high_res[0].end = TITAN_REGS_VLYNQ1 + 0xff;
+	vlynq_high_res[1].start = 34;
+	vlynq_high_res[1].end = 34;
+	vlynq_high_res[2].start = 0x40000000;
+	vlynq_high_res[2].end = 0x43ffffff;
+	vlynq_high_res[3].start = 112;
+	vlynq_high_res[3].end = 143;
+
+	/* Set cpmac0 data */
+	cpmac_low_data.phy_mask = 0x40000000;
+
+	/* Set cpmac1 data */
+	cpmac_high_data.phy_mask = 0x80000000;
+
+	/* Set cpmac0 resources */
+	cpmac_low_res[0].start = TITAN_REGS_MAC0;
+	cpmac_low_res[0].end = TITAN_REGS_MAC0 + 0x7ff;
+
+	/* Set cpmac1 resources */
+	cpmac_high_res[0].start = TITAN_REGS_MAC1;
+	cpmac_high_res[0].end = TITAN_REGS_MAC1 + 0x7ff;
+}
+
 static int __init ar7_register_devices(void)
 {
 	void __iomem *bootcr;
@@ -574,6 +627,9 @@ static int __init ar7_register_devices(void)
 	if (res)
 		pr_warning("unable to register physmap-flash: %d\n", res);
 
+	if (ar7_is_titan())
+		titan_fixup_devices();
+
 	ar7_device_disable(vlynq_low_data.reset_bit);
 	res = platform_device_register(&vlynq_low);
 	if (res)

commit d16f7093b6eb4f3859856f6ee4ab504cbeeea0b9
Author: Alexander Clouter <alex@digriz.org.uk>
Date:   Mon Jul 5 21:11:26 2010 +0100

    MIPS: AR7: rewrite of cpmac_get_mac()
    
    Shamelessly stealing wisdom from pasemi_mac.c, I found char2hex() could
    be replaced with a single call to sscanf(), looks cleaner to me at
    least.  The result is 100 bytes trimmed off the size of a compiled
    cpmac_get_mac() and as an extra bonus it grumbles and gracefully fails
    over to using random_ether_addr() when an attempt to parse an invalid
    MAC address is made.
    
    Signed-off-by: Alexander Clouter <alex@digriz.org.uk>
    To: linux-mips@linux-mips.org
    Cc: florian@openwrt.org
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 8f31d1d59683..0da5b2b8dd88 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -292,40 +292,28 @@ static struct platform_device cpmac_high = {
 	.num_resources	= ARRAY_SIZE(cpmac_high_res),
 };
 
-static inline unsigned char char2hex(char h)
+static void __init cpmac_get_mac(int instance, unsigned char *dev_addr)
 {
-	switch (h) {
-	case '0': case '1': case '2': case '3': case '4':
-	case '5': case '6': case '7': case '8': case '9':
-		return h - '0';
-	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
-		return h - 'A' + 10;
-	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
-		return h - 'a' + 10;
-	default:
-		return 0;
-	}
-}
-
-static void cpmac_get_mac(int instance, unsigned char *dev_addr)
-{
-	int i;
-	char name[5], default_mac[ETH_ALEN], *mac;
+	char name[5], *mac;
 
-	mac = NULL;
 	sprintf(name, "mac%c", 'a' + instance);
 	mac = prom_getenv(name);
-	if (!mac) {
+	if (!mac && instance) {
 		sprintf(name, "mac%c", 'a');
 		mac = prom_getenv(name);
 	}
-	if (!mac) {
-		random_ether_addr(default_mac);
-		mac = default_mac;
-	}
-	for (i = 0; i < 6; i++)
-		dev_addr[i] = (char2hex(mac[i * 3]) << 4) +
-			char2hex(mac[i * 3 + 1]);
+
+	if (mac) {
+		if (sscanf(mac, "%hhx:%hhx:%hhx:%hhx:%hhx:%hhx",
+					&dev_addr[0], &dev_addr[1],
+					&dev_addr[2], &dev_addr[3],
+					&dev_addr[4], &dev_addr[5]) != 6) {
+			pr_warning("cannot parse mac address, "
+					"using random address\n");
+			random_ether_addr(dev_addr);
+		}
+	} else
+		random_ether_addr(dev_addr);
 }
 
 /*****************************************************************************

commit 154615d554596d96dd2b29bba4116fa21770fdc0
Author: Florian Fainelli <florian@openwrt.org>
Date:   Sun May 16 15:25:17 2010 +0200

    MIPS: AR7: Use correct UART port type
    
    PORT_AR7 has the correct TRIG flag (UART_FCR_R_TRIG_00) as well as
    UART_CAP_AFE being set. This fixes UART on TNETD7300 revision 0x02,
    which would otherwise mangle some characters, no side effects on
    other revisions.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/1246/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 566f2d7f2ea3..8f31d1d59683 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -542,7 +542,7 @@ static int __init ar7_register_uarts(void)
 	if (IS_ERR(bus_clk))
 		panic("unable to get bus clk\n");
 
-	uart_port.type		= PORT_16550A;
+	uart_port.type		= PORT_AR7;
 	uart_port.uartclk	= clk_get_rate(bus_clk) / 2;
 	uart_port.iotype	= UPIO_MEM32;
 	uart_port.regshift	= 2;

commit 142a2ceea793b4d134757c226daeb4101d649df0
Author: Florian Fainelli <florian@openwrt.org>
Date:   Tue May 11 11:20:14 2010 +0200

    MIPS: AR7: prevent race between clock initialization and devices registration
    
    ar7_regiser_devices needs ar7_clocks_init to have been called first,
    however clock.o is currently linked later due to its order in the Makefile,
    therefore ar7_clocks_init always gets called later than ar7_register_devices
    because both have the same initcall level. Fix this by moving
    ar7_register_devices to the right initcall level.
    
    Reported-by: Michael J. Evans <mjevans1983@gmail.com>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    To: linux-mips@linux-mips.org
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Patchwork: http://patchwork.linux-mips.org/patch/1212/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 1d4a466ccb6f..566f2d7f2ea3 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -647,4 +647,4 @@ static int __init ar7_register_devices(void)
 
 	return 0;
 }
-arch_initcall(ar7_register_devices);
+device_initcall(ar7_register_devices);

commit 9c1b013a3951671e219c32ca056fc07381a9e113
Author: Florian Fainelli <florian@openwrt.org>
Date:   Tue May 11 11:20:09 2010 +0200

    MIPS: AR7: use ar7_has_high_vlynq() to determine watchdog base address
    
    Instead of doing yet another switch/case on the chip_id, use existing
    inline function to set the watchdog base address.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/1211/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 2fafc78e5ce1..1d4a466ccb6f 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -576,7 +576,6 @@ static int __init ar7_register_devices(void)
 {
 	void __iomem *bootcr;
 	u32 val;
-	u16 chip_id;
 	int res;
 
 	res = ar7_register_uarts();
@@ -635,18 +634,10 @@ static int __init ar7_register_devices(void)
 	val = readl(bootcr);
 	iounmap(bootcr);
 	if (val & AR7_WDT_HW_ENA) {
-		chip_id = ar7_chip_id();
-		switch (chip_id) {
-		case AR7_CHIP_7100:
-		case AR7_CHIP_7200:
-			ar7_wdt_res.start = AR7_REGS_WDT;
-			break;
-		case AR7_CHIP_7300:
+		if (ar7_has_high_vlynq())
 			ar7_wdt_res.start = UR8_REGS_WDT;
-			break;
-		default:
-			break;
-		}
+		else
+			ar7_wdt_res.start = AR7_REGS_WDT;
 
 		ar7_wdt_res.end = ar7_wdt_res.start + 0x20;
 		res = platform_device_register(&ar7_wdt);

commit 727c0075c80005e2012be113a91e5976abec4f9d
Author: Alexander Clouter <alex@digriz.org.uk>
Date:   Sat Mar 13 00:09:15 2010 +0000

    MIPS: AR7: Fix phat finger of cpmac fixed_phy_add
    
    Seems I trimmed one too many lines in
    29ca2d81bd2a62fa86bc9a72ddadcf03d7daf795 (lmo) rsp
    7084338eb8eb0cc021ba86c340157bad397f3f0b (kernel.org) which led to no
    functioning Ethernet on my WAG54Gv2.  This patch restores the AWOL line.
    
    Signed-off-by: Alexander Clouter <alex@digriz.org.uk>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/1065/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 0bd5f67320be..2fafc78e5ce1 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -600,6 +600,7 @@ static int __init ar7_register_devices(void)
 	}
 
 	if (ar7_has_high_cpmac()) {
+		res = fixed_phy_add(PHY_POLL, cpmac_high.id, &fixed_phy_status);
 		if (!res) {
 			cpmac_get_mac(1, cpmac_high_data.dev_addr);
 

commit 1e3fb3778be3c0a56626eba4a84f7d2fa991aa93
Author: Alexander Clouter <alex@digriz.org.uk>
Date:   Fri Mar 12 19:39:48 2010 +0000

    MIPS: AR7: Fix phat finger of reset bit in vlynq_high_data
    
    Seems in my whitespace cleanup 0f2536082d01448daeced8d9e82c3ba1751fefa3
    (lmo) rsp.  8c2961da46abd85a71d20f2b169bf80618e (kernel.org) caused AR7
    to no longer get as far as init.  Fixed my phat fingering.
    
    Signed-off-by: Alexander Clouter <alex@digriz.org.uk>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/1064/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 246df7aca2e7..0bd5f67320be 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -168,7 +168,7 @@ static struct plat_vlynq_data vlynq_high_data = {
 		.on	= vlynq_on,
 		.off	= vlynq_off,
 	},
-	.reset_bit	= 26,
+	.reset_bit	= 16,
 	.gpio_bit	= 19,
 };
 

commit 7084338eb8eb0cc021ba86c340157bad397f3f0b
Author: Alexander Clouter <alex@digriz.org.uk>
Date:   Sun Jan 31 19:39:57 2010 +0000

    MIPS: AR7: Make ar7_register_devices much more durable
    
    [Ralf: Fixed up the rejects and changed all the new printk(KERN_...); to
    pr_xxx() as suggested by Wu.]
    
    Signed-off-by: Alexander Clouter <alex@digriz.org.uk>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/920/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 65facecb3ffb..246df7aca2e7 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -529,115 +529,130 @@ static struct platform_device ar7_wdt = {
 /*****************************************************************************
  * Init
  ****************************************************************************/
-static int __init ar7_register_devices(void)
+static int __init ar7_register_uarts(void)
 {
-	u16 chip_id;
-	int res;
-	u32 *bootcr, val;
 #ifdef CONFIG_SERIAL_8250
-	static struct uart_port uart_port[2] __initdata;
+	static struct uart_port uart_port __initdata;
 	struct clk *bus_clk;
+	int res;
 
-	memset(uart_port, 0, sizeof(struct uart_port) * 2);
+	memset(&uart_port, 0, sizeof(struct uart_port));
 
 	bus_clk = clk_get(NULL, "bus");
 	if (IS_ERR(bus_clk))
 		panic("unable to get bus clk\n");
 
-	uart_port[0].type	= PORT_16550A;
-	uart_port[0].line	= 0;
-	uart_port[0].irq	= AR7_IRQ_UART0;
-	uart_port[0].uartclk	= clk_get_rate(bus_clk) / 2;
-	uart_port[0].iotype	= UPIO_MEM32;
-	uart_port[0].mapbase	= AR7_REGS_UART0;
-	uart_port[0].membase	= ioremap(uart_port[0].mapbase, 256);
-	uart_port[0].regshift	= 2;
-	res = early_serial_setup(&uart_port[0]);
+	uart_port.type		= PORT_16550A;
+	uart_port.uartclk	= clk_get_rate(bus_clk) / 2;
+	uart_port.iotype	= UPIO_MEM32;
+	uart_port.regshift	= 2;
+
+	uart_port.line		= 0;
+	uart_port.irq		= AR7_IRQ_UART0;
+	uart_port.mapbase	= AR7_REGS_UART0;
+	uart_port.membase	= ioremap(uart_port.mapbase, 256);
+
+	res = early_serial_setup(&uart_port);
 	if (res)
 		return res;
 
 	/* Only TNETD73xx have a second serial port */
 	if (ar7_has_second_uart()) {
-		uart_port[1].type	= PORT_16550A;
-		uart_port[1].line	= 1;
-		uart_port[1].irq	= AR7_IRQ_UART1;
-		uart_port[1].uartclk	= clk_get_rate(bus_clk) / 2;
-		uart_port[1].iotype	= UPIO_MEM32;
-		uart_port[1].mapbase	= UR8_REGS_UART1;
-		uart_port[1].membase 	= ioremap(uart_port[1].mapbase, 256);
-		uart_port[1].regshift	= 2;
-		res = early_serial_setup(&uart_port[1]);
+		uart_port.line		= 1;
+		uart_port.irq		= AR7_IRQ_UART1;
+		uart_port.mapbase	= UR8_REGS_UART1;
+		uart_port.membase	= ioremap(uart_port.mapbase, 256);
+
+		res = early_serial_setup(&uart_port);
 		if (res)
 			return res;
 	}
-#endif /* CONFIG_SERIAL_8250 */
+#endif
+
+	return 0;
+}
+
+static int __init ar7_register_devices(void)
+{
+	void __iomem *bootcr;
+	u32 val;
+	u16 chip_id;
+	int res;
+
+	res = ar7_register_uarts();
+	if (res)
+		pr_err("unable to setup uart(s): %d\n", res);
+
 	res = platform_device_register(&physmap_flash);
 	if (res)
-		return res;
+		pr_warning("unable to register physmap-flash: %d\n", res);
 
 	ar7_device_disable(vlynq_low_data.reset_bit);
 	res = platform_device_register(&vlynq_low);
 	if (res)
-		return res;
+		pr_warning("unable to register vlynq-low: %d\n", res);
 
 	if (ar7_has_high_vlynq()) {
 		ar7_device_disable(vlynq_high_data.reset_bit);
 		res = platform_device_register(&vlynq_high);
 		if (res)
-			return res;
+			pr_warning("unable to register vlynq-high: %d\n", res);
 	}
 
 	if (ar7_has_high_cpmac()) {
-		res = fixed_phy_add(PHY_POLL, cpmac_high.id, &fixed_phy_status);
-		if (res && res != -ENODEV)
-			return res;
-		cpmac_get_mac(1, cpmac_high_data.dev_addr);
-		res = platform_device_register(&cpmac_high);
-		if (res)
-			return res;
-	} else {
+		if (!res) {
+			cpmac_get_mac(1, cpmac_high_data.dev_addr);
+
+			res = platform_device_register(&cpmac_high);
+			if (res)
+				pr_warning("unable to register cpmac-high: %d\n", res);
+		} else
+			pr_warning("unable to add cpmac-high phy: %d\n", res);
+	} else
 		cpmac_low_data.phy_mask = 0xffffffff;
-	}
 
 	res = fixed_phy_add(PHY_POLL, cpmac_low.id, &fixed_phy_status);
-	if (res && res != -ENODEV)
-		return res;
-
-	cpmac_get_mac(0, cpmac_low_data.dev_addr);
-	res = platform_device_register(&cpmac_low);
-	if (res)
-		return res;
+	if (!res) {
+		cpmac_get_mac(0, cpmac_low_data.dev_addr);
+		res = platform_device_register(&cpmac_low);
+		if (res)
+			pr_warning("unable to register cpmac-low: %d\n", res);
+	} else
+		pr_warning("unable to add cpmac-low phy: %d\n", res);
 
 	detect_leds();
 	res = platform_device_register(&ar7_gpio_leds);
 	if (res)
-		return res;
+		pr_warning("unable to register leds: %d\n", res);
 
 	res = platform_device_register(&ar7_udc);
-
-	chip_id = ar7_chip_id();
-	switch (chip_id) {
-	case AR7_CHIP_7100:
-	case AR7_CHIP_7200:
-		ar7_wdt_res.start = AR7_REGS_WDT;
-		break;
-	case AR7_CHIP_7300:
-		ar7_wdt_res.start = UR8_REGS_WDT;
-		break;
-	default:
-		break;
-	}
-
-	ar7_wdt_res.end = ar7_wdt_res.start + 0x20;
-
-	bootcr = (u32 *)ioremap_nocache(AR7_REGS_DCL, 4);
-	val = *bootcr;
-	iounmap(bootcr);
+	if (res)
+		pr_warning("unable to register usb slave: %d\n", res);
 
 	/* Register watchdog only if enabled in hardware */
-	if (val & AR7_WDT_HW_ENA)
+	bootcr = ioremap_nocache(AR7_REGS_DCL, 4);
+	val = readl(bootcr);
+	iounmap(bootcr);
+	if (val & AR7_WDT_HW_ENA) {
+		chip_id = ar7_chip_id();
+		switch (chip_id) {
+		case AR7_CHIP_7100:
+		case AR7_CHIP_7200:
+			ar7_wdt_res.start = AR7_REGS_WDT;
+			break;
+		case AR7_CHIP_7300:
+			ar7_wdt_res.start = UR8_REGS_WDT;
+			break;
+		default:
+			break;
+		}
+
+		ar7_wdt_res.end = ar7_wdt_res.start + 0x20;
 		res = platform_device_register(&ar7_wdt);
+		if (res)
+			pr_warning("unable to register watchdog: %d\n", res);
+	}
 
-	return res;
+	return 0;
 }
 arch_initcall(ar7_register_devices);

commit 632b629c0c4b0f8caaf7f2b448911d03859fda59
Author: Alexander Clouter <alex@digriz.org.uk>
Date:   Sun Jan 31 19:38:52 2010 +0000

    MIPS: AR7: Fix USB slave mem range typo
    
    Signed-off-by: Alexander Clouter <alex@digriz.org.uk>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/919/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 76a358ec15f0..65facecb3ffb 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -348,7 +348,7 @@ static struct resource usb_res[] = {
 		.name	= "mem",
 		.flags	= IORESOURCE_MEM,
 		.start	= 0x03400000,
-		.end	= 0x034001fff,
+		.end	= 0x03401fff,
 	},
 };
 

commit 4d1da8c2961da46abd85a71d20f2b169bf80618e
Author: Alexander Clouter <alex@digriz.org.uk>
Date:   Sun Jan 31 19:38:19 2010 +0000

    MIPS: AR7: Whitespace hacking
    
    [Ralf: Fixed up reject and Wu's complaints about comment style.]
    
    Signed-off-by: Alexander Clouter <alex@digriz.org.uk>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/921/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 1db191cd49c3..76a358ec15f0 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -42,39 +42,42 @@
 #include <asm/mach-ar7/gpio.h>
 #include <asm/mach-ar7/prom.h>
 
+/*****************************************************************************
+ * VLYNQ Bus
+ ****************************************************************************/
 struct plat_vlynq_data {
 	struct plat_vlynq_ops ops;
 	int gpio_bit;
 	int reset_bit;
 };
 
-
 static int vlynq_on(struct vlynq_device *dev)
 {
-	int result;
+	int ret;
 	struct plat_vlynq_data *pdata = dev->dev.platform_data;
 
-	result = gpio_request(pdata->gpio_bit, "vlynq");
-	if (result)
+	ret = gpio_request(pdata->gpio_bit, "vlynq");
+	if (ret)
 		goto out;
 
 	ar7_device_reset(pdata->reset_bit);
 
-	result = ar7_gpio_disable(pdata->gpio_bit);
-	if (result)
+	ret = ar7_gpio_disable(pdata->gpio_bit);
+	if (ret)
 		goto out_enabled;
 
-	result = ar7_gpio_enable(pdata->gpio_bit);
-	if (result)
+	ret = ar7_gpio_enable(pdata->gpio_bit);
+	if (ret)
 		goto out_enabled;
 
-	result = gpio_direction_output(pdata->gpio_bit, 0);
-	if (result)
+	ret = gpio_direction_output(pdata->gpio_bit, 0);
+	if (ret)
 		goto out_gpio_enabled;
 
 	msleep(50);
 
 	gpio_set_value(pdata->gpio_bit, 1);
+
 	msleep(50);
 
 	return 0;
@@ -85,320 +88,384 @@ static int vlynq_on(struct vlynq_device *dev)
 	ar7_device_disable(pdata->reset_bit);
 	gpio_free(pdata->gpio_bit);
 out:
-	return result;
+	return ret;
 }
 
 static void vlynq_off(struct vlynq_device *dev)
 {
 	struct plat_vlynq_data *pdata = dev->dev.platform_data;
+
 	ar7_gpio_disable(pdata->gpio_bit);
 	gpio_free(pdata->gpio_bit);
 	ar7_device_disable(pdata->reset_bit);
 }
 
-static struct resource physmap_flash_resource = {
-	.name = "mem",
-	.flags = IORESOURCE_MEM,
-	.start = 0x10000000,
-	.end = 0x107fffff,
-};
-
-static struct resource cpmac_low_res[] = {
+static struct resource vlynq_low_res[] = {
 	{
-		.name = "regs",
-		.flags = IORESOURCE_MEM,
-		.start = AR7_REGS_MAC0,
-		.end = AR7_REGS_MAC0 + 0x7ff,
+		.name	= "regs",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR7_REGS_VLYNQ0,
+		.end	= AR7_REGS_VLYNQ0 + 0xff,
 	},
 	{
-		.name = "irq",
-		.flags = IORESOURCE_IRQ,
-		.start = 27,
-		.end = 27,
+		.name	= "irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= 29,
+		.end	= 29,
 	},
-};
-
-static struct resource cpmac_high_res[] = {
 	{
-		.name = "regs",
-		.flags = IORESOURCE_MEM,
-		.start = AR7_REGS_MAC1,
-		.end = AR7_REGS_MAC1 + 0x7ff,
+		.name	= "mem",
+		.flags	= IORESOURCE_MEM,
+		.start	= 0x04000000,
+		.end	= 0x04ffffff,
 	},
 	{
-		.name = "irq",
-		.flags = IORESOURCE_IRQ,
-		.start = 41,
-		.end = 41,
+		.name	= "devirq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= 80,
+		.end	= 111,
 	},
 };
 
-static struct resource vlynq_low_res[] = {
+static struct resource vlynq_high_res[] = {
 	{
-		.name = "regs",
-		.flags = IORESOURCE_MEM,
-		.start = AR7_REGS_VLYNQ0,
-		.end = AR7_REGS_VLYNQ0 + 0xff,
+		.name	= "regs",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR7_REGS_VLYNQ1,
+		.end	= AR7_REGS_VLYNQ1 + 0xff,
 	},
 	{
-		.name = "irq",
-		.flags = IORESOURCE_IRQ,
-		.start = 29,
-		.end = 29,
+		.name	= "irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= 33,
+		.end	= 33,
 	},
 	{
-		.name = "mem",
-		.flags = IORESOURCE_MEM,
-		.start = 0x04000000,
-		.end = 0x04ffffff,
+		.name	= "mem",
+		.flags	= IORESOURCE_MEM,
+		.start	= 0x0c000000,
+		.end	= 0x0cffffff,
 	},
 	{
-		.name = "devirq",
-		.flags = IORESOURCE_IRQ,
-		.start = 80,
-		.end = 111,
+		.name	= "devirq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= 112,
+		.end	= 143,
 	},
 };
 
-static struct resource vlynq_high_res[] = {
-	{
-		.name = "regs",
-		.flags = IORESOURCE_MEM,
-		.start = AR7_REGS_VLYNQ1,
-		.end = AR7_REGS_VLYNQ1 + 0xff,
+static struct plat_vlynq_data vlynq_low_data = {
+	.ops = {
+		.on	= vlynq_on,
+		.off	= vlynq_off,
 	},
-	{
-		.name = "irq",
-		.flags = IORESOURCE_IRQ,
-		.start = 33,
-		.end = 33,
+	.reset_bit	= 20,
+	.gpio_bit	= 18,
+};
+
+static struct plat_vlynq_data vlynq_high_data = {
+	.ops = {
+		.on	= vlynq_on,
+		.off	= vlynq_off,
 	},
-	{
-		.name = "mem",
-		.flags = IORESOURCE_MEM,
-		.start = 0x0c000000,
-		.end = 0x0cffffff,
+	.reset_bit	= 26,
+	.gpio_bit	= 19,
+};
+
+static struct platform_device vlynq_low = {
+	.id		= 0,
+	.name		= "vlynq",
+	.dev = {
+		.platform_data	= &vlynq_low_data,
 	},
-	{
-		.name = "devirq",
-		.flags = IORESOURCE_IRQ,
-		.start = 112,
-		.end = 143,
+	.resource	= vlynq_low_res,
+	.num_resources	= ARRAY_SIZE(vlynq_low_res),
+};
+
+static struct platform_device vlynq_high = {
+	.id		= 1,
+	.name		= "vlynq",
+	.dev = {
+		.platform_data	= &vlynq_high_data,
 	},
+	.resource	= vlynq_high_res,
+	.num_resources	= ARRAY_SIZE(vlynq_high_res),
 };
 
-static struct resource usb_res[] = {
-	{
-		.name = "regs",
-		.flags = IORESOURCE_MEM,
-		.start = AR7_REGS_USB,
-		.end = AR7_REGS_USB + 0xff,
+/*****************************************************************************
+ * Flash
+ ****************************************************************************/
+static struct resource physmap_flash_resource = {
+	.name	= "mem",
+	.flags	= IORESOURCE_MEM,
+	.start	= 0x10000000,
+	.end	= 0x107fffff,
+};
+
+static struct physmap_flash_data physmap_flash_data = {
+	.width	= 2,
+};
+
+static struct platform_device physmap_flash = {
+	.name		= "physmap-flash",
+	.dev = {
+		.platform_data	= &physmap_flash_data,
 	},
+	.resource	= &physmap_flash_resource,
+	.num_resources	= 1,
+};
+
+/*****************************************************************************
+ * Ethernet
+ ****************************************************************************/
+static struct resource cpmac_low_res[] = {
 	{
-		.name = "irq",
-		.flags = IORESOURCE_IRQ,
-		.start = 32,
-		.end = 32,
+		.name	= "regs",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR7_REGS_MAC0,
+		.end	= AR7_REGS_MAC0 + 0x7ff,
 	},
 	{
-		.name = "mem",
-		.flags = IORESOURCE_MEM,
-		.start = 0x03400000,
-		.end = 0x03401fff,
+		.name	= "irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= 27,
+		.end 	= 27,
 	},
 };
 
-static struct physmap_flash_data physmap_flash_data = {
-	.width = 2,
+static struct resource cpmac_high_res[] = {
+	{
+		.name	= "regs",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR7_REGS_MAC1,
+		.end	= AR7_REGS_MAC1 + 0x7ff,
+	},
+	{
+		.name	= "irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= 41,
+		.end	= 41,
+	},
 };
 
 static struct fixed_phy_status fixed_phy_status __initdata = {
-	.link = 1,
-	.speed = 100,
-	.duplex = 1,
+	.link		= 1,
+	.speed		= 100,
+	.duplex		= 1,
 };
 
 static struct plat_cpmac_data cpmac_low_data = {
-	.reset_bit = 17,
-	.power_bit = 20,
-	.phy_mask = 0x80000000,
+	.reset_bit	= 17,
+	.power_bit	= 20,
+	.phy_mask	= 0x80000000,
 };
 
 static struct plat_cpmac_data cpmac_high_data = {
-	.reset_bit = 21,
-	.power_bit = 22,
-	.phy_mask = 0x7fffffff,
-};
-
-static struct plat_vlynq_data vlynq_low_data = {
-	.ops.on = vlynq_on,
-	.ops.off = vlynq_off,
-	.reset_bit = 20,
-	.gpio_bit = 18,
-};
-
-static struct plat_vlynq_data vlynq_high_data = {
-	.ops.on = vlynq_on,
-	.ops.off = vlynq_off,
-	.reset_bit = 16,
-	.gpio_bit = 19,
-};
-
-static struct platform_device physmap_flash = {
-	.id = 0,
-	.name = "physmap-flash",
-	.dev.platform_data = &physmap_flash_data,
-	.resource = &physmap_flash_resource,
-	.num_resources = 1,
+	.reset_bit	= 21,
+	.power_bit	= 22,
+	.phy_mask	= 0x7fffffff,
 };
 
 static u64 cpmac_dma_mask = DMA_BIT_MASK(32);
+
 static struct platform_device cpmac_low = {
-	.id = 0,
-	.name = "cpmac",
+	.id		= 0,
+	.name		= "cpmac",
 	.dev = {
-		.dma_mask = &cpmac_dma_mask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-		.platform_data = &cpmac_low_data,
+		.dma_mask		= &cpmac_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &cpmac_low_data,
 	},
-	.resource = cpmac_low_res,
-	.num_resources = ARRAY_SIZE(cpmac_low_res),
+	.resource	= cpmac_low_res,
+	.num_resources	= ARRAY_SIZE(cpmac_low_res),
 };
 
 static struct platform_device cpmac_high = {
-	.id = 1,
-	.name = "cpmac",
+	.id		= 1,
+	.name		= "cpmac",
 	.dev = {
-		.dma_mask = &cpmac_dma_mask,
-		.coherent_dma_mask = DMA_BIT_MASK(32),
-		.platform_data = &cpmac_high_data,
+		.dma_mask		= &cpmac_dma_mask,
+		.coherent_dma_mask	= DMA_BIT_MASK(32),
+		.platform_data		= &cpmac_high_data,
 	},
-	.resource = cpmac_high_res,
-	.num_resources = ARRAY_SIZE(cpmac_high_res),
+	.resource	= cpmac_high_res,
+	.num_resources	= ARRAY_SIZE(cpmac_high_res),
 };
 
-static struct platform_device vlynq_low = {
-	.id = 0,
-	.name = "vlynq",
-	.dev.platform_data = &vlynq_low_data,
-	.resource = vlynq_low_res,
-	.num_resources = ARRAY_SIZE(vlynq_low_res),
-};
+static inline unsigned char char2hex(char h)
+{
+	switch (h) {
+	case '0': case '1': case '2': case '3': case '4':
+	case '5': case '6': case '7': case '8': case '9':
+		return h - '0';
+	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+		return h - 'A' + 10;
+	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
+		return h - 'a' + 10;
+	default:
+		return 0;
+	}
+}
 
-static struct platform_device vlynq_high = {
-	.id = 1,
-	.name = "vlynq",
-	.dev.platform_data = &vlynq_high_data,
-	.resource = vlynq_high_res,
-	.num_resources = ARRAY_SIZE(vlynq_high_res),
+static void cpmac_get_mac(int instance, unsigned char *dev_addr)
+{
+	int i;
+	char name[5], default_mac[ETH_ALEN], *mac;
+
+	mac = NULL;
+	sprintf(name, "mac%c", 'a' + instance);
+	mac = prom_getenv(name);
+	if (!mac) {
+		sprintf(name, "mac%c", 'a');
+		mac = prom_getenv(name);
+	}
+	if (!mac) {
+		random_ether_addr(default_mac);
+		mac = default_mac;
+	}
+	for (i = 0; i < 6; i++)
+		dev_addr[i] = (char2hex(mac[i * 3]) << 4) +
+			char2hex(mac[i * 3 + 1]);
+}
+
+/*****************************************************************************
+ * USB
+ ****************************************************************************/
+static struct resource usb_res[] = {
+	{
+		.name	= "regs",
+		.flags	= IORESOURCE_MEM,
+		.start	= AR7_REGS_USB,
+		.end	= AR7_REGS_USB + 0xff,
+	},
+	{
+		.name	= "irq",
+		.flags	= IORESOURCE_IRQ,
+		.start	= 32,
+		.end	= 32,
+	},
+	{
+		.name	= "mem",
+		.flags	= IORESOURCE_MEM,
+		.start	= 0x03400000,
+		.end	= 0x034001fff,
+	},
 };
 
+static struct platform_device ar7_udc = {
+	.name		= "ar7_udc",
+	.resource	= usb_res,
+	.num_resources	= ARRAY_SIZE(usb_res),
+};
 
+/*****************************************************************************
+ * LEDs
+ ****************************************************************************/
 static struct gpio_led default_leds[] = {
 	{
-		.name = "status",
-		.gpio = 8,
-		.active_low = 1,
+		.name			= "status",
+		.gpio			= 8,
+		.active_low		= 1,
 	},
 };
 
 static struct gpio_led dsl502t_leds[] = {
 	{
-		.name = "status",
-		.gpio = 9,
-		.active_low = 1,
+		.name			= "status",
+		.gpio			= 9,
+		.active_low		= 1,
 	},
 	{
-		.name = "ethernet",
-		.gpio = 7,
-		.active_low = 1,
+		.name			= "ethernet",
+		.gpio			= 7,
+		.active_low		= 1,
 	},
 	{
-		.name = "usb",
-		.gpio = 12,
-		.active_low = 1,
+		.name			= "usb",
+		.gpio			= 12,
+		.active_low		= 1,
 	},
 };
 
 static struct gpio_led dg834g_leds[] = {
 	{
-		.name = "ppp",
-		.gpio = 6,
-		.active_low = 1,
+		.name			= "ppp",
+		.gpio			= 6,
+		.active_low		= 1,
 	},
 	{
-		.name = "status",
-		.gpio = 7,
-		.active_low = 1,
+		.name			= "status",
+		.gpio			= 7,
+		.active_low		= 1,
 	},
 	{
-		.name = "adsl",
-		.gpio = 8,
-		.active_low = 1,
+		.name			= "adsl",
+		.gpio			= 8,
+		.active_low		= 1,
 	},
 	{
-		.name = "wifi",
-		.gpio = 12,
-		.active_low = 1,
+		.name			= "wifi",
+		.gpio			= 12,
+		.active_low		= 1,
 	},
 	{
-		.name = "power",
-		.gpio = 14,
-		.active_low = 1,
-		.default_trigger = "default-on",
+		.name			= "power",
+		.gpio			= 14,
+		.active_low		= 1,
+		.default_trigger	= "default-on",
 	},
 };
 
 static struct gpio_led fb_sl_leds[] = {
 	{
-		.name = "1",
-		.gpio = 7,
+		.name			= "1",
+		.gpio			= 7,
 	},
 	{
-		.name = "2",
-		.gpio = 13,
-		.active_low = 1,
+		.name			= "2",
+		.gpio			= 13,
+		.active_low		= 1,
 	},
 	{
-		.name = "3",
-		.gpio = 10,
-		.active_low = 1,
+		.name			= "3",
+		.gpio			= 10,
+		.active_low		= 1,
 	},
 	{
-		.name = "4",
-		.gpio = 12,
-		.active_low = 1,
+		.name			= "4",
+		.gpio			= 12,
+		.active_low		= 1,
 	},
 	{
-		.name = "5",
-		.gpio = 9,
-		.active_low = 1,
+		.name			= "5",
+		.gpio			= 9,
+		.active_low		= 1,
 	},
 };
 
 static struct gpio_led fb_fon_leds[] = {
 	{
-		.name = "1",
-		.gpio = 8,
+		.name			= "1",
+		.gpio			= 8,
 	},
 	{
-		.name = "2",
-		.gpio = 3,
-		.active_low = 1,
+		.name			= "2",
+		.gpio			= 3,
+		.active_low		= 1,
 	},
 	{
-		.name = "3",
-		.gpio = 5,
+		.name			= "3",
+		.gpio			= 5,
 	},
 	{
-		.name = "4",
-		.gpio = 4,
-		.active_low = 1,
+		.name			= "4",
+		.gpio			= 4,
+		.active_low		= 1,
 	},
 	{
-		.name = "5",
-		.gpio = 11,
-		.active_low = 1,
+		.name			= "5",
+		.gpio			= 11,
+		.active_low		= 1,
 	},
 };
 
@@ -406,69 +473,11 @@ static struct gpio_led_platform_data ar7_led_data;
 
 static struct platform_device ar7_gpio_leds = {
 	.name = "leds-gpio",
-	.id = -1,
 	.dev = {
 		.platform_data = &ar7_led_data,
 	}
 };
 
-static struct platform_device ar7_udc = {
-	.id = -1,
-	.name = "ar7_udc",
-	.resource = usb_res,
-	.num_resources = ARRAY_SIZE(usb_res),
-};
-
-static struct resource ar7_wdt_res = {
-	.name = "regs",
-	.start = -1, /* Filled at runtime */
-	.end = -1, /* Filled at runtime */
-	.flags = IORESOURCE_MEM,
-};
-
-static struct platform_device ar7_wdt = {
-	.id = -1,
-	.name  = "ar7_wdt",
-	.resource = &ar7_wdt_res,
-	.num_resources = 1,
-};
-
-static inline unsigned char char2hex(char h)
-{
-	switch (h) {
-	case '0': case '1': case '2': case '3': case '4':
-	case '5': case '6': case '7': case '8': case '9':
-		return h - '0';
-	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
-		return h - 'A' + 10;
-	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
-		return h - 'a' + 10;
-	default:
-		return 0;
-	}
-}
-
-static void cpmac_get_mac(int instance, unsigned char *dev_addr)
-{
-	int i;
-	char name[5], default_mac[ETH_ALEN], *mac;
-
-	mac = NULL;
-	sprintf(name, "mac%c", 'a' + instance);
-	mac = prom_getenv(name);
-	if (!mac) {
-		sprintf(name, "mac%c", 'a');
-		mac = prom_getenv(name);
-	}
-	if (!mac) {
-		random_ether_addr(default_mac);
-		mac = default_mac;
-	}
-	for (i = 0; i < 6; i++)
-		dev_addr[i] = (char2hex(mac[i * 3]) << 4) +
-			char2hex(mac[i * 3 + 1]);
-}
-
 static void __init detect_leds(void)
 {
 	char *prid, *usb_prod;
@@ -501,6 +510,25 @@ static void __init detect_leds(void)
 	}
 }
 
+/*****************************************************************************
+ * Watchdog
+ ****************************************************************************/
+static struct resource ar7_wdt_res = {
+	.name		= "regs",
+	.flags		= IORESOURCE_MEM,
+	.start		= -1,	/* Filled at runtime */
+	.end		= -1,	/* Filled at runtime */
+};
+
+static struct platform_device ar7_wdt = {
+	.name		= "ar7_wdt",
+	.resource	= &ar7_wdt_res,
+	.num_resources	= 1,
+};
+
+/*****************************************************************************
+ * Init
+ ****************************************************************************/
 static int __init ar7_register_devices(void)
 {
 	u16 chip_id;
@@ -516,29 +544,28 @@ static int __init ar7_register_devices(void)
 	if (IS_ERR(bus_clk))
 		panic("unable to get bus clk\n");
 
-	uart_port[0].type = PORT_16550A;
-	uart_port[0].line = 0;
-	uart_port[0].irq = AR7_IRQ_UART0;
-	uart_port[0].uartclk = clk_get_rate(bus_clk) / 2;
-	uart_port[0].iotype = UPIO_MEM32;
-	uart_port[0].mapbase = AR7_REGS_UART0;
-	uart_port[0].membase = ioremap(uart_port[0].mapbase, 256);
-	uart_port[0].regshift = 2;
+	uart_port[0].type	= PORT_16550A;
+	uart_port[0].line	= 0;
+	uart_port[0].irq	= AR7_IRQ_UART0;
+	uart_port[0].uartclk	= clk_get_rate(bus_clk) / 2;
+	uart_port[0].iotype	= UPIO_MEM32;
+	uart_port[0].mapbase	= AR7_REGS_UART0;
+	uart_port[0].membase	= ioremap(uart_port[0].mapbase, 256);
+	uart_port[0].regshift	= 2;
 	res = early_serial_setup(&uart_port[0]);
 	if (res)
 		return res;
 
-
 	/* Only TNETD73xx have a second serial port */
 	if (ar7_has_second_uart()) {
-		uart_port[1].type = PORT_16550A;
-		uart_port[1].line = 1;
-		uart_port[1].irq = AR7_IRQ_UART1;
-		uart_port[1].uartclk = clk_get_rate(bus_clk) / 2;
-		uart_port[1].iotype = UPIO_MEM32;
-		uart_port[1].mapbase = UR8_REGS_UART1;
-		uart_port[1].membase = ioremap(uart_port[1].mapbase, 256);
-		uart_port[1].regshift = 2;
+		uart_port[1].type	= PORT_16550A;
+		uart_port[1].line	= 1;
+		uart_port[1].irq	= AR7_IRQ_UART1;
+		uart_port[1].uartclk	= clk_get_rate(bus_clk) / 2;
+		uart_port[1].iotype	= UPIO_MEM32;
+		uart_port[1].mapbase	= UR8_REGS_UART1;
+		uart_port[1].membase 	= ioremap(uart_port[1].mapbase, 256);
+		uart_port[1].regshift	= 2;
 		res = early_serial_setup(&uart_port[1]);
 		if (res)
 			return res;

commit 780019ddf02f214ad61e641b57b8ac30c837e2a7
Author: Florian Fainelli <florian@openwrt.org>
Date:   Wed Jan 27 09:10:06 2010 +0100

    MIPS: AR7: Implement clock API
    
    This patch makes the ar7 clock code implement the Linux clk API. Drivers
    using the various clocks available in the SoC are updated accordingly.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Acked-by: Wim Van Sebroeck <wim@iguana.be>
    To: linux-mips@linux-mips.org
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: netdev@vger.kernel.org
    Cc: David Miller <davem@davemloft.net>
    Patchwork: http://patchwork.linux-mips.org/patch/881/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 5a3fa9407710..1db191cd49c3 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -35,6 +35,7 @@
 #include <linux/phy.h>
 #include <linux/phy_fixed.h>
 #include <linux/gpio.h>
+#include <linux/clk.h>
 
 #include <asm/addrspace.h>
 #include <asm/mach-ar7/ar7.h>
@@ -507,13 +508,18 @@ static int __init ar7_register_devices(void)
 	u32 *bootcr, val;
 #ifdef CONFIG_SERIAL_8250
 	static struct uart_port uart_port[2] __initdata;
+	struct clk *bus_clk;
 
 	memset(uart_port, 0, sizeof(struct uart_port) * 2);
 
+	bus_clk = clk_get(NULL, "bus");
+	if (IS_ERR(bus_clk))
+		panic("unable to get bus clk\n");
+
 	uart_port[0].type = PORT_16550A;
 	uart_port[0].line = 0;
 	uart_port[0].irq = AR7_IRQ_UART0;
-	uart_port[0].uartclk = ar7_bus_freq() / 2;
+	uart_port[0].uartclk = clk_get_rate(bus_clk) / 2;
 	uart_port[0].iotype = UPIO_MEM32;
 	uart_port[0].mapbase = AR7_REGS_UART0;
 	uart_port[0].membase = ioremap(uart_port[0].mapbase, 256);
@@ -528,7 +534,7 @@ static int __init ar7_register_devices(void)
 		uart_port[1].type = PORT_16550A;
 		uart_port[1].line = 1;
 		uart_port[1].irq = AR7_IRQ_UART1;
-		uart_port[1].uartclk = ar7_bus_freq() / 2;
+		uart_port[1].uartclk = clk_get_rate(bus_clk) / 2;
 		uart_port[1].iotype = UPIO_MEM32;
 		uart_port[1].mapbase = UR8_REGS_UART1;
 		uart_port[1].membase = ioremap(uart_port[1].mapbase, 256);

commit 5f3c909881d5deebb9a3ddc836a15937e76daefc
Author: Florian Fainelli <florian@openwrt.org>
Date:   Sun Jan 3 21:16:51 2010 +0100

    MIPS: AR7: Implement gpiolib
    
    This patch implements gpiolib for the AR7 SoC.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/816/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index f70a10a8cc96..5a3fa9407710 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -34,6 +34,7 @@
 #include <linux/etherdevice.h>
 #include <linux/phy.h>
 #include <linux/phy_fixed.h>
+#include <linux/gpio.h>
 
 #include <asm/addrspace.h>
 #include <asm/mach-ar7/ar7.h>

commit ba284b1f199ef7121489010da6614561a679eab6
Author: Alexander Clouter <alex@digriz.org.uk>
Date:   Sun Jan 31 19:38:52 2010 +0000

    MIPS: AR7: Fix USB slave mem range typo
    
    Signed-off-by: Alexander Clouter <alex@digriz.org.uk>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/919/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 85169c08d8dc..f70a10a8cc96 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -202,7 +202,7 @@ static struct resource usb_res[] = {
 		.name = "mem",
 		.flags = IORESOURCE_MEM,
 		.start = 0x03400000,
-		.end = 0x034001fff,
+		.end = 0x03401fff,
 	},
 };
 

commit 599a89459f316499446fdb5c817a0a4835681bae
Author: Dmitri Vorobiev <dmitri.vorobiev@movial.com>
Date:   Mon Nov 23 13:53:37 2009 +0200

    MIPS: Move several variables from .bss to .init.data
    
    Several static uninitialized variables are used in the scope of __init
    functions but are themselves not marked as __initdata.  This patch is to put
    those variables to where they belong and to reduce the memory footprint a
    little bit.
    
    Also, a couple of lines with spaces instead of tabs were fixed.
    
    Signed-off-by: Dmitri Vorobiev <dmitri.vorobiev@movial.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/698/
    Acked-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 835f3f0319ca..85169c08d8dc 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -505,7 +505,7 @@ static int __init ar7_register_devices(void)
 	int res;
 	u32 *bootcr, val;
 #ifdef CONFIG_SERIAL_8250
-	static struct uart_port uart_port[2];
+	static struct uart_port uart_port[2] __initdata;
 
 	memset(uart_port, 0, sizeof(struct uart_port) * 2);
 

commit 72838a170372d6bb44bcb04a81aa2c83312cfbc0
Author: Florian Fainelli <florian@openwrt.org>
Date:   Tue Aug 4 23:09:36 2009 +0200

    MIPS: AR7: register watchdog device only if enabled in hw configuration
    
    This patch checks if the watchdog enable bit is set in the DCL register
    meaning that the hardware watchdog actually works and if so, register the
    ar7_wdt platform_device.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index e2278c04459d..835f3f0319ca 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -503,6 +503,7 @@ static int __init ar7_register_devices(void)
 {
 	u16 chip_id;
 	int res;
+	u32 *bootcr, val;
 #ifdef CONFIG_SERIAL_8250
 	static struct uart_port uart_port[2];
 
@@ -595,7 +596,13 @@ static int __init ar7_register_devices(void)
 
 	ar7_wdt_res.end = ar7_wdt_res.start + 0x20;
 
-	res = platform_device_register(&ar7_wdt);
+	bootcr = (u32 *)ioremap_nocache(AR7_REGS_DCL, 4);
+	val = *bootcr;
+	iounmap(bootcr);
+
+	/* Register watchdog only if enabled in hardware */
+	if (val & AR7_WDT_HW_ENA)
+		res = platform_device_register(&ar7_wdt);
 
 	return res;
 }

commit d47fbb5996269f3081deb7a1b4ba717557256555
Author: Florian Fainelli <florian@openwrt.org>
Date:   Wed Jul 15 12:09:34 2009 +0200

    MIPS: AR7: Make board code register ar7_wdt as a platform device
    
    This patch makes the board code register the ar7_wdt driver as a platform
    device. We move the dynamic resource calculation here since the driver
    should not be aware of the AR7 SoC version it is running on.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index cf50fa29b198..e2278c04459d 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -417,6 +417,20 @@ static struct platform_device ar7_udc = {
 	.num_resources = ARRAY_SIZE(usb_res),
 };
 
+static struct resource ar7_wdt_res = {
+	.name = "regs",
+	.start = -1, /* Filled at runtime */
+	.end = -1, /* Filled at runtime */
+	.flags = IORESOURCE_MEM,
+};
+
+static struct platform_device ar7_wdt = {
+	.id = -1,
+	.name  = "ar7_wdt",
+	.resource = &ar7_wdt_res,
+	.num_resources = 1,
+};
+
 static inline unsigned char char2hex(char h)
 {
 	switch (h) {
@@ -487,6 +501,7 @@ static void __init detect_leds(void)
 
 static int __init ar7_register_devices(void)
 {
+	u16 chip_id;
 	int res;
 #ifdef CONFIG_SERIAL_8250
 	static struct uart_port uart_port[2];
@@ -565,6 +580,23 @@ static int __init ar7_register_devices(void)
 
 	res = platform_device_register(&ar7_udc);
 
+	chip_id = ar7_chip_id();
+	switch (chip_id) {
+	case AR7_CHIP_7100:
+	case AR7_CHIP_7200:
+		ar7_wdt_res.start = AR7_REGS_WDT;
+		break;
+	case AR7_CHIP_7300:
+		ar7_wdt_res.start = UR8_REGS_WDT;
+		break;
+	default:
+		break;
+	}
+
+	ar7_wdt_res.end = ar7_wdt_res.start + 0x20;
+
+	res = platform_device_register(&ar7_wdt);
+
 	return res;
 }
 arch_initcall(ar7_register_devices);

commit aa11d958d1a6572eda08214d7c6a735804fe48a5
Merge: 07f6642ee941 9799218ae369
Author: David S. Miller <davem@davemloft.net>
Date:   Wed Aug 12 17:44:53 2009 -0700

    Merge branch 'master' of master.kernel.org:/pub/scm/linux/kernel/git/davem/net-2.6
    
    Conflicts:
            arch/microblaze/include/asm/socket.h

commit 1e2c8d830a74c24ccb25601bd89dcd0dbcb4e9f5
Author: Florian Fainelli <florian@openwrt.org>
Date:   Tue Aug 4 10:52:47 2009 +0000

    ar7: add fixed PHY support for the two on-board cpmac
    
    This patch adds fixed PHY support for the two on-chip
    cpmac Ethernet adapters.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 542244961780..c4737ce6d29c 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -33,6 +33,8 @@
 #include <linux/leds.h>
 #include <linux/string.h>
 #include <linux/etherdevice.h>
+#include <linux/phy.h>
+#include <linux/phy_fixed.h>
 
 #include <asm/addrspace.h>
 #include <asm/mach-ar7/ar7.h>
@@ -209,6 +211,12 @@ static struct physmap_flash_data physmap_flash_data = {
 	.width = 2,
 };
 
+static struct fixed_phy_status fixed_phy_status __initdata = {
+	.link = 1,
+	.speed = 100,
+	.duplex = 1,
+};
+
 static struct plat_cpmac_data cpmac_low_data = {
 	.reset_bit = 17,
 	.power_bit = 20,
@@ -530,6 +538,9 @@ static int __init ar7_register_devices(void)
 	}
 
 	if (ar7_has_high_cpmac()) {
+		res = fixed_phy_add(PHY_POLL, cpmac_high.id, &fixed_phy_status);
+		if (res && res != -ENODEV)
+			return res;
 		cpmac_get_mac(1, cpmac_high_data.dev_addr);
 		res = platform_device_register(&cpmac_high);
 		if (res)
@@ -538,6 +549,10 @@ static int __init ar7_register_devices(void)
 		cpmac_low_data.phy_mask = 0xffffffff;
 	}
 
+	res = fixed_phy_add(PHY_POLL, cpmac_low.id, &fixed_phy_status);
+	if (res && res != -ENODEV)
+		return res;
+
 	cpmac_get_mac(0, cpmac_low_data.dev_addr);
 	res = platform_device_register(&cpmac_low);
 	if (res)

commit 8e84c1480d2e7d98d487b567100717b9cc9dcfd7
Author: Florian Fainelli <florian@openwrt.org>
Date:   Fri Jul 24 13:18:16 2009 +0200

    MIPS: AR7: Use DMA_BIT_MASK(nn) instead of deprecated DMA_nnBIT_MASK
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 8ef8266e47f4..2ecab6155932 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -242,13 +242,13 @@ static struct platform_device physmap_flash = {
 	.num_resources = 1,
 };
 
-static u64 cpmac_dma_mask = DMA_32BIT_MASK;
+static u64 cpmac_dma_mask = DMA_BIT_MASK(32);
 static struct platform_device cpmac_low = {
 	.id = 0,
 	.name = "cpmac",
 	.dev = {
 		.dma_mask = &cpmac_dma_mask,
-		.coherent_dma_mask = DMA_32BIT_MASK,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
 		.platform_data = &cpmac_low_data,
 	},
 	.resource = cpmac_low_res,
@@ -260,7 +260,7 @@ static struct platform_device cpmac_high = {
 	.name = "cpmac",
 	.dev = {
 		.dma_mask = &cpmac_dma_mask,
-		.coherent_dma_mask = DMA_32BIT_MASK,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
 		.platform_data = &cpmac_high_data,
 	},
 	.resource = cpmac_high_res,

commit 50ca961912be315035cb0f3508e35c974851da2a
Author: Florian Fainelli <florian@openwrt.org>
Date:   Fri Jul 24 13:24:15 2009 +0200

    MIPS: AR7: Fix build failures when CONFIG_SERIAL_8250 is not enabled
    
    This patch fixes the following build failure when CONFIG_SERIAL_8250
    is not enabled in the kernel configuration:
    arch/mips/ar7/built-in.o: In function 'ar7_register_devices':
    platform.c:(.init.text+0x61c): undefined reference to 'early_serial_setup'
    platform.c:(.init.text+0x61c): relocation truncated to fit: R_MIPS_26 against 'early_serial_setup'
    platform.c:(.init.text+0x68c): undefined reference to 'early_serial_setup'
    platform.c:(.init.text+0x68c): relocation truncated to fit: R_MIPS_26 against 'early_serial_setup'
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index c4d71fb18deb..8ef8266e47f4 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -480,6 +480,7 @@ static void __init detect_leds(void)
 static int __init ar7_register_devices(void)
 {
 	int res;
+#ifdef CONFIG_SERIAL_8250
 	static struct uart_port uart_port[2];
 
 	memset(uart_port, 0, sizeof(struct uart_port) * 2);
@@ -511,7 +512,7 @@ static int __init ar7_register_devices(void)
 		if (res)
 			return res;
 	}
-
+#endif /* CONFIG_SERIAL_8250 */
 	res = platform_device_register(&physmap_flash);
 	if (res)
 		return res;

commit 1de010a2702eb21d90883b83bf8c737d5e69d234
Author: Huang Weiyi <weiyi.huang@gmail.com>
Date:   Thu Jul 9 06:14:37 2009 +0800

    MIPS: AR7: Remove unused inclusions of <linux/version.h>.
    
    Signed-off-by: Huang Weiyi <weiyi.huang@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
index 542244961780..c4d71fb18deb 100644
--- a/arch/mips/ar7/platform.c
+++ b/arch/mips/ar7/platform.c
@@ -28,7 +28,6 @@
 #include <linux/serial_8250.h>
 #include <linux/ioport.h>
 #include <linux/io.h>
-#include <linux/version.h>
 #include <linux/vlynq.h>
 #include <linux/leds.h>
 #include <linux/string.h>

commit 7ca5dc145bc7daddd8aed8bbda46b74af9cebefc
Author: Florian Fainelli <florian@openwrt.org>
Date:   Wed Jun 24 11:12:57 2009 +0200

    MIPS: Add support for Texas Instruments AR7 System-on-a-Chip
    
    This patch adds support for the Texas Instruments AR7 System-on-a-Chip.
    It supports the TNETD7100, 7200 and 7300 versions of the SoC.
    
    Signed-off-by: Matteo Croce <matteo@openwrt.org>
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: Eugene Konev <ejka@openwrt.org>
    Signed-off-by: Nicolas Thill <nico@openwrt.org>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/platform.c b/arch/mips/ar7/platform.c
new file mode 100644
index 000000000000..542244961780
--- /dev/null
+++ b/arch/mips/ar7/platform.c
@@ -0,0 +1,555 @@
+/*
+ * Copyright (C) 2006,2007 Felix Fietkau <nbd@openwrt.org>
+ * Copyright (C) 2006,2007 Eugene Konev <ejka@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/init.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/platform_device.h>
+#include <linux/mtd/physmap.h>
+#include <linux/serial.h>
+#include <linux/serial_8250.h>
+#include <linux/ioport.h>
+#include <linux/io.h>
+#include <linux/version.h>
+#include <linux/vlynq.h>
+#include <linux/leds.h>
+#include <linux/string.h>
+#include <linux/etherdevice.h>
+
+#include <asm/addrspace.h>
+#include <asm/mach-ar7/ar7.h>
+#include <asm/mach-ar7/gpio.h>
+#include <asm/mach-ar7/prom.h>
+
+struct plat_vlynq_data {
+	struct plat_vlynq_ops ops;
+	int gpio_bit;
+	int reset_bit;
+};
+
+
+static int vlynq_on(struct vlynq_device *dev)
+{
+	int result;
+	struct plat_vlynq_data *pdata = dev->dev.platform_data;
+
+	result = gpio_request(pdata->gpio_bit, "vlynq");
+	if (result)
+		goto out;
+
+	ar7_device_reset(pdata->reset_bit);
+
+	result = ar7_gpio_disable(pdata->gpio_bit);
+	if (result)
+		goto out_enabled;
+
+	result = ar7_gpio_enable(pdata->gpio_bit);
+	if (result)
+		goto out_enabled;
+
+	result = gpio_direction_output(pdata->gpio_bit, 0);
+	if (result)
+		goto out_gpio_enabled;
+
+	msleep(50);
+
+	gpio_set_value(pdata->gpio_bit, 1);
+	msleep(50);
+
+	return 0;
+
+out_gpio_enabled:
+	ar7_gpio_disable(pdata->gpio_bit);
+out_enabled:
+	ar7_device_disable(pdata->reset_bit);
+	gpio_free(pdata->gpio_bit);
+out:
+	return result;
+}
+
+static void vlynq_off(struct vlynq_device *dev)
+{
+	struct plat_vlynq_data *pdata = dev->dev.platform_data;
+	ar7_gpio_disable(pdata->gpio_bit);
+	gpio_free(pdata->gpio_bit);
+	ar7_device_disable(pdata->reset_bit);
+}
+
+static struct resource physmap_flash_resource = {
+	.name = "mem",
+	.flags = IORESOURCE_MEM,
+	.start = 0x10000000,
+	.end = 0x107fffff,
+};
+
+static struct resource cpmac_low_res[] = {
+	{
+		.name = "regs",
+		.flags = IORESOURCE_MEM,
+		.start = AR7_REGS_MAC0,
+		.end = AR7_REGS_MAC0 + 0x7ff,
+	},
+	{
+		.name = "irq",
+		.flags = IORESOURCE_IRQ,
+		.start = 27,
+		.end = 27,
+	},
+};
+
+static struct resource cpmac_high_res[] = {
+	{
+		.name = "regs",
+		.flags = IORESOURCE_MEM,
+		.start = AR7_REGS_MAC1,
+		.end = AR7_REGS_MAC1 + 0x7ff,
+	},
+	{
+		.name = "irq",
+		.flags = IORESOURCE_IRQ,
+		.start = 41,
+		.end = 41,
+	},
+};
+
+static struct resource vlynq_low_res[] = {
+	{
+		.name = "regs",
+		.flags = IORESOURCE_MEM,
+		.start = AR7_REGS_VLYNQ0,
+		.end = AR7_REGS_VLYNQ0 + 0xff,
+	},
+	{
+		.name = "irq",
+		.flags = IORESOURCE_IRQ,
+		.start = 29,
+		.end = 29,
+	},
+	{
+		.name = "mem",
+		.flags = IORESOURCE_MEM,
+		.start = 0x04000000,
+		.end = 0x04ffffff,
+	},
+	{
+		.name = "devirq",
+		.flags = IORESOURCE_IRQ,
+		.start = 80,
+		.end = 111,
+	},
+};
+
+static struct resource vlynq_high_res[] = {
+	{
+		.name = "regs",
+		.flags = IORESOURCE_MEM,
+		.start = AR7_REGS_VLYNQ1,
+		.end = AR7_REGS_VLYNQ1 + 0xff,
+	},
+	{
+		.name = "irq",
+		.flags = IORESOURCE_IRQ,
+		.start = 33,
+		.end = 33,
+	},
+	{
+		.name = "mem",
+		.flags = IORESOURCE_MEM,
+		.start = 0x0c000000,
+		.end = 0x0cffffff,
+	},
+	{
+		.name = "devirq",
+		.flags = IORESOURCE_IRQ,
+		.start = 112,
+		.end = 143,
+	},
+};
+
+static struct resource usb_res[] = {
+	{
+		.name = "regs",
+		.flags = IORESOURCE_MEM,
+		.start = AR7_REGS_USB,
+		.end = AR7_REGS_USB + 0xff,
+	},
+	{
+		.name = "irq",
+		.flags = IORESOURCE_IRQ,
+		.start = 32,
+		.end = 32,
+	},
+	{
+		.name = "mem",
+		.flags = IORESOURCE_MEM,
+		.start = 0x03400000,
+		.end = 0x034001fff,
+	},
+};
+
+static struct physmap_flash_data physmap_flash_data = {
+	.width = 2,
+};
+
+static struct plat_cpmac_data cpmac_low_data = {
+	.reset_bit = 17,
+	.power_bit = 20,
+	.phy_mask = 0x80000000,
+};
+
+static struct plat_cpmac_data cpmac_high_data = {
+	.reset_bit = 21,
+	.power_bit = 22,
+	.phy_mask = 0x7fffffff,
+};
+
+static struct plat_vlynq_data vlynq_low_data = {
+	.ops.on = vlynq_on,
+	.ops.off = vlynq_off,
+	.reset_bit = 20,
+	.gpio_bit = 18,
+};
+
+static struct plat_vlynq_data vlynq_high_data = {
+	.ops.on = vlynq_on,
+	.ops.off = vlynq_off,
+	.reset_bit = 16,
+	.gpio_bit = 19,
+};
+
+static struct platform_device physmap_flash = {
+	.id = 0,
+	.name = "physmap-flash",
+	.dev.platform_data = &physmap_flash_data,
+	.resource = &physmap_flash_resource,
+	.num_resources = 1,
+};
+
+static u64 cpmac_dma_mask = DMA_32BIT_MASK;
+static struct platform_device cpmac_low = {
+	.id = 0,
+	.name = "cpmac",
+	.dev = {
+		.dma_mask = &cpmac_dma_mask,
+		.coherent_dma_mask = DMA_32BIT_MASK,
+		.platform_data = &cpmac_low_data,
+	},
+	.resource = cpmac_low_res,
+	.num_resources = ARRAY_SIZE(cpmac_low_res),
+};
+
+static struct platform_device cpmac_high = {
+	.id = 1,
+	.name = "cpmac",
+	.dev = {
+		.dma_mask = &cpmac_dma_mask,
+		.coherent_dma_mask = DMA_32BIT_MASK,
+		.platform_data = &cpmac_high_data,
+	},
+	.resource = cpmac_high_res,
+	.num_resources = ARRAY_SIZE(cpmac_high_res),
+};
+
+static struct platform_device vlynq_low = {
+	.id = 0,
+	.name = "vlynq",
+	.dev.platform_data = &vlynq_low_data,
+	.resource = vlynq_low_res,
+	.num_resources = ARRAY_SIZE(vlynq_low_res),
+};
+
+static struct platform_device vlynq_high = {
+	.id = 1,
+	.name = "vlynq",
+	.dev.platform_data = &vlynq_high_data,
+	.resource = vlynq_high_res,
+	.num_resources = ARRAY_SIZE(vlynq_high_res),
+};
+
+
+static struct gpio_led default_leds[] = {
+	{
+		.name = "status",
+		.gpio = 8,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_led dsl502t_leds[] = {
+	{
+		.name = "status",
+		.gpio = 9,
+		.active_low = 1,
+	},
+	{
+		.name = "ethernet",
+		.gpio = 7,
+		.active_low = 1,
+	},
+	{
+		.name = "usb",
+		.gpio = 12,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_led dg834g_leds[] = {
+	{
+		.name = "ppp",
+		.gpio = 6,
+		.active_low = 1,
+	},
+	{
+		.name = "status",
+		.gpio = 7,
+		.active_low = 1,
+	},
+	{
+		.name = "adsl",
+		.gpio = 8,
+		.active_low = 1,
+	},
+	{
+		.name = "wifi",
+		.gpio = 12,
+		.active_low = 1,
+	},
+	{
+		.name = "power",
+		.gpio = 14,
+		.active_low = 1,
+		.default_trigger = "default-on",
+	},
+};
+
+static struct gpio_led fb_sl_leds[] = {
+	{
+		.name = "1",
+		.gpio = 7,
+	},
+	{
+		.name = "2",
+		.gpio = 13,
+		.active_low = 1,
+	},
+	{
+		.name = "3",
+		.gpio = 10,
+		.active_low = 1,
+	},
+	{
+		.name = "4",
+		.gpio = 12,
+		.active_low = 1,
+	},
+	{
+		.name = "5",
+		.gpio = 9,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_led fb_fon_leds[] = {
+	{
+		.name = "1",
+		.gpio = 8,
+	},
+	{
+		.name = "2",
+		.gpio = 3,
+		.active_low = 1,
+	},
+	{
+		.name = "3",
+		.gpio = 5,
+	},
+	{
+		.name = "4",
+		.gpio = 4,
+		.active_low = 1,
+	},
+	{
+		.name = "5",
+		.gpio = 11,
+		.active_low = 1,
+	},
+};
+
+static struct gpio_led_platform_data ar7_led_data;
+
+static struct platform_device ar7_gpio_leds = {
+	.name = "leds-gpio",
+	.id = -1,
+	.dev = {
+		.platform_data = &ar7_led_data,
+	}
+};
+
+static struct platform_device ar7_udc = {
+	.id = -1,
+	.name = "ar7_udc",
+	.resource = usb_res,
+	.num_resources = ARRAY_SIZE(usb_res),
+};
+
+static inline unsigned char char2hex(char h)
+{
+	switch (h) {
+	case '0': case '1': case '2': case '3': case '4':
+	case '5': case '6': case '7': case '8': case '9':
+		return h - '0';
+	case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':
+		return h - 'A' + 10;
+	case 'a': case 'b': case 'c': case 'd': case 'e': case 'f':
+		return h - 'a' + 10;
+	default:
+		return 0;
+	}
+}
+
+static void cpmac_get_mac(int instance, unsigned char *dev_addr)
+{
+	int i;
+	char name[5], default_mac[ETH_ALEN], *mac;
+
+	mac = NULL;
+	sprintf(name, "mac%c", 'a' + instance);
+	mac = prom_getenv(name);
+	if (!mac) {
+		sprintf(name, "mac%c", 'a');
+		mac = prom_getenv(name);
+	}
+	if (!mac) {
+		random_ether_addr(default_mac);
+		mac = default_mac;
+	}
+	for (i = 0; i < 6; i++)
+		dev_addr[i] = (char2hex(mac[i * 3]) << 4) +
+			char2hex(mac[i * 3 + 1]);
+}
+
+static void __init detect_leds(void)
+{
+	char *prid, *usb_prod;
+
+	/* Default LEDs	*/
+	ar7_led_data.num_leds = ARRAY_SIZE(default_leds);
+	ar7_led_data.leds = default_leds;
+
+	/* FIXME: the whole thing is unreliable */
+	prid = prom_getenv("ProductID");
+	usb_prod = prom_getenv("usb_prod");
+
+	/* If we can't get the product id from PROM, use the default LEDs */
+	if (!prid)
+		return;
+
+	if (strstr(prid, "Fritz_Box_FON")) {
+		ar7_led_data.num_leds = ARRAY_SIZE(fb_fon_leds);
+		ar7_led_data.leds = fb_fon_leds;
+	} else if (strstr(prid, "Fritz_Box_")) {
+		ar7_led_data.num_leds = ARRAY_SIZE(fb_sl_leds);
+		ar7_led_data.leds = fb_sl_leds;
+	} else if ((!strcmp(prid, "AR7RD") || !strcmp(prid, "AR7DB"))
+		&& usb_prod != NULL && strstr(usb_prod, "DSL-502T")) {
+		ar7_led_data.num_leds = ARRAY_SIZE(dsl502t_leds);
+		ar7_led_data.leds = dsl502t_leds;
+	} else if (strstr(prid, "DG834")) {
+		ar7_led_data.num_leds = ARRAY_SIZE(dg834g_leds);
+		ar7_led_data.leds = dg834g_leds;
+	}
+}
+
+static int __init ar7_register_devices(void)
+{
+	int res;
+	static struct uart_port uart_port[2];
+
+	memset(uart_port, 0, sizeof(struct uart_port) * 2);
+
+	uart_port[0].type = PORT_16550A;
+	uart_port[0].line = 0;
+	uart_port[0].irq = AR7_IRQ_UART0;
+	uart_port[0].uartclk = ar7_bus_freq() / 2;
+	uart_port[0].iotype = UPIO_MEM32;
+	uart_port[0].mapbase = AR7_REGS_UART0;
+	uart_port[0].membase = ioremap(uart_port[0].mapbase, 256);
+	uart_port[0].regshift = 2;
+	res = early_serial_setup(&uart_port[0]);
+	if (res)
+		return res;
+
+
+	/* Only TNETD73xx have a second serial port */
+	if (ar7_has_second_uart()) {
+		uart_port[1].type = PORT_16550A;
+		uart_port[1].line = 1;
+		uart_port[1].irq = AR7_IRQ_UART1;
+		uart_port[1].uartclk = ar7_bus_freq() / 2;
+		uart_port[1].iotype = UPIO_MEM32;
+		uart_port[1].mapbase = UR8_REGS_UART1;
+		uart_port[1].membase = ioremap(uart_port[1].mapbase, 256);
+		uart_port[1].regshift = 2;
+		res = early_serial_setup(&uart_port[1]);
+		if (res)
+			return res;
+	}
+
+	res = platform_device_register(&physmap_flash);
+	if (res)
+		return res;
+
+	ar7_device_disable(vlynq_low_data.reset_bit);
+	res = platform_device_register(&vlynq_low);
+	if (res)
+		return res;
+
+	if (ar7_has_high_vlynq()) {
+		ar7_device_disable(vlynq_high_data.reset_bit);
+		res = platform_device_register(&vlynq_high);
+		if (res)
+			return res;
+	}
+
+	if (ar7_has_high_cpmac()) {
+		cpmac_get_mac(1, cpmac_high_data.dev_addr);
+		res = platform_device_register(&cpmac_high);
+		if (res)
+			return res;
+	} else {
+		cpmac_low_data.phy_mask = 0xffffffff;
+	}
+
+	cpmac_get_mac(0, cpmac_low_data.dev_addr);
+	res = platform_device_register(&cpmac_low);
+	if (res)
+		return res;
+
+	detect_leds();
+	res = platform_device_register(&ar7_gpio_leds);
+	if (res)
+		return res;
+
+	res = platform_device_register(&ar7_udc);
+
+	return res;
+}
+arch_initcall(ar7_register_devices);
