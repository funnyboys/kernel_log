commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index 2292e55c12e2..8b006addd6ba 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -308,7 +308,7 @@ int __init ar7_gpio_init(void)
 		size = 0x1f;
 	}
 
-	gpch->regs = ioremap_nocache(AR7_REGS_GPIO, size);
+	gpch->regs = ioremap(AR7_REGS_GPIO, size);
 	if (!gpch->regs) {
 		printk(KERN_ERR "%s: failed to ioremap regs\n",
 					gpch->chip.label);

commit fd534e9b5fdcf9bab33c03cb3ade1a1ae5b23c20
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:39 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 102
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      51 franklin st fifth floor boston ma 02110 1301 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 50 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091649.499889647@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index 4eee7e9e26ee..2292e55c12e2 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -1,21 +1,8 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * Copyright (C) 2007 Felix Fietkau <nbd@openwrt.org>
  * Copyright (C) 2007 Eugene Konev <ejka@openwrt.org>
  * Copyright (C) 2009-2010 Florian Fainelli <florian@openwrt.org>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
 #include <linux/init.h>

commit 26dd3e4ff9ac1aa576c97d23d7425d2544dbc5bf
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Jan 28 21:05:57 2017 -0500

    MIPS: Audit and remove any unnecessary uses of module.h
    
    Historically a lot of these existed because we did not have
    a distinction between what was modular code and what was providing
    support to modules via EXPORT_SYMBOL and friends.  That changed
    when we forked out support for the latter into the export.h file.
    
    This means we should be able to reduce the usage of module.h
    in code that is obj-y Makefile or bool Kconfig.  In the case of
    some code where it is modular, we can extend that to also include
    files that are building basic support functionality but not related
    to loading or registering the final module; such files also have
    no need whatsoever for module.h
    
    The advantage in removing such instances is that module.h itself
    sources about 15 other headers; adding significantly to what we feed
    cpp, and it can obscure what headers we are effectively using.
    
    Since module.h might have been the implicit source for init.h
    (for __init) and for export.h (for EXPORT_SYMBOL) we consider each
    instance for the presence of either and replace/add as needed.
    
    Also note that MODULE_DEVICE_TABLE is a no-op for non-modular code.
    
    Build coverage of all the mips defconfigs revealed the module.h
    header was masking a couple of implicit include instances, so
    we add the appropriate headers there.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: David Daney <david.daney@cavium.com>
    Cc: John Crispin <john@phrozen.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: "Steven J. Hill" <steven.hill@cavium.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/15131/
    [james.hogan@imgtec.com: Preserve sort order where it already exists]
    Signed-off-by: James Hogan <james.hogan@imgtec.com>

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index ed5b3d297caf..4eee7e9e26ee 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -18,7 +18,8 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/export.h>
 #include <linux/gpio.h>
 
 #include <asm/mach-ar7/ar7.h>

commit 1b2766fb496c462b3f6e1d1c52c72f8601ac8540
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 8 14:15:03 2015 +0100

    MIPS: ar7: use gpiochip data pointer
    
    This makes the driver use the data pointer added to the gpio_chip
    to store a pointer to the state container instead of relying on
    container_of().
    
    Cc: linux-mips@linux-mips.org
    Cc: Alban Bedel <albeu@free.fr>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index f969f583c68c..ed5b3d297caf 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -33,8 +33,7 @@ struct ar7_gpio_chip {
 
 static int ar7_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
 {
-	struct ar7_gpio_chip *gpch =
-				container_of(chip, struct ar7_gpio_chip, chip);
+	struct ar7_gpio_chip *gpch = gpiochip_get_data(chip);
 	void __iomem *gpio_in = gpch->regs + AR7_GPIO_INPUT;
 
 	return !!(readl(gpio_in) & (1 << gpio));
@@ -42,8 +41,7 @@ static int ar7_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
 
 static int titan_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
 {
-	struct ar7_gpio_chip *gpch =
-				container_of(chip, struct ar7_gpio_chip, chip);
+	struct ar7_gpio_chip *gpch = gpiochip_get_data(chip);
 	void __iomem *gpio_in0 = gpch->regs + TITAN_GPIO_INPUT_0;
 	void __iomem *gpio_in1 = gpch->regs + TITAN_GPIO_INPUT_1;
 
@@ -53,8 +51,7 @@ static int titan_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
 static void ar7_gpio_set_value(struct gpio_chip *chip,
 				unsigned gpio, int value)
 {
-	struct ar7_gpio_chip *gpch =
-				container_of(chip, struct ar7_gpio_chip, chip);
+	struct ar7_gpio_chip *gpch = gpiochip_get_data(chip);
 	void __iomem *gpio_out = gpch->regs + AR7_GPIO_OUTPUT;
 	unsigned tmp;
 
@@ -67,8 +64,7 @@ static void ar7_gpio_set_value(struct gpio_chip *chip,
 static void titan_gpio_set_value(struct gpio_chip *chip,
 				unsigned gpio, int value)
 {
-	struct ar7_gpio_chip *gpch =
-				container_of(chip, struct ar7_gpio_chip, chip);
+	struct ar7_gpio_chip *gpch = gpiochip_get_data(chip);
 	void __iomem *gpio_out0 = gpch->regs + TITAN_GPIO_OUTPUT_0;
 	void __iomem *gpio_out1 = gpch->regs + TITAN_GPIO_OUTPUT_1;
 	unsigned tmp;
@@ -81,8 +77,7 @@ static void titan_gpio_set_value(struct gpio_chip *chip,
 
 static int ar7_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
 {
-	struct ar7_gpio_chip *gpch =
-				container_of(chip, struct ar7_gpio_chip, chip);
+	struct ar7_gpio_chip *gpch = gpiochip_get_data(chip);
 	void __iomem *gpio_dir = gpch->regs + AR7_GPIO_DIR;
 
 	writel(readl(gpio_dir) | (1 << gpio), gpio_dir);
@@ -92,8 +87,7 @@ static int ar7_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
 
 static int titan_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
 {
-	struct ar7_gpio_chip *gpch =
-				container_of(chip, struct ar7_gpio_chip, chip);
+	struct ar7_gpio_chip *gpch = gpiochip_get_data(chip);
 	void __iomem *gpio_dir0 = gpch->regs + TITAN_GPIO_DIR_0;
 	void __iomem *gpio_dir1 = gpch->regs + TITAN_GPIO_DIR_1;
 
@@ -108,8 +102,7 @@ static int titan_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
 static int ar7_gpio_direction_output(struct gpio_chip *chip,
 					unsigned gpio, int value)
 {
-	struct ar7_gpio_chip *gpch =
-				container_of(chip, struct ar7_gpio_chip, chip);
+	struct ar7_gpio_chip *gpch = gpiochip_get_data(chip);
 	void __iomem *gpio_dir = gpch->regs + AR7_GPIO_DIR;
 
 	ar7_gpio_set_value(chip, gpio, value);
@@ -121,8 +114,7 @@ static int ar7_gpio_direction_output(struct gpio_chip *chip,
 static int titan_gpio_direction_output(struct gpio_chip *chip,
 					unsigned gpio, int value)
 {
-	struct ar7_gpio_chip *gpch =
-				container_of(chip, struct ar7_gpio_chip, chip);
+	struct ar7_gpio_chip *gpch = gpiochip_get_data(chip);
 	void __iomem *gpio_dir0 = gpch->regs + TITAN_GPIO_DIR_0;
 	void __iomem *gpio_dir1 = gpch->regs + TITAN_GPIO_DIR_1;
 
@@ -335,7 +327,7 @@ int __init ar7_gpio_init(void)
 		return -ENOMEM;
 	}
 
-	ret = gpiochip_add(&gpch->chip);
+	ret = gpiochip_add_data(&gpch->chip, gpch);
 	if (ret) {
 		printk(KERN_ERR "%s: failed to add gpiochip\n",
 					gpch->chip.label);

commit 249e573d99ab590e19bd23f084f8c6540daa7b06
Author: Linus Walleij <linus.walleij@linaro.org>
Date:   Tue Dec 22 15:40:27 2015 +0100

    MIPS: ar7: Be sure to clamp return value
    
    As we want gpio_chip .get() calls to be able to return negative
    error codes and propagate to drivers, we need to go over all
    drivers and make sure their return values are clamped to [0,1].
    We do this by using the ret = !!(val) design pattern.
    
    Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
    Acked-by: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Alban Bedel <albeu@free.fr>
    Cc: linux-mips@linux-mips.org
    Cc: linux-gpio@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/11922/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index f4930456eb8e..f969f583c68c 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -37,7 +37,7 @@ static int ar7_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
 				container_of(chip, struct ar7_gpio_chip, chip);
 	void __iomem *gpio_in = gpch->regs + AR7_GPIO_INPUT;
 
-	return readl(gpio_in) & (1 << gpio);
+	return !!(readl(gpio_in) & (1 << gpio));
 }
 
 static int titan_gpio_get_value(struct gpio_chip *chip, unsigned gpio)

commit 832f5dacfa0bb081a3b3b979a36a132b28ffacf3
Author: Alban Bedel <albeu@free.fr>
Date:   Sun Aug 2 18:30:11 2015 +0200

    MIPS: Remove all the uses of custom gpio.h
    
    Currently CONFIG_ARCH_HAVE_CUSTOM_GPIO_H is defined for all MIPS
    machines, and each machine type provides its own gpio.h. However
    only a handful really implement the GPIO API, most just forward
    everythings to gpiolib.
    
    The Alchemy machine is notable as it provides a system to allow
    implementing the GPIO API at the board level. But it is not used by
    any board currently supported, so it can also be removed.
    
    For most machine types we can just remove the custom gpio.h, as well
    as the custom wrappers if some exists. Some of the code found in
    the wrappers must be moved to the respective GPIO driver.
    
    A few more fixes are need in some drivers as they rely on linux/gpio.h
    to provides some machine specific definitions, or used asm/gpio.h
    instead of linux/gpio.h for the gpio API.
    
    Signed-off-by: Alban Bedel <albeu@free.fr>
    Reviewed-by: Linus Walleij <linus.walleij@linaro.org>
    Cc: linux-mips@linux-mips.org
    Cc: Hauke Mehrtens <hauke@hauke-m.de>
    Cc: Rafał Miłecki <zajec5@gmail.com>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Alexandre Courbot <gnurou@gmail.com>
    Cc: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Daniel Walter <dwalter@google.com>
    Cc: Sergey Ryazanov <ryazanov.s.a@gmail.com>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: James Hartley <james.hartley@imgtec.com>
    Cc: Andrew Bresticker <abrestic@chromium.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Jiri Kosina <jkosina@suse.cz>
    Cc: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Wolfram Sang <wsa@the-dreams.de>
    Cc: Randy Dunlap <rdunlap@infradead.org>
    Cc: Varka Bhadram <varkabhadram@gmail.com>
    Cc: Masanari Iida <standby24x7@gmail.com>
    Cc: Tomi Valkeinen <tomi.valkeinen@ti.com>
    Cc: Michael Buesch <m@bues.ch>
    Cc: abdoulaye berthe <berthe.ab@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-ide@vger.kernel.org
    Cc: linux-gpio@vger.kernel.org
    Cc: linux-input@vger.kernel.org
    Cc: netdev@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/10828/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index d8dbd8f0c1d2..f4930456eb8e 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -21,7 +21,10 @@
 #include <linux/module.h>
 #include <linux/gpio.h>
 
-#include <asm/mach-ar7/gpio.h>
+#include <asm/mach-ar7/ar7.h>
+
+#define AR7_GPIO_MAX 32
+#define TITAN_GPIO_MAX 51
 
 struct ar7_gpio_chip {
 	void __iomem		*regs;

commit edc9ded191f7075f2d9e7aa3c9e84c48bc4338b2
Author: Florian Fainelli <florian@openwrt.org>
Date:   Tue Nov 15 20:23:43 2011 +0100

    MIPS: AR7: constify some arrays in gpio and prom code
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2980/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index bb571bcdb8f2..d8dbd8f0c1d2 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -217,7 +217,7 @@ struct titan_gpio_cfg {
 	u32 func;
 };
 
-static struct titan_gpio_cfg titan_gpio_table[] = {
+static const struct titan_gpio_cfg titan_gpio_table[] = {
 	/* reg, start bit, mux value */
 	{4, 24, 1},
 	{4, 26, 1},

commit 3e9957b4866f3767f19bf0e543b322ad7906c564
Author: Florian Fainelli <florian@openwrt.org>
Date:   Fri May 13 17:41:21 2011 +0200

    MIPS: AR7: Fix GPIO register size for Titan variant.
    
    The 'size' variable contains the correct register size for both AR7
    and Titan, but we never used it to ioremap the correct register size.
    This problem only shows up on Titan.
    
    [ralf@linux-mips.org: Fixed the fix.  The original patch as in patchwork
    recognizes the problem correctly then fails to fix it ...]
    
    Reported-by: Alexander Clouter <alex@digriz.org.uk>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Patchwork: https://patchwork.linux-mips.org/patch/2380/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index 425dfa5d6e12..bb571bcdb8f2 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -325,9 +325,7 @@ int __init ar7_gpio_init(void)
 		size = 0x1f;
 	}
 
-	gpch->regs = ioremap_nocache(AR7_REGS_GPIO,
-					AR7_REGS_GPIO + 0x10);
-
+	gpch->regs = ioremap_nocache(AR7_REGS_GPIO, size);
 	if (!gpch->regs) {
 		printk(KERN_ERR "%s: failed to ioremap regs\n",
 					gpch->chip.label);

commit 238dd317f74250983aefbde6dc0a1f345a717993
Author: Florian Fainelli <florian@openwrt.org>
Date:   Sun Aug 29 17:08:44 2010 +0200

    MIPS: AR7: Add support for Titan (TNETV10xx) SoC variant
    
    Add support for Titan TNETV1050,1055,1056,1060 variants. This SoC is almost
    completely identical to AR7 except on a few points:
    - a second bank of gpios is available
    - vlynq0 on titan is vlynq1 on ar7
    - different PHY addresses for cpmac0
    
    This SoC can be found on commercial products like the Linksys WRTP54G
    
    Original patch by Xin with improvments by Florian.
    
    Signed-off-by: Xin Zhen <xlonestar2000@aim.com>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/1563/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
    ---

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index f84834229dcf..425dfa5d6e12 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -1,7 +1,7 @@
 /*
  * Copyright (C) 2007 Felix Fietkau <nbd@openwrt.org>
  * Copyright (C) 2007 Eugene Konev <ejka@openwrt.org>
- * Copyright (C) 2009 Florian Fainelli <florian@openwrt.org>
+ * Copyright (C) 2009-2010 Florian Fainelli <florian@openwrt.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,6 +37,16 @@ static int ar7_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
 	return readl(gpio_in) & (1 << gpio);
 }
 
+static int titan_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
+{
+	struct ar7_gpio_chip *gpch =
+				container_of(chip, struct ar7_gpio_chip, chip);
+	void __iomem *gpio_in0 = gpch->regs + TITAN_GPIO_INPUT_0;
+	void __iomem *gpio_in1 = gpch->regs + TITAN_GPIO_INPUT_1;
+
+	return readl(gpio >> 5 ? gpio_in1 : gpio_in0) & (1 << (gpio & 0x1f));
+}
+
 static void ar7_gpio_set_value(struct gpio_chip *chip,
 				unsigned gpio, int value)
 {
@@ -51,6 +61,21 @@ static void ar7_gpio_set_value(struct gpio_chip *chip,
 	writel(tmp, gpio_out);
 }
 
+static void titan_gpio_set_value(struct gpio_chip *chip,
+				unsigned gpio, int value)
+{
+	struct ar7_gpio_chip *gpch =
+				container_of(chip, struct ar7_gpio_chip, chip);
+	void __iomem *gpio_out0 = gpch->regs + TITAN_GPIO_OUTPUT_0;
+	void __iomem *gpio_out1 = gpch->regs + TITAN_GPIO_OUTPUT_1;
+	unsigned tmp;
+
+	tmp = readl(gpio >> 5 ? gpio_out1 : gpio_out0) & ~(1 << (gpio & 0x1f));
+	if (value)
+		tmp |= 1 << (gpio & 0x1f);
+	writel(tmp, gpio >> 5 ? gpio_out1 : gpio_out0);
+}
+
 static int ar7_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
 {
 	struct ar7_gpio_chip *gpch =
@@ -62,6 +87,21 @@ static int ar7_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
 	return 0;
 }
 
+static int titan_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
+{
+	struct ar7_gpio_chip *gpch =
+				container_of(chip, struct ar7_gpio_chip, chip);
+	void __iomem *gpio_dir0 = gpch->regs + TITAN_GPIO_DIR_0;
+	void __iomem *gpio_dir1 = gpch->regs + TITAN_GPIO_DIR_1;
+
+	if (gpio >= TITAN_GPIO_MAX)
+		return -EINVAL;
+
+	writel(readl(gpio >> 5 ? gpio_dir1 : gpio_dir0) | (1 << (gpio & 0x1f)),
+			gpio >> 5 ? gpio_dir1 : gpio_dir0);
+	return 0;
+}
+
 static int ar7_gpio_direction_output(struct gpio_chip *chip,
 					unsigned gpio, int value)
 {
@@ -75,6 +115,24 @@ static int ar7_gpio_direction_output(struct gpio_chip *chip,
 	return 0;
 }
 
+static int titan_gpio_direction_output(struct gpio_chip *chip,
+					unsigned gpio, int value)
+{
+	struct ar7_gpio_chip *gpch =
+				container_of(chip, struct ar7_gpio_chip, chip);
+	void __iomem *gpio_dir0 = gpch->regs + TITAN_GPIO_DIR_0;
+	void __iomem *gpio_dir1 = gpch->regs + TITAN_GPIO_DIR_1;
+
+	if (gpio >= TITAN_GPIO_MAX)
+		return -EINVAL;
+
+	titan_gpio_set_value(chip, gpio, value);
+	writel(readl(gpio >> 5 ? gpio_dir1 : gpio_dir0) & ~(1 <<
+		(gpio & 0x1f)), gpio >> 5 ? gpio_dir1 : gpio_dir0);
+
+	return 0;
+}
+
 static struct ar7_gpio_chip ar7_gpio_chip = {
 	.chip = {
 		.label			= "ar7-gpio",
@@ -87,7 +145,19 @@ static struct ar7_gpio_chip ar7_gpio_chip = {
 	}
 };
 
-int ar7_gpio_enable(unsigned gpio)
+static struct ar7_gpio_chip titan_gpio_chip = {
+	.chip = {
+		.label			= "titan-gpio",
+		.direction_input	= titan_gpio_direction_input,
+		.direction_output	= titan_gpio_direction_output,
+		.set			= titan_gpio_set_value,
+		.get			= titan_gpio_get_value,
+		.base			= 0,
+		.ngpio			= TITAN_GPIO_MAX,
+	}
+};
+
+static inline int ar7_gpio_enable_ar7(unsigned gpio)
 {
 	void __iomem *gpio_en = ar7_gpio_chip.regs + AR7_GPIO_ENABLE;
 
@@ -95,9 +165,26 @@ int ar7_gpio_enable(unsigned gpio)
 
 	return 0;
 }
+
+static inline int ar7_gpio_enable_titan(unsigned gpio)
+{
+	void __iomem *gpio_en0 = titan_gpio_chip.regs  + TITAN_GPIO_ENBL_0;
+	void __iomem *gpio_en1 = titan_gpio_chip.regs  + TITAN_GPIO_ENBL_1;
+
+	writel(readl(gpio >> 5 ? gpio_en1 : gpio_en0) | (1 << (gpio & 0x1f)),
+		gpio >> 5 ? gpio_en1 : gpio_en0);
+
+	return 0;
+}
+
+int ar7_gpio_enable(unsigned gpio)
+{
+	return ar7_is_titan() ? ar7_gpio_enable_titan(gpio) :
+				ar7_gpio_enable_ar7(gpio);
+}
 EXPORT_SYMBOL(ar7_gpio_enable);
 
-int ar7_gpio_disable(unsigned gpio)
+static inline int ar7_gpio_disable_ar7(unsigned gpio)
 {
 	void __iomem *gpio_en = ar7_gpio_chip.regs + AR7_GPIO_ENABLE;
 
@@ -105,26 +192,159 @@ int ar7_gpio_disable(unsigned gpio)
 
 	return 0;
 }
+
+static inline int ar7_gpio_disable_titan(unsigned gpio)
+{
+	void __iomem *gpio_en0 = titan_gpio_chip.regs + TITAN_GPIO_ENBL_0;
+	void __iomem *gpio_en1 = titan_gpio_chip.regs + TITAN_GPIO_ENBL_1;
+
+	writel(readl(gpio >> 5 ? gpio_en1 : gpio_en0) & ~(1 << (gpio & 0x1f)),
+			gpio >> 5 ? gpio_en1 : gpio_en0);
+
+	return 0;
+}
+
+int ar7_gpio_disable(unsigned gpio)
+{
+	return ar7_is_titan() ? ar7_gpio_disable_titan(gpio) :
+				ar7_gpio_disable_ar7(gpio);
+}
 EXPORT_SYMBOL(ar7_gpio_disable);
 
+struct titan_gpio_cfg {
+	u32 reg;
+	u32 shift;
+	u32 func;
+};
+
+static struct titan_gpio_cfg titan_gpio_table[] = {
+	/* reg, start bit, mux value */
+	{4, 24, 1},
+	{4, 26, 1},
+	{4, 28, 1},
+	{4, 30, 1},
+	{5, 6, 1},
+	{5, 8, 1},
+	{5, 10, 1},
+	{5, 12, 1},
+	{7, 14, 3},
+	{7, 16, 3},
+	{7, 18, 3},
+	{7, 20, 3},
+	{7, 22, 3},
+	{7, 26, 3},
+	{7, 28, 3},
+	{7, 30, 3},
+	{8, 0, 3},
+	{8, 2, 3},
+	{8, 4, 3},
+	{8, 10, 3},
+	{8, 14, 3},
+	{8, 16, 3},
+	{8, 18, 3},
+	{8, 20, 3},
+	{9, 8, 3},
+	{9, 10, 3},
+	{9, 12, 3},
+	{9, 14, 3},
+	{9, 18, 3},
+	{9, 20, 3},
+	{9, 24, 3},
+	{9, 26, 3},
+	{9, 28, 3},
+	{9, 30, 3},
+	{10, 0, 3},
+	{10, 2, 3},
+	{10, 8, 3},
+	{10, 10, 3},
+	{10, 12, 3},
+	{10, 14, 3},
+	{13, 12, 3},
+	{13, 14, 3},
+	{13, 16, 3},
+	{13, 18, 3},
+	{13, 24, 3},
+	{13, 26, 3},
+	{13, 28, 3},
+	{13, 30, 3},
+	{14, 2, 3},
+	{14, 6, 3},
+	{14, 8, 3},
+	{14, 12, 3}
+};
+
+static int titan_gpio_pinsel(unsigned gpio)
+{
+	struct titan_gpio_cfg gpio_cfg;
+	u32 mux_status, pin_sel_reg, tmp;
+	void __iomem *pin_sel = (void __iomem *)KSEG1ADDR(AR7_REGS_PINSEL);
+
+	if (gpio >= ARRAY_SIZE(titan_gpio_table))
+		return -EINVAL;
+
+	gpio_cfg = titan_gpio_table[gpio];
+	pin_sel_reg = gpio_cfg.reg - 1;
+
+	mux_status = (readl(pin_sel + pin_sel_reg) >> gpio_cfg.shift) & 0x3;
+
+	/* Check the mux status */
+	if (!((mux_status == 0) || (mux_status == gpio_cfg.func)))
+		return 0;
+
+	/* Set the pin sel value */
+	tmp = readl(pin_sel + pin_sel_reg);
+	tmp |= ((gpio_cfg.func & 0x3) << gpio_cfg.shift);
+	writel(tmp, pin_sel + pin_sel_reg);
+
+	return 0;
+}
+
+/* Perform minimal Titan GPIO configuration */
+static void titan_gpio_init(void)
+{
+	unsigned i;
+
+	for (i = 44; i < 48; i++) {
+		titan_gpio_pinsel(i);
+		ar7_gpio_enable_titan(i);
+		titan_gpio_direction_input(&titan_gpio_chip.chip, i);
+	}
+}
+
 int __init ar7_gpio_init(void)
 {
 	int ret;
+	struct ar7_gpio_chip *gpch;
+	unsigned size;
+
+	if (!ar7_is_titan()) {
+		gpch = &ar7_gpio_chip;
+		size = 0x10;
+	} else {
+		gpch = &titan_gpio_chip;
+		size = 0x1f;
+	}
 
-	ar7_gpio_chip.regs = ioremap_nocache(AR7_REGS_GPIO,
+	gpch->regs = ioremap_nocache(AR7_REGS_GPIO,
 					AR7_REGS_GPIO + 0x10);
 
-	if (!ar7_gpio_chip.regs) {
-		printk(KERN_ERR "ar7-gpio: failed to ioremap regs\n");
+	if (!gpch->regs) {
+		printk(KERN_ERR "%s: failed to ioremap regs\n",
+					gpch->chip.label);
 		return -ENOMEM;
 	}
 
-	ret = gpiochip_add(&ar7_gpio_chip.chip);
+	ret = gpiochip_add(&gpch->chip);
 	if (ret) {
-		printk(KERN_ERR "ar7-gpio: failed to add gpiochip\n");
+		printk(KERN_ERR "%s: failed to add gpiochip\n",
+					gpch->chip.label);
 		return ret;
 	}
-	printk(KERN_INFO "ar7-gpio: registered %d GPIOs\n",
-				ar7_gpio_chip.chip.ngpio);
+	printk(KERN_INFO "%s: registered %d GPIOs\n",
+				gpch->chip.label, gpch->chip.ngpio);
+
+	if (ar7_is_titan())
+		titan_gpio_init();
+
 	return ret;
 }

commit 3bc6968adc7b1926f4582a33a33ad42d9b302ce0
Author: Florian Fainelli <florian@openwrt.org>
Date:   Sun Aug 29 17:08:41 2010 +0200

    MIPS: AR7: Initialize GPIO earlier
    
    In order to detect the Titan variant, we must initialize GPIOs earlier since
    detection relies on some GPIO values to be set.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/1562/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
    ---

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index c32fbb57441a..f84834229dcf 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -107,7 +107,7 @@ int ar7_gpio_disable(unsigned gpio)
 }
 EXPORT_SYMBOL(ar7_gpio_disable);
 
-static int __init ar7_gpio_init(void)
+int __init ar7_gpio_init(void)
 {
 	int ret;
 
@@ -128,4 +128,3 @@ static int __init ar7_gpio_init(void)
 				ar7_gpio_chip.chip.ngpio);
 	return ret;
 }
-arch_initcall(ar7_gpio_init);

commit 4d1da8c2961da46abd85a71d20f2b169bf80618e
Author: Alexander Clouter <alex@digriz.org.uk>
Date:   Sun Jan 31 19:38:19 2010 +0000

    MIPS: AR7: Whitespace hacking
    
    [Ralf: Fixed up reject and Wu's complaints about comment style.]
    
    Signed-off-by: Alexander Clouter <alex@digriz.org.uk>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/921/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index 0e9f4e13f427..c32fbb57441a 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -24,8 +24,8 @@
 #include <asm/mach-ar7/gpio.h>
 
 struct ar7_gpio_chip {
-	void __iomem	*regs;
-	struct gpio_chip chip;
+	void __iomem		*regs;
+	struct gpio_chip	chip;
 };
 
 static int ar7_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
@@ -77,7 +77,7 @@ static int ar7_gpio_direction_output(struct gpio_chip *chip,
 
 static struct ar7_gpio_chip ar7_gpio_chip = {
 	.chip = {
-		.label		= "ar7-gpio",
+		.label			= "ar7-gpio",
 		.direction_input	= ar7_gpio_direction_input,
 		.direction_output	= ar7_gpio_direction_output,
 		.set			= ar7_gpio_set_value,

commit 5f3c909881d5deebb9a3ddc836a15937e76daefc
Author: Florian Fainelli <florian@openwrt.org>
Date:   Sun Jan 3 21:16:51 2010 +0100

    MIPS: AR7: Implement gpiolib
    
    This patch implements gpiolib for the AR7 SoC.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/816/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
index 74e14a3dbf4a..0e9f4e13f427 100644
--- a/arch/mips/ar7/gpio.c
+++ b/arch/mips/ar7/gpio.c
@@ -1,6 +1,7 @@
 /*
  * Copyright (C) 2007 Felix Fietkau <nbd@openwrt.org>
  * Copyright (C) 2007 Eugene Konev <ejka@openwrt.org>
+ * Copyright (C) 2009 Florian Fainelli <florian@openwrt.org>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -18,31 +19,113 @@
  */
 
 #include <linux/module.h>
+#include <linux/gpio.h>
 
 #include <asm/mach-ar7/gpio.h>
 
-static const char *ar7_gpio_list[AR7_GPIO_MAX];
+struct ar7_gpio_chip {
+	void __iomem	*regs;
+	struct gpio_chip chip;
+};
 
-int gpio_request(unsigned gpio, const char *label)
+static int ar7_gpio_get_value(struct gpio_chip *chip, unsigned gpio)
 {
-	if (gpio >= AR7_GPIO_MAX)
-		return -EINVAL;
+	struct ar7_gpio_chip *gpch =
+				container_of(chip, struct ar7_gpio_chip, chip);
+	void __iomem *gpio_in = gpch->regs + AR7_GPIO_INPUT;
 
-	if (ar7_gpio_list[gpio])
-		return -EBUSY;
+	return readl(gpio_in) & (1 << gpio);
+}
+
+static void ar7_gpio_set_value(struct gpio_chip *chip,
+				unsigned gpio, int value)
+{
+	struct ar7_gpio_chip *gpch =
+				container_of(chip, struct ar7_gpio_chip, chip);
+	void __iomem *gpio_out = gpch->regs + AR7_GPIO_OUTPUT;
+	unsigned tmp;
+
+	tmp = readl(gpio_out) & ~(1 << gpio);
+	if (value)
+		tmp |= 1 << gpio;
+	writel(tmp, gpio_out);
+}
+
+static int ar7_gpio_direction_input(struct gpio_chip *chip, unsigned gpio)
+{
+	struct ar7_gpio_chip *gpch =
+				container_of(chip, struct ar7_gpio_chip, chip);
+	void __iomem *gpio_dir = gpch->regs + AR7_GPIO_DIR;
 
-	if (label)
-		ar7_gpio_list[gpio] = label;
-	else
-		ar7_gpio_list[gpio] = "busy";
+	writel(readl(gpio_dir) | (1 << gpio), gpio_dir);
 
 	return 0;
 }
-EXPORT_SYMBOL(gpio_request);
 
-void gpio_free(unsigned gpio)
+static int ar7_gpio_direction_output(struct gpio_chip *chip,
+					unsigned gpio, int value)
 {
-	BUG_ON(!ar7_gpio_list[gpio]);
-	ar7_gpio_list[gpio] = NULL;
+	struct ar7_gpio_chip *gpch =
+				container_of(chip, struct ar7_gpio_chip, chip);
+	void __iomem *gpio_dir = gpch->regs + AR7_GPIO_DIR;
+
+	ar7_gpio_set_value(chip, gpio, value);
+	writel(readl(gpio_dir) & ~(1 << gpio), gpio_dir);
+
+	return 0;
+}
+
+static struct ar7_gpio_chip ar7_gpio_chip = {
+	.chip = {
+		.label		= "ar7-gpio",
+		.direction_input	= ar7_gpio_direction_input,
+		.direction_output	= ar7_gpio_direction_output,
+		.set			= ar7_gpio_set_value,
+		.get			= ar7_gpio_get_value,
+		.base			= 0,
+		.ngpio			= AR7_GPIO_MAX,
+	}
+};
+
+int ar7_gpio_enable(unsigned gpio)
+{
+	void __iomem *gpio_en = ar7_gpio_chip.regs + AR7_GPIO_ENABLE;
+
+	writel(readl(gpio_en) | (1 << gpio), gpio_en);
+
+	return 0;
+}
+EXPORT_SYMBOL(ar7_gpio_enable);
+
+int ar7_gpio_disable(unsigned gpio)
+{
+	void __iomem *gpio_en = ar7_gpio_chip.regs + AR7_GPIO_ENABLE;
+
+	writel(readl(gpio_en) & ~(1 << gpio), gpio_en);
+
+	return 0;
+}
+EXPORT_SYMBOL(ar7_gpio_disable);
+
+static int __init ar7_gpio_init(void)
+{
+	int ret;
+
+	ar7_gpio_chip.regs = ioremap_nocache(AR7_REGS_GPIO,
+					AR7_REGS_GPIO + 0x10);
+
+	if (!ar7_gpio_chip.regs) {
+		printk(KERN_ERR "ar7-gpio: failed to ioremap regs\n");
+		return -ENOMEM;
+	}
+
+	ret = gpiochip_add(&ar7_gpio_chip.chip);
+	if (ret) {
+		printk(KERN_ERR "ar7-gpio: failed to add gpiochip\n");
+		return ret;
+	}
+	printk(KERN_INFO "ar7-gpio: registered %d GPIOs\n",
+				ar7_gpio_chip.chip.ngpio);
+	return ret;
 }
-EXPORT_SYMBOL(gpio_free);
+arch_initcall(ar7_gpio_init);

commit 7ca5dc145bc7daddd8aed8bbda46b74af9cebefc
Author: Florian Fainelli <florian@openwrt.org>
Date:   Wed Jun 24 11:12:57 2009 +0200

    MIPS: Add support for Texas Instruments AR7 System-on-a-Chip
    
    This patch adds support for the Texas Instruments AR7 System-on-a-Chip.
    It supports the TNETD7100, 7200 and 7300 versions of the SoC.
    
    Signed-off-by: Matteo Croce <matteo@openwrt.org>
    Signed-off-by: Felix Fietkau <nbd@openwrt.org>
    Signed-off-by: Eugene Konev <ejka@openwrt.org>
    Signed-off-by: Nicolas Thill <nico@openwrt.org>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/ar7/gpio.c b/arch/mips/ar7/gpio.c
new file mode 100644
index 000000000000..74e14a3dbf4a
--- /dev/null
+++ b/arch/mips/ar7/gpio.c
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2007 Felix Fietkau <nbd@openwrt.org>
+ * Copyright (C) 2007 Eugene Konev <ejka@openwrt.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <linux/module.h>
+
+#include <asm/mach-ar7/gpio.h>
+
+static const char *ar7_gpio_list[AR7_GPIO_MAX];
+
+int gpio_request(unsigned gpio, const char *label)
+{
+	if (gpio >= AR7_GPIO_MAX)
+		return -EINVAL;
+
+	if (ar7_gpio_list[gpio])
+		return -EBUSY;
+
+	if (label)
+		ar7_gpio_list[gpio] = label;
+	else
+		ar7_gpio_list[gpio] = "busy";
+
+	return 0;
+}
+EXPORT_SYMBOL(gpio_request);
+
+void gpio_free(unsigned gpio)
+{
+	BUG_ON(!ar7_gpio_list[gpio]);
+	ar7_gpio_list[gpio] = NULL;
+}
+EXPORT_SYMBOL(gpio_free);
