commit ac8fd122e070ce0e60c608d4f085f7af77290844
Author: afzal mohammed <afzal.mohd.ma@gmail.com>
Date:   Thu Mar 5 17:27:53 2020 +0530

    MIPS: Replace setup_irq() by request_irq()
    
    request_irq() is preferred over setup_irq(). Invocations of setup_irq()
    occur after memory allocators are ready.
    
    Per tglx[1], setup_irq() existed in olden days when allocators were not
    ready by the time early interrupts were initialized.
    
    Hence replace setup_irq() by request_irq().
    
    remove_irq() has been replaced by free_irq() as well.
    
    There were build error's during previous version, couple of which was
    reported by kbuild test robot <lkp@intel.com> of which one was reported
    by Thomas Bogendoerfer <tsbogend@alpha.franken.de> as well. There were a
    few more issues including build errors, those also have been fixed.
    
    [1] https://lkml.kernel.org/r/alpine.DEB.2.20.1710191609480.1971@nanos
    
    Signed-off-by: afzal mohammed <afzal.mohd.ma@gmail.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index ac61b90bcc66..dec89afc9886 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -27,7 +27,7 @@ asmlinkage void plat_irq_dispatch(void)
 }
 
 /* ISA irq handler */
-static irqreturn_t sni_isa_irq_handler(int dummy, void *p)
+irqreturn_t sni_isa_irq_handler(int dummy, void *p)
 {
 	int irq;
 
@@ -39,12 +39,6 @@ static irqreturn_t sni_isa_irq_handler(int dummy, void *p)
 	return IRQ_HANDLED;
 }
 
-struct irqaction sni_isa_irq = {
-	.handler = sni_isa_irq_handler,
-	.name = "ISA",
-	.flags = IRQF_SHARED
-};
-
 /*
  * On systems with i8259-style interrupt controllers we assume for
  * driver compatibility reasons interrupts 0 - 15 to be the i8295

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index 5a4ec75382e2..ac61b90bcc66 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -58,25 +58,25 @@ void __init arch_init_irq(void)
 	case SNI_BRD_10NEW:
 	case SNI_BRD_TOWER_OASIC:
 	case SNI_BRD_MINITOWER:
-	        sni_a20r_irq_init();
-	        break;
+		sni_a20r_irq_init();
+		break;
 
 	case SNI_BRD_PCI_TOWER:
-	        sni_pcit_irq_init();
-	        break;
+		sni_pcit_irq_init();
+		break;
 
 	case SNI_BRD_PCI_TOWER_CPLUS:
-	        sni_pcit_cplus_irq_init();
-	        break;
+		sni_pcit_cplus_irq_init();
+		break;
 
 	case SNI_BRD_RM200:
-	        sni_rm200_irq_init();
-	        break;
+		sni_rm200_irq_init();
+		break;
 
 	case SNI_BRD_PCI_MTOWER:
 	case SNI_BRD_PCI_DESKTOP:
 	case SNI_BRD_PCI_MTOWER_CPLUS:
-	        sni_pcimt_irq_init();
-	        break;
+		sni_pcimt_irq_init();
+		break;
 	}
 }

commit 8b5690f8847490c1e3ea47266819833a13621253
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Tue Nov 22 14:38:03 2011 +0000

    MIPS: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled and we even check
    and yell when an interrupt handler returns with interrupts enabled (see
    commit [b738a50a: genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    [ralf@linux-mips.org: Fixed up conflicts in
    arch/mips/alchemy/common/dbdma.c, arch/mips/cavium-octeon/smp.c and
    arch/mips/kernel/perf_event.c.]
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    To: linux-kernel@vger.kernel.org
    Cc: tglx@linutronix.de
    linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2835/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index e8e72bb3a9af..5a4ec75382e2 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -42,7 +42,7 @@ static irqreturn_t sni_isa_irq_handler(int dummy, void *p)
 struct irqaction sni_isa_irq = {
 	.handler = sni_isa_irq_handler,
 	.name = "ISA",
-	.flags = IRQF_SHARED | IRQF_DISABLED
+	.flags = IRQF_SHARED
 };
 
 /*

commit 231a35d37293ab88d325a9cb94e5474c156282c0
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Fri Jan 4 23:31:07 2008 +0100

    [MIPS] RM: Collected changes
    
    - EISA support for non PCI RMs (RM200 and RM400-xxx). The major part
      is the splitting of the EISA and onboard ISA of the RM200, which
      makes the EISA bus on the RM200 look like on other RMs.
    - 64bit kernel support
    - system type detection is now common for big and little endian
    - moved sniprom code to arch/mips/fw
    - added call_o32 function to arch/mips/fw/lib, which uses a private
      stack for calling prom functions
    - fix problem with ISA interrupts, which makes using PIT clockevent
      possible
    
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index 9ccffdfb8289..e8e72bb3a9af 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -35,14 +35,14 @@ static irqreturn_t sni_isa_irq_handler(int dummy, void *p)
 	if (unlikely(irq < 0))
 		return IRQ_NONE;
 
-	do_IRQ(irq);
+	generic_handle_irq(irq);
 	return IRQ_HANDLED;
 }
 
 struct irqaction sni_isa_irq = {
 	.handler = sni_isa_irq_handler,
 	.name = "ISA",
-	.flags = IRQF_SHARED
+	.flags = IRQF_SHARED | IRQF_DISABLED
 };
 
 /*

commit 2833bf68b9634a02895d9463349d8c21bd32ccf6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 8 00:28:52 2007 -0700

    Replace deprecated SA_xxx interrupt flags
    
    Fix the last users of the deprecated SA_xxx interrupt flags.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index ad5fc471a004..9ccffdfb8289 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -42,7 +42,7 @@ static irqreturn_t sni_isa_irq_handler(int dummy, void *p)
 struct irqaction sni_isa_irq = {
 	.handler = sni_isa_irq_handler,
 	.name = "ISA",
-	.flags = SA_SHIRQ
+	.flags = IRQF_SHARED
 };
 
 /*

commit c066a32a890c50ce59e91f8cea8eb5fd8d5821b9
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Thu Dec 28 18:22:32 2006 +0100

    [MIPS] Support for several more SNI RM models.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index 039e8e540508..ad5fc471a004 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -5,6 +5,7 @@
  *
  * Copyright (C) 1992 Linus Torvalds
  * Copyright (C) 1994 - 2000 Ralf Baechle
+ * Copyright (C) 2006 Thomas Bogendoerfer
  */
 #include <linux/delay.h>
 #include <linux/init.h>
@@ -15,152 +16,34 @@
 #include <asm/i8259.h>
 #include <asm/io.h>
 #include <asm/sni.h>
+#include <asm/irq.h>
+#include <asm/irq_cpu.h>
 
-static void enable_pciasic_irq(unsigned int irq)
-{
-	unsigned int mask = 1 << (irq - PCIMT_IRQ_INT2);
-
-	*(volatile u8 *) PCIMT_IRQSEL |= mask;
-}
-
-void disable_pciasic_irq(unsigned int irq)
-{
-	unsigned int mask = ~(1 << (irq - PCIMT_IRQ_INT2));
-
-	*(volatile u8 *) PCIMT_IRQSEL &= mask;
-}
+void (*sni_hwint)(void);
 
-static void end_pciasic_irq(unsigned int irq)
-{
-	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
-		enable_pciasic_irq(irq);
-}
-
-static struct irq_chip pciasic_irq_type = {
-	.name = "ASIC-PCI",
-	.ack = disable_pciasic_irq,
-	.mask = disable_pciasic_irq,
-	.mask_ack = disable_pciasic_irq,
-	.unmask = enable_pciasic_irq,
-	.end = end_pciasic_irq,
-};
-
-/*
- * hwint0 should deal with MP agent, ASIC PCI, EISA NMI and debug
- * button interrupts.  Later ...
- */
-static void pciasic_hwint0(void)
-{
-	panic("Received int0 but no handler yet ...");
-}
-
-/* This interrupt was used for the com1 console on the first prototypes.  */
-static void pciasic_hwint2(void)
-{
-	/* I think this shouldn't happen on production machines.  */
-	panic("hwint2 and no handler yet");
-}
-
-/* hwint5 is the r4k count / compare interrupt  */
-static void pciasic_hwint5(void)
-{
-	panic("hwint5 and no handler yet");
-}
-
-static unsigned int ls1bit8(unsigned int x)
-{
-	int b = 7, s;
-
-	s = 4; if ((x & 0x0f) == 0) s = 0; b -= s; x <<= s;
-	s = 2; if ((x & 0x30) == 0) s = 0; b -= s; x <<= s;
-	s = 1; if ((x & 0x40) == 0) s = 0; b -= s;
-
-	return b;
-}
-
-/*
- * hwint 1 deals with EISA and SCSI interrupts,
- *
- * The EISA_INT bit in CSITPEND is high active, all others are low active.
- */
-static void pciasic_hwint1(void)
+asmlinkage void plat_irq_dispatch(void)
 {
-	u8 pend = *(volatile char *)PCIMT_CSITPEND;
-	unsigned long flags;
-
-	if (pend & IT_EISA) {
-		int irq;
-		/*
-		 * Note: ASIC PCI's builtin interrupt achknowledge feature is
-		 * broken.  Using it may result in loss of some or all i8259
-		 * interupts, so don't use PCIMT_INT_ACKNOWLEDGE ...
-		 */
-		irq = i8259_irq();
-		if (unlikely(irq < 0))
-			return;
-
-		do_IRQ(irq);
-	}
-
-	if (!(pend & IT_SCSI)) {
-		flags = read_c0_status();
-		clear_c0_status(ST0_IM);
-		do_IRQ(PCIMT_IRQ_SCSI);
-		write_c0_status(flags);
-	}
+	sni_hwint();
 }
 
-/*
- * hwint 3 should deal with the PCI A - D interrupts,
- */
-static void pciasic_hwint3(void)
+/* ISA irq handler */
+static irqreturn_t sni_isa_irq_handler(int dummy, void *p)
 {
-	u8 pend = *(volatile char *)PCIMT_CSITPEND;
 	int irq;
 
-	pend &= (IT_INTA | IT_INTB | IT_INTC | IT_INTD);
-	clear_c0_status(IE_IRQ3);
-	irq = PCIMT_IRQ_INT2 + ls1bit8(pend);
-	do_IRQ(irq);
-	set_c0_status(IE_IRQ3);
-}
+	irq = i8259_irq();
+	if (unlikely(irq < 0))
+		return IRQ_NONE;
 
-/*
- * hwint 4 is used for only the onboard PCnet 32.
- */
-static void pciasic_hwint4(void)
-{
-	clear_c0_status(IE_IRQ4);
-	do_IRQ(PCIMT_IRQ_ETHERNET);
-	set_c0_status(IE_IRQ4);
-}
-
-asmlinkage void plat_irq_dispatch(void)
-{
-	unsigned int pending = read_c0_status() & read_c0_cause();
-	static unsigned char led_cache;
-
-	*(volatile unsigned char *) PCIMT_CSLED = ++led_cache;
-
-	if (pending & 0x0800)
-		pciasic_hwint1();
-	else if (pending & 0x4000)
-		pciasic_hwint4();
-	else if (pending & 0x2000)
-		pciasic_hwint3();
-	else if (pending & 0x1000)
-		pciasic_hwint2();
-	else if (pending & 0x8000)
-		pciasic_hwint5();
-	else if (pending & 0x0400)
-		pciasic_hwint0();
+	do_IRQ(irq);
+	return IRQ_HANDLED;
 }
 
-void __init init_pciasic(void)
-{
-	* (volatile u8 *) PCIMT_IRQSEL =
-		IT_EISA | IT_INTA | IT_INTB | IT_INTC | IT_INTD;
-}
+struct irqaction sni_isa_irq = {
+	.handler = sni_isa_irq_handler,
+	.name = "ISA",
+	.flags = SA_SHIRQ
+};
 
 /*
  * On systems with i8259-style interrupt controllers we assume for
@@ -169,14 +52,31 @@ void __init init_pciasic(void)
  */
 void __init arch_init_irq(void)
 {
-	int i;
-
 	init_i8259_irqs();			/* Integrated i8259  */
-	init_pciasic();
-
-	/* Actually we've got more interrupts to handle ...  */
-	for (i = PCIMT_IRQ_INT2; i <= PCIMT_IRQ_ETHERNET; i++)
-		set_irq_chip(i, &pciasic_irq_type);
-
-	change_c0_status(ST0_IM, IE_IRQ1|IE_IRQ2|IE_IRQ3|IE_IRQ4);
+	switch (sni_brd_type) {
+	case SNI_BRD_10:
+	case SNI_BRD_10NEW:
+	case SNI_BRD_TOWER_OASIC:
+	case SNI_BRD_MINITOWER:
+	        sni_a20r_irq_init();
+	        break;
+
+	case SNI_BRD_PCI_TOWER:
+	        sni_pcit_irq_init();
+	        break;
+
+	case SNI_BRD_PCI_TOWER_CPLUS:
+	        sni_pcit_cplus_irq_init();
+	        break;
+
+	case SNI_BRD_RM200:
+	        sni_rm200_irq_init();
+	        break;
+
+	case SNI_BRD_PCI_MTOWER:
+	case SNI_BRD_PCI_DESKTOP:
+	case SNI_BRD_PCI_MTOWER_CPLUS:
+	        sni_pcimt_irq_init();
+	        break;
+	}
 }

commit 70d21cdeef6331e67ed87262c894cd6601f0dccc
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Jan 15 00:07:25 2007 +0900

    [MIPS] use name instead of typename for each irq_chip
    
    The "typename" field was obsoleted by the "name" field.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index 8511bcc6d99d..039e8e540508 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -37,7 +37,7 @@ static void end_pciasic_irq(unsigned int irq)
 }
 
 static struct irq_chip pciasic_irq_type = {
-	.typename = "ASIC-PCI",
+	.name = "ASIC-PCI",
 	.ack = disable_pciasic_irq,
 	.mask = disable_pciasic_irq,
 	.mask_ack = disable_pciasic_irq,

commit 1603b5aca4f15b34848fb5594d0c7b6333b99144
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Nov 2 02:08:36 2006 +0900

    [MIPS] IRQ cleanups
    
    This is a big irq cleanup patch.
    
    * Use set_irq_chip() to register irq_chip.
    * Initialize .mask, .unmask, .mask_ack field.  Functions for these
      method are already exist in most case.
    * Do not initialize .startup, .shutdown, .enable, .disable fields if
      default routines provided by irq_chip_set_defaults() were suitable.
    * Remove redundant irq_desc initializations.
    * Remove unnecessary local_irq_save/local_irq_restore, spin_lock.
    
    With this cleanup, it would be easy to switch to slightly lightwait
    irq flow handlers (handle_level_irq(), etc.) instead of __do_IRQ().
    
    Though whole this patch is quite large, changes in each irq_chip are
    not quite simple.  Please review and test on your platform.  Thanks.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index 48fb74a7aaec..8511bcc6d99d 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -11,44 +11,25 @@
 #include <linux/interrupt.h>
 #include <linux/irq.h>
 #include <linux/kernel.h>
-#include <linux/spinlock.h>
 
 #include <asm/i8259.h>
 #include <asm/io.h>
 #include <asm/sni.h>
 
-DEFINE_SPINLOCK(pciasic_lock);
-
 static void enable_pciasic_irq(unsigned int irq)
 {
 	unsigned int mask = 1 << (irq - PCIMT_IRQ_INT2);
-	unsigned long flags;
 
-	spin_lock_irqsave(&pciasic_lock, flags);
 	*(volatile u8 *) PCIMT_IRQSEL |= mask;
-	spin_unlock_irqrestore(&pciasic_lock, flags);
-}
-
-static unsigned int startup_pciasic_irq(unsigned int irq)
-{
-	enable_pciasic_irq(irq);
-	return 0; /* never anything pending */
 }
 
-#define shutdown_pciasic_irq	disable_pciasic_irq
-
 void disable_pciasic_irq(unsigned int irq)
 {
 	unsigned int mask = ~(1 << (irq - PCIMT_IRQ_INT2));
-	unsigned long flags;
 
-	spin_lock_irqsave(&pciasic_lock, flags);
 	*(volatile u8 *) PCIMT_IRQSEL &= mask;
-	spin_unlock_irqrestore(&pciasic_lock, flags);
 }
 
-#define mask_and_ack_pciasic_irq disable_pciasic_irq
-
 static void end_pciasic_irq(unsigned int irq)
 {
 	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
@@ -57,11 +38,10 @@ static void end_pciasic_irq(unsigned int irq)
 
 static struct irq_chip pciasic_irq_type = {
 	.typename = "ASIC-PCI",
-	.startup = startup_pciasic_irq,
-	.shutdown = shutdown_pciasic_irq,
-	.enable = enable_pciasic_irq,
-	.disable = disable_pciasic_irq,
-	.ack = mask_and_ack_pciasic_irq,
+	.ack = disable_pciasic_irq,
+	.mask = disable_pciasic_irq,
+	.mask_ack = disable_pciasic_irq,
+	.unmask = enable_pciasic_irq,
 	.end = end_pciasic_irq,
 };
 
@@ -178,12 +158,8 @@ asmlinkage void plat_irq_dispatch(void)
 
 void __init init_pciasic(void)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&pciasic_lock, flags);
 	* (volatile u8 *) PCIMT_IRQSEL =
 		IT_EISA | IT_INTA | IT_INTB | IT_INTC | IT_INTD;
-	spin_unlock_irqrestore(&pciasic_lock, flags);
 }
 
 /*
@@ -199,12 +175,8 @@ void __init arch_init_irq(void)
 	init_pciasic();
 
 	/* Actually we've got more interrupts to handle ...  */
-	for (i = PCIMT_IRQ_INT2; i <= PCIMT_IRQ_ETHERNET; i++) {
-		irq_desc[i].status     = IRQ_DISABLED;
-		irq_desc[i].action     = 0;
-		irq_desc[i].depth      = 1;
-		irq_desc[i].chip    = &pciasic_irq_type;
-	}
+	for (i = PCIMT_IRQ_INT2; i <= PCIMT_IRQ_ETHERNET; i++)
+		set_irq_chip(i, &pciasic_irq_type);
 
 	change_c0_status(ST0_IM, IE_IRQ1|IE_IRQ2|IE_IRQ3|IE_IRQ4);
 }

commit 937a801576f954bd030d7c4a5a94571710d87c0b
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Oct 7 19:44:33 2006 +0100

    [MIPS] Complete fixes after removal of pt_regs argument to int handlers.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index cda165f42b6a..48fb74a7aaec 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -69,20 +69,20 @@ static struct irq_chip pciasic_irq_type = {
  * hwint0 should deal with MP agent, ASIC PCI, EISA NMI and debug
  * button interrupts.  Later ...
  */
-static void pciasic_hwint0(struct pt_regs *regs)
+static void pciasic_hwint0(void)
 {
 	panic("Received int0 but no handler yet ...");
 }
 
 /* This interrupt was used for the com1 console on the first prototypes.  */
-static void pciasic_hwint2(struct pt_regs *regs)
+static void pciasic_hwint2(void)
 {
 	/* I think this shouldn't happen on production machines.  */
 	panic("hwint2 and no handler yet");
 }
 
 /* hwint5 is the r4k count / compare interrupt  */
-static void pciasic_hwint5(struct pt_regs *regs)
+static void pciasic_hwint5(void)
 {
 	panic("hwint5 and no handler yet");
 }
@@ -103,7 +103,7 @@ static unsigned int ls1bit8(unsigned int x)
  *
  * The EISA_INT bit in CSITPEND is high active, all others are low active.
  */
-static void pciasic_hwint1(struct pt_regs *regs)
+static void pciasic_hwint1(void)
 {
 	u8 pend = *(volatile char *)PCIMT_CSITPEND;
 	unsigned long flags;
@@ -119,13 +119,13 @@ static void pciasic_hwint1(struct pt_regs *regs)
 		if (unlikely(irq < 0))
 			return;
 
-		do_IRQ(irq, regs);
+		do_IRQ(irq);
 	}
 
 	if (!(pend & IT_SCSI)) {
 		flags = read_c0_status();
 		clear_c0_status(ST0_IM);
-		do_IRQ(PCIMT_IRQ_SCSI, regs);
+		do_IRQ(PCIMT_IRQ_SCSI);
 		write_c0_status(flags);
 	}
 }
@@ -133,7 +133,7 @@ static void pciasic_hwint1(struct pt_regs *regs)
 /*
  * hwint 3 should deal with the PCI A - D interrupts,
  */
-static void pciasic_hwint3(struct pt_regs *regs)
+static void pciasic_hwint3(void)
 {
 	u8 pend = *(volatile char *)PCIMT_CSITPEND;
 	int irq;
@@ -141,21 +141,21 @@ static void pciasic_hwint3(struct pt_regs *regs)
 	pend &= (IT_INTA | IT_INTB | IT_INTC | IT_INTD);
 	clear_c0_status(IE_IRQ3);
 	irq = PCIMT_IRQ_INT2 + ls1bit8(pend);
-	do_IRQ(irq, regs);
+	do_IRQ(irq);
 	set_c0_status(IE_IRQ3);
 }
 
 /*
  * hwint 4 is used for only the onboard PCnet 32.
  */
-static void pciasic_hwint4(struct pt_regs *regs)
+static void pciasic_hwint4(void)
 {
 	clear_c0_status(IE_IRQ4);
-	do_IRQ(PCIMT_IRQ_ETHERNET, regs);
+	do_IRQ(PCIMT_IRQ_ETHERNET);
 	set_c0_status(IE_IRQ4);
 }
 
-asmlinkage void plat_irq_dispatch(struct pt_regs *regs)
+asmlinkage void plat_irq_dispatch(void)
 {
 	unsigned int pending = read_c0_status() & read_c0_cause();
 	static unsigned char led_cache;
@@ -163,17 +163,17 @@ asmlinkage void plat_irq_dispatch(struct pt_regs *regs)
 	*(volatile unsigned char *) PCIMT_CSLED = ++led_cache;
 
 	if (pending & 0x0800)
-		pciasic_hwint1(regs);
+		pciasic_hwint1();
 	else if (pending & 0x4000)
-		pciasic_hwint4(regs);
+		pciasic_hwint4();
 	else if (pending & 0x2000)
-		pciasic_hwint3(regs);
+		pciasic_hwint3();
 	else if (pending & 0x1000)
-		pciasic_hwint2(regs);
+		pciasic_hwint2();
 	else if (pending & 0x8000)
-		pciasic_hwint5(regs);
+		pciasic_hwint5();
 	else if (pending & 0x0400)
-		pciasic_hwint0(regs);
+		pciasic_hwint0();
 }
 
 void __init init_pciasic(void)

commit 94dee171df34b7955cd647da4c40ba67d55a7671
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sun Jul 2 14:41:42 2006 +0100

    [MIPS] Eleminate interrupt migration helper use.
    
    > #define hw_interrupt_type       irq_chip
    > typedef struct irq_chip         hw_irq_controller;
    > #define no_irq_type             no_irq_chip
    > typedef struct irq_desc         irq_desc_t;
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index c19e158ec402..cda165f42b6a 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -55,7 +55,7 @@ static void end_pciasic_irq(unsigned int irq)
 		enable_pciasic_irq(irq);
 }
 
-static struct hw_interrupt_type pciasic_irq_type = {
+static struct irq_chip pciasic_irq_type = {
 	.typename = "ASIC-PCI",
 	.startup = startup_pciasic_irq,
 	.shutdown = shutdown_pciasic_irq,

commit d1bef4ed5faf7d9872337b33c4269e45ae1bf960
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jun 29 02:24:36 2006 -0700

    [PATCH] genirq: rename desc->handler to desc->chip
    
    This patch-queue improves the generic IRQ layer to be truly generic, by adding
    various abstractions and features to it, without impacting existing
    functionality.
    
    While the queue can be best described as "fix and improve everything in the
    generic IRQ layer that we could think of", and thus it consists of many
    smaller features and lots of cleanups, the one feature that stands out most is
    the new 'irq chip' abstraction.
    
    The irq-chip abstraction is about describing and coding and IRQ controller
    driver by mapping its raw hardware capabilities [and quirks, if needed] in a
    straightforward way, without having to think about "IRQ flow"
    (level/edge/etc.) type of details.
    
    This stands in contrast with the current 'irq-type' model of genirq
    architectures, which 'mixes' raw hardware capabilities with 'flow' details.
    The patchset supports both types of irq controller designs at once, and
    converts i386 and x86_64 to the new irq-chip design.
    
    As a bonus side-effect of the irq-chip approach, chained interrupt controllers
    (master/slave PIC constructs, etc.) are now supported by design as well.
    
    The end result of this patchset intends to be simpler architecture-level code
    and more consolidation between architectures.
    
    We reused many bits of code and many concepts from Russell King's ARM IRQ
    layer, the merging of which was one of the motivations for this patchset.
    
    This patch:
    
    rename desc->handler to desc->chip.
    
    Originally i did not want to do this, because it's a big patch.  But having
    both "desc->handler", "desc->handle_irq" and "action->handler" caused a
    large degree of confusion and made the code appear alot less clean than it
    truly is.
    
    I have also attempted a dual approach as well by introducing a
    desc->chip alias - but that just wasnt robust enough and broke
    frequently.
    
    So lets get over with this quickly.  The conversion was done automatically
    via scripts and converts all the code in the kernel.
    
    This renaming patch is the first one amongst the patches, so that the
    remaining patches can stay flexible and can be merged and split up
    without having some big monolithic patch act as a merge barrier.
    
    [akpm@osdl.org: build fix]
    [akpm@osdl.org: another build fix]
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index 7365b4853ddb..c19e158ec402 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -203,7 +203,7 @@ void __init arch_init_irq(void)
 		irq_desc[i].status     = IRQ_DISABLED;
 		irq_desc[i].action     = 0;
 		irq_desc[i].depth      = 1;
-		irq_desc[i].handler    = &pciasic_irq_type;
+		irq_desc[i].chip    = &pciasic_irq_type;
 	}
 
 	change_c0_status(ST0_IM, IE_IRQ1|IE_IRQ2|IE_IRQ3|IE_IRQ4);

commit e4ac58afdfac792c0583af30dbd9eae53e24c78b
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Apr 3 17:56:36 2006 +0100

    [MIPS] Rewrite all the assembler interrupt handlers to C.
    
    Saves like 1,600 lines of code, is way easier to debug, compilers
    frequently do a better job than the cut and paste type of handlers many
    boards had.  And finally having all the stuff done in a single place
    also means alot of bug potencial for the MT ASE is gone.
    
    The only surviving handler in assembler is the DECstation one; I hope
    Maciej will rewrite it.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index 952038aa4b90..7365b4853ddb 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -19,8 +19,6 @@
 
 DEFINE_SPINLOCK(pciasic_lock);
 
-extern asmlinkage void sni_rm200_pci_handle_int(void);
-
 static void enable_pciasic_irq(unsigned int irq)
 {
 	unsigned int mask = 1 << (irq - PCIMT_IRQ_INT2);
@@ -71,20 +69,20 @@ static struct hw_interrupt_type pciasic_irq_type = {
  * hwint0 should deal with MP agent, ASIC PCI, EISA NMI and debug
  * button interrupts.  Later ...
  */
-void pciasic_hwint0(struct pt_regs *regs)
+static void pciasic_hwint0(struct pt_regs *regs)
 {
 	panic("Received int0 but no handler yet ...");
 }
 
 /* This interrupt was used for the com1 console on the first prototypes.  */
-void pciasic_hwint2(struct pt_regs *regs)
+static void pciasic_hwint2(struct pt_regs *regs)
 {
 	/* I think this shouldn't happen on production machines.  */
 	panic("hwint2 and no handler yet");
 }
 
 /* hwint5 is the r4k count / compare interrupt  */
-void pciasic_hwint5(struct pt_regs *regs)
+static void pciasic_hwint5(struct pt_regs *regs)
 {
 	panic("hwint5 and no handler yet");
 }
@@ -105,7 +103,7 @@ static unsigned int ls1bit8(unsigned int x)
  *
  * The EISA_INT bit in CSITPEND is high active, all others are low active.
  */
-void pciasic_hwint1(struct pt_regs *regs)
+static void pciasic_hwint1(struct pt_regs *regs)
 {
 	u8 pend = *(volatile char *)PCIMT_CSITPEND;
 	unsigned long flags;
@@ -135,7 +133,7 @@ void pciasic_hwint1(struct pt_regs *regs)
 /*
  * hwint 3 should deal with the PCI A - D interrupts,
  */
-void pciasic_hwint3(struct pt_regs *regs)
+static void pciasic_hwint3(struct pt_regs *regs)
 {
 	u8 pend = *(volatile char *)PCIMT_CSITPEND;
 	int irq;
@@ -150,13 +148,34 @@ void pciasic_hwint3(struct pt_regs *regs)
 /*
  * hwint 4 is used for only the onboard PCnet 32.
  */
-void pciasic_hwint4(struct pt_regs *regs)
+static void pciasic_hwint4(struct pt_regs *regs)
 {
 	clear_c0_status(IE_IRQ4);
 	do_IRQ(PCIMT_IRQ_ETHERNET, regs);
 	set_c0_status(IE_IRQ4);
 }
 
+asmlinkage void plat_irq_dispatch(struct pt_regs *regs)
+{
+	unsigned int pending = read_c0_status() & read_c0_cause();
+	static unsigned char led_cache;
+
+	*(volatile unsigned char *) PCIMT_CSLED = ++led_cache;
+
+	if (pending & 0x0800)
+		pciasic_hwint1(regs);
+	else if (pending & 0x4000)
+		pciasic_hwint4(regs);
+	else if (pending & 0x2000)
+		pciasic_hwint3(regs);
+	else if (pending & 0x1000)
+		pciasic_hwint2(regs);
+	else if (pending & 0x8000)
+		pciasic_hwint5(regs);
+	else if (pending & 0x0400)
+		pciasic_hwint0(regs);
+}
+
 void __init init_pciasic(void)
 {
 	unsigned long flags;
@@ -176,8 +195,6 @@ void __init arch_init_irq(void)
 {
 	int i;
 
-	set_except_vector(0, sni_rm200_pci_handle_int);
-
 	init_i8259_irqs();			/* Integrated i8259  */
 	init_pciasic();
 

commit 8ab00b9a02c55fd6263c5f7c0dc88389d94de327
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Feb 28 13:39:57 2005 +0000

    Convert struct hw_interrupt_type initializations to ISO C99 named
    initializers.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index 141a310d74d8..952038aa4b90 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -58,14 +58,13 @@ static void end_pciasic_irq(unsigned int irq)
 }
 
 static struct hw_interrupt_type pciasic_irq_type = {
-	"ASIC-PCI",
-	startup_pciasic_irq,
-	shutdown_pciasic_irq,
-	enable_pciasic_irq,
-	disable_pciasic_irq,
-	mask_and_ack_pciasic_irq,
-	end_pciasic_irq,
-	NULL
+	.typename = "ASIC-PCI",
+	.startup = startup_pciasic_irq,
+	.shutdown = shutdown_pciasic_irq,
+	.enable = enable_pciasic_irq,
+	.disable = disable_pciasic_irq,
+	.ack = mask_and_ack_pciasic_irq,
+	.end = end_pciasic_irq,
 };
 
 /*

commit 42a3b4f25af8f8d77feddf27f839fa0628dbff1a
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Sep 3 15:56:17 2005 -0700

    [PATCH] mips: nuke trailing whitespace
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
index 62c760f14674..141a310d74d8 100644
--- a/arch/mips/sni/irq.c
+++ b/arch/mips/sni/irq.c
@@ -103,7 +103,7 @@ static unsigned int ls1bit8(unsigned int x)
 
 /*
  * hwint 1 deals with EISA and SCSI interrupts,
- * 
+ *
  * The EISA_INT bit in CSITPEND is high active, all others are low active.
  */
 void pciasic_hwint1(struct pt_regs *regs)

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/sni/irq.c b/arch/mips/sni/irq.c
new file mode 100644
index 000000000000..62c760f14674
--- /dev/null
+++ b/arch/mips/sni/irq.c
@@ -0,0 +1,194 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1992 Linus Torvalds
+ * Copyright (C) 1994 - 2000 Ralf Baechle
+ */
+#include <linux/delay.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+
+#include <asm/i8259.h>
+#include <asm/io.h>
+#include <asm/sni.h>
+
+DEFINE_SPINLOCK(pciasic_lock);
+
+extern asmlinkage void sni_rm200_pci_handle_int(void);
+
+static void enable_pciasic_irq(unsigned int irq)
+{
+	unsigned int mask = 1 << (irq - PCIMT_IRQ_INT2);
+	unsigned long flags;
+
+	spin_lock_irqsave(&pciasic_lock, flags);
+	*(volatile u8 *) PCIMT_IRQSEL |= mask;
+	spin_unlock_irqrestore(&pciasic_lock, flags);
+}
+
+static unsigned int startup_pciasic_irq(unsigned int irq)
+{
+	enable_pciasic_irq(irq);
+	return 0; /* never anything pending */
+}
+
+#define shutdown_pciasic_irq	disable_pciasic_irq
+
+void disable_pciasic_irq(unsigned int irq)
+{
+	unsigned int mask = ~(1 << (irq - PCIMT_IRQ_INT2));
+	unsigned long flags;
+
+	spin_lock_irqsave(&pciasic_lock, flags);
+	*(volatile u8 *) PCIMT_IRQSEL &= mask;
+	spin_unlock_irqrestore(&pciasic_lock, flags);
+}
+
+#define mask_and_ack_pciasic_irq disable_pciasic_irq
+
+static void end_pciasic_irq(unsigned int irq)
+{
+	if (!(irq_desc[irq].status & (IRQ_DISABLED|IRQ_INPROGRESS)))
+		enable_pciasic_irq(irq);
+}
+
+static struct hw_interrupt_type pciasic_irq_type = {
+	"ASIC-PCI",
+	startup_pciasic_irq,
+	shutdown_pciasic_irq,
+	enable_pciasic_irq,
+	disable_pciasic_irq,
+	mask_and_ack_pciasic_irq,
+	end_pciasic_irq,
+	NULL
+};
+
+/*
+ * hwint0 should deal with MP agent, ASIC PCI, EISA NMI and debug
+ * button interrupts.  Later ...
+ */
+void pciasic_hwint0(struct pt_regs *regs)
+{
+	panic("Received int0 but no handler yet ...");
+}
+
+/* This interrupt was used for the com1 console on the first prototypes.  */
+void pciasic_hwint2(struct pt_regs *regs)
+{
+	/* I think this shouldn't happen on production machines.  */
+	panic("hwint2 and no handler yet");
+}
+
+/* hwint5 is the r4k count / compare interrupt  */
+void pciasic_hwint5(struct pt_regs *regs)
+{
+	panic("hwint5 and no handler yet");
+}
+
+static unsigned int ls1bit8(unsigned int x)
+{
+	int b = 7, s;
+
+	s = 4; if ((x & 0x0f) == 0) s = 0; b -= s; x <<= s;
+	s = 2; if ((x & 0x30) == 0) s = 0; b -= s; x <<= s;
+	s = 1; if ((x & 0x40) == 0) s = 0; b -= s;
+
+	return b;
+}
+
+/*
+ * hwint 1 deals with EISA and SCSI interrupts,
+ * 
+ * The EISA_INT bit in CSITPEND is high active, all others are low active.
+ */
+void pciasic_hwint1(struct pt_regs *regs)
+{
+	u8 pend = *(volatile char *)PCIMT_CSITPEND;
+	unsigned long flags;
+
+	if (pend & IT_EISA) {
+		int irq;
+		/*
+		 * Note: ASIC PCI's builtin interrupt achknowledge feature is
+		 * broken.  Using it may result in loss of some or all i8259
+		 * interupts, so don't use PCIMT_INT_ACKNOWLEDGE ...
+		 */
+		irq = i8259_irq();
+		if (unlikely(irq < 0))
+			return;
+
+		do_IRQ(irq, regs);
+	}
+
+	if (!(pend & IT_SCSI)) {
+		flags = read_c0_status();
+		clear_c0_status(ST0_IM);
+		do_IRQ(PCIMT_IRQ_SCSI, regs);
+		write_c0_status(flags);
+	}
+}
+
+/*
+ * hwint 3 should deal with the PCI A - D interrupts,
+ */
+void pciasic_hwint3(struct pt_regs *regs)
+{
+	u8 pend = *(volatile char *)PCIMT_CSITPEND;
+	int irq;
+
+	pend &= (IT_INTA | IT_INTB | IT_INTC | IT_INTD);
+	clear_c0_status(IE_IRQ3);
+	irq = PCIMT_IRQ_INT2 + ls1bit8(pend);
+	do_IRQ(irq, regs);
+	set_c0_status(IE_IRQ3);
+}
+
+/*
+ * hwint 4 is used for only the onboard PCnet 32.
+ */
+void pciasic_hwint4(struct pt_regs *regs)
+{
+	clear_c0_status(IE_IRQ4);
+	do_IRQ(PCIMT_IRQ_ETHERNET, regs);
+	set_c0_status(IE_IRQ4);
+}
+
+void __init init_pciasic(void)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&pciasic_lock, flags);
+	* (volatile u8 *) PCIMT_IRQSEL =
+		IT_EISA | IT_INTA | IT_INTB | IT_INTC | IT_INTD;
+	spin_unlock_irqrestore(&pciasic_lock, flags);
+}
+
+/*
+ * On systems with i8259-style interrupt controllers we assume for
+ * driver compatibility reasons interrupts 0 - 15 to be the i8295
+ * interrupts even if the hardware uses a different interrupt numbering.
+ */
+void __init arch_init_irq(void)
+{
+	int i;
+
+	set_except_vector(0, sni_rm200_pci_handle_int);
+
+	init_i8259_irqs();			/* Integrated i8259  */
+	init_pciasic();
+
+	/* Actually we've got more interrupts to handle ...  */
+	for (i = PCIMT_IRQ_INT2; i <= PCIMT_IRQ_ETHERNET; i++) {
+		irq_desc[i].status     = IRQ_DISABLED;
+		irq_desc[i].action     = 0;
+		irq_desc[i].depth      = 1;
+		irq_desc[i].handler    = &pciasic_irq_type;
+	}
+
+	change_c0_status(ST0_IM, IE_IRQ1|IE_IRQ2|IE_IRQ3|IE_IRQ4);
+}
