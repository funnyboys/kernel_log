commit 42b76a1d6dfede2a412567d37bd0df0cfac99adf
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Jan 17 16:18:47 2017 +0100

    MIPS: Avoid old-style declaration
    
    gcc warns about nonstandard declarations:
    
    arch/mips/sgi-ip32/ip32-irq.c:31:1: error: 'inline' is not at beginning of declaration [-Werror=old-style-declaration]
    arch/mips/sgi-ip32/ip32-irq.c:36:1: error: 'inline' is not at beginning of declaration [-Werror=old-style-declaration]
    arch/mips/sgi-ip27/ip27-klnuma.c: In function 'replicate_kernel_text':
    arch/mips/sgi-ip27/ip27-klnuma.c:85:116: error: old-style function definition [-Werror=old-style-definition]
    
    Moving 'inline' before the return type, and adding argument types
    shuts up the warning here. This patch affects several platforms,
    but all in a trivial way. I'm fixing up all instances I found in
    any of the 'defconfig' builds.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/15050/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index 87d7846af2d0..d61004dd71b4 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -197,7 +197,7 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 	}
 }
 
-void xlp_wakeup_secondary_cpus()
+void xlp_wakeup_secondary_cpus(void)
 {
 	/*
 	 * In case of u-boot, the secondaries are in reset

commit c2736525465a5d6fe1456da8cc2bc701f9128682
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Wed Jan 7 16:58:30 2015 +0530

    MIPS: Netlogic: Move cores per node out of multi-node.h
    
    Use the current_cpu_data package field to get the node of the current CPU.
    
    This allows us to remove xlp_cores_per_node and move nlm_threads_per_node()
    and nlm_cores_per_node() to netlogic/common.h, which simplifies code.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/8889/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index 26d82f79ef29..87d7846af2d0 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -111,7 +111,7 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 	struct nlm_soc_info *nodep;
 	uint64_t syspcibase, fusebase;
 	uint32_t syscoremask, mask, fusemask;
-	int core, n, cpu;
+	int core, n, cpu, ncores;
 
 	for (n = 0; n < NLM_NR_NODES; n++) {
 		if (n != 0) {
@@ -168,7 +168,8 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 		syscoremask = (1 << hweight32(~fusemask & mask)) - 1;
 
 		pr_info("Node %d - SYS/FUSE coremask %x\n", n, syscoremask);
-		for (core = 0; core < nlm_cores_per_node(); core++) {
+		ncores = nlm_cores_per_node();
+		for (core = 0; core < ncores; core++) {
 			/* we will be on node 0 core 0 */
 			if (n == 0 && core == 0)
 				continue;
@@ -178,8 +179,7 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 				continue;
 
 			/* see if at least the first hw thread is enabled */
-			cpu = (n * nlm_cores_per_node() + core)
-						* NLM_THREADS_PER_CORE;
+			cpu = (n * ncores + core) * NLM_THREADS_PER_CORE;
 			if (!cpumask_test_cpu(cpu, wakeup_mask))
 				continue;
 

commit 46ab6f24ac7b05c07e2936124b45da5f2f8fdc61
Author: Shanghui Liu <shliu@broadcom.com>
Date:   Wed Jan 7 16:58:22 2015 +0530

    MIPS: Netlogic: Fix wait for slave CPUs
    
    For core 0, the condition of "cpu == bootcpu" is always true, so it
    does not wait for other three threads to become ready. Fix this by
    using correct check.
    
    Signed-off-by: Shanghui Liu <shliu@broadcom.com>
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/8881/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index e5f44d2605a8..26d82f79ef29 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -99,7 +99,7 @@ static int wait_for_cpus(int cpu, int bootcpu)
 	do {
 		notready = nlm_threads_per_core;
 		for (i = 0; i < nlm_threads_per_core; i++)
-			if (cpu_ready[cpu + i] || cpu == bootcpu)
+			if (cpu_ready[cpu + i] || (cpu + i) == bootcpu)
 				--notready;
 	} while (notready != 0 && --count > 0);
 

commit 1c98398662c9b4e2f03f64344f83dd6cb14e0420
Author: Yonghong Song <ysong@broadcom.com>
Date:   Tue Apr 29 20:07:53 2014 +0530

    MIPS: Netlogic: Add support for XLP5XX
    
    Add support for the XLP5XX processor which is an 8 core variant of the
    XLP9XX. Add XLP5XX cases to code which earlier handled XLP9XX.
    
    Signed-off-by: Yonghong Song <ysong@broadcom.com>
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6871/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index f4823ad6145f..e5f44d2605a8 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -135,7 +135,15 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 		if (cpu_is_xlp9xx()) {
 			fusebase = nlm_get_fuse_regbase(n);
 			fusemask = nlm_read_reg(fusebase, FUSE_9XX_DEVCFG6);
-			mask = 0xfffff;
+			switch (read_c0_prid() & PRID_IMP_MASK) {
+			case PRID_IMP_NETLOGIC_XLP5XX:
+				mask = 0xff;
+				break;
+			case PRID_IMP_NETLOGIC_XLP9XX:
+			default:
+				mask = 0xfffff;
+				break;
+			}
 		} else {
 			fusemask = nlm_read_sys_reg(nodep->sysbase,
 						SYS_EFUSE_DEVICE_CFG_STATUS0);

commit 5874743ea8479b780799927f25580ef134547f0f
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Tue Apr 29 20:07:49 2014 +0530

    MIPS: Netlogic: Use PRID_IMP_MASK macro
    
    Use PRID_IMP_MASK macro instead of 0xff00 to extract the processor
    type.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6868/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index 758923865886..f4823ad6145f 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -139,7 +139,7 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 		} else {
 			fusemask = nlm_read_sys_reg(nodep->sysbase,
 						SYS_EFUSE_DEVICE_CFG_STATUS0);
-			switch (read_c0_prid() & 0xff00) {
+			switch (read_c0_prid() & PRID_IMP_MASK) {
 			case PRID_IMP_NETLOGIC_XLP3XX:
 				mask = 0xf;
 				break;

commit 3e468567c2d56441079db090b3771bfc9d91cba5
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Tue Apr 29 20:07:42 2014 +0530

    MIPS: Netlogic: Move coremask setup to nlm_node_init
    
    This is needed for nlm_node_present(0) to work on uniprocessor compile.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6861/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index 9a92617a2af5..758923865886 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -159,10 +159,6 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 		 */
 		syscoremask = (1 << hweight32(~fusemask & mask)) - 1;
 
-		/* The boot cpu */
-		if (n == 0)
-			nodep->coremask = 1;
-
 		pr_info("Node %d - SYS/FUSE coremask %x\n", n, syscoremask);
 		for (core = 0; core < nlm_cores_per_node(); core++) {
 			/* we will be on node 0 core 0 */

commit 3b2663ca844648c1b511f4dc8b1d5918174da58b
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Mon Jan 6 14:59:30 2014 -0500

    mips: delete non-required instances of include <linux/init.h>
    
    None of these files are actually using any __init type directives
    and hence don't need to include <linux/init.h>.  Most are just a
    left over from __devinit and __cpuinit removal, or simply due to
    code getting copied from one driver to the next.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6320/

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index 4eb7cdb8a0ff..9a92617a2af5 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -32,7 +32,6 @@
  * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/threads.h>
 

commit e92e1d0d789634f8136c7ca1cb7d679acc3c52b0
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Tue Jan 14 12:39:15 2014 +0100

    MIPS: Netlogic: Core wakeup improvements
    
    Move wakeup to after early console. This will allow us to display error
    messages when cores are not woken up.  Also reduce the wait time for core
    to come up.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6303/

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index bbd53f8e92db..4eb7cdb8a0ff 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -96,7 +96,7 @@ static int wait_for_cpus(int cpu, int bootcpu)
 	volatile uint32_t *cpu_ready = nlm_get_boot_data(BOOT_CPU_READY);
 	int i, count, notready;
 
-	count = 0x20000000;
+	count = 0x800000;
 	do {
 		notready = nlm_threads_per_core;
 		for (i = 0; i < nlm_threads_per_core; i++)
@@ -188,7 +188,8 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 			nodep->coremask |= 1u << core;
 
 			/* spin until the hw threads sets their ready */
-			wait_for_cpus(cpu, 0);
+			if (!wait_for_cpus(cpu, 0))
+				pr_err("Node %d : timeout core %d\n", n, core);
 		}
 	}
 }
@@ -200,7 +201,8 @@ void xlp_wakeup_secondary_cpus()
 	 * first wakeup core 0 threads
 	 */
 	xlp_boot_core0_siblings();
-	wait_for_cpus(0, 0);
+	if (!wait_for_cpus(0, 0))
+		pr_err("Node 0 : timeout core 0\n");
 
 	/* now get other cores out of reset */
 	xlp_enable_secondary_cores(&nlm_cpumask);

commit 98d4884ca55883e8b16180bd969a8bccaa885c80
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Sat Dec 21 16:52:26 2013 +0530

    MIPS: Netlogic: Add cpu to node mapping for XLP9XX
    
    XLP9XX has 20 cores per node, opposed to 8 on earlier XLP8XX.
    Update code that calculates node id from cpu id to handle this.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6283/

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index a5d6647e5fe8..bbd53f8e92db 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -165,7 +165,7 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 			nodep->coremask = 1;
 
 		pr_info("Node %d - SYS/FUSE coremask %x\n", n, syscoremask);
-		for (core = 0; core < NLM_CORES_PER_NODE; core++) {
+		for (core = 0; core < nlm_cores_per_node(); core++) {
 			/* we will be on node 0 core 0 */
 			if (n == 0 && core == 0)
 				continue;
@@ -175,7 +175,7 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 				continue;
 
 			/* see if at least the first hw thread is enabled */
-			cpu = (n * NLM_CORES_PER_NODE + core)
+			cpu = (n * nlm_cores_per_node() + core)
 						* NLM_THREADS_PER_CORE;
 			if (!cpumask_test_cpu(cpu, wakeup_mask))
 				continue;

commit 861c056953dc4354414881a5e1d382297ef4ea53
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Sat Dec 21 16:52:23 2013 +0530

    MIPS: Netlogic: SYS block updates of XLP9XX
    
    Add the SYS block registers for XLP9XX, most of them have changed.
    The wakeup sequence has been updated to set the coherent mode from
    the main thread rather than the woken up thread.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6280/

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index f11035b1ad11..a5d6647e5fe8 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -54,7 +54,7 @@
 static int xlp_wakeup_core(uint64_t sysbase, int node, int core)
 {
 	uint32_t coremask, value;
-	int count;
+	int count, resetreg;
 
 	coremask = (1 << core);
 
@@ -65,12 +65,24 @@ static int xlp_wakeup_core(uint64_t sysbase, int node, int core)
 		nlm_write_sys_reg(sysbase, SYS_CORE_DFS_DIS_CTRL, value);
 	}
 
+	/* On 9XX, mark coherent first */
+	if (cpu_is_xlp9xx()) {
+		value = nlm_read_sys_reg(sysbase, SYS_9XX_CPU_NONCOHERENT_MODE);
+		value &= ~coremask;
+		nlm_write_sys_reg(sysbase, SYS_9XX_CPU_NONCOHERENT_MODE, value);
+	}
+
 	/* Remove CPU Reset */
-	value = nlm_read_sys_reg(sysbase, SYS_CPU_RESET);
+	resetreg = cpu_is_xlp9xx() ? SYS_9XX_CPU_RESET : SYS_CPU_RESET;
+	value = nlm_read_sys_reg(sysbase, resetreg);
 	value &= ~coremask;
-	nlm_write_sys_reg(sysbase, SYS_CPU_RESET, value);
+	nlm_write_sys_reg(sysbase, resetreg, value);
+
+	/* We are done on 9XX */
+	if (cpu_is_xlp9xx())
+		return 1;
 
-	/* Poll for CPU to mark itself coherent */
+	/* Poll for CPU to mark itself coherent on other type of XLP */
 	count = 100000;
 	do {
 		value = nlm_read_sys_reg(sysbase, SYS_CPU_NONCOHERENT_MODE);
@@ -98,33 +110,48 @@ static int wait_for_cpus(int cpu, int bootcpu)
 static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 {
 	struct nlm_soc_info *nodep;
-	uint64_t syspcibase;
+	uint64_t syspcibase, fusebase;
 	uint32_t syscoremask, mask, fusemask;
 	int core, n, cpu;
 
 	for (n = 0; n < NLM_NR_NODES; n++) {
-		syspcibase = nlm_get_sys_pcibase(n);
-		if (nlm_read_reg(syspcibase, 0) == 0xffffffff)
-			break;
+		if (n != 0) {
+			/* check if node exists and is online */
+			if (cpu_is_xlp9xx()) {
+				int b = xlp9xx_get_socbus(n);
+				pr_info("Node %d SoC PCI bus %d.\n", n, b);
+				if (b == 0)
+					break;
+			} else {
+				syspcibase = nlm_get_sys_pcibase(n);
+				if (nlm_read_reg(syspcibase, 0) == 0xffffffff)
+					break;
+			}
+			nlm_node_init(n);
+		}
 
 		/* read cores in reset from SYS */
-		if (n != 0)
-			nlm_node_init(n);
 		nodep = nlm_get_node(n);
 
-		fusemask = nlm_read_sys_reg(nodep->sysbase,
-					SYS_EFUSE_DEVICE_CFG_STATUS0);
-		switch (read_c0_prid() & 0xff00) {
-		case PRID_IMP_NETLOGIC_XLP3XX:
-			mask = 0xf;
-			break;
-		case PRID_IMP_NETLOGIC_XLP2XX:
-			mask = 0x3;
-			break;
-		case PRID_IMP_NETLOGIC_XLP8XX:
-		default:
-			mask = 0xff;
-			break;
+		if (cpu_is_xlp9xx()) {
+			fusebase = nlm_get_fuse_regbase(n);
+			fusemask = nlm_read_reg(fusebase, FUSE_9XX_DEVCFG6);
+			mask = 0xfffff;
+		} else {
+			fusemask = nlm_read_sys_reg(nodep->sysbase,
+						SYS_EFUSE_DEVICE_CFG_STATUS0);
+			switch (read_c0_prid() & 0xff00) {
+			case PRID_IMP_NETLOGIC_XLP3XX:
+				mask = 0xf;
+				break;
+			case PRID_IMP_NETLOGIC_XLP2XX:
+				mask = 0x3;
+				break;
+			case PRID_IMP_NETLOGIC_XLP8XX:
+			default:
+				mask = 0xff;
+				break;
+			}
 		}
 
 		/*
@@ -137,6 +164,7 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 		if (n == 0)
 			nodep->coremask = 1;
 
+		pr_info("Node %d - SYS/FUSE coremask %x\n", n, syscoremask);
 		for (core = 0; core < NLM_CORES_PER_NODE; core++) {
 			/* we will be on node 0 core 0 */
 			if (n == 0 && core == 0)

commit d150cef4e8cc723d90226e503ef6aff2ca9fc57c
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Sat Dec 21 16:52:22 2013 +0530

    MIPS: Netlogic: XLP9XX PIC updates
    
    Functions for the XLP9XX interrupt table entry format and other PIC
    register changes.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6279/

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index e6f77c053658..f11035b1ad11 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -47,8 +47,8 @@
 #include <asm/netlogic/mips-extns.h>
 
 #include <asm/netlogic/xlp-hal/iomap.h>
-#include <asm/netlogic/xlp-hal/pic.h>
 #include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/pic.h>
 #include <asm/netlogic/xlp-hal/sys.h>
 
 static int xlp_wakeup_core(uint64_t sysbase, int node, int core)

commit db038feedd9a5c83851d2f5aa6a84ff800da8ccb
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Sat Dec 21 16:52:18 2013 +0530

    MIPS: Netlogic: Get coremask from FUSE register
    
    Use the FUSE register to get the list of active cores in the CPU
    instead of using the CPU reset register, this is the recommended
    method.
    
    Also add code to mask the coremask with the default number of cores
    for each processor series.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6275/

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index 682d5638dc01..e6f77c053658 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -99,7 +99,7 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 {
 	struct nlm_soc_info *nodep;
 	uint64_t syspcibase;
-	uint32_t syscoremask;
+	uint32_t syscoremask, mask, fusemask;
 	int core, n, cpu;
 
 	for (n = 0; n < NLM_NR_NODES; n++) {
@@ -111,12 +111,31 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 		if (n != 0)
 			nlm_node_init(n);
 		nodep = nlm_get_node(n);
-		syscoremask = nlm_read_sys_reg(nodep->sysbase, SYS_CPU_RESET);
+
+		fusemask = nlm_read_sys_reg(nodep->sysbase,
+					SYS_EFUSE_DEVICE_CFG_STATUS0);
+		switch (read_c0_prid() & 0xff00) {
+		case PRID_IMP_NETLOGIC_XLP3XX:
+			mask = 0xf;
+			break;
+		case PRID_IMP_NETLOGIC_XLP2XX:
+			mask = 0x3;
+			break;
+		case PRID_IMP_NETLOGIC_XLP8XX:
+		default:
+			mask = 0xff;
+			break;
+		}
+
+		/*
+		 * Fused out cores are set in the fusemask, and the remaining
+		 * cores are renumbered to range 0 .. nactive-1
+		 */
+		syscoremask = (1 << hweight32(~fusemask & mask)) - 1;
+
 		/* The boot cpu */
-		if (n == 0) {
-			syscoremask |= 1;
+		if (n == 0)
 			nodep->coremask = 1;
-		}
 
 		for (core = 0; core < NLM_CORES_PER_NODE; core++) {
 			/* we will be on node 0 core 0 */

commit c49e42aba8e8471e30e0ee4d29f9871a4ba67ae9
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Sun Aug 11 14:43:57 2013 +0530

    MIPS: Netlogic: Core wakeup changes for XLP2XX
    
    On XLP2xx, wakeup code does not need to enable clock on the core.
    Update xlp/wakeup.c to handle this.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5703/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index 0cce37cbffef..682d5638dc01 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -58,10 +58,12 @@ static int xlp_wakeup_core(uint64_t sysbase, int node, int core)
 
 	coremask = (1 << core);
 
-	/* Enable CPU clock */
-	value = nlm_read_sys_reg(sysbase, SYS_CORE_DFS_DIS_CTRL);
-	value &= ~coremask;
-	nlm_write_sys_reg(sysbase, SYS_CORE_DFS_DIS_CTRL, value);
+	/* Enable CPU clock in case of 8xx/3xx */
+	if (!cpu_is_xlpii()) {
+		value = nlm_read_sys_reg(sysbase, SYS_CORE_DFS_DIS_CTRL);
+		value &= ~coremask;
+		nlm_write_sys_reg(sysbase, SYS_CORE_DFS_DIS_CTRL, value);
+	}
 
 	/* Remove CPU Reset */
 	value = nlm_read_sys_reg(sysbase, SYS_CPU_RESET);

commit 4033d38ceb9d84ed66b925c1740c1a88f8a4a8f9
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Mon Jun 10 06:41:07 2013 +0000

    MIPS: Netlogic: wait for all hardware threads
    
    Earlier we just waited for the first thread of the CPU to come online
    before proceeding to wake up others. Update it to wait for all the CPUs
    in the core. This will be useful when the boot-up is slow, like while
    debugging or when running in a simulator.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5429/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index feb573670f90..0cce37cbffef 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -77,13 +77,28 @@ static int xlp_wakeup_core(uint64_t sysbase, int node, int core)
 	return count != 0;
 }
 
+static int wait_for_cpus(int cpu, int bootcpu)
+{
+	volatile uint32_t *cpu_ready = nlm_get_boot_data(BOOT_CPU_READY);
+	int i, count, notready;
+
+	count = 0x20000000;
+	do {
+		notready = nlm_threads_per_core;
+		for (i = 0; i < nlm_threads_per_core; i++)
+			if (cpu_ready[cpu + i] || cpu == bootcpu)
+				--notready;
+	} while (notready != 0 && --count > 0);
+
+	return count != 0;
+}
+
 static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 {
 	struct nlm_soc_info *nodep;
 	uint64_t syspcibase;
 	uint32_t syscoremask;
-	volatile uint32_t *cpu_ready = nlm_get_boot_data(BOOT_CPU_READY);
-	int core, n, cpu, count, val;
+	int core, n, cpu;
 
 	for (n = 0; n < NLM_NR_NODES; n++) {
 		syspcibase = nlm_get_sys_pcibase(n);
@@ -123,11 +138,8 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 			/* core is up */
 			nodep->coremask |= 1u << core;
 
-			/* spin until the first hw thread sets its ready */
-			count = 0x20000000;
-			do {
-				val = cpu_ready[cpu];
-			} while (val == 0 && --count > 0);
+			/* spin until the hw threads sets their ready */
+			wait_for_cpus(cpu, 0);
 		}
 	}
 }
@@ -139,6 +151,7 @@ void xlp_wakeup_secondary_cpus()
 	 * first wakeup core 0 threads
 	 */
 	xlp_boot_core0_siblings();
+	wait_for_cpus(0, 0);
 
 	/* now get other cores out of reset */
 	xlp_enable_secondary_cores(&nlm_cpumask);

commit 919f9abb3723f088290c62648b12fbfc7600d923
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Mon Jun 10 06:41:04 2013 +0000

    MIPS: Netlogic: move cpu_ready array to boot area
    
    Move the nlm_cpu_ready[] array used by the cpu wakeup code to the
    boot area, along with rest of the boot parameter code.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5425/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index abb3e08cc052..feb573670f90 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -82,6 +82,7 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 	struct nlm_soc_info *nodep;
 	uint64_t syspcibase;
 	uint32_t syscoremask;
+	volatile uint32_t *cpu_ready = nlm_get_boot_data(BOOT_CPU_READY);
 	int core, n, cpu, count, val;
 
 	for (n = 0; n < NLM_NR_NODES; n++) {
@@ -125,7 +126,7 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 			/* spin until the first hw thread sets its ready */
 			count = 0x20000000;
 			do {
-				val = *(volatile int *)&nlm_cpu_ready[cpu];
+				val = cpu_ready[cpu];
 			} while (val == 0 && --count > 0);
 		}
 	}

commit 571886b2a52395f030d439c6259663a033e11e6a
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Mon Jun 10 06:41:02 2013 +0000

    MIPS: Netlogic: Initialization when !CONFIG_SMP
    
    The core initialization and reset vector setup needs to be done
    even when booting uniprocessor. Move this code from smp.c to setup.c
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5428/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index 1a7d529fcec0..abb3e08cc052 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -137,7 +137,6 @@ void xlp_wakeup_secondary_cpus()
 	 * In case of u-boot, the secondaries are in reset
 	 * first wakeup core 0 threads
 	 */
-	nlm_init_boot_cpu();
 	xlp_boot_core0_siblings();
 
 	/* now get other cores out of reset */

commit 9584c55a5cc0db82329dd1142ca570e2d64ea491
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Mon Jun 10 06:41:01 2013 +0000

    MIPS: Netlogic: Split reset code out of smpboot.S
    
    The reset and core initialization code should be available for
    uniprocessor as well. This changes is just to take out the code
    into a different file, without any change to the logic.
    
    The change for  uniprocessor initialization code is in a later patch.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5423/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index abb3e08cc052..1a7d529fcec0 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -137,6 +137,7 @@ void xlp_wakeup_secondary_cpus()
 	 * In case of u-boot, the secondaries are in reset
 	 * first wakeup core 0 threads
 	 */
+	nlm_init_boot_cpu();
 	xlp_boot_core0_siblings();
 
 	/* now get other cores out of reset */

commit cba3b643039b9d38284a5fd5143558622b9b64d9
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Mon Jan 14 15:12:01 2013 +0000

    MIPS: Netlogic: Fix for quad-XLP boot
    
    On multi-chip boards, the first core on slave SoCs may take much
    more time to wakeup. Add code to wait for the core to come up before
    proceeding with the rest of the boot up.
    
    Update xlp_wakeup_core to also skip the boot node and the boot CPU
    initialization which is already complete.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Patchwork: http://patchwork.linux-mips.org/patch/4783/
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index cb9010642ac3..abb3e08cc052 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -51,7 +51,7 @@
 #include <asm/netlogic/xlp-hal/xlp.h>
 #include <asm/netlogic/xlp-hal/sys.h>
 
-static int xlp_wakeup_core(uint64_t sysbase, int core)
+static int xlp_wakeup_core(uint64_t sysbase, int node, int core)
 {
 	uint32_t coremask, value;
 	int count;
@@ -82,36 +82,51 @@ static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 	struct nlm_soc_info *nodep;
 	uint64_t syspcibase;
 	uint32_t syscoremask;
-	int core, n, cpu;
+	int core, n, cpu, count, val;
 
 	for (n = 0; n < NLM_NR_NODES; n++) {
 		syspcibase = nlm_get_sys_pcibase(n);
 		if (nlm_read_reg(syspcibase, 0) == 0xffffffff)
 			break;
 
-		/* read cores in reset from SYS and account for boot cpu */
-		nlm_node_init(n);
+		/* read cores in reset from SYS */
+		if (n != 0)
+			nlm_node_init(n);
 		nodep = nlm_get_node(n);
 		syscoremask = nlm_read_sys_reg(nodep->sysbase, SYS_CPU_RESET);
-		if (n == 0)
+		/* The boot cpu */
+		if (n == 0) {
 			syscoremask |= 1;
+			nodep->coremask = 1;
+		}
 
 		for (core = 0; core < NLM_CORES_PER_NODE; core++) {
+			/* we will be on node 0 core 0 */
+			if (n == 0 && core == 0)
+				continue;
+
 			/* see if the core exists */
 			if ((syscoremask & (1 << core)) == 0)
 				continue;
 
-			/* see if at least the first thread is enabled */
+			/* see if at least the first hw thread is enabled */
 			cpu = (n * NLM_CORES_PER_NODE + core)
 						* NLM_THREADS_PER_CORE;
 			if (!cpumask_test_cpu(cpu, wakeup_mask))
 				continue;
 
 			/* wake up the core */
-			if (xlp_wakeup_core(nodep->sysbase, core))
-				nodep->coremask |= 1u << core;
-			else
-				pr_err("Failed to enable core %d\n", core);
+			if (!xlp_wakeup_core(nodep->sysbase, n, core))
+				continue;
+
+			/* core is up */
+			nodep->coremask |= 1u << core;
+
+			/* spin until the first hw thread sets its ready */
+			count = 0x20000000;
+			do {
+				val = *(volatile int *)&nlm_cpu_ready[cpu];
+			} while (val == 0 && --count > 0);
 		}
 	}
 }

commit 77ae798f5b736dfdc692b86b393d9699052ac77a
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Wed Oct 31 12:01:39 2012 +0000

    MIPS: Netlogic: Support for multi-chip configuration
    
    Upto 4 Netlogic XLP SoCs can be connected over ICI links to form a
    coherent multi-node system.  Each SoC has its own set of on-chip
    devices including PIC.  To support this, add a per SoC stucture and
    use it for the PIC and SYS block addresses instead of using global
    variables.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Patchwork: http://patchwork.linux-mips.org/patch/4469
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index 88ce38d096f0..cb9010642ac3 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -79,32 +79,38 @@ static int xlp_wakeup_core(uint64_t sysbase, int core)
 
 static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
 {
-	uint64_t syspcibase, sysbase;
+	struct nlm_soc_info *nodep;
+	uint64_t syspcibase;
 	uint32_t syscoremask;
-	int core, n;
+	int core, n, cpu;
 
-	for (n = 0; n < 4; n++) {
+	for (n = 0; n < NLM_NR_NODES; n++) {
 		syspcibase = nlm_get_sys_pcibase(n);
 		if (nlm_read_reg(syspcibase, 0) == 0xffffffff)
 			break;
 
 		/* read cores in reset from SYS and account for boot cpu */
-		sysbase = nlm_get_sys_regbase(n);
-		syscoremask = nlm_read_sys_reg(sysbase, SYS_CPU_RESET);
+		nlm_node_init(n);
+		nodep = nlm_get_node(n);
+		syscoremask = nlm_read_sys_reg(nodep->sysbase, SYS_CPU_RESET);
 		if (n == 0)
 			syscoremask |= 1;
 
-		for (core = 0; core < 8; core++) {
+		for (core = 0; core < NLM_CORES_PER_NODE; core++) {
 			/* see if the core exists */
 			if ((syscoremask & (1 << core)) == 0)
 				continue;
 
 			/* see if at least the first thread is enabled */
-			if (!cpumask_test_cpu((n * 8 + core) * 4, wakeup_mask))
+			cpu = (n * NLM_CORES_PER_NODE + core)
+						* NLM_THREADS_PER_CORE;
+			if (!cpumask_test_cpu(cpu, wakeup_mask))
 				continue;
 
 			/* wake up the core */
-			if (!xlp_wakeup_core(sysbase, core))
+			if (xlp_wakeup_core(nodep->sysbase, core))
+				nodep->coremask |= 1u << core;
+			else
 				pr_err("Failed to enable core %d\n", core);
 		}
 	}

commit 2a37b1ae443f20470a789b12a45cbc249c9e50a6
Author: Jayachandran C <jchandra@broadcom.com>
Date:   Wed Oct 31 12:01:37 2012 +0000

    MIPS: Netlogic: Move from u32 cpumask to cpumask_t
    
    Initial code to support more than 32 cpus. The platform CPU mask
    is updated from 32-bit mask to cpumask_t. Convert places that use
    cpu_/cpus_ functions to use cpumask_* functions.
    
    Signed-off-by: Jayachandran C <jchandra@broadcom.com>
    Patchwork: http://patchwork.linux-mips.org/patch/4464
    Signed-off-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index 44d923ff3846..88ce38d096f0 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -51,45 +51,66 @@
 #include <asm/netlogic/xlp-hal/xlp.h>
 #include <asm/netlogic/xlp-hal/sys.h>
 
-static void xlp_enable_secondary_cores(void)
+static int xlp_wakeup_core(uint64_t sysbase, int core)
 {
-	uint32_t core, value, coremask, syscoremask;
+	uint32_t coremask, value;
 	int count;
 
-	/* read cores in reset from SYS block */
-	syscoremask = nlm_read_sys_reg(nlm_sys_base, SYS_CPU_RESET);
+	coremask = (1 << core);
 
-	/* update user specified */
-	nlm_coremask = nlm_coremask & (syscoremask | 1);
+	/* Enable CPU clock */
+	value = nlm_read_sys_reg(sysbase, SYS_CORE_DFS_DIS_CTRL);
+	value &= ~coremask;
+	nlm_write_sys_reg(sysbase, SYS_CORE_DFS_DIS_CTRL, value);
 
-	for (core = 1; core < 8; core++) {
-		coremask = 1 << core;
-		if ((nlm_coremask & coremask) == 0)
-			continue;
+	/* Remove CPU Reset */
+	value = nlm_read_sys_reg(sysbase, SYS_CPU_RESET);
+	value &= ~coremask;
+	nlm_write_sys_reg(sysbase, SYS_CPU_RESET, value);
 
-		/* Enable CPU clock */
-		value = nlm_read_sys_reg(nlm_sys_base, SYS_CORE_DFS_DIS_CTRL);
-		value &= ~coremask;
-		nlm_write_sys_reg(nlm_sys_base, SYS_CORE_DFS_DIS_CTRL, value);
+	/* Poll for CPU to mark itself coherent */
+	count = 100000;
+	do {
+		value = nlm_read_sys_reg(sysbase, SYS_CPU_NONCOHERENT_MODE);
+	} while ((value & coremask) != 0 && --count > 0);
 
-		/* Remove CPU Reset */
-		value = nlm_read_sys_reg(nlm_sys_base, SYS_CPU_RESET);
-		value &= ~coremask;
-		nlm_write_sys_reg(nlm_sys_base, SYS_CPU_RESET, value);
+	return count != 0;
+}
+
+static void xlp_enable_secondary_cores(const cpumask_t *wakeup_mask)
+{
+	uint64_t syspcibase, sysbase;
+	uint32_t syscoremask;
+	int core, n;
+
+	for (n = 0; n < 4; n++) {
+		syspcibase = nlm_get_sys_pcibase(n);
+		if (nlm_read_reg(syspcibase, 0) == 0xffffffff)
+			break;
+
+		/* read cores in reset from SYS and account for boot cpu */
+		sysbase = nlm_get_sys_regbase(n);
+		syscoremask = nlm_read_sys_reg(sysbase, SYS_CPU_RESET);
+		if (n == 0)
+			syscoremask |= 1;
+
+		for (core = 0; core < 8; core++) {
+			/* see if the core exists */
+			if ((syscoremask & (1 << core)) == 0)
+				continue;
 
-		/* Poll for CPU to mark itself coherent */
-		count = 100000;
-		do {
-			value = nlm_read_sys_reg(nlm_sys_base,
-			    SYS_CPU_NONCOHERENT_MODE);
-		} while ((value & coremask) != 0 && count-- > 0);
+			/* see if at least the first thread is enabled */
+			if (!cpumask_test_cpu((n * 8 + core) * 4, wakeup_mask))
+				continue;
 
-		if (count == 0)
-			pr_err("Failed to enable core %d\n", core);
+			/* wake up the core */
+			if (!xlp_wakeup_core(sysbase, core))
+				pr_err("Failed to enable core %d\n", core);
+		}
 	}
 }
 
-void xlp_wakeup_secondary_cpus(void)
+void xlp_wakeup_secondary_cpus()
 {
 	/*
 	 * In case of u-boot, the secondaries are in reset
@@ -98,5 +119,5 @@ void xlp_wakeup_secondary_cpus(void)
 	xlp_boot_core0_siblings();
 
 	/* now get other cores out of reset */
-	xlp_enable_secondary_cores();
+	xlp_enable_secondary_cores(&nlm_cpumask);
 }

commit 66d29985fab8207b1b2c03ac34a2c294c5b47a30
Author: Jayachandran C <jayachandranc@netlogicmicro.com>
Date:   Wed Nov 16 00:21:29 2011 +0000

    MIPS: Netlogic: Merge some of XLR/XLP wakup code
    
    Create a common NMI and reset handler in smpboot.S and use this for
    both XLR and XLP.  In the earlier code, the woken up CPUs would
    busy wait until released, switch this to wakeup by NMI.
    
    The initial wakeup code or XLR and XLP are differ since they are
    started from different bootloaders (XLP from u-boot and XLR from
    netlogic bootloader). But in both platforms the woken up CPUs wait
    and are released by sending an NMI.
    
    Add support for starting XLR and XLP in 1/2/4 threads per core.
    
    Signed-off-by: Jayachandran C <jayachandranc@netlogicmicro.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2970/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
index e081a778678e..44d923ff3846 100644
--- a/arch/mips/netlogic/xlp/wakeup.c
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -51,18 +51,20 @@
 #include <asm/netlogic/xlp-hal/xlp.h>
 #include <asm/netlogic/xlp-hal/sys.h>
 
-unsigned long secondary_entry;
-uint32_t nlm_coremask;
-unsigned int nlm_threads_per_core;
-unsigned int nlm_threadmode;
-
-static void nlm_enable_secondary_cores(unsigned int cores_bitmap)
+static void xlp_enable_secondary_cores(void)
 {
-	uint32_t core, value, coremask;
+	uint32_t core, value, coremask, syscoremask;
+	int count;
+
+	/* read cores in reset from SYS block */
+	syscoremask = nlm_read_sys_reg(nlm_sys_base, SYS_CPU_RESET);
+
+	/* update user specified */
+	nlm_coremask = nlm_coremask & (syscoremask | 1);
 
 	for (core = 1; core < 8; core++) {
 		coremask = 1 << core;
-		if ((cores_bitmap & coremask) == 0)
+		if ((nlm_coremask & coremask) == 0)
 			continue;
 
 		/* Enable CPU clock */
@@ -76,74 +78,25 @@ static void nlm_enable_secondary_cores(unsigned int cores_bitmap)
 		nlm_write_sys_reg(nlm_sys_base, SYS_CPU_RESET, value);
 
 		/* Poll for CPU to mark itself coherent */
+		count = 100000;
 		do {
 			value = nlm_read_sys_reg(nlm_sys_base,
 			    SYS_CPU_NONCOHERENT_MODE);
-		} while ((value & coremask) != 0);
-	}
-}
-
-
-static void nlm_parse_cpumask(u32 cpu_mask)
-{
-	uint32_t core0_thr_mask, core_thr_mask;
-	int i;
+		} while ((value & coremask) != 0 && count-- > 0);
 
-	core0_thr_mask = cpu_mask & 0xf;
-	switch (core0_thr_mask) {
-	case 1:
-		nlm_threads_per_core = 1;
-		nlm_threadmode = 0;
-		break;
-	case 3:
-		nlm_threads_per_core = 2;
-		nlm_threadmode = 2;
-		break;
-	case 0xf:
-		nlm_threads_per_core = 4;
-		nlm_threadmode = 3;
-		break;
-	default:
-		goto unsupp;
+		if (count == 0)
+			pr_err("Failed to enable core %d\n", core);
 	}
-
-	/* Verify other cores CPU masks */
-	nlm_coremask = 1;
-	for (i = 1; i < 8; i++) {
-		core_thr_mask = (cpu_mask >> (i * 4)) & 0xf;
-		if (core_thr_mask) {
-			if (core_thr_mask != core0_thr_mask)
-				goto unsupp;
-			nlm_coremask |= 1 << i;
-		}
-	}
-	return;
-
-unsupp:
-	panic("Unsupported CPU mask %x\n", cpu_mask);
 }
 
-int __cpuinit nlm_wakeup_secondary_cpus(u32 wakeup_mask)
+void xlp_wakeup_secondary_cpus(void)
 {
-	unsigned long reset_vec;
-	unsigned int *reset_data;
-
-	/* Update reset entry point with CPU init code */
-	reset_vec = CKSEG1ADDR(RESET_VEC_PHYS);
-	memcpy((void *)reset_vec, (void *)nlm_reset_entry,
-			(nlm_reset_entry_end - nlm_reset_entry));
-
-	/* verify the mask and setup core config variables */
-	nlm_parse_cpumask(wakeup_mask);
-
-	/* Setup CPU init parameters */
-	reset_data = (unsigned int *)CKSEG1ADDR(RESET_DATA_PHYS);
-	reset_data[BOOT_THREAD_MODE] = nlm_threadmode;
-
-	/* first wakeup core 0 siblings */
-	nlm_boot_core0_siblings();
-
-	/* enable the reset of the cores */
-	nlm_enable_secondary_cores(nlm_coremask);
-	return 0;
+	/*
+	 * In case of u-boot, the secondaries are in reset
+	 * first wakeup core 0 threads
+	 */
+	xlp_boot_core0_siblings();
+
+	/* now get other cores out of reset */
+	xlp_enable_secondary_cores();
 }

commit 65040e224e5b214a93fa0c790add5d69b054ecae
Author: Jayachandran C <jayachandranc@netlogicmicro.com>
Date:   Wed Nov 16 00:21:28 2011 +0000

    MIPS: Netlogic: Add XLP platform files for XLP SoC
    
    - Update common files to support XLP.
    - Add arch/mips/include/asm/netlogic/xlp-hal for register definitions
      and access macros
    - Add arch/mips/netlogic/xlp/ for XLP specific files.
    
    Signed-off-by: Jayachandran C <jayachandranc@netlogicmicro.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2967/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/netlogic/xlp/wakeup.c b/arch/mips/netlogic/xlp/wakeup.c
new file mode 100644
index 000000000000..e081a778678e
--- /dev/null
+++ b/arch/mips/netlogic/xlp/wakeup.c
@@ -0,0 +1,149 @@
+/*
+ * Copyright 2003-2011 NetLogic Microsystems, Inc. (NetLogic). All rights
+ * reserved.
+ *
+ * This software is available to you under a choice of one of two
+ * licenses.  You may choose to be licensed under the terms of the GNU
+ * General Public License (GPL) Version 2, available from the file
+ * COPYING in the main directory of this source tree, or the NetLogic
+ * license below:
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY NETLOGIC ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL NETLOGIC OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/threads.h>
+
+#include <asm/asm.h>
+#include <asm/asm-offsets.h>
+#include <asm/mipsregs.h>
+#include <asm/addrspace.h>
+#include <asm/string.h>
+
+#include <asm/netlogic/haldefs.h>
+#include <asm/netlogic/common.h>
+#include <asm/netlogic/mips-extns.h>
+
+#include <asm/netlogic/xlp-hal/iomap.h>
+#include <asm/netlogic/xlp-hal/pic.h>
+#include <asm/netlogic/xlp-hal/xlp.h>
+#include <asm/netlogic/xlp-hal/sys.h>
+
+unsigned long secondary_entry;
+uint32_t nlm_coremask;
+unsigned int nlm_threads_per_core;
+unsigned int nlm_threadmode;
+
+static void nlm_enable_secondary_cores(unsigned int cores_bitmap)
+{
+	uint32_t core, value, coremask;
+
+	for (core = 1; core < 8; core++) {
+		coremask = 1 << core;
+		if ((cores_bitmap & coremask) == 0)
+			continue;
+
+		/* Enable CPU clock */
+		value = nlm_read_sys_reg(nlm_sys_base, SYS_CORE_DFS_DIS_CTRL);
+		value &= ~coremask;
+		nlm_write_sys_reg(nlm_sys_base, SYS_CORE_DFS_DIS_CTRL, value);
+
+		/* Remove CPU Reset */
+		value = nlm_read_sys_reg(nlm_sys_base, SYS_CPU_RESET);
+		value &= ~coremask;
+		nlm_write_sys_reg(nlm_sys_base, SYS_CPU_RESET, value);
+
+		/* Poll for CPU to mark itself coherent */
+		do {
+			value = nlm_read_sys_reg(nlm_sys_base,
+			    SYS_CPU_NONCOHERENT_MODE);
+		} while ((value & coremask) != 0);
+	}
+}
+
+
+static void nlm_parse_cpumask(u32 cpu_mask)
+{
+	uint32_t core0_thr_mask, core_thr_mask;
+	int i;
+
+	core0_thr_mask = cpu_mask & 0xf;
+	switch (core0_thr_mask) {
+	case 1:
+		nlm_threads_per_core = 1;
+		nlm_threadmode = 0;
+		break;
+	case 3:
+		nlm_threads_per_core = 2;
+		nlm_threadmode = 2;
+		break;
+	case 0xf:
+		nlm_threads_per_core = 4;
+		nlm_threadmode = 3;
+		break;
+	default:
+		goto unsupp;
+	}
+
+	/* Verify other cores CPU masks */
+	nlm_coremask = 1;
+	for (i = 1; i < 8; i++) {
+		core_thr_mask = (cpu_mask >> (i * 4)) & 0xf;
+		if (core_thr_mask) {
+			if (core_thr_mask != core0_thr_mask)
+				goto unsupp;
+			nlm_coremask |= 1 << i;
+		}
+	}
+	return;
+
+unsupp:
+	panic("Unsupported CPU mask %x\n", cpu_mask);
+}
+
+int __cpuinit nlm_wakeup_secondary_cpus(u32 wakeup_mask)
+{
+	unsigned long reset_vec;
+	unsigned int *reset_data;
+
+	/* Update reset entry point with CPU init code */
+	reset_vec = CKSEG1ADDR(RESET_VEC_PHYS);
+	memcpy((void *)reset_vec, (void *)nlm_reset_entry,
+			(nlm_reset_entry_end - nlm_reset_entry));
+
+	/* verify the mask and setup core config variables */
+	nlm_parse_cpumask(wakeup_mask);
+
+	/* Setup CPU init parameters */
+	reset_data = (unsigned int *)CKSEG1ADDR(RESET_DATA_PHYS);
+	reset_data[BOOT_THREAD_MODE] = nlm_threadmode;
+
+	/* first wakeup core 0 siblings */
+	nlm_boot_core0_siblings();
+
+	/* enable the reset of the cores */
+	nlm_enable_secondary_cores(nlm_coremask);
+	return 0;
+}
