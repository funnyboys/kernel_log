commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index 2a66e908f6a9..1eb356fdd832 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *	Bus error event handling code for systems equipped with ECC
  *	handling logic, i.e. DECstation/DECsystem 5000/200 (KN02),
@@ -5,11 +6,6 @@
  *	5900/260 (KN05) systems.
  *
  *	Copyright (c) 2003, 2005  Maciej W. Rozycki
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License
- *	as published by the Free Software Foundation; either version
- *	2 of the License, or (at your option) any later version.
  */
 
 #include <linux/init.h>

commit af37530bbe9cae2a17044525b9f898ff60012157
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Mon Mar 31 23:51:30 2014 +0100

    MIPS: DEC: Bus error handler <asm/cpu-type.h> fixes
    
    Commit 69f24d1784b631b81a54eb57c49bf46536dd2382 [MIPS: Optimize
    current_cpu_type() for better code.] missed an update for two DECstation
    bus error support files that now do not build, this is a fix.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6667/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index 5abf4e894216..2a66e908f6a9 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -21,6 +21,7 @@
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
+#include <asm/cpu-type.h>
 #include <asm/irq_regs.h>
 #include <asm/processor.h>
 #include <asm/ptrace.h>

commit b81947c646bfefdf98e2fde5d7d39cbbda8525d4
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for MIPS
    
    Disintegrate asm/system.h for MIPS.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    cc: linux-mips@linux-mips.org

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index 7abce661b90f..5abf4e894216 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -24,7 +24,6 @@
 #include <asm/irq_regs.h>
 #include <asm/processor.h>
 #include <asm/ptrace.h>
-#include <asm/system.h>
 #include <asm/traps.h>
 
 #include <asm/dec/ecc.h>

commit 49316cbf0a9875f102f98dc8b7c80cfa142e33cf
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Jul 6 09:13:17 2009 +0100

    MIPS: Eleminate filenames from comments
    
    They tend to get not updated when files are moved around or copied and
    lack any obvious use.  While at it zap some only too obvious comments and
    as per Shinya's suggestion, add a copyright header to extable.c.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
    Acked-by: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index 6a17c9b508ea..7abce661b90f 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -1,6 +1,4 @@
 /*
- *	linux/arch/mips/dec/ecc-berr.c
- *
  *	Bus error event handling code for systems equipped with ECC
  *	handling logic, i.e. DECstation/DECsystem 5000/200 (KN02),
  *	5000/240 (KN03), 5000/260 (KN05) and DECsystem 5900 (KN03),

commit 10cc3529072d5415fb040018a8a99aa7a60190b6
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:15 2007 +0100

    [MIPS] Allow hardwiring of the CPU type to a single type for optimization.
    
    This saves a few k on systems which only ever ship with a single CPU type.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index 6d55e8aab668..6a17c9b508ea 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -263,7 +263,7 @@ static inline void dec_kn03_be_init(void)
 	 */
 	*mcr = (*mcr & ~(KN03_MCR_DIAGCHK | KN03_MCR_DIAGGEN)) |
 	       KN03_MCR_CORRECT;
-	if (current_cpu_data.cputype == CPU_R4400SC)
+	if (current_cpu_type() == CPU_R4400SC)
 		*mbcs |= KN4K_MB_CSR_EE;
 	fast_iob();
 }

commit 49afb1f67b42c4240fef9d2d8b76c317c56a189d
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Wed Dec 6 11:50:23 2006 +0000

    [MIPS] *-berr: Header inclusions for DEC bus error handlers
    
     A fixup to add missing header inclusions for bus error handlers for
    DECstation system after the recent switch to get_irq_regs().
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index c8430c07355e..6d55e8aab668 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -25,6 +25,7 @@
 #include <asm/cpu.h>
 #include <asm/irq_regs.h>
 #include <asm/processor.h>
+#include <asm/ptrace.h>
 #include <asm/system.h>
 #include <asm/traps.h>
 

commit 1603b5aca4f15b34848fb5594d0c7b6333b99144
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Nov 2 02:08:36 2006 +0900

    [MIPS] IRQ cleanups
    
    This is a big irq cleanup patch.
    
    * Use set_irq_chip() to register irq_chip.
    * Initialize .mask, .unmask, .mask_ack field.  Functions for these
      method are already exist in most case.
    * Do not initialize .startup, .shutdown, .enable, .disable fields if
      default routines provided by irq_chip_set_defaults() were suitable.
    * Remove redundant irq_desc initializations.
    * Remove unnecessary local_irq_save/local_irq_restore, spin_lock.
    
    With this cleanup, it would be easy to switch to slightly lightwait
    irq flow handlers (handle_level_irq(), etc.) instead of __do_IRQ().
    
    Though whole this patch is quite large, changes in each irq_chip are
    not quite simple.  Please review and test on your platform.  Thanks.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index 3e374d05978f..c8430c07355e 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -18,7 +18,6 @@
 #include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
-#include <linux/spinlock.h>
 #include <linux/types.h>
 
 #include <asm/addrspace.h>
@@ -231,13 +230,10 @@ irqreturn_t dec_ecc_be_interrupt(int irq, void *dev_id)
 static inline void dec_kn02_be_init(void)
 {
 	volatile u32 *csr = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_CSR);
-	unsigned long flags;
 
 	kn0x_erraddr = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_ERRADDR);
 	kn0x_chksyn = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_CHKSYN);
 
-	spin_lock_irqsave(&kn02_lock, flags);
-
 	/* Preset write-only bits of the Control Register cache. */
 	cached_kn02_csr = *csr | KN02_CSR_LEDS;
 
@@ -247,8 +243,6 @@ static inline void dec_kn02_be_init(void)
 	cached_kn02_csr |= KN02_CSR_CORRECT;
 	*csr = cached_kn02_csr;
 	iob();
-
-	spin_unlock_irqrestore(&kn02_lock, flags);
 }
 
 static inline void dec_kn03_be_init(void)

commit 6dab2f4564b3dc8747452e256fb779f320ff5650
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 9 00:00:31 2006 +0100

    [MIPS] DEC: pt_regs fixes for buserror handlers
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index cc24c5ed0c05..3e374d05978f 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -24,6 +24,7 @@
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
+#include <asm/irq_regs.h>
 #include <asm/processor.h>
 #include <asm/system.h>
 #include <asm/traps.h>
@@ -200,8 +201,10 @@ int dec_ecc_be_handler(struct pt_regs *regs, int is_fixup)
 	return dec_ecc_be_backend(regs, is_fixup, 0);
 }
 
-irqreturn_t dec_ecc_be_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t dec_ecc_be_interrupt(int irq, void *dev_id)
 {
+	struct pt_regs *regs = get_irq_regs();
+
 	int action = dec_ecc_be_backend(regs, 0, 1);
 
 	if (action == MIPS_BE_DISCARD)

commit a5fc9c0bbee8b91025993a49a9176a88380aef3c
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Fri Jul 1 16:10:40 2005 +0000

    Use physical addresses at the interface level, letting drivers remap
    them as appropriate.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index 8f3498aa43ab..cc24c5ed0c05 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -227,11 +227,11 @@ irqreturn_t dec_ecc_be_interrupt(int irq, void *dev_id, struct pt_regs *regs)
  */
 static inline void dec_kn02_be_init(void)
 {
-	volatile u32 *csr = (void *)KN02_CSR_BASE;
+	volatile u32 *csr = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_CSR);
 	unsigned long flags;
 
-	kn0x_erraddr = (void *)(KN02_SLOT_BASE + KN02_ERRADDR);
-	kn0x_chksyn = (void *)(KN02_SLOT_BASE + KN02_CHKSYN);
+	kn0x_erraddr = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_ERRADDR);
+	kn0x_chksyn = (void *)CKSEG1ADDR(KN02_SLOT_BASE + KN02_CHKSYN);
 
 	spin_lock_irqsave(&kn02_lock, flags);
 
@@ -250,11 +250,11 @@ static inline void dec_kn02_be_init(void)
 
 static inline void dec_kn03_be_init(void)
 {
-	volatile u32 *mcr = (void *)(KN03_SLOT_BASE + IOASIC_MCR);
-	volatile u32 *mbcs = (void *)(KN4K_SLOT_BASE + KN4K_MB_CSR);
+	volatile u32 *mcr = (void *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_MCR);
+	volatile u32 *mbcs = (void *)CKSEG1ADDR(KN4K_SLOT_BASE + KN4K_MB_CSR);
 
-	kn0x_erraddr = (void *)(KN03_SLOT_BASE + IOASIC_ERRADDR);
-	kn0x_chksyn = (void *)(KN03_SLOT_BASE + IOASIC_CHKSYN);
+	kn0x_erraddr = (void *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_ERRADDR);
+	kn0x_chksyn = (void *)CKSEG1ADDR(KN03_SLOT_BASE + IOASIC_CHKSYN);
 
 	/*
 	 * Set normal ECC detection and generation, enable ECC correction.

commit 64dac503e8265007ea5c53b4d6bf42488a8a8d7a
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Wed Jun 22 20:56:26 2005 +0000

    System-specific handling of bus errors for DECstation variations
    supporting parity errors only for memory (Pmax/3min/Maxine).
    Fixes for resources decoded by the KN04/KN05 MB ASIC.  Additional
    clean-ups for the ECC handler.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index a36503c95bbb..8f3498aa43ab 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -6,7 +6,7 @@
  *	5000/240 (KN03), 5000/260 (KN05) and DECsystem 5900 (KN03),
  *	5900/260 (KN05) systems.
  *
- *	Copyright (c) 2003  Maciej W. Rozycki
+ *	Copyright (c) 2003, 2005  Maciej W. Rozycki
  *
  *	This program is free software; you can redistribute it and/or
  *	modify it under the terms of the GNU General Public License
@@ -15,6 +15,7 @@
  */
 
 #include <linux/init.h>
+#include <linux/interrupt.h>
 #include <linux/kernel.h>
 #include <linux/sched.h>
 #include <linux/spinlock.h>
@@ -57,7 +58,7 @@ static int dec_ecc_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
 
 	const char *kind, *agent, *cycle, *event;
 	const char *status = "", *xbit = "", *fmt = "";
-	dma_addr_t address;
+	unsigned long address;
 	u16 syn = 0, sngl;
 
 	int i = 0;
@@ -66,7 +67,7 @@ static int dec_ecc_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
 	u32 chksyn = *kn0x_chksyn;
 	int action = MIPS_BE_FATAL;
 
-	/* For non-ECC ack ASAP, so any subsequent errors get caught. */
+	/* For non-ECC ack ASAP, so that any subsequent errors get caught. */
 	if ((erraddr & (KN0X_EAR_VALID | KN0X_EAR_ECCERR)) == KN0X_EAR_VALID)
 		dec_ecc_be_ack();
 
@@ -74,7 +75,7 @@ static int dec_ecc_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
 
 	if (!(erraddr & KN0X_EAR_VALID)) {
 		/* No idea what happened. */
-		printk(KERN_ALERT "Unidentified bus error %s.\n", kind);
+		printk(KERN_ALERT "Unidentified bus error %s\n", kind);
 		return action;
 	}
 
@@ -126,7 +127,7 @@ static int dec_ecc_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
 			/* Ack now, no rewrite will happen. */
 			dec_ecc_be_ack();
 
-			fmt = KERN_ALERT "%s" "invalid.\n";
+			fmt = KERN_ALERT "%s" "invalid\n";
 		} else {
 			sngl = syn & KN0X_ESR_SNGLO;
 			syn &= KN0X_ESR_SYNLO;
@@ -161,12 +162,12 @@ static int dec_ecc_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
 				if (syn == 0x01) {
 					fmt = KERN_ALERT "%s"
 					      "%#04x -- %s bit error "
-					      "at check bit C%s.\n";
+					      "at check bit C%s\n";
 					xbit = "X";
 				} else {
 					fmt = KERN_ALERT "%s"
 					      "%#04x -- %s bit error "
-					      "at check bit C%s%u.\n";
+					      "at check bit C%s%u\n";
 				}
 				i = syn >> 2;
 			} else {
@@ -176,16 +177,16 @@ static int dec_ecc_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
 				if (i < 32)
 					fmt = KERN_ALERT "%s"
 					      "%#04x -- %s bit error "
-					      "at data bit D%s%u.\n";
+					      "at data bit D%s%u\n";
 				else
 					fmt = KERN_ALERT "%s"
-					      "%#04x -- %s bit error.\n";
+					      "%#04x -- %s bit error\n";
 			}
 		}
 	}
 
 	if (action != MIPS_BE_FIXUP)
-		printk(KERN_ALERT "Bus error %s: %s %s %s at %#010lx.\n",
+		printk(KERN_ALERT "Bus error %s: %s %s %s at %#010lx\n",
 			kind, agent, cycle, event, address);
 
 	if (action != MIPS_BE_FIXUP && erraddr & KN0X_EAR_ECCERR)
@@ -207,8 +208,8 @@ irqreturn_t dec_ecc_be_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 		return IRQ_HANDLED;
 
 	/*
-	 * FIXME: Find affected processes and kill them, otherwise we
-	 * must die.
+	 * FIXME: Find the affected processes and kill them, otherwise
+	 * we must die.
 	 *
 	 * The interrupt is asynchronously delivered thus EPC and RA
 	 * may be irrelevant, but are printed for a reference.
@@ -235,7 +236,7 @@ static inline void dec_kn02_be_init(void)
 	spin_lock_irqsave(&kn02_lock, flags);
 
 	/* Preset write-only bits of the Control Register cache. */
-	cached_kn02_csr = *csr | KN03_CSR_LEDS;
+	cached_kn02_csr = *csr | KN02_CSR_LEDS;
 
 	/* Set normal ECC detection and generation. */
 	cached_kn02_csr &= ~(KN02_CSR_DIAGCHK | KN02_CSR_DIAGGEN);
@@ -250,7 +251,7 @@ static inline void dec_kn02_be_init(void)
 static inline void dec_kn03_be_init(void)
 {
 	volatile u32 *mcr = (void *)(KN03_SLOT_BASE + IOASIC_MCR);
-	volatile u32 *mbcs = (void *)(KN03_SLOT_BASE + KN05_MB_CSR);
+	volatile u32 *mbcs = (void *)(KN4K_SLOT_BASE + KN4K_MB_CSR);
 
 	kn0x_erraddr = (void *)(KN03_SLOT_BASE + IOASIC_ERRADDR);
 	kn0x_chksyn = (void *)(KN03_SLOT_BASE + IOASIC_CHKSYN);
@@ -265,7 +266,7 @@ static inline void dec_kn03_be_init(void)
 	*mcr = (*mcr & ~(KN03_MCR_DIAGCHK | KN03_MCR_DIAGGEN)) |
 	       KN03_MCR_CORRECT;
 	if (current_cpu_data.cputype == CPU_R4400SC)
-		*mbcs |= KN05_MB_CSR_EE;
+		*mbcs |= KN4K_MB_CSR_EE;
 	fast_iob();
 }
 

commit 3bd4c902da14030c9a780cd0c4be2ffe9aee2974
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Thu Jun 16 20:30:54 2005 +0000

    Deal with the bloody KSEG vs CKSEG horror...
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index c4842096e50d..a36503c95bbb 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -144,7 +144,8 @@ static int dec_ecc_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
 			} else if (!sngl) {
 				status = dbestr;
 			} else {
-				volatile u32 *ptr = (void *)KSEG1ADDR(address);
+				volatile u32 *ptr =
+					(void *)CKSEG1ADDR(address);
 
 				*ptr = *ptr;		/* Rewrite. */
 				iob();

commit 68e4a86c8010d15ec844d06f45cd564631f2fa7e
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Mon Jun 13 19:53:38 2005 +0000

    This interrupt is *always* handled -- MIPS_BE_DISCARD just means
    no further action wanted.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index 6dbce92eb068..c4842096e50d 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -203,7 +203,7 @@ irqreturn_t dec_ecc_be_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 	int action = dec_ecc_be_backend(regs, 0, 1);
 
 	if (action == MIPS_BE_DISCARD)
-		return IRQ_NONE;
+		return IRQ_HANDLED;
 
 	/*
 	 * FIXME: Find affected processes and kill them, otherwise we

commit 42a3b4f25af8f8d77feddf27f839fa0628dbff1a
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Sep 3 15:56:17 2005 -0700

    [PATCH] mips: nuke trailing whitespace
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
index 133fb7c48e6c..6dbce92eb068 100644
--- a/arch/mips/dec/ecc-berr.c
+++ b/arch/mips/dec/ecc-berr.c
@@ -253,7 +253,7 @@ static inline void dec_kn03_be_init(void)
 
 	kn0x_erraddr = (void *)(KN03_SLOT_BASE + IOASIC_ERRADDR);
 	kn0x_chksyn = (void *)(KN03_SLOT_BASE + IOASIC_CHKSYN);
-			
+
 	/*
 	 * Set normal ECC detection and generation, enable ECC correction.
 	 * For KN05 we also need to make sure EE (?) is enabled in the MB.

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/dec/ecc-berr.c b/arch/mips/dec/ecc-berr.c
new file mode 100644
index 000000000000..133fb7c48e6c
--- /dev/null
+++ b/arch/mips/dec/ecc-berr.c
@@ -0,0 +1,280 @@
+/*
+ *	linux/arch/mips/dec/ecc-berr.c
+ *
+ *	Bus error event handling code for systems equipped with ECC
+ *	handling logic, i.e. DECstation/DECsystem 5000/200 (KN02),
+ *	5000/240 (KN03), 5000/260 (KN05) and DECsystem 5900 (KN03),
+ *	5900/260 (KN05) systems.
+ *
+ *	Copyright (c) 2003  Maciej W. Rozycki
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/traps.h>
+
+#include <asm/dec/ecc.h>
+#include <asm/dec/kn02.h>
+#include <asm/dec/kn03.h>
+#include <asm/dec/kn05.h>
+
+static volatile u32 *kn0x_erraddr;
+static volatile u32 *kn0x_chksyn;
+
+static inline void dec_ecc_be_ack(void)
+{
+	*kn0x_erraddr = 0;			/* any write clears the IRQ */
+	iob();
+}
+
+static int dec_ecc_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
+{
+	static const char excstr[] = "exception";
+	static const char intstr[] = "interrupt";
+	static const char cpustr[] = "CPU";
+	static const char dmastr[] = "DMA";
+	static const char readstr[] = "read";
+	static const char mreadstr[] = "memory read";
+	static const char writestr[] = "write";
+	static const char mwritstr[] = "partial memory write";
+	static const char timestr[] = "timeout";
+	static const char overstr[] = "overrun";
+	static const char eccstr[] = "ECC error";
+
+	const char *kind, *agent, *cycle, *event;
+	const char *status = "", *xbit = "", *fmt = "";
+	dma_addr_t address;
+	u16 syn = 0, sngl;
+
+	int i = 0;
+
+	u32 erraddr = *kn0x_erraddr;
+	u32 chksyn = *kn0x_chksyn;
+	int action = MIPS_BE_FATAL;
+
+	/* For non-ECC ack ASAP, so any subsequent errors get caught. */
+	if ((erraddr & (KN0X_EAR_VALID | KN0X_EAR_ECCERR)) == KN0X_EAR_VALID)
+		dec_ecc_be_ack();
+
+	kind = invoker ? intstr : excstr;
+
+	if (!(erraddr & KN0X_EAR_VALID)) {
+		/* No idea what happened. */
+		printk(KERN_ALERT "Unidentified bus error %s.\n", kind);
+		return action;
+	}
+
+	agent = (erraddr & KN0X_EAR_CPU) ? cpustr : dmastr;
+
+	if (erraddr & KN0X_EAR_ECCERR) {
+		/* An ECC error on a CPU or DMA transaction. */
+		cycle = (erraddr & KN0X_EAR_WRITE) ? mwritstr : mreadstr;
+		event = eccstr;
+	} else {
+		/* A CPU timeout or a DMA overrun. */
+		cycle = (erraddr & KN0X_EAR_WRITE) ? writestr : readstr;
+		event = (erraddr & KN0X_EAR_CPU) ? timestr : overstr;
+	}
+
+	address = erraddr & KN0X_EAR_ADDRESS;
+	/* For ECC errors on reads adjust for MT pipelining. */
+	if ((erraddr & (KN0X_EAR_WRITE | KN0X_EAR_ECCERR)) == KN0X_EAR_ECCERR)
+		address = (address & ~0xfffLL) | ((address - 5) & 0xfffLL);
+	address <<= 2;
+
+	/* Only CPU errors are fixable. */
+	if (erraddr & KN0X_EAR_CPU && is_fixup)
+		action = MIPS_BE_FIXUP;
+
+	if (erraddr & KN0X_EAR_ECCERR) {
+		static const u8 data_sbit[32] = {
+			0x4f, 0x4a, 0x52, 0x54, 0x57, 0x58, 0x5b, 0x5d,
+			0x23, 0x25, 0x26, 0x29, 0x2a, 0x2c, 0x31, 0x34,
+			0x0e, 0x0b, 0x13, 0x15, 0x16, 0x19, 0x1a, 0x1c,
+			0x62, 0x64, 0x67, 0x68, 0x6b, 0x6d, 0x70, 0x75,
+		};
+		static const u8 data_mbit[25] = {
+			0x07, 0x0d, 0x1f,
+			0x2f, 0x32, 0x37, 0x38, 0x3b, 0x3d, 0x3e,
+			0x43, 0x45, 0x46, 0x49, 0x4c, 0x51, 0x5e,
+			0x61, 0x6e, 0x73, 0x76, 0x79, 0x7a, 0x7c, 0x7f,
+		};
+		static const char sbestr[] = "corrected single";
+		static const char dbestr[] = "uncorrectable double";
+		static const char mbestr[] = "uncorrectable multiple";
+
+		if (!(address & 0x4))
+			syn = chksyn;			/* Low bank. */
+		else
+			syn = chksyn >> 16;		/* High bank. */
+
+		if (!(syn & KN0X_ESR_VLDLO)) {
+			/* Ack now, no rewrite will happen. */
+			dec_ecc_be_ack();
+
+			fmt = KERN_ALERT "%s" "invalid.\n";
+		} else {
+			sngl = syn & KN0X_ESR_SNGLO;
+			syn &= KN0X_ESR_SYNLO;
+
+			/*
+			 * Multibit errors may be tagged incorrectly;
+			 * check the syndrome explicitly.
+			 */
+			for (i = 0; i < 25; i++)
+				if (syn == data_mbit[i])
+					break;
+
+			if (i < 25) {
+				status = mbestr;
+			} else if (!sngl) {
+				status = dbestr;
+			} else {
+				volatile u32 *ptr = (void *)KSEG1ADDR(address);
+
+				*ptr = *ptr;		/* Rewrite. */
+				iob();
+
+				status = sbestr;
+				action = MIPS_BE_DISCARD;
+			}
+
+			/* Ack now, now we've rewritten (or not). */
+			dec_ecc_be_ack();
+
+			if (syn && syn == (syn & -syn)) {
+				if (syn == 0x01) {
+					fmt = KERN_ALERT "%s"
+					      "%#04x -- %s bit error "
+					      "at check bit C%s.\n";
+					xbit = "X";
+				} else {
+					fmt = KERN_ALERT "%s"
+					      "%#04x -- %s bit error "
+					      "at check bit C%s%u.\n";
+				}
+				i = syn >> 2;
+			} else {
+				for (i = 0; i < 32; i++)
+					if (syn == data_sbit[i])
+						break;
+				if (i < 32)
+					fmt = KERN_ALERT "%s"
+					      "%#04x -- %s bit error "
+					      "at data bit D%s%u.\n";
+				else
+					fmt = KERN_ALERT "%s"
+					      "%#04x -- %s bit error.\n";
+			}
+		}
+	}
+
+	if (action != MIPS_BE_FIXUP)
+		printk(KERN_ALERT "Bus error %s: %s %s %s at %#010lx.\n",
+			kind, agent, cycle, event, address);
+
+	if (action != MIPS_BE_FIXUP && erraddr & KN0X_EAR_ECCERR)
+		printk(fmt, "  ECC syndrome ", syn, status, xbit, i);
+
+	return action;
+}
+
+int dec_ecc_be_handler(struct pt_regs *regs, int is_fixup)
+{
+	return dec_ecc_be_backend(regs, is_fixup, 0);
+}
+
+irqreturn_t dec_ecc_be_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	int action = dec_ecc_be_backend(regs, 0, 1);
+
+	if (action == MIPS_BE_DISCARD)
+		return IRQ_NONE;
+
+	/*
+	 * FIXME: Find affected processes and kill them, otherwise we
+	 * must die.
+	 *
+	 * The interrupt is asynchronously delivered thus EPC and RA
+	 * may be irrelevant, but are printed for a reference.
+	 */
+	printk(KERN_ALERT "Fatal bus interrupt, epc == %08lx, ra == %08lx\n",
+	       regs->cp0_epc, regs->regs[31]);
+	die("Unrecoverable bus error", regs);
+}
+
+
+/*
+ * Initialization differs a bit between KN02 and KN03/KN05, so we
+ * need two variants.  Once set up, all systems can be handled the
+ * same way.
+ */
+static inline void dec_kn02_be_init(void)
+{
+	volatile u32 *csr = (void *)KN02_CSR_BASE;
+	unsigned long flags;
+
+	kn0x_erraddr = (void *)(KN02_SLOT_BASE + KN02_ERRADDR);
+	kn0x_chksyn = (void *)(KN02_SLOT_BASE + KN02_CHKSYN);
+
+	spin_lock_irqsave(&kn02_lock, flags);
+
+	/* Preset write-only bits of the Control Register cache. */
+	cached_kn02_csr = *csr | KN03_CSR_LEDS;
+
+	/* Set normal ECC detection and generation. */
+	cached_kn02_csr &= ~(KN02_CSR_DIAGCHK | KN02_CSR_DIAGGEN);
+	/* Enable ECC correction. */
+	cached_kn02_csr |= KN02_CSR_CORRECT;
+	*csr = cached_kn02_csr;
+	iob();
+
+	spin_unlock_irqrestore(&kn02_lock, flags);
+}
+
+static inline void dec_kn03_be_init(void)
+{
+	volatile u32 *mcr = (void *)(KN03_SLOT_BASE + IOASIC_MCR);
+	volatile u32 *mbcs = (void *)(KN03_SLOT_BASE + KN05_MB_CSR);
+
+	kn0x_erraddr = (void *)(KN03_SLOT_BASE + IOASIC_ERRADDR);
+	kn0x_chksyn = (void *)(KN03_SLOT_BASE + IOASIC_CHKSYN);
+			
+	/*
+	 * Set normal ECC detection and generation, enable ECC correction.
+	 * For KN05 we also need to make sure EE (?) is enabled in the MB.
+	 * Otherwise DBE/IBE exceptions would be masked but bus error
+	 * interrupts would still arrive, resulting in an inevitable crash
+	 * if get_dbe() triggers one.
+	 */
+	*mcr = (*mcr & ~(KN03_MCR_DIAGCHK | KN03_MCR_DIAGGEN)) |
+	       KN03_MCR_CORRECT;
+	if (current_cpu_data.cputype == CPU_R4400SC)
+		*mbcs |= KN05_MB_CSR_EE;
+	fast_iob();
+}
+
+void __init dec_ecc_be_init(void)
+{
+	if (mips_machtype == MACH_DS5000_200)
+		dec_kn02_be_init();
+	else
+		dec_kn03_be_init();
+
+	/* Clear any leftover errors from the firmware. */
+	dec_ecc_be_ack();
+}
