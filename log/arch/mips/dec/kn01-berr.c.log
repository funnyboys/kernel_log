commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/dec/kn01-berr.c b/arch/mips/dec/kn01-berr.c
index e9d2db480aeb..76efed7bc9f3 100644
--- a/arch/mips/dec/kn01-berr.c
+++ b/arch/mips/dec/kn01-berr.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *	Bus error event handling code for DECstation/DECsystem 3100
  *	and 2100 (KN01) systems equipped with parity error detection
  *	logic.
  *
  *	Copyright (c) 2005  Maciej W. Rozycki
- *
- *	This program is free software; you can redistribute it and/or
- *	modify it under the terms of the GNU General Public License
- *	as published by the Free Software Foundation; either version
- *	2 of the License, or (at your option) any later version.
  */
 
 #include <linux/init.h>

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/dec/kn01-berr.c b/arch/mips/dec/kn01-berr.c
index 44d8a87a8a68..e9d2db480aeb 100644
--- a/arch/mips/dec/kn01-berr.c
+++ b/arch/mips/dec/kn01-berr.c
@@ -23,7 +23,7 @@
 #include <asm/page.h>
 #include <asm/ptrace.h>
 #include <asm/traps.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include <asm/dec/kn01.h>
 

commit b81947c646bfefdf98e2fde5d7d39cbbda8525d4
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for MIPS
    
    Disintegrate asm/system.h for MIPS.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    cc: linux-mips@linux-mips.org

diff --git a/arch/mips/dec/kn01-berr.c b/arch/mips/dec/kn01-berr.c
index 94d23b4a7dc3..44d8a87a8a68 100644
--- a/arch/mips/dec/kn01-berr.c
+++ b/arch/mips/dec/kn01-berr.c
@@ -22,7 +22,6 @@
 #include <asm/mipsregs.h>
 #include <asm/page.h>
 #include <asm/ptrace.h>
-#include <asm/system.h>
 #include <asm/traps.h>
 #include <asm/uaccess.h>
 

commit 32baba2fb7149ac262be1dca39291b55d846a075
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Feb 27 12:53:36 2010 +0100

    MIPS: DEC: Convert KN01 lock to raw spinlock.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/kn01-berr.c b/arch/mips/dec/kn01-berr.c
index b9bdc6f8ba7f..94d23b4a7dc3 100644
--- a/arch/mips/dec/kn01-berr.c
+++ b/arch/mips/dec/kn01-berr.c
@@ -46,7 +46,7 @@
  * There is no default value -- it has to be initialized.
  */
 u16 cached_kn01_csr;
-static DEFINE_SPINLOCK(kn01_lock);
+static DEFINE_RAW_SPINLOCK(kn01_lock);
 
 
 static inline void dec_kn01_be_ack(void)
@@ -54,12 +54,12 @@ static inline void dec_kn01_be_ack(void)
 	volatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);
 	unsigned long flags;
 
-	spin_lock_irqsave(&kn01_lock, flags);
+	raw_spin_lock_irqsave(&kn01_lock, flags);
 
 	*csr = cached_kn01_csr | KN01_CSR_MEMERR;	/* Clear bus IRQ. */
 	iob();
 
-	spin_unlock_irqrestore(&kn01_lock, flags);
+	raw_spin_unlock_irqrestore(&kn01_lock, flags);
 }
 
 static int dec_kn01_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
@@ -182,7 +182,7 @@ void __init dec_kn01_be_init(void)
 	volatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);
 	unsigned long flags;
 
-	spin_lock_irqsave(&kn01_lock, flags);
+	raw_spin_lock_irqsave(&kn01_lock, flags);
 
 	/* Preset write-only bits of the Control Register cache. */
 	cached_kn01_csr = *csr;
@@ -194,7 +194,7 @@ void __init dec_kn01_be_init(void)
 	*csr = cached_kn01_csr;
 	iob();
 
-	spin_unlock_irqrestore(&kn01_lock, flags);
+	raw_spin_unlock_irqrestore(&kn01_lock, flags);
 
 	/* Clear any leftover errors from the firmware. */
 	dec_kn01_be_ack();

commit 4a8a738de637dc7141de5228d2d722573a329b95
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Feb 27 12:53:30 2010 +0100

    MIPS: Make various locks static.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/kn01-berr.c b/arch/mips/dec/kn01-berr.c
index b0dc6d53edd6..b9bdc6f8ba7f 100644
--- a/arch/mips/dec/kn01-berr.c
+++ b/arch/mips/dec/kn01-berr.c
@@ -46,7 +46,7 @@
  * There is no default value -- it has to be initialized.
  */
 u16 cached_kn01_csr;
-DEFINE_SPINLOCK(kn01_lock);
+static DEFINE_SPINLOCK(kn01_lock);
 
 
 static inline void dec_kn01_be_ack(void)

commit 49316cbf0a9875f102f98dc8b7c80cfa142e33cf
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Jul 6 09:13:17 2009 +0100

    MIPS: Eleminate filenames from comments
    
    They tend to get not updated when files are moved around or copied and
    lack any obvious use.  While at it zap some only too obvious comments and
    as per Shinya's suggestion, add a copyright header to extable.c.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
    Acked-by: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>

diff --git a/arch/mips/dec/kn01-berr.c b/arch/mips/dec/kn01-berr.c
index d3b8002bf1e7..b0dc6d53edd6 100644
--- a/arch/mips/dec/kn01-berr.c
+++ b/arch/mips/dec/kn01-berr.c
@@ -1,6 +1,4 @@
 /*
- *	linux/arch/mips/dec/kn01-berr.c
- *
  *	Bus error event handling code for DECstation/DECsystem 3100
  *	and 2100 (KN01) systems equipped with parity error detection
  *	logic.

commit 49afb1f67b42c4240fef9d2d8b76c317c56a189d
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Wed Dec 6 11:50:23 2006 +0000

    [MIPS] *-berr: Header inclusions for DEC bus error handlers
    
     A fixup to add missing header inclusions for bus error handlers for
    DECstation system after the recent switch to get_irq_regs().
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/kn01-berr.c b/arch/mips/dec/kn01-berr.c
index f19b4617a0a6..d3b8002bf1e7 100644
--- a/arch/mips/dec/kn01-berr.c
+++ b/arch/mips/dec/kn01-berr.c
@@ -20,8 +20,10 @@
 #include <linux/types.h>
 
 #include <asm/inst.h>
+#include <asm/irq_regs.h>
 #include <asm/mipsregs.h>
 #include <asm/page.h>
+#include <asm/ptrace.h>
 #include <asm/system.h>
 #include <asm/traps.h>
 #include <asm/uaccess.h>

commit 6dab2f4564b3dc8747452e256fb779f320ff5650
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 9 00:00:31 2006 +0100

    [MIPS] DEC: pt_regs fixes for buserror handlers
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/kn01-berr.c b/arch/mips/dec/kn01-berr.c
index b9271db9bc76..f19b4617a0a6 100644
--- a/arch/mips/dec/kn01-berr.c
+++ b/arch/mips/dec/kn01-berr.c
@@ -150,10 +150,10 @@ int dec_kn01_be_handler(struct pt_regs *regs, int is_fixup)
 	return dec_kn01_be_backend(regs, is_fixup, 0);
 }
 
-irqreturn_t dec_kn01_be_interrupt(int irq, void *dev_id,
-				    struct pt_regs *regs)
+irqreturn_t dec_kn01_be_interrupt(int irq, void *dev_id)
 {
 	volatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);
+	struct pt_regs *regs = get_irq_regs();
 	int action;
 
 	if (!(*csr & KN01_CSR_MEMERR))

commit a5fc9c0bbee8b91025993a49a9176a88380aef3c
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Fri Jul 1 16:10:40 2005 +0000

    Use physical addresses at the interface level, letting drivers remap
    them as appropriate.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/kn01-berr.c b/arch/mips/dec/kn01-berr.c
index 8ec7b30a90c1..b9271db9bc76 100644
--- a/arch/mips/dec/kn01-berr.c
+++ b/arch/mips/dec/kn01-berr.c
@@ -51,7 +51,7 @@ DEFINE_SPINLOCK(kn01_lock);
 
 static inline void dec_kn01_be_ack(void)
 {
-	volatile u16 *csr = (void *)(KN01_SLOT_BASE + KN01_CSR);
+	volatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);
 	unsigned long flags;
 
 	spin_lock_irqsave(&kn01_lock, flags);
@@ -64,7 +64,8 @@ static inline void dec_kn01_be_ack(void)
 
 static int dec_kn01_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
 {
-	volatile u32 *kn01_erraddr = (void *)(KN01_SLOT_BASE + KN01_ERRADDR);
+	volatile u32 *kn01_erraddr = (void *)CKSEG1ADDR(KN01_SLOT_BASE +
+							KN01_ERRADDR);
 
 	static const char excstr[] = "exception";
 	static const char intstr[] = "interrupt";
@@ -152,7 +153,7 @@ int dec_kn01_be_handler(struct pt_regs *regs, int is_fixup)
 irqreturn_t dec_kn01_be_interrupt(int irq, void *dev_id,
 				    struct pt_regs *regs)
 {
-	volatile u16 *csr = (void *)(KN01_SLOT_BASE + KN01_CSR);
+	volatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);
 	int action;
 
 	if (!(*csr & KN01_CSR_MEMERR))
@@ -178,7 +179,7 @@ irqreturn_t dec_kn01_be_interrupt(int irq, void *dev_id,
 
 void __init dec_kn01_be_init(void)
 {
-	volatile u16 *csr = (void *)(KN01_SLOT_BASE + KN01_CSR);
+	volatile u16 *csr = (void *)CKSEG1ADDR(KN01_SLOT_BASE + KN01_CSR);
 	unsigned long flags;
 
 	spin_lock_irqsave(&kn01_lock, flags);

commit 69c75fb458cd81bb29e1d9580469110b00316748
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Wed Jun 22 20:58:45 2005 +0000

    Actual handlers for bus errors for Pmax and 3min.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
    diff --git a/arch/mips/dec/kn01-berr.c b/arch/mips/dec/kn01-berr.c
    new file mode 100644

diff --git a/arch/mips/dec/kn01-berr.c b/arch/mips/dec/kn01-berr.c
new file mode 100644
index 000000000000..8ec7b30a90c1
--- /dev/null
+++ b/arch/mips/dec/kn01-berr.c
@@ -0,0 +1,200 @@
+/*
+ *	linux/arch/mips/dec/kn01-berr.c
+ *
+ *	Bus error event handling code for DECstation/DECsystem 3100
+ *	and 2100 (KN01) systems equipped with parity error detection
+ *	logic.
+ *
+ *	Copyright (c) 2005  Maciej W. Rozycki
+ *
+ *	This program is free software; you can redistribute it and/or
+ *	modify it under the terms of the GNU General Public License
+ *	as published by the Free Software Foundation; either version
+ *	2 of the License, or (at your option) any later version.
+ */
+
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+
+#include <asm/inst.h>
+#include <asm/mipsregs.h>
+#include <asm/page.h>
+#include <asm/system.h>
+#include <asm/traps.h>
+#include <asm/uaccess.h>
+
+#include <asm/dec/kn01.h>
+
+
+/* CP0 hazard avoidance. */
+#define BARRIER				\
+	__asm__ __volatile__(		\
+		".set	push\n\t"	\
+		".set	noreorder\n\t"	\
+		"nop\n\t"		\
+		".set	pop\n\t")
+
+/*
+ * Bits 7:0 of the Control Register are write-only -- the
+ * corresponding bits of the Status Register have a different
+ * meaning.  Hence we use a cache.  It speeds up things a bit
+ * as well.
+ *
+ * There is no default value -- it has to be initialized.
+ */
+u16 cached_kn01_csr;
+DEFINE_SPINLOCK(kn01_lock);
+
+
+static inline void dec_kn01_be_ack(void)
+{
+	volatile u16 *csr = (void *)(KN01_SLOT_BASE + KN01_CSR);
+	unsigned long flags;
+
+	spin_lock_irqsave(&kn01_lock, flags);
+
+	*csr = cached_kn01_csr | KN01_CSR_MEMERR;	/* Clear bus IRQ. */
+	iob();
+
+	spin_unlock_irqrestore(&kn01_lock, flags);
+}
+
+static int dec_kn01_be_backend(struct pt_regs *regs, int is_fixup, int invoker)
+{
+	volatile u32 *kn01_erraddr = (void *)(KN01_SLOT_BASE + KN01_ERRADDR);
+
+	static const char excstr[] = "exception";
+	static const char intstr[] = "interrupt";
+	static const char cpustr[] = "CPU";
+	static const char mreadstr[] = "memory read";
+	static const char readstr[] = "read";
+	static const char writestr[] = "write";
+	static const char timestr[] = "timeout";
+	static const char paritystr[] = "parity error";
+
+	int data = regs->cp0_cause & 4;
+	unsigned int __user *pc = (unsigned int __user *)regs->cp0_epc +
+				  ((regs->cp0_cause & CAUSEF_BD) != 0);
+	union mips_instruction insn;
+	unsigned long entrylo, offset;
+	long asid, entryhi, vaddr;
+
+	const char *kind, *agent, *cycle, *event;
+	unsigned long address;
+
+	u32 erraddr = *kn01_erraddr;
+	int action = MIPS_BE_FATAL;
+
+	/* Ack ASAP, so that any subsequent errors get caught. */
+	dec_kn01_be_ack();
+
+	kind = invoker ? intstr : excstr;
+
+	agent = cpustr;
+
+	if (invoker)
+		address = erraddr;
+	else {
+		/* Bloody hardware doesn't record the address for reads... */
+		if (data) {
+			/* This never faults. */
+			__get_user(insn.word, pc);
+			vaddr = regs->regs[insn.i_format.rs] +
+				insn.i_format.simmediate;
+		} else
+			vaddr = (long)pc;
+		if (KSEGX(vaddr) == CKSEG0 || KSEGX(vaddr) == CKSEG1)
+			address = CPHYSADDR(vaddr);
+		else {
+			/* Peek at what physical address the CPU used. */
+			asid = read_c0_entryhi();
+			entryhi = asid & (PAGE_SIZE - 1);
+			entryhi |= vaddr & ~(PAGE_SIZE - 1);
+			write_c0_entryhi(entryhi);
+			BARRIER;
+			tlb_probe();
+			/* No need to check for presence. */
+			tlb_read();
+			entrylo = read_c0_entrylo0();
+			write_c0_entryhi(asid);
+			offset = vaddr & (PAGE_SIZE - 1);
+			address = (entrylo & ~(PAGE_SIZE - 1)) | offset;
+		}
+	}
+
+	/* Treat low 256MB as memory, high -- as I/O. */
+	if (address < 0x10000000) {
+		cycle = mreadstr;
+		event = paritystr;
+	} else {
+		cycle = invoker ? writestr : readstr;
+		event = timestr;
+	}
+
+	if (is_fixup)
+		action = MIPS_BE_FIXUP;
+
+	if (action != MIPS_BE_FIXUP)
+		printk(KERN_ALERT "Bus error %s: %s %s %s at %#010lx\n",
+			kind, agent, cycle, event, address);
+
+	return action;
+}
+
+int dec_kn01_be_handler(struct pt_regs *regs, int is_fixup)
+{
+	return dec_kn01_be_backend(regs, is_fixup, 0);
+}
+
+irqreturn_t dec_kn01_be_interrupt(int irq, void *dev_id,
+				    struct pt_regs *regs)
+{
+	volatile u16 *csr = (void *)(KN01_SLOT_BASE + KN01_CSR);
+	int action;
+
+	if (!(*csr & KN01_CSR_MEMERR))
+		return IRQ_NONE;		/* Must have been video. */
+
+	action = dec_kn01_be_backend(regs, 0, 1);
+
+	if (action == MIPS_BE_DISCARD)
+		return IRQ_HANDLED;
+
+	/*
+	 * FIXME: Find the affected processes and kill them, otherwise
+	 * we must die.
+	 *
+	 * The interrupt is asynchronously delivered thus EPC and RA
+	 * may be irrelevant, but are printed for a reference.
+	 */
+	printk(KERN_ALERT "Fatal bus interrupt, epc == %08lx, ra == %08lx\n",
+	       regs->cp0_epc, regs->regs[31]);
+	die("Unrecoverable bus error", regs);
+}
+
+
+void __init dec_kn01_be_init(void)
+{
+	volatile u16 *csr = (void *)(KN01_SLOT_BASE + KN01_CSR);
+	unsigned long flags;
+
+	spin_lock_irqsave(&kn01_lock, flags);
+
+	/* Preset write-only bits of the Control Register cache. */
+	cached_kn01_csr = *csr;
+	cached_kn01_csr &= KN01_CSR_STATUS | KN01_CSR_PARDIS | KN01_CSR_TXDIS;
+	cached_kn01_csr |= KN01_CSR_LEDS;
+
+	/* Enable parity error detection. */
+	cached_kn01_csr &= ~KN01_CSR_PARDIS;
+	*csr = cached_kn01_csr;
+	iob();
+
+	spin_unlock_irqrestore(&kn01_lock, flags);
+
+	/* Clear any leftover errors from the firmware. */
+	dec_kn01_be_ack();
+}
