commit f06e7aa47f3cad55c5737eb87280e90e25882d60
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Mon May 7 17:28:28 2018 +0800

    MIPS: Convert update_persistent_clock() to update_persistent_clock64()
    
    Since struct timespec is not y2038 safe on 32bit machines, this patch
    converts update_persistent_clock() to update_persistent_clock64() using
    struct timespec64.
    
    The rtc_mips_set_time() and rtc_mips_set_mmss() interfaces were using
    'unsigned long' type that is not y2038 safe on 32bit machines, moreover
    there is only one platform implementing rtc_mips_set_time() and two
    platforms implementing rtc_mips_set_mmss(), so we can just make them each
    implement update_persistent_clock64() directly, to get that helper out
    of the common mips code by removing rtc_mips_set_time() and
    rtc_mips_set_mmss() interfaces.
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@linux-mips.org
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 9e992cf1129e..c38686f89a18 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -59,14 +59,15 @@ void read_persistent_clock64(struct timespec64 *ts)
 }
 
 /*
- * In order to set the CMOS clock precisely, rtc_mips_set_mmss has to
+ * In order to set the CMOS clock precisely, update_persistent_clock64 has to
  * be called 500 ms after the second nowtime has started, because when
  * nowtime is written into the registers of the CMOS clock, it will
  * jump to the next second precisely 500 ms later.  Check the Dallas
  * DS1287 data sheet for details.
  */
-int rtc_mips_set_mmss(unsigned long nowtime)
+int update_persistent_clock64(struct timespec64 now)
 {
+	time64_t nowtime = now.tv_sec;
 	int retval = 0;
 	int real_seconds, real_minutes, cmos_minutes;
 	unsigned char save_control, save_freq_select;
@@ -91,8 +92,7 @@ int rtc_mips_set_mmss(unsigned long nowtime)
 	 * messing with unknown time zones but requires your
 	 * RTC not to be off by more than 15 minutes
 	 */
-	real_seconds = nowtime % 60;
-	real_minutes = nowtime / 60;
+	real_minutes = div_s64_rem(nowtime, 60, &real_seconds);
 	if (((abs(real_minutes - cmos_minutes) + 15) / 30) & 1)
 		real_minutes += 30;	/* correct for half hour time zone */
 	real_minutes %= 60;

commit 09adad17191942cac01ccfbb897b976ac8f42c22
Author: Baolin Wang <baolin.wang@linaro.org>
Date:   Mon May 7 17:28:27 2018 +0800

    MIPS: Convert read_persistent_clock() to read_persistent_clock64()
    
    Since struct timespec is not y2038 safe on 32bit machines, this patch
    converts read_persistent_clock() to read_persistent_clock64() using
    struct timespec64, as well as converting mktime() to mktime64().
    
    Signed-off-by: Baolin Wang <baolin.wang@linaro.org>
    Acked-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@linux-mips.org
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index a2a150e4fbc2..9e992cf1129e 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -19,7 +19,7 @@
 #include <asm/dec/ioasic.h>
 #include <asm/dec/machtype.h>
 
-void read_persistent_clock(struct timespec *ts)
+void read_persistent_clock64(struct timespec64 *ts)
 {
 	unsigned int year, mon, day, hour, min, sec, real_year;
 	unsigned long flags;
@@ -54,7 +54,7 @@ void read_persistent_clock(struct timespec *ts)
 
 	year += real_year - 72 + 2000;
 
-	ts->tv_sec = mktime(year, mon, day, hour, min, sec);
+	ts->tv_sec = mktime64(year, mon, day, hour, min, sec);
 	ts->tv_nsec = 0;
 }
 

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 1914e56f0d96..a2a150e4fbc2 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  Copyright (C) 1991, 1992, 1995  Linus Torvalds
  *  Copyright (C) 2000, 2003  Maciej W. Rozycki

commit daed1285c33582d93447a0ad971bbc1dd15d1940
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Thu Sep 12 12:01:53 2013 +0100

    MIPS: DECstation HRT initialization rearrangement
    
    Not all I/O ASIC versions have the free-running counter implemented, an
    early revision used in the 5000/1xx models aka 3MIN and 4MIN did not have
    it.  Therefore we cannot unconditionally use it as a clock source.
    Fortunately if not implemented its register slot has a fixed value so it
    is enough if we check for the value at the end of the calibration period
    being the same as at the beginning.
    
    This also means we need to look for another high-precision clock source on
    the systems affected.  The 5000/1xx can have an R4000SC processor
    installed where the CP0 Count register can be used as a clock source.
    Unfortunately all the R4k DECstations suffer from the missed timer
    interrupt on CP0 Count reads erratum, so we cannot use the CP0 timer as a
    clock source and a clock event both at a time.  However we never need an
    R4k clock event device because all DECstations have a DS1287A RTC chip
    whose periodic interrupt can be used as a clock source.
    
    This gives us the following four configuration possibilities for I/O ASIC
    DECstations:
    
    1. No I/O ASIC counter and no CP0 timer, e.g. R3k 5000/1xx (3MIN).
    
    2. No I/O ASIC counter but the CP0 timer, i.e. R4k 5000/150 (4MIN).
    
    3. The I/O ASIC counter but no CP0 timer, e.g. R3k 5000/240 (3MAX+).
    
    4. The I/O ASIC counter and the CP0 timer, e.g. R4k 5000/260 (4MAX+).
    
    For #1 and #2 this change stops the I/O ASIC free-running counter from
    being installed as a clock source of a 0Hz frequency.  For #2 it also
    arranges for the CP0 timer to be used as a clock source rather than a
    clock event device, because having an accurate wall clock is more
    important than a high-precision interval timer.  For #3 there is no
    change.  For #4 the change makes the I/O ASIC free-running counter
    installed as a clock source so that the CP0 timer can be used as a clock
    event device.
    
    Unfortunately the use of the CP0 timer as a clock event device relies on a
    succesful completion of c0_compare_interrupt.  That never happens, because
    while waiting for a CP0 Compare interrupt to happen the function spins in
    a loop reading the CP0 Count register.  This makes the CP0 Count erratum
    trigger reliably causing the interrupt waited for to be lost in all cases.
    As a result #4 resorts to using the CP0 timer as a clock source as well,
    just as #2.  However we want to keep this separate arrangement in case
    (hope) c0_compare_interrupt is eventually rewritten such that it avoids
    the erratum.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5825/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 56ebc7f2bede..1914e56f0d96 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -125,12 +125,16 @@ int rtc_mips_set_mmss(unsigned long nowtime)
 
 void __init plat_time_init(void)
 {
+	int ioasic_clock = 0;
 	u32 start, end;
 	int i = HZ / 8;
 
 	/* Set up the rate of periodic DS1287 interrupts. */
 	ds1287_set_base_clock(HZ);
 
+	/* On some I/O ASIC systems we have the I/O ASIC's counter.  */
+	if (IOASIC)
+		ioasic_clock = dec_ioasic_clocksource_init() == 0;
 	if (cpu_has_counter) {
 		ds1287_timer_state();
 		while (!ds1287_timer_state())
@@ -147,9 +151,21 @@ void __init plat_time_init(void)
 		mips_hpt_frequency = (end - start) * 8;
 		printk(KERN_INFO "MIPS counter frequency %dHz\n",
 			mips_hpt_frequency);
-	} else if (IOASIC)
-		/* For pre-R4k systems we use the I/O ASIC's counter.  */
-		dec_ioasic_clocksource_init();
+
+		/*
+		 * All R4k DECstations suffer from the CP0 Count erratum,
+		 * so we can't use the timer as a clock source, and a clock
+		 * event both at a time.  An accurate wall clock is more
+		 * important than a high-precision interval timer so only
+		 * use the timer as a clock source, and not a clock event
+		 * if there's no I/O ASIC counter available to serve as a
+		 * clock source.
+		 */
+		if (!ioasic_clock) {
+			init_r4k_clocksource();
+			mips_hpt_frequency = 0;
+		}
+	}
 
 	ds1287_clockevent_init(dec_interrupt[DEC_IRQ_RTC]);
 }

commit 8533966a6dba09d65a6764accdf44f3e96cddbfb
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Wed Sep 4 23:47:45 2013 +0100

    MIPS: DECstation HRT calibration bug fixes
    
    This change corrects DECstation HRT calibration, by removing the following
    bugs:
    
    1. Calibration period selection -- HZ / 10 has been chosen, however on
       DECstation computers, HZ never divides by 10, as the choice for HZ is
       among 128, 256 and 1024.  The choice therefore results in a systematic
       calibration error, e.g. 6.25% for the usual choice of 128 for HZ:
    
       128 / 10 * 10 = 120
    
       (128 - 120) / 128 -> 6.25%
    
       The change therefore makes calibration use HZ / 8 that is always
       accurate for the HZ values available, getting rid of the systematic
       error.
    
    2. Calibration starting point synchronisation -- the duration of a number
       of intervals between DS1287A periodic interrupt assertions is measured,
       however code does not ensure at the beginning that the interrupt has
       not been previously asserted.  This results in a variable error of e.g.
       up to another 6.25% for the period of HZ / 8 (8.(3)% with the original
       HZ / 10 period) and the usual choice of 128 for HZ:
    
       1 / 16 -> 6.25%
    
       1 / 12 -> 8.(3)%
    
       The change therefore adds an initial call to ds1287_timer_state that
       clears any previous periodic interrupt pending.
    
    The same issue applies to both I/O ASIC counter and R4k CP0 timer
    calibration on DECstation systems as similar code is used in both cases
    and both pieces of code are covered by this fix.
    
    On an R3400 test system used this fix results in a change of the I/O ASIC
    clock frequency reported from values like:
    
    I/O ASIC clock frequency 23185830Hz
    
    to:
    
    I/O ASIC clock frequency 24999288Hz
    
    removing the miscalculation by 6.25% from the systematic error and (for
    the individual sample provided) a further 1.00% from the variable error,
    accordingly.  The nominal I/O ASIC clock frequency is 25MHz on this
    system.
    
    Here's another result, with the fix applied, from a system that has both
    HRTs available (using an R4400 at 60MHz nominal):
    
    MIPS counter frequency 59999328Hz
    I/O ASIC clock frequency 24999432Hz
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5807/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index ea57f39e6736..56ebc7f2bede 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -126,12 +126,13 @@ int rtc_mips_set_mmss(unsigned long nowtime)
 void __init plat_time_init(void)
 {
 	u32 start, end;
-	int i = HZ / 10;
+	int i = HZ / 8;
 
 	/* Set up the rate of periodic DS1287 interrupts. */
 	ds1287_set_base_clock(HZ);
 
 	if (cpu_has_counter) {
+		ds1287_timer_state();
 		while (!ds1287_timer_state())
 			;
 
@@ -143,7 +144,7 @@ void __init plat_time_init(void)
 
 		end = read_c0_count();
 
-		mips_hpt_frequency = (end - start) * 10;
+		mips_hpt_frequency = (end - start) * 8;
 		printk(KERN_INFO "MIPS counter frequency %dHz\n",
 			mips_hpt_frequency);
 	} else if (IOASIC)

commit 3e5c12409c54c30f1d1b16bba5d4d24e35aa283c
Author: Stephen Hemminger <shemminger@vyatta.com>
Date:   Wed Jan 12 16:59:31 2011 -0800

    set_rtc_mmss: show warning message only once
    
    Occasionally the system gets into a state where the CMOS clock has gotten
    slightly ahead of current time and the periodic update of RTC fails.  The
    message is a nuisance and repeats spamming the log.
    
      See: http://www.ntp.org/ntpfaq/NTP-s-trbl-spec.htm#Q-LINUX-SET-RTC-MMSS
    
    Rather than just removing the message, make it show only once and reduce
    severity since it indicates a normal and non urgent condition.
    
    Signed-off-by: Stephen Hemminger <shemminger@vyatta.com>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 02f505f23c32..ea57f39e6736 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -104,7 +104,7 @@ int rtc_mips_set_mmss(unsigned long nowtime)
 		CMOS_WRITE(real_seconds, RTC_SECONDS);
 		CMOS_WRITE(real_minutes, RTC_MINUTES);
 	} else {
-		printk(KERN_WARNING
+		printk_once(KERN_NOTICE
 		       "set_rtc_mmss: can't update from %d to %d\n",
 		       cmos_minutes, real_minutes);
 		retval = -1;

commit d4f587c67fc39e0030ddd718675e252e208da4d7
Author: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date:   Fri Aug 14 15:47:31 2009 +0200

    timekeeping: Increase granularity of read_persistent_clock()
    
    The persistent clock of some architectures (e.g. s390) have a
    better granularity than seconds. To reduce the delta between the
    host clock and the guest clock in a virtualized system change the
    read_persistent_clock function to return a struct timespec.
    
    Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Acked-by: John Stultz <johnstul@us.ibm.com>
    Cc: Daniel Walker <dwalker@fifo99.com>
    LKML-Reference: <20090814134811.013873340@de.ibm.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 463136e6685a..02f505f23c32 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -18,7 +18,7 @@
 #include <asm/dec/ioasic.h>
 #include <asm/dec/machtype.h>
 
-unsigned long read_persistent_clock(void)
+void read_persistent_clock(struct timespec *ts)
 {
 	unsigned int year, mon, day, hour, min, sec, real_year;
 	unsigned long flags;
@@ -53,7 +53,8 @@ unsigned long read_persistent_clock(void)
 
 	year += real_year - 72 + 2000;
 
-	return mktime(year, mon, day, hour, min, sec);
+	ts->tv_sec = mktime(year, mon, day, hour, min, sec);
+	ts->tv_nsec = 0;
 }
 
 /*

commit 49316cbf0a9875f102f98dc8b7c80cfa142e33cf
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Jul 6 09:13:17 2009 +0100

    MIPS: Eleminate filenames from comments
    
    They tend to get not updated when files are moved around or copied and
    lack any obvious use.  While at it zap some only too obvious comments and
    as per Shinya's suggestion, add a copyright header to extable.c.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
    Acked-by: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 1359c03ded51..463136e6685a 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -1,6 +1,4 @@
 /*
- *  linux/arch/mips/dec/time.c
- *
  *  Copyright (C) 1991, 1992, 1995  Linus Torvalds
  *  Copyright (C) 2000, 2003  Maciej W. Rozycki
  *

commit 02112dbc925f664bc4d24ff098686b9d21bfbfb1
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Oct 18 20:28:44 2008 -0700

    mips: use bcd2bin/bin2bcd
    
    Changes mips to use the new bcd2bin/bin2bcd functions instead of the
    obsolete BCD_TO_BIN/BIN_TO_BCD/BCD2BIN/BIN2BCD macros.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 3965fda94a89..1359c03ded51 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -45,12 +45,12 @@ unsigned long read_persistent_clock(void)
 	spin_unlock_irqrestore(&rtc_lock, flags);
 
 	if (!(CMOS_READ(RTC_CONTROL) & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
-		sec = BCD2BIN(sec);
-		min = BCD2BIN(min);
-		hour = BCD2BIN(hour);
-		day = BCD2BIN(day);
-		mon = BCD2BIN(mon);
-		year = BCD2BIN(year);
+		sec = bcd2bin(sec);
+		min = bcd2bin(min);
+		hour = bcd2bin(hour);
+		day = bcd2bin(day);
+		mon = bcd2bin(mon);
+		year = bcd2bin(year);
 	}
 
 	year += real_year - 72 + 2000;
@@ -83,7 +83,7 @@ int rtc_mips_set_mmss(unsigned long nowtime)
 
 	cmos_minutes = CMOS_READ(RTC_MINUTES);
 	if (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD)
-		cmos_minutes = BCD2BIN(cmos_minutes);
+		cmos_minutes = bcd2bin(cmos_minutes);
 
 	/*
 	 * since we're only adjusting minutes and seconds,
@@ -99,8 +99,8 @@ int rtc_mips_set_mmss(unsigned long nowtime)
 
 	if (abs(real_minutes - cmos_minutes) < 30) {
 		if (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
-			real_seconds = BIN2BCD(real_seconds);
-			real_minutes = BIN2BCD(real_minutes);
+			real_seconds = bin2bcd(real_seconds);
+			real_minutes = bin2bcd(real_minutes);
 		}
 		CMOS_WRITE(real_seconds, RTC_SECONDS);
 		CMOS_WRITE(real_minutes, RTC_MINUTES);

commit 6457d9fc3bb87c72db03cfb34cd414c8fb9b8edf
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Fri Apr 25 12:11:44 2008 +0900

    [MIPS] DS1287: Add clockevent driver
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 0cbab8d0052b..3965fda94a89 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -9,30 +9,15 @@
  *
  */
 #include <linux/bcd.h>
-#include <linux/errno.h>
 #include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/kernel.h>
 #include <linux/mc146818rtc.h>
-#include <linux/mm.h>
-#include <linux/module.h>
 #include <linux/param.h>
-#include <linux/sched.h>
-#include <linux/string.h>
-#include <linux/time.h>
-#include <linux/types.h>
-
-#include <asm/bootinfo.h>
-#include <asm/cpu.h>
-#include <asm/io.h>
-#include <asm/irq.h>
-#include <asm/mipsregs.h>
-#include <asm/sections.h>
-#include <asm/time.h>
 
+#include <asm/cpu-features.h>
+#include <asm/ds1287.h>
+#include <asm/time.h>
 #include <asm/dec/interrupts.h>
 #include <asm/dec/ioasic.h>
-#include <asm/dec/ioasic_addrs.h>
 #include <asm/dec/machtype.h>
 
 unsigned long read_persistent_clock(void)
@@ -139,42 +124,32 @@ int rtc_mips_set_mmss(unsigned long nowtime)
 	return retval;
 }
 
-static int dec_timer_state(void)
+void __init plat_time_init(void)
 {
-	return (CMOS_READ(RTC_REG_C) & RTC_PF) != 0;
-}
+	u32 start, end;
+	int i = HZ / 10;
 
-static void dec_timer_ack(void)
-{
-	CMOS_READ(RTC_REG_C);			/* Ack the RTC interrupt.  */
-}
+	/* Set up the rate of periodic DS1287 interrupts. */
+	ds1287_set_base_clock(HZ);
 
-static cycle_t dec_ioasic_hpt_read(void)
-{
-	/*
-	 * The free-running counter is 32-bit which is good for about
-	 * 2 minutes, 50 seconds at possible count rates of up to 25MHz.
-	 */
-	return ioasic_read(IO_REG_FCTR);
-}
+	if (cpu_has_counter) {
+		while (!ds1287_timer_state())
+			;
 
+		start = read_c0_count();
 
-void __init plat_time_init(void)
-{
-	mips_timer_ack = dec_timer_ack;
+		while (i--)
+			while (!ds1287_timer_state())
+				;
+
+		end = read_c0_count();
 
-	if (!cpu_has_counter && IOASIC)
+		mips_hpt_frequency = (end - start) * 10;
+		printk(KERN_INFO "MIPS counter frequency %dHz\n",
+			mips_hpt_frequency);
+	} else if (IOASIC)
 		/* For pre-R4k systems we use the I/O ASIC's counter.  */
 		dec_ioasic_clocksource_init();
 
-	/* Set up the rate of periodic DS1287 interrupts.  */
-	CMOS_WRITE(RTC_REF_CLCK_32KHZ | (16 - __ffs(HZ)), RTC_REG_A);
-}
-
-void __init plat_timer_setup(struct irqaction *irq)
-{
-	setup_irq(dec_interrupt[DEC_IRQ_RTC], irq);
-
-	/* Enable periodic DS1287 interrupts.  */
-	CMOS_WRITE(CMOS_READ(RTC_REG_B) | RTC_PIE, RTC_REG_B);
+	ds1287_clockevent_init(dec_interrupt[DEC_IRQ_RTC]);
 }

commit 4247417d8457b326ede001cb74af8570b5aa302b
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Thu Apr 24 09:48:40 2008 +0900

    [MIPS] add DECstation I/O ASIC clocksource
    
    Add DECstation I/O ASIC clocksource
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 60349062595a..0cbab8d0052b 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -165,7 +165,7 @@ void __init plat_time_init(void)
 
 	if (!cpu_has_counter && IOASIC)
 		/* For pre-R4k systems we use the I/O ASIC's counter.  */
-		clocksource_mips.read = dec_ioasic_hpt_read;
+		dec_ioasic_clocksource_init();
 
 	/* Set up the rate of periodic DS1287 interrupts.  */
 	CMOS_WRITE(RTC_REF_CLCK_32KHZ | (16 - __ffs(HZ)), RTC_REG_A);

commit c9662341f8a09cffd7234a89cc066c342fe343bf
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Sun Dec 9 21:19:36 2007 +0900

    [MIPS] time: remove unused mips_timer_state()
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 820e5331205f..60349062595a 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -161,7 +161,6 @@ static cycle_t dec_ioasic_hpt_read(void)
 
 void __init plat_time_init(void)
 {
-	mips_timer_state = dec_timer_state;
 	mips_timer_ack = dec_timer_ack;
 
 	if (!cpu_has_counter && IOASIC)

commit 4b550488f894c899aa54dc935c8fee47bca2b7df
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:08 2007 +0100

    [MIPS] Deforest the function pointer jungle in the time code.
    
    Hard to follow who is pointing what to where and why so it's simply getting
    in the way of the time code renovation.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index e2973a432b92..820e5331205f 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -35,7 +35,7 @@
 #include <asm/dec/ioasic_addrs.h>
 #include <asm/dec/machtype.h>
 
-static unsigned long dec_rtc_get_time(void)
+unsigned long read_persistent_clock(void)
 {
 	unsigned int year, mon, day, hour, min, sec, real_year;
 	unsigned long flags;
@@ -74,13 +74,13 @@ static unsigned long dec_rtc_get_time(void)
 }
 
 /*
- * In order to set the CMOS clock precisely, dec_rtc_set_mmss has to
+ * In order to set the CMOS clock precisely, rtc_mips_set_mmss has to
  * be called 500 ms after the second nowtime has started, because when
  * nowtime is written into the registers of the CMOS clock, it will
  * jump to the next second precisely 500 ms later.  Check the Dallas
  * DS1287 data sheet for details.
  */
-static int dec_rtc_set_mmss(unsigned long nowtime)
+int rtc_mips_set_mmss(unsigned long nowtime)
 {
 	int retval = 0;
 	int real_seconds, real_minutes, cmos_minutes;
@@ -139,7 +139,6 @@ static int dec_rtc_set_mmss(unsigned long nowtime)
 	return retval;
 }
 
-
 static int dec_timer_state(void)
 {
 	return (CMOS_READ(RTC_REG_C) & RTC_PF) != 0;
@@ -160,11 +159,8 @@ static cycle_t dec_ioasic_hpt_read(void)
 }
 
 
-void __init dec_time_init(void)
+void __init plat_time_init(void)
 {
-	rtc_mips_get_time = dec_rtc_get_time;
-	rtc_mips_set_mmss = dec_rtc_set_mmss;
-
 	mips_timer_state = dec_timer_state;
 	mips_timer_ack = dec_timer_ack;
 

commit 99977c1e9faa6a28677314c16f94762fc1f3f365
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Mon Sep 24 16:13:34 2007 +0100

    [MIPS] dec/time.c: Remove no longer needed inclusion of <asm/div64.h>.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 8b7e0c17ac35..e2973a432b92 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -24,7 +24,6 @@
 
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
-#include <asm/div64.h>
 #include <asm/io.h>
 #include <asm/irq.h>
 #include <asm/mipsregs.h>

commit 005985609ff72df3257fde6b29aa9d71342c2a6b
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sun Nov 12 00:10:28 2006 +0900

    [MIPS] mips HPT cleanup: make clocksource_mips public
    
    Make clocksource_mips public and get rid of mips_hpt_read,
    mips_hpt_mask.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 69e424e9ab6f..8b7e0c17ac35 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -151,7 +151,7 @@ static void dec_timer_ack(void)
 	CMOS_READ(RTC_REG_C);			/* Ack the RTC interrupt.  */
 }
 
-static unsigned int dec_ioasic_hpt_read(void)
+static cycle_t dec_ioasic_hpt_read(void)
 {
 	/*
 	 * The free-running counter is 32-bit which is good for about
@@ -171,7 +171,7 @@ void __init dec_time_init(void)
 
 	if (!cpu_has_counter && IOASIC)
 		/* For pre-R4k systems we use the I/O ASIC's counter.  */
-		mips_hpt_read = dec_ioasic_hpt_read;
+		clocksource_mips.read = dec_ioasic_hpt_read;
 
 	/* Set up the rate of periodic DS1287 interrupts.  */
 	CMOS_WRITE(RTC_REF_CLCK_32KHZ | (16 - __ffs(HZ)), RTC_REG_A);

commit 16b7b2ac0148e839da86af8747b6fa4aad43a9b7
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Oct 24 00:21:27 2006 +0900

    [MIPS] Fixup migration to GENERIC_TIME
    
    Since we already moved to GENERIC_TIME, we should implement alternatives
    of old do_gettimeoffset routines to get sub-jiffies resolution from
    gettimeofday().  This patch includes:
    
     * MIPS clocksource support (based on works by Manish Lachwani).
     * remove unused gettimeoffset routines and related codes.
     * remove unised 64bit do_div64_32().
     * simplify mips_hpt_init. (no argument needed, __init tag)
     * simplify c0_hpt_timer_init. (no need to write to c0_count)
     * remove some hpt_init routines.
     * mips_hpt_mask variable to specify bitmask of hpt value.
     * convert jmr3927_do_gettimeoffset to jmr3927_hpt_read.
     * convert ip27_do_gettimeoffset to ip27_hpt_read.
     * convert bcm1480_do_gettimeoffset to bcm1480_hpt_read.
     * simplify sb1250 hpt functions. (no need to subtract and shift)
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 4cf0c06e2414..69e424e9ab6f 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -160,11 +160,6 @@ static unsigned int dec_ioasic_hpt_read(void)
 	return ioasic_read(IO_REG_FCTR);
 }
 
-static void dec_ioasic_hpt_init(unsigned int count)
-{
-	ioasic_write(IO_REG_FCTR, ioasic_read(IO_REG_FCTR) - count);
-}
-
 
 void __init dec_time_init(void)
 {
@@ -174,11 +169,9 @@ void __init dec_time_init(void)
 	mips_timer_state = dec_timer_state;
 	mips_timer_ack = dec_timer_ack;
 
-	if (!cpu_has_counter && IOASIC) {
+	if (!cpu_has_counter && IOASIC)
 		/* For pre-R4k systems we use the I/O ASIC's counter.  */
 		mips_hpt_read = dec_ioasic_hpt_read;
-		mips_hpt_init = dec_ioasic_hpt_init;
-	}
 
 	/* Set up the rate of periodic DS1287 interrupts.  */
 	CMOS_WRITE(RTC_REF_CLCK_32KHZ | (16 - __ffs(HZ)), RTC_REG_A);

commit 8db0201026fbb45c383176f539dc8af2a6871ab8
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 2 16:54:48 2006 +0100

    [MIPS] Fix wreckage after removal of tickadj; convert to GENERIC_TIME.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 57294740c2dd..4cf0c06e2414 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -184,8 +184,6 @@ void __init dec_time_init(void)
 	CMOS_WRITE(RTC_REF_CLCK_32KHZ | (16 - __ffs(HZ)), RTC_REG_A);
 }
 
-EXPORT_SYMBOL(do_settimeofday);
-
 void __init plat_timer_setup(struct irqaction *irq)
 {
 	setup_irq(dec_interrupt[DEC_IRQ_RTC], irq);

commit 54d0a216f40e060ba4265bb851cc36b3ca55d1a8
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sun Jul 9 21:38:56 2006 +0100

    [MIPS] Replace board_timer_setup function pointer by plat_timer_setup.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
    ---

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 76e4d09ff4d2..57294740c2dd 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -186,7 +186,7 @@ void __init dec_time_init(void)
 
 EXPORT_SYMBOL(do_settimeofday);
 
-void __init dec_timer_setup(struct irqaction *irq)
+void __init plat_timer_setup(struct irqaction *irq)
 {
 	setup_irq(dec_interrupt[DEC_IRQ_RTC], irq);
 

commit 1723b4a34af85447684c9696af83929d2c1e8e6b
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Jun 20 00:19:13 2006 +0900

    [MIPS] Make timer interrupt frequency configurable from kconfig.
    
    Make HZ configurable.  DECSTATION can select 128/256/1024 HZ, JAZZ can
    only select 100 HZ, others can select 100/128/250/256/1000/1024 HZ if
    not explicitly specified).  Also remove all mach-xxx/param.h files and
    update all defconfigs according to current HZ value.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 74cb055d4bf6..76e4d09ff4d2 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -181,7 +181,7 @@ void __init dec_time_init(void)
 	}
 
 	/* Set up the rate of periodic DS1287 interrupts.  */
-	CMOS_WRITE(RTC_REF_CLCK_32KHZ | (16 - LOG_2_HZ), RTC_REG_A);
+	CMOS_WRITE(RTC_REF_CLCK_32KHZ | (16 - __ffs(HZ)), RTC_REG_A);
 }
 
 EXPORT_SYMBOL(do_settimeofday);

commit ddcabb4fc7f2f4a70f35aa72827888a4c549d355
Author: Matt Mackall <mpm@selenic.com>
Date:   Tue Mar 28 01:56:06 2006 -0800

    [PATCH] RTC: Remove RTC UIP synchronization on MIPS-based DEC
    
    Move real_year inside the read loop and move the spinlock up as well
    
    Signed-off-by: Matt Mackall <mpm@selenic.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index f17d3378e9a6..74cb055d4bf6 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -36,41 +36,13 @@
 #include <asm/dec/ioasic_addrs.h>
 #include <asm/dec/machtype.h>
 
-
-/*
- * Returns true if a clock update is in progress
- */
-static inline unsigned char dec_rtc_is_updating(void)
-{
-	unsigned char uip;
-	unsigned long flags;
-
-	spin_lock_irqsave(&rtc_lock, flags);
-	uip = (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP);
-	spin_unlock_irqrestore(&rtc_lock, flags);
-	return uip;
-}
-
 static unsigned long dec_rtc_get_time(void)
 {
 	unsigned int year, mon, day, hour, min, sec, real_year;
-	int i;
 	unsigned long flags;
 
-	/* The Linux interpretation of the DS1287 clock register contents:
-	 * When the Update-In-Progress (UIP) flag goes from 1 to 0, the
-	 * RTC registers show the second which has precisely just started.
-	 * Let's hope other operating systems interpret the RTC the same way.
-	 */
-	/* read RTC exactly on falling edge of update flag */
-	for (i = 0; i < 1000000; i++)	/* may take up to 1 second... */
-		if (dec_rtc_is_updating())
-			break;
-	for (i = 0; i < 1000000; i++)	/* must try at least 2.228 ms */
-		if (!dec_rtc_is_updating())
-			break;
 	spin_lock_irqsave(&rtc_lock, flags);
-	/* Isn't this overkill?  UIP above should guarantee consistency */
+
 	do {
 		sec = CMOS_READ(RTC_SECONDS);
 		min = CMOS_READ(RTC_MINUTES);
@@ -78,7 +50,16 @@ static unsigned long dec_rtc_get_time(void)
 		day = CMOS_READ(RTC_DAY_OF_MONTH);
 		mon = CMOS_READ(RTC_MONTH);
 		year = CMOS_READ(RTC_YEAR);
+		/*
+		 * The PROM will reset the year to either '72 or '73.
+		 * Therefore we store the real year separately, in one
+		 * of unused BBU RAM locations.
+		 */
+		real_year = CMOS_READ(RTC_DEC_YEAR);
 	} while (sec != CMOS_READ(RTC_SECONDS));
+
+	spin_unlock_irqrestore(&rtc_lock, flags);
+
 	if (!(CMOS_READ(RTC_CONTROL) & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
 		sec = BCD2BIN(sec);
 		min = BCD2BIN(min);
@@ -87,13 +68,7 @@ static unsigned long dec_rtc_get_time(void)
 		mon = BCD2BIN(mon);
 		year = BCD2BIN(year);
 	}
-	/*
-	 * The PROM will reset the year to either '72 or '73.
-	 * Therefore we store the real year separately, in one
-	 * of unused BBU RAM locations.
-	 */
-	real_year = CMOS_READ(RTC_DEC_YEAR);
-	spin_unlock_irqrestore(&rtc_lock, flags);
+
 	year += real_year - 72 + 2000;
 
 	return mktime(year, mon, day, hour, min, sec);

commit d23ee8fe6e2176a9d4dbfdd18edfa1b5bc3c79a5
Author: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
Date:   Mon Mar 27 01:16:33 2006 -0800

    [PATCH] mips: fixed collision of rtc function name
    
    Fix the collision of rtc function name.
    
    Signed-off-by: Yoichi Yuasa <yoichi_yuasa@tripeaks.co.jp>
    Cc: Alessandro Zummo <a.zummo@towertech.it>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index 174822344131..f17d3378e9a6 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -193,8 +193,8 @@ static void dec_ioasic_hpt_init(unsigned int count)
 
 void __init dec_time_init(void)
 {
-	rtc_get_time = dec_rtc_get_time;
-	rtc_set_mmss = dec_rtc_set_mmss;
+	rtc_mips_get_time = dec_rtc_get_time;
+	rtc_mips_set_mmss = dec_rtc_set_mmss;
 
 	mips_timer_state = dec_timer_state;
 	mips_timer_ack = dec_timer_ack;

commit 53c2df2f4ebbc1d8231ca7cc13ac5381230888b1
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Nov 3 01:01:15 2005 +0900

    Use rtc_lock to protect RTC operations
    
    Many RTC routines were not protected against each other, so there are
    potential races, for example, ntp-update against /dev/rtc.  This patch
    fixes them using rtc_lock.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
index dc7091caa7aa..174822344131 100644
--- a/arch/mips/dec/time.c
+++ b/arch/mips/dec/time.c
@@ -37,10 +37,25 @@
 #include <asm/dec/machtype.h>
 
 
+/*
+ * Returns true if a clock update is in progress
+ */
+static inline unsigned char dec_rtc_is_updating(void)
+{
+	unsigned char uip;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rtc_lock, flags);
+	uip = (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP);
+	spin_unlock_irqrestore(&rtc_lock, flags);
+	return uip;
+}
+
 static unsigned long dec_rtc_get_time(void)
 {
 	unsigned int year, mon, day, hour, min, sec, real_year;
 	int i;
+	unsigned long flags;
 
 	/* The Linux interpretation of the DS1287 clock register contents:
 	 * When the Update-In-Progress (UIP) flag goes from 1 to 0, the
@@ -49,11 +64,12 @@ static unsigned long dec_rtc_get_time(void)
 	 */
 	/* read RTC exactly on falling edge of update flag */
 	for (i = 0; i < 1000000; i++)	/* may take up to 1 second... */
-		if (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP)
+		if (dec_rtc_is_updating())
 			break;
 	for (i = 0; i < 1000000; i++)	/* must try at least 2.228 ms */
-		if (!(CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP))
+		if (!dec_rtc_is_updating())
 			break;
+	spin_lock_irqsave(&rtc_lock, flags);
 	/* Isn't this overkill?  UIP above should guarantee consistency */
 	do {
 		sec = CMOS_READ(RTC_SECONDS);
@@ -77,6 +93,7 @@ static unsigned long dec_rtc_get_time(void)
 	 * of unused BBU RAM locations.
 	 */
 	real_year = CMOS_READ(RTC_DEC_YEAR);
+	spin_unlock_irqrestore(&rtc_lock, flags);
 	year += real_year - 72 + 2000;
 
 	return mktime(year, mon, day, hour, min, sec);
@@ -95,6 +112,8 @@ static int dec_rtc_set_mmss(unsigned long nowtime)
 	int real_seconds, real_minutes, cmos_minutes;
 	unsigned char save_control, save_freq_select;
 
+	/* irq are locally disabled here */
+	spin_lock(&rtc_lock);
 	/* tell the clock it's being set */
 	save_control = CMOS_READ(RTC_CONTROL);
 	CMOS_WRITE((save_control | RTC_SET), RTC_CONTROL);
@@ -141,6 +160,7 @@ static int dec_rtc_set_mmss(unsigned long nowtime)
 	 */
 	CMOS_WRITE(save_control, RTC_CONTROL);
 	CMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);
+	spin_unlock(&rtc_lock);
 
 	return retval;
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/dec/time.c b/arch/mips/dec/time.c
new file mode 100644
index 000000000000..dc7091caa7aa
--- /dev/null
+++ b/arch/mips/dec/time.c
@@ -0,0 +1,200 @@
+/*
+ *  linux/arch/mips/dec/time.c
+ *
+ *  Copyright (C) 1991, 1992, 1995  Linus Torvalds
+ *  Copyright (C) 2000, 2003  Maciej W. Rozycki
+ *
+ * This file contains the time handling details for PC-style clocks as
+ * found in some MIPS systems.
+ *
+ */
+#include <linux/bcd.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/mc146818rtc.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/param.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/time.h>
+#include <linux/types.h>
+
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/div64.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/mipsregs.h>
+#include <asm/sections.h>
+#include <asm/time.h>
+
+#include <asm/dec/interrupts.h>
+#include <asm/dec/ioasic.h>
+#include <asm/dec/ioasic_addrs.h>
+#include <asm/dec/machtype.h>
+
+
+static unsigned long dec_rtc_get_time(void)
+{
+	unsigned int year, mon, day, hour, min, sec, real_year;
+	int i;
+
+	/* The Linux interpretation of the DS1287 clock register contents:
+	 * When the Update-In-Progress (UIP) flag goes from 1 to 0, the
+	 * RTC registers show the second which has precisely just started.
+	 * Let's hope other operating systems interpret the RTC the same way.
+	 */
+	/* read RTC exactly on falling edge of update flag */
+	for (i = 0; i < 1000000; i++)	/* may take up to 1 second... */
+		if (CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP)
+			break;
+	for (i = 0; i < 1000000; i++)	/* must try at least 2.228 ms */
+		if (!(CMOS_READ(RTC_FREQ_SELECT) & RTC_UIP))
+			break;
+	/* Isn't this overkill?  UIP above should guarantee consistency */
+	do {
+		sec = CMOS_READ(RTC_SECONDS);
+		min = CMOS_READ(RTC_MINUTES);
+		hour = CMOS_READ(RTC_HOURS);
+		day = CMOS_READ(RTC_DAY_OF_MONTH);
+		mon = CMOS_READ(RTC_MONTH);
+		year = CMOS_READ(RTC_YEAR);
+	} while (sec != CMOS_READ(RTC_SECONDS));
+	if (!(CMOS_READ(RTC_CONTROL) & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+		sec = BCD2BIN(sec);
+		min = BCD2BIN(min);
+		hour = BCD2BIN(hour);
+		day = BCD2BIN(day);
+		mon = BCD2BIN(mon);
+		year = BCD2BIN(year);
+	}
+	/*
+	 * The PROM will reset the year to either '72 or '73.
+	 * Therefore we store the real year separately, in one
+	 * of unused BBU RAM locations.
+	 */
+	real_year = CMOS_READ(RTC_DEC_YEAR);
+	year += real_year - 72 + 2000;
+
+	return mktime(year, mon, day, hour, min, sec);
+}
+
+/*
+ * In order to set the CMOS clock precisely, dec_rtc_set_mmss has to
+ * be called 500 ms after the second nowtime has started, because when
+ * nowtime is written into the registers of the CMOS clock, it will
+ * jump to the next second precisely 500 ms later.  Check the Dallas
+ * DS1287 data sheet for details.
+ */
+static int dec_rtc_set_mmss(unsigned long nowtime)
+{
+	int retval = 0;
+	int real_seconds, real_minutes, cmos_minutes;
+	unsigned char save_control, save_freq_select;
+
+	/* tell the clock it's being set */
+	save_control = CMOS_READ(RTC_CONTROL);
+	CMOS_WRITE((save_control | RTC_SET), RTC_CONTROL);
+
+	/* stop and reset prescaler */
+	save_freq_select = CMOS_READ(RTC_FREQ_SELECT);
+	CMOS_WRITE((save_freq_select | RTC_DIV_RESET2), RTC_FREQ_SELECT);
+
+	cmos_minutes = CMOS_READ(RTC_MINUTES);
+	if (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD)
+		cmos_minutes = BCD2BIN(cmos_minutes);
+
+	/*
+	 * since we're only adjusting minutes and seconds,
+	 * don't interfere with hour overflow. This avoids
+	 * messing with unknown time zones but requires your
+	 * RTC not to be off by more than 15 minutes
+	 */
+	real_seconds = nowtime % 60;
+	real_minutes = nowtime / 60;
+	if (((abs(real_minutes - cmos_minutes) + 15) / 30) & 1)
+		real_minutes += 30;	/* correct for half hour time zone */
+	real_minutes %= 60;
+
+	if (abs(real_minutes - cmos_minutes) < 30) {
+		if (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
+			real_seconds = BIN2BCD(real_seconds);
+			real_minutes = BIN2BCD(real_minutes);
+		}
+		CMOS_WRITE(real_seconds, RTC_SECONDS);
+		CMOS_WRITE(real_minutes, RTC_MINUTES);
+	} else {
+		printk(KERN_WARNING
+		       "set_rtc_mmss: can't update from %d to %d\n",
+		       cmos_minutes, real_minutes);
+		retval = -1;
+	}
+
+	/* The following flags have to be released exactly in this order,
+	 * otherwise the DS1287 will not reset the oscillator and will not
+	 * update precisely 500 ms later.  You won't find this mentioned
+	 * in the Dallas Semiconductor data sheets, but who believes data
+	 * sheets anyway ...                           -- Markus Kuhn
+	 */
+	CMOS_WRITE(save_control, RTC_CONTROL);
+	CMOS_WRITE(save_freq_select, RTC_FREQ_SELECT);
+
+	return retval;
+}
+
+
+static int dec_timer_state(void)
+{
+	return (CMOS_READ(RTC_REG_C) & RTC_PF) != 0;
+}
+
+static void dec_timer_ack(void)
+{
+	CMOS_READ(RTC_REG_C);			/* Ack the RTC interrupt.  */
+}
+
+static unsigned int dec_ioasic_hpt_read(void)
+{
+	/*
+	 * The free-running counter is 32-bit which is good for about
+	 * 2 minutes, 50 seconds at possible count rates of up to 25MHz.
+	 */
+	return ioasic_read(IO_REG_FCTR);
+}
+
+static void dec_ioasic_hpt_init(unsigned int count)
+{
+	ioasic_write(IO_REG_FCTR, ioasic_read(IO_REG_FCTR) - count);
+}
+
+
+void __init dec_time_init(void)
+{
+	rtc_get_time = dec_rtc_get_time;
+	rtc_set_mmss = dec_rtc_set_mmss;
+
+	mips_timer_state = dec_timer_state;
+	mips_timer_ack = dec_timer_ack;
+
+	if (!cpu_has_counter && IOASIC) {
+		/* For pre-R4k systems we use the I/O ASIC's counter.  */
+		mips_hpt_read = dec_ioasic_hpt_read;
+		mips_hpt_init = dec_ioasic_hpt_init;
+	}
+
+	/* Set up the rate of periodic DS1287 interrupts.  */
+	CMOS_WRITE(RTC_REF_CLCK_32KHZ | (16 - LOG_2_HZ), RTC_REG_A);
+}
+
+EXPORT_SYMBOL(do_settimeofday);
+
+void __init dec_timer_setup(struct irqaction *irq)
+{
+	setup_irq(dec_interrupt[DEC_IRQ_RTC], irq);
+
+	/* Enable periodic DS1287 interrupts.  */
+	CMOS_WRITE(CMOS_READ(RTC_REG_B) | RTC_PIE, RTC_REG_B);
+}
