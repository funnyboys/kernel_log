commit 26dd3e4ff9ac1aa576c97d23d7425d2544dbc5bf
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Jan 28 21:05:57 2017 -0500

    MIPS: Audit and remove any unnecessary uses of module.h
    
    Historically a lot of these existed because we did not have
    a distinction between what was modular code and what was providing
    support to modules via EXPORT_SYMBOL and friends.  That changed
    when we forked out support for the latter into the export.h file.
    
    This means we should be able to reduce the usage of module.h
    in code that is obj-y Makefile or bool Kconfig.  In the case of
    some code where it is modular, we can extend that to also include
    files that are building basic support functionality but not related
    to loading or registering the final module; such files also have
    no need whatsoever for module.h
    
    The advantage in removing such instances is that module.h itself
    sources about 15 other headers; adding significantly to what we feed
    cpp, and it can obscure what headers we are effectively using.
    
    Since module.h might have been the implicit source for init.h
    (for __init) and for export.h (for EXPORT_SYMBOL) we consider each
    instance for the presence of either and replace/add as needed.
    
    Also note that MODULE_DEVICE_TABLE is a no-op for non-modular code.
    
    Build coverage of all the mips defconfigs revealed the module.h
    header was masking a couple of implicit include instances, so
    we add the appropriate headers there.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: David Daney <david.daney@cavium.com>
    Cc: John Crispin <john@phrozen.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: "Steven J. Hill" <steven.hill@cavium.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/15131/
    [james.hogan@imgtec.com: Preserve sort order where it already exists]
    Signed-off-by: James Hogan <james.hogan@imgtec.com>

diff --git a/arch/mips/bcm63xx/timer.c b/arch/mips/bcm63xx/timer.c
index 2110359c00e5..a86065854c0c 100644
--- a/arch/mips/bcm63xx/timer.c
+++ b/arch/mips/bcm63xx/timer.c
@@ -8,7 +8,8 @@
 
 #include <linux/kernel.h>
 #include <linux/err.h>
-#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/export.h>
 #include <linux/spinlock.h>
 #include <linux/interrupt.h>
 #include <linux/clk.h>

commit 63893ea5304c919656613a47b04e35c6814d9041
Author: Gregory Fong <gregory.0xf0@gmail.com>
Date:   Wed Oct 14 04:27:38 2015 -0700

    MIPS: BCM63XX: Use pr_* instead of printk
    
    Signed-off-by: Gregory Fong <gregory.0xf0@gmail.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Jonas Gorski <jogo@openwrt.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Nicolas Schichan <nschichan@freebox.fr>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/11300/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/timer.c b/arch/mips/bcm63xx/timer.c
index 5f1135981568..2110359c00e5 100644
--- a/arch/mips/bcm63xx/timer.c
+++ b/arch/mips/bcm63xx/timer.c
@@ -195,7 +195,7 @@ int bcm63xx_timer_init(void)
 	irq = bcm63xx_get_irq_number(IRQ_TIMER);
 	ret = request_irq(irq, timer_interrupt, 0, "bcm63xx_timer", NULL);
 	if (ret) {
-		printk(KERN_ERR "bcm63xx_timer: failed to register irq\n");
+		pr_err("%s: failed to register irq\n", __func__);
 		return ret;
 	}
 

commit d8d607d59e78a865e0b55c60e84412519a83022c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Feb 27 12:53:35 2010 +0100

    MIPS: BCM63xx: Convert timer locks to raw spinlocks.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/timer.c b/arch/mips/bcm63xx/timer.c
index ba522bdcde4b..5f1135981568 100644
--- a/arch/mips/bcm63xx/timer.c
+++ b/arch/mips/bcm63xx/timer.c
@@ -17,8 +17,8 @@
 #include <bcm63xx_timer.h>
 #include <bcm63xx_regs.h>
 
-static DEFINE_SPINLOCK(timer_reg_lock);
-static DEFINE_SPINLOCK(timer_data_lock);
+static DEFINE_RAW_SPINLOCK(timer_reg_lock);
+static DEFINE_RAW_SPINLOCK(timer_data_lock);
 static struct clk *periph_clk;
 
 static struct timer_data {
@@ -31,23 +31,23 @@ static irqreturn_t timer_interrupt(int irq, void *dev_id)
 	u32 stat;
 	int i;
 
-	spin_lock(&timer_reg_lock);
+	raw_spin_lock(&timer_reg_lock);
 	stat = bcm_timer_readl(TIMER_IRQSTAT_REG);
 	bcm_timer_writel(stat, TIMER_IRQSTAT_REG);
-	spin_unlock(&timer_reg_lock);
+	raw_spin_unlock(&timer_reg_lock);
 
 	for (i = 0; i < BCM63XX_TIMER_COUNT; i++) {
 		if (!(stat & TIMER_IRQSTAT_TIMER_CAUSE(i)))
 			continue;
 
-		spin_lock(&timer_data_lock);
+		raw_spin_lock(&timer_data_lock);
 		if (!timer_data[i].cb) {
-			spin_unlock(&timer_data_lock);
+			raw_spin_unlock(&timer_data_lock);
 			continue;
 		}
 
 		timer_data[i].cb(timer_data[i].data);
-		spin_unlock(&timer_data_lock);
+		raw_spin_unlock(&timer_data_lock);
 	}
 
 	return IRQ_HANDLED;
@@ -61,7 +61,7 @@ int bcm63xx_timer_enable(int id)
 	if (id >= BCM63XX_TIMER_COUNT)
 		return -EINVAL;
 
-	spin_lock_irqsave(&timer_reg_lock, flags);
+	raw_spin_lock_irqsave(&timer_reg_lock, flags);
 
 	reg = bcm_timer_readl(TIMER_CTLx_REG(id));
 	reg |= TIMER_CTL_ENABLE_MASK;
@@ -71,7 +71,7 @@ int bcm63xx_timer_enable(int id)
 	reg |= TIMER_IRQSTAT_TIMER_IR_EN(id);
 	bcm_timer_writel(reg, TIMER_IRQSTAT_REG);
 
-	spin_unlock_irqrestore(&timer_reg_lock, flags);
+	raw_spin_unlock_irqrestore(&timer_reg_lock, flags);
 	return 0;
 }
 
@@ -85,7 +85,7 @@ int bcm63xx_timer_disable(int id)
 	if (id >= BCM63XX_TIMER_COUNT)
 		return -EINVAL;
 
-	spin_lock_irqsave(&timer_reg_lock, flags);
+	raw_spin_lock_irqsave(&timer_reg_lock, flags);
 
 	reg = bcm_timer_readl(TIMER_CTLx_REG(id));
 	reg &= ~TIMER_CTL_ENABLE_MASK;
@@ -95,7 +95,7 @@ int bcm63xx_timer_disable(int id)
 	reg &= ~TIMER_IRQSTAT_TIMER_IR_EN(id);
 	bcm_timer_writel(reg, TIMER_IRQSTAT_REG);
 
-	spin_unlock_irqrestore(&timer_reg_lock, flags);
+	raw_spin_unlock_irqrestore(&timer_reg_lock, flags);
 	return 0;
 }
 
@@ -110,7 +110,7 @@ int bcm63xx_timer_register(int id, void (*callback)(void *data), void *data)
 		return -EINVAL;
 
 	ret = 0;
-	spin_lock_irqsave(&timer_data_lock, flags);
+	raw_spin_lock_irqsave(&timer_data_lock, flags);
 	if (timer_data[id].cb) {
 		ret = -EBUSY;
 		goto out;
@@ -120,7 +120,7 @@ int bcm63xx_timer_register(int id, void (*callback)(void *data), void *data)
 	timer_data[id].data = data;
 
 out:
-	spin_unlock_irqrestore(&timer_data_lock, flags);
+	raw_spin_unlock_irqrestore(&timer_data_lock, flags);
 	return ret;
 }
 
@@ -133,9 +133,9 @@ void bcm63xx_timer_unregister(int id)
 	if (id >= BCM63XX_TIMER_COUNT)
 		return;
 
-	spin_lock_irqsave(&timer_data_lock, flags);
+	raw_spin_lock_irqsave(&timer_data_lock, flags);
 	timer_data[id].cb = NULL;
-	spin_unlock_irqrestore(&timer_data_lock, flags);
+	raw_spin_unlock_irqrestore(&timer_data_lock, flags);
 }
 
 EXPORT_SYMBOL(bcm63xx_timer_unregister);
@@ -159,7 +159,7 @@ int bcm63xx_timer_set(int id, int monotonic, unsigned int countdown_us)
 	if (countdown & ~TIMER_CTL_COUNTDOWN_MASK)
 		return -EINVAL;
 
-	spin_lock_irqsave(&timer_reg_lock, flags);
+	raw_spin_lock_irqsave(&timer_reg_lock, flags);
 	reg = bcm_timer_readl(TIMER_CTLx_REG(id));
 
 	if (monotonic)
@@ -171,7 +171,7 @@ int bcm63xx_timer_set(int id, int monotonic, unsigned int countdown_us)
 	reg |= countdown;
 	bcm_timer_writel(reg, TIMER_CTLx_REG(id));
 
-	spin_unlock_irqrestore(&timer_reg_lock, flags);
+	raw_spin_unlock_irqrestore(&timer_reg_lock, flags);
 	return 0;
 }
 

commit e7300d04bd0809eb7ea10a2ed8c729459f816e36
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Tue Aug 18 13:23:37 2009 +0100

    MIPS: BCM63xx: Add support for the Broadcom BCM63xx family of SOCs.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/timer.c b/arch/mips/bcm63xx/timer.c
new file mode 100644
index 000000000000..ba522bdcde4b
--- /dev/null
+++ b/arch/mips/bcm63xx/timer.c
@@ -0,0 +1,205 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2008 Maxime Bizon <mbizon@freebox.fr>
+ */
+
+#include <linux/kernel.h>
+#include <linux/err.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/interrupt.h>
+#include <linux/clk.h>
+#include <bcm63xx_cpu.h>
+#include <bcm63xx_io.h>
+#include <bcm63xx_timer.h>
+#include <bcm63xx_regs.h>
+
+static DEFINE_SPINLOCK(timer_reg_lock);
+static DEFINE_SPINLOCK(timer_data_lock);
+static struct clk *periph_clk;
+
+static struct timer_data {
+	void	(*cb)(void *);
+	void	*data;
+} timer_data[BCM63XX_TIMER_COUNT];
+
+static irqreturn_t timer_interrupt(int irq, void *dev_id)
+{
+	u32 stat;
+	int i;
+
+	spin_lock(&timer_reg_lock);
+	stat = bcm_timer_readl(TIMER_IRQSTAT_REG);
+	bcm_timer_writel(stat, TIMER_IRQSTAT_REG);
+	spin_unlock(&timer_reg_lock);
+
+	for (i = 0; i < BCM63XX_TIMER_COUNT; i++) {
+		if (!(stat & TIMER_IRQSTAT_TIMER_CAUSE(i)))
+			continue;
+
+		spin_lock(&timer_data_lock);
+		if (!timer_data[i].cb) {
+			spin_unlock(&timer_data_lock);
+			continue;
+		}
+
+		timer_data[i].cb(timer_data[i].data);
+		spin_unlock(&timer_data_lock);
+	}
+
+	return IRQ_HANDLED;
+}
+
+int bcm63xx_timer_enable(int id)
+{
+	u32 reg;
+	unsigned long flags;
+
+	if (id >= BCM63XX_TIMER_COUNT)
+		return -EINVAL;
+
+	spin_lock_irqsave(&timer_reg_lock, flags);
+
+	reg = bcm_timer_readl(TIMER_CTLx_REG(id));
+	reg |= TIMER_CTL_ENABLE_MASK;
+	bcm_timer_writel(reg, TIMER_CTLx_REG(id));
+
+	reg = bcm_timer_readl(TIMER_IRQSTAT_REG);
+	reg |= TIMER_IRQSTAT_TIMER_IR_EN(id);
+	bcm_timer_writel(reg, TIMER_IRQSTAT_REG);
+
+	spin_unlock_irqrestore(&timer_reg_lock, flags);
+	return 0;
+}
+
+EXPORT_SYMBOL(bcm63xx_timer_enable);
+
+int bcm63xx_timer_disable(int id)
+{
+	u32 reg;
+	unsigned long flags;
+
+	if (id >= BCM63XX_TIMER_COUNT)
+		return -EINVAL;
+
+	spin_lock_irqsave(&timer_reg_lock, flags);
+
+	reg = bcm_timer_readl(TIMER_CTLx_REG(id));
+	reg &= ~TIMER_CTL_ENABLE_MASK;
+	bcm_timer_writel(reg, TIMER_CTLx_REG(id));
+
+	reg = bcm_timer_readl(TIMER_IRQSTAT_REG);
+	reg &= ~TIMER_IRQSTAT_TIMER_IR_EN(id);
+	bcm_timer_writel(reg, TIMER_IRQSTAT_REG);
+
+	spin_unlock_irqrestore(&timer_reg_lock, flags);
+	return 0;
+}
+
+EXPORT_SYMBOL(bcm63xx_timer_disable);
+
+int bcm63xx_timer_register(int id, void (*callback)(void *data), void *data)
+{
+	unsigned long flags;
+	int ret;
+
+	if (id >= BCM63XX_TIMER_COUNT || !callback)
+		return -EINVAL;
+
+	ret = 0;
+	spin_lock_irqsave(&timer_data_lock, flags);
+	if (timer_data[id].cb) {
+		ret = -EBUSY;
+		goto out;
+	}
+
+	timer_data[id].cb = callback;
+	timer_data[id].data = data;
+
+out:
+	spin_unlock_irqrestore(&timer_data_lock, flags);
+	return ret;
+}
+
+EXPORT_SYMBOL(bcm63xx_timer_register);
+
+void bcm63xx_timer_unregister(int id)
+{
+	unsigned long flags;
+
+	if (id >= BCM63XX_TIMER_COUNT)
+		return;
+
+	spin_lock_irqsave(&timer_data_lock, flags);
+	timer_data[id].cb = NULL;
+	spin_unlock_irqrestore(&timer_data_lock, flags);
+}
+
+EXPORT_SYMBOL(bcm63xx_timer_unregister);
+
+unsigned int bcm63xx_timer_countdown(unsigned int countdown_us)
+{
+	return (clk_get_rate(periph_clk) / (1000 * 1000)) * countdown_us;
+}
+
+EXPORT_SYMBOL(bcm63xx_timer_countdown);
+
+int bcm63xx_timer_set(int id, int monotonic, unsigned int countdown_us)
+{
+	u32 reg, countdown;
+	unsigned long flags;
+
+	if (id >= BCM63XX_TIMER_COUNT)
+		return -EINVAL;
+
+	countdown = bcm63xx_timer_countdown(countdown_us);
+	if (countdown & ~TIMER_CTL_COUNTDOWN_MASK)
+		return -EINVAL;
+
+	spin_lock_irqsave(&timer_reg_lock, flags);
+	reg = bcm_timer_readl(TIMER_CTLx_REG(id));
+
+	if (monotonic)
+		reg &= ~TIMER_CTL_MONOTONIC_MASK;
+	else
+		reg |= TIMER_CTL_MONOTONIC_MASK;
+
+	reg &= ~TIMER_CTL_COUNTDOWN_MASK;
+	reg |= countdown;
+	bcm_timer_writel(reg, TIMER_CTLx_REG(id));
+
+	spin_unlock_irqrestore(&timer_reg_lock, flags);
+	return 0;
+}
+
+EXPORT_SYMBOL(bcm63xx_timer_set);
+
+int bcm63xx_timer_init(void)
+{
+	int ret, irq;
+	u32 reg;
+
+	reg = bcm_timer_readl(TIMER_IRQSTAT_REG);
+	reg &= ~TIMER_IRQSTAT_TIMER0_IR_EN;
+	reg &= ~TIMER_IRQSTAT_TIMER1_IR_EN;
+	reg &= ~TIMER_IRQSTAT_TIMER2_IR_EN;
+	bcm_timer_writel(reg, TIMER_IRQSTAT_REG);
+
+	periph_clk = clk_get(NULL, "periph");
+	if (IS_ERR(periph_clk))
+		return -ENODEV;
+
+	irq = bcm63xx_get_irq_number(IRQ_TIMER);
+	ret = request_irq(irq, timer_interrupt, 0, "bcm63xx_timer", NULL);
+	if (ret) {
+		printk(KERN_ERR "bcm63xx_timer: failed to register irq\n");
+		return ret;
+	}
+
+	return 0;
+}
+
+arch_initcall(bcm63xx_timer_init);
