commit c9b0299034665d594e56ee343f28033d1b24de6d
Author: Liangliang Huang <huanglllzu@gmail.com>
Date:   Mon May 4 16:51:29 2020 +0800

    MIPS: Use fallthrough for arch/mips
    
    Convert the various /* fallthrough */ comments to the pseudo-keyword
    fallthrough;
    
    Done via script:
    https://lore.kernel.org/lkml/b56602fcf79f849e733e7b521bb0e17895d390fa.1582230379.git.joe@perches.com/
    
    Signed-off-by: Liangliang Huang <huangll@lemote.com>
    Reviewed-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index f61c16f57a97..8e3e199dd35d 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -304,7 +304,7 @@ void __init bcm63xx_cpu_init(void)
 	case CPU_BMIPS3300:
 		if ((read_c0_prid() & PRID_IMP_MASK) != PRID_IMP_BMIPS3300_ALT)
 			__cpu_name[cpu] = "Broadcom BCM6338";
-		/* fall-through */
+		fallthrough;
 	case CPU_BMIPS32:
 		chipid_reg = BCM_6345_PERF_BASE;
 		break;

commit 26dd3e4ff9ac1aa576c97d23d7425d2544dbc5bf
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Jan 28 21:05:57 2017 -0500

    MIPS: Audit and remove any unnecessary uses of module.h
    
    Historically a lot of these existed because we did not have
    a distinction between what was modular code and what was providing
    support to modules via EXPORT_SYMBOL and friends.  That changed
    when we forked out support for the latter into the export.h file.
    
    This means we should be able to reduce the usage of module.h
    in code that is obj-y Makefile or bool Kconfig.  In the case of
    some code where it is modular, we can extend that to also include
    files that are building basic support functionality but not related
    to loading or registering the final module; such files also have
    no need whatsoever for module.h
    
    The advantage in removing such instances is that module.h itself
    sources about 15 other headers; adding significantly to what we feed
    cpp, and it can obscure what headers we are effectively using.
    
    Since module.h might have been the implicit source for init.h
    (for __init) and for export.h (for EXPORT_SYMBOL) we consider each
    instance for the presence of either and replace/add as needed.
    
    Also note that MODULE_DEVICE_TABLE is a no-op for non-modular code.
    
    Build coverage of all the mips defconfigs revealed the module.h
    header was masking a couple of implicit include instances, so
    we add the appropriate headers there.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: David Daney <david.daney@cavium.com>
    Cc: John Crispin <john@phrozen.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: "Steven J. Hill" <steven.hill@cavium.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/15131/
    [james.hogan@imgtec.com: Preserve sort order where it already exists]
    Signed-off-by: James Hogan <james.hogan@imgtec.com>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 1c7c3fbfa1f3..f61c16f57a97 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -8,7 +8,7 @@
  */
 
 #include <linux/kernel.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/cpu.h>
 #include <asm/cpu.h>
 #include <asm/cpu-info.h>

commit 63893ea5304c919656613a47b04e35c6814d9041
Author: Gregory Fong <gregory.0xf0@gmail.com>
Date:   Wed Oct 14 04:27:38 2015 -0700

    MIPS: BCM63XX: Use pr_* instead of printk
    
    Signed-off-by: Gregory Fong <gregory.0xf0@gmail.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Jonas Gorski <jogo@openwrt.org>
    Cc: Joe Perches <joe@perches.com>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Nicolas Schichan <nschichan@freebox.fr>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/11300/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 307ec8b8e41c..1c7c3fbfa1f3 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -376,10 +376,10 @@ void __init bcm63xx_cpu_init(void)
 	bcm63xx_cpu_freq = detect_cpu_clock();
 	bcm63xx_memory_size = detect_memory_size();
 
-	printk(KERN_INFO "Detected Broadcom 0x%04x CPU revision %02x\n",
-	       bcm63xx_cpu_id, bcm63xx_cpu_rev);
-	printk(KERN_INFO "CPU frequency is %u MHz\n",
-	       bcm63xx_cpu_freq / 1000000);
-	printk(KERN_INFO "%uMB of RAM installed\n",
-	       bcm63xx_memory_size >> 20);
+	pr_info("Detected Broadcom 0x%04x CPU revision %02x\n",
+		bcm63xx_cpu_id, bcm63xx_cpu_rev);
+	pr_info("CPU frequency is %u MHz\n",
+		bcm63xx_cpu_freq / 1000000);
+	pr_info("%uMB of RAM installed\n",
+		bcm63xx_memory_size >> 20);
 }

commit 635c99070600ff04b4c1d5afe67f051631a8397c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Oct 21 14:12:49 2014 +0200

    MIPS: Remove useless parentheses
    
    Based on the spatch
    
    @@
    expression e;
    @@
    - return (e);
    + return e;
    
    with heavy hand editing because some of the changes are either whitespace
    or identation only or result in excessivly long lines.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 536f64443031..307ec8b8e41c 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -263,7 +263,7 @@ static unsigned int detect_memory_size(void)
 
 	if (BCMCPU_IS_6345()) {
 		val = bcm_sdram_readl(SDRAM_MBASE_REG);
-		return (val * 8 * 1024 * 1024);
+		return val * 8 * 1024 * 1024;
 	}
 
 	if (BCMCPU_IS_6338() || BCMCPU_IS_6348()) {

commit e86ae9e2e0c3badc74c81f3449b9d59513d8845c
Author: Jonas Gorski <jogo@openwrt.org>
Date:   Tue Jul 8 16:53:24 2014 +0200

    MIPS: BCM63xx: Remove !RUNTIME_DETECT code for bcmcpu_get_id
    
    Use the same pattern as with get_*_cpu_type() to allow the compiler
    to remove code for non enabled SoC types.
    
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Cc: John Crispin <blogic@openwrt.org>
    Cc: Maxime Bizon <mbizon@freebox.fr>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/7273/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index fd4e76c00a42..536f64443031 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -24,7 +24,9 @@ EXPORT_SYMBOL(bcm63xx_regs_base);
 const int *bcm63xx_irqs;
 EXPORT_SYMBOL(bcm63xx_irqs);
 
-static u16 bcm63xx_cpu_id;
+u16 bcm63xx_cpu_id __read_mostly;
+EXPORT_SYMBOL(bcm63xx_cpu_id);
+
 static u8 bcm63xx_cpu_rev;
 static unsigned int bcm63xx_cpu_freq;
 static unsigned int bcm63xx_memory_size;
@@ -97,13 +99,6 @@ static const int bcm6368_irqs[] = {
 
 };
 
-u16 __bcm63xx_get_cpu_id(void)
-{
-	return bcm63xx_cpu_id;
-}
-
-EXPORT_SYMBOL(__bcm63xx_get_cpu_id);
-
 u8 bcm63xx_get_cpu_rev(void)
 {
 	return bcm63xx_cpu_rev;

commit d7b12056bc9cbd7f0c0ae5bc52f2b049d48c4314
Author: Wu Zhangjin <wuzhangjin@gmail.com>
Date:   Sun Dec 26 04:42:37 2010 +0800

    MIPS: Use current_cpu_type() instead of c->cputype
    
    If current_cpu_type() is pre-defined in cpu-feature-overrides.h, This
    may save about 10k for the compressed kernel image(vmlinuz).
    
    Signed-off-by: Wu Zhangjin <wuzhangjin@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/1901/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 1b1b8a89959b..fd4e76c00a42 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -299,14 +299,13 @@ static unsigned int detect_memory_size(void)
 void __init bcm63xx_cpu_init(void)
 {
 	unsigned int tmp;
-	struct cpuinfo_mips *c = &current_cpu_data;
 	unsigned int cpu = smp_processor_id();
 	u32 chipid_reg;
 
 	/* soc registers location depends on cpu type */
 	chipid_reg = 0;
 
-	switch (c->cputype) {
+	switch (current_cpu_type()) {
 	case CPU_BMIPS3300:
 		if ((read_c0_prid() & PRID_IMP_MASK) != PRID_IMP_BMIPS3300_ALT)
 			__cpu_name[cpu] = "Broadcom BCM6338";

commit 17d97bad1ab966f1f39b10c48cd3f858a29b3659
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Mon Sep 30 09:38:00 2013 +0100

    MIPS: bcm63xx: cpu: Replace BUG() with panic()
    
    BUG() can be a noop if CONFIG_BUG is not selected,
    leading to the following build problem on a randconfig:
    
    arch/mips/bcm63xx/cpu.c: In function 'detect_cpu_clock':
    arch/mips/bcm63xx/cpu.c:254:1: error: control reaches end of
    non-void function [-Werror=return-type]
    
    We fix this problem by replacing BUG() with panic() since it's
    best to handle the case of an unknown board instead of silently
    returning a random clock frequency.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Acked-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Acked-by: Jonas Gorski <jogo@openwrt.org>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/5932/

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index b713cd64b087..1b1b8a89959b 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -123,7 +123,9 @@ unsigned int bcm63xx_get_memory_size(void)
 
 static unsigned int detect_cpu_clock(void)
 {
-	switch (bcm63xx_get_cpu_id()) {
+	u16 cpu_id = bcm63xx_get_cpu_id();
+
+	switch (cpu_id) {
 	case BCM3368_CPU_ID:
 		return 300000000;
 
@@ -249,7 +251,7 @@ static unsigned int detect_cpu_clock(void)
 	}
 
 	default:
-		BUG();
+		panic("Failed to detect clock for CPU with id=%04X\n", cpu_id);
 	}
 }
 

commit 8ff374b9c296b96484d5e63b45b22d0862ffee8f
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Tue Sep 17 16:58:10 2013 +0100

    MIPS: Cleanup CP0 PRId and CP1 FPIR register access masks
    
    Replace hardcoded CP0 PRId and CP1 FPIR register access masks throughout.
    The change does not touch places that use shifted or partial masks.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5838/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 7e17374a9ae8..b713cd64b087 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -306,14 +306,14 @@ void __init bcm63xx_cpu_init(void)
 
 	switch (c->cputype) {
 	case CPU_BMIPS3300:
-		if ((read_c0_prid() & 0xff00) != PRID_IMP_BMIPS3300_ALT)
+		if ((read_c0_prid() & PRID_IMP_MASK) != PRID_IMP_BMIPS3300_ALT)
 			__cpu_name[cpu] = "Broadcom BCM6338";
 		/* fall-through */
 	case CPU_BMIPS32:
 		chipid_reg = BCM_6345_PERF_BASE;
 		break;
 	case CPU_BMIPS4350:
-		switch ((read_c0_prid() & 0xff)) {
+		switch ((read_c0_prid() & PRID_REV_MASK)) {
 		case 0x04:
 			chipid_reg = BCM_3368_PERF_BASE;
 			break;

commit 7b9334215f53135fb9cbdf0b44833cbc8e7d57b2
Author: Florian Fainelli <florian@openwrt.org>
Date:   Tue Jun 18 16:55:40 2013 +0000

    MIPS: BCM63XX: add support for BCM3368 Cable Modem
    
    The Broadcom BCM3368 Cable Modem SoC is extremely similar to the
    existing BCM63xx DSL SoCs, in particular BCM6358, therefore little effort
    in the existing code base is required to get it supported. This patch adds
    support for the following on-chip peripherals:
    
    - two UARTS
    - GPIO
    - Ethernet
    - SPI
    - PCI
    - NOR Flash
    
    The most noticeable difference with 3368 is that it has its peripheral
    register at 0xfff8_0000 we check that separately in ioremap.h. Since
    3368 is identical to 6358 for its clock and reset bits, we use them
    verbatim.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Cc: cernekee@gmail.com
    Cc: jogo@openwrt.org
    Patchwork: https://patchwork.linux-mips.org/patch/5499/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 79fe32df5e96..7e17374a9ae8 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -29,6 +29,14 @@ static u8 bcm63xx_cpu_rev;
 static unsigned int bcm63xx_cpu_freq;
 static unsigned int bcm63xx_memory_size;
 
+static const unsigned long bcm3368_regs_base[] = {
+	__GEN_CPU_REGS_TABLE(3368)
+};
+
+static const int bcm3368_irqs[] = {
+	__GEN_CPU_IRQ_TABLE(3368)
+};
+
 static const unsigned long bcm6328_regs_base[] = {
 	__GEN_CPU_REGS_TABLE(6328)
 };
@@ -116,6 +124,9 @@ unsigned int bcm63xx_get_memory_size(void)
 static unsigned int detect_cpu_clock(void)
 {
 	switch (bcm63xx_get_cpu_id()) {
+	case BCM3368_CPU_ID:
+		return 300000000;
+
 	case BCM6328_CPU_ID:
 	{
 		unsigned int tmp, mips_pll_fcvo;
@@ -266,7 +277,7 @@ static unsigned int detect_memory_size(void)
 		banks = (val & SDRAM_CFG_BANK_MASK) ? 2 : 1;
 	}
 
-	if (BCMCPU_IS_6358() || BCMCPU_IS_6368()) {
+	if (BCMCPU_IS_3368() || BCMCPU_IS_6358() || BCMCPU_IS_6368()) {
 		val = bcm_memc_readl(MEMC_CFG_REG);
 		rows = (val & MEMC_CFG_ROW_MASK) >> MEMC_CFG_ROW_SHIFT;
 		cols = (val & MEMC_CFG_COL_MASK) >> MEMC_CFG_COL_SHIFT;
@@ -302,10 +313,17 @@ void __init bcm63xx_cpu_init(void)
 		chipid_reg = BCM_6345_PERF_BASE;
 		break;
 	case CPU_BMIPS4350:
-		if ((read_c0_prid() & 0xf0) == 0x10)
+		switch ((read_c0_prid() & 0xff)) {
+		case 0x04:
+			chipid_reg = BCM_3368_PERF_BASE;
+			break;
+		case 0x10:
 			chipid_reg = BCM_6345_PERF_BASE;
-		else
+			break;
+		default:
 			chipid_reg = BCM_6368_PERF_BASE;
+			break;
+		}
 		break;
 	}
 
@@ -322,6 +340,10 @@ void __init bcm63xx_cpu_init(void)
 	bcm63xx_cpu_rev = (tmp & REV_REVID_MASK) >> REV_REVID_SHIFT;
 
 	switch (bcm63xx_cpu_id) {
+	case BCM3368_CPU_ID:
+		bcm63xx_regs_base = bcm3368_regs_base;
+		bcm63xx_irqs = bcm3368_irqs;
+		break;
 	case BCM6328_CPU_ID:
 		bcm63xx_regs_base = bcm6328_regs_base;
 		bcm63xx_irqs = bcm6328_irqs;

commit 2c8aaf71b0a4738ae8cb70d9367089bdb892aea3
Author: Jonas Gorski <jogo@openwrt.org>
Date:   Thu Mar 21 14:03:17 2013 +0000

    MIPS: BCM63XX: add basic BCM6362 support
    
    Add basic support for detecting and booting the BCM6362.
    
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/5009/
    Acked-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index fef168d85884..79fe32df5e96 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -71,6 +71,15 @@ static const int bcm6358_irqs[] = {
 
 };
 
+static const unsigned long bcm6362_regs_base[] = {
+	__GEN_CPU_REGS_TABLE(6362)
+};
+
+static const int bcm6362_irqs[] = {
+	__GEN_CPU_IRQ_TABLE(6362)
+
+};
+
 static const unsigned long bcm6368_regs_base[] = {
 	__GEN_CPU_REGS_TABLE(6368)
 };
@@ -169,6 +178,42 @@ static unsigned int detect_cpu_clock(void)
 		return (16 * 1000000 * n1 * n2) / m1;
 	}
 
+	case BCM6362_CPU_ID:
+	{
+		unsigned int tmp, mips_pll_fcvo;
+
+		tmp = bcm_misc_readl(MISC_STRAPBUS_6362_REG);
+		mips_pll_fcvo = (tmp & STRAPBUS_6362_FCVO_MASK)
+				>> STRAPBUS_6362_FCVO_SHIFT;
+		switch (mips_pll_fcvo) {
+		case 0x03:
+		case 0x0b:
+		case 0x13:
+		case 0x1b:
+			return 240000000;
+		case 0x04:
+		case 0x0c:
+		case 0x14:
+		case 0x1c:
+			return 160000000;
+		case 0x05:
+		case 0x0e:
+		case 0x16:
+		case 0x1e:
+		case 0x1f:
+			return 400000000;
+		case 0x06:
+			return 440000000;
+		case 0x07:
+		case 0x17:
+			return 384000000;
+		case 0x15:
+		case 0x1d:
+			return 200000000;
+		default:
+			return 320000000;
+		}
+	}
 	case BCM6368_CPU_ID:
 	{
 		unsigned int tmp, p1, p2, ndiv, m1;
@@ -205,7 +250,7 @@ static unsigned int detect_memory_size(void)
 	unsigned int cols = 0, rows = 0, is_32bits = 0, banks = 0;
 	u32 val;
 
-	if (BCMCPU_IS_6328())
+	if (BCMCPU_IS_6328() || BCMCPU_IS_6362())
 		return bcm_ddr_readl(DDR_CSEND_REG) << 24;
 
 	if (BCMCPU_IS_6345()) {
@@ -297,6 +342,10 @@ void __init bcm63xx_cpu_init(void)
 		bcm63xx_regs_base = bcm6358_regs_base;
 		bcm63xx_irqs = bcm6358_irqs;
 		break;
+	case BCM6362_CPU_ID:
+		bcm63xx_regs_base = bcm6362_regs_base;
+		bcm63xx_irqs = bcm6362_irqs;
+		break;
 	case BCM6368_CPU_ID:
 		bcm63xx_regs_base = bcm6368_regs_base;
 		bcm63xx_irqs = bcm6368_irqs;

commit 13be798c57ebe5df09254832330f48c936ac39fd
Author: Jonas Gorski <jogo@openwrt.org>
Date:   Thu Mar 21 14:03:16 2013 +0000

    MIPS: BCM63XX: rework chip detection
    
    Instead of trying to use a correlation of cpu prid and chip id and
    hoping they will always be unique, use the cpu prid to determine the
    chip id register location and just read out the chip id.
    
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/5008/
    Acked-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index ae16626d4001..fef168d85884 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -240,53 +240,27 @@ static unsigned int detect_memory_size(void)
 
 void __init bcm63xx_cpu_init(void)
 {
-	unsigned int tmp, expected_cpu_id;
+	unsigned int tmp;
 	struct cpuinfo_mips *c = &current_cpu_data;
 	unsigned int cpu = smp_processor_id();
+	u32 chipid_reg;
 
 	/* soc registers location depends on cpu type */
-	expected_cpu_id = 0;
+	chipid_reg = 0;
 
 	switch (c->cputype) {
 	case CPU_BMIPS3300:
-		if ((read_c0_prid() & 0xff00) == PRID_IMP_BMIPS3300_ALT) {
-			expected_cpu_id = BCM6348_CPU_ID;
-			bcm63xx_regs_base = bcm6348_regs_base;
-			bcm63xx_irqs = bcm6348_irqs;
-		} else {
+		if ((read_c0_prid() & 0xff00) != PRID_IMP_BMIPS3300_ALT)
 			__cpu_name[cpu] = "Broadcom BCM6338";
-			expected_cpu_id = BCM6338_CPU_ID;
-			bcm63xx_regs_base = bcm6338_regs_base;
-			bcm63xx_irqs = bcm6338_irqs;
-		}
-		break;
+		/* fall-through */
 	case CPU_BMIPS32:
-		expected_cpu_id = BCM6345_CPU_ID;
-		bcm63xx_regs_base = bcm6345_regs_base;
-		bcm63xx_irqs = bcm6345_irqs;
+		chipid_reg = BCM_6345_PERF_BASE;
 		break;
 	case CPU_BMIPS4350:
-		if ((read_c0_prid() & 0xf0) == 0x10) {
-			expected_cpu_id = BCM6358_CPU_ID;
-			bcm63xx_regs_base = bcm6358_regs_base;
-			bcm63xx_irqs = bcm6358_irqs;
-		} else {
-			/* all newer chips have the same chip id location */
-			u16 chip_id = bcm_readw(BCM_6368_PERF_BASE);
-
-			switch (chip_id) {
-			case BCM6328_CPU_ID:
-				expected_cpu_id = BCM6328_CPU_ID;
-				bcm63xx_regs_base = bcm6328_regs_base;
-				bcm63xx_irqs = bcm6328_irqs;
-				break;
-			case BCM6368_CPU_ID:
-				expected_cpu_id = BCM6368_CPU_ID;
-				bcm63xx_regs_base = bcm6368_regs_base;
-				bcm63xx_irqs = bcm6368_irqs;
-				break;
-			}
-		}
+		if ((read_c0_prid() & 0xf0) == 0x10)
+			chipid_reg = BCM_6345_PERF_BASE;
+		else
+			chipid_reg = BCM_6368_PERF_BASE;
 		break;
 	}
 
@@ -294,20 +268,43 @@ void __init bcm63xx_cpu_init(void)
 	 * really early to panic, but delaying panic would not help since we
 	 * will never get any working console
 	 */
-	if (!expected_cpu_id)
+	if (!chipid_reg)
 		panic("unsupported Broadcom CPU");
 
-	/*
-	 * bcm63xx_regs_base is set, we can access soc registers
-	 */
-
-	/* double check CPU type */
-	tmp = bcm_perf_readl(PERF_REV_REG);
+	/* read out CPU type */
+	tmp = bcm_readl(chipid_reg);
 	bcm63xx_cpu_id = (tmp & REV_CHIPID_MASK) >> REV_CHIPID_SHIFT;
 	bcm63xx_cpu_rev = (tmp & REV_REVID_MASK) >> REV_REVID_SHIFT;
 
-	if (bcm63xx_cpu_id != expected_cpu_id)
-		panic("bcm63xx CPU id mismatch");
+	switch (bcm63xx_cpu_id) {
+	case BCM6328_CPU_ID:
+		bcm63xx_regs_base = bcm6328_regs_base;
+		bcm63xx_irqs = bcm6328_irqs;
+		break;
+	case BCM6338_CPU_ID:
+		bcm63xx_regs_base = bcm6338_regs_base;
+		bcm63xx_irqs = bcm6338_irqs;
+		break;
+	case BCM6345_CPU_ID:
+		bcm63xx_regs_base = bcm6345_regs_base;
+		bcm63xx_irqs = bcm6345_irqs;
+		break;
+	case BCM6348_CPU_ID:
+		bcm63xx_regs_base = bcm6348_regs_base;
+		bcm63xx_irqs = bcm6348_irqs;
+		break;
+	case BCM6358_CPU_ID:
+		bcm63xx_regs_base = bcm6358_regs_base;
+		bcm63xx_irqs = bcm6358_irqs;
+		break;
+	case BCM6368_CPU_ID:
+		bcm63xx_regs_base = bcm6368_regs_base;
+		bcm63xx_irqs = bcm6368_irqs;
+		break;
+	default:
+		panic("unsupported broadcom CPU %x", bcm63xx_cpu_id);
+		break;
+	}
 
 	bcm63xx_cpu_freq = detect_cpu_clock();
 	bcm63xx_memory_size = detect_memory_size();

commit 6605428c506bea269ca6c4aed85e97fbee2cbe7b
Author: Jonas Gorski <jogo@openwrt.org>
Date:   Thu Mar 21 14:03:15 2013 +0000

    MIPS: BCM63XX: fix revision ID width
    
    The REVID is only 8 bit wide.
    
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/5007/
    Acked-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index a7afb289b15a..ae16626d4001 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -25,7 +25,7 @@ const int *bcm63xx_irqs;
 EXPORT_SYMBOL(bcm63xx_irqs);
 
 static u16 bcm63xx_cpu_id;
-static u16 bcm63xx_cpu_rev;
+static u8 bcm63xx_cpu_rev;
 static unsigned int bcm63xx_cpu_freq;
 static unsigned int bcm63xx_memory_size;
 
@@ -87,7 +87,7 @@ u16 __bcm63xx_get_cpu_id(void)
 
 EXPORT_SYMBOL(__bcm63xx_get_cpu_id);
 
-u16 bcm63xx_get_cpu_rev(void)
+u8 bcm63xx_get_cpu_rev(void)
 {
 	return bcm63xx_cpu_rev;
 }

commit e5766aea5b9b7519654261c27b639f567b5415b4
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Tue Jul 24 16:33:12 2012 +0200

    MIPS: BCM63XX: Add basic BCM6328 support
    
    This includes CPU speed, memory size detection and working UART, but
    lacking the appropriate drivers, no support for attached flash.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: Maxime Bizon <mbizon@freebox.fr>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/3951/
    Reviewed-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index e3c1da59ea13..a7afb289b15a 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -29,6 +29,14 @@ static u16 bcm63xx_cpu_rev;
 static unsigned int bcm63xx_cpu_freq;
 static unsigned int bcm63xx_memory_size;
 
+static const unsigned long bcm6328_regs_base[] = {
+	__GEN_CPU_REGS_TABLE(6328)
+};
+
+static const int bcm6328_irqs[] = {
+	__GEN_CPU_IRQ_TABLE(6328)
+};
+
 static const unsigned long bcm6338_regs_base[] = {
 	__GEN_CPU_REGS_TABLE(6338)
 };
@@ -99,6 +107,33 @@ unsigned int bcm63xx_get_memory_size(void)
 static unsigned int detect_cpu_clock(void)
 {
 	switch (bcm63xx_get_cpu_id()) {
+	case BCM6328_CPU_ID:
+	{
+		unsigned int tmp, mips_pll_fcvo;
+
+		tmp = bcm_misc_readl(MISC_STRAPBUS_6328_REG);
+		mips_pll_fcvo = (tmp & STRAPBUS_6328_FCVO_MASK)
+				>> STRAPBUS_6328_FCVO_SHIFT;
+
+		switch (mips_pll_fcvo) {
+		case 0x12:
+		case 0x14:
+		case 0x19:
+			return 160000000;
+		case 0x1c:
+			return 192000000;
+		case 0x13:
+		case 0x15:
+			return 200000000;
+		case 0x1a:
+			return 384000000;
+		case 0x16:
+			return 400000000;
+		default:
+			return 320000000;
+		}
+
+	}
 	case BCM6338_CPU_ID:
 		/* BCM6338 has a fixed 240 Mhz frequency */
 		return 240000000;
@@ -170,6 +205,9 @@ static unsigned int detect_memory_size(void)
 	unsigned int cols = 0, rows = 0, is_32bits = 0, banks = 0;
 	u32 val;
 
+	if (BCMCPU_IS_6328())
+		return bcm_ddr_readl(DDR_CSEND_REG) << 24;
+
 	if (BCMCPU_IS_6345()) {
 		val = bcm_sdram_readl(SDRAM_MBASE_REG);
 		return (val * 8 * 1024 * 1024);
@@ -237,6 +275,11 @@ void __init bcm63xx_cpu_init(void)
 			u16 chip_id = bcm_readw(BCM_6368_PERF_BASE);
 
 			switch (chip_id) {
+			case BCM6328_CPU_ID:
+				expected_cpu_id = BCM6328_CPU_ID;
+				bcm63xx_regs_base = bcm6328_regs_base;
+				bcm63xx_irqs = bcm6328_irqs;
+				break;
 			case BCM6368_CPU_ID:
 				expected_cpu_id = BCM6368_CPU_ID;
 				bcm63xx_regs_base = bcm6368_regs_base;

commit 288752a8aa1be6cf89ee5066435a617efd97fb86
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Tue Jul 24 16:33:12 2012 +0200

    MIPS: BCM63XX: Use the Chip ID register for identifying the SoC
    
    Newer BCM63XX SoCs use virtually the same CPU ID, differing only in the
    revision bits. But since they all have the Chip ID register at the same
    location, we can use that to identify the SoC we are running on.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: Maxime Bizon <mbizon@freebox.fr>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/3955/
    Reviewed-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 8f0d6c7725ea..e3c1da59ea13 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -228,17 +228,21 @@ void __init bcm63xx_cpu_init(void)
 		bcm63xx_irqs = bcm6345_irqs;
 		break;
 	case CPU_BMIPS4350:
-		switch (read_c0_prid() & 0xf0) {
-		case 0x10:
+		if ((read_c0_prid() & 0xf0) == 0x10) {
 			expected_cpu_id = BCM6358_CPU_ID;
 			bcm63xx_regs_base = bcm6358_regs_base;
 			bcm63xx_irqs = bcm6358_irqs;
-			break;
-		case 0x30:
-			expected_cpu_id = BCM6368_CPU_ID;
-			bcm63xx_regs_base = bcm6368_regs_base;
-			bcm63xx_irqs = bcm6368_irqs;
-			break;
+		} else {
+			/* all newer chips have the same chip id location */
+			u16 chip_id = bcm_readw(BCM_6368_PERF_BASE);
+
+			switch (chip_id) {
+			case BCM6368_CPU_ID:
+				expected_cpu_id = BCM6368_CPU_ID;
+				bcm63xx_regs_base = bcm6368_regs_base;
+				bcm63xx_irqs = bcm6368_irqs;
+				break;
+			}
 		}
 		break;
 	}

commit d61fcfe2bbb27d4da18c609cf279627ae1b74151
Author: Florian Fainelli <florian@openwrt.org>
Date:   Wed Nov 16 20:10:36 2011 +0100

    MIPS: BCM63xx: Fix SDRAM size computation for BCM6345
    
    Instead of hardcoding the amount of available RAM, read the number of
    effective multiples of 8MB from SDRAM_MBASE_REG.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3008/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 80941687b9dd..8f0d6c7725ea 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -170,8 +170,10 @@ static unsigned int detect_memory_size(void)
 	unsigned int cols = 0, rows = 0, is_32bits = 0, banks = 0;
 	u32 val;
 
-	if (BCMCPU_IS_6345())
-		return (8 * 1024 * 1024);
+	if (BCMCPU_IS_6345()) {
+		val = bcm_sdram_readl(SDRAM_MBASE_REG);
+		return (val * 8 * 1024 * 1024);
+	}
 
 	if (BCMCPU_IS_6338() || BCMCPU_IS_6348()) {
 		val = bcm_sdram_readl(SDRAM_CFG_REG);

commit 04712f3ff6e3a42ef658b55b0f99478f4f0682e3
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Fri Nov 4 19:09:35 2011 +0100

    MIPS: BCM63XX: Add support for bcm6368 CPU.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2892/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 8bd5133eafd1..80941687b9dd 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -63,6 +63,15 @@ static const int bcm6358_irqs[] = {
 
 };
 
+static const unsigned long bcm6368_regs_base[] = {
+	__GEN_CPU_REGS_TABLE(6368)
+};
+
+static const int bcm6368_irqs[] = {
+	__GEN_CPU_IRQ_TABLE(6368)
+
+};
+
 u16 __bcm63xx_get_cpu_id(void)
 {
 	return bcm63xx_cpu_id;
@@ -89,20 +98,19 @@ unsigned int bcm63xx_get_memory_size(void)
 
 static unsigned int detect_cpu_clock(void)
 {
-	unsigned int tmp, n1 = 0, n2 = 0, m1 = 0;
-
-	/* BCM6338 has a fixed 240 Mhz frequency */
-	if (BCMCPU_IS_6338())
+	switch (bcm63xx_get_cpu_id()) {
+	case BCM6338_CPU_ID:
+		/* BCM6338 has a fixed 240 Mhz frequency */
 		return 240000000;
 
-	/* BCM6345 has a fixed 140Mhz frequency */
-	if (BCMCPU_IS_6345())
+	case BCM6345_CPU_ID:
+		/* BCM6345 has a fixed 140Mhz frequency */
 		return 140000000;
 
-	/*
-	 * frequency depends on PLL configuration:
-	 */
-	if (BCMCPU_IS_6348()) {
+	case BCM6348_CPU_ID:
+	{
+		unsigned int tmp, n1, n2, m1;
+
 		/* 16MHz * (N1 + 1) * (N2 + 2) / (M1_CPU + 1) */
 		tmp = bcm_perf_readl(PERF_MIPSPLLCTL_REG);
 		n1 = (tmp & MIPSPLLCTL_N1_MASK) >> MIPSPLLCTL_N1_SHIFT;
@@ -111,17 +119,47 @@ static unsigned int detect_cpu_clock(void)
 		n1 += 1;
 		n2 += 2;
 		m1 += 1;
+		return (16 * 1000000 * n1 * n2) / m1;
 	}
 
-	if (BCMCPU_IS_6358()) {
+	case BCM6358_CPU_ID:
+	{
+		unsigned int tmp, n1, n2, m1;
+
 		/* 16MHz * N1 * N2 / M1_CPU */
 		tmp = bcm_ddr_readl(DDR_DMIPSPLLCFG_REG);
 		n1 = (tmp & DMIPSPLLCFG_N1_MASK) >> DMIPSPLLCFG_N1_SHIFT;
 		n2 = (tmp & DMIPSPLLCFG_N2_MASK) >> DMIPSPLLCFG_N2_SHIFT;
 		m1 = (tmp & DMIPSPLLCFG_M1_MASK) >> DMIPSPLLCFG_M1_SHIFT;
+		return (16 * 1000000 * n1 * n2) / m1;
 	}
 
-	return (16 * 1000000 * n1 * n2) / m1;
+	case BCM6368_CPU_ID:
+	{
+		unsigned int tmp, p1, p2, ndiv, m1;
+
+		/* (64MHz / P1) * P2 * NDIV / M1_CPU */
+		tmp = bcm_ddr_readl(DDR_DMIPSPLLCFG_6368_REG);
+
+		p1 = (tmp & DMIPSPLLCFG_6368_P1_MASK) >>
+			DMIPSPLLCFG_6368_P1_SHIFT;
+
+		p2 = (tmp & DMIPSPLLCFG_6368_P2_MASK) >>
+			DMIPSPLLCFG_6368_P2_SHIFT;
+
+		ndiv = (tmp & DMIPSPLLCFG_6368_NDIV_MASK) >>
+			DMIPSPLLCFG_6368_NDIV_SHIFT;
+
+		tmp = bcm_ddr_readl(DDR_DMIPSPLLDIV_6368_REG);
+		m1 = (tmp & DMIPSPLLDIV_6368_MDIV_MASK) >>
+			DMIPSPLLDIV_6368_MDIV_SHIFT;
+
+		return (((64 * 1000000) / p1) * p2 * ndiv) / m1;
+	}
+
+	default:
+		BUG();
+	}
 }
 
 /*
@@ -143,7 +181,7 @@ static unsigned int detect_memory_size(void)
 		banks = (val & SDRAM_CFG_BANK_MASK) ? 2 : 1;
 	}
 
-	if (BCMCPU_IS_6358()) {
+	if (BCMCPU_IS_6358() || BCMCPU_IS_6368()) {
 		val = bcm_memc_readl(MEMC_CFG_REG);
 		rows = (val & MEMC_CFG_ROW_MASK) >> MEMC_CFG_ROW_SHIFT;
 		cols = (val & MEMC_CFG_COL_MASK) >> MEMC_CFG_COL_SHIFT;
@@ -188,9 +226,18 @@ void __init bcm63xx_cpu_init(void)
 		bcm63xx_irqs = bcm6345_irqs;
 		break;
 	case CPU_BMIPS4350:
-		expected_cpu_id = BCM6358_CPU_ID;
-		bcm63xx_regs_base = bcm6358_regs_base;
-		bcm63xx_irqs = bcm6358_irqs;
+		switch (read_c0_prid() & 0xf0) {
+		case 0x10:
+			expected_cpu_id = BCM6358_CPU_ID;
+			bcm63xx_regs_base = bcm6358_regs_base;
+			bcm63xx_irqs = bcm6358_irqs;
+			break;
+		case 0x30:
+			expected_cpu_id = BCM6368_CPU_ID;
+			bcm63xx_regs_base = bcm6368_regs_base;
+			bcm63xx_irqs = bcm6368_irqs;
+			break;
+		}
 		break;
 	}
 

commit ec68c5206ab32f67583c1297f7883ceb91b043eb
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Fri Nov 4 19:09:29 2011 +0100

    MIPS: BCM63XX: Cleanup cpu registers.
    
    Use preprocessor when possible to avoid duplicated and error-prone
    code.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2897/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 7c7e4d4486ce..8bd5133eafd1 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -29,166 +29,38 @@ static u16 bcm63xx_cpu_rev;
 static unsigned int bcm63xx_cpu_freq;
 static unsigned int bcm63xx_memory_size;
 
-/*
- * 6338 register sets and irqs
- */
-static const unsigned long bcm96338_regs_base[] = {
-	[RSET_DSL_LMEM]		= BCM_6338_DSL_LMEM_BASE,
-	[RSET_PERF]		= BCM_6338_PERF_BASE,
-	[RSET_TIMER]		= BCM_6338_TIMER_BASE,
-	[RSET_WDT]		= BCM_6338_WDT_BASE,
-	[RSET_UART0]		= BCM_6338_UART0_BASE,
-	[RSET_UART1]		= BCM_6338_UART1_BASE,
-	[RSET_GPIO]		= BCM_6338_GPIO_BASE,
-	[RSET_SPI]		= BCM_6338_SPI_BASE,
-	[RSET_OHCI0]		= BCM_6338_OHCI0_BASE,
-	[RSET_OHCI_PRIV]	= BCM_6338_OHCI_PRIV_BASE,
-	[RSET_USBH_PRIV]	= BCM_6338_USBH_PRIV_BASE,
-	[RSET_UDC0]		= BCM_6338_UDC0_BASE,
-	[RSET_MPI]		= BCM_6338_MPI_BASE,
-	[RSET_PCMCIA]		= BCM_6338_PCMCIA_BASE,
-	[RSET_SDRAM]		= BCM_6338_SDRAM_BASE,
-	[RSET_DSL]		= BCM_6338_DSL_BASE,
-	[RSET_ENET0]		= BCM_6338_ENET0_BASE,
-	[RSET_ENET1]		= BCM_6338_ENET1_BASE,
-	[RSET_ENETDMA]		= BCM_6338_ENETDMA_BASE,
-	[RSET_MEMC]		= BCM_6338_MEMC_BASE,
-	[RSET_DDR]		= BCM_6338_DDR_BASE,
+static const unsigned long bcm6338_regs_base[] = {
+	__GEN_CPU_REGS_TABLE(6338)
 };
 
-static const int bcm96338_irqs[] = {
-	[IRQ_TIMER]		= BCM_6338_TIMER_IRQ,
-	[IRQ_UART0]		= BCM_6338_UART0_IRQ,
-	[IRQ_DSL]		= BCM_6338_DSL_IRQ,
-	[IRQ_ENET0]		= BCM_6338_ENET0_IRQ,
-	[IRQ_ENET_PHY]		= BCM_6338_ENET_PHY_IRQ,
-	[IRQ_ENET0_RXDMA]	= BCM_6338_ENET0_RXDMA_IRQ,
-	[IRQ_ENET0_TXDMA]	= BCM_6338_ENET0_TXDMA_IRQ,
+static const int bcm6338_irqs[] = {
+	__GEN_CPU_IRQ_TABLE(6338)
 };
 
-/*
- * 6345 register sets and irqs
- */
-static const unsigned long bcm96345_regs_base[] = {
-	[RSET_DSL_LMEM]		= BCM_6345_DSL_LMEM_BASE,
-	[RSET_PERF]		= BCM_6345_PERF_BASE,
-	[RSET_TIMER]		= BCM_6345_TIMER_BASE,
-	[RSET_WDT]		= BCM_6345_WDT_BASE,
-	[RSET_UART0]		= BCM_6345_UART0_BASE,
-	[RSET_UART1]		= BCM_6345_UART1_BASE,
-	[RSET_GPIO]		= BCM_6345_GPIO_BASE,
-	[RSET_SPI]		= BCM_6345_SPI_BASE,
-	[RSET_UDC0]		= BCM_6345_UDC0_BASE,
-	[RSET_OHCI0]		= BCM_6345_OHCI0_BASE,
-	[RSET_OHCI_PRIV]	= BCM_6345_OHCI_PRIV_BASE,
-	[RSET_USBH_PRIV]	= BCM_6345_USBH_PRIV_BASE,
-	[RSET_MPI]		= BCM_6345_MPI_BASE,
-	[RSET_PCMCIA]		= BCM_6345_PCMCIA_BASE,
-	[RSET_DSL]		= BCM_6345_DSL_BASE,
-	[RSET_ENET0]		= BCM_6345_ENET0_BASE,
-	[RSET_ENET1]		= BCM_6345_ENET1_BASE,
-	[RSET_ENETDMA]		= BCM_6345_ENETDMA_BASE,
-	[RSET_EHCI0]		= BCM_6345_EHCI0_BASE,
-	[RSET_SDRAM]		= BCM_6345_SDRAM_BASE,
-	[RSET_MEMC]		= BCM_6345_MEMC_BASE,
-	[RSET_DDR]		= BCM_6345_DDR_BASE,
+static const unsigned long bcm6345_regs_base[] = {
+	__GEN_CPU_REGS_TABLE(6345)
 };
 
-static const int bcm96345_irqs[] = {
-	[IRQ_TIMER]		= BCM_6345_TIMER_IRQ,
-	[IRQ_UART0]		= BCM_6345_UART0_IRQ,
-	[IRQ_DSL]		= BCM_6345_DSL_IRQ,
-	[IRQ_ENET0]		= BCM_6345_ENET0_IRQ,
-	[IRQ_ENET_PHY]		= BCM_6345_ENET_PHY_IRQ,
-	[IRQ_ENET0_RXDMA]	= BCM_6345_ENET0_RXDMA_IRQ,
-	[IRQ_ENET0_TXDMA]	= BCM_6345_ENET0_TXDMA_IRQ,
+static const int bcm6345_irqs[] = {
+	__GEN_CPU_IRQ_TABLE(6345)
 };
 
-/*
- * 6348 register sets and irqs
- */
-static const unsigned long bcm96348_regs_base[] = {
-	[RSET_DSL_LMEM]		= BCM_6348_DSL_LMEM_BASE,
-	[RSET_PERF]		= BCM_6348_PERF_BASE,
-	[RSET_TIMER]		= BCM_6348_TIMER_BASE,
-	[RSET_WDT]		= BCM_6348_WDT_BASE,
-	[RSET_UART0]		= BCM_6348_UART0_BASE,
-	[RSET_UART1]		= BCM_6348_UART1_BASE,
-	[RSET_GPIO]		= BCM_6348_GPIO_BASE,
-	[RSET_SPI]		= BCM_6348_SPI_BASE,
-	[RSET_OHCI0]		= BCM_6348_OHCI0_BASE,
-	[RSET_OHCI_PRIV]	= BCM_6348_OHCI_PRIV_BASE,
-	[RSET_USBH_PRIV]	= BCM_6348_USBH_PRIV_BASE,
-	[RSET_MPI]		= BCM_6348_MPI_BASE,
-	[RSET_PCMCIA]		= BCM_6348_PCMCIA_BASE,
-	[RSET_SDRAM]		= BCM_6348_SDRAM_BASE,
-	[RSET_DSL]		= BCM_6348_DSL_BASE,
-	[RSET_ENET0]		= BCM_6348_ENET0_BASE,
-	[RSET_ENET1]		= BCM_6348_ENET1_BASE,
-	[RSET_ENETDMA]		= BCM_6348_ENETDMA_BASE,
-	[RSET_MEMC]		= BCM_6348_MEMC_BASE,
-	[RSET_DDR]		= BCM_6348_DDR_BASE,
+static const unsigned long bcm6348_regs_base[] = {
+	__GEN_CPU_REGS_TABLE(6348)
 };
 
-static const int bcm96348_irqs[] = {
-	[IRQ_TIMER]		= BCM_6348_TIMER_IRQ,
-	[IRQ_UART0]		= BCM_6348_UART0_IRQ,
-	[IRQ_DSL]		= BCM_6348_DSL_IRQ,
-	[IRQ_ENET0]		= BCM_6348_ENET0_IRQ,
-	[IRQ_ENET1]		= BCM_6348_ENET1_IRQ,
-	[IRQ_ENET_PHY]		= BCM_6348_ENET_PHY_IRQ,
-	[IRQ_OHCI0]		= BCM_6348_OHCI0_IRQ,
-	[IRQ_PCMCIA]		= BCM_6348_PCMCIA_IRQ,
-	[IRQ_ENET0_RXDMA]	= BCM_6348_ENET0_RXDMA_IRQ,
-	[IRQ_ENET0_TXDMA]	= BCM_6348_ENET0_TXDMA_IRQ,
-	[IRQ_ENET1_RXDMA]	= BCM_6348_ENET1_RXDMA_IRQ,
-	[IRQ_ENET1_TXDMA]	= BCM_6348_ENET1_TXDMA_IRQ,
-	[IRQ_PCI]		= BCM_6348_PCI_IRQ,
+static const int bcm6348_irqs[] = {
+	__GEN_CPU_IRQ_TABLE(6348)
+
 };
 
-/*
- * 6358 register sets and irqs
- */
-static const unsigned long bcm96358_regs_base[] = {
-	[RSET_DSL_LMEM]		= BCM_6358_DSL_LMEM_BASE,
-	[RSET_PERF]		= BCM_6358_PERF_BASE,
-	[RSET_TIMER]		= BCM_6358_TIMER_BASE,
-	[RSET_WDT]		= BCM_6358_WDT_BASE,
-	[RSET_UART0]		= BCM_6358_UART0_BASE,
-	[RSET_UART1]		= BCM_6358_UART1_BASE,
-	[RSET_GPIO]		= BCM_6358_GPIO_BASE,
-	[RSET_SPI]		= BCM_6358_SPI_BASE,
-	[RSET_OHCI0]		= BCM_6358_OHCI0_BASE,
-	[RSET_EHCI0]		= BCM_6358_EHCI0_BASE,
-	[RSET_OHCI_PRIV]	= BCM_6358_OHCI_PRIV_BASE,
-	[RSET_USBH_PRIV]	= BCM_6358_USBH_PRIV_BASE,
-	[RSET_MPI]		= BCM_6358_MPI_BASE,
-	[RSET_PCMCIA]		= BCM_6358_PCMCIA_BASE,
-	[RSET_SDRAM]		= BCM_6358_SDRAM_BASE,
-	[RSET_DSL]		= BCM_6358_DSL_BASE,
-	[RSET_ENET0]		= BCM_6358_ENET0_BASE,
-	[RSET_ENET1]		= BCM_6358_ENET1_BASE,
-	[RSET_ENETDMA]		= BCM_6358_ENETDMA_BASE,
-	[RSET_MEMC]		= BCM_6358_MEMC_BASE,
-	[RSET_DDR]		= BCM_6358_DDR_BASE,
+static const unsigned long bcm6358_regs_base[] = {
+	__GEN_CPU_REGS_TABLE(6358)
 };
 
-static const int bcm96358_irqs[] = {
-	[IRQ_TIMER]		= BCM_6358_TIMER_IRQ,
-	[IRQ_UART0]		= BCM_6358_UART0_IRQ,
-	[IRQ_UART1]		= BCM_6358_UART1_IRQ,
-	[IRQ_DSL]		= BCM_6358_DSL_IRQ,
-	[IRQ_ENET0]		= BCM_6358_ENET0_IRQ,
-	[IRQ_ENET1]		= BCM_6358_ENET1_IRQ,
-	[IRQ_ENET_PHY]		= BCM_6358_ENET_PHY_IRQ,
-	[IRQ_OHCI0]		= BCM_6358_OHCI0_IRQ,
-	[IRQ_EHCI0]		= BCM_6358_EHCI0_IRQ,
-	[IRQ_PCMCIA]		= BCM_6358_PCMCIA_IRQ,
-	[IRQ_ENET0_RXDMA]	= BCM_6358_ENET0_RXDMA_IRQ,
-	[IRQ_ENET0_TXDMA]	= BCM_6358_ENET0_TXDMA_IRQ,
-	[IRQ_ENET1_RXDMA]	= BCM_6358_ENET1_RXDMA_IRQ,
-	[IRQ_ENET1_TXDMA]	= BCM_6358_ENET1_TXDMA_IRQ,
-	[IRQ_PCI]		= BCM_6358_PCI_IRQ,
+static const int bcm6358_irqs[] = {
+	__GEN_CPU_IRQ_TABLE(6358)
+
 };
 
 u16 __bcm63xx_get_cpu_id(void)
@@ -301,24 +173,24 @@ void __init bcm63xx_cpu_init(void)
 	case CPU_BMIPS3300:
 		if ((read_c0_prid() & 0xff00) == PRID_IMP_BMIPS3300_ALT) {
 			expected_cpu_id = BCM6348_CPU_ID;
-			bcm63xx_regs_base = bcm96348_regs_base;
-			bcm63xx_irqs = bcm96348_irqs;
+			bcm63xx_regs_base = bcm6348_regs_base;
+			bcm63xx_irqs = bcm6348_irqs;
 		} else {
 			__cpu_name[cpu] = "Broadcom BCM6338";
 			expected_cpu_id = BCM6338_CPU_ID;
-			bcm63xx_regs_base = bcm96338_regs_base;
-			bcm63xx_irqs = bcm96338_irqs;
+			bcm63xx_regs_base = bcm6338_regs_base;
+			bcm63xx_irqs = bcm6338_irqs;
 		}
 		break;
 	case CPU_BMIPS32:
 		expected_cpu_id = BCM6345_CPU_ID;
-		bcm63xx_regs_base = bcm96345_regs_base;
-		bcm63xx_irqs = bcm96345_irqs;
+		bcm63xx_regs_base = bcm6345_regs_base;
+		bcm63xx_irqs = bcm6345_irqs;
 		break;
 	case CPU_BMIPS4350:
 		expected_cpu_id = BCM6358_CPU_ID;
-		bcm63xx_regs_base = bcm96358_regs_base;
-		bcm63xx_irqs = bcm96358_irqs;
+		bcm63xx_regs_base = bcm6358_regs_base;
+		bcm63xx_irqs = bcm6358_irqs;
 		break;
 	}
 

commit 602977b0d672687909b0cb0542ede134ed6ef858
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Sat Oct 16 14:22:30 2010 -0700

    MIPS: Decouple BMIPS CPU support from bcm47xx/bcm63xx SoC code
    
    BMIPS processor cores are used in 50+ different chipsets spread across
    5+ product lines.  In many cases the chipsets do not share the same
    peripheral register layouts, the same register blocks, the same
    interrupt controllers, the same memory maps, or much of anything else.
    
    But, across radically different SoCs that share nothing more than the
    same BMIPS CPU, a few things are still mostly constant:
    
    SMP operations
    Access to performance counters
    DMA cache coherency quirks
    Cache and memory bus configuration
    
    So, it makes sense to treat each BMIPS processor type as a generic
    "building block," rather than tying it to a specific SoC.  This makes it
    easier to support a large number of BMIPS-based chipsets without
    unnecessary duplication of code, and provides the infrastructure needed
    to support BMIPS-proprietary features.
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Cc: mbizon@freebox.fr
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Tested-by: Florian Fainelli <ffainelli@freebox.fr>
    Patchwork: https://patchwork.linux-mips.org/patch/1706/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index cbb7caf86d77..7c7e4d4486ce 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -10,7 +10,9 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/cpu.h>
+#include <asm/cpu.h>
 #include <asm/cpu-info.h>
+#include <asm/mipsregs.h>
 #include <bcm63xx_cpu.h>
 #include <bcm63xx_regs.h>
 #include <bcm63xx_io.h>
@@ -296,26 +298,24 @@ void __init bcm63xx_cpu_init(void)
 	expected_cpu_id = 0;
 
 	switch (c->cputype) {
-	/*
-	 * BCM6338 as the same PrId as BCM3302 see arch/mips/kernel/cpu-probe.c
-	 */
-	case CPU_BCM3302:
-		__cpu_name[cpu] = "Broadcom BCM6338";
-		expected_cpu_id = BCM6338_CPU_ID;
-		bcm63xx_regs_base = bcm96338_regs_base;
-		bcm63xx_irqs = bcm96338_irqs;
+	case CPU_BMIPS3300:
+		if ((read_c0_prid() & 0xff00) == PRID_IMP_BMIPS3300_ALT) {
+			expected_cpu_id = BCM6348_CPU_ID;
+			bcm63xx_regs_base = bcm96348_regs_base;
+			bcm63xx_irqs = bcm96348_irqs;
+		} else {
+			__cpu_name[cpu] = "Broadcom BCM6338";
+			expected_cpu_id = BCM6338_CPU_ID;
+			bcm63xx_regs_base = bcm96338_regs_base;
+			bcm63xx_irqs = bcm96338_irqs;
+		}
 		break;
-	case CPU_BCM6345:
+	case CPU_BMIPS32:
 		expected_cpu_id = BCM6345_CPU_ID;
 		bcm63xx_regs_base = bcm96345_regs_base;
 		bcm63xx_irqs = bcm96345_irqs;
 		break;
-	case CPU_BCM6348:
-		expected_cpu_id = BCM6348_CPU_ID;
-		bcm63xx_regs_base = bcm96348_regs_base;
-		bcm63xx_irqs = bcm96348_irqs;
-		break;
-	case CPU_BCM6358:
+	case CPU_BMIPS4350:
 		expected_cpu_id = BCM6358_CPU_ID;
 		bcm63xx_regs_base = bcm96358_regs_base;
 		bcm63xx_irqs = bcm96358_irqs;

commit 524ef29cff593ab6635cda2a17b331bede58a396
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Sat Jan 30 18:34:55 2010 +0100

    MIPS: BCM63xx: Add support for second uart.
    
    The BCm63xx SOC has two uarts.  Some boards use the second one for
    bluetooth.  This patch changes platform device registration code to
    handle this.  Changes to the UART driver were already merged in
    6a2c7eabfd09ca7986bf96b8958a87ca041a19d8.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    To: linux-mips@linux-mips.org
    Cc: Maxime Bizon <mbizon@freebox.fr>
    Patchwork: http://patchwork.linux-mips.org/patch/900/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 70378bb5e3f9..cbb7caf86d77 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -36,6 +36,7 @@ static const unsigned long bcm96338_regs_base[] = {
 	[RSET_TIMER]		= BCM_6338_TIMER_BASE,
 	[RSET_WDT]		= BCM_6338_WDT_BASE,
 	[RSET_UART0]		= BCM_6338_UART0_BASE,
+	[RSET_UART1]		= BCM_6338_UART1_BASE,
 	[RSET_GPIO]		= BCM_6338_GPIO_BASE,
 	[RSET_SPI]		= BCM_6338_SPI_BASE,
 	[RSET_OHCI0]		= BCM_6338_OHCI0_BASE,
@@ -72,6 +73,7 @@ static const unsigned long bcm96345_regs_base[] = {
 	[RSET_TIMER]		= BCM_6345_TIMER_BASE,
 	[RSET_WDT]		= BCM_6345_WDT_BASE,
 	[RSET_UART0]		= BCM_6345_UART0_BASE,
+	[RSET_UART1]		= BCM_6345_UART1_BASE,
 	[RSET_GPIO]		= BCM_6345_GPIO_BASE,
 	[RSET_SPI]		= BCM_6345_SPI_BASE,
 	[RSET_UDC0]		= BCM_6345_UDC0_BASE,
@@ -109,6 +111,7 @@ static const unsigned long bcm96348_regs_base[] = {
 	[RSET_TIMER]		= BCM_6348_TIMER_BASE,
 	[RSET_WDT]		= BCM_6348_WDT_BASE,
 	[RSET_UART0]		= BCM_6348_UART0_BASE,
+	[RSET_UART1]		= BCM_6348_UART1_BASE,
 	[RSET_GPIO]		= BCM_6348_GPIO_BASE,
 	[RSET_SPI]		= BCM_6348_SPI_BASE,
 	[RSET_OHCI0]		= BCM_6348_OHCI0_BASE,
@@ -150,6 +153,7 @@ static const unsigned long bcm96358_regs_base[] = {
 	[RSET_TIMER]		= BCM_6358_TIMER_BASE,
 	[RSET_WDT]		= BCM_6358_WDT_BASE,
 	[RSET_UART0]		= BCM_6358_UART0_BASE,
+	[RSET_UART1]		= BCM_6358_UART1_BASE,
 	[RSET_GPIO]		= BCM_6358_GPIO_BASE,
 	[RSET_SPI]		= BCM_6358_SPI_BASE,
 	[RSET_OHCI0]		= BCM_6358_OHCI0_BASE,
@@ -170,6 +174,7 @@ static const unsigned long bcm96358_regs_base[] = {
 static const int bcm96358_irqs[] = {
 	[IRQ_TIMER]		= BCM_6358_TIMER_IRQ,
 	[IRQ_UART0]		= BCM_6358_UART0_IRQ,
+	[IRQ_UART1]		= BCM_6358_UART1_IRQ,
 	[IRQ_DSL]		= BCM_6358_DSL_IRQ,
 	[IRQ_ENET0]		= BCM_6358_ENET0_IRQ,
 	[IRQ_ENET1]		= BCM_6358_ENET1_IRQ,

commit 2b5b9b786c177fa4bca1646325a1dd98c4399523
Author: Florian Fainelli <florian@openwrt.org>
Date:   Wed Oct 14 09:56:00 2009 +0200

    MIPS: bcm63xx: Set the correct BCM3302 CPU name
    
    For consistency with other BCM63xx SoC set the CPU name to "Broadcom
    BCM6338" when actually running on that system.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
index 6dc43f0483e8..70378bb5e3f9 100644
--- a/arch/mips/bcm63xx/cpu.c
+++ b/arch/mips/bcm63xx/cpu.c
@@ -10,6 +10,7 @@
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/cpu.h>
+#include <asm/cpu-info.h>
 #include <bcm63xx_cpu.h>
 #include <bcm63xx_regs.h>
 #include <bcm63xx_io.h>
@@ -284,6 +285,7 @@ void __init bcm63xx_cpu_init(void)
 {
 	unsigned int tmp, expected_cpu_id;
 	struct cpuinfo_mips *c = &current_cpu_data;
+	unsigned int cpu = smp_processor_id();
 
 	/* soc registers location depends on cpu type */
 	expected_cpu_id = 0;
@@ -293,6 +295,7 @@ void __init bcm63xx_cpu_init(void)
 	 * BCM6338 as the same PrId as BCM3302 see arch/mips/kernel/cpu-probe.c
 	 */
 	case CPU_BCM3302:
+		__cpu_name[cpu] = "Broadcom BCM6338";
 		expected_cpu_id = BCM6338_CPU_ID;
 		bcm63xx_regs_base = bcm96338_regs_base;
 		bcm63xx_irqs = bcm96338_irqs;

commit e7300d04bd0809eb7ea10a2ed8c729459f816e36
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Tue Aug 18 13:23:37 2009 +0100

    MIPS: BCM63xx: Add support for the Broadcom BCM63xx family of SOCs.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/cpu.c b/arch/mips/bcm63xx/cpu.c
new file mode 100644
index 000000000000..6dc43f0483e8
--- /dev/null
+++ b/arch/mips/bcm63xx/cpu.c
@@ -0,0 +1,345 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2008 Maxime Bizon <mbizon@freebox.fr>
+ * Copyright (C) 2009 Florian Fainelli <florian@openwrt.org>
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/cpu.h>
+#include <bcm63xx_cpu.h>
+#include <bcm63xx_regs.h>
+#include <bcm63xx_io.h>
+#include <bcm63xx_irq.h>
+
+const unsigned long *bcm63xx_regs_base;
+EXPORT_SYMBOL(bcm63xx_regs_base);
+
+const int *bcm63xx_irqs;
+EXPORT_SYMBOL(bcm63xx_irqs);
+
+static u16 bcm63xx_cpu_id;
+static u16 bcm63xx_cpu_rev;
+static unsigned int bcm63xx_cpu_freq;
+static unsigned int bcm63xx_memory_size;
+
+/*
+ * 6338 register sets and irqs
+ */
+static const unsigned long bcm96338_regs_base[] = {
+	[RSET_DSL_LMEM]		= BCM_6338_DSL_LMEM_BASE,
+	[RSET_PERF]		= BCM_6338_PERF_BASE,
+	[RSET_TIMER]		= BCM_6338_TIMER_BASE,
+	[RSET_WDT]		= BCM_6338_WDT_BASE,
+	[RSET_UART0]		= BCM_6338_UART0_BASE,
+	[RSET_GPIO]		= BCM_6338_GPIO_BASE,
+	[RSET_SPI]		= BCM_6338_SPI_BASE,
+	[RSET_OHCI0]		= BCM_6338_OHCI0_BASE,
+	[RSET_OHCI_PRIV]	= BCM_6338_OHCI_PRIV_BASE,
+	[RSET_USBH_PRIV]	= BCM_6338_USBH_PRIV_BASE,
+	[RSET_UDC0]		= BCM_6338_UDC0_BASE,
+	[RSET_MPI]		= BCM_6338_MPI_BASE,
+	[RSET_PCMCIA]		= BCM_6338_PCMCIA_BASE,
+	[RSET_SDRAM]		= BCM_6338_SDRAM_BASE,
+	[RSET_DSL]		= BCM_6338_DSL_BASE,
+	[RSET_ENET0]		= BCM_6338_ENET0_BASE,
+	[RSET_ENET1]		= BCM_6338_ENET1_BASE,
+	[RSET_ENETDMA]		= BCM_6338_ENETDMA_BASE,
+	[RSET_MEMC]		= BCM_6338_MEMC_BASE,
+	[RSET_DDR]		= BCM_6338_DDR_BASE,
+};
+
+static const int bcm96338_irqs[] = {
+	[IRQ_TIMER]		= BCM_6338_TIMER_IRQ,
+	[IRQ_UART0]		= BCM_6338_UART0_IRQ,
+	[IRQ_DSL]		= BCM_6338_DSL_IRQ,
+	[IRQ_ENET0]		= BCM_6338_ENET0_IRQ,
+	[IRQ_ENET_PHY]		= BCM_6338_ENET_PHY_IRQ,
+	[IRQ_ENET0_RXDMA]	= BCM_6338_ENET0_RXDMA_IRQ,
+	[IRQ_ENET0_TXDMA]	= BCM_6338_ENET0_TXDMA_IRQ,
+};
+
+/*
+ * 6345 register sets and irqs
+ */
+static const unsigned long bcm96345_regs_base[] = {
+	[RSET_DSL_LMEM]		= BCM_6345_DSL_LMEM_BASE,
+	[RSET_PERF]		= BCM_6345_PERF_BASE,
+	[RSET_TIMER]		= BCM_6345_TIMER_BASE,
+	[RSET_WDT]		= BCM_6345_WDT_BASE,
+	[RSET_UART0]		= BCM_6345_UART0_BASE,
+	[RSET_GPIO]		= BCM_6345_GPIO_BASE,
+	[RSET_SPI]		= BCM_6345_SPI_BASE,
+	[RSET_UDC0]		= BCM_6345_UDC0_BASE,
+	[RSET_OHCI0]		= BCM_6345_OHCI0_BASE,
+	[RSET_OHCI_PRIV]	= BCM_6345_OHCI_PRIV_BASE,
+	[RSET_USBH_PRIV]	= BCM_6345_USBH_PRIV_BASE,
+	[RSET_MPI]		= BCM_6345_MPI_BASE,
+	[RSET_PCMCIA]		= BCM_6345_PCMCIA_BASE,
+	[RSET_DSL]		= BCM_6345_DSL_BASE,
+	[RSET_ENET0]		= BCM_6345_ENET0_BASE,
+	[RSET_ENET1]		= BCM_6345_ENET1_BASE,
+	[RSET_ENETDMA]		= BCM_6345_ENETDMA_BASE,
+	[RSET_EHCI0]		= BCM_6345_EHCI0_BASE,
+	[RSET_SDRAM]		= BCM_6345_SDRAM_BASE,
+	[RSET_MEMC]		= BCM_6345_MEMC_BASE,
+	[RSET_DDR]		= BCM_6345_DDR_BASE,
+};
+
+static const int bcm96345_irqs[] = {
+	[IRQ_TIMER]		= BCM_6345_TIMER_IRQ,
+	[IRQ_UART0]		= BCM_6345_UART0_IRQ,
+	[IRQ_DSL]		= BCM_6345_DSL_IRQ,
+	[IRQ_ENET0]		= BCM_6345_ENET0_IRQ,
+	[IRQ_ENET_PHY]		= BCM_6345_ENET_PHY_IRQ,
+	[IRQ_ENET0_RXDMA]	= BCM_6345_ENET0_RXDMA_IRQ,
+	[IRQ_ENET0_TXDMA]	= BCM_6345_ENET0_TXDMA_IRQ,
+};
+
+/*
+ * 6348 register sets and irqs
+ */
+static const unsigned long bcm96348_regs_base[] = {
+	[RSET_DSL_LMEM]		= BCM_6348_DSL_LMEM_BASE,
+	[RSET_PERF]		= BCM_6348_PERF_BASE,
+	[RSET_TIMER]		= BCM_6348_TIMER_BASE,
+	[RSET_WDT]		= BCM_6348_WDT_BASE,
+	[RSET_UART0]		= BCM_6348_UART0_BASE,
+	[RSET_GPIO]		= BCM_6348_GPIO_BASE,
+	[RSET_SPI]		= BCM_6348_SPI_BASE,
+	[RSET_OHCI0]		= BCM_6348_OHCI0_BASE,
+	[RSET_OHCI_PRIV]	= BCM_6348_OHCI_PRIV_BASE,
+	[RSET_USBH_PRIV]	= BCM_6348_USBH_PRIV_BASE,
+	[RSET_MPI]		= BCM_6348_MPI_BASE,
+	[RSET_PCMCIA]		= BCM_6348_PCMCIA_BASE,
+	[RSET_SDRAM]		= BCM_6348_SDRAM_BASE,
+	[RSET_DSL]		= BCM_6348_DSL_BASE,
+	[RSET_ENET0]		= BCM_6348_ENET0_BASE,
+	[RSET_ENET1]		= BCM_6348_ENET1_BASE,
+	[RSET_ENETDMA]		= BCM_6348_ENETDMA_BASE,
+	[RSET_MEMC]		= BCM_6348_MEMC_BASE,
+	[RSET_DDR]		= BCM_6348_DDR_BASE,
+};
+
+static const int bcm96348_irqs[] = {
+	[IRQ_TIMER]		= BCM_6348_TIMER_IRQ,
+	[IRQ_UART0]		= BCM_6348_UART0_IRQ,
+	[IRQ_DSL]		= BCM_6348_DSL_IRQ,
+	[IRQ_ENET0]		= BCM_6348_ENET0_IRQ,
+	[IRQ_ENET1]		= BCM_6348_ENET1_IRQ,
+	[IRQ_ENET_PHY]		= BCM_6348_ENET_PHY_IRQ,
+	[IRQ_OHCI0]		= BCM_6348_OHCI0_IRQ,
+	[IRQ_PCMCIA]		= BCM_6348_PCMCIA_IRQ,
+	[IRQ_ENET0_RXDMA]	= BCM_6348_ENET0_RXDMA_IRQ,
+	[IRQ_ENET0_TXDMA]	= BCM_6348_ENET0_TXDMA_IRQ,
+	[IRQ_ENET1_RXDMA]	= BCM_6348_ENET1_RXDMA_IRQ,
+	[IRQ_ENET1_TXDMA]	= BCM_6348_ENET1_TXDMA_IRQ,
+	[IRQ_PCI]		= BCM_6348_PCI_IRQ,
+};
+
+/*
+ * 6358 register sets and irqs
+ */
+static const unsigned long bcm96358_regs_base[] = {
+	[RSET_DSL_LMEM]		= BCM_6358_DSL_LMEM_BASE,
+	[RSET_PERF]		= BCM_6358_PERF_BASE,
+	[RSET_TIMER]		= BCM_6358_TIMER_BASE,
+	[RSET_WDT]		= BCM_6358_WDT_BASE,
+	[RSET_UART0]		= BCM_6358_UART0_BASE,
+	[RSET_GPIO]		= BCM_6358_GPIO_BASE,
+	[RSET_SPI]		= BCM_6358_SPI_BASE,
+	[RSET_OHCI0]		= BCM_6358_OHCI0_BASE,
+	[RSET_EHCI0]		= BCM_6358_EHCI0_BASE,
+	[RSET_OHCI_PRIV]	= BCM_6358_OHCI_PRIV_BASE,
+	[RSET_USBH_PRIV]	= BCM_6358_USBH_PRIV_BASE,
+	[RSET_MPI]		= BCM_6358_MPI_BASE,
+	[RSET_PCMCIA]		= BCM_6358_PCMCIA_BASE,
+	[RSET_SDRAM]		= BCM_6358_SDRAM_BASE,
+	[RSET_DSL]		= BCM_6358_DSL_BASE,
+	[RSET_ENET0]		= BCM_6358_ENET0_BASE,
+	[RSET_ENET1]		= BCM_6358_ENET1_BASE,
+	[RSET_ENETDMA]		= BCM_6358_ENETDMA_BASE,
+	[RSET_MEMC]		= BCM_6358_MEMC_BASE,
+	[RSET_DDR]		= BCM_6358_DDR_BASE,
+};
+
+static const int bcm96358_irqs[] = {
+	[IRQ_TIMER]		= BCM_6358_TIMER_IRQ,
+	[IRQ_UART0]		= BCM_6358_UART0_IRQ,
+	[IRQ_DSL]		= BCM_6358_DSL_IRQ,
+	[IRQ_ENET0]		= BCM_6358_ENET0_IRQ,
+	[IRQ_ENET1]		= BCM_6358_ENET1_IRQ,
+	[IRQ_ENET_PHY]		= BCM_6358_ENET_PHY_IRQ,
+	[IRQ_OHCI0]		= BCM_6358_OHCI0_IRQ,
+	[IRQ_EHCI0]		= BCM_6358_EHCI0_IRQ,
+	[IRQ_PCMCIA]		= BCM_6358_PCMCIA_IRQ,
+	[IRQ_ENET0_RXDMA]	= BCM_6358_ENET0_RXDMA_IRQ,
+	[IRQ_ENET0_TXDMA]	= BCM_6358_ENET0_TXDMA_IRQ,
+	[IRQ_ENET1_RXDMA]	= BCM_6358_ENET1_RXDMA_IRQ,
+	[IRQ_ENET1_TXDMA]	= BCM_6358_ENET1_TXDMA_IRQ,
+	[IRQ_PCI]		= BCM_6358_PCI_IRQ,
+};
+
+u16 __bcm63xx_get_cpu_id(void)
+{
+	return bcm63xx_cpu_id;
+}
+
+EXPORT_SYMBOL(__bcm63xx_get_cpu_id);
+
+u16 bcm63xx_get_cpu_rev(void)
+{
+	return bcm63xx_cpu_rev;
+}
+
+EXPORT_SYMBOL(bcm63xx_get_cpu_rev);
+
+unsigned int bcm63xx_get_cpu_freq(void)
+{
+	return bcm63xx_cpu_freq;
+}
+
+unsigned int bcm63xx_get_memory_size(void)
+{
+	return bcm63xx_memory_size;
+}
+
+static unsigned int detect_cpu_clock(void)
+{
+	unsigned int tmp, n1 = 0, n2 = 0, m1 = 0;
+
+	/* BCM6338 has a fixed 240 Mhz frequency */
+	if (BCMCPU_IS_6338())
+		return 240000000;
+
+	/* BCM6345 has a fixed 140Mhz frequency */
+	if (BCMCPU_IS_6345())
+		return 140000000;
+
+	/*
+	 * frequency depends on PLL configuration:
+	 */
+	if (BCMCPU_IS_6348()) {
+		/* 16MHz * (N1 + 1) * (N2 + 2) / (M1_CPU + 1) */
+		tmp = bcm_perf_readl(PERF_MIPSPLLCTL_REG);
+		n1 = (tmp & MIPSPLLCTL_N1_MASK) >> MIPSPLLCTL_N1_SHIFT;
+		n2 = (tmp & MIPSPLLCTL_N2_MASK) >> MIPSPLLCTL_N2_SHIFT;
+		m1 = (tmp & MIPSPLLCTL_M1CPU_MASK) >> MIPSPLLCTL_M1CPU_SHIFT;
+		n1 += 1;
+		n2 += 2;
+		m1 += 1;
+	}
+
+	if (BCMCPU_IS_6358()) {
+		/* 16MHz * N1 * N2 / M1_CPU */
+		tmp = bcm_ddr_readl(DDR_DMIPSPLLCFG_REG);
+		n1 = (tmp & DMIPSPLLCFG_N1_MASK) >> DMIPSPLLCFG_N1_SHIFT;
+		n2 = (tmp & DMIPSPLLCFG_N2_MASK) >> DMIPSPLLCFG_N2_SHIFT;
+		m1 = (tmp & DMIPSPLLCFG_M1_MASK) >> DMIPSPLLCFG_M1_SHIFT;
+	}
+
+	return (16 * 1000000 * n1 * n2) / m1;
+}
+
+/*
+ * attempt to detect the amount of memory installed
+ */
+static unsigned int detect_memory_size(void)
+{
+	unsigned int cols = 0, rows = 0, is_32bits = 0, banks = 0;
+	u32 val;
+
+	if (BCMCPU_IS_6345())
+		return (8 * 1024 * 1024);
+
+	if (BCMCPU_IS_6338() || BCMCPU_IS_6348()) {
+		val = bcm_sdram_readl(SDRAM_CFG_REG);
+		rows = (val & SDRAM_CFG_ROW_MASK) >> SDRAM_CFG_ROW_SHIFT;
+		cols = (val & SDRAM_CFG_COL_MASK) >> SDRAM_CFG_COL_SHIFT;
+		is_32bits = (val & SDRAM_CFG_32B_MASK) ? 1 : 0;
+		banks = (val & SDRAM_CFG_BANK_MASK) ? 2 : 1;
+	}
+
+	if (BCMCPU_IS_6358()) {
+		val = bcm_memc_readl(MEMC_CFG_REG);
+		rows = (val & MEMC_CFG_ROW_MASK) >> MEMC_CFG_ROW_SHIFT;
+		cols = (val & MEMC_CFG_COL_MASK) >> MEMC_CFG_COL_SHIFT;
+		is_32bits = (val & MEMC_CFG_32B_MASK) ? 0 : 1;
+		banks = 2;
+	}
+
+	/* 0 => 11 address bits ... 2 => 13 address bits */
+	rows += 11;
+
+	/* 0 => 8 address bits ... 2 => 10 address bits */
+	cols += 8;
+
+	return 1 << (cols + rows + (is_32bits + 1) + banks);
+}
+
+void __init bcm63xx_cpu_init(void)
+{
+	unsigned int tmp, expected_cpu_id;
+	struct cpuinfo_mips *c = &current_cpu_data;
+
+	/* soc registers location depends on cpu type */
+	expected_cpu_id = 0;
+
+	switch (c->cputype) {
+	/*
+	 * BCM6338 as the same PrId as BCM3302 see arch/mips/kernel/cpu-probe.c
+	 */
+	case CPU_BCM3302:
+		expected_cpu_id = BCM6338_CPU_ID;
+		bcm63xx_regs_base = bcm96338_regs_base;
+		bcm63xx_irqs = bcm96338_irqs;
+		break;
+	case CPU_BCM6345:
+		expected_cpu_id = BCM6345_CPU_ID;
+		bcm63xx_regs_base = bcm96345_regs_base;
+		bcm63xx_irqs = bcm96345_irqs;
+		break;
+	case CPU_BCM6348:
+		expected_cpu_id = BCM6348_CPU_ID;
+		bcm63xx_regs_base = bcm96348_regs_base;
+		bcm63xx_irqs = bcm96348_irqs;
+		break;
+	case CPU_BCM6358:
+		expected_cpu_id = BCM6358_CPU_ID;
+		bcm63xx_regs_base = bcm96358_regs_base;
+		bcm63xx_irqs = bcm96358_irqs;
+		break;
+	}
+
+	/*
+	 * really early to panic, but delaying panic would not help since we
+	 * will never get any working console
+	 */
+	if (!expected_cpu_id)
+		panic("unsupported Broadcom CPU");
+
+	/*
+	 * bcm63xx_regs_base is set, we can access soc registers
+	 */
+
+	/* double check CPU type */
+	tmp = bcm_perf_readl(PERF_REV_REG);
+	bcm63xx_cpu_id = (tmp & REV_CHIPID_MASK) >> REV_CHIPID_SHIFT;
+	bcm63xx_cpu_rev = (tmp & REV_REVID_MASK) >> REV_REVID_SHIFT;
+
+	if (bcm63xx_cpu_id != expected_cpu_id)
+		panic("bcm63xx CPU id mismatch");
+
+	bcm63xx_cpu_freq = detect_cpu_clock();
+	bcm63xx_memory_size = detect_memory_size();
+
+	printk(KERN_INFO "Detected Broadcom 0x%04x CPU revision %02x\n",
+	       bcm63xx_cpu_id, bcm63xx_cpu_rev);
+	printk(KERN_INFO "CPU frequency is %u MHz\n",
+	       bcm63xx_cpu_freq / 1000000);
+	printk(KERN_INFO "%uMB of RAM installed\n",
+	       bcm63xx_memory_size >> 20);
+}
