commit 18836b48ebae20850631ee2916d0cdbb86df813d
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Thu Feb 21 10:56:42 2019 +0100

    MIPS: BCM63XX: provide DMA masks for ethernet devices
    
    The switch to the generic dma ops made dma masks mandatory, breaking
    devices having them not set. In case of bcm63xx, it broke ethernet with
    the following warning when trying to up the device:
    
    [    2.633123] ------------[ cut here ]------------
    [    2.637949] WARNING: CPU: 0 PID: 325 at ./include/linux/dma-mapping.h:516 bcm_enetsw_open+0x160/0xbbc
    [    2.647423] Modules linked in: gpio_button_hotplug
    [    2.652361] CPU: 0 PID: 325 Comm: ip Not tainted 4.19.16 #0
    [    2.658080] Stack : 80520000 804cd3ec 00000000 00000000 804ccc00 87085bdc 87d3f9d4 804f9a17
    [    2.666707]         8049cf18 00000145 80a942a0 00000204 80ac0000 10008400 87085b90 eb3d5ab7
    [    2.675325]         00000000 00000000 80ac0000 000022b0 00000000 00000000 00000007 00000000
    [    2.683954]         0000007a 80500000 0013b381 00000000 80000000 00000000 804a1664 80289878
    [    2.692572]         00000009 00000204 80ac0000 00000200 00000002 00000000 00000000 80a90000
    [    2.701191]         ...
    [    2.703701] Call Trace:
    [    2.706244] [<8001f3c8>] show_stack+0x58/0x100
    [    2.710840] [<800336e4>] __warn+0xe4/0x118
    [    2.715049] [<800337d4>] warn_slowpath_null+0x48/0x64
    [    2.720237] [<80289878>] bcm_enetsw_open+0x160/0xbbc
    [    2.725347] [<802d1d4c>] __dev_open+0xf8/0x16c
    [    2.729913] [<802d20cc>] __dev_change_flags+0x100/0x1c4
    [    2.735290] [<802d21b8>] dev_change_flags+0x28/0x70
    [    2.740326] [<803539e0>] devinet_ioctl+0x310/0x7b0
    [    2.745250] [<80355fd8>] inet_ioctl+0x1f8/0x224
    [    2.749939] [<802af290>] sock_ioctl+0x30c/0x488
    [    2.754632] [<80112b34>] do_vfs_ioctl+0x740/0x7dc
    [    2.759459] [<80112c20>] ksys_ioctl+0x50/0x94
    [    2.763955] [<800240b8>] syscall_common+0x34/0x58
    [    2.768782] ---[ end trace fb1a6b14d74e28b6 ]---
    [    2.773544] bcm63xx_enetsw bcm63xx_enetsw.0: cannot allocate rx ring 512
    
    Fix this by adding appropriate DMA masks for the platform devices.
    
    Fixes: f8c55dc6e828 ("MIPS: use generic dma noncoherent ops for simple noncoherent platforms")
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: stable@vger.kernel.org # v4.19+

diff --git a/arch/mips/bcm63xx/dev-enet.c b/arch/mips/bcm63xx/dev-enet.c
index 07b4c65a88a4..8e73d65f3480 100644
--- a/arch/mips/bcm63xx/dev-enet.c
+++ b/arch/mips/bcm63xx/dev-enet.c
@@ -70,6 +70,8 @@ static struct platform_device bcm63xx_enet_shared_device = {
 
 static int shared_device_registered;
 
+static u64 enet_dmamask = DMA_BIT_MASK(32);
+
 static struct resource enet0_res[] = {
 	{
 		.start		= -1, /* filled at runtime */
@@ -99,6 +101,8 @@ static struct platform_device bcm63xx_enet0_device = {
 	.resource	= enet0_res,
 	.dev		= {
 		.platform_data = &enet0_pd,
+		.dma_mask = &enet_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
 	},
 };
 
@@ -131,6 +135,8 @@ static struct platform_device bcm63xx_enet1_device = {
 	.resource	= enet1_res,
 	.dev		= {
 		.platform_data = &enet1_pd,
+		.dma_mask = &enet_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
 	},
 };
 
@@ -157,6 +163,8 @@ static struct platform_device bcm63xx_enetsw_device = {
 	.resource	= enetsw_res,
 	.dev		= {
 		.platform_data = &enetsw_pd,
+		.dma_mask = &enet_dmamask,
+		.coherent_dma_mask = DMA_BIT_MASK(32),
 	},
 };
 

commit 1942e482258d8cfec9606156cafc6fd1a871f4d5
Author: Jonas Gorski <jonas.gorski@gmail.com>
Date:   Sun Dec 17 17:02:53 2017 +0100

    bcm63xx_enet: use platform data for dma channel numbers
    
    To reduce the reliance on device ids, pass the dma channel numbers to
    the enet devices as platform data.
    
    Signed-off-by: Jonas Gorski <jonas.gorski@gmail.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/mips/bcm63xx/dev-enet.c b/arch/mips/bcm63xx/dev-enet.c
index e8284771d620..07b4c65a88a4 100644
--- a/arch/mips/bcm63xx/dev-enet.c
+++ b/arch/mips/bcm63xx/dev-enet.c
@@ -265,6 +265,14 @@ int __init bcm63xx_enet_register(int unit,
 		dpd->dma_chan_width = ENETDMA_CHAN_WIDTH;
 	}
 
+	if (unit == 0) {
+		dpd->rx_chan = 0;
+		dpd->tx_chan = 1;
+	} else {
+		dpd->rx_chan = 2;
+		dpd->tx_chan = 3;
+	}
+
 	ret = platform_device_register(pdev);
 	if (ret)
 		return ret;

commit e7101c2ae2a6a2b10e9bb256205dfe9100840777
Author: Jonas Gorski <jogo@openwrt.org>
Date:   Tue Jul 8 16:53:22 2014 +0200

    MIPS: BCM63xx: Remove !RUNTIME_DETECT usage from enet code
    
    Cc: linux-mips@linux-mips.org
    Cc: John Crispin <blogic@openwrt.org>
    Cc: Maxime Bizon <mbizon@freebox.fr>
    Cc: Florian Fainelli <florian@openwrt.org>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/7270/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/dev-enet.c b/arch/mips/bcm63xx/dev-enet.c
index 52bc01df9bfe..e8284771d620 100644
--- a/arch/mips/bcm63xx/dev-enet.c
+++ b/arch/mips/bcm63xx/dev-enet.c
@@ -14,7 +14,6 @@
 #include <bcm63xx_io.h>
 #include <bcm63xx_regs.h>
 
-#ifdef BCMCPU_RUNTIME_DETECT
 static const unsigned long bcm6348_regs_enetdmac[] = {
 	[ENETDMAC_CHANCFG]	= ENETDMAC_CHANCFG_REG,
 	[ENETDMAC_IR]		= ENETDMAC_IR_REG,
@@ -43,9 +42,6 @@ static __init void bcm63xx_enetdmac_regs_init(void)
 	else
 		bcm63xx_regs_enetdmac = bcm6348_regs_enetdmac;
 }
-#else
-static __init void bcm63xx_enetdmac_regs_init(void) { }
-#endif
 
 static struct resource shared_res[] = {
 	{

commit 3dc6475c0c9e55ac7f053ad6b8b398e779954545
Author: Florian Fainelli <florian@openwrt.org>
Date:   Wed Jun 12 20:53:05 2013 +0100

    bcm63xx_enet: add support Broadcom BCM6345 Ethernet
    
    This patch adds support for the Broadcom BCM6345 SoC Ethernet. BCM6345
    has a slightly different and older DMA engine which requires the
    following modifications:
    
    - the width of the DMA channels on BCM6345 is 64 bytes vs 16 bytes,
      which means that the helpers enet_dma{c,s} need to account for this
      channel width and we can no longer use macros
    
    - BCM6345 DMA engine does not have any internal SRAM for transfering
      buffers
    
    - BCM6345 buffer allocation and flow control is not per-channel but
      global (done in RSET_ENETDMA)
    
    - the DMA engine bits are right-shifted by 3 compared to other DMA
      generations
    
    - the DMA enable/interrupt masks are a little different (we need to
      enabled more bits for 6345)
    
    - some register have the same meaning but are offsetted in the ENET_DMAC
      space so a lookup table is required to return the proper offset
    
    The MAC itself is identical and requires no modifications to work.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/mips/bcm63xx/dev-enet.c b/arch/mips/bcm63xx/dev-enet.c
index 6cbaee0f6d70..52bc01df9bfe 100644
--- a/arch/mips/bcm63xx/dev-enet.c
+++ b/arch/mips/bcm63xx/dev-enet.c
@@ -9,10 +9,44 @@
 #include <linux/init.h>
 #include <linux/kernel.h>
 #include <linux/platform_device.h>
+#include <linux/export.h>
 #include <bcm63xx_dev_enet.h>
 #include <bcm63xx_io.h>
 #include <bcm63xx_regs.h>
 
+#ifdef BCMCPU_RUNTIME_DETECT
+static const unsigned long bcm6348_regs_enetdmac[] = {
+	[ENETDMAC_CHANCFG]	= ENETDMAC_CHANCFG_REG,
+	[ENETDMAC_IR]		= ENETDMAC_IR_REG,
+	[ENETDMAC_IRMASK]	= ENETDMAC_IRMASK_REG,
+	[ENETDMAC_MAXBURST]	= ENETDMAC_MAXBURST_REG,
+};
+
+static const unsigned long bcm6345_regs_enetdmac[] = {
+	[ENETDMAC_CHANCFG]	= ENETDMA_6345_CHANCFG_REG,
+	[ENETDMAC_IR]		= ENETDMA_6345_IR_REG,
+	[ENETDMAC_IRMASK]	= ENETDMA_6345_IRMASK_REG,
+	[ENETDMAC_MAXBURST]	= ENETDMA_6345_MAXBURST_REG,
+	[ENETDMAC_BUFALLOC]	= ENETDMA_6345_BUFALLOC_REG,
+	[ENETDMAC_RSTART]	= ENETDMA_6345_RSTART_REG,
+	[ENETDMAC_FC]		= ENETDMA_6345_FC_REG,
+	[ENETDMAC_LEN]		= ENETDMA_6345_LEN_REG,
+};
+
+const unsigned long *bcm63xx_regs_enetdmac;
+EXPORT_SYMBOL(bcm63xx_regs_enetdmac);
+
+static __init void bcm63xx_enetdmac_regs_init(void)
+{
+	if (BCMCPU_IS_6345())
+		bcm63xx_regs_enetdmac = bcm6345_regs_enetdmac;
+	else
+		bcm63xx_regs_enetdmac = bcm6348_regs_enetdmac;
+}
+#else
+static __init void bcm63xx_enetdmac_regs_init(void) { }
+#endif
+
 static struct resource shared_res[] = {
 	{
 		.start		= -1, /* filled at runtime */
@@ -137,12 +171,19 @@ static int __init register_shared(void)
 	if (shared_device_registered)
 		return 0;
 
+	bcm63xx_enetdmac_regs_init();
+
 	shared_res[0].start = bcm63xx_regset_address(RSET_ENETDMA);
 	shared_res[0].end = shared_res[0].start;
-	shared_res[0].end += (RSET_ENETDMA_SIZE)  - 1;
+	if (BCMCPU_IS_6345())
+		shared_res[0].end += (RSET_6345_ENETDMA_SIZE) - 1;
+	else
+		shared_res[0].end += (RSET_ENETDMA_SIZE)  - 1;
 
 	if (BCMCPU_IS_6328() || BCMCPU_IS_6362() || BCMCPU_IS_6368())
 		chan_count = 32;
+	else if (BCMCPU_IS_6345())
+		chan_count = 8;
 	else
 		chan_count = 16;
 
@@ -172,7 +213,7 @@ int __init bcm63xx_enet_register(int unit,
 	if (unit > 1)
 		return -ENODEV;
 
-	if (unit == 1 && BCMCPU_IS_6338())
+	if (unit == 1 && (BCMCPU_IS_6338() || BCMCPU_IS_6345()))
 		return -ENODEV;
 
 	ret = register_shared();
@@ -213,6 +254,21 @@ int __init bcm63xx_enet_register(int unit,
 		dpd->phy_interrupt = bcm63xx_get_irq_number(IRQ_ENET_PHY);
 	}
 
+	dpd->dma_chan_en_mask = ENETDMAC_CHANCFG_EN_MASK;
+	dpd->dma_chan_int_mask = ENETDMAC_IR_PKTDONE_MASK;
+	if (BCMCPU_IS_6345()) {
+		dpd->dma_chan_en_mask |= ENETDMAC_CHANCFG_CHAINING_MASK;
+		dpd->dma_chan_en_mask |= ENETDMAC_CHANCFG_WRAP_EN_MASK;
+		dpd->dma_chan_en_mask |= ENETDMAC_CHANCFG_FLOWC_EN_MASK;
+		dpd->dma_chan_int_mask |= ENETDMA_IR_BUFDONE_MASK;
+		dpd->dma_chan_int_mask |= ENETDMA_IR_NOTOWNER_MASK;
+		dpd->dma_chan_width = ENETDMA_6345_CHAN_WIDTH;
+		dpd->dma_desc_shift = ENETDMA_6345_DESC_SHIFT;
+	} else {
+		dpd->dma_has_sram = true;
+		dpd->dma_chan_width = ENETDMA_CHAN_WIDTH;
+	}
+
 	ret = platform_device_register(pdev);
 	if (ret)
 		return ret;
@@ -246,6 +302,11 @@ bcm63xx_enetsw_register(const struct bcm63xx_enetsw_platform_data *pd)
 	else if (BCMCPU_IS_6362() || BCMCPU_IS_6368())
 		enetsw_pd.num_ports = ENETSW_PORTS_6368;
 
+	enetsw_pd.dma_has_sram = true;
+	enetsw_pd.dma_chan_width = ENETDMA_CHAN_WIDTH;
+	enetsw_pd.dma_chan_en_mask = ENETDMAC_CHANCFG_EN_MASK;
+	enetsw_pd.dma_chan_int_mask = ENETDMAC_IR_PKTDONE_MASK;
+
 	ret = platform_device_register(&bcm63xx_enetsw_device);
 	if (ret)
 		return ret;

commit 6f00a0229627ca189529cad3f9154ac2f9e5c7db
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Tue Jun 4 22:53:35 2013 +0100

    bcm63xx_enet: add support for Broadcom BCM63xx integrated gigabit switch
    
    Newer Broadcom BCM63xx SoCs: 6328, 6362 and 6368 have an integrated switch
    which needs to be driven slightly differently from the traditional
    external switches. This patch introduces changes in arch/mips/bcm63xx in order
    to:
    
    - register a bcm63xx_enetsw driver instead of bcm63xx_enet driver
    - update DMA channels configuration & state RAM base addresses
    - add a new platform data configuration knob to define the number of
      ports per switch/device and force link on some ports
    - define the required switch registers
    
    On the driver side, the following changes are required:
    
    - the switch ports need to be polled to ensure the link is up and
      running and RX/TX can properly work
    - basic switch configuration needs to be performed for the switch to
      forward packets to the CPU
    - update the MIB counters since the integrated
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/mips/bcm63xx/dev-enet.c b/arch/mips/bcm63xx/dev-enet.c
index df5bf6686942..6cbaee0f6d70 100644
--- a/arch/mips/bcm63xx/dev-enet.c
+++ b/arch/mips/bcm63xx/dev-enet.c
@@ -104,6 +104,64 @@ static struct platform_device bcm63xx_enet1_device = {
 	},
 };
 
+static struct resource enetsw_res[] = {
+	{
+		/* start & end filled at runtime */
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		/* start filled at runtime */
+		.flags		= IORESOURCE_IRQ,
+	},
+	{
+		/* start filled at runtime */
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct bcm63xx_enetsw_platform_data enetsw_pd;
+
+static struct platform_device bcm63xx_enetsw_device = {
+	.name		= "bcm63xx_enetsw",
+	.num_resources	= ARRAY_SIZE(enetsw_res),
+	.resource	= enetsw_res,
+	.dev		= {
+		.platform_data = &enetsw_pd,
+	},
+};
+
+static int __init register_shared(void)
+{
+	int ret, chan_count;
+
+	if (shared_device_registered)
+		return 0;
+
+	shared_res[0].start = bcm63xx_regset_address(RSET_ENETDMA);
+	shared_res[0].end = shared_res[0].start;
+	shared_res[0].end += (RSET_ENETDMA_SIZE)  - 1;
+
+	if (BCMCPU_IS_6328() || BCMCPU_IS_6362() || BCMCPU_IS_6368())
+		chan_count = 32;
+	else
+		chan_count = 16;
+
+	shared_res[1].start = bcm63xx_regset_address(RSET_ENETDMAC);
+	shared_res[1].end = shared_res[1].start;
+	shared_res[1].end += RSET_ENETDMAC_SIZE(chan_count)  - 1;
+
+	shared_res[2].start = bcm63xx_regset_address(RSET_ENETDMAS);
+	shared_res[2].end = shared_res[2].start;
+	shared_res[2].end += RSET_ENETDMAS_SIZE(chan_count)  - 1;
+
+	ret = platform_device_register(&bcm63xx_enet_shared_device);
+	if (ret)
+		return ret;
+	shared_device_registered = 1;
+
+	return 0;
+}
+
 int __init bcm63xx_enet_register(int unit,
 				 const struct bcm63xx_enet_platform_data *pd)
 {
@@ -117,24 +175,9 @@ int __init bcm63xx_enet_register(int unit,
 	if (unit == 1 && BCMCPU_IS_6338())
 		return -ENODEV;
 
-	if (!shared_device_registered) {
-		shared_res[0].start = bcm63xx_regset_address(RSET_ENETDMA);
-		shared_res[0].end = shared_res[0].start;
-		shared_res[0].end += (RSET_ENETDMA_SIZE)  - 1;
-
-		shared_res[1].start = bcm63xx_regset_address(RSET_ENETDMAC);
-		shared_res[1].end = shared_res[1].start;
-		shared_res[1].end += RSET_ENETDMAC_SIZE(16)  - 1;
-
-		shared_res[2].start = bcm63xx_regset_address(RSET_ENETDMAS);
-		shared_res[2].end = shared_res[2].start;
-		shared_res[2].end += RSET_ENETDMAS_SIZE(16)  - 1;
-
-		ret = platform_device_register(&bcm63xx_enet_shared_device);
-		if (ret)
-			return ret;
-		shared_device_registered = 1;
-	}
+	ret = register_shared();
+	if (ret)
+		return ret;
 
 	if (unit == 0) {
 		enet0_res[0].start = bcm63xx_regset_address(RSET_ENET0);
@@ -175,3 +218,37 @@ int __init bcm63xx_enet_register(int unit,
 		return ret;
 	return 0;
 }
+
+int __init
+bcm63xx_enetsw_register(const struct bcm63xx_enetsw_platform_data *pd)
+{
+	int ret;
+
+	if (!BCMCPU_IS_6328() && !BCMCPU_IS_6362() && !BCMCPU_IS_6368())
+		return -ENODEV;
+
+	ret = register_shared();
+	if (ret)
+		return ret;
+
+	enetsw_res[0].start = bcm63xx_regset_address(RSET_ENETSW);
+	enetsw_res[0].end = enetsw_res[0].start;
+	enetsw_res[0].end += RSET_ENETSW_SIZE - 1;
+	enetsw_res[1].start = bcm63xx_get_irq_number(IRQ_ENETSW_RXDMA0);
+	enetsw_res[2].start = bcm63xx_get_irq_number(IRQ_ENETSW_TXDMA0);
+	if (!enetsw_res[2].start)
+		enetsw_res[2].start = -1;
+
+	memcpy(bcm63xx_enetsw_device.dev.platform_data, pd, sizeof(*pd));
+
+	if (BCMCPU_IS_6328())
+		enetsw_pd.num_ports = ENETSW_PORTS_6328;
+	else if (BCMCPU_IS_6362() || BCMCPU_IS_6368())
+		enetsw_pd.num_ports = ENETSW_PORTS_6368;
+
+	ret = platform_device_register(&bcm63xx_enetsw_device);
+	if (ret)
+		return ret;
+
+	return 0;
+}

commit 0ae99b5fede6f3a8d252d50bb4aba29544295219
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Tue Jun 4 22:53:34 2013 +0100

    bcm63xx_enet: split DMA channel register accesses
    
    The current bcm63xx_enet driver always uses bcmenet_shared_base whenever
    it needs to access DMA channel configuration space or access the DMA
    channel state RAM. Split these register in 3 parts to be more accurate:
    
    - global DMA configuration
    - per DMA channel configuration space
    - per DMA channel state RAM space
    
    This is preliminary to support new chips where the global DMA
    configuration remains the same, but there is a varying number of DMA
    channels located at a different memory offset.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>

diff --git a/arch/mips/bcm63xx/dev-enet.c b/arch/mips/bcm63xx/dev-enet.c
index 39c23366c5c7..df5bf6686942 100644
--- a/arch/mips/bcm63xx/dev-enet.c
+++ b/arch/mips/bcm63xx/dev-enet.c
@@ -19,6 +19,16 @@ static struct resource shared_res[] = {
 		.end		= -1, /* filled at runtime */
 		.flags		= IORESOURCE_MEM,
 	},
+	{
+		.start		= -1, /* filled at runtime */
+		.end		= -1, /* filled at runtime */
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= -1, /* filled at runtime */
+		.end		= -1, /* filled at runtime */
+		.flags		= IORESOURCE_MEM,
+	},
 };
 
 static struct platform_device bcm63xx_enet_shared_device = {
@@ -110,10 +120,15 @@ int __init bcm63xx_enet_register(int unit,
 	if (!shared_device_registered) {
 		shared_res[0].start = bcm63xx_regset_address(RSET_ENETDMA);
 		shared_res[0].end = shared_res[0].start;
-		if (BCMCPU_IS_6338())
-			shared_res[0].end += (RSET_ENETDMA_SIZE / 2)  - 1;
-		else
-			shared_res[0].end += (RSET_ENETDMA_SIZE)  - 1;
+		shared_res[0].end += (RSET_ENETDMA_SIZE)  - 1;
+
+		shared_res[1].start = bcm63xx_regset_address(RSET_ENETDMAC);
+		shared_res[1].end = shared_res[1].start;
+		shared_res[1].end += RSET_ENETDMAC_SIZE(16)  - 1;
+
+		shared_res[2].start = bcm63xx_regset_address(RSET_ENETDMAS);
+		shared_res[2].end = shared_res[2].start;
+		shared_res[2].end += RSET_ENETDMAS_SIZE(16)  - 1;
 
 		ret = platform_device_register(&bcm63xx_enet_shared_device);
 		if (ret)

commit 7f13f65e61f1deed77c5c335ed0fa4d08f69e608
Author: Florian Fainelli <florian@openwrt.org>
Date:   Wed Jul 21 22:59:26 2010 +0200

    MIPS: BCM63xx: Prevent second enet registration on BCM6338
    
    This SoC has only one ethernet MAC, so prevent registration of a second one.
    
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    To: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/1482/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/dev-enet.c b/arch/mips/bcm63xx/dev-enet.c
index 9f544badd0b4..39c23366c5c7 100644
--- a/arch/mips/bcm63xx/dev-enet.c
+++ b/arch/mips/bcm63xx/dev-enet.c
@@ -104,6 +104,9 @@ int __init bcm63xx_enet_register(int unit,
 	if (unit > 1)
 		return -ENODEV;
 
+	if (unit == 1 && BCMCPU_IS_6338())
+		return -ENODEV;
+
 	if (!shared_device_registered) {
 		shared_res[0].start = bcm63xx_regset_address(RSET_ENETDMA);
 		shared_res[0].end = shared_res[0].start;

commit 9b1fc55a05006523bced65f4d99f7072831ff56a
Author: Maxime Bizon <mbizon@freebox.fr>
Date:   Tue Aug 18 13:23:40 2009 +0100

    MIPS: BCM63xx: Add integrated ethernet mac support.
    
    Signed-off-by: Maxime Bizon <mbizon@freebox.fr>
    Signed-off-by: Florian Fainelli <florian@openwrt.org>
    Signed-off-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/bcm63xx/dev-enet.c b/arch/mips/bcm63xx/dev-enet.c
new file mode 100644
index 000000000000..9f544badd0b4
--- /dev/null
+++ b/arch/mips/bcm63xx/dev-enet.c
@@ -0,0 +1,159 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 2008 Maxime Bizon <mbizon@freebox.fr>
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <bcm63xx_dev_enet.h>
+#include <bcm63xx_io.h>
+#include <bcm63xx_regs.h>
+
+static struct resource shared_res[] = {
+	{
+		.start		= -1, /* filled at runtime */
+		.end		= -1, /* filled at runtime */
+		.flags		= IORESOURCE_MEM,
+	},
+};
+
+static struct platform_device bcm63xx_enet_shared_device = {
+	.name		= "bcm63xx_enet_shared",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(shared_res),
+	.resource	= shared_res,
+};
+
+static int shared_device_registered;
+
+static struct resource enet0_res[] = {
+	{
+		.start		= -1, /* filled at runtime */
+		.end		= -1, /* filled at runtime */
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= -1, /* filled at runtime */
+		.flags		= IORESOURCE_IRQ,
+	},
+	{
+		.start		= -1, /* filled at runtime */
+		.flags		= IORESOURCE_IRQ,
+	},
+	{
+		.start		= -1, /* filled at runtime */
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct bcm63xx_enet_platform_data enet0_pd;
+
+static struct platform_device bcm63xx_enet0_device = {
+	.name		= "bcm63xx_enet",
+	.id		= 0,
+	.num_resources	= ARRAY_SIZE(enet0_res),
+	.resource	= enet0_res,
+	.dev		= {
+		.platform_data = &enet0_pd,
+	},
+};
+
+static struct resource enet1_res[] = {
+	{
+		.start		= -1, /* filled at runtime */
+		.end		= -1, /* filled at runtime */
+		.flags		= IORESOURCE_MEM,
+	},
+	{
+		.start		= -1, /* filled at runtime */
+		.flags		= IORESOURCE_IRQ,
+	},
+	{
+		.start		= -1, /* filled at runtime */
+		.flags		= IORESOURCE_IRQ,
+	},
+	{
+		.start		= -1, /* filled at runtime */
+		.flags		= IORESOURCE_IRQ,
+	},
+};
+
+static struct bcm63xx_enet_platform_data enet1_pd;
+
+static struct platform_device bcm63xx_enet1_device = {
+	.name		= "bcm63xx_enet",
+	.id		= 1,
+	.num_resources	= ARRAY_SIZE(enet1_res),
+	.resource	= enet1_res,
+	.dev		= {
+		.platform_data = &enet1_pd,
+	},
+};
+
+int __init bcm63xx_enet_register(int unit,
+				 const struct bcm63xx_enet_platform_data *pd)
+{
+	struct platform_device *pdev;
+	struct bcm63xx_enet_platform_data *dpd;
+	int ret;
+
+	if (unit > 1)
+		return -ENODEV;
+
+	if (!shared_device_registered) {
+		shared_res[0].start = bcm63xx_regset_address(RSET_ENETDMA);
+		shared_res[0].end = shared_res[0].start;
+		if (BCMCPU_IS_6338())
+			shared_res[0].end += (RSET_ENETDMA_SIZE / 2)  - 1;
+		else
+			shared_res[0].end += (RSET_ENETDMA_SIZE)  - 1;
+
+		ret = platform_device_register(&bcm63xx_enet_shared_device);
+		if (ret)
+			return ret;
+		shared_device_registered = 1;
+	}
+
+	if (unit == 0) {
+		enet0_res[0].start = bcm63xx_regset_address(RSET_ENET0);
+		enet0_res[0].end = enet0_res[0].start;
+		enet0_res[0].end += RSET_ENET_SIZE - 1;
+		enet0_res[1].start = bcm63xx_get_irq_number(IRQ_ENET0);
+		enet0_res[2].start = bcm63xx_get_irq_number(IRQ_ENET0_RXDMA);
+		enet0_res[3].start = bcm63xx_get_irq_number(IRQ_ENET0_TXDMA);
+		pdev = &bcm63xx_enet0_device;
+	} else {
+		enet1_res[0].start = bcm63xx_regset_address(RSET_ENET1);
+		enet1_res[0].end = enet1_res[0].start;
+		enet1_res[0].end += RSET_ENET_SIZE - 1;
+		enet1_res[1].start = bcm63xx_get_irq_number(IRQ_ENET1);
+		enet1_res[2].start = bcm63xx_get_irq_number(IRQ_ENET1_RXDMA);
+		enet1_res[3].start = bcm63xx_get_irq_number(IRQ_ENET1_TXDMA);
+		pdev = &bcm63xx_enet1_device;
+	}
+
+	/* copy given platform data */
+	dpd = pdev->dev.platform_data;
+	memcpy(dpd, pd, sizeof(*pd));
+
+	/* adjust them in case internal phy is used */
+	if (dpd->use_internal_phy) {
+
+		/* internal phy only exists for enet0 */
+		if (unit == 1)
+			return -ENODEV;
+
+		dpd->phy_id = 1;
+		dpd->has_phy_interrupt = 1;
+		dpd->phy_interrupt = bcm63xx_get_irq_number(IRQ_ENET_PHY);
+	}
+
+	ret = platform_device_register(pdev);
+	if (ret)
+		return ret;
+	return 0;
+}
