commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/irq_txx9.c b/arch/mips/kernel/irq_txx9.c
index b0c55b50218e..ab00e490482f 100644
--- a/arch/mips/kernel/irq_txx9.c
+++ b/arch/mips/kernel/irq_txx9.c
@@ -1,12 +1,12 @@
 /*
  * Based on linux/arch/mips/jmr3927/rbhma3100/irq.c,
- *          linux/arch/mips/tx4927/common/tx4927_irq.c,
- *          linux/arch/mips/tx4938/common/irq.c
+ *	    linux/arch/mips/tx4927/common/tx4927_irq.c,
+ *	    linux/arch/mips/tx4938/common/irq.c
  *
  * Copyright 2001, 2003-2005 MontaVista Software Inc.
  * Author: MontaVista Software, Inc.
- *         ahennessy@mvista.com
- *         source@mvista.com
+ *	   ahennessy@mvista.com
+ *	   source@mvista.com
  * Copyright (C) 2000-2001 Toshiba Corporation
  *
  * This file is subject to the terms and conditions of the GNU General Public
@@ -122,7 +122,7 @@ static int txx9_irq_set_type(struct irq_data *d, unsigned int flow_type)
 	switch (flow_type & IRQF_TRIGGER_MASK) {
 	case IRQF_TRIGGER_RISING:	mode = TXx9_IRCR_UP;	break;
 	case IRQF_TRIGGER_FALLING:	mode = TXx9_IRCR_DOWN;	break;
-	case IRQF_TRIGGER_HIGH:	mode = TXx9_IRCR_HIGH;	break;
+	case IRQF_TRIGGER_HIGH: mode = TXx9_IRCR_HIGH;	break;
 	case IRQF_TRIGGER_LOW:	mode = TXx9_IRCR_LOW;	break;
 	default:
 		return -EINVAL;

commit e4ec7989b4e55d9275ebac66230b7dac6dcb1fae
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun Mar 27 15:19:28 2011 +0200

    MIPS: Convert the irq functions to the new names
    
    Scripted with coccinelle.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/mips/kernel/irq_txx9.c b/arch/mips/kernel/irq_txx9.c
index 526e1581549a..b0c55b50218e 100644
--- a/arch/mips/kernel/irq_txx9.c
+++ b/arch/mips/kernel/irq_txx9.c
@@ -154,8 +154,8 @@ void __init txx9_irq_init(unsigned long baseaddr)
 	for (i = 0; i < TXx9_MAX_IR; i++) {
 		txx9irq[i].level = 4; /* middle level */
 		txx9irq[i].mode = TXx9_IRCR_LOW;
-		set_irq_chip_and_handler(TXX9_IRQ_BASE + i,
-					 &txx9_irq_chip, handle_level_irq);
+		irq_set_chip_and_handler(TXX9_IRQ_BASE + i, &txx9_irq_chip,
+					 handle_level_irq);
 	}
 
 	/* mask all IRC interrupts */

commit 0e9c4ec61a80a2058a600c9ac8ad3b15574b1201
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed Mar 23 21:09:02 2011 +0000

    MIPS: TXx9: Convert core to new irq_chip functions
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    To: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2192/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/irq_txx9.c b/arch/mips/kernel/irq_txx9.c
index 95a96f69172d..526e1581549a 100644
--- a/arch/mips/kernel/irq_txx9.c
+++ b/arch/mips/kernel/irq_txx9.c
@@ -63,9 +63,9 @@ static struct {
 	unsigned char mode;
 } txx9irq[TXx9_MAX_IR] __read_mostly;
 
-static void txx9_irq_unmask(unsigned int irq)
+static void txx9_irq_unmask(struct irq_data *d)
 {
-	unsigned int irq_nr = irq - TXX9_IRQ_BASE;
+	unsigned int irq_nr = d->irq - TXX9_IRQ_BASE;
 	u32 __iomem *ilrp = &txx9_ircptr->ilr[(irq_nr % 16 ) / 2];
 	int ofs = irq_nr / 16 * 16 + (irq_nr & 1) * 8;
 
@@ -79,9 +79,9 @@ static void txx9_irq_unmask(unsigned int irq)
 #endif
 }
 
-static inline void txx9_irq_mask(unsigned int irq)
+static inline void txx9_irq_mask(struct irq_data *d)
 {
-	unsigned int irq_nr = irq - TXX9_IRQ_BASE;
+	unsigned int irq_nr = d->irq - TXX9_IRQ_BASE;
 	u32 __iomem *ilrp = &txx9_ircptr->ilr[(irq_nr % 16) / 2];
 	int ofs = irq_nr / 16 * 16 + (irq_nr & 1) * 8;
 
@@ -99,19 +99,19 @@ static inline void txx9_irq_mask(unsigned int irq)
 #endif
 }
 
-static void txx9_irq_mask_ack(unsigned int irq)
+static void txx9_irq_mask_ack(struct irq_data *d)
 {
-	unsigned int irq_nr = irq - TXX9_IRQ_BASE;
+	unsigned int irq_nr = d->irq - TXX9_IRQ_BASE;
 
-	txx9_irq_mask(irq);
+	txx9_irq_mask(d);
 	/* clear edge detection */
 	if (unlikely(TXx9_IRCR_EDGE(txx9irq[irq_nr].mode)))
 		__raw_writel(TXx9_IRSCR_EIClrE | irq_nr, &txx9_ircptr->scr);
 }
 
-static int txx9_irq_set_type(unsigned int irq, unsigned int flow_type)
+static int txx9_irq_set_type(struct irq_data *d, unsigned int flow_type)
 {
-	unsigned int irq_nr = irq - TXX9_IRQ_BASE;
+	unsigned int irq_nr = d->irq - TXX9_IRQ_BASE;
 	u32 cr;
 	u32 __iomem *crp;
 	int ofs;
@@ -139,11 +139,11 @@ static int txx9_irq_set_type(unsigned int irq, unsigned int flow_type)
 
 static struct irq_chip txx9_irq_chip = {
 	.name		= "TXX9",
-	.ack		= txx9_irq_mask_ack,
-	.mask		= txx9_irq_mask,
-	.mask_ack	= txx9_irq_mask_ack,
-	.unmask		= txx9_irq_unmask,
-	.set_type	= txx9_irq_set_type,
+	.irq_ack	= txx9_irq_mask_ack,
+	.irq_mask	= txx9_irq_mask,
+	.irq_mask_ack	= txx9_irq_mask_ack,
+	.irq_unmask	= txx9_irq_unmask,
+	.irq_set_type	= txx9_irq_set_type,
 };
 
 void __init txx9_irq_init(unsigned long baseaddr)

commit ca4d3e6746bdcfccb517349bce2d2c5b5614fb6f
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 7 14:08:54 2010 +0100

    MIPS: Add missing #inclusions of <linux/irq.h>
    
    Add missing #inclusions of <linux/irq.h> to a whole bunch of files that should
    really include it.  Note that this can replace #inclusions of <asm/irq.h>.
    
    This is required for the patch to sort out irqflags handling function naming to
    compile on MIPS.
    
    The problem is that these files require access to things like setup_irq() -
    which isn't available by #including <linux/interrupt.h>
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/irq_txx9.c b/arch/mips/kernel/irq_txx9.c
index 9b78029bea70..95a96f69172d 100644
--- a/arch/mips/kernel/irq_txx9.c
+++ b/arch/mips/kernel/irq_txx9.c
@@ -16,6 +16,7 @@
 #include <linux/init.h>
 #include <linux/interrupt.h>
 #include <linux/types.h>
+#include <linux/irq.h>
 #include <asm/txx9irq.h>
 
 struct txx9_irc_reg {

commit 49316cbf0a9875f102f98dc8b7c80cfa142e33cf
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Jul 6 09:13:17 2009 +0100

    MIPS: Eleminate filenames from comments
    
    They tend to get not updated when files are moved around or copied and
    lack any obvious use.  While at it zap some only too obvious comments and
    as per Shinya's suggestion, add a copyright header to extable.c.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
    Acked-by: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>

diff --git a/arch/mips/kernel/irq_txx9.c b/arch/mips/kernel/irq_txx9.c
index a4d1462c27f7..9b78029bea70 100644
--- a/arch/mips/kernel/irq_txx9.c
+++ b/arch/mips/kernel/irq_txx9.c
@@ -1,6 +1,4 @@
 /*
- * linux/arch/mips/kernel/irq_txx9.c
- *
  * Based on linux/arch/mips/jmr3927/rbhma3100/irq.c,
  *          linux/arch/mips/tx4927/common/tx4927_irq.c,
  *          linux/arch/mips/tx4938/common/irq.c

commit 5d3fdeacee5d071a5c3d674231bf00cfa5d35a7a
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Aug 3 23:33:38 2007 +0900

    [MIPS] Remove dead code from irq_txx9.c
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/irq_txx9.c b/arch/mips/kernel/irq_txx9.c
index 172e14b461df..a4d1462c27f7 100644
--- a/arch/mips/kernel/irq_txx9.c
+++ b/arch/mips/kernel/irq_txx9.c
@@ -105,13 +105,9 @@ static void txx9_irq_mask_ack(unsigned int irq)
 	unsigned int irq_nr = irq - TXX9_IRQ_BASE;
 
 	txx9_irq_mask(irq);
-	if (TXx9_IRCR_EDGE(txx9irq[irq_nr].mode)) {
-		/* clear edge detection */
-		u32 cr = __raw_readl(&txx9_ircptr->cr[irq_nr / 8]);
-		cr = (cr >> ((irq_nr & (8 - 1)) * 2)) & 3;
-		__raw_writel(TXx9_IRSCR_EIClrE | irq_nr,
-			     &txx9_ircptr->scr);
-	}
+	/* clear edge detection */
+	if (unlikely(TXx9_IRCR_EDGE(txx9irq[irq_nr].mode)))
+		__raw_writel(TXx9_IRSCR_EIClrE | irq_nr, &txx9_ircptr->scr);
 }
 
 static int txx9_irq_set_type(unsigned int irq, unsigned int flow_type)

commit 8420fd00e88ef4f6082866aa151bc753b006b3b6
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Aug 2 23:35:53 2007 +0900

    [MIPS] The irq_chip for TX39/TX49 SoCs
    
    Add generic irq_chip for TX39/TX49 SoCs.  This can be replace
    jmr3927_irq_irc, tx4927_irq_pic_type and tx4938_irq_pic_type.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/irq_txx9.c b/arch/mips/kernel/irq_txx9.c
new file mode 100644
index 000000000000..172e14b461df
--- /dev/null
+++ b/arch/mips/kernel/irq_txx9.c
@@ -0,0 +1,196 @@
+/*
+ * linux/arch/mips/kernel/irq_txx9.c
+ *
+ * Based on linux/arch/mips/jmr3927/rbhma3100/irq.c,
+ *          linux/arch/mips/tx4927/common/tx4927_irq.c,
+ *          linux/arch/mips/tx4938/common/irq.c
+ *
+ * Copyright 2001, 2003-2005 MontaVista Software Inc.
+ * Author: MontaVista Software, Inc.
+ *         ahennessy@mvista.com
+ *         source@mvista.com
+ * Copyright (C) 2000-2001 Toshiba Corporation
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <asm/txx9irq.h>
+
+struct txx9_irc_reg {
+	u32 cer;
+	u32 cr[2];
+	u32 unused0;
+	u32 ilr[8];
+	u32 unused1[4];
+	u32 imr;
+	u32 unused2[7];
+	u32 scr;
+	u32 unused3[7];
+	u32 ssr;
+	u32 unused4[7];
+	u32 csr;
+};
+
+/* IRCER : Int. Control Enable */
+#define TXx9_IRCER_ICE	0x00000001
+
+/* IRCR : Int. Control */
+#define TXx9_IRCR_LOW	0x00000000
+#define TXx9_IRCR_HIGH	0x00000001
+#define TXx9_IRCR_DOWN	0x00000002
+#define TXx9_IRCR_UP	0x00000003
+#define TXx9_IRCR_EDGE(cr)	((cr) & 0x00000002)
+
+/* IRSCR : Int. Status Control */
+#define TXx9_IRSCR_EIClrE	0x00000100
+#define TXx9_IRSCR_EIClr_MASK	0x0000000f
+
+/* IRCSR : Int. Current Status */
+#define TXx9_IRCSR_IF	0x00010000
+#define TXx9_IRCSR_ILV_MASK	0x00000700
+#define TXx9_IRCSR_IVL_MASK	0x0000001f
+
+#define irc_dlevel	0
+#define irc_elevel	1
+
+static struct txx9_irc_reg __iomem *txx9_ircptr __read_mostly;
+
+static struct {
+	unsigned char level;
+	unsigned char mode;
+} txx9irq[TXx9_MAX_IR] __read_mostly;
+
+static void txx9_irq_unmask(unsigned int irq)
+{
+	unsigned int irq_nr = irq - TXX9_IRQ_BASE;
+	u32 __iomem *ilrp = &txx9_ircptr->ilr[(irq_nr % 16 ) / 2];
+	int ofs = irq_nr / 16 * 16 + (irq_nr & 1) * 8;
+
+	__raw_writel((__raw_readl(ilrp) & ~(0xff << ofs))
+		     | (txx9irq[irq_nr].level << ofs),
+		     ilrp);
+#ifdef CONFIG_CPU_TX39XX
+	/* update IRCSR */
+	__raw_writel(0, &txx9_ircptr->imr);
+	__raw_writel(irc_elevel, &txx9_ircptr->imr);
+#endif
+}
+
+static inline void txx9_irq_mask(unsigned int irq)
+{
+	unsigned int irq_nr = irq - TXX9_IRQ_BASE;
+	u32 __iomem *ilrp = &txx9_ircptr->ilr[(irq_nr % 16) / 2];
+	int ofs = irq_nr / 16 * 16 + (irq_nr & 1) * 8;
+
+	__raw_writel((__raw_readl(ilrp) & ~(0xff << ofs))
+		     | (irc_dlevel << ofs),
+		     ilrp);
+#ifdef CONFIG_CPU_TX39XX
+	/* update IRCSR */
+	__raw_writel(0, &txx9_ircptr->imr);
+	__raw_writel(irc_elevel, &txx9_ircptr->imr);
+	/* flush write buffer */
+	__raw_readl(&txx9_ircptr->ssr);
+#else
+	mmiowb();
+#endif
+}
+
+static void txx9_irq_mask_ack(unsigned int irq)
+{
+	unsigned int irq_nr = irq - TXX9_IRQ_BASE;
+
+	txx9_irq_mask(irq);
+	if (TXx9_IRCR_EDGE(txx9irq[irq_nr].mode)) {
+		/* clear edge detection */
+		u32 cr = __raw_readl(&txx9_ircptr->cr[irq_nr / 8]);
+		cr = (cr >> ((irq_nr & (8 - 1)) * 2)) & 3;
+		__raw_writel(TXx9_IRSCR_EIClrE | irq_nr,
+			     &txx9_ircptr->scr);
+	}
+}
+
+static int txx9_irq_set_type(unsigned int irq, unsigned int flow_type)
+{
+	unsigned int irq_nr = irq - TXX9_IRQ_BASE;
+	u32 cr;
+	u32 __iomem *crp;
+	int ofs;
+	int mode;
+
+	if (flow_type & IRQF_TRIGGER_PROBE)
+		return 0;
+	switch (flow_type & IRQF_TRIGGER_MASK) {
+	case IRQF_TRIGGER_RISING:	mode = TXx9_IRCR_UP;	break;
+	case IRQF_TRIGGER_FALLING:	mode = TXx9_IRCR_DOWN;	break;
+	case IRQF_TRIGGER_HIGH:	mode = TXx9_IRCR_HIGH;	break;
+	case IRQF_TRIGGER_LOW:	mode = TXx9_IRCR_LOW;	break;
+	default:
+		return -EINVAL;
+	}
+	crp = &txx9_ircptr->cr[(unsigned int)irq_nr / 8];
+	cr = __raw_readl(crp);
+	ofs = (irq_nr & (8 - 1)) * 2;
+	cr &= ~(0x3 << ofs);
+	cr |= (mode & 0x3) << ofs;
+	__raw_writel(cr, crp);
+	txx9irq[irq_nr].mode = mode;
+	return 0;
+}
+
+static struct irq_chip txx9_irq_chip = {
+	.name		= "TXX9",
+	.ack		= txx9_irq_mask_ack,
+	.mask		= txx9_irq_mask,
+	.mask_ack	= txx9_irq_mask_ack,
+	.unmask		= txx9_irq_unmask,
+	.set_type	= txx9_irq_set_type,
+};
+
+void __init txx9_irq_init(unsigned long baseaddr)
+{
+	int i;
+
+	txx9_ircptr = ioremap(baseaddr, sizeof(struct txx9_irc_reg));
+	for (i = 0; i < TXx9_MAX_IR; i++) {
+		txx9irq[i].level = 4; /* middle level */
+		txx9irq[i].mode = TXx9_IRCR_LOW;
+		set_irq_chip_and_handler(TXX9_IRQ_BASE + i,
+					 &txx9_irq_chip, handle_level_irq);
+	}
+
+	/* mask all IRC interrupts */
+	__raw_writel(0, &txx9_ircptr->imr);
+	for (i = 0; i < 8; i++)
+		__raw_writel(0, &txx9_ircptr->ilr[i]);
+	/* setup IRC interrupt mode (Low Active) */
+	for (i = 0; i < 2; i++)
+		__raw_writel(0, &txx9_ircptr->cr[i]);
+	/* enable interrupt control */
+	__raw_writel(TXx9_IRCER_ICE, &txx9_ircptr->cer);
+	__raw_writel(irc_elevel, &txx9_ircptr->imr);
+}
+
+int __init txx9_irq_set_pri(int irc_irq, int new_pri)
+{
+	int old_pri;
+
+	if ((unsigned int)irc_irq >= TXx9_MAX_IR)
+		return 0;
+	old_pri = txx9irq[irc_irq].level;
+	txx9irq[irc_irq].level = new_pri;
+	return old_pri;
+}
+
+int txx9_irq(void)
+{
+	u32 csr = __raw_readl(&txx9_ircptr->csr);
+
+	if (likely(!(csr & TXx9_IRCSR_IF)))
+		return TXX9_IRQ_BASE + (csr & (TXx9_MAX_IR - 1));
+	return -1;
+}
