commit bd6e38983bb76a48604b7a4f0740354158217bd3
Author: Zhi Li <lizhi01@loongson.cn>
Date:   Mon May 18 15:08:08 2020 +0800

    MIPS: Remove useless parameter of bootcmdline_init()
    
    The parameter "cmdline_p" is useless in bootcmdline_init()ï¼Œremove it.
    
    Signed-off-by: Zhi Li <lizhi01@loongson.cn>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 8db533cd816c..7b537fa2035d 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -575,7 +575,7 @@ static int __init bootcmdline_scan_chosen(unsigned long node, const char *uname,
 
 #endif /* CONFIG_OF_EARLY_FLATTREE */
 
-static void __init bootcmdline_init(char **cmdline_p)
+static void __init bootcmdline_init(void)
 {
 	bool dt_bootargs = false;
 
@@ -658,7 +658,7 @@ static void __init arch_mem_init(char **cmdline_p)
 	plat_mem_setup();
 	memblock_set_bottom_up(true);
 
-	bootcmdline_init(cmdline_p);
+	bootcmdline_init();
 	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
 	*cmdline_p = command_line;
 

commit 269b3a9ac538c4ae87f84be640b9fa89914a2489
Author: Tiezhu Yang <yangtiezhu@loongson.cn>
Date:   Tue Apr 21 19:59:46 2020 +0800

    MIPS: Make sparse_init() using top-down allocation
    
    In the current code, if CONFIG_SWIOTLB is set, when failed to get IO TLB
    memory from the low pages by plat_swiotlb_setup(), it may lead to the boot
    process failed with kernel panic.
    
    (1) On the Loongson and SiByte platform
    arch/mips/loongson64/dma.c
    arch/mips/sibyte/common/dma.c
    void __init plat_swiotlb_setup(void)
    {
            swiotlb_init(1);
    }
    
    kernel/dma/swiotlb.c
    void  __init
    swiotlb_init(int verbose)
    {
    ...
            vstart = memblock_alloc_low(PAGE_ALIGN(bytes), PAGE_SIZE);
            if (vstart && !swiotlb_init_with_tbl(vstart, io_tlb_nslabs, verbose))
                    return;
    ...
            pr_warn("Cannot allocate buffer");
            no_iotlb_memory = true;
    }
    
    phys_addr_t swiotlb_tbl_map_single()
    {
    ...
            if (no_iotlb_memory)
                    panic("Can not allocate SWIOTLB buffer earlier ...");
    ...
    }
    
    (2) On the Cavium OCTEON platform
    arch/mips/cavium-octeon/dma-octeon.c
    void __init plat_swiotlb_setup(void)
    {
    ...
            octeon_swiotlb = memblock_alloc_low(swiotlbsize, PAGE_SIZE);
            if (!octeon_swiotlb)
                    panic("%s: Failed to allocate %zu bytes align=%lx\n",
                          __func__, swiotlbsize, PAGE_SIZE);
    ...
    }
    
    Because IO_TLB_DEFAULT_SIZE is 64M, if the rest size of low memory is less
    than 64M when call plat_swiotlb_setup(), we can easily reproduce the panic
    case.
    
    In order to reduce the possibility of kernel panic when failed to get IO
    TLB memory under CONFIG_SWIOTLB, it is better to allocate low memory as
    small as possible before plat_swiotlb_setup(), so make sparse_init() using
    top-down allocation.
    
    Reported-by: Juxin Gao <gaojuxin@loongson.cn>
    Co-developed-by: Juxin Gao <gaojuxin@loongson.cn>
    Signed-off-by: Juxin Gao <gaojuxin@loongson.cn>
    Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 5481a0c68521..8db533cd816c 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -700,7 +700,17 @@ static void __init arch_mem_init(char **cmdline_p)
 		memblock_reserve(crashk_res.start, resource_size(&crashk_res));
 #endif
 	device_tree_init();
+
+	/*
+	 * In order to reduce the possibility of kernel panic when failed to
+	 * get IO TLB memory under CONFIG_SWIOTLB, it is better to allocate
+	 * low memory as small as possible before plat_swiotlb_setup(), so
+	 * make sparse_init() using top-down allocation.
+	 */
+	memblock_set_bottom_up(false);
 	sparse_init();
+	memblock_set_bottom_up(true);
+
 	plat_swiotlb_setup();
 
 	dma_contiguous_reserve(PFN_PHYS(max_low_pfn));

commit 2a3d47c94ebdfb97bd8aa95343c58b679cb11724
Author: Tiezhu Yang <yangtiezhu@loongson.cn>
Date:   Tue Apr 21 19:59:45 2020 +0800

    MIPS: Cleanup code about plat_mem_setup()
    
    In the current code, plat_mem_setup() is called by arch_mem_init() instead
    of setup_arch() and has been declared in asm/bootinfo.h, so modify the code
    comment to reflect the reality and remove the useless duplicate declartion
    in arch/mips/kernel/setup.c.
    
    Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index b1e2d4360383..5481a0c68521 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -654,8 +654,6 @@ static void __init bootcmdline_init(char **cmdline_p)
  */
 static void __init arch_mem_init(char **cmdline_p)
 {
-	extern void plat_mem_setup(void);
-
 	/* call board setup routine */
 	plat_mem_setup();
 	memblock_set_bottom_up(true);

commit 2c66e281c0330289aad93e6dd722b25fee29306c
Author: Tiezhu Yang <yangtiezhu@loongson.cn>
Date:   Tue Apr 21 19:59:44 2020 +0800

    MIPS: Do not initialise globals to 0
    
    Fix the following checkpatch error:
    
    ERROR: do not initialise globals to 0
    #834: FILE: arch/mips/kernel/setup.c:834:
    +int hw_coherentio = 0; /* Actual hardware supported DMA coherency setting. */
    
    Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 10bef8f78e7c..b1e2d4360383 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -831,7 +831,7 @@ arch_initcall(debugfs_mips);
 /* User defined DMA coherency from command line. */
 enum coherent_io_user_state coherentio = IO_COHERENCE_DEFAULT;
 EXPORT_SYMBOL_GPL(coherentio);
-int hw_coherentio = 0;	/* Actual hardware supported DMA coherency setting. */
+int hw_coherentio;	/* Actual hardware supported DMA coherency setting. */
 
 static int __init setcoherentio(char *str)
 {

commit be8fa1cb444cdf3dcab72053939d073394886ff8
Author: Tiezhu Yang <yangtiezhu@loongson.cn>
Date:   Wed Feb 5 12:08:33 2020 +0800

    MIPS: Add support for Desktop Management Interface (DMI)
    
    Enable DMI scanning on the MIPS architecture, this setups DMI identifiers
    (dmi_system_id) for printing it out on task dumps and prepares DIMM entry
    information (dmi_memdev_info) from the SMBIOS table. With this patch, the
    driver can easily match various of mainboards.
    
    In the SMBIOS reference specification, the table anchor string "_SM_" is
    present in the address range 0xF0000 to 0xFFFFF on a 16-byte boundary,
    but there exists a special case for Loongson platform, when call function
    dmi_early_remap, it should specify the start address to 0xFFFE000 due to
    it is reserved for SMBIOS and can be normally access in the BIOS.
    
    This patch works fine on the Loongson 3A3000 platform which belongs to
    MIPS architecture and has no influence on the other architectures such
    as x86 and ARM.
    
    Additionally, in order to avoid the unknown risks on the mips platform
    which is not MACH_LOONGSON64, the DMI config is better to depend on
    MACH_LOONGSON64. If other mips platform also needs this DMI feature in
    the future, the "depends on" condition can be modified.
    
    Co-developed-by: Yinglu Yang <yangyinglu@loongson.cn>
    Signed-off-by: Yinglu Yang <yangyinglu@loongson.cn>
    [jiaxun.yang@flygoat.com: Refine definitions and Kconfig]
    Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
    Signed-off-by: Tiezhu Yang <yangtiezhu@loongson.cn>
    Reviewed-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index a7b469d89e2c..10bef8f78e7c 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -28,6 +28,7 @@
 #include <linux/decompress/generic.h>
 #include <linux/of_fdt.h>
 #include <linux/of_reserved_mem.h>
+#include <linux/dmi.h>
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
@@ -799,6 +800,7 @@ void __init setup_arch(char **cmdline_p)
 #endif
 
 	arch_mem_init(cmdline_p);
+	dmi_setup();
 
 	resource_init();
 	plat_smp_setup();

commit 8e029eb0bcd6a7fab6dc9191152c085784c31ee6
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Tue Feb 25 12:28:09 2020 -0300

    MIPS: Fix CONFIG_MIPS_CMDLINE_DTB_EXTEND handling
    
    The CONFIG_MIPS_CMDLINE_DTB_EXTEND option is used so that the kernel
    arguments provided in the 'bootargs' property in devicetree are extended
    with the kernel arguments provided by the bootloader.
    
    The code was broken, as it didn't actually take any of the kernel
    arguments provided in devicetree when that option was set.
    
    Fixes: 7784cac69735 ("MIPS: cmdline: Clean up boot_command_line initialization")
    Cc: stable@vger.kernel.org
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 1ac2752fb791..a7b469d89e2c 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -605,7 +605,8 @@ static void __init bootcmdline_init(char **cmdline_p)
 	 * If we're configured to take boot arguments from DT, look for those
 	 * now.
 	 */
-	if (IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_DTB))
+	if (IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_DTB) ||
+	    IS_ENABLED(CONFIG_MIPS_CMDLINE_DTB_EXTEND))
 		of_scan_flat_dt(bootcmdline_scan_chosen, &dt_bootargs);
 #endif
 

commit c5951e7c8ee5cb04b8b41c32bf567b90117a2124
Merge: b7e573bb4a7a 2c4288719806
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 31 11:28:31 2020 -0800

    Merge tag 'mips_5.6' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux
    
    Pull MIPS changes from Paul Burton:
     "Nothing too big or scary in here:
    
       - Support mremap() for the VDSO, primarily to allow CRIU to restore
         the VDSO to its checkpointed location.
    
       - Restore the MIPS32 cBPF JIT, after having reverted the enablement
         of the eBPF JIT for MIPS32 systems in the 5.5 cycle.
    
       - Improve cop0 counter synchronization behaviour whilst onlining CPUs
         by running with interrupts disabled.
    
       - Better match FPU behaviour when emulating multiply-accumulate
         instructions on pre-r6 systems that implement IEEE754-2008 style
         MACs.
    
       - Loongson64 kernels now build using the MIPS64r2 ISA, allowing them
         to take advantage of instructions introduced by r2.
    
       - Support for the Ingenic X1000 SoC & the really nice little CU Neo
         development board that's using it.
    
       - Support for WMAC on GARDENA Smart Gateway devices.
    
       - Lots of cleanup & refactoring of SGI IP27 (Origin 2*) support in
         preparation for introducing IP35 (Origin 3*) support.
    
       - Various Kconfig & Makefile cleanups"
    
    * tag 'mips_5.6' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux: (60 commits)
      MIPS: PCI: Add detection of IOC3 on IO7, IO8, IO9 and Fuel
      MIPS: Loongson64: Disable exec hazard
      MIPS: Loongson64: Bump ISA level to MIPSR2
      MIPS: Make DIEI support as a config option
      MIPS: OCTEON: octeon-irq: fix spelling mistake "to" -> "too"
      MIPS: asm: local: add barriers for Loongson
      MIPS: Loongson64: Select mac2008 only feature
      MIPS: Add MAC2008 Support
      Revert "MIPS: Add custom serial.h with BASE_BAUD override for generic kernel"
      MIPS: sort MIPS and MIPS_GENERIC Kconfig selects alphabetically (again)
      MIPS: make CPU_HAS_LOAD_STORE_LR opt-out
      MIPS: generic: don't unconditionally select PINCTRL
      MIPS: don't explicitly select LIBFDT in Kconfig
      MIPS: sync-r4k: do slave counter synchronization with disabled HW interrupts
      MIPS: SGI-IP30: Check for valid pointer before using it
      MIPS: syscalls: fix indentation of the 'SYSNR' message
      MIPS: boot: fix typo in 'vmlinux.lzma.its' target
      MIPS: fix indentation of the 'RELOCS' message
      dt-bindings: Document loongson vendor-prefix
      MIPS: CU1000-Neo: Refresh defconfig to support HWMON and WiFi.
      ...

commit 3229af4f3ef4db439471d21df562532365005bd5
Author: Arvind Sankar <nivedita@alum.mit.edu>
Date:   Wed Dec 18 16:44:54 2019 -0500

    arch/mips/setup: Drop dummy_con initialization
    
    con_init in tty/vt.c will now set conswitchp to dummy_con if it's unset.
    Drop it from arch setup code.
    
    Signed-off-by: Arvind Sankar <nivedita@alum.mit.edu>
    Link: https://lore.kernel.org/r/20191218214506.49252-13-nivedita@alum.mit.edu
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c3d4212b5f1d..a28057946ed1 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -796,8 +796,6 @@ void __init setup_arch(char **cmdline_p)
 #if defined(CONFIG_VT)
 #if defined(CONFIG_VGA_CONSOLE)
 	conswitchp = &vga_con;
-#elif defined(CONFIG_DUMMY_CONSOLE)
-	conswitchp = &dummy_con;
 #endif
 #endif
 

commit ecb983790fe893e73e6d29bcb6d8df71e593a550
Author: Julia Lawall <Julia.Lawall@inria.fr>
Date:   Wed Jan 1 18:49:48 2020 +0100

    MIPS: use resource_size
    
    Use resource_size rather than a verbose computation on
    the end and start fields.
    
    The semantic patch that makes these changes is as follows:
    (http://coccinelle.lip6.fr/)
    
    <smpl>
    @@ struct resource ptr; @@
    - (ptr.end - ptr.start + 1)
    + resource_size(&ptr)
    </smpl>
    
    Signed-off-by: Julia Lawall <Julia.Lawall@inria.fr>
    Reviewed-by: Philippe Mathieu-DaudÃ© <f4bug@amsat.org>
    Signed-off-by: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: kernel-janitors@vger.kernel.org
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c3d4212b5f1d..701f4bc3046f 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -515,8 +515,7 @@ static void __init request_crashkernel(struct resource *res)
 	ret = request_resource(res, &crashk_res);
 	if (!ret)
 		pr_info("Reserving %ldMB of memory at %ldMB for crashkernel\n",
-			(unsigned long)((crashk_res.end -
-					 crashk_res.start + 1) >> 20),
+			(unsigned long)(resource_size(&crashk_res) >> 20),
 			(unsigned long)(crashk_res.start  >> 20));
 }
 #else /* !defined(CONFIG_KEXEC)		*/
@@ -698,8 +697,7 @@ static void __init arch_mem_init(char **cmdline_p)
 	mips_parse_crashkernel();
 #ifdef CONFIG_KEXEC
 	if (crashk_res.start != crashk_res.end)
-		memblock_reserve(crashk_res.start,
-				 crashk_res.end - crashk_res.start + 1);
+		memblock_reserve(crashk_res.start, resource_size(&crashk_res));
 #endif
 	device_tree_init();
 	sparse_init();

commit 268a2d60013049cfd9a0aada77284aa6ea8ad26a
Author: Jiaxun Yang <jiaxun.yang@flygoat.com>
Date:   Sun Oct 20 22:43:13 2019 +0800

    MIPS: Loongson64: Rename CPU TYPES
    
    CPU_LOONGSON2 -> CPU_LOONGSON2EF
    CPU_LOONGSON3 -> CPU_LOONGSON64
    
    As newer loongson-2 products (2G/2H/2K1000) can share kernel
    implementation with loongson-3 while 2E/2F are less similar with
    other LOONGSON64 products.
    
    Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
    Signed-off-by: Paul Burton <paulburton@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: chenhc@lemote.com
    Cc: paul.burton@mips.com

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 2af05879772f..c3d4212b5f1d 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -287,7 +287,7 @@ static unsigned long __init init_initrd(void)
  * Initialize the bootmem allocator. It also setup initrd related data
  * if needed.
  */
-#if defined(CONFIG_SGI_IP27) || (defined(CONFIG_CPU_LOONGSON3) && defined(CONFIG_NUMA))
+#if defined(CONFIG_SGI_IP27) || (defined(CONFIG_CPU_LOONGSON64) && defined(CONFIG_NUMA))
 
 static void __init bootmem_init(void)
 {

commit 9dd422f69777b928f8a12e5392d4aeeb00a55c2b
Author: Paul Burton <paul.burton@mips.com>
Date:   Sat Oct 12 20:43:38 2019 +0000

    MIPS: Make builtin_cmdline const & variable length
    
    We have no need for the builtin_cmdline array to be fixed at the length
    of COMMAND_LINE_SIZE - we'll only copy out the string it contains up to
    its NULL terminator anyway, and cap the size at COMMAND_LINE_SIZE when
    copying into or concatenating with boot_command_line.
    
    The string value is also constant, so we can declare it as such to place
    it in the .init.rodata section.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 7ccc8a9e1bfe..2af05879772f 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -67,7 +67,7 @@ static char __initdata command_line[COMMAND_LINE_SIZE];
 char __initdata arcs_cmdline[COMMAND_LINE_SIZE];
 
 #ifdef CONFIG_CMDLINE_BOOL
-static char __initdata builtin_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;
+static const char builtin_cmdline[] __initconst = CONFIG_CMDLINE;
 #else
 static const char builtin_cmdline[] __initconst = "";
 #endif

commit 972727766ee4d9e8b455c09e8dcb1e7dc14c4967
Author: Paul Burton <paul.burton@mips.com>
Date:   Sat Oct 12 20:43:37 2019 +0000

    MIPS: Fix CONFIG_OF_EARLY_FLATTREE=n builds
    
    Configurations with CONFIG_OF_EARLY_FLATTREE=n fail to build since
    commit 7784cac69735 ("MIPS: cmdline: Clean up boot_command_line
    initialization") because of_scan_flat_dt() & of_scan_flat_dt() are not
    defined in these configurations. Fix this by #ifdef'ing the affected
    code...
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Fixes: 7784cac69735 ("MIPS: cmdline: Clean up boot_command_line initialization")
    Reported-by: kbuild test robot <lkp@intel.com>
    Cc: linux-mips@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 119999d31558..7ccc8a9e1bfe 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -551,6 +551,8 @@ static void __init bootcmdline_append(const char *s, size_t max)
 	strlcat(boot_command_line, s, max);
 }
 
+#ifdef CONFIG_OF_EARLY_FLATTREE
+
 static int __init bootcmdline_scan_chosen(unsigned long node, const char *uname,
 					  int depth, void *data)
 {
@@ -571,6 +573,8 @@ static int __init bootcmdline_scan_chosen(unsigned long node, const char *uname,
 	return 1;
 }
 
+#endif /* CONFIG_OF_EARLY_FLATTREE */
+
 static void __init bootcmdline_init(char **cmdline_p)
 {
 	bool dt_bootargs = false;
@@ -597,12 +601,14 @@ static void __init bootcmdline_init(char **cmdline_p)
 	else
 		boot_command_line[0] = 0;
 
+#ifdef CONFIG_OF_EARLY_FLATTREE
 	/*
 	 * If we're configured to take boot arguments from DT, look for those
 	 * now.
 	 */
 	if (IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_DTB))
 		of_scan_flat_dt(bootcmdline_scan_chosen, &dt_bootargs);
+#endif
 
 	/*
 	 * If we didn't get any arguments from DT (regardless of whether that's

commit b7340422cc16c5deff100812f38114bb5ec81203
Author: Paul Burton <paul.burton@mips.com>
Date:   Sat Oct 12 20:43:36 2019 +0000

    MIPS: Always define builtin_cmdline
    
    Commit 7784cac69735 ("MIPS: cmdline: Clean up boot_command_line
    initialization") made use of builtin_cmdline conditional upon plain C if
    statements rather than preprocessor #ifdef's. This caused build failures
    for configurations with CONFIG_CMDLINE_BOOL=n where builtin_cmdline
    wasn't defined, for example:
    
       arch/mips/kernel/setup.c: In function 'bootcmdline_init':
    >> arch/mips/kernel/setup.c:582:30: error: 'builtin_cmdline' undeclared
        (first use in this function); did you mean 'builtin_driver'?
          strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
                                     ^~~~~~~~~~~~~~~
                                     builtin_driver
       arch/mips/kernel/setup.c:582:30: note: each undeclared identifier is
        reported only once for each function it appears in
    
    Fix this by defining builtin_cmdline as an empty string in the affected
    configurations. All of the paths that use it should be optimized out
    anyway so the data itself gets optimized away too.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Fixes: 7784cac69735 ("MIPS: cmdline: Clean up boot_command_line initialization")
    Reported-by: kbuild test robot <lkp@intel.com>
    Reported-by: Nathan Chancellor <natechancellor@gmail.com>
    Cc: linux-mips@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 4aeba3122972..119999d31558 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -68,6 +68,8 @@ char __initdata arcs_cmdline[COMMAND_LINE_SIZE];
 
 #ifdef CONFIG_CMDLINE_BOOL
 static char __initdata builtin_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;
+#else
+static const char builtin_cmdline[] __initconst = "";
 #endif
 
 /*

commit 7784cac697351f0cc0a4bb619594c0c99348c5aa
Author: Paul Burton <paul.burton@mips.com>
Date:   Wed Oct 9 23:09:45 2019 +0000

    MIPS: cmdline: Clean up boot_command_line initialization
    
    Our current code to initialize boot_command_line is a mess. Some of this
    is due to the addition of too many options over the years, and some of
    this is due to workarounds for early_init_dt_scan_chosen() performing
    actions specific to options from other architectures that probably
    shouldn't be in generic code.
    
    Clean this up by introducing a new bootcmdline_init() function that
    simplifies the initialization somewhat. The major changes are:
    
    - Because bootcmdline_init() is a function it can return early in the
      CONFIG_CMDLINE_OVERRIDE case.
    
    - We clear boot_command_line rather than inheriting whatever
      early_init_dt_scan_chosen() may have left us. This means we no longer
      need to set boot_command_line to a space character in an attempt to
      prevent early_init_dt_scan_chosen() from copying CONFIG_CMDLINE into
      boot_command_line without us knowing about it.
    
    - Indirection via USE_PROM_CMDLINE, USE_DTB_CMDLINE, EXTEND_WITH_PROM &
      BUILTIN_EXTEND_WITH_PROM macros is removed; they seemingly served only
      to obfuscate the code.
    
    - The logic is cleaner, clearer & commented.
    
    Two minor drawbacks of this approach are:
    
    1) We call of_scan_flat_dt(), which means we scan through the DT again.
       The overhead is fairly minimal & shouldn't be noticeable.
    
    2) cmdline_scan_chosen() duplicates a small amount of the logic from
       early_init_dt_scan_chosen(). Alternatives might be to allow the
       generic FDT code to keep & expose a copy of the arguments taken from
       the /chosen node's bootargs property, or to introduce a function like
       early_init_dt_scan_chosen() that retrieves them without modification
       to handle CONFIG_CMDLINE. Neither of these sounds particularly
       cleaner though, and this way we at least keep the extra work in
       arch/mips.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 5eec13b8d222..4aeba3122972 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -538,11 +538,88 @@ static void __init check_kernel_sections_mem(void)
 	}
 }
 
-#define USE_PROM_CMDLINE	IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_BOOTLOADER)
-#define USE_DTB_CMDLINE		IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_DTB)
-#define EXTEND_WITH_PROM	IS_ENABLED(CONFIG_MIPS_CMDLINE_DTB_EXTEND)
-#define BUILTIN_EXTEND_WITH_PROM	\
-	IS_ENABLED(CONFIG_MIPS_CMDLINE_BUILTIN_EXTEND)
+static void __init bootcmdline_append(const char *s, size_t max)
+{
+	if (!s[0] || !max)
+		return;
+
+	if (boot_command_line[0])
+		strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
+
+	strlcat(boot_command_line, s, max);
+}
+
+static int __init bootcmdline_scan_chosen(unsigned long node, const char *uname,
+					  int depth, void *data)
+{
+	bool *dt_bootargs = data;
+	const char *p;
+	int l;
+
+	if (depth != 1 || !data ||
+	    (strcmp(uname, "chosen") != 0 && strcmp(uname, "chosen@0") != 0))
+		return 0;
+
+	p = of_get_flat_dt_prop(node, "bootargs", &l);
+	if (p != NULL && l > 0) {
+		bootcmdline_append(p, min(l, COMMAND_LINE_SIZE));
+		*dt_bootargs = true;
+	}
+
+	return 1;
+}
+
+static void __init bootcmdline_init(char **cmdline_p)
+{
+	bool dt_bootargs = false;
+
+	/*
+	 * If CMDLINE_OVERRIDE is enabled then initializing the command line is
+	 * trivial - we simply use the built-in command line unconditionally &
+	 * unmodified.
+	 */
+	if (IS_ENABLED(CONFIG_CMDLINE_OVERRIDE)) {
+		strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
+		return;
+	}
+
+	/*
+	 * If the user specified a built-in command line &
+	 * MIPS_CMDLINE_BUILTIN_EXTEND, then the built-in command line is
+	 * prepended to arguments from the bootloader or DT so we'll copy them
+	 * to the start of boot_command_line here. Otherwise, empty
+	 * boot_command_line to undo anything early_init_dt_scan_chosen() did.
+	 */
+	if (IS_ENABLED(CONFIG_MIPS_CMDLINE_BUILTIN_EXTEND))
+		strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
+	else
+		boot_command_line[0] = 0;
+
+	/*
+	 * If we're configured to take boot arguments from DT, look for those
+	 * now.
+	 */
+	if (IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_DTB))
+		of_scan_flat_dt(bootcmdline_scan_chosen, &dt_bootargs);
+
+	/*
+	 * If we didn't get any arguments from DT (regardless of whether that's
+	 * because we weren't configured to look for them, or because we looked
+	 * & found none) then we'll take arguments from the bootloader.
+	 * plat_mem_setup() should have filled arcs_cmdline with arguments from
+	 * the bootloader.
+	 */
+	if (IS_ENABLED(CONFIG_MIPS_CMDLINE_DTB_EXTEND) || !dt_bootargs)
+		bootcmdline_append(arcs_cmdline, COMMAND_LINE_SIZE);
+
+	/*
+	 * If the user specified a built-in command line & we didn't already
+	 * prepend it, we append it to boot_command_line here.
+	 */
+	if (IS_ENABLED(CONFIG_CMDLINE_BOOL) &&
+	    !IS_ENABLED(CONFIG_MIPS_CMDLINE_BUILTIN_EXTEND))
+		bootcmdline_append(builtin_cmdline, COMMAND_LINE_SIZE);
+}
 
 /*
  * arch_mem_init - initialize memory management subsystem
@@ -570,48 +647,12 @@ static void __init arch_mem_init(char **cmdline_p)
 {
 	extern void plat_mem_setup(void);
 
-	/*
-	 * Initialize boot_command_line to an innocuous but non-empty string in
-	 * order to prevent early_init_dt_scan_chosen() from copying
-	 * CONFIG_CMDLINE into it without our knowledge. We handle
-	 * CONFIG_CMDLINE ourselves below & don't want to duplicate its
-	 * content because repeating arguments can be problematic.
-	 */
-	strlcpy(boot_command_line, " ", COMMAND_LINE_SIZE);
-
 	/* call board setup routine */
 	plat_mem_setup();
 	memblock_set_bottom_up(true);
 
-#if defined(CONFIG_CMDLINE_BOOL) && defined(CONFIG_CMDLINE_OVERRIDE)
-	strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
-#else
-	if ((USE_PROM_CMDLINE && arcs_cmdline[0]) ||
-	    (USE_DTB_CMDLINE && !boot_command_line[0]))
-		strlcpy(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
-
-	if (EXTEND_WITH_PROM && arcs_cmdline[0]) {
-		if (boot_command_line[0])
-			strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
-		strlcat(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
-	}
-
-#if defined(CONFIG_CMDLINE_BOOL)
-	if (builtin_cmdline[0]) {
-		if (boot_command_line[0])
-			strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
-		strlcat(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
-	}
-
-	if (BUILTIN_EXTEND_WITH_PROM && arcs_cmdline[0]) {
-		if (boot_command_line[0])
-			strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
-		strlcat(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
-	}
-#endif
-#endif
+	bootcmdline_init(cmdline_p);
 	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
-
 	*cmdline_p = command_line;
 
 	parse_early_param();

commit bd848d1b9235d027e65fcc87de26cc1b02b41cc8
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Tue Sep 24 17:20:51 2019 +0200

    MIPS: init: Prevent adding memory before PHYS_OFFSET
    
    On some SGI machines (IP28 and IP30) a small region of memory is mirrored
    to pyhsical address 0 for exception vectors while rest of the memory
    is reachable at a higher physical address. ARC PROM marks this
    region as reserved, but with commit a94e4f24ec83 ("MIPS: init: Drop
    boot_mem_map") this chunk is used, when searching for start of ram,
    which breaks at least IP28 and IP30 machines. To fix this
    add_region_memory() checks for start address < PHYS_OFFSET and ignores
    these chunks.
    
    Fixes: a94e4f24ec83 ("MIPS: init: Drop boot_mem_map")
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index f5c6b4c6de24..5eec13b8d222 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -108,6 +108,9 @@ void __init add_memory_region(phys_addr_t start, phys_addr_t size, long type)
 		return;
 	}
 
+	if (start < PHYS_OFFSET)
+		return;
+
 	memblock_add(start, size);
 	/* Reserve any memory except the ordinary RAM ranges. */
 	switch (type) {

commit 66b416ee41ed7a8216e5234a96288dbb8124e4b6
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Tue Sep 24 17:19:56 2019 +0200

    MIPS: init: Fix reservation of memory between PHYS_OFFSET and mem start
    
    Fix calculation of the size for reserving memory between PHYS_OFFSET
    and real memory start.
    
    Fixes: a94e4f24ec83 ("MIPS: init: Drop boot_mem_map")
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index b8249c233754..f5c6b4c6de24 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -321,7 +321,7 @@ static void __init bootmem_init(void)
 	 * Reserve any memory between the start of RAM and PHYS_OFFSET
 	 */
 	if (ramstart > PHYS_OFFSET)
-		memblock_reserve(PHYS_OFFSET, PFN_UP(ramstart) - PHYS_OFFSET);
+		memblock_reserve(PHYS_OFFSET, ramstart - PHYS_OFFSET);
 
 	if (PFN_UP(ramstart) > ARCH_PFN_OFFSET) {
 		pr_info("Wasting %lu bytes for tracking %lu unused pages\n",

commit 12051b318bc3ce5b42d6d786191008284b067d83
Author: Nick Desaulniers <ndesaulniers@google.com>
Date:   Mon Jul 29 14:10:12 2019 -0700

    mips: avoid explicit UB in assignment of mips_io_port_base
    
    The code in question is modifying a variable declared const through
    pointer manipulation.  Such code is explicitly undefined behavior, and
    is the lone issue preventing malta_defconfig from booting when built
    with Clang:
    
    If an attempt is made to modify an object defined with a const-qualified
    type through use of an lvalue with non-const-qualified type, the
    behavior is undefined.
    
    LLVM is removing such assignments. A simple fix is to not declare
    variables const that you plan on modifying.  Limiting the scope would be
    a better method of preventing unwanted writes to such a variable.
    
    Further, the code in question mentions "compiler bugs" without any links
    to bug reports, so it is difficult to know if the issue is resolved in
    GCC. The patch was authored in 2006, which would have been GCC 4.0.3 or
    4.1.1. The minimal supported version of GCC in the Linux kernel is
    currently 4.6.
    
    For what its worth, there was UB before the commit in question, it just
    added a barrier and got lucky IRT codegen. I don't think there's any
    actual compiler bugs related, just runtime bugs due to UB.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/610
    Fixes: 966f4406d903 ("[MIPS] Work around bad code generation for <asm/io.h>.")
    Reported-by: Nathan Chancellor <natechancellor@gmail.com>
    Debugged-by: Nathan Chancellor <natechancellor@gmail.com>
    Suggested-by: Eli Friedman <efriedma@quicinc.com>
    Signed-off-by: Nick Desaulniers <ndesaulniers@google.com>
    Reviewed-by: Nathan Chancellor <natechancellor@gmail.com>
    Tested-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: ralf@linux-mips.org
    Cc: jhogan@kernel.org
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: Hassan Naveed <hnaveed@wavecomp.com>
    Cc: Stephen Kitt <steve@sk2.org>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: clang-built-linux@googlegroups.com

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 2f13814807a9..b8249c233754 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -74,7 +74,7 @@ static char __initdata builtin_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;
  * mips_io_port_base is the begin of the address space to which x86 style
  * I/O ports are mapped.
  */
-const unsigned long mips_io_port_base = -1;
+unsigned long mips_io_port_base = -1;
 EXPORT_SYMBOL(mips_io_port_base);
 
 static struct resource code_resource = { .name = "Kernel code", };

commit dbb9ced797640cfd4996e879c53fb1134e693d53
Author: Paul Burton <paul.burton@mips.com>
Date:   Fri Aug 23 18:00:38 2019 +0100

    MIPS: Fix build with CONFIG_PROC_VMCORE=y
    
    Commit a94e4f24ec83 ("MIPS: init: Drop boot_mem_map") introduced a
    reference to a non-existant "end" field in struct memblock_region.
    Replace it with a sum of the base & size fields to fix builds with
    CONFIG_PROC_VMCORE=y.
    
    Reported-by: kbuild test robot <lkp@intel.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 90c44e1b5e97..2f13814807a9 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -458,7 +458,7 @@ static int __init early_parse_elfcorehdr(char *p)
 
 	 for_each_memblock(memory, mem) {
 		unsigned long start = mem->base;
-		unsigned long end = mem->end;
+		unsigned long end = start + mem->size;
 		if (setup_elfcorehdr >= start && setup_elfcorehdr < end) {
 			/*
 			 * Reserve from the elf core header to the end of

commit a94e4f24ec836c8984f839594bad7454184975b1
Author: Jiaxun Yang <jiaxun.yang@flygoat.com>
Date:   Mon Aug 19 22:23:13 2019 +0800

    MIPS: init: Drop boot_mem_map
    
    boot_mem_map was introduced very early and cannot handle memory maps
    with nid. Nowadays, memblock can exactly replace boot_mem_map.
    
    Detect pfn info and setup resources with memblock maps.
    
    Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
    [paul.burton@mips.com: Fix size calculation in check_kernel_sections_mem]
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@vger.kernel.org
    Cc: yasha.che3@gmail.com
    Cc: aurelien@aurel32.net
    Cc: sfr@canb.auug.org.au
    Cc: fancer.lancer@gmail.com
    Cc: matt.redfearn@mips.com
    Cc: chenhc@lemote.com

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index ab349d2381c3..90c44e1b5e97 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -63,8 +63,6 @@ unsigned long mips_machtype __read_mostly = MACH_UNKNOWN;
 
 EXPORT_SYMBOL(mips_machtype);
 
-struct boot_mem_map boot_mem_map;
-
 static char __initdata command_line[COMMAND_LINE_SIZE];
 char __initdata arcs_cmdline[COMMAND_LINE_SIZE];
 
@@ -92,8 +90,10 @@ EXPORT_SYMBOL(ARCH_PFN_OFFSET);
 
 void __init add_memory_region(phys_addr_t start, phys_addr_t size, long type)
 {
-	int x = boot_mem_map.nr_map;
-	int i;
+	/*
+	 * Note: This function only exists for historical reason,
+	 * new code should use memblock_add or memblock_add_node instead.
+	 */
 
 	/*
 	 * If the region reaches the top of the physical address space, adjust
@@ -108,38 +108,20 @@ void __init add_memory_region(phys_addr_t start, phys_addr_t size, long type)
 		return;
 	}
 
-	/*
-	 * Try to merge with existing entry, if any.
-	 */
-	for (i = 0; i < boot_mem_map.nr_map; i++) {
-		struct boot_mem_map_entry *entry = boot_mem_map.map + i;
-		unsigned long top;
-
-		if (entry->type != type)
-			continue;
-
-		if (start + size < entry->addr)
-			continue;			/* no overlap */
+	memblock_add(start, size);
+	/* Reserve any memory except the ordinary RAM ranges. */
+	switch (type) {
+	case BOOT_MEM_RAM:
+		break;
 
-		if (entry->addr + entry->size < start)
-			continue;			/* no overlap */
+	case BOOT_MEM_NOMAP: /* Discard the range from the system. */
+		memblock_remove(start, size);
+		break;
 
-		top = max(entry->addr + entry->size, start + size);
-		entry->addr = min(entry->addr, start);
-		entry->size = top - entry->addr;
-
-		return;
+	default: /* Reserve the rest of the memory types at boot time */
+		memblock_reserve(start, size);
+		break;
 	}
-
-	if (boot_mem_map.nr_map == BOOT_MEM_MAP_MAX) {
-		pr_err("Ooops! Too many entries in the memory map!\n");
-		return;
-	}
-
-	boot_mem_map.map[x].addr = start;
-	boot_mem_map.map[x].size = size;
-	boot_mem_map.map[x].type = type;
-	boot_mem_map.nr_map++;
 }
 
 void __init detect_memory_region(phys_addr_t start, phys_addr_t sz_min, phys_addr_t sz_max)
@@ -161,70 +143,6 @@ void __init detect_memory_region(phys_addr_t start, phys_addr_t sz_min, phys_add
 	add_memory_region(start, size, BOOT_MEM_RAM);
 }
 
-static bool __init __maybe_unused memory_region_available(phys_addr_t start,
-							  phys_addr_t size)
-{
-	int i;
-	bool in_ram = false, free = true;
-
-	for (i = 0; i < boot_mem_map.nr_map; i++) {
-		phys_addr_t start_, end_;
-
-		start_ = boot_mem_map.map[i].addr;
-		end_ = boot_mem_map.map[i].addr + boot_mem_map.map[i].size;
-
-		switch (boot_mem_map.map[i].type) {
-		case BOOT_MEM_RAM:
-			if (start >= start_ && start + size <= end_)
-				in_ram = true;
-			break;
-		case BOOT_MEM_RESERVED:
-		case BOOT_MEM_NOMAP:
-			if ((start >= start_ && start < end_) ||
-			    (start < start_ && start + size >= start_))
-				free = false;
-			break;
-		default:
-			continue;
-		}
-	}
-
-	return in_ram && free;
-}
-
-static void __init print_memory_map(void)
-{
-	int i;
-	const int field = 2 * sizeof(unsigned long);
-
-	for (i = 0; i < boot_mem_map.nr_map; i++) {
-		printk(KERN_INFO " memory: %0*Lx @ %0*Lx ",
-		       field, (unsigned long long) boot_mem_map.map[i].size,
-		       field, (unsigned long long) boot_mem_map.map[i].addr);
-
-		switch (boot_mem_map.map[i].type) {
-		case BOOT_MEM_RAM:
-			printk(KERN_CONT "(usable)\n");
-			break;
-		case BOOT_MEM_INIT_RAM:
-			printk(KERN_CONT "(usable after init)\n");
-			break;
-		case BOOT_MEM_ROM_DATA:
-			printk(KERN_CONT "(ROM data)\n");
-			break;
-		case BOOT_MEM_RESERVED:
-			printk(KERN_CONT "(reserved)\n");
-			break;
-		case BOOT_MEM_NOMAP:
-			printk(KERN_CONT "(nomap)\n");
-			break;
-		default:
-			printk(KERN_CONT "type %lu\n", boot_mem_map.map[i].type);
-			break;
-		}
-	}
-}
-
 /*
  * Manage initrd
  */
@@ -376,8 +294,11 @@ static void __init bootmem_init(void)
 
 static void __init bootmem_init(void)
 {
-	phys_addr_t ramstart = PHYS_ADDR_MAX;
-	int i;
+	struct memblock_region *mem;
+	phys_addr_t ramstart, ramend;
+
+	ramstart = memblock_start_of_DRAM();
+	ramend = memblock_end_of_DRAM();
 
 	/*
 	 * Sanity check any INITRD first. We don't take it into account
@@ -391,122 +312,66 @@ static void __init bootmem_init(void)
 	memblock_reserve(__pa_symbol(&_text),
 			__pa_symbol(&_end) - __pa_symbol(&_text));
 
+	/* max_low_pfn is not a number of pages but the end pfn of low mem */
+
+#ifdef CONFIG_MIPS_AUTO_PFN_OFFSET
+	ARCH_PFN_OFFSET = PFN_UP(ramstart);
+#else
 	/*
-	 * max_low_pfn is not a number of pages. The number of pages
-	 * of the system is given by 'max_low_pfn - min_low_pfn'.
+	 * Reserve any memory between the start of RAM and PHYS_OFFSET
 	 */
-	min_low_pfn = ~0UL;
-	max_low_pfn = 0;
-
-	/* Find the highest and lowest page frame numbers we have available. */
-	for (i = 0; i < boot_mem_map.nr_map; i++) {
-		unsigned long start, end;
-
-		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
-			continue;
+	if (ramstart > PHYS_OFFSET)
+		memblock_reserve(PHYS_OFFSET, PFN_UP(ramstart) - PHYS_OFFSET);
 
-		start = PFN_UP(boot_mem_map.map[i].addr);
-		end = PFN_DOWN(boot_mem_map.map[i].addr
-				+ boot_mem_map.map[i].size);
+	if (PFN_UP(ramstart) > ARCH_PFN_OFFSET) {
+		pr_info("Wasting %lu bytes for tracking %lu unused pages\n",
+			(unsigned long)((PFN_UP(ramstart) - ARCH_PFN_OFFSET) * sizeof(struct page)),
+			(unsigned long)(PFN_UP(ramstart) - ARCH_PFN_OFFSET));
+	}
+#endif
 
-		ramstart = min(ramstart, boot_mem_map.map[i].addr);
+	min_low_pfn = ARCH_PFN_OFFSET;
+	max_pfn = PFN_DOWN(ramend);
+	for_each_memblock(memory, mem) {
+		unsigned long start = memblock_region_memory_base_pfn(mem);
+		unsigned long end = memblock_region_memory_end_pfn(mem);
 
-#ifndef CONFIG_HIGHMEM
 		/*
 		 * Skip highmem here so we get an accurate max_low_pfn if low
 		 * memory stops short of high memory.
 		 * If the region overlaps HIGHMEM_START, end is clipped so
 		 * max_pfn excludes the highmem portion.
 		 */
+		if (memblock_is_nomap(mem))
+			continue;
 		if (start >= PFN_DOWN(HIGHMEM_START))
 			continue;
 		if (end > PFN_DOWN(HIGHMEM_START))
 			end = PFN_DOWN(HIGHMEM_START);
-#endif
-
 		if (end > max_low_pfn)
 			max_low_pfn = end;
-		if (start < min_low_pfn)
-			min_low_pfn = start;
 	}
 
 	if (min_low_pfn >= max_low_pfn)
 		panic("Incorrect memory mapping !!!");
 
-#ifdef CONFIG_MIPS_AUTO_PFN_OFFSET
-	ARCH_PFN_OFFSET = PFN_UP(ramstart);
-#else
-	/*
-	 * Reserve any memory between the start of RAM and PHYS_OFFSET
-	 */
-	if (ramstart > PHYS_OFFSET) {
-		add_memory_region(PHYS_OFFSET, ramstart - PHYS_OFFSET,
-				  BOOT_MEM_RESERVED);
-		memblock_reserve(PHYS_OFFSET, ramstart - PHYS_OFFSET);
-	}
-
-	if (min_low_pfn > ARCH_PFN_OFFSET) {
-		pr_info("Wasting %lu bytes for tracking %lu unused pages\n",
-			(min_low_pfn - ARCH_PFN_OFFSET) * sizeof(struct page),
-			min_low_pfn - ARCH_PFN_OFFSET);
-	} else if (ARCH_PFN_OFFSET - min_low_pfn > 0UL) {
-		pr_info("%lu free pages won't be used\n",
-			ARCH_PFN_OFFSET - min_low_pfn);
-	}
-	min_low_pfn = ARCH_PFN_OFFSET;
-#endif
-
-	/*
-	 * Determine low and high memory ranges
-	 */
-	max_pfn = max_low_pfn;
-	if (max_low_pfn > PFN_DOWN(HIGHMEM_START)) {
+	if (max_pfn > PFN_DOWN(HIGHMEM_START)) {
 #ifdef CONFIG_HIGHMEM
 		highstart_pfn = PFN_DOWN(HIGHMEM_START);
-		highend_pfn = max_low_pfn;
-#endif
+		highend_pfn = max_pfn;
+#else
 		max_low_pfn = PFN_DOWN(HIGHMEM_START);
-	}
-
-	/* Install all valid RAM ranges to the memblock memory region */
-	for (i = 0; i < boot_mem_map.nr_map; i++) {
-		unsigned long start, end;
-
-		start = PFN_UP(boot_mem_map.map[i].addr);
-		end = PFN_DOWN(boot_mem_map.map[i].addr
-				+ boot_mem_map.map[i].size);
-
-		if (start < min_low_pfn)
-			start = min_low_pfn;
-#ifndef CONFIG_HIGHMEM
-		/* Ignore highmem regions if highmem is unsupported */
-		if (end > max_low_pfn)
-			end = max_low_pfn;
+		max_pfn = max_low_pfn;
 #endif
-		if (end <= start)
-			continue;
-
-		memblock_add_node(PFN_PHYS(start), PFN_PHYS(end - start), 0);
+	}
 
-		/* Reserve any memory except the ordinary RAM ranges. */
-		switch (boot_mem_map.map[i].type) {
-		case BOOT_MEM_RAM:
-			break;
-		case BOOT_MEM_NOMAP: /* Discard the range from the system. */
-			memblock_remove(PFN_PHYS(start), PFN_PHYS(end - start));
-			continue;
-		default: /* Reserve the rest of the memory types at boot time */
-			memblock_reserve(PFN_PHYS(start), PFN_PHYS(end - start));
-			break;
-		}
 
-		/*
-		 * In any case the added to the memblock memory regions
-		 * (highmem/lowmem, available/reserved, etc) are considered
-		 * as present, so inform sparsemem about them.
-		 */
-		memory_present(0, start, end);
-	}
+	/*
+	 * In any case the added to the memblock memory regions
+	 * (highmem/lowmem, available/reserved, etc) are considered
+	 * as present, so inform sparsemem about them.
+	 */
+	memblocks_present();
 
 	/*
 	 * Reserve initrd memory if needed.
@@ -528,8 +393,9 @@ static int __init early_parse_mem(char *p)
 	 * size.
 	 */
 	if (usermem == 0) {
-		boot_mem_map.nr_map = 0;
 		usermem = 1;
+		memblock_remove(memblock_start_of_DRAM(),
+			memblock_end_of_DRAM() - memblock_start_of_DRAM());
 	}
 	start = 0;
 	size = memparse(p, &p);
@@ -586,14 +452,13 @@ early_param("memmap", early_parse_memmap);
 unsigned long setup_elfcorehdr, setup_elfcorehdr_size;
 static int __init early_parse_elfcorehdr(char *p)
 {
-	int i;
+	struct memblock_region *mem;
 
 	setup_elfcorehdr = memparse(p, &p);
 
-	for (i = 0; i < boot_mem_map.nr_map; i++) {
-		unsigned long start = boot_mem_map.map[i].addr;
-		unsigned long end = (boot_mem_map.map[i].addr +
-				     boot_mem_map.map[i].size);
+	 for_each_memblock(memory, mem) {
+		unsigned long start = mem->base;
+		unsigned long end = mem->end;
 		if (setup_elfcorehdr >= start && setup_elfcorehdr < end) {
 			/*
 			 * Reserve from the elf core header to the end of
@@ -613,47 +478,20 @@ static int __init early_parse_elfcorehdr(char *p)
 early_param("elfcorehdr", early_parse_elfcorehdr);
 #endif
 
-static void __init arch_mem_addpart(phys_addr_t mem, phys_addr_t end, int type)
-{
-	phys_addr_t size;
-	int i;
-
-	size = end - mem;
-	if (!size)
-		return;
-
-	/* Make sure it is in the boot_mem_map */
-	for (i = 0; i < boot_mem_map.nr_map; i++) {
-		if (mem >= boot_mem_map.map[i].addr &&
-		    mem < (boot_mem_map.map[i].addr +
-			   boot_mem_map.map[i].size))
-			return;
-	}
-	add_memory_region(mem, size, type);
-}
-
 #ifdef CONFIG_KEXEC
-static inline unsigned long long get_total_mem(void)
-{
-	unsigned long long total;
-
-	total = max_pfn - min_low_pfn;
-	return total << PAGE_SHIFT;
-}
-
 static void __init mips_parse_crashkernel(void)
 {
 	unsigned long long total_mem;
 	unsigned long long crash_size, crash_base;
 	int ret;
 
-	total_mem = get_total_mem();
+	total_mem = memblock_phys_mem_size();
 	ret = parse_crashkernel(boot_command_line, total_mem,
 				&crash_size, &crash_base);
 	if (ret != 0 || crash_size <= 0)
 		return;
 
-	if (!memory_region_available(crash_base, crash_size)) {
+	if (!memblock_find_in_range(crash_base, crash_base + crash_size, crash_size, 0)) {
 		pr_warn("Invalid memory region reserved for crash kernel\n");
 		return;
 	}
@@ -686,6 +524,17 @@ static void __init request_crashkernel(struct resource *res)
 }
 #endif /* !defined(CONFIG_KEXEC)  */
 
+static void __init check_kernel_sections_mem(void)
+{
+	phys_addr_t start = PFN_PHYS(PFN_DOWN(__pa_symbol(&_text)));
+	phys_addr_t size = PFN_PHYS(PFN_UP(__pa_symbol(&_end))) - start;
+
+	if (!memblock_is_region_memory(start, size)) {
+		pr_info("Kernel sections are not in the memory maps\n");
+		memblock_add(start, size);
+	}
+}
+
 #define USE_PROM_CMDLINE	IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_BOOTLOADER)
 #define USE_DTB_CMDLINE		IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_DTB)
 #define EXTEND_WITH_PROM	IS_ENABLED(CONFIG_MIPS_CMDLINE_DTB_EXTEND)
@@ -731,25 +580,6 @@ static void __init arch_mem_init(char **cmdline_p)
 	plat_mem_setup();
 	memblock_set_bottom_up(true);
 
-	/*
-	 * Make sure all kernel memory is in the maps.  The "UP" and
-	 * "DOWN" are opposite for initdata since if it crosses over
-	 * into another memory section you don't want that to be
-	 * freed when the initdata is freed.
-	 */
-	arch_mem_addpart(PFN_DOWN(__pa_symbol(&_text)) << PAGE_SHIFT,
-			 PFN_UP(__pa_symbol(&_edata)) << PAGE_SHIFT,
-			 BOOT_MEM_RAM);
-	arch_mem_addpart(PFN_UP(__pa_symbol(&__init_begin)) << PAGE_SHIFT,
-			 PFN_DOWN(__pa_symbol(&__init_end)) << PAGE_SHIFT,
-			 BOOT_MEM_INIT_RAM);
-	arch_mem_addpart(PFN_DOWN(__pa_symbol(&__bss_start)) << PAGE_SHIFT,
-			 PFN_UP(__pa_symbol(&__bss_stop)) << PAGE_SHIFT,
-			 BOOT_MEM_RAM);
-
-	pr_info("Determined physical RAM map:\n");
-	print_memory_map();
-
 #if defined(CONFIG_CMDLINE_BOOL) && defined(CONFIG_CMDLINE_OVERRIDE)
 	strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
 #else
@@ -783,14 +613,17 @@ static void __init arch_mem_init(char **cmdline_p)
 
 	parse_early_param();
 
-	if (usermem) {
-		pr_info("User-defined physical RAM map:\n");
-		print_memory_map();
-	}
+	if (usermem)
+		pr_info("User-defined physical RAM map overwrite\n");
+
+	check_kernel_sections_mem();
 
 	early_init_fdt_reserve_self();
 	early_init_fdt_scan_reserved_mem();
 
+#ifndef CONFIG_NUMA
+	memblock_set_node(0, PHYS_ADDR_MAX, &memblock.memory, 0);
+#endif
 	bootmem_init();
 
 	/*
@@ -830,12 +663,12 @@ static void __init arch_mem_init(char **cmdline_p)
 
 	memblock_dump_all();
 
-	early_memtest(PFN_PHYS(min_low_pfn), PFN_PHYS(max_low_pfn));
+	early_memtest(PFN_PHYS(ARCH_PFN_OFFSET), PFN_PHYS(max_low_pfn));
 }
 
 static void __init resource_init(void)
 {
-	int i;
+	struct memblock_region *region;
 
 	if (UNCAC_BASE != IO_BASE)
 		return;
@@ -847,16 +680,10 @@ static void __init resource_init(void)
 	bss_resource.start = __pa_symbol(&__bss_start);
 	bss_resource.end = __pa_symbol(&__bss_stop) - 1;
 
-	for (i = 0; i < boot_mem_map.nr_map; i++) {
+	for_each_memblock(memory, region) {
+		phys_addr_t start = PFN_PHYS(memblock_region_memory_base_pfn(region));
+		phys_addr_t end = PFN_PHYS(memblock_region_memory_end_pfn(region)) - 1;
 		struct resource *res;
-		unsigned long start, end;
-
-		start = boot_mem_map.map[i].addr;
-		end = boot_mem_map.map[i].addr + boot_mem_map.map[i].size - 1;
-		if (start >= HIGHMEM_START)
-			continue;
-		if (end >= HIGHMEM_START)
-			end = HIGHMEM_START - 1;
 
 		res = memblock_alloc(sizeof(struct resource), SMP_CACHE_BYTES);
 		if (!res)
@@ -865,20 +692,8 @@ static void __init resource_init(void)
 
 		res->start = start;
 		res->end = end;
-		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
-
-		switch (boot_mem_map.map[i].type) {
-		case BOOT_MEM_RAM:
-		case BOOT_MEM_INIT_RAM:
-		case BOOT_MEM_ROM_DATA:
-			res->name = "System RAM";
-			res->flags |= IORESOURCE_SYSRAM;
-			break;
-		case BOOT_MEM_RESERVED:
-		case BOOT_MEM_NOMAP:
-		default:
-			res->name = "reserved";
-		}
+		res->flags = IORESOURCE_SYSTEM_RAM | IORESOURCE_BUSY;
+		res->name = "System RAM";
 
 		request_resource(&iomem_resource, res);
 

commit 3751cbda8f223549d7ea28803cbec8ac87e43ed2
Author: Serge Semin <fancer.lancer@gmail.com>
Date:   Fri May 3 20:50:41 2019 +0300

    mips: Manually call fdt_init_reserved_mem() method
    
    Since memblock-patchset was introduced the reserved-memory nodes are
    supported being declared in dt-files. So these nodes are actually parsed
    during the arch setup procedure when the early_init_fdt_scan_reserved_mem()
    method is called. But due to the arch-specific boot mem_map container
    utilization we need to manually call the fdt_init_reserved_mem() method
    after all the available and reserved memory has been moved to memblock.
    The first function call performed before bootmem_init() by the
    early_init_fdt_scan_reserved_mem() routine fails due to the lack of any
    memblock memory regions to allocate from at that stage.
    
    Signed-off-by: Serge Semin <fancer.lancer@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Serge Semin <Sergey.Semin@t-platforms.ru>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index fbd216b4e929..ab349d2381c3 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -27,6 +27,7 @@
 #include <linux/dma-contiguous.h>
 #include <linux/decompress/generic.h>
 #include <linux/of_fdt.h>
+#include <linux/of_reserved_mem.h>
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
@@ -825,6 +826,8 @@ static void __init arch_mem_init(char **cmdline_p)
 	memblock_reserve(__pa_symbol(&__nosave_begin),
 		__pa_symbol(&__nosave_end) - __pa_symbol(&__nosave_begin));
 
+	fdt_init_reserved_mem();
+
 	memblock_dump_all();
 
 	early_memtest(PFN_PHYS(min_low_pfn), PFN_PHYS(max_low_pfn));

commit 2f5bd0367e7a9e5f5a150500e016a9cb7042803b
Author: Serge Semin <fancer.lancer@gmail.com>
Date:   Fri May 3 20:50:38 2019 +0300

    mips: Perform early low memory test
    
    memblock subsystem provides a method to optionally test the passed
    memory region in case if it was requested via special kernel boot
    argument. Lets add the function at the bottom of the arch_mem_init()
    method. Testing at this point in the boot sequence should be safe since all
    critical areas are now reserved and a minimum of allocations have been
    done.
    
    Reviewed-by: Matt Redfearn <matt.redfearn@mips.com>
    Signed-off-by: Serge Semin <fancer.lancer@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Serge Semin <Sergey.Semin@t-platforms.ru>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index ca493fdf69b0..fbd216b4e929 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -826,6 +826,8 @@ static void __init arch_mem_init(char **cmdline_p)
 		__pa_symbol(&__nosave_end) - __pa_symbol(&__nosave_begin));
 
 	memblock_dump_all();
+
+	early_memtest(PFN_PHYS(min_low_pfn), PFN_PHYS(max_low_pfn));
 }
 
 static void __init resource_init(void)

commit 30c8f4e411fb76f752a193bd945d4b9ef06c2d87
Author: Serge Semin <fancer.lancer@gmail.com>
Date:   Fri May 3 20:50:37 2019 +0300

    mips: Dump memblock regions for debugging
    
    It is useful to have the whole memblock memory space printed to console
    when basic memlock initializations are done. It can be performed by
    ready-to-use method memblock_dump_all(), which prints the available
    and reserved memory spaces if memblock=debug kernel parameter is
    specified. Lets call it at the very end of arch_mem_init() function,
    when all memblock memory and reserved regions are defined, but before
    any serious allocation is performed.
    
    Signed-off-by: Serge Semin <fancer.lancer@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: Serge Semin <Sergey.Semin@t-platforms.ru>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 2a1b2e7a1bc9..ca493fdf69b0 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -824,6 +824,8 @@ static void __init arch_mem_init(char **cmdline_p)
 	/* Reserve for hibernation. */
 	memblock_reserve(__pa_symbol(&__nosave_begin),
 		__pa_symbol(&__nosave_end) - __pa_symbol(&__nosave_begin));
+
+	memblock_dump_all();
 }
 
 static void __init resource_init(void)

commit 9b9a59db84812d326af41a3802c63f1f95d81016
Author: Serge Semin <fancer.lancer@gmail.com>
Date:   Wed Apr 24 01:47:43 2019 +0300

    mips: Add reserve-nomap memory type support
    
    It might be necessary to prevent the virtual mapping creation for a
    requested memory region. For instance there is a "no-map" property
    indicating exactly this feature. In this case we need to not only
    reserve the specified region by pretending it doesn't exist in the
    memory space, but completely remove the range from system just by
    removing it from memblock. The same way it's done in default
    early_init_dt_reserve_memory_arch() method.
    
    Signed-off-by: Serge Semin <fancer.lancer@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Matt Redfearn <matt.redfearn@mips.com>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 3a5140943f54..2a1b2e7a1bc9 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -178,6 +178,7 @@ static bool __init __maybe_unused memory_region_available(phys_addr_t start,
 				in_ram = true;
 			break;
 		case BOOT_MEM_RESERVED:
+		case BOOT_MEM_NOMAP:
 			if ((start >= start_ && start < end_) ||
 			    (start < start_ && start + size >= start_))
 				free = false;
@@ -213,6 +214,9 @@ static void __init print_memory_map(void)
 		case BOOT_MEM_RESERVED:
 			printk(KERN_CONT "(reserved)\n");
 			break;
+		case BOOT_MEM_NOMAP:
+			printk(KERN_CONT "(nomap)\n");
+			break;
 		default:
 			printk(KERN_CONT "type %lu\n", boot_mem_map.map[i].type);
 			break;
@@ -487,6 +491,9 @@ static void __init bootmem_init(void)
 		switch (boot_mem_map.map[i].type) {
 		case BOOT_MEM_RAM:
 			break;
+		case BOOT_MEM_NOMAP: /* Discard the range from the system. */
+			memblock_remove(PFN_PHYS(start), PFN_PHYS(end - start));
+			continue;
 		default: /* Reserve the rest of the memory types at boot time */
 			memblock_reserve(PFN_PHYS(start), PFN_PHYS(end - start));
 			break;
@@ -861,6 +868,7 @@ static void __init resource_init(void)
 			res->flags |= IORESOURCE_SYSRAM;
 			break;
 		case BOOT_MEM_RESERVED:
+		case BOOT_MEM_NOMAP:
 		default:
 			res->name = "reserved";
 		}

commit 4e50a35de4ccc834dbc32c664fb068f4c24cfebf
Author: Serge Semin <fancer.lancer@gmail.com>
Date:   Wed Apr 24 01:47:42 2019 +0300

    mips: Use memblock to reserve the __nosave memory range
    
    Originally before legacy bootmem was removed, the memory for the range was
    correctly reserved by reserve_bootmem_region(). But since memblock has been
    selected for early memory allocation the function can be utilized only
    after paging is fully initialized (as it is done by memblock_free_all()
    function). So calling it from arch_mem_init() method is prone to errors,
    and at this stage we need to reserve the memory in the memblock allocator.
    
    Signed-off-by: Serge Semin <fancer.lancer@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Matt Redfearn <matt.redfearn@mips.com>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 2ae6b02b948f..3a5140943f54 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -814,8 +814,9 @@ static void __init arch_mem_init(char **cmdline_p)
 
 	dma_contiguous_reserve(PFN_PHYS(max_low_pfn));
 
-	reserve_bootmem_region(__pa_symbol(&__nosave_begin),
-			__pa_symbol(&__nosave_end)); /* Reserve for hibernation */
+	/* Reserve for hibernation. */
+	memblock_reserve(__pa_symbol(&__nosave_begin),
+		__pa_symbol(&__nosave_end) - __pa_symbol(&__nosave_begin));
 }
 
 static void __init resource_init(void)

commit eadb6925efeb0c254d17e1da9bb730d2add5613d
Author: Serge Semin <fancer.lancer@gmail.com>
Date:   Wed Apr 24 01:47:41 2019 +0300

    mips: Discard post-CMA-init foreach loop
    
    Really the loop is pointless, since it walks over memblock-reserved
    memory regions and mark them as reserved in memblock. Before
    bootmem was removed from the kernel, this loop had been
    used to map the memory reserved by CMA into the legacy bootmem
    allocator. But now the early memory allocator is memblock,
    which is used by CMA for reservation, so we don't need any mapping
    anymore.
    
    Reviewed-by: Matt Redfearn <matt.redfearn@mips.com>
    Signed-off-by: Serge Semin <fancer.lancer@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index f71a7d32a687..2ae6b02b948f 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -708,7 +708,6 @@ static void __init request_crashkernel(struct resource *res)
  */
 static void __init arch_mem_init(char **cmdline_p)
 {
-	struct memblock_region *reg;
 	extern void plat_mem_setup(void);
 
 	/*
@@ -814,10 +813,6 @@ static void __init arch_mem_init(char **cmdline_p)
 	plat_swiotlb_setup();
 
 	dma_contiguous_reserve(PFN_PHYS(max_low_pfn));
-	/* Tell bootmem about cma reserved memblock section */
-	for_each_memblock(reserved, reg)
-		if (reg->size != 0)
-			memblock_reserve(reg->base, reg->size);
 
 	reserve_bootmem_region(__pa_symbol(&__nosave_begin),
 			__pa_symbol(&__nosave_end)); /* Reserve for hibernation */

commit b93ddc4f9156205eb3c8df6ad35a37be3fa4e31e
Author: Serge Semin <fancer.lancer@gmail.com>
Date:   Wed Apr 24 01:47:40 2019 +0300

    mips: Reserve memory for the kernel image resources
    
    The reserved_end variable had been used by the bootmem_init() code
    to find a lowest limit of memory available for memmap blob. The original
    code just tried to find a free memory space higher than kernel was placed.
    This limitation seems justified for the memmap ragion search process, but
    I can't see any obvious reason to reserve the unused space below kernel
    seeing some platforms place it much higher than standard 1MB. Moreover
    the RELOCATION config enables it to be loaded at any memory address.
    So lets reserve the memory occupied by the kernel only, leaving the region
    below being free for allocations. After doing this we can now discard the
    code freeing a space between kernel _text and VMLINUX_LOAD_ADDRESS symbols
    since it's going to be free anyway (unless marked as reserved by
    platforms).
    
    Signed-off-by: Serge Semin <fancer.lancer@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Matt Redfearn <matt.redfearn@mips.com>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 185e0e42e009..f71a7d32a687 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -371,7 +371,6 @@ static void __init bootmem_init(void)
 
 static void __init bootmem_init(void)
 {
-	unsigned long reserved_end;
 	phys_addr_t ramstart = PHYS_ADDR_MAX;
 	int i;
 
@@ -382,10 +381,10 @@ static void __init bootmem_init(void)
 	 * will reserve the area used for the initrd.
 	 */
 	init_initrd();
-	reserved_end = (unsigned long) PFN_UP(__pa_symbol(&_end));
 
-	memblock_reserve(PHYS_OFFSET,
-			 (reserved_end << PAGE_SHIFT) - PHYS_OFFSET);
+	/* Reserve memory occupied by kernel. */
+	memblock_reserve(__pa_symbol(&_text),
+			__pa_symbol(&_end) - __pa_symbol(&_text));
 
 	/*
 	 * max_low_pfn is not a number of pages. The number of pages
@@ -501,29 +500,6 @@ static void __init bootmem_init(void)
 		memory_present(0, start, end);
 	}
 
-#ifdef CONFIG_RELOCATABLE
-	/*
-	 * The kernel reserves all memory below its _end symbol as bootmem,
-	 * but the kernel may now be at a much higher address. The memory
-	 * between the original and new locations may be returned to the system.
-	 */
-	if (__pa_symbol(_text) > __pa_symbol(VMLINUX_LOAD_ADDRESS)) {
-		unsigned long offset;
-		extern void show_kernel_relocation(const char *level);
-
-		offset = __pa_symbol(_text) - __pa_symbol(VMLINUX_LOAD_ADDRESS);
-		memblock_free(__pa_symbol(VMLINUX_LOAD_ADDRESS), offset);
-
-#if defined(CONFIG_DEBUG_KERNEL) && defined(CONFIG_DEBUG_INFO)
-		/*
-		 * This information is necessary when debugging the kernel
-		 * But is a security vulnerability otherwise!
-		 */
-		show_kernel_relocation(KERN_INFO);
-#endif
-	}
-#endif
-
 	/*
 	 * Reserve initrd memory if needed.
 	 */

commit cf0c4876684d287b6fe72699598517ca9b827216
Author: Serge Semin <fancer.lancer@gmail.com>
Date:   Wed Apr 24 01:47:39 2019 +0300

    mips: Combine memblock init and memory reservation loops
    
    Before bootmem was completely removed from the kernel, the last loop
    in the bootmem_init() had been used to reserve the correspondingly
    marked regions, initialize sparsemem sections and to free the low memory
    pages, which then would be used for early memory allocations. After the
    bootmem removing patchset had been merged the loop was left to do the first
    two things only. But it didn't do them quite well.
    
    First of all it leaves the BOOT_MEM_INIT_RAM memory types unreserved,
    which is definitely bug (although it isn't noticeable due to being used
    by the kernel region only, which is fully marked as reserved). Secondly
    the reservation is supposed to be done for any memory including the
    high one. (I couldn't figure out why the highmem was ignored in the first
    place, since platforms and dts' may declare any memory region for
    reservation) Thirdly the reserved_end variable had been used here to not
    accidentally free memory occupied by kernel. Since we already reserved the
    corresponding region higher in this method there is no need in using the
    variable here anymore. Fourthly the sparsemem should be aware of all the
    memory types in the system including the ROM_DATA even if it is going to
    be reserved for the whole system uptime. Finally after all these notes are
    fixed the loop of memory reservation can be freely merged into the memory
    installation loop as it's done in this patch.
    
    Signed-off-by: Serge Semin <fancer.lancer@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Matt Redfearn <matt.redfearn@mips.com>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 53d93a727d1a..185e0e42e009 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -483,55 +483,21 @@ static void __init bootmem_init(void)
 			continue;
 
 		memblock_add_node(PFN_PHYS(start), PFN_PHYS(end - start), 0);
-	}
-
-	/*
-	 * Register fully available low RAM pages with the bootmem allocator.
-	 */
-	for (i = 0; i < boot_mem_map.nr_map; i++) {
-		unsigned long start, end, size;
-
-		start = PFN_UP(boot_mem_map.map[i].addr);
-		end   = PFN_DOWN(boot_mem_map.map[i].addr
-				    + boot_mem_map.map[i].size);
 
-		/*
-		 * Reserve usable memory.
-		 */
+		/* Reserve any memory except the ordinary RAM ranges. */
 		switch (boot_mem_map.map[i].type) {
 		case BOOT_MEM_RAM:
 			break;
-		case BOOT_MEM_INIT_RAM:
-			memory_present(0, start, end);
-			continue;
-		default:
-			/* Not usable memory */
-			if (start > min_low_pfn && end < max_low_pfn)
-				memblock_reserve(boot_mem_map.map[i].addr,
-						boot_mem_map.map[i].size);
-
-			continue;
+		default: /* Reserve the rest of the memory types at boot time */
+			memblock_reserve(PFN_PHYS(start), PFN_PHYS(end - start));
+			break;
 		}
 
 		/*
-		 * We are rounding up the start address of usable memory
-		 * and at the end of the usable range downwards.
-		 */
-		if (start >= max_low_pfn)
-			continue;
-		if (start < reserved_end)
-			start = reserved_end;
-		if (end > max_low_pfn)
-			end = max_low_pfn;
-
-		/*
-		 * ... finally, is the area going away?
+		 * In any case the added to the memblock memory regions
+		 * (highmem/lowmem, available/reserved, etc) are considered
+		 * as present, so inform sparsemem about them.
 		 */
-		if (end <= start)
-			continue;
-		size = end - start;
-
-		/* Register lowmem ranges */
 		memory_present(0, start, end);
 	}
 

commit 6ea3ba6fac31380af86339c37be095a672dd01bb
Author: Serge Semin <fancer.lancer@gmail.com>
Date:   Wed Apr 24 01:47:38 2019 +0300

    mips: Discard rudiments from bootmem_init
    
    There is a pointless code left in the bootmem_init() method since
    the bootmem allocator removal. First part resides the PFN ranges
    calculation loop. The conditional expressions and continue operator
    are useless there, since nothing is done after them. Second part is
    in RAM ranges installation loop. We can simplify the conditions cascade
    a bit without much of the logic redefinition, so to reduce the code
    length. In particular the end boundary value can be verified after
    the possible reduction to be below max_low_pfn.
    
    Signed-off-by: Serge Semin <fancer.lancer@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Matt Redfearn <matt.redfearn@mips.com>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 0ee033c44116..53d93a727d1a 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -394,10 +394,7 @@ static void __init bootmem_init(void)
 	min_low_pfn = ~0UL;
 	max_low_pfn = 0;
 
-	/*
-	 * Find the highest page frame number we have available
-	 * and the lowest used RAM address
-	 */
+	/* Find the highest and lowest page frame numbers we have available. */
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long start, end;
 
@@ -427,13 +424,6 @@ static void __init bootmem_init(void)
 			max_low_pfn = end;
 		if (start < min_low_pfn)
 			min_low_pfn = start;
-		if (end <= reserved_end)
-			continue;
-#ifdef CONFIG_BLK_DEV_INITRD
-		/* Skip zones before initrd and initrd itself */
-		if (initrd_end && end <= (unsigned long)PFN_UP(__pa(initrd_end)))
-			continue;
-#endif
 	}
 
 	if (min_low_pfn >= max_low_pfn)
@@ -474,6 +464,7 @@ static void __init bootmem_init(void)
 		max_low_pfn = PFN_DOWN(HIGHMEM_START);
 	}
 
+	/* Install all valid RAM ranges to the memblock memory region */
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long start, end;
 
@@ -481,21 +472,15 @@ static void __init bootmem_init(void)
 		end = PFN_DOWN(boot_mem_map.map[i].addr
 				+ boot_mem_map.map[i].size);
 
-		if (start <= min_low_pfn)
+		if (start < min_low_pfn)
 			start = min_low_pfn;
-		if (start >= end)
-			continue;
-
 #ifndef CONFIG_HIGHMEM
+		/* Ignore highmem regions if highmem is unsupported */
 		if (end > max_low_pfn)
 			end = max_low_pfn;
-
-		/*
-		 * ... finally, is the area going away?
-		 */
+#endif
 		if (end <= start)
 			continue;
-#endif
 
 		memblock_add_node(PFN_PHYS(start), PFN_PHYS(end - start), 0);
 	}

commit a703db3d5b4b43cb7e46b65a661471015cbcba57
Author: Serge Semin <fancer.lancer@gmail.com>
Date:   Wed Apr 24 01:47:37 2019 +0300

    mips: Make sure kernel .bss exists in boot mem pool
    
    Current MIPS platform code makes sure the kernel text, data and init
    sections are added to the boot memory map pool right after the
    arch-specific memory setup method has been executed. But for some reason
    the MIPS platform code skipped the kernel .bss section, which definitely
    should be in the boot mem pool as well in any case. Lets fix this just be
    adding the space between __bss_start and __bss_stop.
    
    Reviewed-by: Matt Redfearn <matt.redfearn@mips.com>
    Signed-off-by: Serge Semin <fancer.lancer@gmail.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Mike Rapoport <rppt@linux.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Stefan Agner <stefan@agner.ch>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Alexandre Belloni <alexandre.belloni@bootlin.com>
    Cc: Juergen Gross <jgross@suse.com>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 8d1dc6c71173..0ee033c44116 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -809,6 +809,9 @@ static void __init arch_mem_init(char **cmdline_p)
 	arch_mem_addpart(PFN_UP(__pa_symbol(&__init_begin)) << PAGE_SHIFT,
 			 PFN_DOWN(__pa_symbol(&__init_end)) << PAGE_SHIFT,
 			 BOOT_MEM_INIT_RAM);
+	arch_mem_addpart(PFN_DOWN(__pa_symbol(&__bss_start)) << PAGE_SHIFT,
+			 PFN_UP(__pa_symbol(&__bss_stop)) << PAGE_SHIFT,
+			 BOOT_MEM_RAM);
 
 	pr_info("Determined physical RAM map:\n");
 	print_memory_map();

commit 8a7f97b902f4fb0d94b355b6b3f1fbd7154cafb9
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Mar 11 23:30:31 2019 -0700

    treewide: add checks for the return value of memblock_alloc*()
    
    Add check for the return value of memblock_alloc*() functions and call
    panic() in case of error.  The panic message repeats the one used by
    panicing memblock allocators with adjustment of parameters to include
    only relevant ones.
    
    The replacement was mostly automated with semantic patches like the one
    below with manual massaging of format strings.
    
      @@
      expression ptr, size, align;
      @@
      ptr = memblock_alloc(size, align);
      + if (!ptr)
      +     panic("%s: Failed to allocate %lu bytes align=0x%lx\n", __func__, size, align);
    
    [anders.roxell@linaro.org: use '%pa' with 'phys_addr_t' type]
      Link: http://lkml.kernel.org/r/20190131161046.21886-1-anders.roxell@linaro.org
    [rppt@linux.ibm.com: fix format strings for panics after memblock_alloc]
      Link: http://lkml.kernel.org/r/1548950940-15145-1-git-send-email-rppt@linux.ibm.com
    [rppt@linux.ibm.com: don't panic if the allocation in sparse_buffer_init fails]
      Link: http://lkml.kernel.org/r/20190131074018.GD28876@rapoport-lnx
    [akpm@linux-foundation.org: fix xtensa printk warning]
    Link: http://lkml.kernel.org/r/1548057848-15136-20-git-send-email-rppt@linux.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Anders Roxell <anders.roxell@linaro.org>
    Reviewed-by: Guo Ren <ren_guo@c-sky.com>                [c-sky]
    Acked-by: Paul Burton <paul.burton@mips.com>            [MIPS]
    Acked-by: Heiko Carstens <heiko.carstens@de.ibm.com>    [s390]
    Reviewed-by: Juergen Gross <jgross@suse.com>            [Xen]
    Reviewed-by: Geert Uytterhoeven <geert@linux-m68k.org>  [m68k]
    Acked-by: Max Filippov <jcmvbkbc@gmail.com>             [xtensa]
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Christophe Leroy <christophe.leroy@c-s.fr>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Dennis Zhou <dennis@kernel.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 5151532ad959..8d1dc6c71173 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -919,6 +919,9 @@ static void __init resource_init(void)
 			end = HIGHMEM_START - 1;
 
 		res = memblock_alloc(sizeof(struct resource), SMP_CACHE_BYTES);
+		if (!res)
+			panic("%s: Failed to allocate %zu bytes\n", __func__,
+			      sizeof(struct resource));
 
 		res->start = start;
 		res->end = end;

commit d9862cfbe2099deb83f0e9c1932c91f2d9c50464
Merge: 8feed3efa802 aeb669d41ffa
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 5 11:28:25 2019 -0800

    Merge tag 'mips_5.1' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux
    
    Pull MIPS updates from Paul Burton:
    
     - Support for the MIPSr6 MemoryMapID register & Global INValidate TLB
       (GINVT) instructions, allowing for more efficient TLB maintenance
       when running on a CPU such as the I6500 that supports these.
    
     - Enable huge page support for MIPS64r6.
    
     - Optimize post-DMA cache sync by removing that code entirely for
       kernel configurations in which we know it won't be needed.
    
     - The number of pages allocated for interrupt stacks is now calculated
       correctly, where before we would wastefully allocate too much memory
       in some configurations.
    
     - The ath79 platform migrates to devicetree.
    
     - The bcm47xx platform sees fixes for the Buffalo WHR-G54S board.
    
     - The ingenic/jz4740 platform gains support for appended devicetrees.
    
     - The cavium_octeon, lantiq, loongson32 & sgi-ip27 platforms all see
       cleanups as do various pieces of core architecture code.
    
    * tag 'mips_5.1' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux: (66 commits)
      MIPS: lantiq: Remove separate GPHY Firmware loader
      MIPS: ingenic: Add support for appended devicetree
      MIPS: SGI-IP27: rework HUB interrupts
      MIPS: SGI-IP27: do boot CPU init later
      MIPS: SGI-IP27: do xtalk scanning later
      MIPS: SGI-IP27: use pr_info/pr_emerg and pr_cont to fix output
      MIPS: SGI-IP27: clean up bridge access and header files
      MIPS: SGI-IP27: get rid of volatile and hubreg_t
      MIPS: irq: Allocate accurate order pages for irq stack
      MIPS: dma-noncoherent: Remove bogus condition in dma_sync_phys()
      MIPS: eBPF: Remove REG_32BIT_ZERO_EX
      MIPS: eBPF: Always return sign extended 32b values
      MIPS: CM: Fix indentation
      MIPS: BCM47XX: Fix/improve Buffalo WHR-G54S support
      MIPS: OCTEON: program rx/tx-delay always from DT
      MIPS: OCTEON: delete board-specific link status
      MIPS: OCTEON: don't lie about interface type of CN3005 board
      MIPS: OCTEON: warn if deprecated link status is being used
      MIPS: OCTEON: add fixed-link nodes to in-kernel device tree
      MIPS: Delete unused flush_cache_sigtramp()
      ...

commit e0bf304e4a00d66d90904a6c5b93141f177cf6d2
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Wed Feb 27 10:42:56 2019 +0100

    MIPS: fix memory setup for platforms with PHYS_OFFSET != 0
    
    For platforms, which use a PHYS_OFFSET != 0, symbol _end also
    contains that offset. So when calling memblock_reserve() for
    reserving kernel the size argument needs to be adjusted.
    
    Fixes: bcec54bf3118 ("mips: switch to NO_BOOTMEM")
    Acked-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: stable@vger.kernel.org # v4.20+

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 8c6c48ed786a..d2e5a5ad0e6f 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -384,7 +384,8 @@ static void __init bootmem_init(void)
 	init_initrd();
 	reserved_end = (unsigned long) PFN_UP(__pa_symbol(&_end));
 
-	memblock_reserve(PHYS_OFFSET, reserved_end << PAGE_SHIFT);
+	memblock_reserve(PHYS_OFFSET,
+			 (reserved_end << PAGE_SHIFT) - PHYS_OFFSET);
 
 	/*
 	 * max_low_pfn is not a number of pages. The number of pages

commit d8140426bc39f7d4f00f6d55e1e7f269a3762ffa
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Tue Jan 22 15:57:42 2019 +0100

    mips: kernel: no need to check return value of debugfs_create functions
    
    When calling debugfs functions, there is no need to ever check the
    return value.  The function can work or not, but the code logic should
    never do something different based on this.
    
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Yangtao Li <tiny.windzz@gmail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Mathieu Malaterre <malat@debian.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Marcin Nowakowski <marcin.nowakowski@mips.com>
    Cc: Yasha Cherikovsky <yasha.che3@gmail.com>
    Cc: linux-mips@vger.kernel.org
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Paul Burton <paul.burton@mips.com>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 8c6c48ed786a..44434e50a355 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -1010,12 +1010,7 @@ unsigned long fw_passed_dtb;
 struct dentry *mips_debugfs_dir;
 static int __init debugfs_mips(void)
 {
-	struct dentry *d;
-
-	d = debugfs_create_dir("mips", NULL);
-	if (!d)
-		return -ENOMEM;
-	mips_debugfs_dir = d;
+	mips_debugfs_dir = debugfs_create_dir("mips", NULL);
 	return 0;
 }
 arch_initcall(debugfs_mips);

commit 25517ed4e99b3be4244dfd61d1e5c753b09faf2c
Author: Huacai Chen <chenhc@lemote.com>
Date:   Sat Nov 10 11:50:14 2018 +0800

    MIPS: Let early memblock_alloc*() allocate memories bottom-up
    
    After switched to NO_BOOTMEM, there are several boot failures. Some of
    them have been fixed and some of them haven't. I find that many of them
    are because of memory allocations are top-down, while the old behavior
    is bottom-up. This patch let early memblock_alloc*() allocate memories
    bottom-up to avoid some potential problems.
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Fixes: bcec54bf3118 ("mips: switch to NO_BOOTMEM")
    Patchwork: https://patchwork.linux-mips.org/patch/21069/
    References: https://patchwork.linux-mips.org/patch/21031/
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <james.hogan@mips.com>
    Cc: Steven J . Hill <Steven.Hill@cavium.com>
    Cc: linux-mips@linux-mips.org
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index ea09ed6a80a9..8c6c48ed786a 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -794,6 +794,7 @@ static void __init arch_mem_init(char **cmdline_p)
 
 	/* call board setup routine */
 	plat_mem_setup();
+	memblock_set_bottom_up(true);
 
 	/*
 	 * Make sure all kernel memory is in the maps.  The "UP" and

commit 7e1c4e27928e5f87b9b1eaf06dc31773b2f1e7f1
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:57 2018 -0700

    memblock: stop using implicit alignment to SMP_CACHE_BYTES
    
    When a memblock allocation APIs are called with align = 0, the alignment
    is implicitly set to SMP_CACHE_BYTES.
    
    Implicit alignment is done deep in the memblock allocator and it can
    come as a surprise.  Not that such an alignment would be wrong even
    when used incorrectly but it is better to be explicit for the sake of
    clarity and the prinicple of the least surprise.
    
    Replace all such uses of memblock APIs with the 'align' parameter
    explicitly set to SMP_CACHE_BYTES and stop implicit alignment assignment
    in the memblock internal allocation functions.
    
    For the case when memblock APIs are used via helper functions, e.g.  like
    iommu_arena_new_node() in Alpha, the helper functions were detected with
    Coccinelle's help and then manually examined and updated where
    appropriate.
    
    The direct memblock APIs users were updated using the semantic patch below:
    
    @@
    expression size, min_addr, max_addr, nid;
    @@
    (
    |
    - memblock_alloc_try_nid_raw(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_raw(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid_nopanic(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid_nopanic(size, SMP_CACHE_BYTES, min_addr, max_addr,
    nid)
    |
    - memblock_alloc_try_nid(size, 0, min_addr, max_addr, nid)
    + memblock_alloc_try_nid(size, SMP_CACHE_BYTES, min_addr, max_addr, nid)
    |
    - memblock_alloc(size, 0)
    + memblock_alloc(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_raw(size, 0)
    + memblock_alloc_raw(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from(size, 0, min_addr)
    + memblock_alloc_from(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_nopanic(size, 0)
    + memblock_alloc_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low(size, 0)
    + memblock_alloc_low(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_low_nopanic(size, 0)
    + memblock_alloc_low_nopanic(size, SMP_CACHE_BYTES)
    |
    - memblock_alloc_from_nopanic(size, 0, min_addr)
    + memblock_alloc_from_nopanic(size, SMP_CACHE_BYTES, min_addr)
    |
    - memblock_alloc_node(size, 0, nid)
    + memblock_alloc_node(size, SMP_CACHE_BYTES, nid)
    )
    
    [mhocko@suse.com: changelog update]
    [akpm@linux-foundation.org: coding-style fixes]
    [rppt@linux.ibm.com: fix missed uses of implicit alignment]
      Link: http://lkml.kernel.org/r/20181016133656.GA10925@rapoport-lnx
    Link: http://lkml.kernel.org/r/1538687224-17535-1-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Suggested-by: Michal Hocko <mhocko@suse.com>
    Acked-by: Paul Burton <paul.burton@mips.com>    [MIPS]
    Acked-by: Michael Ellerman <mpe@ellerman.id.au> [powerpc]
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 41c1683761bb..ea09ed6a80a9 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -916,7 +916,7 @@ static void __init resource_init(void)
 		if (end >= HIGHMEM_START)
 			end = HIGHMEM_START - 1;
 
-		res = memblock_alloc(sizeof(struct resource), 0);
+		res = memblock_alloc(sizeof(struct resource), SMP_CACHE_BYTES);
 
 		res->start = start;
 		res->end = end;

commit 57c8a661d95dff48dd9c2f2496139082bbaf241a
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:49 2018 -0700

    mm: remove include/linux/bootmem.h
    
    Move remaining definitions and declarations from include/linux/bootmem.h
    into include/linux/memblock.h and remove the redundant header.
    
    The includes were replaced with the semantic patch below and then
    semi-automated removal of duplicated '#include <linux/memblock.h>
    
    @@
    @@
    - #include <linux/bootmem.h>
    + #include <linux/memblock.h>
    
    [sfr@canb.auug.org.au: dma-direct: fix up for the removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181002185342.133d1680@canb.auug.org.au
    [sfr@canb.auug.org.au: powerpc: fix up for removal of linux/bootmem.h]
      Link: http://lkml.kernel.org/r/20181005161406.73ef8727@canb.auug.org.au
    [sfr@canb.auug.org.au: x86/kaslr, ACPI/NUMA: fix for linux/bootmem.h removal]
      Link: http://lkml.kernel.org/r/20181008190341.5e396491@canb.auug.org.au
    Link: http://lkml.kernel.org/r/1536927045-23536-30-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Stephen Rothwell <sfr@canb.auug.org.au>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 31522d3bc8bf..41c1683761bb 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -15,7 +15,6 @@
 #include <linux/export.h>
 #include <linux/screen_info.h>
 #include <linux/memblock.h>
-#include <linux/bootmem.h>
 #include <linux/initrd.h>
 #include <linux/root_dev.h>
 #include <linux/highmem.h>

commit 2013288f723887837d2f1cebef5fcf663b2319de
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:21 2018 -0700

    memblock: replace free_bootmem{_node} with memblock_free
    
    The free_bootmem and free_bootmem_node are merely wrappers for
    memblock_free. Replace their usage with a call to memblock_free using the
    following semantic patch:
    
    @@
    expression e1, e2, e3;
    @@
    (
    - free_bootmem(e1, e2)
    + memblock_free(e1, e2)
    |
    - free_bootmem_node(e1, e2, e3)
    + memblock_free(e2, e3)
    )
    
    Link: http://lkml.kernel.org/r/1536927045-23536-24-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Acked-by: Michal Hocko <mhocko@suse.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c1f95359d298..31522d3bc8bf 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -561,7 +561,7 @@ static void __init bootmem_init(void)
 		extern void show_kernel_relocation(const char *level);
 
 		offset = __pa_symbol(_text) - __pa_symbol(VMLINUX_LOAD_ADDRESS);
-		free_bootmem(__pa_symbol(VMLINUX_LOAD_ADDRESS), offset);
+		memblock_free(__pa_symbol(VMLINUX_LOAD_ADDRESS), offset);
 
 #if defined(CONFIG_DEBUG_KERNEL) && defined(CONFIG_DEBUG_INFO)
 		/*

commit 2a5bda5a624d6471d25e953b9adba5182ab1b51f
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:09:09 2018 -0700

    memblock: replace alloc_bootmem with memblock_alloc
    
    The alloc_bootmem(size) is a shortcut for allocation of SMP_CACHE_BYTES
    aligned memory. When the align parameter of memblock_alloc() is 0, the
    alignment is implicitly set to SMP_CACHE_BYTES and thus alloc_bootmem(size)
    and memblock_alloc(size, 0) are equivalent.
    
    The conversion is done using the following semantic patch:
    
    @@
    expression size;
    @@
    - alloc_bootmem(size)
    + memblock_alloc(size, 0)
    
    Link: http://lkml.kernel.org/r/1536927045-23536-22-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 0c997645e8f0..c1f95359d298 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -917,7 +917,7 @@ static void __init resource_init(void)
 		if (end >= HIGHMEM_START)
 			end = HIGHMEM_START - 1;
 
-		res = alloc_bootmem(sizeof(struct resource));
+		res = memblock_alloc(sizeof(struct resource), 0);
 
 		res->start = start;
 		res->end = end;

commit eb31d559f1e8390195372cd51cfb198da8bc84b9
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Tue Oct 30 15:08:04 2018 -0700

    memblock: remove _virt from APIs returning virtual address
    
    The conversion is done using
    
    sed -i 's@memblock_virt_alloc@memblock_alloc@g' \
            $(git grep -l memblock_virt_alloc)
    
    Link: http://lkml.kernel.org/r/1536927045-23536-8-git-send-email-rppt@linux.vnet.ibm.com
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Hocko <mhocko@suse.com>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Palmer Dabbelt <palmer@sifive.com>
    Cc: Paul Burton <paul.burton@mips.com>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 01a5ff4c41ff..0c997645e8f0 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -859,7 +859,7 @@ static void __init arch_mem_init(char **cmdline_p)
 	 * Prevent memblock from allocating high memory.
 	 * This cannot be done before max_low_pfn is detected, so up
 	 * to this point is possible to only reserve physical memory
-	 * with memblock_reserve; memblock_virt_alloc* can be used
+	 * with memblock_reserve; memblock_alloc* can be used
 	 * only after this point
 	 */
 	memblock_set_current_limit(PFN_PHYS(max_low_pfn));

commit cc10ad25bbca3d2925adc32d51cb7a10b837d32c
Merge: ec9c16643459 edbb4233e7ef
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 26 14:43:48 2018 -0700

    Merge tag 'mips_4.20' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux
    
    Pull MIPS updates from Paul Burton:
    
     - kexec support for the generic MIPS platform when running on a CPU
       including the MIPS Coherence Manager & related hardware.
    
     - Improvements to the definition of memory barriers used around MMIO
       accesses, and fixes in their use.
    
     - Switch to CONFIG_NO_BOOTMEM from Mike Rapoport, finally dropping
       reliance on the old bootmem code.
    
     - A number of fixes & improvements for Loongson 3 systems.
    
     - DT & config updates for the Microsemi Ocelot platform.
    
     - Workaround to enable USB power on the Netgear WNDR3400v3.
    
     - Various cleanups & fixes.
    
    * tag 'mips_4.20' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux: (51 commits)
      MIPS: Cleanup DSP ASE detection
      MIPS: dts: Change upper case to lower case
      MIPS: generic: Add Network, SPI and I2C to ocelot_defconfig
      MIPS: Loongson-3: Fix BRIDGE irq delivery problem
      MIPS: Loongson-3: Fix CPU UART irq delivery problem
      MIPS: Remove unused PREF, PREFE & PREFX macros
      MIPS: lib: Use kernel_pref & user_pref in memcpy()
      MIPS: Remove unused CAT macro
      MIPS: Add kernel_pref & user_pref helpers
      MIPS: Remove unused TTABLE macro
      MIPS: Remove unused PIC macros
      MIPS: Remove unused MOVN & MOVZ macros
      MIPS: Provide actually relaxed MMIO accessors
      MIPS: Enforce strong ordering for MMIO accessors
      MIPS: Correct `mmiowb' barrier for `wbflush' platforms
      MIPS: Define MMIO ordering barriers
      MIPS: mscc: add PCB120 to the ocelot fitImage
      MIPS: mscc: add DT for Ocelot PCB120
      MIPS: memset: Limit excessive `noreorder' assembly mode use
      MIPS: memset: Fix CPU_DADDI_WORKAROUNDS `small_fixup' regression
      ...

commit cff229491af5df946781edfbeafd43e9cf66a3b4
Merge: 13775dacca5c b9fd04262a8a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 22 18:16:03 2018 +0100

    Merge tag 'dma-mapping-4.20' of git://git.infradead.org/users/hch/dma-mapping
    
    Pull dma mapping updates from Christoph Hellwig:
     "First batch of dma-mapping changes for 4.20.
    
      There will be a second PR as some big changes were only applied just
      before the end of the merge window, and I want to give them a few more
      days in linux-next.
    
      Summary:
    
       - mostly more consolidation of the direct mapping code, including
         converting over hexagon, and merging the coherent and non-coherent
         code into a single dma_map_ops instance (me)
    
       - cleanups for the dma_configure/dma_unconfigure callchains (me)
    
       - better handling of dma_masks in odd setups (me, Alexander Duyck)
    
       - better debugging of passing vmalloc address to the DMA API (Stephen
         Boyd)
    
       - CMA command line parsing fix (He Zhe)"
    
    * tag 'dma-mapping-4.20' of git://git.infradead.org/users/hch/dma-mapping: (27 commits)
      dma-direct: respect DMA_ATTR_NO_WARN
      dma-mapping: translate __GFP_NOFAIL to DMA_ATTR_NO_WARN
      dma-direct: document the zone selection logic
      dma-debug: Check for drivers mapping invalid addresses in dma_map_single()
      dma-direct: fix return value of dma_direct_supported
      dma-mapping: move dma_default_get_required_mask under ifdef
      dma-direct: always allow dma mask <= physiscal memory size
      dma-direct: implement complete bus_dma_mask handling
      dma-direct: refine dma_direct_alloc zone selection
      dma-direct: add an explicit dma_direct_get_required_mask
      dma-mapping: make the get_required_mask method available unconditionally
      unicore32: remove swiotlb support
      Revert "dma-mapping: clear dev->dma_ops in arch_teardown_dma_ops"
      dma-mapping: support non-coherent devices in dma_common_get_sgtable
      dma-mapping: consolidate the dma mmap implementations
      dma-mapping: merge direct and noncoherent ops
      dma-mapping: move the dma_coherent flag to struct device
      MIPS: don't select DMA_MAYBE_COHERENT from DMA_PERDEV_COHERENT
      dma-mapping: add the missing ARCH_HAS_SYNC_DMA_FOR_CPU_ALL declaration
      dma-mapping: fix panic caused by passing empty cma command line argument
      ...

commit 951d223c6c16ed5d2a71a4d1f13c1e65d6882156
Author: Paul Burton <paul.burton@mips.com>
Date:   Thu Sep 27 22:59:18 2018 +0000

    MIPS: Fix CONFIG_CMDLINE handling
    
    Commit 8ce355cf2e38 ("MIPS: Setup boot_command_line before
    plat_mem_setup") fixed a problem for systems which have
    CONFIG_CMDLINE_BOOL=y & use a DT with a chosen node that has either no
    bootargs property or an empty one. In this configuration
    early_init_dt_scan_chosen() copies CONFIG_CMDLINE into
    boot_command_line, but the MIPS code doesn't know this so it appends
    CONFIG_CMDLINE (via builtin_cmdline) to boot_command_line again. The
    result is that boot_command_line contains the arguments from
    CONFIG_CMDLINE twice.
    
    That commit took the approach of simply setting up boot_command_line
    from the MIPS code before early_init_dt_scan_chosen() runs, causing it
    not to copy CONFIG_CMDLINE to boot_command_line if a chosen node with no
    bootargs property is found.
    
    Unfortunately this is problematic for systems which do have a non-empty
    bootargs property & CONFIG_CMDLINE_BOOL=y. There
    early_init_dt_scan_chosen() will overwrite boot_command_line with the
    arguments from DT, which means we lose those from CONFIG_CMDLINE
    entirely. This breaks CONFIG_MIPS_CMDLINE_DTB_EXTEND. If we have
    CONFIG_MIPS_CMDLINE_FROM_BOOTLOADER or
    CONFIG_MIPS_CMDLINE_BUILTIN_EXTEND selected and the DT has a bootargs
    property which we should ignore, it will instead be honoured breaking
    those configurations too.
    
    Fix this by reverting commit 8ce355cf2e38 ("MIPS: Setup
    boot_command_line before plat_mem_setup") to restore the former
    behaviour, and fixing the CONFIG_CMDLINE duplication issue by
    initializing boot_command_line to a non-empty string that
    early_init_dt_scan_chosen() will not overwrite with CONFIG_CMDLINE.
    
    This is a little ugly, but cleanup in this area is on its way. In the
    meantime this is at least easy to backport & contains the ugliness
    within arch/mips/.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Fixes: 8ce355cf2e38 ("MIPS: Setup boot_command_line before plat_mem_setup")
    References: https://patchwork.linux-mips.org/patch/18804/
    Patchwork: https://patchwork.linux-mips.org/patch/20813/
    Cc: Frank Rowand <frowand.list@gmail.com>
    Cc: Jaedon Shin <jaedon.shin@gmail.com>
    Cc: Mathieu Malaterre <malat@debian.org>
    Cc: Rob Herring <robh+dt@kernel.org>
    Cc: devicetree@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org # v4.16+

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c71d1eb7da59..8aaaa42f91ed 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -846,6 +846,34 @@ static void __init arch_mem_init(char **cmdline_p)
 	struct memblock_region *reg;
 	extern void plat_mem_setup(void);
 
+	/*
+	 * Initialize boot_command_line to an innocuous but non-empty string in
+	 * order to prevent early_init_dt_scan_chosen() from copying
+	 * CONFIG_CMDLINE into it without our knowledge. We handle
+	 * CONFIG_CMDLINE ourselves below & don't want to duplicate its
+	 * content because repeating arguments can be problematic.
+	 */
+	strlcpy(boot_command_line, " ", COMMAND_LINE_SIZE);
+
+	/* call board setup routine */
+	plat_mem_setup();
+
+	/*
+	 * Make sure all kernel memory is in the maps.  The "UP" and
+	 * "DOWN" are opposite for initdata since if it crosses over
+	 * into another memory section you don't want that to be
+	 * freed when the initdata is freed.
+	 */
+	arch_mem_addpart(PFN_DOWN(__pa_symbol(&_text)) << PAGE_SHIFT,
+			 PFN_UP(__pa_symbol(&_edata)) << PAGE_SHIFT,
+			 BOOT_MEM_RAM);
+	arch_mem_addpart(PFN_UP(__pa_symbol(&__init_begin)) << PAGE_SHIFT,
+			 PFN_DOWN(__pa_symbol(&__init_end)) << PAGE_SHIFT,
+			 BOOT_MEM_INIT_RAM);
+
+	pr_info("Determined physical RAM map:\n");
+	print_memory_map();
+
 #if defined(CONFIG_CMDLINE_BOOL) && defined(CONFIG_CMDLINE_OVERRIDE)
 	strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
 #else
@@ -873,26 +901,6 @@ static void __init arch_mem_init(char **cmdline_p)
 	}
 #endif
 #endif
-
-	/* call board setup routine */
-	plat_mem_setup();
-
-	/*
-	 * Make sure all kernel memory is in the maps.  The "UP" and
-	 * "DOWN" are opposite for initdata since if it crosses over
-	 * into another memory section you don't want that to be
-	 * freed when the initdata is freed.
-	 */
-	arch_mem_addpart(PFN_DOWN(__pa_symbol(&_text)) << PAGE_SHIFT,
-			 PFN_UP(__pa_symbol(&_edata)) << PAGE_SHIFT,
-			 BOOT_MEM_RAM);
-	arch_mem_addpart(PFN_UP(__pa_symbol(&__init_begin)) << PAGE_SHIFT,
-			 PFN_DOWN(__pa_symbol(&__init_end)) << PAGE_SHIFT,
-			 BOOT_MEM_INIT_RAM);
-
-	pr_info("Determined physical RAM map:\n");
-	print_memory_map();
-
 	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
 
 	*cmdline_p = command_line;

commit 5748e1b35ba28368515d850e8087929a3a65e055
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Aug 16 16:47:53 2018 +0300

    MIPS: don't select DMA_MAYBE_COHERENT from DMA_PERDEV_COHERENT
    
    While both option select a form of conditional dma coherence they don't
    actually share any code in the implementation, so untangle them.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Paul Burton <paul.burton@mips.com>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c71d1eb7da59..6d840a44fa36 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -1067,7 +1067,7 @@ static int __init debugfs_mips(void)
 arch_initcall(debugfs_mips);
 #endif
 
-#if defined(CONFIG_DMA_MAYBE_COHERENT) && !defined(CONFIG_DMA_PERDEV_COHERENT)
+#ifdef CONFIG_DMA_MAYBE_COHERENT
 /* User defined DMA coherency from command line. */
 enum coherent_io_user_state coherentio = IO_COHERENCE_DEFAULT;
 EXPORT_SYMBOL_GPL(coherentio);

commit bcec54bf3118a26422cd83675cb461ef4dea81ef
Author: Mike Rapoport <rppt@linux.vnet.ibm.com>
Date:   Mon Sep 10 12:23:18 2018 +0300

    mips: switch to NO_BOOTMEM
    
    MIPS already has memblock support and all the memory is already registered
    with it.
    
    This patch replaces bootmem memory reservations with memblock ones and
    removes the bootmem initialization.
    
    Since memblock allocates memory in top-down mode, we ensure that memblock
    limit is max_low_pfn to prevent allocations from the high memory.
    
    To have the exceptions base in the lower 512M of the physical memory, its
    allocation in arch/mips/kernel/traps.c::traps_init() is using bottom-up
    mode.
    
    Signed-off-by: Mike Rapoport <rppt@linux.vnet.ibm.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/20560/
    Cc: Serge Semin <fancer.lancer@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Michal Hocko <mhocko@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-mm@kvack.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 32fc11d72ad3..2fde53ebb3af 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -333,7 +333,7 @@ static void __init finalize_initrd(void)
 
 	maybe_bswap_initrd();
 
-	reserve_bootmem(__pa(initrd_start), size, BOOTMEM_DEFAULT);
+	memblock_reserve(__pa(initrd_start), size);
 	initrd_below_start_ok = 1;
 
 	pr_info("Initial ramdisk at: 0x%lx (%lu bytes)\n",
@@ -370,20 +370,10 @@ static void __init bootmem_init(void)
 
 #else  /* !CONFIG_SGI_IP27 */
 
-static unsigned long __init bootmap_bytes(unsigned long pages)
-{
-	unsigned long bytes = DIV_ROUND_UP(pages, 8);
-
-	return ALIGN(bytes, sizeof(long));
-}
-
 static void __init bootmem_init(void)
 {
 	unsigned long reserved_end;
-	unsigned long mapstart = ~0UL;
-	unsigned long bootmap_size;
 	phys_addr_t ramstart = PHYS_ADDR_MAX;
-	bool bootmap_valid = false;
 	int i;
 
 	/*
@@ -395,6 +385,8 @@ static void __init bootmem_init(void)
 	init_initrd();
 	reserved_end = (unsigned long) PFN_UP(__pa_symbol(&_end));
 
+	memblock_reserve(PHYS_OFFSET, reserved_end << PAGE_SHIFT);
+
 	/*
 	 * max_low_pfn is not a number of pages. The number of pages
 	 * of the system is given by 'max_low_pfn - min_low_pfn'.
@@ -442,9 +434,6 @@ static void __init bootmem_init(void)
 		if (initrd_end && end <= (unsigned long)PFN_UP(__pa(initrd_end)))
 			continue;
 #endif
-		if (start >= mapstart)
-			continue;
-		mapstart = max(reserved_end, start);
 	}
 
 	if (min_low_pfn >= max_low_pfn)
@@ -456,9 +445,11 @@ static void __init bootmem_init(void)
 	/*
 	 * Reserve any memory between the start of RAM and PHYS_OFFSET
 	 */
-	if (ramstart > PHYS_OFFSET)
+	if (ramstart > PHYS_OFFSET) {
 		add_memory_region(PHYS_OFFSET, ramstart - PHYS_OFFSET,
 				  BOOT_MEM_RESERVED);
+		memblock_reserve(PHYS_OFFSET, ramstart - PHYS_OFFSET);
+	}
 
 	if (min_low_pfn > ARCH_PFN_OFFSET) {
 		pr_info("Wasting %lu bytes for tracking %lu unused pages\n",
@@ -483,52 +474,6 @@ static void __init bootmem_init(void)
 		max_low_pfn = PFN_DOWN(HIGHMEM_START);
 	}
 
-#ifdef CONFIG_BLK_DEV_INITRD
-	/*
-	 * mapstart should be after initrd_end
-	 */
-	if (initrd_end)
-		mapstart = max(mapstart, (unsigned long)PFN_UP(__pa(initrd_end)));
-#endif
-
-	/*
-	 * check that mapstart doesn't overlap with any of
-	 * memory regions that have been reserved through eg. DTB
-	 */
-	bootmap_size = bootmap_bytes(max_low_pfn - min_low_pfn);
-
-	bootmap_valid = memory_region_available(PFN_PHYS(mapstart),
-						bootmap_size);
-	for (i = 0; i < boot_mem_map.nr_map && !bootmap_valid; i++) {
-		unsigned long mapstart_addr;
-
-		switch (boot_mem_map.map[i].type) {
-		case BOOT_MEM_RESERVED:
-			mapstart_addr = PFN_ALIGN(boot_mem_map.map[i].addr +
-						boot_mem_map.map[i].size);
-			if (PHYS_PFN(mapstart_addr) < mapstart)
-				break;
-
-			bootmap_valid = memory_region_available(mapstart_addr,
-								bootmap_size);
-			if (bootmap_valid)
-				mapstart = PHYS_PFN(mapstart_addr);
-			break;
-		default:
-			break;
-		}
-	}
-
-	if (!bootmap_valid)
-		panic("No memory area to place a bootmap bitmap");
-
-	/*
-	 * Initialize the boot-time allocator with low memory only.
-	 */
-	if (bootmap_size != init_bootmem_node(NODE_DATA(0), mapstart,
-					 min_low_pfn, max_low_pfn))
-		panic("Unexpected memory size required for bootmap");
-
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long start, end;
 
@@ -577,9 +522,9 @@ static void __init bootmem_init(void)
 		default:
 			/* Not usable memory */
 			if (start > min_low_pfn && end < max_low_pfn)
-				reserve_bootmem(boot_mem_map.map[i].addr,
-						boot_mem_map.map[i].size,
-						BOOTMEM_DEFAULT);
+				memblock_reserve(boot_mem_map.map[i].addr,
+						boot_mem_map.map[i].size);
+
 			continue;
 		}
 
@@ -602,15 +547,9 @@ static void __init bootmem_init(void)
 		size = end - start;
 
 		/* Register lowmem ranges */
-		free_bootmem(PFN_PHYS(start), size << PAGE_SHIFT);
 		memory_present(0, start, end);
 	}
 
-	/*
-	 * Reserve the bootmap memory.
-	 */
-	reserve_bootmem(PFN_PHYS(mapstart), bootmap_size, BOOTMEM_DEFAULT);
-
 #ifdef CONFIG_RELOCATABLE
 	/*
 	 * The kernel reserves all memory below its _end symbol as bootmem,
@@ -907,21 +846,29 @@ static void __init arch_mem_init(char **cmdline_p)
 	early_init_fdt_scan_reserved_mem();
 
 	bootmem_init();
+
+	/*
+	 * Prevent memblock from allocating high memory.
+	 * This cannot be done before max_low_pfn is detected, so up
+	 * to this point is possible to only reserve physical memory
+	 * with memblock_reserve; memblock_virt_alloc* can be used
+	 * only after this point
+	 */
+	memblock_set_current_limit(PFN_PHYS(max_low_pfn));
+
 #ifdef CONFIG_PROC_VMCORE
 	if (setup_elfcorehdr && setup_elfcorehdr_size) {
 		printk(KERN_INFO "kdump reserved memory at %lx-%lx\n",
 		       setup_elfcorehdr, setup_elfcorehdr_size);
-		reserve_bootmem(setup_elfcorehdr, setup_elfcorehdr_size,
-				BOOTMEM_DEFAULT);
+		memblock_reserve(setup_elfcorehdr, setup_elfcorehdr_size);
 	}
 #endif
 
 	mips_parse_crashkernel();
 #ifdef CONFIG_KEXEC
 	if (crashk_res.start != crashk_res.end)
-		reserve_bootmem(crashk_res.start,
-				crashk_res.end - crashk_res.start + 1,
-				BOOTMEM_DEFAULT);
+		memblock_reserve(crashk_res.start,
+				 crashk_res.end - crashk_res.start + 1);
 #endif
 	device_tree_init();
 	sparse_init();
@@ -931,7 +878,7 @@ static void __init arch_mem_init(char **cmdline_p)
 	/* Tell bootmem about cma reserved memblock section */
 	for_each_memblock(reserved, reg)
 		if (reg->size != 0)
-			reserve_bootmem(reg->base, reg->size, BOOTMEM_DEFAULT);
+			memblock_reserve(reg->base, reg->size);
 
 	reserve_bootmem_region(__pa_symbol(&__nosave_begin),
 			__pa_symbol(&__nosave_end)); /* Reserve for hibernation */

commit 52c985acf3fe95bd7b842bace8134971f0f431a2
Author: Paul Burton <paul.burton@mips.com>
Date:   Fri Aug 31 15:28:57 2018 -0700

    MIPS: Move arch_mem_init() comment near definition
    
    The comment describing arch_mem_init() was separated from the definition
    of arch_mem_init() by commit a09fc446fb6d ("[MIPS] setup.c: use
    early_param() for early command line parsing"). Move the comment such
    that it's next to the definition again for ease of reading.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c71d1eb7da59..32fc11d72ad3 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -642,29 +642,6 @@ static void __init bootmem_init(void)
 
 #endif	/* CONFIG_SGI_IP27 */
 
-/*
- * arch_mem_init - initialize memory management subsystem
- *
- *  o plat_mem_setup() detects the memory configuration and will record detected
- *    memory areas using add_memory_region.
- *
- * At this stage the memory configuration of the system is known to the
- * kernel but generic memory management system is still entirely uninitialized.
- *
- *  o bootmem_init()
- *  o sparse_init()
- *  o paging_init()
- *  o dma_contiguous_reserve()
- *
- * At this stage the bootmem allocator is ready to use.
- *
- * NOTE: historically plat_mem_setup did the entire platform initialization.
- *	 This was rather impractical because it meant plat_mem_setup had to
- * get away without any kind of memory allocator.  To keep old code from
- * breaking plat_setup was just renamed to plat_mem_setup and a second platform
- * initialization hook for anything else was introduced.
- */
-
 static int usermem __initdata;
 
 static int __init early_parse_mem(char *p)
@@ -841,6 +818,28 @@ static void __init request_crashkernel(struct resource *res)
 #define BUILTIN_EXTEND_WITH_PROM	\
 	IS_ENABLED(CONFIG_MIPS_CMDLINE_BUILTIN_EXTEND)
 
+/*
+ * arch_mem_init - initialize memory management subsystem
+ *
+ *  o plat_mem_setup() detects the memory configuration and will record detected
+ *    memory areas using add_memory_region.
+ *
+ * At this stage the memory configuration of the system is known to the
+ * kernel but generic memory management system is still entirely uninitialized.
+ *
+ *  o bootmem_init()
+ *  o sparse_init()
+ *  o paging_init()
+ *  o dma_contiguous_reserve()
+ *
+ * At this stage the bootmem allocator is ready to use.
+ *
+ * NOTE: historically plat_mem_setup did the entire platform initialization.
+ *	 This was rather impractical because it meant plat_mem_setup had to
+ * get away without any kind of memory allocator.  To keep old code from
+ * breaking plat_setup was just renamed to plat_mem_setup and a second platform
+ * initialization hook for anything else was introduced.
+ */
 static void __init arch_mem_init(char **cmdline_p)
 {
 	struct memblock_region *reg;

commit 6c359eb1dcdb721908f4336171ed8eb6d78190c5
Author: Paul Burton <paul.burton@mips.com>
Date:   Fri Jul 27 18:23:20 2018 -0700

    MIPS: Allow auto-dection of ARCH_PFN_OFFSET & PHYS_OFFSET
    
    On systems where physical memory begins at a non-zero address, defining
    PHYS_OFFSET (which influences ARCH_PFN_OFFSET) can save us time & memory
    by avoiding book-keeping for pages from address zero to the start of
    memory.
    
    Some MIPS platforms already make use of this, but with the definition of
    PHYS_OFFSET being compile-time constant it hasn't been possible to
    enable this optimization for a kernel which may run on systems with
    varying physical memory base addresses.
    
    Introduce a new Kconfig option CONFIG_MIPS_AUTO_PFN_OFFSET which, when
    enabled, makes ARCH_PFN_OFFSET a variable & detects it from the boot
    memory map (which for example may have been populated from DT). The
    relationship with PHYS_OFFSET is reversed, with PHYS_OFFSET now being
    based on ARCH_PFN_OFFSET. This is because ARCH_PFN_OFFSET is used far
    more often, so avoiding the need for runtime calculation gives us a
    smaller impact on kernel text size (0.1% rather than 0.15% for
    64r6el_defconfig).
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Suggested-by: Vladimir Kondratiev <vladimir.kondratiev@intel.com>
    Patchwork: https://patchwork.linux-mips.org/patch/20048/
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 3d4524309b5c..c71d1eb7da59 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -85,6 +85,11 @@ static struct resource bss_resource = { .name = "Kernel bss", };
 
 static void *detect_magic __initdata = detect_memory_region;
 
+#ifdef CONFIG_MIPS_AUTO_PFN_OFFSET
+unsigned long ARCH_PFN_OFFSET;
+EXPORT_SYMBOL(ARCH_PFN_OFFSET);
+#endif
+
 void __init add_memory_region(phys_addr_t start, phys_addr_t size, long type)
 {
 	int x = boot_mem_map.nr_map;
@@ -442,6 +447,12 @@ static void __init bootmem_init(void)
 		mapstart = max(reserved_end, start);
 	}
 
+	if (min_low_pfn >= max_low_pfn)
+		panic("Incorrect memory mapping !!!");
+
+#ifdef CONFIG_MIPS_AUTO_PFN_OFFSET
+	ARCH_PFN_OFFSET = PFN_UP(ramstart);
+#else
 	/*
 	 * Reserve any memory between the start of RAM and PHYS_OFFSET
 	 */
@@ -449,8 +460,6 @@ static void __init bootmem_init(void)
 		add_memory_region(PHYS_OFFSET, ramstart - PHYS_OFFSET,
 				  BOOT_MEM_RESERVED);
 
-	if (min_low_pfn >= max_low_pfn)
-		panic("Incorrect memory mapping !!!");
 	if (min_low_pfn > ARCH_PFN_OFFSET) {
 		pr_info("Wasting %lu bytes for tracking %lu unused pages\n",
 			(min_low_pfn - ARCH_PFN_OFFSET) * sizeof(struct page),
@@ -460,6 +469,7 @@ static void __init bootmem_init(void)
 			ARCH_PFN_OFFSET - min_low_pfn);
 	}
 	min_low_pfn = ARCH_PFN_OFFSET;
+#endif
 
 	/*
 	 * Determine low and high memory ranges

commit aa4db775959a65ddbb4a5b2c886cc520614abb81
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jun 15 13:08:45 2018 +0200

    MIPS: move coherentio setup to setup.c
    
    We want to be able to use it even when not building dma-default.c
    in the near future.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Patchwork: https://patchwork.linux-mips.org/patch/19543/
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: David Daney <david.daney@cavium.com>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Jiaxun Yang <jiaxun.yang@flygoat.com>
    Cc: Tom Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: iommu@lists.linux-foundation.org
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 2c96c0c68116..3d4524309b5c 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -36,6 +36,7 @@
 #include <asm/cdmm.h>
 #include <asm/cpu.h>
 #include <asm/debug.h>
+#include <asm/dma-coherence.h>
 #include <asm/sections.h>
 #include <asm/setup.h>
 #include <asm/smp-ops.h>
@@ -1055,3 +1056,26 @@ static int __init debugfs_mips(void)
 }
 arch_initcall(debugfs_mips);
 #endif
+
+#if defined(CONFIG_DMA_MAYBE_COHERENT) && !defined(CONFIG_DMA_PERDEV_COHERENT)
+/* User defined DMA coherency from command line. */
+enum coherent_io_user_state coherentio = IO_COHERENCE_DEFAULT;
+EXPORT_SYMBOL_GPL(coherentio);
+int hw_coherentio = 0;	/* Actual hardware supported DMA coherency setting. */
+
+static int __init setcoherentio(char *str)
+{
+	coherentio = IO_COHERENCE_ENABLED;
+	pr_info("Hardware DMA cache coherency (command line)\n");
+	return 0;
+}
+early_param("coherentio", setcoherentio);
+
+static int __init setnocoherentio(char *str)
+{
+	coherentio = IO_COHERENCE_DISABLED;
+	pr_info("Software DMA cache coherency (command line)\n");
+	return 0;
+}
+early_param("nocoherentio", setnocoherentio);
+#endif

commit d7dc899abefb4412388a5d3ec690070197d07d20
Author: Stefan Agner <stefan@agner.ch>
Date:   Thu Jun 14 15:28:02 2018 -0700

    treewide: use PHYS_ADDR_MAX to avoid type casting ULLONG_MAX
    
    With PHYS_ADDR_MAX there is now a type safe variant for all bits set.
    Make use of it.
    
    Patch created using a semantic patch as follows:
    
    // <smpl>
    @@
    typedef phys_addr_t;
    @@
    -(phys_addr_t)ULLONG_MAX
    +PHYS_ADDR_MAX
    // </smpl>
    
    Link: http://lkml.kernel.org/r/20180419214204.19322-1-stefan@agner.ch
    Signed-off-by: Stefan Agner <stefan@agner.ch>
    Reviewed-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: Ard Biesheuvel <ard.biesheuvel@linaro.org>
    Acked-by: Catalin Marinas <catalin.marinas@arm.com>     [arm64]
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 563188ac6fa2..2c96c0c68116 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -93,7 +93,7 @@ void __init add_memory_region(phys_addr_t start, phys_addr_t size, long type)
 	 * If the region reaches the top of the physical address space, adjust
 	 * the size slightly so that (start + size) doesn't overflow
 	 */
-	if (start + size - 1 == (phys_addr_t)ULLONG_MAX)
+	if (start + size - 1 == PHYS_ADDR_MAX)
 		--size;
 
 	/* Sanity check */
@@ -376,7 +376,7 @@ static void __init bootmem_init(void)
 	unsigned long reserved_end;
 	unsigned long mapstart = ~0UL;
 	unsigned long bootmap_size;
-	phys_addr_t ramstart = (phys_addr_t)ULLONG_MAX;
+	phys_addr_t ramstart = PHYS_ADDR_MAX;
 	bool bootmap_valid = false;
 	int i;
 

commit ab3d8441290bcd648f487b69ea87cfe5b37d9e02
Author: Mathieu Malaterre <malat@debian.org>
Date:   Tue Jan 2 19:53:15 2018 +0100

    MIPS: Remove a warning when PHYS_OFFSET is 0x0
    
    Rewrite the comparison in `else if` statement, case where `min_low_pfn >
    ARCH_PFN_OFFSET` has already been checked in the first `if` statement:
    
      if (min_low_pfn > ARCH_PFN_OFFSET) {
    
    Fix non-fatal warning during compilation using W=1:
    
    arch/mips/kernel/setup.c: In function â€˜bootmem_initâ€™:
    arch/mips/kernel/setup.c:461:25: warning: comparison of unsigned expression < 0 is always false [-Wtype-limits]
      } else if (min_low_pfn < ARCH_PFN_OFFSET) {
                             ^
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Reviewed-by: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/18176/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 28be8f238e77..563188ac6fa2 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -454,7 +454,7 @@ static void __init bootmem_init(void)
 		pr_info("Wasting %lu bytes for tracking %lu unused pages\n",
 			(min_low_pfn - ARCH_PFN_OFFSET) * sizeof(struct page),
 			min_low_pfn - ARCH_PFN_OFFSET);
-	} else if (min_low_pfn < ARCH_PFN_OFFSET) {
+	} else if (ARCH_PFN_OFFSET - min_low_pfn > 0UL) {
 		pr_info("%lu free pages won't be used\n",
 			ARCH_PFN_OFFSET - min_low_pfn);
 	}

commit 427aeea072acd7afa6ffe20fc76f887b0f8b232c
Author: Mathieu Malaterre <malat@debian.org>
Date:   Tue Jan 2 19:52:21 2018 +0100

    MIPS: Make declaration for function `memory_region_available` static
    
    Fix non-fatal warning during compilation using W=1:
    
    arch/mips/kernel/setup.c:158:13: warning: no previous prototype for â€˜memory_region_availableâ€™ [-Wmissing-prototypes]
     bool __init memory_region_available(phys_addr_t start, phys_addr_t size)
                 ^~~~~~~~~~~~~~~~~~~~~~~
    
    Signed-off-by: Mathieu Malaterre <malat@debian.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/18175/
    [jhogan@kernel.org: tweak whitespace]
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 5f8b0a9e30b3..28be8f238e77 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -155,7 +155,8 @@ void __init detect_memory_region(phys_addr_t start, phys_addr_t sz_min, phys_add
 	add_memory_region(start, size, BOOT_MEM_RAM);
 }
 
-bool __init memory_region_available(phys_addr_t start, phys_addr_t size)
+static bool __init __maybe_unused memory_region_available(phys_addr_t start,
+							  phys_addr_t size)
 {
 	int i;
 	bool in_ram = false, free = true;

commit 67a3ba25aa955198196f40b76b329b3ab9ad415a
Author: Marcin Nowakowski <marcin.nowakowski@mips.com>
Date:   Thu Feb 1 12:37:21 2018 +0100

    MIPS: Fix incorrect mem=X@Y handling
    
    Commit 73fbc1eba7ff ("MIPS: fix mem=X@Y commandline processing") added a
    fix to ensure that the memory range between PHYS_OFFSET and low memory
    address specified by mem= cmdline argument is not later processed by
    free_all_bootmem.  This change was incorrect for systems where the
    commandline specifies more than 1 mem argument, as it will cause all
    memory between PHYS_OFFSET and each of the memory offsets to be marked
    as reserved, which results in parts of the RAM marked as reserved
    (Creator CI20's u-boot has a default commandline argument 'mem=256M@0x0
    mem=768M@0x30000000').
    
    Change the behaviour to ensure that only the range between PHYS_OFFSET
    and the lowest start address of the memories is marked as protected.
    
    This change also ensures that the range is marked protected even if it's
    only defined through the devicetree and not only via commandline
    arguments.
    
    Reported-by: Mathieu Malaterre <mathieu.malaterre@gmail.com>
    Signed-off-by: Marcin Nowakowski <marcin.nowakowski@mips.com>
    Fixes: 73fbc1eba7ff ("MIPS: fix mem=X@Y commandline processing")
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: <stable@vger.kernel.org> # v4.11+
    Tested-by: Mathieu Malaterre <malat@debian.org>
    Patchwork: https://patchwork.linux-mips.org/patch/18562/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 85bc601e9a0d..5f8b0a9e30b3 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -375,6 +375,7 @@ static void __init bootmem_init(void)
 	unsigned long reserved_end;
 	unsigned long mapstart = ~0UL;
 	unsigned long bootmap_size;
+	phys_addr_t ramstart = (phys_addr_t)ULLONG_MAX;
 	bool bootmap_valid = false;
 	int i;
 
@@ -395,7 +396,8 @@ static void __init bootmem_init(void)
 	max_low_pfn = 0;
 
 	/*
-	 * Find the highest page frame number we have available.
+	 * Find the highest page frame number we have available
+	 * and the lowest used RAM address
 	 */
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long start, end;
@@ -407,6 +409,8 @@ static void __init bootmem_init(void)
 		end = PFN_DOWN(boot_mem_map.map[i].addr
 				+ boot_mem_map.map[i].size);
 
+		ramstart = min(ramstart, boot_mem_map.map[i].addr);
+
 #ifndef CONFIG_HIGHMEM
 		/*
 		 * Skip highmem here so we get an accurate max_low_pfn if low
@@ -436,6 +440,13 @@ static void __init bootmem_init(void)
 		mapstart = max(reserved_end, start);
 	}
 
+	/*
+	 * Reserve any memory between the start of RAM and PHYS_OFFSET
+	 */
+	if (ramstart > PHYS_OFFSET)
+		add_memory_region(PHYS_OFFSET, ramstart - PHYS_OFFSET,
+				  BOOT_MEM_RESERVED);
+
 	if (min_low_pfn >= max_low_pfn)
 		panic("Incorrect memory mapping !!!");
 	if (min_low_pfn > ARCH_PFN_OFFSET) {
@@ -664,9 +675,6 @@ static int __init early_parse_mem(char *p)
 
 	add_memory_region(start, size, BOOT_MEM_RAM);
 
-	if (start && start > PHYS_OFFSET)
-		add_memory_region(PHYS_OFFSET, start - PHYS_OFFSET,
-				BOOT_MEM_RESERVED);
 	return 0;
 }
 early_param("mem", early_parse_mem);

commit 8ce355cf2e38afdb364d03d12b23d9cf44c3b7f1
Author: Paul Burton <paul.burton@mips.com>
Date:   Tue Jan 16 16:47:57 2018 +0100

    MIPS: Setup boot_command_line before plat_mem_setup
    
    Platforms using DT will typically call __dt_setup_arch from
    plat_mem_setup. This in turn calls early_init_dt_scan. When
    CONFIG_CMDLINE is set, this leads to its value being copied into
    boot_command_line by early_init_dt_scan_chosen. If this happens before
    the code setting up boot_command_line in arch_mem_init runs, that code
    will go on to append CONFIG_CMDLINE (via builtin_cmdline) to
    boot_command_line again, duplicating it. For some command line
    parameters (eg. earlycon) this can be a problem. Set up
    boot_command_line before early_init_dt_scan_chosen gets called such that
    it will not write CONFIG_CMDLINE in this scenario & the arguments aren't
    duplicated.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Acked-by: Mathieu Malaterre <malat@debian.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Maarten ter Huurne <maarten@treewalker.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/18483/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 702c678de116..85bc601e9a0d 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -826,25 +826,6 @@ static void __init arch_mem_init(char **cmdline_p)
 	struct memblock_region *reg;
 	extern void plat_mem_setup(void);
 
-	/* call board setup routine */
-	plat_mem_setup();
-
-	/*
-	 * Make sure all kernel memory is in the maps.  The "UP" and
-	 * "DOWN" are opposite for initdata since if it crosses over
-	 * into another memory section you don't want that to be
-	 * freed when the initdata is freed.
-	 */
-	arch_mem_addpart(PFN_DOWN(__pa_symbol(&_text)) << PAGE_SHIFT,
-			 PFN_UP(__pa_symbol(&_edata)) << PAGE_SHIFT,
-			 BOOT_MEM_RAM);
-	arch_mem_addpart(PFN_UP(__pa_symbol(&__init_begin)) << PAGE_SHIFT,
-			 PFN_DOWN(__pa_symbol(&__init_end)) << PAGE_SHIFT,
-			 BOOT_MEM_INIT_RAM);
-
-	pr_info("Determined physical RAM map:\n");
-	print_memory_map();
-
 #if defined(CONFIG_CMDLINE_BOOL) && defined(CONFIG_CMDLINE_OVERRIDE)
 	strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
 #else
@@ -872,6 +853,26 @@ static void __init arch_mem_init(char **cmdline_p)
 	}
 #endif
 #endif
+
+	/* call board setup routine */
+	plat_mem_setup();
+
+	/*
+	 * Make sure all kernel memory is in the maps.  The "UP" and
+	 * "DOWN" are opposite for initdata since if it crosses over
+	 * into another memory section you don't want that to be
+	 * freed when the initdata is freed.
+	 */
+	arch_mem_addpart(PFN_DOWN(__pa_symbol(&_text)) << PAGE_SHIFT,
+			 PFN_UP(__pa_symbol(&_edata)) << PAGE_SHIFT,
+			 BOOT_MEM_RAM);
+	arch_mem_addpart(PFN_UP(__pa_symbol(&__init_begin)) << PAGE_SHIFT,
+			 PFN_DOWN(__pa_symbol(&__init_end)) << PAGE_SHIFT,
+			 BOOT_MEM_INIT_RAM);
+
+	pr_info("Determined physical RAM map:\n");
+	print_memory_map();
+
 	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
 
 	*cmdline_p = command_line;

commit e0c5f36b2a638fc3298200c385af7f196d3b5cd4
Author: David Daney <david.daney@cavium.com>
Date:   Thu Oct 12 12:50:34 2017 -0700

    MIPS: Add iomem resource for kernel bss section.
    
    The kexec/kdump tools need to know where the .bss is so it can be
    included in the core dump.  This allows vmcore-dmesg to have access to
    the dmesg buffers of the crashed kernel as well as allowing the
    debugger to examine variables in the bss section.
    
    Add a request for the bss resource in addition to the already
    requested code and data sections.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Steven J. Hill <steven.hill@cavium.com>,
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/17485/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index fe3939726765..702c678de116 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -80,6 +80,7 @@ EXPORT_SYMBOL(mips_io_port_base);
 
 static struct resource code_resource = { .name = "Kernel code", };
 static struct resource data_resource = { .name = "Kernel data", };
+static struct resource bss_resource = { .name = "Kernel bss", };
 
 static void *detect_magic __initdata = detect_memory_region;
 
@@ -927,6 +928,8 @@ static void __init resource_init(void)
 	code_resource.end = __pa_symbol(&_etext) - 1;
 	data_resource.start = __pa_symbol(&_etext);
 	data_resource.end = __pa_symbol(&_edata) - 1;
+	bss_resource.start = __pa_symbol(&__bss_start);
+	bss_resource.end = __pa_symbol(&__bss_stop) - 1;
 
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		struct resource *res;
@@ -966,6 +969,7 @@ static void __init resource_init(void)
 		 */
 		request_resource(res, &code_resource);
 		request_resource(res, &data_resource);
+		request_resource(res, &bss_resource);
 		request_crashkernel(res);
 	}
 }

commit 296a7624f5b292af610d728e7e347fda341a985e
Author: Miodrag Dinic <miodrag.dinic@imgtec.com>
Date:   Mon Jun 19 17:50:08 2017 +0200

    MIPS: cmdline: Add support for 'memmap' parameter
    
    Implement support for parsing 'memmap' kernel command line parameter.
    
    This patch covers parsing of the following two formats for 'memmap'
    parameter values:
    
      - nn[KMG]@ss[KMG]
      - nn[KMG]$ss[KMG]
    
      ([KMG] = K M or G (kilo, mega, giga))
    
    These two allowed formats for parameter value are already documented
    in file kernel-parameters.txt in Documentation/admin-guide folder.
    Some architectures already support them, but Mips did not prior to
    this patch.
    
    Excerpt from Documentation/admin-guide/kernel-parameters.txt:
    
    memmap=nn[KMG]@ss[KMG]
        [KNL] Force usage of a specific region of memory.
        Region of memory to be used is from ss to ss+nn.
    
    memmap=nn[KMG]$ss[KMG]
        Mark specific memory as reserved.
        Region of memory to be reserved is from ss to ss+nn.
        Example: Exclude memory from 0x18690000-0x1869ffff
            memmap=64K$0x18690000
            or
            memmap=0x10000$0x18690000
    
    There is no need to update this documentation file with respect to
    this patch.
    
    Signed-off-by: Miodrag Dinic <miodrag.dinic@imgtec.com>
    Signed-off-by: Goran Ferenc <goran.ferenc@imgtec.com>
    Signed-off-by: Aleksandar Markovic <aleksandar.markovic@imgtec.com>
    Cc: James.Hogan@imgtec.com
    Cc: Paul.Burton@imgtec.com
    Cc: Raghu.Gandham@imgtec.com
    Cc: Leonid.Yegoshin@imgtec.com
    Cc: Douglas.Leung@imgtec.com
    Cc: Petar.Jovanovic@imgtec.com
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/16508/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 01d1dbde5fbf..fe3939726765 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -670,6 +670,46 @@ static int __init early_parse_mem(char *p)
 }
 early_param("mem", early_parse_mem);
 
+static int __init early_parse_memmap(char *p)
+{
+	char *oldp;
+	u64 start_at, mem_size;
+
+	if (!p)
+		return -EINVAL;
+
+	if (!strncmp(p, "exactmap", 8)) {
+		pr_err("\"memmap=exactmap\" invalid on MIPS\n");
+		return 0;
+	}
+
+	oldp = p;
+	mem_size = memparse(p, &p);
+	if (p == oldp)
+		return -EINVAL;
+
+	if (*p == '@') {
+		start_at = memparse(p+1, &p);
+		add_memory_region(start_at, mem_size, BOOT_MEM_RAM);
+	} else if (*p == '#') {
+		pr_err("\"memmap=nn#ss\" (force ACPI data) invalid on MIPS\n");
+		return -EINVAL;
+	} else if (*p == '$') {
+		start_at = memparse(p+1, &p);
+		add_memory_region(start_at, mem_size, BOOT_MEM_RESERVED);
+	} else {
+		pr_err("\"memmap\" invalid format!\n");
+		return -EINVAL;
+	}
+
+	if (*p == '\0') {
+		usermem = 1;
+		return 0;
+	} else
+		return -EINVAL;
+}
+early_param("memmap", early_parse_memmap);
+
 #ifdef CONFIG_PROC_VMCORE
 unsigned long setup_elfcorehdr, setup_elfcorehdr_size;
 static int __init early_parse_elfcorehdr(char *p)

commit a8f108d70c74d83574c157648383eb2e4285a190
Author: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
Date:   Wed Nov 23 14:43:50 2016 +0100

    MIPS: kexec: Do not reserve invalid crashkernel memory on boot
    
    Do not reserve memory for the crashkernel if the commandline argument
    points to a wrong location. This can happen if the location is specified
    wrong or if the same commandline is reused when starting the crashkernel
    - in the latter case the reserved memory would point to the location
    from which the crashkernel is executing.
    
    Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14612/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index ae888662bda3..01d1dbde5fbf 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -741,6 +741,11 @@ static void __init mips_parse_crashkernel(void)
 	if (ret != 0 || crash_size <= 0)
 		return;
 
+	if (!memory_region_available(crash_base, crash_size)) {
+		pr_warn("Invalid memory region reserved for crash kernel\n");
+		return;
+	}
+
 	crashk_res.start = crash_base;
 	crashk_res.end	 = crash_base + crash_size - 1;
 }

commit 73fbc1eba7ffa3bf0ad12486232a8a1edb4e4411
Author: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
Date:   Wed Nov 23 14:43:49 2016 +0100

    MIPS: fix mem=X@Y commandline processing
    
    When a memory offset is specified through the commandline, add the
    memory in range PHYS_OFFSET:Y as reserved memory area.
    Otherwise the bootmem allocator is initialised with low page equal to
    min_low_pfn = PHYS_OFFSET, and in free_all_bootmem will process pages
    starting from min_low_pfn instead of PFN(Y).
    
    Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14613/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c22f0fdd4cfb..ae888662bda3 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -662,6 +662,10 @@ static int __init early_parse_mem(char *p)
 		start = memparse(p + 1, &p);
 
 	add_memory_region(start, size, BOOT_MEM_RAM);
+
+	if (start && start > PHYS_OFFSET)
+		add_memory_region(PHYS_OFFSET, start - PHYS_OFFSET,
+				BOOT_MEM_RESERVED);
 	return 0;
 }
 early_param("mem", early_parse_mem);

commit 73346081cac18732a959be580a90abc707dea52a
Author: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
Date:   Wed Nov 23 14:43:46 2016 +0100

    MIPS: Use early_init_fdt_reserve_self to protect DTB location
    
    early_init_fdt_reserve_self is used to tell the boot memory allocator
    that a memory is occupied by the DTB, so add it in the MIPS init code to
    ensure information about the DTB is added to the boot memory array.
    
    Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14610/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 64b38d400987..c22f0fdd4cfb 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -27,6 +27,7 @@
 #include <linux/device.h>
 #include <linux/dma-contiguous.h>
 #include <linux/decompress/generic.h>
+#include <linux/of_fdt.h>
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
@@ -832,6 +833,9 @@ static void __init arch_mem_init(char **cmdline_p)
 		print_memory_map();
 	}
 
+	early_init_fdt_reserve_self();
+	early_init_fdt_scan_reserved_mem();
+
 	bootmem_init();
 #ifdef CONFIG_PROC_VMCORE
 	if (setup_elfcorehdr && setup_elfcorehdr_size) {

commit d9b5b658210f28ed9f70c757d553e679d76e2986
Author: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
Date:   Wed Nov 23 14:43:45 2016 +0100

    MIPS: init: Ensure bootmem does not corrupt reserved memory
    
    Current init code initialises bootmem allocator with all of the low
    memory that it assumes is available, but does not check for reserved
    memory block, which can lead to corruption of data that may be stored
    there.
    Move bootmem's allocation map to a location that does not cross any
    reserved regions
    
    Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14609/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 8ebad247ce82..64b38d400987 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -153,6 +153,35 @@ void __init detect_memory_region(phys_addr_t start, phys_addr_t sz_min, phys_add
 	add_memory_region(start, size, BOOT_MEM_RAM);
 }
 
+bool __init memory_region_available(phys_addr_t start, phys_addr_t size)
+{
+	int i;
+	bool in_ram = false, free = true;
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		phys_addr_t start_, end_;
+
+		start_ = boot_mem_map.map[i].addr;
+		end_ = boot_mem_map.map[i].addr + boot_mem_map.map[i].size;
+
+		switch (boot_mem_map.map[i].type) {
+		case BOOT_MEM_RAM:
+			if (start >= start_ && start + size <= end_)
+				in_ram = true;
+			break;
+		case BOOT_MEM_RESERVED:
+			if ((start >= start_ && start < end_) ||
+			    (start < start_ && start + size >= start_))
+				free = false;
+			break;
+		default:
+			continue;
+		}
+	}
+
+	return in_ram && free;
+}
+
 static void __init print_memory_map(void)
 {
 	int i;
@@ -332,11 +361,19 @@ static void __init bootmem_init(void)
 
 #else  /* !CONFIG_SGI_IP27 */
 
+static unsigned long __init bootmap_bytes(unsigned long pages)
+{
+	unsigned long bytes = DIV_ROUND_UP(pages, 8);
+
+	return ALIGN(bytes, sizeof(long));
+}
+
 static void __init bootmem_init(void)
 {
 	unsigned long reserved_end;
 	unsigned long mapstart = ~0UL;
 	unsigned long bootmap_size;
+	bool bootmap_valid = false;
 	int i;
 
 	/*
@@ -430,11 +467,42 @@ static void __init bootmem_init(void)
 #endif
 
 	/*
-	 * Initialize the boot-time allocator with low memory only.
+	 * check that mapstart doesn't overlap with any of
+	 * memory regions that have been reserved through eg. DTB
 	 */
-	bootmap_size = init_bootmem_node(NODE_DATA(0), mapstart,
-					 min_low_pfn, max_low_pfn);
+	bootmap_size = bootmap_bytes(max_low_pfn - min_low_pfn);
+
+	bootmap_valid = memory_region_available(PFN_PHYS(mapstart),
+						bootmap_size);
+	for (i = 0; i < boot_mem_map.nr_map && !bootmap_valid; i++) {
+		unsigned long mapstart_addr;
+
+		switch (boot_mem_map.map[i].type) {
+		case BOOT_MEM_RESERVED:
+			mapstart_addr = PFN_ALIGN(boot_mem_map.map[i].addr +
+						boot_mem_map.map[i].size);
+			if (PHYS_PFN(mapstart_addr) < mapstart)
+				break;
+
+			bootmap_valid = memory_region_available(mapstart_addr,
+								bootmap_size);
+			if (bootmap_valid)
+				mapstart = PHYS_PFN(mapstart_addr);
+			break;
+		default:
+			break;
+		}
+	}
 
+	if (!bootmap_valid)
+		panic("No memory area to place a bootmap bitmap");
+
+	/*
+	 * Initialize the boot-time allocator with low memory only.
+	 */
+	if (bootmap_size != init_bootmem_node(NODE_DATA(0), mapstart,
+					 min_low_pfn, max_low_pfn))
+		panic("Unexpected memory size required for bootmap");
 
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long start, end;

commit e89ef66d7682f031f026eee6bba03c8c2248d2a9
Author: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
Date:   Wed Nov 23 14:43:44 2016 +0100

    MIPS: init: Ensure reserved memory regions are not added to bootmem
    
    Memories managed through boot_mem_map are generally expected to define
    non-crossing areas. However, if part of a larger memory block is marked
    as reserved, it would still be added to bootmem allocator as an
    available block and could end up being overwritten by the allocator.
    
    Prevent this by explicitly marking the memory as reserved it if exists
    in the range used by bootmem allocator.
    
    Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14608/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 0058feaa65e5..8ebad247ce82 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -483,6 +483,10 @@ static void __init bootmem_init(void)
 			continue;
 		default:
 			/* Not usable memory */
+			if (start > min_low_pfn && end < max_low_pfn)
+				reserve_bootmem(boot_mem_map.map[i].addr,
+						boot_mem_map.map[i].size,
+						BOOTMEM_DEFAULT);
 			continue;
 		}
 

commit 269aa43aad0f96673478fe2446abe54d7ad42e8f
Author: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
Date:   Wed Nov 23 14:43:43 2016 +0100

    MIPS: Do not request resources for crashkernel if one isn't defined
    
    When KEXEC is enabled but crashkernel details are not passed through the
    kernel commandline unnecessary resources are requested (start==end==0)
    
    Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14607/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index f66e5ce505b2..0058feaa65e5 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -672,6 +672,9 @@ static void __init request_crashkernel(struct resource *res)
 {
 	int ret;
 
+	if (crashk_res.start == crashk_res.end)
+		return;
+
 	ret = request_resource(res, &crashk_res);
 	if (!ret)
 		pr_info("Reserving %ldMB of memory at %ldMB for crashkernel\n",

commit 16a767ec63167ef70c056795782d6c9c76ba5a5c
Author: James Hogan <james.hogan@imgtec.com>
Date:   Tue Nov 1 13:59:09 2016 +0000

    MIPS: Fix max_low_pfn with disabled highmem
    
    When low memory doesn't reach HIGHMEM_START (e.g. up to 256MB at PA=0 is
    common) and highmem is present above HIGHMEM_START (e.g. on Malta the
    RAM overlayed by the IO region is aliased at PA=0x90000000), max_low_pfn
    will be initially calculated very large and then clipped down to
    HIGHMEM_START.
    
    This causes crashes when reading /sys/kernel/mm/page_idle/bitmap
    (i.e. CONFIG_IDLE_PAGE_TRACKING=y) when highmem is disabled. pfn_valid()
    will compare against max_mapnr which is derived from max_low_pfn when
    there is no highend_pfn set up, and will return true for PFNs right up
    to HIGHMEM_START, even though they are beyond the end of low memory and
    no page structs will actually exist for these PFNs.
    
    This is fixed by skipping high memory regions when initially calculating
    max_low_pfn if highmem is disabled, so it doesn't get clipped too high.
    We also clip regions which overlap the highmem boundary when highmem is
    disabled, so that max_pfn doesn't extend into highmem either.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14490/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 0d57909d9026..f66e5ce505b2 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -368,6 +368,19 @@ static void __init bootmem_init(void)
 		end = PFN_DOWN(boot_mem_map.map[i].addr
 				+ boot_mem_map.map[i].size);
 
+#ifndef CONFIG_HIGHMEM
+		/*
+		 * Skip highmem here so we get an accurate max_low_pfn if low
+		 * memory stops short of high memory.
+		 * If the region overlaps HIGHMEM_START, end is clipped so
+		 * max_pfn excludes the highmem portion.
+		 */
+		if (start >= PFN_DOWN(HIGHMEM_START))
+			continue;
+		if (end > PFN_DOWN(HIGHMEM_START))
+			end = PFN_DOWN(HIGHMEM_START);
+#endif
+
 		if (end > max_low_pfn)
 			max_low_pfn = end;
 		if (start < min_low_pfn)

commit 058effe7fdc5776b017356f690976a857eea473f
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Sep 2 15:17:31 2016 +0100

    MIPS: Fix detection of unsupported highmem with cache aliases
    
    The paging_init() function contains code which detects that highmem is
    in use but unsupported due to dcache aliasing. However this code was
    ineffective because it was being run before the caches are probed,
    meaning that cpu_has_dc_aliases would always evaluate to false (unless a
    platform overrides it to a compile-time constant) and the detection of
    the unsupported case is never triggered. The kernel would then go on to
    attempt to use highmem & either hit coherency issues or trigger the
    BUG_ON in flush_kernel_dcache_page().
    
    Fix this by running paging_init() later than cpu_cache_init(), such that
    the cpu_has_dc_aliases macro will evaluate correctly & the unsupported
    highmem case will be detected successfully.
    
    This then leads to a formerly hidden issue in that
    mem_init_free_highmem() will attempt to free all highmem pages, even
    though we're avoiding use of them & don't have valid page structs for
    them. This leads to an invalid pointer dereference & a TLB exception.
    Avoid this by skipping the loop in mem_init_free_highmem() if
    cpu_has_dc_aliases evaluates true.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: Rabin Vincent <rabinv@axis.com>
    Cc: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Jerome Marchand <jmarchan@redhat.com>
    Cc: Alexander Sverdlin <alexander.sverdlin@gmail.com>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: Jaedon Shin <jaedon.shin@gmail.com>
    Cc: Toshi Kani <toshi.kani@hpe.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Sergey Ryazanov <ryazanov.s.a@gmail.com>
    Cc: Jonas Gorski <jogo@openwrt.org>
    Cc: Kirill A. Shutemov <kirill.shutemov@linux.intel.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/14184/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 3be0e6ba2797..0d57909d9026 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -764,7 +764,6 @@ static void __init arch_mem_init(char **cmdline_p)
 	device_tree_init();
 	sparse_init();
 	plat_swiotlb_setup();
-	paging_init();
 
 	dma_contiguous_reserve(PFN_PHYS(max_low_pfn));
 	/* Tell bootmem about cma reserved memblock section */
@@ -877,6 +876,7 @@ void __init setup_arch(char **cmdline_p)
 	prefill_possible_map();
 
 	cpu_cache_init();
+	paging_init();
 }
 
 unsigned long kernelsp[NR_CPUS];

commit 58cae9b0f0c1d9cc55de018d927e65549b24cf5b
Author: James Hogan <james.hogan@imgtec.com>
Date:   Tue Aug 9 13:21:48 2016 +0100

    MIPS: Fix memory regions reaching top of physical
    
    Memory regions added with add_memory_region() at the top of the physical
    address space will have their end address overflow to 0. This causes
    them to be rejected as invalid, and would cause various other issues
    later on.
    
    This causes issues on Malta and Boston platforms when wanting to use all
    2GB of RAM on a 32-bit kernel, either via highmem (using physical
    addresses 0x90000000..0xFFFFFFFF), or with the Malta Enhanced Virtual
    Addressing (EVA) layout which exposes the whole 0x80000000..0xFFFFFFFF
    physical address range to kernel mode at 0x00000000..0x7FFFFFFF.
    
    Due to the abundance of these non-overflow assumptions and the fact that
    memblock already avoids the arithmetic overflow by limiting the size of
    new memory regions without the arch code knowing it (in particular
    mem_init_free_highmem() will trigger a page dump due to nonzero mapcount
    on the last page), it is simpler and safer to just limit the size of the
    region in a similar way to memblock but at the arch level to allow most
    of the RAM to be used without arithmetic overflows.
    
    Therefore we detect this case specifically and reduce the size of the
    region slightly to avoid the arithmetic overflows and cause the last
    page to be ignored.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13857/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 36cf8d65c47d..3be0e6ba2797 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -87,6 +87,13 @@ void __init add_memory_region(phys_addr_t start, phys_addr_t size, long type)
 	int x = boot_mem_map.nr_map;
 	int i;
 
+	/*
+	 * If the region reaches the top of the physical address space, adjust
+	 * the size slightly so that (start + size) doesn't overflow
+	 */
+	if (start + size - 1 == (phys_addr_t)ULLONG_MAX)
+		--size;
+
 	/* Sanity check */
 	if (start + size < start) {
 		pr_warn("Trying to add an invalid memory region, skipped\n");

commit 15f37e1588920e010f20b53f04af94e91b8ee714
Author: Jonas Gorski <jogo@openwrt.org>
Date:   Mon Jun 20 11:27:37 2016 +0200

    MIPS: store the appended dtb address in a variable
    
    Instead of rewriting the arguments to match the UHI spec, store the
    address of a appended or UHI supplied dtb in fw_supplied_dtb.
    
    That way the original bootloader arugments are kept intact while still
    making the use of an appended dtb invisible for mach code.
    
    Mach code can still find out if it is an appended dtb by comparing
    fw_arg1 with fw_supplied_dtb.
    
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: John Crispin <john@phrozen.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Alban Bedel <albeu@free.fr>
    Cc: Daniel Gimpelevich <daniel@gimpelevich.san-francisco.ca.us>
    Cc: Antony Pavlov <antonynpavlov@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13699/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index ef408a03e818..36cf8d65c47d 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -875,6 +875,10 @@ void __init setup_arch(char **cmdline_p)
 unsigned long kernelsp[NR_CPUS];
 unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
 
+#ifdef CONFIG_USE_OF
+unsigned long fw_passed_dtb;
+#endif
+
 #ifdef CONFIG_DEBUG_FS
 struct dentry *mips_debugfs_dir;
 static int __init debugfs_mips(void)

commit 8f4703aa4df758def78e9a39cc5d1ff73c3ef51f
Author: Aurelien Jarno <aurelien@aurel32.net>
Date:   Wed May 11 00:50:03 2016 +0200

    MIPS: Octeon: detect and fix byte swapped initramfs
    
    Octeon machines support running in little endian mode. U-Boot usually
    runs in big endian-mode. Therefore the initramfs is loaded in big endian
    mode, and the kernel later tries to access it in little endian mode.
    
    This patch fixes that by detecting byte swapped initramfs using either the
    CPIO header or the header from standard compression methods, and
    byte swaps it if needed. It first checks that the header doesn't match
    in the native endianness to avoid false detections. It uses the kernel
    decompress library so that we don't have to maintain the list of magics
    if some decompression methods are added to the kernel.
    
    Signed-off-by: Aurelien Jarno <aurelien@aurel32.net>
    Acked-by: David Daney <david.daney@cavium.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13219/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 19c03a9e7492..ef408a03e818 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -26,6 +26,7 @@
 #include <linux/sizes.h>
 #include <linux/device.h>
 #include <linux/dma-contiguous.h>
+#include <linux/decompress/generic.h>
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
@@ -243,6 +244,35 @@ static unsigned long __init init_initrd(void)
 	return 0;
 }
 
+/* In some conditions (e.g. big endian bootloader with a little endian
+   kernel), the initrd might appear byte swapped.  Try to detect this and
+   byte swap it if needed.  */
+static void __init maybe_bswap_initrd(void)
+{
+#if defined(CONFIG_CPU_CAVIUM_OCTEON)
+	u64 buf;
+
+	/* Check for CPIO signature */
+	if (!memcmp((void *)initrd_start, "070701", 6))
+		return;
+
+	/* Check for compressed initrd */
+	if (decompress_method((unsigned char *)initrd_start, 8, NULL))
+		return;
+
+	/* Try again with a byte swapped header */
+	buf = swab64p((u64 *)initrd_start);
+	if (!memcmp(&buf, "070701", 6) ||
+	    decompress_method((unsigned char *)(&buf), 8, NULL)) {
+		unsigned long i;
+
+		pr_info("Byteswapped initrd detected\n");
+		for (i = initrd_start; i < ALIGN(initrd_end, 8); i += 8)
+			swab64s((u64 *)i);
+	}
+#endif
+}
+
 static void __init finalize_initrd(void)
 {
 	unsigned long size = initrd_end - initrd_start;
@@ -256,6 +286,8 @@ static void __init finalize_initrd(void)
 		goto disable;
 	}
 
+	maybe_bswap_initrd();
+
 	reserve_bootmem(__pa(initrd_start), size, BOOTMEM_DEFAULT);
 	initrd_below_start_ok = 1;
 

commit ed47e1533292e26baaec1b5ed7d425690289d5df
Author: Rabin Vincent <rabinv@axis.com>
Date:   Thu Apr 28 11:03:09 2016 +0200

    MIPS: Add support for extending builtin cmdline
    
    Allow the builtin command line to be extended by what the bootloader
    passes in.  For example, the bootloader can pass specific arguments
    depending on the boot mode, and these should override the defaults in
    the builtin cmdline.
    
    The default MIPS_CMDLINE_FROM_BOOTLOADER option prepends the
    bootloader's cmdline to the builtin cmdline so is not suitable for this
    purpose.
    
    Signed-off-by: Rabin Vincent <rabinv@axis.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13181/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 38815f78c819..19c03a9e7492 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -640,6 +640,8 @@ static void __init request_crashkernel(struct resource *res)
 #define USE_PROM_CMDLINE	IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_BOOTLOADER)
 #define USE_DTB_CMDLINE		IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_DTB)
 #define EXTEND_WITH_PROM	IS_ENABLED(CONFIG_MIPS_CMDLINE_DTB_EXTEND)
+#define BUILTIN_EXTEND_WITH_PROM	\
+	IS_ENABLED(CONFIG_MIPS_CMDLINE_BUILTIN_EXTEND)
 
 static void __init arch_mem_init(char **cmdline_p)
 {
@@ -684,6 +686,12 @@ static void __init arch_mem_init(char **cmdline_p)
 			strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
 		strlcat(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
 	}
+
+	if (BUILTIN_EXTEND_WITH_PROM && arcs_cmdline[0]) {
+		if (boot_command_line[0])
+			strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
+		strlcat(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
+	}
 #endif
 #endif
 	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);

commit e54ad8c56258af3b414a3e5707a45c18f1db69e1
Author: Rabin Vincent <rabinv@axis.com>
Date:   Thu Apr 28 11:03:08 2016 +0200

    MIPS: Don't add leading spacing to command lines
    
    The leading spaces don't affect functionality but are unnecessary.
    
    Signed-off-by: Rabin Vincent <rabinv@axis.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13180/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 693e8d1a174c..38815f78c819 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -673,13 +673,15 @@ static void __init arch_mem_init(char **cmdline_p)
 		strlcpy(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
 
 	if (EXTEND_WITH_PROM && arcs_cmdline[0]) {
-		strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
+		if (boot_command_line[0])
+			strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
 		strlcat(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
 	}
 
 #if defined(CONFIG_CMDLINE_BOOL)
 	if (builtin_cmdline[0]) {
-		strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
+		if (boot_command_line[0])
+			strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
 		strlcat(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
 	}
 #endif

commit e8b5325ca3d01c512be6f04d587869a01e0ea59f
Author: Sergey Ryazanov <ryazanov.s.a@gmail.com>
Date:   Sat Aug 30 06:06:28 2014 +0400

    MIPS: make PCI_DMA_BUS_IS_PHYS=1 constant
    
    No one of supported MIPS machines has an IOMMU unit, so we can safely define
    PCI_DMA_BUS_IS_PHYS = 1. Also remove iommu flag from the pci controller
    structure, since it is useless.
    
    Signed-off-by: Sergey Ryazanov <ryazanov.s.a@gmail.com>
    Cc: Linux MIPS <linux-mips@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7604/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 9b20a0f89812..693e8d1a174c 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -51,13 +51,6 @@ EXPORT_SYMBOL(cpu_data);
 struct screen_info screen_info;
 #endif
 
-/*
- * Despite it's name this variable is even if we don't have PCI
- */
-unsigned int PCI_DMA_BUS_IS_PHYS;
-
-EXPORT_SYMBOL(PCI_DMA_BUS_IS_PHYS);
-
 /*
  * Setup information
  *

commit 919beb4eedc587b70f8c1390fedac10cda783c36
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Thu Mar 31 10:05:42 2016 +0100

    MIPS: KASLR: Print relocation Information on boot
    
    When debugging a relocated kernel, the addresses of the relocated
    symbols and the offset applied is essential information. If the kernel
    is compiled with debugging information, then print this information
    during bootup using the same function as the panic notifier.
    
    [ralf@linux-mips.org: Fixed spelling mistake pointed out by
    Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>.]
    
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Aaro Koskinen <aaro.koskinen@nokia.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Alexander Sverdlin <alexander.sverdlin@gmail.com>
    Cc: Jaedon Shin <jaedon.shin@gmail.com>
    Cc: Jonas Gorski <jogo@openwrt.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: kernel-hardening@lists.openwall.com
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/12989/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 3378fdaf4dd3..9b20a0f89812 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -477,9 +477,18 @@ static void __init bootmem_init(void)
 	 */
 	if (__pa_symbol(_text) > __pa_symbol(VMLINUX_LOAD_ADDRESS)) {
 		unsigned long offset;
+		extern void show_kernel_relocation(const char *level);
 
 		offset = __pa_symbol(_text) - __pa_symbol(VMLINUX_LOAD_ADDRESS);
 		free_bootmem(__pa_symbol(VMLINUX_LOAD_ADDRESS), offset);
+
+#if defined(CONFIG_DEBUG_KERNEL) && defined(CONFIG_DEBUG_INFO)
+		/*
+		 * This information is necessary when debugging the kernel
+		 * But is a security vulnerability otherwise!
+		 */
+		show_kernel_relocation(KERN_INFO);
+#endif
 	}
 #endif
 

commit 61cd52d4e44d7d8c55dad939b1877fd39d7103a2
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Thu Mar 31 10:05:38 2016 +0100

    MIPS: bootmem: When relocatable, free memory below kernel
    
    The kernel reserves all memory before the _end symbol as bootmem,
    however, once the kernel can be relocated elsewhere in memory this may
    result in a large amount of wasted memory. The assumption is that the
    memory between the link and relocated address of the kernel may be
    released back to the available memory pool.
    
    Memory statistics for a Malta with the kernel relocating by
    16Mb, without the patch:
    Memory: 105952K/131072K available (4604K kernel code, 242K rwdata,
    892K rodata, 1280K init, 183K bss, 25120K reserved, 0K cma-reserved)
    And with the patch:
    Memory: 122336K/131072K available (4604K kernel code, 242K rwdata,
    892K rodata, 1280K init, 183K bss, 8736K reserved, 0K cma-reserved)
    
    The 16Mb offset is removed from the reserved region and added back to
    the available region.
    
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Aaro Koskinen <aaro.koskinen@nokia.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Alexander Sverdlin <alexander.sverdlin@gmail.com>
    Cc: Jaedon Shin <jaedon.shin@gmail.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Jonas Gorski <jogo@openwrt.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: kernel-hardening@lists.openwall.com
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/12986/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index d20caacfdbd3..3378fdaf4dd3 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -469,6 +469,20 @@ static void __init bootmem_init(void)
 	 */
 	reserve_bootmem(PFN_PHYS(mapstart), bootmap_size, BOOTMEM_DEFAULT);
 
+#ifdef CONFIG_RELOCATABLE
+	/*
+	 * The kernel reserves all memory below its _end symbol as bootmem,
+	 * but the kernel may now be at a much higher address. The memory
+	 * between the original and new locations may be returned to the system.
+	 */
+	if (__pa_symbol(_text) > __pa_symbol(VMLINUX_LOAD_ADDRESS)) {
+		unsigned long offset;
+
+		offset = __pa_symbol(_text) - __pa_symbol(VMLINUX_LOAD_ADDRESS);
+		free_bootmem(__pa_symbol(VMLINUX_LOAD_ADDRESS), offset);
+	}
+#endif
+
 	/*
 	 * Reserve initrd memory if needed.
 	 */

commit a95d069204e178f18476f5499abab0d0d9cbc32c
Author: Huacai Chen <chenhc@lemote.com>
Date:   Thu Mar 17 20:37:10 2016 +0800

    MIPS: Reserve nosave data for hibernation
    
    After commit 92923ca3aacef63c92d ("mm: meminit: only set page reserved
    in the memblock region"), the MIPS hibernation is broken. Because pages
    in nosave data section should be "reserved", but currently they aren't
    set to "reserved" at initialization. This patch makes hibernation work
    again.
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: Steven J . Hill <sjhill@realitydiluted.com>
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/12888/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 4f607341a793..d20caacfdbd3 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -706,6 +706,9 @@ static void __init arch_mem_init(char **cmdline_p)
 	for_each_memblock(reserved, reg)
 		if (reg->size != 0)
 			reserve_bootmem(reg->base, reg->size, BOOTMEM_DEFAULT);
+
+	reserve_bootmem_region(__pa_symbol(&__nosave_begin),
+			__pa_symbol(&__nosave_end)); /* Reserve for hibernation */
 }
 
 static void __init resource_init(void)

commit bc94b99636dc7bcccce439a9fb9c00065e2e2627
Merge: 4650bac1fc45 fc77dbd34c5c
Author: Ingo Molnar <mingo@kernel.org>
Date:   Fri Mar 4 12:12:08 2016 +0100

    Merge tag 'v4.5-rc6' into core/resources, to resolve conflict
    
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

commit 3af5a67c86a30f8cd8bfd6202709be21cedd2756
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Feb 8 09:46:31 2016 -0800

    MIPS: Fix early CM probing
    
    Commit c014d164f21d ("MIPS: Add platform callback before initializing
    the L2 cache") added a platform_early_l2_init function in order to allow
    platforms to probe for the CM before L2 initialisation is performed, so
    that CM GCRs are available to mips_sc_probe.
    
    That commit actually fails to do anything useful, since it checks
    mips_cm_revision to determine whether it should call mips_cm_probe but
    the result of mips_cm_revision will always be 0 until mips_cm_probe has
    been called. Thus the "early" mips_cm_probe call never occurs.
    
    Fix this & drop the useless weak platform_early_l2_init function by
    simply calling mips_cm_probe from setup_arch. For platforms that don't
    select CONFIG_MIPS_CM this will be a no-op, and for those that do it
    removes the requirement for them to call mips_cm_probe manually
    (although doing so isn't harmful for now).
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Reviewed-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Cc: Andrzej Hajda <a.hajda@samsung.com>
    Cc: Aaro Koskinen <aaro.koskinen@nokia.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Rob Herring <robh@kernel.org>
    Cc: Peter Hurley <peter@hurleysoftware.com>
    Cc: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: Jaedon Shin <jaedon.shin@gmail.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Jonas Gorski <jogo@openwrt.org>
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/12475/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 569a7d5242dd..5fdaf8bdcd2e 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -782,6 +782,7 @@ static inline void prefill_possible_map(void) {}
 void __init setup_arch(char **cmdline_p)
 {
 	cpu_probe();
+	mips_cm_probe();
 	prom_init();
 
 	setup_early_fdc_console();

commit 35d98e93fe6a7ab612f6b389ce42c1dc135d6eef
Author: Toshi Kani <toshi.kani@hpe.com>
Date:   Tue Jan 26 21:57:22 2016 +0100

    arch: Set IORESOURCE_SYSTEM_RAM flag for System RAM
    
    Set IORESOURCE_SYSTEM_RAM in flags of resource ranges with
    "System RAM", "Kernel code", "Kernel data", and "Kernel bss".
    
    Note that:
    
     - IORESOURCE_SYSRAM (i.e. modifier bit) is set in flags when
       IORESOURCE_MEM is already set. IORESOURCE_SYSTEM_RAM is defined
       as (IORESOURCE_MEM|IORESOURCE_SYSRAM).
    
     - Some archs do not set 'flags' for children nodes, such as
       "Kernel code".  This patch does not change 'flags' in this
       case.
    
    Signed-off-by: Toshi Kani <toshi.kani@hpe.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Gerst <brgerst@gmail.com>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Luis R. Rodriguez <mcgrof@suse.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Toshi Kani <toshi.kani@hp.com>
    Cc: linux-arch@vger.kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-mm <linux-mm@kvack.org>
    Cc: linux-parisc@vger.kernel.org
    Cc: linux-s390@vger.kernel.org
    Cc: linux-sh@vger.kernel.org
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: sparclinux@vger.kernel.org
    Link: http://lkml.kernel.org/r/1453841853-11383-7-git-send-email-bp@alien8.de
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 569a7d5242dd..c745f0ea2577 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -732,21 +732,23 @@ static void __init resource_init(void)
 			end = HIGHMEM_START - 1;
 
 		res = alloc_bootmem(sizeof(struct resource));
+
+		res->start = start;
+		res->end = end;
+		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+
 		switch (boot_mem_map.map[i].type) {
 		case BOOT_MEM_RAM:
 		case BOOT_MEM_INIT_RAM:
 		case BOOT_MEM_ROM_DATA:
 			res->name = "System RAM";
+			res->flags |= IORESOURCE_SYSRAM;
 			break;
 		case BOOT_MEM_RESERVED:
 		default:
 			res->name = "reserved";
 		}
 
-		res->start = start;
-		res->end = end;
-
-		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
 		request_resource(&iomem_resource, res);
 
 		/*

commit 2549cc967ebb4043f3507b55e3dc579f44d3b516
Author: Jaedon Shin <jaedon.shin@gmail.com>
Date:   Mon Dec 21 12:47:35 2015 +0900

    MIPS: Fix macro typo
    
    Change the CONFIG_MIPS_CMDLINE_EXTEND to CONFIG_MIPS_CMDLINE_DTB_EXTEND
    to resolve the EXTEND_WITH_PROM macro.
    
    Signed-off-by: Jaedon Shin <jaedon.shin@gmail.com>
    Fixes: 2024972ef533 ("MIPS: Make the kernel arguments from dtb available")
    Reviewed-by: Alexander Sverdlin <alexander.svedlin@gmail.com>
    Cc: Jonas Gorski <jogo@openwrt.org>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Aaro Koskinen <aaro.koskinen@nokia.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/11909/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 66aac55df349..569a7d5242dd 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -623,7 +623,7 @@ static void __init request_crashkernel(struct resource *res)
 
 #define USE_PROM_CMDLINE	IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_BOOTLOADER)
 #define USE_DTB_CMDLINE		IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_DTB)
-#define EXTEND_WITH_PROM	IS_ENABLED(CONFIG_MIPS_CMDLINE_EXTEND)
+#define EXTEND_WITH_PROM	IS_ENABLED(CONFIG_MIPS_CMDLINE_DTB_EXTEND)
 
 static void __init arch_mem_init(char **cmdline_p)
 {

commit 87db537da4cd1bfad388511a3647bbb497d2fb61
Author: Aaro Koskinen <aaro.koskinen@nokia.com>
Date:   Fri Sep 11 17:46:14 2015 +0300

    MIPS: vmlinux: create a section for appended DTB
    
    For bootloaders that support booting only ELF kernels and load only ELF
    segments to memory there is no easy way to supply DTB without kernel
    recompilation. For that purpose, create a section called .appended_dtb
    that can be later updated with board-specific DTB using binutils e.g. at
    kernel installation time.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@nokia.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/11114/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 6f142ee4a086..66aac55df349 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -39,6 +39,10 @@
 #include <asm/smp-ops.h>
 #include <asm/prom.h>
 
+#ifdef CONFIG_MIPS_ELF_APPENDED_DTB
+const char __section(.appended_dtb) __appended_dtb[0x100000];
+#endif /* CONFIG_MIPS_ELF_APPENDED_DTB */
+
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
 EXPORT_SYMBOL(cpu_data);

commit 2024972ef5330dcae47f400c586764d8f4cb0b04
Author: Jonas Gorski <jogo@openwrt.org>
Date:   Mon Oct 12 13:13:02 2015 +0200

    MIPS: Make the kernel arguments from dtb available
    
    Similar to how arm allows using selecting between bootloader arguments,
    dtb arguments and both, allow to select them on mips. But since we have
    less control over the place of the dtb do not modify it but instead use
    the boot_command_line for merging them.
    
    The default is "use bootloader arguments" to keep the current behaviour
    as default.
    
    Signed-off-by: Jonas Gorski <jogo@openwrt.org>
    Cc: linux-mips@linux-mips.org
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: John Crispin <blogic@openwrt.org>
    Cc: Ganesan Ramalingam <ganesanr@broadcom.com>
    Cc: Jayachandran C <jchandra@broadcom.com>
    Cc: Andrew Bresticker <abrestic@chromium.org>
    Cc: James Hartley <james.hartley@imgtec.com>
    Patchwork: https://patchwork.linux-mips.org/patch/11284/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 5b46b672c939..6f142ee4a086 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -617,6 +617,10 @@ static void __init request_crashkernel(struct resource *res)
 }
 #endif /* !defined(CONFIG_KEXEC)  */
 
+#define USE_PROM_CMDLINE	IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_BOOTLOADER)
+#define USE_DTB_CMDLINE		IS_ENABLED(CONFIG_MIPS_CMDLINE_FROM_DTB)
+#define EXTEND_WITH_PROM	IS_ENABLED(CONFIG_MIPS_CMDLINE_EXTEND)
+
 static void __init arch_mem_init(char **cmdline_p)
 {
 	struct memblock_region *reg;
@@ -641,18 +645,24 @@ static void __init arch_mem_init(char **cmdline_p)
 	pr_info("Determined physical RAM map:\n");
 	print_memory_map();
 
-#ifdef CONFIG_CMDLINE_BOOL
-#ifdef CONFIG_CMDLINE_OVERRIDE
+#if defined(CONFIG_CMDLINE_BOOL) && defined(CONFIG_CMDLINE_OVERRIDE)
 	strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
 #else
+	if ((USE_PROM_CMDLINE && arcs_cmdline[0]) ||
+	    (USE_DTB_CMDLINE && !boot_command_line[0]))
+		strlcpy(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
+
+	if (EXTEND_WITH_PROM && arcs_cmdline[0]) {
+		strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
+		strlcat(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
+	}
+
+#if defined(CONFIG_CMDLINE_BOOL)
 	if (builtin_cmdline[0]) {
-		strlcat(arcs_cmdline, " ", COMMAND_LINE_SIZE);
-		strlcat(arcs_cmdline, builtin_cmdline, COMMAND_LINE_SIZE);
+		strlcat(boot_command_line, " ", COMMAND_LINE_SIZE);
+		strlcat(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
 	}
-	strlcpy(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
 #endif
-#else
-	strlcpy(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
 #endif
 	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
 

commit 75dcfc1d678d76a82288c043bfd5bfc0fbd43b49
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Tue Sep 22 10:10:55 2015 -0700

    MIPS: Declare mips_debugfs_dir in a header
    
    We have many extern declarations of mips_debugfs_dir through arch/mips/
    in various C files. Unify them by declaring mips_debugfs_dir in a
    header, including it in each affected C file & removing the duplicate
    declarations.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Cc: Masahiro Yamada <yamada.masahiro@socionext.com>
    Cc: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: linux-kernel@vger.kernel.org
    Cc: Joe Perches <joe@perches.com>
    Cc: Jaedon Shin <jaedon.shin@gmail.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: David Daney <david.daney@cavium.com>
    Cc: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Cc: James Cowgill <James.Cowgill@imgtec.com>
    Patchwork: https://patchwork.linux-mips.org/patch/11181/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 479515109e5b..5b46b672c939 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -33,6 +33,7 @@
 #include <asm/cache.h>
 #include <asm/cdmm.h>
 #include <asm/cpu.h>
+#include <asm/debug.h>
 #include <asm/sections.h>
 #include <asm/setup.h>
 #include <asm/smp-ops.h>

commit 88d3426942d748b90b051b7ef2d5d765f5f3054c
Author: Alexander Sverdlin <alexander.sverdlin@gmail.com>
Date:   Thu Sep 3 08:36:35 2015 +0200

    MIPS: bootmem: Fix mapstart calculation for contiguous maps
    
    Commit a6335fa1 fixed the case with gap between initrd and next usable PFN zone,
    but broken the case when initrd is combined with usable memory into one region
    (in add_memory_region()). Restore the fixup initially brought in by f9a7febd.
    
    ---- error message ----
    Unpacking initramfs...
    Initramfs unpacking failed: junk in compressed archive
    BUG: Bad page state in process swapper  pfn:00261
    page:81004c20 count:0 mapcount:-127 mapping:  (null) index:0x2
    flags: 0x0()
    page dumped because: nonzero mapcount
    CPU: 0 PID: 1 Comm: swapper Not tainted 4.2.0+ #1782
    -----------------------
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@gmail.com>
    Reported-by: Tony Wu <tung7970@gmail.com>
    Tested-by: Tony Wu <tung7970@gmail.com>
    Cc: David Daney <david.daney@cavium.com>
    Cc: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Cc: stable@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/11086/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 35b8316002f8..479515109e5b 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -338,7 +338,7 @@ static void __init bootmem_init(void)
 		if (end <= reserved_end)
 			continue;
 #ifdef CONFIG_BLK_DEV_INITRD
-		/* mapstart should be after initrd_end */
+		/* Skip zones before initrd and initrd itself */
 		if (initrd_end && end <= (unsigned long)PFN_UP(__pa(initrd_end)))
 			continue;
 #endif
@@ -371,6 +371,14 @@ static void __init bootmem_init(void)
 		max_low_pfn = PFN_DOWN(HIGHMEM_START);
 	}
 
+#ifdef CONFIG_BLK_DEV_INITRD
+	/*
+	 * mapstart should be after initrd_end
+	 */
+	if (initrd_end)
+		mapstart = max(mapstart, (unsigned long)PFN_UP(__pa(initrd_end)));
+#endif
+
 	/*
 	 * Initialize the boot-time allocator with low memory only.
 	 */

commit e1c05067c323fb92d27418fb3586171bd7ce2e12
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Tue Jul 7 10:14:59 2015 +0900

    treewide: fix typos in comment blocks
    
    Looks like the word "contiguous" is often mistyped.
    
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.com>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 008b3378653a..35b8316002f8 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -476,7 +476,7 @@ static void __init bootmem_init(void)
  *  o bootmem_init()
  *  o sparse_init()
  *  o paging_init()
- *  o dma_continguous_reserve()
+ *  o dma_contiguous_reserve()
  *
  * At this stage the bootmem allocator is ready to use.
  *

commit a6335fa11e08fc386740557b2a4c1b7ff34bc499
Author: Alexander Sverdlin <alexander.sverdlin@nokia.com>
Date:   Thu Jul 2 17:16:01 2015 +0200

    MIPS: bootmem: Don't use memory holes for page bitmap
    
    Commit f9a7febd leads to a fact that mapstart and therefore a page bitmap for
    bootmem allocator immediately follows initrd_end. This doesn't always work
    well on Octeon, where there are holes in PFN ranges (refer to 5b3b1688 and
    4MB-aligned PFN allocation). Depending on the inird location it could happen,
    that mapstart would be in an area not allocated by plat_mem_setup() in
    arch/mips/cavium-octeon/setup.c, but in the alignment hole between initrd and
    the next PFN area. Later on this memory will be unconditionally made available
    to buddy allocator at the end of free_all_bootmem_core() (mm/bootmem.c).
    All of this results in Linux using the memory not designated for Linux in
    Octeon's plat_mem_setup(), which in turn means corruption of the memory used
    by another OS/baremetal code on the same SoC.
    
    It doesn't look to me as a problem of Octeon platform code, but rather as an
    inability of f9a7febd to deal correctly with the fragmented memory-mappings.
    Proposed fix moves the check for initrd address to the same calculation-loop
    in bootmem_init() (arch/mips/kernel/setup.c), which also accounts for kernel
    code location. This should result in mapstart located starting from the first
    PFN area after kernel code AND initrd.
    
    Signed-off-by: Alexander Sverdlin <alexander.sverdlin@nokia.com>
    Cc: linux-mips@linux-mips.org
    Cc: David Daney <david.daney@cavium.com>
    Cc: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: Andreas Herrmann <andreas.herrmann@caviumnetworks.com>
    Cc: Joe Perches <joe@perches.com>
    Cc: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: Yusuf Khan <yusuf.khan@nokia.com>
    Cc: Michael Kreuzer <michael.kreuzer@nokia.com>
    Cc: Aaro Koskinen <aaro.koskinen@iki.fi>
    Patchwork: https://patchwork.linux-mips.org/patch/10594/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index be73c491182b..008b3378653a 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -337,6 +337,11 @@ static void __init bootmem_init(void)
 			min_low_pfn = start;
 		if (end <= reserved_end)
 			continue;
+#ifdef CONFIG_BLK_DEV_INITRD
+		/* mapstart should be after initrd_end */
+		if (initrd_end && end <= (unsigned long)PFN_UP(__pa(initrd_end)))
+			continue;
+#endif
 		if (start >= mapstart)
 			continue;
 		mapstart = max(reserved_end, start);
@@ -366,14 +371,6 @@ static void __init bootmem_init(void)
 		max_low_pfn = PFN_DOWN(HIGHMEM_START);
 	}
 
-#ifdef CONFIG_BLK_DEV_INITRD
-	/*
-	 * mapstart should be after initrd_end
-	 */
-	if (initrd_end)
-		mapstart = max(mapstart, (unsigned long)PFN_UP(__pa(initrd_end)));
-#endif
-
 	/*
 	 * Initialize the boot-time allocator with low memory only.
 	 */

commit e934945db7625716f9cc469e31fc5da8666c8024
Author: James Hogan <james.hogan@imgtec.com>
Date:   Thu Jan 29 11:14:13 2015 +0000

    MIPS, ttyFDC: Add early FDC console support
    
    Add support for early console of MIPS Fast Debug Channel (FDC) on
    channel 1 with a call very early from the MIPS setup_arch().
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/9145/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 058929041368..be73c491182b 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -31,6 +31,7 @@
 #include <asm/bootinfo.h>
 #include <asm/bugs.h>
 #include <asm/cache.h>
+#include <asm/cdmm.h>
 #include <asm/cpu.h>
 #include <asm/sections.h>
 #include <asm/setup.h>
@@ -763,6 +764,7 @@ void __init setup_arch(char **cmdline_p)
 	cpu_probe();
 	prom_init();
 
+	setup_early_fdc_console();
 #ifdef CONFIG_EARLY_PRINTK
 	setup_early_printk();
 #endif

commit ad8f723afbfe242ad2bc5067e06ca438b6a5c8a9
Author: Jaedon Shin <jaedon.shin@gmail.com>
Date:   Fri Dec 12 19:51:15 2014 +0100

    MIPS: Use phys_addr_t instead of phys_t
    
    Ralf Baechle says:
     "This should have been part of the merge commit c0222ac08666 (Merge
      branch 'upstream' of git://git.linux-mips.org/pub/scm/-
      ralf/upstream-linus) but I forgot to mention the need for this in my
      pull request"
    
    Signed-off-by: Jaedon Shin <jaedon.shin@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index a8c20afeb813..058929041368 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -493,7 +493,7 @@ static int usermem __initdata;
 
 static int __init early_parse_mem(char *p)
 {
-	phys_t start, size;
+	phys_addr_t start, size;
 
 	/*
 	 * If a user specifies memory size, we

commit c0222ac086669a631814bbf857f8c8023452a4d7
Merge: 140cd7fb04a4 e2965cd0003f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Dec 11 17:56:37 2014 -0800

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
     "This is an unusually large pull request for MIPS - in parts because
      lots of patches missed the 3.18 deadline but primarily because some
      folks opened the flood gates.
    
       - Retire the MIPS-specific phys_t with the generic phys_addr_t.
       - Improvments for the backtrace code used by oprofile.
       - Better backtraces on SMP systems.
       - Cleanups for the Octeon platform code.
       - Cleanups and fixes for the Loongson platform code.
       - Cleanups and fixes to the firmware library.
       - Switch ATH79 platform to use the firmware library.
       - Grand overhault to the SEAD3 and Malta interrupt code.
       - Move the GIC interrupt code to drivers/irqchip
       - Lots of GIC cleanups and updates to the GIC code to use modern IRQ
         infrastructures and features of the kernel.
       - OF documentation updates for the GIC bindings
       - Move GIC clocksource driver to drivers/clocksource
       - Merge GIC clocksource driver with clockevent driver.
       - Further updates to bring the GIC clocksource driver up to date.
       - R3000 TLB code cleanups
       - Improvments to the Loongson 3 platform code.
       - Convert pr_warning to pr_warn.
       - Merge a bunch of small lantiq and ralink fixes that have been
         staged/lingering inside the openwrt tree for a while.
       - Update archhelp for IP22/IP32
       - Fix a number of issues for Loongson 1B.
       - New clocksource and clockevent driver for Loongson 1B.
       - Further work on clk handling for Loongson 1B.
       - Platform work for Broadcom BMIPS.
       - Error handling cleanups for TurboChannel.
       - Fixes and optimization to the microMIPS support.
       - Option to disable the FTLB.
       - Dump more relevant information on machine check exception
       - Change binfmt to allow arch to examine PT_*PROC headers
       - Support for new style FPU register model in O32
       - VDSO randomization.
       - BCM47xx cleanups
       - BCM47xx reimplement the way the kernel accesses NVRAM information.
       - Random cleanups
       - Add support for ATH25 platforms
       - Remove pointless locking code in some PCI platforms.
       - Some improvments to EVA support
       - Minor Alchemy cleanup"
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (185 commits)
      MIPS: Add MFHC0 and MTHC0 instructions to uasm.
      MIPS: Cosmetic cleanups of page table headers.
      MIPS: Add CP0 macros for extended EntryLo registers
      MIPS: Remove now unused definition of phys_t.
      MIPS: Replace use of phys_t with phys_addr_t.
      MIPS: Replace MIPS-specific 64BIT_PHYS_ADDR with generic PHYS_ADDR_T_64BIT
      PCMCIA: Alchemy Don't select 64BIT_PHYS_ADDR in Kconfig.
      MIPS: lib: memset: Clean up some MIPS{EL,EB} ifdefery
      MIPS: iomap: Use __mem_{read,write}{b,w,l} for MMIO
      MIPS: <asm/types.h> fix indentation.
      MAINTAINERS: Add entry for BMIPS multiplatform kernel
      MIPS: Enable VDSO randomization
      MIPS: Remove a temporary hack for debugging cache flushes in SMTC configuration
      MIPS: Remove declaration of obsolete arch_init_clk_ops()
      MIPS: atomic.h: Reformat to fit in 79 columns
      MIPS: Apply `.insn' to fixup labels throughout
      MIPS: Fix microMIPS LL/SC immediate offsets
      MIPS: Kconfig: Only allow 32-bit microMIPS builds
      MIPS: signal.c: Fix an invalid cast in ISA mode bit handling
      MIPS: mm: Only build one microassembler that is suitable
      ...

commit 15d45cce3a0e0716fa49c768f887c6406dfb91f7
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Nov 22 00:22:09 2014 +0100

    MIPS: Replace use of phys_t with phys_addr_t.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index eacfd7dbe8cc..a51c023d0707 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -82,7 +82,7 @@ static struct resource data_resource = { .name = "Kernel data", };
 
 static void *detect_magic __initdata = detect_memory_region;
 
-void __init add_memory_region(phys_t start, phys_t size, long type)
+void __init add_memory_region(phys_addr_t start, phys_addr_t size, long type)
 {
 	int x = boot_mem_map.nr_map;
 	int i;
@@ -127,10 +127,10 @@ void __init add_memory_region(phys_t start, phys_t size, long type)
 	boot_mem_map.nr_map++;
 }
 
-void __init detect_memory_region(phys_t start, phys_t sz_min, phys_t sz_max)
+void __init detect_memory_region(phys_addr_t start, phys_addr_t sz_min, phys_addr_t sz_max)
 {
 	void *dm = &detect_magic;
-	phys_t size;
+	phys_addr_t size;
 
 	for (size = sz_min; size < sz_max; size <<= 1) {
 		if (!memcmp(dm, dm + size, sizeof(detect_magic)))
@@ -545,9 +545,9 @@ static int __init early_parse_elfcorehdr(char *p)
 early_param("elfcorehdr", early_parse_elfcorehdr);
 #endif
 
-static void __init arch_mem_addpart(phys_t mem, phys_t end, int type)
+static void __init arch_mem_addpart(phys_addr_t mem, phys_addr_t end, int type)
 {
-	phys_t size;
+	phys_addr_t size;
 	int i;
 
 	size = end - mem;

commit 7178d2cdd9f5f70902dd0201ebcf01c9489c4afb
Author: Joe Perches <joe@perches.com>
Date:   Sat Oct 4 09:50:42 2014 -0700

    mips: Convert pr_warning to pr_warn
    
    Use the much more common pr_warn instead of pr_warning
    with the goal of removing pr_warning eventually.
    
    Other miscellanea:
    
    o Coalesce formats
    o Realign arguments
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Cc: linux-mips <linux-mips@linux-mips.org>
    Cc: LKML <linux-kernel@vger.kernel.org>
    Patchwork: https://patchwork.linux-mips.org/patch/7935/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index d21ec57b6e95..eacfd7dbe8cc 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -89,7 +89,7 @@ void __init add_memory_region(phys_t start, phys_t size, long type)
 
 	/* Sanity check */
 	if (start + size < start) {
-		pr_warning("Trying to add an invalid memory region, skipped\n");
+		pr_warn("Trying to add an invalid memory region, skipped\n");
 		return;
 	}
 

commit b4da18b3714a35c1123522810cc5ec0cd2ee4101
Author: Steven J. Hill <Steven.Hill@imgtec.com>
Date:   Thu Nov 13 09:52:00 2014 -0600

    MIPS: Fix address type used for early memory detection.
    
    In 'early_parse_mem' the data type used for the start
    and size of a memory region specified on the command line
    is incorrect. If 64-bit addressing is used, the value
    gets truncated.
    
    Signed-off-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/8456/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 083c3c289577..f3b635f86c39 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -493,7 +493,7 @@ static int usermem __initdata;
 
 static int __init early_parse_mem(char *p)
 {
-	unsigned long start, size;
+	phys_t start, size;
 
 	/*
 	 * If a user specifies memory size, we

commit 7f0dd7683c4d7e01dc99d8922190af6bcc9a0860
Author: RafaÅ‚ MiÅ‚ecki <zajec5@gmail.com>
Date:   Wed Sep 3 07:36:51 2014 +0200

    MIPS: Fix info about plat_setup in arch_mem_init comment
    
    Signed-off-by: RafaÅ‚ MiÅ‚ecki <zajec5@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7607/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index d21ec57b6e95..083c3c289577 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -485,7 +485,7 @@ static void __init bootmem_init(void)
  * NOTE: historically plat_mem_setup did the entire platform initialization.
  *	 This was rather impractical because it meant plat_mem_setup had to
  * get away without any kind of memory allocator.  To keep old code from
- * breaking plat_setup was just renamed to plat_setup and a second platform
+ * breaking plat_setup was just renamed to plat_mem_setup and a second platform
  * initialization hook for anything else was introduced.
  */
 

commit 30fa0530ff87f6379e046629adfa3f4872a2d353
Author: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
Date:   Tue Oct 28 11:28:34 2014 +0000

    MIPS: CMA: Do not reserve memory if not required
    
    Even if CMA is disabled, the for_each_memblock macro expands
    to run reserve_bootmem once. Hence, reserve_bootmem attempts to
    reserve location 0 of size 0.
    
    Add a check to avoid that.
    
    Issue was highlighted during testing with EVA enabled.
    resrve_bootmem used to exit gracefully when passed arguments to
    reserve 0 size location at 0 without EVA.
    
    But with EVA enabled, macros would point to different addresses
    and the code would trigger a BUG.
    
    Signed-off-by: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
    Tested-by: Markos Chandras <markos.chandras@imgtec.com>
    Tested-by: Huacai Chen <chenhc@lemote.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/8231/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index b3b8f0d9d4a7..d21ec57b6e95 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -683,7 +683,8 @@ static void __init arch_mem_init(char **cmdline_p)
 	dma_contiguous_reserve(PFN_PHYS(max_low_pfn));
 	/* Tell bootmem about cma reserved memblock section */
 	for_each_memblock(reserved, reg)
-		reserve_bootmem(reg->base, reg->size, BOOTMEM_DEFAULT);
+		if (reg->size != 0)
+			reserve_bootmem(reg->base, reg->size, BOOTMEM_DEFAULT);
 }
 
 static void __init resource_init(void)

commit f46493826a79f6a2bf9d8a0030e627e0255bbf48
Author: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
Date:   Wed Jul 16 16:51:32 2014 +0100

    MIPS: DMA: Add cma support
    
    Adds cma support to the MIPS architecture.
    
    cma uses memblock. However, mips uses bootmem.
    bootmem is informed about any regions reserved by memblock
    
    dma api is modified to use cma reserved memory regions when available
    
    Tested using cma_test. cma_test is a simple driver that assigns blocks
    of memory from cma reserved sections.
    
    Signed-off-by: Zubair Lutfullah Kakakhel <Zubair.Kakakhel@imgtec.com>
    Acked-by: Michal Nazarewicz <mina86@mina86.com>
    Cc: catalin.marinas@arm.com
    Cc: will.deacon@arm.com
    Cc: tglx@linutronix.de
    Cc: mingo@redhat.com
    Cc: hpa@zytor.com
    Cc: arnd@arndb.de
    Cc: gregkh@linuxfoundation.org
    Cc: m.szyprowski@samsung.com
    Cc: x86@kernel.org
    Cc: linux-arm-kernel@lists.infradead.org
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-arch@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/7360/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 7c1fe2b42d40..b3b8f0d9d4a7 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -24,6 +24,8 @@
 #include <linux/debugfs.h>
 #include <linux/kexec.h>
 #include <linux/sizes.h>
+#include <linux/device.h>
+#include <linux/dma-contiguous.h>
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
@@ -476,6 +478,7 @@ static void __init bootmem_init(void)
  *  o bootmem_init()
  *  o sparse_init()
  *  o paging_init()
+ *  o dma_continguous_reserve()
  *
  * At this stage the bootmem allocator is ready to use.
  *
@@ -609,6 +612,7 @@ static void __init request_crashkernel(struct resource *res)
 
 static void __init arch_mem_init(char **cmdline_p)
 {
+	struct memblock_region *reg;
 	extern void plat_mem_setup(void);
 
 	/* call board setup routine */
@@ -675,6 +679,11 @@ static void __init arch_mem_init(char **cmdline_p)
 	sparse_init();
 	plat_swiotlb_setup();
 	paging_init();
+
+	dma_contiguous_reserve(PFN_PHYS(max_low_pfn));
+	/* Tell bootmem about cma reserved memblock section */
+	for_each_memblock(reserved, reg)
+		reserve_bootmem(reg->base, reg->size, BOOTMEM_DEFAULT);
 }
 
 static void __init resource_init(void)

commit c46173183657bbdbe0d54a981c28807581648422
Author: Huacai Chen <chenhc@lemote.com>
Date:   Thu Jun 26 11:41:28 2014 +0800

    MIPS: Add NUMA support for Loongson-3
    
    Multiple Loongson-3A chips can be interconnected with HT0-bus. This is
    a CC-NUMA system that every chip (node) has its own local memory and
    cache coherency is maintained by hardware. The 64-bit physical memory
    address format is as follows:
    
    0x-0000-YZZZ-ZZZZ-ZZZZ
    
    The high 16 bits should be 0, which means the real physical address
    supported by Loongson-3 is 48-bit. The "Y" bits is the base address of
    each node, which can be also considered as the node-id. The "Z" bits is
    the address offset within a node, which means every node has a 44 bits
    address space.
    
    Macros XPHYSADDR and MAX_PHYSMEM_BITS are modified unconditionally,
    because many other MIPS CPUs have also extended their address spaces.
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Cc: John Crispin <john@phrozen.org>
    Cc: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: linux-mips@linux-mips.org
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/7187/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 2f01201b158c..7c1fe2b42d40 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -282,7 +282,7 @@ static unsigned long __init init_initrd(void)
  * Initialize the bootmem allocator. It also setup initrd related data
  * if needed.
  */
-#ifdef CONFIG_SGI_IP27
+#if defined(CONFIG_SGI_IP27) || (defined(CONFIG_CPU_LOONGSON3) && defined(CONFIG_NUMA))
 
 static void __init bootmem_init(void)
 {

commit 0f3f506b275517250ee0169ec075d5382967f5f6
Author: Huacai Chen <chenhc@lemote.com>
Date:   Thu Jun 26 11:41:25 2014 +0800

    MIPS: Support hard limit of cpu count (nr_cpu_ids)
    
    On MIPS currently, only the soft limit of cpu count (maxcpus) has its
    effect, this patch enable the hard limit (nr_cpus) as well. Processor
    cores which greater than maxcpus and less than nr_cpus can be taken up
    via cpu hotplug. The code is borrowed from X86.
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Reviewed-by: Andreas Herrmann <andreas.herrmann@caviumnetworks.com>
    Cc: John Crispin <john@phrozen.org>
    Cc: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: linux-mips@linux-mips.org
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/7183/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index a842154d57dc..2f01201b158c 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -729,6 +729,25 @@ static void __init resource_init(void)
 	}
 }
 
+#ifdef CONFIG_SMP
+static void __init prefill_possible_map(void)
+{
+	int i, possible = num_possible_cpus();
+
+	if (possible > nr_cpu_ids)
+		possible = nr_cpu_ids;
+
+	for (i = 0; i < possible; i++)
+		set_cpu_possible(i, true);
+	for (; i < NR_CPUS; i++)
+		set_cpu_possible(i, false);
+
+	nr_cpu_ids = possible;
+}
+#else
+static inline void prefill_possible_map(void) {}
+#endif
+
 void __init setup_arch(char **cmdline_p)
 {
 	cpu_probe();
@@ -752,6 +771,7 @@ void __init setup_arch(char **cmdline_p)
 
 	resource_init();
 	plat_smp_setup();
+	prefill_possible_map();
 
 	cpu_cache_init();
 }

commit f9a7febd82f413b9c8bafd40145bc398b7eb619f
Author: Greg Ungerer <gerg@snapgear.com>
Date:   Wed Sep 8 15:50:43 2010 +1000

    MIPS: Fix start of free memory when using initrd
    
    Currently when using an initrd on a MIPS system the start of the bootmem
    region of memory is set to the larger of the end of the kernel bss region
    (_end) or the end of the initrd. In a typical memory layout where the
    initrd is at some address above the kernel image this means that the start
    of the bootmem region will be the end of the initrd. But when we are done
    processing/loading the initrd we have no way to reclaim the memory region
    it occupied, and we lose a large chunk of now otherwise empty RAM from our
    final running system.
    
    The bootmem code is designed to allow this initrd to be reserved (and the
    code in finalize_initrd() currently does this). When the initrd is finally
    processed/loaded its reserved memory is freed.
    
    Fix the setting of the start of the bootmem map to be the end of the kernel.
    
    [ralf@linux-mips.org: fold in the fix of Ashok Kumar <ashoks@broadcom.com>.]
    
    Signed-off-by: Greg Ungerer <gerg@uclinux.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/1574/
    Cc: Ashok Kumar <ashoks@broadcom.com>
    Patchwork: https://patchwork.linux-mips.org/patch/5883/
    Patchwork: https://patchwork.linux-mips.org/patch/6028/
    Patchwork: https://patchwork.linux-mips.org/patch/6064/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c538d6e01b7b..a842154d57dc 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -300,12 +300,13 @@ static void __init bootmem_init(void)
 	int i;
 
 	/*
-	 * Init any data related to initrd. It's a nop if INITRD is
-	 * not selected. Once that done we can determine the low bound
-	 * of usable memory.
+	 * Sanity check any INITRD first. We don't take it into account
+	 * for bootmem setup initially, rely on the end-of-kernel-code
+	 * as our memory range starting point. Once bootmem is inited we
+	 * will reserve the area used for the initrd.
 	 */
-	reserved_end = max(init_initrd(),
-			   (unsigned long) PFN_UP(__pa_symbol(&_end)));
+	init_initrd();
+	reserved_end = (unsigned long) PFN_UP(__pa_symbol(&_end));
 
 	/*
 	 * max_low_pfn is not a number of pages. The number of pages
@@ -362,6 +363,14 @@ static void __init bootmem_init(void)
 		max_low_pfn = PFN_DOWN(HIGHMEM_START);
 	}
 
+#ifdef CONFIG_BLK_DEV_INITRD
+	/*
+	 * mapstart should be after initrd_end
+	 */
+	if (initrd_end)
+		mapstart = max(mapstart, (unsigned long)PFN_UP(__pa(initrd_end)));
+#endif
+
 	/*
 	 * Initialize the boot-time allocator with low memory only.
 	 */

commit c2882b7fab9251309dc10c980b17e486f848502f
Author: Prem Mallappa <prem.mallappa@gmail.com>
Date:   Wed Sep 4 23:26:24 2013 +0530

    MIPS: kexec: Fix random crashes while loading crashkernel
    
    Fixed compilation errors in case of non-KEXEC kernel
    Rearranging code so that crashk_res gets updated.
    - crashk_res is updated after mips_parse_crashkernel(),
       after resource_init(), which is after arch_mem_init().
    - The reserved memory is actually treated as Usable memory,
       Unless we load the crash kernel, everything works.
    
    Signed-off-by: Prem Mallappa <pmallappa@caviumnetworks.com>
    Cc: linux-mips <linux-mips@linux-mips.org>
    Patchwork: http://patchwork.linux-mips.org/patch/5805/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c7f90519e58c..c538d6e01b7b 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -552,6 +552,52 @@ static void __init arch_mem_addpart(phys_t mem, phys_t end, int type)
 	add_memory_region(mem, size, type);
 }
 
+#ifdef CONFIG_KEXEC
+static inline unsigned long long get_total_mem(void)
+{
+	unsigned long long total;
+
+	total = max_pfn - min_low_pfn;
+	return total << PAGE_SHIFT;
+}
+
+static void __init mips_parse_crashkernel(void)
+{
+	unsigned long long total_mem;
+	unsigned long long crash_size, crash_base;
+	int ret;
+
+	total_mem = get_total_mem();
+	ret = parse_crashkernel(boot_command_line, total_mem,
+				&crash_size, &crash_base);
+	if (ret != 0 || crash_size <= 0)
+		return;
+
+	crashk_res.start = crash_base;
+	crashk_res.end	 = crash_base + crash_size - 1;
+}
+
+static void __init request_crashkernel(struct resource *res)
+{
+	int ret;
+
+	ret = request_resource(res, &crashk_res);
+	if (!ret)
+		pr_info("Reserving %ldMB of memory at %ldMB for crashkernel\n",
+			(unsigned long)((crashk_res.end -
+					 crashk_res.start + 1) >> 20),
+			(unsigned long)(crashk_res.start  >> 20));
+}
+#else /* !defined(CONFIG_KEXEC)		*/
+static void __init mips_parse_crashkernel(void)
+{
+}
+
+static void __init request_crashkernel(struct resource *res)
+{
+}
+#endif /* !defined(CONFIG_KEXEC)  */
+
 static void __init arch_mem_init(char **cmdline_p)
 {
 	extern void plat_mem_setup(void);
@@ -608,6 +654,8 @@ static void __init arch_mem_init(char **cmdline_p)
 				BOOTMEM_DEFAULT);
 	}
 #endif
+
+	mips_parse_crashkernel();
 #ifdef CONFIG_KEXEC
 	if (crashk_res.start != crashk_res.end)
 		reserve_bootmem(crashk_res.start,
@@ -620,52 +668,6 @@ static void __init arch_mem_init(char **cmdline_p)
 	paging_init();
 }
 
-#ifdef CONFIG_KEXEC
-static inline unsigned long long get_total_mem(void)
-{
-	unsigned long long total;
-
-	total = max_pfn - min_low_pfn;
-	return total << PAGE_SHIFT;
-}
-
-static void __init mips_parse_crashkernel(void)
-{
-	unsigned long long total_mem;
-	unsigned long long crash_size, crash_base;
-	int ret;
-
-	total_mem = get_total_mem();
-	ret = parse_crashkernel(boot_command_line, total_mem,
-				&crash_size, &crash_base);
-	if (ret != 0 || crash_size <= 0)
-		return;
-
-	crashk_res.start = crash_base;
-	crashk_res.end	 = crash_base + crash_size - 1;
-}
-
-static void __init request_crashkernel(struct resource *res)
-{
-	int ret;
-
-	ret = request_resource(res, &crashk_res);
-	if (!ret)
-		pr_info("Reserving %ldMB of memory at %ldMB for crashkernel\n",
-			(unsigned long)((crashk_res.end -
-				crashk_res.start + 1) >> 20),
-			(unsigned long)(crashk_res.start  >> 20));
-}
-#else /* !defined(CONFIG_KEXEC)	 */
-static void __init mips_parse_crashkernel(void)
-{
-}
-
-static void __init request_crashkernel(struct resource *res)
-{
-}
-#endif /* !defined(CONFIG_KEXEC)  */
-
 static void __init resource_init(void)
 {
 	int i;
@@ -678,11 +680,6 @@ static void __init resource_init(void)
 	data_resource.start = __pa_symbol(&_etext);
 	data_resource.end = __pa_symbol(&_edata) - 1;
 
-	/*
-	 * Request address space for all standard RAM.
-	 */
-	mips_parse_crashkernel();
-
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		struct resource *res;
 		unsigned long start, end;

commit 4d9f77d2526840fc2b3d4dcaedfd2f633a6d5426
Author: John Crispin <blogic@openwrt.org>
Date:   Sat Apr 13 13:15:47 2013 +0200

    MIPS: add detect_memory_region()
    
    Add a generic way of detecting the available RAM. This function is based on the
    implementation already used by ath79.
    
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/5178/

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 4c774d5d5087..c7f90519e58c 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -23,6 +23,7 @@
 #include <linux/pfn.h>
 #include <linux/debugfs.h>
 #include <linux/kexec.h>
+#include <linux/sizes.h>
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
@@ -77,6 +78,8 @@ EXPORT_SYMBOL(mips_io_port_base);
 static struct resource code_resource = { .name = "Kernel code", };
 static struct resource data_resource = { .name = "Kernel data", };
 
+static void *detect_magic __initdata = detect_memory_region;
+
 void __init add_memory_region(phys_t start, phys_t size, long type)
 {
 	int x = boot_mem_map.nr_map;
@@ -122,6 +125,25 @@ void __init add_memory_region(phys_t start, phys_t size, long type)
 	boot_mem_map.nr_map++;
 }
 
+void __init detect_memory_region(phys_t start, phys_t sz_min, phys_t sz_max)
+{
+	void *dm = &detect_magic;
+	phys_t size;
+
+	for (size = sz_min; size < sz_max; size <<= 1) {
+		if (!memcmp(dm, dm + size, sizeof(detect_magic)))
+			break;
+	}
+
+	pr_debug("Memory: %lluMB of RAM detected at 0x%llx (min: %lluMB, max: %lluMB)\n",
+		((unsigned long long) size) / SZ_1M,
+		(unsigned long long) start,
+		((unsigned long long) sz_min) / SZ_1M,
+		((unsigned long long) sz_max) / SZ_1M);
+
+	add_memory_region(start, size, BOOT_MEM_RAM);
+}
+
 static void __init print_memory_map(void)
 {
 	int i;

commit 8bfc245f9ad7bd4e461179e4e7852ef99b8b6144
Merge: 612663a97406 535237cecab2
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Feb 21 12:51:33 2013 +0100

    Merge branch 'mips-next-3.9' of git://git.linux-mips.org/pub/scm/john/linux-john into mips-for-linux-next

commit 4893fc8856a81d2037c1c976cb320be6f00e84a0
Author: Corey Minyard <cminyard@mvista.com>
Date:   Tue Feb 12 19:41:48 2013 +0000

    mips: reserve elfcorehdr
    
    /proc/vmcore wasn't showing up in kdump kernels.  It turns that that
    for Octeon, the memory used by elfcorehdr wasn't being set aside
    properly and it was getting clobbered before /proc/vmcore could get
    it.  So reserve the memory if it shows up in a memory area managed
    by the kernel.
    
    Signed-off-by: Corey Minyard <cminyard@mvista.com>
    Acked-by: David Daney  <ddaney@caviumnetworks.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4936/

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 53462500c3cd..795f4379c0b6 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -480,6 +480,37 @@ static int __init early_parse_mem(char *p)
 }
 early_param("mem", early_parse_mem);
 
+#ifdef CONFIG_PROC_VMCORE
+unsigned long setup_elfcorehdr, setup_elfcorehdr_size;
+static int __init early_parse_elfcorehdr(char *p)
+{
+	int i;
+
+	setup_elfcorehdr = memparse(p, &p);
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		unsigned long start = boot_mem_map.map[i].addr;
+		unsigned long end = (boot_mem_map.map[i].addr +
+				     boot_mem_map.map[i].size);
+		if (setup_elfcorehdr >= start && setup_elfcorehdr < end) {
+			/*
+			 * Reserve from the elf core header to the end of
+			 * the memory segment, that should all be kdump
+			 * reserved memory.
+			 */
+			setup_elfcorehdr_size = end - setup_elfcorehdr;
+			break;
+		}
+	}
+	/*
+	 * If we don't find it in the memory map, then we shouldn't
+	 * have to worry about it, as the new kernel won't use it.
+	 */
+	return 0;
+}
+early_param("elfcorehdr", early_parse_elfcorehdr);
+#endif
+
 static void __init arch_mem_addpart(phys_t mem, phys_t end, int type)
 {
 	phys_t size;
@@ -547,6 +578,14 @@ static void __init arch_mem_init(char **cmdline_p)
 	}
 
 	bootmem_init();
+#ifdef CONFIG_PROC_VMCORE
+	if (setup_elfcorehdr && setup_elfcorehdr_size) {
+		printk(KERN_INFO "kdump reserved memory at %lx-%lx\n",
+		       setup_elfcorehdr, setup_elfcorehdr_size);
+		reserve_bootmem(setup_elfcorehdr, setup_elfcorehdr_size,
+				BOOTMEM_DEFAULT);
+	}
+#endif
 #ifdef CONFIG_KEXEC
 	if (crashk_res.start != crashk_res.end)
 		reserve_bootmem(crashk_res.start,

commit d3ff9338023236f39332b07b3afed76c490a5041
Author: Corey Minyard <cminyard@mvista.com>
Date:   Tue Feb 12 19:41:47 2013 +0000

    mips: Make sure kernel memory is in iomem
    
    Kernel memory isn't necessarily added to the memory tables, so it
    wouldn't show up in /proc/iomem.  This was breaking kdump, which
    requires these memory addresses to work correctly.
    
    Signed-off-by: Corey Minyard <cminyard@mvista.com>
    Acked-by: David Daney <ddaney@caviumnetworks.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Patchwork: http://patchwork.linux-mips.org/patch/4937/

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 8c41187801ce..53462500c3cd 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -480,34 +480,44 @@ static int __init early_parse_mem(char *p)
 }
 early_param("mem", early_parse_mem);
 
-static void __init arch_mem_init(char **cmdline_p)
+static void __init arch_mem_addpart(phys_t mem, phys_t end, int type)
 {
-	phys_t init_mem, init_end, init_size;
+	phys_t size;
+	int i;
+
+	size = end - mem;
+	if (!size)
+		return;
+
+	/* Make sure it is in the boot_mem_map */
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		if (mem >= boot_mem_map.map[i].addr &&
+		    mem < (boot_mem_map.map[i].addr +
+			   boot_mem_map.map[i].size))
+			return;
+	}
+	add_memory_region(mem, size, type);
+}
 
+static void __init arch_mem_init(char **cmdline_p)
+{
 	extern void plat_mem_setup(void);
 
 	/* call board setup routine */
 	plat_mem_setup();
 
-	init_mem = PFN_UP(__pa_symbol(&__init_begin)) << PAGE_SHIFT;
-	init_end = PFN_DOWN(__pa_symbol(&__init_end)) << PAGE_SHIFT;
-	init_size = init_end - init_mem;
-	if (init_size) {
-		/* Make sure it is in the boot_mem_map */
-		int i, found;
-		found = 0;
-		for (i = 0; i < boot_mem_map.nr_map; i++) {
-			if (init_mem >= boot_mem_map.map[i].addr &&
-			    init_mem < (boot_mem_map.map[i].addr +
-					boot_mem_map.map[i].size)) {
-				found = 1;
-				break;
-			}
-		}
-		if (!found)
-			add_memory_region(init_mem, init_size,
-					  BOOT_MEM_INIT_RAM);
-	}
+	/*
+	 * Make sure all kernel memory is in the maps.  The "UP" and
+	 * "DOWN" are opposite for initdata since if it crosses over
+	 * into another memory section you don't want that to be
+	 * freed when the initdata is freed.
+	 */
+	arch_mem_addpart(PFN_DOWN(__pa_symbol(&_text)) << PAGE_SHIFT,
+			 PFN_UP(__pa_symbol(&_edata)) << PAGE_SHIFT,
+			 BOOT_MEM_RAM);
+	arch_mem_addpart(PFN_UP(__pa_symbol(&__init_begin)) << PAGE_SHIFT,
+			 PFN_DOWN(__pa_symbol(&__init_end)) << PAGE_SHIFT,
+			 BOOT_MEM_INIT_RAM);
 
 	pr_info("Determined physical RAM map:\n");
 	print_memory_map();

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 8c41187801ce..653197e151d5 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -8,7 +8,7 @@
  * Copyright (C) 1994, 95, 96, 97, 98, 99, 2000, 01, 02, 03  Ralf Baechle
  * Copyright (C) 1996 Stoned Elipot
  * Copyright (C) 1999 Silicon Graphics, Inc.
- * Copyright (C) 2000, 2001, 2002, 2007  Maciej W. Rozycki
+ * Copyright (C) 2000, 2001, 2002, 2007	 Maciej W. Rozycki
  */
 #include <linux/init.h>
 #include <linux/ioport.h>
@@ -449,7 +449,7 @@ static void __init bootmem_init(void)
  * At this stage the bootmem allocator is ready to use.
  *
  * NOTE: historically plat_mem_setup did the entire platform initialization.
- *       This was rather impractical because it meant plat_mem_setup had to
+ *	 This was rather impractical because it meant plat_mem_setup had to
  * get away without any kind of memory allocator.  To keep old code from
  * breaking plat_setup was just renamed to plat_setup and a second platform
  * initialization hook for anything else was introduced.
@@ -469,7 +469,7 @@ static int __init early_parse_mem(char *p)
 	if (usermem == 0) {
 		boot_mem_map.nr_map = 0;
 		usermem = 1;
- 	}
+	}
 	start = 0;
 	size = memparse(p, &p);
 	if (*p == '@')
@@ -571,7 +571,7 @@ static void __init mips_parse_crashkernel(void)
 		return;
 
 	crashk_res.start = crash_base;
-	crashk_res.end   = crash_base + crash_size - 1;
+	crashk_res.end	 = crash_base + crash_size - 1;
 }
 
 static void __init request_crashkernel(struct resource *res)
@@ -585,7 +585,7 @@ static void __init request_crashkernel(struct resource *res)
 				crashk_res.start + 1) >> 20),
 			(unsigned long)(crashk_res.start  >> 20));
 }
-#else /* !defined(CONFIG_KEXEC)  */
+#else /* !defined(CONFIG_KEXEC)	 */
 static void __init mips_parse_crashkernel(void)
 {
 }

commit 7aa1c8f47e7e792d11f898cbdddaf6fa21ff08cc
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 18:14:58 2012 +0200

    MIPS: kdump: Add support
    
    [ralf@linux-mips.org: Original patch by Maxim Uvarov <muvarov@gmail.com>
    with plenty of further shining, polishing, debugging and testing by me.]
    
    Signed-off-by: Maxim Uvarov <muvarov@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: kexec@lists.infradead.org
    Cc: horms@verge.net.au
    Patchwork: https://patchwork.linux-mips.org/patch/1025/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 290dc6a1d7a3..8c41187801ce 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -22,6 +22,7 @@
 #include <linux/console.h>
 #include <linux/pfn.h>
 #include <linux/debugfs.h>
+#include <linux/kexec.h>
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
@@ -536,12 +537,64 @@ static void __init arch_mem_init(char **cmdline_p)
 	}
 
 	bootmem_init();
+#ifdef CONFIG_KEXEC
+	if (crashk_res.start != crashk_res.end)
+		reserve_bootmem(crashk_res.start,
+				crashk_res.end - crashk_res.start + 1,
+				BOOTMEM_DEFAULT);
+#endif
 	device_tree_init();
 	sparse_init();
 	plat_swiotlb_setup();
 	paging_init();
 }
 
+#ifdef CONFIG_KEXEC
+static inline unsigned long long get_total_mem(void)
+{
+	unsigned long long total;
+
+	total = max_pfn - min_low_pfn;
+	return total << PAGE_SHIFT;
+}
+
+static void __init mips_parse_crashkernel(void)
+{
+	unsigned long long total_mem;
+	unsigned long long crash_size, crash_base;
+	int ret;
+
+	total_mem = get_total_mem();
+	ret = parse_crashkernel(boot_command_line, total_mem,
+				&crash_size, &crash_base);
+	if (ret != 0 || crash_size <= 0)
+		return;
+
+	crashk_res.start = crash_base;
+	crashk_res.end   = crash_base + crash_size - 1;
+}
+
+static void __init request_crashkernel(struct resource *res)
+{
+	int ret;
+
+	ret = request_resource(res, &crashk_res);
+	if (!ret)
+		pr_info("Reserving %ldMB of memory at %ldMB for crashkernel\n",
+			(unsigned long)((crashk_res.end -
+				crashk_res.start + 1) >> 20),
+			(unsigned long)(crashk_res.start  >> 20));
+}
+#else /* !defined(CONFIG_KEXEC)  */
+static void __init mips_parse_crashkernel(void)
+{
+}
+
+static void __init request_crashkernel(struct resource *res)
+{
+}
+#endif /* !defined(CONFIG_KEXEC)  */
+
 static void __init resource_init(void)
 {
 	int i;
@@ -557,6 +610,8 @@ static void __init resource_init(void)
 	/*
 	 * Request address space for all standard RAM.
 	 */
+	mips_parse_crashkernel();
+
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		struct resource *res;
 		unsigned long start, end;
@@ -593,6 +648,7 @@ static void __init resource_init(void)
 		 */
 		request_resource(res, &code_resource);
 		request_resource(res, &data_resource);
+		request_crashkernel(res);
 	}
 }
 

commit 0ec7ec75f674dbf48010081383263771f2611e72
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Nov 15 12:53:59 2012 +0100

    MIPS: Merge overlapping bootmem ranges
    
    Without this, we may end up with something like this in /proc/iomem:
    
    01100000-014fffff : System RAM
      01100000-013bf48f : Kernel code
      013bf490-0149e01f : Kernel data
    01500000-0c0fffff : System RAM
    
    but the two System RAM ranges should be one single range.  This particular
    case will result in kexec failure on Octeon systems if the kernel being
    loaded by kexec is bigger than the already running kernel.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index a53f8ec37aac..290dc6a1d7a3 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -79,7 +79,7 @@ static struct resource data_resource = { .name = "Kernel data", };
 void __init add_memory_region(phys_t start, phys_t size, long type)
 {
 	int x = boot_mem_map.nr_map;
-	struct boot_mem_map_entry *prev = boot_mem_map.map + x - 1;
+	int i;
 
 	/* Sanity check */
 	if (start + size < start) {
@@ -88,15 +88,29 @@ void __init add_memory_region(phys_t start, phys_t size, long type)
 	}
 
 	/*
-	 * Try to merge with previous entry if any.  This is far less than
-	 * perfect but is sufficient for most real world cases.
+	 * Try to merge with existing entry, if any.
 	 */
-	if (x && prev->addr + prev->size == start && prev->type == type) {
-		prev->size += size;
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		struct boot_mem_map_entry *entry = boot_mem_map.map + i;
+		unsigned long top;
+
+		if (entry->type != type)
+			continue;
+
+		if (start + size < entry->addr)
+			continue;			/* no overlap */
+
+		if (entry->addr + entry->size < start)
+			continue;			/* no overlap */
+
+		top = max(entry->addr + entry->size, start + size);
+		entry->addr = min(entry->addr, start);
+		entry->size = top - entry->addr;
+
 		return;
 	}
 
-	if (x == BOOT_MEM_MAP_MAX) {
+	if (boot_mem_map.nr_map == BOOT_MEM_MAP_MAX) {
 		pr_err("Ooops! Too many entries in the memory map!\n");
 		return;
 	}

commit 6650df3c380e0db558dbfec63ed860402c6afb2a
Author: David Daney <david.daney@cavium.com>
Date:   Tue May 15 00:04:50 2012 -0700

    MIPS: Move cache setup to setup_arch().
    
    commit 97ce2c88f9ad42e3c60a9beb9fca87abf3639faa (jump-label: initialize
    jump-label subsystem much earlier) breaks MIPS.  The jump_label_init()
    call was moved before trap_init() which is where we initialize
    flush_icache_range().
    
    In order to be good citizens, we move cache initialization earlier so
    that we don't jump through a null flush_icache_range function pointer
    when doing the jump label initialization.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/3822/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c504b212f8f3..a53f8ec37aac 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -605,6 +605,8 @@ void __init setup_arch(char **cmdline_p)
 
 	resource_init();
 	plat_smp_setup();
+
+	cpu_cache_init();
 }
 
 unsigned long kernelsp[NR_CPUS];

commit b81947c646bfefdf98e2fde5d7d39cbbda8525d4
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for MIPS
    
    Disintegrate asm/system.h for MIPS.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    cc: linux-mips@linux-mips.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 058e964e7303..c504b212f8f3 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -31,7 +31,6 @@
 #include <asm/sections.h>
 #include <asm/setup.h>
 #include <asm/smp-ops.h>
-#include <asm/system.h>
 #include <asm/prom.h>
 
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;

commit 4964e0664c80680fa6b28ef91381c076a5b25c2c
Merge: 0a80939b3e6a 7bf6612e8a9d
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jan 14 13:05:21 2012 -0800

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (119 commits)
      MIPS: Delete unused function add_temporary_entry.
      MIPS: Set default pci cache line size.
      MIPS: Flush huge TLB
      MIPS: Octeon: Remove SYS_SUPPORTS_HIGHMEM.
      MIPS: Octeon: Add support for OCTEON II PCIe
      MIPS: Octeon: Update PCI Latency timer and enable more error reporting.
      MIPS: Alchemy: Update cpu-feature-overrides
      MIPS: Alchemy: db1200: Improve PB1200 detection.
      MIPS: Alchemy: merge Au1000 and Au1300-style IRQ controller code.
      MIPS: Alchemy: chain IRQ controllers to MIPS IRQ controller
      MIPS: Alchemy: irq: register pm at irq init time
      MIPS: Alchemy: Touchscreen support on DB1100
      MIPS: Alchemy: Hook up IrDA on DB1000/DB1100
      net/irda: convert au1k_ir to platform driver.
      MIPS: Alchemy: remove unused board headers
      MTD: nand: make au1550nd.c a platform_driver
      MIPS: Netlogic: Mark Netlogic chips as SMT capable
      MIPS: Netlogic: Add support for XLP 3XX cores
      MIPS: Netlogic: Merge some of XLR/XLP wakup code
      MIPS: Netlogic: Add default XLP config.
      ...
    
    Fix up trivial conflicts in arch/mips/kernel/{perf_event_mipsxx.c,
    traps.c} and drivers/tty/serial/Makefile

commit 9d15ffc824a90842b16592f3a960836841bd6c58
Author: Tejun Heo <tj@kernel.org>
Date:   Thu Dec 8 10:22:09 2011 -0800

    mips: Use HAVE_MEMBLOCK_NODE_MAP
    
    mips used early_node_map[] just to prime free_area_init_nodes().  Now
    memblock can be used for the same purpose and early_node_map[] is
    scheduled to be dropped.  Use memblock instead.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 84af26ab2212..b1cb8f87d7b4 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -14,6 +14,7 @@
 #include <linux/ioport.h>
 #include <linux/export.h>
 #include <linux/screen_info.h>
+#include <linux/memblock.h>
 #include <linux/bootmem.h>
 #include <linux/initrd.h>
 #include <linux/root_dev.h>
@@ -352,7 +353,7 @@ static void __init bootmem_init(void)
 			continue;
 #endif
 
-		add_active_range(0, start, end);
+		memblock_add_node(PFN_PHYS(start), PFN_PHYS(end - start), 0);
 	}
 
 	/*

commit 43064c0c8ee2ada8edd421520c633584d648e100
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Tue Nov 22 14:38:03 2011 +0000

    MIPS: Handle initmem in systems with kernel not in add_memory_region() mem
    
    This patch addresses a couple of related problems:
    
    1) The kernel may reside in physical memory outside of the ranges set
       by plat_mem_setup().  If this is the case, init mem cannot be
       reused as it resides outside of the range of pages that the kernel
       memory allocators control.
    
    2) initrd images might be loaded in physical memory outside of the
       ranges set by plat_mem_setup().  The memory likewise cannot be
       reused.  The patch doesn't handle this specific case, but the
       infrastructure is useful for future patches that do.
    
    The crux of the problem is that there are memory regions that need be
    memory_present(), but that cannot be free_bootmem() at the time of
    arch_mem_init().  We create a new type of memory (BOOT_MEM_INIT_RAM)
    for use with add_memory_region().  Then arch_mem_init() adds the init
    mem with this type if the init mem is not already covered by existing
    ranges.
    
    When memory is being freed into the bootmem allocator, we skip the
    BOOT_MEM_INIT_RAM ranges so they are not clobbered, but we do signal
    them as memory_present().  This way when they are later freed, the
    necessary memory manager structures have initialized and the Sparse
    allocater is prevented from crashing.
    
    The Octeon specific code that handled this case is removed, because
    the new general purpose code handles the case.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    To: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/1988/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 84af26ab2212..e86c2cf554aa 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -121,6 +121,9 @@ static void __init print_memory_map(void)
 		case BOOT_MEM_RAM:
 			printk(KERN_CONT "(usable)\n");
 			break;
+		case BOOT_MEM_INIT_RAM:
+			printk(KERN_CONT "(usable after init)\n");
+			break;
 		case BOOT_MEM_ROM_DATA:
 			printk(KERN_CONT "(ROM data)\n");
 			break;
@@ -361,15 +364,24 @@ static void __init bootmem_init(void)
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long start, end, size;
 
+		start = PFN_UP(boot_mem_map.map[i].addr);
+		end   = PFN_DOWN(boot_mem_map.map[i].addr
+				    + boot_mem_map.map[i].size);
+
 		/*
 		 * Reserve usable memory.
 		 */
-		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
+		switch (boot_mem_map.map[i].type) {
+		case BOOT_MEM_RAM:
+			break;
+		case BOOT_MEM_INIT_RAM:
+			memory_present(0, start, end);
 			continue;
+		default:
+			/* Not usable memory */
+			continue;
+		}
 
-		start = PFN_UP(boot_mem_map.map[i].addr);
-		end   = PFN_DOWN(boot_mem_map.map[i].addr
-				    + boot_mem_map.map[i].size);
 		/*
 		 * We are rounding up the start address of usable memory
 		 * and at the end of the usable range downwards.
@@ -455,11 +467,33 @@ early_param("mem", early_parse_mem);
 
 static void __init arch_mem_init(char **cmdline_p)
 {
+	phys_t init_mem, init_end, init_size;
+
 	extern void plat_mem_setup(void);
 
 	/* call board setup routine */
 	plat_mem_setup();
 
+	init_mem = PFN_UP(__pa_symbol(&__init_begin)) << PAGE_SHIFT;
+	init_end = PFN_DOWN(__pa_symbol(&__init_end)) << PAGE_SHIFT;
+	init_size = init_end - init_mem;
+	if (init_size) {
+		/* Make sure it is in the boot_mem_map */
+		int i, found;
+		found = 0;
+		for (i = 0; i < boot_mem_map.nr_map; i++) {
+			if (init_mem >= boot_mem_map.map[i].addr &&
+			    init_mem < (boot_mem_map.map[i].addr +
+					boot_mem_map.map[i].size)) {
+				found = 1;
+				break;
+			}
+		}
+		if (!found)
+			add_memory_region(init_mem, init_size,
+					  BOOT_MEM_INIT_RAM);
+	}
+
 	pr_info("Determined physical RAM map:\n");
 	print_memory_map();
 
@@ -523,6 +557,7 @@ static void __init resource_init(void)
 		res = alloc_bootmem(sizeof(struct resource));
 		switch (boot_mem_map.map[i].type) {
 		case BOOT_MEM_RAM:
+		case BOOT_MEM_INIT_RAM:
 		case BOOT_MEM_ROM_DATA:
 			res->name = "System RAM";
 			break;

commit 73bc256d47a23272ce1dd50b4de64a0ff23d01f1
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Jul 23 16:30:40 2011 -0400

    mips: migrate core kernel file from module.h --> export.h
    
    These files are not modules, but were including module.h only for
    EXPORT_SYMBOL and/or THIS_MODULE.  Now that we have the lightweight
    export.h, use it in these kinds of cases.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 8ad1d5679f14..84af26ab2212 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -12,7 +12,7 @@
  */
 #include <linux/init.h>
 #include <linux/ioport.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <linux/screen_info.h>
 #include <linux/bootmem.h>
 #include <linux/initrd.h>

commit 1befdd5536e1500371f7f884d0f0ae528a519333
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Thu Oct 14 12:36:49 2010 -0700

    MIPS: Implement __read_mostly
    
    Just do what everyone else is doing by placing __read_mostly things in
    the .data.read_mostly section.
    
    mips_io_port_base can not be read-only (const) and writable
    (__read_mostly) at the same time.  One of them has to go, so I chose
    to eliminate the __read_mostly.  It will still get stuck in a portion
    of memory that is not adjacent to things that are written, and thus
    not be on a dirty cache line, for whatever that is worth.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    To: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/1702/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index acd3f2c49c06..8ad1d5679f14 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -70,7 +70,7 @@ static char __initdata builtin_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;
  * mips_io_port_base is the begin of the address space to which x86 style
  * I/O ports are mapped.
  */
-const unsigned long mips_io_port_base __read_mostly = -1;
+const unsigned long mips_io_port_base = -1;
 EXPORT_SYMBOL(mips_io_port_base);
 
 static struct resource code_resource = { .name = "Kernel code", };

commit ee71b7d2f834d5e4b3a43001b2fa88743ed71a2c
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Fri Oct 1 13:27:33 2010 -0700

    MIPS: Add a platform hook for swiotlb setup.
    
    This allows platforms that are using the swiotlb to initialize it.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Patchwork: http://patchwork.linux-mips.org/patch/1638/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index a6b900f2962b..acd3f2c49c06 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -490,6 +490,7 @@ static void __init arch_mem_init(char **cmdline_p)
 	bootmem_init();
 	device_tree_init();
 	sparse_init();
+	plat_swiotlb_setup();
 	paging_init();
 }
 

commit f2ffa5ab74f4dfd598860f96ca37a71c4d0a28a8
Author: Dezhong Diao <dediao@cisco.com>
Date:   Wed Oct 13 00:52:46 2010 -0600

    of/mips: Add device tree support to MIPS
    
    Add the ability to enable CONFIG_OF on the MIPS architecture.
    
    Signed-off-by: Dezhong Diao <dediao@cisco.com>
    [grant.likely@secretlab.ca: cleared out obsolete hooks,
            removed ARCH_HAS_DEVTREE_MEM,
            remove __init tags from header file,
            removed debugfs support hunk]
    [ddaney@linux-mips.org: backed out over aggressive trimming of hooks]
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Tested-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Grant Likely <grant.likely@secretlab.ca>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 85aef3fc6716..a6b900f2962b 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -31,6 +31,7 @@
 #include <asm/setup.h>
 #include <asm/smp-ops.h>
 #include <asm/system.h>
+#include <asm/prom.h>
 
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
@@ -487,6 +488,7 @@ static void __init arch_mem_init(char **cmdline_p)
 	}
 
 	bootmem_init();
+	device_tree_init();
 	sparse_init();
 	paging_init();
 }

commit 0103d23f44b1e9f8d2e89cc197e21192f6914f24
Author: Kevin Cernekee <cernekee@gmail.com>
Date:   Sun May 2 14:43:52 2010 -0700

    MIPS: nofpu and nodsp only affect CPU0
    
    The "nofpu" and "nodsp" kernel command line options currently do not
    affect CPUs that are brought online later in the boot process or
    hotplugged at runtime.  It is desirable to apply the nofpu/nodsp options
    to all CPUs in the system, so that surprising results are not seen when
    a process migrates from one CPU to another.
    
    [Ralf: Moved definitions of mips_fpu_disabled, fpu_disable,
    mips_dsp_disabled and dsp_disable from setup.c to cpu-probe.c to allow
    making mips_fpu_disabled and mips_dsp_disabled static.]
    
    Signed-off-by: Kevin Cernekee <cernekee@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: http://patchwork.linux-mips.org/patch/1169/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index f9513f9e61d3..85aef3fc6716 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -569,27 +569,6 @@ void __init setup_arch(char **cmdline_p)
 	plat_smp_setup();
 }
 
-static int __init fpu_disable(char *s)
-{
-	int i;
-
-	for (i = 0; i < NR_CPUS; i++)
-		cpu_data[i].options &= ~MIPS_CPU_FPU;
-
-	return 1;
-}
-
-__setup("nofpu", fpu_disable);
-
-static int __init dsp_disable(char *s)
-{
-	cpu_data[0].ases &= ~MIPS_ASE_DSP;
-
-	return 1;
-}
-
-__setup("nodsp", dsp_disable);
-
 unsigned long kernelsp[NR_CPUS];
 unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
 

commit 6acc7d485c24c00e111c61b2e6dff9180faebcae
Author: Dmitri Vorobiev <dmitri.vorobiev@movial.com>
Date:   Sat Nov 21 22:34:41 2009 +0200

    MIPS: Fix and enhance built-in kernel command line
    
    Currently, MIPS kernels silently overwrite kernel command-line parameters
    hardcoded in CONFIG_CMDLINE by the ones received from firmware.  Therefore,
    using firmware remains the only reliable method to transfer the
    command-line parameters, which is not always desirable or convenient, and
    the CONFIG_CMDLINE option is thereby effectively rendered useless.
    
    This patch fixes the problem described above and introduces a more flexible
    scheme of handling the kernel command line, in a manner identical to what is
    currently used for x86.  The default behavior, i.e. when CONFIG_CMDLINE_BOOL
    is not defined, retains the existing semantics, and firmware command-line
    arguments override the hardcoded ones.
    
    [Ralf: I fixed up all the defconfig files so the stay unaffected by this
    change.]
    
    Signed-off-by: Dmitri Vorobiev <dmitri.vorobiev@movial.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: http://patchwork.linux-mips.org/patch/689/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index bd55f71055ba..f9513f9e61d3 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -58,8 +58,12 @@ EXPORT_SYMBOL(mips_machtype);
 
 struct boot_mem_map boot_mem_map;
 
-static char command_line[COMMAND_LINE_SIZE];
-       char arcs_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;
+static char __initdata command_line[COMMAND_LINE_SIZE];
+char __initdata arcs_cmdline[COMMAND_LINE_SIZE];
+
+#ifdef CONFIG_CMDLINE_BOOL
+static char __initdata builtin_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;
+#endif
 
 /*
  * mips_io_port_base is the begin of the address space to which x86 style
@@ -458,8 +462,20 @@ static void __init arch_mem_init(char **cmdline_p)
 	pr_info("Determined physical RAM map:\n");
 	print_memory_map();
 
-	strlcpy(command_line, arcs_cmdline, sizeof(command_line));
-	strlcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);
+#ifdef CONFIG_CMDLINE_BOOL
+#ifdef CONFIG_CMDLINE_OVERRIDE
+	strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);
+#else
+	if (builtin_cmdline[0]) {
+		strlcat(arcs_cmdline, " ", COMMAND_LINE_SIZE);
+		strlcat(arcs_cmdline, builtin_cmdline, COMMAND_LINE_SIZE);
+	}
+	strlcpy(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
+#endif
+#else
+	strlcpy(boot_command_line, arcs_cmdline, COMMAND_LINE_SIZE);
+#endif
+	strlcpy(command_line, boot_command_line, COMMAND_LINE_SIZE);
 
 	*cmdline_p = command_line;
 

commit 32028f1f7bce32e72183129dc55fc23656e7081c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Dec 17 01:57:07 2009 +0000

    MIPS: Remove addinitrd and CONFIG_PROBE_INITRD_HEADER
    
    Addinitrd has been superseded by initramfs ages ago.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index fd138c9b33ef..bd55f71055ba 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -166,26 +166,8 @@ static unsigned long __init init_initrd(void)
 	 * already set up initrd_start and initrd_end. In these cases
 	 * perfom sanity checks and use them if all looks good.
 	 */
-	if (!initrd_start || initrd_end <= initrd_start) {
-#ifdef CONFIG_PROBE_INITRD_HEADER
-		u32 *initrd_header;
-
-		/*
-		 * See if initrd has been added to the kernel image by
-		 * arch/mips/boot/addinitrd.c. In that case a header is
-		 * prepended to initrd and is made up by 8 bytes. The first
-		 * word is a magic number and the second one is the size of
-		 * initrd.  Initrd start must be page aligned in any cases.
-		 */
-		initrd_header = __va(PAGE_ALIGN(__pa_symbol(&_end) + 8)) - 8;
-		if (initrd_header[0] != 0x494E5244)
-			goto disable;
-		initrd_start = (unsigned long)(initrd_header + 2);
-		initrd_end = initrd_start + initrd_header[1];
-#else
+	if (!initrd_start || initrd_end <= initrd_start)
 		goto disable;
-#endif
-	}
 
 	if (initrd_start & ~PAGE_MASK) {
 		pr_err("initrd start must be page aligned\n");

commit 7580c9c3938f45b0d889728d5533cb46b0322a85
Author: Dmitri Vorobiev <dmitri.vorobiev@movial.com>
Date:   Tue Oct 13 23:43:24 2009 +0300

    MIPS: Replace all usages of CL_SIZE by COMMAND_LINE_SIZE
    
    The MIPS-specific macro CL_SIZE is merely aliasing the macro
    COMMAND_LINE_SIZE. Other architectures use the latter; also,
    COMMAND_LINE_SIZE is documented in kernel-parameters.txt, so
    let's use it, and remove the alias.
    
    Signed-off-by: Dmitri Vorobiev <dmitri.vorobiev@movial.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 2b290d70083e..fd138c9b33ef 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -58,8 +58,8 @@ EXPORT_SYMBOL(mips_machtype);
 
 struct boot_mem_map boot_mem_map;
 
-static char command_line[CL_SIZE];
-       char arcs_cmdline[CL_SIZE]=CONFIG_CMDLINE;
+static char command_line[COMMAND_LINE_SIZE];
+       char arcs_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;
 
 /*
  * mips_io_port_base is the begin of the address space to which x86 style

commit 982f6ffeeed5ef6104cfd72e517ff9e7a9270fda
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Sep 17 02:25:07 2009 +0200

    MIPS: Remove useless zero initializations.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 2950b97253b7..2b290d70083e 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -441,7 +441,7 @@ static void __init bootmem_init(void)
  * initialization hook for anything else was introduced.
  */
 
-static int usermem __initdata = 0;
+static int usermem __initdata;
 
 static int __init early_parse_mem(char *p)
 {

commit 12e22e8e60add9e1ccd61509ab7fd6fc1c214c52
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Mar 30 14:49:41 2009 +0200

    MIPS: Stop using <asm-generic/int-l64.h>.
    
    This fixes a few warnings - and triggers a few new ones which the rest of
    this patch fixes.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 4430a1f8fdf1..2950b97253b7 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -277,7 +277,8 @@ static void __init bootmem_init(void)
 	 * not selected. Once that done we can determine the low bound
 	 * of usable memory.
 	 */
-	reserved_end = max(init_initrd(), PFN_UP(__pa_symbol(&_end)));
+	reserved_end = max(init_initrd(),
+			   (unsigned long) PFN_UP(__pa_symbol(&_end)));
 
 	/*
 	 * max_low_pfn is not a number of pages. The number of pages

commit b517531ce53794f2a2eae1fff1d1216b9db4da9f
Author: Zhaolei <zhaolei@cn.fujitsu.com>
Date:   Fri Oct 17 19:12:35 2008 +0800

    MIPS: Fix debugfs_create_*'s error checking method for mips/kernel/
    
    debugfs_create_*() returns NULL on error.  Make its callers return -ENODEV
    on error.
    
    Signed-off-by: Zhao Lei <zhaolei@cn.fujitsu.com>
    Acked-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 16f8edfe5cdc..4430a1f8fdf1 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -601,8 +601,8 @@ static int __init debugfs_mips(void)
 	struct dentry *d;
 
 	d = debugfs_create_dir("mips", NULL);
-	if (IS_ERR(d))
-		return PTR_ERR(d);
+	if (!d)
+		return -ENOMEM;
 	mips_debugfs_dir = d;
 	return 0;
 }

commit 0011036beeffeada15acd1936d67988de21ca65e
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Aug 26 22:34:57 2008 +0900

    [MIPS] Probe initrd header only if explicitly specified
    
    Currently init_initrd() probes initrd header at the last page of kernel
    image, but it is valid only if addinitrd was used.  If addinitrd was not
    used, the area contains garbage so probing there might misdetect initrd
    header (magic number is not strictly robust).
    
    This patch introduces CONFIG_PROBE_INITRD_HEADER to explicitly enable this
    probing.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 2aae76bce293..16f8edfe5cdc 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -160,30 +160,33 @@ early_param("rd_size", rd_size_early);
 static unsigned long __init init_initrd(void)
 {
 	unsigned long end;
-	u32 *initrd_header;
 
 	/*
 	 * Board specific code or command line parser should have
 	 * already set up initrd_start and initrd_end. In these cases
 	 * perfom sanity checks and use them if all looks good.
 	 */
-	if (initrd_start && initrd_end > initrd_start)
-		goto sanitize;
+	if (!initrd_start || initrd_end <= initrd_start) {
+#ifdef CONFIG_PROBE_INITRD_HEADER
+		u32 *initrd_header;
 
-	/*
-	 * See if initrd has been added to the kernel image by
-	 * arch/mips/boot/addinitrd.c. In that case a header is
-	 * prepended to initrd and is made up by 8 bytes. The fisrt
-	 * word is a magic number and the second one is the size of
-	 * initrd.  Initrd start must be page aligned in any cases.
-	 */
-	initrd_header = __va(PAGE_ALIGN(__pa_symbol(&_end) + 8)) - 8;
-	if (initrd_header[0] != 0x494E5244)
+		/*
+		 * See if initrd has been added to the kernel image by
+		 * arch/mips/boot/addinitrd.c. In that case a header is
+		 * prepended to initrd and is made up by 8 bytes. The first
+		 * word is a magic number and the second one is the size of
+		 * initrd.  Initrd start must be page aligned in any cases.
+		 */
+		initrd_header = __va(PAGE_ALIGN(__pa_symbol(&_end) + 8)) - 8;
+		if (initrd_header[0] != 0x494E5244)
+			goto disable;
+		initrd_start = (unsigned long)(initrd_header + 2);
+		initrd_end = initrd_start + initrd_header[1];
+#else
 		goto disable;
-	initrd_start = (unsigned long)(initrd_header + 2);
-	initrd_end = initrd_start + initrd_header[1];
+#endif
+	}
 
-sanitize:
 	if (initrd_start & ~PAGE_MASK) {
 		pr_err("initrd start must be page aligned\n");
 		goto disable;

commit a64ae7a2256b56bbd2830749c580fa533b69758c
Author: Mike Crowe <mac@mcrowe.com>
Date:   Mon Jul 28 13:12:52 2008 +0100

    [MIPS] Convert printk statements during kernel setup to use severity levels
    
    Signed-off-by: Mike Crowe <mac@mcrowe.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 8af84867e74d..2aae76bce293 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -78,7 +78,7 @@ void __init add_memory_region(phys_t start, phys_t size, long type)
 
 	/* Sanity check */
 	if (start + size < start) {
-		printk("Trying to add an invalid memory region, skipped\n");
+		pr_warning("Trying to add an invalid memory region, skipped\n");
 		return;
 	}
 
@@ -92,7 +92,7 @@ void __init add_memory_region(phys_t start, phys_t size, long type)
 	}
 
 	if (x == BOOT_MEM_MAP_MAX) {
-		printk("Ooops! Too many entries in the memory map!\n");
+		pr_err("Ooops! Too many entries in the memory map!\n");
 		return;
 	}
 
@@ -108,22 +108,22 @@ static void __init print_memory_map(void)
 	const int field = 2 * sizeof(unsigned long);
 
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
-		printk(" memory: %0*Lx @ %0*Lx ",
+		printk(KERN_INFO " memory: %0*Lx @ %0*Lx ",
 		       field, (unsigned long long) boot_mem_map.map[i].size,
 		       field, (unsigned long long) boot_mem_map.map[i].addr);
 
 		switch (boot_mem_map.map[i].type) {
 		case BOOT_MEM_RAM:
-			printk("(usable)\n");
+			printk(KERN_CONT "(usable)\n");
 			break;
 		case BOOT_MEM_ROM_DATA:
-			printk("(ROM data)\n");
+			printk(KERN_CONT "(ROM data)\n");
 			break;
 		case BOOT_MEM_RESERVED:
-			printk("(reserved)\n");
+			printk(KERN_CONT "(reserved)\n");
 			break;
 		default:
-			printk("type %lu\n", boot_mem_map.map[i].type);
+			printk(KERN_CONT "type %lu\n", boot_mem_map.map[i].type);
 			break;
 		}
 	}
@@ -185,11 +185,11 @@ static unsigned long __init init_initrd(void)
 
 sanitize:
 	if (initrd_start & ~PAGE_MASK) {
-		printk(KERN_ERR "initrd start must be page aligned\n");
+		pr_err("initrd start must be page aligned\n");
 		goto disable;
 	}
 	if (initrd_start < PAGE_OFFSET) {
-		printk(KERN_ERR "initrd start < PAGE_OFFSET\n");
+		pr_err("initrd start < PAGE_OFFSET\n");
 		goto disable;
 	}
 
@@ -221,18 +221,18 @@ static void __init finalize_initrd(void)
 		goto disable;
 	}
 	if (__pa(initrd_end) > PFN_PHYS(max_low_pfn)) {
-		printk("Initrd extends beyond end of memory");
+		printk(KERN_ERR "Initrd extends beyond end of memory");
 		goto disable;
 	}
 
 	reserve_bootmem(__pa(initrd_start), size, BOOTMEM_DEFAULT);
 	initrd_below_start_ok = 1;
 
-	printk(KERN_INFO "Initial ramdisk at: 0x%lx (%lu bytes)\n",
-	       initrd_start, size);
+	pr_info("Initial ramdisk at: 0x%lx (%lu bytes)\n",
+		initrd_start, size);
 	return;
 disable:
-	printk(" - disabling initrd\n");
+	printk(KERN_CONT " - disabling initrd\n");
 	initrd_start = 0;
 	initrd_end = 0;
 }
@@ -310,14 +310,12 @@ static void __init bootmem_init(void)
 	if (min_low_pfn >= max_low_pfn)
 		panic("Incorrect memory mapping !!!");
 	if (min_low_pfn > ARCH_PFN_OFFSET) {
-		printk(KERN_INFO
-		       "Wasting %lu bytes for tracking %lu unused pages\n",
-		       (min_low_pfn - ARCH_PFN_OFFSET) * sizeof(struct page),
-		       min_low_pfn - ARCH_PFN_OFFSET);
+		pr_info("Wasting %lu bytes for tracking %lu unused pages\n",
+			(min_low_pfn - ARCH_PFN_OFFSET) * sizeof(struct page),
+			min_low_pfn - ARCH_PFN_OFFSET);
 	} else if (min_low_pfn < ARCH_PFN_OFFSET) {
-		printk(KERN_INFO
-		       "%lu free pages won't be used\n",
-		       ARCH_PFN_OFFSET - min_low_pfn);
+		pr_info("%lu free pages won't be used\n",
+			ARCH_PFN_OFFSET - min_low_pfn);
 	}
 	min_low_pfn = ARCH_PFN_OFFSET;
 
@@ -471,7 +469,7 @@ static void __init arch_mem_init(char **cmdline_p)
 	/* call board setup routine */
 	plat_mem_setup();
 
-	printk("Determined physical RAM map:\n");
+	pr_info("Determined physical RAM map:\n");
 	print_memory_map();
 
 	strlcpy(command_line, arcs_cmdline, sizeof(command_line));
@@ -482,7 +480,7 @@ static void __init arch_mem_init(char **cmdline_p)
 	parse_early_param();
 
 	if (usermem) {
-		printk("User-defined physical RAM map:\n");
+		pr_info("User-defined physical RAM map:\n");
 		print_memory_map();
 	}
 

commit 07cdb78436d52416a582e645b9afb6e26f986bc9
Author: Dmitri Vorobiev <dmitri.vorobiev@movial.fi>
Date:   Thu May 29 17:57:08 2008 +0300

    [MIPS] fix sparse warning about setup_early_printk()
    
    This patch fixes the following sparse warning:
    
    <<<<<<<<
    
    arch/mips/kernel/early_printk.c:35:13: warning: symbol 'setup_early_printk'
    was not declared. Should it be static?
    
    <<<<<<<<
    
    The fix is to define a prototype of the setup_early_printk() function and
    to include the appropriate header into arch/mips/kernel/early_printk.c.
    
    [Ralf: Sorted includes again]
    
    Signed-off-by: Dmitri Vorobiev <dmitri.vorobiev@movial.fi>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c04e4e3afede..8af84867e74d 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -550,11 +550,7 @@ void __init setup_arch(char **cmdline_p)
 	prom_init();
 
 #ifdef CONFIG_EARLY_PRINTK
-	{
-		extern void setup_early_printk(void);
-
-		setup_early_printk();
-	}
+	setup_early_printk();
 #endif
 	cpu_report();
 	check_bugs_early();

commit c88a8b4ab0e1a1f06938939d9ba42e9da6144ccb
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Mon Jun 9 17:19:53 2008 +0100

    [MIPS] Remove obsolete isa_slot_offset
    
     The isa_slot_offset variable and its __ISA_IO_base macro is not used
    anywhere anymore.  It does not look like a decent interface per today's
    standards either.  Remove both including all places of initialization.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c6a063b2a0d9..c04e4e3afede 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -68,13 +68,6 @@ static char command_line[CL_SIZE];
 const unsigned long mips_io_port_base __read_mostly = -1;
 EXPORT_SYMBOL(mips_io_port_base);
 
-/*
- * isa_slot_offset is the address where E(ISA) busaddress 0 is mapped
- * for the processor.
- */
-unsigned long isa_slot_offset;
-EXPORT_SYMBOL(isa_slot_offset);
-
 static struct resource code_resource = { .name = "Kernel code", };
 static struct resource data_resource = { .name = "Kernel data", };
 

commit dc3bf3532bf7240cf117b8ecf3d16526810eba6a
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Apr 18 10:56:07 2008 +0100

    [MIPS] Initialize max_pfn again.
    
    This was dropped by
    
    commit a0d9e2d891e4cf54676c430da63bd4a17d1cdb80 (lmo)
    commit b6f1f0dea1469e0c956eb89399916d60dd2a3808 (ko)
    Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Date:   Fri Aug 11 17:51:48 2006 +0200
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 39f3dfe134fb..c6a063b2a0d9 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -331,6 +331,7 @@ static void __init bootmem_init(void)
 	/*
 	 * Determine low and high memory ranges
 	 */
+	max_pfn = max_low_pfn;
 	if (max_low_pfn > PFN_DOWN(HIGHMEM_START)) {
 #ifdef CONFIG_HIGHMEM
 		highstart_pfn = PFN_DOWN(HIGHMEM_START);

commit 72a7fe3967dbf86cb34e24fbf1d957fe24d2f246
Author: Bernhard Walle <bwalle@suse.de>
Date:   Thu Feb 7 00:15:17 2008 -0800

    Introduce flags for reserve_bootmem()
    
    This patchset adds a flags variable to reserve_bootmem() and uses the
    BOOTMEM_EXCLUSIVE flag in crashkernel reservation code to detect collisions
    between crashkernel area and already used memory.
    
    This patch:
    
    Change the reserve_bootmem() function to accept a new flag BOOTMEM_EXCLUSIVE.
    If that flag is set, the function returns with -EBUSY if the memory already
    has been reserved in the past.  This is to avoid conflicts.
    
    Because that code runs before SMP initialisation, there's no race condition
    inside reserve_bootmem_core().
    
    [akpm@linux-foundation.org: coding-style fixes]
    [akpm@linux-foundation.org: fix powerpc build]
    Signed-off-by: Bernhard Walle <bwalle@suse.de>
    Cc: <linux-arch@vger.kernel.org>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Vivek Goyal <vgoyal@in.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c032409cba9b..39f3dfe134fb 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -232,7 +232,7 @@ static void __init finalize_initrd(void)
 		goto disable;
 	}
 
-	reserve_bootmem(__pa(initrd_start), size);
+	reserve_bootmem(__pa(initrd_start), size, BOOTMEM_DEFAULT);
 	initrd_below_start_ok = 1;
 
 	printk(KERN_INFO "Initial ramdisk at: 0x%lx (%lu bytes)\n",
@@ -413,7 +413,7 @@ static void __init bootmem_init(void)
 	/*
 	 * Reserve the bootmap memory.
 	 */
-	reserve_bootmem(PFN_PHYS(mapstart), bootmap_size);
+	reserve_bootmem(PFN_PHYS(mapstart), bootmap_size, BOOTMEM_DEFAULT);
 
 	/*
 	 * Reserve initrd memory if needed.

commit 603e82edf78ad6c0f836023f8db585620211947b
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 3 16:54:53 2008 +0200

    arch/mips/: Spelling fixes
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 269c252d956f..c032409cba9b 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -424,13 +424,13 @@ static void __init bootmem_init(void)
 #endif	/* CONFIG_SGI_IP27 */
 
 /*
- * arch_mem_init - initialize memory managment subsystem
+ * arch_mem_init - initialize memory management subsystem
  *
  *  o plat_mem_setup() detects the memory configuration and will record detected
  *    memory areas using add_memory_region.
  *
  * At this stage the memory configuration of the system is known to the
- * kernel but generic memory managment system is still entirely uninitialized.
+ * kernel but generic memory management system is still entirely uninitialized.
  *
  *  o bootmem_init()
  *  o sparse_init()

commit 87353d8ac39c52784da605ecbe965ecdfad609ad
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Nov 19 12:23:51 2007 +0000

    [MIPS] SMP: Call platform methods via ops structure.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 7b4418dd5857..269c252d956f 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -29,6 +29,7 @@
 #include <asm/cpu.h>
 #include <asm/sections.h>
 #include <asm/setup.h>
+#include <asm/smp-ops.h>
 #include <asm/system.h>
 
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
@@ -575,9 +576,7 @@ void __init setup_arch(char **cmdline_p)
 	arch_mem_init(cmdline_p);
 
 	resource_init();
-#ifdef CONFIG_SMP
 	plat_smp_setup();
-#endif
 }
 
 static int __init fpu_disable(char *s)

commit 20d60d9973c3b441902b0a3f4f6f7e7ade08f77d
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Tue Oct 23 12:43:11 2007 +0100

    [MIPS] R4000/R4400 errata workarounds
    
     This is the gereric part of R4000/R4400 errata workarounds.  They include
    compiler and assembler support as well as some source code modifications
    to address the problems with some combinations of multiply/divide+shift
    instructions as well as the daddi and daddiu instructions.
    
     Changes included are as follows:
    
    1. New Kconfig options to select workarounds by platforms as necessary.
    
    2. Arch top-level Makefile to pass necessary options to the compiler; also
       incompatible configurations are detected (-mno-sym32 unsupported as
       horribly intrusive for little gain).
    
    3. Bug detection updated and shuffled -- the multiply/divide+shift problem
       is lethal enough that if not worked around it makes the kernel crash in
       time_init() because of a division by zero; the daddiu erratum might
       also trigger early potentially, though I have not observed it.  On the
       other hand the daddi detection code requires the exception subsystem to
       have been initialised (and is there mainly for information).
    
    4. r4k_daddiu_bug() added so that the existence of the erratum can be
       queried by code at the run time as necessary; useful for generated code
       like TLB fault and copy/clear page handlers.
    
    5. __udelay() updated as it uses multiplication in inline assembly.
    
     Note that -mdaddi requires modified toolchain (which has been maintained
    by myself and available from my site for ~4years now -- versions covered
    are GCC 2.95.4 - 4.1.2 and binutils from 2.13 onwards).  The -mfix-r4000
    and -mfix-r4400 have been standard for a while though.
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index f8a535afce39..7b4418dd5857 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -8,7 +8,7 @@
  * Copyright (C) 1994, 95, 96, 97, 98, 99, 2000, 01, 02, 03  Ralf Baechle
  * Copyright (C) 1996 Stoned Elipot
  * Copyright (C) 1999 Silicon Graphics, Inc.
- * Copyright (C) 2000 2001, 2002  Maciej W. Rozycki
+ * Copyright (C) 2000, 2001, 2002, 2007  Maciej W. Rozycki
  */
 #include <linux/init.h>
 #include <linux/ioport.h>
@@ -24,6 +24,7 @@
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
+#include <asm/bugs.h>
 #include <asm/cache.h>
 #include <asm/cpu.h>
 #include <asm/sections.h>
@@ -561,6 +562,7 @@ void __init setup_arch(char **cmdline_p)
 	}
 #endif
 	cpu_report();
+	check_bugs_early();
 
 #if defined(CONFIG_VT)
 #if defined(CONFIG_VGA_CONSOLE)

commit e452e94e21e8f4a3c2ff045b301ca21c1f6d03bf
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Jan 8 00:41:13 2008 +0900

    [MIPS] Replace 40c7869b693b18412491fdcff64682215b739f9e kludge
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 7f6ddcb5d485..f8a535afce39 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -269,7 +269,7 @@ static void __init bootmem_init(void)
 
 static void __init bootmem_init(void)
 {
-	unsigned long init_begin, reserved_end;
+	unsigned long reserved_end;
 	unsigned long mapstart = ~0UL;
 	unsigned long bootmap_size;
 	int i;
@@ -344,7 +344,6 @@ static void __init bootmem_init(void)
 					 min_low_pfn, max_low_pfn);
 
 
-	init_begin = PFN_UP(__pa_symbol(&__init_begin));
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long start, end;
 
@@ -352,8 +351,8 @@ static void __init bootmem_init(void)
 		end = PFN_DOWN(boot_mem_map.map[i].addr
 				+ boot_mem_map.map[i].size);
 
-		if (start <= init_begin)
-			start = init_begin;
+		if (start <= min_low_pfn)
+			start = min_low_pfn;
 		if (start >= end)
 			continue;
 

commit cce335ae47e231398269fb05fa48e0e9cbf289e0
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Nov 3 02:05:43 2007 +0000

    [MIPS] 64-bit Sibyte kernels need DMA32.
    
    Sibyte SOCs only have 32-bit PCI.  Due to the sparse use of the address
    space only the first 1GB of memory is mapped at physical addresses
    below 1GB.  If a system has more than 1GB of memory 32-bit DMA will
    not be able to reach all of it.
    
    For now this patch is good enough to keep Sibyte users happy but it seems
    eventually something like swiotlb will be needed for Sibyte.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index a06a27d6cfcd..7f6ddcb5d485 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -269,7 +269,7 @@ static void __init bootmem_init(void)
 
 static void __init bootmem_init(void)
 {
-	unsigned long reserved_end;
+	unsigned long init_begin, reserved_end;
 	unsigned long mapstart = ~0UL;
 	unsigned long bootmap_size;
 	int i;
@@ -342,6 +342,35 @@ static void __init bootmem_init(void)
 	 */
 	bootmap_size = init_bootmem_node(NODE_DATA(0), mapstart,
 					 min_low_pfn, max_low_pfn);
+
+
+	init_begin = PFN_UP(__pa_symbol(&__init_begin));
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		unsigned long start, end;
+
+		start = PFN_UP(boot_mem_map.map[i].addr);
+		end = PFN_DOWN(boot_mem_map.map[i].addr
+				+ boot_mem_map.map[i].size);
+
+		if (start <= init_begin)
+			start = init_begin;
+		if (start >= end)
+			continue;
+
+#ifndef CONFIG_HIGHMEM
+		if (end > max_low_pfn)
+			end = max_low_pfn;
+
+		/*
+		 * ... finally, is the area going away?
+		 */
+		if (end <= start)
+			continue;
+#endif
+
+		add_active_range(0, start, end);
+	}
+
 	/*
 	 * Register fully available low RAM pages with the bootmem allocator.
 	 */

commit 05dc8c02bf40090e9ed23932b1980ead48eb8870
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:08 2007 +0100

    [MIPS] ARC: Get rid of mips_machgroup
    
    This has not been any serious user of this ill conceived thing since the
    original invention in like '95.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 316685fca059..a06a27d6cfcd 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -51,10 +51,8 @@ EXPORT_SYMBOL(PCI_DMA_BUS_IS_PHYS);
  * These are initialized so they are in the .data section
  */
 unsigned long mips_machtype __read_mostly = MACH_UNKNOWN;
-unsigned long mips_machgroup __read_mostly = MACH_GROUP_UNKNOWN;
 
 EXPORT_SYMBOL(mips_machtype);
-EXPORT_SYMBOL(mips_machgroup);
 
 struct boot_mem_map boot_mem_map;
 

commit 6312e0ee45236b6882cd26b2ccc167b1b91646fc
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat Jun 30 00:55:48 2007 +0900

    [MIPS] Add some debugfs files to debug unaligned accesses
    
    Currently a number of unaligned instructions is counted but not used.
    Add /debug/mips/unaligned_instructions file to show the value.
    
    And add /debug/mips/unaligned_action to control behavior upon an
    unaligned access.  Possible actions are:
    
    0: silently fixup the unaligned access.
    1: send SIGBUS.
    2: dump registers, process name, etc. and fixup.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 4975da0bfb63..316685fca059 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -20,6 +20,7 @@
 #include <linux/highmem.h>
 #include <linux/console.h>
 #include <linux/pfn.h>
+#include <linux/debugfs.h>
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
@@ -574,3 +575,18 @@ __setup("nodsp", dsp_disable);
 
 unsigned long kernelsp[NR_CPUS];
 unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;
+
+#ifdef CONFIG_DEBUG_FS
+struct dentry *mips_debugfs_dir;
+static int __init debugfs_mips(void)
+{
+	struct dentry *d;
+
+	d = debugfs_create_dir("mips", NULL);
+	if (IS_ERR(d))
+		return PTR_ERR(d);
+	mips_debugfs_dir = d;
+	return 0;
+}
+arch_initcall(debugfs_mips);
+#endif

commit 36a885306fdf7bb557c773309c993bfb2d0d693c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Mar 1 11:56:43 2007 +0000

    [MIPS] Fix and cleanup the mess that a dozen prom_printf variants are.
    
    early_printk is a so much saner thing.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 11ab222a2e97..4975da0bfb63 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -525,6 +525,14 @@ void __init setup_arch(char **cmdline_p)
 {
 	cpu_probe();
 	prom_init();
+
+#ifdef CONFIG_EARLY_PRINTK
+	{
+		extern void setup_early_printk(void);
+
+		setup_early_printk();
+	}
+#endif
 	cpu_report();
 
 #if defined(CONFIG_VT)

commit f49a747c4adadd96addf4dbf4a44f439513fb29b
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sun Feb 18 01:02:14 2007 +0900

    [MIPS] Make some __setup functions static
    
    This fixes some sparse warnings. ("warning: symbol 'foo' was not
    declared. Should it be static?")
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 394540fad769..11ab222a2e97 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -543,7 +543,7 @@ void __init setup_arch(char **cmdline_p)
 #endif
 }
 
-int __init fpu_disable(char *s)
+static int __init fpu_disable(char *s)
 {
 	int i;
 
@@ -555,7 +555,7 @@ int __init fpu_disable(char *s)
 
 __setup("nofpu", fpu_disable);
 
-int __init dsp_disable(char *s)
+static int __init dsp_disable(char *s)
 {
 	cpu_data[0].ases &= ~MIPS_ASE_DSP;
 

commit 43cd34645d3bf35cbaa68f28b85d12d0b9e08ab9
Author: Alon Bar-Lev <alon.barlev@gmail.com>
Date:   Mon Feb 12 00:54:15 2007 -0800

    [PATCH] Dynamic kernel command-line: mips
    
    Rename saved_command_line into boot_command_line.
    
    Signed-off-by: Alon Bar-Lev <alon.barlev@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index d2e01e7167b8..394540fad769 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -452,7 +452,7 @@ static void __init arch_mem_init(char **cmdline_p)
 	print_memory_map();
 
 	strlcpy(command_line, arcs_cmdline, sizeof(command_line));
-	strlcpy(saved_command_line, command_line, COMMAND_LINE_SIZE);
+	strlcpy(boot_command_line, command_line, COMMAND_LINE_SIZE);
 
 	*cmdline_p = command_line;
 

commit e0daad449c5195fa4552c60392eeee4e5c58d31c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Feb 5 00:10:11 2007 +0000

    [MIPS] Whitespace cleanups.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index c4359791bd5c..d2e01e7167b8 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -529,9 +529,9 @@ void __init setup_arch(char **cmdline_p)
 
 #if defined(CONFIG_VT)
 #if defined(CONFIG_VGA_CONSOLE)
-        conswitchp = &vga_con;
+	conswitchp = &vga_con;
 #elif defined(CONFIG_DUMMY_CONSOLE)
-        conswitchp = &dummy_con;
+	conswitchp = &dummy_con;
 #endif
 #endif
 

commit 69a6c312e5ebb2e929ceb67e6246e2d9314f1d29
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Wed Jan 24 01:21:05 2007 +0900

    [MIPS] Move some kernel globals from asm file to C file.
    
    This get rid of some undesirable hole in BSS section due to random
    order of placement.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index e1d76b87601c..c4359791bd5c 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -563,3 +563,6 @@ int __init dsp_disable(char *s)
 }
 
 __setup("nodsp", dsp_disable);
+
+unsigned long kernelsp[NR_CPUS];
+unsigned long fw_arg0, fw_arg1, fw_arg2, fw_arg3;

commit 6f284a2ce7b8bc49cb8455b1763357897a899abb
Author: Franck Bui-Huu <fbuihuu@gmail.com>
Date:   Wed Jan 10 09:44:05 2007 +0100

    [MIPS] FLATMEM: introduce PHYS_OFFSET.
    
    The old code was assuming that min_low_pfn was always 0. This
    means that platforms having a big hole at their memory start
    paid the price of wasting some memory for the allocation of
    unused entries in mem_map[].
    
    This patch prevents this waste.
    
    It introduces PHYS_OFFSET define which is the start of the
    physical memory and uses it wherever needed. Specially when
    converting physical/virtual addresses into virtual/physical
    ones.
    
    Currently all platforms defines PHYS_OFFSET to 0.
    
    Signed-off-by: Franck Bui-Huu <fbuihuu@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index f352cd9c834b..e1d76b87601c 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -315,13 +315,17 @@ static void __init bootmem_init(void)
 
 	if (min_low_pfn >= max_low_pfn)
 		panic("Incorrect memory mapping !!!");
-	if (min_low_pfn > 0) {
+	if (min_low_pfn > ARCH_PFN_OFFSET) {
 		printk(KERN_INFO
 		       "Wasting %lu bytes for tracking %lu unused pages\n",
-		       min_low_pfn * sizeof(struct page),
-		       min_low_pfn);
-		min_low_pfn = 0;
+		       (min_low_pfn - ARCH_PFN_OFFSET) * sizeof(struct page),
+		       min_low_pfn - ARCH_PFN_OFFSET);
+	} else if (min_low_pfn < ARCH_PFN_OFFSET) {
+		printk(KERN_INFO
+		       "%lu free pages won't be used\n",
+		       ARCH_PFN_OFFSET - min_low_pfn);
 	}
+	min_low_pfn = ARCH_PFN_OFFSET;
 
 	/*
 	 * Determine low and high memory ranges

commit db84dc61552ae0d198a8133d28b80c3838930ba8
Author: Franck Bui-Huu <fbuihuu@gmail.com>
Date:   Wed Jan 10 09:44:04 2007 +0100

    [MIPS] Setup min_low_pfn/max_low_pfn correctly
    
    This patch makes a better usage of these two globals.
    'min_low_pfn' is now correctly setup for all configs, which
    allow us to rely on it in boot memory code init.
    
    Signed-off-by: Franck Bui-Huu <fbuihuu@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 89440a0d8528..f352cd9c834b 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -271,8 +271,7 @@ static void __init bootmem_init(void)
 static void __init bootmem_init(void)
 {
 	unsigned long reserved_end;
-	unsigned long highest = 0;
-	unsigned long mapstart = -1UL;
+	unsigned long mapstart = ~0UL;
 	unsigned long bootmap_size;
 	int i;
 
@@ -283,6 +282,13 @@ static void __init bootmem_init(void)
 	 */
 	reserved_end = max(init_initrd(), PFN_UP(__pa_symbol(&_end)));
 
+	/*
+	 * max_low_pfn is not a number of pages. The number of pages
+	 * of the system is given by 'max_low_pfn - min_low_pfn'.
+	 */
+	min_low_pfn = ~0UL;
+	max_low_pfn = 0;
+
 	/*
 	 * Find the highest page frame number we have available.
 	 */
@@ -296,8 +302,10 @@ static void __init bootmem_init(void)
 		end = PFN_DOWN(boot_mem_map.map[i].addr
 				+ boot_mem_map.map[i].size);
 
-		if (end > highest)
-			highest = end;
+		if (end > max_low_pfn)
+			max_low_pfn = end;
+		if (start < min_low_pfn)
+			min_low_pfn = start;
 		if (end <= reserved_end)
 			continue;
 		if (start >= mapstart)
@@ -305,22 +313,32 @@ static void __init bootmem_init(void)
 		mapstart = max(reserved_end, start);
 	}
 
+	if (min_low_pfn >= max_low_pfn)
+		panic("Incorrect memory mapping !!!");
+	if (min_low_pfn > 0) {
+		printk(KERN_INFO
+		       "Wasting %lu bytes for tracking %lu unused pages\n",
+		       min_low_pfn * sizeof(struct page),
+		       min_low_pfn);
+		min_low_pfn = 0;
+	}
+
 	/*
 	 * Determine low and high memory ranges
 	 */
-	if (highest > PFN_DOWN(HIGHMEM_START)) {
+	if (max_low_pfn > PFN_DOWN(HIGHMEM_START)) {
 #ifdef CONFIG_HIGHMEM
 		highstart_pfn = PFN_DOWN(HIGHMEM_START);
-		highend_pfn = highest;
+		highend_pfn = max_low_pfn;
 #endif
-		highest = PFN_DOWN(HIGHMEM_START);
+		max_low_pfn = PFN_DOWN(HIGHMEM_START);
 	}
 
 	/*
 	 * Initialize the boot-time allocator with low memory only.
 	 */
-	bootmap_size = init_bootmem(mapstart, highest);
-
+	bootmap_size = init_bootmem_node(NODE_DATA(0), mapstart,
+					 min_low_pfn, max_low_pfn);
 	/*
 	 * Register fully available low RAM pages with the bootmem allocator.
 	 */

commit a7837b76b6de932c31d0b7c71176ca8d1213a3ce
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Thu Oct 19 13:20:04 2006 +0200

    [MIPS] setup.c: clean up initrd related code
    
    Signed-off-by: Franck Bui-Huu <fbuihuu@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index b52cc9763763..89440a0d8528 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -145,13 +145,12 @@ static int __init rd_start_early(char *p)
 	unsigned long start = memparse(p, &p);
 
 #ifdef CONFIG_64BIT
-	/* HACK: Guess if the sign extension was forgotten */
-	if (start > 0x0000000080000000 && start < 0x00000000ffffffff)
-		start |= 0xffffffff00000000UL;
+	/* Guess if the sign extension was forgotten by bootloader */
+	if (start < XKPHYS)
+		start = (int)start;
 #endif
 	initrd_start = start;
 	initrd_end += start;
-
 	return 0;
 }
 early_param("rd_start", rd_start_early);
@@ -159,41 +158,64 @@ early_param("rd_start", rd_start_early);
 static int __init rd_size_early(char *p)
 {
 	initrd_end += memparse(p, &p);
-
 	return 0;
 }
 early_param("rd_size", rd_size_early);
 
+/* it returns the next free pfn after initrd */
 static unsigned long __init init_initrd(void)
 {
-	unsigned long tmp, end, size;
+	unsigned long end;
 	u32 *initrd_header;
 
-	ROOT_DEV = Root_RAM0;
-
 	/*
 	 * Board specific code or command line parser should have
 	 * already set up initrd_start and initrd_end. In these cases
 	 * perfom sanity checks and use them if all looks good.
 	 */
-	size = initrd_end - initrd_start;
-	if (initrd_end == 0 || size == 0) {
-		initrd_start = 0;
-		initrd_end = 0;
-	} else
-		return initrd_end;
-
-	end = (unsigned long)&_end;
-	tmp = PAGE_ALIGN(end) - sizeof(u32) * 2;
-	if (tmp < end)
-		tmp += PAGE_SIZE;
-
-	initrd_header = (u32 *)tmp;
-	if (initrd_header[0] == 0x494E5244) {
-		initrd_start = (unsigned long)&initrd_header[2];
-		initrd_end = initrd_start + initrd_header[1];
+	if (initrd_start && initrd_end > initrd_start)
+		goto sanitize;
+
+	/*
+	 * See if initrd has been added to the kernel image by
+	 * arch/mips/boot/addinitrd.c. In that case a header is
+	 * prepended to initrd and is made up by 8 bytes. The fisrt
+	 * word is a magic number and the second one is the size of
+	 * initrd.  Initrd start must be page aligned in any cases.
+	 */
+	initrd_header = __va(PAGE_ALIGN(__pa_symbol(&_end) + 8)) - 8;
+	if (initrd_header[0] != 0x494E5244)
+		goto disable;
+	initrd_start = (unsigned long)(initrd_header + 2);
+	initrd_end = initrd_start + initrd_header[1];
+
+sanitize:
+	if (initrd_start & ~PAGE_MASK) {
+		printk(KERN_ERR "initrd start must be page aligned\n");
+		goto disable;
 	}
-	return initrd_end;
+	if (initrd_start < PAGE_OFFSET) {
+		printk(KERN_ERR "initrd start < PAGE_OFFSET\n");
+		goto disable;
+	}
+
+	/*
+	 * Sanitize initrd addresses. For example firmware
+	 * can't guess if they need to pass them through
+	 * 64-bits values if the kernel has been built in pure
+	 * 32-bit. We need also to switch from KSEG0 to XKPHYS
+	 * addresses now, so the code can now safely use __pa().
+	 */
+	end = __pa(initrd_end);
+	initrd_end = (unsigned long)__va(end);
+	initrd_start = (unsigned long)__va(__pa(initrd_start));
+
+	ROOT_DEV = Root_RAM0;
+	return PFN_UP(end);
+disable:
+	initrd_start = 0;
+	initrd_end = 0;
+	return 0;
 }
 
 static void __init finalize_initrd(void)
@@ -259,8 +281,7 @@ static void __init bootmem_init(void)
 	 * not selected. Once that done we can determine the low bound
 	 * of usable memory.
 	 */
-	reserved_end = init_initrd();
-	reserved_end = PFN_UP(max(__pa(reserved_end), __pa_symbol(&_end)));
+	reserved_end = max(init_initrd(), PFN_UP(__pa_symbol(&_end)));
 
 	/*
 	 * Find the highest page frame number we have available.

commit f5bffe3a9bcd6e5319b5fd3a8109625f8638425a
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Thu Oct 19 13:20:03 2006 +0200

    [MIPS] setup.c: use __pa_symbol() where needed
    
    It should fix the broken code in resource_init() too.
    
    Signed-off-by: Franck Bui-Huu <fbuihuu@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 715451a9d5d6..b52cc9763763 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -260,7 +260,7 @@ static void __init bootmem_init(void)
 	 * of usable memory.
 	 */
 	reserved_end = init_initrd();
-	reserved_end = PFN_UP(__pa(max(reserved_end, (unsigned long)&_end)));
+	reserved_end = PFN_UP(max(__pa(reserved_end), __pa_symbol(&_end)));
 
 	/*
 	 * Find the highest page frame number we have available.
@@ -432,10 +432,10 @@ static void __init resource_init(void)
 	if (UNCAC_BASE != IO_BASE)
 		return;
 
-	code_resource.start = virt_to_phys(&_text);
-	code_resource.end = virt_to_phys(&_etext) - 1;
-	data_resource.start = virt_to_phys(&_etext);
-	data_resource.end = virt_to_phys(&_edata) - 1;
+	code_resource.start = __pa_symbol(&_text);
+	code_resource.end = __pa_symbol(&_etext) - 1;
+	data_resource.start = __pa_symbol(&_etext);
+	data_resource.end = __pa_symbol(&_edata) - 1;
 
 	/*
 	 * Request address space for all standard RAM.

commit d4df6d4e7a66b7a9bd57f5dc7d80d6b55dc12dbb
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Thu Oct 19 13:20:01 2006 +0200

    [MIPS] setup.c: get ride of CPHYSADDR()
    
    and use new __pa() implementation instead introduced by the previous
    patch. Indeed this macro can be used now even by the 64 bit kernels
    with CONFIG_BUILD_ELF64=n config.
    
    Signed-off-by: Franck Bui-Huu <fbuihuu@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 8f6e89697ccf..715451a9d5d6 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -204,12 +204,12 @@ static void __init finalize_initrd(void)
 		printk(KERN_INFO "Initrd not found or empty");
 		goto disable;
 	}
-	if (CPHYSADDR(initrd_end) > PFN_PHYS(max_low_pfn)) {
+	if (__pa(initrd_end) > PFN_PHYS(max_low_pfn)) {
 		printk("Initrd extends beyond end of memory");
 		goto disable;
 	}
 
-	reserve_bootmem(CPHYSADDR(initrd_start), size);
+	reserve_bootmem(__pa(initrd_start), size);
 	initrd_below_start_ok = 1;
 
 	printk(KERN_INFO "Initial ramdisk at: 0x%lx (%lu bytes)\n",
@@ -260,7 +260,7 @@ static void __init bootmem_init(void)
 	 * of usable memory.
 	 */
 	reserved_end = init_initrd();
-	reserved_end = PFN_UP(CPHYSADDR(max(reserved_end, (unsigned long)&_end)));
+	reserved_end = PFN_UP(__pa(max(reserved_end, (unsigned long)&_end)));
 
 	/*
 	 * Find the highest page frame number we have available.

commit 9ba126cfbf505f4d5b39ed294cedd241321c7a91
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Oct 13 11:22:52 2006 +0100

    [MIPS] Fix warning about init_initrd() call if !CONFIG_BLK_DEV_INITRD.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index fdbb508661c5..8f6e89697ccf 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -223,7 +223,11 @@ static void __init finalize_initrd(void)
 
 #else  /* !CONFIG_BLK_DEV_INITRD */
 
-#define init_initrd()		0
+static unsigned long __init init_initrd(void)
+{
+	return 0;
+}
+
 #define finalize_initrd()	do {} while (0)
 
 #endif

commit a09fc446fb6d541281d9559fe7215d7c0d3cc9ce
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Fri Aug 11 17:51:53 2006 +0200

    [MIPS] setup.c: use early_param() for early command line parsing
    
    There's no point to rewrite some logic to parse command line
    to pass initrd parameters or to declare a user memory area.
    We could use instead parse_early_param() that does the same
    thing.
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 804b93dc3c5a..fdbb508661c5 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -135,138 +135,54 @@ static void __init print_memory_map(void)
 	}
 }
 
-static void __init parse_cmdline_early(void)
-{
-	char c = ' ', *to = command_line, *from = saved_command_line;
-	unsigned long start_at, mem_size;
-	int len = 0;
-	int usermem = 0;
-
-	printk("Determined physical RAM map:\n");
-	print_memory_map();
-
-	for (;;) {
-		/*
-		 * "mem=XXX[kKmM]" defines a memory region from
-		 * 0 to <XXX>, overriding the determined size.
-		 * "mem=XXX[KkmM]@YYY[KkmM]" defines a memory region from
-		 * <YYY> to <YYY>+<XXX>, overriding the determined size.
-		 */
-		if (c == ' ' && !memcmp(from, "mem=", 4)) {
-			if (to != command_line)
-				to--;
-			/*
-			 * If a user specifies memory size, we
-			 * blow away any automatically generated
-			 * size.
-			 */
-			if (usermem == 0) {
-				boot_mem_map.nr_map = 0;
-				usermem = 1;
-			}
-			mem_size = memparse(from + 4, &from);
-			if (*from == '@')
-				start_at = memparse(from + 1, &from);
-			else
-				start_at = 0;
-			add_memory_region(start_at, mem_size, BOOT_MEM_RAM);
-		}
-		c = *(from++);
-		if (!c)
-			break;
-		if (CL_SIZE <= ++len)
-			break;
-		*(to++) = c;
-	}
-	*to = '\0';
-
-	if (usermem) {
-		printk("User-defined physical RAM map:\n");
-		print_memory_map();
-	}
-}
-
 /*
  * Manage initrd
  */
 #ifdef CONFIG_BLK_DEV_INITRD
 
-static int __init parse_rd_cmdline(unsigned long *rd_start, unsigned long *rd_end)
+static int __init rd_start_early(char *p)
 {
-	/*
-	 * "rd_start=0xNNNNNNNN" defines the memory address of an initrd
-	 * "rd_size=0xNN" it's size
-	 */
-	unsigned long start = 0;
-	unsigned long size = 0;
-	unsigned long end;
-	char cmd_line[CL_SIZE];
-	char *start_str;
-	char *size_str;
-	char *tmp;
-
-	strcpy(cmd_line, command_line);
-	*command_line = 0;
-	tmp = cmd_line;
-	/* Ignore "rd_start=" strings in other parameters. */
-	start_str = strstr(cmd_line, "rd_start=");
-	if (start_str && start_str != cmd_line && *(start_str - 1) != ' ')
-		start_str = strstr(start_str, " rd_start=");
-	while (start_str) {
-		if (start_str != cmd_line)
-			strncat(command_line, tmp, start_str - tmp);
-		start = memparse(start_str + 9, &start_str);
-		tmp = start_str + 1;
-		start_str = strstr(start_str, " rd_start=");
-	}
-	if (*tmp)
-		strcat(command_line, tmp);
-
-	strcpy(cmd_line, command_line);
-	*command_line = 0;
-	tmp = cmd_line;
-	/* Ignore "rd_size" strings in other parameters. */
-	size_str = strstr(cmd_line, "rd_size=");
-	if (size_str && size_str != cmd_line && *(size_str - 1) != ' ')
-		size_str = strstr(size_str, " rd_size=");
-	while (size_str) {
-		if (size_str != cmd_line)
-			strncat(command_line, tmp, size_str - tmp);
-		size = memparse(size_str + 8, &size_str);
-		tmp = size_str + 1;
-		size_str = strstr(size_str, " rd_size=");
-	}
-	if (*tmp)
-		strcat(command_line, tmp);
+	unsigned long start = memparse(p, &p);
 
 #ifdef CONFIG_64BIT
 	/* HACK: Guess if the sign extension was forgotten */
 	if (start > 0x0000000080000000 && start < 0x00000000ffffffff)
 		start |= 0xffffffff00000000UL;
 #endif
+	initrd_start = start;
+	initrd_end += start;
+
+	return 0;
+}
+early_param("rd_start", rd_start_early);
+
+static int __init rd_size_early(char *p)
+{
+	initrd_end += memparse(p, &p);
 
-	end = start + size;
-	if (start && end) {
-		*rd_start = start;
-		*rd_end = end;
-		return 1;
-	}
 	return 0;
 }
+early_param("rd_size", rd_size_early);
 
 static unsigned long __init init_initrd(void)
 {
-	unsigned long tmp, end;
+	unsigned long tmp, end, size;
 	u32 *initrd_header;
 
 	ROOT_DEV = Root_RAM0;
 
-	if (parse_rd_cmdline(&initrd_start, &initrd_end))
-		return initrd_end;
 	/*
-	 * Board specific code should have set up initrd_start
-	 * and initrd_end...
+	 * Board specific code or command line parser should have
+	 * already set up initrd_start and initrd_end. In these cases
+	 * perfom sanity checks and use them if all looks good.
 	 */
+	size = initrd_end - initrd_start;
+	if (initrd_end == 0 || size == 0) {
+		initrd_start = 0;
+		initrd_end = 0;
+	} else
+		return initrd_end;
+
 	end = (unsigned long)&_end;
 	tmp = PAGE_ALIGN(end) - sizeof(u32) * 2;
 	if (tmp < end)
@@ -436,8 +352,6 @@ static void __init bootmem_init(void)
  *
  *  o plat_mem_setup() detects the memory configuration and will record detected
  *    memory areas using add_memory_region.
- *  o parse_cmdline_early() parses the command line for mem= options which,
- *    iff detected, will override the results of the automatic detection.
  *
  * At this stage the memory configuration of the system is known to the
  * kernel but generic memory managment system is still entirely uninitialized.
@@ -455,19 +369,53 @@ static void __init bootmem_init(void)
  * initialization hook for anything else was introduced.
  */
 
-extern void plat_mem_setup(void);
+static int usermem __initdata = 0;
+
+static int __init early_parse_mem(char *p)
+{
+	unsigned long start, size;
+
+	/*
+	 * If a user specifies memory size, we
+	 * blow away any automatically generated
+	 * size.
+	 */
+	if (usermem == 0) {
+		boot_mem_map.nr_map = 0;
+		usermem = 1;
+ 	}
+	start = 0;
+	size = memparse(p, &p);
+	if (*p == '@')
+		start = memparse(p + 1, &p);
+
+	add_memory_region(start, size, BOOT_MEM_RAM);
+	return 0;
+}
+early_param("mem", early_parse_mem);
 
 static void __init arch_mem_init(char **cmdline_p)
 {
+	extern void plat_mem_setup(void);
+
 	/* call board setup routine */
 	plat_mem_setup();
 
+	printk("Determined physical RAM map:\n");
+	print_memory_map();
+
 	strlcpy(command_line, arcs_cmdline, sizeof(command_line));
 	strlcpy(saved_command_line, command_line, COMMAND_LINE_SIZE);
 
 	*cmdline_p = command_line;
 
-	parse_cmdline_early();
+	parse_early_param();
+
+	if (usermem) {
+		printk("User-defined physical RAM map:\n");
+		print_memory_map();
+	}
+
 	bootmem_init();
 	sparse_init();
 	paging_init();

commit 1c6fd44d7ed3d105b2eaa29d72b415ca51e40d32
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Fri Aug 11 17:51:52 2006 +0200

    [MIPS] setup.c: remove MAXMEM macro
    
    It doesn't improve readability.
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index f66af9cc7220..804b93dc3c5a 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -473,9 +473,6 @@ static void __init arch_mem_init(char **cmdline_p)
 	paging_init();
 }
 
-#define MAXMEM		HIGHMEM_START
-#define MAXMEM_PFN	PFN_DOWN(MAXMEM)
-
 static void __init resource_init(void)
 {
 	int i;
@@ -497,10 +494,10 @@ static void __init resource_init(void)
 
 		start = boot_mem_map.map[i].addr;
 		end = boot_mem_map.map[i].addr + boot_mem_map.map[i].size - 1;
-		if (start >= MAXMEM)
+		if (start >= HIGHMEM_START)
 			continue;
-		if (end >= MAXMEM)
-			end = MAXMEM - 1;
+		if (end >= HIGHMEM_START)
+			end = HIGHMEM_START - 1;
 
 		res = alloc_bootmem(sizeof(struct resource));
 		switch (boot_mem_map.map[i].type) {
@@ -529,9 +526,6 @@ static void __init resource_init(void)
 	}
 }
 
-#undef MAXMEM
-#undef MAXMEM_PFN
-
 void __init setup_arch(char **cmdline_p)
 {
 	cpu_probe();

commit 8df32c636e785069ba7d223ceb9b72c182902295
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Fri Aug 11 17:51:51 2006 +0200

    [MIPS] setup.c: do not inline functions
    
    There's no point to inline any functions in setup.c. Let's GCC
    doing its job, it's good enough for that now.
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 0bdc67116deb..f66af9cc7220 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -135,7 +135,7 @@ static void __init print_memory_map(void)
 	}
 }
 
-static inline void parse_cmdline_early(void)
+static void __init parse_cmdline_early(void)
 {
 	char c = ' ', *to = command_line, *from = saved_command_line;
 	unsigned long start_at, mem_size;
@@ -476,7 +476,7 @@ static void __init arch_mem_init(char **cmdline_p)
 #define MAXMEM		HIGHMEM_START
 #define MAXMEM_PFN	PFN_DOWN(MAXMEM)
 
-static inline void resource_init(void)
+static void __init resource_init(void)
 {
 	int i;
 

commit 8ff7bc4808f25e4dd75c3775dba313ddf35277e1
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Fri Aug 11 17:51:50 2006 +0200

    [MIPS] setup.c: remove useless includes.
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 489b27320dfa..0bdc67116deb 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -10,29 +10,15 @@
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Copyright (C) 2000 2001, 2002  Maciej W. Rozycki
  */
-#include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
-#include <linux/sched.h>
-#include <linux/kernel.h>
-#include <linux/mm.h>
 #include <linux/module.h>
-#include <linux/stddef.h>
-#include <linux/string.h>
-#include <linux/unistd.h>
-#include <linux/slab.h>
-#include <linux/user.h>
-#include <linux/utsname.h>
-#include <linux/a.out.h>
 #include <linux/screen_info.h>
 #include <linux/bootmem.h>
 #include <linux/initrd.h>
-#include <linux/major.h>
-#include <linux/kdev_t.h>
 #include <linux/root_dev.h>
 #include <linux/highmem.h>
 #include <linux/console.h>
-#include <linux/mmzone.h>
 #include <linux/pfn.h>
 
 #include <asm/addrspace.h>

commit d2043ca8484d434201816267c0e23c5999df6cfd
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Fri Aug 11 17:51:49 2006 +0200

    [MIPS] setup.c: move initrd code inside dedicated functions
    
    NUMA specific code could rely on them too.
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index bcbd926e58f7..489b27320dfa 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -200,7 +200,12 @@ static inline void parse_cmdline_early(void)
 	}
 }
 
-static inline int parse_rd_cmdline(unsigned long* rd_start, unsigned long* rd_end)
+/*
+ * Manage initrd
+ */
+#ifdef CONFIG_BLK_DEV_INITRD
+
+static int __init parse_rd_cmdline(unsigned long *rd_start, unsigned long *rd_end)
 {
 	/*
 	 * "rd_start=0xNNNNNNNN" defines the memory address of an initrd
@@ -263,49 +268,93 @@ static inline int parse_rd_cmdline(unsigned long* rd_start, unsigned long* rd_en
 	return 0;
 }
 
+static unsigned long __init init_initrd(void)
+{
+	unsigned long tmp, end;
+	u32 *initrd_header;
+
+	ROOT_DEV = Root_RAM0;
+
+	if (parse_rd_cmdline(&initrd_start, &initrd_end))
+		return initrd_end;
+	/*
+	 * Board specific code should have set up initrd_start
+	 * and initrd_end...
+	 */
+	end = (unsigned long)&_end;
+	tmp = PAGE_ALIGN(end) - sizeof(u32) * 2;
+	if (tmp < end)
+		tmp += PAGE_SIZE;
+
+	initrd_header = (u32 *)tmp;
+	if (initrd_header[0] == 0x494E5244) {
+		initrd_start = (unsigned long)&initrd_header[2];
+		initrd_end = initrd_start + initrd_header[1];
+	}
+	return initrd_end;
+}
+
+static void __init finalize_initrd(void)
+{
+	unsigned long size = initrd_end - initrd_start;
+
+	if (size == 0) {
+		printk(KERN_INFO "Initrd not found or empty");
+		goto disable;
+	}
+	if (CPHYSADDR(initrd_end) > PFN_PHYS(max_low_pfn)) {
+		printk("Initrd extends beyond end of memory");
+		goto disable;
+	}
+
+	reserve_bootmem(CPHYSADDR(initrd_start), size);
+	initrd_below_start_ok = 1;
+
+	printk(KERN_INFO "Initial ramdisk at: 0x%lx (%lu bytes)\n",
+	       initrd_start, size);
+	return;
+disable:
+	printk(" - disabling initrd\n");
+	initrd_start = 0;
+	initrd_end = 0;
+}
+
+#else  /* !CONFIG_BLK_DEV_INITRD */
+
+#define init_initrd()		0
+#define finalize_initrd()	do {} while (0)
+
+#endif
+
 /*
  * Initialize the bootmem allocator. It also setup initrd related data
  * if needed.
  */
+#ifdef CONFIG_SGI_IP27
+
 static void __init bootmem_init(void)
 {
-	unsigned long reserved_end = (unsigned long)&_end;
-#ifndef CONFIG_SGI_IP27
+	init_initrd();
+	finalize_initrd();
+}
+
+#else  /* !CONFIG_SGI_IP27 */
+
+static void __init bootmem_init(void)
+{
+	unsigned long reserved_end;
 	unsigned long highest = 0;
 	unsigned long mapstart = -1UL;
 	unsigned long bootmap_size;
 	int i;
-#endif
-#ifdef CONFIG_BLK_DEV_INITRD
-	int initrd_reserve_bootmem = 0;
-
-	/* Board specific code should have set up initrd_start and initrd_end */
- 	ROOT_DEV = Root_RAM0;
-	if (parse_rd_cmdline(&initrd_start, &initrd_end)) {
-		reserved_end = max(reserved_end, initrd_end);
-		initrd_reserve_bootmem = 1;
-	} else {
-		unsigned long tmp;
-		u32 *initrd_header;
-
-		tmp = PAGE_ALIGN(reserved_end) - sizeof(u32) * 2;
-		if (tmp < reserved_end)
-			tmp += PAGE_SIZE;
-		initrd_header = (u32 *)tmp;
-		if (initrd_header[0] == 0x494E5244) {
-			initrd_start = (unsigned long)&initrd_header[2];
-			initrd_end = initrd_start + initrd_header[1];
-			reserved_end = max(reserved_end, initrd_end);
-			initrd_reserve_bootmem = 1;
-		}
-	}
-#endif	/* CONFIG_BLK_DEV_INITRD */
 
-#ifndef CONFIG_SGI_IP27
 	/*
-	 * reserved_end is now a pfn
+	 * Init any data related to initrd. It's a nop if INITRD is
+	 * not selected. Once that done we can determine the low bound
+	 * of usable memory.
 	 */
-	reserved_end = PFN_UP(CPHYSADDR(reserved_end));
+	reserved_end = init_initrd();
+	reserved_end = PFN_UP(CPHYSADDR(max(reserved_end, (unsigned long)&_end)));
 
 	/*
 	 * Find the highest page frame number we have available.
@@ -388,35 +437,14 @@ static void __init bootmem_init(void)
 	 */
 	reserve_bootmem(PFN_PHYS(mapstart), bootmap_size);
 
-#endif /* CONFIG_SGI_IP27 */
-
-#ifdef CONFIG_BLK_DEV_INITRD
-	initrd_below_start_ok = 1;
-	if (initrd_start) {
-		unsigned long initrd_size = ((unsigned char *)initrd_end) -
-			((unsigned char *)initrd_start);
-		const int width = sizeof(long) * 2;
-
-		printk("Initial ramdisk at: 0x%p (%lu bytes)\n",
-		       (void *)initrd_start, initrd_size);
-
-		if (CPHYSADDR(initrd_end) > PFN_PHYS(max_low_pfn)) {
-			printk("initrd extends beyond end of memory "
-			       "(0x%0*Lx > 0x%0*Lx)\ndisabling initrd\n",
-			       width,
-			       (unsigned long long) CPHYSADDR(initrd_end),
-			       width,
-			       (unsigned long long) PFN_PHYS(max_low_pfn));
-			initrd_start = initrd_end = 0;
-			initrd_reserve_bootmem = 0;
-		}
-
-		if (initrd_reserve_bootmem)
-			reserve_bootmem(CPHYSADDR(initrd_start), initrd_size);
-	}
-#endif /* CONFIG_BLK_DEV_INITRD  */
+	/*
+	 * Reserve initrd memory if needed.
+	 */
+	finalize_initrd();
 }
 
+#endif	/* CONFIG_SGI_IP27 */
+
 /*
  * arch_mem_init - initialize memory managment subsystem
  *

commit b6f1f0dea1469e0c956eb89399916d60dd2a3808
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Fri Aug 11 17:51:48 2006 +0200

    [MIPS] setup.c: cleanup bootmem_init()
    
    This function although doing simple thing is hard to follow. It's
    mainly due to:
    
        - a lot of #ifdef
        - bad local names
        - redundant tests
    
    So this patch try to address these issues. It also do not use
    max_pfn global which is marked as an unused exported symbol.
    
    As a bonus side, it's now really easy to see what part of the
    code is for no-numa system.
    
    There's also no point to make this function inline.
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 8c2b596a136f..bcbd926e58f7 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -96,6 +96,12 @@ void __init add_memory_region(phys_t start, phys_t size, long type)
 	int x = boot_mem_map.nr_map;
 	struct boot_mem_map_entry *prev = boot_mem_map.map + x - 1;
 
+	/* Sanity check */
+	if (start + size < start) {
+		printk("Trying to add an invalid memory region, skipped\n");
+		return;
+	}
+
 	/*
 	 * Try to merge with previous entry if any.  This is far less than
 	 * perfect but is sufficient for most real world cases.
@@ -257,15 +263,16 @@ static inline int parse_rd_cmdline(unsigned long* rd_start, unsigned long* rd_en
 	return 0;
 }
 
-#define MAXMEM		HIGHMEM_START
-#define MAXMEM_PFN	PFN_DOWN(MAXMEM)
-
-static inline void bootmem_init(void)
+/*
+ * Initialize the bootmem allocator. It also setup initrd related data
+ * if needed.
+ */
+static void __init bootmem_init(void)
 {
-	unsigned long start_pfn;
 	unsigned long reserved_end = (unsigned long)&_end;
 #ifndef CONFIG_SGI_IP27
-	unsigned long first_usable_pfn;
+	unsigned long highest = 0;
+	unsigned long mapstart = -1UL;
 	unsigned long bootmap_size;
 	int i;
 #endif
@@ -281,7 +288,7 @@ static inline void bootmem_init(void)
 		unsigned long tmp;
 		u32 *initrd_header;
 
-		tmp = ((reserved_end + PAGE_SIZE-1) & PAGE_MASK) - sizeof(u32) * 2;
+		tmp = PAGE_ALIGN(reserved_end) - sizeof(u32) * 2;
 		if (tmp < reserved_end)
 			tmp += PAGE_SIZE;
 		initrd_header = (u32 *)tmp;
@@ -294,16 +301,15 @@ static inline void bootmem_init(void)
 	}
 #endif	/* CONFIG_BLK_DEV_INITRD */
 
+#ifndef CONFIG_SGI_IP27
 	/*
-	 * Partially used pages are not usable - thus
-	 * we are rounding upwards.
+	 * reserved_end is now a pfn
 	 */
-	start_pfn = PFN_UP(CPHYSADDR(reserved_end));
+	reserved_end = PFN_UP(CPHYSADDR(reserved_end));
 
-#ifndef CONFIG_SGI_IP27
-	/* Find the highest page frame number we have available.  */
-	max_pfn = 0;
-	first_usable_pfn = -1UL;
+	/*
+	 * Find the highest page frame number we have available.
+	 */
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
 		unsigned long start, end;
 
@@ -312,56 +318,38 @@ static inline void bootmem_init(void)
 
 		start = PFN_UP(boot_mem_map.map[i].addr);
 		end = PFN_DOWN(boot_mem_map.map[i].addr
-		      + boot_mem_map.map[i].size);
+				+ boot_mem_map.map[i].size);
 
-		if (start >= end)
+		if (end > highest)
+			highest = end;
+		if (end <= reserved_end)
 			continue;
-		if (end > max_pfn)
-			max_pfn = end;
-		if (start < first_usable_pfn) {
-			if (start > start_pfn) {
-				first_usable_pfn = start;
-			} else if (end > start_pfn) {
-				first_usable_pfn = start_pfn;
-			}
-		}
+		if (start >= mapstart)
+			continue;
+		mapstart = max(reserved_end, start);
 	}
 
 	/*
 	 * Determine low and high memory ranges
 	 */
-	max_low_pfn = max_pfn;
-	if (max_low_pfn > MAXMEM_PFN) {
-		max_low_pfn = MAXMEM_PFN;
-#ifndef CONFIG_HIGHMEM
-		/* Maximum memory usable is what is directly addressable */
-		printk(KERN_WARNING "Warning only %ldMB will be used.\n",
-		       MAXMEM >> 20);
-		printk(KERN_WARNING "Use a HIGHMEM enabled kernel.\n");
+	if (highest > PFN_DOWN(HIGHMEM_START)) {
+#ifdef CONFIG_HIGHMEM
+		highstart_pfn = PFN_DOWN(HIGHMEM_START);
+		highend_pfn = highest;
 #endif
+		highest = PFN_DOWN(HIGHMEM_START);
 	}
 
-#ifdef CONFIG_HIGHMEM
 	/*
-	 * Crude, we really should make a better attempt at detecting
-	 * highstart_pfn
+	 * Initialize the boot-time allocator with low memory only.
 	 */
-	highstart_pfn = highend_pfn = max_pfn;
-	if (max_pfn > MAXMEM_PFN) {
-		highstart_pfn = MAXMEM_PFN;
-		printk(KERN_NOTICE "%ldMB HIGHMEM available.\n",
-		       (highend_pfn - highstart_pfn) >> (20 - PAGE_SHIFT));
-	}
-#endif
-
-	/* Initialize the boot-time allocator with low memory only.  */
-	bootmap_size = init_bootmem(first_usable_pfn, max_low_pfn);
+	bootmap_size = init_bootmem(mapstart, highest);
 
 	/*
 	 * Register fully available low RAM pages with the bootmem allocator.
 	 */
 	for (i = 0; i < boot_mem_map.nr_map; i++) {
-		unsigned long curr_pfn, last_pfn, size;
+		unsigned long start, end, size;
 
 		/*
 		 * Reserve usable memory.
@@ -369,49 +357,37 @@ static inline void bootmem_init(void)
 		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
 			continue;
 
-		/*
-		 * We are rounding up the start address of usable memory:
-		 */
-		curr_pfn = PFN_UP(boot_mem_map.map[i].addr);
-		if (curr_pfn >= max_low_pfn)
-			continue;
-		if (curr_pfn < start_pfn)
-			curr_pfn = start_pfn;
-
-		/*
-		 * ... and at the end of the usable range downwards:
-		 */
-		last_pfn = PFN_DOWN(boot_mem_map.map[i].addr
+		start = PFN_UP(boot_mem_map.map[i].addr);
+		end   = PFN_DOWN(boot_mem_map.map[i].addr
 				    + boot_mem_map.map[i].size);
-
-		if (last_pfn > max_low_pfn)
-			last_pfn = max_low_pfn;
-
 		/*
-		 * Only register lowmem part of lowmem segment with bootmem.
+		 * We are rounding up the start address of usable memory
+		 * and at the end of the usable range downwards.
 		 */
-		size = last_pfn - curr_pfn;
-		if (curr_pfn > PFN_DOWN(HIGHMEM_START))
-			continue;
-		if (curr_pfn + size - 1 > PFN_DOWN(HIGHMEM_START))
-			size = PFN_DOWN(HIGHMEM_START) - curr_pfn;
-		if (!size)
+		if (start >= max_low_pfn)
 			continue;
+		if (start < reserved_end)
+			start = reserved_end;
+		if (end > max_low_pfn)
+			end = max_low_pfn;
 
 		/*
-		 * ... finally, did all the rounding and playing
-		 * around just make the area go away?
+		 * ... finally, is the area going away?
 		 */
-		if (last_pfn <= curr_pfn)
+		if (end <= start)
 			continue;
+		size = end - start;
 
 		/* Register lowmem ranges */
-		free_bootmem(PFN_PHYS(curr_pfn), PFN_PHYS(size));
-		memory_present(0, curr_pfn, curr_pfn + size - 1);
+		free_bootmem(PFN_PHYS(start), size << PAGE_SHIFT);
+		memory_present(0, start, end);
 	}
 
-	/* Reserve the bootmap memory.  */
-	reserve_bootmem(PFN_PHYS(first_usable_pfn), bootmap_size);
+	/*
+	 * Reserve the bootmap memory.
+	 */
+	reserve_bootmem(PFN_PHYS(mapstart), bootmap_size);
+
 #endif /* CONFIG_SGI_IP27 */
 
 #ifdef CONFIG_BLK_DEV_INITRD
@@ -483,6 +459,9 @@ static void __init arch_mem_init(char **cmdline_p)
 	paging_init();
 }
 
+#define MAXMEM		HIGHMEM_START
+#define MAXMEM_PFN	PFN_DOWN(MAXMEM)
+
 static inline void resource_init(void)
 {
 	int i;

commit 894673ee6122a3ce1958e1fe096901ba5356a96b
Author: Jon Smirl <jonsmir@gmail.com>
Date:   Mon Jul 10 04:44:13 2006 -0700

    [PATCH] tty: Remove include of screen_info.h from tty.h
    
    screen_info.h doesn't have anything to do with the tty layer and shouldn't be
    included by tty.h.  This patches removes the include and modifies all users to
    directly include screen_info.h.  struct screen_info is mainly used to
    communicate with the console drivers in drivers/video/console.  Note that this
    patch touches every arch and I have no way of testing it.  If there is a
    mistake the worst thing that will happen is a compile error.
    
    [akpm@osdl.org: fix arm build]
    [akpm@osdl.org: fix alpha build]
    Signed-off-by: Jon Smirl <jonsmir@gmail.com>
    Signed-off-by: Antonino Daplas <adaplas@pol.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 5edd8d4bb665..8c2b596a136f 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -24,7 +24,7 @@
 #include <linux/user.h>
 #include <linux/utsname.h>
 #include <linux/a.out.h>
-#include <linux/tty.h>
+#include <linux/screen_info.h>
 #include <linux/bootmem.h>
 #include <linux/initrd.h>
 #include <linux/major.h>

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: JÃ¶rn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: JÃ¶rn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index d3e087115023..5edd8d4bb665 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -10,7 +10,6 @@
  * Copyright (C) 1999 Silicon Graphics, Inc.
  * Copyright (C) 2000 2001, 2002  Maciej W. Rozycki
  */
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/init.h>
 #include <linux/ioport.h>

commit 6adb5fe7020e8f99d27da932157ea27325df9263
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jun 20 12:47:53 2006 +0100

    [MIPS] Only register RAM as resources if UNCAC_BASE != IO_BASE.
    
    This fixes a resource collision of RAM and I/O memory on systems that
    use the physical address space multiple times.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index bfcec8d9bfe4..d3e087115023 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -488,6 +488,9 @@ static inline void resource_init(void)
 {
 	int i;
 
+	if (UNCAC_BASE != IO_BASE)
+		return;
+
 	code_resource.start = virt_to_phys(&_text);
 	code_resource.end = virt_to_phys(&_etext) - 1;
 	data_resource.start = virt_to_phys(&_etext);

commit 2925aba4223f4532e85f0c6f64584b3e0b2849c3
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sun Jun 18 01:32:22 2006 +0100

    [MIPS] Cleanup memory managment initialization.
    
    Historically plat_mem_setup did the entire platform initialization.  This
    was rather impractical because it meant plat_mem_setup had to get away
    without any kind of memory allocator.  To keep old code from breaking
    plat_setup was just renamed to plat_setup and a second platform
    initialization hook for anything else was introduced.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 397a70e651b5..bfcec8d9bfe4 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -442,6 +442,48 @@ static inline void bootmem_init(void)
 #endif /* CONFIG_BLK_DEV_INITRD  */
 }
 
+/*
+ * arch_mem_init - initialize memory managment subsystem
+ *
+ *  o plat_mem_setup() detects the memory configuration and will record detected
+ *    memory areas using add_memory_region.
+ *  o parse_cmdline_early() parses the command line for mem= options which,
+ *    iff detected, will override the results of the automatic detection.
+ *
+ * At this stage the memory configuration of the system is known to the
+ * kernel but generic memory managment system is still entirely uninitialized.
+ *
+ *  o bootmem_init()
+ *  o sparse_init()
+ *  o paging_init()
+ *
+ * At this stage the bootmem allocator is ready to use.
+ *
+ * NOTE: historically plat_mem_setup did the entire platform initialization.
+ *       This was rather impractical because it meant plat_mem_setup had to
+ * get away without any kind of memory allocator.  To keep old code from
+ * breaking plat_setup was just renamed to plat_setup and a second platform
+ * initialization hook for anything else was introduced.
+ */
+
+extern void plat_mem_setup(void);
+
+static void __init arch_mem_init(char **cmdline_p)
+{
+	/* call board setup routine */
+	plat_mem_setup();
+
+	strlcpy(command_line, arcs_cmdline, sizeof(command_line));
+	strlcpy(saved_command_line, command_line, COMMAND_LINE_SIZE);
+
+	*cmdline_p = command_line;
+
+	parse_cmdline_early();
+	bootmem_init();
+	sparse_init();
+	paging_init();
+}
+
 static inline void resource_init(void)
 {
 	int i;
@@ -495,8 +537,6 @@ static inline void resource_init(void)
 #undef MAXMEM
 #undef MAXMEM_PFN
 
-extern void plat_setup(void);
-
 void __init setup_arch(char **cmdline_p)
 {
 	cpu_probe();
@@ -511,18 +551,8 @@ void __init setup_arch(char **cmdline_p)
 #endif
 #endif
 
-	/* call board setup routine */
-	plat_setup();
+	arch_mem_init(cmdline_p);
 
-	strlcpy(command_line, arcs_cmdline, sizeof(command_line));
-	strlcpy(saved_command_line, command_line, COMMAND_LINE_SIZE);
-
-	*cmdline_p = command_line;
-
-	parse_cmdline_early();
-	bootmem_init();
-	sparse_init();
-	paging_init();
 	resource_init();
 #ifdef CONFIG_SMP
 	plat_smp_setup();

commit b1c231f5a57cb4a417c38a8a946f1e66db3bb9c0
Author: Chad Reese <creese@caviumnetworks.com>
Date:   Tue May 30 17:16:49 2006 -0700

    [MIPS] Fix sparsemem support.
    
    Move memory_present() in arch/mips/kernel/setup.c. When using sparsemem
    extreme, this function does an allocate for bootmem. This would always
    fail since init_bootmem hasn't been called yet.
    
    Move memory_present after free_bootmem. This only marks actual memory
    ranges as present instead of the entire address space.
    
    Signed-off-by: Chad Reese  <creese@caviumnetworks.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index a481be047696..397a70e651b5 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -355,8 +355,6 @@ static inline void bootmem_init(void)
 	}
 #endif
 
-	memory_present(0, first_usable_pfn, max_low_pfn);
-
 	/* Initialize the boot-time allocator with low memory only.  */
 	bootmap_size = init_bootmem(first_usable_pfn, max_low_pfn);
 
@@ -410,6 +408,7 @@ static inline void bootmem_init(void)
 
 		/* Register lowmem ranges */
 		free_bootmem(PFN_PHYS(curr_pfn), PFN_PHYS(size));
+		memory_present(0, curr_pfn, curr_pfn + size - 1);
 	}
 
 	/* Reserve the bootmap memory.  */

commit ecf52d3c895c8bc069b9ae07c18acf39d846c2ef
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jun 1 01:00:03 2006 +0900

    [MIPS] Fix compiler warnings (field width, unused variable)
    
    Fix following warnings:
    linux/arch/mips/kernel/setup.c:432: warning: field width is not type int (arg 2)
    linux/arch/mips/kernel/setup.c:432: warning: field width is not type int (arg 4)
    linux/arch/mips/kernel/syscall.c:279: warning: unused variable `len'
    linux/arch/mips/kernel/syscall.c:280: warning: unused variable `name'
    linux/arch/mips/math-emu/dp_fint.c:32: warning: unused variable `xc'
    linux/arch/mips/math-emu/dp_flong.c:32: warning: unused variable `xc'
    linux/arch/mips/math-emu/sp_fint.c:32: warning: unused variable `xc'
    linux/arch/mips/math-emu/sp_flong.c:32: warning: unused variable `xc'
    
    (original patch by Atsushi, slight changes to the setup.c part by me.)
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index faeed5f4cf26..a481be047696 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -419,17 +419,20 @@ static inline void bootmem_init(void)
 #ifdef CONFIG_BLK_DEV_INITRD
 	initrd_below_start_ok = 1;
 	if (initrd_start) {
-		unsigned long initrd_size = ((unsigned char *)initrd_end) - ((unsigned char *)initrd_start);
+		unsigned long initrd_size = ((unsigned char *)initrd_end) -
+			((unsigned char *)initrd_start);
+		const int width = sizeof(long) * 2;
+
 		printk("Initial ramdisk at: 0x%p (%lu bytes)\n",
 		       (void *)initrd_start, initrd_size);
 
 		if (CPHYSADDR(initrd_end) > PFN_PHYS(max_low_pfn)) {
 			printk("initrd extends beyond end of memory "
 			       "(0x%0*Lx > 0x%0*Lx)\ndisabling initrd\n",
-			       sizeof(long) * 2,
-			       (unsigned long long)CPHYSADDR(initrd_end),
-			       sizeof(long) * 2,
-			       (unsigned long long)PFN_PHYS(max_low_pfn));
+			       width,
+			       (unsigned long long) CPHYSADDR(initrd_end),
+			       width,
+			       (unsigned long long) PFN_PHYS(max_low_pfn));
 			initrd_start = initrd_end = 0;
 			initrd_reserve_bootmem = 0;
 		}

commit 460c0422c3861ab63a14c2be600a96a9e68b89f2
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Jun 1 01:00:39 2006 +0900

    [MIPS] Fix sparse warnings about too big constants.
    
    Fix following warnings:
    linux/arch/mips/kernel/setup.c:249:12: warning: constant 0xffffffff00000000 is so big it is unsigned long
    linux/arch/mips/kernel/cpu-bugs64.c:209:10: warning: constant 0xffffffffffffdb9a is so big it is unsigned long
    linux/arch/mips/kernel/cpu-bugs64.c:227:10: warning: constant 0xffffffffffffdb9a is so big it is unsigned long
    linux/arch/mips/kernel/cpu-bugs64.c:283:10: warning: constant 0xffffffffffffdb9a is so big it is unsigned long
    linux/arch/mips/kernel/cpu-bugs64.c:299:10: warning: constant 0xffffffffffffdb9a is so big it is unsigned long
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index bcf1b10e518f..faeed5f4cf26 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -246,7 +246,7 @@ static inline int parse_rd_cmdline(unsigned long* rd_start, unsigned long* rd_en
 #ifdef CONFIG_64BIT
 	/* HACK: Guess if the sign extension was forgotten */
 	if (start > 0x0000000080000000 && start < 0x00000000ffffffff)
-		start |= 0xffffffff00000000;
+		start |= 0xffffffff00000000UL;
 #endif
 
 	end = start + size;

commit f088fc84f94c1a36943e28ad704a9a740a35f877
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Apr 5 09:45:47 2006 +0100

    [MIPS] FPU affinity for MT ASE.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index dcbfd27071f0..bcf1b10e518f 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -529,7 +529,10 @@ void __init setup_arch(char **cmdline_p)
 
 int __init fpu_disable(char *s)
 {
-	cpu_data[0].options &= ~MIPS_CPU_FPU;
+	int i;
+
+	for (i = 0; i < NR_CPUS; i++)
+		cpu_data[i].options &= ~MIPS_CPU_FPU;
 
 	return 1;
 }

commit 22a9835c350782a5c3257343713932af3ac92ee0
Author: Dave Hansen <haveblue@us.ibm.com>
Date:   Mon Mar 27 01:16:04 2006 -0800

    [PATCH] unify PFN_* macros
    
    Just about every architecture defines some macros to do operations on pfns.
     They're all virtually identical.  This patch consolidates all of them.
    
    One minor glitch is that at least i386 uses them in a very skeletal header
    file.  To keep away from #include dependency hell, I stuck the new
    definitions in a new, isolated header.
    
    Of all of the implementations, sh64 is the only one that varied by a bit.
    It used some masks to ensure that any sign-extension got ripped away before
    the arithmetic is done.  This has been posted to that sh64 maintainers and
    the development list.
    
    Compiles on x86, x86_64, ia64 and ppc64.
    
    Signed-off-by: Dave Hansen <haveblue@us.ibm.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 0cb3b6097e0e..dcbfd27071f0 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -34,6 +34,7 @@
 #include <linux/highmem.h>
 #include <linux/console.h>
 #include <linux/mmzone.h>
+#include <linux/pfn.h>
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
@@ -257,10 +258,6 @@ static inline int parse_rd_cmdline(unsigned long* rd_start, unsigned long* rd_en
 	return 0;
 }
 
-#define PFN_UP(x)	(((x) + PAGE_SIZE - 1) >> PAGE_SHIFT)
-#define PFN_DOWN(x)	((x) >> PAGE_SHIFT)
-#define PFN_PHYS(x)	((x) << PAGE_SHIFT)
-
 #define MAXMEM		HIGHMEM_START
 #define MAXMEM_PFN	PFN_DOWN(MAXMEM)
 
@@ -493,10 +490,6 @@ static inline void resource_init(void)
 	}
 }
 
-#undef PFN_UP
-#undef PFN_DOWN
-#undef PFN_PHYS
-
 #undef MAXMEM
 #undef MAXMEM_PFN
 

commit 8145095cd8fd466980ea6401f26a52e462275222
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Feb 22 23:06:55 2006 +0000

    [MIPS] Remove CONFIG_BUILD_ELF64.
    
    This option is no longer usable with supported compilers.  It will be
    replaced by usage of -msym32 in a separate patch.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index d9293c558e41..0cb3b6097e0e 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -447,21 +447,10 @@ static inline void resource_init(void)
 {
 	int i;
 
-#if defined(CONFIG_64BIT) && !defined(CONFIG_BUILD_ELF64)
-	/*
-	 * The 64bit code in 32bit object format trick can't represent
-	 * 64bit wide relocations for linker script symbols.
-	 */
-	code_resource.start = CPHYSADDR(&_text);
-	code_resource.end = CPHYSADDR(&_etext) - 1;
-	data_resource.start = CPHYSADDR(&_etext);
-	data_resource.end = CPHYSADDR(&_edata) - 1;
-#else
 	code_resource.start = virt_to_phys(&_text);
 	code_resource.end = virt_to_phys(&_etext) - 1;
 	data_resource.start = virt_to_phys(&_etext);
 	data_resource.end = virt_to_phys(&_edata) - 1;
-#endif
 
 	/*
 	 * Request address space for all standard RAM.

commit 9b6695a8adfe0916e81ddd810a5b9db3eb8b0e46
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Feb 23 12:23:27 2006 +0000

    [MIPS] SMP: Fix initialization order bug.
    
    A recent change requires cpu_possible_map to be initialized before
    smp_sched_init() but most MIPS platforms were initializing their
    processors in the prom_prepare_cpus callback of smp_prepare_cpus.  The
    simple fix of calling prom_prepare_cpus from one of the earlier SMP
    initialization hooks doesn't work well either since IPIs may require
    init_IRQ() to have completed, so bit the bullet and split
    prom_prepare_cpus into two initialization functions, plat_smp_setup
    which is called early from setup_arch and plat_prepare_cpus called where
    prom_prepare_cpus used to be called.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index d86affa21278..d9293c558e41 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -540,6 +540,9 @@ void __init setup_arch(char **cmdline_p)
 	sparse_init();
 	paging_init();
 	resource_init();
+#ifdef CONFIG_SMP
+	plat_smp_setup();
+#endif
 }
 
 int __init fpu_disable(char *s)

commit ec74e361f1e71a2498e48b62abdc4bd8d2423354
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Jul 13 11:48:45 2005 +0000

    Mark a few variables __read_mostly.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 9253dccefd07..d86affa21278 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -37,12 +37,13 @@
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
+#include <asm/cache.h>
 #include <asm/cpu.h>
 #include <asm/sections.h>
 #include <asm/setup.h>
 #include <asm/system.h>
 
-struct cpuinfo_mips cpu_data[NR_CPUS];
+struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
 EXPORT_SYMBOL(cpu_data);
 
@@ -62,8 +63,8 @@ EXPORT_SYMBOL(PCI_DMA_BUS_IS_PHYS);
  *
  * These are initialized so they are in the .data section
  */
-unsigned long mips_machtype = MACH_UNKNOWN;
-unsigned long mips_machgroup = MACH_GROUP_UNKNOWN;
+unsigned long mips_machtype __read_mostly = MACH_UNKNOWN;
+unsigned long mips_machgroup __read_mostly = MACH_GROUP_UNKNOWN;
 
 EXPORT_SYMBOL(mips_machtype);
 EXPORT_SYMBOL(mips_machgroup);
@@ -77,7 +78,7 @@ static char command_line[CL_SIZE];
  * mips_io_port_base is the begin of the address space to which x86 style
  * I/O ports are mapped.
  */
-const unsigned long mips_io_port_base = -1;
+const unsigned long mips_io_port_base __read_mostly = -1;
 EXPORT_SYMBOL(mips_io_port_base);
 
 /*

commit e50c0a8fa60da9ac0e0a70caa8a3a803815c1f2f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 31 11:49:19 2005 +0000

    Support the MIPS32 / MIPS64 DSP ASE.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 6fc51b298304..9253dccefd07 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -549,3 +549,12 @@ int __init fpu_disable(char *s)
 }
 
 __setup("nofpu", fpu_disable);
+
+int __init dsp_disable(char *s)
+{
+	cpu_data[0].ases &= ~MIPS_ASE_DSP;
+
+	return 1;
+}
+
+__setup("nodsp", dsp_disable);

commit c83cfc9c9477d0bc0e0a1ba29dfc58e0d42b2faf
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jun 21 13:56:30 2005 +0000

    Get rid of early_init.  There's more need to make this form of
    initialization actually useful and as is certainly unmergable with
    upstream.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 12b531c295c4..6fc51b298304 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -510,31 +510,7 @@ static inline void resource_init(void)
 #undef MAXMEM
 #undef MAXMEM_PFN
 
-static int __initdata earlyinit_debug;
-
-static int __init earlyinit_debug_setup(char *str)
-{
-	earlyinit_debug = 1;
-	return 1;
-}
-__setup("earlyinit_debug", earlyinit_debug_setup);
-
-extern initcall_t __earlyinitcall_start, __earlyinitcall_end;
-
-static void __init do_earlyinitcalls(void)
-{
-	initcall_t *call, *start, *end;
-
-	start = &__earlyinitcall_start;
-	end = &__earlyinitcall_end;
-
-	for (call = start; call < end; call++) {
-		if (earlyinit_debug)
-			printk("calling earlyinitcall 0x%p\n", *call);
-
-		(*call)();
-	}
-}
+extern void plat_setup(void);
 
 void __init setup_arch(char **cmdline_p)
 {
@@ -551,7 +527,7 @@ void __init setup_arch(char **cmdline_p)
 #endif
 
 	/* call board setup routine */
-	do_earlyinitcalls();
+	plat_setup();
 
 	strlcpy(command_line, arcs_cmdline, sizeof(command_line));
 	strlcpy(saved_command_line, command_line, COMMAND_LINE_SIZE);

commit 875d43e72b5bf22161a81de7554f88eccf8a51ae
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Sep 3 15:56:16 2005 -0700

    [PATCH] mips: clean up 32/64-bit configuration
    
    Start cleaning 32-bit vs. 64-bit configuration.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 3a240e3e004c..12b531c295c4 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -241,7 +241,7 @@ static inline int parse_rd_cmdline(unsigned long* rd_start, unsigned long* rd_en
 	if (*tmp)
 		strcat(command_line, tmp);
 
-#ifdef CONFIG_MIPS64
+#ifdef CONFIG_64BIT
 	/* HACK: Guess if the sign extension was forgotten */
 	if (start > 0x0000000080000000 && start < 0x00000000ffffffff)
 		start |= 0xffffffff00000000;
@@ -446,7 +446,7 @@ static inline void resource_init(void)
 {
 	int i;
 
-#if defined(CONFIG_MIPS64) && !defined(CONFIG_BUILD_ELF64)
+#if defined(CONFIG_64BIT) && !defined(CONFIG_BUILD_ELF64)
 	/*
 	 * The 64bit code in 32bit object format trick can't represent
 	 * 64bit wide relocations for linker script symbols.

commit b4819b593740a6d11db07b52e0fe35975b29a185
Author: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
Date:   Sat Jun 25 14:54:31 2005 -0700

    [PATCH] mips: add MIPS-specific support for flatmem/discontigmem
    
    2.6.12-git6 doesn't boot on some MIPS machines.  They need the support of flat
    memory and discontig memory.
    
    Signed-off-by: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
index 6018ca25aceb..3a240e3e004c 100644
--- a/arch/mips/kernel/setup.c
+++ b/arch/mips/kernel/setup.c
@@ -33,6 +33,7 @@
 #include <linux/root_dev.h>
 #include <linux/highmem.h>
 #include <linux/console.h>
+#include <linux/mmzone.h>
 
 #include <asm/addrspace.h>
 #include <asm/bootinfo.h>
@@ -356,6 +357,8 @@ static inline void bootmem_init(void)
 	}
 #endif
 
+	memory_present(0, first_usable_pfn, max_low_pfn);
+
 	/* Initialize the boot-time allocator with low memory only.  */
 	bootmap_size = init_bootmem(first_usable_pfn, max_low_pfn);
 
@@ -557,6 +560,7 @@ void __init setup_arch(char **cmdline_p)
 
 	parse_cmdline_early();
 	bootmem_init();
+	sparse_init();
 	paging_init();
 	resource_init();
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/kernel/setup.c b/arch/mips/kernel/setup.c
new file mode 100644
index 000000000000..6018ca25aceb
--- /dev/null
+++ b/arch/mips/kernel/setup.c
@@ -0,0 +1,571 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1995 Linus Torvalds
+ * Copyright (C) 1995 Waldorf Electronics
+ * Copyright (C) 1994, 95, 96, 97, 98, 99, 2000, 01, 02, 03  Ralf Baechle
+ * Copyright (C) 1996 Stoned Elipot
+ * Copyright (C) 1999 Silicon Graphics, Inc.
+ * Copyright (C) 2000 2001, 2002  Maciej W. Rozycki
+ */
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/module.h>
+#include <linux/stddef.h>
+#include <linux/string.h>
+#include <linux/unistd.h>
+#include <linux/slab.h>
+#include <linux/user.h>
+#include <linux/utsname.h>
+#include <linux/a.out.h>
+#include <linux/tty.h>
+#include <linux/bootmem.h>
+#include <linux/initrd.h>
+#include <linux/major.h>
+#include <linux/kdev_t.h>
+#include <linux/root_dev.h>
+#include <linux/highmem.h>
+#include <linux/console.h>
+
+#include <asm/addrspace.h>
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/sections.h>
+#include <asm/setup.h>
+#include <asm/system.h>
+
+struct cpuinfo_mips cpu_data[NR_CPUS];
+
+EXPORT_SYMBOL(cpu_data);
+
+#ifdef CONFIG_VT
+struct screen_info screen_info;
+#endif
+
+/*
+ * Despite it's name this variable is even if we don't have PCI
+ */
+unsigned int PCI_DMA_BUS_IS_PHYS;
+
+EXPORT_SYMBOL(PCI_DMA_BUS_IS_PHYS);
+
+/*
+ * Setup information
+ *
+ * These are initialized so they are in the .data section
+ */
+unsigned long mips_machtype = MACH_UNKNOWN;
+unsigned long mips_machgroup = MACH_GROUP_UNKNOWN;
+
+EXPORT_SYMBOL(mips_machtype);
+EXPORT_SYMBOL(mips_machgroup);
+
+struct boot_mem_map boot_mem_map;
+
+static char command_line[CL_SIZE];
+       char arcs_cmdline[CL_SIZE]=CONFIG_CMDLINE;
+
+/*
+ * mips_io_port_base is the begin of the address space to which x86 style
+ * I/O ports are mapped.
+ */
+const unsigned long mips_io_port_base = -1;
+EXPORT_SYMBOL(mips_io_port_base);
+
+/*
+ * isa_slot_offset is the address where E(ISA) busaddress 0 is mapped
+ * for the processor.
+ */
+unsigned long isa_slot_offset;
+EXPORT_SYMBOL(isa_slot_offset);
+
+static struct resource code_resource = { .name = "Kernel code", };
+static struct resource data_resource = { .name = "Kernel data", };
+
+void __init add_memory_region(phys_t start, phys_t size, long type)
+{
+	int x = boot_mem_map.nr_map;
+	struct boot_mem_map_entry *prev = boot_mem_map.map + x - 1;
+
+	/*
+	 * Try to merge with previous entry if any.  This is far less than
+	 * perfect but is sufficient for most real world cases.
+	 */
+	if (x && prev->addr + prev->size == start && prev->type == type) {
+		prev->size += size;
+		return;
+	}
+
+	if (x == BOOT_MEM_MAP_MAX) {
+		printk("Ooops! Too many entries in the memory map!\n");
+		return;
+	}
+
+	boot_mem_map.map[x].addr = start;
+	boot_mem_map.map[x].size = size;
+	boot_mem_map.map[x].type = type;
+	boot_mem_map.nr_map++;
+}
+
+static void __init print_memory_map(void)
+{
+	int i;
+	const int field = 2 * sizeof(unsigned long);
+
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		printk(" memory: %0*Lx @ %0*Lx ",
+		       field, (unsigned long long) boot_mem_map.map[i].size,
+		       field, (unsigned long long) boot_mem_map.map[i].addr);
+
+		switch (boot_mem_map.map[i].type) {
+		case BOOT_MEM_RAM:
+			printk("(usable)\n");
+			break;
+		case BOOT_MEM_ROM_DATA:
+			printk("(ROM data)\n");
+			break;
+		case BOOT_MEM_RESERVED:
+			printk("(reserved)\n");
+			break;
+		default:
+			printk("type %lu\n", boot_mem_map.map[i].type);
+			break;
+		}
+	}
+}
+
+static inline void parse_cmdline_early(void)
+{
+	char c = ' ', *to = command_line, *from = saved_command_line;
+	unsigned long start_at, mem_size;
+	int len = 0;
+	int usermem = 0;
+
+	printk("Determined physical RAM map:\n");
+	print_memory_map();
+
+	for (;;) {
+		/*
+		 * "mem=XXX[kKmM]" defines a memory region from
+		 * 0 to <XXX>, overriding the determined size.
+		 * "mem=XXX[KkmM]@YYY[KkmM]" defines a memory region from
+		 * <YYY> to <YYY>+<XXX>, overriding the determined size.
+		 */
+		if (c == ' ' && !memcmp(from, "mem=", 4)) {
+			if (to != command_line)
+				to--;
+			/*
+			 * If a user specifies memory size, we
+			 * blow away any automatically generated
+			 * size.
+			 */
+			if (usermem == 0) {
+				boot_mem_map.nr_map = 0;
+				usermem = 1;
+			}
+			mem_size = memparse(from + 4, &from);
+			if (*from == '@')
+				start_at = memparse(from + 1, &from);
+			else
+				start_at = 0;
+			add_memory_region(start_at, mem_size, BOOT_MEM_RAM);
+		}
+		c = *(from++);
+		if (!c)
+			break;
+		if (CL_SIZE <= ++len)
+			break;
+		*(to++) = c;
+	}
+	*to = '\0';
+
+	if (usermem) {
+		printk("User-defined physical RAM map:\n");
+		print_memory_map();
+	}
+}
+
+static inline int parse_rd_cmdline(unsigned long* rd_start, unsigned long* rd_end)
+{
+	/*
+	 * "rd_start=0xNNNNNNNN" defines the memory address of an initrd
+	 * "rd_size=0xNN" it's size
+	 */
+	unsigned long start = 0;
+	unsigned long size = 0;
+	unsigned long end;
+	char cmd_line[CL_SIZE];
+	char *start_str;
+	char *size_str;
+	char *tmp;
+
+	strcpy(cmd_line, command_line);
+	*command_line = 0;
+	tmp = cmd_line;
+	/* Ignore "rd_start=" strings in other parameters. */
+	start_str = strstr(cmd_line, "rd_start=");
+	if (start_str && start_str != cmd_line && *(start_str - 1) != ' ')
+		start_str = strstr(start_str, " rd_start=");
+	while (start_str) {
+		if (start_str != cmd_line)
+			strncat(command_line, tmp, start_str - tmp);
+		start = memparse(start_str + 9, &start_str);
+		tmp = start_str + 1;
+		start_str = strstr(start_str, " rd_start=");
+	}
+	if (*tmp)
+		strcat(command_line, tmp);
+
+	strcpy(cmd_line, command_line);
+	*command_line = 0;
+	tmp = cmd_line;
+	/* Ignore "rd_size" strings in other parameters. */
+	size_str = strstr(cmd_line, "rd_size=");
+	if (size_str && size_str != cmd_line && *(size_str - 1) != ' ')
+		size_str = strstr(size_str, " rd_size=");
+	while (size_str) {
+		if (size_str != cmd_line)
+			strncat(command_line, tmp, size_str - tmp);
+		size = memparse(size_str + 8, &size_str);
+		tmp = size_str + 1;
+		size_str = strstr(size_str, " rd_size=");
+	}
+	if (*tmp)
+		strcat(command_line, tmp);
+
+#ifdef CONFIG_MIPS64
+	/* HACK: Guess if the sign extension was forgotten */
+	if (start > 0x0000000080000000 && start < 0x00000000ffffffff)
+		start |= 0xffffffff00000000;
+#endif
+
+	end = start + size;
+	if (start && end) {
+		*rd_start = start;
+		*rd_end = end;
+		return 1;
+	}
+	return 0;
+}
+
+#define PFN_UP(x)	(((x) + PAGE_SIZE - 1) >> PAGE_SHIFT)
+#define PFN_DOWN(x)	((x) >> PAGE_SHIFT)
+#define PFN_PHYS(x)	((x) << PAGE_SHIFT)
+
+#define MAXMEM		HIGHMEM_START
+#define MAXMEM_PFN	PFN_DOWN(MAXMEM)
+
+static inline void bootmem_init(void)
+{
+	unsigned long start_pfn;
+	unsigned long reserved_end = (unsigned long)&_end;
+#ifndef CONFIG_SGI_IP27
+	unsigned long first_usable_pfn;
+	unsigned long bootmap_size;
+	int i;
+#endif
+#ifdef CONFIG_BLK_DEV_INITRD
+	int initrd_reserve_bootmem = 0;
+
+	/* Board specific code should have set up initrd_start and initrd_end */
+ 	ROOT_DEV = Root_RAM0;
+	if (parse_rd_cmdline(&initrd_start, &initrd_end)) {
+		reserved_end = max(reserved_end, initrd_end);
+		initrd_reserve_bootmem = 1;
+	} else {
+		unsigned long tmp;
+		u32 *initrd_header;
+
+		tmp = ((reserved_end + PAGE_SIZE-1) & PAGE_MASK) - sizeof(u32) * 2;
+		if (tmp < reserved_end)
+			tmp += PAGE_SIZE;
+		initrd_header = (u32 *)tmp;
+		if (initrd_header[0] == 0x494E5244) {
+			initrd_start = (unsigned long)&initrd_header[2];
+			initrd_end = initrd_start + initrd_header[1];
+			reserved_end = max(reserved_end, initrd_end);
+			initrd_reserve_bootmem = 1;
+		}
+	}
+#endif	/* CONFIG_BLK_DEV_INITRD */
+
+	/*
+	 * Partially used pages are not usable - thus
+	 * we are rounding upwards.
+	 */
+	start_pfn = PFN_UP(CPHYSADDR(reserved_end));
+
+#ifndef CONFIG_SGI_IP27
+	/* Find the highest page frame number we have available.  */
+	max_pfn = 0;
+	first_usable_pfn = -1UL;
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		unsigned long start, end;
+
+		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
+			continue;
+
+		start = PFN_UP(boot_mem_map.map[i].addr);
+		end = PFN_DOWN(boot_mem_map.map[i].addr
+		      + boot_mem_map.map[i].size);
+
+		if (start >= end)
+			continue;
+		if (end > max_pfn)
+			max_pfn = end;
+		if (start < first_usable_pfn) {
+			if (start > start_pfn) {
+				first_usable_pfn = start;
+			} else if (end > start_pfn) {
+				first_usable_pfn = start_pfn;
+			}
+		}
+	}
+
+	/*
+	 * Determine low and high memory ranges
+	 */
+	max_low_pfn = max_pfn;
+	if (max_low_pfn > MAXMEM_PFN) {
+		max_low_pfn = MAXMEM_PFN;
+#ifndef CONFIG_HIGHMEM
+		/* Maximum memory usable is what is directly addressable */
+		printk(KERN_WARNING "Warning only %ldMB will be used.\n",
+		       MAXMEM >> 20);
+		printk(KERN_WARNING "Use a HIGHMEM enabled kernel.\n");
+#endif
+	}
+
+#ifdef CONFIG_HIGHMEM
+	/*
+	 * Crude, we really should make a better attempt at detecting
+	 * highstart_pfn
+	 */
+	highstart_pfn = highend_pfn = max_pfn;
+	if (max_pfn > MAXMEM_PFN) {
+		highstart_pfn = MAXMEM_PFN;
+		printk(KERN_NOTICE "%ldMB HIGHMEM available.\n",
+		       (highend_pfn - highstart_pfn) >> (20 - PAGE_SHIFT));
+	}
+#endif
+
+	/* Initialize the boot-time allocator with low memory only.  */
+	bootmap_size = init_bootmem(first_usable_pfn, max_low_pfn);
+
+	/*
+	 * Register fully available low RAM pages with the bootmem allocator.
+	 */
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		unsigned long curr_pfn, last_pfn, size;
+
+		/*
+		 * Reserve usable memory.
+		 */
+		if (boot_mem_map.map[i].type != BOOT_MEM_RAM)
+			continue;
+
+		/*
+		 * We are rounding up the start address of usable memory:
+		 */
+		curr_pfn = PFN_UP(boot_mem_map.map[i].addr);
+		if (curr_pfn >= max_low_pfn)
+			continue;
+		if (curr_pfn < start_pfn)
+			curr_pfn = start_pfn;
+
+		/*
+		 * ... and at the end of the usable range downwards:
+		 */
+		last_pfn = PFN_DOWN(boot_mem_map.map[i].addr
+				    + boot_mem_map.map[i].size);
+
+		if (last_pfn > max_low_pfn)
+			last_pfn = max_low_pfn;
+
+		/*
+		 * Only register lowmem part of lowmem segment with bootmem.
+		 */
+		size = last_pfn - curr_pfn;
+		if (curr_pfn > PFN_DOWN(HIGHMEM_START))
+			continue;
+		if (curr_pfn + size - 1 > PFN_DOWN(HIGHMEM_START))
+			size = PFN_DOWN(HIGHMEM_START) - curr_pfn;
+		if (!size)
+			continue;
+
+		/*
+		 * ... finally, did all the rounding and playing
+		 * around just make the area go away?
+		 */
+		if (last_pfn <= curr_pfn)
+			continue;
+
+		/* Register lowmem ranges */
+		free_bootmem(PFN_PHYS(curr_pfn), PFN_PHYS(size));
+	}
+
+	/* Reserve the bootmap memory.  */
+	reserve_bootmem(PFN_PHYS(first_usable_pfn), bootmap_size);
+#endif /* CONFIG_SGI_IP27 */
+
+#ifdef CONFIG_BLK_DEV_INITRD
+	initrd_below_start_ok = 1;
+	if (initrd_start) {
+		unsigned long initrd_size = ((unsigned char *)initrd_end) - ((unsigned char *)initrd_start);
+		printk("Initial ramdisk at: 0x%p (%lu bytes)\n",
+		       (void *)initrd_start, initrd_size);
+
+		if (CPHYSADDR(initrd_end) > PFN_PHYS(max_low_pfn)) {
+			printk("initrd extends beyond end of memory "
+			       "(0x%0*Lx > 0x%0*Lx)\ndisabling initrd\n",
+			       sizeof(long) * 2,
+			       (unsigned long long)CPHYSADDR(initrd_end),
+			       sizeof(long) * 2,
+			       (unsigned long long)PFN_PHYS(max_low_pfn));
+			initrd_start = initrd_end = 0;
+			initrd_reserve_bootmem = 0;
+		}
+
+		if (initrd_reserve_bootmem)
+			reserve_bootmem(CPHYSADDR(initrd_start), initrd_size);
+	}
+#endif /* CONFIG_BLK_DEV_INITRD  */
+}
+
+static inline void resource_init(void)
+{
+	int i;
+
+#if defined(CONFIG_MIPS64) && !defined(CONFIG_BUILD_ELF64)
+	/*
+	 * The 64bit code in 32bit object format trick can't represent
+	 * 64bit wide relocations for linker script symbols.
+	 */
+	code_resource.start = CPHYSADDR(&_text);
+	code_resource.end = CPHYSADDR(&_etext) - 1;
+	data_resource.start = CPHYSADDR(&_etext);
+	data_resource.end = CPHYSADDR(&_edata) - 1;
+#else
+	code_resource.start = virt_to_phys(&_text);
+	code_resource.end = virt_to_phys(&_etext) - 1;
+	data_resource.start = virt_to_phys(&_etext);
+	data_resource.end = virt_to_phys(&_edata) - 1;
+#endif
+
+	/*
+	 * Request address space for all standard RAM.
+	 */
+	for (i = 0; i < boot_mem_map.nr_map; i++) {
+		struct resource *res;
+		unsigned long start, end;
+
+		start = boot_mem_map.map[i].addr;
+		end = boot_mem_map.map[i].addr + boot_mem_map.map[i].size - 1;
+		if (start >= MAXMEM)
+			continue;
+		if (end >= MAXMEM)
+			end = MAXMEM - 1;
+
+		res = alloc_bootmem(sizeof(struct resource));
+		switch (boot_mem_map.map[i].type) {
+		case BOOT_MEM_RAM:
+		case BOOT_MEM_ROM_DATA:
+			res->name = "System RAM";
+			break;
+		case BOOT_MEM_RESERVED:
+		default:
+			res->name = "reserved";
+		}
+
+		res->start = start;
+		res->end = end;
+
+		res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
+		request_resource(&iomem_resource, res);
+
+		/*
+		 *  We don't know which RAM region contains kernel data,
+		 *  so we try it repeatedly and let the resource manager
+		 *  test it.
+		 */
+		request_resource(res, &code_resource);
+		request_resource(res, &data_resource);
+	}
+}
+
+#undef PFN_UP
+#undef PFN_DOWN
+#undef PFN_PHYS
+
+#undef MAXMEM
+#undef MAXMEM_PFN
+
+static int __initdata earlyinit_debug;
+
+static int __init earlyinit_debug_setup(char *str)
+{
+	earlyinit_debug = 1;
+	return 1;
+}
+__setup("earlyinit_debug", earlyinit_debug_setup);
+
+extern initcall_t __earlyinitcall_start, __earlyinitcall_end;
+
+static void __init do_earlyinitcalls(void)
+{
+	initcall_t *call, *start, *end;
+
+	start = &__earlyinitcall_start;
+	end = &__earlyinitcall_end;
+
+	for (call = start; call < end; call++) {
+		if (earlyinit_debug)
+			printk("calling earlyinitcall 0x%p\n", *call);
+
+		(*call)();
+	}
+}
+
+void __init setup_arch(char **cmdline_p)
+{
+	cpu_probe();
+	prom_init();
+	cpu_report();
+
+#if defined(CONFIG_VT)
+#if defined(CONFIG_VGA_CONSOLE)
+        conswitchp = &vga_con;
+#elif defined(CONFIG_DUMMY_CONSOLE)
+        conswitchp = &dummy_con;
+#endif
+#endif
+
+	/* call board setup routine */
+	do_earlyinitcalls();
+
+	strlcpy(command_line, arcs_cmdline, sizeof(command_line));
+	strlcpy(saved_command_line, command_line, COMMAND_LINE_SIZE);
+
+	*cmdline_p = command_line;
+
+	parse_cmdline_early();
+	bootmem_init();
+	paging_init();
+	resource_init();
+}
+
+int __init fpu_disable(char *s)
+{
+	cpu_data[0].options &= ~MIPS_CPU_FPU;
+
+	return 1;
+}
+
+__setup("nofpu", fpu_disable);
