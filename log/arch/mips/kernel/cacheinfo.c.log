commit 3b1313eb32c499d46dc4c3e896d19d9564c879c4
Author: Vladimir Kondratiev <vladimir.kondratiev@intel.com>
Date:   Sun Nov 24 16:07:31 2019 +0200

    mips: cacheinfo: report shared CPU map
    
    Report L1 caches as shared per core; L2 - per cluster.
    
    This fixes "perf" that went crazy if shared_cpu_map attribute not
    reported on sysfs, in form of
    
    /sys/devices/system/cpu/cpu*/cache/index*/shared_cpu_list
    /sys/devices/system/cpu/cpu*/cache/index*/shared_cpu_map
    
    Signed-off-by: Vladimir Kondratiev <vladimir.kondratiev@intel.com>
    Signed-off-by: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/cacheinfo.c b/arch/mips/kernel/cacheinfo.c
index f777e44653d5..47312c529410 100644
--- a/arch/mips/kernel/cacheinfo.c
+++ b/arch/mips/kernel/cacheinfo.c
@@ -50,6 +50,25 @@ static int __init_cache_level(unsigned int cpu)
 	return 0;
 }
 
+static void fill_cpumask_siblings(int cpu, cpumask_t *cpu_map)
+{
+	int cpu1;
+
+	for_each_possible_cpu(cpu1)
+		if (cpus_are_siblings(cpu, cpu1))
+			cpumask_set_cpu(cpu1, cpu_map);
+}
+
+static void fill_cpumask_cluster(int cpu, cpumask_t *cpu_map)
+{
+	int cpu1;
+	int cluster = cpu_cluster(&cpu_data[cpu]);
+
+	for_each_possible_cpu(cpu1)
+		if (cpu_cluster(&cpu_data[cpu1]) == cluster)
+			cpumask_set_cpu(cpu1, cpu_map);
+}
+
 static int __populate_cache_leaves(unsigned int cpu)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
@@ -57,14 +76,20 @@ static int __populate_cache_leaves(unsigned int cpu)
 	struct cacheinfo *this_leaf = this_cpu_ci->info_list;
 
 	if (c->icache.waysize) {
+		/* L1 caches are per core */
+		fill_cpumask_siblings(cpu, &this_leaf->shared_cpu_map);
 		populate_cache(dcache, this_leaf, 1, CACHE_TYPE_DATA);
+		fill_cpumask_siblings(cpu, &this_leaf->shared_cpu_map);
 		populate_cache(icache, this_leaf, 1, CACHE_TYPE_INST);
 	} else {
 		populate_cache(dcache, this_leaf, 1, CACHE_TYPE_UNIFIED);
 	}
 
-	if (c->scache.waysize)
+	if (c->scache.waysize) {
+		/* L2 cache is per cluster */
+		fill_cpumask_cluster(cpu, &this_leaf->shared_cpu_map);
 		populate_cache(scache, this_leaf, 2, CACHE_TYPE_UNIFIED);
+	}
 
 	if (c->tcache.waysize)
 		populate_cache(tcache, this_leaf, 3, CACHE_TYPE_UNIFIED);

commit 76d7961ff4ee02cc70365600a52fb59ca544dc7c
Merge: f4eb1423e433 74034a09267c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Aug 6 14:01:08 2019 -0700

    Merge tag 'mips_fixes_5.3_1' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux
    
    Pull MIPS fixes from Paul Burton:
     "A few MIPS fixes for 5.3:
    
       - Various switch fall through annotations to fixup warnings & errors
         resulting from -Wimplicit-fallthrough.
    
       - A fix for systems (at least jazz) using an i8253 PIT as clocksource
         when it's not suitably configured.
    
       - Set struct cacheinfo's cpu_map_populated field to true, indicating
         that we filled in cache info detected from cop0 registers &
         avoiding complaints about that info being (intentionally) missing
         in devicetree"
    
    * tag 'mips_fixes_5.3_1' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux:
      MIPS: BCM63XX: Mark expected switch fall-through
      MIPS: OProfile: Mark expected switch fall-throughs
      MIPS: Annotate fall-through in Cavium Octeon code
      MIPS: Annotate fall-through in kvm/emulate.c
      mips: fix cacheinfo
      MIPS: kernel: only use i8253 clocksource with periodic clockevent

commit b8bea8a5e5d942e62203416ab41edecaed4fda02
Author: Vladimir Kondratiev <vladimir.kondratiev@linux.intel.com>
Date:   Tue Jul 16 10:36:56 2019 +0300

    mips: fix cacheinfo
    
    Because CONFIG_OF defined for MIPS, cacheinfo attempts to fill information
    from DT, ignoring data filled by architecture routine. This leads to error
    reported
    
     cacheinfo: Unable to detect cache hierarchy for CPU 0
    
    Way to fix this provided in
    commit fac51482577d ("drivers: base: cacheinfo: fix x86 with
     CONFIG_OF enabled")
    
    Utilize same mechanism to report that cacheinfo set by architecture
    specific function
    
    Signed-off-by: Vladimir Kondratiev <vladimir.kondratiev@linux.intel.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/cacheinfo.c b/arch/mips/kernel/cacheinfo.c
index 97d5239ca47b..428ef2189203 100644
--- a/arch/mips/kernel/cacheinfo.c
+++ b/arch/mips/kernel/cacheinfo.c
@@ -80,6 +80,8 @@ static int __populate_cache_leaves(unsigned int cpu)
 	if (c->tcache.waysize)
 		populate_cache(tcache, this_leaf, 3, CACHE_TYPE_UNIFIED);
 
+	this_cpu_ci->cpu_map_populated = true;
+
 	return 0;
 }
 

commit c9af7f315d3f78c2cc81a5d600dab8c4c916996f
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Wed May 29 07:12:26 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 252
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed as is without any warranty of any kind whether express
      or implied without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not see http www gnu org
      licenses
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 2 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190529141332.617181045@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/kernel/cacheinfo.c b/arch/mips/kernel/cacheinfo.c
index 97d5239ca47b..e0dd66881da6 100644
--- a/arch/mips/kernel/cacheinfo.c
+++ b/arch/mips/kernel/cacheinfo.c
@@ -1,17 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * MIPS cacheinfo support
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- *
- * This program is distributed "as is" WITHOUT ANY WARRANTY of any
- * kind, whether express or implied; without even the implied warranty
- * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 #include <linux/cacheinfo.h>
 

commit 4828b5f56f9596f014567ceef0e5c200fb582e13
Author: James Hogan <james.hogan@imgtec.com>
Date:   Fri Feb 10 22:44:03 2017 +0000

    MIPS: Fix cacheinfo overflow
    
    The recently added MIPS cacheinfo support used a macro populate_cache()
    to populate the cacheinfo structures depending on which caches are
    present. However the macro contains multiple statements without
    enclosing them in a do {} while (0) loop, so the L2 and L3 cache
    conditionals in populate_cache_leaves() only conditionalised the first
    statement in the macro.
    
    This overflows the buffer allocated by detect_cache_attributes(),
    resulting in boot failures under QEMU where neither the L2 or L2 caches
    are present.
    
    Enclose the macro statements in a do {} while (0) block to keep the
    whole macro inside the conditionals.
    
    Fixes: ef462f3b64e9 ("MIPS: Add cacheinfo support")
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Tested-by: Guenter Roeck <linux@roeck-us.net>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Justin Chen <justin.chen@broadcom.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: bcm-kernel-feedback-list@broadcom.com
    Patchwork: https://patchwork.linux-mips.org/patch/15276/

diff --git a/arch/mips/kernel/cacheinfo.c b/arch/mips/kernel/cacheinfo.c
index a92bbbae969b..97d5239ca47b 100644
--- a/arch/mips/kernel/cacheinfo.c
+++ b/arch/mips/kernel/cacheinfo.c
@@ -17,6 +17,7 @@
 
 /* Populates leaf and increments to next leaf */
 #define populate_cache(cache, leaf, c_level, c_type)		\
+do {								\
 	leaf->type = c_type;					\
 	leaf->level = c_level;					\
 	leaf->coherency_line_size = c->cache.linesz;		\
@@ -24,7 +25,8 @@
 	leaf->ways_of_associativity = c->cache.ways;		\
 	leaf->size = c->cache.linesz * c->cache.sets *		\
 		c->cache.ways;					\
-	leaf++;
+	leaf++;							\
+} while (0)
 
 static int __init_cache_level(unsigned int cpu)
 {

commit ef462f3b64e9fb0c8e1cd5d60f5bd7f13ac2156d
Author: Justin Chen <justin.chen@broadcom.com>
Date:   Wed Dec 7 17:16:26 2016 -0800

    MIPS: Add cacheinfo support
    
    Add cacheinfo support for MIPS architectures.
    
    Use information from the cpuinfo_mips struct to populate the
    cacheinfo struct. This allows an architecture agnostic approach,
    however this also means if cache information is not properly
    populated within the cpuinfo_mips struct, there is nothing
    we can do. (I.E. c-r3k.c)
    
    Signed-off-by: Justin Chen <justin.chen@broadcom.com>
    Cc: f.fainelli@gmail.com
    Cc: linux-mips@linux-mips.org
    Cc: bcm-kernel-feedback-list@broadcom.com
    Patchwork: https://patchwork.linux-mips.org/patch/14650/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/cacheinfo.c b/arch/mips/kernel/cacheinfo.c
new file mode 100644
index 000000000000..a92bbbae969b
--- /dev/null
+++ b/arch/mips/kernel/cacheinfo.c
@@ -0,0 +1,85 @@
+/*
+ * MIPS cacheinfo support
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed "as is" WITHOUT ANY WARRANTY of any
+ * kind, whether express or implied; without even the implied warranty
+ * of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+#include <linux/cacheinfo.h>
+
+/* Populates leaf and increments to next leaf */
+#define populate_cache(cache, leaf, c_level, c_type)		\
+	leaf->type = c_type;					\
+	leaf->level = c_level;					\
+	leaf->coherency_line_size = c->cache.linesz;		\
+	leaf->number_of_sets = c->cache.sets;			\
+	leaf->ways_of_associativity = c->cache.ways;		\
+	leaf->size = c->cache.linesz * c->cache.sets *		\
+		c->cache.ways;					\
+	leaf++;
+
+static int __init_cache_level(unsigned int cpu)
+{
+	struct cpuinfo_mips *c = &current_cpu_data;
+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
+	int levels = 0, leaves = 0;
+
+	/*
+	 * If Dcache is not set, we assume the cache structures
+	 * are not properly initialized.
+	 */
+	if (c->dcache.waysize)
+		levels += 1;
+	else
+		return -ENOENT;
+
+
+	leaves += (c->icache.waysize) ? 2 : 1;
+
+	if (c->scache.waysize) {
+		levels++;
+		leaves++;
+	}
+
+	if (c->tcache.waysize) {
+		levels++;
+		leaves++;
+	}
+
+	this_cpu_ci->num_levels = levels;
+	this_cpu_ci->num_leaves = leaves;
+	return 0;
+}
+
+static int __populate_cache_leaves(unsigned int cpu)
+{
+	struct cpuinfo_mips *c = &current_cpu_data;
+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);
+	struct cacheinfo *this_leaf = this_cpu_ci->info_list;
+
+	if (c->icache.waysize) {
+		populate_cache(dcache, this_leaf, 1, CACHE_TYPE_DATA);
+		populate_cache(icache, this_leaf, 1, CACHE_TYPE_INST);
+	} else {
+		populate_cache(dcache, this_leaf, 1, CACHE_TYPE_UNIFIED);
+	}
+
+	if (c->scache.waysize)
+		populate_cache(scache, this_leaf, 2, CACHE_TYPE_UNIFIED);
+
+	if (c->tcache.waysize)
+		populate_cache(tcache, this_leaf, 3, CACHE_TYPE_UNIFIED);
+
+	return 0;
+}
+
+DEFINE_SMP_CALL_CACHE_FUNCTION(init_cache_level)
+DEFINE_SMP_CALL_CACHE_FUNCTION(populate_cache_leaves)
