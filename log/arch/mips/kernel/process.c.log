commit e31cf2f4ca422ac9b14ecc4a1295b8977a20f812
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:33 2020 -0700

    mm: don't include asm/pgtable.h if linux/mm.h is already included
    
    Patch series "mm: consolidate definitions of page table accessors", v2.
    
    The low level page table accessors (pXY_index(), pXY_offset()) are
    duplicated across all architectures and sometimes more than once.  For
    instance, we have 31 definition of pgd_offset() for 25 supported
    architectures.
    
    Most of these definitions are actually identical and typically it boils
    down to, e.g.
    
    static inline unsigned long pmd_index(unsigned long address)
    {
            return (address >> PMD_SHIFT) & (PTRS_PER_PMD - 1);
    }
    
    static inline pmd_t *pmd_offset(pud_t *pud, unsigned long address)
    {
            return (pmd_t *)pud_page_vaddr(*pud) + pmd_index(address);
    }
    
    These definitions can be shared among 90% of the arches provided
    XYZ_SHIFT, PTRS_PER_XYZ and xyz_page_vaddr() are defined.
    
    For architectures that really need a custom version there is always
    possibility to override the generic version with the usual ifdefs magic.
    
    These patches introduce include/linux/pgtable.h that replaces
    include/asm-generic/pgtable.h and add the definitions of the page table
    accessors to the new header.
    
    This patch (of 12):
    
    The linux/mm.h header includes <asm/pgtable.h> to allow inlining of the
    functions involving page table manipulations, e.g.  pte_alloc() and
    pmd_alloc().  So, there is no point to explicitly include <asm/pgtable.h>
    in the files that include <linux/mm.h>.
    
    The include statements in such cases are remove with a simple loop:
    
            for f in $(git grep -l "include <linux/mm.h>") ; do
                    sed -i -e '/include <asm\/pgtable.h>/ d' $f
            done
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Mike Rapoport <rppt@kernel.org>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-1-rppt@kernel.org
    Link: http://lkml.kernel.org/r/20200514170327.31389-2-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index b2a797557825..ff5320b79100 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -42,7 +42,6 @@
 #include <asm/irq.h>
 #include <asm/mips-cps.h>
 #include <asm/msa.h>
-#include <asm/pgtable.h>
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
 #include <asm/reg.h>

commit aebdc6ff3b2e79327d8eff7c0e2d835bb1d3221f
Author: Yousong Zhou <yszhou4tech@gmail.com>
Date:   Tue Mar 24 23:27:51 2020 +0800

    MIPS: Exclude more dsemul code when CONFIG_MIPS_FP_SUPPORT=n
    
    This furthers what commit 42b10815d559 ("MIPS: Don't compile math-emu
    when CONFIG_MIPS_FP_SUPPORT=n") has done
    
    Signed-off-by: Yousong Zhou <yszhou4tech@gmail.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 339870ed92f7..b2a797557825 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -75,7 +75,9 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 	lose_fpu(0);
 	clear_thread_flag(TIF_MSA_CTX_LIVE);
 	clear_used_math();
+#ifdef CONFIG_MIPS_FP_SUPPORT
 	atomic_set(&current->thread.bd_emu_frame, BD_EMUFRAME_NONE);
+#endif
 	init_dsp();
 	regs->cp0_epc = pc;
 	regs->regs[29] = sp;
@@ -176,7 +178,9 @@ int copy_thread_tls(unsigned long clone_flags, unsigned long usp,
 	clear_tsk_thread_flag(p, TIF_FPUBOUND);
 #endif /* CONFIG_MIPS_MT_FPAFF */
 
+#ifdef CONFIG_MIPS_FP_SUPPORT
 	atomic_set(&p->thread.bd_emu_frame, BD_EMUFRAME_NONE);
+#endif
 
 	if (clone_flags & CLONE_SETTLS)
 		ti->tp_value = tls;
@@ -650,8 +654,10 @@ unsigned long mips_stack_top(void)
 {
 	unsigned long top = TASK_SIZE & PAGE_MASK;
 
-	/* One page for branch delay slot "emulation" */
-	top -= PAGE_SIZE;
+	if (IS_ENABLED(CONFIG_MIPS_FP_SUPPORT)) {
+		/* One page for branch delay slot "emulation" */
+		top -= PAGE_SIZE;
+	}
 
 	/* Space for the VDSO, data page & GIC user page */
 	top -= PAGE_ALIGN(current->thread.abi->vdso->size);

commit 2b424cfc69728224fcb5fad138ea7260728e0901
Author: Jun-Ru Chang <jrjang@realtek.com>
Date:   Tue Jan 29 11:56:07 2019 +0800

    MIPS: Remove function size check in get_frame_info()
    
    Patch (b6c7a324df37b "MIPS: Fix get_frame_info() handling of
    microMIPS function size.") introduces additional function size
    check for microMIPS by only checking insn between ip and ip + func_size.
    However, func_size in get_frame_info() is always 0 if KALLSYMS is not
    enabled. This causes get_frame_info() to return immediately without
    calculating correct frame_size, which in turn causes "Can't analyze
    schedule() prologue" warning messages at boot time.
    
    This patch removes func_size check, and let the frame_size check run
    up to 128 insns for both MIPS and microMIPS.
    
    Signed-off-by: Jun-Ru Chang <jrjang@realtek.com>
    Signed-off-by: Tony Wu <tonywu@realtek.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Fixes: b6c7a324df37b ("MIPS: Fix get_frame_info() handling of microMIPS function size.")
    Cc: <ralf@linux-mips.org>
    Cc: <jhogan@kernel.org>
    Cc: <macro@mips.com>
    Cc: <yamada.masahiro@socionext.com>
    Cc: <peterz@infradead.org>
    Cc: <mingo@kernel.org>
    Cc: <linux-mips@vger.kernel.org>
    Cc: <linux-kernel@vger.kernel.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 6829a064aac8..339870ed92f7 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -371,7 +371,7 @@ static inline int is_sp_move_ins(union mips_instruction *ip, int *frame_size)
 static int get_frame_info(struct mips_frame_info *info)
 {
 	bool is_mmips = IS_ENABLED(CONFIG_CPU_MICROMIPS);
-	union mips_instruction insn, *ip, *ip_end;
+	union mips_instruction insn, *ip;
 	const unsigned int max_insns = 128;
 	unsigned int last_insn_size = 0;
 	unsigned int i;
@@ -384,10 +384,9 @@ static int get_frame_info(struct mips_frame_info *info)
 	if (!ip)
 		goto err;
 
-	ip_end = (void *)ip + info->func_size;
-
-	for (i = 0; i < max_insns && ip < ip_end; i++) {
+	for (i = 0; i < max_insns; i++) {
 		ip = (void *)ip + last_insn_size;
+
 		if (is_mmips && mm_insn_16bit(ip->halfword[0])) {
 			insn.word = ip->halfword[0] << 16;
 			last_insn_size = 2;

commit 41e486f4f66d3e646fedd60469bc60e73662de50
Author: Paul Burton <paul.burton@mips.com>
Date:   Mon Dec 17 22:05:40 2018 -0800

    MIPS: Remove struct mm_context_t fp_mode_switching field
    
    The fp_mode_switching field in struct mm_context_t was left unused by
    commit 8c8d953c2800 ("MIPS: Schedule on CPUs we need to lose FPU for a
    mode switch") in v4.19, with nothing modifying its value & nothing
    waiting on it having any particular value after that commit. Remove the
    unused field & the one remaining reference to it.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index d4f7fd4550e1..6829a064aac8 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -737,10 +737,9 @@ static long prepare_for_fp_mode_switch(void *unused)
 	/*
 	 * This is icky, but we use this to simply ensure that all CPUs have
 	 * context switched, regardless of whether they were previously running
-	 * kernel or user code. This ensures that no CPU currently has its FPU
-	 * enabled, or is about to attempt to enable it through any path other
-	 * than enable_restore_fp_context() which will wait appropriately for
-	 * fp_mode_switching to be zero.
+	 * kernel or user code. This ensures that no CPU that a mode-switching
+	 * program may execute on keeps its FPU enabled (& in the old mode)
+	 * throughout the mode switch.
 	 */
 	return 0;
 }
@@ -829,8 +828,6 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 		work_on_cpu(cpu, prepare_for_fp_mode_switch, NULL);
 	put_online_cpus();
 
-	wake_up_var(&task->mm->context.fp_mode_switching);
-
 	return 0;
 }
 

commit ea7e0480a4b695d0aa6b3fa99bd658a003122113
Author: Paul Burton <paul.burton@mips.com>
Date:   Tue Sep 25 15:51:26 2018 -0700

    MIPS: VDSO: Always map near top of user memory
    
    When using the legacy mmap layout, for example triggered using ulimit -s
    unlimited, get_unmapped_area() fills memory from bottom to top starting
    from a fairly low address near TASK_UNMAPPED_BASE.
    
    This placement is suboptimal if the user application wishes to allocate
    large amounts of heap memory using the brk syscall. With the VDSO being
    located low in the user's virtual address space, the amount of space
    available for access using brk is limited much more than it was prior to
    the introduction of the VDSO.
    
    For example:
    
      # ulimit -s unlimited; cat /proc/self/maps
      00400000-004ec000 r-xp 00000000 08:00 71436      /usr/bin/coreutils
      004fc000-004fd000 rwxp 000ec000 08:00 71436      /usr/bin/coreutils
      004fd000-0050f000 rwxp 00000000 00:00 0
      00cc3000-00ce4000 rwxp 00000000 00:00 0          [heap]
      2ab96000-2ab98000 r--p 00000000 00:00 0          [vvar]
      2ab98000-2ab99000 r-xp 00000000 00:00 0          [vdso]
      2ab99000-2ab9d000 rwxp 00000000 00:00 0
      ...
    
    Resolve this by adjusting STACK_TOP to reserve space for the VDSO &
    providing an address hint to get_unmapped_area() causing it to use this
    space even when using the legacy mmap layout.
    
    We reserve enough space for the VDSO, plus 1MB or 256MB for 32 bit & 64
    bit systems respectively within which we randomize the VDSO base
    address. Previously this randomization was taken care of by the mmap
    base address randomization performed by arch_mmap_rnd(). The 1MB & 256MB
    sizes are somewhat arbitrary but chosen such that we have some
    randomization without taking up too much of the user's virtual address
    space, which is often in short supply for 32 bit systems.
    
    With this the VDSO is always mapped at a high address, leaving lots of
    space for statically linked programs to make use of brk:
    
      # ulimit -s unlimited; cat /proc/self/maps
      00400000-004ec000 r-xp 00000000 08:00 71436      /usr/bin/coreutils
      004fc000-004fd000 rwxp 000ec000 08:00 71436      /usr/bin/coreutils
      004fd000-0050f000 rwxp 00000000 00:00 0
      00c28000-00c49000 rwxp 00000000 00:00 0          [heap]
      ...
      7f67c000-7f69d000 rwxp 00000000 00:00 0          [stack]
      7f7fc000-7f7fd000 rwxp 00000000 00:00 0
      7fcf1000-7fcf3000 r--p 00000000 00:00 0          [vvar]
      7fcf3000-7fcf4000 r-xp 00000000 00:00 0          [vdso]
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Reported-by: Huacai Chen <chenhc@lemote.com>
    Fixes: ebb5e78cc634 ("MIPS: Initial implementation of a VDSO")
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org # v4.4+

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 8fc69891e117..d4f7fd4550e1 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -32,6 +32,7 @@
 #include <linux/nmi.h>
 #include <linux/cpu.h>
 
+#include <asm/abi.h>
 #include <asm/asm.h>
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
@@ -39,6 +40,7 @@
 #include <asm/dsp.h>
 #include <asm/fpu.h>
 #include <asm/irq.h>
+#include <asm/mips-cps.h>
 #include <asm/msa.h>
 #include <asm/pgtable.h>
 #include <asm/mipsregs.h>
@@ -645,6 +647,29 @@ unsigned long get_wchan(struct task_struct *task)
 	return pc;
 }
 
+unsigned long mips_stack_top(void)
+{
+	unsigned long top = TASK_SIZE & PAGE_MASK;
+
+	/* One page for branch delay slot "emulation" */
+	top -= PAGE_SIZE;
+
+	/* Space for the VDSO, data page & GIC user page */
+	top -= PAGE_ALIGN(current->thread.abi->vdso->size);
+	top -= PAGE_SIZE;
+	top -= mips_gic_present() ? PAGE_SIZE : 0;
+
+	/* Space for cache colour alignment */
+	if (cpu_has_dc_aliases)
+		top -= shm_align_mask + 1;
+
+	/* Space to randomize the VDSO base */
+	if (current->flags & PF_RANDOMIZE)
+		top -= VDSO_RANDOMIZE_SIZE;
+
+	return top;
+}
+
 /*
  * Don't forget that the stack pointer must be aligned on a 8 bytes
  * boundary for 32-bits ABI and 16 bytes for 64-bits ABI.

commit e5a32b5b21a18d24e9d735891550c194b4c60bd2
Merge: 2280a5360e4f 22f20a110321
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Aug 13 19:24:32 2018 -0700

    Merge tag 'mips_4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux
    
    Pull MIPS updates from Paul Burton:
     "Here are the main MIPS changes for 4.19.
    
      An overview of the general architecture changes:
    
       - Massive DMA ops refactoring from Christoph Hellwig (huzzah for
         deleting crufty code!).
    
       - We introduce NT_MIPS_DSP & NT_MIPS_FP_MODE ELF notes &
         corresponding regsets to expose DSP ASE & floating point mode state
         respectively, both for live debugging & core dumps.
    
       - We better optimize our code by hard-coding cpu_has_* macros at
         compile time where their values are known due to the ISA revision
         that the kernel build is targeting.
    
       - The EJTAG exception handler now better handles SMP systems, where
         it was previously possible for CPUs to clobber a register value
         saved by another CPU.
    
       - Our implementation of memset() gained a couple of fixes for MIPSr6
         systems to return correct values in some cases where stores fault.
    
       - We now implement ioremap_wc() using the uncached-accelerated cache
         coherency attribute where supported, which is detected during boot,
         and fall back to plain uncached access where necessary. The
         MIPS-specific (and unused in tree) ioremap_uncached_accelerated() &
         ioremap_cacheable_cow() are removed.
    
       - The prctl(PR_SET_FP_MODE, ...) syscall is better supported for SMP
         systems by reworking the way we ensure remote CPUs that may be
         running threads within the affected process switch mode.
    
       - Systems using the MIPS Coherence Manager will now set the
         MIPS_IC_SNOOPS_REMOTE flag to avoid some unnecessary cache
         maintenance overhead when flushing the icache.
    
       - A few fixes were made for building with clang/LLVM, which now
         sucessfully builds kernels for many of our platforms.
    
       - Miscellaneous cleanups all over.
    
      And some platform-specific changes:
    
       - ar7 gained stubs for a few clock API functions to fix build
         failures for some drivers.
    
       - ath79 gained support for a few new SoCs, a few fixes & better
         gpio-keys support.
    
       - Ci20 now exposes its SPI bus using the spi-gpio driver.
    
       - The generic platform can now auto-detect a suitable value for
         PHYS_OFFSET based upon the memory map described by the device tree,
         allowing us to avoid wasting memory on page book-keeping for
         systems where RAM starts at a non-zero physical address.
    
       - Ingenic systems using the jz4740 platform code now link their
         vmlinuz higher to allow for kernels of a realistic size.
    
       - Loongson32 now builds the kernel targeting MIPSr1 rather than
         MIPSr2 to avoid CPU errata.
    
       - Loongson64 gains a couple of fixes, a workaround for a write
         buffering issue & support for the Loongson 3A R3.1 CPU.
    
       - Malta now uses the piix4-poweroff driver to handle powering down.
    
       - Microsemi Ocelot gained support for its SPI bus & NOR flash, its
         second MDIO bus and can now be supported by a FIT/.itb image.
    
       - Octeon saw a bunch of header cleanups which remove a lot of
         duplicate or unused code"
    
    * tag 'mips_4.19' of git://git.kernel.org/pub/scm/linux/kernel/git/mips/linux: (123 commits)
      MIPS: Remove remnants of UASM_ISA
      MIPS: netlogic: xlr: Remove erroneous check in nlm_fmn_send()
      MIPS: VDSO: Force link endianness
      MIPS: Always specify -EB or -EL when using clang
      MIPS: Use dins to simplify __write_64bit_c0_split()
      MIPS: Use read-write output operand in __write_64bit_c0_split()
      MIPS: Avoid using array as parameter to write_c0_kpgd()
      MIPS: vdso: Allow clang's --target flag in VDSO cflags
      MIPS: genvdso: Remove GOT checks
      MIPS: Remove obsolete MIPS checks for DST node "chosen@0"
      MIPS: generic: Remove input symbols from defconfig
      MIPS: Delete unused code in linux32.c
      MIPS: Remove unused sys_32_mmap2
      MIPS: Remove nabi_no_regargs
      mips: dts: mscc: enable spi and NOR flash support on ocelot PCB123
      mips: dts: mscc: Add spi on Ocelot
      MIPS: Loongson: Merge load addresses
      MIPS: Loongson: Set Loongson32 to MIPS32R1
      MIPS: mscc: ocelot: add interrupt controller properties to GPIO controller
      MIPS: generic: Select MIPS_AUTO_PFN_OFFSET
      ...

commit b63e132b6433a41cf311e8bc382d33fd2b73b505
Author: Paul Burton <paul.burton@mips.com>
Date:   Fri Jun 22 10:55:46 2018 -0700

    MIPS: Use async IPIs for arch_trigger_cpumask_backtrace()
    
    The current MIPS implementation of arch_trigger_cpumask_backtrace() is
    broken because it attempts to use synchronous IPIs despite the fact that
    it may be run with interrupts disabled.
    
    This means that when arch_trigger_cpumask_backtrace() is invoked, for
    example by the RCU CPU stall watchdog, we may:
    
      - Deadlock due to use of synchronous IPIs with interrupts disabled,
        causing the CPU that's attempting to generate the backtrace output
        to hang itself.
    
      - Not succeed in generating the desired output from remote CPUs.
    
      - Produce warnings about this from smp_call_function_many(), for
        example:
    
        [42760.526910] INFO: rcu_sched detected stalls on CPUs/tasks:
        [42760.535755]  0-...!: (1 GPs behind) idle=ade/140000000000000/0 softirq=526944/526945 fqs=0
        [42760.547874]  1-...!: (0 ticks this GP) idle=e4a/140000000000000/0 softirq=547885/547885 fqs=0
        [42760.559869]  (detected by 2, t=2162 jiffies, g=266689, c=266688, q=33)
        [42760.568927] ------------[ cut here ]------------
        [42760.576146] WARNING: CPU: 2 PID: 1216 at kernel/smp.c:416 smp_call_function_many+0x88/0x20c
        [42760.587839] Modules linked in:
        [42760.593152] CPU: 2 PID: 1216 Comm: sh Not tainted 4.15.4-00373-gee058bb4d0c2 #2
        [42760.603767] Stack : 8e09bd20 8e09bd20 8e09bd20 fffffff0 00000007 00000006 00000000 8e09bca8
        [42760.616937]         95b2b379 95b2b379 807a0080 00000007 81944518 0000018a 00000032 00000000
        [42760.630095]         00000000 00000030 80000000 00000000 806eca74 00000009 8017e2b8 000001a0
        [42760.643169]         00000000 00000002 00000000 8e09baa4 00000008 808b8008 86d69080 8e09bca0
        [42760.656282]         8e09ad50 805e20aa 00000000 00000000 00000000 8017e2b8 00000009 801070ca
        [42760.669424]         ...
        [42760.673919] Call Trace:
        [42760.678672] [<27fde568>] show_stack+0x70/0xf0
        [42760.685417] [<84751641>] dump_stack+0xaa/0xd0
        [42760.692188] [<699d671c>] __warn+0x80/0x92
        [42760.698549] [<68915d41>] warn_slowpath_null+0x28/0x36
        [42760.705912] [<f7c76c1c>] smp_call_function_many+0x88/0x20c
        [42760.713696] [<6bbdfc2a>] arch_trigger_cpumask_backtrace+0x30/0x4a
        [42760.722216] [<f845bd33>] rcu_dump_cpu_stacks+0x6a/0x98
        [42760.729580] [<796e7629>] rcu_check_callbacks+0x672/0x6ac
        [42760.737476] [<059b3b43>] update_process_times+0x18/0x34
        [42760.744981] [<6eb94941>] tick_sched_handle.isra.5+0x26/0x38
        [42760.752793] [<478d3d70>] tick_sched_timer+0x1c/0x50
        [42760.759882] [<e56ea39f>] __hrtimer_run_queues+0xc6/0x226
        [42760.767418] [<e88bbcae>] hrtimer_interrupt+0x88/0x19a
        [42760.775031] [<6765a19e>] gic_compare_interrupt+0x2e/0x3a
        [42760.782761] [<0558bf5f>] handle_percpu_devid_irq+0x78/0x168
        [42760.790795] [<90c11ba2>] generic_handle_irq+0x1e/0x2c
        [42760.798117] [<1b6d462c>] gic_handle_local_int+0x38/0x86
        [42760.805545] [<b2ada1c7>] gic_irq_dispatch+0xa/0x14
        [42760.812534] [<90c11ba2>] generic_handle_irq+0x1e/0x2c
        [42760.820086] [<c7521934>] do_IRQ+0x16/0x20
        [42760.826274] [<9aef3ce6>] plat_irq_dispatch+0x62/0x94
        [42760.833458] [<6a94b53c>] except_vec_vi_end+0x70/0x78
        [42760.840655] [<22284043>] smp_call_function_many+0x1ba/0x20c
        [42760.848501] [<54022b58>] smp_call_function+0x1e/0x2c
        [42760.855693] [<ab9fc705>] flush_tlb_mm+0x2a/0x98
        [42760.862730] [<0844cdd0>] tlb_flush_mmu+0x1c/0x44
        [42760.869628] [<cb259b74>] arch_tlb_finish_mmu+0x26/0x3e
        [42760.877021] [<1aeaaf74>] tlb_finish_mmu+0x18/0x66
        [42760.883907] [<b3fce717>] exit_mmap+0x76/0xea
        [42760.890428] [<c4c8a2f6>] mmput+0x80/0x11a
        [42760.896632] [<a41a08f4>] do_exit+0x1f4/0x80c
        [42760.903158] [<ee01cef6>] do_group_exit+0x20/0x7e
        [42760.909990] [<13fa8d54>] __wake_up_parent+0x0/0x1e
        [42760.917045] [<46cf89d0>] smp_call_function_many+0x1a2/0x20c
        [42760.924893] [<8c21a93b>] syscall_common+0x14/0x1c
        [42760.931765] ---[ end trace 02aa09da9dc52a60 ]---
        [42760.938342] ------------[ cut here ]------------
        [42760.945311] WARNING: CPU: 2 PID: 1216 at kernel/smp.c:291 smp_call_function_single+0xee/0xf8
        ...
    
    This patch switches MIPS' arch_trigger_cpumask_backtrace() to use async
    IPIs & smp_call_function_single_async() in order to resolve this
    problem. We ensure use of the pre-allocated call_single_data_t
    structures is serialized by maintaining a cpumask indicating that
    they're busy, and refusing to attempt to send an IPI when a CPU's bit is
    set in this mask. This should only happen if a CPU hasn't responded to a
    previous backtrace IPI - ie. if it's hung - and we print a warning to
    the console in this case.
    
    I've marked this for stable branches as far back as v4.9, to which it
    applies cleanly. Strictly speaking the faulty MIPS implementation can be
    traced further back to commit 856839b76836 ("MIPS: Add
    arch_trigger_all_cpu_backtrace() function") in v3.19, but kernel
    versions v3.19 through v4.8 will require further work to backport due to
    the rework performed in commit 9a01c3ed5cdb ("nmi_backtrace: add more
    trigger_*_cpu_backtrace() methods").
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/19597/
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org # v4.9+
    Fixes: 856839b76836 ("MIPS: Add arch_trigger_all_cpu_backtrace() function")
    Fixes: 9a01c3ed5cdb ("nmi_backtrace: add more trigger_*_cpu_backtrace() methods")

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index d4cfeb931382..9670e70139fd 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -29,6 +29,7 @@
 #include <linux/kallsyms.h>
 #include <linux/random.h>
 #include <linux/prctl.h>
+#include <linux/nmi.h>
 
 #include <asm/asm.h>
 #include <asm/bootinfo.h>
@@ -655,28 +656,42 @@ unsigned long arch_align_stack(unsigned long sp)
 	return sp & ALMASK;
 }
 
-static void arch_dump_stack(void *info)
-{
-	struct pt_regs *regs;
+static DEFINE_PER_CPU(call_single_data_t, backtrace_csd);
+static struct cpumask backtrace_csd_busy;
 
-	regs = get_irq_regs();
-
-	if (regs)
-		show_regs(regs);
-	else
-		dump_stack();
+static void handle_backtrace(void *info)
+{
+	nmi_cpu_backtrace(get_irq_regs());
+	cpumask_clear_cpu(smp_processor_id(), &backtrace_csd_busy);
 }
 
-void arch_trigger_cpumask_backtrace(const cpumask_t *mask, bool exclude_self)
+static void raise_backtrace(cpumask_t *mask)
 {
-	long this_cpu = get_cpu();
+	call_single_data_t *csd;
+	int cpu;
 
-	if (cpumask_test_cpu(this_cpu, mask) && !exclude_self)
-		dump_stack();
+	for_each_cpu(cpu, mask) {
+		/*
+		 * If we previously sent an IPI to the target CPU & it hasn't
+		 * cleared its bit in the busy cpumask then it didn't handle
+		 * our previous IPI & it's not safe for us to reuse the
+		 * call_single_data_t.
+		 */
+		if (cpumask_test_and_set_cpu(cpu, &backtrace_csd_busy)) {
+			pr_warn("Unable to send backtrace IPI to CPU%u - perhaps it hung?\n",
+				cpu);
+			continue;
+		}
 
-	smp_call_function_many(mask, arch_dump_stack, NULL, 1);
+		csd = &per_cpu(backtrace_csd, cpu);
+		csd->func = handle_backtrace;
+		smp_call_function_single_async(cpu, csd);
+	}
+}
 
-	put_cpu();
+void arch_trigger_cpumask_backtrace(const cpumask_t *mask, bool exclude_self)
+{
+	nmi_trigger_cpumask_backtrace(mask, exclude_self, raise_backtrace);
 }
 
 int mips_get_process_fp_mode(struct task_struct *task)

commit 5a267832c2ec47b2dad0fdb291a96bb5b8869315
Author: Paul Burton <paul.burton@mips.com>
Date:   Fri Jun 22 10:55:45 2018 -0700

    MIPS: Call dump_stack() from show_regs()
    
    The generic nmi_cpu_backtrace() function calls show_regs() when a struct
    pt_regs is available, and dump_stack() otherwise. If we were to make use
    of the generic nmi_cpu_backtrace() with MIPS' current implementation of
    show_regs() this would mean that we see only register data with no
    accompanying stack information, in contrast with our current
    implementation which calls dump_stack() regardless of whether register
    state is available.
    
    In preparation for making use of the generic nmi_cpu_backtrace() to
    implement arch_trigger_cpumask_backtrace(), have our implementation of
    show_regs() call dump_stack() and drop the explicit dump_stack() call in
    arch_dump_stack() which is invoked by arch_trigger_cpumask_backtrace().
    
    This will allow the output we produce to remain the same after a later
    patch switches to using nmi_cpu_backtrace(). It may mean that we produce
    extra stack output in other uses of show_regs(), but this:
    
      1) Seems harmless.
      2) Is good for consistency between arch_trigger_cpumask_backtrace()
         and other users of show_regs().
      3) Matches the behaviour of the ARM & PowerPC architectures.
    
    Marked for stable back to v4.9 as a prerequisite of the following patch
    "MIPS: Call dump_stack() from show_regs()".
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/19596/
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org # v4.9+

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 8d85046adcc8..d4cfeb931382 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -663,8 +663,8 @@ static void arch_dump_stack(void *info)
 
 	if (regs)
 		show_regs(regs);
-
-	dump_stack();
+	else
+		dump_stack();
 }
 
 void arch_trigger_cpumask_backtrace(const cpumask_t *mask, bool exclude_self)

commit 8c8d953c28000045e5e823f3398319f04d49a7f1
Author: Paul Burton <paul.burton@mips.com>
Date:   Tue Dec 19 15:11:08 2017 -0800

    MIPS: Schedule on CPUs we need to lose FPU for a mode switch
    
    Commit 6b8322576e9d ("MIPS: Force CPUs to lose FP context during mode
    switches") ensures that we react to PR_SET_FP_MODE prctl syscalls
    quickly by broadcasting an IPI in order to cause CPUs to lose FPU access
    when necessary. Whilst it achieves that, unfortunately it causes all
    sorts of strange race conditions because:
    
     1) The IPI may arrive at a point where the FPU is in the process of
        being enabled, but that process is not yet complete leading to a
        state we aren't prepared to handle. For example:
    
        [  370.215903] do_cpu invoked from kernel context![#1]:
        [  370.221064] CPU: 0 PID: 963 Comm: fp-prctl Not tainted 4.9.0-rc5-00323-g210db32-dirty #226
        [  370.229420] task: a8000000fd672e00 task.stack: a8000000fd630000
        [  370.235399] $ 0   : 0000000000000000 0000000000000001 0000000000000001 a8000000fd630000
        [  370.243882] $ 4   : a8000000fd672e00 0000000000000000 0000000000000453 0000000000000000
        [  370.252317] $ 8   : 0000000000000000 a8000000fd637c28 1000000000000000 0000000000000010
        [  370.260753] $12   : 00000000140084e0 ffffffff80109c00 0000000000000000 0000000000000002
        [  370.269179] $16   : ffffffff8092f080 a8000000fd672e00 ffffffff80107fe8 a8000000fd485000
        [  370.277612] $20   : ffffffff8084d328 ffffffff80940000 0000000000000009 ffffffff80930000
        [  370.286038] $24   : 0000000000000000 900000001612048c
        [  370.294476] $28   : a8000000fd630000 a8000000fd637ac0 ffffffff80937300 ffffffff8010807c
        [  370.302909] Hi    : 0000000000000000
        [  370.306595] Lo    : 0000000000000200
        [  370.310376] epc   : ffffffff80115d38 _save_fp+0x10/0xa0
        [  370.315784] ra    : ffffffff8010807c prepare_for_fp_mode_switch+0x94/0x1b0
        [  370.322707] Status: 140084e2 KX SX UX KERNEL EXL
        [  370.327980] Cause : 1080002c (ExcCode 0b)
        [  370.332091] PrId  : 0001a428 (MIPS P6600)
        [  370.336179] Modules linked in:
        [  370.339486] Process fp-prctl (pid: 963, threadinfo=a8000000fd630000, task=a8000000fd672e00, tls=00000000756e67d0)
        [  370.349724] Stack : 0000000000000000 a8000000fd557dc0 0000000000000000 ffffffff801ca8e0
        [  370.358161]         0000000000000000 a8000000fd637b9c 0000000000000009 ffffffff80923780
        [  370.366575]         ffffffff80850000 ffffffff8011610c 00000000000000b8 ffffffff801a5084
        [  370.374989]         ffffffff8084a370 ffffffff8084a388 ffffffff80923780 ffffffff80923828
        [  370.383395]         0000000000010000 ffffffff809237a8 0000000000020000 ffffffff80a40000
        [  370.391817]         000000000000007c 00000000004a0000 00000000756dedd0 ffffffff801a5188
        [  370.400230]         a800000002014900 0000000000000001 ffffffff80923780 0000000080923828
        [  370.408644]         ffffffff80923780 ffffffff80923780 ffffffff80923828 ffffffff801a521c
        [  370.417066]         ffffffff80923780 ffffffff80923828 0000000000010000 ffffffff801a8f84
        [  370.425472]         ffffffff80a40000 a8000000fd637c20 ffffffff80a39240 0000000000000001
        [  370.433885]         ...
        [  370.436562] Call Trace:
        [  370.439222] [<ffffffff80115d38>] _save_fp+0x10/0xa0
        [  370.444305] [<ffffffff8010807c>] prepare_for_fp_mode_switch+0x94/0x1b0
        [  370.451035] [<ffffffff801ca8e0>] flush_smp_call_function_queue+0xf8/0x230
        [  370.457991] [<ffffffff8011610c>] ipi_call_interrupt+0xc/0x20
        [  370.463814] [<ffffffff801a5084>] __handle_irq_event_percpu+0xc4/0x1a8
        [  370.470404] [<ffffffff801a5188>] handle_irq_event_percpu+0x20/0x68
        [  370.476734] [<ffffffff801a521c>] handle_irq_event+0x4c/0x88
        [  370.482486] [<ffffffff801a8f84>] handle_edge_irq+0x12c/0x210
        [  370.488316] [<ffffffff801a47a0>] generic_handle_irq+0x38/0x48
        [  370.494280] [<ffffffff804a2dbc>] gic_handle_shared_int+0x194/0x268
        [  370.500616] [<ffffffff801a47a0>] generic_handle_irq+0x38/0x48
        [  370.506529] [<ffffffff80107e60>] do_IRQ+0x18/0x28
        [  370.511445] [<ffffffff804a1524>] plat_irq_dispatch+0xc4/0x140
        [  370.517339] [<ffffffff80106230>] ret_from_irq+0x0/0x4
        [  370.522583] [<ffffffff8010fad4>] do_ri+0x4fc/0x7e8
        [  370.527546] [<ffffffff80106220>] ret_from_exception+0x0/0x10
    
     2) The IPI may arrive during kernel use of the FPU, since we generally
        only disable preemption around use of the FPU & leave interrupts
        enabled. This can lead to us unexpectedly losing access to the FPU
        in places where it previously had not been possible. For example:
    
        do_cpu invoked from kernel context![#2]:
        CPU: 2 PID: 7338 Comm: fp-prctl Tainted: G      D         4.7.0-00424-g49b0c82
        #2
        task: 838e4000 ti: 88d38000 task.ti: 88d38000
        $ 0   : 00000000 00000001 ffffffff 88d3fef8
        $ 4   : 838e4000 88d38004 00000000 00000001
        $ 8   : 3400fc01 801f8020 808e9100 24000000
        $12   : dbffffff 807b69d8 807b0000 00000000
        $16   : 00000000 80786150 00400fc4 809c0398
        $20   : 809c0338 0040273c 88d3ff28 808e9d30
        $24   : 808e9d30 00400fb4
        $28   : 88d38000 88d3fe88 00000000 8011a2ac
        Hi    : 0040273c
        Lo    : 88d3ff28
        epc   : 80114178 _restore_fp+0x10/0xa0
        ra    : 8011a2ac mipsr2_decoder+0xd5c/0x1660
        Status: 1400fc03    KERNEL EXL IE
        Cause : 1080002c (ExcCode 0b)
        PrId  : 0001a920 (MIPS I6400)
        Modules linked in:
        Process fp-prctl (pid: 7338, threadinfo=88d38000, task=838e4000, tls=766527d0)
        Stack : 00000000 00000000 00000000 88d3fe98 00000000 00000000 809c0398 809c0338
              808e9100 00000000 88d3ff28 00400fc4 00400fc4 0040273c 7fb69e18 004a0000
              004a0000 004a0000 7664add0 8010de18 00000000 00000000 88d3fef8 88d3ff28
              808e9100 00000000 766527d0 8010e534 000c0000 85755000 8181d580 00000000
              00000000 00000000 004a0000 00000000 766527d0 7fb69e18 004a0000 80105c20
              ...
        Call Trace:
        [<80114178>] _restore_fp+0x10/0xa0
        [<8011a2ac>] mipsr2_decoder+0xd5c/0x1660
        [<8010de18>] do_ri+0x90/0x6b8
        [<80105c20>] ret_from_exception+0x0/0x10
    
    At first glance a simple fix may seem to be to disable interrupts around
    kernel use of the FPU rather than merely preemption, however this would
    introduce further overhead outside of the mode switch path & doesn't
    solve the third problem:
    
     3) The IPI may arrive whilst the kernel is running code that will lead
        to a preempt_disable() call & FPU usage soon. If this happens then
        the IPI will be serviced & we'll proceed to enable an FPU whilst the
        mode switch is in progress, leading to strange & inconsistent
        behaviour.
    
    Further to all of this is a separate but related problem:
    
     4) There are various paths through which we may enable the FPU without
        the user having triggered a coprocessor 1 disabled exception. These
        paths are those in which we emulate instructions & then enable the
        FPU with the expectation that the user might execute an FP
        instruction shortly afterwards. However these paths have not
        previously checked whether an FP mode switch is underway for the
        task, and therefore could enable the FPU whilst such a mode switch
        is in progress leading to strange & inconsistent behaviour for user
        code.
    
    This patch fixes all of the above by taking a step back & re-examining
    our approach to FP mode switches. Up until now we have taken these basic
    steps:
    
     a) Prevent any threads that are part of the affected process from being
        able to obtain ownership of the FPU.
    
     b) Cause any threads that are part of the affected process and already
        have ownership of an FPU to lose it.
    
     c) Set the thread flags for each thread that is part of the affected
        process to reflect the new FP mode.
    
     d) Allow threads to obtain ownership of the FPU again.
    
    This approach is however more complex than necessary. All that we really
    require is that the mode switch has occurred for all threads that are
    part of the affected process before mips_set_process_fp_mode(), and thus
    the PR_SET_FP_MODE prctl() syscall, returns. This doesn't require that
    we stop threads from owning or using an FPU whilst a mode switch occurs,
    only that we force them to relinquish it after the mode switch has
    occurred such that they next own an FPU with the correct mode
    configured. Our basic steps therefore simplify to:
    
     A) Set the thread flags for each thread that is part of the affected
        process to reflect the new FP mode.
    
     B) Cause any threads that are part of the affected process and already
        have ownership of an FPU to lose it.
    
    We implement B) by forcing each CPU which might be running a thread
    which is part of the affected process to schedule a no-op function,
    which causes the affected thread to lose its FPU ownership when it is
    descheduled.
    
    The end result is simpler FP mode switching with less overhead in the
    FPU enable path (ie. enable_restore_fp_context()) and fewer moving
    parts.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Fixes: 9791554b45a2 ("MIPS,prctl: add PR_[GS]ET_FP_MODE prctl options for MIPS")
    Fixes: 6b8322576e9d ("MIPS: Force CPUs to lose FP context during mode switches")
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: stable <stable@vger.kernel.org> # v4.0+

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 8d85046adcc8..fe6001d748cf 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -29,6 +29,7 @@
 #include <linux/kallsyms.h>
 #include <linux/random.h>
 #include <linux/prctl.h>
+#include <linux/cpu.h>
 
 #include <asm/asm.h>
 #include <asm/bootinfo.h>
@@ -691,19 +692,25 @@ int mips_get_process_fp_mode(struct task_struct *task)
 	return value;
 }
 
-static void prepare_for_fp_mode_switch(void *info)
+static long prepare_for_fp_mode_switch(void *unused)
 {
-	struct mm_struct *mm = info;
-
-	if (current->mm == mm)
-		lose_fpu(1);
+	/*
+	 * This is icky, but we use this to simply ensure that all CPUs have
+	 * context switched, regardless of whether they were previously running
+	 * kernel or user code. This ensures that no CPU currently has its FPU
+	 * enabled, or is about to attempt to enable it through any path other
+	 * than enable_restore_fp_context() which will wait appropriately for
+	 * fp_mode_switching to be zero.
+	 */
+	return 0;
 }
 
 int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 {
 	const unsigned int known_bits = PR_FP_MODE_FR | PR_FP_MODE_FRE;
 	struct task_struct *t;
-	int max_users;
+	struct cpumask process_cpus;
+	int cpu;
 
 	/* If nothing to change, return right away, successfully.  */
 	if (value == mips_get_process_fp_mode(task))
@@ -736,35 +743,7 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 	if (!(value & PR_FP_MODE_FR) && raw_cpu_has_fpu && cpu_has_mips_r6)
 		return -EOPNOTSUPP;
 
-	/* Proceed with the mode switch */
-	preempt_disable();
-
-	/* Save FP & vector context, then disable FPU & MSA */
-	if (task->signal == current->signal)
-		lose_fpu(1);
-
-	/* Prevent any threads from obtaining live FP context */
-	atomic_set(&task->mm->context.fp_mode_switching, 1);
-	smp_mb__after_atomic();
-
-	/*
-	 * If there are multiple online CPUs then force any which are running
-	 * threads in this process to lose their FPU context, which they can't
-	 * regain until fp_mode_switching is cleared later.
-	 */
-	if (num_online_cpus() > 1) {
-		/* No need to send an IPI for the local CPU */
-		max_users = (task->mm == current->mm) ? 1 : 0;
-
-		if (atomic_read(&current->mm->mm_users) > max_users)
-			smp_call_function(prepare_for_fp_mode_switch,
-					  (void *)current->mm, 1);
-	}
-
-	/*
-	 * There are now no threads of the process with live FP context, so it
-	 * is safe to proceed with the FP mode switch.
-	 */
+	/* Indicate the new FP mode in each thread */
 	for_each_thread(task, t) {
 		/* Update desired FP register width */
 		if (value & PR_FP_MODE_FR) {
@@ -781,9 +760,34 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 			clear_tsk_thread_flag(t, TIF_HYBRID_FPREGS);
 	}
 
-	/* Allow threads to use FP again */
-	atomic_set(&task->mm->context.fp_mode_switching, 0);
-	preempt_enable();
+	/*
+	 * We need to ensure that all threads in the process have switched mode
+	 * before returning, in order to allow userland to not worry about
+	 * races. We can do this by forcing all CPUs that any thread in the
+	 * process may be running on to schedule something else - in this case
+	 * prepare_for_fp_mode_switch().
+	 *
+	 * We begin by generating a mask of all CPUs that any thread in the
+	 * process may be running on.
+	 */
+	cpumask_clear(&process_cpus);
+	for_each_thread(task, t)
+		cpumask_set_cpu(task_cpu(t), &process_cpus);
+
+	/*
+	 * Now we schedule prepare_for_fp_mode_switch() on each of those CPUs.
+	 *
+	 * The CPUs may have rescheduled already since we switched mode or
+	 * generated the cpumask, but that doesn't matter. If the task in this
+	 * process is scheduled out then our scheduling
+	 * prepare_for_fp_mode_switch() will simply be redundant. If it's
+	 * scheduled in then it will already have picked up the new FP mode
+	 * whilst doing so.
+	 */
+	get_online_cpus();
+	for_each_cpu_and(cpu, &process_cpus, cpu_online_mask)
+		work_on_cpu(cpu, prepare_for_fp_mode_switch, NULL);
+	put_online_cpus();
 
 	wake_up_var(&task->mm->context.fp_mode_switching);
 

commit 050e9baa9dc9fbd9ce2b27f0056990fc9e0a08a0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jun 14 12:21:18 2018 +0900

    Kbuild: rename CC_STACKPROTECTOR[_STRONG] config variables
    
    The changes to automatically test for working stack protector compiler
    support in the Kconfig files removed the special STACKPROTECTOR_AUTO
    option that picked the strongest stack protector that the compiler
    supported.
    
    That was all a nice cleanup - it makes no sense to have the AUTO case
    now that the Kconfig phase can just determine the compiler support
    directly.
    
    HOWEVER.
    
    It also meant that doing "make oldconfig" would now _disable_ the strong
    stackprotector if you had AUTO enabled, because in a legacy config file,
    the sane stack protector configuration would look like
    
      CONFIG_HAVE_CC_STACKPROTECTOR=y
      # CONFIG_CC_STACKPROTECTOR_NONE is not set
      # CONFIG_CC_STACKPROTECTOR_REGULAR is not set
      # CONFIG_CC_STACKPROTECTOR_STRONG is not set
      CONFIG_CC_STACKPROTECTOR_AUTO=y
    
    and when you ran this through "make oldconfig" with the Kbuild changes,
    it would ask you about the regular CONFIG_CC_STACKPROTECTOR (that had
    been renamed from CONFIG_CC_STACKPROTECTOR_REGULAR to just
    CONFIG_CC_STACKPROTECTOR), but it would think that the STRONG version
    used to be disabled (because it was really enabled by AUTO), and would
    disable it in the new config, resulting in:
    
      CONFIG_HAVE_CC_STACKPROTECTOR=y
      CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
      CONFIG_CC_STACKPROTECTOR=y
      # CONFIG_CC_STACKPROTECTOR_STRONG is not set
      CONFIG_CC_HAS_SANE_STACKPROTECTOR=y
    
    That's dangerously subtle - people could suddenly find themselves with
    the weaker stack protector setup without even realizing.
    
    The solution here is to just rename not just the old RECULAR stack
    protector option, but also the strong one.  This does that by just
    removing the CC_ prefix entirely for the user choices, because it really
    is not about the compiler support (the compiler support now instead
    automatially impacts _visibility_ of the options to users).
    
    This results in "make oldconfig" actually asking the user for their
    choice, so that we don't have any silent subtle security model changes.
    The end result would generally look like this:
    
      CONFIG_HAVE_CC_STACKPROTECTOR=y
      CONFIG_CC_HAS_STACKPROTECTOR_NONE=y
      CONFIG_STACKPROTECTOR=y
      CONFIG_STACKPROTECTOR_STRONG=y
      CONFIG_CC_HAS_SANE_STACKPROTECTOR=y
    
    where the "CC_" versions really are about internal compiler
    infrastructure, not the user selections.
    
    Acked-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 3775a8d694fb..8d85046adcc8 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -180,7 +180,7 @@ int copy_thread_tls(unsigned long clone_flags, unsigned long usp,
 	return 0;
 }
 
-#ifdef CONFIG_CC_STACKPROTECTOR
+#ifdef CONFIG_STACKPROTECTOR
 #include <linux/stackprotector.h>
 unsigned long __stack_chk_guard __read_mostly;
 EXPORT_SYMBOL(__stack_chk_guard);

commit 28e4213dd331e944e7fca1954a946829162ed9d4
Author: Maciej W. Rozycki <macro@mips.com>
Date:   Tue May 15 23:04:44 2018 +0100

    MIPS: prctl: Disallow FRE without FR with PR_SET_FP_MODE requests
    
    Having PR_FP_MODE_FRE (i.e. Config5.FRE) set without PR_FP_MODE_FR (i.e.
    Status.FR) is not supported as the lone purpose of Config5.FRE is to
    emulate Status.FR=0 handling on FPU hardware that has Status.FR=1
    hardwired[1][2].  Also we do not handle this case elsewhere, and assume
    throughout our code that TIF_HYBRID_FPREGS and TIF_32BIT_FPREGS cannot
    be set both at once for a task, leading to inconsistent behaviour if
    this does happen.
    
    Return unsuccessfully then from prctl(2) PR_SET_FP_MODE calls requesting
    PR_FP_MODE_FRE to be set with PR_FP_MODE_FR clear.  This corresponds to
    modes allowed by `mips_set_personality_fp'.
    
    References:
    
    [1] "MIPS Architecture For Programmers, Vol. III: MIPS32 / microMIPS32
        Privileged Resource Architecture", Imagination Technologies,
        Document Number: MD00090, Revision 6.02, July 10, 2015, Table 9.69
        "Config5 Register Field Descriptions", p. 262
    
    [2] "MIPS Architecture For Programmers, Volume III: MIPS64 / microMIPS64
        Privileged Resource Architecture", Imagination Technologies,
        Document Number: MD00091, Revision 6.03, December 22, 2015, Table
        9.72 "Config5 Register Field Descriptions", p. 288
    
    Fixes: 9791554b45a2 ("MIPS,prctl: add PR_[GS]ET_FP_MODE prctl options for MIPS")
    Signed-off-by: Maciej W. Rozycki <macro@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: <stable@vger.kernel.org> # 4.0+
    Patchwork: https://patchwork.linux-mips.org/patch/19327/
    Signed-off-by: James Hogan <jhogan@kernel.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index b9e9bf628849..3775a8d694fb 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -721,6 +721,10 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 	if (value & ~known_bits)
 		return -EOPNOTSUPP;
 
+	/* Setting FRE without FR is not supported.  */
+	if ((value & (PR_FP_MODE_FR | PR_FP_MODE_FRE)) == PR_FP_MODE_FRE)
+		return -EOPNOTSUPP;
+
 	/* Avoid inadvertently triggering emulation */
 	if ((value & PR_FP_MODE_FR) && raw_cpu_has_fpu &&
 	    !(raw_current_cpu_data.fpu_id & MIPS_FPIR_F64))

commit 6887a56b6e8ef5daf1160f2ebe5cbe38fd8819a2
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Thu Mar 15 11:45:44 2018 +0100

    sched/wait, arch/mips: Fix and convert wait_on_atomic_t() usage to the new wait_var_event() API
    
    The old wait_on_atomic_t() is going to get removed, use the more
    flexible wait_var_event() API instead.
    
    And while there, fix a bug and add the missing wakeup...
    
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 57028d49c202..b9e9bf628849 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -781,6 +781,8 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 	atomic_set(&task->mm->context.fp_mode_switching, 0);
 	preempt_enable();
 
+	wake_up_var(&task->mm->context.fp_mode_switching);
+
 	return 0;
 }
 

commit b67336eee3fcb8ecedc6c13e2bf88aacfa3151e2
Author: Maciej W. Rozycki <macro@mips.com>
Date:   Mon Nov 27 09:33:03 2017 +0000

    MIPS: Validate PR_SET_FP_MODE prctl(2) requests against the ABI of the task
    
    Fix an API loophole introduced with commit 9791554b45a2 ("MIPS,prctl:
    add PR_[GS]ET_FP_MODE prctl options for MIPS"), where the caller of
    prctl(2) is incorrectly allowed to make a change to CP0.Status.FR or
    CP0.Config5.FRE register bits even if CONFIG_MIPS_O32_FP64_SUPPORT has
    not been enabled, despite that an executable requesting the mode
    requested via ELF file annotation would not be allowed to run in the
    first place, or for n64 and n64 ABI tasks which do not have non-default
    modes defined at all.  Add suitable checks to `mips_set_process_fp_mode'
    and bail out if an invalid mode change has been requested for the ABI in
    effect, even if the FPU hardware or emulation would otherwise allow it.
    
    Always succeed however without taking any further action if the mode
    requested is the same as one already in effect, regardless of whether
    any mode change, should it be requested, would actually be allowed for
    the task concerned.
    
    Signed-off-by: Maciej W. Rozycki <macro@mips.com>
    Fixes: 9791554b45a2 ("MIPS,prctl: add PR_[GS]ET_FP_MODE prctl options for MIPS")
    Reviewed-by: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <james.hogan@mips.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Cc: stable@vger.kernel.org # 4.0+
    Patchwork: https://patchwork.linux-mips.org/patch/17800/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 45d0b6b037ee..57028d49c202 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -705,6 +705,18 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 	struct task_struct *t;
 	int max_users;
 
+	/* If nothing to change, return right away, successfully.  */
+	if (value == mips_get_process_fp_mode(task))
+		return 0;
+
+	/* Only accept a mode change if 64-bit FP enabled for o32.  */
+	if (!IS_ENABLED(CONFIG_MIPS_O32_FP64_SUPPORT))
+		return -EOPNOTSUPP;
+
+	/* And only for o32 tasks.  */
+	if (IS_ENABLED(CONFIG_64BIT) && !test_thread_flag(TIF_32BIT_REGS))
+		return -EOPNOTSUPP;
+
 	/* Check the value is valid */
 	if (value & ~known_bits)
 		return -EOPNOTSUPP;

commit 508c5757a72873d007e932faff5fa0014b25812d
Author: Tobias Klauser <tklauser@distanz.ch>
Date:   Mon Sep 18 13:38:40 2017 +0200

    MIPS: make thread_saved_pc static
    
    The only user of thread_saved_pc() in non-arch-specific code was removed
    in commit 8243d5597793 ("sched/core: Remove pointless printout in
    sched_show_task()"), so it no longer needs to be globally defined for
    MIPS and can be made static.
    
    Signed-off-by: Tobias Klauser <tklauser@distanz.ch>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/17303/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index c5ff6bfe2825..45d0b6b037ee 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -487,7 +487,7 @@ arch_initcall(frame_info_init);
 /*
  * Return saved PC of a blocked thread.
  */
-unsigned long thread_saved_pc(struct task_struct *tsk)
+static unsigned long thread_saved_pc(struct task_struct *tsk)
 {
 	struct thread_struct *t = &tsk->thread;
 

commit 56dfb7001a396ef6c7928adcb890043ff55e9977
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Tue Aug 8 13:22:35 2017 +0100

    MIPS: Refactor handling of stack pointer in get_frame_info
    
    Commit 34c2f668d0f6 ("MIPS: microMIPS: Add unaligned access support.")
    added handling of microMIPS instructions to manipulate the stack
    pointer. The code that was added violates code style rules with long
    lines caused by lots of nested conditionals.
    
    The added code interprets (inline) any known stack pointer manipulation
    instruction to find the stack frame size. Handling the microMIPS cases
    added quite a bit of complication to this function.
    
    Refactor is_sp_move_ins to perform the interpretation of the immediate
    as the instruction manipulating the stack pointer is found. This reduces
    the amount of indentation required in get_frame_info, and more closely
    matches the operation of is_ra_save_ins.
    
    Suggested-by: Maciej W. Rozycki <macro@imgtec.com>
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/16958/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 86139ac3bbad..c5ff6bfe2825 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -313,9 +313,11 @@ static inline int is_jump_ins(union mips_instruction *ip)
 #endif
 }
 
-static inline int is_sp_move_ins(union mips_instruction *ip)
+static inline int is_sp_move_ins(union mips_instruction *ip, int *frame_size)
 {
 #ifdef CONFIG_CPU_MICROMIPS
+	unsigned short tmp;
+
 	/*
 	 * addiusp -imm
 	 * addius5 sp,-imm
@@ -325,20 +327,39 @@ static inline int is_sp_move_ins(union mips_instruction *ip)
 	 * microMIPS is not more fun...
 	 */
 	if (mm_insn_16bit(ip->word >> 16)) {
-		return (ip->mm16_r3_format.opcode == mm_pool16d_op &&
-			ip->mm16_r3_format.simmediate & mm_addiusp_func) ||
-		       (ip->mm16_r5_format.opcode == mm_pool16d_op &&
-			ip->mm16_r5_format.rt == 29);
+		if (ip->mm16_r3_format.opcode == mm_pool16d_op &&
+		    ip->mm16_r3_format.simmediate & mm_addiusp_func) {
+			tmp = ip->mm_b0_format.simmediate >> 1;
+			tmp = ((tmp & 0x1ff) ^ 0x100) - 0x100;
+			if ((tmp + 2) < 4) /* 0x0,0x1,0x1fe,0x1ff are special */
+				tmp ^= 0x100;
+			*frame_size = -(signed short)(tmp << 2);
+			return 1;
+		}
+		if (ip->mm16_r5_format.opcode == mm_pool16d_op &&
+		    ip->mm16_r5_format.rt == 29) {
+			tmp = ip->mm16_r5_format.imm >> 1;
+			*frame_size = -(signed short)(tmp & 0xf);
+			return 1;
+		}
+		return 0;
 	}
 
-	return ip->mm_i_format.opcode == mm_addiu32_op &&
-	       ip->mm_i_format.rt == 29 && ip->mm_i_format.rs == 29;
+	if (ip->mm_i_format.opcode == mm_addiu32_op &&
+	    ip->mm_i_format.rt == 29 && ip->mm_i_format.rs == 29) {
+		*frame_size = -ip->i_format.simmediate;
+		return 1;
+	}
 #else
 	/* addiu/daddiu sp,sp,-imm */
 	if (ip->i_format.rs != 29 || ip->i_format.rt != 29)
 		return 0;
-	if (ip->i_format.opcode == addiu_op || ip->i_format.opcode == daddiu_op)
+
+	if (ip->i_format.opcode == addiu_op ||
+	    ip->i_format.opcode == daddiu_op) {
+		*frame_size = -ip->i_format.simmediate;
 		return 1;
+	}
 #endif
 	return 0;
 }
@@ -375,29 +396,7 @@ static int get_frame_info(struct mips_frame_info *info)
 		}
 
 		if (!info->frame_size) {
-			if (is_sp_move_ins(&insn))
-			{
-#ifdef CONFIG_CPU_MICROMIPS
-				if (mm_insn_16bit(insn.word >> 16))
-				{
-					unsigned short tmp;
-
-					if (ip->mm16_r3_format.simmediate & mm_addiusp_func)
-					{
-						tmp = ip->mm_b0_format.simmediate >> 1;
-						tmp = ((tmp & 0x1ff) ^ 0x100) - 0x100;
-						/* 0x0,0x1,0x1fe,0x1ff are special */
-						if ((tmp + 2) < 4)
-							tmp ^= 0x100;
-						info->frame_size = -(signed short)(tmp << 2);
-					} else {
-						tmp = (ip->mm16_r5_format.imm >> 1);
-						info->frame_size = -(signed short)(tmp & 0xf);
-					}
-				} else
-#endif
-				info->frame_size = - ip->i_format.simmediate;
-			}
+			is_sp_move_ins(&insn, &info->frame_size);
 			continue;
 		} else if (!saw_jump && is_jump_ins(ip)) {
 			/*

commit 41885b02127c7ae169dc94542de4a8eed175495a
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Tue Aug 8 13:22:34 2017 +0100

    MIPS: Stacktrace: Fix microMIPS stack unwinding on big endian systems
    
    The stack unwinding code uses the mips_instuction union to decode the
    instructions it finds. That union uses the __BITFIELD_FIELD macro to
    reorder depending on endianness. The stack unwinding code always places
    16bit instructions in halfword 1 of the union. This makes the union
    accesses correct for little endian systems. Similarly, 32bit
    instructions are reordered such that they are correct for little endian
    systems. This handling leaves unwinding the stack on big endian systems
    broken, as the mips_instruction union will then look for the fields in
    the wrong halfword.
    
    To fix this, use a logical shift to place the 16bit instruction into the
    correct position in the word field of the union. Use the same shifting
    to order the 2 halfwords of 32bit instuctions. Then replace accesses to
    the halfword with accesses to the shifted word.
    In the case of the ADDIUS5 instruction, switch to using the
    mm16_r5_format union member to avoid the need for a 16bit shift.
    
    Fixes: 34c2f668d0f6 ("MIPS: microMIPS: Add unaligned access support.")
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Cc: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/16956/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index debc0410a2d5..86139ac3bbad 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -208,7 +208,7 @@ static inline int is_ra_save_ins(union mips_instruction *ip, int *poff)
 	 *
 	 * microMIPS is way more fun...
 	 */
-	if (mm_insn_16bit(ip->halfword[1])) {
+	if (mm_insn_16bit(ip->word >> 16)) {
 		switch (ip->mm16_r5_format.opcode) {
 		case mm_swsp16_op:
 			if (ip->mm16_r5_format.rt != 31)
@@ -287,7 +287,7 @@ static inline int is_jump_ins(union mips_instruction *ip)
 	 *
 	 * microMIPS is kind of more fun...
 	 */
-	if (mm_insn_16bit(ip->halfword[1])) {
+	if (mm_insn_16bit(ip->word >> 16)) {
 		if ((ip->mm16_r5_format.opcode == mm_pool16c_op &&
 		    (ip->mm16_r5_format.rt & mm_jr16_op) == mm_jr16_op))
 			return 1;
@@ -324,7 +324,7 @@ static inline int is_sp_move_ins(union mips_instruction *ip)
 	 *
 	 * microMIPS is not more fun...
 	 */
-	if (mm_insn_16bit(ip->halfword[1])) {
+	if (mm_insn_16bit(ip->word >> 16)) {
 		return (ip->mm16_r3_format.opcode == mm_pool16d_op &&
 			ip->mm16_r3_format.simmediate & mm_addiusp_func) ||
 		       (ip->mm16_r5_format.opcode == mm_pool16d_op &&
@@ -364,12 +364,10 @@ static int get_frame_info(struct mips_frame_info *info)
 	for (i = 0; i < max_insns && ip < ip_end; i++) {
 		ip = (void *)ip + last_insn_size;
 		if (is_mmips && mm_insn_16bit(ip->halfword[0])) {
-			insn.halfword[0] = 0;
-			insn.halfword[1] = ip->halfword[0];
+			insn.word = ip->halfword[0] << 16;
 			last_insn_size = 2;
 		} else if (is_mmips) {
-			insn.halfword[0] = ip->halfword[1];
-			insn.halfword[1] = ip->halfword[0];
+			insn.word = ip->halfword[0] << 16 | ip->halfword[1];
 			last_insn_size = 4;
 		} else {
 			insn.word = ip->word;
@@ -380,7 +378,7 @@ static int get_frame_info(struct mips_frame_info *info)
 			if (is_sp_move_ins(&insn))
 			{
 #ifdef CONFIG_CPU_MICROMIPS
-				if (mm_insn_16bit(ip->halfword[0]))
+				if (mm_insn_16bit(insn.word >> 16))
 				{
 					unsigned short tmp;
 
@@ -393,7 +391,7 @@ static int get_frame_info(struct mips_frame_info *info)
 							tmp ^= 0x100;
 						info->frame_size = -(signed short)(tmp << 2);
 					} else {
-						tmp = (ip->halfword[0] >> 1);
+						tmp = (ip->mm16_r5_format.imm >> 1);
 						info->frame_size = -(signed short)(tmp & 0xf);
 					}
 				} else

commit cea8cd498f4f1c30ea27e3664b3c671e495c4fce
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Tue Aug 8 13:22:33 2017 +0100

    MIPS: microMIPS: Fix decoding of swsp16 instruction
    
    When the immediate encoded in the instruction is accessed, it is sign
    extended due to being a signed value being assigned to a signed integer.
    The ISA specifies that this operation is an unsigned operation.
    The sign extension leads us to incorrectly decode:
    
    801e9c8e:       cbf1            sw      ra,68(sp)
    
    As having an immediate of 1073741809.
    
    Since the instruction format does not specify signed/unsigned, and this
    is currently the only location to use this instuction format, change it
    to an unsigned immediate.
    
    Fixes: bb9bc4689b9c ("MIPS: Calculate microMIPS ra properly when unwinding the stack")
    Suggested-by: Paul Burton <paul.burton@imgtec.com>
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Reviewed-by: James Hogan <james.hogan@imgtec.com>
    Cc: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: Miodrag Dinic <miodrag.dinic@imgtec.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: David Daney <david.daney@cavium.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/16957/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 516089f8c6e7..debc0410a2d5 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -214,7 +214,7 @@ static inline int is_ra_save_ins(union mips_instruction *ip, int *poff)
 			if (ip->mm16_r5_format.rt != 31)
 				return 0;
 
-			*poff = ip->mm16_r5_format.simmediate;
+			*poff = ip->mm16_r5_format.imm;
 			*poff = (*poff << 2) / sizeof(ulong);
 			return 1;
 

commit a0ae2b08331a9882150618e0c81ea837e4a37ace
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Tue Aug 8 13:22:32 2017 +0100

    MIPS: microMIPS: Fix decoding of addiusp instruction
    
    Commit 34c2f668d0f6 ("MIPS: microMIPS: Add unaligned access support.")
    added handling of microMIPS instructions to manipulate the stack
    pointer. Unfortunately the decoding of the addiusp instruction was
    incorrect, and performed a left shift by 2 bits to the raw immediate,
    rather than decoding the immediate and then performing the shift, as
    documented in the ISA.
    
    This led to incomplete stack traces, due to incorrect frame sizes being
    calculated. For example the instruction:
    801faee0 <do_sys_poll>:
    801faee0:       4e25            addiu   sp,sp,-952
    
    As decoded by objdump, would be interpreted by the existing code as
    having manipulated the stack pointer by +1096.
    
    Fix this by changing the order of decoding the immediate and applying
    the left shift. Also change to accessing the instuction through the
    union to avoid the endianness problem of accesing halfword[0], which
    will fail on big endian systems.
    
    Cope with the special behaviour of immediates 0x0, 0x1, 0x1fe and 0x1ff
    by XORing with 0x100 again if mod(immediate) < 4. This logic was tested
    with the following test code:
    
    int main(int argc, char **argv)
    {
            unsigned int enc;
            int imm;
    
            for (enc = 0; enc < 512; ++enc) {
                    int tmp = enc << 2;
                    imm = -(signed short)(tmp | ((tmp & 0x100) ? 0xfe00 : 0));
                    unsigned short tmp = enc;
                    tmp = (tmp ^ 0x100) - 0x100;
                    if ((unsigned short)(tmp + 2) < 4)
                            tmp ^= 0x100;
                    imm = -(signed short)(tmp << 2);
                    printf("%#x\t%d\t->\t(%#x\t%d)\t%#x\t%d\n",
                           enc, enc,
                           (short)tmp, (short)tmp,
                           imm, imm);
            }
            return EXIT_SUCCESS;
    }
    
    Which generates the table:
    
    input encoding  ->      tmp (matching manual)   frame size
    -----------------------------------------------------------------------
    0       0       ->      (0x100          256)    0xfffffc00      -1024
    0x1     1       ->      (0x101          257)    0xfffffbfc      -1028
    0x2     2       ->      (0x2            2)      0xfffffff8      -8
    0x3     3       ->      (0x3            3)      0xfffffff4      -12
    ...
    0xfe    254     ->      (0xfe           254)    0xfffffc08      -1016
    0xff    255     ->      (0xff           255)    0xfffffc04      -1020
    0x100   256     ->      (0xffffff00     -256)   0x400           1024
    0x101   257     ->      (0xffffff01     -255)   0x3fc           1020
    ...
    0x1fc   508     ->      (0xfffffffc     -4)     0x10            16
    0x1fd   509     ->      (0xfffffffd     -3)     0xc             12
    0x1fe   510     ->      (0xfffffefe     -258)   0x408           1032
    0x1ff   511     ->      (0xfffffeff     -257)   0x404           1028
    
    Thanks to James Hogan for the test code & verifying the logic.
    
    Fixes: 34c2f668d0f6 ("MIPS: microMIPS: Add unaligned access support.")
    Suggested-by: James Hogan <james.hogan@imgtec.com>
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/16955/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 40200545a3d9..516089f8c6e7 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -384,10 +384,14 @@ static int get_frame_info(struct mips_frame_info *info)
 				{
 					unsigned short tmp;
 
-					if (ip->halfword[0] & mm_addiusp_func)
+					if (ip->mm16_r3_format.simmediate & mm_addiusp_func)
 					{
-						tmp = (((ip->halfword[0] >> 1) & 0x1ff) << 2);
-						info->frame_size = -(signed short)(tmp | ((tmp & 0x100) ? 0xfe00 : 0));
+						tmp = ip->mm_b0_format.simmediate >> 1;
+						tmp = ((tmp & 0x1ff) ^ 0x100) - 0x100;
+						/* 0x0,0x1,0x1fe,0x1ff are special */
+						if ((tmp + 2) < 4)
+							tmp ^= 0x100;
+						info->frame_size = -(signed short)(tmp << 2);
 					} else {
 						tmp = (ip->halfword[0] >> 1);
 						info->frame_size = -(signed short)(tmp & 0xf);

commit b332fec0489295ee7a0aab4a89bd7257cd126f7f
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Tue Aug 8 13:22:31 2017 +0100

    MIPS: microMIPS: Fix detection of addiusp instruction
    
    The addiusp instruction uses the pool16d opcode, with bit 0 of the
    immediate set. The test for the addiusp opcode erroneously did a logical
    and of the immediate with mm_addiusp_func, which has value 1, so this
    test always passes when the immediate is non-zero.
    
    Fix the test by replacing the logical and with a bitwise and.
    
    Fixes: 34c2f668d0f6 ("MIPS: microMIPS: Add unaligned access support.")
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/16954/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 8374bf40ac77..40200545a3d9 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -326,7 +326,7 @@ static inline int is_sp_move_ins(union mips_instruction *ip)
 	 */
 	if (mm_insn_16bit(ip->halfword[1])) {
 		return (ip->mm16_r3_format.opcode == mm_pool16d_op &&
-			ip->mm16_r3_format.simmediate && mm_addiusp_func) ||
+			ip->mm16_r3_format.simmediate & mm_addiusp_func) ||
 		       (ip->mm16_r5_format.opcode == mm_pool16d_op &&
 			ip->mm16_r5_format.rt == 29);
 	}

commit 11887ed172a6960673f130dad8f8fb42778f64d7
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Tue Aug 8 13:22:30 2017 +0100

    MIPS: Handle non word sized instructions when examining frame
    
    Commit 34c2f668d0f6b ("MIPS: microMIPS: Add unaligned access support.")
    added fairly broken support for handling 16bit microMIPS instructions in
    get_frame_info(). It adjusts the instruction pointer by 16bits in the
    case of a 16bit sp move instruction, but not any other 16bit
    instruction.
    
    Commit b6c7a324df37 ("MIPS: Fix get_frame_info() handling of microMIPS
    function size") goes some way to fixing get_frame_info() to iterate over
    microMIPS instuctions, but the instruction pointer is still manipulated
    using a postincrement, and is of union mips_instruction type. Since the
    union is sized to the largest member (a word), but microMIPS
    instructions are a mix of halfword and word sizes, the function does not
    always iterate correctly, ending up misaligned with the instruction
    stream and interpreting it incorrectly.
    
    Since the instruction modifying the stack pointer is usually the first
    in the function, that one is usually handled correctly. But the
    instruction which saves the return address to the sp is some variable
    number of instructions into the frame and is frequently missed due to
    not being on a word boundary, leading to incomplete walking of the
    stack.
    
    Fix this by incrementing the instruction pointer based on the size of
    the previously decoded instruction (& remove the hack introduced by
    commit 34c2f668d0f6b ("MIPS: microMIPS: Add unaligned access support.")
    which adjusts the instruction pointer in the case of a 16bit sp move
    instruction, but not any other).
    
    Fixes: 34c2f668d0f6b ("MIPS: microMIPS: Add unaligned access support.")
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/16953/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index a1d930a8705b..8374bf40ac77 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -348,6 +348,7 @@ static int get_frame_info(struct mips_frame_info *info)
 	bool is_mmips = IS_ENABLED(CONFIG_CPU_MICROMIPS);
 	union mips_instruction insn, *ip, *ip_end;
 	const unsigned int max_insns = 128;
+	unsigned int last_insn_size = 0;
 	unsigned int i;
 	bool saw_jump = false;
 
@@ -360,15 +361,19 @@ static int get_frame_info(struct mips_frame_info *info)
 
 	ip_end = (void *)ip + info->func_size;
 
-	for (i = 0; i < max_insns && ip < ip_end; i++, ip++) {
+	for (i = 0; i < max_insns && ip < ip_end; i++) {
+		ip = (void *)ip + last_insn_size;
 		if (is_mmips && mm_insn_16bit(ip->halfword[0])) {
 			insn.halfword[0] = 0;
 			insn.halfword[1] = ip->halfword[0];
+			last_insn_size = 2;
 		} else if (is_mmips) {
 			insn.halfword[0] = ip->halfword[1];
 			insn.halfword[1] = ip->halfword[0];
+			last_insn_size = 4;
 		} else {
 			insn.word = ip->word;
+			last_insn_size = 4;
 		}
 
 		if (!info->frame_size) {
@@ -387,8 +392,6 @@ static int get_frame_info(struct mips_frame_info *info)
 						tmp = (ip->halfword[0] >> 1);
 						info->frame_size = -(signed short)(tmp & 0xf);
 					}
-					ip = (void *) &ip->halfword[1];
-					ip--;
 				} else
 #endif
 				info->frame_size = - ip->i_format.simmediate;

commit aee16625b193916d7616c37a1d20a703d9b3dd15
Author: Corey Minyard <cminyard@mvista.com>
Date:   Thu Aug 10 13:27:37 2017 -0500

    MIPS: Fix issues in backtraces
    
    I saw two problems when doing backtraces:
    
    The compiler was putting a "fast return" at the top of some
    functions, before it set up the frame.  The backtrace code
    would stop when it saw a jump instruction, so it would never
    get to the stack frame setup and would thus misinterpret it.
    To fix this, don't look for jump instructions until the
    frame setup has been seen.
    
    The assembly code here is:
    
    ffffffff80b885a0 <serial8250_handle_irq>:
    ffffffff80b885a0:       c8a00003        bbit0   a1,0x0,ffffffff80b885b0 <serial8250_handle_irq+0x10>
    ffffffff80b885a4:       0000102d        move    v0,zero
    ffffffff80b885a8:       03e00008        jr      ra
    ffffffff80b885ac:       00000000        nop
    ffffffff80b885b0:       67bdffd0        daddiu  sp,sp,-48
    ffffffff80b885b4:       ffb00008        sd      s0,8(sp)
    
    The second problem was the compiler was putting the last
    instruction of the frame save in the delay slot of the
    jump instruction.  If it saved the RA in there, the
    backtrace could would miss it and misinterpret the frame.
    To fix this, make sure to process the instruction after
    the first jump seen.
    
    The assembly code for this is:
    
    ffffffff80806fd0 <plat_irq_dispatch>:
    ffffffff80806fd0:       67bdffd0        daddiu  sp,sp,-48
    ffffffff80806fd4:       ffb30020        sd      s3,32(sp)
    ffffffff80806fd8:       24130018        li      s3,24
    ffffffff80806fdc:       ffb20018        sd      s2,24(sp)
    ffffffff80806fe0:       3c12811c        lui     s2,0x811c
    ffffffff80806fe4:       ffb10010        sd      s1,16(sp)
    ffffffff80806fe8:       3c11811c        lui     s1,0x811c
    ffffffff80806fec:       ffb00008        sd      s0,8(sp)
    ffffffff80806ff0:       3c10811c        lui     s0,0x811c
    ffffffff80806ff4:       08201c03        j       ffffffff8080700c <plat_irq_dispa
    tch+0x3c>
    ffffffff80806ff8:       ffbf0028        sd      ra,40(sp)
    
    Signed-off-by: Corey Minyard <cminyard@mvista.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/16992/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 5351e1f3950d..a1d930a8705b 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -349,6 +349,7 @@ static int get_frame_info(struct mips_frame_info *info)
 	union mips_instruction insn, *ip, *ip_end;
 	const unsigned int max_insns = 128;
 	unsigned int i;
+	bool saw_jump = false;
 
 	info->pc_offset = -1;
 	info->frame_size = 0;
@@ -370,9 +371,6 @@ static int get_frame_info(struct mips_frame_info *info)
 			insn.word = ip->word;
 		}
 
-		if (is_jump_ins(&insn))
-			break;
-
 		if (!info->frame_size) {
 			if (is_sp_move_ins(&insn))
 			{
@@ -396,10 +394,28 @@ static int get_frame_info(struct mips_frame_info *info)
 				info->frame_size = - ip->i_format.simmediate;
 			}
 			continue;
+		} else if (!saw_jump && is_jump_ins(ip)) {
+			/*
+			 * If we see a jump instruction, we are finished
+			 * with the frame save.
+			 *
+			 * Some functions can have a shortcut return at
+			 * the beginning of the function, so don't start
+			 * looking for jump instruction until we see the
+			 * frame setup.
+			 *
+			 * The RA save instruction can get put into the
+			 * delay slot of the jump instruction, so look
+			 * at the next instruction, too.
+			 */
+			saw_jump = true;
+			continue;
 		}
 		if (info->pc_offset == -1 &&
 		    is_ra_save_ins(&insn, &info->pc_offset))
 			break;
+		if (saw_jump)
+			break;
 	}
 	if (info->frame_size && info->pc_offset >= 0) /* nested */
 		return 0;

commit b0f5a8f32e8bbdaae1abb8abe2d3cbafaba57e08
Author: Vegard Nossum <vegard.nossum@oracle.com>
Date:   Mon May 29 09:22:07 2017 +0200

    kthread: fix boot hang (regression) on MIPS/OpenRISC
    
    This fixes a regression in commit 4d6501dce079 where I didn't notice
    that MIPS and OpenRISC were reinitialising p->{set,clear}_child_tid to
    NULL after our initialisation in copy_process().
    
    We can simply get rid of the arch-specific initialisation here since it
    is now always done in copy_process() before hitting copy_thread{,_tls}().
    
    Review notes:
    
     - As far as I can tell, copy_process() is the only user of
       copy_thread_tls(), which is the only caller of copy_thread() for
       architectures that don't implement copy_thread_tls().
    
     - After this patch, there is no arch-specific code touching
       p->set_child_tid or p->clear_child_tid whatsoever.
    
     - It may look like MIPS/OpenRISC wanted to always have these fields be
       NULL, but that's not true, as copy_process() would unconditionally
       set them again _after_ calling copy_thread_tls() before commit
       4d6501dce079.
    
    Fixes: 4d6501dce079c1eb6bf0b1d8f528a5e81770109e ("kthread: Fix use-after-free if kthread fork fails")
    Reported-by: Guenter Roeck <linux@roeck-us.net>
    Tested-by: Guenter Roeck <linux@roeck-us.net> # MIPS only
    Acked-by: Stafford Horne <shorne@gmail.com>
    Acked-by: Oleg Nesterov <oleg@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>
    Cc: openrisc@lists.librecores.org
    Cc: Jamie Iles <jamie.iles@oracle.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Vegard Nossum <vegard.nossum@oracle.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 918d4c73e951..5351e1f3950d 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -120,7 +120,6 @@ int copy_thread_tls(unsigned long clone_flags, unsigned long usp,
 	struct thread_info *ti = task_thread_info(p);
 	struct pt_regs *childregs, *regs = current_pt_regs();
 	unsigned long childksp;
-	p->set_child_tid = p->clear_child_tid = NULL;
 
 	childksp = (unsigned long)task_stack_page(p) + THREAD_SIZE - 32;
 

commit f9c4e3a6dae1a3a15055ea478438cdc0352e1af2
Author: James Cowgill <James.Cowgill@imgtec.com>
Date:   Fri Mar 31 17:09:58 2017 +0100

    MIPS: Opt into HAVE_COPY_THREAD_TLS
    
    This the mips version of commit c1bd55f922a2d ("x86: opt into
    HAVE_COPY_THREAD_TLS, for both 32-bit and 64-bit").
    
    Simply use the tls system call argument instead of extracting the tls
    argument by magic from the pt_regs structure.
    
    See commit 3033f14ab78c3 ("clone: support passing tls argument via C
    rather than pt_regs magic") for more background.
    
    Signed-off-by: James Cowgill <James.Cowgill@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/15855/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index b68e10fc453d..918d4c73e951 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -114,8 +114,8 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
 /*
  * Copy architecture-specific thread state
  */
-int copy_thread(unsigned long clone_flags, unsigned long usp,
-	unsigned long kthread_arg, struct task_struct *p)
+int copy_thread_tls(unsigned long clone_flags, unsigned long usp,
+	unsigned long kthread_arg, struct task_struct *p, unsigned long tls)
 {
 	struct thread_info *ti = task_thread_info(p);
 	struct pt_regs *childregs, *regs = current_pt_regs();
@@ -176,7 +176,7 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 	atomic_set(&p->thread.bd_emu_frame, BD_EMUFRAME_NONE);
 
 	if (clone_flags & CLONE_SETTLS)
-		ti->tp_value = regs->regs[7];
+		ti->tp_value = tls;
 
 	return 0;
 }

commit db8466c581cca1a08b505f1319c3ecd246f16fa8
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Tue Mar 21 14:52:25 2017 +0000

    MIPS: IRQ Stack: Unwind IRQ stack onto task stack
    
    When the separate IRQ stack was introduced, stack unwinding only
    proceeded as far as the top of the IRQ stack, leading to kernel
    backtraces being less useful, lacking the trace of what was interrupted.
    
    Fix this by providing a means for the kernel to unwind the IRQ stack
    onto the interrupted task stack. The processor state is saved to the
    kernel task stack on interrupt. The IRQ_STACK_START macro reserves an
    unsigned long at the top of the IRQ stack where the interrupted task
    stack pointer can be saved. After the active stack is switched to the
    IRQ stack, save the interrupted tasks stack pointer to the reserved
    location.
    
    Fix the stack unwinding code to look for the frame being the top of the
    IRQ stack and if so get the next frame from the saved location. The
    existing test does not work with the separate stack since the ra is no
    longer pointed at ret_from_{irq,exception}.
    
    The test to stop unwinding the stack 32 bytes from the top of a stack
    must be modified to allow unwinding to continue up to the location of
    the saved task stack pointer when on the IRQ stack. The low / high marks
    of the stack are set depending on whether the sp is on an irq stack or
    not.
    
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Paolo Bonzini <pbonzini@redhat.com>
    Cc: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: Masanari Iida <standby24x7@gmail.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Ingo Molnar <mingo@kernel.org>
    Cc: Jason A. Donenfeld <jason@zx2c4.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/15788/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index fb6b6b650719..b68e10fc453d 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -488,31 +488,52 @@ unsigned long notrace unwind_stack_by_address(unsigned long stack_page,
 					      unsigned long pc,
 					      unsigned long *ra)
 {
+	unsigned long low, high, irq_stack_high;
 	struct mips_frame_info info;
 	unsigned long size, ofs;
+	struct pt_regs *regs;
 	int leaf;
-	extern void ret_from_irq(void);
-	extern void ret_from_exception(void);
 
 	if (!stack_page)
 		return 0;
 
 	/*
-	 * If we reached the bottom of interrupt context,
-	 * return saved pc in pt_regs.
+	 * IRQ stacks start at IRQ_STACK_START
+	 * task stacks at THREAD_SIZE - 32
 	 */
-	if (pc == (unsigned long)ret_from_irq ||
-	    pc == (unsigned long)ret_from_exception) {
-		struct pt_regs *regs;
-		if (*sp >= stack_page &&
-		    *sp + sizeof(*regs) <= stack_page + THREAD_SIZE - 32) {
-			regs = (struct pt_regs *)*sp;
-			pc = regs->cp0_epc;
-			if (!user_mode(regs) && __kernel_text_address(pc)) {
-				*sp = regs->regs[29];
-				*ra = regs->regs[31];
-				return pc;
-			}
+	low = stack_page;
+	if (!preemptible() && on_irq_stack(raw_smp_processor_id(), *sp)) {
+		high = stack_page + IRQ_STACK_START;
+		irq_stack_high = high;
+	} else {
+		high = stack_page + THREAD_SIZE - 32;
+		irq_stack_high = 0;
+	}
+
+	/*
+	 * If we reached the top of the interrupt stack, start unwinding
+	 * the interrupted task stack.
+	 */
+	if (unlikely(*sp == irq_stack_high)) {
+		unsigned long task_sp = *(unsigned long *)*sp;
+
+		/*
+		 * Check that the pointer saved in the IRQ stack head points to
+		 * something within the stack of the current task
+		 */
+		if (!object_is_on_stack((void *)task_sp))
+			return 0;
+
+		/*
+		 * Follow pointer to tasks kernel stack frame where interrupted
+		 * state was saved.
+		 */
+		regs = (struct pt_regs *)task_sp;
+		pc = regs->cp0_epc;
+		if (!user_mode(regs) && __kernel_text_address(pc)) {
+			*sp = regs->regs[29];
+			*ra = regs->regs[31];
+			return pc;
 		}
 		return 0;
 	}
@@ -533,8 +554,7 @@ unsigned long notrace unwind_stack_by_address(unsigned long stack_page,
 	if (leaf < 0)
 		return 0;
 
-	if (*sp < stack_page ||
-	    *sp + info.frame_size > stack_page + THREAD_SIZE - 32)
+	if (*sp < low || *sp + info.frame_size > high)
 		return 0;
 
 	if (leaf)

commit 68db0cf10678630d286f4bbbbdfa102951a35faa
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:37 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/task_stack.h>
    
    We are going to split <linux/sched/task_stack.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/task_stack.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 8bfb833b3158..fb6b6b650719 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -13,6 +13,7 @@
 #include <linux/sched.h>
 #include <linux/sched/debug.h>
 #include <linux/sched/task.h>
+#include <linux/sched/task_stack.h>
 #include <linux/tick.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>

commit 299300258d1bc4e997b7db340a2e06636757fe2e
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:36 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/task.h>
    
    We are going to split <linux/sched/task.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/task.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 97574cdb532d..8bfb833b3158 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -12,6 +12,7 @@
 #include <linux/errno.h>
 #include <linux/sched.h>
 #include <linux/sched/debug.h>
+#include <linux/sched/task.h>
 #include <linux/tick.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>

commit b17b01533b719e9949e437abf66436a875739b40
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:35 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/debug.h>
    
    We are going to split <linux/sched/debug.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/debug.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 803e255b6fc3..97574cdb532d 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -11,6 +11,7 @@
  */
 #include <linux/errno.h>
 #include <linux/sched.h>
+#include <linux/sched/debug.h>
 #include <linux/tick.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>

commit 08c941bf6ec523d666a78f86e3d696ed45dfb6e5
Author: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
Date:   Mon Nov 21 11:23:38 2016 +0100

    MIPS: Move register dump routines out of ptrace code
    
    Current register dump methods for MIPS are implemented inside ptrace
    methods, but there will be other uses in the kernel for them, so keep
    them separately in process.c and use those definitions for ptrace
    instead.
    
    Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/14587/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 3da0161bdf84..803e255b6fc3 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -729,3 +729,47 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 
 	return 0;
 }
+
+#if defined(CONFIG_32BIT) || defined(CONFIG_MIPS32_O32)
+void mips_dump_regs32(u32 *uregs, const struct pt_regs *regs)
+{
+	unsigned int i;
+
+	for (i = MIPS32_EF_R1; i <= MIPS32_EF_R31; i++) {
+		/* k0/k1 are copied as zero. */
+		if (i == MIPS32_EF_R26 || i == MIPS32_EF_R27)
+			uregs[i] = 0;
+		else
+			uregs[i] = regs->regs[i - MIPS32_EF_R0];
+	}
+
+	uregs[MIPS32_EF_LO] = regs->lo;
+	uregs[MIPS32_EF_HI] = regs->hi;
+	uregs[MIPS32_EF_CP0_EPC] = regs->cp0_epc;
+	uregs[MIPS32_EF_CP0_BADVADDR] = regs->cp0_badvaddr;
+	uregs[MIPS32_EF_CP0_STATUS] = regs->cp0_status;
+	uregs[MIPS32_EF_CP0_CAUSE] = regs->cp0_cause;
+}
+#endif /* CONFIG_32BIT || CONFIG_MIPS32_O32 */
+
+#ifdef CONFIG_64BIT
+void mips_dump_regs64(u64 *uregs, const struct pt_regs *regs)
+{
+	unsigned int i;
+
+	for (i = MIPS64_EF_R1; i <= MIPS64_EF_R31; i++) {
+		/* k0/k1 are copied as zero. */
+		if (i == MIPS64_EF_R26 || i == MIPS64_EF_R27)
+			uregs[i] = 0;
+		else
+			uregs[i] = regs->regs[i - MIPS64_EF_R0];
+	}
+
+	uregs[MIPS64_EF_LO] = regs->lo;
+	uregs[MIPS64_EF_HI] = regs->hi;
+	uregs[MIPS64_EF_CP0_EPC] = regs->cp0_epc;
+	uregs[MIPS64_EF_CP0_BADVADDR] = regs->cp0_badvaddr;
+	uregs[MIPS64_EF_CP0_STATUS] = regs->cp0_status;
+	uregs[MIPS64_EF_CP0_CAUSE] = regs->cp0_cause;
+}
+#endif /* CONFIG_64BIT */

commit a00eeede507c975087b7b8df8cf2c9f88ba285de
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Fri Nov 4 09:28:56 2016 +0000

    MIPS: SMP: Use a completion event to signal CPU up
    
    If a secondary CPU failed to start, for any reason, the CPU requesting
    the secondary to start would get stuck in the loop waiting for the
    secondary to be present in the cpu_callin_map.
    
    Rather than that, use a completion event to signal that the secondary
    CPU has started and is waiting to synchronise counters.
    
    Since the CPU presence will no longer be marked in cpu_callin_map,
    remove the redundant test from arch_cpu_idle_dead().
    
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Cc: Maciej W. Rozycki <macro@imgtec.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Paul Gortmaker <paul.gortmaker@windriver.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Qais Yousef <qsyousef@gmail.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/14502/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index efa1df52c616..3da0161bdf84 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -50,9 +50,7 @@
 #ifdef CONFIG_HOTPLUG_CPU
 void arch_cpu_idle_dead(void)
 {
-	/* What the heck is this check doing ? */
-	if (!cpumask_test_cpu(smp_processor_id(), &cpu_callin_map))
-		play_dead();
+	play_dead();
 }
 #endif
 

commit 096a0de427ea333f56f0ee00328cff2a2731bcf1
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Nov 7 15:07:07 2016 +0000

    MIPS: Handle microMIPS jumps in the same way as MIPS32/MIPS64 jumps
    
    is_jump_ins() checks for plain jump ("j") instructions since commit
    e7438c4b893e ("MIPS: Fix sibling call handling in get_frame_info") but
    that commit didn't make the same change to the microMIPS code, leaving
    it inconsistent with the MIPS32/MIPS64 code. Handle the microMIPS
    encoding of the jump instruction too such that it behaves consistently.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Fixes: e7438c4b893e ("MIPS: Fix sibling call handling in get_frame_info")
    Cc: Tony Wu <tung7970@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: <stable@vger.kernel.org> # v3.10+
    Patchwork: https://patchwork.linux-mips.org/patch/14533/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 801b399d4861..efa1df52c616 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -294,6 +294,8 @@ static inline int is_jump_ins(union mips_instruction *ip)
 		return 0;
 	}
 
+	if (ip->j_format.opcode == mm_j32_op)
+		return 1;
 	if (ip->j_format.opcode == mm_jal32_op)
 		return 1;
 	if (ip->r_format.opcode != mm_pool32a_op ||

commit bb9bc4689b9c635714fbcd5d335bad9934a7ebfc
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Nov 7 15:07:06 2016 +0000

    MIPS: Calculate microMIPS ra properly when unwinding the stack
    
    get_frame_info() calculates the offset of the return address within a
    stack frame simply by dividing a the bottom 16 bits of the instruction,
    treated as a signed integer, by the size of a long. Whilst this works
    for MIPS32 & MIPS64 ISAs where the sw or sd instructions are used, it's
    incorrect for microMIPS where encodings differ. The result is that we
    typically completely fail to unwind the stack on microMIPS.
    
    Fix this by adjusting is_ra_save_ins() to calculate the return address
    offset, and take into account the various different encodings there in
    the same place as we consider whether an instruction is storing the
    ra/$31 register.
    
    With this we are now able to unwind the stack for kernels targetting the
    microMIPS ISA, for example we can produce:
    
        Call Trace:
        [<80109e1f>] show_stack+0x63/0x7c
        [<8011ea17>] __warn+0x9b/0xac
        [<8011ea45>] warn_slowpath_fmt+0x1d/0x20
        [<8013fe53>] register_console+0x43/0x314
        [<8067c58d>] of_setup_earlycon+0x1dd/0x1ec
        [<8067f63f>] early_init_dt_scan_chosen_stdout+0xe7/0xf8
        [<8066c115>] do_early_param+0x75/0xac
        [<801302f9>] parse_args+0x1dd/0x308
        [<8066c459>] parse_early_options+0x25/0x28
        [<8066c48b>] parse_early_param+0x2f/0x38
        [<8066e8cf>] setup_arch+0x113/0x488
        [<8066c4f3>] start_kernel+0x57/0x328
        ---[ end trace 0000000000000000 ]---
    
    Whereas previously we only produced:
    
        Call Trace:
        [<80109e1f>] show_stack+0x63/0x7c
        ---[ end trace 0000000000000000 ]---
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Fixes: 34c2f668d0f6 ("MIPS: microMIPS: Add unaligned access support.")
    Cc: Leonid Yegoshin <leonid.yegoshin@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: <stable@vger.kernel.org> # v3.10+
    Patchwork: https://patchwork.linux-mips.org/patch/14532/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index e03113493580..801b399d4861 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -196,7 +196,7 @@ struct mips_frame_info {
 #define J_TARGET(pc,target)	\
 		(((unsigned long)(pc) & 0xf0000000) | ((target) << 2))
 
-static inline int is_ra_save_ins(union mips_instruction *ip)
+static inline int is_ra_save_ins(union mips_instruction *ip, int *poff)
 {
 #ifdef CONFIG_CPU_MICROMIPS
 	/*
@@ -209,25 +209,70 @@ static inline int is_ra_save_ins(union mips_instruction *ip)
 	 * microMIPS is way more fun...
 	 */
 	if (mm_insn_16bit(ip->halfword[1])) {
-		return (ip->mm16_r5_format.opcode == mm_swsp16_op &&
-			ip->mm16_r5_format.rt == 31) ||
-		       (ip->mm16_m_format.opcode == mm_pool16c_op &&
-			ip->mm16_m_format.func == mm_swm16_op);
+		switch (ip->mm16_r5_format.opcode) {
+		case mm_swsp16_op:
+			if (ip->mm16_r5_format.rt != 31)
+				return 0;
+
+			*poff = ip->mm16_r5_format.simmediate;
+			*poff = (*poff << 2) / sizeof(ulong);
+			return 1;
+
+		case mm_pool16c_op:
+			switch (ip->mm16_m_format.func) {
+			case mm_swm16_op:
+				*poff = ip->mm16_m_format.imm;
+				*poff += 1 + ip->mm16_m_format.rlist;
+				*poff = (*poff << 2) / sizeof(ulong);
+				return 1;
+
+			default:
+				return 0;
+			}
+
+		default:
+			return 0;
+		}
 	}
-	else {
-		return (ip->mm_m_format.opcode == mm_pool32b_op &&
-			ip->mm_m_format.rd > 9 &&
-			ip->mm_m_format.base == 29 &&
-			ip->mm_m_format.func == mm_swm32_func) ||
-		       (ip->i_format.opcode == mm_sw32_op &&
-			ip->i_format.rs == 29 &&
-			ip->i_format.rt == 31);
+
+	switch (ip->i_format.opcode) {
+	case mm_sw32_op:
+		if (ip->i_format.rs != 29)
+			return 0;
+		if (ip->i_format.rt != 31)
+			return 0;
+
+		*poff = ip->i_format.simmediate / sizeof(ulong);
+		return 1;
+
+	case mm_pool32b_op:
+		switch (ip->mm_m_format.func) {
+		case mm_swm32_func:
+			if (ip->mm_m_format.rd < 0x10)
+				return 0;
+			if (ip->mm_m_format.base != 29)
+				return 0;
+
+			*poff = ip->mm_m_format.simmediate;
+			*poff += (ip->mm_m_format.rd & 0xf) * sizeof(u32);
+			*poff /= sizeof(ulong);
+			return 1;
+		default:
+			return 0;
+		}
+
+	default:
+		return 0;
 	}
 #else
 	/* sw / sd $ra, offset($sp) */
-	return (ip->i_format.opcode == sw_op || ip->i_format.opcode == sd_op) &&
-		ip->i_format.rs == 29 &&
-		ip->i_format.rt == 31;
+	if ((ip->i_format.opcode == sw_op || ip->i_format.opcode == sd_op) &&
+		ip->i_format.rs == 29 && ip->i_format.rt == 31) {
+		*poff = ip->i_format.simmediate / sizeof(ulong);
+		return 1;
+	}
+
+	return 0;
 #endif
 }
 
@@ -350,11 +395,9 @@ static int get_frame_info(struct mips_frame_info *info)
 			}
 			continue;
 		}
-		if (info->pc_offset == -1 && is_ra_save_ins(&insn)) {
-			info->pc_offset =
-				ip->i_format.simmediate / sizeof(long);
+		if (info->pc_offset == -1 &&
+		    is_ra_save_ins(&insn, &info->pc_offset))
 			break;
-		}
 	}
 	if (info->frame_size && info->pc_offset >= 0) /* nested */
 		return 0;

commit 67c75057709a6d85c681c78b9b2f9b71191f01a2
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Nov 7 15:07:05 2016 +0000

    MIPS: Fix is_jump_ins() handling of 16b microMIPS instructions
    
    is_jump_ins() checks 16b instruction fields without verifying that the
    instruction is indeed 16b, as is done by is_ra_save_ins() &
    is_sp_move_ins(). Add the appropriate check.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Fixes: 34c2f668d0f6 ("MIPS: microMIPS: Add unaligned access support.")
    Cc: Leonid Yegoshin <leonid.yegoshin@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: <stable@vger.kernel.org> # v3.10+
    Patchwork: https://patchwork.linux-mips.org/patch/14531/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 9f7a19ca1d4c..e03113493580 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -242,9 +242,14 @@ static inline int is_jump_ins(union mips_instruction *ip)
 	 *
 	 * microMIPS is kind of more fun...
 	 */
-	if ((ip->mm16_r5_format.opcode == mm_pool16c_op &&
-	    (ip->mm16_r5_format.rt & mm_jr16_op) == mm_jr16_op) ||
-	    ip->j_format.opcode == mm_jal32_op)
+	if (mm_insn_16bit(ip->halfword[1])) {
+		if ((ip->mm16_r5_format.opcode == mm_pool16c_op &&
+		    (ip->mm16_r5_format.rt & mm_jr16_op) == mm_jr16_op))
+			return 1;
+		return 0;
+	}
+
+	if (ip->j_format.opcode == mm_jal32_op)
 		return 1;
 	if (ip->r_format.opcode != mm_pool32a_op ||
 			ip->r_format.func != mm_pool32axf_op)

commit b6c7a324df37bf05ef7a2c1580683cf10d082d97
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Nov 7 15:07:04 2016 +0000

    MIPS: Fix get_frame_info() handling of microMIPS function size
    
    get_frame_info() is meant to iterate over up to the first 128
    instructions within a function, but for microMIPS kernels it will not
    reach that many instructions unless the function is 512 bytes long since
    we calculate the maximum number of instructions to check by dividing the
    function length by the 4 byte size of a union mips_instruction. In
    microMIPS kernels this won't do since instructions are variable length.
    
    Fix this by instead checking whether the pointer to the current
    instruction has reached the end of the function, and use max_insns as a
    simple constant to check the number of iterations against.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Fixes: 34c2f668d0f6 ("MIPS: microMIPS: Add unaligned access support.")
    Cc: Leonid Yegoshin <leonid.yegoshin@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: <stable@vger.kernel.org> # v3.10+
    Patchwork: https://patchwork.linux-mips.org/patch/14530/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 8dddaef1a345..9f7a19ca1d4c 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -294,9 +294,9 @@ static inline int is_sp_move_ins(union mips_instruction *ip)
 static int get_frame_info(struct mips_frame_info *info)
 {
 	bool is_mmips = IS_ENABLED(CONFIG_CPU_MICROMIPS);
-	union mips_instruction insn, *ip;
-	unsigned max_insns = info->func_size / sizeof(union mips_instruction);
-	unsigned i;
+	union mips_instruction insn, *ip, *ip_end;
+	const unsigned int max_insns = 128;
+	unsigned int i;
 
 	info->pc_offset = -1;
 	info->frame_size = 0;
@@ -305,11 +305,9 @@ static int get_frame_info(struct mips_frame_info *info)
 	if (!ip)
 		goto err;
 
-	if (max_insns == 0)
-		max_insns = 128U;	/* unknown function size */
-	max_insns = min(128U, max_insns);
+	ip_end = (void *)ip + info->func_size;
 
-	for (i = 0; i < max_insns; i++, ip++) {
+	for (i = 0; i < max_insns && ip < ip_end; i++, ip++) {
 		if (is_mmips && mm_insn_16bit(ip->halfword[0])) {
 			insn.halfword[0] = 0;
 			insn.halfword[1] = ip->halfword[0];

commit a3552dace7d1d0cabf573e88fc3025cb90c4a601
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Nov 7 15:07:03 2016 +0000

    MIPS: Prevent unaligned accesses during stack unwinding
    
    During stack unwinding we call a number of functions to determine what
    type of instruction we're looking at. The union mips_instruction pointer
    provided to them may be pointing at a 2 byte, but not 4 byte, aligned
    address & we thus cannot directly access the 4 byte wide members of the
    union mips_instruction. To avoid this is_ra_save_ins() copies the
    required half-words of the microMIPS instruction to a correctly aligned
    union mips_instruction on the stack, which it can then access safely.
    The is_jump_ins() & is_sp_move_ins() functions do not correctly perform
    this temporary copy, and instead attempt to directly dereference 4 byte
    fields which may be misaligned and lead to an address exception.
    
    Fix this by copying the instruction halfwords to a temporary union
    mips_instruction in get_frame_info() such that we can provide a 4 byte
    aligned union mips_instruction to the is_*_ins() functions and they do
    not need to deal with misalignment themselves.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Fixes: 34c2f668d0f6 ("MIPS: microMIPS: Add unaligned access support.")
    Cc: Leonid Yegoshin <leonid.yegoshin@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: <stable@vger.kernel.org> # v3.10+
    Patchwork: https://patchwork.linux-mips.org/patch/14529/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 213278dbbc04..8dddaef1a345 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -199,8 +199,6 @@ struct mips_frame_info {
 static inline int is_ra_save_ins(union mips_instruction *ip)
 {
 #ifdef CONFIG_CPU_MICROMIPS
-	union mips_instruction mmi;
-
 	/*
 	 * swsp ra,offset
 	 * swm16 reglist,offset(sp)
@@ -210,23 +208,20 @@ static inline int is_ra_save_ins(union mips_instruction *ip)
 	 *
 	 * microMIPS is way more fun...
 	 */
-	if (mm_insn_16bit(ip->halfword[0])) {
-		mmi.word = (ip->halfword[0] << 16);
-		return (mmi.mm16_r5_format.opcode == mm_swsp16_op &&
-			mmi.mm16_r5_format.rt == 31) ||
-		       (mmi.mm16_m_format.opcode == mm_pool16c_op &&
-			mmi.mm16_m_format.func == mm_swm16_op);
+	if (mm_insn_16bit(ip->halfword[1])) {
+		return (ip->mm16_r5_format.opcode == mm_swsp16_op &&
+			ip->mm16_r5_format.rt == 31) ||
+		       (ip->mm16_m_format.opcode == mm_pool16c_op &&
+			ip->mm16_m_format.func == mm_swm16_op);
 	}
 	else {
-		mmi.halfword[0] = ip->halfword[1];
-		mmi.halfword[1] = ip->halfword[0];
-		return (mmi.mm_m_format.opcode == mm_pool32b_op &&
-			mmi.mm_m_format.rd > 9 &&
-			mmi.mm_m_format.base == 29 &&
-			mmi.mm_m_format.func == mm_swm32_func) ||
-		       (mmi.i_format.opcode == mm_sw32_op &&
-			mmi.i_format.rs == 29 &&
-			mmi.i_format.rt == 31);
+		return (ip->mm_m_format.opcode == mm_pool32b_op &&
+			ip->mm_m_format.rd > 9 &&
+			ip->mm_m_format.base == 29 &&
+			ip->mm_m_format.func == mm_swm32_func) ||
+		       (ip->i_format.opcode == mm_sw32_op &&
+			ip->i_format.rs == 29 &&
+			ip->i_format.rt == 31);
 	}
 #else
 	/* sw / sd $ra, offset($sp) */
@@ -247,12 +242,8 @@ static inline int is_jump_ins(union mips_instruction *ip)
 	 *
 	 * microMIPS is kind of more fun...
 	 */
-	union mips_instruction mmi;
-
-	mmi.word = (ip->halfword[0] << 16);
-
-	if ((mmi.mm16_r5_format.opcode == mm_pool16c_op &&
-	    (mmi.mm16_r5_format.rt & mm_jr16_op) == mm_jr16_op) ||
+	if ((ip->mm16_r5_format.opcode == mm_pool16c_op &&
+	    (ip->mm16_r5_format.rt & mm_jr16_op) == mm_jr16_op) ||
 	    ip->j_format.opcode == mm_jal32_op)
 		return 1;
 	if (ip->r_format.opcode != mm_pool32a_op ||
@@ -281,15 +272,13 @@ static inline int is_sp_move_ins(union mips_instruction *ip)
 	 *
 	 * microMIPS is not more fun...
 	 */
-	if (mm_insn_16bit(ip->halfword[0])) {
-		union mips_instruction mmi;
-
-		mmi.word = (ip->halfword[0] << 16);
-		return (mmi.mm16_r3_format.opcode == mm_pool16d_op &&
-			mmi.mm16_r3_format.simmediate && mm_addiusp_func) ||
-		       (mmi.mm16_r5_format.opcode == mm_pool16d_op &&
-			mmi.mm16_r5_format.rt == 29);
+	if (mm_insn_16bit(ip->halfword[1])) {
+		return (ip->mm16_r3_format.opcode == mm_pool16d_op &&
+			ip->mm16_r3_format.simmediate && mm_addiusp_func) ||
+		       (ip->mm16_r5_format.opcode == mm_pool16d_op &&
+			ip->mm16_r5_format.rt == 29);
 	}
+
 	return ip->mm_i_format.opcode == mm_addiu32_op &&
 	       ip->mm_i_format.rt == 29 && ip->mm_i_format.rs == 29;
 #else
@@ -304,7 +293,8 @@ static inline int is_sp_move_ins(union mips_instruction *ip)
 
 static int get_frame_info(struct mips_frame_info *info)
 {
-	union mips_instruction *ip;
+	bool is_mmips = IS_ENABLED(CONFIG_CPU_MICROMIPS);
+	union mips_instruction insn, *ip;
 	unsigned max_insns = info->func_size / sizeof(union mips_instruction);
 	unsigned i;
 
@@ -320,11 +310,21 @@ static int get_frame_info(struct mips_frame_info *info)
 	max_insns = min(128U, max_insns);
 
 	for (i = 0; i < max_insns; i++, ip++) {
+		if (is_mmips && mm_insn_16bit(ip->halfword[0])) {
+			insn.halfword[0] = 0;
+			insn.halfword[1] = ip->halfword[0];
+		} else if (is_mmips) {
+			insn.halfword[0] = ip->halfword[1];
+			insn.halfword[1] = ip->halfword[0];
+		} else {
+			insn.word = ip->word;
+		}
 
-		if (is_jump_ins(ip))
+		if (is_jump_ins(&insn))
 			break;
+
 		if (!info->frame_size) {
-			if (is_sp_move_ins(ip))
+			if (is_sp_move_ins(&insn))
 			{
 #ifdef CONFIG_CPU_MICROMIPS
 				if (mm_insn_16bit(ip->halfword[0]))
@@ -347,7 +347,7 @@ static int get_frame_info(struct mips_frame_info *info)
 			}
 			continue;
 		}
-		if (info->pc_offset == -1 && is_ra_save_ins(ip)) {
+		if (info->pc_offset == -1 && is_ra_save_ins(&insn)) {
 			info->pc_offset =
 				ip->i_format.simmediate / sizeof(long);
 			break;

commit ccaf7caf2c73c6db920772bf08bf1d47b2170634
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Nov 7 15:07:02 2016 +0000

    MIPS: Clear ISA bit correctly in get_frame_info()
    
    get_frame_info() can be called in microMIPS kernels with the ISA bit
    already clear. For example this happens when unwind_stack_by_address()
    is called because we begin with a PC that has the ISA bit set & subtract
    the (odd) offset from the preceding symbol (which does not have the ISA
    bit set). Since get_frame_info() unconditionally subtracts 1 from the PC
    in microMIPS kernels it incorrectly misaligns the address it then
    attempts to access code at, leading to an address error exception.
    
    Fix this by using msk_isa16_mode() to clear the ISA bit, which allows
    get_frame_info() to function regardless of whether it is provided with a
    PC that has the ISA bit set or not.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Fixes: 34c2f668d0f6 ("MIPS: microMIPS: Add unaligned access support.")
    Cc: Leonid Yegoshin <leonid.yegoshin@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: <stable@vger.kernel.org> # v3.10+
    Patchwork: https://patchwork.linux-mips.org/patch/14528/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 48e30e0469ef..213278dbbc04 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -304,17 +304,14 @@ static inline int is_sp_move_ins(union mips_instruction *ip)
 
 static int get_frame_info(struct mips_frame_info *info)
 {
-#ifdef CONFIG_CPU_MICROMIPS
-	union mips_instruction *ip = (void *) (((char *) info->func) - 1);
-#else
-	union mips_instruction *ip = info->func;
-#endif
+	union mips_instruction *ip;
 	unsigned max_insns = info->func_size / sizeof(union mips_instruction);
 	unsigned i;
 
 	info->pc_offset = -1;
 	info->frame_size = 0;
 
+	ip = (void *)msk_isa16_mode((ulong)info->func);
 	if (!ip)
 		goto err;
 

commit d42d8d106b0275b027c1e8992c42aecf933436ea
Author: Matt Redfearn <matt.redfearn@imgtec.com>
Date:   Mon Dec 19 14:20:57 2016 +0000

    MIPS: Stack unwinding while on IRQ stack
    
    Within unwind stack, check if the stack pointer being unwound is within
    the CPU's irq_stack and if so use that page rather than the task's stack
    page.
    
    Signed-off-by: Matt Redfearn <matt.redfearn@imgtec.com>
    Acked-by: Jason A. Donenfeld <jason@zx2c4.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Adam Buchbinder <adam.buchbinder@gmail.com>
    Cc: Maciej W. Rozycki <macro@imgtec.com>
    Cc: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/14741/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 5142b1dfe8a7..48e30e0469ef 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -33,6 +33,7 @@
 #include <asm/dsemul.h>
 #include <asm/dsp.h>
 #include <asm/fpu.h>
+#include <asm/irq.h>
 #include <asm/msa.h>
 #include <asm/pgtable.h>
 #include <asm/mipsregs.h>
@@ -511,7 +512,19 @@ EXPORT_SYMBOL(unwind_stack_by_address);
 unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
 			   unsigned long pc, unsigned long *ra)
 {
-	unsigned long stack_page = (unsigned long)task_stack_page(task);
+	unsigned long stack_page = 0;
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		if (on_irq_stack(cpu, *sp)) {
+			stack_page = (unsigned long)irq_stack[cpu];
+			break;
+		}
+	}
+
+	if (!stack_page)
+		stack_page = (unsigned long)task_stack_page(task);
+
 	return unwind_stack_by_address(stack_page, sp, pc, ra);
 }
 #endif

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 9514e5f2209f..5142b1dfe8a7 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -38,7 +38,7 @@
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
 #include <asm/reg.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/io.h>
 #include <asm/elf.h>
 #include <asm/isadep.h>

commit 9a01c3ed5cdb35d9004eb92510ee6ea11b4a5f16
Author: Chris Metcalf <cmetcalf@mellanox.com>
Date:   Fri Oct 7 17:02:45 2016 -0700

    nmi_backtrace: add more trigger_*_cpu_backtrace() methods
    
    Patch series "improvements to the nmi_backtrace code" v9.
    
    This patch series modifies the trigger_xxx_backtrace() NMI-based remote
    backtracing code to make it more flexible, and makes a few small
    improvements along the way.
    
    The motivation comes from the task isolation code, where there are
    scenarios where we want to be able to diagnose a case where some cpu is
    about to interrupt a task-isolated cpu.  It can be helpful to see both
    where the interrupting cpu is, and also an approximation of where the
    cpu that is being interrupted is.  The nmi_backtrace framework allows us
    to discover the stack of the interrupted cpu.
    
    I've tested that the change works as desired on tile, and build-tested
    x86, arm, mips, and sparc64.  For x86 I confirmed that the generic
    cpuidle stuff as well as the architecture-specific routines are in the
    new cpuidle section.  For arm, mips, and sparc I just build-tested it
    and made sure the generic cpuidle routines were in the new cpuidle
    section, but I didn't attempt to figure out which the platform-specific
    idle routines might be.  That might be more usefully done by someone
    with platform experience in follow-up patches.
    
    This patch (of 4):
    
    Currently you can only request a backtrace of either all cpus, or all
    cpus but yourself.  It can also be helpful to request a remote backtrace
    of a single cpu, and since we want that, the logical extension is to
    support a cpumask as the underlying primitive.
    
    This change modifies the existing lib/nmi_backtrace.c code to take a
    cpumask as its basic primitive, and modifies the linux/nmi.h code to use
    the new "cpumask" method instead.
    
    The existing clients of nmi_backtrace (arm and x86) are converted to
    using the new cpumask approach in this change.
    
    The other users of the backtracing API (sparc64 and mips) are converted
    to use the cpumask approach rather than the all/allbutself approach.
    The mips code ignored the "include_self" boolean but with this change it
    will now also dump a local backtrace if requested.
    
    Link: http://lkml.kernel.org/r/1472487169-14923-2-git-send-email-cmetcalf@mellanox.com
    Signed-off-by: Chris Metcalf <cmetcalf@mellanox.com>
    Tested-by: Daniel Thompson <daniel.thompson@linaro.org> [arm]
    Reviewed-by: Aaron Tomlin <atomlin@redhat.com>
    Reviewed-by: Petr Mladek <pmladek@suse.com>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: David Miller <davem@davemloft.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index d2d061520a23..9514e5f2209f 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -569,9 +569,16 @@ static void arch_dump_stack(void *info)
 	dump_stack();
 }
 
-void arch_trigger_all_cpu_backtrace(bool include_self)
+void arch_trigger_cpumask_backtrace(const cpumask_t *mask, bool exclude_self)
 {
-	smp_call_function(arch_dump_stack, NULL, 1);
+	long this_cpu = get_cpu();
+
+	if (cpumask_test_cpu(this_cpu, mask) && !exclude_self)
+		dump_stack();
+
+	smp_call_function_many(mask, arch_dump_stack, NULL, 1);
+
+	put_cpu();
 }
 
 int mips_get_process_fp_mode(struct task_struct *task)

commit b244614a60ab7ce54c12a9cbe15cfbf8d79d0967
Author: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
Date:   Wed Aug 31 12:33:23 2016 +0200

    MIPS: Avoid a BUG warning during prctl(PR_SET_FP_MODE, ...)
    
    cpu_has_fpu macro uses smp_processor_id() and is currently executed
    with preemption enabled, that triggers the warning at runtime.
    
    It is assumed throughout the kernel that if any CPU has an FPU, then all
    CPUs would have an FPU as well, so it is safe to perform the check with
    preemption enabled - change the code to use raw_ variant of the check to
    avoid the warning.
    
    Signed-off-by: Marcin Nowakowski <marcin.nowakowski@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: stable@vger.kernel.org  # 4.0+
    Patchwork: https://patchwork.linux-mips.org/patch/14125/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 7429ad09fbe3..d2d061520a23 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -605,14 +605,14 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 		return -EOPNOTSUPP;
 
 	/* Avoid inadvertently triggering emulation */
-	if ((value & PR_FP_MODE_FR) && cpu_has_fpu &&
-	    !(current_cpu_data.fpu_id & MIPS_FPIR_F64))
+	if ((value & PR_FP_MODE_FR) && raw_cpu_has_fpu &&
+	    !(raw_current_cpu_data.fpu_id & MIPS_FPIR_F64))
 		return -EOPNOTSUPP;
-	if ((value & PR_FP_MODE_FRE) && cpu_has_fpu && !cpu_has_fre)
+	if ((value & PR_FP_MODE_FRE) && raw_cpu_has_fpu && !cpu_has_fre)
 		return -EOPNOTSUPP;
 
 	/* FR = 0 not supported in MIPS R6 */
-	if (!(value & PR_FP_MODE_FR) && cpu_has_fpu && cpu_has_mips_r6)
+	if (!(value & PR_FP_MODE_FR) && raw_cpu_has_fpu && cpu_has_mips_r6)
 		return -EOPNOTSUPP;
 
 	/* Proceed with the mode switch */

commit 432c6bacbd0c16ec210c43da411ccc3855c4c010
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Jul 8 11:06:19 2016 +0100

    MIPS: Use per-mm page to execute branch delay slot instructions
    
    In some cases the kernel needs to execute an instruction from the delay
    slot of an emulated branch instruction. These cases include:
    
      - Emulated floating point branch instructions (bc1[ft]l?) for systems
        which don't include an FPU, or upon which the kernel is run with the
        "nofpu" parameter.
    
      - MIPSr6 systems running binaries targeting older revisions of the
        architecture, which may include branch instructions whose encodings
        are no longer valid in MIPSr6.
    
    Executing instructions from such delay slots is done by writing the
    instruction to memory followed by a trap, as part of an "emuframe", and
    executing it. This avoids the requirement of an emulator for the entire
    MIPS instruction set. Prior to this patch such emuframes are written to
    the user stack and executed from there.
    
    This patch moves FP branch delay emuframes off of the user stack and
    into a per-mm page. Allocating a page per-mm leaves userland with access
    to only what it had access to previously, and compared to other
    solutions is relatively simple.
    
    When a thread requires a delay slot emulation, it is allocated a frame.
    A thread may only have one frame allocated at any one time, since it may
    only ever be executing one instruction at any one time. In order to
    ensure that we can free up allocated frame later, its index is recorded
    in struct thread_struct. In the typical case, after executing the delay
    slot instruction we'll execute a break instruction with the BRK_MEMU
    code. This traps back to the kernel & leads to a call to do_dsemulret
    which frees the allocated frame & moves the user PC back to the
    instruction that would have executed following the emulated branch.
    In some cases the delay slot instruction may be invalid, such as a
    branch, or may trigger an exception. In these cases the BRK_MEMU break
    instruction will not be hit. In order to ensure that frames are freed
    this patch introduces dsemul_thread_cleanup() and calls it to free any
    allocated frame upon thread exit. If the instruction generated an
    exception & leads to a signal being delivered to the thread, or indeed
    if a signal simply happens to be delivered to the thread whilst it is
    executing from the struct emuframe, then we need to take care to exit
    the frame appropriately. This is done by either rolling back the user PC
    to the branch or advancing it to the continuation PC prior to signal
    delivery, using dsemul_thread_rollback(). If this were not done then a
    sigreturn would return to the struct emuframe, and if that frame had
    meanwhile been used in response to an emulated branch instruction within
    the signal handler then we would execute the wrong user code.
    
    Whilst a user could theoretically place something like a compact branch
    to self in a delay slot and cause their thread to become stuck in an
    infinite loop with the frame never being deallocated, this would:
    
      - Only affect the users single process.
    
      - Be architecturally invalid since there would be a branch in the
        delay slot, which is forbidden.
    
      - Be extremely unlikely to happen by mistake, and provide a program
        with no more ability to harm the system than a simple infinite loop
        would.
    
    If a thread requires a delay slot emulation & no frame is available to
    it (ie. the process has enough other threads that all frames are
    currently in use) then the thread joins a waitqueue. It will sleep until
    a frame is freed by another thread in the process.
    
    Since we now know whether a thread has an allocated frame due to our
    tracking of its index, the cookie field of struct emuframe is removed as
    we can be more certain whether we have a valid frame. Since a thread may
    only ever have a single frame at any given time, the epc field of struct
    emuframe is also removed & the PC to continue from is instead stored in
    struct thread_struct. Together these changes simplify & shrink struct
    emuframe somewhat, allowing twice as many frames to fit into the page
    allocated for them.
    
    The primary benefit of this patch is that we are now free to mark the
    user stack non-executable where that is possible.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: Leonid Yegoshin <leonid.yegoshin@imgtec.com>
    Cc: Maciej Rozycki <maciej.rozycki@imgtec.com>
    Cc: Faraz Shahbazker <faraz.shahbazker@imgtec.com>
    Cc: Raghu Gandham <raghu.gandham@imgtec.com>
    Cc: Matthew Fortune <matthew.fortune@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13764/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 813ed7829c61..7429ad09fbe3 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -30,6 +30,7 @@
 #include <asm/asm.h>
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
+#include <asm/dsemul.h>
 #include <asm/dsp.h>
 #include <asm/fpu.h>
 #include <asm/msa.h>
@@ -68,11 +69,22 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 	lose_fpu(0);
 	clear_thread_flag(TIF_MSA_CTX_LIVE);
 	clear_used_math();
+	atomic_set(&current->thread.bd_emu_frame, BD_EMUFRAME_NONE);
 	init_dsp();
 	regs->cp0_epc = pc;
 	regs->regs[29] = sp;
 }
 
+void exit_thread(struct task_struct *tsk)
+{
+	/*
+	 * User threads may have allocated a delay slot emulation frame.
+	 * If so, clean up that allocation.
+	 */
+	if (!(current->flags & PF_KTHREAD))
+		dsemul_thread_cleanup(tsk);
+}
+
 int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
 {
 	/*
@@ -159,6 +171,8 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 	clear_tsk_thread_flag(p, TIF_FPUBOUND);
 #endif /* CONFIG_MIPS_MT_FPAFF */
 
+	atomic_set(&p->thread.bd_emu_frame, BD_EMUFRAME_NONE);
+
 	if (clone_flags & CLONE_SETTLS)
 		ti->tp_value = regs->regs[7];
 

commit 4029632c344142e0e92da3ff4937cd41bd647bb4
Merge: d66492bce151 a8c5ddf08f1f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat May 28 16:41:39 2016 -0700

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull more MIPS updates from Ralf Baechle:
     "This is the secondnd batch of MIPS patches for 4.7. Summary:
    
      CPS:
       - Copy EVA configuration when starting secondary VPs.
    
      EIC:
       - Clear Status IPL.
    
      Lasat:
       - Fix a few off by one bugs.
    
      lib:
       - Mark intrinsics notrace.  Not only are the intrinsics
         uninteresting, it would cause infinite recursion.
    
      MAINTAINERS:
       - Add file patterns for MIPS BRCM device tree bindings.
       - Add file patterns for mips device tree bindings.
    
      MT7628:
       - Fix MT7628 pinmux typos.
       - wled_an pinmux gpio.
       - EPHY LEDs pinmux support.
    
      Pistachio:
       - Enable KASLR
    
      VDSO:
       - Build microMIPS VDSO for microMIPS kernels.
       - Fix aliasing warning by building with `-fno-strict-aliasing' for
         debugging but also tracing them might result in recursion.
    
      Misc:
       - Add missing FROZEN hotplug notifier transitions.
       - Fix clk binding example for varioius PIC32 devices.
       - Fix cpu interrupt controller node-names in the DT files.
       - Fix XPA CPU feature separation.
       - Fix write_gc0_* macros when writing zero.
       - Add inline asm encoding helpers.
       - Add missing VZ accessor microMIPS encodings.
       - Fix little endian microMIPS MSA encodings.
       - Add 64-bit HTW fields and fix its configuration.
       - Fix sigreturn via VDSO on microMIPS kernel.
       - Lots of typo fixes.
       - Add definitions of SegCtl registers and use them"
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (49 commits)
      MIPS: Add missing FROZEN hotplug notifier transitions
      MIPS: Build microMIPS VDSO for microMIPS kernels
      MIPS: Fix sigreturn via VDSO on microMIPS kernel
      MIPS: devicetree: fix cpu interrupt controller node-names
      MIPS: VDSO: Build with `-fno-strict-aliasing'
      MIPS: Pistachio: Enable KASLR
      MIPS: lib: Mark intrinsics notrace
      MIPS: Fix 64-bit HTW configuration
      MIPS: Add 64-bit HTW fields
      MAINTAINERS: Add file patterns for mips device tree bindings
      MAINTAINERS: Add file patterns for mips brcm device tree bindings
      MIPS: Simplify DSP instruction encoding macros
      MIPS: Add missing tlbinvf/XPA microMIPS encodings
      MIPS: Fix little endian microMIPS MSA encodings
      MIPS: Add missing VZ accessor microMIPS encodings
      MIPS: Add inline asm encoding helpers
      MIPS: Spelling fix lets -> let's
      MIPS: VR41xx: Fix typo
      MIPS: oprofile: Fix typo
      MIPS: math-emu: Fix typo
      ...

commit a90c59e636da2352ab9d2f51bf0d6c9b2eef3c13
Author: Andrea Gelmini <andrea.gelmini@gelma.net>
Date:   Sat May 21 14:01:27 2016 +0200

    MIPS: kernel: Fix typo
    
    Signed-off-by: Andrea Gelmini <andrea.gelmini@gelma.net>
    Cc: paul.burton@imgtec.com
    Cc: macro@imgtec.com
    Cc: james.hogan@imgtec.com
    Cc: jslaby@suse.cz
    Cc: adam.buchbinder@gmail.com
    Cc: trivial@kernel.org
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/13330/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index a6b3dc54260a..866d083f2d81 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -349,7 +349,7 @@ static int get_frame_info(struct mips_frame_info *info)
 		return 0;
 	if (info->pc_offset < 0) /* leaf */
 		return 1;
-	/* prologue seems boggus... */
+	/* prologue seems bogus... */
 err:
 	return -1;
 }

commit 5f56a5dfdb9bcb3bca03df59980d4d2f012cbb53
Author: Jiri Slaby <jslaby@suse.cz>
Date:   Fri May 20 17:00:16 2016 -0700

    exit_thread: remove empty bodies
    
    Define HAVE_EXIT_THREAD for archs which want to do something in
    exit_thread. For others, let's define exit_thread as an empty inline.
    
    This is a cleanup before we change the prototype of exit_thread to
    accept a task parameter.
    
    [akpm@linux-foundation.org: fix mips]
    Signed-off-by: Jiri Slaby <jslaby@suse.cz>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: "H. Peter Anvin" <hpa@zytor.com>
    Cc: "James E.J. Bottomley" <jejb@parisc-linux.org>
    Cc: Aurelien Jacquiot <a-jacquiot@ti.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chen Liqin <liqin.linux@gmail.com>
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: David Howells <dhowells@redhat.com>
    Cc: Fenghua Yu <fenghua.yu@intel.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Cc: Hans-Christian Egtvedt <egtvedt@samfundet.no>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ivan Kokshaysky <ink@jurassic.park.msu.ru>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Jesper Nilsson <jesper.nilsson@axis.com>
    Cc: Jiri Slaby <jslaby@suse.cz>
    Cc: Jonas Bonn <jonas@southpole.se>
    Cc: Koichi Yasutake <yasutake.koichi@jp.panasonic.com>
    Cc: Lennox Wu <lennox.wu@gmail.com>
    Cc: Ley Foon Tan <lftan@altera.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Richard Henderson <rth@twiddle.net>
    Cc: Richard Kuo <rkuo@codeaurora.org>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Steven Miao <realmz6@gmail.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will.deacon@arm.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index a6b3dc54260a..411c971e3417 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -73,10 +73,6 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 	regs->regs[29] = sp;
 }
 
-void exit_thread(void)
-{
-}
-
 int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
 {
 	/*

commit 6b8322576e9d325b65c54fbef64e4e8690ad70ce
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Thu Apr 21 12:43:58 2016 +0100

    MIPS: Force CPUs to lose FP context during mode switches
    
    Commit 9791554b45a2 ("MIPS,prctl: add PR_[GS]ET_FP_MODE prctl options
    for MIPS") added support for the PR_SET_FP_MODE prctl, which allows a
    userland program to modify its FP mode at runtime. This is most notably
    required if dynamic linking leads to the FP mode requirement changing at
    runtime from that indicated in the initial executable's ELF header. In
    order to avoid overhead in the general FP context restore code, it aimed
    to have threads in the process become unable to enable the FPU during a
    mode switch & have the thread calling the prctl syscall wait for all
    other threads in the process to be context switched at least once. Once
    that happens we can know that no thread in the process whose mode will
    be switched has live FP context, and it's safe to perform the mode
    switch. However in the (rare) case of modeswitches occurring in
    multithreaded programs this can lead to indeterminate delays for the
    thread invoking the prctl syscall, and the code monitoring for those
    context switches was woefully inadequate for all but the simplest cases.
    
    Fix this by broadcasting an IPI if other CPUs may have live FP context
    for an affected thread, with a handler causing those CPUs to relinquish
    their FPU ownership. Threads will then be allowed to continue running
    but will stall on the wait_on_atomic_t in enable_restore_fp_context if
    they attempt to use FP again whilst the mode switch is still in
    progress. The end result is less fragile poking at scheduler context
    switch counts & a more expedient completion of the mode switch.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Fixes: 9791554b45a2 ("MIPS,prctl: add PR_[GS]ET_FP_MODE prctl options for MIPS")
    Reviewed-by: Maciej W. Rozycki <macro@imgtec.com>
    Cc: Adam Buchbinder <adam.buchbinder@gmail.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: stable <stable@vger.kernel.org> # v4.0+
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/13145/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index dcccc6dc68e6..a6b3dc54260a 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -576,11 +576,19 @@ int mips_get_process_fp_mode(struct task_struct *task)
 	return value;
 }
 
+static void prepare_for_fp_mode_switch(void *info)
+{
+	struct mm_struct *mm = info;
+
+	if (current->mm == mm)
+		lose_fpu(1);
+}
+
 int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 {
 	const unsigned int known_bits = PR_FP_MODE_FR | PR_FP_MODE_FRE;
-	unsigned long switch_count;
 	struct task_struct *t;
+	int max_users;
 
 	/* Check the value is valid */
 	if (value & ~known_bits)
@@ -609,31 +617,17 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 	smp_mb__after_atomic();
 
 	/*
-	 * If there are multiple online CPUs then wait until all threads whose
-	 * FP mode is about to change have been context switched. This approach
-	 * allows us to only worry about whether an FP mode switch is in
-	 * progress when FP is first used in a tasks time slice. Pretty much all
-	 * of the mode switch overhead can thus be confined to cases where mode
-	 * switches are actually occurring. That is, to here. However for the
-	 * thread performing the mode switch it may take a while...
+	 * If there are multiple online CPUs then force any which are running
+	 * threads in this process to lose their FPU context, which they can't
+	 * regain until fp_mode_switching is cleared later.
 	 */
 	if (num_online_cpus() > 1) {
-		spin_lock_irq(&task->sighand->siglock);
-
-		for_each_thread(task, t) {
-			if (t == current)
-				continue;
-
-			switch_count = t->nvcsw + t->nivcsw;
-
-			do {
-				spin_unlock_irq(&task->sighand->siglock);
-				cond_resched();
-				spin_lock_irq(&task->sighand->siglock);
-			} while ((t->nvcsw + t->nivcsw) == switch_count);
-		}
+		/* No need to send an IPI for the local CPU */
+		max_users = (task->mm == current->mm) ? 1 : 0;
 
-		spin_unlock_irq(&task->sighand->siglock);
+		if (atomic_read(&current->mm->mm_users) > max_users)
+			smp_call_function(prepare_for_fp_mode_switch,
+					  (void *)current->mm, 1);
 	}
 
 	/*

commit bd239f1e1429e7781096bf3884bdb1b2b1bb4f28
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Thu Apr 21 12:43:57 2016 +0100

    MIPS: Disable preemption during prctl(PR_SET_FP_MODE, ...)
    
    Whilst a PR_SET_FP_MODE prctl is performed there are decisions made
    based upon whether the task is executing on the current CPU. This may
    change if we're preempted, so disable preemption to avoid such changes
    for the lifetime of the mode switch.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Fixes: 9791554b45a2 ("MIPS,prctl: add PR_[GS]ET_FP_MODE prctl options for MIPS")
    Reviewed-by: Maciej W. Rozycki <macro@imgtec.com>
    Tested-by: Aurelien Jarno <aurelien@aurel32.net>
    Cc: Adam Buchbinder <adam.buchbinder@gmail.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: stable <stable@vger.kernel.org> # v4.0+
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/13144/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index f57891616357..dcccc6dc68e6 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -597,6 +597,9 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 	if (!(value & PR_FP_MODE_FR) && cpu_has_fpu && cpu_has_mips_r6)
 		return -EOPNOTSUPP;
 
+	/* Proceed with the mode switch */
+	preempt_disable();
+
 	/* Save FP & vector context, then disable FPU & MSA */
 	if (task->signal == current->signal)
 		lose_fpu(1);
@@ -655,6 +658,7 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 
 	/* Allow threads to use FP again */
 	atomic_set(&task->mm->context.fp_mode_switching, 0);
+	preempt_enable();
 
 	return 0;
 }

commit 04cc89d120f94131de89a6e20da27016db4782ce
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sun Mar 27 00:07:14 2016 +0100

    MIPS: Make flush_thread
    
    Avoids function calls to an empty function.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 3f5aa3bc191e..f57891616357 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -77,10 +77,6 @@ void exit_thread(void)
 {
 }
 
-void flush_thread(void)
-{
-}
-
 int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
 {
 	/*

commit a816b306c62195b7c43c92cb13330821a96bdc27
Author: James Hogan <james.hogan@imgtec.com>
Date:   Fri Dec 4 22:25:01 2015 +0000

    MIPS: Don't unwind to user mode with EVA
    
    When unwinding through IRQs and exceptions, the unwinding only continues
    if the PC is a kernel text address, however since EVA it is possible for
    user and kernel address ranges to overlap, potentially allowing
    unwinding to continue to user mode if the user PC happens to be in the
    kernel text address range.
    
    Adjust the check to also ensure that the register state from before the
    exception is actually running in kernel mode, i.e. !user_mode(regs).
    
    I don't believe any harm can come of this problem, since the PC is only
    output, the stack pointer is checked to ensure it resides within the
    task's stack page before it is dereferenced in search of the return
    address, and the return address register is similarly only output (if
    the PC is in a leaf function or the beginning of a non-leaf function).
    
    However unwind_stack() is only meant for unwinding kernel code, so to be
    correct the unwind should stop there.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: <stable@vger.kernel.org> # 3.15+
    Patchwork: https://patchwork.linux-mips.org/patch/11700/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 92880cee449e..3f5aa3bc191e 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -455,7 +455,7 @@ unsigned long notrace unwind_stack_by_address(unsigned long stack_page,
 		    *sp + sizeof(*regs) <= stack_page + THREAD_SIZE - 32) {
 			regs = (struct pt_regs *)*sp;
 			pc = regs->cp0_epc;
-			if (__kernel_text_address(pc)) {
+			if (!user_mode(regs) && __kernel_text_address(pc)) {
 				*sp = regs->regs[29];
 				*ra = regs->regs[31];
 				return pc;

commit 92a76f6d8545efc67f03278009e9a828bdad3419
Author: Adam Buchbinder <adam.buchbinder@gmail.com>
Date:   Thu Feb 25 00:44:58 2016 -0800

    MIPS: Fix misspellings in comments.
    
    Signed-off-by: Adam Buchbinder <adam.buchbinder@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: trivial@kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/12617/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index eddd5fd6fdfa..92880cee449e 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -615,7 +615,7 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 	 * allows us to only worry about whether an FP mode switch is in
 	 * progress when FP is first used in a tasks time slice. Pretty much all
 	 * of the mode switch overhead can thus be confined to cases where mode
-	 * switches are actually occuring. That is, to here. However for the
+	 * switches are actually occurring. That is, to here. However for the
 	 * thread performing the mode switch it may take a while...
 	 */
 	if (num_online_cpus() > 1) {

commit 76e5846d3bdf59eb1010d5607003da2dc3910bb1
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Feb 1 13:50:36 2016 +0000

    MIPS: Properly disable FPU in start_thread()
    
    start_thread() (called for execve(2)) clears the TIF_USEDFPU flag
    without atomically disabling the FPU. With a preemptive kernel, an
    unfortunately timed preemption after this could result in another
    task (or KVM guest) being scheduled in with the FPU still enabled, since
    lose_fpu_inatomic() only turns it off if TIF_USEDFPU is set.
    
    Use lose_fpu(0) instead of the separate FPU / MSA management, which
    should do the right thing (drop FPU properly and atomically without
    saving state) and will be more future proof.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/12302/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index f2975d4d1e44..eddd5fd6fdfa 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -65,12 +65,10 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 	status = regs->cp0_status & ~(ST0_CU0|ST0_CU1|ST0_FR|KU_MASK);
 	status |= KU_USER;
 	regs->cp0_status = status;
+	lose_fpu(0);
+	clear_thread_flag(TIF_MSA_CTX_LIVE);
 	clear_used_math();
-	clear_fpu_owner();
 	init_dsp();
-	clear_thread_flag(TIF_USEDMSA);
-	clear_thread_flag(TIF_MSA_CTX_LIVE);
-	disable_msa();
 	regs->cp0_epc = pc;
 	regs->regs[29] = sp;
 }

commit 6496edfce95f943e1da43631c2f437509e56af7f
Merge: b19a42e3cb9e e4afa120c982
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 20 10:19:03 2015 -0700

    Merge tag 'cpumask-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux
    
    Pull final removal of deprecated cpus_* cpumask functions from Rusty Russell:
     "This is the final removal (after several years!) of the obsolete
      cpus_* functions, prompted by their mis-use in staging.
    
      With these function removed, all cpu functions should only iterate to
      nr_cpu_ids, so we finally only allocate that many bits when cpumasks
      are allocated offstack"
    
    * tag 'cpumask-next-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/rusty/linux: (25 commits)
      cpumask: remove __first_cpu / __next_cpu
      cpumask: resurrect CPU_MASK_CPU0
      linux/cpumask.h: add typechecking to cpumask_test_cpu
      cpumask: only allocate nr_cpumask_bits.
      Fix weird uses of num_online_cpus().
      cpumask: remove deprecated functions.
      mips: fix obsolete cpumask_of_cpu usage.
      x86: fix more deprecated cpu function usage.
      ia64: remove deprecated cpus_ usage.
      powerpc: fix deprecated CPU_MASK_CPU0 usage.
      CPU_MASK_ALL/CPU_MASK_NONE: remove from deprecated region.
      staging/lustre/o2iblnd: Don't use cpus_weight
      staging/lustre/libcfs: replace deprecated cpus_ calls with cpumask_
      staging/lustre/ptlrpc: Do not use deprecated cpus_* functions
      blackfin: fix up obsolete cpu function usage.
      parisc: fix up obsolete cpu function usage.
      tile: fix up obsolete cpu function usage.
      arm64: fix up obsolete cpu function usage.
      mips: fix up obsolete cpu function usage.
      x86: fix up obsolete cpu function usage.
      ...

commit e2c5aaa5fd3b4038061adf878254cceb30e41ddd
Author: Alex Dowad <alexinbeijing@gmail.com>
Date:   Fri Mar 13 20:14:41 2015 +0200

    mips: copy_thread(): rename 'arg' argument to 'kthread_arg'
    
    The 'arg' argument to copy_thread() is only ever used when forking a new
    kernel thread. Hence, rename it to 'kthread_arg' for clarity (and consistency
    with do_fork() and other arch-specific implementations of copy_thread()).
    
    Signed-off-by: Alex Dowad <alexinbeijing@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Alex Smith <alex@alex-smith.me.uk>
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Eunbong Song <eunb.song@samsung.com>
    Cc: linux-mips@linux-mips.org (open list:MIPS)
    Patchwork: https://patchwork.linux-mips.org/patch/9546/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index bf85cc180d91..d295bd1e4996 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -107,8 +107,11 @@ int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
 	return 0;
 }
 
+/*
+ * Copy architecture-specific thread state
+ */
 int copy_thread(unsigned long clone_flags, unsigned long usp,
-	unsigned long arg, struct task_struct *p)
+	unsigned long kthread_arg, struct task_struct *p)
 {
 	struct thread_info *ti = task_thread_info(p);
 	struct pt_regs *childregs, *regs = current_pt_regs();
@@ -123,11 +126,12 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 	childksp = (unsigned long) childregs;
 	p->thread.cp0_status = read_c0_status() & ~(ST0_CU2|ST0_CU1);
 	if (unlikely(p->flags & PF_KTHREAD)) {
+		/* kernel thread */
 		unsigned long status = p->thread.cp0_status;
 		memset(childregs, 0, sizeof(struct pt_regs));
 		ti->addr_limit = KERNEL_DS;
 		p->thread.reg16 = usp; /* fn */
-		p->thread.reg17 = arg;
+		p->thread.reg17 = kthread_arg;
 		p->thread.reg29 = childksp;
 		p->thread.reg31 = (unsigned long) ret_from_kernel_thread;
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
@@ -139,6 +143,8 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 		childregs->cp0_status = status;
 		return 0;
 	}
+
+	/* user thread */
 	*childregs = *regs;
 	childregs->regs[7] = 0; /* Clear error flag */
 	childregs->regs[2] = 0; /* Child gets zero as return value */

commit 8dd928915a73bf95a727a46037964243eb1e042c
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Thu Mar 5 10:49:17 2015 +1030

    mips: fix up obsolete cpu function usage.
    
    Thanks to spatch, plus manual removal of "&*".  Then a sweep for
    for_each_cpu_mask => for_each_cpu.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Kevin Cernekee <cernekee@gmail.com>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index bf85cc180d91..4501c7a4bd58 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -49,7 +49,7 @@
 void arch_cpu_idle_dead(void)
 {
 	/* What the heck is this check doing ? */
-	if (!cpu_isset(smp_processor_id(), cpu_callin_map))
+	if (!cpumask_test_cpu(smp_processor_id(), &cpu_callin_map))
 		play_dead();
 }
 #endif

commit a135c717d5cdb311cff7661af4c17fef0562e590
Merge: 217703323308 44923c9cfa1a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Feb 21 19:41:38 2015 -0800

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
     "This is the main pull request for MIPS:
    
       - a number of fixes that didn't make the 3.19 release.
    
       - a number of cleanups.
    
       - preliminary support for Cavium's Octeon 3 SOCs which feature up to
         48 MIPS64 R3 cores with FPU and hardware virtualization.
    
       - support for MIPS R6 processors.
    
         Revision 6 of the MIPS architecture is a major revision of the MIPS
         architecture which does away with many of original sins of the
         architecture such as branch delay slots.  This and other changes in
         R6 require major changes throughout the entire MIPS core
         architecture code and make up for the lion share of this pull
         request.
    
       - finally some preparatory work for eXtendend Physical Address
         support, which allows support of up to 40 bit of physical address
         space on 32 bit processors"
    
         [ Ahh, MIPS can't leave the PAE brain damage alone.  It's like
           every CPU architect has to make that mistake, but pee in the snow
           by changing the TLA.  But whether it's called PAE, LPAE or XPA,
           it's horrid crud   - Linus ]
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (114 commits)
      MIPS: sead3: Corrected get_c0_perfcount_int
      MIPS: mm: Remove dead macro definitions
      MIPS: OCTEON: irq: add CIB and other fixes
      MIPS: OCTEON: Don't do acknowledge operations for level triggered irqs.
      MIPS: OCTEON: More OCTEONIII support
      MIPS: OCTEON: Remove setting of processor specific CVMCTL icache bits.
      MIPS: OCTEON: Core-15169 Workaround and general CVMSEG cleanup.
      MIPS: OCTEON: Update octeon-model.h code for new SoCs.
      MIPS: OCTEON: Implement DCache errata workaround for all CN6XXX
      MIPS: OCTEON: Add little-endian support to asm/octeon/octeon.h
      MIPS: OCTEON: Implement the core-16057 workaround
      MIPS: OCTEON: Delete unused COP2 saving code
      MIPS: OCTEON: Use correct instruction to read 64-bit COP0 register
      MIPS: OCTEON: Save and restore CP2 SHA3 state
      MIPS: OCTEON: Fix FP context save.
      MIPS: OCTEON: Save/Restore wider multiply registers in OCTEON III CPUs
      MIPS: boot: Provide more uImage options
      MIPS: Remove unneeded #ifdef __KERNEL__ from asm/processor.h
      MIPS: ip22-gio: Remove legacy suspend/resume support
      mips: pci: Add ifdef around pci_proc_domain
      ...

commit 13e45f095753b8203a8446648dea527f9ce4413c
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Tue Jan 13 13:01:49 2015 +0000

    MIPS: kernel: process: Do not allow FR=0 on MIPS R6
    
    A prctl() call to set FR=0 for MIPS R6 should not be allowed
    since FR=1 is the only option for R6 cores.
    
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: Matthew Fortune <matthew.fortune@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 4677b4c67da6..696d59e40fa4 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -581,6 +581,10 @@ int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
 	if ((value & PR_FP_MODE_FRE) && cpu_has_fpu && !cpu_has_fre)
 		return -EOPNOTSUPP;
 
+	/* FR = 0 not supported in MIPS R6 */
+	if (!(value & PR_FP_MODE_FR) && cpu_has_fpu && cpu_has_mips_r6)
+		return -EOPNOTSUPP;
+
 	/* Save FP & vector context, then disable FPU & MSA */
 	if (task->signal == current->signal)
 		lose_fpu(1);

commit 9791554b45a2acc28247f66a5fd5bbc212a6b8c8
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Thu Jan 8 12:17:37 2015 +0000

    MIPS,prctl: add PR_[GS]ET_FP_MODE prctl options for MIPS
    
    Userland code may be built using an ABI which permits linking to objects
    that have more restrictive floating point requirements. For example,
    userland code may be built to target the O32 FPXX ABI. Such code may be
    linked with other FPXX code, or code built for either one of the more
    restrictive FP32 or FP64. When linking with more restrictive code, the
    overall requirement of the process becomes that of the more restrictive
    code. The kernel has no way to know in advance which mode the process
    will need to be executed in, and indeed it may need to change during
    execution. The dynamic loader is the only code which will know the
    overall required mode, and so it needs to have a means to instruct the
    kernel to switch the FP mode of the process.
    
    This patch introduces 2 new options to the prctl syscall which provide
    such a capability. The FP mode of the process is represented as a
    simple bitmask combining a number of mode bits mirroring those present
    in the hardware. Userland can either retrieve the current FP mode of
    the process:
    
      mode = prctl(PR_GET_FP_MODE);
    
    or modify the current FP mode of the process:
    
      err = prctl(PR_SET_FP_MODE, new_mode);
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: Matthew Fortune <matthew.fortune@imgtec.com>
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/8899/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index eb76434828e8..4677b4c67da6 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -25,6 +25,7 @@
 #include <linux/completion.h>
 #include <linux/kallsyms.h>
 #include <linux/random.h>
+#include <linux/prctl.h>
 
 #include <asm/asm.h>
 #include <asm/bootinfo.h>
@@ -550,3 +551,94 @@ void arch_trigger_all_cpu_backtrace(bool include_self)
 {
 	smp_call_function(arch_dump_stack, NULL, 1);
 }
+
+int mips_get_process_fp_mode(struct task_struct *task)
+{
+	int value = 0;
+
+	if (!test_tsk_thread_flag(task, TIF_32BIT_FPREGS))
+		value |= PR_FP_MODE_FR;
+	if (test_tsk_thread_flag(task, TIF_HYBRID_FPREGS))
+		value |= PR_FP_MODE_FRE;
+
+	return value;
+}
+
+int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)
+{
+	const unsigned int known_bits = PR_FP_MODE_FR | PR_FP_MODE_FRE;
+	unsigned long switch_count;
+	struct task_struct *t;
+
+	/* Check the value is valid */
+	if (value & ~known_bits)
+		return -EOPNOTSUPP;
+
+	/* Avoid inadvertently triggering emulation */
+	if ((value & PR_FP_MODE_FR) && cpu_has_fpu &&
+	    !(current_cpu_data.fpu_id & MIPS_FPIR_F64))
+		return -EOPNOTSUPP;
+	if ((value & PR_FP_MODE_FRE) && cpu_has_fpu && !cpu_has_fre)
+		return -EOPNOTSUPP;
+
+	/* Save FP & vector context, then disable FPU & MSA */
+	if (task->signal == current->signal)
+		lose_fpu(1);
+
+	/* Prevent any threads from obtaining live FP context */
+	atomic_set(&task->mm->context.fp_mode_switching, 1);
+	smp_mb__after_atomic();
+
+	/*
+	 * If there are multiple online CPUs then wait until all threads whose
+	 * FP mode is about to change have been context switched. This approach
+	 * allows us to only worry about whether an FP mode switch is in
+	 * progress when FP is first used in a tasks time slice. Pretty much all
+	 * of the mode switch overhead can thus be confined to cases where mode
+	 * switches are actually occuring. That is, to here. However for the
+	 * thread performing the mode switch it may take a while...
+	 */
+	if (num_online_cpus() > 1) {
+		spin_lock_irq(&task->sighand->siglock);
+
+		for_each_thread(task, t) {
+			if (t == current)
+				continue;
+
+			switch_count = t->nvcsw + t->nivcsw;
+
+			do {
+				spin_unlock_irq(&task->sighand->siglock);
+				cond_resched();
+				spin_lock_irq(&task->sighand->siglock);
+			} while ((t->nvcsw + t->nivcsw) == switch_count);
+		}
+
+		spin_unlock_irq(&task->sighand->siglock);
+	}
+
+	/*
+	 * There are now no threads of the process with live FP context, so it
+	 * is safe to proceed with the FP mode switch.
+	 */
+	for_each_thread(task, t) {
+		/* Update desired FP register width */
+		if (value & PR_FP_MODE_FR) {
+			clear_tsk_thread_flag(t, TIF_32BIT_FPREGS);
+		} else {
+			set_tsk_thread_flag(t, TIF_32BIT_FPREGS);
+			clear_tsk_thread_flag(t, TIF_MSA_CTX_LIVE);
+		}
+
+		/* Update desired FP single layout */
+		if (value & PR_FP_MODE_FRE)
+			set_tsk_thread_flag(t, TIF_HYBRID_FPREGS);
+		else
+			clear_tsk_thread_flag(t, TIF_HYBRID_FPREGS);
+	}
+
+	/* Allow threads to use FP again */
+	atomic_set(&task->mm->context.fp_mode_switching, 0);
+
+	return 0;
+}

commit 39148e94e3e1f0477ce8ed3fda00123722681f3a
Author: James Hogan <james.hogan@imgtec.com>
Date:   Mon Jan 19 10:30:54 2015 +0000

    MIPS: fork: Fix MSA/FPU/DSP context duplication race
    
    There is a race in the MIPS fork code which allows the child to get a
    stale copy of parent MSA/FPU/DSP state that is active in hardware
    registers when the fork() is called. This is because copy_thread() saves
    the live register state into the child context only if the hardware is
    currently in use, apparently on the assumption that the hardware state
    cannot have been saved and disabled since the initial duplication of the
    task_struct. However preemption is certainly possible during this
    window.
    
    An example sequence of events is as follows:
    
    1) The parent userland process puts important data into saved floating
       point registers ($f20-$f31), which are then dirty compared to the
       process' stored context.
    
    2) The parent process calls fork() which does a clone system call.
    
    3) In the kernel, do_fork() -> copy_process() -> dup_task_struct() ->
       arch_dup_task_struct() (which uses the weakly defined default
       implementation). This duplicates the parent process' task context,
       which includes a stale version of its FP context from when it was
       last saved, probably some time before (1).
    
    4) At some point before copy_process() calls copy_thread(), such as when
       duplicating the memory map, the process is desceduled. Perhaps it is
       preempted asynchronously, or perhaps it sleeps while blocked on a
       mutex. The dirty FP state in the FP registers is saved to the parent
       process' context and the FPU is disabled.
    
    5) When the process is rescheduled again it continues copying state
       until it gets to copy_thread(), which checks whether the FPU is in
       use, so that it can copy that dirty state to the child process' task
       context. Because of the deschedule however the FPU is not in use, so
       the child process' context is left with stale FP context from the
       last time the parent saved it (some time before (1)).
    
    6) When the new child process is scheduled it reads the important data
       from the saved floating point register, and ends up doing a NULL
       pointer dereference as a result of the stale data.
    
    This use of saved floating point registers across function calls can be
    triggered fairly easily by explicitly using inline asm with a current
    (MIPS R2) compiler, but is far more likely to happen unintentionally
    with a MIPS R6 compiler where the FP registers are more likely to get
    used as scratch registers for storing non-fp data.
    
    It is easily fixed, in the same way that other architectures do it, by
    overriding the implementation of arch_dup_task_struct() to sync the
    dirty hardware state to the parent process' task context *prior* to
    duplicating it, rather than copying straight to the child process' task
    context in copy_thread(). Note, the FPU hardware is not disabled so the
    parent process may continue executing with the live register context,
    but now the child process is guaranteed to have an identical copy of it
    at that point.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reported-by: Matthew Fortune <matthew.fortune@imgtec.com>
    Tested-by: Markos Chandras <markos.chandras@imgtec.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/9075/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index eb76434828e8..85bff5d513e5 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -82,6 +82,30 @@ void flush_thread(void)
 {
 }
 
+int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)
+{
+	/*
+	 * Save any process state which is live in hardware registers to the
+	 * parent context prior to duplication. This prevents the new child
+	 * state becoming stale if the parent is preempted before copy_thread()
+	 * gets a chance to save the parent's live hardware registers to the
+	 * child context.
+	 */
+	preempt_disable();
+
+	if (is_msa_enabled())
+		save_msa(current);
+	else if (is_fpu_owner())
+		_save_fp(current);
+
+	save_dsp(current);
+
+	preempt_enable();
+
+	*dst = *src;
+	return 0;
+}
+
 int copy_thread(unsigned long clone_flags, unsigned long usp,
 	unsigned long arg, struct task_struct *p)
 {
@@ -92,18 +116,6 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 
 	childksp = (unsigned long)task_stack_page(p) + THREAD_SIZE - 32;
 
-	preempt_disable();
-
-	if (is_msa_enabled())
-		save_msa(p);
-	else if (is_fpu_owner())
-		save_fp(p);
-
-	if (cpu_has_dsp)
-		save_dsp(p);
-
-	preempt_enable();
-
 	/* set up new TSS. */
 	childregs = (struct pt_regs *) childksp - 1;
 	/*  Put the stack after the struct pt_regs.  */

commit 856839b76836a2ee524a8638f568275da57f719c
Author: Eunbong Song <eunb.song@samsung.com>
Date:   Wed Oct 22 06:39:56 2014 +0000

    MIPS: Add arch_trigger_all_cpu_backtrace() function
    
    Currently, arch_trigger_all_cpu_backtrace() is defined in only x86 and
    sparc which have an NMI.  But in case of softlockup, it could be possible
    to dump backtrace of all cpus. and this could be helpful for debugging.
    
    for example, if system has 2 cpus.
    
            CPU 0                           CPU 1
     acquire read_lock()
    
                                    try to do write_lock()
    
     ,,,
     missing read_unlock()
    
    In this case, softlockup will occur becasuse CPU 0 does not call
    read_unlock().  And dump_stack() print only backtrace for "CPU 0". If
    CPU1's backtrace is printed it's very helpful.
    
    [ralf@linux-mips.org: Fixed whitespace and formatting issues.]
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/8200/

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index d0e77b2470cb..eb76434828e8 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -42,6 +42,7 @@
 #include <asm/isadep.h>
 #include <asm/inst.h>
 #include <asm/stacktrace.h>
+#include <asm/irq_regs.h>
 
 #ifdef CONFIG_HOTPLUG_CPU
 void arch_cpu_idle_dead(void)
@@ -532,3 +533,20 @@ unsigned long arch_align_stack(unsigned long sp)
 
 	return sp & ALMASK;
 }
+
+static void arch_dump_stack(void *info)
+{
+	struct pt_regs *regs;
+
+	regs = get_irq_regs();
+
+	if (regs)
+		show_regs(regs);
+
+	dump_stack();
+}
+
+void arch_trigger_all_cpu_backtrace(bool include_self)
+{
+	smp_call_function(arch_dump_stack, NULL, 1);
+}

commit 635c99070600ff04b4c1d5afe67f051631a8397c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Oct 21 14:12:49 2014 +0200

    MIPS: Remove useless parentheses
    
    Based on the spatch
    
    @@
    expression e;
    @@
    - return (e);
    + return e;
    
    with heavy hand editing because some of the changes are either whitespace
    or identation only or result in excessivly long lines.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 636b0745d7c7..d0e77b2470cb 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -187,21 +187,21 @@ static inline int is_ra_save_ins(union mips_instruction *ip)
 	 */
 	if (mm_insn_16bit(ip->halfword[0])) {
 		mmi.word = (ip->halfword[0] << 16);
-		return ((mmi.mm16_r5_format.opcode == mm_swsp16_op &&
-			 mmi.mm16_r5_format.rt == 31) ||
-			(mmi.mm16_m_format.opcode == mm_pool16c_op &&
-			 mmi.mm16_m_format.func == mm_swm16_op));
+		return (mmi.mm16_r5_format.opcode == mm_swsp16_op &&
+			mmi.mm16_r5_format.rt == 31) ||
+		       (mmi.mm16_m_format.opcode == mm_pool16c_op &&
+			mmi.mm16_m_format.func == mm_swm16_op);
 	}
 	else {
 		mmi.halfword[0] = ip->halfword[1];
 		mmi.halfword[1] = ip->halfword[0];
-		return ((mmi.mm_m_format.opcode == mm_pool32b_op &&
-			 mmi.mm_m_format.rd > 9 &&
-			 mmi.mm_m_format.base == 29 &&
-			 mmi.mm_m_format.func == mm_swm32_func) ||
-			(mmi.i_format.opcode == mm_sw32_op &&
-			 mmi.i_format.rs == 29 &&
-			 mmi.i_format.rt == 31));
+		return (mmi.mm_m_format.opcode == mm_pool32b_op &&
+			mmi.mm_m_format.rd > 9 &&
+			mmi.mm_m_format.base == 29 &&
+			mmi.mm_m_format.func == mm_swm32_func) ||
+		       (mmi.i_format.opcode == mm_sw32_op &&
+			mmi.i_format.rs == 29 &&
+			mmi.i_format.rt == 31);
 	}
 #else
 	/* sw / sd $ra, offset($sp) */
@@ -233,7 +233,7 @@ static inline int is_jump_ins(union mips_instruction *ip)
 	if (ip->r_format.opcode != mm_pool32a_op ||
 			ip->r_format.func != mm_pool32axf_op)
 		return 0;
-	return (((ip->u_format.uimmediate >> 6) & mm_jalr_op) == mm_jalr_op);
+	return ((ip->u_format.uimmediate >> 6) & mm_jalr_op) == mm_jalr_op;
 #else
 	if (ip->j_format.opcode == j_op)
 		return 1;
@@ -260,13 +260,13 @@ static inline int is_sp_move_ins(union mips_instruction *ip)
 		union mips_instruction mmi;
 
 		mmi.word = (ip->halfword[0] << 16);
-		return ((mmi.mm16_r3_format.opcode == mm_pool16d_op &&
-			 mmi.mm16_r3_format.simmediate && mm_addiusp_func) ||
-			(mmi.mm16_r5_format.opcode == mm_pool16d_op &&
-			 mmi.mm16_r5_format.rt == 29));
+		return (mmi.mm16_r3_format.opcode == mm_pool16d_op &&
+			mmi.mm16_r3_format.simmediate && mm_addiusp_func) ||
+		       (mmi.mm16_r5_format.opcode == mm_pool16d_op &&
+			mmi.mm16_r5_format.rt == 29);
 	}
-	return (ip->mm_i_format.opcode == mm_addiu32_op &&
-		 ip->mm_i_format.rt == 29 && ip->mm_i_format.rs == 29);
+	return ip->mm_i_format.opcode == mm_addiu32_op &&
+	       ip->mm_i_format.rt == 29 && ip->mm_i_format.rs == 29;
 #else
 	/* addiu/daddiu sp,sp,-imm */
 	if (ip->i_format.rs != 29 || ip->i_format.rt != 29)

commit 7daef8f261e509bea79ea3b0076e624135259bc1
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Jul 11 16:47:05 2014 +0100

    MIPS: consistently clear MSA flags when starting & copying threads
    
    The TIF_MSA_CTX_LIVE flag (indicating that a task has MSA context which
    needs to be preserved) was being cleared in start_thread, but the
    TIF_USEDMSA flag (indicating that a task has used MSA in this timeslice)
    was not. In copy_thread neither flag was cleared, but both need to be.
    Without clearing these flags the kernel will proceed to attempt to save
    MSA context when the task is context switched out, and if the task had
    not used MSA in the meantime then it will fail because MSA or the FPU
    are disabled. The end result is typically:
    
      do_cpu invoked from kernel context![#1]:
      CPU: 0 PID: 99 Comm: sh Not tainted 3.16.0-rc4-00025-g6dc9476-dirty #88
      task: 8f23dc60 ti: 8f1d8000 task.ti: 8f1d8000
      ...
      Call Trace:
      [<8010edbc>] resume+0x5c/0x280
      [<80481e0c>] __schedule+0x370/0x800
      [<80104838>] work_resched+0x8/0x2c
    
    Fix by consistently clearing both flags in both functions.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7309/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 2dafceb0d0c6..636b0745d7c7 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -66,6 +66,7 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 	clear_used_math();
 	clear_fpu_owner();
 	init_dsp();
+	clear_thread_flag(TIF_USEDMSA);
 	clear_thread_flag(TIF_MSA_CTX_LIVE);
 	disable_msa();
 	regs->cp0_epc = pc;
@@ -141,6 +142,8 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 	childregs->cp0_status &= ~(ST0_CU2|ST0_CU1);
 
 	clear_tsk_thread_flag(p, TIF_USEDFPU);
+	clear_tsk_thread_flag(p, TIF_USEDMSA);
+	clear_tsk_thread_flag(p, TIF_MSA_CTX_LIVE);
 
 #ifdef CONFIG_MIPS_MT_FPAFF
 	clear_tsk_thread_flag(p, TIF_FPUBOUND);

commit 60be939c5a7956cd93714b0737bf289269a52c17
Author: Alex Smith <alex@alex-smith.me.uk>
Date:   Wed Jul 23 14:40:15 2014 +0100

    MIPS: Remove asm/user.h
    
    The struct user definition in this file is not used anywhere (the ELF
    core dumper does not use that format). Therefore, remove the header and
    instead enable the asm-generic user.h which is an empty header to
    satisfy a few generic headers which still try to include user.h.
    
    Signed-off-by: Alex Smith <alex@alex-smith.me.uk>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7459/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 7564c371c660..2dafceb0d0c6 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -21,7 +21,6 @@
 #include <linux/mman.h>
 #include <linux/personality.h>
 #include <linux/sys.h>
-#include <linux/user.h>
 #include <linux/init.h>
 #include <linux/completion.h>
 #include <linux/kallsyms.h>
@@ -36,6 +35,7 @@
 #include <asm/pgtable.h>
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
+#include <asm/reg.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
 #include <asm/elf.h>

commit 30852ad0039b4a54b5062efd66877125e519dc30
Author: Alex Smith <alex@alex-smith.me.uk>
Date:   Wed Jul 23 14:40:14 2014 +0100

    MIPS: Remove old core dump functions
    
    Since the core dumper now uses regsets, the old core dump functions are
    now unused. Remove them.
    
    Signed-off-by: Alex Smith <alex@alex-smith.me.uk>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7456/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 0a1ec0f3beff..7564c371c660 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -152,61 +152,6 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 	return 0;
 }
 
-/* Fill in the fpu structure for a core dump.. */
-int dump_fpu(struct pt_regs *regs, elf_fpregset_t *r)
-{
-	int i;
-
-	for (i = 0; i < NUM_FPU_REGS; i++)
-		memcpy(&r[i], &current->thread.fpu.fpr[i], sizeof(*r));
-
-	memcpy(&r[NUM_FPU_REGS], &current->thread.fpu.fcr31,
-	       sizeof(current->thread.fpu.fcr31));
-
-	return 1;
-}
-
-void elf_dump_regs(elf_greg_t *gp, struct pt_regs *regs)
-{
-	int i;
-
-	for (i = 0; i < EF_R0; i++)
-		gp[i] = 0;
-	gp[EF_R0] = 0;
-	for (i = 1; i <= 31; i++)
-		gp[EF_R0 + i] = regs->regs[i];
-	gp[EF_R26] = 0;
-	gp[EF_R27] = 0;
-	gp[EF_LO] = regs->lo;
-	gp[EF_HI] = regs->hi;
-	gp[EF_CP0_EPC] = regs->cp0_epc;
-	gp[EF_CP0_BADVADDR] = regs->cp0_badvaddr;
-	gp[EF_CP0_STATUS] = regs->cp0_status;
-	gp[EF_CP0_CAUSE] = regs->cp0_cause;
-#ifdef EF_UNUSED0
-	gp[EF_UNUSED0] = 0;
-#endif
-}
-
-int dump_task_regs(struct task_struct *tsk, elf_gregset_t *regs)
-{
-	elf_dump_regs(*regs, task_pt_regs(tsk));
-	return 1;
-}
-
-int dump_task_fpu(struct task_struct *t, elf_fpregset_t *fpr)
-{
-	int i;
-
-	for (i = 0; i < NUM_FPU_REGS; i++)
-		memcpy(&fpr[i], &t->thread.fpu.fpr[i], sizeof(*fpr));
-
-	memcpy(&fpr[NUM_FPU_REGS], &t->thread.fpu.fcr31,
-	       sizeof(t->thread.fpu.fcr31));
-
-	return 1;
-}
-
 #ifdef CONFIG_CC_STACKPROTECTOR
 #include <linux/stackprotector.h>
 unsigned long __stack_chk_guard __read_mostly;

commit b633648c5ad3cfbda0b3daea50d2135d44899259
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri May 23 16:29:44 2014 +0200

    MIPS: MT: Remove SMTC support
    
    Nobody is maintaining SMTC anymore and there also seems to be no userbase.
    Which is a pity - the SMTC technology primarily developed by Kevin D.
    Kissell <kevink@paralogos.com> is an ingenious demonstration for the MT
    ASE's power and elegance.
    
    Based on Markos Chandras <Markos.Chandras@imgtec.com> patch
    https://patchwork.linux-mips.org/patch/6719/ which while very similar did
    no longer apply cleanly when I tried to merge it plus some additional
    post-SMTC cleanup - SMTC was a feature as tricky to remove as it was to
    merge once upon a time.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 60e39dc7f1eb..0a1ec0f3beff 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -140,13 +140,6 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 	 */
 	childregs->cp0_status &= ~(ST0_CU2|ST0_CU1);
 
-#ifdef CONFIG_MIPS_MT_SMTC
-	/*
-	 * SMTC restores TCStatus after Status, and the CU bits
-	 * are aliased there.
-	 */
-	childregs->cp0_tcstatus &= ~(ST0_CU2|ST0_CU1);
-#endif
 	clear_tsk_thread_flag(p, TIF_USEDFPU);
 
 #ifdef CONFIG_MIPS_MT_FPAFF

commit 1db1af84d6df99a8e5d6ddea8c7b5c1327c9a620
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Jan 27 15:23:11 2014 +0000

    MIPS: Basic MSA context switching support
    
    This patch adds support for context switching the MSA vector registers.
    These 128 bit vector registers are aliased with the FP registers - an
    FP register accesses the least significant bits of the vector register
    with which it is aliased (ie. the register with the same index). Due to
    both this & the requirement that the scalar FPU must be 64-bit (FR=1) if
    enabled at the same time as MSA the kernel will enable MSA & scalar FP
    at the same time for tasks which use MSA. If we restore the MSA vector
    context then we might as well enable the scalar FPU since the reason it
    was left disabled was to allow for lazy FP context restoring - but we
    just restored the FP context as it's a subset of the vector context. If
    we restore the FP context and have previously used MSA then we have to
    restore the whole vector context anyway (see comment in
    enable_restore_fp_context for details) so similarly we might as well
    enable MSA.
    
    Thus if a task does not use MSA then it will continue to behave as
    without this patch - the scalar FP context will be saved & restored as
    usual. But if a task executes an MSA instruction then it will save &
    restore the vector context forever more.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6431/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 2f01f3d48d75..60e39dc7f1eb 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -32,6 +32,7 @@
 #include <asm/cpu.h>
 #include <asm/dsp.h>
 #include <asm/fpu.h>
+#include <asm/msa.h>
 #include <asm/pgtable.h>
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
@@ -65,6 +66,8 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 	clear_used_math();
 	clear_fpu_owner();
 	init_dsp();
+	clear_thread_flag(TIF_MSA_CTX_LIVE);
+	disable_msa();
 	regs->cp0_epc = pc;
 	regs->regs[29] = sp;
 }
@@ -89,7 +92,9 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 
 	preempt_disable();
 
-	if (is_fpu_owner())
+	if (is_msa_enabled())
+		save_msa(p);
+	else if (is_fpu_owner())
 		save_fp(p);
 
 	if (cpu_has_dsp)

commit 6cec7c4ad79f8fd66574044adfa284b20ee7c4fd
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Jan 27 15:23:06 2014 +0000

    MIPS: Don't assume 64-bit FP registers for dump_{,task_}fpu
    
    This code assumed that saved FP registers are 64 bits wide, an
    assumption which will no longer be true once MSA is introduced. This
    patch modifies the code to copy the lower 64 bits of each register in
    turn, which is safe for any FP register width >= 64 bits.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6425/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 6ae540e133b2..2f01f3d48d75 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -157,7 +157,13 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 /* Fill in the fpu structure for a core dump.. */
 int dump_fpu(struct pt_regs *regs, elf_fpregset_t *r)
 {
-	memcpy(r, &current->thread.fpu, sizeof(current->thread.fpu));
+	int i;
+
+	for (i = 0; i < NUM_FPU_REGS; i++)
+		memcpy(&r[i], &current->thread.fpu.fpr[i], sizeof(*r));
+
+	memcpy(&r[NUM_FPU_REGS], &current->thread.fpu.fcr31,
+	       sizeof(current->thread.fpu.fcr31));
 
 	return 1;
 }
@@ -192,7 +198,13 @@ int dump_task_regs(struct task_struct *tsk, elf_gregset_t *regs)
 
 int dump_task_fpu(struct task_struct *t, elf_fpregset_t *fpr)
 {
-	memcpy(fpr, &t->thread.fpu, sizeof(current->thread.fpu));
+	int i;
+
+	for (i = 0; i < NUM_FPU_REGS; i++)
+		memcpy(&fpr[i], &t->thread.fpu.fpr[i], sizeof(*fpr));
+
+	memcpy(&fpr[NUM_FPU_REGS], &t->thread.fpu.fcr31,
+	       sizeof(t->thread.fpu.fcr31));
 
 	return 1;
 }

commit a3056b1ca5db9103e079f3d8d9e386b3590b9250
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Tue Nov 19 17:30:38 2013 +0000

    MIPS: replace open-coded init_dsp
    
    There is already an init_dsp function which checks cpu_has_dsp & calls
    __init_dsp if it does. Make use of it instead of duplicating the same
    code.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Reviewed-by: Qais Yousef <qais.yousef@imgtec.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6148/

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 747a6cfbb709..6ae540e133b2 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -64,8 +64,7 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 	regs->cp0_status = status;
 	clear_used_math();
 	clear_fpu_owner();
-	if (cpu_has_dsp)
-		__init_dsp();
+	init_dsp();
 	regs->cp0_epc = pc;
 	regs->regs[29] = sp;
 }

commit 597ce1723e0fa0bdbe2ae4c94f18da6e29b92635
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Fri Nov 22 13:12:07 2013 +0000

    MIPS: Support for 64-bit FP with O32 binaries
    
    CPUs implementing MIPS32 R2 may include a 64-bit FPU, just as MIPS64 CPUs
    do. In order to preserve backwards compatibility a 64-bit FPU will act
    like a 32-bit FPU (by accessing doubles from the least significant 32
    bits of an even-odd pair of FP registers) when the Status.FR bit is
    zero, again just like a mips64 CPU. The standard O32 ABI is defined
    expecting a 32-bit FPU, however recent toolchains support use of a
    64-bit FPU from an O32 MIPS32 executable. When an ELF executable is
    built to use a 64-bit FPU a new flag (EF_MIPS_FP64) is set in the ELF
    header.
    
    With this patch the kernel will check the EF_MIPS_FP64 flag when
    executing an O32 binary, and set Status.FR accordingly. The addition
    of O32 64-bit FP support lessens the opportunity for optimisation in
    the FPU emulator, so a CONFIG_MIPS_O32_FP64_SUPPORT Kconfig option is
    introduced to allow this support to be disabled for those that don't
    require it.
    
    Inspired by an earlier patch by Leonid Yegoshin, but implemented more
    cleanly & correctly.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Paul Burton <paul.burton@imgtec.com>
    Patchwork: https://patchwork.linux-mips.org/patch/6154/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index ddc76103e78c..747a6cfbb709 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -60,9 +60,6 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 
 	/* New thread loses kernel privileges. */
 	status = regs->cp0_status & ~(ST0_CU0|ST0_CU1|ST0_FR|KU_MASK);
-#ifdef CONFIG_64BIT
-	status |= test_thread_flag(TIF_32BIT_REGS) ? 0 : ST0_FR;
-#endif
 	status |= KU_USER;
 	regs->cp0_status = status;
 	clear_used_math();

commit 42a111797e8fa961d6168922e873d6b4be87e904
Author: Tony Wu <tung7970@gmail.com>
Date:   Fri Jun 21 10:09:23 2013 +0000

    MIPS: Fix typos and cleanup comment
    
    Signed-off-by: Tony Wu <tung7970@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5535/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 7d62894f7e23..ddc76103e78c 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -207,9 +207,6 @@ unsigned long __stack_chk_guard __read_mostly;
 EXPORT_SYMBOL(__stack_chk_guard);
 #endif
 
-/*
- *
- */
 struct mips_frame_info {
 	void		*func;
 	unsigned long	func_size;

commit 36ecafc5ad17861e2bc1fb12af4cc97680e25942
Author: Gregory Fong <gregory.0xf0@gmail.com>
Date:   Wed Jun 12 17:08:54 2013 +0000

    MIPS: initial stack protector support
    
    Implements basic stack protector support based on ARM version in
    c743f38013aeff58ef6252601e397b5ba281c633 , with Kconfig option,
    constant canary value set at boot time, and script to check if
    compiler actually supports stack protector.
    
    Tested by creating a kernel module that writes past end of char[].
    
    Signed-off-by: Gregory Fong <gregory.0xf0@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: Filippo Arcidiacono <filippo.arcidiacono@st.com>
    Cc: Carmelo Amoroso <carmelo.amoroso@st.com>
    Patchwork: https://patchwork.linux-mips.org/patch/5448/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index c6a041d9d05d..7d62894f7e23 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -201,6 +201,12 @@ int dump_task_fpu(struct task_struct *t, elf_fpregset_t *fpr)
 	return 1;
 }
 
+#ifdef CONFIG_CC_STACKPROTECTOR
+#include <linux/stackprotector.h>
+unsigned long __stack_chk_guard __read_mostly;
+EXPORT_SYMBOL(__stack_chk_guard);
+#endif
+
 /*
  *
  */

commit 49f2ec91e14ce9bb20fdac88a38243129f3261c3
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 21 10:53:37 2013 +0200

    MIPS: Consolidate idle loop / WAIT instruction support in a single file.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index a682a87bcc04..c6a041d9d05d 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -51,19 +51,6 @@ void arch_cpu_idle_dead(void)
 }
 #endif
 
-void arch_cpu_idle(void)
-{
-#ifdef CONFIG_MIPS_MT_SMTC
-	extern void smtc_idle_loop_hook(void);
-
-	smtc_idle_loop_hook();
-#endif
-	if (cpu_wait)
-		(*cpu_wait)();
-	else
-		local_irq_enable();
-}
-
 asmlinkage void ret_from_fork(void);
 asmlinkage void ret_from_kernel_thread(void);
 

commit 5000653e923de49aa282fd7d172eb6528c3ec5c7
Author: Tony Wu <tung7970@gmail.com>
Date:   Sun May 12 15:05:34 2013 +0000

    MIPS: Extract schedule_mfi info from __schedule
    
    schedule_mfi is supposed to be extracted from schedule(), and
    is used in thread_saved_pc and get_wchan.
    
    But, after optimization, schedule() is reduced to a sibling
    call to __schedule(), and no real frame info can be extracted.
    
    One solution is to compile schedule() with -fno-omit-frame-pointer
    and -fno-optimize-sibling-calls, but that will incur performance
    degradation.
    
    Another solution is to extract info from the real scheduler,
    __schedule, and this is the approache adopted here.
    
    This patch reads the __schedule address by either following
    the 'j' call in schedule if KALLSYMS is disabled or by using
    kallsyms_lookup_name to lookup __schedule if KALLSYMS is
    available, then, extracts schedule_mfi from __schedule frame info.
    
    This patch also fixes the "Can't analyze schedule() prologue"
    warning at boot time.
    
    Signed-off-by: Tony Wu <tung7970@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5237/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 785bf2a4129a..a682a87bcc04 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -224,6 +224,9 @@ struct mips_frame_info {
 	int		pc_offset;
 };
 
+#define J_TARGET(pc,target)	\
+		(((unsigned long)(pc) & 0xf0000000) | ((target) << 2))
+
 static inline int is_ra_save_ins(union mips_instruction *ip)
 {
 #ifdef CONFIG_CPU_MICROMIPS
@@ -395,15 +398,42 @@ static int get_frame_info(struct mips_frame_info *info)
 
 static struct mips_frame_info schedule_mfi __read_mostly;
 
+#ifdef CONFIG_KALLSYMS
+static unsigned long get___schedule_addr(void)
+{
+	return kallsyms_lookup_name("__schedule");
+}
+#else
+static unsigned long get___schedule_addr(void)
+{
+	union mips_instruction *ip = (void *)schedule;
+	int max_insns = 8;
+	int i;
+
+	for (i = 0; i < max_insns; i++, ip++) {
+		if (ip->j_format.opcode == j_op)
+			return J_TARGET(ip, ip->j_format.target);
+	}
+	return 0;
+}
+#endif
+
 static int __init frame_info_init(void)
 {
 	unsigned long size = 0;
 #ifdef CONFIG_KALLSYMS
 	unsigned long ofs;
+#endif
+	unsigned long addr;
 
-	kallsyms_lookup_size_offset((unsigned long)schedule, &size, &ofs);
+	addr = get___schedule_addr();
+	if (!addr)
+		addr = (unsigned long)schedule;
+
+#ifdef CONFIG_KALLSYMS
+	kallsyms_lookup_size_offset(addr, &size, &ofs);
 #endif
-	schedule_mfi.func = schedule;
+	schedule_mfi.func = (void *)addr;
 	schedule_mfi.func_size = size;
 
 	get_frame_info(&schedule_mfi);

commit e7438c4b893e87311d2fb0facb3e6a0df17abe01
Author: Tony Wu <tung7970@gmail.com>
Date:   Sun May 12 15:04:29 2013 +0000

    MIPS: Fix sibling call handling in get_frame_info
    
    Given a function, get_frame_info() analyzes its instructions
    to figure out frame size and return address. get_frame_info()
    works as follows:
    
    1. analyze up to 128 instructions if the function size is unknown
    2. search for 'addiu/daddiu sp,sp,-immed' for frame size
    3. search for 'sw ra,offset(sp)' for return address
    4. end search when it sees jr/jal/jalr
    
    This leads to an issue when the given function is a sibling
    call, example shown as follows.
    
    801ca110 <schedule>:
    801ca110:       8f820000        lw      v0,0(gp)
    801ca114:       8c420000        lw      v0,0(v0)
    801ca118:       080726f0        j       801c9bc0 <__schedule>
    801ca11c:       00000000        nop
    
    801ca120 <io_schedule>:
    801ca120:       27bdffe8        addiu   sp,sp,-24
    801ca124:       3c028022        lui     v0,0x8022
    801ca128:       afbf0014        sw      ra,20(sp)
    
    In this case, get_frame_info() cannot properly detect schedule's
    frame info, and eventually returns io_schedule's instead.
    
    This patch adds 'j' to the end search condition to workaround
    sibling call cases.
    
    Signed-off-by: Tony Wu <tung7970@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5236/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index eb902c1f0cad..785bf2a4129a 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -264,7 +264,7 @@ static inline int is_ra_save_ins(union mips_instruction *ip)
 #endif
 }
 
-static inline int is_jal_jalr_jr_ins(union mips_instruction *ip)
+static inline int is_jump_ins(union mips_instruction *ip)
 {
 #ifdef CONFIG_CPU_MICROMIPS
 	/*
@@ -288,6 +288,8 @@ static inline int is_jal_jalr_jr_ins(union mips_instruction *ip)
 		return 0;
 	return (((ip->u_format.uimmediate >> 6) & mm_jalr_op) == mm_jalr_op);
 #else
+	if (ip->j_format.opcode == j_op)
+		return 1;
 	if (ip->j_format.opcode == jal_op)
 		return 1;
 	if (ip->r_format.opcode != spec_op)
@@ -350,7 +352,7 @@ static int get_frame_info(struct mips_frame_info *info)
 
 	for (i = 0; i < max_insns; i++, ip++) {
 
-		if (is_jal_jalr_jr_ins(ip))
+		if (is_jump_ins(ip))
 			break;
 		if (!info->frame_size) {
 			if (is_sp_move_ins(ip))

commit daf799cca8abbf7f3e253ecf1d41d244070773d7
Merge: 6019958d146a b22d1b6a91ca
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 10 07:48:05 2013 -0700

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
    
     - More work on DT support for various platforms
    
     - Various fixes that were to late to make it straight into 3.9
    
     - Improved platform support, in particular the Netlogic XLR and
       BCM63xx, and the SEAD3 and Malta eval boards.
    
     - Support for several Ralink SOC families.
    
     - Complete support for the microMIPS ASE which basically reencodes the
       existing MIPS32/MIPS64 ISA to use non-constant size instructions.
    
     - Some fallout from LTO work which remove old cruft and will generally
       make the MIPS kernel easier to maintain and resistant to compiler
       optimization, even in absence of LTO.
    
     - KVM support.  While MIPS has announced hardware virtualization
       extensions this KVM extension uses trap and emulate mode for
       virtualization of MIPS32.  More KVM work to add support for VZ
       hardware virtualizaiton extensions and MIPS64 will probably already
       be merged for 3.11.
    
    Most of this has been sitting in -next for a long time.  All defconfigs
    have been build or run time tested except three for which fixes are being
    sent by other maintainers.
    
    Semantic conflict with kvm updates done as per Ralf
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (118 commits)
      MIPS: Add new GIC clockevent driver.
      MIPS: Formatting clean-ups for clocksources.
      MIPS: Refactor GIC clocksource code.
      MIPS: Move 'gic_frequency' to common location.
      MIPS: Move 'gic_present' to common location.
      MIPS: MIPS16e: Add unaligned access support.
      MIPS: MIPS16e: Support handling of delay slots.
      MIPS: MIPS16e: Add instruction formats.
      MIPS: microMIPS: Optimise 'strnlen' core library function.
      MIPS: microMIPS: Optimise 'strlen' core library function.
      MIPS: microMIPS: Optimise 'strncpy' core library function.
      MIPS: microMIPS: Optimise 'memset' core library function.
      MIPS: microMIPS: Add configuration option for microMIPS kernel.
      MIPS: microMIPS: Disable LL/SC and fix linker bug.
      MIPS: microMIPS: Add vdso support.
      MIPS: microMIPS: Add unaligned access support.
      MIPS: microMIPS: Support handling of delay slots.
      MIPS: microMIPS: Add support for exception handling.
      MIPS: microMIPS: Floating point support.
      MIPS: microMIPS: Fix macro naming in micro-assembler.
      ...

commit 34c2f668d0f6b2ca1c076d8170d6cd4f2235a9d4
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Mon Mar 25 13:18:07 2013 -0500

    MIPS: microMIPS: Add unaligned access support.
    
    Add logic needed to handle unaligned accesses in microMIPS mode.
    
    Signed-off-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 3be4405c2d14..ef533760d2c8 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -7,6 +7,7 @@
  * Copyright (C) 2005, 2006 by Ralf Baechle (ralf@linux-mips.org)
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  * Copyright (C) 2004 Thiemo Seufer
+ * Copyright (C) 2013  Imagination Technologies Ltd.
  */
 #include <linux/errno.h>
 #include <linux/sched.h>
@@ -243,34 +244,115 @@ struct mips_frame_info {
 
 static inline int is_ra_save_ins(union mips_instruction *ip)
 {
+#ifdef CONFIG_CPU_MICROMIPS
+	union mips_instruction mmi;
+
+	/*
+	 * swsp ra,offset
+	 * swm16 reglist,offset(sp)
+	 * swm32 reglist,offset(sp)
+	 * sw32 ra,offset(sp)
+	 * jradiussp - NOT SUPPORTED
+	 *
+	 * microMIPS is way more fun...
+	 */
+	if (mm_insn_16bit(ip->halfword[0])) {
+		mmi.word = (ip->halfword[0] << 16);
+		return ((mmi.mm16_r5_format.opcode == mm_swsp16_op &&
+			 mmi.mm16_r5_format.rt == 31) ||
+			(mmi.mm16_m_format.opcode == mm_pool16c_op &&
+			 mmi.mm16_m_format.func == mm_swm16_op));
+	}
+	else {
+		mmi.halfword[0] = ip->halfword[1];
+		mmi.halfword[1] = ip->halfword[0];
+		return ((mmi.mm_m_format.opcode == mm_pool32b_op &&
+			 mmi.mm_m_format.rd > 9 &&
+			 mmi.mm_m_format.base == 29 &&
+			 mmi.mm_m_format.func == mm_swm32_func) ||
+			(mmi.i_format.opcode == mm_sw32_op &&
+			 mmi.i_format.rs == 29 &&
+			 mmi.i_format.rt == 31));
+	}
+#else
 	/* sw / sd $ra, offset($sp) */
 	return (ip->i_format.opcode == sw_op || ip->i_format.opcode == sd_op) &&
 		ip->i_format.rs == 29 &&
 		ip->i_format.rt == 31;
+#endif
 }
 
 static inline int is_jal_jalr_jr_ins(union mips_instruction *ip)
 {
+#ifdef CONFIG_CPU_MICROMIPS
+	/*
+	 * jr16,jrc,jalr16,jalr16
+	 * jal
+	 * jalr/jr,jalr.hb/jr.hb,jalrs,jalrs.hb
+	 * jraddiusp - NOT SUPPORTED
+	 *
+	 * microMIPS is kind of more fun...
+	 */
+	union mips_instruction mmi;
+
+	mmi.word = (ip->halfword[0] << 16);
+
+	if ((mmi.mm16_r5_format.opcode == mm_pool16c_op &&
+	    (mmi.mm16_r5_format.rt & mm_jr16_op) == mm_jr16_op) ||
+	    ip->j_format.opcode == mm_jal32_op)
+		return 1;
+	if (ip->r_format.opcode != mm_pool32a_op ||
+			ip->r_format.func != mm_pool32axf_op)
+		return 0;
+	return (((ip->u_format.uimmediate >> 6) & mm_jalr_op) == mm_jalr_op);
+#else
 	if (ip->j_format.opcode == jal_op)
 		return 1;
 	if (ip->r_format.opcode != spec_op)
 		return 0;
 	return ip->r_format.func == jalr_op || ip->r_format.func == jr_op;
+#endif
 }
 
 static inline int is_sp_move_ins(union mips_instruction *ip)
 {
+#ifdef CONFIG_CPU_MICROMIPS
+	/*
+	 * addiusp -imm
+	 * addius5 sp,-imm
+	 * addiu32 sp,sp,-imm
+	 * jradiussp - NOT SUPPORTED
+	 *
+	 * microMIPS is not more fun...
+	 */
+	if (mm_insn_16bit(ip->halfword[0])) {
+		union mips_instruction mmi;
+
+		mmi.word = (ip->halfword[0] << 16);
+		return ((mmi.mm16_r3_format.opcode == mm_pool16d_op &&
+			 mmi.mm16_r3_format.simmediate && mm_addiusp_func) ||
+			(mmi.mm16_r5_format.opcode == mm_pool16d_op &&
+			 mmi.mm16_r5_format.rt == 29));
+	}
+	return (ip->mm_i_format.opcode == mm_addiu32_op &&
+		 ip->mm_i_format.rt == 29 && ip->mm_i_format.rs == 29);
+#else
 	/* addiu/daddiu sp,sp,-imm */
 	if (ip->i_format.rs != 29 || ip->i_format.rt != 29)
 		return 0;
 	if (ip->i_format.opcode == addiu_op || ip->i_format.opcode == daddiu_op)
 		return 1;
+#endif
 	return 0;
 }
 
 static int get_frame_info(struct mips_frame_info *info)
 {
+#ifdef CONFIG_CPU_MICROMIPS
+	union mips_instruction *ip = (void *) (((char *) info->func) - 1);
+#else
 	union mips_instruction *ip = info->func;
+#endif
 	unsigned max_insns = info->func_size / sizeof(union mips_instruction);
 	unsigned i;
 
@@ -290,7 +372,26 @@ static int get_frame_info(struct mips_frame_info *info)
 			break;
 		if (!info->frame_size) {
 			if (is_sp_move_ins(ip))
+			{
+#ifdef CONFIG_CPU_MICROMIPS
+				if (mm_insn_16bit(ip->halfword[0]))
+				{
+					unsigned short tmp;
+
+					if (ip->halfword[0] & mm_addiusp_func)
+					{
+						tmp = (((ip->halfword[0] >> 1) & 0x1ff) << 2);
+						info->frame_size = -(signed short)(tmp | ((tmp & 0x100) ? 0xfe00 : 0));
+					} else {
+						tmp = (ip->halfword[0] >> 1);
+						info->frame_size = -(signed short)(tmp & 0xf);
+					}
+					ip = (void *) &ip->halfword[1];
+					ip--;
+				} else
+#endif
 				info->frame_size = - ip->i_format.simmediate;
+			}
 			continue;
 		}
 		if (info->pc_offset == -1 && is_ra_save_ins(ip)) {

commit cdbedc61c8d0122ad682815936f0d11df1fe5f57
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu Mar 21 22:49:52 2013 +0100

    mips: Use generic idle loop
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Paul McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Cc: Srivatsa S. Bhat <srivatsa.bhat@linux.vnet.ibm.com>
    Cc: Magnus Damm <magnus.damm@gmail.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Link: http://lkml.kernel.org/r/20130321215234.754954871@linutronix.de
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 3be4405c2d14..cfc742d75b7f 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -41,44 +41,26 @@
 #include <asm/inst.h>
 #include <asm/stacktrace.h>
 
-/*
- * The idle thread. There's no useful work to be done, so just try to conserve
- * power and have a low exit latency (ie sit in a loop waiting for somebody to
- * say that they'd like to reschedule)
- */
-void __noreturn cpu_idle(void)
+#ifdef CONFIG_HOTPLUG_CPU
+void arch_cpu_idle_dead(void)
 {
-	int cpu;
-
-	/* CPU is going idle. */
-	cpu = smp_processor_id();
+	/* What the heck is this check doing ? */
+	if (!cpu_isset(smp_processor_id(), cpu_callin_map))
+		play_dead();
+}
+#endif
 
-	/* endless idle loop with no priority at all */
-	while (1) {
-		tick_nohz_idle_enter();
-		rcu_idle_enter();
-		while (!need_resched() && cpu_online(cpu)) {
+void arch_cpu_idle(void)
+{
 #ifdef CONFIG_MIPS_MT_SMTC
-			extern void smtc_idle_loop_hook(void);
+	extern void smtc_idle_loop_hook(void);
 
-			smtc_idle_loop_hook();
+	smtc_idle_loop_hook();
 #endif
-
-			if (cpu_wait) {
-				/* Don't trace irqs off for idle */
-				stop_critical_timings();
-				(*cpu_wait)();
-				start_critical_timings();
-			}
-		}
-#ifdef CONFIG_HOTPLUG_CPU
-		if (!cpu_online(cpu) && !cpu_isset(cpu, cpu_callin_map))
-			play_dead();
-#endif
-		rcu_idle_exit();
-		tick_nohz_idle_exit();
-		schedule_preempt_disabled();
-	}
+	if (cpu_wait)
+		(*cpu_wait)();
+	else
+		local_irq_enable();
 }
 
 asmlinkage void ret_from_fork(void);

commit aebb2afd5420c860b7fbc3882a323ef1247fbf16
Merge: 8eae508b7c6f edb15d83a875
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 2 07:44:16 2013 -0800

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
    
     o Add basic support for the Mediatek/Ralink Wireless SoC family.
    
     o The Qualcomm Atheros platform is extended by support for the new
       QCA955X SoC series as well as a bunch of patches that get the code
       ready for OF support.
    
     o Lantiq and BCM47XX platform have a few improvements and bug fixes.
    
     o MIPS has sent a few patches that get the kernel ready for the
       upcoming microMIPS support.
    
     o The rest of the series is made up of small bug fixes and cleanups
       that relate to various parts of the MIPS code.  The biggy in there is
       a whitespace cleanup.  After I was sent another set of whitespace
       cleanup patches I decided it was the time to clean the whitespace
       "issues" for once and and that touches many files below arch/mips/.
    
    Fix up silly conflicts, mostly due to whitespace cleanups.
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (105 commits)
      MIPS: Quit exporting kernel internel break codes to uapi/asm/break.h
      MIPS: remove broken conditional inside vpe loader code
      MIPS: SMTC: fix implicit declaration of set_vi_handler
      MIPS: early_printk: drop __init annotations
      MIPS: Probe for and report hardware virtualization support.
      MIPS: ath79: add support for the Qualcomm Atheros AP136-010 board
      MIPS: ath79: add USB controller registration code for the QCA955X SoCs
      MIPS: ath79: add PCI controller registration code for the QCA955X SoCs
      MIPS: ath79: add WMAC registration code for the QCA955X SoCs
      MIPS: ath79: register UART for the QCA955X SoCs
      MIPS: ath79: add QCA955X specific glue to ath79_device_reset_{set, clear}
      MIPS: ath79: add GPIO setup code for the QCA955X SoCs
      MIPS: ath79: add IRQ handling code for the QCA955X SoCs
      MIPS: ath79: add clock setup code for the QCA955X SoCs
      MIPS: ath79: add SoC detection code for the QCA955X SoCs
      MIPS: ath79: add early printk support for the QCA955X SoCs
      MIPS: ath79: fix WMAC IRQ resource assignment
      mips: reserve elfcorehdr
      mips: Make sure kernel memory is in iomem
      MIPS: ath79: use dynamically allocated USB platform devices
      ...

commit 64b3122df48b81a40366a11f299ab819138c96e8
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Thu Dec 27 11:52:32 2012 -0500

    mips: take the "zero newsp means inherit the parent's one" to copy_thread()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index a11c6f9fdd5e..a33d2ef8f273 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -156,7 +156,8 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 	*childregs = *regs;
 	childregs->regs[7] = 0;	/* Clear error flag */
 	childregs->regs[2] = 0;	/* Child gets zero as return value */
-	childregs->regs[29] = usp;
+	if (usp)
+		childregs->regs[29] = usp;
 	ti->addr_limit = USER_DS;
 
 	p->thread.reg29 = (unsigned long) childregs;

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index a11c6f9fdd5e..902e7803fcfa 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -154,8 +154,8 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 		return 0;
 	}
 	*childregs = *regs;
-	childregs->regs[7] = 0;	/* Clear error flag */
-	childregs->regs[2] = 0;	/* Child gets zero as return value */
+	childregs->regs[7] = 0; /* Clear error flag */
+	childregs->regs[2] = 0; /* Child gets zero as return value */
 	childregs->regs[29] = usp;
 	ti->addr_limit = USER_DS;
 

commit cebfa85eb86d92bf85d3b041c6b044184517a988
Merge: d42b3a2906a1 241738bd51cb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 14 14:27:45 2012 -0800

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
     "The MIPS bits for 3.8.  This also includes a bunch fixes that were
      sitting in the linux-mips.org git tree for a long time.  This pull
      request contains updates to several OCTEON drivers and the board
      support code for BCM47XX, BCM63XX, XLP, XLR, XLS, lantiq, Loongson1B,
      updates to the SSB bus support, MIPS kexec code and adds support for
      kdump.
    
      When pulling this, there are two expected merge conflicts in
      include/linux/bcma/bcma_driver_chipcommon.h which are trivial to
      resolve, just remove the conflict markers and keep both alternatives."
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (90 commits)
      MIPS: PMC-Sierra Yosemite: Remove support.
      VIDEO: Newport Fix console crashes
      MIPS: wrppmc: Fix build of PCI code.
      MIPS: IP22/IP28: Fix build of EISA code.
      MIPS: RB532: Fix build of prom code.
      MIPS: PowerTV: Fix build.
      MIPS: IP27: Correct fucked grammar in ops-bridge.c
      MIPS: Highmem: Fix build error if CONFIG_DEBUG_HIGHMEM is disabled
      MIPS: Fix potencial corruption
      MIPS: Fix for warning from FPU emulation code
      MIPS: Handle COP3 Unusable exception as COP1X for FP emulation
      MIPS: Fix poweroff failure when HOTPLUG_CPU configured.
      MIPS: MT: Fix build with CONFIG_UIDGID_STRICT_TYPE_CHECKS=y
      MIPS: Remove unused smvp.h
      MIPS/EDAC: Improve OCTEON EDAC support.
      MIPS: OCTEON: Add definitions for OCTEON memory contoller registers.
      MIPS: OCTEON: Add OCTEON family definitions to octeon-model.h
      ata: pata_octeon_cf: Use correct byte order for DMA in when built little-endian.
      MIPS/OCTEON/ata: Convert pata_octeon_cf.c to use device tree.
      MIPS: Remove usage of CEVT_R4K_LIB config option.
      ...

commit 8add1ecb81f541ef2fcb0b85a5470ad9ecfb4a84
Author: Huacai Chen <chenhc@lemote.com>
Date:   Mon Aug 13 20:52:24 2012 +0800

    MIPS: Fix poweroff failure when HOTPLUG_CPU configured.
    
    When poweroff machine, kernel_power_off() call disable_nonboot_cpus().
    And if we have HOTPLUG_CPU configured, disable_nonboot_cpus() is not an
    empty function but attempt to actually disable the nonboot cpus. Since
    system state is SYSTEM_POWER_OFF, play_dead() won't be called and thus
    disable_nonboot_cpus() hangs. Therefore, we make this patch to avoid
    poweroff failure.
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Hongliang Tao <taohl@lemote.com>
    Signed-off-by: Hua Yan <yanh@lemote.com>
    Cc: Yong Zhang <yong.zhang@windriver.com>
    Cc: stable@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Patchwork: https://patchwork.linux-mips.org/patch/4211/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index e9a5fd7277f4..69b17a920049 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -72,9 +72,7 @@ void __noreturn cpu_idle(void)
 			}
 		}
 #ifdef CONFIG_HOTPLUG_CPU
-		if (!cpu_online(cpu) && !cpu_isset(cpu, cpu_callin_map) &&
-		    (system_state == SYSTEM_RUNNING ||
-		     system_state == SYSTEM_BOOTING))
+		if (!cpu_online(cpu) && !cpu_isset(cpu, cpu_callin_map))
 			play_dead();
 #endif
 		rcu_idle_exit();

commit afa86fc426ff7e7f5477f15da9c405d08d5cf790
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Mon Oct 22 22:51:14 2012 -0400

    flagday: don't pass regs to copy_thread()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index d13720ac656f..38097652d62d 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -114,10 +114,10 @@ void flush_thread(void)
 }
 
 int copy_thread(unsigned long clone_flags, unsigned long usp,
-	unsigned long arg, struct task_struct *p, struct pt_regs *regs)
+	unsigned long arg, struct task_struct *p)
 {
 	struct thread_info *ti = task_thread_info(p);
-	struct pt_regs *childregs;
+	struct pt_regs *childregs, *regs = current_pt_regs();
 	unsigned long childksp;
 	p->set_child_tid = p->clear_child_tid = NULL;
 

commit 8f54bcacbc39f883bde2210cf2754e5d198f55a4
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Tue Oct 9 16:27:45 2012 -0400

    mips: switch to generic kernel_thread()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index e9a5fd7277f4..d13720ac656f 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -84,6 +84,7 @@ void __noreturn cpu_idle(void)
 }
 
 asmlinkage void ret_from_fork(void);
+asmlinkage void ret_from_kernel_thread(void);
 
 void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 {
@@ -113,7 +114,7 @@ void flush_thread(void)
 }
 
 int copy_thread(unsigned long clone_flags, unsigned long usp,
-	unsigned long unused, struct task_struct *p, struct pt_regs *regs)
+	unsigned long arg, struct task_struct *p, struct pt_regs *regs)
 {
 	struct thread_info *ti = task_thread_info(p);
 	struct pt_regs *childregs;
@@ -136,19 +137,30 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 	childregs = (struct pt_regs *) childksp - 1;
 	/*  Put the stack after the struct pt_regs.  */
 	childksp = (unsigned long) childregs;
+	p->thread.cp0_status = read_c0_status() & ~(ST0_CU2|ST0_CU1);
+	if (unlikely(p->flags & PF_KTHREAD)) {
+		unsigned long status = p->thread.cp0_status;
+		memset(childregs, 0, sizeof(struct pt_regs));
+		ti->addr_limit = KERNEL_DS;
+		p->thread.reg16 = usp; /* fn */
+		p->thread.reg17 = arg;
+		p->thread.reg29 = childksp;
+		p->thread.reg31 = (unsigned long) ret_from_kernel_thread;
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+		status = (status & ~(ST0_KUP | ST0_IEP | ST0_IEC)) |
+			 ((status & (ST0_KUC | ST0_IEC)) << 2);
+#else
+		status |= ST0_EXL;
+#endif
+		childregs->cp0_status = status;
+		return 0;
+	}
 	*childregs = *regs;
 	childregs->regs[7] = 0;	/* Clear error flag */
-
 	childregs->regs[2] = 0;	/* Child gets zero as return value */
+	childregs->regs[29] = usp;
+	ti->addr_limit = USER_DS;
 
-	if (childregs->cp0_status & ST0_CU0) {
-		childregs->regs[28] = (unsigned long) ti;
-		childregs->regs[29] = childksp;
-		ti->addr_limit = KERNEL_DS;
-	} else {
-		childregs->regs[29] = usp;
-		ti->addr_limit = USER_DS;
-	}
 	p->thread.reg29 = (unsigned long) childregs;
 	p->thread.reg31 = (unsigned long) ret_from_fork;
 
@@ -156,7 +168,6 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 	 * New tasks lose permission to use the fpu. This accelerates context
 	 * switching for most programs since they don't use the fpu.
 	 */
-	p->thread.cp0_status = read_c0_status() & ~(ST0_CU2|ST0_CU1);
 	childregs->cp0_status &= ~(ST0_CU2|ST0_CU1);
 
 #ifdef CONFIG_MIPS_MT_SMTC
@@ -221,35 +232,6 @@ int dump_task_fpu(struct task_struct *t, elf_fpregset_t *fpr)
 	return 1;
 }
 
-/*
- * Create a kernel thread
- */
-static void __noreturn kernel_thread_helper(void *arg, int (*fn)(void *))
-{
-	do_exit(fn(arg));
-}
-
-long kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
-{
-	struct pt_regs regs;
-
-	memset(&regs, 0, sizeof(regs));
-
-	regs.regs[4] = (unsigned long) arg;
-	regs.regs[5] = (unsigned long) fn;
-	regs.cp0_epc = (unsigned long) kernel_thread_helper;
-	regs.cp0_status = read_c0_status();
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
-	regs.cp0_status = (regs.cp0_status & ~(ST0_KUP | ST0_IEP | ST0_IEC)) |
-			  ((regs.cp0_status & (ST0_KUC | ST0_IEC)) << 2);
-#else
-	regs.cp0_status |= ST0_EXL;
-#endif
-
-	/* Ok, create the new process.. */
-	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
-}
-
 /*
  *
  */

commit b81947c646bfefdf98e2fde5d7d39cbbda8525d4
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for MIPS
    
    Disintegrate asm/system.h for MIPS.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    cc: linux-mips@linux-mips.org

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 61f1cb45a1d5..e9a5fd7277f4 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -32,7 +32,6 @@
 #include <asm/dsp.h>
 #include <asm/fpu.h>
 #include <asm/pgtable.h>
-#include <asm/system.h>
 #include <asm/mipsregs.h>
 #include <asm/processor.h>
 #include <asm/uaccess.h>

commit bd2f55361f18347e890d52ff9cfd8895455ec11b
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon Mar 21 12:33:18 2011 +0100

    sched/rt: Use schedule_preempt_disabled()
    
    Coccinelle based conversion.
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Acked-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Link: http://lkml.kernel.org/n/tip-24swm5zut3h9c4a6s46x8rws@git.kernel.org
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 7955409051c4..61f1cb45a1d5 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -80,9 +80,7 @@ void __noreturn cpu_idle(void)
 #endif
 		rcu_idle_exit();
 		tick_nohz_idle_exit();
-		preempt_enable_no_resched();
-		schedule();
-		preempt_disable();
+		schedule_preempt_disabled();
 	}
 }
 

commit 1268fbc746ea1cd279886a740dcbad4ba5232225
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Thu Nov 17 18:48:14 2011 +0100

    nohz: Remove tick_nohz_idle_enter_norcu() / tick_nohz_idle_exit_norcu()
    
    Those two APIs were provided to optimize the calls of
    tick_nohz_idle_enter() and rcu_idle_enter() into a single
    irq disabled section. This way no interrupt happening in-between would
    needlessly process any RCU job.
    
    Now we are talking about an optimization for which benefits
    have yet to be measured. Let's start simple and completely decouple
    idle rcu and dyntick idle logics to simplify.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 17fb3a270160..7955409051c4 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -56,7 +56,8 @@ void __noreturn cpu_idle(void)
 
 	/* endless idle loop with no priority at all */
 	while (1) {
-		tick_nohz_idle_enter_norcu();
+		tick_nohz_idle_enter();
+		rcu_idle_enter();
 		while (!need_resched() && cpu_online(cpu)) {
 #ifdef CONFIG_MIPS_MT_SMTC
 			extern void smtc_idle_loop_hook(void);
@@ -77,7 +78,8 @@ void __noreturn cpu_idle(void)
 		     system_state == SYSTEM_BOOTING))
 			play_dead();
 #endif
-		tick_nohz_idle_exit_norcu();
+		rcu_idle_exit();
+		tick_nohz_idle_exit();
 		preempt_enable_no_resched();
 		schedule();
 		preempt_disable();

commit 2bbb6817c0ac1b5f2a68d720f364f98eeb1ac4fd
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Sat Oct 8 16:01:00 2011 +0200

    nohz: Allow rcu extended quiescent state handling seperately from tick stop
    
    It is assumed that rcu won't be used once we switch to tickless
    mode and until we restart the tick. However this is not always
    true, as in x86-64 where we dereference the idle notifiers after
    the tick is stopped.
    
    To prepare for fixing this, add two new APIs:
    tick_nohz_idle_enter_norcu() and tick_nohz_idle_exit_norcu().
    
    If no use of RCU is made in the idle loop between
    tick_nohz_enter_idle() and tick_nohz_exit_idle() calls, the arch
    must instead call the new *_norcu() version such that the arch doesn't
    need to call rcu_idle_enter() and rcu_idle_exit().
    
    Otherwise the arch must call tick_nohz_enter_idle() and
    tick_nohz_exit_idle() and also call explicitly:
    
    - rcu_idle_enter() after its last use of RCU before the CPU is put
    to sleep.
    - rcu_idle_exit() before the first use of RCU after the CPU is woken
    up.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: David Miller <davem@davemloft.net>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Hans-Christian Egtvedt <hans-christian.egtvedt@atmel.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index c11e5ca2a434..17fb3a270160 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -56,7 +56,7 @@ void __noreturn cpu_idle(void)
 
 	/* endless idle loop with no priority at all */
 	while (1) {
-		tick_nohz_idle_enter();
+		tick_nohz_idle_enter_norcu();
 		while (!need_resched() && cpu_online(cpu)) {
 #ifdef CONFIG_MIPS_MT_SMTC
 			extern void smtc_idle_loop_hook(void);
@@ -77,7 +77,7 @@ void __noreturn cpu_idle(void)
 		     system_state == SYSTEM_BOOTING))
 			play_dead();
 #endif
-		tick_nohz_idle_exit();
+		tick_nohz_idle_exit_norcu();
 		preempt_enable_no_resched();
 		schedule();
 		preempt_disable();

commit 280f06774afedf849f0b34248ed6aff57d0f6908
Author: Frederic Weisbecker <fweisbec@gmail.com>
Date:   Fri Oct 7 18:22:06 2011 +0200

    nohz: Separate out irq exit and idle loop dyntick logic
    
    The tick_nohz_stop_sched_tick() function, which tries to delay
    the next timer tick as long as possible, can be called from two
    places:
    
    - From the idle loop to start the dytick idle mode
    - From interrupt exit if we have interrupted the dyntick
    idle mode, so that we reprogram the next tick event in
    case the irq changed some internal state that requires this
    action.
    
    There are only few minor differences between both that
    are handled by that function, driven by the ts->inidle
    cpu variable and the inidle parameter. The whole guarantees
    that we only update the dyntick mode on irq exit if we actually
    interrupted the dyntick idle mode, and that we enter in RCU extended
    quiescent state from idle loop entry only.
    
    Split this function into:
    
    - tick_nohz_idle_enter(), which sets ts->inidle to 1, enters
    dynticks idle mode unconditionally if it can, and enters into RCU
    extended quiescent state.
    
    - tick_nohz_irq_exit() which only updates the dynticks idle mode
    when ts->inidle is set (ie: if tick_nohz_idle_enter() has been called).
    
    To maintain symmetry, tick_nohz_restart_sched_tick() has been renamed
    into tick_nohz_idle_exit().
    
    This simplifies the code and micro-optimize the irq exit path (no need
    for local_irq_save there). This also prepares for the split between
    dynticks and rcu extended quiescent state logics. We'll need this split to
    further fix illegal uses of RCU in extended quiescent states in the idle
    loop.
    
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Mike Frysinger <vapier@gentoo.org>
    Cc: Guan Xuetao <gxt@mprc.pku.edu.cn>
    Cc: David Miller <davem@davemloft.net>
    Cc: Chris Metcalf <cmetcalf@tilera.com>
    Cc: Hans-Christian Egtvedt <hans-christian.egtvedt@atmel.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Russell King <linux@arm.linux.org.uk>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Signed-off-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Reviewed-by: Josh Triplett <josh@joshtriplett.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index c47f96e453c0..c11e5ca2a434 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -56,7 +56,7 @@ void __noreturn cpu_idle(void)
 
 	/* endless idle loop with no priority at all */
 	while (1) {
-		tick_nohz_stop_sched_tick(1);
+		tick_nohz_idle_enter();
 		while (!need_resched() && cpu_online(cpu)) {
 #ifdef CONFIG_MIPS_MT_SMTC
 			extern void smtc_idle_loop_hook(void);
@@ -77,7 +77,7 @@ void __noreturn cpu_idle(void)
 		     system_state == SYSTEM_BOOTING))
 			play_dead();
 #endif
-		tick_nohz_restart_sched_tick();
+		tick_nohz_idle_exit();
 		preempt_enable_no_resched();
 		schedule();
 		preempt_disable();

commit cae39d1386dba405de0fbda32e224a1535d38a07
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Thu Jul 28 18:46:31 2011 -0400

    mips: add export.h to files using EXPORT_SYMBOL/THIS_MODULE
    
    Or else we get lots of variations on this:
    
    arch/mips/pci/pci.c:330: warning: type defaults to 'int' in declaration of 'EXPORT_SYMBOL'
    
    scattered throughout the build.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 5b7a28448fae..c47f96e453c0 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -15,6 +15,7 @@
 #include <linux/mm.h>
 #include <linux/stddef.h>
 #include <linux/unistd.h>
+#include <linux/export.h>
 #include <linux/ptrace.h>
 #include <linux/mman.h>
 #include <linux/personality.h>

commit 848484e2c41220f07b432ffea79874a1b02ce6db
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Jul 23 16:55:17 2011 -0400

    mips: remove needless include of module.h from core kernel files.
    
    None of these files are using modular infrastructure, and build
    tests reveal that none of these files are really relying on any
    implicit inclusions via. module.h either.  So delete them.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index b30cb2573aaf..5b7a28448fae 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -9,7 +9,6 @@
  * Copyright (C) 2004 Thiemo Seufer
  */
 #include <linux/errno.h>
-#include <linux/module.h>
 #include <linux/sched.h>
 #include <linux/tick.h>
 #include <linux/kernel.h>

commit 6fd4ce886440c7a1b08b6642e606ee19097829df
Merge: ba5b56cb3e3d bf28607fbe52
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 26 14:17:28 2011 -0700

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/upstream-linus
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/upstream-linus: (31 commits)
      MIPS: Close races in TLB modify handlers.
      MIPS: Add uasm UASM_i_SRL_SAFE macro.
      MIPS: RB532: Use hex_to_bin()
      MIPS: Enable cpu_has_clo_clz for MIPS Technologies' platforms
      MIPS: PowerTV: Provide cpu-feature-overrides.h
      MIPS: Remove pointless return statement from empty void functions.
      MIPS: Limit fixrange_init() to the FIXMAP region
      MIPS: Install handlers for software IRQs
      MIPS: Move FIXADDR_TOP into spaces.h
      MIPS: Add SYNC after cacheflush
      MIPS: pfn_valid() is broken on low memory HIGHMEM systems
      MIPS: HIGHMEM DMA on noncoherent MIPS32 processors
      MIPS: topdown mmap support
      MIPS: Remove redundant addr_limit assignment on exec.
      MIPS: AR7: Replace __attribute__((__packed__)) with __packed
      MIPS: AR7: Remove 'space before tabs' in platform.c
      MIPS: Lantiq: Add missing clk_enable and clk_disable functions.
      MIPS: AR7: Fix trailing semicolon bug in clock.c
      MAINTAINERS: Update MIPS entry.
      MIPS: BCM63xx: Remove duplicate PERF_IRQSTAT_REG definition
      ...

commit 3a7136602b6fcb27073a241006cd5d029cacfafa
Author: Mathias Krause <minipli@googlemail.com>
Date:   Fri Jun 10 15:10:04 2011 +0200

    MIPS: Remove redundant addr_limit assignment on exec.
    
    The address limit is already set in flush_old_exec() via set_fs(USER_DS)
    so this assignment is redundant.
    
    [ralf@linux-mips.org: also see dac853ae89043f1b7752875300faf614de43c74b for
    further explanation.]
    
    Signed-off-by: Mathias Krause <minipli@googlemail.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/2466/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index d2112d3cf115..a8d53e508bb7 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -103,7 +103,6 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 		__init_dsp();
 	regs->cp0_epc = pc;
 	regs->regs[29] = sp;
-	current_thread_info()->addr_limit = USER_DS;
 }
 
 void exit_thread(void)

commit 94ea09c6a8e6c5ffb59bb1d5ca10008d37544e1a
Author: Daniel Kalmar <kalmard@homejinni.com>
Date:   Fri May 13 08:38:04 2011 -0400

    MIPS: Add new unwind_stack variant
    
    The unwind_stack_by_address variant supports unwinding based
    on any kernel code address.
    This symbol is also exported so it can be called from modules.
    
    Signed-off-by: Daniel Kalmar <kalmard@homejinni.com>
    Signed-off-by: Gergely Kis <gergely@homejinni.com>
    Signed-off-by: Robert Richter <robert.richter@amd.com>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index d2112d3cf115..c28fbe6107bc 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -373,18 +373,18 @@ unsigned long thread_saved_pc(struct task_struct *tsk)
 
 
 #ifdef CONFIG_KALLSYMS
-/* used by show_backtrace() */
-unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
-			   unsigned long pc, unsigned long *ra)
+/* generic stack unwinding function */
+unsigned long notrace unwind_stack_by_address(unsigned long stack_page,
+					      unsigned long *sp,
+					      unsigned long pc,
+					      unsigned long *ra)
 {
-	unsigned long stack_page;
 	struct mips_frame_info info;
 	unsigned long size, ofs;
 	int leaf;
 	extern void ret_from_irq(void);
 	extern void ret_from_exception(void);
 
-	stack_page = (unsigned long)task_stack_page(task);
 	if (!stack_page)
 		return 0;
 
@@ -443,6 +443,15 @@ unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
 	*ra = 0;
 	return __kernel_text_address(pc) ? pc : 0;
 }
+EXPORT_SYMBOL(unwind_stack_by_address);
+
+/* used by show_backtrace() */
+unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
+			   unsigned long pc, unsigned long *ra)
+{
+	unsigned long stack_page = (unsigned long)task_stack_page(task);
+	return unwind_stack_by_address(stack_page, sp, pc, ra);
+}
 #endif
 
 /*

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index ae167df73ddd..d2112d3cf115 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -410,7 +410,7 @@ unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
 	if (!kallsyms_lookup_size_offset(pc, &size, &ofs))
 		return 0;
 	/*
-	 * Return ra if an exception occured at the first instruction
+	 * Return ra if an exception occurred at the first instruction
 	 */
 	if (unlikely(ofs == 0)) {
 		pc = *ra;

commit a989ff898f9740651d00388c33bdf4f2a7914920
Author: Al Viro <viro@ZenIV.linux.org.uk>
Date:   Thu Nov 4 11:13:59 2010 +0000

    MIPS: Don't stomp on caller's ->regs[2] in copy_thread()
    
    We never needed that (->regs[2] is overwritten on return from syscall paths
    with return value of syscall, so storing it there early made no sense) and
    with new restart logics since d27240bf7e61d2656de18e158ec910a902030847 it
    has become really bad - we lose the original syscall number before the
    place where we decide that we might need a syscall restart.
    
    Note that for child we do need the assignment to regs[2] - it won't go
    through the normal return from syscall path.
    
    [Ralf: Issue found and reported by Llus; initial investigations by me;
    bug finally found and patch by Al; testing by me and Llus.]
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Tested-by: Llus Batlle i Rossell <viriketo@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 99960940d4a4..ae167df73ddd 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -142,7 +142,6 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 	childregs->regs[7] = 0;	/* Clear error flag */
 
 	childregs->regs[2] = 0;	/* Child gets zero as return value */
-	regs->regs[2] = p->pid;
 
 	if (childregs->cp0_status & ST0_CU0) {
 		childregs->regs[28] = (unsigned long) ti;

commit 7a7ac952d5217b2f568e5ef91ac39b572e166f24
Author: Wu Zhangjin <wuzhangjin@gmail.com>
Date:   Wed Mar 10 00:27:28 2010 +0800

    MIPS: Trace: Don't trace irqsoff for the idle process
    
    Like x86 did in arch/x86/kernel/{process_32.c,process_64.c}, also don't
    trace irqsoff for idle.
    
    If there's no useful work to be done, we don't care about the irqsoff
    duration. If we trace the idle process, the max duration of irqsoff will
    be the idle time and make the irqsoff tracer useless.
    
    Signed-off-by: Wu Zhangjin <wuzhangjin@gmail.com>
    Cc: linux-mips@linux-mips.org
    Cc: Steven Rostedt <rostedt@goodmis.org>
    Cc: Frederic Weisbecker <fweisbec@gmail.com>
    Cc: Ingo Molnar <mingo@redhat.com>
    Patchwork: http://patchwork.linux-mips.org/patch/1044/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 463b71b90a00..99960940d4a4 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -63,8 +63,13 @@ void __noreturn cpu_idle(void)
 
 			smtc_idle_loop_hook();
 #endif
-			if (cpu_wait)
+
+			if (cpu_wait) {
+				/* Don't trace irqs off for idle */
+				stop_critical_timings();
 				(*cpu_wait)();
+				start_critical_timings();
+			}
 		}
 #ifdef CONFIG_HOTPLUG_CPU
 		if (!cpu_online(cpu) && !cpu_isset(cpu, cpu_callin_map) &&

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index f3d73e1831c1..463b71b90a00 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -17,7 +17,6 @@
 #include <linux/stddef.h>
 #include <linux/unistd.h>
 #include <linux/ptrace.h>
-#include <linux/slab.h>
 #include <linux/mman.h>
 #include <linux/personality.h>
 #include <linux/sys.h>

commit 484889fc85a223ef56edc31828b86751b2296b7c
Author: David Daney <ddaney@caviumnetworks.com>
Date:   Wed Jul 8 10:07:50 2009 -0700

    MIPS: Avoid clobbering struct pt_regs in kthreads
    
    The resume() implementation octeon_switch.S examines the saved cp0_status
    register.  We were clobbering the entire pt_regs structure in kernel
    threads leading to random crashes.
    
    When switching away from a kernel thread, the saved cp0_status is examined
    and if bit 30 is set it is cleared and the CP2 state saved into the pt_regs
    structure.  Since the kernel thread stack overlaid the pt_regs structure
    this resulted in a corrupt stack.  When the kthread with the corrupt stack
    was resumed, it could crash if it used any of the data in the stack that was
    clobbered.
    
    We fix it by moving the kernel thread stack down so it doesn't overlay
    pt_regs.
    
    Signed-off-by: David Daney <ddaney@caviumnetworks.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index c09d681b7181..f3d73e1831c1 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -115,7 +115,7 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 {
 	struct thread_info *ti = task_thread_info(p);
 	struct pt_regs *childregs;
-	long childksp;
+	unsigned long childksp;
 	p->set_child_tid = p->clear_child_tid = NULL;
 
 	childksp = (unsigned long)task_stack_page(p) + THREAD_SIZE - 32;
@@ -132,6 +132,8 @@ int copy_thread(unsigned long clone_flags, unsigned long usp,
 
 	/* set up new TSS. */
 	childregs = (struct pt_regs *) childksp - 1;
+	/*  Put the stack after the struct pt_regs.  */
+	childksp = (unsigned long) childregs;
 	*childregs = *regs;
 	childregs->regs[7] = 0;	/* Clear error flag */
 

commit 1b2bc75c1bde6581d2694cb3ed7fb06b69685008
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jun 23 10:00:31 2009 +0100

    MIPS: Add arch generic CPU hotplug
    
    Each platform has to add support for CPU hotplugging itself by providing
    suitable definitions for the cpu_disable and cpu_die of the smp_ops
    methods and setting SYS_SUPPORTS_HOTPLUG_CPU.  A platform should only set
    SYS_SUPPORTS_HOTPLUG_CPU once all it's smp_ops definitions have the
    necessary changes.  This patch contains the changes to the dummy smp_ops
    definition for uni-processor systems.
    
    Parts of the code contributed by Cavium Inc.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 1eaaa450e20c..c09d681b7181 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -50,10 +50,15 @@
  */
 void __noreturn cpu_idle(void)
 {
+	int cpu;
+
+	/* CPU is going idle. */
+	cpu = smp_processor_id();
+
 	/* endless idle loop with no priority at all */
 	while (1) {
 		tick_nohz_stop_sched_tick(1);
-		while (!need_resched()) {
+		while (!need_resched() && cpu_online(cpu)) {
 #ifdef CONFIG_MIPS_MT_SMTC
 			extern void smtc_idle_loop_hook(void);
 
@@ -62,6 +67,12 @@ void __noreturn cpu_idle(void)
 			if (cpu_wait)
 				(*cpu_wait)();
 		}
+#ifdef CONFIG_HOTPLUG_CPU
+		if (!cpu_online(cpu) && !cpu_isset(cpu, cpu_callin_map) &&
+		    (system_state == SYSTEM_RUNNING ||
+		     system_state == SYSTEM_BOOTING))
+			play_dead();
+#endif
 		tick_nohz_restart_sched_tick();
 		preempt_enable_no_resched();
 		schedule();

commit 6f2c55b843836d26528c56a0968689accaedbc67
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Thu Apr 2 16:56:59 2009 -0700

    Simplify copy_thread()
    
    First argument unused since 2.3.11.
    
    [akpm@linux-foundation.org: coding-style fixes]
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: <linux-arch@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index ca2e4026ad20..1eaaa450e20c 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -99,7 +99,7 @@ void flush_thread(void)
 {
 }
 
-int copy_thread(int nr, unsigned long clone_flags, unsigned long usp,
+int copy_thread(unsigned long clone_flags, unsigned long usp,
 	unsigned long unused, struct task_struct *p, struct pt_regs *regs)
 {
 	struct thread_info *ti = task_thread_info(p);

commit e758936e02700ff88a0b08b722a3847b95283ef2
Merge: 239cfbde1f58 4480f15b3306
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Mon Oct 13 17:13:56 2008 +0100

    Merge branch 'master' of git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6
    
    Conflicts:
    
            include/asm-x86/statfs.h

commit 9cc123631b6630948eb5059d218f44424888daa7
Author: Kevin D. Kissell <kevink@paralogos.com>
Date:   Tue Sep 9 21:33:36 2008 +0200

    [MIPS] SMTC: Fix holes in SMTC and FPU affinity support.
    
    Signed-off-by: Kevin D. Kissell <kevink@paralogos.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index ce7684335a41..22fc19bbe87f 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -55,7 +55,7 @@ void __noreturn cpu_idle(void)
 	while (1) {
 		tick_nohz_stop_sched_tick(1);
 		while (!need_resched()) {
-#ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG
+#ifdef CONFIG_MIPS_MT_SMTC
 			extern void smtc_idle_loop_hook(void);
 
 			smtc_idle_loop_hook();
@@ -145,19 +145,18 @@ int copy_thread(int nr, unsigned long clone_flags, unsigned long usp,
 	 */
 	p->thread.cp0_status = read_c0_status() & ~(ST0_CU2|ST0_CU1);
 	childregs->cp0_status &= ~(ST0_CU2|ST0_CU1);
+
+#ifdef CONFIG_MIPS_MT_SMTC
+	/*
+	 * SMTC restores TCStatus after Status, and the CU bits
+	 * are aliased there.
+	 */
+	childregs->cp0_tcstatus &= ~(ST0_CU2|ST0_CU1);
+#endif
 	clear_tsk_thread_flag(p, TIF_USEDFPU);
 
 #ifdef CONFIG_MIPS_MT_FPAFF
 	clear_tsk_thread_flag(p, TIF_FPUBOUND);
-
-	/*
-	 * FPU affinity support is cleaner if we track the
-	 * user-visible CPU affinity from the very beginning.
-	 * The generic cpus_allowed mask will already have
-	 * been copied from the parent before copy_thread
-	 * is invoked.
-	 */
-	p->thread.user_cpus_allowed = p->cpus_allowed;
 #endif /* CONFIG_MIPS_MT_FPAFF */
 
 	if (clone_flags & CLONE_SETTLS)

commit 6657fe0a0281e06ff46eb42bc18ecb68d8b14b27
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 9 15:19:10 2008 +0200

    [MIPS] SMTC: Clear TIF_FPUBOUND on clone / fork.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index b16facd9ea8e..ce7684335a41 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -148,6 +148,8 @@ int copy_thread(int nr, unsigned long clone_flags, unsigned long usp,
 	clear_tsk_thread_flag(p, TIF_USEDFPU);
 
 #ifdef CONFIG_MIPS_MT_FPAFF
+	clear_tsk_thread_flag(p, TIF_FPUBOUND);
+
 	/*
 	 * FPU affinity support is cleaner if we track the
 	 * user-visible CPU affinity from the very beginning.

commit 9d5a9e74655b9d04d0ec9c8e47801163b7b74211
Author: Adrian Bunk <bunk@kernel.org>
Date:   Sat Jun 28 00:12:52 2008 +0300

    Remove asm/a.out.h files for all architectures without a.out support.
    
    This patch also includes the required removal of (unused) inclusion of
    <asm/a.out.h> <linux/a.out.h>'s in the arch/ code for these
    architectures.
    
    [dwmw2: updated for 2.6.27-rc]
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index b16facd9ea8e..17edc69cf5c1 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -22,7 +22,6 @@
 #include <linux/personality.h>
 #include <linux/sys.h>
 #include <linux/user.h>
-#include <linux/a.out.h>
 #include <linux/init.h>
 #include <linux/completion.h>
 #include <linux/kallsyms.h>

commit 9b610fda0df5d0f0b0c64242e37441ad1b384aac
Merge: b8f8c3cf0a4a 5b664cb235e9
Author: Ingo Molnar <mingo@elte.hu>
Date:   Fri Jul 18 19:53:16 2008 +0200

    Merge branch 'linus' into timers/nohz

commit b8f8c3cf0a4ac0632ec3f0e15e9dc0c29de917af
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri Jul 18 17:27:28 2008 +0200

    nohz: prevent tick stop outside of the idle loop
    
    Jack Ren and Eric Miao tracked down the following long standing
    problem in the NOHZ code:
    
            scheduler switch to idle task
            enable interrupts
    
    Window starts here
    
            ----> interrupt happens (does not set NEED_RESCHED)
                    irq_exit() stops the tick
    
            ----> interrupt happens (does set NEED_RESCHED)
    
            return from schedule()
    
            cpu_idle(): preempt_disable();
    
    Window ends here
    
    The interrupts can happen at any point inside the race window. The
    first interrupt stops the tick, the second one causes the scheduler to
    rerun and switch away from idle again and we end up with the tick
    disabled.
    
    The fact that it needs two interrupts where the first one does not set
    NEED_RESCHED and the second one does made the bug obscure and extremly
    hard to reproduce and analyse. Kudos to Jack and Eric.
    
    Solution: Limit the NOHZ functionality to the idle loop to make sure
    that we can not run into such a situation ever again.
    
    cpu_idle()
    {
            preempt_disable();
    
            while(1) {
                     tick_nohz_stop_sched_tick(1); <- tell NOHZ code that we
                                                      are in the idle loop
    
                     while (!need_resched())
                           halt();
    
                     tick_nohz_restart_sched_tick(); <- disables NOHZ mode
                     preempt_enable_no_resched();
                     schedule();
                     preempt_disable();
            }
    }
    
    In hindsight we should have done this forever, but ...
    
    /me grabs a large brown paperbag.
    
    Debugged-by: Jack Ren <jack.ren@marvell.com>,
    Debugged-by: eric miao <eric.y.miao@gmail.com>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 2c09a442e5e5..bdead3aad253 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -53,7 +53,7 @@ void __noreturn cpu_idle(void)
 {
 	/* endless idle loop with no priority at all */
 	while (1) {
-		tick_nohz_stop_sched_tick();
+		tick_nohz_stop_sched_tick(1);
 		while (!need_resched()) {
 #ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG
 			extern void smtc_idle_loop_hook(void);

commit 2957c9e61ee9c37e7ebf2c8acab03e073fe942fd
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jul 15 18:44:30 2008 +0100

    [MIPS] IRIX: Goodbye and thanks for all the fish
    
    Never terribly functional or popular, plagued by hard to fix bugs the time
    to say goodbye has more than arrived.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 2c09a442e5e5..c06f5b5d764c 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -125,13 +125,6 @@ int copy_thread(int nr, unsigned long clone_flags, unsigned long usp,
 	*childregs = *regs;
 	childregs->regs[7] = 0;	/* Clear error flag */
 
-#if defined(CONFIG_BINFMT_IRIX)
-	if (current->personality != PER_LINUX) {
-		/* Under IRIX things are a little different. */
-		childregs->regs[3] = 1;
-		regs->regs[3] = 0;
-	}
-#endif
 	childregs->regs[2] = 0;	/* Child gets zero as return value */
 	regs->regs[2] = p->pid;
 

commit bbaf238b5f910f8f3dda4b96cf844f50b2dcc6fa
Author: Chris Dearman <chris@mips.com>
Date:   Thu Dec 13 22:42:19 2007 +0000

    [MIPS] Ensure that ST0_FR is never set on a 32 bit kernel
    
    Signed-off-by: Chris Dearman <chris@mips.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 11cb264f59ce..2c09a442e5e5 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -77,9 +77,8 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 	unsigned long status;
 
 	/* New thread loses kernel privileges. */
-	status = regs->cp0_status & ~(ST0_CU0|ST0_CU1|KU_MASK);
+	status = regs->cp0_status & ~(ST0_CU0|ST0_CU1|ST0_FR|KU_MASK);
 #ifdef CONFIG_64BIT
-	status &= ~ST0_FR;
 	status |= test_thread_flag(TIF_32BIT_REGS) ? 0 : ST0_FR;
 #endif
 	status |= KU_USER;

commit 49a89efbbbcc178a39555c43bd59a7593c429664
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:15 2007 +0100

    [MIPS] Fix "no space between function name and open parenthesis" warnings.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index f99bb4085430..11cb264f59ce 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -202,13 +202,13 @@ void elf_dump_regs(elf_greg_t *gp, struct pt_regs *regs)
 #endif
 }
 
-int dump_task_regs (struct task_struct *tsk, elf_gregset_t *regs)
+int dump_task_regs(struct task_struct *tsk, elf_gregset_t *regs)
 {
 	elf_dump_regs(*regs, task_pt_regs(tsk));
 	return 1;
 }
 
-int dump_task_fpu (struct task_struct *t, elf_fpregset_t *fpr)
+int dump_task_fpu(struct task_struct *t, elf_fpregset_t *fpr)
 {
 	memcpy(fpr, &t->thread.fpu, sizeof(current->thread.fpu));
 

commit 7bcf7717b6a047c272410d0cd00213185fe6b99d
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 11 23:46:09 2007 +0100

    [MIPS] Implement clockevents for R4000-style cp0 count/compare interrupt
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index aadd2cd5778c..f99bb4085430 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -11,6 +11,7 @@
 #include <linux/errno.h>
 #include <linux/module.h>
 #include <linux/sched.h>
+#include <linux/tick.h>
 #include <linux/kernel.h>
 #include <linux/mm.h>
 #include <linux/stddef.h>
@@ -52,6 +53,7 @@ void __noreturn cpu_idle(void)
 {
 	/* endless idle loop with no priority at all */
 	while (1) {
+		tick_nohz_stop_sched_tick();
 		while (!need_resched()) {
 #ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG
 			extern void smtc_idle_loop_hook(void);
@@ -61,6 +63,7 @@ void __noreturn cpu_idle(void)
 			if (cpu_wait)
 				(*cpu_wait)();
 		}
+		tick_nohz_restart_sched_tick();
 		preempt_enable_no_resched();
 		schedule();
 		preempt_disable();

commit e5d77754c5e1a54f9eb61c03085d7932a0b6b738
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Tue Sep 18 18:49:08 2007 +0100

    [MIPS] R3000 setup for kernel_thread()
    
     Match the R4000 semantics for the initial state of interrupt/kernel
    status register flags for the R3000 in kernel_thread().
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index e6ce943099a0..aadd2cd5778c 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -231,8 +231,8 @@ long kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 	regs.cp0_epc = (unsigned long) kernel_thread_helper;
 	regs.cp0_status = read_c0_status();
 #if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
-	regs.cp0_status &= ~(ST0_KUP | ST0_IEC);
-	regs.cp0_status |= ST0_IEP;
+	regs.cp0_status = (regs.cp0_status & ~(ST0_KUP | ST0_IEP | ST0_IEC)) |
+			  ((regs.cp0_status & (ST0_KUC | ST0_IEC)) << 2);
 #else
 	regs.cp0_status |= ST0_EXL;
 #endif

commit 293c5bd13f124c325f74f89ad26edf5612ce7235
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Jul 25 16:19:33 2007 +0100

    [MIPS] Fixup secure computing stuff.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index bd05f5a927ea..e6ce943099a0 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -77,7 +77,7 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 	status = regs->cp0_status & ~(ST0_CU0|ST0_CU1|KU_MASK);
 #ifdef CONFIG_64BIT
 	status &= ~ST0_FR;
-	status |= (current->thread.mflags & MF_32BIT_REGS) ? 0 : ST0_FR;
+	status |= test_thread_flag(TIF_32BIT_REGS) ? 0 : ST0_FR;
 #endif
 	status |= KU_USER;
 	regs->cp0_status = status;

commit 941091024ef0f2f7e09eb81201d293ac18833cc8
Author: Franck Bui-Huu <fbuihuu@gmail.com>
Date:   Thu Jul 19 14:04:21 2007 +0200

    [MIPS] User stack pointer randomisation
    
    Signed-off-by: Franck Bui-Huu <fbuihuu@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 8f4cf27c7157..bd05f5a927ea 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -25,7 +25,9 @@
 #include <linux/init.h>
 #include <linux/completion.h>
 #include <linux/kallsyms.h>
+#include <linux/random.h>
 
+#include <asm/asm.h>
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
 #include <asm/dsp.h>
@@ -460,3 +462,15 @@ unsigned long get_wchan(struct task_struct *task)
 out:
 	return pc;
 }
+
+/*
+ * Don't forget that the stack pointer must be aligned on a 8 bytes
+ * boundary for 32-bits ABI and 16 bytes for 64-bits ABI.
+ */
+unsigned long arch_align_stack(unsigned long sp)
+{
+	if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
+		sp -= get_random_int() & ~PAGE_MASK;
+
+	return sp & ALMASK;
+}

commit b3f6df9f21c6efc4641613188204aa0742bc9e22
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Fri May 25 14:32:28 2007 -0400

    [MIPS] Transform old-style macros to newer "__noreturn"
    
    Convert old/obsolete NORET_TYPE and ATTRIB_NORET macros to use the
    newer standard of "__noreturn" as defined in compiler-gcc.h.
    
    Signed-off-by: Robert P. J. Day <rpjday@mindspring.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 6bdfb5a9fa1a..8f4cf27c7157 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -46,7 +46,7 @@
  * power and have a low exit latency (ie sit in a loop waiting for somebody to
  * say that they'd like to reschedule)
  */
-ATTRIB_NORET void cpu_idle(void)
+void __noreturn cpu_idle(void)
 {
 	/* endless idle loop with no priority at all */
 	while (1) {
@@ -213,7 +213,7 @@ int dump_task_fpu (struct task_struct *t, elf_fpregset_t *fpr)
 /*
  * Create a kernel thread
  */
-static ATTRIB_NORET void kernel_thread_helper(void *arg, int (*fn)(void *))
+static void __noreturn kernel_thread_helper(void *arg, int (*fn)(void *))
 {
 	do_exit(fn(arg));
 }

commit c68644d3304d217d50b8f0a179d4aa7e5a85a5bc
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Feb 26 20:46:34 2007 +0000

    [MIPS] Make SMTC_IDLE_HOOK_DEBUG a proper option in Kconfig.debug.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index a669089e4672..6bdfb5a9fa1a 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -51,11 +51,11 @@ ATTRIB_NORET void cpu_idle(void)
 	/* endless idle loop with no priority at all */
 	while (1) {
 		while (!need_resched()) {
-#ifdef CONFIG_MIPS_MT_SMTC
+#ifdef CONFIG_SMTC_IDLE_HOOK_DEBUG
 			extern void smtc_idle_loop_hook(void);
 
 			smtc_idle_loop_hook();
-#endif /* CONFIG_MIPS_MT_SMTC */
+#endif
 			if (cpu_wait)
 				(*cpu_wait)();
 		}

commit db0b937daf9bee741aa8fd488ea657872b9579fe
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Feb 19 00:54:27 2007 +0900

    [MIPS] Make kernel_thread_helper() static
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 9704c21607a2..a669089e4672 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -213,7 +213,7 @@ int dump_task_fpu (struct task_struct *t, elf_fpregset_t *fpr)
 /*
  * Create a kernel thread
  */
-ATTRIB_NORET void kernel_thread_helper(void *arg, int (*fn)(void *))
+static ATTRIB_NORET void kernel_thread_helper(void *arg, int (*fn)(void *))
 {
 	do_exit(fn(arg));
 }

commit 151fd6acd94e12ef3a7d5fa0911a2590690c493f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Feb 15 11:40:37 2007 +0000

    [MIPS] signals: Share even more code.
    
    native and compat do_signal and handle_signal are identical and can easily
    be unified.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 04e5b38d327d..9704c21607a2 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -26,7 +26,6 @@
 #include <linux/completion.h>
 #include <linux/kallsyms.h>
 
-#include <asm/abi.h>
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
 #include <asm/dsp.h>
@@ -66,38 +65,6 @@ ATTRIB_NORET void cpu_idle(void)
 	}
 }
 
-/*
- * Native o32 and N64 ABI without DSP ASE
- */
-struct mips_abi mips_abi = {
-	.do_signal	= do_signal,
-#ifdef CONFIG_TRAD_SIGNALS
-	.setup_frame	= setup_frame,
-#endif
-	.setup_rt_frame	= setup_rt_frame
-};
-
-#ifdef CONFIG_MIPS32_O32
-/*
- * o32 compatibility on 64-bit kernels, without DSP ASE
- */
-struct mips_abi mips_abi_32 = {
-	.do_signal	= do_signal32,
-	.setup_frame	= setup_frame_32,
-	.setup_rt_frame	= setup_rt_frame_32
-};
-#endif /* CONFIG_MIPS32_O32 */
-
-#ifdef CONFIG_MIPS32_N32
-/*
- * N32 on 64-bit kernels, without DSP ASE
- */
-struct mips_abi mips_abi_n32 = {
-	.do_signal	= do_signal,
-	.setup_rt_frame	= setup_rt_frame_n32
-};
-#endif /* CONFIG_MIPS32_N32 */
-
 asmlinkage void ret_from_fork(void);
 
 void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)

commit 447deafba4de56bfa5ed5d5778e56afe55432394
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Feb 5 00:34:20 2007 +0000

    [MIPS] SMTC: Cleanup idle hook invocation.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index ec8209f3a0c6..04e5b38d327d 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -41,10 +41,6 @@
 #include <asm/isadep.h>
 #include <asm/inst.h>
 #include <asm/stacktrace.h>
-#ifdef CONFIG_MIPS_MT_SMTC
-#include <asm/mipsmtregs.h>
-extern void smtc_idle_loop_hook(void);
-#endif /* CONFIG_MIPS_MT_SMTC */
 
 /*
  * The idle thread. There's no useful work to be done, so just try to conserve
@@ -57,6 +53,8 @@ ATTRIB_NORET void cpu_idle(void)
 	while (1) {
 		while (!need_resched()) {
 #ifdef CONFIG_MIPS_MT_SMTC
+			extern void smtc_idle_loop_hook(void);
+
 			smtc_idle_loop_hook();
 #endif /* CONFIG_MIPS_MT_SMTC */
 			if (cpu_wait)

commit 55b7428303d390c53d3a1bc587de8592ce65900e
Author: Franck Bui-Huu <fbuihuu@gmail.com>
Date:   Fri Oct 13 13:37:35 2006 +0200

    [MIPS] Use kallsyms_lookup_size_offset() instead of kallsyms_lookup()
    
    This new routine doesn't lookup for symbol names. So we needn't
    to pass any char buffers or pointer since we don't care about
    names.
    
    Signed-off-by: Franck Bui-Huu <fbuihuu@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 9f307eb1a31e..ec8209f3a0c6 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -358,10 +358,8 @@ static int __init frame_info_init(void)
 	unsigned long size = 0;
 #ifdef CONFIG_KALLSYMS
 	unsigned long ofs;
-	char *modname;
-	char namebuf[KSYM_NAME_LEN + 1];
 
-	kallsyms_lookup((unsigned long)schedule, &size, &ofs, &modname, namebuf);
+	kallsyms_lookup_size_offset((unsigned long)schedule, &size, &ofs);
 #endif
 	schedule_mfi.func = schedule;
 	schedule_mfi.func_size = size;
@@ -403,8 +401,6 @@ unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
 {
 	unsigned long stack_page;
 	struct mips_frame_info info;
-	char *modname;
-	char namebuf[KSYM_NAME_LEN + 1];
 	unsigned long size, ofs;
 	int leaf;
 	extern void ret_from_irq(void);
@@ -433,7 +429,7 @@ unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
 		}
 		return 0;
 	}
-	if (!kallsyms_lookup(pc, &size, &ofs, &modname, namebuf))
+	if (!kallsyms_lookup_size_offset(pc, &size, &ofs))
 		return 0;
 	/*
 	 * Return ra if an exception occured at the first instruction

commit e04582b7bc70b40c57287cdc24f81964ee88f565
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Oct 9 00:10:01 2006 +0900

    [MIPS] Make sure cpu_has_fpu is used only in atomic context
    
    Make sure cpu_has_fpu (which uses smp_processor_id()) is used only in
    atomic context.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 045d987bc683..9f307eb1a31e 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -115,7 +115,7 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 	status |= KU_USER;
 	regs->cp0_status = status;
 	clear_used_math();
-	lose_fpu();
+	clear_fpu_owner();
 	if (cpu_has_dsp)
 		__init_dsp();
 	regs->cp0_epc = pc;

commit 1924600cdb3143cdcc32b6fa43325739503659b9
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Sep 29 18:02:51 2006 +0900

    [MIPS] Make unwind_stack() can dig into interrupted context
    
    If the PC was ret_from_irq or ret_from_exception, there will be no
    more normal stackframe.  Instead of stopping the unwinding, use PC and
    RA saved by an exception handler to continue unwinding into the
    interrupted context.  This also simplifies the CONFIG_STACKTRACE code.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 695538031c69..045d987bc683 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -399,7 +399,7 @@ unsigned long thread_saved_pc(struct task_struct *tsk)
 #ifdef CONFIG_KALLSYMS
 /* used by show_backtrace() */
 unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
-			   unsigned long pc, unsigned long ra)
+			   unsigned long pc, unsigned long *ra)
 {
 	unsigned long stack_page;
 	struct mips_frame_info info;
@@ -407,18 +407,42 @@ unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
 	char namebuf[KSYM_NAME_LEN + 1];
 	unsigned long size, ofs;
 	int leaf;
+	extern void ret_from_irq(void);
+	extern void ret_from_exception(void);
 
 	stack_page = (unsigned long)task_stack_page(task);
 	if (!stack_page)
 		return 0;
 
+	/*
+	 * If we reached the bottom of interrupt context,
+	 * return saved pc in pt_regs.
+	 */
+	if (pc == (unsigned long)ret_from_irq ||
+	    pc == (unsigned long)ret_from_exception) {
+		struct pt_regs *regs;
+		if (*sp >= stack_page &&
+		    *sp + sizeof(*regs) <= stack_page + THREAD_SIZE - 32) {
+			regs = (struct pt_regs *)*sp;
+			pc = regs->cp0_epc;
+			if (__kernel_text_address(pc)) {
+				*sp = regs->regs[29];
+				*ra = regs->regs[31];
+				return pc;
+			}
+		}
+		return 0;
+	}
 	if (!kallsyms_lookup(pc, &size, &ofs, &modname, namebuf))
 		return 0;
 	/*
 	 * Return ra if an exception occured at the first instruction
 	 */
-	if (unlikely(ofs == 0))
-		return ra;
+	if (unlikely(ofs == 0)) {
+		pc = *ra;
+		*ra = 0;
+		return pc;
+	}
 
 	info.func = (void *)(pc - ofs);
 	info.func_size = ofs;	/* analyze from start to ofs */
@@ -437,11 +461,12 @@ unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
 		 * one. In that cases avoid to return always the
 		 * same value.
 		 */
-		pc = pc != ra ? ra : 0;
+		pc = pc != *ra ? *ra : 0;
 	else
 		pc = ((unsigned long *)(*sp))[info.pc_offset];
 
 	*sp += info.frame_size;
+	*ra = 0;
 	return __kernel_text_address(pc) ? pc : 0;
 }
 #endif
@@ -454,6 +479,7 @@ unsigned long get_wchan(struct task_struct *task)
 	unsigned long pc = 0;
 #ifdef CONFIG_KALLSYMS
 	unsigned long sp;
+	unsigned long ra = 0;
 #endif
 
 	if (!task || task == current || task->state == TASK_RUNNING)
@@ -467,7 +493,7 @@ unsigned long get_wchan(struct task_struct *task)
 	sp = task->thread.reg29 + schedule_mfi.frame_size;
 
 	while (in_sched_functions(pc))
-		pc = unwind_stack(task, &sp, pc, 0);
+		pc = unwind_stack(task, &sp, pc, &ra);
 #endif
 
 out:

commit 1df0f0ff7e56f6dcb1351b9490d55ebf91ff4bd8
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Sep 26 23:44:01 2006 +0900

    [MIPS] lockdep: Add STACKTRACE_SUPPORT and enable LOCKDEP_SUPPORT
    
    Implement stacktrace interface by using unwind_stack() and enable lockdep
    support in Kconfig.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 2613a0dd4b82..695538031c69 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -40,6 +40,7 @@
 #include <asm/elf.h>
 #include <asm/isadep.h>
 #include <asm/inst.h>
+#include <asm/stacktrace.h>
 #ifdef CONFIG_MIPS_MT_SMTC
 #include <asm/mipsmtregs.h>
 extern void smtc_idle_loop_hook(void);

commit b5943182592ba256639a569c7d5305cf60360733
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Fri Aug 18 16:18:09 2006 +0200

    [MIPS] get_wchan(): remove uses of mfinfo[64]
    
    This array was used to 'cache' some frame info about scheduler
    functions to speed up get_wchan(). This array was 1Ko size and
    was only used when CONFIG_KALLSYMS was set but declared for all
    configs.
    
    Rather than make the array statement conditional, this patches
    removes this array and its uses. Indeed the common case doesn't
    seem to use this array and get_wchan() is not a critical path
    anyways.
    
    It results in a smaller bss and a smaller/cleaner code:
    
       text    data     bss     dec     hex filename
    2543808  254148  139296 2937252  2cd1a4 vmlinux-new-get-wchan
    2544080  254148  143392 2941620  2ce2b4 vmlinux~old
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index b160ea30de0f..2613a0dd4b82 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -273,13 +273,15 @@ long kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }
 
-static struct mips_frame_info {
-	void *func;
-	unsigned long func_size;
-	int frame_size;
-	int pc_offset;
-} *schedule_frame, mfinfo[64];
-static int mfinfo_num;
+/*
+ *
+ */
+struct mips_frame_info {
+	void		*func;
+	unsigned long	func_size;
+	int		frame_size;
+	int		pc_offset;
+};
 
 static inline int is_ra_save_ins(union mips_instruction *ip)
 {
@@ -348,45 +350,30 @@ static int get_frame_info(struct mips_frame_info *info)
 	return -1;
 }
 
+static struct mips_frame_info schedule_mfi __read_mostly;
+
 static int __init frame_info_init(void)
 {
-	int i;
+	unsigned long size = 0;
 #ifdef CONFIG_KALLSYMS
+	unsigned long ofs;
 	char *modname;
 	char namebuf[KSYM_NAME_LEN + 1];
-	unsigned long start, size, ofs;
-	extern char __sched_text_start[], __sched_text_end[];
-	extern char __lock_text_start[], __lock_text_end[];
-
-	start = (unsigned long)__sched_text_start;
-	for (i = 0; i < ARRAY_SIZE(mfinfo); i++) {
-		if (start == (unsigned long)schedule)
-			schedule_frame = &mfinfo[i];
-		if (!kallsyms_lookup(start, &size, &ofs, &modname, namebuf))
-			break;
-		mfinfo[i].func = (void *)(start + ofs);
-		mfinfo[i].func_size = size;
-		start += size - ofs;
-		if (start >= (unsigned long)__lock_text_end)
-			break;
-		if (start == (unsigned long)__sched_text_end)
-			start = (unsigned long)__lock_text_start;
-	}
-#else
-	mfinfo[0].func = schedule;
-	schedule_frame = &mfinfo[0];
+
+	kallsyms_lookup((unsigned long)schedule, &size, &ofs, &modname, namebuf);
 #endif
-	for (i = 0; i < ARRAY_SIZE(mfinfo) && mfinfo[i].func; i++)
-		get_frame_info(mfinfo + i);
+	schedule_mfi.func = schedule;
+	schedule_mfi.func_size = size;
+
+	get_frame_info(&schedule_mfi);
 
 	/*
 	 * Without schedule() frame info, result given by
 	 * thread_saved_pc() and get_wchan() are not reliable.
 	 */
-	if (schedule_frame->pc_offset < 0)
+	if (schedule_mfi.pc_offset < 0)
 		printk("Can't analyze schedule() prologue at %p\n", schedule);
 
-	mfinfo_num = i;
 	return 0;
 }
 
@@ -402,58 +389,11 @@ unsigned long thread_saved_pc(struct task_struct *tsk)
 	/* New born processes are a special case */
 	if (t->reg31 == (unsigned long) ret_from_fork)
 		return t->reg31;
-
-	if (!schedule_frame || schedule_frame->pc_offset < 0)
+	if (schedule_mfi.pc_offset < 0)
 		return 0;
-	return ((unsigned long *)t->reg29)[schedule_frame->pc_offset];
+	return ((unsigned long *)t->reg29)[schedule_mfi.pc_offset];
 }
 
-/* get_wchan - a maintenance nightmare^W^Wpain in the ass ...  */
-unsigned long get_wchan(struct task_struct *p)
-{
-	unsigned long stack_page;
-	unsigned long pc;
-#ifdef CONFIG_KALLSYMS
-	unsigned long frame;
-#endif
-
-	if (!p || p == current || p->state == TASK_RUNNING)
-		return 0;
-
-	stack_page = (unsigned long)task_stack_page(p);
-	if (!stack_page || !mfinfo_num)
-		return 0;
-
-	pc = thread_saved_pc(p);
-#ifdef CONFIG_KALLSYMS
-	if (!in_sched_functions(pc))
-		return pc;
-
-	frame = p->thread.reg29 + schedule_frame->frame_size;
-	do {
-		int i;
-
-		if (frame < stack_page || frame > stack_page + THREAD_SIZE - 32)
-			return 0;
-
-		for (i = mfinfo_num - 1; i >= 0; i--) {
-			if (pc >= (unsigned long) mfinfo[i].func)
-				break;
-		}
-		if (i < 0)
-			break;
-
-		if (mfinfo[i].pc_offset < 0)
-			break;
-		pc = ((unsigned long *)frame)[mfinfo[i].pc_offset];
-		if (!mfinfo[i].frame_size)
-			break;
-		frame += mfinfo[i].frame_size;
-	} while (in_sched_functions(pc));
-#endif
-
-	return pc;
-}
 
 #ifdef CONFIG_KALLSYMS
 /* used by show_backtrace() */
@@ -504,3 +444,31 @@ unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
 	return __kernel_text_address(pc) ? pc : 0;
 }
 #endif
+
+/*
+ * get_wchan - a maintenance nightmare^W^Wpain in the ass ...
+ */
+unsigned long get_wchan(struct task_struct *task)
+{
+	unsigned long pc = 0;
+#ifdef CONFIG_KALLSYMS
+	unsigned long sp;
+#endif
+
+	if (!task || task == current || task->state == TASK_RUNNING)
+		goto out;
+	if (!task_stack_page(task))
+		goto out;
+
+	pc = thread_saved_pc(task);
+
+#ifdef CONFIG_KALLSYMS
+	sp = task->thread.reg29 + schedule_mfi.frame_size;
+
+	while (in_sched_functions(pc))
+		pc = unwind_stack(task, &sp, pc, 0);
+#endif
+
+out:
+	return pc;
+}

commit 29b376ff10aaea69ee4d93b70d0fbb2ebfd80f4e
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Fri Aug 18 16:18:08 2006 +0200

    [MIPS] get_frame_info(): null function size means size is unknown
    
    This patch adds 2 sanity checks.
    
    The first one test that the start address of the function to analyze has been
    set by the caller. If not return an error since nothing usefull can be done
    without.
    
    The second one checks that the function's size has been set. A null size can
    happen if CONFIG_KALLSYMS is not set and it means that we don't know the size
    of the function to analyze. In this case, we make it equal to 128 instructions
    by default.
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index e7b0b385fb2b..b160ea30de0f 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -311,12 +311,19 @@ static inline int is_sp_move_ins(union mips_instruction *ip)
 static int get_frame_info(struct mips_frame_info *info)
 {
 	union mips_instruction *ip = info->func;
-	int i, max_insns =
-		min(128UL, info->func_size / sizeof(union mips_instruction));
+	unsigned max_insns = info->func_size / sizeof(union mips_instruction);
+	unsigned i;
 
 	info->pc_offset = -1;
 	info->frame_size = 0;
 
+	if (!ip)
+		goto err;
+
+	if (max_insns == 0)
+		max_insns = 128U;	/* unknown function size */
+	max_insns = min(128U, max_insns);
+
 	for (i = 0; i < max_insns; i++, ip++) {
 
 		if (is_jal_jalr_jr_ins(ip))
@@ -337,6 +344,7 @@ static int get_frame_info(struct mips_frame_info *info)
 	if (info->pc_offset < 0) /* leaf */
 		return 1;
 	/* prologue seems boggus... */
+err:
 	return -1;
 }
 

commit 1fd6909802b837ed5510603846c0ce5938d296a1
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Fri Aug 18 16:18:07 2006 +0200

    [MIPS] unwind_stack(): return ra if an exception occured at the first instruction
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 951bf9ca3ce9..e7b0b385fb2b 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -465,8 +465,11 @@ unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
 
 	if (!kallsyms_lookup(pc, &size, &ofs, &modname, namebuf))
 		return 0;
-	if (ofs == 0)
-		return 0;
+	/*
+	 * Return ra if an exception occured at the first instruction
+	 */
+	if (unlikely(ofs == 0))
+		return ra;
 
 	info.func = (void *)(pc - ofs);
 	info.func_size = ofs;	/* analyze from start to ofs */

commit 4d157d5eac29d7d5559fdcabf20f3961bc5cb3e7
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Thu Aug 3 09:29:21 2006 +0200

    [MIPS] Improve unwind_stack()
    
    This patch allows unwind_stack() to return ra for leaf function.
    But it tries to detects cases where get_frame_info() wrongly
    consider nested function as a leaf one.
    
    It also pass 'unsinged long *sp' instead of 'unsigned long **sp'
    as second parameter. The code looks cleaner.
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 309bfa4a1520..951bf9ca3ce9 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -448,15 +448,16 @@ unsigned long get_wchan(struct task_struct *p)
 }
 
 #ifdef CONFIG_KALLSYMS
-/* used by show_frametrace() */
-unsigned long unwind_stack(struct task_struct *task,
-			   unsigned long **sp, unsigned long pc)
+/* used by show_backtrace() */
+unsigned long unwind_stack(struct task_struct *task, unsigned long *sp,
+			   unsigned long pc, unsigned long ra)
 {
 	unsigned long stack_page;
 	struct mips_frame_info info;
 	char *modname;
 	char namebuf[KSYM_NAME_LEN + 1];
 	unsigned long size, ofs;
+	int leaf;
 
 	stack_page = (unsigned long)task_stack_page(task);
 	if (!stack_page)
@@ -469,18 +470,26 @@ unsigned long unwind_stack(struct task_struct *task,
 
 	info.func = (void *)(pc - ofs);
 	info.func_size = ofs;	/* analyze from start to ofs */
-	if (get_frame_info(&info)) {
-		/* leaf or unknown */
-		*sp += info.frame_size / sizeof(long);
+	leaf = get_frame_info(&info);
+	if (leaf < 0)
 		return 0;
-	}
-	if ((unsigned long)*sp < stack_page ||
-	    (unsigned long)*sp + info.frame_size / sizeof(long) >
-	    stack_page + THREAD_SIZE - 32)
+
+	if (*sp < stack_page ||
+	    *sp + info.frame_size > stack_page + THREAD_SIZE - 32)
 		return 0;
 
-	pc = (*sp)[info.pc_offset];
-	*sp += info.frame_size / sizeof(long);
-	return pc;
+	if (leaf)
+		/*
+		 * For some extreme cases, get_frame_info() can
+		 * consider wrongly a nested function as a leaf
+		 * one. In that cases avoid to return always the
+		 * same value.
+		 */
+		pc = pc != ra ? ra : 0;
+	else
+		pc = ((unsigned long *)(*sp))[info.pc_offset];
+
+	*sp += info.frame_size;
+	return __kernel_text_address(pc) ? pc : 0;
 }
 #endif

commit 0cceb4aa9acf6192a5f02134e764b1feeea8b9de
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Thu Aug 3 09:29:20 2006 +0200

    [MIPS] Make get_frame_info() more robust
    
    Now get_frame_info() wants to detect move sp instruction first. It
    assumes that the save ra in the stack instruction can't happen
    before allocating frame size space into the stack.
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index da332d707ce5..309bfa4a1520 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -321,17 +321,15 @@ static int get_frame_info(struct mips_frame_info *info)
 
 		if (is_jal_jalr_jr_ins(ip))
 			break;
-		if (is_sp_move_ins(ip)) {
-			if (info->frame_size)
-				continue;
-			info->frame_size = - ip->i_format.simmediate;
+		if (!info->frame_size) {
+			if (is_sp_move_ins(ip))
+				info->frame_size = - ip->i_format.simmediate;
+			continue;
 		}
-
-		if (is_ra_save_ins(ip)) {
-			if (info->pc_offset != -1)
-				continue;
+		if (info->pc_offset == -1 && is_ra_save_ins(ip)) {
 			info->pc_offset =
 				ip->i_format.simmediate / sizeof(long);
+			break;
 		}
 	}
 	if (info->frame_size && info->pc_offset >= 0) /* nested */

commit 6057a7987608941a203f40f8b53513af433d8d2f
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Thu Aug 3 09:29:18 2006 +0200

    [MIPS] Make frame_info_init() more readable.
    
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 93d5432759db..da332d707ce5 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -370,15 +370,15 @@ static int __init frame_info_init(void)
 	mfinfo[0].func = schedule;
 	schedule_frame = &mfinfo[0];
 #endif
-	for (i = 0; i < ARRAY_SIZE(mfinfo) && mfinfo[i].func; i++) {
-		struct mips_frame_info *info = &mfinfo[i];
-		if (get_frame_info(info)) {
-			/* leaf or unknown */
-			if (info->func == schedule)
-				printk("Can't analyze prologue code at %p\n",
-				       info->func);
-		}
-	}
+	for (i = 0; i < ARRAY_SIZE(mfinfo) && mfinfo[i].func; i++)
+		get_frame_info(mfinfo + i);
+
+	/*
+	 * Without schedule() frame info, result given by
+	 * thread_saved_pc() and get_wchan() are not reliable.
+	 */
+	if (schedule_frame->pc_offset < 0)
+		printk("Can't analyze schedule() prologue at %p\n", schedule);
 
 	mfinfo_num = i;
 	return 0;

commit c0efbb6dc2726785482d85a284c883d541a6e0be
Author: Franck Bui-Huu <vagabon.xyz@gmail.com>
Date:   Thu Aug 3 09:29:15 2006 +0200

    [MIPS] Make get_frame_info() more readable.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Franck Bui-Huu <vagabon.xyz@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 8709a46a45c1..93d5432759db 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -281,48 +281,53 @@ static struct mips_frame_info {
 } *schedule_frame, mfinfo[64];
 static int mfinfo_num;
 
+static inline int is_ra_save_ins(union mips_instruction *ip)
+{
+	/* sw / sd $ra, offset($sp) */
+	return (ip->i_format.opcode == sw_op || ip->i_format.opcode == sd_op) &&
+		ip->i_format.rs == 29 &&
+		ip->i_format.rt == 31;
+}
+
+static inline int is_jal_jalr_jr_ins(union mips_instruction *ip)
+{
+	if (ip->j_format.opcode == jal_op)
+		return 1;
+	if (ip->r_format.opcode != spec_op)
+		return 0;
+	return ip->r_format.func == jalr_op || ip->r_format.func == jr_op;
+}
+
+static inline int is_sp_move_ins(union mips_instruction *ip)
+{
+	/* addiu/daddiu sp,sp,-imm */
+	if (ip->i_format.rs != 29 || ip->i_format.rt != 29)
+		return 0;
+	if (ip->i_format.opcode == addiu_op || ip->i_format.opcode == daddiu_op)
+		return 1;
+	return 0;
+}
+
 static int get_frame_info(struct mips_frame_info *info)
 {
-	int i;
-	void *func = info->func;
-	union mips_instruction *ip = (union mips_instruction *)func;
+	union mips_instruction *ip = info->func;
+	int i, max_insns =
+		min(128UL, info->func_size / sizeof(union mips_instruction));
+
 	info->pc_offset = -1;
 	info->frame_size = 0;
-	for (i = 0; i < 128; i++, ip++) {
-		/* if jal, jalr, jr, stop. */
-		if (ip->j_format.opcode == jal_op ||
-		    (ip->r_format.opcode == spec_op &&
-		     (ip->r_format.func == jalr_op ||
-		      ip->r_format.func == jr_op)))
-			break;
 
-		if (info->func_size && i >= info->func_size / 4)
+	for (i = 0; i < max_insns; i++, ip++) {
+
+		if (is_jal_jalr_jr_ins(ip))
 			break;
-		if (
-#ifdef CONFIG_32BIT
-		    ip->i_format.opcode == addiu_op &&
-#endif
-#ifdef CONFIG_64BIT
-		    ip->i_format.opcode == daddiu_op &&
-#endif
-		    ip->i_format.rs == 29 &&
-		    ip->i_format.rt == 29) {
-			/* addiu/daddiu sp,sp,-imm */
+		if (is_sp_move_ins(ip)) {
 			if (info->frame_size)
 				continue;
 			info->frame_size = - ip->i_format.simmediate;
 		}
 
-		if (
-#ifdef CONFIG_32BIT
-		    ip->i_format.opcode == sw_op &&
-#endif
-#ifdef CONFIG_64BIT
-		    ip->i_format.opcode == sd_op &&
-#endif
-		    ip->i_format.rs == 29 &&
-		    ip->i_format.rt == 31) {
-			/* sw / sd $ra, offset($sp) */
+		if (is_ra_save_ins(ip)) {
 			if (info->pc_offset != -1)
 				continue;
 			info->pc_offset =

commit f66686f70a2a61e53ee8c2284f75ca342e4c0dc8
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sat Jul 29 23:27:20 2006 +0900

    [MIPS] dump_stack() based on prologue code analysis
    
    Instead of dump all possible address in the stack, unwind the stack frame
    based on prologue code analysis, as like as get_wchan() does.  While the
    code analysis might fail for some reason, there is a new kernel option
    "raw_show_trace" to disable this feature.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 7ab67f786bfe..8709a46a45c1 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -281,7 +281,7 @@ static struct mips_frame_info {
 } *schedule_frame, mfinfo[64];
 static int mfinfo_num;
 
-static int __init get_frame_info(struct mips_frame_info *info)
+static int get_frame_info(struct mips_frame_info *info)
 {
 	int i;
 	void *func = info->func;
@@ -329,14 +329,12 @@ static int __init get_frame_info(struct mips_frame_info *info)
 				ip->i_format.simmediate / sizeof(long);
 		}
 	}
-	if (info->pc_offset == -1 || info->frame_size == 0) {
-		if (func == schedule)
-			printk("Can't analyze prologue code at %p\n", func);
-		info->pc_offset = -1;
-		info->frame_size = 0;
-	}
-
-	return 0;
+	if (info->frame_size && info->pc_offset >= 0) /* nested */
+		return 0;
+	if (info->pc_offset < 0) /* leaf */
+		return 1;
+	/* prologue seems boggus... */
+	return -1;
 }
 
 static int __init frame_info_init(void)
@@ -367,8 +365,15 @@ static int __init frame_info_init(void)
 	mfinfo[0].func = schedule;
 	schedule_frame = &mfinfo[0];
 #endif
-	for (i = 0; i < ARRAY_SIZE(mfinfo) && mfinfo[i].func; i++)
-		get_frame_info(&mfinfo[i]);
+	for (i = 0; i < ARRAY_SIZE(mfinfo) && mfinfo[i].func; i++) {
+		struct mips_frame_info *info = &mfinfo[i];
+		if (get_frame_info(info)) {
+			/* leaf or unknown */
+			if (info->func == schedule)
+				printk("Can't analyze prologue code at %p\n",
+				       info->func);
+		}
+	}
 
 	mfinfo_num = i;
 	return 0;
@@ -427,6 +432,8 @@ unsigned long get_wchan(struct task_struct *p)
 		if (i < 0)
 			break;
 
+		if (mfinfo[i].pc_offset < 0)
+			break;
 		pc = ((unsigned long *)frame)[mfinfo[i].pc_offset];
 		if (!mfinfo[i].frame_size)
 			break;
@@ -437,3 +444,40 @@ unsigned long get_wchan(struct task_struct *p)
 	return pc;
 }
 
+#ifdef CONFIG_KALLSYMS
+/* used by show_frametrace() */
+unsigned long unwind_stack(struct task_struct *task,
+			   unsigned long **sp, unsigned long pc)
+{
+	unsigned long stack_page;
+	struct mips_frame_info info;
+	char *modname;
+	char namebuf[KSYM_NAME_LEN + 1];
+	unsigned long size, ofs;
+
+	stack_page = (unsigned long)task_stack_page(task);
+	if (!stack_page)
+		return 0;
+
+	if (!kallsyms_lookup(pc, &size, &ofs, &modname, namebuf))
+		return 0;
+	if (ofs == 0)
+		return 0;
+
+	info.func = (void *)(pc - ofs);
+	info.func_size = ofs;	/* analyze from start to ofs */
+	if (get_frame_info(&info)) {
+		/* leaf or unknown */
+		*sp += info.frame_size / sizeof(long);
+		return 0;
+	}
+	if ((unsigned long)*sp < stack_page ||
+	    (unsigned long)*sp + info.frame_size / sizeof(long) >
+	    stack_page + THREAD_SIZE - 32)
+		return 0;
+
+	pc = (*sp)[info.pc_offset];
+	*sp += info.frame_size / sizeof(long);
+	return pc;
+}
+#endif

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 199a06e873c6..7ab67f786bfe 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -8,7 +8,6 @@
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  * Copyright (C) 2004 Thiemo Seufer
  */
-#include <linux/config.h>
 #include <linux/errno.h>
 #include <linux/module.h>
 #include <linux/sched.h>

commit f088fc84f94c1a36943e28ad704a9a740a35f877
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Apr 5 09:45:47 2006 +0100

    [MIPS] FPU affinity for MT ASE.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 8b393df460a2..199a06e873c6 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -185,6 +185,17 @@ int copy_thread(int nr, unsigned long clone_flags, unsigned long usp,
 	childregs->cp0_status &= ~(ST0_CU2|ST0_CU1);
 	clear_tsk_thread_flag(p, TIF_USEDFPU);
 
+#ifdef CONFIG_MIPS_MT_FPAFF
+	/*
+	 * FPU affinity support is cleaner if we track the
+	 * user-visible CPU affinity from the very beginning.
+	 * The generic cpus_allowed mask will already have
+	 * been copied from the parent before copy_thread
+	 * is invoked.
+	 */
+	p->thread.user_cpus_allowed = p->cpus_allowed;
+#endif /* CONFIG_MIPS_MT_FPAFF */
+
 	if (clone_flags & CLONE_SETTLS)
 		ti->tp_value = regs->regs[7];
 

commit 41c594ab65fc89573af296d192aa5235d09717ab
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Apr 5 09:45:45 2006 +0100

    [MIPS] MT: Improved multithreading support.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index c66db5e5ab62..8b393df460a2 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -41,6 +41,10 @@
 #include <asm/elf.h>
 #include <asm/isadep.h>
 #include <asm/inst.h>
+#ifdef CONFIG_MIPS_MT_SMTC
+#include <asm/mipsmtregs.h>
+extern void smtc_idle_loop_hook(void);
+#endif /* CONFIG_MIPS_MT_SMTC */
 
 /*
  * The idle thread. There's no useful work to be done, so just try to conserve
@@ -51,9 +55,13 @@ ATTRIB_NORET void cpu_idle(void)
 {
 	/* endless idle loop with no priority at all */
 	while (1) {
-		while (!need_resched())
+		while (!need_resched()) {
+#ifdef CONFIG_MIPS_MT_SMTC
+			smtc_idle_loop_hook();
+#endif /* CONFIG_MIPS_MT_SMTC */
 			if (cpu_wait)
 				(*cpu_wait)();
+		}
 		preempt_enable_no_resched();
 		schedule();
 		preempt_disable();

commit 0cb3463f04e771869f481e2dd44f66419e850586
Author: Adrian Bunk <bunk@stusta.de>
Date:   Fri Mar 31 02:32:07 2006 -0800

    [PATCH] unexport get_wchan
    
    The only user of get_wchan is the proc fs - and proc can't be built modular.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index a8f435d82940..c66db5e5ab62 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -419,4 +419,3 @@ unsigned long get_wchan(struct task_struct *p)
 	return pc;
 }
 
-EXPORT_SYMBOL(get_wchan);

commit 9c6031cc93626a194a9ef32d62b078ef1b396c45
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Sun Feb 19 23:46:44 2006 +0900

    [MIPS] Signal cleanup
    
    Move function prototypes to asm/signal.h to detect trivial errors and
    add some __user tags to get rid of sparse warnings.  Generated code
    should not be changed.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 092679c2dca9..a8f435d82940 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -60,17 +60,9 @@ ATTRIB_NORET void cpu_idle(void)
 	}
 }
 
-extern void do_signal(struct pt_regs *regs);
-extern void do_signal32(struct pt_regs *regs);
-
 /*
  * Native o32 and N64 ABI without DSP ASE
  */
-extern int setup_frame(struct k_sigaction * ka, struct pt_regs *regs,
-        int signr, sigset_t *set);
-extern int setup_rt_frame(struct k_sigaction * ka, struct pt_regs *regs,
-        int signr, sigset_t *set, siginfo_t *info);
-
 struct mips_abi mips_abi = {
 	.do_signal	= do_signal,
 #ifdef CONFIG_TRAD_SIGNALS
@@ -83,11 +75,6 @@ struct mips_abi mips_abi = {
 /*
  * o32 compatibility on 64-bit kernels, without DSP ASE
  */
-extern int setup_frame_32(struct k_sigaction * ka, struct pt_regs *regs,
-        int signr, sigset_t *set);
-extern int setup_rt_frame_32(struct k_sigaction * ka, struct pt_regs *regs,
-        int signr, sigset_t *set, siginfo_t *info);
-
 struct mips_abi mips_abi_32 = {
 	.do_signal	= do_signal32,
 	.setup_frame	= setup_frame_32,
@@ -99,9 +86,6 @@ struct mips_abi mips_abi_32 = {
 /*
  * N32 on 64-bit kernels, without DSP ASE
  */
-extern int setup_rt_frame_n32(struct k_sigaction * ka, struct pt_regs *regs,
-        int signr, sigset_t *set, siginfo_t *info);
-
 struct mips_abi mips_abi_n32 = {
 	.do_signal	= do_signal,
 	.setup_rt_frame	= setup_rt_frame_n32

commit 63077519899721120b61d663a68adced068a459d
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Wed Feb 8 01:48:03 2006 +0900

    [MIPS] Rewrite get_wchan and its helper functions using kallsyms_lookup.
    
    Implement get_wchan() and frame_info_init() using kallsyms_lookup().
    This fixes problem with static sched/lock functions and mfinfo[]
    maintenance issue.  If CONFIG_KALLSYMS was disabled, get_wchan() just
    returns thread_saved_pc() value.
    
    Also unwind stackframe based on "addiu sp,-imm" analysis instead of
    frame pointer.  This fixes problem with functions compiled without
    -fomit-frame-pointer.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 5232fc752935..092679c2dca9 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -25,6 +25,7 @@
 #include <linux/a.out.h>
 #include <linux/init.h>
 #include <linux/completion.h>
+#include <linux/kallsyms.h>
 
 #include <asm/abi.h>
 #include <asm/bootinfo.h>
@@ -272,46 +273,19 @@ long kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 
 static struct mips_frame_info {
 	void *func;
-	int omit_fp;	/* compiled without fno-omit-frame-pointer */
-	int frame_offset;
+	unsigned long func_size;
+	int frame_size;
 	int pc_offset;
-} schedule_frame, mfinfo[] = {
-	{ schedule, 0 },	/* must be first */
-	/* arch/mips/kernel/semaphore.c */
-	{ __down, 1 },
-	{ __down_interruptible, 1 },
-	/* kernel/sched.c */
-#ifdef CONFIG_PREEMPT
-	{ preempt_schedule, 0 },
-#endif
-	{ wait_for_completion, 0 },
-	{ interruptible_sleep_on, 0 },
-	{ interruptible_sleep_on_timeout, 0 },
-	{ sleep_on, 0 },
-	{ sleep_on_timeout, 0 },
-	{ yield, 0 },
-	{ io_schedule, 0 },
-	{ io_schedule_timeout, 0 },
-#if defined(CONFIG_SMP) && defined(CONFIG_PREEMPT)
-	{ __preempt_spin_lock, 0 },
-	{ __preempt_write_lock, 0 },
-#endif
-	/* kernel/timer.c */
-	{ schedule_timeout, 1 },
-/*	{ nanosleep_restart, 1 }, */
-	/* lib/rwsem-spinlock.c */
-	{ __down_read, 1 },
-	{ __down_write, 1 },
-};
+} *schedule_frame, mfinfo[64];
+static int mfinfo_num;
 
-static int mips_frame_info_initialized;
 static int __init get_frame_info(struct mips_frame_info *info)
 {
 	int i;
 	void *func = info->func;
 	union mips_instruction *ip = (union mips_instruction *)func;
 	info->pc_offset = -1;
-	info->frame_offset = info->omit_fp ? 0 : -1;
+	info->frame_size = 0;
 	for (i = 0; i < 128; i++, ip++) {
 		/* if jal, jalr, jr, stop. */
 		if (ip->j_format.opcode == jal_op ||
@@ -320,6 +294,23 @@ static int __init get_frame_info(struct mips_frame_info *info)
 		      ip->r_format.func == jr_op)))
 			break;
 
+		if (info->func_size && i >= info->func_size / 4)
+			break;
+		if (
+#ifdef CONFIG_32BIT
+		    ip->i_format.opcode == addiu_op &&
+#endif
+#ifdef CONFIG_64BIT
+		    ip->i_format.opcode == daddiu_op &&
+#endif
+		    ip->i_format.rs == 29 &&
+		    ip->i_format.rt == 29) {
+			/* addiu/daddiu sp,sp,-imm */
+			if (info->frame_size)
+				continue;
+			info->frame_size = - ip->i_format.simmediate;
+		}
+
 		if (
 #ifdef CONFIG_32BIT
 		    ip->i_format.opcode == sw_op &&
@@ -327,31 +318,20 @@ static int __init get_frame_info(struct mips_frame_info *info)
 #ifdef CONFIG_64BIT
 		    ip->i_format.opcode == sd_op &&
 #endif
-		    ip->i_format.rs == 29)
-		{
+		    ip->i_format.rs == 29 &&
+		    ip->i_format.rt == 31) {
 			/* sw / sd $ra, offset($sp) */
-			if (ip->i_format.rt == 31) {
-				if (info->pc_offset != -1)
-					continue;
-				info->pc_offset =
-					ip->i_format.simmediate / sizeof(long);
-			}
-			/* sw / sd $s8, offset($sp) */
-			if (ip->i_format.rt == 30) {
-//#if 0	/* gcc 3.4 does aggressive optimization... */
-				if (info->frame_offset != -1)
-					continue;
-//#endif
-				info->frame_offset =
-					ip->i_format.simmediate / sizeof(long);
-			}
+			if (info->pc_offset != -1)
+				continue;
+			info->pc_offset =
+				ip->i_format.simmediate / sizeof(long);
 		}
 	}
-	if (info->pc_offset == -1 || info->frame_offset == -1) {
-		printk("Can't analyze prologue code at %p\n", func);
+	if (info->pc_offset == -1 || info->frame_size == 0) {
+		if (func == schedule)
+			printk("Can't analyze prologue code at %p\n", func);
 		info->pc_offset = -1;
-		info->frame_offset = -1;
-		return -1;
+		info->frame_size = 0;
 	}
 
 	return 0;
@@ -359,25 +339,36 @@ static int __init get_frame_info(struct mips_frame_info *info)
 
 static int __init frame_info_init(void)
 {
-	int i, found;
-	for (i = 0; i < ARRAY_SIZE(mfinfo); i++)
-		if (get_frame_info(&mfinfo[i]))
-			return -1;
-	schedule_frame = mfinfo[0];
-	/* bubble sort */
-	do {
-		struct mips_frame_info tmp;
-		found = 0;
-		for (i = 1; i < ARRAY_SIZE(mfinfo); i++) {
-			if (mfinfo[i-1].func > mfinfo[i].func) {
-				tmp = mfinfo[i];
-				mfinfo[i] = mfinfo[i-1];
-				mfinfo[i-1] = tmp;
-				found = 1;
-			}
-		}
-	} while (found);
-	mips_frame_info_initialized = 1;
+	int i;
+#ifdef CONFIG_KALLSYMS
+	char *modname;
+	char namebuf[KSYM_NAME_LEN + 1];
+	unsigned long start, size, ofs;
+	extern char __sched_text_start[], __sched_text_end[];
+	extern char __lock_text_start[], __lock_text_end[];
+
+	start = (unsigned long)__sched_text_start;
+	for (i = 0; i < ARRAY_SIZE(mfinfo); i++) {
+		if (start == (unsigned long)schedule)
+			schedule_frame = &mfinfo[i];
+		if (!kallsyms_lookup(start, &size, &ofs, &modname, namebuf))
+			break;
+		mfinfo[i].func = (void *)(start + ofs);
+		mfinfo[i].func_size = size;
+		start += size - ofs;
+		if (start >= (unsigned long)__lock_text_end)
+			break;
+		if (start == (unsigned long)__sched_text_end)
+			start = (unsigned long)__lock_text_start;
+	}
+#else
+	mfinfo[0].func = schedule;
+	schedule_frame = &mfinfo[0];
+#endif
+	for (i = 0; i < ARRAY_SIZE(mfinfo) && mfinfo[i].func; i++)
+		get_frame_info(&mfinfo[i]);
+
+	mfinfo_num = i;
 	return 0;
 }
 
@@ -394,47 +385,52 @@ unsigned long thread_saved_pc(struct task_struct *tsk)
 	if (t->reg31 == (unsigned long) ret_from_fork)
 		return t->reg31;
 
-	if (schedule_frame.pc_offset < 0)
+	if (!schedule_frame || schedule_frame->pc_offset < 0)
 		return 0;
-	return ((unsigned long *)t->reg29)[schedule_frame.pc_offset];
+	return ((unsigned long *)t->reg29)[schedule_frame->pc_offset];
 }
 
 /* get_wchan - a maintenance nightmare^W^Wpain in the ass ...  */
 unsigned long get_wchan(struct task_struct *p)
 {
 	unsigned long stack_page;
-	unsigned long frame, pc;
+	unsigned long pc;
+#ifdef CONFIG_KALLSYMS
+	unsigned long frame;
+#endif
 
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 
 	stack_page = (unsigned long)task_stack_page(p);
-	if (!stack_page || !mips_frame_info_initialized)
+	if (!stack_page || !mfinfo_num)
 		return 0;
 
 	pc = thread_saved_pc(p);
+#ifdef CONFIG_KALLSYMS
 	if (!in_sched_functions(pc))
 		return pc;
 
-	frame = ((unsigned long *)p->thread.reg30)[schedule_frame.frame_offset];
+	frame = p->thread.reg29 + schedule_frame->frame_size;
 	do {
 		int i;
 
 		if (frame < stack_page || frame > stack_page + THREAD_SIZE - 32)
 			return 0;
 
-		for (i = ARRAY_SIZE(mfinfo) - 1; i >= 0; i--) {
+		for (i = mfinfo_num - 1; i >= 0; i--) {
 			if (pc >= (unsigned long) mfinfo[i].func)
 				break;
 		}
 		if (i < 0)
 			break;
 
-		if (mfinfo[i].omit_fp)
-			break;
 		pc = ((unsigned long *)frame)[mfinfo[i].pc_offset];
-		frame = ((unsigned long *)frame)[mfinfo[i].frame_offset];
+		if (!mfinfo[i].frame_size)
+			break;
+		frame += mfinfo[i].frame_size;
 	} while (in_sched_functions(pc));
+#endif
 
 	return pc;
 }

commit 40ac5d479b7deb98f6ccc4a7a29ee62dba7a798f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Feb 8 13:38:18 2006 +0000

    [MIPS] Make do_signal return void.
    
    It's return value is ignored everywhere.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
    ---

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 02adc7384153..5232fc752935 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -4,6 +4,7 @@
  * for more details.
  *
  * Copyright (C) 1994 - 1999, 2000 by Ralf Baechle and others.
+ * Copyright (C) 2005, 2006 by Ralf Baechle (ralf@linux-mips.org)
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
  * Copyright (C) 2004 Thiemo Seufer
  */
@@ -58,8 +59,8 @@ ATTRIB_NORET void cpu_idle(void)
 	}
 }
 
-extern int do_signal(struct pt_regs *regs);
-extern int do_signal32(struct pt_regs *regs);
+extern void do_signal(struct pt_regs *regs);
+extern void do_signal32(struct pt_regs *regs);
 
 /*
  * Native o32 and N64 ABI without DSP ASE

commit 7b3e2fc847c8325a7b35185fa1fc2f1729ed9c5b
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Feb 8 12:58:41 2006 +0000

    [MIPS] Add support for TIF_RESTORE_SIGMASK.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    
    ---

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index fa98f10d0132..02adc7384153 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -58,8 +58,8 @@ ATTRIB_NORET void cpu_idle(void)
 	}
 }
 
-extern int do_signal(sigset_t *oldset, struct pt_regs *regs);
-extern int do_signal32(sigset_t *oldset, struct pt_regs *regs);
+extern int do_signal(struct pt_regs *regs);
+extern int do_signal32(struct pt_regs *regs);
 
 /*
  * Native o32 and N64 ABI without DSP ASE

commit 75bb07e788abb060cc93b6f4dc48a70a53c1406b
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jan 12 01:06:08 2006 -0800

    [PATCH] mips: task_stack_page()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index aca56f4a5d50..fa98f10d0132 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -140,12 +140,12 @@ void flush_thread(void)
 int copy_thread(int nr, unsigned long clone_flags, unsigned long usp,
 	unsigned long unused, struct task_struct *p, struct pt_regs *regs)
 {
-	struct thread_info *ti = p->thread_info;
+	struct thread_info *ti = task_thread_info(p);
 	struct pt_regs *childregs;
 	long childksp;
 	p->set_child_tid = p->clear_child_tid = NULL;
 
-	childksp = (unsigned long)ti + THREAD_SIZE - 32;
+	childksp = (unsigned long)task_stack_page(p) + THREAD_SIZE - 32;
 
 	preempt_disable();
 
@@ -407,7 +407,7 @@ unsigned long get_wchan(struct task_struct *p)
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 
-	stack_page = (unsigned long)p->thread_info;
+	stack_page = (unsigned long)task_stack_page(p);
 	if (!stack_page || !mips_frame_info_initialized)
 		return 0;
 

commit 40bc9c671a9f0a5189c07a2b4280aec9b40e30cd
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Thu Jan 12 01:06:07 2006 -0800

    [PATCH] mips: task_pt_regs()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 0476a4dce14e..aca56f4a5d50 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -229,9 +229,7 @@ void elf_dump_regs(elf_greg_t *gp, struct pt_regs *regs)
 
 int dump_task_regs (struct task_struct *tsk, elf_gregset_t *regs)
 {
-	struct thread_info *ti = tsk->thread_info;
-	long ksp = (unsigned long)ti + THREAD_SIZE - 32;
-	elf_dump_regs(&(*regs)[0], (struct pt_regs *) ksp - 1);
+	elf_dump_regs(*regs, task_pt_regs(tsk));
 	return 1;
 }
 

commit d56efda4510b1c6be3bd5ceb3e6dd3a4d64396f3
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Fri Dec 16 22:40:47 2005 +0000

    MIPS: Namespace pollution: dump_regs() -> elf_dump_regs()
    
    dump_regs() is used by a bunch of drivers for their internal stuff;
    renamed mips instance (one that is seen in system-wide headers)
    to elf_dump_regs()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index dd725779d91f..0476a4dce14e 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -205,7 +205,7 @@ int dump_fpu(struct pt_regs *regs, elf_fpregset_t *r)
 	return 1;
 }
 
-void dump_regs(elf_greg_t *gp, struct pt_regs *regs)
+void elf_dump_regs(elf_greg_t *gp, struct pt_regs *regs)
 {
 	int i;
 
@@ -231,7 +231,7 @@ int dump_task_regs (struct task_struct *tsk, elf_gregset_t *regs)
 {
 	struct thread_info *ti = tsk->thread_info;
 	long ksp = (unsigned long)ti + THREAD_SIZE - 32;
-	dump_regs(&(*regs)[0], (struct pt_regs *) ksp - 1);
+	elf_dump_regs(&(*regs)[0], (struct pt_regs *) ksp - 1);
 	return 1;
 }
 

commit 5bfb5d690f36d316a5f3b4f7775fda996faa6b12
Author: Nick Piggin <nickpiggin@yahoo.com.au>
Date:   Tue Nov 8 21:39:01 2005 -0800

    [PATCH] sched: disable preempt in idle tasks
    
    Run idle threads with preempt disabled.
    
    Also corrected a bugs in arm26's cpu_idle (make it actually call schedule()).
    How did it ever work before?
    
    Might fix the CPU hotplugging hang which Nigel Cunningham noted.
    
    We think the bug hits if the idle thread is preempted after checking
    need_resched() and before going to sleep, then the CPU offlined.
    
    After calling stop_machine_run, the CPU eventually returns from preemption and
    into the idle thread and goes to sleep.  The CPU will continue executing
    previous idle and have no chance to call play_dead.
    
    By disabling preemption until we are ready to explicitly schedule, this bug is
    fixed and the idle threads generally become more robust.
    
    From: alexs <ashepard@u.washington.edu>
    
      PPC build fix
    
    From: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
    
      MIPS build fix
    
    Signed-off-by: Nick Piggin <npiggin@suse.de>
    Signed-off-by: Yoichi Yuasa <yuasa@hh.iij4u.or.jp>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 4fe3d5715c41..dd725779d91f 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -52,7 +52,9 @@ ATTRIB_NORET void cpu_idle(void)
 		while (!need_resched())
 			if (cpu_wait)
 				(*cpu_wait)();
+		preempt_enable_no_resched();
 		schedule();
+		preempt_disable();
 	}
 }
 

commit 129bc8f78b468df6824dd1584829f10aa3a69c27
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Jul 11 20:45:51 2005 +0000

    Setup_frame is now returning a success value.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 98432097a86a..4fe3d5715c41 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -62,9 +62,9 @@ extern int do_signal32(sigset_t *oldset, struct pt_regs *regs);
 /*
  * Native o32 and N64 ABI without DSP ASE
  */
-extern void setup_frame(struct k_sigaction * ka, struct pt_regs *regs,
+extern int setup_frame(struct k_sigaction * ka, struct pt_regs *regs,
         int signr, sigset_t *set);
-extern void setup_rt_frame(struct k_sigaction * ka, struct pt_regs *regs,
+extern int setup_rt_frame(struct k_sigaction * ka, struct pt_regs *regs,
         int signr, sigset_t *set, siginfo_t *info);
 
 struct mips_abi mips_abi = {
@@ -79,9 +79,9 @@ struct mips_abi mips_abi = {
 /*
  * o32 compatibility on 64-bit kernels, without DSP ASE
  */
-extern void setup_frame_32(struct k_sigaction * ka, struct pt_regs *regs,
+extern int setup_frame_32(struct k_sigaction * ka, struct pt_regs *regs,
         int signr, sigset_t *set);
-extern void setup_rt_frame_32(struct k_sigaction * ka, struct pt_regs *regs,
+extern int setup_rt_frame_32(struct k_sigaction * ka, struct pt_regs *regs,
         int signr, sigset_t *set, siginfo_t *info);
 
 struct mips_abi mips_abi_32 = {
@@ -95,7 +95,7 @@ struct mips_abi mips_abi_32 = {
 /*
  * N32 on 64-bit kernels, without DSP ASE
  */
-extern void setup_rt_frame_n32(struct k_sigaction * ka, struct pt_regs *regs,
+extern int setup_rt_frame_n32(struct k_sigaction * ka, struct pt_regs *regs,
         int signr, sigset_t *set, siginfo_t *info);
 
 struct mips_abi mips_abi_n32 = {

commit e50c0a8fa60da9ac0e0a70caa8a3a803815c1f2f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 31 11:49:19 2005 +0000

    Support the MIPS32 / MIPS64 DSP ASE.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 368526af5f5e..98432097a86a 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -25,8 +25,10 @@
 #include <linux/init.h>
 #include <linux/completion.h>
 
+#include <asm/abi.h>
 #include <asm/bootinfo.h>
 #include <asm/cpu.h>
+#include <asm/dsp.h>
 #include <asm/fpu.h>
 #include <asm/pgtable.h>
 #include <asm/system.h>
@@ -54,6 +56,54 @@ ATTRIB_NORET void cpu_idle(void)
 	}
 }
 
+extern int do_signal(sigset_t *oldset, struct pt_regs *regs);
+extern int do_signal32(sigset_t *oldset, struct pt_regs *regs);
+
+/*
+ * Native o32 and N64 ABI without DSP ASE
+ */
+extern void setup_frame(struct k_sigaction * ka, struct pt_regs *regs,
+        int signr, sigset_t *set);
+extern void setup_rt_frame(struct k_sigaction * ka, struct pt_regs *regs,
+        int signr, sigset_t *set, siginfo_t *info);
+
+struct mips_abi mips_abi = {
+	.do_signal	= do_signal,
+#ifdef CONFIG_TRAD_SIGNALS
+	.setup_frame	= setup_frame,
+#endif
+	.setup_rt_frame	= setup_rt_frame
+};
+
+#ifdef CONFIG_MIPS32_O32
+/*
+ * o32 compatibility on 64-bit kernels, without DSP ASE
+ */
+extern void setup_frame_32(struct k_sigaction * ka, struct pt_regs *regs,
+        int signr, sigset_t *set);
+extern void setup_rt_frame_32(struct k_sigaction * ka, struct pt_regs *regs,
+        int signr, sigset_t *set, siginfo_t *info);
+
+struct mips_abi mips_abi_32 = {
+	.do_signal	= do_signal32,
+	.setup_frame	= setup_frame_32,
+	.setup_rt_frame	= setup_rt_frame_32
+};
+#endif /* CONFIG_MIPS32_O32 */
+
+#ifdef CONFIG_MIPS32_N32
+/*
+ * N32 on 64-bit kernels, without DSP ASE
+ */
+extern void setup_rt_frame_n32(struct k_sigaction * ka, struct pt_regs *regs,
+        int signr, sigset_t *set, siginfo_t *info);
+
+struct mips_abi mips_abi_n32 = {
+	.do_signal	= do_signal,
+	.setup_rt_frame	= setup_rt_frame_n32
+};
+#endif /* CONFIG_MIPS32_N32 */
+
 asmlinkage void ret_from_fork(void);
 
 void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
@@ -70,6 +120,8 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 	regs->cp0_status = status;
 	clear_used_math();
 	lose_fpu();
+	if (cpu_has_dsp)
+		__init_dsp();
 	regs->cp0_epc = pc;
 	regs->regs[29] = sp;
 	current_thread_info()->addr_limit = USER_DS;
@@ -95,9 +147,11 @@ int copy_thread(int nr, unsigned long clone_flags, unsigned long usp,
 
 	preempt_disable();
 
-	if (is_fpu_owner()) {
+	if (is_fpu_owner())
 		save_fp(p);
-	}
+
+	if (cpu_has_dsp)
+		save_dsp(p);
 
 	preempt_enable();
 

commit 3c37026d43c47bec4710cbda286f4a17f416f5e6
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Apr 13 17:43:59 2005 +0000

    NPTL, round one.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 2b7a44deb856..368526af5f5e 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -89,6 +89,7 @@ int copy_thread(int nr, unsigned long clone_flags, unsigned long usp,
 	struct thread_info *ti = p->thread_info;
 	struct pt_regs *childregs;
 	long childksp;
+	p->set_child_tid = p->clear_child_tid = NULL;
 
 	childksp = (unsigned long)ti + THREAD_SIZE - 32;
 
@@ -134,6 +135,9 @@ int copy_thread(int nr, unsigned long clone_flags, unsigned long usp,
 	childregs->cp0_status &= ~(ST0_CU2|ST0_CU1);
 	clear_tsk_thread_flag(p, TIF_USEDFPU);
 
+	if (clone_flags & CLONE_SETTLS)
+		ti->tp_value = regs->regs[7];
+
 	return 0;
 }
 

commit 71e0e556db08cc20de76d510be5600f6e5ce143c
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Mar 14 10:16:59 2005 +0000

    Multithreaded core dumps.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 5223c4450e4c..2b7a44deb856 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -167,6 +167,14 @@ void dump_regs(elf_greg_t *gp, struct pt_regs *regs)
 #endif
 }
 
+int dump_task_regs (struct task_struct *tsk, elf_gregset_t *regs)
+{
+	struct thread_info *ti = tsk->thread_info;
+	long ksp = (unsigned long)ti + THREAD_SIZE - 32;
+	dump_regs(&(*regs)[0], (struct pt_regs *) ksp - 1);
+	return 1;
+}
+
 int dump_task_fpu (struct task_struct *t, elf_fpregset_t *fpr)
 {
 	memcpy(fpr, &t->thread.fpu, sizeof(current->thread.fpu));

commit fe00f943e0ef98b4057abcc2940d631a975b43cd
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Mar 1 19:22:29 2005 +0000

    Sparseify MIPS.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index f99efce556ea..5223c4450e4c 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -38,14 +38,6 @@
 #include <asm/isadep.h>
 #include <asm/inst.h>
 
-/*
- * We use this if we don't have any better idle routine..
- * (This to kill: kernel/platform.c.
- */
-void default_idle (void)
-{
-}
-
 /*
  * The idle thread. There's no useful work to be done, so just try to conserve
  * power and have a low exit latency (ie sit in a loop waiting for somebody to

commit dc953df1ba5526814982676f47580c8e1bcdbfeb
Author: Thiemo Seufer <ths@networkno.de>
Date:   Mon Feb 21 10:55:16 2005 +0000

    Fix wchan implementation, based on earlier by from Atsushi Nemoto.
    
    Signed-off-by: Thiemo Seufer <ths@networkno.de>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index e4f2f8011387..f99efce556ea 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -211,22 +211,48 @@ long kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
 	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
 }
 
-struct mips_frame_info {
+static struct mips_frame_info {
+	void *func;
+	int omit_fp;	/* compiled without fno-omit-frame-pointer */
 	int frame_offset;
 	int pc_offset;
+} schedule_frame, mfinfo[] = {
+	{ schedule, 0 },	/* must be first */
+	/* arch/mips/kernel/semaphore.c */
+	{ __down, 1 },
+	{ __down_interruptible, 1 },
+	/* kernel/sched.c */
+#ifdef CONFIG_PREEMPT
+	{ preempt_schedule, 0 },
+#endif
+	{ wait_for_completion, 0 },
+	{ interruptible_sleep_on, 0 },
+	{ interruptible_sleep_on_timeout, 0 },
+	{ sleep_on, 0 },
+	{ sleep_on_timeout, 0 },
+	{ yield, 0 },
+	{ io_schedule, 0 },
+	{ io_schedule_timeout, 0 },
+#if defined(CONFIG_SMP) && defined(CONFIG_PREEMPT)
+	{ __preempt_spin_lock, 0 },
+	{ __preempt_write_lock, 0 },
+#endif
+	/* kernel/timer.c */
+	{ schedule_timeout, 1 },
+/*	{ nanosleep_restart, 1 }, */
+	/* lib/rwsem-spinlock.c */
+	{ __down_read, 1 },
+	{ __down_write, 1 },
 };
-static struct mips_frame_info schedule_frame;
-static struct mips_frame_info schedule_timeout_frame;
-static struct mips_frame_info sleep_on_frame;
-static struct mips_frame_info sleep_on_timeout_frame;
-static struct mips_frame_info wait_for_completion_frame;
+
 static int mips_frame_info_initialized;
-static int __init get_frame_info(struct mips_frame_info *info, void *func)
+static int __init get_frame_info(struct mips_frame_info *info)
 {
 	int i;
+	void *func = info->func;
 	union mips_instruction *ip = (union mips_instruction *)func;
 	info->pc_offset = -1;
-	info->frame_offset = -1;
+	info->frame_offset = info->omit_fp ? 0 : -1;
 	for (i = 0; i < 128; i++, ip++) {
 		/* if jal, jalr, jr, stop. */
 		if (ip->j_format.opcode == jal_op ||
@@ -247,14 +273,16 @@ static int __init get_frame_info(struct mips_frame_info *info, void *func)
 			/* sw / sd $ra, offset($sp) */
 			if (ip->i_format.rt == 31) {
 				if (info->pc_offset != -1)
-					break;
+					continue;
 				info->pc_offset =
 					ip->i_format.simmediate / sizeof(long);
 			}
 			/* sw / sd $s8, offset($sp) */
 			if (ip->i_format.rt == 30) {
+//#if 0	/* gcc 3.4 does aggressive optimization... */
 				if (info->frame_offset != -1)
-					break;
+					continue;
+//#endif
 				info->frame_offset =
 					ip->i_format.simmediate / sizeof(long);
 			}
@@ -272,13 +300,25 @@ static int __init get_frame_info(struct mips_frame_info *info, void *func)
 
 static int __init frame_info_init(void)
 {
-	mips_frame_info_initialized =
-		!get_frame_info(&schedule_frame, schedule) &&
-		!get_frame_info(&schedule_timeout_frame, schedule_timeout) &&
-		!get_frame_info(&sleep_on_frame, sleep_on) &&
-		!get_frame_info(&sleep_on_timeout_frame, sleep_on_timeout) &&
-		!get_frame_info(&wait_for_completion_frame, wait_for_completion);
-
+	int i, found;
+	for (i = 0; i < ARRAY_SIZE(mfinfo); i++)
+		if (get_frame_info(&mfinfo[i]))
+			return -1;
+	schedule_frame = mfinfo[0];
+	/* bubble sort */
+	do {
+		struct mips_frame_info tmp;
+		found = 0;
+		for (i = 1; i < ARRAY_SIZE(mfinfo); i++) {
+			if (mfinfo[i-1].func > mfinfo[i].func) {
+				tmp = mfinfo[i];
+				mfinfo[i] = mfinfo[i-1];
+				mfinfo[i-1] = tmp;
+				found = 1;
+			}
+		}
+	} while (found);
+	mips_frame_info_initialized = 1;
 	return 0;
 }
 
@@ -303,60 +343,39 @@ unsigned long thread_saved_pc(struct task_struct *tsk)
 /* get_wchan - a maintenance nightmare^W^Wpain in the ass ...  */
 unsigned long get_wchan(struct task_struct *p)
 {
+	unsigned long stack_page;
 	unsigned long frame, pc;
 
 	if (!p || p == current || p->state == TASK_RUNNING)
 		return 0;
 
-	if (!mips_frame_info_initialized)
+	stack_page = (unsigned long)p->thread_info;
+	if (!stack_page || !mips_frame_info_initialized)
 		return 0;
+
 	pc = thread_saved_pc(p);
 	if (!in_sched_functions(pc))
-		goto out;
-
-	if (pc >= (unsigned long) sleep_on_timeout)
-		goto schedule_timeout_caller;
-	if (pc >= (unsigned long) sleep_on)
-		goto schedule_caller;
-	if (pc >= (unsigned long) interruptible_sleep_on_timeout)
-		goto schedule_timeout_caller;
-	if (pc >= (unsigned long)interruptible_sleep_on)
-		goto schedule_caller;
-	if (pc >= (unsigned long)wait_for_completion)
-		goto schedule_caller;
-	goto schedule_timeout_caller;
-
-schedule_caller:
-	frame = ((unsigned long *)p->thread.reg30)[schedule_frame.frame_offset];
-	if (pc >= (unsigned long) sleep_on)
-		pc = ((unsigned long *)frame)[sleep_on_frame.pc_offset];
-	else
-		pc = ((unsigned long *)frame)[wait_for_completion_frame.pc_offset];
-	goto out;
+		return pc;
 
-schedule_timeout_caller:
-	/*
-	 * The schedule_timeout frame
-	 */
 	frame = ((unsigned long *)p->thread.reg30)[schedule_frame.frame_offset];
+	do {
+		int i;
 
-	/*
-	 * frame now points to sleep_on_timeout's frame
-	 */
-	pc    = ((unsigned long *)frame)[schedule_timeout_frame.pc_offset];
+		if (frame < stack_page || frame > stack_page + THREAD_SIZE - 32)
+			return 0;
 
-	if (in_sched_functions(pc)) {
-		/* schedule_timeout called by [interruptible_]sleep_on_timeout */
-		frame = ((unsigned long *)frame)[schedule_timeout_frame.frame_offset];
-		pc    = ((unsigned long *)frame)[sleep_on_timeout_frame.pc_offset];
-	}
-
-out:
+		for (i = ARRAY_SIZE(mfinfo) - 1; i >= 0; i--) {
+			if (pc >= (unsigned long) mfinfo[i].func)
+				break;
+		}
+		if (i < 0)
+			break;
 
-#ifdef CONFIG_64BIT
-	if (current->thread.mflags & MF_32BIT_REGS) /* Kludge for 32-bit ps  */
-		pc &= 0xffffffffUL;
-#endif
+		if (mfinfo[i].omit_fp)
+			break;
+		pc = ((unsigned long *)frame)[mfinfo[i].pc_offset];
+		frame = ((unsigned long *)frame)[mfinfo[i].frame_offset];
+	} while (in_sched_functions(pc));
 
 	return pc;
 }

commit 875d43e72b5bf22161a81de7554f88eccf8a51ae
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Sep 3 15:56:16 2005 -0700

    [PATCH] mips: clean up 32/64-bit configuration
    
    Start cleaning 32-bit vs. 64-bit configuration.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
index 6e70c42c2058..e4f2f8011387 100644
--- a/arch/mips/kernel/process.c
+++ b/arch/mips/kernel/process.c
@@ -70,7 +70,7 @@ void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
 
 	/* New thread loses kernel privileges. */
 	status = regs->cp0_status & ~(ST0_CU0|ST0_CU1|KU_MASK);
-#ifdef CONFIG_MIPS64
+#ifdef CONFIG_64BIT
 	status &= ~ST0_FR;
 	status |= (current->thread.mflags & MF_32BIT_REGS) ? 0 : ST0_FR;
 #endif
@@ -236,10 +236,10 @@ static int __init get_frame_info(struct mips_frame_info *info, void *func)
 			break;
 
 		if (
-#ifdef CONFIG_MIPS32
+#ifdef CONFIG_32BIT
 		    ip->i_format.opcode == sw_op &&
 #endif
-#ifdef CONFIG_MIPS64
+#ifdef CONFIG_64BIT
 		    ip->i_format.opcode == sd_op &&
 #endif
 		    ip->i_format.rs == 29)
@@ -353,7 +353,7 @@ unsigned long get_wchan(struct task_struct *p)
 
 out:
 
-#ifdef CONFIG_MIPS64
+#ifdef CONFIG_64BIT
 	if (current->thread.mflags & MF_32BIT_REGS) /* Kludge for 32-bit ps  */
 		pc &= 0xffffffffUL;
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c
new file mode 100644
index 000000000000..6e70c42c2058
--- /dev/null
+++ b/arch/mips/kernel/process.c
@@ -0,0 +1,364 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1994 - 1999, 2000 by Ralf Baechle and others.
+ * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
+ * Copyright (C) 2004 Thiemo Seufer
+ */
+#include <linux/config.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/kernel.h>
+#include <linux/mm.h>
+#include <linux/stddef.h>
+#include <linux/unistd.h>
+#include <linux/ptrace.h>
+#include <linux/slab.h>
+#include <linux/mman.h>
+#include <linux/personality.h>
+#include <linux/sys.h>
+#include <linux/user.h>
+#include <linux/a.out.h>
+#include <linux/init.h>
+#include <linux/completion.h>
+
+#include <asm/bootinfo.h>
+#include <asm/cpu.h>
+#include <asm/fpu.h>
+#include <asm/pgtable.h>
+#include <asm/system.h>
+#include <asm/mipsregs.h>
+#include <asm/processor.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <asm/elf.h>
+#include <asm/isadep.h>
+#include <asm/inst.h>
+
+/*
+ * We use this if we don't have any better idle routine..
+ * (This to kill: kernel/platform.c.
+ */
+void default_idle (void)
+{
+}
+
+/*
+ * The idle thread. There's no useful work to be done, so just try to conserve
+ * power and have a low exit latency (ie sit in a loop waiting for somebody to
+ * say that they'd like to reschedule)
+ */
+ATTRIB_NORET void cpu_idle(void)
+{
+	/* endless idle loop with no priority at all */
+	while (1) {
+		while (!need_resched())
+			if (cpu_wait)
+				(*cpu_wait)();
+		schedule();
+	}
+}
+
+asmlinkage void ret_from_fork(void);
+
+void start_thread(struct pt_regs * regs, unsigned long pc, unsigned long sp)
+{
+	unsigned long status;
+
+	/* New thread loses kernel privileges. */
+	status = regs->cp0_status & ~(ST0_CU0|ST0_CU1|KU_MASK);
+#ifdef CONFIG_MIPS64
+	status &= ~ST0_FR;
+	status |= (current->thread.mflags & MF_32BIT_REGS) ? 0 : ST0_FR;
+#endif
+	status |= KU_USER;
+	regs->cp0_status = status;
+	clear_used_math();
+	lose_fpu();
+	regs->cp0_epc = pc;
+	regs->regs[29] = sp;
+	current_thread_info()->addr_limit = USER_DS;
+}
+
+void exit_thread(void)
+{
+}
+
+void flush_thread(void)
+{
+}
+
+int copy_thread(int nr, unsigned long clone_flags, unsigned long usp,
+	unsigned long unused, struct task_struct *p, struct pt_regs *regs)
+{
+	struct thread_info *ti = p->thread_info;
+	struct pt_regs *childregs;
+	long childksp;
+
+	childksp = (unsigned long)ti + THREAD_SIZE - 32;
+
+	preempt_disable();
+
+	if (is_fpu_owner()) {
+		save_fp(p);
+	}
+
+	preempt_enable();
+
+	/* set up new TSS. */
+	childregs = (struct pt_regs *) childksp - 1;
+	*childregs = *regs;
+	childregs->regs[7] = 0;	/* Clear error flag */
+
+#if defined(CONFIG_BINFMT_IRIX)
+	if (current->personality != PER_LINUX) {
+		/* Under IRIX things are a little different. */
+		childregs->regs[3] = 1;
+		regs->regs[3] = 0;
+	}
+#endif
+	childregs->regs[2] = 0;	/* Child gets zero as return value */
+	regs->regs[2] = p->pid;
+
+	if (childregs->cp0_status & ST0_CU0) {
+		childregs->regs[28] = (unsigned long) ti;
+		childregs->regs[29] = childksp;
+		ti->addr_limit = KERNEL_DS;
+	} else {
+		childregs->regs[29] = usp;
+		ti->addr_limit = USER_DS;
+	}
+	p->thread.reg29 = (unsigned long) childregs;
+	p->thread.reg31 = (unsigned long) ret_from_fork;
+
+	/*
+	 * New tasks lose permission to use the fpu. This accelerates context
+	 * switching for most programs since they don't use the fpu.
+	 */
+	p->thread.cp0_status = read_c0_status() & ~(ST0_CU2|ST0_CU1);
+	childregs->cp0_status &= ~(ST0_CU2|ST0_CU1);
+	clear_tsk_thread_flag(p, TIF_USEDFPU);
+
+	return 0;
+}
+
+/* Fill in the fpu structure for a core dump.. */
+int dump_fpu(struct pt_regs *regs, elf_fpregset_t *r)
+{
+	memcpy(r, &current->thread.fpu, sizeof(current->thread.fpu));
+
+	return 1;
+}
+
+void dump_regs(elf_greg_t *gp, struct pt_regs *regs)
+{
+	int i;
+
+	for (i = 0; i < EF_R0; i++)
+		gp[i] = 0;
+	gp[EF_R0] = 0;
+	for (i = 1; i <= 31; i++)
+		gp[EF_R0 + i] = regs->regs[i];
+	gp[EF_R26] = 0;
+	gp[EF_R27] = 0;
+	gp[EF_LO] = regs->lo;
+	gp[EF_HI] = regs->hi;
+	gp[EF_CP0_EPC] = regs->cp0_epc;
+	gp[EF_CP0_BADVADDR] = regs->cp0_badvaddr;
+	gp[EF_CP0_STATUS] = regs->cp0_status;
+	gp[EF_CP0_CAUSE] = regs->cp0_cause;
+#ifdef EF_UNUSED0
+	gp[EF_UNUSED0] = 0;
+#endif
+}
+
+int dump_task_fpu (struct task_struct *t, elf_fpregset_t *fpr)
+{
+	memcpy(fpr, &t->thread.fpu, sizeof(current->thread.fpu));
+
+	return 1;
+}
+
+/*
+ * Create a kernel thread
+ */
+ATTRIB_NORET void kernel_thread_helper(void *arg, int (*fn)(void *))
+{
+	do_exit(fn(arg));
+}
+
+long kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)
+{
+	struct pt_regs regs;
+
+	memset(&regs, 0, sizeof(regs));
+
+	regs.regs[4] = (unsigned long) arg;
+	regs.regs[5] = (unsigned long) fn;
+	regs.cp0_epc = (unsigned long) kernel_thread_helper;
+	regs.cp0_status = read_c0_status();
+#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
+	regs.cp0_status &= ~(ST0_KUP | ST0_IEC);
+	regs.cp0_status |= ST0_IEP;
+#else
+	regs.cp0_status |= ST0_EXL;
+#endif
+
+	/* Ok, create the new process.. */
+	return do_fork(flags | CLONE_VM | CLONE_UNTRACED, 0, &regs, 0, NULL, NULL);
+}
+
+struct mips_frame_info {
+	int frame_offset;
+	int pc_offset;
+};
+static struct mips_frame_info schedule_frame;
+static struct mips_frame_info schedule_timeout_frame;
+static struct mips_frame_info sleep_on_frame;
+static struct mips_frame_info sleep_on_timeout_frame;
+static struct mips_frame_info wait_for_completion_frame;
+static int mips_frame_info_initialized;
+static int __init get_frame_info(struct mips_frame_info *info, void *func)
+{
+	int i;
+	union mips_instruction *ip = (union mips_instruction *)func;
+	info->pc_offset = -1;
+	info->frame_offset = -1;
+	for (i = 0; i < 128; i++, ip++) {
+		/* if jal, jalr, jr, stop. */
+		if (ip->j_format.opcode == jal_op ||
+		    (ip->r_format.opcode == spec_op &&
+		     (ip->r_format.func == jalr_op ||
+		      ip->r_format.func == jr_op)))
+			break;
+
+		if (
+#ifdef CONFIG_MIPS32
+		    ip->i_format.opcode == sw_op &&
+#endif
+#ifdef CONFIG_MIPS64
+		    ip->i_format.opcode == sd_op &&
+#endif
+		    ip->i_format.rs == 29)
+		{
+			/* sw / sd $ra, offset($sp) */
+			if (ip->i_format.rt == 31) {
+				if (info->pc_offset != -1)
+					break;
+				info->pc_offset =
+					ip->i_format.simmediate / sizeof(long);
+			}
+			/* sw / sd $s8, offset($sp) */
+			if (ip->i_format.rt == 30) {
+				if (info->frame_offset != -1)
+					break;
+				info->frame_offset =
+					ip->i_format.simmediate / sizeof(long);
+			}
+		}
+	}
+	if (info->pc_offset == -1 || info->frame_offset == -1) {
+		printk("Can't analyze prologue code at %p\n", func);
+		info->pc_offset = -1;
+		info->frame_offset = -1;
+		return -1;
+	}
+
+	return 0;
+}
+
+static int __init frame_info_init(void)
+{
+	mips_frame_info_initialized =
+		!get_frame_info(&schedule_frame, schedule) &&
+		!get_frame_info(&schedule_timeout_frame, schedule_timeout) &&
+		!get_frame_info(&sleep_on_frame, sleep_on) &&
+		!get_frame_info(&sleep_on_timeout_frame, sleep_on_timeout) &&
+		!get_frame_info(&wait_for_completion_frame, wait_for_completion);
+
+	return 0;
+}
+
+arch_initcall(frame_info_init);
+
+/*
+ * Return saved PC of a blocked thread.
+ */
+unsigned long thread_saved_pc(struct task_struct *tsk)
+{
+	struct thread_struct *t = &tsk->thread;
+
+	/* New born processes are a special case */
+	if (t->reg31 == (unsigned long) ret_from_fork)
+		return t->reg31;
+
+	if (schedule_frame.pc_offset < 0)
+		return 0;
+	return ((unsigned long *)t->reg29)[schedule_frame.pc_offset];
+}
+
+/* get_wchan - a maintenance nightmare^W^Wpain in the ass ...  */
+unsigned long get_wchan(struct task_struct *p)
+{
+	unsigned long frame, pc;
+
+	if (!p || p == current || p->state == TASK_RUNNING)
+		return 0;
+
+	if (!mips_frame_info_initialized)
+		return 0;
+	pc = thread_saved_pc(p);
+	if (!in_sched_functions(pc))
+		goto out;
+
+	if (pc >= (unsigned long) sleep_on_timeout)
+		goto schedule_timeout_caller;
+	if (pc >= (unsigned long) sleep_on)
+		goto schedule_caller;
+	if (pc >= (unsigned long) interruptible_sleep_on_timeout)
+		goto schedule_timeout_caller;
+	if (pc >= (unsigned long)interruptible_sleep_on)
+		goto schedule_caller;
+	if (pc >= (unsigned long)wait_for_completion)
+		goto schedule_caller;
+	goto schedule_timeout_caller;
+
+schedule_caller:
+	frame = ((unsigned long *)p->thread.reg30)[schedule_frame.frame_offset];
+	if (pc >= (unsigned long) sleep_on)
+		pc = ((unsigned long *)frame)[sleep_on_frame.pc_offset];
+	else
+		pc = ((unsigned long *)frame)[wait_for_completion_frame.pc_offset];
+	goto out;
+
+schedule_timeout_caller:
+	/*
+	 * The schedule_timeout frame
+	 */
+	frame = ((unsigned long *)p->thread.reg30)[schedule_frame.frame_offset];
+
+	/*
+	 * frame now points to sleep_on_timeout's frame
+	 */
+	pc    = ((unsigned long *)frame)[schedule_timeout_frame.pc_offset];
+
+	if (in_sched_functions(pc)) {
+		/* schedule_timeout called by [interruptible_]sleep_on_timeout */
+		frame = ((unsigned long *)frame)[schedule_timeout_frame.frame_offset];
+		pc    = ((unsigned long *)frame)[sleep_on_timeout_frame.pc_offset];
+	}
+
+out:
+
+#ifdef CONFIG_MIPS64
+	if (current->thread.mflags & MF_32BIT_REGS) /* Kludge for 32-bit ps  */
+		pc &= 0xffffffffUL;
+#endif
+
+	return pc;
+}
+
+EXPORT_SYMBOL(get_wchan);
