commit a9a08845e9acbd224e4ee466f5c1275ed50054e8
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Feb 11 14:34:03 2018 -0800

    vfs: do bulk POLL* -> EPOLL* replacement
    
    This is the mindless scripted replacement of kernel use of POLL*
    variables as described by Al, done by this script:
    
        for V in IN OUT PRI ERR RDNORM RDBAND WRNORM WRBAND HUP RDHUP NVAL MSG; do
            L=`git grep -l -w POLL$V | grep -v '^t' | grep -v /um/ | grep -v '^sa' | grep -v '/poll.h$'|grep -v '^D'`
            for f in $L; do sed -i "-es/^\([^\"]*\)\(\<POLL$V\>\)/\\1E\\2/" $f; done
        done
    
    with de-mangling cleanups yet to come.
    
    NOTE! On almost all architectures, the EPOLL* constants have the same
    values as the POLL* constants do.  But they keyword here is "almost".
    For various bad reasons they aren't the same, and epoll() doesn't
    actually work quite correctly in some cases due to this on Sparc et al.
    
    The next patch from Al will sort out the final differences, and we
    should be all done.
    
    Scripted-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index bbb0f4770c0d..18c509c59f33 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -349,11 +349,11 @@ static __poll_t file_poll(struct file *file, poll_table *wait)
 
 	/* data available to read? */
 	if (rtlx_read_poll(minor, 0))
-		mask |= POLLIN | POLLRDNORM;
+		mask |= EPOLLIN | EPOLLRDNORM;
 
 	/* space to write */
 	if (rtlx_write_poll(minor))
-		mask |= POLLOUT | POLLWRNORM;
+		mask |= EPOLLOUT | EPOLLWRNORM;
 
 	return mask;
 }

commit 8b9aab09aaf390b868359b9365b667cf6506473c
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Jul 2 22:27:13 2017 -0400

    mips: annotate ->poll() instances
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index b80dd8b17a76..bbb0f4770c0d 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -336,10 +336,10 @@ static int file_release(struct inode *inode, struct file *filp)
 	return rtlx_release(iminor(inode));
 }
 
-static unsigned int file_poll(struct file *file, poll_table *wait)
+static __poll_t file_poll(struct file *file, poll_table *wait)
 {
 	int minor = iminor(file_inode(file));
-	unsigned int mask = 0;
+	__poll_t mask = 0;
 
 	poll_wait(file, &channel_wqs[minor].rt_queue, wait);
 	poll_wait(file, &channel_wqs[minor].lx_queue, wait);

commit 174cd4b1e5fbd0d74c68cf3a74f5bd4923485512
Author: Ingo Molnar <mingo@kernel.org>
Date:   Thu Feb 2 19:15:33 2017 +0100

    sched/headers: Prepare to move signal wakeup & sigpending methods from <linux/sched.h> into <linux/sched/signal.h>
    
    Fix up affected files that include this signal functionality via sched.h.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index c5c4fd54d797..b80dd8b17a76 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -12,6 +12,8 @@
 #include <linux/syscalls.h>
 #include <linux/moduleloader.h>
 #include <linux/atomic.h>
+#include <linux/sched/signal.h>
+
 #include <asm/mipsmtregs.h>
 #include <asm/mips_mt.h>
 #include <asm/processor.h>

commit 3dc4bf310a5c74eefb23af026034cce2a584296e
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Tue Oct 7 12:57:45 2014 +0900

    MIPS: rtlx: Remove KERN_DEBUG from pr_debug() arguments in rtlx.c
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/7938/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 31b1b763cb29..c5c4fd54d797 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -94,12 +94,12 @@ int rtlx_open(int index, int can_sleep)
 	int ret = 0;
 
 	if (index >= RTLX_CHANNELS) {
-		pr_debug(KERN_DEBUG "rtlx_open index out of range\n");
+		pr_debug("rtlx_open index out of range\n");
 		return -ENOSYS;
 	}
 
 	if (atomic_inc_return(&channel_wqs[index].in_open) > 1) {
-		pr_debug(KERN_DEBUG "rtlx_open channel %d already opened\n", index);
+		pr_debug("rtlx_open channel %d already opened\n", index);
 		ret = -EBUSY;
 		goto out_fail;
 	}

commit 5792bf6438658cb129c3022aa2cf7e9b19b5de3a
Author: Steven J. Hill <Steven.Hill@imgtec.com>
Date:   Wed Jan 1 16:35:32 2014 +0100

    MIPS: APRP: Code formatting clean-ups.
    
    Clean-up code according to the 'checkpatch.pl' script.
    
    Signed-off-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Reviewed-by: Qais Yousef <Qais.Yousef@imgtec.com>
    Patchwork: http://patchwork.linux-mips.org/patch/6097/
    Reviewed-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 59db407d0499..31b1b763cb29 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -1,46 +1,23 @@
 /*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
  * Copyright (C) 2005 MIPS Technologies, Inc.  All rights reserved.
  * Copyright (C) 2005, 06 Ralf Baechle (ralf@linux-mips.org)
- *
- *  This program is free software; you can distribute it and/or modify it
- *  under the terms of the GNU General Public License (Version 2) as
- *  published by the Free Software Foundation.
- *
- *  This program is distributed in the hope it will be useful, but WITHOUT
- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- *  for more details.
- *
- *  You should have received a copy of the GNU General Public License along
- *  with this program; if not, write to the Free Software Foundation, Inc.,
- *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
- *
+ * Copyright (C) 2013 Imagination Technologies Ltd.
  */
-
-#include <linux/device.h>
 #include <linux/kernel.h>
 #include <linux/fs.h>
-#include <linux/init.h>
-#include <asm/uaccess.h>
-#include <linux/list.h>
-#include <linux/vmalloc.h>
-#include <linux/elf.h>
-#include <linux/seq_file.h>
 #include <linux/syscalls.h>
 #include <linux/moduleloader.h>
-#include <linux/interrupt.h>
-#include <linux/poll.h>
-#include <linux/sched.h>
-#include <linux/wait.h>
+#include <linux/atomic.h>
 #include <asm/mipsmtregs.h>
 #include <asm/mips_mt.h>
-#include <asm/cacheflush.h>
-#include <linux/atomic.h>
-#include <asm/cpu.h>
 #include <asm/processor.h>
-#include <asm/vpe.h>
 #include <asm/rtlx.h>
 #include <asm/setup.h>
+#include <asm/vpe.h>
 
 static int sp_stopping;
 struct rtlx_info *rtlx;
@@ -53,22 +30,22 @@ static void __used dump_rtlx(void)
 {
 	int i;
 
-	printk("id 0x%lx state %d\n", rtlx->id, rtlx->state);
+	pr_info("id 0x%lx state %d\n", rtlx->id, rtlx->state);
 
 	for (i = 0; i < RTLX_CHANNELS; i++) {
 		struct rtlx_channel *chan = &rtlx->channel[i];
 
-		printk(" rt_state %d lx_state %d buffer_size %d\n",
-		       chan->rt_state, chan->lx_state, chan->buffer_size);
+		pr_info(" rt_state %d lx_state %d buffer_size %d\n",
+			chan->rt_state, chan->lx_state, chan->buffer_size);
 
-		printk(" rt_read %d rt_write %d\n",
-		       chan->rt_read, chan->rt_write);
+		pr_info(" rt_read %d rt_write %d\n",
+			chan->rt_read, chan->rt_write);
 
-		printk(" lx_read %d lx_write %d\n",
-		       chan->lx_read, chan->lx_write);
+		pr_info(" lx_read %d lx_write %d\n",
+			chan->lx_read, chan->lx_write);
 
-		printk(" rt_buffer <%s>\n", chan->rt_buffer);
-		printk(" lx_buffer <%s>\n", chan->lx_buffer);
+		pr_info(" rt_buffer <%s>\n", chan->rt_buffer);
+		pr_info(" lx_buffer <%s>\n", chan->lx_buffer);
 	}
 }
 
@@ -76,8 +53,7 @@ static void __used dump_rtlx(void)
 static int rtlx_init(struct rtlx_info *rtlxi)
 {
 	if (rtlxi->id != RTLX_ID) {
-		printk(KERN_ERR "no valid RTLX id at 0x%p 0x%lx\n",
-			rtlxi, rtlxi->id);
+		pr_err("no valid RTLX id at 0x%p 0x%lx\n", rtlxi, rtlxi->id);
 		return -ENOEXEC;
 	}
 
@@ -93,7 +69,7 @@ void rtlx_starting(int vpe)
 	sp_stopping = 0;
 
 	/* force a reload of rtlx */
-	rtlx=NULL;
+	rtlx = NULL;
 
 	/* wake up any sleeping rtlx_open's */
 	for (i = 0; i < RTLX_CHANNELS; i++)
@@ -118,31 +94,30 @@ int rtlx_open(int index, int can_sleep)
 	int ret = 0;
 
 	if (index >= RTLX_CHANNELS) {
-		printk(KERN_DEBUG "rtlx_open index out of range\n");
+		pr_debug(KERN_DEBUG "rtlx_open index out of range\n");
 		return -ENOSYS;
 	}
 
 	if (atomic_inc_return(&channel_wqs[index].in_open) > 1) {
-		printk(KERN_DEBUG "rtlx_open channel %d already opened\n",
-		       index);
+		pr_debug(KERN_DEBUG "rtlx_open channel %d already opened\n", index);
 		ret = -EBUSY;
 		goto out_fail;
 	}
 
 	if (rtlx == NULL) {
-		if( (p = vpe_get_shared(tclimit)) == NULL) {
-		    if (can_sleep) {
-			ret = __wait_event_interruptible(
+		p = vpe_get_shared(aprp_cpu_index());
+		if (p == NULL) {
+			if (can_sleep) {
+				ret = __wait_event_interruptible(
 					channel_wqs[index].lx_queue,
-					(p = vpe_get_shared(tclimit)));
-			if (ret)
+					(p = vpe_get_shared(aprp_cpu_index())));
+				if (ret)
+					goto out_fail;
+			} else {
+				pr_debug("No SP program loaded, and device opened with O_NONBLOCK\n");
+				ret = -ENOSYS;
 				goto out_fail;
-		    } else {
-			printk(KERN_DEBUG "No SP program loaded, and device "
-					"opened with O_NONBLOCK\n");
-			ret = -ENOSYS;
-			goto out_fail;
-		    }
+			}
 		}
 
 		smp_rmb();
@@ -164,24 +139,24 @@ int rtlx_open(int index, int can_sleep)
 					ret = -ERESTARTSYS;
 					goto out_fail;
 				}
-				finish_wait(&channel_wqs[index].lx_queue, &wait);
+				finish_wait(&channel_wqs[index].lx_queue,
+					    &wait);
 			} else {
-				pr_err(" *vpe_get_shared is NULL. "
-				       "Has an SP program been loaded?\n");
+				pr_err(" *vpe_get_shared is NULL. Has an SP program been loaded?\n");
 				ret = -ENOSYS;
 				goto out_fail;
 			}
 		}
 
 		if ((unsigned int)*p < KSEG0) {
-			printk(KERN_WARNING "vpe_get_shared returned an "
-			       "invalid pointer maybe an error code %d\n",
-			       (int)*p);
+			pr_warn("vpe_get_shared returned an invalid pointer maybe an error code %d\n",
+				(int)*p);
 			ret = -ENOSYS;
 			goto out_fail;
 		}
 
-		if ((ret = rtlx_init(*p)) < 0)
+		ret = rtlx_init(*p);
+		if (ret < 0)
 			goto out_ret;
 	}
 
@@ -312,7 +287,7 @@ ssize_t rtlx_write(int index, const void __user *buffer, size_t count)
 	size_t fl;
 
 	if (rtlx == NULL)
-		return(-ENOSYS);
+		return -ENOSYS;
 
 	rt = &rtlx->channel[index];
 
@@ -321,8 +296,8 @@ ssize_t rtlx_write(int index, const void __user *buffer, size_t count)
 	rt_read = rt->rt_read;
 
 	/* total number of bytes to copy */
-	count = min(count, (size_t)write_spacefree(rt_read, rt->rt_write,
-							rt->buffer_size));
+	count = min_t(size_t, count, write_spacefree(rt_read, rt->rt_write,
+						     rt->buffer_size));
 
 	/* first bit from write pointer to the end of the buffer, or count */
 	fl = min(count, (size_t) rt->buffer_size - rt->rt_write);
@@ -332,9 +307,8 @@ ssize_t rtlx_write(int index, const void __user *buffer, size_t count)
 		goto out;
 
 	/* if there's any left copy to the beginning of the buffer */
-	if (count - fl) {
+	if (count - fl)
 		failed = copy_from_user(rt->rt_buffer, buffer + fl, count - fl);
-	}
 
 out:
 	count -= failed;
@@ -360,7 +334,7 @@ static int file_release(struct inode *inode, struct file *filp)
 	return rtlx_release(iminor(inode));
 }
 
-static unsigned int file_poll(struct file *file, poll_table * wait)
+static unsigned int file_poll(struct file *file, poll_table *wait)
 {
 	int minor = iminor(file_inode(file));
 	unsigned int mask = 0;
@@ -382,21 +356,20 @@ static unsigned int file_poll(struct file *file, poll_table * wait)
 	return mask;
 }
 
-static ssize_t file_read(struct file *file, char __user * buffer, size_t count,
-			 loff_t * ppos)
+static ssize_t file_read(struct file *file, char __user *buffer, size_t count,
+			 loff_t *ppos)
 {
 	int minor = iminor(file_inode(file));
 
 	/* data available? */
-	if (!rtlx_read_poll(minor, (file->f_flags & O_NONBLOCK) ? 0 : 1)) {
-		return 0;	// -EAGAIN makes cat whinge
-	}
+	if (!rtlx_read_poll(minor, (file->f_flags & O_NONBLOCK) ? 0 : 1))
+		return 0;	/* -EAGAIN makes 'cat' whine */
 
 	return rtlx_read(minor, buffer, count);
 }
 
-static ssize_t file_write(struct file *file, const char __user * buffer,
-			  size_t count, loff_t * ppos)
+static ssize_t file_write(struct file *file, const char __user *buffer,
+			  size_t count, loff_t *ppos)
 {
 	int minor = iminor(file_inode(file));
 
@@ -418,11 +391,11 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 
 const struct file_operations rtlx_fops = {
 	.owner =   THIS_MODULE,
-	.open =	   file_open,
+	.open =    file_open,
 	.release = file_release,
 	.write =   file_write,
-	.read =	   file_read,
-	.poll =	   file_poll,
+	.read =    file_read,
+	.poll =    file_poll,
 	.llseek =  noop_llseek,
 };
 

commit 2c973ef0cc3f981bfb137c3e42e08de5e8f1cc18
Author: Deng-Cheng Zhu <dengcheng.zhu@imgtec.com>
Date:   Wed Jan 1 16:26:46 2014 +0100

    MIPS: APRP: Split RTLX support into separate files.
    
    Split the RTLX functionality in preparation for adding support for CMP
    platforms. Common functions remain in the original file and a new file
    contains code specific to platforms that do not have a CMP.
    
    Signed-off-by: Deng-Cheng Zhu <dengcheng.zhu@imgtec.com>
    Signed-off-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Reviewed-by: Qais Yousef <Qais.Yousef@imgtec.com>
    Patchwork: http://patchwork.linux-mips.org/patch/6093/
    Reviewed-by: John Crispin <blogic@openwrt.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 2c12ea1668d1..59db407d0499 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -42,52 +42,12 @@
 #include <asm/rtlx.h>
 #include <asm/setup.h>
 
-static struct rtlx_info *rtlx;
-static int major;
-static char module_name[] = "rtlx";
-
-static struct chan_waitqueues {
-	wait_queue_head_t rt_queue;
-	wait_queue_head_t lx_queue;
-	atomic_t in_open;
-	struct mutex mutex;
-} channel_wqs[RTLX_CHANNELS];
-
-static struct vpe_notifications notify;
 static int sp_stopping;
-
-extern void *vpe_get_shared(int index);
-
-static void rtlx_dispatch(void)
-{
-	do_IRQ(MIPS_CPU_IRQ_BASE + MIPS_CPU_RTLX_IRQ);
-}
-
-
-/* Interrupt handler may be called before rtlx_init has otherwise had
-   a chance to run.
-*/
-static irqreturn_t rtlx_interrupt(int irq, void *dev_id)
-{
-	unsigned int vpeflags;
-	unsigned long flags;
-	int i;
-
-	/* Ought not to be strictly necessary for SMTC builds */
-	local_irq_save(flags);
-	vpeflags = dvpe();
-	set_c0_status(0x100 << MIPS_CPU_RTLX_IRQ);
-	irq_enable_hazard();
-	evpe(vpeflags);
-	local_irq_restore(flags);
-
-	for (i = 0; i < RTLX_CHANNELS; i++) {
-			wake_up(&channel_wqs[i].lx_queue);
-			wake_up(&channel_wqs[i].rt_queue);
-	}
-
-	return IRQ_HANDLED;
-}
+struct rtlx_info *rtlx;
+struct chan_waitqueues channel_wqs[RTLX_CHANNELS];
+struct vpe_notifications rtlx_notify;
+void (*aprp_hook)(void) = NULL;
+EXPORT_SYMBOL(aprp_hook);
 
 static void __used dump_rtlx(void)
 {
@@ -127,7 +87,7 @@ static int rtlx_init(struct rtlx_info *rtlxi)
 }
 
 /* notifications */
-static void starting(int vpe)
+void rtlx_starting(int vpe)
 {
 	int i;
 	sp_stopping = 0;
@@ -140,7 +100,7 @@ static void starting(int vpe)
 		wake_up_interruptible(&channel_wqs[i].lx_queue);
 }
 
-static void stopping(int vpe)
+void rtlx_stopping(int vpe)
 {
 	int i;
 
@@ -384,6 +344,8 @@ ssize_t rtlx_write(int index, const void __user *buffer, size_t count)
 	smp_wmb();
 	mutex_unlock(&channel_wqs[index].mutex);
 
+	_interrupt_sp();
+
 	return count;
 }
 
@@ -454,7 +416,7 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 	return rtlx_write(minor, buffer, count);
 }
 
-static const struct file_operations rtlx_fops = {
+const struct file_operations rtlx_fops = {
 	.owner =   THIS_MODULE,
 	.open =	   file_open,
 	.release = file_release,
@@ -464,90 +426,6 @@ static const struct file_operations rtlx_fops = {
 	.llseek =  noop_llseek,
 };
 
-static struct irqaction rtlx_irq = {
-	.handler	= rtlx_interrupt,
-	.name		= "RTLX",
-};
-
-static int rtlx_irq_num = MIPS_CPU_IRQ_BASE + MIPS_CPU_RTLX_IRQ;
-
-static char register_chrdev_failed[] __initdata =
-	KERN_ERR "rtlx_module_init: unable to register device\n";
-
-static int __init rtlx_module_init(void)
-{
-	struct device *dev;
-	int i, err;
-
-	if (!cpu_has_mipsmt) {
-		printk("VPE loader: not a MIPS MT capable processor\n");
-		return -ENODEV;
-	}
-
-	if (tclimit == 0) {
-		printk(KERN_WARNING "No TCs reserved for AP/SP, not "
-		       "initializing RTLX.\nPass maxtcs=<n> argument as kernel "
-		       "argument\n");
-
-		return -ENODEV;
-	}
-
-	major = register_chrdev(0, module_name, &rtlx_fops);
-	if (major < 0) {
-		printk(register_chrdev_failed);
-		return major;
-	}
-
-	/* initialise the wait queues */
-	for (i = 0; i < RTLX_CHANNELS; i++) {
-		init_waitqueue_head(&channel_wqs[i].rt_queue);
-		init_waitqueue_head(&channel_wqs[i].lx_queue);
-		atomic_set(&channel_wqs[i].in_open, 0);
-		mutex_init(&channel_wqs[i].mutex);
-
-		dev = device_create(mt_class, NULL, MKDEV(major, i), NULL,
-				    "%s%d", module_name, i);
-		if (IS_ERR(dev)) {
-			err = PTR_ERR(dev);
-			goto out_chrdev;
-		}
-	}
-
-	/* set up notifiers */
-	notify.start = starting;
-	notify.stop = stopping;
-	vpe_notify(tclimit, &notify);
-
-	if (cpu_has_vint)
-		set_vi_handler(MIPS_CPU_RTLX_IRQ, rtlx_dispatch);
-	else {
-		pr_err("APRP RTLX init on non-vectored-interrupt processor\n");
-		err = -ENODEV;
-		goto out_chrdev;
-	}
-
-	rtlx_irq.dev_id = rtlx;
-	setup_irq(rtlx_irq_num, &rtlx_irq);
-
-	return 0;
-
-out_chrdev:
-	for (i = 0; i < RTLX_CHANNELS; i++)
-		device_destroy(mt_class, MKDEV(major, i));
-
-	return err;
-}
-
-static void __exit rtlx_module_exit(void)
-{
-	int i;
-
-	for (i = 0; i < RTLX_CHANNELS; i++)
-		device_destroy(mt_class, MKDEV(major, i));
-
-	unregister_chrdev(major, module_name);
-}
-
 module_init(rtlx_module_init);
 module_exit(rtlx_module_exit);
 

commit 35a2af94c7ce7130ca292c68b1d27fcfdb648f6b
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Wed Oct 2 11:22:33 2013 +0200

    sched/wait: Make the __wait_event*() interface more friendly
    
    Change all __wait_event*() implementations to match the corresponding
    wait_event*() signature for convenience.
    
    In particular this does away with the weird 'ret' logic. Since there
    are __wait_event*() users this requires we update them too.
    
    Reviewed-by: Oleg Nesterov <oleg@redhat.com>
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Link: http://lkml.kernel.org/r/20131002092529.042563462@infradead.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index d763f11e35e2..2c12ea1668d1 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -172,8 +172,9 @@ int rtlx_open(int index, int can_sleep)
 	if (rtlx == NULL) {
 		if( (p = vpe_get_shared(tclimit)) == NULL) {
 		    if (can_sleep) {
-			__wait_event_interruptible(channel_wqs[index].lx_queue,
-				(p = vpe_get_shared(tclimit)), ret);
+			ret = __wait_event_interruptible(
+					channel_wqs[index].lx_queue,
+					(p = vpe_get_shared(tclimit)));
 			if (ret)
 				goto out_fail;
 		    } else {
@@ -263,11 +264,10 @@ unsigned int rtlx_read_poll(int index, int can_sleep)
 	/* data available to read? */
 	if (chan->lx_read == chan->lx_write) {
 		if (can_sleep) {
-			int ret = 0;
-
-			__wait_event_interruptible(channel_wqs[index].lx_queue,
+			int ret = __wait_event_interruptible(
+				channel_wqs[index].lx_queue,
 				(chan->lx_read != chan->lx_write) ||
-				sp_stopping, ret);
+				sp_stopping);
 			if (ret)
 				return ret;
 
@@ -440,14 +440,13 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 
 	/* any space left... */
 	if (!rtlx_write_poll(minor)) {
-		int ret = 0;
+		int ret;
 
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
 
-		__wait_event_interruptible(channel_wqs[minor].rt_queue,
-					   rtlx_write_poll(minor),
-					   ret);
+		ret = __wait_event_interruptible(channel_wqs[minor].rt_queue,
+					   rtlx_write_poll(minor));
 		if (ret)
 			return ret;
 	}

commit b90b3802624e1f2a509f3e9f39775d94ec4762d7
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 7 14:10:24 2013 +0200

    MIPS: Fix rtlx build error.
    
      CC      arch/mips/kernel/rtlx.o
    /home/ralf/src/linux/upstream-sfr/arch/mips/kernel/rtlx.c: In function ‘file_write’:
    /home/ralf/src/linux/upstream-sfr/arch/mips/kernel/rtlx.c:439:23: error: unused variable ‘rt’ [-Werror=unused-variable]
    /home/ralf/src/linux/upstream-sfr/arch/mips/kernel/rtlx.c: In function ‘rtlx_module_init’:
    /home/ralf/src/linux/upstream-sfr/arch/mips/kernel/rtlx.c:523:3: error: implicit declaration of function ‘set_vi_handler’ [-Werror=implicit-function-declaration]
    cc1: all warnings being treated as errors
    
    Caused by 496ad9aa8ef448058e36ca7a787c61f2e63f0f54 [new helper:
    file_inode(file)].
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 6fa198db8999..d763f11e35e2 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -437,7 +437,6 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 			  size_t count, loff_t * ppos)
 {
 	int minor = iminor(file_inode(file));
-	struct rtlx_channel *rt = &rtlx->channel[minor];
 
 	/* any space left... */
 	if (!rtlx_write_poll(minor)) {

commit 406b5ee22215554a37760b6fa807da6ad4d52f52
Author: Yoichi Yuasa <yuasa@linux-mips.org>
Date:   Tue May 28 01:23:22 2013 +0000

    MIPS: rtlx: Fix implicit declaration of function set_vi_handler()
    
    arch/mips/kernel/rtlx.c: In function 'rtlx_module_init':
    arch/mips/kernel/rtlx.c:523:3: error: implicit declaration of function 'set_vi_handler' [-Werror=implicit-function-declaration]
    
    Signed-off-by: Yoichi Yuasa <yuasa@linux-mips.org>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5340/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 93c070b41b0d..6fa198db8999 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -40,6 +40,7 @@
 #include <asm/processor.h>
 #include <asm/vpe.h>
 #include <asm/rtlx.h>
+#include <asm/setup.h>
 
 static struct rtlx_info *rtlx;
 static int major;

commit aebb2afd5420c860b7fbc3882a323ef1247fbf16
Merge: 8eae508b7c6f edb15d83a875
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 2 07:44:16 2013 -0800

    Merge branch 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus
    
    Pull MIPS updates from Ralf Baechle:
    
     o Add basic support for the Mediatek/Ralink Wireless SoC family.
    
     o The Qualcomm Atheros platform is extended by support for the new
       QCA955X SoC series as well as a bunch of patches that get the code
       ready for OF support.
    
     o Lantiq and BCM47XX platform have a few improvements and bug fixes.
    
     o MIPS has sent a few patches that get the kernel ready for the
       upcoming microMIPS support.
    
     o The rest of the series is made up of small bug fixes and cleanups
       that relate to various parts of the MIPS code.  The biggy in there is
       a whitespace cleanup.  After I was sent another set of whitespace
       cleanup patches I decided it was the time to clean the whitespace
       "issues" for once and and that touches many files below arch/mips/.
    
    Fix up silly conflicts, mostly due to whitespace cleanups.
    
    * 'upstream' of git://git.linux-mips.org/pub/scm/ralf/upstream-linus: (105 commits)
      MIPS: Quit exporting kernel internel break codes to uapi/asm/break.h
      MIPS: remove broken conditional inside vpe loader code
      MIPS: SMTC: fix implicit declaration of set_vi_handler
      MIPS: early_printk: drop __init annotations
      MIPS: Probe for and report hardware virtualization support.
      MIPS: ath79: add support for the Qualcomm Atheros AP136-010 board
      MIPS: ath79: add USB controller registration code for the QCA955X SoCs
      MIPS: ath79: add PCI controller registration code for the QCA955X SoCs
      MIPS: ath79: add WMAC registration code for the QCA955X SoCs
      MIPS: ath79: register UART for the QCA955X SoCs
      MIPS: ath79: add QCA955X specific glue to ath79_device_reset_{set, clear}
      MIPS: ath79: add GPIO setup code for the QCA955X SoCs
      MIPS: ath79: add IRQ handling code for the QCA955X SoCs
      MIPS: ath79: add clock setup code for the QCA955X SoCs
      MIPS: ath79: add SoC detection code for the QCA955X SoCs
      MIPS: ath79: add early printk support for the QCA955X SoCs
      MIPS: ath79: fix WMAC IRQ resource assignment
      mips: reserve elfcorehdr
      mips: Make sure kernel memory is in iomem
      MIPS: ath79: use dynamically allocated USB platform devices
      ...

commit 496ad9aa8ef448058e36ca7a787c61f2e63f0f54
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 23 17:07:38 2013 -0500

    new helper: file_inode(file)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index b8c18dcdd2c4..88f7b50d541c 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -399,11 +399,9 @@ static int file_release(struct inode *inode, struct file *filp)
 
 static unsigned int file_poll(struct file *file, poll_table * wait)
 {
-	int minor;
+	int minor = iminor(file_inode(file));
 	unsigned int mask = 0;
 
-	minor = iminor(file->f_path.dentry->d_inode);
-
 	poll_wait(file, &channel_wqs[minor].rt_queue, wait);
 	poll_wait(file, &channel_wqs[minor].lx_queue, wait);
 
@@ -424,7 +422,7 @@ static unsigned int file_poll(struct file *file, poll_table * wait)
 static ssize_t file_read(struct file *file, char __user * buffer, size_t count,
 			 loff_t * ppos)
 {
-	int minor = iminor(file->f_path.dentry->d_inode);
+	int minor = iminor(file_inode(file));
 
 	/* data available? */
 	if (!rtlx_read_poll(minor, (file->f_flags & O_NONBLOCK) ? 0 : 1)) {
@@ -437,11 +435,8 @@ static ssize_t file_read(struct file *file, char __user * buffer, size_t count,
 static ssize_t file_write(struct file *file, const char __user * buffer,
 			  size_t count, loff_t * ppos)
 {
-	int minor;
-	struct rtlx_channel *rt;
-
-	minor = iminor(file->f_path.dentry->d_inode);
-	rt = &rtlx->channel[minor];
+	int minor = iminor(file_inode(file));
+	struct rtlx_channel *rt = &rtlx->channel[minor];
 
 	/* any space left... */
 	if (!rtlx_write_poll(minor)) {

commit 7034228792cc561e79ff8600f02884bd4c80e287
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Jan 22 12:59:30 2013 +0100

    MIPS: Whitespace cleanup.
    
    Having received another series of whitespace patches I decided to do this
    once and for all rather than dealing with this kind of patches trickling
    in forever.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index b8c18dcdd2c4..ce72bfff5e29 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -252,12 +252,12 @@ int rtlx_release(int index)
 
 unsigned int rtlx_read_poll(int index, int can_sleep)
 {
- 	struct rtlx_channel *chan;
+	struct rtlx_channel *chan;
 
- 	if (rtlx == NULL)
- 		return 0;
+	if (rtlx == NULL)
+		return 0;
 
- 	chan = &rtlx->channel[index];
+	chan = &rtlx->channel[index];
 
 	/* data available to read? */
 	if (chan->lx_read == chan->lx_write) {
@@ -451,8 +451,8 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 			return -EAGAIN;
 
 		__wait_event_interruptible(channel_wqs[minor].rt_queue,
-		                           rtlx_write_poll(minor),
-		                           ret);
+					   rtlx_write_poll(minor),
+					   ret);
 		if (ret)
 			return ret;
 	}
@@ -462,11 +462,11 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 
 static const struct file_operations rtlx_fops = {
 	.owner =   THIS_MODULE,
-	.open =    file_open,
+	.open =	   file_open,
 	.release = file_release,
 	.write =   file_write,
-	.read =    file_read,
-	.poll =    file_poll,
+	.read =	   file_read,
+	.poll =	   file_poll,
 	.llseek =  noop_llseek,
 };
 

commit b81947c646bfefdf98e2fde5d7d39cbbda8525d4
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:02 2012 +0100

    Disintegrate asm/system.h for MIPS
    
    Disintegrate asm/system.h for MIPS.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    cc: linux-mips@linux-mips.org

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index a9d801dec6b0..b8c18dcdd2c4 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -38,7 +38,6 @@
 #include <linux/atomic.h>
 #include <asm/cpu.h>
 #include <asm/processor.h>
-#include <asm/system.h>
 #include <asm/vpe.h>
 #include <asm/rtlx.h>
 

commit 8b5690f8847490c1e3ea47266819833a13621253
Author: Yong Zhang <yong.zhang0@gmail.com>
Date:   Tue Nov 22 14:38:03 2011 +0000

    MIPS: irq: Remove IRQF_DISABLED
    
    Since commit [e58aa3d2: genirq: Run irq handlers with interrupts disabled],
    We run all interrupt handlers with interrupts disabled and we even check
    and yell when an interrupt handler returns with interrupts enabled (see
    commit [b738a50a: genirq: Warn when handler enables interrupts]).
    
    So now this flag is a NOOP and can be removed.
    
    [ralf@linux-mips.org: Fixed up conflicts in
    arch/mips/alchemy/common/dbdma.c, arch/mips/cavium-octeon/smp.c and
    arch/mips/kernel/perf_event.c.]
    
    Signed-off-by: Yong Zhang <yong.zhang0@gmail.com>
    To: linux-kernel@vger.kernel.org
    Cc: tglx@linutronix.de
    linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/2835/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 933166f44a6d..a9d801dec6b0 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -473,7 +473,6 @@ static const struct file_operations rtlx_fops = {
 
 static struct irqaction rtlx_irq = {
 	.handler	= rtlx_interrupt,
-	.flags		= IRQF_DISABLED,
 	.name		= "RTLX",
 };
 

commit 848484e2c41220f07b432ffea79874a1b02ce6db
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Jul 23 16:55:17 2011 -0400

    mips: remove needless include of module.h from core kernel files.
    
    None of these files are using modular infrastructure, and build
    tests reveal that none of these files are really relying on any
    implicit inclusions via. module.h either.  So delete them.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 7a80b7cda7cc..933166f44a6d 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -19,7 +19,6 @@
 
 #include <linux/device.h>
 #include <linux/kernel.h>
-#include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/init.h>
 #include <asm/uaccess.h>

commit 60063497a95e716c9a689af3be2687d261f115b4
Author: Arun Sharma <asharma@fb.com>
Date:   Tue Jul 26 16:09:06 2011 -0700

    atomic: use <linux/atomic.h>
    
    This allows us to move duplicated code in <asm/atomic.h>
    (atomic_inc_not_zero() for now) to <linux/atomic.h>
    
    Signed-off-by: Arun Sharma <asharma@fb.com>
    Reviewed-by: Eric Dumazet <eric.dumazet@gmail.com>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: David Miller <davem@davemloft.net>
    Cc: Eric Dumazet <eric.dumazet@gmail.com>
    Acked-by: Mike Frysinger <vapier@gentoo.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 557ef72472e0..7a80b7cda7cc 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -36,7 +36,7 @@
 #include <asm/mipsmtregs.h>
 #include <asm/mips_mt.h>
 #include <asm/cacheflush.h>
-#include <asm/atomic.h>
+#include <linux/atomic.h>
 #include <asm/cpu.h>
 #include <asm/processor.h>
 #include <asm/system.h>

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 26f9b9ab19cc..557ef72472e0 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -468,7 +468,8 @@ static const struct file_operations rtlx_fops = {
 	.release = file_release,
 	.write =   file_write,
 	.read =    file_read,
-	.poll =    file_poll
+	.poll =    file_poll,
+	.llseek =  noop_llseek,
 };
 
 static struct irqaction rtlx_irq = {

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index dcaed1bbbfe5..26f9b9ab19cc 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -23,7 +23,6 @@
 #include <linux/fs.h>
 #include <linux/init.h>
 #include <asm/uaccess.h>
-#include <linux/slab.h>
 #include <linux/list.h>
 #include <linux/vmalloc.h>
 #include <linux/elf.h>

commit 8facefd0907ae16f96a35bef7ce654206d87c2fc
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Feb 27 12:52:57 2010 +0100

    MIPS: Don't include <linux/smp_lock.h> unnecessarily.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 364f066cb497..dcaed1bbbfe5 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -28,7 +28,6 @@
 #include <linux/vmalloc.h>
 #include <linux/elf.h>
 #include <linux/seq_file.h>
-#include <linux/smp_lock.h>
 #include <linux/syscalls.h>
 #include <linux/moduleloader.h>
 #include <linux/interrupt.h>

commit 1bbfc20d0161cd94b1b8111566be2fa41b41b608
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 29 00:52:27 2009 +0100

    MIPS: VPE: Get rid of BKL.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index a10ebfdc28ae..364f066cb497 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -72,8 +72,9 @@ static void rtlx_dispatch(void)
 */
 static irqreturn_t rtlx_interrupt(int irq, void *dev_id)
 {
+	unsigned int vpeflags;
+	unsigned long flags;
 	int i;
-	unsigned int flags, vpeflags;
 
 	/* Ought not to be strictly necessary for SMTC builds */
 	local_irq_save(flags);
@@ -392,20 +393,12 @@ ssize_t rtlx_write(int index, const void __user *buffer, size_t count)
 
 static int file_open(struct inode *inode, struct file *filp)
 {
-	int minor = iminor(inode);
-	int err;
-
-	lock_kernel();
-	err = rtlx_open(minor, (filp->f_flags & O_NONBLOCK) ? 0 : 1);
-	unlock_kernel();
-	return err;
+	return rtlx_open(iminor(inode), (filp->f_flags & O_NONBLOCK) ? 0 : 1);
 }
 
 static int file_release(struct inode *inode, struct file *filp)
 {
-	int minor = iminor(inode);
-
-	return rtlx_release(minor);
+	return rtlx_release(iminor(inode));
 }
 
 static unsigned int file_poll(struct file *file, poll_table * wait)

commit 982f6ffeeed5ef6104cfd72e517ff9e7a9270fda
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Sep 17 02:25:07 2009 +0200

    MIPS: Remove useless zero initializations.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 4ce93aa7b372..a10ebfdc28ae 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -57,7 +57,7 @@ static struct chan_waitqueues {
 } channel_wqs[RTLX_CHANNELS];
 
 static struct vpe_notifications notify;
-static int sp_stopping = 0;
+static int sp_stopping;
 
 extern void *vpe_get_shared(int index);
 

commit a9b12619f7b6f19c871437ec24a088787a04b1de
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jul 21 20:03:34 2008 -0700

    device create: misc: convert device_create_drvdata to device_create
    
    Now that device_create() has been audited, rename things back to the
    original call to be sane.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index dfd868b68364..4ce93aa7b372 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -522,8 +522,8 @@ static int __init rtlx_module_init(void)
 		atomic_set(&channel_wqs[i].in_open, 0);
 		mutex_init(&channel_wqs[i].mutex);
 
-		dev = device_create_drvdata(mt_class, NULL, MKDEV(major, i),
-					    NULL, "%s%d", module_name, i);
+		dev = device_create(mt_class, NULL, MKDEV(major, i), NULL,
+				    "%s%d", module_name, i);
 		if (IS_ERR(dev)) {
 			err = PTR_ERR(dev);
 			goto out_chrdev;

commit 43f98747d48195d92c4102c17d7175bf24df1801
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 21 12:52:33 2008 -0700

    device create: mips: convert device_create to device_create_drvdata
    
    device_create() is race-prone, so use the race-free
    device_create_drvdata() instead as device_create() is going away.
    
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index b55641961232..dfd868b68364 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -522,8 +522,8 @@ static int __init rtlx_module_init(void)
 		atomic_set(&channel_wqs[i].in_open, 0);
 		mutex_init(&channel_wqs[i].mutex);
 
-		dev = device_create(mt_class, NULL, MKDEV(major, i),
-		                    "%s%d", module_name, i);
+		dev = device_create_drvdata(mt_class, NULL, MKDEV(major, i),
+					    NULL, "%s%d", module_name, i);
 		if (IS_ERR(dev)) {
 			err = PTR_ERR(dev);
 			goto out_chrdev;

commit 7558da942e51933b5e6aa5e851d4da1df0cd6752
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Thu May 15 09:10:50 2008 -0600

    mips: cdev lock_kernel() pushdown
    
    Push the cdev lock_kernel() call into MIPS-specific drivers.
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index b88f1c18ff4d..b55641961232 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -28,6 +28,7 @@
 #include <linux/vmalloc.h>
 #include <linux/elf.h>
 #include <linux/seq_file.h>
+#include <linux/smp_lock.h>
 #include <linux/syscalls.h>
 #include <linux/moduleloader.h>
 #include <linux/interrupt.h>
@@ -392,8 +393,12 @@ ssize_t rtlx_write(int index, const void __user *buffer, size_t count)
 static int file_open(struct inode *inode, struct file *filp)
 {
 	int minor = iminor(inode);
+	int err;
 
-	return rtlx_open(minor, (filp->f_flags & O_NONBLOCK) ? 0 : 1);
+	lock_kernel();
+	err = rtlx_open(minor, (filp->f_flags & O_NONBLOCK) ? 0 : 1);
+	unlock_kernel();
+	return err;
 }
 
 static int file_release(struct inode *inode, struct file *filp)

commit 1928cc84a0a937ce7042d9235996ab380f36f18a
Author: Kevin D. Kissell <kevink@mips.com>
Date:   Wed Apr 16 15:32:22 2008 +0200

    [MIPS] MT: Functional fixes and a little reformatting of APRP support
    
    Signed-off-by: Kevin D. Kissell <kevink@mips.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 0233798f7155..b88f1c18ff4d 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -72,6 +72,15 @@ static void rtlx_dispatch(void)
 static irqreturn_t rtlx_interrupt(int irq, void *dev_id)
 {
 	int i;
+	unsigned int flags, vpeflags;
+
+	/* Ought not to be strictly necessary for SMTC builds */
+	local_irq_save(flags);
+	vpeflags = dvpe();
+	set_c0_status(0x100 << MIPS_CPU_RTLX_IRQ);
+	irq_enable_hazard();
+	evpe(vpeflags);
+	local_irq_restore(flags);
 
 	for (i = 0; i < RTLX_CHANNELS; i++) {
 			wake_up(&channel_wqs[i].lx_queue);
@@ -108,7 +117,8 @@ static void __used dump_rtlx(void)
 static int rtlx_init(struct rtlx_info *rtlxi)
 {
 	if (rtlxi->id != RTLX_ID) {
-		printk(KERN_ERR "no valid RTLX id at 0x%p 0x%lx\n", rtlxi, rtlxi->id);
+		printk(KERN_ERR "no valid RTLX id at 0x%p 0x%lx\n",
+			rtlxi, rtlxi->id);
 		return -ENOEXEC;
 	}
 
@@ -162,18 +172,17 @@ int rtlx_open(int index, int can_sleep)
 
 	if (rtlx == NULL) {
 		if( (p = vpe_get_shared(tclimit)) == NULL) {
-			if (can_sleep) {
-				__wait_event_interruptible(channel_wqs[index].lx_queue,
-				                           (p = vpe_get_shared(tclimit)),
-				                           ret);
-				if (ret)
-					goto out_fail;
-			} else {
-				printk(KERN_DEBUG "No SP program loaded, and device "
-					"opened with O_NONBLOCK\n");
-				ret = -ENOSYS;
+		    if (can_sleep) {
+			__wait_event_interruptible(channel_wqs[index].lx_queue,
+				(p = vpe_get_shared(tclimit)), ret);
+			if (ret)
 				goto out_fail;
-			}
+		    } else {
+			printk(KERN_DEBUG "No SP program loaded, and device "
+					"opened with O_NONBLOCK\n");
+			ret = -ENOSYS;
+			goto out_fail;
+		    }
 		}
 
 		smp_rmb();
@@ -182,7 +191,9 @@ int rtlx_open(int index, int can_sleep)
 				DEFINE_WAIT(wait);
 
 				for (;;) {
-					prepare_to_wait(&channel_wqs[index].lx_queue, &wait, TASK_INTERRUPTIBLE);
+					prepare_to_wait(
+						&channel_wqs[index].lx_queue,
+						&wait, TASK_INTERRUPTIBLE);
 					smp_rmb();
 					if (*p != NULL)
 						break;
@@ -195,7 +206,7 @@ int rtlx_open(int index, int can_sleep)
 				}
 				finish_wait(&channel_wqs[index].lx_queue, &wait);
 			} else {
-				printk(" *vpe_get_shared is NULL. "
+				pr_err(" *vpe_get_shared is NULL. "
 				       "Has an SP program been loaded?\n");
 				ret = -ENOSYS;
 				goto out_fail;
@@ -203,8 +214,9 @@ int rtlx_open(int index, int can_sleep)
 		}
 
 		if ((unsigned int)*p < KSEG0) {
-			printk(KERN_WARNING "vpe_get_shared returned an invalid pointer "
-			       "maybe an error code %d\n", (int)*p);
+			printk(KERN_WARNING "vpe_get_shared returned an "
+			       "invalid pointer maybe an error code %d\n",
+			       (int)*p);
 			ret = -ENOSYS;
 			goto out_fail;
 		}
@@ -232,6 +244,10 @@ int rtlx_open(int index, int can_sleep)
 
 int rtlx_release(int index)
 {
+	if (rtlx == NULL) {
+		pr_err("rtlx_release() with null rtlx\n");
+		return 0;
+	}
 	rtlx->channel[index].lx_state = RTLX_STATE_UNUSED;
 	return 0;
 }
@@ -251,8 +267,8 @@ unsigned int rtlx_read_poll(int index, int can_sleep)
 			int ret = 0;
 
 			__wait_event_interruptible(channel_wqs[index].lx_queue,
-			                           chan->lx_read != chan->lx_write || sp_stopping,
-			                           ret);
+				(chan->lx_read != chan->lx_write) ||
+				sp_stopping, ret);
 			if (ret)
 				return ret;
 
@@ -282,7 +298,9 @@ static inline int write_spacefree(int read, int write, int size)
 unsigned int rtlx_write_poll(int index)
 {
 	struct rtlx_channel *chan = &rtlx->channel[index];
-	return write_spacefree(chan->rt_read, chan->rt_write, chan->buffer_size);
+
+	return write_spacefree(chan->rt_read, chan->rt_write,
+				chan->buffer_size);
 }
 
 ssize_t rtlx_read(int index, void __user *buff, size_t count)
@@ -344,8 +362,8 @@ ssize_t rtlx_write(int index, const void __user *buffer, size_t count)
 	rt_read = rt->rt_read;
 
 	/* total number of bytes to copy */
-	count = min(count,
-		    (size_t)write_spacefree(rt_read, rt->rt_write, rt->buffer_size));
+	count = min(count, (size_t)write_spacefree(rt_read, rt->rt_write,
+							rt->buffer_size));
 
 	/* first bit from write pointer to the end of the buffer, or count */
 	fl = min(count, (size_t) rt->buffer_size - rt->rt_write);
@@ -514,6 +532,11 @@ static int __init rtlx_module_init(void)
 
 	if (cpu_has_vint)
 		set_vi_handler(MIPS_CPU_RTLX_IRQ, rtlx_dispatch);
+	else {
+		pr_err("APRP RTLX init on non-vectored-interrupt processor\n");
+		err = -ENODEV;
+		goto out_chrdev;
+	}
 
 	rtlx_irq.dev_id = rtlx;
 	setup_irq(rtlx_irq_num, &rtlx_irq);

commit adfb8998669a77c7942f220adf1c1fe8ced9deb6
Author: Lucas Woods <woodzy@gmail.com>
Date:   Tue Nov 6 07:13:47 2007 +1100

    [MIPS] Remove duplicate includes.
    
    Signed-off-by: Lucas Woods <woodzy@gmail.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 1ba00c15505b..0233798f7155 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -40,7 +40,6 @@
 #include <asm/atomic.h>
 #include <asm/cpu.h>
 #include <asm/processor.h>
-#include <asm/mips_mt.h>
 #include <asm/system.h>
 #include <asm/vpe.h>
 #include <asm/rtlx.h>

commit 4d24c8f955b8c9d51c5fe7299c898527e94d39ad
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Sep 12 16:32:54 2007 +0100

    [MIPS] rtlx: Fix build error.
    
      CC      arch/mips/kernel/rtlx.o
    cc1: warnings being treated as errors
    arch/mips/kernel/rtlx.c:59: warning: 'irq' defined but not used
    arch/mips/kernel/rtlx.c:60: warning: 'irq_num' defined but not used
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 04d8ee787f78..1ba00c15505b 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -56,8 +56,6 @@ static struct chan_waitqueues {
 	struct mutex mutex;
 } channel_wqs[RTLX_CHANNELS];
 
-static struct irqaction irq;
-static int irq_num;
 static struct vpe_notifications notify;
 static int sp_stopping = 0;
 

commit e606c109c485c6f8e27dd6ddcd2c0b58c96fc5c9
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Sep 12 16:31:12 2007 +0100

    [MIPS] rtlx: fix int vs. long bug.
    
      CC      arch/mips/kernel/rtlx.o
    arch/mips/kernel/rtlx.c: In function 'rtlx_init':
    arch/mips/kernel/rtlx.c:114: warning: format '%x' expects type 'unsigned int', but argument 3 has type 'long unsigned int'
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index aab89e97abb5..04d8ee787f78 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -111,7 +111,7 @@ static void __used dump_rtlx(void)
 static int rtlx_init(struct rtlx_info *rtlxi)
 {
 	if (rtlxi->id != RTLX_ID) {
-		printk(KERN_ERR "no valid RTLX id at 0x%p 0x%x\n", rtlxi, rtlxi->id);
+		printk(KERN_ERR "no valid RTLX id at 0x%p 0x%lx\n", rtlxi, rtlxi->id);
 		return -ENOEXEC;
 	}
 

commit 9d5a3f5fa389821f55c77462f30782b07080b8ef
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Jul 28 00:51:45 2007 +0100

    [MIPS] rtlx: Fix modpost warning
    
    WARNING: vmlinux.o(.text+0x11504): Section mismatch: reference to .init.data:register_chrdev_failed (between 'rtlx_module_init' and 'rtlx_dispatch')
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 5c040060560e..aab89e97abb5 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -471,7 +471,7 @@ static int rtlx_irq_num = MIPS_CPU_IRQ_BASE + MIPS_CPU_RTLX_IRQ;
 static char register_chrdev_failed[] __initdata =
 	KERN_ERR "rtlx_module_init: unable to register device\n";
 
-static int rtlx_module_init(void)
+static int __init rtlx_module_init(void)
 {
 	struct device *dev;
 	int i, err;

commit 07cc0c9e65d3e262f871ea357dd77b41950b1ca5
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Jul 27 19:31:10 2007 +0100

    [MIPS] MT: Enable coexistence of AP/SP with VSMP and SMTC.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 8cf24d716d41..5c040060560e 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -40,12 +40,11 @@
 #include <asm/atomic.h>
 #include <asm/cpu.h>
 #include <asm/processor.h>
+#include <asm/mips_mt.h>
 #include <asm/system.h>
 #include <asm/vpe.h>
 #include <asm/rtlx.h>
 
-#define RTLX_TARG_VPE 1
-
 static struct rtlx_info *rtlx;
 static int major;
 static char module_name[] = "rtlx";
@@ -165,10 +164,10 @@ int rtlx_open(int index, int can_sleep)
 	}
 
 	if (rtlx == NULL) {
-		if( (p = vpe_get_shared(RTLX_TARG_VPE)) == NULL) {
+		if( (p = vpe_get_shared(tclimit)) == NULL) {
 			if (can_sleep) {
 				__wait_event_interruptible(channel_wqs[index].lx_queue,
-				                           (p = vpe_get_shared(RTLX_TARG_VPE)),
+				                           (p = vpe_get_shared(tclimit)),
 				                           ret);
 				if (ret)
 					goto out_fail;
@@ -477,6 +476,19 @@ static int rtlx_module_init(void)
 	struct device *dev;
 	int i, err;
 
+	if (!cpu_has_mipsmt) {
+		printk("VPE loader: not a MIPS MT capable processor\n");
+		return -ENODEV;
+	}
+
+	if (tclimit == 0) {
+		printk(KERN_WARNING "No TCs reserved for AP/SP, not "
+		       "initializing RTLX.\nPass maxtcs=<n> argument as kernel "
+		       "argument\n");
+
+		return -ENODEV;
+	}
+
 	major = register_chrdev(0, module_name, &rtlx_fops);
 	if (major < 0) {
 		printk(register_chrdev_failed);
@@ -501,7 +513,7 @@ static int rtlx_module_init(void)
 	/* set up notifiers */
 	notify.start = starting;
 	notify.stop = stopping;
-	vpe_notify(RTLX_TARG_VPE, &notify);
+	vpe_notify(tclimit, &notify);
 
 	if (cpu_has_vint)
 		set_vi_handler(MIPS_CPU_RTLX_IRQ, rtlx_dispatch);

commit f5dbeaf5ed3938beea8e58ee473982a4bcadc172
Author: David Rientjes <rientjes@google.com>
Date:   Sun Jul 22 01:01:39 2007 -0700

    [MIPS] Replace __attribute_used__ with __used
    
    Replaces the deprecated __attribute_used__ with __used.  Also makes some
    style adjustments to abide by the kernel coding conventions.
    
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: David Rientjes <rientjes@google.com>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index bfc8ca168f83..8cf24d716d41 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -85,7 +85,7 @@ static irqreturn_t rtlx_interrupt(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static __attribute_used__ void dump_rtlx(void)
+static void __used dump_rtlx(void)
 {
 	int i;
 

commit 7f5a7716dc0b380fd3c85ca5a5841969555feaa7
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Apr 25 15:08:57 2007 +0100

    [MIPS] Fix AP/SP to work in the reality of modern kernels.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index e6e3047151a6..bfc8ca168f83 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -289,7 +289,7 @@ unsigned int rtlx_write_poll(int index)
 	return write_spacefree(chan->rt_read, chan->rt_write, chan->buffer_size);
 }
 
-ssize_t rtlx_read(int index, void __user *buff, size_t count, int user)
+ssize_t rtlx_read(int index, void __user *buff, size_t count)
 {
 	size_t lx_write, fl = 0L;
 	struct rtlx_channel *lx;
@@ -331,9 +331,10 @@ ssize_t rtlx_read(int index, void __user *buff, size_t count, int user)
 	return count;
 }
 
-ssize_t rtlx_write(int index, const void __user *buffer, size_t count, int user)
+ssize_t rtlx_write(int index, const void __user *buffer, size_t count)
 {
 	struct rtlx_channel *rt;
+	unsigned long failed;
 	size_t rt_read;
 	size_t fl;
 
@@ -363,7 +364,7 @@ ssize_t rtlx_write(int index, const void __user *buffer, size_t count, int user)
 	}
 
 out:
-	count -= cailed;
+	count -= failed;
 
 	smp_wmb();
 	rt->rt_write = (rt->rt_write + count) % rt->buffer_size;

commit 46230aa6ea1671690e3e5efa2a961fc0745fe9b5
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Mar 16 12:16:27 2007 +0000

    [MIPS] RTLX: Handle copy_*_user return values.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 745649e15adc..e6e3047151a6 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -289,26 +289,11 @@ unsigned int rtlx_write_poll(int index)
 	return write_spacefree(chan->rt_read, chan->rt_write, chan->buffer_size);
 }
 
-static inline void copy_to(void *dst, void *src, size_t count, int user)
-{
-	if (user)
-		copy_to_user(dst, src, count);
-	else
-		memcpy(dst, src, count);
-}
-
-static inline void copy_from(void *dst, void *src, size_t count, int user)
-{
-	if (user)
-		copy_from_user(dst, src, count);
-	else
-		memcpy(dst, src, count);
-}
-
-ssize_t rtlx_read(int index, void *buff, size_t count, int user)
+ssize_t rtlx_read(int index, void __user *buff, size_t count, int user)
 {
 	size_t lx_write, fl = 0L;
 	struct rtlx_channel *lx;
+	unsigned long failed;
 
 	if (rtlx == NULL)
 		return -ENOSYS;
@@ -327,11 +312,16 @@ ssize_t rtlx_read(int index, void *buff, size_t count, int user)
 	/* then how much from the read pointer onwards */
 	fl = min(count, (size_t)lx->buffer_size - lx->lx_read);
 
-	copy_to(buff, lx->lx_buffer + lx->lx_read, fl, user);
+	failed = copy_to_user(buff, lx->lx_buffer + lx->lx_read, fl);
+	if (failed)
+		goto out;
 
 	/* and if there is anything left at the beginning of the buffer */
 	if (count - fl)
-		copy_to(buff + fl, lx->lx_buffer, count - fl, user);
+		failed = copy_to_user(buff + fl, lx->lx_buffer, count - fl);
+
+out:
+	count -= failed;
 
 	smp_wmb();
 	lx->lx_read = (lx->lx_read + count) % lx->buffer_size;
@@ -341,7 +331,7 @@ ssize_t rtlx_read(int index, void *buff, size_t count, int user)
 	return count;
 }
 
-ssize_t rtlx_write(int index, void *buffer, size_t count, int user)
+ssize_t rtlx_write(int index, const void __user *buffer, size_t count, int user)
 {
 	struct rtlx_channel *rt;
 	size_t rt_read;
@@ -363,11 +353,17 @@ ssize_t rtlx_write(int index, void *buffer, size_t count, int user)
 	/* first bit from write pointer to the end of the buffer, or count */
 	fl = min(count, (size_t) rt->buffer_size - rt->rt_write);
 
-	copy_from(rt->rt_buffer + rt->rt_write, buffer, fl, user);
+	failed = copy_from_user(rt->rt_buffer + rt->rt_write, buffer, fl);
+	if (failed)
+		goto out;
 
 	/* if there's any left copy to the beginning of the buffer */
-	if (count - fl)
-		copy_from(rt->rt_buffer, buffer + fl, count - fl, user);
+	if (count - fl) {
+		failed = copy_from_user(rt->rt_buffer, buffer + fl, count - fl);
+	}
+
+out:
+	count -= cailed;
 
 	smp_wmb();
 	rt->rt_write = (rt->rt_write + count) % rt->buffer_size;
@@ -426,7 +422,7 @@ static ssize_t file_read(struct file *file, char __user * buffer, size_t count,
 		return 0;	// -EAGAIN makes cat whinge
 	}
 
-	return rtlx_read(minor, buffer, count, 1);
+	return rtlx_read(minor, buffer, count);
 }
 
 static ssize_t file_write(struct file *file, const char __user * buffer,
@@ -452,7 +448,7 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 			return ret;
 	}
 
-	return rtlx_write(minor, (void *)buffer, count, 1);
+	return rtlx_write(minor, buffer, count);
 }
 
 static const struct file_operations rtlx_fops = {

commit bc4809e939b91c9642f1ddaea732e2d432ee6af6
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Mar 15 17:13:47 2007 +0000

    [MIPS] RTLX: Protect rtlx_{read,write} with mutex.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 0441c7c1e44c..745649e15adc 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -54,6 +54,7 @@ static struct chan_waitqueues {
 	wait_queue_head_t rt_queue;
 	wait_queue_head_t lx_queue;
 	atomic_t in_open;
+	struct mutex mutex;
 } channel_wqs[RTLX_CHANNELS];
 
 static struct irqaction irq;
@@ -314,6 +315,7 @@ ssize_t rtlx_read(int index, void *buff, size_t count, int user)
 
 	lx = &rtlx->channel[index];
 
+	mutex_lock(&channel_wqs[index].mutex);
 	smp_rmb();
 	lx_write = lx->lx_write;
 
@@ -334,6 +336,7 @@ ssize_t rtlx_read(int index, void *buff, size_t count, int user)
 	smp_wmb();
 	lx->lx_read = (lx->lx_read + count) % lx->buffer_size;
 	smp_wmb();
+	mutex_unlock(&channel_wqs[index].mutex);
 
 	return count;
 }
@@ -349,6 +352,7 @@ ssize_t rtlx_write(int index, void *buffer, size_t count, int user)
 
 	rt = &rtlx->channel[index];
 
+	mutex_lock(&channel_wqs[index].mutex);
 	smp_rmb();
 	rt_read = rt->rt_read;
 
@@ -368,6 +372,7 @@ ssize_t rtlx_write(int index, void *buffer, size_t count, int user)
 	smp_wmb();
 	rt->rt_write = (rt->rt_write + count) % rt->buffer_size;
 	smp_wmb();
+	mutex_unlock(&channel_wqs[index].mutex);
 
 	return count;
 }
@@ -486,6 +491,7 @@ static int rtlx_module_init(void)
 		init_waitqueue_head(&channel_wqs[i].rt_queue);
 		init_waitqueue_head(&channel_wqs[i].lx_queue);
 		atomic_set(&channel_wqs[i].in_open, 0);
+		mutex_init(&channel_wqs[i].mutex);
 
 		dev = device_create(mt_class, NULL, MKDEV(major, i),
 		                    "%s%d", module_name, i);

commit 61dcc6f4d9ed5db71f4f0be9026bdd09f1a7dc06
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Mar 15 17:10:16 2007 +0000

    [MIPS] RTLX: Harden against compiler reordering and optimization.
    
    RTLX communication is based on lock-free shared memory buffers.  It
    happened to be working by luck so far but relies on the optimizer doing
    certain optimizations but no reordering.
    
    Fixed by inserting proper barriers in rtlx_read and rtlx_write, and careful
    pointer dereferencing.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 16d3fdecf3ea..0441c7c1e44c 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -306,7 +306,7 @@ static inline void copy_from(void *dst, void *src, size_t count, int user)
 
 ssize_t rtlx_read(int index, void *buff, size_t count, int user)
 {
-	size_t fl = 0L;
+	size_t lx_write, fl = 0L;
 	struct rtlx_channel *lx;
 
 	if (rtlx == NULL)
@@ -314,23 +314,26 @@ ssize_t rtlx_read(int index, void *buff, size_t count, int user)
 
 	lx = &rtlx->channel[index];
 
+	smp_rmb();
+	lx_write = lx->lx_write;
+
 	/* find out how much in total */
 	count = min(count,
-		     (size_t)(lx->lx_write + lx->buffer_size - lx->lx_read)
+		     (size_t)(lx_write + lx->buffer_size - lx->lx_read)
 		     % lx->buffer_size);
 
 	/* then how much from the read pointer onwards */
-	fl = min( count, (size_t)lx->buffer_size - lx->lx_read);
+	fl = min(count, (size_t)lx->buffer_size - lx->lx_read);
 
-	copy_to(buff, &lx->lx_buffer[lx->lx_read], fl, user);
+	copy_to(buff, lx->lx_buffer + lx->lx_read, fl, user);
 
 	/* and if there is anything left at the beginning of the buffer */
-	if ( count - fl )
-		copy_to (buff + fl, lx->lx_buffer, count - fl, user);
+	if (count - fl)
+		copy_to(buff + fl, lx->lx_buffer, count - fl, user);
 
-	/* update the index */
-	lx->lx_read += count;
-	lx->lx_read %= lx->buffer_size;
+	smp_wmb();
+	lx->lx_read = (lx->lx_read + count) % lx->buffer_size;
+	smp_wmb();
 
 	return count;
 }
@@ -338,6 +341,7 @@ ssize_t rtlx_read(int index, void *buff, size_t count, int user)
 ssize_t rtlx_write(int index, void *buffer, size_t count, int user)
 {
 	struct rtlx_channel *rt;
+	size_t rt_read;
 	size_t fl;
 
 	if (rtlx == NULL)
@@ -345,24 +349,27 @@ ssize_t rtlx_write(int index, void *buffer, size_t count, int user)
 
 	rt = &rtlx->channel[index];
 
+	smp_rmb();
+	rt_read = rt->rt_read;
+
 	/* total number of bytes to copy */
 	count = min(count,
-		    (size_t)write_spacefree(rt->rt_read, rt->rt_write,
-					    rt->buffer_size));
+		    (size_t)write_spacefree(rt_read, rt->rt_write, rt->buffer_size));
 
 	/* first bit from write pointer to the end of the buffer, or count */
 	fl = min(count, (size_t) rt->buffer_size - rt->rt_write);
 
-	copy_from (&rt->rt_buffer[rt->rt_write], buffer, fl, user);
+	copy_from(rt->rt_buffer + rt->rt_write, buffer, fl, user);
 
 	/* if there's any left copy to the beginning of the buffer */
-	if( count - fl )
-		copy_from (rt->rt_buffer, buffer + fl, count - fl, user);
+	if (count - fl)
+		copy_from(rt->rt_buffer, buffer + fl, count - fl, user);
 
-	rt->rt_write += count;
-	rt->rt_write %= rt->buffer_size;
+	smp_wmb();
+	rt->rt_write = (rt->rt_write + count) % rt->buffer_size;
+	smp_wmb();
 
-	return(count);
+	return count;
 }
 
 

commit 9e34682026572f07328208f7d2b2c611d2001844
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Mar 15 17:08:28 2007 +0000

    [MIPS] RTLX: Don't use volatile; it's fragile.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index e14ae09eda2b..16d3fdecf3ea 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -146,7 +146,7 @@ static void stopping(int vpe)
 
 int rtlx_open(int index, int can_sleep)
 {
-	volatile struct rtlx_info **p;
+	struct rtlx_info **p;
 	struct rtlx_channel *chan;
 	enum rtlx_state state;
 	int ret = 0;
@@ -179,13 +179,24 @@ int rtlx_open(int index, int can_sleep)
 			}
 		}
 
+		smp_rmb();
 		if (*p == NULL) {
 			if (can_sleep) {
-				__wait_event_interruptible(channel_wqs[index].lx_queue,
-				                           *p != NULL,
-				                           ret);
-				if (ret)
+				DEFINE_WAIT(wait);
+
+				for (;;) {
+					prepare_to_wait(&channel_wqs[index].lx_queue, &wait, TASK_INTERRUPTIBLE);
+					smp_rmb();
+					if (*p != NULL)
+						break;
+					if (!signal_pending(current)) {
+						schedule();
+						continue;
+					}
+					ret = -ERESTARTSYS;
 					goto out_fail;
+				}
+				finish_wait(&channel_wqs[index].lx_queue, &wait);
 			} else {
 				printk(" *vpe_get_shared is NULL. "
 				       "Has an SP program been loaded?\n");

commit 3dac2561e2ed8d75a8bb682c25a32b271298ff49
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Feb 23 14:12:32 2007 +0000

    [MIPS] RTLX: Delete multiple definition of ret shaddowing each other.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 7a8683ab6fde..e14ae09eda2b 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -166,8 +166,6 @@ int rtlx_open(int index, int can_sleep)
 	if (rtlx == NULL) {
 		if( (p = vpe_get_shared(RTLX_TARG_VPE)) == NULL) {
 			if (can_sleep) {
-				int ret = 0;
-
 				__wait_event_interruptible(channel_wqs[index].lx_queue,
 				                           (p = vpe_get_shared(RTLX_TARG_VPE)),
 				                           ret);
@@ -183,8 +181,6 @@ int rtlx_open(int index, int can_sleep)
 
 		if (*p == NULL) {
 			if (can_sleep) {
-				int ret = 0;
-
 				__wait_event_interruptible(channel_wqs[index].lx_queue,
 				                           *p != NULL,
 				                           ret);

commit c4c4018b04f9b7993e3800dc1f391ac8947764a5
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri Feb 23 13:40:45 2007 +0000

    [MIPS] RTLX, VPE: Make open actually atomic.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 766db51ab69e..7a8683ab6fde 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -53,7 +53,7 @@ static char module_name[] = "rtlx";
 static struct chan_waitqueues {
 	wait_queue_head_t rt_queue;
 	wait_queue_head_t lx_queue;
-	int in_open;
+	atomic_t in_open;
 } channel_wqs[RTLX_CHANNELS];
 
 static struct irqaction irq;
@@ -148,6 +148,7 @@ int rtlx_open(int index, int can_sleep)
 {
 	volatile struct rtlx_info **p;
 	struct rtlx_channel *chan;
+	enum rtlx_state state;
 	int ret = 0;
 
 	if (index >= RTLX_CHANNELS) {
@@ -155,13 +156,13 @@ int rtlx_open(int index, int can_sleep)
 		return -ENOSYS;
 	}
 
-	if (channel_wqs[index].in_open) {
-		printk(KERN_DEBUG "rtlx_open channel %d already opened\n", index);
-		return -EBUSY;
+	if (atomic_inc_return(&channel_wqs[index].in_open) > 1) {
+		printk(KERN_DEBUG "rtlx_open channel %d already opened\n",
+		       index);
+		ret = -EBUSY;
+		goto out_fail;
 	}
 
-	channel_wqs[index].in_open++;
-
 	if (rtlx == NULL) {
 		if( (p = vpe_get_shared(RTLX_TARG_VPE)) == NULL) {
 			if (can_sleep) {
@@ -173,9 +174,8 @@ int rtlx_open(int index, int can_sleep)
 				if (ret)
 					goto out_fail;
 			} else {
-				printk( KERN_DEBUG "No SP program loaded, and device "
+				printk(KERN_DEBUG "No SP program loaded, and device "
 					"opened with O_NONBLOCK\n");
-				channel_wqs[index].in_open = 0;
 				ret = -ENOSYS;
 				goto out_fail;
 			}
@@ -193,7 +193,6 @@ int rtlx_open(int index, int can_sleep)
 			} else {
 				printk(" *vpe_get_shared is NULL. "
 				       "Has an SP program been loaded?\n");
-				channel_wqs[index].in_open = 0;
 				ret = -ENOSYS;
 				goto out_fail;
 			}
@@ -202,31 +201,28 @@ int rtlx_open(int index, int can_sleep)
 		if ((unsigned int)*p < KSEG0) {
 			printk(KERN_WARNING "vpe_get_shared returned an invalid pointer "
 			       "maybe an error code %d\n", (int)*p);
- 			channel_wqs[index].in_open = 0;
 			ret = -ENOSYS;
 			goto out_fail;
 		}
 
-		if ((ret = rtlx_init(*p)) < 0) {
- 			channel_wqs[index].in_open = 0;
-  			return ret;
- 		}
+		if ((ret = rtlx_init(*p)) < 0)
+			goto out_ret;
 	}
 
 	chan = &rtlx->channel[index];
 
- 	if (chan->lx_state == RTLX_STATE_OPENED) {
- 		channel_wqs[index].in_open = 0;
-  		return -EBUSY;
- 	}
-
-  	chan->lx_state = RTLX_STATE_OPENED;
- 	channel_wqs[index].in_open = 0;
-	return 0;
+	state = xchg(&chan->lx_state, RTLX_STATE_OPENED);
+	if (state == RTLX_STATE_OPENED) {
+		ret = -EBUSY;
+		goto out_fail;
+	}
 
 out_fail:
-	channel_wqs[index].in_open--;
+	smp_mb();
+	atomic_dec(&channel_wqs[index].in_open);
+	smp_mb();
 
+out_ret:
 	return ret;
 }
 
@@ -475,7 +471,7 @@ static int rtlx_module_init(void)
 	for (i = 0; i < RTLX_CHANNELS; i++) {
 		init_waitqueue_head(&channel_wqs[i].rt_queue);
 		init_waitqueue_head(&channel_wqs[i].lx_queue);
-		channel_wqs[i].in_open = 0;
+		atomic_set(&channel_wqs[i].in_open, 0);
 
 		dev = device_create(mt_class, NULL, MKDEV(major, i),
 		                    "%s%d", module_name, i);

commit 67e2cccec6d230165345fdf6c0fe4c8761f9d1ba
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Feb 22 14:19:48 2007 +0000

    [MIPS] RTLX: Handle signals when sleeping.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index d92c48e0d7a6..766db51ab69e 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -146,9 +146,9 @@ static void stopping(int vpe)
 
 int rtlx_open(int index, int can_sleep)
 {
-	int ret;
-	struct rtlx_channel *chan;
 	volatile struct rtlx_info **p;
+	struct rtlx_channel *chan;
+	int ret = 0;
 
 	if (index >= RTLX_CHANNELS) {
 		printk(KERN_DEBUG "rtlx_open index out of range\n");
@@ -165,65 +165,37 @@ int rtlx_open(int index, int can_sleep)
 	if (rtlx == NULL) {
 		if( (p = vpe_get_shared(RTLX_TARG_VPE)) == NULL) {
 			if (can_sleep) {
-				DECLARE_WAITQUEUE(wait, current);
-
-				/* go to sleep */
-				add_wait_queue(&channel_wqs[index].lx_queue, &wait);
+				int ret = 0;
 
-				set_current_state(TASK_INTERRUPTIBLE);
-				while ((p = vpe_get_shared(RTLX_TARG_VPE)) == NULL) {
-					schedule();
-					set_current_state(TASK_INTERRUPTIBLE);
-				}
-
-				set_current_state(TASK_RUNNING);
-				remove_wait_queue(&channel_wqs[index].lx_queue, &wait);
-
-				/* back running */
+				__wait_event_interruptible(channel_wqs[index].lx_queue,
+				                           (p = vpe_get_shared(RTLX_TARG_VPE)),
+				                           ret);
+				if (ret)
+					goto out_fail;
 			} else {
 				printk( KERN_DEBUG "No SP program loaded, and device "
 					"opened with O_NONBLOCK\n");
 				channel_wqs[index].in_open = 0;
-				return -ENOSYS;
+				ret = -ENOSYS;
+				goto out_fail;
 			}
 		}
 
 		if (*p == NULL) {
 			if (can_sleep) {
-				DECLARE_WAITQUEUE(wait, current);
-
-				/* go to sleep */
-				add_wait_queue(&channel_wqs[index].lx_queue, &wait);
+				int ret = 0;
 
-				set_current_state(TASK_INTERRUPTIBLE);
-				while (*p == NULL) {
-					schedule();
-
-					/* reset task state to interruptable otherwise
-					   we'll whizz round here like a very fast loopy
-					   thing. schedule() appears to return with state
-					   set to TASK_RUNNING.
-
-					   If the loaded SP program, for whatever reason,
-					   doesn't set up the shared structure *p will never
-					   become true. So whoever connected to either /dev/rt?
-					   or if it was kspd, will then take up rather a lot of
-					   processor cycles.
-					*/
-
-					set_current_state(TASK_INTERRUPTIBLE);
-				}
-
-				set_current_state(TASK_RUNNING);
-				remove_wait_queue(&channel_wqs[index].lx_queue, &wait);
-
-				/* back running */
-			}
-			else {
+				__wait_event_interruptible(channel_wqs[index].lx_queue,
+				                           *p != NULL,
+				                           ret);
+				if (ret)
+					goto out_fail;
+			} else {
 				printk(" *vpe_get_shared is NULL. "
 				       "Has an SP program been loaded?\n");
 				channel_wqs[index].in_open = 0;
-				return -ENOSYS;
+				ret = -ENOSYS;
+				goto out_fail;
 			}
 		}
 
@@ -231,10 +203,11 @@ int rtlx_open(int index, int can_sleep)
 			printk(KERN_WARNING "vpe_get_shared returned an invalid pointer "
 			       "maybe an error code %d\n", (int)*p);
  			channel_wqs[index].in_open = 0;
-			return -ENOSYS;
+			ret = -ENOSYS;
+			goto out_fail;
 		}
 
- 		if ((ret = rtlx_init(*p)) < 0) {
+		if ((ret = rtlx_init(*p)) < 0) {
  			channel_wqs[index].in_open = 0;
   			return ret;
  		}
@@ -250,6 +223,11 @@ int rtlx_open(int index, int can_sleep)
   	chan->lx_state = RTLX_STATE_OPENED;
  	channel_wqs[index].in_open = 0;
 	return 0;
+
+out_fail:
+	channel_wqs[index].in_open--;
+
+	return ret;
 }
 
 int rtlx_release(int index)
@@ -270,30 +248,17 @@ unsigned int rtlx_read_poll(int index, int can_sleep)
 	/* data available to read? */
 	if (chan->lx_read == chan->lx_write) {
 		if (can_sleep) {
-			DECLARE_WAITQUEUE(wait, current);
+			int ret = 0;
 
-			/* go to sleep */
-			add_wait_queue(&channel_wqs[index].lx_queue, &wait);
+			__wait_event_interruptible(channel_wqs[index].lx_queue,
+			                           chan->lx_read != chan->lx_write || sp_stopping,
+			                           ret);
+			if (ret)
+				return ret;
 
-			set_current_state(TASK_INTERRUPTIBLE);
-			while (chan->lx_read == chan->lx_write) {
-				schedule();
-
-				set_current_state(TASK_INTERRUPTIBLE);
-
-				if (sp_stopping) {
-					set_current_state(TASK_RUNNING);
-					remove_wait_queue(&channel_wqs[index].lx_queue, &wait);
-					return 0;
-				}
-			}
-
-			set_current_state(TASK_RUNNING);
-			remove_wait_queue(&channel_wqs[index].lx_queue, &wait);
-
-			/* back running */
-		}
-		else
+			if (sp_stopping)
+				return 0;
+		} else
 			return 0;
 	}
 
@@ -454,25 +419,22 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 {
 	int minor;
 	struct rtlx_channel *rt;
-	DECLARE_WAITQUEUE(wait, current);
 
 	minor = iminor(file->f_path.dentry->d_inode);
 	rt = &rtlx->channel[minor];
 
 	/* any space left... */
 	if (!rtlx_write_poll(minor)) {
+		int ret = 0;
 
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
 
-		add_wait_queue(&channel_wqs[minor].rt_queue, &wait);
-		set_current_state(TASK_INTERRUPTIBLE);
-
-		while (!rtlx_write_poll(minor))
-			schedule();
-
-		set_current_state(TASK_RUNNING);
-		remove_wait_queue(&channel_wqs[minor].rt_queue, &wait);
+		__wait_event_interruptible(channel_wqs[minor].rt_queue,
+		                           rtlx_write_poll(minor),
+		                           ret);
+		if (ret)
+			return ret;
 	}
 
 	return rtlx_write(minor, (void *)buffer, count, 1);

commit 5dfe4c964a0dd7bb3a1d64a4166835a153146207
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:31 2007 -0800

    [PATCH] mark struct file_operations const 2
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    [akpm@osdl.org: sparc64 fix]
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index f29e93c6ccfc..d92c48e0d7a6 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -478,7 +478,7 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 	return rtlx_write(minor, (void *)buffer, count, 1);
 }
 
-static struct file_operations rtlx_fops = {
+static const struct file_operations rtlx_fops = {
 	.owner =   THIS_MODULE,
 	.open =    file_open,
 	.release = file_release,

commit bb3d7c7ff1cc18b4cb83820327905f7e1f8dc414
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Feb 7 15:36:56 2007 +0000

    [MIPS] RTLX: Sprinkle device model code into code to make udev happier.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 8610f4a925e9..f29e93c6ccfc 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -17,6 +17,7 @@
  *
  */
 
+#include <linux/device.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <linux/fs.h>
@@ -34,6 +35,7 @@
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <asm/mipsmtregs.h>
+#include <asm/mips_mt.h>
 #include <asm/cacheflush.h>
 #include <asm/atomic.h>
 #include <asm/cpu.h>
@@ -498,7 +500,8 @@ static char register_chrdev_failed[] __initdata =
 
 static int rtlx_module_init(void)
 {
-	int i;
+	struct device *dev;
+	int i, err;
 
 	major = register_chrdev(0, module_name, &rtlx_fops);
 	if (major < 0) {
@@ -511,6 +514,13 @@ static int rtlx_module_init(void)
 		init_waitqueue_head(&channel_wqs[i].rt_queue);
 		init_waitqueue_head(&channel_wqs[i].lx_queue);
 		channel_wqs[i].in_open = 0;
+
+		dev = device_create(mt_class, NULL, MKDEV(major, i),
+		                    "%s%d", module_name, i);
+		if (IS_ERR(dev)) {
+			err = PTR_ERR(dev);
+			goto out_chrdev;
+		}
 	}
 
 	/* set up notifiers */
@@ -525,10 +535,21 @@ static int rtlx_module_init(void)
 	setup_irq(rtlx_irq_num, &rtlx_irq);
 
 	return 0;
+
+out_chrdev:
+	for (i = 0; i < RTLX_CHANNELS; i++)
+		device_destroy(mt_class, MKDEV(major, i));
+
+	return err;
 }
 
 static void __exit rtlx_module_exit(void)
 {
+	int i;
+
+	for (i = 0; i < RTLX_CHANNELS; i++)
+		device_destroy(mt_class, MKDEV(major, i));
+
 	unregister_chrdev(major, module_name);
 }
 

commit 97dcb82de6cc99a5669eb8e342efc24cceb1e77e
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Jan 8 02:14:29 2007 +0900

    [MIPS] Define MIPS_CPU_IRQ_BASE in generic header
    
    The irq_base for {mips,rm7k,rm9k}_cpu_irq_init() are constant on all
    platforms and are same value on most platforms (0 or 16, depends on
    CONFIG_I8259).  Define them in asm-mips/mach-generic/irq.h and make
    them customizable.  This will save a few cycle on each CPU interrupt.
    
    A good side effect is removing some dependencies to MALTA in generic
    SMTC code.
    
    Although MIPS_CPU_IRQ_BASE is customizable, this patch changes irq
    mappings on DDB5477, EMMA2RH and MIPS_SIM, since really customizing
    them might cause some header dependency problem and there seems no
    good reason to customize it.  So currently only VR41XX is using custom
    MIPS_CPU_IRQ_BASE value, which is 0 regardless of CONFIG_I8259.
    
    Testing this patch on those platforms is greatly appreciated.  Thank
    you.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 5a99e3e0c96d..8610f4a925e9 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -63,7 +63,7 @@ extern void *vpe_get_shared(int index);
 
 static void rtlx_dispatch(void)
 {
-	do_IRQ(MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ);
+	do_IRQ(MIPS_CPU_IRQ_BASE + MIPS_CPU_RTLX_IRQ);
 }
 
 
@@ -491,7 +491,7 @@ static struct irqaction rtlx_irq = {
 	.name		= "RTLX",
 };
 
-static int rtlx_irq_num = MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ;
+static int rtlx_irq_num = MIPS_CPU_IRQ_BASE + MIPS_CPU_RTLX_IRQ;
 
 static char register_chrdev_failed[] __initdata =
 	KERN_ERR "rtlx_module_init: unable to register device\n";

commit 1b04fe9a8ef10774174897b15d753b9de85fe9e9
Author: Josef Sipek <jsipek@fsl.cs.sunysb.edu>
Date:   Fri Dec 8 02:37:20 2006 -0800

    [PATCH] struct path: convert mips
    
    Signed-off-by: Josef Sipek <jsipek@fsl.cs.sunysb.edu>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 8c8c8324f775..5a99e3e0c96d 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -415,7 +415,7 @@ static unsigned int file_poll(struct file *file, poll_table * wait)
 	int minor;
 	unsigned int mask = 0;
 
-	minor = iminor(file->f_dentry->d_inode);
+	minor = iminor(file->f_path.dentry->d_inode);
 
 	poll_wait(file, &channel_wqs[minor].rt_queue, wait);
 	poll_wait(file, &channel_wqs[minor].lx_queue, wait);
@@ -437,7 +437,7 @@ static unsigned int file_poll(struct file *file, poll_table * wait)
 static ssize_t file_read(struct file *file, char __user * buffer, size_t count,
 			 loff_t * ppos)
 {
-	int minor = iminor(file->f_dentry->d_inode);
+	int minor = iminor(file->f_path.dentry->d_inode);
 
 	/* data available? */
 	if (!rtlx_read_poll(minor, (file->f_flags & O_NONBLOCK) ? 0 : 1)) {
@@ -454,7 +454,7 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 	struct rtlx_channel *rt;
 	DECLARE_WAITQUEUE(wait, current);
 
-	minor = iminor(file->f_dentry->d_inode);
+	minor = iminor(file->f_path.dentry->d_inode);
 	rt = &rtlx->channel[minor];
 
 	/* any space left... */

commit 937a801576f954bd030d7c4a5a94571710d87c0b
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sat Oct 7 19:44:33 2006 +0100

    [MIPS] Complete fixes after removal of pt_regs argument to int handlers.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index cdab1b2cd134..8c8c8324f775 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -61,16 +61,16 @@ static int sp_stopping = 0;
 
 extern void *vpe_get_shared(int index);
 
-static void rtlx_dispatch(struct pt_regs *regs)
+static void rtlx_dispatch(void)
 {
-	do_IRQ(MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ, regs);
+	do_IRQ(MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ);
 }
 
 
 /* Interrupt handler may be called before rtlx_init has otherwise had
    a chance to run.
 */
-static irqreturn_t rtlx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t rtlx_interrupt(int irq, void *dev_id)
 {
 	int i;
 

commit f40298fddcc3c8115c6135c9733f5a0de52dcea9
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:20 2006 -0700

    [PATCH] irq-flags: MIPS: Use the new IRQF_ constants
    
    Use the new IRQF_ constants and remove the SA_INTERRUPT define
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index caf777f83289..cdab1b2cd134 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -487,7 +487,7 @@ static struct file_operations rtlx_fops = {
 
 static struct irqaction rtlx_irq = {
 	.handler	= rtlx_interrupt,
-	.flags		= SA_INTERRUPT,
+	.flags		= IRQF_DISABLED,
 	.name		= "RTLX",
 };
 

commit 79e55bcf24ad8f31c3021b6ef21c4ce054fe4e38
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Apr 24 17:15:10 2006 +0100

    [MIPS] Cleanup inode->r_dev usage.
    
    imajor()/iminor() should be used instead of accessing r_dev directly.
    
    Based on patch from Eric Sesterhenn (snakebyte@gmx.de).
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 6179805af9f0..caf777f83289 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -398,15 +398,14 @@ ssize_t rtlx_write(int index, void *buffer, size_t count, int user)
 
 static int file_open(struct inode *inode, struct file *filp)
 {
-	int minor = MINOR(inode->i_rdev);
+	int minor = iminor(inode);
 
 	return rtlx_open(minor, (filp->f_flags & O_NONBLOCK) ? 0 : 1);
 }
 
 static int file_release(struct inode *inode, struct file *filp)
 {
-	int minor;
-	minor = MINOR(inode->i_rdev);
+	int minor = iminor(inode);
 
 	return rtlx_release(minor);
 }
@@ -416,7 +415,7 @@ static unsigned int file_poll(struct file *file, poll_table * wait)
 	int minor;
 	unsigned int mask = 0;
 
-	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	minor = iminor(file->f_dentry->d_inode);
 
 	poll_wait(file, &channel_wqs[minor].rt_queue, wait);
 	poll_wait(file, &channel_wqs[minor].lx_queue, wait);
@@ -438,7 +437,7 @@ static unsigned int file_poll(struct file *file, poll_table * wait)
 static ssize_t file_read(struct file *file, char __user * buffer, size_t count,
 			 loff_t * ppos)
 {
-	int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	int minor = iminor(file->f_dentry->d_inode);
 
 	/* data available? */
 	if (!rtlx_read_poll(minor, (file->f_flags & O_NONBLOCK) ? 0 : 1)) {
@@ -455,7 +454,7 @@ static ssize_t file_write(struct file *file, const char __user * buffer,
 	struct rtlx_channel *rt;
 	DECLARE_WAITQUEUE(wait, current);
 
-	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	minor = iminor(file->f_dentry->d_inode);
 	rt = &rtlx->channel[minor];
 
 	/* any space left... */

commit 2600990e640e3bef29ed89d565864cf16ee83833
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed Apr 5 09:45:45 2006 +0100

    [MIPS] kpsd and other AP/SP improvements.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 986a9cf23067..6179805af9f0 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -21,45 +21,44 @@
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/vmalloc.h>
+#include <linux/elf.h>
+#include <linux/seq_file.h>
+#include <linux/syscalls.h>
+#include <linux/moduleloader.h>
 #include <linux/interrupt.h>
-#include <linux/irq.h>
 #include <linux/poll.h>
 #include <linux/sched.h>
 #include <linux/wait.h>
-
 #include <asm/mipsmtregs.h>
-#include <asm/bitops.h>
+#include <asm/cacheflush.h>
+#include <asm/atomic.h>
 #include <asm/cpu.h>
 #include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/vpe.h>
 #include <asm/rtlx.h>
-#include <asm/uaccess.h>
 
 #define RTLX_TARG_VPE 1
 
 static struct rtlx_info *rtlx;
 static int major;
 static char module_name[] = "rtlx";
-static struct irqaction irq;
-static int irq_num;
-
-static inline int spacefree(int read, int write, int size)
-{
-	if (read == write) {
-		/*
-		 * never fill the buffer completely, so indexes are always
-		 * equal if empty and only empty, or !equal if data available
-		 */
-		return size - 1;
-	}
-
-	return ((read + size - write) % size) - 1;
-}
 
 static struct chan_waitqueues {
 	wait_queue_head_t rt_queue;
 	wait_queue_head_t lx_queue;
+	int in_open;
 } channel_wqs[RTLX_CHANNELS];
 
+static struct irqaction irq;
+static int irq_num;
+static struct vpe_notifications notify;
+static int sp_stopping = 0;
+
 extern void *vpe_get_shared(int index);
 
 static void rtlx_dispatch(struct pt_regs *regs)
@@ -67,174 +66,298 @@ static void rtlx_dispatch(struct pt_regs *regs)
 	do_IRQ(MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ, regs);
 }
 
+
+/* Interrupt handler may be called before rtlx_init has otherwise had
+   a chance to run.
+*/
 static irqreturn_t rtlx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
 	int i;
 
 	for (i = 0; i < RTLX_CHANNELS; i++) {
-		struct rtlx_channel *chan = &rtlx->channel[i];
-
-		if (chan->lx_read != chan->lx_write)
-			wake_up_interruptible(&channel_wqs[i].lx_queue);
+			wake_up(&channel_wqs[i].lx_queue);
+			wake_up(&channel_wqs[i].rt_queue);
 	}
 
 	return IRQ_HANDLED;
 }
 
-/* call when we have the address of the shared structure from the SP side. */
-static int rtlx_init(struct rtlx_info *rtlxi)
+static __attribute_used__ void dump_rtlx(void)
 {
 	int i;
 
-	if (rtlxi->id != RTLX_ID) {
-		printk(KERN_WARNING "no valid RTLX id at 0x%p\n", rtlxi);
-		return -ENOEXEC;
-	}
+	printk("id 0x%lx state %d\n", rtlx->id, rtlx->state);
 
-	/* initialise the wait queues */
 	for (i = 0; i < RTLX_CHANNELS; i++) {
-		init_waitqueue_head(&channel_wqs[i].rt_queue);
-		init_waitqueue_head(&channel_wqs[i].lx_queue);
-	}
+		struct rtlx_channel *chan = &rtlx->channel[i];
 
-	/* set up for interrupt handling */
-	memset(&irq, 0, sizeof(struct irqaction));
+		printk(" rt_state %d lx_state %d buffer_size %d\n",
+		       chan->rt_state, chan->lx_state, chan->buffer_size);
 
-	if (cpu_has_vint)
-		set_vi_handler(MIPS_CPU_RTLX_IRQ, rtlx_dispatch);
+		printk(" rt_read %d rt_write %d\n",
+		       chan->rt_read, chan->rt_write);
 
-	irq_num = MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ;
-	irq.handler = rtlx_interrupt;
-	irq.flags = SA_INTERRUPT;
-	irq.name = "RTLX";
-	irq.dev_id = rtlx;
-	setup_irq(irq_num, &irq);
+		printk(" lx_read %d lx_write %d\n",
+		       chan->lx_read, chan->lx_write);
+
+		printk(" rt_buffer <%s>\n", chan->rt_buffer);
+		printk(" lx_buffer <%s>\n", chan->lx_buffer);
+	}
+}
+
+/* call when we have the address of the shared structure from the SP side. */
+static int rtlx_init(struct rtlx_info *rtlxi)
+{
+	if (rtlxi->id != RTLX_ID) {
+		printk(KERN_ERR "no valid RTLX id at 0x%p 0x%x\n", rtlxi, rtlxi->id);
+		return -ENOEXEC;
+	}
 
 	rtlx = rtlxi;
 
 	return 0;
 }
 
-/* only allow one open process at a time to open each channel */
-static int rtlx_open(struct inode *inode, struct file *filp)
+/* notifications */
+static void starting(int vpe)
 {
-	int minor, ret;
+	int i;
+	sp_stopping = 0;
+
+	/* force a reload of rtlx */
+	rtlx=NULL;
+
+	/* wake up any sleeping rtlx_open's */
+	for (i = 0; i < RTLX_CHANNELS; i++)
+		wake_up_interruptible(&channel_wqs[i].lx_queue);
+}
+
+static void stopping(int vpe)
+{
+	int i;
+
+	sp_stopping = 1;
+	for (i = 0; i < RTLX_CHANNELS; i++)
+		wake_up_interruptible(&channel_wqs[i].lx_queue);
+}
+
+
+int rtlx_open(int index, int can_sleep)
+{
+	int ret;
 	struct rtlx_channel *chan;
+	volatile struct rtlx_info **p;
 
-	/* assume only 1 device at the mo. */
-	minor = MINOR(inode->i_rdev);
+	if (index >= RTLX_CHANNELS) {
+		printk(KERN_DEBUG "rtlx_open index out of range\n");
+		return -ENOSYS;
+	}
+
+	if (channel_wqs[index].in_open) {
+		printk(KERN_DEBUG "rtlx_open channel %d already opened\n", index);
+		return -EBUSY;
+	}
+
+	channel_wqs[index].in_open++;
 
 	if (rtlx == NULL) {
-		struct rtlx_info **p;
 		if( (p = vpe_get_shared(RTLX_TARG_VPE)) == NULL) {
-			printk(KERN_ERR "vpe_get_shared is NULL. "
-			       "Has an SP program been loaded?\n");
-			return -EFAULT;
+			if (can_sleep) {
+				DECLARE_WAITQUEUE(wait, current);
+
+				/* go to sleep */
+				add_wait_queue(&channel_wqs[index].lx_queue, &wait);
+
+				set_current_state(TASK_INTERRUPTIBLE);
+				while ((p = vpe_get_shared(RTLX_TARG_VPE)) == NULL) {
+					schedule();
+					set_current_state(TASK_INTERRUPTIBLE);
+				}
+
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue(&channel_wqs[index].lx_queue, &wait);
+
+				/* back running */
+			} else {
+				printk( KERN_DEBUG "No SP program loaded, and device "
+					"opened with O_NONBLOCK\n");
+				channel_wqs[index].in_open = 0;
+				return -ENOSYS;
+			}
 		}
 
 		if (*p == NULL) {
-			printk(KERN_ERR "vpe_shared %p %p\n", p, *p);
-			return -EFAULT;
+			if (can_sleep) {
+				DECLARE_WAITQUEUE(wait, current);
+
+				/* go to sleep */
+				add_wait_queue(&channel_wqs[index].lx_queue, &wait);
+
+				set_current_state(TASK_INTERRUPTIBLE);
+				while (*p == NULL) {
+					schedule();
+
+					/* reset task state to interruptable otherwise
+					   we'll whizz round here like a very fast loopy
+					   thing. schedule() appears to return with state
+					   set to TASK_RUNNING.
+
+					   If the loaded SP program, for whatever reason,
+					   doesn't set up the shared structure *p will never
+					   become true. So whoever connected to either /dev/rt?
+					   or if it was kspd, will then take up rather a lot of
+					   processor cycles.
+					*/
+
+					set_current_state(TASK_INTERRUPTIBLE);
+				}
+
+				set_current_state(TASK_RUNNING);
+				remove_wait_queue(&channel_wqs[index].lx_queue, &wait);
+
+				/* back running */
+			}
+			else {
+				printk(" *vpe_get_shared is NULL. "
+				       "Has an SP program been loaded?\n");
+				channel_wqs[index].in_open = 0;
+				return -ENOSYS;
+			}
+		}
+
+		if ((unsigned int)*p < KSEG0) {
+			printk(KERN_WARNING "vpe_get_shared returned an invalid pointer "
+			       "maybe an error code %d\n", (int)*p);
+ 			channel_wqs[index].in_open = 0;
+			return -ENOSYS;
 		}
 
-		if ((ret = rtlx_init(*p)) < 0)
-			return ret;
+ 		if ((ret = rtlx_init(*p)) < 0) {
+ 			channel_wqs[index].in_open = 0;
+  			return ret;
+ 		}
 	}
 
-	chan = &rtlx->channel[minor];
+	chan = &rtlx->channel[index];
 
-	if (test_and_set_bit(RTLX_STATE_OPENED, &chan->lx_state))
-		return -EBUSY;
+ 	if (chan->lx_state == RTLX_STATE_OPENED) {
+ 		channel_wqs[index].in_open = 0;
+  		return -EBUSY;
+ 	}
 
+  	chan->lx_state = RTLX_STATE_OPENED;
+ 	channel_wqs[index].in_open = 0;
 	return 0;
 }
 
-static int rtlx_release(struct inode *inode, struct file *filp)
+int rtlx_release(int index)
 {
-	int minor = MINOR(inode->i_rdev);
-
-	clear_bit(RTLX_STATE_OPENED, &rtlx->channel[minor].lx_state);
-	smp_mb__after_clear_bit();
-
+	rtlx->channel[index].lx_state = RTLX_STATE_UNUSED;
 	return 0;
 }
 
-static unsigned int rtlx_poll(struct file *file, poll_table * wait)
+unsigned int rtlx_read_poll(int index, int can_sleep)
 {
-	int minor;
-	unsigned int mask = 0;
-	struct rtlx_channel *chan;
+ 	struct rtlx_channel *chan;
 
-	minor = MINOR(file->f_dentry->d_inode->i_rdev);
-	chan = &rtlx->channel[minor];
+ 	if (rtlx == NULL)
+ 		return 0;
 
-	poll_wait(file, &channel_wqs[minor].rt_queue, wait);
-	poll_wait(file, &channel_wqs[minor].lx_queue, wait);
+ 	chan = &rtlx->channel[index];
 
 	/* data available to read? */
-	if (chan->lx_read != chan->lx_write)
-		mask |= POLLIN | POLLRDNORM;
+	if (chan->lx_read == chan->lx_write) {
+		if (can_sleep) {
+			DECLARE_WAITQUEUE(wait, current);
 
-	/* space to write */
-	if (spacefree(chan->rt_read, chan->rt_write, chan->buffer_size))
-		mask |= POLLOUT | POLLWRNORM;
+			/* go to sleep */
+			add_wait_queue(&channel_wqs[index].lx_queue, &wait);
 
-	return mask;
+			set_current_state(TASK_INTERRUPTIBLE);
+			while (chan->lx_read == chan->lx_write) {
+				schedule();
+
+				set_current_state(TASK_INTERRUPTIBLE);
+
+				if (sp_stopping) {
+					set_current_state(TASK_RUNNING);
+					remove_wait_queue(&channel_wqs[index].lx_queue, &wait);
+					return 0;
+				}
+			}
+
+			set_current_state(TASK_RUNNING);
+			remove_wait_queue(&channel_wqs[index].lx_queue, &wait);
+
+			/* back running */
+		}
+		else
+			return 0;
+	}
+
+	return (chan->lx_write + chan->buffer_size - chan->lx_read)
+	       % chan->buffer_size;
 }
 
-static ssize_t rtlx_read(struct file *file, char __user * buffer, size_t count,
-			 loff_t * ppos)
+static inline int write_spacefree(int read, int write, int size)
 {
-	unsigned long failed;
-	size_t fl = 0L;
-	int minor;
-	struct rtlx_channel *lx;
-	DECLARE_WAITQUEUE(wait, current);
+	if (read == write) {
+		/*
+		 * Never fill the buffer completely, so indexes are always
+		 * equal if empty and only empty, or !equal if data available
+		 */
+		return size - 1;
+	}
 
-	minor = MINOR(file->f_dentry->d_inode->i_rdev);
-	lx = &rtlx->channel[minor];
+	return ((read + size - write) % size) - 1;
+}
 
-	/* data available? */
-	if (lx->lx_write == lx->lx_read) {
-		if (file->f_flags & O_NONBLOCK)
-			return 0;	/* -EAGAIN makes cat whinge */
+unsigned int rtlx_write_poll(int index)
+{
+	struct rtlx_channel *chan = &rtlx->channel[index];
+	return write_spacefree(chan->rt_read, chan->rt_write, chan->buffer_size);
+}
 
-		/* go to sleep */
-		add_wait_queue(&channel_wqs[minor].lx_queue, &wait);
-		set_current_state(TASK_INTERRUPTIBLE);
+static inline void copy_to(void *dst, void *src, size_t count, int user)
+{
+	if (user)
+		copy_to_user(dst, src, count);
+	else
+		memcpy(dst, src, count);
+}
 
-		while (lx->lx_write == lx->lx_read)
-			schedule();
+static inline void copy_from(void *dst, void *src, size_t count, int user)
+{
+	if (user)
+		copy_from_user(dst, src, count);
+	else
+		memcpy(dst, src, count);
+}
 
-		set_current_state(TASK_RUNNING);
-		remove_wait_queue(&channel_wqs[minor].lx_queue, &wait);
+ssize_t rtlx_read(int index, void *buff, size_t count, int user)
+{
+	size_t fl = 0L;
+	struct rtlx_channel *lx;
 
-		/* back running */
-	}
+	if (rtlx == NULL)
+		return -ENOSYS;
+
+	lx = &rtlx->channel[index];
 
 	/* find out how much in total */
 	count = min(count,
-		    (size_t)(lx->lx_write + lx->buffer_size - lx->lx_read) % lx->buffer_size);
+		     (size_t)(lx->lx_write + lx->buffer_size - lx->lx_read)
+		     % lx->buffer_size);
 
 	/* then how much from the read pointer onwards */
-	fl = min(count, (size_t)lx->buffer_size - lx->lx_read);
+	fl = min( count, (size_t)lx->buffer_size - lx->lx_read);
 
-	failed = copy_to_user (buffer, &lx->lx_buffer[lx->lx_read], fl);
-	if (failed) {
-		count = fl - failed;
-		goto out;
-	}
+	copy_to(buff, &lx->lx_buffer[lx->lx_read], fl, user);
 
 	/* and if there is anything left at the beginning of the buffer */
-	if (count - fl) {
-		failed = copy_to_user (buffer + fl, lx->lx_buffer, count - fl);
-		if (failed) {
-			count -= failed;
-			goto out;
-		}
-	}
+	if ( count - fl )
+		copy_to (buff + fl, lx->lx_buffer, count - fl, user);
 
-out:
 	/* update the index */
 	lx->lx_read += count;
 	lx->lx_read %= lx->buffer_size;
@@ -242,20 +365,101 @@ static ssize_t rtlx_read(struct file *file, char __user * buffer, size_t count,
 	return count;
 }
 
-static ssize_t rtlx_write(struct file *file, const char __user * buffer,
+ssize_t rtlx_write(int index, void *buffer, size_t count, int user)
+{
+	struct rtlx_channel *rt;
+	size_t fl;
+
+	if (rtlx == NULL)
+		return(-ENOSYS);
+
+	rt = &rtlx->channel[index];
+
+	/* total number of bytes to copy */
+	count = min(count,
+		    (size_t)write_spacefree(rt->rt_read, rt->rt_write,
+					    rt->buffer_size));
+
+	/* first bit from write pointer to the end of the buffer, or count */
+	fl = min(count, (size_t) rt->buffer_size - rt->rt_write);
+
+	copy_from (&rt->rt_buffer[rt->rt_write], buffer, fl, user);
+
+	/* if there's any left copy to the beginning of the buffer */
+	if( count - fl )
+		copy_from (rt->rt_buffer, buffer + fl, count - fl, user);
+
+	rt->rt_write += count;
+	rt->rt_write %= rt->buffer_size;
+
+	return(count);
+}
+
+
+static int file_open(struct inode *inode, struct file *filp)
+{
+	int minor = MINOR(inode->i_rdev);
+
+	return rtlx_open(minor, (filp->f_flags & O_NONBLOCK) ? 0 : 1);
+}
+
+static int file_release(struct inode *inode, struct file *filp)
+{
+	int minor;
+	minor = MINOR(inode->i_rdev);
+
+	return rtlx_release(minor);
+}
+
+static unsigned int file_poll(struct file *file, poll_table * wait)
+{
+	int minor;
+	unsigned int mask = 0;
+
+	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+
+	poll_wait(file, &channel_wqs[minor].rt_queue, wait);
+	poll_wait(file, &channel_wqs[minor].lx_queue, wait);
+
+	if (rtlx == NULL)
+		return 0;
+
+	/* data available to read? */
+	if (rtlx_read_poll(minor, 0))
+		mask |= POLLIN | POLLRDNORM;
+
+	/* space to write */
+	if (rtlx_write_poll(minor))
+		mask |= POLLOUT | POLLWRNORM;
+
+	return mask;
+}
+
+static ssize_t file_read(struct file *file, char __user * buffer, size_t count,
+			 loff_t * ppos)
+{
+	int minor = MINOR(file->f_dentry->d_inode->i_rdev);
+
+	/* data available? */
+	if (!rtlx_read_poll(minor, (file->f_flags & O_NONBLOCK) ? 0 : 1)) {
+		return 0;	// -EAGAIN makes cat whinge
+	}
+
+	return rtlx_read(minor, buffer, count, 1);
+}
+
+static ssize_t file_write(struct file *file, const char __user * buffer,
 			  size_t count, loff_t * ppos)
 {
-	unsigned long failed;
 	int minor;
 	struct rtlx_channel *rt;
-	size_t fl;
 	DECLARE_WAITQUEUE(wait, current);
 
 	minor = MINOR(file->f_dentry->d_inode->i_rdev);
 	rt = &rtlx->channel[minor];
 
 	/* any space left... */
-	if (!spacefree(rt->rt_read, rt->rt_write, rt->buffer_size)) {
+	if (!rtlx_write_poll(minor)) {
 
 		if (file->f_flags & O_NONBLOCK)
 			return -EAGAIN;
@@ -263,61 +467,64 @@ static ssize_t rtlx_write(struct file *file, const char __user * buffer,
 		add_wait_queue(&channel_wqs[minor].rt_queue, &wait);
 		set_current_state(TASK_INTERRUPTIBLE);
 
-		while (!spacefree(rt->rt_read, rt->rt_write, rt->buffer_size))
+		while (!rtlx_write_poll(minor))
 			schedule();
 
 		set_current_state(TASK_RUNNING);
 		remove_wait_queue(&channel_wqs[minor].rt_queue, &wait);
 	}
 
-	/* total number of bytes to copy */
-	count = min(count, (size_t)spacefree(rt->rt_read, rt->rt_write, rt->buffer_size) );
-
-	/* first bit from write pointer to the end of the buffer, or count */
-	fl = min(count, (size_t) rt->buffer_size - rt->rt_write);
-
-	failed = copy_from_user(&rt->rt_buffer[rt->rt_write], buffer, fl);
-	if (failed) {
-		count = fl - failed;
-		goto out;
-	}
-
-	/* if there's any left copy to the beginning of the buffer */
-	if (count - fl) {
-		failed = copy_from_user(rt->rt_buffer, buffer + fl, count - fl);
-		if (failed) {
-			count -= failed;
-			goto out;
-		}
-	}
-
-out:
-	rt->rt_write += count;
-	rt->rt_write %= rt->buffer_size;
-
-	return count;
+	return rtlx_write(minor, (void *)buffer, count, 1);
 }
 
 static struct file_operations rtlx_fops = {
-	.owner		= THIS_MODULE,
-	.open		= rtlx_open,
-	.release	= rtlx_release,
-	.write		= rtlx_write,
-	.read		= rtlx_read,
-	.poll		= rtlx_poll
+	.owner =   THIS_MODULE,
+	.open =    file_open,
+	.release = file_release,
+	.write =   file_write,
+	.read =    file_read,
+	.poll =    file_poll
 };
 
+static struct irqaction rtlx_irq = {
+	.handler	= rtlx_interrupt,
+	.flags		= SA_INTERRUPT,
+	.name		= "RTLX",
+};
+
+static int rtlx_irq_num = MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ;
+
 static char register_chrdev_failed[] __initdata =
 	KERN_ERR "rtlx_module_init: unable to register device\n";
 
-static int __init rtlx_module_init(void)
+static int rtlx_module_init(void)
 {
+	int i;
+
 	major = register_chrdev(0, module_name, &rtlx_fops);
 	if (major < 0) {
 		printk(register_chrdev_failed);
 		return major;
 	}
 
+	/* initialise the wait queues */
+	for (i = 0; i < RTLX_CHANNELS; i++) {
+		init_waitqueue_head(&channel_wqs[i].rt_queue);
+		init_waitqueue_head(&channel_wqs[i].lx_queue);
+		channel_wqs[i].in_open = 0;
+	}
+
+	/* set up notifiers */
+	notify.start = starting;
+	notify.stop = stopping;
+	vpe_notify(RTLX_TARG_VPE, &notify);
+
+	if (cpu_has_vint)
+		set_vi_handler(MIPS_CPU_RTLX_IRQ, rtlx_dispatch);
+
+	rtlx_irq.dev_id = rtlx;
+	setup_irq(rtlx_irq_num, &rtlx_irq);
+
 	return 0;
 }
 
@@ -330,5 +537,5 @@ module_init(rtlx_module_init);
 module_exit(rtlx_module_exit);
 
 MODULE_DESCRIPTION("MIPS RTLX");
-MODULE_AUTHOR("Elizabeth Clarke, MIPS Technologies, Inc.");
+MODULE_AUTHOR("Elizabeth Oldham, MIPS Technologies, Inc.");
 MODULE_LICENSE("GPL");

commit a84c96e202c286c1d56fed4a81bd850017aa2c64
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sun Jan 15 18:11:28 2006 +0000

    [MIPS] RTLX compile fixes.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 1d855112bac2..986a9cf23067 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2005 MIPS Technologies, Inc.  All rights reserved.
+ * Copyright (C) 2005, 06 Ralf Baechle (ralf@linux-mips.org)
  *
  *  This program is free software; you can distribute it and/or modify it
  *  under the terms of the GNU General Public License (Version 2) as
@@ -20,9 +21,12 @@
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
 #include <linux/poll.h>
 #include <linux/sched.h>
 #include <linux/wait.h>
+
 #include <asm/mipsmtregs.h>
 #include <asm/bitops.h>
 #include <asm/cpu.h>

commit afc4841d8a0118fcce9fd520b21ec1da401603a3
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Oct 31 00:30:39 2005 +0000

    Turn rtlx upside down.
    
     o Coding style
     o Race condition on open
     o Switch to dynamic major
     o Header file cleanup
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
index 8c81f3cb4e2d..1d855112bac2 100644
--- a/arch/mips/kernel/rtlx.c
+++ b/arch/mips/kernel/rtlx.c
@@ -20,42 +20,42 @@
 #include <linux/module.h>
 #include <linux/fs.h>
 #include <linux/init.h>
-#include <asm/uaccess.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/vmalloc.h>
-#include <linux/elf.h>
-#include <linux/seq_file.h>
-#include <linux/syscalls.h>
-#include <linux/moduleloader.h>
-#include <linux/interrupt.h>
 #include <linux/poll.h>
 #include <linux/sched.h>
 #include <linux/wait.h>
 #include <asm/mipsmtregs.h>
-#include <asm/cacheflush.h>
-#include <asm/atomic.h>
+#include <asm/bitops.h>
 #include <asm/cpu.h>
 #include <asm/processor.h>
-#include <asm/system.h>
 #include <asm/rtlx.h>
+#include <asm/uaccess.h>
 
-#define RTLX_MAJOR 64
 #define RTLX_TARG_VPE 1
 
-struct rtlx_info *rtlx;
+static struct rtlx_info *rtlx;
 static int major;
 static char module_name[] = "rtlx";
-static inline int spacefree(int read, int write, int size);
+static struct irqaction irq;
+static int irq_num;
+
+static inline int spacefree(int read, int write, int size)
+{
+	if (read == write) {
+		/*
+		 * never fill the buffer completely, so indexes are always
+		 * equal if empty and only empty, or !equal if data available
+		 */
+		return size - 1;
+	}
+
+	return ((read + size - write) % size) - 1;
+}
 
 static struct chan_waitqueues {
 	wait_queue_head_t rt_queue;
 	wait_queue_head_t lx_queue;
 } channel_wqs[RTLX_CHANNELS];
 
-static struct irqaction irq;
-static int irq_num;
-
 extern void *vpe_get_shared(int index);
 
 static void rtlx_dispatch(struct pt_regs *regs)
@@ -63,9 +63,8 @@ static void rtlx_dispatch(struct pt_regs *regs)
 	do_IRQ(MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ, regs);
 }
 
-irqreturn_t rtlx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t rtlx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 {
-	irqreturn_t r = IRQ_HANDLED;
 	int i;
 
 	for (i = 0; i < RTLX_CHANNELS; i++) {
@@ -75,30 +74,7 @@ irqreturn_t rtlx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
 			wake_up_interruptible(&channel_wqs[i].lx_queue);
 	}
 
-	return r;
-}
-
-void dump_rtlx(void)
-{
-	int i;
-
-	printk("id 0x%lx state %d\n", rtlx->id, rtlx->state);
-
-	for (i = 0; i < RTLX_CHANNELS; i++) {
-		struct rtlx_channel *chan = &rtlx->channel[i];
-
-		printk(" rt_state %d lx_state %d buffer_size %d\n",
-		       chan->rt_state, chan->lx_state, chan->buffer_size);
-
-		printk(" rt_read %d rt_write %d\n",
-		       chan->rt_read, chan->rt_write);
-
-		printk(" lx_read %d lx_write %d\n",
-		       chan->lx_read, chan->lx_write);
-
-		printk(" rt_buffer <%s>\n", chan->rt_buffer);
-		printk(" lx_buffer <%s>\n", chan->lx_buffer);
-	}
+	return IRQ_HANDLED;
 }
 
 /* call when we have the address of the shared structure from the SP side. */
@@ -108,7 +84,7 @@ static int rtlx_init(struct rtlx_info *rtlxi)
 
 	if (rtlxi->id != RTLX_ID) {
 		printk(KERN_WARNING "no valid RTLX id at 0x%p\n", rtlxi);
-		return (-ENOEXEC);
+		return -ENOEXEC;
 	}
 
 	/* initialise the wait queues */
@@ -120,9 +96,8 @@ static int rtlx_init(struct rtlx_info *rtlxi)
 	/* set up for interrupt handling */
 	memset(&irq, 0, sizeof(struct irqaction));
 
-	if (cpu_has_vint) {
+	if (cpu_has_vint)
 		set_vi_handler(MIPS_CPU_RTLX_IRQ, rtlx_dispatch);
-	}
 
 	irq_num = MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ;
 	irq.handler = rtlx_interrupt;
@@ -132,7 +107,8 @@ static int rtlx_init(struct rtlx_info *rtlxi)
 	setup_irq(irq_num, &irq);
 
 	rtlx = rtlxi;
-	return (0);
+
+	return 0;
 }
 
 /* only allow one open process at a time to open each channel */
@@ -147,36 +123,36 @@ static int rtlx_open(struct inode *inode, struct file *filp)
 	if (rtlx == NULL) {
 		struct rtlx_info **p;
 		if( (p = vpe_get_shared(RTLX_TARG_VPE)) == NULL) {
-			printk(" vpe_get_shared is NULL. Has an SP program been loaded?\n");
-			return (-EFAULT);
+			printk(KERN_ERR "vpe_get_shared is NULL. "
+			       "Has an SP program been loaded?\n");
+			return -EFAULT;
 		}
 
 		if (*p == NULL) {
-			printk(" vpe_shared %p %p\n", p, *p);
-			return (-EFAULT);
+			printk(KERN_ERR "vpe_shared %p %p\n", p, *p);
+			return -EFAULT;
 		}
 
 		if ((ret = rtlx_init(*p)) < 0)
-			return (ret);
+			return ret;
 	}
 
 	chan = &rtlx->channel[minor];
 
-	/* already open? */
-	if (chan->lx_state == RTLX_STATE_OPENED)
-		return (-EBUSY);
+	if (test_and_set_bit(RTLX_STATE_OPENED, &chan->lx_state))
+		return -EBUSY;
 
-	chan->lx_state = RTLX_STATE_OPENED;
-	return (0);
+	return 0;
 }
 
 static int rtlx_release(struct inode *inode, struct file *filp)
 {
-	int minor;
+	int minor = MINOR(inode->i_rdev);
 
-	minor = MINOR(inode->i_rdev);
-	rtlx->channel[minor].lx_state = RTLX_STATE_UNUSED;
-	return (0);
+	clear_bit(RTLX_STATE_OPENED, &rtlx->channel[minor].lx_state);
+	smp_mb__after_clear_bit();
+
+	return 0;
 }
 
 static unsigned int rtlx_poll(struct file *file, poll_table * wait)
@@ -199,12 +175,13 @@ static unsigned int rtlx_poll(struct file *file, poll_table * wait)
 	if (spacefree(chan->rt_read, chan->rt_write, chan->buffer_size))
 		mask |= POLLOUT | POLLWRNORM;
 
-	return (mask);
+	return mask;
 }
 
 static ssize_t rtlx_read(struct file *file, char __user * buffer, size_t count,
 			 loff_t * ppos)
 {
+	unsigned long failed;
 	size_t fl = 0L;
 	int minor;
 	struct rtlx_channel *lx;
@@ -216,7 +193,7 @@ static ssize_t rtlx_read(struct file *file, char __user * buffer, size_t count,
 	/* data available? */
 	if (lx->lx_write == lx->lx_read) {
 		if (file->f_flags & O_NONBLOCK)
-			return (0);	// -EAGAIN makes cat whinge
+			return 0;	/* -EAGAIN makes cat whinge */
 
 		/* go to sleep */
 		add_wait_queue(&channel_wqs[minor].lx_queue, &wait);
@@ -232,39 +209,39 @@ static ssize_t rtlx_read(struct file *file, char __user * buffer, size_t count,
 	}
 
 	/* find out how much in total */
-	count = min( count,
-		     (size_t)(lx->lx_write + lx->buffer_size - lx->lx_read) % lx->buffer_size);
+	count = min(count,
+		    (size_t)(lx->lx_write + lx->buffer_size - lx->lx_read) % lx->buffer_size);
 
 	/* then how much from the read pointer onwards */
-	fl = min( count, (size_t)lx->buffer_size - lx->lx_read);
+	fl = min(count, (size_t)lx->buffer_size - lx->lx_read);
 
-	copy_to_user (buffer, &lx->lx_buffer[lx->lx_read], fl);
+	failed = copy_to_user (buffer, &lx->lx_buffer[lx->lx_read], fl);
+	if (failed) {
+		count = fl - failed;
+		goto out;
+	}
 
 	/* and if there is anything left at the beginning of the buffer */
-	if ( count - fl )
-		copy_to_user (buffer + fl, lx->lx_buffer, count - fl);
+	if (count - fl) {
+		failed = copy_to_user (buffer + fl, lx->lx_buffer, count - fl);
+		if (failed) {
+			count -= failed;
+			goto out;
+		}
+	}
 
+out:
 	/* update the index */
 	lx->lx_read += count;
 	lx->lx_read %= lx->buffer_size;
 
-	return (count);
-}
-
-static inline int spacefree(int read, int write, int size)
-{
-	if (read == write) {
-		/* never fill the buffer completely, so indexes are always equal if empty
-		   and only empty, or !equal if data available */
-		return (size - 1);
-	}
-
-	return ((read + size - write) % size) - 1;
+	return count;
 }
 
 static ssize_t rtlx_write(struct file *file, const char __user * buffer,
 			  size_t count, loff_t * ppos)
 {
+	unsigned long failed;
 	int minor;
 	struct rtlx_channel *rt;
 	size_t fl;
@@ -277,7 +254,7 @@ static ssize_t rtlx_write(struct file *file, const char __user * buffer,
 	if (!spacefree(rt->rt_read, rt->rt_write, rt->buffer_size)) {
 
 		if (file->f_flags & O_NONBLOCK)
-			return (-EAGAIN);
+			return -EAGAIN;
 
 		add_wait_queue(&channel_wqs[minor].rt_queue, &wait);
 		set_current_state(TASK_INTERRUPTIBLE);
@@ -290,52 +267,64 @@ static ssize_t rtlx_write(struct file *file, const char __user * buffer,
 	}
 
 	/* total number of bytes to copy */
-	count = min( count, (size_t)spacefree(rt->rt_read, rt->rt_write, rt->buffer_size) );
+	count = min(count, (size_t)spacefree(rt->rt_read, rt->rt_write, rt->buffer_size) );
 
 	/* first bit from write pointer to the end of the buffer, or count */
 	fl = min(count, (size_t) rt->buffer_size - rt->rt_write);
 
-	copy_from_user(&rt->rt_buffer[rt->rt_write], buffer, fl);
+	failed = copy_from_user(&rt->rt_buffer[rt->rt_write], buffer, fl);
+	if (failed) {
+		count = fl - failed;
+		goto out;
+	}
 
 	/* if there's any left copy to the beginning of the buffer */
-	if( count - fl )
-		copy_from_user(rt->rt_buffer, buffer + fl, count - fl);
+	if (count - fl) {
+		failed = copy_from_user(rt->rt_buffer, buffer + fl, count - fl);
+		if (failed) {
+			count -= failed;
+			goto out;
+		}
+	}
 
+out:
 	rt->rt_write += count;
 	rt->rt_write %= rt->buffer_size;
 
-	return(count);
+	return count;
 }
 
 static struct file_operations rtlx_fops = {
-	.owner = THIS_MODULE,
-	.open = rtlx_open,
-	.release = rtlx_release,
-	.write = rtlx_write,
-	.read = rtlx_read,
-	.poll = rtlx_poll
+	.owner		= THIS_MODULE,
+	.open		= rtlx_open,
+	.release	= rtlx_release,
+	.write		= rtlx_write,
+	.read		= rtlx_read,
+	.poll		= rtlx_poll
 };
 
-static int rtlx_module_init(void)
+static char register_chrdev_failed[] __initdata =
+	KERN_ERR "rtlx_module_init: unable to register device\n";
+
+static int __init rtlx_module_init(void)
 {
-	if ((major = register_chrdev(RTLX_MAJOR, module_name, &rtlx_fops)) < 0) {
-		printk("rtlx_module_init: unable to register device\n");
-		return (-EBUSY);
+	major = register_chrdev(0, module_name, &rtlx_fops);
+	if (major < 0) {
+		printk(register_chrdev_failed);
+		return major;
 	}
 
-	if (major == 0)
-		major = RTLX_MAJOR;
-
-	return (0);
+	return 0;
 }
 
-static void rtlx_module_exit(void)
+static void __exit rtlx_module_exit(void)
 {
 	unregister_chrdev(major, module_name);
 }
 
 module_init(rtlx_module_init);
 module_exit(rtlx_module_exit);
+
 MODULE_DESCRIPTION("MIPS RTLX");
-MODULE_AUTHOR("Elizabeth Clarke, MIPS Technologies, Inc");
+MODULE_AUTHOR("Elizabeth Clarke, MIPS Technologies, Inc.");
 MODULE_LICENSE("GPL");

commit e01402b115cccb6357f956649487aca2c6f7fbba
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Jul 14 15:57:16 2005 +0000

    More AP / SP bits for the 34K, the Malta bits and things.  Still wants
    a little polishing.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/rtlx.c b/arch/mips/kernel/rtlx.c
new file mode 100644
index 000000000000..8c81f3cb4e2d
--- /dev/null
+++ b/arch/mips/kernel/rtlx.c
@@ -0,0 +1,341 @@
+/*
+ * Copyright (C) 2005 MIPS Technologies, Inc.  All rights reserved.
+ *
+ *  This program is free software; you can distribute it and/or modify it
+ *  under the terms of the GNU General Public License (Version 2) as
+ *  published by the Free Software Foundation.
+ *
+ *  This program is distributed in the hope it will be useful, but WITHOUT
+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ *  for more details.
+ *
+ *  You should have received a copy of the GNU General Public License along
+ *  with this program; if not, write to the Free Software Foundation, Inc.,
+ *  59 Temple Place - Suite 330, Boston MA 02111-1307, USA.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <asm/uaccess.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/vmalloc.h>
+#include <linux/elf.h>
+#include <linux/seq_file.h>
+#include <linux/syscalls.h>
+#include <linux/moduleloader.h>
+#include <linux/interrupt.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <asm/mipsmtregs.h>
+#include <asm/cacheflush.h>
+#include <asm/atomic.h>
+#include <asm/cpu.h>
+#include <asm/processor.h>
+#include <asm/system.h>
+#include <asm/rtlx.h>
+
+#define RTLX_MAJOR 64
+#define RTLX_TARG_VPE 1
+
+struct rtlx_info *rtlx;
+static int major;
+static char module_name[] = "rtlx";
+static inline int spacefree(int read, int write, int size);
+
+static struct chan_waitqueues {
+	wait_queue_head_t rt_queue;
+	wait_queue_head_t lx_queue;
+} channel_wqs[RTLX_CHANNELS];
+
+static struct irqaction irq;
+static int irq_num;
+
+extern void *vpe_get_shared(int index);
+
+static void rtlx_dispatch(struct pt_regs *regs)
+{
+	do_IRQ(MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ, regs);
+}
+
+irqreturn_t rtlx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	irqreturn_t r = IRQ_HANDLED;
+	int i;
+
+	for (i = 0; i < RTLX_CHANNELS; i++) {
+		struct rtlx_channel *chan = &rtlx->channel[i];
+
+		if (chan->lx_read != chan->lx_write)
+			wake_up_interruptible(&channel_wqs[i].lx_queue);
+	}
+
+	return r;
+}
+
+void dump_rtlx(void)
+{
+	int i;
+
+	printk("id 0x%lx state %d\n", rtlx->id, rtlx->state);
+
+	for (i = 0; i < RTLX_CHANNELS; i++) {
+		struct rtlx_channel *chan = &rtlx->channel[i];
+
+		printk(" rt_state %d lx_state %d buffer_size %d\n",
+		       chan->rt_state, chan->lx_state, chan->buffer_size);
+
+		printk(" rt_read %d rt_write %d\n",
+		       chan->rt_read, chan->rt_write);
+
+		printk(" lx_read %d lx_write %d\n",
+		       chan->lx_read, chan->lx_write);
+
+		printk(" rt_buffer <%s>\n", chan->rt_buffer);
+		printk(" lx_buffer <%s>\n", chan->lx_buffer);
+	}
+}
+
+/* call when we have the address of the shared structure from the SP side. */
+static int rtlx_init(struct rtlx_info *rtlxi)
+{
+	int i;
+
+	if (rtlxi->id != RTLX_ID) {
+		printk(KERN_WARNING "no valid RTLX id at 0x%p\n", rtlxi);
+		return (-ENOEXEC);
+	}
+
+	/* initialise the wait queues */
+	for (i = 0; i < RTLX_CHANNELS; i++) {
+		init_waitqueue_head(&channel_wqs[i].rt_queue);
+		init_waitqueue_head(&channel_wqs[i].lx_queue);
+	}
+
+	/* set up for interrupt handling */
+	memset(&irq, 0, sizeof(struct irqaction));
+
+	if (cpu_has_vint) {
+		set_vi_handler(MIPS_CPU_RTLX_IRQ, rtlx_dispatch);
+	}
+
+	irq_num = MIPSCPU_INT_BASE + MIPS_CPU_RTLX_IRQ;
+	irq.handler = rtlx_interrupt;
+	irq.flags = SA_INTERRUPT;
+	irq.name = "RTLX";
+	irq.dev_id = rtlx;
+	setup_irq(irq_num, &irq);
+
+	rtlx = rtlxi;
+	return (0);
+}
+
+/* only allow one open process at a time to open each channel */
+static int rtlx_open(struct inode *inode, struct file *filp)
+{
+	int minor, ret;
+	struct rtlx_channel *chan;
+
+	/* assume only 1 device at the mo. */
+	minor = MINOR(inode->i_rdev);
+
+	if (rtlx == NULL) {
+		struct rtlx_info **p;
+		if( (p = vpe_get_shared(RTLX_TARG_VPE)) == NULL) {
+			printk(" vpe_get_shared is NULL. Has an SP program been loaded?\n");
+			return (-EFAULT);
+		}
+
+		if (*p == NULL) {
+			printk(" vpe_shared %p %p\n", p, *p);
+			return (-EFAULT);
+		}
+
+		if ((ret = rtlx_init(*p)) < 0)
+			return (ret);
+	}
+
+	chan = &rtlx->channel[minor];
+
+	/* already open? */
+	if (chan->lx_state == RTLX_STATE_OPENED)
+		return (-EBUSY);
+
+	chan->lx_state = RTLX_STATE_OPENED;
+	return (0);
+}
+
+static int rtlx_release(struct inode *inode, struct file *filp)
+{
+	int minor;
+
+	minor = MINOR(inode->i_rdev);
+	rtlx->channel[minor].lx_state = RTLX_STATE_UNUSED;
+	return (0);
+}
+
+static unsigned int rtlx_poll(struct file *file, poll_table * wait)
+{
+	int minor;
+	unsigned int mask = 0;
+	struct rtlx_channel *chan;
+
+	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	chan = &rtlx->channel[minor];
+
+	poll_wait(file, &channel_wqs[minor].rt_queue, wait);
+	poll_wait(file, &channel_wqs[minor].lx_queue, wait);
+
+	/* data available to read? */
+	if (chan->lx_read != chan->lx_write)
+		mask |= POLLIN | POLLRDNORM;
+
+	/* space to write */
+	if (spacefree(chan->rt_read, chan->rt_write, chan->buffer_size))
+		mask |= POLLOUT | POLLWRNORM;
+
+	return (mask);
+}
+
+static ssize_t rtlx_read(struct file *file, char __user * buffer, size_t count,
+			 loff_t * ppos)
+{
+	size_t fl = 0L;
+	int minor;
+	struct rtlx_channel *lx;
+	DECLARE_WAITQUEUE(wait, current);
+
+	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	lx = &rtlx->channel[minor];
+
+	/* data available? */
+	if (lx->lx_write == lx->lx_read) {
+		if (file->f_flags & O_NONBLOCK)
+			return (0);	// -EAGAIN makes cat whinge
+
+		/* go to sleep */
+		add_wait_queue(&channel_wqs[minor].lx_queue, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		while (lx->lx_write == lx->lx_read)
+			schedule();
+
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&channel_wqs[minor].lx_queue, &wait);
+
+		/* back running */
+	}
+
+	/* find out how much in total */
+	count = min( count,
+		     (size_t)(lx->lx_write + lx->buffer_size - lx->lx_read) % lx->buffer_size);
+
+	/* then how much from the read pointer onwards */
+	fl = min( count, (size_t)lx->buffer_size - lx->lx_read);
+
+	copy_to_user (buffer, &lx->lx_buffer[lx->lx_read], fl);
+
+	/* and if there is anything left at the beginning of the buffer */
+	if ( count - fl )
+		copy_to_user (buffer + fl, lx->lx_buffer, count - fl);
+
+	/* update the index */
+	lx->lx_read += count;
+	lx->lx_read %= lx->buffer_size;
+
+	return (count);
+}
+
+static inline int spacefree(int read, int write, int size)
+{
+	if (read == write) {
+		/* never fill the buffer completely, so indexes are always equal if empty
+		   and only empty, or !equal if data available */
+		return (size - 1);
+	}
+
+	return ((read + size - write) % size) - 1;
+}
+
+static ssize_t rtlx_write(struct file *file, const char __user * buffer,
+			  size_t count, loff_t * ppos)
+{
+	int minor;
+	struct rtlx_channel *rt;
+	size_t fl;
+	DECLARE_WAITQUEUE(wait, current);
+
+	minor = MINOR(file->f_dentry->d_inode->i_rdev);
+	rt = &rtlx->channel[minor];
+
+	/* any space left... */
+	if (!spacefree(rt->rt_read, rt->rt_write, rt->buffer_size)) {
+
+		if (file->f_flags & O_NONBLOCK)
+			return (-EAGAIN);
+
+		add_wait_queue(&channel_wqs[minor].rt_queue, &wait);
+		set_current_state(TASK_INTERRUPTIBLE);
+
+		while (!spacefree(rt->rt_read, rt->rt_write, rt->buffer_size))
+			schedule();
+
+		set_current_state(TASK_RUNNING);
+		remove_wait_queue(&channel_wqs[minor].rt_queue, &wait);
+	}
+
+	/* total number of bytes to copy */
+	count = min( count, (size_t)spacefree(rt->rt_read, rt->rt_write, rt->buffer_size) );
+
+	/* first bit from write pointer to the end of the buffer, or count */
+	fl = min(count, (size_t) rt->buffer_size - rt->rt_write);
+
+	copy_from_user(&rt->rt_buffer[rt->rt_write], buffer, fl);
+
+	/* if there's any left copy to the beginning of the buffer */
+	if( count - fl )
+		copy_from_user(rt->rt_buffer, buffer + fl, count - fl);
+
+	rt->rt_write += count;
+	rt->rt_write %= rt->buffer_size;
+
+	return(count);
+}
+
+static struct file_operations rtlx_fops = {
+	.owner = THIS_MODULE,
+	.open = rtlx_open,
+	.release = rtlx_release,
+	.write = rtlx_write,
+	.read = rtlx_read,
+	.poll = rtlx_poll
+};
+
+static int rtlx_module_init(void)
+{
+	if ((major = register_chrdev(RTLX_MAJOR, module_name, &rtlx_fops)) < 0) {
+		printk("rtlx_module_init: unable to register device\n");
+		return (-EBUSY);
+	}
+
+	if (major == 0)
+		major = RTLX_MAJOR;
+
+	return (0);
+}
+
+static void rtlx_module_exit(void)
+{
+	unregister_chrdev(major, module_name);
+}
+
+module_init(rtlx_module_init);
+module_exit(rtlx_module_exit);
+MODULE_DESCRIPTION("MIPS RTLX");
+MODULE_AUTHOR("Elizabeth Clarke, MIPS Technologies, Inc");
+MODULE_LICENSE("GPL");
