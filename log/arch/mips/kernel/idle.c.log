commit c9b0299034665d594e56ee343f28033d1b24de6d
Author: Liangliang Huang <huanglllzu@gmail.com>
Date:   Mon May 4 16:51:29 2020 +0800

    MIPS: Use fallthrough for arch/mips
    
    Convert the various /* fallthrough */ comments to the pseudo-keyword
    fallthrough;
    
    Done via script:
    https://lore.kernel.org/lkml/b56602fcf79f849e733e7b521bb0e17895d390fa.1582230379.git.joe@perches.com/
    
    Signed-off-by: Liangliang Huang <huangll@lemote.com>
    Reviewed-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 60d8c2a380fe..5bc3b04693c7 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -202,7 +202,7 @@ void __init check_wait(void)
 		 */
 		if (IS_ENABLED(CONFIG_MIPS_EJTAG_FDC_TTY))
 			break;
-		/* fall through */
+		fallthrough;
 	case CPU_M14KC:
 	case CPU_M14KEC:
 	case CPU_24K:

commit 0cf2ea1121aa14f6873ed2907a3e27b62c87fcbe
Author: Jiaxun Yang <jiaxun.yang@flygoat.com>
Date:   Wed Apr 22 22:43:44 2020 +0800

    MIPS: Kernel: Identify Loongson-2K processors
    
    Loongson-2K (Loongson64 Reduced) is a family of SoC shipped with
    gs264e core.
    
    Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 37f8e78e2869..60d8c2a380fe 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -180,7 +180,8 @@ void __init check_wait(void)
 		break;
 	case CPU_LOONGSON64:
 		if ((c->processor_id & (PRID_IMP_MASK | PRID_REV_MASK)) >=
-				(PRID_IMP_LOONGSON_64C | PRID_REV_LOONGSON3A_R2_0))
+				(PRID_IMP_LOONGSON_64C | PRID_REV_LOONGSON3A_R2_0) ||
+				(c->processor_id & PRID_IMP_MASK) == PRID_IMP_LOONGSON_64R)
 			cpu_wait = r4k_wait;
 		break;
 

commit b2afb64cccd243afd8a4337d8ee4c2f2afbe991d
Author: Huacai Chen <chenhc@lemote.com>
Date:   Mon Nov 4 14:11:20 2019 +0800

    MIPS: Loongson: Rename LOONGSON1 to LOONGSON32
    
    Now old Loongson-2E/2F use LOONGSON2EF and will be removed in future,
    newer Loongson-2/3 use LOONGSON64. So rename LOONGSON1 to LOONGSON32
    will make the naming style more unified.
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    [paulburton@kernel.org: Fix checkpatch whitespace warning in irqflags.h]
    Signed-off-by: Paul Burton <paulburton@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-mips@vger.kernel.org
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Cc: Huacai Chen <chenhuacai@gmail.com>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 57dfa6c9edc5..37f8e78e2869 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -173,7 +173,7 @@ void __init check_wait(void)
 	case CPU_CAVIUM_OCTEON2:
 	case CPU_CAVIUM_OCTEON3:
 	case CPU_XBURST:
-	case CPU_LOONGSON1:
+	case CPU_LOONGSON32:
 	case CPU_XLR:
 	case CPU_XLP:
 		cpu_wait = r4k_wait;

commit 268a2d60013049cfd9a0aada77284aa6ea8ad26a
Author: Jiaxun Yang <jiaxun.yang@flygoat.com>
Date:   Sun Oct 20 22:43:13 2019 +0800

    MIPS: Loongson64: Rename CPU TYPES
    
    CPU_LOONGSON2 -> CPU_LOONGSON2EF
    CPU_LOONGSON3 -> CPU_LOONGSON64
    
    As newer loongson-2 products (2G/2H/2K1000) can share kernel
    implementation with loongson-3 while 2E/2F are less similar with
    other LOONGSON64 products.
    
    Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
    Signed-off-by: Paul Burton <paulburton@kernel.org>
    Cc: linux-mips@vger.kernel.org
    Cc: chenhc@lemote.com
    Cc: paul.burton@mips.com

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 980d6c39aab3..57dfa6c9edc5 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -178,7 +178,7 @@ void __init check_wait(void)
 	case CPU_XLP:
 		cpu_wait = r4k_wait;
 		break;
-	case CPU_LOONGSON3:
+	case CPU_LOONGSON64:
 		if ((c->processor_id & (PRID_IMP_MASK | PRID_REV_MASK)) >=
 				(PRID_IMP_LOONGSON_64C | PRID_REV_LOONGSON3A_R2_0))
 			cpu_wait = r4k_wait;

commit 7507445b1993087d2a6ef3e30e3eaeb2da40dbc8
Author: Huacai Chen <chenhc@lemote.com>
Date:   Sat Sep 21 21:50:27 2019 +0800

    MIPS: Loongson: Add Loongson-3A R4 basic support
    
    All Loongson-3 CPU family:
    
    Code-name         Brand-name       PRId
    Loongson-3A R1    Loongson-3A1000  0x6305
    Loongson-3A R2    Loongson-3A2000  0x6308
    Loongson-3A R2.1  Loongson-3A2000  0x630c
    Loongson-3A R3    Loongson-3A3000  0x6309
    Loongson-3A R3.1  Loongson-3A3000  0x630d
    Loongson-3A R4    Loongson-3A4000  0xc000
    Loongson-3B R1    Loongson-3B1000  0x6306
    Loongson-3B R2    Loongson-3B1500  0x6307
    
    Features of R4 revision of Loongson-3A:
    
      - All R2/R3 features, including SFB, V-Cache, FTLB, RIXI, DSP, etc.
      - Support variable ASID bits.
      - Support MSA and VZ extensions.
      - Support CPUCFG (CPU config) and CSR (Control and Status Register)
          extensions.
      - 64 entries of VTLB (classic TLB), 2048 entries of FTLB (8-way
          set-associative).
    
    Now 64-bit Loongson processors has three types of PRID.IMP: 0x6300 is
    the classic one so we call it PRID_IMP_LOONGSON_64C (e.g., Loongson-2E/
    2F/3A1000/3B1000/3B1500/3A2000/3A3000), 0x6100 is for some processors
    which has reduced capabilities so we call it PRID_IMP_LOONGSON_64R
    (e.g., Loongson-2K), 0xc000 is supposed to cover all new processors in
    general (e.g., Loongson-3A4000+) so we call it PRID_IMP_LOONGSON_64G.
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Jiaxun Yang <jiaxun.yang@flygoat.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: linux-mips@linux-mips.org
    Cc: linux-mips@vger.kernel.org
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Cc: Huacai Chen <chenhuacai@gmail.com>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index eb2afc0b8db1..980d6c39aab3 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -179,7 +179,8 @@ void __init check_wait(void)
 		cpu_wait = r4k_wait;
 		break;
 	case CPU_LOONGSON3:
-		if ((c->processor_id & PRID_REV_MASK) >= PRID_REV_LOONGSON3A_R2_0)
+		if ((c->processor_id & (PRID_IMP_MASK | PRID_REV_MASK)) >=
+				(PRID_IMP_LOONGSON_64C | PRID_REV_LOONGSON3A_R2_0))
 			cpu_wait = r4k_wait;
 		break;
 

commit f9065b54d437c4660e3d974ad9ce5188c068cd76
Author: Paul Burton <paul.burton@mips.com>
Date:   Mon Jul 22 21:59:43 2019 +0000

    MIPS: Remove unused R4300 CPU support
    
    Our R4300 CPU support can only be included if a system selects
    CONFIG_SYS_HAS_CPU_R4300. No system does, making all R4300-related CPU
    support dead code. Remove it.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: linux-mips@vger.kernel.org

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index feaf9bbb82f2..eb2afc0b8db1 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -151,7 +151,6 @@ void __init check_wait(void)
 		cpu_wait = r39xx_wait;
 		break;
 	case CPU_R4200:
-/*	case CPU_R4300: */
 	case CPU_R4600:
 	case CPU_R4640:
 	case CPU_R4650:

commit 3b25b763116482596227225bea7c03fcde11c9ed
Author: Paul Cercueil <paul@crapouillou.net>
Date:   Wed May 8 00:43:56 2019 +0200

    MIPS: Rename JZRISC to XBURST
    
    The real name of the CPU present in the JZ line of SoCs from Ingenic is
    XBurst, not JZRISC.
    
    Signed-off-by: Paul Cercueil <paul@crapouillou.net>
    [paul.burton@mips.com: Leave /proc/cpuinfo string as-is.]
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: od@zcrc.me
    Cc: linux-mips@vger.kernel.org
    Cc: linux-kernel@vger.kernel.org

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 7388f1374d5f..feaf9bbb82f2 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -173,7 +173,7 @@ void __init check_wait(void)
 	case CPU_CAVIUM_OCTEON_PLUS:
 	case CPU_CAVIUM_OCTEON2:
 	case CPU_CAVIUM_OCTEON3:
-	case CPU_JZRISC:
+	case CPU_XBURST:
 	case CPU_LOONGSON1:
 	case CPU_XLR:
 	case CPU_XLP:

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 695f55477503..7388f1374d5f 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * MIPS idle loop and WAIT instruction support.
  *
@@ -5,11 +6,6 @@
  * Copyright (C) 1994 - 2006 Ralf Baechle
  * Copyright (C) 2003, 2004  Maciej W. Rozycki
  * Copyright (C) 2001, 2004, 2011, 2012	 MIPS Technologies, Inc.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version
- * 2 of the License, or (at your option) any later version.
  */
 #include <linux/cpu.h>
 #include <linux/export.h>

commit f3ade253615ae6d83aeb72d1c8a96f62a4b4b29b
Author: Huacai Chen <chenhc@lemote.com>
Date:   Thu Nov 15 15:53:52 2018 +0800

    MIPS: Loongson: Add Loongson-3A R2.1 basic support
    
    Loongson-3A R2.1 is the bugfix revision of Loongson-3A R2.
    
    All Loongson-3 CPU family:
    
    Code-name         Brand-name       PRId
    Loongson-3A R1    Loongson-3A1000  0x6305
    Loongson-3A R2    Loongson-3A2000  0x6308
    Loongson-3A R2.1  Loongson-3A2000  0x630c
    Loongson-3A R3    Loongson-3A3000  0x6309
    Loongson-3A R3.1  Loongson-3A3000  0x630d
    Loongson-3B R1    Loongson-3B1000  0x6306
    Loongson-3B R2    Loongson-3B1500  0x6307
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/21128/
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: James Hogan <james.hogan@mips.com>
    Cc: Steven J . Hill <Steven.Hill@cavium.com>
    Cc: linux-mips@linux-mips.org
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 4d335b15826e..695f55477503 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -184,7 +184,7 @@ void __init check_wait(void)
 		cpu_wait = r4k_wait;
 		break;
 	case CPU_LOONGSON3:
-		if ((c->processor_id & PRID_REV_MASK) >= PRID_REV_LOONGSON3A_R2)
+		if ((c->processor_id & PRID_REV_MASK) >= PRID_REV_LOONGSON3A_R2_0)
 			cpu_wait = r4k_wait;
 		break;
 

commit 378ed6f0e3c525e3b12827e7b7fb0a078ee48a32
Author: Paul Burton <paul.burton@mips.com>
Date:   Thu Nov 8 20:14:38 2018 +0000

    MIPS: Avoid using .set mips0 to restore ISA
    
    We currently have 2 commonly used methods for switching ISA within
    assembly code, then restoring the original ISA.
    
      1) Using a pair of .set push & .set pop directives. For example:
    
         .set       push
         .set       mips32r2
         <some_insn>
         .set       pop
    
      2) Using .set mips0 to restore the ISA originally specified on the
         command line. For example:
    
         .set       mips32r2
         <some_insn>
         .set       mips0
    
    Unfortunately method 2 does not work with nanoMIPS toolchains, where the
    assembler rejects the .set mips0 directive like so:
    
         Error: cannot change ISA from nanoMIPS to mips0
    
    In preparation for supporting nanoMIPS builds, switch all instances of
    method 2 in generic non-platform-specific code to use push & pop as in
    method 1 instead. The .set push & .set pop is arguably cleaner anyway,
    and if nothing else it's good to consistently use one method.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Patchwork: https://patchwork.linux-mips.org/patch/21037/
    Cc: linux-mips@linux-mips.org

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 046846999efd..4d335b15826e 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -101,7 +101,8 @@ static void __cpuidle au1k_wait(void)
 	unsigned long c0status = read_c0_status() | 1;	/* irqs on */
 
 	__asm__(
-	"	.set	arch=r4000			\n"
+	"	.set	push			\n"
+	"	.set	arch=r4000		\n"
 	"	cache	0x14, 0(%0)		\n"
 	"	cache	0x14, 32(%0)		\n"
 	"	sync				\n"
@@ -111,7 +112,7 @@ static void __cpuidle au1k_wait(void)
 	"	nop				\n"
 	"	nop				\n"
 	"	nop				\n"
-	"	.set	mips0			\n"
+	"	.set	pop			\n"
 	: : "r" (au1k_wait), "r" (c0status));
 }
 

commit 97c8580e85cf81cbc785102a1180f81ff431b1f0
Author: Paul Burton <paul.burton@mips.com>
Date:   Fri Jun 22 10:55:47 2018 -0700

    MIPS: Annotate cpu_wait implementations with __cpuidle
    
    Annotate cpu_wait implementations using the __cpuidle macro which
    places these functions in the .cpuidle.text section. This allows
    cpu_in_idle() to return true for PC values which fall within these
    functions, allowing nmi_backtrace() to produce cleaner output for CPUs
    running idle functions. For example:
    
      # echo l >/proc/sysrq-trigger
      [   38.587170] sysrq: SysRq : Show backtrace of all active CPUs
      [   38.593657] NMI backtrace for cpu 1
      [   38.597611] CPU: 1 PID: 161 Comm: sh Not tainted 4.18.0-rc1+ #27
      [   38.604306] Stack : 00000000 00000004 00000006 80486724 00000000 00000000 00000000 00000000
      [   38.613647]         80e17eda 00000034 00000000 00000000 80d20000 80b67e98 8e559c90 0ffe1e88
      [   38.622986]         00000000 00000000 80e70000 00000000 8f61db18 38312e34 722d302e 202b3163
      [   38.632324]         8e559d3c 8e559adc 00000001 6b636162 80d20000 80000000 00000000 80d1cfa4
      [   38.641664]         00000001 80d20000 80d19520 00000000 00000003 80836724 00000004 80e10004
      [   38.650993]         ...
      [   38.653724] Call Trace:
      [   38.656499] [<8040cdd0>] show_stack+0xa0/0x144
      [   38.661475] [<80b67e98>] dump_stack+0xe8/0x120
      [   38.666455] [<80b6f6d4>] nmi_cpu_backtrace+0x1b4/0x1cc
      [   38.672189] [<80b6f81c>] nmi_trigger_cpumask_backtrace+0x130/0x1e4
      [   38.679081] [<808295d8>] __handle_sysrq+0xc0/0x180
      [   38.684421] [<80829b84>] write_sysrq_trigger+0x50/0x64
      [   38.690176] [<8061c984>] proc_reg_write+0xd0/0xfc
      [   38.695447] [<805aac1c>] __vfs_write+0x54/0x194
      [   38.700500] [<805aaf24>] vfs_write+0xe0/0x18c
      [   38.705360] [<805ab190>] ksys_write+0x7c/0xf0
      [   38.710238] [<80416018>] syscall_common+0x34/0x58
      [   38.715558] Sending NMI from CPU 1 to CPUs 0,2-3:
      [   38.720916] NMI backtrace for cpu 0 skipped: idling at r4k_wait_irqoff+0x2c/0x34
      [   38.729186] NMI backtrace for cpu 3 skipped: idling at r4k_wait_irqoff+0x2c/0x34
      [   38.737449] NMI backtrace for cpu 2 skipped: idling at r4k_wait_irqoff+0x2c/0x34
    
    Without this we get register value & backtrace output from all CPUs,
    which is generally useless for those running the idle function & serves
    only to overwhelm & obfuscate the meaningful output from non-idle CPUs.
    
    Signed-off-by: Paul Burton <paul.burton@mips.com>
    Cc: James Hogan <jhogan@kernel.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Huacai Chen <chenhc@lemote.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/19598/

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 7c246b69c545..046846999efd 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -33,21 +33,21 @@
 void (*cpu_wait)(void);
 EXPORT_SYMBOL(cpu_wait);
 
-static void r3081_wait(void)
+static void __cpuidle r3081_wait(void)
 {
 	unsigned long cfg = read_c0_conf();
 	write_c0_conf(cfg | R30XX_CONF_HALT);
 	local_irq_enable();
 }
 
-static void r39xx_wait(void)
+static void __cpuidle r39xx_wait(void)
 {
 	if (!need_resched())
 		write_c0_conf(read_c0_conf() | TX39_CONF_HALT);
 	local_irq_enable();
 }
 
-void r4k_wait(void)
+void __cpuidle r4k_wait(void)
 {
 	local_irq_enable();
 	__r4k_wait();
@@ -60,7 +60,7 @@ void r4k_wait(void)
  * interrupt is requested" restriction in the MIPS32/MIPS64 architecture makes
  * using this version a gamble.
  */
-void r4k_wait_irqoff(void)
+void __cpuidle r4k_wait_irqoff(void)
 {
 	if (!need_resched())
 		__asm__(
@@ -75,7 +75,7 @@ void r4k_wait_irqoff(void)
  * The RM7000 variant has to handle erratum 38.	 The workaround is to not
  * have any pending stores when the WAIT instruction is executed.
  */
-static void rm7k_wait_irqoff(void)
+static void __cpuidle rm7k_wait_irqoff(void)
 {
 	if (!need_resched())
 		__asm__(
@@ -96,7 +96,7 @@ static void rm7k_wait_irqoff(void)
  * since coreclock (and the cp0 counter) stops upon executing it. Only an
  * interrupt can wake it, so they must be enabled before entering idle modes.
  */
-static void au1k_wait(void)
+static void __cpuidle au1k_wait(void)
 {
 	unsigned long c0status = read_c0_status() | 1;	/* irqs on */
 

commit 91955e3ef5a247fa96908822d4021072106edca8
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Wed Aug 23 11:17:47 2017 -0700

    MIPS: Include linux/cpu.h for arch_cpu_idle()
    
    arch/mips/kernel/idle.c provides our implementation of the
    arch_cpu_idle() function, but doesn't include the linux/cpu.h header
    which declares it. This leads to a warning from sparse:
    
      arch/mips/kernel/idle.c:256:6: warning: symbol 'arch_cpu_idle' was not
        declared. Should it be static?
    
    Fix this by including linux/cpu.h to get the declaration of
    arch_cpu_idle().
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: trivial@kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/17169/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 60ab4c44d305..7c246b69c545 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -11,6 +11,7 @@
  * as published by the Free Software Foundation; either version
  * 2 of the License, or (at your option) any later version.
  */
+#include <linux/cpu.h>
 #include <linux/export.h>
 #include <linux/init.h>
 #include <linux/irqflags.h>

commit b2edcfc814017eb278e29bfdc72844f0434dd8b1
Author: Huacai Chen <chenhc@lemote.com>
Date:   Thu Mar 3 09:45:09 2016 +0800

    MIPS: Loongson: Add Loongson-3A R2 basic support
    
    Loongson-3 CPU family:
    
    Code-name       Brand-name       PRId
    Loongson-3A R1  Loongson-3A1000  0x6305
    Loongson-3A R2  Loongson-3A2000  0x6308
    Loongson-3B R1  Loongson-3B1000  0x6306
    Loongson-3B R2  Loongson-3B1500  0x6307
    
    Features of R2 revision of Loongson-3A:
    
      - Primary cache includes I-Cache, D-Cache and V-Cache (Victim Cache).
      - I-Cache, D-Cache and V-Cache are 16-way set-associative, linesize is
         64 bytes.
      - 64 entries of VTLB (classic TLB), 1024 entries of FTLB (8-way
         set-associative).
      - Supports DSP/DSPv2 instructions, UserLocal register and Read-Inhibit/
         Execute-Inhibit.
    
    [ralf@linux-mips.org: Resolved merge conflicts.]
    
    Signed-off-by: Huacai Chen <chenhc@lemote.com>
    Cc: Aurelien Jarno <aurelien@aurel32.net>
    Cc: Steven J . Hill <sjhill@realitydiluted.com>
    Cc: Fuxin Zhang <zhangfx@lemote.com>
    Cc: Zhangjin Wu <wuzhangjin@gmail.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/12751/
    Patchwork: https://patchwork.linux-mips.org/patch/13136/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 46794d64c0bf..60ab4c44d305 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -181,6 +181,11 @@ void __init check_wait(void)
 	case CPU_XLP:
 		cpu_wait = r4k_wait;
 		break;
+	case CPU_LOONGSON3:
+		if ((c->processor_id & PRID_REV_MASK) >= PRID_REV_LOONGSON3A_R2)
+			cpu_wait = r4k_wait;
+		break;
+
 	case CPU_BMIPS5000:
 		cpu_wait = r4k_wait_irqoff;
 		break;

commit da34232641a91ca785a787c23c158488e459b938
Merge: bf463f2f7510 3bfb72245665
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Nov 12 11:36:03 2015 +0100

    Merge branch '4.3-fixes' into mips-for-linux-next

commit bf463f2f7510771db180908507005379850dade0
Author: Aurelien Jarno <aurelien@aurel32.net>
Date:   Sat Sep 5 18:47:31 2015 +0200

    MIPS: idle: add case for CPU_5KE
    
    While the 5KE processors have never been taped out, they exists though
    a CP0.PRId and experimental RTLs or QEMU implementations. Add a case
    entry in the idle code, as they can use the standard idle loop like the
    5K processors.
    
    Signed-off-by: Aurelien Jarno <aurelien@aurel32.net>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/11099/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 3e2b0b6c3b08..35af61530de1 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -165,6 +165,7 @@ void __init check_wait(void)
 	case CPU_4KEC:
 	case CPU_4KSC:
 	case CPU_5KC:
+	case CPU_5KE:
 	case CPU_25KF:
 	case CPU_PR4450:
 	case CPU_BMIPS3300:

commit 5b10a0e84b4ebe02a7018846e882caa112b4ffc6
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Tue Sep 22 11:24:20 2015 -0700

    MIPS: Always use r4k_wait_irqoff for MIPSr6
    
    Prior to release 6 of the MIPS architecture it has been implementation
    dependent whether masked interrupts cause a wait instruction to return,
    so the kernel has effectively had to maintain a whitelist of cores upon
    which it is safe to use the r4k_wait_irqoff cpu_wait implementation.
    With MIPSr6 this is no longer implementation dependent and
    r4k_wait_irqoff can always be used.
    
    Remove the existing I6400 case which will no longer ever be hit, and was
    incorrect anyway since I6400 & r6 in general doesn't have the WII bit.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: linux-kernel@vger.kernel.org
    Cc: James Hogan <james.hogan@imgtec.com>
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Patchwork: https://patchwork.linux-mips.org/patch/11210/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index ab1478d5a4db..3e2b0b6c3b08 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -134,6 +134,16 @@ void __init check_wait(void)
 		return;
 	}
 
+	/*
+	 * MIPSr6 specifies that masked interrupts should unblock an executing
+	 * wait instruction, and thus that it is safe for us to use
+	 * r4k_wait_irqoff. Yippee!
+	 */
+	if (cpu_has_mips_r6) {
+		cpu_wait = r4k_wait_irqoff;
+		return;
+	}
+
 	switch (current_cpu_type()) {
 	case CPU_R3081:
 	case CPU_R3081E:
@@ -196,7 +206,6 @@ void __init check_wait(void)
 	case CPU_INTERAPTIV:
 	case CPU_M5150:
 	case CPU_QEMU_GENERIC:
-	case CPU_I6400:
 		cpu_wait = r4k_wait;
 		if (read_c0_config7() & MIPS_CONF7_WII)
 			cpu_wait = r4k_wait_irqoff;

commit adaa0b6c49795551b07576e952dfa94c3ccded51
Author: Petri Gynther <pgynther@google.com>
Date:   Mon Oct 19 11:44:24 2015 -0700

    MIPS: Switch BMIPS5000 to use r4k_wait_irqoff()
    
    BCM7425 CPU Interface Zephyr Processor, pages 5-309 and 5-310
    BCM7428B0 CPU Interface Zephyr Processor, pages 5-337 and 5-338
    
    WAIT instruction:
    Thread enters wait state. No instructions are executed until an
    interrupt occurs. The processor's clocks are stopped if both threads
    are in idle mode.
    
    Description:
    Execution of this instruction puts the thread into wait state, an idle
    mode in which no instructions are fetched or executed. The thread remains
    in wait state until an interrupt occurs that is not masked by the
    interrupt mask field in the Status register. Then, if interrupts are
    enabled by the IE bit in the Status register, the interrupt is serviced.
    The ERET instruction returns to the instruction following the WAIT
    instruction. If interrupts are disabled, the processor resumes executing
    instructions with the next sequential instruction.
    
    Programming notes:
    The WAIT instruction should be executed while interrupts are disabled
    by the IE bit in the Status register. This avoids a potential timing
    hazard, which occurs if an interrupt is taken between testing the counter
    and executing the WAIT instruction. In this hazard case, the interrupt
    will have been completed before the WAIT instruction is executed, so
    the processor will remain indefinitely in wait state until the next
    interrupt.
    
    Signed-off-by: Petri Gynther <pgynther@google.com>
    Reviewed-by: Florian Fainelli <f.fainelli@gmail.com>
    Cc: cernekee@gmail.com
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/11322/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index ab1478d5a4db..d636c70fef19 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -160,7 +160,6 @@ void __init check_wait(void)
 	case CPU_BMIPS3300:
 	case CPU_BMIPS4350:
 	case CPU_BMIPS4380:
-	case CPU_BMIPS5000:
 	case CPU_CAVIUM_OCTEON:
 	case CPU_CAVIUM_OCTEON_PLUS:
 	case CPU_CAVIUM_OCTEON2:
@@ -171,7 +170,9 @@ void __init check_wait(void)
 	case CPU_XLP:
 		cpu_wait = r4k_wait;
 		break;
-
+	case CPU_BMIPS5000:
+		cpu_wait = r4k_wait_irqoff;
+		break;
 	case CPU_RM7000:
 		cpu_wait = rm7k_wait_irqoff;
 		break;

commit 4e88a8621301b992e8e3422e08bfb604772f3338
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Thu Jul 9 10:40:36 2015 +0100

    MIPS: Add cases for CPU_I6400
    
    Add a CPU_I6400 case to various switch statements, doing the same thing
    as for CPU_P5600.
    
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/10635/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index e4f62b7875d2..ab1478d5a4db 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -196,6 +196,7 @@ void __init check_wait(void)
 	case CPU_INTERAPTIV:
 	case CPU_M5150:
 	case CPU_QEMU_GENERIC:
+	case CPU_I6400:
 		cpu_wait = r4k_wait;
 		if (read_c0_config7() & MIPS_CONF7_WII)
 			cpu_wait = r4k_wait_irqoff;

commit e38df288a9db56c1bdb60aa4fb2354cde57fdc5f
Author: James Hogan <james.hogan@imgtec.com>
Date:   Thu Jan 29 11:14:11 2015 +0000

    MIPS: idle: Workaround wait + FDC problems
    
    On certain cores (namely proAptiv and P5600) incoming data via a Fast
    Debug Channel (FDC) while the core is blocked on a wait instruction will
    cause the wait not to wake up even when another interrupt is received.
    This makes an idle target stop as soon as you send FDC data to it, until
    the debug probe interrupts it and restarts the wait instruction.
    
    This is worked around by avoiding using r4k_wait on these cores if
    CONFIG_MIPS_EJTAG_FDC_TTY is enabled (which would imply the user intends
    to use the FDC).
    
    [ralf@linux-mips.org: Fix conflict.]
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: linux-kernel@vger.kernel.org
    Patchwork: https://patchwork.linux-mips.org/patch/9144/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 368c88b7eb6c..e4f62b7875d2 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -176,6 +176,17 @@ void __init check_wait(void)
 		cpu_wait = rm7k_wait_irqoff;
 		break;
 
+	case CPU_PROAPTIV:
+	case CPU_P5600:
+		/*
+		 * Incoming Fast Debug Channel (FDC) data during a wait
+		 * instruction causes the wait never to resume, even if an
+		 * interrupt is received. Avoid using wait at all if FDC data is
+		 * likely to be received.
+		 */
+		if (IS_ENABLED(CONFIG_MIPS_EJTAG_FDC_TTY))
+			break;
+		/* fall through */
 	case CPU_M14KC:
 	case CPU_M14KEC:
 	case CPU_24K:
@@ -183,8 +194,6 @@ void __init check_wait(void)
 	case CPU_1004K:
 	case CPU_1074K:
 	case CPU_INTERAPTIV:
-	case CPU_PROAPTIV:
-	case CPU_P5600:
 	case CPU_M5150:
 	case CPU_QEMU_GENERIC:
 		cpu_wait = r4k_wait;

commit 4695089f03929c8cfa58470faf6e1e041bfb285a
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Mon Nov 24 12:59:01 2014 +0000

    MIPS: Add cases for CPU_QEMU_GENERIC
    
    Add a CPU_QEMU_GENERIC case to various switch statements.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 0b9082b6b683..368c88b7eb6c 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -186,6 +186,7 @@ void __init check_wait(void)
 	case CPU_PROAPTIV:
 	case CPU_P5600:
 	case CPU_M5150:
+	case CPU_QEMU_GENERIC:
 		cpu_wait = r4k_wait;
 		if (read_c0_config7() & MIPS_CONF7_WII)
 			cpu_wait = r4k_wait_irqoff;

commit 9d26024c964718c6307a96f387b24fc06dac4d91
Author: Markos Chandras <markos.chandras@imgtec.com>
Date:   Tue Sep 16 13:57:08 2014 +0100

    MIPS: idle: Remove leftover __pastwait symbol and its references
    
    The __pastwait symbol was only used by the address_is_in_r4k_wait_irqoff
    function but this is no longer used since the SMTC removal in commit
    b633648c5ad3 ('MIPS: MT: Remove SMTC support'). That symbol also led to
    build failures under certain random configuration due to the way the
    compiler compiled the r4k_wait_irqoff function. If that function was
    called multiple times, the __pastwait symbol was redefined breaking the
    build like this:
    
    CHK     include/generated/compile.h
    CC      arch/mips/kernel/idle.o
    {standard input}: Assembler messages:
    {standard input}:527: Error: symbol `__pastwait' is already defined
    
    Link: http://www.linux-mips.org/cgi-bin/mesg.cgi?a=linux-mips&i=1244879922.24479.30.camel%40falcon
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Cc: Markos Chandras <markos.chandras@imgtec.com>
    Patchwork: https://patchwork.linux-mips.org/patch/7791/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 09ce45980758..0b9082b6b683 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -68,9 +68,6 @@ void r4k_wait_irqoff(void)
 		"	wait			\n"
 		"	.set	pop		\n");
 	local_irq_enable();
-	__asm__(
-	"	.globl __pastwait	\n"
-	"__pastwait:			\n");
 }
 
 /*

commit 2e2d663d2dd64ffe9855be0b35aa221c9b8139f2
Merge: 5ec79bf919dd 322014531e1f
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Wed May 28 19:00:14 2014 +0200

    Merge branch 'wip-mips-pm' of https://github.com/paulburton/linux into mips-for-linux-next

commit da9f970fdd55a018ab97ec2d25653756407bdaaf
Author: Paul Burton <paul.burton@imgtec.com>
Date:   Mon Apr 14 16:16:41 2014 +0100

    MIPS: cpuidle wait instruction state
    
    Defines a macro intended to allow trivial use of the regular MIPS wait
    instruction from cpuidle drivers, which may simply invoke the macro
    within their array of states.
    
    Signed-off-by: Paul Burton <paul.burton@imgtec.com>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 837ff27950bc..2879e2ed5192 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -250,3 +250,14 @@ void arch_cpu_idle(void)
 	else
 		local_irq_enable();
 }
+
+#ifdef CONFIG_CPU_IDLE
+
+int mips_cpuidle_wait_enter(struct cpuidle_device *dev,
+			    struct cpuidle_driver *drv, int index)
+{
+	arch_cpu_idle();
+	return index;
+}
+
+#endif

commit b633648c5ad3cfbda0b3daea50d2135d44899259
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri May 23 16:29:44 2014 +0200

    MIPS: MT: Remove SMTC support
    
    Nobody is maintaining SMTC anymore and there also seems to be no userbase.
    Which is a pity - the SMTC technology primarily developed by Kevin D.
    Kissell <kevink@paralogos.com> is an ingenious demonstration for the MT
    ASE's power and elegance.
    
    Based on Markos Chandras <Markos.Chandras@imgtec.com> patch
    https://patchwork.linux-mips.org/patch/6719/ which while very similar did
    no longer apply cleanly when I tried to merge it plus some additional
    post-SMTC cleanup - SMTC was a feature as tricky to remove as it was to
    merge once upon a time.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 5e3b653f5d9e..c4ceccfa3828 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -229,18 +229,8 @@ void __init check_wait(void)
 	}
 }
 
-static void smtc_idle_hook(void)
-{
-#ifdef CONFIG_MIPS_MT_SMTC
-	void smtc_idle_loop_hook(void);
-
-	smtc_idle_loop_hook();
-#endif
-}
-
 void arch_cpu_idle(void)
 {
-	smtc_idle_hook();
 	if (cpu_wait)
 		cpu_wait();
 	else

commit 9ef988ddb0bd36687501079333e2d8a1c31c5318
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu May 22 17:19:20 2014 +0200

    MIPS: RM9000: Remove support for idle loop.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 837ff27950bc..5e3b653f5d9e 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -224,10 +224,6 @@ void __init check_wait(void)
 		   cpu_wait = r4k_wait;
 		 */
 		break;
-	case CPU_RM9000:
-		if ((c->processor_id & 0x00ff) >= 0x40)
-			cpu_wait = r4k_wait;
-		break;
 	default:
 		break;
 	}

commit a809d46066d5171ed446d59a51cd1e57d99fcfc3
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Sun Mar 30 13:20:10 2014 +0200

    MIPS: Fix gigaton of warning building with microMIPS.
    
    With binutils 2.24 the attempt to switch with microMIPS mode to MIPS III
    mode through .set mips3 results in *lots* of warnings like
    
    {standard input}: Assembler messages:
    {standard input}:397: Warning: the 64-bit MIPS architecture does not support the `smartmips' extension
    
    during a kernel build.  Fixed by using .set arch=r4000 instead.
    
    This breaks support for building the kernel with binutils 2.13 which
    was supported for 32 bit kernels only anyway and 2.14 which was a bad
    vintage for MIPS anyway.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 9f904eda5de5..837ff27950bc 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -64,7 +64,7 @@ void r4k_wait_irqoff(void)
 	if (!need_resched())
 		__asm__(
 		"	.set	push		\n"
-		"	.set	mips3		\n"
+		"	.set	arch=r4000	\n"
 		"	wait			\n"
 		"	.set	pop		\n");
 	local_irq_enable();
@@ -82,7 +82,7 @@ static void rm7k_wait_irqoff(void)
 	if (!need_resched())
 		__asm__(
 		"	.set	push					\n"
-		"	.set	mips3					\n"
+		"	.set	arch=r4000				\n"
 		"	.set	noat					\n"
 		"	mfc0	$1, $12					\n"
 		"	sync						\n"
@@ -103,7 +103,7 @@ static void au1k_wait(void)
 	unsigned long c0status = read_c0_status() | 1;	/* irqs on */
 
 	__asm__(
-	"	.set	mips3			\n"
+	"	.set	arch=r4000			\n"
 	"	cache	0x14, 0(%0)		\n"
 	"	cache	0x14, 32(%0)		\n"
 	"	sync				\n"

commit f36c4720fca325579faddc880d4e178e4ccbda88
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Tue Mar 4 13:34:43 2014 +0000

    MIPS: Add support for the M5150 processor
    
    The M5150 core is a 32-bit MIPS RISC which implements the
    MIPS Architecture Release-5  in a 5-stage pipeline.
    In addition, it includes the MIPS Architecture Virtualization Module
    that enables virtualization of operating systems,
    which provides a scalable, trusted, and secure execution environment.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6596/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 04ea1c7a3d31..9f904eda5de5 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -188,6 +188,7 @@ void __init check_wait(void)
 	case CPU_INTERAPTIV:
 	case CPU_PROAPTIV:
 	case CPU_P5600:
+	case CPU_M5150:
 		cpu_wait = r4k_wait;
 		if (read_c0_config7() & MIPS_CONF7_WII)
 			cpu_wait = r4k_wait_irqoff;

commit aced4cbd6e3da7dd71f19d0378d27aa74f76e70b
Author: James Hogan <james.hogan@imgtec.com>
Date:   Wed Jan 22 16:19:38 2014 +0000

    MIPS: Add cases for CPU_P5600
    
    Add a CPU_P5600 case to various switch statements, doing the same thing
    as for CPU_PROAPTIV.
    
    Signed-off-by: James Hogan <james.hogan@imgtec.com>
    Reviewed-by: Markos Chandras <markos.chandras@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6408/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index c1fd0bc7a315..04ea1c7a3d31 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -187,6 +187,7 @@ void __init check_wait(void)
 	case CPU_1074K:
 	case CPU_INTERAPTIV:
 	case CPU_PROAPTIV:
+	case CPU_P5600:
 		cpu_wait = r4k_wait;
 		if (read_c0_config7() & MIPS_CONF7_WII)
 			cpu_wait = r4k_wait_irqoff;

commit 442e14a2c55e55f208bf87e3686396b4ff17ebf6
Author: Steven J. Hill <Steven.Hill@imgtec.com>
Date:   Fri Jan 17 15:03:50 2014 -0600

    MIPS: Add 1074K CPU support explicitly.
    
    The 1074K is a multiprocessing coherent processing system (CPS) based
    on modified 74K cores. This patch makes the 1074K an actual unique
    CPU type, instead of a 74K derivative, which it is not.
    
    Signed-off-by: Steven J. Hill <Steven.Hill@imgtec.com>
    Reviewed-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/6389/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 3553243bf9d6..c1fd0bc7a315 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -184,6 +184,7 @@ void __init check_wait(void)
 	case CPU_24K:
 	case CPU_34K:
 	case CPU_1004K:
+	case CPU_1074K:
 	case CPU_INTERAPTIV:
 	case CPU_PROAPTIV:
 		cpu_wait = r4k_wait;

commit 26ab96dfa9f98d74ef38efbe830d356547a292c1
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Wed Nov 27 10:07:53 2013 +0000

    MIPS: Add support for interAptiv cores
    
    The interAptiv is a power-efficient multi-core microprocessor
    for use in system-on-chip (SoC) applications. The interAptiv combines
    a multi-threading pipeline with a coherence manager to deliver improved
    computational throughput and power efficiency. The interAptiv can
    contain one to four MIPS32R3 interAptiv cores, system level
    coherence manager with L2 cache, optional coherent I/O port,
    and optional floating point unit.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6163/

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index cb2c94f13d01..3553243bf9d6 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -184,6 +184,7 @@ void __init check_wait(void)
 	case CPU_24K:
 	case CPU_34K:
 	case CPU_1004K:
+	case CPU_INTERAPTIV:
 	case CPU_PROAPTIV:
 		cpu_wait = r4k_wait;
 		if (read_c0_config7() & MIPS_CONF7_WII)

commit 708ac4b8703ea3204eee7c1c00c29912468a759d
Author: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
Date:   Thu Nov 14 16:12:27 2013 +0000

    MIPS: Add support for the proAptiv cores
    
    The proAptiv Multiprocessing System is a power efficient multi-core
    microprocessor for use in system-on-chip (SoC) applications.
    The proAptiv Multiprocessing System combines a deep pipeline
    with multi-issue out of order execution for improved computational
    throughput. The proAptiv Multiprocessing System can contain one to
    six MIPS32r3 proAptiv cores, system level coherence
    manager with L2 cache, optional coherent I/O port, and optional
    floating point unit.
    
    Signed-off-by: Leonid Yegoshin <Leonid.Yegoshin@imgtec.com>
    Signed-off-by: Markos Chandras <markos.chandras@imgtec.com>
    Signed-off-by: John Crispin <blogic@openwrt.org>
    Patchwork: http://patchwork.linux-mips.org/patch/6134/

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index f7991d95bff9..cb2c94f13d01 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -184,6 +184,7 @@ void __init check_wait(void)
 	case CPU_24K:
 	case CPU_34K:
 	case CPU_1004K:
+	case CPU_PROAPTIV:
 		cpu_wait = r4k_wait;
 		if (read_c0_config7() & MIPS_CONF7_WII)
 			cpu_wait = r4k_wait_irqoff;

commit 69f24d1784b631b81a54eb57c49bf46536dd2382
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue Sep 17 10:25:47 2013 +0200

    MIPS: Optimize current_cpu_type() for better code.
    
     o Move current_cpu_type() to a separate header file
     o #ifdefing on supported CPU types lets modern GCC know that certain
       code in callers may be discarded ideally turning current_cpu_type() into
       a function returning a constant.
     o Use current_cpu_type() rather than direct access to struct cpuinfo_mips.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Cc: Steven J. Hill <Steven.Hill@imgtec.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5833/

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 42f8875d2444..f7991d95bff9 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -18,6 +18,7 @@
 #include <linux/sched.h>
 #include <asm/cpu.h>
 #include <asm/cpu-info.h>
+#include <asm/cpu-type.h>
 #include <asm/idle.h>
 #include <asm/mipsregs.h>
 
@@ -136,7 +137,7 @@ void __init check_wait(void)
 		return;
 	}
 
-	switch (c->cputype) {
+	switch (current_cpu_type()) {
 	case CPU_R3081:
 	case CPU_R3081E:
 		cpu_wait = r3081_wait;

commit 4122af0ab02a4b394e4703a3ac557d556701f4d9
Author: David Daney <david.daney@cavium.com>
Date:   Mon Jul 29 15:07:02 2013 -0700

    MIPS: Use r4k_wait for OCTEON3 CPUs.
    
    Signed-off-by: David Daney <david.daney@cavium.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/5636/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 0c655deeea4a..42f8875d2444 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -166,6 +166,7 @@ void __init check_wait(void)
 	case CPU_CAVIUM_OCTEON:
 	case CPU_CAVIUM_OCTEON_PLUS:
 	case CPU_CAVIUM_OCTEON2:
+	case CPU_CAVIUM_OCTEON3:
 	case CPU_JZRISC:
 	case CPU_LOONGSON1:
 	case CPU_XLR:

commit e63a24ddc79cc801766646fb643451ad366a1121
Author: Manuel Lauss <manuel.lauss@gmail.com>
Date:   Sat Jun 8 19:15:41 2013 +0000

    MIPS: Alchemy: fix wait function
    
    Only an interrupt can wake the core from 'wait', enable interrupts
    locally before executing 'wait'.
    
    [ralf@linux-mips.org: This leave the race between an interrupt that's
    setting TIF_NEED_RESCHEd and entering the WAIT status. but at least it's
    going to bring Alchemy back from the dead, so I'm going to apply this
    patch.]
    
    Signed-off-by: Manuel Lauss <manuel.lauss@gmail.com>
    Cc: Linux-MIPS <linux-mips@linux-mips.org>
    Cc: Maciej W. Rozycki <macro@linux-mips.org>
    Patchwork: https://patchwork.linux-mips.org/patch/5408/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 3b09b888afa9..0c655deeea4a 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -93,26 +93,27 @@ static void rm7k_wait_irqoff(void)
 }
 
 /*
- * The Au1xxx wait is available only if using 32khz counter or
- * external timer source, but specifically not CP0 Counter.
- * alchemy/common/time.c may override cpu_wait!
+ * Au1 'wait' is only useful when the 32kHz counter is used as timer,
+ * since coreclock (and the cp0 counter) stops upon executing it. Only an
+ * interrupt can wake it, so they must be enabled before entering idle modes.
  */
 static void au1k_wait(void)
 {
+	unsigned long c0status = read_c0_status() | 1;	/* irqs on */
+
 	__asm__(
 	"	.set	mips3			\n"
 	"	cache	0x14, 0(%0)		\n"
 	"	cache	0x14, 32(%0)		\n"
 	"	sync				\n"
-	"	nop				\n"
+	"	mtc0	%1, $12			\n" /* wr c0status */
 	"	wait				\n"
 	"	nop				\n"
 	"	nop				\n"
 	"	nop				\n"
 	"	nop				\n"
 	"	.set	mips0			\n"
-	: : "r" (au1k_wait));
-	local_irq_enable();
+	: : "r" (au1k_wait), "r" (c0status));
 }
 
 static int __initdata nowait;

commit 087d990b371c59edbfc119600e2d2eda18366292
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 21 17:33:32 2013 +0200

    MIPS: Idle: Break r4k_wait into two functions and fix it.
    
    local_irq_enable() may expand into very different code, so it rather should
    stay in C.  Also this keeps the assembler code size constant which keeps
    the rollback code simple.  So it's best to split r4k_wait into two parts,
    one C and one assembler.
    
    Finally add the local_irq_enable() to r4k_wait to ensure the WAIT
    instruction in __r4k_wait() will work properly.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 985cc02786e3..3b09b888afa9 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -45,6 +45,12 @@ static void r39xx_wait(void)
 	local_irq_enable();
 }
 
+void r4k_wait(void)
+{
+	local_irq_enable();
+	__r4k_wait();
+}
+
 /*
  * This variant is preferable as it allows testing need_resched and going to
  * sleep depending on the outcome atomically.  Unfortunately the "It is

commit bdc92d74e0ec95a8101447467c25f015105f2e5a
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 21 16:59:19 2013 +0200

    MIPS: Idle: Consolidate all declarations in <asm/idle.h>.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 1f85dda03df4..985cc02786e3 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -18,6 +18,7 @@
 #include <linux/sched.h>
 #include <asm/cpu.h>
 #include <asm/cpu-info.h>
+#include <asm/idle.h>
 #include <asm/mipsregs.h>
 
 /*
@@ -44,8 +45,6 @@ static void r39xx_wait(void)
 	local_irq_enable();
 }
 
-extern void r4k_wait(void);
-
 /*
  * This variant is preferable as it allows testing need_resched and going to
  * sleep depending on the outcome atomically.  Unfortunately the "It is

commit d882f07a83642283b9bc4e7f4c56ac4982c5e629
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 21 14:14:48 2013 +0200

    MIPS: Idle: Don't call local_irq_disable() in cpu_wait() implementations.
    
    The generic idle loop has already disabled interrupts so this is redundant.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 78cc7d6fc845..1f85dda03df4 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -39,7 +39,6 @@ static void r3081_wait(void)
 
 static void r39xx_wait(void)
 {
-	local_irq_disable();
 	if (!need_resched())
 		write_c0_conf(read_c0_conf() | TX39_CONF_HALT);
 	local_irq_enable();
@@ -56,7 +55,6 @@ extern void r4k_wait(void);
  */
 void r4k_wait_irqoff(void)
 {
-	local_irq_disable();
 	if (!need_resched())
 		__asm__(
 		"	.set	push		\n"
@@ -75,7 +73,6 @@ void r4k_wait_irqoff(void)
  */
 static void rm7k_wait_irqoff(void)
 {
-	local_irq_disable();
 	if (!need_resched())
 		__asm__(
 		"	.set	push					\n"

commit fb40bc3e94933007d3e42e96daf1ec8044821cb8
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 21 14:05:27 2013 +0200

    MIPS: Idle: Re-enable irqs at the end of r3081, au1k and loongson2 cpu_wait.
    
    Without this, the
    
        WARN_ON_ONCE(irqs_disabled());
    
    in the idle loop will be triggered.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 36e79f528e89..78cc7d6fc845 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -34,6 +34,7 @@ static void r3081_wait(void)
 {
 	unsigned long cfg = read_c0_conf();
 	write_c0_conf(cfg | R30XX_CONF_HALT);
+	local_irq_enable();
 }
 
 static void r39xx_wait(void)
@@ -109,6 +110,7 @@ static void au1k_wait(void)
 	"	nop				\n"
 	"	.set	mips0			\n"
 	: : "r" (au1k_wait));
+	local_irq_enable();
 }
 
 static int __initdata nowait;

commit c9b6869dbb3c6edb24e3cc76d3655067cfa7b802
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 21 13:02:12 2013 +0200

    MIPS: Idle: Make call of function pointer readable.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index b33875bf699d..36e79f528e89 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -234,7 +234,7 @@ void arch_cpu_idle(void)
 {
 	smtc_idle_hook();
 	if (cpu_wait)
-		(*cpu_wait)();
+		cpu_wait();
 	else
 		local_irq_enable();
 }

commit f91a148aa22b3808c12525ccc5779ff0ae6314a4
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 21 12:58:08 2013 +0200

    MIPS: Idle: Consistently reformat inline assembler.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 28abda73126a..b33875bf699d 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -57,13 +57,15 @@ void r4k_wait_irqoff(void)
 {
 	local_irq_disable();
 	if (!need_resched())
-		__asm__("	.set	push		\n"
-			"	.set	mips3		\n"
-			"	wait			\n"
-			"	.set	pop		\n");
+		__asm__(
+		"	.set	push		\n"
+		"	.set	mips3		\n"
+		"	wait			\n"
+		"	.set	pop		\n");
 	local_irq_enable();
-	__asm__("	.globl __pastwait	\n"
-		"__pastwait:			\n");
+	__asm__(
+	"	.globl __pastwait	\n"
+	"__pastwait:			\n");
 }
 
 /*
@@ -94,18 +96,19 @@ static void rm7k_wait_irqoff(void)
  */
 static void au1k_wait(void)
 {
-	__asm__("	.set	mips3			\n"
-		"	cache	0x14, 0(%0)		\n"
-		"	cache	0x14, 32(%0)		\n"
-		"	sync				\n"
-		"	nop				\n"
-		"	wait				\n"
-		"	nop				\n"
-		"	nop				\n"
-		"	nop				\n"
-		"	nop				\n"
-		"	.set	mips0			\n"
-		: : "r" (au1k_wait));
+	__asm__(
+	"	.set	mips3			\n"
+	"	cache	0x14, 0(%0)		\n"
+	"	cache	0x14, 32(%0)		\n"
+	"	sync				\n"
+	"	nop				\n"
+	"	wait				\n"
+	"	nop				\n"
+	"	nop				\n"
+	"	nop				\n"
+	"	nop				\n"
+	"	.set	mips0			\n"
+	: : "r" (au1k_wait));
 }
 
 static int __initdata nowait;

commit 00baf8576c29c93a470bdfc98a5c121a49c2f34b
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 21 12:47:26 2013 +0200

    MIPS: Idle: cleaup SMTC idle hook as per Linux coding style.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
index 1e9d9383d49f..28abda73126a 100644
--- a/arch/mips/kernel/idle.c
+++ b/arch/mips/kernel/idle.c
@@ -218,13 +218,18 @@ void __init check_wait(void)
 	}
 }
 
-void arch_cpu_idle(void)
+static void smtc_idle_hook(void)
 {
 #ifdef CONFIG_MIPS_MT_SMTC
-	extern void smtc_idle_loop_hook(void);
+	void smtc_idle_loop_hook(void);
 
 	smtc_idle_loop_hook();
 #endif
+}
+
+void arch_cpu_idle(void)
+{
+	smtc_idle_hook();
 	if (cpu_wait)
 		(*cpu_wait)();
 	else

commit 49f2ec91e14ce9bb20fdac88a38243129f3261c3
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Tue May 21 10:53:37 2013 +0200

    MIPS: Consolidate idle loop / WAIT instruction support in a single file.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/idle.c b/arch/mips/kernel/idle.c
new file mode 100644
index 000000000000..1e9d9383d49f
--- /dev/null
+++ b/arch/mips/kernel/idle.c
@@ -0,0 +1,232 @@
+/*
+ * MIPS idle loop and WAIT instruction support.
+ *
+ * Copyright (C) xxxx  the Anonymous
+ * Copyright (C) 1994 - 2006 Ralf Baechle
+ * Copyright (C) 2003, 2004  Maciej W. Rozycki
+ * Copyright (C) 2001, 2004, 2011, 2012	 MIPS Technologies, Inc.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version
+ * 2 of the License, or (at your option) any later version.
+ */
+#include <linux/export.h>
+#include <linux/init.h>
+#include <linux/irqflags.h>
+#include <linux/printk.h>
+#include <linux/sched.h>
+#include <asm/cpu.h>
+#include <asm/cpu-info.h>
+#include <asm/mipsregs.h>
+
+/*
+ * Not all of the MIPS CPUs have the "wait" instruction available. Moreover,
+ * the implementation of the "wait" feature differs between CPU families. This
+ * points to the function that implements CPU specific wait.
+ * The wait instruction stops the pipeline and reduces the power consumption of
+ * the CPU very much.
+ */
+void (*cpu_wait)(void);
+EXPORT_SYMBOL(cpu_wait);
+
+static void r3081_wait(void)
+{
+	unsigned long cfg = read_c0_conf();
+	write_c0_conf(cfg | R30XX_CONF_HALT);
+}
+
+static void r39xx_wait(void)
+{
+	local_irq_disable();
+	if (!need_resched())
+		write_c0_conf(read_c0_conf() | TX39_CONF_HALT);
+	local_irq_enable();
+}
+
+extern void r4k_wait(void);
+
+/*
+ * This variant is preferable as it allows testing need_resched and going to
+ * sleep depending on the outcome atomically.  Unfortunately the "It is
+ * implementation-dependent whether the pipeline restarts when a non-enabled
+ * interrupt is requested" restriction in the MIPS32/MIPS64 architecture makes
+ * using this version a gamble.
+ */
+void r4k_wait_irqoff(void)
+{
+	local_irq_disable();
+	if (!need_resched())
+		__asm__("	.set	push		\n"
+			"	.set	mips3		\n"
+			"	wait			\n"
+			"	.set	pop		\n");
+	local_irq_enable();
+	__asm__("	.globl __pastwait	\n"
+		"__pastwait:			\n");
+}
+
+/*
+ * The RM7000 variant has to handle erratum 38.	 The workaround is to not
+ * have any pending stores when the WAIT instruction is executed.
+ */
+static void rm7k_wait_irqoff(void)
+{
+	local_irq_disable();
+	if (!need_resched())
+		__asm__(
+		"	.set	push					\n"
+		"	.set	mips3					\n"
+		"	.set	noat					\n"
+		"	mfc0	$1, $12					\n"
+		"	sync						\n"
+		"	mtc0	$1, $12		# stalls until W stage	\n"
+		"	wait						\n"
+		"	mtc0	$1, $12		# stalls until W stage	\n"
+		"	.set	pop					\n");
+	local_irq_enable();
+}
+
+/*
+ * The Au1xxx wait is available only if using 32khz counter or
+ * external timer source, but specifically not CP0 Counter.
+ * alchemy/common/time.c may override cpu_wait!
+ */
+static void au1k_wait(void)
+{
+	__asm__("	.set	mips3			\n"
+		"	cache	0x14, 0(%0)		\n"
+		"	cache	0x14, 32(%0)		\n"
+		"	sync				\n"
+		"	nop				\n"
+		"	wait				\n"
+		"	nop				\n"
+		"	nop				\n"
+		"	nop				\n"
+		"	nop				\n"
+		"	.set	mips0			\n"
+		: : "r" (au1k_wait));
+}
+
+static int __initdata nowait;
+
+static int __init wait_disable(char *s)
+{
+	nowait = 1;
+
+	return 1;
+}
+
+__setup("nowait", wait_disable);
+
+void __init check_wait(void)
+{
+	struct cpuinfo_mips *c = &current_cpu_data;
+
+	if (nowait) {
+		printk("Wait instruction disabled.\n");
+		return;
+	}
+
+	switch (c->cputype) {
+	case CPU_R3081:
+	case CPU_R3081E:
+		cpu_wait = r3081_wait;
+		break;
+	case CPU_TX3927:
+		cpu_wait = r39xx_wait;
+		break;
+	case CPU_R4200:
+/*	case CPU_R4300: */
+	case CPU_R4600:
+	case CPU_R4640:
+	case CPU_R4650:
+	case CPU_R4700:
+	case CPU_R5000:
+	case CPU_R5500:
+	case CPU_NEVADA:
+	case CPU_4KC:
+	case CPU_4KEC:
+	case CPU_4KSC:
+	case CPU_5KC:
+	case CPU_25KF:
+	case CPU_PR4450:
+	case CPU_BMIPS3300:
+	case CPU_BMIPS4350:
+	case CPU_BMIPS4380:
+	case CPU_BMIPS5000:
+	case CPU_CAVIUM_OCTEON:
+	case CPU_CAVIUM_OCTEON_PLUS:
+	case CPU_CAVIUM_OCTEON2:
+	case CPU_JZRISC:
+	case CPU_LOONGSON1:
+	case CPU_XLR:
+	case CPU_XLP:
+		cpu_wait = r4k_wait;
+		break;
+
+	case CPU_RM7000:
+		cpu_wait = rm7k_wait_irqoff;
+		break;
+
+	case CPU_M14KC:
+	case CPU_M14KEC:
+	case CPU_24K:
+	case CPU_34K:
+	case CPU_1004K:
+		cpu_wait = r4k_wait;
+		if (read_c0_config7() & MIPS_CONF7_WII)
+			cpu_wait = r4k_wait_irqoff;
+		break;
+
+	case CPU_74K:
+		cpu_wait = r4k_wait;
+		if ((c->processor_id & 0xff) >= PRID_REV_ENCODE_332(2, 1, 0))
+			cpu_wait = r4k_wait_irqoff;
+		break;
+
+	case CPU_TX49XX:
+		cpu_wait = r4k_wait_irqoff;
+		break;
+	case CPU_ALCHEMY:
+		cpu_wait = au1k_wait;
+		break;
+	case CPU_20KC:
+		/*
+		 * WAIT on Rev1.0 has E1, E2, E3 and E16.
+		 * WAIT on Rev2.0 and Rev3.0 has E16.
+		 * Rev3.1 WAIT is nop, why bother
+		 */
+		if ((c->processor_id & 0xff) <= 0x64)
+			break;
+
+		/*
+		 * Another rev is incremeting c0_count at a reduced clock
+		 * rate while in WAIT mode.  So we basically have the choice
+		 * between using the cp0 timer as clocksource or avoiding
+		 * the WAIT instruction.  Until more details are known,
+		 * disable the use of WAIT for 20Kc entirely.
+		   cpu_wait = r4k_wait;
+		 */
+		break;
+	case CPU_RM9000:
+		if ((c->processor_id & 0x00ff) >= 0x40)
+			cpu_wait = r4k_wait;
+		break;
+	default:
+		break;
+	}
+}
+
+void arch_cpu_idle(void)
+{
+#ifdef CONFIG_MIPS_MT_SMTC
+	extern void smtc_idle_loop_hook(void);
+
+	smtc_idle_loop_hook();
+#endif
+	if (cpu_wait)
+		(*cpu_wait)();
+	else
+		local_irq_enable();
+}
