commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index 7c7c902249f2..f2e72094051b 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Stack trace management functions
  *

commit 68db0cf10678630d286f4bbbbdfa102951a35faa
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:37 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/task_stack.h>
    
    We are going to split <linux/sched/task_stack.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/task_stack.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index 986f910961d9..7c7c902249f2 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -5,6 +5,7 @@
  */
 #include <linux/sched.h>
 #include <linux/sched/debug.h>
+#include <linux/sched/task_stack.h>
 #include <linux/stacktrace.h>
 #include <linux/export.h>
 #include <asm/stacktrace.h>

commit b17b01533b719e9949e437abf66436a875739b40
Author: Ingo Molnar <mingo@kernel.org>
Date:   Wed Feb 8 18:51:35 2017 +0100

    sched/headers: Prepare for new header dependencies before moving code to <linux/sched/debug.h>
    
    We are going to split <linux/sched/debug.h> out of <linux/sched.h>, which
    will have to be picked up from other headers and a couple of .c files.
    
    Create a trivial placeholder <linux/sched/debug.h> file that just
    maps to <linux/sched.h> to make this patch obviously correct and
    bisectable.
    
    Include the new header in the files that are going to need it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Mike Galbraith <efault@gmx.de>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-kernel@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index 506021f62549..986f910961d9 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -4,6 +4,7 @@
  *  Copyright (C) 2006 Atsushi Nemoto <anemo@mba.ocn.ne.jp>
  */
 #include <linux/sched.h>
+#include <linux/sched/debug.h>
 #include <linux/stacktrace.h>
 #include <linux/export.h>
 #include <asm/stacktrace.h>

commit e1e1611598148e03c6d65e6c23338f4ff2cee71e
Author: Aaro Koskinen <aaro.koskinen@nokia.com>
Date:   Fri Oct 23 15:39:02 2015 +0300

    MIPS: Add LATENCYTOP support
    
    Add LATENCYTOP support for MIPS. Tested on OCTEON.
    
    Signed-off-by: Aaro Koskinen <aaro.koskinen@nokia.com>
    Cc: linux-mips@linux-mips.org
    Patchwork: https://patchwork.linux-mips.org/patch/11353/
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index 1ba775d24d38..506021f62549 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -12,14 +12,15 @@
  * Save stack-backtrace addresses into a stack_trace buffer:
  */
 static void save_raw_context_stack(struct stack_trace *trace,
-	unsigned long reg29)
+	unsigned long reg29, int savesched)
 {
 	unsigned long *sp = (unsigned long *)reg29;
 	unsigned long addr;
 
 	while (!kstack_end(sp)) {
 		addr = *sp++;
-		if (__kernel_text_address(addr)) {
+		if (__kernel_text_address(addr) &&
+		    (savesched || !in_sched_functions(addr))) {
 			if (trace->skip > 0)
 				trace->skip--;
 			else
@@ -31,7 +32,7 @@ static void save_raw_context_stack(struct stack_trace *trace,
 }
 
 static void save_context_stack(struct stack_trace *trace,
-	struct task_struct *tsk, struct pt_regs *regs)
+	struct task_struct *tsk, struct pt_regs *regs, int savesched)
 {
 	unsigned long sp = regs->regs[29];
 #ifdef CONFIG_KALLSYMS
@@ -43,20 +44,22 @@ static void save_context_stack(struct stack_trace *trace,
 			(unsigned long)task_stack_page(tsk);
 		if (stack_page && sp >= stack_page &&
 		    sp <= stack_page + THREAD_SIZE - 32)
-			save_raw_context_stack(trace, sp);
+			save_raw_context_stack(trace, sp, savesched);
 		return;
 	}
 	do {
-		if (trace->skip > 0)
-			trace->skip--;
-		else
-			trace->entries[trace->nr_entries++] = pc;
-		if (trace->nr_entries >= trace->max_entries)
-			break;
+		if (savesched || !in_sched_functions(pc)) {
+			if (trace->skip > 0)
+				trace->skip--;
+			else
+				trace->entries[trace->nr_entries++] = pc;
+			if (trace->nr_entries >= trace->max_entries)
+				break;
+		}
 		pc = unwind_stack(tsk, &sp, pc, &ra);
 	} while (pc);
 #else
-	save_raw_context_stack(trace, sp);
+	save_raw_context_stack(trace, sp, savesched);
 #endif
 }
 
@@ -82,6 +85,6 @@ void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 		regs->cp0_epc = tsk->thread.reg31;
 	} else
 		prepare_frametrace(regs);
-	save_context_stack(trace, tsk, regs);
+	save_context_stack(trace, tsk, regs, tsk == current);
 }
 EXPORT_SYMBOL_GPL(save_stack_trace_tsk);

commit 73bc256d47a23272ce1dd50b4de64a0ff23d01f1
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Sat Jul 23 16:30:40 2011 -0400

    mips: migrate core kernel file from module.h --> export.h
    
    These files are not modules, but were including module.h only for
    EXPORT_SYMBOL and/or THIS_MODULE.  Now that we have the lightweight
    export.h, use it in these kinds of cases.
    
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index d52ff77baf3f..1ba775d24d38 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -5,7 +5,7 @@
  */
 #include <linux/sched.h>
 #include <linux/stacktrace.h>
-#include <linux/module.h>
+#include <linux/export.h>
 #include <asm/stacktrace.h>
 
 /*

commit 49316cbf0a9875f102f98dc8b7c80cfa142e33cf
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Mon Jul 6 09:13:17 2009 +0100

    MIPS: Eleminate filenames from comments
    
    They tend to get not updated when files are moved around or copied and
    lack any obvious use.  While at it zap some only too obvious comments and
    as per Shinya's suggestion, add a copyright header to extable.c.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Acked-by: Shinya Kuribayashi <shinya.kuribayashi@necel.com>
    Acked-by: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index 58f5cd76c8c3..d52ff77baf3f 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -1,6 +1,4 @@
 /*
- * arch/mips/kernel/stacktrace.c
- *
  * Stack trace management functions
  *
  *  Copyright (C) 2006 Atsushi Nemoto <anemo@mba.ocn.ne.jp>

commit 2ec220e27f5040aec1e88901c1b6ea3d135787ad
Author: Ken Chen <kenchen@google.com>
Date:   Mon Nov 10 11:26:08 2008 +0300

    proc: add /proc/*/stack
    
    /proc/*/stack adds the ability to query a task's stack trace. It is more
    useful than /proc/*/wchan as it provides full stack trace instead of single
    depth. Example output:
    
            $ cat /proc/self/stack
            [<c010a271>] save_stack_trace_tsk+0x17/0x35
            [<c01827b4>] proc_pid_stack+0x4a/0x76
            [<c018312d>] proc_single_show+0x4a/0x5e
            [<c016bdec>] seq_read+0xf3/0x29f
            [<c015a004>] vfs_read+0x6d/0x91
            [<c015a0c1>] sys_read+0x3b/0x60
            [<c0102eda>] syscall_call+0x7/0xb
            [<ffffffff>] 0xffffffff
    
    [add save_stack_trace_tsk() on mips, ACK Ralf --adobriyan]
    Signed-off-by: Ken Chen <kenchen@google.com>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index 0632e2a849c0..58f5cd76c8c3 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -32,7 +32,8 @@ static void save_raw_context_stack(struct stack_trace *trace,
 	}
 }
 
-static void save_context_stack(struct stack_trace *trace, struct pt_regs *regs)
+static void save_context_stack(struct stack_trace *trace,
+	struct task_struct *tsk, struct pt_regs *regs)
 {
 	unsigned long sp = regs->regs[29];
 #ifdef CONFIG_KALLSYMS
@@ -41,7 +42,7 @@ static void save_context_stack(struct stack_trace *trace, struct pt_regs *regs)
 
 	if (raw_show_trace || !__kernel_text_address(pc)) {
 		unsigned long stack_page =
-			(unsigned long)task_stack_page(current);
+			(unsigned long)task_stack_page(tsk);
 		if (stack_page && sp >= stack_page &&
 		    sp <= stack_page + THREAD_SIZE - 32)
 			save_raw_context_stack(trace, sp);
@@ -54,7 +55,7 @@ static void save_context_stack(struct stack_trace *trace, struct pt_regs *regs)
 			trace->entries[trace->nr_entries++] = pc;
 		if (trace->nr_entries >= trace->max_entries)
 			break;
-		pc = unwind_stack(current, &sp, pc, &ra);
+		pc = unwind_stack(tsk, &sp, pc, &ra);
 	} while (pc);
 #else
 	save_raw_context_stack(trace, sp);
@@ -65,13 +66,24 @@ static void save_context_stack(struct stack_trace *trace, struct pt_regs *regs)
  * Save stack-backtrace addresses into a stack_trace buffer.
  */
 void save_stack_trace(struct stack_trace *trace)
+{
+	save_stack_trace_tsk(current, trace);
+}
+EXPORT_SYMBOL_GPL(save_stack_trace);
+
+void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)
 {
 	struct pt_regs dummyregs;
 	struct pt_regs *regs = &dummyregs;
 
 	WARN_ON(trace->nr_entries || !trace->max_entries);
 
-	prepare_frametrace(regs);
-	save_context_stack(trace, regs);
+	if (tsk != current) {
+		regs->regs[29] = tsk->thread.reg29;
+		regs->regs[31] = 0;
+		regs->cp0_epc = tsk->thread.reg31;
+	} else
+		prepare_frametrace(regs);
+	save_context_stack(trace, tsk, regs);
 }
-EXPORT_SYMBOL_GPL(save_stack_trace);
+EXPORT_SYMBOL_GPL(save_stack_trace_tsk);

commit 36bd53d07243ae83c1b73bae549086cea2252854
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Wed Jul 23 00:58:13 2008 -0700

    arch/mips/kernel/stacktrace.c: Heiko can't type
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index 702e2e92a1ca..0632e2a849c0 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -7,7 +7,7 @@
  */
 #include <linux/sched.h>
 #include <linux/stacktrace.h>
-#include <linux/module.h
+#include <linux/module.h>
 #include <asm/stacktrace.h>
 
 /*

commit 8b95d9172be7146c87e7a998310ce2919c851adc
Author: Heiko Carstens <heiko.carstens@de.ibm.com>
Date:   Mon Jul 14 23:32:32 2008 +0200

    fix core/stacktrace changes on avr32, mips, sh
    
    Fixes this type of problem:
    
      CC      arch/s390/kernel/stacktrace.o
    arch/s390/kernel/stacktrace.c:84: warning: data definition has no type or storage class
    arch/s390/kernel/stacktrace.c:84: warning: type defaults to 'int' in declaration of 'EXPORT_SYMBOL_GPL'
    arch/s390/kernel/stacktrace.c:84: warning: parameter names (without types) in function declaration
    arch/s390/kernel/stacktrace.c:97: warning: data definition has no type or storage class
    arch/s390/kernel/stacktrace.c:97: warning: type defaults to 'int' in declaration of 'EXPORT_SYMBOL_GPL'
    arch/s390/kernel/stacktrace.c:97: warning: parameter names (without types) in function declaration
    
    caused by "stacktrace: export save_stack_trace[_tsk]"
    
    Signed-off-by: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index 5eb4681a73d2..702e2e92a1ca 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -7,6 +7,7 @@
  */
 #include <linux/sched.h>
 #include <linux/stacktrace.h>
+#include <linux/module.h
 #include <asm/stacktrace.h>
 
 /*

commit 7b4c9505f2fd82b117dd015b561f723b9a5dab79
Author: Ingo Molnar <mingo@elte.hu>
Date:   Thu Jul 3 09:17:55 2008 +0200

    stacktrace: export save_stack_trace[_tsk]
    
    Andrew Morton reported this against linux-next:
    
    ERROR: ".save_stack_trace" [tests/backtracetest.ko] undefined!
    
    Reported-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ingo Molnar <mingo@elte.hu>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index ebd9db8d1ece..5eb4681a73d2 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -73,3 +73,4 @@ void save_stack_trace(struct stack_trace *trace)
 	prepare_frametrace(regs);
 	save_context_stack(trace, regs);
 }
+EXPORT_SYMBOL_GPL(save_stack_trace);

commit ab1b6f03a10ba1f5638188ab06bf46e33ac3a160
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 8 00:23:29 2007 -0700

    simplify the stacktrace code
    
    Simplify the stacktrace code:
    
     - remove the unused task argument to save_stack_trace, it's always
       current
     - remove the all_contexts flag, it's alwasy 0
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Cc: Paul Mundt <lethal@linux-sh.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Andi Kleen <ak@suse.de>
    Cc: Akinobu Mita <akinobu.mita@gmail.com>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index a586aba337a7..ebd9db8d1ece 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -31,8 +31,7 @@ static void save_raw_context_stack(struct stack_trace *trace,
 	}
 }
 
-static void save_context_stack(struct stack_trace *trace,
-	struct task_struct *task, struct pt_regs *regs)
+static void save_context_stack(struct stack_trace *trace, struct pt_regs *regs)
 {
 	unsigned long sp = regs->regs[29];
 #ifdef CONFIG_KALLSYMS
@@ -41,7 +40,7 @@ static void save_context_stack(struct stack_trace *trace,
 
 	if (raw_show_trace || !__kernel_text_address(pc)) {
 		unsigned long stack_page =
-			(unsigned long)task_stack_page(task);
+			(unsigned long)task_stack_page(current);
 		if (stack_page && sp >= stack_page &&
 		    sp <= stack_page + THREAD_SIZE - 32)
 			save_raw_context_stack(trace, sp);
@@ -54,7 +53,7 @@ static void save_context_stack(struct stack_trace *trace,
 			trace->entries[trace->nr_entries++] = pc;
 		if (trace->nr_entries >= trace->max_entries)
 			break;
-		pc = unwind_stack(task, &sp, pc, &ra);
+		pc = unwind_stack(current, &sp, pc, &ra);
 	} while (pc);
 #else
 	save_raw_context_stack(trace, sp);
@@ -64,22 +63,13 @@ static void save_context_stack(struct stack_trace *trace,
 /*
  * Save stack-backtrace addresses into a stack_trace buffer.
  */
-void save_stack_trace(struct stack_trace *trace, struct task_struct *task)
+void save_stack_trace(struct stack_trace *trace)
 {
 	struct pt_regs dummyregs;
 	struct pt_regs *regs = &dummyregs;
 
 	WARN_ON(trace->nr_entries || !trace->max_entries);
 
-	if (task && task != current) {
-		regs->regs[29] = task->thread.reg29;
-		regs->regs[31] = 0;
-		regs->cp0_epc = task->thread.reg31;
-	} else {
-		if (!task)
-			task = current;
-		prepare_frametrace(regs);
-	}
-
-	save_context_stack(trace, task, regs);
+	prepare_frametrace(regs);
+	save_context_stack(trace, regs);
 }

commit eea32d4c6e272b6c324c8c22df4c28274fcb5a21
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Mon Oct 16 22:48:49 2006 +0900

    [MIPS] save_context_stack fix
    
    CONFIG_KALLSYMS=n case is obviously wrong, though it is harmless since
    CONFIG_KALLSYMS is always enabled with CONFIG_STACKTRACE for now.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index 4aabe526a68e..a586aba337a7 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -57,7 +57,7 @@ static void save_context_stack(struct stack_trace *trace,
 		pc = unwind_stack(task, &sp, pc, &ra);
 	} while (pc);
 #else
-	save_raw_context_stack(sp);
+	save_raw_context_stack(trace, sp);
 #endif
 }
 

commit 1924600cdb3143cdcc32b6fa43325739503659b9
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Fri Sep 29 18:02:51 2006 +0900

    [MIPS] Make unwind_stack() can dig into interrupted context
    
    If the PC was ret_from_irq or ret_from_exception, there will be no
    more normal stackframe.  Instead of stopping the unwinding, use PC and
    RA saved by an exception handler to continue unwinding into the
    interrupted context.  This also simplifies the CONFIG_STACKTRACE code.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index 676e6f69d24b..4aabe526a68e 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -31,23 +31,21 @@ static void save_raw_context_stack(struct stack_trace *trace,
 	}
 }
 
-static struct pt_regs * save_context_stack(struct stack_trace *trace,
+static void save_context_stack(struct stack_trace *trace,
 	struct task_struct *task, struct pt_regs *regs)
 {
 	unsigned long sp = regs->regs[29];
 #ifdef CONFIG_KALLSYMS
 	unsigned long ra = regs->regs[31];
 	unsigned long pc = regs->cp0_epc;
-	unsigned long stack_page =
-		(unsigned long)task_stack_page(task);
-	extern void ret_from_irq(void);
-	extern void ret_from_exception(void);
 
 	if (raw_show_trace || !__kernel_text_address(pc)) {
+		unsigned long stack_page =
+			(unsigned long)task_stack_page(task);
 		if (stack_page && sp >= stack_page &&
 		    sp <= stack_page + THREAD_SIZE - 32)
 			save_raw_context_stack(trace, sp);
-		return NULL;
+		return;
 	}
 	do {
 		if (trace->skip > 0)
@@ -56,25 +54,11 @@ static struct pt_regs * save_context_stack(struct stack_trace *trace,
 			trace->entries[trace->nr_entries++] = pc;
 		if (trace->nr_entries >= trace->max_entries)
 			break;
-		/*
-		 * If we reached the bottom of interrupt context,
-		 * return saved pt_regs.
-		 */
-		if (pc == (unsigned long)ret_from_irq ||
-		    pc == (unsigned long)ret_from_exception) {
-			if (stack_page && sp >= stack_page &&
-			    sp <= stack_page + THREAD_SIZE - 32)
-				return (struct pt_regs *)sp;
-			break;
-		}
-		pc = unwind_stack(task, &sp, pc, ra);
-		ra = 0;
+		pc = unwind_stack(task, &sp, pc, &ra);
 	} while (pc);
 #else
 	save_raw_context_stack(sp);
 #endif
-
-	return NULL;
 }
 
 /*
@@ -97,9 +81,5 @@ void save_stack_trace(struct stack_trace *trace, struct task_struct *task)
 		prepare_frametrace(regs);
 	}
 
-	while (1) {
-		regs = save_context_stack(trace, task, regs);
-		if (!regs || trace->nr_entries >= trace->max_entries)
-			break;
-	}
+	save_context_stack(trace, task, regs);
 }

commit 23126692e30ec22760e0ef932c3c2fff00d440bb
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Thu Sep 28 19:15:33 2006 +0900

    [MIPS] Stacktrace build-fix and improvement
    
    Fix build error due to stacktrace API change.  Now save_stack_trace()
    tries to save all kernel context, including interrupts and exception.
    Also some asm code are changed a bit so that we can detect the end of
    current context easily.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
index f851d0cc245f..676e6f69d24b 100644
--- a/arch/mips/kernel/stacktrace.c
+++ b/arch/mips/kernel/stacktrace.c
@@ -13,7 +13,7 @@
  * Save stack-backtrace addresses into a stack_trace buffer:
  */
 static void save_raw_context_stack(struct stack_trace *trace,
-	unsigned int skip, unsigned long reg29)
+	unsigned long reg29)
 {
 	unsigned long *sp = (unsigned long *)reg29;
 	unsigned long addr;
@@ -21,10 +21,10 @@ static void save_raw_context_stack(struct stack_trace *trace,
 	while (!kstack_end(sp)) {
 		addr = *sp++;
 		if (__kernel_text_address(addr)) {
-			if (!skip)
-				trace->entries[trace->nr_entries++] = addr;
+			if (trace->skip > 0)
+				trace->skip--;
 			else
-				skip--;
+				trace->entries[trace->nr_entries++] = addr;
 			if (trace->nr_entries >= trace->max_entries)
 				break;
 		}
@@ -32,37 +32,40 @@ static void save_raw_context_stack(struct stack_trace *trace,
 }
 
 static struct pt_regs * save_context_stack(struct stack_trace *trace,
-	unsigned int skip, struct task_struct *task, struct pt_regs *regs)
+	struct task_struct *task, struct pt_regs *regs)
 {
 	unsigned long sp = regs->regs[29];
 #ifdef CONFIG_KALLSYMS
 	unsigned long ra = regs->regs[31];
 	unsigned long pc = regs->cp0_epc;
+	unsigned long stack_page =
+		(unsigned long)task_stack_page(task);
 	extern void ret_from_irq(void);
+	extern void ret_from_exception(void);
 
 	if (raw_show_trace || !__kernel_text_address(pc)) {
-		save_raw_context_stack(trace, skip, sp);
+		if (stack_page && sp >= stack_page &&
+		    sp <= stack_page + THREAD_SIZE - 32)
+			save_raw_context_stack(trace, sp);
 		return NULL;
 	}
 	do {
-		if (!skip)
-			trace->entries[trace->nr_entries++] = pc;
+		if (trace->skip > 0)
+			trace->skip--;
 		else
-			skip--;
+			trace->entries[trace->nr_entries++] = pc;
 		if (trace->nr_entries >= trace->max_entries)
 			break;
 		/*
 		 * If we reached the bottom of interrupt context,
 		 * return saved pt_regs.
 		 */
-		if (pc == (unsigned long)ret_from_irq) {
-			unsigned long stack_page =
-				(unsigned long)task_stack_page(task);
-			if (!stack_page ||
-			    sp < stack_page ||
-			    sp > stack_page + THREAD_SIZE - 32)
-				break;
-			return (struct pt_regs *)sp;
+		if (pc == (unsigned long)ret_from_irq ||
+		    pc == (unsigned long)ret_from_exception) {
+			if (stack_page && sp >= stack_page &&
+			    sp <= stack_page + THREAD_SIZE - 32)
+				return (struct pt_regs *)sp;
+			break;
 		}
 		pc = unwind_stack(task, &sp, pc, ra);
 		ra = 0;
@@ -76,12 +79,8 @@ static struct pt_regs * save_context_stack(struct stack_trace *trace,
 
 /*
  * Save stack-backtrace addresses into a stack_trace buffer.
- * If all_contexts is set, all contexts (hardirq, softirq and process)
- * are saved. If not set then only the current context is saved.
  */
-void save_stack_trace(struct stack_trace *trace,
-		      struct task_struct *task, int all_contexts,
-		      unsigned int skip)
+void save_stack_trace(struct stack_trace *trace, struct task_struct *task)
 {
 	struct pt_regs dummyregs;
 	struct pt_regs *regs = &dummyregs;
@@ -99,13 +98,8 @@ void save_stack_trace(struct stack_trace *trace,
 	}
 
 	while (1) {
-		regs = save_context_stack(trace, skip, task, regs);
-		if (!all_contexts || !regs ||
-		    trace->nr_entries >= trace->max_entries)
-			break;
-		trace->entries[trace->nr_entries++] = ULONG_MAX;
-		if (trace->nr_entries >= trace->max_entries)
+		regs = save_context_stack(trace, task, regs);
+		if (!regs || trace->nr_entries >= trace->max_entries)
 			break;
-		skip = 0;
 	}
 }

commit 1df0f0ff7e56f6dcb1351b9490d55ebf91ff4bd8
Author: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
Date:   Tue Sep 26 23:44:01 2006 +0900

    [MIPS] lockdep: Add STACKTRACE_SUPPORT and enable LOCKDEP_SUPPORT
    
    Implement stacktrace interface by using unwind_stack() and enable lockdep
    support in Kconfig.
    
    Signed-off-by: Atsushi Nemoto <anemo@mba.ocn.ne.jp>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/arch/mips/kernel/stacktrace.c b/arch/mips/kernel/stacktrace.c
new file mode 100644
index 000000000000..f851d0cc245f
--- /dev/null
+++ b/arch/mips/kernel/stacktrace.c
@@ -0,0 +1,111 @@
+/*
+ * arch/mips/kernel/stacktrace.c
+ *
+ * Stack trace management functions
+ *
+ *  Copyright (C) 2006 Atsushi Nemoto <anemo@mba.ocn.ne.jp>
+ */
+#include <linux/sched.h>
+#include <linux/stacktrace.h>
+#include <asm/stacktrace.h>
+
+/*
+ * Save stack-backtrace addresses into a stack_trace buffer:
+ */
+static void save_raw_context_stack(struct stack_trace *trace,
+	unsigned int skip, unsigned long reg29)
+{
+	unsigned long *sp = (unsigned long *)reg29;
+	unsigned long addr;
+
+	while (!kstack_end(sp)) {
+		addr = *sp++;
+		if (__kernel_text_address(addr)) {
+			if (!skip)
+				trace->entries[trace->nr_entries++] = addr;
+			else
+				skip--;
+			if (trace->nr_entries >= trace->max_entries)
+				break;
+		}
+	}
+}
+
+static struct pt_regs * save_context_stack(struct stack_trace *trace,
+	unsigned int skip, struct task_struct *task, struct pt_regs *regs)
+{
+	unsigned long sp = regs->regs[29];
+#ifdef CONFIG_KALLSYMS
+	unsigned long ra = regs->regs[31];
+	unsigned long pc = regs->cp0_epc;
+	extern void ret_from_irq(void);
+
+	if (raw_show_trace || !__kernel_text_address(pc)) {
+		save_raw_context_stack(trace, skip, sp);
+		return NULL;
+	}
+	do {
+		if (!skip)
+			trace->entries[trace->nr_entries++] = pc;
+		else
+			skip--;
+		if (trace->nr_entries >= trace->max_entries)
+			break;
+		/*
+		 * If we reached the bottom of interrupt context,
+		 * return saved pt_regs.
+		 */
+		if (pc == (unsigned long)ret_from_irq) {
+			unsigned long stack_page =
+				(unsigned long)task_stack_page(task);
+			if (!stack_page ||
+			    sp < stack_page ||
+			    sp > stack_page + THREAD_SIZE - 32)
+				break;
+			return (struct pt_regs *)sp;
+		}
+		pc = unwind_stack(task, &sp, pc, ra);
+		ra = 0;
+	} while (pc);
+#else
+	save_raw_context_stack(sp);
+#endif
+
+	return NULL;
+}
+
+/*
+ * Save stack-backtrace addresses into a stack_trace buffer.
+ * If all_contexts is set, all contexts (hardirq, softirq and process)
+ * are saved. If not set then only the current context is saved.
+ */
+void save_stack_trace(struct stack_trace *trace,
+		      struct task_struct *task, int all_contexts,
+		      unsigned int skip)
+{
+	struct pt_regs dummyregs;
+	struct pt_regs *regs = &dummyregs;
+
+	WARN_ON(trace->nr_entries || !trace->max_entries);
+
+	if (task && task != current) {
+		regs->regs[29] = task->thread.reg29;
+		regs->regs[31] = 0;
+		regs->cp0_epc = task->thread.reg31;
+	} else {
+		if (!task)
+			task = current;
+		prepare_frametrace(regs);
+	}
+
+	while (1) {
+		regs = save_context_stack(trace, skip, task, regs);
+		if (!all_contexts || !regs ||
+		    trace->nr_entries >= trace->max_entries)
+			break;
+		trace->entries[trace->nr_entries++] = ULONG_MAX;
+		if (trace->nr_entries >= trace->max_entries)
+			break;
+		skip = 0;
+	}
+}
